{"ver":"0.1","info":{"id":"WlySzG","date":"1582938331","viewed":52,"name":"Meditating Astronaut","username":"henrybergstrom","description":"Found a nice picture in a magazine I wanted to recreate in a shader.. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Meditating Astronaut\n// TODO: SKY\n#define MAX_STEP 100\n#define EPSILON  0.003\n#define STEP_SIZE 0.1\n#define MAX_DIST 30.\n#define ENABLE_ROTATION 0\n\n#define TYPE_WALL 0.0\n#define TYPE_SEAT 1.0\n#define TYPE_PERSON 2.0\n#define TYPE_CLOUD 2.0\n\n\n//// Points ////\n// Head\nconst vec3 headPos =        vec3(           0.00,              0.31,            1.00);\nconst float headRadius = 0.1;\n// Body\nconst vec3 bodyA =          vec3(headPos.x + 0.00, headPos.y - 0.10, headPos.z + 0.00);\nconst vec3 bodyB =          vec3(  bodyA.x + 0.00,   bodyA.y - 0.28,   bodyA.z + 0.00);\nconst float bodyRadius = 0.08;\n// Arms\nconst vec3 armLeftA =       vec3(       headPos.x - 0.10,        headPos.y - 0.12,        headPos.z + 0.00);\nconst vec3 armLeftB =       vec3(         bodyA.x - 0.18,          bodyA.y - 0.20,          bodyA.z + 0.00);\nconst vec3 armLeftLowerA =  vec3(      armLeftB.x + 0.00,       armLeftB.y - 0.01,       armLeftB.z + 0.00);\nconst vec3 armLeftLowerB =  vec3( armLeftLowerA.x - 0.08,  armLeftLowerA.y + 0.08,  armLeftLowerA.z - 0.06);\n\nconst vec3 armRightA =      vec3(       headPos.x + 0.10,        headPos.y - 0.12,        headPos.z + 0.00);\nconst vec3 armRightB =      vec3(         bodyA.x + 0.18,          bodyA.y - 0.20,          bodyA.z + 0.00);\nconst vec3 armRightLowerA = vec3(     armRightB.x + 0.00,      armRightB.y - 0.01,      armRightB.z + 0.00);\nconst vec3 armRightLowerB = vec3(armRightLowerA.x + 0.08, armRightLowerA.y + 0.08, armRightLowerA.z - 0.06);\n\n// Legs\nconst vec3 legLeftA =       vec3(   bodyB.x + 0.00,      bodyB.y - 0.04, bodyB.z    - 0.02);\nconst vec3 legLeftB =       vec3(legLeftA.x + 0.20,   legLeftA.y + 0.04, legLeftA.z - 0.05);\nconst vec3 legLeftLowerA =  vec3(legLeftB.x + 0.01,   legLeftB.y + 0.00, legLeftB.z - 0.006);\nconst vec3 legLeftLowerB =  vec3(legLeftB.x - 0.14,   legLeftB.y - 0.10, legLeftB.z - 0.008);\n\nconst vec3 legRightA =      vec3(bodyB.x,               bodyB.y  - 0.04, bodyB.z     - 0.02);\nconst vec3 legRightB =      vec3(legRightA.x - 0.20, legRightA.y + 0.04, legRightA.z - 0.05);\nconst vec3 legRightLowerA = vec3(legRightB.x - 0.01, legRightB.y       , legRightB.z - 0.006);\nconst vec3 legRightLowerB = vec3(legRightB.x + 0.14, legRightB.y - 0.10, legRightB.z - 0.008);\n\n// Center of character\nconst vec3  CENTER        = vec3(headPos.x, headPos.y - 0.25, headPos.z);\nconst float HALF_WIDTH    = length(armRightB- armLeftB) * 0.5;\nconst float HALF_HEIGHT   = (length((headPos + headRadius) - (legRightLowerB - 0.036))) * 0.5;  \n\n\n//// Functions ////\nmat2 rotate(float angle) {\n\treturn mat2( cos(angle), -sin(angle), \n                 sin(angle), cos(angle));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdCapsule(vec3 ray, vec3 a, vec3 b, float r ) {\n  vec3 pa = ray - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(vec3 ray, vec2 sc, float ra, float rb) {\n  ray.x = abs(ray.x);\n  float k = (sc.y*ray.x>sc.x*ray.y) ? dot(ray.xy,sc) : length(ray.xy);\n  return sqrt( dot(ray,ray) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdSphere( vec3 ray, vec3 p, float s )\n{\n  return length(ray - p) - s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat head(vec3 ray) {\n    vec2 mse = iMouse.xy/iResolution.xy;\n    ray = ray - headPos;                // translate\n    ray.xz *= rotate(3.1415/2.0);\t\t// rotation\n    ray.xy *= rotate(-3.1415/2.0);\n    float d = sdCappedTorus(ray, vec2(0.31, -0.4), headRadius*0.11, headRadius);\n    return d;\n}\n\nfloat wrinkels(vec3 ray) {\n    float height = (ray.y-bodyA.y)/(bodyA.y - bodyB.y);\n    float width = (ray.x-bodyA.x)/(bodyRadius*2.);\n    float wWrink = 0.0005*sin(width *  122.);\n    float hWrink = 0.0005*sin(height * 121.);\n    return wWrink + hWrink;\n}\n\nfloat body(vec3 ray) {\n    float z = 1.5;\n    vec3 squash = vec3(1.0, 1.0, z);\n\tfloat d = sdCapsule(ray*squash, bodyA*squash, bodyB*squash, bodyRadius)/z;\n\n    return d + wrinkels(ray);\n}\n\nfloat arms(vec3 ray) {\n    float leftArm = sdCapsule(ray, armLeftA, armLeftB, 0.03);\n    float rightArm = sdCapsule(ray, armRightA, armRightB, 0.03);\n\n\treturn min(leftArm, rightArm) + wrinkels(ray);\n}\n\nfloat lowerArms(vec3 ray) {\n     float leftArmLower = sdCapsule(ray, armLeftLowerA, armLeftLowerB, 0.024);\n     float rightArmLower = sdCapsule(ray, armRightLowerA, armRightLowerB, 0.023);\n     return min(leftArmLower, rightArmLower) + wrinkels(ray);\n}\n\nfloat legs(vec3 ray) {\n    float legLeft = sdCapsule(ray, legLeftA, legLeftB, 0.036);\n    float leftArmLower = sdCapsule(ray, legLeftLowerA, legLeftLowerB, 0.031);\n\tfloat left = min(legLeft, leftArmLower);\n    \n    float rightleg = sdCapsule(ray, legRightA, legRightB, 0.036);\n    float rightlegLower = sdCapsule(ray, legRightLowerA, legRightLowerB, 0.031);\n\tfloat right = min(rightleg, rightlegLower);\n    \n    return min(left, right) + wrinkels(ray);\n}\n\n\n\nvec2 map(vec3 ray) {\n    float t = mod(iTime, 6.);\n    //vec2 res = vec2(0.);\n    vec3 qray = vec3(mod(ray.x, 3.), ray.y, mod(ray.z, 3.));\n    float sph = sdSphere(qray, vec3(1.40 + 0.1*sin(5.*t)/t, \n                                    -1.0 + abs(sin(0.5*t)),\n                                    2.5), 0.35);\n    float gro = ray.y + 0.75;\n    vec2 res = vec2(smin(gro, sph, 0.3), TYPE_WALL);\n    //res = vec2(smin(res.x, 15.0 - ray.z, 0.2), TYPE_WALL);\n    //res = vec2(smin(res.x, 3.4 + ray.x, 0.2 ), TYPE_WALL);\n    //res = vec2(smin(res.x, 3.4 - ray.x, 0.2 ), TYPE_WALL); \n    \n    \n    // Early exit (not sure if helping/working)\n    //float boundingSphere = min(d, sdSphere(ray, CENTER, HALF_HEIGHT));\n    //if(boundingSphere> d ) return d;\n    \n    \n    // Seat\n    float seatD = sdRoundedCylinder(ray - vec3(CENTER.x, -.55, CENTER.z), 0.15, 0.1, 0.05);\n    if (res.x > seatD) {\n    \tres = vec2(seatD, TYPE_SEAT);\n    }\n    \n    \n    // Head\n    float headD = head( ray + vec3(0., 0.08*sin(iTime + 0.11), 0.));\n    if (res.x > headD) {\n          res = vec2(headD, TYPE_PERSON);\n    }\n    \n    // Body\n    float bodyD = body(ray + vec3(0., 0.08*sin(iTime + 0.00), 0.));\n    if (res.x > bodyD) {\n    \tres = vec2(bodyD, TYPE_PERSON);\n    }\n\n    \n    // Arms\n    float armsD = arms(ray + vec3(0., 0.08*sin(iTime+0.12), 0.));\n    if (res.x > armsD) {\n    \tres = vec2(armsD, TYPE_PERSON);\n    }\n       \n    float lowerArmsD = lowerArms(ray + vec3(0., 0.08*sin(iTime+0.18), 0.));\n    if (res.x > lowerArmsD) {\n    \tres = vec2(lowerArmsD, TYPE_PERSON);\n    }\n    \n    // Legs\n\tfloat legsD = legs(ray + vec3(0., 0.08*sin(iTime+0.12), 0.));\n    if (res.x > legsD) {\n    \tres = vec2(legsD, TYPE_PERSON);\n    }\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    const vec2 h = vec2(EPSILON,0.);\n    float d = map(p).x;\n    return normalize( vec3(map(p+h.xyy).x - d,\n                           map(p+h.yxy).x - d,\n                           map(p+h.yyx).x - d) );\n\n}\n\n\nvec2 rayCast(vec3 ro, vec3 rd) {\n\tvec2 res = vec2(0.0);\n    vec2 closest;\n    for (int i = 0; i < MAX_STEP; i++) {\n    \tvec3 ray = ro + rd * res.x;\n        closest = map(ray);\n        res.x += closest.x;\n        res.y = closest.y;\n        \n        if (closest.x < EPSILON || res.x > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return res;\n    \n}\n\nfloat shadowCast(vec3 ro, vec3 rd, float mind, float maxd) {\n    float d = 0.;\n    for( float d=mind; d<maxd; )\n    {\n        float h = map(ro + rd*d).x;\n        if( h<EPSILON )\n            break;\n        d += h;\n    }\n    return d;\n}\n\nvec3 getColor(float type) {\n    vec3 color = vec3(0.);\n    if (type < TYPE_WALL + .5) {\n        color = vec3(.03, 0.15, 0.36);\n    } else if (type < TYPE_SEAT + .5) {\n        color = vec3(0.55, 0.35, 0.0);\n    } else if (type < TYPE_PERSON + .5) {\n        color = vec3(0.53, 0.51, 0.62);\n    } else if (type < TYPE_CLOUD + .5) {\n        color = vec3(0.83, 0.81, 0.2);\n    }\n    return color;\n}\n\nvec3 getLight(vec3 p, vec3 li, vec3 camDir, float material) {\n    // debug\n    vec2 mse = iMouse.xy/iResolution.xy;   \n    \n\tvec3 lightDir = normalize(p - li);\n    vec3 normal = getNormal(p);\n    float diff = clamp(dot(lightDir, -normal), 0.0, 1.0);\n    float spec = .6*max(dot(-camDir, reflect(lightDir, normal)), 0.);\n    \n    vec3 sunColor = vec3(0.12, 0.18, 0.17);\n    vec3 skyColor = vec3(0.11, 0.16, 0.24);\n    vec3 bouColor = mix(sunColor, skyColor, 0.5);\n    \n    // Shadow\n    vec3 almostP = p + 2.0 * normal * EPSILON;\n    float maxLength = length(li-(almostP));\n    float shadowD = smoothstep(0.0, maxLength, rayCast(almostP, li).x);\n    float shadowCoef = shadowD / maxLength;\n    \n    float skyDiff = clamp(dot(-lightDir, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float bouDiff = clamp(dot(lightDir, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n    sunColor *= diff * shadowCoef;\n    skyColor *= skyDiff * shadowCoef;\n    bouColor *= bouDiff * shadowCoef;\n    return getColor(material) * (diff + spec) + sunColor + skyColor + bouColor;\n}\n\nvec3 camera(vec2 uv, vec3 eye, vec3 target, float zoom) {\n    vec3 forward = normalize(target-eye),\n        right = normalize(cross(vec3(0,1,0), forward)),\n        up = cross(forward,right),\n        centerScreen = eye+forward*zoom,\n        intersection = centerScreen + uv.x*right + uv.y*up,\n        rayDir = normalize(intersection-eye);\n    return rayDir;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mse = iMouse.xy/iResolution.xy;\n    mse -= 0.5;\n    mse.y *= iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n\tvec3 ro = vec3(0.0, 0.0, -2.0);\n#if ENABLE_ROTATION\n    ro.xy *= rotate(2.0*3.14 + 6.28 * mse.x);\n    ro.yz *= rotate(-6.28 * mse.y);\n#endif\n    vec3 target = CENTER;\n    vec3 rd = camera(uv, ro, target, 1.0);\n\n\tvec2 res = rayCast(ro, rd);\n    \n    // Sky\n    vec3 SKY_COLOR = vec3(0.45, 0.66, 0.99);\n    vec3 HORIZON_COLOR = vec3(0.7, 0.75, 0.8);\n    vec3 col = SKY_COLOR - rd.y;\n    col = mix(col, HORIZON_COLOR, exp(-10.*rd.y));\n    \n    \n    vec2 st = rd.xz/max(rd.y, 0.0);\n    col += 0.3 * smoothstep(-0.5, 0.5, 0.5*(sin(st.x) + sin(st.y)));\n\n\n    \n    if (res.x < MAX_DIST) {\n    \tvec3 p = ro + rd * res.x;\n    \tcol = getLight(p, vec3(0.2, 0.96, -1.0), rd, res.y);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}