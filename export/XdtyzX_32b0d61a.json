{"ver":"0.1","info":{"id":"XdtyzX","date":"1519862543","viewed":430,"name":"Multiverse","username":"patu","description":"Reusing noise (\"stars\")  function from totally different shader. \nexperiment.\n\n","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// multiverse by Patu\n//\n// https://github.com/patuwwy/ShaderToy-Chrome-Plugin\n\n#define FOV 40.0\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n// Modified \"stars\" function from great shader of user Nimitz.\n// https://www.shadertoy.com/view/XsyGWV :\n// \"Very happy with this star function, cheap and smooth\"\nvec3 stars(in vec3 p)\n{\n    float res = 1000.;        \n\t\n    vec3 q = fract(p*(.15*res))-0.5;\n    vec3 id = floor(p*(.15*res));\n    vec2 rn = hash33(id).xy / 3.;\n    float c2 = 1.-smoothstep(0.,.73,length(q * .998));\n    c2 *= step(rn.x,.00+0.05);    \n\n    return abs(c2*c2*vec3(.57));\n}\n\nfloat map(vec3 p) {\n    return (stars(p * 0.009).r - .14) * .6;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    vec2 t = vec2(-.2, 0.);\n    for (int i = 0; i < 236; i++) {\n        float d = map(ro + rd * t.x);\n        if (abs(d) < 0.015) break;\n        t.x += d;         \n    }\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = .01;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist) * 1.;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p) {\n    const vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float mat) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001); \n    ld /= lDist; \n    float atten = 1. / (1.0 + lDist * 0.525+ lDist * lDist * .15);\n\n    float diff = max(dot(sn, ld), .3);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 14.0);\n    vec3 objCol = abs(sin(sp));\n    sceneCol += (objCol * (diff + 0.15) + abs(sin(sp)) * spec * 9.) * atten;\n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = \n        (fragCoord.xy - iResolution.xy * .5) / iResolution.y\n\t\t* tan(radians (FOV) / 2.0) * .75;\n    \n    float t = iTime,\n    \t  sk = sin(t * .2) * 1.0,\n       \t  ck = cos(t * .12) * 1.0;\n    \t\n    vec3 \n        sceneColor = vec3(0.),\n    \n        vuv = normalize(vec3(0., 1., 0.)),\n    \tro = vec3(ck * 3., 99., ck + iTime * .1) - 10.,\n    \tvrp =  ro - vec3(sk, ck + 10., 10.),\n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        lp = ro - 1.;\n    \n    for (int i = 1; i < 4; i++) {\n        vec2 t = trace(ro, rd);\n\n        ro += rd * t.x;\n        vec3 sn = getNormal(ro);\n       \n        sceneColor += doColor(ro, rd, sn, lp, 0.) * 20. / float(i) - t.x / 1320.;\n        sceneColor *= softShadow(ro, lp, 0.2);\n\n        rd = mix(rd, reflect(rd, sn), .6);\n    }\n\n    fragColor = vec4(clamp(sceneColor * 3., 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}