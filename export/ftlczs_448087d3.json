{"ver":"0.1","info":{"id":"ftlczs","date":"1648626698","viewed":30,"name":"Simple Scene with Camerav2","username":"havenousername","description":"Simple Scene with Camera","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simplescenewithcamera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int spheresNumber = 2;\n\nint currentSize = 0;\nSphere spheres[spheresNumber];\n\n\n// =================== Model Creators ============================\n\n// create new sphere insid global array\n// TODO: later global array should contain different types of objects\nint CreateSphere(vec3 center, float radius) {\n    int newIndex =  currentSize;\n    if (newIndex >= spheresNumber) return newIndex;\n    Sphere sphere;\n    sphere.center = center;\n    sphere.radius = radius;\n    sphere.id = newIndex;\n    spheres[newIndex] = sphere;\n    currentSize += 1;\n    return 0;\n}\n\n// ==============================================================\n\n\n// =================== Object Distances ============================\n\n// distance to the sphere\n/*\n   vec3 p - current ray position in the scene\n   vec3 center - center of the circle\n   float radius - how big will the circle be\n   vec3 scale - scale on the x,y,z directions, thus forming other type ofn shapes (rouded elipses)\n*/\nfloat sdSphere(vec3 p, vec3 center, float radius, vec3 scale) {\n    // using position subtract center where you want to place your sphere,\n    // radius specifies the size of the sphere from a point to inf.\n    p *= scale;\n    return (length(p - center.xyz) - radius) / findBiggestVec3(scale);\n}\n\n\n// distance to the box, marches box for current pixel\n/*\n   vec3 p - current ray position in the scene\n   vec3 d - translation point\n   vec3 size - size in x,y,z directions\n*/\nfloat sdBox(vec3 p, vec3 d, vec3 size) {\n    // translation\n    p -= d;\n    // animations\n    // rotation\n    // p.zx *= Rot(-iTime);\n    // p.yx *= Rot(iTime);\n    \n    return length(max(abs(p) - size, 0.));\n}\n\nfloat sdTorus(vec3 p, vec3 d, vec2 r) {\n    p -= d;\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n} \n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = a - b;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - .5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e + i;\n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = a - b;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = saturate(t);\n    \n    vec3 c = a + t*ab;\n    return sdSphere(p, c, r, vec3(1, 1, 1));\n}\n\n\n// ==============================================================\n\n// =================== Distance Object Operations Fns ============================\n\n// boolean substraction\n// get A - B\nfloat sdSubtract(float sdA, float sdB) {\n    return max(-sdA, sdB);\n}\n\n// boolean intersection\n// get A && B\nfloat sdIntersect(float sdA, float sdB) {\n    return max(sdA, sdB);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0., 1.);\n    return mix(b, a, h) - k * h *(1.0 - h);\n}\n\n// iTime dependent function\nfloat blendTo(float from, float to) {\n    return mix(from, to, sin(iTime) * .5 + .5 );\n}\n// boolean union\n// get A || B\nfloat sdUnion(float sdA, float sdB) {\n    return smin(sdA, sdB, 0.25);\n}\n\nfloat planeIntersect(vec3 p, float a, float amount) {\n    float plane = dot(p, normalize(vec3(1, 1, 1))) + amount;\n    return sdIntersect(plane, a);\n}\n\n// inner thinkness of the object\nfloat makeShell(float a, float amount) {\n    return abs(a) - amount;\n}\n\n// ==============================================================\n\n// =================== Ray Marching Fns ============================\n\nfloat GetDistance(vec3 p) {\n    // x = 0 - center, y = 1, z the distance from camera, args[3] is the radius\n    \n    float sphereDistances[spheresNumber];\n    for (int i = 0; i < currentSize; i++) {\n        sphereDistances[i] = sdSphere(p, spheres[i].center, spheres[i].radius, vec3(1., 1., 1.));\n    }\n    \n    float planeDistance = p.y - 0.1;\n    float rectDist = p.y;\n    \n    float d = MAX_DISTANCE + 1.;\n    float dSpheres;\n    //for (int i = 0; i < currentSize; i += 2) {\n    //    if (i < currentSize) break;\n    //    dSpheres = sdSubtract(sphereDistances[i], sphereDistances[i + 1]); \n    //}\n    float movingSpheres = blendTo(sphereDistances[1], sphereDistances[0]);\n    d = min(d, movingSpheres);\n    float box = sdBox(p, vec3(-3.5, 1, 1), vec3(1, 0.75, 1));\n    d = min(d, planeIntersect(p, box, 1.65));\n    d = min(d, sdBox(p, vec3(-1.5, 1, -1), vec3(1, 0.75, 1)));\n    d = min(d, sdTorus(p, vec3(1, 0.5, 6), vec2(1.8, 0.8)));\n    d = min(d, sdCapsule(p, vec3(-2.5, 1, 3), vec3(-2., 1.5, 0.8), .3));\n    d = min(d, sdCylinder(p, vec3(0, .3, 3), vec3(3, .3, 5), .3));\n    d = min(d, planeDistance);\n    return d;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDistance) {\n    float dOrigin = 0.; \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rayOrigin + rayDistance * dOrigin;\n        float dS = GetDistance(p);\n        \n        dOrigin += dS;\n        if (dOrigin > MAX_DISTANCE || abs(dS) < SURF_DISTANCE) break;\n    }\n    \n    return dOrigin;\n}\n \nvec3 GetNormal(vec3 position) {\n    float distance = GetDistance(position);\n    // close to zero x vector needed for calculations of normal close to the position\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = distance - vec3(\n        GetDistance(position - e.xyy),\n        GetDistance(position - e.yxy),\n        GetDistance(position - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 position, vec3 initPos, float speed) {\n    vec3 lightPosition = initPos;\n    \n    lightPosition.xz += vec2(sin(iTime * speed), cos(iTime * speed)) * 2.;\n    vec3 light = normalize(lightPosition - position);\n    \n    vec3 normal = GetNormal(position);\n    \n    float diff = clamp(dot(normal, light), 0., 1.);\n    \n    // shadow part\n    float d = RayMarch(position + normal * SURF_DISTANCE * 2., light);\n    if (d < length(lightPosition - position)) diff *= 0.1;\n    \n    return diff;\n}\n\n\nvec3 RayDistance(vec2 uv, vec3 p, vec3 l, float z) {\n     vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nRay createRay(vec2 uv, vec2 m) {\n    Ray ray;\n    ray.origin = vec3(-2, 1, 4);\n    ray.origin.yz *= Rot(-m.y+.4);\n    ray.origin.xz *= Rot(.6 - m.x * TWO_PI);\n    //ray.distance = normalize(vec3(uv.x - .15, uv.y - .2, 1)) ;\n    ray.distance = RayDistance(uv, ray.origin, vec3(0,0,0), .7);\n    return ray;\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    int test1 = CreateSphere(vec3(0.1, 1.1, 1), 1.);\n    int test2 = CreateSphere(vec3(1, 1.1, 1), 1.);\n    \n    // test if there is an initialization error (black -> no errors, white -> error)\n    //fragColor = vec4(vec3(test2) / 10., 1.0);\n    //return;\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n    Ray ray = createRay(uv, m);\n    \n    \n    float distance = RayMarch(ray.origin, ray.distance);\n    //distance  /= 12.0;\n    \n    vec3 position = ray.origin + ray.distance * distance;\n    float diff = GetLight(position, vec3(0, 10, -5), 1.0);\n    \n    // diff = mix(diff, GetLight(position, vec3(0, 1, 4), 1.), 0.5);\n    col = vec3(diff);\n    \n    // col = GetNormal(position);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURF_DISTANCE .01\n\n\n#define PI 3.1415926535897932384626433832795\n#define TWO_PI 6.28318530718\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nfloat findBiggestVec3(vec3 vec) {\n    if (vec.x >= vec.y && vec.x >= vec.z) {\n        return vec.x;\n    } else if (vec.y >= vec.z && vec.y >= vec.x) {\n        return vec.y;\n    } else {\n        return vec.z;\n    }\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int id;\n};\n\nstruct Object {\n    vec3 center;\n    vec3 center2;\n    float radius;\n    int id;\n    vec2 rotation;\n    vec3 scale;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 distance;\n};","name":"Common","description":"","type":"common"}]}