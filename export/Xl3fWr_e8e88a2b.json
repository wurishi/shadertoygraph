{"ver":"0.1","info":{"id":"Xl3fWr","date":"1540999439","viewed":310,"name":"Cosmic scene","username":"Thominator","description":"This is the result of a practical lesson on implicit surfaces. \n\nThe base of the code was provided by Eric Galin.\n\nThis is great","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["space","planet","asteroids","implicitsurfaces"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int Steps = 750;\nconst float Epsilon = 0.005; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Matrix for fractal noise\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n//Usefull for asteroid belt rotations\nvec3 rotateU(vec3 p, vec3 u, float a)\n{\t\n  \tfloat sa = sin(a);\n  \tfloat ca = cos(a);\n    float f1 = u.x*u.y*(1.0-ca); \n    float f2 = u.x*u.z*(1.0-ca);\n    float f3 = u.y*u.z*(1.0-ca);\n    float nx = (ca+u.x*u.x*(1.0-ca))*p.x + \n        (f1-u.z*sa)*p.y +\n        (f2+u.y*sa)*p.z;\n    \n    float ny = (f1+u.z*sa)*p.x + \n        (ca+u.y*u.y*(1.0-ca))*p.y +\n        (f3-u.x*sa)*p.z;\n    \n    float nz = (f2-u.y*sa)*p.x +\n        (f3+u.x*sa)*p.y +\n        (ca+u.z*u.z*(1.0-ca))*p.z;\n    \n    return vec3(nx, ny, nz);\n}\n\n//2D Noise function from user iq\nfloat hash(vec2 p)\n{\n    p  = 45.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//3D Noise function from user iq\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Value of the lambda aka Liptschitz constant\n// e : energy associated to the primitive\n// R : radius associated to the primitive\nfloat lambda(float e, float R){\n    // maximum of the falloff function derivative\n    const float lambda_zero = 96. / (25. * sqrt(5.));\n    \n    return e * lambda_zero / R;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat point(vec3 p, vec3 c, \n            float e,float R, out float lam)\n{\n  lam = lambda(e, R)/dot(p-c, p-c);\n  return e*falloff(length(p-c),R);\n}\n\n// Calculate the distance of a point to a segment\n// p : point\n// a : starting point of the segment\n// b : ending point of the segment\nfloat distSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float L = length(ab);\n    float d = dot(ap, ab)/(dot(ab,ab));\n    if (d < 0.0)\n    {\n        return length(p-a);\n    }\n    if (d > 1.0)\n    {\n        return length(p-b);\n    }\n    else\n    {\n        vec3 pp = a + d*ab;\n    \treturn length(p-pp);\n    } \n}\n\n// Segment\n// p : point\n// a : starting point of the segment\n// b : ending point of the segment\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Segment(vec3 p, vec3 a, vec3 b, \n              float e, float R, out float lam)\n{\n    float dist = distSegment(p, a, b);\n    lam = lambda(e, R)/dist;\n    return e*falloff(dist, R);\n}\n\n// Circle\n// p : point\n// c : center of the circle\n// r : radius of the circle\n// n : orientation of the circle\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Circle(vec3 p, vec3 c, float r, vec3 n, \n             float e, float R, out float lam)\n{\t\n    vec3 cp = c-p;\n    float l = dot(n, cp);\n    float h = sqrt(dot(cp, cp) - l*l);\n    float hcr = h-r;\n    float dist = sqrt(hcr*hcr+l*l);\n    lam = lambda(e, R)/dist;\n    return e*falloff(dist, R);\n}\n\n// Non regular circle\n// p : point\n// c : center of the circle\n// r : radius of the circle\n// n : orientation of the circle\n// f : flatening agent\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat FlatCircle(vec3 p, vec3 c, float r, vec3 n, float f, \n                 float e, float R, out float lam)\n{\t\n    vec3 cp = p-c;\n    float l = dot(n, cp);\n    float h = sqrt(dot(cp, cp) - l*l);\n    float hcr = h-r;\n    float d = sqrt(hcr*hcr+l*l*f*f);\n    float la = lambda(e, R);\n    \n    //For death ray\n    //lam = la*f/h;\n    //Normal lambda calculation\n    //lam = la*f/d;\n    //Optimized optimisation\n    lam = 0.5*la*f/d;\n    return e*falloff(d, R);\n}\n \n// Asteroids : fractal noise\n// tp  : point\n// d   : density of the field\n// len : distance of the point to the field\n// R   : large radius\nfloat Asteroids(vec3 tp, float d, float len, float R)\n{\n    float noi = 0.0;\n    //If we are close nough to care about the astero√Øds\n    if(len < R){\n    \tvec3 q = 3.0*tp;//vec3(x, y, z);\n    \tnoi  = 0.5000*noise( q ); q = m3*q*2.01;\n    \tnoi += 0.2500*noise( q ); q = m3*q*2.02;\n    \tnoi += 0.1250*noise( q ); q = m3*q*2.03;\n        \n        //Second noise calculation : clumpy uneven results\n        /*\n        q = vec3(noi*tp.x, noi*tp.y, noi*tp.z);\n    \tnoi  = 1.0000*noise( q ); q = m3*q*2.01;\n    \tnoi += 0.25000*noise( q ); q = m3*q*2.02;\n    \t//*/\n    }\n    \n    //density factor\n    float sc = 1.0/d;\n    //distance to the asteroids\n    return sc*noi;\n}\n\n// Asteroid field\n// p : point\n// c : center of field\n// r : radius of the field\n// d : density of the field\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Asterofield(vec3 p, vec3 c, float r, float d, \n                  float e,float R, out float lam)\n{\n    // Distance to the center\n    vec3 cp = p-c;\n    // Distance to the shell\n    float len = length(cp)-r;\n    \n    // The distance calculated for the asteroids (distances are squared)\n    float afact = Asteroids(cp, d, len*len, R*R);\n    \n    // General distance\n    // \"Proper\" way, disturbing the distance with a noise\n    //float dist = sqrt(len*len)+afact;\n    // \"Wtf way, disturbing the distance calculation in itself\n    float dist = sqrt(len*len+afact*afact);\n    \n    // If we are near the asteroids we need more precisions\n    float l = lambda(e, R);\n    if (afact > 0.0)\n        // Very specific, dangerous\n        //lam = 4.0*l/(dist*dist);\n        //Usual\n        lam = 4.0*l/dist;\n    else\n        lam = l/dist;\n    return e*falloff(dist, R);\n}\n\n// Asteroid belt\n// p : point\n// c : center of belt\n// r : radius of the belt\n// n : orientation of the belt\n// d : density of the belt\n// f : flatness of the belt\n// e : energy associated to skeleton\n// R : large radius\n// lam : pseudo-calculated lambda\nfloat Asteroidbelt(vec3 p, vec3 c, float r, vec3 n, float d, float f, \n                   float e, float R, out float lam)\n{\n    // Distance to the center of the circle\n    vec3 cp = p-c;\n    //Comment to prevent the belt from rotating\n    cp = rotateU(cp, n, 0.5*iTime);\n    // Distance to the circle \n    float l = dot(n, cp);\n    float h = sqrt(dot(cp, cp) - l*l);\n    float hcr = h-r;\n    \n    // The distance calculated for the asteroids (distances are squared)\n    float afact = Asteroids(cp, d, hcr*hcr+l*l, R*R);\n    \n    //General distance\n    // \"Proper\" way, disturbing the distance with a noise\n    //float dist = sqrt(hcr*hcr+l*l*f*f)+afact;\n    // Better results if afact is added in the square root\n    float dist = sqrt(hcr*hcr+l*l*f*f+afact*afact);\n    float la = lambda(e, R);\n    \n    // If we are near the asteroids we need more precisions\n    if (afact > 0.0)\n        // Very specific, dangerous\n        //lam = 5.0*la*f/(dist*dist);\n        // usual\n        lam = 4.0*la*f/dist;\n    else\n        lam = la*f/dist;\n    \n    return e*falloff(dist, R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n    return min(a,b);\n}\n\n// Substraction\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Substraction(float a,float b)\n{\n    return min(a, 2.0*T-b);\n}\n\n\n//OBJECTS\n//AsteroStar\nfloat AsteroStar(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = Asterofield(p, vec3( 0.0, 0.0, 0.0), 3.0*abs(cos(0.10*iTime)), 0.4, \n                          1.0, 1.3, lam);\n    v = Blend(v, point(p,vec3(0.0, 0.0,0.0),1.0*abs(sin(0.10*iTime)),3.5, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//MegaBelt\nfloat MegaBelt(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = Asteroidbelt(p, vec3(0.0, 0.0, 0.0), 5.5, normalize(vec3(0.0, .71, .71)), \n                              0.3, 3.0, 1.0, 2.0, lam);\n    v = Blend(v, point(p,vec3(5.0, -2.0,2.0),1.0,1.5, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Saturn\nfloat Saturn(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = point(p,vec3(-7.0, 2.0,2.0),1.0,2.5, lam);\n    v = Blend(v, FlatCircle(p, vec3(-7.0, 2.0,2.0), 2.0, normalize(vec3(1.0, 0.8, 0.0)), \n                           17.5, 1.0, 0.8, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Loner\nfloat Loner(vec3 p, out float lam)\n{\n    float lam2;\n    float v = point(p,vec3(5.0,-2.5,-10.0),1.0,1.5, lam);\n    v = Blend(v, Asteroidbelt(p, vec3(5.0,-2.5,-10.0), 1.5, normalize(vec3(0.71, 0.71, 0.0)), \n                              0.3, 1.0, 1.0, 1.3, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Binary planets\nfloat Binary(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = point(p,vec3(7.0, 0.0,6.0),1.0,1.5, lam);\n    v = Blend(v,point(p,vec3(7.0, 1.0,4.0),1.0,1.5, lam2));\n    lam = max(lam, lam2);\n    v = Blend(v,Asteroidbelt(p, vec3(7.0, 1.0, 4.0), 1.5, normalize(vec3(-0.19, .98, 0.0)), \n                              0.4, 1.0, 1.0, 1.3, lam2));    \n    lam = max(lam, lam2);\n    return v;\n}\n\n//Blob\nfloat Blob(vec3 p, out float lam)\n{\n    float lam2 = 0.0;\n    float v = point(p,vec3(0.0, 5.0,-1.0),1.0,1.5, lam);\n    v = Blend(v, point(p,vec3(0.0, 5.5,-1.0),0.8,0.5, lam2));\n    lam = max(lam, lam2);\n    v = Blend(v, point(p,vec3(0.0, 5.2,-2.0),0.8,0.5, lam2));\n    lam = max(lam, lam2);\n    return v;\n}\n\n//Scene\nfloat Scene(vec3 p, out float lam)\n{\n    float lam2;\n\tfloat v_astar = AsteroStar(p, lam);\n    float v_abelt = MegaBelt(p, lam2);\n    lam = max(lam, lam2);\n    float v_saturn = Saturn(p, lam2);\n    lam = max(lam, lam2);\n    float v_loner = Loner(p, lam2);\n    lam = max(lam, lam2);\n    float v_binary = Binary(p, lam2);\n    lam = max(lam, lam2);\n    float v_blob = Blob(p, lam2);\n    lam = max(lam, lam2);\n    \n    float v = Union(v_astar, v_abelt);\n    v = Union(v, v_saturn);\n    v = Union(v, v_loner);\n    v = Union(v, v_binary);\n    v = Union(v, v_blob);\n    return v;\n}\n\n// Potential field of the object\n// p : point\n// lam : pseudo-calculated lambda\nfloat object(vec3 p, out float lam)\n{\n  p.z=-p.z;\n    lam = 1.0;\n    //Circle\n  \t//float v = Circle(p, vec3(0.0, 0.0, 0.0), 4.0, normalize(vec3(0.0, .71, .71)), 1.0, 1.8, lam);\n    //FlatCircle\n  \t//float v = FlatCircle(p, vec3(0.0, 0.0, 0.0), 4.0, normalize(vec3(0.0, 0.0, 1.0)), 10.0, 1.0, 1.4, lam);\n    //Segment\n  \t//float v = Segment(p, vec3(-1.0, -2.0, -3.0), vec3(1.0, 1.0, -3.0), 1.0, 3.0, lam);\n    //AsteroidField\n    //float v = Asterofield(p, vec3( 0.0, 0.0, 0.0), 3.0, 0.4, 1.0, 1.3, lam);\n    //AsteroidBelt\n    /*float v = Asteroidbelt(p, vec3(0.0,0.0,0.0), 3.5, normalize(vec3(0.71, 0.71, 0.0)), \n                              0.4, 4.0, 1.0, 2.0, lam);//*/\n    //Scene\n\tfloat v = Scene(p, lam);\n    return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float l;\n  float v = object(p, l);\n  n.x = object( vec3(p.x+eps, p.y, p.z), l ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z), l ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps), l ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n    float l;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, l);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out float lam)\n{\n  h = false;\n\tlam = 1.0;\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\tfloat l;\n    \n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, l);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          lam = l;\n          break;\n      }\n      // Move along ray\n      //t += max(Epsilon,abs(v)/4.0);\n      // Move along the ray but faster\n      t += max(Epsilon,abs(v)/l);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n    //return vec3(0, 0, 0);\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  //const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightPos = vec3(0.0, 0.0, 0.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(-n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(-n, l));\n\n  c += diff*lightColor;\n  \n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n    return vec3(3.*t, t, 3.*t);\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\t//pixel*=2.0;\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 25.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=3.14;\n  // Uncomment to have the scene rotation\n  a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n  float lam;\n  float t = SphereTrace(ro, rd, hit,s, lam);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n    // Shade object with \"lambda\"\n    // rgb = vec3(1.0/lam, 1.0/lam, 1.0/lam);\n  }\n  else\n  {\n      float star = rand(pixel);  \n      if(star > 0.9985)\n          rgb = vec3(1, 1, 1);\n      else\n          rgb = vec3(0, 0, 0);\n  }\n\n  // Add step shading to have a cool dusty effect\n  rgb += ShadeSteps(s);\n    \n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}