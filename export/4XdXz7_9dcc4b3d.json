{"ver":"0.1","info":{"id":"4XdXz7","date":"1719391721","viewed":59,"name":"Britney Spheres","username":"Chriscamplin","description":"Originally based on a ray marching tutorial by kishimisu\n\nhttps://www.youtube.com/watch?v=khblXafu7iA","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition"],"hasliked":0,"parentid":"l3dSzn","parentname":"Raymarched BoxFrames"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n//     (extended to 3D)\nvec3 hash( vec3 p )\n{\n\tp *= mat3( 127.1,311.7,-53.7,\n\t\t\t   269.5,183.3, 77.1,\n\t\t\t  -301.7, 27.3,215.3 );\n\n\treturn 2.*fract(sin(p)*43758.5453123) -1.;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n      // u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // smoother. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n \n    return 2.*mix(\n              mix( mix( dot( hash( i + vec3(0,0,0) ), f - vec3(0,0,0) ), \n                        dot( hash( i + vec3(1,0,0) ), f - vec3(1,0,0) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,0) ), f - vec3(0,1,0) ), \n                        dot( hash( i + vec3(1,1,0) ), f - vec3(1,1,0) ), u.x), u.y),\n              mix( mix( dot( hash( i + vec3(0,0,1) ), f - vec3(0,0,1) ), \n                        dot( hash( i + vec3(1,0,1) ), f - vec3(1,0,1) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,1) ), f - vec3(0,1,1) ), \n                        dot( hash( i + vec3(1,1,1) ), f - vec3(1,1,1) ), u.x), u.y), u.z);\n}\n\nmat3 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n  );\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n// Sphere.\nfloat sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 palette(float t, vec2 m) {\n    return .5+.5*cos(6.28318*(t+vec3(.3*m.y,.416*m.y,1.557*m.x)));\n}\n\n\n// 2D rotation function\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\n// Distance to the scene.\nfloat map(vec3 p) {\n    float tm = iTime*.5;\n\n    p.x -=iTime*.25;\n    p.z -=iTime*.25;\n    p.y +=iTime*.5;\n    // Space repetition\n    p.xy = fract(p.xy) - .5;     // spacing: 1\n    p.z =  mod(p.z, .2) - .1; // spacing: .25\n    // paramteres\n    const float le = 0.125, r1 = 0.15, r2 = 0.058;\n   // p.zx*=rot2D((PI)*(tm*.25));\n    //p.xy*=rot2D((PI)*(tm*.25));\n    // evaluate links\n  ///float box = sdLink(p,le*p.z,r1,r2-.02);\n  float box = sdSphere(p,.08);\n  //float box = sdOctahedron(p, vec2(r1*.5, r1*.4+p.z).x);\n  //float ground = p.y + .75;\n  //float box = sdCapsule(p, vec3(0.051,0.051,0.051), vec3(0.251,0.251,0.251),.05);\n  return box;\n}\n// RADIAL UV\n// authored by @bruno_simon\n// (uv) transform uv to radial uv\nvec2 getRadialUv(vec2 uv) {\n    float angle = atan(uv.x, -uv.y);\n    angle = abs(angle);\n\n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI * 2.0) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), 4.0);\n\n    return radialUv;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy)/iResolution.y;\n    vec2 rUv = getRadialUv(uv);\n    vec2 m = (iMouse.xy* 2.0 - iResolution.xy)/iResolution.y;\n    vec3 vid = texture(iChannel0, uv*.5+.5).rgb;\n\n    vec3 RayOrigin = vec3(0,0,-0);\n    vec3 RayDirection = normalize(vec3(uv.x, uv.y,1));\n    float t = 0.0;\n    float tm = iTime*.5;\n    vec3 col = vec3(0);\n    float noiseFreq = .1;\n    // loop through the ray\n    int i;\n    for(i = 0; i< 512; i++) {\n        vec3 p = RayOrigin + RayDirection * t;\n         \n        //p.xy += noise(p+t*.005 * 2.);     // rotate ray around z-axis\n        p.xy *= rot2D(t*.005 * 10.);     // rotate ray around z-axis\n        p.xz *= rot2D(tm*.005 * 10.);     // rotate ray around z-axis\n        p.x += sin(t*(m.x)*.5)*.35;  // wiggle ray\n        p.yx *= rot2D((PI*tm*.0001) * tm);     // rotate ray around z-axis\n        p.yzx*=rotation3d(vec3(1, 10,1), (PI)*(tm*.005));\n        //p.xyz*=rotation3d(vec3(1, -1,1), (-PI*2.)*(tm*.05));\n        p -= vid;\n\n        float d = map(p);\n        t+=d;\n        //col+= vec3(i);\n        if(d<0.00001 || t > 256.) break; // early out\n    }\n    vec3 pos = RayOrigin + t*RayDirection;\n        //pos.xy += noise(pos+t*.005 * 2.);     // rotate ray around z-axis\n        pos.xy *= rot2D(t*.005 * 10.);     // rotate ray around z-axis\n        pos.xz *= rot2D(tm*.005 * 10.);     // rotate ray around z-axis\n        pos.x += sin(t*(m.x)*.5)*.35;  // wiggle ray\n        pos.yx *= rot2D((PI*tm*.0001) * tm);     // rotate ray around z-axis\n        pos.yzx*=rotation3d(vec3(1, 10,1), (PI)*(tm*.005));\n        //pos.xyz*=rotation3d(vec3(1, -1,1), (-PI*2.)*(tm*.05));\n        pos -= vid;\n\n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(1.6,0.2,0.4));\n    vec3 hal = normalize(lig-RayDirection);\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float occ = calcOcclusion( pos, nor );\n    if( dif>0.00001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n    float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-RayDirection),0.0,1.0),5.0));\n    float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n    col =  vec3(0.5,1.0,1.2)*amb*occ;\n    col += vec3(2.8,2.2,1.8)*dif;\n    col *= 0.2;\n    col += vec3(2.8,2.2,1.8)*spe*3.0;\n    //col += palette(t*.2 + float(i)*.00075*(m.y-.5), m)*vid;\n    col += palette(t*.04 + float(i)*.005, m)-vid;\n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    //col += vid;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}