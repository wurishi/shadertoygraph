{"ver":"0.1","info":{"id":"ddGfDG","date":"1698586321","viewed":65,"name":"noise image fade","username":"DeltaT","description":"would probably look cooler with voronoi","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float influence(vec2 v) {\n    v *= 1.1547005; // 1/sqrt(0.75)\n    float d = clamp(1.-dot(v, v), 0., 1.);\n    return d*d*d;\n}\n\nvec2 hash22(vec2 p) { // hash function taken from shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 v, int seed) {\n    const mat2 unskew = mat2(1., 0., -0.5773503, 1.1547005); // -(1/sqrt(0.75))/2 and 1/sqrt(0.75)\n    const mat2 skew = mat2(1., 0., 0.5, 0.8660254); // sqrt(0.75)\n    \n    vec2 v1 = unskew*v;\n    vec2 grid = floor(v1);\n    float s = float(seed)*3.14159;\n    float c = fract(v1).x + fract(v1).y < 1. ? 0. : 1.;\n    vec2[3] tri = vec2[3](grid+vec2(-c+1., c), grid+vec2(c, -c+1.), grid+vec2(c)); // verts on right angled triangle\n    vec2[3] rand = vec2[3](hash22(tri[0]+s), hash22(tri[1]+s), hash22(tri[2]+s));\n    vec2[3] corners = vec2[3](v-skew*tri[0], v-skew*tri[1], v-skew*tri[2]);\n    return 2.*(\n        dot(rand[0], corners[0])*influence(corners[0])\n      + dot(rand[1], corners[1])*influence(corners[1])\n      + dot(rand[2], corners[2])*influence(corners[2])\n    );\n}\n\nfloat fbm(vec2 coord, int numOctaves) {\n    float a = 1.;\n    float f = 1.;\n    float m = 1.;\n    float result = 0.;\n    \n    for (int i = 0; i < numOctaves; i++) {\n        result += noise(coord*f, i)*a;\n        a /= 2.;\n        f *= 2.;\n        m += a;\n    }\n    return result/m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float noise = fbm(uv*4., 8);\n    vec3 i1 = texture(iChannel0, uv/2.).rgb;\n    vec3 i2 = texture(iChannel1, uv/2.).rgb;\n    float mask = noise+1. > uv.y+2.*cos(0.5*iTime)+1. ? 0. : 1.;\n    vec3 col = mix(i1, i2, mask);\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}