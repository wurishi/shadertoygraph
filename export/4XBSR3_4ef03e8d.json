{"ver":"0.1","info":{"id":"4XBSR3","date":"1711485558","viewed":26,"name":"Bar of Light","username":"MikSu","description":"An abstract bar of light opening and closing.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["satisfying"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define OPEN_SIZE .2\n#define INITIAL_SHADE .4\n#define TILT -.1\n#define GRAIN .3\n\nfloat aaRadius(){\n    // Computes a global anti-aliasing radius relative to video resolution.\n    return 6./iResolution.y;\n}\n\nfloat timeF(float t){\n    // Specifies how much the light bar is opened at the given time.\n    // Output: 0 = closed , 1 = fully open.\n    t = mod(t, 16.);\n    \n    // Define the intervals when the transitions take place,\n    // e.g. the first opening should happen between 1.00s and 3.00s.\n    vec2 open1Ts = vec2(1., 3.);\n    vec2 open2Ts = vec2(3., 6.);\n    vec2 closeTs = vec2(8., 16.);\n    \n    float m = 4.; // Initial velocity\n    float d = -.5; // Second derivative at 1\n    float s1 = (t-open1Ts.x)/(open1Ts.y-open1Ts.x); // Shifted coordinate\n    float s2 = s1*s1; float s4 = s2*s2;\n    float open1 = max(.3*((3.+d-m)*s4+(3.*m-2.*d-8.)*s1*s2+(6.+d-3.*m)*s2+m*s1), 0.);\n    float s = (t-open2Ts.x)/(open2Ts.y-open2Ts.x);\n    float open2 = max(.7*s*s*s*s*s, 0.) + .3;\n    float open = mix(open1, open2, step(open1Ts.y, t));\n    s = (t-closeTs.x)/(closeTs.y-closeTs.x);\n    float close = smoothstep(0., 1., (1.-s)*(1.-s)*(1.-s));\n    \n    return mix(open, close, smoothstep(open2Ts.y, open2Ts.y+.05, t));\n}\n\nfloat bottomShade(float s){\n    return INITIAL_SHADE*(1.-.5*s);\n}\n\nfloat lightOpening(float d, float s){\n    float openingSize = OPEN_SIZE*s;\n    return smoothstep(-openingSize, -openingSize+aaRadius(), d)*smoothstep(0., -aaRadius(), d);\n}\n\nfloat topGradient(vec2 nc, float s){\n    // Computes \"brightness value\" that should be scaled and added to the base shade.\n    // Output: 0 = no light, 1 = full brightness.\n    float brightness = (.9*s)/((nc.x+1.)*(nc.x+1.));\n    float grain = 1.-GRAIN*texture(iChannel0, nc*iResolution.x/768.-s*vec2(.05,0)).x;\n    return smoothstep(-aaRadius(), 0., nc.x)*brightness*grain;\n}\n\nfloat haze(vec2 nc, float s){\n    float halfW = .5*OPEN_SIZE*s;\n    float x = nc.x+halfW;\n    float x2 = x*x;\n    float w2 = halfW*halfW;\n    float h = .15;\n    float dropOff = 6.;\n    float dither = 1.-.5*texture(iChannel0, nc*iResolution.x/256.).y;\n    return max((2.*w2*h*h*h)/(w2*h*(2.*h-halfW*dropOff)+halfW*h*dropOff*x2), 0.)*dither;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n    // Orthonormal coordinates along the line in the direction of vec2(1., TILT).\n    vec2 nc = vec2(dot(uv, vec2(-TILT, 1.)),dot(uv, vec2(1., TILT)))/length(vec2(1.,TILT));\n    float s = timeF(iTime);\n    \n    float col = mix(bottomShade(s), INITIAL_SHADE, step(-aaRadius(), nc.x)) // Base shade\n                + lightOpening(nc.x, s) // Light bar\n                + (1. - INITIAL_SHADE)*topGradient(nc, s) // Top gradient\n                + mix(0., haze(nc, s), smoothstep(.01, .1, s)); // Extra haze\n    \n    fragColor = vec4(vec3(col),1.);\n}","name":"Image","description":"","type":"image"}]}