{"ver":"0.1","info":{"id":"NtVczh","date":"1661326203","viewed":89,"name":"hoval","username":"miqforshade","description":"drawing a hoval to blur out","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blur","hoval"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 topLeft = vec2(0.0,1.0); \nconst vec2 bottomLeft = vec2(0.0,0.0); \nconst vec2 topRight = vec2(1.0,1.0); \nconst vec2 bottomRight = vec2(1.0,0.0); \nconst vec2 htp1 = vec2(0.5,1.0); \nconst vec2 htp2 = vec2(0.087,1.0); \nconst vec2 htp3 = vec2(0.0,0.7925); \nconst vec2 htp4hbp1 = vec2(0.0, 0.525); \nconst vec2 hbp2 = vec2(0.0,0.2575); \nconst vec2 hbp3 = vec2(0.18,0.0); \nconst vec2 hbp4 = vec2(0.5,0.0); \nconst float widthAR = 0.3; // hoval width factor \nconst float hovalAR = 4.0 / 3.0;\nconst float ht_x[99] = float[](0.4877f, 0.4756f, 0.4637f, 0.4520f, 0.4404f, 0.4291f, 0.4179f, 0.4069f, 0.3962f, 0.3856f,\n0.3751f, 0.3649f,\n0.3548f, 0.3449f, 0.3352f, 0.3257f, 0.3163f, 0.3072f, 0.2981f, 0.2893f, 0.2806f, 0.2721f, 0.2637f, 0.2555f, 0.2475f, 0.2396f, 0.2319f,\n0.2244f, 0.2170f, 0.2097f, 0.2026f, 0.1957f, 0.1889f, 0.1823f, 0.1758f, 0.1694f, 0.1632f, 0.1571f, 0.1512f, 0.1454f, 0.1398f, 0.1343f,\n0.1289f, 0.1237f, 0.1186f, 0.1136f, 0.1088f, 0.1040f, 0.0995f, 0.0950f, 0.0907f, 0.0864f, 0.0824f, 0.0784f, 0.0745f, 0.0708f, 0.0672f,\n0.0636f, 0.0602f, 0.0570f, 0.0538f, 0.0507f, 0.0478f, 0.0449f, 0.0421f, 0.0395f, 0.0369f, 0.0345f, 0.0321f, 0.0299f, 0.0277f, 0.0257f,\n0.0237f, 0.0218f, 0.0200f, 0.0183f, 0.0167f, 0.0151f, 0.0137f, 0.0123f, 0.0110f, 0.0098f, 0.0087f, 0.0076f, 0.0067f, 0.0058f, 0.0049f,\n0.0042f, 0.0035f, 0.0028f, 0.0023f, 0.0018f, 0.0014f, 0.0010f, 0.0007f, 0.0004f, 0.0002f, 0.0001f, 0.0000f);\nfloat[99] ht_y = float[] ( 0.9999f, 0.9998f, 0.9994f, 0.9990f, 0.9985f, 0.9978f, 0.9970f, 0.9961f, 0.9951f, 0.9939f,\n0.9927f, 0.9913f,\n0.9898f, 0.9882f, 0.9865f, 0.9847f, 0.9827f, 0.9807f, 0.9785f, 0.9763f, 0.9739f, 0.9714f, 0.9689f, 0.9662f, 0.9634f, 0.9605f, 0.9575f,\n0.9544f, 0.9512f, 0.9480f, 0.9446f, 0.9411f, 0.9375f, 0.9338f, 0.9301f, 0.9262f, 0.9223f, 0.9182f, 0.9141f, 0.9098f, 0.9055f, 0.9011f,\n0.8966f, 0.8920f, 0.8874f, 0.8826f, 0.8778f, 0.8729f, 0.8679f, 0.8628f, 0.8577f, 0.8524f, 0.8471f, 0.8417f, 0.8362f, 0.8307f, 0.8251f,\n0.8194f, 0.8136f, 0.8078f, 0.8018f, 0.7959f, 0.7898f, 0.7837f, 0.7775f, 0.7712f, 0.7649f, 0.7585f, 0.7521f, 0.7456f, 0.7390f, 0.7324f,\n0.7256f, 0.7189f, 0.7121f, 0.7052f, 0.6983f, 0.6913f, 0.6842f, 0.6771f, 0.6700f, 0.6628f, 0.6555f, 0.6482f, 0.6408f, 0.6334f, 0.6260f,\n0.6185f, 0.6109f, 0.6033f, 0.5957f, 0.5880f, 0.5802f, 0.5725f, 0.5647f, 0.5568f, 0.5489f, 0.5410f, 0.5330f );\nfloat[99] hb_x = float[] ( 0.0001f, 0.0002f, 0.0005f, 0.0009f, 0.0013f, 0.0019f, 0.0026f, 0.0034f, 0.0043f, 0.0054f,\n0.0065f, 0.0077f,\n0.0090f, 0.0105f, 0.0120f, 0.0137f, 0.0154f, 0.0173f, 0.0192f, 0.0213f, 0.0234f, 0.0257f, 0.0281f, 0.0306f, 0.0331f, 0.0358f, 0.0386f,\n0.0415f, 0.0444f, 0.0475f, 0.0507f, 0.0540f, 0.0574f, 0.0609f, 0.0644f, 0.0681f, 0.0719f, 0.0758f, 0.0798f, 0.0838f, 0.0880f, 0.0923f,\n0.0967f, 0.1011f, 0.1057f, 0.1104f, 0.1151f, 0.1200f, 0.1249f, 0.1300f, 0.1351f, 0.1404f, 0.1457f, 0.1512f, 0.1567f, 0.1623f, 0.1680f,\n0.1739f, 0.1798f, 0.1858f, 0.1919f, 0.1980f, 0.2043f, 0.2107f, 0.2172f, 0.2237f, 0.2304f, 0.2371f, 0.2440f, 0.2509f, 0.2579f, 0.2650f,\n0.2722f, 0.2795f, 0.2869f, 0.2943f, 0.3019f, 0.3096f, 0.3173f, 0.3251f, 0.3330f, 0.3410f, 0.3491f, 0.3573f, 0.3656f, 0.3739f, 0.3824f,\n0.3909f, 0.3995f, 0.4082f, 0.4170f, 0.4259f, 0.4349f, 0.4439f, 0.4531f, 0.4623f, 0.4716f, 0.4810f, 0.4904f );\nfloat[99] hb_y = float[]( 0.5170f, 0.5090f, 0.5010f, 0.4930f, 0.4850f, 0.4770f, 0.4691f, 0.4611f, 0.4532f, 0.4453f,\n0.4374f, 0.4296f,\n0.4217f, 0.4139f, 0.4061f, 0.3984f, 0.3907f, 0.3830f, 0.3753f, 0.3677f, 0.3601f, 0.3525f, 0.3450f, 0.3375f, 0.3301f, 0.3227f, 0.3154f,\n0.3081f, 0.3008f, 0.2936f, 0.2865f, 0.2794f, 0.2723f, 0.2653f, 0.2584f, 0.2515f, 0.2447f, 0.2380f, 0.2313f, 0.2246f, 0.2181f, 0.2116f,\n0.2051f, 0.1988f, 0.1925f, 0.1863f, 0.1801f, 0.1741f, 0.1681f, 0.1622f, 0.1564f, 0.1506f, 0.1449f, 0.1394f, 0.1339f, 0.1285f, 0.1232f,\n0.1179f, 0.1128f, 0.1078f, 0.1028f, 0.0980f, 0.0932f, 0.0886f, 0.0840f, 0.0796f, 0.0752f, 0.0710f, 0.0669f, 0.0628f, 0.0589f, 0.0551f,\n0.0514f, 0.0479f, 0.0444f, 0.0411f, 0.0379f, 0.0348f, 0.0318f, 0.0289f, 0.0262f, 0.0236f, 0.0211f, 0.0188f, 0.0165f, 0.0145f, 0.0125f,\n0.0107f, 0.0090f, 0.0075f, 0.0061f, 0.0048f, 0.0037f, 0.0027f, 0.0019f, 0.0012f, 0.0007f, 0.0003f, 0.0001f );\nconst int totalPoints = 99; \n \n\nvec4 applyBlur(vec2 uv){ \n    float Pi = 6.28318530718; // Pi*2 \n \n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower) \n    float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower) \n \n    vec2 Radius = vec2(0.02); \n     \n    // Pixel colour \n    vec4 Color = texture(iChannel0, uv); \n \n    // Blur calculations \n    for( float d=0.0; d<Pi; d+=Pi/Directions) \n    { \n        vec2 offset = vec2(cos(d),sin(d))*Radius; \n        for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality) \n        { \n            Color += texture( iChannel0, uv+ offset *i); \n        } \n    } \n \n    // Output to screen \n    Color /= Quality * Directions; \n    return Color; \n} \n \nbool isInRect(vec2 coord, vec2 bottomLeft, vec2 topRight) { \n    bvec2 botL = lessThan(coord, bottomLeft); \n    bvec2 topR = greaterThan(coord, topRight); \n \n    if(botL.x || botL.y || topR.x || topR.y) \n        return false; \n    else \n        return true; \n} \n \nfloat getHTXVal(int position, bool is_right) { \n    if(is_right) \n        return 1.0 - ht_x[position]; \n    else \n        return ht_x[position]; \n} \nfloat getHBXVal(int position, bool is_right) { \n    if(is_right) \n        return 1.0 - hb_x[position]; \n    else \n        return hb_x[position]; \n} \nfloat getXVal(int position, bool is_top, bool is_right) { \n    if(is_top) \n        return getHTXVal(position, is_right); \n    else \n        return getHBXVal(position, is_right); \n} \nfloat getYVal(int position, bool is_top) { \n    if(is_top) \n        return ht_y[position]; \n    else \n        return hb_y[position]; \n} \nvec2 getPointFirstXHigh(vec2 value, bool is_top, bool is_right) { \n    int start = 0; \n    int end = totalPoints-1; \n    int pos = 0; \n    float x_val = 0.0; \n \n    while(start <= end) { \n        pos = (start + end) / 2; \n        x_val = getXVal(pos, is_top, is_right); \n        if(x_val > value.x) { \n            start = pos + 1; \n        } else if (x_val < value.x) { \n            end = pos -1; \n        } else \n            break; \n    } \n \n    return vec2(x_val, getYVal(pos, is_top)); \n} \nvec2 getPointFirstXLow(vec2 value, bool is_top, bool is_right) { \n    int start = 0; \n    int end = totalPoints-1; \n    int pos = 0; \n    float x_val = 0.0; \n \n    while(start <= end) { \n        pos = (start + end) / 2; \n        x_val = getXVal(pos, is_top, is_right); \n        if(x_val < value.x) { \n            start = pos + 1; \n        } else if (x_val > value.x) { \n            end = pos -1; \n        } else \n            break; \n    } \n \n    return vec2(x_val, getYVal(pos, is_top)); \n} \nvec2 getCurvePointForHTL(vec2 value) { \n    return getPointFirstXHigh(value, true, false); \n} \nvec2 getCurvePointForHTR(vec2 value) { \n    return getPointFirstXLow(value, true, true); \n} \nvec2 getCurvePointForHBL(vec2 value) { \n    return getPointFirstXLow(value, false, false); \n} \nvec2 getCurvePointForHBR(vec2 value) { \n    return getPointFirstXHigh(value, false, true); \n} \nbool hasToBlurHTL(vec2 coord){ \n    vec2 aux = getCurvePointForHTL(coord); \n    return coord.y >= aux.y; \n}\n \nbool hasToBlurHTR(vec2 coord){ \n    vec2 aux = getCurvePointForHTR(coord); \n    return coord.y >= aux.y; \n} \n \nbool hasToBlurHBL(vec2 coord){ \n    vec2 aux = getCurvePointForHBL(coord); \n    return coord.y <= aux.y; \n} \n \nbool hasToBlurHBR(vec2 coord){ \n    vec2 aux = getCurvePointForHBR(coord); \n    return coord.y <= aux.y; \n} \n \nbool isBlurPoint(vec2 coord) { \n \n    if(coord.x <= htp1.x) { \n        if (coord.y <= htp4hbp1.y) \n            return hasToBlurHBL(coord); \n        else \n            return hasToBlurHTL(coord); \n    } else { \n        if (coord.y <= htp4hbp1.y) \n            return hasToBlurHBR(coord); \n        else \n            return hasToBlurHTR(coord); \n    } \n} \n \nvec2 normToHoval(vec2 coord, vec2 hovalSize, vec2 offset) { \n    vec2 screenPoint = coord * iResolution.xy; \n    vec2 screenOffset = offset * iResolution.xy; \n \n    vec2 aux = screenPoint - screenOffset; \n \n    return aux / hovalSize; \n}\n\nbool hasToBlur(vec2 coord) { \n    float hovalW = iResolution.x * widthAR; \n    float hovalH = hovalW * hovalAR; \n    float hAR = hovalH / iResolution.y; \n    float heightOffset = ((iResolution.y / 2.0) - (hovalH / 2.0)) / iResolution.y; \n    float widthOffset = (1.0 - widthAR) / 2.0; \n \n    vec2 offset = vec2(widthOffset,heightOffset); \n    vec2 uv = normToHoval(coord, vec2(hovalW, hovalH), offset); \n \n    bool inR = isInRect(uv,bottomLeft, topRight); \n \n    if(inR) \n        return isBlurPoint(uv); \n    else \n        return true; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n\n    bool isBlur = hasToBlur(coord);\n\n    if (isBlur)\n    {\n        fragColor = applyBlur(coord);//vec4(vec3(0.0),1.0);\n    }\n    else\n    {\n        fragColor = vec4(texture(iChannel0, coord).rgb, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}