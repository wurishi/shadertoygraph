{"ver":"0.1","info":{"id":"WdjBDV","date":"1590913753","viewed":288,"name":"Rain & Floods","username":"kastorp","description":"didn't give the expected result, but it's still funny!\n \npress SPACE to start an empty scenario\nmouse + SPACE : add thick wall\nmouse + SHIFT: ERASE\nmouse: bucket","likes":27,"published":1,"flags":48,"usePreview":0,"tags":["water","rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*-----------------------------------------------------------\n\nWhen playing Minecraft years ago, I always asked myself why \nwater physic was so so irrealistic... I will never know!\nLucklily there was a mod called \"finite liquid\", that I liked so much.\n\nI'm trying to make something similar, with these constraints:\n1. the water state for each block (= texel) should be \n    stored in one integer (8 bits)\n2. to update  water state, only neightbours blocks \n   from previous frame should be evaluated (8 blocks)\n3. the water MUST be finite, so no water generation \n   or destruction during transition\n\nI've modelled the water state in the \"x\" variable with the following values\n\tx==0: no water\n    0 < x < M: surface water or falling water, with level =x\n\tx>= M: deep water, where x-M is the pressure (now pressure is always 0)\nwhere M is max levelling distance.\n\nAt the moment, I've implemented two basic rules:\n1. FALLS: when the block below is free, transfer as much water as possibile\n2. LATERAL: when the blocks below are not free and the lateral block level\n\t\t\tis less then current level, transfer part of the difference\n\nthe 2nd rule is evaluated with the left block in odd frames, \nand with right block on even frames. \nIn a 3D version, the lateral block would be 4 so a iFrame%4 would be necessary.\n\nEach rule must be implemented  twice (water out, water in) \nto guarantee water conservation. Order of in/out rules must be randomic.\n\nAfter implementing the rules, I added adjustment factors, \nbased on empirical observation.\n\n-------------------------------------------------------------*/\nMain {\n       \n    vec4 data=A(U / ZOOM );\n    float w = data.x;\n\n    Q = mat4(0. , .5, 1., 0., //water\n             0. , -5., 1., 0., //level max\n             1. , 0, 0., 0.,  // pressure (not implemented yet)\n             1. , 1., 1., 0. ) //barrier\n        *vec4(step(.5,w),step(M,w),step(M+1.,w) ,data.y );\n\t\n    //mouse pointer\n    Q+=vec4(1. , 0., 0., 0. )*data.z;\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//SETTINGS\n#define ZOOM  3.\n#define MS  3.\n#define M 255.\n#define RAIN\n#define DEMOT 30. //enable to switch scenario every 30s\n\n//RESOLUTION\n#define R iResolution.xy\n#define RZ (R/ZOOM  -vec2(0.,10.))\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n//VARIABLES\n#define A(U) texture(iChannel0,(U)/R)\n#define TS vec2(textureSize(iChannel0,0))\n#define DEMO (texture(iChannel0,vec2(RZ.x,0.)).r > 0.)\n#define Neighborhood vec4 n[9] = vec4[] \\\n\t\t(A(U+vec2(-1,1)),  A(U+vec2(0,1)),  A(U+vec2(1,1)),  \\\n         A(U+vec2(-1,0)),  A(U+vec2(0, 0)), A(U+vec2(1,0)), \\\n         A(U+vec2(-1,-1)), A(U+vec2(0,-1)), A(U+vec2(1,-1)));\n#define w(i) n[i].x //water\n#define b(i) n[i].y //barrier\n\n            \n//EMPIRICAL ADJUSTMENT           \n#define OVERFLOW .2 //0.=  waterfalls are always vertical but slow, >.5: water flows lateral in waterfalls\n#define LTRANSF .8 //.5=half difference is transferred lateral (stable but slow) \n//RULES:\n#define RULE1_IN   if(w(1) > 0. && w(4) <M &&  b(4)<1.)  Q.x=min(M, w(4)+w(1))            \n#define RULE1_OUT  if(w(4) >0. && w(7) <M  && b(7) <1.) Q.x =max(0., w(4) + w(7)-M) \n\n//RULE 2 (SEMILATERAL VERSION):                 \n#define RULE2_OUT  if(w(4)>0. && (w(7)>=M*(1.-OVERFLOW) || b(7)>0.)  &&  w(5-i) < w(4)-2. && b(5-i)<1. && w(2-i)<1.) {\\\n  Q.x=w(4)-floor((w(4)-w(5-i)) *LTRANSF);}   \n#define RULE2_IN   if (w(3+i)>0. && (w(6+i)>=M*(1.-OVERFLOW*.4) || b(6+i)>0.) && w(4) < w(3+i) -2. && b(4)<1. && w(1)<1.){ \\\n  Q.x= w(4)+floor((w(3+i)-w(4))*LTRANSF );}\n\n/*\n//RULE 2 (BILATERAL VERSION):\n#define RULE2_OUT  if( w(4)>.0 &&  (w(7)>=M*(1.-OVERFLOW) || b(7)>0.) ) {\\\n  float rd=   ( w(3+i) < w(4)-2. && b(3+i)<1. && w(i)<1.) ? w(4)-w(3+i):0.;\\\n  float ld=   ( w(5-i) < w(4)-2. && b(5-i)<1. && w(2-i)<1.) ? w(4)-w(5-i):0.;\\\n  if(ld+rd>2.) Q.x=w(4)-floor( min(ld+rd,w(4)) *LTRANSF);} \n\n#define RULE2_IN if( b(4)<1. && w(1)<1.){ \\\n  float ld= (w(4) < w(3+i) -2. && w(3+i)>0. && (w(6+i)>=M*(1.-OVERFLOW*.4) || b(6+i)>0.)) ? w(3+i)-w(4) :0.; \\\n  float rd= (w(4) < w(5-i) -2. && w(5-i)>0. && (w(8-i)>=M*(1.-OVERFLOW*.4) || b(8-i)>0.)) ? w(5-i)-w(4) :0.; \\\n  if(ld+rd>2.) Q.x= w(4)+floor(min(ld+rd,M-w(4))*LTRANSF );}             \n*/\n\n//KEYBOARD\n#define CH_SPC 32\n#define CH_SH 16      \n#define keyboard(k) texelFetch(iChannel1, ivec2(k,0), 0).r>.5\n\n//HASH\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nMain {\n    Q =vec4(0.);\n    \n    Neighborhood;\n    // 0 1 2\n    // 3 4 5\n    // 6 7 8    \n    Q = n[4]; //propagate state if nothing happens\n    \n    // DEMO MODE\n    bool demoMode=true;\n    if(iFrame>0) demoMode= DEMO;\n\tif(keyboard(CH_SPC)) demoMode=false;\n\tif(DEMO && !demoMode  && U.x>2. && U.x <RZ.x-2. &&  U.y> 2. ) Q.y=0.;\n\n    //BARRIERS:\n    if (iFrame==0 \n        || (demoMode && mod(iTime,DEMOT)<.2 )         \n        || TS.x != A(vec2(0.)).z){\n        demoMode=true;\n        Q =vec4(0.);\n        if( U.x<=2. || U.x >=RZ.x-2. ||  U.y<= 2.  ) Q=vec4(0.,1.,0.,0.);\n        \n        float ang=.3;\n        vec2 Us = U ;\n        \n        if(demoMode){\n           \n         float mode= mod( iTime/DEMOT,3.);       \n         if(mode>=1.) Us = U + vec2(0., sin(U.x/5.)*5.);\n         if(mode>=2.) Us=U+ vec2(U.x*sin(ang) -U.y*cos(ang),+U.x*cos(ang) +(U.y )* sin(ang));\n\n        //the maze by FabriceN: https://www.shadertoy.com/view/lt2cRR \n         if(RZ.y - U.y>RZ.y*.2) Q.y= step(.4,Q.y +step( mod( (Us/MS) [ int( 1e4*length(ceil(Us/8./MS)) ) % 2 ] , 8. ),.7));\n        }\n    }\n    \n    //WATER UPDATE\n    if(b(4)<1. && U.y>0. && U.y <RZ.y && U.x>1.){\n        Neighborhood;   \n\t\tint i=int(hash12(iTime + U +1.)*2.)*2; //left or right RULE (for semilateraal version)\n\t\t\n        // the order of IN/OUT  for each rule is crucial\n        // neither is better, so i made it randomic\n        \n        //RULE 1 - FALLS       \n        if(hash12(iTime + U)>0.5){\n        \tRULE1_OUT; \n        \tRULE1_IN ;   \n        } else { //inverse order\n        \tRULE1_IN ;    \n\t\t\tRULE1_OUT; \n        }\n        \n        //RULE 2 - LATERAL \n        if(hash12(iTime + U)>.5){ \n            RULE2_OUT;\n            RULE2_IN;          \n        }else{//inverse order           \n            RULE2_IN;\n            RULE2_OUT;  \n       }\n\n    } else Q.x=0.; //out of the grid\n    \n \n#ifdef RAIN \n    //RAIN:\n    if( U.x>1. && abs(U.y-RZ.y+5.)<5.  && hash12(U+iTime)>.995) Q.x=floor(M*.2);\n#endif  \n    \n    //MOUSE \n    if(length(U- floor(iMouse.xy/ZOOM +.5))<1.) Q.z=1.; else Q.z=0.;\n    if (iMouse.z>0.){\n        if(keyboard(CH_SPC) &&  length(U -floor(iMouse.xy/ZOOM +.5))<5.){Q.x =0.; Q.y=1.;}\n        else if(keyboard(CH_SH) &&  length(U -floor(iMouse.xy/ZOOM +.5))<5.){Q.x =0.; Q.y=0.;}\n        else if ( length(U -floor(iMouse.xy/ZOOM +.5))<1.\n        && U.x >1. //&& hash12(U+iTime)>.7\n       \t&& A(iMouse.xy/ZOOM).x <1. )\n        {Q.x =  M; Q.y=0.; }\n\t}\t\n    \n    //CHANGE RESOLUTION DETECTION:\n    if(max(U.x,U.y)<1.) Q.zw= TS.xy; \n    \n    //store demo mode\n    if(demoMode && U.y<1. && U.x>=RZ.x) Q.x=1.;\n  \n}","name":"Buffer A","description":"","type":"buffer"}]}