{"ver":"0.1","info":{"id":"lcGczV","date":"1732097016","viewed":27,"name":"Rotating Bread Alpha Compositing","username":"vitasa","description":"Randomly placing bread and rotating at random speeds.Made each slice transparent and blend with other slices","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["slice","rotation","alpha","position","bread"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy code to render multiple rotating transparent bread slices scattered across the screen\n// with proper alpha compositing (over operator)\n\n// Hash function to generate pseudo-random numbers\nfloat hash(float n) {\n    return fract(sin(n) * 4358.5453123);\n}\n\n// 2D rotation function\nmat2 rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Signed distance function for an ellipse (oval)\nfloat sdEllipse(vec2 p, vec2 r) {\n    vec2 k = abs(p) / r;\n    return (length(k) - 1.0) * min(r.x, r.y);\n}\n\n// Signed distance function for a square (body of the bread)\nfloat sdSquare(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size / 2.0;\n    return max(d.x, d.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    // Adjust for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Number of slices\n    const int numSlices = 15;\n\n    // Bread and background colors\n    vec3 breadColor = vec3(0.95, 0.82, 0.63);       // Light brown bread color\n    vec3 backgroundColor = vec3(0.25, 0.12, 0.13);  // Dark background color\n\n    // Initialize accumulated color and alpha\n    vec3 accumColor = backgroundColor * 0.0; // Start with black, we'll blend in the background later\n    float accumAlpha = 0.0;\n\n    // Loop over slices\n    for (int i = 0; i < numSlices; i++) {\n        // Generate pseudo-random parameters based on the slice index\n        float index = float(i);\n\n        // Random position within [-1, 1]\n        float randX = hash(index * 12.9898);\n        float randY = hash(index * 78.233);\n        vec2 position = vec2(randX * 2.0 - 1.0, randY * 2.0 - 1.0);\n        position.x *= iResolution.x / iResolution.y; // Adjust for aspect ratio\n\n        // Random size between 0.1 and 0.5\n        float sizeFactor = 0.1 + 0.4 * hash(index * 93.433);\n        vec2 squareSize = vec2(sizeFactor);\n        vec2 ovalRadii = vec2(sizeFactor * 0.6, sizeFactor * 0.3);\n\n        // Random initial rotation angle between 0 and 2*pi\n        float initialAngle = hash(index * 45.352) * 6.2831;\n\n        // Random rotation speed between -0.5 and 0.5 radians per second\n        float rotationSpeed = -0.5 + hash(index * 1273.456);\n\n        // Compute total rotation angle\n        float angle = initialAngle + rotationSpeed * iTime;\n\n        // Transform coordinates\n        vec2 p = uv - position;\n        p = rotate2D(angle) * p;\n\n        // Compute signed distances to the square and ellipse\n        float dSquare = sdSquare(p - vec2(0.0, -ovalRadii.y), squareSize);\n        float dOval = sdEllipse(p - vec2(0.0, squareSize.y / 2.0 - ovalRadii.y), ovalRadii);\n\n        // Combine the square and oval using union operation\n        float dSlice = min(dSquare, dOval);\n\n        // Smooth edges for anti-aliasing\n        float thickness = 0.002;\n        float alpha = smoothstep(0.0, thickness, -dSlice);\n\n        // Set bread's opacity (alpha)\n        float breadAlpha = alpha * 0.5; // 50% opacity\n\n        // Alpha compositing using \"over\" operator\n        // Compute the color contribution of this slice\n        vec3 sliceColor = breadColor * breadAlpha;\n\n        // Blend the slice over the accumulated color\n        accumColor = accumColor + sliceColor * (1.0 - accumAlpha);\n        accumAlpha = accumAlpha + breadAlpha * (1.0 - accumAlpha);\n    }\n\n    // Blend the accumulated color with the background color\n    vec3 finalColor = accumColor + backgroundColor * (1.0 - accumAlpha);\n\n    // Set the final fragment color (opaque output)\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}