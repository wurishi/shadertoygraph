{"ver":"0.1","info":{"id":"WlVyW3","date":"1611872778","viewed":333,"name":"Genuary 2021 – 03 – Human","username":"endymion","description":"Genuary 2021 – 03 – Something Human\n\nYou guessed it, it's you. ","likes":2,"published":1,"flags":34,"usePreview":0,"tags":["voronoi","fbm","hexagon","webcam","human"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**\n * Hexagon grid pattern\n * @src https://www.shadertoy.com/view/ll3yW7\n */\nconst vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\n\nvec4 calcHexInfo(vec2 uv) {\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? \n        vec4(offset.xy, hexCenter.xy) : \n        vec4(offset.zw, hexCenter.zw);\n}\n\n/**\n * @main\n * Genuary 03 - Something human\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Hexagons\n    float hexScale = 40.;\n    vec4 hex = calcHexInfo(uv * hexScale);\n    \n    // Get video input\n    vec2 videoUv = vec2(hex.zw / hexScale);\n    videoUv.y = videoUv.y * s.y;; // Flip video input\n    vec3 color = texture(iChannel0, videoUv).rgb;\n    \n\n    // Output\n    fragColor = vec4(color,1.0);\n}\n\n/**\n * @main\n * Renders output from Buffer A\n */\nvoid mainImagePure(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define PI 3.14159265359\n\n/**\n * Utils\n */\nvec2 random(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n/** \n * Noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n */\n \n// Noise: Random\nfloat rand(vec2 c){\n    return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Noise: Basic noise\nfloat noise(vec2 p, float freq){\n    float unit = iResolution.x / freq;\n    vec2 ij = floor(p / unit);\n    vec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n    float a = rand((ij + vec2(0., 0.)));\n    float b = rand((ij + vec2(1., 0.)));\n    float c = rand((ij + vec2(0., 1.)));\n    float d = rand((ij + vec2(1., 1.)));\n    float x1 = mix(a,b,xy.x);\n    float x2 = mix(c,d,xy.x);\n    return mix(x1,x2,xy.y);\n}\n\n/**\n* Fractional Brownian Motion\n* @src https://thebookofshaders.com/13/\n*/\nfloat fbm(in vec2 _st, in int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(_st, 2000. + abs(1000. * sin(iTime * 0.0009)));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n/**\n* RGB to HSB\n* All components are in the range [0…1], including hue.\n* @src https://stackoverflow.com/a/17897228\n*/\nvec3 rgb2hsb(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n/**\n* HSB to RGB\n* All components are in the range [0…1], including hue.\n* @src https://stackoverflow.com/a/17897228\n*/\nvec3 hsb2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/**\n * Voronoi cells\n * @src https://thebookofshaders.com/12/\n */\nfloat voronoi(vec2 st, float scale) {\n    // Scale\n    st *= 3.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimum distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random(i_st + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n            // Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n    \n    return m_dist;\n}\n\n/**\n * @main\n * Genuary 03 - Something human\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Get video input\n    uv.x = 1. - uv.x;; // Mirror video input, cuz it's a webcam\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    // Distance field using Voronoi\n    float m_dist = voronoi(uv, 10.) * 2.;\n\n    // Mess with colors with fbm\n    vec2 r = vec2(0.);\n    r.x = fbm(uv  + 0.10, 1);\n\n    float f = fbm(uv + r, 10);\n    f = f* 0.5 + fbm(vec2(f *0.5), 2);\n    f = f* 0.5 + fbm(vec2(f *0.5), 2);\n\n    color = rgb2hsb(color); // Ah, HSB is so much easier to work with\n    color.x += m_dist * 0.5 + 0.3 * f + 0.5 * f + 0.8 * f;\n    color.y += 0.5 * f;\n    color = hsb2rgb(color);\n    \n\n    // Output\n    fragColor = vec4((f*f*f+.3*f*f+.8*f)*color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}