{"ver":"0.1","info":{"id":"dtjXD1","date":"1676038871","viewed":85,"name":"Menger Sponge Pathtraced","username":"RubberDuck55","description":"A simple image of the menger sponge, path traced","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.a),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 1000.0\n#define SURF_DIST 0.01\n#define MAX_STEP 500\n\n#define NUM_OBJECTS 0\n#define BOUNCES 3\n\n#define DIFF 0\n#define REFL 1\n#define EMIT 2\n#define REFR 3\n\nfloat seed;\n\nstruct Sphere {\n    vec3 pos;\n    float r;\n    vec3 col;\n    float aux;\n    int mat;\n};\n\nstruct ray {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 n, rd, ro;\n    Sphere co;\n};\n\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1415 * 2.;\n    float theta = (rand()-0.5) * 3.1415 * 2.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nmat2 rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sd_box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sd_cross (vec3 p) {\n    float big = 10000000.;\n    float da = sd_box(p, vec3(big,1.0,1.0));\n    float db = sd_box(p, vec3(1.0,big,1.0));\n    float dc = sd_box(p, vec3(1.0,1.0,big));\n    \n    return min(da, min(db, dc));\n}\n\n// Returns distance(float)\nfloat distNearest (vec3 p, out Sphere outS) {\n    vec3 p_copy = vec3(p.xyz);\n    float d = sd_box(p, vec3(3.));\n    \n    float s = 1.0;\n    for( int m=0; m<3; m++ ) {\n    \n        // Change these:\n        //\\\\//\\\\//\\\\//\\\\//\\\\\n        \n        p.xy*=rot(0.1);\n        //p.xz*=rot(0.1);\n        p.yz*=rot(45.);\n        p*=vec3(1.1,1.,1.);\n        \n        //\\\\//\\\\//\\\\//\\\\//\\\\\n        \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = 1.0 - 3.0*abs(a);\n\n        float c = sd_cross(r)/s;\n        d = max(d,c);\n    }\n    \n    outS = Sphere(vec3(0), 0., vec3(255, 254, 215)/255., 1.0, DIFF);\n    \n    return d;\n}\n\nfloat dist(vec3 p) {\n    Sphere s;\n    return distNearest(p, s);\n}\n\n// Returns a normal(vec3) from a point\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\n// Returns object (hit|?|, pos, dist, n|ormal|, rd, ro)\nray raymarch (vec3 ro, vec3 rd) {\n    \n    bool hit = false;\n    \n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        float d = dist(p);\n        \n        if(d < SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if(dO > MAX_DIST) {\n            hit = false;\n        }\n        \n        dO += d;\n    }\n    \n    vec3 p = ro+rd * dO;\n    \n    vec3 n = vec3(0,1,0);\n    if(hit){\n        n = normal(p);\n    }\n    \n    Sphere outS;//Sphere(vec3(0), 0.0, vec3(1.,0.,0.), 1.0, DIFF);\n    distNearest(p, outS);\n    \n    return ray(hit, p, dO, n, ro, rd, outS);\n}\n\nvec3 color (in vec3 ro, in vec3 rd) { \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 col = vec3(0.);\n        ray r = raymarch(ro, rd);\n        \n        col = r.co.col;\n        \n        ro = r.pos + r.n * SURF_DIST * 2.0;\n        \n        if(r.co.mat == DIFF){\n            rd = rand_hemisphere(r.n);\n        }\n        if(r.co.mat == REFL){\n            rd = reflect(rd,r.n);\n            float a = r.co.aux;\n        }\n        if(r.co.mat == EMIT) {\n            rd = vec3(0);\n            \n            fcol *= col * r.co.aux;\n            tcol += fcol;\n            \n            continue;\n        }\n        \n        if(r.hit == false) {\n            col = texture(iChannel1, r.ro).rgb;\n            rd = vec3(0.);\n            \n            fcol *= col;\n            tcol += fcol;\n            \n            continue;\n        }\n        \n        fcol *= col;\n        tcol += fcol * 0.01;\n    }\n    \n    return tcol;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy)-.5)/vec2(iResolution.y/iResolution.x, 1.);\n    \n    init_rand(uv + iTime + 1.0);\n    \n    // Setup for raycast\n    vec2 tv = (((fragCoord+vec2(rand(),rand()))/iResolution.xy)-.5)/vec2(iResolution.y/iResolution.x, 1.);\n    vec3 ro = vec3(0,0,-10.);\n    vec3 rd = normalize(vec3(tv, 1.));\n    \n    // Rotations\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    \n    rd.yz *= rot(-m.y);\n    rd.xz *= rot(-m.x);\n    ro.yz *= rot(-m.y);\n    ro.xz *= rot(-m.x);\n    \n    \n    \n    vec3 col = color(ro, rd);\n    \n    //vec3 col = vec3(raymarch(p, rd).hit ? vec3(1.) : vec3(0.));\n    \n    \n    // Fog\n    // col *= 1.-clamp(o.dist*0.01, 0.0, 1.0);\n\n    if(texelFetch(iChannel0, ivec2(0), 0).xyzw == vec4(iResolution.xy, iMouse.xy)){\n        fragColor = vec4(col, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col, 1.0);\n    }\n    \n    if(ivec2(fragCoord) == ivec2(0))\n        fragColor = vec4(iResolution.xy, iMouse.xy);\n}","name":"Buffer A","description":"","type":"buffer"}]}