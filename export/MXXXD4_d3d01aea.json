{"ver":"0.1","info":{"id":"MXXXD4","date":"1709606371","viewed":61,"name":"Perlin Noise Lighting","username":"mooddood235","description":"Perlin Noise converted into a normal map, then basic lighting applied.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 albedo = vec3(69, 25, 12) / 255.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 normal = texture(iChannel0, uv).rgb;\n    vec3 lightPos =\n        vec3(cos(iTime * 0.5) * 0.7 + 0.5, sin(iTime * 0.5) * 0.7+ 0.5, 1.0);\n    vec3 fragPos = vec3(uv, 0.0);\n    \n    vec3 lightDir = lightPos - fragPos;    \n    vec3 color = \n        vec3(dot(normal, normalize(lightDir)))\n        / (pow(length(lightDir), 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// PCG hash, see:\n// https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\n\n// Used as initial seed to the PRNG.\nuint pcg_hash(uint seed)\n{\n  uint state = seed * 747796405u + 2891336453u;\n  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n  return (word >> 22u) ^ word;\n}\n\n// Used to advance the PCG state.\nuint rand_pcg(inout uint rng_state)\n{\n  uint state = rng_state;\n  rng_state = rng_state * 747796405u + 2891336453u;\n  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n  return (word >> 22u) ^ word;\n}\n\n// Advances the prng state and returns the corresponding random float.\n// Range is [0, 1)\nfloat rand(inout uint state)\n{\n  uint x = rand_pcg(state);\n  state = x;\n  return float(x) / (2.0 * float(0x80000000u));\n}\nint ZtoN(int z){\n    if (z >= 0) return 2 * z;\n    return -2 * z - 1;\n}\nint ZxZtoN(int z0, int z1){\n    int x = ZtoN(z0);\n    int y = ZtoN(z1);\n    return (x + y) * (x + y + 1) / 2 + y;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float PerlinNoise(vec2 uv);\nvec2 GetGradient(vec2 p);\n\nconst float scrollSpeed = 0.1;\nconst int N_OCTAVES = 7;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y + iTime * scrollSpeed;\n       \n    float value = 0.0; \n    float freq = 10.0;\n    float amplitude = 0.45;\n    \n    for (int i = 0; i < N_OCTAVES; i++) {\n        value += PerlinNoise(uv * freq) * amplitude;\n        amplitude *= 0.5;\n        freq *= 2.0;\n    }\n    vec3 n = vec3(uv, value);\n    vec3 color = vec3(value);\n    fragColor = vec4(color, 1.0);\n}\nfloat PerlinNoise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0)), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0)), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1)), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1)), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal * 0.5 + 0.5;\n}\nvec2 GetGradient(vec2 p){\n    int seed = ZxZtoN(int(p.x), int(p.y));\n    uint state = pcg_hash(uint(seed));\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float rand = rand(state);\n    float angle = 6.283185 * rand + 4.0 * rand;\n    return vec2(cos(angle), sin(angle));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 GetNormal(vec2 uv);\nfloat GetHeight(vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 normal = GetNormal(uv);\n    fragColor = vec4(normal, 1.0, 1.0);\n}\nfloat GetHeight(vec2 uv){\n    return texture(iChannel0, uv).r;\n}\nvec2 GetNormal(vec2 uv){\n    float height = GetHeight(uv);\n    return normalize(-vec2(dFdx(height), dFdy(height)));\n}\n","name":"Buffer B","description":"","type":"buffer"}]}