{"ver":"0.1","info":{"id":"3ldcDS","date":"1610014789","viewed":197,"name":"Concentration of attention","username":"savegor","description":"One more particle simulation shader program based on Lennard Jones potential.\nPlease hold the mouse left button to attract particles. It is better to use fullscreen.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["particles","lennardjones"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragCoord += 2.0 * CELL_SIZE;\n    float glow = 0.0;\n    \n    for(float dx = -2.0; dx < 2.01; dx ++) {\n        for(float dy = -2.0; dy < 2.01; dy ++) {\n            vec2 uv = (fragCoord * SCALE + vec2(dx, dy)) / iResolution.xy;\n            vec4 cell_state = texture(iChannel0, uv);\n            float dist = distance(fragCoord, cell_state.xy * CELL_SIZE);            \n            glow += 0.16 / dist;\n        }\n    }\n    \n    fragColor = vec4(glow);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool has_particle(vec4 cell_state, vec2 cell_pos) {\n    // cell state: xyzw -> [x, y, vx, vy]\n    // cell_pos:   xy   -> x,y in {N * 0.5} where N is integer\n    vec2 diff = abs(cell_state.xy - cell_pos);\n\treturn diff.x < 0.5 && diff.y < 0.5;    \n}\n\nvec2 calc_accel(vec4 particle_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(has_particle(cell_state, cell));\n    \n    vec2 diff = particle_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n    float dist = sqrt(sqr_dist);\n    \n    // Lennard Jones potential\n    // r_m = 2^(1/6) sigma\n    const float sigma = 2.5 / 1.122462;\n    const float epsilone = 0.5;\n    \n    // (sigma / r)^2\n    float rat_sqr = sigma * sigma / sqr_dist;\n    \n    float pow6_rat = rat_sqr * rat_sqr * rat_sqr;\n    float pow12_rat = pow6_rat * pow6_rat;\n    \n    vec2 diff_norm = diff / dist;\n    \n    float smooth_switch = smoothstep(dist, 3.0, 2.0);\n    \n    float force = epsilone * (pow12_rat - pow6_rat) * smooth_switch;\n    \n    force = clamp(force, -F_MAX, F_MAX);\n    \n    \n    return particle_in_cell * force * diff_norm * smooth_switch;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cur_cell = fragCoord;\n    \n    int x = int(cur_cell.x);\n    int y = int(cur_cell.y);\n    if(iFrame == 0 && x % 3 == 0 && y % 3 == 0) {\n        vec2 start_velocity = vec2(noise(fragCoord), noise(fragCoord.yx));\n        if(length(start_velocity) > 1.0) {\n            start_velocity = normalize(start_velocity);    \n        }\n\n        // 0.5 pixel per frame is the max value of the each particle velocity\n        // so the relative speed is not exceed 1 pixel per frame\n        start_velocity *= 0.5;\n\n        fragColor = vec4(fragCoord.xy, start_velocity);\n    }\n    else {\n        \n        vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n        vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n\n        \n        if(iFrame % 2 == 0) {\n\t\t\t\n            if(has_particle(cur_state, fragCoord)) {\n                // COLLISION\n                // calculate the repulsion from particles\n                // in the outer boundary:\n                //\n                // * * * * *\n                // *       *\n                // *   O < O\n                // *   ^   *\n                // * * O * *\n                // \n                vec2 accel = vec2(0.0);\n                \n                for(float i = -3.0; i < 3.01; i += 1.0) {\n                    for(float j = -3.0; j < 3.01; j += 1.0) {\n                        if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        \taccel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                        }\n                    }\n                }\n\t\t\t\t\n\n                cur_state.zw += accel;\n                \n                // MOUSE FORCE\n                vec2 mouse_pos = iMouse.xy * SCALE;\n                if(iMouse.z > 0.0) {\n                    vec2 mouse_diff = mouse_pos - cur_state.xy;\n                    float mouse_dist = length(mouse_diff);\n                    \n                    float sgn = sign(CELL_SIZE * 4.0 - mouse_dist);\n                    \n                    sgn *= sign(CELL_SIZE * 11.0 - mouse_dist);\n                    \n                    cur_state.zw += 0.02 * mouse_diff * (sgn / mouse_dist);\n                \n                }\n                \n                // FRICTION\n                cur_state.zw *= 0.97;\n\n                // velocity normalization\n                float velocity = length(cur_state.zw);\n                float new_vel = clamp(velocity, 0.0, 0.5);\n                cur_state.zw = cur_state.zw / velocity * new_vel;   \n                \n                fragColor = cur_state;\n            }\n        }\n        else {\n            // MOTION\n            // simulation the particle propagation from the \n            // neighbouring cells into current one:\n            //\n            //  ____________________\n            // |      |      |      |\n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      |\n            // |  O---|->    |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      | \n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            //\n\n            \n            // 1) cur state is empty (we could add here a check for boundaries)\n            if(!has_particle(cur_state, cur_cell)) {\n                \n                int count = 0;\n                \n                for(int i = 0; i < 8; ++i) {\n                    vec2 nb_cell = cur_cell + SHIFTS[i];\n\n                    vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\t\t\t\t\t\n                    // position of particle moved from the neighboring cell\n                    vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\t\t\t\t\t\n                    // diff from the current cell to the neighbouring cell particle\n                    vec2 nb_particle_diff = abs(cur_cell - nb_pos_after_move);\n\n                    if(nb_particle_diff.x < 0.5 &&\n                       nb_particle_diff.y < 0.5 ) {\n                        count++;\n                        next_state.xy = nb_pos_after_move; // coord\n                        next_state.zw = nb_state.zw;    // velocity\n                    }\n                }\n                \n                float can_move = float(count == 1);\n                \n                fragColor = next_state * can_move;\n            }\n            // 2) cur state is not empty\n            else {\n                // if the current particle move away from the \n                // current cell we need to additional check\n                // that this particle is the nearest to the next one\n                \n                vec2 target_pos = cur_state.xy + cur_state.zw;\n                vec2 target_cell = floor(target_pos) + vec2(0.5, 0.5);\n                                \n                // if we the particle in the current cell\n                if(distance(target_cell, cur_cell) < 0.1) {\n                    next_state.xy = target_pos;\n                    next_state.zw = cur_state.zw;\n                }\n                //try to move to the next cell\n                else {                    \n                    vec2 cell_shift = cur_cell - target_cell;\n                                        \n                    int count = 0;\n                    \n                    for(int i = 0; i < 8; ++i) {\n                        vec2 nb_cell = target_cell + SHIFTS[i];\n                        \n                        vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\n                        vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\t\t\t\t\t\t\n                        vec2 nb_particle_diff = abs(target_cell - nb_pos_after_move);\n\n                        count += int(nb_particle_diff.x < 0.5 && nb_particle_diff.y < 0.5);\n\n                    }\n                    \n                    vec4 target_state = texture(iChannel0, target_cell / iResolution.xy);\n\n                    float unable_move = float(count != 1 || has_particle(target_state, target_cell));\n                    \n                    next_state = vec4(cur_state.xy, cur_state.zw * 0.6) *  float(unable_move);\n                }\n                \n                fragColor = next_state;\n\n            }\n            \n        }\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float F_MAX = 0.8;\nconst float CELL_SIZE = 6.0;\nconst float SCALE = 1.0 / CELL_SIZE;\n\nconst vec2 SHIFTS[8] = vec2[8](\n    vec2(-1, -1),\n    vec2(-1,  0),\n    vec2(-1,  1),\n    vec2(0,  -1),\n    vec2(0,   1),\n    vec2(1,  -1),\n    vec2(1,   0),\n    vec2(1,   1)\n);","name":"Common","description":"","type":"common"}]}