{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//==============================================\n// Structs\n//==============================================\nstruct SCircle\n{\n\tvec2  m_center;\n\tfloat m_radius;\n\tvec3  m_color;\n};\n\t\nstruct STriangle\n{\n\tvec2 m_pointA;\n\tvec2 m_pointB;\n\tvec2 m_pointC;\n\tvec3 m_color;\n};\n\t\nstruct SSquare\n{\n\tvec2 m_pointA;\n\tvec2 m_pointB;\n\tvec2 m_pointC;\n\tvec2 m_pointD;\n\tvec3 m_color;\t\n};\n\t\nstruct SPentagon\n{\n\tvec2 m_pointA;\n\tvec2 m_pointB;\n\tvec2 m_pointC;\n\tvec2 m_pointD;\n\tvec2 m_pointE;\n\tvec3 m_color;\t\n};\n\t\nstruct SBestHit\n{\n\tfloat m_dist;\n\tvec3 m_color;\n};\n\n//==============================================\n// Functions for global object support\n//==============================================\nvec2 Rotate2d (vec2 point, float angle)\n{\n\treturn vec2\n\t\t(\n\t\t\tpoint.x * cos(angle) - point.y * sin(angle),\n\t\t\tpoint.y * cos(angle) + point.x * sin(angle)\n\t\t);\n}\n\t\n//==============================================\n// Objects\n//==============================================\nSCircle circle1 =\n\tSCircle\n\t(\n\t\tvec2(0.5,0.5),\n\t\t0.1,\n\t\tvec3(1.0,0.0,0.0)\n\t);\n\t\nSCircle circle2 =\n\tSCircle\n\t(\n\t\tvec2(1.3,0.3),\n\t\t0.15,\n\t\tvec3(0.0,1.0,0.0)\n\t);\t\n\nSCircle circle3 =\n\tSCircle\n\t(\n\t\tvec2(1.2,0.8),\n\t\t0.01 + (sin(iTime*0.87) + 1.0) * 0.05,\n\t\tvec3(0.0,0.0,1.0)\n\t);\n\nvec2 triangle1Offset = vec2(cos(iTime*0.93)*0.1, sin(iTime*0.93)*0.1);\nSTriangle triangle1 =\n\tSTriangle\n\t(\n\t\tvec2(0.8, 0.3) + triangle1Offset,\n\t\tvec2(0.9, 0.4) + triangle1Offset,\n\t\tvec2(1.0, 0.3) + triangle1Offset,\n\t\tvec3(1.0,1.0,0.0)\n\t);\n\n\nfloat square1Rotation = iTime * 0.74;\nvec2 square1Pos = vec2(1.0, 0.6);\nSSquare square1 =\n\tSSquare\n\t(\n\t\tRotate2d(vec2(-0.025,  0.1), square1Rotation) + square1Pos,\n\t\tRotate2d(vec2( 0.025,  0.1), square1Rotation) + square1Pos,\n\t\tRotate2d(vec2( 0.025, -0.1), square1Rotation) + square1Pos,\n\t\tRotate2d(vec2(-0.025, -0.1), square1Rotation) + square1Pos,\n\t\tvec3(1.0,0.0,1.0)\n\t);\n\nvec2 pentagon1Offset = vec2(0.0, sin(iTime * 0.83) * 0.5 + 0.5);\nSPentagon pentagon1 =\n\tSPentagon\n\t(\n\t\tvec2(0.05, 0.0)   + pentagon1Offset,\t\t\n\t\tvec2(0.05, 0.05)  + pentagon1Offset,\n\t\tvec2(0.1 , 0.1)   + pentagon1Offset,\t\t\n\t\tvec2(0.15, 0.05)  + pentagon1Offset,\n\t\tvec2(0.15, 0.0)   + pentagon1Offset,\n\t\tvec3(0.0,1.0,1.0)\n\t);\n\n//==============================================\n// Macro lists\n//==============================================\n\n#define SHAPES CIRCLE(circle1) CIRCLE(circle2) CIRCLE(circle3) TRIANGLE(triangle1) SQUARE(square1) PENTAGON(pentagon1)\n\n//==============================================\n// taken from \"real time collision detection\" 5.1.9.1\nfloat Signed2DTriArea (vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\n}\n\n//==============================================\nfloat SignedDistanceToLineSegment (in vec2 coordinate, in vec2 pointA, in vec2 pointB)\n{\n\tvec2 AB = pointB - pointA;\n\tfloat ABlen = length(AB);\n\tAB = normalize(AB);\n\tvec2 AtoCoord = coordinate - pointA;\n\t\n\tfloat proj = dot(AtoCoord, AB);\n\tproj = max(proj, 0.0);\n\tproj = min(proj, ABlen);\n\tvec2 closestPoint = pointA + AB * proj;\n\t\n\tfloat sign = Signed2DTriArea(coordinate, pointA, pointB);\n\tif (sign > 0.0)\n\t\treturn length(closestPoint - coordinate);\n\telse\n\t\treturn -length(closestPoint - coordinate);\n}\n\n//==============================================\nvoid TestPentagon (in vec2 coordinate, in SPentagon pentagon, inout SBestHit bestHit)\n{\n\t// get the distance to each segment\n\tfloat distAB = SignedDistanceToLineSegment(coordinate, pentagon.m_pointA, pentagon.m_pointB);\n\tfloat distBC = SignedDistanceToLineSegment(coordinate, pentagon.m_pointB, pentagon.m_pointC);\n\tfloat distCD = SignedDistanceToLineSegment(coordinate, pentagon.m_pointC, pentagon.m_pointD);\n\tfloat distDE = SignedDistanceToLineSegment(coordinate, pentagon.m_pointD, pentagon.m_pointE);\n\tfloat distEA = SignedDistanceToLineSegment(coordinate, pentagon.m_pointE, pentagon.m_pointA);\n\t\n\t// if all distances are negative, the point is inside\n\tif (distAB < 0.0 && distBC < 0.0 && distCD < 0.0 && distDE < 0.0 && distEA < 0.0)\n\t{\n\t\tfloat dist = min(distAB, min(distBC, min(distCD, min(distDE, distEA))));\n\t\tif (dist < bestHit.m_dist)\n\t\t{\n\t\t\tbestHit.m_dist = dist;\n\t\t\tbestHit.m_color = pentagon.m_color;\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\n\t// get the minimum positive distance\n\tfloat dist = 100.0;\n\tif (distAB >= 0.0 && distAB < dist)\n\t\tdist = distAB;\n\t\n\tif (distBC >= 0.0 && distBC < dist)\n\t\tdist = distBC;\t\n\n\tif (distCD >= 0.0 && distCD < dist)\n\t\tdist = distCD;\n\t\n\tif (distDE >= 0.0 && distDE < dist)\n\t\tdist = distDE;\t\n\t\n\tif (distEA >= 0.0 && distEA < dist)\n\t\tdist = distEA;\t\n\n\t// if we are the new winner, set us as the best hit\n\tif (dist < bestHit.m_dist)\n\t{\n\t\tbestHit.m_dist = dist;\n\t\tbestHit.m_color = pentagon.m_color;\t\t\t\n\t}\n}\n\n//==============================================\nvoid TestSquare (in vec2 coordinate, in SSquare square, inout SBestHit bestHit)\n{\n\t// get the distance to each segment\n\tfloat distAB = SignedDistanceToLineSegment(coordinate, square.m_pointA, square.m_pointB);\n\tfloat distBC = SignedDistanceToLineSegment(coordinate, square.m_pointB, square.m_pointC);\n\tfloat distCD = SignedDistanceToLineSegment(coordinate, square.m_pointC, square.m_pointD);\n\tfloat distDA = SignedDistanceToLineSegment(coordinate, square.m_pointD, square.m_pointA);\n\t\n\t// if all distances are negative, the point is inside\n\tif (distAB < 0.0 && distBC < 0.0 && distCD < 0.0 && distDA < 0.0)\n\t{\n\t\tfloat dist = min(distAB, min(distBC, min(distCD, distDA)));\n\t\tif (dist < bestHit.m_dist)\n\t\t{\n\t\t\tbestHit.m_dist = dist;\n\t\t\tbestHit.m_color = square.m_color;\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\n\t// get the minimum positive distance\n\tfloat dist = 100.0;\n\tif (distAB >= 0.0 && distAB < dist)\n\t\tdist = distAB;\n\t\n\tif (distBC >= 0.0 && distBC < dist)\n\t\tdist = distBC;\t\n\n\tif (distCD >= 0.0 && distCD < dist)\n\t\tdist = distCD;\n\t\n\tif (distDA >= 0.0 && distDA < dist)\n\t\tdist = distDA;\t\n\t\n\t// if we are the new winner, set us as the best hit\n\tif (dist < bestHit.m_dist)\n\t{\n\t\tbestHit.m_dist = dist;\n\t\tbestHit.m_color = square.m_color;\t\t\t\n\t}\n}\n\n//==============================================\nvoid TestTriangle (in vec2 coordinate, in STriangle triangle, inout SBestHit bestHit)\n{\n\t// get the distance to each segment\n\tfloat distAB = SignedDistanceToLineSegment(coordinate, triangle.m_pointA, triangle.m_pointB);\n\tfloat distBC = SignedDistanceToLineSegment(coordinate, triangle.m_pointB, triangle.m_pointC);\n\tfloat distCA = SignedDistanceToLineSegment(coordinate, triangle.m_pointC, triangle.m_pointA);\n\t\n\t// if all distances are negative, the point is inside the triangle\n\tif (distAB < 0.0 && distBC < 0.0 && distCA < 0.0)\n\t{\n\t\tfloat dist = min(distAB, min(distBC, distCA));\n\t\tif (dist < bestHit.m_dist)\n\t\t{\n\t\t\tbestHit.m_dist = dist;\n\t\t\tbestHit.m_color = triangle.m_color;\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\n\t// get the minimum positive distance\n\tfloat dist = 100.0;\n\tif (distAB >= 0.0 && distAB < dist)\n\t\tdist = distAB;\n\t\n\tif (distBC >= 0.0 && distBC < dist)\n\t\tdist = distBC;\t\n\n\tif (distCA >= 0.0 && distCA < dist)\n\t\tdist = distCA;\t\t\n\n\t// if we are the new winner, set us as the best hit\n\tif (dist < bestHit.m_dist)\n\t{\n\t\tbestHit.m_dist = dist;\n\t\tbestHit.m_color = triangle.m_color;\t\t\t\n\t}\n}\n\n\n//==============================================\nvoid TestCircle (in vec2 coordinate, in SCircle circle, inout SBestHit bestHit)\n{\n\tfloat dist = length(circle.m_center - coordinate) - circle.m_radius;\n\tif (dist < bestHit.m_dist)\n\t{\n\t\tbestHit.m_dist = dist;\n\t\tbestHit.m_color = circle.m_color;\n\t}\n}\n\n//==============================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get our 2d coordinates where y is from 0 to 1, and x is from\n\t// whatever is needed to correct for aspect ration\n\tvec2 coord = fragCoord.xy / iResolution.xy;\n\tcoord.x *= (iResolution.x / iResolution.y);\n\t\n\t// init best hit distance to some large number and black color\n\tSBestHit bestHit =\n\t\tSBestHit\n\t\t(\n\t\t\t100.0,\n\t\t\tvec3(0.0,0.0,0.0)\n\t\t);\n\n\t// test our shapes\n\t#define CIRCLE(x)   TestCircle(coord, x, bestHit);\n\t#define TRIANGLE(x) TestTriangle(coord, x, bestHit);\n\t#define SQUARE(x)   TestSquare(coord, x, bestHit);\n\t#define PENTAGON(x) TestPentagon(coord, x, bestHit);\n\tSHAPES\n\t#undef PENTAGON\n\t#undef SQUARE\n\t#undef TRIANGLE\n\t#undef CIRCLE\t\t\n\t\n\t// display our result\n\tif (bestHit.m_dist <= 0.0)\n\t\tfragColor = vec4(bestHit.m_color, 1.0);\n\telse\n\t\tfragColor = vec4(bestHit.m_color * 0.5, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsX3Ds","date":"1381376404","viewed":192,"name":"Point Object Promixity 2d","username":"demofox","description":"The color of each pixel represents which shape it's closest to.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["visualization","experimental"],"hasliked":0,"parentid":"","parentname":""}}