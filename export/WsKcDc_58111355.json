{"ver":"0.1","info":{"id":"WsKcDc","date":"1606048879","viewed":169,"name":"Mandebrot on water","username":"NivBehar","description":"mandelbrot","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).xyz;\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\nvec3 col_1(float j, float repeat, vec3 offset)\n{\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n\n    return a1 + b1 * cos(2.*PI*(sqrt(j) * repeat + d1 + offset));\n}\nvec3 col_2(float j, float repeat, vec3 offset)\n{\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    return a2 + b2 * cos(2.*PI*(sqrt(j) * repeat + d2 + offset));\n}\nvec3 col_3(float j, float repeat, vec3 offset)\n{\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 d3 = vec3(0., 0., 0.);\n    return a3 + b3 * cos(2.*PI*(sqrt(j) * repeat + d3 + offset));\n}\nvec3 col_4(float j, float repeat, vec3 offset)\n{\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    return a4 + b4 * cos(2.*PI*(sqrt(j) * repeat + d4 + offset));\n}\nvec3 col_5(float j, float repeat, vec3 offset)\n{\n    // Color 5 - \n    vec3 a5 = vec3(0.5, 0.4, 0.56);\n    vec3 b5 = vec3(0.5, 0.7, 0.8);\n    vec3 d5 = vec3(0.6, 0.7, 0.79);\n    return a5 + b5 * cos(2.*PI*(sqrt(j) * repeat + d5 + offset));\n}\nfloat lum(vec3 col)\n{\n    return 0.21 * col.r + 0.71 * col.g + 0.07 * col.b;\n}\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 2\n#define ITERATIONS 200.\n#define COLOR_REPEAT 0.3\n#define MANIPULATED 1.\n#define SHAPE 4\n#define time iTime\n\n#define q1 0.7\n#define q2 0.5\n#define q3 0.5\n\n#define loww 0.3\n#define q5 time*13.5*loww\n#define q6 time*14.6*loww\n#define q7 time*12.7*loww\n#define q8 time*1.1*loww\n\n// calculate light\n// https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set#Normal_map_effect\nfloat calc_light(vec2 z, vec2 der, float h, float angle)\n{\n    //float h = 1.3;  // height factor of the incoming light  \n    //float angle = PI/5.;// + sin(time)*0.3; // incoming direction of light\n    vec2 v = vec2 (cos(angle), sin(angle)); // unit 2D vector in this direction\n    vec2 u = (1./(der.x*der.x + der.y*der.y))*vec2(z.x*der.x + z.y*der.y, z.y*der.x - z.x*der.y);// = z/der\n    u = u/length(u); // normal vector: (u.re,u.im,1)\n    float t = (u.x*v.x + u.y*v.y) + h; // dot product with the incoming light\n    t = t/(1.+h); // rescale so that t does not get bigger than 1\n    if(t<0.)\n        t = 0.;\n    float light = mix(1.,0.,t);\n    return light;\n}\nvec3 iterate(vec2 UV)\n{\n    vec3 col;\n\t    vec3 end_col = vec3(0.);\n    vec3 end_colA = vec3(0.);\n    vec3 end_colB = vec3(0.);\n    float uv_rot_speed = time*0.1;\n    //\tUV += 0.5*vec2(sin(uv_rot_speed), cos(uv_rot_speed));\n    //UV = UV/dot(UV,UV);\n    vec2 zA = UV;\n    vec2 zB = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    float GOLDEN = 0.;\n    //vec2 shapes[11] = {zA, vec2(0, 1-GOLDEN), vec2(GOLDEN-2, GOLDEN-1), vec2(0.285, 0.), vec2(0.285, 0.01), vec2(0.45, 0.1428), vec2(-0.70176, -0.3842), vec2(-0.835, -0.2321),\n    //    \t\t\t\t vec2(-0.8, 0.156), vec2(-0.7269, 0.1889), vec2(-0.754, -0.066)};\n    float[] x = float[] (zA.x, 0.       , GOLDEN-2., 0.285, 0.285 , 0.45  , -0.70176, -0.835 , -0.8 , -0.7269, -0.754);\n    float[] y = float[] (zA.y, 1.-GOLDEN, GOLDEN-1., 0.01 , 0.01  , 0.1428, -0.3842 , -0.2321, 0.156, 0.1889 , -0.066);\n    \n    vec2 shape;\n    //shape = vec2(0.285, 0.0103);\n    //shape = vec2(-0.70176, -0.3842);\n    shape = vec2(x[SHAPE], y[SHAPE]);// + 0.00013*vec2(cos(q5*0.2),sin(q6*0.2));\n\n    vec2 dc = vec2(1.,0.);\n    vec2 derA = dc;\n    vec2 derB = dc;\n    vec2 prev_derA;\n    vec2 prev_derB;\n    \n    float rA = 100.;\n    float rB = 100.;\n\n    float iA = 0.; // for regular mandelbrot\n    float iB = 0.; // for manipulated mandelbrot\n\n    float breakloopA = 0.; // for regular mandelbrot\n    float breakloopB = 0.; // for manipulated mandelbrot\n    float dummy_counter = 0.;\n    while((breakloopA == 0. || breakloopB == 0. ) && (iA < ITERATIONS || iB < ITERATIONS) && dummy_counter < 2.*ITERATIONS)\n    {   \n\n            //Flowers\n            \t//vec2 z2 = rot(z, 0, time*0.4);\n            //r = 2. + 1.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));            \n            \n            //Fingers\n            /*float k1 = 0.;//4;\n            float k2 = 1.;\n            vec2 z1 = 2.*zB/dot(zB + k1*cos(zA*k2),zB + k1*sin(zB*k2));\n            vec2 z2 = rot(z1, zB, 2. + (q5+q6+q7)*0.01);\n            rB = 7. + 2.*TriangleDist(rot(zB,vec2(0.),q8),  + vec2(2000000000.,2000000000.));//*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), vec2(1000.,3.2));\n            */\n            float k1 = 0.;//4;\n            float k2 = 1.;\n            vec2 z1 = 2.*zB/dot(zB + k1*cos(zA*k2),zB + k1*sin(zB*k2));\n            vec2 z2 = rot(z1, zB, 2. + (q5+q6+q7)*0.01);\n            rB = 7. + 2.*TriangleDist(rot(zB,vec2(0.),q8*6.*0.), vec2(3.,(20.+ 2000000000.+18.*sin(q8*4.))*(6.+sin(q5*0.3*0.))));//*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), float2(1000.,3.2));\n\n        \n            //Hair\n            //vec2 z2 = rot(z, 0, time*0.4);\n            //r = 3. + 2.*TriangleDist(sin(cos(z2*PI+time)*0.5 + 5.)*cos(cos(z2*PI)), vec2(50.,3.2));\n        \n        /*float epsilon = 0.09;\n        if(length(der) < epsilon)\n        {\n            end_col = vec3(0.1,0.3,0.6);\n        }*/\n        \n        vec2 derA_new = 2. * vec2(derA.x*zA.x - derA.y*zA.y, derA.x*zA.y + derA.y*zA.x) + dc;\n        vec2 derB_new = 2. * vec2(derB.x*zB.x - derB.y*zB.y, derB.x*zB.y + derB.y*zB.x) + dc;\n        //vec2 zXder = vec2(z.x * der.x - z.y * der.y, z.x * der.y + z.y * der.x);\n        \n        //if(length(rot(der,der_new,time*4)) > r)\n        if(length(zA) > rA)\n        {\n            breakloopA = 1.;\n        }\n        if(length(zB) > rB)\n        {\n            breakloopB = 1.;\n        }\n\n        // calculate derivative\n        if(breakloopA == 0.)\n        {\n            derA = derA_new;//2. * vec2(der.x*z.x - der.y*z.y, der.x*z.y + der.y*z.x) + dc;\n            zA = vec2(zA.x * zA.x - zA.y * zA.y, 2. * zA.x * zA.y) + shape;\n            iA++;\n        }\n        if(breakloopB == 0.)\n        { \n            derB = derB_new;\n            zB = vec2(zB.x * zB.x - zB.y * zB.y, 2. * zB.x * zB.y) + shape;\n            iB++;\n        }\n    \n\n/*        if(breakloopA == 0)\n            iA++;\n        if(breakloopB == 0)\n            iB++;\n*/\n        dummy_counter ++;\n    }\n\n    if(iA >= ITERATIONS)\n    {\n        end_colA = vec3(0.);\n    }\n    else\n    {\n        float fraciterA = log2( log(length(zA)) / log(rA) );\n        //float fraciterB = log2( log(length(zB)) / log(rB) );\n        \n        float jA = iA;\n        //float jB = iB;\n        //if(breakloopA == 0) // right side\n        jA -= fraciterA;\n\n        float flicker_treb = min(q1,1.);//0.891-min(q1, 0.89);//(0.5+0.7*(cos(sin(time*15.) + sin(cos(11.*time))) + sin(cos(5.*time))));\n        float flicker_mid = min(q2,1.);//0.891-min(q2, 0.89);\n        float flicker_bass = min(q3,1.);//0.891-min(q3, 0.89);\n\n        float light_speed_mul = 0.07;\n\n        float light1 = calc_light(zA, derA, 1.3, time*0.8);\n\n        float light2 = calc_light(zA, derA,1.00, 0.5*q7*light_speed_mul);\n        light2 = pow(light2, 2000. - 1850.*flicker_bass);\n        light2 = clamp(0.,1.,light2);\n\n        float light3 = calc_light(zA, derA,1.00, -q6*light_speed_mul);\n        light3 = pow(light3, 2000. - 1800.*flicker_mid );\n        light3 = clamp(0.,1.,light3);\n\n        float light4 = calc_light(zA, derA,1.00, q5*light_speed_mul);\n        light4 = pow(light4, 500. - 460.*flicker_treb);\n        light4 = clamp(0.,1.,light4);\n /*\n        float b = 50.;\n        float light5 = calc_light(zA, derA, 1., 2.*PI*0.875 + floor(q8*PI*2.));\n        light5 = pow(light5, b);\n        light5 = clamp(0.,1.,light5);\n\n        float light6 = calc_light(zA, derA, 1., 2.*PI*0.875 + 2.*PI/3. + floor(q8*PI*2.));\n        light6 = pow(light6, b);\n        light6 = clamp(0.,1.,light6);\n\n        float light7 = calc_light(zA, derA, 1., 2.*PI*0.875 + 4.*PI/3. + floor(q8*PI*2.));\n        light7 = pow(light7, b);\n        light7 = clamp(0.,1.,light7);\n*/\n        light1 *= (1.-min(q3,1.)*light2)*(1.-min(q2,1.)*light3)*(1.-min(q1,1.)*light4);     \n\n        vec3 col1 = col_1(jA, COLOR_REPEAT*2., vec3((q5+q6+q7)*0.02));\n        //vec3 col12 = col_1(jA, COLOR_REPEAT*20., time*3.);\n        //vec3 col13 = col_1(jA, COLOR_REPEAT*1.4, time*0.1);\n        //vec3 col2 = col_2(jA, COLOR_REPEAT, vec3(time*0.5));\n        //vec3 col2_light3 = col_2(jA, COLOR_REPEAT, vec3(q6*0.1));\n        vec3 col2_light4 = col_2(jA, COLOR_REPEAT*8., vec3(q5*0.1));\n        //vec3 col3 = col_3(jA, COLOR_REPEAT, vec3(time*0.5));\n        vec3 col4 = col_4(jA, COLOR_REPEAT*5., vec3(time));\n        vec3 col5 = col_5(jA, COLOR_REPEAT*2., vec3((q5+q6+q7)*0.02 + time*0.4));\n        vec3 col5_light3 = col_5(jA, COLOR_REPEAT*8., vec3(q6*0.1));        \n        //vec3 col5_light2 = col_5(jA, COLOR_REPEAT*25., vec3(time*0.2));\n\n        //vec3 col2_light5 = col_2(jA, COLOR_REPEAT*5., vec3(q5*0.1));\n        //vec3 col1_light6 = col_1(jA, COLOR_REPEAT*5., vec3(q6*0.1));\n        //vec3 col3_light7 = col_3(jA, COLOR_REPEAT*5., vec3(q7*0.1));\n\n\n        //end_col = vec3(sqrt(j*0.01));\n        //end_col = col4 * pow(light,1.) + col12*(pow(1.-light,2000.));\n        end_colA = col5*light1 + min(q3,1.)*col4*light2 + min(q2,1.)*col5_light3*light3 + min(q1,1.)*col2_light4*light4;//col22*light2 + col22*light3;\n        //end_colA = col1*light1 + min(q3,1.)*col4*light2 + min(q2,1.)*col5_light3*light3 + min(q1,1.)*col2_light4*light4;//col22*light2 + col22*light3;\n        //end_col = col2_light3*light3;\n        \n        //end_col = col1*light1\n        //          + light5*col2_light5*min(q12,1) \n        //          + light6*col1_light6*min(q13,1)\n        //          + light7*col3_light7*min(q14,1);        \n        \n    }\n    if(iB >= ITERATIONS)\n    {\n        end_colB = vec3(0.);\n    }\n    else\n    {\n        float fraciterB = log2( log(length(zB)) / log(rB) );\n        float jB = iB;\n        jB -= fraciterB;\n        end_colB = col_1(jB, COLOR_REPEAT*2., vec3(q8*2.));\n\n        float leaves = smoothstep(-0.2,1.2,fraciterB);\n        end_colB *= leaves*2.;\n        //end_colB = leaves;\n        end_colB *= min(q2,1.);\n    }\n    end_colA = clamp(end_colA, vec3(0.), vec3(1.));\n    end_colB = clamp(end_colB, vec3(0.), vec3(1.));\n    float end_colA_alpha = lum(end_colA);\n    float end_colB_alpha = lum(end_colB); \n    end_col = end_colA*(1.-end_colB_alpha) + end_colB;\n    //end_col = end_colB;\n    return end_col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    \n    float zoom = 0.9;//1. + 0.8*sin(sin(time*0.1))*cos(time*0.2);\n\n    #if AA\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n        uv.y -= 0.45;\n        uv.x += 0.4*sin(time*0.089);\n            // water by martin (Milkdrop)\n            vec2 uv1 = uv+vec2(0.6,0.51);//-0.0*vec2(0.6,0.44);//*(1.2+0.1*(sin(cos(time*0.3)*0.451 + 0.392*sin(time*0.8)*cos(time*0.3))));\n            float z = 0.2/(uv1.y);\n            vec2 rs0 = vec2(uv1.x * z, z);\n            vec2 rs = (rs0 + vec2(0.,-time*0.05));\n            vec3 water = texture(iChannel0,rs*0.5).xyz*0.3 + 0.1*texture(iChannel0,rs*2.).xyz/2.-0.75;\n            vec2 uv_wat = (uv+water.xy*0.1/z);\n    \t\tfloat mask = 0.4/z;//clamp(0.4/z, 0., 1.);\n    \t\tuv = mix(uv,uv_wat,smoothstep(0.,-0.3,mask));\n\t   col += iterate( uv);\n            col += smoothstep(0.8,2.,1.-mask)*vec3(0.8,0.2,0.7);\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n    uv.y -= 0.45;\n    uv.x += 0.4*sin(time*0.089);\n\tvec3 col = iterate(uv);\n    \n    #endif\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}