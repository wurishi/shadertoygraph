{"ver":"0.1","info":{"id":"4dcXWH","date":"1458936780","viewed":165,"name":"Life Spirit","username":"JoNil","description":" ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat hash(in vec2 p, float scale)\n{\n    return fract(sin(mod(p.x, scale)*17.31758341 + p.y*39.786792357 - 7.5312) * 43758.236237153);\n}\n\n// iqnoise adapted from voronoise (Perlin noise)\n// this version uses radial symmetry\nfloat iqnoise(float radius, float angle, float angle_scale)\n{\n    angle *= angle_scale;\n    \n    vec2 p = floor(vec2(angle, radius));\n    vec2 f = fract(vec2(angle, radius));\n    \n    float va = 0.0;\n    float wt = 0.0;\n    \n    for (int j = -1; j <= 2; j++) {\n        for (int i = -1; i <= 2; i++) {\n            \n            if (i+j>3 || i+j<-1) {\n                continue;\n            }\n            if (i-j>2 || i-j<-2) {\n                continue;\n            }\n            \n            vec2 g = vec2(float(i),float(j));\n            float o = hash(p + g, angle_scale);\n            vec2 r = g - f ;\n            float d = dot(r,r);\n            float ww =  1.0 - smoothstep(0.0, 1.4142, sqrt(d));\n            va += o*ww;\n            wt += ww;\n        }\n    }\n    \n    return 2.0*va/wt - 1.0;\n}\n\n\nvec3 core(vec2 p, float r)\n{\n    float final1 = iqnoise(30.0*p.x*pow(r, 0.55)- 0.5*iTime, p.y*pow(r, 0.55), 30.0) * 4.0;\n    float final2 = iqnoise(30.0*p.x*pow(r, 0.6)- 0.5*iTime, p.y*pow(r, 0.6), 30.0) * 4.0;\n    float final3 = iqnoise(30.0*p.x*pow(r, 0.65)- 0.5*iTime, p.y*pow(r, 0.65), 30.0) * 4.0;\n    \n    return mix(vec3(final1, final2, final3), vec3(0.0, 0.0, 0.0), clamp(r, 0.0, 1.0));\n}\n\nvec3 edge(float r, float phi)\n{\n    float radial1 = iqnoise(10.0 * r - 0.3*iTime, phi + 0.01*sin(19.5 * r - iTime), 80.0) * 4.0;\n    float final1 = mix(radial1, 0.0, 1.0 - r);\n    \n    float radial2 = iqnoise(10.0 * r - 0.3*iTime, phi + 0.01*sin(20.0 * r - iTime), 80.0) * 4.0;\n    float final2 = mix(radial2, 0.0, 1.0 - r);\n    \n    float radial3 = iqnoise(10.0 * r - 0.3*iTime, phi + 0.01*sin(20.5 * r - iTime), 80.0) * 4.0;\n    float final3 = mix(radial3, 0.0, 1.0 - r);\n\n    vec3 color = vec3(final1, final2, final3);\n    \n    return mix(color, vec3(0.0, 0.0, 0.0), clamp(r*r*r, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = (uv - 0.5) * 2.0 * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float r = sqrt(dot(p, p));\n    float phi = atan(p.x, p.y) / (2.0 * PI);\n    \n    vec3 edge_color = edge(r, phi);\n    vec3 core_color = core(p, r);\n    \n        \n    fragColor = vec4(mix(edge_color, core_color, clamp(1.0 - (atan(80.0*(r - 0.55 - 0.03*sin(iTime))) / PI + 0.5), 0.0, 1.0)), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}