{"ver":"0.1","info":{"id":"dt3XR7","date":"1685177228","viewed":115,"name":"Fork SunflowerTransform","username":"Carandiru","description":"finally found this, just experimenting.\n\nAn efficient (loop-less) transformation to \"sunflower coordinates\".","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["spiral","sunflower","loopless","coordinatetransformation","vogelspiral"],"hasliked":0,"parentid":"Mdd3R7","parentname":"SunflowerTransform"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// fork of:\n\n// Sunflower Transform - written 2015-11-18 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to FabriceNeyret2 for optimizations!\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = vec4(0);\n    \n    color += textureLod(iChannel0, uv, 0.0f) * 2.0f;\n    color += textureLod(iChannel0, uv, 1.0f);\n      color += textureLod(iChannel0, uv, 2.0f) * 0.5f;\n       color += textureLod(iChannel0, uv, 3.0f) * 0.25f;\n    color /=  4.0f;\n    \n    O = pow(color, vec4(1.0f/2.2f));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fork of:\n\n// Sunflower Transform - written 2015-11-18 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to FabriceNeyret2 for optimizations!\n\n#define pi (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820) // 1618033988\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define GOLDEN_ANGLE (2.399963229728653)\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat circ(vec2 v)\n{\n    v = fract(v)-.5;\n    return max(     smoothstep(.4, .5, length(v)), \n                (1.-smoothstep(.0, .1, abs(v.y))) * mirror(iTime*.1) );\n}\n\nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy; \n    vec2 I = /*14.0f*/iTime*(fragCoord+fragCoord-R)/R.y;\n    \n    vec3 bn = textureLod(iChannel0, fragCoord.xy/1024.0f, 0.0f).rgb * 2.0f - 1.0f;\n    \n    I += (GOLDEN_RATIO * bn.xy)/R;\n    \n    //I = vec2(0, length(I)) + fract( atan(I.y, I.x) / 2./3.1415926 );\n    I = vec2(0, length(I)) + fract( atan(I.y, I.x) / (pi*2.0) );\n    I.x = ceil(I.y) - I.x;\n    //I.x *= I.x * (sqrt(5.)-1.)*2.;\n    float angle = GOLDEN_ANGLE * GOLDEN_RATIO;\n    I.x *= fract(I.x * angle) + angle * iTime * GOLDEN_RATIO_ZERO * bn.z; // approximation to golden angle pi * (3-sqrt(5))\n    //I.x *= I.x * 3.1415926/(sqrt(5.)-1.);\n    //I.x *= I.x * (sqrt(5.)-1.)*2.*mirror(iTime*.01);\n    //I.x -= iTime;\n\n    float c0 = textureLod(iChannel1, fragCoord.xy/iResolution.xy, 0.0f).r;\n    float c1 = circ(I);\n    \n    O = vec4(vec3(mix(c0, c1, 0.95f), c0, c1), 1.0f);\n\n}\n\n/*\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat circ(vec2 v)\n{\n    //return smoothstep(.4, .5, length(fract(v)-.5));\n    return max(smoothstep(.4, .5, length(fract(v)-.5)), (1.- smoothstep(.0, .1, abs(fract(v.y)-.5)))*mirror(iTime * .1));\n    //return smoothstep(.0, .1, abs(length(fract(v)-.5)-.4));\n    //return smoothstep(.0, .1, abs(length(fract(v)-.5)-.4)) * smoothstep(.0, .1, abs(fract(v.y)-.5));\n    //return max(smoothstep(.0, .1, abs(length(fract(v)-.5)-.4)), (1.- smoothstep(.0, .1, abs(fract(v.y)-.5)))*mirror(iTime * .1));\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\tI = 2.*I/iResolution.xy-1.;\n    I.x *= iResolution.x / iResolution.y;\n    I *= 8.;\n    float a = fract(atan(I.y, I.x) / 2./3.1415926);\n    float b = length(I) + a;\n    I = vec2(a, b);\n    I.x = ceil(b) - I.x;\n    I.x *= I.x * (sqrt(5.)-1.)*2.;\n\n    O = vec4(circ(I));\n}\n*/","name":"Buffer A","description":"","type":"buffer"}]}