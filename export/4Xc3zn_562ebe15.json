{"ver":"0.1","info":{"id":"4Xc3zn","date":"1716072473","viewed":60,"name":"City Template","username":"elifront","description":"A template city terrain","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["terrain","generative","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst int MAX_STEPS = 80;\n\nconst int TOWER_ROWS = 5;\nconst int TOWER_COUNT = 6;\n\nconst float GROUND_POS = -0.35;\nconst float BUILDING_SEP = .4;\n\nfloat random(float seed) {\n    return fract(sin(seed) * 43758.5453123);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdGround(vec3 p, float y) {\n    return p.y - y;\n}\n\nvec2 minArray(vec2 arr[TOWER_COUNT*TOWER_ROWS]) {\n    float minValue = arr[0].x;\n    float id = 0.;\n    for (int i = 1; i < TOWER_COUNT*TOWER_ROWS; i++) {\n        minValue = min(minValue, arr[i].x);\n        if (minValue == arr[i].x) id = arr[i].y;\n    }\n    return vec2(minValue, id);\n}\n\n\nvec2 sdTower(vec3 p, float h, float w, vec2 pos) {\n    \n    float tower = sdBox(p + vec3(pos.x, -GROUND_POS-h, pos.y), vec3(w, h, w));\n    float window1 = sdBox(p + vec3(pos.x, -GROUND_POS-h*1.8-.02, pos.y), vec3(w + .001, 0.001, w+.001));\n    float window2 = sdBox(p + vec3(pos.x, -GROUND_POS-h*1.8-.04, pos.y), vec3(w + .001, 0.001, w+.001));\n    \n    float wins = min(window1, window2);\n\n    float minDist = min(tower, wins);\n    \n    float id = 1.0;\n    if (wins == minDist)id = 2.;\n    \n    \n    return vec2(minDist, id);\n}\n\n\n\nvec2 DE(vec3 p) {\n    vec2[TOWER_COUNT*TOWER_ROWS] towers;\n    \n\n    for (int i = 0; i < TOWER_COUNT*TOWER_ROWS; i++) {\n        float width = .1;\n        \n        int z = i / TOWER_COUNT;\n        int x = i % TOWER_COUNT;\n        \n \n        vec2 t = sdTower(p, random(float(x+z))*.3+.2, width, vec2((float(x)-float(TOWER_COUNT)/2.+(.5))*BUILDING_SEP,  mod(float(z) + iTime*.5, 5.)-2.));\n        towers[i] = t;\n        \n    }\n    \n    float ground = sdGround(p, -0.35);\n    vec2 towerMin = minArray(towers);\n    \n    float minDist = min(ground, towerMin.x);\n    float id = 0.;\n    \n    if (minDist == towerMin.x) id=towerMin.y;\n    \n    return vec2(minDist,id);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, -3); // Ray origin\n    vec3 rd = normalize(vec3(uv * 0.5, 1)); // Ray direction\n\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    int i = 0;\n    vec3 p;\n    \n    // Raymarching\n    for (i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * t;\n                \n        float d = DE(p).x;\n        if (d < EPSILON * 10.0 || t > 100.0) break;\n        t += d;\n        \n    }\n    \n    col = vec3(t*.1);\n    \n    float id = DE(p).y;\n    \n    if (id == 2.) col *= 3.;\n    if (id == 1.) col *= 1.3;\n    if (id == 0.) col *= .5;\n    \n       // Hacky LED glow effect\n    if (id == 2.0) {\n        float glowFactor = smoothstep(0.0, 1.0, 1.0 / (t * t));\n        col += vec3(1.0, 0.5, 0.0) * glowFactor; // Adding an orange glow\n    }\n    \n    \n    \n\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}