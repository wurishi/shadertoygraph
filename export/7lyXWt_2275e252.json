{"ver":"0.1","info":{"id":"7lyXWt","date":"1641498688","viewed":5296,"name":"dithering: values, linelightgame","username":"hornet","description":"illustration for https://pixelmager.github.io/linelight/article_linelight_dithering","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://jameshfisher.com/2017/08/30/how-do-i-make-a-full-width-iframe/\n\n// This set suits the coords of of 0-1.0 ranges..\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n//#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.z * p3.y);\n}\n\n//----------------------------------------------------------------------------------------\n\nconst float NUM_LEVELS_F = 5.0;\n\n//----------------------------------------------------------------------------------------\nfloat quantize_round( float v, float num_levels )\n{\n    return floor(v * num_levels ) / num_levels;\n}\n\nfloat quantize_round_rnd( float v, float num_levels, vec2 seed )\n{\n    float rnd = hash12( seed );\n    float v_rnd = v + rnd / NUM_LEVELS_F;\n    return quantize_round( v_rnd, NUM_LEVELS_F );\n}\n\n//----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n\n    vec2 fc = fragCoord.xy;\n    fc = floor( fc.xy / 4.0 ) * 4.0;\n    \n    vec2 uv = fc/iResolution.xy;\n    \n\n    float v = uv.x;\n\n    vec2 mp = iMouse.xy;\n    if ( iMouse.z <= 0.0 ) mp.x = iResolution.x * fract( 0.05 * iTime );\n\n    mp = floor( mp / 4.0 ) * 4.0;\n    mp = mp / iResolution.xy;\n    float c_mp = quantize_round( mp.x, NUM_LEVELS_F );\n\n    vec3 c;\n    if ( ssuv.y > 0.75 )\n    {\n        c = vec3(v);\n    }\n    else if ( ssuv.y > 0.5 )\n    {\n        c = vec3( quantize_round( v, NUM_LEVELS_F ) );\n        \n        float c_mp_floor = c_mp;\n        float c_mp_ceil = c_mp_floor + 1.0/NUM_LEVELS_F;\n        if ( abs( c_mp_ceil - ssuv.x) < 8.0*dFdx(ssuv.x/4.0)  )\n        {\n            c = vec3(1,0,0);\n        }\n        else if ( abs( c_mp_floor - ssuv.x) < 8.0*dFdx(ssuv.x/4.0)  )\n        {\n            c = vec3(0.0/255.0, 201.0/255.0, 250.0/255.0);\n        }\n    }\n    else if( ssuv.y > 0.25 )\n    {\n        float rnd = hash12( fc / 1000.0 );\n        float v_rnd = v + rnd / NUM_LEVELS_F;\n        c = vec3( quantize_round( v_rnd, NUM_LEVELS_F ) );\n\n        if ( abs( abs(mp.x) - uv.x) < dFdx(ssuv.x/4.0)  )\n        {\n            c = ( c.r != c_mp ) ? vec3(1, 0, 0) : vec3(0.0/255.0, 201.0/255.0, 250.0/255.0);\n        }\n\n    }\n    else\n    {\n        vec2 luv = vec2( ssuv.x, 4.0 * ssuv.y );\n        vec2 luvq = vec2( uv.x, 4.0 * uv.y );\n\n        float vl = ssuv.x;\n\n        float v_q = quantize_round( vl, NUM_LEVELS_F );\n        \n        float v_rnd_q = quantize_round_rnd( vl, NUM_LEVELS_F, vec2(vl)/1000.0 );\n        \n        float x0 = luv.x - 1.0*dFdx(luv.x);\n        float x1 = luv.x + 1.0*dFdx(luv.x);\n\n        if ( abs(luv.y-v) < dFdy(ssuv.y*4.0) ) c += vec3( 1, 0.75, 0 );\n        \n\n        //#define SHOW_STAIRSTEP\n        #if defined( SHOW_STAIRSTEP )\n        {\n            float y0 = quantize_round( x0, NUM_LEVELS_F );\n            float y1 = quantize_round( x1, NUM_LEVELS_F );\n            \n            float mn = min(y0,y1);\n            float mx = max(y0,y1);\n            float w = 1.0*dFdy(luv.y);\n            float t = step( mn-w, luv.y ) * step( luv.y, mx+w );\n            c += t * vec3(0.25,.5,0);\n        }\n        #endif //SHOW_STAIRSTEP\n\n\n        {\n            float mp_rnd_q = quantize_round_rnd( mp.x, NUM_LEVELS_F, vec2(mp.x)/1000.0 );\n\n            const vec3 c0 = vec3(0,201.0/255.0,1);\n            const vec3 c1 = vec3(1,0,0);\n            vec3 cx = (luv.y > v ) ? c1 : c0;\n            vec3 cx2 = (mp_rnd_q > v ) ? c1 : c0;\n\n            //float fw = abs(dFdx(luv.x)) + abs(dFdy(luv.y));\n            float fw = max( abs(dFdx(luv.x)), abs(dFdy(luv.y)) );\n\n            //note: random->int\n            if ( abs(luv.y-v_rnd_q) < 2.0*dFdy(luv.y) )\n            {\n                c = cx;\n            }\n        \n            //vec2 p0 = vec2(x0, y0);\n            //vec2 p1 = vec2(x1, y1);\n            vec2 p = vec2( mp.x, mp_rnd_q );\n            vec2 aspect = vec2(1.0, 0.25 )*vec2(1.0, iResolution.y/iResolution.x);            \n            \n            //note: current-value circle\n            if ( distance(aspect*luv,aspect*p)<1.0*fw )\n            {\n                c = cx2;\n            }\n            \n            //note: calc and show average\n            float avg_y = 0.0;\n            const int NUM_SAMPLES = 32;\n            const float NUM_SAMPLES_F = float(NUM_SAMPLES);\n            for ( int i=0; i<NUM_SAMPLES; ++i )\n            {\n                float v_mp = quantize_round_rnd( mp.x, NUM_LEVELS_F, vec2(mp.x, float(i))/1000.0 );\n                avg_y += v_mp;\n            }\n            avg_y /= NUM_SAMPLES_F;\n            vec2 avg_p = vec2(mp.x, avg_y);\n            if ( distance(aspect*luv,aspect*avg_p) < 0.5 * fw )\n            {\n                c = vec3(1,1,1);\n            }\n\n        }\n    }\n\n    if ( ssuv.x > 0.99 )\n    {\n        if ( ssuv.y > 0.75 ) { fragColor = vec4(1,.75,0,1); return; }\n        //if ( ssuv.y > 0.5 ) { fragColor = vec4(0.25,.75,0,1); return; }\n        //if ( ssuv.y > 0.25 ) { fragColor = vec4(0,1,.25,1); return; }\n    }\n\n    //vec2 luv = vec2( ssuv.x, fract(2.0 * ssuv.y) );\n    \n\n    fragColor = vec4(c,1.0);\n    \n    fragColor.rgb += hash12(ssuv)/255.0;\n}","name":"Image","description":"","type":"image"}]}