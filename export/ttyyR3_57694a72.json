{"ver":"0.1","info":{"id":"ttyyR3","date":"1611409524","viewed":169,"name":"Naive SDF voxel grid","username":"DragonWolf","description":"Determines if an  SDF voxel grid using brute force (pixel by pixel) determination.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdfvoxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define gridSize 10.0\n\nfloat sdBox( vec2 uv, vec2 position, in vec2 bounds )\n{\n    vec2 d = abs(position - uv)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius) {\n    return length(uv - pos) - radius;\n}\n\nfloat sdf(vec2 uv) {\n    float radius1 = 0.4 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.3), sin(iTime * 0.2));\n    float circle1 = sdCircle(uv, position1, radius1);   \n    \n    float radius2 = 0.3 * (1.0 + sin(iTime * 0.1));\n    vec2 position2 = vec2(sin(iTime * 0.2), sin(iTime * 0.5));\n    float circle2 = sdCircle(uv, position2, radius2);   \n    \n    return min(circle1, circle2);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound, vec2 pixelSize) {\n\n    float i = 0.;\n    float pixelsHigh = (2.0 * bound.y / pixelSize.y);\n    vec2 rd = vec2(1.0, 0.0);\n    vec2 ro = position - bound;\n    while (i < pixelsHigh) {\n        i += 1.0;\n        ro.y += pixelSize.y;\n        vec2 pos = ro;\n        float dist = 0.;\n        while (dist < bound.x * 2.0) {\n            float d = sdf(pos);\n            d = clamp(d, 0., 100.);\n            if (d > pixelSize.x) {\n                return false;\n            }\n            \n            if (d < pixelSize.x) {\n                d = pixelSize.x;\n            }\n            \n            dist += d;\n            pos = ro + rd * dist;\n        }  \n    }\n    \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound, vec2 pixelSize) {\n\n    float i = 0.;\n    float pixelsHigh = (2.0 * bound.y / pixelSize.y);\n    vec2 rd = vec2(1.0, 0.0);\n    vec2 ro = position - bound;\n    while (i < pixelsHigh) {\n        i += 1.0;\n        ro.y += pixelSize.y;\n        vec2 pos = ro;\n        float dist = 0.;\n        while (dist < bound.x * 2.0) {\n            float box1 = sdBox(pos, position, bound);\n            float d = sdf(pos);\n            d = abs(max(abs(d), box1));\n            if (d <= pixelSize.x) {\n                return true;\n            }\n            \n            if (d < pixelSize.x) {\n                d = pixelSize.x;\n            }\n            \n            dist += d;\n            pos = ro + rd * dist;\n        }  \n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    vec2 pixelSize = 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    // Bounding Box\n    vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n    vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n    vec2 minExtent = voxelMidpoint - voxelSize;\n    vec2 maxExtent = voxelMidpoint + voxelSize;\n    float box1 = sdBox(uv, voxelMidpoint, voxelSize);\n    \n    // Work out if the SDF is inside the box or not.\n    bool inside = insideBoundingSquare(voxelMidpoint, voxelSize, pixelSize);\n    bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize, pixelSize);\n    bool outside = !touching;\n\n    vec3 statusColor = vec3(1.0, 1.0, 0.0);\n    if (inside) {\n        statusColor = vec3(0.0, 1.0, 0.0);\n    } else if (outside) {\n        statusColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n    if (uv.x > minExtent.x && uv.x < maxExtent.x && uv.y > minExtent.y && uv.y < maxExtent.y) {\n        baseColor = vec3(0.8,0.2,0.2);\n    }\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)));\n    \n    // Add the grid\n    col = mix( col, statusColor, 1.0-smoothstep(0.0,0.015,abs(box1)) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}