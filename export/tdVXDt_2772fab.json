{"ver":"0.1","info":{"id":"tdVXDt","date":"1575367046","viewed":138,"name":"génération de terrain","username":"DanielDht","description":"génération de terrain","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["gnrationdeterrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PIP \n\n// View distance\nconst float view=6500.0;\n\n// Iterations\nconst int N=400;\n\n// Lipschitz constant\nconst float K=8.0;\n\n// Hashing function\nfloat Hash(vec3 p)  \n{\n    p  = fract( p*0.3183099+0.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise\nfloat Noise( in vec3 x ) // x : Point\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat ridge_noise(in vec2 p, in float k)\n{\n    float n  = Noise(vec3(p.xy,0.0));\n    for( float i=0.0; i<k; i++ )\n    {\n        n = min(n, Noise(vec3(p.xy + i*5.0, 0.0)));\n    }\n    return n;\n}\n\n// Terrain\nfloat Terrain( in vec2 x ) // x : Position in the plane\n{\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8); // Rotation matrix\n\n    const float l0 = 600.0; // longueur d'onde ini\n    const float a0 = 400.0; // y (altitude) scale\n    \n\tvec2  p = x/l0;\n    float a = 0.0;      // altitude\n    float alpha = 1.0;  // coeff de reduction\n    float b = 1.0;      // fréquence réduite par 2\n    \n    for( int i=0; i<8; i++ ) \n    {\n        float n = ridge_noise(p, 2.0);\n        a += b*n *alpha; \n        alpha *= smoothstep(-0.30, 0.99 , a); \n\t\tb *= 0.6; \n        p = m2*p*2.0;\n    }\n\treturn 0.0 +a0*a;\n}\n\nbool Intersect( in vec3 ro, in vec3 rd, out float t, out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<N; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - Terrain( pos.xz );\n\t\tif( abs(h)<(0.01*t)  ) return true;\n\t\tif( t>view ) return false;\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += h*sqrt(1.0+8.0*t/view)/K;\n\t}\n\n\treturn false;\n}\n\n// Normal of the Terrain\nvec3 Normal( in vec2 p) // p : Position in the plane\n{\n    vec2 eps = vec2( 0.25, 0.0 );\n    return normalize( vec3( Terrain(p-eps.xy) - Terrain(p+eps.xy),\n                            2.0*eps.x,\n                            Terrain(p-eps.yx) - Terrain(p+eps.yx) ) );\n}\n\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // ro : Camera transform\n    // rd : Camera ray\n\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    \n\tvec3 color;\n    float t;\n    int it;\n    bool b=Intersect( ro, rd, t , it);\n    if( b==false)\n    {\n        // sky\t\t\n        color = vec3(0.35,0.65,0.95) - rd.y*rd.y*0.5;\n    }\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 p = ro + t*rd;\n        vec3 n = Normal( p.xz );\n\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n\n        color=vec3(0.471,0.361,0.110);\n        \n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif*2.0; // *alpha: intensité \n        \n        color += dif*vec3(0.35,0.35,0.35);\n\n\t\t// fog\n        float fo = 1.0-exp(-pow(0.0005*t,1.5) );\n        fo *= 0.85;\n        //float fo = 0.f; // fog désactivé\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        color = mix( color, fco, fo );\n\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    float s=float(it)/float(N);\n\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    // Gamma with square root\n    return vec4( sqrt(color), t );\n    }\n}\n\n// Camera path\nvec3 Path( float time )\n{\n    // desynchronize cos and sin for epic lissajou path, circle otherwise\n\treturn vec3( 1100.0*cos(0.25*time), (613.0 ), 1100.0*sin(0.85*time) );\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro = Path( time );\n\t\n    // Target\n    vec3 ta = Path( time + 3.0 );\n\tta.y = ro.y - 362.0;\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw +0.2);\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/3.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.2 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; // set par moveCamera\n    mat3 cam = moveCamera( time, ro);   \n\n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n    \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0)); \n     \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n    //fragColor = vec4( 0.0,0.0,0.0, 0.0 );\n}","name":"Image","description":"","type":"image"}]}