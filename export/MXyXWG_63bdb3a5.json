{"ver":"0.1","info":{"id":"MXyXWG","date":"1720431907","viewed":108,"name":"Balrog In The Lord of the Rings","username":"zhangrm","description":"The dynamic version of prototype shader for Balrog - a 256 byte executable graphics for DOS by pestis /brainlez Coders.\nref:https://www.shadertoy.com/view/4XsGRr","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ifs","kaleidoscopicifs","executablegraphics"],"hasliked":0,"parentid":"4XsGRr","parentname":"Balrog - DOS 256b exe gfx"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS = 20;\nconst float BIG = 403.;\nconst float BIGZ = BIG / 384. * 2.;\nconst int ITERS = 29;\nconst float MINDIST = .0001;\nconst float CAM_X = .00;\nconst float CAM_Y = .61;\nconst float CAM_Z = 36.7;\nconst float LEVEL = 1.;\nconst float XMULT_BASE = 1.5;\nconst float COLORMULT_BASE = 3.14592;\nconst float COLORSCALE = 0.0549857728183;\nconst float XDIV = 2.0006;\nconst float RSCALE = pow(2., 1. / 3.);\nconst float RDIV = pow(RSCALE, float(ITERS));\nconst float GLOWAMOUNT = 0.0549857728183;\nconst float GLOWDECAY = 1e4;\nconst float PI = 3.14;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ray = vec2((fragCoord - 0.5 * iResolution.xy) / iResolution.xy);\n    ray.y = -ray.y;\n    ray.xy *= vec2(512, 384); // this is actually what we have on DOS: the screen coordinates\n\n    vec3 p = vec3(CAM_X, CAM_Y, CAM_Z);\n    int i;\n    float glow = 0.0;\n\n    float timeFactor = (sin((1.*iTime - 23.0) * PI / 25.0) + 1.0) * 0.5; \n    float XMULT = XMULT_BASE * (1.0 + 0.5 * timeFactor);\n    float COLORMULT = COLORMULT_BASE * (1.0 + 0.5 * timeFactor);\n\n    for (i = 0; i < STEPS; i++) {\n        vec3 t = p;\n        // o is the amount of rotation in the kaleidoscopic IFS.\n        float o = cos(p.x * XMULT) / XDIV;\n        float r = 0.;\n\n        for (int j = 0; j < ITERS; j++) {\n            t.x = abs(t.x - round(t.x)); // abs is folding, t.x - round(t.x) is domain repetition\n            t.x += t.x; // domain scaling\n            r *= RSCALE;\n            r += t.x * t.x;\n            t.xyz = t.yzx; // shuffle coordinates so next time we operate on previous y etc.\n             t.x += t.z * o; // rotation, but using very poor math\n            t.z -= t.x * o;\n        }\n\n        float dist = sqrt(r / RDIV) - LEVEL;\n        glow += GLOWAMOUNT / (1. + dist * dist * GLOWDECAY);\n\n        p.xy += ray.xy * dist / BIG;\n        p.z += dist / BIGZ;\n        if (dist < MINDIST) break;\n    }\n\n    float s = float(i) * COLORSCALE;\n    vec3 col = vec3(s * s) + cos(p * COLORMULT) * glow; // s*s to adjust the contrast\n    col = mix(col, vec3(0.1, 0.1, 0.2), 0.3);\n    fragColor = vec4(abs(sin(col)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}