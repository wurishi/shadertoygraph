{"ver":"0.1","info":{"id":"lcdXRn","date":"1713578584","viewed":145,"name":"de Laval nozzle 2","username":"ukeshet","description":"Compressible 2D flow simulation of converging vs. converging-diverging (de Laval) nozzles.\nV2: Temperature blob visualization added to V1 (https://www.shadertoy.com/view/XcyGW3)\nSteady-state burning around t~2min (wall time).\nClick a field name for view. ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","physics","finitedifferences","nozzle","idealfluid","compressibleflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compressible 2D flow simulation of a converging-diverging (de Laval) nozzle.\n// Two identical engines: de Laval achieves a supersonic outflow within the nozzle.\n// V1 - See https://www.shadertoy.com/view/XcyGW3\n// V2 - Added blob visualization (color ~ temperature, size ~ 1/density).\n// Demo for ICP + Astrophysics 1 courses, by ukeshet.\n//\n// Buffer A sets up initial and boundary conditions.\n// Buffer B is a simple 2D ideal fluid solver.\n// Buffer C traces T-blobs (moving at velocity*10).\n//\n// If the code crashes on your setup, lower the time stepping (CFL) parameter in Common (line 7).\n// Otherwise, raise CFL for a faster and more interesting (best before crash!) visualization.\n//\n// Visualization cycles through field views unless you click on a field name or elsewhere.\n\n#define Bx .77 // Text box geometry.\n#define y1 .64\n#define y2 .57\n#define y3 .50\n#define y4 .43\n#define y5 .36\n\nvec2 uv, k;\n\nvec4 K(int c) { // Type a character\n    vec2 p=(uv-k)*22.; k.x+=.02;\n    if (p.x<.0||p.x>1.||p.y<0.||p.y>1.) return vec4(0.);\n    return textureGrad(iChannel1,p/16.+fract(vec2(c+64,15-(c+64)/16)/16.),dFdx(p/16.),dFdy(p/16.));\n}\n\nvec3 CP(float x) { // Color palette\n    x=smoothstep(-1.,1.,x)*2.-1.;\n    float x2=x*x, x4=x2*x2, x8=x4*x4;\n    return vec3(x,x2,x8*x8);\n}\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n    uv = Coo.xy/iResolution.xy;\n    float T, dx=1./iResolution.x, dy=1./iResolution.y, dt=CFL*min(dx,dy), t=mod(iTime,35.);\n    Dx=round(iResolution.x/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    vec4 A=texture(iChannel0, uv);\n    Col = vec4(log(A.z+.1)*.4,log(A.w+.1)*.1,.5*length(A.xy)/pow(G*A.w/A.z,0.5),1.);\n    int V; vec2 M;\n    if ((uv.x>Bx) && (uv.y>y5) && (uv.y<y1)) Col*=0.; // Text box and text:\n    k=vec2(.78,.57); Col += vec4(0.,(K(16)+K(50)+K(37)+K(51)+K(51)+K(53)+K(50)+K(37)).x,0.,1.);\n    k=vec2(.78,.51); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)).x,1.);\n    k=vec2(.78,.45); Col += vec4((K(4)+K(37)+K(46)+K(51)+K(41)+K(52)+K(57)).x,0.,0.,1.);\n    k=vec2(.78,.39); Col += vec4(vec2((K(20)+K(37)+K(45)+K(48)+K(232)+K(54)+K(234)+K(241)+K(240)+K(233)).x),0.,1.);\n    if(iMouse.z<=0.) V=0; else { M=iMouse.xy/iResolution.xy;\n        if (M.x>Bx && M.y>y2 && M.y<y1) V=1;\n        else if (M.x>Bx && M.y>y3 && M.y<y2) V=2;\n        else if (M.x>Bx && M.y>y4 && M.y<y3) V=3;\n        else if (M.x>Bx && M.y>y5 && M.y<y4) V=4;\n        else V=5;}\n    if ((V==5) || ((V==0) && (t>19.) && (t<23.))) {          // show (rho,P,M)\n        if ((uv.x>Bx) && (uv.y>y5) && (uv.y<y4)) Col*=0.; }\n    if (V==1 || (V==0 && (t>27.) && (t<31.))) {  // show (0,P,0)\n        Col.xz*=0.; if ((uv.x>Bx) && (uv.y>y5) && (uv.y<y2)) Col*=0.; }\n    if (V==2 || (V==0 && (t>23.) && (t<27.))) {  // show (0,0,Mach)\n        Col.xy*=0.; if ((uv.x>Bx) && (((uv.y>y5) && (uv.y<y3)) || ((uv.y>y2) && (uv.y<y1)))) Col*=0.;\n        if ((uv.y > .51) && (uv.y<.56)) Col=vec4(0.,0.,.5,1.);             // show M=1 reference\n        k=vec2(.79,.57); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)+K(241)).x,1.); }\n    if (V==3 || (V==0 && t>31.)) {                            // show (rho,0,0)\n        Col.yz*=0.; if ((uv.x>Bx) && (((uv.y>y3) && (uv.y<y1)) || ((uv.y>y5) && (uv.y<y4)))) Col*=0.; }\n    if (V==4 || (V==0 && (t>0.) && (t<19.))) {   // show T blobs\n        if ((uv.x<Bx) || ((uv.y<y5) || (uv.y>y4))) {\n            Col=vec4(0.,0.,0.,1.);\n            if ((uv.x<1.-2.*Dx) && ((T=A.w/A.z)>1.3)) {\n                for(float ix=-1.; ix<1.5; ix+=1.) for(float iy=-1.; iy<1.5; iy+=1.) {\n                    vec2 uv1=uv+vec2(Dx*ix,Dy*iy);\n                    if (uv1.x>=0. && uv1.x<1. && uv1.y>=0. && uv1.y<1.) {\n                        vec4 B=texture(iChannel2,uv1);\n                        for (int j=0; j<4; j++) {\n                            vec3 q=unpack(B2i(B[j]));\n                            if (length(uv-vec2(Dx*floor(uv1.x/Dx),Dy*floor(uv1.y/Dy))-vec2(Dx*q.x,Dy*q.y))<.005*(1.-.5*log(1.*A.z)))                                \n                                Col.xyz=max(Col.xyz,CP(log(T-.3)*.27*(1.+.1*q[2])));\n                        }}}}}\n        if ((uv.x>Bx) && (uv.y>y4) && (uv.y<y1)) Col*=0.;\n    }\n    if ((uv.x > xLN) && ((abs(dyBN1(uv))<dy) || (abs(dyTN1(uv))<dy))) Col=vec4(1.); // mark nozzle 1\n    if ((uv.x > xLN) && ((abs(dyBN2(uv))<dy) || (abs(dyTN2(uv))<dy))) Col=vec4(1.); // mark nozzle 2\n    if ((uv.y>.5-dy) && (uv.y<.5+dy)) Col=vec4(1.); // mark separatrix\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common: Geometry and parameter setup.\n// ______________________________________\n\n#define pi 3.1415926535\n\n// Time stepping (CFL) parameter:\n#define CFL .015 // lower value if code crashes on your setup.\n\n// Hydro params:\n#define rho0 1.\n#define P0 1.\n#define P1 100.\n#define rho1 3.\n#define v0 0.\n#define G 1.4 // adiabatic index\n\n// Nozzle x ranges:\n#define xLN .7\n#define xRN .97\n\n// Nozzle 1 profile:\n#define yBN 0.195\n#define yTN 0.305\n#define dyN (yTN-yBN)*.24\n\n// Nozzle 2 profile:\n#define yBN2 0.71\n#define yTN2 0.79\n#define dyN2 (yTN2-yBN2)*.2\n\n// T-blob visualization\n#define SU 10.\n#define DT .05\n#define Nx 40.\n#define Ny 40.\nfloat Dx,Dy;\n\n// Nozzle geometry:\n\nfloat dyBN1(vec2 xy) { // Oriented distance from bottom edge of nozzle 1\n    return xy.y-(yBN-dyN*cos((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN)));\n}\n\nfloat dyTN1(vec2 xy) { // Oriented distance from top edge of nozzle 1\n    return xy.y-(yTN+dyN*cos((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN)));\n}\n\nfloat dyBN2(vec2 xy) { // Oriented distance from bottom edge of nozzle 2\n    return xy.y-(yBN2-dyN2*cos((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN)));\n}\n\nfloat dyTN2(vec2 xy) { // Oriented distance from top edge of nozzle 2\n    return xy.y-(yTN2+dyN2*cos((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN)));\n}\n\nvec2 NormB1(vec2 xy) { // Normal to bottom edge of nozzle 1\n    float a=atan(2.*pi*dyN*sin((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormT1(vec2 xy) { // Normal to top edge of nozzle 1\n    float a=atan(-2.*pi*dyN*sin((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB2(vec2 xy) { // Normal to bottom edge of nozzle 2\n    float a=atan(.3*pi*dyN2*sin((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormT2(vec2 xy) { // Normal to top edge of nozzle 2\n    float a=atan(-.3*pi*dyN2*sin((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\n\n// T-blob packing/unpacking:\n#define B1 14\n#define B2 14\n#define B3 4\nfloat b1=float((1<<B1)), b2=float((1<<B2)), b3=float((1<<B3));\n#define B2f(i) intBitsToFloat(i)\n#define B2i(i) floatBitsToInt(i)\n#define pack(qx,qy,qT) intBitsToFloat( (int(b1*qx)<<(B2+B3)) | (int(b2*qy)<<B3) | int(b3*qT) )\n#define unpack(Q) vec3(float(((Q>>(B2+B3))&((1<<B1)-1)))/b1,float(((Q>>B3)&((1<<B2)-1)))/b2,float(Q&((1<<B3)-1))/b3)\n\n// Hash\nfloat h(float I, float F) {\n    float combined = log(abs(I))/53.432 - log(abs(F))/23.364;\n    combined = fract(sin(combined*8264.2352)*4758.5453);\n    return fract(combined);\n}\n#define pack01 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N11*Dx,(1.+floor(uv.y/Dy))*n11*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N12*Dx,(1.+floor(uv.y/Dy))*n12*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N13*Dx,(1.+floor(uv.y/Dy))*n13*Dy)) )\n#define pack02 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N21*Dx,(1.+floor(uv.y/Dy))*n21*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N22*Dx,(1.+floor(uv.y/Dy))*n22*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N23*Dx,(1.+floor(uv.y/Dy))*n23*Dy)) )\n#define pack03 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N31*Dx,(1.+floor(uv.y/Dy))*n31*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N32*Dx,(1.+floor(uv.y/Dy))*n32*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N33*Dx,(1.+floor(uv.y/Dy))*n33*Dy)) )\n#define pack04 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N41*Dx,(1.+floor(uv.y/Dy))*n41*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N42*Dx,(1.+floor(uv.y/Dy))*n42*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N43*Dx,(1.+floor(uv.y/Dy))*n43*Dy)) )\n\n// Hash parameters (meaningless):\n#define n11 25236.264\n#define n12 46247.964\n#define n13 85446.343\n#define n21 74447.543\n#define n22 89345.434\n#define n23 78446.211\n#define n31 27242.754\n#define n32 93546.123\n#define n33 62147.141\n#define n41 57342.548\n#define n42 17445.547\n#define n43 56781.135\n#define N11 12411.346\n#define N12 76235.373\n#define N13 33743.748\n#define N21 72361.843\n#define N22 26898.834\n#define N23 58133.782\n#define N31 81345.853\n#define N32 82788.286\n#define N33 17457.842\n#define N41 14825.174\n#define N42 45856.723\n#define N43 56823.432","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Initial and boundary conditions.\n// Presently sets up the double-nozzle problem.\n// ____________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1./iResolution.x;\n    float dy = 1./iResolution.y;\n\n    Col = texture(iChannel0, uv); // Fetch pixel and neighbors\n    vec4 AR = texture(iChannel0, uv+vec2(dx,.0));\n    vec4 AL = texture(iChannel0, uv-vec2(dx,.0));\n    vec4 AU = texture(iChannel0, uv+vec2(.0,dy));\n    vec4 AD = texture(iChannel0, uv-vec2(.0,dy));\n\n    // Boundary conditions\n    if (uv.x<1.1*dx)                       // Left boundary\n        Col = vec4(-abs(AR.x),AR.yzw);     // outflow\n    if (uv.x>1.-1.1*dx)                   // Right boundary\n        Col = vec4(+abs(AL.x),AL.yzw);     // outflow\n    if (uv.y<1.1*dy)                       // Bottom boundary\n        Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow\n    if (uv.y>1.-1.1*dy)                   // Top boundary\n        Col = vec4(AD.x,+abs(AD.y),AD.zw); // outflow\n    if ((uv.y>.5-dy) && (uv.y<.5+dy))      // Separatrix\n        Col = vec4(0.,0.,rho0,P0);         // ambient\n    if ((uv.y>.5+dy) && (uv.y<.5+2.1*dy))  // Separatrix top\n        Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow downward\n    if ((uv.y<.5-dy) && (uv.y>.5-2.1*dy))  // Separatrix bottom\n        Col = vec4(AD.x,+abs(AD.y),AD.zw); // outflow upwards\n    if (uv.x > xLN) { // Nozzle region\n        float dyB=dyBN1(uv), dyT=dyTN1(uv);\n        if ((dyB>0.) && (dyT<0.)) {                     // inside nozzle 1\n            if (uv.x > xRN) Col = vec4(v0,0.,rho1,P1);  // inlet\n            if (dyT>-1.1*dy) Col = vec4(AD.xy-NormT1(uv)*dot(AD.xy,NormT1(uv)),AD.zw); // slip\n            if (dyB<1.1*dy)  Col = vec4(AU.xy-NormB1(uv)*dot(AU.xy,NormB1(uv)),AU.zw); // slip\n        } else {                                                      // outside nozzle 1\n            if ((dyB>0.) && (dyT<2.1*dy))  Col = vec4(0.,0.,rho0,P0); // ambient\n            if ((dyT<0.) && (dyB>-2.1*dy)) Col = vec4(0.,0.,rho0,P0); // ambient\n        }\n        float dyB2=dyBN2(uv), dyT2=dyTN2(uv);\n        if ((dyB2>0.) && (dyT2<0.)) {                   // inside nozzle 2\n            if (uv.x > xRN) Col = vec4(v0,0.,rho1,P1);  // inlet\n            if (dyT2>-1.1*dy) Col = vec4(AD.xy-NormT2(uv)*dot(AD.xy,NormT2(uv)),AD.zw); // slip\n            if (dyB2<1.1*dy)  Col = vec4(AU.xy-NormB2(uv)*dot(AU.xy,NormB2(uv)),AU.zw); // slip\n        } else {                                                        // outside nozzle 2\n            if ((dyB2>0.) && (dyT2<1.1*dy))  Col = vec4(0.,0.,rho0,P0); // ambient\n            if ((dyT2<0.) && (dyB2>-1.1*dy)) Col = vec4(0.,0.,rho0,P0); // ambient\n        }\n    }\n\n    if (iFrame<1) {  // Initial conditions\n        vec2 vi = vec2(0,0.);\n        float rho=rho0;\n        float P=P0;\n        if ((uv.x>xLN) && (dyBN1(uv)>0.) && (dyTN1(uv)<0.)) { // init nozzle 1\n            P = P0+(P1-P0)*smoothstep(xLN,xRN,uv.x);\n            vi.x = v0*smoothstep(xLN,xRN,uv.x);\n            if (uv.x > xRN) {P=P1; rho=rho1; vi.x=v0;}        // inlet\n        }\n        if ((uv.x>xLN) && (dyBN2(uv)>0.) && (dyTN2(uv)<0.)) { // init nozzle 2\n            P = P0+(P1-P0)*smoothstep(xLN,xRN,uv.x);\n            vi.x = v0*smoothstep(xLN,xRN,uv.x);\n            if (uv.x > xRN) {P=P1; rho=rho1; vi.x=v0;}        // inlet\n        }\n        Col = vec4(vi,rho0,P);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: 2D ideal fluid solver.\n// Simplest version: nearest neighbors only, operator splitting, donor-cell advection.\n// ____________________________________________________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float CV = 1./(G-1.); \n    float minV = .001;\n\n    // Grid\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1./iResolution.x;\n    float dy = 1./iResolution.y;\n    float dt = CFL*min(dx,dy); // lower CFL (defined in Common line 6) if crash.\n\n    // Fetch pixel and neighbours\n    vec4 A = texture(iChannel0, uv);\n    vec4 AR = texture(iChannel0, uv+vec2(dx,.0));\n    vec4 AL = texture(iChannel0, uv-vec2(dx,.0));\n    vec4 AU = texture(iChannel0, uv+vec2(.0,dy));\n    vec4 AD = texture(iChannel0, uv-vec2(.0,dy));  \n    \n    // Edge veclocities\n    float uR = .5*(AR.x+A.x), uL = .5*(AL.x+A.x);\n    float vU = .5*(AU.y+A.y), vD = .5*(AD.y+A.y);\n\n    // Mass flux\n    float frhoR = uR*(step(0.,uR)*A.z + step(uR,0.)*AR.z);\n    float frhoL = uL*(step(0.,uL)*AL.z + step(uL,0.)*A.z);\n    float frhoU = vU*(step(0.,vU)*A.z + step(vU,0.)*AU.z);\n    float frhoD = vD*(step(0.,vD)*AD.z + step(vD,0.)*A.z);\n    float rho2 = A.z - dt*( (frhoR-frhoL)/dx + (frhoU-frhoD)/dy );\n    rho2 = max(minV,rho2);\n\n    // x-momentum flux\n    float fpxR = uR*(step(0.,uR)*A.z*A.x + step(uR,0.)*AR.z*AR.x);\n    float fpxL = uL*(step(0.,uL)*AL.z*AL.x + step(uL,0.)*A.z*A.x);\n    float fpxU = vU*(step(0.,vU)*A.z*A.x + step(vU,0.)*AU.z*AU.x);\n    float fpxD = vD*(step(0.,vD)*AD.z*AD.x + step(vD,0.)*A.z*A.x);\n    float vx2 = ( A.z*A.x - dt*( (fpxR-fpxL)/dx + (fpxU-fpxD)/dy + (AR.w-AL.w)/dx/2. ) )/rho2;\n    \n    // y-momentum flux\n    float fpyR = uR*(step(0.,uR)*A.z*A.y + step(uR,0.)*AR.z*AR.y);\n    float fpyL = uL*(step(0.,uL)*AL.z*AL.y + step(uL,0.)*A.z*A.y);\n    float fpyU = vU*(step(0.,vU)*A.z*A.y + step(vU,0.)*AU.z*AU.y);\n    float fpyD = vD*(step(0.,vD)*AD.z*AD.y + step(vD,0.)*A.z*A.y);\n    float vy2 = ( A.z*A.y - dt*( (fpyR-fpyL)/dx + (fpyU-fpyD)/dy + (AU.w-AD.w)/dy/2. ) )/rho2;\n\n    // Total energy*density\n    float erho = CV*A.w+.5*A.z*(A.x*A.x+A.y*A.y);\n    float erhoR = CV*AR.w+.5*AR.z*(AR.x*AR.x+AR.y*AR.y);\n    float erhoL = CV*AL.w+.5*AL.z*(AL.x*AL.x+AL.y*AL.y);\n    float erhoU = CV*AU.w+.5*AU.z*(AU.x*AU.x+AU.y*AU.y);\n    float erhoD = CV*AD.w+.5*AD.z*(AD.x*AD.x+AD.y*AD.y);\n\n    // Energy flux\n    float feR = uR*(step(0.,uR)*erho + step(uR,0.)*erhoR);\n    float feL = uL*(step(0.,uL)*erhoL + step(uL,0.)*erho);\n    float feU = vU*(step(0.,vU)*erho + step(vU,0.)*erhoU);\n    float feD = vD*(step(0.,vD)*erhoD + step(vD,0.)*erho);\n    float erho2 = erho - dt*( (feR-feL)/dx + (feU-feD)/dy + \n                              (AR.w*AR.x-AL.w*AL.x)/dx/2. + (AU.w*AU.y-AD.w*AD.y)/dy/2. );\n\n    // Reconstruct pressure\n    float P2 = (erho2 - .5*rho2*(vx2*vx2+vy2*vy2))/CV;\n    P2 = max(minV,P2);\n\n    Col = vec4(vx2,vy2,rho2,P2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: temperature blob evolution.\n// ______________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo)\n{\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1./iResolution.x, dy = 1./iResolution.y;\n    float dt = CFL*min(dx,dy);\n    Dx=round(iResolution.x/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    if (iFrame<1) {\n        Col=vec4(pack01,pack02,pack03,pack04);\n    } else {\n        vec4 B=texture(iChannel1, uv);\n        for (int j=0; j<4; j++) {\n            vec2 cell=vec2(Dx*floor(uv.x/Dx),Dy*floor(uv.y/Dy));\n            vec3 q=unpack(B2i(B[j]));\n            float rx=Dx*q.x, ry=Dy*q.y;\n            vec4 A=texture(iChannel0, cell+vec2(rx,ry));\n            if (A.w!=P0 && (iTime<50. || abs(A.x)>.02 || abs(A.y)>.02)) { \n                rx+=A.x*dt*SU;\n                ry+=A.y*dt*SU;\n            } else { // blob out of dynamical range or got stuck; push it.\n                rx=Dx*h(n11*(1.+cell.x)*iTime,N11*(1.+cell.y)*iTime);\n                ry=Dy*h(n21*(1.+cell.x)*iTime,N21*(1.+cell.y)*iTime);\n            }            \n            float crossed, qT=q[2];\n            if (abs(crossed=floor(rx/Dx))>0.) { // blob crossed to next cell\n                ry=Dy*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                rx=Dx*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            if (abs(crossed=floor(ry/Dy))>0.) { // blob crossed to next cell\n                rx=Dx*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                ry=Dy*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            Col[j]=pack(fract(rx/Dx),fract(ry/Dy),qT);\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}