{"ver":"0.1","info":{"id":"XfycRW","date":"1731522941","viewed":101,"name":"spiralic move","username":"nayk","description":"source https://www.shadertoy.com/view/MdXSzS","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["spiral","galaxy","move"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n#define Log log2\n#define Exp exp2\n\n// represents the scale between successive spiral blocks.\nconst float scale = 0.05;\n// 2 times PI.\n#define TAU 6.2831853\n\n// Draws only the border of a circle with a specified thickness\nfloat CircleBorder(vec2 uv, vec2 position, float r, float thickness) {\n    uv -= position;\n    uv.x *= iResolution.x / iResolution.y;\n    float d = length(uv);\n    return smoothstep(r + thickness, r, d) - smoothstep(r, r - thickness, d); // Creates a ring by subtracting two smoothstep layers\n}\n// Number of spiral arms. Non-negative integers only. Setting this to zero\n    // will result in zero spirals -- Visually, just concentric shapes.\n    const float spiralN = 1.;\n\n    // reverses the spiral direction.\n    const float scF = Log(scale); //float scF = Log(pow(scale, -arms));\n   \n    // Log spiral rotation: Oddly enough, the best way to see what this line\n    // does is to comment it out. :)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n    // Number of spiral arms. Non-negative integers only. Setting this to zero\n    // will result in zero spirals -- Visually, just concentric shapes.\n    const float spiralN = 1.;\n   \n    // The logarithmic radial scale. You can incorporate the spiral arms into\n    // this calculation \"scF = log(pow(scale, -spiralArms))\", but I prefer to\n    // include the spiral arms inside the spiral rotation matrix.\n    //\n    // By the way, the value, \"scF\", is actually negative, so I've negated\n    // the two terms in the middle of the spiral matrix to account for this.\n    // In the end, it doesn't really matter, because reversing signs simply\n    // reverses the spiral direction.\n\n   \n    // Log spiral rotation: Oddly enough, the best way to see what this line\n    // does is to comment it out. :)\n        uv+= vec2(log(length(uv)), atan(uv.y, uv.x));\n           uv *= mat2(1, -spiralN*scF/TAU, spiralN*scF/TAU, 1);\n   \n    // Converting to cartesian coordinates. At the same time, we're\n    // animating the radial coordinate from the center to the maximum\n    // radial length, \"scF\", before snapping back to the center. It's\n    // a pretty common infinite zoom animation move.\n    uv = Exp(mod(uv.x - iTime, scF))*vec2( cos(uv.y), sin(uv.y));\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n vec3 col2 = vec3(0.01, 0.01, 0.01);\nuv*=ma;\n    int circleCount = 30; // Keep 30 circles on screen\n    float thickness = 0.0025;\n    float maxBaseRadius = 0.075;\n    float growthRate = 0.05; // Growth rate for each circleâ€™s radius\n\n    for (int i = 0; i < circleCount; i++) {\n   \n        float maxRadius = maxBaseRadius + 0.03 * hash(float(i) * 78.91);\n        float individualTime = 1.5 * iTime + float(i + 1) * 1.5;\n\n        float currentRadius = mod(growthRate * individualTime, maxRadius);\n\n        vec2 randomPos = vec2(\n            hash(float(i) * 12.34 ),\n            hash(float(i) * 56.78 )\n        );\n\n        if (currentRadius < maxRadius) {\n            float circleBorder = CircleBorder(uv, randomPos, currentRadius, thickness);\n            col2 = mix(col2, vec3(0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4))), circleBorder);    \n        }\n    }\nfloat v1, v2, v3;\nv1 = v2 = v3 = 0.0;\n\nfloat s = 0.0;\nfor (int i = 0; i < 90; i++)\n{\nvec3 p = s * vec3(uv, 0.0);\np.xy*=ma;\np += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\nfor (int i = 0; i < 8; i++) p = abs(p) / dot(p,p) - 0.659;\nv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\nv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\nv3 += length(p.xy*10.) * .0003;\ns  += .035;\n}\n\nfloat len = length(uv);\nv1 *= smoothstep(.7, .0, len);\nv2 *= smoothstep(.5, .0, len);\nv3 *= smoothstep(.9, .0, len);\n\nvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n(v1 + v3) * .3,\nv2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\nfragColor=vec4(min(pow(abs(col*vec3(0.1,0.1,2.)*10.), vec3(1.2)), 1.0), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}