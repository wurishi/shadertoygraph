{"ver":"0.1","info":{"id":"lfdyD7","date":"1730761222","viewed":96,"name":"Cohab","username":"Elsio","description":"a fork of https://www.shadertoy.com/view/Xfdyzr","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","geometry","city","flood","shane","traversal","building"],"hasliked":0,"parentid":"l3SfRd","parentname":"Plastic Cross"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define PI acos(-1.)\n#define t iTime * .3\n#define FAR 90.\n\nvec3 gDir;\nvec3 gRd;\nfloat gCD;\n\nfloat h21(vec2 f) {\n    f = mod(f + 16384., 16384.);\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U * (p >> 1U ^ p.yx);\n    return float(1103515245U * (p.x ^(p.y >> 3U))) / float(0xffffffffU);\n}\n\nfloat hm(vec2 p) {\n    float h = cos(\n                  dot(\n                      cos(p * .1 - iTime * 3.),\n                      sin(p.yx * .2 - iTime * 2.)\n                  ) * 2.\n              ) * .5 + .5;\n              \n    float h2 = dot(sin(p * .7 - tanh(cos(p.yx + iTime * .1) * 5.) * .7), vec2(.25)) + .5; \n    h2 = smoothstep(.6, 1., h2) * 4.;\n    \n    return max(h2, h);\n}\n\nfloat opExtrusion(float sdf, float pz, float h, float sf) {\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\nfloat sBoxS(vec2 p, vec2 b, float rf) {\n    vec2 d = abs(p) - b + rf;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n// from @shane\nvoid blocks(vec2 p, out vec2 q, out vec2 id, out vec2 dim) {\n    id = floor(p);\n    p  = fract(p) - .5;\n    \n    vec2 A, B, D, C;\n\n    if(mod(id.x + id.y, 2.) < 1.) {\n        A.x = h21(id) * .8 - .4;\n        D.x = p.x < A.x ? -1. : 1.;\n        A.y = h21(id + D) * .8 - .4;\n        D.y = p.y < A.y ? -1. : 1.;\n        B = vec2(h21(id + D), h21(id + D * vec2(0, 1)));\n    }\n    \n    else {\n        A.y = h21(id) * .8 - .4;\n        D.y = p.y < A.y ? -1. : 1.;\n        A.x = h21(id + D) * .8 - .4;\n        D.x = p.x < A.x ? -1. : 1.;\n        B = vec2(h21(id + D * vec2(1, 0)), h21(id + D));\n    }\n    \n    B = D + B * .8 - .4;\n    C = (A + B) / 2.;\n\n    // ret \n    dim = D * (B - A);\n    id += C;\n    q = p - C;\n}\n\n\n\nfloat map(vec3 p) {\n    \n    // subdivide blocks\n    vec2 q, id, dim;\n    blocks(p.xy, q, id, dim);\n    \n    float d2 = sBoxS(q, dim / 2. - .025, .1);\n    \n    // higthmap\n    float h = hm(id);\n    \n    // holes\n    if(dim.x > .25 && dim.y > .25 && h21(id + .53) > .5) \n        d2 = max(d2, - (d2 + .5));\n    \n    // decoration\n    float d = opExtrusion(d2, p.z + h / 2., h / 2., .01);\n    d -= smoothstep(0., .007, abs(d2 + .035)) * .025;\n    d += (d2 + .03) * .25;\n    \n    // andares\n    float lNum = 4.; \n    float z = p.z + h;\n    float ln = (abs(fract(z * lNum + .5) - .5) - .25) / lNum;\n    d += smoothstep(0., 1. / 40., ln) * .02;\n    \n    // limit dist\n    vec2 rC = (gDir.xy * dim.xy - q) / gRd.xy;\n    gCD = min(rC.x, rC.y) + .0001;\n    \n    // ret\n    return min(-p.z, d);\n}\n\n\nfloat march(vec3 ro, vec3 rd) {\n    float d, s, i;\n    \n    gDir = step(0., rd) - .5;\n    gRd = rd;\n    \n    while(i++ < 148.) {\n        d = map(ro + rd * s);\n        \n        if(abs(d) < .001 || s > FAR) break;\n        s += min(d, gCD);\n    }\n    \n    return s;\n}\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.01, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\n\nfloat AO(vec3 p, vec3 n) {\n    float i, occ, sca = 2.;\n    \n    while(i++ < 5.) {\n        float hr = (i + 1.) * .2 / 5.;\n        float d = map(p + n * hr);\n        occ += (hr - d) * sca;\n        sca *= .5;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\nvoid camera(inout vec3 p, inout vec3 D){\n    float T = t * .4;\n    \n    if(cos(t) > 0.){\n        p.zy *= rot(cos(T * 3.) * .2 - 1.1);\n        D.zy *= rot(sin(T * 2.) * .2 - 1.1);\n\n        D.xy *= rot(sin(T * .5) * 1.);\n\n        p.y += T * 28.;\n    }\n    \n    else{\n        p.zx *= rot(cos(T * 3.) * .6);\n        D.zx *= rot(sin(T * 2.) * .6);\n\n        p.x += T * 38.;\n\n        D.zy *= rot(cos(T * 1.2) * .2 - 1.1);\n        p.yz *= rot(cos(T * 1.3) * .2 - 1.1);\n    }\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n    u = (u - r / 2.) / r.y;\n    \n    vec3 p = vec3(0, 0, -15),\n         D = normalize(vec3(u, 1));\n    \n    camera(p, D);\n    \n    float d = march(p, D);\n    \n    if(d < FAR) {\n        vec3 p = p + d * D;\n        vec3 n = normal(p);\n        o = vec4(n * .2 + .4, 1) * 1.5 * AO(p, n);\n    }\n}","name":"Image","description":"","type":"image"}]}