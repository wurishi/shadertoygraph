{"ver":"0.1","info":{"id":"MfdfD2","date":"1733518474","viewed":22,"name":"Hypnotic fractal 126","username":"kukovisuals","description":"Polynomial","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// Convert HSB to RGB\nvec3 hsb2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.z * 6.0 + vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,\n                     0.0,\n                     1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb); \n    return c.x * mix(vec3(1.0), rgb, c.y);\n}\n\n// Polynomial: z^3 - c = 0, where c rotates over time\n// Roots rotate as c changes\n// For simplicity, start with c ~ 1 but rotate in complex plane\nvec2 complexC(float t) {\n    // c = e^(i t/5)\n    float angle = t*1.2;\n    return vec2(cos(angle), sin(angle));\n}\n\n// f(z) = z^3 - c\nvec2 f(vec2 z, vec2 c) {\n    float x = z.x; float y = z.y;\n    float xx = x*x - y*y;\n    float xy = 2.0*x*y;\n    // z^3 = (x+iy)^3 = (x^3 - 3xy^2) + i(3x^2y - y^3)\n    float x3 = x*x*x - 3.0*x*y*y;\n    float y3 = 3.0*x*x*y - y*y*y;\n    return vec2(x3 - c.x, y3 - c.y);\n}\n\nvec2 fprime(vec2 z) {\n    float x = z.x; float y = z.y;\n    // f'(z) = 3z^2\n    float xx = x*x - y*y;\n    float xy = 2.0*x*y;\n    return vec2(3.0*xx, 3.0*xy);\n}\n\n// Apply multiple conformal maps and distortions to make it more interesting\nvec2 applyTransforms(vec2 z, float t) {\n    // 1) Rotate the plane over time\n    float angle = t * 0.1;\n    vec2 complexPhase = vec2(cos(angle), sin(angle));\n    vec2 zRot = vec2(z.x*complexPhase.x - z.y*complexPhase.y, z.x*complexPhase.y + z.y*complexPhase.x);\n\n    // 2) Exponential map\n    float re = exp(zRot.x)*cos(zRot.y);\n    float im = exp(zRot.x)*sin(zRot.y);\n    vec2 zExp = vec2(re, im);\n\n    // 3) Möbius transform: w = (zExp - i)/(zExp + i)\n    // i = (0,1)\n    vec2 numerator = vec2(zExp.x, zExp.y - 1.0);\n    vec2 denominator = vec2(zExp.x, zExp.y + 1.0);\n    float denomSq = denominator.x*denominator.x + denominator.y*denominator.y;\n    vec2 w = vec2((numerator.x*denominator.x + numerator.y*denominator.y)/denomSq,\n                  (numerator.y*denominator.x - numerator.x*denominator.y)/denomSq);\n\n    // 4) Joukowsky transform: j = (w + 1/w)/2\n    float ww = w.x*w.x + w.y*w.y;\n    // Avoid division by zero:\n    if (ww < 1e-9) {\n        ww = 1e-9;\n    }\n    vec2 invW = vec2(w.x/ww, -w.y/ww);\n    vec2 j = vec2((w.x + invW.x)*0.5, (w.y + invW.y)*0.5);\n\n    return j;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Zoom\n    float zoom = 0.7 + 0.5*sin(iTime*0.1);\n    uv /= zoom;\n\n    // Apply transformations\n    vec2 z = applyTransforms(uv, iTime);\n\n    // Compute complex c that changes over time\n    vec2 c = complexC(iTime);\n\n    // Newton iteration\n    const int MAX_ITER = 100;\n    float tol = 1e-7;\n    int i;\n    for (i = 0; i < MAX_ITER; i++) {\n        vec2 val = f(z, c);\n        float rr = val.x*val.x + val.y*val.y;\n        if(rr < tol) break;\n        vec2 der = fprime(z);\n        float denom = der.x*der.x + der.y*der.y;\n        if(denom < 1e-14) break;\n        // z <- z - f(z)/f'(z)\n        float realPart = (val.x*der.x + val.y*der.y)/denom;\n        float imagPart = (val.y*der.x - val.x*der.y)/denom;\n        z = vec2(z.x - realPart, z.y - imagPart);\n    }\n\n    // After iteration, color based on root and iteration count\n    // Approximate roots by checking nearest solution of z^3=c\n    // Roots of z^3=c are c^(1/3)*{1, w, w^2} where w = e^{2πi/3}\n    // We'll just pick a hue based on argument of z and brightness on i\n    float arg = atan(z.y, z.x);\n    float mag = length(z);\n    float shade = float(i)/float(MAX_ITER);\n    \n    // Hue cycles with argument and time\n    float hue = mod((arg/(2.0*3.14159)) + iTime*0.001,1.0);\n    // Saturation is high, brightness depends on how quickly we converged\n    float sat = 1.0;\n    float bri = 1.0 - shade;\n\n    vec3 color = hsb2rgb(vec3(hue, sat, bri));\n\n    // Add a subtle line pattern by mixing with another hue channel\n    float linePattern = sin((uv.x*uv.x+uv.y*uv.y)*1.0 + iTime*0.0)*0.5+0.5;\n    color = mix(color, hsb2rgb(vec3(hue+0.0,0.0,0.0)), linePattern*0.1);\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}