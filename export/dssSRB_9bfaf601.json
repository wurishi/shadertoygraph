{"ver":"0.1","info":{"id":"dssSRB","date":"1669148035","viewed":157,"name":"Woven Pipes Tiling II","username":"fizzer","description":"A variation on my [url=https://www.shadertoy.com/view/DslXD8]previous shader[/url]. Here the number of pipes in a cell is variable.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","tiling","weave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Line segment\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\n// Two-segment 90-degree angle pipe\nfloat Rline(vec2 p, vec2 a, vec2 b)\n{\n    if(abs(a.y - .5) > abs(a.x - .5))\n    {\n        vec2 nx = vec2(clamp(p.x, min(a.x, b.x), max(a.x, b.x)), b.y);\n        vec2 ny = vec2(a.x, clamp(p.y, min(a.y, b.y), max(a.y, b.y)));\n        return min(distance(p,ny), distance(p, nx));\n    }\n    else\n    {\n        vec2 nx = vec2(clamp(p.x, min(a.x, b.x), max(a.x, b.x)), a.y);\n        vec2 ny = vec2(b.x, clamp(p.y, min(a.y, b.y), max(a.y, b.y)));\n        return min(distance(p,ny), distance(p, nx));\n    }\n}\n\n// Three-segment S-shaped pipe\nfloat Sline(vec2 p, vec2 a, vec2 b, float t)\n{\n    vec2 mid = mix(a, b, t);\n    if(abs(b.x - a.x) > abs(b.y - a.y))\n    {\n        vec2 c = vec2(mid.x, a.y), d = vec2(mid.x, b.y);\n        return min(min(line(p, a, c), line(p, d, b)), line(p, c, d));\n    }\n    else\n    {\n        vec2 c = vec2(a.x, mid.y), d = vec2(b.x, mid.y);\n        return min(min(line(p, a, c), line(p, d, b)), line(p, c, vec2(b.x, mid.y)));\n    }\n}\n\n// Three-segment U-shaped pipe\nfloat Uline(vec2 p, vec2 a, vec2 b)\n{\n    float m = .2;\n    if(abs(b.x - a.x) > abs(b.y - a.y))\n    {\n        vec2 c = vec2(a.x, a.y + sign(b.y - .5) * m), d = vec2(b.x, a.y + sign(b.y - .5) * m);\n        return min(min(line(p, a, c), line(p, c, d)), line(p, d, b));\n    }\n    else\n    {\n        vec2 c = vec2(a.x + sign(b.x - .5) * m, a.y), d = vec2(a.x + sign(b.x - .5) * m, b.y);\n        return min(min(line(p, a, c), line(p, c, d)), line(p, d, b));\n    }\n}\n\nfloat rand(vec2 p)\n{\n    p = floor(vec2(p.x + p.y, p.x - p.y));\n    float x = texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n    return mix(.33, .66, floor(x * 1.99) / 1.);\n}\n\nfloat rand2(vec2 p)\n{\n    p = floor(vec2(p.x + p.y, p.x - p.y));\n    float x = texelFetch(iChannel1, ivec2(p) & 511, 0).g;\n    return x;\n}\n\n// Based on https://www.shadertoy.com/view/llGSzw\nuint hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nvec2 globalUV;\nvec3 draw(vec3 b, float d, float f)\n{\n    d /= 4.;\n    f /= 4. * 2.0;\n\n    vec3 c0 = vec3(0);\n    c0 = c0.bgr;\n\n    float n0 = 0.04;\n    float n1 = 0.03;\n    float n2 = 0.025;\n    \n    vec3 res = mix(mix(mix(b * smoothstep(0.02, .06, d), vec3(.8), 1. - smoothstep(n0 - f, n0 + f, d)),\n                               vec3(0), 1. - smoothstep(n1 - f, n1 + f, d)),\n                               vec3(.3), 1. - smoothstep(n2 - f, n2 + f, d));\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y*6.;\n    uv.x += iTime * .3;\n    \n    if(iMouse.z>.5)\n        uv = uv.xy + iMouse.xy / iResolution.xy * 15.;\n\n    globalUV = uv;\n\n    float bgx = (uv.x + uv.y) * 8.1;\n    float bgf = max(abs(dFdx(bgx)), abs(dFdy(bgx)));\n    // Background pattern\n    vec3 col = mix(vec3(.7), vec3(.4), smoothstep(-bgf, +bgf, abs(fract(bgx) - .5) - .1));\n    \n    float m = .1;\n    vec2 p = fract(uv);\n    vec2 q = floor(uv);\n    \n    // Eight points around the perimeter of the current square cell\n    vec2 c[8] = vec2[8](vec2(mix(m, .5, rand(q + vec2(.5, 0))), 0.),\n                        vec2(mix(.5, 1. - m, rand(q + vec2(.5, 0))), 0.),\n                        vec2(1., mix(m, .5,rand(q + vec2(1., .5)))),\n                        vec2(1., mix(.5, 1. - m, rand(q + vec2(1., .5)))),\n                        vec2(mix(m, .5, rand(q + vec2(.5, 1))), 1.),\n                        vec2(mix(.5, 1. - m, rand(q + vec2(.5, 1))), 1.),\n                        vec2(0., mix(m,.5, rand(q + vec2(0, .5)))),\n                        vec2(0., mix(.5, 1. - m, rand(q + vec2(0, .5)))));\n\n    // Shuffle the indices by using the Fisher-Yates algorithm\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    uint inds[8], inds2[8];\n    \n    for(uint j = 0U; j < 8U; ++j)\n        inds2[j] = j;\n\n    uint num_inds = 0U;\n\n    for(uint j = 0U; j < 8U; j += 2U)\n    {\n        if(rand2(q + c[j]) < .6)\n        {\n            inds[num_inds++] = inds2[j + 0U];\n            inds[num_inds++] = inds2[j + 1U];\n        }\n    }\n    \n    uint seed = uint(q.x + q.y * 8192.)*319U;\n    for(uint j = 1U; j < num_inds; ++j)\n    {\n        seed = hash1(seed);\n        uint k = seed % j;\n        uint temp = inds[k];\n        inds[k] = inds[j];\n        inds[j] = temp;\n    }\n    \n    // Try to avoid creating small rings or terminations\n    for(uint j = 0U; j < num_inds; j += 2U)\n    {\n        if(inds[j] / 2U == inds[j + 1U] / 2U)\n        {\n            uint temp = inds[(j + 3U) % num_inds];\n            inds[(j + 3U) % num_inds] = inds[j];\n            inds[j] = temp;\n        }\n    }\n    \n    float f = max(length(dFdx(uv)), length(dFdy(uv)));\n    float md = 1e4;\n    \n    // Draw pipes connecting pairs of points on the cell perimeter\n    for(uint j = 0U; j < num_inds; j += 2U)\n    {\n        uint ia = inds[j];\n        uint ib = inds[j + 1U];\n        \n        if(ia / 2U == ib / 2U)\n        {\n            // The points are on the same side of the cell\n            float d = Uline(p, c[ia], c[ib]);\n            md = min(md, d);\n            col.rgb = draw(col.rgb, d, f);\n        }\n        else if(abs(float(ia / 2U) - float(ib / 2U)) == 2.)\n        {\n            // The points are on opposite sides of the cell\n            float t = floor(mix(.2,.8,texelFetch(iChannel0, ivec2(p + 34.+float(j) * 9.) & 255, 0).r) * 11.) / 11.;\n            float d = Sline(p, c[ia], c[ib], mix(.1, .9, t));\n            md = min(md, d);\n            col.rgb = draw(col.rgb, d, f);\n        }\n        else\n        {\n            // The points are on perpendicular sides of the cell\n            float d = Rline(p, c[ia], c[ib]);\n            md = min(md, d);\n            col.rgb = draw(col.rgb, d, f);\n        }\n    }\n    \n    fragColor = vec4(pow(max(col, 0.), vec3(1. / 2.2)), 1.);\n}","name":"Image","description":"","type":"image"}]}