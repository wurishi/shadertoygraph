{"ver":"0.1","info":{"id":"43BBRG","date":"1729573191","viewed":30,"name":"Toon Spreading Fissure","username":"Shoozes","description":"Spreading Fissure Crack, time added, toon stylized.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","toon","crack","fissure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader code to create a growing crack with branching fissure reveal\n\nconst float THIC = 1.44; // Adjusts the randomness applied to each cell\nconst float SECTIONS = 8.0;\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\n// Impact and animation loop constants\nconst float MIN_IMPACT = 0.025;   // Minimum thickness for the impact effect\nconst float MAX_IMPACT = 0.05;   // Maximum thickness for the impact effect\nconst float LOOP_DURATION = 2.0; // Duration for the animation loop\nconst float NUM_STEPS = 14.0;    // Number of steps in the animation\nconst float MOVE_FACTOR = 0.7;   // Factor for the move duration relative to step duration\nconst float PAUSE_FACTOR = 1.44;  // Factor for the pause duration relative to step duration\n\n// Hash function to generate a pseudo-random offset for each cell position\nvec2 hash(vec2 _pos) {\n    _pos = mod(_pos, SECTIONS);\n    return fract(sin(vec2(dot(_pos, vec2(144.44)), dot(_pos, vec2(144.44)))) * 14444.4444);\n}\n\n// Computes the Voronoi cell closest to the given point and its border distance\nvec3 voronoi(vec2 _point, out vec2 cellId) {\n    vec2 _cell = floor(_point);\n    vec2 _off = fract(_point);\n    vec2 nearestCell, offToCell;\n    float minDist = 8.0;\n\n    // Find the nearest neighboring cell\n    for (int j = -1; j <= 1; j++)\n    for (int i = -1; i <= 1; i++) {\n        vec2 cell = vec2(float(i), float(j));\n        vec2 rndOff = THIC * hash(_cell + cell);\n        vec2 distance = cell + rndOff - _off;\n        float distSquared = dot(distance, distance);\n        if (distSquared < minDist) { \n            minDist = distSquared; \n            offToCell = distance; \n            nearestCell = cell; \n        }\n    }\n\n    // Refine the border distance to handle edges between cells\n    minDist = 8.0;\n    for (int j = -2; j <= 2; j++)\n    for (int i = -2; i <= 2; i++) {\n        vec2 cell = nearestCell + vec2(float(i), float(j));\n        vec2 rndOff = THIC * hash(_cell + cell);\n        vec2 distance = cell + rndOff - _off;\n        if (dot(offToCell - distance, offToCell - distance) > 0.000001) {\n            float dist = dot(0.5 * (offToCell + distance), normalize(distance - offToCell));\n            minDist = min(minDist, dist);\n        }\n    }\n\n    cellId = _cell + nearestCell;\n    return vec3(minDist, offToCell);\n}\n\n// Generates a basic noise value based on sine waves\nfloat noise(float _value) {\n    float _floor = floor(_value);\n    float _frac = fract(_value);\n    return mix(\n        fract(sin(_floor) * 14444.),\n        fract(sin(_floor + 1.0) * 14444.),\n        _frac\n    );\n}\n\n// Generates low-frequency noise for smooth transitions\nfloat lowFreqNoise(float _value) {\n    _value = mod(_value, 1.0);\n    float res = 10.0;\n    float _frac = fract(_value * res);\n    float index = floor(_value * res);\n    float a = noise(mod(index, res));\n    float b = noise(mod(index + 1.0, res));\n    return mix(a, b, _frac) * 2.0 - 1.0;\n}\n\n// Generates the color of a pixel based on its position and Voronoi calculations\nvec3 getColor(vec2 fragCoord) {\n    vec2 uvCenter = vec2(0.5, 0.5);\n    vec2 uv = fragCoord.xy / iResolution.xy - uvCenter;\n    float dist = length(uv);\n    float angle = atan(uv.y, uv.x);\n\n    // Time-based progress with steps and pauses\n    float totalDuration = LOOP_DURATION; // Use the constant for loop duration\n    float stepDuration = totalDuration / NUM_STEPS;\n    float moveDuration = MOVE_FACTOR * stepDuration;\n    float pauseDuration = PAUSE_FACTOR * stepDuration;\n\n    float t = mod(iTime, totalDuration);\n    float currentStep = floor(t / stepDuration);\n    float tInStep = mod(t, stepDuration);\n\n    float progress = currentStep / NUM_STEPS;\n\n    if (tInStep < moveDuration) {\n        float moveProgress = tInStep / moveDuration;\n        progress += moveProgress / NUM_STEPS;\n    } else {\n        progress += 1.0 / NUM_STEPS;\n    }\n\n    float maxRadius = 0.7071; // From center to corner\n\n    // Animate edge thickness using a sine wave for impact effect\n    float impactEffect = 0.5 + 0.5 * sin(progress * PI * 1.0); // Oscillates between 0 and 1\n    float edgeWidth = mix(MIN_IMPACT, MAX_IMPACT, impactEffect) - 0.01 * progress;\n\n    // Introduce angle variation for branching effect\n    float numBranches = 8.0;          // Number of branches (N, S, E, W)\n    float variationAmount = 0.2;      // Amount of variation for branching\n    float angleVariation = sin(angle * numBranches) * variationAmount;\n\n    // Adjust progress based on angle to create branches\n    float adjustedProgress = clamp(progress + angleVariation, 0.0, 1.0);\n    float adjustedRadius = adjustedProgress * maxRadius;\n\n    // Create the revealing mask (inverted to reveal the crack)\n    float mask = 1.0 - smoothstep(adjustedRadius - edgeWidth, adjustedRadius, dist);\n\n    // Original crack pattern computations\n    vec2 polarCoords = vec2(max(0.5, pow(dist, 0.1)), angle / PI2 + 0.5);\n    polarCoords.x += 0.015 * abs(lowFreqNoise(polarCoords.y));\n    vec2 frequency = vec2(12.0, SECTIONS);\n\n    vec2 cellId;\n    float borderDist = voronoi(polarCoords * frequency, cellId).x;\n    cellId = mod(cellId, SECTIONS);\n\n    // Adjust edge thickness based on progress\n    float edgeFactor = mix(MIN_IMPACT, MAX_IMPACT, impactEffect); // Thicken more at impact moments\n    float edge = smoothstep(edgeFactor, edgeFactor + 0.0001, borderDist);\n\n    vec3 nmOff = vec3(\n        noise(cellId.x * 7.0),\n        noise(cellId.y * 13.0),\n        noise(27.0 * (cellId.x - cellId.y))\n    ) * 2.0 - 1.0;\n    vec3 N = normalize(vec3(0.0, 0.0, 1.0) + 0.1 * nmOff);\n\n    vec3 finalColor = mix(vec3(1.0), vec3(0.2, 0.36, 0.4), 1.0 - edge);\n\n    vec3 backgroundColor = vec3(1.0); // White background\n    vec3 color = mix(backgroundColor, finalColor, mask);\n    return color;\n}\n\n// Main shader function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = getColor(fragCoord);\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}