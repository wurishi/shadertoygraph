{"ver":"0.1","info":{"id":"MscfWS","date":"1526510783","viewed":179,"name":"Portal Cube","username":"Bundas","description":"Check out the other sides of the cube maybe there are more things there ;)\nIf you feel lost, try it with the USE_WORLD_BACKGOUND setting.\nSome places seem empty but are they really?","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cube","portal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DRAW_LIGHT_SPHERE\n//#define USE_WORLD_BACKGOUND\n//#define AUTO_CAMERA\n\n//#define DRAW_MOUSE_INPUT\n\n\n#define D_PI 6.2831853\n#define PI_2 1.5707963\n#define PI   3.1415927\n#define EPS  0.001\n\n// camera\nfloat camera_r = 8.0;\nvec3 eye = vec3(-5,0,0);\nvec3 center = vec3(0,0,0);\nvec3 up = vec3(0,1,0);\n\n// light\nvec3 light_pos = vec3(0,5,0);\nfloat specular_power = 16.0;\n\n// ray and object\nvec3 rayOrig = vec3(0);\nvec3 rayDir = vec3(1,0,0);\nfloat t = -1.0;\nvec3 norm = vec3(0);\nvec3 objColor = vec3(0.5);\n\nfloat time = 0.0;\nvec3[] bg = vec3[](\n\tvec3(0,0.5,1),\n    vec3(0.5,0.75,0),\n    vec3(0.25,0,0.75),\n    vec3(0.5,0.25,0.5),\n    vec3(1,0.75,0.25),\n    vec3(1,0,0.5),\n    vec3(0.5,0,0.75)\n);\n\n// functions\nvoid getRay(in vec3 eye, in vec3 center, in vec3 up, in vec2 normFragCoords, out vec3 rayDirection);\nvoid RubiksCube(in vec3 centerPos, in float sideLength);\nvoid drawPortalCube(inout int portalSide);\nvoid world1();\nvoid world2();\nvoid world3();\nvoid world4();\nvoid world5();\nvoid world6();\nvoid sphere(in vec3 center, in float r, in vec3 col);\nvoid octahedron(in vec3 center, in float r, in vec3 col);\nvoid frame(in vec3 corner, in vec3 dir1, in vec3 dir2, inout vec2 par, in bool oneWay, in float frameSize, out bool inside, in vec3 col);\nvoid outerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, out int lookThrough, in vec3 col);\nvoid innerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, in vec3 col);\nvoid parallelogram(in vec3 corner, in vec3 dir1, in vec3 dir2, inout vec2 par, in vec3 col);\nvoid triangle(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 col);\nvec3 shade(in vec3 pos, in vec3 normal, in bool shadowed);\nvec3 polarToDesc(in float r, in float phi, in float theta);\nvoid animatedParalelogram(in vec3 corner, in vec3 dir1, in vec3 dir2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime/2.0;\n    #ifdef DRAW_MOUSE_INPUT\n        if(distance(iMouse.xy,fragCoord) < 5.0) { fragColor = vec4(1,0,0,1); return;}\n        if(distance(iMouse.zw,fragCoord) < 5.0) { fragColor = vec4(0,1,0,1); return;}\n    #endif\n\n    // set camera position\n    float phi = 0.0;\n    float theta = PI_2;\n    vec2 mOffset = vec2(0);\n    if(iMouse.z > 0.0){\n        mOffset = (iMouse.xy - iMouse.zw) / iResolution.xy;\n        mOffset.y = clamp(mOffset.y, -0.499, 0.499);\n    }\n    theta += mOffset.y * PI;\n    #ifdef AUTO_CAMERA\n    \tphi -= time * PI * 0.25;\n    #else\n        phi += mOffset.x * D_PI;\n    #endif\n    eye = polarToDesc(camera_r, phi, theta);\n    \n    // set point light\n    light_pos = vec3(5.0*cos(time/7.0*D_PI), 1.0+1.2*sin(time/3.0*D_PI), 5.0*sin(time/7.0*D_PI));\n    \n    // get normalized fragment coordinates\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    \n    // draw the scene\n    getRay(eye, center, up, uv, rayDir);\n    rayOrig = eye;\n    t = -1.0;\n    #ifdef DRAW_LIGHT_SPHERE\n        sphere(light_pos, 0.1, vec3(10.0));\n    #endif\n    int portal = -1;\n    drawPortalCube(portal);\n    float pos_t = t;\n    vec3 pos_pos = rayOrig + t * rayDir;\n    vec3 pos_norm = norm;\n    vec3 pos_objColor = objColor;\n    \n    // shadow\n    bool inShadow = false;\n    if(pos_t >= 0.0){\n        rayDir = pos_pos - light_pos;\n        float lightRay_t = length(rayDir);\n        rayDir = normalize(rayDir);\n        rayOrig = light_pos;\n        t = -1.0;\n    \tdrawPortalCube(portal);\n        inShadow = (t > 0.0) && (t + EPS < lightRay_t);\n\n        objColor = pos_objColor;\n    }\n    \n    #ifdef USE_WORLD_BACKGOUND\n\t\tvec3 background = bg[portal];\n    #else\n\t\tvec3 background = bg[0];\n    #endif\n    \n    vec3 col = pos_t < 0.0 ? background : shade(pos_pos, pos_norm, inShadow);\n    \n    fragColor = vec4(col, 1.0); \n}\n\nvoid getRay(in vec3 eye, in vec3 center, in vec3 up, in vec2 normFragCoords, out vec3 rayDirection)\n{\n    vec3 w = normalize(eye-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n   \tvec2 mres = normalize(iResolution.xy);\n    \n    float alpha = normFragCoords.x*mres.x;\n    float beta = normFragCoords.y*mres.y;\n    \n    rayDirection = normalize(alpha*u + beta*v - w);\n}\n\nvoid drawPortalCube(inout int portalSide)\n{\n    // in portalSide == -1 -> draw phase\n    // in portalSide == 0 -> shadowing phase (no portal)\n    // in portalSide > 0 -> shadowing phase (we are in a portal)\n    \n    int side = 0;\n    \n    outerCubeFrame(vec3(0), 5.0, 0.1, side, vec3(0.8));\n    innerCubeFrame(vec3(0), 5.0, 0.1, vec3(0.8));\n    \n    int world = (portalSide == -1 ? side : portalSide);\n    switch(world){\n    \tcase 1: world1(); break;\n        case 2: world2(); break;\n        case 3: world3(); break;\n        case 4: world4(); break;\n        case 5: world5(); break;\n        case 6: world6(); break;\n    }\n    \n\tportalSide = (portalSide == -1) ? side : portalSide;\n}\n\nvoid world1()\n{\n    RubiksCube(vec3(0), 1.0);\n    //RubiksCube(vec3(5.0,0,0), 1.0);\n    //RubiksCube(vec3(0,5.0,0), 1.0);\n    //RubiksCube(vec3(0,-5.0,0), 1.0);\n    //RubiksCube(vec3(0,0,5.0), 1.0);\n    //RubiksCube(vec3(0,0,-5.0), 1.0);\n}\n\nvoid world2()\n{\n    sphere(vec3(-2.5+2.0*cos(time/6.0*D_PI), 2.5+2.0*sin(time/6.0*D_PI), 0.0), 1.0, vec3(0.75,0.75,0));\n}\n\nvoid world3()\n{\n    sphere(vec3(0,2.0*sin(time),0), 1.0, vec3(0.5,1,0.25));\n}\n\nvoid world4()\n{\n    if(iMouse.z > 0.0 && (abs(iMouse.xy-iMouse.zw)/iResolution.xy).x > 0.5)\n    \tRubiksCube(vec3(0,0,0), 3.0);\n    else\n\t\toctahedron(vec3(0), 2.0, vec3(1,0.3,0));\n    \n}\n\nvoid world5()\n{\n    sphere(4.0*vec3(cos(time/12.0*D_PI), 0.0, -sin(time/12.0*D_PI)), 1.0, vec3(0,1,0));\n}\n\nvoid world6()\n{\n    if(iMouse.z > 0.0 && (abs(iMouse.xy-iMouse.zw)/iResolution.xy).x > 0.5){\n        //octahedron(vec3(0,4.0,0), 3.0, vec3(0.5,1,0.25));\n        //octahedron(vec3(0,-4.0,0), 3.0, vec3(0.5,1,0.25));\n        //octahedron(vec3(4.0,0,0), 3.0, vec3(0.5,1,0.25));\n        //octahedron(vec3(-4.0,0,0), 3.0, vec3(0.5,1,0.25));\n        octahedron(vec3(0,0,-4.0), 3.0, vec3(0.5,1,0.25));\n    }else{\n        animatedParalelogram(vec3(-2.0,-2.0,0),vec3(4,0,0),vec3(0,4,0));\n    }\n    \n}\n\nvoid RubiksCube(in vec3 centerPos, in float sideLength)\n{\n    vec2 par = vec2(-1.0);\n    vec3 minCorner = centerPos - sideLength/2.0;\n    vec3 maxCorner = centerPos + sideLength/2.0;\n    vec3 x = vec3(sideLength,0,0);\n    vec3 y = vec3(0,sideLength,0);\n    vec3 z = vec3(0,0,sideLength);\n\n    // back\n    parallelogram(minCorner, z, y, par, vec3(1,0,0));\n    // bottom\n    parallelogram(minCorner, x, z, par, vec3(1,1,0));\n    // right\n    parallelogram(minCorner, y, x, par, vec3(0,1,0));\n\t// front\n    parallelogram(maxCorner, -y, -z, par, vec3(1,0.5,0));\n\t// top\n    parallelogram(maxCorner, -z, -x, par, vec3(0.9));\n    // left\n    parallelogram(maxCorner, -x, -y, par, vec3(0,0,1));\n    \n    float eps = 0.01;\n    if(abs(par.x)<eps||abs(par.x-1.0/3.0)<eps||abs(par.x-2.0/3.0)<eps||abs(par.x-1.0)<eps||\n       abs(par.y)<eps||abs(par.y-1.0/3.0)<eps||abs(par.y-2.0/3.0)<eps||abs(par.y-1.0)<eps)\n        objColor = vec3(0);\n}\n\nvoid sphere(in vec3 center, in float r, in vec3 col)\n{\n\tfloat B = 2.0*dot(rayDir, rayOrig - center);\n\tfloat C = dot( rayOrig - center, rayOrig - center) - r*r;\n\n\tfloat discr = B*B - 4.0*C;\n\tif (discr < 0.0) return;\n\n\tfloat tt = 0.5*(-B - sqrt(discr));\n\n    if(tt > 0.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(rayOrig + tt*rayDir - center);\n\t\tobjColor = col;\n    }\n}\n\nvoid octahedron(in vec3 c, in float r, in vec3 col)\n{\n    vec3 x = vec3(r, 0, 0);\n    vec3 y = vec3(0, r, 0);\n    vec3 z = vec3(0, 0, r);\n    triangle(c+z, c+x, c+y, col);\n    triangle(c+x, c-z, c+y, col);\n    triangle(c-z, c-x, c+y, col);\n    triangle(c-x, c+z, c+y, col);\n    triangle(c+x, c+z, c-y, col);\n    triangle(c-z, c+x, c-y, col);\n    triangle(c-x, c-z, c-y, col);\n    triangle(c+z, c-x, c-y, col);\n}\n\nvoid frame(in vec3 corner, in vec3 dir1, in vec3 dir2, in float frameSize, out bool inside, in vec3 col)\n{\n    inside = false;\n    vec2 locPar = vec2(0,0);\n    float old_t = t;\n    vec3 old_norm = norm;\n\tvec3 old_col = objColor;\n    parallelogram(corner, dir1, dir2, locPar, col);\n\n\tif(locPar.x > frameSize && locPar.y > frameSize && locPar.x < 1.0 - frameSize && locPar.y < 1.0 - frameSize){\n\t\tt = old_t;\n\t\tnorm = old_norm;\n\t\tobjColor = old_col;\n\t\tinside = true;\n\t}\n}\n\nvoid outerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, out int lookThrough, in vec3 col)\n{\n    lookThrough = 0;\n    vec3 minCorner = centerPos - sideLength/2.0;\n    vec3 maxCorner = centerPos + sideLength/2.0;\n    vec3 x = vec3(sideLength,0,0);\n    vec3 y = vec3(0,sideLength,0);\n    vec3 z = vec3(0,0,sideLength);\n    bool intersect = false;\n    bool inside = false;\n    // back\n    frame(minCorner, z, y, frameSize, inside, col);\n\tlookThrough = inside ? 1 : lookThrough;\n    // bottom\n    frame(minCorner, x, z, frameSize, inside, col);\n\tlookThrough = inside ? 2 : lookThrough;\n    // right\n    frame(minCorner, y, x, frameSize, inside, col);\n\tlookThrough = inside ? 3 : lookThrough;\n    // front\n    frame(maxCorner, -y, -z, frameSize, inside, col);\n\tlookThrough = inside ? 4 : lookThrough;\n    // top\n    frame(maxCorner, -z, -x, frameSize, inside, col);\n\tlookThrough = inside ? 5 : lookThrough;\n    // left\n    frame(maxCorner, -x, -y, frameSize, inside, col);\n\tlookThrough = inside ? 6 : lookThrough;\n}\n\nvoid innerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, in vec3 col)\n{\n    vec3 minCorner = centerPos - sideLength/2.0;\n    vec3 maxCorner = centerPos + sideLength/2.0;\n    vec3 x = vec3(sideLength,0,0);\n    vec3 y = vec3(0,sideLength,0);\n    vec3 z = vec3(0,0,sideLength);\n    float absFrame = frameSize*sideLength;\n    vec3 xx = vec3(absFrame,0,0);\n    vec3 yy = vec3(0,absFrame,0);\n    vec3 zz = vec3(0,0,absFrame);\n    bool inside = false;\n    // back\n    frame(minCorner+xx, y, z, frameSize, inside, col);\n    // bottom\n    frame(minCorner+yy, z, x, frameSize, inside, col);\n    // right\n    frame(minCorner+zz, x, y, frameSize, inside, col);\n    // front\n    frame(maxCorner-xx, -z, -y, frameSize, inside, col);\n    // top\n    frame(maxCorner-yy, -x, -z, frameSize, inside, col);\n    // left\n    frame(maxCorner-zz, -y, -x, frameSize, inside, col);\n}\n\nvoid parallelogram(in vec3 corner, in vec3 dir1, in vec3 dir2, inout vec2 par, in vec3 col)\n{\n    vec3 faceNormal = cross(dir1, dir2);\n    if(dot(rayDir, faceNormal) >= 0.0) return;\n    \n    mat3 A = mat3(dir1, dir2, -rayDir);\n    vec3 b = rayOrig - corner;\n    \n    vec3 a_b_t = inverse(A)*b;\n    float aa = a_b_t.x;\n    float bb = a_b_t.y;\n    float tt = a_b_t.z;\n    \n    if(aa >= 0.0 && aa <= 1.0 && bb >= 0.0 && bb <= 1.0 && tt >= 0.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(faceNormal);\n\t\tobjColor = col;\n\t\tpar = vec2(aa, bb);\n    }\n}\n\nvoid triangle(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 col)\n{\n    vec3 dir1 = p2 - p1;\n    vec3 dir2 = p3 - p1;\n    vec3 faceNormal = cross(dir1, dir2);\n    if(dot(rayDir, faceNormal) >= 0.0) return;\n    \n    mat3 A = mat3(dir1, dir2, -rayDir);\n    vec3 b = rayOrig - p1;\n    \n    vec3 a_b_t = inverse(A)*b;\n    float aa = a_b_t.x;\n    float bb = a_b_t.y;\n    float tt = a_b_t.z;\n    \n    if(aa >= 0.0 && bb >= 0.0 && tt >= 0.0 && aa + bb <= 1.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(faceNormal);\n\t\tobjColor = col;\n    }\n}\n\nvec3 shade(in vec3 pos, in vec3 normal, in bool shadowed)\n{\n\tvec3 ambient = 0.2*objColor;\n    if(shadowed) return clamp(ambient, 0.0, 1.0);\n    \n\tvec3 toLight = normalize(light_pos - pos);\n\tfloat di = clamp(dot(toLight, normal), 0.0, 1.0);\n\tvec3 diffuse = di*objColor;\n\t\n\tvec3 specular = vec3(0);\n\tif (di > 0.0)\n\t{\n\t\tvec3 e = normalize(eye - pos);\n\t\tvec3 r = reflect(-toLight, normal);\n\t\tfloat si = pow(clamp(dot(e, r), 0.0, 1.0), specular_power);\n\t\tspecular = si*vec3(0.9);\n\t}\n\n\treturn clamp(ambient + diffuse + specular, 0.0, 1.0);   \n}\n\nvec3 polarToDesc(in float r, in float phi, in float theta)\n{\n    return r*vec3(cos(phi)*sin(theta), cos(theta), sin(phi)*sin(theta));\n}\n\nfloat metaBall(in vec2 c, in float r, in vec2 p){\n    float d = distance(c, p) / r;\n    return (d >= 1.0) ? 0.0 : clamp(2.0*d*d*d - 3.0*d*d + 1.0, 0.0, 1.0);\n}\n\nfloat metaBalls(in vec2 p){\n    vec2 c1 = vec2(0.5); \n    float r1 = 0.2;\n    vec2 c2 = 0.5+0.3*vec2(cos(iTime),sin(iTime));\n    float r2 = 0.2;\n    vec2 c3 = 0.5+0.3*vec2(cos(2.0*iTime),sin(4.0*iTime));\n    float r3 = 0.1;\n    vec2 c4 = 0.5+0.2*vec2(cos(iTime),-sin(iTime));\n    float r4 = 0.1;\n    \n    float f = \n        metaBall(c1, r1, p)+\n        metaBall(c2, r2, p)+\n        metaBall(c3, r3, p)+\n        metaBall(c4, r4, p);\n    f = clamp(f, 0.0, 1.0);\n    return f;\n}\n\nvoid animatedParalelogram(in vec3 corner, in vec3 dir1, in vec3 dir2)\n{\n    vec3 faceNormal = cross(dir1, dir2);\n    if(dot(rayDir, faceNormal) >= 0.0) return;\n    \n    mat3 A = mat3(dir1, dir2, -rayDir);\n    vec3 b = rayOrig - corner;\n    \n    vec3 a_b_t = inverse(A)*b;\n    float aa = a_b_t.x;\n    float bb = a_b_t.y;\n    float tt = a_b_t.z;\n    \n    if(aa >= 0.0 && aa <= 1.0 && bb >= 0.0 && bb <= 1.0 && tt >= 0.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(faceNormal);\n\t\tobjColor = vec3((metaBalls(vec2(aa,bb)) < 0.25) ? 0.0 : 1.0, 0 ,0);\n    }\n}","name":"Image","description":"","type":"image"}]}