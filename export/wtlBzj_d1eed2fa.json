{"ver":"0.1","info":{"id":"wtlBzj","date":"1597222401","viewed":74,"name":"Raymarched red sphere","username":"pixeljig","description":"Learning raymarching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","red","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float minDistance = 0.001;\nfloat maxDistance = 1000.0;\nconst int maxMarchingSteps = 32;\n\nstruct Sphere {\n   vec3 center;\n   float radius;\n};\n    \nfloat sphereSDF(vec3 p, Sphere sphere) {\n    return length(p - sphere.center) - sphere.radius;\n}\n\nfloat mapTheWorld(vec3 pos) {\n    float sphere0 = sphereSDF(pos, Sphere(vec3(0.0), 1.0));\n    \n    return sphere0;\n}\n\n\nvec3 calcNormal(in vec3 currentPos) {\n    vec3 smallStep = vec3(0.001, 0.0, 0.0);\n    \n    float gradientX = mapTheWorld(currentPos + smallStep.xyy) - mapTheWorld(currentPos - smallStep.xyy);\n    float gradientY = mapTheWorld(currentPos + smallStep.yxy) - mapTheWorld(currentPos - smallStep.yxy);\n    float gradientZ = mapTheWorld(currentPos + smallStep.yyx) - mapTheWorld(currentPos - smallStep.yyx);\n    \n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n    \n    return normalize(normal);\n    \n}\n\nvec3 rayMarchToScene(vec3 p, vec3 rayDir) {\n    float dist = 0.0;\n    float stepDist = dist;\n    \n    for (int i = 0; i < maxMarchingSteps; i++) {\n        vec3 photonPos = p + stepDist*rayDir;\n        \n        dist = mapTheWorld(photonPos);\n        \n        //hit\n        if (dist <= minDistance) {\n       \t\tvec3 normal = calcNormal(photonPos);\n            vec3 lightPos = vec3(2.0, -2.0, sin(iTime));\n            vec3 lightDir = normalize(photonPos - lightPos);\n            float diffuseIntensity = max(0.0, dot(normal, lightDir));\n            \n            return vec3(1.0, 0.0, 0.0) * diffuseIntensity;\n        }\n        \n        //didn't hit anything\n        if (stepDist > 1000.0) {\n            break;\n        }\n        \n        \n        stepDist += dist;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1.0, iResolution.y/iResolution.x);\n    vec2 uv = (fragCoord.xy/iResolution.xy * 2.0 -1.0) * aspectRatio;\n\n    vec3 eyePos = vec3(0.0, 0.0, 5.0);\n    \n    vec3 pixelPos = vec3(uv.xy, 3.0);\n\n    vec3 rayDir = normalize(pixelPos - eyePos);\n    \n    vec3 col = rayMarchToScene(eyePos, rayDir);\n    \n    fragColor = vec4(col, 1.0);\n        \n}","name":"Image","description":"","type":"image"}]}