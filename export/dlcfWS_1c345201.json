{"ver":"0.1","info":{"id":"dlcfWS","date":"1701556663","viewed":84,"name":"Procedural Maze Generator","username":"MrHAX00","description":"A cellular automata that will generate a maze after sufficient amount of steps.\n\nClick again to create a new maze using the current time as its seed!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["procedural","maze","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\n    //Initialization\n    //\n\n    //Initialize the whole maze as -1 which we'll interpret as undetermined except the start location\n    if (iFrame == 0 || iMouse.w > 1.) {\n        if (fragCoord.x < 1. && fragCoord.y < 1.) {\n            fragColor = vec4(StarterState, iTime, 0., 1.);\n        } else {\n            fragColor = vec4(-1., iTime, 0., 1.);\n        }\n        \n        return;\n    }\n    \n    //\n    //Yielding\n    //\n    vec4 CurrentLayout = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //Stop if it hasn't been more than n seconds since the last step\n    if (iTime - CurrentLayout.y < Yield) {\n        fragColor = CurrentLayout;\n        return;\n    } else {\n        CurrentLayout.y += Yield;\n    }\n    \n    //\n    //Cellular automata logic\n    //\n\n    //Stop if we're outside of the maze\n    if (fragCoord.x > MazeX || fragCoord.y > MazeY)\n    {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    };\n    \n    //Stop if the current room is determined\n    if (CurrentLayout.x != -1.) {\n        fragColor = CurrentLayout;\n        return;\n    }\n    \n    //Return if previous rooms are undetermined\n    int IdBellow = int(texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y - 1.), 0).x);\n    int IdLeft = int(texelFetch(iChannel0, ivec2(fragCoord.x - 1., fragCoord.y), 0).x);\n    if (IdBellow == -1 && IdLeft == -1) {\n        fragColor = CurrentLayout;\n        return;\n    }\n    \n    //Get previous room layouts\n    mat3 RoomBellow = Rooms[IdBellow];\n    mat3 RoomLeft = Rooms[IdLeft];\n    \n    //Use a hasing function to find a random layout that fits with previous layouts\n    float Id = 0.;\n    float AttemptCount = Seed;\n    while (true) {\n        Id = floor(hash13(vec3(fragCoord.xy, AttemptCount)) * RoomCount);\n        mat3 Room = Rooms[int(Id)];\n        AttemptCount++;\n        \n        bool CanBreak = true;\n        for (int i = 0; i < 2 && IdBellow != -1; i++) {\n            CanBreak = CanBreak && Room[2][i] == RoomBellow[0][i];\n        }\n        for (int i = 0; i < 2 && IdLeft != -1; i++) {\n            CanBreak = CanBreak && Room[i][0] == RoomLeft[i][2];\n        }\n        \n        if (CanBreak) break;\n    }\n    \n    fragColor = vec4(Id, CurrentLayout.y, 0., 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SquareSDF(vec2 uv, vec2 MinCorner, vec2 MaxCorner, float CornerRadius){\n    vec2 Clamped = clamp(uv, MinCorner + CornerRadius, MaxCorner - CornerRadius);\n    \n    return length(uv - Clamped) - CornerRadius;\n}\n\nfloat DrawRoom(vec2 uv, float LayoutId) {\n    vec2 Tile = fract(uv) * 3.;\n    \n    float Squares = smoothstep(.05, .0, SquareSDF(fract(Tile), vec2(.1), vec2(.9), .2));\n    Squares *= .8 + hash12(floor(uv * 3.)) * .2;\n    Squares -= smoothstep(.05, .0, SquareSDF(fract(Tile), vec2(.2), vec2(.8), .1)) * .3;\n    \n    return Rooms[int(LayoutId)][2 - int(Tile.y)][int(Tile.x)] * Squares;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - iResolution.xy * .5) / iResolution.y + vec2(MazeX / MazeY * .5, .5)) * MazeY;\n    \n    float LayoutId = texelFetch(iChannel0, ivec2(floor(uv)), 0).x;\n    \n    float Room = DrawRoom(uv, LayoutId);\n    fragColor = vec4(vec3(.6, .25, .82) * Room, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MazeX 18.\n#define MazeY 15.\n#define Yield .025\n#define StarterState 3.\n#define Seed iDate.w\n\n//hash functions from https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst mat3 Rooms[] = mat3[](\n    //0 way\n    mat3(\n        1., 1., 1.,\n        1., 1., 1.,\n        1., 1., 1.\n    ),\n    \n    //1 way\n    mat3(\n        1., 1., 1.,\n        1., 0., 0.,\n        1., 0., 1.\n    ),\n    mat3(\n        1., 1., 1.,\n        0., 0., 1.,\n        1., 0., 1.\n    ),\n    mat3(\n        1., 0., 1.,\n        1., 0., 0.,\n        1., 1., 1.\n    ),\n    mat3(\n        1., 0., 1.,\n        0., 0., 1.,\n        1., 1., 1.\n    ),\n    mat3(\n        1., 0., 1.,\n        1., 0., 1.,\n        1., 0., 1.\n    ),\n    mat3(\n        1., 1., 1.,\n        0., 0., 0.,\n        1., 1., 1.\n    ),\n    \n    //2 way\n    mat3(\n        1., 0., 1.,\n        1., 0., 0.,\n        1., 0., 1.\n    ),\n    mat3(\n        1., 0., 1.,\n        0., 0., 1.,\n        1., 0., 1.\n    ),\n    \n    mat3(\n        1., 0., 1.,\n        0., 0., 0.,\n        1., 1., 1.\n    ),\n    mat3(\n        1., 1., 1.,\n        0., 0., 0.,\n        1., 0., 1.\n    ),\n    \n    //3 way\n    mat3(\n        1., 0., 1.,\n        0., 0., 0.,\n        1., 0., 1.\n    )\n);\n\nconst float RoomCount = float(Rooms.length());","name":"Common","description":"","type":"common"}]}