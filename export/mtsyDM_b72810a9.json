{"ver":"0.1","info":{"id":"mtsyDM","date":"1691496324","viewed":71,"name":"Rounded Polygon SDF","username":"TheTurk","description":"Distance function for a rounded polygon. Based on [url]https://www.shadertoy.com/view/mdl3R8[/url]. Simplified the math and added ability to handle polygons with a variable number of sides and the ability to specify a distinct radius for every corner.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","distance","polygon","path","arc","shape","rounded","corner","primitive","corners"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_POINT_COUNT = 16;\n\nfloat polygon(vec2 position, vec2[MAX_POINT_COUNT] points, float[MAX_POINT_COUNT] radii, int pointCount) {\n    float d1 = float(0xffffffffU);\n    float d2 = float(0xffffffffU);\n    float s = 1.0;\n    \n    vec2[MAX_POINT_COUNT] startPoints;\n    vec2[MAX_POINT_COUNT] endPoints;\n    for (int i = pointCount - 2, j = pointCount - 1, k = 0; k < pointCount; i = j, j = k, k++) {\n        vec2 point1 = points[i];\n        vec2 point2 = points[j];\n        vec2 point3 = points[k];\n        float radius = radii[j];\n        vec2 position = position - point2;\n        vec2 a = normalize(point1 - point2);\n        vec2 b = normalize(point3 - point2);\n        vec2 center = (a + b) * radius / abs(a.x * b.y - a.y * b.x);\n        position -= center;\n        // even-odd rule\n        float c = radius * radius - position.y * position.y;\n        if (c > 0.0) {\n           c = sqrt(c);\n           vec2 p1 = vec2(-c, position.y); \n           vec2 p2 = vec2(c, position.y);\n           float s1 = dot(p1, a);\n           float s2 = dot(p1, b);\n           float s3 = dot(p2, a);\n           float s4 = dot(p2, b);\n           if (position.x < p1.x && s1 < 0.0 && s2 < 0.0) {\n               s = -s;\n           }\n           if (position.x < p2.x && s4 < 0.0 && s3 < 0.0) {\n               s = -s;\n           }\n        }\n        float s1 = dot(position, a);\n        float s2 = dot(position, b);\n        if (s1 < 0.0 && s2 < 0.0) {\n            float d = abs(length(position) - radius);\n            d1 = min(d1, d); \n        }\n        vec2 start = point2 + a * dot(center, a);\n        vec2 end = point2 + b * dot(center, b);\n        startPoints[k] = start;\n        endPoints[k] = end;\n    }\n    \n    for (int i = pointCount - 1, j = 0; j < pointCount; i = j, j++) {\n        vec2 start = endPoints[i];\n        vec2 end = startPoints[j];\n        vec2 e = end - start;\n        vec2 p = position - start;\n        float h = clamp(dot(p, e) / dot(e, e), 0.0, 1.0);\n        vec2 d = p - e * h;\n        d2 = min(d2, dot(d, d));\n        // even-odd rule\n        if ((p.y > 0.0) != (p.y > e.y)) {\n            if ((e.y * p.x < e.x * p.y) != (e.y < 0.0)) {\n                s = -s;\n            } \n        }\n    }\n    \n    return min(d1, sqrt(d2)) * s;\n}\n\n/*\n\n// variant with a single radius for every corner\n\nfloat polygon(vec2 position, vec2[MAX_POINT_COUNT] points, float radius, int pointCount) {\n    float d1 = float(0xffffffffU);\n    float d2 = float(0xffffffffU);\n    float s = 1.0;\n    \n    vec2[MAX_POINT_COUNT] startPoints;\n    vec2[MAX_POINT_COUNT] endPoints;\n    for (int i = pointCount - 2, j = pointCount - 1, k = 0; k < pointCount; i = j, j = k, k++) {\n        vec2 point1 = points[i];\n        vec2 point2 = points[j];\n        vec2 point3 = points[k];\n        vec2 position = position - point2;\n        vec2 a = normalize(point1 - point2);\n        vec2 b = normalize(point3 - point2);\n        vec2 center = (a + b) * radius / abs(a.x * b.y - a.y * b.x);\n        position -= center;\n        // even-odd rule\n        float c = radius * radius - position.y * position.y;\n        if (c > 0.0) {\n           c = sqrt(c);\n           vec2 p1 = vec2(-c, position.y); \n           vec2 p2 = vec2(c, position.y);\n           float s1 = dot(p1, a);\n           float s2 = dot(p1, b);\n           float s3 = dot(p2, a);\n           float s4 = dot(p2, b);\n           if (position.x < p1.x && s1 < 0.0 && s2 < 0.0) {\n               s = -s;\n           }\n           if (position.x < p2.x && s4 < 0.0 && s3 < 0.0) {\n               s = -s;\n           }\n        }\n        float s1 = dot(position, a);\n        float s2 = dot(position, b);\n        if (s1 < 0.0 && s2 < 0.0) {\n            float d = abs(length(position) - radius);\n            d1 = min(d1, d); \n        }\n        vec2 start = point2 + a * dot(center, a);\n        vec2 end = point2 + b * dot(center, b);\n        startPoints[k] = start;\n        endPoints[k] = end;\n    }\n    \n    for (int i = pointCount - 1, j = 0; j < pointCount; i = j, j++) {\n        vec2 start = endPoints[i];\n        vec2 end = startPoints[j];\n        vec2 e = end - start;\n        vec2 p = position - start;\n        float h = clamp(dot(p, e) / dot(e, e), 0.0, 1.0);\n        vec2 d = p - e * h;\n        d2 = min(d2, dot(d, d));\n        // even-odd rule\n        if ((p.y > 0.0) != (p.y > e.y)) {\n            if ((e.y * p.x < e.x * p.y) != (e.y < 0.0)) {\n                s = -s;\n            } \n        }\n    }\n    \n    return min(d1, sqrt(d2)) * s;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n   \n    vec2[MAX_POINT_COUNT] points;\n    points[0] = 0.8 * cos(0.4 * (iTime - 9.0) + vec2(0.0, 2.0));\n    points[1] = 0.8 * cos(0.45 * (iTime - 9.0) + vec2(1.0, 2.5));\n    points[2] = 0.8 * cos(0.5 * (iTime - 9.0) + vec2(2.0, 5.0));\n    points[3] = 0.8 * cos(0.55 * (iTime - 9.0) + vec2(4.0, 6.0));\n    points[4] = 0.8 * cos(0.6 * (iTime - 9.0) + vec2(5.0, 6.0));\n     \n    // compute safe radii for random polygon\n    float[MAX_POINT_COUNT] radii;\n    int pointCount = 5;\n    for (int i = pointCount - 2, j = pointCount - 1, k = 0; k < pointCount; i = j, j = k, k++) {\n        vec2 point1 = points[i];\n        vec2 point2 = points[j];\n        vec2 point3 = points[k];\n        float a = length(point2 - point1);\n        float b = length(point3 - point2);\n        float c = length(point1 - point3);\n        float s = 0.5 * (a + b + c);\n        float radius = sqrt((s - a) * (s - b) * (s - c) / s);\n        radii[j] = radius * 0.45;\n    }\n    \n    float d = polygon(position, points, radii, pointCount);\n     \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d);\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    if (iMouse.z > 0.0) {\n        vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        float d = polygon(mousePosition, points, radii, pointCount);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 3.0, abs(length(position - mousePosition) - abs(d)) * iResolution.y - 1.0));\n    }\n    fragColor = vec4(color, 1.0);\n} ","name":"Image","description":"","type":"image"}]}