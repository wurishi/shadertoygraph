{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// This shader supports multiple modes to illustrate the different noises used in this shader.\n// Mode 0: Visualizes the hash-key for the given pixel.\n// Mode 1: Visualizes the hash-key with an additional time dependency to illustrate the non-coherent nature of the noise.\n// Mode 2: Visualizes the (1st octave) of the Perlin noise used, based on the hask-key.\n// Mode 3: Visualizes a fractal sum using the Perlin noise and two simple applications for the fractal sum noise.\n#define MODE 3\n\n// == Constants: Procedural clouded sky ===================\nconst vec4 skyColor = vec4(0.4, 0.4, 1.0, 1.0);\nconst vec4 cloudColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n// == Constants: Prcedural geographic map =================\nconst vec4 seaColor = vec4(0.16, 0.62, 0.82, 1.0);\nconst vec4 landColor = vec4(0.92, 0.95, 0.0, 1.0);\n\n/**\n * Creates a hashkey based on a 3D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash(in vec3 p){\n    // Transform 3D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec3(123.45, 678.91, 234.56));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Creates a hashkey based on a 2D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash(in vec2 p){\n    // Transform 2D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec2(12.34, 56.78));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm. Haskeys are\n * used to remove the need of an array of random values.\n * @return: noise value in the range[0.0, 1.0)\n */\nfloat perlinNoise( in vec2 p )\n{\n    // see: http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html#whatsnoise\n    vec2 i = floor(p); // Use hashing with this to fake a gridbased value noise.\n    vec2 f = fract(p);\n\t\n    // Using this 'ease curve' generates more visually pleasing noise then without.\n    // Function describes a function similar to a smoothstep.\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix(hash(i + vec2(0.0,0.0)), \n                    hash(i + vec2(1.0,0.0)), u.x),\n                mix(hash(i + vec2(0.0,1.0)), \n                    hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm, based on the\n * 'perlinNoise' function.\n * @return: noise value in the range[-1.0, 1.0)\n */\nfloat signedPerlinNoise(in vec2 p){\n    return 2.0 * perlinNoise(p) - 1.0;\n}\n\n/**\n * Performs a fractal sum of the same noise function for different 'frequencies'.\n * @return: noise value in the range [0.0, ~1.94)\n */\nfloat fractalSumNoise(in vec2 p){\n    float value = 0.0;\n    \n    float f = 1.0;\n    \n    // Experimentation yielded 5 itterations gave optimal results. Less itterations gave too\n    // blotchy result, and more itterations did no longer have any significant visual impact.\n    for (int i = 0; i < 5; i++){\n        value += perlinNoise(p * f)/f;\n        f = f * 2.0;\n    }\n    \n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // Range: [0.0, 1.0]\n    \n    // This shader uses different visulization modes to illustrate the different\n    // components used in the shader.\n    #if MODE == 0\n    // Demonstrates the hask-key function used.\n    float h = hash(uv*10.0);\n    #elif MODE == 1\n    // Demonstrates the non-coherent noise properties of the hash method.\n    float h = hash(vec3(uv*10.0, iTime*0.001));\n    #elif MODE == 2\n    // Demonstrates the coherent Perlin noise, showing the 1st octave of the fractal\n    // sum example of mode 3\n    float h = perlinNoise(uv*10.0);\n    #else\n    float h = fractalSumNoise(uv*10.0);\n    #endif\n    \n    // The greyscale color of the noise-value:\n    vec4 greyScale = vec4(h,h,h,1.0);\n    \n    // Animation mixing index value:\n    float animIndex = clamp(1.0-cos(iTime), 0.0, 1.0);\n    \n    // Show 3 vertical panels:\n    if(abs(uv.x - 0.333) < 0.001){\n        // 1st border.\n       fragColor = vec4(0.2, 0.2, 0.2, 1.0); \n    }\n    else if (uv.x < 0.333){\n        // Greyscale version of the noise.\n        fragColor = greyScale;\n    }\n    else if (abs(uv.x - 0.666) < 0.001){\n        // 2nd border.\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0); \n    }\n    #if MODE > 2\n    else if (uv.x <  0.666){\n        // 2nd panel: Application of the fractal noise to procedurally generate a simple geographic map.\n        h = smoothstep(0.85, 1.0, h);\n        vec4 mapColor = mix(landColor, seaColor, h);\n        fragColor = mix(greyScale, mapColor, animIndex);\n    }\n    else if (uv.x < 1.0)\n    {\n        // 3rd panel: application of the fractal noise to precedurally generate a simple clouded sky.\n        h = smoothstep(0.0, 0.7, h);\n        vec4 cloudSkyColor = mix(cloudColor, skyColor, h);\n    \tfragColor = mix(greyScale, cloudSkyColor, animIndex);\n    }\n    #endif\n    else{\n        // Show greyscale in case application panels are not used:\n        fragColor = greyScale;\n    }\n}\n    ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2SRK","date":"1414441517","viewed":172,"name":"Experimenting with noise","username":"xilconic","description":"Experimenting a little with procedural noise generation. Change the MODE variable value to 0, 1, 2 or 3 to show various aspects of noise aspects used inside this shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","perlin","documented"],"hasliked":0,"parentid":"","parentname":""}}