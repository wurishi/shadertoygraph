{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//sans normal by eiffie (lighting without finding the surface normal)\n//Some of my multisampling stuff requires a number of lighting calcs so I was wondering\n//what the minimum number of DE taps would be to calc diffuse and spec terms. 2\n//The lighting calc is at the end and they are simply based on DE ratios.\n\n//v2 I decided to add the aforementioned multisampling.\n\n//I have yet to find a scene that didn't benefit from overstepping!\n#define AUTO_OVERSTEP\n#define LOTSAPOTS 2\n\nfloat textureIt(vec3 p){\n\tp*=64.0;\n\treturn clamp(0.5*abs(sin(p.y+sin(p.x+sin(p.z)))),0.0,0.33);\n}\nfloat ohfudge;\nfloat DE(in vec3 p0){\n\tvec2 v=vec2(2.0,2.5);\n\tp0.xz=mod(p0.xz+v,2.0*v)-v;\n\tvec3 p=p0;\n\tfloat d=100.0,scl=1.0;\n\tfor(int i=0;i<LOTSAPOTS;i++){\n\t\tfloat r=0.5+sin((p.y+0.75)*3.5)*0.25;\n\t\tfloat o0=length(max(abs(vec2((length(p)-0.8)*0.57,p.y+1.0))-vec2(0.0,0.6),0.0))-0.02;\n\t\tp.z-=sign(p.z)*1.6;\n\t\tfloat o1=length(max(abs(vec2((length(p.xz)-r)*0.7,p.y))-vec2(0.0,1.0),0.0))-0.02;\n\t\tp.x-=sign(p.x)*1.4;\n\t\tfloat d0=max(abs(p.z),abs(p.x))-r*0.707;\n\t\tfloat d1=0.577*(max(abs(p.x+p.z),abs(p.x-p.z))-r);\n\t\tfloat o2=length(max(abs(vec2(max(d0,d1)*0.8,p.y))-vec2(0.0,1.0),0.0))-0.02;\n\t\tp.z-=sign(p.z)*1.0;\n\t\tp.y+=0.75;\n\t\td=min(d,min(o0,min(o1,o2))*scl);\n\t\tp*=5.0;scl*=0.2;\n\t}\n\tp0.xz=abs(p0.xz)-v*0.5;\n\td-=textureIt(p0)*0.004;\n\treturn abs(d)*ohfudge;\n}\n\nfloat rnd(vec2 p){return fract(sin(dot(p,vec2(317.234,13.241)))*423.1123);}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfloat tim=iTime*0.3;\n\tvec3 ro=vec3(sin(tim),1.0,cos(tim))*(1.5+iTime*0.015);\n\tvec3 rd=vec3(uv,1.0);\n\tfloat px=2.5/iResolution.y;\n\tvec3 fw=-ro;\n\tif(mod(iTime,40.0)>20.0){\n\t\ttim*=2.0;\n\t\tro=vec3(-tim,0.6+sin(tim)*0.3,2.0+sin((0.5+tim)*1.57));\n\t\ttim+=1.5;\n\t\tfw=vec3(-tim,0.5+sin(tim)*0.3,2.0+sin((0.5+tim)*1.57))-ro;\n\t}\n\tif(mod(iTime,60.0)>40.0){ro=vec3(-tim,-0.62,2.5);fw=vec3(1.0,0.0,0.0);}\n\trd=lookat(fw)*normalize(rd);\n\tohfudge=0.9-abs(rd.y)*0.3;\n\tfloat t=DE(ro)*rnd(fragCoord.xy),d,pd=10.0,os=0.0,step;\n\tfloat tG=-(1.0+ro.y)/rd.y;if(tG<0.0)tG=10.0-tG;\n\tvec4 hit=vec4(-100.0);//clear stack\n\tfor(int i=0;i<64;i++){\n\t\td=DE(ro+rd*t);\n#ifdef AUTO_OVERSTEP\n\t\tif(d>=os){\t\t//we have NOT stepped over anything\n\t\t\tos=0.44*d*d/pd;//overstep based on ratio of this step to last\n\t\t\tstep=d+os;\t//add in the overstep\n\t\t\tpd=d;\t\t//save this step length for next calc\n\t\t}else{step=-os;d=1.0;pd=100000.0;os=0.0;}//remove overstep\n#else\n\t\tstep=d;\n#endif\n\t\tif(d<0.75*px*t)hit=vec4(hit.yzw,t);//enough of a contribution to matter\n\t\tt+=step;\n\t\tif(hit.x>0.0 || t>tG)break;//the stack is full or marched out of bounds\n\t}\n\t\n\tvec2 so=(ro.xz+rd.xz*tG)*vec2(25.0,50.0);\n\tvec3 col=vec3(0.7+0.3*abs(sin(so*2.0)+sin(so+sin(so.yx))),0.8);\n\t\n\tif(rd.y>0.0)col=vec3(0.05+0.05*sin(atan(rd.x,rd.z)*10.0),0.0,0.0)*rd.y;\n\telse col*=exp(-tG*0.1)*0.25*sqrt(abs(DE(ro+rd*tG)));\n\t\n\tvec3 lightDir=normalize(vec3(0.1,0.2,0.6));\n\tvec3 in4r=normalize(lightDir-rd);//ideal normal for reflection (half ray)\n\tvec3 lightCol=vec3(2.0,0.5,0.0);\n\tvec3 diffuse=vec3(0.5,0.4,0.3);\n\tfor(int i=0;i<4;i++){\n\t\thit=hit.wxyz;\n\t\tif(hit.x>0.0){\n\t\t\tvec3 so=ro+rd*hit.x;\n\t\t\td=DE(so);\n\t\t\t\n\t\t\t//Here are the lighting calcs without a normal.\n\t\t\tvec3 scol=diffuse*clamp(pow(0.5*DE(so+d*lightDir)/d,2.0),0.0,1.0);//self shadow\n\t\t\tscol+=lightCol*clamp(pow(0.5*DE(so+d*in4r)/d,8.0),0.0,1.0);//specular\n\t\t\t\n\t\t\tcol=mix(scol*exp(-hit.x*0.1),col,clamp(d/(px*hit.x),0.0,1.0));\n\t\t}\n\t}\n\tuv=vec2(uv.x+uv.y,uv.x-uv.y);\n\tfloat dim=1.0-0.1*abs(mod(iTime,20.0)-10.0);\n\tfloat vig=clamp(dim-0.15*length(uv*uv),0.0,1.0)*4.0;\n\tfragColor = vec4(col*vig,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"//more fractal music by eiffie\n#define bps 5.0\n\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return 440.0 * pow(2.0, (n - 67.0) / 12.0);}\n\nfloat nofs(float n){//the song's \"random\" ring\n    n=mod(n,6.0);\n    if(n<1.0)return 0.0;\n    if(n<2.0)return 1.0;\n    if(n<3.0)return 2.0;\n    if(n<4.0)return -1.0;\n    if(n<5.0)return 2.0;\n    if(n<6.0)return 1.0;\n    if(n<7.0)return -1.0;\n    return 0.0;\n}\nfloat scale(float note){//throws out dissonant tones\n    float n2=mod(note,12.0);\n    //if((n2==2.0)||(n2==3.0)||(n2==5.0)||(n2==7.0)||(n2==9.0))note=-100.0;//enigmatic\n    //if((n2==1.0)||(n2==2.0)||(n2==4.0)||(n2==6.0)||(n2==8.0)||(n2==9.0)||(n2==11.0))note=-100.0;//pent minor\n\tif((n2==1.0)||(n2==4.0)||(n2==6.0)||(n2==9.0)||(n2==11.0))note=-100.0;//minor\n\n    return note;\n}\nfloat saw(float t){\n    float f=fract(t),f2=fract(t+0.1),f3=fract(t*1.005);\n    return 0.5*abs(f*f2*f3-0.5)-0.125;\n}\nfloat square(float t){return sign(fract(t)-0.5)*0.125;}\nfloat rand(float t){return fract(sin(t*341.545234)*1531.2341);}\nfloat att(float t){\n    return exp(-2.0*t)*min(t*10.0,1.0);\n}\n#define TAO 6.2831\nvec2 mainSound( in int samp,float time)\n{\n    float tim=time*bps;\n    float b=floor(tim);\n    float t=fract(tim);\n    float t1=mod(tim,2.0)*0.5;\n    float t2=mod(tim,4.0)*0.25;\n    float t3=mod(tim,8.0)*0.125;\n    float t4=mod(tim,16.0)*0.0625;\n    float n0=0.0,n1=0.0,n2=0.0,n3=0.0,n4=0.0;\n    \n  \tn4+=nofs(b*0.0625);\n    n3+=n4+nofs(b*0.125);\n    n2+=n3+nofs(b*0.25);\n    n1+=n2+nofs(b*0.5);\n    n0+=n1+nofs(b);//fractal buildup of notes like a landscape\n    \n    if(mod(b,8.0)<1.0){b=rand(time)-0.5;b*=t*0.2*rand(time*0.0001);}\n    else b=0.0;\n    \n    float f0=ntof(scale(n0+72.0))*time;\n    float f1=ntof(scale(n1+60.0))*time;\n    float f1h=ntof(scale(n1+64.0))*time*1.002;\n    float f2=ntof(scale(n2+48.0))*time;\n    float f2h=ntof(scale(n2+52.0))*time*0.999;\n    return min(time*0.025,0.5)*vec2( b+square(f0)*att(t*0.75)*rand(t)+(saw(f1)+saw(f1h))*att(t1)+(saw(f2)+saw(f2h))*att(t2) );\n}\n\n","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xll3zH","date":"1418664068","viewed":386,"name":"sans normal","username":"eiffie","description":"As he cracked the seal and peered into the ancient tomb he wondered what treasures he would find... \noh crap, more pots.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["whacklighting"],"hasliked":0,"parentid":"","parentname":""}}