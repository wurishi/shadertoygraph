{"ver":"0.1","info":{"id":"tlKBD3","date":"1615228282","viewed":126,"name":"ring shader","username":"csgradle","description":"since i made a grid shader last time, this time I'm making rings\nbreakdown:\n- noise coordinate distortion\n- rings from the center\n- one regular grid, and one rotated grid\n- horizontal particles\n- color distortion","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["rings","ring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat ring(vec2 st, float size, float ringSize) {\n    return ringSize*abs(0.5-mod(length(st), 1./size)*size);\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0, 0.0,_scale.y);\n}\nfloat brick(vec2 st, vec2 size, float thickness) {\n    float xt = fract(st.x*size.x);\n    float yt = fract(st.y*size.y);\n    return step(1.-thickness*(size.x/size.y), xt)+step(1.-thickness,yt);\n}\n// getVal does practically everything. \n// distorts the space, creates a ring, adds two grids, \n// rotates the color, and adds horizontal particles\nvec3 getVal(vec2 uv, float difference) {\n    float distortion = noise(uv*3.)*0.3+0.5;\n    vec2 st = uv * scale(vec2(1.+distortion)*(1.+difference));\n    return vec3(ring(st*scale(vec2(0.2*sin(iTime*0.5+1.4))), 10., 3.) \n            + brick(st, vec2(10.), 0.03)\n            + brick(st*rotate2d(iTime*0.1), vec2(10.), 0.03) \n            + rotate2d(iTime)\n            + step(0.4, noise((st+ vec2(-iTime*0.2,0))*10.*scale(vec2(0.3, 10.)))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    float colorDistortionAmount = 0.5;\n    // split into r, g, and b to distort color\n    float r = getVal(uv, -colorDistortionAmount).r;\n    float g = getVal(uv, 0.).g; // supposed to be 0 but it looks cooler with 0.5\n    float b = getVal(uv, colorDistortionAmount).b;\n    \n    vec3 col =  vec3(r,g,b);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}