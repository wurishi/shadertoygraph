{"ver":"0.1","info":{"id":"cdVcRy","date":"1698137347","viewed":35,"name":"M1 Lyon 1 - Tp projet","username":"wail","description":"HASSAN BABIKER Wail p1802896\nZEMOURI Adnane p1812386\n\nProjet du tp de M1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tpprojet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//structure de donnée\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Ellipsoid{\n    vec3 ce; //Center\n    float a,b,c;\n    int i;\n};\n\nstruct Box{\n    vec3 minPoint; // Coin min\n    vec3 maxPoint; // Coin max\n    int i;// Texture Id\n};\n\nstruct Disk {\n    vec3 c;  // Center \n    vec3 n;  // Normal \n    float r; // Radius\n    int i; // Texture Id\n};\n\nstruct Cylinder {\n    vec3 c; // Center\n    float r; // Radius\n    float h; // Height\n    int i; // Texture Id\n};\n\nstruct Capsule{\n    vec3 c;     // Center of the base\n    float r;    // Radius\n    float h;    // Height\n    int i;      // Texture Id\n};\n\nstruct Torus {\n    vec3 c; // Center\n    vec2 t; // Radius maj et mineur du tore\n    int i; // Identifiant de la texture\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\nstruct Material{\n    vec3 d;// Diffuse\n    vec3 a;//ambient\n    vec3 s;//speculaire\n    vec3 r; // Reflectivity\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nint Checkerboard(vec3 p, float size) {\n    vec3 sp = p / size;\n    int x = int(sp.x);\n    int y = int(sp.y);\n    int z = int(sp.z);\n    \n    return (x + y + z ) % 2;\n}\n\nMaterial CheckerboardTexture(vec3 p, int i)\n{\n    // Checkerboard pattern\n    float checkerValue = float(Checkerboard(p, 0.25)); \n    \n    if(checkerValue > 0.5) {\n        return Material(vec3(5.,0.,4.),vec3(0.), vec3(0.), vec3(0.)); // Diffuse\n    } else {\n         return Material(vec3(0.), vec3(0.), vec3(5.,0.,4.), vec3(0.)); // Spéculaire\n    }\n    \n}\n\nMaterial UniformTexture(vec3 color) {\n    return Material(color, color, color, vec3(0.));\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return UniformTexture(vec3(1.,0.,0.)); \n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col,col,col, vec3(0.));\n    }\n    else if(i==2){\n        float checkerValue = float(Checkerboard(p, 0.5));\n        vec3 col = vec3(checkerValue);\n        return Material(col,col,col, vec3(0.));\n    }\n    else if(i==3){\n        return CheckerboardTexture(p, i);\n    }\n    else if(i==4){\n        return Material(vec3(1.),vec3(1.), vec3(1.),vec3(1.));\n    }\n    else if (i == 5)\n    {\n        vec3 col = vec3(sin(p.x) * 0.5 + 0.5, cos(p.y) * 0.5 + 0.5, abs(sin(p.z) * 0.5 + 0.5));\n        return Material(col,col, col,vec3(0.));\n    }\n    return Material(vec3(0),vec3(0),vec3(0), vec3(0.));\n}\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n   \nbool IntersectEllipsoid(Ray ray,Ellipsoid el,out Hit x) {\n    vec3 dae = vec3(el.a,el.b,el.c);//demi axes de l'ellipsoide\n    vec3 oc = ray.o - el.ce;\n    float A = dot(ray.d / dae, ray.d / dae);\n    float B = 2. * dot(oc / dae, ray.d / dae);\n    float C = dot(oc / dae, oc / dae) - 1.;\n    \n    float discriminant = B * B - 4. * A * C;\n    if (discriminant < 0.0) {\n        return false; // no intersection\n    }\n\n    float t1 = (-B + sqrt(discriminant)) / (2. * A);\n    float t2 = (-B - sqrt(discriminant)) / (2. * A);\n    float t = min(t1,t2); \n    \n    if (t < 0.) {\n        return false; // no intersection\n    }\n    vec3 p=Point(ray,t);\n    x =Hit(t,normalize(p-el.ce),el.i);\n    return true; // Intersection\n}\n\nbool IntersectBox(Ray ray,Box box,out Hit x)\n{   \n    vec3 invDir = 1.0 / ray.d;\n    vec3 tMin = (box.minPoint - ray.o) * invDir;\n    vec3 tMax = (box.maxPoint - ray.o) * invDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    if (tNear > tFar || tFar < 0.0) {\n        return false; // Pas d'intersection\n    }\n    vec3 p = ray.o + ray.d * tNear;// Calcul intersect\n    \n    vec3 normal;//calcul normal\n    if (abs(p.x - box.minPoint.x) < 0.001) normal = vec3(-1.0, 0.0, 0.0);\n    else if (abs(p.x - box.maxPoint.x) < 0.001) normal = vec3(1.0, 0.0, 0.0);\n    else if (abs(p.y - box.minPoint.y) < 0.001) normal = vec3(0.0, -1.0, 0.0);\n    else if (abs(p.y - box.maxPoint.y) < 0.001) normal = vec3(0.0, 1.0, 0.0);\n    else if (abs(p.z - box.minPoint.z) < 0.001) normal = vec3(0.0, 0.0, -1.0);\n    else if (abs(p.z - box.maxPoint.z) < 0.001) normal = vec3(0.0, 0.0, 1.0);\n    \n    x = Hit(tNear ,normalize(normal), box.i); \n    return true;\n}\n\nbool IntersectDisk(Ray ray, Disk disk, out Hit x) {\n    float t = dot(disk.c - ray.o, disk.n) / dot(ray.d, disk.n);\n\n    if (t > 0.0) {\n        vec3 p = Point(ray, t);\n        float distanceSquared = dot(p - disk.c, p - disk.c);\n\n        if (distanceSquared <= disk.r * disk.r) {\n            x = Hit(t, disk.n, disk.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x) {\n    vec2 p = ray.o.xz - cyl.c.xz;\n    vec2 d = ray.d.xz;\n    float a = dot(d, d);\n    float b = 2. * dot(p, d);\n    float c = dot(p, p) - cyl.r * cyl.r;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant > 0.0) {\n        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t = min(t1, t2);\n        float y = ray.o.y + t * ray.d.y;\n        if (y >= cyl.c.y && y <= cyl.c.y + cyl.h) {\n            vec3 p = Point(ray, t);\n            vec3 n = normalize(vec3(p.x - cyl.c.x, 0.0, p.z - cyl.c.z));\n            x = Hit(t, n, cyl.i);\n            return true;\n            \n        }\n    }\n    x = Hit(1000., vec3(0.), -1);\n    Hit current;\n    bool ret = false;\n    \n    // Test the intersection with the top and bottom disks\n    Disk topDisk = Disk(cyl.c + vec3(0.0, cyl.h, 0.0), vec3(0.0, 1.0, 0.0), cyl.r, cyl.i);\n    Disk bottomDisk = Disk(cyl.c, vec3(0.0, -1.0, 0.0), cyl.r, cyl.i);\n\n    Hit diskHitTop, diskHitBottom;\n    bool diskIntersectedTop = IntersectDisk(ray, topDisk, diskHitTop);\n    bool diskIntersectedBottom = IntersectDisk(ray, bottomDisk, diskHitBottom);\n\n    if (diskIntersectedTop && diskIntersectedBottom) {\n        if (diskHitTop.t < diskHitBottom.t) {\n            x = diskHitTop;\n        } else {\n            x = diskHitBottom;\n        }\n        return true;\n    } else if (diskIntersectedTop) {\n        x = diskHitTop;\n        return true;\n    } else if (diskIntersectedBottom) {\n        x = diskHitBottom;\n        return true;\n    }\n\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule caps, out Hit x) {\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,Sphere(caps.c,caps.r,caps.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinder(ray,Cylinder(caps.c,caps.r,caps.h,caps.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,Sphere(caps.c+ vec3(0., caps.h,0.),caps.r,caps.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    return ret;\n}\n\n\n// Signed distance function for a torus\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n\nbool IntersectTorus(Ray ray, Torus tor, out Hit x) {\n    float tMin = 0.; \n    float tMax = 1000.; \n    float epsilon = 0.001;\n    float tCurrent = tMin;\n\n    // Ray marching loop\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = Point(ray, tCurrent); // Point sur le rayon à la distance tCurrent\n        vec3 localP = p - tor.c; // Convertir le point en coordonnées locales du tore\n\n        // Calcul de la distance signée du point au tore\n        float dist = sdTorus(localP, tor.t);\n\n        // Si la distance est inférieure à epsilon, on a une intersection\n        if (abs(dist) < epsilon) {\n            // Approximation of the normal using the gradient of the SDF\n            vec3 nor = normalize(vec3(\n                sdTorus(localP + vec3(epsilon, 0.0, 0.0), tor.t) - dist,\n                sdTorus(localP + vec3(0.0, epsilon, 0.0), tor.t) - dist,\n                sdTorus(localP + vec3(0.0, 0.0, epsilon), tor.t) - dist\n            ));\n\n            // Stocker les informations d'intersection dans la structure Hit\n            x = Hit(tCurrent, nor, tor.i);\n            return true; // Intersection trouvée\n        }\n\n        // Avancer le long du rayon de la distance calculée\n        tCurrent += dist;\n\n        // Si on dépasse tMax, il n'y a pas d'intersection\n        if (tCurrent >= tMax) {\n            return false;\n        }\n    }\n}\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n\n//////////translation\nSphere translation(Sphere sph, vec3 tr){\n    return Sphere(sph.c+tr, sph.r, sph.i);\n}\n\nEllipsoid translation(Ellipsoid ell, vec3 tr){\n    return Ellipsoid(ell.ce+tr, ell.a, ell.b ,ell.c ,ell.i); \n}\n\nBox translation(Box box, vec3 tr){\n    return Box(box.minPoint+tr,box.maxPoint+tr,box.i);\n}\n\nCylinder translation(Cylinder cyl, vec3 tr){\n    return Cylinder(cyl.c+tr, cyl.r, cyl.h, cyl.i);\n}\n\nCapsule translation(Capsule caps, vec3 tr){\n    return Capsule(caps.c+tr, caps.r, caps.h, caps.i);\n}\n\nTorus translation(Torus torus, vec3 tr){\n    return Torus(torus.c+tr, torus.t, torus.i);\n}\n\n///fonctions\n//opérateur de rotations (matrices)\nmat3 rotationX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotationY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotationZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    Sphere sph1=Sphere(vec3(0.,0.,0.),1.,4);\n    sph1 = translation(sph1, vec3(-2.,6.,1.));\n    //Ellipsoid\n    Ellipsoid el = Ellipsoid(vec3(-6., 0.,1.), 1.,2.,1., 1);\n    //Cylinder\n    Cylinder cyl = Cylinder(vec3(0., -6., 1.), 1., 2., 5);\n    //Capsule\n    Capsule caps = Capsule(vec3(5., 4., 1.), 1., 2., 2);\n    // Définissez la boîte d'origine\n    Box box = Box(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), 5);\n    box = translation(box, vec3(6.,-1.,1.)); \n    \n    //raymarching\n    Torus tor1 = Torus(vec3(-0.0, 0.0, 1.5), vec2(1.0, 0.5), 3);\n   \n    //rotation\n    mat3 rotationX = rotationX(iTime);\n    mat3 rotationY = rotationY(iTime);\n    mat3 rotationZ = rotationZ(iTime);\n    \n    cyl.c = rotationZ * cyl.c;\n    sph1.c = rotationZ * sph1.c;\n    el.ce = rotationZ * el.ce;\n    caps.c = rotationZ * caps.c;\n \n    box.minPoint = rotationZ * box.minPoint;\n    box.maxPoint =  box.minPoint + vec3(2.0, 2.0, 2.0); \n    \n    float timer2 =  mod(iTime, 10.); \n    float timer =  mod(iTime, 5.); \n    if (timer2 >= 5. ){\n        tor1 = translation(tor1, vec3(0.,0., 5. - timer)); \n    }else {\n        tor1 = translation(tor1, vec3(0.,0., timer)); \n    }\n    \n    \n    \n    // Plane\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    \n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoid(ray,el,current)&&current.t<x.t){\n        x=current;\n        ret = true;\n    }    \n    if(IntersectBox(ray,box,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }       \n    if(IntersectCylinder(ray, cyl, current) && current.t < x.t){\n        x=current;\n        ret=true;\n    }    \n    if (IntersectCapsule(ray, caps, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    } \n    if(IntersectTorus(ray,tor1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    return ret;\n}\n\n\n\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.2,.4,.9),vec3(.7,.7,.8),rd.z);\n}\n\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n\n\n\nbool IsInShadow(vec3 point, vec3 lightDir)\n{\n    float bias = 0.001;\n    vec3 shadowRayOrigin = point + bias * lightDir;\n    Ray shadowRay = Ray(shadowRayOrigin, lightDir);\n\n    Hit shadowHit;\n    bool inShadow = Intersect(shadowRay, shadowHit);\n\n    if (inShadow && shadowHit.t < length(shadowRayOrigin - point)) {\n        inShadow = false; // Ignore the shadow if it hits the original surface\n    }\n\n    return inShadow;\n}\n\n\n\n\n\n#define NUM_SAMPLES 64\n#define AMBIENT_OCCLUSION_RADIUS 0.3\n\nvec3 Color(Material m, vec3 n, vec3 l, vec3 v, vec3 p) {\n    vec3 lightDir = normalize(l);\n    vec3 viewDir = normalize(v);\n    vec3 reflectDir = reflect(-lightDir, n);\n\n    // Calcul de l'occlusion ambiante\n    float ambientOcclusion = 0.0;\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        vec3 hemisphereDir = Hemisphere(i, n); // Obtention d'un vecteur de direction aléatoire dans l'hémisphère\n        vec3 pointInHemisphere = p + hemisphereDir * AMBIENT_OCCLUSION_RADIUS;\n        if (!IsInShadow(pointInHemisphere, hemisphereDir)) {\n            ambientOcclusion += 1.0;\n        }\n    }\n    ambientOcclusion /= float(NUM_SAMPLES); // Moyenne des échantillons\n\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * ambientOcclusion * m.a; // Inclure l'occlusion ambiante dans la composante ambiante\n\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * m.d;\n\n    float specularStrength = 0.5;\n    float shininess = 32.0;\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = specularStrength * spec * vec3(1.0, 1.0, 1.0);\n\n    vec3 result = ambient + diffuse + specular;\n\n    return result;\n}\n\nvec3 ReflectRay(vec3 incident, vec3 normal) {\n    return reflect(incident, normal);\n}\n\nvec3 Shade(Ray ray) {\n    vec3 color = vec3(0.0);\n\n    int maxReflections = 2;  // À ajuster selon le niveau de réflexion souhaité\n\n    for (int i = 0; i < maxReflections; i++) {\n        Hit x;\n        bool idx = Intersect(ray, x);\n\n        if (idx) {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture(p, x.i);\n            vec3 viewDir = normalize(ray.o - p);\n            vec3 lightDir = normalize(vec3(1., 1., 1.));\n\n            bool inShadow = IsInShadow(p, lightDir);\n            color = Color(mat, x.n, lightDir, viewDir, p);\n\n            if (inShadow) {\n                color *= 0.5;\n            }\n\n            if (dot(mat.r, vec3(1.)) > 0.0) {\n                vec3 reflectionDir = ReflectRay(ray.d, x.n);\n                ray = Ray(p, reflectionDir);\n            } else {\n                break;  \n            }\n        } else {\n            color = Background(ray.d);\n            break;  \n        }\n    }\n\n    return color;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1))); //position de la caméra\n    vec3 ta=vec3(0.,0.,1.5); //point que l'on vise\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Définir la profondeur maximale pour les réflexions\n    vec3 col = Shade(Ray(ro, rd));\n    \n    fragColor=vec4(col,1.);//couleur opaque\n}","name":"Image","description":"","type":"image"}]}