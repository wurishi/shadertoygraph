{"ver":"0.1","info":{"id":"MltGzB","date":"1470130294","viewed":465,"name":"bezier path","username":"runekill","description":"Simple implementation of bezier path. Unfortunately i didn't get how i can draw all steps for all curves, so i solve this task by &quot;step&quot; workaround. At least it works.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simple","tutorial","bezier","curve","path","heartbeet","ekg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//health bar v 0.2\n//based on works:\n//https://www.shadertoy.com/view/4tlSRr by udart\n//https://www.shadertoy.com/view/lstXDj by akohdr\n#define cirleWidth 0.01\n#define red   vec3(1.00,0.38,0.227)\n#define blue vec3(0.09,0.99,0.55)\n//if health>40 - blue line and some alhorithm for speed, >0 - red line, 0 - straight line.\n#define health 100.\nconst int c = 20; //array size\nconst float size = 10.0;//dotted grid size\n//calculate point based on cubic bezier alhoritm\nvec2 calculateBezierPoint(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float u = 1. - t;\n    float tt = t*t;\n    float uu = u*u;\n    float uuu = uu * u;\n    float ttt = tt * t;\n \n    vec2 p = uuu * p0;    \n    p += 3. * uu * t * p1;   \n    p += 3. * u * tt * p2;    \n    p += ttt * p3;           \n \n    return p;\n}\n//draw line segment\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float l = length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0) );\n    l = smoothstep(cirleWidth,cirleWidth-0.005,l);\n    return l;\n\n}\n//calculate bezier curve\nfloat curve(vec2 uv, vec2 bezierArray[c],float ts)\n{\n    float l=0.;\n    vec2 q0;\n    for (int i=0; i <c; i+=3)\n    {\n        //cordinates of bezier curve control points\n        vec2 p0=bezierArray[i];\n        vec2 p1=bezierArray[i+1];\n        vec2 p2=bezierArray[i+2];\n        vec2 p3=bezierArray[i+3];\n        //first point of bezier curve\n\t\tq0 = calculateBezierPoint(0.,p0,p1,p2,p3);\n\t\t//calculate all points and draw as many of them while j > elapsed time\n        for (float j = 0.; j < 1.01; j+=0.1)\n    \t{\n   \n        \tvec2 q1 = calculateBezierPoint(j,p0,p1,p2,p3);\n        \tl += lineSegment(uv,q0,q1);\n        \tq0 = q1;\n            \n\t\t\t\n    \t}\n        \n    }\n    \n    return l;\n}\n//calculate grid line\nfloat IsGridLine(vec2 fragCoord)\n{\n\tvec2 vGridSquareCoords = fract(fragCoord.xy / vec2(size));\n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vec2(size);\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\treturn fIsGridLine;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.-1.);\n    uv.x+=1.;\n    uv.x *= iResolution.x / iResolution.y;\n    float col = 0.;\n    //creating array of points for bezier lines\n    vec2 bezierArray[c];\n    bezierArray[0] = vec2( -0.0, 0.0);\n    bezierArray[1] = vec2( -0.0+0.1, 0.0);\n    bezierArray[2] = vec2( -0.0+0.2, 0.0);\n    bezierArray[3] = vec2( -0.0+0.3,0.0);\n    bezierArray[4] = vec2( -0.0+0.45, 0.5);\n    bezierArray[5] = vec2( -0.0+0.45, -0.05);\n    bezierArray[6] = vec2( -0.0+0.6, -0.0);\n    bezierArray[7] = vec2( -0.0+0.9, -0.5);\n    bezierArray[8] = vec2( -0.0+0.8, 1.2);\n    bezierArray[9] = vec2( -0.0+0.92, 0.9);\n    bezierArray[10] = vec2( -0.0+1.0, 0.5);\n    bezierArray[11] = vec2( -0.0+1.1, -2.);\n    bezierArray[12] = vec2( -0.0+1.2, 0.0);\n    bezierArray[13] = vec2( -0.0+1.3, 0.00);\n    bezierArray[14] = vec2( -0.0+1.35, 0.15);\n    bezierArray[15] = vec2( -0.0+1.5, 0.0);\n    bezierArray[16] = vec2( -0.0+1.6, 0.0);\n    bezierArray[17] = vec2( -0.0+1.7, 0.0);\n    bezierArray[18] = vec2( -0.0+1.8, 0.0);\n    bezierArray[19] = vec2( -0.0+1.9, 0.0);\n\n\tfloat x,y;\n    vec3 finalcolor;\n    //draw 2 connected bezier curves\n    if (health>40.)\n    {\n        //time calculation for x coordinates and step by step drawing\n    \tfloat ts = mod(iTime,0.04*health)*200./health;\n        //find redraw coordinates\n    \ty = step(ts,uv.x);\n    \tx = smoothstep(uv.x,ts,ts-0.1);\n    \t//draw grid\n    \tcol += min(0.1,IsGridLine(fragCoord));\n        col += min(1.,curve(uv, bezierArray,ts));\n    \tcol += min(1.,curve(vec2(uv.x-1.914,uv.y), bezierArray,ts));\n        //make color out of col value\n    \tfinalcolor = blue*col;\n    } else if (health>0.) \n    {\n        //time calculation for x coordinates and step by step drawing\n    \tfloat ts = mod(iTime,1.6)*5.;\n        //find redraw coordinates\n    \ty = step(ts,uv.x);\n    \tx = smoothstep(uv.x,ts,ts-0.1);\n    \t//draw grid\n    \tcol += min(0.1,IsGridLine(fragCoord));\n        col += min(1.,curve(uv, bezierArray,ts));\n    \tcol += min(1.,curve(vec2(uv.x-1.914,uv.y), bezierArray,ts));\n        //make color out of col value\n    \tfinalcolor = red*col;\n       \n    } else\n    {\n        //time calculation for x coordinates and step by step drawing\n    \tfloat ts = mod(iTime,20.)/5.;\n        //find redraw coordinates\n    \ty = step(ts,uv.x);\n    \tx = smoothstep(uv.x,ts,ts-0.1);\n    \t//draw grid\n    \tcol += min(0.1,IsGridLine(fragCoord));\n\t\tcol += lineSegment(uv, vec2(0.), vec2(3.6,0.)); \n        //make color out of col value\n    \tfinalcolor = red*col;\n        \n    }\n    \n\n\n    //redraw function\n    finalcolor-=vec3(y);\n    finalcolor /=vec3(x);\n    \n\n    \n\tfragColor = vec4(finalcolor, 1);\n}\n","name":"Image","description":"","type":"image"}]}