{"ver":"0.1","info":{"id":"msKGWW","date":"1678594086","viewed":364,"name":"Spiderman without web","username":"ianertson","description":"Couldn't figure out a way to make him actually swing around using spiderweb, or maybe I was just lazy.\nLet me know if you have any good ideas for implementing a spiderweb.\nUpdate: Added spiderweb, enable it in \"Common\"\n\nUse the mouse to look around :)","likes":19,"published":1,"flags":48,"usePreview":1,"tags":["3d","raymarching","raymarch","materials","textures","city","spiderman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getColor(in vec2 uv) { return texture(iChannel0, uv).rgba; }\n\nfloat cdiff(in vec3 a, in vec3 b) {\n    return distance(a, b);\n}\n\nfloat estNoise(in sampler2D samp, in vec2 uv) {\n    vec2 texel = 1.0 / vec2(textureSize(samp, 0).xy);\n    \n    vec3 a = texture(samp, uv).rgb;\n    vec3 b = texture(samp, uv + texel*vec2(-1., 0)).rgb;\n    vec3 c = texture(samp, uv + texel*vec2(1., 0)).rgb;\n    vec3 d = texture(samp, uv + texel*vec2(0, 1)).rgb;\n    vec3 e = texture(samp, uv + texel*vec2(0., -1)).rgb;\n\n    float ab = cdiff(a, b);\n    float ac = cdiff(a, c);\n    float ad = cdiff(a, d);\n    float ae = cdiff(a, e);\n    \n    float bc = cdiff(b, c)*0.9;\n    float bd = cdiff(b, d)*0.9;\n    float be = cdiff(b, e)*0.9;\n    \n    float cd = cdiff(c, d)*0.7;\n    float ce = cdiff(c, e)*0.7;\n    \n    float de = cdiff(d, e)*0.5;\n    \n    float n = ((ab + ac + ad + ae) +\n              (bc + bd + be) +\n              (cd + ce) +\n              (de)) / 10.;\n              \n    return clamp(pow(n, 2.0)*2.5, 0.0, 1.0);\n}\n\nvoid edgeKernel(inout vec4 n[9], sampler2D tex, vec2 coord, float width, float height)\n{\n  float w = 1.0/width;\n  float h = 1.0/height;\n\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\n\nfloat edgeDetectSobel(sampler2D tex, vec2 coord) {\n\n  vec2 texSize = vec2(textureSize(tex, 0).xy);\n\n  vec4 n[9];\n  edgeKernel(n, tex, coord, texSize.x, texSize.y);\n\n  vec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n\n  return clamp(max(max(sobel.r, sobel.g), sobel.b), 0.0, 1.0);\n}\n\nvec3 getMax(in sampler2D samp, in vec2 uv, float f) {\n    vec2 texel = 1.0 / vec2(textureSize(samp, 0).xy);\n    \n    vec3 a = texture(samp, uv).rgb;\n    vec3 b = texture(samp, uv + texel*vec2(-1., 0)).rgb;\n    vec3 c = texture(samp, uv + texel*vec2(1., 0)).rgb;\n    vec3 d = texture(samp, uv + texel*vec2(0, 1)).rgb;\n    vec3 e = texture(samp, uv + texel*vec2(0., -1)).rgb;\n\n    return smax(a, smax(b, smax(c, smax(d, e, f), f), f), f);\n}\n\nvec3 boxBlur(vec2 uv, in float f) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = clamp(1.0+f, 1.0, 2.5) / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\nvec3 shade(in vec2 uv) {\n    vec4 rgba = getColor(uv);\n    vec3 col = rgba.rgb;\n    float depth = rgba.a;\n    float edge = edgeDetectSobel(iChannel0, uv);\n    float no = estNoise(iChannel0, uv);\n    vec3 mcol = getMax(iChannel0, uv, 0.45);\n    vec3 blurred = boxBlur(uv, depth+no);\n    float l = luma(col); \n    col = mix(col, mcol, 0.25*clamp(l*l*length(col), 0.0, 1.0));\n    col = mix(col, blurred, 0.5*clamp(pow(edge+no, 2.), 0.0, 1.0));\n    col = mix(col, blurred, depth);\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    col = shade(uv);\n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AMBIENT 0.07\n#define ENABLE_SPIDERWEB 0\n\n#define R (iResolution.xy)\n#define FF 11.6\n#define T ((iFrame <= 1 || iTime <= 0.000003) ? FF : (iTime + FF))\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define NO(V) (0.5+(0.5*(V)))\n#define RADMIX(A, B, M) radians(mix(A, B, M))\n#define SAMPLE(var, OB, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OB; }\n#define SAMPLE_NOOB(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Object { vec3 p; vec3 q; };\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float z; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 r;\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec2 screenUv;\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), vec2(0.0), vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n        light.type == LIGHT_POINT ? normalize(light.p - p) :\n            normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) /\n            max(0.00001, pow(distance(light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * NdotL * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 normal = normalize(cross(vec3(dx, bumpScale), vec3(dy, bumpScale)));\n    normal += bumpScale * normalize(normal);\n    \n   \n    vec3 next = (wn+normal);\n    float dp = clamp(dot(wn, next), 0.0, 1.0);\n   \n    \n    return normalize(mix(wn, next, mx*dp*length(next)));\n    \n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 pointRot(in vec3 p, in vec3 q) {\n    p.xz *= rot(q.z);\n    p.yz *= rot(q.x);\n    p.xz *= rot(q.y);\n    return p;\n}\n\nvec3 pointRotInv(in vec3 p, in vec3 q) {\n    p.xz *= inverse(rot(q.z));\n    p.yz *= inverse(rot(q.x));\n    p.xz *= inverse(rot(q.y));\n    return p;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,3.,-10.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define WALK 0\n#define DEBUG 0\n#define DEBUG_POS vec3(0, 0, -1)\n#define SPIDER_TIME (T*2.)\n\n#define NEAR 0.003\n#define FAR 87.0\n#define STEPS 87\n#define SHADOW_STEPS 33\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n\n#define ONE_METER 0.5\n\n#define ID_BUILDING_1 3\n#define ID_BUILDING_1_WIN_BOT 4\n#define ID_BUILDING_1_FLOOR 5\n#define ID_BUILDING_1_GROUND 6\n#define ID_BUILDING_1_PIPE 7\n\n#define ID_ARM_LEFT 8\n#define ID_HAND_LEFT 9\n#define ID_FINGER_LEFT 10\n\n#define ID_ARM_RIGHT 11\n#define ID_HAND_RIGHT 12\n#define ID_FINGER_RIGHT 13\n\n#define RIGHT_ARM_Q vec3(RADMIX(-20., 30., NO(sin(SPIDER_TIME*1.5))), RADMIX(-20.0, -30.0, NO(cos(SPIDER_TIME*0.5))), RADMIX(30.0, 60.0, NO(cos(SPIDER_TIME))))\n#define LEFT_ARM_Q vec3(RADMIX(-20., 30., NO(cos(SPIDER_TIME*1.3))), RADMIX(-20.0, -30.0, NO(sin(SPIDER_TIME*0.7))), RADMIX(-10.0, -30.0, NO(sin(SPIDER_TIME*1.1))))\n\n#define NOISE(P, SEED, LOD) (textureLod(iChannel3, ((P) + ((SEED)*1.98277215))/256., LOD).rgb)\n\nfloat rand(in vec2 p, in float seed) {\n    p += fract(seed*10.2381892);\n    vec3 p1 = vec3(fract(seed*33.6625281283), fract(p.yx*11.773332613));\n    vec3 p2 = vec3(fract(p.xy*10.89271842), fract(seed*10.99277733)) * 2.0 - 1.0;\n    vec3 p3 = fract(cross(p1, p2)*10.87827733);\n    return fract(10.33828*dot(vec3(p.xy, fract(length(p)+seed)), p3));\n    \n}\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, float freq, float warp, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += (n.xz+n.y)*warp;\n    }\n    return n / div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    };\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat building1SDF(in vec3 p, in float h, in float w, in int skip, inout int id) {\n    id = ID_BUILDING_1;\n    float dist = FAR;\n    const float sm = 0.03;\n    \n    vec3 size = vec3(ONE_METER*9.*w, ONE_METER*(16.+h), ONE_METER*9.*w);\n    float base = boxSDF(p - vec3(0, size.y, 0), size)-0.05;\n    float inside = boxSDF(p - vec3(0, size.y*0.91, 0), vec3(size.x*0.91, size.y+0.5, size.z*0.91));\n    base = max(base, -inside);\n    \n    vec3 entranceSize = vec3(ONE_METER, ONE_METER*2., ONE_METER);\n    float entrance = boxSDF(p - vec3(0, entranceSize.y, (-size.z)+(entranceSize.z/2.)), entranceSize)-sm;\n    base = max(base, -entrance);\n    \n    float ground = boxSDF(p - vec3(0, -0.02, 0), vec3(size.x*0.91, 0.1, size.z*0.91))-0.001;\n    SAMPLE_NOOB(ground, ID_BUILDING_1_GROUND);\n    \n    float botFloor = boxSDF(p - vec3(0, 2.5, 0), vec3(size.x*0.91, 0.1, size.z*0.91))-0.001;\n    SAMPLE_NOOB(botFloor, ID_BUILDING_1_FLOOR);\n    \n    float pipe = cylSDF(p - vec3((size.x/2.), size.y*2., -size.z/2.), vec3(0, 0, 0), vec3(0, 1, 0), 0.5);\n    SAMPLE_NOOB(pipe, ID_BUILDING_1_PIPE);\n    \n    p.y -= 0.9;\n    float py = p.y+0.9;\n    p.y = mod(p.y-1., 3.)+1.5;\n   \n    vec3 winSize = vec3(ONE_METER, ONE_METER*1.3, ONE_METER);\n    vec3 botSize = vec3(winSize.x, 0.06, 0.2);\n    // py <= (1.1+0.9\n    if ((py + 1.5 + (h/3.9)) < size.y*2. && py >= (1.1+0.9)) {\n        \n        \n        float win1= boxSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(size.x/2., winSize.y+(size.y/3.), (size.z-0.1)), winSize)-sm;\n        float win2 = boxSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(size.x-0.1, winSize.y+(size.y/3.), size.z/2.), winSize.zyx)-sm;\n        float win = min(win1, win2);\n        base = max(base, - win);\n        \n        \n        float winBot1 = boxSDF(\n            vec3(abs(p.x), p.y, abs(p.z)) -\n            vec3(size.x/2., ((size.y/3.))-botSize.y, (size.z)+(botSize.z)), botSize);\n            \n        float winBot2 = boxSDF(\n            vec3(abs(p.x), p.y, abs(p.z)) -\n            vec3((size.z)+(botSize.z), ((size.y/3.))-botSize.y, size.z/2.), botSize.zyx);\n            \n        float winBot = min(winBot1, winBot2)-0.01;\n            \n        SAMPLE_NOOB(winBot, ID_BUILDING_1_WIN_BOT);\n        \n        \n        float bfloor = boxSDF(p - vec3(0, 2.0, 0), vec3(size.x*0.91, 0.1, size.z*0.91))-0.001;\n        SAMPLE_NOOB(bfloor, ID_BUILDING_1_FLOOR);\n    \n    }\n    \n   // float winBot = \n    \n    SAMPLE_NOOB(base, ID_BUILDING_1);\n    \n    return dist-0.009;\n}\n\nfloat fingerSDF(in vec3 p, in vec3 dir, in float len, in float r, in vec3 bend) {\n    vec3 end = dir*(len*0.7);\n    float a = lineSDF(p, vec3(0, 0, 0), end, r);\n    \n    dir = normalize(dir + bend);\n    float b = lineSDF(p - end, vec3(0, 0, 0), dir*(len*0.3), r*0.9);\n    return smin(a, b, 0.01);\n}\n\nstruct Arm {\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    vec3 p;\n    vec3 q;\n};\n\nArm getArm(in Data data, in float sig) {\n    vec3 forward = data.q;\n    vec3 right = cross(vec3(0, 1, 0), forward);\n    if (length(right) <= 0.0001) right = vec3(1, 0, 0);\n    right = normalize(right);\n    vec3 up = cross(forward, right);\n    if (length(up) <= 0.00001) up = vec3(0, 1, 0);\n    up = normalize(up);\n    \n    vec3 pos = vec3(0.0);\n    pos -= data.ro + data.q;\n    pos -= (right*0.59) * sig;\n    pos += up*0.4;\n    pos += forward*0.4;\n    \n    return Arm(forward, right, up, pos, sig < 0.0 ? LEFT_ARM_Q : RIGHT_ARM_Q);\n}\n\nfloat armSDF(in Data data, in vec3 p, in int skip, inout int id, inout Object o, in bool isLeft) {\n\n    Object oo = o;\n    float dist = FAR;\n    id = isLeft ? ID_ARM_LEFT : ID_ARM_RIGHT;\n\n    float sig = (isLeft ? -1.0 : 1.0);\n    \n    Arm armData = getArm(data, sig);\n    vec3 offset = armData.p;\n    vec3 forward = armData.forward;\n    vec3 right = armData.right;\n    vec3 up = armData.up;\n    \n    p += offset;\n    o.p = offset;\n    oo.p = offset;\n    float k = dot(right, up);\n    p.xz *= rot(atan(forward.z, forward.x)-1.6);\n    p.yz *= rot(acos(forward.y));\n    p.xz *= rot(radians(180.));\n    p = pointRot(p, oo.q);\n\n    float len = 0.6;\n    float frontFlat = smoothstep(0.0, 1.0, max(0.0, abs(p.z)+0.01));\n    vec3 end = vec3(0, len, 0);\n    float armR = 0.05;\n    \n    armR /= (1.0 + smoothstep(0.4, 0.7, abs(p.y)));\n    armR += smoothstep(0.2, 3.0, max(0.0, (p.y-(len-0.5))));\n    armR += exp(cos(abs(p.y*30.))-1.)*0.01*smoothstep(0.0, 1.0, max(0.0, -p.y+0.9));\n    armR += smoothstep(0.2, 6.0, max(0.0, -p.y+1.))*0.9*(0.5+(0.5*sin((p.y+4.)*7.)));\n    \n    float arm = lineSDF(p, vec3(0, 0, 0), end, armR);\n    arm += frontFlat;\n    arm += smoothstep(0.5, 1.0, max(0.0, p.y+0.1))*0.05;\n    arm += smoothstep(0.9, 9., max(0.0, p.y+0.9));\n    arm /= 1.001;\n    \n    float palmR = 0.13;\n    palmR /= (1.0 + smoothstep(0.07, 0.2, abs(p.z)+0.1));\n    palmR /= (1.0 + smoothstep(0.2, 0.3, abs(p.x)+0.13));\n  \n    palmR += smoothstep(0.0, 0.5, max(0.0, 0.6-p.y))*smoothstep(0.0, 1.0, max(0.0, p.y-0.1)) *\n        (1.0-smoothstep(0.0, 0.12, abs(p.x)));\n        \n    palmR /= (1.0 + smoothstep(0.2, 0.5, max(0.0, p.x+0.1)));\n    palmR /= (1.0 + smoothstep(0.0, 0.4, max(0.0, 0.6-p.y)));\n \n    float palm = sphereSDF(p - end, palmR);\n    palm += smoothstep(-0.01, 0.6, abs(p.z));\n    palm += smoothstep(0.04, 0.8, abs(p.x));\n    palm += frontFlat*1.9;\n    palm += exp(cos(abs(p.y*60.))-1.)*0.02;\n    palm /= 1.0001;\n    palm = smin(palm, arm, 0.005);\n    \n    float fingerR = 0.7;\n    float fingerLen = 1.4;\n    \n    int fingerId = isLeft ? ID_FINGER_LEFT : ID_FINGER_RIGHT;\n    \n    float frame = 0.0;\n    \n    vec3 thumbDir = normalize(vec3(0.3*sig, 0.5, 0.0));\n    vec3 qThumb = vec3(0, RADMIX(0.0, 59.*sig, NO(cos((SPIDER_TIME+sig+frame)*2.))), 0);\n    Object oThumb = Object(offset, qThumb + oo.q);\n    thumbDir = pointRot(thumbDir, qThumb);\n    frame += 0.2;\n    \n    vec3 indexDir = vec3(0, 1, 0);\n    vec3 qIndex = vec3(RADMIX(0., 40., NO(sin((SPIDER_TIME+sig+frame)*2.))), 0, 0);\n    Object oIndex = Object(offset, qIndex + oo.q);\n    indexDir = pointRot(indexDir, qIndex);\n    frame += 0.2;\n    \n    vec3 middleDir = vec3(0, 1, 0);\n    vec3 qMiddle = vec3(RADMIX(0., 25., NO(sin((SPIDER_TIME+sig+frame)*4.))), 0, 0);\n    Object oMiddle = Object(offset, qMiddle + oo.q);\n    middleDir = pointRot(middleDir, qMiddle);\n    frame += 0.2;\n    \n    vec3 ringDir = vec3(0, 1, 0);\n    vec3 qRing = vec3(RADMIX(0., 35., NO(sin((SPIDER_TIME+sig+frame)*2.))), 0, 0);\n    Object oRing = Object(offset, qRing + oo.q);\n    ringDir = pointRot(ringDir, qRing);\n    frame += 0.2;\n    \n    vec3 pinkDir = normalize(vec3(-0.25*sig, 1, 0));\n    vec3 qPink = vec3(RADMIX(0., 45., NO(sin((SPIDER_TIME+sig+frame)*1.5))), 0, 0);\n    Object oPink = Object(offset, qPink + oo.q);\n    pinkDir = pointRot(pinkDir, qPink);\n    frame += 0.2;\n    \n    vec3 bendThumb = vec3(0.0);\n    vec3 bendIndex = vec3(0.0, -0.56, 0);\n    vec3 bendMiddle = vec3(0.0, -0.33, 0);\n    vec3 bendRing = vec3(0.0, -0.30, 0);\n    vec3 bendPink = vec3(0.0, -0.25, 0);\n    \n    float thumb = fingerSDF(p - (end + vec3(0.06*sig, -0.05, 0)),\n        thumbDir, 0.11 * fingerLen, 0.023 * fingerR, bendThumb);\n    SAMPLE(thumb, oThumb, fingerId);\n    \n    float index = fingerSDF(p - (end + vec3(0.05*sig, 0.03, 0)),\n        indexDir, 0.19 * fingerLen, 0.014 * fingerR, bendIndex);\n    SAMPLE(index, oIndex, fingerId);\n    \n    float middle = fingerSDF(p - (end + vec3(0.0, 0.06, 0)),\n        middleDir, 0.19 * fingerLen, 0.014 * fingerR, bendMiddle);\n    SAMPLE(middle, oMiddle, fingerId);\n    \n    float ring = fingerSDF(p - (end + vec3(-0.044*sig, 0.03, 0)),\n        ringDir, 0.19 * fingerLen, 0.014 * fingerR, bendRing);\n    SAMPLE(ring, oRing, fingerId);\n    \n    \n    float pink = fingerSDF(p - (end + vec3(-0.078*sig, 0.05, 0)),\n        pinkDir, 0.10 * fingerLen, 0.005 * fingerR, bendPink);\n    SAMPLE(pink, oPink, fingerId);\n    \n    SAMPLE(arm, oo, (isLeft ? ID_ARM_LEFT : ID_ARM_RIGHT));\n    SAMPLE(palm, oo, (isLeft ? ID_HAND_LEFT : ID_HAND_RIGHT));\n    \n    return dist/1.5;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    vec3 ro = data.ro;\n    vec3 rd = data.rd;\n    \n    float ground = groundSDF(p);\n    SAMPLE_NOOB(ground, ID_GROUND);\n    \n    if (data.screenUv.x > 0.0) { // optimization\n        int rightArmId = 0;\n        Object oRightArm = Object(vec3(0.0), RIGHT_ARM_Q);\n        float rightArm = armSDF(data, p, skip, rightArmId, oRightArm, false);\n\n        SAMPLE(rightArm, oRightArm, rightArmId);\n    }\n    \n    if (data.screenUv.x < 0.0) { // optimization\n        int leftArmId = 0;\n        Object oLeftArm = Object(vec3(0.0), LEFT_ARM_Q);\n        float leftArm = armSDF(data, p, skip, leftArmId, oLeftArm, true);\n\n        SAMPLE(leftArm, oLeftArm, leftArmId);\n    }\n    \n    vec3 buildingP = p;\n\n    \n    \n    // buildings\n    int building1Id = 0;\n    vec2 bid = floor((abs(buildingP.xz)/16.));\n    float ra = rand(bid*30.92812831, 9.38772199);\n    float ra2 = rand(bid*60.1182724, 44.0288213 + ra);\n    float ra3 = fract((ra+ra2)*190.9328298999);\n    buildingP.x = mod((buildingP.x), 16.)-8.;\n    buildingP.z = mod((buildingP.z), 16.)-8.;\n\n    float h = ceil(ra*2.0) + ceil(ra2*4.*ra);\n    h *= (floor(ra3*2.));\n    float w = 1.0;\n    w = mix(w, 0.8, ra2);\n    float building1 = building1SDF(buildingP, h, w, skip, building1Id)/1.4;\n    SAMPLE_NOOB(building1, building1Id);\n    float buildingW = ONE_METER*9.*w;\n\n    #if ENABLE_SPIDERWEB\n    // spiderweb\n    float lineLen = 1.0;\n    lineLen = mix(lineLen, 0.0, clamp(ro.y/16., 0.0, 1.0));\n    if (data.skip <= 0 && abs(p.x) < 8. && lineLen > 0.0001) {\n        Arm arm = getArm(data, 1.0);\n        vec3 dir = arm.forward;\n        vec3 lineOrigin = arm.p;\n        vec3 offset = dir;\n        offset = pointRot(offset, arm.q);\n\n        vec3 dirBuild = -normalize((buildingP*16.) - arm.p);\n        float invbuild = clamp(1.0 / building1, 0.0, 1.0);\n\n        float line = lineSDF(p - (-lineOrigin), vec3(0, 0, 0), \n            (((vec3((abs(buildingP.x*16.)), abs(buildingP.y), abs(buildingP.z*16.))*invbuild))*lineLen) - vec3(1, 0, 0), 0.04);\n\n        line /= 2.0;\n        SAMPLE_NOOB(line, 3292);\n    }\n    #endif\n    \n    \n    data.o = o;\n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    data.ro = ro;\n    data.rd = rd;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d*2.)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getShadow(in Data primData, in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= 0.000003) return 1.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    data.ro = ro;\n    data.rd = rd;\n    \n    float d = 0.0003;\n    float r = 1.0;\n    float avg = 0.0;\n    float c = 0.0;\n    \n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        avg += next;\n        c += 1.0;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    avg /= c;\n    \n    return clamp(avg+(r*0.5), AMBIENT, 1.0);\n}\n\n//#define DEBUG_TEXTURE plasterTexture\n\n//#define DEBUG_TEXTURE spidermanTexture\n\nvec3 spidermanTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 red1 = rgb(163, 33, 46);\n    vec3 red2 = rgb(174, 43, 44);\n    vec3 red3 = rgb(177, 18, 10);\n    vec3 red4 = rgb(124, 29, 18);\n    \n    vec3 blue1 = rgb(17, 32, 73);\n    vec3 blue2 = rgb(26, 61, 100);\n    vec3 blue3 = rgb(64, 108, 145);\n    vec3 blue4 = rgb(27, 78, 166);\n    \n    vec3 warp = snoiseWarp(uv, 0.0389281, 0.4, 16.0, 0.22, 6);\n    vec3 hf1 = snoise(uv, 2.2988724, 0.2, 100.0, 6);\n    vec3 hf2 = snoise(uv, 9.9767237, 0.2, 100.0, 6);\n    \n    vec3 red = mix(mix(mix(red1, red2, hf1.x), red3, hf1.y), red4, hf1.z);\n    vec3 blue = mix(mix(mix(blue1, blue2, hf2.x), blue3, hf2.y), blue4, hf2.z);\n    \n    float tile = 16.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lxs = smoothstep(0.89, 1.0, alv.x);\n    float lys = smoothstep(0.89, 1.0, alv.y);\n    float ls = lys+lxs;\n    \n    float lxb = smoothstep(0.5, 1.0, alv.x);\n    float lyb = smoothstep(0.5, 1.0, alv.y);\n    float lb = lxb+lyb;\n    \n    float line1 = 0.0;\n    float line2 = 0.0;\n    \n    {\n        float thick = 0.04;\n        vec2 lp = lv;\n        vec2 a = vec2(0.0, 0.0);\n        vec2 b = vec2(1.0, 1.0);\n\n        float mm = mod(id.x-id.y, 2.0);\n\n        a = mix(a, vec2(1.0, 0.0), mm);\n        b = mix(b, vec2(0.0, 1.0), mm);\n\n        vec2 pa = lp - a;\n        vec2 ba = b - a;\n        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        line1 = max(0.0, 1.0 - length(pa - ba * h) / thick);\n    }\n\n    {\n        float thick = 0.5;\n        vec2 lp = lv;\n        vec2 a = vec2(0.0, 0.0);\n        vec2 b = vec2(1.0, 1.0);\n\n        float mm = mod(id.x-id.y, 2.0);\n\n        a = mix(a, vec2(1.0, 0.0), mm);\n        b = mix(b, vec2(0.0, 1.0), mm);\n        \n        lp += 0.05;\n        a -= 0.05;\n        b -= 0.05;\n\n        vec2 pa = lp - a;\n        vec2 ba = b - a;\n        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        line2 = max(0.0, 1.0 - length(pa - ba * h) / thick);\n    }\n    \n    col += red;\n    col = mix(col, blue, smoothstep(0.4, 0.49, max(0.0, -p.y+0.66)));\n    \n    col += line1;\n    col = mix(col, col*col, line2);\n    \n    m.spec = clamp(pow(line1 + (line2*0.2*line2), 4.0), 0.0, 1.0);\n    \n    m.z = clamp((line1+line2)/2., 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 plasterTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    float w = wnoise(uv*2., 4, 1.0);\n    vec3 warp = snoiseWarp(uv, 0.081231, 0.3, 16.0, 0.19, 6);\n    vec3 hf1 = snoise(uv, 2.988712, 0.2, 64.0, 6);\n    vec3 lf1 = snoise(uv, 9.827124, 0.2, 8.0, 6);\n    vec3 grain1 = textureLod(iChannel3, uv, 0.0).rgb;\n    vec3 grain2 = abs(normalize(reflect(cross(grain1*2.0-1.0, hf1*2.0-1.0), warp*2.0-1.0)));\n       \n    vec3 c1 = rgb(174, 172, 168);\n    vec3 c2 = rgb(160, 153, 140);\n    vec3 c3 = rgb(76, 66, 55);\n    vec3 c4 = rgb(111, 105, 96);\n    vec3 c5 = rgb(182, 180, 176);\n    \n    float brush = smoothstep(0.7, 0.0, w)*warp.z;\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    vec3 col2 = mix(mix(mix(c1, c2, warp.x), c3, warp.y), c4, warp.z);\n    vec3 col3 = mix(col1, c5, brush);\n    \n    col = mix(col1, col2, smoothstep(0.4, 0.9, lf1.x));\n    col = mix(col, col3, smoothstep(0.2, 0.9, lf1.y));\n    \n    col = mix(col, c5, clamp(grain2.x*grain2.y*grain2.z*3., 0.0, 1.0)*lf1.z);\n    \n    m.spec = clamp((1.0-(brush*2.))*hf1.x*lf1.z, 0.0, 1.0);\n    m.z = clamp(lf1.x*warp.x*(0.5+(0.5*brush)), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    \n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = mod(length(vec2(alv.x/2., alv.y)), 0.4*cos(alv.y*(TAU-(alv.x/2.+hf2.y)))*hf2.z);\n    lines = max(0.002, 1.0-max(0.0, 0.5-lines));\n    \n    col = mix(col, col*col*col, lines);\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x*tile)*10.*lf1.y, sin((uv.y*tile)*TAU)*2.));\n    col = mix(col, mix(c1, c5, hf1.z), w2*0.6);\n    \n    float t2 = fract(uv.y*tile*2.);\n    float gs = smoothstep(0.5-0.25, 0.5+0.25, abs(t2*2.0-1.0)-0.5);\n    col = mix(col, col*col, gs);\n    \n    m.z = clamp((w2*lf1.x)*max(0.0, 0.5-gs), 0.0, 1.0);\n    m.spec = clamp(w2*lf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 rockTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 hh = snoise(uv, 203.231, 0.01, 16.0, 4);\n    float h = hh.x;\n    grain = (grain+h)/2.;\n    vec3 lf1 = snoiseWarp(uv, 0.032123, 0.5, 4.5, 1.5, 4);\n    vec3 lf2 = snoise(uv, 1.1112312, 0.01, 16.0, 4);\n    \n    vec3 c1 = rgb(106, 104, 105);\n    vec3 c2 = rgb(120, 114, 109);\n    vec3 c3 = rgb(133, 113, 92);\n    vec3 c4 = rgb(83, 81, 75);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    col1 = mix(col1, vec3(1.), lf1.x*lf1.x*h*grain.x);\n    col += col1;\n    \n    float edge = abs(lf2.x*2.0-1.0);\n    edge = max(0.0, 1.0-smoothstep(0.02, 0.09, edge));\n    \n    float scratchReg = edge*lf1.y*h*grain.y;\n    col = mix(col, col*col, scratchReg);\n    \n    m.spec = clamp((1.0-scratchReg)*grain.x, 0.0, 1.0);\n    \n    m.z = clamp(lf1.x+scratchReg, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 metalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 0.0328125, 0.9, 16.0, 0.25, 6);\n    vec3 hf2 = snoise(uv, 2.3456767, 0.9, 64.0, 2);\n    vec3 hf3 = clamp(abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0))), 0.0, 1.0);\n    vec3 lf1 = snoiseWarp(uv, 5.55939123, 0.9, 8.0, 0.25, 6);\n    vec3 lf2 = snoise(uv, 10.02931925, 0.0, 2.5, 4);\n  \n    vec3 grain = textureLod(iChannel3, uv*0.5, 0.0).xyz;\n    vec3 hf4 = clamp(abs(normalize(cross(reflect((hf3)*2.0-1.0, grain*2.0-1.0), hf1*2.0-1.0))), 0.0, 1.0);\n    \n    vec3 m1 = rgb(134, 145, 151);\n    vec3 m2 = rgb(89, 91, 97);\n    vec3 m3 = rgb(175, 175, 175);\n    vec3 m4 = rgb(203, 203, 203);\n    vec3 m5 = rgb(92, 92, 92);\n    \n    vec3 col1 = mix(mix(mix(m1, m2, hf1.x), m3, hf1.y), m4, hf1.z);\n    \n    col += col1;\n    \n    vec3 d1 = rgb(103, 80, 71);\n    vec3 d2 = rgb(118, 92, 57);\n    vec3 d3 = rgb(71, 55, 40);\n    vec3 d4 = rgb(181, 106, 50);\n    \n    vec3 d5 = rgb(52, 51, 56);\n    vec3 d6 = rgb(69, 64, 56);\n    vec3 d7 = rgb(109, 94, 88);\n    vec3 d8 = rgb(82, 78, 80);\n    \n    vec3 dirtCol1 = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    vec3 dirtCol2 = mix(mix(mix(d5, d6, hf3.x), d7, hf3.y), d8, hf3.z);\n    \n    vec3 dirtCol = mix(dirtCol1, dirtCol2, smoothstep(0.34, 0.5, lf1.x));\n    \n    float dirtReg = clamp(pow(lf2.x, 3.)*6., 0.0, 1.0);\n    col = mix(col, dirtCol, 0.5);\n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, hf4.z*lf2.y*grain.x*grain.y);\n    \n    m.spec = clamp(lf1.x*max(0.0, 1.0-(dirtReg*hf3.y)), 0.0, 1.0);\n    m.z = clamp(luma(col)+(dirtReg-0.56), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 asphaltTexture(in vec2 uv, in vec3 p, inout Material m, in vec3 pos) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(27, 30, 41);\n    vec3 c2 = rgb(61, 59, 57);\n    vec3 c3 = rgb(81, 84, 82);\n    vec3 c4 = rgb(46, 50, 55);\n    \n    vec3 y1 = rgb(191, 165, 79);\n    vec3 y2 = rgb(168, 145, 81);\n    vec3 y3 = rgb(221, 191, 87);\n    \n    vec3 grain = snoise(uv, 3.9872712, 0.3, 100., 6);\n    vec3 hf = snoise(uv, 1.0019231, 0.3, 32.0, 6);\n    \n    vec3 asphalt = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    vec3 yellow = mix(mix(y1, y2, hf.x), y3, hf.y);\n    \n    col += asphalt;\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.03, 0.19, abs(hf.x-hf.y)));\n    \n    cracks *= 0.8;\n    col = mix(col, ((0.5*c3)+(0.5*grain.x)), 0.5*cracks*cracks*(0.2+(0.5*grain.y)));\n    \n    p = p - pos;  \n\n    float rad = (0.5 + (cracks*0.1))*0.36;\n    float fe = (rad*(0.2));\n    float x = p.x;\n    float line1 = smoothstep(rad-(fe*2.), rad+(fe*2.), (-p.x)) *\n        smoothstep(rad+(fe*2.), rad-(fe*2.), (-p.x));\n    float line2 = smoothstep(rad-(fe*2.), rad+(fe*2.), max(0.0, p.x-rad/2.)) *\n        smoothstep(rad+(fe*2.), rad-(fe*2.), max(0.0, p.x-rad/2.));\n    float line = max(line1, line2);\n    col = mix(col, yellow*2., line);\n    \n    float specF = clamp((1.0-smoothstep(3.9, 4.6, abs(p.x)))*2., 0.0, 1.0);\n\n    m.spec = (((pow(hf.x, 2.0) * max(0.0, 1.0 - cracks) * max(0.0, 1.0 - (line*2.)))*0.5 *\n        specF));\n        \n    \n    m.z = clamp(0.5+0.5*((cracks*0.12)+luma(col)), 0.0, 1.0);\n\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 pos = vec3(0.0);\n    vec3 col = asphaltTexture(uv, p, data.m, pos);\n    float depth = data.d / FAR;\n    float s = smoothstep(1.0, 0.0, depth);\n    data.n = makeNormal(n, data.m.z, 0.09, 0.5);\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    vec3 col = snoise(uv, 0.39215, 0.4, 3.0, 6);\n    return col;\n}\n\nvec3 getAlbedoBuilding(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = plasterTexture(uv, p, data.m);\n    data.n = makeNormal(n, data.m.z, 0.032, 0.9);\n    return col;\n}\n\nvec3 getAlbedoBuildingPipe(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv+4.0928213;\n    vec3 col = metalTexture(uv, p, data.m);\n    data.n = makeNormal(n, data.m.z, 0.15, 0.9);\n    return col;\n}\n\nvec3 getAlbedoBuildingFloor(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = plankTexture(uv, p, data.m);\n    data.n = makeNormal(n, data.m.z, 0.33, 0.1);\n    return col;\n}\n\nvec3 getAlbedoWindowBot(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = rockTexture(uv, p, data.m);\n    data.n = makeNormal(n, data.m.z, 0.1, 0.5);\n    return col;\n}\n\nvec3 getAlbedoArm(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    // this block of code just brings the point and the normal\n    // into the translated & rotated space\n    vec3 forward = data.q;\n    vec3 right = cross(vec3(0, 1, 0), forward);\n    if (length(right) <= 0.0001) right = vec3(1, 0, 0);\n    right = normalize(right);\n    vec3 up = cross(forward, right);\n    if (length(up) <= 0.00001) up = vec3(0, 1, 0);\n    up = normalize(up);\n    p += data.o.p;\n    float k = dot(right, up);\n    p.xz *= rot(atan(forward.z, forward.x)-1.6);\n    p.yz *= rot(acos(forward.y));\n    p.xz *= rot(radians(180.));\n    vec3 nr = n;\n    p = pointRot(p, data.o.q);\n    nr = pointRot(data.n, data.o.q);\n    //////////////////////////////////////////////////////////////\n    \n    vec2 uv = boxUv(p, nr)*2.5;\n    uv = p.xy*2.5;\n    vec3 col = spidermanTexture(uv, p, data.m);\n    data.n.x += data.m.z*0.2;\n    data.n.y += data.m.z*0.2;\n    data.n.z += data.m.z*0.7;\n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_BUILDING_1: return getAlbedoBuilding(data); break;\n        case ID_BUILDING_1_PIPE: return getAlbedoBuildingPipe(data); break;\n        case ID_BUILDING_1_WIN_BOT: return getAlbedoWindowBot(data); break;\n        case ID_BUILDING_1_FLOOR: return getAlbedoBuildingFloor(data); break;\n        \n        case ID_ARM_RIGHT: return getAlbedoArm(data); break;\n        case ID_HAND_RIGHT: return getAlbedoArm(data); break;\n        case ID_FINGER_RIGHT: return getAlbedoArm(data); break;\n        case ID_ARM_LEFT: return getAlbedoArm(data); break;\n        case ID_HAND_LEFT: return getAlbedoArm(data); break;\n        case ID_FINGER_LEFT: return getAlbedoArm(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getClouds(in vec3 rd) {\n    if (rd.y < -0.00001) return vec3(0.);\n    vec2 uv = rd.xz / rd.y;\n    float time = T*0.1;\n    vec2 shift = vec2(cos(time), sin(time));\n    vec3 lf1 = snoise(uv + shift, 0.028811, 0.2, 2.0, 6);\n    vec3 lf2 = snoise(uv - shift, 1.987766, 0.1, 3.0, 6);\n    vec3 hf1 = snoise(uv + shift, 3.333398, 0.0, 10.0, 6);\n    vec3 hf2 = snoise(uv - shift, 7.776261, 0.1, 24.0, 6);\n    vec3 mixer1 = snoise(uv + shift, 23.987271, 0.3, 2.5, 4);\n    vec3 mixer2 = snoise(uv - shift, 34.676622, 0.3, 2.5, 4);\n    vec3 mixer3 = snoise(uv + shift, 73.777324, 0.3, 2.5, 4);\n    float low1 = mix(mix(lf1.x, lf1.y, mixer1.x), lf1.z, mixer1.y);\n    float low2 = mix(mix(lf2.x, lf2.y, mixer2.x), lf2.z, mixer2.y);\n    float high1 = mix(mix(hf1.x, hf1.y, mixer1.x), hf1.z, mixer1.y);\n    float high2 = mix(mix(hf2.x, hf2.y, mixer2.x), hf2.z, mixer2.y);\n    float low = mix(low1, low2, mixer1.z);\n    float high = mix(high1, high2, mixer2.z);\n    float clouds = mix(low, high, mixer3.x);\n    clouds = pow(clouds, 2.0);\n    return vec3(clouds);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0)); \n    vec3 col = pow(vec3(0.29, 0.59, 0.9), vec3(1.0 + dotup));\n    float cloudFactor = smoothstep(0.0, 0.09, dotup);\n    if (cloudFactor > 0.00000001) {\n        vec3 clouds = getClouds(rd);\n        col += clouds * cloudFactor;\n    }\n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(data, p + (n*NEAR*2.), L, data.n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 lightEffect(in Data data, in Light light, in vec3 ro, in vec3 rd, in float depth) {\n    vec3 col = vec3(0.0);\n    vec3 L = getLightDir(light, ro);\n    float VdotR = cdot(rd, L);\n    col += light.c * light.s * pow(VdotR, 32.0) * smoothstep(0.0, 1.0, depth);\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(1.0, 0.9569, 0.8392), 2.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        vec3 p = data.p;\n        vec3 n = data.n;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(data, light, ro, rd, diffuse);\n        col += lightEffect(data, light, ro, rd, data.d/FAR);\n    } else {\n        col += getSky(rd);\n        col += lightEffect(data, light, ro, rd, data.d/FAR);\n    }\n    \n    depth = data.d / FAR;\n    \n    col += smoothstep(0.15, 1.0, depth) * max(0.0, 1.0 - smoothstep(-0.09, 0.15, dotup)) * light.c;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd, inout Data data) {\n    ro = vec3(0, 0, -20.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if DEBUG\n    ro =  DEBUG_POS;\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    ro.yz *= rot(m.y*TAU);\n    ro.xz *= rot(m.x*TAU);\n    ro.y += 0.5;\n    return;\n    #endif\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    ro += walk;\n    ro.y += fly.y;\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    \n    float pitch  = m.y*TAU;\n    float yaw = m.x*TAU;\n    vec3 camdir = normalize(vec3(\n        sin(yaw),\n        tan(pitch),\n        cos(yaw)\n    ));\n    data.q = camdir;\n    data.r = vec3(pitch, yaw, yaw);\n    #else\n    \n   if (length(m.xy) > 0.0001 && m.z > 0.001 && iFrame > 1 && iTime > 0.0003) {\n        float pitch = clamp(m.y*TAU, -1.4, 1.4);\n        float yaw = m.x*TAU;\n        vec3 camdir = normalize(vec3(\n            sin(yaw),\n            tan(pitch),\n            cos(yaw)\n        ));\n        data.q = camdir;\n        data.r = vec3(pitch, yaw, yaw);\n        rd.yz *= rot(pitch);\n        rd.xz *= rot(yaw);\n    } else {\n        float yaw = sin(T*0.5)*0.5;\n        float pitch = RADMIX(-10., 10., NO(cos(T*2.)));\n        rd.yz *= rot(pitch);\n        rd.xz *= rot(yaw);\n\n        vec3 camdir = normalize(vec3(\n            sin(yaw),\n            tan(pitch),\n            cos(yaw)\n        ));\n        data.q = camdir;\n        data.r = vec3(pitch, yaw, yaw);\n        rd.xy *= rot(RADMIX(-5., 5., NO(sin(T))));\n    }\n    \n    ro.y += 8.;\n    ro.y += (cos(T)*7.) + (9.0*(0.5+(0.5*sin(T*0.5))));\n    ro.z += T*5.;\n\n    #endif\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    \n    Data data = NEW_DATA;\n    data.screenUv = uv;\n    getRay(uv, m, ro, rd, data);\n    \n    data.ro = ro;\n    data.rd = rd;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col += (col*col*luma(col));\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif \n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}