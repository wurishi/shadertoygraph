{"ver":"0.1","info":{"id":"4dtfDj","date":"1526785623","viewed":210,"name":"Accelerated raymarching concept2","username":"rory618","description":"Typically we only sample the sdf at points along the ray, but nearby points may provide more information. If the circle/sphere of empty space intersects the ray, you may march forward. Is the extra computation worth it? Is there a better way to get grad?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Accelerated raymarching concept\" by rory618. https://shadertoy.com/view/MdcfWj\n// 2018-05-20 02:18:59\n\nvoid lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P \n\n    \n    fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-length( z - b),0.,1.));\n}\n\nvoid circle(inout vec4 fragColor, vec2 z, vec2 a, float r, vec4 c,  float w){\n    \n    fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-abs(length(z-a)-r),0.,1.));\n}\n\nfloat map(vec2 z){\n    //Edges of the screen and center circle\n    return min((length(z-iResolution.xy/2.)-100.),min(min(z.x,z.y),min(iResolution.x-z.x,iResolution.y-z.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int it = 10;\n    \n    fragColor = vec4(1);\n    float l = 0.;\n    vec2 z = iMouse.zw;\n    vec2 d = normalize(iMouse.xy-iMouse.zw);\n    if(iMouse.z<=0.){\n        z = (.5+.5*sin(iTime*vec2(.031,.042)))*iResolution.xy;\n        d = normalize(sin(iTime*vec2(.064,.077)));\n    }\n    //Do normal raymarching in green\n    for(int i = 0; i < it; i++){\n        float d0 = map(z+l*d);\n     \tcircle(fragColor,fragCoord,z+l*d,d0,vec4(0,1,0,1),1.);\n        l += d0;\n            \n        lineSegment(fragColor,fragCoord,z,z+d*l,vec4(0,1,0,1),1.);\n    }\n     l = 0.;\n    //y is a running value of how far away from the ray we should sample the sdf. Farther from the ray is good if it is also farther \n    //from the surface, because if there is nothing nearby then you will get a bigger circle that intersects more of the ray than \n    //the smaller circle from sampling the sdf right on the ray.\n    \n    \n    float y = map(z);\n    //Accelerated raymarching in red\n    for(int i = 0; i < it; i++){\n        float d0 = map(z+l*d);\n        //Estimate gradient of sdf numerically\n        float d1 = map(z+l*d+vec2(2e-3,0));\n        float d2 = map(z+l*d+vec2(0,2e-3));\n        \n        vec2 grad = normalize(vec2(d1-d0,d2-d0));\n       \tfloat cs = dot(grad,d);\n        float h = y*sqrt(1.-cs*cs);\n        //pick a spot some distance in the direction of the gradient\n        vec2 c = z+l*d+y*grad;\n        float p = map(c);\n        if(p>h){\n            float a = y*cs+sqrt(p*p-h*h);\n            if(d0<a){\n                //If successful skip, then go even bigger next time\n                y*=2.;\n                l += a;\n     \t\t\tcircle(fragColor,fragCoord,c,p,vec4(1,0,0,.4),2.);\n                \n            } else {\n        \t\tcircle(fragColor,fragCoord,z+l*d,d0,vec4(1,0,0,.4),2.);\n                l += d0;\n            }\n        } else {\n            //Reduce y when failiure happens, but not too much\n        \ty = max(.1,.5*y+.5*min(d0,y));\n        \tcircle(fragColor,fragCoord,z+l*d,d0,vec4(1,0,0,.4),2.);\n            l += d0;\n        }\n        y = max(.1,.5*y+.5*min(p,y));\n        lineSegment(fragColor,fragCoord,z,z+d*l,vec4(1,0,0,.4),2.);\n    }\n    circle(fragColor,fragCoord,iResolution.xy/2.,100.,vec4(1,0,1,.9),2.);\n}","name":"Image","description":"","type":"image"}]}