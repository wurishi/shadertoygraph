{"ver":"0.1","info":{"id":"3dKfDh","date":"1615820956","viewed":77,"name":"Raymarched Astronaut","username":"qw","description":"just chilling in space","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","astronaut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n \n\nfloat opRound( float inShape, float rad )\n{\n    return inShape - rad;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec3 opRotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 opRotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 opRotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\nfloat opBlend(float d1, float d2, float t)\n{\n    float k = 5.0 * t;\n    float d = sminCubic(d1, d2, k);\n    return d;\n}\n\nfloat opUnion(float a, float b)\n{\n    if( a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nvec2 opUnionMat(float a, float b, float matA, float matB )\n{\n    if( a < b)\n    {\n        return vec2(a,matA);\n    }\n    return vec2(b,matB);\n}\n\n\nfloat opCut(float a, float b)\n{\n    return max(-a,b);\n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 position, vec3 capAPos, vec3 capBPos, float radius)\n{\n    vec3 ab = capBPos-capAPos;\n    vec3 ap = position - capAPos;\n    \n    // projecting ab on ap and normalizing by length of a<->b, ie: dot product ab.ab\n    float t = dot(ab, ap) / dot(ab,ab);\n\t//clamp value to stay between a & b\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 closestPoint = capAPos + ab * t;\n    float distance = length(position - closestPoint) - radius;\n    return distance;\n}\n\nfloat sdTorus( vec3 position, vec3 torusOrigin, float torusRadius, float width )\n{\n    vec3 posToTorus = torusOrigin - position;\n    float x = length( posToTorus.xz) - torusRadius;\n    float y = posToTorus.y;\n    return length(vec2(x,y)) - width;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat sdBox(vec3 position, vec3 origin, vec3 size)\n{\n    vec3 boxPos = position - origin;\n    return length( max(abs( boxPos ) - size, 0.0) );\n}\n               \n\nfloat sdCylinder(vec3 position, vec3 capAPos, vec3 capBPos, float radius)\n{\n    vec3 ab = capBPos-capAPos;\n    vec3 ap = position - capAPos;\n    \n    // projecting ab on ap and normalizing by length of a<->b, ie: dot product ab.ab\n    float t = dot(ab, ap) / dot(ab,ab);\n\t//clamp value to stay between a & b\n    //t = clamp(t, 0.0, 1.0);\n    \n    vec3 closestPoint = capAPos + ab * t;\n    \n    float x = length(position - closestPoint) - radius;\n    float y = (abs(t- 0.5) - 0.5) * length(ab);\n    float exteriorDist = length( max( vec2(x,y), 0.0) );\n    \n    //fix for inaccuracy distance estimation\n    float interriorDist = min( max(x,y),0.0);\n    float distance = exteriorDist + interriorDist; \n    \n    return distance;\n}\n\nfloat GetDistanceToScene(vec3 position, out float matID)\n{\n\t//Helmet\n    //Sphere (pos.xyz, radius)\n    vec3 modelPos =  vec3(-1.0,2.0, -0.0);\n    vec3 helmetPos = modelPos+vec3(0.0,0.0, 0.0);\n    \n    //position = opRotateY(position,sin(iTime)*3.14);\n    \n    vec4 helmetOuterSphere = vec4(helmetPos, 1.0);\n    vec4 helmetLowerOuterSphere = vec4(helmetPos+vec3(0,0,-0.0), 1.04);\n    vec4 helmetUpperOuterSphere = vec4(helmetPos+vec3(0,0,-0.0), 1.04);\n    vec4 helmetInnerSphere = vec4(helmetPos+vec3(0,0.1,-.3), 0.8);\n    float helmetOuterSphereDistance = length( helmetOuterSphere.xyz - position) - helmetOuterSphere.w; \n    float helmetLowerOuterSphereDistance = length( helmetLowerOuterSphere.xyz - position) - helmetLowerOuterSphere.w; \n    float helmetUpperOuterSphereDistance = length( helmetUpperOuterSphere.xyz - position) - helmetUpperOuterSphere.w; \n    float helmetInnerSphereDistance = length( helmetInnerSphere.xyz - position) - helmetInnerSphere.w; \n    \n    \n    //Base\n    //float torusDistance = sdTorus(position, helmetPos+vec3(0,-0.6,0), 1.0, 0.2);\n    vec3 helmetBasePos = helmetPos - position + vec3(0,-0.9,0);\n    float helmetBaseDist = sdCappedCylinder(helmetBasePos, 0.8 ,0.15);\n    float helmetBaseCutoutOuterDist = sdCappedCylinder(helmetBasePos, 0.85 , 0.05);\n    float helmetBaseCutoutInnerDist = sdCappedCylinder(helmetBasePos, 0.75 , 1.0);\n    \n    vec3 helmetTopNudgePos = helmetBasePos+vec3(0,0.4,0);\n    helmetTopNudgePos = opRotateZ(opRotateX(opRotateY(helmetTopNudgePos, 3.14*0.5 ), 3.14 ), 3.14*0.35);\n    //float helmetTopNudgeDist = sdCappedCylinder( helmetTopNudgePos, 0.2 , 0.5);\n    float helmetTopNudgeDist = sdCappedTorus(helmetTopNudgePos, vec2(1.0, 0.01), 1.5, 0.2);\n\n    //Side nobs\n    vec3 helmetSideNobPos = helmetBasePos+vec3(0,0.9,-0.3);\n\tfloat helmetSideNobDist = sdCappedCylinder( opRotateZ(helmetSideNobPos,3.14*0.5), 0.15 , 1.1);\n    \n    \n    \n    //Plane (plane is flat at height 0, which means it's at \"y\" distance from camera\n    float planeDistance = position.y;\n    /*\n    float capsuleDistance = sdCapsule(position, vec3(-3.0,2,2), vec3(-2.0,1,2), 0.20);\n    float torusDistance = sdTorus(position, vec3(0,1.2,4), 2.0, 0.2);\n    vec3 repeatedPos = position;\n    float boxDistance = sdBox(position, vec3(0.0, 1, 4.0), vec3(0.9) );\n    float cylinderDistance = sdCylinder(position, vec3(-4.0,0.4,2.5), vec3(-1.0,0.4,1.5), 0.30);\n    \n    //Box 2\n    float box2IntersectionPlane = dot(position + vec3(0,0, 1.5*( sin(iTime) *0.5)+0.5 ), normalize(vec3(-1,1,-1)) )+1.1; \n    float box2Distance = sdBox(position, vec3(3.0, 0.6, 0.5), vec3(0.5) );\n    box2Distance = max( box2IntersectionPlane, box2Distance);\n    box2Distance = abs(box2Distance) - 0.3;\n    */\n    \n    // find closest object('s distance)\n\t//Main helmet sphere shape\n    \n    //Lower helmet\n    float helmetLowerOuterIntersectionPlane = dot(position + vec3(0,3.5, 5.8 ), normalize(vec3(0,1,-1)) ); \n    helmetLowerOuterSphereDistance = opIntersection(helmetLowerOuterIntersectionPlane, helmetLowerOuterSphereDistance );\n    float helmetDistance = helmetLowerOuterSphereDistance;\n    \n\t//Upper helmet\n    float helmetUpperOuterIntersectionPlane = dot(position + vec3(0,-0.7, -1.1), normalize(vec3(0,-1,-1)) ); \n    helmetUpperOuterSphereDistance = opIntersection(helmetUpperOuterIntersectionPlane, helmetUpperOuterSphereDistance );\n   \thelmetDistance = opUnion(helmetUpperOuterSphereDistance, helmetDistance);\n    \n    //Top Nudge\n    helmetTopNudgeDist = opIntersection(-1.0*helmetLowerOuterIntersectionPlane,helmetTopNudgeDist);\n    helmetDistance = opUnion(helmetTopNudgeDist,helmetDistance);\n    \n    //Side nobs\n    helmetDistance = opUnion(helmetSideNobDist,helmetDistance);\n    \n    \n    //cut out inside\n    helmetDistance = opCut(helmetOuterSphereDistance, helmetDistance);\n    \n    \n    //helmet Base (with cut)\n    helmetBaseCutoutOuterDist = opCut(helmetBaseCutoutInnerDist , helmetBaseCutoutOuterDist);\n    helmetDistance = opUnion(helmetBaseDist, helmetDistance);\n    helmetDistance = opCut(helmetBaseCutoutOuterDist, helmetDistance);\n    \n    \n    //Face \n    vec3 facePos = modelPos - (position-vec3(0.0,1.495,1.55));\n    //3 Eyes\n    float eyesDistance = length(facePos-vec3(0.0,1.2,1.9))-.25;\n    eyesDistance = opUnion( length(facePos-vec3(0.5,1.3,1.9))-.25, eyesDistance);\n    eyesDistance = opUnion( length(facePos-vec3(-0.5,1.3,1.9))-.25, eyesDistance);\n    //pupils\n    float eyePupilDistance = length(facePos-vec3(0.0,1.16,2.09))-.08;\n    eyePupilDistance = opUnion( length(facePos-vec3(0.5,1.3,2.1))-.08, eyePupilDistance);\n    eyePupilDistance = opUnion( length(facePos-vec3(-0.5,1.3,2.1))-.08, eyePupilDistance);\n    \n    \n    //Head\n    float faceDistanceR =  length(facePos-vec3(0.2,1.7,1.5))-0.75;\n    float faceDistanceL =  length(facePos-vec3(-0.2,1.7,1.5))-0.75;\n    \n    float faceDistance = sminCubic(faceDistanceR, faceDistanceL, 0.1);\n    faceDistance = opUnion(eyesDistance, faceDistance);\n    faceDistance = opUnion(eyePupilDistance, faceDistance);\n    \n    \n    //Mouth\n    vec3 mouthPos = opRotateX( facePos-vec3(0.0,1.54,2.18), 3.14) ;\n    mouthPos.x = abs(mouthPos.x) - 0.2;\n    mouthPos = opRotateZ(mouthPos,3.14*0.95);\n    float mouthDist = sdCappedTorus(mouthPos, vec2(1.0, 0.01), 0.2, 0.1);\n\tfaceDistance = opUnion(mouthDist, faceDistance);\n    \n    \n    \n    vec2 distanceData = opUnionMat(helmetDistance, planeDistance, 1.0, 0.0);\n    //float distance = opUnion(faceDistance, planeDistance);\n    distanceData = opUnionMat(faceDistance, distanceData.x, 2.0, distanceData.y );\n    float distance = distanceData.x;\n    matID = distanceData.y;\n    \n    return distance;\n}\n\n\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir, out float matID )\n{\n    //Vec2 (X = distanceToScene, Y = object ID - used for differentiation like different textures)\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + rayDir*distanceFromOrigin;\n        float distanceToScene = GetDistanceToScene(pos, matID);\n        distanceFromOrigin += distanceToScene;\n        if(distanceFromOrigin > MAX_DISTANCE || distanceToScene < SURFACE_DISTANCE)\n        {\n        \tbreak;\n        }    \n        \n    }\n    \n    \n    return distanceFromOrigin;\n}\n\n\nvec3 GetNormal(vec3 scenePos)\n{\n    float matID;\n    float distance = GetDistanceToScene(scenePos, matID);\n    \n    //We use derivatives to calculate normal of a position\n    vec2 smallDiff = vec2(0.01, 0);\n    \n    vec3 normal = distance - vec3(\n        GetDistanceToScene(scenePos - smallDiff.xyy, matID),\n        GetDistanceToScene(scenePos - smallDiff.yxy, matID),\n        GetDistanceToScene(scenePos - smallDiff.yyx, matID)\n        );\n\n\treturn normalize(normal);\n    \n}\n\nfloat GetLight( vec3 scenePos , vec3 normal)\n{\n    //Light position in world\n    vec3 lightPos = vec3(0, 4.0, -3);\n    //make light move in circle\n    //lightPos.xz += vec2(cos(iTime), -sin(iTime) ) * 2.0;\n    lightPos.y += sin(iTime) * 1.5;\n    \n    \n    vec3 lightDir = normalize( lightPos-scenePos);\n\n    float diffuse = dot(normal, lightDir);\n    //Clamp diffuse\n    diffuse = clamp(diffuse,0.0,1.0);\n    \n    //Shadow ((normal*SURFACE_DISTANCE*2.0) -> offset shading point a little bit away of surface to not intersect with it again,\n    //*2 is to avoid artefacts\n    float matID;\n    float distanceToLightRayMarch = RayMarch(scenePos + (normal*SURFACE_DISTANCE*2.0), lightDir, matID);\n    if( distanceToLightRayMarch < length( scenePos - lightPos) )\n    {\n        //something is in between the point in the world and the light, ie: we're in shadow\n        diffuse *= 0.1;\n    }\n    \n    return diffuse;\n}\n\n\nvec3 GetAlbedo( vec3 scenePos, vec3 normal, float matID)\n{\n    // apply tri-planar mapping\n    mat3 triMapSamples; \n    vec3 color;\n\t//first we calculate planar mapping for each 3 directions\n    //Support multiple textures based on objectID\t\n    if( matID == 0.0){\n        \n    \ttriMapSamples = mat3(\n                texture(iChannel0, scenePos.yz).rgb,\n                texture(iChannel0, scenePos.xz).rgb,\n                texture(iChannel0, scenePos.xy).rgb\n        \t);\n        color = triMapSamples * abs(normal);\n    }else if(matID == 1.0){\n    \ttriMapSamples = mat3(\n                texture(iChannel1, scenePos.yz).rgb,\n                texture(iChannel1, scenePos.xz).rgb,\n                texture(iChannel1, scenePos.xy).rgb\n        \t);\n        color = triMapSamples * abs(normal);\n        \n    }else{\n    \tcolor = vec3(0.898,0.941,0.394);\n    }\n    \n    //Then we \"weigh\" this 3x3 matrix by the normal, this is our result\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  \t//Change to square aspect ratio & center in middle of viewport\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    vec3 cameraPos = vec3(0,3,-4);\n    vec3 cameraLookDir = normalize( vec3(0.0,-0.3,1.0));\n    vec3 rayDir = normalize(vec3(uv.xy+cameraLookDir.xy, cameraLookDir.z));\n        \n    \n    //Vec2 (X = distanceToScene, Y = object ID - used for differentiation like different textures)\n    float matID;\n    float rayMarchDistance = RayMarch(cameraPos, rayDir, matID);\n    vec3 scenePos = cameraPos + rayDir * rayMarchDistance;\n    \n    vec3 normal = GetNormal(scenePos);\n    \n    vec3 albedo = GetAlbedo(scenePos, normal, matID); \n\tfloat diffuseLighting = GetLight(scenePos, normal);\n    \n    vec3 lightColor = vec3(0.8,0.8,0.8);\n       \n\tvec3 col = albedo * vec3(lightColor*diffuseLighting);\n    \n    vec3 ambientColor = vec3(0.2,0.2,0.2);\n    col += ambientColor;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}