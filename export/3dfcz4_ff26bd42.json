{"ver":"0.1","info":{"id":"3dfcz4","date":"1584222710","viewed":333,"name":"Block Matching motion detector","username":"levonchic","description":"Motion detector using block matching algorithm.\nSimple implementation of the Three Step Search in GLSL shader with parameters 16 and 7.\nSee: https://en.wikipedia.org/wiki/Block-matching_algorithm","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["motiondetector","blockmatching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Specify what to display\n// #define DISPLAY_DELTA\n#define DISPLAY_METRIC\n\n// Used to scale return value of metric difference because it may bee too low and invisible\n#define METRIC_SCALE 1000.0\n\n\n// Simple implementation of Block Matching algorithm in GLSL shader in shadertoy.\n// This algorithm breaks input video into pieces (blocks) of fixed size \n// and calculates displacement and metric value for each block on the scene.\n// See: https://en.wikipedia.org/wiki/Block-matching_algorithm#Three_Step_Search\n//\n// Buffer A is used to store previous frame in the A Channel and returning (dx, dy) \n// in .g and .b coords, metric in .a coord.\n// \n// (c) bitrate16 2020.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tfragColor.rgb = texture(iChannel0, fragCoord.xy / iResolution.xy).xxx;\n    \n    if (fragCoord.x > iChannelResolution[1].x + 10.0) { // iResolution.y * 0.5\n        vec2 relativeCoord = fragCoord.xy - vec2(iChannelResolution[1].x + 10.0, 0.0);\n        float relativeWidth = iResolution.x - iChannelResolution[1].x - 10.0 - 10.0;\n        float relativeHeight = iChannelResolution[1].y * relativeWidth / iChannelResolution[1].x;\n        \n        #ifdef DISPLAY_METRIC\n        // Renders simple metric for each block of input video.\n        // Can be used to detect changes on scene by using threshold on blocks. \n        if (relativeCoord.x < relativeWidth && relativeCoord.y < relativeHeight) {\n            vec2 relUV = relativeCoord.xy / vec2(relativeWidth, relativeHeight);\n            relUV *= iChannelResolution[1].xy;\n            relUV *= 1.0 / 16.0;\n        \tfragColor.gb = texelFetch(iChannel0, ivec2(relUV), 0).aa * METRIC_SCALE;\n        }\n        #endif\n        \n        #ifdef DISPLAY_DELTA\n        // Visualize dx, dy for block matching aldorithm.\n        // Green is dx, blue is dy. \n        // Displays calculated displacements for each block relative to it's top left corner.\n        if (relativeCoord.x < relativeWidth && relativeCoord.y < relativeHeight) {\n            vec2 relUV = relativeCoord.xy / vec2(relativeWidth, relativeHeight);\n            relUV *= iChannelResolution[1].xy;\n            relUV *= 1.0 / 16.0;\n        \tfragColor.gb = texelFetch(iChannel0, ivec2(relUV), 0).gb * 0.5;\n        }\n        #endif\n        \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Defines the block dimensions in width & height\n// Pre defined: \n// BLOCK_SIZE   16px\n// SEARCH_SIZE   7px\n// ^ Defines the search area as (BLOCK_SIZE + SEARCH_SIZE) rectangle for block\n\n// Returns previous frame value\nvec4 prev(ivec2 xy) {\n    return texelFetch(iChannel0, xy, 0);\n}\n\n// Returns current frame value (does not contain g, b, a)\nvec4 curr(ivec2 xy) {\n    return vec4(texelFetch(iChannel1, xy, 0).x, 0.0, 0.0, 1.0);\n}\n\n// Returns previous frame value with checking for coord bounds\nfloat prevf(ivec2 xy) {\n    if (xy.x < 0 || xy.y < 0 || xy.x >= int(iChannelResolution[1].x) || xy.y >= int(iChannelResolution[1].y))\n        return 0.0;\n    return texelFetch(iChannel0, xy, 0).x;\n}\n\n// Returns current frame value (does not contain g, b, a) with checking for coord bounds\nfloat currf(ivec2 xy) {\n    if (xy.x < 0 || xy.y < 0 || xy.x >= int(iChannelResolution[1].x) || xy.y >= int(iChannelResolution[1].y))\n        return 0.0;\n    return texelFetch(iChannel1, xy, 0).x;\n}\n\n// Computes Mean Squared Difference between two blocks in the specified location\n//\n// Input is:\n// icoordPrev - coordinates of the previous block.\n//              prev block should stay in place while current block \n//              is moving trying to find the best match.\n// icoordCurrent - coordinates of the current block.\nfloat metric(ivec2 icoordPrev, ivec2 icoordCurrent) {\n    float collector = 0.0;\n    float delta = 0.0;\n    \n    // As SUM(old - new) ^ 2 / N^2\n    for (ivec2 ij = ivec2(0, 0); ij.x < 16; ++ij.x)\n    \tfor (ij.y = 0; ij.y < 16; ++ij.y)\n            collector += (delta = (prevf(icoordPrev + ij) - currf(icoordCurrent + ij))) * delta;\n        \n    return collector * (1.0 / (16.0 * 16.0));\n}\n\n\n// Three step search algorithm third step function, S = 1\n//\n// Input is:\n// icoord - coordinate of the top-left pixel of the block\nvec3 threeStepSearchThird(ivec2 icoord) {\n    // Start calculating metric over all block locations\n    vec3 res = vec3(0.0);\n    \n    // Search: 2, 2\n    // \n    //  1  2  3\n    //         \n    //  8  0  4\n    //         \n    //  7  6  5\n    // \n    // 0 - it's your uber driver here\n    \n    // -> 0\n    res.z = metric(icoord, icoord + ivec2(0, 0)); res.x = 0.0; res.y = 0.0;\n    // -> 1\n    float nval = 0.0;\n    if ((nval = metric(icoord, icoord + ivec2(-1, -1))) < res.z) { res.z = nval; res.x = -1.0; res.y = -1.0; }\n    // -> 2\n    if ((nval = metric(icoord, icoord + ivec2( 0, -1))) < res.z) { res.z = nval; res.x =  0.0; res.y = -1.0; }\n    // -> 3 \n    if ((nval = metric(icoord, icoord + ivec2( 1, -1))) < res.z) { res.z = nval; res.x =  1.0; res.y = -1.0; }\n    // -> 4 \n    if ((nval = metric(icoord, icoord + ivec2( 1,  0))) < res.z) { res.z = nval; res.x =  1.0; res.y =  0.0; }\n    // -> 5 \n    if ((nval = metric(icoord, icoord + ivec2( 1,  1))) < res.z) { res.z = nval; res.x =  1.0; res.y =  1.0; }\n    // -> 6 \n    if ((nval = metric(icoord, icoord + ivec2( 0,  1))) < res.z) { res.z = nval; res.x =  0.0; res.y =  1.0; }\n    // -> 7 \n    if ((nval = metric(icoord, icoord + ivec2(-2,  1))) < res.z) { res.z = nval; res.x = -1.0; res.y =  1.0; }\n    // -> 8 \n    if ((nval = metric(icoord, icoord + ivec2(-1,  0))) < res.z) { res.z = nval; res.x = -1.0; res.y =  0.0; }\n    \n    return res;\n}\n\n\n// Three step search algorithm second step function, S = 2\n//\n// Input is:\n// icoord - coordinate of the top-left pixel of the block\nvec3 threeStepSearchSecond(ivec2 icoord) {\n    // Start calculating metric over all block locations\n    vec3 res = vec3(0.0);\n    \n    // Search: 2, 2\n    // \n    //  1  2  3\n    //         \n    //  8  0  4\n    //         \n    //  7  6  5\n    // \n    // 0 - it's your uber driver here\n    \n    // -> 0\n    res.z = metric(icoord, icoord + ivec2(0, 0)); res.x = 0.0; res.y = 0.0;\n    // -> 1\n    float nval = 0.0;\n    if ((nval = metric(icoord, icoord + ivec2(-2, -2))) < res.z) { res.z = nval; res.x = -2.0; res.y = -2.0; }\n    // -> 2\n    if ((nval = metric(icoord, icoord + ivec2( 0, -2))) < res.z) { res.z = nval; res.x =  0.0; res.y = -2.0; }\n    // -> 3 \n    if ((nval = metric(icoord, icoord + ivec2( 2, -2))) < res.z) { res.z = nval; res.x =  2.0; res.y = -2.0; }\n    // -> 4 \n    if ((nval = metric(icoord, icoord + ivec2( 2,  0))) < res.z) { res.z = nval; res.x =  2.0; res.y =  0.0; }\n    // -> 5 \n    if ((nval = metric(icoord, icoord + ivec2( 2,  2))) < res.z) { res.z = nval; res.x =  2.0; res.y =  2.0; }\n    // -> 6 \n    if ((nval = metric(icoord, icoord + ivec2( 0,  2))) < res.z) { res.z = nval; res.x =  0.0; res.y =  2.0; }\n    // -> 7 \n    if ((nval = metric(icoord, icoord + ivec2(-2,  2))) < res.z) { res.z = nval; res.x = -2.0; res.y =  2.0; }\n    // -> 8 \n    if ((nval = metric(icoord, icoord + ivec2(-2,  0))) < res.z) { res.z = nval; res.x = -2.0; res.y =  0.0; }\n    \n    return threeStepSearchThird(icoord + ivec2(res.xy)) + vec3(res.xy, 0.0);\n}\n\n// Three step search algorithm function, entry, S = 4\n//\n// Input is:\n// icoord - coordinate of the top-left pixel of the block\nvec3 threeStepSearch(ivec2 icoord) {\n    // Start calculating metric over all block locations\n    vec3 res = vec3(0.0);\n    \n    // Search: 4, 4\n    // \n    //  1  2  3\n    //         \n    //  8  0  4\n    //         \n    //  7  6  5\n    // \n    // 0 - it's your uber driver here\n    \n    // -> 0\n    res.z = metric(icoord, icoord + ivec2(0, 0)); res.x = 0.0; res.y = 0.0;\n    // -> 1\n    float nval = 0.0;\n    if ((nval = metric(icoord, icoord + ivec2(-4, -4))) < res.z) { res.z = nval; res.x = -4.0; res.y = -4.0; }\n    // -> 2\n    if ((nval = metric(icoord, icoord + ivec2( 0, -4))) < res.z) { res.z = nval; res.x =  0.0; res.y = -4.0; }\n    // -> 3 \n    if ((nval = metric(icoord, icoord + ivec2( 4, -4))) < res.z) { res.z = nval; res.x =  4.0; res.y = -4.0; }\n    // -> 4 \n    if ((nval = metric(icoord, icoord + ivec2( 4,  0))) < res.z) { res.z = nval; res.x =  4.0; res.y =  0.0; }\n    // -> 5  \n    if ((nval = metric(icoord, icoord + ivec2( 4,  4))) < res.z) { res.z = nval; res.x =  4.0; res.y =  4.0; }\n    // -> 6  \n    if ((nval = metric(icoord, icoord + ivec2( 0,  4))) < res.z) { res.z = nval; res.x =  0.0; res.y =  4.0; }\n    // -> 7 \n    if ((nval = metric(icoord, icoord + ivec2(-4,  4))) < res.z) { res.z = nval; res.x = -4.0; res.y =  4.0; }\n    // -> 8 \n    if ((nval = metric(icoord, icoord + ivec2(-4,  0))) < res.z) { res.z = nval; res.x = -4.0; res.y =  0.0; }\n    \n    return threeStepSearchSecond(icoord + ivec2(res.xy)) + vec3(res.xy, 0.0);\n}\n\nvoid mainImage(out vec4 frag, in vec2 coord) {\n    // r - Brightness\n    // g - block dx\n    // b - block dy\n    // a - min metric\n    \n    ivec2 icoord = ivec2(coord);\n    \n    // Preserve frame for the next frame\n    frag = curr(icoord);\n    \n    // Display old frame as blue value\n    frag.b = prev(icoord).x;\n    \n    // Display difference as green value\n    frag.g = frag.r - prev(icoord).x;\n    \n    // Calculate Motion vectors only in (width(iChannel1), height(iChannel1) / BLOCK_SIZE rectangle\n    \n    // Vector deltas is stored as frag.gb = (dx, dy).\n    // Vector[x, y] = fragFrame[x, y] (Where frag frame is the entire output image of the buffer)\n    \n    if (coord.x < iChannelResolution[1].x / 16.0 && coord.y < iChannelResolution[1].y / 16.0) {\n        \n        // The following vector constains (dx, dy, metric) for the block [icoord.x, icoord.y]\n        vec3 res = threeStepSearch(icoord * 16);\n        \n        frag.gb = 0.5 + res.xy / 14.0; // Bound in [-7, 7]\n       \tfrag.a  = res.z;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}