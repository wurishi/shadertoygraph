{"ver":"0.1","info":{"id":"dl3GzB","date":"1683081613","viewed":188,"name":"Weird way to render","username":"Cesium_137","description":"It's not rasterizing, not raytracing, not raymarching, not path tracing, not raycasting. Mouse to control. Desmos link: https://www.desmos.com/calculator/xl5ulyuvwa and if that doesn't work, https://www.desmos.com/calculator/jxwsu9u0pk","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float d = 3.0; //FOV; lower numbers = higher FOV\nfloat pi = 3.14159265358979323846264338;\n\nfloat de( vec2 a, vec2 b, vec2 p, float c) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return 1.-smoothstep(length( pa - ba*h ),0.,0.001);\n} //a way i came up with of connecting two points with a line that has anti-aliasing\n//edited version of FabriceNayret2's comment on https://www.shadertoy.com/view/4ljfRD\n\nfloat z(vec2 a, float theta, float r, float h){\n    return cos(a.y)*r*sin(a.x + theta) - sin(a.y)*h;\n}\n\nvec2 c(vec2 a, float theta, float r, float h){\n    return 0.2*vec2((d*r*cos(a.x + theta))/(d - z(a,theta,r,h)),(d/(d-z(a,theta,r,h)))*(r*sin(a.y)*sin(a.x + theta) + h*cos(a.y))) + vec2(.5);\n} //plots cylindrical coordinates\n\nvec2 b(vec2 a, float x, float y, float h){\n    return c(a, atan(y,x),sqrt(x*x+y*y),h);\n} // plots cartesian coordinates\n\nfloat[] xcoords = float[](-1.,1.,-1.,1.,-1.,1.,-1.,1.);\nfloat[] ycoords = float[](-1.,-1.,1.,1.,-1.,-1.,1.,1.);\nfloat[] zcoords = float[](-1.,-1.,-1.,-1.,1.,1.,1.,1.);\nint[] edgeData1 = int[](0,0,0,7,7,7,1,1,2,2,4,4); //first list of points for the line function\nint[] edgeData2 = int[](1,2,4,6,5,3,3,5,3,6,5,6); //second list of points for the line function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 16./9.; //fixes stretching from the screen being a rectangle\n    uv.x -= 0.38; //shifts it right to be at the center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 rot = vec2(mouse.x * 4. + iTime / 2.,(mouse.y + .125) * 4.); // rot is rotation\n    float col;\n    for(int i = 0; i <= 11; i++){\n        col += de(b(rot,xcoords[edgeData1[i]],ycoords[edgeData1[i]],zcoords[edgeData1[i]]),b(rot,xcoords[edgeData2[i]],ycoords[edgeData2[i]],zcoords[edgeData2[i]]),uv,1.0);\n    }\n    //11 is the number of edges minus one\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"}]}