{"ver":"0.1","info":{"id":"3ttXD2","date":"1581890803","viewed":279,"name":"snowmobile","username":"monsterkodi","description":"CURSOR keys to drive\nR to reset snow tracks","likes":24,"published":1,"flags":48,"usePreview":0,"tags":["sdf","snow","car"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define keys(x,y)  texelFetch(iChannel0, ivec2(x,y), 0)\n#define load(x)    texelFetch(iChannel1, ivec2(x,0), 0)\n#define load2(x,y) texelFetch(iChannel1, ivec2(x,y), 0)\nbool keyState(int key) { return keys(key, 2).x < 0.5; }\nbool keyDown(int key)  { return keys(key, 0).x > 0.5; }\n\n#define ZERO min(iFrame,0)\n#define MAX_STEPS  256\n#define MIN_DIST   0.001\n#define MAX_DIST   200.0\n\n#define NONE   0\n#define SNOW   1\n#define MOBILE 2\n#define GROUND 5\n#define NMAT   5\n#define GLOW   100\n\n#define SNOW_RES   min(iChannelResolution[1].y,1024.0)\n#define SNOW_I     int(SNOW_RES)\n#define SNOW_SCALE floor(SNOW_RES/64.0)\n\nMat[NMAT] material = Mat[NMAT](\n    //  hue   sat  lum    shiny  glossy\n    Mat(0.5,  0.0,  1.0,   0.0,  0.4 ), // SNOW\n    Mat(0.5,  0.0,  1.0,   0.0,  1.0 ), // MOBILE\n    Mat(0.5,  0.0,  0.01,  0.1,  0.5 ), // WHEEL\n    Mat(0.5,  0.0,  0.01,  0.0,  1.0 ), // WINDOW\n    Mat(0.5,  0.0,  0.01,  0.1,  1.0 )  // GROUND\n);\n\nbool space, anim, soft, occl, light, dither, foggy, rotate, normal, depthb;\n\nfloat hash(float n) { return fract(cos(n)*45758.5453); }\nmat2  rot2(float a) { vec2 v = sin(vec2(1.570796, 0) + a); return mat2(v, -v.y, v.x); }\n\nfloat at;\n\n//  0000000  000   000   0000000   000   000  \n// 000       0000  000  000   000  000 0 000  \n// 0000000   000 0 000  000   000  000000000  \n//      000  000  0000  000   000  000   000  \n// 0000000   000   000   0000000   00     00  \n\nfloat snowHeight(vec3 p)\n{\n    vec2  q = mod(p.xz, SNOW_RES*2.0);\n    ivec2 m = ivec2(q)/2;\n    vec4  h = load2(m.x, m.y);\n    vec2  f = fract(q/2.0);\n    float mx;\n    vec4  n;\n    if (m.x < 2 && m.y < 8 || m.x >= SNOW_I-1 && m.y < 3 || m.y >= SNOW_I-1 && m.x < 2 || m.x >= SNOW_I-1 && m.y >= SNOW_I-1)\n    {\n        return load2(2, 0)[0];\n    }\n    if (f.x < 0.5 && f.y < 0.5)\n    {\n        mx = mix(mix(h[0], h[2], f.x*2.0), mix(h[1], h[3], f.x*2.0), f.y*2.0);\n    }\n    else if (f.x >= 0.5 && f.y < 0.5)\n    {\n        n  = load2((m.x+1)%SNOW_I, m.y);\n        mx = mix(mix(h[2], n[0], (f.x-0.5)*2.0), mix(h[3], n[1], (f.x-0.5)*2.0), f.y*2.0);\n    }\n    else if (f.x < 0.5 && f.y >= 0.5)\n    {\n        n  = load2(m.x, (m.y+1)%SNOW_I);\n        mx = mix(mix(h[1], h[3], f.x*2.0), mix(n[0], n[2], f.x*2.0), (f.y-0.5)*2.0);\n    }\n    else\n    {\n        n       = load2((m.x+1)%SNOW_I, (m.y+1)%SNOW_I);\n        vec4 nx = load2((m.x+1)%SNOW_I, m.y);\n        vec4 ny = load2(m.x, (m.y+1)%SNOW_I);\n        mx = mix(mix(h[3], nx[1], (f.x-0.5)*2.0), mix(ny[2], n[0], (f.x-0.5)*2.0), (f.y-0.5)*2.0);\n    }\n    \n    return mx;\n}\n\nfloat floorDist()\n{\n    sdMat(GROUND, floorSinus());\n    sdMat(SNOW, sdf.pos.y - snowHeight(sdf.pos*SNOW_SCALE));\n    return sdf.dist;\n}\n\n// 000       0000000    0000000   0000000    \n// 000      000   000  000   000  000   000  \n// 000      000   000  000000000  000   000  \n// 000      000   000  000   000  000   000  \n// 0000000   0000000   000   000  0000000    \n\nvoid loadMobile()\n{\n    mobile.pos    = load2(1, 0).xyz;\n    mobile.up     = load2(1, 1).xyz;\n    mobile.dir    = load2(1, 2).xyz;\n    mobile.rgt    = load2(1, 3).xyz;\n    mobile.vel    = load2(1, 4).xyz;\n    mobile.turret = load2(1, 5).xyz;\n    mobile.track  = load2(1, 6).xy;\n}\n\n// 00     00   0000000   0000000    000  000      00000000  \n// 000   000  000   000  000   000  000  000      000       \n// 000000000  000   000  0000000    000  000      0000000   \n// 000 0 000  000   000  000   000  000  000      000       \n// 000   000   0000000   0000000    000  0000000  00000000  \n\nvoid renderMobile()\n{\n    vec3 p  = mobile.pos + 2.0*mobile.up;\n    \n    float dc  = sdCapsule(p+mobile.dir*0.4, p-mobile.dir*0.4, 1.2);\n    float d = dc;\n    \n    if (d > sdf.dist+1.5) return;\n    \n    p += 0.7*mobile.up;\n    \n    d = opUnion(d, sdLink(mobile.pos-mobile.dir*0.5+1.0*mobile.up+1.0*mobile.rgt, mobile.pos+mobile.dir*0.5+1.0*mobile.up+1.0*mobile.rgt, mobile.rgt, vec3(1.0, 0.4, 0.2), -1.0), 0.1);\n    d = opUnion(d, sdLink(mobile.pos-mobile.dir*0.5+1.0*mobile.up-1.0*mobile.rgt, mobile.pos+mobile.dir*0.5+1.0*mobile.up-1.0*mobile.rgt, mobile.rgt, vec3(1.0, 0.4, 0.2),  1.0), 0.1);\n    \n    d = opUnion(d, sdCapsule   (p, p-mobile.turret*2.5, 0.3), 0.02);\n    d = opUnion(d, sdHalfSphere(p-mobile.turret*2.8, mobile.turret, 0.7, 0.1), 0.1);\n    d = opInter(d, sdPlane(mobile.pos + 1.5*mobile.up, -mobile.up), 0.3);\n    d = opDiff (d, sdBox(p+mobile.dir*0.66, mobile.up, mobile.dir, vec3(1.5,0.15,0.8)), 0.2);\n    \n    sdMat(MOBILE, d);\n    sdMat(MOBILE+1, sdLink(mobile.pos-mobile.dir*0.5+0.9*mobile.up+1.2*mobile.rgt, mobile.pos+mobile.dir*0.5+0.9*mobile.up+1.2*mobile.rgt, mobile.rgt, vec3(0.7, 0.6, 0.2), -1.0));\n    sdMat(MOBILE+1, sdLink(mobile.pos-mobile.dir*0.5+0.9*mobile.up-1.2*mobile.rgt, mobile.pos+mobile.dir*0.5+0.9*mobile.up-1.2*mobile.rgt, mobile.rgt, vec3(0.7, 0.6, 0.2),  1.0));    \n    sdMat(MOBILE+2, opInter(dc+0.05, sdBox(p+mobile.dir*0.66, mobile.up, mobile.dir, vec3(1.2,0.2,0.8)), 0.05));\n}\n \n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    sdf = SDF(MAX_DIST, p, NONE);\n    \n    floorDist();\n    renderMobile();\n        \n    if (gl.march) \n    { \n        sdMat(GLOW, sdCylinder(gl.light1, gl.light1-0.01*mobile.turret, 0.4, 0.1));\n    }\n\n    return sdf.dist;\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0, d;\n    for(int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro+rd*t;\n        gl.rd = rd;\n        d = map(p);\n        t += d;\n        if (d < MIN_DIST) return t;\n        if (t > MAX_DIST) break;\n    }\n    sdf.mat = NONE;\n    return min(t, MAX_DIST);\n}\n\n// 000   000   0000000   00000000   00     00   0000000   000      \n// 0000  000  000   000  000   000  000   000  000   000  000      \n// 000 0 000  000   000  0000000    000000000  000000000  000      \n// 000  0000  000   000  000   000  000 0 000  000   000  000      \n// 000   000   0000000   000   000  000   000  000   000  0000000  \n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++) \n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*MIN_DIST); \n    }\n    return normalize(n);\n}\n\n//  0000000   00     00  0000000    000  00000000  000   000  000000000    \n// 000   000  000   000  000   000  000  000       0000  000     000       \n// 000000000  000000000  0000000    000  0000000   000 0 000     000       \n// 000   000  000 0 000  000   000  000  000       000  0000     000       \n// 000   000  000   000  0000000    000  00000000  000   000     000       \n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n    if (!occl) return 1.0;\n    float a = 0.0;\n    float weight = 1.0;\n    for (int i = ZERO; i <= 6; i++)\n    {\n        float d = (float(i) / 6.0) * 0.3;\n        a += weight * (d - map(p + n*d));\n        weight *= 0.8;\n    }\n    float f = clamp01(1.0-a);\n    return f*f;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    float shade = 1.0;\n    float dist = 1.0;    \n    vec3 rd = (lp-ro);\n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/24.0;\n    rd /= end;\n    for (int i = ZERO; i < 24; i++)\n    {\n        float h = map(ro+rd*dist);\n        shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist);\n        if (h < 0.0 || dist > end) break; \n    }\n    return min(max(shade, 0.0)+gl.shadow, 1.0); \n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nvec3 getLight(vec3 p, vec3 n, int mat, float d)\n{\n    if (mat == NONE) return vec3(0.5);\n    if (mat == GLOW) return white;\n    \n    Mat m = material[mat-1];\n\n    vec3 bn = (dither && mat != MOBILE && mat != MOBILE+1) ? bumpMap(p, n, mat == MOBILE+2 ? 0.002 : 0.2) : n;\n\n    vec3  col = hsl(m.hue, m.sat, m.lum);\n    \n    if (mat == MOBILE+1)\n    {\n        float ts = mobile.track[gl.tuv.z > 0.0 ? 0 : 1];\n        float ss = sin(TAU*fract(gl.tuv.x+ts)*3.0)*gl.tuv.y;\n        bn = normalize(bn+vec3(ss,0,0));\n        col *= 1.0+ss*0.5;\n    }\n    else if (mat == SNOW)\n    {\n        col *= 1.0+p.y*0.1;\n    }\n    \n    float dl1 = dot(bn,normalize(gl.light1-p));\n    float dl2 = dot(bn,normalize(gl.light2-p));\n    float dl3 = 0.35*dot(bn,normalize(vy)); //directional\n    float dnl = max(max(dl1, dl2), dl3);\n    \n    col  = (light) ? gray(col) : col;\n    \n    col += pow(m.glossy, 3.0)*vec3(pow(smoothstep(0.0+m.glossy*0.9, 1.0, dnl), 1.0+40.0*m.glossy));\n    col *= clamp(pow(dnl, 1.0+m.shiny*20.0), gl.ambient, 1.0) * getOcclusion(p, n);\n    \n    if (length(p-mobile.pos) < 5.0)\n        col *= softShadow(p, vec3(p.x,p.y+5.0,p.z), 4.0); \n\n    return clamp01(col);\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initGlobal(fragCoord, iResolution, iMouse, iTime);\n    gl.zero = ZERO;\n    gl.shadow = 0.3;\n    gl.ambient = 0.1;\n    for (int i = KEY_1; i <= KEY_9; i++) { if (keyDown(i)) { gl.option = i-KEY_1+1; break; } }\n    \n    rotate =  keyState(KEY_R);\n    anim   =  keyState(KEY_P);\n    occl   = !keyState(KEY_O);\n    dither =  keyState(KEY_G);\n    normal = !keyState(KEY_X);\n    depthb = !keyState(KEY_Z);\n    light  = !keyState(KEY_L);\n    space  = !keyState(KEY_T);\n    foggy  =  keyState(KEY_F);\n    \n    if (anim) at = 0.9*iTime;\n    \n    initCam(0.0, vec2(0));\n    \n    lookAtFrom(load2(0,1).xyz, load2(0,2).xyz);\n\n    #ifndef TOY\n    if (space) lookAtFrom(iCenter, iCamera);\n    #endif\n    \n    gl.uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(gl.uv.x*cam.x + gl.uv.y*cam.up + cam.fov*cam.dir);\n    \n    loadMobile();\n    \n    gl.light1 = mobile.pos + mobile.up*2.7 - mobile.turret*2.8;\n    gl.light2 = cam.pos + 5.0*cam.up - 20.0*cam.x;\n    \n    gl.march = true;\n    float d = march(cam.pos, rd);\n    gl.march = false;\n    int mat = sdf.mat;\n    \n    vec3  p = cam.pos + d * rd;\n    vec3  n = getNormal(p);\n    vec3  col = v0;\n           \n    if (normal || depthb)\n    {\n        vec3 nc = normal ? d >= MAX_DIST ? black : n : white;\n        vec3 zc = depthb ? vec3(1.0-pow(d/MAX_DIST,0.1)) : white;\n        col = nc*zc;\n    }\n    else\n    {\n        col = getLight(p, n, mat, d);\n        if (foggy) col = mix(col, vec3(0.8), smoothstep(MAX_DIST*0.4, MAX_DIST*1.2, d));\n    }\n        \n    fragColor = postProc(col, dither, true, true);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TOY\n#define PI   3.141592653589\n#define PI2  1.570796326795\n#define TAU  6.283185307178\n#define E    2.718281828459\n#define EPS  0.000000000001\n#define PHI  1.618033988750\n#define EPS1 1.00001\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n#define KEY_SPACE 32\n#define KEY_1     49\n#define KEY_9     57\n#define KEY_A     65\n#define KEY_C     67\n#define KEY_D     68\n#define KEY_E     69\n#define KEY_F     70\n#define KEY_G     71\n#define KEY_L     76\n#define KEY_N     78\n#define KEY_O     79\n#define KEY_P     80\n#define KEY_Q     81\n#define KEY_R     82\n#define KEY_S     83\n#define KEY_T     84\n#define KEY_W     87\n#define KEY_X     88\n#define KEY_Z     90\n\nconst vec3 v0 = vec3(0,0,0);\nconst vec3 vx = vec3(1,0,0);\nconst vec3 vy = vec3(0,1,0);\nconst vec3 vz = vec3(0,0,1);\n\nconst vec3 red   = vec3(0.8,0.0,0.0);\nconst vec3 green = vec3(0.0,0.5,0.0);\nconst vec3 blue  = vec3(0.2,0.2,1.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\nconst vec3 black = vec3(0.0,0.0,0.0);\n\n#define sdMat(m,d)  if (d < sdf.dist) { sdf.dist = d; sdf.mat = m; }\n\n// 00     00   0000000   0000000    000  000      00000000  \n// 000   000  000   000  000   000  000  000      000       \n// 000000000  000   000  0000000    000  000      0000000   \n// 000 0 000  000   000  000   000  000  000      000       \n// 000   000   0000000   0000000    000  0000000  00000000  \n\nstruct Mobile {\n    vec3 pos;\n    vec3 up;\n    vec3 dir;\n    vec3 rgt;\n    vec3 vel;\n    vec3 turret;\n    vec2 track;\n} mobile;\n\n//  0000000   000       0000000   0000000     0000000   000      \n// 000        000      000   000  000   000  000   000  000      \n// 000  0000  000      000   000  0000000    000000000  000      \n// 000   000  000      000   000  000   000  000   000  000      \n//  0000000   0000000   0000000   0000000    000   000  0000000  \n\nstruct Text {\n    ivec2 size;\n    ivec2 adv;\n} text;\n\nstruct SDF {\n    float dist;\n    vec3  pos;\n    int   mat;\n} sdf;\n\nfloat floorSinus()\n{\n    vec2 sp = sin(sdf.pos.xz*0.2);\n    return sdf.pos.y - (sp.x+sp.y);\n}\n\nstruct _gl {\n    vec2  uv;\n    vec3  tuv;\n    vec2  frag;\n    vec2  mouse;\n    vec2  mp;\n    ivec2 ifrag;\n    float aspect;\n    vec4  color;\n    int   option;\n    float time;\n    vec3  light1;\n    vec3  light2;\n    vec3  light3;\n    vec3  rd;\n    float ambient;\n    float shadow;\n    int   zero;\n    bool  march;\n} gl;\n\nstruct _cam {\n    vec3  tgt;\n    vec3  pos;\n    vec3  pos2tgt;\n    vec3  dir;\n    vec3  up;\n    vec3  x;\n    float dist;\n    float fov;\n} cam;\n\nstruct Mat {\n    float hue;\n    float sat;\n    float lum;\n    float shiny;\n    float glossy;\n};\n\nuniform sampler2D fontChannel;\n\nvoid initGlobal(vec2 fragCoord, vec3 resolution, vec4 mouse, float time)\n{\n    text.size = ivec2(16,32)*2;\n    text.adv  = ivec2(text.size.x,0);\n    \n    mouse.xy = min(mouse.xy,resolution.xy);\n    if (mouse.z < 1.0)\n    {\n        if (mouse.z > -1.0)\n            gl.mouse = resolution.xy*0.5;\n        else\n            gl.mouse = mouse.xy;\n    }\n    else gl.mouse = mouse.xy;\n    \n    gl.mp = (2.0*abs(gl.mouse)-vec2(resolution.xy))/resolution.y;    \n\n    gl.aspect = resolution.x / resolution.y;\n    gl.frag   = fragCoord;\n    gl.ifrag  = ivec2(fragCoord);\n    gl.uv     = (fragCoord+fragCoord-resolution.xy)/resolution.y;\n    \n    gl.ambient = 0.03;\n    gl.shadow  = 0.20;\n}\n\nfloat powi(int a, int b) { return pow(float(a), float(b)); }\nfloat log10(float a) { return log(a)/log(10.0); }\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\nvec3  clamp01(vec3 v) { return clamp(v, 0.0, 1.0); }\n\n// 00000000   00000000   000  000   000  000000000  \n// 000   000  000   000  000  0000  000     000     \n// 00000000   0000000    000  000 0 000     000     \n// 000        000   000  000  000  0000     000     \n// 000        000   000  000  000   000     000     \n\n#ifndef TOY\nfloat print(ivec2 pos, int ch)\n{\n    ivec2 r = gl.ifrag-pos; bool i = r.y>0 && r.x>0 && r.x<=text.size.y && r.y<=text.size.y;\n    return i ? texelFetch(iChannel2,ivec2((ch%16)*64,(1024-64-64*(ch/16)))+r*64/text.size.y,0).r : 0.0;\n}\n\nfloat print(ivec2 pos, float v)\n{\n    float c = 0.0; ivec2 a = text.adv; \n    float fv = fract(v);\n    v = (fv > 0.995 || fv < 0.005) ? round(v) : v;\n    float f = abs(v);\n    int i = (fv == 0.0) ? 1 : fract(v*10.0) == 0.0 ? -1 : -2;\n    int ch, u = max(1,int(log10(f))+1);\n    ivec2 p = pos+6*a;\n    for (; i <= u; i++) {\n        if (i == 0)     ch = 46;\n        else if (i > 0) ch = 48+int(mod(f, powi(10,i))/powi(10,i-1));\n        else            ch = 48+int(mod(f+0.005, powi(10,i+1))/powi(10,i));\n        c = max(c, print(p-i*a, ch)*float(i+3)/30.0); }\n    if (v < 0.0) c = max(c, print(p-i*a, 45)*float(i)/30.0);\n    return c;\n}\n\nfloat print(ivec2 pos, vec4 v)\n{\n    float c = 0.0;\n    for (int i = 0; i < 4; i++) {\n        c = max(c, print(pos, v[i]));\n        pos += text.adv*8; }\n    return c;\n}\n\nfloat print(ivec2 pos, vec3 v)\n{\n    float c = 0.0;\n    for (int i = 0; i < 3; i++) {\n        c = max(c, print(pos, v[i]));\n        pos += text.adv*8; }\n    return c;\n}\n\nfloat print(ivec2 pos, vec2 v)\n{\n    float c = 0.0;\n    for (int i = 0; i < 2; i++) {\n        c = max(c, print(pos, v[i]));\n        pos += text.adv*8; }\n    return c;\n}\n\nfloat print(int x, int y, int v)   { return print(ivec2(text.size.x*x,text.size.y*y), float(v)); }\nfloat print(int x, int y, float v) { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, vec4 v)  { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, vec3 v)  { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, vec2 v)  { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, ivec3 v) { return print(ivec2(text.size.x*x,text.size.y*y), vec3(v)); }\n#endif\n\nfloat gradientNoise(vec2 v)\n{\n    return fract(52.9829189 * fract(dot(v, vec2(0.06711056, 0.00583715))));\n}\n\n// 000   000   0000000  000      \n// 000   000  000       000      \n// 000000000  0000000   000      \n// 000   000       000  000      \n// 000   000  0000000   0000000  \n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsl(float h, float s, float l) { return hsl2rgb(vec3(h,s,l)); }\n\nvec3 rgb2hsl(vec3 col)\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + EPS)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              \n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + EPS),  \n                 (minc+maxc)*0.5);\n}\n\nvec3 colsat(vec3 col, float sat)\n{\n    vec3 h = rgb2hsl(col);\n    return hsl(h.x,sat,h.z);\n}\n\nvec3 gray(vec3 col)\n{\n    return colsat(col, 0.0);\n}\n\n// 00     00   0000000   000000000  00000000   000  000   000  \n// 000   000  000   000     000     000   000  000   000 000   \n// 000000000  000000000     000     0000000    000    00000    \n// 000 0 000  000   000     000     000   000  000   000 000   \n// 000   000  000   000     000     000   000  000  000   000  \n\nmat3 alignMatrix(vec3 dir) \n{\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3  rad2deg(vec3 v) { return 180.0 * v / PI; }\nvec3  deg2rad(vec3 v) { return PI * v / 180.0; }\n\nmat3  rotMat(vec3 u, float angle)\n{\n    float s = sin(deg2rad(angle));\n    float c = cos(deg2rad(angle));\n    float i = 1.0-c;\n    \n    return mat3(\n        c+u.x*u.x*i, u.x*u.y*i-u.z*s, u.x*u.z*i+u.y*s,\n        u.y*u.x*i+u.z*s, c+u.y*u.y*i, u.y*u.z*i-u.x*s,\n        u.z*u.x*i-u.y*s, u.z*u.y*i+u.x*s, c+u.z*u.z*i\n        );\n}\n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{\n    mat3 m = rotMat(axis, angle);\n    return m * position;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2, float k) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h);\n}\n\nfloat opInter(float d1, float d2, float k) \n{\n    \n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\nfloat opDiff (float d1, float d2) { return opDiff (d1, d2, 0.0); }\nfloat opUnion(float d1, float d2) { return opUnion(d1, d2, 0.5); }\nfloat opInter(float d1, float d2) { return opInter(d1, d2, 0.2); }\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdSphere(vec3 a, float r)\n{\n    return length(sdf.pos-a)-r;\n}\n\nfloat sdPlane(vec3 a, vec3 n)\n{   \n    return dot(n, sdf.pos-a);\n}\n\nfloat sdPlane(vec3 n)\n{   \n    return dot(n, sdf.pos);\n}\n\nfloat sdHalfSphere(vec3 a, vec3 n, float r, float k)\n{\n    return opInter(sdPlane(a, -n), sdSphere(a, r), k);\n}\n\nfloat sdBox(vec3 a, vec3 up, vec3 dir, vec3 dim)\n{\n  vec3  q = sdf.pos-a;\n  float x = abs(dot(cross(dir, up), q))-dim.x;\n  float y = abs(dot(up,  q))-dim.y;\n  float z = abs(dot(dir, q))-dim.z;\n  return max(x,max(y,z));\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = sdf.pos-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(sdf.pos-c)-r;        \n}\n\nfloat sdCylinder(vec3 a, vec3 b, float r, float cr)\n{\n  vec3  ba = b - a;\n  vec3  pa = sdf.pos - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba - cr;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2)\n{\n    vec3 q = vec3(p.x, max(abs(p.y)-le,0.0), p.z);\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdLink(vec3 a, vec3 b, vec3 n, vec3 r, float uvz)\n{\n    vec3 ab = normalize(b-a);\n    float lab = length(ab);\n    vec3 p = sdf.pos - (b+a)*0.5; // center\n    p *= mat3(cross(n, ab), ab, n); // orientate\n    p -= vec3(0,0,clamp(p.z,-r.y, r.y)); // elongate\n    vec3 q = vec3(p.x, max(abs(p.y)-lab,0.0), p.z); // stretch up\n    float d = length(vec2(length(q.xy)-r.x,q.z)) - r.z;\n    if (d < sdf.dist && gl.march) \n    {\n        float uvy = abs(length(q.xy)-r.x)/r.z;\n        if (q.y == 0.0)\n            gl.tuv = vec3(fract(sign(p.x)*p.y/lab), uvy, uvz);\n        else\n            gl.tuv = vec3(fract(sign(p.x)*sign(p.y)*(1.0-acos(dot(normalize(q.xy), vec2(0,1)))/PI2)), uvy, uvz);\n    }\n    return d;\n}\n\n// 000   000   0000000   000   0000000  00000000  \n// 0000  000  000   000  000  000       000       \n// 000 0 000  000   000  000  0000000   0000000   \n// 000  0000  000   000  000       000  000       \n// 000   000   0000000   000  0000000   00000000  \n\nfloat noise3D(in vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// 0000000    000   000  00     00  00000000   \n// 000   000  000   000  000   000  000   000  \n// 0000000    000   000  000000000  00000000   \n// 000   000  000   000  000 0 000  000        \n// 0000000     0000000   000   000  000        \n\nfloat drawSphere(in vec3 p)\n{\n    p = fract(p)-.5; return dot(p, p);\n}\n\nfloat cellTile(in vec3 p)\n{\n    vec4 d; \n    d.x = drawSphere(p - vec3(.81, .62, .53)); p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2,  .11)); p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2,  .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*2.66;\n}\n\nfloat bumpSurf(vec3 p, float factor)\n{\n    return 0.2*noise3D(p*15.0) - 0.05*noise3D(p*10.0/factor);\n}\n\nvec3 bumpMap(vec3 p, vec3 nor, float factor)\n{\n    const vec2 e = vec2(0.001, 0);\n    vec3 grad = (vec3(bumpSurf(p - e.xyy, factor),\n                      bumpSurf(p - e.yxy, factor),\n                      bumpSurf(p - e.yyx, factor))-bumpSurf(p, factor))/e.x;                     \n    grad -= nor*dot(nor, grad);          \n    return normalize(nor - grad*0.3*factor*smoothstep(0.0,1.0,1.0-length(cam.pos-p)/30.0));\n}\n\n//  0000000   0000000   00     00  \n// 000       000   000  000   000  \n// 000       000000000  000000000  \n// 000       000   000  000 0 000  \n//  0000000  000   000  000   000  \n\nvoid lookAtFrom(vec3 tgt, vec3 pos) \n{ \n    cam.tgt     = tgt;\n    cam.pos     = pos;\n    cam.pos2tgt = cam.tgt-cam.pos;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.x       = normalize(cross(cam.dir, vy));\n    cam.up      = normalize(cross(cam.x,cam.dir));\n    cam.dist    = length(cam.pos2tgt);\n}\nvoid lookAt  (vec3 tgt) { lookAtFrom(tgt, cam.pos); }\nvoid lookFrom(vec3 pos) { lookAtFrom(cam.tgt, pos); }\nvoid lookPan (vec3 pan) { lookAtFrom(cam.tgt+pan, cam.pos+pan); }\nvoid lookPitch(float ang) { \n    cam.pos2tgt = rotAxisAngle(cam.pos2tgt, cam.x, ang); \n    cam.tgt     = cam.pos + cam.pos2tgt;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.up      = normalize(cross(cam.x,cam.dir));\n}\nvoid orbitPitch(float pitch)\n{\n    cam.pos2tgt = rotAxisAngle(cam.pos2tgt, cam.x, pitch); \n    cam.pos     = cam.tgt - cam.pos2tgt;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.up      = normalize(cross(cam.x,cam.dir));\n}\nvoid orbitYaw(float yaw)\n{\n    cam.pos2tgt = rotAxisAngle(cam.pos2tgt, vy, yaw); \n    cam.pos     = cam.tgt - cam.pos2tgt;\n    cam.dir     = normalize(cam.pos2tgt);\n    cam.x       = normalize(cross(cam.dir, vy));\n    cam.up      = normalize(cross(cam.x,cam.dir));\n}\nvoid orbit(float pitch, float yaw) \n{\n    orbitYaw(yaw);\n    orbitPitch(pitch);\n}\n\nvoid initCam(float dist, vec2 rot)\n{\n    lookAtFrom(v0, rotAxisAngle(rotAxisAngle(vec3(0,0,-dist), -vx, 89.0*rot.y), vy, -90.0*rot.x));\n    cam.fov = PI2; // 4.0;\n}\n\n// 00000000    0000000    0000000  000000000  \n// 000   000  000   000  000          000     \n// 00000000   000   000  0000000      000     \n// 000        000   000       000     000     \n// 000         0000000   0000000      000     \n\nvec4 postProc(vec3 col, bool dither, bool gamma, bool vignette)\n{\n    if (dither)   col -= vec3(gradientNoise(gl.frag)/256.0); \n    if (gamma)    col  = pow(col, vec3(1.0/2.2));\n    if (vignette) col *= vec3(smoothstep(1.8, 0.5, length(gl.uv)/max(gl.aspect,1.0)));\n    return vec4(col, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define keys(x,y)  texelFetch(iChannel0, ivec2(x,y), 0)\n#define load(x)    texelFetch(iChannel1, ivec2((x),0), 0)\n#define load2(x,y) texelFetch(iChannel1, ivec2((x),(y)), 0)\n#define save(a,c)    if((gl.ifrag.x==(a))&&(gl.ifrag.y==0)){gl.color=(c);}\n#define save2(a,b,c) if((gl.ifrag.x==(a))&&(gl.ifrag.y==(b))){gl.color=(c);}\nbool keyState(int key) { return keys(key, 2).x < 0.5; }\nbool keyDown(int key)  { return keys(key, 0).x > 0.5; }\n\n#define ZERO min(iFrame,0)\n\n#define MAX_STEPS  128\n#define MIN_DIST   0.005\n#define MAX_DIST   100.0\n\n#define NONE    0\n#define MOBILE  2\n\n#define SNOW_RES   min(iChannelResolution[1].y,1024.0)\n#define SNOW_I     int(SNOW_RES)\n#define SNOW_SCALE floor(SNOW_RES/64.0)\n\n//  0000000  000   000   0000000   000   000  \n// 000       0000  000  000   000  000 0 000  \n// 0000000   000 0 000  000   000  000000000  \n//      000  000  0000  000   000  000   000  \n// 0000000   000   000   0000000   00     00  \n\nfloat snowHeight(vec3 p)\n{\n    vec2  q = mod(p.xz, 2.0*SNOW_RES);\n    ivec2 m = ivec2(q)/2;\n    vec4  h = load2(m.x, m.y);\n    vec2  f = fract(q/2.0);\n    vec4  n;\n    \n    if (m.x < 2 && m.y < 8 || m.x >= SNOW_I-1 && m.y < 3 || m.y >= SNOW_I-1 && m.x < 2 || m.x >= SNOW_I-1 && m.y >= SNOW_I-1)\n    {\n        return load2(2, 0)[0];\n    }\n    \n    if (f.x < 0.5 && f.y < 0.5)\n    {\n        return mix(mix(h[0], h[2], f.x*2.0), mix(h[1], h[3], f.x*2.0), f.y*2.0);\n    }\n    if (f.x >= 0.5 && f.y < 0.5)\n    {\n        n  = load2((m.x+1)%SNOW_I, m.y);\n        return mix(mix(h[2], n[0], (f.x-0.5)*2.0), mix(h[3], n[1], (f.x-0.5)*2.0), f.y*2.0);\n    }\n    if (f.x < 0.5 && f.y >= 0.5)\n    {\n        n  = load2(m.x, (m.y+1)%SNOW_I);\n        return mix(mix(h[1], h[3], f.x*2.0), mix(n[0], n[2], f.x*2.0), (f.y-0.5)*2.0);\n    }\n\n    n       = load2((m.x+1)%SNOW_I, (m.y+1)%SNOW_I);\n    vec4 nx = load2((m.x+1)%SNOW_I, m.y);\n    vec4 ny = load2(m.x, (m.y+1)%SNOW_I);\n    return mix(mix(h[3], nx[1], (f.x-0.5)*2.0), mix(ny[2], n[0], (f.x-0.5)*2.0), (f.y-0.5)*2.0);\n}\n\nfloat floorDist()\n{\n    return min(floorSinus(), sdf.pos.y - snowHeight(sdf.pos*SNOW_SCALE));\n}\n\nvec3 floorNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        sdf.pos = p+e*0.0001;\n        n += e*floorDist(); }\n    return normalize(n);\n}\n\nfloat floorHeight(vec3 p)\n{\n    sdf.pos = p;\n    return floorDist();\n}\n\n// 000       0000000    0000000   0000000    \n// 000      000   000  000   000  000   000  \n// 000      000   000  000000000  000   000  \n// 000      000   000  000   000  000   000  \n// 0000000   0000000   000   000  0000000    \n\nvoid loadMobile()\n{\n    mobile.pos    = load2(1, 0).xyz;\n    mobile.up     = load2(1, 1).xyz;\n    mobile.dir    = load2(1, 2).xyz;\n    mobile.rgt    = load2(1, 3).xyz;\n    mobile.vel    = load2(1, 4).xyz;\n    mobile.turret = load2(1, 5).xyz;\n    mobile.track  = load2(1, 6).xy;\n}\n\n//  0000000   0000000   000   000  00000000  \n// 000       000   000  000   000  000       \n// 0000000   000000000   000 000   0000000   \n//      000  000   000     000     000       \n// 0000000   000   000      0      00000000  \n\nvoid saveMobile()\n{\n    save2(1, 0, vec4(mobile.pos,   0));\n    save2(1, 1, vec4(mobile.up,    0));\n    save2(1, 2, vec4(mobile.dir,   0));\n    save2(1, 3, vec4(mobile.rgt,   0));\n    save2(1, 4, vec4(mobile.vel,   0));\n    save2(1, 5, vec4(mobile.turret,0));\n    save2(1, 6, vec4(mobile.track, 0,0));\n}\n\n// 000  000   000  000  000000000  \n// 000  0000  000  000     000     \n// 000  000 0 000  000     000     \n// 000  000  0000  000     000     \n// 000  000   000  000     000     \n\nvoid initCamera()\n{\n    save2(0,1,vec4(2,1,2,0));\n    save2(0,2,vec4(8,1,8,0));\n}\n\nvoid initMobile()\n{\n   mobile.pos    = vec3(2,2,2);\n   mobile.dir    = vx;\n   mobile.up     = vy;\n   mobile.rgt    = vz;\n   mobile.turret = vx;\n   mobile.vel    = vx*0.5;\n   mobile.track  = vec2(0);\n   saveMobile();\n}\n\nvoid initSnow(int x, int y)\n{\n   float x1 = 3.0*cos( (float(x)     /SNOW_RES-0.5)*TAU);\n   float x2 = 3.0*cos(((float(x)+0.5)/SNOW_RES-0.5)*TAU);\n   float y1 = 3.0*cos( (float(y)     /SNOW_RES-0.5)*TAU);\n   float y2 = 3.0*cos(((float(y)+0.5)/SNOW_RES-0.5)*TAU);\n   \n   x1 += 1.0*cos(((float(x)+0.0)/(SNOW_RES/4.0)-0.5)*TAU);\n   x2 += 1.0*cos(((float(x)+0.5)/(SNOW_RES/4.0)-0.5)*TAU);\n   y1 += 1.0*cos(((float(y)+0.0)/(SNOW_RES/4.0)-0.5)*TAU);\n   y2 += 1.0*cos(((float(y)+0.5)/(SNOW_RES/4.0)-0.5)*TAU);\n   \n   save2(x, y, 8.0+vec4( x1+y1, x1+y2, x2+y1, x2+y2));\n}\n\n// 00     00   0000000   0000000    000  000      00000000  \n// 000   000  000   000  000   000  000  000      000       \n// 000000000  000   000  0000000    000  000      0000000   \n// 000 0 000  000   000  000   000  000  000      000       \n// 000   000   0000000   0000000    000  0000000  00000000  \n\nvoid calcMobile()\n{\n    loadMobile();\n    \n    float d, v, a;\n    vec3 acc, vel;\n    \n    acc = v0;\n\n    vec3 oldPosR = mobile.pos + 1.3*mobile.rgt;\n    vec3 oldPosL = mobile.pos - 1.3*mobile.rgt;\n    \n    float td = iTimeDelta*60.0;\n        \n    float rotSpeed = 4.0*td;\n    float rotAngle = keyDown(KEY_LEFT) ? -rotSpeed : keyDown(KEY_RIGHT) ? rotSpeed : iMouse.z > 0.0 ? gl.mp.x * rotSpeed : 0.0;\n    \n    mobile.dir = rotAxisAngle(mobile.dir, mobile.up, rotAngle);        \n    mobile.dir = normalize(mobile.dir);\n    \n    float accel = 0.02*td;\n    accel *= keyDown(KEY_UP) ? 1.0 : keyDown(KEY_DOWN) ? -0.8 : iMouse.z > 0.0 ? gl.mp.y*0.5+0.5 : 0.0;\n    acc += accel*mobile.dir;\n        \n    mobile.vel += acc;\n    \n    mobile.pos += mobile.vel;\n    \n    mobile.pos.y -= (floorHeight(mobile.pos+mobile.dir*2.0) + floorHeight(mobile.pos-mobile.dir*2.0) + floorHeight(mobile.pos+mobile.rgt*2.0) + floorHeight(mobile.pos-mobile.rgt*2.0))/4.0; \n    mobile.up     = mix(mobile.up, (floorNormal(mobile.pos+mobile.dir*2.0) + floorNormal(mobile.pos-mobile.dir*2.0) + floorNormal(mobile.pos+mobile.rgt*2.0) + floorNormal(mobile.pos-mobile.rgt*2.0))/4.0, 0.5);\n    \n    mobile.rgt = normalize(cross(mobile.dir, mobile.up));\n    mobile.dir = normalize(cross(mobile.up, mobile.rgt));\n    \n    mobile.vel = mix(mobile.vel, mobile.dir*length(mobile.vel), 0.01);\n    float vell = length(mobile.vel);\n\n    vec3 veln = normalize(mobile.vel);\n    mobile.vel -= veln*0.01*td;\n    if (vell > 1.0)\n    {\n        mobile.vel = veln;\n    }\n    \n    vec3 deltaR = (mobile.pos + 1.3*mobile.rgt)-oldPosR;\n    vec3 deltaL = (mobile.pos - 1.3*mobile.rgt)-oldPosL;\n    float dr = length(deltaR);\n    float dl = length(deltaL);\n    if (dl > EPS)\n    {\n        mobile.track.x = fract(mobile.track.x-dot(normalize(deltaL), mobile.dir)*dl);\n    }\n    if (dr > EPS)\n    {\n        mobile.track.y = fract(mobile.track.y-dot(normalize(deltaR), mobile.dir)*dr);\n    }\n    \n    mobile.turret = normalize(mix(mobile.turret, mobile.dir, 0.1))*(0.75+0.25*smoothstep(0.0, 3.0, length(mobile.vel)));\n    \n    saveMobile();\n}\n\n//  0000000  000   000   0000000   000   000  \n// 000       0000  000  000   000  000 0 000  \n// 0000000   000 0 000  000   000  000000000  \n//      000  000  0000  000   000  000   000  \n// 0000000   000   000   0000000   00     00  \n\nvoid calcSnow(int x, int y)\n{\n    if (keyDown(KEY_R) || load(0).x != SNOW_RES) \n    {\n        initSnow(x, y);\n        return;\n    }\n    \n    vec4 h = load2(x,y);\n    loadMobile();\n    \n    vec3 p = mobile.pos*SNOW_SCALE;\n    vec2 q1 = mod(p.xz, SNOW_RES*2.0)*0.5;\n    vec2 q2 = q1+vec2(SNOW_RES,0);\n    vec2 q3 = q1-vec2(SNOW_RES,0);\n    vec2 q4 = q1+vec2(0,SNOW_RES);\n    vec2 q5 = q1-vec2(0,SNOW_RES);\n    \n    float td = iTimeDelta*60.0;\n    float speedFactor = clamp01(1.2*(length(mobile.vel)-0.15*td));\n    \n    for (float i = float(ZERO); i < 4.0; i++)\n    {\n        vec2 o = vec2(x,y)+vec2(0.5*mod(floor(i/2.0),2.0),0.5*mod(i,2.0));\n        float d = min (min( min(length(q1-o), length(q2-o)), min(length(q3-o), length(q4-o))), length(q5-o));\n        float mf = clamp01(1.0-(mobile.pos.y-h[int(i)])/0.35);\n        float ssc = SNOW_SCALE/4.0;\n        h[int(i)] -= 0.33*(1.0-smoothstep(4.0*ssc,ssc*(5.0+2.0*speedFactor),d))*speedFactor*mf;\n    }\n    save2(x, y, h);\n}\n\n//  0000000   0000000   00     00  00000000  00000000    0000000   \n// 000       000   000  000   000  000       000   000  000   000  \n// 000       000000000  000000000  0000000   0000000    000000000  \n// 000       000   000  000 0 000  000       000   000  000   000  \n//  0000000  000   000  000   000  00000000  000   000  000   000  \n\nvoid calcCamera()\n{\n    vec4 tgt = load2(0,1);\n    vec4 pos = load2(0,2);\n    \n    loadMobile();\n        \n    tgt.xyz = mix(tgt.xyz, mobile.pos, 0.2);\n    pos.xyz = mix(pos.xyz, tgt.xyz - 20.0*mobile.dir + 8.0*mobile.up, 0.02);\n    \n    pos.y = max(pos.y, snowHeight(pos.xyz)+8.0);\n    \n    save2(0,1,tgt);\n    save2(0,2,pos);\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initGlobal(fragCoord, iResolution, iMouse, iTime);\n\n    ivec2 mem = ivec2(fragCoord);\n    int id = mem.x;\n    \n    if (iFrame < 1)\n    {\n        if (id == 0 && mem.y == 0)\n        {\n            save(0,vec4(SNOW_RES,0,0,0));\n        }\n        else\n        {\n            if (id == 0 && mem.y < 3)\n            {\n                initCamera();\n            }\n            else if (id >= 1 && id <= 1 && mem.y < 8)\n            {\n                initMobile();\n            } \n            else\n            {\n                initSnow(mem.x, mem.y);\n            }\n        }\n        \n        fragColor = gl.color;\n        return;\n    }\n\n    if (id == 0 && mem.y == 0)\n    {\n        save(id,vec4(SNOW_RES,0,0,0));\n    }\n    else\n    {\n        if (id == 0 && mem.y < 3)\n        {\n            calcCamera();\n        }\n        else if (id >= 1 && id <= 1 && mem.y < 8)\n        {\n            calcMobile();\n            calcMobile();\n        }\n        else if (mem.x < SNOW_I && mem.y < SNOW_I)\n        {\n            calcSnow(mem.x, mem.y);\n        }\n    }\n    \n    fragColor = gl.color;\n}","name":"Buffer A","description":"","type":"buffer"}]}