{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.1415926\n#define MAX_STEPS 1000\n#define MAX_DIST 200.\n#define MIN_DIST .01\n\nfloat noise(vec2 coords) {\n    return fract(sin(dot(coords.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n\nfloat simplex(vec2 pos) {\n    pos.x /= cos(PI/6.);\n\n    pos.y += sin(PI/6.)*pos.x;\n\n    vec2 b = round(pos);\n\n    //vec3 col = vec3((abs(b-pos).x < .02) || (abs(b-pos).y < .02) || (abs(fract(pos.x)-fract(pos.y)) < .02) ? 1.0 : (fract(pos.x) < fract(pos.y)) ? .25 : .75);\n\n    //col = vec3(noise((fract(pos.x) < fract(pos.y)) ? floor(pos) : ceil(pos)), 0., .5);\n\n    float trVert = ceil(fract(pos.x)-fract(pos.y));\n\n    vec3 c = vec3(\n\n        noise(floor(pos)), \n\n        noise(floor(pos + 1.)), \n\n        noise(floor(pos) + vec2(trVert, 1.-trVert)));\n\n    vec2 v[3];\n\n    v[0] = floor(pos);\n\n    v[1] = floor(pos + 1.);\n\n    v[2] = floor(pos) + vec2(trVert, 1.-trVert);\n\n    vec3 interp = vec3(\n\n        ((v[1].y-v[2].y)*(pos.x-v[2].x)\n\n        +(v[2].x-v[1].x)*(pos.y-v[2].y))/\n\n        ((v[1].y-v[2].y)*(v[0].x-v[2].x)\n\n        +(v[2].x-v[1].x)*(v[0].y-v[2].y)),\n\n        ((v[2].y-v[0].y)*(pos.x-v[2].x)\n\n        +(v[0].x-v[2].x)*(pos.y-v[2].y))/\n\n        ((v[1].y-v[2].y)*(v[0].x-v[2].x)\n\n        +(v[2].x-v[1].x)*(v[0].y-v[2].y)),\n\n        0.\n\n    );\n    interp.z = 1.-interp.x-interp.y;\n    //return c[0]*interp.x+c[1]*interp.y+c[2]*interp.z;\n    if (interp.x > interp.y && interp.x > interp.z) \n        return c[0];\n    if (interp.y > interp.x && interp.y > interp.z) \n        return c[1];\n    return c[2];\n}\n\nfloat sdSphere(vec3 pos, vec3 o, float r) {\n    return length(o - pos) - r;\n}\n\nfloat sdPlane(vec3 pos){\n    return pos.y+2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 1.*fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    vec3 pos = vec3(0., 2.+iTime, 2.);\n    vec3 dir = vec3(uv, -.3);\n    vec3 origin = pos;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        float noiseVal = simplex(pos.xy);\n        float minDist = //pos.y - noiseVal+1.;\n            //sdSphere(pos, vec3(0., 0., 1.), sin(iTime)/2.+.5)\n            sdPlane(pos)\n        ;\n        if (pos.z - noiseVal <= MIN_DIST){ \n            col = vec3(noiseVal/length(pos - origin));\n            if (pos.z < .5+sin(pos.x)*.1) col += vec3(1., 0., 0.);\n            if (abs(pos.z - noiseVal) < .01) col += vec3(0., 1., 0.)/length(pos - origin);\n            break;\n        }\n        pos +=.005* normalize(dir);\n        //pos += normalize(dir)*minDist;\n        if (length(pos - origin) > MAX_DIST) break;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fGBz1","date":"1733912869","viewed":121,"name":"Terrain generation attempt","username":"kofi","description":"Generating terrain","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["terrain","simplexnoise"],"hasliked":0,"parentid":"","parentname":""}}