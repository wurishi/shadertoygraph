{"ver":"0.1","info":{"id":"MXfGW4","date":"1707458541","viewed":65,"name":"NooB RayCasting","username":"NeeTer","description":"My First Ray Casting :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NO_INTERSECT Intersect(-1.0f, vec3(0.0f), vec3(0.0f), vec3(0.0f))\n#define TOGGLE_NORMAL false\n\n// ======================= Components =======================\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\nstruct Intersect\n{\n    float t;\n    vec3 color;\n    vec3 normal;\n    vec3 hitPoint;\n};\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\nstruct AABB\n{\n    vec3 center;\n    vec3 scale;\n    vec3 color;\n};\n\n// ======================= Intersect Function =======================\nIntersect Min(Intersect org, Intersect comp)\n{\n    if(comp.t >= 0.0f && comp.t < org.t)\n        return comp;\n    else\n        return org;\n}\nIntersect intersect(const Ray ray, const Sphere sphere)\n{\n    float b = 2.0f * dot(ray.org - sphere.center, ray.dir);\n    float c = dot(ray.org - sphere.center, ray.org - sphere.center) - (sphere.radius * sphere.radius);\n    \n    float discriminant = (b * b - 4.0f * c);\n    float t;\n    \n    if(discriminant < 0.0f) { return NO_INTERSECT; }\n    else if(abs(discriminant) < 1e-6)\n    {\n        t = -b / 2.0f;\n        if(t < 0.0f) { return NO_INTERSECT; }\n    }\n    else\n    {\n        float t1 = (-b + sqrt(discriminant)) / 2.0f;\n        float t2 = (-b - sqrt(discriminant)) / 2.0f;\n        if(t1 < 0.0f && t2 < 0.0f) { return NO_INTERSECT; }\n        t = min(max(t1, 0.0f), max(t2, 0.0f));\n    }\n    \n    vec3 hitPoint = ray.org + t * ray.dir;\n    return Intersect(t, sphere.color, normalize(hitPoint - sphere.center), hitPoint);\n}\nIntersect intersect(const Ray ray, const AABB aabb)\n{\n    vec3 aabbMin = aabb.center - aabb.scale / 2.0f;\n    vec3 aabbMax = aabb.center + aabb.scale / 2.0f;\n    \n    bool inside_X_Axis = aabbMin.x <= ray.org.x && ray.org.x <= aabbMax.x;\n    bool inside_Y_Axis = aabbMin.y <= ray.org.y && ray.org.y <= aabbMax.y;\n    bool inside_Z_Axis = aabbMin.z <= ray.org.z && ray.org.z <= aabbMax.z;\n    \n    float tMin = -1e9, tMax = 1e9;\n    float t1, t2, t3, t4, t5, t6;\n    \n    if(ray.dir.x != 0.0f)\n    {\n        t1 = (aabbMin.x - ray.org.x) / ray.dir.x;\n        t2 = (aabbMax.x - ray.org.x) / ray.dir.x;\n        tMin = max(min(t1, t2), tMin);\n        tMax = min(max(t1, t2), tMax);\n    }\n    if(ray.dir.y != 0.0f)\n    {\n        t3 = (aabbMin.y - ray.org.y) / ray.dir.y;\n        t4 = (aabbMax.y - ray.org.y) / ray.dir.y;\n        tMin = max(min(t3, t4), tMin);\n        tMax = min(max(t3, t4), tMax);\n    }\n    if(ray.dir.z != 0.0f)\n    {\n        t5 = (aabbMin.z - ray.org.z) / ray.dir.z;\n        t6 = (aabbMax.z - ray.org.z) / ray.dir.z;\n        tMin = max(min(t5, t6), tMin);\n        tMax = min(max(t5, t6), tMax);\n    }\n    \n    if ((ray.dir.x == 0.0f && !inside_X_Axis) ||\n        (ray.dir.y == 0.0f && !inside_Y_Axis) ||\n        (ray.dir.z == 0.0f && !inside_Z_Axis))\n        return NO_INTERSECT;\n    \n    if(tMin > tMax || tMin < 0.0f)\n        return NO_INTERSECT;\n        \n    float t = max(tMin, 0.0f);\n    vec3 normal;\n    if(tMin == t1) { normal = vec3(-1.0f, 0.0f, 0.0f); } \n    else if(tMin == t2) { normal = vec3(1.0f, 0.0f, 0.0f); }\n    else if(tMin == t3) { normal = vec3(0.0f, -1.0f, 0.0f); } \n    else if(tMin == t4) { normal = vec3(0.0f, 1.0f, 0.0f); }\n    else if(tMin == t5) { normal = vec3(0.0f, 0.0f, -1.0f); } \n    else if(tMin == t6) { normal = vec3(0.0f, 0.0f, 1.0f); }\n    vec3 hitPoint = ray.org + t * ray.dir;\n    return Intersect(t, aabb.color, normal, hitPoint);\n}\n\n// ======================= Utility Function =======================\nmat4 CalculateLookAt(vec3 cameraEye, vec3 lookAtPos)\n{\n    vec3 forward = normalize(cameraEye - lookAtPos);\n    vec3 right = cross(vec3(0.0f, 1.0f, 0.0f), forward);\n    vec3 up = cross(forward, right);\n    \n    return mat4(vec4(right, 0.0f), vec4(up, 0.0f), vec4(forward, 0.0f), vec4(cameraEye, 1.0f));\n}\nfloat random(float val, float start, float end)\n{\n    return start + (end - start) * fract(cos(val * 173.952) * 51783.6251f);\n}\n\n// ======================= Main =======================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dx = 2.0f * (fragCoord.x + 0.5f) / iResolution.x - 1.0f;\n    dx *= iResolution.x / iResolution.y;\n    float dy = 2.0f * (fragCoord.y + 0.5f) / iResolution.y - 1.0f;\n    vec3 cameraEye = vec3(0.0f, 0.0f, -5.0f);\n    \n    float r = 4.0f;\n    cameraEye = vec3(r * sin(iTime), 0.0f, r * cos(iTime));\n    vec3 lightPos = vec3(3.0f, 3.0f, 3.0f);\n    mat4 lookAt = CalculateLookAt(cameraEye, vec3(0.0f));\n    vec3 X = (lookAt * vec4(1.0f, 0.0f, 0.0f, 0.0f)).xyz;\n    vec3 Y = (lookAt * vec4(0.0f, 1.0f, 0.0f, 0.0f)).xyz;\n    vec3 Z = (lookAt * vec4(0.0f, 0.0f, 1.0f, 0.0f)).xyz;\n    // ------------- Ray & Intersection Data -------------\n    Ray ray;\n    ray.org = cameraEye;\n    ray.dir = normalize(vec3(dx * X + dy * Y - Z));\n    \n    Intersect result;\n    result.t = 1e9;\n    result.color = vec3(0.0f);\n    \n    // ------------- Shape -------------\n    Sphere sphere[4];\n    for(int i = 0; i < 4; i++)\n    {\n        float val = fract(cos(random(float(i << 4), 0.0f, 1.0f) * 2385.8394f) * 382.8024f);\n        sphere[i].radius = random(val * 1248.18975f, 0.25f, 1.5f);\n        sphere[i].center = vec3(random(val * 98591.8127f, -3.0f, 3.0f), sphere[i].radius / 2.0f, random(val * 174.78951f, -3.0f, 3.0f));\n        sphere[i].color = vec3(random(val * 1847.5985f, 0.0f, 1.0f), random(val * 49824.957f, 0.0f, 1.0f), random(val * 1824.8579f, 0.0f, 1.0f));\n    }\n    \n    Sphere light;\n    light.center = lightPos;\n    light.radius = 2.0f;\n    light.color = vec3(0.9f);\n    \n    AABB ground[2];\n    ground[0].center = vec3(0.0f, -1.0f, 0.0f);\n    ground[1].center = vec3(0.0f, 9.0f, 0.0f);\n    for(int i = 0; i < 2; i++)\n    {\n        ground[i].scale = vec3(10.0f, 0.1f, 10.0f);\n        ground[i].color = vec3(0.1f);\n    }\n    \n    AABB wall[4];\n    vec3 wallScale[2];\n    vec3 wallPos[4];\n    wallScale[0] = vec3(1.0f, 10.0f, 10.0f); wallScale[1] = vec3(10.0f, 10.0f, 1.0f);\n    wallPos[0] = vec3(5.0f, 4.0f, 0.0f); wallPos[1] = vec3(-5.0f, 4.0f, 0.0f);\n    wallPos[2] = vec3(0.0f, 4.0f, 5.0f); wallPos[3] = vec3(0.0f, 4.0f, -5.0f);\n    for(int i = 0; i < 4; i++)\n    {\n        wall[i].center = wallPos[i];\n        wall[i].scale = wallScale[i >> 1];\n        wall[i].color = vec3(0.25f, i >> 1, 0.0f);\n    }\n    \n    for(int i = 0; i < 4; i++) { result = Min(result, intersect(ray, sphere[i])); } \n    result = Min(result, intersect(ray, light));\n    for(int i = 0; i < 2; i++) { result = Min(result, intersect(ray, ground[i])); }\n    for(int i = 0; i < 4; i++) { result = Min(result, intersect(ray, wall[i])); }\n\n    vec3 L = lightPos - result.hitPoint;\n    vec3 diffuse = max(dot(result.normal, L), 0.0f) * light.color;\n    vec3 ambient = 0.2f * light.color;\n    vec3 finalColor = (ambient + diffuse) * result.color;\n    \n    float lightT = intersect(ray, light).t;\n    if(result.t == lightT)\n        finalColor = light.color;\n\n    // Output to screen\n    if(TOGGLE_NORMAL)\n        fragColor = vec4(abs(result.normal),1.0);\n    else\n        fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}