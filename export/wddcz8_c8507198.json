{"ver":"0.1","info":{"id":"wddcz8","date":"1600578984","viewed":145,"name":" Computer Graphics template 2","username":"TinkersPot","description":"Computer Graphics course template for exercise 4 assignment 2. copied from:  https://www.shadertoy.com/view/tdd3DB","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["texturing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 AMBIENT = vec3(0.323,0.331,0.700);\nconst vec3 DIFFUSE = vec3(0.740,0.733,0.309);\nconst vec3 SPECULAR = vec3(0.750,0.643,0.750);\nconst float DIFFUSE_INTENSITY = 0.5;\nconst float SPECULAR_INTENSITY = 0.3;\nconst float SHININESS = 20.0;\n\n\n//implement better method for texturing the objects (extra assignment 2)\nvec2 getUV(vec3 p, vec3 n){\n    vec3 m = abs(n);\n    \n    if(m.x >= m.y && m.x >= m.z){\n        return p.yz*0.25;\n    }\n    else if(m.y > m.x && m.y >= m.z){\n        return p.xz*0.25;\n    }\n    else{\n        return p.xy*0.25;\n    }\n}\n\n//n = surface normal\n//rd = view direction\n//ld = light direction\nvec3 shade(vec3 n, vec3 rd, vec3 ld){\n    \n    //Fill in phong or blinn phong shading (extra assignment)\n    return AMBIENT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec2 mp = (iMouse.xy/iResolution.xy)*2.0-1.0;\n    \n    vec3 ro = vec3(4.0 * sin(iTime*0.1), 2.0 * cos(iTime*0.2), 4.0 * cos(iTime*0.1));\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    vec3 lo = normalize(ro);\n    \n    vec3 ld = (rt-lo)/distance(rt,lo);\n    vec3 rd = r(rt, ro, q);\n    float t = march(ro, rd);\n    vec3 p = ro+rd*t;\n    vec3 color = vec3(0.0);\n    \n    if(t < FAR && t >= E){\n        vec3 n = normals(p);\n        color = shade(n, rd, ld);\n        \n        //texture the objects using getUV function and testure in iChannel0\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STEPS 60\n#define FAR 30.0\n#define E 0.001\n\nfloat box(vec3 p, vec3 r){\n    vec3 d = abs(p)-r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nvoid pR(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdf(vec3 p){\n    //pR(p.xz, iTime*0.2);\n    \n    float b = box(p-vec3(2.0, 0.0, 0.0), vec3(1.0));\n    float s = sphere(p-vec3(-2.0, 0.0, 0.0), 1.0);\n    \n    return min(b, s);\n}\n\nvec3 r(vec3 rt, vec3 ro, vec2 q){\n    vec3 a = normalize(rt-ro);\n    vec3 b = normalize(cross(a, vec3(0.0, 1.0, 0.0)));\n    return normalize(mat3(b, normalize(cross(b, a)), a)*vec3(q, radians(50.0)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = sdf(p);\n        p += rd*d;\n        t += d;\n        \n        if(d < E || t >= FAR){\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    return normalize(vec3(\n        sdf(p+eps.xyy)-sdf(p-eps.xyy),\n        sdf(p+eps.yxy)-sdf(p-eps.yxy),\n        sdf(p+eps.yyx)-sdf(p-eps.yyx)\n    ));\n}","name":"Common","description":"","type":"common"}]}