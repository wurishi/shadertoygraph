{"ver":"0.1","info":{"id":"4sycWc","date":"1523481004","viewed":251,"name":"Texture displacement","username":"LilGast8","description":"Texture displacement","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","displacement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //vec4 noiseTx = texture( iChannel1, uv );\n   \tvec4 noiseTx = texture( iChannel2, uv );\n    //vec4 noiseTx = texture( iChannel3, uv );\n    \n    uv.x += noiseTx.r * 0.03;\n\tuv.y += noiseTx.r * 0.08;\n\tvec4 displacedTx = texture( iChannel0, uv );\n    \n    \n    //fragColor = noiseTx;\n    fragColor = displacedTx;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float NOISE_DETAIL = 10.0;\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\t\t return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy) );\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\t\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t\n\t// Permutations\n\ti = mod289(i); \n\tvec4 p = permute( permute( permute( \n\t\t\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t\t + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t\t\t + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tvec3 p0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1.xy,h.z);\n\tvec3 p3 = vec3(a1.zw,h.w);\n\t\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float n = snoise( vec3( uv, cos( iTime * 0.2 ) ) * 3.0 + iTime * 0.5 );\n    \n    vec3 color = vec3( n );\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float NOISE_DETAIL = 10.0;\n\n\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec4 P){\n\tvec4 Pi0 = floor(P); // Integer part for indexing\n\tvec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n\tPi0 = mod(Pi0, 289.0);\n\tPi1 = mod(Pi1, 289.0);\n\tvec4 Pf0 = fract(P); // Fractional part for interpolation\n\tvec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n\tvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\tvec4 iy = vec4(Pi0.yy, Pi1.yy);\n\tvec4 iz0 = vec4(Pi0.zzzz);\n\tvec4 iz1 = vec4(Pi1.zzzz);\n\tvec4 iw0 = vec4(Pi0.wwww);\n\tvec4 iw1 = vec4(Pi1.wwww);\n\n\tvec4 ixy = permute(permute(ix) + iy);\n\tvec4 ixy0 = permute(ixy + iz0);\n\tvec4 ixy1 = permute(ixy + iz1);\n\tvec4 ixy00 = permute(ixy0 + iw0);\n\tvec4 ixy01 = permute(ixy0 + iw1);\n\tvec4 ixy10 = permute(ixy1 + iw0);\n\tvec4 ixy11 = permute(ixy1 + iw1);\n\n\tvec4 gx00 = ixy00 / 7.0;\n\tvec4 gy00 = floor(gx00) / 7.0;\n\tvec4 gz00 = floor(gy00) / 6.0;\n\tgx00 = fract(gx00) - 0.5;\n\tgy00 = fract(gy00) - 0.5;\n\tgz00 = fract(gz00) - 0.5;\n\tvec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n\tvec4 sw00 = step(gw00, vec4(0.0));\n\tgx00 -= sw00 * (step(0.0, gx00) - 0.5);\n\tgy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n\tvec4 gx01 = ixy01 / 7.0;\n\tvec4 gy01 = floor(gx01) / 7.0;\n\tvec4 gz01 = floor(gy01) / 6.0;\n\tgx01 = fract(gx01) - 0.5;\n\tgy01 = fract(gy01) - 0.5;\n\tgz01 = fract(gz01) - 0.5;\n\tvec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n\tvec4 sw01 = step(gw01, vec4(0.0));\n\tgx01 -= sw01 * (step(0.0, gx01) - 0.5);\n\tgy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n\tvec4 gx10 = ixy10 / 7.0;\n\tvec4 gy10 = floor(gx10) / 7.0;\n\tvec4 gz10 = floor(gy10) / 6.0;\n\tgx10 = fract(gx10) - 0.5;\n\tgy10 = fract(gy10) - 0.5;\n\tgz10 = fract(gz10) - 0.5;\n\tvec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n\tvec4 sw10 = step(gw10, vec4(0.0));\n\tgx10 -= sw10 * (step(0.0, gx10) - 0.5);\n\tgy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n\tvec4 gx11 = ixy11 / 7.0;\n\tvec4 gy11 = floor(gx11) / 7.0;\n\tvec4 gz11 = floor(gy11) / 6.0;\n\tgx11 = fract(gx11) - 0.5;\n\tgy11 = fract(gy11) - 0.5;\n\tgz11 = fract(gz11) - 0.5;\n\tvec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n\tvec4 sw11 = step(gw11, vec4(0.0));\n\tgx11 -= sw11 * (step(0.0, gx11) - 0.5);\n\tgy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n\tvec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n\tvec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n\tvec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n\tvec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n\tvec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n\tvec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n\tvec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n\tvec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n\tvec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n\tvec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n\tvec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n\tvec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n\tvec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n\tvec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n\tvec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n\tvec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n\tvec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n\tg0000 *= norm00.x;\n\tg0100 *= norm00.y;\n\tg1000 *= norm00.z;\n\tg1100 *= norm00.w;\n\n\tvec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n\tg0001 *= norm01.x;\n\tg0101 *= norm01.y;\n\tg1001 *= norm01.z;\n\tg1101 *= norm01.w;\n\n\tvec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n\tg0010 *= norm10.x;\n\tg0110 *= norm10.y;\n\tg1010 *= norm10.z;\n\tg1110 *= norm10.w;\n\n\tvec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n\tg0011 *= norm11.x;\n\tg0111 *= norm11.y;\n\tg1011 *= norm11.z;\n\tg1111 *= norm11.w;\n\n\tfloat n0000 = dot(g0000, Pf0);\n\tfloat n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n\tfloat n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n\tfloat n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n\tfloat n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n\tfloat n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n\tfloat n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n\tfloat n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n\tfloat n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n\tfloat n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n\tfloat n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n\tfloat n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n\tfloat n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n\tfloat n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n\tfloat n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n\tfloat n1111 = dot(g1111, Pf1);\n\n\tvec4 fade_xyzw = fade(Pf0);\n\tvec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n\tvec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n\tvec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n\tvec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n\tfloat n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n\treturn 2.2 * n_xyzw;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float n = cnoise( vec4( uv, -uv.yx ) * NOISE_DETAIL + iTime * 0.5 );\n    \n    vec3 color = vec3( n );\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float NOISE_DETAIL = 10.0;\n\n\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float n = cnoise( vec3( uv, cos( iTime * 0.1 ) ) * NOISE_DETAIL + iTime * 0.5 );\n    \n    vec3 color = vec3( n );\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf C","description":"","type":"buffer"}]}