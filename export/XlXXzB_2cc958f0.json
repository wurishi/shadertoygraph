{"ver":"0.1","info":{"id":"XlXXzB","date":"1437449730","viewed":212,"name":"super_light_2d","username":"OtterCuddler","description":"super light 2d","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//-------------------------------------------------------------\n//-------------------------------------------------------------\nstruct SpriteData\n{\n    vec3    center;\n    vec2    size;\n};\n\nstruct LightData\n{\n    vec3    center;\n    vec3    size;\n};\n\nvec3    draw_background     (in vec2 fragment_uvs);\nvec4    draw_sprite         (in SpriteData sprite, in vec2 fragment_uvs, in LightData light);\nvec3    mix_colors          (in vec3 destination, in vec4 source);\nbool    is_inside           (in vec2 point, in vec2 min, in vec2 max);\nvec4    sample_light        (in vec2 light_uvs);\nvec4    sample_sprite       (in vec2 sprite_uvs);\n\nconst SpriteData    sprite_0            = SpriteData(vec3(0.5, 0.5 , 0.9), vec2(0.8 , 0.3)       );\nconst SpriteData    sprite_1            = SpriteData(vec3(0.2, 0.5 , 0.8), vec2(0.1 , 0.6) * 0.6 );\nconst SpriteData    sprite_2            = SpriteData(vec3(0.4, 0.45, 0.8), vec2(0.08, 0.5) * 0.6 );\nconst SpriteData    sprite_3            = SpriteData(vec3(0.6, 0.55, 0.8), vec2(0.05, 0.7) * 0.6 );\nconst SpriteData    sprite_4            = SpriteData(vec3(0.8, 0.5 , 0.8), vec2(0.11, 0.6) * 0.6 );\nconst SpriteData    sprite_5            = SpriteData(vec3(0.1, 0.4 , 0.2), vec2(0.1 , 0.6)       );\nconst SpriteData    sprite_6            = SpriteData(vec3(0.3, 0.35, 0.2), vec2(0.08, 0.5)       );\nconst SpriteData    sprite_7            = SpriteData(vec3(0.5, 0.45, 0.2), vec2(0.05, 0.7)       );\nconst SpriteData    sprite_8            = SpriteData(vec3(0.7, 0.4 , 0.2), vec2(0.11, 0.6)       );\nconst SpriteData    sprite_9            = SpriteData(vec3(0.9, 0.3 , 0.2), vec2(0.1 , 0.4)       );\n\nconst vec3          ambient_color       = vec3(0.1, 0.1, 0.2);\n\n//-------------------------------------------------------------\n//-------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LightData           light               = LightData( vec3(0.6, 0.5, 0.5 + sin(iTime * 0.3) * 0.3), vec3(0.4 , 0.4, 0.4));\n    SpriteData          sprite_character    = SpriteData(vec3(0.6 + sin(iTime * 0.4) * 0.2, 0.5, 0.5), vec2(0.1 , 0.2)     );\n\n    vec2                fragment_uvs        = fragCoord.xy / iResolution.xy;\n    vec3                final_color         = draw_background(fragment_uvs);\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_0        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_1        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_2        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_3        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_4        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_character, fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_5        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_6        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_7        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_8        , fragment_uvs, light));\n    final_color                             = mix_colors(final_color, draw_sprite(sprite_9        , fragment_uvs, light));\n\n    fragColor                               = vec4(final_color, 1.0);\n}\n\n//-------------------------------------------------------------\nvec3 draw_background(in vec2 fragment_uvs)\n{\n    return texture(iChannel0, fragment_uvs * 4.0).xyz * ambient_color;\n}\n\n//-------------------------------------------------------------\nvec4 draw_sprite(in SpriteData sprite, in vec2 fragment_uvs, in LightData light)\n{\n    vec2    sprite_min      = sprite.center.xy - sprite.size * 0.5;\n    vec2    sprite_max      = sprite_min + sprite.size;\n    if(is_inside(fragment_uvs, sprite_min, sprite_max) == false)\n    {\n        return vec4(0.0);\n    }\n\n    vec3    position        = vec3(fragment_uvs, sprite.center.z);      // note : change this if the world space doesn't match the screen space anymore or if you need a camera.\n    vec2    uvs             = ((position.xy - sprite.center.xy) / sprite.size.xy) + vec2(0.5);\n\n    vec2    light_uvs       = ((position.xy - light.center.xy) / light.size.xy) + vec2(0.5);\n    vec4    light_sample    = sample_light(light_uvs);\n    vec3    light_color     = light_sample.xyz;\n    float   light_intensity = (1.0 - min(abs(position.z - light.center.z) / (light.size.z * 0.5), 1.0)) * light_sample.a;\n\n    vec4    sprite_sample   = sample_sprite(uvs);\n\n    vec3    final_color     = sprite_sample.xyz * clamp(ambient_color + light_color * light_intensity, 0.0, 1.0);\n    return vec4(final_color, sprite_sample.a);\n}\n\n//-------------------------------------------------------------\nvec3 mix_colors(in vec3 destination, in vec4 source)\n{\n    return mix(destination, source.xyz, source.w);\n}\n\n//-------------------------------------------------------------\nbool is_inside(in vec2 point, in vec2 min, in vec2 max)\n{\n    return (   (point.x >= min.x) && (point.x <= max.x)\n            && (point.y >= min.y) && (point.y <= max.y) );\n}\n\n//-------------------------------------------------------------\nvec4 sample_light(in vec2 light_uvs)\n{\n    float   distance    = length(light_uvs * 2.0 - vec2(1.0));\n    return vec4(1.0, 1.0, 1.0, 1.0 - min(distance * 1.4 - 0.4, 1.0));\n}\n\n//-------------------------------------------------------------\nvec4 sample_sprite(in vec2 sprite_uvs)\n{\n    return vec4(texture(iChannel1, sprite_uvs).xyz, min(texture(iChannel2, sprite_uvs).z * 4.0, 1.0));\n}\n","name":"","description":"","type":"image"}]}