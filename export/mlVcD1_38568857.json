{"ver":"0.1","info":{"id":"mlVcD1","date":"1700200017","viewed":145,"name":"Copper chainmail - movement","username":"berelium","description":"\"Combining raymarching and pathtracing to render a simple chainmail pattern.\"\nForked from https://www.shadertoy.com/view/3dyBWh.\n\nTried applying some basic camera movement for fun... at a loss of specified quality.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Copper chainmail\" by athibaul. https://shadertoy.com/view/3dyBWh\n// 2023-11-17 05:35:30\n\n// COPPER CHAINMAIL\n\n// Combining raymarching and pathtracing to render a simple chainmail pattern.\n\n// Fork of my shader \"European 4 in 1 chainmail weave\"\n// https://www.shadertoy.com/view/tdVfWz\n\n// Render is done in Buffer A.\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{\n    col = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    \n    // Vignette\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.xy;\n    col *= smoothstep(2.0,0.7,length(uv));\n    \n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col *= 1.8;\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    col.rgb = pow(col.rgb, vec3(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash function adapted from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx)-0.5;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define R(th) mat2(cos(th),sin(th),-sin(th),cos(th))\n#define rgb(r,g,b) pow(vec3(r,g,b)/255., vec3(2.2))\n\nfloat dTorus(vec3 p, float r_large, float r_small)\n{\n    // Calculate distance to torus\n    float h = length(p.xy) - r_large;\n    float d = sqrt(h*h + p.z*p.z) - r_small;\n    return d;\n}\n\nfloat torusGrid(vec3 p, float r_small, float r_large, float angle, vec2 sep)\n{\n    // Create a grid of tori through domain repetition\n    vec3 q = p - vec3(round(p.xy/sep)*sep,0) - vec3(0,sep.y/2.,0);\n    q.yz *= R(angle);\n    float d = dTorus(q, r_large, r_small);\n    q = p - vec3(round(p.xy/sep)*sep,0) - vec3(0,-sep.y/2.,0);\n    q.yz *= R(angle);\n    d = min(d, dTorus(q, r_large, r_small));\n    return d;\n}\n\nfloat material = 0.;\nfloat map(vec3 p)\n{\n    // Warp space\n    p.x += 0.5*cos(0.2*p.y);\n    p.y += 0.3*cos(0.3*p.x);\n    p.z += 0.3*sin(0.3*p.y+0.2*p.x);\n    \n    // Weave is a combination of two regular grids of tori\n    material = 0.;\n    float angle = 0.3;\n    vec2 sep = vec2(1,0.8);\n    float d = torusGrid(p, 0.07, 0.4, angle, sep);\n    d = min(d, torusGrid(p-vec3(sep/2.,0), 0.07, 0.4, -angle, sep));\n    \n    // Plane below\n    vec3 p2 = 12.3*p;\n    p2.yz *= R(0.7);\n    p2.xz *= R(-0.7);\n    vec2 q = p2.xy-round(p2.xy);\n    float bump = dot(q,q) * 0.005;\n    float d2 = p.z+0.15+bump;\n    if(d2<d){ material = 1.; d = d2; }\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    // Tetrahedral normal calculation\n    // See https://iquilezles.org/articles/normalsSDF\n    vec2 e = 0.001 * vec2(1,-1);\n    return normalize(\n        e.xxx*map(p+e.xxx)\n       +e.xyy*map(p+e.xyy)\n       +e.yxy*map(p+e.yxy)\n       +e.yyx*map(p+e.yyx));\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    // Standard raymarching loop\n    float d, t=0.;\n    for(int i=0;i<100;i++)\n    {\n        d = map(ro+t*rd);\n        if(d<0.001 || t>100.) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float spNum)\n{\n    // Simple pathtracing routine: bounce the ray until it exits the scene\n   \tvec3 transmittance = vec3(1);\n    int BOUNCES=8;\n    int i;\n    for(i=0; i<BOUNCES; i++)\n    {\n        float t = raymarch(ro, rd);\n        if(t > 100.) break;\n        float mat = material;\n        vec3 p = ro+t*rd;\n        vec3 n = normal(p);\n        \n        // Material properties\n        // Differentiate between copper color / floor color\n        float noise = (sin(p.x*18.)+cos(p.y*12.)+cos(p.x-p.y));\n        vec3 f0 = vec3(0.6,0.3,0.2) + 0.2*smoothstep(-0.5,0.5,noise);\n       \t#if 1\n        vec3 floorCol = rgb(63,138,125);\n        #else\n        vec3 floorCol = vec3(0.2,0.3,0.6);\n        #endif\n        f0 = mat==0. ? f0 : floorCol;\n        vec3 fre = f0 + (1.-f0)*pow(clamp(1.+dot(rd,n),0.,1.),5.);\n        \n        // Bounce ray\n        transmittance *= fre;\n        rd = reflect(rd, n);\n        float roughness = mat==0. ? 0.3 : 0.9;\n        rd = normalize(rd + roughness*hash33(p*1000.+spNum));\n        ro = p+0.01*n;\n    }\n    if(i>=BOUNCES) return vec3(0);\n    \n    // Use a dome to light the scene. Half the dome is occluded.\n    vec3 skyColor = pow(textureLod(iChannel0, rd.xzy, 0.).rgb, vec3(2.2));\n    skyColor *= step(0., -rd.x+rd.y);\n    return transmittance * skyColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Place camera\n    \n    int convergeTime = 30;   // Interval on which to force converge and wipe old frames\n    float framesKept = 0.90; // Percent of frames kept\n    float t = 0.075 * iTime; // Local time to move cam\n    vec3 ro = vec3(2,-1. * t, 2);\n    \n    vec3 camFwd = normalize(-ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    \n    float renderedFrames = texelFetch(iChannel1, ivec2(0,1), 0).a + 1.;\n    // Jitter ray direction for antialiasing\n    vec2 jitter = 0.5 * sin(vec2(1,1.62)*renderedFrames);\n    vec2 uv = ((fragCoord+jitter)*2.-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(camFwd + 0.5*(camRight*uv.x + camUp*uv.y));\n    \n    // Calculate ray color\n    vec3 col = shade(ro,rd,float(iFrame));\n   \n    // Check for resolution change\n    float oldRes = texelFetch(iChannel1, ivec2(0,0), 0).a;\n    if(iFrame > 0 && iResolution.x == oldRes)\n    {\n        // Accumulate color\n        vec3 oldCol = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n        col = mix(oldCol, col, 1./float(renderedFrames));\n    }\n    else\n    {\n        // On resolution change, reset the accumulation\n        renderedFrames = 0.;\n    }\n    \n    // Check if frame is on a converge time interval\n    if(iFrame % convergeTime == 0) {\n        renderedFrames = float(convergeTime) * framesKept; // keep some frames based on the converge time\n    }\n    \n    fragColor = vec4(col,1.0);\n    \n    if(ivec2(fragCoord) == ivec2(0,0))\n        fragColor.a = iResolution.x;\n    if(ivec2(fragCoord) == ivec2(0,1))\n        fragColor.a = renderedFrames;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}