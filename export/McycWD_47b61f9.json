{"ver":"0.1","info":{"id":"McycWD","date":"1731871396","viewed":36,"name":"Room with Crystal","username":"uk0141","description":"Classic GLSL Graphics @ SESSIONS 2024","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","reflection","refraction","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define lightPos vec3(3., 0., 0.)\nmat2 rot(float t){return mat2(cos(t), sin(t), -sin(t), cos(t));}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(12.9898, 78.233)))*43758.5453123);}\nfloat noise(vec2 uv){\n    vec2 f = fract(uv);\n\tvec2 i = floor(uv);\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1., 0.));\n\tfloat c = hash(i + vec2(0., 1.));\n\tfloat d = hash(i + vec2(1., 1.));\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\nvec2 intersect(vec3 p){\n    vec2 res = vec2(-1., 20.);\n\tvec2 obj;\n\tvec3 p_o = p;\n\n\tfloat sdBox;\n\tp.y = abs(p.y);\n\tvec3 q = abs(p-vec3(0., 4., 0.))-vec3(5., .01, 5.);\n\tsdBox = length(max(q, 0.)+min(max(q.x, max(q.y, q.z)), 0.));\n\tobj = vec2(1.1, sdBox);\n\tif(obj.y < res.y)res = obj;\n\n\tp = p_o;\n\tp.x = abs(p.x);\n\tq = abs(p-vec3(5., 0., 0.))-vec3(.01, 4., 5.);\n\tsdBox = length(max(q, 0.)+min(max(q.x, max(q.y, q.z)), 0.));\n\tobj = vec2(1.2, sdBox);\n\tif(obj.y < res.y)res = obj;\n\n\t\n\tp = p_o;\n\tp.z = abs(p.z);\n\tq = abs(p-vec3(0., 0., 5.))-vec3(5., 4., .2);\n\tsdBox = length(max(q, 0.)+min(max(q.x, max(q.y, q.z)), 0.));\n\tobj = vec2(1.3, sdBox);\n\tif(obj.y < res.y)res = obj;\n\t\n\n\tp = p_o;\n\tp = abs(p)-.2;\n\tp.xy = rot(.4)*p.xy;\n\tp = abs(p)-1.;//-1.\n\tp.yz = rot(.4)*p.yz;\n\n\tp.xz = rot(iTime/10.)*p.xz;\n\n\tq = abs(p-vec3(0., 0., 0.))-vec3(1.);\n\tsdBox = length(max(q, 0.))-length(min(max(q.x, max(q.y, q.z)), 0.))-.12;\n\tobj = vec2(1., sdBox);\n\tif(obj.y < res.y)res = obj;\n\n\treturn res;\n}\nvec2 rayMarch(vec3 ro, vec3 rd){\n\tvec2 res = vec2(-1., 20.);\n\tfloat t = 0.;\n\tvec3 ray;\n\tfor(float i = 0.;i < 200.;i++){\n\t\tray = ro + rd*t;\n\t\tvec2 obj = intersect(ray);\n\t\tif(abs(obj.y) < .01){\n\t\t\tres = obj;\n\t\t\tbreak;\n\t\t}\n\t\tif(t > 20.)break;\n\t\tt += abs(obj.y)*.5;\n\t}\n\treturn vec2(res.x, t);\n}\nvec3 getNor(vec3 p){\n\tvec2 e = vec2(0., 0.001);\n\treturn normalize(vec3(\n\t\t\t\tintersect(p+e.yxx).y - intersect(p-e.yxx).y,\n\t\t\t\tintersect(p+e.xyx).y - intersect(p-e.xyx).y,\n\t\t\t\tintersect(p+e.xxy).y - intersect(p-e.xxy).y\n\t\t\t\t));\n}\nvec3 sideWallCol(vec3 p, bool light){\n\tvec3 col;\n\tvec3 mate = vec3(step(hash(floor(p.yz*2.)+floor(iTime)), .5));\n\tmate = light?mate:mate*.03;\n\tvec3 nor = getNor(p);\n\tfloat diff = clamp(dot(normalize(lightPos-p), nor), 0., 1.);\n\tcol = mate*diff;\n\treturn col;\n}\nvec3 wallCol(vec3 p, bool light){\n\tvec3 col;\n\tvec3 mate = fract(p.x*.1+iTime/10.)<.5?vec3(1.):vec3(0.);\n\tmate = light?mate:mate*.03;\n\tvec3 nor = getNor(p);\n\tfloat diff = clamp(dot(normalize(lightPos-p), nor), 0., 1.);\n\tcol = mate*diff;\n\treturn col;\n}\nvec3 floorCol(vec3 p, bool light){\n\tvec3 col;\n\tvec3 mate = fract(p.z+iTime/10.)<.5?vec3(1.):vec3(0.);\n\tmate = light?mate:mate*.03;\n\tvec3 nor = getNor(p);\n\tfloat diff = clamp(dot(normalize(lightPos-p), nor), 0., 1.);\n\tcol = mate*diff;\n\treturn col;\n}\n\nvec3 lightCol(vec3 p){\n\treturn vec3(1.);\n}\nvec3 colHub(float id, vec3 hitPos, bool light){\n\tvec3 col = vec3(0.);\n\tif(id == 1.1)col = floorCol(hitPos, light);\n\telse if(id == 1.2)col = sideWallCol(hitPos, light);\n\telse if(id == 1.3)col = wallCol(hitPos, light);\n\n\treturn col;\n}\n\nvec3 prismCol(vec3 p, vec3 rd, bool light, vec3 baseCol){\n\tvec3 col = vec3(0.);\n\tvec3 norIn = getNor(p);\n\n\t//surface reflection\n\tvec3 rdRefl = reflect(rd, norIn);\n\tvec2 obj = rayMarch(p+norIn*.5, rdRefl);\n\tvec3 reflCol = colHub(obj.x, p + rdRefl*obj.y, light);\n\tfloat diff = .2-clamp(dot(rd, norIn), 0., .2);\n\n\t//refraction\n\tvec3 rdIn = refract(rd, norIn, 1./1.45);\n\tvec3 roIn = p - norIn*.02;\n\n\tobj = rayMarch(roIn, rdIn);\n\tvec3 inPos = roIn + rdIn*obj.y;\n\tvec3 norOut = getNor(inPos);\n\n\t//inside reflection & refraction\n\tvec3 rdOut = refract(rdIn, -norOut, 1.45);\n\tvec3 roOut = inPos + norOut*.02;\n\tif(length(rdOut) == 0.){\n\t\trdOut = reflect(rdIn, -norOut);\n\t\tvec3 inPos2 = inPos + rdOut*rayMarch(inPos, rdOut).y;\n\t\troOut = inPos2 + rdOut*2.;\n\t}\n\n\tobj = rayMarch(roOut, rdOut);\n\tvec3 hitPos = roOut + rdOut*obj.y;\n\tcol = colHub(obj.x, hitPos, light);\n\n\tcol = baseCol*col;\n\treturn col*.5 + reflCol*diff;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n\n\tvec3 ray;\n\tvec3 ro = fract(iTime/12.)<.5?vec3(0., -2., 4.5):vec3(0., 0., 4.5);\n\tro.xz = rot(iTime*.1)*ro.xz;\n\tvec3 rd = normalize(vec3(p, -1.));\n\trd.yz = fract(iTime/12.)<.5?rot(radians(20.))*rd.yz:rot(radians(0.))*rd.yz;\n\trd.xz = rot(iTime*.1)*rd.xz;\n\tfloat t = 0.;\n\tvec3 col = vec3(0.);\n\tvec2 obj = rayMarch(ro, rd);\n\tray = ro + rd*obj.y;\n\tfloat tcycle = fract(iTime/12.);\n\tbool light = tcycle< .95?true:tcycle<.97?mod(floor(tcycle*400.),2.)==0.?true:false:false;\n\tvec3 baseCol[4];\n\tbaseCol[3] = vec3(1.);\t\n\tbaseCol[0] = vec3(1., .2, 0.);\n\tbaseCol[1] = vec3(0., .2, 1.);\n\tbaseCol[2] = vec3(1., .8, .1);\t\n\tint colIndex = int(mod(floor(iTime/12.), 4.));\n\tif(obj.x != -1.){\n\t\tif(obj.x == 1.1)col = floorCol(ray, light);\n\t\telse if(obj.x == 1.2)col = sideWallCol(ray, light);\n\t\telse if(obj.x == 1.)col = prismCol(ray, rd, light, baseCol[colIndex]);\n\t\telse if(obj.x == 1.3)col = wallCol(ray, light);\n\t}\n\tcol = pow(col, vec3(.4545));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}