{"ver":"0.1","info":{"id":"Nt2Gz3","date":"1624384670","viewed":383,"name":"MurmurHash vs Hash without Sine","username":"TheTurk","description":"Quick comparison between MurmurHash ([url]https://www.shadertoy.com/view/stjGRR[/url]) and Hash without Sine (right). Hash without Sine produces good results most of the time but can also produce very bad results from time to time.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","sin","random","sine","fract","hash","whitenoise","murmur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector. The vector is hashed by simply treating as a \n// sequence of bytes. MurmurHash is the natural choice for this task because it works \n// on 4 byte sequences which happens to be also the length of the uint data type.\n\nuint murmurHash(uvec2 x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hashWithoutSine(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    fragCoord  *= 1.0 + mod(round(iTime), 100.0);\n    float value;\n    if (position.x < 0.0) {\n        uint seed = 0x578437adU; // can be set to something else if you want a different set of random values\n        uint hashValue = murmurHash(uvec2(uint(fragCoord.x), uint(fragCoord.y)), seed); \n        value = float(hashValue) / float(0xffffffffU); // convert to float in range [0, 1]\n    } else {\n        value = hashWithoutSine(fragCoord);\n    }\n    vec3 color = vec3(value);\n    color *= smoothstep(0.0, 3.0, (abs(position.x) - 0.004) * iResolution.y);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}