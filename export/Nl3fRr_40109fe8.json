{"ver":"0.1","info":{"id":"Nl3fRr","date":"1662757644","viewed":454,"name":"GGX: BRDF vs importance sampling","username":"stduhpf","description":"Trying to understand BRDFs \nLeft is ufiform sampling on the light source area, right is using importance sampling\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["specular","importancesampling","montecarlo","ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sources:\n// https://hal.archives-ouvertes.fr/hal-01509746/document\n// https://hal.inria.fr/hal-00996995v2/document\n// https://jcgt.org/published/0007/04/01/\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// and some more I didn't keep track of\n\nvec4 ntexture(sampler2D s , vec2 uv){\n    vec4 c = texture(s,uv);\n    return c/c.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.x>0.?iMouse.xy:vec2(0.,iResolution.y*.5);\n\n    vec4 col = fragCoord.x>m.x?\n        (fragCoord.y<m.y?texture(iChannel0,uv):texture(iChannel1,uv)):\n        (fragCoord.y<m.y? //diff\n            vec4(ntexture(iChannel0,uv).rgb-ntexture(iChannel0,fract(uv+vec2(.5,0.))).rgb,1.):\n            vec4(ntexture(iChannel1,uv).rgb-ntexture(iChannel1,fract(uv+vec2(.5,0.))).rgb,1.)\n        );\n    \n    // superposition\n    // col = ntexture(iChannel0,uv)+3.*ntexture(iChannel1,fract(uv+vec2(.5,0.)));\n\n    fragColor = vec4(pow(col.rgb/col.a,vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*(fragCoord)-iResolution.xy)/iResolution.x;\n\n    vec3 ro = vec3(0.,0.,-2.25);\n    vec3 rd = normalize(vec3(uv-vec2(sign(uv.x)*.5,0.),1.));//vec3(uv,sqrt(1.-dot(uv,uv)));\n\n    //vec3 ld = normalize(vec3(0.,1.5,2.+sin(iTime)));\n    \n    vec4 noise = texture(iChannel1,fragCoord/iChannelResolution[1].xy);\n    vec2 dithering = (noise.rg*255.+noise.ba)/256.;\n    \n    vec4 i = iSphere(vec3(0),1.,ro,rd);\n    if(i.a>10.){\n        fragColor = pow(texture(iChannel2,rd),vec4(2.2));\n        return;\n    }\n    vec3 p = ro+rd*i.a;\n    vec3 n = normalize(p);\n    float r = getRoughness(p,iChannel3);\n    r*=r;\n    fragColor = .9998*texture(iChannel0,fragCoord/iResolution.xy);\n    if(uv.x>0.){\n        importanceSampling(true, fragColor,n,rd,vec3(0),r,dithering,iChannel2,iFrame);\n    }else{\n        vec3 ld = hspherePoint(n, dithering, iFrame);\n        directLightSampling(true,fragColor,n,rd,ld, TAU,r,dithering,iChannel2,iFrame);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ld = normalize(vec3(-1,1.,-1.));\n\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*(fragCoord)-iResolution.xy)/iResolution.x;\n\n    vec3 ro = vec3(0.,0.,-2.25);\n    vec3 rd = normalize(vec3(uv-vec2(sign(uv.x)*.5,0.),1.));//vec3(uv,sqrt(1.-dot(uv,uv)));\n\n    //vec3 ld = normalize(vec3(0.,1.5,2.+sin(iTime)));\n    \n    vec4 noise = texture(iChannel1,fragCoord/iChannelResolution[1].xy);\n    vec2 dithering = (noise.rg*255.+noise.ba)/256.;\n    \n    vec4 i = iSphere(vec3(0),1.,ro,rd);\n    if(i.a>10.){\n        fragColor = vec4(vec3(lightsourceBrightness)*step(acos(dot(rd,ld)),lightsourceSize),1.);\n        return;\n    }\n    vec3 p = ro+rd*i.a;\n\n    vec3 n = normalize(p);\n    float r = getRoughness(p, iChannel3);\n    r*=r;\n    fragColor = .9998*texture(iChannel0, fragCoord/iResolution.xy);\n    if(uv.x>0.){\n        importanceSampling(false, fragColor, n, rd, ld, r, dithering, iChannel2, iFrame);\n    }else{\n\n        vec3 ld = sphereCapPoint(ld, lightsourceSize, dithering, iFrame); //sample point on the lightsource\n\n        float samplingMeasure = 2.*PI*(1.-cos(lightsourceSize)); //area of sampling sphere cap\n\n        directLightSampling(false, fragColor, n, rd, ld, samplingMeasure, r, dithering, iChannel2, iFrame);\n\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float lightsourceSize = 20.*.009250245; //in radians (default = 20x the size of the sun)\nconst float lightsourceBrightness = 1000./(20.*20.);\n\n\nconst float PI = acos(-1.);\nconst float TAU = PI+PI;\n\nmat3 getBasis(vec3 nor){\n    bool t = 1.-abs(nor.z)>.00001;\n    if(!t)\n        nor=nor.zxy;\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    return t?mat3(uu,vv,nor):mat3(uu.yzx,vv.yzx,nor.yzx);\n}\n\nvec4 iSphere(vec3 sp, float sr,vec3 ro, vec3 rd) //intersection entre une sphere et un rayon\n{\n    vec3 p = sp-ro;\n    float d = dot(-rd,p);\n    float i = d*d- dot(p,p)+sr*sr;\n    d = i>0.?-sqrt(i)-d:-1000.;\n    if(d<0.)\n        i=-abs(i);\n\treturn vec4(normalize(rd*d-p),i>0.?d:1e6); //renvoie le vecteur normal au point d'intersection et la distance\n}\t\t\t\t\t\t\t\t\t//1e6 est un nombre tres grand\n\n\nfloat ggxMaskingShadowing(vec3 n, vec3 d, vec3 l, float a){\n    a*=a;\n    float dotNL = dot(n,l);\n    float dotND = dot(n,d);\n    float denomA = dotNL * sqrt(a + (1.0f - a) * dotND * dotND);\n    float denomB = dotND * sqrt(a + (1.0f - a) * dotNL * dotNL);\n\n    return 2.0f * dotND * dotNL / (denomA + denomB);\n}\n\nfloat ggxMasking(vec3 n, vec3 l, float a){\n    a*=a;\n    float dotNL = dot(n,l);\n    float denom = sqrt((1.-a) + a/(dotNL*dotNL));\n\n    return 2.0f / (1.+denom);\n}\n\nfloat D_GGX_A(vec3 n, const vec3 h, float at, float ab) { //anisotropic\n    vec3 hh = inverse(getBasis(n))*h; //should probably be precomputed\n    float d = hh.z;\n    float ToH = hh.x;\n    float BoH = hh.y;\n    float a2 = at * ab;\n    vec3 v = vec3(ab * ToH, at * BoH, a2 * d);\n    float v2 = dot(v, v);\n    float w2 = a2 / v2;\n    return a2 * w2 * w2 * (1.0 / PI);\n}\n\n\nfloat ggx(vec3 n, vec3 h, float a){\n    //return D_GGX_A(n,h,a,a); \n    float d = dot(n,h);\n    a = a*a;\n    float w = (d*d*(a-1.)+1.);\n    return a/(PI*w*w);\n}\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// https://hal.archives-ouvertes.fr/hal-01509746/document\nvec3 sampleGGXVNDF(vec3 V_, float at, float ab, float U1, float U2)\n{\n    // stretch view\n    vec3 V = normalize(vec3(at * V_.x, ab * V_.y, V_.z));\n    // orthonormal basis\n    vec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0,0,1))) : vec3(1,0,0);\n    vec3 T2 = cross(T1, V);\n    // sample point with polar coordinates (r, phi)\n    float a = 1.0 / (1.0 + V.z);\n    float r = sqrt(U1);\n    float phi = (U2<a) ? U2/a * PI : PI + (U2-a)/(1.0-a) * PI;\n    float P1 = r*cos(phi);\n    float P2 = r*sin(phi)*((U2<a) ? 1.0 : V.z);\n    // compute normal\n    vec3 N = P1*T1 + P2*T2 + sqrt(max(0.0, 1.0 - P1*P1 - P2*P2))*V;\n    // unstretch\n    N = normalize(vec3(at*N.x, ab*N.y, max(0.0, N.z)));\n    return N;\n}\n\nvec3 h_sampleGGXVNDF(vec3 n,vec3 v, float a, vec2 seed, int iFrame){\n    const float phi2=1.32471795724474602596090885447809734; //root of X^3-X-1=0.\n\tconst float phi2sq=phi2*phi2;\n    vec2 hash = fract(seed + fract(.5+float(iFrame)/vec2(phi2sq,phi2)));\n    \n    mat3 b =  getBasis(n);\n    return getBasis(n)*sampleGGXVNDF(inverse(b)*v,a,a,hash.x,hash.y);\n}\n\n//I forgot where I fond the formulas for this one, sorry\nvec3 ggxSample(vec3 n,float r, vec2 seed, int iFrame){\n    const float phi2=1.32471795724474602596090885447809734; //root of X^3-X-1=0.\n\tconst float phi2sq=phi2*phi2;\n    vec2 hash = fract(seed + fract(.5+float(iFrame)/vec2(phi2sq,phi2)));\n    \n    float e0 = hash.x;\n    float t = acos(sqrt((1.-e0)/((r*r-1.)*e0+1.))); //acos makes this pretty slow\n    float p = hash.y*TAU;\n    \n    vec3 h = getBasis(n)*vec3(sin(t)*vec2(cos(p),sin(p)),cos(t));    \n\n    return h;\n}\n\nvec3 spherePoint(vec2 seed, int iFrame){\n    const float phi2=1.32471795724474602596090885447809734; //root of X^3-X-1=0.\n\tconst float phi2sq=phi2*phi2;\n    vec2 h = fract(.5+float(iFrame)/vec2(phi2sq,phi2));\n    \n    vec2 uv = fract(seed+h);\n    \n    float theta = TAU * uv.x;\n    uv.y = 2. *uv.y - 1.;\n    return vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n}\n\nvec3 hspherePoint(vec3 n,vec2 seed, int iFrame){\n    vec3 p = spherePoint(seed, iFrame); \n    return p*sign(dot(n,p));\n}\n\nvec3 sphereCapPoint(vec3 n, float a, vec2 seed, int iFrame){\n    const float phi2=1.32471795724474602596090885447809734; //root of X^3-X-1=0.\n\tconst float phi2sq=phi2*phi2;\n    vec2 h = fract(seed + fract(.5+float(iFrame)/vec2(phi2sq,phi2)));\n    h.x=acos(1.-h.x*(1.-cos(a)));\n    h.y*=2.*PI;\n    \n    //conversion to cartesian space\n    return getBasis(n)*vec3(sin(h.x)*vec2(cos(h.y),sin(h.y)),cos(h.x));\n}\n\nfloat cook_Torrence(vec3 n,vec3 v,vec3 l,float r){\n    vec3 h = normalize(v+l);\n    //if(dot(h,n)<0.||dot(l,n)<0.)return 0.;\n    float fres = 1.;\n    return fres*ggx(n,h,r)*ggxMaskingShadowing(n,v,l,r)/(4.*dot(n,l)*dot(n,v)) ;\n}\n\nfloat getRoughness(vec3 p, sampler2D t){\n    return .2+.4*texture(t,(p.xy)).r;//sin(p.y*40.)*0.1+.3;\n}\n\n\n\n// the two sampling methods :\n// useCubemap determines wether we want IBL or a surface lightsource\n\nvoid importanceSampling(bool useCubemap, inout vec4 fragColor, vec3 n, vec3 rd, vec3 ld, float r, vec2 dithering, samplerCube cubemap, int iFrame )\n{\n    //converges faster for IBL / Raytracing, doesn't work for point lightsources\n    //works very well for low roughness\n    \n    //vec3 h = ggxSample(n,r,dithering, iFrame);\n    vec3 h = h_sampleGGXVNDF(n,-rd,r,dithering,iFrame);\n    vec3 dir = reflect(rd,h);\n    if(dot(dir,n)>=0.){ //ignore sample if reflected vector intersects sphere\n        vec3 tx = useCubemap?\n            pow(texture(cubemap,dir).rgb,vec3(2.2)):\n            vec3(lightsourceBrightness)*step(acos(dot(dir,ld)),lightsourceSize);\n        float l = ggxMasking(n,dir,r);\n        fragColor += vec4(tx*l,1.);\n    }else{\n        // for some reason, just dropping the sample for intersecting reflections don't match the BRDF\n        // so i add black instead, which fixes it\n        // Wich boggles my mind, because it seems that this would make some energy dissapear, right?\n        // my intuition would be that it gets a second chance at reflecting off the surface\n        // with h = h_sampleGGXVNDF(n, -dir, r,dithering,iFrame);\n        // So either my intuition is wrong, or something is missing from my BRDF implementation\n        fragColor += vec4(0.,0.,0.,1.);\n    }\n}\n\nvoid directLightSampling(bool useCubemap, inout vec4 fragColor, vec3 n, vec3 rd,vec3 ld, float samplingMeasure, float r, vec2 dithering, samplerCube cubemap, int iFrame ){\n    //converges faster for small lightsources (works even for point lightsources)\n    //srtuggles at low roughness, useless for perfectly polished surfaces\n    \n    vec3 tx = useCubemap?\n        pow(texture(cubemap,ld).rgb,vec3(2.2)):\n        vec3(lightsourceBrightness); //only the lightsouce is sampled anyways, no need for the step()\n\n    float l = max(cook_Torrence(n,-rd,ld,r),0.);\n    vec3 c = (tx*l*max(dot(n,ld),0.));\n    fragColor += vec4(c*samplingMeasure,1.);\n}","name":"Common","description":"","type":"common"}]}