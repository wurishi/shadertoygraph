{"ver":"0.1","info":{"id":"4dcyRn","date":"1517685949","viewed":114,"name":"reflectiondemo","username":"inantop","description":"reflections","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 perspective(float fovy, float aspect, float near, float far)\n{\n\tmat4 result;\n    float rad = fovy * 3.14159265 / 180.0;\n    float tanHalfFovy = tan(rad / 2.0);\n    result[0][0] = 1.0 / (aspect * tanHalfFovy);\n    result[1][1] = 1.0 / tanHalfFovy;\n    result[2][2] = - (far + near) / (far - near);\n    result[2][3] = - 1.0;\n    result[3][2] = - (2.0 * far * near) / (far - near);\n    return result;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    mat4 Result = mat4(1.0);\n    \n    vec3  f = normalize(center - eye);\n    vec3  u = normalize(up);\n    vec3  s = normalize(cross(f, u));\n    \n    u = cross(s, f);\n    Result[0][0] = s.x;\n    Result[1][0] = s.y;\n    Result[2][0] = s.z;\n    Result[0][1] = u.x;\n    Result[1][1] = u.y;\n    Result[2][1] = u.z;\n    Result[0][2] =-f.x;\n    Result[1][2] =-f.y;\n    Result[2][2] =-f.z;\n    Result[3][0] =-dot(s, eye);\n    Result[3][1] =-dot(u, eye);\n    Result[3][2] = dot(f, eye);\n    return Result;   \n}\n\n\n\nvec3 unproject(vec3 win, mat4 mvp, vec4 vp)\n{\n    mat4 inv = inverse(mvp);\n\n    vec4 tmp = vec4(win, 1.0);\n    tmp.x = (tmp.x - vp.x) / vp.z;\n    tmp.y = (tmp.y - vp.y) / vp.w;\n    tmp.x = tmp.x * 2.0 - 1.0;\n    tmp.y = tmp.y * 2.0 - 1.0;\n\n    vec4 obj = inv * tmp;\n    obj /= obj.w;\n\n    return vec3(obj);\n}\n\n/* Rays */\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere\n{\n    vec3 position;\n\tfloat radius;\n    vec3 color;\n};\n\nfloat RaySphereDistance(in Ray ray, in Sphere sphere, out vec3 collision)\n{\n    vec3 p = ray.origin;\n    vec3 d = ray.direction;\n    \n    vec3 s = sphere.position;\n    float r = sphere.radius;\n    vec3 v = s - p;\n    \n    //Compute distance from sphere center to ray\n    vec3 c = cross(s - p, d);\n    float dist = length(c);\n    \n    if(dot(v,d) > 0.0)\n    {\n        //Sphere is in front of ray        \n        if (dist < r)\n        {\n            //The distance from the center to the point on the ray is \"dist\"\n            //The distance from the point on the ray to the surface of the sphere is \"x\"\n            //The distance from the center to the surface of the sphere is \"r\"\n            //These form a right triangle\n            float x = sqrt(r * r - dist * dist);\n            \n            //The collision is a point on the ray \"x\" distance back toward the origin.            \n            vec3 pointOnRayClosestToSphereCenter = p + dot(v,d) * d;\n            collision = pointOnRayClosestToSphereCenter - (d * x);\n        }\n    }\n\n    //Sphere is behind ray\n    return dist;   \n}\n\nvec3 ScreenToWorld(in vec3 screen)\n{\n    mat4 p = perspective(45.0f, iResolution.x / iResolution.y, 0.01, 1000.0);\n    \n    vec3 eye = vec3(0.0, sin(iTime) * 2. + 3., 5.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 v = lookAt(eye, center, up);\n    return unproject(screen, p * v, vec4(0.0, 0.0, iResolution.x, iResolution.y));\n}\n\nvec4 GetSphereContribution(in Ray worldRay, in Sphere s, out Ray newWorldRay)\n{\n    vec3 collision;\n\tfloat dist = RaySphereDistance(worldRay, s, collision);   \n    if (dist < s.radius)\n    {\n        vec3 normal = normalize(collision);\n        vec3 l = normalize(worldRay.origin - collision);\n        \n        newWorldRay.origin = collision;\n        newWorldRay.direction = reflect(worldRay.direction, normal);\n        \n        return vec4(max(dot(normal, l), 0.0) * s.color, 1.0);\n    }\n    else\n    {\n        return vec4(0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray worldRay;\n    worldRay.origin = ScreenToWorld(vec3(fragCoord, 0.0));\n    worldRay.direction = normalize(ScreenToWorld(vec3(fragCoord, 1.0)) - worldRay.origin);\n    \n    Sphere s;\n    s.position = vec3(0.0,0.0,0.0);\n    s.radius = 1.0;\n    s.color = vec3(.7, .7, 0.0);\n    \n    \n\tfragColor += GetSphereContribution(worldRay, s, worldRay);\n    fragColor += texture(iChannel0, worldRay.direction);\n}","name":"Image","description":"","type":"image"}]}