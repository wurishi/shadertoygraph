{"ver":"0.1","info":{"id":"4fj3RG","date":"1704361589","viewed":162,"name":"HighQuality Blue Noise 2","username":"FabriceNeyret2","description":"simplifying + commenting  \"HighQuality Blue Noise\" by sampajama. https://shadertoy.com/view/Mfj3Dm\n3843 chars â†’ 586\n- factor 4 directional filters in Common  (horiz, vertic, diags)\n- use simple buitin whitenoise texture in buffA\n- a bit of simplif/golfing","likes":10,"published":3,"flags":32,"usePreview":0,"tags":["noise","math","blue","hash","hash","bluenoise","rng","sinc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// === simplifying \"HighQuality Blue Noise\" by sampajama. https://shadertoy.com/view/Mfj3Dm ===\n// principle is to filter whitenoise with Bessel, approx as 4 directions separable filter\n// then blue noise =  source - lowpass filter \n\nM(vec2(1,-1));    // apply 2nd diagonal filter filter\n\n                  // blue noise =  source - lowpass filter \n    O = .5 + .5*( texelFetch(iChannel1, ivec2(u), 0 ) - O );\n // O = O.rrrr;   // grey version\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// === source white noise. use better hash if needed =============\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = texelFetch(iChannel0, ivec2(u + 73.*floor(3.*iTime) )%256, 0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// === apply horizontal filter =======================\n\nM(vec2(1,0) ); }","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float EPS = 5.79334e-21,\n             PI = 3.1415927,\n         KERNEL = 2.,\n          RANGE = floor(KERNEL * 32.),                  // windowing. 8 seems identical\n     MID_WEIGHT = 1.;\n\n// --- choose your filters here\n\n  #define kernel(x)  sin( PI*x + EPS) / ( PI*x + EPS)   // Sinc\n//#define kernel(x)  exp( -x*x )                        // Gauss\n\n//#define window(x)   1.                                // no window ( indeed, box[-1,1] due to loop(RANGE) \n  #define window(x) ( .35875 + .48829* cos(PI*x) + .14128* cos(2.*PI*x) + .01168* cos(3.*PI*x) ) // Blackman Harris window function [-1,1]\n\n\n// ---  apply 1D filter to channel0\n\n#define T(u) vec4( texelFetch(iChannel0, ivec2(u), 0 ).rgb, 1 )\n\n#define M(D)            /* D: direction of integration  */ \\\nvoid mainImage( out vec4 O, vec2 u ) {                     \\\n    float l = length(D);                                   \\\n    vec4  s =  T(u)                                        \\\n             * MID_WEIGHT * window(0.) * kernel(0.);       \\\n    for(float d = 1.; d < RANGE - .5; d++ )                \\\n        s += (  T( u + d*D )                               \\\n              + T( u - d*D )                               \\\n             )                                             \\\n             * window(     d / RANGE )                     \\\n             * kernel( l * d / KERNEL);                    \\\n                                                           \\\n    O = s / s.a","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// === apply vertical filter =======================\n\nM(vec2(0,1)); }","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// === apply 1st diagonal filter =======================\n\nM(vec2(1)); }","name":"Buffer D","description":"","type":"buffer"}]}