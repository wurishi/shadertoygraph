{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// ray marching\nconst int max_iterations = 512;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// iq's distance function\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\nfloat sdInter( float d0, float d1 ) {\n    return max( d0, d1 );\n}\n\nfloat sdSub( float d0, float d1 ) {\n    return max( d0, -d1 );\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sfDisp( vec3 p ) {\n    return sin(p.x)*sin(p.y)*sin(p.z) ;\n}\n\nvec3 sdTwist( vec3 p, float a ) {\n    float c = cos(a*p.y);\n    float s = sin(a*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 sdRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n//  p = sdRep( p, vec3( 4.0 ) );\n//  p = sdTwist( p, 3.0 );\n    \n    float d0 = sdBox( p, vec3(0.5) );\n    float d1 = sdSphere( p, 0.6 );\n    \n    float d = sdInter( d1, d0 );\n\n    return d;\n    //return d + sfDisp( p * 2.5 );\n    //return sdUnion_s( d + sfDisp( p * 2.5 * sin( iTime * 1.01 ) ), d1, 0.1 );\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ref = reflect( dir, n );\n    \n    vec3 Ks = vec3( 0.5 );\n    vec3 Kd = vec3( 1.0 );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n\t\t\n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -30.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        \n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F );\n\t}\n\n    final += texture( iChannel0, ref ).rgb * fresnel( Ks, n, -dir );\n    \n\treturn final;\n}\n\n\nbool ray_vs_aabb(vec3 o, vec3 dir, vec3 bmin, vec3 bmax, inout vec2 e ) {\n    vec3 a = ( bmin - o ) / dir;\n    vec3 b = ( bmax - o ) / dir;\n    \n    vec3 s = min( a, b );\n    vec3 t = max( a, b );\n    \n    e.x = max( max( s.x, s.y ), max( s.z, e.x ) );\n    e.y = max( min( t.x, t.y ), max( t.z, e.y ) );\n    \n    return e.x < e.y;\n}\n\n// ray marching\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    float d = 10000.0;\n    float dt = 0.0;\n    for ( int i = 0; i < 128; i++ ) {\n        vec3 v = o + dir * t;\n        d = dist_field( v );\n        if ( d < 0.001 ) {\n            break;\n        }\n        dt = min( abs(d), 0.1 );\n        t += dt;\n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    if ( d >= 0.001 ) {\n        return false;\n    }\n    \n    t -= dt;\n    for ( int i = 0; i < 4; i++ ) {\n        dt *= 0.5;\n        \n        vec3 v = o + dir * ( t + dt );\n        if ( dist_field( v ) >= 0.001 ) {\n            t += dt;\n        }\n    }\n    \n    depth = t;\n    n = normalize( gradient( o + dir * t ) );\n    return true;\n    \n    return true;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    float depth = clip_far;\n    vec3 n = vec3( 0.0 );\n\tif ( !ray_marching( eye, dir, depth, n ) ) {\n\t\tfragColor = texture( iChannel0, dir );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n    \n    vec3 color = shading( pos, n, dir, eye );\n\tfragColor = vec4( pow( color, vec3(1.0/1.2) ), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsB3Rm","date":"1384962854","viewed":12776,"name":"Raymarching Sample Code","username":"gltracy","description":"a basic sample code demonstrates how to generate rays, rotate rays, do ray marching, calculate gradients and do phong shading; drag mouse to rotate camera","likes":110,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}