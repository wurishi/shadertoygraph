{"ver":"0.1","info":{"id":"mtySDd","date":"1688314518","viewed":138,"name":"Rain ripples normals","username":"peremoya2000","description":"Outputs a normal map of rain ripples based on torus shapes.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["rain","normal","uvs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_SCALE 7.\n#define MIN_SCALE 1.5\n\n\nvec3 ripplesLayer(vec2 baseUVs, float scale)\n{\n    float time = iTime+100.*scale;\n\n    vec2 scaledUVs = baseUVs.xy*scale+scale*.1;\n    vec2 tile = floor(scaledUVs);\n    vec2 fr = fract(scaledUVs);\n \n    vec2 point = hash22(tile+scale);\n    point = 0.5 + 0.5*sin(iTime*.5 + TAU*point);\n    \n    float size = mix(.15,.35,hash21(tile+scale));\n    vec2 offset = (point - fr.xy)*size;\n    vec2 cartesianUVs = (fr-.5)/size+offset;\n    \n    vec2 polarUVs = vec2(length(cartesianUVs),atan2(cartesianUVs.y,cartesianUVs.x));\n    \n    float speed = .5+cos(point.x+time*.6)*.001+(1.-size);\n    float radius = fract(time*speed);\n    float thickness = min((size*.5+.25)*.5,radius);\n    \n    float start = radius+thickness;\n    float end = max(0.,radius-thickness);\n    float cylinderAngle = smoothstep(start, end, polarUVs.x)*PI;\n        \n    float rippleMask = smoothstep(thickness*1.1,0.,abs(polarUVs.x-radius));\n    float decayMask = min(1.,max(0.,1.-polarUVs.x));      \n    cylinderAngle = mix(cylinderAngle, PI/2., (1.-rippleMask*decayMask));\n    \n    float c = cos(cylinderAngle);\n    vec3 normal = vec3(\n        c*cos(polarUVs.y), \n        c*sin(polarUVs.y), \n        sin(cylinderAngle));\n    \n    return normal;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n             \n    vec3 normal = vec3(0,0,1);\n    \n    for(float i = MAX_SCALE; i>MIN_SCALE; i-=1.5)\n    {\n        normal=mix(normal,ripplesLayer(uv, i),.6);\n    }\n   \n    \n    fragColor = vec4(normalToImageRange(normalize(normal)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TAU 6.283185307\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p * PI;\n    return fract(p);\n}\n\nfloat hash21(vec2 p) {\n\tp = fract(p*vec2(1.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvec2 hash22(vec2 p){\n    return fract(\n    sin(vec2(dot(p,vec2(127.1,311.7)),\n    dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*PI/2. : atan(y, x);\n}\n\nvec3 normalToImageRange(vec3 vector)\n{\n    return vector*.5+.5;\n}","name":"Common","description":"","type":"common"}]}