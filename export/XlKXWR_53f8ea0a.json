{"ver":"0.1","info":{"id":"XlKXWR","date":"1483852194","viewed":1984,"name":"Gradient Band Interpolation","username":"kylawl","description":"A test implementation of Rune Skovbo Johansen's Gradient Band Interpolation. This is a pretty cool way of computing animation blend weights. \nRed is Cartesian interpolation and Green is Polar.\nhttp://runevision.com/thesis/rune_skovbo_johansen_thesis.pdf\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["animationblendweights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define POINT_COUNT 8\n\nconst float kPi         = 3.14159;\n\nvoid sampleWeightsCartesian(vec2 sample_point, vec2 points[POINT_COUNT], out float weights[POINT_COUNT] )\n{\n    float total_weight = 0.0;\n    \n    for( int i = 0; i < POINT_COUNT; ++i )\n    {\n        // Calc vec i -> sample\n        vec2    point_i = points[i];\n        vec2    vec_is  = sample_point - point_i;\n        \n        float   weight  = 1.0;\n        \n        for( int j = 0; j < POINT_COUNT; ++j )\n        {\n            if( j == i ) \n                continue;\n            \n            // Calc vec i -> j\n            vec2    point_j     = points[j];            \n            vec2    vec_ij      = point_j - point_i;      \n            \n            // Calc Weight\n            float lensq_ij      = dot( vec_ij, vec_ij );\n            float new_weight    = dot( vec_is, vec_ij ) / lensq_ij;\n            new_weight          = 1.0 - new_weight;\n            new_weight          = clamp(new_weight, 0.0, 1.0 );\n            \n            weight              = min(weight, new_weight);\n        }\n       \n        weights[i]          = weight;\n        total_weight        += weight;\n    }\n    \n    for( int i = 0; i < POINT_COUNT; ++i )\n    {\n        weights[i] = weights[i] / total_weight;\n    }\n}\n\nfloat signedAngle(vec2 a, vec2 b)\n{\n    return atan( a.x*b.y - a.y*b.x, a.x*b.x + a.y*b.y );\n}\n\nvoid sampleWeightsPolar(vec2 sample_point, vec2 points[POINT_COUNT], out float weights[POINT_COUNT] )\n{\n    \n    const float kDirScale   = 2.0;\n    \n    float   total_weight    = 0.0;\n    \n    float   sample_mag      = length( sample_point );\n    \n    for( int i = 0; i < POINT_COUNT; ++i )\n    {      \n        vec2    point_i     = points[i];\n        float   point_mag_i = length(point_i);\n        \n        float   weight      = 1.0;\n        \n        for( int j = 0; j < POINT_COUNT; ++j )\n        {\n            if( j == i ) \n                continue;\n            \n            vec2    point_j         = points[j];\n            float   point_mag_j     = length( point_j );\n            \n            float   ij_avg_mag      = (point_mag_j + point_mag_i) * 0.5;\n            \n            // Calc angle and mag for i -> sample\n            float   mag_is          = (sample_mag - point_mag_i) / ij_avg_mag;\n            float   angle_is\t\t= signedAngle(point_i, sample_point);\n            \n            // Calc angle and mag for i -> j\n            float   mag_ij          = (point_mag_j - point_mag_i) / ij_avg_mag;\n            float   angle_ij\t\t= signedAngle(point_i, point_j);\n            \n            // Calc vec for i -> sample\n            vec2    vec_is;\n            vec_is.x                = mag_is;\n            vec_is.y                = angle_is * kDirScale;\n            \n            // Calc vec for i -> j\n            vec2    vec_ij;\n            vec_ij.x                = mag_ij;\n            vec_ij.y                = angle_ij * kDirScale;\n            \n            // Calc weight\n         \tfloat lensq_ij      = dot( vec_ij, vec_ij );\n            float new_weight    = dot( vec_is, vec_ij ) / lensq_ij;\n            new_weight          = 1.0-new_weight;\n            new_weight          = clamp( new_weight, 0.0, 1.0 );\n            \n            weight              = min( new_weight, weight );\n        }\n        \n        weights[i]          = weight;\n        \n        total_weight        += weight;\n    }\n    \n    for( int i = 0; i < POINT_COUNT; ++i )\n    {\n\t\tweights[i] = weights[i] / total_weight;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 3.0;\n    \n    vec2 aspect = vec2( iResolution.x / iResolution.y, 1.0 );\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= scale;\n    uv *= aspect;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= 0.5;\n    mouse *= scale;\n    mouse *= aspect;\n    \n    vec2 mouse2 = (iResolution.xy - iMouse.xy) / iResolution.xy;\n    mouse2 -= 0.5;\n    mouse2 *= scale;\n    mouse2 *= aspect;\n    \n    vec2 points[POINT_COUNT];\n    points[0] = mouse;\n    points[7] = mouse2 ;\n    points[1] = vec2( 1.0, 0.0 );\n    points[2] = vec2( 0.0, 1.0 );\n    points[3] = vec2(-1.0, 0.0 );\n    points[4] = vec2( 0.0,-1.0 );\n    points[5] = vec2( 0.0, 0.0 );\n        \n    float weights_polar[POINT_COUNT];\n    sampleWeightsPolar(uv, points, weights_polar);\n    \n    float weights_linear[POINT_COUNT];\n    sampleWeightsCartesian(uv, points, weights_linear);\n    \n  \n    vec3 total_value   = vec3( weights_linear[0], weights_polar[7], 0.0 );\n    total_value         = pow( total_value, vec3(1.0 / 2.2) ); // Linearize so we can see the full range\n    \n    fragColor.xyz       = vec3( total_value );\n    \n    for( int i = 0; i < POINT_COUNT; ++i )\n    {\n        float point_dot = ceil( pow( clamp(1.0-length(points[i] - uv), 0.0, 1.0), 1500.0) );\n        fragColor.xyz   = mix(fragColor.xyz, vec3(1.0, 0.0, 1.0), point_dot);\n    }\n}","name":"Image","description":"","type":"image"}]}