{"ver":"0.1","info":{"id":"sdBcD1","date":"1649648246","viewed":102,"name":"YouTubeTutorial_Part3","username":"Paws101","description":"Tutorial Part3\n1:54t","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tute"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Step #3 of the LIVE Shade Deconstruction tutorial for \"Happy Jumping\"\n// https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n\n// Step 1: https://www.shadertoy.com/view/Wl2SRw\n// Step 2: https://www.shadertoy.com/view/3ljSzw\n// Step 3: https://www.shadertoy.com/view/ttjXDz\n// Step 4: https://www.shadertoy.com/view/tljSDz\n// Final:  https://www.shadertoy.com/view/3lsSzf\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\t\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos, float atime )\n{\n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1);\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\t\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec2 res = vec2( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0 );\n\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18,0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.x = smin( res.x, arms.x, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.x = smin( res.x, ear.x, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.x = smax( res.x, -d, 0.03 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    res = opU( res, vec2(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0));\n    res = opU( res, vec2(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0));\n    }\n        \n    // ground\n    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n\n    d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0),pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(2.0,y,0.0), siz*rad );\n    \n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) res = vec2(d,1.0);\n    }\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, float time )\n{\n/*\n    vec2 e = vec2(0.0005,0.0);\n    return normalize( vec3( \n        map( pos + e.xyy, time ).x - map( pos - e.xyy, time ).x,\n\t\tmap( pos + e.yxy, time ).x - map( pos - e.yxy, time ).x,\n\t\tmap( pos + e.yyx, time ).x - map( pos - e.yyx, time ).x ) );\n*/\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    \n    vec2 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = vec3(0.144,0.09,0.0036);\n        }\n\t\telse // terrain\n        {\n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n        }\n        \n        // lighting\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = step(castRay( pos+0.001*nor, sun_lig,time ).y,0.0);\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n        lin += sky_dif*vec3(0.50,0.70,1.00);\n        lin += bou_dif*vec3(0.40,1.00,0.40);\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        \n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float time = iTime;\n\n    time *= 0.9;\n\n    // camera\t\n    float cl = sin(0.5*time);\n    float an = 1.57 + 0.7*sin(0.15*time);\n    vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n    vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 rd = ca * normalize( vec3(p,1.8) );\n\n    vec3 col = render( ro, rd, time );\n\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}