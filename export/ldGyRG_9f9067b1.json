{"ver":"0.1","info":{"id":"ldGyRG","date":"1522541771","viewed":384,"name":"Simple interactive ripple effect","username":"emaldonado_gamedev","description":"Instructions:\nClick anywhere on the screen!\n\nCurrent major constraint is that you can only create one ripple wave at the moment.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["rippleeffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Author: Esteban Enrique Maldonado Cab√°n\n\n/*\nReferences:\n1) For gameplay / simulation states\nhttps://www.shadertoy.com/view/MddGzf <-- This is really cool!\n\n2) Mouse input:\nhttps://www.shadertoy.com/view/MdlGRr\n\n3) Math for simple ripple effect:\nhttp://adrianboeing.blogspot.com/2011/02/ripple-effect-in-webgl.html\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //load saved sim. states\n    vec2 rippleSource = texelFetch(iChannel2, txRipplePoint, 0).xy;\n    float currRippleStrength = texelFetch(iChannel2, txCurrRipleStrength, 0).x;\n    float currRippleStartTime = texelFetch(iChannel2, txCurrRippleStartTime, 0).x;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 fragCoordNormalized = fragCoord/iResolution.xy;\n    \n    //current pixel position in range of -1 to 1\n    vec2 currentPos = toRange1toNeg1(fragCoordNormalized);\n    \n    float currentLength = length(currentPos - rippleSource);\n    \n    vec2 uv = fragCoordNormalized + (currentPos / currentLength) * \n        (currRippleStrength/maxRippleStrength) * \n        sincFunction(currentLength * 11.0 - (iTime - currRippleStartTime) * 8.) / 3.;\n    \n    \n    ////////////////////////////\n    //TODO: Normal calculation for lighting\n    //http://www.teacherschoice.com.au/Maths_Library/Calculus/tangents_and_normals.htm\n    \n    \n    // Output to screen - also as a bonus I'm combining the 2 textures just for fun\n    // saturate the final color using the clamp function\n    fragColor = clamp(texture( iChannel0, uv ) * texture( iChannel1, uv ) * 2.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//----------------------------------------------------------------------------------------------\n//KEYBOARD HELPER FUNCTIONS\nbool isKeyPressed(int key) \n{\n\tfloat pressSpace = texelFetch( iChannel0, ivec2(key, 0), 0 ).x;\n    \n    //if greater than 0.5, then pressed is true\n \treturn pressSpace > 0.5f;\n}\n\nbool isKeyPressed(float key)\n{   \n    bool toggle = true;\n    \n\tfloat keyValue = textureLod( iChannel0, vec2( key, toggle ? 0.75f : 0.25f ), 0.0f).x;\n\t\n    return (keyValue > 0.5f);\n}\n//----------------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------------\n//SAVE & LOAD HELPER FUNCTIONS\nvec4 loadValueFromTextureLocation(in ivec2 valueLocation )\n{\n    return texelFetch( iChannel1, valueLocation, 0 );\n}\n\nvoid storeValueToTextureLocation(\n    in ivec2 registerLoc,\n    in vec4 newValue,\n    inout vec4 currfragColor, \n    in ivec2 pixCoord )\n{\n    currfragColor = (pixCoord == registerLoc) ? newValue : currfragColor;\n}\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //load current state of simulation\n\tvec2 rippleSourcePoint = loadValueFromTextureLocation(txRipplePoint).xy;\n    float currRippleStrength = loadValueFromTextureLocation(txCurrRipleStrength).x;\n    float currRippleStartTime = loadValueFromTextureLocation(txCurrRippleStartTime).x;\n    \n    //Check mouse click to re-start ripple\n    if(iMouse.z > 0.0) \n    {\n        currRippleStrength = maxRippleStrength;\n        currRippleStartTime = iTime;\n        \n        //Move the ripple source position to where the mouse is last pressed.\n    \t//Also move the values to the range of -1.0 to 1.0\n        rippleSourcePoint = toRange1toNeg1(iMouse.xy/iResolution.xy);\n\t}\n    \n    //update ripple vars.\n    currRippleStrength = max(0.0, currRippleStrength * \n    \t(1.0f - (iTime - currRippleStartTime) / singleRippleDuration));\n    \n    \n    //Save simulation state\n    fragColor = vec4(0.);\n    \n    ivec2 ipx = ivec2(fragCoord-0.5);\n    storeValueToTextureLocation(txRipplePoint, vec4(rippleSourcePoint, 1.,1.), fragColor, ipx);\n    storeValueToTextureLocation(txCurrRipleStrength, vec4(currRippleStrength, 1.,1.,1.), fragColor, ipx);\n    storeValueToTextureLocation(txCurrRippleStartTime, vec4(currRippleStartTime, 1.,1.,1.), fragColor, ipx);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// storage register/texel addresses\nconst ivec2 txRipplePoint = ivec2(0,0);\nconst ivec2 txCurrRipleStrength = ivec2(1,0);\nconst ivec2 txCurrRippleStartTime = ivec2(2,0);\n\n//ripple sim. constants\nconst float maxRippleStrength = 110.0;\nconst float singleRippleDuration = 100.0;\n\n//Keyboard constants\nconst float KEY_Q     = 81.5/256.0;\nconst int KEY_Q_int = 81;\n\nfloat sincFunction(float x) \n{\n    //if(abs(x) < 0.00001)\n    //    return 1.0;\n    \n    return sin(x) / x;\n}\n\nvec2 toRange1toNeg1(in vec2 normalValue_0to1)\n{\n    return 2.0 * normalValue_0to1 - 1.0;\n}\n","name":"Common","description":"","type":"common"}]}