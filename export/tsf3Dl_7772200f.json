{"ver":"0.1","info":{"id":"tsf3Dl","date":"1547776918","viewed":218,"name":"DPrecLib Explorable Mandelbrot","username":"JoshScholar","description":"1s test complete double precision library. Mandelbrot fractal with controllable zoom. Click to zoom in. Ctrl+click to zoom out. From rmccampbell7's https://www.shadertoy.com/view/Wss3Dj \nNote only a little of the library is tested here.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Explorable Mandelbrot\" by None. https://shadertoy.com/view/-1\n// 2019-01-18 01:28:39\n\n// Fork of \"Explorable Mandelbrot\" by None. https://shadertoy.com/view/-1\n// 2019-01-17 21:27:56\n\n\n// Fork of \"Explorable Mandelbrot\" by rmccampbell7. https://shadertoy.com/view/Wss3Dj\n// 2019-01-16 03:04:16\n\n#define SAMPLES 2\n#define MAXIT 2048\n#define RAD 8.\n#define COLOR_PERIOD 2.\n#define COLOR_SHIFT 0.\n\n\n\nint mandelbrot(vec4 c, out vec4 z) {\n    z = c;\n    for (int i=1; i<=MAXIT; i++) {\n        if ((z.x*z.x + z.z*z.z) > RAD*RAD) return i;\n        //z = mat2(z, -z.y, z.x) * z + c;\n        //z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z = dcAdd(dcSqr(z),c);\n    }\n    return -1;\n}\n\n// https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_(smooth)_coloring\nfloat smooth_color(vec4 z, int i) {\n    return float(i) + 1. - log2(log2(sqrt(dcLength(z).x)));\n}\n\n// Colormap is matplotlib.cm.twilight: https://matplotlib.org/\nvec3[] colors = vec3[] (\n    vec3(0.88575016, 0.85000925, 0.88797365),\n    vec3(0.76751109, 0.80980076, 0.83252817),\n    vec3(0.58301487, 0.70958888, 0.77925782),\n    vec3(0.44802471, 0.59238331, 0.75574176),\n    vec3(0.38407269, 0.46139019, 0.73094665),\n    vec3(0.3698798 , 0.3163841 , 0.67703755),\n    vec3(0.35060304, 0.1659513 , 0.56147965),\n    vec3(0.27008638, 0.07548368, 0.36056376),\n    vec3(0.18488036, 0.07942573, 0.21307652),\n    vec3(0.29128515, 0.07489905, 0.25755102),\n    vec3(0.45383005, 0.11622184, 0.30970441),\n    vec3(0.59659918, 0.20721296, 0.31258523),\n    vec3(0.69806082, 0.33828976, 0.32207479),\n    vec3(0.76257334, 0.48718907, 0.38675335),\n    vec3(0.80029415, 0.64098213, 0.53730535),\n    vec3(0.84892246, 0.77992021, 0.74663719)\n);\n\nconst int N = colors.length();\n\nvec3 colormap(float v) {\n    float i = clamp(v, 0., 1.)*float(N);\n    int i0 = int(i) % N;\n    int i1 = (i0+1) % N;\n    float f = fract(i);\n    return colors[i0]*(1.-f) + colors[i1]*f;\n}\n\nvec3 get_color(vec2 pix, vec4 center, float zoom) {\n    vec2 uv = (2.*pix - iResolution.xy)/iResolution.y;\n    vec4 c = dcAdd(dcSet(uv * pow(2., -zoom)) , center);\n    vec4 z;\n    int i = mandelbrot(c, z);\n    if (i < 0) return vec3(0);\n    float val = log(max(smooth_color(z, i), 1.));\n    return colormap(fract(val/COLOR_PERIOD + COLOR_SHIFT));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 avg_col = vec3(0);\n\n    vec4 state = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 stateh = texelFetch(iChannel2, ivec2(0, 0), 0);\n    mix_amount=state.w;\n    \n    vec4 center = stateh;\n    float zoom = state.z;\n\n    for (int i=0; i<SAMPLES; i++) {\n\t    for (int j=0; j<SAMPLES; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(SAMPLES);\n        \tavg_col += get_color(pix, center, zoom);\n        }\n    }\n    avg_col /= float(SAMPLES*SAMPLES);\n\n    fragColor = vec4(avg_col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define INITCENTER vec2(-.5, 0)\n#define INITZOOM -0.2\n#define MAXZOOM 38.\n#define SPEED 1.\n\n#define KEY_CTRL 17\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = INITCENTER;\n    float zoom = INITZOOM;\n    mix_amount=1.;\n    \n    if (iFrame > 0) {\n        vec4 state = texelFetch(iChannel0, ivec2(0, 0), 0);\n        center = state.xy;\n        zoom = state.z;\n        mix_amount=state.w;\n    }\n    \n    if ( iMouse.z > 0.) {\n        float sgn = 1. - 2.*texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x;\n        float dzoom = sgn * SPEED * iTimeDelta;\n        vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n        vec2 disp = mouse * pow(2., -zoom);\n        center += disp * (1. - pow(2., -dzoom));\n        zoom += dzoom;\n\t    zoom = min(zoom, MAXZOOM);\n    }\n    \n    fragColor = vec4(center, zoom, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//From Extended-Precision Floating-Point Numbers for GPU Computation\n//by Andrew Thall\n//where a>b\n\nfloat mix_amount;\n\nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, mix_amount);\n}\n\nfloat plus_frc(float a, float b) {\n  return  mix(a, a + b, mix_amount);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, mix_amount);\n}\n\nvec2  quickTwoSum ( float a , float b ) {\n\tfloat  s = plus_frc(a , b) ;\n\tfloat  e = minus_frc(b , minus_frc( s , a )) ;\n\treturn vec2 ( s , e ) ;\n}\nvec2 twoSum ( float a , float b ) {\n\tfloat s = plus_frc(a , b) ;\n\tfloat v = minus_frc(s, a) ;\n\tfloat e = plus_frc(minus_frc( a , minus_frc( s , v ) ), minus_frc( b , v )) ;\n\treturn vec2 ( s , e ) ;\n}\n/*\n vec2 df64_add (vec2 a , vec2 b ) {\n\tvec2 s , t;\n\ts = twoSum ( a.x , b.x ) ;\n\tt= twoSum ( a.y , b.y ) ;\n\ts.y += t.x ;\n\ts = quickTwoSum ( s.x , s.y ) ;\n\ts.y += t.y ;\n\ts = quickTwoSum ( s.x , s.y ) ;\n\treturn s ;\n}\n*/\nvec2 parts_add(vec2 a, vec2 b)\n{\n    return vec2(plus_frc(a.x,b.x),plus_frc(a.y,b.y));\n}\nvec2 parts_sub(vec2 a, vec2 b)\n{\n    return vec2(minus_frc(a.x,b.x),minus_frc(a.y,b.y));\n}\n\nvec4 twoSumComp ( vec2 ari , vec2 bri ) {\n\tvec2 s = parts_add(ari, bri) ;\n\tvec2 v = parts_sub(s , ari) ;\n\tvec2 e = parts_add(parts_sub( ari , parts_sub( s , v ) ) , parts_sub(bri , v) ) ;\n\treturn vec4 ( s.x , e.x , s.y , e.y ) ;\n}\n//possibly faster version\nvec2 df64_add ( vec2 a , vec2 b ) {\n\tvec4 st;\n\tst= twoSumComp ( a , b ) ;\n\tst.y = plus_frc(st.y, st.z) ;\n\tst.xy = quickTwoSum ( st.x , st.y ) ;\n\tst.y = plus_frc(st.y,st.w);\n\tst.xy = quickTwoSum ( st.x , st.y ) ;\n\treturn st.xy ;\n}\n\nvec2 df64_sub ( vec2 a , vec2 b ) {\n\tvec4 st;\n\tst= twoSumComp ( a , -b ) ;\n\tst.y = plus_frc(st.y,st.z);\n\tst.xy = quickTwoSum ( st.x , st.y ) ;\n\tst.y = plus_frc(st.y,st.w);\n\tst.xy = quickTwoSum ( st.x , st.y ) ;\n\treturn st.xy ;\n}\n\nvec2 split( float a ) {\n\tconst float split= 4097.; // (1 << 12) + 1;\n\tfloat t= a* split;\n\tfloat ahi = minus_frc(t, minus_frc( t, a )) ;\n\tfloat alo = minus_frc(a , ahi) ;\n\treturn vec2 ( ahi , alo ) ;\n}\nvec4 splitComp ( vec2 c ) {\n\tconst float split= 4097.; // (1 << 12) + 1;\n\tvec2 t= c* split;\n\tvec2 chi = parts_sub(t, parts_sub( t, c )) ;\n\tvec2 clo = parts_sub(c , chi) ;\n\treturn vec4 ( chi.x , clo.x , chi.y , clo.y ) ;\n}\n\nvec2 twoProd ( float a , float b ) {\n\tfloat p = times_frc(a,b );\n\tvec2 aS =split( a ) ;\n\tvec2 bS =split( b ) ;\n\tfloat err= plus_frc(plus_frc( plus_frc(minus_frc( aS.x*bS.x , p ),\n\t\t aS.x*bS.y) , aS.y*bS.x )\n\t\t, aS.y*bS.y) ;\n\treturn vec2 ( p , err) ;\n}\n\nvec2 df64_mult( vec2 a , vec2 b ) {\n\tvec2 p ;\n\tp = twoProd ( a.x , b.x ) ;\n\tp.y = plus_frc(p.y,a.x * b.y) ;\n\tp.y = plus_frc(p.y,a.y * b.x) ;\n\tp = quickTwoSum ( p.x , p.y ) ;\n\treturn p ;\n}\nvec2 df64_sqr( vec2 a ) {\n\tvec2 p ;\n\tp = twoProd ( a.x , a.x ) ;\n\tp.y = plus_frc(p.y,2.0*(a.x * a.y)) ;\n\tp = quickTwoSum ( p.x , p.y ) ;\n\treturn p ;\n}\n\nvec2 df64_div ( vec2 B , vec2 A) {\n\tfloat xn = 1.0 /A. x ;\n\tfloat yn = B.x*xn ;\n\tfloat diffTerm = ( df64_sub (B , df64_mult(A, vec2(yn,0.) ) ) ).x ;\n\tvec2 prodTerm = twoProd ( xn , diffTerm ) ;\n\treturn df64_add ( vec2(yn,0.) , prodTerm ) ;\n}\nvec2 df64_sqrt( vec2 A) {\n\tfloat xn = 1./sqrt(A. x ) ; \n\tfloat yn = A. x*xn ;\n\tvec2 ynsqr = df64_sqr ( vec2(yn,0.) ) ;\n\tfloat diff = ( df64_sub (A, ynsqr ) ).x ;\n\tvec2 prodTerm = twoProd ( xn , diff ) / 2. ;\n\treturn df64_add ( vec2(yn,0.) , prodTerm ) ;\n}\n\nbool df64_eq ( vec2 a , vec2 b ) {\n\treturn a.x == b.x && a.y == b.y;\n}\nbool df64_neq ( vec2 a , vec2 b ) {\n\treturn a.x != b.x || a.y != b.y;;\n}\nbool df64_lt( vec2 a , vec2 b ) {\n\treturn ( a.x < b.x || ( a.x == b.x && a.y < b.y ) ) ;\n}\n\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(df64_sub(df64_mult(a.xy,b.xy),df64_mult(a.zw,b.zw)),df64_add(df64_mult(a.xy,b.zw),df64_mult(a.zw,b.xy)));\n}\n\n// double complex multiplication\nvec4 dcSqr(vec4 a) {\n  return vec4(df64_sub(df64_sqr(a.xy),df64_sqr(a.zw)),2.*df64_mult(a.xy,a.zw));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(df64_add(a.xy,b.xy),df64_add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return df64_add(df64_mult(a.xy,a.xy),df64_mult(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, a.y, ad.x, ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(df64_mult(a.xy,b),df64_mult(a.wz,b));\n}\n\n\tvec4 dcSub(vec4 a, vec4 b) {\n\t\treturn vec4(df64_sub(a.xy,b.xy),df64_sub(a.zw,b.zw));\n\t}\n\nvec2 df64_exp ( vec2 a ) {\n\tfloat thresh = 1.0e-20*exp( a.x ) ;\n\tvec2 t; /* Term b e i n g added.*/\n\tvec2 p ; /* C u r r e n tpower o f a.*/\n\tvec2 f ; /* Denominator.*/\n\tvec2 s ; /* C u r r e n tp a r ti a l sum.*/\n\tvec2 x ; /* = -s q r ( a ) */\n\tfloat m;\n\ts = df64_add ( vec2(1.0,0.) , a ) ; // f i r s ttwo te r m s\n\tp = df64_sqr ( a ) ;\n\tm = 2.0;\n\tf = vec2 ( 2.0 , 0.0 ) ;\n\tt= p / 2.0 ;\n\twhile ( abs ( t.x ) > thresh ) {\n\t\ts = df64_add ( s , t) ;\n\t\tp = df64_mult( p , a ) ;\n\t\tm += 1.0;\n\t\tf = df64_mult( f , vec2(m,0.)) ;\n\t\tt= df64_div ( p , f ) ;\n\t}\n\treturn df64_add ( s , t) ;\n}\n\nvec2 df64_log ( vec2 a ) {\n\tvec2 xi = vec2 ( 0.0 , 0.0 ) ;\n\tif ( ! df64_eq ( a , vec2(1.0,0.) ) ) {\n        if ( a.x <= 0.0 ){\n\t\t\tfloat t = log ( a.x ) ; // r e tu r n NaN\n        \txi = vec2(t,t);\n        } else {\n\t\t\txi.x = log ( a.x ) ;\n\t\t\txi = df64_add ( df64_add ( xi ,\n\t\t\tdf64_mult( df64_exp(-xi ) , a ) ) , vec2(-1.0,0.));\n\t\t}\n\t}\n\treturn xi ;\n}\n\nvec4 df64_sincos( vec2 a ) {\n\tfloat thresh = 1.0e-20 * abs ( a.x ) ;\n\tvec2 t; /* Term b e i n g added.*/\n\tvec2 p ; /* C u r r e n tpower o f a.*/\n\tvec2 f ; /* Denominator.*/\n\tvec2 s ; /* C u r r e n tp a r ti a l sum.*/\n\tvec2 x ; /* = -s q r ( a ) */\n\tfloat m;\n\tvec2 sina , cosa ;\n\tif ( a.x == 0.0 ) {\n\t\tsina = vec2 (0., 0. ) ;\n\t\tcosa = vec2 (1., 0. ) ;\n\t}\n\telse {\n\t\tx = -df64_sqr ( a ) ;\n\t\ts = a ;\n\t\tp = a ;\n\t\tm = 1.;\n\t\tf = vec2 (1., 0. ) ;\n\t\twhile ( true ) {\n\t\t\tp = df64_mult( p , x ) ;\n\t\t\tm += 2.0 ;\n\t\t\tf = df64_mult( f , vec2( m*(m-1.),0.));\n\t\t\tt = df64_div ( p , f ) ;\n\t\t\ts = df64_add ( s , t) ;\n\t\t\tif ( abs ( t.x ) < thresh )\n\t\t\t\tbreak ;\n\t\t}\n\t\tsina = s ;\n\t\tcosa = df64_sqrt( df64_add (vec2(1.,0.), -df64_sqr ( s ) ) ) ;\n\t}\n\treturn vec4 ( sina , cosa ) ;\n}\n\nvec2 set(float a)\n{\n    return vec2(a,0.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define INITCENTER vec2(-.5, 0)\n#define INITZOOM -0.2\n#define MAXZOOM 34.\n#define SPEED 1.\n\n#define KEY_CTRL 17\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centerx = set(INITCENTER.x);\n    vec2 centery = set(INITCENTER.y);\n    float zoom = INITZOOM;\n    mix_amount=1.;\n    if (abs(mix_amount-1.)>0.)mix_amount/=log(2.7182818284);\n\n    if (iFrame > 0) {\n        vec4 state0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n        vec4 state = texelFetch(iChannel2, ivec2(0, 0), 0);\n        centerx = state.xy;\n        centery = state.zw;\n        zoom = state0.z;\n        mix_amount=state0.w;\n    }\n    \n    if ( iMouse.z > 0.) {\n        float sgn = 1. - 2.*texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x;\n        float dzoom = sgn * SPEED * iTimeDelta;\n        vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n        vec2 disp = mouse * pow(2., -zoom) * (1. - pow(2., -dzoom));\n        centerx = df64_add(centerx,set(disp.x));\n        centery = df64_add(centery,set(disp.y));\n    }\n    \n    fragColor = vec4(centerx, centery);\n}","name":"Buffer B","description":"","type":"buffer"}]}