{"ver":"0.1","info":{"id":"7dSyzK","date":"1643759828","viewed":69,"name":"RaycastSpheres","username":"mulletdulla","description":"Rasycast Spheres testing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// randomize sphere surface height with noise\n// calculate correct backwards path tracing\n// rectify additive blending\n// add brdf lighting model\n// - spec\n// - surface shadowing\n// - fresnel\n\n// add shadow penumbras\n// add multiple lights\n// add reflectivity\n// add refraction\n// add SSS\n// add ground surface\n// add and sample ambient background\n// add other geometric shapdes\n\nconst int sphereCount = 27;\nconst float m = .75;\nconst float bias = 0.001;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // frame coords\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(.1);\n    float depth = 0.;\n    \n    vec3 ambient = vec3(.035, .002, .07);\n    \n    Sphere sphere[sphereCount];\n\n    for (int i = 0; i < sphereCount; i++)\n    {\n        sphere[i].hit = false;\n        sphere[i].pos = cubeGrid[i] * vec3(m);// * vec3(m, 2. * m, 3. * m);\n        sphere[i].radius = .05 + float(i) * .005;\n        sphere[i].albedo = vec3((.1 + float(i)) / float(sphereCount), .5, 0);\n    }\n\n    Ray pRay; // Primary Ray\n    pRay.o = vec3(0, 0, -4.);\n    pRay.d = normalize(vec3(uv.x, uv.y, 1));\n\n    Light light;\n    light.pos = vec3(0., 1., - .5) * 100.;\n    light.col = vec3(1., .87, .66);\n    light.intensity = 1.4;\n    light.col *= pow(light.intensity, 2.0);\n\n    // do intersection test per frag\n    // if we hit, do not test for any other intersections\n\n    float minDist = 10000.;\n    vec3 pHit; // primary hit\n    vec3 nHit; // normal at primary hit\n\n    Sphere hitSphere;\n    bool shadow = false;\n\n    for (int i; i < sphereCount; i++)\n    {\n\n        if (SphereInterection(pRay, sphere[i], pHit, nHit))\n        {\n            // we have hit a sphere\n            sphere[i].hit = true;\n            float dist = distance(pRay.o, pHit);\n\n            // not very optimizesd!\n            if (dist < minDist)\n            {\n                hitSphere = sphere[i];\n                minDist = dist;\n\n                Ray rToL;\n                rToL.o = pHit + nHit * bias;\n                rToL.d = normalize(light.pos - rToL.o);\n\n                vec3 sHit; // primary hit\n                vec3 nSHit; // normal at primary hit\n\n                for (int j; j < sphereCount; j++)\n                {\n                    if (SphereInterection(rToL, sphere[j], sHit, nSHit))\n                    {\n                        if (hitSphere.pos == sphere[j].pos) break;\n                        shadow = true;\n\n                        col = hitSphere.albedo;\n                        break;\n                    }\n                }\n\n                if (!shadow)\n                {\n                    col = hitSphere.albedo * LightTrace(nHit, pHit, light);\n                }\n                else\n                {\n                    col = vec3(0);\n                }\n            }\n        }\n    }\n\n    if (hitSphere.hit == true)\n    {\n\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GLSLIFY 1\nvec3 cubeGrid[27] = vec3[27]\n(\n    vec3(-1, -1, -1),\n    vec3(0, -1, -1),\n    vec3(1, -1, -1),\n    vec3(-1, 0, -1),\n    vec3(0, 0, -1),\n    vec3(1, 0, -1),\n    vec3(-1, 1, -1),\n    vec3(0, 1, -1),\n    vec3(1, 1, -1),\n    vec3(-1, -1, 0),\n    vec3(0, -1, 0),\n    vec3(1, -1, 0),\n    vec3(-1, 0, 0),\n    vec3(0, 0, 0),\n    vec3(1, 0, 0),\n    vec3(-1, 1, 0),\n    vec3(0, 1, 0),\n    vec3(1, 1, 0),\n    vec3(-1, -1, 1),\n    vec3(0, -1, 1),\n    vec3(1, -1, 1),\n    vec3(-1, 0, 1),\n    vec3(0, 0, 1),\n    vec3(1, 0, 1),\n    vec3(-1, 1, 1),\n    vec3(0, 1, 1),\n    vec3(1, 1, 1)\n);\n\nstruct Disc {\n    vec3 p;\n    float s;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n    vec3 invD;\n    int sign[3];\n};\n\nstruct Sphere\n{\n    bool hit;\n    vec3 pos;\n    vec3 albedo;\n    float radius;\n    float specularity;\n};\n\nstruct Box\n{\n    bool hit;\n    vec3 pos;\n    vec3 albedo;\n    vec3 scale;\n    vec3 rotation;\n    vec3 hitPos;\n    vec3 normal;\n    float specularity;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n    float attenuation;\n    float intensity;\n};\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p)\n{\n    vec3 rop = (p - ro);\n    return length(cross(rop, rd)) / length(rd);\n}\n\nfloat DrawDisc(Disc d, Ray r)\n{\n    float radius = 1. - DistLine(r.o, r.d, d.p) / d.s;\n    return smoothstep(0.0,.05,radius);\n}\n\nvec3 LightTrace(vec3 normal, vec3 intersection, Light light)\n{\n    Ray r;\n    r.o = intersection;\n    r.d = normalize(light.pos - r.o); //\n\n    float nDotL = dot(normal, r.d);\n    vec3 lambert = nDotL * light.col;\n\n    return vec3(lambert);\n}\n\nbool SphereInterection(Ray r, Sphere s, inout vec3 hit, inout vec3 normal)\n{\n    float t = dot(s.pos - r.o, r.d);\n    if (t < 0.)  return false; // make sure we are not using casts in the opposite direction\n\n    vec3 p = r.o + r.d * t;\n\n    float y = length(s.pos - p);\n    if (y < s.radius)\n    {\n        float x = sqrt(s.radius * s.radius - y * y);\n        float t1 = t - x;\n        float t2 = t + x;\n\n        hit = r.o + r.d * t1;\n        normal = normalize(hit - s.pos);\n\n        return true;\n    }\n}\n\nvoid InitializeSphere(inout Sphere sphere)\n{\n\n}","name":"Common","description":"","type":"common"}]}