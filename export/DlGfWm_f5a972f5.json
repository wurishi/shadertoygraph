{"ver":"0.1","info":{"id":"DlGfWm","date":"1702129398","viewed":45,"name":"artichoke","username":"Efim","description":"fork [url]https://www.shadertoy.com/view/dtyfWD[/url]","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","displacement","artichoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//short temlate of FabriceNeyret2\n//M - sdf function for artichoke\n\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\n#define N        normalize\n#define r(f)     mat2( cos(f + vec4(0,33,11,0)) )   // rotation \n\nfloat t;\n\n\nfloat scale5(float x, float y)\n{\n    //float r = (1.-asin(abs((x - 0.5)*2.))*2./PI)*0.7 + 0.3 -y; //pine\n    float r = (1.-asin(abs((x - 0.5)*2.))*2./PI) - y; //Artichoke\n    float f = smoothstep(-0.05, 0.05, r);\n    f *= y*y*.8;\n    f *= (1. + 6.0*cos((x-0.5)*PI)*cos((y-0.5)*PI));\n    //f += smoothstep(0.02, 0., abs(x-0.5)) * 0.2;\n    float dl = f*0.01;\n    return dl;   \n}\n\n\nfloat toorow(float x, float y, float step)\n{\n    float x1 = x;\n    float y1 = y*0.5 + 0.5;\n    float x2 = mod(x + step, 1.0);\n    float y2 = y*0.5;\n    float dl1 = scale5(x1, y1);\n    float dl2 = scale5(x2, y2);\n    return max(dl1, dl2);\n}\n\nfloat sdArtichoke(vec3 p, float r)\n{\n    float l = length(p.xy);\n    float d = length(p)-r;\n    \n    float n = 10.;\n    float m = 8.;\n    float step = 0.5;\n    \n    float y = (atan(l, p.z) + PI/2.)/PI;\n    //float y = 1. - (p.z + r)/2./r; \n    float x = mod(atan(p.y, p.x), TAU)/TAU;\n    float row = floor(y*n);\n    y = y*n - row;\n    \n    float shift = mod(step*row, 1.0);\n    x = mod(x - shift/m, 1.0);\n    x = fract(x*m);\n    float dl = toorow(x, y, step);\n    d*=0.3;\n    d -= dl;\n    return d;\n}\n\n\nfloat M(vec3 p)                                     // map: sdCeli\n{\n   //p.yz *= r( t);\n   p.xy *= r(-t);\n   return sdArtichoke(p, .8);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 m, R = iResolution.xy, e = vec2(1,-1)/1e4;\n    t = iMouse.z > 0. ? m = ( 2.*iMouse.xy - R ) / R.y, 0. // mouse or auto-demo\n                      : iTime;\n  \n    vec3 p = vec3(0., 2., 0.);                               // camera\n    p.yz *= r(m.y*PI);                            // camera rotation\n    p.xz *= r(m.x*TAU);\n   \n    int k; \n    \n    #if HW_PERFORMANCE==0\n    #define A 1\n    #else\n    #define A 2\n    #endif    \n                                      // antialiasing AxA\n    for( O *= 0.; k < A*A; k++ )\n    {   vec3 p = p, \n             n = N(-p),\n             r = N(vec3(n.z,0,-n)),                 // ray direction\n             d = N(   mat3( r, cross(n,r), n )\n                    * vec3( ( 2.*( U +vec2(k%A,k/A)/float(A)-.5 ) - R ) / R.y, 1.5 ) \n                  );\n   \n        float t, E = .001, h = E;                   // --- ray-march\n        for (int i; i++ < 128 && h >= E && t < 5. ; )\n            t += h = M( p += d*h );    \n        \n        t < 5. ?                                    // if hit:\n            n = N( e.xyy* M(p + e.xyy ) +           // normal\n                   e.yyx* M(p + e.yyx ) + \n                   e.yxy* M(p + e.yxy ) + \n                   e.xxx* M(p + e.x   ) ),  \n            O +=  vec4(.2  ,.3,.4 ,0) * (.5 + .5*dot( n, vec3(0, .7,-.7)) )     // ambiant\n                + vec4(.85,.75,.65,0) * max(     dot( n, vec3(0, .7, .7)), .2 ) // diffuse\n          : O ;\n    }\n\n    O = sqrt( O ) / float(A);                       // sRGB\n}","name":"Image","description":"","type":"image"}]}