{"ver":"0.1","info":{"id":"4cBXDV","date":"1711385072","viewed":211,"name":"Mandelbulb classic path traced","username":"sedenion","description":"simple path traced mandelbulb with no color, no effects and using uniform sampling","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["ray","mandelbulb","marching","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture(iChannel0,fragCoord/iResolution.xy);\n    color.xyz = pow(color.xyz/color.w, vec3(1.0/2.2));\n    fragColor = vec4(color.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEP 255\n#define MIN_DIST 0.001\n#define MAX_DIST 100.\n#define MAX_BOUNCE 5\n\nstruct HitRecord{\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nfloat sdMandelbulb(vec3 pos, int maxIterations, float bailout, float power) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < maxIterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat sdPlane(vec3 p, float h){\n    return p.y-h;\n}\n\nfloat sdScene(vec3 p){\n    int maxIterations = 50;\n    float bailout = 100.0;\n    float power = 8.0;\n    \n    return min(sdMandelbulb(p,  maxIterations, bailout, power),sdPlane(p, -1.));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.00005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\n\nbool rayMarch(Ray ray, inout HitRecord hit){\n    float totalDistance = 0.;\n    \n    int i;\n    vec3 p;\n    for(i=0; i<MAX_STEP; i++){\n        p = ray.origin + totalDistance*ray.direction;\n        float currentDistance = sdScene(p);\n        totalDistance += currentDistance;\n        \n        if(currentDistance < MIN_DIST || totalDistance > MAX_DIST){\n            totalDistance-=MIN_DIST;\n            break;\n        }\n    }\n    \n    if(totalDistance>MAX_DIST){\n        return false;\n    }\n    p = ray.origin + totalDistance*ray.direction;\n    hit.position = ray.origin + 0.99*totalDistance*ray.direction;\n    hit.normal = calcNormal(p);\n    return true;\n}\n\nvec3 render(Ray ray){\n    vec3 backgroundColor = vec3(0.8,0.9,1.);\n    Ray currentRay = ray;\n    HitRecord hit;\n    vec3 attenuation  = vec3(1);\n    \n    for(int i = 0; i<MAX_BOUNCE; i++){\n        if(!rayMarch(currentRay, hit)){\n            return attenuation*backgroundColor; //texture(iChannel0, -currentRay.direction).rgb;\n        }\n        currentRay.origin = hit.position;\n        currentRay.direction = hit.normal+random_in_unit_sphere(g_seed);\n        attenuation *= 0.8;\n    }\n    return vec3(0);\n}\n\nvec3 getRayDirection(vec2 uv, vec3 origin, vec3 direction){\n    float focalLength = 1.;\n    float vfov = 90.; //vertical field of view\n    \n    float h = focalLength * tan(radians(vfov)/2.); // half of vertical sensor size\n    \n    vec3 fixedUp = vec3(0,1,0);\n    vec3 front = normalize(direction - origin);\n    vec3 right = -normalize(cross(front, fixedUp));\n    vec3 up = cross(front, right);  \n    \n    return normalize(h*uv.x*right + h*uv.y*up + front*focalLength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.xy - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy - 0.5)*5.5;\n    mouse.y*=-1.;\n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    \n    vec3 col = vec3(0,0,0);\n    \n    vec3 rayOrigin = vec3(sin(mouse.x)*cos(mouse.y),sin(mouse.y+0.5),cos(mouse.x)*cos(mouse.y))*1.5;\n    vec3 lookAtDirection = vec3(0,0,0);\n    \n    vec3 rayDirection = getRayDirection(uv, rayOrigin, lookAtDirection);\n    \n    Ray ray;\n    ray.origin = rayOrigin;\n    ray.direction = rayDirection;    \n    \n    col += render(ray); \n    \n    vec4 lastFrame;\n    if (iMouse.z > 0.0){\n        lastFrame = vec4(0);\n    }else{\n        lastFrame = texture(iChannel1, fragCoord/iResolution.xy);\n    }\n    \n    \n    fragColor = vec4(col,1.0)+lastFrame;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n","name":"Common","description":"","type":"common"}]}