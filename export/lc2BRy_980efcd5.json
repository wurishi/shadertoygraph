{"ver":"0.1","info":{"id":"lc2BRy","date":"1725409706","viewed":33,"name":"Colorblindness filter","username":"devdeltek","description":"A filter that mimics what colorblind people see following a daltonlens article I found. Seems to give decent results when compared to the simulation on the daltonlens website.\n\nhttps://daltonlens.org/understahttps://daltonlens.org/colorblindness-simulator","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["filter","colorblind"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nIn an inital test I tried just moving from the sRGB colorspace to \nthe LMS colorspace directly and changing one of the rods to 0, but\nit didn't turn out too good. Doing some more research I found this article\nhttps://daltonlens.org/understanding-cvd-simulation/ doing some more \nresearch and will try to follow its steps to get a better result.\n\nFirst we convert from sRGB to linear sRGB, as sRGB compenstates for quirks\nin display technology, making it imperfect for image processing.\n\nNext step is to convert from Linear sRGB to CIE XYZ, as CIE XYZ was standardized early\nin color research and has been used for research since then. The method of anaylsis\nused in the paper relies on research using the CIE XYZ color space, so we need to be in\nthat color space to as well.\n\nFinally we can convert into the LMS colorspace. This is a matrix transformation, and can\nbe combined with the transformation from the previous step.\n\nOnce we are in LSM we can use the the matrix transformations found in the article to convert\ncolors from the 3d colorspace to a color that falls onto the 2d plane that mkes up colorblind\nvision, then linearly interpolate from the original color to the new color based on a severity\n\nLastly we translate back to srgb to get the final output color\n*/\n\n//setup variables\nconst int none = 0;\nconst int protan = 1;\nconst int duetan = 2;\nconst int tritan = 3;\n//neutral color point to use as white point\nconst vec3 srgbNeutral = vec3(0.8, 0.8, 0.8);\n\n\n\n//--------------Change for different Outputs -----------------\n\n//Number corresponding to type of colorblindness\nconst int leftType = none;\nconst int rightType = protan;\n\n//true for Brettel 1997 model, false for Vienot 1999 model\nconst bool left1997 = true;\nconst bool right1997 = true;\n\n\n// severity from 0 to 1\nconst float leftSeverity = 0.;\nconst float rightSeverity = 1.;\n\n\n\n// ------------- Color Space transformations --------------\n\n\n//Convert from a linear RGB colorspace to a LMS color space\nmat3 ToLms = mat3(17.8820413,  3.45564232,  .02995656,\n                  43.51609057, 27.15538246, .18430896,\n                  4.11934969,  3.86713084,  1.46708614);\n\n//convert form a LMS color space to a RGB colorspace\nmat3 FromLms = mat3(0.0809,   -.0102485,  -0.0003652,\n                   -.1305043,    .0540193,  -0.0003652,\n                    0.1167,   -.1136147,   .6935132);\n\n\n//-------------- Colorblind color transformations -----------------\n\n//Transform a LMS color to the color somebody with protan would see\n//Follows the 1999 Vienot paper\nconst mat3 toProtanSimple = mat3(0.,          0., 0.,\n                                 2.02344377,  1., 0.,\n                                -2.52580405,  0., 1.);\n\nconst mat3 toDuetanSimple = mat3(1., 0.49420696, 0.,\n                                 0., 0.,         0.,\n                                 0., 1.24826995, 1.);\n                          \nconst mat3 toTritanSimple = mat3(1., 0., -0.01224491,\n                                 0., 1., 0.07203435,\n                                 0., 0., 0.         );\n                          \n\nconst mat3 toProtan475 = mat3(0.,          0., 0.,\n                              2.27376148,  1., 0.,\n                             -5.92721645,  0., 1.);\n                       \nconst mat3 toProtan575 = mat3(0.,          0., 0.,\n                              2.18595384,  1., 0.,\n                             -4.10029338,  0., 1.);\n                       \nconst mat3 toDuetan475 = mat3(1.,  0.43979987, 0.,\n                              0.,  0.,          0.,\n                              0.,  2.60678902, 1.);\n                        \nconst mat3 toDuetan575 = mat3(1.,  0.4574662,  0.,\n                              0.,  0.,          0.,\n                              0.,  1.87574564, 1.);\n                        \nconst mat3 toTritan485 = mat3(1.,  0.,  -0.05574292,\n                              0.,  1.,   0.15892917,\n                              0.,  0.,   0.        );\n                        \nconst mat3 toTritan585 = mat3(1.,  0.,  -0.00254865,\n                              0.,  1.,   0.0531321,\n                              0.,  0.,   0.        );\n\n//------------Methods to translate to linear srgb---------\n\n\n//using Method from sRGB Wikipedia\nvec3 SrgbToLinear(in vec3 sRgb){\n    vec3 lin = vec3(0,0,0);\n    \n    if(sRgb.x <= 0.04045){\n         lin.x = sRgb.x/12.92;\n    }\n    else{\n        lin.x = pow(((sRgb.x+0.055)/1.055), 2.4);\n    }\n    \n    if(sRgb.y <= 0.04045){\n         lin.y = sRgb.y/12.92;\n    }\n    else{\n        lin.y = pow(((sRgb.y+0.055)/1.055), 2.4);\n    }\n    \n    if(sRgb.z <= 0.04045){\n         lin.z = sRgb.z/12.92;\n    }\n    else{\n        lin.z = pow(((sRgb.z+0.055)/1.055), 2.4);\n    }\n    return lin;\n}\n\n\n vec3 LinearToSrgb(in vec3 lin){\n    vec3 sRgb = vec3(0,0,0);\n    \n    if(lin.x <= 0.0031308){\n         sRgb.x = lin.x * 12.92;\n    }\n    else{\n        sRgb.x = 1.055 * (pow(lin.x, 1./2.4)) -0.055;\n    }\n    \n    if(lin.y <= 0.0031308){\n         sRgb.y = lin.y*12.92;\n    }\n    else{\n        sRgb.y = 1.055 * (pow(lin.y, 1./2.4)) -0.055;\n    }\n    \n    if(lin.z <= 0.0031308){\n         sRgb.z = lin.z*12.92;\n    }\n    else{\n        sRgb.z = 1.055 * (pow(lin.z, 1./2.4)) -0.055;\n    }\n    return sRgb;\n}\n\n// ------------------ Functions for colorblind conversion ------------\nvec3 toProtan(in vec3 col, vec3 whitePoint, bool m1997){\n    if(!m1997){\n        col = toProtanSimple * col;\n    }\n    else{\n        if(col.z/col.y < whitePoint.z/whitePoint.y){\n            col = toProtan475 * col;\n        }\n        else{\n            col = toProtan575 * col;\n        }\n    }\n    return col;\n}\n\nvec3 toDuetan(in vec3 col, vec3 whitePoint, bool m1997){\n    if(!m1997){\n        col = toDuetanSimple * col;\n    }\n    else{\n        if(col.z/col.x < whitePoint.z/whitePoint.x){\n            col = toDuetan475 * col;\n        }\n        else{\n            col = toDuetan575 * col;\n        }\n    }\n    return col;\n}\n\nvec3 toTritan(in vec3 col, vec3 whitePoint, bool m1997){\n    if(!m1997){\n        col = toTritanSimple * col;\n    }\n    else{\n        if(col.y/col.x < whitePoint.y/whitePoint.x){\n            col = toTritan485 * col;\n        }\n        else{\n            col = toTritan585 * col;\n        }\n    }\n    return col;\n}\n\n\n//Function to find if pixel falls on the line\nfloat aastep(float edge, float x)\n{\n    float aawidth = 0.7 * fwidth(x);\n\treturn smoothstep(edge - aawidth, edge + aawidth, x);\n}\n\nvec3 linearInterpolation(in vec3 original, in vec3 processed, float severity){\n    vec3 final = (1.-severity) * original + severity * processed;\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //get a video as a texture\n    vec4 imageIn = texture(iChannel0, uv);\n    \n    // Time varying pixel color\n   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 col = imageIn.rgb;\n    vec3 orig = col;\n       \n    \n    //First need to convert from sRGB to LinearRGB\n    col = SrgbToLinear(col);\n\n    //then to LMS\n    col = ToLms * col;\n    \n    //do the same for the white point\n    vec3 lmsNeutral = ToLms * SrgbToLinear(srgbNeutral);\n\n    \n    //then do the transformation for colorblindness\n    vec3 lCol = col;\n    vec3 rCol = col;\n    \n    switch(leftType){\n        case 1:\n            lCol = toProtan(col, lmsNeutral, left1997);\n            break;\n        case 2:\n            lCol = toDuetan(col, lmsNeutral, left1997);\n            break;\n        case 3:\n            lCol = toTritan(col, lmsNeutral, left1997);\n            break;\n        default:\n            lCol = col;\n    }\n    \n    switch(rightType){\n        case 1:\n            rCol = toProtan(col, lmsNeutral, right1997);\n            break;\n        case 2:\n            rCol = toDuetan(col, lmsNeutral, right1997);\n            break;\n        case 3:\n            rCol = toTritan(col, lmsNeutral, right1997);\n            break;\n        default:\n            rCol = col;\n    }\n    \n    //linear interpolation for severity\n    lCol = linearInterpolation(col, lCol, leftSeverity);\n    rCol = linearInterpolation(col, rCol, rightSeverity);\n    \n    \n    \n    lCol = FromLms * lCol;\n    rCol = FromLms * rCol;\n    \n    lCol = LinearToSrgb(lCol);\n    rCol = LinearToSrgb(rCol);\n    \n    \n    //add a slider to see if what I'm doing is actually working\n    \n    float slider_pos = iMouse.z > 0.0 ? iMouse.x : iResolution.x / 2.0;\n    float slider_dist = fragCoord.x - slider_pos;\n    vec3 slider_color = vec3(0.4, 0.0, 0.8);\n    col = slider_dist < 0.0 ? lCol : rCol;\n    col = mix(slider_color, col, aastep(2.0, abs(slider_dist)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n//https://daltonlens.org/understanding-cvd-simulation/\n//https://arxiv.org/pdf/1711.10662\n//https://www.shadertoy.com/view/wtlSWB - borrowed the slider from this\n//https://vision.psychol.cam.ac.uk/jdmollon/papers/Dichromatsimulation.pdf\n//https://www.inf.ufrgs.br/%7Eoliveira/pubs_files/CVD_Simulation/Machado_Oliveira_Fernandes_CVD_Vis2009_final.pdf","name":"Image","description":"","type":"image"}]}