{"ver":"0.1","info":{"id":"DslBDn","date":"1688663070","viewed":57,"name":"CoolRT","username":"ativata","description":"rt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU 6.283185\n#define NUM_BOUNCES 30\n#define RESOLUTION 20\n\nstruct sphere{\n    vec3 pos;\n    float rad;\n    \n    bool emissive;\n    vec3 color;\n    \n    float roughness;\n\n};\nfloat random (float randseed) {\n        float rand = fract(sin(dot(vec2(randseed , randseed),\n                         vec2(12.9898,12.9898)))*\n        43758.5453123);\n        \n        return rand * 200.;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nfloat hit_sphere(vec3 center, float radius,vec3 ro,vec3 rd) {\n    vec3 oc = ro - center;\n    float a = dot(rd,rd);\n    float half_b = dot(oc, rd);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = half_b*half_b - a*c;\n\n    if (discriminant < 0.) {\n        return -1.0;\n    } else {\n        return (-half_b - sqrt(discriminant) ) / a;\n    }\n}\nvec3 GetSphereNormal(vec3 hp,vec3 so){\n    return normalize(hp - so);\n}\nvec3 GetRandVec3(vec3 inp){\n    return vec3(random(fract(iTime) + inp.x),random(fract(iTime) + inp.y),random(fract(iTime) + inp.z));\n}\nvec3 ToGrayscale(vec3 inp){\n    return vec3(0.21 * inp.r + 0.71 * inp.g + 0.07 * inp.b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set shit up\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    vec3 ro = vec3(0, 5, -5);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = vec3(1);\n    vec3 light = vec3(0);\n    \n    float light_intensity = 1.;\n    \n    sphere spheres[] = sphere[](\n        sphere(vec3(-1,0,0),.5,true,vec3(1,0,0),0.),\n        sphere(vec3(0,0,0),.5,true,vec3(0,1,1),0.),\n        sphere(vec3(1,0,0),.5,true,vec3(0,0,1),0.),\n        \n        sphere(vec3(0,101,0),100.,false,vec3(.3,.3,.3),20.),\n        sphere(vec3(0,-101,0),100.,false,vec3(.3,.1,.1),20.)\n    );\n    \n    for(int i; i < NUM_BOUNCES;i++){\n        float t = 1000.;\n        sphere sp;\n        for(int j; j < spheres.length();j++){\n            float t2 = hit_sphere(spheres[j].pos,spheres[j].rad,ro,rd);\n            if(t2 < t && t2 > 0.){\n                t = t2;\n                sp = spheres[j];\n            }\n        }\n        if(t > 0. && t < 1000.){\n            vec3 p = ro + rd * t;\n            vec3 n = GetSphereNormal(p,sp.pos);\n            \n            vec3 r = reflect(rd, n) * normalize(GetRandVec3(p) * sp.roughness);\n            float dif = dot(n, rd)*.5+.5;\n            \n            if (sp.emissive){\n                light += sp.color;\n            }\n            col *= sp.color;\n            \n            \n                \n         \n            ro = p;\n            rd = r;\n            \n        }else{\n            light += texture(iChannel0,rd).rgb;\n            break;\n        }\n    }\n    \n    fragColor = vec4(light * col,1.0);\n}","name":"Image","description":"","type":"image"}]}