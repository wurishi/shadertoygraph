{"ver":"0.1","info":{"id":"NljfRw","date":"1652448946","viewed":225,"name":"sdf tracing framework ","username":"fancyzero","description":"SDF tracing framework\na better and optimized version is here\nhttps://www.shadertoy.com/view/NsdcD4","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdftracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//for better quality\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n#define ZERO (min(iFrame,0))\n//for debug purpose\n#define DRAW_RAYS \n\n\n#define STEPS 30\n\n\nfloat FresnelRef(float b, float c) \n{\n    return .5 * (pow(tan(b - c) / tan(b + c), 2.) + sqrt(sin(b - c)) / sqrt(sin(b + c))); \n}\n\nvec2 Snell( float n1, float n2, float t1) \n{ \n\n    float t2 = asin(n1 / n2 * sin(t1)); \n    \n    float R = FresnelRef(abs(t1), abs(t2)); \n    return vec2(t2, 1.-clamp(0.,1.,R));\n}\n\n\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n    float bL = length(lE - lS);\n    if ( bL < 0.00001)\n        return 10000.0;\n    vec3 bD = (lE - lS) / bL;\n    vec3 tD = lS - rP;\n    float aDb = dot(rD, bD);\n    \n    float aDt = dot(rD, tD);\n    float bDt = dot(bD, tD);\n    float u = (aDt - bDt * aDb) / (1.- aDb * aDb);\n    float v = max(min(u * aDb - bDt, bL), 0.);\n    u = max(min(v * aDb + aDt, 1e6), 0.);\n    return length((rP + rD * u) - (lS + bD * v));\n}\n\n\n\nvec4 drawLine(vec3 start, vec3 dir, vec3 a, vec3 b , vec4 color, vec4 fragColor)\n{\n    float d = RayLineSegmentDistance(start, dir, a, b);\n    return mix( color, fragColor, smoothstep(0.01,0.012,d));\n\n}\n \n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\n    //float aa = length(p+vec3(0.5,0,0)) - 1.;\n    //float bb = length(p-vec3(0.5,0,0)) - 1.;\n    //return min(aa,bb);\n    b-=vec3(r);\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n\nmat3x3 LookAt( vec3 src, vec3 target, vec3 up)\n{\n    vec3 forward = normalize(target-src);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3x3(right, up, forward);\n}\n\n\nstruct TraceResult\n{\n    vec3 pos;\n    float d;\n    float iters;\n    float lastD;\n    bool hit;\n};\n\n\n\nfloat map( vec3  p)\n{\n    float r = mix(0.01,0.5,smoothstep(-1.,1.,sin(iTime)));\n\n    float d1 = sdRoundBox(p + vec3(0, 0., 0), vec3(1. ,1,1.) , r);\n\n\n    return d1;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float eps = 0.002;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e);\n    }\n    return normalize(n);\n}\n\n\nTraceResult trace( vec3 start, vec3 dir, float maxLength, float _sign )\n{\n    TraceResult tr;\n    tr.hit = false;\n    tr.pos = start;\n    float traveled = 0.;\n    for ( int i = 0; i < STEPS; i++ )\n    {\n        \n        float d = map(tr.pos);\n        \n            tr.lastD = sign(d);\n        if ( abs(d) < 0.01)\n        {\n            tr.d = length(start-tr.pos);\n            \n            tr.iters = float(i)/float(STEPS);\n            \n            tr.hit = true;\n            return tr;\n        }\n        tr.pos += dir*abs(d);\n        traveled += abs(d);\n        if ( traveled > maxLength )\n            return tr ;\n        \n    }\n    return tr;\n}\n\n\nconst float airIOR = 1.0;\nconst float glassIOR = 1.5;\n\nstruct Segment\n{\n    vec3 start;\n    vec3 end;\n    float intensity;\n    bool hit;\n};\n\nSegment[6] rayTrace( vec3 start, vec3 dir, int depth, out int validSegments )\n{\n    dir = normalize(dir);\n    Segment[6] segments;\n    \n    validSegments = 0;\n        float iorA = 1.5;\n        \n        float iorB = 1.;\n    for( int i = 0; i < 5; i++ )\n    {\n        TraceResult tr = trace(start, dir, 10., 1.);\n\n        segments[i].start = start;\n        segments[i].end = tr.pos;\n        segments[i].hit = tr.hit;\n        \n\n\n        vec3 n = getNormal(tr.pos);\n        \n        \n        if ( i == 0)\n        {\n            vec2 snell = Snell( iorB, iorA, acos(dot(dir,-n)));\n            segments[5].start = tr.pos;\n            segments[5].end = reflect(dir, n) + tr.pos;\n            segments[5].intensity = 1.-snell.y;\n        }        \n        \n        if (tr.hit)\n            validSegments ++ ;\n        else\n            return segments;        \n\n        vec3 newDir = vec3(0);\n\n        if ( tr.lastD > 0. )\n        {\n            newDir = refract(dir,n,iorB/iorA);\n            \n        }\n        else\n        {\n            newDir = refract(dir,-n,iorA/iorB);\n\n        }\n        \n        \n        if ( dot(newDir,newDir) < 0.0001) //total internal reflection\n        {\n            newDir = reflect(dir, -n);\n            start = tr.pos + tr.lastD*n*0.02;;\n        }\n        else\n        {\n            start = tr.pos + -tr.lastD*n*0.02;;\n        }\n        dir = newDir;\n        \n    }\n\n\n      \n    return segments;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 txtUV = uv;\n\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if (iFrame == 0 )\n        mousePos = vec2(0.6,0.2);\n\n    vec3 cam = vec3(4., 4., 4.);\n    float near = 0.1;\n    float fov = 60.0;\n    float aspect = iResolution.y / iResolution.x;\n    float w = 2.* near / sqrt(3.);\n    float h = aspect * w;\n\n    vec3 vlt = vec3(-w / 2., -h / 2., near);\n    vec3 vrb = vec3(w / 2., h / 2., near);\n\n    \n    float theta = mousePos.x * 4.*3.14;\n    float phi = (1.-mousePos.y)*3.14*2.;\n    cam = vec3(cos(theta) * sin(phi),\n           cos(phi),\n            sin(theta) * sin(phi)) * 7.6;\n    vec4 allColor = vec4(0.);\n    for ( int m =0; m < AA; m++ )\n    {\n        for ( int k =0; k < AA; k++ )\n        {\n            float ox = 1./iResolution.x/float(AA)*float(m);\n            float oy= 1./iResolution.y/float(AA)*float(k);\n            vec3 rayDir = vec3(mix(vlt.x, vrb.x, uv.x+ox), mix(vlt.y, vrb.y, uv.y+oy), near);\n\n            rayDir = normalize(rayDir);\n\n            mat3x3 rot = LookAt(cam, vec3(0., 0., 0.), vec3(0., 1., 0.));\n            rayDir = normalize(rot * rayDir);\n\n\n\n            int validSegments;\n            Segment[6] segments = rayTrace(cam, rayDir, 0, validSegments);    \n            vec4 bg = texture(iChannel0, ( rayDir) );\n            vec4 box = vec4(0.);\n            //segments[5] contains the reflected fraction of the first bounce\n            if (validSegments > 0)\n            {\n                fragColor = texture(iChannel0, normalize(segments[validSegments-1].end-segments[validSegments-1].start)) *(1.- segments[5].intensity);\n                fragColor += (texture(iChannel0 , normalize(segments[5].end-segments[5].start)))*segments[5].intensity;\n            }\n            else \n            {\n                fragColor = bg;\n            }\n            \n\n            allColor += fragColor;\n        }\n     }  \n    \n    fragColor = allColor/float(AA*AA);    \n    \n    \n#if defined DRAW_RAYS        \n    uv = fragCoord / iResolution.xy;\n    vec3 rayDir = vec3(mix(vlt.x, vrb.x, uv.x), mix(vlt.y, vrb.y, uv.y), 0.1);\n    mat3x3 rot = LookAt(cam, vec3(0., 0., 0.), vec3(0., 1., 0.));\n    rayDir = normalize(rot * rayDir);\n    \n\n    int validSegments = 0;\n    vec3 start = vec3(-2.5,0,0);\n    \n    float alpha = 2.;\n    float n = 15.;\n    float phi2 = (sqrt(5.)+1.)*0.5;\n    //demostrate some rays that evenly distributed\n    for( int j = 0; j < int(n) ; j++ )\n    {\n        float b = round(alpha*sqrt(n));  \n        float r = 1.;\n        if (float(j) > n-b)\n            r = 1.;\n        else\n            r =  sqrt(abs(float(j)-0.5))/sqrt(n-(b+1.)/2.);  \n        float theta2 = 2.*3.1415926*float(j)/(phi2*phi2);  \n        \n        vec3 dir = normalize(vec3(2.,r*cos(theta2), r*sin(theta2)));\n        Segment[6] segments = rayTrace(start, dir, 0, validSegments);\n        for( int i = 0; i <min(4,validSegments+1); i++ )\n        {\n            vec4 lineColor = mix( vec4(0.059,0.902,0.114,1), vec4(0.933,0.067,0.486,1), float(i)/float(validSegments+1));\n            fragColor = drawLine(cam,rayDir, segments[i].start, segments[i].end,lineColor,fragColor);\n        }\n        \n        //fragColor = drawLine(cam,rayDir, segments[5].start, segments[5].end,vec4(0.5,0.5,0.5,1.),fragColor);\n    }\n#endif    \n\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}