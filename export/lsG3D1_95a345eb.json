{"ver":"0.1","info":{"id":"lsG3D1","date":"1454311666","viewed":3362,"name":"Advection filter comparison","username":"sebbbi","description":"Comparison of different image filters for bitmap advection. Useful for example with temporal re-projection.","likes":33,"published":1,"flags":32,"usePreview":1,"tags":["2d","bicubic","advection","smoothstep","reprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Advection filter comparison by Sebastian Aaltonen 2016\n\n// Code for bicubic and smoothstep filters created by Inigo Quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original code here: https://www.shadertoy.com/view/XsSXDy\n// Thanks to Inigo for letting me use his filtering code for this comparison. Saved me a lot of time!\n\n#define circ(j) length(fragCoord/iResolution.y-vec2(1.5,float(j)/8.+.5/8.))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor.rgb = texture(iChannel0, uv).rgb;\n    \n    // Mode visualization\n    for (int i=0; i<8; i++)\n\t\tfragColor += smoothstep(.005,.0,abs(circ(i)-.05));\n  \tfragColor.r += smoothstep(.05,.04,circ(texture(iChannel0, .5/iResolution.xy).a));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Advection filter comparison by Sebastian Aaltonen 2016\n\n// Code for bicubic and smoothstep filters created by Inigo Quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original code here: https://www.shadertoy.com/view/XsSXDy\n// Thanks to Inigo for letting me use his filtering code for this comparison. Saved me a lot of time!\n\nconst int modeGroundTruth = 0;\nconst int modeBilinear = 1;\nconst int modeSmootherstep = 2;\t\t\t// Perlin's quintic smootherstep\nconst int modeCubic_Hermite = 3;\t\t// Hermite (B=0, C=0)\nconst int modeCubic_BSpline = 4;\t\t// B-spline (B=1, C=0)\nconst int modeCubic_Mitchell = 5;\t\t// Mitchell (B=1/3, C=1/3)\nconst int modeCubic_CatmullRom = 6;\t\t// Catmull-Rom (B=0, C=1/2)\nconst int modeCubic_Photoshop = 7;\t\t// Photoshop (B=0, C=3/4)\nconst int modeMax = 8;\n\n// Select the mode with this. Set -1 for automatic scrolling.\nint renderMode = -1;\n\n// Hermite = cubic with B=0 & C=0 (also known as smoothstep)\nvec4 textureHermite(sampler2D tex, vec2 uv, vec2 res)\n{\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\n\tuv = (uv - 0.5)/res;\n\treturn texture( tex, uv );\n}\n\n// Perlin's smootherstep (quintic)\n// https://en.wikipedia.org/wiki/Smoothstep\nvec4 textureSmootherstep(sampler2D tex, vec2 uv, vec2 res)\n{\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);\n\tuv = (uv - 0.5)/res;\n\treturn texture( tex, uv );\n}\n\nvec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nvec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nvec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nvec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nvec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nvec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\nvec4 PS_A = vec4(   1.25,-2.25,   0.0,  1.0 ) /  1.0;\nvec4 PS_B = vec4(  -0.75, 3.75,  -6.0,  3.0 ) /  1.0;\n\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca, cb;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = iChannelResolution[1].xy;\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\nfloat angleAtFrame(int frame)\n{\n    float time = float(frame) / 60.0;\n    return time * 3.1;\n}\n\nvec2 screenToUv(vec2 uv, float angle)\n{\n    vec2 b0 = vec2(sin(angle), -cos(angle));\n    b0 = normalize(b0);\n    vec2 b1 = vec2(-b0.y, b0.x);\n    \n    vec2 uvCenter = uv - 0.5;\n    uvCenter.x *= (iResolution.x / iResolution.y);\n    uvCenter *= 1.5;\n    return b0 * uvCenter.x + b1 * uvCenter.y + 0.5;\n}\n\nvec2 uvToScreen(vec2 uv, float angle)\n{\n    vec2 b0 = vec2(sin(-angle), -cos(-angle));\n    b0 = normalize(b0);\n    vec2 b1 = vec2(-b0.y, b0.x);\n    \n    vec2 uvCenter = uv - 0.5;\n    uvCenter = b0 * uvCenter.x + b1 * uvCenter.y;\n    uvCenter /= 1.5;    \n    uvCenter.x *= (iResolution.y / iResolution.x);\n    return uvCenter + 0.5;\n}\n\nvec3 sampleBlackBorders(vec2 uv)\n{\n    if (length(clamp(uv, vec2(0.0, 0.0), vec2(1.0, 1.0)) - uv) == 0.0)\n    {\n        return texture(iChannel0, uv).xyz;\n    }\n    else\n    {\n        return vec3(0, 0, 0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    \n    // Modulo / bitwise AND are not supported in WebGL (hacking around)\n    int loopCount = (iFrame / 128);\n    int frame = iFrame - loopCount * 128;\t\t\t// modulo\n    loopCount -= (loopCount / modeMax) * modeMax;\t// modulo\n    int rMode = renderMode >= 0 ? renderMode : loopCount;\n    \n     // Mode visualization\n    if (fragCoord==vec2(.5)) fragColor.a = float(rMode);\n    \n    // Rotate for 64 frames, show result for 64 frames\n    if (frame > 64)\n    {\n        fragColor.xyz = texture(iChannel1, screen).xyz;\n        return;\n    }\n    \n    if (rMode == modeGroundTruth)\n    {\n        // Ground truth simply rotates the original image\n        float angle = angleAtFrame(frame);\n\t    vec2 uv = screenToUv(screen, angle);\n\t    screen = uvToScreen(uv, angle);\n\t    uv = screenToUv(screen, angle);\n    \tfragColor.xyz = sampleBlackBorders(uv);            \n    }\n    else\n    {    \n        if (frame == 0)\n        {\n            // Blit startup image at 0 angle\n            float angle = angleAtFrame(0);\n\t    \tvec2 uv = screenToUv(screen, angle);\n    \t\tfragColor.xyz = sampleBlackBorders(uv);   \n        }\n        else\n        {\n            // Rotate every frame by the same angle\n            float angleDif = angleAtFrame(1) - angleAtFrame(0);\n            \n\t    \tvec2 uvPrev = screenToUv(screen, angleDif);\n\t    \tvec2 screenPrev = uvToScreen(uvPrev, 0.0);\n            screenPrev = 1.0 - screenPrev;\n            \n            if (rMode == modeBilinear)\n                fragColor.xyz = texture(iChannel1, screenPrev).xyz;\n\n            if (rMode == modeSmootherstep)\n            \tfragColor.xyz = textureSmootherstep(iChannel1, screenPrev, iChannelResolution[1].xy).xyz;\n            \n            if (rMode == modeCubic_Hermite)         \n                fragColor.xyz = textureHermite(iChannel1, screenPrev, iChannelResolution[1].xy).xyz;\n           \n            if (rMode >= modeCubic_BSpline)\n            {\n                if (rMode == modeCubic_BSpline) { ca=BS_A; cb=BS_B; }\n                if (rMode == modeCubic_Mitchell) { ca=RE_A; cb=RE_B; }\n                if (rMode == modeCubic_CatmullRom) { ca=CR_A; cb=CR_B; }\n                if (rMode == modeCubic_Photoshop) {ca=PS_A; cb=PS_B; }\n                fragColor.xyz = texture_Bicubic(iChannel1, screenPrev).xyz;\n            }\n        }\n \n    }\n}","name":"Buf A","description":"","type":"buffer"}]}