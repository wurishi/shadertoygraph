{"ver":"0.1","info":{"id":"l3c3Dl","date":"1717128557","viewed":66,"name":"SDF Interior (3x Circle)","username":"eclipixie","description":"(fork)\n\nChecking some miscellaneous things about the current approach of finding an exact union.\nhttps://www.shadertoy.com/view/XX3GDM","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"XX3GDM","parentname":"SDF Interior Dist. (Closer)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Projecting into closest object iteratively, same\n// as what's described here: https://en.wikipedia.org/wiki/Projections_onto_convex_sets#Related_algorithms\n\n// Based on this: https://www.shadertoy.com/view/lXsSWX\n    // Which is then based on this: https://www.shadertoy.com/view/slGyWt\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0));\n}\n\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1, iquilezles.org/articles/distfunctions2d\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1, iquilezles.org/articles/distfunctions2d\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2  w = abs(p)-b;\n    vec2  s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l: g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1, iquilezles.org/articles/distfunctions2d\n// yes, I did duplicate this function without realising it was implemented above.\n//\n// The union between a segment and a circle is remarkably close! IQ's method of finding\n// intersection points works well, the only issue is that I still don't know how to find\n// an alternate surface to rely on when the component SDF and the intersection point\n// are both unreliable.\n//\n// If the circle is in the direct centre of the segment, the SDF is exact excluding one point\n// at the very centre of the circle.\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d-r,q/d);\n}\n\n//---------------------------------------------------------------------\n\nvec3 sdf1( in vec2 p ) { return sdgCircle(p-vec2(-0.5, -0.25),0.7); }\nvec3 sdf2( in vec2 p ) { return sdgCircle(p-vec2( 0.1,  0.25),0.8); }\n//vec3 sdf2( in vec2 p ) { return sdgBox(p-vec2( 0.1,  0.25), vec2(0.5,0.5)); }\n//vec3 sdf2( in vec2 p ) { return sdgSegment(p,vec2(0.0,0.0),vec2(0.5,0.0),0.2); }\nvec3 sdf3( in vec2 p ) { return sdgCircle(p-vec2( 0.0, -0.7),0.5); }\n\n// This is my take on the issue of switching between the two shapes and their \n// intersecting corners. The idea is that if the nearest surface is inside another\n// object, then it should not trust the SDF of the shape.\n\n// There are still a couple of edge cases where this fails in every scenario.\n// These issues are most prominent when the side of the box is tangent to the circle\n// (change the x position of sdf1 to 0.0 and they'll appear)\n\n// What this method does very well is demonstrate where we are to trust the naive\n// union, and showing ther area in which we have to choose between the intersection\n// points or a different piece of the border of a component shape.\nfloat checkBoundary(vec2 p)\n{\n    vec3 a = sdf1(p);\n    vec3 b = sdf2(p);\n    vec3 c = sdf3(p);\n    \n    // distances\n    float ad = -a.x;\n    float bd = -b.x;\n    float cd = -c.x;\n    \n    // normals\n    vec2 an = a.yz;\n    vec2 bn = b.yz;\n    vec2 cn = c.yz;\n    \n    float probea = -max(\n        sdf1(p + bd * bn).x, \n        sdf1(p + cd * cn).x);\n    float probeb = -max(\n        sdf2(p + ad * an).x, \n        sdf2(p + cd * cn).x);\n    float probec = -max(\n        sdf3(p + ad * an).x, \n        sdf3(p + bd * bn).x);\n        \n    float out1 = min(probea, probeb);\n    float out2 = min(probeb, probec);\n    float out3 = min(probec, probea);\n    \n    return max(max(\n        out1, \n        out2), \n        out3);\n}\n\nfloat opSubtract( in vec2 p )\n{\n    vec3  a = sdf1(p);\n    vec3  b = sdf2(p);\n    vec3  c = sdf3(p);\n    float d = min( min( a.x, b.x ), c.x );\n    \n    if( d>0.0 ) return d;\n    \n    vec2 op = p;\n    \n    for( int i=0; i<32; i++ )\n    {\n        p -= (a.x*a.yz + b.x*b.yz + c.x*c.yz)/3.;\n        a = sdf1(p);\n        b = sdf2(p);\n        c = sdf3(p);\n        if( max(max(\n            abs(a.x),\n            abs(b.x)), \n            abs(c.x))<0.001 ) break;\n    }\n    \n    float dc = length(p-op); //return -dc;\n\n    float s = checkBoundary(op);\n    //return s;\n    //return d;\n    return (s<0.0) ? d : -dc;\n}\n\nfloat naiveUnion(in vec2 p)\n{\n    return min(sdf1(p).x,sdf2(p).x);\n}\n// https://iquilezles.org/articles/sdfxor/\nfloat xor(in vec2 p) {\n    return max( min(sdf1(p),sdf2(p)), -max(sdf1(p),sdf2(p)) ).x;\n}\n\nfloat map( in vec2 p )\n{\n    //return xor(p);\n    //return naiveUnion(p);\n    return opSubtract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.001 )\n    {\n        m = vec2(0.6,0.25)*sin(iTime*vec2(0.7,0.5)+vec2(0.0,2.0));\n        m = vec2(m.x-m.y,m.x+m.y);\n    }\n    \n    float d = map(p);\n\n    // show SDF\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n\tcol *= 1.0 - exp2(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.002,0.005,abs(d)) );\n\n    // show distance bound\n    {\n        float dm = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(dm))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // show search path to closest shape intersection/featurr\n    if( d<0.0 )\n    {\n        vec2 w = m;\n        float c = 1e20;\n        for( int i = 0; i<16; i++ )\n        {\n            vec3 a = sdf1(w);\n            vec3 b = sdf2(w);\n            vec2 q = w - .5*(a.x*a.yz+b.x*b.yz);\n            c = min( c, sdSegment(p,w,q)-0.005 );\n            c = min( c, length(p-w)-0.015 );\n            w = q;\n        }\n        col = mix(col, vec3(1.0,1.0,1.0), smoothstep(px, -px, c));\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}