{"ver":"0.1","info":{"id":"7dsyDN","date":"1642127977","viewed":134,"name":"simple sdf scene","username":"banbao990","description":"modified from iq' work, a toy for shadertoy.\nrefrence:\n    https://www.shadertoy.com/view/NtlSDs\n    ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_POSITION vec3(-4.30, 5.45, 0.32)\n\n// 场景数据\n// 地面: y=0\n#define DESK_PLANE 1.0\n\n#define AA 1\n#define ZERO min(iFrame, 0)\n#define PI 3.1415926\n\n//-------------------------------------------------------------------------------\n// 辅助函数\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// https://iquilezles.org/articles/sfrand\nfloat sfrand( inout int mirand ) {\n    mirand = mirand*0x343fd+0x269ec3;\n    float res = uintBitsToFloat((uint(mirand)>>9)|0x40000000u );\n    return( res-3.0 );\n}\n\n// hash by Hugo Elias(哈希函数 uint)\nuint ihash( uint n ) {\n    n = (n << 13) ^ n;\n    n = (n*(n*n*15731u+789221u)+1376312589u)&0x7fffffffu;\n    return n;\n}\n\n// hash by Hugo Elias(哈希函数 float)\nfloat hash( int n ) {\n    n = (n << 13) ^ n;\n    n = (n*(n*n*15731+789221)+1376312589)&0x7fffffff;\n    return 1.0 - float(n)*(1.0/1073741824.0);\n}\n\nfloat noise( vec3 p ) {\n    ivec3 ip = ivec3(floor(p));\n    vec3  fp = fract(p);\n\n    vec3 w = fp*fp*(3.0-2.0*fp);\n\n    int n = ip.x + ip.y*57 + 113*ip.z;\n\n    return mix(mix(mix( hash(n+(0+57*0+113*0)),\n                        hash(n+(1+57*0+113*0)),w.x),\n                   mix( hash(n+(0+57*1+113*0)),\n                        hash(n+(1+57*1+113*0)),w.x),w.y),\n               mix(mix( hash(n+(0+57*0+113*1)),\n                        hash(n+(1+57*0+113*1)),w.x),\n                   mix( hash(n+(0+57*1+113*1)),\n                        hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\n// https://iquilezles.org/articles/fbm\n// Fractional Brownian Motion(分数布朗运动)\n// 自相似性\nfloat fbm( vec3 p ) {\n#if 0\n    // original code\n    return 0.5000*noise( p*1.0 ) +\n           0.2500*noise( p*2.0 ) +\n           0.1250*noise( p*4.0 ) +\n           0.0625*noise( p*8.0 );\n#else\n    // equivalent code, but compiles MUCH faster\n    float f = 0.0;\n    float s = 0.5;\n    for( int i = ZERO; i < 4; i++ ) {\n        f += s*noise( p );\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return f;\n#endif\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min 1 (k=0.1)\n// 返回两者之间的较小值, 更加平滑\nfloat smin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0 - h); // mix(x,y,a)=x*(1-a)+y*a\n}\n\n// 返回两者之间的较大值, 更加平滑\nfloat smax(float a,float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// 返回旋转矩阵\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    // OpenGL 列优先\n    return mat2(c,s,-s,c);    // 用于右乘\n    // return mat2(c,-s,s,c); // 用于左乘\n}\n\n\n//-------------------------------------------------------------------------------\n// 基本图元\n// https://iquilezles.org/articles/distfunctions\n\n\n// 长方体\n// p: 相对长方体中心的坐标\n// b: 长方体 x,y,z 轴的放缩(初始为 [-1,1]^3)\nfloat sdBox(vec3 p, vec3 b) {\n    // 推导: https://www.youtube.com/watch?v=62-pRVZuS5c&ab_channel=InigoQuilez\n    // 到 3 个平面的距离, abs 将其化成第一象限\n    vec3 d = abs(p) - b;\n    // 左边部分: sdf<0(内部)\n    // 右边部分: sdf>0(外部)\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// 注意 udSqBox 返回的是 sdf^2\n// 长方体, 不过和长方体不一样的地方在于内部的 sdf 值都为 0\nfloat udSqBox( vec3 p, vec3 b ) {\n    float di = 0.0;\n    float dx = abs(p.x)-b.x; if( dx>0.0 ) di+=dx*dx;\n    float dy = abs(p.y)-b.y; if( dy>0.0 ) di+=dy*dy;\n    float dz = abs(p.z)-b.z; if( dz>0.0 ) di+=dz*dz;\n    return di;\n}\n\n// 圆柱体, 底盘在 y=h,y=-h 平面, 只保证外部的正确性(sdf >=0)\n// dir: 朝向(要求归一化)\n// h: 高度\n// r: 半径\nfloat sdCylinder(vec3 p, vec3 dir, float h, float r) {\n    float t = dot(p, dir);\n    float d = distance(p, dir*t); // 返回两个点之间的距离\n    // 取绝对值变为正数\n    return length( max( abs(vec2(d, t)) - vec2(r, h), vec2(0) ) );\n}\n\n// 甜甜圈(xoz)\n// 方程: (R-sqrt(x^2 + z^2))^2 + y^2 = r^2\n// R: 洞的中心到管的中心的距离\n// r: 管的半径\nfloat sdTorus(vec3 p, float R, float r) {\n    // 到线的距离减去管的半径\n    return length( vec2(length(p.xz)-R, p.y) )-r;\n}\n\n// 被切掉一段的甜甜圈(xoy)\n// ra: 洞的中心到管的中心的距离\n// rb: 管的半径\n// sc: sin(x), cos(x), x 表示甜甜圈保留部分的大小 x=[0, 3.14]\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x); // 对称, 考虑 1,4 象限\n    // 画开一个扇形, 扇形部分以下则计算到圆弧(cap)的距离, 其他计算到圆线(管)的距离\n    // 在下方 ? case1 : case2\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy, sc) : length(p.xy);\n    // 在上方, 上面的式子展开即为下式\n    // 在下方, 到 cap 球心的距离, 展开即可\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\n//-------------------------------------------------------------------------------\n\n// 桌子\nfloat sdDesk( vec3 pos ) {\n    float dist = 1e10;\n\n    // 桌面\n    dist = min(dist, sdBox( pos - vec3(0.0, DESK_PLANE-0.01, 0.0), vec3(1.0, 0.02, 1.0) ));\n    // 桌腿\n    const float[] dx = float[4]( 1.0, -1.0, -1.0,  1.0 );\n    const float[] dy = float[4]( 1.0,  1.0, -1.0, -1.0 );\n    for( int i = ZERO; i < 4; ++i ) {\n        dist = min(dist, sdBox(\n            pos - vec3(dx[i]*0.8, DESK_PLANE/2.0, dy[i]*0.8),\n            vec3(0.02, DESK_PLANE/2.0, 0.02) ));\n    };\n    return dist;\n}\n\n// 书本\nfloat sdBook(vec3 pos, out uint subMatID) {\n    float dist = 1e10;\n    subMatID = 22u;\n    pos -= vec3(-0.5, DESK_PLANE, -0.6);\n\n    dist = min(dist, sdBox(pos - vec3(0.0, 0.06, 0.0), vec3(0.15, 0.04, 0.2)));   // b1 白页\n    {\n        float d = 1e10;\n        d = min(d, sdBox(pos - vec3(0.01, 0.01, 0.0), vec3(0.16, 0.01, 0.21)));   // b1 底\n        d = min(d, sdBox(pos - vec3(0.01, 0.11, 0.0), vec3(0.16, 0.01, 0.21)));   // b1 盖\n        d = min(d, sdBox(pos - vec3(-0.15, 0.06, 0.0), vec3(0.01, 0.06, 0.21)));  // b1 侧\n        if(d < dist) {\n            dist = d; subMatID = 2u;\n        }\n    }\n\n    pos.xz *= rotmat(0.3);\n    {\n        float d = min(dist, sdBox(pos - vec3(0.0, 0.18, 0.0), vec3(0.12, 0.04, 0.15)));  // b2 白页\n        if(d < dist) {\n            dist = d; subMatID = 22u;\n        }\n    }\n    {\n        float d = 1e10;\n        d = min(d, sdBox(pos - vec3(0.01, 0.13, 0.0), vec3(0.13, 0.01, 0.16)));   // b2 底\n        d = min(d, sdBox(pos - vec3(0.01, 0.23, 0.0), vec3(0.13, 0.01, 0.16)));   // b2 盖\n        d = min(d, sdBox(pos - vec3(-0.12, 0.18, 0.0), vec3(0.01, 0.06, 0.16)));  // b2 侧\n        if(d < dist) {\n            dist = d; subMatID = 3u;\n        }\n    }\n\n\n    return dist;\n}\n\n// 杯子\nfloat sdCup(vec3 pos) {\n\n    // 杯壁 21u\n#define CUP_r 0.01\n#define CUP_R 0.07\n#define CUP_HEIGHT 0.2\n    pos -= vec3(0.7, DESK_PLANE+2.0*CUP_r, -0.8);\n    float dist = sdTorus( pos-vec3(0.0,clamp(pos.y,0.0,CUP_HEIGHT),0.0), CUP_R, CUP_r);\n\n    // 杯缘 21u\n    dist = smin(dist, sdTorus(pos-vec3(0.0,CUP_HEIGHT,0.0), CUP_R, CUP_r), 0.01);\n\n    // 杯底 21u\n    dist = smin(dist, sdCylinder(pos, vec3(0.0,1.0,0.0), CUP_r, CUP_R), 0.05);\n\n    // 杯子的把手 21u\n    vec2 sc = vec2(1.0, 0.0); // 半个甜甜圈\n    vec3 p = pos-vec3(CUP_R,CUP_HEIGHT/2.0,0.0);\n    p.xy *= mat2(0.0,-1.0,1.0,0.0); // 顺时针旋转 90 度\n    dist = smin(dist, sdCappedTorus(p, sc, CUP_HEIGHT/4.0, CUP_r), 0.01);\n\n    return dist;\n}\n\n// 行走的丑人\nfloat sdMonster(vec3 pos) {\n    float dist = 1e10;\n    // (1+abs(cos(1.8)))*0.2+0.07 = 0.31544(脚 R,r)\n    #define BODY_CENTER 0.31544\n    pos -= vec3(0.0, BODY_CENTER+DESK_PLANE, 0.0);\n    float iTimesin = sin(iTime*2.0);\n\n    // 脚\n    {\n        // 甜甜圈\n        vec3 p = pos;\n        p.xz *= rotmat(0.4*iTimesin); // 动起来\n        vec2 sc = vec2(sin(1.8), cos(1.8));\n        p.y += 0.2; // R=0.2\n        dist = sdCappedTorus(p, sc, 0.2, 0.07); // R=0.2,r=0.07\n    }\n\n    // 身体\n    {\n        // 圆柱球\n        dist = smin(dist, distance( vec3(0.0, clamp(pos.y, 0.0, 0.2), 0.0) , pos) - 0.07, 0.2);\n    }\n\n\n    pos.y -= 0.2; // 身体高度为 0.2\n    // 手\n    {\n        // 甜甜圈\n        vec3 p = pos;\n        p.xz *= rotmat(-0.5*iTimesin); // 动起来\n        vec2 sc = vec2(sin(0.45), cos(0.45));\n        p.y -= 0.5; // R=0.5, r=0.07\n        p.y = -p.y;\n        dist = smin(dist, sdCappedTorus(p, sc, 0.5, 0.07), 0.2);\n    }\n\n    pos.y -= 0.07; // 手r=0.07\n    // 头\n    {\n        // 球\n        vec3 p = pos;\n        p.y -= 0.1 + (iTimesin+1.0)*0.02;\n        dist = min(dist, distance(p, vec3(0.0,  clamp(p.y,0.0,0.02), 0.0)) - 0.1);\n    }\n\n    return dist;\n}\n\nfloat sdApple(vec3 pos, out uint subMatID) {\n    float dist = 1e10;\n    pos -= vec3(-0.6,DESK_PLANE,0.1);\n\n    #define APPLE_R 0.1\n    #define ALLPE_DOWN_OFF 0.04\n    #define ALLPE_UP_OFF 0.03\n    // 苹果\n    subMatID = 24u;\n    dist =      sdTorus( pos-vec3(0.0, 2.0*APPLE_R-ALLPE_DOWN_OFF, 0.0), APPLE_R-ALLPE_UP_OFF, APPLE_R);\n    dist = smin(sdTorus( pos-vec3(0.0,   APPLE_R-ALLPE_DOWN_OFF, 0.0), APPLE_R-ALLPE_UP_OFF, APPLE_R-ALLPE_DOWN_OFF), dist, 0.1);\n\n    // 苹果梗\n    pos.y -= (2.0*APPLE_R-ALLPE_DOWN_OFF);\n    {\n        #define APPLE_H 0.08\n        pos.y -= APPLE_H;\n        pos.xy *= rotmat(3.0*pos.y + noise(pos));\n        float d = sdCylinder(pos, vec3(0.0,1.0,0.0), APPLE_H, 0.005+0.02*pos.y);\n        if(d < dist) {\n            dist = d;\n            subMatID = 4u;\n        }\n    }\n    return dist;\n}\n\n// 场景构建\nfloat map( vec3 pos, out uint sid, out uint subMat ) {\n    subMat = 0u;           // 击中的物体的材质\n    float mindist = 1e10;  // sdf 值\n\n    //-----------------------\n    // 桌子\n    // sid=2u\n    //-----------------------\n    {\n        float dist = sdDesk(pos);\n        if(dist < mindist) {\n            sid = 2u; subMat = 1u;\n            mindist = dist;\n        };\n    }\n\n#if 1\n    //-----------------------\n    // suelo 地板\n    // sid=1u\n    //-----------------------\n    {\n#define suelo_y (0.0)\n        float dis = pos.y - suelo_y;\n\n        // 控制地砖间距的大小, suelo_seg 越大则间距越小\n#define suelo_seg 2.0\n        float ax = 128.0 + (pos.x+pos.z)*suelo_seg;\n        float az = 128.0 + (pos.x-pos.z)*suelo_seg;\n        uint ix = uint(floor(ax));\n        uint iz = uint(floor(az));\n        uint kk = ihash(ix+53u*iz); // 用于决定地板上的格子的颜色\n\n        bool ba = (((subMat>>10)&7u) > 6u);\n        float peld = max(fract(ax),fract(az)); // fract(x) = x - floor(x)\n        // smoothstep(edge0, edge1, t)\n        // 等价于\n        //     t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        //     t = (3.0 - 2.0 * t) * t * t;\n        peld = smoothstep(0.975, 1.0, peld); // 将 peld 插值到 [0.975, 1.0] 之间\n        if(ba) peld = 1.0;\n        dis += 0.005*peld;        // 用于生成地面高低不平的感觉(每一块地砖不一样高)\n        if(dis < mindist) {\n            mindist = dis;\n            subMat = kk;\n            // sid=0u(黑色), sid=1u(地板)\n            if( peld > 0.0000001 ) sid = 0u; else sid = 1u;\n        }\n    }\n\n    //-----------------------\n    // 桌子上的摆设\n    // sid=2u\n    //-----------------------\n\n    // 杯子\n    {\n        float dist = sdCup(pos);\n        if(dist < mindist) {\n            sid = 2u; subMat = 21u;\n            mindist = dist;\n        };\n    }\n\n    // 书本\n    {\n        uint kk;\n        float dist = sdBook(pos, kk);\n        if(dist < mindist) {\n            sid = 2u; subMat = kk;\n            mindist = dist;\n        };\n    }\n\n    // 行走的丑人\n    {\n        float dist = sdMonster(pos);\n        if(dist < mindist) {\n            sid = 2u; subMat = 23u;\n            mindist = dist;\n        };\n    }\n\n#endif\n    // 苹果\n    {\n        uint kk;\n        float dist = sdApple(pos, kk);\n        if(dist < mindist) {\n            sid = 2u; subMat = kk;\n            mindist = dist;\n        };\n    }\n\n    return mindist;\n}\n\nvoid raycast( vec3 ro, vec3 rd, float tMin, float tMax,\n              out float resT, out vec3 resPos,\n              out uint resSurface, out uint subMat ) {\n    float t = tMin;\n    for(int i = ZERO; i < 256 && t < tMax; i++) {\n        resPos = ro + t*rd;\n        float h = map(resPos, resSurface, subMat);\n        if(h < 0.0001) {\n            resT = t;\n            return;\n        }\n        // 最简单的步进方式, 0.75 做一个步进限制\n        t += h*0.75;\n    }\n    // 没击中任何物体设置 resSurface=666u\n    resSurface = 666u;\n}\n\nvec3 calcNormal( vec3 pos ) {\n#if 0\n    // original code\n    const float eps = 0.0002;\n    uint kk, kk2;\n    vec3 nor = vec3(\n      map( pos.x+eps, pos.y, pos.z, kk, kk2 ) - map( pos.x-eps, pos.y, pos.z, kk, kk2 ),\n      map( pos.x, pos.y+eps, pos.z, kk, kk2 ) - map( pos.x, pos.y-eps, pos.z, kk, kk2 ),\n      map( pos.x, pos.y, pos.z+eps, kk, kk2 ) - map( pos.x, pos.y, pos.z-eps, kk, kk2 ));\n    return normalize(nor);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        uint kk, kk2;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos + 0.0002*e, kk, kk2);\n        if( n.x + n.y + n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = ZERO; i < 128; i++) {\n        uint tt1, tt2;\n        float h = map(ro + rd*t, tt1, tt2);\n        // 就是最简单的 softshadow(没有改进)\n        // k=8.0\n        float s = clamp(8.0*h/t, 0.0, 1.0);\n        res = min( res, s );\n        // t += clamp( h, 0.02, 0.2 );\n        t += h;\n        if( t > tmax ) break;\n    }\n    res = res*res*(3.0 - 2.0*res); // 0.037 => 0.004\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = ZERO; i < 5; i++ ) {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        uint tt1, tt2;\n        float d = map(pos + h*nor, tt1, tt2);\n        occ += (h - d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n}\n\n// 材质\n// subMatID 为奇数则不需要 bump mapping\nvec3 shade( vec3 pos, vec3 rd, uint matID, uint subMatID, float dis ) {\n    // 没有击中任何物体\n    if( matID == 666u ) return vec3(0.0,0.0,0.0);\n\n    vec3 col = vec3(0.1 * dis);\n\n    // calc normal\n    vec3 nor = calcNormal( pos );\n\n    // bump mapping\n    // 对法线进行随机扰动\n#if 1\n    if(matID != 2u || subMatID <= 20u) {\n        const float kke = 0.0001;\n        float bumpa = 0.0075; // 越大则凹凸程度越大\n        bumpa *= 0.75;\n        bumpa /= kke;\n        float kk = fbm( 32.0*pos );\n        nor.x += bumpa*(fbm( 32.0*vec3(pos.x+kke, pos.y, pos.z) )-kk);\n        nor.y += bumpa*(fbm( 32.0*vec3(pos.x, pos.y+kke, pos.z) )-kk);\n        nor.z += bumpa*(fbm( 32.0*vec3(pos.x, pos.y, pos.z+kke) )-kk);\n        nor = normalize(nor);\n    }\n#endif\n\n    // materials\n    if( matID == 0u ) {\n        // ID=0, 全黑色\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    else if( matID == 1u ) {\n        // ID=1 地板\n        // subMatID 为一个位置相关的随机数\n        // 通过一堆随机数的计算让整个地面有不同的明亮效果\n        float xoff = 13.1 * float(subMatID&255u);\n        float fb = fbm( 16.0*vec3(pos.x+xoff, pos.y, pos.z) );\n\n        col = 0.7 + vec3(0.20, 0.22, 0.25) * fb;\n\n        float baldscale = float((subMatID>>9)&15u)/14.0;\n        baldscale = 0.51 + 0.34*baldscale;\n        col *= baldscale;\n        float fx = 1.0;\n        if( (subMatID&256u)!=0u ) fx = -1.0;\n        float m = sin( 64.0*pos.z*fx +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.25, 0.5, m ) - smoothstep( 0.5, 0.75, m );\n\n        col += m*0.15;\n        col *= vec3(0.5,0.5,0.2); // 调色\n    }\n    else if( matID == 2u ) {\n        // bump mapping\n        // 1u 桌子\n        if( subMatID == 1u ) col = vec3(0.5);\n        // 2u 书 1 封面\n        else if( subMatID == 2u ) col = vec3(0.2, 0.05, 0.05);\n        // 3u 书 2 封面\n        else if( subMatID == 3u ) col = vec3(0.05, 0.2, 0.05);\n        // 4u 苹果梗\n        else if( subMatID == 4u ) col = vec3(0.247, 0.112, 0.112);\n\n        // no bump mapping\n        // 21u 杯子\n        else if( subMatID == 21u ) col = vec3(0.6,0.1,0.1);\n        // 22u 书本内的白色书本\n        else if( subMatID == 22u ) col = vec3(1.0);\n        // 23u 行走的丑人\n        else if( subMatID == 23u ) col = vec3(0.05, 0.2, 0.5);\n        // 24u 苹果\n        else if( subMatID == 24u ) col = vec3(0.5, 0.0, 0.0);\n    }\n\n    // shade\n    // blinn-phong\n    vec3  lig = normalize( LIGHT_POSITION  - pos );\n    vec3  hal = normalize( lig - rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 16.0);\n\n    float ao = calcAO(pos, nor); // AO\n    float ss = calcSoftshadow( pos, lig, 0.02, 20.0 ); // shadow\n    col *= (ao*0.05 + ss*(dif + spe*vec3(0.2)));\n\n    return col;\n}\n\n// 后处理\nvec3 post( vec3 col) {\n\n    // gamma correction\n    col = pow( col, vec3(0.4545) ); // 1/2.2=0.4545\n\n    return clamp(col, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 computePixel(vec2 p) {\n    // y: [-1, 1]\n    // x: [-a, a], a=iResolution.x/iResolution.y\n    vec2 s = (2.0*p - iResolution.xy)/iResolution.y;\n\n    // camera, ray\n    float time = 32.0 + iTime*1.5;\n    vec3 ta = vec3( 0.0,1.0,0.0 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time), 1.3, 4.5*sin(0.1*time) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize(vec3(s, 2.73));\n\n    // 光线碰到的物体\n    float t;              // 时间\n    uint matID, sumMatID; // 材质\n    vec3 xyz;             // 位置\n\n    // raycast\n    // tMin 设置成 0.5 为了避免旋转的时候被遮挡住\n    raycast(ro , rd, 0.0, 24.0, t, xyz, matID, sumMatID );\n\n    // shade\n    vec3 col = shade( xyz, rd, matID, sumMatID, t );\n\n    // 光源\n    {\n        vec3 v1 =  LIGHT_POSITION - ro;\n        float lig_dist2 = dot(v1, v1);\n        float dist = dot(v1 ,rd);\n        float seg2 = lig_dist2 - dist*dist;\n#if 1\n        // 叠加雾状光源\n        // (1) 光源在物体前面 / 没有击中物体\n        if((dist > 0.0 && (dist < t || matID == 666u))) {\n            col += vec3(1.0, 0.95, 0.90)*exp2( -64.0*seg2 );\n        }\n#else\n        // 击中光源直接返回\n        #define R2 0.01\n        // (1) 光源在物体前面 / 没有击中物体\n        // (2) 击中光源\n        if((dist > 0 && (dist < t || matID == 666u)) && (seg2 < R2)) {\n            return vec3( 1.0, 0.95, 0.90 );\n        }\n#endif\n    }\n\n    // postprocess\n    col = post(col);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n#if AA<2\n    vec3 col = computePixel(fragCoord);\n#else\n    vec3 col = vec3(0.0);\n    for( int j = 0; j < AA; j++ ) {\n        for( int i = 0; i < AA; i++ ) {\n            vec2 of = vec2(i, j) / float(AA);\n            col += computePixel(fragCoord + of);\n        }\n        col /= float(AA*AA);\n    }\n#endif\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}