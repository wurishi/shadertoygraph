{"ver":"0.1","info":{"id":"MctGz8","date":"1711743473","viewed":112,"name":"Cruising the Grid","username":"incre_ment","description":"A loan circle cruising the grid.  More practice with domain repetition.\nGoal was to have a single object traverse the grid (with motion controlled by a function).\nAdded some simple visual elements to make it more interesting.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["grid","domainrepetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A loan circle cruising the grid.  More practice with domain repetition.\n// Goal was to have a single object traverse the grid (with motion contrained by a function).\n// Added some simple visual elements to make it more interesting.\n\nfloat PI = 3.14159256;\nfloat TAU = 2.0*3.14159256;\n\n// Function for circle motion.  Could change to parametric f(t)=vec2(x,y)\nvec2 pathFunction(float xx){\n  return vec2(xx,1.2*sin(TAU/4.*xx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    // Time from 0 -> 1, and slow it down a bit.\n    float tt = fract(.2*iTime);\n   \n    // Create the grid cells\n    float scale = 2.;\n    uv*= scale;\n    vec2 cellID = floor(uv);\n    \n    // Copy the the scaled coordinate for later.\n    vec2 uv_0 = uv;\n    \n    // Cells go from -.5 to .5\n    uv = fract(uv) - .5;\n       \n    // Calculate the global path through the grid.\n    float xVal = -(2.*scale) + (4.*scale)*tt;\n    vec2 pathVal = pathFunction(xVal);\n    // Calculate the path cellID.\n    vec2 pathCell = floor(pathVal);\n    \n    \n    // Draw    \n    float th = .0;\n    if(pathCell == cellID){\n      th = 0.0;  // Change to 0.05 to highlight cell \n      \n      // Draw line from current path to cell center\n      vec2 pVal = fract(pathVal) - .5;\n      float proj = clamp(dot(uv, pVal)/dot(pVal,pVal), 0., 1.);\n      float lineVal = length(uv - pVal * proj);\n      col += .02/lineVal; \n    }\n    \n    // Draw grid with radial dynamics\n    if (abs(uv.x) > (.48 - th) )\n      col += vec3(1.0)+ .9*sin(TAU*tt - length(uv_0));\n    else if (abs(uv.y) > (.48 - th) )\n      col += vec3(1.0)+ .9*sin(TAU*tt - length(uv_0));\n    \n \n    // Constrain circle to the path, and check neighbors for circle pixels.\n    float circleRad = .15;\n    float circMin = 1e20;\n    if(distance(uv_0, pathVal) <= circleRad){\n      pathVal = fract(pathVal) - .5;\n      for (float i = -1.; i<=1.; i++)\n        for (float j = -1.; j<=1.; j++){\n          circMin = min(circMin,length((uv - pathVal) - vec2(i,j)) - circleRad);\n      }\n    }\n    // Draw the central cell \"nodes\"\n    col += 1.5*smoothstep(.1,-.1,abs(length(uv) - .05) - .01);\n\n    float w = 10./iResolution.y;\n    col += smoothstep(w,-w,circMin);\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}