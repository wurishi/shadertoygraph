{"ver":"0.1","info":{"id":"ftyfDc","date":"1693936876","viewed":58,"name":"Random basic stuff","username":"Etienne248","description":"test all","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS              0.001\n#define RM_MAX_STEPS     1000\n#define RM_MAX_DIST      100.0\n#define RM_MIN_DIST      0.001\n#define AMBIENT          0.1\n#define SHADOW_K         8.0\n#define MAX_SHADOW_STEPS 100\n#define GAMMA            2.2\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nstruct DirLight { vec3 d, c; float i; };\n\nstruct Ray { vec3 o, d; };\nvec3 ray_evaluate(in Ray r, in float t) { return r.o + t * r.d; }\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdf_Box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat sdf_sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat sdf_plane(in vec3 p, in vec3 n, in float h) { return dot(p, n) + h; }\nfloat sdf_Torus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdf_scene(in vec3 p) {\n    float dist = sdf_sphere(p-vec3(0., 0.5-sin(iTime)*0.5,0.),1.);\n    {\n        vec3 pb=p-vec3(2.0,0.1,0.0);\n        pb.yz*=Rot(iTime);\n        dist = smin(dist,\n        sdf_Box(pb,vec3(1.0,0.5,0.3))\n        ,1.0+sin(iTime*3.0));\n    }\n    dist=abs(dist)-0.1;\n    {\n        vec3 pb=p;\n        pb.yx*=Rot(iTime*2.);\n        pb-=-vec3(1.0,1,sin(iTime));\n        dist = max(dist,\n        -sdf_Box(pb,vec3(1.0,1.,1.)));\n    }\n    \n    {\n        vec3 pt = p-vec3(-3.,1,1.);\n        pt.xy*=Rot(1.);\n        float tor = sdf_Torus(pt, vec2(0.8+sin(iTime*10.)*0.2, 0.4));\n        float sphere=sdf_sphere(p-vec3(-3.,1,1.),1.);\n        float box=sdf_Box(p-vec3(-3.,1,1.),vec3(.5,0.5,0.5));\n        float d=mix(tor,sphere,sin(iTime*1.8)*.5+.5);\n        d=mix(d,box,clamp(sin(iTime*1.8+2.)*2.-1.,0.0,1.0));\n        dist = min(dist,d);\n    }\n    \n    dist = min(dist,\n    sdf_plane(p, vec3(0.0, 1.0, 0.0), 1.0)\n    +0.2*sin(p.x+iTime*6.)*sin(p.z));\n\n    \n    return dist;\n}\n\nvec2 normalize_uv(in vec2 fragCoord) {\n    float ar = iResolution.x / iResolution.y;\n    return (2.0 * fragCoord / iResolution.xy - 1.0) * vec2(ar, 1.0);\n}\n\nvec3 compute_normal(in vec3 p) {\n    vec2 e = vec2(EPS, 0.0);\n    return normalize(vec3(\n        sdf_scene(p + e.xyy) - sdf_scene(p - e.xyy),\n        sdf_scene(p + e.yxy) - sdf_scene(p - e.yxy),\n        sdf_scene(p + e.yyx) - sdf_scene(p - e.yyx)\n    ));\n}\n\nfloat ray_marching(in Ray ray) {\n    float t = 0.0;\n    for(int step = 0; step < RM_MAX_STEPS; ++step) {\n        vec3 p = ray_evaluate(ray, t);\n        float h = sdf_scene(p);\n        if(h < RM_MIN_DIST) break;\n        t += h;\n        if(t > RM_MAX_DIST) break;\n    }\n    return (t > RM_MAX_DIST)? -1.0: t;\n}\n\nfloat shadow(vec3 p, vec3 n, DirLight l) {\n    Ray ray = Ray(p + n * (EPS*1.1), l.d);\n    float r = 1.0;\n    float t = 0.0;\n    for(int step = 0; step < MAX_SHADOW_STEPS; ++step) {\n        p = ray_evaluate(ray, t);\n        float h = sdf_scene(p);\n        if(h < RM_MIN_DIST) return 0.0;\n        t += h;\n        r = min(r, SHADOW_K * h / t);\n    }\n    return r;\n}\n\nvec3 render(in Ray ray, in DirLight sun, in DirLight sky, in DirLight bou) {\n    vec3 color = sky.c;\n    float dist = ray_marching(ray);\n    \n    if(dist > 0.0) {\n        vec3 p = ray_evaluate(ray, dist);\n        vec3 n = compute_normal(p);\n        \n        vec3 albedo = vec3(1.0);\n        vec3 diffuse = vec3(AMBIENT);\n        \n        float sun_shadow = shadow(p, n, sun);\n        diffuse += albedo * clamp(dot(n, sun.d), 0.0, 1.0) * sun.c * sun.i * sun_shadow;\n        diffuse += albedo * clamp(dot(n, sky.d), 0.0, 1.0) * sky.c * sky.i;\n        diffuse += albedo * clamp(dot(n, bou.d), 0.0, 1.0) * bou.c * bou.i;\n        \n        color = albedo * diffuse;\n        color = mix(color, sky.c, 1.0 - exp(-0.1 * EPS * dist * dist));\n    }\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = normalize_uv(fragCoord);\n    \n    vec3 ro = vec3(0.0, 3.0, 6.0);\n    vec3 rd = normalize(vec3(uv.xy, -1.8));\n    mat2 cam_rot = Rot(iTime*0.5);\n    ro.xz *= cam_rot;\n    rd.yz *= Rot(-0.5);\n    rd.xz *= cam_rot;\n    Ray ray = Ray(ro, rd);\n    \n    DirLight sun = DirLight(normalize(vec3( 1.0,  1.0,  1.0)), vec3(1.0, 0.9, 0.8), 1.0);\n    DirLight sky = DirLight(normalize(vec3(-2.0,  0.0, -1.0)), vec3(0.6, 0.8, 0.9), 1.0);\n    DirLight bou = DirLight(normalize(vec3( 0.0, -1.0,  0.0)), vec3(0.2, 0.8, 0.4), 0.1);\n    \n    vec3 color = render(ray, sun, sky, bou);\n    color = pow(color, vec3(1.0 / GAMMA));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}