{"ver":"0.1","info":{"id":"ldtyRB","date":"1519571211","viewed":76,"name":"raymarch_try","username":"inantop","description":"raymarch","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 perspective(float fovy, float aspect, float near, float far)\n{\n\tmat4 result;\n    float rad = fovy * 3.14159265 / 180.0;\n    float tanHalfFovy = tan(rad / 2.0);\n    result[0][0] = 1.0 / (aspect * tanHalfFovy);\n    result[1][1] = 1.0 / tanHalfFovy;\n    result[2][2] = - (far + near) / (far - near);\n    result[2][3] = - 1.0;\n    result[3][2] = - (2.0 * far * near) / (far - near);\n    return result;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    mat4 Result = mat4(1.0);\n    \n    vec3  f = normalize(center - eye);\n    vec3  u = normalize(up);\n    vec3  s = normalize(cross(f, u));\n    \n    u = cross(s, f);\n    Result[0][0] = s.x;\n    Result[1][0] = s.y;\n    Result[2][0] = s.z;\n    Result[0][1] = u.x;\n    Result[1][1] = u.y;\n    Result[2][1] = u.z;\n    Result[0][2] =-f.x;\n    Result[1][2] =-f.y;\n    Result[2][2] =-f.z;\n    Result[3][0] =-dot(s, eye);\n    Result[3][1] =-dot(u, eye);\n    Result[3][2] = dot(f, eye);\n    return Result;   \n}\n\nvec3 unproject(vec3 win, mat4 mvp, vec4 vp)\n{\n    mat4 inv = inverse(mvp);\n\n    vec4 tmp = vec4(win, 1.0);\n    tmp.x = (tmp.x - vp.x) / vp.z;\n    tmp.y = (tmp.y - vp.y) / vp.w;\n    tmp.x = tmp.x * 2.0 - 1.0;\n    tmp.y = tmp.y * 2.0 - 1.0;\n\n    vec4 obj = inv * tmp;\n    obj /= obj.w;\n\n    return vec3(obj);\n}\n\n/* Rays */\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere\n{\n    vec3 position;\n\tfloat radius;\n    vec3 color;\n};\n    \nstruct Box\n{\n    vec3 position;\n    vec3 size;\n    vec3 color;\n};\n    \nstruct Light\n{\n    vec3 position;\n    vec3 color;\n};\n    \nstruct Camera\n{\n    vec3 position;\n    vec3 target;\n    vec3 up;\n};\n\nconst int MAX_PER_TYPE = 8;\nint NUM_SPHERES = 0;\nint NUM_BOXES = 0;\nstruct Map\n{\n\tSphere spheres[MAX_PER_TYPE];\n    Box boxes[MAX_PER_TYPE];\n};\nMap m;\n\nvoid InitMap()\n{\n    m.spheres[NUM_SPHERES];\n    m.spheres[NUM_SPHERES].position = vec3(-0.8,0.0,0.0);\n    m.spheres[NUM_SPHERES].radius = .45;\n    m.spheres[NUM_SPHERES].color = vec3(.0, .0, .9);\n    NUM_SPHERES++;\n    \n    m.spheres[NUM_SPHERES];\n    m.spheres[NUM_SPHERES].position = vec3(0.8,0.0,0.0);\n    m.spheres[NUM_SPHERES].radius = .45;\n    m.spheres[NUM_SPHERES].color = vec3(.9, .0, .0);\n    NUM_SPHERES++;\n    \n    m.spheres[NUM_SPHERES];\n    m.spheres[NUM_SPHERES].position = vec3(0.0,0.8,0.0);\n    m.spheres[NUM_SPHERES].radius = .45;\n    m.spheres[NUM_SPHERES].color = vec3(.0, .9, .0);\n    NUM_SPHERES++;\n    \n    m.boxes[NUM_BOXES];\n    m.boxes[NUM_BOXES].position = vec3(-.8,0.0,0.0);\n    m.boxes[NUM_BOXES].size = vec3(0.4);\n    m.boxes[NUM_BOXES].color = vec3(.0, .0, .9);\n    NUM_BOXES++;\n    \n    m.boxes[NUM_BOXES];\n    m.boxes[NUM_BOXES].position = vec3(0.8,0.0,0.0);\n    m.boxes[NUM_BOXES].size = vec3(0.4);\n    m.boxes[NUM_BOXES].color = vec3(.9, .0, .0);\n    NUM_BOXES++;\n    \n    m.boxes[NUM_BOXES];\n    m.boxes[NUM_BOXES].position = vec3(0.0,0.8,0.0);\n    m.boxes[NUM_BOXES].size = vec3(0.4);\n    m.boxes[NUM_BOXES].color = vec3(.0, .9, .0);\n    NUM_BOXES++;\n}\n\n    \nvec3 ScreenToWorld(in vec3 screen, in Camera c)\n{\n    mat4 p = perspective(45.0f, iResolution.x / iResolution.y, 0.01, 1000.0);\n    mat4 v = lookAt(c.position, c.target, c.up);\n    return unproject(screen, p * v, vec4(0.0, 0.0, iResolution.x, iResolution.y));\n}\n\nfloat pointDistance(in vec3 worldPos, in Box box)\n{\n    vec3 v = abs(worldPos - box.position) - box.size;\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat pointDistance(in vec3 worldPos, in Sphere s)\n{\n\treturn distance(worldPos, s.position) - s.radius;   \n}\n\nfloat sdf_smin(float a, float b)\n{\n    const float k = 16.;\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(max(0.0001,res)) / k;\n}\n\nbool approx(in float a, in float b)\n{\n    return abs(a-b) < 0.05;\n}\n\nfloat sdf_subtract(float a, float b)\n{\n    return max(-a, b);\n}\n\nfloat sdf_add(float a, float b)\n{\n    return min(a,b);\n}\n\nfloat sdf_smooth_add(float a, float b)\n{\n    return sdf_smin(a,b);\n}\n\nfloat sdf_intersect(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat map(in vec3 worldPos, out vec3 objColor)\n{   \n    bool first = true;\n    float minDist = 100000.;\n         \n\tfloat shape1;\n    float sdist1 = pointDistance(worldPos, m.spheres[0]);\n    float bdist1 = pointDistance(worldPos, m.boxes[0]);\n    \n    shape1 = sdf_subtract(sdist1, bdist1);\n    \n    float shape2;\n    float sdist2 = pointDistance(worldPos, m.spheres[1]);\n    float bdist2 = pointDistance(worldPos, m.boxes[1]);\n    \n    shape2 = sdf_subtract(sdist2, bdist2);\n    \n    float shape3;\n    float sdist3 = pointDistance(worldPos, m.spheres[2]);\n    float bdist3 = pointDistance(worldPos, m.boxes[2]);\n\n    shape3 = sdf_subtract(sdist3, bdist3);\n    \n    \n    float accumulated = sdf_smooth_add(shape1, sdf_smooth_add(shape2, shape3));\n    \n    if (approx(accumulated, sdist1))\n    {\n        objColor = m.spheres[0].color;\n    }\n    if (approx(accumulated, sdist2))\n    {\n        objColor = m.spheres[1].color;\n    }\n    if (approx(accumulated, sdist3))\n    {\n        objColor = m.spheres[2].color;\n    }\n    if (approx(accumulated, bdist1))\n    {\n        objColor = m.boxes[0].color;\n    }\n    if (approx(accumulated, bdist2))\n    {\n        objColor = m.boxes[1].color;\n    }\n    if (approx(accumulated, bdist3))\n    {\n        objColor = m.boxes[2].color;\n    }\n    \n    return accumulated;\n}\n\nfloat map(in vec3 worldPos)\n{\n    vec3 dontCare;\n    return map(worldPos, dontCare);\n}\n\nvec4 simpleLambert(in vec3 normal, in vec3 color, in vec3 lColor, in vec3 lDir, in vec3 eye)\n{  \n   vec3 halfVec = (lDir + eye) / 2.;\n   float s = pow(dot(normal, halfVec), 8.0) * 0.5;\n    \n   float ndotl = max(dot(normal, lDir), 0.0);\n   ndotl = clamp(ndotl, 0.0, 1.0);\n    \n   vec3 environment = texture(iChannel0, reflect(-eye, normal)).rgb;\n   float REFLECTIVITY = sin(iTime);\n    \n   vec3 baseColor = environment * REFLECTIVITY + color * (1.0 - REFLECTIVITY);\n    \n   vec4 col;\n   const float AMBIENT = 0.6;\n   col = vec4(baseColor * AMBIENT + baseColor * lColor * ndotl + s, 1.0);\n   return col;\n}\n\nvec3 normal (in vec3 point)\n{\n\tconst float eps = 0.01;\n    \n    return normalize(vec3(map(point + vec3(eps, 0, 0)) - map(point - vec3(eps, 0, 0)),\n                     map(point + vec3(0, eps, 0)) - map(point - vec3(0, eps, 0)),\n                     map(point + vec3(0, 0, eps)) - map(point - vec3(0, 0, eps))));\n}\n\nvec4 raymarch(in Ray ray, in Light l, in Camera c)\n{\n    const int STEPS = 64;\n    const float MIN_DISTANCE = 0.0001;\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 objColor;\n        float dist = map(ray.origin, objColor);\n        if (dist < MIN_DISTANCE)\n        {\n            return simpleLambert(normal(ray.origin), objColor, l.color, normalize(l.position - ray.origin), normalize(c.position - ray.origin));\n        }\n        ray.origin += dist * ray.direction;\n    }\n    return texture(iChannel0, ray.direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera c;\n    c.position = vec3(3.0, 3.0, 3.0);\n    c.target = vec3(0.0, 0.0, 0.0);\n    c.up = vec3(0.0, 1.0, 0.0);\n       \n    Light l;\n    l.position = vec3(0.0, 5.0, 0.0);\n    l.color = vec3(1.0, 1.0, 1.0);\n    \n    const float ANIMATION_SPEED = 0.8;\n    float adjustedTime = ANIMATION_SPEED * iTime;\n    c.position = vec3(cos(adjustedTime) * 5.0, 3.0, sin(adjustedTime) * 5.0);\n    c.target = vec3(sin(adjustedTime), 0.0, 0.0);\n    \n    Ray worldRay;\n    worldRay.origin = ScreenToWorld(vec3(fragCoord, 0.0), c);\n    worldRay.direction = normalize(ScreenToWorld(vec3(fragCoord, 1.0), c) - worldRay.origin);\n    \n    InitMap();\n    \n    fragColor = raymarch(worldRay, l, c);\n}","name":"Image","description":"","type":"image"}]}