{"ver":"0.1","info":{"id":"WlsGRS","date":"1556720571","viewed":130,"name":"Keep Calm and Slow Motion","username":"Sot","description":"A small shader written to test some new simple skills.\nThis is my first one.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spheres","blend","rotation","tranlsation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_DIST  10000.0\n#define RM_DIST 0.01\n\nfloat PI = 3.14159;\n\nmat2 Rot(float deg)\n{ \n    float rad = ((2.*PI)/360.)*deg;\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat plane(vec3 p)\n{\n  return p.y;\n}\n\nfloat box(vec3 p, vec3 center, vec3 size)\n{\n    vec3 centeredPos = p-center;\n    return length(max(abs(centeredPos)-size, 0.));\n}\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n  return length(p-center)-radius;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix(b,a,h)-k*h*(1.-h);\n}\n\nfloat map(vec3 pos)\n{\n  // sphere ring\n  // pos = pos + vec3(0.0, 1.0, 0.0);\n  // pos = pos * RotXY(fGlobalTime);\n  float count = 12.;\n  float spheres[12];\n  float ds = 0.;\n  for (float i=0.; i < count; ++i)\n  {\n      vec3 spherePos = pos;\n      spherePos += vec3(-2,0,0);  //translate          \n      spherePos.xz *= Rot(30.*i+2.*iTime);  //rotate  \n      spherePos += vec3(2,0,0);  //translate    \n      spheres[int(i)] = sphere(spherePos, vec3(0.,0.15,0.), 0.35);    \n\n      if (i==0.)\n        ds = spheres[int(i)];\n      else\n        ds = smin(spheres[int(i)], ds,0.2);\n  }\n  \n  for (float i=0.; i < count; ++i)\n  {\n      vec3 spherePos = pos;\n      spherePos += vec3(2,0,0);  //translate          \n      spherePos.yz *= Rot(90.);  //rotate  \n      spherePos.xz *= Rot(30.*i+10.*iTime);  //rotate  \n      spherePos += vec3(2,0,0);  //translate    \n      \n      spheres[int(i)] = sphere(spherePos, vec3(0.,0.5,0.), .35);    \n\n      ds = smin(spheres[int(i)], ds,.2);\n  }\n  \n  \n  \n  float dp = plane(pos);\n  \n  float db = box(pos, vec3(-2.,0.5,0.), vec3(.25));\n  \n  // float dmix = mix (ds, db, sin(fGlobalTime));\n\n  float d = smin(dp,ds,.2);\n  \n\n  return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd)\n{\n  vec3 pos = ro;\n  float dist = 0.;\n\n  for (int i=0; i<100; ++i)\n  { \n    pos += dist*rd;\n    dist = map(pos);\n    \n    if ((dist < RM_DIST) || dist > MAX_DIST)\n    {\n      break;\n    }\n  }\n\n  return pos;\n}\n\nvec3 getNormal(vec3 pos)\n{\n  vec2 eps = vec2(0.0001,0);\n  vec3 normal = normalize(vec3(map(pos + eps.xyy)-map(pos - eps.xyy),map(pos + eps.yxy)-map(pos - eps.yxy),map(pos + eps.yyx)-map(pos - eps.yyx)));\n\n  return normal;\n}\n\nvec3 applyFog(vec3 color, float dist)\n{ \n   float fogColor = (exp(1.-10./(dist*dist)))/exp(1.);\n   return mix(color, vec3(0.), fogColor);\n}\n\nfloat getDiffuse(vec3 pos)\n{\n  vec3 lightPos = vec3(2,5,-4);\n  // lightPos.xz *= Rot(30.*iTime);\n  vec3 light = normalize(lightPos - pos);\n  vec3 normal = getNormal(pos);\n  \n  float dimFactor=1.0;\n\n  vec3 sd = normalize(lightPos-pos);\n  vec3 so = pos + 0.05*sd;\n  \n  vec3 surface = RayMarch(so, sd);\n  if (length(surface-pos) < length(lightPos-pos))\n      dimFactor = 0.2;\n\n  return dimFactor * dot(normal,light)*0.5+0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y /iResolution.x, 1);\n  \n  vec3 ro = vec3(0,1,-5.5);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  vec3 pos = RayMarch(ro, rd);\n  vec3 myColor = vec3(getDiffuse(pos));\n  myColor = applyFog(myColor, pos.z);\n  fragColor  = vec4(myColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}