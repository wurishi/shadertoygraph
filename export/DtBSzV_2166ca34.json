{"ver":"0.1","info":{"id":"DtBSzV","date":"1687446958","viewed":38,"name":"explosion in 2d bby me","username":"thimmythimble","description":"explosion","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","explosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAGIC 43758.5453123\nfloat random (vec2 st) {\n    float s = dot(st, vec2(0.400,0.230));\n    return -1. + 2. * fract(sin(s) * MAGIC);\n}\n\nvec2 random2(vec2 st){\n    vec2 s = vec2(\n      dot(st, vec2(127.1,311.7)),\n      dot(st, vec2(269.5,183.3))\n    );\n    return -1. + 2. * fract(sin(s) * MAGIC);\n}\nvec4 valueNoise (vec2 p) {\n    vec2 i = floor(p);\n\n    float f11 = random(i + vec2(0., 0.));\n    float f12 = random(i + vec2(0., 1.));\n    float f21 = random(i + vec2(1., 0.));\n    float f22 = random(i + vec2(1., 1.));\n\n    return vec4(f11, f12, f21, f22);\n}\n\nvec4 gradientNoise (vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float f11 = dot(random2(i + vec2(0., 0.)), f - vec2(0., 0.));\n    float f12 = dot(random2(i + vec2(0., 1.)), f - vec2(0., 1.));\n    float f21 = dot(random2(i + vec2(1., 0.)), f - vec2(1., 0.));\n    float f22 = dot(random2(i + vec2(1., 1.)), f - vec2(1., 1.));\n\n    return vec4(f11, f12, f21, f22);\n}\n\n\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*3.141593/2. : atan(y, x);\n}\nvec3 circle(float radius, vec2 uv)\n{\n    if(uv.x*uv.x + uv.y*uv.y < radius*radius + .050*length(random(uv) + 1.))\n    {\n        return vec3(1,0,0);\n    }\n    else\n    {\n        return vec3(0,0,0);\n    }\n}\n\n\nvec3 radiiline(float spawnTime, float growRate, float startAngle, float widthAngle, float spinRate, vec2 uv)\n{\n    //see if we have spawned\n    if(iTime < spawnTime)\n    {\n        float scaleNow = iTime/spawnTime * 2.;\n        if (length(uv) > scaleNow)\n            return vec3(0);\n    }\n    //work out what angle the pixel is\n    float angle = atan2(uv.y, uv.x);\n    angle += 3.141593;\n    //work out what our start and end angles are\n    float start = startAngle + iTime*spinRate;\n    start = abs(mod(start, 2.*3.1415927));\n    float end = start + widthAngle + iTime*growRate;\n    if (end > 2.*3.1415 && angle < start)\n    {\n        angle += 2.*3.1415;\n        }\n    if(angle > start && angle < end)\n    {\n        return vec3(1,0,0);\n    }\n    else\n    {\n        return vec3(0,0,0);\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1 in height)\n    vec2 uv;\n    uv.x = fragCoord.x/iResolution.y;\n    uv.y = fragCoord.y/iResolution.y;\n    //centre uv\n    uv.y -= .5;\n    uv.x -= iResolution.x/iResolution.y/2.;\n\n    // Time varying pixel color\n    float timeSin = (iTime) + 1.;\n    timeSin *= 1.;\n    vec3 col = circle(.1 * (1.-timeSin), uv);\n    col += 0.5*circle(.2 * (1.-timeSin), uv);\n    col += 0.4*radiiline(0., .01, 0., 0.1,1.2,uv);\n    col += 0.4*radiiline(1., 0.01, .2, 0.1,1.3,uv);\n    col += 0.4*radiiline(2., 0.01, 0.4, 0.1,1.,uv);\n    col += 0.4*radiiline(3., 0.01, 0.6, 0.1,1.5, uv);\n    col += 0.4*radiiline(4., 0.01, 0.7, 0.1,0.8, uv);\n    col += 0.4*radiiline(0., .01, 0.6, 0.1,1.2,uv);\n    col += 0.4*radiiline(1., 0.01, 1.8, 0.1,1.3,uv);\n    col += 0.4*radiiline(2., 0.01, 6., 0.1,1.,uv);\n    col += 0.4*radiiline(3., 0.01, 12.25, 0.1,1.5, uv);\n    col += 0.4*radiiline(4., 0.01, 13589373.65235, 0.1,0.8, uv);\n    col += 0.4*radiiline(0., .01, 124.23, 0.1,1.2,uv);\n    col += 0.4*radiiline(1., 0.01, 14.34865, 0.1,1.3,uv);\n    col += 0.4*radiiline(2., 0.01, 0.659847, 0.1,1.,uv);\n    col += 0.4*radiiline(3., 0.01, 0.919, 0.1,1.5, uv);\n    col += 0.4*radiiline(4., 0.01, 124.357, 0.1,0.8, uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}