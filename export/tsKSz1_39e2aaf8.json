{"ver":"0.1","info":{"id":"tsKSz1","date":"1573664588","viewed":373,"name":"flower_sdf_experiment","username":"skaplun","description":"Lighting borrowed from @iq","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 96\n#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON .005\n\nconst float THICKNESS = .001;\n#define HASHSCALE1 .1031\nfloat hash11(float p){\n    vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 opMin(vec4 a, vec4 b){\n\tif(a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\nvec4 world(vec3 orPos){\n    vec3 mp = orPos;\n    float size = 1.;\n    \n    {\n        float delta = PI/5.;\n        float l = length(mp.xz);\n        float a = atan(mp.x, mp.z);\n        float vertAng = mod(a, delta) - delta/2.;\n        mp = vec3(l * sin(vertAng), mp.y, l * cos(vertAng));\n    }\n\t\n    float l = length(mp);\n    const float VERT_PETALS_COUNT = 30.;\n    const float petalAngleRange = PI/VERT_PETALS_COUNT;\n    float a = atan(mp.y, mp.z);\n    size = pow(smoothstep(PI*1.4, 0., a), .1) * pow(smoothstep(PI*1.4, .25, a), 1.5);\n    a = atan(mp.y -cos(l * (5.5 + .5 * fbm1x(a * .137, iTime))) * .1, mp.z);\n    float id = floor(a/petalAngleRange);\n    \n    mp = orPos;\n    float rotAng = PI * .31 * hash11(id * .471);\n    {\n        float delta = PI/5.;\n        float l = length(mp.xz);\n        float a = atan(mp.x, mp.z) + rotAng;\n        float vertAng = mod(a, delta) - delta/2.;\n        float id = floor(a/delta);\n        float f = fbm1x(id, iTime) * .025;\n        mp = vec3(l * sin(vertAng + f), mp.y, l * cos(vertAng + f));\n    }\n\t\n    l = length(mp.yz);\n    float ma = mix(a - .1 , mod(a, petalAngleRange) - petalAngleRange/2., step(distance(a, PI/4.), PI/4.));\n    mp = vec3(mp.x, l * sin(ma), l * cos(ma));\n    \n    vec4 leaf = vec4(MAX_FLOAT);\n    for(int i=0; i<2; i++){\n    \tvec3 rp = mp;\n        float a = -PI/5. * float(i);\n        rp.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n        a = radians(2.);\n    \trp.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n        vec2 vesicaCoords = rp.xz - vec2(0., .7 * pow(size, 4.));\n        float v = sdVesica(vesicaCoords, size, .7 + pow(1.-size, .5) * .3);\n    \tleaf = opMin(leaf, vec4(opExtrussion(rp, v, .0001), vesicaCoords, v));\n    }\n\n    return leaf;\n}\nvec4 march(vec3 eye, vec3 marchingDirection) {\n\tconst float precis = .01;\n    float t = 0., l = 0.;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++ ){\n\t    vec3 pos = eye + marchingDirection * t ;\n        vec4 h = world(pos);\n        if( h.x < precis ) return vec4(t, h.yzw);\n        t += h.x * .25;\n        if ((pos.y < -.1) || length(pos.xz) < precis/10.)\n            break;\n    }\n    return vec4(-1.);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)).x - world(vec3(p.x - EPSILON, p.y, p.z)).x,\n        world(vec3(p.x, p.y + EPSILON, p.z)).x - world(vec3(p.x, p.y - EPSILON, p.z)).x,\n        world(vec3(p.x, p.y, p.z  + EPSILON)).x - world(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n#define ZERO (min(iFrame,0))\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0., sca = 1.;\n    for(int i=ZERO; i<5; i++){\n        float hr = .01 + 0.05 * float(i)/1.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = world(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 3. * occ, 0., 1.) * (.5 + .5 * nor.y);\n}\n\nconst float maxHei = 1.;\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax){\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++){\n\t\tfloat h = world(ro + rd * t).x;\n        float s = clamp(h/t, 0., 1.);\n        res = min( res, s*s*(3.0-2.0*s));\n        t += clamp(h, .005, .025);\n        if(res<.01 || t>tmax) break;\n    }\n    return clamp(res, 0., 1.);\n}\n\n#define aa (100./iResolution.y)\nvec4 render(in vec2 fragCoord){\n\tvec4 color = vec4(.1);\n    float a = iMouse.x/iResolution.x * 6.28;//sin(iTime * .5) * PI;\n    vec3 eye = vec3(4. * sin(a), 2.5 + sin(a) * 2.5, 4. * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., .125, 0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    vec4 dist = march(eye, worldDir);\n    if (dist.x >= 0.) {\n        vec3 pos = (eye + dist.x * worldDir);\n    \tvec3 nor = estimateNormal(pos);\n        vec3 ref = reflect( worldDir, nor );\n        \n        float n = fbm(dist.yz * 2.5) + abs(dist.w) * 6.;\n        float mv = pow(abs(dist.w), .5);\n        mv = smoothstep(mv, mv + aa, n);\n        \n        //vec3 col = mix(vec3(1., 1., 0.), vec3(1., 0., 0.), pow(abs(dist.y), .1));\n        vec3 col = mix(vec3(.1, 0., .05), vec3(.3, .3, 0.), mv);\n        \n        // lighting\n        float occ = max(calcAO(pos, nor), .33);\n\t\tvec3  lig = normalize( vec3(2., 7., 0.));\n        vec3  hal = normalize( lig-worldDir );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor, worldDir),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow(pos, lig, .15, .5);\n        dom *= calcSoftshadow(pos, ref, .15, .5);\n\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0., 1.), 16.) *\n                    dif * (.04 + .96*pow( clamp(1.0+dot(hal,worldDir),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*dist.x*dist.x*dist.x ) );\n\t\t\n        color = vec4(col, 1.);\n    }\n    \n    return color;\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += render(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdVesica(vec2 p, float r, float d){\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y), 0.0) + length(max(w, 0.));\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv){\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}","name":"Common","description":"","type":"common"}]}