{"ver":"0.1","info":{"id":"cljXzc","date":"1676396912","viewed":106,"name":"Rose for Valentine's Day","username":"amuda","description":"model ref https://www.shadertoy.com/view/XsdyWrï¼Œadd some background effect and some details, render in different method","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ref https://www.shadertoy.com/view/XsdyWr\n#define backgroundColor vec3(200.0 / 255.0, 40.0 / 255.0, 80.0 / 255.0)\n\nfloat greenHandler = 1e4;\n\nmat3 rotationXY(vec2 angle)\n{\n    vec2 c = cos(angle);\n    vec2 s = sin(angle);\n\n    return mat3(c.y, 0.0, -s.y, s.y * s.x, c.x, c.y * s.x, s.y * c.x, -s.x, c.y * c.x);\n}\n\nfloat opI(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s)\n{\n    p = p * vec3(0.8, 1.5, 0.8) + vec3(0.1, 0.0, 0.0);\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n\n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n\n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region);\n}\n\nfloat Cylinder(vec3 p, vec2 h)\n{\n    return max(length(p.xz) - h.x, abs(p.y) - h.y);\n}\n\n// sdf scene\nvec2 map(vec3 p)\n{\n    vec2 result = vec2(1000000.0, 1.0);\n\n    vec3 oldp = p;\n\n    float d = 1000000.0;\n    float s = 2.0;\n    mat3 r = rotationXY(vec2(0.1, 3.14 * 2.0 * 0.618034));\n    r = r * mat3(1.08,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.08);\n    for (int i = 0; i < 20; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.02, 0.0);\n        s *= 1.05;\n    }\n\n    p = oldp;\n\n    \n    greenHandler = Cylinder(p - vec3(0.0, -100, 0.0), vec2(0.12, 100.0));\n\n    p.y *= 3.0;\n    p.x *= 0.95;\n\n    r = rotationXY(vec2(0.1, 3.14 * 2.0 * 0.618034));\n    r = r *  mat3(1.2,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.2);\n    s = 2.0;\n    for (int i = 0; i < 3; i++) {\n        p = r * p;\n    }\n    p += vec3(0.0, 1.8, 0.0);\n    for (int i = 0; i < 5; i++) {\n        greenHandler = opU(greenHandler, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, 0.02, 0.0);\n        s *= 1.01;\n    }\n\n    result.x = min(d, greenHandler);\n\n    return result;\n}\n\nfloat f(vec3 p)\n{\n    return map(p).x;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n    vec3 e = vec3(1e-5, 0, 0);\n    float d = f(p);\n    return normalize(vec3(f(p + e.xyy) - d, f(p + e.yxy) - d, f(p + e.yyx) - d));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 18;\n    const float delta = 1.5;\n\n    float a = 0.0;\n    float weight = .5;\n    for(int i = 1; i <= steps; i++)\n    {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight * (d - f(p + n * d));\n        weight *= 0.6;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec3 heart(vec2 inuv)\n{\n    vec2 uv = inuv;\n    uv.x *= 0.7;\n    float f = uv.x * uv.x + pow(uv.y - pow(uv.x * uv.x, 1.0 / 3.0), 2.0);\n    float v = smoothstep(f, f + 0.2, 1.0);\n    return vec3(v * (length(f) + 0.2) * 0.6);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n * 122.99 + 42264.23) * 438.763) * 2.0 - 1.0;\n}\n\nvec2 rotate(vec2 inuv, float theta)\n{\n    return inuv * mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvec2 size(vec2 inuv, float scale)\n{\n    return inuv / scale;\n}\n\nvec2 traslate(vec2 inuv, vec2 offset)\n{\n    return inuv - offset;\n}\n\nvec3 BackGround(vec2 uv)\n{\n    float scale = 5.0;\n\n    uv *= scale;\n\n    vec3 color = backgroundColor;\n\n  // color = mix(color, vec3(1.0, 0.0, 0.0), heart(uv));\n\n    for(int i = 0; i < 50; i++)\n    {\n        float floati = float(i);\n        vec2 offset = vec2(hash(floati), hash(floati + 2334.5));\n        offset *= 7.0;\n    // offset += vec2(iTime);\n        vec2 curUv = traslate(uv, offset);\n\n        float scale = hash(float(i) + 234.54) * 0.1 + 0.9;\n        scale *= 1.0 + 0.1 * cos(iTime + floati * 234.0);\n        curUv = size(curUv, scale);\n\n        float theta = hash(float(i) + 1234.5) * 3.14159 / 6.0;\n        curUv = rotate(curUv, theta + cos(iTime + floati * 12324.2) * 0.2 * hash(floati));\n\n        color = mix(color, vec3(255.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0), heart(curUv));\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    float ylerp = iMouse.y / iResolution.y;\n    vec3 cameraPos = vec3(clamp(ylerp * 10.0 - 5.0, -5.0, 5.0), clamp(4.0 + ylerp * 2.0 - 1.0, 3.0, 5.0), -4.7);\n    vec3 tarPos = vec3(0.0, 1.5, 0.0);\n\n    vec3 w = normalize(tarPos - cameraPos);\n    vec3 u = cross(w, vec3(0.0, 1.0, 0.0));\n    vec3 v = cross(u, w);\n    mat3 cameraMatrix = mat3(u, v, w);\n\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(cameraMatrix * vec3(uv.x, uv.y, 1.0));\n\n    // Raymarching\n    float t = 4., d = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        d = f(ro + rd * t);\n        if(d < 1e-4 || t > 20.)\n            break;\n        t += d * 0.3;\n    }\n\n    // Directional light\n    float d2 = f(ro + rd * t + normalize(vec3(1, 2, -2)) * 5e-2);\n    float l = .5 + .5 * (d2 - d) / 0.1;\n    vec3 rp = (ro + rd * t);\n    vec3 n = sceneNorm(rp);\n    vec3 bcol = BackGround(uv);\n    vec3 col = bcol;\n\n    if(t < 20.)\n    {\n        col = vec3(mix(vec3(10.0/255.0, 50.0/255.0, 10.0/255.0), vec3(0.95, 0.0, 0.0), smoothstep(0.0, 0.01, greenHandler - d)));\n        col *= l;\n\n        col += pow(clamp(-n.y, 0., 1.), 2.) * backgroundColor / 1.5;\n\n        if(n.y > .999)\n        {\n            col *= pow(ambientOcclusion(rp, n), 1.);\n            col *= mix(.7, 1., smoothstep(0., 2., length(rp.xz)));\n        }\n        else\n        {\n            vec3 r = reflect(rd, n);\n            col += step(0.5, r.y) * .2 * pow(clamp(0., 1., 1. - dot(-rd, n)), 2.);\n            col *= pow(ambientOcclusion(rp, n), 2.);\n        }\n    }\n    else\n    {\n        col = max(mix(bcol + max((0.25 - length(uv.xy) / 1.5), -0.7), vec3(1), 0.1), 0.);    \n    }\n\n    fragColor.rgb = max(col, 0.);\n    fragColor.rgb = sqrt(fragColor.rgb + .01);\n}\n","name":"Image","description":"","type":"image"}]}