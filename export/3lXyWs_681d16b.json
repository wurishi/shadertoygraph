{"ver":"0.1","info":{"id":"3lXyWs","date":"1593379882","viewed":275,"name":"SDF Soft Shadows & AO","username":"Assossa","description":"AO loosely based on https://www.youtube.com/watch?v=FkVlF5OzLcM","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","shadows","softshadows","ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYMARCH_STEPS 64\n#define FAR_PLANE 10.\n#define AO_STEPS 12\n#define AO_MAX_DIST 4.\n#define FLOOR_SCALE 4.\n#define CAMERA_SPEED 0.02\n\nvec2 cameraPosition(float t) {\n    return vec2(\n        cos(t * CAMERA_SPEED) * 100.,\n        sin(t * CAMERA_SPEED) * 100.\n    );\n}\n\nmat3 viewMatrix(vec3 eye, vec3 lookAt) {\n    vec3 f = normalize(lookAt - eye);\n    vec3 s = normalize(cross(f, vec3(0,1,0)));\n    vec3 u = cross(s, f);\n    return mat3(s, u, f);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene(vec3 p) {\n    vec2 intPos = floor(p.xz * FLOOR_SCALE);\n    float boxScale = 1. / FLOOR_SCALE;\n    \n    float dist = 2. * FAR_PLANE;\n    for(int x = -1; x <= 1; ++x) {\n        for(int y = -1; y <= 1; ++y) {\n            vec2 adjPos = intPos + vec2(x, y);\n            ivec2 texUV = ivec2(mod(adjPos, 256.));\n            float height = texelFetch(iChannel0, texUV, 0).r * 0.2 + 0.1;\n            vec3 boxPos = vec3((adjPos + 0.5) * boxScale, 0.).xzy;\n            dist = min(dist, box(p - boxPos, vec3(boxScale * 0.5, height, boxScale * 0.5)));\n        }\n    }\n    \n    vec3 objPos = p - vec3(cameraPosition(iTime + 1.), .5).xzy - vec3(0, sin(iTime * 2.) * .1 + 0.05, 0);\n    float obj = max(\n        box(objPos, vec3(1., .1, 1.)),\n        length(objPos) - .8\n    );\n    \n    return min(dist, obj);\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n    \tscene(p + e.xyy) - scene(p - e.xyy),\n        scene(p + e.yxy) - scene(p - e.yxy),\n        scene(p + e.yyx) - scene(p - e.yyx)\n    ));\n}\n\nfloat raymarch(vec3 p, vec3 d) {\n    float dist = 0.0;\n    for(int i = 0; i < RAYMARCH_STEPS; ++i) {\n        dist += scene(p + d * dist);\n    }\n    return dist;\n}\n\nfloat occlusion(vec3 p) {\n    vec3 nml = sceneNormal(p);\n    float scale = AO_MAX_DIST / pow(2., float(AO_STEPS));\n    \n    float ocl = 0.0;\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2., float(i)) * scale;\n        ocl += 1. - (max(0., scene(p + nml * dist)) / dist);\n    }\n    \n    return ocl / float(AO_STEPS);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(cameraPosition(iTime), 1.).xzy;\n    vec3 camFocus = vec3(cameraPosition(iTime + 1.), 0.).xzy;\n    vec3 camDir = viewMatrix(camPos, camFocus) * normalize(vec3(uv, 1));\n    \n    float dist = raymarch(camPos, camDir);\n    float foreground = 1. - smoothstep(FAR_PLANE, FAR_PLANE + 1., dist);\n    \n    float ocl = occlusion(camPos + camDir * dist);\n    \n    fragColor = vec4(1. - ocl) * foreground;\n}","name":"Image","description":"","type":"image"}]}