{"ver":"0.1","info":{"id":"flBSWh","date":"1627488754","viewed":812,"name":"Audio Reactive Webcam Star Field","username":"Chriscamplin","description":"Following The Art of code's tutorial on a star field: https://www.youtube.com/watch?v=dhuigO4A7RY\nThen passing texture data from webcam & soundcloud\n\n","likes":17,"published":1,"flags":66,"usePreview":0,"tags":["random","rotate","webcam","starfield","audioreactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdtGRB","filepath":"https://soundcloud.com/chris-camplin/howsthatacidfeeling20","previewfilepath":"https://soundcloud.com/chris-camplin/howsthatacidfeeling20","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n#define PI2 6.28318530718\n#define NUM_LAYERS 6.\n\nmat2 rot2D(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n  p = fract(p*vec2(123.34, 465.21));\n  p += dot(p, p+45.32);\n  return fract(p.x * p.y);\n}\n\nfloat Star(vec2 uv, float flare) {\n    // star\n    float d = length(uv);\n    float m = 0.05/d;\n\n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m+=rays*flare;\n    uv *= rot2D(PI*.25);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*.3*flare;\n    \n    // prevent glow bleeding into neighbouring cells\n    m *= smoothstep(.75, .2, d);\n    return m;\n}\n\nvec3 StarLayer(vec2 uv, float snd) {\n    vec3 col = vec3(0.);\n    // fract & floor 2 sides of the same coin\n    // grid coord\n    vec2 gv = fract(uv)-.5;\n    // Tile ID\n    vec2 id = floor(uv);\n    // iterate through getting neighbours by offset\n    for(float y=-1.;y<=1.;y++) {\n        for(float x=-1.;x<=1.;x+=1.) {\n            vec2 offset = vec2(x, y);\n            float n = Hash21(id+offset);// rand between 0 & 1\n            float size =  snd;\n            vec3 color = sin(vec3(.2, .3, .9)*fract(n*2345.2)*PI2*20.)*.5+.5;\n            color *= color *vec3(1., .5, 1.+size);\n            float star = Star(gv-offset-vec2(n-.5, fract(n*34.))+.5, smoothstep(.9, 1., size));\n            col += star * size * color;\n        }\n    }\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1) with aspect ratio fix\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // actual uv normalised 0-1;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    uv*=4.;\n    vec3 snd = texture(iChannel1, UV).rgb;\n    vec3 vid = texture(iChannel0, UV-(snd.x*.05)).rgb;\n    uv = uv *abs(vid.rg);\n    float t = iTime*.005*snd.x;\n    uv*=rot2D(t);\n\n    for(int i = 0; i< 4;i++) {\n        //uv = normalize(abs(uv)/abs(dot(uv, uv))-vec2(vid.x));\n        uv=abs(-uv);\n    }\n    //  bg color\n    vec3 col = vec3(0.);\n    for(float i = 0.; i<1.;i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scl = mix(10.*snd.x, snd.x, depth);\n        float fade = depth*smoothstep(1.,0.9, depth);\n        col+= StarLayer(uv*scl+i*453.2, snd.x*2.)*fade;\n    }\n    // add red border to grid for debugging\n    //if(gv.x>.48||gv.y>.48) col.r=1.;\n    \n    col.rb += vid.xy * .4;\n    //col += Hash21(snd.xy);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}