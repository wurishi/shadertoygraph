{"ver":"0.1","info":{"id":"Wsy3zR","date":"1569535369","viewed":212,"name":"Musical raymarching","username":"zodiax","description":"Following Inigo Quilez's tutorial on raymarching. Did first 3h and since not have spare time in next weeks I decided to publish what I have so far. Will make next versions soon.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _tries 80\n#define _renTreshold 0.001\n\n//RENDERING OBJECTS HERE\n\n\t\tfloat smin(float a, float b, float k)// smooth minimum\n        {\n            float m = max(k - abs(a-b),0.0); //spike fucntion - checking when they are close enough to smooth\n        \tfloat s = min(a,b) - pow(m,2.)/(k*4.0);\n            return s;\n        }\n\n\t\tfloat smax(float a, float b, float k)// smooth maximum\n        {\n            float m = max(k - abs(a-b),0.0); //spike fucntion - checking when they are close enough to smooth\n        \tfloat s = max(a,b) + pow(m,2.)/(k*4.0);\n            return s;\n        }\n\n\t\t//Music animations\n\t\tfloat GatherSoundInfo(int SampleWished)// 0 - 512\n            {\n                return texelFetch(iChannel0, ivec2(float(SampleWished), 0), 0).r;\n            }\n\n\t//Cylinder\n\tfloat sdCappedCylinder( vec3 p, float h, float r )//https://iquilezles.org/articles/distfunctions\n        {\n          vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\n\t//Elipsoid\n\tfloat elipsoid(vec3 lastStep, vec3 rad)\n    {\n    \tfloat k0 = length(lastStep/rad);\n        float k1 = length(lastStep/rad/rad);\n        return k0*(k0-1.0)/k1;\n    }\n\n\t//Sphere\n\tfloat sphere(vec3 lastStep, float radius)\n    {\t\n    \treturn length(lastStep) - radius;\n    }\n\n\t//Character\n    vec2 character(vec3 lastStep)\n    {\n        \n        float time = 0.5 + sin(iTime/2.)/5.;\n        vec3 radius = vec3(0.25,0.25,0.25);\n        float parabola = 4.0*time*(1.0-time)- radius.y*3./4.; //up and down parabolic movement\n        \tfloat dParabola = 3.0*(1.0-2.0*time);//derivative to calc the angle\n        \tvec2 u = normalize(vec2(1.0,dParabola));\n        \tvec2 v = normalize(vec2(-dParabola, 1.0));\n\t\tfloat squashfactor = 0.5 + 0.5* parabola;\n        float strechfactor = 0.5 + 0.5*(1.-parabola);\n        radius.y *= squashfactor;\n        radius.xz *= strechfactor;\n        vec3 center = vec3(0.0,parabola,0.0);\n        \n        \tvec3 q = lastStep - center;\n        \t//q.xz = vec2(dot(u,q.xz),dot(v,q.xz));\n        \t\t//////////////ALL THE MODELLING OF THE HEAD\n        \t\t\t\t        \t\t\t\tfloat moveT = (step(cos(iTime),0.)*(-1.)+1.)*clamp(tan(iTime),-1.,1.)+step(cos(iTime),0.)*(-1.)*clamp(tan(iTime),-1.,1.);\n\n        \t\t\t//HEAD SHAPE\n        \t\t\tvec3 p = q + vec3(0.,0.,0.5);\n        \t\t\tfloat headP1 = elipsoid(p, vec3(0.55,0.6,.45));\n        \t\t\tp = vec3(pow(q.x,2.),q.yz)+vec3(-0.15,-0.35,0.48);\n        \t\t\tfloat headP2 = elipsoid(p, vec3(0.7,0.45,.45));\n        \t\t\t//Eyebrow\n        \t\t\tp = vec3(pow(q.x,2.),q.yz)+vec3(-0.2,-0.45,0.025);\n        \t\t\tp.xy = (mat2(3.,1.*sin(moveT),-1.,5.)/5.)*p.xy;// check pitagorian triplets\n        \t\t\tfloat headP3 = elipsoid(p, vec3(0.09,0.045,.03));\n        \t\t\t//Mouth\n        \t\t\tp = q + vec3(0.,0.4,0.25);\n        \t\t\t\tp.y += 2.*pow(p.x,2.)*0.7*moveT;\n        \t\t\tfloat headP4 = elipsoid(p, vec3(0.2,0.08,.2));\n        \t\t\t\n        \t\t\t//Combinig the parts\n        \t\t\tfloat head = smin(headP1,headP2,0.15);\n        \t\t\thead = smin(head, headP3, 0.08);\n        \t\t\thead = smax(head, -headP4,0.08);\n        \n        \t\t\t///NOSE\n        \t\t\tfloat d = elipsoid(q, radius);\n        \t\t\t\tvec3 h = q - vec3(0.0,0.25,-0.15);\n        \t\t\tfloat d2 = sphere(h, 0.15);\n        \t\t\t\th = vec3(abs(q.x),q.yz) - vec3(0.2,-0.03,-0.02);\n        \t\t\tfloat d3 = sphere(h, 0.1);\n\n        \t\t\td2 = smin(d2,d3,0.1);\n        \n        \t\t\tfloat nose = smin(d2,d,0.1);\n        \t\t\tnose = smin(nose, head, 0.03);\n        \n        \t\t\t///EYES\n         \n\t\t\t\t\th = q - vec3(0.35,0.3,-0.03);\n        \t\t\tfloat eyeRB = elipsoid(h, vec3(0.15,0.07,0.03));\n        \t\t\th = q - vec3(-0.35,0.3,-0.03);\n        \t\t\tfloat eyeLB = elipsoid(h, vec3(0.15,0.07,0.03));\n       \t\t\t\t\n        \t\t\th = q - vec3(0.35+(.07*moveT),0.3,-0.03);\n        \t\t\tfloat eyeR = sphere(h, 0.01);\n        \t\t\teyeR = smin(eyeR,eyeRB,0.04);\n  \t\t\t\t\th = q - vec3(-0.35+(.07*moveT),0.3,-0.03);\n        \t\t\tfloat eyeL = sphere(h, 0.01);\n        \t\t\teyeL = smin(eyeL,eyeLB,0.04);\n        \t\t\tfloat eyes = smin(eyeL, eyeR, 0.04);\n        \t\t\t        \n        \t\t\td = min(eyes, nose);\n        \t\t\t\n        //COLORING RESULT\n        vec2 result = vec2(d, 2.0);//DISTANCE AND IDENTIFIER\n        \n        \tif(eyeR<eyeRB || eyeL<eyeLB)\n            {\n            result.y = 3.0;\n            }\n        \tif(nose<eyes)\n            {\n            result.y = 4.0;\n            }\n        return result;\n    }\n\t//Glows\n\t\tvec2 glows(vec3 lastStep)\n\t\t{\n        \treturn vec2(1.,1.);\n        }\n\t//Musical cylinders\n\tfloat cylinders(vec3 lastStep)\n\t\t{\n        vec3 p = lastStep;\n        p.y += 0.5;\n        float height = .03;\n        float radius = 0.05;\n        float geo = 20.;\n        float dist = 0.7;\n        int parts = 10; \n        for(int i=0;i<parts;i++)\n        \t{\n                height = GatherSoundInfo(int(512./float(parts)*float(i)));\n        \t\tp.x = lastStep.x + sin((iTime/6.+3.151592*2./float(parts)*float(i)))*dist;\n                p.z = lastStep.z + cos((iTime/6.+3.151592*2./float(parts)*float(i)))*dist;\n                geo = min(sdCappedCylinder(p, radius, height ), geo);\n        \t}\t\n        return geo;\n        }\n\n//MAIN RENDERING FUCNCTION\nvec2 objects(vec3 lastStep)\n{\n    vec2 plane = vec2(lastStep.y - (-0.25),1.0);\n    //plane.x = lastStep.y - (((sin(lastStep.z*5.)*sin(iTime*0.2)+sin(lastStep.x*5.+iTime)*cos(iTime*0.7))/7.-0.45));\n    plane = vec2(lastStep.y - ((sin((lastStep.x)*2.)*(lastStep.x))*0.1*sin(lastStep.z)-0.5),1.0);\n    vec2 cylinders = vec2(cylinders(lastStep-vec3(0.0,0.0,-0.7)),5.);\n    vec2 character = character(lastStep-vec3(0.0,-0.2,0.0)); // check what is closer to the screen\n    float mixedFloor = smin(cylinders.x, plane.x, 0.1);\n    vec2 enviro = (plane.x < cylinders.x) ? plane : cylinders;\n    enviro.x = mixedFloor;\n    \n    return (enviro.x < character.x) ? enviro : character;\n}\n\n//END OF RENDERING OBJECTS\nvec3 calcNormal(vec3 localNormals)\n{\n    vec2 e = vec2(0.0001,0.0); //crete 2 variables - 1 null and other really small\n    return normalize(vec3(objects(localNormals+e.xyy).x - objects(localNormals-e.xyy).x,\n                          objects(localNormals+e.yxy).x - objects(localNormals-e.yxy).x,\n                          objects(localNormals+e.yyx).x - objects(localNormals-e.yyx).x)    \n    \t\t\t\t);\n}\nfloat castShadow(vec3 camPos, vec3 rayDirection)\n{\n\tfloat result = 1.0;\n    float dist = 0.01;\n    for(int i = 0; i<_tries; i++) //repeat 100 times or unless geometry found\n        {\n            vec3 lastStep = camPos + dist * rayDirection; // add the step to the ray\n            float renderableDist = objects(lastStep).x;\n\t\t\tresult = min(result,16.*renderableDist/dist);\n            if (result<0.0001) break;\n\t\t\tdist += renderableDist;\n            if (dist>20.) break;\n\n        }\n    return clamp(result,.0,1.);\n}\nvec2 castRay(vec3 camPos, vec3 rayDirection)\n{\n    float materialID = -1.;// initial mat\n    float dist = 0.01;//start with initial value of 0\n    for(int i = 0; i<_tries; i++) //repeat 100 times or unless geometry found\n        {\n            vec3 lastStep = camPos + dist * rayDirection; // add the step to the ray\n            vec2 renderableDist = objects(lastStep);\n            materialID = renderableDist.y;\n\n            if(dist < _renTreshold)\n                {\n                    break; //if the current distance from ray to shape is smaller than our threshold then finish the loop\n                }\n            else\n                {\n                    dist += renderableDist.x; // if the current distance is greater then the treshold then travel closer to it\n                }\n\n            if(dist > 20.0) \n                {\n                    break;   // far clip - do not render anything further than 20 // could be 0??\n                }\n        }\n    if(dist > 20.0) \n        {\n          \tdist = -1.0;  // far clip - do not render anything further than 20 // could be 0??\n        \tmaterialID = -1.0;\n        }\n    return vec2(dist,materialID);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//coordinate system\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) /iResolution.y; // -1 do 1 na y, x dependent from y\n    \n    \n    //camera position and orienation\n    \t//STEADY CAMERA\n       // vec3 camPos = vec3(0.0, 0.0, 1.0); // camera 1m away from the center\n       // vec3 rayDirection = normalize(vec3(uv, -1.5)); // ray direction from Camera to Pixel, add near clip\n    \t//MOVING CAMERA\n    \tvec3 camLook = vec3(0.0, 0.5, -1.0);\n    \tfloat angle = 10.0 * iMouse.x/iResolution.x;//0.3 * iTime;\n    \tvec3 camPos = vec3(1.3*sin(angle),0.0,1.3*cos(angle));\n    \t\t//rotating the direction\n    \t\tvec3 ww = normalize(camLook - camPos);\n    \t\tvec3 uu = normalize(cross(ww, vec3(0.0,1.0,.0)));\n    \t\tvec3 vv = normalize(cross(uu,ww));\n    \tvec3 rayDirection = normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n    \t\n    //initial color, background color\n    vec3 color = vec3(0.4,0.75,1.0) - 0.2*rayDirection.y;\n    color = mix(color, vec3(0.7,0.75,0.8), exp(-10.0*rayDirection.y)); // fade out color when far\n    //COLORING\n      vec2 depthMapMaterial = castRay(camPos, rayDirection);\n\n    //Casting the ray\n    //color the geometry - geometry shows only when it is more than 0, otherwise use initial color\n    if(depthMapMaterial.y > 0.0)\n    {\n        float depthMap = depthMapMaterial.x;\n        //Normals\n    \tvec3 worldNormals = camPos + (depthMap * rayDirection);\n        vec3 localNormals = calcNormal(worldNormals);\n        \n        //Sun and light\n            //001 SUN\n            vec3 sunColor = vec3(7.0,4.5,3.0); //affetcted intesity after mate\n            vec3 sunDirection = vec3(0.8,0.4,0.2); \n            float sunReflectionFactor = clamp(dot(localNormals,sunDirection),0.0,1.0);\n                //shadows\n                   float SunShadows = castShadow(worldNormals + localNormals*0.001, sunDirection);\n\n            //002 SKY\n            vec3 skyColor = vec3(0.5,0.8,0.9); //affetcted intesity after mate\n            vec3 skyDirection = vec3(0.0, 1.0, 0.0);\n            float skyReflectionFactor = clamp(0.5 + 0.5 * dot(localNormals,skyDirection),0.0,1.0); // starting with minimal value of 0.5\n\n            //003 BOUNCE - BELOW\n            vec3 bounceColor = vec3(0.7,0.3,0.2); //affetcted intesity after mate\n            vec3 bounceDirection = vec3(0.0, -1.0, 0.0);\n            float bounceReflectionFactor = clamp(0.5 + 0.5 * dot(localNormals,bounceDirection),0.0,1.0); // starting with minimal value of 0.5\n                \n        //Object colors\n        //MATERIAL\n        vec3 material = vec3(0.18);\n        if(depthMapMaterial.y == 1.0)\n            {\n\t\t\t\tmaterial = vec3(0.02,0.09,0.02);\n                float f = smoothstep(.3,.3,sin(18.0*worldNormals.x)+sin(18.0*worldNormals.z));\n                material += f*vec3(0.06,0.06,0.02);\n            }\n        else if(depthMapMaterial.y == 2.0)\n            {\n\t\t\t\tmaterial = vec3(1.0,1.0,1.0);\n            }\n        else if(depthMapMaterial.y == 3.0)\n            {\n\t\t\t\tmaterial = vec3(0.2,0.2,0.2);\n            }\n        else if(depthMapMaterial.y == 4.0)\n            {\n\t\t\t\tmaterial = vec3(0.8,0.8,0.2)*0.4;\n                \n            }\n         else if(depthMapMaterial.y == 5.0)\n            {\n\t\t\t\tmaterial = vec3(.1,0.1,0.2);\n            }\n        \n        color = material * sunColor * sunReflectionFactor * SunShadows; //Add sun light and shadows\n        color += material * skyColor * skyReflectionFactor; //Add sky light\n        color += material * bounceColor * bounceReflectionFactor; //Add bounce light\n    }\n    \n    //Gamma correction - from physics to eye\n    color = pow(color, vec3(0.4545));\n    \n    //FinalColor\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}