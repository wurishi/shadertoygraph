{"ver":"0.1","info":{"id":"XfByzW","date":"1722851798","viewed":56,"name":"cloud based ","username":"jamielobban","description":"asd","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I have no idea how to fix this dithering issue ill come back to it at some point.\n// there also a few tricks, plus i know the dithering issue is being produced by the jitter\n// and hash function\n\nconst int MAX_MARCHING_STEPS = 60;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 7.5;\nconst float PRECISION = 0.05;\nconst float MARCH_SIZE = 0.1;\n\n//light\nfloat marchSize = 0.075;\n\n#define MAX_STEPS_LIGHTS 5\n#define ABSORPTION_COEFFICIENT 1.\n#define SCATTERING_ANISO 0.1\n#define PI 3.14159265359\n\nconst vec3 SUN_POSITION = vec3(1, -0.3, -2.0);\n\n\n////////////////////////////////////////////////////\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n\nfloat HenyeyGreenstein(float g, float mu) {\n  float gg = g * g;\n\treturn (1.0 / (4.0 * PI))  * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = smoothstep(0.,1.,f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p, bool lowRes) {\n  vec3 q = p + iTime * 0.3 * vec3(0.6, -0.2, 0.3);\n\n  \n  float f = 0.8;\n  float scale = 0.6;\n  float factor = 2.05;\n    int maxOctave = 5;\n    \n    if(lowRes){\n        maxOctave = 3;\n    }\n    \n  for (int i = 0; i < maxOctave; i++) {\n      f += scale * noise(q);\n      q *= factor;\n      factor += 0.1;\n      scale *= 0.55;\n  }\n\n  return f;\n}\n\n////////////////////////////////////////////////////\nfloat sdSphere(vec3 p, float scale, vec3 elongation, vec3 offset)\n{\n    p = p - offset;\n    vec3 scaledP = p / elongation;\n    return length(scaledP) - scale;\n}\n\nfloat scene(vec3 p, bool lowRes) {\n  \n                        // its p, radius, scale, pos\n                        // would be ideal i can control the times of scrolling\n                        // here ill do it later, cause \n                        // i need to multiply the p value of fbm\n                        // by a vec3 which controls it\n                        \n  float distance = sdSphere(p, 0.25, vec3(1.5,1.,1.), vec3(-1.5,0.85,0.));\n  float d2 = sdSphere(p, 0.25,vec3(8.3,0.3,2.), vec3(0.7,-1.9,-2.));\n  \n  float res = min(distance,d2);\n  float f = fbm(p, lowRes);\n\n  return -res + f;\n}\n\n\n// Beer * Powder -> (exp(-dist * absorption  * 2.0f) but powder is just making it lighter\n// and its supposed to be 1. - (exp(-dist * absorption  * 2.0f)... \n// but its just not appearing with the 1.- so... a tomar x culo el 1.-\nfloat BeersLaw (float dist, float absorption) {\n  return exp((-dist * SCATTERING_ANISO)) * (exp(-dist * SCATTERING_ANISO  * 2.0f));;\n}\n\n// Jitter function\nfloat jitter(vec3 ro, vec3 rd, float time) {\n    return hash(dot(ro + rd + vec3(time), vec3(12.9898, 78.233, 45.164)));\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end, float jitterValue) {\n    vec4 res = vec4(0.0);\n    res.a = 4.; //start a bit forward since theres nothing in between\n    \n    float totalTransmittance = 1.0;\n    vec3 lightDirection = normalize(SUN_POSITION);\n    float totalDensity = 0.0;\n    \n    float phase = HenyeyGreenstein(ABSORPTION_COEFFICIENT, dot(rd, lightDirection));\n  \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + res.a * rd;\n        p += jitterValue * MARCH_SIZE * rd;\n\n        float density = scene(p, false);\n\n        if (density > PRECISION) {\n            for (int step = 0; step < MAX_STEPS_LIGHTS; step++) {\n                p += lightDirection * marchSize;\n\n                float lightSample = scene(p, true);\n                totalDensity += lightSample;\n            }\n            float lightTransmittance = BeersLaw(totalDensity, SCATTERING_ANISO);\n            \n            float luminance = 0.12 + density * 1.0 / (4.0 * 3.14);\n            totalTransmittance *= lightTransmittance;\n            res.rgb += totalTransmittance * luminance;\n        }\n\n        res.a += MARCH_SIZE;\n\n        if (res.a > MAX_DIST) break;\n    }\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 6.0); \n    vec3 rd = normalize(vec3(uv, -1.0)); \n\n    vec3 sunColor = vec3(1.0, 0.5, 0.3);\n    vec3 sunDirection = normalize(SUN_POSITION);\n    float sun = clamp(dot(sunDirection, rd), 0.0, 1.0);\n\n    float jitterValue = jitter(ro, rd, iTime * 0.01);\n\n    color = vec3(0.7, 0.7, 0.90) * 0.8;\n    color -= 0.9 * vec3(0.90, 0.75, 0.90) * rd.y;\n    color += sunColor * pow(sun, 1000.0);\n\n    vec4 res = rayMarch(ro, rd, MIN_DIST, MAX_DIST, jitterValue);\n\n    color = color + sunColor * res.rgb;\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}