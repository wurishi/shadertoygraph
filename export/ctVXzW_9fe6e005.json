{"ver":"0.1","info":{"id":"ctVXzW","date":"1685988875","viewed":129,"name":"magnet fractal","username":"adrinalino","description":"It show the colour of magnet where the steel ball ends after released ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractalchaos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by canagrisa https://www.youtube.com/watch?v=3jJ51bj1jTM\n// A steel ball gets released on a pixel.\n// There a 6 (variable : num) magnets (located at the black dots).\n// The pixel gets the colour of the magnet it is closest to after num_steps.\n// Over time I let the atraction constant k vary.\n// Feel free to experiment with the variables and create your own fractals\n\nint num = 4; // number of magnets\nint num_steps  = 1000; // number of timesteps before ending\nfloat k = -1.0;  // force = k/distance ^ power. k Varies over time\nfloat speed = 0.04; // the speed at which k changes\nfloat power = 0.8;\nfloat dt = 0.005;  // timestep\nfloat min_dist = .02;  // closest distance to magnet, to avoid iregularities\nfloat friction = 0.008; // dampening of ball\nfloat radius =  0.15;  // radius of the circle that the magnets are on\nfloat twopi =  6.28318530718;\n\n////////////////////////////////////////////////////////\n\nfloat magnet_y(int i){\n    float alfa = float(i) * twopi / float(num);\n    return radius * cos(alfa);\n}\n\n/////////////////////////////////////////////////////////\n\nfloat magnet_x(int i){\n      float alfa = float(i) * twopi / float(num);\n    return radius * sin(alfa);\n}\n\n/////////////////////////////////////////////////////////\n\nvec3 colour(int i){\n  return vec3(abs(cos(float(i)*1.234)), abs(cos(float(i)*5.324)), abs(sin(float(i)*7.423)));\n}\n\n/////////////////////////////////////////////////////////\n\nint select_final_magnet(vec2 uv) {\n  float vx = 0.;\n  float vy = 0.;\n  for (int i = 0; i < num_steps; i++) {\n    float fx = 0.;\n    float fy = 0.;\n    float dist;\n    float force;\n    for (int j = 0; j < num; j++) {\n      dist = max(length(uv - vec2(magnet_x(j), magnet_y(j))), min_dist); // max(length(uv - vec2(magnet_x(j), magnet_y(j)), min_dist));\n      force = k / pow(dist, power);\n      fx += force * (uv.x - magnet_x(j)) / dist;\n      fy += force * (uv.y - magnet_y(j)) / dist;\n    }\n    vx += fx * dt;\n    vy += fy * dt;\n    uv.x += vx * dt;\n    uv.y += vy * dt;\n    vx -= friction * vx;\n    vy -= friction * vy;\n  }\n  float closest = 1000000.; // just a big number\n  int col_code = 0;\n  for (int i = 0; i < num; i++) {\n    float afstand = length(uv - vec2( magnet_x(i), magnet_y(i)) );\n    if (afstand < closest) {\n      closest = afstand;\n      col_code = i;\n    }\n  }\n  return col_code;\n}\n\n/////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  k = -abs(sin(iTime * speed));\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\n    vec3 col = colour(select_final_magnet(uv));\n    \n    for (int i = 0; i < num; i++){\n      float len = length(uv-vec2(magnet_x(i), magnet_y(i)));\n      if (len < .003) col = vec3(0); //colour(i);    \n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}