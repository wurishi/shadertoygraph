{"ver":"0.1","info":{"id":"wlGXWt","date":"1583917224","viewed":810,"name":"Hearthbeat","username":"ceceppa","description":"Simple heartbeat shader inspired by this image https://i.stack.imgur.com/bUPoH.jpg\n\nand this Formula: \nhttps://www.reddit.com/r/Physics/comments/30royq/whats_the_equation_of_a_human_heart_beat/","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["heartbeath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SCALE = 2.;\nconst float LINES_WIDTH = 0.05;\nconst float DOT_SPEED_LIMITER = 5.;\nconst float EGC_SCALE = 1.;\nconst int MAX_TRAIL_ITEMS = 500;\n\nconst vec3 GRID_COLOR = vec3(.01, .07, .06);\nconst vec3 DOT_COLOR = vec3(1., 1., 1.);\nconst vec3 BLURRED_COLOR = vec3(.15, .68, .83);\nconst vec3 RING_COLOR = vec3(.10, .24, .25);\n\nfloat remap01(float t, float a, float b) {\n    return (t - a) / (b - a);\n}\n\nfloat Circle(vec2 uv, vec2 position, float radius, float blur) {\n    float distance = length(uv - position);\n\n    return smoothstep(radius, radius - blur, distance);\n}\n\nfloat GridLines(float t, float lines) {\n    return step(fract(t * lines), LINES_WIDTH);\n}\n\nvec3 Ring(vec2 uv, vec2 position) {\n    float ring = Circle(uv, position, .08, .01);\n\tring -= Circle(uv, position, .065, .01);\n    \n    return RING_COLOR * ring;\n}\n\n\nfloat spike(float x, float d, float w, float raiseBy) {\n    float f1 = pow(abs(x + (d * SCALE)), raiseBy);\n\n    return exp(-f1 / w);\n}\n\nfloat generateEGC(float x) {\n    x -= .5 * SCALE;\n\n    float a = 0.4 * SCALE;\n\tfloat d = .3;\n\tfloat w = 0.001;\n    \n    float f1 = a * spike(x, d, w, 2.);\n    float f2 = a * spike(x, d - 0.1, 2. * w, 2.);\n    float f3 = a * 0.7 * spike(x, d - 0.3, 0.002, 2.);\n    float f3a = 0.15 * spike(x, d - 0.37, 0.0001, 4.);\n    float f4 = 0.25 * spike(x, d - 0.5, 0.005, 2.);\n    float f5 = 0.1 * spike(x, d - 0.75, 0.0001, 4.);\n\n    float f6 = a * spike(x, d - 1., 0.002, 2.);\n    float f7 = 0.5 * spike(x, d - 1.1, w, 2.);\n\n    float f8 = 0.1 * spike(x, d - 1.3, 0.0001, 4.);\n    float f9 = 0.1 * spike(x, d - 1.45, 0.0001, 4.);\n\n    return f1 - f2 + f3 + f3a - f4 + f5 + f6 - f7 - f8 + f9;\n}\n\nfloat getDotXPosition() {\n    // Animate the dot position from left --> right\n    float dotX = fract(iTime / DOT_SPEED_LIMITER);\n\tdotX *= 2. * SCALE;\n\n    return dotX;\n}\n\nvec3 MovingDot(vec2 uv, vec2 dotPosition) {\n    float movingDot = Circle(uv, dotPosition, .015, .01);\n    float smallBlurredDot = Circle(uv, dotPosition, .06, .1);\n\tfloat bigBlurredDot = Circle(uv, dotPosition, .3, .6);\n\n    vec3 color = DOT_COLOR * movingDot;\n    color += BLURRED_COLOR * smallBlurredDot;\n    color += BLURRED_COLOR * bigBlurredDot;\n    color += Ring(uv, dotPosition);\n\n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Scale the view\n    uv *= SCALE;\n\n    uv.y -= .5 * SCALE; // Center the Y axis\n    uv.x *= iResolution.x / iResolution.y; // Keeps the aspect ratio\n\n    float grid = GridLines(uv.x, 6.) + GridLines(uv.y, 6.);\n    vec3 color = GRID_COLOR * grid;\n\n    float dotX = getDotXPosition();\n    vec2 dotPosition = vec2(dotX, generateEGC(dotX));\n\n\tcolor += MovingDot(uv, dotPosition);\n\n    for(int i = 1; i < MAX_TRAIL_ITEMS; i++) {\n        float delayedX = dotX - (float(i) * 0.002);\n\t\tvec2 trailPosition = vec2(delayedX, generateEGC(delayedX));\n\n        float trail = Circle(uv, trailPosition, 0.028, 0.1);\n        float trailBlur = Circle(uv, trailPosition, 0.06, 0.5);\n\n        float q = 1. - remap01(float(i), 1., float(MAX_TRAIL_ITEMS));\n\n        color += (DOT_COLOR * q) * trail;\n        color += trailBlur * (BLURRED_COLOR * q);\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}