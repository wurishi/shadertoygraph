{"ver":"0.1","info":{"id":"llyfzD","date":"1541988640","viewed":170,"name":"Poison bubbles","username":"kernalphage","description":"cellular  noise!  it started as trying to imitate waves but uhh... here we are. the normals look pointy, and im not quite sure how to fix it. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["codevember","poison"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nfloat cellular(vec2 pos, int i, int j){\n    pos = pos-.5;\n    float pp =  3. * sin(4.*atan(pos.y, pos.x)*iTime);\n    return length(pos * pp);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat bubble( vec2 uv) {\n   // return length(.5 - uv);\n    // Scale\n    vec2 st = 5.4 * uv;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\t\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point) * vec2(.5, 1);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n            // Distance to the point\n            float dist = length(diff);\n\t\t\t//dist = pow(dist, .7 + .5 * random2(i_st + neighbor + 114.215).x);\n            // Keep the closer distance\n            m_dist = opSmoothUnion(m_dist, dist, 0.5);\n        }\n    }  \n    //return 1./(1.13+m_dist);\n    return m_dist;\n}\n\nfloat lighting(vec3 light, vec3 normal){\n \n    return .5 * max(dot( normal, light), .24);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= 1.64;\n    \n    //calculate normal\n    float m_dist = bubble(uv);\n    vec3 pos = vec3(uv, m_dist); \n    \n    vec3 dx = vec3(.05,0.,0.);\n    dx = pos - vec3(uv+ dx.xy, bubble(uv + dx.xy));\n    \n    vec3 dy = vec3(0.,.05,0.);\n    dy = pos - vec3(uv+ dy.xy, bubble(uv + dy.xy));    \n\t\n    vec3 normal =  normalize(cross(1./dx, 1./dy));\n\n    // calculate color \n    float col = smoothstep(1.-uv.y*2.,1.-uv.y*1., m_dist * sin(iTime * .2));\n    vec3 background = vec3(.60 , .14, .20)*uv.y;\n    vec3 foreground = vec3(.0, .82306, .320);\n    \n    // lighting\n    float light = lighting(normalize(vec3(1.2,sin(iTime)*-.72,3.14)), normal);\n    light += lighting(normalize(vec3(4.2,-3.35,6.7)), normal);\n  \tlight = max(light, col);\n    vec3 color = light *  mix(foreground,background, col);\n    \n    // Output to screen\n    fragColor =  vec4(.5 + .5 * normal, 1.0);\n    //fragColor = vec4(m_dist);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}