{"ver":"0.1","info":{"id":"Nll3Wf","date":"1623012683","viewed":76,"name":"Smooth trunchet circles","username":"Envy24","description":"Smooth trunchet circles","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circles","smooth","trunchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample2DHashUI32(uint x, uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * enthropy2 + x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nvec2 trunchetPattern(vec2 uv, float random)\n{\n    // random = [0.0; 1.0]\n    // uv = ([0.0; 1.0], [0.0; 1.0])\n\n    uv.x = mix(uv.x, 1.0 - uv.x, float(random > 0.66));\n    uv.y = mix(uv.y, 1.0 - uv.y, float(random > 0.33));\n    \n    // some smoothstep distortion.\n    //uv.x = uv.x * uv.x * (3.0 - 2.0 * uv.x);\n    //uv.y = uv.y * uv.y * (3.0 - 2.0 * uv.y);\n    \n    return uv;\n}\n\nfloat circles(\n    vec2 tile,\n    float innerRadius,\n    float outerRadius)\n{\n    float length0 = length(tile); // distance from BL corner to fragment.\n    float length1 = length(tile - vec2(1.0)); // distance from TR corner to fragment.          \n                              \n    if ((float(length0 < outerRadius && length0 > innerRadius)) == 1.0)\n    {\n        if (length0 < 0.5)\n        {\n            return smoothstep(innerRadius, outerRadius, length0);\n        }\n        else\n        {\n            return smoothstep(outerRadius, innerRadius, length0);\n        }     \n    }\n    if ((float(length1 < outerRadius && length1 > innerRadius)) == 1.0)\n    {\n        if (length1 < 0.5)\n        {\n            return smoothstep(innerRadius, outerRadius, length1);\n        }\n        else\n        {\n            return smoothstep(outerRadius, innerRadius, length1);\n        }   \n    }\n}\n\nfloat circlesBranchless(\n    vec2 tile,\n    float innerRadius,\n    float outerRadius)\n{\n    float length0 = length(tile); // distance from BL corner to fragment.\n    float length1 = length(tile - vec2(1.0)); // distance from TR corner to fragment.          \n                              \n    // branchless\n    float semicircle0 = float(length0 < outerRadius && length0 > innerRadius);\n    float semicircle1 = float(length1 < outerRadius && length1 > innerRadius);\n\n    float l = length0 * semicircle0 + length1 * semicircle1;\n    \n    float p = float(l < 0.5);\n    float i = p * innerRadius + (1.0 - p) * outerRadius;\n    float o = p * outerRadius + (1.0 - p) * innerRadius;\n    \n    //return step((o - i) / 2.0, l);   // no AA\n    return smoothstep(i, o, l);        // AA\n}\n\nvec2 makeTiles(\n    const vec2 uv,\n    const float pixelWidth)\n{\n    return vec2(\n        uv.x * pixelWidth,\n        uv.y * pixelWidth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float offset = mix(5.0, 30.0, step(0.5, uv.x));\n    \n    float scale = offset + (iMouse.y / iResolution.y * 30.0);\n    uv = makeTiles(uv, 1.0 * scale);\n    \n    vec2 ipos = floor(uv);\n    vec2 fpos = fract(uv);\n    \n    vec2 tile = \n        trunchetPattern(\n            fpos,\n            clamp(0.0, 1.0, sample2DHashUI32(uint(ipos.x), uint(ipos.y)) + sin(iTime * 1.0) * 0.1)\n            );\n\n    float gray = circlesBranchless(tile, 0.3, 0.7);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"}]}