{"ver":"0.1","info":{"id":"wtdXz7","date":"1580689086","viewed":482,"name":"eye boids","username":"monsterkodi","description":"MOUSE: move center of attraction\nUP: ambient occlusion\nLEFT: colors\nDOWN: antialias\nRIGHT: animation","likes":36,"published":1,"flags":48,"usePreview":0,"tags":["sdf","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define keys(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n#define load(x) texelFetch(iChannel1, ivec2(x,0), 0)\n#define load3(x,y) texelFetch(iChannel3, ivec2(x,y), 0)\n#define font(x,y) texelFetch(iChannel2, ivec2(x,y), 0)\n\nbool keyState(int key) { return keys(key, 2).x < 0.5; }\nbool keyDown(int key)  { return keys(key, 0).x > 0.5; }\n\n#define ZERO min(iFrame,0)\n#define MAX_STEPS  128\n#define MIN_DIST   0.002\n#define MAX_DIST   5.0\n#define SHADOW     0.2\n#define FLOOR      0.0\n\n#define NONE  0\n#define PLANE 1\n#define BULB  2\n#define PUPL  3\n\nbool anim, soft, occl, light;\n\nvec3 camPos;\nvec3 camTgt;\nvec3 camDir;\n\nint  mat;\nint  num;\nint  AA = 2;\n\nfloat planeDist;\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nsdf s;\n\n// 00000000  000   000  00000000  \n// 000        000 000   000       \n// 0000000     00000    0000000   \n// 000          000     000       \n// 00000000     000     00000000  \n\nvoid eye(int id, vec3 pos, vec3 n)\n{\n    float d, r = 0.1;\n        \n   \td = sdSphere(s.pos, pos, r);\n    \n    if (d > s.dist+r) return;\n    \n    float fid = float(id);\n    vec3 hsh1 = hash31(fid+floor(iTime*fid/(fid-0.5)*0.2));\n    vec3 hsh2 = hash31(fid+floor(iTime*fid/(fid-0.5)*0.3));\n    \n    n  = normalize(n+(hsh1 + hsh2 - 1.0)*(dot(n,vz)-0.5));\n    \n    vec3 pupil = pos+1.0*r*n;\n    vec3 lens  = pos+0.5*r*n;\n    \n    d = opDiff(d, sdSphere(s.pos, pupil, r*0.75), r*0.1);\n\n    if (d < s.dist) { s.mat = BULB; s.dist = d; }\n    \n    d = min(d, sdEllipsoid(s.pos, lens, r*vec3(0.7, 0.7, 0.35)));\n    \n    if (d < s.dist) { s.mat = PUPL; s.dist = d; }\n    \n    d = opUnion(planeDist, sdTorus(s.pos, pos+0.0*vz, vz, r*1.3, r*0.2), r*0.3);\n    \n    if (d < s.dist) { s.mat = PLANE; s.dist = d; }\n}\n\nvoid nose(vec3 pos)\n{\n    float r = 0.1;\n    float d = sdPlane(s.pos, v0, vz);\n \n    d = opDiff (d, sdSphere(s.pos, pos, r*1.4), r*0.4);\n    \n    planeDist = d;\n    if (d < s.dist) { s.mat = PLANE; s.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    s = sdf(1000.0, p, NONE);\n    \n    nose(vec3(gl.mp,0));\n     \n    for (int i = 1; i <= num; i++)\n    {\n        vec4 fish = load(i);\n            \n        float fd = length(fish.xy-gl.uv); \n        \n        if (fd < 0.5 || gl.option!=0)\n    \t{\n            vec3 fp = vec3(fish.x,fish.y,0);\n            vec3 fdir = vec3(fish.zw,0);\n            eye(i, fp, normalize(normalize(camPos-fp) + 1.5*fdir));\n    \t}\n    }\n\n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    float shade = 1.;\n    float dist = MIN_DIST;    \n    vec3 rd = (lp-ro);\n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/25.0;\n    rd /= end;\n    for (int i=0; i<25; i++)\n    {\n        float h = map(ro+rd*dist);\n        //if (s.mat != BBOX)\n            shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n//  0000000    0000000   0000000  000      000   000   0000000  000   0000000   000   000  \n// 000   000  000       000       000      000   000  000       000  000   000  0000  000  \n// 000   000  000       000       000      000   000  0000000   000  000   000  000 0 000  \n// 000   000  000       000       000      000   000       000  000  000   000  000  0000  \n//  0000000    0000000   0000000  0000000   0000000   0000000   000   0000000   000   000  \n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n    if (!occl) return 1.0;\n    float a = 0.0;\n    float weight = 1.0;\n    for (int i = ZERO; i <= 6; i++)\n    {\n        float d = (float(i) / 6.0) * 0.3;\n        a += weight * (d - map(p + n*d));\n        weight *= 0.8;\n    }\n    float f = clamp01(1.0-a);\n    return f*f;\n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat shiny(float rough, float NoH, const vec3 h) \n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * rough;\n    float k = rough / (oneMinusNoHSquared + a * a);\n    float d = k * k / PI;\n    return d;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 col)\n{\n    if (mat == NONE) return col;\n    \n    vec3 cr = cross(camDir, vec3(0,1,0));\n    vec3 up = normalize(cross(cr,camDir));\n    vec3 lp = vec3(-0.5,1.0,4.0); \n    vec3 l = normalize(lp-p);\n \n    float ambient = 0.005;\n    float dif = clamp(dot(n,l), 0.0, 1.0);\n    \n    if (mat == PUPL)\n    {\n        dif = clamp(dot(n,normalize(mix(camPos,lp,0.1)-p)), 0.0, 1.0);\n        dif = mix(pow(dif, 16.0), dif, 0.2);\n        dif += 1.0 - smoothstep(0.0, 0.2, dif);\n        if (mat == PUPL) ambient = 0.1;\n    }\n    else if (mat == BULB)\n    {\n        dif = mix(pow(dif, 32.0), 3.0*dif+1.0, 0.2);\n        ambient = 0.12;\n    }\n    else if (mat == PLANE)\n    {\n        dif = mix(pow(dif, 2.0), dif, 0.2);\n    }\n    \n    if (mat == PLANE || mat == BULB)\n    {\n        dif *= softShadow(p, lp, 6.0);        \n    }\n       \n    col *= clamp(dif, ambient, 1.0);\n    col *= getOcclusion(p, n);\n    \n    if (light) col = vec3(dif*getOcclusion(p, n));\n    \n   \tif (mat == PUPL || mat == BULB)\n    {\n        col += vec3(pow(clamp01(smoothstep(0.9,1.0,dot(n, l))), 20.0));\n    }\n    else if (mat == PLANE)\n    {\n        col += col*vec3(pow(clamp01(smoothstep(0.25,1.0,dot(n, l))), 2.0));\n        col += col*vec3(pow(clamp01(smoothstep(0.9,1.0,dot(n, l))), 4.0));\n    }\n    \n    if (light) col = clamp(col, 0.0, 1.0);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initGlobal(fragCoord, iResolution, iMouse, iTime);\n    for (int i = KEY_1; i <= KEY_9; i++) { if (keyDown(i)) { gl.option = i-KEY_1+1; break; } }\n    \n    soft  = !keyState(KEY_DOWN);\n    light = !keyState(KEY_LEFT);\n    anim  =  keyState(KEY_RIGHT);\n    occl  =  keyState(KEY_UP);\n    \n    vec3 cols = v0, col = v0;\n\tnum = int(load(0).x);\n    \n    if (!soft) AA = 1; \n    \n   \tvec2 ao = vec2(0);\n    \n    float md = 4.0;\n    float my = 0.0;\n    float mx = 0.0;\n        \n    camTgt = v0; \n  \tcamPos = rotAxisAngle(rotAxisAngle(vec3(0,0,md), vx, 89.0*my), vy, -180.0*mx);\n        \n    vec3 ww = normalize(camTgt-camPos);\n    vec3 uu = normalize(cross(ww, vy));\n    vec3 vv = normalize(cross(uu, ww));\n    float fov = 4.0 + float(gl.option);\n    \n    for( int am=ZERO; am<AA; am++ )\n    for( int an=ZERO; an<AA; an++ )\n    {\n        if (AA > 1) ao = vec2(float(am),float(an))/float(AA)-0.5;\n\n        gl.uv = (2.0*(fragCoord+ao)-iResolution.xy)/iResolution.y;\n    \n        vec3 rd = normalize(gl.uv.x*uu + gl.uv.y*vv + fov*ww);\n        \n        float d = rayMarch(camPos, rd);\n        mat = s.mat;\n        \n        vec3 p = camPos + d * rd;\n        vec3 n = getNormal(p);\n                \n        if      (mat == PLANE) col = vec3(0.15, 0.0, 0.0);\n        else if (mat == PUPL)  col = vec3(0.1, 0.1, 0.5);\n        else if (mat == BULB)  col = vec3(1.0, 1.0, 1.0);\n        else if (mat == NONE)  col = vec3(0.22, 0.0, 0.0);\n    \n        col = getLight(p, n, col);\n            \n        cols += col;\n    }\n    \n    col = cols/float(AA*AA);\n    \n    col *= pow(clamp01(1.2*gl.aspect-length(gl.uv)), 0.5);\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define keys(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n#define save(a,c) if(gl.ifrag.x==(a)&&gl.ifrag.y==0){gl.color=(c);}\n#define load(x) texelFetch(iChannel1, ivec2(x,0), 0)\n\nbool keyState(int key) { return keys(key, 2).x < 0.5; }\n\nint  id = -1;\nint  num = 0;\nvec4 val;\n\n#define SPEED    0.05\n#define DAMP     0.5\n#define MAX_FISH 18.\n\nvec2 hash(int n) { return fract(sin(vec2(float(n),float(n)*7.))*43758.5); }\n\nvec2 repulse(vec4 fish, vec2 target, float dist, float a)\n{\n    vec2 w = target-fish.xy;\n    float x = length(w);\n    if (x < EPSILON) return a*0.5*(hash31(float(id))-vec3(0.5)).xy;\n    return w*a*(smoothstep(0.0, dist, x)-1.0)/x;\n}\n\nvec2 attract(vec4 fish, vec2 target, float dist, float a, float s2, float s3)\n{\n    vec2  w = target-fish.xy;\n    float x = length(w);\n    float k = dist+s2;\n    float d = (2.0*dist+s2)*0.5;\n    float xkd = (x-d)/(k-d);\n    float l = min(max(-1.0, -abs(x-d)/(k-d)), xkd*exp(1.0+xkd));\n    float r = max(-1.0, xkd*exp(1.0-xkd)-max(0.0,(1.0-s3)*(1.0-exp(1.0-x/k))));\n    float f = a*max(r,l)*0.5+0.5;\n    return w*f;\n}\n\nvec2 swirl(vec4 fish, vec2 center, float a, float k)\n{\n    vec2 w = center-fish.xy;\n    w = vec2(-w.y,w.x);\n    return sign(k)*w*a/pow(length(w),abs(k));\n}\n\nvoid boid()\n{\n    vec2 vel, acc, w, u = vec2(0.0);\n    vec4 fish = load(id);\n    \n    if (!keyState(KEY_RIGHT)) { save(id, fish); return; }\n    \n    float d, v, a;\n      \n    for (int i = 1; i <= num; i++) \n    {\n        if (i == id) continue;\n    \tacc += repulse(fish, load(i).xy, 0.55, 4.0);\n\t}\n\n    acc += attract(fish, gl.mp, 0.025, 0.01, 0.2, 0.1);\n    acc += repulse(fish, gl.mp, 0.45, 20.0);\n    acc += swirl  (fish, gl.mp, iTimeDelta/6.0, 6.0*sin(iTime*0.25));\n    \n    //acc = normalize(acc)*min(0.5,length(acc));\n    vel = fish.zw + acc*SPEED;\n\n   \tvel *= pow(DAMP, SPEED);\n    \n    w = fish.xy+vel*SPEED;\n    \n    float b = 0.175;\n    val.x  = clamp(w.x,-1.0*gl.aspect+b,1.0*gl.aspect-b);\n    val.y  = clamp(w.y,-1.0+b,1.0-b);\n    val.zw = vel;\n    \n    save(id, val);\n}\n\nvoid initFish(int id)\n{\n   float r = 2.0*hash11(float(id))-1.0;\n   save(id, 0.5*vec4(r, 2.0*fract(r*123.0)-1.0, 0.0, 0.0)); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initGlobal(fragCoord, iResolution, iMouse, iTime);\n    \n    if (iFrame == 0) \n    {\n\t\tsave(0,vec4(1,0,0,0));\n        initFish(1);\n        fragColor = gl.color;\n        return;\n    }\n\n    ivec2 mem = ivec2(fragCoord);\n    if (mem.y > 0) return;\n    id = mem.x;\n\n    val = load(id);\n\tnum = int(load(0).x);\n    \n    if (id == 0)\n    {\n        save(id,vec4(clamp(floor(iTime*20.0)+1.0, 1.0, MAX_FISH),0,0,0));\n    }\n    else\n    {\n        if (id > num) initFish(id);\n        else boid();\n    }\n    \n    fragColor = gl.color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589\n#define E  2.718281828459\n#define EPSILON 0.0000001\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n#define KEY_SPACE 32\n#define KEY_1     49\n#define KEY_9     57\n\nconst vec3 v0 = vec3(0,0,0);\nconst vec3 vx = vec3(1,0,0);\nconst vec3 vy = vec3(0,1,0);\nconst vec3 vz = vec3(0,0,1);\n\nconst vec3 red   = vec3(0.8,0.0,0.0);\nconst vec3 green = vec3(0.0,0.5,0.0);\nconst vec3 blue  = vec3(0.2,0.2,1.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\n\n//  0000000   000       0000000   0000000     0000000   000      \n// 000        000      000   000  000   000  000   000  000      \n// 000  0000  000      000   000  0000000    000000000  000      \n// 000   000  000      000   000  000   000  000   000  000      \n//  0000000   0000000   0000000   0000000    000   000  0000000  \n\nstruct _text {\n    ivec2 size;\n    ivec2 adv;\n} text;\n\nstruct _gl {\n    vec2  uv;\n    vec2  frag;\n    vec2  mouse;\n    vec2  mp;\n    ivec2 ifrag;\n    float aspect;\n    vec4  color;\n    int   option;\n    float time;\n} gl;\n\nvoid initGlobal(vec2 fragCoord, vec3 resolution, vec4 mouse, float time)\n{\n    //text.size = ivec2(8,16);\n    text.size = ivec2(16,32);\n    text.adv  = ivec2(text.size.x,0);\n    \n    mouse.xy = min(mouse.xy,resolution.xy);\n    if (mouse.z < 1.0)\n    {\n        if (mouse.z > -1.0)\n        \tgl.mouse = resolution.xy*0.5;\n       \telse\n            gl.mouse = mouse.xy;\n       \n        \n        //gl.mouse.x += sin(time*2.0)*resolution.y/32.0;\n    }\n    else gl.mouse = mouse.xy;\n    \n\tgl.mp = (2.0*abs(gl.mouse)-vec2(resolution.xy))/resolution.y;    \n\n    gl.aspect = resolution.x / resolution.y;\n    gl.frag   = fragCoord;\n    gl.ifrag  = ivec2(fragCoord);\n    gl.uv     = (fragCoord+fragCoord-resolution.xy)/resolution.y;\n}\n\nfloat powi(int a, int b) { return pow(float(a), float(b)); }\nfloat log10(float a) { return log(a)/log(10.0); }\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\n// 000   000   0000000    0000000  000   000  \n// 000   000  000   000  000       000   000  \n// 000000000  000000000  0000000   000000000  \n// 000   000  000   000       000  000   000  \n// 000   000  000   000  0000000   000   000  \n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gradientNoise(vec2 v)\n{\n    return fract(52.9829189 * fract(dot(v, vec2(0.06711056, 0.00583715))));\n}\n\n// 000   000   0000000  000      \n// 000   000  000       000      \n// 000000000  0000000   000      \n// 000   000       000  000      \n// 000   000  0000000   0000000  \n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsl(float h, float s, float l) { return hsl2rgb(vec3(h,s,l)); }\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + EPSILON)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              \n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + EPSILON),  \n                 (minc+maxc)*0.5 );                           \n}\n\n// 00     00   0000000   000000000  00000000   000  000   000  \n// 000   000  000   000     000     000   000  000   000 000   \n// 000000000  000000000     000     0000000    000    00000    \n// 000 0 000  000   000     000     000   000  000   000 000   \n// 000   000  000   000     000     000   000  000  000   000  \n\nmat3 alignMatrix(vec3 dir) \n{\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nmat3 rotMat(vec3 u, float angle)\n{\n    float s = sin(deg2rad(angle));\n    float c = cos(deg2rad(angle));\n    float i = 1.0-c;\n    \n    return mat3(\n        c+u.x*u.x*i, u.x*u.y*i-u.z*s, u.x*u.z*i+u.y*s,\n        u.y*u.x*i+u.z*s, c+u.y*u.y*i, u.y*u.z*i-u.x*s,\n        u.z*u.x*i-u.y*s, u.z*u.y*i+u.x*s, c+u.z*u.z*i\n        );\n}\n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{\n    mat3 m = rotMat(axis, angle);\n    return m * position;\n}\n\n//  0000000   000   000   0000000   000000000  \n// 000   000  000   000  000   000     000     \n// 000 00 00  000   000  000000000     000     \n// 000 0000   000   000  000   000     000     \n//  00000 00   0000000   000   000     000     \n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    float half_angle = deg2rad(angle*0.5);\n    return vec4(axis*sin(half_angle), cos(half_angle));\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 q, vec3 p)\n{\n    vec4 conj = quatConj(q);\n    vec4 q_tmp = quatMul(q, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\nvec3 rotate(vec4 q, vec3 o, vec3 p)\n{\n    vec4 conj = quatConj(q);\n    vec4 q_tmp = quatMul(q, vec4(p-o, 0));\n    return o + quatMul(q_tmp, conj).xyz;\n}\n\nvec3 rotAxisAngleQuat(vec3 p, vec3 axis, float angle)\n{ \n    vec4 qr = quatAxisAngle(axis, angle);\n    return quatMul(quatMul(qr, vec4(p, 0)), quatConj(qr)).xyz;\n}\n\nvec3 rotRayAngle(vec3 p, vec3 ro, vec3 rd, float angle)\n{ \n    return rotAxisAngle(p-ro, rd-ro, angle)+ro;\n}\n\nvec3 rotY(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x*c+v.z*s, v.y, v.z*c+v.x*s);\n}\n\nvec3 rotX(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x, v.y*c+v.z*s, v.z*c+v.y*s);\n}\n\nvec3 rotZ(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x*c+v.y*s, v.y*c+v.x*s, v.z);\n}\n\n//  0000000   00000000   0000000   00     00    \n// 000        000       000   000  000   000    \n// 000  0000  0000000   000   000  000000000    \n// 000   000  000       000   000  000 0 000    \n//  0000000   00000000   0000000   000   000    \n\n\nvec3 posOnPlane(vec3 p, vec3 a, vec3 n)\n{\n    return p-dot(p-a,n)*n;\n}\n\nvec3 posOnRay(vec3 ro, vec3 rd, vec3 p)\n{\n    return ro + max(0.0, dot(p - ro, rd) / dot(rd, rd)) * rd;\n}\n\nbool rayIntersectsSphere(vec3 ro, vec3 rd, vec3 ctr, float r)\n{\n    return length(posOnRay(ro, rd, ctr) - ctr) < r;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2)\n{\n    float k = 0.15;\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opUnion(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opDiff(float d1, float d2, float k) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{   \n    return dot(n, p);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 a, vec3 r)\n{\n    p = p-a;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(p-c)-(t*r2+(1.0-t)*r1);      \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, float rl, float rs)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-rl,abs(dot(n, q))))-rs;\n}\n","name":"Common","description":"","type":"common"}]}