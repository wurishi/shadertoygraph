{"ver":"0.1","info":{"id":"ssScz1","date":"1643081011","viewed":140,"name":"Three-Body Trilogy - Raindrops","username":"nelsonkuang","description":"Raindrops' Marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raindrop","threebody"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2022 NelsonKuang\n// Inspired by https://inspirnathan.com/posts/63-shadertoy-tutorial-part-16\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset) {\n  return length(p - offset) - r;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h, vec3 offset) {\n  p = p - offset;\n  float q = length(p.yz);\n  return max(dot(c.xy, vec2(q, -p.x)), -h + p.x);\n}\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opRepRaindrop(vec3 p, vec3 c) {\n  p = mod(p + 0.5 * c, c) - 0.5 * c;\n  return opUnion(sdSphere(p, 0.75 / 4., vec3(0, 0, 0)), sdCone(p, vec2(.939, .541) / 4., 1.118 / 4., vec3(-1.485 / 4.0, 0., 0)));\n}\n\nfloat sdScene(vec3 p) {\n  return opRepRaindrop(p, vec3(8));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if(d < PRECISION || depth > MAX_DIST)\n      break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  float r = 1.;\n  return normalize(e.xyy * sdScene(p + e.xyy) +\n    e.yyx * sdScene(p + e.yyx) +\n    e.yxy * sdScene(p + e.yxy) +\n    e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n  vec3 cd = normalize(lookAtPoint - cameraPos);\n  vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n  vec3 cu = normalize(cross(cd, cr));\n\n  return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal) {\n  vec3 cubemapReflectionColor = texture(iChannel0, reflect(rd, normal)).rgb;\n  vec3 K_a = cubemapReflectionColor;\n  vec3 K_d = vec3(1);\n  vec3 K_s = vec3(1);\n  float alpha = 50.;\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n  uv.x -= iTime * 0.05;\n\n  vec2 mouseUV = iMouse.xy / iResolution.xy;\n  if(mouseUV == vec2(0.0))\n    mouseUV = vec2(0.5);\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI / 2., PI / 2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n  vec3 col = vec3(0);\n\n  float d = rayMarch(ro, rd);\n\n  vec3 p = ro + rd * d;\n  vec3 normal = calcNormal(p);\n\n  vec3 lightPosition1 = vec3(1, 1, 1);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  vec3 lightPosition2 = vec3(-8, -6, -5);\n  vec3 lightDirection2 = normalize(lightPosition2 - p);\n\n  float lightIntensity1 = 0.6;\n  float lightIntensity2 = 0.3;\n\n  vec3 raindropColor = phong(lightDirection1, lightIntensity1, rd, normal);\n  raindropColor += phong(lightDirection2, lightIntensity2, rd, normal);\n  raindropColor += fresnel(normal, rd) * 0.4;\n\n  col = mix(col, raindropColor, step(d - MAX_DIST, 0.));\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}