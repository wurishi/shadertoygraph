{"ver":"0.1","info":{"id":"wd2BRc","date":"1590549566","viewed":145,"name":"htw/Matrix_text","username":"htw6174","description":"actual text","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["text"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made in collaboration with user lucasrumney94\n// See his version here: https://www.shadertoy.com/view/3d2fRd\n// TODO: each column goes from bright to dark and then jumps back to bright\n// Brigntness is offset by random based on column\n\n// probably only needed for serious optimization\n//const float sixteenth = 1. / 16.;\n#define EPSILON 0.01\n#define SHARPNESS 0.2\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 100000.0);\n}\n\nfloat rand2(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n/* Returns an ASCII character identifier for one of the uppercase letters.\n * Use x to sample the RNG\n */\nint randLetter(float x)\n{\n    int letter = int(rand(x) * 25.);\n    return letter + 65;\n}\n\nint randLetter(vec2 x)\n{\n    int letter = int(rand2(x) * 25.);\n    return letter + 65;\n}\n\nint randHackerSymbol(vec2 x)\n{\n    int letter = int(rand2(x) * 210.);\n    return letter + 35;\n}\n\n/* Takes an ASCII character identifier, and a uv in the range (0, 1).\n * Returns 1.0 if uv is inside the character centered at (0.5, 0.5), 0.0 otherwise.\n */\nfloat character(int index, highp vec2 uv)\n{\n    // Prevents drawing characters other than the one selected\n    uv = clamp(uv, 0., 1.);\n    // Translate index to an x, y coordinate on the texture from 0 to 15\n    vec2 charPos = vec2(mod(float(index), 16.), 15 - index / 16);\n    // Scale and translate to select only the desired character\n    vec2 uvTex = uv / 16. + charPos / 16.;\n    vec4 texSample = texture(iChannel0, uvTex);\n    // Eliminate magic line; ensure output is between 0 and 1\n    return clamp(texSample.x * 1.1 - 0.1, 0., 1.);\n}\n\nfloat textFall(vec2 uv, float size, float speed)\n{\n    // Use a seperate uv coordinate to do spacial transformations\n    highp vec2 uvChar = uv;\n    // Scale and scroll\n    uvChar *= size;\n    //float scrollSpeed = 10. + 5. * cos(floor(uvChar.x) + sin(iTime));\n    float scroll = speed * iTime + sin(iTime + 5. * rand(floor(uvChar.x)));\n    uvChar.y += scroll;\n    // Divide into horizontal stripes of space and store the coordinates of each stripe in cell\n    vec2 cell = floor(uvChar);\n    uvChar.xy = fract(uvChar.xy);\n    // Sample the color using a random letter per stripe and the transformed uv\n    float char = character(randHackerSymbol(cell.xy), uvChar);\n    // Create a sawtooth wave to fade text that is offset by scroll and a random value per column\n    float fade = fract((uv.y * size + scroll + floor(37. * rand(cell.x))) / 20.) * 2.;\n    char = mix(char, 0., fade);\n\treturn clamp(char, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Place uv = (0, 0) at the center of the screen\n    uv -= 0.5;\n    // scale by aspect ratio on the x axis\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float char = textFall(uv, 15., 3.);\n    char = max(char, textFall(uv, 27., 6.) * .5);\n    char = max(char, textFall(uv, 35., 12.) * .25);\n    char = max(char, textFall(uv, 55., 24.) * .125);\n    \n    vec3 col = vec3(0., char, 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}