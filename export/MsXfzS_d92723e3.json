{"ver":"0.1","info":{"id":"MsXfzS","date":"1496685667","viewed":107,"name":"Pillar test","username":"macke","description":"pillar","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pillar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415\n#define tm iTime\n\n\nstruct Object {\n    float d; // Distance\n    vec3 color;\n};\n    \n    \nObject omin(Object o1, Object o2) {\n    if(o1.d <= o2.d) {\n        return o1;\n    }\n    return o2;\n}\n\nObject omax(Object o1, Object o2) {\n    if(o1.d >= o2.d) {\n        return o1;\n    }\n    return o2;\n}\n    \nmat3 rotz(float t){\n     return mat3( cos(t),  -sin(t), 0,\n       \t          sin(t),   cos(t), 0,\n\t\t  \t\t  0,        0 ,     1);\n}\n\nmat3 roty(float t){\n    return  mat3( cos(t),  0,  sin(t),\n     \t    \t  0,       1,  0,\n           \t      -sin(t), 0,  cos(t)); \n\n}\n\nmat3 rotx(float t){\n     return mat3( 1, 0 ,      0,\n            \t  0, cos(t), -sin(t),\n\t   \t  \t      0, sin(t),  cos(t));\n}\n\nfloat modcenter(float t, float m) {\n    t += m/2.;\n    return mod(t, m) - m/2.;\n}\n\nfloat modax(float t, float m) {\n    return mod(t, m) - m/2.;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat udBox(vec3 p, vec3 s) {\n   \treturn length(max(abs(p)-s,0.));\n    \n}\n\nfloat random(float hash) {\n \treturn fract(sin(hash*361.)*45345.34645645) * 2. - 1.;   \n}\n\nObject map(vec3 p) {\n    \n    vec3 q = p;\n    q.x = abs(q.x) - 8.;\n    q.z = modcenter(q.z, 20.);\n    q.y = modcenter(q.y, 2.);\n    \n    // Random block\n    q.x += random(floor(p.y/2.))* 0.5;\n    q.z += random(floor(p.y/2.) + 1.)* 0.5;\n    \n    // Random color\n    vec3 col = vec3(((random(floor(p.y/2.)) + 1.) * 0.5 + .8)/8.);\n    \n    Object boxes = Object(udBox(q,vec3(2.,1.,2.)), col);  \n    Object plane = Object(p.y + 5.4, vec3(.3));\n    \n    vec3 pp = p + vec3(0.,5.6,-40.-tm*5.);\n    pp.z = modcenter(pp.z, 2.);\n    pp.x = abs(pp.x) - 2.;\n    pp.x = abs(pp.x) - 2.;\n    pp.x = abs(pp.x) - 2.;\n    pp.x = abs(pp.x) - 2.;\n    pp.y -= random(floor(p.x/2.))* 0.2;\n    pp.y -= random(floor(p.z/2.))* 0.2;\n    \n    Object path = Object(udBox(pp , vec3(2.,2.,2.)), vec3(0.4));\n    \n    return omin(path, omin(boxes,plane));\n}\n\nvec3 normalapprox(vec3 p, float e) {\n    vec2 h = vec2(e, 0.);\n    return normalize(vec3(map(p + h.xyy).d - map(p - h.xyy).d,\n                          map(p + h.yxy).d - map(p - h.yxy).d,\n                          map(p + h.yyx).d - map(p - h.yyx).d));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float fasttime = tm * 5.;\n    vec3 o = vec3(0.,5.+sin(fasttime)/5., fasttime);\n    vec3 r = normalize(vec3(uv,2.));\n    \n    //Mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n  \t//r *= rotx(pi/6.);\n   \t//r *= roty(pi/6.);\n    \n    //Distance, p = position of object\n   \tObject obj = Object(0., vec3(0.,0.,0.));\n    vec3 p;\n    for (int i = 0; i < 64; i++) {\n        p = o + r * obj.d;\n     \tObject m = map(p);\n        //if (m.d < 0.01) break;\n        obj.d += m.d * 0.9;\n      \tobj.color = m.color;\n    }\n    \n   \t//Light\n    //vec3 normal = normalapprox(p,0.0001);\n    vec3 normal = normalize(-p);\n    vec3 light = normalize(vec3(0.,1., -1.));\n    float a = acos(dot(normal, light));\n    \n    float fog = 1.0 / (0.0005 * obj.d * obj.d + .5 + a);\n    \n\tfragColor = vec4(vec3(fog) * obj.color,1.0);\n}","name":"Image","description":"","type":"image"}]}