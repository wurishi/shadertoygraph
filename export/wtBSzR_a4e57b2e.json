{"ver":"0.1","info":{"id":"wtBSzR","date":"1564751096","viewed":187,"name":"Intersect 2D ray & screen +Mouse","username":"104","description":"Use mouse to create rays.\nJust a quick utility function which extends a ray from center to the edge of the screen. Could easily be adapted for arbitrary center point.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["utility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// takes ray with origin {viewport center} and direction rd,\n// extends it to the edge of the viewport and returns the point of intersection.\nvec2 intersectRayFromCenterAndViewportBoundary(vec2 rd) {\n    vec2 ro = iResolution.xy*.5;\n    rd -= ro;\n    // avoid div by 0 by clamping to epsilon. sign(0) is 0 so shift within epsilon is needed.\n    const float epsilon = .001;\n    rd = sign(rd-epsilon*.5)*max(abs(rd),epsilon);\n    vec2 i = ro + sign(rd.x)*vec2(ro.x, ro.x*rd.y/rd.x);\n    if (i.y < 0. || i.y >= iResolution.y) { // probably some fancy way to avoid this branch i didn't consider\n        i = ro + sign(rd.y)*vec2(rd.x*ro.y/rd.y, ro.y);\n    }\n    return i;\n}\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    vec2 R = iResolution.xy;\n    if (iMouse.z > 0.){\n        vec2 i = intersectRayFromCenterAndViewportBoundary(iMouse.xy);\n      \tfragColor = vec4(1.-step(1., sdLine(fragCoord, R*.5, i)-.5));\n      \tfragColor += 1.-step(1., length(fragCoord-i)-15.);\n    }\n    fragColor += 1.-step(1., length(fragCoord-R*.5)-5.);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}