{"ver":"0.1","info":{"id":"sltfDN","date":"1663134576","viewed":130,"name":"normal and reflact","username":"wingto","description":"combine","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * |===============================================|\n * |         GT         |   DERIVATIVES ADDITION   |\n * |===============================================|\n * |  NORMALS ADDITION  |   DERIVATIVES BLENDING   |\n * |===============================================|\n */\n\n// normalmap texture\nvec3 textureNormal(vec2 uv) {\n    uv = fract(uv) * 3.0 - 1.5;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    ret = ret * 0.5 + 0.5;    \n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.98,dot(uv,uv)));\n}\n\n// normals combine: normals addition\nvec3 combineNormals0(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    return normalize(n0 + n1) * 0.5 + 0.5;\n}\n\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color;\n    vec2 time = vec2(sin(iTime * 0.1), cos(iTime * 0.1));\n    vec3 n0 = textureNormal(uv + time);\n    vec3 n1 = textureNormal((uv - time) * 2.0 + vec2(0.25));\n    \nvec3 lens_normal = combineNormals0(n0,n1);\n\n//-----------------------------------------------------------------------------\n\n    vec2 vUV = fragCoord/iResolution.xy;\n    // the incoming light direction\n    vec3 incident = normalize(vec3(0.0, 0.0, -1.0));\n\n    // ior ratios of (medium A)/(medium B). \n    // medium A is outside the lens, medium B is inside the lens\n    // - Use an ior of 1.0, corresponding to air, for medium A\n    // - Use a slightly higher ior for medium B. Tune to taste!\n    // See \n    // - https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\n    // - https://pixelandpoly.com/ior.html\n    float eta_r = 1.0 / 1.15;\n    float eta_y = 1.0 / 1.17;\n    float eta_g = 1.0 / 1.19;\n    float eta_c = 1.0 / 1.21;\n    float eta_b = 1.0 / 1.23;\n    float eta_v = 1.0 / 1.25;\n  \n  \n  \n    // Calculate different refraction vectors for each color channel\n  vec2 refract_r = refract(incident, lens_normal, eta_r).xy;\n  vec2 refract_y = refract(incident, lens_normal, eta_y).xy;\n  vec2 refract_g = refract(incident, lens_normal, eta_g).xy;\n  vec2 refract_c = refract(incident, lens_normal, eta_c).xy;\n  vec2 refract_b = refract(incident, lens_normal, eta_b).xy;\n  vec2 refract_v = refract(incident, lens_normal, eta_v).xy;\n\n  vec3 tex = texture(iChannel0, vUV).rgb;\n  vec3 tex_r = texture(iChannel0, refract_r + vUV).rgb;\n  vec3 tex_y = texture(iChannel0, refract_y + vUV).rgb;\n  vec3 tex_g = texture(iChannel0, refract_g + vUV).rgb;\n  vec3 tex_c = texture(iChannel0, refract_c + vUV).rgb;\n  vec3 tex_b = texture(iChannel0, refract_b + vUV).rgb;\n  vec3 tex_v = texture(iChannel0, refract_v + vUV).rgb;\n  \n//---------------------------------------------------------------------\n\n  float r = tex_r.r * 0.5;\n  float g = tex_g.g * 0.5;\n  float b = tex_b.b * 0.5;\n  float y = dot(vec3(2.0, 2.0, -1.0), tex_y)/6.0;\n  float c = dot(vec3(-1.0, 2.0, 2.0), tex_c)/6.0;\n  float v = dot(vec3(2.0, -1.0, 2.0), tex_v)/6.0;\n\n  float R = r + (2.0 * v + 2.0 * y - c)/3.0;\n  float G = g + (2.0 * y + 2.0 * c - v)/3.0;\n  float B = b + (2.0 * c + 2.0 * v - y)/3.0;\n\n\n\n\n//---------------------------------------------------------------------\n\n\n   // vec3 color = mix(tex, vec3(R, G, B), step(lens_dist, lens_radius));\n     color = vec3(R, G, B);\n     \n  float ring = smoothstep(\n      0.0,3.0 / iResolution.y,\n     0.5);\n  color *= ring;\n\n\n\n    fragColor = vec4(color,1.0);\n\n\n\t\n}","name":"Image","description":"","type":"image"}]}