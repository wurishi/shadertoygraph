{"ver":"0.1","info":{"id":"WtcXzr","date":"1580270770","viewed":380,"name":"2D Light Stuff","username":"bad_dreams_","description":"Click to drag a light around.\n\nFelt somewhat inspired by what Loren Schmidt's been posting to Twitter lately so here's a quick stab at the same idea.\nCouldn't get it to run at any kind of reasonable speed on my phone which is a bummer. ü§∑‚Äç‚ôÄÔ∏è","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2.5.2023:\n// Added temporal accumulation with neighborhood clamping.\n// Added colored lighting.\n\n// 8.17.2021:\n// Added jittering for each ray direction instead\n// of just the initial one. Helps to clear up\n// streaky sampling pattern in lower sample counts.\n\n// 1.29.2020:\n// Upped the mouse light's intensity somewhat.\n// Moves Box data to BufferA.\n\nfloat noise21(vec2 point) {\n  return fract(sin(point.x * 97.0 + point.y * 3230.0) * 8492.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n  vec3 tonemapped = pow(color, vec3(1.0 / 2.2));\n  \n  fragColor = vec4(tonemapped, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 readValue(ivec2 id) {\n  return texelFetch(iChannel0, id, 0);\n}\n\nvec4 writeBox(vec4 currentValue, ivec2 coord, int index, Box box) {\n  if (coord.x != index) { return currentValue; }\n  if (coord.y == 0) { return vec4(box.origin, box.size); }\n  if (coord.y == 1) { return vec4(box.energy, 0.0); }\n  return currentValue;\n}\n\n#define write(i, b) writeBox(value, coord, i, b);\n\nconst vec3 dark = vec3(0.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  ivec2 coord = ivec2(fragCoord);\n  vec4 value = readValue(coord); // Pull up our current value.\n\n  // Encode our boxes into the buffer on the first frame.\n  if (iFrame == 0) {\n    value = write(0, Box(vec2(0.25, 0.25), vec2(0.1), vec3(1.0))); // Light.\n    value = write(1, Box(vec2(-0.54, 0.0), vec2(0.1, 0.35), dark));\n    value = write(2, Box(vec2(0.5, 0.25), vec2(0.1, 0.1), dark));\n    value = write(3, Box(vec2(0.5, -0.25), vec2(0.1, 0.1), dark));\n    value = write(4, Box(vec2(0.9, -0.25), vec2(0.05, 0.41), vec3(1.5, 1.388235294117647, 1.0647058823529412))); // Light.\n    value = write(5, Box(vec2(-0.9, -0.01), vec2(0.05, 0.41), vec3(1.0))); // Light.\n    value = write(6, Box(vec2(-0.75, -0.15), vec2(0.05, 0.05), dark));\n    value = write(7, Box(vec2(-0.75, 0.15), vec2(0.05, 0.05), dark));\n    value = write(8, Box(vec2(-1.0), vec2(0.02), vec3(1.5, 1.5, 2.5))); // Mouse Light.\n    value = write(9, Box(vec2(-0.25, 0.45), vec2(0.01, 0.05), dark));\n    value = write(10, Box(vec2(-0.30, 0.45), vec2(0.01, 0.05), dark));\n    value = write(11, Box(vec2(-0.35, 0.45), vec2(0.01, 0.05), dark));\n    value = write(12, Box(vec2(0.0), vec2(0.05, 0.05), dark));\n  }\n    \n  // Ad-hoc moving stuff.\n  // For part A value.xy is box origin.\n  // For part A value.zw is box size.\n  // For part B value.xyz is box energy.\n  if (coord.x == 0 && coord.y == 0) {\n    value.xy = vec2(cos(iTime) * 0.25, sin(iTime) * 0.25); // Spin.\n  }\n\n  if (coord.x == 0 && coord.y == 1) {\n    value.xyz = vec3(clamp(cos(1.25 * iTime + 0.3), 0.0, 1.0) * 0.5 + 0.25); // Glow.\n  }\n\n  if (coord.x == 4 && coord.y == 0) { value.y = cos(iTime / 4.0); } // Slide.\n  if (coord.x == 5 && coord.y == 1) { value.xyz = vec3(clamp(cos(iTime), 0.0, 1.0)); } // Glow.\n    \n  // Follow mouse.\n  vec2 mousePosition = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n  if (coord.x == 8 && coord.y == 0) { value.xy = mousePosition; }  \n    \n  fragColor = value;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Box { vec2 origin; vec2 size; vec3 energy; };","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nconst bool useJitter = true;\nconst float sampleCount = 16.0;\n\nstruct Line { vec2 a; vec2 b; };\nstruct Ray { vec2 origin; vec2 direction; };\nstruct HitResult { bool hit; float time; Box box; };\nstruct LineResult { bool hit; float time; vec2 point; };\n\nBox loadBox(int index) {\n  // Boxes are just slightly too wide for one texel,\n  // origin, size are stored in one vec4,\n  // followed by the first component of the next texel for energy.\n  vec4 a = texelFetch(iChannel0, ivec2(index, 0), 0);\n  vec3 b = texelFetch(iChannel0, ivec2(index, 1), 0).xyz;\n    \n  return Box(a.xy, a.zw, b);\n}\n\nfloat noise21(vec2 uv) {\n  return fract(sin(uv.x * 12781.1372 + uv.y * 19735.1855) * 3531.877);\n}\n\nvec2 rotateRight(vec2 v) { return vec2(v.y, -v.x); }\n\nLineResult intersectLine(Ray ray, Line line) {\n  vec2 ba = line.b - line.a;\n  vec2 planeNormal = rotateRight(normalize(ba));\n  \n  float denom = dot(ray.direction, planeNormal);\n  if (denom < 1e-6 && denom > -1e-6) {\n    // No intersections.\n    return LineResult(false, 1e4, vec2(0.0));\n  }\n  \n  vec2 leg = line.a - ray.origin;\n  float t = dot(leg, planeNormal) / denom;\n  \n  // t for our ray's time, u for the line's time.\n  vec2 point = ray.origin + (ray.direction * t);\n  float lineLength = length(ba);\n  float u = dot(ba, point - line.a) / lineLength;\n  float maxU = lineLength;\n  bool hit = t >= 0.0 && u >= 0.0 && u < maxU;\n    \n  return LineResult(hit, t, point);\n}\n\nHitResult intersectBox(Ray ray, Box box) {\n  vec2 quadrant = vec2(1.0, 1.0);\n  vec2 topRight = box.origin + (box.size * vec2(1, 1));\n  vec2 bottomRight = box.origin + (box.size * vec2(1, -1));\n  vec2 bottomLeft = box.origin + (box.size * vec2(-1, -1));\n  vec2 topLeft = box.origin + (box.size * vec2(-1, 1));\n  \n  Line top = Line(topLeft, topRight);\n  Line left = Line(bottomLeft, topLeft);\n  Line bottom = Line(bottomRight, bottomLeft);\n  Line right = Line(topRight, bottomRight);\n  \n  Line[] lines = Line[](top, left, bottom, right);\n  \n  HitResult winner = HitResult(false, 1e4, box);\n  for (int index = 0; index < 4; index += 1) {\n    LineResult result = intersectLine(ray, lines[index]);\n    if (result.hit && result.time <= winner.time && result.time > 0.0) {\n      winner = HitResult(true, result.time, box);\n    }\n  }\n\n  return winner;\n}\n\nHitResult intersectScene(Ray ray) {\n  HitResult winner = HitResult(false, 1e4, Box(vec2(0.0), vec2(0.0), vec3(0.0)));\n  \n  for (int index = 0; index < 12; index += 1) {\n    HitResult result = intersectBox(ray, loadBox(index));\n    if (result.time < winner.time) { winner = result; }\n  }\n\n  return winner;\n}\n\n#define TAU 6.28318530718\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n \n  float noise = noise21(uv * (iTime + 1.0));\n  \n  // Blue noise incantation from demofox.\n  int frame = iFrame % 64;\n  const float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n  float blueNoise = texture(iChannel1, fragCoord / 1024.0f).r;\n  blueNoise = fract(blueNoise + c_goldenRatioConjugate * float(frame));\n  \n  vec3 acc = vec3(0.0);\n  const float maxSteps = sampleCount;\n  float stepSize = TAU / maxSteps;\n  float initialAngle = (blueNoise * stepSize); // blueNoise * TAU; // noise * TAU;\n  // fract(iTime * 0.5) * stepSize; //\n  \n  for (float index = 0.0; index < maxSteps; index += 1.0) {    \n    float angle = initialAngle + (index * stepSize);\n    vec2 direction = vec2(cos(angle), sin(angle));\n    Ray ray = Ray(uv, direction);\n    \n    HitResult result = intersectScene(ray);\n    \n    if (result.hit) {\n      vec3 adjustedEnergy = (0.02 * result.box.energy) / (result.time / 2.0);\n      acc += adjustedEnergy;\n    }\n  }\n  \n  vec3 color = acc / maxSteps;\n  fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// iChannel0 (buffer B) -> latest sample\n// iChannel1 (buffer C) -> previous sample \n\nstruct AABB {\n    vec3 maximum;\n    vec3 minimum;\n};\n\n// Sample min/max colors in a 3x3 neighborhood around coord.\nAABB sampleLocalColor(ivec2 coord) {\n  // Grow our aabb to include our neighborhood samples.\n  vec3 center = texelFetch(iChannel0, coord + ivec2(0, 0), 0).xyz;\n  vec3 colorMin = center;\n  vec3 colorMax = center;\n\n  vec3 up = texelFetch(iChannel0, coord + ivec2(0, 1), 0).xyz;\n  colorMin = min(colorMin, up);\n  colorMax = max(colorMax, up);\n  vec3 right = texelFetch(iChannel0, coord + ivec2(1, 0), 0).xyz;\n  colorMin = min(colorMin, right);\n  colorMax = max(colorMax, right);\n  vec3 down = texelFetch(iChannel0, coord + ivec2(0, -1), 0).xyz;\n  colorMin = min(colorMin, down);\n  colorMax = max(colorMax, down);\n  vec3 left = texelFetch(iChannel0, coord + ivec2(-1, 0), 0).xyz;\n  colorMin = min(colorMin, left);\n  colorMax = max(colorMax, left);\n    \n  return AABB(colorMax, colorMin);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 latest = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n  vec3 previous = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n  \n  AABB range = sampleLocalColor(ivec2(fragCoord));\n  vec3 adjustedPrevious = clamp(previous, range.minimum, range.maximum);\n\n  float weight = 0.1;\n  vec3 blended = mix(adjustedPrevious, latest, weight).xyz;\n  \n  fragColor = vec4(blended, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}