{"ver":"0.1","info":{"id":"dd23Dh","date":"1667926514","viewed":170,"name":"sunrise& sunset","username":"qr","description":"this is a learning process for shadertoy","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sunrisesunset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is an impletation of the exercise in The Book of Shaders\n// https://thebookofshaders.com/06/\n#define PI 3.1415926538\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\nvec3 black = vec3(0.);\nvec3 white = vec3(1.);\n\nfloat random (float x) {\n    return fract(sin(x)*100.0);\n}\n\nfloat timeElapse(float x) \n{\n  return min(abs(cos(x / 3.)*2.), 1.);\n}\n\n\n// implict function implemented shapes\nfloat sdfCircle(vec2 st, float r, vec2 offset)\n{\n   vec2 xy = st - offset;\n   return length(xy) - r;\n}\n\nfloat sdfCircle2(vec2 st,vec2 center,float size,float blur){\n\tst = st - center;\n\tst /= size;\n\tfloat len = length(st);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\n//Uneven Capsule - exact   (https://www.shadertoy.com/view/4lcBWn)\nfloat sdUnevenCapsule( vec2 st, float r1, float r2, float h, vec2 offset)\n{\n   vec2 p = st - offset;\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n//\nvec3 drawSky(vec2 st)\n{\n    vec3 gradientStartColor = mix(black, colorA, timeElapse(iTime/2.));\n    vec3 gradientEndColor = mix(black, colorB, timeElapse(iTime/2.));\n    return mix(gradientStartColor, gradientEndColor, st.y);\n}\n\nvec3 drawSun(vec2 st, vec3 color)\n{\n  vec3 suncolor = mix(black, mix(vec3(1., 0., 0.), colorB * 1.1, timeElapse(iTime/2.)), timeElapse(iTime/2.));\n  float circle = sdfCircle(st, 0.1, vec2(.0, timeElapse(iTime/2.) - .7));\n  return mix(suncolor, color, step(0., circle));\n}\n\n// some ugly functions need to be polish\nvec3 drawWave(vec2 st, vec3 color)\n{\n  // 振幅（控制波浪顶端和底端的高度）\n  float amplitude = 0.01;\n  // 角速度（控制波浪的周期）\n  float angularVelocity = timeElapse(iTime/2.) * 5.;\n  // 频率（控制波浪移动的速度）\n  float frequency = 3.0;\n  // 偏距（设为 0.5 使得波浪垂直居中于屏幕）\n  float offset = 0.2;\n  // 初相位（正值表现为向左移动，负值则表现为向右移动）\n  // iTime 是 Shadertoy 提供的运行时间全局变量（类型：float）\n  float initialPhase = frequency * (iTime);\n  // 代入正弦曲线公式计算 y 值\n  // y = Asin(ωx ± φt) + k\n  float y = amplitude * sin((angularVelocity * st.x)+ initialPhase) + offset;\n  y += amplitude /1.28 * sin((angularVelocity * st.x / 1.22) + initialPhase*1.121);\n  y += amplitude /1.68 * sin((angularVelocity * st.x / 2.22)+ initialPhase*0.437);\n  // 区分 y 值上下部分，设置不同颜色\n  vec3 seacolor = mix(black, colorA, timeElapse(iTime/2.));\n  \n  color = mix(seacolor, color, step(0., st.y - y));\n  //绘制反射\n  float ref_width = 0.3 - 0.05 * y;\n  vec3 suncolor = mix(black, mix(vec3(1., 0., 0.), colorB, timeElapse(iTime/2.)), timeElapse(iTime/2.));\n  vec3 reflectcolor = suncolor * 0.5;\n  \n  float ref = sdUnevenCapsule( vec2(st.x - 0.08 + cos(random(st.y*iTime/3.))* 0.1, st.y), \n    0.03 * (1.1-timeElapse(iTime/2.)) , 0.07 * (1.5-timeElapse(iTime/2.)), 0.25, vec2(.5, 0.));\n  return mix(reflectcolor, color, step(0., max(ref, st.y - y)) );\n}\n\nfloat drawCloud(vec2 st,vec2 center,float size)\n{\n\tst = st - center;\n\tst /= size;\n\tfloat col = sdfCircle2(st,vec2(0.,0.),0.2,0.05);\n\tcol =col *  smoothstep(-0.1,-0.1+0.01,st.y);\n\tcol += sdfCircle2(st,vec2(0.15,-0.05),0.1,0.05);\n\tcol += sdfCircle2(st,vec2(0.,-0.1),0.11,0.05);\n\tcol += sdfCircle2(st,vec2(-0.15,-0.1),0.1,0.05);\n\tcol += sdfCircle2(st,vec2(-0.3,-0.08),0.1,0.15);\n\tcol += sdfCircle2(st,vec2(timeElapse(iTime/2.)*-0.2,0.),0.15,0.05);\n\treturn col;\n}\nfloat drawClouds(vec2 uv)\n{\n\tuv.x += 0.03 * iTime;\n\tuv.x = fract(uv.x+0.5) - 0.5;\n\tfloat col = drawCloud( uv,vec2(-0.4,0.3),0.25);\n\tcol += drawCloud( uv,vec2(0.0,0.4),0.15);\n\tcol += drawCloud( uv,vec2(0.45,0.45),0.2);\n\treturn col;\n}\n\nvec3 darwScene(vec2 st)\n{\n  vec3 color = drawSky(st + 0.5);\n  color = drawSun(st, color);\n  color = drawWave(st + 0.5, color);\n  color += mix(black, vec3(drawClouds(st + 0.17) * 0.5), timeElapse(iTime/2.));\n\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st -= 0.5;\n    st.x *= iResolution.x / iResolution.y; \n\n    vec3 color = darwScene(st);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}