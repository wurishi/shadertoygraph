{"ver":"0.1","info":{"id":"XctSRj","date":"1714232659","viewed":33,"name":"theguy888's raymarch 1","username":"TheGuy888","description":"me when im in a \"being a very basic raymarcher\" contest and my opponent is this project:\n /(0 0)\\\n|  \\*/  |\n\n  thanks michael walczyk","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getDist(vec4 s,vec3 p){return length(s.xyz-p)-s.w;}\n\nvec4 nearestPoint(vec3 p){\n    // x,y,z,radius\n    vec4 spheres[]=vec4[](vec4(0.,-.5,3.,1.),vec4(0.,1.,3,.75));\n    \n    vec4 nearSphere=spheres[0];\n    for (int i=1;i<spheres.length();i++){\n        if (getDist(spheres[i],p)<getDist(nearSphere,p)){\n            nearSphere=spheres[i];}}\n\n    // returns xyz to center of nearest sphere and distance to edge\n    return vec4(nearSphere.xyz-p,getDist(nearSphere,p));}\n    \nvec3 march(vec3 o,vec3 dir){\n    float minDist=0.001;\n    float maxDist=1000.;\n    int maxIts=50;\n    vec3 pos=o;\n    vec3 col=vec3(0.);\n    \n    for (int i=0;i<maxIts;i++){\n        vec4 nearP=nearestPoint(pos);\n        if (nearP.w<minDist){return (nearP.xyz/length(nearP.xyz));}\n        if (length(pos-o)>maxDist){return col;}\n        pos+=nearP.w*dir;\n    }\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 pix)\n{\n    //uv.x goes from -1 to 1\n    //uv.y's range depends on the ratio of your screen (-0.5625 to 0.5625 in my case)\n    vec2 uv = fov*(pix-(iResolution.xy/2.))/iResolution.x;\n    vec3 dir=angleToVec(uv);\n    fragColor = vec4(march(cameraPos,dir),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define cameraPos vec3(2.5*sin(iTime),.5*cos(iTime)+.5,0.)\n// ^^^ camera moves around in an ellipse\n\n//#define cameraPos vec3((5.*iMouse.xy/iResolution.xy)-2.5,-1.)\n// ^^^ move camera by dragging mouse\n\n//#define cameraPos vec3(0.)\n// ^^^ camera stays at 0,0,0\n\n#define camDir vec2(0.,0.)\n// ^^^ camDir is = vec2(left/right angle, up/down angle). Angles are in degrees.\n\n#define fov 180.\n\nvec3 angleToVec(vec2 angleChange)\n{\nvec2 angleR=radians(camDir+angleChange);\nreturn vec3(sin(angleR.x)*cos(angleR.y),sin(angleR.y),cos(angleR.x)*cos(angleR.y));\n}","name":"Common","description":"","type":"common"}]}