{"ver":"0.1","info":{"id":"tsXyDs","date":"1585837342","viewed":236,"name":"Soundsystem Acid Trip","username":"julianlumia","description":"some messy code of a WIP sketch i'm working on ","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["light","disco","soundsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.01).x;\n    fragColor.y = T(uv -f*0.01).y;\n    fragColor.z = T(uv-f*0.01).z;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\nfloat GetDist(vec3 p) {\n float the = sin(p.y*.1+iTime*.5)*.5+0.;\n p.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n      the = sin(p.x*.5+iTime*1.)*.15+0.;\n\n     p.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n      the = (sin((p.x*.05)+iTime*.2)*.2+0.);\n\n     p.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n\n vec3 p7 = p;\n float gap = 4.2;\n p.x = abs(p.x)-2.3;\n p.x = abs(p.x)-2.3;\n p.x = abs(p.x)-2.3;\n vec3 p6 = p;\n float d;\n gap = 3.;\n p.x = abs(p.x)-1.1;\n float plane2 = dot(p-vec3(1,1,1),normalize(vec3(0.,0.,0.2)))-0.;\n p -= vec3(-3.,-0,-0.); \n vec3 p4 = p;  \n the = 2.7;\n p4 -= vec3(3,1.73,-1.4);\n p4.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float box7 = sdBox(p4-vec3(0,1,0), vec3(1,0.02,.6));\n vec3 p5 = p;  \n the = 2.6;\n p5 -= vec3(3.,0.73,-.9);\n p5.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n p5.x = abs(p5.x)-.5;\n float box8 = sdBox(p5-vec3(0,1,0), vec3(0.05,1.3,.5));\n vec3 p3 = p;  \n the = 2.5;\n p3 -= vec3(3,1.,-.5);\n p3.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float box6 = sdBox(p3-vec3(0,1,0), vec3(1,0.05,.4));\n\n    vec3 p2 = p;  \n     the = 2.2;\n\tp2 -= vec3(3,2.6,-0.6);\n    p2.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    float box5 = sdBox(p2-vec3(0,1,0), vec3(1,0.05,1.2));\n float x = sdCapsule(p2,vec3(0,2.,0.),vec3(0,1.2,-.2),.8);\n    \n   \n    \n    vec3 conusp = p2;\n         conusp += vec3(0.,-0.3,0.);\n    \n     float y = sdCapsule(conusp,vec3(0,2.,0.),vec3(0,1.,-0.2),.8);\n     conusp += vec3(0.,abs(sin(iTime))-0.,0.);\n float z = sdCapsule(conusp,vec3(0,4.,0.),vec3(0,1.,-0.2),.7);\n\n    \n    \n    \n    float box2 = sdBox(p-vec3(3,1,0), vec3(1,2,2));\n      x = max(min(z,-(max(x,(y)))),(box5));\n\n\tbox2 = abs(box2)-0.05;\n    float op2 =  max(plane2, min(box8,box2));\n    \n\n    \n    \n    \n    \n    \n    d = min(op2,min(x,(min(box7,box6))));\n    \n    \n    \n    \n    \n    \n    \n    p = p6;\n    p += vec3(2,0,0);\n      float boxkick = sdBox(p-vec3(2,4.,0), vec3(1.8,0.8,1.1));\n          float frontkick = sdBox(p-vec3(2,4.,.9), vec3(1.8,0.8,.03));\n          float bafflekick = sdBox(p-vec3(2,4.,0.8), vec3(0.2,0.8,.5));\n          float bafflemiddle = sdBox(p-vec3(2,4.,0.45), vec3(0.2,0.02,1.5));\n\n       the = 2.5;\n    p.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n     p += vec3(-2,4.9,1.9);\n      p.x =abs(p.x)-1.;\n        conusp = p;\n         conusp += vec3(0.,-1.,1.);\n    \n      y = sdCapsule(conusp,vec3(0,1.,-0.),vec3(0,0,0.5),.7);\n \n          x = y;\n      conusp += vec3(0.0,cos(abs(p7.x*.2)+iTime*2.),.6);\n      y = sdCapsule(conusp,vec3(0,.35,-0.),vec3(0,1,.0),.8);\n    \n    \tboxkick = abs(boxkick)-0.05;\n    \tboxkick = max(plane2,min(max(-bafflekick,max(frontkick,-max(x,-y))),min(bafflemiddle,boxkick)));\n        d = min(d,boxkick);\n    \n      p = p6;\n      float midbox = sdBox(p-vec3(0,6.,0), vec3(.9,1.,1.1));\n    \n          float between = sdBox(p-vec3(0,6.,-0.4), vec3(.3,1.,.02));\n\n    \n    vec3 bendp = p; \n    bendp.x = abs(bendp.x)-0.2;\n    bendp += vec3(-.3,-6.,-0.4);\n    the = sin(bendp.x*.7+0.4);\n    bendp.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n          float bafle1 = sdBox(bendp, vec3(.01,1.,.7));\n\n        \tmidbox = abs(midbox)-0.03;\n     p += vec3(-0,-6.,.5);\n          p.y =abs(p.y)+2.8;\n\n       the = 2.5;\n    p.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n     \n\n   p += vec3(-0,4.,1.9);\n        conusp = p;\n     \n         conusp += vec3(0.,-1.,1.);\n \n      y = sdCapsule(conusp,vec3(0,1.,0.),vec3(0,0,1.5),.35);\n x = y;\n  \n    \n\n            d = max(plane2,min(d,min(bafle1,min(midbox,max(between,-x)))));\n\n\n    p = p6;\n vec3 bendp2 = p;\n      bendp2.x = abs(bendp2.x)+.02;\n\n    \tbendp2 -= vec3(.3,7.5,.6);\n\n    the = sin(bendp2.x*1.3+0.4);\n    bendp2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n          float bafle2 = sdBox(bendp2, vec3(.01,.4,.7));\n    \n    p += vec3(0,-7.1,-1);\n      float topbox = sdBox(p-vec3(0.,0.4,0.), vec3(.8,.4,2.));\n topbox = abs(topbox)-0.06;   \n p = p7;\n float sphereg = (length(p+vec3(sin(iTime)*11.,sin(iTime*1.)*3.+3.,(cos(iTime))*12.))-1.);\n float ground = sdBox(p-vec3(0,6.,0), vec3(10,7.,15));\n float sphereg3 = (length(p+vec3(0.,sin(iTime)*0.+0.,0.))-12.);\n vec3 grondp = p;       \n gap = .8;\n grondp.y = mod(grondp.y + gap,2.0 * gap) - gap;\n float ground2 = sdBox(grondp-vec3(0,-.6,0), vec3(14.,.2,14));\n p.x = abs(p.x)-3.3;\n p.x = abs(p.x)-3.3;\n p.x = abs(p.x)-3.3;\n float sphereg2 = sdBox(p+vec3(0.5,-3.5,0.), vec3(.1,.5,0.1));\n float sphereg24 = sdBox(p+vec3(2.,-0.5,0.), vec3(.1,.5,0.1));\n float sphereg4 = sdBox(p+vec3(1.,(sin(iTime)*0.5+2.)+-8.5,-0.1), vec3(.1,.5,0.1));\n     float bkgrnd = sdBox(p+vec3(1.,-3.5,-5.), vec3(.1,.5,0.1));\n\n d = min(d,max(plane2,min(topbox,bafle2)));\n d = min(sphereg2,d);\n ground =max(max(sphereg3,-ground),-ground2);\n d = min(d,ground);\ng2 +=1./(0.006+pow(abs(z),4.));\n g3 +=.05/(.2+abs(sphereg2*sphereg2));\n g4 +=1./(.005+pow(abs(sphereg4),(abs(sin(p.x*1.+iTime))*1.)));\n g3 +=.05/((sin(p7.x*0.01+iTime*1.)*0.5+0.5)*0.5+sphereg24*sphereg24);\n     g5 +=1./((sin(p7.x*0.1+iTime*2.)*0.5+0.5)*0.5+pow(abs(bkgrnd),4.));\ng2 +=1./(0.01+pow(abs(y),4.));\n\n return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS*.9;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0., 6.5, 5.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5-.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*.01, l);\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\nconst float PI = 3.14159265359;\n\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n        ao += (l - max(GetDist( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = 0.005;\n    float shadow = 1.0;\n    while(d < maxDist)\n    {\n        float t = GetDist(r0 + d * rd);\n        if(t < 0.004) return 0.0;\n        d += t;\n        shadow = min(shadow, 30.0 * (t / d));\n    }\n    return shadow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, 20.);\n\n    vec3 rd = R(uv, ro, vec3(1,1.0,-10.), 1.);\n\n    float d = RayMarch(ro, rd);\n    vec3 p;\n    if(d<MAX_DIST) {\n\n    \t p = ro + rd * d;\n   \n\n    \tfloat dif = GetLight(p);\n   col += vec3(dif);\n                              vec3 n = GetNormal(p.xyz);\n\n         float a = ambientOcclusion(p,n, 5., 7.);\ncol += a;\n \n        col +=g2*vec3(0.006)*vec3(abs(sin(iTime)),abs(sin(iTime*0.3)),.5)*.10;   \n\t\tcol +=g4*vec3(0.2)*vec3(sin(iTime)*1.,.9,0.5)*0.1;    \n\t\tcol +=g5*vec3(.1)*vec3(abs(cos(iTime)),abs(sin(iTime)),0.5)*0.5;    \n\n\n\n        \n        vec3 lp =vec3(0,10.,-10.);\n\n        const int numIter =80;\n    vec3 vD = rd;\n    vD = normalize(vD);\n    float stepSize = length(p - ro) / float(numIter);\n   vec3 vO = ro + stepSize * vD;\n    float accum = 0.0;\n    for(int i = 0; i  < numIter; ++i)\n    {\n        vec3 ld = normalize(lp - vO);\n        float shad = shadow(vO, ld,sin(iTime)*0.5+0.5+5.);\n        float d = dot(vO, vO);\n        accum += (.05 / d ) * shad;\n        vO += stepSize * vD;\n    }\n    col += g3 * vec3(.8, 0.5, .3)*.3;\n    col += accum * vec3(.8, 0.5, .3) * 10.;\n   \n    }\n                     vec3 sky = vec3(0., 0., 1.);\ncol *= mix(sky, col, 1./(d*d/10./10.*0.5+1.)); \n      \n  col*=0.4;\n  col=smoothstep(0.0,2.5,col);\n  col=pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}