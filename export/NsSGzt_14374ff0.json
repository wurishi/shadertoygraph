{"ver":"0.1","info":{"id":"NsSGzt","date":"1618666173","viewed":131,"name":"Sauron's magic ball","username":"Goleaf","description":"Project \"Sauron's magic ball\" was made as a part of the CMC MSU practical work.\n\nThere is a scene, which contains a glass ball on platform and Sauron's eye in it.\n\nby V. L., 325","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","antialiasing","shadows","ball","sauron","polygonlights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*                         Sauron's magic ball\n\nMaterials, which I used and modified for my project:\nglass ball: https://www.shadertoy.com/view/7dS3Wh\npolygon lights: https://www.shadertoy.com/view/tddcD8\nSauron's eye: https://www.shadertoy.com/view/4tj3Dw\n*/\n\n    /////////////////STRUCTS AND GLOBALS/////////////////\nstruct Quad {\n    vec3 pos[4];\n    vec3 color;\n    vec3 normal;\n};\n\nstruct Sphere {\n    vec3 pos;\n    vec3 color;\n    vec3 normal;\n    float rad;\n    int mat;\n};\n\nstruct Cylinder {\n    vec3 color;\n    vec3 normal;\n    int mat;\n};\n\nconst vec3 CAM_POS = vec3(0, 1.2, -6);\nconst float INF = 1e10;\nconst float EPS = 1e-3;\nconst float PI = 3.14159265359;\nconst int NUM_RAY = 10;\nconst int NUM_LIGHTS = 2;\n\nconst float CORONA = 0.1;\nconst float PUPIL = 0.2;\n\n#define FIRE_RADIUS 0.1\n\nvec3 randDir;\n\n    /////////////////FUNCTIONS/////////////////\nfloat rayQuadIntersection(Quad q, vec3 origin, vec3 dir) \n{\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, q.normal);\n    \n    if (abs(normalViewAngle) < EPS)\n        return INF;\n    float d = dot(q.pos[0] - origin, q.normal) / normalViewAngle;\n    if (d < 0.0)\n        return INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[4] = vec3[4](\n        q.pos[1] - q.pos[0],\n        q.pos[2] - q.pos[1],\n        q.pos[3] - q.pos[2],\n        q.pos[0] - q.pos[3]\n    );\n    float square = length(cross(edges[0], edges[1])) + length(cross(edges[2], edges[3]));\n    vec3 toHitVecs[4] = vec3[4](\n        hitPos - q.pos[0],\n        hitPos - q.pos[1],\n        hitPos - q.pos[2],\n        hitPos - q.pos[3]\n    );\n    float testSq[4] = float[4](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2])),\n        length(cross(toHitVecs[3], edges[3]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2] - testSq[3]) < EPS)\n        return d;\n    return INF;\n}\n\nfloat pow2(float x) { return x * x; }\n\nfloat traceFlat(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (-1.1 - pos.y) / dir.y;\n    \n    if (t <= 0.0)\n        return INF;\n     \n    vec3 worldPos = dir * t + pos;\n    if (abs(worldPos.x) >= 3.2 || abs(worldPos.z) >= 3.0)\n        return INF;\n    normal = vec3(0.0, 1.0, 0.0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float b = dot(pos, dir);\n    float D = pow2(b) - dot(pos, pos) + pow2(r);\n    if (D < 0.0)\n        return INF;\n    float t = -b - sqrt(D);\n    if (t > 0.0)\n    {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0)\n        return INF;\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) \n{\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) \n    {\n        return INF;\n    }\n    vec3 worldPos = dir * t + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 2.0) \n    {\n        normal = vec3(0.0, 1.0, 0.0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float D = pow2(b) - (dot(pos.xz, pos.xz) - 2.0) * a;\n    if (D < 0.0)\n        return INF;\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0)\n    {\n        worldPos = dir * t + pos;\n        if (worldPos.y <= -1.0) \n        {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0)\n        return INF;\n    worldPos = dir * t + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\n//Function, which checks intersection with objects to create shadows\nbool isOccluded(vec3 pos, vec3 target)\n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphN;\n    float sphT = traceSphere(pos, dir, 1.0, sphN);\n    if (sphT < dist)\n        return true;\n    vec3 cylN;\n    float cylT = traceCylinder(pos, dir, cylN);\n    return (cylT < dist);\n}\n\nvec3 getLightSpecular(Quad light, vec3 worldPos, vec3 viewVec, vec3 normal, float specFactor) \n{\n    vec3 r = reflect(viewVec, normal);\n    float sp = 0.0;\n    for (int i = 0; i < 4; ++i) \n    {\n        vec3 vi = normalize(light.pos[i] - worldPos);\n        vec3 vi1 = normalize(light.pos[(i + 1) % 4] - worldPos);\n        vec3 ni = -normalize(cross(vi, vi1));\n        vec3 ti = normalize(cross(vi, ni));\n        float c;\n        float delta;\n        {\n            float a = max(dot(vi, r), 1e-9);\n            float b = max(dot(ti, r), 1e-9);\n            c = sqrt(a * a + b * b);\n            delta = atan(b / a);\n        }\n        float Imin = 0.0;\n        float Imax = (pow(c, specFactor + 2.0) - 1.0) / (pow2(c) - 1.0);\n        float xw = PI / 3.0 * sqrt(1.0 - pow2(c - c / float(specFactor)));\n        float cosxw = cos(xw);\n        float fxw = c * cosxw;\n        float Ixw = (pow(fxw, specFactor + 2.0) - fxw) / (pow2(fxw) - 1.0);\n        float yw = (Ixw - Imin) / (Imax - Imin);\n        float a = (1.0 - yw - 4.0 * pow2(xw / PI)) / yw / pow2(xw);\n        float Pmax = 1.0 / (1.0 + a * pow2(0.0));\n        float Pmin = 1.0 / (1.0 + a * pow2(PI / 2.0));\n        float s = (Imax - Imin) / (Pmax - Pmin);\n        float t = Imin - s * Pmin;\n        float Phi = acos(dot(vi, vi1));\n        float sqrt_a = sqrt(a);\n        float F = s / sqrt_a * (\n            atan(sqrt_a * (Phi - delta)) - atan(-sqrt_a * delta)\n        ) + t * Phi;\n        float l = F * dot(ni, r);\n        sp += max(l, 0.0);\n        //Here we create soft shadows, using random direction varible\n        if (isOccluded(worldPos, light.pos[i] + randDir))\n            sp = 0.0;\n\t}    \n    return light.color * sp;\n}\n\nvec3 refraction(vec3 view, vec3 normal, float n1, float n2) \n{\n    if (dot(view, normal) < 0.0) \n        normal = -normal;\n    float cosA = dot(view, normal);\n    float sinA = sqrt(1.0 - pow2(cosA));\n    vec3 tang = normalize(view - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0)\n        return reflect(view, normal);\n    float cosB = sqrt(1.0 - pow2(sinB));\n    return sinB * tang + cosB * normal;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n}\n\nfloat sdF(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nvec2 map(vec3 p)\n{\n    // Pupil\n    vec3 pp = p;\n    pp.x *= 0.7;\n    pp.y *= 0.1;\n    pp -= vec3(0.0, 0.045, -2.18);\n    \n    // Coronas\n    \n    p.y -= 0.45;\n    \n    float x = 0.5 * (atan(p.y , p.x )) / PI;\n    float y = 0.5 * (atan(p.y , p.z )) / PI;\n    \n    float d = sdF(p, 2.0) * 0.25;\n    float l = length(p);\n    \n    vec3 np = vec3(x, y, -length(p) * 0.5);// + iTime * 0.03);\n    float corona = abs(noise(np * 25.0));\n    \n    float corona1 = abs(noise(np * 50.0));\n    float corona2 = abs(noise(np * 75.0));\n    float corona3 = abs(noise(np * 200.0));\n    corona += corona1 * 0.5 + corona2 * 0.35 + corona3 * 0.35;\n\tcorona *= FIRE_RADIUS;\n    \n    \n    float cor = -corona + d;\n    float ppl = sdF(pp, 0.06);\n    \n    \n    float m = min(ppl, cor);\n    \n    if ( m == cor)\n    {\n        return vec2(CORONA, m);\n    }\n    return vec2(PUPIL, m);\n\n}\n\n//Function, which creates an eye, using RayMarching\nbool trace(vec3 from, vec3 rd, inout vec4 color)\n{\n    vec3 rp = from;\n    float d = 0.0;\n    color.a = 0.0;\n    bool hit = false;\n    //rd /= 1.3;\n    \n    vec3 col = vec3(0.07, 0.020, 0.0115) * 0.2;\n    float dens = 1.5;\n    \n    for (int i = 0; i < 250; ++i)\n    {\n        \n        if(rp.z > 0.1)\n        {\n            return hit;\n        }\n        \n        vec2 mat = map(rp);\n        d = mat.y;\n        if ( d <= 0.0 && color.a <= 1.0)\n        {\n            hit = true;\n            float density = abs(d) * dens;\n            color.a += abs(density);\n            if (mat.x == CORONA)\n            {\n\t            color.rgb += col;\n            }\n            else if (mat.x == PUPIL)\n            {\n                color += vec4(0.0, 0.0, 0.0, 0.2);\n            }\n        }\n        rp += rd * max(d * 0.2, 0.0005);\n    }\n    \n    return hit;\n}\n\n    /////////////////MAIN_FUNCTION/////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n  \n    Quad lights[NUM_LIGHTS] = Quad[NUM_LIGHTS](\n    Quad(vec3[4](\n        vec3(1.75, -1.1, 2.5),\n        vec3(1.75,  0.4, 2.5),\n        vec3(2.75,  0.4, 2.5),\n        vec3(2.75, -1.1, 2.5)),\n        \n        vec3(0xf8, 0xa7, 0x3f) / 255.0 * 0.7,\n        vec3(0.0, 0.0, -1.0)),  \n        \n    Quad(vec3[4](\n        vec3(-2.25, 0.5, 5.5),\n        vec3(-2.25, 1.5, 5.5),\n        vec3(-0.75, 1.5, 5.5),\n        vec3(-0.75, 0.5, 5.5)),\n        \n        vec3(0x99, 0x99, 0x8f) / 255.0,\n        vec3(0.0, 0.0, -1.0))      \n    );\n    \n    Sphere sphere;\n    sphere.pos = CAM_POS;\n    sphere.rad = 1.0;\n    sphere.mat = REFRACTION;\n    \n    Cylinder cylinder;\n    cylinder.mat = DIFFUSE;\n    \n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    \n    //Creating Anti-aliasing\n    vec2 uv = (fragCoord - iResolution.xy / 2.0 + (randVals.xy - 0.5) * 2.0) / iResolution.x;\n    //vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    \n    vec3 front = normalize(-CAM_POS);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    float specFactor = 128.0 * 2.0 + 1.0;\n\n    vec3 color;\n    vec3 normal;\n    vec3 worldPos;\n    \n    vec3 curPos = CAM_POS;\n    vec3 curDir = viewVec;\n    bool done = true;\n  \n  \n\n    for (int i = 0; i < NUM_RAY; i++)\n    {\n        float t = INF;\n        int matType;\n        \n        vec3 floorNormal;\n        vec3 flatNorm;\n        float quadT;\n        \n        float flatT = traceFlat(curPos, curDir, flatNorm);\n        color = 0.3 * vec3(0x1b, 0x16, 0x12) / 255.0;\n        \n        //Intersection with flat\n        if(flatT < t)\n        {\n            t = flatT;\n            matType = DIFFUSE;\n            worldPos = curDir * t + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.2).rgb * 0.1;\n            floorNormal = normalize(vec3(0.0, 1.0, 0.0) + (texture (iChannel0, worldPos.xz * 0.2).rgb * 2.0 - 1.0) * 0.2);\n            normal = flatNorm;\n        }\n        for (int k = 0; k < NUM_LIGHTS; k++)\n        {\n            //Intersection with lights\n            quadT = rayQuadIntersection(lights[k], curPos, curDir);\n            if (quadT < t)\n            {\n                t = quadT;\n                color = lights[k].color;\n                matType = EMISSION;\n                normal = lights[k].normal;\n            }\n        }\n        //Intersection with sphere\n        float sphT = traceSphere(curPos, curDir, sphere.rad, sphere.normal);\n        if (sphT < t)\n        {\n            t = sphT;\n            normal = sphere.normal;\n            if (randVals.x * 0.2 < GLASS_R)\n                sphere.mat = REFLECTION;\n            else\n                sphere.mat = REFRACTION;\n            matType = sphere.mat;\n        }\n        //Intersection with cylinder platform\n        float cylT = traceCylinder(curPos, curDir, cylinder.normal);\n        if (cylT < t)\n        {\n            t = cylT;\n            matType = cylinder.mat;\n            worldPos = curDir * t + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb * 0.1;\n            floorNormal = normalize(vec3(0.0, 1.0, 0.0) + (texture (iChannel2, worldPos.xz * worldPos.y).rgb * 2.0 - 1.0) * 0.2);\n            normal = cylinder.normal;\n        }\n        //We need to figure out the material of intersection \n        if (t != INF)\n        {\n            worldPos = curDir * t + curPos;\n            if (matType == EMISSION)\n            {\n                fragColor.rgb = color;\n                break;\n            }\n            else if (matType == DIFFUSE)\n            {\n                //Adding lights to diffuse material\n                for (int k = 0; k < NUM_LIGHTS; k++)\n                    fragColor.rgb += getLightSpecular(lights[k], worldPos, curDir, floorNormal, specFactor) / 2.0 / PI;\n                fragColor.rgb += texture(iChannel1, vec3(0.0, 0.1, 0.0)).rgb * 0.3;\n                break;\n            }\n            else if (matType == REFLECTION)\n            {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * EPS;\n            }\n            else if (matType == REFRACTION)\n            {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * EPS;\n                //Creating an eye in the magic ball\n                if (done && trace(CAM_POS, curDir, fragColor))\n                {              \n                    fragColor.a = clamp(fragColor.a, 0.0, 1.0);\n                    done = false;\n                }\n                float tmp = n1;\n                n1 = n2;\n                n2 = tmp;\n            }\n        }\n        else\n        {\n            //Cube map environment\n            fragColor += texture(iChannel1, curDir) * 0.3;\n            break;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}