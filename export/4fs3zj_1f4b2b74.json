{"ver":"0.1","info":{"id":"4fs3zj","date":"1703290117","viewed":13,"name":"Hydraulics","username":"serioux666","description":"Calculate water flow over terrain, using \"Virtual Pipes\" algorithm from ShaderX 7, Article 5.2.\nWASD + Mouse: Move Camera, R: Reset Terrain/Water\n\nDepends on selected resolution! Recommend fullscreen, use (R)eset after switching.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["terrain","water","flow","hydraulic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Hydraulics\n * \n * Copyright (C) 2023  Gregor Vollmer <git@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define FSAA 0\n\nfloat fbm_rock(vec2 p)\n{\n    p *= 0.3;\n    const float L = 2.3;\n    const float G = .5;\n    float A = 1.;\n    float h;\n    const float angle = 0.3;\n    const float angle2 = 0.3;\n    //const mat3 M = L * (mat3(cos(angle), -sin(angle), 0., 0., 1., 0., sin(angle), cos(angle), 0.) * mat3(1., 0., 0., 0., cos(angle2), -sin(angle2), 0., sin(angle2), cos(angle2)));\n    const mat2 M = L * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    for(int i = 0; i < 4; ++i) {\n        h += A * lfnoise(p * 64.); A *= G; p = M * p;\n    }\n    return h * 3.141;\n}\n\nvec3 hash( vec3 p )      // this hash is not production ready, please\n{                        // replace this by something better\n    // By iq, MIT License\n    // https://www.shadertoy.com/view/4dffRH\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec4 noised( in vec3 x )\n{\n    // By iq, MIT License\n    // https://www.shadertoy.com/view/4dffRH\n    // grid\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    // quintic interpolant\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec3 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, f-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\nvoid foamTexture(vec3 p, vec2 vel, float foam_factor, out vec3 foam_color, out float blend)\n{\n    p = p * 10. + c.yxy * iTime * (10. + abs(0.5 + 0.5 * fbm_rock(p.xz / 500.)) * 0.);\n    float tex = 0.;\n    float A = 1.;\n    const float g = 0.6;\n    const float L = 2.1;\n    float freq = 1.;\n    float rot = 1.5;\n    vec3 gsum;\n    for(int i = 0; i < 6; i++) {\n        vec3 grad;\n        tex += A * psrdnoise(p * freq + gsum * .3, c.yyy, iTime * rot, grad);\n        gsum += A * grad;\n        freq *= L;\n        A *= g;\n        rot *= 2.0;\n    }\n    tex = clamp(1. - 0.4 * tex, 0.0, 1.0);\n    foam_color = tex + 0. * c.xxx;\n    blend = clamp(1.0 - pow(1.0 - tex, foam_factor * 2.), 0., 1.) * 0.8 * smoothstep(0.0, .6, length(vel));\n}\n\nfloat planarWavefront(vec2 p, vec2 d, float a)\n{\n    float lambda = pow(a, 3.);\n    float speed = 5. + pow(lambda, 2.0);\n    float crest = 3.5;\n    return a * (pow(0.5 * sin(dot(p, d) / lambda + speed * iTime) + 0.5, crest) - 0.5);\n}\n\nfloat waveField(vec3 p)\n{\n    p *= 14.;\n    vec2 d = normalize(vec2(1.0, 1.0));\n    return 0.1 * (\n           planarWavefront(p.xz, normalize(vec2(1.0, 1.0)), 0.4)\n         + planarWavefront(p.xz, normalize(vec2(1.0, 1.5)), 0.3)\n         + planarWavefront(p.xz, normalize(vec2(1.0, 2.9)), 0.35)\n         + planarWavefront(p.xz, normalize(vec2(1.0, .0)), 0.4)\n         + planarWavefront(p.xz, normalize(vec2(.0, 1.0)), 0.3) * .6\n         + planarWavefront(p.xz, normalize(vec2(-1.0, 1.0)), 0.25) * .4\n         );\n}\n\nfloat sdTerrain(vec3 p)\n{\n    vec3 size;\n    size.y = 100.;\n    size.xz = iResolution.xy * DRAW_SCALE * 0.5;\n    return sdBox(p - size, size);\n}\n\nvec4 terrainComponents(vec3 p)\n{\n    p.xz = p.xz / DRAW_SCALE / iResolution.xy;\n    vec4 tex = texture(iChannel1, p.xz);\n    //tex.y = max(4.0 - tex.x, 0.); // Set waterline at height 4 for rendering. Useful for testing stuff\n    tex.y += waveField(p) * smoothstep(0.0, 1.3, tex.y);\n    return tex;\n}\n\nvec2 waterVelocity(vec3 p)\n{\n    vec2 uv = p.xz / DRAW_SCALE / iResolution.xy;\n    vec2 duv = 1. / iResolution.xy;\n    vec4 flowC = texture(iChannel0, uv);\n    vec4 flowR = texture(iChannel0, uv + duv * c.xy);\n    vec4 flowL = texture(iChannel0, uv - duv * c.xy);\n    vec4 flowT = texture(iChannel0, uv + duv * c.yx);\n    vec4 flowB = texture(iChannel0, uv - duv * c.yx);\n    vec2 vel = vec2(\n        flowL.x + flowC.x - flowR.y - flowC.y,\n        flowT.w + flowC.w - flowB.z - flowC.z) / 2.;\n    float factor = 0.0;\n    if(factor > 0.0) {\n        vel /= factor;\n    }\n    return vel * 2.;\n}\n\nvec2 waterVelocityInterpolated(vec3 p)\n{\n    p -= DRAW_SCALE * 0.5;\n    vec2 blend = fract(p.xz / DRAW_SCALE);\n    vec2 vx1 = waterVelocity(p);\n    vec2 vx2 = waterVelocity(p + DRAW_SCALE * c.xyy);\n    vec2 vy1 = waterVelocity(p + DRAW_SCALE * c.yyx);\n    vec2 vy2 = waterVelocity(p + DRAW_SCALE * c.xyx);\n    vec2 vx = mix(vx1, vx2, blend.x);\n    vec2 vy = mix(vy1, vy2, blend.x);\n    return mix(vx, vy, blend.y);\n\n}\n\nfloat terrainHeight(vec3 p)\n{\n    return terrainComponents(p).x;\n}\n\nfloat terrainHeightFbm(vec3 p)\n{\n    return terrainComponents(p).x + 0.06 * fbm_rock(p.xz * .4 + p.y*0.1);\n}\n\nfloat surfaceHeight(vec3 p)\n{\n    vec2 H = terrainComponents(p).xy;\n    return H.x + H.y;\n}\n\nfloat surfaceHeightFbm(vec3 p)\n{\n    vec2 H = terrainComponents(p).xy + 0.06 * fbm_rock(p.xz * .4 + p.y*0.1);\n    return H.x + H.y;\n}\n\nvec3 waterNormal(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.);\n    return normalize(vec3(\n        surfaceHeight(p - eps.xyy) - surfaceHeight(p + eps.xyy),\n        2. * eps.x,\n        surfaceHeight(p - eps.yyx) - surfaceHeight(p + eps.yyx)));\n}\n\nvec3 waterNormalFbm(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.);\n    return normalize(vec3(\n        surfaceHeightFbm(p - eps.xyy) - surfaceHeightFbm(p + eps.xyy),\n        2. * eps.x,\n        surfaceHeightFbm(p - eps.yyx) - surfaceHeightFbm(p + eps.yyx)));\n}\n\nvec3 terrainNormal(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.);\n    return normalize(vec3(\n        terrainHeight(p - eps.xyy) - terrainHeight(p + eps.xyy),\n        2. * eps.x,\n        terrainHeight(p - eps.yyx) - terrainHeight(p + eps.yyx)));\n}\n\nvec3 terrainNormalFbm(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.);\n    return normalize(vec3(\n        terrainHeightFbm(p - eps.xyy) - terrainHeightFbm(p + eps.xyy),\n        2. * eps.x,\n        terrainHeightFbm(p - eps.yyx) - terrainHeightFbm(p + eps.yyx)));\n}\n\nfloat raycastWater(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i = 0; i < 256 && t < MAX_DEPTH; ++i) {\n        vec3 p = ro + rd * t;\n        float D = sdTerrain(p);\n        if(D < 0.) {\n            float dh = p.y - surfaceHeight(p);\n            if(abs(dh) < 0.001 * t) {\n                break;\n            }\n            t += 0.5 * dh;\n        } else {\n            t += D;\n        }\n    }\n    return t;\n}\n\nfloat raycastTerrain(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i = 0; i < 256 && t < MAX_DEPTH; ++i) {\n        vec3 p = ro + rd * t;\n        float D = sdTerrain(p);\n        if(D < 0.) {\n            float dh = p.y - terrainHeight(p);\n            if(abs(dh) < 0.001 * t) {\n                break;\n            }\n            t += 0.5 * dh;\n        } else {\n            t += D;\n        }\n    }\n    return t;\n}\n\nfloat raycastTerrainShadow(vec3 ro, vec3 rd)\n{\n    float t = 0.3;\n    float lightness = 1.0;\n    const float k = 4.0;\n    for(int i = 0; i < 32 && t < MAX_DEPTH; ++i) {\n        vec3 p = ro + t * rd;\n        float h = p.y - terrainHeight(p);\n        float dt = 0.8 * h;\n        lightness = min(lightness, max(0., k * h / t));\n        t += 0.6 * h;\n    }\n    return lightness;\n}\n\nvec3 renderTerrainPoint(vec3 p, vec3 v)\n{\n    vec4 H = terrainComponents(p);\n    vec3 n_terrain = terrainNormal(p);\n    vec3 n_fine = terrainNormalFbm(p);\n    vec4 col_rock = vec4(cmap_CielabCielab_rock(0.5 + 0.5 * sin(mod(0.9 + sin(p.y * 1.4) * 0.4 + 0.3 * fbm_rock(0.5 * p.xz), 2. * 3.141) + 0.2 * fbm_rock(p.xz * 0.2))), 0.7);\n    float fade_rock_grass = smoothstep(0.6, 0.75, n_terrain.y);\n    vec3 n_dry = normalize(n_terrain + n_fine * mix(3.0, 0.6, fade_rock_grass));\n    vec4 col_dry = mix(col_rock, mix(COLOR_GRASS * 0.7, COLOR_DIRT, sin(0.5 * fbm_rock(p.xz * 0.1))), fade_rock_grass);\n    vec3 n_wet = normalize(n_terrain + n_fine * 0.3);\n    vec4 col_wet = vec4(texture(iChannel3, p.xz / 10.0).rgb, 0.9);\n    vec4 base_color = mix(col_dry, col_wet, H.z);\n    vec3 n = mix(n_dry, n_wet, H.z);\n    float shadow = raycastTerrainShadow(p, SUN_DIR) * exp(-H.y / WATER_MUD_EXTINCTION);\n    vec3 col = base_color.rgb * (c.xxx * clamp(dot(n, SUN_DIR) * shadow, 0., 1.) + getSkyColor(n, 1.) * 0.7);\n    col += shadow * SUN_COLOR * base_color.rgb * base_color.a * pow(clamp(dot((SUN_DIR - v), n) / length(SUN_DIR - v), 0., 1.), 30.0);\n    col *= exp(-H.y / WATER_EXTINCTION);\n    col *= exp(-H.y / WATER_MUD_EXTINCTION); // muddiness\n    //col = c.yyy;\n    col += mix(c.yyy, normalize(WATER_EXTINCTION) * .4, 1.0 - exp(-H.y / 2.)) * clamp(shadow, 0.1, 1.0); // scattered light in water\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col = getSkyColor(rd, 1.);\n    float t = raycastWater(ro, rd);\n    if(t < MAX_DEPTH) {\n        vec3 p = ro + rd * t;\n        vec3 n_s = waterNormal(p);\n        vec3 n_f = waterNormalFbm(p);\n        vec2 heights = terrainComponents(p).xy;\n        const float fresnel_R0 = pow(0.333 / 2.333, 2.);\n        if(heights.y > 0.001) {\n            float fresnel = fresnel_R0 + (1. - fresnel_R0) * pow(1. - abs(dot(rd, n_s)), 5.);\n            vec3 rdrefract = refract(rd, n_s, 1. / 1.333);\n            vec3 rdreflect = reflect(rd, n_s);\n            float tw = raycastTerrain(p, rdrefract);\n            float tr = raycastTerrain(p + rdreflect * t * 0.001, rdreflect);\n            vec3 col_underwater = renderTerrainPoint(p + rdrefract * tw, rdrefract);\n            vec3 col_refract = col_underwater * exp(-tw/WATER_EXTINCTION);\n            vec3 col_reflect = getSkyColor(rdreflect, 40.);\n            if(tr < MAX_DEPTH) {\n                col_reflect = renderTerrainPoint(p + tr * rdreflect, rdreflect);\n            }\n            vec2 vel = waterVelocityInterpolated(p) / heights.y * smoothstep(0.01, 0.04, heights.y);\n            float foam_factor = 0.4 * smoothstep(0.2, 0.5, length(vel));\n            vec3 col_foam;\n            float foam_blend;\n            foamTexture(p, vel, foam_factor, col_foam, foam_blend);\n            \n            col_foam = col_foam * (clamp(dot(n_s, SUN_DIR), 0.7, 1.) * raycastTerrainShadow(p, SUN_DIR) * SUN_COLOR + getSkyColor(n_s, 1.0) * 0.5);\n            col = mix(col_refract, mix(col_reflect, col_foam, foam_blend), fresnel);\n            col = mix(col, col_foam, foam_blend);\n            //col = vec3(vel, -vel.x - vel.y);\n        } else {\n            col = renderTerrainPoint(p, rd);\n        }\n        //col = mix(c.yxy, c.yyx, smoothstep(0., 2.0, heights.y)) * max(dot(n_s, LIGHT_DIR), 0.1);\n        col = mix(col, getSkyColor(rd, 0.0), min(1.0 - exp(-t / MAX_DEPTH * 3.), 1.0));\n    }\n    return col;\n}\n\nvec3 cameraPath(float time)\n{\n    float speed = 0.9;\n    vec3 pos = vec3(\n        cos(0.2 * speed * time) * 100. + cos(0.0001 * time * speed) * 500.,\n        0.5 * (cos(0.01 * time) + 1.) * 7. + 3.,\n       7.0 * time * speed);\n    pos.y += surfaceHeight(pos) + 7.0;\n    return pos;\n}\n\ncameraState moveCamera(float time)\n{\n    cameraState cs;\n    cs.pos = texture(iChannel2, vec2(0.,0.)).xyz;\n    cs.target = cs.pos + getCameraDir(iMouse.xy, iResolution.xy);\n    cs.roll = sin(0.1 * time) * 0.001;\n    cs.focal_length = fovToFocalLength(40.);\n    return cs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    cameraState cs = moveCamera(iTime);\n    mat3 camTransform = cameraTransform(cs);\n    \n    \n    \n    vec3 col;\n    for(float dx = 0.; dx < 1.; dx += 1./(float(FSAA)+1.)) {\n        for(float dy = 0.; dy < 1.; dy += 1./(float(FSAA)+1.)) {\n            vec2 dp = vec2(dx, dy) / max(iResolution.x, iResolution.y);\n            vec3 ro = cs.pos;\n            vec3 rd = camTransform * normalize(vec3(p + dp, 1.));\n            col += render(ro, rd);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col / pow(float(FSAA + 1), 2.),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Hydraulics\n * \n * Copyright (C) 2023  Gregor Vollmer <git@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvoid getNeighbourHeights(vec2 uv, out vec4 waterH, out vec4 terrainH)\n{\n    vec2 duv = 1. / iResolution.xy;\n    vec2 n1 = texture(iChannel1, uv + duv * c.xy).xy; // Right\n    vec2 n2 = texture(iChannel1, uv - duv * c.xy).xy; // Left\n    vec2 n3 = texture(iChannel1, uv + duv * c.yx).xy; // Top\n    vec2 n4 = texture(iChannel1, uv - duv * c.yx).xy; // Bottom\n    waterH = vec4(n1.y, n2.y, n3.y, n4.y);\n    terrainH = vec4(n1.x, n2.x, n3.x, n4.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float dt = 1. / PHYSICS_FRAMERATE;\n    vec4 oldOutflow = texture(iChannel0, uv);\n    float waterC =  texture(iChannel1, uv).y;\n    float totalC = waterC + texture(iChannel1, uv).x;\n    vec4 waterNeigh;\n    vec4 terrainNeigh;\n    getNeighbourHeights(uv, waterNeigh, terrainNeigh);\n    vec4 totalNeigh = waterNeigh + terrainNeigh;\n    vec4 deltaH = totalC - totalNeigh;\n    vec4 accel = GRAVITY * deltaH / CELL_SIZE;\n    vec4 outflow = DAMPING * oldOutflow + dt * CROSS_SECTION * accel;\n    outflow = max(vec4(0.), outflow);\n    float maxWater = CELL_SIZE * CELL_SIZE * waterC;\n    float waterOut = (outflow.x + outflow.y + outflow.z + outflow.w) * dt;\n    if(waterOut == 0.) {\n        outflow = c.yyyy;\n    } else {\n        float scale = maxWater / waterOut;\n        if(scale < 1.0) {\n            outflow *= scale;\n        }\n    }\n    if(isKeyPressed(KEY_R) || iFrame == 0) {\n        outflow = c.yyyy;\n    }\n    fragColor = outflow;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n * Hydraulics\n * \n * Copyright (C) 2023  Gregor Vollmer <git@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define SCALE 4096.0\n#define SEED 0.\n\n#define PHYSICS_FRAMERATE 25.\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\nconst float CAMERA_SPEED = 5.0;\nconst float GRAVITY = 10.0;\nconst float CELL_SIZE = 0.1;\nconst float DRAW_SCALE = .14;\nconst float CROSS_SECTION = 0.01;\nconst float DAMPING = 0.9999;\nconst float SOURCE_INFLOW = .4 * CELL_SIZE * CELL_SIZE;\nconst float MAX_DEPTH = 256.;\nconst vec4 COLOR_GRASS = vec4(0.4, 0.7, 0.23, 0.1);\nconst vec4 COLOR_DIRT = vec4(0.4, 0.4, 0.0, 0.1);\nconst vec4 COLOR_SNOW = vec4(0.95, 0.95, 1.0, 1.);\nconst vec4 COLOR_STONE = vec4(0.6, 0.6, 0.5, 0.7);\nconst vec3 SUN_DIR = normalize(vec3(2.0, 1.6, 1.0));\nconst vec3 SUN_COLOR = vec3(1., 1., 1.);\nconst float SUN_ANGULAR_SIZE = 0.53 * 3.1415 / 180.;\nconst float SUN_FUZZYNESS = 6.0;\nconst float WATER_MUD_EXTINCTION = 10.;\nconst vec3 WATER_EXTINCTION = vec3(.5, 0.6, .9) * 50.;\n\nvec3 cmap_OklabCielab_sky(float t) {\n    return vec3(0.98,1.01,1.02)\n        +t*(vec3(-4.17,-1.70,-1.02)\n        +t*(vec3(25.10,9.57,12.33)\n        +t*(vec3(-102.18,-55.27,-67.76)\n        +t*(vec3(202.40,128.09,143.01)\n        +t*(vec3(-180.60,-122.35,-128.60)\n        +t*(vec3(59.45,41.65,42.03)\n    ))))));\n}\n\nvec3 cmap_CielabCielab_grass(float t) {\n    return vec3(0.30,0.37,0.28)\n        +t*(vec3(-2.28,-1.39,-3.01)\n        +t*(vec3(25.02,17.47,32.28)\n        +t*(vec3(-88.44,-62.85,-116.98)\n        +t*(vec3(145.17,104.86,190.31)\n        +t*(vec3(-114.25,-84.44,-144.40)\n        +t*(vec3(34.77,26.35,41.77)\n    ))))));\n}\n\nvec3 cmap_CielabCielab_rock(float t) {\n    return vec3(0.35,0.37,0.36)\n        +t*(vec3(1.56,1.46,1.31)\n        +t*(vec3(11.95,14.18,16.85)\n        +t*(vec3(-103.96,-120.78,-130.60)\n        +t*(vec3(264.67,306.57,321.03)\n        +t*(vec3(-275.05,-318.18,-327.59)\n        +t*(vec3(100.93,116.88,119.12)\n    ))))));\n}\n\n\nconst vec3 COLOR_SKY = vec3(0.7, 0.7, 1.0);\n\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(dot(p3.xy, p3.zz));\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// </David Hoskins>\n\nfloat lnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = c.xx * smoothstep(0., 1., fract(t));\n    vec2 v1 = 2. * mix(vec2(hash12(i), hash12(i + c.xy)), vec2(hash12(i + c.yx), hash12(i + c.xx)), t.y) - 1.;\n    return mix(v1.x, v1.y, t.x);\n}\n\n\nfloat lfnoise(vec2 t)\n{    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat lfnoise(vec3 t)\n{    vec3 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yyy, c.xxx, t);\n    vec3 v1 = vec3(hash13(i), hash13(i+c.xyy), hash13(i+c.yyx)), \n         v2 = vec3(hash13(i+c.yxy), hash13(i+c.xxx), hash13(i+c.xyx));\n    v1 = c.zzz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\n    vec2 s = step(bottomLeft, v) - step(topRight, v);\n    return s.x * s.y;\n}\n\nstruct cameraState\n{\n    vec3 pos;\n    vec3 target;\n    float roll;\n    float focal_length;\n};\n\nfloat fovToFocalLength(float FOV)\n{\n    return tan((90. - FOV/2.)/180.* pi) * 0.5;\n}\n\nmat3 cameraTransform(cameraState cs)\n{\n    vec3 cw = normalize(cs.target - cs.pos);\n    vec3 up = vec3(sin(cs.roll), cos(cs.roll), 0.0);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nfloat calcTerrainHeight(vec2 p)\n{\n    p /= 4.;\n    const float L = 2.7;\n    const float G = .4;\n    float A = 1.;\n    float h;\n    const float angle = 0.3;\n    const mat2 M = L * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    for(int i = 0; i < 8; ++i) {\n        h += A * lfnoise(p * 64.); A *= G; p = M * p;\n    }\n    return pow(abs(h), 1.4) * 12.;\n}\n\nvec3 getSkyColor(vec3 dir, float sun_intensity)\n{\n    float ar = acos(dot(SUN_DIR, dir));\n    return cmap_OklabCielab_sky(pow(abs(dir.y), 1.3) * .5) + SUN_COLOR * (1.-smoothstep(SUN_ANGULAR_SIZE, SUN_FUZZYNESS * SUN_ANGULAR_SIZE, ar)) * sun_intensity;\n}\n\n\nvec3 getCameraDir(vec2 mouse, vec2 resolution)\n{\n    float yaw = 2. * mouse.x / resolution.x * 2. * pi;\n    float pitch = clamp(2.0 * (mouse.y / resolution.y * pi - pi / 2.), -pi/2.1, pi/2.1);\n    if(mouse.x == 0. && mouse.y == 0.) {\n        yaw = 0.;\n        pitch = 0.;\n    }\n    return vec3(cos(yaw) * cos(pitch), sin(pitch), sin(yaw) * cos(pitch));\n}\n\nvec3 getCameraLeft(vec2 mouse, vec2 resolution)\n{\n    float yaw = 2. * mouse.x / resolution.x * 2. * pi - pi / 2.;\n    float pitch = 0.;\n    if(mouse.x == 0. && mouse.y == 0.) {\n        yaw = 0.;\n        pitch = 0.;\n    }\n    return vec3(cos(yaw) * cos(pitch), sin(pitch), sin(yaw) * cos(pitch));\n}\n\n#define isKeyPressed(key) (texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.5)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\nvec4 permute(vec4 x) {\n     vec4 xm = mod(x, 289.0);\n     return mod(((xm*34.0)+10.0)*xm, 289.0);\n}\n\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\n{\n\n#ifndef PERLINGRID\n  // Transformation matrices for the axis-aligned simplex grid\n  const mat3 M = mat3(0.0, 1.0, 1.0,\n                      1.0, 0.0, 1.0,\n                      1.0, 1.0, 0.0);\n\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                        0.5,-0.5, 0.5,\n                        0.5, 0.5,-0.5);\n#endif\n\n  vec3 uvw;\n\n  // Transform to simplex space (tetrahedral grid)\n#ifndef PERLINGRID\n  // Use matrix multiplication, let the compiler optimise\n  uvw = M * x;\n#else\n  // Optimised transformation to uvw (slightly faster than\n  // the equivalent matrix multiplication on most platforms)\n  uvw = x + dot(x, vec3(1.0/3.0));\n#endif\n\n  // Determine which simplex we're in, i0 is the \"base corner\"\n  vec3 i0 = floor(uvw);\n  vec3 f0 = fract(uvw); // coords within \"skewed cube\"\n\n  // To determine which simplex corners are closest, rank order the\n  // magnitudes of u,v,w, resolving ties in priority order u,v,w,\n  // and traverse the four corners from largest to smallest magnitude.\n  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.\n  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison \"less-than\"\n  vec3 l_ = 1.0 - g_;             // complement is \"greater-or-equal\"\n  vec3 g = vec3(l_.z, g_.xy);\n  vec3 l = vec3(l_.xy, g_.z);\n  vec3 o1 = min( g, l );\n  vec3 o2 = max( g, l );\n\n  // Enumerate the remaining simplex corners\n  vec3 i1 = i0 + o1;\n  vec3 i2 = i0 + o2;\n  vec3 i3 = i0 + vec3(1.0);\n\n  vec3 v0, v1, v2, v3;\n\n  // Transform the corners back to texture space\n#ifndef PERLINGRID\n  v0 = Mi * i0;\n  v1 = Mi * i1;\n  v2 = Mi * i2;\n  v3 = Mi * i3;\n#else\n  // Optimised transformation (mostly slightly faster than a matrix)\n  v0 = i0 - dot(i0, vec3(1.0/6.0));\n  v1 = i1 - dot(i1, vec3(1.0/6.0));\n  v2 = i2 - dot(i2, vec3(1.0/6.0));\n  v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n  // Compute vectors to each of the simplex corners\n  vec3 x0 = x - v0;\n  vec3 x1 = x - v1;\n  vec3 x2 = x - v2;\n  vec3 x3 = x - v3;\n\n  if(any(greaterThan(period, vec3(0.0)))) {\n    // Wrap to periods and transform back to simplex space\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n\t// Wrap to periods where specified\n\tif(period.x > 0.0) vx = mod(vx, period.x);\n\tif(period.y > 0.0) vy = mod(vy, period.y);\n\tif(period.z > 0.0) vz = mod(vz, period.z);\n    // Transform back\n#ifndef PERLINGRID\n    i0 = M * vec3(vx.x, vy.x, vz.x);\n    i1 = M * vec3(vx.y, vy.y, vz.y);\n    i2 = M * vec3(vx.z, vy.z, vz.z);\n    i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n    v0 = vec3(vx.x, vy.x, vz.x);\n    v1 = vec3(vx.y, vy.y, vz.y);\n    v2 = vec3(vx.z, vy.z, vz.z);\n    v3 = vec3(vx.w, vy.w, vz.w);\n    // Transform wrapped coordinates back to uvw\n    i0 = v0 + dot(v0, vec3(1.0/3.0));\n    i1 = v1 + dot(v1, vec3(1.0/3.0));\n    i2 = v2 + dot(v2, vec3(1.0/3.0));\n    i3 = v3 + dot(v3, vec3(1.0/3.0));\n#endif\n\t// Fix rounding errors\n    i0 = floor(i0 + 0.5);\n    i1 = floor(i1 + 0.5);\n    i2 = floor(i2 + 0.5);\n    i3 = floor(i3 + 0.5);\n  }\n\n  // Compute one pseudo-random hash value for each corner\n  vec4 hash = permute( permute( permute( \n              vec4(i0.z, i1.z, i2.z, i3.z ))\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n  // Compute generating gradients from a Fibonacci spiral on the unit sphere\n  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio\n  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289\n  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation\n\n  vec4 Ct = cos(theta);\n  vec4 St = sin(theta);\n  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere\n\n  vec4 gx, gy, gz;\n\n  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis\n#ifdef FASTROTATION\n  // Fast algorithm, but without dynamic shortcut for alpha = 0\n  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator\n  vec4 qy = -Ct; \n  vec4 qz = vec4(0.0);\n\n  vec4 px =  sz * qy;   // p' = cross(q, s)\n  vec4 py = -sz * qx;\n  vec4 pz = sz_prime;\n\n  psi += alpha;         // psi and alpha in the same plane\n  vec4 Sa = sin(psi);\n  vec4 Ca = cos(psi);\n\n  gx = Ca * px + Sa * qx;\n  gy = Ca * py + Sa * qy;\n  gz = Ca * pz + Sa * qz;\n#else\n  // Slightly slower algorithm, but with g = s for alpha = 0, and a\n  // useful conditional speedup for alpha = 0 across all fragments\n  if(alpha != 0.0) {\n    vec4 Sp = sin(psi);          // q' from psi on equator\n    vec4 Cp = cos(psi);\n\n    vec4 px = Ct * sz_prime;     // px = sx\n    vec4 py = St * sz_prime;     // py = sy\n    vec4 pz = sz;\n\n    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')\n    vec4 qx = mix( Ctp*St, Sp, sz);\n    vec4 qy = mix(-Ctp*Ct, Cp, sz);\n    vec4 qz = -(py*Cp + px*Sp);\n\n    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes\n    vec4 Ca = vec4(cos(alpha));\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n  }\n  else {\n    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient\n    gy = St * sz_prime;\n    gz = sz;  \n  }\n#endif\n\n  // Reorganize for dot products below\n  vec3 g0 = vec3(gx.x, gy.x, gz.x);\n  vec3 g1 = vec3(gx.y, gy.y, gz.y);\n  vec3 g2 = vec3(gx.z, gy.z, gz.z);\n  vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n  // Radial decay with distance from each simplex corner\n  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  w = max(w, 0.0);\n  vec4 w2 = w * w;\n  vec4 w3 = w2 * w;\n\n  // The value of the linear ramp from each of the corners\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n  // Multiply by the radial decay and sum up the noise value\n  float n = dot(w3, gdotx);\n\n  // Compute the first order partial derivatives\n  vec4 dw = -6.0 * w2 * gdotx;\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n  // Scale the return value to fit nicely into the range [-1,1]\n  return 39.5 * n;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n * Hydraulics\n * \n * Copyright (C) 2023  Gregor Vollmer <git@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nfloat fbm(vec2 p)\n{\n    const float L = 2.0;\n    const float G = .5;\n    float A = 1.;\n    float h;\n    const float angle = 0.3;\n    const float angle2 = 0.3;\n    //const mat3 M = L * (mat3(cos(angle), -sin(angle), 0., 0., 1., 0., sin(angle), cos(angle), 0.) * mat3(1., 0., 0., 0., cos(angle2), -sin(angle2), 0., sin(angle2), cos(angle2)));\n    const mat2 M = L * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    for(int i = 0; i < 3; ++i) {\n        h += A * lfnoise(p * 64.); A *= G; p = M * p;\n    }\n    return h * 3.141;\n}\n\nfloat getSourceMask(vec2 p)\n{\n    p += SCALE * 3.;\n    const float L = 4.4;\n    const float G = .7;\n    float A = 1.;\n    float h;\n    const float angle = 0.3;\n    const mat2 M = L * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    for(int i = 0; i < 3; ++i) {\n        h += A * lfnoise(p * 64.); A *= G; p = M * p;\n    }\n    h = step(3.0, pow(h, 4.0));\n    return h * pow(abs(fbm(p + 0.3* iTime)), 0.2);\n}\n\nfloat getSinkMask(vec2 p)\n{\n    p *= SCALE;\n    float m = 1.0;\n    return insideBox(p, 2.0 * c.xx, iResolution.xy - c.xx * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy / SCALE;\n    vec4 texel = texture(iChannel1, uv);\n    if(isKeyPressed(KEY_R) || iFrame == 0) {\n        texel.x = calcTerrainHeight(p + SEED);\n        texel.yz = c.yy;\n        texel.w = iTime;\n    }\n    float dt = 1. / PHYSICS_FRAMERATE;\n    if(dt < iTime - texel.w) {\n        fragColor = texel;\n    } else {\n        float terrainHeight = texel.x;\n        float waterHeight = texel.y;\n        float wetness = texel.z;\n        vec2 duv = 1. / iResolution.xy;\n        vec4 flowC = texture(iChannel0, uv);\n        vec4 flowR = texture(iChannel0, uv + duv * c.xy);\n        vec4 flowL = texture(iChannel0, uv - duv * c.xy);\n        vec4 flowT = texture(iChannel0, uv + duv * c.yx);\n        vec4 flowB = texture(iChannel0, uv - duv * c.yx);\n        float inflows = getSourceMask(p) * SOURCE_INFLOW + flowL.x + flowR.y + flowB.z + flowT.w;\n        float outflows = flowC.x + flowC.y + flowC.z + flowC.w;\n        waterHeight += dt * (inflows - outflows) / (CELL_SIZE * CELL_SIZE);\n        waterHeight *= getSinkMask(p);\n        wetness += (smoothstep(0.02, 0.2, waterHeight) - wetness) * 0.99999 * dt;\n        fragColor = vec4(terrainHeight, waterHeight, wetness, texel.w + dt);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n * Hydraulics\n * \n * Copyright (C) 2023  Gregor Vollmer <git@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvec4 terrainComponents(vec3 p)\n{\n    p.xz = p.xz / DRAW_SCALE / iResolution.xy;\n    vec4 tex = texture(iChannel1, p.xz);\n    //tex.y = max(4.0 - tex.x, 0.);\n    tex.y += 0.2 * smoothstep(0.0, 0.5, tex.y);\n    return tex;\n    return mix(-50. * c.xxyy, tex, insideBox(p.xz, c.yy, c.xx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fwd = getCameraDir(iMouse.xy, iResolution.xy);\n    vec3 left = getCameraLeft(iMouse.xy, iResolution.xy);\n    vec3 pos = texture(iChannel0, c.yy).xyz;\n    if(isKeyPressed(KEY_W)) {\n        pos += fwd * CAMERA_SPEED * iTimeDelta;\n    }\n    if(isKeyPressed(KEY_S)) {\n        pos -= fwd * CAMERA_SPEED * iTimeDelta;\n    }\n    if(isKeyPressed(KEY_A)) {\n        pos += left * CAMERA_SPEED * iTimeDelta;\n    }\n    if(isKeyPressed(KEY_D)) {\n        pos -= left * CAMERA_SPEED * iTimeDelta;\n    }\n    if(length(pos) < 0.001) {\n        pos = vec3(10., 20., 10.);\n    }\n    vec4 terrainComps = terrainComponents(pos);\n    float terrain = terrainComps.x + terrainComps.y + 0.1;\n    pos.y = max(pos.y, terrain);\n    fragColor = vec4(pos,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}