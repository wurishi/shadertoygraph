{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Rotation ( used for mouse interactivity )\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c,-s,s,c);\n}\n\n// Coloring function\nvec3 palette( float t){\n\n    vec3 a = vec3(0.1,0.1,0.65);\n    vec3 b = vec3(0.9,0.75,0.75);\n    vec3 c = vec3(0.98,0.98,0.99);\n    vec3 d = vec3(0.1,0.6,1.0);\n            \n    return a + b*cos(0.81318*(c*t+d));\n}\n\nfloat drawSphere(vec3 p , float s){\n    return length(p) - s;\n}\n\n\nfloat drawBox(vec3 p , vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat drawOctahedron(vec3 p , float s){\n    p = abs(p);\n    return (p.x + p.y + p.z - s ) * 0.57735027;\n}\n\n\nfloat scene(vec3 p){\n\n    // Forward & Sideways movement \n    p.z += iTime * 1.25;\n    p.x += sin(iTime*0.5)*0.25;\n    \n    // Inifinite number of elements\n    p.xy = (fract(p.xy)- 0.5);\n    p.z = mod(p.z , 0.35) - 0.225;\n    \n    float box = drawOctahedron(p,0.125);\n\n    return box;\n    \n    //vec3 spherePos = vec3(sin(iTime)*2.0,0,0);\n    //float sphere = drawSphere(p - spherePos, 1.0);\n    //float ground = p.y + 0.8;\n    //return min(ground, min(sphere,box));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float fov = 0.75;\n    \n    \n    \n    vec3 ray_origin = vec3(0,0,-3);\n    vec3 ray_dir = normalize(vec3(uv*fov,1));\n    vec3 col = vec3(0);\n    \n    float t = 0.0; \n    \n    // Mouse interactivity Horizontal and Vertical\n    ray_origin.yz *= rot2D(-m.y*1.5);\n    ray_dir.yz *= rot2D(-m.y*1.5);\n    \n    ray_origin.xz *= rot2D(-m.x*2.0);\n    ray_dir.xz *= rot2D(-m.x*2.0);\n    \n    int i ;\n    for (int i = 0; i < 40 ; i++){\n\n        // start at rayOrigin and move with each iteration \n        vec3 p = ray_origin + ray_dir * t;\n        \n        p.xy *= rot2D(t*0.25);\n        \n        p.y += sin(t*0.5)*0.5;\n\n        // distance to our objects \n        float d = scene(p);\n\n\n        // adding the total distance so we can display it \n        //t+= d;\n        if(d < .001 || d > 100.) break;\n\n        t += d*.7;\n    }    \n   \n   \n    // Coloring with the i values adds depth \n    col = palette(t*0.35 + float(i));\n    \n    fragColor = vec4(col,1.0);\n    \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4X3cRr","date":"1735042073","viewed":79,"name":"Raymarching Ivkoneli ","username":"ivkoneli","description":"Raymarching testing ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}