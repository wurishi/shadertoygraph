{"ver":"0.1","info":{"id":"ttfBR4","date":"1596449655","viewed":1044,"name":"SVO Test","username":"profhua","description":"SVO Test,Most code from https://www.shadertoy.com/view/3d2XRd","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voxel","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Most code from https://www.shadertoy.com/view/3d2XRd\n//Add some comments,change the data structure and remove shading since all i need is depth\n\n//#define bunny\n//#define shortarray\n\nconst float root_size = 3.;\nconst int levels = 5;\nconst int MAX_ITER = 222 ;\n\nconst float Power = 4.;\nconst float Bailout = 1.5;\nconst int Iterations = 6;\n\n#ifdef bunny\n#ifdef shortarray\nint voxels[64] = int[64](1,1,1,1,3,1,0,3, \n                        0,2,2,2,0,2,0,0,\n                        0,0,0,4,4,0,4,0,\n\t\t\t\t\t\t0,0,4,0,0,4,0,4,\n                         5,5,5,0,5,0,0,0,\n                         0,0,0,0,6,0,0,0,\n                         0,7,0,0,7,0,7,0,\n                       \t-1,0,-1,0,0,-1,0,0);\n\n#else\nint voxels[1840] = int[1840](1,0,0,0,0,0,0,0,8,11,2,44,116,122,154,161,0,0,3,0,63,57,36,47,0,5,0,4,0,6,0,7,0,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,0,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,0,-1,-1,0,0,0,18,0,9,68,21,53,28,0,0,0,0,0,10,0,14,0,0,0,0,0,-1,-1,-1,16,0,12,0,24,50,30,41,0,0,0,0,13,20,15,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,-1,0,22,23,49,26,70,72,74,75,0,0,0,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,39,40,25,27,73,71,76,77,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,52,29,43,33,80,81,87,88,-1,-1,-1,-1,-1,-1,-1,-1,31,32,34,35,82,83,89,90,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,37,0,38,115,99,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,0,0,-1,0,0,0,-1,-1,42,0,56,0,84,113,91,0,-1,0,-1,0,-1,-1,-1,-1,0,-1,0,0,-1,-1,-1,-1,0,0,0,0,60,65,45,0,0,0,46,0,0,0,0,0,-1,0,-1,0,-1,0,0,0,0,67,0,48,100,101,102,103,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,-1,0,0,0,0,51,0,104,0,78,106,0,0,0,0,-1,0,-1,0,0,0,0,0,-1,-1,-1,-1,0,54,0,55,107,79,85,86,0,0,0,0,0,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,0,58,59,0,0,93,94,110,114,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,61,62,0,0,95,96,111,112,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,64,0,0,108,92,109,98,0,0,0,0,-1,-1,0,0,66,0,0,0,97,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,69,0,105,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,-1,0,0,0,0,0,0,0,-1,0,0,0,-1,-1,0,-1,0,0,0,-1,0,-1,-1,0,-1,0,-1,0,-1,-1,0,0,0,-1,0,0,0,-1,0,-1,0,-1,0,-1,-1,-1,0,-1,0,-1,-1,-1,0,-1,-1,-1,0,0,-1,-1,-1,0,-1,-1,0,0,-1,-1,0,0,-1,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,-1,0,0,117,119,135,137,0,215,0,223,0,118,0,134,0,178,0,183,0,0,0,-1,0,0,0,-1,120,121,128,129,179,181,184,185,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,123,126,140,143,217,0,220,0,124,125,130,131,182,180,186,187,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,127,0,132,133,0,0,188,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,0,-1,-1,0,0,0,-1,0,0,0,-1,146,136,147,148,195,189,196,197,-1,-1,-1,-1,-1,-1,-1,-1,138,139,149,150,190,191,198,199,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,141,142,151,152,192,193,200,201,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,144,145,153,0,194,0,202,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,0,0,0,-1,0,-1,0,0,0,-1,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,155,158,173,176,228,0,0,0,156,157,167,168,209,203,210,211,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,159,160,169,170,204,205,212,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,162,165,0,0,0,0,0,0,163,164,171,172,206,207,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,166,0,0,0,208,0,0,0,-1,-1,-1,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,174,175,0,0,213,214,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,177,0,0,0,0,0,0,0,-1,0,0,0,-1,0,0,0,0,0,0,-1,0,0,0,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,0,-1,-1,0,-1,0,0,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,0,0,-1,0,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,0,-1,0,0,0,0,0,-1,0,-1,0,0,0,0,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,0,0,0,-1,0,0,0,0,0,0,0,0,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,216,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,218,219,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,221,222,226,227,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,0,-1,-1,0,0,0,0,0,224,0,225,0,0,0,0,0,-1,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,229,0,0,0,0,0,0,0,0,-1,0,0,0,0,0);\n#endif\n#endif\nconst float[6] Scales = float[6](1.,.5,.25,.125,.0625,.03125);\n\n// -----------------------------------------------------------------------------------------\n\nfloat dist(vec3 pos) {\n    // This function takes ~all of the rendering time, the trigonometry is super expensive\n    // So if there are any faster approximations, they should definitely be used\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    for (int i = 0; i < Iterations; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\n\t\tfloat phi = atan(z.y,z.x);\n\n\t\tdr = pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nvec2 isect(in vec3 pos, in float size, in vec3 ro, in vec3 rd, out vec3 tmid, out vec3 tmax) {\n    vec3 mn = pos - 0.5 * size;\n    vec3 mx = mn + size;\n    vec3 t1 = (mn-ro) / rd;\n    vec3 t2 = (mx-ro) / rd;\n    vec3 tmin = min(t1, t2);\n    tmax = max(t1, t2);\n    tmid = (pos-ro)/rd; // tmax;\n    return vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\n\nconst float d_corner = sqrt(0.75);\n\nbool trace(in vec3 ro, in vec3 rd, out vec2 t, out vec3 pos, out int iter, out float size) {\n    \n    struct ST {\n    vec3 pos;\n\tint scale; // size = root_size * exp2(float(-scale));\n    vec3 idx;\n    int ptr;\n    float h;\n\t} stack[levels];\n\n\tint stack_ptr = 0; // Next open index\n\n\n    \n    //-- INITIALIZE --//\n    \n    \n    size = root_size;//3.\n    vec3 root_pos = vec3(0);\n    pos = root_pos;\n    vec3 tmid;\n    vec3 tmax;\n    bool can_push = true;\n    float d;\n    t = isect(pos, size, ro, rd, tmid, tmax);\n    float h = t.y;\n    \n    // Initial push, sort of\n    // If the minimum is before the middle in this axis, we need to go to the first one (-rd)\n    vec3 idx = mix(-sign(rd), sign(rd), lessThanEqual(tmid, vec3(t.x)));\n    int stackIdx = 0;\n   \tint scale = 1;\n    size *= 0.5;//level 1 size\n    pos += 0.5 * size * idx;//move to first hitted sub-cell center\n    \n    \n    iter = MAX_ITER;\n    while (iter --> 0) {\n        t = isect(pos, size, ro, rd, tmid, tmax);\n        \n        #ifndef bunny\n        d = dist(pos);\n        #endif\n        \n        #ifdef bunny\n\n        float subIdx = dot(idx*.5+.5,vec3(1.,2.,4.));\n        int curIdx = stackIdx*8+int(subIdx);\n        \n        if (voxels[curIdx] != 0) { // Voxel exists\n        #else\n            if(d <size*d_corner){\n        #endif    \n            if (scale >= levels)// //hit the smallest voxel;\n                return true;\n            \n            if (can_push) {\n                //-- PUSH --//\n                \n                \n                if (t.y < h) //*t.y is this voxel exist dist,h is parent voxel exist dist\n                {\n                    \n                    stack[stack_ptr++] = ST(pos, scale, idx,stackIdx, h);\n                }\n                h = t.y;\n                scale++;\n                size *= 0.5;\n                idx = mix(-sign(rd), sign(rd), step(tmid, vec3(t.x)));\n                \n                #ifdef bunny\n                stackIdx = voxels[curIdx];\n                #else\n                stackIdx = 0;\n                #endif\n                \n                pos += 0.5 * size * idx;\n                continue;\n            }\n        }\n        \n        //when code still running,means (!voxel Exist  || can_push == false) \n        //-- ADVANCE --//\n        \n        // Advance for every direction where we're hitting the middle (tmax = tmid)\n        vec3 old = idx;\n        \n        //this is genius,for the hitted direction,if hit point is in the middle,we advance to the other side,\n\t\t//else if hit point is in the edge,it will leave the stack.and keep all unhitted direction\n        idx = mix(idx, sign(rd), equal(tmax, vec3(t.y)));\n        \n        //if old = idx → stay,else → move forward in this stack\n        pos += mix(vec3(0.), sign(rd), notEqual(old, idx)) * size;\n        \n        // If idx hasn't changed, we're at the last child in this voxel\n        if (idx == old) {\n            //-- POP --//\n           \n            if (stack_ptr == 0 || scale == 0) return false; //exist Whole Octree;\n            \n            ST s = stack[--stack_ptr];//Back to parent Stack\n            pos = s.pos;\n            scale = s.scale;\n            //size = root_size * exp2(float(-scale));\n            size = root_size * Scales[scale];\n\t\t\tidx = s.idx;\n\t\t\tstackIdx = s.ptr;\n            h = s.h;\n            \n            \n            can_push = false; //*once stack pop out,get rid out pushing in again\n        } else can_push = true;//idx != old  move forward in this stack\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r = 12.0*iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(8.0*sin(0.5*r),1.5-iMouse.y/iResolution.y,8.*cos(0.5*r));\n    vec3 lookAt = vec3(0.0);\n    vec3 cameraDir = normalize(lookAt-ro);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 left = normalize(cross(cameraDir, up)); // Might be right\n    vec3 rd = cameraDir;\n    float FOV = 0.4; // Not actual FOV, just a multiplier\n    rd += FOV * up * uv.y;\n    rd += FOV * left * uv.x;\n    // `rd` is now a point on the film plane, so turn it back to a direction\n    rd = normalize(rd);\n    \n    vec2 t;\n    vec3 pos;\n    float size;\n    int iter;\n    bool hit = trace(ro, rd, t, pos, iter, size);\n    vec3 col =  hit ? vec3((t.x-6.)*.5,0.,0.) : vec3(.0,0.,0.);\n\n    //fragColor = vec4(vec3(float(iter)/float(MAX_ITER)),1.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}