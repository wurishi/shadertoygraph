{"ver":"0.1","info":{"id":"fdj3zt","date":"1618709635","viewed":94,"name":"Icosahedron [v 5.6]","username":"catbox","description":"by Doroshenko Ilya","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["msu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\n    \nvec3 W = vec3(1120.0);\n\nvec3 uncharted2ToneMapping(vec3 x){\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0,fragCoord.xy / iResolution.xy).rgb;\n    vec3 curr = uncharted2ToneMapping(color.xyz*2.0);\n\tvec3 whiteScale = 1.0/uncharted2ToneMapping(W); \n\tvec3 mapped = curr*whiteScale;\n\t\n\tmapped = pow(mapped, vec3(1.0 / 2.2));\n\tfragColor =  vec4(mapped,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EMISSIVE 0\n#define DIELECTRIC 1\n#define METALIC 2\n#define GLASS 3\n#define EPSILON 0.0000001\n#define GR (1.618033988749895)\n\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float refractiveIndex;\n    int type;\n};\n\n\nstruct Refracted\n{\n    bool did;\n    vec3 direction;\n};\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec3 attenuation;\n    vec3 radiance;\n    float rand;\n    float t;\n    bool done;\n};\n    \n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material mat;\n};\n\n\nstruct Icosahedron\n{\n    vec3 center;\n    float sideLen;\n    Material mat;\n};\n\n\nstruct Cylinder\n{\n    vec3 bottom, top;\n    float radius;\n    Material mat;\n};\n\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n    Material mat;\n};\n\n\nstruct Triangle\n{\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\n    \nstruct Hit\n{\n  vec3 normal;\n  float t;\n  bool hit;\n  Material mat;\n};\n\n\nstruct Volume\n{\n    vec3 center;\n    float radius;\n    vec3 absorption;\n};\n\n\nfloat aperture = 0.03;\nint pathsPerFrame = 5;\nint maxDepth = 20;\nfloat t_max = 4294967296.0;\nfloat t_min = 0.0039;\n\nSphere sphereI               = Sphere(vec3(0.0, 0.8, 0.2), 0.08, Material(vec3(34.0/255.0, 165.0/255.0, 227.0/255.0), 0.0, 1.52, GLASS));\nSphere sphereII              = Sphere(vec3(0.0, 0.7, 0.0), 0.05, Material(vec3(34.0/255.0, 165.0/255.0, 227.0/255.00), 0.0, 1.52, GLASS));\nSphere sphereIII             = Sphere(vec3(0.0, 0.5, 0.1), 0.04, Material(vec3(34.0/255.0, 165.0/255.0, 227.0/255.0), 0.0, 1.52, GLASS));\nSphere sphereIV              = Sphere(vec3(0.0, 0.4, 0.0), 0.02, Material(vec3(34.0/255.0, 165.0/255.0, 227.0/255.0), 0.0, 1.52, GLASS));\nIcosahedron wIcosahedron     = Icosahedron(vec3(0.0, 0.6, 0.0), 0.3, Material(vec3(1.0), 0.0, 1.52, GLASS));\nCylinder stand               = Cylinder(vec3(0.0, -0.0, 0.0), vec3(0.0, 0.1, 0.0), 0.55, Material(vec3(145.0/255.0, 70.0/255.0, 34.0/255.0), 0.05, 5.8735, METALIC));\nSphere LightI                = Sphere(vec3(0.5, 2.0,  1.0), 0.45, Material(vec3(0.1333, 0.4078, 0.3294)*15.0, 0.7, 2.8735, EMISSIVE));\nSphere LightII               = Sphere(vec3(1.5, 1.35, -0.9), 0.25, Material(vec3(0.945, 0.847, 0.133)*15.0, 0.7, 2.8735, EMISSIVE));\nPlane plane                  = Plane(vec3(0.0), vec3(0.0, 1.0, 0.0), Material(vec3(0.3), 0.1, 2.8735, DIELECTRIC));\n\n\nuint hash(uint x)\n{\n    x += (x << 10u);\n    x ^= (x >>  6u);\n    x += (x <<  3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n\n\nuint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }\nuint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }\nuint hash(uvec4 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w)); }\n\n\nfloat floatConstruct(uint m)\n{\n    const uint ieeeMantissa = 0x007FFFFFu;\n    const uint ieeeOne      = 0x3F800000u;\n\n    m &= ieeeMantissa;\n    m |= ieeeOne;\n\n    float  f = uintBitsToFloat( m );\n    return f - 1.0;\n}\n\n\nfloat random(float x) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random(vec2  v) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random(vec3  v) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random(vec4  v) { return floatConstruct(hash(floatBitsToUint(v))); }    \n\n\nvec3 randv(float n)\n{\n\tvec3 v = 2.0 * vec3(random(n + 1.0), random(n + 2.0), random(n + 3.0)) - 1.0;\n    \n    do\n    {\n        v = 2.0 * vec3(random(v.x), random(v.y), random(v.z)) - 1.0;\n    }\n    while(length(v) >= 1.0);\n    \n    return v;\n}\n\n\nvec3 backgroundColor(vec3 dir)\n{\n    vec3 unit_dir = normalize(dir);\n    float t = 0.5*(unit_dir.y+1.0);\n\n    return pow(texture(iChannel1,dir).rgb,vec3(2.2))*10.1;\n}\n\n\nHit traceSphere(Ray ray, Sphere sphere)\n{\n   \tfloat a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, ray.origin - sphere.center) * 2.0;\n    float c = dot(ray.origin - sphere.center, ray.origin - sphere.center) - sphere.radius * sphere.radius;\n    float d = b*b - 4.0*a*c;\n    \n    Hit hit;\n    \n    if(d >= 0.0)\n    {\n        hit.t = (-b - sqrt(d)) / (2.0*a);\n      \tif(hit.t < t_max && hit.t > t_min)\n        {\n        \thit.normal = normalize((ray.origin + ray.direction * hit.t) - sphere.center);\n        \thit.mat = sphere.mat;\n        \thit.hit = true;\n        \treturn hit;\n        }\n        \n        hit.t = (-b + sqrt(d)) / (2.0*a);\n        if(hit.t < t_max && hit.t > t_min)\n        {\n        \thit.normal = normalize((ray.origin + ray.direction * hit.t) - sphere.center);\n        \thit.mat = sphere.mat;\n        \thit.hit = true;\n        \treturn hit;\n        }\n    }\n    \n\thit.hit = false;\n\treturn hit;\n}\n\n\nHit traceTriangle(Ray ray, Triangle triangle) {\n    Hit hit;\n    vec3 vertex0 = triangle.v0 * wIcosahedron.sideLen + wIcosahedron.center;\n    vec3 vertex1 = triangle.v1 * wIcosahedron.sideLen + wIcosahedron.center;  \n    vec3 vertex2 = triangle.v2 * wIcosahedron.sideLen + wIcosahedron.center;\n    vec3 edge1, edge2, h, s, q;\n    float a,f,u,v;\n    \n    edge1 = vertex1 - vertex0;\n    edge2 = vertex2 - vertex0;\n    \n    h = cross(ray.direction, edge2);\n    a = dot(edge1, h);\n    \n    if (abs(a) < EPSILON)\n    {\n        hit.hit = false;\n        return hit;\n    }\n    \n    f = 1.0/a;\n    s = ray.origin - vertex0;\n    u = f * dot(s, h);\n    \n    if (u < 0.0 || u > 1.0)\n    {\n        hit.hit = false;\n        return hit;\n    }\n    \n    q = cross(s, edge1);\n    v = f * dot(ray.direction, q);\n    \n    if (v < 0.0 || u + v > 1.0)\n    {\n        hit.hit = false;\n        return hit;\n    }\n    \n    float t = f * dot(edge2, q);\n    \n    if (t < EPSILON)\n    {\n      hit.hit = false;\n      return hit;\n    }\n    \n    hit.hit = true;\n    hit.t = t;\n    hit.normal = normalize(cross(edge1, edge2));\n    //hit.normal = normalize((vertex0 + vertex1 + vertex2));\n    //hit.normal = normalize(vec3(edge1.y*edge2.z - edge1.z*edge2.y, edge1.z*edge2.x - edge1.x*edge2.z, edge1.x*edge2.y - edge1.y*edge2.x));\n    return hit;\n    \n}\n\n\nHit compareHit(Hit hit, Hit newHit)\n{\n    if(newHit.hit)\n    {\n    \tif(newHit.t < hit.t )\n        {\n            return newHit;\n        }\n    }   \n   \t\n    return hit;\n}\n\n\nTriangle face[20] = Triangle[20](Triangle(vec3(0.0, -GR, -1.0),vec3(1.0, 0.0, -GR), vec3(GR, -1.0, 0.0)),\n                                     Triangle(vec3(0.0, -GR, -1.0),vec3(0.0, -GR, 1.0), vec3(GR, -1.0, 0.0)),\n                                     Triangle(vec3(0.0, -GR, -1.0),vec3(0.0, -GR, 1.0), vec3(-GR, -1.0, 0.0)),\n                                     Triangle(vec3(0.0, -GR, -1.0), vec3(-1.0, 0.0, -GR), vec3(-GR, -1.0, 0.0)),\n                                     Triangle(vec3(0.0, -GR, -1.0),vec3(1.0, 0.0, -GR), vec3(-1.0, 0.0, -GR)),\n                \n                                     Triangle(vec3(0.0, GR, -1.0),vec3(-1.0, 0.0, -GR), vec3(1.0, 0.0, -GR)),\n                                     Triangle(vec3(-1.0, 0.0, -GR),vec3(-GR, 1.0, 0.0), vec3(0.0, GR, -1.0)),\n                                     Triangle(vec3(-GR, 1.0, 0.0),vec3(-GR, -1.0, 0.0), vec3(-1.0, 0.0, -GR)),\n                                     Triangle(vec3(-GR, -1.0, 0.0),vec3(-1.0, 0.0, GR), vec3(-GR, 1.0, 0.0)),\n                                     Triangle(vec3(-1.0, 0.0, GR),vec3(0.0, -GR, 1.0), vec3(-GR, -1.0, 0.0)),\n                                     Triangle(vec3(0.0, -GR, 1.0),vec3(1.0, 0.0, GR), vec3(-1.0, 0.0, GR)),\n                                     Triangle(vec3(1.0, 0.0, GR),vec3(GR, -1.0, 0.0), vec3(0.0, -GR, 1.0)),\n                                     Triangle(vec3(GR, -1.0, 0.0),vec3(GR, 1.0, 0.0), vec3(1.0, 0.0, GR)),\n                                     Triangle(vec3(GR, 1.0, 0.0),vec3(1.0, 0.0, -GR), vec3(GR, -1.0, 0.0)),\n                                     Triangle(vec3(1.0, 0.0, -GR),vec3(0.0, GR, -1.0), vec3(GR, 1.0, 0.0)),\n                \n                                     Triangle(vec3(0.0, GR, 1.0),vec3(0.0, GR, -1.0), vec3(-GR, 1.0, 0.0)),\n                                     Triangle(vec3(0.0, GR, 1.0),vec3(-GR, 1.0, 0.0), vec3(-1.0, 0.0, GR)),\n                                     Triangle(vec3(0.0, GR, 1.0),vec3(1.0, 0.0, GR), vec3(-1.0, 0.0, GR)),\n                                     Triangle(vec3(0.0, GR, 1.0),vec3(GR, 1.0, 0.0), vec3(1.0, 0.0, GR)),\n                                     Triangle(vec3(0.0, GR, 1.0),vec3(0.0, GR, -1.0), vec3(GR, 1.0, 0.0)));\n\nHit traceIcosahedron(Ray ray, Icosahedron icosahedron)\n{\n    Hit   hit;\n    \n    for(int i = 0; i < 20; i++)\n    {\n        hit = traceTriangle(ray, face[i]);\n        if (hit.hit == true)\n        {\n            hit.mat = icosahedron.mat;\n            return hit;\n        }\n    }\n    \n    return hit;\n}\n\n\nHit traceCylinder(Ray ray, Cylinder cylinder)\n{\n    vec3 cc = 0.5 * (cylinder.bottom + cylinder.top);\n    float ch = length(cylinder.top - cylinder.bottom);\n    vec3 ca = (cylinder.top - cylinder.bottom) / ch;\n    ch *= 0.5;\n\n    vec3  oc = ray.origin - cc;\n\n    float card = dot(ca, ray.direction);\n    float caoc = dot(ca, oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot(oc, ray.direction) - caoc*card;\n    float c = dot(oc, oc) - caoc*caoc - cylinder.radius*cylinder.radius;\n    float d = b*b - a*c;\n    \n    Hit hit;\n    \n    if(d >= 0.0)\n    {\n        float sqrtd = sqrt(d);\n        hit.t = (-b - sqrtd) / a;\n        float y = caoc + hit.t*card;\n        if(hit.t < t_max && hit.t > t_min)\n        {\n            if(abs(y) < ch)\n            {\n                hit.normal = normalize(oc + hit.t*ray.direction - ca*y);\n                hit.mat = cylinder.mat;\n                hit.hit = true;\n                return hit;\n            }\n        }\n        float sy = sign(y);\n        hit.t = (sy*ch - caoc) / card;\n        if(hit.t < t_max && hit.t > t_min)\n        {\n            if(abs(b + a * hit.t) < sqrtd)\n            {\n                hit.normal = ca * sy;\n                hit.mat = cylinder.mat;\n                hit.hit = true;\n                return hit;\n            }\n        }\n    }\n\n    hit.hit = false;\n    return hit;\n}\n\n\nHit tracePlane(Ray ray, Plane plane)\n{\n    Hit hit;\n    \n    float dn = dot(ray.direction, plane.normal);\n    if(dn != 0.0)\n    {\n        hit.t = dot(plane.point - ray.origin, plane.normal) /  dn;\n        if(hit.t < t_max && hit.t > t_min)\n        {\n            hit.normal = plane.normal;\n            hit.mat = plane.mat;\n            hit.hit = true;\n            return hit;\n        }\n    }\n    \n    hit.hit = false;\n    return hit;\n}\n\n\nHit traceScene(Ray ray)\n{\n    Hit hit;\n    hit.t = t_max;\n    \n    hit = compareHit(hit, traceSphere(ray, sphereI));\n    hit = compareHit(hit, traceSphere(ray, sphereII));\n    hit = compareHit(hit, traceSphere(ray, sphereIII));\n    hit = compareHit(hit, traceSphere(ray, sphereIV));\n   \n    hit = compareHit(hit, traceSphere(ray, LightI));\n    hit = compareHit(hit, traceSphere(ray, LightII));\n    \n    hit = compareHit(hit, traceIcosahedron(ray, wIcosahedron)); \n    hit = compareHit(hit, tracePlane(ray, plane));\n    hit = compareHit(hit, traceCylinder(ray, stand));\n\n    return hit;   \n}\n\n\nfloat schlick(float cosine, float refractiveIndex)\n{\n    float r0 = (1.0 - refractiveIndex) / (1.0 + refractiveIndex);\n    r0 = r0 * r0;\n    \n    return r0 + (1.0 - r0) * pow(max(0.0, 1.0 - cosine), 5.0);\n}\n\n\nRefracted refract0(vec3 v,vec3 n, float ni_nt)\n{\n    Refracted ref;\n    \n    v = normalize(v);\n    float dt = dot(v, n);\n    float disc = 1.0 - ni_nt*ni_nt * (1.0 - dt*dt);\n    \n    if(disc > 0.0){\n        ref.direction = ni_nt * (v - n*dt) - n*sqrt(disc);\n        ref.did = true;\n    }\n    else\n    {\n        ref.did = false;\n    }\n    \n    return ref;\n}\n\n\nRay castRay(Ray ray)\n{\n    Hit hit = traceScene(ray);\n    ray.t = hit.t;\n    float roughness = hit.mat.roughness * hit.mat.roughness;\n    \n    if(hit.hit)\n    {\n        float ref_idx = hit.mat.refractiveIndex;\n        \n        ray.radiance = vec3(0.0);\n        ray.rand = random(ray.rand);\n        ray.origin = ray.t*ray.direction + ray.origin;\n        ray.attenuation = ray.attenuation * hit.mat.albedo;\n        \n        if(hit.mat.type == DIELECTRIC)\n        {\n            float cosine = -dot(ray.direction, mix(hit.normal, -ray.direction, roughness)) / length(ray.direction);\n            float schlick = schlick(cosine, ref_idx);\n            \n            if(ray.rand > schlick)\n            {\n\t\t\t\tray.direction = normalize(hit.normal + randv(ray.rand));\n            }\n            else\n            {\n\t\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n            }\n        }\n        else if(hit.mat.type == METALIC)\n        {\n\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n        }\n        else if(hit.mat.type == GLASS)\n        {        \n            float cosine;\n            float ni_nt;\n            vec3 normal;\n            \n            if(dot(ray.direction, hit.normal) > 0.0)\n            {\n\t\t\t\tnormal = -hit.normal;\n               \tni_nt = ref_idx;\n                cosine = ref_idx * dot(ray.direction, hit.normal) / length(ray.direction);\n            }\n            else\n            {\n                normal = hit.normal;\n                ni_nt = 1.0 / ref_idx;\n                cosine = -dot(ray.direction, hit.normal) / length(ray.direction);\n            }\n            \n            float schlick0;\n            Refracted ref = refract0(ray.direction, normal, ni_nt);\n            \n            if(ref.did)\n            {\n                schlick0 = schlick(cosine, ref_idx);\n            }\n            else\n            {  \n                schlick0 = 1.0;\n            }\n           \t\n            if(ray.rand > schlick0)\n            {\n                ray.direction = normalize(ref.direction + randv(ray.rand)*roughness);\n            }\n            else\n            {\n\t\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n            }\n        }\n        else if(hit.mat.type == EMISSIVE)\n        {\n\t\t\tfloat cosine = -dot(ray.direction, mix(hit.normal, -ray.direction, roughness)) / length(ray.direction);\n            float schlick = schlick(cosine, ref_idx);\n            \n            if(ray.rand > schlick)\n            {\n                ray.direction = normalize(hit.normal + randv(ray.rand)*roughness);\n                ray.radiance = hit.mat.albedo;\n            }\n            else\n            {\n\t\t\t\tray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);\n            }\n            ray.done = true;\n        }\n    }\n    else\n    {\n        ray.radiance = backgroundColor(ray.direction);\n        ray.done = true;\n    }\n    \n    return ray;   \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray  ray;\n    vec2 uv            = (vec2(-1.0) + 2.0*(fragCoord.xy / iResolution.xy)) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 frame         = vec2(-4.3, -0.2); \n    mat3 rotY          = mat3(vec3(cos(frame.x),0,sin(frame.x)),vec3(0,1,0),vec3(-sin(frame.x),0,cos(frame.x)));               \n    mat3 rotX          = mat3(vec3(1,0,0),vec3(0,  cos(frame.y), sin(frame.y)),vec3(0, -sin(frame.y), cos(frame.y)));                \n    mat3 rot           = rotY * rotX;\n    vec4 previousColor = texture(iChannel0, (fragCoord.xy / iResolution.xy));\n    vec3 color         = vec3(0.0);\n    float focal        = (iMouse.y / iResolution.y)*0.0 + 2.5;\n    \n    for(int path = 0; path < pathsPerFrame; path++)\n    {\n        vec2 offset0 = randv(random(vec4(uv, iFrame, path))).xy * aperture;\n        vec2 offset1 = (2.0*vec2(random(vec4(uv, path, iFrame)),random(vec4(uv, path + pathsPerFrame, iFrame))) - 1.0) / iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0);\n\n        ray.direction = rot*normalize(vec3(uv*focal/2.5-offset0+offset1,-focal));\n        ray.origin = rot*vec3(offset0+offset1, 3.0) + vec3(0.0, wIcosahedron.sideLen + stand.top.y, 0.0);\n        ray.attenuation = vec3(1.0);\n    \tray.rand = random(vec4(uv,path,iTime));\n   \t\tray.done = false;\n\n    \tfor(int depth = 0; depth < maxDepth && !ray.done ;depth++)\n    \t{\n    \t   ray = castRay(ray);\n    \t}\n\t\tcolor += ray.radiance*ray.attenuation;\n    }\n    \n    color /= float(pathsPerFrame);      \n   \tfloat temp = previousColor.w+1.0;\n    float mixf = 1.0/temp;\n\tfragColor = vec4(mix(color, previousColor.rgb, 1.0-mixf),temp);\n}","name":"Buffer A","description":"","type":"buffer"}]}