{"ver":"0.1","info":{"id":"3dGGzh","date":"1569651779","viewed":767,"name":"Autostereogram v2","username":"BFrizzFoShizz","description":"An Autostereogram 3D renderer, displaying two quads on top of a rippling wave.\nCross your eyes so the two black squares overlap to see in 3D.\n\nit's not really depth-correct, but it works well enough.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["stereogram","autostereogram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GetXOffset(float x, float depth, float eyeWidth)\n{\n    return x - (eyeWidth - depth);\n}\n\nstruct Rect\n{\n    float x;\n    float y;\n    float w;\n    float h;\n    float z;\n};\n\nRect CreateRect(float x, float y, float w, float h, float z)\n{\n    Rect rect;\n    rect.x = x;\n    rect.y = y;\n    rect.w = w;\n    rect.h = h;\n    rect.z = z;\n    return rect;\n}\n\n\nRect CreateRect(float x, float y, float w, float h, vec2 dims, float z)\n{\n    Rect rect;\n    rect.x = x/dims.x;\n    rect.y = y/dims.y;\n    rect.w = w/dims.x;\n    rect.h = h/dims.y;\n    rect.z = z;\n    return rect;\n}\n\nbool RectContains(Rect rect, vec2 pos)\n{\n    return (rect.x <= pos.x && pos.x < rect.x + rect.w &&\n            rect.y <= pos.y && pos.y < rect.y + rect.h);\n}\n\nfloat GetDepth(Rect rect, vec2 pos, float depth)\n{\n    if(RectContains(rect, pos))\n        return max(depth, rect.z);\n    return depth;\n}\n\nfloat GetConeDepth(vec2 conePos, vec2 pixelPos, float depth)\n{\n    vec2 delta = conePos - pixelPos;\n    float squareDepth = 5.0f - 5.0f * cos(20.0f*sqrt(dot(delta,delta)) - iTime * 5.0f);\n    return max(squareDepth,depth);\n}\n\nbool RectShiftLeftContains(Rect rect, vec2 pos, float eyeWidth)\n{\n    float shift = (eyeWidth - rect.z) / iResolution.x;\n    return (rect.x - shift <= pos.x && pos.x < rect.x + rect.w &&\n            rect.y <= pos.y && pos.y < rect.y + rect.h);\n}\n\nbool RectShiftRightContains(Rect rect, vec2 pos, float eyeWidth)\n{\n    float shift = (eyeWidth - rect.z) / iResolution.x;\n    return (rect.x + shift * 0.5f <= pos.x && pos.x < rect.x + rect.w - shift * 1.5 &&\n            rect.y <= pos.y && pos.y < rect.y + rect.h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    Rect rect1 = CreateRect(0.1f,0.1f,0.3f,0.3f, 15.0f);\n    Rect rect2 = CreateRect(0.175f,0.175,0.15f,0.15f, 20.0f);\n    \n    \n    float eyeWidth = 60.0f;\n    \n    // draw dots\n    float centredX = (uv.x-0.5f);\n    float eyeOffsetMinX = ((eyeWidth / 2.0f) - 10.0f) /iResolution.x;\n    float eyeOffsetMaxX = ((eyeWidth / 2.0f) + 10.0f)/iResolution.x;\n    float eyeOffsetMinY = ((iResolution.y - 50.0f) - 20.0f) /iResolution.y;\n    float eyeOffsetMaxY = (iResolution.y - 50.0f)/iResolution.y;\n    if(eyeOffsetMinX < abs(centredX) && abs(centredX) < eyeOffsetMaxX\n      && eyeOffsetMinY < uv.y && uv.y < eyeOffsetMaxY)\n    {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    \n    // draw X pad\n    if(fragCoord.x < eyeWidth)\n    {\n        fragColor = texture(iChannel0, uv);\n    }\n\t\n    float xOffset = fragCoord.x;\n    \n    \n      \n    // add z to x for new colour position\n    float newDepth;\n    while(xOffset >= eyeWidth)\n    {\n        newDepth = 0.0f;\n        vec2 pixelPos = vec2(xOffset / iResolution.x,uv.y);\n        newDepth = GetDepth(rect1, pixelPos, newDepth);\n        newDepth = GetDepth(rect2, pixelPos, newDepth);\n        newDepth = GetConeDepth(vec2(0.5,0.5), pixelPos, newDepth);\n        \n        xOffset = GetXOffset(xOffset, newDepth, eyeWidth);\n    }\n    vec2 finalUV = vec2(xOffset, fragCoord.y) / iResolution.xy;\n    // Output to screen\n    fragColor = texture(iChannel0, finalUV);\n    \n    vec2 prevRect = uv + vec2((eyeWidth-rect2.z) / iResolution.x, 0);\n    \n    //if(RectContains(rect2, uv))\n    //    fragColor.r += 0.3f;\n    //if(RectShiftLeftContains(rect2, uv, eyeWidth))\n    //    fragColor.r += 0.3f;\n    //if(RectShiftRightContains(rect2, uv, eyeWidth))\n    //    fragColor.r += 0.3f;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// random distribution stolen from https://www.shadertoy.com/view/4ssXRX\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float o = n1rand(uv);\n    float o2 = n1rand(uv + vec2(1.0f,0.0f));\n    float o3 = n1rand(uv + vec2(0.0f,1.0f));\n    fragColor = vec4(o,o2,o3,1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}