{"ver":"0.1","info":{"id":"ftcyzM","date":"1659998844","viewed":75,"name":"rm_5","username":"mleeteak13","description":"w","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["w"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nconst float PI = 3.14159;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat sphere(in vec3 p, in vec3 c, in float radius ){\n  \n\n    return length( p - c ) - radius;\n}\n\nfloat smoothabs(in float x) {\n  if (x  <= -1.0|| x >= 1.0) {\n    return abs(x);\n  }\n  return cos(x * PI);\n}\n\nfloat objects(in vec3 p){\n    //float px = step(.5, p.x);\n    p.x = smoothabs(p.x);\n   \n    float disp = sin(5. * p.x - iTime) * sin(4.0 * p.y + iTime  ) * cos(5.0 * p.z + iTime) * 0.5;\n    float sphere1 = sphere(p,vec3(0.),1.);\n    \n    return sphere1 + disp;\n}\n\nvec3 normal(in vec3 p){\n\n    const vec3 unit = vec3(.01,0.,0.);\n    float x = objects(p + unit.xyy) - objects(p - unit.xyy);\n    float y = objects(p + unit.yxy) - objects(p - unit.yxy);\n    float z = objects(p + unit.yyx) - objects(p - unit.yyx);\n    \n    vec3 normal = vec3(x,y,z);\n    \n    return normalize(normal);\n}\n\n\nvec3 raymarch(in vec3 ro, in vec3 rd){\n    float tDist = 0.;\n    const int steps = 32;\n    const float minT = .001;\n    const float maxT = 1000.0;\n    \n    for (int i = 0; i < steps; i++){\n        vec3 currentPos = ro + tDist * rd;\n        float distClosest = objects(currentPos);\n        \n        if(distClosest < minT){\n            vec3 _normal = normal(currentPos);\n            float sinTime = sin(iTime)*.5;\n            float cosTime = cos(iTime)*.5;\n            vec3 lightPos = vec3(0.1,0.5,2.);\n            vec3 lightDir = normalize(currentPos - lightPos);\n            float diffuse = max(0.,dot(_normal, lightDir));\n            return vec3(1.,1.,1.) * diffuse;\n        }\n        \n        if(distClosest > maxT){\n            break;\n        }\n        \n        tDist += distClosest;\n    \n    }\n    \n    return vec3(0.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 camPos = vec3(0.,0.,-3.);\n    vec3 rayDir = vec3(uv,1.0);\n    \n    vec3 result = raymarch(camPos, rayDir);\n\n\n    fragColor = vec4(result,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}