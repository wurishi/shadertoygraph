{"ver":"0.1","info":{"id":"lcsGDB","date":"1703496099","viewed":31,"name":"Rainbow Cubes","username":"JumaGFX","description":"My first ever 3D shader I hope you like it I enjoyed learning a ton of stuff. Still I think im missing some stuff here and there but I managed to make this so im happy!\nScene items contain 1 Plane, 1 Sphere, repeating boxes. Lighting as well!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","rays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//NOTE: THIS WAS ORIGNALLY DONE ON UNITY AND MOVED OVER TO SHADERTOY FOR FUN!\n//THIS IS ALSO NOT OPTIMIZED!\n#define DEBUG 0.0\n//#define DEBUG 0.0 = FOR FULL IMAGE\n//#define DEBUG 1.0 = FOR VIEWING NORMALS & \"DEPTH BUFFER\"\n//MAC = PRESS (CMD + ENTER) TO COMPILE AFTER CHANGING DEBUG\n//WINDOWS = PRESS (ALT + ENTER) TO COMPILE AFTER CHANGING DEBUG\n\n//source\n#define PI 3.1415\n#define TAU 6.2831\n#define MAX_DIST 100.0\n#define MIN_SURF_DIST 0.001\n#define MAX_STEPS 100\n\n//palette by inigo quilez\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//sdf box inigo quilez\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//IMPORTANT: GET DISTANCE IS USED TO GET THE DISTANCE OF EVERYTHING IN THE SCENE, SO IF YOU WANT TO ADD MORE OBJECTS, YOU NEED TO ADD IT HERE.\n//THIS IS KEY WHEN UNDERSTANDING HOW RAYMARCHING ACTUALLY WORKS. The raymarching algortihim is so simple tbh but understanding distances is 10x more important.\nfloat GetDistance(vec3 distancePoint)\n{   \n    vec4 _SpherePos = vec4(0.,0.5,8.0,0.5);\n    vec3 sp = _SpherePos.xyz;\n    sp.x += sin(iTime*2.) * 2.;\n    //sp.z += sin(iTime*2.)+(iTime);\n    float dSphere = length(distancePoint - (sp)) - _SpherePos.w;\n    float dPlane = distancePoint.y;// REFERENCE NOTE 1 // for some reason i had a hard time understanding just (dPlane = distancePoint.y).\n    \n    distancePoint.z += iTime;\n    distancePoint.y += sin(distancePoint.z*4. + iTime*5.)*0.1;\n    vec3 q = fract(distancePoint)-0.5;\n    \n    q.z = mod(distancePoint.z, 0.3) - 0.15;\n    //q.y += sin(distancePoint.z *4. + iTime*1.) * 0.2 +0.2;//this causing the artifacting\n    \n\n    float dbox = sdBox(q,0.025 + vec3(float(cos((distancePoint.z*2.) + iTime*3.) * 0.05+0.05)));\n    \n    //float dbox = length(q - float3(0.01,0.01,0.01)) - 0.1;\n    \n\n    float distanceToScene = min(dbox,min(dSphere, dPlane));         //get min from the 2 objects so we dont step into something we dont want to.\n    //float distanceToScene = min(dSphere, dPlane);\n    \n    return distanceToScene; //distance to scene is the distance scalar from ANYTHING in the scene\n}\n\n\n//in order to get normals on complex objects that have a curve on them its fairly simple, you have to sample 2 points inifi close to each other and \n//draw a line between them, effectively the slope & then you get the normal from that line!\nvec3 GetNormals(vec3 p)\n{\n    float d = GetDistance(p);\n    vec2 e = vec2(0.001, 0);\n    \n    \n    vec3 normals = d - vec3(\n      GetDistance(p - e.xyy),\n      GetDistance(p - e.yxy),\n      GetDistance(p - e.yyx)\n    );\n    \n    \n        /*trying to understand how partial derivatives work, slightly missing how this gives you a correct normal vector\n        same as above but with partial derivatives\n        float df_dx = (d - GetDistance(p - e.xyy));\n        float df_dy = (d - GetDistance(p - e.yxy));\n        float df_dz = (d - GetDistance(p - e.yyx));\n        return normalize(float3(df_dx, df_dy, df_dz));\n        */\n\n        //ok now i kind of understand, after tons of images and desmos trials but a simple summary is to compare the distances of the shifted points (shifting the points means the whole sphere will move with it!) \n        //to the original points in the 4 quadrants. (the result from [original distance point] - [shifted distance point] is you get a x and y value that is the vector/correct color gradient to be used as the normal! ) \n        //here is a extremely bad drawing of what i was doing and figured it out? https://prnt.sc/DQRrOrAIYs1c i might still be wrong but the idea at least is in my head now. will revisit this later.\n        //Im not sure if my thinking is right but help is needed understanding partial derivatives and how you obtain normals with them. Any explanations in the comments would help.\n    return normalize(normals);\n}\n\n\n\nvec2 rot2D(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\n\n\nfloat rm (vec3 rayOrigin, vec3 rayDirection)\n{\n    float dO = 0.0; //Distance from Origin\n    float dS = 0.0; //Distance from Scene\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + rayDirection * dO;             // standard point calculation dO is the offset for direction or magnitude\n        //p.xy += rot2D(p.xy, p); //rotate the scene\n        //p.y += sin(p.z * 4. + iTime*3.)*0.1;\n        dS = GetDistance(p);                             \n        dO += dS;\n        if (dS < MIN_SURF_DIST || dO > MAX_DIST) break;            // if we are close enough to a surface or went to infinity, break & return distance to the origin\n    }\n    return dO;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec4 _LightPos = vec4(.0,7.,8.,8.);\n    _LightPos.xz += vec2(sin(iTime*2.),cos(iTime*2.))*_LightPos.w;\n    vec3 lightDir = normalize(_LightPos.xyz - p).xyz;\n    vec3 normal = GetNormals(p);\n\n    float dotNL = clamp(dot(normal, lightDir),0.,1.);\n    float d = rm(p + normal * (MIN_SURF_DIST * 2.), lightDir);\n    if (d < length(lightDir)) \n    {\n        dotNL *= smoothstep(0.9, 1., d / length(lightDir));\n        //dotNL *= 0.1;\n    }\n\n    return dotNL;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 cuv = uv * 2. - 1.;\n    vec4 _CameraOrigin = vec4(0.0,2.0,1.0,1.0);\n    vec3 ro = _CameraOrigin.xyz;\n    //ro.z += (iTime);\n    ro.xy += vec2(sin(iTime*0.5) * 2.,cos(iTime*1.) * 1.);\n\n    vec3 rd = normalize(vec3(cuv.xy,1));\n\n    rd.z += rot2D(rd.xy, iTime).x * 0.5;\n    rd.xy += rot2D(rd.xy, iTime) * 0.2;\n    rd = normalize(rd);\n\n    float distanceRM = rm(ro, rd);//i.camPos\n    //return (distanceRM)*0.01;\n\n    //if(distanceRM > MAX_DIST) return float4(0,0.4,0.8,1);//skybox\n    vec3 p = ro + rd * distanceRM;\n    //return float4(abs(p.rrr/50),1);\n    \n    vec3 tCol = palette(distanceRM + iTime*2.,vec3(0.7, 0.5, 0.5),vec3(0.5, 0.2, 0.9),vec3(1.0, 0.5, 0.3),vec3(0.09, 0.33, 0.67));\n    //fragColor = vec4(tCol,1);\n    \n    \n    vec3 light = vec3(GetLight(p));\n    //fragColor = vec4(light,1);\n    //return;\n\n    light -= (light * (distanceRM*0.05));\n    light += (distanceRM*0.04) + tCol.xyz;\n    vec3 diff = GetNormals(p); //test normals\n\n\n    if(cuv.x < (1. - DEBUG)){ \n        fragColor = vec4(light * vec3(1,1,1),1);\n        return;\n    } else {\n        if(cuv.y < 0.){fragColor = vec4(diff,1.); return;}\n        fragColor = vec4(vec3((distanceRM*0.01)),1.);\n        return;\n    }\n\n            \n}\n","name":"Image","description":"","type":"image"}]}