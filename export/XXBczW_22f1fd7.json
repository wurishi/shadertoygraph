{"ver":"0.1","info":{"id":"XXBczW","date":"1727023938","viewed":70,"name":"Klein bottle 简单克莱茵瓶","username":"shadertoyjiang","description":"It took a lot of time, but the results were not ideal, the lines were uneven, and artifacts were visible in special cases. Some incomplete processing is already very much affecting the speed.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["klein","bottle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2231 克莱茵瓶简单 2328\n#define background 1\n#define NEAR 0\n#define TAU 6.2831853\n#define PI 3.1415926535\n#define rot(t) mat2(cos(t),-sin(t),sin(t),cos(t));\n       \n\nfloat tclr;\nbool ctxt;\n\nvoid ctxtclr(vec2 txt){\n        \n        txt *= vec2(20., 40.);\n        txt -= round(txt);\n        txt = abs(txt);\n        float d = min(txt.x, txt.y);\n        tclr = clamp(1.*exp(-50.*d), 0., 1.);\n}\n\nfloat klein(vec3 p)\n{\n        float R = 1.,\n              r = .3;\n        float e = .03;\n        vec2 ta,tb;// 纹理用\n        vec2 f = p.xy - R;\n        if(f.x<0. && f.y<0. && f.y>-R-R)f.y=-R-R-f.y;\n        vec2 a = vec2(length(f)-R, p.z);\n        if(ctxt){\n                ta.x = atan(a.y, a.x); // -.5 到 .5  环向\n                ta.y = atan(f.y, f.x); // 接点 .5, 另一端-.5\n                ta.y = PI-ta.y; // 向上为正\n        }\n        float d1 = length(a)-r; // d1 没求边界，没看到伪影\n        //d1 = min(d1,  e+ abs(-R-p.y));\n        //d1 = min(d1,  e+ abs(p.y-R));\n        \n        float d2 = 9999.;\n        \n        if(ctxt)tb.x = atan(p.z, p.x); // 环向\n        vec2 u = vec2(length(p.xz), p.y);\n        f=u-R;\n        bool up = true;\n        if(f.y<-R)f.y += R+R, up=false;\n        if(f.x<0. && f.y<0.){\n                d2 = min(d2, abs(length(f)-(R-r)));\n                if(ctxt){\n                        tb.y = atan(f.y, f.x);\n                        if(up) tb.y = -(tb.y+PI)+4.*PI; \n                        else   tb.y = PI+PI+tb.y+PI;\n                }\n        }else{\n                d2 = min(d2, e+length(max(f, 0.))); // box\n        }\n        \n        f = u - vec2(R, r-R);\n        if(f.x>0.){\n                d2 = min(d2, abs(length(f)-R));\n                if(ctxt){\n                        tb.y = atan(f.y, f.x);\n                        tb.y = PI+PI+PI*.5+tb.y+PI*.5;\n                }\n        }else{\n                d2 = min(d2, -f.x+e);\n        }\n        \n        d2 = max(d2, -d1);\n        d1 = abs(d1);\n        d2 = abs(d2);\n        if(ctxt){\n        vec2 txt;\n                if(d1<d2)txt=ta+PI;\n                else     txt=tb;\n                txt /= vec2(PI*2., PI*4.);\n                ctxtclr(txt);\n        }\n        \n        //if(abs(d1+d2)<.04 && length(p-vec3(R,0,0))<R*55.5)tclr=1.;\n        return min(d1,d2)-1e-3;// 此处必须减去一个小数是为了防止法向量错误,它的两倍（厚度）要大于e\n}\n\nfloat map(vec3 p)\n{\n        float t = iTime-10.;\n        mat2 rot = mat2(cos(t),-sin(t),sin(t),cos(t));\n        p.yz *=rot(t*.3);\n        p.xz *=rot(t*.5);\n        p.xy *=rot(t*.7);\n        return klein(p);\n}\n\nvoid mainImage3(out vec4 O, vec2 U)\n{\n        float N = 66.,\n              E = 99.;\n        O = vec4(.05);\n        vec2 R = iResolution.xy,\n             u =  (U+U - R) / R.y;\n        float a = atan(u.y, u.x)/3.1415926535/2., r = length(u);\n        float t = iTime*.5, t1=sin(t)*2.+7., t0 = t*9.*0.;\n        \n        //float j =r*99.;// 斜边\n        float j = round( r*E); // 方块\n        float i = 1e-6 + j/E ;\n        \n        \n        //i=i*i*i; // 角速度\n        \n        \n        if((int(j)&1)==0)t1=-t1;\n        //t1*=cos(t);\n        a = a *N- round(a*N); // 多辐条\n        \n        float d = (a-.3+t0-t1*sqrt(1./i))*r;\n        \n        d -= round(d/r)*r;\n        \n        if(abs(d)<.05){\n                O++;\n        \n                if((int(j)&1)==0)O.z-=.3;// 颜色错觉\n        }\n}\n\n\nvoid mainImage2(out vec4 O, vec2 U)\n{\n        float N = 4., \n              M = 3.;\n        vec2 R = iResolution.xy,\n             u = 2.*  (U+U - R) / R.y ;\n        float a = atan(u.y, u.x)/TAU, r = length(u);\n        \n        float i = round(r*M)/M;\n        float dy = .5/M-abs(r-i);\n        \n        float x = M*i*a+iTime*(fract(sin(i*123.)*53.54567)-.5);\n        float j = round(x*N)/N;\n        float dx = (.5/N-abs(x-j))*r/i;\n        \n        float d = min(dx,dy*M/N);\n        d = min(d, length( vec2(r-i,(x-j)*r/i )));\n        \n        O = .4-vec4( 5.*exp(-8.* abs(sin(d*100.))));\n        O.x += exp(-80.*d);\n}\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n        vec4 bk;\n        O = vec4(0.3);\n        #if background==0\n                \n        #elif background==1\n        mainImage3(bk, v);bk*=2.3;\n        #elif background==2\n        mainImage2(bk, v);\n        #endif\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,      // 实际坐标\n             m = 1. * (iMouse.xy*2. - R) / R.y;// 实际鼠标\n        #if NEAR==1\n        vec3 o = vec3(0, 0, -3.),               // 眼睛坐标\n             r = normalize(vec3(u, .7)),        // 射线\n        #else\n        vec3 o = vec3(0, 0, -6),               // 眼睛坐标\n             r = normalize(vec3(u, 2)),\n        #endif\n             e = vec3(0, 1e-3, 0),             // 微距\n             p,n,                                // 法向量\n             s = normalize(vec3(-1,2,-3));     // 太阳\n        \n        float d,t,f,g,c,xi=1.;\n        ctxt=false;\n        for(int i;i<256 && t < 15.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        //O *= 0.;\n                        ctxt=true;\n                        float a = map(p+e);\n                        ctxt=false;\n                        n = normalize(vec3(map(p+e.yxx),a,map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3;//+g*g; // 665.352.6.542.9958.8.63\n                        O += O*(c+tclr)*xi;\n                        xi *=.25;\n                        bk=bk*.25;\n                        d =.2;\n                        //break;\n                }\n                t += d ;\n        }\n        //O *= 3.;\n        O += bk*.1;\n}\n\n\n\n\n\n\n\n/*\n// 2231 克莱茵瓶简单\nfloat klein(vec3 p)\n{\n        float R = 1.,\n              r = .3;\n        \n        vec2 f = p.xy - R;\n        if(f.x<0. && f.y<0. && f.y>-R-R)f.y=-R-R-f.y;\n        vec2 a = vec2(length(f)-R, p.z);\n        float d1 = length(a)-r;\n        \n        float d2 = 9999.;\n        \n        vec2 u = vec2(length(p.xz), p.y);\n        f=u-R;\n        if(f.y<-R)f.y += R+R;\n        if(f.x<0. && f.y<0.){\n                d2 = min(d2, abs(length(f)-(R-r)));\n        }\n        \n        f = u - vec2(R, r-R);\n        if(f.x>0.)d2 = min(d2, abs(length(f)-R));\n        \n        d2 = max(d2, -d1);\n        d1 = abs(d1);\n        return min(d1,d2)-.001;\n}\n\n\nfloat map(vec3 p)\n{\n        float t = iTime;\n        mat2 rot = mat2(cos(t),-sin(t),sin(t),cos(t));\n        p.yz *=rot;\n        p.xz *=rot;\n        return klein(p);\n}\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n        O = vec4(0.5);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,      // 实际坐标\n             m = 1. * (iMouse.xy*2. - R) / R.y;// 实际鼠标\n        vec3 o = vec3(0, 0, -6),               // 眼睛坐标\n             r = normalize(vec3(u, 2)),        // 射线\n             e = vec3(0, 1e-3, 0),             // 微距\n             p,n,                                // 法向量\n             s = normalize(vec3(-1,2,-3));     // 太阳\n        \n        float d,t,f,g,c,xi=1.;\n        for(int i;i<256 && t < 15.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        O *= 0.;\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; // 665.352.6.542.9958.8.63\n                        O += c*xi;\n                        xi *= .9;\n                        d =.2;\n                }\n                t += d * .9 ;\n        }\n}\n*/\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}