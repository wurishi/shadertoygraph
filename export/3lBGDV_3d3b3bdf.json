{"ver":"0.1","info":{"id":"3lBGDV","date":"1561532911","viewed":610,"name":"study4_rainRuning","username":"firegump","description":"just leaning. original shader by BigWIngs. ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a,b,t)  smoothstep(a,b,t)\n\nfloat N(float t){\n\treturn fract(sin(t*3456.)*6547.);//make a random value 0 to 1;\n}\n\nvec4 N14(float t){\n\treturn fract(sin(t*vec4(123., 1024., 3456., 9564))*vec4(6547.,345., 8799., 1564.));//make a random value 0 to 1;\n}//make a radom vec4 value\n\nstruct ray{//it's like creating your own value type.\n\tvec3 o, d;\n};\n    ray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n        ray a;\n        a.o = camPos;\n        \n        vec3 f = normalize(lookat - camPos);\n        vec3 r = cross(vec3(0.,1,0.), f);\n        vec3 u = cross(f, r);//zoom is the distance of camera to screen,.\n        vec3 c = a.o +  f* zoom;    //center of screen point, f is normalized\n        vec3 i = c + uv.x * r + uv.y * u;\n        a.d = normalize(i - a.o);//distance of ray from focus to screen.\n        return a;\n    \n    }\nvec3 ClosestPoint(ray r, vec3 p){//the point closest to the ray\n\t//dot  the projection of vector into another one;\n\treturn r.o+ max(0., dot(p - r.o, r.d))*r.d;//max :Prevent negative results\n}\nfloat DistRay(ray r, vec3 p){\n\treturn length(p - ClosestPoint(r, p));\n}\nfloat Bokeh(ray r, vec3 p, float size, float blur){\n    \n    float d = DistRay(r , p);\n    size *= length(p - r.o);\n    float c = S(size , size*(1. - blur) , d);//size(1 - blur)  normalize blur to (0, 1)\n\tc *= mix(.6 , 1., S(size*.8, size, d));//mix: mix two values as alpha;\n    return c;\n}\nvec3 StreetLights(ray r, float t, float roadWith){\n\n    float side = step(r.d.x, 0.);//x<0 return 0,x>0,return 1;\n    r.d.x = abs(r.d.x);\n    const float s = 1./ 10.;//s has to be a constant, represent a quantity\n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float ti = fract(t + i + side*s*.5 );//let two side have different velocities;\n        vec3 p = vec3(roadWith , 3.5 , 100.- ti*100.);\n        m += Bokeh(r, p, .05, .1)*ti*ti*ti;//x^n can make curve flatter;\n    }\n    \n    \n    return  vec3(1., .7, .3) *m;\n}\n\nvec3 EnvLights(ray r, float t, float roadWith){\n\n    float side = step(r.d.x, 0.);//x<0 return 0,x>0,return 1;\n    r.d.x = abs(r.d.x);\n    const float s = 1./ 4.5;//s has to be a constant, represent a quantity\n    \n    vec3 c = vec3(0.);\n    \n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float ti = fract(t + i + side*s*.5 );//let two side have different velocities;\n        vec4 n = N14(i + side*100.);// make different\n        \n        float fade = ti*ti*ti;\n        \n        float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;// make the shop light blink\n        \n        fade = occlusion;\n        \n        float x = mix(2.5, 10., n.x);\n        float y = mix(.1, 1.5, n.y);\n        vec3 p = vec3(roadWith + x ,y , 70.- ti*70.);//light start point  is 50\n        \n        vec3 col = n.wzy;\n            \n        c += Bokeh(r, p, .05, .1)*fade*col*.5;//x^n can make curve flatter;\n    }\n    \n    \n    return  c;\n}\n\n\nvec3 HeadLights(ray r, float t, float roadWith){\n\n    t *= 2.;//make car faster than street lamp\n    float w1 = .25;//light width\n    float w2 = w1*1.2;\n    const float s = 1./ 10.;\n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float n =N(i);\n        \n        if(n > .345) continue;//jump to top,cut % light\n        \n        float ti = fract(t + i);\n        float z =  100.- ti*100.;\n        //fract(t + i), if i=.9,fract's value will rise to 1 in short time\n        float fade = ti*ti*ti*ti;\n        float focus = S(.8, 1., ti);\n        float size = mix(.05, .03, focus);\n        roadWith *= -.3;\n        \n        m += Bokeh(r, vec3(roadWith -1.-w1, .15 ,z ), size, .1)*fade;\n        m += Bokeh(r, vec3(roadWith -1.+w1, .15 ,z ), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(roadWith -1.-w2, .15 ,z ), size, .1)*fade;//extra light effect\n        m += Bokeh(r, vec3(roadWith -1.+w2, .15 ,z ), size, .1)*fade;\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(roadWith -1.-w2, -.15 ,z ), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(roadWith -1.+w2, -.15 ,z ), size*3., 1.)*fade;\n        \n        m += ref*focus;\n        \n    }\n    \n    \n    return  vec3(.9, .9, 1.) *m;\n}\n\nvec3 TailLights(ray r, float t, float roadWith){\n    \n\tt *= .25;\n    float w1 = .25;//light width\n    float w2 = w1*1.2;\n    const float s = 1./ 10.;\n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float n =N(i);\n        \n        if(n > .5) continue;//jump to top,cut % light\n         \n        float lane = step(.25,n);//n = 0~ .5\n        \n        float ti = fract(t + i);\n        float z =  100.- ti*100.;\n        //fract(t + i), if i=.9,fract's value will rise to 1 in short time\n        float fade = ti*ti*ti*ti;\n        float focus = S(.8, 1., ti);\n        float size = mix(.05, .03, focus);\n        \n        float laneShift = S(.99, .95, ti);\n        float x = 1.5 - lane*laneShift;//control rightside car'lan\n        roadWith *= .3;\n        \n        float blink = step(0. ,sin(t*500.))*7.*lane*step(.96,ti);//return 0 | 7 lane control witch car blink\n        //step(.96,ti), car at far point ti = 0, instead close poing ti = 1,\n        m += Bokeh(r, vec3(roadWith + x - w1, .15 ,z ), size, .1)*fade;\n        m += Bokeh(r, vec3(roadWith + x + w1, .15 ,z ), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(roadWith + x - w2, .15 ,z ), size, .1)*fade;//extra light effect\n        m += Bokeh(r, vec3(roadWith + x + w2, .15 ,z ), size, .1)*fade*(1. + blink);//1|8 right taillight\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(roadWith + x - w2, -.15 ,z ), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(roadWith + x + w2, -.15 ,z ), size*3., 1.)*fade*(1. + blink*.1);\n        \n        m += ref*focus;\n        \n    }\n    \n    \n    return  vec3(1., .1, .03) *m;\n}\n\nvec2 Rain(vec2 uv, float t){\n    \n    \n    t *= 40.;\n    \n    vec2 a = vec2(3.,1.);\n    \n    vec2 st = uv*a;\n    st.y += t*.22;\n    \n    vec2 id = floor(st);//in same rect,make same id,seems like 11,21,31,41\n    \n    float n = fract(sin(id.x*76.34)*768.34);\n    st.y += n;  //make different rhythm,offset y eath box\n    id = floor(st); //initialize  id\n    st = fract(st)-.5;//movepoint to center\n    \n    t += fract(sin(id.x*76.34 + id.y*1453.7)*768.34)*6.283;//make per rect different time \n    //same id t plus value is same. multiply 2π,the reason : t is use to sin function\n    \n    float y = - sin( t + sin(t + sin(t)*.5 )) *.43;//water drop animation\n    vec2 p1 = vec2(0. , y);\n    vec2 o1 = (st - p1)/a;\n    float d = length(o1);\n    \n    float ml = S(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*a.x*vec2(1.,2.)) - .5)/vec2(1.,2.);\n    d = length(o2);//*vec2 change the y coordnate to create more drop\n    \n    float m2 = S(.3*(.5-st.y), .0, d)*S(-.1, .1, st.y - p1.y);\n    //if st.y>p1.y，return 1,else return 0, so can hide the point under of p1.\n    //5-st.y  scale by y\n    \n    //if(st.x > .46|| st.y > .49) ml = 1.;//debug line\n    \n\treturn vec2(ml*o1*30.+ m2*o2*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    float screenScale = iResolution.x/iResolution.y;\n    uv.x *= screenScale ;\n    \n  \tfloat g = S(0.,.5,.3*length(uv*vec2(1.,1.5)));\n    g *= g;\n    vec2 GM = g*uv*.2;//convex lens\n   \n\t    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.07+ m.x*.3;//if pause,can control time by moving mouse;\n    \n    float rt = t*230.;//run speed\n    float cameAnima = cos(rt)*.025;\n    float runRhythm = clamp(0.,3.,sin(rt + sin(rt+sin(rt)*.5)))*.03;\n    //the peak is to the left sine,move up quikly and down slowly,\n    //clamp is just let he stay at ground a moment\n    \n    float runSideId =  step(0.,sin(rt*.5));\n    \n    vec3 camPos = vec3(.5 + cameAnima * runSideId ,.2 + cameAnima, 0.);\n    vec3 lookat = vec3(.5 , .2+runRhythm , 1.);\n    \n    \n    //uv.x += sin(uv.y*40.)*.1;\n    vec2 rainDistort = Rain(uv*5. , t)*.5;\n    rainDistort += Rain(uv*7. , t)*.3;\n    \n    uv.x += sin(uv.y*70.)*.003;\n    uv.y += sin(uv.x*70.)*.003;\n    \n    ray r = GetRay(uv - rainDistort*.5 - GM, camPos, lookat, 2.);// - refract other  side\n   \n\t\n    \n    float roadWith = 4.2+ (.5 + sin(t/2.)*.5);// road width\n    \n    vec3 col = StreetLights(r, t, roadWith);\n    col += HeadLights(r, t, roadWith);\n    col += TailLights(r, t, roadWith);\n    col += EnvLights(r, t, roadWith);\n    \n    \n        \n    col += (r.d.y + .55)*vec3(.2,.1,.5)*.3;//sky color\n    //col = vec3(0.);\n    col += (S(.0,.5,r.d.y)*1.3)*vec3(.9,.2, .1)*.5;//sky color 2\n    \n    \n   \n    //col = vec3(g);\n    //col = vec3(rainDistort, 0.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}