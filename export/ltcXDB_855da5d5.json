{"ver":"0.1","info":{"id":"ltcXDB","date":"1481416280","viewed":241,"name":"raymarching - glitching","username":"generateme","description":"ray marching errors test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ray marching glitches\n// some parts taken from IQ\n\n#define STEPS 100 // ray marching steps, try 1 - 100\n#define LSTEPS 50 // shadow steps, try 5 - 100\n#define SHADOW_SOFT 4.0 // try 1.0 - 32.0\n#define OCCLUSION_DECAY 0.76 // -0.99 - 0.99\n#define UNION 1 // 1 = union, 0 = subtract\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\n\nfloat map(in vec3 p) {\n\tfloat dd =  0.03*(sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z));\n    vec3 d = p + vec3(dd,dd,dd);\n    float r = 0.0;\n    if(UNION==1) {\n    \tr = opU( sdBox(d, vec3(2.5, 2.5, 2.5)), sdSphere(d, 3.4));\n    } else {\n    \tr = opS( sdBox(d, vec3(2.5, 2.5, 2.5)), sdSphere(d, 3.4));\n    }\n    return min((p.y+1.0),r);\n}\n\n//----------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.3*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += (hr-dd)*sca;\n        sca *= OCCLUSION_DECAY;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.001;\n    float tmax = 20.0;\n        \n\tfloat precis = 0.0001;\n    float t = tmin;\n    for( int i=0; i<STEPS; i++ )\n    {\n\t    float res = map( ro+rd*t );\n        if(i==0) res *= 0.3;\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n   \tif(t>tmax) t=-1.0;\n    return t;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<LSTEPS; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, SHADOW_SOFT*h/t );\n        t += h;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    float t = castRay(ro,rd);\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tcol = vec3(0.85,0.80,0.204);\n\n\t\tvec3  lig1 = normalize( vec3(-2.0,1.0,0.0) );\n        vec3  lig2 = normalize( vec3(0.0,4.5,4.0) );\n        \n        float dif1 = dot(nor,lig1);\n        float dif2 = dot(nor,lig2);\n        \n        float sha1 = softshadow( pos, lig1, 0.01, 20.0 );\n        float sha2 = softshadow( pos, lig2, 0.01, 20.0 );\n\n        float dif = 0.5 * (dif1*sha1 + dif2*sha2);\n        \n        float ao = calcAO(pos,nor);\n\t\tcol = col*ao*dif*1.6;\n\n    \tcol = mix( col, vec3(0.91,0.86,0.796), 1.0-exp( -0.001*t*t ) );\n\n    } else col = vec3(0.91,0.86,0.796);\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -2.0+4.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    float st = sin(iTime)*4.0;\n    float ct = cos(iTime)*4.0;\n    vec3 ro = vec3(st,3.5,ct);\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, vec3(0.0, 0.0, 0.0), 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,1.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.8) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}