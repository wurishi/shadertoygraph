{"ver":"0.1","info":{"id":"MfscWH","date":"1721149177","viewed":47,"name":"LoudSpeakers","username":"_TAU_","description":"pumping loudspeakers","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rave","loudspeaker"],"hasliked":0,"parentid":"X3cXRH","parentname":"Ray Marching Engine Easy"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV =  0.9;\nconst int MAX_STEPS = 256;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.001;\nconst float BLUR = .0001;\nconst float BASE = .05;\n\n\nfloat Rays(vec2 uv, float ray_amp, float ray_freq, float wiggle_speed, float rotation, float freq){\n    float d = length(uv);\n    float theta_rot = ray_amp * sin(ray_freq * d +  wiggle_speed * iTime);\n    theta_rot += iTime * rotation;\n    pR(uv, theta_rot);\n    float col = cos(freq * acos(uv.x / d ));\n    return smoothstep(BASE-BLUR,BASE+BLUR,col); \n}\n\nfloat frac(float v)\n{\n    return v - floor(v);\n}\n\nfloat spiral(vec2 uv, float ecc_x, float ecc_y, float zoom_in, float thickness, float ccw){  \n    float d = length(uv);\n    float theta = atan( ecc_y * uv.y, ecc_x * uv.x) / 6.28; \n    // time varying pixel color\n    float col = frac(d / zoom_in - theta + sign (ccw) * iTime);\n    return smoothstep(BASE-BLUR+.2,BASE+BLUR+.2,col);\n}\n\nvec3 drawBackground(vec2 uv){\n    \n    // Rays params\n    float ray_amp = 0.03;\n    float ray_freq = -22.;\n    float wiggle_speed = 8.;\n    float rotation = 0.19;\n    float freq = 13.;\n    //spiral params\n    float ecc_x_mov = 1.3 + 0.5 * sin(iTime) + 0.5 * sin(iTime) * sin(iTime); \n    float ecc_y_mov = 1.3 + 0.5 * cos(iTime) + 0.5 * cos(iTime) * cos(iTime);\n    float zoom_in = 0.4 + 0.05 * (sin(0.1 * iTime) + sin(iTime) + sin(0.8 *iTime));\n    float thickness = 2.8;\n    float radial_pos = 0.3;\n    float radial_pos_delta = 0.05;\n    \n    float col = Rays(uv, ray_amp, ray_freq, wiggle_speed, rotation, freq);\n    \n    // do foreground spiral\n    float r = length(vec2(uv.x, uv.y));\n    if(r < radial_pos ){\n        if(r < radial_pos - radial_pos_delta){\n          col = spiral(uv, ecc_y_mov, ecc_x_mov, zoom_in, thickness, -1.0); \n        }else{\n          col = 0.0;\n        }\n    }\n    \n    return vec3(col);\n}\n\nvec2 loudspeakerDist(vec3 p){\n\n    // Louspeaker body\n    float box = fBox(p, vec3(1., 2., .5));\n    \n    //loudspeaker hole\n    vec3 p_hole = p + vec3(0.,0.,0.8);\n    pR(p_hole.yz, PI/2.);\n    float hole = fCylinder(p_hole, 0.8, 2.);    \n\n    //loudspeaker cone\n    vec3 p_cone = p + vec3(0., 0., 0.53 + 0.03*sin(15.*iTime));\n    pR(p_cone.yz, PI/2.);\n    float coneDist = fCone(p_cone, 0.8, 0.3);\n    \n    vec3 p_cone_hole = p_cone + vec3(0.,.01, 0.);\n    float coneHoleDist = fCone(p_cone_hole, 0.7, 0.3);\n    float cone = opSubtraction(coneHoleDist, coneDist);\n    \n    //loudspeaker bulb\n    vec3 p_bulb = p + vec3(0., 0., 0.25 + 0.05*sin(15.*iTime));\n    float bulb = length(p_bulb) - .25;\n    \n    //loudspearer rim\n    vec3 p_torus = p + vec3(0.,0.,0.52);\n    pR(p_torus.yz, PI/2.);\n    float rim = fTorus(p_torus, vec2(0.8,0.05));\n\n    //loudspeaker tweeter hole\n    vec3 p_tweet = p * vec3(1.,1.,0.1) + vec3(0., -1.4, 0.5);    \n    float tweet = fBox(p_tweet, vec3(0.6, 0.25, 0.51));\n\n    // result\n    float ls_dist = opSubtraction(hole, box);\n    ls_dist = opUnion(ls_dist, cone);\n    ls_dist = opUnion(ls_dist, rim);\n    ls_dist = opUnion(ls_dist, bulb);\n    ls_dist = opSubtraction(tweet, ls_dist);\n    \n    return vec2(ls_dist, 1.0);\n}\n\n\nvec2 map(vec3 p){\n// this function contains the distance functions of all objects and returns the closest one\n// using the union operator\n\n    // plane \n    float planeDist = fPlane(p, vec3(0., 1., 0.), 1.);\n    float planeID = 2.0;\n    vec2 plane = vec2(planeDist, planeID);\n    \n    float spacing = 3.;\n    vec2 loudspeaker1 = loudspeakerDist(p + vec3(spacing,0.,0.));\n    vec2 loudspeaker2 = loudspeakerDist(p + vec3(-spacing,0.,0.));\n    \n    vec2 res = fOpUnion(plane, loudspeaker1);\n    res = fOpUnion(res, loudspeaker2);\n    return res;\n    \n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n// the rayMarch function returns a 2-dimensiona vector object in order to store\n// the distance to the object in the X component, and get the object ID ( it's color) \n// in the Y component\n    vec2 hit, object;\n    for(int i = 0; i < MAX_STEPS; i++){\n        // march the ray p ...\n        vec3 p = ro + object.x * rd;\n        // and compute distance from the objects\n        hit = map(p);\n        // update distance from the objects and ID\n        object.x += hit.x;\n        object.y = hit.y;\n        // stop is object is hit ( really small distance ) or ray has travelled to far away\n        if(abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 color){\n// Lighting model based on the Lambert Law: \n// amount of reflected light is proportional to the scalar product of the vector\n// directed to the light source and the normal to the surface\n    vec3 lightPos = vec3(0., 20., -20.);\n    vec3 L = normalize(lightPos - p); // vector from surface element directed to the light source\n    vec3 N = getNormal(p);  \n    \n    // return N; //check normals\n    // compute the Lambert Law\n    vec3 diffuse = color * clamp(dot(L, N), 0.0, 1.0);\n    \n    // shadows\n    float d = rayMarch(p + N * 0.02, normalize(lightPos)).x; // cast ray from surface point p towards the light and get distance\n    // if the distance travelled from p to the ligth is lower that the distance from the point to the light, it means we've hit an object\n    // which is obstructing the light, so we cast a shadow for point p\n    if (d < length(lightPos - p)) return vec3(0.0);\n    \n    return diffuse;\n}\n\nvec3 getMaterial(vec3 p, float id) {\n// Gives the color based on the ID of the hit object\n    vec3 m;\n    switch (int(id)) {\n        case 1:\n        m = vec3(0.1, 0.1, 0.1); break;\n        case 2:\n        m = vec3(1.); break;\n    }\n    return m;\n}\n\nvoid render(inout vec3 col, in vec2 uv){\n    // sets ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    // sets ray directionS -> points towards xy plane \n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    vec2 object = rayMarch(ro, rd);\n    \n    vec3 background = drawBackground(uv);\n    \n    if(object.x < MAX_DIST){\n        vec3 p = ro + object.x * rd;\n        vec3 material = getMaterial(p, object.y);\n        col += getLight(p, rd, material);\n        float blur = .0001;\n        float base = .05;\n        col = smoothstep(BASE-BLUR,BASE+BLUR,col); \n    }else{\n        col = background;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (x,y in (-1,1))\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) /iResolution.y;\n\n    vec3 col;\n    \n    //AA setting\n    int aa_factor = 2;\n    \n    // Supersampling - nxn grid within each pixel\n    for(int x = 0; x < aa_factor; x++) {\n        for(int y = 0; y < aa_factor; y++) {\n            // Offset for each sample - shifts within the pixel grid\n            vec2 offset = vec2(x, y) * (1. / float(aa_factor)) / iResolution.y;\n            // Adjusted UV for current sample\n            vec2 sampleUV = uv + offset;\n            // Render scene for this sample\n            vec3 sampleColor;\n            render(sampleColor, sampleUV);\n            col += sampleColor;\n        }\n    }\n\n    // Average the color from the samples\n    col /= float(aa_factor * aa_factor);\n    \n    // gamma correction -- needed to adjust the lighting (make all brighter)\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat fTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 fOpUnion(vec2 res1, vec2 res2){\n// returns the closestbetween 2 objects ( distance and ID ) \n    return (res1.x < res2.x) ? res1 : res2;\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             2D GRAPHICS\n//\n////////////////////////////////////////////////////////////////\n\n//TRANSFORMS\nvec2 rotate(vec2 pos, float theta){\n    pos.x = pos.x * cos(theta) - pos.y * sin(theta);\n    pos.y = pos.x * sin(theta) + pos.y * cos(theta);\n    return pos;\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}