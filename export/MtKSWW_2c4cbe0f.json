{"ver":"0.1","info":{"id":"MtKSWW","date":"1494722632","viewed":5833,"name":"Dynamism","username":"nimitz","description":"Buffer A is the fbm noise gradient generation\nBuffer B is the exact same thing\nBuffer C is the divergence calculator and coloring\nBuffer D is radial blur","likes":233,"published":1,"flags":32,"usePreview":0,"tags":["procedural","noise","fbm","gradient","divergence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Dynamism by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MtKSWW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tMostly about showing divergence based procedural noise, the rest is just me\n\tplaying around to make it somewhat interesting to look at.\n\n\tI stumbled upon this new form of noise while playing with noise gradients\n\tand noise diverengence. First generate more or less standard fbm (with high decay)\n\tthen compute the gradient of that noise (either numerically or analytically) and \n\tthen compute the divergence of the gradient and you get the noise you see here.\n\n\tAs you can see it has a very \"DLA\" look to it. It is also very easy to animate as\n\tyou can simply offset the noise fetches inside the initial fbm generation and produce\n\tgood looking animated noise. I did some\ttesting and the paremeters can be modified \n\tto result in a decent variety of output\tnoises, altough still somewhat similar than\n\twhat is seen here.\n\n\tI have not tested it yet, but this method should extend to 3D without issues\n\tand should result in interesting volumes.\n\n\tThis shader used to run at 60fps with webGL 1 but since webGL it seems\n\tcapped at 30fps on my test computer.\n*/\n\nconst vec2 center = vec2(0,0);\nconst int samples = 15;\nconst float wCurveA = 1.;\nconst float wCurveB = 1.;\nconst float dspCurveA = 2.;\nconst float dspCurveB = 1.;\n\n#define time iTime\n\nfloat wcurve(float x, float a, float b)\n{\n    float r = pow(a + b,a + b)/(pow(a, a)*pow(b, b));\n    return r*pow(x, a)*pow(1.0 - x, b);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\n    vec2 center= mo;\n    center = vec2(0.5,0.5);\n    \n    vec3  col = vec3(0.0);\n    vec2 tc = center - p;\n    \n    float w = 1.0;\n    float tw = 1.;\n    \n    float rnd = (hash21(p)-0.5)*0.75;\n    \n    //derivative of the \"depth\"\n    //time*2.1 + ((1.0+sin(time + sin(time*0.4+ cos(time*0.1)))))*1.5\n    float x = time;\n    float drvT = 1.5 * cos(x + sin(0.4*x + cos(0.1*x)))*(cos(0.4*x + cos(0.1*x)) * (0.4 - 0.1*sin(0.1*x)) + 1.0) + 2.1;\n    \n    \n    float strength = 0.01 + drvT*0.01;\n    \n    for(int i=0; i<samples; i++)\n    {\n        float sr = float(i)/float(samples);\n        float sr2 = (float(i) + rnd)/float(samples);\n        float weight = wcurve(sr2, wCurveA, wCurveB);\n        float displ = wcurve(sr2, dspCurveA, dspCurveB);\n        col += texture( iChannel0, p + (tc*sr2*strength*displ)).rgb*weight;\n        tw += .9*weight;\n    }\n    col /= tw;\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Dynamism by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MtKSWW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n\n#define time iTime\n#define time2 (time*2.1 + ((1.0+sin(time + sin(time*0.4+ cos(time*0.1)))))*1.5)\n#define time3 (time*1. + ((1.0+sin(time*0.9 + sin(time*0.34+ cos(time*0.21)))))*1.5)\n#define time4 (time*0.5 + ((1.0+sin(time*0.8 + sin(time*0.14+ cos(time*0.15)))))*1.2)\n\nvec2 hash(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return -1.0 + 2.0*fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//2D Simplex noise from iq: https://www.shadertoy.com/view/Msf3WH\nfloat noise(in vec2 p)\n{\n    p *= 0.45;\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(38.0) );\n\t\n}\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat fbm(in vec2 p, in vec2 of)\n{\t\n    p *= rot(time3*0.1);\n    p += of;\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i <9.;i++ )\n\t{\n        rz+= noise(p*rot(float(i)*2.3)+ time*0.5)/z;\n\t\tz *= 3.2;\n\t\tp *= 2.0;\n\t}\n\treturn rz;\n}\n\nvec2 grdf(in vec2 p, in vec2 of)\n{\n    vec2 ep = vec2(0.0,0.0005);\n    vec2 d = vec2(fbm(p - ep.yx, of) - fbm(p + ep.yx, of),\n                fbm(p - ep.xy, of) - fbm(p + ep.xy, of));\n    d /= length(d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 1.75;\n    \n    float t1 = mod(time2*0.35,4.);\n    float t2 = mod(time2*0.35 + 1.,4.);\n    \n    vec2 p1 = p*(4.0-t1);\n    vec2 p2 = p*(4.0-t2);\n    \n    vec2 fld = grdf(p1, vec2(time4*0.2,time*0.0));\n    vec2 fld2 = grdf(p2, vec2(time4*0.2,time*0.0) + 2.2);\n    \n    fragColor = vec4(fld, fld2);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Dynamism by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MtKSWW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define time iTime\n#define time2 (time*2.1 + ((1.0+sin(time + sin(time*0.4+ cos(time*0.1)))))*1.5)\n#define time3 (time*1. + ((1.0+sin(time*0.9 + sin(time*0.34+ cos(time*0.21)))))*1.5)\n#define time4 (time*0.5 + ((1.0+sin(time*0.8 + sin(time*0.14+ cos(time*0.15)))))*1.2)\n\nvec2 hash(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return -1.0 + 2.0*fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//2D Simplex noise from iq: https://www.shadertoy.com/view/Msf3WH\nfloat noise(in vec2 p)\n{\n    p *= 0.45;\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(38.0) );\n\t\n}\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat fbm(in vec2 p, in vec2 of)\n{\t\n    p *= rot(time3*0.1);\n    p += of;\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i <9.;i++ )\n\t{\n        rz+= noise(p*rot(float(i)*2.3)+ time*0.5)/z;\n\t\tz *= 3.2;\n\t\tp *= 2.0;\n\t}\n\treturn rz;\n}\n\nvec2 grdf(in vec2 p, in vec2 of)\n{\n    vec2 ep = vec2(0.0,0.0005);\n    vec2 d = vec2(fbm(p - ep.yx, of) - fbm(p + ep.yx, of),\n                fbm(p - ep.xy, of) - fbm(p + ep.xy, of));\n    d /= length(d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 1.75;\n    \n    float t3 = mod(time2*0.35 + 2.,4.);\n    float t4 = mod(time2*0.35 + 3.,4.);\n    \n    vec2 p3 = p*(4.0-t3);\n    vec2 p4 = p*(4.0-t4);\n    \n    vec2 fld = grdf(p3, vec2(time4*0.2,time*0.0) + 4.5);\n    vec2 fld2 = grdf(p4, vec2(time4*0.2,time*0.0) + 7.3);\n    \n    fragColor = vec4(fld, fld2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Dynamism by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MtKSWW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define time iTime\n\n#define time2v (((1.0+sin(time + sin(time*0.4+ cos(time*0.1)))))*1.5)\n#define time2 (time*2.1 + time2v)\n\n//Divergence\nvec2 div( vec2 p, sampler2D smp)\n{\n    vec2 tx = 1. / iResolution.xy;\n\n    vec4 uv =    textureLod(smp, p, -100.);\n    vec4 uv_n =  textureLod(smp, p + vec2(0.0, tx.y), -100.);\n    vec4 uv_e =  textureLod(smp, p + vec2(tx.x, 0.0), -100.);\n    vec4 uv_s =  textureLod(smp, p + vec2(0.0, -tx.y), -100.);\n    vec4 uv_w =  textureLod(smp, p + vec2(-tx.x, 0.0), -100.);\n\n   \tfloat div = uv_s.y - uv_n.y - uv_e.x + uv_w.x;\n    float div2 = uv_s.w - uv_n.w - uv_e.z + uv_w.z;\n    \n    return vec2(div, div2)*1.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec2 dv = div(p, iChannel0);\n    vec2 dv2 = div(p, iChannel1);\n    \n    dv = pow(abs(dv), vec2(.5))*sign(dv);\n    dv = clamp(dv,0.,4.);\n    dv2 = pow(abs(dv2), vec2(.5))*sign(dv2);\n    dv2 = clamp(dv2,0.,4.);\n    \n    float t1 = mod(time2*0.35,4.);\n    float t2 = mod(time2*0.35 + 1.,4.);\n    float t3 = mod(time2*0.35 + 2.,4.);\n    float t4 = mod(time2*0.35 + 3.,4.);\n    \n    const float ws = 1.1;\n    const float wof = 1.8;\n    \n    //derivative of the \"depth\"\n    //time*2.1 + ((1.0+sin(time + sin(time*0.4+ cos(time*0.1)))))*1.5\n    float x = time;\n    float drvT = 1.5 * cos(x + sin(0.4*x + cos(0.1*x)))*(cos(0.4*x + cos(0.1*x)) * (0.4 - 0.1*sin(0.1*x)) + 1.0) + 2.1;\n    \n    float ofsc = 0.8 + drvT*0.07;\n    float t1w = clamp(t1*ws + wof,0.,10.);\n    float t2w = clamp(t2*ws + wof,0.,10.);\n    float t3w = clamp(t3*ws + wof,0.,10.);\n    float t4w = clamp(t4*ws + wof,0.,10.);\n    \n    vec3 col = vec3(0);\n    \n    col += sqrt(t1)*vec3(0.28,0.19,0.15)*exp2(dv.x*t1w-t1w*ofsc);\n    col += sqrt(t2)*vec3(0.1,0.13,0.23)*exp2(dv.y*t2w-t2w*ofsc);\n    col += sqrt(t3)*vec3(0.27,0.07,0.07)*exp2(dv2.x*t3w-t3w*ofsc);\n    col += sqrt(t4)*vec3(0.1,0.18,0.25)*exp2(dv2.y*t4w-t4w*ofsc);\n    \n    col = pow(col, vec3(.6))*1.2;\n    col *= smoothstep(0.,1.,col);\n    \n    col *= pow(16.0*p.x*p.y*(1.0 - p.x)*(1.0 - p.y), 0.4);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}