{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Rendering shadows by sampling multiple rays from each pixel to an area source light\n// Uses a closest-point map to minimize the number of samples needed\n// Original inspiration: https://shadertoy.com/view/3tVfWc\n\nconst int MAX_SAMPLES = 40;\nconst int MAX_STEPS = 40;\nconst int LIGHT_SIZE = 20;\nconst float LIGHT_ATTENUATION_COEFFICIENT = 1.0;\n\nstruct Ray {\n    vec2 pos;\n    vec2 dir;\n};\n\n// returns true where an intersection of the scene occurs before the ray reaches the stop position\nbool ray_scene_intersect(in Ray ray, in vec2 stop_pos) {\n    // use different channels to lookup the closest point based in the direction\n    vec2 pos = ray.pos;\n    float scale = 1.0 / iResolution.y;\n\n    if (ray.dir.x >= 0.0) {\n        if (ray.dir.y >= 0.0) {\n            // top right\n            for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n                ivec2 cell_pos = ivec2(floor(pos / scale));\n                ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).x);\n                float radius = length(vec2(step_amount)) * scale;\n                \n                if (pos.x > stop_pos.x && pos.y > stop_pos.y) {\n                    return false;\n                }\n\n                if (radius < scale) {\n                    // hit so stop\n                    return true;\n                }\n\n                // step along on the ray direction\n                pos += ray.dir * radius;\n            }\n        } else {\n            // bottom right\n            for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n                ivec2 cell_pos = ivec2(floor(pos / scale));\n                ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).y);\n                float radius = length(vec2(step_amount)) * scale;\n                \n                if (pos.x > stop_pos.x && pos.y < stop_pos.y) {\n                    return false;\n                }\n\n                if (radius < scale) {\n                    // hit so stop\n                    return true;\n                }\n\n                // step along on the ray direction\n                pos += ray.dir * radius;\n            }\n        }\n    } else if (ray.dir.y >= 0.0) {\n        // top left\n        for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n            ivec2 cell_pos = ivec2(floor(pos / scale));\n            ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).w);\n            float radius = length(vec2(step_amount)) * scale;\n\n            if (pos.x < stop_pos.x && pos.y > stop_pos.y) {\n                return false;\n            }\n\n            if (radius < scale) {\n                // hit so stop\n                return true;\n            }\n\n            // step along on the ray direction\n            pos += ray.dir * radius;\n        }\n    } else {\n        // bottom left\n        for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n            ivec2 cell_pos = ivec2(floor(pos / scale));\n            ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).z);\n            float radius = length(vec2(step_amount)) * scale;\n\n            if (pos.x < stop_pos.x && pos.y < stop_pos.y) {\n                return false;\n            }\n\n            if (radius < scale) {\n                // hit so stop\n                return true;\n            }\n\n            // step along on the ray direction\n            pos += ray.dir * radius;\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 1.0 / iResolution.y;\n    vec2 uv = fragCoord * scale;\n    \n    // if we are inside the scene then draw it\n    float scene = texture(iChannel0, uv).r;\n    if (scene > 0.5) {\n        fragColor = vec4(vec3(scene), 1.0);\n        return;\n    }\n    \n    // light\n    vec2 light_pos = vec2(0.5);\n    \n    if(length(iMouse.xy) > 0.0) {\n        light_pos = iMouse.xy * scale;\n    }\n    \n    float light_radius = float(LIGHT_SIZE) * scale;\n    \n    // cycle the light colour over time to make it more interesting\n    vec3 light_colour = clamp(spectral(mod(iTime / 10.0, 1.0)) + 0.5, 0.0, 1.0);\n    \n    // if the pixel is inside the light source then fully illuminated\n    if (distance(uv, light_pos) < light_radius) {\n        fragColor = vec4(light_colour, 1.0);\n        return;\n    }\n\n    // step along the tangent of the point across the radius\n    // TODO: step along the sphere circumference instead (only makes a difference when light intersects geometry)\n    vec2 dir = normalize(light_pos - uv);\n    vec2 tangent = vec2(-dir.y, dir.x);\n    \n    vec2 start = light_pos + (tangent * light_radius);\n    vec2 end = light_pos - (tangent * light_radius);\n    \n    // TODO: vary the number of samples based on the distance from the light source since we are in a grid\n    int num_samples = MAX_SAMPLES;\n    float intensity_step = 1.0 / float(num_samples + 1);\n    \n    float intensity = 0.0;\n    \n    for (int offset=0; offset<=num_samples; offset++) {\n        vec2 target = mix(start, end, float(offset) / float(num_samples));\n        vec2 dir = normalize(target - uv);\n        \n        // project rays from the current point towards the light source\n        if (!ray_scene_intersect(Ray(uv + dir * scale, dir), target)) {\n            intensity += intensity_step * exp(-LIGHT_ATTENUATION_COEFFICIENT * (distance(target, uv) - light_radius));\n        }\n    }\n    \n    fragColor = vec4(light_colour * clamp(intensity, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float PI = 3.14159265359;\n\n// settings - common throughout all buffers\nstruct Settings {\n    uint resolution;\n    uint num_samples;\n    uint num_frames;\n    uint total_frames;\n    uint max_value;\n};\n\nSettings get_settings(vec2 res) {\n    // the target width/height to cover\n    uint resolution = uint(ceil(max(res.x, res.y)));\n    \n    // the number of samples to take for each direction per frame\n    // optimal as a base of 2\n    uint num_samples = uint(4); // 4 = 16 samples per frame, halves the number of frames needed\n    \n    // frames needed per pass\n    uint num_frames = uint(ceil(log(float(resolution)) / log(float(num_samples))));\n    \n    // total frames needed before the map can be used\n    uint total_frames = num_frames * uint(2);\n    \n    // the maximum value to use as the default distance for no-hits\n    uint max_value = uint(ceil(sqrt(float(resolution * resolution) * 2.0)));\n\n    return Settings(\n        resolution,\n        num_samples,\n        num_frames,\n        total_frames,\n        max_value\n    );\n}\n\n// some methods to package a 2 16-bit int into a single 32-bit float\nfloat pack_2d_pos(in ivec2 pos) {\n    return uintBitsToFloat(packSnorm2x16(vec2(pos) / 32767.0));\n}\n\nivec2 unpack_2d_pos(in float col) {\n    return ivec2(unpackSnorm2x16(floatBitsToUint(col)) * 32767.0);\n}\n\nfloat dist(in ivec2 a) {\n    return length(vec2(a));\n}\n\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-8-simulating-diffraction\nvec3 spectral(float x) {\n    vec3 col = 4.0 * (x - vec3(0.75, 0.5, 0.25));\n    return max(vec3(0.0), vec3(1.0) - col * col);\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Compute the closest-distance map: https://www.shadertoy.com/view/XcVBzh\n// could just do this once but will need to re-compute it when the scene changes\n// or when the resolution changes (resize / fullscreen) so just keep re-computing for demo\n\nbool hit_scene(in ivec2 coord) {\n    return texture(iChannel0, vec2(coord) / iResolution.y).r > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(floor(fragCoord));\n    ivec2 res = ivec2(iResolution.xy);\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame) % settings.total_frames;\n    \n    // check collision with the scene for the first frame\n    if (frame == uint(0)) {\n        //sample this pixel first and just return if we get a result\n        if (hit_scene(coord)) {\n            fragColor = vec4(uintBitsToFloat(uint(0)));\n            return;\n        }\n        \n        // otherwise branch out in each direction linearly\n        // split the sampling of each direction so we can break early in each direction\n        \n        // top\n        uint closest_top = settings.max_value;\n        uint max_top_offset = min(settings.num_samples, uint(res.y - coord.y));\n        for (uint offset=uint(1); offset<max_top_offset; offset++) {\n            if (hit_scene(coord + ivec2(0, offset))) {\n                closest_top = offset;\n                break;\n            }\n        }\n\n        // right\n        uint closest_right = settings.max_value;\n        uint max_right_offset = min(settings.num_samples, uint(res.x - coord.x));\n        for (uint offset=uint(1); offset<max_right_offset; offset++) {\n            if (hit_scene(coord + ivec2(offset, 0))) {\n                closest_right = offset;\n                break;\n            }\n        }\n\n        // bottom\n        uint closest_bottom = settings.max_value;\n        uint max_bottom_offset = min(settings.num_samples, uint(coord.y));\n        for (uint offset=uint(1); offset<max_bottom_offset; offset++) {\n            if (hit_scene(coord + ivec2(0, -offset))) {\n                closest_bottom = offset;\n                break;\n            }\n        }\n\n        // left\n        uint closest_left = settings.max_value;\n        uint max_left_offset = min(settings.num_samples, uint(coord.x));\n        for (uint offset=uint(1); offset<max_left_offset; offset++) {\n            if (hit_scene(coord + ivec2(-offset, 0))) {\n                closest_left = offset;\n                break;\n            }\n        }\n\n        fragColor = vec4(\n            uintBitsToFloat(closest_top),\n            uintBitsToFloat(closest_right),\n            uintBitsToFloat(closest_bottom),\n            uintBitsToFloat(closest_left)\n        );\n\n        return;\n    }\n    \n    if (frame < settings.num_frames) {\n        // jump in a binary manner over multiple frames to find the closest distance for the entire resolution\n        vec4 last_value = texelFetch(iChannel1, coord, 0);\n        uint step_amount = uint(pow(float(settings.num_samples), float(frame)));\n        \n        uint step_max_offset = settings.num_samples * step_amount;\n\n        // top\n        uint last_top = floatBitsToUint(last_value.r);\n\n        if (last_top > step_amount) {\n            uint max_offset = min(step_max_offset, uint(iResolution.y) - uint(coord.y));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 top_neighbour = texelFetch(iChannel1, coord + ivec2(0, offset), 0);\n                uint closest_top = floatBitsToUint(top_neighbour.r) + offset;\n\n                if (closest_top < last_top) {\n                    last_top = closest_top;\n                    break;\n                }\n            }\n        }\n\n        // right\n        uint last_right = floatBitsToUint(last_value.g);\n\n        if (last_right > step_amount) {\n            uint max_offset = min(step_max_offset, uint(iResolution.x) - uint(coord.x));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 right_neighbour = texelFetch(iChannel1, coord + ivec2(offset, 0), 0);\n                uint closest_right = floatBitsToUint(right_neighbour.g) + offset;\n\n                if (closest_right < last_right) {\n                    last_right = closest_right;\n                    break;\n                }\n            }\n        }\n\n        // bottom\n        uint last_bottom = floatBitsToUint(last_value.b);\n\n        if (last_bottom > step_amount) {\n            uint max_offset = min(step_max_offset, uint(coord.y));\n        \n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 bottom_neighbour = texelFetch(iChannel1, coord + ivec2(0, -offset), 0);\n                uint closest_bottom = floatBitsToUint(bottom_neighbour.b) + offset;\n\n                if (closest_bottom < last_bottom) {\n                    last_bottom = closest_bottom;\n                    break;\n                }\n            }\n        }\n\n        // left\n        uint last_left = floatBitsToUint(last_value.a);\n\n        if (last_left > step_amount) {\n            uint max_offset = min(step_max_offset, uint(coord.x));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 left_neighbour = texelFetch(iChannel1, coord + ivec2(-offset, 0), 0);\n                uint closest_left = floatBitsToUint(left_neighbour.a) + offset;\n\n                if (closest_left < last_left) {\n                    last_left = closest_left;\n                    break;\n                }\n            }\n        }\n\n        // store the accumulated closest point\n        fragColor = vec4(\n            uintBitsToFloat(last_top),\n            uintBitsToFloat(last_right),\n            uintBitsToFloat(last_bottom),\n            uintBitsToFloat(last_left)\n        );\n        \n        return;\n    }\n\n    // once complete, compute the quadrant closest points using the distances computed\n    frame -= settings.num_frames;\n\n    if (frame == uint(0)) {\n        vec4 distances = texelFetch(iChannel1, coord, 0);\n        uint top_dist = floatBitsToUint(distances.r);\n        uint right_dist = floatBitsToUint(distances.g);\n        uint bottom_dist = floatBitsToUint(distances.b);\n        uint left_dist = floatBitsToUint(distances.a);\n        \n        // top right\n        ivec2 closest_top_right;\n        float closest_top_right_dist;\n        if (top_dist < right_dist) {\n            closest_top_right = ivec2(0, int(top_dist));\n            closest_top_right_dist = float(top_dist);\n        } else {\n            closest_top_right = ivec2(int(right_dist), 0);\n            closest_top_right_dist = float(right_dist);\n        }\n        \n        int max_top_right_offset = min(res.y - coord.y, min(res.x - coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_top_right_offset; offset++) {\n            ivec2 cell_offset = ivec2(offset, offset);\n            \n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n            \n            ivec2 closest_top = ivec2(0, int(floatBitsToUint(next_cells.r))) + cell_offset;\n            float closest_top_distance = dist(closest_top);\n\n            if (closest_top_distance < closest_top_right_dist) {\n                closest_top_right = closest_top;\n                closest_top_right_dist = closest_top_distance;\n            }\n\n            ivec2 closest_right = ivec2(int(floatBitsToUint(next_cells.g)), 0) + cell_offset;\n            float closest_right_distance = dist(closest_right);\n\n            if (closest_right_distance < closest_top_right_dist) {\n                closest_top_right = closest_right;\n                closest_top_right_dist = closest_right_distance;\n            }\n        }\n        \n        // bottom right\n        ivec2 closest_bottom_right;\n        float closest_bottom_right_dist;\n        if (bottom_dist < right_dist) {\n            closest_bottom_right = ivec2(0, -int(bottom_dist));\n            closest_bottom_right_dist = float(bottom_dist);\n        } else {\n            closest_bottom_right = ivec2(int(right_dist), 0);\n            closest_bottom_right_dist = float(right_dist);\n        }\n        \n        int max_bottom_right_offset = min(coord.y, min(res.x - coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_bottom_right_offset; offset++) {\n            ivec2 cell_offset = ivec2(offset, -offset);\n            \n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_bottom = ivec2(0, -int(floatBitsToUint(next_cells.b))) + cell_offset;\n            float closest_bottom_distance = dist(closest_bottom);\n\n            if (closest_bottom_distance < closest_bottom_right_dist) {\n                closest_bottom_right = closest_bottom;\n                closest_bottom_right_dist = closest_bottom_distance;\n            }\n\n            ivec2 closest_right = ivec2(int(floatBitsToUint(next_cells.g)), 0) + cell_offset;\n            float closest_right_distance = dist(closest_right);\n\n            if (closest_right_distance < closest_bottom_right_dist) {\n                closest_bottom_right = closest_right;\n                closest_bottom_right_dist = closest_right_distance;\n            }\n        }\n        \n        // bottom left\n        ivec2 closest_bottom_left;\n        float closest_bottom_left_dist;\n        if (bottom_dist < left_dist) {\n            closest_bottom_left = ivec2(0, -int(bottom_dist));\n            closest_bottom_left_dist = float(bottom_dist);\n        } else {\n            closest_bottom_left = ivec2(-int(left_dist), 0);\n            closest_bottom_left_dist = float(left_dist);\n        }\n        \n        int max_bottom_left_offset = min(coord.y, min(coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_bottom_left_offset; offset++) {\n            ivec2 cell_offset = ivec2(-offset);\n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_bottom = ivec2(0, -int(floatBitsToUint(next_cells.b))) + cell_offset;\n            float closest_bottom_distance = dist(closest_bottom);\n\n            if (closest_bottom_distance < closest_bottom_left_dist) {\n                closest_bottom_left = closest_bottom;\n                closest_bottom_left_dist = closest_bottom_distance;\n            }\n\n            ivec2 closest_left = ivec2(-int(floatBitsToUint(next_cells.a)), 0) + cell_offset;\n            float closest_left_distance = dist(closest_left);\n\n            if (closest_left_distance < closest_bottom_left_dist) {\n                closest_bottom_left = closest_left;\n                closest_bottom_left_dist = closest_left_distance;\n            }\n        }\n        \n        // top left\n        ivec2 closest_top_left;\n        float closest_top_left_dist;\n        if (top_dist < left_dist) {\n            closest_top_left = ivec2(0, int(top_dist));\n            closest_top_left_dist = float(top_dist);\n        } else {\n            closest_top_left = ivec2(-int(left_dist), 0);\n            closest_top_left_dist = float(left_dist);\n        }\n        \n        int max_top_left_offset = min(res.y - coord.y, min(coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_top_left_offset; offset++) {\n            ivec2 cell_offset = ivec2(-offset, offset);\n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_top = ivec2(0, int(floatBitsToUint(next_cells.r))) + cell_offset;\n            float closest_top_distance = dist(closest_top);\n\n            if (closest_top_distance < closest_top_left_dist) {\n                closest_top_left = closest_top;\n                closest_top_left_dist = closest_top_distance;\n            }\n\n            ivec2 closest_left = ivec2(-int(floatBitsToUint(next_cells.a)), 0) + cell_offset;\n            float closest_left_distance = dist(closest_left);\n\n            if (closest_left_distance < closest_top_left_dist) {\n                closest_top_left = closest_left;\n                closest_top_left_dist = closest_left_distance;\n            }\n        }\n\n        fragColor = vec4(\n            pack_2d_pos(closest_top_right),\n            pack_2d_pos(closest_bottom_right),\n            pack_2d_pos(closest_bottom_left),\n            pack_2d_pos(closest_top_left)\n        );\n\n        return;\n    }\n    \n    // for later frames we lookup the diagonal closest points and compare them to the existing closest point\n    int step_amount = int(pow(float(settings.num_samples), float(frame)));\n    int max_offset = step_amount * int(settings.num_samples);\n\n    vec4 last_closest = texelFetch(iChannel1, coord, 0);\n    \n    // top right\n    ivec2 last_top_right = unpack_2d_pos(last_closest.r);\n    float top_right_dist = dist(last_top_right);\n    int max_top_right_offset = min(min(res.y - coord.y, res.x - coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_top_right_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(1);\n        ivec2 test_top_right = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).r) + offset;\n        float test_top_right_dist = dist(test_top_right);\n\n        if (test_top_right_dist < top_right_dist) {\n            last_top_right = test_top_right;\n            top_right_dist = test_top_right_dist;\n        }\n    }\n    \n    // bottom right\n    ivec2 last_bottom_right = unpack_2d_pos(last_closest.g);\n    float bottom_right_dist = dist(last_bottom_right);\n    int max_bottom_right_offset = min(min(coord.y, res.x - coord.x), max_offset);\n    \n    for (int sample_index = step_amount; sample_index < max_bottom_right_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(1, -1);\n        ivec2 test_bottom_right = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).g) + offset;\n        float test_bottom_right_dist = dist(test_bottom_right);\n\n        if (test_bottom_right_dist < bottom_right_dist) {\n            last_bottom_right = test_bottom_right;\n            bottom_right_dist = test_bottom_right_dist;\n        }\n    }\n    \n    // bottom left\n    ivec2 last_bottom_left = unpack_2d_pos(last_closest.b);\n    float bottom_left_dist = dist(last_bottom_left);\n    int max_bottom_left_offset = min(min(coord.y, coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_bottom_left_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(-1);\n        ivec2 test_bottom_left = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).b) + offset;\n        float test_bottom_left_dist = dist(test_bottom_left);\n\n        if (test_bottom_left_dist < bottom_left_dist) {\n            last_bottom_left = test_bottom_left;\n            bottom_left_dist = test_bottom_left_dist;\n        }\n    }\n    \n    // top left\n    ivec2 last_top_left = unpack_2d_pos(last_closest.a);\n    float top_left_dist = dist(last_top_left);\n    int max_top_left_offset = min(min(res.y - coord.y, coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_top_left_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(-1, 1);\n        ivec2 test_top_left = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).a) + offset;\n        float test_top_left_dist = dist(test_top_left);\n\n        if (test_top_left_dist < top_left_dist) {\n            last_top_left = test_top_left;\n            top_left_dist = test_top_left_dist;\n        }\n    }\n\n    // store the accumulated closest point\n    fragColor = vec4(\n        pack_2d_pos(last_top_right),\n        pack_2d_pos(last_bottom_right),\n        pack_2d_pos(last_bottom_left),\n        pack_2d_pos(last_top_left)\n    );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer renders buffer A when it is complete, keeping the result in the buffer until the next pass\n// only needed where the geometry is dynamic to ensure a map is available whilst being recomputed\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(floor(fragCoord));\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame);\n    \n    if (frame == uint(0)) {\n        fragColor = vec4(pack_2d_pos(ivec2(0)));\n        return;\n    }\n     \n    // the last frame should contain what we want to render\n    if ((frame % settings.total_frames) == (settings.total_frames - uint(1))) {\n        fragColor = texelFetch(iChannel0, coord, 0);\n        return;\n    }\n    \n    fragColor = texelFetch(iChannel1, coord, 0);\n}\n","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcGSW3","date":"1735233653","viewed":102,"name":"2D Shadows - Ray Casting Hi-Res","username":"mrboggieman","description":"High resolution version of https://shadertoy.com/view/3tVfWc with area light. Uses closest-point map to accelerate ray traces. Drag light source with mouse.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","raycasting","shadows"],"hasliked":0,"parentid":"","parentname":""}}