{"ver":"0.1","info":{"id":"tdtSz4","date":"1571600741","viewed":243,"name":"light snake","username":"snolot","description":"test sdf","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["sdf","light","snake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 sampleDist = vec2(1.28,1.28);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist/iResolution.xy;\n    \n    for(int x = -8; x <= 8; x++){\n    \tfor(int y = -8; y <= 8; y++){\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n    \n\n    tex /= 50.0;\n\ttex = mix(tex, texture(iChannel0, uv),  .965);\n\tfragColor = tex;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// All code taken from IQ and others, thanks to all ;)\n\n#define AA 1\nvec3 vGlowColour = vec3(1.0, 0.075, 0.01) * 5.0;\n\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n    const vec3 s = vec3(113, 157, 1);\n    \n    vec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n    p -= ip; // Cell's fractional component.\n    \n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    \n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); // Range: [0, 1].\n    \n    return n; //abs(n - .5)*2.;\n}\n\n\n\n// https://www.shadertoy.com/view/tl23RK\nfloat sdSqCappedTorus(in vec3 p, in vec2 sc, in float ra)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return dot(p,p) + ra*ra - 2.0*ra*k;\n}\n\nvec3 hash( float n )\n{\n    vec3 m = n*vec3(23.0,41.0,17.0) + vec3(9.0,1.0,31.0);\n    return fract( m*fract( m*0.3183099 ) );\n}\n\nvec2 map( in vec3 pos )\n{\n    vec3 pp = vec3(0.0);\n    vec3 ww = vec3(0.0,1.0,0.0);\n    \n    float d = length(pos-pp);\n    \n    vec4 data = vec4(0.0);\n    vec3 l = vec3(0.0);\n\n    for( int i=0; i<16; i++ )\n    {\n        // segment parameters        \n        vec3 ran = hash(float(i));\n        float ra = 0.14 + 0.08*ran.x; // radius\n        float ap = 1.10 + 0.80*ran.y; // aperture\n        vec3  up = normalize( sin(90.0*ran.z+vec3(0.0,2.3,3.5))); // orientation\n\n        // world to torus transformation\n        vec2 sc = vec2(sin(ap),cos(ap));\n        vec3 ou = normalize(cross(ww,up));\n        vec3 vv = cross(ou,ww);\n        vec3 uu =  sc.x*ou + sc.y*ww;\n             ww = -sc.y*ou + sc.x*ww;\n        vec3 cpos = (pos-pp)*mat3(uu,ww,vv) + ra*vec3(-sc.x,sc.y,0.0);\n        \n        // distance evaluation        \n        float tmp = sdSqCappedTorus(cpos, sc, ra );\n        if( tmp<d )\n        {\n            d = tmp;\n            data = vec4( float(i), cpos.xy, ap );\n        }\n        \n\n        // prepare next segment        \n        pp += 2.0*ra*sc.x*uu;\n        ww = sc.y*uu - sc.x*ww;\n    }\n    \n    return vec2(sqrt(d) - 0.035, // distance\n                data.x + 0.5+0.5*(atan(data.y,data.z))/data.w // u\n               );\n}\n\n\nfloat noise(vec3 p)\n{\n    vec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n\n\nfloat fogFactorExp2_4_9(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat curv_modifier(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;   \n    \n    float t1 = map(p + e.yxx).x, t2 = map(p + e.xxy).x;\n    float t3 = map(p + e.xyx).x, t4 = map(p + e.yyy).x;\n    \n    return (.25/e.y) * (t1 + t2 + t3 + t4 - 4.0 * map(p).x);\n}\n\n#define ZERO min(u_frame,0)\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.35*(iTime-4.0);\n    vec3 ta = vec3( -0.5, -0.4, -0.02 );\n\tvec3 ro = ta + vec3( 1.5*cos(an * .6), 0.0, 1.5*sin(an * .6) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    float fGlow = 0.0;\n\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n        //float glow = 0.0;\n        float raylength = 0.0;\n\n        // raymarch\n        const float tmax = 3.5;\n        float hz = 0.0;\n\n        float l = 99999.9;\n        float t = 0.5;\n        float m = 0.0;\n        vec3 lc = vec3(0.0);\n\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 h = map(pos);\n            m = h.y;\n    \n\n            if( h.x<0.001 || t>tmax ) break;\n            t += h.x;\n\n            \n            raylength = distance(ro,pos);\n            float hz = pow(noise(pos*vec3(0.2,0.3,0.1)+vec3(0.0,iTime*-0.2,iTime*0.5)),4.0)*10.0;\n        }\n    \n        // shade/light\n        \n        float fShade = 1.0;\n        vec3 pos = ro + t*rd;\n        \n        vec3 nor = calcNormal(pos);\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = calcAO(pos, nor);\n        float amb = 0.5 + 0.5*nor.y;\n\n        //vec3 col = vec3(0.1 - 0.015*length(p) + 0.05*rd.y ) * .4 ;\n        vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n        vec3 sun = vec3(.24, .27, 0.29); \n        vec3 skycolor = vec3(0.6, 1.2, 1.0); \n\n        vec3 bg = exp(p.y-4.0)*vec3(0.4, .3, .3);\n\n        float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.); \n        vec3 col=bg+vec3(.24, .27, 0.29)*pow(halo,20.0); \n\n\n\n        if( t<tmax )\n        {\n            \n            // material\n            vec3 mat = 0.5 + 0.5*cos( m*0.16 + vec3(.00,1.0,1.8) + 1.0 );\n            mat += 0.05*nor;\n            // lighting\n            col = mat*1.5*occ*vec3(amb+fre*fre*col*0.2);\n            col *= 4.0*smoothstep( 0.01, .99, sin(5.0*m*.02+iTime*3.0) );\n            \n            col *= 4.*smoothstep( 0.1, 0.2, sin(25.0*m+iTime*20.0) );\n            col += fre*occ*0.2*vec3(0.4,0.6,.9)*smoothstep(0.0,0.02,reflect(rd,nor).y);\n            //col += fre*occ*0.2*vec3(0.4,0.6,.9)*smoothstep(0.0,.2,reflect(rd,nor).y);\n            \n            col = sqrt( col );\n\n            col += vGlowColour * 10.0 * fGlow;\n            \n        }\n\n        float f = fogFactorExp2_4_9(.8, 1.08);\n        col *= vec3(f);\n\n        vec3 emission = (col * smoothstep(50.0,0.0,raylength)) * smoothstep(1.0,0.,raylength); //emissive pieces;\n        float hazer = smoothstep(10.0,0.0,raylength); // hazyness;\n       \n        vec3 lightfield = max(col.rgb,vec3(.3));\n        vec3 lightmix = lightfield*3.0;\n        \n        //col = 1.0 /hz;// abs(pos)+1.0;\n\n        col =   col * lightmix  + hazer * emission ; \n       // col = mix(col,hazer+emission,hazer);\n       \n        \n        // gamma        \n        // col = sqrt( col );\n        //vec3 glow = col;\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    \n\n    //col += vec3(hz);\n    //float hazer = smoothstep(0.0,20.0,raylength); // hazyness;\n    //col = mix(col, col*10.25, hazer);\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}