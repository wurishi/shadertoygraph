{"ver":"0.1","info":{"id":"dtXyzf","date":"1691002382","viewed":40,"name":"bricks: 2d or not 2d","username":"valalalalala","description":"Working on a small project, I wanted a brick texture with a big of wiggly and tad of jiggly and hence this!\n\nYou can mouse move into some weirdness... colors and params galore!\n\nCheck out my 3d version here: https://www.shadertoy.com/view/WtdfD8","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","fbm","brick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"bricks: 2d or not 2d\"                                    // //\n     //                                                            //  //\n    //  Working on a small project, I wanted a brick texture      //   //\n   //  with a big of wiggly and tad of jiggly and hence this!    //    //\n  //  You can mouse move into some weirdness ...                //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n#if 0\n    /// this controls the major hue\n    const ivec3 RGB = ivec3( 255, 145, 94 );\n    //const ivec3 RGB = ivec3( 84, 75, 124 );\n#else \n\n#define USE_PALETTE\n// convert rgs.png -colors 16 -unique-colors /tmp/p.txt ; awk 'BEGIN {C=\" \"; print \"const ivec3 PALETTE[] = ivec3[](\"} END { print \");\" } /^[0-9]*,/ { color = $2; sub( /,[0-9.]*)/, \")\", color ); gsub( /\\.[0-9]*/, \"\", color ); sub( /),/, \")\", color ); printf( \"\\t%s ivec3%s\\n\", C, color ); C = \",\" } ' /tmp/p.txt\n\nconst int ROWS = 3;\nconst int COLUMNS = 4;\nconst ivec3 PALETTE[] = ivec3[](\n      ivec3(249,246,232)\n    , ivec3(224,186,162)\n    , ivec3(175,143,117)\n    , ivec3(155,110,98)\n    \n    , ivec3(255,145,94)\n    , ivec3(210,104,104)\n    , ivec3(204,110,138)\n    , ivec3(179,175,204)     \n    \n    , ivec3(158,193,123)\n    , ivec3(98,213,185)\n    , ivec3(112,168,170)\n    , ivec3(156,194,194)\n);\n#endif\n\n/////////////////////////////////////////////////////////\n\nconst float SEED = 1.1;\n\n/////////////////////////////////////////////////////////\n\n// how dark or light to make the color\nconst vec2 COLOR_RANGE = vec2( .696, 1. );\n\n/////////////////////////////////////////////////////////\n\n// the weights and scales for the noise\nconst vec4 SCL = vec4( 1., 2., 4., 8. );\nconst vec4 WTZ = vec4( 1., .5, .25, .125 );\n\n/////////////////////////////////////////////////////////\n\n\n// you can get some interesting effects with really big or small values\nconst float BRICK_SCALE = 11.; //  *4.;\nconst float BRICK_GAP  = .04; //* .01;  \n\nconst vec2  BRICK_RATIO = vec2( .75, 2 );\n\n/////////////////////////////////////////////////////////\n \nvec2 fromScreen(vec2 st) {\n    return ( st.xy * 2. - iResolution.xy ) / iResolution.y;\n}\n\nint mapToGrid(vec2 st, int rows, int columns ) {\n  float x = st.x / (iResolution.x / float(columns));\n  float y = (iResolution.y-st.y) / (iResolution.y / float(rows));\n  int gridIndex = int(floor(y)) * columns + int(floor(x));\n  return gridIndex;\n}\n\nfloat inRange( in float f, in vec2 color_range ) {\n    return color_range.x + f * ( color_range.y - color_range.x );\n}\n\n/////////////////////////////////////////////////////////\n\nvec3 swath( in ivec3 rgb, in vec2 uv, in vec2 color_range, vec4 scale, vec4 weight ) {\n    float nz = inRange( fbm( uv, weight, scale ), color_range );\n    return nz * vec3( rgb ) / 255.;\n}\n\nvec3 swath( ivec3 rgb, vec2 uv ) {\n    return swath( rgb, uv, COLOR_RANGE, SCL, WTZ );\n}\n\nfloat bricko( in vec2 uv ) {\n    vec4 brb = .66 * vec4( \n        fbm3( uv + .00 ),\n        fbm3( uv + .11 ),\n        fbm3( uv + .22 ),\n        fbm3( uv + .33 )\n    );\n\n    vec2 brickSize = brb.xy + BRICK_SCALE * BRICK_RATIO;\n    vec2 brickGap  = brb.zw + BRICK_GAP * BRICK_RATIO.yx;\n    float brick = 1. - inset( uv, brickSize, brickGap );\n    \n    return clamp( max( brick, COLOR_RANGE.x), COLOR_RANGE.x, 1. ); \n}\n\nvoid mainImage( out vec4 result, in vec2 st ) {\n    vec2 uv = fromScreen( st + fromScreen( iMouse.xy ) * 9000.1 ) + SEED;\n\n#ifdef USE_PALETTE\n    ivec3 color = PALETTE[ mapToGrid( st, ROWS, COLUMNS ) ];\n#else\n    ivec3 color = RGB;\n#endif\n\n    result = vec4( swath( color, uv ) * bricko( uv ), 1 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 hash( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( vec2( q.x * q.y, q.y * q.z ) );\n}\n\nvec3 hash( in vec3 uv ) {\n    vec3 q = fract( uv * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( q );//vec2( q.x * q.y, q.y * q.z ) );\n}\nconst vec2 corner_00 = vec2( 0, 0 );\nconst vec2 corner_10 = vec2( 1, 0 );\nconst vec2 corner_01 = vec2( 0, 1 );\nconst vec2 corner_11 = vec2( 1, 1 );\n\nfloat noise( vec2 uv ) {\n    vec2 i = floor( uv );\n    vec2 f = fract( uv );\n\n    /*\n        hash_00         hash_10\n               +-------+\n               |       |\n               | f     |\n               |       |\n               +-------+\n        hash_01         hash_11\n    */\n\n    // hash values at each corner\n    \n    vec2 hash_00 = hash( i + corner_00 );\n    vec2 hash_10 = hash( i + corner_10 );\n    vec2 hash_01 = hash( i + corner_01 );\n    vec2 hash_11 = hash( i + corner_11 );\n        \n    // offset from corners\n    \n    vec2 offset_00 = f - corner_00;\n    vec2 offset_10 = f - corner_10;\n    vec2 offset_01 = f - corner_01;\n    vec2 offset_11 = f - corner_11;\n        \n    // scalar projection \n    \n    float h_00 = dot( hash_00, offset_00 );\n    float h_10 = dot( hash_10, offset_10 );\n    float h_01 = dot( hash_01, offset_01 );\n    float h_11 = dot( hash_11, offset_11 );\n        \n    //////////////////////////////////////////////\n    // interpolate the values\n    \n    // the Hermite interpolation\n\n    vec2 s = smoothstep( .0, 1., f );\n    \n    // horizontally \n    \n    float h_y0 = mix( h_00, h_10, s.x );\n    float h_y1 = mix( h_01, h_11, s.x );\n    \n    // vertically\n\n    return mix( h_y0, h_y1, s.y );\n}\n\nfloat anoise( vec2 uv ) {\n    return abs( noise( mod( uv, 8.8 ) ) );\n}\n\n\nfloat fbm( vec2 uv, vec4 wtz, vec4 scl ) {\n    return dot( wtz, vec4(\n        anoise( scl[ 0 ] * uv ),\n        anoise( scl[ 1 ] * uv ),\n        anoise( scl[ 2 ] * uv ),\n        anoise( scl[ 3 ] * uv )\n    ));\n}\n\nfloat fbm( vec2 uv, vec3 wtz, vec3 scl ) {\n    return dot( wtz, vec3(\n        anoise( scl[ 0 ] * uv ),\n        anoise( scl[ 1 ] * uv ),\n        anoise( scl[ 2 ] * uv ) \n    ));\n}\n\n\nfloat fbm3( in vec2 uv ) {\n    return fbm( uv, vec3( .10, .03, .01 ), vec3( 3., 9., 23. ) );\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// brick making \n\nfloat everyOtherRow( in float value, in float row ) {\n    return mod( value + .5 * step( 1., mod( row, 2. ) ), 1. );\n}\n\nfloat inset( in vec2 p, in vec2 scale, in vec2 inOut ) {\n    vec2 s = scale * p;\n    vec2 f = fract( s );\n    vec2 i = s - f;\n    f.x = everyOtherRow( f.x, i.y );\n        \n    // almost certainly not exactly...\n    vec2 q = min( f, 1. -f );\n    return smoothstep( inOut.x, inOut.y, min(q.x,q.y) );\n}\n\nfloat brickly( vec2 p ) {\n    //vec4 theF = fbm( p + 0.33, vec3( .10, .03, .01 ), vec3( 3., 9., 23. ) );\n    float f = 1.; //theF.w;\n\n    vec2 brickSize = 3.5 * vec2( .25, .6 ) + f;\n    vec2 brickGap = 1.2 *vec2( .1, .01 ) + f * .2;\n    \n    return .125 * inset( p.xy, brickSize, brickGap ) + f * 1.3;\n}\n","name":"Common","description":"","type":"common"}]}