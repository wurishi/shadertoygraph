{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//  Copyright (c) 2018-2019 Michele Morrone\n//  All rights reserved.\n//\n//  https://michelemorrone.eu - https://BrutPitt.com\n//\n//  me@michelemorrone.eu - brutpitt@gmail.com\n//  twitter: @BrutPitt - github: BrutPitt\n//  \n//  https://github.com/BrutPitt/glslSmartDeNoise/\n//  https://www.shadertoy.com/view/3dd3Wr\n//\n//  This software is distributed under the terms of the BSD 2-Clause license\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI\n#define INV_PI 0.31830988618379067153776752674503\n\n//  smartDeNoise - parameters\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//  sampler2D tex     - sampler image / texture\n//  vec2 uv           - actual fragment coord\n//  float sigma  >  0 - sigma Standard Deviation\n//  float kSigma >= 0 - sigma coefficient \n//      kSigma * sigma  -->  radius of the circular kernel\n//  float threshold   - edge sharpening threshold \n\nvec4 smartDeNoise(sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold)\n{\n    float radius = round(kSigma*sigma);\n    float radQ = radius * radius;\n    \n    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)\n    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)\n    \n    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)\n    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)\n    \n    vec4 centrPx = texture(tex,uv);\n    \n    float zBuff = 0.0;\n    vec4 aBuff = vec4(0.0);\n    vec2 size = vec2(textureSize(tex, 0));\n    \n    for(float x=-radius; x <= radius; x++) {\n        float pt = sqrt(radQ-x*x);  // pt = yRadius: have circular trend\n        for(float y=-pt; y <= pt; y++) {\n            vec2 d = vec2(x,y);\n\n            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI; \n            \n            vec4 walkPx =  texture(tex,uv+d/size);\n\n            vec4 dC = walkPx-centrPx;\n            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;\n                                 \n            zBuff += deltaFactor;\n            aBuff += deltaFactor*walkPx;\n        }\n    }\n    return aBuff/zBuff;\n}\n\n//  About Standard Deviations (watch Gauss curve)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//  kSigma = 1*sigma cover 68% of data\n//  kSigma = 2*sigma cover 95% of data - but there are over 3 times \n//                   more points to compute\n//  kSigma = 3*sigma cover 99.7% of data - but needs more than double \n//                   the calculations of 2*sigma\n\n\n//  Optimizations (description)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//  fX = exp( -(x*x) * invSigmaSqx2 ) * invSigmaxSqrt2PI; \n//  fY = exp( -(y*y) * invSigmaSqx2 ) * invSigmaxSqrt2PI; \n//  where...\n//      invSigmaSqx2     = 1.0 / (sigma^2 * 2.0)\n//      invSigmaxSqrt2PI = 1.0 / (sqrt(2 * PI) * sigma)\n//\n//  now, fX*fY can be written in unique expression...\n//\n//      e^(a*X) * e^(a*Y) * c*c\n//\n//      where:\n//        a = invSigmaSqx2, X = (x*x), Y = (y*y), c = invSigmaxSqrt2PI\n//\n//           -[(x*x) * 1/(2 * sigma^2)]             -[(y*y) * 1/(2 * sigma^2)] \n//          e                                      e\n//  fX = -------------------------------    fY = -------------------------------\n//                ________                               ________\n//              \\/ 2 * PI  * sigma                     \\/ 2 * PI  * sigma\n//\n//      now with... \n//        a = 1/(2 * sigma^2), \n//        X = (x*x) \n//        Y = (y*y) ________\n//        c = 1 / \\/ 2 * PI  * sigma\n//\n//      we have...\n//              -[aX]              -[aY]\n//        fX = e      * c;   fY = e      * c;\n//\n//      and...\n//                 -[aX + aY]    [2]     -[a(X + Y)]    [2]\n//        fX*fY = e           * c     = e            * c   \n//\n//      well...\n//\n//                    -[(x*x + y*y) * 1/(2 * sigma^2)]\n//                   e                                \n//        fX*fY = --------------------------------------\n//                                        [2]           \n//                          2 * PI * sigma           \n//      \n//      now with assigned constants...\n//\n//          invSigmaQx2   = 1/(2 * sigma^2)\n//          invSigmaQx2PI = 1/(2 * PI * sigma^2) = invSigmaQx2 * INV_PI \n//\n//      and the kernel vector \n//\n//          k = vec2(x,y)\n//\n//      we can write:\n//\n//          fXY = exp( -dot(k,k) * invSigmaQx2) * invSigmaQx2PI\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float szSlide = 1.0 / iResolution.x;\n    float thres = iResolution.x / 10000.0;\n    vec2 mouse =iMouse.xy/ iResolution.xy;\n    if(mouse.x <= 0.0 &&  mouse.y <= 0.0) mouse.x = .5; // to show initial screen half splitted\n    \n\tfragColor = uv.x<mouse.x-szSlide  ? texture(iChannel2,uv)\n          : (uv.x>mouse.x+szSlide ? smartDeNoise(iChannel2, uv, 2.0, 3.0, .400+thres) \n          :  vec4(0.0,1.0, 0.0, 1.0));\n    \n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n      \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n    Input logic\n*/\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    if(uv0.x >= 256.0 || uv0.y >= 8.0) discard;\n    \n    Resolution = iResolution.xy;\n\n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\n    outCol = vec4(0.0);\n    \n    // blit key board texture\n    outCol = texelFetch(KeyBoard, ivec2(uv0 - 0.5), 0);\n    \n    // program state:\n    {\n        vec4 iMouseLast     = ReadVar4(0, VAR_ROW);\n        vec4 iMouseAccuLast = ReadVar4(1, VAR_ROW);\n        vec4 wasdAccuLast   = ReadVar4(2, VAR_ROW);\n        float frameAccuLast = ReadVar (3, VAR_ROW);\n        float num           = ReadVar (4, VAR_ROW);\n        \n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        if(ReadKey(KEY_N1) != 0.0) num = 0.0;\n        if(ReadKey(KEY_N2) != 0.0) num = 1.0;\n        if(ReadKey(KEY_N3) != 0.0) num = 2.0;\n        if(ReadKey(KEY_N4) != 0.0) num = 3.0;\n        if(ReadKey(KEY_N5) != 0.0) num = 4.0;\n        if(ReadKey(KEY_N6) != 0.0) num = 5.0;\n        if(ReadKey(KEY_N7) != 0.0) num = 6.0;\n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        anyK = anyK || ReadKey(KEY_TAB) != 0.0;\n        anyK = anyK || ReadKey(KEY_SHIFT) != 0.0;\n        anyK = anyK || ReadKey(KEY_SPACE) != 0.0;\n        anyK = anyK || ReadKey(KEY_CTRL) != 0.0;\n        \n        float frameAccu = frameAccuLast;\n        //if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        if(cond0 && dot(abs(mouseDelta), vec2(1.0)) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_TAB ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_CTRL) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_R   ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_W   ) != 0.0) frameAccu = 0.0;\n        if(ReadKey(KEY_SPACE)!= 0.0) frameAccu = 0.0;\n        \n        frameAccu += 1.0;\n        \n        vec4 toggles = vec4(\n        ReadKeyToggle(KEY_TAB  ) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_SHIFT) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_SPACE) != 0.0 ? 1.0 : 0.0,\n        ReadKeyToggle(KEY_CTRL ) != 0.0 ? 1.0 : 0.0);\n        \n        WriteVar4(iMouse,        0, VAR_ROW);\n        WriteVar4(iMouseAccu,    1, VAR_ROW);\n        WriteVar4(wasdAccu,      2, VAR_ROW);\n        WriteVar (frameAccu,     3, VAR_ROW);\n        WriteVar (num,           4, VAR_ROW);\n        WriteVar4(iMouseAccuLast,5, VAR_ROW);\n        WriteVar4(toggles       ,6, VAR_ROW);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n     \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvec2 Resolution;\n\n#define USE_TEMP_ACCU_COND                (ReadKeyToggle(KEY_TAB  ) != 0.0)\n#define USE_PERSPECTIVE_CAM_COND          (ReadKeyToggle(KEY_CTRL ) == 0.0)\n#define SHOW_UI_COND                      (ReadKeyToggle(KEY_U    ) == 0.0)\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// misc\n//==========================================================================================================//\n#define VAR_ROW 4\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n#define KEY_G 71\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_U 85\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\nconst float RcpPi05 = 1.0 / Pi05;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// camera logic + transforms\n//==========================================================================================================//\nbool isPerspectiveCam;// ortho/proj cam toggle\nfloat cdist, nearZ;// camera dist from origin + z-near\nmat3 cmat;// camera matrix\nvec3 cpos;// camera pos\nmat4 pmat, ipmat;// proj matrix + inverse\n\nvoid PrepareCam(vec4 mouseAccu, bool isPerspectiveCam0)\n{\n    isPerspectiveCam = isPerspectiveCam0;\n    \n    vec2 ang = vec2(Pi * 0.25, Pi * -0.1);\n   // ang = vec2(Pi05, Pi * -0.5);// start top-down\n    ang += mouseAccu.xy * 0.008;\n\n    vec3 front, right, up;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n        right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        up    = vec3(-cosPhi * sinTheta,\n                               cosTheta,\n                     -sinPhi * sinTheta);\n        \n    }\n\n    cmat = mat3(right, up, front);\n    \n    cdist = exp2(1.5 + mouseAccu.w * 0.02);\n\n    float aspect = Resolution.x / Resolution.y;\n\n    vec2 vpSize = vec2(1.0, 1.0 / aspect) * 2.0;// viewport size at focal length\n\n    if(!isPerspectiveCam) vpSize *= cdist;\n\n    nearZ = isPerspectiveCam ? 0.125 : 0.0;\n\n   #if 1\n    float focalLen = 0.8;// = cot(fov * 0.5) for w == 2\n\n    float w = vpSize.x;\n    float h = vpSize.y;\n\n    float m00 = 2.0 * focalLen / w;\n    float m11 = 2.0 * focalLen / h;\n   #else \n\n    float fovX = 0.570447 * Pi;// 2 * arccot(focalLen) fpr w == 2\n    float m00 = cos(fovX * 0.5) / sin(fovX * 0.5);\n    float m11 = m00 * aspect;\n   #endif\n    \n    \n    float m23 = -nearZ;\n    float m32 = 1.0;\n    \n    float m33 = 0.0;\n    \n    if(!isPerspectiveCam)\n    {\n        m00 = 2.0 / vpSize.x;\n        m11 = 2.0 / vpSize.y;\n    \n        m23 = m32 = 0.0;\n        m33 = 1.0;\n    }    \n    \n    pmat = mat4(m00, 0.0, 0.0, 0.0,\n                0.0, m11, 0.0, 0.0,\n                0.0, 0.0, 1.0, m32,\n                0.0, 0.0, m23, m33);\n    \n    float i00 = 1.0 / m00;\n    float i11 = 1.0 / m11;\n    \n    float i22 = 0.0;\n    \n    float i23 = 1.0;\n    float i32 =-1.0/nearZ;\n    \n    float i33 = 1.0/nearZ;\n    \n    if(!isPerspectiveCam)\n    {\n        i22 = i33 = 1.0;\n        i23 = i32 = 0.0;\n    }\n                \n    ipmat = mat4(i00, 0.0, 0.0, 0.0,\n                 0.0, i11, 0.0, 0.0,\n                 0.0, 0.0, i22, i32,\n                 0.0, 0.0, i23, i33);\n    \n    \n    if(isPerspectiveCam)\n    {\n        cpos = -front * cdist;\n    }\n    else\n    {\n        cpos = -front * 8.0;\n    }    \n}\n\nfloat LinDepth_from_NonLinDepth(float depth)\n{\n    if(!isPerspectiveCam) return depth;\n    \n    //1.0 / (-depth/nearZ + 1.0/nearZ);\n    //1.0 / ((-depth + 1.0)/nearZ);\n    //nearZ / (-depth + 1.0);\n    return nearZ / (1.0 - depth);\n}\n\nfloat NonLinDepth_from_LinDepth(float depth)\n{\n    if(!isPerspectiveCam) return depth;\n\n    //return (depth - n) / depth;\n    return 1.0 - nearZ / depth;\n}\n\n\n// ====== View <-> World ====== //\nvec3 VPos_from_WPos(vec3 wpos)\n{\n    return (wpos - cpos) * cmat;\n}\n\nvec3 VVec_from_WVec(vec3 wvec)\n{\n    return wvec * cmat;\n}\n\n////\n\nvec3 WPos_from_VPos(vec3 vpos)\n{\n    return cmat * vpos + cpos;\n}\n\nvec3 WVec_from_VVec(vec3 vvec)\n{\n    return cmat * vvec;\n}\n// =========================== //\n\n// ====== Proj <-> View ====== //\nvec4 PPos_from_VPos(vec3 vpos)\n{\n    return pmat * vec4(vpos, 1.0);\n}\n\nvec3 VPos_from_PPos(vec4 ppos)\n{\n    vec4 vpos = ipmat * ppos;\n    \n    return vpos.xyz / vpos.w;\n}\n\nvec4 PVec_from_VVec(vec3 vvec)\n{\n    return pmat * vec4(vvec, 0.0);\n}\n// =========================== //\n\n\n// ====== Screen <-> View ====== //\nvec3 SPos_from_VPos(vec3 vpos)\n{\n    vec4 ppos = PPos_from_VPos(vpos);\n    \n    vec2 tc21 = ppos.xy / ppos.w;\n    \n    vec2 uv0 = (tc21 * 0.5 + 0.5) * Resolution;\n    \n    return vec3(uv0, vpos.z);\n}\n\nvec3 SVec_from_VVec_Ortho(vec3 vvec)\n{\n    vec4 pvec = PVec_from_VVec(vvec);\n    \n    vec2 xy = (pvec.xy * 0.5) * Resolution;\n    \n    return vec3(xy, vvec.z);\n}\n////\n\nvec3 VPos_from_SPos(vec3 spos)\n{\n    vec2 uv0 = spos.xy;\n    float depth = spos.z;\n          depth = NonLinDepth_from_LinDepth(depth);\n    \n    vec2 tc21 = uv0 / Resolution * 2.0 - 1.0;\n    \n    vec3 ppos = vec3(tc21, depth);\n    \n    vec4 vpos = ipmat * vec4(ppos, 1.0); \n    \n    vpos /= vpos.w;\n    \n    return vpos.xyz;  \n}\n// ============================= //\n\n// ====== Proj <-> World ====== //\nvec4 PPos_from_WPos(vec3 wpos)\n{\n    vec3 vpos = VPos_from_WPos(wpos);\n    \n    return PPos_from_VPos(vpos);\n}\n\nvec3 WPos_from_PPos(vec4 ppos)\n{\n    vec3 vpos = VPos_from_PPos(ppos);\n    \n    return WPos_from_VPos(vpos);\n}\n\nvec4 PVec_from_WVec(vec3 wvec)\n{\n    vec3 vvec = VVec_from_WVec(wvec);\n    \n    return PVec_from_VVec(vvec);\n}\n// =========================== //\n\n// ====== Screen <-> World ====== //\nvec3 SPos_from_WPos(vec3 wpos)\n{\n    vec3 vpos = VPos_from_WPos(wpos);\n\n    return SPos_from_VPos(vpos);\n}\n\n////\n\nvec3 WPos_from_SPos(vec3 spos)\n{\n    vec3 vpos = VPos_from_SPos(spos);\n\n    return WPos_from_VPos(vpos);\n}\n// ============================== //\n\nvoid GetRay(vec2 uv0, out vec3 rp, out vec3 rd)\n{\n    vec3 spos = vec3(uv0, nearZ);\n    \n    vec3 vpos = VPos_from_SPos(spos); \n\n    if(isPerspectiveCam)\n    {\n        rp = cpos;\n        rd = WVec_from_VVec(normalize(vpos)); \n    }\n    else\n    {\n        rp = WPos_from_VPos(vpos); \n        rd = cmat[2];\n    }\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// intersection routines\n//==========================================================================================================//\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nbvec2 minmask(vec2 v)\n{\n    bool x = v.x < v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec2 maxmask(vec2 v)\n{\n    bool x = v.x >= v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec3 minmask(vec3 v)\n{    \n    return bvec3(v.x <= v.y && v.x <= v.z,\n                 v.y <  v.z && v.y <  v.x,\n                 v.z <  v.x && v.z <= v.y);\n}\n\nbvec3 maxmask(vec3 v)\n{\n    return bvec3(v.x >= v.y && v.x >= v.z,\n                 v.y >  v.z && v.y >  v.x,\n                 v.z >  v.x && v.z >= v.y);\n}\n\nbvec3 minmask2(vec3 v)\n{\n    bool x = !(v.x >  v.y || v.x >  v.z) && !isnan(v.x);\n    bool y = !(v.y >= v.z || v.y >= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nbvec3 maxmask2(vec3 v)\n{\n    bool x = !(v.x <  v.y || v.x <  v.z) && !isnan(v.x);\n    bool y = !(v.y <= v.z || v.y <= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    bvec3 mb = minmask2(ub);\n    \n    N = os * vec3(mb);\n    \n    t = mb.x ? ub.x : mb.y ? ub.y : ub.z;\n}\n\nbool IsInsideCube(vec3 p, vec3 cp, vec3 cd)\n{\n    vec3 b = abs(p - cp);\n    \n    return b.x < cd.x && b.y < cd.y && b.z < cd.z;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// scene intersection\n//==========================================================================================================//\nvoid Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, \n                        inout float hit, inout float t, inout vec3 n)\n{\n    vec2 tt; vec3 n0, n1;\n    float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n    if(th > 0.0)\n    if(hit <= 0.0 || tt.x < t)\n    {\n        t = tt.x;\n        n = n0;\n\n        hit = 1.0;\n    }        \n}\n\nbool Intersect_Ray_Plate(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, float c1p_y, float c1dxz, float c1dy, float c1ps,\n                        inout float hit, inout float t, inout vec3 n)\n{\n    vec3 c1p = vec3(0.0, c1p_y, 0.0);\n    vec3 c1d = vec3(c1dxz, c1dy, c1dxz);\n\n    //c1p.y = 0.0;// remove tile pattern\n\n    c1p.xz = (floor(rp.xz*c1ps+0.5))/c1ps;\n\n    bool isInsideC0 = IsInsideCube(rp, c0p, c0d);\n    bool isInsideC1 = IsInsideCube(rp, c1p, c1d);\n\n    if(isInsideC0 && isInsideC1)\n    {\n        float t0; vec3 n0;\n        Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n        if(IsInsideCube(rp+rd*t0, c0p, c0d))\n        {\n            if(hit <= 0.0 || t0 < t)\n            {\n                hit = 1.0;\n                t = t0;\n                n = n0;\n            \n                return true;\n            }\n        }\n    }\n    else\n    {\n        vec2 tt; vec3 n0, n1;\n        float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n        bool hit0 = th > 0.0;\n        if ( hit0 )\n        {\n            c1p.xz = (floor((rp.xz+rd.xz*tt.x)*c1ps+0.5))/c1ps;\n            \n            if(IsInsideCube(rp+rd*tt.x, c1p, c1d))\n            {\n                float t0; vec3 n0;\n                Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n                if(IsInsideCube(rp+rd*t0, c0p, c0d))\n                {\n                    if(hit <= 0.0 || t0 < t)\n                    {\n                        hit = 1.0;\n                        t = t0;\n                        n = n0;\n\n                        return true;\n                    }\n                }\n            }\n            else\n            {\n                if(hit <= 0.0 || tt.x < t)\n                {\n                    hit = 1.0;\n                    t = tt.x;\n                    n = n0;\n\n                    return true;\n                }\n            }\n\n        }        \n    }\n    \n    return false;\n}\n\nvec3 TransA(vec3 u, bool foo)\n{\n    if(foo)\n    {\n        u.xy = u.yx;\n        u.x *= -1.0;\n    }\n    else\n    {\n        u.x *= -1.0;\n        u.xy = u.yx;\n    }\n    \n    return u;\n}\n\nvec3 TransB(vec3 u, bool foo)\n{\n    if(foo)\n    {\n        u.zy = u.yz;\n        u.z *= -1.0;\n    }\n    else\n    {\n        u.z *= -1.0;\n        u.zy = u.yz;\n    }\n    \n    return u;\n}\n\n\nvoid Intersect_Ray_Plates(vec3 rp, vec3 rd, vec3 c0p, vec3 c0d, float c1p_y, float c1dxz, float c1dy, float c1ps,\n                         inout float hit, inout float t, inout vec3 n)\n{\n    rp.x += exp2(-18.0);\n    //if(false)\n    if(Intersect_Ray_Plate(TransA(rp, false), TransA(rd, false), c0p, c0d, c1p_y, c1dxz, c1dy, c1ps, /*inout*/ hit, t, n))\n    {\n        n = TransA(n, true);\n    }\n    //if(false)\n    if(Intersect_Ray_Plate(TransB(rp, false), TransB(rd, false), c0p, c0d, c1p_y, c1dxz, c1dy, c1ps, /*inout*/ hit, t, n))\n    {\n        n = TransB(n, true);\n    }    \n}\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n    float hit = 0.0;\n\n    float c1dxz = 0.4;\n    float c1ps = 0.85;\n\n    // ground plate thingy:\n    //if(false)\n    {\n        Intersect_Ray_Plate(rp, rd, vec3(0.0, -0.8, 0.0), vec3(2.0, 0.125*1.2, 2.0), -0.64, c1dxz,  0.125, c1ps, /*inout*/ hit, t, n);\n        \n        Intersect_Ray_Plates(rp, rd, vec3(0.0, -2., 0.0), vec3(2.0, 0.05, 2.0), -1.9, 0.2,  0.5, 2., /*inout*/ hit, t, n);\n    }\n    \n    // slim pillars:\n    //if(false)\n    {\n        float r = 0.125*0.25;\n        float u = 1.0/c1ps;\n        float l = 0.4;\n        float h = 1.0;\n        \n        vec3 c0p = vec3(c1dxz, l, c1dxz);\n         c0p = vec3(u - c1dxz, l, u - c1dxz);\n         c0p = vec3(u - c1dxz, l, c1dxz);\n        vec3 c0d = vec3(r, h, r);\n        \n        vec3 pa = vec3(u - c1dxz, l,     c1dxz);\n        vec3 pb = vec3(u - c1dxz, l, u - c1dxz);\n        vec3 pc = vec3(    c1dxz, l, u - c1dxz);\n        \n        //Intersect_Ray_Cube(rp, rd, c0p, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        #if 0\n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n        #endif\n        \n        pa = vec3(-pa.z, pa.y, pa.x);\n        pb = vec3(-pb.z, pb.y, pb.x);\n        pc = vec3(-pc.z, pc.y, pc.x);\n        \n        Intersect_Ray_Cube(rp, rd, pa, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pb, c0d, /*inout*/ hit, t, n);\n        Intersect_Ray_Cube(rp, rd, pc, c0d, /*inout*/ hit, t, n);\n    }\n    \n    // top sphere:\n    //if(false)\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    // bottom sphere:\n    if(false)\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0, -2.25, 0.0), 2.0, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x - vec3(0.0, -2.25, 0.0));\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    if(hit <= 0.0)\n    {\n        t = exp2(20.0);\n        n = vec3(0.0);\n        a = vec3(0.0);\n    }\n    \n    return hit;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// sampling routines\n//==========================================================================================================//\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nvec3 Sample_Sphere(vec2 s) { return Sample_Sphere(s.x, s.y); }\n\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// interleaved gradient noise | license: unclear\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat IGN(vec2 uv, uint frame)\n{\n    frame = frame % 64u;\n    \n    uv += 5.588238 * float(frame);\n    \n    return IGN(uv);\n}\n\n// linearizes uv using a Hilbert curve; tile dimension = 2^N\nuint EvalHilbertCurve(uvec2 uv, uint N)\n{\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by level)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////// low-discrepancy sobol noise\n//==========================================================================================================//\n// \"Shuffled Scrambled Sobol (2D)\" - https://www.shadertoy.com/view/3lcczS | license: unclear\n//  code taken from \"Practical Hash-based Owen Scrambling\" - http://www.jcgt.org/published/0009/04/01/\nuint reverse_bits(uint x) \n{\n    x = (((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1));\n    x = (((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2));\n    x = (((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4));\n    x = (((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8));\n    \n    return ((x >> 16) | (x << 16));\n}\n\n// license: unclear\nuint laine_karras_permutation(uint x, uint seed) \n{\n    x += seed;\n    x ^= x*0x6c50b47cu;\n    x ^= x*0xb82f1e52u;\n    x ^= x*0xc7afe638u;\n    x ^= x*0x8d22f6e6u;\n    \n    return x;\n}\n\n// license: unclear\nuint nested_uniform_scramble(uint x, uint seed) \n{\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    \n    return x;\n}\n\n// from https://www.shadertoy.com/view/3ldXzM | license: unclear\nuvec2 sobol_2d(uint index) \n{\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) \n    {\n        if((index & 1u) != 0u) \n        {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\n// license: unclear\nuvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) \n{\n    index = nested_uniform_scramble(index, seed);\n    \n    uvec2 p = sobol_2d(index);\n    \n    seed = seed * 2891336453u + 1u;\n    p.x = nested_uniform_scramble(p.x, seed );\n    seed = seed * 2891336453u + 1u;\n    p.y = nested_uniform_scramble(p.y, seed);\n   \n    return p;\n}\n\nuint shuffled_scrambled_sobol_angle01(uint x, uint seed) \n{\n    x = reverse_bits(x);\n    \n    x = laine_karras_permutation(x, seed);\n    \n    return x;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/ | license: public domain (http://unlicense.org/)\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/ | license: public domain (http://unlicense.org/)\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html | license: public domain (http://unlicense.org/)\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. O’Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash01x4(uvec4 v, uint seed) { return Float01(pcg4(v, seed)); }\nvec4 Hash01x4(uvec3 v, uint seed) { return Hash01x4(uvec4(v, 0u        ), seed); }\nvec4 Hash01x4(uvec2 v, uint seed) { return Hash01x4(uvec4(v, 0u, 0u    ), seed); }\nvec4 Hash01x4(uint  v, uint seed) { return Hash01x4(uvec4(v, 0u, 0u, 0u), seed); }\n\nvec3 Hash01x3(uvec4 v, uint seed) { return Float01(pcg4(v, seed).xyz); }\nvec3 Hash01x3(uvec3 v, uint seed) { return Float01(pcg3(v, seed)); }\nvec3 Hash01x3(uvec2 v, uint seed) { return Hash01x3(uvec3(v, 0u    ), seed); }\nvec3 Hash01x3(uint  v, uint seed) { return Hash01x3(uvec3(v, 0u, 0u), seed); }\n\nvec2 Hash01x2(uvec4 v, uint seed) { return Float01(pcg4(v, seed).xy); }\nvec2 Hash01x2(uvec3 v, uint seed) { return Float01(pcg3(v, seed).xy); }\nvec2 Hash01x2(uvec2 v, uint seed) { return Hash01x3(uvec3(v, 0u    ), seed).xy; }\nvec2 Hash01x2(uint  v, uint seed) { return Hash01x3(uvec3(v, 0u, 0u), seed).xy; }\n\nfloat Hash01(uvec4 v, uint seed) { return Float01(pcg4(v, seed).x); }\nfloat Hash01(uvec3 v, uint seed) { return Float01(pcg3(v, seed).x); }\nfloat Hash01(uvec2 v, uint seed) { return Float01(pcg3(uvec3(v, 0u), seed).x); }\nfloat Hash01(uint  v, uint seed) { return Float01(pcg(v, seed)); }\n\n\nvec4 Hash11x4(uvec4 v, uint seed) { return Float11(pcg4(v, seed)); }\nvec4 Hash11x4(uvec3 v, uint seed) { return Hash11x4(uvec4(v, 0u        ), seed); }\nvec4 Hash11x4(uvec2 v, uint seed) { return Hash11x4(uvec4(v, 0u, 0u    ), seed); }\nvec4 Hash11x4(uint  v, uint seed) { return Hash11x4(uvec4(v, 0u, 0u, 0u), seed); }\n\nvec3 Hash11x3(uvec4 v, uint seed) { return Float11(pcg4(v, seed).xyz); }\nvec3 Hash11x3(uvec3 v, uint seed) { return Float11(pcg3(v, seed)); }\nvec3 Hash11x3(uvec2 v, uint seed) { return Hash11x3(uvec3(v, 0u    ), seed); }\nvec3 Hash11x3(uint  v, uint seed) { return Hash11x3(uvec3(v, 0u, 0u), seed); }\n\nvec2 Hash11x2(uvec4 v, uint seed) { return Float11(pcg4(v, seed).xy); }\nvec2 Hash11x2(uvec3 v, uint seed) { return Float11(pcg3(v, seed).xy); }\nvec2 Hash11x2(uvec2 v, uint seed) { return Hash11x3(uvec3(v, 0u    ), seed).xy; }\nvec2 Hash11x2(uint  v, uint seed) { return Hash11x3(uvec3(v, 0u, 0u), seed).xy; }\n\nfloat Hash11(uvec4 v, uint seed) { return Float11(pcg4(v, seed).x); }\nfloat Hash11(uvec3 v, uint seed) { return Float11(pcg3(v, seed).x); }\nfloat Hash11(uvec2 v, uint seed) { return Float11(pcg3(uvec3(v, 0u), seed).x); }\nfloat Hash11(uint  v, uint seed) { return Float11(pcg(v, seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n       \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n    G-buffer rendering: vec4(world space normal.xyz, linear depth)\n    \n    Camera controls via mouse + shift key.\n*/\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n    \n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint frame = uint(iFrame);\n    \n    vec4 mouseAccu = ReadVar4(1, VAR_ROW);\n\n    PrepareCam(mouseAccu, USE_PERSPECTIVE_CAM_COND);\n    \n    vec3 rp, rd;\n    GetRay(uv0, /*out*/ rp, rd);\n    \n    float t; vec3 N; vec3 a;\n    Intersect_Scene(rp, rd, /*out:*/ t, N, a);    \n    \n    vec3 wpos = rp + rd * t;\n    \n    vec3 vpos = VPos_from_WPos(wpos);\n    \n    // N     : world space normal.xyz\n    // vpos.z: linear depth\n    outCol = vec4(N, vpos.z);\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n    \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n////////////////////////////////////////////////////////////////////////////////////// config\n//==================================================================================//\n\n/*\n    toggles:\n    \n    Tab  : toggle temporal accumulation on/off\n    Ctrl : toggle ortho cam off/on\n\n    U    : toggle UI off/on\n*/\n\n// when using white noise, GT-VBAO converges exactly to the reference\n//#define GTVBAO_USE_WHITE_NOISE\n//#define  REFAO_USE_WHITE_NOISE\n\n// #define USE_ANALYTICAL_RAYCASTING\n\nconst float Raymarching_SampleCount = 32.0;\nconst float Raymarching_Width = 512.0;\nconst float Thickness = 0.5;\n\n//==================================================================================//\n////////////////////////////////////////////////////////////////////////////////////// \n\n\nbool isLeft;// true on the left half of the screen; for debugging purposes\n\n#define KeyBoard iChannel3\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\n////////////////////////////////////////////////////////////////////////////////////// quaternion utils\n//==================================================================================//\n\nvec4 GetQuaternion(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float s  =   dot(from, to);\n\n    float u = inversesqrt(max(0.0, s * 0.5 + 0.5));// rcp(cosine half-angle formula)\n    \n    s    = 1.0 / u;\n    xyz *= u * 0.5;\n\n    return vec4(xyz, s);  \n}\n\nvec4 GetQuaternion(vec3 to)\n{\n    //vec3 from = vec3(0.0, 0.0, 1.0);\n\n    vec3 xyz = vec3(-to.y, to.x, 0.0);// cross(from, to);\n    float s  =                   to.z;//   dot(from, to);\n\n    float u = inversesqrt(max(0.0, s * 0.5 + 0.5));// rcp(cosine half-angle formula)\n    \n    s    = 1.0 / u;\n    xyz *= u * 0.5;\n\n    return vec4(xyz, s);  \n}\n\n// transform v by unit quaternion q.xyzs\nvec3 Transform(vec3 v, vec4 q)\n{\n    vec3 k = cross(q.xyz, v);\n    \n    return v + 2.0 * vec3(dot(vec3(q.wy, -q.z), k.xzy),\n                          dot(vec3(q.wz, -q.x), k.yxz),\n                          dot(vec3(q.wx, -q.y), k.zyx));\n}\n\n// transform v by unit quaternion q.xy0s\nvec3 Transform_Qz0(vec3 v, vec4 q)\n{\n    float k = v.y * q.x - v.x * q.y;\n    float g = 2.0 * (v.z * q.w + k);\n    \n    vec3 r;\n    r.xy = v.xy + q.yx * vec2(g, -g);\n    r.z  = v.z  + 2.0 * (q.w * k - v.z * dot(q.xy, q.xy));\n    \n    return r;\n}\n\n// transform v.xy0 by unit quaternion q.xy0s\nvec3 Transform_Vz0Qz0(vec2 v, vec4 q)\n{\n    float o = q.x * v.y;\n    float c = q.y * v.x;\n    \n    vec3 b = vec3( o - c,\n                  -o + c,\n                   o - c);\n    \n    return vec3(v, 0.0) + 2.0 * (b * q.yxw);\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// blue noise utils\n//==================================================================================//\n\n// increases bit depth of 8 bit per channel blue noise texture\nvec4 MixBlueNoiseBits(vec4 bnoise)\n{\n   const vec4 a = exp2(-vec4(0.0, 8.0, 16.0, 24.0));\n   const vec4 b = a / (a.x + a.y + a.z + a.w);\n\n   return vec4(dot(bnoise.xyzw, b), \n               dot(bnoise.yzwx, b), \n               dot(bnoise.zwxy, b), \n               dot(bnoise.wxyz, b));\n}\n\n// blue noise randomized via uv jittering\nvec4 BlueNoise01x4(uvec2 uv, uint n)\n{\n    const uint res = 1024u;\n\n    ivec2 uvi = ivec2((uv + (rPhi2 * n)) & (res - 1u));\n\n    return MixBlueNoiseBits(texelFetch(iChannel1, uvi, 0));\n}\n\n// blue noise randomized via value jittering\n// -> stratifies values along the time axis\nfloat BlueNoise01(uvec2 uv, uint n)\n{\n    const uint res = 1024u;\n\n    ivec2 uvi = ivec2(uv & (res - 1u));\n\n    float rnd01 = MixBlueNoiseBits(texelFetch(iChannel1, uvi, 0)).r;    \n\n    return Float01(uint(rnd01 * 4294967295.0) + rPhi1 * n);// == fract(rnd01 + rPhif1 * float(n));\n}\n\n//==================================================================================//\n////////////////////////////////////////////////////////////////////////////////////// \n\n\n////////////////////////////////////////////////////////////////////////////////////// GT-VBAO\n//==================================================================================//\n\n// returns 4 uniformly distributed rnd numbers [0,1]\n// rnd01.x/rnd01.xy -> used to sample a slice direction (exact importance sampling needs 2 rnd numbers)\n// rnd01.z -> used to jitter sample positions along ray marching direction\n// rnd01.w -> used to jitter sample positions radially around slice normal\nvec4 Rnd01x4(vec2 uv, uint n)\n{\n    uvec2 uvu = uvec2(uv);\n\n    vec4 rnd01 = vec4(0.0);\n        \n   #ifdef GTVBAO_USE_WHITE_NOISE\n    rnd01.xzw = Hash01x3(uvec3(uvu, n), 0x9CF617FAu);\n   #else\n    rnd01.x  = BlueNoise01  (uvu, n);\n  //rnd01.x  = IGN(floor(uv), n);\n  //rnd01.y  = unused\n    rnd01.zw = BlueNoise01x4(uvu, n).zw;\n   #endif\n    \n    return rnd01;\n}\n\n// https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel | license: public domain\nuint CountBits(uint v)\n{\n    v = v - ((v >> 1u) & 0x55555555u);\n    v = (v & 0x33333333u) + ((v >> 2u) & 0x33333333u);\n    return ((v + (v >> 4u) & 0xF0F0F0Fu) * 0x1010101u) >> 24u;\n}\n\nfloat SliceRelCDF_Uniform(float horCos, float sinN, bool isPhiLargerThanAngN)\n{\n    bool c = isPhiLargerThanAngN;\n\n    float m0 = c ? 1.0 : 0.0;\n    float m1 = c ?-0.5 : 0.5;\n\n    float d0 = m0 + m1 * horCos + (0.5 * sinN);\n    \n    return d0;\n}\n\nvec2 SliceRelCDF_Uniform(vec2 horCos, float sinN, bool isPhiLargerThanAngN)\n{\n    return vec2(SliceRelCDF_Uniform(horCos.x, sinN, isPhiLargerThanAngN),\n                SliceRelCDF_Uniform(horCos.y, sinN, isPhiLargerThanAngN));\n}\n\nfloat hemiGTVBAO(vec2 uv0, vec3 wpos, vec3 N, uint dirCount)\n{\n    vec3 positionVS = VPos_from_WPos(wpos);\n    vec3 normalVS   = VVec_from_WVec(N);\n    \n    vec3 V = isPerspectiveCam ? -normalize(positionVS) : vec3(0.0, 0.0, -1.0);\n    \n    vec2 rayStart = SPos_from_VPos(positionVS).xy;\n\n    uint frame = USE_TEMP_ACCU_COND ? uint(iFrame) : 0u;\n        \n    float ao = 0.0;\n    \n    for(uint i = 0u; i < dirCount; ++i)\n    {\n        uint n = frame * dirCount + i;\n        vec4 rnd01 = Rnd01x4(uv0, n);\n        \n        ////////////////////////////////////////////////// slice direction sampling\n        vec3 smplDirVS;// view space sampling vector\n        vec2 dir;// screen space sampling vector\n        {\n            dir = vec2(cos(rnd01.x * Pi), sin(rnd01.x * Pi));\n            smplDirVS = vec3(dir, 0.0);\n\n            if(isPerspectiveCam)\n            {\n                // set up View Vec Space -> View Space mapping\n                vec4 Q_toV = GetQuaternion(V);\n\n                smplDirVS = Transform_Vz0Qz0(dir, Q_toV);\n\n                vec3 rayStart = SPos_from_VPos(positionVS);\n                vec3 rayEnd   = SPos_from_VPos(positionVS + smplDirVS*(nearZ*0.5));\n\n                vec3 rayDir   = rayEnd - rayStart;\n\n                rayDir /= length(rayDir.xy);\n\n                dir = rayDir.xy;\n            }\n        }\n        //////////////////////////////////////////////////\n        \n        ////////////////////////////////////////////////// construct slice\n        float cosN, sinN, projNRcpLen;\n        {\n            vec3 sliceN = cross(V, smplDirVS);\n\n            vec3 projN = normalVS - sliceN * dot(normalVS, sliceN);\n\n            float projNSqrLen = dot(projN, projN);\n               if(projNSqrLen == 0.0) return 1.0;\n\n            vec3 T = cross(sliceN, projN);\n\n            projNRcpLen = inversesqrt(projNSqrLen);\n\n            cosN = dot(projN, V) * projNRcpLen;\n            sinN = dot(T    , V) * projNRcpLen;\n        }\n        //////////////////////////////////////////////////\n\n        // find horizons\n        uint occBits = 0u;\n        for(float d = -1.0; d <= 1.0; d += 2.0)\n        {\n            vec2 rayDir = dir.xy * d;\n            \n            const float count = Raymarching_SampleCount;\n            \n            const float s = pow(Raymarching_Width, 1.0/count);\n            \n            float t = pow(s, rnd01.z);// init t: [1, s]\n            \n            rnd01.z = 1.0 - rnd01.z;\n            \n            for (float i = 0.0; i < count; ++i)\n            {\n                vec2 samplePos = rayStart + rayDir * t;\n                \n                t *= s;\n                \n                // handle oob\n                if(samplePos.x < 0.0 || samplePos.x >= iResolution.x || samplePos.y < 0.0 || samplePos.y >= iResolution.y) break;\n                \n                float sampleDepth = textureLod(iChannel2, samplePos / Resolution.xy, 0.0).w;\n                \n                vec3 samplePosVS = VPos_from_SPos(vec3(samplePos, sampleDepth));\n\n                vec3 deltaPosFront = samplePosVS - positionVS;\n                vec3 deltaPosBack  = deltaPosFront - V * Thickness;\n                \n               #if 1\n                // required for correctness, but probably not worth to keep active in a practical application:\n                if(isPerspectiveCam)\n                {\n                   #if 1\n                    deltaPosBack = VPos_from_SPos(vec3(samplePos, sampleDepth + Thickness)) - positionVS;\n                   #else\n                    // also valid, but not consistent with reference ray marcher\n                    deltaPosBack = deltaPosFront + normalize(samplePosVS) * Thickness;\n                   #endif\n                }\n               #endif\n\n                // project samples onto unit circle and compute cos(angles) relative to V\n                vec2 horCos = vec2(dot(normalize(deltaPosFront), V), \n                                   dot(normalize(deltaPosBack ), V));\n\n                // sampling direction flips min/max cos(angles)\n                horCos = d >= 0.0 ? horCos.xy : horCos.yx;\n                \n                // map to slice relative distribution\n                vec2 hor01;// = SliceRelCDF_Uniform(horCos, sinN, d > 0.0);\n                {\n                    float d05 = d * 0.5;\n\n                    hor01 = ((0.5 + 0.5 * sinN) + d05) - d05 * horCos;\n                }\n\n                // jitter sample locations + clamp01\n                hor01 = clamp(hor01 + rnd01.w * (1.0/32.0), 0.0, 1.0);\n               \n                uint occBits0;// turn arc into bit mask\n                {\n                    uvec2 horInt = uvec2(floor(hor01 * 32.0));\n\n                    uint OxFFFFFFFFu = 0xFFFFFFFFu;// don't inline here! ANGLE bug: https://issues.angleproject.org/issues/353039526\n\n                    uint mX = horInt.x < 32u ? OxFFFFFFFFu <<        horInt.x  : 0u;\n                    uint mY = horInt.y != 0u ? OxFFFFFFFFu >> (32u - horInt.y) : 0u;\n\n                    occBits0 = mX & mY;            \n                }\n\n                occBits = occBits | occBits0;\n            }\n        }\n        \n        float occ0 = float(CountBits(occBits)) * (1.0/32.0);\n\n        ao += 1.0 - occ0;\n    }\n    \n    ao /= float(dirCount);\n    \n    return ao;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////// reference AO\n//==================================================================================//\n\nfloat ReferenceAO(vec2 uv0, vec3 wpos, vec3 N, uint dirCount)\n{\n    uvec2 uvu = uvec2(uv0);\n\n   #ifndef REFAO_USE_WHITE_NOISE\n    // randomly shift noise pattern around\n    if(USE_TEMP_ACCU_COND) uvu += Hash(uvec2(iFrame, 0u), 0xBD1E0BB0u).xy;\n\n    // linearize uv in a locality preserving way\n    uint pxId = EvalHilbertCurve(uvu, 9u);\n   #endif\n\n    vec3 positionVS = VPos_from_WPos(wpos);\n\n    uint frame = USE_TEMP_ACCU_COND ? uint(iFrame) : 0u;\n\n    float occ = 0.0;\n    \n    for(uint i = 0u; i < dirCount; ++i)\n    {\n        uint n = frame * dirCount + i;\n        \n      #ifdef REFAO_USE_WHITE_NOISE\n        vec2 s = Hash11x2(uvec3(uvu, n), 0x3579A945u);\n      #else\n        uint h = pxId * dirCount + i;\n        vec2 s = Float11(shuffled_scrambled_sobol_2d(h, 0xCC925D21u));\n      #endif\n        \n        vec3 rayDir = Sample_Sphere(s); \n        \n        // uniform weighted hemisphere\n        rayDir -= N * min(dot(rayDir, N) * 2.0, 0.0);// flip if on wrong side\n        \n       #ifdef USE_ANALYTICAL_RAYCASTING\n        {\n            float t; vec3 n; vec3 a;\n            occ += Intersect_Scene(wpos, rayDir, /*out:*/ t, n, a) > 0.0 ? 1.0 : 0.0;\n        }\n       #else\n        // ray march in screen space\n        if(isPerspectiveCam)\n        {\n            vec4 rayStart = PPos_from_WPos(wpos);\n            vec4 rayEnd   = PPos_from_WPos(wpos + rayDir * (nearZ * 0.5));\n            \n            float rwStart = 1.0 / rayStart.w;\n            float rwEnd   = 1.0 / rayEnd.w;\n            \n            vec2 tcStart = rayStart.xy * rwStart * 0.5 + 0.5;\n            vec2 tcEnd   = rayEnd.xy   * rwEnd   * 0.5 + 0.5;\n            \n            vec2  tcDelta0 = tcEnd - tcStart;\n            float rwDelta0 = rwEnd - rwStart;\n            \n            vec2  uvDelta0       = tcDelta0 * iResolution.xy;\n            float uvDelta0RcpLen = inversesqrt(dot(uvDelta0, uvDelta0));\n\n            // 1 px step size\n            vec2  tcDelta = tcDelta0 * uvDelta0RcpLen;\n            float rwDelta = rwDelta0 * uvDelta0RcpLen;\n            \n            float rnd01 = Hash01(uvec3(uvu, n), 0x2D56DA3Bu);\n\n            const float count = Raymarching_SampleCount;\n            \n            const float s = pow(Raymarching_Width, 1.0/count);\n            \n            float t = pow(s, rnd01);// init t: [1, s]\n\n            for (float i = 0.0; i < count; ++i)\n            {\n                vec2  tc = tcStart + tcDelta * t;\n                float rw = rwStart + rwDelta * t;\n\n                t *= s;\n\n                float depth = 1.0 / rw;\n\n                // handle oob\n                if(tc.x < 0.0 || tc.x >= 1.0 || tc.y < 0.0 || tc.y >= 1.0) break;\n                \n                float sampleDepth = textureLod(iChannel2, tc.xy, 0.0).w;\n\n                if(depth > sampleDepth && depth < sampleDepth + Thickness)\n                {\n                    occ += 1.0;\n                    \n                    break;\n                }\n             }\n        }\n        else\n        {\n            vec3 rayStart = SPos_from_WPos(wpos);\n            vec3 rayDir   = SVec_from_VVec_Ortho(VVec_from_WVec(rayDir));\n            \n            // 1 px step size\n            rayDir /= length(rayDir.xy);\n\n            float rnd01 = Hash01(uvec3(uvu, n), 0x2D56DA3Bu);\n\n            const float count = Raymarching_SampleCount;\n                        \n            const float s = pow(Raymarching_Width, 1.0/count);\n            \n            float t = pow(s, rnd01);// init t: [1, s]\n            \n            for (float i = 0.0; i < count; ++i)\n            {\n                vec3 samplePos = rayStart + rayDir * t;\n                \n                t *= s;\n\n                vec2 tc = samplePos.xy / iResolution.xy;\n\n                // handle oob\n                if(tc.x < 0.0 || tc.x >= 1.0 || tc.y < 0.0 || tc.y >= 1.0) break;\n                \n                float sampleDepth = textureLod(iChannel2, tc.xy, 0.0).w;\n\n                if(samplePos.z > sampleDepth && samplePos.z < sampleDepth + Thickness)\n                {\n                    occ += 1.0;\n                    \n                    break;\n                }\n            }\n        }\n       #endif\n    }\n    \n    occ /= float(dirCount);\n    \n    return 1.0 - occ;\n}\n\n//==================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    Resolution = iResolution.xy;\n    isLeft = uv0.x < iResolution.x * 0.5;\n    \n    vec4 mouseAccu  = ReadVar4(1, VAR_ROW);\n    float frameAccu = ReadVar (3, VAR_ROW);\n    \n    PrepareCam(mouseAccu, USE_PERSPECTIVE_CAM_COND);\n    \n    vec4 gbuffer = textureLod(iChannel2, uv0 / iResolution.xy, 0.0);\n    vec3  N     = gbuffer.xyz;\n    float depth = gbuffer.w;\n    \n    if(depth >= exp2(10.0))\n    {\n        outCol = vec4(0.0);\n        \n        return;\n    }\n    \n    vec3 spos = vec3(uv0, depth);\n    \n    vec3 wpos = WPos_from_SPos(spos);\n    // need a larger offset here when using uniform hemisphere weighting \n    // due to increased potential for self-shadowing\n    wpos += N * (4.0/1024.0);\n    \n    vec3 col = vec3(0.0);\n\n    float refao;\n    {\n        uint count = 2u;// set to 2 to make comparison fair since GTVBAO marches bidirectionally\n        \n        refao = ReferenceAO(uv0, wpos, N, count);\n    }\n    \n    float ssao;\n    {\n        uint count = 1u;\n        \n        ssao = hemiGTVBAO(uv0, wpos, N, count);\n    }\n    \n    col = vec3(refao, ssao, 0.0);\n    \n    // accumulate frames\n    if(USE_TEMP_ACCU_COND)\n    {\n        vec2 tc = uv0.xy / iResolution.xy;\n    \n        vec4 colLast = textureLod(iChannel0, tc, 0.0);\n\n        col = mix(colLast.rgb, col, 1.0 / (frameAccu));\n        \n        frameAccu += 1.0;\n        \n        outCol = vec4(col.rgb, frameAccu);\n        \n        return;\n    }\n   \n    outCol = vec4(col, 0.0);\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// https://twitter.com//status/1865464707282243843\n/*\n    Optimized version of uniformly weighted GT-VBAO (https://www.shadertoy.com/view/XXGSDd).\n    No more acos calls.\n    \n    I realized that the SliceRelCDF_Uniform(..) mapping could be simplified from:\n    \n        ...\n        \n        vec2 horAng = ACos(horCos) * d;\n\n        // shift relative angles from V to N + map to [0,1]\n        vec2 hor01 = clamp(horAng * RcpPi + angOff, 0.0, 1.0);\n\n        // sampling direction flips min/max angles\n        hor01 = d >= 0.0 ? hor01.xy : hor01.yx;\n        \n        // map to slice relative distribution\n        hor01 = SliceRelCDF_Uniform(hor01, angN, d > 0.0);\n        \n        ...\n        \n        float SliceRelCDF_Uniform(float x, float angN, bool isPhiLargerThanAngN)\n        {\n            if(x <= 0.0 || x >= 1.0) return x;\n\n            float phi = x * Pi - Pi05;\n\n            bool c = isPhiLargerThanAngN;\n\n            float m0 = c ? 2.0 : 0.0;\n            float m1 = c ?-1.0 : 1.0;\n\n            float d0 = 0.5 * (m0 + m1 * cos(angN - phi) + sin(angN));\n\n            return d0;\n        }\n    \n    down to:\n\n        ...\n        \n        // sampling direction flips min/max cos(angles)\n        horCos = d >= 0.0 ? horCos.xy : horCos.yx;\n\n        // map to slice relative distribution\n        vec2 hor01 = SliceRelCDF_Uniform(horCos, sinN, d > 0.0);\n        \n        ...\n        \n        float SliceRelCDF_Uniform(float horCos, float sinN, bool isPhiLargerThanAngN)\n        {\n            bool c = isPhiLargerThanAngN;\n\n            float m0 = c ? 2.0 : 0.0;\n            float m1 = c ?-1.0 : 1.0;\n\n            float d0 = 0.5 * (m0 + m1 * horCos + sinN);\n\n            return d0;\n        }.\n        \n    This eliminates all the arcus cosine calls.\n    \n    It doesn't look like this is possible for the cosine weighted GT-VBAO since SliceRelCDF_Cos(..) \n    uses phi directly and a good approximation of SliceRelCDF_Cos(..) that doesn't require phi might\n    be more expensive than just computing 'good enough' acos approximations to get horAng.xy.\n    \n    \n    Buffer A: input logic\n    Buffer B: g-buffer rendering\n    Buffer C: GT-VBAO + reference ray marcher/caster\n    Image   : documentation + presentation\n\n    Controls:\n    1: split screen comparison of GT-VBAO (left) and reference ray marcher (right)\n    2: GT-VBAO\n    3: reference ray marcher\n    4: grey-scale difference betwwen GT-VBAO and reference (white: too bright | black: too dark)\n    5: colored    difference betwwen GT-VBAO and reference (red  : too bright | blue : too dark)\n    6: blurred version of 4\n    7: blurred version of 5\n    -> options 4-7 only make sense to use with converged results\n\n    toggles:\n    \n    Tab  : toggle temporal accumulation on/off\n    Ctrl : toggle ortho cam off/on\n\n    U    : toggle UI off/on\n    \n    Camera controls via mouse + shift key.\n    \n    \n    Related/Sources:\n    \n        -  bidirectional GT-VBAO: https://www.shadertoy.com/view/XXGSDd\n        - unidirectional GT-VBAO: https://www.shadertoy.com/view/Xc3yzs\n        -  bidirectional GTAO+  : https://www.shadertoy.com/view/lctBzH\n        - unidirectional GTAO+  : https://www.shadertoy.com/view/4ctBRH\n\n        - optimized uniformly weighted, bidirectional GT-VBAO: https://www.shadertoy.com/view/4cdfzf\n\n        - Screen Space Indirect Lighting with Visibility Bitmask: the original VBAO\n          https://arxiv.org/abs/2301.11376\n          \n        - An overview of the original VBAO including source code (Olivier Therrien's blog): my initial implementation was based on this\n          https://cdrinmatane.github.io/posts/ssaovb-code/\n          \n        - Practical Real-Time Strategies for Accurate Indirect Occlusion: introduces GTAO, which VBAO is a variant of\n          https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf\n          \n        - Horizon Based Indirect Lighting (HBIL)\n          https://github.com/Patapom/GodComplex/tree/master/Tests/TestHBIL\n*/\n\n\n/*\n    This work is licensed under a dual license, public domain and MIT, unless noted otherwise. Choose the one that best suits your needs:\n     \n    CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n    To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n    \n    or\n    \n    The MIT License\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), \n    to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n    and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR \n    THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define KeyBoard iChannel2\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel3\n#define OutCol outCol\n#define OutChannel w\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n/////////////////////////////////////////////////////////////////////////////////// UI\n//===============================================================================//\n\nfloat glyph2(bool style, vec2 tc)\n{\n    float r0 = 10.0;\n    float r1 = 1.;\n    float b = max(abs(tc.x), abs(tc.y)) - r0;\n    float c = length(tc) - r0*0.9;\n    \n    b = max(b, -c);\n    \n    if(!style) if(r1 != 0.0) b = abs(b) - r1;\n    \n    b = max(b, -(abs(tc.x) - r1));\n    b = max(b, -(abs(tc.y) - r1));\n    \n    return 1.0 - clamp(b + 0.5, 0.0, 1.0);\n}\n\nfloat glyph(bool type, vec2 tc, float r0, float r1, bool separator)\n{\n    float b = (type ? length(tc) : max(abs(tc.x), abs(tc.y))) - r0;\n    \n    if(r1 != 0.0) b = abs(b) - r1;\n    \n    if(separator) b = max(b, -(abs(tc.x) - r1));\n    \n    return 1.0 - clamp(b + 0.5, 0.0, 1.0);\n}\n\nvec2 EvalUI(vec2 uv0, float id, bvec2 modes)\n{\n    vec2 s = vec2(30.0, 30.0);\n\n    vec2 uv = uv0;\n\n    vec2 uvI = floor(uv / s);\n    vec2 uvF = uv - uvI * s;\n\n    if(uvI.y > 0.0 || uvI.x < 0.0 || uvI.x > 3.0) { return vec2(0.0); }\n\n    vec2 tc = uvF-s*0.5;\n\n    float k = 0.35;\n    if(uvI.x == id) k = 0.9;\n\n    bool isSolid = false;\n\n    if(uvI.x == 0.0) \n    isSolid = tc.x   < 0.0 ? modes.x : modes.y;\n    else\n    isSolid = uvI.x == 1.0 ? modes.x : modes.y;\n    \n    bool type = uvI.x == 1.0;\n    if(uvI.x == 0.0) type = tc.x < 0.0;\n\n    float v = glyph(type, tc, 8.0, isSolid ? 0.0 : 2.0, uvI.x == 0.0);\n    if(uvI.x == 3.0) v = glyph2(modes.x || modes.y, tc);\n\n    //if(uvI.y > 0.0 || uvI.x < 0.0 || uvI.x > 3.0) { v = 0.0; k = 0.0; }\n\n    return vec2(v, k);\n}\n\n//===============================================================================//\n///////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution.xy;\n\n    float num = ReadVar(4, VAR_ROW);\n\n    ivec2 uv = ivec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n        \n    vec2 ao = textureLod(iChannel0, tex, 0.0).rg;\n    //num=1.0;\n    if(num == 0.0)// split screen: gtvbao | ray-marched reference\n    {\n        col = vec3(ao.y);\n    }\n    else if(num == 1.0)// gtvbao\n    {\n        col = vec3(ao.y);\n    }\n    else if(num == 2.0)// ray-marched reference\n    {\n        col = vec3(ao.x);\n    }\n    else if(num == 3.0 || num == 4.0)// visualize error\n    {\n        float diff = (ao.y - ao.x) * 8.0;\n        \n        if(num == 3.0)\n        {\n            col = vec3(0.5 + diff*2.0);\n        }\n        else// num == 4.0: gtvbao brighter than ref -> red | gtvbao darker than ref -> blue\n        {\n            col = abs(diff) * 3.0 * (diff > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.18, 1.0));\n        }\n    }\n    else if(num == 5.0 || num == 6.0)// visualize error blurred\n    {\n        float count = 10.0;\n        float wa = 0.0;\n        \n        for(float j = -count; j <= count; ++j)\n        for(float i = -count; i <= count; ++i)\n        {\n            vec2 o = vec2(i, j);\n            vec2 w2 = pow(1.0 - pow(abs(o)/(count+0.5), vec2(2.0)), vec2(1.0));\n            \n            float w = 1.0;\n            w = w2.x * w2.y;\n            \n            vec2 ao = textureLod(iChannel0, (uv0 + o) / iResolution.xy, 0.0).rg;\n            \n            float diff = (ao.y - ao.x) * 8.0;\n\n            vec3 col0;\n            \n            if(num == 5.0)\n            {\n                col0 = vec3(abs(diff));\n                col0 = vec3(0.5 + diff*2.0);\n            }\n            else\n            {\n                col0 = abs(diff) * 3.0 * (diff > 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.18, 1.0));\n            }\n        \n            col += col0 * w;\n            wa += w;\n        }\n        \n        col /= wa;\n    }\n    \n    #if 0\n    if(num < 3.0 && ReadKeyToggle(KEY_S) != 0.0)\n    {\n        // isolines\n        col = 1.0-(cos(col * 32.0) * 0.5 + 0.5);\n    }\n    #endif\n    \n    // highlight pixels green if they clip beneath 0 or above 1: \n    if(ReadKeyToggle(KEY_N) != 0.0)\n    if(col.r < 0.0 || col.r > 1.0 || col.g < 0.0 || col.g > 1.0 || col.b < 0.0 || col.b > 1.0) col.rgb = vec3(0.0, 1.0, 0.0);\n    \n    outCol = vec4(pow(clamp01(col), vec3(1.0/2.2)), 0.0);\n    \n    \n    if(SHOW_UI_COND)\n    {\n        bvec2 modes = bvec2(true);\n        \n        vec2 ui = EvalUI(uv0, min(num, 3.0), modes.xx);\n        \n        outCol.rgb = mix(outCol.rgb, vec3(ui.y) * mix(vec3(0., 0.6, 1.0), vec3(1.0), 0.9), ui.x);\n    }    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"McGfRz","date":"1733689209","viewed":230,"name":"GT-VBAO + glslSmartDenoise","username":"BrutPitt","description":"Test glslSmartDenoise my de noise filter on GT-VBAO (optimized by @TinyTexel)\n\nglslSmartDenoise: realtime filter to reduce noise in grained photo/video: works worse with great luminance difference between pixels (raytracing),but works better over GT-VBAO","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["ao","occlusion","ambient","gtao","vbao"],"hasliked":0,"parentid":"4cdfzf","parentname":"GT-VBAO (uniformly weighted)"}}