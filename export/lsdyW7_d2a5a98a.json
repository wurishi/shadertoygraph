{"ver":"0.1","info":{"id":"lsdyW7","date":"1519198493","viewed":228,"name":"rose_with_high_light","username":"thu_yumeng","description":"rose with fresnel reflection \nreference:https://www.shadertoy.com/view/XsdyWr\nhttps://www.shadertoy.com/view/4tyXDR\nhttps://www.shadertoy.com/view/4dfGDj","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fxaa","fresnel","rose","learn","relfection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//try fxAA\n//refs: https://www.shadertoy.com/view/4dfGDj\n#define FXAA_SPAN_MAX\t8.0\n#define FXAA_REDUCE_MUL 1.0/8.0\n#define FXAA_REDUCE_MIN 1.0/128.0\nvec3 Color(vec2 uv)\n{\n    return texture(iChannel0, uv).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 add = vec2(1.0) / iResolution.xy;\n\t\t\t\n\tvec3 rgbNW = Color(uv+vec2(-add.x, -add.y));\n\tvec3 rgbNE = Color(uv+vec2( add.x, -add.y));\n\tvec3 rgbSW = Color(uv+vec2(-add.x,  add.y));\n\tvec3 rgbSE = Color(uv+vec2( add.x,  add.y));\n\tvec3 rgbM  = Color(uv);\n\t\n\tvec3 luma\t = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\t\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\n\t\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\t\t  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\t\t  dir * rcpDirMin)) * add;\n\n\t\t\n\tvec3 rgbA = (1.0/2.0) * (Color(uv + dir * (1.0/3.0 - 0.5)) +\n\t\t\t\t\t\t\t Color(uv + dir * (2.0/2.0 - 0.5)));\n\t\n\tvec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) *\n\t\t(Color(uv.xy + dir * (0.0/3.0 - 0.5)) +\n\t\t Color(uv.xy + dir * (3.0/3.0 - 0.5)));\n\t\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))\n\t{\n\t\tfragColor.xyz=rgbA;\n\t}else\n\t{\n\t\tfragColor.xyz=rgbB;\n\t}\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// reference:\n// https://www.shadertoy.com/view/XsdyWr\n// https://www.shadertoy.com/view/4tyXDR\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n#define OBJECT_ABSORB       vec3(1.0, 8.0, 3.0) // for beers law\n\n// 记录内部光线追踪的宏\n#define MAX_RAY_BOUNCES 10\n\n// 光照物体相关宏\n#define OBJECT_REFLECTIVITY 0.01\n// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.01;\nconst float clip_far = 10.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// distance function\n\nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s) {\n    p = p * vec3(0.8, 1.5, 0.8) + vec3(0.1, 0.0, 0.0);\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n\n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n\n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0, s = 2.0;\n    mat3 r = rotationXY(vec2(0.1, PI2 * 0.618034));\n    r = r * mat3(1.08,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.08);\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.02, 0.0);\n        s *= 1.05;\n    }\n    return d;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = map( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.3;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nconst vec3 light_pos = vec3( 20.0, 50.0, 20.0 );\n\nvec3 shading(vec3 v, vec3 n, vec3 eye) {\n\tvec3 ev = normalize(v - eye);\n    vec3 mat_color = vec3(0.65,0.0,0.0);\n\n    vec3 vl = normalize(light_pos - v);\n\n    float diffuse = dot(vl, n) * 0.5 + 0.5;\n    vec3 h = normalize(vl - ev);\n    float rim = pow(1.0 - max(dot(n, -ev), 0.0), 2.0) * 0.15;\n    float ao = clamp(v.y * 0.5 + 0.5, 0.0, 1.0);\n    return (mat_color * diffuse + rim) * ao;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// 计算高光反射\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n\n    if (n1 > n2)\n    {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosX * cosX);\n        // 全反射情况\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0 - sinT2);\n    }\n    float x = 1.0 - cosX;\n    float ret = r0 + (1.0 - r0) *x*x*x*x*x;\n\n    ret = OBJECT_REFLECTIVITY + (1.0 - OBJECT_REFLECTIVITY) * ret;\n    // smooth the highlight to avoid white edges\n    float bright_edge = 0.8;\n   \tfloat ret_edge = 1.0 - step(bright_edge, ret);\n    ret = smoothstep(0.0, 0.8, ret) * ret_edge;\n    return ret;\n}\n\n// 计算折射和介质内反射\nvec3 GetInternalRayColor(in vec3 rayPos, in vec3 rayDir)\n{\n    vec3 multiplier = vec3(1.0);\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\n    // 主要计算花瓣薄片的折射衰减\n    for (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // find intersect point\n        float inner_depth = ray_marching(rayPos, rayDir, 0.0, clip_far);\n        // 当ray trace不与场景中的物体相交时返回折射衰减系数\n        if (inner_depth >= clip_far)\n            break;\n\n        // calculate beer's law absortion\n        absorbDistance += inner_depth;\n        vec3 absorb_color = exp(-OBJECT_ABSORB * absorbDistance);\n\n        // 光线追踪折射光线（去掉光线进入介质时的反射）\n        vec3 normal = gradient(rayPos);\n        float reflect_ratio = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, normal);\n      \tfloat refract_ratio = 1.0 - reflect_ratio;\n\n        // 本应该通过折射光线的方向计算折射光的颜色，这里由于背景颜色均为暗红色所以不计算对应方向颜色,只计算衰减\n        multiplier *= (refract_ratio * absorb_color);\n\n        // 反推入射光\n        rayDir = refract(rayDir, normal, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        rayPos += rayDir * 0.01;\n    }\n    ret = vec3(0.2, 0.0, 0.1) * multiplier;\n\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY(vec2(-1.0, 1.0));\n    if (iMouse.x > 0.0)\n\t\trot = rotationXY(iMouse.yx / iResolution.yx * vec2(PI, -2.0 * PI) + vec2(PI * -0.5, PI));\n\n\tdir = rot * dir;\n\teye = rot * eye;\n\n\t// ray marching\n\tfloat depth = ray_marching(eye, dir, 0.0, clip_far);\n    vec3 pos = eye + dir * depth;\n    vec3 c;\n    if (depth >= clip_far) {\n\t\tc = vec3(0.2, 0.0, 0.1);\n    }\n    else {\n        // shading\n        vec3 n = gradient( pos );\n        c = shading(pos, n, eye);\n\n        // 计算高光\n        float reflect_ratio = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, n, dir);\n        c += vec3(0.8, 0.0, 0.2)*reflect_ratio;\n    }\n\n    float r = 1.2 - length((fragCoord.xy / iResolution.xy) - 0.5) * 1.0;\n    fragColor = vec4(c * r, 1.0);\n}\n","name":"Buf A","description":"","type":"buffer"}]}