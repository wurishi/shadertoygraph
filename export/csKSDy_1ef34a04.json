{"ver":"0.1","info":{"id":"csKSDy","date":"1681563879","viewed":135,"name":"2D BVH Quadtree","username":"weasel","description":"This shader computes the bounding box of a pixel shape in a parallized way. In the process it creates a full quadtree. Note, the bounding boxes are a couple frame delayed from the video. To analyse a still frame, stop the view and drag with the mouse.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["2d","aabb","bvh","quadtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * This shader demonstrates the parallel computation of bounding boxes on the GPU.\n * It's quite a simple procedure, however to implement it in shadertoy I had to\n * do my own mipmap levels (the functions for those are in Common). In a real application\n * one would render all mipmap levels sequentially just like for a bloom effect or other\n * blurry effects. In that case one can pass the stuff from Common in as a uniform variable.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // determine the placement of the result (optimally this would be mipmap levels of a texture)\n    int max_level = getMaxLevel(iResolution);\n    vec4 max_section = getSection(max_level-1, iResolution);\n    vec4 aabb = texelFetch(iChannel0, ivec2(max_section.xy), 0);\n    \n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    fragColor += vec4(TEX(fragCoord));\n    \n    // draw aabb\n    if (aabb.x <= aabb.z) {\n        float line_thickness = 1.0;\n        float x = abs(fragCoord.x - (aabb.x+aabb.z)/2.0) - (aabb.z-aabb.x)/2.0;\n        float y = abs(fragCoord.y - (aabb.y+aabb.w)/2.0) - (aabb.w-aabb.y)/2.0;\n        if (abs(x) <= line_thickness && y < line_thickness\n           || abs(y) <= line_thickness && x < line_thickness)\n            fragColor = vec4(0, 1, 1, 1);\n    }\n    \n    /*\n    // draw the aabb buffer (debugging)\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (fragColor.x > fragColor.z)\n        fragColor = vec4(0,0,0,1);\n    /**/\n    // draw quad tree from level 2 to 6\n    for (int level = 2; level <= 6; level++) {\n        vec4 section = getSection(level, iResolution);\n        float fac = 0.5 * pow(0.5, float(level));\n        vec4 max_aabb = vec4(vec2(ivec2(fragCoord * fac)) / fac, vec2(ivec2(fragCoord * fac) + 1) / fac) + AABB_PADDING;\n        aabb = texelFetch(iChannel0, ivec2(fragCoord*fac + section.xy), 0);\n        // if the aabb\n        if (aabb.x <= aabb.z) {\n            // check if the aabb is valid (visual debugging)\n            if (aabb.x < max_aabb.x || aabb.y < max_aabb.y || aabb.z > max_aabb.z || aabb.w > max_aabb.w)\n                fragColor = vec4(1,0,1,1);\n            float line_thickness = 0.5;\n            float x = abs(fragCoord.x - (aabb.x+aabb.z)/2.0) - (aabb.z-aabb.x)/2.0;\n            float y = abs(fragCoord.y - (aabb.y+aabb.w)/2.0) - (aabb.w-aabb.y)/2.0;\n            if (abs(x) <= line_thickness && y < line_thickness\n               || abs(y) <= line_thickness && x < line_thickness)\n                fragColor = vec4(1, 0, 0, 1);\n        }\n    }\n    /**/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this buffer contains the splitting of the black white image into bounding boxes.\n// the data in this buffer is vec4(x0, y0, x1, y1) for AABBs\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5;\n    // determine the placement of the result (optimally this would be mipmap levels of a texture)\n    int max_level = getMaxLevel(iResolution);\n    // TODO determine from position\n    int level = getLevel(ivec2(fragCoord), iResolution);//iFrame % max_level;\n    vec4 section = getSection(level, iResolution);\n    float width = section.z;\n    float height = section.w;\n    \n    if (iFrame == 0 || level == -1) {\n        fragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    \n    // don't change out of bounds pixels\n    if (fragCoord.x < section.x || fragCoord.x >= section.x + width\n         || fragCoord.y < section.y || fragCoord.y >= section.y + height) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    if (level == 0) {\n        // compute 2x2 bounding boxes from image\n        vec2 coord = (fragCoord - section.xy) * 2.0;\n        float aa = TEX(coord + vec2(0.5, 0.5));\n        float ab = TEX(coord + vec2(0.5, 1.5));\n        float ba = TEX(coord + vec2(1.5, 0.5));\n        float bb = TEX(coord + vec2(1.5, 1.5));\n        vec4 aabb = vec4(iResolution.xy, 0.0, 0.0);\n        if (aa + ab + ba + bb > 0.0) {\n            aabb.x = coord.x + (1.0 - max(aa, ab));\n            aabb.z = coord.x + max(ba, bb);\n            aabb.y = coord.y + (1.0 - max(aa, ba));\n            aabb.w = coord.y + max(ab, bb);\n        }\n        \n        fragColor = aabb + AABB_PADDING;\n    }\n    else {\n        // combine bounding boxes from finer levels\n        vec4 section_fine = getSection(level - 1, iResolution);\n        float width_fine = section_fine.z;\n        float height_fine = section_fine.w;\n        vec2 coord = (fragCoord - section.xy) * 2.0 + section_fine.xy;\n        bool x_fine = coord.x + 1.0 < width_fine + section_fine.x;\n        bool y_fine = coord.y + 1.0 < height_fine + section_fine.y;\n        vec4 aabb1 = texelFetch(iChannel0, ivec2(coord + vec2(0.5, 0.5)), 0);\n        vec4 aabb2 = y_fine ? texelFetch(iChannel0, ivec2(coord + vec2(0.5, 1.5)), 0) : vec4(iResolution.xy, 0.0, 0.0);\n        vec4 aabb3 = x_fine ? texelFetch(iChannel0, ivec2(coord + vec2(1.5, 0.5)), 0) : vec4(iResolution.xy, 0.0, 0.0);\n        vec4 aabb4 = x_fine && y_fine ? texelFetch(iChannel0, ivec2(coord + vec2(1.5, 1.5)), 0) : vec4(iResolution.xy, 0.0, 0.0);\n        vec4 aabb = vec4(\n            min(min(aabb1.xy, aabb2.xy), min(aabb3.xy, aabb4.xy)),\n            max(max(aabb1.zw, aabb2.zw), max(aabb3.zw, aabb4.zw))\n        );\n        fragColor = aabb;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TEX(pos) float(length(texture(iChannel1, (vec2(ivec2(pos)) + vec2(0.5, 0.5))/iResolution.xy) - texture(iChannel1, (vec2(ivec2(pos)) + vec2(-0.5,0.5))/iResolution.xy))>0.1)\n\n// define a padding to make the bounding boxes a little bigger\n#define AABB_PADDING vec4(vec2(-0.0), vec2(0.0))\n\n\nvec4 getSection(int level, vec3 res) {\n#if 0\n    // for resolutions with a power of 2 we can do:\n    float lvl = float(level);\n    float x0 = res.x * (1.0 - pow(0.5, lvl));\n    float width = float(int(res.x * 0.5 * pow(0.5, lvl) - 0.5));\n    float height = float(int(res.y * 0.5 * pow(0.5, lvl) - 0.5));\n#else\n    // for general resolutions do the loop\n    // HACK: since this sum for x0 can be bigger than res.x,\n    //       we need to position the first level different.\n    if (level == 0)\n        return vec4(0.0, (int(res.y) + 1) / 3, (int(res.x) + 1) / 2, (int(res.y) + 1) / 2);\n    int width = ((int(res.x) + 1) / 2 + 1) / 2;\n    int height = ((int(res.y) + 1) / 2 + 1) / 2;\n    int x0 = 0;\n    for (int i = 1; i < level; i++) {\n        x0 += width;\n        width = (width + 1) / 2;\n        height = (height + 1) / 2;\n    }\n#endif\n    return vec4(float(x0), 0.0, float(width), float(height));\n}\n\nint getMaxLevel(vec3 res) {\n#if 0\n    // for resolutions with a power of 2 we can do:\n    return int(log(res.x) / log(2.0));\n#else\n    // for general resolutions do the loop:\n    int width = (int(res.x) + 1) / 2;\n    int height = (int(res.y) + 1) / 2;\n    int x0 = 0;\n    for (int i = 0; i < 100; i++) {\n        x0 += width;\n        width = (width + 1) / 2;\n        height = (height + 1) / 2;\n        if (width == 1 && height == 1)\n            return i+2;\n    }\n#endif\n}\n\n/* find level such that pos is inside getSection(level), otherwise return -1 */\nint getLevel(ivec2 pos, vec3 res) {\n    // slow but stable way to do this\n    int max_level = getMaxLevel(res);\n    for (int i = 0; i < max_level; i++) {\n        ivec4 section = ivec4(getSection(i, res) + vec4(0.5));\n        section.zw += section.xy;\n        if (pos.x >= section.x && pos.x < section.z && pos.y >= section.y && pos.y < section.w)\n            return i;\n    }\n    return -1;\n}","name":"Common","description":"","type":"common"}]}