{"ver":"0.1","info":{"id":"XXfyzj","date":"1726396074","viewed":18,"name":"sobel filter shader / cmcc","username":"Doris","description":"Based on http://en.wikipedia.org/wiki/Sobel_operator, can be used for edge detection.\nA very basic example to start other work from (and also my first submission to shadertoy ;) )","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["abasicsobelfiltershader"],"hasliked":0,"parentid":"Xdf3Rf","parentname":"Sobel Filter"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Basic sobel filter implementation\n// Jeroen Baert - jeroen.baert@cs.kuleuven.be\n// \n// www.forceflow.be\n\n\n// Use these parameters to fiddle with settings\nfloat step = 2.0;\n\nfloat intensity(in vec4 color, vec2 pos){\n float b = sin(color.b + iTime + pos.y) * 0.5 + 0.5; //sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n    float r = sin(0.1 + color.r + iTime + pos.x) * 0.5 + 0.5;\n    return b * r + b + r;\n}\n\nvec3 sobel(float stepx, float stepy, vec2 center){\n // get samples around pixel\n    float tleft = intensity(texture(iChannel0,center + vec2(-stepx,stepy)), center);\n    float left = intensity(texture(iChannel0,center + vec2(-stepx,0)), center);\n    float bleft = intensity(texture(iChannel0,center + vec2(-stepx,-stepy)), center);\n    float top = intensity(texture(iChannel0,center + vec2(0,stepy)), center);\n    float bottom = intensity(texture(iChannel0,center + vec2(0,-stepy)), center);\n    float tright = intensity(texture(iChannel0,center + vec2(stepx,stepy)), center);\n    float right = intensity(texture(iChannel0,center + vec2(stepx,0)), center);\n    float bright = intensity(texture(iChannel0,center + vec2(stepx,-stepy)), center);\n \n // Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\n //        1 0 -1     -1 -2 -1\n //    X = 2 0 -2  Y = 0  0  0\n //        1 0 -1      1  2  1\n \n // You could also use Scharr operator:\n //        3 0 -3        3 10   3\n //    X = 10 0 -10  Y = 0  0   0\n //        3 0 -3        -3 -10 -3\n \n    float x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n    float y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n    float color = sqrt((x*x) + (y*y));\n    color = pow(color, 2.0);\n    return vec3(color,color,color);\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 uv = fragCoord.xy / iResolution.xy;\n vec4 color = texture(iChannel0, uv.xy);\n fragColor.xyz = sobel(step/iResolution[0], step/iResolution[1], uv);\n    \n    float slider = iMouse.x / iResolution.x;\n    float effect = iMouse.y / iResolution.y;\n    \n    float grad = pow(1.0 - abs(uv.x - 0.5) * 2.0, 0.5);\n    grad *= pow(1.0 - abs(1.0 - uv.y) * 1.0, 0.25);\n    \n    grad = mix(grad, 1.0, slider);\n    \n    fragColor.xyz = color.xyz * (0.7 + 0.3 * effect) + fragColor.xyz * (0.7 - 0.7 * effect);\n    \n    \n    //fragColor.xyz *= grad; // * color.xyz;\n    \n    \n    fragColor.xyz = mix(fragColor.xyz, vec3(0.0, 0.0, 0.0), 1.0 - grad);\n    \n}","name":"Image","description":"","type":"image"}]}