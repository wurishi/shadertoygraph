{"ver":"0.1","info":{"id":"3t2cRz","date":"1620375712","viewed":175,"name":"Ray-traced disco whip","username":"Atchafalaya","description":"Computing the complex lighting emitted from a parametric curve.\nStill working on a better way to render the parametric curve itself by computing a better ray-curve intersection.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","curve","prametric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tfragColor = smartDeNoise(iChannel0, uv, 2.5, 2.0, .3);    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const uint nbSamples = 30u;\nconst uint nbMCSamples = 40u;\nconst float lineLightThickness = 0.13;\n\nconst float PI = 3.1415926535;\n\nconst vec3 camera_position = vec3(-13., 18., 10.);\nvec3 camera_target = vec3(-0.0, -0., 2.);\nconst float camera_hfovX = 0.5;\n\nfloat getHtanfovX()\n{\n    return camera_hfovX;\n}\nfloat getHtanfovY()\n{\n    return getHtanfovX() * iResolution.y / iResolution.x;\n}\n\nvec2 getMousePos()\n{\n    return vec2(iMouse.xy);\n}\n\nvec2 getResolution()\n{\n    return vec2(iResolution.xy);\n}\n\nvoid UpdateCameraTarget()\n{\n    vec3 toTarget = camera_target - camera_position;\n    vec2 angles = ((getMousePos() / getResolution())*2. - 1.);\n    mat2 roth = mat2(0.);\n    roth[0][0] = roth[1][1] = cos(angles.x);\n    roth[1][0] = sin(angles.x);\n    roth[0][1] = -sin(angles.x);\n    toTarget.xy = roth * toTarget.xy;\n    toTarget.z += angles.y*length(toTarget);\n    camera_target = camera_position + toTarget;\n}\n\nfloat getTimeInSecond()\n{\n    return iTime;\n}\n\nvec3 getReflectionRay(vec3 incomingRayDir, vec3 normal)\n{\n\treturn normalize(2. * dot(-incomingRayDir, normal) * normal + incomingRayDir);\n}\n\n//***********************************************************\n\nconst float SKY_DIST = 1e10;\nstruct Material\n{\n    vec3 diffuse;\n    float roughness;\n};\n    \nstruct Object\n{\n    uint type;\n    vec3 pos;\n    vec3 scale;\n    Material material;\n};\n\nstruct RayPayload\n{\n    Object object;\n    float dist;\n    vec3 normal;\n    Material material;\n};\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\nconst uint OBJECT_TYPE_PLANE = 0u;\nconst uint OBJECT_TYPE_AABB = 1u;\nconst uint OBJECT_TYPE_SPHERE = 2u;\nconst uint OBJECT_TYPE_DISCO_WHIP = 3u;\n\nstruct Camera \n{\n    mat4 projToWorld;\n    mat4 camToWorld;\n    vec2 halfTanFov;\n};\n \nCamera MakeCamera(vec3 position, vec3 target, vec2 tanHalfFov)\n{\n    vec3 up = vec3(0., 0., 1.);\n    \n    float nearZ = 0.1;\n    float farZ = 1000.;\n    float zRange = farZ - nearZ;\n    float ooRange = 1. / zRange;\n    float foRange = farZ* ooRange;\n    \n    \n    vec3 camZ = normalize(target - position);\n    vec3 camX = normalize(cross(camZ, up));\n    vec3 camY = cross(camZ, camX);\n    \n    \n    mat4 PInv = mat4(0.);\n    \n    PInv[0][0] = tanHalfFov.x;\n    PInv[1][1] = tanHalfFov.y;\n \n    PInv[3][2] = 1.;\n        \n    PInv[0][3] = 0.;\n    PInv[1][3] = 0.;\n    PInv[2][3] = 1./(-nearZ*foRange);\n    PInv[3][3] = 1./nearZ;\n    Camera result;\n    \n    mat4 camToWorld;\n    camToWorld[0] = vec4(camX, 0.);\n    camToWorld[1] = vec4(camY, 0.);\n    camToWorld[2] = vec4(camZ, 0.);\n    camToWorld[3] = vec4(position, 1.);\n    \n    result.camToWorld = camToWorld;\n    result.projToWorld = camToWorld * PInv;\n    return result;\n}\n\nRay GenerateCameraRay(vec2 uv)\n{ \n    UpdateCameraTarget();\n\n    Camera cam = MakeCamera(camera_position, camera_target, vec2(getHtanfovX(), getHtanfovY()));\n    Ray ray;\n    ray.orig = cam.camToWorld[3].xyz;\n    vec2 screenPosm11 = uv * 2. - 1.;\n    vec4 dirw4 = cam.projToWorld*vec4(screenPosm11, 1, 1);\n    ray.dir = normalize((dirw4).xyz);\n    return ray;\n}  \n\nRayPayload IntersectPlane(Object object, Ray ray, float tmin, float tmax)\n{\n    RayPayload result;\n    result.dist = tmax;\n    if (ray.dir.z * ray.orig.z >= 0.)\n        return result;\n    result.dist = -ray.orig.z/ray.dir.z;\n    result.normal = vec3(0,0,1);\n    return result;\n}\n\n\nRayPayload IntersectAABB(Object object, Ray ray, float tmin, float tmax)\n{\n    RayPayload result;\n    result.dist = SKY_DIST;\n\n    vec3 boxMin = object.pos - object.scale;\n    vec3 boxMax = object.pos + object.scale;\n    vec3 tMin = (boxMin - ray.orig) / ray.dir;\n    vec3 tMax = (boxMax - ray.orig) / ray.dir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if (tNear > tFar) {\n        // No intersection\n        return result;\n    }\n    result.dist = tNear;\n    if (t1.x == tNear){\n        result.normal = vec3(1., 0., 0.) * sign(ray.dir.x);\n    }\n    else if (t1.y == tNear){\n        result.normal = vec3(0., -1., 0.) * sign(ray.dir.y);\n    }\n    else {\n        result.normal = vec3(0., 0., -1.) * sign(ray.dir.z);\n    }\n    result.material = object.material;\n\n    return result;\n}\n\nbool solveQuadratic(float a, float b, float c, inout float x1, inout float x2)\n{\n    float delta = b*b - 4. * a * c;\n    if (delta < 0.) {\n        return false;\n    }\n    else if (delta == 0.) {\n        x1 = - 0.5 * b / a;\n        x2 = x1;\n    }\n    else{\n        x1 = 0.5 * (- b + sqrt(delta)) / a;\n        x2 = 0.5 * (- b - sqrt(delta)) / a;\n    }\n    return true;\n}\n\nRayPayload IntersectSphere(Object object, Ray ray, float tmin, float tmax)\n{\n    RayPayload result;\n    result.dist = SKY_DIST;\n    float radius = object.scale.x; \t\t// only homothetic scaling is supported for spheres\n    vec3 center = object.pos;\n    float x1 = SKY_DIST;\n    float x2 = SKY_DIST;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(ray.dir, ray.orig - center);\n    float c = dot(ray.orig - center, ray.orig - center) - radius * radius;\n    if (solveQuadratic(a, b, c, x1, x2)) {\n        x1 = min(max(x1, 0.), max(x2, 0.));\n        if (x1 < 0.) {\n            return result;\n        }\n        else {\n            result.dist = x1;\n            result.normal = normalize(ray.orig + x1 * ray.dir - center);\n            result.material = object.material;\n        }\n    }\n    return result;\n}\n\nstruct LightEmitterSample\n{\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 LissajouCol(float u )\n{\n    float a = u*2.*PI;\n    return 0.5+0.5*vec3(cos(5.*a+getTimeInSecond()), sin(3.*a), cos(7.*a+1.3*getTimeInSecond()));\n}\n\nvec3 LightEmitterObjectDiffuseCol(float u)\n{\n    vec3 col = LissajouCol(u);\n    return col * (fract(u*100.)>0.5 ? 1. : 0.2);\n}\n\nLightEmitterSample LightEmitter(float u)\n{\n    LightEmitterSample result;\n    result.color = vec3(1.);\n    result.pos = vec3(0.5,6,4.4);\n    if (false)\n    {\n        //rod\n        result.pos = vec3(-5,2,3);\n        float ra = getTimeInSecond();\n        float c = cos(ra);\n        float s = sin(ra);\n        result.pos += vec3(vec2(c,s)*10.,0.)*(2.*u-1.) + vec3(13., 3., -2.);\n        result.color = LissajouCol(u);\n        return result;\n    }\n    else if (false)\n    {\n        //circle\n        float r = 9.;\n        float a = u*2.*PI;\n        result.pos.xz += r*vec2(cos(a), sin(a));\n        result.color = LissajouCol(u);\n\n        return result;\n    }\n    else if (true)\n    {\n        //lissajou\n        float r = 2.;\n        float a = u*2.*PI;\n        result.pos += r*vec3(cos(5.*a+getTimeInSecond()), sin(3.*a), 2. * cos(2.*a+1.3*getTimeInSecond()));\n        result.color = LissajouCol(u);\n        //result.color *= 100;\n        return result;\n    }\n}\n\nstruct LightSegmentSample {\n    float t;\n    vec3 diffuseCol;\n    float distFromRay;\t    // distance between a ray and the light segment\n    LightEmitterSample le;\n};\n\n/// fragPos is the position in world coordinates of the fragment to illuminate\n/// u0 and u1 must be between 0 and 1\n/// ray must be normalized\nLightSegmentSample GetLineSegmentInterpolation(vec3 fragPos, float u0, float u1, vec3 ray)\n{\n    // This function returns a point light equivalent that lies at the closest point \n    // of the line segment light to the ray.\n    LightEmitterSample le0 = LightEmitter(u0);\n    LightEmitterSample le1 = LightEmitter(u1);\n    // Reposition lights' positions along the ray direction (like an orthographic projection)\n    vec3 pos0 = (le0.pos - fragPos) - dot((le0.pos - fragPos), ray) * ray;\n    vec3 pos1 = (le1.pos - fragPos) - dot((le1.pos - fragPos), ray) * ray;\n\t// Compute the interpolation parameters\n    LightSegmentSample result;\n    result.t = 0.;\n    if (pos0 != pos1){\n        result.t = dot(-pos0, pos1 - pos0) / dot(pos1 - pos0, pos1 - pos0);\n    } \n    if (result.t > 0. && result.t < 1.){\n        vec3 lightPos = LightEmitter(mix(u0, u1, result.t)).pos;\n\t\tlightPos = (lightPos - fragPos) - dot((lightPos - fragPos), ray) * ray;\n        result.distFromRay = length(lightPos);\n    }\n    else {\n        result.distFromRay = sqrt(max(dot(pos0, pos0), dot(pos1, pos1)));\n    }\n    result.t = clamp(result.t, 0., 1.);\n    result.le.pos = mix(le0.pos, le1.pos, result.t);\n    result.le.color = mix(le0.color, le1.color, result.t);\n    result.diffuseCol = LightEmitterObjectDiffuseCol(mix(u0, u1, result.t));\n    return result;\n}\n\nRayPayload IntersectDiscoWhip(Object object, Ray ray, float tmin, float tmax)\n{\n    RayPayload raypay;\n    raypay.dist = tmax;\n    for(uint i = 0u; i < nbSamples; i++)\n    {\n        float u0 = float(i) / float(nbSamples);\n        float u1 = float(i + 1u) / float(nbSamples);\n            \n\t\tLightSegmentSample ls = GetLineSegmentInterpolation(ray.orig, u0, u1, ray.dir);\n        if (ls.distFromRay < lineLightThickness\n            && dot(ls.le.pos - ray.orig, ls.le.pos - ray.orig) < raypay.dist * raypay.dist)\n        {\n\t\t    raypay.dist = distance(ls.le.pos, ray.orig);\n            raypay.material = Material(ls.diffuseCol, 1.);\n        }\n    }\n    return raypay;\n}\n\nconst Object objects[] = Object[] (\n    Object(OBJECT_TYPE_PLANE, vec3(0,0,0), vec3(1,1,1), Material(0.6*vec3(0.05,0.1,0.3), 0.08)),\n    Object(OBJECT_TYPE_AABB, vec3(2,0,1), vec3(1,1,1), Material(vec3(1.,0.5,0.), 1.)),\n    Object(OBJECT_TYPE_AABB, vec3(6,0,1), vec3(1,1,1), Material(vec3(0.,0.1,1.), 0.1)),\n    Object(OBJECT_TYPE_SPHERE, vec3(10,2,2), vec3(2,2,2), Material(vec3(0.5), 1.)),\n    Object(OBJECT_TYPE_SPHERE, vec3(10,8,2), vec3(2,2,2), Material(vec3(0.), 0.005)),\n    Object(OBJECT_TYPE_DISCO_WHIP, vec3(0.5,6,4.4), vec3(1,1,1), Material(vec3(1.), 1.))    \n);\n\nRayPayload IntersectObject(Object object, Ray ray, float tmin, float tmax)\n{\n    RayPayload result;\n    result.dist = tmax;\n    switch(object.type)\n    {\n        case OBJECT_TYPE_PLANE: result = IntersectPlane(object, ray, tmin, tmax); break;\n        case OBJECT_TYPE_AABB: result = IntersectAABB(object, ray, tmin, tmax); break;\n        case OBJECT_TYPE_SPHERE: result = IntersectSphere(object, ray, tmin, tmax); break;\n        case OBJECT_TYPE_DISCO_WHIP: result = IntersectDiscoWhip(object, ray, tmin, tmax); break;\n    };\n    if (result.dist < tmax) \n    {\n        if (object.type != OBJECT_TYPE_DISCO_WHIP)\n        {\n        \tresult.material = object.material;\n        }\n\t\tresult.object = object;\n    }\n    \n    return result;\n}\n\nRayPayload IntersectScene(Ray ray, float tmin, float tmax)\n{\n    RayPayload result;\n    result.dist = tmax;\n    for (uint i = 0u; i < uint(objects.length()); ++i)\n    {\n        RayPayload interi = IntersectObject(objects[i], ray, tmin, tmax);\n        if (interi.dist < result.dist && interi.dist >= tmin)\n        {\n            result = interi;\n            interi.material = objects[i].material;\n            tmax = result.dist;\n        }\n    }\n    return result;\n}\n\nvec3 SampleSky(vec3 dir)\n{\n    vec3 topCol = vec3(0.1,0.1, 0.4);\n    vec3 horizonCol = 0.56*vec3(0.4,0.6,0.8);\n    return 0.3*mix(horizonCol, topCol, clamp(dir.z, 0.f, 1.f));\n}\n\n//Shlick approx\nvec3 FresnelTermApprox(vec3 toEye, vec3 halfVec, vec3 minVal)\n{\n    return minVal + (1. - minVal)*pow(1. - dot(toEye, halfVec), 5.);\n}\n\nfloat MicrofacetDistribution(vec3 toEye, vec3 reflectedRay, float roughness)\n{\n    float alpha = roughness * roughness;\n    float dotER = dot(toEye, reflectedRay);\n    float f = (dotER * alpha - dotER) * dotER + 1.;\n    return alpha / (PI * f * f);\n}\n\nstruct LightSampleResult\n{\n    vec3 debug;\n    vec3 contrib;\n    vec3 diffuseContrib; //not dot normal light\n    vec3 specularContrib; //not dot normal light\n    vec3 diffuseContribDNL;\n    vec3 specularContribDNL;\n    bool isShadowed;\n};\n\nLightSampleResult SampleLight(vec3 pos, vec3 normal, vec3 toEye, vec3 lightPos, vec3 lightColor, Material material, bool useShadows)\n{\n    vec3 toLight = lightPos-pos;\n    float dnl = dot(normal, toLight);\n    LightSampleResult result;\n    result.contrib = vec3(0.);\n    result.isShadowed = false;\n    if (dnl <= 0.)\n        return result;\n    float toLightLength = length(toLight);\n    float ooToLightLength = 1./toLightLength;\n    dnl *= ooToLightLength;\n    vec3 toLightN = toLight*ooToLightLength;\n    if (useShadows)\n    {\n        Ray ray;\n        ray.orig = pos;\n        ray.dir = toLightN;\n        RayPayload rpl = IntersectScene(ray, 1e-3, toLightLength);\n        if (rpl.dist < toLightLength && rpl.object.type != OBJECT_TYPE_DISCO_WHIP)\n        {\n            result.isShadowed = true;\n            return result;   \n        }\n    }\n    vec3 hvec = normalize(toLightN+toEye);\n    vec3 f0 = vec3(0.005);\n    vec3 fresnel = FresnelTermApprox(toEye, hvec, f0);\n    if (material.roughness < 1.)\n    {\n        float D = MicrofacetDistribution(normal, hvec, material.roughness);\n        result.specularContrib = fresnel * D;\n    }\n    else\n    {\n        result.specularContrib = vec3(0.);\n    }\n    result.diffuseContrib = (1./PI) * (1. - fresnel) * material.diffuse;\n\t\n    result.diffuseContribDNL = lightColor * result.diffuseContrib * (dnl * pow(ooToLightLength, 1.5));\n    result.specularContribDNL = lightColor * result.specularContrib * (dnl * ooToLightLength * ooToLightLength);\n    result.contrib = result.diffuseContribDNL + result.specularContribDNL;\n    return result;\n}\n\nvec3 SampleScene(Ray ray, float tmin, float tmax)\n{\n    vec3 result = vec3(0);\n    RayPayload rayres = IntersectScene(ray, tmin, tmax);\n\n    if (rayres.dist < tmin || rayres.dist >= tmax)\n    {\n        result = SampleSky(ray.dir);\n    }\n    else if(rayres.object.type == OBJECT_TYPE_DISCO_WHIP){\n        return rayres.material.diffuse;\n    }\n    else\n    {\n        vec3 pos = ray.orig + ray.dir * rayres.dist;\n        vec3 reflectRay = getReflectionRay(ray.dir, rayres.normal);\n\n        // Disco whip light\n\t\tfor (uint i = 0u; i < nbMCSamples; i++) {\n            float u = random(pos.xy * random(float(i) + 1.));\n            LightEmitterSample le = LightEmitter(u);\n            LightSampleResult lr = SampleLight(pos, rayres.normal, -ray.dir, le.pos, le.color, rayres.material, true);\n            result += 100. * lr.contrib;\n        }\n    }\n    return result / float(nbMCSamples);\n}\n\nvec4 renderMain(vec2 uv)\n{\n    Ray ray = GenerateCameraRay(uv);\n    vec4 ocol = vec4(1,0,0,1);\n    vec3 diffuse = SampleScene(ray, 1e-6, SKY_DIST);\n    ocol.xyz = diffuse;\n    \n    ocol.xyz = pow(ocol.xyz, vec3(0.35));\n    // Output to screen\n    return ocol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/getResolution();\n    uv.y = 1.-uv.y;\n    fragColor = renderMain(uv);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Denoiser by Michele Morrone https://github.com/BrutPitt\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//  Copyright (c) 2018-2019 Michele Morrone\n//  All rights reserved.\n//\n//  https://michelemorrone.eu - https://BrutPitt.com\n//\n//  me@michelemorrone.eu - brutpitt@gmail.com\n//  twitter: @BrutPitt - github: BrutPitt\n//  \n//  https://github.com/BrutPitt/glslSmartDeNoise/\n//\n//  This software is distributed under the terms of the BSD 2-Clause license\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI\n#define INV_PI 0.31830988618379067153776752674503\n\n//  smartDeNoise - parameters\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//  sampler2D tex     - sampler image / texture\n//  vec2 uv           - actual fragment coord\n//  float sigma  >  0 - sigma Standard Deviation\n//  float kSigma >= 0 - sigma coefficient \n//      kSigma * sigma  -->  radius of the circular kernel\n//  float threshold   - edge sharpening threshold \n\nvec4 smartDeNoise(sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold)\n{\n    float radius = round(kSigma*sigma);\n    float radQ = radius * radius;\n    \n    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)\n    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)\n    \n    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)\n    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)\n    \n    vec4 centrPx = texture(tex,uv);\n    \n    float zBuff = 0.0;\n    vec4 aBuff = vec4(0.0);\n    vec2 size = vec2(textureSize(tex, 0));\n    \n    for(float x=-radius; x <= radius; x++) {\n        float pt = sqrt(radQ-x*x);  // pt = yRadius: have circular trend\n        for(float y=-pt; y <= pt; y++) {\n            vec2 d = vec2(x,y);\n\n            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI; \n            \n            vec4 walkPx =  texture(tex,uv+d/size);\n\n            vec4 dC = walkPx-centrPx;\n            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;\n                                 \n            zBuff += deltaFactor;\n            aBuff += deltaFactor*walkPx;\n        }\n    }\n    return aBuff/zBuff;\n}\n\n/*\n    static.frag\n    by Spatial on https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n    05 July 2013\n*/\n\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n","name":"Common","description":"","type":"common"}]}