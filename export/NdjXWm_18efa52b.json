{"ver":"0.1","info":{"id":"NdjXWm","date":"1620379933","viewed":122,"name":"Rotating Meander","username":"nowhales","description":"A circular rotating Greek meander pattern.\n\nVersion1: Veeery slow, my first time writing glsl, best not use this as a reference :). I'm following thebookofshaders.com.\nVersion2: Went from 32 to 60fps on my laptop.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["circular","greek","meander"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VERSION (2)\n\n#if VERSION == 2\n#define PI (3.14159)\n\nfloat circle(in vec2 uv, in float radius)\n{\n    return smoothstep(radius+(radius*0.001),\n                      radius-(radius*0.001),\n                      dot(uv, uv) * 4.0);\n}\n\nmat2 rotate2d(in float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat circleOutline(in vec2 uv, in float outerRadius, in float innerRadius)\n{\n    return min(circle(uv, outerRadius), (1.0-circle(uv, innerRadius)));\n}\n\n#define LAYERS (5)\n#define STEPS (16)\n#define REPS (8)\n\nfloat pattern(int y, int x)\n{\n    if(x < 0 || x >= STEPS) return 0.;\n    if(y < 0 || y >= LAYERS) return 0.;\n#if 0\n    float p[STEPS*LAYERS] = float[STEPS*LAYERS](\n        1., 1., 1., 1., 1., 0., 1., 1., 1., 0., 1., 0., 1., 1., 1., 0.,\n        1., 0., 0., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.,\n        1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.,\n        1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 0., 0.,\n        1., 0., 1., 1., 1., 0., 1., 0., 1., 1., 1., 0., 1., 1., 1., 1.\n    );\n    return p[y * STEPS + x];\n#else\n    if(x == 5 || x == 11) return 0.;\n    if(x == 0 || x == 4 || x == 6 || x == 8 || x == 10 || x == 12) return 1.;\n    if(x == 1 && y != 0) return 0.;\n    if(x == 2 && y == 1) return 0.;\n    if(x == 3 && (y != 0 && y != 4)) return 0.;\n    if(x == 7 && y != 0) return 0.;\n    if(x == 9 && y != 4) return 0.;\n    if(x == 13 && (y != 0 && y != 4)) return 0.;\n    if(x == 14 && y == 3) return 0.;\n    if(x == 15 && y != 4) return 0.;\n    \n    return 1.0;\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec2 origuv = uv;\n    uv = rotate2d(iTime/8.) * uv;\n    \n    float pat = atan(uv.x, uv.y) / (2.0*PI) + 0.5;\n    int idx = int(floor(fract(pat * float(REPS)) * float(STEPS)));\n\n    // First pattern\n    float outer = 0.3;\n    float inner = 0.15;\n    float y = (dot(uv, uv) * 4.0 - inner) / (outer - inner);\n    int idy = int(floor(y * float(LAYERS)));\n    \n    float on = pattern(idy, idx) * circleOutline(uv, outer, inner);\n    vec3 col1 = on * vec3(1.0, 0.4, 0.2);\n    \n    // Second pattern\n    outer = 0.14;\n    inner = 0.085;\n    uv = rotate2d(-iTime/16.0) * origuv;\n    pat = atan(uv.x, uv.y) / (2.0*PI) + 0.5;\n    idx = int(floor(fract(pat * float(REPS)) * float(STEPS)));\n    y = (dot(uv, uv) * 4.0 - inner) / (outer - inner);\n    idy = int(floor(y * float(LAYERS - 1)) + 1.);\n    \n    on = pattern(idy, idx) * circleOutline(uv, outer, inner);\n    vec3 col2 = vec3(on);\n    \n    vec3 color = col1 + col2;\n    fragColor = vec4(color, 1.0);\n}\n#endif\n\n\n\n#if VERSION == 1\n\n#define PI (3.14159)\n\nfloat circle(in vec2 st, in float radius)\n{\n\treturn smoothstep(radius+(radius*0.001),\n                      radius-(radius*0.001),\n                      dot(st,st)*4.0);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat circleOutline(in vec2 st, in float radius, in float width)\n{\n    return min(circle(st, radius), (1.0-circle(st, radius - width)));\n}\n\nfloat mask(in vec2 uv, in float angle, in float width)\n{\n    uv = rotate2d(angle) * uv;\n    float slice = smoothstep(0.0, 0.001, uv.x);\n    uv = rotate2d(width) * uv;\n    slice -= smoothstep(0.0, 0.001, uv.x);\n    slice = abs(slice);\n    return slice;\n}\n\nfloat layer(in vec2 uv, in float[34] arr, in int start, in int arrlen, in float lw,\n            in int ln, in int repeat, in float patlen, in float unit, in float circSize)\n{\n    float pat = circleOutline(uv, circSize * (1.0 - lw*float(ln)), circSize*lw);\n    for(int i = start; i < start + arrlen; ++i)\n    {\n        vec2 uv2 = uv;\n        for(int j = 0; j < repeat; ++j)\n        {\n            pat -= mask(uv2, arr[i]*unit, unit);\n            uv2 = rotate2d(patlen) * uv2;\n        }\n    }\n    return clamp(pat, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec2 origuv = uv;\n\n    uv = rotate2d(iTime/8.) * uv;\n\n    // half circle repeats\n    int repeat = 4;\n    int steps = 16;\n    float lw = 0.1;\n\n    float patlen = PI / float(repeat);\n    float unit = patlen / float(steps);\n\n    float pattern[34] = float[34](\n        5., 9., 11., 15.,\n        1., 2., 3., 5., 7., 9., 11., 13., 15.,\n        1., 3., 5., 7., 9., 11., 13., 15.,\n        1., 3., 5., 7., 9., 11., 13., 14., 15.,\n        1., 5., 7., 11.\n    );\n\n    int layers[5] = int[5](4, 9, 8, 9, 4);\n    float pat = 0.0;\n    int off = 0;\n    for(int i = 0; i < 5; ++i)\n    {\n        pat += layer(uv, pattern, off, layers[i], lw, i, repeat, patlen, unit, 0.3);\n        off += layers[i];\n    }\n    \n    uv = rotate2d(-iTime/16.) * origuv;\n    \n    float pat2 = 0.0;\n    off = 0;\n    for(int i = 0; i < 4; ++i)\n    {\n        pat2 += layer(uv, pattern, off, layers[i], lw, i, repeat, patlen, unit, 0.14);\n        off += layers[i];\n    }\n\n    vec3 color = vec3(pat) * vec3(1.0, 0.4, 0.2);\n    color += vec3(pat2);\n\n    fragColor = vec4(color,1.0);\n}\n#endif\n\n","name":"Image","description":"","type":"image"}]}