{"ver":"0.1","info":{"id":"4fGyR1","date":"1731459070","viewed":60,"name":"cherry blossom julia (antialias)","username":"brickdude","description":"trying to visualize julia set fractals","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITERS 1500\n#define ZOOM_LVL 3.7\n#define TIMESCALE 0.09\n#define GROWTH_CAP 10.0\n\n//#define COLOR_SEED 3.265\n#define COLOR_SEED 3258\n//#define COLOR_SEED 87635.25\n#define GAMMA 0.4\n#define ANTI_ALIAS_SAMPLES 5\n\nconst float TWO_PI = 6.28318530718;\nconst float PI = 3.1415926535;\n\n\nvec2 hash2(float id)\n{\n    return fract(sin(vec2(id)) * vec2(2345.435, 4535.345));\n}\n\nvec3 hash3(float id)\n{\n    return fract(sin(vec3(id * 1.3752)) * vec3(2345.435, 4656.34, 4535.345));\n}\n\nvec3 depthColor(float iterations)\n{\n    return 0.5 + 0.5*sin(hash3(float(COLOR_SEED)) * vec3(iterations / 10.0));\n}\n\nvec2 zSquared(vec2 z)\n{   // x is the real part y is the imaginary part\n    return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n}\n\nstruct Zoom\n{\n    vec2 pivot;\n    float level;\n};\n\nvec2 zoomPoint(vec2 p, Zoom zoom)\n{\n    return (p - zoom.pivot) * (1.0 / pow(zoom.level, 5.0)) + zoom.pivot;\n}\n\nvec3 sampleJulia(vec2 z, float c, int iterations)\n{\n    float smoothDepth = 0.0;\n    \n    int i;\n    for (i = 0; i < iterations; i++)\n    {\n        smoothDepth += exp(-length(z));\n        vec2 newZ = zSquared(z) - vec2(c);\n        \n        if (length(newZ) > GROWTH_CAP)\n            break;\n        \n        z = newZ;\n    }\n    \n    return vec3(\n        z.x,\n        smoothDepth * exp(1.0) / 1.5,\n        float(i)\n    );\n}\n\nfloat ease(float x, int initSlopeN, float power)\n{\n    x = clamp(x, 0.0, 1.0);\n    return x / float(initSlopeN) + float(initSlopeN - 1) * pow(x, power) / float(initSlopeN);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = (iTime + 2.5) * TIMESCALE;\n    \n    // Zooming\n    Zoom zoom = Zoom( vec2(0.430731, 0.25608), 1.0 + (1.0 - cos(time)) * ZOOM_LVL );\n\n    // Twist c into view at start\n    float c = -0.36458;\n    float t = pow(1.0 - cos(time), 1.2) * TWO_PI;\n    float damping = 0.003;\n    c = c + damping * cos(t/t)/(t*t);\n\n    // Increase iterations as we zoom for less fickering\n    int iters = 5 + int(ease(1.0 - cos(time), 2, 9.0) * float(MAX_ITERS - 5));\n    \n    // SAMPLE MAIN in loop for antialiasing (?)\n    vec3 result = vec3(0.0);\n    for (int i = 0; i < ANTI_ALIAS_SAMPLES; i++)\n    {\n        vec2 subPixelOff = hash2(float(i)) - 0.5;\n        vec2 z = ((fragCoord.xy + subPixelOff) * 2.0 - iResolution.xy) / iResolution.y;\n        \n        z = zoomPoint(z, zoom);\n\n        result += depthColor(sampleJulia(z, c, iters).y);\n    }\n    result /= float(ANTI_ALIAS_SAMPLES);\n\n    // color correction\n    result = pow(result, vec3(1.0 / GAMMA));\n\n    // Output to screen\n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}