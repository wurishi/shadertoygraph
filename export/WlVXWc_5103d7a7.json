{"ver":"0.1","info":{"id":"WlVXWc","date":"1583840392","viewed":606,"name":"Polyps","username":"TGlad","description":"Bilaplacian growth (Laplacian growith in two directions with two chemicals), where you can choose the chemical concentration (the boundary gradient).\nFor more info: https://sites.google.com/site/tomloweprojects/scale-symmetry/polyps","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["fractal","dla","viscousfingering","coral","dbm","laplaciangrowth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backgroundChemical = vec3(0.2, 0.5, 0.7);\n    vec3 treeChemical = vec3(0.5, 0.6, 0.0);\n    vec3 treeColour = vec3(0.7, 0.3, 0.1);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 val=texture(iChannel3, uv).xyzw;\n    \n    vec3 combined = treeColour*val.z + backgroundChemical*0.005*val.x + treeChemical*0.005*val.y;\n    fragColor = vec4(combined, 1.0);//+ val.w*0.001*vec3(1.0,0.0,1.0), 1.0);   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = uv;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\n    vec4 e0 = texture( iChannel3,  position - P.zy).xyzw;\n    vec4 e1 = texture( iChannel3,  position - P.xz).xyzw;\n    vec4 e2 = texture( iChannel3,  position + P.xz).xyzw;\n    vec4 e3 = texture( iChannel3,  position + P.zy).xyzw;\n    vec4 c0 = texture( iChannel3,  position - P.xy).xyzw;\n    vec4 c1 = texture( iChannel3,  position - P.wy).xyzw;\n    vec4 c2 = texture( iChannel3,  position + P.wy).xyzw;\n    vec4 c3 = texture( iChannel3,  position + P.xy).xyzw;\n    vec4 m  = texture( iChannel3,  position).xyzw;\n\n    getFragColour(iMouse, iResolution, iFrame, fragColor, fragCoord, e0,e1,e2,e3,c0,c1,c2,c3,m, iTime);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = uv;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\n    vec4 e0 = texture( iChannel0,  position - P.zy).xyzw;\n    vec4 e1 = texture( iChannel0,  position - P.xz).xyzw;\n    vec4 e2 = texture( iChannel0,  position + P.xz).xyzw;\n    vec4 e3 = texture( iChannel0,  position + P.zy).xyzw;\n    vec4 c0 = texture( iChannel0,  position - P.xy).xyzw;\n    vec4 c1 = texture( iChannel0,  position - P.wy).xyzw;\n    vec4 c2 = texture( iChannel0,  position + P.wy).xyzw;\n    vec4 c3 = texture( iChannel0,  position + P.xy).xyzw;\n    vec4 m  = texture( iChannel0,  position).xyzw;\n\n    getFragColour(iMouse, iResolution, iFrame, fragColor, fragCoord, e0,e1,e2,e3,c0,c1,c2,c3,m, iTime);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = uv;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\n    vec4 e0 = texture( iChannel1,  position - P.zy).xyzw;\n    vec4 e1 = texture( iChannel1,  position - P.xz).xyzw;\n    vec4 e2 = texture( iChannel1,  position + P.xz).xyzw;\n    vec4 e3 = texture( iChannel1,  position + P.zy).xyzw;\n    vec4 c0 = texture( iChannel1,  position - P.xy).xyzw;\n    vec4 c1 = texture( iChannel1,  position - P.wy).xyzw;\n    vec4 c2 = texture( iChannel1,  position + P.wy).xyzw;\n    vec4 c3 = texture( iChannel1,  position + P.xy).xyzw;\n    vec4 m  = texture( iChannel1,  position).xyzw;\n\n    getFragColour(iMouse, iResolution, iFrame, fragColor, fragCoord, e0,e1,e2,e3,c0,c1,c2,c3,m, iTime);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = uv;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\n    vec4 e0 = texture( iChannel2,  position - P.zy).xyzw;\n    vec4 e1 = texture( iChannel2,  position - P.xz).xyzw;\n    vec4 e2 = texture( iChannel2,  position + P.xz).xyzw;\n    vec4 e3 = texture( iChannel2,  position + P.zy).xyzw;\n    vec4 c0 = texture( iChannel2,  position - P.xy).xyzw;\n    vec4 c1 = texture( iChannel2,  position - P.wy).xyzw;\n    vec4 c2 = texture( iChannel2,  position + P.wy).xyzw;\n    vec4 c3 = texture( iChannel2,  position + P.xy).xyzw;\n    vec4 m  = texture( iChannel2,  position).xyzw;\n\n    getFragColour(iMouse, iResolution, iFrame, fragColor, fragCoord, e0,e1,e2,e3,c0,c1,c2,c3,m, iTime);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Fractal diffusion algorithm by Thomas Lowe\n// Use the left mouse button to add yellow chemical source, notice that the tree branches\n// attract towards it.\n\n// This algorithm is a form of Laplacian growth function\n// but rather than one diffused chemical (creating a thin tree) it uses two so generates\n// a thick tree with once chemical diffusing inside and one diffusing outside\n// The boundary of the tree (in blue) then grows in proportion to the gradient gX of \n// the chemical X (red) and the gradient gY of the chemical Y (green) such that:\n//\n//          growth rate = (gXgY-1)(gX-gY)\n//\n// the second term is a signed version of Laplacian growth, so\n// when the first term is positive it makes the boundary more rough, and \n// when the first term is negative it makes the boundary more smooth.\n//\n// when the 'stochastic' parameter is set, the growth rate is applied as a probability of\n// adding or removing one pixel. Otherwise it is applied as a sub-pixel addition to the\n// boundary.\nconst bool stochastic = false; \nconst float chemicalGradient = 200.0; // values from 100 up to about 800 are good. low gives smaller polyps that move faster, high are bigger, slower moving but more unstable\n\n// random functions courtesy of TomF.\nfloat nrand(vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat n1rand(vec2 n, float time)\n{\n\tfloat t = fract( time );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\n\nconst float dt = 1.0;\n\nfloat distToBox(in vec2 pos, in vec2 boxMin, in vec2 boxMax)\n{\n    float expand = 0.1;\n    boxMin -= vec2(expand,expand);\n    boxMax += vec2(expand,expand);\n    float bMax = max(pos.x - boxMax.x, pos.y - boxMax.y);\n    float bMin = max(boxMin.x - pos.x, boxMin.y - pos.y);\n    return max(bMax, bMin);\n}\n\nvoid getFragColour(in vec4 iMouse, in vec3 iResolution, in int iFrame, inout vec4 fragColor, in vec2 fragCoord, in vec4 e0, in vec4 e1, in vec4 e2, in vec4 e3, \n                   in vec4 c0, in vec4 c1, in vec4 c2, in vec4 c3, in vec4 m, float time)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n   \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    if(iFrame == 0 || (iMouse.z > 0.0 && iResolution.x>1000.0))\n    {\n        float height = 0.5;\n        if (nrand(uv) < 0.5)\n            height += pixelSize.y;\n        if (uv.y < height)\n        {\n            fragColor.z = 1.0;\n            fragColor.x = 0.0;\n            fragColor.y = max(chemicalGradient*((0.5-uv.y)-0.1), 0.0);\n        }\n        else\n        {\n            fragColor.z = 0.0;\n            fragColor.y = 0.0;\n            fragColor.x = max(chemicalGradient*((uv.y-0.5)-0.1), 0.0);\n        }\n        fragColor.w = 1.0;\n        return;\n    }\n   \n    vec2 delta;\n    \n    float w = max(e0.w, max(e1.w, max(e2.w, e3.w)));\n    \n    // Diffusion of chemical x and y\n    if (stochastic)\n    {\n        delta.x = e0.x + e1.x + e2.x + e3.x;\n        delta.x += 0.5*(c0.x + c1.x + c2.x + c3.x);\n        delta.x -= 6.0*m.x;\n\n        delta.y = e0.y + e1.y + e2.y + e3.y;\n        delta.y += 0.5*(c0.y + c1.y + c2.y + c3.y);\n        delta.y -= 6.0*m.y;\n\n        delta /= 6.0;  \n    }\n    else\n    {\n        float denomX = (1.0-e0.z) + (1.0-e1.z) + (1.0-e2.z) + (1.0-e3.z);\n        denomX += 0.5*((1.0-c0.z) + (1.0-c1.z) + (1.0-c2.z) + (1.0-c3.z));\n        float denomY = e0.z + e1.z + e2.z + e3.z;\n        denomY += 0.5*(c0.z + c1.z + c2.z + c3.z);\n\n        delta.x = e0.x*(1.0-e0.z) + e1.x*(1.0-e1.z) + e2.x*(1.0-e2.z) + e3.x*(1.0-e3.z);\n        delta.x += 0.5*(c0.x*(1.0-c0.z) + c1.x*(1.0-c1.z) + c2.x*(1.0-c2.z) + c3.x*(1.0-c3.z));\n\n        // Note: there dX and dY functions are a little heuristic, we can't just set the\n        // centre pixel to a darkened (by z) average of the Moore neighbourhood as this would be\n        // darker than it should be.\n        float dX = denomX + max(0.0, min(denomY, 2.0) + max(0.0, (denomY - 2.0)/2.0) - m.z);\n        delta.x /= dX;\n\n        delta.y = e0.y*e0.z + e1.y*e1.z + e2.y*e2.z + e3.y*e3.z;\n        delta.y += 0.5*(c0.y*c0.z + c1.y*c1.z + c2.y*c2.z + c3.y*c3.z);\n\n        float dY = denomY + max(0.0, min(denomX, 2.0) + max(0.0, (denomX - 2.0)/2.0) - (1.0-m.z));\n        delta.y /= dY;\n\n        delta -= vec2(m.x, m.y);\n    }\n    delta *= 1.4;\n    m.xy = vec2(m.x+delta.x*dt, m.y+delta.y*dt);\n    float W = max(0.000001, w);\n    \n    // Grow or shrink the tree\n    if (stochastic)\n    {\n        float maxX = max(e0.x, max(e1.x, max(e2.x, e3.x)));\n        float maxX2 = max(c0.x, max(c1.x, max(c2.x, c3.x)));\n        if (maxX > 0.0)\n          maxX = max(maxX, maxX2*0.707);\n        float maxY = max(e0.y, max(e1.y, max(e2.y, e3.y)));\n        float maxY2 = max(c0.y, max(c1.y, max(c2.y, c3.y)));\n        if (maxY > 0.0)\n          maxY = max(maxY, maxY2*0.707);\n\n        maxX /= pixelSize.y;\n        maxY /= pixelSize.y;\n\n        fragColor.z = m.z;\n        float gX = m.x/pixelSize.y;\n        float gY = m.y/pixelSize.y;\n\n        float p = 0.0;\n        if (m.z < 0.5)\n        {\n            // if m.x or m.y are 0, it should gives p=0\n            p = (gX*maxY - 1.0)*(gX-maxY);\n            if (n1rand(uv, time) < p/W)\n                fragColor.z = 1.0;\n        }\n        else\n        {\n            p = (gY*maxX - 1.0)*(gY-maxX);\n            if (n1rand(uv, time) < p/W)\n                fragColor.z = 0.0;\n        }  \n        w = max(w, p);\n    }\n    else\n    {\n        fragColor.z = m.z;\n        fragColor.z = max(0.0, min(fragColor.z, 1.0));\n        // For this sub-pixel calculation the gradient is higher when the pixel intersects\n        // more with the boundary\n        float gX = m.x/((1.0-0.5*m.z)*pixelSize.y);\n        float gY = m.y/((1.0-0.5*(1.0-m.z))*pixelSize.y);\n\n        if (m.z>0.0 && m.z<1.0)\n        {\n            float p = (gX*gY - 1.0)*(gX-gY);\n            w = max(w, p);\n            fragColor.z += p/W;\n        }\n\n        const float mx = 0.999;\n        const float mn = 0.001;\n        float extra = max(0.0, e0.z-mx) + max(0.0, e1.z-mx) + max(0.0, e2.z-mx) + max(0.0, e3.z-mx); \n        float extra2= max(0.0, c0.z-mx) + max(0.0, c1.z-mx) + max(0.0, c2.z-mx) + max(0.0, c3.z-mx); \n        float under = min(e0.z-mn, 0.0) + min(e1.z-mn, 0.0) + min(e2.z-mn, 0.0) + min(e3.z-mn, 0.0); \n        float under2= min(c0.z-mn, 0.0) + min(c1.z-mn, 0.0) + min(c2.z-mn, 0.0) + min(c3.z-mn, 0.0); \n\n        extra += extra2/2.0;\n        under += under2/2.0;\n        if (fragColor.z <= 0.0 && extra > 0.0)\n        {\n          fragColor.z += extra/3.0;\n        }\n        if (fragColor.z >= 1.0 && under < 0.0)\n        {\n          fragColor.z += under/3.0;\n        }\n        fragColor.z = max(-1.0, min(fragColor.z, 2.0));\n    }\n    fragColor.xy = m.xy;\n    fragColor.w = w * 0.997;\n    \n\n    if (fragColor.z <= 0.0)\n        fragColor.y = 0.0;\n    else if (fragColor.z >= 1.0)\n        fragColor.x = 0.0;\n    float gradient = chemicalGradient;\n    if (fragCoord.y <= 1.0)\n        fragColor.y = e3.y + gradient*pixelSize.y; \n    if (fragCoord.y >= iResolution.y-1.0)\n        fragColor.x = e0.x + gradient*pixelSize.y; \n    \n    if (iMouse.z > 0.0 && length(fragCoord.xy - iMouse.xy) < 20.0)\n        fragColor.y = 1.0;       \n}\n","name":"Common","description":"","type":"common"}]}