{"ver":"0.1","info":{"id":"tlXfz8","date":"1595967638","viewed":422,"name":"marching squares","username":"CoolerZ","description":"Implementing the square marching algorithm on simplex noise.\nSee https://en.wikipedia.org/wiki/Marching_squares and https://youtu.be/0ZONMNUKTfU for more details.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["noise","marching","square"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MARCHING SQUARES\n// See https://en.wikipedia.org/wiki/Marching_squares and https://youtu.be/0ZONMNUKTfU for more details.\n\n// Simplex noise in 3d\n\n#define R2 .6\n#define A .5\n#define F 1.\n\nconst vec3[] grad = vec3[](\n    vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n\tvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n\tvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1)\n);\n\nconst int perm[] = int[](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\nint hash(ivec3 p)\n{\n    return perm[p.x+perm[p.y+perm[p.z]]]%12;\n}\n\nvec3 skew(vec3 p)\n{\n    return p+(p.x+p.y+p.z)/3.;\n}\n\nvec3 unskew(vec3 p)\n{\n    return p-(p.x+p.y+p.z)/6.;\n}\n\nfloat simplex3d(vec3 xyz)\n{\n    vec3 ijk = floor(skew(xyz));\n    vec3 XYZ0 = unskew(ijk);\n\n    vec3 xyz0 = xyz - XYZ0;\n\n    vec3 ijk1, ijk2;\n    if(xyz0.x >= xyz0.y)\n    {\n        if(xyz0.y >= xyz0.z)\n        {\n            ijk1 = vec3(1,0,0);\n            ijk2 = vec3(1,1,0);\n        }\n        else if(xyz0.x >= xyz0.z)\n        {\n            ijk1 = vec3(1,0,0);\n            ijk2 = vec3(1,0,1);\n        }\n        else\n        {\n            ijk1 = vec3(0,0,1);\n            ijk2 = vec3(1,0,1);\n        }\n    }\n    else\n    {\n        if(xyz0.y < xyz0.z)\n        {\n            ijk1 = vec3(0,0,1);\n            ijk2 = vec3(0,1,1);\n        }\n        else if(xyz0.x < xyz0.z)\n        {\n            ijk1 = vec3(0,1,0);\n            ijk2 = vec3(0,1,1);\n        }\n        else\n        {\n            ijk1 = vec3(0,1,0);\n            ijk2 = vec3(1,1,0);\n        }\n    }\n\n    vec3 xyz1 = xyz0 - unskew(ijk1);\n    vec3 xyz2 = xyz0 - unskew(ijk2);\n    vec3 xyz3 = xyz0 - unskew(vec3(1,1,1));\n\n   \tivec3 IJK = ivec3(ijk) & 0xFF;\n    int gi0 = hash(IJK);\n    int gi1 = hash(IJK + ivec3(ijk1));\n    int gi2 = hash(IJK + ivec3(ijk2));\n    int gi3 = hash(IJK + ivec3(1,1,1));\n\n    float n0 = pow(max(R2 - dot(xyz0, xyz0), 0.), 4.)*dot(grad[gi0], xyz0);\n    float n1 = pow(max(R2 - dot(xyz1, xyz1), 0.), 4.)*dot(grad[gi1], xyz1);\n    float n2 = pow(max(R2 - dot(xyz2, xyz2), 0.), 4.)*dot(grad[gi2], xyz2);\n    float n3 = pow(max(R2 - dot(xyz3, xyz3), 0.), 4.)*dot(grad[gi3], xyz3);\n\n    return 32.*(n0+n1+n2+n3);\n}\n\n// Square marching starts here\n\nbool random_bool(ivec2 p)\n{\n    //return simplex3d(vec3(p,0.))>0.;\n    return simplex3d(vec3(vec2(p)*.1,iTime))>0.;\n}\n\nint combine(bool b3, bool b2, bool b1, bool b0)\n{\n    return int(b3)*8+int(b2)*4+int(b1)*2+int(b0);\n}\n\nconst vec2[] axes = vec2[](\n    vec2(1,0),\n    normalize(vec2(1,1)),\n    normalize(vec2(-1,1)),\n    vec2(0,1),\n    normalize(vec2(1,1)),\n    normalize(vec2(-1,1)),\n    vec2(1,0),\n    normalize(vec2(-1,1)),\n    normalize(vec2(-1,1)),\n    vec2(1,0),\n    normalize(vec2(1,1)),\n    normalize(vec2(1,1)),\n    vec2(0,1),\n    normalize(vec2(-1,1)),\n    normalize(vec2(1,1)),\n    vec2(1,0)\n);\n\n\n// lines passing through (-4,-2) will be offscreen for all the 4 different slopes we use.\nconst vec4[] points = vec4[](\n    vec4(-4,-4,-4,-2),\n    vec4( 0,-1,-4,-2),\n    vec4( 0,-1,-4,-2),\n    vec4( 0, 0,-4,-2),\n\n    vec4( 0, 1,-4,-2),\n    vec4( 0, 1, 0,-1),\n    vec4( 0, 0,-4,-2),\n    vec4( 0, 1,-4,-2),\n\n    vec4( 0, 1,-4,-2),\n    vec4( 0, 0,-4,-2),\n    vec4( 0, 1, 0,-1),\n    vec4( 0, 1,-4,-2),\n\n    vec4( 0, 0,-4,-2),\n    vec4( 0,-1,-4,-2),\n    vec4( 0,-1,-4,-2),\n    vec4(-4,-4,-4,-2)\n);\n\nfloat line_d(vec2 p, vec2 axis, float width)\n{\n    return abs(dot(p,axis))-width;\n}\n\nvec2 combine_dots(vec2 dot1, vec2 dot2)\n{\n    return dot1.x <= dot2.x ? dot1 : dot2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 10.;\n\n    ivec2 bl = ivec2(floor(uv));\n    ivec2 br = bl + ivec2(1,0);\n    ivec2 tl = bl + ivec2(0,1);\n    ivec2 tr = bl + ivec2(1,1);\n\n    bool bbl = random_bool(bl);\n    bool bbr = random_bool(br);\n    bool btr = random_bool(tr);\n    bool btl = random_bool(tl);\n    int index = combine(btl, btr, bbr, bbl);\n    //int index = combine(random_bool(tl), random_bool(tr), random_bool(br), random_bool(bl));\n\n    vec2 xy = 2.*fract(uv)-1.;\n    vec4 points_on_lines = points[index];\n    vec2 axis = axes[index];\n    const float line_width = 0.1;\n    float d1 = line_d(xy-points_on_lines.xy, axis, line_width);\n    float d2 = line_d(xy-points_on_lines.zw, axis, line_width);\n    float d = min(d1, d2);\n    float mask = smoothstep(0.,.01,d);\n    vec3 col = vec3(mask);\n    //col -= vec3(fract(uv),0.); // for debugging purposes\n\n    // dots\n    const float dot_size = .1;\n    float dbl = length(uv-vec2(bl))-dot_size;\n    float dbr = length(uv-vec2(br))-dot_size;\n    float dtl = length(uv-vec2(tl))-dot_size;\n    float dtr = length(uv-vec2(tr))-dot_size;\n    vec2 dot_dist = combine_dots(vec2(dbl,bbl), vec2(dbr, bbr));\n    dot_dist = combine_dots(dot_dist, vec2(dtr, btr));\n    dot_dist = combine_dots(dot_dist, vec2(dtl, btl));\n    //float dot_dist = min(min(min(dbl, dbr), dtl), dtr);\n    float dot_mask = smoothstep(0.,.01, dot_dist.x);\n    col = mix(col, vec3(dot_dist.y), 1.-dot_mask);\n    col = 1.-col; // dark mode\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}