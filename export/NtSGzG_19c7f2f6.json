{"ver":"0.1","info":{"id":"NtSGzG","date":"1624067065","viewed":52,"name":"Hilbert Colors","username":"xingyzt","description":"Map RGB to a plane.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I thought, color pickers nowadays are\n// pretty lame. There's always one color\n// axis hidden under a slider, be it hue\n// or saturation or something else.\n\n// So I made this rectangle, which given\n// enough resolution, is able to show\n// every sRGB color at once.\n\n// This shader maps each point on the 2D\n// viewpoint onto a point on the 1D\n// Hilbert line, then maps that point\n// into 3D RGB space.\n\n// The transposeToAxes part might be\n// broken, so some parts of the colors\n// do not transition propertly.\n\n// (C) 2021 Xing Liu, GPL 3.\n\n// transposeToAxes & axesToTranspose\n// are based off of public domain code\n// by John Skilling\n\nivec4 transposeToAxes(ivec4 A, int b, int n)\t// position, #bits, dimension\n{\n\tint N = 2 << (b - 1), P, Q, t;\n\tint i;\n\t// Gray decode by H ^ (H/2)\n\tt = A[n - 1] >> 1;\n\tfor (i = n - 1; i > 0; i--) A[i] ^= A[i - 1];\n\tA[0] ^= t;\n\t// Undo excess work\n\tfor (Q = 2; Q != N; Q <<= 1)\n\t{\n\t\tP = Q - 1;\n\t\tfor (i = n - 1; i >= 0; i--)\n\t\t\tif ((A[i] &Q) == 1) A[0] ^= P;\t// invert\n\t\t\telse\n\t\t\t{\n\t\t\t\tt = (A[0] ^ A[i]) &P;\n\t\t\t\tA[0] ^= t;\n\t\t\t\tA[i] ^= t;\n\t\t\t}\n\t}\t// exchange\n\treturn A;\n}\nivec4 axesToTranspose(ivec4 A, int b, int n)\t// position, #bits, dimension\n{\n\tint M = 1 << (b - 1), P, Q, t;\n\tint i;\n\t// Inverse undo\n\tfor (Q = M; Q > 1; Q >>= 1)\n\t{\n\t\tP = Q - 1;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tif ((A[i] &Q) == 1) A[0] ^= P;\t// invert\n\t\t\telse\n\t\t\t{\n\t\t\t\tt = (A[0] ^ A[i]) &P;\n\t\t\t\tA[0] ^= t;\n\t\t\t\tA[i] ^= t;\n\t\t\t}\n\t}\t// exchange\n\t// Gray encode\n\tfor (i = 1; i < n; i++) A[i] ^= A[i - 1];\n\tt = 0;\n\tfor (Q = M; Q > 1; Q >>= 1)\n\t\tif ((A[n - 1] &Q) == 1) t ^= Q - 1;\n\tfor (i = 0; i < n; i++) A[i] ^= t;\n\treturn A;\n}\nint transposeToInt(ivec4 A, int b, int n)\n{\n\tint x = 0, i, j;\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tx += (A[j] >> i &1) << ((i + 1) *n - (j + 1));\t// digit << place\n\treturn x;\n}\nivec4 intToTranspose(int x, int b, int n)\n{\n\tivec4 A = ivec4(0,0,0,0);\n\tint i, j;\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tA[n - j - 1] += ((x >> (i *n + j)) &1) << i; // I have no idea how I solved this inverse\n\treturn A;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int bits = 16;\n    float scale = float(1<<bits);\n    vec2 position = fragCoord/iResolution.xy;\n    \t\n    ivec4 uv = ivec4(position*float(bits*bits),0,0);\n    \n\tvec3 col = vec3(\n        transposeToAxes(\n            intToTranspose(\n                transposeToInt(\n                    axesToTranspose(\n                        uv, bits/2*3, 2\n                    ), bits/2*3, 2\n                ), bits, 3\n            ), bits, 3\n        )\n    ) / scale;\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}