{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// mi-ku / altair\n\n#define STEPS 50\n#define EPSILON 0.001\n//#define FLAT_SHADING\n#define BORDER_LINES\n#define BORDER_THICKNESS 1.0\n//#define FLAT_GROUND\n#define TRIANGLE_BG\n\n// iq's sSqdSegment and sdTriangle functions from: https://www.shadertoy.com/view/XsXSz4\n// squared distance to a segment (and orientation)\nvec2 sSqdSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot( pa-ba*h, pa-ba*h ), pa.x*ba.y-pa.y*ba.x );\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 v1, in vec2 v2, in vec2 v3, in vec2 p )\n{\n\tvec2 d = min( min( sSqdSegment( v1, v2, p ), \n\t\t\t\t\t   sSqdSegment( v2, v3, p )), \n\t\t\t\t       sSqdSegment( v3, v1, p ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// background\nvec3 shadeBG( vec2 uv, float sp )\n{\n\tfloat sp2 = texture( iChannel0, vec2( 0.25, 0.0 ) ).r;\n\t// TRIANGLE BG\n#ifdef TRIANGLE_BG\n\tvec2 v2 = vec2( -0.12, 0.1 );\n\tvec2 v1 = vec2( 0.12, 0.1 );\n\tvec2 v3 = vec2( 0.0,  0.4 );\n\tfloat vadd1 = sp * 0.1;\n\tfloat vadd2 = sp2;\n\tfloat triDist1 = min( 1.0, ( 300.0 * \n\t\t\t\t\t\tsdTriangle( v1 + vec2( vadd1, -vadd1 ), v2 + vec2( -vadd1, -vadd1 ), v3 + vec2( 0.0, vadd1 ), uv ) ) );\n\tif ( triDist1 < 0.0 ) // todo: optimize branch\n\t{\n\t\ttriDist1 = pow( smoothstep( 0.0, 1.0, abs( triDist1 * 0.05 ) ), 0.1 );\n\t}\n\ttriDist1 = max( 0.6, triDist1 );\n\treturn vec3( triDist1 ) * \n\t\tvec3( 1.0, 0.95, 0.975 );\n#else\n\t// SPHERE BG\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y -= 0.25;\n\t\n\tvec3 color = vec3( 1.0, 1.0, 1.0 );\n\t\n\tfloat l1 = pow( max( 0.0, min( 1.0, length( uv ) * 4.0 * ( 1.0 + sp  ) ) ), 10.0 );\n\tfloat l2 = pow( max( 0.0, min( 1.0, length( uv ) * 6.0 * ( 1.0 + sp2 ) ) ), 10.0 );\n\treturn color * ( max( 1.0 - l1, l2 ) );\n#endif\n}\nint triIsect( const vec3   V1,  // Triangle vertices\n\t\t\t  const vec3   V2,\n\t\t\t  const vec3   V3,\n\t\t\t  const vec3    O,  //Ray origin\n\t\t\t  const vec3    D,  //Ray direction\n\t\t\t  out float res )\n{\n  vec3 e1, e2;  //Edge1, Edge2\n  vec3 P, Q, T;\n  float det, inv_det, u, v;\n  float t;\n \n  e1 = V2 - V1;\n  e2 = V3 - V1;\n\n  P = cross( D, e2 );\n  det = dot( e1, P );\n  if(det > -EPSILON && det < EPSILON) return 0;\n  inv_det = 1.0 / det;\n \n  T = O - V1;\n \n  u = dot(T, P) * inv_det;\n  if(u < 0. || u > 1.) return 0;\n \n  Q = cross( T, e1 );\n \n  v = dot(D, Q) * inv_det;\n  if(v < 0. || u + v  > 1.) return 0;\n \n  t = dot(e2, Q) * inv_det;\n \n  if(t > EPSILON) { //ray intersection\n    res = t;\n    return 1;\n  }\n \n  return 0;\n}\nint triIsectNC( const vec3   V1,  // Triangle vertices\n\t\t\t const vec3   V2,\n\t\t\t const vec3   V3,\n\t\t\t const vec3    O,  //Ray origin\n\t\t\t const vec3    D,  //Ray direction\n\t\t\t out float res )\n{\n  vec3 e1, e2;  //Edge1, Edge2\n  vec3 P, Q, T;\n  float det, inv_det, u, v;\n  float t;\n \n  e1 = V2 - V1;\n  e2 = V3 - V1;\n\n  P = cross( D, e2 );\n  det = dot( e1, P );\n  if(det > -EPSILON && det < EPSILON) return 0;\n  inv_det = 1.0 / det;\n \n  T = O - V1;\n \n  u = dot(T, P) * inv_det;\n \n  Q = cross( T, e1 );\n \n  v = dot(D, Q) * inv_det;\n \n  t = dot(e2, Q) * inv_det;\n \n  if(t > EPSILON) { //ray intersection\n    res = t;\n    return 1;\n  }\n \n  return 0;\n}\n\nvec3 polygonalGround( vec3 pos, float zshift, float sp )\n{\n\tfloat gridSize = 1.0;\n\tpos.z += zshift;\n\tvec2 uv1 = floor( pos.xz );\n\tvec2 uv2 = uv1 + vec2( gridSize, gridSize );\n\tfloat um = 0.002;\n\tfloat tm = 20.0;\n\tfloat gtm = 5.0;\n\n#ifdef FLAT_GROUND\n\tfloat h1 = 0.0;\n\tfloat h2 = 0.0;\n\tfloat h3 = 0.0;\n\tfloat h4 = 0.0;\n#else\n\tfloat h1 = sin( gtm * iTime + tm * texture( iChannel1, um * uv1 ).r );\n\tfloat h2 = sin( gtm * iTime + tm * texture( iChannel1, um * vec2( uv2.x, uv1.y ) ).r );\n\tfloat h3 = sin( gtm * iTime + tm * texture( iChannel1, um * uv2 ).r );\n\tfloat h4 = sin( gtm * iTime + tm * texture( iChannel1, um * vec2( uv1.x, uv2.y ) ).r );\n#endif\n\t\n\tfloat hm = 0.7 * max( 0.3, min( 1.0, -( uv1.y - 26.0 ) * 0.05 ) );\n\tvec3 v1 = vec3( uv1.x, h1 * hm, uv1.y );\n\tvec3 v2 = vec3( uv2.x, h2 * hm, uv1.y );\n\tvec3 v3 = vec3( uv2.x, h3 * hm, uv2.y );\n\tvec3 v4 = vec3( uv1.x, h4 * hm, uv2.y );\n\tfloat t1, t2, border1, border2;\n\tvec3 ro = pos + vec3( 0.0, 100.0, 0.0 );\n\tvec3 rd = vec3( 0.0, -1.0, 0.0 );\n\tint tri1res = triIsect( v1, v2, v3, ro, rd, t1 );\n\tint tri2res = triIsectNC( v1, v3, v4, ro, rd, t2 );\n\t\t\t\t\t\t \n\tfloat h = 0.0;\n\tif ( tri1res == 1 )\n\t{\n\t\tvec3 pt = ro + rd * t1;\n\t\treturn ( pt );\n\t}\n\tvec3 pt = ro + rd * t2;\n\treturn pt;\n}\n\nvec3 mapGround( vec3 pos, float sp, float zshift )\n{\n\tvec3 res = polygonalGround( pos, zshift, sp );\n\tfloat h = res.y;\n\n\treturn vec3( pos.x, h * 1.5 - 4.0, pos.z );\n}\n\nfloat rayMarchGround( vec3 ro, vec3 rd, float sp, float zshift )\n{\n\tfloat t = 0.0;\n\tfor( int i = 0; i < STEPS; i++ )\n\t{\n\t\tvec3 pt = ro + rd * t;\n\t\tfloat h = abs( pt.y - mapGround( pt, sp, zshift ).y );\n\t\tif ( h < 0.05 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += 0.3 * h;\n\t}\n\treturn t;\n}\n\nfloat intersectZPlane( vec3 ro, vec3 rd, float planeZ )\n{\n\treturn ( -ro.z + planeZ ) / rd.z;\n}\n\n\n// ground\nvec3 shadeGround( vec3 eye, vec3 pt, vec3 norm, vec3 normReflection, vec3 light, float mult, float sp )\n{\n#ifdef FLAT_SHADING\n\tpt.xz = pt.xz - mod( pt.xz, 1.0 ); // flat shading\n#endif\n\tvec3 r = normalize( reflect( light, norm ) );\n\tvec3 eyeDir = normalize( pt - eye );\n\tfloat dotR = dot( r, eyeDir );\n\tfloat diffuseColor = max( 0.0, dotR );\n\tfloat ambientColor = 0.7;\n\tvec3 groundColor = vec3( diffuseColor + ambientColor );\n\t\n\tvec3 rd = normalize( reflect( -eyeDir, normReflection ) );\n\tfloat t = intersectZPlane( pt, rd, 10.0 );\n\tvec3 bgPos = pt + rd * t;\n\t\n\tfloat mixv = max( 0.0, dotR * 2.0 );\n\tvec3 bgColor = shadeBG( abs( bgPos.xy ) * vec2( 0.1, -0.2 ) + vec2( 0.0,2.0 ), sp );\n\treturn groundColor * mixv + bgColor * ( 1.0 - mixv );\n}\n\nvec3 colorize( vec2 uv )\n{\n\tvec3 ro = vec3( 0.0, 7.0, 0.0 );\n\tvec3 rd = vec3( uv.x, uv.y - 0.4, 1.0 );\n\trd = normalize( rd );\n\n\tfloat sp = texture( iChannel0, vec2( 0.0, 0.0 ) ).r; // sound\n\n\tfloat zshift = iTime * 0.0;\n\t\n\tfloat t = rayMarchGround( ro, rd, sp, zshift );\n\t\n\t// directional light\n\tvec3 lightDir = vec3( sin( iTime ), 0.6, 0.0 ); \n\tlightDir = normalize( lightDir );\n\n\tvec3 color;\n\t{\n\t\tvec3 pt = ro + rd * t;\n\n\t\tfloat eps = 0.001;\n\t\tvec3 norm1 = vec3( mapGround( pt + vec3( eps, 0.0, 0.0 ), sp, zshift ).y - \n\t\t\t\t\t\t   mapGround( pt, sp, zshift ).y,\n\t\t\t\t\t\t   0.005,\n\t\t\t\t\t\t   mapGround( pt + vec3( 0.0, 0.0, eps ), sp, zshift ).y - \n\t\t\t\t\t\t   mapGround( pt, sp, zshift ).y );\n\t\tnorm1 = normalize( norm1 );\n\t\tvec3 norm2 = normalize( norm1 + vec3(0.0,8.0,0.0) );\n\t\t\n\t\t// border calculation\n\t\tfloat modx = abs( mod( pt.x, 1.0 ) );\n\t\tfloat modz = abs( mod( pt.z + zshift, 1.0 ) );\n\t\tfloat power = 60.0;\n#ifdef BORDER_LINES\n\t\tfloat border = pow(     modx, power )\t\t\t\t // x axis border \n\t\t\t         + pow( 1.0-modx, power )\n\t\t\t         + pow(     modz, power )\t\t\t\t // z axis border\n\t\t\t         + pow( 1.0-modz, power )\t\t\t\t //\n\t\t\t\t\t + pow( 1.0-abs( modx - modz ), power ); // cross border\n\t\tborder = max( 0.0, min( 1.0, border * BORDER_THICKNESS * sp ) );\n#else\n\t\tfloat border = 0.0;\n#endif\n\t\t\n\t\tvec3 diffuseColor = vec3( 1.0, 0.95, 0.90 );\n\t\t//vec3 diffuseColor = vec3( 1.0, 0.98, .95 );\n\t\tvec3 color1 = shadeBG( uv, sp ) * diffuseColor;\n\t\tvec3 color2 = shadeGround( ro, pt, norm1, norm2, lightDir, -1.0, sp ) * diffuseColor * ( 1.0 - border ) + vec3( .5, .5, .5 ) * border;\n\t\tfloat mixv = pow( min( min( 1.0, max( 0.0, -abs( pt.x ) + 7.0 ) ), min( 1.0, max( 0.0, -abs( pt.z ) + 25.0 ) ) ), 2.0 );\n\t\tcolor = color1 * ( 1.0 - mixv ) + color2 * mixv;\n\t}\n\n\treturn color;\n}\n\nvec3 noiseGrain( vec2 uv )\n{\n\treturn vec3(\n\t\ttexture( iChannel1, uv * 20.0 + vec2( iTime * 100.678, iTime * 100.317 ) ).r\n\t) * 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2( 0.5, 0.5 );\n\tfloat dist = ( 1.0 - length( uv - vec2( 0.0, 0.25 ) ) * .5) * 1.0;\n\tvec3 color = colorize( uv ) * dist - noiseGrain( uv );\n\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dlSRX","date":"1405028248","viewed":2550,"name":"For the love of polygons","username":"mi_ku","description":"Shader that will take you back in time to the low-poly era","likes":68,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","triangles","polygons","lowpoly"],"hasliked":0,"parentid":"","parentname":""}}