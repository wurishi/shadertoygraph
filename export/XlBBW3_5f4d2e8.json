{"ver":"0.1","info":{"id":"XlBBW3","date":"1517317190","viewed":135,"name":"lfsr6 - in c64 colors","username":"visy","description":"lfsr effect","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lasfl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 pal[16];  //Palette form: http://www.pepto.de/projects/colorvic/\nvoid setpal()\n{\n    pal[0]=vec3(0),pal[1]=vec3(1),pal[2]=vec3(0.4530,0.2611,0.2089),pal[3]=vec3(0.4845,0.6764,0.7286), pal[4]=vec3(0.4825,0.2829,0.5663),pal[5]=vec3(0.3925,0.5921,0.3087),\n    pal[6]=vec3(0.2500,0.1972,0.5206), pal[7]=vec3(0.7500,0.8028,0.4794),pal[8]=vec3(0.4825,0.3576,0.1837),pal[9]=vec3(0.3082,0.2691,0.0000),pal[10]=vec3(0.6405,0.4486,0.3964),\n    pal[11]=vec3(0.3125,0.3125,0.3125),pal[12]=vec3(0.4688,0.4688,0.4688),pal[13]=vec3(0.6425,0.8421,0.5587),pal[14]=vec3(0.4688,0.4159,0.7393),pal[15]=vec3(0.6250,0.6250,0.6250);\n}\n\nfloat rectify(in float f){ return mix(pow(((f + 0.055)/1.055), 2.4), f / 12.92, step(f, 0.04045))*100.; }\nfloat pivot(in float x){ return mix(pow(x,0.3333), (903.3*x + 16.)/116., step(x,216.0/24389.0)); }\n//RGB to Lab (for color differencing) https://github.com/THEjoezack/ColorMine\nvec3 rgb2lab(in vec3 c)\n{\n\tc.r = rectify(c.r);\n\tc.g = rectify(c.g);\n\tc.b = rectify(c.b);\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n\tvec3 w = normalize(vec3(1.3,1.33,1.1));\n\tc.x = pivot(c.x/w.x);\n\tc.y = pivot(c.y/w.y);\n\tc.z = pivot(c.z/w.z);\n\t\n\treturn vec3(max(0.,116.*c.y-16.), 500.*(c.x-c.y), 200.*(c.y-c.z));\n}\n\nfloat hash(in float n){return fract(sin(n)*43758.5453);}\n//Using CIE76 for color difference, mainly because it is much cheaper\nvec3 c64(in vec3 c, in vec2 p)\n{\n    c = clamp(c,.0,1.);\n    \n    vec3 hsv = rgb2lab(c);\n    float d = 100000.;\n    float d2 = 100000.;\n    vec3 c2 = vec3(0);\n    for(int i=0;i<16;i++)\n    {\n        if (i < int(abs(cos(iTime*0.1)*5.))) continue;  \n        vec3 ch = rgb2lab(pal[i]);\n        float cd = distance(hsv,ch);\n        if (cd < d)\n        {\n            d2 = d;\n            c2 = c;\n            d = cd;\n            c = pal[i];\n        }\n        else if(cd < d2)\n        {\n            d2 = cd;\n            c2 = pal[i];\n        }\n        if (i > int(abs(cos(iTime*0.1)*16.))) break;  \n    }\n    \n    const float sclx = 320.;\n    const float scly = 200.;\n    float id = floor(p.x*sclx)*1.1+floor(p.y*scly)*2.;\n    float px = mod(floor(p.x*sclx)+floor(p.y*scly),2.);\n    float rn = hash(id);\n    if (rn < smoothstep(d2*0.96, d2*1., d*1.01) && (px ==0.))c=c2;\n    return pow(abs(c),vec3(1.136));  //correct gamma\n}\n\nvec4 overlay(vec2 uv2 )\n{\n    vec2 uv = uv2;\n    if (uv.x > sin(uv.y*iTime*1.1)) uv.x = 1.0-uv.x;\n    if (uv.y > cos(uv.x*iTime*1.1)) uv.y = 1.0-uv.y;\n    uv.y+=fract(uv.y*10.+uv.x*10.)*0.1;\n    uv.x+=fract(uv.y*10.+uv.x*10.)*0.1;\n\tfloat t = uv.y*0.5+iTime*0.5+uv.y*1.1+uv.x*2.;\n    uv+=fract(t+uv.x*2.)*0.1;\n\tvec3 c;\n    float ss;\n    for (float i = 0.0; i < 10.; i+=2.8) {\n        vec3 co = vec3(1.0);\n        ss = abs(0.3-0.2*(-fract(uv.x+t+i*t*0.01)*cos(uv.y+t+i*t*0.01))*i+i*0.1);\n        vec2 ce = vec2(0.5);\n        c += vec3(0.0+i*0.1*uv.y*1.2);\n\n        c+=abs(cos(uv.x-t)+abs(sin(uv.y-t)*i*uv.y*0.1));\n\n        if (uv.x < ce.x-ss || uv.x > ce.x+ss) c += co;\n        if (uv.y < ce.y-ss || uv.y > ce.y+ss) c += co;\n\n        c/=11.0-ss;\n\t\tint a = int(c.r*255.*uv.y) ^ int(c.g*255.*uv.x) ^ int(c.b*255.*ss+fract(i));\n        float b = float(a)/15.*distance(uv.x*ss,uv.y*10.);\n        c+=b*uv.y*0.01;\n    }\n        \n    c/=1.5;\n    c = clamp(c,0.0,1.0);\n\n    \t\tint a = int(c.r*255.*uv.y) ^ int(c.g*255.*uv.x) ^ int(c.b*255.*ss+fract(uv.y));\n        float b = float(a)/15.*distance(uv.x*ss,uv.y*10.);\n\n    b/=5.+cos(t*10.)*2.;\n    \n    \n\treturn(clamp(vec4(vec3(c.r*b+ss*0.2,c.g*b*2.,c.b*b*3.),1.0),0.0,1.0)*0.2);\n}\n\n\nconst float W = 4.0;\nconst float T = 0.05;\nfloat filmic_reinhard_curve (float x) {\n    float q = (T + 1.0)*x*x;    \n\treturn q / (q + x + T);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nint lfsr(in int n)\n{\n  n = (n << 13) ^ n; \n  return (n * (n*n*15731+789221) + 1376312589) & 0x7fffffff;\n}\n\nfloat lfsr_f( in int n )\n{\n  return float(lfsr(n));\n}\n\nvec3 effu(vec2 fragCoord, vec3 co )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif (uv.x < 0.5) uv.x = 1.0-uv.x;\n    uv.x+=0.285;\n    uv.y+=0.285;\n    uv+=co.x*iTime*0.01;\n    vec3 c = vec3(0.0);\n\tfloat t = iTime;\n    float z = 15.0;\n    int val = int(distance(distance(uv.x,uv.y),cos(uv.x*2.1))*z);\n    int val2 = int(fract(distance(uv.x,uv.y))*z);\n    vec3 effu = vec3(lfsr_f(val*val2)*0.0000000004);\n\tc = effu;\n\n    c.r-=distance(float(val), float(val2))*0.05;\n    c.g-=distance(float(val), float(val2))*0.06;\n    c.b-=distance(float(val), float(val2))*0.08;\n    \n    c = filmic_reinhard(c);\n    c = smoothstep(clamp(-10.+(iTime*0.5),-10.,0.9), -iTime*0.1, c);\n    \n\treturn pow(c, vec3(0.4545));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    setpal();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    if (uv.x > 0.5) uv.x = 1.0-uv.x;\n    if (uv.y > 0.5) uv.y = 1.0-uv.y;\n    if (uv2.x > 0.5) uv2.x = 1.0-uv2.x;\n    if (uv2.y > 0.5) uv2.y = 1.0-uv2.y;\n    uv.y+=fract(uv.y*10.+uv.x*10.)*0.01;\n    uv.x+=fract(uv.y*10.+uv.x*10.)*0.01;\n\tfloat t = uv.y*0.5+iTime*0.5+uv.y*1.1+uv.x*2.;\n    uv+=fract(t+uv.x*2.)*0.1;\n\tvec3 c;\n    float ss;\n    for (float i = 0.0; i < 10.; i+=0.8) {\n        vec3 co = vec3(1.0);\n        ss = abs(0.3-0.2*(-fract(uv.x+t+i*t*0.01)*cos(uv.y+t+i*t*0.01))*i+i*0.1);\n        vec2 ce = vec2(0.5);\n        c += vec3(0.0+i*0.1*uv.y*1.2);\n\n        c+=abs(cos(uv.x-t)+abs(sin(uv.y-t)*i*uv.y*0.1));\n\n        if (uv.x < ce.x-ss || uv.x > ce.x+ss) c += co;\n        if (uv.y < ce.y-ss || uv.y > ce.y+ss) c += co;\n\n        c/=11.0-ss;\n\t\tint a = int(c.r*255.*uv.y) ^ int(c.g*255.*uv.x) ^ int(c.b*255.*ss+fract(i));\n        float b = float(a)/15.*distance(uv.x*ss,uv.y*10.);\n        c+=b*uv.y*0.01;\n    }\n        \n    c/=1.5;\n    c = clamp(c,0.0,1.0);\n\n    \t\tint a = int(c.r*255.*uv.y) ^ int(c.g*255.*uv.x) ^ int(c.b*255.*ss+fract(uv.y));\n        float b = float(a)/15.*distance(uv.x*ss,uv.y*10.);\n\n    b/=10.;\n    \n    vec4 o = overlay(uv2*vec2(cos(t),sin(t)));\n\tvec3 ccc = clamp(vec3(c.r*b+ss*0.2,c.g*b*2.,c.b*b*3.),0.0,1.0);\n    ccc += clamp(o.rgb,0.0,1.0)*1.0-0.1*abs(cos(uv.x*10.+t*10.)*1.0);\n    vec3 ef = effu(fragCoord,ccc);\n    ef = clamp(ef,0.0,1.0);\n    ccc.rgb*=ef*1.5;\n    \n    fragColor.rgb = c64(ccc,uv);\n}","name":"Image","description":"","type":"image"}]}