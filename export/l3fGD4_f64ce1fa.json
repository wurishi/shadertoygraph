{"ver":"0.1","info":{"id":"l3fGD4","date":"1707454841","viewed":55,"name":"noise flipper test","username":"ufffd","description":"recreating https://www.youtube.com/watch?v=TdTMeNXCnTs and then diverging\npause and the objects disappear\nmouse to look around\nsomething about the raymarching is off but the concept is there","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n#if DEBUG > 0\n    fragColor = texture(iChannel1,uv);\n#else \n    fragColor = texture(iChannel0, uv);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPHERE 0\n#define SPINNING_CIRCLES 1\n#define SPINNING_SKULL 2\n\n#define RENDER_OBJ SPINNING_CIRCLES\n\nfloat map(in vec3 p) {\n    float d = 999.;\n    const int render = SPINNING_CIRCLES;\n    if (RENDER_OBJ==SPHERE) {\n        // return length(p + sin(T*.8)*.2) - 0.5;\n    }\n    if (RENDER_OBJ==SPINNING_CIRCLES) {\n        for (float i=0.;i<4.;i++) {\n            vec3 cp = p + vec3(sin(T+i*PI/2.),0.,cos(T+i*PI/2.)*.25);\n            float c = length(cp) - 0.5;\n            d = min(d, c);\n        }\n    }\n    if (RENDER_OBJ==SPINNING_SKULL) {\n        p.xz *= Rot(T);\n        d = sdSkull(p/1., 0.5);\n    }\n    return d;\n}\nvec3 norm(in vec3 p) {\n    float m = map(p);\n    vec2 d = vec2(.06+.06*sin(p.z),0.);\n    return map(p)-vec3(\n        map(p-d.xyy),map(p-d.yxy),map(p-d.yyx)\n    );\n}\nfloat drawLine(vec2 p, vec2 a, vec2 b, float thickness) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return smoothstep(thickness, thickness + 1.0, length(pa - ba * h));\n}\nvoid mainImage( out vec4 color, in vec2 coord ) {\n    vec2 uv = coord/R.xy;\n    vec2 uvc = (coord-R.xy/2.)/R.y;\n    vec2 muvc = iMouse.x > 0. ? (iMouse.xy-R.xy/2.)/R.y : vec2(0.);\n    uvc = floor(uvc*R.y/2.)/R.y*2.;\n    float d = 0.;\n    float dd = 1.;\n    vec3 p = vec3(0.,2.,-2.);\n    vec3 rd = normalize(vec3(uvc.xy,1.));\n    rd.zy *= Rot(0.75 + muvc.y);\n    rd.xy *= Rot(muvc.x);\n    bool hit = false;\n    bool near_hit = false;\n    for (float i=0.;i<90. && !hit && d < 9.;i++) {\n        d += dd;\n        p += rd*d;\n        dd = map(p);\n        if (dd<.01) near_hit = true;\n        if (dd<.001) hit = true;\n    }\n    \n    #if DEBUG==2\n       color = vec4(1./d);\n       return;\n    #endif\n    \n    if (drawLine(uvc, vec2(0.5,nsin(T)), vec2(sin(T*2.32)*.5), -0.498) < 0.5)\n        #ifdef WIREFRAME\n        near_hit = true;\n        #else\n        hit = true;\n        #endif\n    \n    color = texture(iChannel0,uv);\n    #ifdef WIREFRAME\n    if (!hit && near_hit) { // wireframe hit, should draw\n    #else\n    if (hit) { // leading edge drawing mode\n    #endif\n        // if this is a new hit for this pixel, set blue to 1. else return it to 0\n        // use blue in bufferb to trigger a noise update/pixel flip\n        if (color.r<0.5) color = vec4(1.);\n        else color.g = 0.;\n    } else \n        color = vec4(0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// #define NO_INIT\n#define WIREFRAME\n// 0 off, 1 view buffer a, 2 view raymarch depth\n#define DEBUG 0\n\n#define SS(a,b,c) smoothstep(a-b,a+b,c)\n#define T iTime\n#define R iResolution\n#define PI 3.1429\nmat2 Rot(in float a) {\n    float s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat nsin(in float a) {\n    return sin(a)*0.5+0.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n// SKULL SDF from Lost_Astronaut\n// https://www.shadertoy.com/view/Mlfyz4\n//==========================================================//\n//                 NOISE 3D\n//\n// 3D noise and fbm function by Inigo Quilez\n//==========================================================//\n\nmat3 m = mat3( .00,  .80,  .60,\n              -.80,  .36, -.48,\n              -.60, -.48,  .64 );\n\nfloat hash( float n )\n{\n    float h =  fract(sin(n) * 4121.15393);\n\n    return  h + .444;   \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f );\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix( hash(n + 00.00), hash(n + 1.000), f.x),\n                   mix( hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix( hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix( hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm( vec3 p )\n{\n   float f = 0.0;\n\n   f += 0.5000 * noise( p ); p = m * p * 2.1;\n   f += 0.2500 * noise( p ); p = m * p * 2.2;\n   f += 0.1250 * noise( p ); p = m * p * 2.3;\n   f += 0.0625 * noise( p );\n    \n   return f / 0.9375;\n}\n//==========================================================\n//            signed DISTANCE FIELD PRIMITIVES \n//==========================================================\n//\n// distance field primitives by Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n//\n//-----------------------------------------------------------\n//                       SPHERE            \n//-----------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n\n//-----------------------------------------------------------\n//                        BOX\n//-----------------------------------------------------------\nfloat sdBox( vec3 p, vec3 b )\n{   \n  vec3 d = abs(p) - b ;   \n  return max(min(d.x, min(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n\n\n// polynomial smooth min and max ref iq's article\n// https://iquilezles.org/articles/smin\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n\nvec3 opRot( vec3 p, float a )\n{\n    float  c = cos(a);\n    float  s = sin(a);\n    mat2   m = mat2(c,-s,s,c);   \n    return vec3(m*p.xy,p.z);\n}\n\n//==========================================================\n//          SKULL SIGNED DISTANCE FIELD \n//==========================================================\n\n\nfloat sdSkull( vec3 p, float s )\n{\n    \n    \n  // --------------------------------------------------------\n  // domain deformation on radius (s) brings some interesting\n  // results this deformation sould be applied to big shapes \n  // in order to preserve details. \n    \n  float ss = noise(p * 9.);\n  ss = mix(s,ss *.5,.1);\n  \n  \n  // sp is using symetry on z axis\n  vec3 sp = vec3(p.x, p.y, abs(p.z));\n    \n      \n  // kind of morphing effect \n // s = clamp(cos(iTime*.5), .20,.35);\n\n  float shape = sdSphere(p - vec3(.0,.05,.0), s * .95 * cos(cos(p.y*11.)* p.z * 2.3) );\n  //---------------------------------------------------------  \n  // first part external skull top\n  // --------------------------------------------------------\n    \n  // globe front \n  shape = smin(shape,  sdSphere (p - vec3(.10, 0.23, 0.00), s * .82), .09);\n    \n  // globe back \n  shape = smin(shape,  sdSphere (p - vec3(-.1, 0.24, 0.00), s * .82), .09);\n    \n  // eye brow\n  shape = smin(shape,  sdSphere (sp - vec3(.25, 0.07, 0.10), s * .36 * cos(p.y * 7.0)), .02);\n    \n  // lateral holes - symmetry\n  shape = smax(shape, -sdSphere (sp - vec3(.15, -.01, 0.31), s * .28 * cos(p.x * .59)), .02);  \n    \n  //checkbones - symmetry\n  shape = smin(shape, sdSphere(sp-vec3(.22,-.13,.18), s*.11),.09);\n  \n  // empty the skull\n  shape = max(shape, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smax(shape,  -sdSphere (p - vec3(.10, 0.23, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(-.1, 0.24, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(.0, 0.24, 0.00), s * .74),.02);\n  \n  // eye balls - symmetry\n  shape = smax(shape, -sdSphere(sp-vec3(.32,-.04,.140), s  * .28 * cos(p.y*10.)),.03);\n  \n  // nose\n  //-----------------------------------------------------------\n    \n  // base nose shape\n  float temp = sdSphere(p- vec3(cos(.0)*.220,-.05, sin(.0)*.3), s * .35 * cos(sin(p.y*22.)*p.z*24.));\n    \n  // substract the eyes balls ( symetrix) & skukl globe\n  temp = smax(temp, -sdSphere(sp-vec3(.32,-.04,.140), s * .35 * cos(p.y*10.)), .02); \n  temp = smax(temp, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ),.02);\n  \n  // add nose shape to skull \n  shape = smin(shape,temp,.015);  \n  \n  // empty the nose\n  shape = smax(shape, - sdSphere(p- vec3(cos(.0)*.238,-.09, sin(.0)*.3), s * .3 * cos(sin(p.y*18.)*p.z*29.)),.002);\n  \n  // substract bottom\n  shape = smax(shape, -sdSphere(p- vec3(-.15,-0.97, .0), s * 2.5 ),.01);\n    \n  // I like the noise deformation on this edge with ss for the sphere radius.\n  // It give a more natural look to the skull.\n  shape = smax(shape, -sdSphere(p- vec3(-.23,-0.57, .0), abs(ss) * 1.6 ),.01);\n    \n  //--------------------------------------------------------- \n  // skull part2: UP jaws\n  // --------------------------------------------------------\n    \n  temp = smax(sdSphere(p - vec3(.13,-.26,.0), .45 * s), -sdSphere(p - vec3(.125,-.3,.0), .40 * s), .01);\n  \n  // substract back\n  temp = smax(temp,-sdSphere(p - vec3(-.2,-.1,.0), .9 * s), .03);\n  \n  // substract bottom  \n  temp = smax(temp,-sdSphere(p - vec3(.13,-.543,.0), .9 * s), .03);\n  \n  // substract up  \n  temp = max(temp, -sdSphere(p - vec3(.0,.02,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smin(shape, temp, .07);\n    \n   \n  // Teeths - symmetry\n  //-----------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.26, -.29, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.26, -.29, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.25, -.29, .05), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.235, -.29, .08), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.215, -.28, .1), .05 * s ));\n  temp = max(temp, -sdSphere(p - vec3(.16, -.35, .0), .33 * s ));   \n  temp = min(temp, sdSphere(sp - vec3(.18, -.28, .115), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.28, .115), .06 * s ));\n\n   \n  shape = smin(shape, temp, .03); \n   \n  // DOWN Jaws\n  //-----------------------------------------------------------\n  \n  temp = sdSphere(p - vec3(.1,-.32,.0), .43 * s);  \n  temp = smax (temp, - sdSphere(p - vec3(.1,-.32,.0), .37 * s ),.02);  \n  temp = smax(temp, - sdSphere(p - vec3(.1,-.034,.0), 1.03 * s),.02) ;  \n  temp = smax(temp, - sdSphere(p - vec3(.0,-.4,.0), .35 * s),.02);   \n  // symmetry\n  temp = smin(temp, sdBox(sp - vec3(.04 -.03 * cos(p.y * 20.2),-.23, .27 + sin(p.y)*.27), vec3(cos(p.y*4.)*.03,.12,.014)), .13);\n  temp = max(temp, - sdSphere(sp - vec3(.0,.153,.2), .85 * s)); \n  temp = smin (temp, sdSphere(sp - vec3(.2, -.45, 0.05), .05 * s ),.07);  \n \n  shape = smin(shape, temp, .02);  \n    \n    \n  // Teeths -  symmetry\n  //--------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.23, -.34, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.23, -.34, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.22, -.34, .048), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.20, -.34, .078), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.17, -.35, .098), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.35, .11), .053 * s));\n      \n \n  shape = 1.5 * smin(shape, temp, .025);  \n    \n  \n    \n return shape ;  \n    \n // return mix(shape, sdSphere(p - vec3(.0, .0, .0), .5), cos(iTime*.1)*.5+.5);\n  //return mix(shape, sdBox(p-vec3(.0),vec3(.45)),abs(cos(iTime)));\n    \n  \n}\t","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// noise pass\nvoid mainImage( out vec4 color, in vec2 coord ) {\n    vec2 uv = coord/R.xy;\n    vec2 uvc = (coord-R.xy/2.)/R.y;\n    uvc = floor(uvc*R.y/2.)/R.y*2.;\n    if (iFrame<10) {\n        #ifdef NO_INIT\n        return;\n        #endif\n        float bw = hash13(vec3(uvc*100.,0.));\n        bw = step(0.5,bw);\n        color = vec4(vec3(bw),1.);\n        return;\n    }\n    \n    color = texture(iChannel0,uv).g > 0.5\n        ? vec4(vec3(1. - texture(iChannel1,uv).r),1.)\n        : texture(iChannel1,uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}