{"ver":"0.1","info":{"id":"4ftcWl","date":"1731344757","viewed":177,"name":"Eroded Island","username":"TekF","description":"Variation on my terrain generation shader, to look like islands. https://www.shadertoy.com/view/Mf3cz4","likes":15,"published":3,"flags":32,"usePreview":1,"tags":["raymarching","terrain","generative","realistic","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Islands - Hazel Quantock\n\nconst float scale = 1.;\nfloat height = 2.; // modified later\n\nvec2 PosToUV( vec3 p )\n{\n    return p.xz*vec2(iResolution.y/iResolution.x,1)/scale+.5;\n}\n\nfloat SDF( vec3 p )\n{\n    // the terrain generator doesn't make vertical things\n    // so I can use the map as an SDF\n    \n    vec2 uv = PosToUV(p);\n    \n    float h = texture(iChannel0,uv).w*scale*height;\n\n    vec2 bounds = abs(p.xz) - .5*scale*vec2(iResolution.x/iResolution.y,1);\n\n    return max(\n            (pow(abs(p.y),.85)+.01-h) * .3 // reduce this number to reduce glitches on steep slopes\n            , max(bounds.x,bounds.y));\n}\n\n\nfloat SpecularBRDF( vec3 toLight, vec3 toCamera, vec3 normal, float roughness )\n{\n    // pretty sure I've got an error in here but it's 1am and it looks good enough\n    vec3 h = normalize(toLight+toCamera);\n    \n    float NoV = max(0.,dot(normal,toCamera));\n    float NoL = max(0.,dot(normal,toLight));\n    \n    float a2 = roughness*roughness;\n    float G_V = NoV + sqrt( (NoV - NoV*a2)*NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL*a2)*NoL + a2 );\n    \n    float ndf = a2 / ( 3.14159 * pow( pow(dot(normal,h),2.)*(a2-1.)+1., 2.) );\n    \n    float ior = 1.5;\n    float f0 = (ior-1.)/(ior+1.);\n    f0 = f0*f0;\n    float fresnel = mix( f0, 1., pow(1.-dot(h,toCamera),5.) );\n    \n    return NoL * ndf * fresnel / (G_V * G_L);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n// debug\n//    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0); fragColour.rgb *= step(.1,fract(fragColour.a*.1)); return;\n\n\n    height /= iResolution.y;\n\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/length(iResolution.xy),1.);\n    ray = normalize(ray);\n    \n    float tt = iTime;\n    vec3 cam = cos(vec3(tt*.09,tt*.13+6.283*.5,tt*.07+.8));\n    cam.xz *= abs(cam.xz);\n    cam.y += 1.1;\n    cam.y = max( cam.y, .1);\n    cam *= vec3(1.8,.4,1.5) * scale;\n    \n    vec3 k = normalize(vec3(0,.3*height*scale,0)-cam);\n    vec3 i = cross(vec3(0,1,0),k);\n    vec3 j = cross(k,i);\n    ray = ray.x*i+ray.y*j+ray.z*k;\n    \n    vec3 pos = cam;\n    float t = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = SDF(ray*t+pos);\n        t += h;\n        if ( h < .0001 || t > 10. ) break;\n    }\n    \n    pos += ray*t;\n    \n    if ( t > 10. )//|| pos.y < .02 )\n    {\n        // sky/water\n        fragColour.rgb = mix(vec3(0,0,.07),vec3(1,1.4,1.7),pow(1.-abs(ray.y),2.));\n\n        if ( ray.y < 0. )\n        {\n            // water surface\n            fragColour.rgb *= .7;\n        }\n        return;\n    }\n    \n    // shading\n    vec2 d = vec2(1,-1)*.4*scale/iResolution.y; // sample at texel size [and in 2D - actually the y cancels this is 2D already]\n    vec3 normal = normalize(\n        SDF(pos+d.xxx)*d.xxx +\n        SDF(pos+d.yyx)*d.yyx +\n        SDF(pos+d.yxy)*d.yxy +\n        SDF(pos+d.xyy)*d.xyy\n    );\n    \n    vec3 albedo = texture(iChannel0,PosToUV(pos)).rgb;\n    \n//    if ( normal.y < .2 ) albedo = vec3(.04); // sides and base\n    // add grass\n    float grass = smoothstep(.9,1.,normal.y);\n    grass *= smoothstep(.6,0.,albedo.y)*.7+.2;\n    albedo = mix( albedo, vec3(.08,.15,.04), grass )*.7;\n\n    vec3 ambientlight = vec3(.4,.55,1) * .5;\n    ambientlight *= clamp( min( SDF(pos+normal*.3)/.3, SDF(pos+normal*.6)/.6 ), 0., 1. );\n\n    vec3 sundir = normalize(normalize(cam*vec3(-1,0,-1))+vec3(.1,.3,0));//vec3(-2,4,-3));\n    vec3 suncol = 1.4*vec3(1,.95,.9);\n\n    if ( pos.y < 0. ) sundir.y = -sundir.y; // reflect sun\n    vec3 diffuselight = suncol*max(0.,dot( normal.xyz, sundir ));\n    \n    float roughness = mix( mix(.3,.6,.5+.5*cos(1.+10.*albedo.g)), 1., grass);\n    \n    vec3 specularlight = suncol*SpecularBRDF( sundir, -ray, normal, roughness );\n   \n    fragColour.rgb = albedo*(diffuselight + ambientlight) + specularlight;\n\n    if ( pos.y < 0. )\n    {\n        // water surface\n        fragColour.rgb *= .7;\n    }\n    \n    fragColour.rgb *= 1.4; // exposure tweak\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float colourErosion = 0.3; // > 0 and < 1\n\nvec3 SampleColour( vec2 fragCoord )\n{\n    return texture(iChannel2,fragCoord/iResolution.y).rgb;\n}\n\n// cost function influences which path is shortest, determining the shape of the mountains\nfloat Cost( vec2 uv )\n{\n    const float bias = .6; // higher = slope away from the river, lower = flatter\n\n    // detail strengths & frequencies\n    const float bigAmp = .8;\n    const float midAmp = .35;\n    const float lilAmp = .05;\n    \n    const float bigFrq = 1.;\n    const float midFrq = 5.;\n    const float lilFrq = 25.;\n    \n    return bias\n        +(texture(iChannel3,bigFrq*uv/iResolution.x).g-.5)*bigAmp\n        +(texture(iChannel3,midFrq*uv/iResolution.x).g-.5)*midAmp\n        +(texture(iChannel3,lilFrq*uv/iResolution.x).g-.5)*lilAmp;\n}\n\n// compute total cost of path from uv+stp to uv, based on cost stored at uv+stp\nvoid TotalCost( inout vec4 lowest, inout vec4 highest, in vec4 current, in ivec2 uv, in ivec2 stp )\n{\n    uv += stp;\n    if ( uv.x < 0 || uv.y < 0 || uv.x >= int(iResolution.x) || uv.y >= int(iResolution.y) )\n        return;\n\n    vec4 t = texelFetch(iChannel0,uv,0);\n    if ( t.w < 0. ) return; // no data\n\n    float edgeLength = length(vec2(stp));\n\n    // colour erosion - blend colours from higher neighbours\n    float weight = (t.w-current.w)/edgeLength; // slope\n    if ( weight > 0.\n           && (uv.x > 0 || uv.y > 0 ) ) // ignore data pixel\n    {\n        highest += vec4(t.rgb*weight, weight);\n    }\n    \n    // compute cost of the step from sample pixel to target pixel\n    float edgeCost = Cost( vec2(uv)-vec2(stp)*.5 );\n    t.w += edgeCost*edgeLength;\n    \n    if ( t.w < lowest.w ) lowest = t;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if ( iChannelResolution[3].x <= 0. ) return;\n\n    // detect resolution changes by storing resolution at (0,0)\n    bool reset = any( notEqual( texelFetch(iChannel0,ivec2(0),0).xyz, iResolution ) );\n    bool isDataPixel = ( fragCoord.x < 1. && fragCoord.y < 1. );\n\n    if ( reset )\n    {\n        fragColour = vec4(-1);\n        \n        // starting shape, some points at height 0\n        float r = SampleColour(fragCoord/13.).g*iResolution.y*.4;\n        if ( fragCoord.x < 1.+r || fragCoord.y < 1.+r || fragCoord.x > iResolution.x-1.-r || fragCoord.y > iResolution.y-1.-r )\n        {\n            fragColour = vec4(0);\n        }\n        \n        // store iresolution in top right pixel, so I can detect resolution changes etc\n        if (isDataPixel) fragColour.xyz = iResolution;\n        \n        return;\n    }\n    \n    \n    \n    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    // measure cost*distance, plus score of those pixels, to any adjacent scored pixels\n    ivec3 d = ivec3(-1,0,1);\n\n    vec4 lowestNeighbour = vec4(0,0,0,1e38);  //ignored xyz,totalcost\n    vec4 highestNeighbour = vec4(0,0,0,0);  //colour,weight\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.xx);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.yx);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.zx);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.xy);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.zy);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.xz);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.yz);\n    TotalCost(lowestNeighbour,highestNeighbour,fragColour,ivec2(fragCoord),d.zz);\n\n    if ( lowestNeighbour.w < 1e37 &&\n        ( lowestNeighbour.w < fragColour.w || fragColour.w < 0. ) )\n    {\n        fragColour.w = lowestNeighbour.w;\n    }\n\n    if ( !isDataPixel )\n    {\n        if ( highestNeighbour.w > 0. )\n        {\n            float erosiveness = 50.*highestNeighbour.w;\n\n            // modify the influence of this point based on the distance between samples, ie the resolution\n            // not sure about the correct maths here, I tuned it until it looked pretty consistent between resolutions\n            erosiveness *= pow(iResolution.y/2560.,3.);\n            erosiveness = mix( erosiveness, 360./iResolution.y, .5 ); // prevent 0 erosion\n\n//                float erosiveness = 360./iResolution.y;\n\n            highestNeighbour.rgb /= highestNeighbour.w;\n            fragColour.rgb = mix( fragColour.rgb, highestNeighbour.rgb,\n                pow(colourErosion,1./erosiveness) );\n            fragColour.rgb = mix( fragColour.rgb, SampleColour(fragCoord), .01 );\n        }\n        else\n        {\n            fragColour.rgb = texture(iChannel2,fragCoord/iResolution.y).rgb;\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}