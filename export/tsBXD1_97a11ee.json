{"ver":"0.1","info":{"id":"tsBXD1","date":"1553601931","viewed":161,"name":"advective lava","username":"khlorghaal","description":"not happy with the result, too much feature diffusion","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise","navierstokes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//h[0,1]\nvec3 incandescence(float h){\n    h= h*h;\n    #define RATHER_HOT unsrgb(vec3(1.,.0,.0))\n    #define QUITE_HOT  unsrgb(vec3(1.,.4,.0))\n    #define VERY_HOT   unsrgb(vec3(1.,.98,.9))\n    vec3 w= vec3(h*2.);\n    w= 1.-abs(w-vec3(0.,1.,2.));\n    w= sat(w);\n    return RATHER_HOT*w.x + QUITE_HOT*w.y + VERY_HOT*w.z;\n}\n\nfloat fbm_nse(vec2 uv){\n    vec2 weights= vec2(4.,1.);\n    weights/= sum(weights);\n    float o0= perlin(vec3(uv*30.,1.*time));\n    float o1= worley(vec3(uv* 8.,4.*time*nmaps(o0)));\n    float d= dot(vec2(o0,o1),weights);\n    \n    return d;\n}\n\nvec4 img(vec2 uv){    \n    vec4 buf= tex(iChannel0, uv);\n    //return vec4(vec3(iridescence(uv.x)),1.);//test iridescence\n    //return vec4(buf.x*.5, nmapu(buf.zw*1.e3),1.);//test flow\n    //return vec4(buf.x);//test heat\n    uv.x*= asp;\n    \n    vec2 flow= buf.zw;\n   \t\n    //heat incandescence\n   \tfloat h= buf.x;\n    \n    //solid\n    float s= sat(1.-h*4.);\n    float s0= s;\n    s= smoother(s);\n    \n    //solid material\n    //float sbump= perlin(vec3(h*.1, (uv-flow*time)*25.));\n    #define NORMAL_HEIGHT 70.\n    //vec3 snorm= norm(vec3( dFdx(sbump), dFdy(sbump), 1./NORMAL_HEIGHT));\n    vec3 albedo= unsrgb(vec3(.08));\n    float lambert= s;\n    vec3 diffuse= albedo*lambert;\n    vec3 ambient= 2.*sat(1.-lambert*.8)*RATHER_HOT*albedo;\n    vec3 solid= diffuse+ambient;\n\t//vec3 solid= lerp(, QUITE_HOT, lambert) * albedo;\n    //solid= vec3(lambert);//test lambert\n    \n    \n    \n    vec3 lava= incandescence(h);\n    \n    vec3 col= lerp(lava, solid, s);\n    \n    //tonemap\n    //col= ;\n    \n\treturn vec4(srgb(col),1.);\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor=img(fragCoord/iResolution.xy); }\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Khlor's header\n//Copyright 2018 John Sherrill GNU GPLv3 https://www.gnu.org/licenses/gpl.txt\n//https://github.com/khlorghaal/glslheader/blob/master/header\n\n//Define-Switches\n#define SHADERTOY\n#define GLES\n\n//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define BIG 1e8\n#define ETA 1e-4\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc gl_FragCoord.xy\n#define res iResolution.xy\n#define aspect (res.x/res.y)\n#define asp aspect\n#define aspinv (1./aspect)\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define sats saturate_signed\n#define smooth(x) smoothstep(0.,1.,x)\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*vec2(PI, PI/2.))\n#define tex texture\n\n\n//vectorization macros\n//I dont use these since I don't trust the optimizer to inline the lambda\n//also multiline edit is easy\n#define VECTORIZE_UNARY_FLOAT(f) \\\nvec2 f(vec2 a){ return vec2(f(a.x),f(a.y)); } \\\nvec3 f(vec3 a){ return vec3(f(a.x),f(a.y),f(a.z)); } \\\nvec4 f(vec4 a){ return vec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_FLOAT(f) \\\nvec2 f(vec2 a, vec2 b){ return vec2(f(a.x,b.x),f(a.y,b.y)); } \\\nvec3 f(vec3 a, vec3 b){ return vec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nvec4 f(vec4 a, vec4 b){ return vec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n#define VECTORIZE_UNARY_INT(f) \\\nivec2 f(ivec2 a){ return ivec2(f(a.x),f(a.y)); } \\\nivec3 f(ivec3 a){ return ivec3(f(a.x),f(a.y),f(a.z)); } \\\nivec4 f(ivec4 a){ return ivec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_INT(f) \\\nivec2 f(ivec2 a, ivec2 b){ return ivec2(f(a.x,b.x),f(a.y,b.y)); } \\\nivec3 f(ivec3 a, ivec3 b){ return ivec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nivec4 f(ivec4 a, ivec4 b){ return ivec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n/* example\nfloat accumulate(float x){ return acc+= x; }\nVECTORIZE_UNARY_FLOAT(accumulate);\nAn impure function is a weird but valid example\n*/\n#define VECTORIZE_SCALAR_ARG(f) \\\nvec2 f(vec2 x, vec1 y){ return _f(x,vec2(y));} \\\nvec3 f(vec3 x, vec1 y){ return _f(x,vec3(y));} \\\nvec4 f(vec4 x, vec1 y){ return _f(x,vec4(y));}\n\n\nvec3   srgb(vec3 c){ return pow(c,vec3(   2.2)); }\nvec3 unsrgb(vec3 c){ return pow(c,vec3(1./2.2)); }\nvec3 texsrgb(sampler2D s,   vec2 uv){ return unsrgb(texture(s,uv).rgb); }\nvec3 texsrgb(samplerCube s, vec3  r){ return unsrgb(texture(s, r).rgb); }\n\n\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\nvec2 clamps(vec2 x, vec1 min, vec1 max){ return clamp(x, vec2(min),vec2(max));}\nvec3 clamps(vec3 x, vec1 min, vec1 max){ return clamp(x, vec3(min),vec3(max));}\nvec4 clamps(vec4 x, vec1 min, vec1 max){ return clamp(x, vec4(min),vec4(max));}\nvec2 mins(vec2 v, vec1 s){ return min(v, vec2(s));}\nvec3 mins(vec3 v, vec1 s){ return min(v, vec3(s));}\nvec4 mins(vec4 v, vec1 s){ return min(v, vec4(s));}\nvec2 maxs(vec2 v, vec1 s){ return max(v, vec2(s));}\nvec3 maxs(vec3 v, vec1 s){ return max(v, vec3(s));}\nvec4 maxs(vec4 v, vec1 s){ return max(v, vec4(s));}\nvec2 mins(vec1 s, vec2 v){ return min(v, vec2(s));}\nvec3 mins(vec1 s, vec3 v){ return min(v, vec3(s));}\nvec4 mins(vec1 s, vec4 v){ return min(v, vec4(s));}\nvec2 maxs(vec1 s, vec2 v){ return max(v, vec2(s));}\nvec3 maxs(vec1 s, vec3 v){ return max(v, vec3(s));}\nvec4 maxs(vec1 s, vec4 v){ return max(v, vec4(s));}\n\nfloat maxv(vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv(vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv(vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv(vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv(vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv(vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\n//[0,1]\nfloat saw(float x){ return mod(x,1.); }\nfloat tri(float x){ return abs( mod(x,2.) -1.); }\n\nfloat sum (vec2 v){ return dot(v,vec2(1));}\nfloat sum (vec3 v){ return dot(v,vec3(1));}\nfloat sum (vec4 v){ return dot(v,vec4(1));}\nfloat prod(vec2 v){ return v.x*v.y;}\nfloat prod(vec3 v){ return v.x*v.y*v.z;}\nfloat prod(vec4 v){ return v.x*v.y*v.z*v.w;}\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nvec1 saturate_signed(vec1 x){ return clamp (x, -1.,1.);}\nvec2 saturate_signed(vec2 x){ return clamps(x, -1.,1.);}\nvec3 saturate_signed(vec3 x){ return clamps(x, -1.,1.);}\nvec4 saturate_signed(vec4 x){ return clamps(x, -1.,1.);}\n\n#define smoother(x) (x*x*x * (x*(x*6.-15.)+10.) )\n\n\nfloat pow2i(int x){ return float(1<<x); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }\nvec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(prod(x)); }\nbool real(vec3 x){ return real(prod(x)); }\nbool real(vec4 x){ return real(prod(x)); }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n//im not sure if this is linear or srgb, or if that even matters much\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n#define INT_MAX     0x7FFFFFFF\n#define INT_HALFMAX 0x00010000\n#define INT_MAXF     float(INT_MAX)\n#define INT_HALFMAXF float(INT_HALFMAX)\nvec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }\nvec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }\nvec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }\nvec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }\nivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }\nivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }\nivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }\nivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }\n\nivec4 hash(ivec4 x){\n\tx= ((x>>16)^x)*0x45d9f3b;\n\tx= ((x>>16)^x)*0x45d9f3b;\n\t//x=  (x>>16)^x;\n    return x;\n}\n//[-max,+max]->[0,1]\nvec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }\nvec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }\nvec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }\nvec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }\n\n#define R2A vec2(.99231, .9933)\n#define R2B vec2(.99111, .9945)\n#define R3A vec3(.99312, .98313, .9846)\n#define R3B vec3(.99111, .98414, .9935)\n#define R4A vec4(.99412, .99343, .99565, .99473)\n#define R4B vec4(.99612, .99836, .99387, .99376)\nvec1 rand (vec1 x){ return hashf(x);   }\nvec2 rand (vec2 x){ return hashf(x*hashf(x+x.yx)); }\nvec3 rand (vec3 x){ return hashf(x*1.e2+hashf(R3A+x+x.yzx+x.zxy)); }\nvec4 rand (vec4 x){ return hashf(x*hashf(x+x.yzwx+x.zwxy+x.wxyz)); }\nvec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }\nvec1 rand1(vec3 x){ return hashf(dot(x+R3A-R3B,-x+R3B+R3A));  }\nvec1 rand1(vec4 x){ return hashf(dot(x+R4A-R4B,-x+R4B+R4A));  }\nvec2 rand2(vec1 x){ return hashf(x+R2A);   }\nvec3 rand3(vec1 x){ return hashf(x+R3A);   }\nfloat vnse(vec1 x){ return lerp(rand(floor(x)),rand(ceil(x)),fract(x)); }\nfloat vnse(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tfloat nn= rand1(vec2(f.x,f.y));\n\tfloat np= rand1(vec2(f.x,c.y));\n\tfloat pn= rand1(vec2(c.x,f.y));\n\tfloat pp= rand1(vec2(c.x,c.y));\n\tvec4 v= vec4(nn,np,pn,pp);\n\tvec2 lx= lerp(v.xy,v.zw, fr.xx);\n\treturn lerp( lx.x,lx.y, fr.y );\n}\nfloat vnse(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tfloat nnn= rand1(vec3(f.x,f.y,f.z));\n\tfloat nnp= rand1(vec3(f.x,f.y,c.z));\n\tfloat npn= rand1(vec3(f.x,c.y,f.z));\n\tfloat npp= rand1(vec3(f.x,c.y,c.z));\n\tfloat pnn= rand1(vec3(c.x,f.y,f.z));\n\tfloat pnp= rand1(vec3(c.x,f.y,c.z));\n\tfloat ppn= rand1(vec3(c.x,c.y,f.z));\n\tfloat ppp= rand1(vec3(c.x,c.y,c.z));\n\tvec4 zn= vec4(\n\t\tnnn,\n\t\tnpn,\n\t\tpnn,\n\t\tppn\n\t);\n\tvec4 zp= vec4(\n\t\tnnp,\n\t\tnpp,\n\t\tpnp,\n\t\tppp\n\t);\n\tvec4 lx= lerp(zn,zp, fr.zzzz);\n\tvec2 ly= lerp(lx.xz, lx.yw, fr.yy);\n\treturn lerp(ly.x,ly.y, fr.x);\n}\n\nfloat perlin(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= nmaps(rand(vec3(f.x,f.y,f.z)));\n\tvec3 nnp= nmaps(rand(vec3(f.x,f.y,c.z)));\n\tvec3 npn= nmaps(rand(vec3(f.x,c.y,f.z)));\n\tvec3 npp= nmaps(rand(vec3(f.x,c.y,c.z)));\n\tvec3 pnn= nmaps(rand(vec3(c.x,f.y,f.z)));\n\tvec3 pnp= nmaps(rand(vec3(c.x,f.y,c.z)));\n\tvec3 ppn= nmaps(rand(vec3(c.x,c.y,f.z)));\n\tvec3 ppp= nmaps(rand(vec3(c.x,c.y,c.z)));\n\tfloat d_nnn= dot(nnn, vec3(fr .x, fr .y, fr .z));\n\tfloat d_nnp= dot(nnp, vec3(fr .x, fr .y, frn.z));\n\tfloat d_npn= dot(npn, vec3(fr .x, frn.y, fr .z));\n\tfloat d_npp= dot(npp, vec3(fr .x, frn.y, frn.z));\n\tfloat d_pnn= dot(pnn, vec3(frn.x, fr .y, fr .z));\n\tfloat d_pnp= dot(pnp, vec3(frn.x, fr .y, frn.z));\n\tfloat d_ppn= dot(ppn, vec3(frn.x, frn.y, fr .z));\n\tfloat d_ppp= dot(ppp, vec3(frn.x, frn.y, frn.z));\n\tvec4 zn= vec4(\n\t\td_nnn,\n\t\td_npn,\n\t\td_pnn,\n\t\td_ppn\n\t);\n\tvec4 zp= vec4(\n\t\td_nnp,\n\t\td_npp,\n\t\td_pnp,\n\t\td_ppp\n\t);\n\tvec4 lx= lerp(zn,zp, smooth(fr.zzzz));\n\tvec2 ly= lerp(lx.xz, lx.yw, smooth(fr.yy));\n\treturn nmapu(lerp(ly.x,ly.y, smooth(fr.x)));\n}\n\nfloat worley(vec3 c){\n    float acc= 1.;\n    vec3 cfl= floor(c);\n    vec3 cfr= fract(c);\n    for(int i=-1; i<=1; i++){\n    for(int j=-1; j<=1; j++){\n    for(int k=-1; k<=1; k++){\n        vec3 g= vec3(i,j,k)+cfl;\n        vec3 p= rand(g)+g;\n        float l= len(p-c);\n        acc= min(acc,l);\n    }}}\n\treturn acc;\n}\n\n#define dFdxy(x) (vec2(dFdx(x),dFdy(x)))\n#define grad2(f,x) \\\n\t((vec2( \\\n    \tf(x+vec2(ETA,0)), \\\n\t\tf(x+vec2(0,ETA)) \\\n\t  )-f(x))/ETA)\n#define grad3(f,f0,x) \\\n\t((vec3( \\\n    \tf(x+vec3(ETA,0,0)), \\\n\t\tf(x+vec3(0,ETA,0)), \\\n\t\tf(x+vec3(0,0,ETA)) \\\n\t  )-f(x))/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n//azimuth, inclination\nvec3 azincl(vec2 a){\n    a.x+= PI/2.;\n    vec2 s= sin(a);//sin theta, sin phi\n    vec2 c= cos(a);//cos theta, cos phi\n    vec3 ret= vec3(c.x,s);\n    ret.xy*= c.y;\n    return ret;\n}\n\nstruct ray{\n\tvec3 a;\n    vec3 c;\n};\n\n#define FOV 110.\n#define FOV_S tan(deg2rad*.5*FOV)\n#define NEAR .1\n\nray look_persp(vec2 uv, vec2 a){\n\tray o;\n    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uv*FOV_S,1.));\n    o.c= o.a*NEAR;\n    return o;\n}\nray look_orbit(vec2 uv, vec2 a, float d){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= norm( mat * vec3(uv*FOV_S,1.));\n    o.c= mat[2]*-d + o.a*NEAR;\n\treturn o;\n}\n\n#ifdef SHADERTOY\n//rip from https://www.shadertoy.com/view/llySRh\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39  \n#define KEY_DOWN   40   \n#define KEY_PGUP   33  \n#define KEY_PGDOWN 34  \n#define KEY_END    35  \n#define KEY_HOME   36\n#define KEY_SPACE  32\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#endif","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//there exists no analytic solution\n//as the noise hash rand is non integrable\n//writing that made me feel smart\n\n#define SUBDUCTION .0\n#define VISCOSITY .2\n#define HEAT_CONFINEMENT .1\n\n#define CAMERA mat3x2(\\\n 1., 0.,\\\n 0., 1.,\\\n 0., 0.)\n\nvec2 camera(vec2 uv){\n    uv= nmaps(uv);\n    uv.x*= asp;\n\treturn CAMERA*vec3(uv,1.);\n}\n\nfloat nse(vec2 uv){\n    vec2 weights= vec2(2.,1.);\n    weights/= sum(weights);\n    float o0= worley(vec3(uv* 8.,time*.5));\n    float o1= perlin(vec3(uv*40.,time*.05));\n    float d= dot(vec2(o0,o1),weights);\n    //d= 1.-d;\n\treturn d;\n}\n\nvec2 outflow(vec2 uv, vec2 c){\n    #define OUTFLOW 1.0e-4\n    vec2 dp= uv-c;\n    float cmag= sat(1.-2.*len(dp));\n    float clen= len(dp);\n    return dp*OUTFLOW*1./(.1+2.*clen*clen);\n}\n\nvec4 img(vec2 uv){   \n    vec2 uva= uv;\n    uva.x*= asp;\n\tvec2 cam= camera(uv);\n    \n   \n    /*\n    explicit euler FEM, because im dumb\n    constant density\n    compressible/expandible, allowing flow divergence\n\theat+= k*abs(divergence), results in sink\n\tviscous\n\t*/\n            \n    //previous state\n    vec4 bb= texelFetch(iChannel0, ivec2(fc), 0);\n    vec2 v0= bb.zw;\n\tfloat h0= bb.x;\n    vec4 txn= texelFetch(iChannel0, ivec2(fc)+ivec2(-1, 0), 0);\n    vec4 txp= texelFetch(iChannel0, ivec2(fc)+ivec2( 1, 0), 0);\n    vec4 tyn= texelFetch(iChannel0, ivec2(fc)+ivec2( 0,-1), 0);\n    vec4 typ= texelFetch(iChannel0, ivec2(fc)+ivec2( 0, 1), 0);\n    float hxn= txn.x;\n    float hxp= txp.x;\n    float hyn= tyn.x;\n    float hyp= typ.x;\n    vec2 vxn= txn.zw;\n    vec2 vxp= txp.zw;\n    vec2 vyn= tyn.zw;\n    vec2 vyp= typ.zw;\n    //compression\n\tfloat rho= sum(\n\t\tvec4(vxn.x, -vxp.x, +vyn.y, -vyp.y)\n        *(1.-vec4(hxn, hxp, hyn, hyp)));\n    //vorticity ccw\n    //float omega= -vxn.y +vxp.y +vyn.x -vyp.x;\n    //omega*= VORTICITY;\n    //advection\n    vec4 advect= tex(iChannel0, uv-v0/vec2(asp,1.)/1.5);\n    float h= advect.x;\n    //vec2 v= advect.zw;\n    //viscosity\n    vec2 laplacian= vxn+vxp+vyn+vyp-4.*v0;\n    vec2 tau= VISCOSITY*laplacian;\n    vec2 v= v0+tau*rho;\n\n    //flow boundary elements\n    //center\n    v+= outflow(cam, vec2(0.));\n    vec2 dp= cam;\n    float speed= len(v);\n\tv-= dp*dot(-v,-dp)*.02;\n\t//preserve energy\n\tv= norm(v)*speed;\n    \n    //friction\n    v*= pow(.99, 4.);\n\n\n\t//heat\n\th+= SUBDUCTION*rho;\n\t//thermal flow\n    vec2 hgrad= vec2(hxn-hxp, hyn-hyp);\n\tv+= hgrad*.0001;\n\n    //heat noise addition\n    float hnse= nse(cam);\n    float hramp= .5;\n    hnse= (hnse-hramp)/(1.-hramp);    \n    //more heat near center\n    float hlen= sat(1.-len(cam));\n    hnse*= pow(hlen, 3.);\n    h+= hnse*.2;\n\n\t//passive cooling\n    h-= .002;\n    \n    //s+= d*.7;\n    \n    float fracture= worley(vec3(uva*40.,time*.1));\n    //fracture= smooth(fracture);\n    //h+= fracture*.01;\n    //s-= .3*(1.+2.*pow(fracture,25.));\n    \n    float bump= 0.;\n    \n    //boundary elements\n    float m= len(fc-iMouse.xy)<32.? 1.:0.;\n    h+= m*.15;\n    \n    h= sat(h);\n    bump= sats(bump);\n    v= sats(v);\n    \n    return vec4(h,bump,v);\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor=img(fragCoord/iResolution.xy); }\n#endif\n","name":"Buffer A","description":"","type":"buffer"}]}