{"ver":"0.1","info":{"id":"MlGXDK","date":"1485913185","viewed":112,"name":"Death Star","username":"NickPowers43","description":"This shader draws a death star like shape using raymarching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Death Star by Nick Powers\n\nconst float PI = 3.14159265359;\n\nconst int ITERATIONS = 100;\nconst float RANGE = 10.0;\nconst float RAY_INC = RANGE / float(ITERATIONS);\n\nconst float FADE_RANGE = 0.05;\n\nconst float DS_RADIUS = 5.0;\nconst float DS_RADIUS_MIN = DS_RADIUS - FADE_RANGE;\nconst float DS_RADIUS_MAX = DS_RADIUS + FADE_RANGE;\nconst float DS_HOLE_DEPTH = 0.5;\nconst float DS_HOLE_RUN = cos(PI * 0.4);\nconst float DS_EQUA_RUN = cos(PI * 0.499);\nconst float DS_EQUA_SCALE = 0.002;\nconst float DS_HOLE_FADE = 0.075;\nconst float DS_HOLE_RUN_MIN = DS_HOLE_RUN - DS_HOLE_FADE;\nconst float DS_HOLE_RUN_MAX = DS_HOLE_RUN + DS_HOLE_FADE;\n\nconst vec3 MINUS_SUN_DIR = -normalize(vec3(-1.0, -1.0, -1.0));\nconst vec3 HOLE_DIR = normalize(vec3(-1.0, 1.0, 3.0));\n\nconst vec3 HOLE_CENTER = HOLE_DIR * (DS_RADIUS - DS_HOLE_DEPTH);\n\nconst float SPEED = 0.5;\n\nvec4 sampleA(vec3 p)\n{\n    float pL = length(p);\n    float sphereD = 1.0 - smoothstep(DS_RADIUS_MIN, DS_RADIUS_MAX, pL);\n    vec3  sphereN = p * (1.0 / pL);\n    \n    float equaD = step(DS_EQUA_RUN, abs(dot(vec3(0, 1, 0), sphereN)));\n    vec3 color = vec3(1, 1, 1) * ((equaD == 0.0) ? 0.4 : 0.5);\n    \n    vec3 holeOffset = normalize(p - HOLE_CENTER);\n    float cosTheta = dot(HOLE_DIR, holeOffset);\n    float holeD = 1.0 - smoothstep(DS_HOLE_RUN_MIN, DS_HOLE_RUN_MAX, cosTheta);\n    vec3  holeN = cross(holeOffset, cross(HOLE_DIR, holeOffset));\n    \n    float i = holeD * sphereD;\n    vec3 normal = mix(sphereN, holeN, 1.0 - holeD);\n    \n    \n    float light = clamp(dot(normal, MINUS_SUN_DIR), 0.0, 1.0);\n    color *= light;\n    return vec4(color,i);\n}\n\nvec3 rayTest(vec3 origin, vec3 dir)\n{\n    vec3 fColor = vec3(0,0,0);\n    vec3 p = origin + (dir * RANGE);\n    for(int i = 0; i < ITERATIONS; i++)\n    {\n        vec4 s = sampleA(p);\n        fColor = (fColor * (1.0 - s.a)) + (s.xyz * s.a);\n        \n        p -= dir * RAY_INC;\n    }\n    return fColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(10.0 * sin(iTime * SPEED), 0.0, 10.0 * cos(iTime * SPEED));\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n\n    vec3 camZ = normalize(camPos - camTarget);\n    vec3 camX = normalize(cross(vec3(0,1,0), camZ));\n    vec3 camY = cross(camZ, camX);\n\n    mat4 camMat = mat4(\n        vec4(camX, 1.0),\n        vec4(camY, 1.0),\n        vec4(camZ, 1.0),\n        vec4(camPos, 1.0)\n    );\n\n    mat4 viewMat = mat4(\n        vec4(camX.x, camY.x, camZ.x, 1.0),\n        vec4(camX.y, camY.y, camZ.y, 1.0),\n        vec4(camX.z, camY.z, camZ.z, 1.0),\n        vec4(-camPos, 1.0)\n    );\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= aspectRatio;\n    \n    \n    vec3 dir = vec3(uv.x, uv.y, -1.0);\n    dir = normalize(dir);\n    \n    dir = (dir.x * camX) + (dir.y * camY) + (dir.z * camZ);\n    \n    vec3 color = rayTest(camPos, dir);\n    \n\tfragColor = vec4(color.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}