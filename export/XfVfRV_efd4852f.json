{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// SDFs borrowed from Indigo Quilez \n// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat sdStar(in vec2 p, in float r, in float n, in float w)\n{\n    // these 5 lines can be precomputed for a given shape\n    //float m = n*(1.0-w) + w*2.0;\n    float m = n + w*(2.0-n);\n    \n    float an = 3.1415927/n;\n    float en = 3.1415927/m;\n    vec2  racs = r*vec2(cos(an),sin(an));\n    vec2   ecs =   vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= racs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, racs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he , vec2 trapPos)\n{\n    p -= trapPos;\n    \n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n//End of free use code\n\n//These ones I made though after researhcing SDFs for awhile\nfloat myRectangle(vec2 pixel, vec2 size, vec2 position) {\n    vec2 newSpot = abs(pixel - position) - size;\n    return length(max(newSpot, 0.0)) + min(max(newSpot.x, newSpot.y), 0.0);\n}\n\nfloat myCircle(vec2 pixel, float radius, vec2 position)\n{\n    return length(pixel - position) - radius;\n}\n\n\n\n//Applies rotation matrix to a 2D point for an angle theta\nvec2 rotate(vec2 pixel, float angle) {\n    float sinTheta = sin(angle);\n    float cosTheta = cos(angle);\n    return vec2(cosTheta * pixel.x - sinTheta * pixel.y, sinTheta * pixel.x + cosTheta * pixel.y);\n}\n\n\n//Makes a row of stars\nvec3 starRow(vec3 col, float starSize, vec2 pixel, vec2 starPos, float rotationSpeed)\n{\n    //Add a rotation effect varying with time\n    float angle = iTime * rotationSpeed;\n    vec2 distToStar = pixel - starPos;\n    distToStar = rotate(distToStar, angle);\n    \n    float star = sdStar(distToStar, starSize, 5.0, 0.7);\n    \n    //If inside the star color it\n    if (star < 0.0) {\n        col = vec3(1.0, 1.0, 0);\n    }\n\n    //Glow settings\n    vec3 glowColor = vec3(1.0, 0.9, 0.5);\n    float glow = 1.0 - smoothstep(0.0, 0.012, abs(star));\n    col += glow * glowColor;\n    return col;\n}\n\n\n//Noise function for a pixel\nfloat noise(vec2 pixel) {\n    return fract(sin(dot(pixel, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//Smooths the noise effect from the noise function\nfloat smoothNoise(vec2 uv) {\n    vec2 pixel = floor(uv); //Find the pixel corresponding to the noise\n    vec2 mixFactor = fract(uv); //Find the amount of mix to do\n    \n   //Smoothstep between values of 0 and 1, found it makes nice smooth striations\n    vec2 smoothFactor = mixFactor * mixFactor * (3.2 - 2.0 * mixFactor); \n    \n    //Really confusing mix that basically blends the value of the four adjacent pixels together\n    return mix(\n        mix(noise(pixel + vec2(0.0, 0.0)), noise(pixel + vec2(1.0, 0.0)), smoothFactor.x),\n        mix(noise(pixel + vec2(0.0, 1.0)), noise(pixel + vec2(1.0, 1.0)), smoothFactor.x),\n        smoothFactor.y\n    );\n}\n\n//Simple implementation of Fractal Brownian Motion\nfloat fracBrownian(vec2 uv, int fractalIterations) {\n    float value = 0.0;\n    float scale = 1.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < fractalIterations; i++) {\n        value += amplitude * smoothNoise(uv * scale);\n        scale *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvec3 hillGen(vec3 col, vec2 pixel, float hillHeight, float hillFrequency, float hillSpeed, vec3 hillColor) {\n    // Calculate the hill position\n    float x = pixel.x + iTime * hillSpeed;\n    float hillY = sin(x * hillFrequency) * hillHeight;\n\n    // I just played around with a sine graph until I saw a combination I liked\n    hillY += sin(x * hillFrequency * 0.5) * (hillHeight * 0.5);\n    hillY += sin(x * hillFrequency * 1.5) * (hillHeight * 0.3);\n    hillY -= 0.3;\n\n    // If below hill color it\n    if (pixel.y < hillY) {\n        col = mix(col, hillColor, 0.7);\n    }\n\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // All adjustable Paramers\n    // Background gradient colors\n    vec3 topColor = vec3(0.5, 0.3, 0.7);\n    vec3 bottomColor = vec3(0.3, 0.1, 0.4);\n    \n    // Noise\n    int fractalIterations = 5; //Increases noise detail\n\n    // Parameters for a row of stars\n    int numStars = 11;\n    float starSpacing = 0.325;\n    float starSize = 0.025;\n    float movementSpeed = 0.1;\n    float rotationSpeed = 0.1;\n    \n    // Parameters for fog\n    vec3 fogColor = vec3(0.8, 0.7, 0.8);\n    float fogThickness = 0.4;\n    float fogDensity = 5.0;\n    float fogSpeed = 1.0; //Higher makes it faster\n    \n    // Parameters for hills\n    float hillHeight = 0.2;\n    float hillFrequency = 4.0;\n    float hillSpeed = 0.1;\n    float hillDepth = 0.7; //How far the hill is away from the road\n    vec3 hillColor = vec3(0.3, 0.6, 0.2);\n    \n    // Parameters for median\n    float medianHeight = 0.01;\n    float medianBotSize = 0.04;\n    float medianTopSize = 0.0325;\n    float medianSpeed = 0.5;\n    float medianY = -0.825;\n    float medianVibrance = 0.6;\n\n    // Parameters for road\n    vec3 roadColor = vec3(0.3, 0.3, 0.3);\n    float roadHeight = 0.3;\n    float roadSpeed = 10.0 * medianSpeed; //If you want to make the median still travel with the road change the medianSpeed\n    float striationThickness = 10.0; //Higher values make them thinner\n    float striationLength = 2.0; //Higher values make them more blended and less distinct\n    float striationIntensity = 0.3; //How much the noise color influences the final result\n    float roadIntensity = 0.7; //How much the road color influences the final result\n    \n    // Parameters for car (if you move the carPos the entire car will move)\n    // Body\n    vec3 carColor = vec3(0.96, 0.97, 0.996);\n    vec2 carSize = vec2(0.1, 0.025);\n    vec2 carPos = vec2(-1.2, -0.9);  \n    \n    //Roof\n    float roofBotSize = 0.075;\n    float roofTopSize = 0.05;\n    float roofHeight = 0.025;\n    float roofThickness = 0.006;\n    vec3 roofOutlineColor = vec3(0.5, 0.5, 0.5);\n    vec2 roofPos = vec2(carPos.x - 0.006, carPos.y + 0.05);\n    \n    //Wheels\n    vec3 wheelColor = vec3(0.15, 0.15, 0.15);\n    float wheel1Size = 0.025;\n    vec2 wheel1Pos = vec2(carPos.x - 0.05, carPos.y - 0.033);\n    float wheel2Size = 0.025;\n    vec2 wheel2Pos = vec2(carPos.x + 0.05, carPos.y - 0.033);\n    \n    // Parameters for headlights\n    vec2 headLightPos = vec2(carPos.x + 0.06, carPos.y + 0.01);\n    vec2 headLightDir = normalize(vec2(1.0, -0.2)); // Light Direction\n    float headLightIntensity = 0.8; // Light Intensity\n    float headLightAngle = 0.95; // Angle of light cone\n    float headLightRadius = 2.0; // Light Range\n    vec3 headLightColor = vec3(1.0, 0.9, 0.8); // Color of the light\n    \n    // Parameters for ambient light\n    vec2 lightPos = vec2(0.0, 1.0); // Origin point\n    float lightIntensity = 1.2; // Light strength\n    float lightRadius = 2.8; // Light radius\n    vec3 lightColor = vec3(0.7, 0.3, 0.9); // Light color\n\n    \n    ////////////Beginning of Scene Code////////////\n    \n    \n    // Set background\n    vec2 pixel = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float screenWidth = (iResolution.x / iResolution.y) * 2.0;\n    vec3 col = mix(topColor, bottomColor, pixel.y);\n    \n    \n    // Stars\n    // Calculating where to put the stars\n    float offsetS = iTime * movementSpeed;\n    float halfRowWidthS = (float(numStars - 1) * starSpacing) / 2.0;\n    float centerOffsetS = -halfRowWidthS;\n    \n    // Top row\n    for (int i = 0; i < numStars; i++) {\n        //Wrap the stars once they get to the edge of the screen\n        float starX = float(i) * starSpacing + centerOffsetS - offsetS; \n        starX = mod(starX + 0.5 * screenWidth, screenWidth) - 0.5 * screenWidth;\n        vec2 starPos = vec2(starX, 0.85);\n        \n        col = starRow(col, starSize, pixel, starPos, -rotationSpeed);\n    }\n    \n    // Middle row\n    for (int i = 0; i < numStars; i++) {\n        //Wrap the stars once they get to the edge of the screen\n        float starX = float(i) * starSpacing + centerOffsetS + offsetS + 0.15125; \n        starX = mod(starX + 0.5 * screenWidth, screenWidth) - 0.5 * screenWidth;\n        vec2 starPos = vec2(starX, 0.6);\n        \n        col = starRow(col, starSize, pixel, starPos, rotationSpeed);\n    }\n    \n    // Bottom row\n    for (int i = 0; i < numStars; i++) {\n        //Wrap the stars once they get to the edge of the screen\n        float starX = float(i) * starSpacing + centerOffsetS - offsetS; \n        starX = mod(starX + 0.5 * screenWidth, screenWidth) - 0.5 * screenWidth;\n        vec2 starPos = vec2(starX, 0.35);\n        \n        col = starRow(col, starSize, pixel, starPos, -rotationSpeed);\n    }\n    \n    \n    // Add a simple hillscape to the background\n    col = mix(col, hillGen(col, pixel, hillHeight, hillFrequency, hillSpeed, hillColor), hillDepth);\n\n\n    // Left scrolling road\n    if (pixel.y < -1.0 + roadHeight) {\n        vec2 uv = pixel * vec2(striationThickness, striationLength);\n        uv.x += iTime * roadSpeed;\n        float roadTexture = fracBrownian(uv, fractalIterations);\n        float roadMix = roadIntensity + striationIntensity * roadTexture;\n        col = roadColor * roadMix; //Assign the color based on the default road and the noise mix\n    }\n    \n    \n    // Yellow median\n    float offsetM = iTime * medianSpeed;\n    float halfRowWidthM = (float(numStars - 1) * starSpacing) / 2.0;\n    float centerOffsetM = -halfRowWidthM;\n    \n    for (int i = 0; i < 11; i++)\n    {\n        float medX = float(i) * starSpacing + centerOffsetM - offsetM; \n        medX = mod(medX + 0.5 * screenWidth, screenWidth) - 0.5 * screenWidth;\n        vec2 medPos = vec2(medX, medianY);\n        \n        float median = sdTrapezoid(pixel, medianBotSize, medianTopSize, medianHeight, medPos);\n    \n        //If inside the trapezoid color it\n        if (median < 0.0) {\n            col = mix(col, vec3(1.0, 1.0, 0), medianVibrance);\n        }\n    }\n    \n    \n    // Fog Effect\n    float fogIntensity = fracBrownian((pixel * fogDensity + iTime * fogSpeed), fractalIterations) * fogThickness;\n    col = mix(col, fogColor, fogIntensity);\n    \n\n    // Car\n    float body = myRectangle(pixel, carSize, carPos);\n    if (body < 0.0) {\n        col = carColor;\n    }\n    \n    float roof = sdTrapezoid(pixel, roofBotSize, roofTopSize, roofHeight, roofPos);\n    if (roof < 0.0) {\n        float outline = step(roofThickness, abs(roof));\n        col = mix(roofOutlineColor, carColor, outline);\n    }\n    \n    float wheel1 = myCircle(pixel, wheel1Size, wheel1Pos);\n    if (wheel1 < 0.0) {\n        col = wheelColor;\n    }\n    \n    float wheel2 = myCircle(pixel, wheel2Size, wheel2Pos);\n    if (wheel2 < 0.0) {\n        col = wheelColor;\n    }\n    \n\n    // Calculate headlight effect\n    vec2 toPixel = pixel - headLightPos; // Vector from light to the pixel\n    float headLightDist = length(toPixel); // Distance to the light\n    vec2 toPixelDir = normalize(toPixel); // Direction to the pixel\n\n    // Check how close to the center of the light the pixels are and apply lighting\n    float angleEffect = max(0.0, dot(headLightDir, toPixelDir)); //Beam angle\n    float inBeam = smoothstep(headLightAngle, 1.0, angleEffect);\n    float distanceEffect = 1.0 - smoothstep(0.0, headLightRadius, headLightDist); // Light falloff\n    float lightEffect = headLightIntensity * inBeam * distanceEffect;\n    col += headLightColor * lightEffect;\n\n\n    // Ambient Light Effect \n    if (pixel.y < -1.0 + roadHeight) {\n        float distanceToLight = length(pixel - lightPos);\n        float lightEffect = max(0.0, 1.0 - (distanceToLight / lightRadius)); // Light falloff\n\n        \n        col += lightEffect * lightColor * lightIntensity;\n    }\n    \n    //Set the pixel color!!\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfVfRV","date":"1734215703","viewed":30,"name":"CS112 Final Project","username":"adrutled","description":"CS 112 Final","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["schoolwork"],"hasliked":0,"parentid":"","parentname":""}}