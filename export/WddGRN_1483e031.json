{"ver":"0.1","info":{"id":"WddGRN","date":"1567963081","viewed":268,"name":"wire net","username":"kaswan","description":"wire net","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["weave","wireneting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAX_ITERATION 64\n#define PI 3.1415926535\n\nfloat sphere(vec3 p, vec3 c, float r)\n{\n\treturn length(p - c) - r;\n}\n\nfloat sdBox(vec3 p, vec3 c, vec3 b)\n{\n\tvec3 d = abs(p - c) - b;\n    return  max(max(d.x, d.y), d.z); \n}\n\nfloat sdCylinder(vec3 p, vec3 c, vec2 h)\n{\n  \tp -= c;\n    \n    vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveV(vec3 p, vec2 h)\n{\n\tp.z += sin(p.y * 1.0) * 0.2;\n  \t\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveV2(vec3 p, vec2 h)\n{\n\tp.z += sin(p.y * 1.0 + PI) * 0.2;\n  \t\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveH(vec3 p, vec2 h)\n{\n  \tp.xyz = p.yxz;\n\tp.z += sin(p.y * 1.0) * 0.2;\n  \t\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveH2(vec3 p, vec2 h)\n{\n  \tp.xyz = p.yxz;\n\tp.z += sin(p.y * 1.0 + PI) * 0.2;\n    \n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat scene(vec3 pos)\n{\n \tfloat grid_size = PI;\n    vec3 p, pR;\n    float d; \n    \n    vec3 sph = vec3(15.0 * sin(iTime), 15.0 * cos(iTime), 3.0);\n    vec3 box = vec3(15.0 * sin(iTime + PI), 15.0 * cos(iTime + PI), 4.0);\n    \n    float theta = 2.0 * iTime * PI / 180.0;\n\tfloat c = cos(iTime * 0.25);\n    float s = sin(iTime * 0.25);\n    \n    float deg = -60.0;\n    float rad = deg * PI / 180.0;\n    p = pos;\n    pos.y = p.y * cos(rad) + p.z * sin(rad);\n    pos.z = -p.y * sin(rad) + p.z * cos(rad);\n    \n    vec2 r = pos.xy - sph.xy;\n    float h = 5.0 / (1.0 + .01 * dot(r, r)); \n    pR.x = pos.x * c + pos.y * s;\n\tpR.y = pos.x * -s + pos.y * c;\n\tpR.z = pos.z + h;\n    //pR = pos;\n    \n    p = pR;\n    p.x += grid_size * 0.5;\n    p.x = mod(p.x, grid_size * 2.0) - grid_size;\n\td = sdCylinderWaveV(p, vec2(0.2, 150));\n\n    p = pR;\n    p.x += grid_size * 0.5;\n    p.x = mod(p.x + grid_size, grid_size * 2.0) - grid_size;\n\td = min(d, sdCylinderWaveV2(p, vec2(0.2, 150)));\n    \n    p = pR;\n    p.y -= grid_size * 0.5;\n    p.y = mod(p.y, grid_size * 2.0) - grid_size;\n    d = min(d, sdCylinderWaveH(p, vec2(0.2, 150)));\n\n\tp = pR;\n    p.y -= grid_size * 0.5;\n    p.y = mod(p.y + grid_size, grid_size * 2.0) - grid_size;\n    d = min(d, sdCylinderWaveH2(p, vec2(0.2, 150)));\n\n    d = min(d, sphere(pos, sph, 6.0));\n    d = min(d, sdBox(pos, box, vec3(4.0, 4.0, 4.0)));\n    d = min(d, sdCylinder(pos, vec3(0.0, 0.0, 4.0), vec2(4.0, 4.0)));\n    \n    return d;\n}\n\nvec3 normal(vec3 pos)\n{\n \tvec3 e = vec3(EPSILON, 0, 0);\n    \n    vec3 n;\n    n.x = scene(pos + e.xyy) - scene(pos - e.xyy);\n    n.y = scene(pos + e.yxy) - scene(pos - e.yxy);\n    n.z = scene(pos + e.yyx) - scene(pos - e.yyx);\n    \n    return normalize(n);\n}\n\nvec3 lightDir = vec3(1.0, 2.5, 1.0);\n\nvec3 traceReflect(vec3 pos, vec3 ray)\n{\n    pos += ray * 0.1;\n    \n    for (int i = 0; i < MAX_ITERATION; i++){\n    \tfloat d = scene(pos);\n        if (abs(d) < EPSILON){\n            \n            vec3 color = vec3(0.0, 1.0, 1.0);\n            \n            vec3 N = normal(pos);\n            vec3 L = normalize(lightDir);\n\t\t\tfloat diffuse = max(dot(N,L), 0.0);\n            \n\t\t\tcolor *= diffuse;\n\n            //vec3 R = reflect(-L,N);\n\t\t\t//vec3 V = -ray;\n            //float specular = pow(max(dot(R,V), 0.0), 32.0);\n            \n            //color += specular;\n\n\t\t\treturn color * 0.6;\n        }\n    \t\n        pos += ray * d;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= aspectRatio;\n    \n    vec3 pos = vec3(0.0, 0.0, 50.0);\n\n    vec3 dir = normalize(vec3(uv, -3.0));\n    \n    for (int i = 0; i < MAX_ITERATION; i++){\n    \tfloat distance = scene(pos);\n        if (distance < EPSILON){\n            \n            vec3 color = vec3(0.5, 0.5, 0.5);\n            \n            // diffuse\n            vec3 N = normal(pos);\n            vec3 L = normalize(lightDir);\n\t\t\tfloat diffuse = max(dot(N,L), 0.0);\n\t\t\tcolor *= diffuse;\n\n            // specular by Phong model\n            //vec3 R = reflect(-L,N);\n            //vec3 V = -dir;\n            //float specular = pow(max(dot(R,V), 0.0), 32.0);\n            \n            // specular by Blinn model\n\t\t\tvec3 V = -dir;\n            vec3 H = normalize(V + L);\n            float specular = pow(max(dot(H,N), 0.0), 32.0);\n\n            // reflection\n            vec3 Ref = reflect(-V,N);\n            //vec3 Ref = refract(-V, N, 0.96);\n            vec3 reflectColor = traceReflect(pos, Ref);\n            color += reflectColor;\n\n            color += specular;\n\n\t\t\tfragColor = vec4(color, 1.0);\n\n            return;\n        }\n        pos += dir * distance;\n    }\n\tfragColor = vec4(0.1, 0.4, 0.6, 1.0);\n}","name":"Image","description":"","type":"image"}]}