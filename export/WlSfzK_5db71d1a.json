{"ver":"0.1","info":{"id":"WlSfzK","date":"1600357111","viewed":103,"name":"Torus_Thingy_23","username":"balkhan","description":"Mouse rotate toris,\nTrying to comment the code ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","mouse","raymarch","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define R iResolution.xy\n#define A(u) texture(iChannel0, u)\n#define B(u) texture(iChannel1, u)\n#define C(u) texture(iChannel2, u)\n\nvec3 tex; // global variable holding texture coordinates and then final color\n\n// 2D rotation utility\nvoid rot(inout vec2 p, float a)\n{\n    p = vec2(cos(a)*p.x + sin(a)*p.y, -sin(a)*p.x + cos(a)*p.y);\n}\n\nfloat map(vec3 p)\n{\n    float ret, a_XY, a_q_XY;        // variables explained at affectation\n    vec2 q, displace_tex, tcd;\n    rot(p.zx, 6.*iMouse.x/R.x);     // rotate space around zx with mouse\n    a_XY = atan(p.x, p.y);          // angle x^y\n    q = vec2(length(p.xy)-.5, p.z); // torus space vector laying along xy plane, hole being from z direction\n    rot(q, iTime*.5 + a_XY );       // rotate torus space along angle x^y\n    q.y = abs(q.y)-.125;            // take the absolute value of one axis to get a symmetry of the torus space along 0 starting at .125 unit from 0\n    a_q_XY = atan(q.x, q.y);        // angle qx^qy <==> angle ON the ring of the torus <==> location on the ring from center to exterior\n    tex = vec3(.0);                 // this is going to contain the color from characters texture\n    \n    tcd = vec2(a_q_XY/5., a_XY/1.256); // the 2 angles we have for the torus are our texture coordinates\n                                       // dividing tcd by value greater than 1 allow to \"zoom in\" the texture \n                                       // This let see letters more clearly\n\n    // here is texture animation\n    // what this is doing : adding a ramping [-2:+2] value to one of the texture coordinate at a time, \n    // alternating between them at a regular interval\n    // to have a displacement dependent of 1 column/line\n    // you need to floor/ceil the texture coordinates  to get an id \n    // then feed it to a sinus function after multiplying it by something larger to get more riples from the sin\n    // remap [-1,1] to [-2,2]\n    displace_tex =\n    sin(floor(tcd.yx*16.)*2.+vec2(1.,-1.)*iTime/4.)*2. // id part\n    *\n    vec2(\n        smoothstep(1.5, 1., mod(iTime/4.   , 4.)) // alternate axis part\n        ,\n        smoothstep(1.5, 1., mod(iTime/4.+2., 4.))\n        );\n    // add the displacement to the texture coordinates\n    tcd += displace_tex;\n    // sampling the letter texture \n    tex.x = A(tcd).x;\n    \n    // getting the distance field of the toris with a small texture displacement\n    ret = length(q) - .11-.005*length(tex);\n    // store an id of the texture coordinates in tex.yz for coloring each square differently, this is done in main\n    tex.yz = vec2(floor(tcd.xy*16.)/16.);\n\n    return ret*.7; // multiply the distance field by a value inferior to 1 to lessen artifacts\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    o = o-o;\n    vec2 uv = (f-.5*R)/R.yy;            // making a screen centered vector for x & y axises\n    vec3 dir = normalize(vec3(uv, 1.)); // using said vector to make the direction of the ray\n    vec3 pos = vec3(.0, .0, -2.);       //starting position of the ray\n    vec2 dist = vec2(0.);               // variable holding {last_distance, sum_distances}\n    bool hit = false;\n    vec3 p;                             // this is the ray\n    for(int i = 0; i < 64; i++)         // marching loop\n    {\n        p = pos + dist.y * dir;         // update the ray position\n        dist.x = map(p);                // distance to closest object from ray + texture_id\n        dist.y += dist.x;               // sum the distance\n\n        if(dist.x < 0.001)              // we hit, assign hit to true and break out of the loop\n        {\n            hit = true;\n            break;\n        }\n    }\n\n    // Here coloring starts\n    // I use the 2nd texture to color the toris\n    // the variable \"tex\" contained cells id on it's yz vector part and the x part wich was a 0 or 1 indicating the presence of a letter\n    // the variable is overwritten by the final coloring in wich we use the ids\n    // I sample the texture using 2 different coordinates so that letters and their background are not the same\n    tex = \n        B( tex.yz * vec2(1.5, -1.5) ).xyz * tex.x      // this affect the color of the letters\n        +\n        B( tex.yz ).xyz                   * (1.-tex.x) // this affect the toris non_lettered parts color\n        ;\n\n    // affect color to output variable\n    o.xyz = \n        (hit ? 1. : .0) * (tex)                        // textured toris color\n        +\n        (hit ? 0. : 1.) * C(dir).xyz                   // cubemap bgd color\n        ;\n    \n    //o.xyz = vec3(o.x * .3 + o.y* .59 + o.z*.11);     // b&w mode (grayscale conversion)\n}","name":"Image","description":"","type":"image"}]}