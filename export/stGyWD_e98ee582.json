{"ver":"0.1","info":{"id":"stGyWD","date":"1661460564","viewed":112,"name":"periodic minimal surfaces","username":"tk87","description":"4*4 variations","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//periodic minimal surfaces\n//TYPE 0: G, 1:D, 2:P, 3:N\n\n#define TYPE1 3\n#define TYPE2 3\n\n#define THICKNESS .1\n\nconst float PI = 3.141592653589793;\nconst float EPS = .001;\n\nfloat BSCALE = 4.;\nvec3 SCALE1, SCALE2;\n\n\nmat3 setCamera(vec3 ro, vec3 tg, float cr){\n\tvec3 cw = normalize(tg-ro);\n\tvec3 cu = normalize(cross(cw,vec3(sin(cr), cos(cr), 0.0)));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nfloat type_g(vec3 p, vec3 scale, float bscale, float th){\n    return (abs(dot(sin(p*scale),cos(p.yzx*scale)))-th)/bscale*.5;\n}\n\nfloat type_d(vec3 p, vec3 scale1, vec3 scale2, float bscale, float th){\n    return \n        (abs(\n            cos(p.x*scale1.x)*cos(p.y*scale1.y)*cos(p.z*scale1.z) \n            - sin(p.x*scale2.x)*sin(p.y*scale2.y)*sin(p.z*scale2.z)\n            )\n        -th\n        )/bscale*.5;\n}\n\nfloat type_p(vec3 p, vec3 scale, float bscale, float th){\n    return (abs(cos(p.x*scale.x)+cos(p.y*scale.y)+cos(p.z*scale.z))-th)/bscale*.5;\n}\n\nfloat type_n(vec3 p, vec3 scale1, vec3 scale2, float bscale, float th){\n    return \n        (abs(\n            3.*cos(p.x*scale1.x)+cos(p.y*scale1.y)+cos(p.z*scale1.z)\n            + 4.*cos(p.x*scale2.x)*cos(p.y*scale2.y)*cos(p.z*scale2.z)\n        )\n        -th)/bscale*.125;\n}\n\nfloat map(vec3 p){\n    float d=-1e5;\n    \n    for(float i=2.;i<5.;++i){\n        vec3 s = vec3(pow(i*.7,6.));\n        #if TYPE1 == 0\n            d = max(d, type_g(p, s, s.x, .3));\n        #elif TYPE1 == 1\n            d = max(d, type_d(p, s, s, s.x, .3));\n        #elif TYPE1 == 2\n            d = max(d, type_p(p, s, s.x, .3));\n        #else\n            d = max(d, type_n(p, s, s, s.x, .3));\n        #endif\n    }\n\n    #if TYPE2 == 0\n        d = max(d, type_g(p, SCALE1, BSCALE, THICKNESS));\n    #elif TYPE2 == 1\n        d = max(d, type_d(p, SCALE1, SCALE2, BSCALE, THICKNESS));\n    #elif TYPE2 == 2\n        d = max(d, type_p(p, SCALE1, BSCALE, THICKNESS));\n    #else\n        d = max(d, type_n(p, SCALE1, SCALE2, BSCALE, THICKNESS));\n    #endif\n\n    //d = min(d, length(p)-.1);\n\n    return d;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, float t){\n\n    SCALE1 = vec3(sin(t),sin(t*1.13),sin(t*1.3))*BSCALE;\n    SCALE2 = vec3(sin(t*1.1),sin(t*1.23),sin(t*1.37))*BSCALE;\n\n    vec3 col = vec3(0);\n    float td = .1, d;\n    vec3 p;\n    for(float i=.0;i<90.;++i){\n        p = ro + td * rd;\n        d = map(p);\n        \n        if(d<EPS){\n            d=max(d,EPS*.5);\n            col += 10./exp(d*5e3) * 100. *abs(p)/exp(length(p)*2.5);\n            break;\n        }\n\n        td += d;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float t = iTime;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.y, iResolution.x);\n    vec3 col = vec3(0);\n    \n    vec3 ro, tg;\n    \n    t*=.1;\n\n    ro = vec3(cos(t)*3., 0., sin(t)*3.);\n    tg = vec3(0);\n\n    mat3 ca = setCamera(ro, tg, 0.);\n    vec3 rd = ca * normalize(vec3(uv, 1.));\n\n    col = raymarch(ro, rd, t);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}