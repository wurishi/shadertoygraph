{"ver":"0.1","info":{"id":"DtjSzh","date":"1675679622","viewed":81,"name":"Noise-Study","username":"jynwang","description":"Noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE (1.)\n#define UNIT (0.005 * SCALE)\n#define SMAA(d)     ( smoothstep(UNIT, 0., d) )\n#define SPEED 0.05\n\nfloat hash (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat saturate(float x) {\n\n   return x < 0. ? 0. : min(x, 1.);\n}\n\n\n// 绘制的函数\nfloat f(float x) { \n    x *= 10.;\n   \n    return 0.1 * fract(sin(x) * 43758.5453123); \n}\n\nfloat f2(vec2 x) { \n  \n    x *= 60.;\n    x = floor(x);\n    // 魔法数字 \n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453123); \n}\n\n\nfloat f22(vec2 x) { \n  \n    x *= 1.;\n    float fractTerm = fract(dot(x, vec2(12.9898, 78.233)));\n    x = floor(x);\n    // 魔法数字 \n    return mix(f2(x), f2(x + vec2(12000.9898, 78000.233)), fractTerm); \n}\n\nfloat fbm(vec2 x, float amplitude, float frequency, int octaves)\n{\n    float y = 0.;\n    for(int i = 0; i < octaves; ++i)\n    {\n        y += amplitude * noise(frequency * x);\n        \n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    return y;\n}\n\nfloat dfdx(float x) { return (f(x+UNIT) - f(x)) / UNIT; }\n\n\nfloat SMAA_RAW(float x) {\n\n   float a = UNIT;\n   float b = 0.;\n   float t = saturate((x - a) / (b - a));\n   return 3. * t * t - 2. * t * t * t;\n\n}\n\n\n\nfloat vertical_line(vec2 uv, float x0) { return SMAA_RAW(abs(uv.x-x0)); }\nfloat horizontal_line(vec2 uv, float y0) { return SMAA_RAW(abs(uv.y-y0)); }\n\nfloat draw_explicit_func(vec2 uv, float fx, float dfdx)\n{\n    float sdf = uv.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); \n    return SMAA_RAW(abs(sdf) / dsdx );\n                           \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 range = uv;\n    \n    uv.x += iTime * SPEED;\n    if (range.x < 0.5 && range.y > 0.5) {\n    //第一格子\n       \n        uv *= SCALE;\n        range.x *= (iResolution.x / iResolution.y);\n        vec2 center = vec2(0.25, 0.75);\n        vec3 color = vec3(1);\n         // draw line\n        color = mix(color, vec3(0), vertical_line(range, center.x));\n        color = mix(color, vec3(0), horizontal_line(range, center.y));\n       \n        color = mix(color, vec3(1,0,0), draw_explicit_func(uv - center, f(uv.x - center.x), dfdx(uv.x - center.x)));\n    \n        fragColor = vec4(color, 1);\n        \n        \n    } else if (range.x > 0.5 && range.y > 0.5) {\n    // 第二格子\n        \n        fragColor = vec4(f2(uv), f2(uv), f2(uv), 0.);\n      \n    \n    } else if (range.x < 0.5 && range.y < 0.5) {\n    // 第三格子\n    \n        mat2 rotation = mat2(cos(f2(uv)), -sin(f2(uv)), sin(f2(uv)), cos(f2(uv)));\n        fragColor = vec4(f22(uv * rotation), f22(uv * rotation), f22(uv * rotation), 0.);\n    } else {\n    \n        fragColor = vec4(\n        fbm(uv, hash(fract(uv) + uv), 25.0, 8), \n        fbm(uv,hash(fract(uv + 1000.0) + uv), 20.0, 8), \n        fbm(uv, hash(fract(uv + 2000.0) + uv),10.0, 8),\n        0.);\n        \n    }\n    \n}","name":"Image","description":"","type":"image"}]}