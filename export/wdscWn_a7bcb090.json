{"ver":"0.1","info":{"id":"wdscWn","date":"1584594487","viewed":312,"name":"getting started on Shadertoy","username":"LoneCactusMotel","description":"An intersection of two spheres with noise and sine displacement.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 estimate_normal(vec3 p);\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c);\nfloat noise(vec3 p);\n\n// return value encodes color in xyz/rgb and distance in w/a components.\nvec4 opSmoothIntersection(vec4 d1, vec4 d2, float k);\n\nvec4 sdf_sin_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color);\nvec4 sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color);\n\n\nvec4 sdf_scene(vec3 probe)\n{\n    return opSmoothIntersection(sdf_sin_sphere(vec3(0.0, sin(0.7*iTime), -8.200), 1.0, probe, vec3(0.0, 1.0, .8)),\n                                sdf_noisy_sphere(vec3(sin(iTime), 0.0, -8.200), 0.8000, probe, vec3(1.0, 1.0, 0.0)),\n                                0.5);\n}\n\n\n// Fragment function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2((fragCoord.x - 0.5*iResolution.x)/iResolution.y , (fragCoord.y - 0.5*iResolution.y)/iResolution.y);\n\n\tfloat eps = 0.0015;\n\tvec3 light = vec3(-3.0+3.0*sin(iTime), 4.0+3.0*sin(1.3*iTime), 8.0);\n\tvec3 camera = vec3(0.0, 0.0, 4.0);\n\tvec3 pixel = vec3(uv, 0.0);\n\tvec3 ray = normalize(pixel-camera);\n\tvec3 probe = camera;\n\tvec4 dist = vec4(0.0, 0.0, 0.0, 2.0*eps);\n    \n    const float min_z = -20.0;\n    const int max_iterations = 500;\n\n    int final_its = max_iterations;\n    \n\tfor(int its=max_iterations; its>0; its-=1)\n\t{\n\t    final_its = its-1;\n\n\t\tdist = sdf_scene(probe);\n\t\tprobe = probe + (dist.w * ray);\n        if(dist.w <= eps || probe.z <= min_z)\n        {\n            break;\n        }\n\t}\n\n\tif (dist.w <= eps)\n\t{\n\t\tvec3 normal = estimate_normal(probe);\n\t\tvec3 color = dist.rgb;\n\t\tfragColor = phong_shading(probe, normal, light, camera, color);\n\t}\n\telse if(final_its <= 0)\n\t{\n\t\tfragColor = vec4(1, 1, 0, 1);\n\t}\n\telse if(probe.z <= min_z)\n\t{\n\t\tfragColor = vec4(0, 0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(1, 1, 1, 1);\n\t}\n}\n\n\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip;\n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat sin_displacement(vec3 p, float frequency)\n{\n\treturn sin(frequency*p.x)*sin(frequency*p.y)*sin(frequency*p.z);\n}\n\n\n// smooth intersection (IQ) with added color blend\nvec4 opSmoothIntersection(vec4 d1, vec4 d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec4 sdf_sin_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color)\n{\n\treturn vec4(color, distance(probe, sphere_center) - sphere_radius + 0.05*sin_displacement(probe, 20.0));\n}\n\nvec4 sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color)\n{\n\tvec3 nrml = normalize(probe-sphere_center);\n\treturn vec4(color, distance(probe, sphere_center) - sphere_radius - 0.5*noise(2.6*(nrml+vec3(0.2*iTime, 0.2*iTime, iTime))));\n}\n\n\n\nvec3 estimate_normal(vec3 p) {\n\tfloat eps = 0.001;\n    return normalize(vec3(\n        sdf_scene(vec3(p.x + eps, p.y, p.z)).w - sdf_scene(vec3(p.x - eps, p.y, p.z)).w,\n        sdf_scene(vec3(p.x, p.y + eps, p.z)).w - sdf_scene(vec3(p.x, p.y - eps, p.z)).w,\n        sdf_scene(vec3(p.x, p.y, p.z + eps)).w - sdf_scene(vec3(p.x, p.y, p.z - eps)).w\n    ));\n}\n\n\n// p: point on surface\n// n: surface normal at p\n// l: position of light source\n// v: position of viewer\n// c: diffuse color\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c)\n{\n\tvec3 light = normalize(l);\n\tvec3 r     = reflect(light, n);\n\tvec3 view  = normalize(v-p);\n\tfloat diffuse  = max(0.0, dot(light, n));\n\tfloat specular = max(0.0, dot(-r, view));\n\tvec3 color = diffuse * c + pow(specular, 40.0) * vec3(1, 1, 1);\n\treturn vec4(color, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}