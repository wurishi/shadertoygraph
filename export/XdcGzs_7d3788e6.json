{"ver":"0.1","info":{"id":"XdcGzs","date":"1452679690","viewed":311,"name":"Whirlpool 128","username":"rohtie","description":"Spiral out, keep going.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["whirldistancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 map (vec3 point) {\n    float t = iTime;    \n    float r = point.y;\n    \n    \n    point.xz *= mat2(cos(t), -sin(t),\n                     sin(t), cos(t));\n    \n    float whirl0 = texture(iChannel1, point.xy * point.yz).r;\n    \n    \n    float whirl1 = texture(iChannel1, point.xz * point.yx).r;\n    \n    \n    if (t > 10.0 && mod(t, 2.0) > -1.0 && mod(t, 2.0) < 1.0) {\n    \twhirl0 = whirl1;\n    }\n\n    float result = min(whirl0, whirl1);\n    \n    float material = 0.0;\n    \n    if (result == whirl0) {\n    \tmaterial = 1.0;\n    } \n    \n    vec2 res = vec2(r + mix(whirl0, whirl1, mod(t, 200.0)), material);\n    \n    res.x += texture(iChannel0, point.xz * point.yx).r;\n    \n    \n    return res;\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy).x,\n        map(point + extraPolate.yxy).x,\n        map(point + extraPolate.yyx).x\n    ) - map(point).x);\n}\n\nvec3 light = normalize(vec3(2.0, 2.0, 10.0));\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n\tpoint.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, 2.0);\n\n    vec3 rayDirection = normalize(vec3(point, -1.0));\n    \n    //float distance = intersect(cameraPosition, rayDirection);\n    \n\tvec3 rayOrigin = cameraPosition;\n    \n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n    \n    float distance = 0.0;\n\n    vec2 currentDistance = vec2(1.0, 0.0);\n    float material = 0.0;\n    \n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance.x < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        currentDistance = map(rayOrigin + rayDirection * distance);\n\n        distance += currentDistance.x;\n        material = currentDistance.y;\n    }\n    \n    vec3 col = vec3(0.0);\n\n    vec3 blue_d = vec3(0.05, 0.01, 0.35);\n    vec3 blue_s = vec3(0.7, 1.0, 0.95);\n    \n    vec3 oran_d = vec3(0.45, 0.25, 0.15);\n    vec3 oran_s = vec3(1.0, 0.5, 0.25);\n    \n    vec3 diff = blue_d;\n    vec3 spec = blue_s;\n    \n    if (distance < maxDistance) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n        \n        if (material == 1.0) {\n            diff = mix(blue_d, oran_d, 0.25 + sin(iTime) * 0.25);\n            spec = oran_s;\n        }\n        \n        col += diff;\n        col += spec * max(dot(normal, light), 0.0);\n        \n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n        \n        col -= point.z * 0.25;\n        col *= 2.0;\n        \n    }\n    \n    color.rgb = col;\n}\n","name":"Image","description":"","type":"image"}]}