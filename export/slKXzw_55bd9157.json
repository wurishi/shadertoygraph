{"ver":"0.1","info":{"id":"slKXzw","date":"1640409570","viewed":283,"name":"Windows 11 Frosted Glass","username":"Sturdyfool10","description":"I designed this to mimic windows 11's transparency effects, I am not too great at shaders though","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["interactive","blur","windows11"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//constands are located here\nfloat blurRadius = 32.0;\nfloat blurSamples = 64.0;\nfloat m = 0.5; //mix, 0 is blur, 1 is background color\nvec3 backgroundColor = vec3(0.2, 0.2, 0.2);\n//end constants\n\nfloat dist(float a, float b) {\n    return max(a, b) - min(a, b);\n}\nfloat hypot(vec2 a, vec2 b) {\n    float diffX = dist(a.x, b.x);\n    float diffY = dist(a.y, b.y);\n    return sqrt(diffX * diffX + diffY * diffY);\n}\nbool isInCircle(vec2 origin, float radius, vec2 point) {\n    if (hypot(origin, point) - radius < 0.0) return true;\n    return false;\n}\nbool isInRect(vec2 topLeftCorner, float width, float height, vec2 point) {\n    vec2 bottomRightCorner = vec2(topLeftCorner.x + width, topLeftCorner.y + height);\n    if (point.x < topLeftCorner.x) return false;\n    if (point.y < topLeftCorner.y) return false;\n    if (point.x > bottomRightCorner.x) return false;\n    if (point.y > bottomRightCorner.y) return false;\n    return true;\n}\nbool isInRoundedRect(vec2 topLeftCorner, float width, float height, float cornerRadius, vec2 point) {\n    vec2 bottomRightCorner = vec2(topLeftCorner.x + width, topLeftCorner.y + height);\n    if (cornerRadius >= min(width, height) / 2.0) {\n        //special case to simplify pill shaped ones\n        float rad = min(width, height) / 2.0;\n        vec2 CirclePos = vec2(topLeftCorner.x + rad, topLeftCorner.y + rad);\n        vec2 Circle1Pos = vec2(bottomRightCorner.x - rad, bottomRightCorner.y - rad);\n        vec2 rectStart = vec2(CirclePos.x, topLeftCorner.y);\n        float widRect = width - (2.0 * rad);\n        return isInCircle(CirclePos, rad, point) || isInCircle(Circle1Pos, rad, point) || isInRect(rectStart, widRect, height, point);\n    } else {\n        float rad = cornerRadius;\n        vec2 xs = vec2(topLeftCorner.x + cornerRadius, bottomRightCorner.x - cornerRadius);\n        vec2 ys = vec2(topLeftCorner.y + cornerRadius, bottomRightCorner.y - cornerRadius);\n        vec2 CirclePos = vec2(xs.x, ys.x);\n        vec2 Circle1Pos = vec2(xs.y, ys.y);\n        vec2 Circle2Pos = vec2(xs.x, ys.y);\n        vec2 Circle3Pos = vec2(xs.y, ys.x);\n        vec4 rectDef = vec4(CirclePos.x, topLeftCorner.y, width - (2.0 * cornerRadius), height);\n        vec4 rect1Def = vec4(topLeftCorner.x, ys.x, cornerRadius, height - (2.0 * cornerRadius));\n        vec4 rect2Def = vec4(xs.y, ys.x, cornerRadius, height - (2.0 * cornerRadius));\n        return isInCircle(CirclePos, rad, point) || isInCircle(Circle1Pos, rad, point) || isInCircle(Circle2Pos, rad, point) || isInCircle(Circle3Pos, rad, point) || isInRect(vec2(rectDef.x, rectDef.y), rectDef.z, rectDef.w, point) || isInRect(vec2(rect1Def.x, rect1Def.y), rect1Def.z, rect1Def.w, point) || isInRect(vec2(rect2Def.x, rect2Def.y), rect2Def.z, rect2Def.w, point);\n    }\n}\n//begin color based code below\nvec2 pixelateUV(vec2 coord, float factor) {\n    return floor(coord / factor) * factor;\n}\nfloat random2 (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))* 43758.5453123);\n}\n#define PI2 6.2831853072 // PI * 2\n#define PI_O_2 1.5707963268 // PI / 2\nvec3 blur(vec2 uv, float passes, float radius, float lossiness) {\n    const float preserveOriginal = 0.0;\n    vec2 pixel = 1.0 / iResolution.xy;\n\n    float count = 1.0 + preserveOriginal;\n    vec4 color = texture(iChannel0, uv) * count;\n    float directionStep = PI2 / passes;\n\n    vec2 off;\n    float c, s, dist, dist2, weight;\n    for(float d = 0.0; d < PI2; d += directionStep) {\n        c = cos(d);\n        s = sin(d);\n        dist = 1.0 / max(abs(c), abs(s));\n        dist2 = dist * (2.0 + lossiness);\n        off = vec2(c, s);\n        for(float i= dist * 1.5; i <= radius; i += dist2) {\n            weight = i / radius; // 1.0 - cos(i / radius * PI_O_2);\n            count += weight;\n            color += texture( iChannel0, uv + off * pixel * i) * weight;\n        }\n    }\n    vec4 toRet = color / count;\n    return vec3(toRet.x, toRet.y, toRet.z);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordnates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = iMouse.xy;\n    // Time varying pixel color\n    //vec3 col = vec3(isInCircle(center, 100.0, fragCoord));\n    vec4 color = texture(iChannel0, uv);\n    vec3 col = blur(uv, blurSamples, blurRadius, 2.0) * (1.0 - m) + (m * backgroundColor);\n    if (isInRoundedRect(center - vec2(100.0, 100.0), 200.0, 200.0, 20.0, fragCoord) == false) {\n        col = vec3(color.x, color.y, color.z);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}