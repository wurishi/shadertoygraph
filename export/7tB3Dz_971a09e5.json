{"ver":"0.1","info":{"id":"7tB3Dz","date":"1623699612","viewed":161,"name":"DoF, CA, OL, Camera demo, Enjoy!","username":"pyrite","description":"DoF, Depth of Field, \nCA, Chromatic Abberation, \nOL, OutLiness\nPlease modify lines 49-55 to see what the camera can do!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["dof","depthoffield","chromaticabberation","ca","ol","outliness"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr, in float ow){ \n    // geometric solution for analytic ray-sphere intersection\n    vec3 e0 = sp - ro; //vector from ray origin to center of sphere\n    float e1 = dot(e0,rd); //distance from origin of ray to closest point on ray to center of sphere\n    float cr2 = dot(e0,e0) - e1*e1; //square of radius of closest point on ray to center of sphere\n    float cr = sqrt(cr2); //radius of closest point on ray to center of sphere\n    float or = (sr+ow); //outline radius\n    float or2 = or*or; //square of outline radius\n    if (cr2 >= or2) return vec3(9999.9,1.0,1.0/((cr-sr))); //miss set to 9999.9 distance\n    float sr2 = sr*sr; //square of sphere radius\n    float e2 = sqrt(sr2 - cr2); //distance from closest point of ray to center of sphere to edge of sphere.\n    float st = e1-e2; //shortest distance from ray origin to intersection of ray and sphere\n    float ot = e1; //distance from origin of ray to closest point on ray to center of sphere\n    if (cr2 < sr2) return vec3(st,0.0,1.0/((cr-sr))); //distance to surface of sphere\n    if (cr2 < or2) return vec3(ot,0.1,1.0/((cr-sr))); //distance to flat ring around sphere\n    \n}\n\nvec3 amins(in vec3 s1, in vec3 s2){ //returns vec3 with smallest first element.\n    return (s1.x<s2.x)?vec3(s1.x, s1.y, s1.z+s2.z):vec3(s2.x, s2.y, s1.z+s2.z);\n}\n\nvec3 ascene(in vec3 ro, in vec3 rd, in float ow){\n    vec3 t = amins(asphere(ro,rd,vec3(0.0,0.0,0.0), 1.5, ow),\n               amins(asphere(ro,rd,vec3(-2,0.0,0.0),1.0, ow), \n                   amins(asphere(ro,rd,vec3(0.0,-2,0.0),1.0, ow),\n                       amins(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0, ow),\n                           amins(asphere(ro,rd,vec3(0.0,0.0,-2),1.0, ow),\n                              asphere(ro,rd,vec3(3.,3.,3.),0.2, ow)\n                           )\n                       )\n                   )\n               )\n           ); //length along ray to intersection\n    vec3 col = vec3(sqrt(t.z)/3.0);\n    if (t.y==0.0) { //if surface is hit calculate color based on surface position\n        vec3 loc = t.x*rd+ro; //ray information to location\n        loc = loc*0.5; //abirtrate scene color scale\n        col =  vec3(clamp(loc.x,0.0,1.0),clamp(loc.y,0.0,1.0),clamp(loc.z,0.0,1.0));\n    }\n    if (t.y==0.1){ //if outline is hit set color to black\n            col = vec3(0.0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //THIS v\n    const int lensRes = 8; //THIS <\n    const int ssaa = 2; //THIS <\n    float lensDis = 0.5; //THIS <\n    float lensSiz = 0.5; //THIS <\n    float focalDis = 11.0; //THIS <\n    float aberration = 0.1; //THIS <\n    float outlineWidth = 0.1; //THIS <\n    //THIS ^\n    //fragcoord is the center of the pixel\n\tvec2 sensorLoc = \n        vec2(0.5, 0.5*(iResolution.y/iResolution.x))//sets x limits from 0-1, y at same scale, center at (0.5,0.?)\n        - fragCoord.xy / iResolution.x; //reverse sensor and center on (0,0)\n    \n    vec3 trueY = vec3(0.0,1.0,0.0); //useful later could be hardcoded later instead\n    float tau = 0.5*iTime - 5.0*iMouse.x/iResolution.x; //tau used to determine camera position\n    \n    vec3 cameraPos = 10.0*vec3(1.0*sin(2.0*tau),1.0*cos(1.5*tau),1.0*cos(2.0*tau)); //this is not normalized\n    vec3 cameraDir = normalize(-cameraPos); //normalized ray from sensor center to 0,0,0\n    vec3 cameraX = normalize(cross(cameraDir,trueY)); //right dir for camera\n    vec3 cameraY = normalize(cross(cameraX,cameraDir)); //up dir for camera\n\t\n    vec3 colorTotal = vec3(0.0);//for each pixel reset the accumulated color\n    float colorCount = 0.0; //keep track of how many color samples are in final sum\n    float lensResF = float(lensRes); //for comparing to float later\n    float focal = 1.0+lensDis/focalDis; //brings the image to focus at focalDis from the cameraPos\n    float ssaaF = float(ssaa); //for using later to save a cast.\n    float sscale = 1.0/(iResolution.x); //size of a pixel\n    float sstep = 1.0/ssaaF; //step for SSAA\n    float sstart = sstep/2.0-0.5; //location of first SSAA step\n    float lstep = 1.0/lensResF; //step for lens\n    float lstart = lstep/2.0-0.5; //location of first lens step\n    \n    //Red Channel\n    float rFocalDis = focalDis*(1.0+aberration);\n    float rFocal = 1.0+lensDis/rFocalDis;\n    \n   \n    //Green Channel \n    float gFocalDis = focalDis;\n    float gFocal = 1.0+lensDis/gFocalDis;\n    \n    \n    //Blue Channel\n    float bFocalDis = focalDis*(1.0-aberration);\n    float bFocal = 1.0+lensDis/bFocalDis;\n    \n    for (float sx = sstart; sx < 0.5; sx += sstep){ //SSAA x direction\n    \tfor (float sy = sstart; sy < 0.5; sy += sstep){ //SSAA y direction\n            \n        \tvec2 ss = vec2(sx,sy)*sscale; //sub pixel offset for SSAA\n            vec3 sensorRel = cameraX*(sensorLoc.x+ss.x) + cameraY*(sensorLoc.y+ss.y); //position on sensor relative to center of sensor. Used once\n            vec3 sensorPos = cameraPos - lensDis*cameraDir + sensorRel; //3d position of ray1 origin on sensor\n            \t\n            for (float lx = lstart; lx < 0.5; lx+=lstep){\n        \t\tfor (float ly = lstart; ly < 0.5; ly+=lstep){\n                    \n            \t\tvec2 lensCoord = vec2(lx,ly); //fragCoord analog for lens array. lens is square\n        \t\t\tvec2 lensLoc = (lensCoord)*lensSiz; //location on 2d lens plane\n            \t\t\n                    if (length(lensLoc)<(lensSiz/2.0)){ //trim lens to circle\n                        \n                \t\tvec3 lensRel = cameraX*(lensLoc.x) + cameraY*(lensLoc.y); //position on lens relative to lens center. Used twice\n            \t\t\tvec3 lensPos = cameraPos + lensRel; // 3d position of ray1 end and ray2 origin on lens\n            \t\t\tvec3 senlenRay = lensPos - sensorPos; //direction of ray from sensor to lens\n                        \n                        //Red channel\n            \t\t\tvec3 rRay = senlenRay - rFocal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\trRay = normalize(rRay); //normalize after focus \n            \t\t\tvec3 red = ascene(lensPos,rRay,outlineWidth); //scene returns red\n                        \n                        //Green channel\n            \t\t\tvec3 gRay = senlenRay - gFocal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\tgRay = normalize(gRay); //normalize after focus \n            \t\t\tvec3 green = ascene(lensPos,gRay,outlineWidth); //scene returns green\n                       \n                        //Blue channel\n            \t\t\tvec3 bRay = senlenRay - bFocal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\tbRay = normalize(bRay); //normalize after focus \n            \t\t\tvec3 blue = ascene(lensPos,bRay,outlineWidth); //scene returns blue\n                        \n            \t\t\tcolorTotal = colorTotal+vec3(red.x, green.y, blue.z); //sum color over all points from lens\n                        colorCount += 1.0; //total number of colors added.\n                    }\n                }\n            }\n        }\n    }\n    fragColor = vec4(colorTotal/colorCount,0.0);\n}","name":"Image","description":"","type":"image"}]}