{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/* Created by Nikita Miropolskiy, nikat/2013\n * Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.\n * http://creativecommons.org/licenses/by-nc-nd/3.0/\n */\n\n//#define PROCEDURAL_NOISE\n\nvec2 rotate2(vec2 p, float theta) {\n\treturn vec2(\n\t\tp.x*cos(theta)-p.y*sin(theta),\n\t\tp.x*sin(theta)+p.y*cos(theta)\n\t);\n}\n\n\n/* discontinuous random vec2 */\nvec2 random2(vec2 c) {\n\tfloat j = 4906.0*sin(dot(c,vec2(169.7, 5.8)));\n\tvec2 r;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n#ifdef PROCEDURAL_NOISE\n\n/* skew constants for 2d simplex functions */\nconst float F2 =  0.3660254;\nconst float G2 = -0.2113249;\n\n/* 2d simplex (tetrahedron) derivative noise*/\nfloat simplex2d(vec2 p) {\n\t vec2 s = floor(p + (p.x+p.y)*F2);\n\t vec2 x = p - s - (s.x+s.y)*G2;\n\t \n     float e = step(0.0, x.x-x.y);\n\t vec2 i1 = vec2(e, 1.0-e);\n\t \t \n\t vec2 x1 = x - i1 - G2;\n\t vec2 x2 = x - 1.0 - 2.0*G2;\n\t \n\t vec3 w, d;\n\t \t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t \t \n\t w = max(0.5 - w, 0.0);\n\t \n\t d.x = dot(random2(s + 0.0), x);\n\t d.y = dot(random2(s +  i1), x1);\n\t d.z = dot(random2(s + 1.0), x2);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \t \n\t return 0.5+dot(d, vec3(70.0));\n}\n\n#else\n\nfloat simplex2d(vec2 p) {\n\treturn texture(iChannel0, p*0.015).x;\n}\n\n#endif\n\n\n/* random star parameters */\nvec4 randomStar(vec2 c) {\n    vec4 r;\n\tr.xy = random2(c);\n\tr.zw = random2(c+0.5)+0.5;\n\treturn r;\n}\n\n/* star density */\nfloat star_density(vec2 p) {\n\tp *= vec2(0.40, 0.20);\n\tp += simplex2d(p);\n\treturn simplex2d(p)-0.2;\n}\n\n/* draw star in tile s fragment x */\nfloat stars2d_tile(vec2 s, vec2 x, float scale, float theta) {\n\tfloat density = star_density(s*3.5/scale);\t\n\tvec4 star = randomStar(s);\n\t\n    if (star.w*1.2 > density) {\n\t\treturn 0.0;\n\t}\n\n\tfloat starMagnitude = 0.7 + star.z*2.0;\n\tfloat starBrightness = 4.0 - star.z*4.0;\n\tvec2 v = starMagnitude*rotate2(x - star.xy, -theta);\n\n\t/* bright star with beams */\n\tif (scale <= 8.0) {\n\t\tv*=2.0;\n\t\treturn 4.0*max(0.0, 0.5-smoothstep(0.0, 1.6, pow(dot(v,v), 0.125))) \t\t\t      \n\t\t\t     + max(0.0, 0.5-smoothstep(0.0, 1.0, pow(dot(v,v), 0.25)))\n\t\t\t     + max(0.0, 0.6-dot(abs(v), vec2(16.0, 1.0)))  // beam\n\t\t\t     + max(0.0, 0.6-dot(abs(v), vec2(1.0, 16.0))); // beam\n\t}\n\t\n\t/* cheap trick against aliasing */\n\tfloat pixels = min(1.0, 24.0/(scale*starMagnitude));\n\tv *= max(0.6, pixels);\n\tstarBrightness *= pixels*pixels;\n\t\n\tfloat d = pow(dot(v,v), 0.25);\n\treturn starBrightness*max(0.0, 0.5-smoothstep(0.0, 1.0, d));\n}\n\n\n/* 2d rectangle stars function with density */\nfloat stars2d(vec2 p, float scale, float theta) {\n\tp*=scale;\n\tvec2 s = floor(p);\n\tvec2 x = p - s;\n\t\n\treturn 0.0\n\t\t+stars2d_tile(s + vec2(0.0, 0.0), x - vec2(0.0, 0.0), scale, theta)\n\t\t+stars2d_tile(s + vec2(1.0, 0.0), x - vec2(1.0, 0.0), scale, theta)\n\t\t+stars2d_tile(s + vec2(0.0, 1.0), x - vec2(0.0, 1.0), scale, theta)\n\t\t+stars2d_tile(s + vec2(1.0, 1.0), x - vec2(1.0, 1.0), scale, theta)\n\t;\n}\n\nfloat sky(vec2 p, float theta) {\n\tp = rotate2(p, theta);\n\treturn 0.0\n\t\t+ stars2d(p, 2.0, theta) \n\t\t//+ stars2d(p, 4.0, theta) \n\t\t//+ stars2d(p, 8.0, theta) \n\t\t//+ stars2d(p, 16.0, theta)\n\t\t+ stars2d(p, 32.0, theta)\n\t\t+ stars2d(p, 64.0, theta)\n\t\t+ stars2d(p, 128.0, theta)\n\t\t+ 0.2*star_density(p*3.5)\n\t\t+ 0.15*simplex2d(p*128.0)\n        ;\n}\n\nvec3 palette(float v) {\n\tvec3 c;\n\n\tc.b = v;\n\tc.g = smoothstep(0.0, 2.0, 2.0*c.b);\n\tc.r = smoothstep(0.0, 4.0, 4.0*c.g);\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy + 300.0)/(400.0); //fixed pixels\n\t\n    float theta = iTime*0.01;\n\t\n\tfragColor = vec4(palette(sky(p, theta)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfGRB","date":"1373393957","viewed":3071,"name":"Night sky","username":"nikat","description":"Night sky with round shaped stars, beams, fractal star distribution, modulated star density, simple color palette.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","fractal","noise","perlin","sky","stars"],"hasliked":0,"parentid":"","parentname":""}}