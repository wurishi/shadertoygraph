{"ver":"0.1","info":{"id":"lXlfRj","date":"1728651927","viewed":85,"name":"frameskip","username":"vivavolt","description":"second surface detection colored by orbit trapping","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","3dfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Apollonian_Sliced\" by kosalos. https://shadertoy.com/view/M3sBWN\n// 2024-10-11 13:05:06\n\n#define PI 3.14159\n#define R iResolution\n#define SS(a,b,c) smoothstep((a)-(b),(a)+(b),c)\n\nfloat foam,foam2,mult;\nvec3 camera = vec3(-4.983,-7.1239,-8.9165);\nvec3 aim = vec3(-0.0237,-0.1558,0.9874);\nfloat sdistance = 0.571;\nfloat sangle = -0.3199;\nfloat srefamt = 0.59;\nfloat smix = 1.;\nfloat ostrength = 0.69;\nfloat ocycle = 0.9;\nvec4 orbit2 = vec4(0.94,-2.08,0.9,2.41);\nvec4 orbit3 = vec4(0.6,-3.92,0.,0.);\nvec3 orbit4 = vec3(1.,-1.,3.);\n\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\n// Ghost effect parameters\nfloat ghostOpacity = 0.4;\nfloat ghostShimmer = 0.3;\nvec3 ghostTint = vec3(0.6, 0.9, 1.0); // Blue tint\nfloat ghostDistortion = 0.2;\nfloat ghostEctoplasmStrength = 0.5;\n\nfloat dotGrid(vec2 uv, float size) {\n    uv = mod(uv,2.)-1.;\n    float l = length(uv);\n    return SS(size,-0.01,l);\n}\n\nfloat DE(vec3 pos) {\n    float t = foam2 + 0.25 * cos(mult * (pos.z - pos.x));\n    float k,scale = 1.0;\n    orbitTrap = vec4(10000.0);\n\n    for(int s=0; s < 3; ++s) {\n        pos = -1.0 + 2.0 * fract(0.5 * pos + 0.5);\n        pos -= sign(pos) * foam;\n\n        k = t / dot(pos,pos);     \n        pos *= k;\n        scale *= k;\n\n        vec3 ot = pos - orbit4;\n        orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n\n    float d1 = sqrt(min(min(dot(pos.xy,pos.xy), dot(pos.yz,pos.yz)), dot(pos.zx,pos.zx))) - 0.02;\n    return 0.5 * min(d1,abs(pos.y)) / scale;\n}\n\nvoid calcNormal() {\n    float d0 = DE(position);\n    const vec2 epsilon = vec2(.0001,0);\n    vec3 d1 = vec3(\n        DE(position-epsilon.xyy),\n        DE(position-epsilon.yxy),\n        DE(position-epsilon.yyx));\n    normal = normalize(d0 - d1);\n}\n\nvoid setDirection(vec2 U) {\n    vec3 viewVector = normalize(aim);\n    vec3 sideVector = normalize(cross(vec3(0.,1.,0.),viewVector));\n    vec3 topVector = cross(viewVector,sideVector);\n    \n    vec2 vPos = (U - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\nvec3 generateColor(float weight,float x) {\n    if(weight == 0.0) return vec3(0.0);\n    x = cos(x);\n    return vec3((1.0-x)*(1.0-x), x*x, 2.0*(1.0-x)*x);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3(cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    if (ocycle > 0.0) {\n        return orbitTrapCycle(ocycle,generateColor(orbit2.x,orbit2.y), orbitTrap.x) * orbit2.x * orbitTrap.x +\n               orbitTrapCycle(ocycle,generateColor(orbit2.z,orbit2.w), orbitTrap.y) * orbit2.z * orbitTrap.y +\n               orbitTrapCycle(ocycle,generateColor(orbit3.x,orbit3.y), orbitTrap.z) * orbit3.x * orbitTrap.z +\n               orbitTrapCycle(ocycle,generateColor(orbit3.z,orbit3.w), orbitTrap.w) * orbit3.z * orbitTrap.w;\n    } else {\n        return generateColor(orbit2.x,orbit2.y) * orbit2.x * orbitTrap.x +\n               generateColor(orbit2.z,orbit2.w) * orbit2.z * orbitTrap.y +\n               generateColor(orbit3.x,orbit3.y) * orbit3.x * orbitTrap.z +\n               generateColor(orbit3.z,orbit3.w) * orbit3.z * orbitTrap.w;\n    }\n}\n\nvoid ambient() { \n    const float amb = 0.014;\n    const float dim = 1.;\n    const float contrast = 1.44;\n    color = vec3(amb) + vec3(10.1 - float(iter) * dim);\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast; \n        \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }\n\n    color = vec3(0.5) + (color - vec3(0.5)) * .344;\n    \n    // Apply ghost tint and shimmer effect\n    color = mix(color, ghostTint, 0.6);\n    color += vec3(ghostShimmer * sin(iTime * 5.0 + position.x * 20.0 + position.y * 15.0 + position.z * 12.0));\n\n    // Add ectoplasmic glow\n    float ectoplasmGlow = ghostEctoplasmStrength * (0.5 + 0.5 * sin(iTime * 3.0 + length(position) * 2.0));\n    color += ghostTint * ectoplasmGlow;\n}\n\nvec3 refractDirection(vec3 incidentVec, vec3 normal, float eta) {\n  float N_dot_I = dot(normal, incidentVec);\n  float k = 1.0 - eta * eta * (1.0 - N_dot_I * N_dot_I);\n  return (k < 0.0) ? vec3(0.0) : normalize(eta * incidentVec - (eta * N_dot_I + sqrt(k)) * normal);\n}\n\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 20.0;\n\nvoid rayMarch() {\n    position = camera;\n    iter = 0;\n    depth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n    \n    for(int i = 0;i < 64;++i) {\n        float distance = DE(position);\n        if(abs(distance) < MIN_DIST || depth > MAX_DIST) break;\n        iter += 1;\n        \n        depth += distance;\n        position += direction * distance;\n\n        // Add ghostly distortion to the ray marching\n        position += ghostDistortion * vec3(\n            sin(position.x * 5.0 + iTime),\n            cos(position.y * 4.0 + iTime * 1.2),\n            sin(position.z * 3.0 + iTime * 0.8)\n        );\n    }\n}\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * 10. * speed) * 0.5)\n    \nvoid mainImage(out vec4 O, vec2 XY) {\n    float factor = R.x/1024.; // designed for 1024*576\n\n    animate(foam,0.03,0.06, 0.02);\n    animate(foam2,1.0,1.7,  0.025);\n    animate(mult,1.7,2.1,   0.3);\n\n    animate(camera.x,-6.5,-5.5,   0.035);\n    animate(camera.y,-7.7,-7.,   0.04);\n    animate(camera.z,-7.7,-7.,   0.045);\n    animate(aim.x,-3.,3.,   0.035);\n    animate(aim.y,-3.,3.,   0.04);\n    animate(aim.z,-3.,3.,   0.045);\n\n    animate(sdistance,0.001,6., 0.1);\n    animate(sangle,0.01,4.,    0.015);\n    animate(srefamt,0.01,4.,   0.02);\n\n    animate(ostrength,0.,1.,0.1);\n    animate(ocycle,0.,1.,0.18);\n    animate(orbit2.x,-3.,3.,0.011);\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-3.,3.,0.015);\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-3.,3.,0.019);\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.23);\n    animate(orbit4.y,-3.,3.,0.25);\n    animate(orbit4.z,-3.,3.,0.27);\n\n    // Animate ghost parameters\n    animate(ghostOpacity, 0.2, 0.6, 0.7);\n    animate(ghostShimmer, 0.2, 0.4, 0.9);\n    animate(ghostDistortion, 0.1, 0.3, 0.5);\n    animate(ghostEctoplasmStrength, 0.3, 0.7, 0.6);\n\n    setDirection(XY);\n    rayMarch();\n    \n    if(depth > MAX_DIST) {\n        O = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    calcNormal();\n    ambient();\n\n    // second surface\n    direction = refractDirection(direction, normal * sangle, srefamt);\n    camera = position + sdistance * direction;\n    rayMarch();\n\n    if(depth < MAX_DIST) { \n        vec3 previousColor = color;\n        position = camera + direction * depth;\n        calcNormal();\n        ambient();\n        color = mix(previousColor, color, smix); \n    }\n\n    // Add ghostly edge glow\n    float edgeGlow = pow(1.0 - abs(dot(normal, direction)), 4.0);\n    color += ghostTint * edgeGlow * 2.0;\n\n    // Apply dot effect\n    vec2 uvc = (XY-R.xy/2.)/R.y;\n\n    // Use the color intensity to modulate dot size\n    float colorIntensity = length(color) / length(vec3(1,1,1));\n    \n    // Create dots using the ghostly color\n    vec3 dotColor = vec3(\n        dotGrid(uvc*80.*factor, colorIntensity*.8),\n        dotGrid(uvc*160.*factor, colorIntensity*.8),\n        dotGrid(uvc*40.*factor, colorIntensity*.9)\n    );\n\n    // Use the dot pattern to render the ghostly scene\n    O.xyz = color * dotColor;\n    \n    // Apply ghostly transparency and pulsating effect\n    float pulseEffect = 0.5 + 0.5 * sin(iTime * 3.0 + length(position) * 0.5);\n    O.a = ghostOpacity * (0.8 + 0.2 * pulseEffect);\n}","name":"Image","description":"","type":"image"}]}