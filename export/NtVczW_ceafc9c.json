{"ver":"0.1","info":{"id":"NtVczW","date":"1661814778","viewed":264,"name":"Avalanche test (u32-to-u32 hash)","username":"chemaguerra","description":"Shadertoy implementation of the \"Avalanche test for a hash function\". This code is meant to allow you to type in any 32-bit->32-bit hash function of your own and estimate how much it achieves Avalanche.\nRef: https://en.wikipedia.org/wiki/Avalanche_effect","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["test","hash","avalanche"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2022 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n//-------------------------------------------------------//\n// Instructions:                                         //\n//-------------------------------------------------------//\n// - Go to the \"Common\" tab.                             //\n// - Simply uncomment the #define hash you wish to test. //\n// - Or provide your own!                                //\n//-------------------------------------------------------//\n\n// - This Shadertoy is complemented by a little entry in my blog:\n// - https://www.brashandplucky.com/2022/08/29/the-avalanche-effect.html\n\n#define COMPUTE_BIAS       0     // 0: Avalanche, 1: Bias.\n\n#define REVEAL_CHANNEL    -1     // -1: Image, 0: Buffer A, 1: Buffer B.\n\n#define BIAS_MAGNIFICATION 100.  // Higher values make errors more evident.\n\n#if COMPUTE_BIAS\n#define to_output( x ) (   abs( (x) - .5 ) * BIAS_MAGNIFICATION )  // Bias (black).\n#else\n#define to_output( x ) ( .5 + ( (x) - .5 ) * BIAS_MAGNIFICATION )  // Avalanche (gray).\n#endif\n\nfloat sample_char_5x5_float_sat( const float f, const vec2 uv )\n{\n  int i = int( clamp( f, 0., 1. ) * 1000000. );\n\n#if COMPUTE_BIAS\n  return ( sample_char_5x5(  98 /* b */, ( uv - vec2( 0, 0 ) ) ) +\n           sample_char_5x5( 105 /* i */, ( uv - vec2( 1, 0 ) ) ) +\n           sample_char_5x5(  97 /* a */, ( uv - vec2( 2, 0 ) ) ) +\n           sample_char_5x5( 115 /* s */, ( uv - vec2( 3, 0 ) ) ) +\n#else\n  return ( sample_char_5x5(  97 /* a */, ( uv - vec2( 0, 0 ) ) ) +\n           sample_char_5x5( 118 /* v */, ( uv - vec2( 1, 0 ) ) ) +\n           sample_char_5x5(  97 /* a */, ( uv - vec2( 2, 0 ) ) ) +\n           sample_char_5x5( 108 /* x */, ( uv - vec2( 3, 0 ) ) ) +\n#endif\n           sample_char_5x5(  61 /* = */, ( uv - vec2( 4, 0 ) ) ) +\n           sample_char_5x5(  46 /* . */, ( uv - vec2( 6, 0 ) ) ) +\n\n           sample_char_5x5( ( 48 + ( ( i / 1000000 ) % 10 ) ), ( uv - vec2(  5, 0 ) ) ) +\n           sample_char_5x5( ( 48 + ( ( i /  100000 ) % 10 ) ), ( uv - vec2(  7, 0 ) ) ) +\n           sample_char_5x5( ( 48 + ( ( i /   10000 ) % 10 ) ), ( uv - vec2(  8, 0 ) ) ) +\n           sample_char_5x5( ( 48 + ( ( i /    1000 ) % 10 ) ), ( uv - vec2(  9, 0 ) ) ) +\n           sample_char_5x5( ( 48 + ( ( i /     100 ) % 10 ) ), ( uv - vec2( 10, 0 ) ) ) +\n           sample_char_5x5( ( 48 + ( ( i /      10 ) % 10 ) ), ( uv - vec2( 11, 0 ) ) ) +\n           sample_char_5x5( ( 48 + ( ( i /       1 ) % 10 ) ), ( uv - vec2( 12, 0 ) ) ) );\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n#if ( REVEAL_CHANNEL == 0 )\n  o.rgb = ( texture( iChannel0, ( uv /   iResolution.xy         ) ).rgb / float( iFrame ) );\n#elif ( REVEAL_CHANNEL == 1 )\n  o.rgb =   texture( iChannel1, ( uv / ( iResolution.xy * 32. ) ) ).rgb;\n#else\n  float m   = min( iResolution.x, iResolution.y );\n\n  vec2  UV  = ( ( uv * 32. ) / m );\n\n  float mag = texture( iChannel1, ( UV / iChannelResolution[ 1 ].xy ) ).r;\n\n  float sum = 0.;  // This sum goes to waste for pixels falling outside the text.\n\n  for ( uint i = 0u; ( i < 32u ); ++i )\n  for ( uint j = 0u; ( j < 32u ); ++j )\n  {\n    sum += texture( iChannel1, ( vec2( i, j ) / iChannelResolution[ 1 ].xy ) ).r;\n  }\n\n    sum /= ( 32. * 32. );\n\n  o.rgb = vec3( to_output( mag ) );\n    sum =     ( to_output( sum ) );\n\n  vec2  text_scale = vec2( m * .05 );  // 5% of the shortest side of the display.\n\n  float f = sample_char_5x5_float_sat( sum, ( uv / text_scale ) );\n\n  o.rgb = ( ( f < 1. ) ? o.rgb : vec3( f, f, 0. ) );\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// The MIT License\n//\n// Copyright (c) 2022 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n// These hash functions are very low-bias.\n\n#define hash( x ) murmur3_finalize( x )\n//#define hash( x ) skeeto          ( x )\n//#define hash( x ) xxhash32        ( x )\n\n// These hash functions are not.\n\n//#define hash( x ) lcg             ( x )\n//#define hash( x ) pcg             ( x )\n//#define hash( x ) iqint1          ( x )\n//#define hash( x ) esgtsa          ( x )\n//#define hash( x ) K               ( x )\n//#define hash( x ) superfast       ( x )\n//#define hash( x ) wang            ( x )\n//#define hash( x ) half_avalanche  ( x )\n\n//----------//\n// Murmur3. //\n//----------//\n\n// - https://en.wikipedia.org/wiki/MurmurHash\n// - Well-known low-bias 32-bit hash.\n  \nuint murmur3_finalize( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\n//---------------//\n// Other hashes. // -- low-bias.\n//---------------//\n\n// - https://github.com/skeeto/hash-prospector\n// - As high-quality as Murmur3.\n\nuint skeeto( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x7FEB352Du;\n  u ^= ( u >> 15 ); u *= 0x846CA68Bu;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\nuint xxhash32( const uint p )\n{\n  const uint PRIME32_2 = 2246822519u, PRIME32_3 = 3266489917u;\n  const uint PRIME32_4 =  668265263u, PRIME32_5 =  374761393u;\n\n  uint h32 = ( p + PRIME32_5 );\n\n  h32 = ( PRIME32_4 * ( ( h32 << 17 ) | ( h32 >> ( 32 - 17 ) ) ) );\n\n  h32 = ( PRIME32_2 * ( h32 ^ ( h32 >> 15 ) ) );\n  h32 = ( PRIME32_3 * ( h32 ^ ( h32 >> 13 ) ) );\n\n  return ( h32 ^ ( h32 >> 16 ) );\n}\n\n//---------------//\n// Other hashes. // -- high-bias.\n//---------------//\n\n// - These are taken from Mark Jarzynski's:\n//   https://www.shadertoy.com/view/XlGcRh\n//   http://www.jcgt.org/published/0009/03/02/\n\nuint lcg( const uint u )\n{\n  return ( ( u * 1664525u ) + 1013904223u );\n}\n\n// https://www.pcg-random.org/\n\nuint pcg( const uint u )\n{\n  uint state = ( ( u * 747796405u ) + 2891336453u );\n\n  uint word  = ( ( ( state >> ( ( state >> 28u ) + 4u ) ) ^ state ) * 277803737u );\n\n  return ( ( word >> 22u ) ^ word );\n}\n\n// - Inigo Quilez, Integer Hash - I, 2017\n// - https://www.shadertoy.com/view/llGSzw\n\nuint iqint1( in uint u )\n{\n  u = ( ( u << 13u ) ^ u );\n\n  u = ( ( u * ( ( u * u * 15731u ) + 789221u ) ) + 1376312589u );\n\n  return u;\n}\n\n// - Schechter and Bridson hash.\n// - https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\n\nuint esgtsa( in uint u )\n{\n  u = ( ( u ^  2747636419u ) * 2654435769u );\n\n  u = ( ( u ^ ( u >> 16u ) ) * 2654435769u );\n  u = ( ( u ^ ( u >> 16u ) ) * 2654435769u );\n\n  return u;\n}\n\nuint K( const uint u )\n{\n  return uint( abs( sin( float( u ) + 1. ) ) * float( 0xFFFFFFFFu ) );\n}\n\n// - SuperFastHash.\n// - http://www.azillionmonkeys.com/qed/hash.html\n\nuint superfast( const uint u )\n{\n  uint hash = 4u, tmp;\n\n  hash += ( u & 0xFFFFu );\n\n  tmp   = ( ( ( ( u >> 16 ) & 0xFFFFu ) << 11 ) ^ hash );\n\n  hash  = ( ( hash << 16 ) ^ tmp );\n\n  hash +=   ( hash >> 11 );\n  hash ^=   ( hash <<  3 );\n  hash +=   ( hash >>  5 );\n  hash ^=   ( hash <<  4 );\n  hash +=   ( hash >> 17 );\n  hash ^=   ( hash << 25 );\n  hash +=   ( hash >>  6 );\n\n  return hash;\n}\n\n// - Wang hash described on: http://burtleburtle.net/bob/hash/integer.html\n// - Original page by Thomas Wang 404.\n\nuint wang( in uint u )\n{\n  u = ( ( u ^ 61u ) ^ ( u >> 16u ) );\n\n  u *= 0x00000009u; u ^= ( u >>  4u );\n  u *= 0x27D4EB2Du; u ^= ( u >> 15u );\n\n  return u;\n}\n\nuint half_avalanche( in uint u )\n{\n  u = ( ( u + 0x479AB41Du ) + ( u <<  8u ) );\n  u = ( ( u ^ 0xE4AA10CEu ) ^ ( u >>  5u ) );\n  u = ( ( u + 0x9942F0A6u ) - ( u << 14u ) );\n  u = ( ( u ^ 0x5AEDD67Du ) ^ ( u >>  3u ) );\n  u = ( ( u + 0x17BEA992u ) + ( u <<  7u ) );\n\n  return u;\n}\n\n//------------//\n// Tiny text. //\n//------------//\n\nfloat sample_char_5x5( const in int c, const in vec2 uv )\n{\n  if ( ( uv.x < 0. ) || ( uv.x >= 1. ) ||\n       ( uv.y < 0. ) || ( uv.y >= 1. ) )\n  {\n    return 0.;\n  }\n\n  uint u = 0u;\n\n  switch ( c )\n  {\n    case  46: /* . */ u = 0x00000020u; break;\n    case  48: /* 0 */ u = 0x4064A4C0u; break;\n    case  49: /* 1 */ u = 0x804311C0u; break;\n    case  50: /* 2 */ u = 0x807609E0u; break;\n    case  51: /* 3 */ u = 0xC07620E0u; break;\n    case  52: /* 4 */ u = 0xC0A4BD00u; break;\n    case  53: /* 5 */ u = 0x00F1B0E0u; break;\n    case  54: /* 6 */ u = 0xC0E3A4C0u; break;\n    case  55: /* 7 */ u = 0x80F41040u; break;\n    case  56: /* 8 */ u = 0x8067A4C0u; break;\n    case  57: /* 9 */ u = 0x8064B8E0u; break;\n    case  61: /* = */ u = 0x000781E0u; break;\n    case  97: /* a */ u = 0x000725C0u; break;\n    case  98: /* b */ u = 0x8013A4E0u; break;\n    case 105: /* i */ u = 0x402008E0u; break;\n    case 108: /* l */ u = 0x403108E0u; break;\n    case 115: /* s */ u = 0x40061060u; break;\n    case 118: /* v */ u = 0x8004A880u; break;\n  };\n\n  uvec2 px = uvec2( floor( uv * vec2( 5, 5 ) ) );\n\n  return float( ( u >> ( px.x + ( px.y * 5u ) ) ) & 0x01u );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2022 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n// - We expect this channel to be nearest/clamp and at least 32x32.\n// - Here we update as many 32x32 partial counter tiles as we can.\n// - Each 32x32 tile analizes the hash on its own u, where u is a\n//   pseudo-random number:\n//\n//   c-th col: u'=u where the c-th bit is flipped.\n//   r-th row: hash(u')^hash(u); i.e., when the c-th bit is flipped\n//             in the input, see if the r-th bit got flipped\n//             in the output.\n//\n// - The output of a \"good\" hashing function should disperse evenly\n//   changes in the input.\n// - In a good hashing function each tile should converge to 50% =>\n//   Each flipped bit affects with a 50/50 chance any output bit.\n//\n// - We work in 32x32 tiles here so each tile can operate on its own\n//   randomly-chosen u and operate on its own 32x32 texels without\n//   parallel-computing conflicts.\n//\n// - Ideally we would want to test each possible u (2^32) just once.\n// - However, this would take \"forever\" so we are choosing uniformly\n//   randomized values for u and it is enough to let the shadertoy\n//   run for a few seconds to have a good-enough estimation of what\n//   the avalanche test will converge to.\n//\n// - Ref: https://en.wikipedia.org/wiki/Avalanche_effect\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  uvec2 ij = uvec2( uv );\n\n  // We're at the (I,J)-th 32x32 texel tile.\n\n  uvec2 IJ = ( ij >> 5 );\n\n  // # complete 32x32 tiles.\n\n  uvec2 n  = ( uvec2( iChannelResolution[ 0 ] ) >> 5 );\n\n  if ( iFrame == 0 )\n  {\n    // Clear this channel on frame #0.\n\n    o.rgb = vec3( 0 );\n  }\n  else if ( ( ij.x < ( n.x << 5 ) ) &&\n            ( ij.y < ( n.y << 5 ) ) )\n  {\n    // - Given \"enough time\" u would fully cover [0..2^32[.\n    // - Since it would take an unreasonable amount of time\n    //   to cover the full 32-bit range, u is hashed into x\n    //   using a high-quality hash (MurMur3).\n    // - This guarantees (kind of) that x values will be\n    //   scattered progressively in the 32-bit range.\n\n    uint u  = ( ( uint( iFrame ) * n.x * n.y ) + ( IJ.y * n.x ) + IJ.x );\n\n    uint x  = murmur3_finalize( u );  // Any high-quality hash will do.\n\n    uint h0 = hash( x );\n\n    // Flip the bits in x, one by one.\n\n    uint i = ( 31u - ( ij.x & 31u ) );\n    {\n      uint bit = ( 1u << i );\n\n      uint h1  = hash( x ^ bit );\n\n      uint set = ( h0 ^ h1 );\n\n      // Rehash + See which of the rehashed bits were affected.\n\n      uint j = ( ij.y & 31u );\n      {\n        // - No other threads will write in this texel,\n        //   so this RD/WR operation is thread-safe.\n        // - Important: Buffer A/B must be nearest/clamp,\n        //   because we are using them as arrays to store\n        //   temp data.\n\n        uv /= iChannelResolution[ 0 ].xy;\n\n        o.rgb = ( texture( iChannel0, uv ).rgb + vec3( ( set >> j ) & 0x01u ) );\n      }\n    }\n  }\n  else\n  {\n    // Discard pixels for incomplete 32x32 tiles.\n\n    discard;\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// The MIT License\n//\n// Copyright (c) 2022 Chema Guerra\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n// - We expect this channel to be nearest/clamp and at least 32x32.\n// - Here all the 32x32 tiles (the partial counts) are safely\n//   averaged down to a single 32x32 tile.\n// - The bias/avalanche value printed out on screen is in turn\n//   the average of this averaged down tile.\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n  if ( ( uv.x < 32. ) &&\n       ( uv.y < 32. ) )\n  {\n    float sum = 0.;\n\n    uvec2 n   = ( uvec2( iChannelResolution[ 0 ] ) >> 5 );  // # complete 32x32 tiles.\n\n    for ( uint i = 0u; ( i < n.x ); ++i )\n    for ( uint j = 0u; ( j < n.y ); ++j )\n    {\n      vec2 UV = ( uv + vec2( ( i << 5 ), ( j << 5 ) ) );\n\n      sum += texture( iChannel0, ( UV / iChannelResolution[ 0 ].xy ) ).r;\n    }\n\n    o.rgb = vec3( sum / float( uint( iFrame ) * n.x * n.y ) );\n  }\n  else\n  {\n    // Discard pixels outside the averaged down 32x32 tile.\n\n    discard;\n  }\n}","name":"Buffer B","description":"","type":"buffer"}]}