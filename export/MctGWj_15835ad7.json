{"ver":"0.1","info":{"id":"MctGWj","date":"1714148167","viewed":2982,"name":"Interstellar video - Black hole","username":"aroussel","description":"Interstellar ScienceClic video - Black hole","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["blackhole","interstellar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\n///////////////////////////////////////////////////////////////////\n// The raytracing part of this shader is mainly inspired\n// by the approach from Mykhailo Moroz presented in this\n// blog article: https://michaelmoroz.github.io/TracingGeodesics/\n//\n// The idea is to integrate the ray's position by calculating\n// the gradient of the Hamiltonian and making use of Hamilton's\n// equations of motion in the context of general relativity\n//\n// We use G=c=M=1 and (-+++) metric signature\n///////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////\n// Settings\n//////////////////////////////\n\nfloat camR = 30.;     // camera distance\nfloat tilt = .1;      // camera tilt\nfloat zoom = 1.5;     // camera zoom\n\nfloat a = .6;         // spin parameter (J/MÂ²)\nfloat discMin = 3.83; // disc inner radius (ISCO)\nfloat discMax = 15.;  // disc outer radius\n\nfloat eps = .01;      // hamiltonian gradient step\nfloat dtau = .1;      // affine step\nint maxSteps = 500;   // maximum steps\n\n\n//////////////////////////////\n// Functions\n//////////////////////////////\n\n// diagonal matrix\nmat4 diag(vec4 vec){\n    return mat4(vec.x,0,0,0,\n                0,vec.y,0,0,\n                0,0,vec.z,0,\n                0,0,0,vec.w);\n}\n\n// r from coordinates\nfloat rFromCoords(vec4 pos){\n    vec3 p = pos.yzw;\n    float rho2 = dot(p,p)-a*a;\n    float r2 = .5*(rho2+sqrt(rho2*rho2+4.*a*a*p.z*p.z));\n    return sqrt(r2);\n}\n\n// Kerr metric in outgoing Kerr-Schild coordinates\nmat4 metric(vec4 pos){\n    float r = rFromCoords(pos);\n    vec4 k = vec4(-1.,(r*pos.y-a*pos.z)/(r*r+a*a),(r*pos.z+a*pos.y)/(r*r+a*a),pos.a/r);\n    float f = 2.*r/(r*r+a*a*pos.a*pos.a/r/r);\n    return f*mat4(k.x*k,k.y*k,k.z*k,k.w*k)+diag(vec4(-1,1,1,1));\n}\n\n// hamiltonian\nfloat hamiltonian(vec4 x, vec4 p){\n    return .5*dot(inverse(metric(x))*p,p);\n}\n\n// hamiltonian gradient\nvec4 hamiltonianGradient(vec4 x, vec4 p){\n    return (vec4(hamiltonian(x+vec4(eps,0,0,0),p),\n                 hamiltonian(x+vec4(0,eps,0,0),p),\n                 hamiltonian(x+vec4(0,0,eps,0),p),\n                 hamiltonian(x+vec4(0,0,0,eps),p))-hamiltonian(x,p))/eps;\n}\n\n// ray integration step\nvoid transportStep(inout vec4 x, inout vec4 p){\n    float r = rFromCoords(x);\n\tfloat stepsize = dtau;\n    p -= stepsize*hamiltonianGradient(x,p);\n    x += stepsize*inverse(metric(x))*p;\n}\n\n// stop condition\nbool stopCondition(vec4 pos){\n    float r = rFromCoords(pos);\n    return r < 1.+sqrt(1.-a*a) || r > max(2.*camR,30.);\n}\n\n// make vector unit\nvec4 unit(vec4 vec, mat4 g){\n    float norm2 = dot(g*vec,vec);\n    if(norm2 > 0.){\n        return vec/sqrt(abs(norm2));\n    }else{\n        return vec;\n    }\n}\n\n// make basis orthonormal\nmat4 tetrad(vec4 x, vec4 time, vec4 aim, vec4 vert){\n    mat4 g = metric(x);\n    vec4 E0 = unit(time, g);\n    vec4 E1 = unit(aim+dot(g*aim,E0)*E0, g);\n    vec4 E3 = unit(vert-dot(g*vert,E1)*E1+dot(g*vert,E0)*E0, g);\n    vec4 E2 = unit(inverse(g)*vec4(dot(E0.yzw,cross(E1.yzw,E3.yzw)),\n                                   -dot(E0.zwx,cross(E1.zwx,E3.zwx)),\n                                   dot(E0.wxy,cross(E1.wxy,E3.wxy)),\n                                   -dot(E0.xyz,cross(E1.xyz,E3.xyz))), g);\n    mat4 tetrad;\n    tetrad[0] = E0;\n    tetrad[1] = E1;\n    tetrad[2] = E2;\n    tetrad[3] = E3;\n    return tetrad;\n}\n\n\n//////////////////////////////\n// Ray tracing\n//////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n    \n    tilt = sin(iTime*.5)*.5;\n    \n    // camera coordinates\n    float x = sqrt(camR*camR+a*a)*cos(tilt);\n    float z = camR*sin(tilt);\n    vec4 camPos = vec4(0.,x,0.,z);\n    \n    // camera axes\n    vec4 time = vec4(1.,0.,0.,0.);\n    vec4 aim = vec4(0.,x,0.,z);\n    vec4 vert = vec4(0.,-x*z,0.,x*x)*sign(cos(tilt));\n    mat4 axes = tetrad(camPos, time, aim, vert);\n    \n    // ray projection\n    vec4 pos = camPos;\n    vec3 dir = normalize(vec3(-zoom,uv));\n    vec4 dir4D = -axes[0]+dir.x*axes[1]+dir.y*axes[2]+dir.z*axes[3];\n    \n    bool captured = false;\n    bool hitDisc = false;\n    vec4 intersectPos;\n    vec2 discUV;\n    float blueshift;\n    \n    // ray tracing    \n    vec4 p = metric(pos)*dir4D;\n    for(int i=0; i<maxSteps; i++){\n        vec4 lastpos = pos;\n        transportStep(pos, p);\n        if(pos.a*lastpos.a < 0.){\n        \n            // hit disc\n            intersectPos = (pos*abs(lastpos.a)+lastpos*abs(pos.a))/abs(lastpos.a-pos.a);\n            float r = rFromCoords(intersectPos);\n            if(r > discMin && r < discMax){\n                hitDisc = true;\n                discUV = (intersectPos.yz/discMax+1.)*.5;\n                vec4 discVel = vec4(r+a/sqrt(r),vec3(-intersectPos.z,intersectPos.y,0.)*sign(a)/sqrt(r))/sqrt(r*r-3.*r+2.*a*sqrt(r));\n                blueshift = 1./dot(p,discVel);\n                break;\n            }\n        }\n        \n        // end tracing\n        if(stopCondition(pos)){\n            float r = rFromCoords(pos);\n            captured = r < 1.+sqrt(1.-a*a);\n            break;\n        }\n    }\n    \n    // sky direction\n    dir4D = inverse(metric(pos))*p;\n    vec3 cubeVec = vec3(-dir4D.y,dir4D.a,-dir4D.z);\n    \n    // pixel color\n    if(hitDisc){\n        fragColor = texture(iChannel1,discUV)*pow(blueshift,3.);\n    }else{\n        fragColor = texture(iChannel0,cubeVec)*float(!captured);\n    }\n}","name":"Image","description":"","type":"image"}]}