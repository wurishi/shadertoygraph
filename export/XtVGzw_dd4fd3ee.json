{"ver":"0.1","info":{"id":"XtVGzw","date":"1473871468","viewed":1230,"name":"FOV Test","username":"lara","description":"Just testing a new lookAt function I came up with (see line ~186) , you can change the horizontal and vertical FOV in line ~363 (last parameter of the Cam struct). Move your mouse to look around.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["fov","lookat","shittyterrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Many thanks to:\n// https://www.shadertoy.com/view/4djSRW\n// https://www.shadertoy.com/view/4slGD4\n// https://iquilezles.org/articles/fog\n\n#define P 0.001  // Precision\n#define D 500.   // Distance\n#define S 32     // Marching steps\n#define R 1.     // Marching substeps\n#define K 16.    // Shadow softness\n#define A 5.     // AO steps\n\n#define T iTime\n#define PI 3.14159\n#define TAU (PI*2.)\n\nstruct Hit {\n    vec3  p; // position\n    float t; // distance travelled\n    float d; // distance to object\n    float s; // steps required\n};\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n} _ray;\n\nstruct Cam {\n    vec3 p; // position\n    vec3 d; // direction\n    vec3 u; // up vector\n    vec2 f; // fov\n} _cam;\n\nconst int _num_objects = 3;\nfloat _obj[_num_objects], _d;\nint _ignore_object = -1;\n\nvec2 _uv;\n\n// gets changed during marching\nbool _shadowMarch = false;\nbool _normalMarch = false;\nbool _ambientOccMarch = false;\nbool _highresTerrain = false;\n\nfloat _water_level = 70.;\n\n/* ================= */\n/* === Utilities === */\n/* ================= */\n\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 rot(vec3 n, float a)\n{\n    float s = sin(a), c = cos(a), k = 1.0 - c;\n    \n    return mat3(n.x*n.x*k + c    , n.y*n.x*k - s*n.z, n.z*n.x*k + s*n.y,\n                n.x*n.y*k + s*n.z, n.y*n.y*k + c    , n.z*n.y*k - s*n.x,\n                n.x*n.z*k - s*n.y, n.y*n.z*k + s*n.x, n.z*n.z*k + c    );\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat hash11(float n)\n{\n    return fract(sin(dot(vec2(n),vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat hash21(vec2 p)\n{\n    p = floor(p/2.)*2.;\n    \n    p = fract(p/vec2(3.07965,7.4235));\n    p += dot(p.xy,p.yx+19.19);\n    return fract(p.x*p.y);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 e = vec2(1,0);\n    \n    f = smoothstep(0.,1.,f);\n\n    return mix(\n        mix(hash21(p),hash21(p+e.xy),f.x),\n        mix(hash21(p+e.yx),hash21(p+e.xx),f.x),\n        f.y\n    );\n}\n\nfloat terrain(vec3 x)\n{\n    float f = 0.;\n    float a = 0.;\n    vec2 p = x.xz*.5;\n    \n    for(float i = 0.; i < 5.; i++)\n    {\n        float h = pow(i+2.,2.);\n\n        f += noise(p/h)*h;\n        a += h;\n        \n        p *= rot(a);\n    }\n    \n    if (_highresTerrain == true)\n    {\n        for(float i = 0.; i < 5.; i++)\n        {\n            float h = pow(i+P,2.);\n\n            f += mix(noise(p*h)/h,noise(p/h)*h,hash11(a)*.5);\n            a += h;\n            \n            p *= rot(a);\n        }   \n    }\n    \n    return smax(f/a*200.,_water_level-.1,10.);\n}\n\n/* ============ */\n/* === Scene=== */\n/* ============ */\n\nfloat scene(vec3 p)\n{\n    float d = 1e10;\n    \n    // skybox\n    _obj[0] = _shadowMarch == true || _ambientOccMarch == true ? 1e10 : abs(length(p-_cam.p)-D)-P;\n    \n    // terrain\n    _obj[1] = p.y-terrain(p);\n    \n    _obj[2] = p.y-_water_level;\n    \n    if (_normalMarch == true)\n    {\n        _obj[2] -= noise(p.xz*vec2(1,2))*.05;\n    }\n\n    for(int i = 0; i < _num_objects; i++)\n    {\n        if (_ignore_object == i) continue;\n        d = min(d,_obj[i]);\n    }\n    \n    _d = d;\n\n    return d;\n}\n\n/* ================ */\n/* === Marching === */\n/* ================ */\n\nHit march(Ray r)\n{\n    vec3 p;\n    float t = 0., d, s;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(p = r.o + r.d*t);\n\n        if (d < P || t > D)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d/max(R+1.,1.);\n    }\n\n    return Hit(p, t, d, s);\n}\n\nRay lookAt(Cam c, vec2 uv, float aspect)\n{   \n    vec3 r = normalize(cross(c.d,c.u));\n    vec3 u = cross(r,c.d);\n    \n    uv.y /= aspect;\n    \n    float a = c.f.x/360. * uv.x * PI;\n    float b = c.f.y/360. * uv.y * PI;\n    \n    c.d *= rot(u,a);\n\n    r = normalize(cross(c.d,u));\n\n    c.d *= rot(r,b);\n    \n    return Ray(c.p, c.d);\n}\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n    \n    vec2 e = vec2(P,0.);\n\n    vec3 n = normalize(vec3(\n        scene(p+e.xyy)-scene(p-e.xyy),\n        scene(p+e.yxy)-scene(p-e.yxy),\n        scene(p+e.yyx)-scene(p-e.yyx)\n    ));\n    \n    _normalMarch = false;\n    \n    return n;\n}\n\n/* =============== */\n/* === Shading === */\n/* =============== */\n\nfloat getAmbientOcclusion(Hit h) \n{    \n    _ambientOccMarch = true;\n    \n    float t = 0., a = 0.;\n    \n    for(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i*5.);\n        t += d/max(R+1.,1.);\n    }\n    \n    _ambientOccMarch = false;\n\n    return clamp(t/A*50./D,0.,1.);\n}\n\nfloat getShadow(vec3 origin, vec3 sunDir)\n{\n    _shadowMarch = true;\n    _highresTerrain = false;\n\n    float t = 0., s = 1.0;\n\n    for(int i = 0; i < S/2; i++)\n    {\n        float d = scene(origin + sunDir * t);\n       \n      \tif (t > D) break;\n        \n        t += d;\n        s = min(s,d/t*K);\n    }\n    \n    _highresTerrain = true;\n    _shadowMarch = false;\n\n    return clamp(s,0.5,1.);\n}\n\nvec3 applyFog(vec3 col, vec3 colFog, vec3 colSun, Hit h, vec3 sunDir)\n{\n    float d = pow(length(h.p-_cam.p)/D,2.);\n    float s = pow(max(dot(_ray.d,sunDir),0.),10.*d);\n    \n    return mix(col, mix(colFog * min(sunDir.y+.5,1.), colSun, s), d);\n}\n\nvec3 getColor(Hit h)\n{    \n    _highresTerrain = true;\n \n    Hit _h = h;\n    vec3 n = getNormal(h.p);\n    \n    vec3 col = vec3(0),c;\n    vec3 col_sky = vec3(1,1.7,2)*.2;;\n    vec3 col_sun = vec3(2,1.5,1);\n    \n    vec3 sunDir = normalize(vec3(0.5,0.3,1));\n    \n    float lastRef = 0.0;\n    float ref = 0.0;\n\n    for(int i = 0; i < 2; i++)\n    {           \n        float diff = max(dot(n, sunDir),.2);\n        float spec = pow(max(dot(reflect(-sunDir,n),normalize(_cam.p-h.p)),0.),20.);\n\n        if (_d == _obj[0])\n        {    \n            c = col_sky;\n        }\n        else if(_d == _obj[1])\n        {\n            vec2 e = vec2(2,0);\n            vec3 p = h.p;\n            \n            float dh = 1.-min(mix(\n                abs(terrain(p+e.xyy)-terrain(p-e.xyy)),\n                abs(terrain(p+e.yyx)-terrain(p-e.yyx)),\n            .5),1.);\n                    \n            c = mix(vec3(.5,.25,0),vec3(.25,.5,0),dh) * getShadow(h.p, sunDir) * getAmbientOcclusion(h) * diff;\n        }\n        else if(_d == _obj[2])\n        {\n            c = vec3(0) + spec * getShadow(_h.p, sunDir);\n            ref = .3;\n        }\n        \n        c = applyFog(c, col_sky, col_sun, h, sunDir) ;\n        col = i == 0 ? c : mix(c,col,1.-lastRef);\n    \n        if (ref > 0.0)\n        {\n            Ray r;\n            r.d = normalize(reflect(h.p-_cam.p,n));\n            r.o = h.p+r.d*1.;\n        \n            h = march(r);\n            n = getNormal(h.p);\n\n            lastRef = ref;\n            ref = 0.0;\n        }\n        else { break; }\n    }\n\n    return col;\n}\n\n/* ============ */\n/* === Main === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (gl_FragCoord.xy/iResolution.xy-.5)*2.;\n    vec2 uvm = (iMouse.xy/iResolution.xy-.5)*2.;\n    \n    if (iMouse.x < 10. && iMouse.y < 10.)\n    {\n        uvm = vec2(cos(T*.5)*.5,sin(T)*.25+.75);\n    }\n    \n    _cam = Cam(\n        vec3(0,0,0),\n        vec3(0,-1,0),\n        vec3(0,0,1),\n        vec2(180,180)\n    );\n    \n    _cam.d.yz *= rot(uvm.y*cos(uvm.x)*PI/2.);\n    _cam.d.yx *= rot(uvm.x*cos(uvm.y)*PI/2.);\n    \n    _cam.p.z += T*100.;\n    \n    float h = terrain(_cam.p);\n    _cam.p.y = pow(h,.7) + _water_level + 100. + sin(T*.5) * 40.;\n\n    _ray = lookAt(_cam, uv, aspect);\n                  \n    vec3 col = getColor(march(_ray));\n\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}