{"ver":"0.1","info":{"id":"3sj3Rt","date":"1549727622","viewed":699,"name":"Uniform points on a sphere","username":"Ion824","description":"Demo of uniform sampling on a sphere.\nSource on math/theory: http://corysimon.github.io/articles/uniformdistn-on-sphere/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sphere","uniformsampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Ion Ureche\n// Year: 2019\n\nconst float SEED = M_PI;\nconst int N_POINTS = 150; // Change this number to increase/reduce number of points\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n    vec3 c = vec3(0,0,0);\n   \n    float d = MAX_DIST + EPSILON;\n    for (int i = 0; i < N_POINTS; i++) {\n        // generating uniform points on the sphere: http://corysimon.github.io/articles/uniformdistn-on-sphere/\n        float fi = float(i);\n        // Note: Use uniform random generator instead of noise in your applications\n        float theta = 2.0f * M_PI * gold_noise(vec2(fi * 0.3482f, fi * 2.18622f), SEED);\n        float phi = acos(1.0f - 2.0f * gold_noise(vec2(fi * 1.9013, fi * 0.94312), SEED));\n        float x = sin(phi) * cos(theta);\n        float y = sin(phi) * sin(theta);\n        float z = cos(phi);\n       \t\n        vec3 p1 = vec3(x,y,z) * 1.6f;\n        d = min(d, sphereSDF(samplePoint, p1, SMALL_SPHERES_RADIUS));\n    }\n    \n    \n    return d;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0 * sin(iTime), 5.0 * sin(iTime + M_PI), 7.0 * sin(iTime + M_PI / 2.0f));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.721, 0.721, 0.771, 1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = (eye + dist * worldDir);\n    fragColor = vec4(p, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float GOLDEN_RATIO = 1.61803398875;\nconst float SMALL_SPHERES_RADIUS = 0.04;\nconst float M_PI = 3.14159265359f;\nconst int MAX_MARCHING_STEPS = 55;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.0001;\n\n// ============================ TRANSFORM ==============================================\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// ============================ NOISE ==============================================\n\n// Gold Noise Â©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio, PI and the Square Root of Two\n// - superior distribution\n// - fastest static noise generator function\n// - works with all chipsets (including low precision)\n// - taken from here: https://www.shadertoy.com/view/ltB3zD\n\nprecision lowp    float;\n\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\n// ============================ SDF ==============================================\n// source: https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n","name":"Common","description":"","type":"common"}]}