{"ver":"0.1","info":{"id":"XtjXz1","date":"1444149840","viewed":219,"name":"Music distortion #2","username":"rohtie","description":"Another experiment on distorting distance fields with music.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","music","distortion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float sphere (vec3 point, float radius) {\n    return mix(length(point) - radius, length(max(abs(point)-vec3(0.2, 0.3, 3.0),0.0)), clamp(sin(iTime), 0.0, 0.5));\n}\n\nfloat map (vec3 point) {    \n    float angle = sin(iTime);\n    point.zx *= mat2(cos(angle), -sin(angle),\n                     sin(angle), cos(angle));\n    \t\n    // Works better for all songs\n    return length(point) - smoothstep(0.0, texture(iChannel0, vec2(0.0, 0.5)).r * 1.75, texture(iChannel0, point.xx * point.yy * point.zz + 0.1).r) * 1.25;\n\n    // Works best for \"experiment\" song\n    //return length(point) - clamp(0.0, 0.5, texture(iChannel0, point.xx * point.yy * point.zz + 0.1).r) * 1.25;\n}\n\nfloat intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n\n    float distance = 0.0;\n    float currentDistance = 1.0;\n    \n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        currentDistance = map(rayOrigin + rayDirection * distance);\n\n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return -1.0;\n    }\n\n    return distance;\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy),\n        map(point + extraPolate.yxy),\n        map(point + extraPolate.yyx)\n    ) - map(point));\n}\n\nvec3 light = normalize(vec3(0.0, 2.0, 3.0));\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n    point.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(point, -1.0));\n\n    float distance = intersect(cameraPosition, rayDirection);\n    \n    vec3 col = vec3(0.0);\n\n    if (distance > 0.0) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n        \n        col += vec3(0.05, 0.01, 0.35);\n        col /= vec3(texture(iChannel0, point.xx * point.yy * point.zz + 0.1).r);\n        col += vec3(0.7, 1.0, 0.95) * max(dot(normal, light), 0.0);\n        \n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n    }\n\n    color.rgb = col;\n}\n","name":"Image","description":"","type":"image"}]}