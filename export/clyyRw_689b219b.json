{"ver":"0.1","info":{"id":"clyyRw","date":"1700010116","viewed":109,"name":"Roaming inversion","username":"stb","description":"As within, so without, and all that.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","volume","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Roaming inversion\n    \n    2023 stb\n\n*/\n\n#define Bright .05         // brightness\n#define Fog    .03         // fog thickness\n#define\tRSize  .3          // size of ray marching steps\n#define\tRStep  24. / RSize // # of ray steps\n\n#define res iResolution.xy\n\nfloat map(in vec3 p) {\n\n    // rotation\n    vec2 a = iMouse.z>0. ? 4.*(iMouse.xy-.5*res)/res.y : vec2(2.*cos(.05*iTime), sin(.0357*iTime));\n    float s, c;\n    p.yz = mat2(c=cos(a.y), s=-sin(a.y), -s, c) * p.yz;\n    p.xz = mat2(c=cos(a.x), s=-sin(a.x), -s, c) * p.xz;\n\n    // mirrored inversion\n    float k = length(p) < 1. ? dot(p, p) : 1.;\n    \n    // invert coords\n    p /= k * .77;\n    \n    // repeat coords\n    p = mod(p+iTime*vec3(.1, .2, .3), 2.) - 1.;\n    \n    // x, y, & z bars\n    return\n        min(\n            min(\n                length(p.xy),\n                length(p.xz)\n            ),\n            length(p.yz)\n        ) * k;\n}\n\nvec3 march(vec3 ray, vec3 dir) {\n\n\t// initial color = sky\n    vec3 c = vec3(.1, 0., .7);\n    \n    // initial alpha value\n    float a = 1.;\n    \n    // march\n    for(float i=0.; i<RStep; i++) {\t\n    \n        // distance estimate at ray position\n\t\tfloat d = map(ray) * RSize;\n        \n        // advance ray\n        ray += d * dir;\n        \n        // mix glowing lines with col\n        c = mix(vec3(3., 2.5, 1.), c, a);\n        \n        // substract from alpha\n        a -= Bright / (d+Fog) / pow(RStep, 2.);\n        \n        // escape when alpha falls below a certain value\n        if(a<.9) break;\n\t}\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 uv = (fc-.5*res) / res.y;\n    \n    vec3 rayBeg\t= vec3(0., 0., -4.);\n    vec3 rayDir\t= normalize(vec3(uv, 2.));\n    \n    fo = vec4(march(rayBeg, rayDir), 1.);\n}","name":"Image","description":"","type":"image"}]}