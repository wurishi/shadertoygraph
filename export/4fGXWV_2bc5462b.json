{"ver":"0.1","info":{"id":"4fGXWV","date":"1715762069","viewed":150,"name":"[zznewclear13] Pixels Marbling","username":"zznewclear13","description":"Simulating paper marbling digitally! This code creates digital patterns that mimic the unique swirls and colors of traditional paper marbling.\n\nAdds smooth transitions between each drop.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["interactive","art","marbling"],"hasliked":0,"parentid":"MfKXWy","parentname":"Raster Pixels Marbling "},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Pixels Marbling\n// https://www.shadertoy.com/view/4fGXWV\n// Forked from Raster Pixels Marbling by ademdj12\n// https://www.shadertoy.com/view/MfKXWy\n\n// Adds smooth transitions between each drop.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 bufferB = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    bufferB = pow(bufferB, vec3(0.4545f));\n    fragColor = vec4(bufferB, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n    {\n        fragColor = vec4(0.0f);\n        return;\n    }\n    \n    vec4 dropData = texelFetch(iChannel1, ivec2(0, 0), 0);\n    vec4 bufferA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 bufferB = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float lastDropTime = dropData.a;\n    float timeElapsed = iTime - lastDropTime;\n    if (timeElapsed >= DROP_INTERVAL || iMouse.z > 0.0f)\n    {\n        fragColor = bufferB;\n    }\n    else\n    {\n        fragColor = bufferA;\n    }    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 leminscate(float t)\n{\n    float sinT = sin(t);\n    float cosT = cos(t);\n    float x = iResolution.x * 0.5f + iResolution.x * 0.5f * cosT / (1.0f + sinT * sinT);\n    float y = iResolution.y * 0.5f + iResolution.x * 0.5f * sinT * cosT / (1.0f + sinT * sinT);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n    {\n        fragColor = vec4(0.0f);\n        return;\n    }\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 dropData = texelFetch(iChannel1, ivec2(0, 0), 0);\n    vec4 bufferA = texture(iChannel0, uv);\n    vec4 bufferB = texture(iChannel1, uv);\n    \n    if (iMouse.z > 0.0f)\n    {\n        dropData = vec4(iMouse.xy, 1.0f, iTime);\n    }\n    \n    float lastDropTime = dropData.a;\n    float timeElapsed = iTime - lastDropTime;  \n    if (timeElapsed >= DROP_INTERVAL || iMouse.z > 0.0f)\n    {\n        fragColor = bufferA;\n        dropData.z = iMouse.z > 0.0f ? 1.0f : 0.0f;\n        dropData.a = iTime;\n    }\n    else\n    {\n        float transitionWeight = min(timeElapsed / DROP_TRANSITION, 1.0f);\n        transitionWeight = 1.0f - pow(1.0f - transitionWeight, 3.0f);\n    \n        vec2 ddxUV = vec2(1.0f, 0.0f) / iResolution.xy;\n        vec2 ddyUV = vec2(0.0f, 1.0f) / iResolution.xy;\n\n        vec3 dropCol = pal(lastDropTime * 0.1f);\n        vec2 dropPos = mix(leminscate(lastDropTime), dropData.xy, dropData.z);\n        \n        float radius = mix(DROP_RADIUS_RANGE.x, DROP_RADIUS_RANGE.y, hash11(lastDropTime)) * iResolution.y;\n        radius *= transitionWeight;\n        vec3 dropParams = drop(fragCoord, dropPos, radius);\n\n        vec2 uv = (fragCoord + dropParams.xy) / iResolution.xy;\n        vec3 bufferA = textureGrad(iChannel0, uv, ddxUV, ddyUV).rgb;\n        vec3 col = mix(bufferA, dropCol, dropParams.z);\n\n        fragColor = vec4(col, bufferB.a);\n    }\n    \n    if (all(equal(iFragCoord, ivec2(0, 0)))) fragColor = dropData;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DROP_RADIUS_RANGE vec2(0.06f, 0.18f)\n#define DROP_INTERVAL 0.3f\n#define DROP_TRANSITION 0.2f\n\n// Palettes\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d));\n}\n\nvec3 pal(float t)\n{\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.10,0.20);\n    return pal(t, a, b, c, d);\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// vec3(offset.x, offset.y, weight)\nvec3 drop(vec2 pos, vec2 dropPos, float radius)\n{\n    vec2 q = pos - dropPos;\n    vec2 offset = q * sqrt(1.0f - radius * radius / dot(q, q));\n    offset = dropPos + offset - pos;\n    \n    float sdCircle = length(q) - radius;\n    float weight = smoothstep(1.5f, 0.0f, sdCircle);\n    \n    return vec3(offset, weight);\n}\n","name":"Common","description":"","type":"common"}]}