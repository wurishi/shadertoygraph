{"ver":"0.1","info":{"id":"MsVcWz","date":"1521677057","viewed":95,"name":"roundedRect v5","username":"matkatmusic","description":"This is a piece-wise implementation of a 'recti-circle'. \nHaving trouble with the Upper Left corner.  can anyone chime in?  it's lines 222-250","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["roundrect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nfloat area( vec2 A, vec2 B, vec2 C)\n{\n \treturn 0.5 * abs( A.x*B.y - A.x*C.y + B.x*C.y - B.x*A.y + C.x*A.y - C.x*B.y );   \n}\n\nfloat distanceFromPointToLine(vec2 P1, vec4 line)\n{\n    //assums P2 and P3 form hypotenuse\n    vec2 P2 = line.xy;\n    vec2 P3 = line.zw;\n    float b = distance(P2, P3);\n    float area = area( P1, P2, P3 );\n    \n    return 2. * area / b;\n}\n\nfloat distanceFromPointToCircle(vec2 p, vec3 circle)\n{\n\treturn abs(sqrt( (p.x-circle.x)*(p.x-circle.x) + (p.y-circle.y)*(p.y-circle.y) ) - circle.z);\n}\n\n\nbool between( float lowerLimit, float value, float upperLimit )\n{\n\treturn lowerLimit <= value && value <= upperLimit;   \n}\n\nbool isOnLine(vec4 line, vec2 point, float threshold) { return distanceFromPointToLine(point, line ) <= threshold; }\n//========================================================================\n/*\nA segment\n*/\nvec4 getA(float width, float height, vec2 center, float radius)\n{\n    //zw is top\n    //xy is bottom\n    float x = center.x - width*0.5 - radius;\n    return vec4(x, \n                center.y - height*0.5, \n                x, \n                center.y + height*0.5); //x,y,z,w\n}\nbool isOnA(vec4 a, vec2 p, float threshold) { return isOnLine( a, p, threshold) && between( a.y, p.y, a.w ); }\nbool isOutsideA(vec4 a, vec2 p ) { return between( a.y, p.y, a.w ) && p.x < a.x; }\nbool isInsideA(vec4 a, vec2 p ) { return between( a.y, p.y, a.w ) && p.x > a.x; }\n//========================================================================\n/*\nB segment\n*/\nvec4 getB(float width, float height, vec2 center, float radius)\n{\n    float x = center.x - width * 0.5;\n    float y = center.y + height * 0.5;\n    return vec4(x, y,\n                radius * 0.5,\n                radius * 0.5);\n}\nbool isOnB(vec4 b, vec2 p, float threshold) { return distanceFromPointToCircle(p, b.xyz) < threshold; }\nbool isOutsideB(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) > b.z && (p.x <= b.x) && (p.y >= b.y); }\nbool isInsideB(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) < b.z && (p.x - b.x < 0.) && (p.y - b.y > 0.); }\n//========================================================================\n/*\nC segment\n*/\nvec4 getC(float width, float height, vec2 center, float radius)\n{\n    float y = center.y + height * 0.5 + radius;\n    return vec4(center.x - width*0.5,\n                y,\n                center.x + width*0.5,\n                y);\n}\nbool isOnC(vec4 c, vec2 p, float threshold) {  return between( c.x, p.x, c.z ) && abs(p.y-c.y) < threshold;}\nbool isOutsideC(vec4 c, vec2 p) { return between( c.x, p.x, c.z) && p.y > c.y; }\nbool isInsideC(vec4 c, vec2 p)  { return between( c.x, p.x, c.z) && p.y < c.y; }\n//========================================================================\n/*\nD segment\n*/\nvec4 getD(float width, float height, vec2 center, float radius)\n{\n    float x = center.x + width * 0.5;\n    float y = center.y + height * 0.5;\n    return vec4(x, y,\n                radius * 0.5,\n                radius * 0.5);\n}\nbool isOnD(vec4 b, vec2 p, float threshold) { return distanceFromPointToCircle(p, b.xyz) < threshold; }\nbool isOutsideD(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) > b.z && (p.x >= b.x) && (p.y >= b.y); }\nbool isInsideD(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) < b.z && (p.x - b.x > 0.) && (p.y - b.y > 0.); }\n//========================================================================\n/*\nE segment\n*/\nvec4 getE(float width, float height, vec2 center, float radius)\n{\n\tfloat x = center.x + width*0.5 + radius;\n    return vec4(x, \n                center.y - height*0.5, \n                x, \n                center.y + height*0.5); //x,y,z,w\n}\nbool isOnE(vec4 a, vec2 p, float threshold ) { return isOnLine( a, p, threshold) && between( a.y, p.y, a.w ); }\nbool isOutsideE(vec4 a, vec2 p ) { return between( a.y, p.y, a.w ) && p.x > a.x; }\nbool isInsideE(vec4 a, vec2 p ) { return between( a.y, p.y, a.w ) && p.x < a.x; } \n//========================================================================\n/*\nF segment\n*/\nvec4 getF(float width, float height, vec2 center, float radius)\n{\n    float x = center.x + width * 0.5;\n    float y = center.y - height * 0.5;\n    return vec4(x, y,\n                radius * 0.5,\n                radius * 0.5);\n}\nbool isOnF(vec4 b, vec2 p, float threshold) { return distanceFromPointToCircle(p, b.xyz) < threshold; }\nbool isOutsideF(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) > b.z && (p.x >= b.x) && (p.y <= b.y); }\nbool isInsideF(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) < b.z && (p.x - b.x > 0.) && (p.y - b.y < 0.); }\n//========================================================================\n/*\nG segment\n*/\nvec4 getG(float width, float height, vec2 center, float radius)\n{\n    float y = center.y - height * 0.5 - radius;\n    return vec4(center.x - width*0.5,\n                y,\n                center.x + width*0.5,\n                y);\n}\nbool isOnG(vec4 g, vec2 p, float threshold) {  return between( g.x, p.x, g.z ) && abs(p.y-g.y) < threshold;}\nbool isOutsideG(vec4 g, vec2 p) { return between( g.x, p.x, g.z) && p.y < g.y; }\nbool isInsideG(vec4 g, vec2 p)  { return between( g.x, p.x, g.z) && p.y > g.y; }\n//========================================================================\n/*\nH segment\n*/\nvec4 getH(float width, float height, vec2 center, float radius)\n{\n    float x = center.x - width * 0.5;\n    float y = center.y - height * 0.5;\n    return vec4(x, y,\n                radius * 0.5,\n                radius * 0.5);\n}\nbool isOnH(vec4 b, vec2 p, float threshold) { return distanceFromPointToCircle(p, b.xyz) < threshold; }\nbool isOutsideH(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) > b.z && (p.x <= b.x) && (p.y <= b.y); }\nbool isInsideH(vec4 b, vec2 p) { return distanceFromPointToCircle(p,b.xyz) < b.z && (p.x - b.x < 0.) && (p.y - b.y < 0.); }\n//========================================================================\nbool isInside()\n{\n \t//returns true if glFragCoord is inside shape A   \n    return true;\n}\nbool isOutside()\n{\n \t//returns true if glFragCoord is outside shape A   \n    return true;\n}\nbool isOn()\n{\n    //returns true if glFragCoord is ON shape A\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 glFragCoord = fragCoord;\n    vec2 bounds = iResolution.xy;\n    \n    float widthPx = 0.7 * bounds.x;\n    float heightPx = .5 * bounds.y;\n    float thicknessPx = 25.;\n    float radiusPx = 30.;\n    \n    vec2 centerPx = bounds * 0.5;\n    float thresholdPx = 1.;\n    \n    vec4 innerColor = vec4(1,0,0,1); //red\n    vec4 outerColor = vec4(0,1,1,1); //green blue\n    \n    vec4 glFragColor = vec4(0., 0., 0., 1.);\n\n    // Output to screen\n    vec4 a = getA(widthPx, heightPx, centerPx, radiusPx);\n    vec4 c = getC(widthPx, heightPx, centerPx, radiusPx);\n    vec4 e = getE(widthPx, heightPx, centerPx, radiusPx);\n    vec4 g = getG(widthPx, heightPx, centerPx, radiusPx);\n    vec4 b = getB(widthPx, heightPx, centerPx, radiusPx);\n    vec4 d = getD(widthPx, heightPx, centerPx, radiusPx);\n    vec4 f = getF(widthPx, heightPx, centerPx, radiusPx);\n    vec4 h = getH(widthPx, heightPx, centerPx, radiusPx);\n    //todo: account for radius\n    float distanceBtoA;\n    float distanceEdgeToA;\n   \tif( isOutsideA( a, glFragCoord ) )\n    {\n        distanceBtoA = distanceFromPointToLine( glFragCoord, a );\n        distanceEdgeToA = distanceFromPointToLine( vec2(0,glFragCoord.y), a );\n    }\n    else if (isOutsideE(e, glFragCoord) )\n    {\n     \tdistanceBtoA = distanceFromPointToLine( glFragCoord, e );\n        distanceEdgeToA = distanceFromPointToLine( vec2(bounds.x,glFragCoord.y), e );\n    }\n    else if( isOutsideC( c, glFragCoord ) )\n    {\n     \tdistanceBtoA = distanceFromPointToLine( glFragCoord, c );\n        distanceEdgeToA = distanceFromPointToLine( vec2(glFragCoord.x, bounds.y), c);\n    }\n    else if( isOutsideG( g, glFragCoord) )\n    {\n     \tdistanceBtoA = distanceFromPointToLine( glFragCoord, g);\n        distanceEdgeToA = distanceFromPointToLine( vec2(glFragCoord.x, 0.), g);\n    }\n    else if( isOutsideB( b, glFragCoord) )\n    {\n        //imagine a line from B thru glFragCoord(aka P) to the edge of the window. \n        //T is on this line at a distance of 'radius' from B\n        //U is on this line, at the edge of the window. \n    \t//find tx\n        vec2 T;\n        vec2 P = glFragCoord;\n        vec2 B = b.xy;\n        T.x = B.x - radiusPx*sqrt((P.x-B.x)*(P.x-B.x) + (P.y-B.y)*(P.y-B.y)) / sqrt((P.x-B.x)*(P.x-B.x));\n        //T.x = b.x - radiusPx * distance(b.xy, glFragCoord) / distance(b.xy, vec2(glFragCoord.x, b.y));\n        //find ty\n        T.y = B.y + radiusPx * sqrt((B.y-P.y)*(B.y-P.y)) / sqrt((P.x-B.x)*(P.x-B.x) + (P.y-B.y)*(P.y-B.y));\n        //T.y = b.y + radiusPx * distance(b.xy, vec2(b.x, glFragCoord.y)) / distance(glFragCoord, b.xy);\n        //if( distance( glFragCoord, T) < thresholdPx )\n        {\n            //glFragColor = outerColor;\n        }\n        //find ux\n        //find uy\n        vec2 U;\n        float ang = atan(P.y - B.y, P.x - B.x);\n        if( (ang * 180. / PI) > 45.0 )\n        {\n         \tU.y = ang * distance( B, vec2(0.,B.y) );\n            U.x = 0.;\n        }\n        else\n        {\n            U.x = ang * distance( B, vec2(B.x, bounds.y)); //distance(B,D) where D is top of window, above B\n            U.y = bounds.y;\n        }\n        \n        distanceBtoA = distance(P, T);\n        distanceEdgeToA = distance(U, T);\n    }\n    else if( isOutsideD( d, glFragCoord ) )\n    {\n        distanceEdgeToA = 1.;\n        distanceBtoA = 1.;\n    }\n    else if( isOutsideF( f, glFragCoord) )\n    {\n    \tdistanceEdgeToA = 1.;\n        distanceBtoA = 1.;   \n    }\n    else if( isOutsideH( h, glFragCoord) )\n    {\n        distanceEdgeToA = 1.;\n        distanceBtoA = 1.;\n    }\n    else\n    {\n        distanceEdgeToA = 1.;\n        distanceBtoA = 0.;\n    }\n    glFragColor = mix( innerColor, outerColor, distanceBtoA / distanceEdgeToA );\n    \n    if( isInsideB( b, glFragCoord) )\n    {\n    \t//glFragColor = innerColor; \t   \n    }\n    \n    \n    \n    \n    fragColor = glFragColor;\n}","name":"Image","description":"","type":"image"}]}