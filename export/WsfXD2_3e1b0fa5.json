{"ver":"0.1","info":{"id":"WsfXD2","date":"1552172053","viewed":210,"name":"Dragonworm","username":"OliverSchaff","description":"Persisting a moving shape. My first try on buffers.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","warping","buffer","persistence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // read in the image from Buffer A\n\tvec4 col0 = texture(iChannel0, uv);\n    \n    // send it to the screen\n    fragColor = col0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // read the last image (better: pixelcolor) from Buffer A\n    // Buffer A is set to \"nearest\". \n    // This gives a sharp last image instead of a slightly blurred one\n    // we apply a shift to uv before reading the last image\n    // this adds a moving effect\n    vec3 col = texture(iChannel0, uv + 0.01*vec2(cos(iTime), sin(iTime))).xyz;\n    \n    // darken the last image a bit to make it fade out with time;\n    col *= 0.96;\n\n    // set aspect ratio of axes to 1.0\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // constant that is used in anti-aliasing\n    float aa = 1.5/min(iResolution.x, iResolution.y);\n    \n    // skew the uv-plane a little\n    // and define a sinple distance function (a circle)\n    vec2 shift = 0.2*vnoise(2.0*uv)+0.2*vec2(cos(2.4*iTime),-2.0*abs(sin(4.0*iTime)));\n    uv += vec2(-0.8,-0.3) + shift;\n    float dist = circle(uv, 0.2);\n\n    // draw the brighter circumference\n    // it is mixed (added) into the last image, which resides in col\n    col += 1.5*color(iTime) * (1.0-smoothstep(0.025, 0.025+aa, dist));\n    // draw the inner band\n    // it is mixed onto the last image, which resides in col\n    col = mix(col, color(iTime), 1.0-smoothstep(0.02, 0.02 + aa, dist));\n    \n    // draw this image into buffer A\n    fragColor = vec4(col, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// very helpful was this shader https://www.shadertoy.com/view/ltdSRn\n// by  panda1234lee\n\n// palette by Inigo Quilez\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(float c) {\n    // 0.0 < c < 1.0 covers the full palette\n    return pal( c, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat vnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// distance function of a circle\nfloat circle(in vec2 st, in float r) {\n    float dist = abs(r - length(st));\n    return dist;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}