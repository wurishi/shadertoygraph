{"ver":"0.1","info":{"id":"XsV3zG","date":"1455839431","viewed":868,"name":"Floating Island Settlement","username":"SamGondelman","description":"WASD/arrows: move\nE,Q: up/down\nTab: fast\nSpace: slow\n1/2/3: reset pos\nMouse: rotate cam\nP: 3rd person\nN: normals\nM: depth\nB: anti-alias off\nV: draw AA edges\n\nReference: http://cdn.paper4pc.com/images/bridge-of-floating-islands-landscapes-wallpaper-1.jpg","likes":18,"published":1,"flags":48,"usePreview":1,"tags":["procedural","3d","raymarching","mouse","clouds","antialiasing","keyboard","trees","multipass","flocking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Depth Aware Fast Approximation Anti-Aliasing\n\t\n\tThis was an implementation I devised for the Ray project in CS123, somewhat\n\toptimized for GLSL.\n\n\tBased on differences in depths between neighboring pixels, a pixel is blurred\n\thorizontally, vertically, or both.\n\n\tThe vignetting is also from my CS123 final\n\n\tHold B to turn off anti-aliasing (and vignetting) for comparison\n\tHold V to visualize the edges that will be blurred\n\tHold M to draw the depth\n**/\n// Other constants\nconst float TMAX = 250.0;\n\n// Texel storage constants\nconst float KEY_M  = 77.5/256.0;\nconst float KEY_B  = 66.5/256.0;\nconst float KEY_V  = 86.5/256.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n\tvec4 col = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n\n    if (texture(iChannel1, vec2(KEY_M, 0.25)).x > 0.5) {\t\t\t\t\t// Depth\n        fragColor = vec4(vec3(0.75*pow(col.w/TMAX, 0.25)),1.0);\n    } else if (texture(iChannel1, vec2(KEY_B, 0.25)).x < 0.5) {\t\t\t// FXAA\n        vec4 middle = col;\n        vec4 left = texture(iChannel0, (fragCoord+vec2(-1,0))/iChannelResolution[0].xy);\n        vec4 right = texture(iChannel0, (fragCoord+vec2(1,0))/iChannelResolution[0].xy);\n        vec4 top = texture(iChannel0, (fragCoord+vec2(0,-1))/iChannelResolution[0].xy);\n        vec4 bottom = texture(iChannel0, (fragCoord+vec2(0,1))/iChannelResolution[0].xy);\n\n        float h = abs((left.w-middle.w)/(right.w-middle.w));\n        float v = abs((top.w-middle.w)/(bottom.w-middle.w));\n\n        const float EDGE_THRESHOLD = 5.0;\n        const int BLUR_RADIUS = 5;\n\n        vec4 result = vec4(0.0);\n        float xRadius = float(BLUR_RADIUS)*step(EDGE_THRESHOLD, h);\n        float yRadius = float(BLUR_RADIUS)*step(EDGE_THRESHOLD, v);\n\n        if (texture(iChannel1, vec2(KEY_V, 0.25)).x > 0.5) {\t\t\t\t// AA edges\n            fragColor = vec4(col.xyz, 1.0);\n            float xStep = step(0.5, xRadius);\n            float yStep = step(0.5, yRadius);\n            fragColor.z = xStep + fragColor.z*(1.0-xStep);\n            fragColor.y = yStep + fragColor.y*(1.0-yStep);\n            return;\n        }\n\n        float total = 0.0;\n        for (int y = -BLUR_RADIUS; y <= BLUR_RADIUS; y++) {\n            for (int x = -BLUR_RADIUS; x <= BLUR_RADIUS; x++) {\n                float weightx = 1.0 - abs(float(x)/float(BLUR_RADIUS))*step(0.5, xRadius);\n                float weighty = 1.0 - abs(float(y)/float(BLUR_RADIUS))*step(0.5, yRadius);\n                float weight = weightx*weighty;\n                float xx = float(x)*step(0.5, xRadius);\n                float yy = float(y)*step(0.5, yRadius);\n                result += texture(iChannel0, (fragCoord+vec2(xx,yy))/iChannelResolution[0].xy)*weight;\n                total += weight;\n            }\n        }\n        result /= total;\n        \n        // Vignette\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tvec2 screenPos = uv*2.0 - 1.0;\n        result.xyz *= 0.5 + 0.5*pow((screenPos.x+1.0)*(screenPos.y+1.0)*(screenPos.x-1.0)*(screenPos.y-1.0), 0.2);\n        fragColor = vec4(result.xyz, 1.0);\n    } else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Normal\n        fragColor = vec4(col.xyz, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\tPlayer Movement\n\t\n\tThis buffer keeps track of the players position and velocity.\n\n\tPressing a key will set your goal velocity, and you will accelerate towards that\n\tvelocity non-linearly for smooth starts and stops.\n\n\tWASD/arrow keys to move\n\tE/Q to go up/down\n\tTab to speed up\n\tSpace to slow down\n\n\tIf your machine is slower you might need to turn VEL_MAG up so you move faster.\n\n\tI used https://www.shadertoy.com/view/MddGzf to figure out how render buffers worked.\n\n\tPress 1/2/3 to reset your position\n**/\n// Math constants\nconst float PI = 3.14159265359;\nconst float EPS = 0.0001;\n\n// Texel addresses\nconst vec2 txPlayerPos = vec2(0.0,0.0);\nconst vec2 txPlayerVel = vec2(1.0,0.0);\n\n// Texel storage constants\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_S  = 83.5/256.0;\nconst float KEY_D  = 68.5/256.0;\n\nconst float KEY_E  = 69.5/256.0;\nconst float KEY_Q  = 81.5/256.0;\nconst float KEY_TAB  = 9.5/256.0;\nconst float KEY_SPACE  = 32.5/256.0;\n\nconst float KEY_1  = 49.5/256.0;\nconst float KEY_2  = 50.5/256.0;\nconst float KEY_3  = 51.5/256.0;\n\n// Other constants\nconst float VEL_MAG = 50.0;\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\n// Render buffer helpers\nvec4 loadValue(in vec2 re) {\n    return texture(iChannel0, (0.5 + re)/iChannelResolution[0].xy, -100.0);\n}\n\nfloat isInside(vec2 p, vec2 c) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\n\nvoid storeValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 2.0 || fragCoord.y > 1.0) discard;\n    \n    vec3 playerPos = loadValue(txPlayerPos).xyz;\n    vec3 playerVel = loadValue(txPlayerVel).xyz;\n    \n    // Reset position at beginning or if 1/2/3 is pressed\n    if(iFrame == 0 || texture(iChannel1, vec2(KEY_1, 0.25)).x > 0.5) {\n        playerPos = vec3(130.0, 5.0, -16.0);\n        playerVel = vec3(0);\n    } else if (texture(iChannel1, vec2(KEY_2, 0.25)).x > 0.5) {\n        playerPos = vec3(10.0, 8.0, -6.0);\n        playerVel = vec3(0);        \n    } else if (texture(iChannel1, vec2(KEY_3, 0.25)).x > 0.5) {\n        playerPos = vec3(23.0, 8.0, -35.0);\n        playerVel = vec3(0);        \n    }\n    \n    vec3 goalVelocity = vec3(0.0);\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0.505, 0.51);\n    }\n    vec3 w = normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n\tvec3 u = normalize(cross(w,UP));\n    \n    // Tab/Space to speed up/slow down\n    float s = 1.0;\n    if (texture(iChannel1, vec2(KEY_TAB, 0.25)).x > 0.5) {\n    \ts = 5.0;\n    } else if (texture(iChannel1, vec2(KEY_SPACE, 0.25)).x > 0.5) {\n       \ts = 0.2;\n    }    \n    \n    // WASD/arrow key movement\n    if (texture(iChannel1, vec2(KEY_UP, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_W, 0.25)).x > 0.5) {\n        goalVelocity += s*VEL_MAG*w;\n    }\n    if (texture(iChannel1, vec2(KEY_DOWN, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_S, 0.25)).x > 0.5) {\n        goalVelocity += -s*VEL_MAG*w;\n    }\n    if (texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_D, 0.25)).x > 0.5) {\n        goalVelocity += s*VEL_MAG*u;\n    }\n    if (texture(iChannel1, vec2(KEY_LEFT, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_A, 0.25)).x > 0.5) {\n        goalVelocity += -s*VEL_MAG*u;\n    }\n    \n    // E,Q for up/down\n    if (texture(iChannel1, vec2(KEY_E, 0.25)).x > 0.5) {\n        goalVelocity += s*VEL_MAG*UP;\n    }\n    if (texture(iChannel1, vec2(KEY_Q, 0.25)).x > 0.5) {\n        goalVelocity -= s*VEL_MAG*UP;\n    }\n    \n    vec3 accel = 15.0*(goalVelocity - playerVel);\n    \n    playerVel = playerVel + accel * iTimeDelta;\n    playerPos += playerVel * iTimeDelta;\n    \n    // Bound to sphere around origin\n    if (dot(playerPos,playerPos) > 200.0*200.0) {\n        playerPos = (200.0-EPS)*normalize(playerPos);\n        playerVel = vec3(0.0);\n    }\n    \n    fragColor = vec4(0.0); \n    storeValue(txPlayerPos, vec4(playerPos,0.0), fragColor, fragCoord);\n    storeValue(txPlayerVel, vec4(playerVel,0.0), fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/** Boids (simplified version of http://www.red3d.com/cwr/boids/)\n\n\tThis buffer stores position, velocity, perch bool, and perch timer for a flock of\n\tboids and handles moving them.\n\n\tI didn't actually end up implementing perching because I didn't have enough time.\n\n\tMovement is a little buggy, but I'm not completely sure why...\n\n**/\n// Constants\n\n// if you change this, also change it in Buf C\n#define NUM_BOIDS 25.0\n\n// Render buffer helpers\nvec4 loadValue(in vec2 re) {\n    return texture(iChannel0, (0.5 + re)/iChannelResolution[0].xy, -100.0);\n}\n\n// Helpers\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nvec3 cohesion(vec4 posPerch, vec2 fragCoord) {\n    vec3 cen = vec3(0.0);\n    \n    for (float i = 0.0; i < NUM_BOIDS; i++) {\n        if (abs(fragCoord.x - i) < 0.5) continue;\n        cen += loadValue(vec2(i, fragCoord.y)-0.5).xyz;\n    }\n    cen /= NUM_BOIDS - 1.0;\n    \n    return (cen - posPerch.xyz)/200.0;\n}\n\nvec3 separation(vec4 posPerch, vec2 fragCoord) {\n    vec3 d = vec3(0.0);\n    \n    for (float i = 0.0; i < NUM_BOIDS; i++) {\n        if (abs(fragCoord.x - i) < 0.5) continue;\n       \tvec3 p = loadValue(vec2(i, fragCoord.y)-0.5).xyz;\n        if (dot(p-posPerch.xyz, p-posPerch.xyz) < 3.0*3.0) {\n            d -= p - posPerch.xyz;\n        }\n    }\n    return d/20.0;\n}\n\nvec3 alignment(vec4 velTime, vec2 fragCoord) {\n    vec3 avg = vec3(0.0);\n    \n    for (float i = 0.0; i < NUM_BOIDS; i++) {\n        if (abs(fragCoord.x - i) < 0.5) continue;\n        avg += loadValue(vec2(i, fragCoord.y)-0.5).xyz;\n    }\n    avg /= NUM_BOIDS - 1.0;\n    \n    return (avg - velTime.xyz)/100.0;\n}\n\nvec3 goal(vec4 posPerch) {\n    vec3 g = 100.0*vec3(sin(iTime/10.0), 0.5*sin(iTime/20.0), cos(iTime/10.0));\n    return (g - posPerch.xyz)/200.0;\n}\n\nvec3 bound(vec4 posPerch) {\n    const float BOUND = 175.0;\n    const float VEL = 2.5;\n    vec3 v = vec3(0.0);\n\n    if (posPerch.x < -BOUND) {\n        v.x = VEL;\n    } else if (posPerch.x > BOUND) {\n        v.x = -VEL;\n    }\n    if (posPerch.y < -BOUND) {\n        v.y = VEL;\n    } else if (posPerch.y > BOUND) {\n        v.y = -VEL;\n    }\n    if (posPerch.z < -BOUND) {\n        v.z = VEL;\n    } else if (posPerch.z > BOUND) {\n        v.z = -VEL;\n    }\n    \n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > NUM_BOIDS || fragCoord.y > 1.5) discard;\n    \n    if (fragCoord.y < 1.0) {\n    \tvec4 velTime = loadValue(fragCoord-0.5);\n    \tvec4 posPerch = loadValue(fragCoord+vec2(0.0, 1.0)-0.5);\n        \n        if(iFrame == 0) {\n            // Random velocities with xyz between -5 and 5\n        \tvelTime = 10.0*vec4(hash(fragCoord.x*234.0+iDate.w) - 0.5,\n                                hash(fragCoord.x*6547.0+iDate.w) - 0.5,\n                                hash(fragCoord.x*945.0+iDate.w) - 0.5, 0.0);\n        } else if (iFrame > 30) {\n            float flockcoeff = 1.5*sin(iTime/5.0);\n           \tvec3 v1 = cohesion(posPerch, fragCoord+vec2(0.0, 1.0));\n\t\t\tvec3 v2 = separation(posPerch, fragCoord+vec2(0.0, 1.0));\n            vec3 v3 = alignment(velTime, fragCoord);\n            vec3 v4 = goal(posPerch);\n            vec3 v5 = bound(posPerch);\n\n\t\t\tvelTime.xyz += flockcoeff*v1 + v2 + v3 + v4 + v5;\n            \n            float speed = length(velTime.xyz);\n            const float MAX_SPEED = 100.0;\n            if (speed > MAX_SPEED) {\n                velTime.xyz = velTime.xyz/speed*MAX_SPEED;\n            }\n        }\n        \n        fragColor = velTime;\n    } else {\n        vec4 velTime = loadValue(fragCoord-vec2(0.0, 1.0)-0.5);\n    \tvec4 posPerch = loadValue(fragCoord-0.5);\n        \n    \tif(iFrame == 0) {\n        \t// Random position with xyz between -200 and 200\n            // Why do the birds all explode at the beginning?\n            posPerch = vec4(400.0*(hash(fragCoord.x*927.0+iDate.w) - 0.5),\n                            400.0*(hash(fragCoord.x*2636.0+iDate.w) - 0.5),\n                            400.0*(hash(fragCoord.x*892.0+iDate.w) - 0.5), 0.0);\n        } else if (iFrame > 30) {\n        \tposPerch += velTime*iTimeDelta;\n        }\n        \n        fragColor = posPerch;\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/** Raymarching\n\n\tThe scene is defined in map() and colored in computeColor().\n\n\tCamera motion is in mainImage().\n\n\tClick and drag to move the camera\n\tHold P to show 3rd person\n\tHold N to draw normals\n**/\n\n// Just draws the leftmost island (without noise), tree + apple, and fence\n#define TEST 0\n\n#define CLOUDS 1\n#define LEAVES 1\n#define SMOKE 1\n\n#define BOIDS 1\n#define NUM_BOIDS 25\n\n#define USE_SHADOWS 0\n\n// Math constants\nconst float PI = 3.14159265359;\nconst float EPS = 0.0001;\nconst float FLT_MAX = 1.0 / 0.000000000001; // hacky but GLSL doesn't have a FLT_MAX by default\n\n// Raymarching constants\nconst float TMAX = 400.0;\nconst int MAX_STEPS = 250;\nconst float DIST_THRESHOLD = 0.00001;\n\n// Texel addresses\nconst vec2 txPlayerPos = vec2(0.0,0.0);\n\n// Texel storage constants\nconst float KEY_N  = 78.5/256.0;\nconst float KEY_P  = 80.5/256.0;\n\n// Other constants/helpers\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nvec3 SUN_DIR = normalize(vec3(-0.5, -1.0, -1.0));\n#define clamp01(a) clamp(a, 0.0, 1.0)\n\nstruct Ray {\n    vec3 src;\n    vec3 dir;\n    float t;\n    vec3 pos;\n    vec3 nor;\n    int matID;\n    int iter;\n};\n\n// GLSL default parameters don't seem to work so this is for any call to map\n// where you don't actually care about the material of what you hit\nint junkMatID;\n\n// Perlin Noise\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nfloat interpolatedNoise2D(vec2 xy, int seed) {\n    vec2 p = floor(xy);\n    vec2 f = fract(xy);\n    f = f*f*(3.0-2.0*f);\n\n    float n = dot(vec3(p.xy, seed), vec3(1, 157, 141));\n    return mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n               mix(hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat perlinNoise2D(vec2 xy, float freq, float amp, int octaves, int seed){\n    float total = 0.0;\n    float totalScale = 0.0;\n    // current freq, amp, scale\n    vec3 currFAS = vec3(freq, amp, amp);\n    for(int i = 0; i < 5; i++){\n        total += interpolatedNoise2D(abs(xy) * currFAS.x, seed) * currFAS.y;\n        totalScale += currFAS.z;\n        currFAS *= vec3(2.0, 0.5, 0.5);\n        if (i >= octaves) break;\n    }\n    return amp * (total / totalScale);\n}\n\nfloat interpolatedNoise3D(vec3 xyz, int seed) {\n    vec3 p = floor(xyz);\n    vec3 f = fract(xyz);\n    f = f*f*(3.0-2.0*f);\n\n    float n = dot(vec4(p, seed), vec4(1, 433, 157, 141));\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.z),\n               mix(mix(hash(n+433.0), hash(n+434.0),f.x),\n                   mix(hash(n+590.0), hash(n+591.0),f.x),f.z), f.y);\n}\n\nfloat perlinNoise3D(vec3 xyz, float freq, float amp, int octaves, int seed){\n    float total = 0.0;\n    float totalScale = 0.0;\n    // current freq, amp, scale\n    vec3 currFAS = vec3(freq, amp, amp);\n    for(int i = 0; i < 5; i++){\n        total += interpolatedNoise3D(abs(xyz) * currFAS.x, seed) * currFAS.y;\n        totalScale += currFAS.z;\n        currFAS *= vec3(2.0, 0.5, 0.5);\n        if (i >= octaves) break;\n    }\n    return amp * (total / totalScale);\n}\n\n// I wrote these primitive equations and CSG operations for my CS123 final\n// Primitives\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 dim) {\n    vec3 d = abs(p) - dim;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat roundedbox(vec3 p, vec3 dim, float r) {\n    vec3 d = abs(p) - dim;\n    return length(max(d,vec3(0.0))) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cone(vec3 p, float r, float h) {\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*r/h;\n    float d2 = max(sqrt(dot(p.xz,p.xz)*(1.0-si*si)) + q*si, q);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat triangularPrism(vec3 p, vec2 h, float theta) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*sin(radians(theta))+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// CSG operations\nfloat intersectionDist(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat subtractionDist(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n// Transformations\nvec3 rX(vec3 p, float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    vec3 q = p;\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n    return p;\n}\n\nvec3 rY(vec3 p, float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    vec3 q = p;\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n    return p;\n}\n\nfloat blend(float a, float b, float k) {\n    float h = clamp01(mix(1.0, (b-a)/k, 0.5));\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// On linux, mod doesn't work as expected for negative numbers\nvec3 repeat(vec3 p, vec3 r) {\n    p = abs(p);\n    return vec3(p.x - (r.x * floor(p.x/r.x)) - 0.5*r.x,\n                p.y - (r.y * floor(p.y/r.y)) - 0.5*r.y,\n                p.z - (r.z * floor(p.z/r.z)) - 0.5*r.z);\n//    return mod(p, r) - 0.5*r;\n}\n\nvoid propose(inout float val, inout int matID, float proposedVal, int proposedMatID) {\n\t// This doesn't work for some reason?\n//    float overridden = step(val, proposedVal);\n//    val = overridden * proposedVal + (1.0-overridden) * val;\n//    matID = int(overridden * float(proposedMatID) + (1.0-overridden) * float(matID));\n    if (proposedVal < val) {\n        val = proposedVal;\n        matID = proposedMatID;\n    }\n}\n\nfloat map(vec3 p, inout int matID, vec3 playerPos, bool drawPlayer) {\n    float res = FLT_MAX;\n    \n    // islands offset\n    vec3 ip = p;\n    ip.y += 0.8;\n    \n#if !TEST\n    ip.y -= perlinNoise2D(ip.xz, 1.0, 0.3, 1, 697);\n    ip.y += (perlinNoise2D(ip.xz+vec2(50.0), 0.5, 5.0, 3, 769)-4.1)*(1.0-smoothstep(6.9, 7.5, ip.y));\n#endif\n    \n    // left island\n    propose(res, matID, blend(cone(rX(ip, 180.0), 10.0, 7.5),\n                              cylinder(p-vec3(0.0, 6.5, 0.0), 13.0, 0.15), 3.0), 3);\n        \n#if !TEST  \n    propose(res, matID, blend(cone(rX(ip-vec3(1.0, 2.5, -12.0), 180.0), 5.5, 5.0),\n                              cylinder(p-vec3(1.0, 6.5, -12.0), 7.0, 0.15), 3.0), 3);\n    propose(res, matID, blend(cone(rX(ip-vec3(5.0, 4.5, -18.0), 180.0), 4.0, 3.0),\n                              cylinder(p-vec3(5.0, 6.5, -18.0), 5.0, 0.15), 3.0), 3);\n    \n    // right island\n    propose(res, matID, blend(cone(rX(ip-vec3(23.0, 2.5, -40.0), 180.0), 6.0, 5.0),\n                              cylinder(p-vec3(23.0, 6.4, -40.0), 6.95, 0.2), 3.0), 3);\n    propose(res, matID, blend(cone(rX(ip-vec3(18.0, 4.25, -45.0), 180.0), 4.0, 3.25),\n                              cylinder(p-vec3(18.0, 6.4, -45.0), 4.45, 0.2), 3.0), 3);\n    \n    // house\n    vec3 z = rY(vec3(0,0,1), 50.0);\n    float cyl1 =  cylinder(rX(rY(p-vec3(-1.0, 10.9, -3.0)+24.0*z, 35.0), 90.0), 22.1, 5.0);\n    float cyl2 =  cylinder(rX(rY(p-vec3(-1.0, 10.9, -3.0)-24.0*z, 35.0), 90.0), 22.1, 5.0);\n    float house = box(rY(p-vec3(-1.0, 10.5, -3.0), 35.0), vec3(2.0, 3.0, 2.0));\n    house = subtractionDist(house, cyl1);\n    house = subtractionDist(house, cyl2);\n    propose(res, matID, house, 4);\n    float roof = blend(triangularPrism(rY(p-vec3(-1.0, 14.0, -3.0), 35.0),\n                                        vec2(1.0,2.0), 20.0),\n                       cylinder(rX(rY(p-vec3(-1.0, 14.4, -3.0), 35.0), 90.0),\n                                0.2, 1.7), 0.6);\n    propose(res, matID, roof, 5);\n    \n    // chimney\n    propose(res, matID, roundedbox(rY(p-vec3(-0.8, 13.5, -1.0), 35.0), vec3(0.15, 1.2, 0.15), 0.05), 6);\n    \n    // door\n    propose(res, matID, box(rY(p-vec3(-1.0, 8.5, -5.0), 35.0), vec3(0.4, 1.05, 0.4)), 7);\n    propose(res, matID, sphere(p-vec3(-1.0, 8.5, -5.52), 0.05), 8);\n    \n    // bridge\n    vec3 x = rY(vec3(1,0,0), 50.0);\n    vec3 cen = vec3(-10.5,7.5,0.0)+36.89*x;\n    vec3 bp = p + vec3(0.0, 0.05, 0.0);\n    vec2 offset = vec2(iTime/35.0, iTime/30.0);\n    bp.y += perlinNoise2D(bp.xz+offset, 0.1+0.05*sin(iTime/6.0)+0.05*cos(iTime/7.0),\n                          2.0, 1, 537)*(max(0.0, 1.0-dot(bp.xz-cen.xz,bp.xz-cen.xz)/59.0));\n    float bridge = box(rY(bp-cen, 40.0), vec3(0.75,1.5,7.8));\n    float planks = box(repeat(rY(bp-vec3(-10.5,7.5,0.0), 40.0), vec3(0.0,0.0,0.3)),\n                       vec3(0.5,0.05,0.125));\n    propose(res, matID, intersectionDist(planks, bridge), 9);\n    \n    // bridge ropes\n    propose(res, matID, cylinder(rX(rY(bp-cen+0.45*z, 40.0), 90.0), 0.01, 7.7), 9);\n    propose(res, matID, cylinder(rX(rY(bp-cen-0.45*z, 40.0), 90.0), 0.01, 7.7), 9);\n    \n    propose(res, matID, cylinder(rX(rY(bp-cen-0.25*x+0.47*z-UP, 40.0), 90.0), 0.03, 8.25), 9);\n    propose(res, matID, cylinder(rX(rY(bp-cen-0.47*z-UP, 40.0), 90.0), 0.03, 8.4), 9);\n    \n    float ropes1 = cylinder(repeat(rY(bp-vec3(-10.5,8.0,0.0)+0.47*z, 40.0), vec3(0.0,0.0,0.9)), 0.02, 0.5);\n    float ropes2 = cylinder(repeat(rY(bp-vec3(-10.5,8.0,0.0)-0.47*z, 40.0), vec3(0.0,0.0,0.9)), 0.02, 0.5);\n    propose(res, matID, intersectionDist(ropes1, bridge), 9);\n    propose(res, matID, intersectionDist(ropes2, bridge), 9);\n    \n    float disp = (sin(p.x*p.y)*sin(p.z*p.x))/40.0;\n    propose(res, matID, cylinder(rX(rY(p-cen+8.25*x+0.55*z-0.5*UP, 60.0), 30.0), 0.07, 0.6)+disp, 9);\n    propose(res, matID, cylinder(rX(rY(p-cen+8.3*x-0.54*z-0.5*UP, 75.0), -15.0), 0.07, 0.6)+disp, 9);\n    propose(res, matID, cylinder(rX(rY(p-cen-8.25*x+0.43*z-0.5*UP, 30.0), 30.0), 0.07, 0.65)+disp, 9);\n    propose(res, matID, cylinder(p-cen-8.4*x-0.47*z-0.5*UP, 0.07, 0.6)+disp, 9);\n\n    \n    // right tree\n    for (int i = 0; i < 4; i++) {\n        float fi = float(i);\n        vec3 tp = p;\n        vec2 add = vec2(sin(p.y+fi/4.0*2.0*PI+2.0*PI*hash(36.0*fi)),\n                        cos(p.y+fi/4.0*2.0*PI+2.0*PI*hash(83.0*fi)))/4.0;\n        float ystep = smoothstep(8.5, 11.0, p.y);\n        tp.xz += add*ystep;\n        propose(res, matID, cylinder(rX(rY(tp-vec3(27.0, 10.0, -42.0), 180.0*(fi-1.0)/4.0*ystep), 40.0*ystep),\n                                 0.07+(max(11.5-p.y, 0.0))/10.0, 4.0), 9);\n    }\n    \n    // right fence\n    for(int i = 0; i < 6; i++) {\n        float fi = float(i);\n    \tvec3 off = rY(vec3(1.0,0.0,0.0), 15.0*fi-40.0);\n    \tvec3 nextOff = rY(vec3(1.0,0.0,0.0), 15.0*float(i+1)-40.0);\n    \tpropose(res, matID, cylinder(p-vec3(23.0, 7.75, -40.0)-6.7*off, 0.07, 0.6), 9);\n        vec3 hc = rX(rY(p-vec3(23.0, 7.75, -40.0)-6.7*(off+nextOff)/2.0, 180.0 - (15.0*(fi+0.5)-40.0)), 90.0);\n        float a1 = 7.0*sin(fi*2320.0);\n        float a2 = 7.0*sin(fi*235.0);\n        a1 = mix(a1, -15.0, step(4.5, fi));\n        a2 = mix(a2, -25.0, step(4.5, fi));\n        propose(res, matID, cylinder(rX(hc, a1), 0.04, 0.87), 9);\n        propose(res, matID, cylinder(rX(hc, a2)-vec3(0.0,0.0,0.4*step(fi, 4.5)), 0.04,\n                                     0.87+0.1*step(4.5, fi)), 9);\n    }\n\n#endif\n    \n   \t// left tree\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        vec3 tp = p;\n        vec2 add = vec2(sin(p.y+fi/5.0*2.0*PI+2.0*PI*hash(50.0*fi)),\n                        cos(p.y+fi/5.0*2.0*PI+2.0*PI*hash(50.0*fi)))/4.0;\n        float ystep = smoothstep(9.0, 11.5, p.y);\n        tp.xz += add*ystep;\n        propose(res, matID, cylinder(rX(rY(tp-vec3(6.0, 10.5, 8.0), 360.0*fi/5.0*ystep), 40.0*ystep),\n                                 0.1+(max(11.5-p.y, 0.0))/10.0, 5.0), 9);\n    }\n    \n    // left fence\n    for(int i = 0; i < 4; i++) {\n        float fi = float(i);\n    \tvec3 off = rY(vec3(1.0,0.0,0.0), 8.0*fi-170.0);\n    \tvec3 nextOff = rY(vec3(1.0,0.0,0.0), 8.0*float(i+1)-170.0);\n    \tpropose(res, matID, cylinder(p-vec3(0.0, 7.75, 0.0)-12.5*off, 0.07, 0.6), 9);\n        vec3 hc = rX(rY(p-vec3(0.0, 7.75, 0.0)-12.5*(off+nextOff)/2.0, 180.0 - (8.0*(fi+0.5)-170.0)), 90.0);\n        float a1 = 7.0*sin(fi*2320.0);\n        float a2 = 7.0*sin(fi*235.0);\n        a1 = mix(a1, -15.0, step(2.5, fi));\n        a2 = mix(a2, -25.0, step(2.5, fi));\n        propose(res, matID, cylinder(rX(hc, a1), 0.04, 0.87), 9);\n        propose(res, matID, cylinder(rX(hc, a2)-vec3(0.0,0.0,0.4*step(fi, 2.5)), 0.04,\n                                     0.87+0.1*step(2.5, fi)), 9);\n    }\n    \n    // apple\n    float t = max(0.0, iTime -10.0);\n    float appleY = min(0.5*9.81*t*t, 5.0);\n    propose(res, matID, sphere(p-vec3(8.0, 12.65-appleY, 7.6), 0.15), 10);\n    \n    // player\n    if (drawPlayer) {\n        propose(res, matID, sphere(p-playerPos, 0.25), 2);\n    }\n    \n#if BOIDS\n    // Sometimes the boids fly backwards so one of these angles is wrong?\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        vec3 v = texture(iChannel2, vec2(float(i), 1.0)/iChannelResolution[2].xy).xyz;\n        float r = length(v);\n        float theta = degrees(acos(v.z/r));\n        float phi = degrees(atan(v.y, v.x))+180.0;\n        vec3 pos = texture(iChannel2, vec2(float(i)/iChannelResolution[2].x, 0.0)).xyz;\n        propose(res, matID,\n                cone(rX(rY(p-pos, phi), theta), 0.25, 0.5),\n                11);\n    }\n#endif\n    \n    return res;\n}\n\n// Lighting\nfloat directionalLightDiffuse(vec3 nor, vec3 ldir) {\n    return clamp01(dot(nor, -ldir));\n}\n\n// Effects\nfloat softshadow(vec3 pos, vec3 ldir, vec3 playerPos) {\n#if USE_SHADOWS\n    float res = 1.0;\n    float t = 0.01;\n    for(int i = 0; i < 25; i++) {\n        float h = map(pos - ldir*t, junkMatID, playerPos, true);\n        res = min(res, 7.0*h/t);\n        t += clamp(h, 0.007, 5.0);\n        if (h < EPS) break;\n    }\n    return clamp01(res);\n#else\n    return 1.0;\n#endif\n}\n\n// Coloring different materials\nvec3 sky(vec3 dir) {\n    return mix(vec3(0.4, 0.7, 0.9),\n               vec3(0.23, 0.17, 0.13),\n               smoothstep(0.0, 0.7, dir.y)/2.0);\n}\n\nvec3 islands(Ray ray) {\n    float topStep = smoothstep(0.0, 0.2, ray.nor.y+perlinNoise2D(ray.pos.xz, 5.0, 0.4, 1, 157));\n    \n    // grass\n    vec3 col = mix(vec3(0.38, 0.2, 0.0), vec3(0.0, 0.8, 0.2), topStep);    \n    \n    // rocky detail\n    col = mix(vec3(0.46, 0.3, 0.2), col, (topStep+smoothstep(0.01, 0.25, abs(ray.nor.y+0.707)))/2.0);\n    col = mix (col, vec3(0.75, 0.60, 0.36), (1.0-topStep)*perlinNoise2D(ray.pos.xz, 0.1, 0.7, 1, 987));\n    \n    return col;\n}\n\nvec3 house(Ray ray) {\n    vec3 col = vec3(1.0);\n    \n    // windows\n    float g = 4.0/3.0;\n    vec3 w = repeat(rY(ray.pos, 35.0) - vec3(g/3.0, g/1.25, g/3.0), vec3(g, 2.0, g)) + vec3(g/2.0);\n    float winStep = step(g/2.0, w.x)*step(0.4, w.y)*step(g/2.0, w.z);\n    col = mix(vec3(0.0, 0.6, 0.0), col, 1.0-winStep);\n\n    w = repeat(rY(ray.pos, 35.0) - vec3(g/1.25, g/1.25, g/1.25), vec3(g, 2.0, g)) + vec3(g/2.0);\n    winStep = step(g/2.0, w.x)*step(0.4, w.y)*step(g/2.0, w.z);\n    col = mix(vec3(0.0, 0.6, 0.0), col, 1.0-winStep);\n    \n    col = mix(vec3(1.0), col, step(9.5, ray.pos.y));\n    \n    // bottom moulding\n    float botStep = step(8.0, ray.pos.y);\n    col = mix(vec3(0.3, 0.5, 0.0), col, botStep);\n    \n    return col;\n}\n\nvec3 roof(Ray ray) {\n    vec3 col = vec3(1.0);\n    \n    // tan roof\n    col = mix(col, vec3(0.9, 0.7, 0.5), step(0.3, ray.nor.y));\n    \n    // roof lines\n    float g = 1.0/2.0;\n    vec3 w = repeat(rY(ray.pos + vec3(g), 35.0), vec3(g)) + vec3(g/2.0);\n    float lineStep = smoothstep(0.0, 0.02, w.z)*smoothstep(g, g-0.02, w.z);\n    col = mix(vec3(0.6, 0.4, 0.2), col, lineStep);\n\n    // round windows\n    vec3 x = rY(vec3(2.0, 0.0, 0.0), 55.0);\n    vec3 p = ray.pos-vec3(-1.0, 14.4, -3.0)+x;\n    float dist2 = dot(p, p);\n    float roundStep = step(dist2, 0.16);\n    p = ray.pos-vec3(-1.0, 14.4, -3.0)-x;\n    dist2 = dot(p, p);\n    roundStep += step(dist2, 0.16);\n    col = mix(col, vec3(0.0, 0.6, 0.0), roundStep);\n    \n \treturn col;\n}\n\nvec3 chimney(Ray ray) {\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    // bricks\n    float g = 1.0/7.0;\n    float offset = mod(floor(ray.pos.y/g),2.0)*g/2.0;\n    vec3 w = repeat(rY(ray.pos + vec3(g), 35.0) - vec3(offset, 0.0, offset), vec3(g)) + vec3(g/2.0);\n    float lineStep = smoothstep(0.0, 0.02, w.x)*smoothstep(g, g-0.02, w.x)*\n        smoothstep(0.0, 0.02, w.y)*smoothstep(g, g-0.02, w.y)*\n        smoothstep(0.0, 0.02, w.z)*smoothstep(g, g-0.02, w.z);\n    col = mix(vec3(0.35, 0.2, 0.1), col, lineStep);\n    \n    col = mix(vec3(0.0), col, 1.0-smoothstep(0.95, 0.99, ray.nor.y));\n    \n    return col;\n}\n\nvec3 door() {\n    return vec3(0.0, 0.5, 0.6);\n}\n\nvec3 doorknob(Ray ray) {\n    vec3 col = vec3(1.0, 0.84, 0.0);\n    vec3 z = rY(vec3(0,0,1), 55.0);\n    col = mix(vec3(0.0), col, smoothstep(0.0, 0.2, abs(ray.nor.y))*smoothstep(0.0, 0.2, abs(dot(ray.nor, z))));\n    return col;\n}\n\nvec3 wood(Ray ray) {\n    vec3 col = vec3(0.6, 0.4, 0.2);    \n    col *= perlinNoise2D(ray.pos.xz, 5.0, 1.0, 1, 487);    \n    return col;\n}\n\nvec3 apple(Ray ray) {\n    vec3 col = vec3(0.8, 0.25, 0.0);\n    col *= perlinNoise3D(ray.nor, 4.0, 1.0, 1, 487)*1.75;\n    return col;\n}\n\nvec3 bird() {\n    return vec3(1.0);\n}\n\nvec3 player(Ray ray, vec3 playerPos) {\n    vec3 col = vec3(0.45);\n    \n    // Lines\n    float th = fract(ray.pos.y-playerPos.y);\n    col = mix(vec3(0.6), col, smoothstep(0.0, 0.006, th)*(1.0-smoothstep(0.994, 1.0, th)));\n    float offset = mod(floor(ray.pos.y-playerPos.y),2.0)*0.5;\n    float phi = fract(fract(acos(dot(normalize(ray.nor.xz), vec2(1,0)))/(PI/5.0))+offset);\n    col = mix(vec3(0.65), col, smoothstep(0.0, 0.025, phi)*(1.0-smoothstep(0.975, 1.0, phi)));\n\n    // Eye\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 w = -normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n    vec3 r = normalize(ray.pos - playerPos);\n    \n    float eyeStep1 = smoothstep(0.95, 0.959, dot(r, w));\n    col = mix(col, vec3(0.1), eyeStep1);\n    float eyeStep2 = smoothstep(0.96, 0.999, dot(r, w));\n    col = mix(col, vec3(1.0,0.0,0.0), eyeStep2);\n    float eyeStep3 = smoothstep(0.998, 1.0, dot(r, w));\n    col = mix(col, vec3(1.0,1.0,0.0), eyeStep3);\n    \n    return col;\n}\n\nvec3 computeColor(Ray ray, vec3 playerPos) {\n    vec3 col = vec3(0.0);\n    \n    // Switch on matID\n    // a return -> different/no lighting\n    // no return -> default lighting\n \tif (ray.matID == 0) {\n    \treturn sky(ray.dir);\n    } else if (ray.matID == 2) {\n        col = player(ray, playerPos);\n    } else if (ray.matID == 3) {\n        col = islands(ray);\n    } else if (ray.matID == 4) {\n        col = house(ray);\n    } else if (ray.matID == 5) {\n        col = roof(ray);\n    } else if (ray.matID == 6) {\n        col = chimney(ray);\n    } else if (ray.matID == 7) {\n        col = door();\n    } else if (ray.matID == 8) {\n        col = doorknob(ray);\n    } else if (ray.matID == 9) {\n        col = wood(ray);\n    } else if (ray.matID == 10) {\n        col = apple(ray);\n    } else if (ray.matID == 11) {\n        col = bird();\n    }\n    \n    // Default lighting\n    float sunLight = directionalLightDiffuse(ray.nor, SUN_DIR);\n    float sunShadow = softshadow(ray.pos, SUN_DIR, playerPos);\n\n    col = col * (0.8 * sunLight * sunShadow + 0.1);\n    \n    return col;\n}\n\nvec3 calculateNormal(vec3 pos, vec3 playerPos) {\n    const vec3 e = vec3(EPS, 0.0, 0.0);\n\tfloat p = map(pos, junkMatID, playerPos, true);\n\treturn normalize(vec3(map(pos + e.xyy, junkMatID, playerPos, true) - p,\n           \t\t\t\t  map(pos + e.yxy, junkMatID, playerPos, true) - p,\n                          map(pos + e.yyx, junkMatID, playerPos, true) - p));\n}\n\nvec3 raymarch(inout Ray ray, vec3 playerPos, bool drawPlayer) {\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        h = map(ray.src + t*ray.dir, ray.matID, playerPos, drawPlayer);\n        t += h;\n        ray.iter = i;\n        if (t > TMAX || h < DIST_THRESHOLD) break;\n    }\n    ray.t = t;\n    ray.pos = ray.src + ray.t*ray.dir;\n    ray.nor = calculateNormal(ray.pos, playerPos);\n    int missed = int(step(TMAX, ray.t));\n    ray.matID = (1- missed) * ray.matID;\n    ray.nor *= float(1-missed);\n    if (texture(iChannel1, vec2(KEY_N, 0.25)).x > 0.5)\t\t\t// Color with normals\n        return normalize(0.5*(ray.nor+1.0));\n    return computeColor(ray, playerPos);\n}\n\nfloat cloudDen(vec3 p) {\n\tvec3 q = p + vec3(500) - vec3(1.0,0.1,1.0)*iTime*50.0;\n    q += vec3(500.0);\n\tfloat f = perlinNoise3D(q, 0.005, 0.25, 3, 1531)-perlinNoise3D(q, 0.005, 0.25, 3, 2131);\n    f *= smoothstep(200.0*200.0, 300.0*300.0, dot(p, p));\n    f *= (1.0-smoothstep(0.0, 600.0, p.y));\n    return clamp01(1.5*f);\n}\n\nvec4 cloudCol(vec4 sum, float den) {\n    vec3 lin = vec3(0.7, 0.6, 0.4)*1.5;\n    vec4 col = vec4(lin*(1.0-den*4.0), den);\n    col.xyz *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\nfloat leafDen(vec3 p) {\n    // left tree\n    vec3 t1 = vec3(6.0, 14.5, 8.0);\n    float f1 = 1.0-dot(p-t1, p-t1)/35.0;\n    f1 /= 1.2;\n    \n    float f2 = 0.0;\n#if !TEST    \n    // right tree\n    vec3 t2 = vec3(27.0, 13.0, -42.0);\n    vec3 d2 = p-t2;\n    f2 = 1.0-dot(d2, d2)/40.0;    \n    f2 -= max(d2.z + d2.y/3.0*d2.y/3.0, 0.0);    \n    f2 *= 0.5;\n#endif\n    \n    float pn = perlinNoise3D(p-vec3(500.0), 1.0, 0.5, 1, 3127);\n    float w = perlinNoise3D(p-vec3(500.0) - vec3(1.0, 0.0, -1.0)*iTime, 2.0, 0.1, 1, 3127);\n    return clamp01(2.0*max(f1-pn+w, f2-pn+w));\n}\n\nvec4 leafCol(vec4 sum, float den) {\n    vec3 lin = vec3(0.65, 0.67, 0.14)*1.2;\n    vec4 col = vec4(lin*(1.0-den), den);\n    col.xyz *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\nfloat smokeDen(vec3 p) {\n    vec3 t = vec3(-0.8, 15.5, -1.0);\n    float r = (abs(p.z - t.z) + 2.0)/1.5;\n    \n    p -= vec3(t.x-1.5, 0.0, t.z-0.1);\n    \n    float f = 1.0 - abs(p.y - t.y + 1.0 - 4.0*sqrt(p.z))/r;\n    \n    f -= perlinNoise3D(p-vec3(500.0)-vec3(0.0, iTime, iTime), 0.5, 1.0, 1, 7691);\n    \n    f *= smoothstep(1.3*p.x-3.0, 1.3*p.x, p.z);\n    f *= smoothstep(-1.3*p.x, -1.3*p.x+3.0, p.z);\n    f *= 1.0 - min(1.0, dot(p-t, p-t)/350.0);\n    \n    return clamp01(0.75*f);\n}\n\nvec4 smokeCol(vec4 sum, float den) {\n    vec3 lin = vec3(0.9);\n    vec4 col = vec4(lin*(1.0-den*2.0), den);\n    col.xyz *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\nvec4 render(Ray ray, vec3 playerPos, bool thirdPerson) {\n    vec3 res = raymarch(ray, playerPos, thirdPerson);\n    float t1 = mix(ray.t, TMAX, step(float(ray.matID), 0.5));\n    \n    float t = 0.0;\n    vec3 p = ray.src + t*ray.dir;\n    \n    // There's probably a better way to do this instead of\n    // raymarching 3 times but Â¯\\_(ãƒ„)_/Â¯\n    // The coloring also needs to happen back to front,\n    // so right now if you look at leaves through chimney smoke,\n    // the leaves will appear on top, but I don't know how to fix\n    // that\n    \n    // Clouds\n#if CLOUDS\n    vec4 cloud = vec4(0.0);\n    t = 0.0;\n    p = ray.src + t*ray.dir;\n    for(int i = 0; i < 310; i++) {\n        float den = cloudDen(p);\n        if(den > 0.01) {\n            cloud = cloudCol(cloud, den);\n\t\t}\n\t\tt += max(0.5, 0.02*t);\n        if(cloud.w > 0.99 || (ray.matID != 0 && t > t1)) break;\n        p = ray.src + t*ray.dir;\n    }\n\n    res = res*(1.0-cloud.w) + cloud.xyz;    \n#endif\n    \n    // Chimney smoke\n#if SMOKE && !TEST\n    vec4 smoke = vec4(0.0);\n    t = 0.0;\n    p = ray.src + t*ray.dir;\n    for(int i = 0; i < 550; i++) {\n        float den = smokeDen(p);\n        if(den > 0.01) {\n            smoke = smokeCol(smoke, den);\n\t\t}\n\t\tt += max(0.1, 0.007*t);\n        if(smoke.w > 0.99 || (ray.matID != 0 && t > t1)) break;\n        p = ray.src + t*ray.dir;\n    }\n\n    res = res*(1.0-smoke.w) + smoke.xyz;    \n#endif\n    \n    // Leaves\n#if LEAVES\n    vec4 leaf = vec4(0.0);\n    t = 0.0;\n    p = ray.src + t*ray.dir;\n    for(int i = 0; i < 360; i++) {\n        float den = leafDen(p);\n        if(den > 0.01) {\n            leaf = leafCol(leaf, den);\n\t\t}\n\t\tt += max(0.3, 0.01*t);\n        if(leaf.w > 0.99 || (ray.matID != 0 && t > t1)) break;\n        p = ray.src + t*ray.dir;\n    }\n\n    res = res*(1.0-leaf.w) + leaf.xyz;    \n#endif\n    \n    return vec4(clamp01(res), t1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0+2.0*uv; \t\t\t\t\t\t// Pixel space of the focal plane\n\tp.x *= iResolution.x/iResolution.y;\n    \n    Ray ray;\n    ray.pos = vec3(0.0);\n    ray.nor = vec3(0.0);\n    ray.matID = 0;\n    ray.t = 0.0;\n    \n\t// camera\n\tvec3 playerPos = texture(iChannel0, (txPlayerPos+0.5)/iChannelResolution[0].xy).xyz;\n\tfloat d = 5.5; \t\t\t\t\t\t\t\t// Distance between eye and focal plane\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0.505, 0.51);\n    }\n    vec3 w = normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n\tvec3 u = normalize(cross(w,UP));\n\tvec3 v = normalize(cross(u,w));\n    ray.dir = normalize(p.x*u + p.y*v + d*w);\n    ray.src = playerPos;\n    \n    bool thirdPerson = texture(iChannel1, vec2(KEY_P, 0.25)).x > 0.5;\n    if (thirdPerson) {\t\t\t\t\t\t\t// Third person\n        ray.src -= 5.0*w;\n    }\n    \n\tfragColor = render(ray, playerPos, thirdPerson);\n}","name":"Buf C","description":"","type":"buffer"}]}