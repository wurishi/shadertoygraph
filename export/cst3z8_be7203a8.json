{"ver":"0.1","info":{"id":"cst3z8","date":"1676983502","viewed":89,"name":"Weierstrass function __","username":"Envy24","description":"Continuous but not differentiable function (if ab > 1 + 3/2 * PI).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","function","continuous","weierstrass","nondifferentiable"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 2.5 )\n#define UNIT                      ( 3.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define PI                          3.1415926535897932\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\n// Function definition.\nfloat Weierstrass(float x) \n{ \n#define T ( iTime * 0.1 )\n#define a ( .5 )//( sinOSC(.5, 1., T) )\n#define b ( sinOSC(1., 10., T) )\n\n    float sum = 0.;\n    \n    // n should be infinite.\n    for (float n = 0.; n < 10.; n += 1.)\n    {\n        sum += pow(a, n) * cos(pow(b, n) * PI * x);\n    }\n    \n    return sum; \n}\nfloat explicit_sdf(\n    in vec2 NDC,\n    in float pixel_size,\n    in float order)\n{\n    order = max(0., order);\n    \n    float minimal_distance = 99.;\n    vec2 B = \n        vec2(NDC.x-order*pixel_size,\n             Weierstrass(NDC.x-order*pixel_size));\n      \n    for (float i = -order + 1.; i <= order; i += 1.)\n    {\n        vec2 E = vec2(B.x + pixel_size, Weierstrass(B.x + pixel_size));\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    /* Explicit function y=f(x) */\n         color = mix( color, vec3(1,0,0), SMAA(explicit_sdf(NDC, UNIT/8., 7.)) );\n         \n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n    //return mix( min, max, .5 + .5*sin(T) )\n}\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}