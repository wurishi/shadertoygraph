{"ver":"0.1","info":{"id":"4dtcRj","date":"1551943714","viewed":136,"name":"Reminisphere","username":"Albeforia","description":".","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GAMMA_FACTOR = 2.2;\n\n/**\n * Gamma correction.\n */\nvec3 linearToGamma(vec3 value, float gammaFactor) {\n\treturn pow(value, vec3(1.0 / gammaFactor));\n}\n\n/**\n * Reinhard tonemapping.\n */\nvec3 tonemapReinhard(vec3 x) {\n\treturn x / (x + vec3(1.0));\n}\n\n/**\n * ACES tonemapping.\n */\nvec3 tonemapACES(vec3 x) {\n\tconst float a = 2.51;\n\tconst float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n        \n    //col = tonemapACES(col);\n    \n    fragColor = vec4(linearToGamma(col, GAMMA_FACTOR), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//=======================================================================================\n// Constants\n//=======================================================================================\n\nconst float PI = 3.14159265359;\nconst float\tEPSILON = 0.001;\n\nconst int\tMSAA_COUNT = 1;\n\nconst int\tVIEW_RAY_MAX_STEPS = 255;\nconst float VIEW_RAY_MAX_LENGTH = 100.0;\n\nconst int\tSHADOW_RAY_MAX_STEPS = 100;\nconst float SHADOW_RAY_MAX_LENGTH = 20.0;\n\nconst float AO_MAX_STEPS = 80.0;\nconst float\tAO_MAX_RANGE = 1.8;\nconst float\tAO_FALLOFF = 1.6;\n\nconst float\tMIN_REFLECTIVITY = 0.04;\n\n//=======================================================================================\n// Math\n//=======================================================================================\n\nfloat pow2(float x) {\n\treturn x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n\treturn x2 * x2;\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat compMin(vec3 v) {\n\treturn min(v.x, min(v.y, v.z));\n}\n\nfloat compMax(vec3 v) {\n\treturn max(v.x, max(v.y, v.z));\n}\n\n// hash functions see: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 0.1031\n#define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\n\nfloat hash11(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n/**\n * Van der Corput radical inverse.\n */\nfloat radicalInverseVdC(uint bits) {\n\tbits = (bits << 16u) | (bits >> 16u);\n\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\treturn float(bits) * 2.3283064365386963e-10;\n}\n\n/**\n * Generate Hammersley 2d points.\n * ref: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n */\nvec2 hammersley2d(uint i, float n) {\n\treturn vec2(float(i)/n, radicalInverseVdC(i));\n}\n\n/**\n * Generate uniform mapped random points on unit hemisphere.\n */\nvec3 sampleHemisphereUniform(vec2 p) {\n\tfloat phi = p.y * 2.0 * PI;\n\tfloat cosTheta = 1.0 - p.x;\n\tfloat sinTheta = sqrt(1.0 - pow2(cosTheta));\n\treturn vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\n/**\n * Generate cosine mapped random points on unit hemisphere.\n */\nvec3 sampleHemisphereCos(vec2 p) {\n\tfloat phi = p.y * 2.0 * PI;\n\tfloat cosTheta = sqrt(1.0 - p.x);\n\tfloat sinTheta = sqrt(1.0 - pow2(cosTheta));\n\treturn vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\n//=======================================================================================\n// Transformations\n// Matrices are column-major and already inverted.\n//=======================================================================================\n\nmat2 rotate2(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nmat4 rotateX(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat4(1, 0, 0, 0,\n                0, c,-s, 0,\n                0, s, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c, 0, s, 0,\n                0, 1, 0, 0,\n                -s,0, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c,-s, 0, 0,\n                s, c, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n}\n\nmat4 translate(vec3 p) {\n\treturn mat4(1,    0,    0,    0,\n                0,    1,    0,    0,\n                0,    0,    1,    0,\n                -p.x, -p.y, -p.z, 1);\n}\n\n/**\n * Convert p from tangent space(z-up) to world space.\n */\nvec3 tangentToWorld(vec3 p, vec3 normal) {\n    vec3 up = abs(normal.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n\tvec3 tx = normalize(cross(up, normal));\n\tvec3 ty = cross(normal, tx);\n    return tx * p.x + ty * p.y + normal * p.z;\n}\n\n//=======================================================================================\n// Struct Definitions\n//=======================================================================================\n\nstruct sRay {\n    vec3\to;\n    vec3\tdir;\n    float\ttMin;\n    float\ttMax;\n};\n\n/**\n * Used as the output parameter of rayMarch.\n *\n * p:\t\tthe intersection point\n * t:\t\tray parameter when hit\n * mid:\t\tmaterial index of the intersection\n */\nstruct sHit {\n    vec3\tp;\n    float\tt;\n    int\t\tmid;\n};\n\n/**\n * Used as the return value of sdScene.\n *\n * d:\t\tthe shortest distance from the a point to the scene surface\n * mid:\t\tmaterial index of the surface that has the shortest distance\n */\nstruct sSceneRec {\n\tfloat\td;\n    int\t\tmid;\n};\n\nstruct sMaterial {\n    vec3\tbaseColor;\n    float\troughness;\n    float\tmetalness;\n};\n\nstruct sDirLight {\n\tvec3    color;\n    vec3    dir;\n};\n\nstruct sPointLight {\n    vec3    color;\n    vec3    position;\n    float   range;\n    float   decay;\n};\n\nstruct sSphereLight {\n    vec3\tradiance;\n\tvec3\tcenter;\n    float\tradius;\n};\n\n//=======================================================================================\n// Material Definitions\n//=======================================================================================\n\n#define MATERIAL_DEFAULT\t\t0\n#define MATERIAL_1\t\t\t\t1\n#define MATERIAL_2\t\t\t\t2\n#define MATERIAL_3\t\t\t\t3\n#define MATERIAL_4\t\t\t\t4\n#define MATERIAL_LIGHT_SPHERE\t5\n\nconst int MAX_MATERIALS_NUM = 3;\n\nsMaterial gMaterials[MAX_MATERIALS_NUM] = sMaterial[MAX_MATERIALS_NUM] (\n    // #0 default\n\tsMaterial(\n    \tvec3(0.1, 0.1, 0.1),\n        0.99,\n        0.0\n    ),\n    // #1\n\tsMaterial(\n    \tvec3(1.000, 0.782, 0.344),  // gold\n        0.2,\n        1.0\n    ),\n    // #2\n\tsMaterial(\n    \tvec3(0.913, 0.922, 0.924),\t// aluminum\n        0.15,\n        1.0\n    )\n);\n\n//=======================================================================================\n// Light Definitions\n//=======================================================================================\n\nsDirLight gDirLight0 = sDirLight(\n    vec3(0.0),\n    normalize(vec3(0.0, -1.0, -1.0))\n);\n\nsPointLight gPointLight0 = sPointLight(\n    vec3(2.0, 2.0, 2.0),\n    vec3(-0.7, 0.6, 2.5),\n    5.0, 2.0\n);\n\nsSphereLight gSphereLight0 = sSphereLight(\n    vec3(10.0),\n    vec3(0.7, 1.2, 2.5),\n    0.28\n);\n\n//=======================================================================================\n// SDF Definitions\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) - r + length(max(d, 0.0));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * 0.866025 + q.y * 0.5, q.y) - h.x);\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdSphere(vec3 p, float r) {\n \treturn length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xy) - t.x, p.z);\n\treturn length(q) - t.y;\n}\n\n//=======================================================================================\n// Distance Operations\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\n/**\n * Return a if cond is true, otherwise b.\n */\nsSceneRec select(sSceneRec a, sSceneRec b, bool cond) {\n    int s = int(cond);\n\treturn sSceneRec(\n        a.d * float(s) + b.d * float(1 - s),\n        a.mid * s + b.mid * (1 - s)\n    );\n}\n\nsSceneRec opU(sSceneRec r1, sSceneRec r2) {\n    return select(r1, r2, r1.d < r2.d);\n}\n\nsSceneRec opI(sSceneRec r1, sSceneRec r2) {\n\treturn select(r1, r2, r1.d > r2.d);\n}\n\nsSceneRec opS(sSceneRec r1, sSceneRec r2) {\n    r2.d = -r2.d;\n\treturn select(r1, r2, r1.d > r2.d);\n}\n\n//=======================================================================================\n// Domain Operations\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\nvec3 opRep(vec3 p, vec3 spacing) {\n\treturn mod(p, spacing) - 0.5 * spacing;\n}\n\n//=======================================================================================\n// Domain Deformations\n// ref: https://iquilezles.org/articles/distfunctions\n//\n// These functions do not preserve distances,\n// you must decrease your marching step to properly sample these functions.\n//=======================================================================================\n\nvec3 opTwistX(vec3 p, float angle) {\n\tmat2 m = rotate2(angle * p.x);\n\treturn vec3(m * p.yz, p.x);\n}\n\nvec3 opTwistY(vec3 p, float angle) {\n\tmat2 m = rotate2(angle * p.y);\n\treturn vec3(m * p.xz, p.y);\n}\n\nvec3 opTwistZ(vec3 p, float angle) {\n\tmat2 m = rotate2(angle * p.z);\n\treturn vec3(m * p.xy, p.z);\n}\n\n//=======================================================================================\n// Scene\n//=======================================================================================\n\n/**\n * Construct the scene here. see sSceneRec.\n *\n * p:\ta point in world space\n */\n/*\nsSceneRec sdSceneNoLights(vec3 p) {\n    sSceneRec p1 = sSceneRec(sdPlane(p), MATERIAL_DEFAULT);\n\n    sSceneRec s1 = sSceneRec(sdSphere(p - vec3(0.8, 0.8, 2.8), 0.5), MATERIAL_1);\n    sSceneRec b1 = sSceneRec(sdBox(p - vec3(-1.1, 0.0, 3.0), vec3(0.2, 2.0, 0.2), 0.05),\n                             MATERIAL_2);\n\n    vec3 q = opRep(p, vec3(1.8, 0.0, 2.5));\n    sSceneRec cl = sSceneRec(\n        sdCappedCylinder(q, vec2(0.2, 2.5)),\n        MATERIAL_2\n    );\n\n    return opU(p1, opU(s1, b1));\n}\n*/\n\nsSceneRec sdSceneNoLights(vec3 p) {\n    sSceneRec p1 = sSceneRec(sdPlane(p), MATERIAL_DEFAULT);\n\n    mat4 b1t = rotateY(PI/4.0) * translate(vec3(1.0, 0.2, 3.3));\n    sSceneRec b1 = sSceneRec(sdBox((b1t*vec4(p, 1.0)).xyz, vec3(0.25), 0.03),\n                             MATERIAL_2);\n\n    mat4 p2t = rotateX(PI/2.0) * rotateY(PI/4.0);\n    sSceneRec p2 = sSceneRec(sdPlane((p2t*vec4(p, 1.0)).xyz), MATERIAL_DEFAULT);\n    \n    mat4 p3t = rotateX(PI/2.0) * rotateY(-PI/4.0);\n    sSceneRec p3 = sSceneRec(sdPlane((p3t*vec4(p, 1.0)).xyz), MATERIAL_DEFAULT);\n    \n    sSceneRec s1 = sSceneRec(sdSphere(p - vec3(-0.6, 0.5, 3.0), 0.5),\n                             MATERIAL_2);\n    \n    return opU(p3, opU(p2, opU(s1, opU(p1, b1))));\n}\n\n/**\n * Add visible light sources here.\n *\n * p:\ta point in world space\n */\nsSceneRec sdSceneLights(vec3 p) {\n    sSceneRec l1 = sSceneRec(sdSphere(p - gSphereLight0.center,\n                                      gSphereLight0.radius),\n                             MATERIAL_LIGHT_SPHERE);\n\n    return l1;\n}\n\nsSceneRec sdScene(vec3 p) {\n\treturn opU(sdSceneNoLights(p), sdSceneLights(p));\n}\n\n/**\n * Estimate the normal at surface point p using the gradient of scene SDF.\n *\n * p:\ta point in world space\n */\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)).d - sdScene(vec3(p.x - EPSILON, p.y, p.z)).d,\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)).d - sdScene(vec3(p.x, p.y - EPSILON, p.z)).d,\n        sdScene(vec3(p.x, p.y, p.z + EPSILON)).d - sdScene(vec3(p.x, p.y, p.z - EPSILON)).d\n    ));\n}\n\n//=======================================================================================\n// BSDFs\n//=======================================================================================\n\n/**\n * Schlick's fresnel approximation.\n *\n * specularColor: reflectance at normal incidence i.e. F0\n */\nvec3 fresnelSchlick(vec3 specularColor, float dotLH) {\n\tfloat fresnel = pow(1.0 - dotLH, 5.0);\n\treturn specularColor + (1.0 - specularColor) * fresnel;\n}\n\n/**\n * ref: three.js - bsdfs.glsl::F_Schlick\n */\nvec3 fresnelUnreal(vec3 specularColor, float dotLH) {\n\tfloat fresnel = exp2((-5.55473 * dotLH - 6.98316) * dotLH);\n\treturn specularColor + (1.0 - specularColor) * fresnel;\n}\n\n/**\n * GGX microfacet distribution. [Walter 07]\n */\nfloat distrGGX(float alpha, float dotNH) {\n    if (dotNH == 0.0) return 0.0;\n\tfloat a2 = pow2(alpha);\n\tfloat denom = pow2(dotNH) * (a2 - 1.0) + 1.0;\n\treturn a2 / (PI * pow2(denom));\n}\n\n/**\n * Smith (monodirectional) shadowing-masking approximation for GGX.\n */\nfloat smithG1_GGX(float alpha, float cosTheta) {\n    float a2 = pow2(alpha);\n    float cosTheta2 = pow2(cosTheta);\n    float tanTheta2 = abs(1.0 / cosTheta2 - 1.0);\n    if (isinf(tanTheta2)) return 0.0;\n    return 2.0f / (1.0f + sqrt(1.0 + a2 * tanTheta2));\n}\n\n/**\n * Smith shadowing-masking approximation for GGX.\n */\nfloat smithG_GGX(float alpha, float dotNL, float dotNV) {\n\treturn smithG1_GGX(alpha, dotNL) * smithG1_GGX(alpha, dotNV);\n}\n\n/**\n * ref: three.js - bsdfs.glsl::G_GGX_SmithCorrelated\n *\n * Note this height-correlated Smith term is combined with\n * the denominator of the microfacet BRDF to be simplified\n */\nfloat smithG_GGX_Correlated(float alpha, float dotNL, float dotNV) {\n\tfloat a2 = pow2(alpha);\n\tfloat gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));\n\tfloat gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\n/**\n * BRDF for microfacet model.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * viewDir:\t\tview direction\n * lightDir:\tlight direction\n */\nvec3 brdfSpecular(const in sMaterial mat, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    vec3 specularColor = mix(vec3(MIN_REFLECTIVITY), mat.baseColor, mat.metalness);\n\n    float alpha = max(0.01, pow2(mat.roughness));\t// prevent alpha being too small\n\n    vec3 halfDir = normalize(viewDir + lightDir);\n\tfloat dotNL = saturate(dot(normal, lightDir));\n\tfloat dotNV = saturate(dot(normal, viewDir));\n\tfloat dotNH = saturate(dot(normal, halfDir));\n\tfloat dotLH = saturate(dot(lightDir, halfDir));\n\n    //if (dotNV == 0.0 || dotNL == 0.0) return vec3(0.0);\n\n#if 0\n\tvec3  F = fresnelSchlick(specularColor, dotLH);\n\tfloat G = smithG_GGX(alpha, dotNL, dotNV);\n\tfloat D = distrGGX(alpha, dotNH);\n\n\treturn F * (G * D) / (4.0 * dotNL * dotNV);\n#else\n    vec3  F = fresnelUnreal(specularColor, dotLH);\n\tfloat G = smithG_GGX_Correlated(alpha, dotNL, dotNV);\n\tfloat D = distrGGX(alpha, dotNH);\n\n    return F * (G * D);\n#endif\n}\n\n/**\n * BRDF for Lambert diffuse model.\n *\n * mid:\t\t\tmaterial index\n */\nvec3 brdfDiffuse(const in sMaterial mat) {\n    vec3 diffuseColor = mat.baseColor * (1.0 - mat.metalness);\n\treturn diffuseColor / PI;\n}\n\n//=======================================================================================\n// Ray Marching\n//=======================================================================================\n\n/**\n * March a ray against the scene defined by sdScene.\n *\n * Return false if exceed the length limit of ray or the iteration limit,\n * otherwise true and intersection information is stored in hit.\n *\n * Set distMod to -1.0 if ray is marching from inside to outside.\n */\nbool rayMarch(const in sRay ray, out sHit hit, int maxSteps, float distMod) {\n    float t = ray.tMin;\n\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = ray.o + t * ray.dir;\n        sSceneRec rec = sdScene(p);\n        rec.d *= distMod;\n        if (rec.d < EPSILON) {\t// hit something\n            hit.p = p;\n            hit.t = t;\n            hit.mid = rec.mid;\n\t\t\treturn true;\n        }\n        t += rec.d;\t\t// march\n        if (t >= ray.tMax) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n//=======================================================================================\n// Lighting\n//=======================================================================================\n\n/**\n * Calculate the shadow factor of a surface point.\n * ref: https://iquilezles.org/articles/rmshadows\n *\n * p:\t\t\ta surface point in world space\n * lightDir:\tlight direction\n * normal:\t\tsurface normal\n * rayLength:\tlength of the shadow ray\n * k:\t\t\tlager k produces sharper shadows, penumbras are disabled when k is 0\n */\nfloat shadow(vec3 p, vec3 lightDir, vec3 normal, float rayLength, float k) {\n\tsRay ray;\n    ray.o = p;\n    ray.dir = lightDir;\n    ray.tMin = 0.01 / max(abs(dot(lightDir, normal)), 0.05);  // avoid self-shadowing\n    ray.tMax = rayLength;\n\n    float factor = 1.0;\n\n    // ray marching\n    float t = ray.tMin;\n    for (int i = 0; i < SHADOW_RAY_MAX_STEPS; i++) {\n        sSceneRec rec = sdSceneNoLights(ray.o + t * ray.dir);\n        factor = min(factor, k * rec.d / t);\n        if (rec.d < EPSILON) {\t// in shadow\n            return 0.0;\n        }\n        t += rec.d;\n        if (t >= ray.tMax) {\n            break;\n        }\n    }\n\n    return mix(1.0, factor, float(k > 0.0));\n}\n\n/**\n * Calculate the ambient occlusion factor of a surface point.\n * ref: http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n */\nfloat ambientOcclusion(vec3 p, vec3 normal) {\n\tfloat ao = 0.0;\n\n    for (float i = 0.0; i < AO_MAX_STEPS; i += 1.0) {\n        float l = hash11(i) * AO_MAX_RANGE;\n        vec3 v = sampleHemisphereCos(hammersley2d(uint(i), AO_MAX_STEPS));\n        v = tangentToWorld(v, normal);\n        ao += (l - max(sdScene(p + l * v).d, 0.0)) / AO_MAX_RANGE * AO_FALLOFF;\n    }\n\n    return saturate(1.0 - ao / AO_MAX_STEPS);\n}\n\n/**\n * Calculate the decay factor of a punctual light.\n * ref: three.js - bsdfs.glsl::punctualLightIntensityToIrradianceFactor\n */\nfloat punctualLightDecay(float dist, float cutoff, float decay, float r0) {\n\tif(decay > 0.0) {\n\t\tfloat distanceFalloff = r0 / max(pow(dist, decay), 0.01);\n\t\tfloat maxDistanceCutoffFactor = pow2(saturate(1.0 - pow4(dist / cutoff)));\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n\t}\n\treturn 1.0;\n}\n\n/**\n * Calculate the irradiance(E) of a directional light.\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n */\nvec3 dirLightIrradiance(vec3 p, vec3 normal, sDirLight light) {\n\tfloat dotNL = saturate(dot(normal, -light.dir));\n    float shadowFactor = shadow(p, -light.dir, normal, SHADOW_RAY_MAX_LENGTH, 8.0);\n    return shadowFactor * PI * dotNL * light.color;\n}\n\n/**\n * Calculate the irradiance(E) of a point light.\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n * lightDir:    output direction from p to light position\n */\nvec3 pointLightIrradiance(vec3 p, vec3 normal, sPointLight light,\n                          out vec3 lightDir) {\n    vec3 l = light.position - p;\n\tfloat dist = length(l);\n\tlightDir = l / dist;\n    float dotNL = saturate(dot(normal, lightDir));\n    vec3 lightColor = light.color * punctualLightDecay(dist, light.range, light.decay, 1.0);\n    float shadowFactor = shadow(p, lightDir, normal, min(dist, SHADOW_RAY_MAX_LENGTH), 16.0);\n\treturn shadowFactor * PI * dotNL * lightColor;\n}\n\n/**\n * Calculate the effective irradiance(E) of a spherical light.\n * This is only for diffuse surface based on \"vector irradiance\" method.\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n */\nvec3 sphereLightIrradianceDiffuse(vec3 p, vec3 normal, sSphereLight light) {\n    vec3 l = light.center - p;\n\tfloat dist = length(l);\n\tvec3 lightDir = l / dist;\n    \n    float dotNL = saturate(dot(normal, lightDir));\n    \n    float falloff = pow2(light.radius / dist);\n    vec3 lightColor = light.radiance * falloff;\n    \n    float shadowFactor = shadow(p, lightDir, normal,\n                                min(dist, SHADOW_RAY_MAX_LENGTH),\n                                16.0);\n\t\n    return shadowFactor * PI * dotNL * lightColor;\n}\n\n/**\n * Simulate the specular highlights caused by an area light\n * using the \"most representative point\" method.\n * (I'm not sure the implementation of the normalization factor\n *  is correct, pls refer to [Karis 13].)\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n * r:\t\t\tmirror reflection vector of the view vector\n * alpha:\t\talpha parameter for the GGX NDF\n *\n * t:\t\t\toutput direction from p to MRP\n * factor:\t\toutput normalization factor\n *\n * returns:\t\tirradiance arriving at p\n */\nvec3 sphereLightIrradianceSpecular(vec3 p, vec3 normal, vec3 r,\n                                   float alpha, sSphereLight light,\n                                   out vec3 t,\n               \t\t\t\t\t   out float factor) {\n    vec3 l = light.center - p;\n\tvec3 lightToR = dot(l, r) * r - l;\t// project l onto r\n    float dist1 = length(lightToR);\n    \n    float cosT;\t\t// cosine between the normal at MRP and -t\n    float dist;\t\t// distance from p to MRP\n    if (dist1 < light.radius) {\n    \t// r is actually hitting the sphere, MRP is the hit point\n        t = l + lightToR;\n        float len_t = length(t);\n        \n        float sinT = dist1 / light.radius;\n        cosT = sqrt( saturate(1.0 - sinT * sinT) );\n        dist = len_t - light.radius * cosT;\n        \n        t = t / len_t;\n    } else {\n        // r is missing the sphere\n        vec3 lightToRN = lightToR / dist1;\n    \tt = l + lightToRN * light.radius;\n        dist = length(t);\n   \t\tt = t / dist;\n        \n        cosT = saturate(dot(-t, lightToRN));\n    }\n    \n    // FIXME\n    cosT = max(cosT, 0.04);\n    \n    // convert radiance to irradiance (ref: PBR3 5.5.3)\n    float area = 4.0 * PI * pow2(light.radius);\n    vec3 irradiance = light.radiance * area * cosT / (dist * dist);\n    \n    // fake soft shadow\n    float shadowFactor = shadow(p, t, normal,\n                                min(dist, SHADOW_RAY_MAX_LENGTH),\n                                16.0);\n    irradiance = shadowFactor * irradiance;\n    \n    // normalization factor\n    float alphaPrime = saturate(alpha + light.radius / (2.0 * length(l)));\n    factor = pow2(alpha / alphaPrime);\n    \n    return irradiance * saturate(dot(normal, t));\n}\n\n/**\n * ref: com.unity.render-pipelines.core - CommonMaterial.hlsl\n */\nfloat geoNormalVariance(vec3 normal, float screenSpaceVariance) {\n    vec3 deltaU = dFdx(normal);\n    vec3 deltaV = dFdy(normal);\n\n    return screenSpaceVariance * (dot(deltaU, deltaU) + dot(deltaV, deltaV));\n}\n\n/**\n * ref: com.unity.render-pipelines.core - CommonMaterial.hlsl\n */\nfloat roughnessFiltering(float roughness, float variance, float threshold) {\n    float alpha = pow2(roughness);\n    float effectiveAlpha = sqrt(saturate(\n        pow2(alpha) + min(2.0 * variance, threshold * threshold)));\n\n    return sqrt(effectiveAlpha);\n}\n\n/**\n * Calculate the color of a surface point from some point of view.\n *\n * hp:\t\t\tsurface point to shade\n * viewDir:\t\tview direction i.e. -viewRay.dir\n */\nvec3 lit(sHit hp, vec3 viewDir) {\n    /* local illumination */\n\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 normal = getNormal(hp.p);\n    \n    sMaterial mat = gMaterials[hp.mid];\n    float var = geoNormalVariance(normal, 0.05);\n    mat.roughness = roughnessFiltering(gMaterials[hp.mid].roughness, var, 0.05);\n\n    //------------------------------------------------------------------------------------\n\n    vec3 irradiance = dirLightIrradiance(hp.p, normal, gDirLight0);\n\n    diffuse  += irradiance * brdfDiffuse(mat);\n    specular += irradiance * brdfSpecular(mat, normal, viewDir, -gDirLight0.dir);\n\n    //------------------------------------------------------------------------------------\n\n    vec3 pointLightDir;\n    //irradiance = pointLightIrradiance(hp.p, normal, gPointLight0, pointLightDir);\n\n    //diffuse  += irradiance * brdfDiffuse(hp.mid);\n    //specular += irradiance * brdfSpecular(hp.mid, normal, viewDir, pointLightDir);\n\n    //------------------------------------------------------------------------------------\n    \n    if (mat.metalness == 0.0) {\n    \tirradiance = sphereLightIrradianceDiffuse(hp.p, normal, gSphereLight0);\n    \tdiffuse += irradiance * brdfDiffuse(mat);\n    }\n    else {\n        vec3 r = reflect(-viewDir, normal), t;\n    \tfloat factor;\n        \n    \tirradiance = sphereLightIrradianceSpecular(hp.p, normal, r,\n                                                   pow2(mat.roughness),\n                                                   gSphereLight0, t, factor);\n    \tspecular += factor * brdfSpecular(mat, normal, viewDir, t) *\n        \t\t\tirradiance;\n    }\n\n    //------------------------------------------------------------------------------------\n\n    //float ao = ambientOcclusion(hp.p, normal);\n    float ao = 1.0;\t// do not apply to punctual light\n\n    return ao * diffuse + specular;\n}\n\n//=======================================================================================\n// Camera\n//=======================================================================================\n\n/**\n * Return a transform matrix that will transform a ray from view space to world space.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See cameraRay.\n */\nmat3 viewMatrix(vec3 eye, vec3 target, vec3 up) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Return the normalized direction in view space from the eye point to a single pixel.\n *\n * fov:\t\t\tvertical field of view in degrees\n * size: \t\tresolution of the output image\n * fragCoord: \tthe x,y coordinate of the pixel in the output image\n */\nvec3 cameraRay(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y / 2.0) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//=======================================================================================\n\nvoid updateScene() {\n    /*\n\tgSphereLight0.center.z = 1.0 + 4.0*sin(0.8*iTime);\n    gSphereLight0.center.y = 4.0 * gSphereLight0.radius +\n        \t\t\t\t\t 2.5 * gSphereLight0.radius * sin(3.0*iTime);\n\t*/\n    gSphereLight0.center.y = 1.2 + 0.8 * sin(0.8*iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 60.0;\n    vec3 eye = vec3(0.0, 1.0, 5.0);\n\n    updateScene();\n\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n\n    sRay viewRay;\n    viewRay.o = eye;\n    viewRay.tMax = VIEW_RAY_MAX_LENGTH;\n\n    vec3 finalColor;\n    for (int i = 1; i <= MSAA_COUNT; ++i) {\n        float x = mod(float(i) - 1.0, 4.0);\n        float y = mod(floor(float(i) / 4.0), 4.0);\n        vec2 jitter = hash21(float(i)) / 4.0;\n        jitter.x += x / 4.0;\n        jitter.y += y / 4.0;\n\n        viewRay.dir = viewToWorld * cameraRay(fov, iResolution.xy, fragCoord + jitter);\n\t\tvec3 col;\n    \tsHit hit;\n    \tif (rayMarch(viewRay, hit, VIEW_RAY_MAX_STEPS, 1.0)) {\n            if (hit.mid == MATERIAL_LIGHT_SPHERE) {\n                // directly visible emitters\n            \tcol = gSphereLight0.radiance;\n            } else {\n                col = lit(hit, -viewRay.dir);\n            }\n    \t}\n        finalColor = mix(finalColor, col, 1.0 / float(i));\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/** FXAA\n *  ref: https://www.shadertoy.com/view/ls3GWS\n */\n\n#define FXAA_SPAN_MAX\t\t8.0\n#define FXAA_REDUCE_MUL\t\t(1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN\t\t(1.0/128.0)\n#define FXAA_SUBPIX_SHIFT\t(1.0/4.0)\n\nvec3 fxaa(vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1.0 / iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec4 uv = vec4(uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\tvec3 col = fxaa(uv, iChannel0, rcpFrame);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}