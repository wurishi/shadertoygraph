{"ver":"0.1","info":{"id":"7lV3Wy","date":"1638288929","viewed":144,"name":"Euclidean triangle groups","username":"TotallyReal","description":"Use reflections of triangles to tile the plane, and color it according to the texture.\nSee also the hyperbolic version here :  https://www.shadertoy.com/view/NtyGW1  .","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tiling","trianglegroup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nA bit about triangle groups:\n\nStart with one triangle and take its reflections through each of its edges. Then for each reflection, \ntake its reflection through each of its edges (one of them will be the original triangle). Continue like\nthis until you cover the whole plane.\n\nIn general, the triangles that we get this way can intersect one another. To avoid messy images, if\ntwo such triangles intersect, we want them to be exactly the same. For example, if we look at triangle \nreflections around a single vertex, they all have the same angle near that vertex. Hence, this angle must\ndivide 2*PI for this overlap=identical condition, and unless the triangle is an isosceles triangle, the\nangle must divide PI. In other words all the angles should be of the form PI/N for some integer N.\n\nWe now have the three angles PI/L, PI/N and PI/M.\nIn the Euclidean geometry, the sum of the angles in a triangle is PI, so that 1/L + 1/M + 1/N = 1.\nThe three choices are then (2, 4, 4), (2, 3, 6) and (3, 3, 3)  (You can choose below which are to show).\nChange the SHOW_REFLECTIONS to \"true\" in order to see the triangles.\n\nOnce you have a single trianle defined by three lines of reflections, we can move each point outside the triangle\ninto it using a sequence of these reflections. If a point is not inside the triangle, then one of the lines\nseparates it from the triangle, so we take its reflection though that line (change the ONLY_TRIANGLE\nto true to see the 3 lines defining the triangle). A bit of math magic shows that each point will eventually \nfind its way into your original triangle, and no matter the order of your reflections, \nit will end up at the same place.\n\nFinally, add some texture to your triangle, and use the procedure above to spread it out to the whole plane.\n\nThe equation 1/L + 1/M + 1/N = 1 is true in the standard Euclidean geometry, but there are other geometries\nwhere the sum of the angles doesn't have to be pi. In particular, in the hyperbolic geometry the sum is less\nthan pi, which you can see here:\nhttps://www.shadertoy.com/view/NtyGW1\n\nand in the spherical geometric the sum is larger than pi.\n\n*/\n\n// Only see the triangle which is the fundamental\n// domain (from which we take the texture and reflect it).\nconst bool ONLY_TRIANGLE = false;\n\n// darken domains which need odd number of steps to get to the main fundamental domain.\nconst bool SHOW_REFLECTIONS = false;\n\n// ------------------------------ Fundamental domains ------------------------------\n\nconst int MAX_STEPS = 16;\n\nstruct Reflection {\n    vec2 point;\n    vec2 normal;\n};\n\n\n// uncomment one of these 3 options\n\n// group (2, 4, 4)\n/*const Reflection reflection1 = Reflection(vec2(0,0), vec2(0,1));\nconst Reflection reflection2 = Reflection(vec2(0,0), vec2(1,0));\nconst Reflection reflection3 = Reflection(vec2(1,1), vec2(-1,-1)/sqrt(2.));*/\n\n// group (2, 3, 6)\nconst Reflection reflection1 = Reflection(vec2(0,0), vec2(0,1));\nconst Reflection reflection2 = Reflection(vec2(0,0), vec2(1,0));\nconst Reflection reflection3 = Reflection(vec2(1,0), -vec2(sqrt(3.)/2.,0.5));\n\n// group (3, 3, 3)\n/*const Reflection reflection1 = Reflection(vec2(0,0), vec2(0,1));\nconst Reflection reflection2 = Reflection(vec2(0,0), vec2(sqrt(3.)/2.,-0.5));\nconst Reflection reflection3 = Reflection(vec2(1,0), -vec2(sqrt(3.)/2.,0.5));*/\n\nint reflectThrough(vec2 point, Reflection ref, out vec2 result){\n    vec2 v = ref.point - point;\n    result = point;\n    if (dot(v, ref.normal)<0.)\n        return 0;\n    result = ref.point - reflect(v, ref.normal);\n    return 1;\n}\n\n\nvec2 toFundamentalDomainTriangle(vec2 point, out int reflections){\n    reflections = 0;\n    int steps = 0;\n    while (steps<MAX_STEPS){\n        int extra = \n            reflectThrough(point, reflection1, point) +\n            reflectThrough(point, reflection2, point) +\n            reflectThrough(point, reflection3, point);\n        if (extra==0)\n            return point;\n        reflections += extra;\n        steps ++;            \n    }\n    return point;\n\n}\n\n// ------------------------------ main ------------------------------\n\nconst vec3 WHITE = vec3(1.);\nconst vec3 BLACK = vec3(0.);\n\nmat2 rotation(float angle){\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nmat2 shearing(float t){\n    return mat2(1., t, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 5.*(fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    if (ONLY_TRIANGLE){\n        // Use this part to see the triangle which is the fundamental\n        // domain (from which we take the texture and reflect it).\n        vec2 result;\n        fragColor = vec4(\n            float(reflectThrough(uv, reflection1, result)),\n            float(reflectThrough(uv, reflection2, result)),\n            float(reflectThrough(uv, reflection3, result)),\n            1.);\n        return;\n    }\n    \n    \n    // add some dynamics to move the whole tiling.\n    uv += 2.*vec2(cos(iTime/7.), sin(iTime/3.));\n    uv = rotation(iTime/4.)*uv;\n    \n    // Move point to the fundamental domain and count the number of reflections.\n    int reflections = 0;\n    vec2 v = toFundamentalDomainTriangle(uv, reflections);\n        \n    // add second dynamics to move the location in the texture from which we choose the pixels.\n    v += 2.*vec2(cos(iTime/4.), sin(-iTime/5.));\n    v *= (cos(iTime/10.)*0.2 + 0.6);\n    v = rotation(iTime/3.)*v;\n    \n    vec3 pixel = 1.2*texture(iChannel0, v).rgb;\n    \n    if (SHOW_REFLECTIONS){\n        reflections %= 2;\n        pixel *= (1.+float(reflections))/2.;\n    }\n    \n    fragColor = vec4(pixel,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}