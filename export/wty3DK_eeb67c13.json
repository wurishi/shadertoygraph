{"ver":"0.1","info":{"id":"wty3DK","date":"1579953205","viewed":204,"name":"[steb] raymarcher","username":"steb","description":"Simple raymarcher\nClick to move lighting","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SURFACE_DISTANCE = .0001;\n\nconst int MAX_STEPS = 500;\nconst int MAX_SHADOW_STEPS = 50;\n\nconst float MAX_DISTANCE = 50.;\nconst float MAX_REFLECT_DISTANCE = 5.;\nconst float MAX_SHADOW_DISTANCE = 15.;\n\nconst float FOV = 600.;\nconst vec2 NORMAL = vec2(0, 0.01);\n\nconst vec3 SUN_DIRECTION = normalize(vec3(0, -1, 1));\nconst vec3 AMBIENT_COL = vec3(0.08, 0.1, 0.14);\nconst float SHADOW_SOFTNESS = .25;\n\nconst float DEG_TO_RAD = 0.01745329251;\nconst vec3 CAMERA_ROTATION = vec3(-25. * DEG_TO_RAD, 35. * DEG_TO_RAD, -15. * DEG_TO_RAD);\nconst mat3 CAMERA_ROTATION_MATRIX = mat3(1, 0, 0,\n                                         0, cos(CAMERA_ROTATION.x), -sin(CAMERA_ROTATION.x),\n                                         0, sin(CAMERA_ROTATION.x), cos(CAMERA_ROTATION.x)) * \n    \t\t\t\t\t\t\t\tmat3(cos(CAMERA_ROTATION.y), 0, sin(CAMERA_ROTATION.y),\n                                        0, 1, 0,\n                                        -sin(CAMERA_ROTATION.y), 0, cos(CAMERA_ROTATION.y)) * \n    \t\t\t\t\t\t\t\tmat3(cos(CAMERA_ROTATION.z), -sin(CAMERA_ROTATION.z), 0,\n                                        sin(CAMERA_ROTATION.z), cos(CAMERA_ROTATION.z), 0,\n                                         0, 0, 1);\n\nfloat SDF_Plane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat SDF_Sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat SDF_Box(vec3 p, vec3 c, vec3 b)\n{\n    p -= c;\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat SDF_Torus(vec3 p, vec3 c, vec2 t)\n{\n    p -= c;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 getDist(vec3 p)\n{\n    float sphere1 = SDF_Sphere(p, vec3(0, 0, 0), 1.);\n    float sphere2 = SDF_Sphere(p, vec3(1.75, -0.5, .6), .5);\n    vec4 spheres = opU(vec4(sphere1, 1, 0, 0), vec4(sphere2, 0, 1, 0));\n    vec4 plane = vec4(SDF_Plane(p, vec4(0, 1, 0, 1.)), 1, 1, 1);\n    //vec4 box = vec4(SDF_Box(p, vec3(1,0,0.2), vec3(.8, .8, .8)), 1, 0., 1);\n    //vec4 torus = vec4(SDF_Torus(p, vec3(.2,-.6,2), vec2(0.6, .3)), vec3(0,0,1));\n    return opU(spheres,  plane);\n}\n\nvec4 rayMarch(vec3 rO, vec3 rD, float maxDistance)\n{   \n    float dist = 0.;\n    vec3 col;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 dS = getDist(rO + rD * dist);\n        dist += dS.x;\n        col = dS.yzw;\n        if (dS.x < SURFACE_DISTANCE || dist > MAX_DISTANCE) \n        {\n            break;\n        }\n    }\n    \n    return vec4(dist, col.rgb);\n}\n\nfloat shadows(vec3 rO, vec3 lD)\n{\n    float shadow = 1.;\n    float t = 0.;\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++)\n    {\n        float d = getDist(rO + lD*t).x;\n        shadow = min(shadow, 0.5 + 0.5 * d / (SHADOW_SOFTNESS * t));\n        if (shadow < 0. || t > MAX_SHADOW_DISTANCE) break;\n        t += d;\n    }\n    shadow = max(shadow, 0.);\n    return smoothstep(.5, 1., shadow);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(getDist(p - NORMAL.yxx).x, getDist(p - NORMAL.xyx).x, getDist(p - NORMAL.xxy).x));\n}\n\nvec3 shade(vec3 p, vec3 lightDir, vec3 rD, vec3 nrm, vec3 baseCol)\n{\n    vec3 col = vec3(0,0,0);\n    vec3 diff = vec3(max(0., dot(nrm, lightDir))) * baseCol;\n    float spec = pow(max(0., dot(-rD, reflect(lightDir, nrm))), 40.) * .6;\n    col = diff + spec;\n\n    col *= vec3(shadows(p - lightDir * 0.01, -lightDir));\n    col += AMBIENT_COL;\n    return col;\n}\n\nvec3 renderSky(vec3 rD)\n{\n    return vec3((1. - rD.y) / 3. + 0.25, (1. - rD.y) / 5. + 0.3, 0.8 - rD.y / 8.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec2 uv = fragCoord - iResolution.xy / vec2(2,2);\n    uv = uv - vec2(0.5, 0.5);\n    uv /= FOV;\n    \n    vec3 rO = vec3(4.8, 2., -5);\n    vec3 rD = CAMERA_ROTATION_MATRIX * normalize(vec3(uv.x, uv.y, 1));\n\n    vec4 dist = rayMarch(rO, rD, MAX_DISTANCE);\n    vec3 col = vec3(0,0,0);\n    \n    if (dist.x < MAX_DISTANCE)\n    {\n        vec3 p = rO + dist.x * rD;\n    \tvec3 nrm = getNormal(p);\n        vec3 lightDir = normalize(SUN_DIRECTION + m.xyz * -6.);\n        \n        col = shade(p, lightDir, rD, nrm, dist.yzw);\n        \n        vec3 ref = reflect(rD, nrm);\n        vec4 refDist = rayMarch(p + (ref * 0.01), ref, MAX_REFLECT_DISTANCE);\n\t\tvec3 reflectCol;\n        \n        if (refDist.x < MAX_REFLECT_DISTANCE)\n        {\n            vec3 refP = (p + ref * 0.01) + (ref * refDist.x);\n            vec3 refNrm = getNormal(refP);\n            reflectCol = shade(refP, lightDir, ref, refNrm, refDist.yzw);\n        }\n        else\n        {\n            //reflectCol = texture(iChannel0, ref).rgb;\n            reflectCol = renderSky(ref);\n        }\n        \n        col = mix(col, reflectCol, clamp(pow(1. - dot(rD, nrm), 4.), 0., 1.));\n    }\n    else \n    {\n    \t//fragColor = texture(iChannel0, rD);\n        col = renderSky(rD);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n/*float lightFeeler = rayMarch(p - lightDir * 0.01, -lightDir, MAX_DISTANCE);\n        \n        if (lightFeeler < MAX_DISTANCE)\n        {\n            col.rgb = AMBIENT_COL;\n        }*/","name":"Image","description":"","type":"image"}]}