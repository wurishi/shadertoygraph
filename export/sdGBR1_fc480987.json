{"ver":"0.1","info":{"id":"sdGBR1","date":"1657644586","viewed":92,"name":"Fork Basic Frac lahwran 535","username":"lahwran","description":"fork of a very straightforward rotate-and-fold fractal, to demonstrate what adding dimensions of variation to a simple space folding algorithm does","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"tltSWs","parentname":"Basic Fractal Zero"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Basic Fractal Zero by @paulofalcao\n\nconst int maxIterations=6;\n\n//generic rotation formula\nmat2 rot(float a){\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n#define VIB_LEVEL 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//normalize stuff\n    vec2 R=iResolution.xy,uv=(fragCoord-0.5*R)/R.x;\n    \n\t//global zoom\n\tif (VIB_LEVEL >= 1) { uv*=sin(iTime)*0.5+1.5; }\n    \n\t//shift, mirror, rotate and scale 6 times...\n\tfor(int i=0;i<maxIterations;i++){\n        uv*=2.1;          //<-Scale\n        if (VIB_LEVEL >= 4) { uv.x*=1.0+0.1*sin(iTime*2.*float(i)); } //<- animated scale x\n        if (VIB_LEVEL >= 3) { uv.y*=1.0+0.1*sin(iTime*3.*float(i)); } //<- animated scale y\n        uv*=rot(iTime/float(i+1));   //<-Rotate\n\t\tuv=abs(uv);       //<-Mirror\n        uv-=0.5;           //<-Shift\n        if (VIB_LEVEL >= 2) { uv -= 0.1*sin(iTime*0.1*float(i)); }           //<-animated Shift\n\t}\n\n\t//draw a circle\n\tfragColor=vec4(length(uv)<0.4);\n}","name":"Image","description":"","type":"image"}]}