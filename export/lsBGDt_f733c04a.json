{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tI wanted to make it as exotic and colorful as possible \n\twithout ruining the framerate too much. \n\n\tI'm not happy with the illumination but anything \n\tbetter hits the performance too hard.\n\n\tPause the shader and rotate it around with the mouse ;)\n\n\tSoundtrack: https://www.youtube.com/watch?v=5mDwVSfY-EE\n\n*/\n\n\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p){return texture(iChannel0,vec2(p*float(1.0/256.0),.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p*vec2(1.0/256.0));}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy*vec2(1.0/256.0) + noise(sprev).yz*21.421),texture(iChannel0,p.xy*vec2(1.0/256.0) + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nconst float toffs = -154.0;\nfloat t;\n\n//density function\nfloat density(vec3 p)\n{\n\tvec4 d = noise(p*.5)*noise(p.xz*.044)*noise(p.xy*.26)*noise(p.yz*.21);\n\tfloat fd = dot(d,vec4(1.4));\n\tfd = fd*fd*fd*fd*fd;\n\t\n\treturn max(.0,fd);\n}\n\n//background with stars\nvec3 background(vec3 d, vec3 p)\n{\n\tvec4 n = noise(d*0.45*iResolution.y+p*.05);\n\tfloat sun = pow(dot(d,normalize(vec3(1.0)))*.5+.5,64.0);;\n\tfloat den = abs(d.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n\treturn vec3(pow(n.x+n.y*.1+den,22.0))*.3+ mix(vec3(.1,.15,.2)*.25,vec3(1.2,.9,.5),sun);\n}\n\n//smooth version of the background - used for ambient lighting\nvec3 background2(vec3 d)\n{\n\tfloat sun = pow(dot(d,normalize(vec3(1.0)))*.5+.5,16.0)*.7;;\n\treturn mix(vec3(.1,.15,.2),vec3(1.2,.9,.5),sun);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime + noise(fragCoord.xy).y/(24.0-24.0/(iTime+1.0)) + toffs;\n    \n     vec2 uv = fragCoord.xy / iResolution.yy -vec2(.9,.5);\n\tvec2 m = iMouse.xy*8.0/ iResolution.yy;\n\t//rotation matrix for the camera\n\tmat3 rotmat = rotate_y((t-toffs)*.07+m.x)*rotate_x((t-toffs)*.031+m.y);\n\t//p is ray position\n\tvec3 p = vec3(.0,.0,-30.0); p*=rotmat;\n\tp += vec3(sin(t),cos(t),sin(t*.25)*29.0+t*7.0-22.0-4.0/((t-toffs)*.01+0.01));\n\t//d is ray direction\n\tvec3 d = normalize(vec3(uv*(sin(t*.17)*.2+0.8),1.0-length(uv)*.2));\n\td*=rotmat;\n\tp+=d*noise(fragCoord.xy).x*.9;\n\t\n\t//some accumulators\n\tfloat a = .0;\n\tfloat ai = .0;\n\tvec3 color = vec3(.0);\n\t\n\t//raycast 60 steps\n\tfor (int i=0; i<60; i++)\n\t{\n\t\t//move forward\n\t\tp+=d*.9;\n\t\t//space distort\n\t\tvec3 n = noise(p.xz*.25+vec2(t*.1)).xyz*12.0*noise(p.zy*.1+vec2(t*.1)).xyz;\n\n\t\tfloat de = density(p+n);\n\t\ta += de; // a is alpha, as the ray traverses the density function the\n\t\t//pixel is more and more opaque\n\t\ta = min(1.0,a); //a > 1.0 makes no sence and produces bugs\n\t\tvec4 c2 = noise(p.yz*.03).xyzw;\n\t\tvec3 c = c2.xyz*1.7;\n\t\t\n\t\t//lame illumiation\n\t\tfloat occ = min((de-density(p+vec3(0.7+n))),1.0);\n\t\tocc = min(occ,(de-density(p+vec3(3.7)+n)));\n\t\tocc = min(occ,(de-density(p+vec3(5.7)+n)));\n\t\t\n\t\tcolor += max(.0,occ)*(1.0-a)*c;\n\t\tif (a>1.0) break; //traversing beyond this point makes\n\t\t//no sense because it's not visible anymore, so break\n\t}\n\n\t//post processing + blending\n\t\n\tcolor += background2(d)*.15;\n\tcolor = mix(min(vec3(1.0),background(d,p)),color,a);\n\t\n\tcolor +=noise(uv).xyz*.08;\n\tcolor -= length(uv)*.12;\n\tcolor = max(vec3(.0),color);\n\tcolor  = mix(color,vec3(length(color)),length(color)*1.7-.4);\n\tcolor  = pow(color,vec3(.6));\n\t\n\tcolor *= 1.0+1.0/(t-toffs+.01);\n\t\n\tfragColor = vec4(color,1.0);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBGDt","date":"1395007823","viewed":2335,"name":"Nebula Clouds","username":"mu6k","description":"Pause the shader and rotate it around with the mouse ;)","likes":38,"published":1,"flags":0,"usePreview":1,"tags":["noise","volume","space","stars"],"hasliked":0,"parentid":"","parentname":""}}