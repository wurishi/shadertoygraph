{"ver":"0.1","info":{"id":"wdGSDd","date":"1575320207","viewed":295,"name":"Ripple Sheet","username":"matan","description":"Very basic attempt at making a ripple-like effect with ray tracing.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ripples"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define M_PI 3.1415926535897932384626433832795\n\nfloat kDiffuse = 0.8;\nfloat kAmbient = 0.4;\n\nvec3 kBackgroundColor = vec3(0.7, 0.75, 0.7);\n\nvec3 kLightSource = vec3(-5.0, 10.0, -5.0);\n\nfloat kInfinity = 1000000.0;\n\n// TODO: for some reason, passing around Ray (instead of direction/source directly)\n// causes the shader not to work on my android\n/* struct Ray {\n    vec3 direction;\n    vec3 source;\n}; */\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\n// 23 fps\n//const int kResolution = 50;\n//const float kSphereRadius = 0.02;\n//const int kLookRange = 13;\n\n// 55 fps\n    \nconst int kResolution = 30;\nconst float kSphereRadius = 0.05;\nconst int kLookRange = 8;\n\nconst float kRippleLength = 2.0 * M_PI / 8.0;\n\nstruct Ripple {\n    vec2 center;\n    float height;  \n};\n\nRipple getRippleForIndex(in int ripple_i) {\n    float[4] heights;\n    heights[0] = 0.22;\n    heights[1] = -0.1;\n    heights[2] = 0.2;\n    heights[3] = -0.2;\n    ripple_i = ripple_i % 8;\n    Ripple ripple;\n    \n    if (ripple_i <= 1) {\n        ripple.center = vec2(0.0, 0.0);\n    } else if (ripple_i <= 3) {\n        ripple.center = vec2(0.5, 0.0);\n    } else if (ripple_i <= 5) {\n        ripple.center = vec2(-0.5, 0.5);\n    } else if (ripple_i <= 7) {\n        ripple.center = vec2(0.5, 0.5);\n    }\n    if (ripple_i % 2 == 0) {\n    \tripple.height = heights[ripple_i / 2];\n    } else {\n        ripple.height = 0.0;\n    }\n    return ripple;\n}\n\nRipple getRipple() {\n    // Interpolate between the two ripples with a sigmoid function to make transitions smooth\n\tfloat ripple_f = iTime / kRippleLength;\n    int ripple_i = int(ripple_f + 0.5);\n    float d = ripple_f - float(ripple_i);\n    Ripple r1 = getRippleForIndex(ripple_i - 1);\n    Ripple r2 = getRippleForIndex(ripple_i);\n    float k = 10.0;\n    float s = 1.0 / (1.0 + exp(-k * d));\n    Ripple ripple;\n    ripple.center = r1.center * (1.0-s) + r2.center * s;\n    ripple.height = r1.height * (1.0-s) + r2.height * s;\n    \n    return ripple;\n}      \n\n// Get the height at (u,v) for the current ripple\nfloat getHeightForRipple(in Ripple ripple, in float u, in float v) {\n    float d = length(vec2(u, v) - ripple.center);\n    float y = ripple.height * cos(3.0 * d - 8.0 * iTime) - ripple.height;\n    // make the ripple weaker as it goes away from the ripple center\n    y /= (1.0 + d * 4.0);\n    return y;\n}\n\nSphere getSphere(in int i, in int j) {\n    \n    Ripple ripple = getRipple();\n    float t = iTime;\n    \n    float u = (float(i) / float(kResolution)) * 2.0 - 1.0;\n    float v = (float(j) / float(kResolution)) * 2.0 - 1.0;\n\n    // baseline waves\n    float y = 0.02 * sin(v * M_PI * 2.0 + 5.0 * iTime) + 0.02 * sin(u * M_PI * 2.0 + 5.0 * iTime);\n    y += getHeightForRipple(ripple, u, v);\n    \n    Sphere sphere;\n    sphere.center = vec3(u, y, v);\n \tsphere.radius = kSphereRadius;\n    sphere.color = vec3(0.5 + 2.0*y + 0.1*u, 0.5 + 2.0*y + 0.1*v, 0.7 + 0.15 * u + 0.15 * v + 0.6 * y);\n    return sphere;\n}\n    \n\nvoid traceRayThroughSphere(\n    in vec3 source, in vec3 direction, in Sphere sphere, out float hit_t) {\n    \n\thit_t = kInfinity;  \n\n    vec3 v = source - sphere.center;\n\n    float a = 1.0;\n    float b = 2.0*dot(v, direction);\n    float c = dot(v, v) - sphere.radius * sphere.radius;\n\n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0) {\n        float t1 = (-b + sqrt(det)) / (2.0 * a);\n        float t2 = (-b - sqrt(det)) / (2.0 * a);            \n        if (t1 > 0.0) {\n            hit_t = t1;\n        }\n        if (t2 > 0.0) {\n            hit_t = min(hit_t, t2);\n        }\n    }    \n}\n\n\nvoid traceRay(in vec3 source, in vec3 direction, out float mint, out vec3 hit_p, out vec3 over_p, out vec3 norm, out vec3 color, out bool is_hit) {\n    mint = 99999.0;\n    \n    // The following is kind of hacky code to make collision checking more efficient\n    // It checks collision of the ray with the y=0 plane and then only looks at spheres\n    // with (u,v) indices around that point.\n    // TODO: make more precise, taking into account current viewpoint and max/min height of\n    // spheres.\n    float plane_t = -source.y / direction.y;\n    vec3 plane_hit = source + direction * plane_t;\n\n    int hit_i = int((plane_hit.x + 1.0) * 0.5 * float(kResolution));\n    int hit_j = int((plane_hit.z + 1.0) * 0.5 * float(kResolution));\n    \n    int start_i = clamp(hit_i - kLookRange, 0, kResolution - 1);\n    int end_i = clamp(hit_i + kLookRange, 0, kResolution - 1);\n    int start_j = clamp(hit_j - kLookRange, 0, kResolution - 1);\n    int end_j = clamp(hit_j + kLookRange, 0, kResolution - 1);\n    \n    for (int sphere_i = start_i; sphere_i <= end_i; ++sphere_i) {\n        for (int sphere_j = start_j; sphere_j <= end_j; ++sphere_j) { \n            Sphere sphere = getSphere(sphere_i, sphere_j);\n            float cur_t;\n            traceRayThroughSphere(source, direction, sphere, cur_t);\n            if (cur_t < mint) {\n                mint = cur_t;\n                hit_p = cur_t * direction + source;\n                norm = normalize(hit_p - sphere.center);\n                color = sphere.color;\n            }\n        }\n    }\n    \n    vec3 col = kBackgroundColor;\n\n    is_hit = false;\n    \n    if (mint < 99998.0) {\n        vec3 light_v = normalize(kLightSource - hit_p);\n        vec3 light_reflect = light_v - 2.0 * norm * dot(light_v, norm);\n        \n\n        float cos_alpha = dot(norm, light_v);   \n        if (cos_alpha < 0.0) cos_alpha = 0.0;\n\n        col = kAmbient * color + kDiffuse * color * cos_alpha;\n        \n        is_hit = true;\n    }\n    \n    color = col;\n    over_p = hit_p + norm * 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = gl_FragCoord.xy / iResolution.xy;  \n\n    \n    float camera_dist = 7.0;\n    float camera_height = 4.0;\n    vec3 camera_p = vec3(sin(0.1*iTime) * camera_dist, camera_height, cos(0.1*iTime) * camera_dist);\n    \n    vec3 camera_look_at = vec3(0.0, 0.0, 0.0);\n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = normalize(camera_look_at - camera_p);\n    vec3 camera_right = cross(camera_forward, camera_up);\n    \n    float width = 2.0;\n    float height = width / iResolution.x * iResolution.y;  // 1.125\n    \n    vec3 screen_p = camera_forward * 5.0 + camera_p;\n    screen_p += (-width*0.5 + (p.x * width)) * camera_right;\n    screen_p += (-height*0.5 + p.y * height) * camera_up;\n    \n    vec3 d = normalize(screen_p - camera_p);\n\n    float mint = 99999.0;\n    vec3 hit_p;\n    vec3 over_p;\n    vec3 norm;\n    vec3 color;\n    bool is_hit;\n    traceRay(camera_p, d, mint, hit_p, over_p, norm, color, is_hit);\n    \n    fragColor = vec4(color,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}