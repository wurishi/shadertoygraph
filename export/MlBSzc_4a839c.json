{"ver":"0.1","info":{"id":"MlBSzc","date":"1445384428","viewed":238,"name":"[CIS565 2015F] GLSL Ray Marching","username":"bblader627","description":"https://github.com/bcrusco/Project5-GLSL-Ray-Marcher\n\nAcknowledgements:\n* graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf\n* iquilezles.org/articles/terrainmarching/terrainmarching.htm\n* https://www.shadertoy.com/view/XsXXWS","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define EPSILON 0.01\n#define MAX_STEPS 500\n#define MAX_DISTANCE 100.0\n#define DISPLACEMENT_FACTOR 4.0\n#define SHADOW_SCALE 25.0\n\n// Defined propertitres\n#define NAIVE\n#define LAMBERT_COLOR\n#define SOFT_SHADOW\n//#define STEP_COUNT_COLOR\n//#define DISTANCE_COLOR\n\n// Distance estimates for different objects\nfloat sphereDistance(vec3 vector, float radius) {\n\treturn length(vector) - radius;\n}\n\nfloat planeDistance(vec3 point, float y) {\n\treturn point.y - y;\n}\n\nfloat boxDistance(vec3 point, vec3 bvec) {\n\tvec3 distance = abs(point) - bvec;\n    return min(max(distance.x, max(distance.y, distance.z)), 0.0) + length(max(distance, 0.0));\n}\n\nfloat roundedBoxDistance(vec3 point) {\n\treturn length(max(abs(point) - 1.0, 0.0)) - 0.1;\n}\n\nfloat torusDistance(vec3 point, float minorRadius, float majorRadius) {\n\treturn length(vec2(length(point.xz) - minorRadius, point.y)) - majorRadius;\n}\n\n// Distance estimator operations\nfloat unionDistance(float distance1, float distance2) {\n\treturn min(distance1, distance2);\n}\n\nfloat intersectionDistance(float distance1, float distance2) {\n\treturn max(distance1, distance2);\n}\n\nfloat subtractionDistance(float distance1, float distance2) {\n\treturn max(distance1, -distance2);\n}\n\nfloat displacementDistance(vec3 point) {\n\treturn sin(DISPLACEMENT_FACTOR * point.x) * sin(DISPLACEMENT_FACTOR * point.y)\n        * sin(DISPLACEMENT_FACTOR * point.z);\n}\n\nfloat blendDistance(float a, float b, float blendRadius) {\n\tfloat c = 1.0 * (0.5 + (b - a) * (0.5 / blendRadius));\n    return (c * a + (1.0 - c) * b) - blendRadius * c * (1.0 - c);\n}\n\nvec3 transform(vec3 point, vec3 t, vec3 rot_axis, float angle, vec3 s) {\n    // translation\n\tmat4 translation = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        -t.x, -t.y, -t.z, 1.0);\n\n    //rotation matrix\n    rot_axis = normalize(rot_axis);\n    float sin = sin(radians(-angle));\n    float cos = cos(radians(-angle));\n\n   mat4 rotation = mat4(\n       (1.0 - cos) * rot_axis.x * rot_axis.x + cos, (1.0 - cos) * rot_axis.x * rot_axis.y - rot_axis.z * sin, (1.0 - cos) * rot_axis.z * rot_axis.x + rot_axis.y * sin, 0.0,\n       (1.0 - cos) * rot_axis.x * rot_axis.y + rot_axis.z * sin, (1.0 - cos) * rot_axis.y * rot_axis.y + cos, (1.0 - cos) * rot_axis.y * rot_axis.z - rot_axis.x * sin, 0.0,\n       (1.0 - cos) * rot_axis.z * rot_axis.x - rot_axis.y * sin, (1.0 - cos) * rot_axis.y * rot_axis.z + rot_axis.x * sin, (1.0 - cos) * rot_axis.z * rot_axis.z + cos, 0.0,\n       0.0, 0.0, 0.0, 1.0);\n\n    //scale matrix\n    mat4 scale = mat4(\n        1.0 / s.x, 0.0, 0.0, 0.0,\n        0.0, 1.0 / s.y, 0.0, 0.0,\n        0.0, 0.0, 1.0 / s.s, 0.0,\n        0.0, 0.0, 0.0, 1.0);\n\n    vec4 new_point = point.xyzz;\n    new_point.w = 1.0;\n    new_point = scale * rotation * translation * new_point;\n    return new_point.xyz;\n}\n\n// Mandelbulb fractal estimator\n// https://www.shadertoy.com/view/XsXXWS\nfloat mandelbulbDistance(vec3 point) {\n\tfloat scale = 1.0; // scale the surface brightness by this value\n    float power = 8.0;\n    float derivative = 1.0;\n    float internalBoundingRadius = 0.72;\n    vec3 temp_point = point;\n\n    // Use a bouncing sphere to speedup the distant ray marching\n    float externalBoundingRadius = 1.2;\n\tfloat r = length(point) - externalBoundingRadius;\n\tif (r > 1.0) {\n    \treturn r;\n    }\n\n    // Darker the deeper we go\n\tfor (int i = 0; i < 10; i++) {\n\t\tscale *= 0.725;\n\t\tfloat r = length(temp_point);\n\n\t\tif (r > 2.0) {\n\t\t\t// The point escaped, remap the scale for more brightness and return\n\t\t\tscale = min((scale + 0.075) * 4.1, 0.0);\n\t\t\treturn min(length(point) - internalBoundingRadius, 0.5 * log(r) * r / derivative);\n\t\t} else {\n\t\t\t// Convert to polar coordinates and then rotate by the power\n\t\t\tfloat theta = acos(temp_point.z / r) * power;\n\t\t\tfloat phi   = atan(temp_point.y, temp_point.x) * power;\n\t\t\tfloat sinTheta = sin(theta);\n\n\t\t\tderivative = pow(r, power - 1.0) * power * derivative + 1.0;\n\n\t\t\t// Convert back to Cartesian coordinates and offset by original point\n\t\t\ttemp_point = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta)) * pow(r, power) + point;\n\t\t}\n\t}\n\n\treturn EPSILON;\n}\n\n// Height-mapped terrain estimator\nfloat terrainDistance(vec3 point, float height, float length) {\n\treturn point.y - height * sin(length * point.x) * cos(point.z);\n}\n\n// Scene creation\nfloat map(vec3 point) {\n    float distance = 0.0;\n\n    // add a sphere\n    vec3 temp_point = transform(point, vec3(-1.5, 0.0, 0.0), vec3(1.0), 0.0, vec3(1.5));\n    float sphere = sphereDistance(temp_point - vec3(1.0, 0.0, 0.0), 0.5);\n\n    // add a plane\n    float plane = planeDistance(point, -2.0);\n    distance = unionDistance(sphere, plane);\n\n    // add a torus\n    temp_point = transform(point, vec3(2.0, -0.5, 0.0), vec3(1.0), 0.0, vec3(0.3));\n    float torus = torusDistance(temp_point, 2.0, 1.0);\n    distance = unionDistance(distance, torus);\n\n    // add rounded box\n    temp_point = transform(point, vec3(-2.0, 0.5, 0.0), vec3(0.0, 1.0, 0.0), 45.0, vec3(0.5));\n    float roundedBox = roundedBoxDistance(temp_point);\n    distance = unionDistance(distance, roundedBox);\n\n    return distance;\n}\n\n// Soft shadow effect\nfloat calculateSoftShadow(vec3 point, vec3 lightPosition) {\n\tfloat t = 2.0;\n    float minT = 2.0;\n    vec3 ro = point;\n    vec3 rd = normalize(lightPosition - point);\n    float maxT = (lightPosition.x - ro.x) / rd.x;\n    float shadowColor = 1.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n        point = ro + rd * t;\n\n        float distance = map(point);\n\n        if(distance < EPSILON) {\n        \treturn 0.0;\n        }\n\n        t += distance;\n        shadowColor = min(shadowColor, SHADOW_SCALE * (distance / t));\n\n        if(t > maxT) {\n        \treturn clamp(shadowColor, 0.0, 1.0);\n        }\n    }\n\n    return clamp(shadowColor, 0.0, 1.0);\n}\n\nvec3 calculateNormal(in vec3 point) {\n\tvec3 epsilon = vec3(EPSILON, 0.0, 0.0);\n    vec3 normal = vec3(\n        map(point + epsilon.xyy) - map(point - epsilon.xyy),\n        map(point + epsilon.yxy) - map(point - epsilon.yxy),\n        map(point + epsilon.yyx) - map(point - epsilon.yyx));\n    return normalize(normal);\n}\n\n// Lambert color calculation\nvec3 calculateLambertColor(vec3 point, vec3 ro) {\n\tvec3 lightPosition = vec3(6.0, 5.0, 0.0);\n    vec3 lightColor = vec3(0.8);\n    vec3 lightVector = normalize(lightPosition - point);\n\n    // calculate the normal\n    vec3 normal = calculateNormal(point);\n\n    // also require naive right?\n    #ifdef SOFT_SHADOW\n    \tfloat shadowColor = calculateSoftShadow(point, lightPosition);\n    \treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightColor * (shadowColor) + 0.05;\n    #else\n    \treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightColor + 0.01;\n\t#endif\n}\n\n// Step count color\nvec3 calculateStepCountColor(vec2 steps) {\n\tfloat t = (steps.y - steps.x) / steps.y;\n    return vec3(1.0 - t, t, 0.0);\n}\n\n// Calls the different types of color calculations\nvec3 calculateColor(vec3 point, vec2 distance, vec3 ro, vec2 steps) {\n    #ifdef LAMBERT_COLOR\n\t\treturn calculateLambertColor(point, ro);\n    #endif\n\n    // Debug colors\n    #ifdef DISTANCE_COLOR\n    \treturn vec3(abs((distance.y - distance.x) / distance.y));\n    #endif\n\n    #ifdef STEP_COUNT_COLOR\n    \treturn calculateStepCountColor(steps);\n    #endif\n\n    return vec3(0.0);\n}\n\nvec3 naiveRayMarch(in vec3 ro, in vec3 rd) {\n\tvec3 point; //The point on the ray\n\n    float i = 0.0;\n    for(float t = 0.0; t < MAX_DISTANCE; t += 0.01) {\n        i++;\n    \tpoint = ro + rd * t;\n\n        // distance estimator goes here\n        float distance = map(point);\n\n        if(distance < EPSILON) {\n        \t// if valid distance return color calculation\n            return calculateColor(point, vec2(t, MAX_DISTANCE), ro, vec2(i, MAX_STEPS));\n        }\n    }\n\n    return vec3(0.0);\n}\n\n// Spherical trace\nvec3 sphericalRayMarch(in vec3 ro, in vec3 rd) {\n    float minStep = 0.01;\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 point = ro + rd * t;\n        float distance = map(point);\n\n        if(distance <= EPSILON) {\n        \treturn calculateColor(point, vec2(t, MAX_DISTANCE), ro, vec2(float(i), MAX_STEPS));\n        }\n\n        if(distance > 0.0) {\n        \tt += max(distance, minStep);\n        }\n\n        if(t >= MAX_DISTANCE) {\n        \tbreak;\n        }\n    }\n\n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    #ifdef NAIVE\n    \treturn naiveRayMarch(ro, rd);\n    #else\n    \treturn sphericalRayMarch(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}