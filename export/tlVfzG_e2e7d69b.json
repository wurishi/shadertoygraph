{"ver":"0.1","info":{"id":"tlVfzG","date":"1614615584","viewed":151,"name":"Outline Shader MB","username":"MarvelousBilly","description":"The outline part needs some work but its good enough","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fov 400 //field of view \n\nvec3 cam = vec3(0.,3.,0.); //camera position \n\nbool outlineOnOff = true;\nfloat outlineSize = 0.3; //not a constant size, but the amount of units wide the outline is\nvec3 outlineColor = vec3(0.847,0.043,0.957);\n\nconst float RenderDistance = 400.; //how far out objects will render\nconst float MinDist = 0.0005; //how close a ray has to be to be considered colliding\nvec2 res;\n\nfloat sdfSphere(vec3 coord, vec3 center, float radius){ \n    return distance(coord,center) - radius; \n} //get the distance to a sphere\n\nint findIndexShortestSphere(vec3 p){\n    float sphereDists = sdfSphere(p,spheres[0].position,spheres[0].radius);\n    int minS = 0;\n    spheres[0].dist = sphereDists;\n    for(int i = 1; i < spheres.length(); i++){\n        if(i == spheres.length()){\n        \tbreak;   \n        }\n        float iSphereSdf = sdfSphere(p,spheres[i].position,spheres[i].radius);\n        sphereDists = min(sphereDists,iSphereSdf);\n        spheres[i].dist = iSphereSdf;\n        if(sphereDists == iSphereSdf){\n            minS = i;\n        }\n    }\n    return minS;\n}\n\nmapResult map(vec3 p){\n    mapResult m;\n    int minS = findIndexShortestSphere(p);\n    m.Md = spheres[minS].dist;\n    m.minS = minS;\n    return m;\n} //finds all distances to all objects from point p and returns the smallest one\n\nraymarchResult raymarch(vec3 direction, vec3 camera, float maxD, float outline){ //ray from camera to direction (extended into infinity)\n    direction = normalize(direction);\n    \n    raymarchResult res;\n    res.type = 0.;\n    res.position = vec3(0.);\n    \n    float minH = 999.;\n    float setI = (outline == 2. ? outlineSize + 1. : 0.3);\n    \n    for(float i = setI; i < maxD;){ //i = length of ray\n        vec3 p = camera + i * direction;\n    \tmapResult hMap = map(p); //smallest distance from all objects to point\n        float h = hMap.Md;\n        if(h > minH && minH > MinDist && minH < MinDist + outlineSize && outline != 0.){ //if distance increases from smallest distance\n            res.position = p;\n            res.type = 2.;\n            return(res);\n        }\n        minH = h;\n        \n        \n    \tif(h < MinDist){\n            res.position = p;\n            res.type = 1.;\n\t\t\treturn(res); //successfully hit something at point \"point\"\n        }\n        i += h;\n    }\n\n    return(res);\n} //travel along a ray taking steps only as large as the map function above returns\n\n\nfloat softshadow(vec3 lig, vec3 cam, float k){\n    float l = distance(cam,lig);\n    vec3 dir = normalize(lig-cam);\n\n    float res = 1.0;\n    float ph = 1e20;\n    for(float i = 0.9; i < l;){\n        vec3 p = cam + dir * i;\n        float h = map(p).Md;\n        if(h < MinDist){\n            return 0.0;\n        }\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0.0, i - y));\n        ph = h;\n        i += h;\n    }\n    return res;\n}\n\nvec3 objectMapMaterial(vec3 p, vec3 v){\n    float b = 0.;\n    for(int i = 0; i < lights.length(); i++){\n        b += softshadow(lights[i].position, p, 8.);\n    }\n    b /= float(lights.length());\n    \n    mapResult M = map(p);\n    float m = M.Md; //min dist from point p  \n    \n    return m > 50.0 ? vec3(0.)\n         : m == spheres[M.minS].dist ? spheres[M.minS].material*b\n         : vec3(1.,0.,0.);\n} //find the material of the object at point p. This includes the skybox, any textures, and the color\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\nvoid setupObjects(){\n    res = (iResolution.xy / 3.) + vec2(3.,0.);\n    \n    lights[0].position = vec3(-25.,50.,0.); //big chonky\n    lights[1].position = vec3(-20.,50.,0.);\n    lights[2].position = vec3(-15.,50.,0.);\n    lights[3].position = vec3(-10.,50.,0.);\n    lights[4].position = vec3(-05.,50.,0.);\n    lights[5].position = vec3( 00.,50.,0.);\n    lights[6].position = vec3( 05.,50.,0.);\n    lights[7].position = vec3( 10.,50.,0.);\n    lights[8].position = vec3( 15.,50.,0.);\n    lights[9].position = vec3( 20.,50.,0.);\n    lights[10].position = vec3(25.,50.,0.);\n\n\n\n    spheres[0].position = vec3(1.+sin(iTime)*10.,3.,10.);\n    spheres[0].radius = 2.; //sphere 1 radius\n    spheres[0].material = vec3(0.8,1.0,0.0);\n    spheres[0].reflectiveness = 1.0;\n    \n    spheres[1].position = vec3(10.,8.,1.+cos(iTime)*10.);\n    spheres[1].radius = 2.; //sphere 1 radius\n    spheres[1].material = vec3(0.0,1.0,1.0);\n    spheres[1].reflectiveness = 0.0;\n    \n} //place all objects at points defined and give them values\n\n\nvec3 render(vec3 cam, vec3 dir, vec2 fragCoord){\n    vec3 col;\n    vec2 uv = fragCoord-iResolution.xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n    \n    cam += vec3(texelFetch(iChannel2, ivec2(res), 0));\n    float o = (outlineOnOff == true ? 1. : outlineOnOff == false ? 0. : 3.);\n    raymarchResult rmRes = raymarch(dir, cam, RenderDistance, o); //p is where the ray from the camera to \"dir\" (extended) collides with anything\n    vec3 p = rmRes.position;\n    float type = rmRes.type;\n    if(type == 1.){ //collision!\n        col = objectMapMaterial(p, cam); //find material of the object the first time\n    }\n    else if(type == 0.){ //no collision!\n        col = texture(iChannel0, dir).xyz; //skybox\n        //col = vec3(1.);\n    }\n    else{\n        col = outlineColor; //outline color\n    }\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    setupObjects(); //calls setup object function\n    \n    vec2 uv = fragCoord-iResolution.xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = fragCoord / iResolution.xy;\n    vec2 Mouse = texelFetch(iChannel2, ivec2(res)+ivec2(2,0), 0).xy; //get the mouse position in pixels to the normalized value from 0 to 1\n    \n    vec3 dir = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov) + cam; //rotate the direction you look\n    vec3 col = render(cam, dir, fragCoord); //(r,g,b), what will be output to the pixel at position fragCoord\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fov 400 //field of view \n#define key(ascii)   (texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\nvec3 vrDir;\nvec2 res;\n\nvoid prevMouse(out vec4 fragColor) {//mouse position\n    vec4 v = vec4(iMouse.xy/iChannelResolution[0].xy,1.,0.); \n    fragColor = v; //update value stored (mouse position normalized)\n}\n\nvoid initVal(out vec4 fragColor){\n    vec4 val = vec4(0.5,0.5,0.,0.);\n    fragColor = val;\n}\n\nvoid deltaMouse(out vec4 fragColor) {//color stored\n    vec4 val = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0);\n    //grab current delta mouse position\n    vec4 oldMouse = texelFetch(iChannel0, ivec2(res)+ivec2(1,0), 0);\n    //grab previous mouse position (last frame)\n    if(iMouse.z > 0.5 && val.w >= 0.5){ //if mouse was not pressed on prev frame, do not update delta\n        //this means it only changes when the mouse is down and does not warp colors.\n        vec2 deltaM = (iMouse.xy/iChannelResolution[0].xy)-oldMouse.xy;\n        //set delta to be the change in mouse positions between frames\n    \tval.xy+=deltaM;\n        //add the delta to val\n    }\n    if(val.x >= 1.){\n    \tval.x = 0.;   \n    }\n    if(val.y >= 1.){\n    \tval.y = 0.;   \n    }\n    val.w = iMouse.z; //update click state\n    fragColor = val;\n}\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\nvoid position(out vec4 fragColor){\n    vec4 val = texelFetch(iChannel0, ivec2(res), 0);\n    vec2 mid = res;\n    vec3 dir;\n    vec3 dirL;\n    vec2 Mouse = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0).xy;\n    vec2 uv = iChannelResolution[0].xy/2.-iChannelResolution[0].xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n    dir = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov));\n    //need to fix this because I don't quite understand why this works \\/\n    //its just taking the direction and rotating it 90 degrees\n    vec2 MouseL = vec2((Mouse.x + 0.25),0.5); // Normalized pixel coordinates (from 0 to 1)\n    dirL = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (MouseL.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (MouseL.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov));\n    float speed = 0.5;\n    if(key(16)){\n    \tspeed++; \n    }\n    if(key(87)){\n    \tval.xyz+=dir*speed;\n    }\n    if(key(83)){\n    \tval.xyz-=dir*speed;   \n    }\n    if(key(68)){\n    \tval.xyz+=dirL*speed;   \n    }\n    if(key(65)){\n    \tval.xyz-=dirL*speed;   \n    }\n\n \tfragColor = val; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = (iResolution.xy / 3.) + vec2(3.,0.);\n\n    if(iFrame == 0){\n        if(ivec2(fragCoord.xy) == ivec2(res)+ivec2(2, 0)){\n    \t\tinitVal(fragColor);\n        }\n    }\n    else{\n        if (ivec2(fragCoord.xy) == ivec2(res)) {\n            position(fragColor);\n        }\n        if (ivec2(fragCoord.xy) == ivec2(res)+ivec2(1, 0)) {\n            //if pixel that is being checked is 0,0\n            //update the stored value\n            prevMouse(fragColor);\n        }\n        if (ivec2(fragCoord.xy) == ivec2(res)+ivec2(2, 0)) {\n            //if pixel that is being checked is 0,0\n            //update the stored value\n            deltaMouse(fragColor);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//this is for defining objects\n\nstruct light {    \n    vec3 position;\n};\n\nstruct sphere {    \n    float radius;    \n    vec3 position;\n    vec3 material;\n    float reflectiveness;\n    float dist;\n};\n      \nstruct mapResult {\n\tfloat Md;\n    int minS;\n};\n\nstruct raymarchResult {    \n    vec3 position;\n    float type; //0 for no collision, 1 for collision, 2 for close miss\n};\n\n    \nlight lights[11]; //number is number of objects of that type\n\nsphere spheres[2]; //number is number of objects of that type","name":"Common","description":"","type":"common"}]}