{"ver":"0.1","info":{"id":"4tKGzD","date":"1473565116","viewed":1717,"name":"3d l system","username":"sillsm","description":"Two bounding spheres have a seam where they intersect which prevents the right branches from rendering. Trying to compensate by throwing a few different sphere systems at the tree and taking the best measurement.","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tree","lsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n// 3d L Systems.\n// Stackless. O(depth*branches*ray march steps*samples)\n//\n#define PI 3.14159265\n#define MAT_PLANE 3.     \n#define MAT_TREE  5.\n// Uncomment to visualize the bounding volumes.\n//#define DEBUG\n\n//--------------------------------------------------------------------------\nmat4 Ry (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Rz (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Disp (vec3 displacement)\n{\nreturn  mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(displacement, 1)\n); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n//--------------------------------------------------------------------------\n\nvec2 opU( float d1, float d2, float m1, float m2 )\n{\n    return (d1<d2) ? vec2(d1, m1) : vec2(d2, m2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  p -= vec3(0.,h.y, 0);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{ \n\treturn p.y;\n}\n//--------------------------------------------------------------------------\nfloat c_t(vec3 pt, float x1, float x2, float x3)\n{    \n    mat4 posR = Rz(-(25.7/360.)*2.*PI);\n    mat4 negR = Rz(25.7/360.*2.*PI);\n    mat4 bendP = Ry(25.7/360.*2.*PI);\n    mat4 bendR = Ry(-25.7/360.*2.*PI);\n    \n    const int depth = 7;\n    const int branches = 3; \n    float len = 1.5;\n    float wid = .05;\n    float widf= .9;\n    \n    float trunk = sdCappedCylinder(pt-vec3(0.,0., 0.), vec2(wid,len));\n    float d = trunk;\n    float x = sdSphere((Disp(vec3(0.,-2.5*len,0.))*vec4(pt, 1.)).xyz,1.8*len);\n    if (x > 2.*len/2.) return min(x,d);\n\n    vec3 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        wid *= widf;\n        float l = len*pow(.5,float(i));\n       \n        mat4 mx1 = Rz(-0.2*sin(iTime+6.2))*posR*bendP*Disp(vec3(0,-2.*l - l/2.,0));\n\n        mat4 wind = Rz(0.2*sin(iTime+6.2));\n        mat4 mx2 = wind*negR*bendP*Disp(vec3(0,-2.*l,0));\n\n        wind = Rz(0.2*sin(iTime+1.));\n        mat4 mx3 = wind*Disp(vec3(0,-4.*l,0)) ;\n        \n        vec3 pt_1 = (mx1 * vec4(pt_n,1)).xyz;\n        vec3 pt_2 = (mx2 * vec4(pt_n,1)).xyz;\n        vec3 pt_3 = (mx3 * vec4(pt_n,1)).xyz;\n          \n        // bounding sphere test\n        float z1 = sdSphere((Disp(vec3(0.,-x1*l,0.))*vec4(pt_1, 1.)).xyz,2.5*l);\n        float z2 = sdSphere((Disp(vec3(0.,-x2*l,0.))*vec4(pt_2, 1.)).xyz,2.5*l);\n        float z3 = sdSphere((Disp(vec3(0.,-x3*l,0.))*vec4(pt_3, 1.)).xyz,2.5*l);\n          \n        // potential cylinders\n        float y1= sdCappedCylinder(pt_1, vec2(wid,l));\n        float y2= sdCappedCylinder(pt_2, vec2(wid,l));\n        float y3= sdCappedCylinder(pt_3, vec2(wid,l));\n\n        // calc closest\n        float mi = min(z1, min(z2,z3));\n          \n        vec3 pt = (z1<z2) ? pt_1 : pt_2;\n        pt_n = (min(z1,z2)<z3) ? pt   : pt_3;\n\n        d = min( d, min(y1,min(y2,y3)) );\n        float epsilon = .5;\n        #ifdef DEBUG\n        epsilon = .0;\n        #endif\n        if (mi < epsilon) {continue;} \n          //break;\n          return min(mi,d);\n     }\n   return d; \n    \n}\n\n// Any system of bounding spheres will capture some pieces\n// and miss others due to confusion at the overlap of two spheres. \n// So we throw a few different\n// systems at the tree and take the best estimate.\nfloat c(vec3 pt)\n{\n    // I culled some bounding volumes for speed leading to small artifacts.\n    float y1 = c_t(pt, 3., 3., 2.);\n    //float y4 = c_t(pt, 2., 3., 3.);\n    //float y = min(y4,y1);\n    return y1;\n}\n\n// Returns distance_to_shape, material index\nvec2 scene(vec3 ray)  \n{\n    vec2 objs = opU(c(ray), sdPlane(ray), MAT_TREE, MAT_PLANE);\n    return objs ;\n}\n\n//iq's softshadow\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec2 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    float tmax = 21.0;\n    float tmin = .1;\n    float m = 0.0;\n    for (int i = 0; i < 70; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\n        vec2 data = scene(p);\n        float dist = data.x;\n        m  = data.y;\n        t += dist;//;*.5;//;// * .9;\n        \n        if ( (t > tmax) || ((t < tmin) && (t > 0.))){\n            break;\n        }\n    }\n    if( t>tmax ) m=-1.0;\n    return vec2(t, m);\t\t\t\t\t\t\n}\n\n// iq normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\n// Stolen from ming's tutorial.\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\tfloat vis = softshadow( pos, toLight, 0.02, 2.5 );\n\t//float vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n// Given distance to shape, material index, world coord, and pixel, color.\nvec4 color (float t, float m, vec3 p)\n{\n\n    vec4 col = vec4(0.0);\n    float f = mod( floor(p.z) + floor(p.x), 2.0);\n    \n    if (abs(p.x) > 10. || abs(p.z) > 10.) {\n        return vec4(0.);\n    }\n    else if (abs(m -MAT_TREE) < .001) {\n         vec4 brown = vec4(.8, .6, .45, 1.);\n         vec4 green = vec4(.125,.49,.22,1.);\n         col = mix(brown,green,p.y/10.);\n         //col = vec4(.8, .6, .45, 1.);\n         //return col;\n    }else if( abs(m -MAT_PLANE) < .001 ){\n         \n         col = vec4( 0.8 + 0.1*f*vec3(1.0), 1.);\n    } \n    vec3 nrm = calcNormal(p);\n    vec4 light1 = vec4(2., 8., 2.,   10.0 );\n    vec4 light2 = vec4(-2., 8., -2., 10.0 );\n    vec3 cc  = shade(p,nrm,light1);\n    vec3 cc1 = shade(p,nrm,light2);\n    \n    return (cc.x+cc1.x)*col;\n}\n\n// returns pixel color\nvec4 render(vec3 ray, vec3 pt)\n{\n    vec2 tm    = trace(ray, pt);\n    float t    = tm.x;\n    float mat  = tm.y;\n    vec3 point = pt + (t* ray);\n    return color(t, mat, point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    vec3 position = vec3(cos(iMouse.x/100. - .8)*10., 3., sin(iMouse.y/100.-.3)*10.);\n    \n    mat4 mat = LookAtRH(position, vec3(0,3,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    fragColor   = render(ray, pt);\n}","name":"Image","description":"","type":"image"}]}