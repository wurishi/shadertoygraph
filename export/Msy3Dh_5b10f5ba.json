{"ver":"0.1","info":{"id":"Msy3Dh","date":"1454202290","viewed":382,"name":"Raymarcher with Parallax Mapping","username":"VoidChicken","description":"A raymarcher with reflections and parallax mapping. Insanely unoptimized. Working on new technique.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 sphere = vec4(5.75,2.75,4,2);\nvec4 sphere2 = vec4(0,2,4,2);\nvec3 light = vec3 (0, 1, 5);\n#define time iTime\n#define ret return vec3\n#define res 1.0\n#define dist 10.0\n#define mdist 20.0\n#define mres 30.0\n#define plane         vec2 uvasr = (uvar-pos.xz); if (iPlane(pos))  return dt;\n#define dt vec3(texture(iChannel3, pos.xz))\n#define dat vec3(texture(iChannel2, norm*vec3(1,-1,1)))\nbool iPlane ( vec3 v ) {\n\treturn v.y < 0.0;\n}\nfloat moda(float a, float b) {\n\treturn a-(floor(a/b)*b);\n}\nfloat height(vec2 uv) {\n    vec3 a = texture(iChannel1, uv).rgb;\n\treturn (a.r+a.g+a.b)/3.0;\n}\nfloat lv(vec3 norm, vec3 pos) {\n\treturn (1.0-(dot(normalize(norm), normalize(pos-light))));\n}\nvec3 dRay(vec3 posi, vec3 norm, vec2 uv, vec2 uvar, float refl) {\n\t\n    for (float i =0.0; i < dist; i+=1.0/res) {\n    \tvec3 pos = posi+(norm*i);\n        vec3 h = sphere2.xyz - pos;\n        float l = length(h);\n       \tfloat la = i/8.0;\n        vec3 dte = normalize(pos-posi);\n        vec2 uvs = uv.xy-pos.xy+sphere2.xy;\n        vec2 uvsa = uvs*dte.xy*(texture(iChannel1, uvs).r*.5);\n        vec3 norma = normalize(-h)*vec3(1,-1,1);\n        float lva = lv(norma, pos);\n        plane\n        if (l<sphere2.w) {\n            vec4 tex = texture(iChannel2, norma);\n            vec2 asr = uvsa;\n         \tvec3 v = (vec3(texture(iChannel0,asr))*(1.0-refl));\n          \tv+=(vec3(tex)*refl);\n            return v*lva;\n        }\n    }\n    \n  return dat;\n}\n\nvec3 bRay(vec3 posi, vec3 norm, vec2 uv, vec2 uvar, float refl) {\n\t\n    for (float i =0.0; i < dist; i+=1.0/res) {\n    \tvec3 pos = posi+(norm*i);\n        vec3 h = sphere.xyz - pos;\n        float l = length(h);\n       \tfloat la = i/8.0;\n        vec3 dte = normalize(pos-posi);\n        vec2 uvs = uv.xy-pos.xy+sphere.xy;\n        vec2 uvsa = uvs+dte.xy*(texture(iChannel1, uvs).r*.5);\n        vec3 norma = normalize(-h)*vec3(1,-1,1);\n        float lvab = lv(norma, pos);\n        plane\n        if (l<sphere.w) {\n            vec4 tex = texture(iChannel2, norma);\n            vec2 asr = uvsa;\n         \tvec3 v = (vec3(texture(iChannel0,asr))*(1.0-refl));\n          \tv+=(vec3(tex)*refl);\n            return v*lvab;\n        }\n      \n        \n    }\n   return dat;\n}\nvec3 ray(vec3 posi, vec3 norm, vec2 uv, vec2 uvar, bool bounce) {\n    float refl = 0.5;\n    vec4 va = vec4(0, 0, 0, 0);\n    bool a = false;\n    bool b = a;\n    vec4 vb = va;\n    for (float i =0.0; i < mdist; i+=1.0/mres) {\n    \tvec3 pos = posi+(norm*i);\n        vec3 h = sphere.xyz - pos;\n        float l = length(h);\n       \tfloat la = i/8.0;\n        vec3 dte = normalize(pos-posi);\n        vec2 uvs = uv.xy-pos.xy+sphere.xy;\n        vec2 uvsa = uvs+dte.xy*(texture(iChannel1, uvs).r*.5);\n        vec3 norma = normalize(-h);\n        float lvab = lv(norma, pos);\n        plane\n        if (l<sphere.w) {\n            vec4 tex = texture(iChannel2, norma*vec3(1,-1,1));\n            vec2 asr = uvsa;\n         \tvec3 v = (vec3(texture(iChannel0,asr))*(1.0-refl));\n            if (!bounce) {v+=(vec3(tex)*refl); } else {\n            \tv+= dRay(pos, vec3(reflect(vec3(norm), vec3(norma))), uv, uvar, refl)*refl;    \n            }\n            va = vec4(v, pos.z);\n            a = true;\n        }\n        vec3 h2 = sphere2.xyz - pos;\n        float l2 = length(h2);\n         vec2 uvs2 = uv.xy-pos.xy+sphere2.xy;\n        vec2 uvsa2 = uvs2+dte.xy*(texture(iChannel1, uvs2).r*.5);\n        vec3 norma2 = normalize(-h2);\n        float lvab2 = lv(norma2, pos);\n        if (l2<sphere2.w) {\n            vec4 tex = texture(iChannel2, norma2*vec3(1,-1,1));\n            vec2 asr = uvsa2;\n         \tvec3 v = (vec3(texture(iChannel0,uvsa2))*(1.0-refl));\n            if (!bounce) {v+=(vec3(tex)*refl); } else {\n            \tv+= bRay(pos,  vec3(reflect(vec3(norm), vec3(norma2))), uv, uvar, refl)*refl;    \n            }\n            b= true;\n            vb = vec4(v, pos.z);\n        }\n        if (a == true && b == true) {\n            if (va.w < vb.w){ ret(va)*lvab;} else{ ret(vb)*lvab2;}   \n        }\n        if (a) ret( va)*lvab;\n        if (b) ret( vb)*lvab2;\n\n    }\n   return dat;\n}\n\nfloat z = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    sphere.y += sin(iTime)*4.0;\n    sphere2.x += cos(iTime)*4.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 cam = vec3(uv.xy, -9.5)+vec3(0, .25, 0);\n    vec3 col = ray(cam+vec3(0,0,moda(time, 20.0) ), vec3(uv.x*2.0-1.0, uv.y-0.5, 1), uv, uv, true) ;\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}