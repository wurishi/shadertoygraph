{"ver":"0.1","info":{"id":"NtjXzc","date":"1628252408","viewed":113,"name":"Capsule (Max Norm Distance)","username":"TheTurk","description":"Maximum norm distance function for a capsule.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","distance","capsule","maxnorm","linfinity","maximumnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube.\n*/\n\nfloat capsule(vec2 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    if (position.x < position.y - radius || position.y < position.x - radius) {\n        return max(position.x, position.y) - radius;\n    }\n    float p = dot(position, vec2(0.5));\n    float q = dot(position, position) * 0.5 - p * p;\n    float h = sqrt(radius * radius * 0.5 - q); \n    return p - h;\n}\n\nfloat capsule(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    \n    // the remaining implementation is identical to that of a sphere\n    // closest point lies on cube face\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xy);;\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n\n    // closest point lies on cube corner\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;  \n    float z = (fract((iTime * 0.2) + 0.5) * 2.0 - 1.0) * 0.35;\n    \n    float radius = 0.3;\n    float halfHeight = 0.6;\n    float d = capsule(vec3(position, z), radius, halfHeight);\n    // float d = capsule(position, radius, halfHeight);\n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d); // ripples\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.001) * iResolution.y)); // outline\n    fragColor = vec4(color, 1.0);\n} ","name":"Image","description":"","type":"image"}]}