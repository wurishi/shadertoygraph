{"ver":"0.1","info":{"id":"l3SBDW","date":"1729453381","viewed":86,"name":"Gravitational lensing formalism ","username":"nagaoo0","description":"https://en.wikipedia.org/wiki/Gravitational_lensing_formalism","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, vec2 u) {\n    // vec2 R stores the screen resolution passed to the shader.\n    vec2  R = iResolution.xy;\n    \n    // d is the initial distance from the black hole (camera distance).\n    // l is a variable used for the loop to track the updated distance.\n    float d = 5., l = d, k;\n    \n    // V is a 3D vector representing the direction from the camera to the pixel being rendered.\n    // It normalizes a vector where the x component is based on screen aspect ratio and y and z\n    // are based on the pixel coordinates (u) passed in. It simulates a ray from the camera.\n    vec3  V = normalize(vec3(.447 * R.x, R - u - u)),\n          P = vec3(-d, 0, 0),  // P is the starting point of the ray in 3D space.\n          c;                   // c is a temporary vector used later for calculations.\n\n    // This loop iterates as long as l (distance from the black hole) is within a valid range.\n    // It updates the ray's position and direction based on gravitational influence.\n    for (O *= 0.; l < d + d && l > 1.;) {\n        // k is a small step size based on the current distance.\n        k = 0.1 * l;\n        \n        // Update l to be the length (distance) of the new position vector P after moving along V.\n        l = length(P += V * k);\n        \n        // Apply gravitational lensing effect by adjusting the direction vector V.\n        // The cross product of V and P creates a perpendicular vector c.\n        // Dot product is used to project the effect of gravitational pull on V.\n        // The result is scaled based on the distance (l) raised to the power of 5.\n        V -= k * dot(c = cross(V, P), c) * P / pow(l, 5.);\n    }\n\n    // Calculate screen coordinates based on the adjusted direction vector V.\n    // atan() is used to transform the vector components into polar coordinates.\n    // Divided by 3.14 (Ï€) for normalization.\n    R = 1. - atan(vec2(V.y, length(V.xy)), V.xz) / 3.14;\n    \n    // Animate the x component of R using iTime to create a dynamic effect.\n    R.x += iTime * .02;\n    \n    // Apply a sinusoidal function to create a checker pattern effect on R.\n    R = sin(R * 69.0);\n    k = R.x * R.y;  // k represents the combined value of the pattern.\n\n    // If l > 1, add the checker pattern to the output color O.\n    // fwidth(k) computes the derivative of k to smooth out the pattern edges.\n    l > 1. ? O += .5 + k / fwidth(k) : O;\n}\n","name":"Image","description":"","type":"image"}]}