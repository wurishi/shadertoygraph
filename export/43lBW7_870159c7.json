{"ver":"0.1","info":{"id":"43lBW7","date":"1728477320","viewed":14,"name":"Complex inversion","username":"Fuergu","description":"Complex analysis: inversion\nI'm reading <Visual Complex Analysis> written by Tristan Needham recently.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["2d","math","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/****************************/\n/*   Draw on the screen!!   */\n/****************************/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = iResolution.xy * 0.5;\n    center.x+=50.*cos(iTime);\n    center.y+=50.*sin(iTime);\n    float radius = iResolution.x/8.;\n\n    vec2 uv = fragCoord.xy;\n\n    vec2 toCenter = uv - center;\n    float Distance = length(toCenter);\n\n    vec2 resultUV;\n\n    if (Distance < radius) {\n        float scale = radius / Distance;\n        resultUV = center + normalize(toCenter) * (radius * scale);\n    } else {\n        float scale = Distance / radius;\n        resultUV = center + normalize(toCenter) * (radius * scale);\n    }\n    vec3 col = vec3(0.);\n    vec3 line = vec3(0.);\n    col+= texture(iChannel0, resultUV / iResolution.xy).r*vec3(0.741,0.949,1.000);\n    line.g += texture(iChannel1, resultUV / iResolution.xy).r;\n    \n    if (Distance > radius) {\n        float scale = radius / Distance;\n        resultUV = center + normalize(toCenter) * (radius * scale);\n    } else {\n        float scale = Distance / radius;\n        resultUV = center + normalize(toCenter) * (radius * scale);\n    }\n    col+= texture(iChannel0, resultUV / iResolution.xy).r*vec3(1.000,0.784,0.000);\n    line.r += texture(iChannel1, resultUV / iResolution.xy).r;\n    vec3 color = vec3(col);\n    if(Distance<radius+1.&& Distance>radius-1.) color.rgb+=1.;\n    \n    fragColor = vec4(color+line,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nhttps://www.shadertoy.com/view/Wdjfzm\n*/\nfloat isKeyToggled(int keyCode) {\n    return texelFetch( iChannel1, ivec2(KEY_F,2), 0 ).x; // Toggled information is on layer 2.\n}\n\nconst float STROKE_THICKNESS = 0.0001;\n\nfloat stroke( vec2 a, vec2 b, vec2 p ) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - STROKE_THICKNESS;\n}\n\nfloat isKeyPress(int keyCode) {\n    return texelFetch( iChannel1, ivec2(keyCode,1), 0 ).x; // Press information is on layer 1;\n}\n\n// Same as <keyCode is pressed> ? a : b\nvec4 ifKeyPress(int keyCode, vec4 a, vec4 b) {\n    return mix(b, a, isKeyPress(keyCode));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xx;\n    vec4 m = iMouse / iResolution.xxxx;\n    vec2 currentMousePosition = m.xy;\n    vec2 mouseDownPosition = m.zw;\n    float isLMBPressed = float(m.z > 0.); // When LMB is not pressed m.zw is -1.0 * lastMouseDownPosition\n    float isF = isKeyToggled(KEY_F);\n    \n    vec4 lastFrame = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 previousMousePosition = lastFrame.zw;\n    float wasLMBPressed = lastFrame.y;\n    \n    vec2 strokeStart = mix(currentMousePosition, previousMousePosition, wasLMBPressed);\n\n    float col = mix(1., \n                    mix(stroke(strokeStart, currentMousePosition, uv),\n                        stroke(currentMousePosition, mouseDownPosition, uv),\n                        isF),\n                    isLMBPressed);\n    \n    float value = 1.0 - smoothstep(0.0, 0.005, col);\n    value = max(lastFrame.x, value);\n    \n    // x  -> 0.0 (blank) or 1.0 (painted)\n    // y  -> 0.0 (LMB pressed) or 1.0 (LMB not pressed)\n    // zw -> vec2 (current mouse position)\n    // R resets canvas\n    fragColor = ifKeyPress(KEY_R,\n                           vec4(0.0, isLMBPressed, currentMousePosition),\n                           vec4(value, isLMBPressed, currentMousePosition));\n                           \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n/*constant*/\n#define PI 3.14159265359\n\n/*Function*/\n#define S(a,b,t) smoothstep(a,b,t)\n#define avg(v) ((v.x+v.y+v.z)/3.0)\n\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 resolution = iResolution.xy;\n\n    float lineY = resolution.y * 0.8;\n\n    float y = fragCoord.y;\n    vec3 color = vec3(0.0);\n    if (abs(y - lineY) < 1.0) { \n        color = vec3(1.0); \n    }\n    vec2 circleCenter = vec2(resolution.x * 0.3, resolution.y * 0.4);\n    vec2 circleCenter2 = vec2(resolution.x * 0.5, resolution.y * 0.5);\n    float circleRadius = 40.0;\n    float circleRadius2 = 20.0;\n    vec2 uv = fragCoord.xy;\n\n    float distanceToCenter = length(uv - circleCenter);\n    float distanceToCenter2 = length(uv - circleCenter2);\n    if (distanceToCenter < circleRadius && distanceToCenter > circleRadius-2.) {\n        color = vec3(1.); \n    }\n    \n    if (distanceToCenter2 < circleRadius2 && distanceToCenter2 > circleRadius2-2.) {\n        color = vec3(1.); \n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}