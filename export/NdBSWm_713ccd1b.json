{"ver":"0.1","info":{"id":"NdBSWm","date":"1620337828","viewed":236,"name":"Low discrepancy Montecarlo PDE","username":"anael","description":"Low discrepancy quasirandom sequence version of https://www.shadertoy.com/view/WsXBzl\nFor more see: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirand","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","lowdiscrepancy","pde"],"hasliked":0,"parentid":"WsXBzl","parentname":"Montecarlo PDE (1)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n// See https://www.shadertoy.com/view/WdXfzl for a more complex example\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = vec4(data.xyz/data.w, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --------------------------------------\n// modified version of this shader using low discrepancy quasirandom sequences\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// --------------------------------------\n\n// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney\n//\n// http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n\n// https://iquilezles.org/articles/distfunctions\nvec4 sdLine( in vec2 p, in vec2 a, in vec2 b, in vec3 ca, in vec3 cb )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    float s = step(0.0,pa.x*ba.y-pa.y*ba.x);\n    return vec4(d, mix(ca,cb,s)*smoothstep(-0.1,0.1,sin(50.0*h)) );\n}\n\n// sdf map\nvec4 map( in vec2 p )\n{\n    vec4 d  = sdLine(p, vec2(-1.0,0.4), vec2(1.1,-0.1), vec3(1.0,0.4,0.1),vec3(0.2,0.5,0.8) )-0.05;\n    vec4 d2 = sdLine(p, vec2(-0.3,0.8), vec2(0.2,-0.6), vec3(1.0,1.0,0.2), vec3(0.1,0.7,0.3) )-0.05;\n    if( d2.x<d.x ) d = d2;\n    \n    return d;\n}\n\n\n// --------------------------------------\n// 10 dimensions sequence\n// and dithering-inspired seed\n\nconst float r10f[10] = float[10](\n    0.936069,\n    0.876225,\n    0.820208,\n    0.767771,\n    0.718687,\n    0.672740,\n    0.629731,\n    0.589472,\n    0.551787,\n    0.516510\n);\n\nvoid r10(out float dest[10], in float seed[10], float n)\n{\n    for (int i = 0; i < 10; i++)\n        dest[i] = fract(seed[i] + n * r10f[i]);\n}\n\nvoid r10_seed(out float dest[10], in vec2 coord)\n{\n    // init the sequence using screen coordinates\n    float x = 0.754878 * coord.x + 0.56984 * coord.y;\n\n    for (int i = 0; i < 10; i++) {\n\n        // advance the 3rd dimencion (i)\n        float xf = fract(x += 0.430160);\n\n        // make triangular\n        dest[i] = (xf < 0.5) ? (xf * 2.0) : (2.0 - xf * 2.0);\n    }    \n}\n\n// --------------------------------------\n\nvec3 march10(in vec2 p, in float rand10[10])\n{\n    vec4 h=vec4(0.0);\n\tfor( int i=0; i<10; i++ )\n    {\n        h = map(p);\n        if( h.x<0.001 ) break;\n        \n        float an = rand10[i] * 6.283185;\n        vec2 rand_circ = vec2(cos(an), sin(an));\n        \n        p = p + h.x*rand_circ;\n    }\n    return h.yzw;\n}\n\n// --------------------------------------\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n// --------------------------------------\n\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n    \n// WoS\nvec3 march( in vec2 p )\n{\n    vec4 h=vec4(0.0);\n\tfor( int i=0; i<10; i++ )\n    {\n        h = map(p);\n        if( h.x<0.001 ) break;\n        p = p + h.x*randomInCircle();\n    }\n    return h.yzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 col;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n       \n    // left low discrepency sequence\n    if (p.x < 0.0) {\n    \n        // init sequence\n        float rand10[10];\n        float seed10[10];\n\n        r10_seed(seed10, fragCoord);\n        r10(rand10, seed10, float(iFrame));\n\n        // solve\n        col = march10(p, rand10);\n    }\n    \n    // right original random\n    else {\n    \n    \t// init randoms\n        ivec2 q = ivec2(fragCoord);\n        srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n        // solve\n        col = march(p);\n    }\n\n    // display map()\n    #if 0\n    vec4 dcol = map(p);\n    float f = 1.0-smoothstep(0.0,0.01,dcol.x);\n    col = mix(col,dcol.yzw,f);\n    col *= smoothstep(0.0,0.01,abs(dcol.x));\n    #endif\n    \n    if (p.x > -0.005 && p.x < 0.005)\n        col += 0.5;\n    \n    // montecarlo\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}