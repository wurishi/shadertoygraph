{"ver":"0.1","info":{"id":"MXjBW3","date":"1730039343","viewed":105,"name":"Adelson's Checker","username":"altunenes","description":"The \"white\" squares in shadow and the \"gray\" squares in light are exactly the same color (RGBa: 95, 95, 95,255).\ncheck it: https://imagecolorpicker.com/ with a screenshot. :) \nsee:\nhttps://persci.mit.edu/gallery/checkershadow","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["illusion","vision","perception"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CYLINDER_HEIGHT 0.8\n#define CYLINDER_RADIUS 0.2\n#define CHECKER_SCALE 0.1 \n#define BOARD_SIZE 2.0\n\nfloat cylinder(vec3 p) {\n    p.xz -= vec2(-0.6 , -0.6);\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(CYLINDER_RADIUS, CYLINDER_HEIGHT);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat plane(vec3 p) {\n    vec2 q = abs(p.xz);\n    if(q.x > BOARD_SIZE || q.y > BOARD_SIZE) return 1000.0;\n    return p.y;\n}\n\nfloat dotss(vec2 p) {\n    float d1 = length(p - vec2(-0.15, 0.25));\n    float d2 = length(p - vec2(0.15, -0.15)); \n    return float(min(d1, d2) < 0.02);\n}\n\nfloat checkerboard(vec2 p) {\n    if(abs(p.x) > BOARD_SIZE || abs(p.y) > BOARD_SIZE) return -1.0;\n    vec2 grid = floor(p / CHECKER_SCALE);\n    return mod(grid.x + grid.y, 2.0);\n}\n\nvec2 refsqpos(float time) {\n    vec2 startPos = vec2(-0.25, 0.15); \n    vec2 endPos = vec2(0.05, -0.25);    \n    float t = (sin(time * 0.5) + 1.0) * 0.5;\n    t = smoothstep(0.0, 1.0, t);\n    return mix(startPos, endPos, t);\n}\n\nfloat refsq(vec2 p, float time) {\n    vec2 squarePos = refsqpos(time);\n    vec2 d = abs(p - squarePos) - vec2(0.05);\n    return step(max(d.x, d.y), 0.0);\n}\n\nvec2 scene(vec3 p) {\n    float cylinder = cylinder(p);\n    float plane = plane(p);\n    float id = (cylinder < plane) ? 1.0 : 0.0;\n    return vec2(min(cylinder, plane), id);\n}\n\nvec3 norm(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = vec3(\n        scene(p + e.xyy).x - scene(p - e.xyy).x,\n        scene(p + e.yxy).x - scene(p - e.yxy).x,\n        scene(p + e.yyx).x - scene(p - e.yyx).x\n    );\n    return normalize(n);\n}\nfloat shad(vec3 p, vec3 ld) {\n    float res = 1.0;\n    float t = 0.1;\n    float k = 16.0;\n    for(int i = 0; i < 32; i++) {\n        float h = scene(p + ld * t).x;\n        res = min(res, k * h / t);\n        t += h;\n        if(res < 0.001 || t > 20.0) break;\n    }\n    return clamp(res, 0.1, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd, float time) {\n    vec3 col = vec3(0.1);\n    float t = 0.0;\n    vec2 res = vec2(0.0);\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        res = scene(p);\n        if(res.x < 0.001 || t > 100.0) break;\n        t += res.x;\n    }\n    if(t < 100.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = norm(p);\n        float shadow = shad(p + n * 0.02, normalize(vec3(-1.0, 1.2, -0.5)));\n        if(res.y > 0.5) {\n            col = vec3(0.2, 0.8, 0.2);\n        } else {\n            float check = checkerboard(p.xz);\n            if(check < 0.0) {\n                col = vec3(0.1);\n            } else {\n                col = mix(vec3(0.15), vec3(0.85), check);\n                if(refsq(p.xz, time) > 0.5) {\n                    col = vec3(29.0/255.0);\n                    return col;\n                }\n                if(dotss(p.xz) > 0.5) {\n                    col = vec3(0.8, 0.0, 0.0);\n                    return col; \n                }\n            }\n        }\n        float diff = max(dot(n, normalize(vec3(-1.0, 1.2, -0.5))), 0.0);\n        float amb = 0.099;//this kind of a \"illusion constant\". I adjusted this value experimental to get exact result...\n        col *= amb + (1.0 - amb) * diff * shadow;\n        float ao = 1.0 - 0.2 * (1.0 - shadow);\n        col *= ao;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float angle = iTime * 2.0 * 3.14 / 30.0;\n    float camHeight = 2.0;\n    float camDist = 1.5; \n    float ang2 = clamp(angle, -1.04, 1.04); \n    vec3 ro = vec3(\n        camDist * sin(angle),\n        camHeight/sin(ang2),\n        camDist * cos(angle)\n    );\n    vec3 ta = vec3(0.0, 0.5, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    vec3 col = render(ro, rd, iTime);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}