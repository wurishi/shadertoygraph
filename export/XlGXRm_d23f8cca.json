{"ver":"0.1","info":{"id":"XlGXRm","date":"1483479886","viewed":1940,"name":"OJ - Fibber 28, scene 5","username":"rammoskar","description":"Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAT_S5_BLOB 13.0\n#define MAT_S5_FLOOR 14.0\n#define MAT_S5_PILLAR 15.0\n\n\n#define EPS 0.01\n\n\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\tfloat t = iTime;\n\tvec2 res = vec2(99999, -1);\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p, s) - 0.5 * s;\n\tivec3 n = ivec3(floor(p / s));//TODO! ivec3(trunc(p / s));\n\t\n\tfloat blob = sphere(p, 4.0);\n\tblob +=  0.15 * sin(- t * 2.0 + p.y * 0.75 ) +\n\t  \t0.1 * sin( t * 1.5 + p.x*1.5) +\n\t\t0.2 * sin( t * 1.0 + p.z);\n\tres = un(res, vec2(blob, MAT_S5_BLOB));\n\t\n\t\n\tfloat roomDis = -sdBox(vec3(n), vec3(40.0, 15.0, 40.0));\n\tif (roomDis < 0.0) {\n\t\tfloat box = udRoundBox(q, vec3(0.4), 0.1);\n\t\tres = un(res, vec2(box, MAT_S5_FLOOR));\n\t} else {\n\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\tfloat a = max(roomDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\tres = un(res, vec2(max(EPS, a), -1));\n\t}\n\t\n\t{\n\t\tvec3 s2 = vec3(30, 10, 30);\n\t\tvec3 q2 = mod(vec3(n), s2) - 0.5 * s2;\n\t\tfloat pDis = sdCylinder(vec3(q2.x, n.y, q2.z), vec3(0, 0, 4));\n\t\tif (pDis < 0.0) {\n\t\t\tfloat box = udRoundBox(q, vec3(0.4), 0.1);\n\t\t\tres = un(res, vec2(box, MAT_S5_PILLAR));\n\t\t} else {\n\t\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\t\tfloat a = max(pDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\t\tres = un(res, vec2(max(EPS, a), -1));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int jumps = 2;\n\tconst int imax = 600;\n\tfloat tmax = 800.0;\n\tvec3 skyColor = vec3(0);\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n\t\n    float time = iTime;\n    vec3 eye = vec3(15.0*sin(time/5.0), 3.0, 15.0*cos(time/5.0)); \n    vec3 tar = vec3(0, 0, 0);\n    float r = 6.0; \n    float azi = time;\n    float pol = 0.5 * time;\n    float x = r*cos(pol)*sin(azi);\n    float y = r*sin(pol)*sin(azi);\n    float z = r*cos(azi);\n\n    vec3 light = vec3(x, y, z);\n    float shadowAmbient = 0.7;\n    float lightInvSize = 30.0;\n    float lightIntensity = 0.01;\n\n    float refJumpDistance = 1.0;\n    \n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); \n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x);\n\n    vec3 color = skyColor;\n      \n    float t = 0.0;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n    float breakVar = 0.0;\n\tfor(int j = 0; j < 2; ++j)\n    {\n        if (breakVar >= 0.5) {\n        \tbreak;\n        }\n    \tt = 0.0;\n        for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n                 break;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) \n\t        {\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)),2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\t\n\t\t\t\tif (m == MAT_S5_BLOB) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} else if (m == MAT_S5_FLOOR) {\n\t\t\t\t\tc = vec3(0.9);\n\t\t\t\t} else if (m == MAT_S5_PILLAR) {\n\t\t\t\t\tc = vec3(0.8, 0, 0);\n\t\t\t\t} \n                c = 0.7*c* (1.0 + diffuse);        \n                c += specular(normal, -invLight, normalize(eye - p), 70.0);\n\t        \t\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1),2.0);\n\t        \tif(tl > 0.0 && (distance(eye, light) < distance(eye, p))){\n\t        \t\tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\t        \t}\n\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\t\n                rd = reflect(rd, normal);\n\t         \tro = p + rd*refJumpDistance;\n\t\t\t\t\n\t        \t\n\t        \t if (m == MAT_S5_BLOB) {\n\t        \t\tref = 0.7;\n\t        \t} else {\n\t\t        \tref = 0.0;\n\t        \t}\n\t        \tif (ref <= 0.01) {\n\t        \t\tbreakVar = 1.0;       \t\t\n\t        \t} \n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n   \n    fragColor = vec4(color + vec3(lightAura),  1.0);\n\n\n\n}","name":"Image","description":"","type":"image"}]}