{"ver":"0.1","info":{"id":"stjczw","date":"1649416092","viewed":281,"name":"Chaikin Smooth Interpolation","username":"luckyballa","description":"Implementation is not optimized for the GPU, just trying to learn more about splines and smooth interpolations\n\nreference - https://sighack.com/post/chaikin-curves","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["spline","interpolation","points","path","chaikin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define originalPointsCount 7\n#define levels 2\n#define showChaikin\n//#define showCatmullRom\n#define showOriginal\n\n#define pointsCount originalPointsCount * int(pow(2.0, float(levels)))\n#define chaikinColor vec3(1., 1., 1.)\n#define catmullRomColor vec3(0., 0., 1.)\n#define baseColor vec3(1., 0.5, 0.)\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 chaikinCut(vec2 a, vec2 b, float ratio) {\n  ratio = ratio > 0.5 ? 1.0 - ratio : ratio;\n\n  vec2 x = mix(a, b, ratio);\n  vec2 y = mix(b, a, ratio);\n\n\n  return vec4(x, y);\n}\n\nvec2[pointsCount] chaikin(vec2[pointsCount] points, float ratio, int count) {\n  vec2[pointsCount] next;\n  int counter = 0;\n  for (int i = 0; i < count - 1; i++) {\n    vec2 a = points[i];\n    vec2 b =  points[(i + 1) % count];\n    vec4 n = chaikinCut(a, b, ratio);\n\n    next[counter] = n.xy;\n    counter++;\n    next[counter] = n.zw;\n    counter++; \n  }\n  \n  next[pointsCount - 1] = vec2(counter);\n  \n  return next;\n}\n\nvec3 drawChaikin(vec3 col, vec2 uv, vec2[pointsCount] points) {\n    int counter = originalPointsCount;\n    const float ratio = 0.2;\n    vec2[pointsCount] p = points;\n\n    for (int l = 0; l < levels; l++) {\n        p = chaikin(p, ratio, counter);\n        counter = int(p[pointsCount - 1].x);\n    }\n\n    for (int i = 0; i < counter; i++) {\n        col = mix(col, chaikinColor, step(length(uv - p[i]), 0.0075));\n        col = i == 0 ? col : mix(col, chaikinColor, step(sdSegment(uv, p[i], p[i - 1]), 0.0015));\n    }\n    \n    return col;\n}\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p) {\n\tvec2 P = -a + (3. * (b - c)) + d;\n    vec2 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec2 R = c - a;\n    vec2 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 drawCatmullRom(vec3 col, vec2 uv, vec2[pointsCount] points) {\n    const int catmullRomStep = levels * levels;\n    vec2 interpolatedPoints[originalPointsCount + originalPointsCount * catmullRomStep];\n    float floatStep = float(catmullRomStep + 1);\n    int currentInd = 0;\n    for (int i = 0; i < originalPointsCount; i++) {\n        interpolatedPoints[currentInd] = points[i];\n        float line = currentInd > 0 ? sdSegment(uv, interpolatedPoints[currentInd], interpolatedPoints[currentInd - 1]) : 1.;\n        currentInd++;\n        \n        col = mix(col, catmullRomColor, step(line, 0.0015));\n        col = mix(col, catmullRomColor, step(length(uv -  points[i]), 0.0075));\n  \n        for (int j = 0; j < catmullRomStep && i < originalPointsCount - 1; j++) {\n            float weight = float(j + 1) / floatStep;\n            int i0 = max(i - 1, 0);\n            int i2 = min(i + 1, originalPointsCount - 1);\n            int i3 = min(i + 2, originalPointsCount - 1);\n\n            vec2 point = interpolate(points[i0], points[i], points[i2], points[i3], weight);\n            interpolatedPoints[currentInd] = point;\n            float line = currentInd > 0 ? sdSegment(uv, interpolatedPoints[currentInd], interpolatedPoints[currentInd - 1]) : 1.;\n            currentInd++;\n\n            col = mix(col, catmullRomColor, step(line, 0.0015));\n            col = mix(col, catmullRomColor, step(length(uv - point), 0.0075));\n        }\n    } \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;; \n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.8);\n    const float pointsCountF = float(originalPointsCount);\n    vec2 points[pointsCount];\n\n    float shapes = sin(iTime / 2.);\n    for (int i = 0; i < originalPointsCount; i++) {\n        float x = aspectRatio - float(i) * (aspectRatio / pointsCountF) - aspectRatio / (pointsCountF * 2.0);\n        float y = smoothstep(0., 0.5, sin(x * 5. + 0.25 + shapes)) * 0.3 + 0.3;\n        points[i] = vec2(x, y);\n        #if defined(showOriginal) \n        col = mix(col, baseColor,  step(length(uv - points[i]), 0.01));\n        col = i == 0 ? col : mix(col, baseColor,  step(sdSegment(uv, points[i], points[i - 1]), 0.0015)); //* step(fract(length(uv - points[i]) * 40.), 0.5)\n        #endif\n    }     \n\n    #if defined(showChaikin) \n    col = drawChaikin(col, uv, points);\n    #endif\n    \n    #if defined(showCatmullRom) \n    col = drawCatmullRom(col, uv, points);\n    #endif\n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}