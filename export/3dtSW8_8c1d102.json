{"ver":"0.1","info":{"id":"3dtSW8","date":"1581476795","viewed":175,"name":"Castle draft - StopMotion","username":"rmmcal","description":"(Castle draft - StopMotion) - 5 frames per second is intentional... ","likes":7,"published":1,"flags":96,"usePreview":0,"tags":["draft","castle","stopmotion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4llGWX","filepath":"https://soundcloud.com/clemensruh/the-awakening","previewfilepath":"https://soundcloud.com/clemensruh/the-awakening","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n////       ....  Castle draft - StopMotion  ....         ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus  \n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Started: 2019/10 - Published: 2020/02\n// - https://www.shadertoy.com/view/3dtSW8\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  Castle draft - StopMotion\n//\n//\tPass: #Desenho_Deserto_Castelo\n//  \n//      ... @rmmcal 2020/02\n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n \nvoid drawPlaying(inout vec4 c, vec2 p)\n{\n\tp *= 2.;\n    float t = -fract(iTime)*PI2;\n    float s = .06;\n    for (float i = 1.; i < 4.; i++) {  \n        c = mix(c, vec4(0.5), 1.-smoothstep(-0.,0.003, abs(s/2.-smoothstep(0.,1.,length(p)))));\n        t+=i;\n        s = s/(2.);  \n        p += s*vec2(cos(t),sin(t));\n    }\n}\n\nvoid drawFrame(inout vec4 c, vec2 p, vec2 aspectRatio){\n    float box = sdBox(p,vec2(0.),vec2(0.5)*aspectRatio);\n    float cbox = smoothstep(0.,.01, 0.05-abs(box));\n    c = mix(c, vec4(0.,0.,0.,0.), cbox);\n    c = mix(c, vec4(0.,0.,0.,0.), -.1+length(p)*.5);\n    c = mix(c, vec4(0.,0.,0.,0.), .3+.5*sdBox(p,vec2(0.),vec2(0.5)*aspectRatio));\n    c = mix(c, vec4(1.,1.,1.2,0.), clamp(.15-.05*(cos(60.*smoothstep(-0.,.1, .05-abs(box)))),0.,1.));\n    float box2 = sdBox(p,vec2(0.),vec2(0.455, 0.42)*aspectRatio) ;\n    c = mix(c, vec4(0.,0.,0.,0.), smoothstep(0.,.0025, 0.0025-abs(box2)));\n    float vf1 = max(1.-pow(cbox,4.), 1.-veronoib(p*40.,.1));\n \tfloat vf2 = max(1.-pow(cbox,4.), 1.-veronoib(p*40.,.2));\n \tfloat vf3 = max(1.-pow(cbox,4.), 1.-veronoib(p*40.,.3));\n    float vf = vf1; \n    c = mix(c, vf1*c,1.00);\n    c = mix(c, (vf2*.5+0.5)*c,1.00);\n    c = mix(c, (vf3*.2+0.8)*c,1.00);\n}\nvoid renderDraft(inout vec4 c, vec2 ip)\n{\n    vec4 cz = texture( iChannel2, ip);\n    c = cz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n    vec2 ip = vec2(uv);\n\n  \n    vec4 c;    \n  \t\n    renderDraft(c, ip);\n    \n    drawFrame(c,p,aspectRatio);\n   \n    drawPlaying(c, p - vec2(0.35,0.15));\n   \n    fragColor = vec4(vec3(c.xyz),.1);\n   \n    \n    //fragColor = texelFetch( iChannel0, ip , 0);\n    //fragColor = texelFetch( iChannel1, ip , 0);\n   \t//fragColor = texelFetch( iChannel2, ip , 0);\n   \t//fragColor = texelFetch( iChannel2, ip , 0)*texelFetch( iChannel1, ip , 0);\n      \n    fragColor.a = 1.;\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/3dtSW8\n//\n// by @rmmcal  2019/10\n\n// https://soundcloud.com/clemensruh/the-awakening\n\n\nstruct Hit{\n    vec3 p;               // point when hitted\n\tfloat distanceRadius; // min distance 3d radius hit => all sides <=\n    int id;       \t\t  // id hit\n    vec3 color;               // point when hitted\n};\n\nstruct RayHit{\n    vec3 uv;  // TODO: uvtexture\n\tvec3 pos; // current position    \n\tvec3 dir; // current direction\n    vec3 clo; // close \n    vec3 nor; // TODO: normal \n    vec3 refl; // TODO: reflection direction\n    vec3 refr; // TODO: fraction   direction  \n    Hit hit;  // hit object\n    float distanceTotal; // total\n};\n\nHit hit(int id, vec3 p, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.distanceRadius = distanceRadius;\n    hit.color = vec3(1.);\n    return hit;\n}    \n\nHit join(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius < hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;\n    \n}\n\nHit intercept(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius > hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;    \n}\n\nHit sub(Hit hit1, Hit hit2)\n{\n    float d = max(hit1.distanceRadius,-hit2.distanceRadius);\n    Hit h = hit(hit1.id, hit2.p,d );\n    return h;\n}\n\nvec2 rotate(vec2 v, float angle){\n    float c = cos(angle); \n    float s = sin(angle); \n    return mat2(c, s, -s, c) * v;\n}\nvec3 rotate3(vec3 p, float x, float y, float z){\n    p.xz = rotate(p.xz,x);\n    p.yz = rotate(p.yz,y);\n    p.xy = rotate(p.xy,z);\n    return p;\n}\n\nfloat loop2(float f, float p){\n\treturn abs(fract(iTime*f+p)*2.-1.)*2.-1.;\n}\n\n\nHit hit(){\n    Hit h; h.distanceRadius = 1000.; h.color = vec3(1.);\n\treturn h;\n}\nHit mapDistance(vec3 p){\n    Hit h = hit();\n    \n\n    float mont = abs(.2*cos(p.x+cos(p.x)+.1*cos((p.x+p.y)*22.2)+sin(p.z)));\n    float mont2 = .3*min(0., 8.-length(p.xz*.1))*(cos((p.x+.1+5000.1)*0.003)+(cos((p.z+1100.)*0.002)));//;\n    Hit hl = hit(1, p, p.y+1.+ mont + mont2);\n\n    h = join(h, hl);\n    //h = join(h,  hit(3, p, -p.y+300.));\n\n    Hit hc = hit();\n    hc = join(hc, hit(2, p, abs(sdBox(abs(p)*.5-1.,vec3(-0.1,-1.,-.1), vec3(.2,0.5,0.2)))-.01));\n    hc = join(hc, hit(2, p, abs(sdBox(abs(p)*.5-1.,vec3(-0.5), vec3(.11,1.0,0.1)))-.01));\n    hc = join(hc, hit(2, p, abs(sdBox((p)*.5,vec3(0.), vec3(.5,1.0,0.5)))-.01));\n    hc = join(hc, hit(2, p, abs(sdBox((p)*.5,vec3(0.), 1.*vec3(.9,.1,.9)))-.01));\n    hc = join(hc, hit(2, p, abs(sdBox((p)*.5,vec3(0.,-0.3,0.), vec3(1.,.2,1.)))-.01));\n  \n    h = join(h, hc);\n\n    return h;\n}\nvec3 closen(RayHit h){ \n    vec2 f = vec2(1.,0.);\n    vec3 d = normalize(h.dir)*.1;\n    vec3 p = h.pos;\n\tfloat dx = mapDistance(p - d * f.xyx).distanceRadius ;\n\tfloat dy = mapDistance(p - d * f.yxx).distanceRadius ;\n\tfloat dz = mapDistance(p - d * f.yyx).distanceRadius ;\n\treturn normalize(vec3(dx, dy, dz)) ;\n}\n\nvec3 close3d(RayHit h){ \n\treturn normalize(closen(h)) ;\n}\n\n// Calculate vector normal to pos\nvec3 normal3d(RayHit h)\n{\n  vec3 pos = h.pos;\n  vec3 eps = vec3(.1,0.0,0.0);\n  vec3 nor;\n  float ref;\n  nor.x = mapDistance(pos+eps.xyy).distanceRadius - mapDistance(pos-eps.xyy).distanceRadius;\n  nor.y = mapDistance(pos+eps.yxy).distanceRadius - mapDistance(pos-eps.yxy).distanceRadius;\n  nor.z = mapDistance(pos+eps.yyx).distanceRadius - mapDistance(pos-eps.yyx).distanceRadius;\n  return -normalize(nor);\n}\n\nRayHit raymarching(inout RayHit ray)\n{\n    RayHit nohit;\n    ray.uv = ray.dir;\n    \n    //ray\n    for (int i = 0; i < 400; i++)\n    {        \n      \tHit hit = mapDistance(ray.pos);\n        ray.hit = hit;\n        ray.distanceTotal\t+= hit.distanceRadius;           // total\n        ray.pos \t\t\t+= hit.distanceRadius * ray.dir; // walk point to direction\n        \n        if (hit.distanceRadius < .01) break;\t\t\t\t\t\t// so close... performance otimization...\n        if (hit.distanceRadius > 500.) { ray = nohit; break; }\t// so far..... performance otimization...\n \n    }\n    if (ray.pos.x != 0.){\n        ray.clo = close3d(ray);\n        ray.nor = normal3d(ray);\n        ray.refl = reflect(ray.dir, ray.nor );\n    }\n    \n    return ray;\n}\n\nvec3 getColor(RayHit r){\n    vec3 col = vec3(1.)*r.hit.color;\n    vec3 p = r.hit.p;\n    /**\n    switch(r.hit.id)\n    {\n        case 0: \n\t\t\tcol = vec3(0.,0.7,0.9); // sky\n       \t\tbreak;\n        case 1: \n\t\t\tcol *= vec3(.2,0.12,0.1);\n            //col *= (1.+((lad(p.xz*.5)))*.2);\n            col *= (1.+((voronoi(p.xz*3.5)))*.5);\n       \t\tbreak;\n        case 2: \n\t\t\tcol *= vec3(.9,0.9,0.6);\n            col *= 1.-(brick(p*4.)); \n       \t\tbreak;\n      \tcase 3: \n\t\t\tcol *= vec3(.3,0.9,1.1);\n            col *= (1.+((lad(p.xz*.005)))*.3);\n           // col *= (1.+((voronoi(p.xz*3.5)))*.5);\n       \t\tbreak;\n    }\n    /**/\n    \n\tif (r.hit.id == 0)\n    {\n        col = vec3(0.,0.7,0.9); // sky\n    } \n    else if (r.hit.id == 1)\n    {\n        col *= vec3(.2,0.12,0.1);\n        //col *= (1.+((lad(p.xz*.5)))*.2);\n        col *= (1.+((voronoi(p.xz*3.5)))*.5);\n    }\n\telse if (r.hit.id == 2)\n    {\n        col *= vec3(.9,0.9,0.6);\n        col *= 1.-(brick(p*4.)); \n    }\n\telse if (r.hit.id == 3)\n    {\n        col *= vec3(.3,0.9,1.1);\n        col *= (1.+((lad(p.xz*.005)))*.3);\n        // col *= (1.+((voronoi(p.xz*3.5)))*.5);\n    }\n    \n    \n    return col;\n}\nmat2 rotate(float a){\n\treturn mat2(cos(a),sin(a), -sin(a), cos(a));\n}\n\n#define LEN_POS 10\n#define LEN_DIR 9\n\n#define animFrame(t, arr, len, vout) {vout = arr[0].xyzw; for(int i = 0; i < len-1; i++){ vec4 a1 = arr[i  ]; vec4 a2 = arr[i+1]; float t1 = clamp((t-a1.w)/(a2.w-a1.w), 0., 1.); if (t1 <= 0.) break; vout = mix(a1, a2, smoothstep(0., 1., t1));}}\n\n/**\n#define animFrame(t, arr, len, vout) { \t\t\t\t\t\t\\\n    vout = arr[0].xyzw; \t\t\t\t\t\t\t\t\t\\\n    for(int i = 0; i < len-1; i++)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        vec4 a1 = arr[i  ]; \t\t\t\t\t\t\t\t\\\n        vec4 a2 = arr[i+1];\t\t\t\t\t\t\t\t\t\\\n        float t1 = clamp((t-a1.w)/(a2.w-a1.w), 0., 1.);\t\t\\\n        if (t1 <= 0.) break;\t\t\t\t\t\t\t\t\\\n        vout = mix(a1, a2, smoothstep(0., 1., t1));\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n/**/\n\n/**\nvoid animFrame(t, arr, vout) { \t\t\t\t\t\t\t\\\n    vout = arr[0].xyzw; \t\t\t\t\t\t\t\t\t\\\n    for(int i = 0; i < arr.length()-1; i++)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        vec4 a1 = arr[(i  )%arr.length()]; \t\t\t\t\t\\\n        vec4 a2 = arr[(i+1)%arr.length()];\t\t\t\t\t\\\n        float t1 = clamp((t-a1.w)/(a2.w-a1.w), 0., 1.);\t\t\\\n        if (t1 <= 0.) break;\t\t\t\t\t\t\t\t\\\n        vout = mix(a1, a2, smoothstep(0., 1., t1));\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n/**/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n    \n    RayHit r;\n    \n    float speed =.2;\n    float totalTime = 30.;\n     float stopMotion = 5.;// 4 frames per sec\n    \n    totalTime /= speed;\n    float t = fract((iTime+0.)/totalTime)*totalTime;\n    \n    t = floor(t*stopMotion)/stopMotion;\n    t *= speed;\n    \n    /**\n    vec4 animPos[] = vec4[]( // keyframes positions\n    \t vec4(0.0,+09.9,-80.0,00.0)\n    \t,vec4(0.0,-00.9,-80.0,02.0)\n    \t,vec4(0.0,+01.0,-04.0,05.0)\n    \t,vec4(10.,+01.0,-10.0,10.0)\n    \t,vec4(0.0,+01.0,+05.0,15.0)\n    \t,vec4(0.0,+10.0,-10.0,20.0)\n    \t,vec4(0.1,+10.0,-10.0,21.0)\n    \t,vec4(0.0,+20.0,-10.0,21.01)\n        ,vec4(0.0,+130.0,-10.0,30.0)\n        ,vec4(0.0,+80.0,-10.0,40.0)\n    ); \n    \n    vec4 animDir[] = vec4[]( // keyframes orientation\n    \t vec4(0.0,+00.25,+00.0,00.0)\n    \t,vec4(0.0,+00.0,-00.0,02.0)\n    \t,vec4(0.10,+00.0,-00.0,10.0)\n    \t,vec4(0.2,+00.0,-00.0,13.0)\n    \t,vec4(0.6,+00.1,+00.0,15.0)\n    \t,vec4(0.0,+00.12,-00.0,20.0)\n        ,vec4(0.0,+00.12,-00.0,21.00)\n        ,vec4(0.0,+00.18,-00.0,21.01)\n        ,vec4(0.0,+00.25,-00.0,30.01)\n        \n    );\n    /**/\n    \n    \n    vec4 animPos[10];  // keyframes positions\n    animPos[0] = vec4(0.0,+09.9,-80.0,00.0);\n    animPos[1] = vec4(0.0,-00.9,-80.0,02.0);\n    animPos[2] = vec4(0.0,+01.0,-04.0,05.0);\n    animPos[3] = vec4(10.,+01.0,-10.0,10.0);\n    animPos[4] = vec4(0.0,+01.0,+05.0,15.0);\n    animPos[5] = vec4(0.0,+10.0,-10.0,20.0);\n    animPos[6] = vec4(0.1,+10.0,-10.0,21.0);\n    animPos[7] = vec4(0.0,+20.0,-10.0,21.01);\n    animPos[8] = vec4(0.0,+130.0,-10.0,30.0);\n    animPos[9] = vec4(0.0,+80.0,-10.0,40.0);\n    \n    \n    vec4 animDir[9];  // keyframes orientation\n    animDir[0] = vec4(0.0,+00.25,+00.0,00.0);\n    animDir[1] = vec4(0.0,+00.0,-00.0,02.0);\n    animDir[2] = vec4(0.10,+00.0,-00.0,10.0);\n    animDir[3] = vec4(0.2,+00.0,-00.0,13.0);\n    animDir[4] = vec4(0.6,+00.1,+00.0,15.0);\n    animDir[5] = vec4(0.0,+00.12,-00.0,20.0);\n    animDir[6] = vec4(0.0,+00.12,-00.0,21.00);\n    animDir[7] = vec4(0.0,+00.18,-00.0,21.01);\n    animDir[8] = vec4(0.0,+00.25,-00.0,30.01);\n        \n    \n    vec4 pos = animPos[0].xyzw;\n    vec4 dir = animDir[0].xyzw;\n\n    animFrame(t, animPos, LEN_POS, pos);\n    animFrame(t, animDir, LEN_DIR, dir);\n\n    r.pos = pos.xyz;\n    r.dir = vec3(p.xy*1.,1.);\n    r.dir.xy = rotate(r.dir.xy,+dir.z*PI2);\n    r.dir.yz = rotate(r.dir.yz,+dir.y*PI2);\n    r.dir.xz = rotate(r.dir.xz,+dir.x*PI2);\n \n    raymarching(r);\n   \n    vec3 col = getColor(r);\n    fragColor = vec4(vec3(col)*(+.7+.3*(r.nor))*(r.clo.z+.5),r.distanceTotal);\n\n    fragColor = mix(fragColor, texture(iChannel0, uv) , .3);\n\tfragColor = clamp(fragColor,0.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n    vec2 ip = vec2(fragCoord);\n   \tvec4 c;// = texture(iChannel0,uv);\n \n    float r = 0.;\n\n\tvec2 rs = iResolution.xy;\n    float r1 = 0.;\n    r1  = texture( iChannel0, (ip + vec2(0.,0.))/rs ).z / texture( iChannel0, (ip + vec2(1.,0.))/rs).z;\n    r1 += texture( iChannel0, (ip + vec2(0.,0.))/rs ).z / texture( iChannel0, (ip + vec2(0.,1.))/rs).z;\n\n    float r2 = 0.;\n    r2 += texture( iChannel0, (ip + vec2(0.,0.))/rs ).z / texture( iChannel0, (ip + vec2(-1.,0.))/rs).z;\n    r2 += texture( iChannel0, (ip + vec2(0.,0.))/rs ).z / texture( iChannel0, (ip + vec2(0.,-1.))/rs).z;\n   \n    r = (r1/r2);\n    fragColor = vec4(vec3(c.xyz),.1);\n    fragColor = vec4(vec3(r),.1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void renderDraft(inout vec4 c, vec2 ip)\n{\n    vec4 cz = texture( iChannel0, ip);\n\tfloat z = clamp(pow(cz.w*.1,15.)+1.0,0.,10.);\n   \t\n    for (int i = 0; i < 9; i++){\n        c+=clamp(texture( iChannel1, ip + ((z)*vec2(modi(i,3)-1, i/3-1)+vec2(  cos(float(i))*5. , float(i)*1. ))/iResolution.xy  ), 0., 1.)/9.0;\n    }\n   // c = texture( iChannel0, ip);\n}\n\n/**\nvoid renderDraft2(inout vec4 c, vec2 ip){\n    vec4 cr;\n    vec4 cz = texture( iChannel0, ip);\n\tfloat z = clamp(abs(cz.w*0.05)+1.0,0.,1.);\n  \n    for (int i = 0; i < 8; i++){\n        float fi =  float(i);\n         cr+=clamp(texture( iChannel1, ip + (  cos(fi/2.)*4.*z , sin(fi/28.)*11.*z ) ), 0., 1.)/8.0  ;\n    }\n    c*=cr*.2+.8;\n}\n/**/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n    vec2 ip = vec2(uv);\n   \n    \n    \n    vec4 c;    \n    renderDraft(c, ip);\n//    renderDraft2(c, ip);\n\n\n    \n \t//c = smoothstep(-4.,100.,c);\n    //c = 1.-smoothstep(-0.,.01,c);\n    //c = c / (1.-c);\n    //c = c / (1.-c);\n    //c = c / (1.-c);\n    c = smoothstep(-.1,1.2,c);\n    \n    // c = c / (.9-c);\n\n    fragColor = vec4(vec3(c.xyz),.1);\n\n    fragColor.a = 1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI =3.14159265359;\nconst float PI2 = 2.*PI;\nconst float PI3 = 3.*PI;\nconst float PIH =.5*PI;\nconst float PIHh = PIH+PIH*.5;\n\n\nint modi(int a, int n){\n\treturn a - (n * int(a/n));\n}\n\nfloat sphere(vec3 p, vec3 t, float radius){\n    return length(p-t)-radius; //length(s)\n}\n\nfloat box(vec3 p, vec3 t, vec3 s) { \n    return length(max(abs(p-t)-s,0.0)); \n}\nfloat sdBox( vec2 p, vec2 t, vec2 b )\n{\n    p-=t;\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\nfloat sdBox( vec3 p, vec3 t,vec3 b )\n{\n    p-=t;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat line( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat lad(vec2 p){\n\tfloat sy = sign(mod(p.y,2.)-1.);                        \n        p+= vec2(step(0.,sy)*1.,0.);\n\tsy = sign(mod(p.y,2.)-1.);                        \n        float  sx = sign(mod(p.x,2.)-1.);                        \n\tvec2 p1 = fract(p)-.5;\n\tfloat pd = dot( cos(  2.*(10.) * sx * max(0.,.5-length(p1)) - vec2(33,0) ), p1);  \n\tfloat sc = (sy*pd);\n\treturn step(0., sc);\n}\n\nfloat brick(vec2 p){\n\tvec2 vBrickPos = p.xy;\n\tvBrickPos.x += floor(vBrickPos.y * 3.0) * 0.5;\n\tvBrickPos = fract(vBrickPos * vec2(1.0, 3.0));\n    return 1.0 - step(vBrickPos.x, 0.96) * step(vBrickPos.y, 0.9);\n \n}\n\n\nfloat brick(vec3 p3d){\n  \tp3d.x  += p3d.z;\n    vec2 p = p3d.xy;\n\tvec2 brickPos = p.xy;\n\tbrickPos.x += floor(brickPos.y * 3.0) * 0.5;\n\tbrickPos = fract(brickPos * vec2(1.0, 3.0)+vec2(0.,.5));\n   // return 1.0 - step(brickPos.x, 0.96) * step(brickPos.y, 0.9);\n    \n    return  1.-\n        smoothstep(-0.1,0.0, +.0+abs(brickPos.x*2.-1.)-.1)*\n        smoothstep(-0.2,0.21, -.0+abs((brickPos.y)*2.-1.)-.1)\n        ;\n\n}\nfloat brick(vec3 p, float s)\n{\n   \tp.xz +=.1;\n    p *= s;\n    return max(brick(p.zy),brick(p.xy)); \n}\n\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec4 voronoi2d( in vec2 x )\n{\n\t   \n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2  g = vec2( float(i), float(j) );\n\t\tvec2  o = hash( n + g );\n\t\tvec2  r = g - f + (0.5+0.5*sin(6.2831*o));\n\t\tfloat d = dot( r, r );\n\t\tif( d<m.x )\n\t\t\tm = vec3( d, o );\n\t}\n\n\tvec4 c = vec4( sqrt(m.x), m.y+m.z, vec2(m.xy) );\n\t\n\treturn c;\n}\n\nfloat veronoib(vec2 p, float f){\n    vec2 e = vec2(f,0.);\n    vec4 v = voronoi2d(p);\n    vec4 v1 = voronoi2d(p+e.xy);\n    vec4 v2 = voronoi2d(p+e.yx);\n    float vf1 = abs(v.y-v1.y) ;\n    float vf2 = abs(v.y-v2.y) ;\n    return smoothstep(0., 0.001, max(vf1,vf2));\n}\n\nfloat voronoi( in vec2 x ){\n    vec2 c = voronoi2d( x ).xy;\n\treturn 0.5 + 0.5*cos( c.y*6.2831 + 0.0 );\n}\n","name":"Common","description":"","type":"common"}]}