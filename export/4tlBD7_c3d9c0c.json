{"ver":"0.1","info":{"id":"4tlBD7","date":"1512106161","viewed":263,"name":"Candy Architecture","username":"zackpudil","description":"meh.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","shinny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// surface used for bump map\nfloat surf(vec2 p) {\n\tp = mod(p + 1.0, 2.0) - 1.0;\n\t\n\tfor(int i = 0; i < 4; i++) {\n\t\tp = abs(p)/clamp(dot(p, p), 0.5, 1.0) - vec2(0.6);\n\t}\n\t\n\treturn smoothstep(0.1, 1.0, abs(p.y));\n}\n\n// simple cube map for 3d->2d\nfloat sc(vec3 p, vec3 n) {\n\tvec3 m = pow(abs(n), vec3(10.0));\n\t\n\tfloat x = surf(p.yz);\n\tfloat y = surf(p.xz);\n\tfloat z = surf(p.xy);\n\t\n\treturn (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\n// bump the normals.\nvec3 bump(vec3 p, vec3 n) {\n\tvec2 h = vec2(0.009, 0.0);\n\tvec3 g = vec3(\n\t\tsc(p + h.xyy, n) - sc(p - h.xyy, n),\n\t\tsc(p + h.yxy, n) - sc(p - h.yxy, n),\n\t\tsc(p + h.yyx, n) - sc(p - h.yxy, n)\n\t);\n\tg -= n*dot(n, g);\n\t\n\treturn normalize(n + 5.0*g);\n}\n\n// Defines the geometry of the scene.\nfloat de(vec3 p) {\n\tvec4 q = vec4(p, 1);\n\t\n    // Yet again, I use the abs box \"fractal\"\n\tq.xzy -= 1.0;\n\tq.y -= 1.5;\n\tfor(int i = 0; i < 3; i++) {\n\t\tq.xyz = abs(q.xyz + 1.0) - 1.0;\n\t\tq /= clamp(dot(q.xyz, q.xyz), 0.4, 1.0);\n\t\tq *= 1.2;\n\t}\n\t\n\treturn min((length(q.xz) - 1.2)/q.w, \n           // 5 plans to make a box with no ceiling\n\t\t   min(p.y + 1.0, min(\n\t\t\t   min(p.x + 3.2, p.z + 3.2),\n\t\t           min(-p.x + 3.2, -p.z + 3.2))));\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001 || t >= mx) break;\n\t\tt += d*0.65;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005;\n\tfloat w = 1.0;\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d)*w;\n\t\tw *= 0.95;\n\t\ts += s/float(i + 1);\n\t}\n\t\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.25);\n\tfloat t = trace(ro, rd, 10.0);\n\tif(t < 10.0) {\n\t\tvec3 pos = ro + rd*t;\n\t\tvec3 nor = bump(pos, normal(pos));\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat occ = ao(pos, nor);\n\t\t\n        // very bright ambient.  Tone mapping allows this (see bottom).\n\t\tcol = vec3(occ);\n        col += clamp(dot(-rd, nor), 0.0, 1.0);\n        \n        // using cube maps for material.\n        if(length(pos.xz) < 3.0)\n        \tcol *= texture(iChannel0, pos + sin(pos.y*pos.x)).rgb;\n        else\n            col *= texture(iChannel1, pos + cos(2.0*pos.y)).rgb;\n        \n        // darken the edges of the surface bump.\n        col *= (0.2 + 0.8*sc(pos, nor));\n        \n        // just using a specular light, for the shinniness.\n\t\tcol += 2.0*pow(clamp(dot(ref, -rd), 0.0, 1.0), 30.0)*occ;\n\n\t}\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n    // camera position and lookat.\n\tvec3 ro = vec3(2.5*cos(iTime*0.5), 1, -2.8*sin(iTime*0.5));\n    vec3 la = vec3(sin(0.3*iTime), 1.0, cos(0.3*iTime));\n\n\tvec3 ww = normalize(la-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.97*ww);\n\t\n\tvec3 col = render(ro, rd);\n\t\n    // tone mapping and gamma correction.\n\tcol = 1.0 - exp(0.4*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\t\n\t//col = vec3(surf(p));\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}