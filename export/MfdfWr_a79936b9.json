{"ver":"0.1","info":{"id":"MfdfWr","date":"1732981326","viewed":109,"name":"little symbols","username":"lem","description":"just testing some  basic symbol creation","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["symbols"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdRhombus(vec2 p, vec2 b) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0*b.x + b.y - q.x*0.5)/2.0, 0.0, b.y);\n    return length(vec2(q.x*0.5 + h, q.y - h)) - 0.01;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nvec4 createDetailedCube(vec2 p, float type, float time) {\n    float shape = 1.0;\n    vec3 color = vec3(0.1);\n    float lines = 1.0;\n    \n    // Scale for denser detail\n    p *= 1.2;\n    \n    if (type < 1.0) {\n        // Detailed isometric cube with internal lines\n        float mainShape = min(\n            sdRhombus(p + vec2(0.0, 0.02), vec2(0.15)),\n            min(\n                sdRhombus(p + vec2(0.1, -0.05), vec2(0.15)),\n                sdRhombus(p + vec2(-0.1, -0.05), vec2(0.15))\n            )\n        );\n        shape = step(0.0, mainShape);\n        \n        // Internal detail lines\n        for(float i = 0.0; i < 3.0; i++) {\n            lines = min(lines, step(0.0, sdLine(p, \n                vec2(sin(i*2.09+1.0)*0.1, cos(i*2.09+1.0)*0.1),\n                vec2(sin(i*2.09)*0.1, cos(i*2.09)*0.1)) - 0.005));\n        }\n    } \n    else if (type < 2.0) {\n        // Complex stacked cube\n        for(float i = 0.0; i < 4.0; i++) {\n            float offset = i * 0.05;\n            shape = min(shape, step(0.0, sdBox(p + vec2(offset, -offset), vec2(0.08 - offset*0.3))));\n        }\n        \n        // Detail lines\n        for(float i = 0.0; i < 5.0; i++) {\n            float y = -0.1 + i * 0.05;\n            lines = min(lines, step(0.0, sdLine(p, vec2(-0.1, y), vec2(0.1, y)) - 0.002));\n        }\n    }\n    else if (type < 3.0) {\n        // Deconstructed cube with internal structure\n        float ang = time * 0.2;\n        for(float i = 0.0; i < 3.0; i++) {\n            vec2 offset = vec2(cos(ang + i*2.09), sin(ang + i*2.09)) * 0.1;\n            shape = min(shape, step(0.0, sdBox(p + offset, vec2(0.06))));\n            \n            // Internal grid for each box\n            vec2 gridUV = fract((p + offset) * 5.0) - 0.5;\n            lines = min(lines, step(0.45, max(abs(gridUV.x), abs(gridUV.y))));\n        }\n    }\n    else {\n        // Geometric abstraction with multiple elements\n        for(float i = 0.0; i < 6.0; i++) {\n            float ang = i * 3.14159 / 3.0;\n            vec2 dir = vec2(cos(ang), sin(ang)) * 0.1;\n            shape = min(shape, step(0.0, sdBox(p + dir, vec2(0.03))));\n        }\n        \n        // Connecting lines\n        for(float i = 0.0; i < 3.0; i++) {\n            float ang = i * 3.14159 / 3.0;\n            lines = min(lines, step(0.0, sdLine(p, \n                vec2(cos(ang), sin(ang)) * 0.1,\n                vec2(cos(ang + 2.09), sin(ang + 2.09)) * 0.1) - 0.002));\n        }\n    }\n    \n    // Accent colors\n    vec3 accentColor1 = vec3(0.9, 0.2, 0.1); // Red\n    vec3 accentColor2 = vec3(0.1, 0.4, 0.8); // Blue\n    vec3 accentColor3 = vec3(0.8, 0.6, 0.1); // Gold\n    \n    float accent = step(p.y, 0.0) * step(0.0, sin(time + type * 2.0));\n    color = mix(color, mix(accentColor1, accentColor2, step(2.0, type)), accent);\n    \n    // Add lines as subtle detail\n    color = mix(color, mix(color, accentColor3, 0.3), 1.0 - lines);\n    \n    return vec4(color, 1.0 - shape);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    // Create denser grid (3x3)\n    float gridSize = 3.0;\n    vec2 cell = floor(uv * gridSize + 1.0);\n    vec2 localUv = fract(uv * gridSize + 1.0) - 0.5;\n    \n    // Background\n    vec3 bgColor = vec3(0.95, 0.93, 0.91);\n    float grid = step(0.98, max(fract(uv.x * 16.0), fract(uv.y * 16.0)));\n    bgColor = mix(bgColor, vec3(0.9, 0.88, 0.86), grid);\n    \n    // Create cube variation\n    float type = mod(cell.x + cell.y * gridSize, 4.0);\n    vec4 cube = createDetailedCube(localUv, type, iTime);\n    \n    // Combine colors with subtle shadow\n    vec3 color = mix(bgColor, cube.rgb, cube.a);\n    float shadow = smoothstep(0.0, 0.5, length(localUv));\n    color *= 0.95 + 0.05 * shadow;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}