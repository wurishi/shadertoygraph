{"ver":"0.1","info":{"id":"3s3cRj","date":"1601327510","viewed":168,"name":"Spirographicius","username":"GCScholar","description":"Some values for the spirograph equation. \nModify #define HOW_MANY_BALLS to change the ball number\nFake shadow, lol.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["sphirograph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background\n    fragColor =vec4(0);\n\t\n    // Spheres\n    vec2 UV = fragCoord/iResolution.xy;\n    vec4 spheres = texture(iChannel0, UV);\n    if(spheres != vec4(0.0)) fragColor = spheres;\n    \n     // Gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define HOW_MANY_BALLS 250.0\n\n#define FREQUENCY 0.4\n#define PI 3.14 \n#define MAX_MARCHING_DISTANCE 10.0\n#define FOCAL_LENGTH 2.5\n\n// Input keys\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_S = 83;\nconst int KEY_W = 87;\nconst int KEY_Y = 89;\nconst int KEY_H = 72;\n\n\n// SIGNED DISTANCE FUNCTIONS. Tnx https://iquilezles.org/articles/distfunctions\nfloat SD_Sphere(vec3 P, float r) { return length(P) - r; }\nfloat SD_Plane( vec3 p, vec3 n, float h ) { return dot(p,n) + h; }\nvec2 SD_OpUnion(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec2 Sphirograph(float t, float l, float k, float R1) \n{\n    vec2 P;\n    P.x = R1*(1.0-k)*cos(t) + l*k*cos((1.0-k)/k *t);\n    P.y = R1*(1.0-k)*sin(t) + l*k*sin((1.0-k)/k *t);\n    return P;\n}\n\nvec2 Sphirograph2(float t, float r, float R, float Q) \n{\n    vec2 P;\n    P.x = R*cos(t) + r*cos(Q*t);\n    P.y = R*sin(t) + r*sin(Q*t);\n    return P;\n}\n\nfloat K[10] = float[10](0.1, 0.8, 0.3, 0.6, 0.5, 0.4, 0.7,0.2,0.9,0.1);\nfloat R1[10] = float[10](1.3, 1.6, 0.2, 0.2, 0.2, 0.2, 0.2,0.2,0.2,0.2);\nfloat L[10] = float[10](0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7,0.8,0.9,1.0);\n\nfloat R[3] = float[3](0.4, 0.5, 0.6);\nfloat r[2] = float[2](0.2, 0.3);\n\nfloat QN[13] = float[13](2.0, 7.0, 11.0, 5.0, -11.0, 4.0, -4.0, 5.0, -3.0, 6.0, 7.0, -2.0, 4.0);\nfloat QD[4] = float[4](2.0, 3.0, 5.0, -3.0);\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Transform UV coords to a linear index from 1 to (iResolution.x*iResolution.y)\n   Remember that UV range from 0.5 to iResolution - 0.5 */\nint fragCoordToLinear(vec2 fragCoord) \n{\n\treturn int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint t = fragCoordToLinear(fragCoord);\n\t\n    int r_id = int(mod(iTime*FREQUENCY, float(r.length())));\n    int R_id = int(mod(iTime*FREQUENCY, float(R.length())));\n    int QN_id = int(mod(iTime*FREQUENCY, float(QN.length())));\n    int QD_id = int(mod(iTime*FREQUENCY, float(QD.length())));\n\t\n    //vec2 P = Sphirograph(float(t), L[currentPeriod], K[currentPeriod], R[currentPeriod]);\n    vec2 P = Sphirograph2(float(t), r[r_id], R[R_id], QN[QN_id]/QD[QD_id]);\n    fragColor = vec4(P, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Transform UV coords to a linear index from 1 to (iResolution.x*iResolution.y)\n   Remember that UV range from 0.5 to iResolution - 0.5 */\nint fragCoordToLinear(vec2 fragCoord) \n{\n\treturn int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint t = fragCoordToLinear(fragCoord);\n\t\n    int r_id = int(mod(iTime*FREQUENCY+1.0, float(r.length()))) ;\n    int R_id = int(mod(iTime*FREQUENCY+1.0, float(R.length())));\n    int QN_id = int(mod(iTime*FREQUENCY+1.0, float(QN.length())));\n    int QD_id = int(mod(iTime*FREQUENCY+1.0, float(QD.length())));\n\t\n\tvec2 P = Sphirograph2(float(t), r[r_id], R[R_id], QN[QN_id]/QD[QD_id]);\n    \n    //vec2 P = Sphirograph(float(t), L[currentPeriod], K[currentPeriod], R[currentPeriod]);\n\t\n\tfragColor = vec4(P, 0.0, 0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Draw a circular point P with a radius of r\n#define drawPoint(P, r) step( length(U - P), r)\n\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/* Transform UV coords to a linear index from 1 to (iResuluation.x*iResuluation.y)\n   Remember that UV range from 0.5 to iResolution - 0.5 */\nint fragCoordToLinear(vec2 fragCoord) \n{\n\treturn int((fragCoord.y-0.5) * iResolution.x + (fragCoord.x+0.5));\n}\n\n/* Get uv coord from linear index */\nvec2 linearToFragCoord(int i) \n{\n\treturn vec2(mod(float(i), iResolution.x) - 0.5, floor(float(i) / iResolution.x) - 0.5); \n}\n\n/* Pos is the linear index obtained with fragCoordToLinear */\nvec4 loadTexelChannel0(int linearIndex) \n{\n\treturn texture(iChannel0, linearToFragCoord(linearIndex)/iResolution.xy);\n}\n\n/* Pos is the linear index obtained with fragCoordToLinear */\nvec4 loadTexelChannel1(int linearIndex) \n{\n\treturn texture(iChannel1, linearToFragCoord(linearIndex)/iResolution.xy);\n}\n    \n// Define materials in the scene\nvec3 material(float id) \n{\n   \treturn vec3(0., 0.1, 0.2);\n}\n\nfloat hit_sphere(vec3 center, float radius, vec3 ro, vec3 rd)\n{\n    vec3 oc = ro - center;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant<0.0) \n    {\n    \treturn -1.0;\n    }\n    else\n    {\n\t\tfloat numerator = -b - sqrt(discriminant);\n\t\tif (numerator > 0.0) return numerator / (2.0 * a);\n\t\tnumerator = -b + sqrt(discriminant);\n\t\tif(numerator > 0.0) return numerator / (2.0 * a);\n\t\treturn -1.0;\n\t}\n}\n\nstruct Hit \n{\n    float d;\n    float mat;\n\tvec3 point;\n    vec3 normal;\n};\n    \nHit rayTraceScene(vec3 eye, vec3 rd) \n{\n\tHit hit;\n    hit.mat = -1.0;\n    float d_min = MAX_MARCHING_DISTANCE;\n   \n    // Ray tracing spheres\n    \n    for(int i=0; i<int(HOW_MANY_BALLS) ; i++)\n    {\t\n        // Compute sphere position\n        vec3 S = mix(loadTexelChannel0(i).xyz, loadTexelChannel1(i).xyz, clamp(fract(iTime*FREQUENCY)*4.0,0.0,1.0)).xzy + vec3(sin(iTime)*0.1);\n\t\t    \n        float d = hit_sphere(S, mix(0.03,0.04,sin(float(i)*3.223432)) , eye, rd);\n        if(d>0.0) \n        {\n            if(d < d_min) \n            {\t\n                d_min = d;\n                hit.d = d_min;\n                hit.mat = 1.0;\n                hit.point = eye+hit.d*rd;\n                hit.normal = normalize(hit.point-S);\n            }\n        }\n    }\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Screen space coordinates\n    vec2 U = 2.0*(fragCoord/iResolution.y) - iResolution.xy/iResolution.y;\n    \n    // Camera\n   \tvec2 camAngle = iMouse.xy/iResolution.xy * 2.0 * PI;\n    vec3 target = vec3(0.0);\n    vec3 eye = vec3(1.3*cos(iTime), mix(0.,1.4,sin(iTime*0.5)*sin(iTime*0.5))*1.14, 1.3*sin(iTime));\n        \n    // Right handed camera frame reference\n    vec3 ww = normalize(vec3(eye-target));\n    vec3 vv = normalize(cross(vec3(0.0,1.0,0.0),ww));\n    vec3 uu = normalize(cross(ww,vv));\n    \n    // Ray march scene\n    vec3 rd = normalize(U.x*vv+U.y*uu-FOCAL_LENGTH*ww);\n    \n    Hit hit;\n    hit.mat = -1.;\n    hit = rayTraceScene(eye, rd);\n\t\n    // Shading\n    vec3 R = reflect(rd, hit.normal);\n    \n    if(hit.mat != -1.0) \n    {\t\n        float ks;\n        if(hit.mat == 0.0) ks = 0.0;\n        else ks = 1.0;\n        \n        vec3 lin=vec3(0.0,0.0,0.0);\n        vec3 mat = material(hit.mat);\n        \n        {\n            vec3  lig = normalize( vec3(1.5, 0.4, 0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( hit.normal, lig ), 0.0, 1.0 );\n            dif += clamp( dot( hit.normal, -lig ), 0.0, 1.0 );\n            float spe = pow( clamp( dot( hit.normal, hal ), 0.0, 1.0 ),16.0);\n            lin += mat*spe*2.20*dif*vec3(1.30,1.00,0.70);    \n        }\n        \n        // sky\n        {\n            vec3  lig = normalize( vec3(0.0, 1.0, 0.0) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp(dot(hit.normal,lig), 0.0, 1.0 );\n            float spe = pow( clamp( dot( hit.normal, hal ), 0.0, 1.0 ),16.0);\n           // spe *= dif;\n           // spe *= 0.04+0.96*pow(clamp(1.0+dot(hit.normal,rd),0.0,1.0), 5.0 );\n            lin += mat*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n       \n        fragColor = vec4(lin,1.0);\n    }\n    else fragColor = vec4(0.0);\n    \n    \n}","name":"Buffer C","description":"","type":"buffer"}]}