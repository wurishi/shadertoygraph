{"ver":"0.1","info":{"id":"4d2yDw","date":"1492362057","viewed":415,"name":"JPEG.","username":"Loeizd","description":"Just the YCbCr conversion with lower resolution Cb and Cr (color channels) + some fun with the buffer + some shitty noise instead of discrete cosine transform.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["jpeg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(texture(iChannel0, uv));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 noiseIt(vec4 img)\n{\n\treturn vec4(sin(img.x*9897.), sin(img.y*7654.8),sin(img.z*97.), 1.);    \n}\nvec4 toYCbCr(vec4 rgb)\n{\n    rgb = rgb * 255.;\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;  \n\treturn vec4(0.299*r+0.587*g+0.114*b,\n               128.-0.168736*r-0.331264*g+0.5*b,\n               128.+0.5*r-0.418688*g-0.081312*b,\n               1.);\n}\n    \n\nvec4 toRGB(vec4 ybr)\n{\n    float y = ybr.x;\n    float b = ybr.y;\n    float r = ybr.z;  \n\treturn vec4(y+1.402*(r-128.),\n               y-0.344136*(b-128.)-0.714136*(r-128.),\n               y+1.772*(b-128.),\n               1.)\n        \t\t/255.;\n}\n    \n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    vec2 offset = vec2(sin(iDate.w)*0.01, 0.015);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float steps = 20.;\n    vec2 puv = floor(uv*steps+.5)/steps;\n\n    vec4 img = texture(iChannel1, uv+offset);\n    vec4 pimg = texture(iChannel1, puv+offset);\n    \n    //C = toRGB(toYCbCr(img));\n   \n    //C = toRGB(toYCbCr(img));\n    img = toYCbCr(img);\n    pimg = toYCbCr(pimg);\n    \n    vec4 finalmix = toRGB(vec4(img.x, pimg.yz, 1.));\n    \n    //add noise\n    finalmix = mix(finalmix, noiseIt(toRGB(pimg)), 0.05) *0.95;\n\n    \n    // london\n    vec4 london = toYCbCr(texture(iChannel0, uv));\n    vec4 plondon = toYCbCr(texture(iChannel0, puv));\n    \n    london = toRGB(vec4(london.x, plondon.yz, 1.));\n    \n   // vec4 london = texture(iChannel0, uv);\n    \n    C = max(london,finalmix);\n    //C = mix(london, finalmix, sin(iDate.w*.5)*.5+0.45);\n    //C = toRGB(toYCbCr(vec4(img.x, pimg.yzw)));\n    \n    //C = vec4(C.y);\n}","name":"Buf A","description":"","type":"buffer"}]}