{"ver":"0.1","info":{"id":"XcGcDd","date":"1732533380","viewed":84,"name":"Infinite Black Room_2","username":"Bakju","description":"Room","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["room"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 128\n#define MAX_DIST 100.0\n#define MIN_DIST 0.001\n\n// Rotation matrix\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Repeated space\nvec3 repeat(vec3 p, vec3 s) {\n    return mod(p + 0.5*s, s) - 0.5*s;\n}\n\n// Distance functions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCross(vec3 p, float b) {\n    float da = sdBox(p.xyz, vec3(b, b/4.0, b/4.0));\n    float db = sdBox(p.yzx, vec3(b/4.0, b, b/4.0));\n    float dc = sdBox(p.zxy, vec3(b/4.0, b/4.0, b));\n    return min(da, min(db, dc));\n}\n\nfloat map(vec3 p) {\n    // Moving down the tunnel\n    vec3 p1 = p;\n    p1.z -= iTime * 2.0;\n    \n    // Repeat structure along tunnel\n    vec3 rep = vec3(2.0, 1.0, 8.0);\n    vec3 cell = floor(p1/rep);\n    p1 = repeat(p1, rep);\n    \n    // Rotate based on position\n    p1.xy *= rot(cell.z * 0.1 + iTime * 0.2);\n    \n    // Main tunnel structure\n    float tunnel = -sdBox(p1, vec3(2.0, 2.0, 4.0));\n    \n    // Add architectural details\n    float pillars = sdBox(p1, vec3(1.8, 0.2, 3.8));\n    float crossBeams = sdCross(p1, 0.2);\n    \n    // Combine elements\n    float structure = min(pillars, crossBeams);\n    \n    // Add variation based on cell position\n    float variation = sin(cell.z * 0.6) * 0.1;\n    \n    return max(tunnel, structure) + variation;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // Mouse control for camera rotation\n    if(iMouse.z > 0.0) {\n        rd.yz *= rot((mo.y - 0.5) * 2.0);\n        rd.xz *= rot((mo.x - 0.5) * 6.0);\n    }\n    \n    // Raymarching\n    float t = 0.0;\n    float d;\n    vec3 p;\n    \n    for(int i = 0; i < STEPS; i++) {\n        p = ro + rd * t;\n        d = map(p);\n        if(abs(d) < MIN_DIST || t > MAX_DIST) break;\n        t += d;\n    }\n    \n    // Coloring\n    vec3 col;\n    if(t < MAX_DIST) {\n        vec3 n = getNormal(p);\n        \n        // Base material color\n        vec3 baseCol = vec3(0.6, 0.8, 1.0);\n        \n        // Lighting\n        vec3 light = normalize(vec3(1.0, 5.0, -3.0));\n        float diff = max(0.0, dot(n, light));\n        float spec = pow(max(0.0, dot(reflect(-light, n), -rd)), 32.0);\n        \n        // Add architectural patterns\n        float pattern = mod(p.z * 0.5 + p.x * 0.5 + p.y * 0.5, 1.0);\n        pattern = smoothstep(0.45, 0.55, pattern);\n        \n        // Combine lighting\n        col = baseCol * (diff * 0.7 + 0.5);\n        col += spec * 0.5;\n        col *= 0.8 + pattern * 0.2;\n        \n        // Distance fog\n        col *= exp(-t * 0.05);\n    } else {\n        col = vec3(0.0);\n    }\n    \n    // Tone mapping and gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}