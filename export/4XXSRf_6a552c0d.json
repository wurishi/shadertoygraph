{"ver":"0.1","info":{"id":"4XXSRf","date":"1710175736","viewed":275,"name":"Voroboids","username":"3t13nn3","description":"A simple example of boids interaction with Voronoi cells centered around each boid.","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","simulation","interaction","swarm","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to check if a point is inside a triangle\nbool isInsideTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    float A = 0.5 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\n    float sign = sign(A);\n    float s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\n    float t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\n\n    return s > 0.0 && t > 0.0 && (s + t) < 2.0 * A * sign;\n}\n\n// Function to check if a point is near the border of a triangle\nbool isNearBorder(vec2 p, vec2 a, vec2 b, vec2 c, float width) {\n    vec2 ba = b - a;\n    vec2 cb = c - b;\n    vec2 ac = a - c;\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    vec2 pc = p - c;\n\n    float d1 = abs(ba.x * pa.y - ba.y * pa.x) / length(ba);\n    float d2 = abs(cb.x * pb.y - cb.y * pb.x) / length(cb);\n    float d3 = abs(ac.x * pc.y - ac.y * pc.x) / length(ac);\n\n    return (d1 < width || d2 < width || d3 < width);\n}\n\n// Function to calculate Voronoi color at a specific coordinate\nvec4 voronoi(in vec2 coord) {\n    float minDist = 1e5;\n    int closestCenter = 0;\n    float secondClosestDist = 1e5;\n    int secondClosestCenter = 0;\n\n    // Find the two closest boids to the current coordinate\n    for (int i = 0; i < numBoids; ++i) {\n        vec2 boidPos = readBoid(i, iChannel0).pos;\n        float dist = distance(coord, boidPos);\n\n        if (dist < minDist) {\n            secondClosestDist = minDist;\n            secondClosestCenter = closestCenter;\n            minDist = dist;\n            closestCenter = i;\n        } else if (dist < secondClosestDist) {\n            secondClosestDist = dist;\n            secondClosestCenter = i;\n        }\n    }\n\n    vec2 h = hash(vec2(float(closestCenter)));\n    float smoothDist = smoothstep(3.00, 0.1, minDist);\n    vec4 color = vec4(\n        h.y * sin((iTime + 2.) / 19.1415) * smoothDist,\n        h.x * sin((iTime + 2.) / 9.1415) * smoothDist,\n        h.x * cos((iTime + 2.) / 10.22 * sin(h.x / 5.)) * smoothDist,\n        1.0\n    );\n\n    vec2 h2 = hash(vec2(float(secondClosestCenter)));\n\n    // Add border between the two cells\n    float borderDist = 0.015;\n    if (secondClosestDist - minDist < borderDist) {\n        color = mix(color, vec4(0.0, 0.0, 0.0, 0.5), 0.3);\n    }\n\n    int insideCount = 0;\n\n    // Check if the coordinate is inside each boid's triangle\n    for (int i = 0; i < numBoids; ++i) {\n        Boids currentBoid = readBoid(i, iChannel0);\n        vec2 dir = normalize(currentBoid.velocity);\n        float angle = atan(dir.y, dir.x) - radians(90.0);\n        mat2 rotation = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n        vec2 p1 = vec2(0.0, 0.02) * 1.5;\n        vec2 p2 = vec2(-0.015, -0.015 * sqrt(3.0)) * 1.5;\n        vec2 p3 = vec2(0.015, -0.015 * sqrt(3.0)) * 1.5;\n        p1 = currentBoid.pos + rotation * p1;\n        p2 = currentBoid.pos + rotation * p2;\n        p3 = currentBoid.pos + rotation * p3;\n\n        bool insideTriangle = isInsideTriangle(coord, p1, p2, p3);\n        float borderWidth = 0.005;\n        bool nearBorder = isNearBorder(coord, p1, p2, p3, borderWidth);\n\n        if (insideTriangle) {\n            insideCount++;\n            if (nearBorder) {\n                color = vec4(0.0, 0.0, 0.0, 1.0);\n            } else {\n                color = vec4(vec3(1.0) - color.xyz, 1.0);\n            }\n        }\n    }\n\n    // If the coordinate is inside more than one triangle, change the color\n    // if (insideCount > 1) {\n    //     color = vec4(1.0, 1.0, 0.0, 1.0);\n    // }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec4 finalColor = voronoi(uv);\n    fragColor = finalColor;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Boids updateBoids(int i) {\n    // Precalculate margin bounds\n    float aspectRatio = iResolution.x / iResolution.y;\n    float topMargin = 1.0 - edgeOffset;\n    float rightMargin = aspectRatio - edgeOffset;\n    float leftMargin = -aspectRatio + edgeOffset;\n    float bottomMargin = -1.0 + edgeOffset;\n\n    // Initialize accumulation variables\n    vec2 avgPos = vec2(0.0);\n    vec2 avgVel = vec2(0.0);\n    int neighboringBoids = 0;\n    vec2 avoidance = vec2(0.0);\n\n    Boids current = readBoid(i, iChannel0);\n\n    // For each other boid in the group\n    for(int j = 0; j < numBoids; ++j) {\n        if (i != j) {\n            Boids jj = readBoid(j, iChannel0);\n            float dist = distance(current.pos, jj.pos);\n\n            // Avoidance with minimum distance\n            if (dist < inCircle) {\n                vec2 separation = current.pos - jj.pos;\n                float separationLength = length(separation);\n                separation = normalize(separation);\n                float minDistance = inCircle;\n                float avoidanceFactor = max(0.0, log(1.0 + (minDistance - separationLength) / minDistance));\n                avoidance += separation * avoidanceFactor * avoidFactor;\n            } else if (dist < outCircle) {\n                // Accumulate positions and velocities for centering and alignment\n                avgPos += jj.pos;\n                avgVel += jj.velocity;\n                neighboringBoids += 1;\n            }\n        }\n    }\n\n    // Centering and alignment\n    if(neighboringBoids > 0) {\n        avgPos /= float(neighboringBoids);\n        avgVel /= float(neighboringBoids);\n\n        current.velocity += (avgPos - current.pos) * log(1.0 + centeringFactor) + (avgVel - current.velocity) * log(1.0 + matchingFactor);\n    }\n\n    // Avoidance\n    current.velocity += avoidance * log(1.0 + avoidFactor);\n\n    // Margin handling\n    if (current.pos.y > topMargin) current.velocity.y -= log(1.0 + rotationFactor);\n    if (current.pos.x > rightMargin) current.velocity.x -= log(1.0 + rotationFactor);\n    if (current.pos.x < leftMargin) current.velocity.x += log(1.0 + rotationFactor);\n    if (current.pos.y < bottomMargin) current.velocity.y += log(1.0 + rotationFactor);\n    \n    current.pos.x = clamp(current.pos.x, -aspectRatio, aspectRatio);\n    current.pos.y = clamp(current.pos.y, -1.0, 1.0);\n    \n    // Limit speed\n    float speed = length(current.velocity);\n    if (speed < minSpeed) {\n        current.velocity = normalize(current.velocity) * log(1.0 + minSpeed);\n    }\n    if (speed > maxSpeed) {\n        current.velocity = normalize(current.velocity) * log(1.0 + maxSpeed);\n    }\n\n    // Update boid position\n    current.pos += current.velocity;\n\n    return current;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int boidIndex = int(floor(fragCoord.x));\n\n    if (iFrame == 0) {\n        fragColor = vec4(\n            hash(vec2(sin(float(boidIndex)))) - 0.5, normalize(hash(vec2(cos(float(boidIndex)),\n            sin(float(boidIndex)))) - vec2(0.5, 0.5)) / 10.\n        );\n    } else {\n        Boids current = updateBoids(boidIndex);\n        fragColor = vec4(current.pos, current.velocity);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Boids {\n    vec2 pos;\n    vec2 velocity;\n};\n\nconst int numBoids = 50;\n\nconst float avoidFactor = 0.05;\nconst float matchingFactor = 0.02;\nconst float centeringFactor = 0.003;\nconst float rotationFactor = 0.001;\nconst float edgeOffset = 0.3;\nconst float maxSpeed = 0.03;\nconst float minSpeed = 0.01;\n\nconst float outCircle = 0.4;\nconst float inCircle = 0.2;\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 41358.5453);\n}\n\nBoids readBoid(int i, sampler2D tex) {\n        Boids b;\n        vec4 channelData = texelFetch(tex, ivec2(i,0),0);\n        b.pos = channelData.xy;\n        b.velocity = channelData.zw;\n        \n        return b;\n}","name":"Common","description":"","type":"common"}]}