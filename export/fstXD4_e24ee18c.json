{"ver":"0.1","info":{"id":"fstXD4","date":"1633177321","viewed":74,"name":"Bump map in a circle","username":"1rosehip","description":"Bump map in a circle","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/**\n * get random number\n */\nfloat random(vec2 uv) {\n    return fract(sin(uv.x * 113.0 + uv.y * 412.0) * 6339.0);\n}\n\n/**\n * perlin noise \n */\nfloat perlin(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    // u = smoothstep(0.,1.,f);\n\n    // mMix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n/**\n * fractal brownian motion - fractal noise\n * https://en.wikipedia.org/wiki/Fractional_Brownian_motion\n */\nfloat fbm (in vec2 position){\n\n    float f = 0.0;\n\n    // the rotation transformation and the magnification transformation are multiplied -> expansion transformation\n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n\n    f  = 0.5000 * perlin(position);\n    position = m * position;\n\n    f += 0.2500 * perlin(position);\n    position = m * position;\n\n    f += 0.1250 * perlin(position);\n    position = m * position;\n\n    f += 0.0625 * perlin(position);\n    position = m * position;\n\n    // change [-1.0, 1.0] => [0.0, 1.0]\n    // f = 0.5 + 0.5 * f;\n    return f;\n}\n\n/**\n * bum noise\n */\nvec3 bumpMap(vec2 position, float normalStrength) {\n    vec2 s = 1.0 / iResolution.xy;\n    float p =  fbm(position);\n    float h1 = fbm(position + s * vec2(1.0, 0));\n    float v1 = fbm(position + s * vec2(0.0, 1.0));\n    vec2 xy = (p - vec2(h1, v1)) * normalStrength;\n    return vec3(xy + 0.5, 1.0);\n}\n\n/**\n * create a circle\n */\nfloat circle(vec2 uv, float radius, float smoothThickness){\n    return smoothstep(radius - smoothThickness, radius + smoothThickness, length(uv));\n    \n    float a = length(fwidth(uv));\n    return smoothstep(radius - a, radius + a, length(uv));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x ,iResolution.y);\n     \n    vec3 color = vec3(0.0);\n\n    // bump map\n    uv += clamp((bumpMap(uv + iTime, 40.0).xy - 0.5), -1.0, 1.0);\n\n    // draw a circle\n    color += 1.0 - circle(uv, 0.2, 0.005);\n\n    //color = mix(vec3(0.0), vec3(1.0), color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}