{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define dPI 6.28318530718\t// 2*PI\n#define sR 0.3  \t\t\t// small radius\n#define bR 1.0 \t\t\t\t// big radius\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// calc coordinates on the canvas\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-vec2(1.);\n    uv.x *= iResolution.x/iResolution.y;\n    \n// calc if it's in the ring area\n    float k = 0.0;\n    float d = length(uv);\n    if(d>sR && d<bR)\n        k = 1.0;\n    \n// calc the texture UV\n    // y coord is easy, but x is tricky, and certain calcs produce artifacts\n    vec2 tUV = vec2(0.0,0.0);\n    \n    // 1st version (with artifact)\n\t//tUV.x = atan(uv.y,uv.x)/dPI;\n    \n    // 2nd version (more readable version of the 3rd version)\n    //float disp = 0.0;\n    //if(uv.x<0.0) disp = 0.5;\n    //tUV.x = atan(uv.y/uv.x)/dPI+disp;\n    \n    // 3rd version (no branching, ugly)\n    tUV.x = atan(uv.y/uv.x)/dPI+0.5*(1.-clamp(uv.x,0.0,1.0)/uv.x);\n    \n    tUV.y = (d-sR)/(bR-sR);\n    \n// output pixel\n    vec3 col = texture(iChannel0, tUV).rgb;\n    fragColor = vec4(col*k,1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSSDz","date":"1410819721","viewed":1002,"name":"Circle distort","username":"Abstract_Algorithm","description":"Shader version for http://stackoverflow.com/questions/25855308/i-need-to-warp-a-long-image-into-a-2d-circle-webgl-distortion-is-expected","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","distortion","circle","image"],"hasliked":0,"parentid":"","parentname":""}}