{"ver":"0.1","info":{"id":"DdVSR3","date":"1681389843","viewed":119,"name":"robot_egyptking_assign1_sofien","username":"sofien","description":"like it please i need the points xd","likes":43,"published":1,"flags":48,"usePreview":1,"tags":["robotegyptking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sofien_Amri\n//Project_For_Computer_Graphics\n//Main Parts :\n// create a robot scence\n// use diferrent objects and colors\n// calculate reflection and refraction components\n// useing different material that reflect and refract light\n// calculate shadows\n// Using BRDFs\n// calculate refraction with max_deph\n// trying a method to calculate the refllection and refraction in recursion way\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\nconst float EPSILON = 1e-8 ;\n\n// Maximum Deph : i put 1 cause if its higher a bit the Shadertoy craches forbut to work well the minimum should be 1000\nconst int MAX_DEPTH = 1;\n\n\n// number of bounces a ray can take\nconst int n_bounce = 1; \n\n// number of frames to render each second\nconst int n_frame = 1;    \n\n// correctional variable for frame rendering\nconst float Render_var = 0.01; \n\n//Struct Material\nstruct Material {\n    vec3  color; // [0,1/pi]\n    float roughness; // [0,~7]\n    vec3  emission; // [0, inf]\n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    float ior; // Refraction index IOR\n};\n\n// Material properties from: https://www.shadertoy.com/view/flXcWN\n#define Light(r,g,b)    Material(vec3(0,0,0)   ,  1.      ,    vec3(r,g,b), 0.  , 0.)\n#define Metal(r,g,b,m)  Material(vec3(r,g,b)/pi,  float(m),    vec3(0,0,0), 0.9 , 0.)\n#define Nonmetal(r,g,b,m)  Material(vec3(r,g,b)/pi,  float(m),    vec3(0,0,0), 0.02, 0.)\n#define Nonmaterial(r,g,b)  Material(vec3(0,0,0), 0., vec3(0,0,0), 0., 0.)\n#define Refractor(r,g,b,m)  Material(vec3(r,g,b)/pi,  float(m),    vec3(0,0,0), 0.02, 0.8)\n#define Yello(r,g,b)       Material(vec3(0,0,0)   , 1.      , vec3(r,g,b), 1.5 ,0.5 )\n#define Red(r,g,b)         Material(vec3(0,0,0)   , 1.      , vec3(r,g,b), 0. ,0. )\n#define sun(r,g,b)         Material(vec3(0,0,0)   , 1.      , vec3(r,g,b), 0. ,0. )\n#define Moon(r,g,b)        Material(vec3(0,0,0)   ,  1.      ,    vec3(r,g,b), 0.  , 0.)\n\n//Struct COlor\nconst Material colors[] = Material[](\n    Metal(  .6,  .4, .1, 0.03), // 0\n    Nonmetal( .15, .01,  1,   .1), // 1\n    Nonmetal(  .1,   1, .5,    1), // 2\n    Nonmetal(   1,   1,  1,  0.3), // 3\n    Light( 1., 1., 1.),      // 4\n    Nonmaterial(0.,  0., 0.),       // 5\n    Refractor( .15, .01,  1,   .1) , // 6\n    Yello( 1., 1., 0.),      // 7\n    sun( 1., 0.5, 0.),      // 8\n    Moon(0.14,0.13,0.12), //9\n    Red( 1., 0., 0.)      // 10\n);\n\n\n\nstruct Cylinder {\n    vec3 position;    // center position of the cylinder\n    float radius;     // radius of the cylinder\n    float height;     // height of the cylinder\n    Material color;       // color of the cylinder\n    bool reflective;  // whether the cylinder is reflective or not\n};\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    Material mat;\n    bool textured;\n};\n\nstruct Plane {\n    vec3 q0;   // any point on the plane\n    vec3 n;    // normal\n    Material mat;\n    bool textured;\n};\n\nstruct Triangle { // Barycentric coordinates for vertices\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    Material mat;\n    bool textured;\n};\n\n\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    Material mat;\n    bool textured;\n};\n\n\n//CookTorranceBRDF\n\nfloat CookTorranceBRDF(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    // Important this is a modified form of the Cook Torrance mode to became => microfacet model (G G X)\n    // more accurate and physically-based representation of the surface reflection compared to the Blinn-Phong \n    //or Cook-Torrance models and more precise because i am using metalic material in the scene !\n    vec3 H = normalize(V + L);\n    float dotNL = clamp(dot(N, L), 1.0, 1.0);\n    float dotNV = clamp(dot(N, V), 0.0, 1.0);\n    float dotNH = clamp(dot(N, H), 0.0, 1.0);\n    float dotLH = clamp(dot(L, H), 0.0, 1.0);\n    \n    // Calculate geometric shadowing\n    float k = roughness * roughness / 2.0;\n    float vis = (2.0 * dotNH * dotNV) / (dotNH + sqrt(dotNH * dotNH + k * k));\n    vis *= (2.0 * dotNH * dotNL) / (dotNH + sqrt(dotNH * dotNH + k * k));\n    \n    // Calculate microfacet distribution\n    float alpha = roughness * roughness;\n    float alphaSqr = alpha * alpha;\n    float pi = 3.1415926535;\n    float D = (alphaSqr / (pi * pow(dotNH * dotNH * (alphaSqr - 1.0) + 1.0, 2.0)));\n    \n    // Calculate Fresnel term\n    float F = F0 + (1.0 - F0) * pow(1.0 - dotLH, 5.0);\n    \n    // Calculate Cook-Torrance BRDF\n    float numerator = vis * D * F;\n    float denominator = 4.0 * dotNL * dotNV;\n    float x = numerator / denominator;\n    return x ;\n}\n\n// Random functions from: https://www.shadertoy.com/view/WsBBR3\nuint R_Function(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n\n// I used this Texture method from :\n//https://www.shadertoy.com/view/XsfXWX\n\n//function to sample the color values from the texture map at the specified texture coordinates.\n// samplerCube : Type of 3D cube map\nvec3 textur1(samplerCube tex, vec3 tc) { \n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n    //The tc specifies the position ( coordinates) in the texture map where to sample the color value\n \tvec3 s0 = texture(tex,tc).xyz;\n    \n    //calculate the neighboring texture coordinates in the positive and negative x-direction\n    //sample the surrounding texels of the input texture in nine different directions \n    //(the center, up, down, left, right, and diagonals).\n    \n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    \n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    //smooth out the texture and reduce aliasing artifacts when the texture is mapped onto a surface.\n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\n// obtain texels from the surrounding cube faces, \n//and then applies a blur filter using a weighted average of the texels\nvec3 Blurtexture1(samplerCube tex, vec3 tc) {\n    // tex : sample the texture cube.\n   \tvec3 r = textur1(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textur1(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textur1(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textur1(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textur1(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textur1(tex,vec3(0.0,0.0,-1.0));\n    // apply the blure filter    \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    //increase the contrast between the most and least important faces.\n    \n    kr = pow(kr,4.0);\n    kt = pow(kt,4.0);\n    kf = pow(kf,4.0);\n    kl = pow(kl,4.0);\n    kb = pow(kb,4.0);\n    ka = pow(ka,4.0);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n\n//generate random float values between 0 and 1\nfloat chose_State(inout uint state)\n{\n    return float(R_Function(state)) / 4294967296.0;\n}\n\n//generates a random unit vector in 3D space\nvec3 chose_vector(inout uint state)\n{\n    float z = chose_State(state) * 2.0f - 1.0f;\n    float a = chose_State(state) * 2.*pi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Number of Spheres\nconst int spheresNo = 11 ;\nSphere spheres[spheresNo];\n\n//Number of Planes\nconst int planeNo = 1;\nPlane planes[planeNo];\n\n//Number of Triangles\nconst int trianglesNo = 3;\nTriangle triangles[trianglesNo];\n\n//Number of Cylinderes\nconst int cylinderNo = 2;\nCylinder cylinders[cylinderNo];\n\n//Number of light Positions\nconst int lightpositionNo = 2;\nvec3 lightposition[lightpositionNo];\n\n//vec3(-5, .5, 215\nconst vec3 EyeStartPosition = vec3(-22,2,0);\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{   \n    // *** Ray generation ***\n    \n    // camera position\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\n    \n    // spherical coordinates\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t\n    vec2 uv\t= abs(data2);\n    \n    //mouse held or was held last frame\n   \tif(iMouse.z>0. || data2.x >= 0.)\t\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y), sin(-uv.y), sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// Plane intersection\nTraceResult intersectPlane(Ray ray, Plane plane) \n{   \n    //Calculate the distance along the ray at which it intersects the plane\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    \n    //Return a TraceResult struct that contains the normal of the plane \n    //the distance at which the ray intersects the plane, the material of the plane,\n    //and whether or not the plane is textured.\n    return TraceResult(plane.n, t, plane.mat, plane.textured);\n}\n\n// Sphere intersection\nTraceResult intersectSphere(Ray ray, Sphere sp) \n{   \n    // Vector from the ray origin to the center of the sphere\n    vec3 p0c = ray.p0 - sp.c;  \n    float a = dot(ray.v, ray.v); \n    float b = 2.0 * dot(p0c, ray.v); \n    \n    // Distance squared between ray origin and sphere center\n    float c = dot(p0c,p0c) - sp.r*sp.r; \n    \n    float discriminant = b*b - 4.0*a*c; \n    \n    // If the discriminant is negative, no intersection\n    if(discriminant < 0.0)\n    \n        // Return a TraceResult with black color and no intersection\n        return TraceResult(vec3(0), ray.tmax, colors[5], false); \n    \n    float sqd = sqrt(discriminant); \n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n    \n        // Select the smaller root if both roots are positive\n        numerator = -b + sqd;\n        \n    // Compute the intersection distance along the ray\n    float t = 0.5 * numerator / a; \n    \n    // Compute the intersection point\n    vec3 p = ray.p0 + t * ray.v; \n    \n    // Compute the normal at the intersection point\n    vec3 normal = normalize(p - sp.c); \n    \n    // Return a TraceResult with the normal, intersection distance, material, and texture information\n    return TraceResult(normal, t, sp.mat, sp.textured); \n}\n\n\n\n // Möller-Trumbore Triangle intersection\nTraceResult intersectTriangle(Ray ray, Triangle trg)\n{   \n    // Compute edge1 of the triangle by subtracting the endpoint b from a\n    vec3 edge1 = trg.b - trg.a;\n    // Compute edge2 of the triangle by subtracting the endpoint c from a\n    vec3 edge2 = trg.c - trg.a;     \n    vec3 pvec = cross(ray.v, edge2);  \n    float det = dot(edge1, pvec);   \n\n    if (det > -EPSILON && det < EPSILON) \n    \n        // Return no intersection if it is close to zero\n        return TraceResult(vec3(0), ray.tmax, colors[5], false);   \n\n    float inv_det = 1.0 / det;   \n    vec3 tvec = ray.p0 - trg.a;   \n    float u = dot(tvec, pvec) * inv_det; \n    \n     // Check if the intersection point lies outside the triangle\n    if (u < 0.0 || u > 1.0) \n    \n        // Return no intersection if it is outside the triangle\n        return TraceResult(vec3(0), ray.tmax, colors[5], false);   \n\n    vec3 qvec = cross(tvec, edge1);   \n    float v = dot(ray.v, qvec) * inv_det; \n    \n     // Check if the intersection point lies outside the triangle\n    if (v < 0.0 || u + v > 1.0)   \n    \n         // Return no intersection if it is outside the triangle\n        return TraceResult(vec3(0), ray.tmax, colors[5], false); \n        \n     // Compute the distance along the ray to the intersection point\n    float t = dot(edge2, qvec) * inv_det;   \n    \n     // Check if the intersection point lies in front of the starting point of the ray\n    if (t > EPSILON) { \n    \n         // Compute the intersection point\n        vec3 p = ray.p0 + t * ray.v;  \n        vec3 normal = normalize(cross(edge1, edge2));\n        \n        // Flip the normal vector if it is facing away from the ray\n        if (dot(normal, ray.v) > 0.0) normal = -normal;  \n        \n        // Return the intersection point and its properties\n        return TraceResult(normal, t, trg.mat, trg.textured);   \n    }\n     // Return no intersection if the intersection point lies behind the starting point of the ray\n    return TraceResult(vec3(0), ray.tmax, colors[5], false);  \n}\n\nTraceResult intersectCylinder(Ray ray, Cylinder cyl)\n{   \n    // Compute the vector OC from the ray origin to the cylinder position\n    vec3 oc = (ray.p0 - cyl.position);\n    \n    // Compute the coefficients of the quadratic equation\n    float a = dot(ray.v, ray.v) - dot(ray.v, cyl.position)*dot(ray.v, cyl.position);\n    float b = float(2)*dot(ray.v, oc) -(dot(ray.v,cyl.position)*dot(oc,cyl.position));\n    float c = dot(oc, oc) - dot(oc, cyl.position)*dot(oc, cyl.position) - (cyl.radius*cyl.radius);\n    \n    // Compute the discriminant of the quadratic equation\n    float delta = b*b - float(4)*(a * c);\n    \n    // Initialize the TraceResult structure with default values\n    TraceResult res;\n    res.t = 1000.f;\n    res.textured = false;\n    \n    // If the discriminant is positive, the ray intersects the cylinder\n    if (delta > float(0))\n    {   \n        // Compute the two intersection points\n        float t1 = (-b - sqrt(delta)) / (2. * a);\n        float t2 = (-b + sqrt(delta)) / (2. * a);\n        \n        // Compute the coordinates of the two intersection points\n        vec3 p1 = ray.p0 + t1 * ray.v;\n        vec3 p2 = ray.p0 + t2 * ray.v;\n        \n        // Test which intersection point is closest to the ray origin and within the height of the cylinder\n        if (t1 < t2)\n        {\n            if (p1.y >= cyl.position.y && p1.y <= cyl.position.y + cyl.height)\n            {\n                res.t = t1;\n                res.n = normalize(p1 - vec3(cyl.position.x, p1.y, cyl.position.z));\n            }\n            else if (p2.y >= cyl.position.y && p2.y <= cyl.position.y + cyl.height)\n            {\n                res.t = t2;\n                res.n = normalize(p2 - vec3(cyl.position.x, p2.y, cyl.position.z));\n            }\n        }\n        else\n        {\n            if (p2.y >= cyl.position.y && p2.y <= cyl.position.y + cyl.height)\n            {\n                res.t = t2;\n                res.n = normalize(p2 - vec3(cyl.position.x, p2.y, cyl.position.z));\n            }\n            else if (p1.y >= cyl.position.y && p1.y <= cyl.position.y + cyl.height)\n            {\n                res.t = t1;\n                res.n = normalize(p1 - vec3(cyl.position.x, p1.y, cyl.position.z));\n            }\n        }\n    }\n    \n    // If the distance of the intersection is still the default value, there was no intersection\n    if (res.t == float(100))\n    {\n        return res;\n    }\n    \n    // Set the material of the cylinder in the TraceResult structure\n    res.mat = cyl.color;\n    res.textured = true;\n    \n    // Return the TraceResult structure\n    return res;\n}\n\n\n\n// Function to calculate the color and other properties of the closest object intersected by a ray.\nTraceResult raycast(Ray ray)\n{\n    // Initialize the TraceResult object with a default value.\n    TraceResult res = TraceResult(vec3(0), ray.tmax, colors[5], false);\n    \n    // Iterate over all spheres in the scene and check for intersections with the ray.\n    for(int i = 0; i < spheresNo; ++i)\n    {   // Calculate the intersection of the ray and the sphere.\n        TraceResult res2 = intersectSphere(ray, spheres[i]); \n        \n        // If the intersection is valid and closer than the previous intersection, update the TraceResult object.\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    // Iterate over all planes in the scene and check for intersections with the ray.\n    for(int i = 0; i < planeNo; ++i)\n    {   // Calculate the intersection of the ray and the plane.\n        TraceResult res2 = intersectPlane(ray, planes[i]); \n        \n        // If the intersection is valid and closer than the previous intersection, update the TraceResult object.\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    // Iterate over all triangles in the scene and check for intersections with the ray.\n    for(int i = 0; i < trianglesNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]); // Calculate the intersection of the ray and the triangle.\n        // If the intersection is valid and closer than the previous intersection, update the TraceResult object.\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    // Iterate over all cylinders in the scene and check for intersections with the ray.\n    for(int i = 0; i < cylinderNo; ++i)\n    {   \n        // Calculate the intersection of the ray and the cylinder.\n        TraceResult res2 = intersectCylinder(ray, cylinders[i]); \n        \n        // If the intersection is valid and closer than the previous intersection, update the TraceResult object.\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    // The function returns a TraceResult objectnwith the closest intersection and that contains the color, normal\n    return res;\n}\n\n\n\n\n\n\n// Function to calculate the color of a pixel based on ray tracing and shading\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos)\n{   \n     // Get the material of the object that was hit\n    Material mat = tr.mat;\n    \n    // Calculate the point of intersection between the ray and the object\n    vec3 p = ray.p0 + ray.v * tr.t; \n    // Get the surface normal at the point of intersection\n    vec3 n = tr.n; \n    \n    // Calculate the vector from the point of intersection to the light source\n    vec3 l = lightPos - p; \n    \n    // Get the distance between the point of intersection and the light source\n    float lightDist = length(l); \n    // Normalize the direction vector to the light source\n    l /= lightDist; \n    \n    // Create a ray to check if the point is in shadow\n    Ray shadowray = Ray(p + 0.001 * n, 0.001, l, lightDist); \n    \n    // Cast the shadow ray to check if the point is in shadow\n    TraceResult res = raycast(shadowray); \n    \n    // Get the view direction\n    vec3 v = -ray.v; \n    \n    // Normalize the direction vector to the light source\n    l = normalize(lightPos - p); \n    \n    // Get the metalness of the material\n    float metallic = mat.metalness; \n    \n    // Get the roughness of the material\n    float roughness = mat.roughness; \n    \n    // Calculate the fresnel power based on the metalness of the material\n    float fresnel_pow = mix(3., 3.5, mat.metalness); \n    \n    // Modify the color of the material\n    vec3 color_mod = mat.color + 0.5; \n    \n    // Get the color of the light source\n    vec3 light_color = pow(texture(iChannel2, vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2)); \n    \n    // Calculate the diffuse and reflection components of the scence based on scence scence lighting (IBL)\n    // and aplly the tesxture effects. ( bluring)\n    // tecture coordinates n:texture coordinates , iChannel2 : sampler Cube map\n    vec3 ibl_diffuse = pow(Blurtexture1(iChannel2, n), vec3(2.2));\n    vec3 ibl_reflection = pow(Blurtexture1(iChannel2, reflect(ray.v, n)), vec3(2.2));\n\n    // Calculate the fresnel effect\n    float fresnel = max(1.0 - dot(n, -ray.v), 0.0);\n    fresnel = pow(fresnel, fresnel_pow);\n\n    // Calculate the reflection component of the scene\n    vec3 refl = pow(texture(iChannel2, reflect(ray.v, n)).xyz, vec3(2.2));\n    refl = mix(refl, ibl_reflection, (1.0 - fresnel) * roughness);\n    refl = mix(refl, ibl_reflection, roughness);\n\n    // Calculate the specular component of scene\n    float power = 1.0 / max(roughness * 0.4, 0.01);\n    \n    // Applying CookTorranceBRDF : surface reflects light as a combination of the diffuse reflection \n    //of rough surfaces with the specular reflection of shiny surfaces\n    vec3 spec = mat.color * CookTorranceBRDF(n, -ray.v, lightPos, roughness * 0.7, 0.2);\n    refl -= spec;\n\n    // Calculate shadow effect\n    float sh = 1.;\n    \n    //If the point is in shadow\n    if (!(res.t == shadowray.tmax || mat.emission != vec3(0.) || res.mat.emission != vec3(0.))) \n    {\n        sh = 0. ; \n    }\n    \n    // diffuse\n    vec3 diffuse = ibl_diffuse * dot(n,l) * sh;\n    diffuse = mix(diffuse * color_mod, refl, fresnel); \n    \n    //compute refraction component using ior reference\n    vec3 refr = vec3(0.0);\n    float eta = mat.ior;\n    if (eta > 0.0) {\n        float cosTheta1 = dot(n, -ray.v);\n        float sinTheta1 = sqrt(1.0 - cosTheta1 * cosTheta1);\n        float sinTheta2 = sinTheta1 / eta;\n        if (sinTheta2 < 1.0) {\n            float cosTheta2 = sqrt(1.0 - sinTheta2 * sinTheta2);\n            vec3 t = (ray.v / eta) + ((cosTheta1 / eta - cosTheta2) * n);\n            Ray refray = Ray(p - 0.001 * n, 0.001, t, ray.tmax);\n            TraceResult refr_res = raycast(refray);\n            refr = pow(texture(iChannel2, refray.v).xyz, vec3(2.2));\n            \n        }\n    }\n\n    \n    \n    vec3 colorfinal = mix(diffuse,refl*color_mod, metallic)+spec;\n    \n    vec3 specular;\n    if(dot(n,l) < 0.)\n    {\n        specular = vec3(0);\n    }\n    else\n    {\n        specular = vec3(30, 30, 30);\n        float specdot = dot(reflect(l, n), v);\n        specular = l * specular * pow(max(0.0, specdot), 100.);\n    }\n    \n    // Adding textures \n    if(tr.textured) \n    {\n        vec3 mattex = texture(iChannel3, p.xy).rgb;\n        mattex *= 0.8;\n        colorfinal+=mattex;\n    }\n    \n    vec3 col = diffuse + (colorfinal + specular*mat.metalness) * max(dot(n,l), 0.);\n    \n    // In case is a light source\n    if(mat.emission != vec3(0.)) \n    { \n        return vec4(col + clamp(mat.emission, 0., 1.), 1.);\n    }\n    \n    \n    return vec4(col, 1.);\n}\n\n\nvec4 Refraction_Depth_Max(Ray ray, TraceResult tr, vec3 lightPos, int max_depth)\n{   \n    //Initialize\n    // Get the material of the surface that was hit\n    Material mat = tr.mat ;\n    \n    // Calculate the point of intersection between the ray and the surface\n    vec3 p = ray.p0 + ray.v * tr.t;\n    \n    // Initialize variables for the refraction ray's origin, direction,\n    // and index of refraction\n    vec3 refractionRayOrigin;\n    vec3 refractionDir;\n    float ior = mat.ior;\n    \n    \n    // Calculate the amount of light that reflects off the surface : fresnel\n    float reflectance = mix(3., 3.5, mat.metalness); \n    \n    // Check if the ray is outside the surface\n    bool outside = dot(ray.v, tr.n) < 0.;\n    \n    // Initialize the color of the refracted light\n    vec4 refractionColor = vec4(0.);\n    \n    // If the surface is not a perfect mirror, calculate the refracted light\n    if (reflectance < 1.)\n    {\n        // Calculate the origin and direction of the refracted ray\n        refractionRayOrigin = p - 0.001;\n        refractionDir = refract(p, -tr.n, 1.0 / ior);\n\n        // Create the refracted ray and trace it to find the next intersection\n        Ray refractionRay = Ray(refractionRayOrigin, 0.001, refractionDir, 500.);\n        TraceResult refractionRes = raycast(refractionRay);\n        \n        // Calculate the point of intersection of the refracted ray\n        vec3 refractionP = refractionRay.p0 + refractionRay.v * refractionRes.t;\n        \n        // Add the color of the refracted light to the total color\n        refractionColor += (1. - reflectance) * hitColor(refractionRay, refractionRes, refractionP);\n    }\n    \n    // Calculate the color of the light that is reflected directly from the surface\n    //vec4 f_col =  hitColor(ray, tr, lightPos) ;\n    vec4 f_col =  vec4(0.) ;\n    \n    // Calculate the direction of the reflected light and create a new ray\n    vec3 l = lightPos - p;\n    vec3 R = reflect(-l, tr.n);\n    Ray refray = Ray(p + 0.001 * tr.n, 0.001, R, 500.);\n    \n    // Trace the reflected ray to find the next intersection\n    TraceResult refres = raycast(refray);\n    \n    // Calculate the point of intersection of the reflected ray\n    p = refray.p0 + refray.v * refres.t;\n    \n    // Initialize a counter for the depth of the recursion\n    int counter = 0;\n    \n    // Initialize a variable for the surface normal\n    vec3 normal;\n\n    // Loop until the maximum recursion depth is reached\n    while (counter < max_depth)\n    {\n        // If the reflected ray does not intersect any surface, exit the loop\n        if(refray.tmax <= refres.t)\n        {\n            break;\n        }\n        \n        // Get the index of refraction and whether the ray is outside the surface\n        ior = mat.ior;\n        outside = dot(refray.v, refres.n) < 0.;\n        \n        // If the ray is outside the surface, use the surface normal;\n        // otherwise, use the negative of the surface\n        \n        if (outside == true)\n        {\n            normal = refres.n;\n            reflectance = mix(3., 3.5, mat.metalness); \n        }\n        else\n        {\n            normal = -refres.n;\n            reflectance = mix(3., 3.5, mat.metalness); \n        }\n        refractionColor = vec4(0.);\n        \n        if (reflectance < 1.)\n        {\n            if (outside == true)\n            {\n                refractionRayOrigin = p - 0.001;\n                refractionDir = refract(p, -tr.n, 1.0 / ior);\n            }\n            else\n            {\n                refractionRayOrigin = p + 0.001;\n                refractionDir = refract(p, tr.n, ior / 1.0);\n            }\n            Ray refractionRay = Ray(refractionRayOrigin, 0.001, refractionDir, 500.);\n\n            TraceResult refractionRes = raycast(refractionRay);\n\n            vec3 refractionP = refractionRay.p0 + refractionRay.v * refractionRes.t;\n\n            refractionColor += (1. - reflectance) * hitColor(refractionRay, refractionRes, refractionP);\n        }\n        \n        f_col += reflectance*hitColor(ray, tr, lightPos);\n        \n        p = refray.p0 + refray.v * refres.t;\n        l = lightPos - p;\n        R = reflect(-l, normal);\n        refray = Ray(p + 0.001 * tr.n, 0.001, R, 500.);\n        refres = raycast(refray);\n        counter += 1;\n    }\n    return f_col;\n}\n\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz, 1.);\n}\n\n// Add light from other light sources in the scean\nvec4 Extra_Light_sources(Ray ray, TraceResult triang) \n{\n    vec4 color;\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        if(spheres[i].mat.emission!=vec3(0.) && spheres[i].c.y > 0.)\n        {\n            color += hitColor(ray, triang, spheres[i].c);\n        }\n    }\n    for(int i = 0; i < trianglesNo; ++i)\n    {\n        if(triangles[i].mat.emission!=vec3(0.))\n        {\n            color += hitColor(ray, triang, triangles[i].a); \n            color += hitColor(ray, triang, triangles[i].b);\n            color += hitColor(ray, triang, triangles[i].c);\n        }\n    }\n    return color;\n}\n\n// since we can not apply recusion in shaders so applying function with boucles ! \nvec4 Frag_Color_Function(Ray ray, TraceResult ret,vec3 lightposition_1,vec3 lightposition_2)\n{\n    vec4 Color_Value ;\n    \n    // Check if the ray hit anything within its maximum range\n    if(ray.tmax <= ret.t){\n        // If not, return the color of a \"miss\" (background color)\n        Color_Value = missColor(ray);\n    }\n    else\n    {   \n        // If the ray hit something, calculate the color at the hit point using two light sources\n        vec4 hitcol1 = hitColor(ray, ret, lightposition_1);\n        vec4 hitcol2 = hitColor(ray, ret, lightposition_2);\n        \n        // Combine the color from the two light sources\n        Color_Value = hitcol1 + hitcol2 ;\n        \n        // Add the color contribution from any other light sources (not currently used in this function)\n        Color_Value += Extra_Light_sources(ray, ret);\n    }\n    \n    // Return the final color value\n    return Color_Value ;\n}\n\n//recursion based on number of bouncing\nvec4 Calcul_Ray_Color(vec3 lightposition_1,vec3 lightposition_2,Ray ray, inout uint N_State)\n{\n    // initialize\n    vec4 ret = vec4(0.); \n    \n    // initialize the color multiplier\n    vec4 col_multip = vec4(.8); \n    \n    // initialize the ray position\n    vec3 rayPos = ray.p0; \n    \n    // initialize the ray direction\n    vec3 rayDir = ray.v; \n    \n    // loop over the number of allowed bounces\n    for(int i=0; i<=n_bounce; i++) \n    {   \n         // trace the ray and get the intersection\n        TraceResult trace = raycast(ray);\n        \n        // if the ray missed, add in the background color and exit the loop\n        if(ray.tmax <= ret.t) \n        {\n            ret += vec4(texture(iChannel2, ray.v).xyz, 1.) * col_multip;\n            break;\n        }\n        \n        // update the ray position to the intersection point\n        rayPos = (rayPos + rayDir * trace.t) + trace.n *Render_var; \n        \n        if(trace.mat.ior != 0.) // if the material is refractive\n        {   \n             // calculate the refracted ray\n            Ray refRay = Ray(rayPos, ray.tmin, refract(rayDir, trace.n, ray.tmin), ray.tmax); \n            \n             // trace the refracted ray\n            TraceResult refRet = raycast(refRay);\n            ret += Frag_Color_Function(refRay, refRet,lightposition_1,lightposition_2) * trace.mat.ior * col_multip; // add the color of the refracted ray\n        }\n        // calculate a new random direction for the reflected ray\n        rayDir = normalize(trace.n + chose_vector(N_State)); \n        \n         // add the color of the reflected ray\n        ret += Frag_Color_Function(ray, trace,lightposition_1,lightposition_2) * (1.-trace.mat.ior) * col_multip;\n        \n        // add in emissive lighting\n        ret += vec4(trace.mat.emission, 1.0) * col_multip; \n        \n        col_multip *= vec4(trace.mat.color, 1.); // update the color multiplier\n        \n        // create a new ray with the updated position and direction\n        Ray newRay = Ray(rayPos, ray.tmin, rayDir, ray.tmax);\n        \n        // set the current ray to the new ray\n        ray = newRay; \n    }\n    \n    // return the final color of the ray\n    return ret; \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RobotSpeed = 100.f*sin(iTime*2.f)+105.f;\n    \n    //Inistialize light Positions\n    lightposition[0] = vec3(-6., 7., -8.6);\n    lightposition[1] = vec3(-6., 7., 8.6);\n    \n    // Define objects in the scene : Robot\n    \n    spheres[0] = Sphere(vec3(0, 1, 0),1.f, colors[0], false);  // Head\n    \n    \n    // Add Hornes\n    cylinders[0] = Cylinder(vec3(0,cos(0.9*iTime)*2.6, 0), cos(iTime)*1.2f, 0.4f, colors[0], true);  // First horn\n    cylinders[1] = Cylinder(vec3(0,cos(0.9*iTime)*3.6, 0), cos(iTime)*1.2f, 0.4f, colors[0], true);  // Second horn\n    \n    \n    \n    \n    spheres[1] = Sphere(vec3(0, -2, 0), 2.f, colors[0], false); // Torso\n   \n    \n    // Add Armes\n    spheres[2] = Sphere(vec3(0, -2, 2),1.f, colors[6], false); // Right arm\n    spheres[3] = Sphere(vec3(0, -2, -2),1.f, colors[6], false); // Left arm\n    \n    \n    spheres[4] = Sphere(vec3(0, -4.5, 0), 1.5f, colors[0], false); // Base\n    \n    \n    // Add eyes \n    spheres[5] = Sphere(vec3(-0.7, 1.3,-0.6), 0.2f,colors[10], false); // Left eye\n    spheres[6] = Sphere(vec3(-0.7, 1.3, 0.6), 0.2f, colors[10], false); // Right eye\n    \n    \n    // Add iris to eyes\n    spheres[7] = Sphere(vec3(-0.85, 1.3, -0.6), 0.1f, colors[7], false); // Left iris\n    spheres[8] = Sphere(vec3(-0.85, 1.3, 0.6), 0.1f, colors[7], false); // Right iris\n    \n    // Add moon and sun\n    spheres[9] = Sphere(vec3(-6, sin(0.2*iTime)*7.,-8.6), sin(0.2*iTime)*1.5f, colors[8], false); // Left lamp\n    spheres[10]= Sphere(vec3(-6, cos(0.2*iTime)*7., 8.6), cos(0.2*iTime)*1.5f, colors[9], false); // Right lamp\n   \n   \n    \n    \n    planes[0] = Plane(vec3(0, -7, 0), vec3(0, 1, 0), colors[3] , false); // Ground plane\n    \n    vec3 top = vec3(0, 2, 0);\n    //vec3 arm1 = vec3(3, -1, 0);\n    //vec3 arm2 = vec3(-3, -1, 0);\n    vec3 arm1 = vec3(0, -1, 3);\n    vec3 arm2 = vec3(0, -1,-3);\n    vec3 base1 = vec3(2, -5, 0);\n    vec3 base2 = vec3(-2, -5, 0);\n    \n    triangles[0] = Triangle(cos(0.9*iTime)*arm1,cos(0.9*iTime)*top,base1, colors[0], false); // Right arm\n    triangles[1] = Triangle(cos(0.9*iTime)*arm2, cos(0.9*iTime)*top, base2, colors[0], false); // Left arm\n    \n    \n    // Define camera and pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy*2.-vec2(1.);\n    vec3 eye; vec2 data;\n    Ray ray = Camera(fragCoord, eye, data);\n    //maxdeph\n    uint x = uint(3);\n    \n    // Cast ray into scene and calculate color\n    vec3 A = lightposition[0];\n    vec3 B = lightposition[1];\n    \n    // this is the main attraction here\n    vec4 color = vec4(0.);\n    \n    // iterate over all the frames: set n_frame to a larger number for higher quality\n    for(int i=0; i<1; i++) \n    {\n       color += Calcul_Ray_Color(A ,B, ray ,x) / float (1);\n     // this comented codes down are for Max_deph Refraction function \n    //TraceResult res = raycast(ray); \n    //vec4 final_col = Refraction_Depth_Max(ray, res,A, MAX_DEPTH)+Refraction_Depth_Max(ray, res,B, MAX_DEPTH)+color;\n    }\n     \n  \n    //fragColor= final_col ;\n    fragColor = color; \n    \n    // Save camera position and data into first two pixels\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5)\n        fragColor.zw = data;\n}\n\n   ","name":"Buffer A","description":"","type":"buffer"}]}