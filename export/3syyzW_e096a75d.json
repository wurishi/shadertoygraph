{"ver":"0.1","info":{"id":"3syyzW","date":"1602360468","viewed":181,"name":"AmongUs ","username":"ptemoche","description":"AmongUs practice with Raymarching.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","amongus","sofshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//shapes primitives from art of code https://www.youtube.com/watch?v=Ff0jJyyiVyw \n//sofShadows from iquilez https://iquilezles.org/articles/rmshadows\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define MIN_DIST 0.005\n#define AA 2\n#define eAA 0.001\n#define wAA 1.0\n#define PI 3.14159265359\n\n\nstruct Material{\n \n    vec3 color;\n    float shininess;\n    float kd;\n    float ks;\n    float ka;\n    float kf;\n    float nd;\n};\n    \nMaterial mats[2];\nvec3 colors[10];\n    \nMaterial i_material(vec3 color,float ka, float kd, float ks, float shininess, float kf, float nd){\n\t\n    Material m;\n    m.color = color;\n    m.shininess = shininess;\n    m.kd = kd;\n    m.ks = ks;\n    m.ka = ka;\n    m.kf = kf;\n    m.nd = nd;\n    return m;\n}\n\nmat2 Rot2(float angle){\n \n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    \n}\n\nmat3 RotX(float angle){\n \n    return mat3(1.0, \t\t0.0,\t\t0.0,\n                0.0, cos(angle),-sin(angle),\n                0.0, sin(angle), cos(angle));\n    \n}\n\nmat3 RotY(float angle){\n \n    return mat3(cos(angle), 0.0,sin(angle),\n                0.0,       1.0,0.0       ,\n                -sin(angle),0.0,cos(angle));\n    \n}\n\nmat3 RotZ(float angle){\n \n    return mat3(cos(angle),-sin(angle),0.0,\n                sin(angle), cos(angle),0.0,\n                \t   0.0,        0.0,1.0);\n    \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 min_v3(vec3 a, vec3 b){\n \treturn(a.x<b.x)?a:b;   \n}\nvec3 max_v3(vec3 a, vec3 b){\n \treturn(a.x>b.x)?a:b;   \n}\n\nfloat hash21(vec2 st){\n \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n    \n}\n\nfloat hash31(vec3 st){\n \treturn hash21(vec2(hash21(st.xz),hash21(vec2(hash21(st.xy),hash21(st.yz)))));   \n}\n\nvec3 hash33(vec3 p){\n \n    return vec3(hash21(p.xy),hash21(p.yz),hash21(p.xz));\n}\n\n\n\nfloat sdSphere(vec3 p, vec4 s){\n    return length(p-s.xyz)-s.w;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nvec3 tripulant(vec3 pos, vec3 translate,int index){\n    //pos = RotY(-PI*0.5)*pos;\n    pos-=translate;\n    vec3 p = pos;\n    //p.z*=1.25;\n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    vec3 d = vec3(sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6),0,index);\n    d.x = smin(d.x,sdBox(pos-vec3(0,0.4,3.55),vec3(1.9,1.7,0.4))-0.1,0.4);\n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d.x = smin(d.x,sdCylinder(p2,vec3(0.8,-1.05,2),vec3(0.85,-2.75,2),0.3)-0.3,0.25);\n    d = min_v3(d,vec3(sdBox(p+vec3(0,-1,-0.5-p.x*p.x*0.3),vec3(0.875,0.375,0.125))-0.125,1,0));\n    return d;\n}\n\nvec3 space_tripulant(vec3 pos, vec3 translate,int index){\n    \n    pos-=translate;\n    pos.y+=sin(iTime)*0.5;\n    pos=RotY(-PI*0.25)*pos;\n    pos=RotX(-0.4)*pos;\n    vec3 p = pos;\n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    vec3 d = vec3(sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6),0,index);\n    d.x = smin(d.x,sdBox(pos-vec3(0,0.4,3.55),vec3(1.9,1.7,0.4))-0.1,0.4);\n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d.x = smin(d.x,sdCylinder(p2,vec3(0.8,-1.25,2),vec3(0.85,-1.75,0.0),0.3)-0.3,0.25);\n    d = min_v3(d,vec3(sdBox(p+vec3(0,-1,-0.5-p.x*p.x*0.3),vec3(0.875,0.375,0.125))-0.125,1,0));\n    return d;\n}\n\nvec3 corpse(vec3 pos, vec3 translate){\n    \n    pos-=translate;\n    pos = RotY(0.7)*pos;\n    pos = RotX(-PI*0.1)*pos;\n    vec3 p = pos;\n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    vec3 d = vec3(sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6),0,1);\n    d = max_v3(d,vec3(p.y,0.,3));\n    d = min_v3(d,vec3(sdTorus(p-vec3(0,0,2),vec2(1.4,0.2)),0,1));\n    \n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d.x = smin(d.x,sdCylinder(p2,vec3(0.8,-1.25,2),vec3(0.85,-1.75,0.0),0.3)-0.3,0.25);\n    \n    vec3 d2 = vec3(sdCapsule(p,vec3(0,0.5,2),vec3(0,0.1,2),0.25),0,0);\n    d2.x = smin(d2.x,sdSphere(vec3(abs(p.x),p.yz),vec4(0.3,0.75,2,0.2)),0.5);\n    d = min_v3(d,d2); \n    return d;\n    \n}\n\nvec3 map(vec3 pos){\n \tvec3 d = tripulant(pos,vec3(-2,0,-3),2);\n    d = min_v3(d,tripulant(pos,vec3(3,0,0),3));\n    d = min_v3(d,tripulant(pos,vec3(8,-0.25,-2),5));\n    d = min_v3(d,space_tripulant(pos,vec3(1,5,7),4));\n    d = min_v3(d,corpse(pos,vec3(-8.,-1.5,1)));\n    d = min_v3(d,vec3(sdSphere(pos,vec4(0.,-103.,0.,100.)),0,25));\n    \n    return d;\n}\n\n\n\nvec3 raymarching(vec3 o, vec3 dir){\n    \n    float d = 0.0;\n    vec3 t = vec3(0);\n    \n    for(int i = 0; i<MAX_STEPS;++i){\n     \tvec3 pos = o+dir*d;\n        t = map(pos);\n        d+=t.x;\n        \n        if(abs(t.x)<MIN_DIST || d>MAX_DIST)\n            break;\n    }\n    \n    t.x = d;\n    return t;\n    \n}\n\nvec3 getNormal(vec3 pos,float normal_desv){\n \n    vec2 e = vec2(0.01,0.0);\n    \n    return normalize(map(pos).x-vec3(\n    \t\t\t\t\t\tmap(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos-e.yyx).x\n    \t\t\t\t\t\t)+sin(hash33(pos)*PI)*normal_desv);\n    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat getLigth(vec3 pos,int index){\n \n    Material m = mats[index];\n    \n    vec3 ligth  = vec3(0,2,-7);\n    vec3 l = normalize(pos-ligth);\n    vec3 N = getNormal(pos,m.nd);\n    float dif = m.kd*clamp(dot(N,-l),0.0,1.0);\n    float spec = m.ks*pow(clamp(dot(-l,reflect(normalize(pos),N)),0.0,1.0),m.shininess);\n    float amb = m.ka*clamp(dot(N,normalize(vec3(0.0,0.0,-1.0))),0.0,1.0);\n    float fresnel = m.kf*(1.0-clamp(dot(N,normalize(-pos)),0.0,1.0));\n    float l_d = dif+spec+amb+fresnel;\n    \n    float fog = exp(-0.0125*pos.z*pos.z);\n    float shadow = clamp(softshadow(pos+N*0.01,-l,0.,20.,4.)+0.25,0.0,1.0);\n\treturn l_d*fog*shadow;    \n}\n\nvec3 getColor(vec3 origin, vec3 dir){\n \n    vec3 col = vec3(0.0);\n    \n    \n    vec3 r_pos = raymarching(origin,dir);\n\n    vec3 p = origin+dir*r_pos.x;\n\tint mat_index = int(r_pos.y);\n    int color_index = int(r_pos.z);\n    vec3 _color;\n    if(color_index<20){\n        _color = colors[color_index];\n    }else{\n        _color = texture(iChannel0,p.xz*0.15).xyz;\n    }\n    \n    if(r_pos.x>90.){\n        float c = hash31(dir);\n     \tcol=vec3(pow(c,200.0));   \n    }else{\n    \tcol = _color*getLigth(p,mat_index);\n    }\n        \n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    float t = 0.0;//iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float distan = 15.0;\n    float angle = PI*0.92;//iTime;\n    float _x = sin(angle)*distan;\n    float _z = cos(angle)*distan;\n    vec3 origin = vec3(_x,1.5,_z);\n    vec3 lookat = vec3(0);\n    \n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-origin);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = origin + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 dir = normalize(i-origin);\n    \n    vec3 col = vec3(0.0);\n    \n    /*********************\n\t*       MATERIALS    *\n\t*********************/\n    \n    mats[0] = i_material(vec3(1,1,1),0.2,0.5,0.15,3.0,0.015,0.0015);\n    mats[1] = i_material(vec3(1,1,1),0.2,0.45,0.95,4.0,0.25,0.0); \n    \n    /********************\n\t*      COLORS       *\n\t********************/\n    colors[0] = vec3(1,1,1);\n    colors[1] = vec3(0,1,0);\n    colors[2] = vec3(0,0,1);\n    colors[3] = vec3(1,0,0);\n    colors[4] = vec3(0,1,1);\n    colors[5] = vec3(1,1,0);\n    \n    \n\tcol = (getColor(origin, dir)*wAA)/(float(AA)+wAA);\n    \n    vec3 e = vec3(eAA,-eAA,0.0);\n    vec3 e2 = vec3(eAA,-eAA,0.0)*0.7071;\n    vec3 sampling[8];\n    sampling[0]=e.xzz;\n    sampling[1]=e.zyz;\n    sampling[2]=e.yzz;\n    sampling[3]=e.zxz;\n    sampling[4]=e2.xxz;\n    sampling[5]=e2.yxz;\n    sampling[6]=e2.xyz;\n    sampling[7]=e2.yyz;\n    \n    for(int i = 0; i<AA;++i){\n     \n        \n        vec3 dir = normalize(dir+sampling[i]);\n\n        col += getColor(origin,dir)/(float(AA)+wAA);\n        \n    }\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}