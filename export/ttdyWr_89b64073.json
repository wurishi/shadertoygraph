{"ver":"0.1","info":{"id":"ttdyWr","date":"1609012145","viewed":197,"name":"snowGlobe","username":"Kaeylos","description":"imac animated gift","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["globe","imac","noel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Ray marching options ----- //\n#define AA_SAMPLES 1 // antialisaing\n#define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 50\n#else\n    #define MAX_STEPS 100\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t)/(2.*s*s)); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n \nmat3 rotX(float a) {return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a), cos(a));}\nmat3 rotY(float a) {return mat3(cos(a),0.0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\nmat3 rotZ(float a) {return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float a, float b, float t) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\nfloat dot2(vec3 v) {return dot(v,v);}\n#define saturate(v) clamp(v, 0., 1.)\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = f;\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nfloat perlinNoise(vec2 x) {\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash1(id);\n    float b = hash1(id + vec2(1.0, 0.0));\n    float c = hash1(id + vec2(0.0, 1.0));\n    float d = hash1(id + vec2(1.0, 1.0));\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = hermiteInter(f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlinNoise(vec3 x) {\n    const vec3 step = vec3(110., 241., 171.);\n\n    vec3 id = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(id, step);\n\n    vec3 u = hermiteInter(f);\n    return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n#define FBM_MAX_ITER 8\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n    vec2 shift = vec2(100.);\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t\t// Rotate and shift to reduce axial bias\n\t\tx = rot2(0.5) * x + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat fbm (vec3 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polysmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 polysmin(vec2 a, vec2 b, float k) {\n    vec2 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h.x) - k*h*(1.0-h);\n}\n\n// min redifinition to handle matId\n\nfloat mmin(float a, inout int mata, float b, int matb) {\n    if( a < b) return a;\n    \n    mata = matb;\n    return b;\n }\n\n\n// source: https://iquilezles.org/articles/normalsSDF\nconst vec2 k = vec2(NORMAL_DELTA, -NORMAL_DELTA);\n#define getNormal(fun, p) normalize(k.xyy * fun(p + k.xyy) + k.yyx * fun(p + k.yyx) + k.yxy * fun(p + k.yxy) + k.xxx * fun(p + k.xxx));\n\n\n// ----- distance functions for 3D primitives ----- // \nfloat sphereSDF(vec3 p, float radius) { return length(p) - radius; }\n\n// float planeSDF(vec3 p, vec3 n, float h) { return dot(p,n) - h;  }\nfloat planeSDF(vec3 p, vec4 plane) { return dot(p, plane.xyz) + plane.w; }\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\nfloat coneSDF(vec3 p, float height, float radius) {\n    // c must be normalized\n    vec2 c = normalize(vec2(height, radius));\n    p.y -= height;\n    float q = length(p.xz);\n    float cone = dot(c,vec2(q,p.y));\n    float plane = planeSDF(p, vec4(0.0, 1.0, 0.0, height));\n\n    return max(-plane,cone);\n}\n\nfloat roundBoxSDF(vec3 p, vec3 boxDim, float radius) {\n  return boxSDF(p, boxDim) - radius;\n}\n\n\nfloat cappedCylinderSDF(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n \nfloat phong(vec3 l, vec3 e, vec3 n, float power) {\n    float nrm = (power + 8.0) / (PI * 8.0);\n    return pow(max(dot(l,reflect(e,n)),0.0), power) * nrm;\n}\n \nvec3 triPlanar(in sampler2D tex, in vec3 p, in vec3 n) {\n    mat3 texMat = mat3(texture(tex, p.yz).rgb, texture(tex, p.xz).rgb, texture(tex, p.xy).rgb);\n    return texMat * abs(n);\n}\n \n//----------------------------------------------------------------\n\nfloat shapeBall(in vec3 pos) {\n    return sphereSDF(pos, 0.6);\n}\n\nfloat traceBall(vec3 O, in vec3 D) {\n    float t= 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {     \n        float d = shapeBall(O + D * t);\n        t += d;\n        \n        // If we reach the max dist (background)\n        if( t > MAX_DIST) { t *= -1.; break; }\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if(abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return t;\n}\n\nfloat shapeTree(vec3 p) {\n    float branches = 1e10;\n    for(float i = 0.; i < 3.; i++)\n        branches = min(branches, coneSDF(p + vec3(0.2, i * 0.1, -0.1), 0.4, 0.3));\n    \n    branches += fbm(p * 142.857, 1., 3)*0.05;\n    return branches;\n}\n\nfloat traceTree(vec3 O, vec3 D) {\n    float t= 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {     \n        float d = shapeTree(O + D * t);\n        t += d;\n        if( t > MAX_DIST) { t *= -1.; break; } // If we reach the max dist (background)\n        if(abs(d) < SURF_DIST*0.99) break; // If we are very close to the object\n    }\n    return t;\n}\n\nfloat shapeTrunk(vec3 p) {\n    return cappedCylinderSDF(p + vec3(0.2, 0.25, -0.1), vec2(0.05, 0.05));\n}\n\nfloat traceTrunk(vec3 O, vec3 D) {\n    float t= 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {     \n        float d = shapeTrunk(O + D * t);\n        t += d;\n        if( t > MAX_DIST) { t *= -1.; break; } // If we reach the max dist (background)\n        if(abs(d) < SURF_DIST*0.99) break; // If we are very close to the object\n    }\n    return t;\n}\n\nfloat shapeSupport(vec3 p) {\n    return cappedCylinderSDF(p + vec3(0., 0.6, 0.), vec2(0.7, 0.26)) - 0.05;\n}\n \nfloat traceSupport(vec3 O, in vec3 D) {\n    float t= 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {     \n        float d = shapeSupport(O + D * t);\n        t += d;\n        \n        // If we reach the max dist (background)\n        if( t > MAX_DIST) { t *= -1.; break; }\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if(abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return t;\n}\n \nfloat shapeSnow(in vec3 pos) {\n    float snow = planeSDF( pos, vec4(0.0, 1.0, 0.0, 0.3) );\n\n    snow = polysmin(snow, sphereSDF(pos + vec3(-0.1, 0.2, 0.2), 0.12), 0.05);\n    snow = polysmin(snow, sphereSDF(pos + vec3(-0.1, 0.05, 0.2), 0.08), 0.03);\n    snow = polysmin(snow, sphereSDF(pos + vec3(-0.1, 0.35, 0.2), 0.15), 0.03);\n\n    snow += perlinNoise(pos.xzy * 123.0) * 0.005;\n    snow += perlinNoise(pos.xzy * 35.12679) * 0.01;\n    \n    snow = max(snow, shapeBall(pos)+ 0.001); // clamp to globe\n    return snow;\n    }\n \nfloat traceSnow(vec3 O, in vec3 D) {\n    float t= 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {     \n        float d = shapeSnow(O + D * t);\n        t += d;\n        \n        // If we reach the max dist (background)\n        if( t > MAX_DIST) { t *= -1.; break; }\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if(abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return t;\n}\n \nfloat shapeTable(in vec3 pos) {\n    vec3 b = vec3(4.0, 0.2, 3.);\n    vec3 p = pos;\n    p.y += 0.9;\n   \n\n    vec3 pPr1 = pos + vec3(1.55, +0.145, 0.5);\n   \n    pPr1 = rotY(0.2 * PI) * pPr1;\n   \n    float dTable = roundBoxSDF(p, b, 0.1);\n   \n    return dTable;\n}\n \nfloat traceTable(vec3 O, in vec3 D) {\n    float t= 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {     \n        float d = shapeTable(O + D * t);\n        t += d;\n        \n        // If we reach the max dist (background)\n        if( t > MAX_DIST) { t *= -1.; break; }\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if(abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return t;\n}\n \nfloat map( in vec3 pos ) {\n    float d1 = shapeBall(pos);\n    float d2 = shapeTable(pos);\n    float d3 = shapeSupport(pos);\n   \n    return min( d1, min(d2, d3) );\n}\n\n// from iq technique\n// source: https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++) {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// Index Of Refraction\n#define IOR 0.98\n\n//----------------------------------------------------------------\n// SHADING\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n \nfloat calcSoftshadow( in vec3 _lo, in float _k ) {\n    float _res = 1.0;\n    float _t = 0.0;\n    float _h = 1.0;\n   \n    for( int _i=0; _i<16; _i++) {\n        _h = map(_lo + lig * _t);\n        _res = min( _res, _k *_h / _t );\n        _t += clamp( _h, 0.01, 1.0 );\n                               \n        if( _h<0.001 ) break;\n    }\n   \n    return clamp(_res,0.0,1.0);\n}\n\nvec3 background(vec3 D) {\n    vec3 col = texture(iChannel0, D).xyz;\n    \n    col.r -= 0.1;\n    col += 0.1;\n    col *= sqrt(col);\n    \n    return col;\n}\n \nvec3 shadeSupport(in vec3 pos, in vec3 ray) {\n    vec3 col = vec3(1.0);\n    vec3 norm = getNormal(shapeSupport, pos);\n   \n    float sha = calcSoftshadow(pos + norm*0.1, 8.0);\n    float occ = calcOcclusion(pos, norm);\n   \n    vec3 color3D = triPlanar(iChannel1, pos, norm);\n\n    float spec = phong(lig, ray, norm, 1.0);\n    float atten = dot(norm, lig);\n   \n    float f = 1.0 - smoothstep(0.3, 0.31, pos.y + 0.95);\n   \n    col = mix(vec3(0.2, 0.7, 0.7), vec3(1.0), f);\n    col *= atten * 0.5 + 0.5;\n    col *= sha * 0.5 + 0.5;\n    col *= occ;\n   \n    col += max(spec * sha * color3D * 2.0, 0.0);\n    col *= 0.8 + color3D * 0.5;\n   \n    return col;\n}\n \nvec3 shadeTable(in vec3 pos, in vec3 ray) {\n    vec3 nor = getNormal(shapeTable, pos);\n   \n    float sha = calcSoftshadow( pos + nor*0.01, 8.0 );\n    float occ = calcOcclusion(pos, nor);\n    float atten = clamp(dot(nor, lig), 0.0, 1.0) * 0.7 + 0.3;\n    float spec = phong(lig, ray, nor, 16.0) * sha;\n               \n    vec3 tex = triPlanar(iChannel1, pos, nor);\n    vec3 col = tex;\n   \n    if (pos.y > -0.55)\n        col = vec3(0.1, 0.3, 1.0) * atten;\n   \n    if (pos.y <= -0.599)\n        spec = spec * tex.r * tex.r;\n    else {\n        float n = perlinNoise(pos * 200.0);\n        spec = spec * n + n * 0.01;\n       \n        col = triPlanar(iChannel1, pos, nor);\n       \n        col.r = 0.8;\n    }\n   \n    col *= 0.5 + sha * atten * 0.5;\n    col *= occ;\n   \n    col += spec;\n   \n    return col;\n}\n \nvec3 shadeTree(vec3 p, vec3 ray) {\n    vec3  col = vec3(0.12, 0.7, 0.08)*0.3;\n    vec3 n = getNormal(shapeTree, p);\n    col += mix(col, vec3(0.9), fbm(p*40., 1., 3));\n    \n    col *= col;\n    return col;\n}\n\nvec3 shadeTrunk(vec3 p, vec3 ray) {\n    vec3 col = vec3(0.59, 0.286, 0.005);\n    \n    col += fbm(p*142.857, 1., 3)*0.5;\n    \n    col *= 0.65;\n    return col;\n}\n\nvec3 shadeSnow(in vec3 po, in vec3 ray) {\n    vec3 col = vec3(0.9);\n    vec3 norm = getNormal(shapeSnow, po);\n    float atten = dot(norm, lig);\n   \n    col *= 0.85 + atten * 0.3;\n   \n    return col;\n}\n\n// source : https://www.shadertoy.com/view/ltfGzn\nvec4 blizzard(vec3 O, vec3 D, float scale) {\n    float sum = 0.0;\n    float fallSpeed = 0.05;\n    float fall;\n    vec3 p1, p2;\n    float teta;\n    float t1, t2;\n    float depth = 100.0;\n    float a = pow(D.x, 2.0) + pow(D.z, 2.0);\n    float b = 2.0 * (D.x * O.x + D.z * O.z);\n    float c = pow(O.x, 2.0) + pow(O.z, 2.0);\n    float ac4 = 4.0 * a*c;\n    float a4 = 4.0 * a;\n    float a2 = 2.0 * a;\n    float bb = b*b;\n    float bbSubAC4 = bb - ac4;\n    for (float r = 1.0; r <= 16.0; r+=0.5)\n    {\n        float R = r + sin(PI * r * iTime * 0.05) / (r * 0.25);\n        float delta = bbSubAC4 + a4 * R*R;\n        if (delta >= 0.0)\n        {\n            t1 = (-b - sqrt(delta))/a2;\n            t2 = (-b + sqrt(delta))/a2;\n            p1 = O + t1 * D;\n            p2 = O + t2 * D;\n            if (t1 < depth && t1 > 2.0)\n            {\n                teta = atan(p1.z, p1.x) / (2.0 * PI);\n                fall = (0.5 + 0.5 * (0.5+0.5*sin(r))) * fallSpeed * iTime  +  cos(r);\n                float s = 6.0;\n                s *= smoothstep(0.65, 1.0, perlinNoise(scale*vec2(0.4 * teta * r, 0.1 * p1.y + fall)));\n                s *= smoothstep(0.65, 1.0, perlinNoise(scale*vec2(0.11 * p1.y + fall, -0.4 * teta * r)));\n                s *= smoothstep(0.65, 1.0, perlinNoise(scale*vec2(-(0.11 * p1.y + fall), 0.4 * teta * r)));\n                \n                sum += s;\n            }\n            if (t2 < depth && t2 > 0.0)\n            {\n                teta = atan(p2.z, p2.x) / (2.0 * PI);\n                fall = (0.5 + 0.5 * (0.5+0.5*sin(r))) * fallSpeed * iTime  +  cos(r);\n                float s = 6.0;\n                s *= smoothstep(0.65, 1.0, perlinNoise(scale*vec2(0.4 * teta * r, 0.1 * p2.y + fall)));\n                s *= smoothstep(0.65, 1.0, perlinNoise(scale*vec2(-(0.11 * p2.y + fall), 0.4 * teta * r)));\n                s *= smoothstep(0.65, 1.0, perlinNoise(scale*vec2(0.11 * p2.y + fall, -0.4 * teta * r)));\n                sum += s;\n            }\n        }\n    }\n    return vec4(vec3(1.0), clamp(sum / 2.0, 0.0, 1.0));\n}\n \n vec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvec3 renderOutsideGlobe(vec3 O, vec3 D) {\n    vec3 col = vec3(0.0);\n    \n    float tTable = traceTable(O, D);\n    float tSupport = traceSupport(O, D);\n    \n    \n    if ((tTable > 0.) && (tTable < tSupport || tSupport < 0.0)) {\n        col = shadeTable(O+D*tTable, D);\n    } else if ((tSupport > 0.)) {\n        col = shadeSupport(O+D*tSupport, D);\n    } else {\n        col = background(D);\n    }\n    \n    return col;\n}\n\nvec3 renderInsideGlobe(vec3 O, vec3 D) {\n    \n    vec3 col = vec3(0.);\n    \n     float tBall = traceBall(O,D);\n     float tSnow = traceSnow(O,D);\n     float tTree = traceTree(O,D);\n     float tTrunk = traceTrunk(O,D); \n        \n    if (tTree > 0. && (tTree < tSnow || tSnow < 0.) && (tTree < tTrunk || tTrunk < 0.)) {\n        col = shadeTree(O+D*tTree, D);\n    }else if (tSnow > 0. && (tSnow < tTrunk || tTrunk < 0.)) {\n        col = shadeSnow(O+D*tSnow, D);\n    } else if (tTrunk > 0.) {\n        col = shadeTrunk(O+D*tTrunk, D);\n    } else {\n        // snowGlobe (again only refraction)\n\n        vec3 pos = O+D*tBall;\n        vec3 refrRay = normalize(refract(D, normalize(pos), IOR));\n        \n        // rayMarch outside globe\n        col = renderOutsideGlobe(pos + refrRay * SURF_DIST*2., refrRay);\n\n    }\n    col *= 0.8;\n   \n    return col;\n}\n\nvec3 render(vec3 O, vec3 D) {\n    vec3 col = vec3(0.0);\n    \n    float tBall = traceBall(O,D);\n    float tTable = traceTable(O, D);\n    float tSupport = traceSupport(O, D);\n    \n    \n    if ((tBall > 0.0) && (tBall < tSupport || tSupport < 0.0) && (tBall < tTable || tTable < 0.0)) {\n        // snowGlobe\n        \n        vec3 pos = O+D*tBall;\n\n        /* ********** refraction ********** */\n        vec3 refrRay = normalize(refract(D, normalize(pos), IOR));\n        \n        col = renderInsideGlobe(pos + refrRay * SURF_DIST*2., refrRay);\n        \n        // col = shadeBall(O+D*rm.x, D);\n              \n        /* ********** reflection ********** **/\n        vec3 reflRay = normalize(reflect(D, normalize(pos)));\n        vec3 reflColor = renderOutsideGlobe(pos + reflRay * SURF_DIST*2., reflRay);\n              \n        \n        col += max(phong(lig, D, normalize(pos), 10.0), 0.0); // add ball specular\n\n        float normDotRay = dot(normalize(pos), -D);\n        col = mix(col, reflColor, (1.0 - normDotRay)*0.5); // add reflection ray (atenuated using dot)\n        col += (1.0 - normDotRay) * 0.2; // ligten\n        \n        vec4 flake = blizzard(pos + refrRay * SURF_DIST, refrRay, 200.);\n        col = mix(col.rgb, flake.rgb, flake.a);\n        \n        col = mix(col.rgb, vec3(0.9, 0.95, 1.0), (normDotRay)*0.5);\n\n\n    \n    } else if ((tSupport > 0.) && (tSupport < tTable || tTable < 0.0)) {\n        col = shadeSupport(O+D*tSupport, D);\n    } else if (tTable > 0.) {\n        col = shadeTable(O+D*tTable, D);\n    }else {\n        col = background(D);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.1; // zoom\n\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n            \n            float radius = 1.3;\n            float rotationSpeed = 0.03;\n            vec3 O = vec3(radius*cos(rotationSpeed*iTime*2.*PI), 1.5 * iMouse.y * 0.002, radius*sin(rotationSpeed*iTime*2.*PI)); // origin\n            \n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n            \n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // gamma corection\n    // finalColor = pow(finalColor, vec3(1./2.2));\n\n    // color grading\n    // finalColor *= vec3(1.07 ,0.92, 0.95);\n    \n\tfragColor = vec4(finalColor,1.);\n}","name":"Image","description":"","type":"image"}]}