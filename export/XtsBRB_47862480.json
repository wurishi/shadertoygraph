{"ver":"0.1","info":{"id":"XtsBRB","date":"1512405927","viewed":197,"name":"3d rendering second","username":"kparga","description":"TODO:\n-microphone controlled particles\n-refractive sphere\n-metalic cilinder ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/Xds3zN\n// https://www.shadertoy.com/view/MscXzn\n// https://www.shadertoy.com/view/XdVSRV\n\n//----------------------\n\n// Constants\nconst float GEO_MAX_DIST  \t\t\t\t= 1000.0;\nconst int MATERIALID_NONE   \t\t   \t= 0;\nconst int MATERIALID_FLOOR     \t\t\t= 1;\nconst int MATERIALID_ICE_OUTER \t\t\t= 2;\nconst int MATERIALID_ICE_INNER \t\t\t= 3;\nconst int MATERIALID_SKY       \t\t\t= 4;\nconst int MATERIALID_GOLD\t   \t\t\t= 5;\nconst int MATERIALID_PINK_PLASTIC\t\t= 6;\nconst int MATERIALID_BLUE_PLASTIC \t  \t= 7;\nconst int MATERIALID_CHANGE_PLASTIC   \t= 8;\n//----------------------\n// Slider bound globals.\nfloat ROUGHNESS      = 0.25; //sliderVal[0]\nfloat ISOVALUE       = 0.03; //sliderVal[1]\nfloat ICE_COLOR      = 0.00; //sliderVal[2]\nfloat REFRACTION_IDX = 1.31; //sliderVal[3]\n\nstruct TraceData\n{\n    float rayLen;\n    vec3  rayDir;\n    vec3  normal;\n    int   matID;\n    vec3  matUVW;\n    float alpha;\n};\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec3 normalMap(vec3 p, vec3 n);\nTraceData TRACE_geometry(vec3 o, vec3 d);\nTraceData TRACE_reflexion(vec3 o, vec3 d);\nTraceData TRACE_translucentDensity(vec3 o, vec3 d);\nTraceData TRACE_cheap(vec3 o, vec3 d);\n\nfloat RAYMARCH_DFSS(vec3 ro, vec3 rd, float coneWidth);\n\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    vec3 L = normalize(vec3(-0.6,0.7,-0.5));\n    vec4 col = vec4(traceData.alpha);\n\n    if(traceData.matID==MATERIALID_NONE)\n    {\n        return vec4(0,0,0,1);\n    }\n    else if(traceData.matID==MATERIALID_ICE_INNER)\n    {\n        //NOTE : Coloring is not physically accurate.\n        //       For this to be more accurate,\n        //       it should probably be computed like fog.\n        //       (in scattering, out scattering / extinction coefficient?).\n        vec3 cRed   = vec3( 0.70,-0.5,-0.60);\n        vec3 cGreen = vec3(-0.50, 0.0,-0.5);\n        vec3 cBlue  = vec3(-0.50,-0.5, 0.30);\n        vec3 cGrey  = vec3(-0.3); //Glass (~extinction coefficient, more or less)\n        vec3 cWhite = vec3(1.0); //Ice (pseudo \"in scattering\")\n\n        col.rgb = mix(cWhite ,cGrey, smoothstep(0.00,0.20,ICE_COLOR));\n        col.rgb = mix(col.rgb,cBlue, smoothstep(0.20,0.40,ICE_COLOR));\n        col.rgb = mix(col.rgb,cGreen,smoothstep(0.40,0.60,ICE_COLOR));\n        col.rgb = mix(col.rgb,cRed , smoothstep(0.60,0.80,ICE_COLOR));\n    }\n    else if(traceData.matID==MATERIALID_SKY)\n    {\n        col.rgb = vec3(0.6,0.7,0.85);\n    }\n    else if(traceData.matID==MATERIALID_FLOOR)\n    {\n\n        vec3 cDiff = vec3(0.45, 0.2, 0.85);\n        /*vec3 cDiff = pow(texture(iChannel1,traceData.matUVW.xz).rgb,vec3(1.2));*/\n        float dfss = RAYMARCH_DFSS(pos, L, 0.07);\n        col.rgb = cDiff*(0.45+1.2*(dfss));\n\n\n    }\n    else if(traceData.matID==MATERIALID_GOLD)\n    {\n        vec3 goldColor = vec3(1.1, 0.91, 0.52);\n        vec3 goldColor2 = vec3(1.1, 1.07, 0.88);\n        vec3 goldColor3 = vec3(1.02, 0.82, 0.55);\n        float goldRef = 0.99;\n\n        pos+= 0.4*noise(pos*24.);\n        float t = noise(pos*30.);\n        vec3 col = mix(goldColor, goldColor2, smoothstep(0.55, 0.95, t));\n        col = mix(col, goldColor3, smoothstep(0.45, 0.25, t));\n\n    }\n\n    else if(traceData.matID==MATERIALID_PINK_PLASTIC)\n    {\n        col.rgb = vec3(0.94,0.61,0.78);\n        /*vec3 cDiff = vec3(0.45, 0.2, 0.85);\n        /*vec3 cDiff = pow(texture(iChannel1,traceData.matUVW.xz).rgb,vec3(1.2));\n        float dfss = RAYMARCH_DFSS(pos, L, 0.07);\n    \tcol.rgb = cDiff*(0.45+1.2*(dfss));*/\n    }\n\n    else if(traceData.matID==MATERIALID_BLUE_PLASTIC)\n    {\n        col.rgb = vec3(0.4,0.6,0.88);\n    }\n\n    else if(traceData.matID==MATERIALID_CHANGE_PLASTIC)\n    {\n        col.rgb = vec3(sin(iTime), sin (iTime+50.), sin(iTime-50.));\n    }\n\n    return col;\n}\n\nstruct IceTracingData\n{\n    TraceData reflectTraceData;\n    TraceData translucentTraceData;\n    TraceData exitTraceData;\n};\n\nIceTracingData renderIce(TraceData iceSurface, vec3 ptIce, vec3 dir)\n{\n    IceTracingData iceData;\n\n    vec3 normalDelta = normalMap(ptIce*ROUGHNESS,iceSurface.normal)*ROUGHNESS/10.;\n\n    vec3 iceSurfaceNormal = normalize(iceSurface.normal+normalDelta);\n    vec3 refract_dir = refract(dir,iceSurfaceNormal,1.0/REFRACTION_IDX); //Ice refraction index = 1.31\n    vec3 reflect_dir = reflect(dir,iceSurfaceNormal);\n\n    //Trace reflection\n    iceData.reflectTraceData = TRACE_reflexion(ptIce,reflect_dir);\n\n    //Balance between refraction and reflection (not entirely physically accurate, Fresnel could be used here).\n    float fReflectAlpha = 0.5*(1.0-abs(dot(normalize(dir),iceSurfaceNormal)));\n    iceData.reflectTraceData.alpha = fReflectAlpha;\n    vec3 ptReflect = ptIce+iceData.reflectTraceData.rayLen*reflect_dir;\n\n    //Trace refraction\n    iceData.translucentTraceData = TRACE_translucentDensity(ptIce,refract_dir);\n\n    vec3 ptRefract = ptIce+iceData.translucentTraceData.rayLen*refract_dir;\n    vec3 exitRefract_dir = refract(refract_dir,-iceData.translucentTraceData.normal,REFRACTION_IDX);\n\n    //This value fades around total internal refraction angle threshold.\n    if(length(exitRefract_dir)<=0.95)\n    {\n        //Total internal reflection (either refraction or reflexion, to keep things cheap).\n        exitRefract_dir = reflect(refract_dir,-iceData.translucentTraceData.normal);\n    }\n\n    //Trace environment upon exit.\n    iceData.exitTraceData = TRACE_cheap(ptRefract,exitRefract_dir);\n    iceData.exitTraceData.matID = MATERIALID_FLOOR;\n\n    return iceData;\n}\n\nstruct GoldTracingData\n{\n    TraceData reflectTraceData;\n    TraceData exitTraceData;\n};\n\nGoldTracingData renderGold(TraceData goldSurface, vec3 ptGold, vec3 dir)\n{\n    GoldTracingData goldData;\n\n    vec3 normalDelta = normalMap(ptGold*ROUGHNESS,goldSurface.normal)*ROUGHNESS/10.;\n\n    vec3 goldSurfaceNormal = normalize(goldSurface.normal+normalDelta);\n    vec3 reflect_dir = reflect(dir,goldSurfaceNormal);\n\n    //Trace reflection\n    goldData.reflectTraceData = TRACE_reflexion(ptGold,reflect_dir);\n\n    //Balance between refraction and reflection (not entirely physically accurate, Fresnel could be used here).\n    float fReflectAlpha = 0.5*(1.0-abs(dot(normalize(dir),goldSurfaceNormal)));\n    goldData.reflectTraceData.alpha = fReflectAlpha;\n    vec3 ptReflect = ptGold+goldData.reflectTraceData.rayLen*reflect_dir;\n\n    vec3 ptRefract = vec3(0., 0., 0.);\n    vec3 exitRefract_dir = vec3(0., 0., 0.);\n\n    //Trace environment upon exit.\n    goldData.exitTraceData = TRACE_cheap(ptRefract,exitRefract_dir);\n    goldData.exitTraceData.matID = MATERIALID_GOLD;\n\n    return goldData;\n}\n\nstruct PlasTracingData\n{\n    TraceData reflectTraceData;\n    TraceData exitTraceData;\n};\n\nPlasTracingData renderPlas(TraceData plasSurface, vec3 ptPlas, vec3 dir)\n{\n    PlasTracingData plasData;\n\n    vec3 normalDelta = normalMap(ptPlas*ROUGHNESS,plasSurface.normal)*ROUGHNESS/10.;\n\n    vec3 plasSurfaceNormal = normalize(plasSurface.normal+normalDelta);\n    vec3 reflect_dir = reflect(dir,plasSurfaceNormal);\n\n    //Trace reflection\n    plasData.reflectTraceData = TRACE_reflexion(ptPlas,reflect_dir);\n\n    //Balance between refraction and reflection (not entirely physically accurate, Fresnel could be used here).\n    float fReflectAlpha = 0.5*(1.0-abs(dot(normalize(dir),plasSurfaceNormal)));\n    plasData.reflectTraceData.alpha = fReflectAlpha;\n    vec3 ptReflect = ptPlas+plasData.reflectTraceData.rayLen*reflect_dir;\n\n    vec3 ptRefract = vec3(0., 0., 0.);\n    vec3 exitRefract_dir = vec3(0., 0., 0. );\n\n    //Trace environment upon exit.\n    plasData.exitTraceData = TRACE_cheap(ptRefract,exitRefract_dir);\n    plasData.exitTraceData.matID = MATERIALID_BLUE_PLASTIC;\n\n    return plasData;\n}\n\nvec3 main_render( vec3 o, vec3 dir, vec2 uv)\n{\n    vec3 pt = o;\n\n    vec3 ptGeometry = vec3(0);\n    vec3 ptReflect = vec3(0);\n\n    TraceData geometryTraceData = TRACE_geometry(pt, dir);\n    ptGeometry = o+geometryTraceData.rayLen*dir;\n\n    IceTracingData iceData;\n    GoldTracingData goldData;\n    PlasTracingData plasData;\n\n    iceData.translucentTraceData.rayLen = 0.0;\n    if(geometryTraceData.matID == MATERIALID_ICE_OUTER && geometryTraceData.rayLen < GEO_MAX_DIST)\n    {\n        vec3 ptIce = ptGeometry;\n        iceData = renderIce(geometryTraceData, ptIce, dir);\n        geometryTraceData = iceData.exitTraceData;\n\n        vec3 ptRefract = ptIce+iceData.translucentTraceData.rayLen*iceData.translucentTraceData.rayDir;\n        ptReflect = ptIce+iceData.reflectTraceData.rayLen*iceData.reflectTraceData.rayDir;\n        ptGeometry = ptRefract+geometryTraceData.rayLen*dir;\n\n        //<Debug section, not mandatory>\n        //[0.80-1.00] = Debug color range.\n        if(ICE_COLOR>0.95) return iceData.exitTraceData.rayDir;\n        if(ICE_COLOR>0.90) return max(iceData.exitTraceData.matUVW,vec3(0));\n        if(ICE_COLOR>0.85) return iceData.translucentTraceData.rayLen*vec3(1);\n        if(ICE_COLOR>0.80) return iceData.reflectTraceData.alpha*vec3(1);\n        //</Debug section, not mandatory>\n    }\n    else if(geometryTraceData.matID == MATERIALID_GOLD && geometryTraceData.rayLen < GEO_MAX_DIST)\n    {\n        vec3 ptGold = ptGeometry;\n        goldData = renderGold(geometryTraceData, ptGold, dir);\n        geometryTraceData = goldData.exitTraceData;\n\n        vec3 ptRefract = vec3(0.,0., 0.);\n        ptReflect = ptGold+goldData.reflectTraceData.rayLen*goldData.reflectTraceData.rayDir;\n        ptGeometry = ptRefract+geometryTraceData.rayLen*dir;\n\n    }\n\n    //cTerrain is either direct ray or refract ray.\n    vec4 cTerrain  = MAT_apply(ptGeometry,geometryTraceData);\n    vec4 cIceInner = MAT_apply(ptGeometry,iceData.translucentTraceData);\n    vec4 cReflect  = MAT_apply(ptReflect,iceData.reflectTraceData);\n\n    if(iceData.translucentTraceData.rayLen > 0.0 )\n    {\n        float fTrav = iceData.translucentTraceData.rayLen;\n        vec3 cRefract = cTerrain.rgb;\n        cRefract.rgb = mix(cRefract,cIceInner.rgb,0.3*fTrav+0.2*sqrt(fTrav*3.0));\n        cRefract.rgb += fTrav*0.3;\n        vec3 cIce = mix(cRefract,cReflect.rgb,iceData.reflectTraceData.alpha);\n        return cIce;\n    }\n    return cTerrain.rgb;\n}\n\nstruct DF_out\n{\n    float d;  //Distance to geometry\n    int matID;//Geometry material ID\n};\n\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, vec3 h )// h = { cos a, sin a, height }\n{\n\n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return octa;\n\n}\n\n//----------------------------------------------------------------------\n\nfloat opSmoothSubtract( float d1, float d2 )\n{\n    return length(vec2(max(d1,0.),min(d2,0.0)));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return (d1<d2) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float t = 20.0*sin(iTime);\n    float  c = cos(t*p.y+10.0);\n    float  s = sin(t*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nDF_out map( in vec3 pos )\n{\n    float dist = opU( sdPlane(     pos-vec3( -1.) ),\n                      sdSphere(pos-vec3(0.0,0.40+abs(0.3*sin(iTime+5.0)), 0.0), 0.40 ) );\n\n    DF_out outData;\n    outData.d = dist-ISOVALUE;\n    outData.matID = MATERIALID_ICE_OUTER;\n\n    dist = opU( dist, sdTorus(     pos-vec3( -1.0,0.4, 1.0), vec2(0.3,0.1) ) );\n    outData.matID = MATERIALID_CHANGE_PLASTIC;\n\n    dist = opU( dist, sdCylinder(  pos-vec3( 1.0,0.55,-1.0), vec2(0.1,0.4) ) );\n    outData.matID = MATERIALID_GOLD;\n\n    dist = opU( dist, 0.25*sdTorus( opTwist(pos-vec3(1.0,0.55, 1.0)),vec2(0.3,0.1)) );\n    outData.matID = MATERIALID_PINK_PLASTIC;\n\n    dist = opU( dist, sdOctahedron( pos-vec3(-1.0,0.55 +0.1*sin(iTime),-1.0), vec3(0.8,0.6,0.25) ));\n    outData.matID = MATERIALID_BLUE_PLASTIC;\n\n    return outData;\n}\n\nvec3 gradient( in vec3 p )\n{\n    const float d = 0.001;\n    vec3 grad = vec3(map(p+vec3(d,0,0)).d-map(p-vec3(d,0,0)).d,\n                     map(p+vec3(0,d,0)).d-map(p-vec3(0,d,0)).d,\n                     map(p+vec3(0,0,d)).d-map(p-vec3(0,0,d)).d);\n    return grad;\n}\n\nvec2 sphereTracing( const vec3 o, const vec3 d, const float tmin, const float eps, const bool bInternal)\n{\n    //https://iquilezles.org/articles/raymarchingdf\n    //http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf p.5-89\n    //[modified for internal marching]\n    float tmax = 10.0;\n    float t = tmin;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ )\n    {\n        vec3 p = o+d*t;\n        dist = (bInternal?-1.:1.)*map(p).d;\n        if( abs(dist)<eps || t>tmax )\n            break;\n        t += dist;\n    }\n\n    dist = (dist<tmax)?dist:GEO_MAX_DIST;\n    return vec2( t, dist );\n}\n\nTraceData TRACE_getFront(const in TraceData tDataA, const in TraceData tDataB)\n{\n    if(tDataA.rayLen<tDataB.rayLen)\n    {\n        return tDataA;\n    }\n    else\n    {\n        return tDataB;\n    }\n}\n\nfloat RAYCAST_floor(vec3 o, vec3 d)\n{\n    vec3 n = vec3(0,1,0);\n    vec3 p = vec3(-0.1);\n    float t = dot(p-o,n)/dot(d,n);\n    return (t<0.0)?GEO_MAX_DIST:t;\n}\n\n//o=origin, d = direction\nTraceData TRACE_cheap(vec3 o, vec3 d)\n{\n    TraceData floorData;\n    floorData.rayLen  = RAYCAST_floor(o, d);\n    floorData.rayDir  = d;\n    floorData.normal  = vec3(0,1,0);\n    floorData.matUVW  = o+d*floorData.rayLen;\n    floorData.matID   = MATERIALID_FLOOR;\n    floorData.alpha   = 1.0;\n\n    TraceData skyData;\n    skyData.rayLen  = 50.0;\n    skyData.rayDir  = d;\n    skyData.normal  = -d;\n    skyData.matUVW  = d;\n    skyData.matID   = MATERIALID_SKY;\n    skyData.alpha   = 1.0;\n    return TRACE_getFront(floorData,skyData);\n}\n\nTraceData TRACE_reflexion(vec3 o, vec3 d)\n{\n    return TRACE_cheap(o,d);\n}\n\n//o=origin, d = direction\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    TraceData cheapTrace = TRACE_cheap(o,d);\n\n    TraceData iceTrace;\n    vec2 rayLen_geoDist = sphereTracing(o,d,0.1,0.0001,false);\n    vec3 iceHitPosition = o+rayLen_geoDist.x*d;\n    iceTrace.rayDir     = d;\n    iceTrace.rayLen     = rayLen_geoDist.x;\n    iceTrace.normal     = normalize(gradient(iceHitPosition));\n    iceTrace.matUVW     = iceHitPosition;\n    iceTrace.matID      = MATERIALID_ICE_OUTER;\n    iceTrace.alpha      = 0.0;\n\n    return TRACE_getFront(cheapTrace,iceTrace);\n}\n\n//o=origin, d = direction\nTraceData TRACE_translucentDensity(vec3 o, vec3 d)\n{\n    TraceData innerIceTrace;\n\n    vec2 rayLen_geoDist   = sphereTracing(o,d,0.01,0.001,true).xy;\n    vec3 iceExitPosition  = o+rayLen_geoDist.x*d;\n    innerIceTrace.rayDir  = d;\n    innerIceTrace.rayLen  = rayLen_geoDist.x;\n    innerIceTrace.normal  = normalize(gradient(iceExitPosition));\n    innerIceTrace.matUVW  = iceExitPosition;\n    innerIceTrace.matID   = MATERIALID_ICE_INNER;\n    innerIceTrace.alpha   = rayLen_geoDist.x;\n    return innerIceTrace;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\n//o=origin, L = light direction\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    //Variation of the Distance Field Soft Shadow from : https://www.shadertoy.com/view/Xds3zN\n    //Initialize the minimum aperture (angle tan) allowable with this distance-field technique\n    //(45deg: sin/cos = 1:1)\n    float minAperture = 1.0;\n    float t = 0.0;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<6; i++ )\n    {\n        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance\n        float dist = map( p ).d;\n        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        t += 0.03+dist; //0.03 : min step size.\n    }\n\n    //The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture/coneWidth); //Should never exceed [0-1]. 0 = shadow, 1 = fully lit.\n}\n\nvec3 smoothSampling(vec2 uv)\n{\n    const float T_RES = 64.0;\n    vec2 x = fract(uv*T_RES+0.5);\n    vec2 pc1 = uv-(x)/T_RES;\n    //vec2 t = x * x * (3.0 - 2.0 * x);\n    vec2 t = (6.*x*x-15.0*x+10.)*x*x*x; //ease function\n    return textureLod(iChannel0,pc1+t/T_RES,0.0).xyz;\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling(p.yz).x\n             +abs(n.y)*smoothSampling(p.xz).x\n             +abs(n.z)*smoothSampling(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\nstruct Cam\n{\n    vec3 R;//Right,\n    vec3 U;//Up,\n    vec3 D;//Direction,\n    vec3 o;//origin (pos)\n};\nCam CAM_animate(vec2 uv)\n{\n    float PI = 3.14159;\n    float rotX = 2.0*PI*(iMouse.x/iResolution.x+iTime*0.05);\n    Cam cam;\n    cam.o = vec3(cos(rotX),0.6,sin(rotX))*2.9;\n    cam.D = normalize(vec3(0,-0.25,0)-cam.o);\n    cam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = cross(cam.R,cam.D);\n    return cam;\n}\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv *= 2.0*iResolution.x/iResolution.y;;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D*2.5);\n}\n\nvec4 processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel2,vec2(0,0));\n    ROUGHNESS       = sliderVal[0]*4.0;\n    ISOVALUE        = 0.005+sliderVal[1]*0.1;\n    ICE_COLOR       = sliderVal[2];\n    REFRACTION_IDX  = 1.0+sliderVal[3];\n\n    if(length(fragCoord.xy-vec2(0,0))>1.)\n    {\n        return texture(iChannel2,fragCoord.xy/iResolution.xy);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 cSlider = processSliders(fragCoord);\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n\n    Cam cam = CAM_animate(uv);\n    vec3 d = CAM_getRay(cam,uv);\n    vec3 c = main_render(cam.o, d, uv);\n\n    //Vignetting\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n\n    //Gamma\n    c = pow(c,vec3(0.4545)); //2.2 Gamma compensation\n\n    //Apply slider overlay\n    c = mix(c,cSlider.rgb,cSlider.a);\n\n    fragColor = vec4(c,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A : slider management (this is not required)\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec4 sliderVal = vec4(0.25,0.22,0,0.31); //Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = textureLod(iChannel0,vec2(0),0.0);\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)/height;\n        t = clamp(t/0.75-0.125,0.,1.); //25% top/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)/width, t);\n    }\n}\n\n//Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  //Cursor radius, in local space\n    const float LW  = 0.030; //Line width\n    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    /*float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization\n    muv = (muv-cMin)/vec2(width,height); //mouse Normalization\n    if( withinUnitRect(uv) )\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); //repeat 4x\n\t\tuv.y = uv.y/0.75-0.125; //25% margins\n        return SLIDER_drawSingle(uv,t,ar,bHighlight);\n    }*/\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.9,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.00);\n    vec2 uvSliders = fragCoord.xy / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buf A","description":"","type":"buffer"}]}