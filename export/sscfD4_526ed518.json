{"ver":"0.1","info":{"id":"sscfD4","date":"1656462968","viewed":126,"name":"Newton fractal, 5th degree","username":"zenzicubic","description":"Newton fractal","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n#define SCALE 2.0\n#define ITERS 50\n#define TOL 1e-10\n#define NUMROOTS 5\n\nvec3 colors[NUMROOTS] = vec3[](\n    vec3(0.204,0.204,0.29),\n    vec3(0.502,0.278,0.369),\n    vec3(0.8,0.353,0.443),\n    vec3(0.784,0.608,0.482),\n    vec3(0.941,0.969,0.341)\n);\n\nvec2 roots[NUMROOTS];\n\n// complex number utils\nvec2 fromRoot(float n, float k)\n{\n    float t = (2.0 * PI * k) / n;\n    return vec2(cos(t), sin(t));\n}\n\nvec2 cmul(vec2 a, vec2 b) \n{\n    float c = a.x * b.x - a.y * b.y;\n    float d = a.y * b.x + a.x * b.y;\n    return vec2(c, d);\n}\n\nvec2 cdiv(vec2 a, vec2 b) \n{\n    float d = a.y * b.x - a.x * b.y;\n    float l = dot(b, b);\n    return vec2(dot(a, b) / l, d / l);\n}\n\n\nvec3 brighten(vec3 col, float fac) \n{\n    float r = clamp(col.x * fac, 0., 1.);\n    float g = clamp(col.y * fac, 0., 1.);\n    float b = clamp(col.z * fac, 0., 1.);\n    return vec3(r, g, b);\n}\n\n// function and derivative for Newton\nvec2 f(vec2 z) \n{\n    vec2 prod = vec2(1, 0);\n    for (int i = 0; i < NUMROOTS; i ++)\n    {\n        prod = cmul(prod, z - roots[i]);\n    }\n    return prod;\n}\n\nvec2 df(vec2 z) \n{\n    vec2 sum, prod;\n    for (int i = 0; i < NUMROOTS; i ++) {\n        prod = vec2(1., 0.);\n        for (int j = 0; j < NUMROOTS; j ++)\n        {\n            if (i != j) {\n                prod = cmul(prod, z - roots[j]);\n            }\n        }\n        sum += prod;\n    }\n    return sum;\n}\n\nvec2 scale(vec2 fragCoord)\n{\n    vec2 pos = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    vec2 z = (2.0 * SCALE * pos) - SCALE;\n    z.x *= ratio;\n    \n    return z;\n}\n\nvec4 test(vec2 z)\n{\n    float dist, col;\n    \n    for (int i = 0; i < ITERS; i ++) \n    {\n        z -= cdiv(f(z), df(z));\n        for (int j = 0; j < NUMROOTS; j ++)\n        {\n            dist = distance(z, roots[j]);\n            if (dist < TOL) \n            {\n                col = 1. - (float(i) / float(ITERS));\n                return vec4(colors[j], col);\n            }\n        }\n    }\n    return vec4(colors[0], 0.);\n}\n\nvoid fillRoots() \n{\n    for (int i = 0; i < NUMROOTS; i ++) \n    {\n        roots[i] = fromRoot(float(NUMROOTS), float(i));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fillRoots();\n    vec2 z = scale(fragCoord);\n\n    vec4 col_raw = test(z);\n    vec3 col = brighten(col_raw.xyz, col_raw.w);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}