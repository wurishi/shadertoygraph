{"ver":"0.1","info":{"id":"NtcGz4","date":"1635804493","viewed":164,"name":"Chase on asteroid","username":"kastorp","description":"Damn, an enemy ship is on our mining base!\n\n","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["asteroid","chase","surfacenets"],"hasliked":0,"parentid":"ftt3zn","parentname":"Surface nets III"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Chase on Asteroid by Kastorp\n//------------------------------------------------\nvoid mainImage( out vec4 O, in vec2 U ) {\n    float ps = iResolution.y>MR?.5:1.;\n    O = texture(iChannel2, U * ps/ iResolution.xy); //upscale if fullscreen\n    \n    //viewfinder\n    O=mix( O, vec4(1,0,0,0),smoothstep(.02,.01,abs(abs(U.x/iResolution.x-.5)-.05))*smoothstep(0.01,0.00,abs(U.y/iResolution.y-.5)));\n    O=mix( O, vec4(1,0,0,0),smoothstep(.02,.01,abs(abs(U.y/iResolution.y-.5)-.05))*smoothstep(0.01,0.00,abs(U.x/iResolution.x-.5))); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float L= 30.;  //cube size (where cube.z =max(R.x*R.y/L/L,L)           \nvec3 offset = floor(vec3(0.,0.,-L/2.)); //center coordinates\nconst vec2 pcs= ceil(sqrt(L) * vec2(1.25 ,0.8)); // iResolution.xy/iResolution.yx \n#define MR 600. //maximum not upscaled resolution\n#define R ( iResolution.xy*(iResolution.y>MR?.5:1.))\n//-----------------------------------------\n// VOXEL CACHE FUNCTIONS from fb39ca4\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float o = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - o);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float o = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + o;\n}\n\nvec3 texToVoxCoord(vec2 t, vec3 offset) {\n\tvec3 v = offset;\n    v.xy += unswizzleChunkCoord(t / pcs);\n    v.z += mod(t.x, pcs.x) + pcs.x * mod(t.y, pcs.y);\n    return v;\n}\n\nvec2 voxToTexCoord(vec3 v) {\n    vec3 p = floor(v);return swizzleChunkCoord(p.xy) * pcs + vec2(mod(p.z, pcs.x), floor(p.z / pcs.x));\n}\n\nvec4  getVoxel(vec3 p,sampler2D iChannel) {\n    p.z-= offset.z;\n    if(p.z>pcs.x * pcs.y || p.z<0.){return vec4(0.);}  \n    return texelFetch(iChannel, ivec2(voxToTexCoord(p))  , 0); \n}\n\n\n//-----------Intersection functions--------------------\n#define NOHIT 1e5\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\tvec3 fuv;  //face & uv \n};\nconst its  NO_its=its(NOHIT,vec3(0.),vec3(0.));\nstruct span\n{\n\tits n;\n\tits f;\n};\n\nstruct RayOut{   \n    float d;\n    vec3 n;\n    vec3 fuv; //unused here\n    float id;\n    float d2;\n};\n\nRayOut FastUnion(  RayOut a, RayOut b)\n{\n   if(a.d<b.d) return a;\n   else return b;\n}\n#define Add(_ro,_func) _ro = FastUnion(_ro,_func);\n\nRayOut InfRay(){return RayOut(NOHIT,vec3(0),vec3(0),0.,0.);}\nRayOut Ray(span s,float mat){    \n    if(s.f.t<0. ||(s.f.t==NOHIT && s.n.t<0. )) return  InfRay();\n    if(s.n.t<0. && s.f.t>0.  ) return RayOut(0.001,vec3(0),vec3(0),mat,s.f.t);\n    return RayOut( s.n.t,s.n.n,s.n.fuv,mat,s.f.t-s.n.t);\n}\n\nspan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return span(NO_its,NO_its); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 oFuv=vec3(0.,atan(oNor.y,length(oNor.xz)),atan(oNor.z,oNor.x))*ra*1.5708  ;\n    vec3 fNor= normalize(ro-(b-h)*rd); \n    vec3 fFuv=vec3(0.,atan(fNor.y,length(fNor.xz)),atan(fNor.z,fNor.x))*ra*1.5708  ;\n    if( h-b < 0. ) return  span(NO_its,NO_its);\n    return span(its(-b-h,oNor,oFuv) , its(-b+h,-fNor,fFuv));\n}\n\nspan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    vec3 oFuv=vec3( dot(abs(oNor),vec3(1,5,9)+ oNor)/2.,dot(ro+rd*tN,oNor.zxy),dot(ro+rd*tN,oNor.yzx));      \n    vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    vec3 fFuv=vec3( dot(abs(fNor),vec3(1,5,9)+ fNor)/2.,dot(ro+rd*tF,fNor.zxy),dot(ro+rd*tF,fNor.yzx));\n    return  span(its(tN,oNor,oFuv) , its(tF,fNor,fFuv));\n}\n\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d= -(dot(ro,n)+h)/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oFuv=vec3(1.,dot(ro+d*rd,u), dot(ro+d*rd,v));\n    vec3 oNor=n;\n    if(d<0.)  return span(NO_its,NO_its);\n    return span(its(d,oNor,oFuv),NO_its);\n}\n\nspan iCylinder( in vec3 ro, in vec3 rd,  in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, \n{\n    span no_hit =  span(NO_its,NO_its);;\n\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 )  return no_hit;\n    h = sqrt(h);\n    \n    float t = (-k1-h)/k2;\n    float y = baoc + t*bard; \n    float t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;   \n    \n    if( (y<0.0 || y>baba )  && abs(k1+k2*t2)>h)  return span(NO_its,NO_its);\n    its iN,iF;\n    vec3 w = normalize(ba), u = normalize(cross(ba,vec3(0,0,1))), v = normalize(cross(u,w) );\n    \n    //entry point\n    vec3 q = (oc+t*rd-ba)*mat3(u,v,w);   \n    if( y>0.0 && y<baba ) iN= its( t, (oc+t*rd - ba*y/baba)/ra,vec3(0.,atan(q.y,q.x)*ra,q.z) ); \n    else iN= its(t2, ba*sign(y)/baba ,vec3(1.,dot(oc+t2*rd-ba,u) ,dot(oc+t2*rd-ba,v) )); \n        \n  \n    //exit point\n    t = (-k1+ h)/k2;\n    y = baoc + t*bard; \n    t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    q = (oc+t*rd-ba)*mat3(u,v,w); \n    if( y>0.0 && y<baba ) iF= its( t, (oc+t*rd - ba*y/baba)/ra,vec3(0.,atan(q.y,q.x)*ra,q.z) ); \n    else iF= its(t2, ba*sign(y)/baba ,vec3(1.,dot(oc+t2*rd-ba,u) ,dot(oc+t2*rd-ba,v) )); \n    \n    return span(iN , iF);\n  \n}\n\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\n\n//from https://www.shadertoy.com/view/Ns2SzG by Oneshade\nspan iBilinearPatch(in vec3 ro, in vec3 rd,in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    bool tr=false;\n    if(abs(rd.x)<.0001){  //not working if rd.x==0.\n         //return span(its(.01,vec3(0),vec3(0)),NO_its);\n        tr=true; ro=ro.yzx;rd=rd.yzx;a=a.yzx;b=b.yzx;c=c.yzx;d=d.yzx;\n    }\n    vec2 m = rd.yz / rd.x;\n    if(length(a - b + c - d)==0.)  a+=vec3(.001); //fix coplanar issue\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;\n    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;\n\n    // Quadratic coefficients (reversed as a trick to deal with edge cases)\n    float qa = cross2D(c4, c2);\n    float qb = cross2D(c4, c1) + cross2D(c3, c2);\n    float qc = cross2D(c3, c1);\n   \n    float discr = (qb * qb - 4.0 * qa * qc);\n    span s=span(NO_its,NO_its);\n    if (discr > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve quadratic in v\n        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x);\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x;\n\n        // Get closest intersection in view and add it to the scene        \n        if (abs(u[0] - 0.5) < 0.5 && abs(v[0] - 0.5) < 0.5) \n             s.n= its(t[0],normalize(cross(p * v[0] + q, p * u[0] + r)),vec3(0.,u[0], v[0]));\n        if ( abs(u[1] - 0.5) < 0.5 && abs(v[1] - 0.5) < 0.5) \n             s.f= its(t[1],normalize(cross(p * v[1] + q, p * u[1] + r)),vec3(0.,u[1], v[1])); \n        if (s.f.t<s.n.t){ its tp=s.n;s.n=s.f;s.f=tp;}     \n        s.n.n*=-sign(dot(s.n.n,rd));\n        s.f.n*=-sign(dot(s.f.n,rd));\n    }\n    if(tr) {s.n.n=s.n.n.zxy;s.f.n=s.f.n.zxy;}\n    return s;\n}\n\n\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//SDF of asteroid\n\nfloat smin(float a, float b, float k){float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);return mix(b, a, h) - k*h*(1.0-h);}\nfloat smax(float a, float b, float k){ return smin(a, b, -k);}\nfloat map(vec3 p)\n{   \n    float z =.8;\n    float s =12.*z;\n    p*=z;\n    float d0=dot(sin(p),cos(p.yzx))+.01;       \n    float d2=length(p)-s;\n    float d=smax(-d0,d2,3.); \n    return d;\n}\n\n//Shane  Tri-Planar blending function\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n//-------------------------------------------\n//Starfield based on https://www.shadertoy.com/view/ltBXDd bt FabriceNeyret\n\n#define RR(U,d) fract( 1e4* sin( U*mat2(1234,-53,457,-17)+d ) )\n\nfloat MM(vec2 U, float t) {           // --- texture layer\n   vec2 iU = ceil(U/=exp2(t-8.)),              // quadtree cell Id - infinite zoom\n          P = .2+.6*RR(iU,0.);                  // 1 star position per cell\n    float r = 9.* RR(iU,1.).x;                  // radius + proba of star ( = P(r<1) )\n\treturn r > 1. ? 1. :   length( P - fract(U) ) * 8./(1.+5.*r) ;\n}\n\nvec3 Starfield(  vec2 U )\n{\n    float D=8., Z=3.;               // D: duration of advection layers, Z: zoom factor\n\n    vec3 o =vec3(0.);\n    //U = U / iResolution.y - .5;\n    vec3 P = vec3(-1,0,1)/3., T,\n         t = fract( 1./D + P +.5 )-.5,  // layer time iTime=1.\n         w = .5+.5*cos(6.28*t);                  // layer weight\n    t = t*D+Z;  \n    T.x = MM(U,t.x),  T.y = MM(-U,t.y),  T.z = MM(U.yx,t.z); // avoid using same U for all layers\n    T = .03/(T*T);\n    o += dot(w,T);\n    return o;\n}\nvec3 StarField3D( in vec3 p, in vec3 n ){ \n    n=abs(n);\n    vec3 m = step(n.yzx,n) * step(n.zxy,n);\n    \n\tp = Starfield( p.yz)*m.x + Starfield( p.zx)*m.y + Starfield( p.xy)*m.z;\n    return p*p;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// SURFACE NET DATA BUFFER\n\n#define cube 0.2 // 0.=smooth .99=voxel\n\n struct GRIDCELL{     //calculated for each cube in the following sequence:\n   vec3 p[8];         //  1. cube vertex positions\n   float val[8];      //  2. isosurface value at each cube vertex\n   float nVertex;     //  3. number of vertex where val[]>0; if 0<nVertex<8  => surface cube\n   float nEdge;       //  4. number of cube edges with crossing \n   vec3 m;            //  5. surface vertex, as an average of all crossing edge positions\n   int dirs;          //  6. 6bit bitmask of surface edges from each cube;                        \n} ;\n\n\nconst vec3 v[8] =vec3[8]\n(\n   vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\nconst int  e[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n\nconst vec3 dir[6] =vec3[6]\n(\n   vec3(1,0,0), vec3(0,1,0),vec3(0,0,1),\n   vec3(-1,0,0), vec3(0,-1,0),vec3(0,0,-1)\n);\n\n\nint gFrame=0; \nvoid  getSurface(vec3 c, inout GRIDCELL g)\n{\n    \n    g.m=vec3(0.);\n    g.nVertex=0.;\n    g.nEdge=0.;\n    g.dirs=0;\n\n    //gFrame unrolling fails here...\n    for(int i=0;i<8;i++)\n    {\n\n        //1. cube vertex positions\n       \n        vec3 vp=c+ cube/2.+ v[i]*(1.-cube);\n        g.p[i]=vp;\n\n        //  2. isosurface value at each cube vertex\n        float val = map(c+  v[i]);\n                   // getVoxel( c+  v[i] ,iChannel0).x;\n         g.val[i]=val;\n        \n        //3. number of vertex where val[]>0;\n        g.nVertex+= (val<=0.?1.:0.);\n\n    }\n \n     if(g.nVertex>0. && g.nVertex<8.)\n     {\n\n          for(int i=gFrame;i<24;i+=2)\n          {\n              //  isosurface weights at each cube edge vertexes\n              float d1 = g.val[e[i]],\n                  d2 = g.val[e[i+1]],\n                  d= d1/(d1-d2);\n\n            //  4. number of cube edges with crossing \n             if(d1*d2<0.){\n                 g.nEdge++;\n                 g.m+= g.p[e[i+1]]*d + g.p[e[i]]*(1.-d);\n                 \n                 for(int k =gFrame;k<6;k++) {\n                     \n                     //  6. 6bit bitmask of surface edges from  each cube\n                     if(dot((g.p[e[i+1]] +g.p[e[i]])/2.- c -.5 , dir[k] )<0. )  g.dirs=g.dirs | (1<<k); \n                     \n                 }\n             }\n          }\n         \n        //  5. surface vertex, as an average of all crossing edge positions\n         g.m/= g.nEdge;\n         g.m =min(max(g.m,c),c+1.); //must be inside the cube\n         //g.m=c+csz/2.; //orthogonal connections\n    } else if(g.nVertex==8. ){\n        g.dirs=64;g.m=c+.5;\n    }\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec3 c = texToVoxCoord(floor(U), offset);        \n    GRIDCELL g;     \n    getSurface(c,g);  \n    O = vec4(g.m,g.dirs);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//SURFACE NET RENDERING\n\n\n float FREQ=.75;\n float TK=.1; //edge thickness \nconst vec3 dir[6] =vec3[6]\n(\n   vec3(1,0,0), vec3(0,1,0),vec3(0,0,1),\n   vec3(-1,0,0), vec3(0,-1,0),vec3(0,0,-1)\n);\n\n\n\n\n//vertex ordering\nspan iCylinder2( in vec3 ro, in vec3 rd,  in vec3 pa, in vec3 pb, float ra ,bool i) \n{\n    return iCylinder( ro,  rd, i? pb:pa, i?pa: pb,  ra );\n}\nspan iBilinearPatch2(in vec3 ro, in vec3 rd,in vec3 a, in vec3 b, in vec3 c, in vec3 d,bool i0,bool i1,bool i2,float fid) {\n   vec3 t;  ivec4 ids=ivec4(1,2,4,8); int id =int(fid);\n   //i0=k2+3<k,  i1= k>2, i2=k2>2\n   if(i2){t=a;a=c;c=t;t=b;b=d;d=t; ids=ivec4(4,8,1,2);}  \n   else if(i1 &&i0 ){t=a;a=b;b=t;t=c;c=d;d=t;ids=ivec4(2,1,8,4);}  \n   else if(i1){t=a;a=b;b=c;c=d;d=t;ids=ivec4(8,1,2,4);} \n   span s=  iBilinearPatch( ro, rd,a,b,c,d);\n   s.n.fuv.x=float( (id&1)*ids[0] + (id&2)/2*ids[1] +(id&4)/4*ids[2]+(id&8)/8*ids[3]);\n   return s;\n}\nfloat id(vec3 mp){\n    return (L+1.)*(L+1.)*(L+1.) +mp.x+ L*mp.y+L*L*mp.z;\n}\n//add vertex id to sphere\nspan iSphere2( in vec3 ro, in vec3 rd, float ra ,float id){\n    span s =iSphere(  ro,rd,  ra);\n    s.n.fuv.x=id;\n    return s;\n}\n\nRayOut trace(in vec3 ro,in vec3 rd)\n{\n   \n    RayOut ray;\n    //RAYTRACING BOUNDING BOX\n    span tb= iBox(  ro,  rd, vec3(L*.50+.00001) ) ;\n    if(tb.f.t==NOHIT) return   InfRay();\n        \n    //VOXEL TRAVERSAL\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp=ro +  max(tb.n.t,0.)*rd;  \n    vec3 mp=floor(rp);\n    vec3 sd = (mp-rp + 0.5 + sign(rd)*0.5) *ri;\n    vec3 mask=vec3(0.);     \n    for (int i = 0; i < 200; i++) {\n\n        if(length(rp-ro)>tb.f.t) break; //outside bounding box\n       \n       //BEGIN SURFACE NETS\n       vec4 data = getVoxel( mp,iChannel0);         \n       int g_dirs =int(data.a);            \n       if(g_dirs>0) {          \n           //RAYTRACE VOXEL \n           vec3 g_m= data.xyz;       \n           ray =  InfRay();\n           if(g_dirs<64) {\n               float id0=id(mp); bool sid0=hash11(id0)<FREQ;;\n              if(TK>0.&&sid0) Add( ray, Ray(iSphere2(ro- g_m,rd,TK,id0),3.));\n               vec3[6] g_ng;\n               for(int k =min(iFrame,0);k<6;k++) {\n                  if((g_dirs & (1<<k))>0) {\n                      //get neighbour surface vertex along each direction\n                      g_ng[k] = getVoxel( mp-dir[k],iChannel0).xyz; \n                      float id1=id(mp-dir[k]);bool sid1=hash11(id1)<FREQ;\n                      if(TK>0. && sid1 && sid0) Add( ray, Ray(iCylinder2(ro,rd,g_m,g_ng[k],TK/2.,k>2),2.));\n                      if(TK>0. && sid1) Add( ray, Ray(iSphere2(ro- g_ng[k],rd,TK,id1),3.));\n                      for(int k2= 0;k2<k;k2++){\n                          if(k2!=k-3 && (g_dirs & (1<<k2))>0){\n                              //get quad opposite vertex\n                              vec4 g_f = getVoxel( mp-dir[k]-dir[k2],iChannel0); \n                              if(g_f.a>0.&& g_f.a<64.){\n                                  float id2=id(mp-dir[k2]);bool sid2=hash11(id2)<FREQ;\n                                  float id3=id(mp-dir[k]-dir[k2]);bool sid3=hash11(id3)<FREQ;                                 \n                                  if(TK>0. && sid3) Add( ray, Ray(iSphere2(ro- g_f.xyz,rd,TK,id2),3.));\n                                  if(TK>0. && sid3 && sid1) Add( ray, Ray(iCylinder2(ro,rd,g_f.xyz,g_ng[k],TK/2.,k>2),2.));\n                                  if(TK>0. && sid3 && sid2) Add( ray, Ray(iCylinder2(ro,rd,g_f.xyz,g_ng[k2],TK/2.,k2>2),2.));\n                                  //thanks Oneshade!! \n                                  float id=float(sid0)*1.+ float(sid1)*2.+float(sid3)*4.+float(sid2)*8.;\n                                  Add( ray, Ray(iBilinearPatch2(ro,rd,g_m,g_ng[k], g_f.xyz,g_ng[k2],k2+3<k,k>2,k2>2,id),1.));                                 \n                              }\n                          }\n                      }                       \n                   } \n               }\n           }     \n           if (ray.d< NOHIT ){ray.d+=max(tb.n.t,0.); return ray;}            \n        }\n        //END SURFACE NETS\n        \n        mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\t\tsd += mask *  rs *ri;\n        mp += mask *  rs;\n       \n\t} \n    return InfRay();\n}\n\n\n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RayDir(in vec3 ro, in vec3 cp, vec2 uv, vec2 res) {\n    return LookAt(cp-ro, vec3(0,0,1))*normalize(vec3((2.*uv-res.xy)/res.y, 3.5));\n}\n\n\nvec3 pos(float t){\n \n     float t0=floor(t)*.5;\n     vec2 a = vec2(cos(t0)+.4+sin(.5*t0) *.5,sin(t0)+.3);\n     return vec3(cos(a.x) *sin(a.y),cos(a.x) *cos(a.y),sin(a.x))*12.5;\n}\nvoid getCam(in vec2 uv, in float time, out vec3 ro, out vec3 rd, out vec3 lp,out vec3 lpn) {\n      \t\n    if(iMouse.x>0.) uv+= (iMouse.xy-iResolution.xy*.5);\n    float t = 1.* time,\n\t\t kt = fract(t);\n    \n    // - Interpolate positions  and direction\n    vec3 ro0=pos(t);\n    vec3 ro1=pos(t+1.);\n    vec3 cp0= pos(t+ 2.);\n    vec3 cp1=pos(t+ 3.);\n    vec3 lp0=pos(t+ 1.);\n    vec3 lp1=pos(t+ 2.);\n    vec3 cp =  mix(cp0, cp1, kt);\n    \n    lp=mix(lp0, lp1, kt);\n    lpn=normalize(cp-lp);\n  \n    ro =  mix(ro0, ro1, kt)*1.3,\n    ro += vec3(.01*cos(2.*time), .01*cos(time),0.);\n    \n    rd = RayDir(ro, cp, uv*1.5, R*1.5);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    \n    if(iResolution.y>MR && any(greaterThan(U,iResolution.xy*.5))) discard;\n    vec3 ro ,rd ,lp,lpn;    \n    getCam(U, iTime, ro, rd,lp,lpn);\n    \n    RayOut r= trace(ro,rd);\n    Add( r, Ray(iSphere(ro- lp,rd,.06),4.))  ; \n    Add(r, Ray(iCylinder(ro,rd,lp+lpn*.1,lp+lpn,.1),5.));\n    if(r.d<NOHIT && r.id>0.){\n        vec3 p = ro+rd*r.d, \n             n = r.n;\n  \n         float emit=0.;\n         if(r.id==1.){\n              int id= int(r.fuv.x);\n              bvec4 w = bvec4((id&3)<3,(id&12)<12,(id&9)<9,(id&6)<6); //borders\n             float m = (w.x?1.:.5+ .5* smoothstep(.1,.3, fract(r.fuv.y))) \n                      *(w.y?1.:.5+ .5* smoothstep(.9,.7, fract(r.fuv.y)))  \n                      *(w.z? 1.:.5+ .5* smoothstep(.1,.3, fract(r.fuv.z)))  \n                      *(w.w?1.:.5+ .5* smoothstep(.9,.7, fract(r.fuv.z))); \n             O.rgb = mix( vec3(.4,.3,.1) , vec3(.8,.8,.7),min(smoothstep(.7,.5,dot(n, normalize(p))),m)) ;             \n             O.rgb = mix(tex3D(iChannel3, (p)*1.5, n).rrr,O.rgb,.5);\n             O.rgb*=m;\n            \n         } else if(r.id==2.){\n             O.rgb=vec3(.2,.4,.7) *( .3+ .7* smoothstep(.49,.51,fract(r.fuv.z*3.+iTime*2.)));\n             O.rgb *=.5+.5*smoothstep(TK,.0, abs(r.fuv.y -TK*.5));\n         } else if(r.id==3.) {\n             emit =  smoothstep(.9,1.,fract(iTime/4.+hash11(r.fuv.x)));\n             O.rgb=mix( vec3(.8,.4,.4),vec3(1,1,.7),emit);\n         } else if(r.id==4.){\n             O.rgb=vec3(1.,1.,.3);\n             emit=1.;\n         } else if(r.id==5.){\n             O.rgb=vec3(.9,.0,.1) *( .7+ .3* smoothstep(.49,.51,fract(r.fuv.z*3.+iTime*3.)));\n             O.rgb *=.5+.5*smoothstep(TK,.0, abs(r.fuv.y -TK*.5));\n         }\n        \n         vec3 ld = normalize(lp-p);\n         float sh =.05*smoothstep(-2.,2.,dot(n,vec3(0,0,1)));     \n         RayOut s= trace(p+n*.01,ld); \n         if( s.id>.0 &&s.d>0.&& s.d<length(p-lp)) ;\n         else sh+= exp(-dot(p-lp,p-lp)*.2)*smoothstep(-1.,1.,dot(n,ld));\n         O*=mix(sh,.8,emit);\n       \n         \n         O = vec4(sqrt(clamp(O, 0., 1.)));      \n    }    \n    else O.rgb= StarField3D(rd,rd);\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}