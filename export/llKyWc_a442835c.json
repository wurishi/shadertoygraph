{"ver":"0.1","info":{"id":"llKyWc","date":"1538498789","viewed":903,"name":"2D Signal Inspector","username":"nimitz","description":"Top left: Distribution\nTop right: First (top) and Second derivatives\nRight side: Fourier amplitude","likes":31,"published":1,"flags":32,"usePreview":0,"tags":["noise","fft","gradient","derivative","fourier","tool","distribution","laplacian","signal","analysis","dft","mean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n    //return smoothstep(-1.0, 1.0,rz);\n}\n\nvec4 powX(float x) {float x2 = x*x; return vec4(x2*x, x2, x, 1.0); }\nvec4 MNParamsA(float B, float C){ return vec4(12. - 9.*B - 6.*C, -18. + 12.*B + 6.*C, 0.0, 6. -2.*B)/6.; }\nvec4 MNParamsB(float B, float C){ return vec4(-B -6.*C, 6.*B + 30.*C, -12.*B - 48.*C, 8.*B + 24.*C)/6.; }\n\nfloat eval(float c0, float c1, float c2, float c3, float x) \n{    \n    const float B = .8;\n    const float C = 0.25;\n    vec4 pA = MNParamsA(B, C);\n    vec4 pB = MNParamsB(B, C);\n    \n    return c0*dot(pB, powX(x + 1.0)) + c1*dot(pA, powX(x)) +\n           c2*dot(pA, powX(1.0 - x)) + c3*dot(pB, powX(2.0 - x));\n}\n\nfloat bicubicNoise(in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    float s99 = hash12(ip+vec2(-1,-1)), s19 = hash12(ip+vec2(1,-1));\n    float s00 = hash12(ip+vec2(0,0)),   s20 = hash12(ip+vec2(2,0));\n    float s91 = hash12(ip+vec2(-1, 1)), s11 = hash12(ip+vec2(1, 1));\n    float s02 = hash12(ip+vec2(0,2)),   s22 = hash12(ip+vec2(2,2));\n    float s09 = hash12(ip+vec2(0,-1)),  s29 = hash12(ip+vec2(2,-1));\n    float s90 = hash12(ip+vec2(-1,0)),  s10 = hash12(ip+vec2(1,0));\n    float s01 = hash12(ip+vec2(0,1)),   s21 = hash12(ip+vec2(2,1));\n    float s92 = hash12(ip+vec2(-1,2)),  s12 = hash12(ip+vec2(1,2));\n    \n    float rz =  eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    \n    //return rz;\n    return smoothstep(0.0,1.,rz);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n\nvec2 hashz( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return normalize(-1.0 + 2.0*fract(sin(p)*43758.5453123) + 1e-7);\n}\n\n//from iq: https://www.shadertoy.com/view/Msf3WH\nfloat simplex( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashz(i+0.0)), dot(b,hashz(i+o)), dot(c,hashz(i+1.0)));\n\n    return dot( n, vec3(80.0) )*0.5+0.5;\n\t\n}\n\nvec2 hashg(vec2 x) { return hash22(x)*2.0-1.0;}\n\n//From iq: https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float rz =  mix( mix( dot( hashg( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hashg( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hashg( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hashg( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return rz*0.75+0.5;\n    return smoothstep(-.9,.9,rz);\n}\n\nfloat fbm(vec2 p)\n{\n    float rz = 0.;\n    float amp = 1.95;\n    for (int i = 0; i < 7; i++)\n    {\n        rz += orbitNoise(p*1.)/amp;\n        //rz += bicubicNoise(p*1.3)/amp;\n        //rz += gradientNoise(p*.6)/amp;\n        //rz += valueNoise(p)/amp;\n        //rz += simplex(p*.35)/amp;\n        amp *= 2.;\n        p *= 2.06;\n    }\n    //return rz;\n    return smoothstep(0.,1.,rz); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)\n        p*=0.75;\n    \n    vec3 col = vec3(0);\n    \n    p *= globalScale;\n    \n#if (NOISE_TYPE == 1)\n    col = orbitNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 2)\n    col = bicubicNoise(p*55.)*vec3(1);\n#elif (NOISE_TYPE == 3)\n    col = valueNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 4)\n    col = gradientNoise(p*25.)*vec3(1);\n#elif (NOISE_TYPE == 5)\n    col = simplex(p*14.)*vec3(1);\n#elif (NOISE_TYPE == 6)\n    col = fbm(p*20.)*vec3(1);\n#endif\n    \n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}","name":"Buffer B","description":"","type":"buffer"}]}