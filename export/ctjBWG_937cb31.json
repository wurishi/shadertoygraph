{"ver":"0.1","info":{"id":"ctjBWG","date":"1694441967","viewed":62,"name":"Hexagons harmonic","username":"Blindman67","description":"Inspired by Saturn's hexagonal polar storm. :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","2dpattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415927410125732; // 355.0 / 113.0;\nconst float INV_PI = 1.0 / PI;\nconst float SIZE_X = 110.0;\nconst float SIZE_X2 = SIZE_X * 2.0;\nconst float SIZE_X3 = SIZE_X * 3.0;\nconst float SIZE_Y = cos(PI * 2.0 / 12.0) * SIZE_X;\nconst float SIZE_Y2 = SIZE_Y * 2.0;\nconst float SIZE_Y3 = SIZE_Y * 3.0;\n\nconst vec2 OFFSETA = vec2(SIZE_X, SIZE_Y);\nconst vec2 MOD_SPACED = vec2(SIZE_X3, SIZE_Y2 );\nconst float EDGE_HARM_1_AMP = 5.0;\nconst float EDGE_HARM_2_AMP = 1.0;\nconst float EDGE_HARM_3_AMP = 0.2;\nconst float EDGE_FEQ_1_AMP = 6.0;\nconst float EDGE_FEQ_2_AMP = 12.0;\nconst float EDGE_FEQ_3_AMP = 18.0;\nconst float SHAPE_SIZE = 90.0 + EDGE_HARM_1_AMP + EDGE_HARM_2_AMP + EDGE_HARM_3_AMP;\nconst float INV_SHAPE_SIZE = 1.0 / SHAPE_SIZE;\n\nconst vec3 COL_YELLOW = vec3(0.8,0.8,0.2);\nconst vec3 COL_YELLOW1 = vec3(0.8,0.4,0.2);\nconst vec3 COL_BLACK = vec3(0.05, 0.2,0.3);\n\n\n\n\nfloat GetEdge(in float ang) {\n    return cos(ang * EDGE_FEQ_1_AMP) * EDGE_HARM_1_AMP + \n        cos(ang * EDGE_FEQ_2_AMP) * EDGE_HARM_2_AMP + \n        cos(ang * EDGE_FEQ_3_AMP) * EDGE_HARM_3_AMP;\n}\nfloat GetInnerEdges(in float len, in float edge) {\n    return len - edge * (len * INV_SHAPE_SIZE);\n}\nvec3 ShadeSpec(in vec3 col, in vec3 pos, in vec3 norm, in vec3 eye, in vec3 light) {\n\n    vec3 toLight = normalize(light - pos);    \n    vec3 lightRef = reflect(norm, toLight);\n    float shade = clamp(dot(norm, toLight), 0.0, 1.0);\n    float spec = pow(clamp(dot(lightRef, -normalize(eye - pos)), 0.0, 1.0), 200.0) * 0.5; \n    return col * shade + spec;\n}\n\nvoid mainImage( out vec4 col, in vec2 px) {\n    float aTime = iTime * 0.1;\n    float COS = cos(aTime);\n    float SIN = sin(aTime);\n    vec2 center = iResolution.xy * 0.5;\n    vec3 eye = vec3(center, 1000.0);\n    vec3 light = vec3(iResolution.xy * (0.5, 0.6), 1000.0);\n\n    mat2 rot = mat2(COS, -SIN, SIN, COS) * (SIN * 0.5 + 1.0);\n    vec2 origin = vec2(SIN, COS) * iResolution.xy * 0.5;\n\n    vec2 pxR = rot * (px - center) + origin;\n    vec2 p = mod(pxR, MOD_SPACED) - OFFSETA;\n    vec3 pos = vec3(px,0);\n\n    float len = length(p);\n    float edge = GetEdge(atan(p.y, p.x));\n    \n    if (len - edge < SHAPE_SIZE) {\n        float innerDetail = mod(GetInnerEdges(len, edge)+ 10.0,  25.0);\n        float line = float(innerDetail > 15.0);\n        innerDetail -= 7.5;\n        float h = sqrt(7.5 * 7.5 - innerDetail * innerDetail);\n        vec3 norm = normalize(vec3(normalize(p) *  sign(innerDetail), h));\n        vec3 c = ShadeSpec(COL_YELLOW, pos, norm, eye, light);\n        col.rgb = mix(c, COL_BLACK, line);   \n\n    } else {\n        p = mod(pxR + vec2(SIZE_X * 1.5, SIZE_Y), MOD_SPACED) - vec2(SIZE_X, SIZE_Y);\n        len = length(p);\n        edge = GetEdge(atan(p.y, p.x));\n        if (len - edge < SHAPE_SIZE) {\n            float innerDetail = mod(GetInnerEdges(len, edge) + 15.0,  25.0);\n            float line = float(innerDetail > 5.0);    \n            innerDetail -= 15.0;\n            float h = min(5.0, sqrt(10.0 * 10.0 - innerDetail * innerDetail)) * line;\n            vec3 norm = normalize(vec3(normalize(p) * sign(innerDetail), h));\n            vec3 c = ShadeSpec(COL_YELLOW1, pos, norm, eye, light);\n            col.rgb = mix(COL_BLACK, c, line);\n            \n          \n        } else {            \n            col.rgb = vec3(0.0);\n        }\n    }\n\n}","name":"Image","description":"","type":"image"}]}