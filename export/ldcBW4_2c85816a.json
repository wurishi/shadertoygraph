{"ver":"0.1","info":{"id":"ldcBW4","date":"1525109843","viewed":359,"name":"Floreate Dodecacyte","username":"dpiponi","description":"Iterating various kinds of dodecahedral folding\nAdded subsurface scattering model for a more waxy look","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["subsurfacescattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float theTime = 0.0;\n\nmat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\n// Assume n normalised\nvec3 fold(vec3 n, vec3 x) {\n    float nx = dot(n, x);\n    return nx >= 0.0 ? x : x-2.0*nx*n;\n}\n\nfloat g(vec3 x) {\n    //return length(x)-1.0;\n    return max(x.z,max(-x.z,max(x.y,max(-x.y,max(x.x, -x.x)))))-0.85;\n}\n\nfloat h(vec3 x) {\n    mat4 m = rotateZ(0.2101*theTime-3.128)*rotateY(0.1311*theTime+1.234);\n    return g((vec4(x, 1.0)*m).xyz);\n}\n\nvec2 xy;\n\n// {{1., 0., 0.}, {0., -1., 0.}, {0.809017, 0.5, -0.309017}}\nvec3 pc = vec3(0.809017, 0.5, -0.309017);\n\nvec3 dodecafold(vec3 x) {\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n\n    return x;\n}\n\nfloat f(vec3 x) {\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.478*theTime-9.128)*rotateY(0.13001*theTime+1.234)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.0, -0.4, 0.1);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.07*theTime-3.128)*rotateY(0.1*theTime+1.234)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.0, 0, 0.3);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.27*theTime-3.999)*rotateY(0.121*theTime+7.034)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.1, 0.3, 0.0);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.7654*theTime-31.128)*rotateY(0.201*theTime+1.034)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.1, 0.2, 0.0);\n\n    x = dodecafold(x);\n\n    x = (vec4(x,1.0)*rotateZ(0.91*theTime-3.128)*rotateY(0.0901*theTime+1.034)*scale(vec3(1.0, 1.0, 1.0))).xyz;\n    x = x+vec3(0.25, 0.3, 0.0);\n    \n    x = dodecafold(x);\n\n    return h(x);\n}\n\nfloat eps = 0.0001;\nfloat lambda = 2.0;\n\nvec3 ico[12];\n\n//vec3 hash3(vec3 x) {\n//    float u = 1000.0*sin(x.x*x.y+3.3*x.z-2.2*x.y+10.123*x.y+11.12*x.y*x.z);\n//    float v = 1000.0*sin(x.z*x.y-2.1*x.z+3.0*x.z+7.211*x.y+32.12*x.y*x.x);\n//    float w = 1000.0*cos(x.z*x.y+3.4*x.z-3.0*x.x+17.97*x.y+11.12*x.x*x.y);\n//    return vec3(u-floor(u), v-floor(v), w-floor(w));\n//}\n\nfloat lighting(vec3 x, vec3 n) {\n    float t = 0.0;\n    for (int i = 0; i < 12; ++i) {\n        float p = f(x-0.05*n+0.10*ico[i]);\n        t += 0.8+10.0*p;\n    }\n    return t/12.0;\n}\n\nmat4 view() {\n    return rotateY(0.2*theTime-6.28*xy.x)*rotateX(0.02*theTime);\n}\n\nvec3 march(vec3 p, vec3 d) {\n    float c;\n    c = f(p);\n    if (c < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    for (int i = 0; i < 70; ++i) {\n        float step = max(0.0025, c);\n        p = p+step*d;\n        c = f(p);\n        if (c <= 0.0) {\n            float ex, ey, ez;\n            ex = f(p+vec3(eps, 0.0, 0.0));\n            ey = f(p+vec3(0.0, eps, 0.0));\n            ez = f(p+vec3(0.0, 0.0, eps));\n            vec3 n = vec3(ex-c, ey-c, ez-c)/eps;\n            n = normalize(n);\n            mat4 m = view();\n            vec3 light = (vec4(1.0,1.0,-1.0,1.0)*m).xyz;\n            float l = 0.0;\n            l += 0.15+0.85*max(dot(n, light)/sqrt(3.0), 0.0);\n            l += 1.0*lighting(p, n);\n            return vec3(l)*vec3(0.74, 0.72, 0.7);\n        }\n    }\n    return vec3(0.1, 0.1, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    theTime = iTime;\n    //theTime = 39.0;\n\n    ico[0] = vec3(-0.26286500, 0.0000000, 0.42532500);\n    ico[1] = vec3(0.26286500, 0.0000000, 0.42532500);\n    ico[2] = vec3(-0.26286500, 0.0000000, -0.42532500);\n    ico[3] = vec3(0.26286500, 0.0000000, -0.42532500);\n    ico[4] = vec3(0.0000000, 0.42532500, 0.26286500);\n    ico[5] = vec3(0.0000000, 0.42532500, -0.26286500);\n    ico[6] = vec3(0.0000000, -0.42532500, 0.26286500);\n    ico[7] = vec3(0.0000000, -0.42532500, -0.26286500);\n    ico[8] = vec3(0.42532500, 0.26286500, 0.0000000);\n    ico[9] = vec3(-0.42532500, 0.26286500, 0.0000000);\n    ico[10] = vec3(0.42532500, -0.26286500, 0.0000000);\n    ico[11] = vec3(-0.42532500, -0.26286500, 0.0000000);    \n    \n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    xy = iMouse.xy/iResolution.xy;\n\n    vec3 p = vec3(0.0, 0.0, -2.0);\n    vec3 d = normalize(vec3(0.5*uv, 1.0));\n    mat4 m = view();\n    p = (vec4(p, 1.0)*m).xyz;\n    d = (vec4(d, 1.0)*m).xyz;\n    vec3 color = march(p, d);\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}