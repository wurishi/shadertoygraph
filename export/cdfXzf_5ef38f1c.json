{"ver":"0.1","info":{"id":"cdfXzf","date":"1669274907","viewed":59,"name":"抄个心","username":"kangwang","description":"学习一下 ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["line"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distance estimation: thanks to https://iquilezles.org/articles/distance\n\n/* Tweaks to try:\n - fill in the hearts (where heart(p) < 0)  With what texture?\n*/\n\n// My daughter requested stripes.\n// #define STRIPES 1\n// #define SOLID_HEARTS 1\n\n// heart(p) = 0 is a heart-shaped curve.\n\n#define EQUATION 2\n\n// Heart curve suggested by IQ, improved by Dave_Hoskins.\nfloat heart(vec2 p) {\n    // Center it more, vertically:\n    p.y += .6;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = .3;\n    // (x^2+(1.2*y-sqrt(abs(x)))^2−1)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    return p.x * p.x + k * k - 1.;\n}\n\n// Gradient of heart function.\n// TODO: make it analytic.\n// For now, use central differences method.\nvec2 grad(vec2 p) {\n    vec2 h = vec2(0.01, 0.0);\n    return vec2(heart(p + h.xy) - heart(p - h.xy),\n                heart(p + h.yx) - heart(p - h.yx)) / (2.0 * h.x);\n}\n\n// Return 0-1 scalar based on abs distance from heart line.\nfloat color(vec2 p, float vol) {\n    float v = heart(p);\n#ifdef SOLID_HEARTS\n    if (v < 0.) return 0.;\n#endif\n    vec2  g = grad(p);\n    float de = abs(v) / length(g);\n    // Thickness: vary with volume\n    float eps = (15. + vol * 3.)/iResolution.x;\n    return smoothstep(1.0 * eps, 2.0 * eps, de);\n}\n\n\nconst float pi = 3.14159;\n\nvec3 heart1(vec2 p, int i, float vol) {\n    vec2 offset = vec2(0.);\n    float scale = .7;\n    float a;\n    vec3 hue;\n    \n    switch (i) {\n        case 0:\n            hue = vec3(1., .3, .3); \n            a = pi * 0. - iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .03;\n            break;\n        case 1:\n            hue = vec3(.6, .6, 1.); \n            a = pi * 1. - iTime * .3; \n            offset = vec2(cos(a), sin(a)) * .03;\n            break;   \n    }\n\n    vec2 q = (p + offset) / (scale * (1.0 + vol * .3) * .8);\n    float brightness = 1. - color(q * 10., vol);\n    return brightness * hue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xx;\n    \n    float vol = 1.0;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 1; i++) {\n        col += heart1(uv, i, vol);\n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}