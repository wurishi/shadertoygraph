{"ver":"0.1","info":{"id":"7sjSWy","date":"1620967525","viewed":120,"name":"Double Pendulum Phase Diagram","username":"Symmetries","description":"Phase diagram of double pendulum.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pendulum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define theta1(p) texture(iChannel0,(p)/iResolution.xy).x\n#define theta2(p) texture(iChannel0,(p)/iResolution.xy).y\n\n// using hsv2rgb from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 o, in vec2 p) {\n    o = vec4(vec3(hsv2rgb(vec3((theta1(p) - theta2(p)), 1., 1.))), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define theta1(p) texture(iChannel0,(p)/iResolution.xy).x\n#define theta2(p) texture(iChannel0,(p)/iResolution.xy).y\n#define p1(p) texture(iChannel0,(p)/iResolution.xy).z\n#define p2(p) texture(iChannel0,(p)/iResolution.xy).w\n#define lambda 1000.0\n#define PI 3.14159265358979323846264338\n#define iterations 250\n#define dt 0.0001\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    float theta1 = float(iFrame < 1) * p.x / iResolution.x\n                 + float(iFrame >= 1) * theta1(p);\n    float theta2 = float(iFrame < 1) * p.y / iResolution.y\n                 + float(iFrame >= 1) * theta2(p);\n    \n    theta1 *= 2. * PI;\n    theta2 *= 2. * PI;\n\n    float m = 1.;\n    float l = 1.;\n    float g = 1.;\n\n    float p1 = float(iFrame > 1) * p1(p) * lambda;\n    float p2 = float(iFrame > 1) * p2(p) * lambda;\n\n    float theta1Dot;\n    float theta2Dot;\n    float p1Dot;\n    float p2Dot;\n    float c12;\n    float s12;\n\n    for (int iteration = 0; iteration < iterations; iteration++) {\n        c12 = cos(theta1 - theta2);\n        s12 = sin(theta1 - theta2);\n        theta1Dot = 6. / (m * l * l) * (2. * p1 - 3. * c12 * p2) / (16. - 9. * c12 * c12);\n        theta2Dot = 6. / (m * l * l) * (8. * p2 - 3. * c12 * p1) / (16. - 9. * c12 * c12);\n        p1Dot = -.5 * m * l * l * (theta1Dot * theta2Dot * s12 + 3. * g / l * sin(theta1));\n        p2Dot = -.5 * m * l * l * (-theta1Dot * theta2Dot * s12 + g / l * sin(theta2));\n\n        p1 += p1Dot * dt;\n        p2 += p2Dot * dt;\n        theta1 += theta1Dot * dt;\n        theta2 += theta2Dot * dt;\n    }\n    \n    o.x = mod(mod(theta1 / (2. * PI), 1.) + 2., 1.);\n    o.y = mod(mod(theta2 / (2. * PI), 1.) + 2., 1.);\n    o.z = p1 / lambda;\n    o.w = p2 / lambda;\n}","name":"Buffer A","description":"","type":"buffer"}]}