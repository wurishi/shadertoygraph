{"ver":"0.1","info":{"id":"fssGDB","date":"1616485771","viewed":354,"name":"oceanic gifski","username":"Carandiru","description":"inspired by https://www.shadertoy.com/view/7sl3zl   fabrice!\n\nquick gif, using gaussian, some bluenoise dithering and a palette.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["blue","gif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WlGczK\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define INTERVAL (sin(0.22f * iTime))\n\n#define SCANLINE_INTERLEAVE 2.0f\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\n#define FILL 2.25 // lower for highlighting edges, higher for whole parts\n\nfloat aaStep(in float compValue, in float gradient){\n  float halfChange = fwidth(gradient) * 0.5f;\n  //base the range of the inverse lerp on the change over one pixel\n  float lowerEdge = compValue - halfChange;\n  float upperEdge = compValue + halfChange;\n  //do the inverse interpolation\n  return( clamp((gradient - lowerEdge) / (upperEdge - lowerEdge), 0.0f, 1.0f) );\n}\n\nvec2 aaStep(in vec2 compValue, in vec2 gradient){\n  vec2 halfChange = fwidth(gradient) * 0.5f;\n  //base the range of the inverse lerp on the change over one pixel\n  vec2 lowerEdge = compValue - halfChange;\n  vec2 upperEdge = compValue + halfChange;\n  //do the inverse interpolation\n  return( clamp((gradient - lowerEdge) / (upperEdge - lowerEdge), 0.0f, 1.0f) );\n}\n\nvec3 cyberpunk(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, (uv)).rgb;\n    float luminance = dot(color, LUMA);\n    color.rgb = mix(vec3(0), color, aaStep( SCANLINE_INTERLEAVE * 0.5f, mod(fragCoord.y, SCANLINE_INTERLEAVE - (1.0f/iResolution.y) * 0.5f) ) );color *= 0.5f;\n    \n    color += texture(iChannel0, (vec2(fragCoord + vec2(-1,-1)) / iResolution.xy)).rgb;;\n    color.rgb = color.rgb * (1.0f - (luminance / dot(color, LUMA)));\n    \n    color += texture(iChannel0, (vec2(fragCoord + vec2(1,1)) / iResolution.xy)).rgb;\n    color.rgb = color.rgb * (1.0f - (luminance / dot(color, LUMA)));\n    \n    float diff = abs(dot(color, LUMA) - luminance) * (1.0f + luminance * FILL);\n    \n    float highlight = aaStep(0.33f + luminance, diff);\n    \n    color.rgb = color.rgb * (1.0f - (luminance / dot(color, LUMA)));\n    color.r = highlight * highlight * 0.95f;\n    color.b += color.g * 0.25f;\n    \n    \n    color.g = color.b;\n    color.b = color.r;\n    color.r = color.g;\n\n    color.g = color.b * 0.5f;\n    \n   \tcolor.g *= (1.0f + luminance);\n    \n    color = smoothstep(0.25f, 1.0f, color);\n    \n    float dither = texture(iChannel1, uv).r * (17.0f/255.0f);\n    color = mix(color - dither, color + dither, luminance);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color;\n\n    color = cyberpunk(fragCoord);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fma(a,b,c) (a*b+c)\nvec2 rotate( in vec2 p, in float angle )\n{\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\n\n// inspired by https://www.shadertoy.com/view/7sl3zl   fabrice!\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) /R.y;\n         \n    O = textureLod(iChannel2, u/R, 0.0f) * 0.98f;\n    \n    vec2 p = rotate(U, textureLod(iChannel1, U, 0.0f).r - 0.5f) * 0.1f;\n    float tex = textureLod(iChannel0, rotate((U + p) * 0.125f, iTime * 0.1f), 0.0f).r;\n    \n    vec3 T = vec3(U, abs(sin(tex * 3.14 + iTime)));\n    \n    vec3 G = exp2(-1.618*T*T);\n         \n    float N = G.x*G.y*G.z;\n    \n    O = O * (1.0f - N) + (1.0f - O) * vec4(N);\n}","name":"Buffer A","description":"","type":"buffer"}]}