{"ver":"0.1","info":{"id":"lfyyWt","date":"1732946305","viewed":126,"name":"241126_cloud_path_tracing","username":"okdalto","description":"Implementation of a path tracing cloud renderer with lighting. \nI'm not sure if I implemented correctly 🤔  but it's working!","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    // apply exposure (how long the shutter is open)\n    // color *= c_exposure;\n\n    // convert unbounded HDR color range to SDR color range\n    color = ACESFilm(color);\n\n    // convert from linear to sRGB for display\n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat length6( vec3 p ) {\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\nvec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nuint wang_hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat randomFloat01(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 randomUnitVector(inout uint state) {\n    float z = randomFloat01(state) * 2.0f - 1.0f;\n    float a = randomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat rand(vec4 seed) {\n    float dotProduct = dot(seed, vec4(12.9898, 78.233, 45.164, 94.673));\n    return fract(sin(dotProduct) * 43758.5453123);\n}\n\nfloat sampleCosTheta(float g, float xi1) {\n    if (g == 0.0) {\n        return 1.0 - 2.0 * xi1;\n    } else {\n        float term = (1.0 - g * g) / (1.0 - g + 2.0 * g * xi1);\n        return (1.0 / (2.0 * g)) * (1.0 + g * g - term * term);\n    }\n}\n\nfloat samplePhi(float xi2) {\n    return c_twopi * xi2;\n}\n\nvec3 computeNewDirection(float cosTheta, float phi) {\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    return vec3(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    );\n}\n\nvec3 alignToDirection(vec3 newDir, vec3 omegaPrime) {\n    vec3 zAxis = vec3(0.0, 0.0, 1.0);\n    vec3 v = cross(zAxis, omegaPrime);\n    float s = length(v);\n    float c = dot(zAxis, omegaPrime);\n    mat3 rotation;\n\n    if (s < 0.00001) { // 거의 0에 가까울 때는 회전 없이 반환\n        return newDir;\n    }\n\n    float invsSq = 1.0 / (s * s);\n    mat3 vSkew = mat3(\n        0.0, -v.z, v.y,\n        v.z, 0.0, -v.x,\n        -v.y, v.x, 0.0\n    );\n\n    // Rodrigues' rotation formula: R = I + vSkew + vSkew^2 * (1 - c) / s^2\n    mat3 vSkewSq = vSkew * vSkew;\n    rotation = mat3(1.0) + vSkew + vSkewSq * (1.0 - c) * invsSq;\n\n    return rotation * newDir;\n}\n\nvec3 sampleHenyeyGreenstein(vec3 omegaPrime, float g, uint rngState) {\n    float xi1 = randomFloat01(rngState);\n    float xi2 = randomFloat01(rngState);\n    float cosTheta = sampleCosTheta(g, xi1);\n    float phi = samplePhi(xi2);\n    vec3 newDir = computeNewDirection(cosTheta, phi);\n    return alignToDirection(newDir, omegaPrime);\n}\n\nfloat calculateScatterProbability(float sigma_s, float delta_x) {\n    return 1.0 - exp(-sigma_s * delta_x);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAY_ITER 40\n#define LIGHT_ITER 32\n#define RAY_STEP_SIZE 0.03\n#define WAVE_ATTEN vec3(0.3, 0.6, 0.9)\n#define LIGHT_STEP 0.05\n\nconst float KEY_SPACE = 32.5/256.0;\n\nvoid rotate(inout vec3 z, vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat3 rot = mat3(\n        c + axis.x * axis.x * (1.0 - c),       axis.x * axis.y * (1.0 - c) - axis.z * s, axis.x * axis.z * (1.0 - c) + axis.y * s,\n        axis.y * axis.x * (1.0 - c) + axis.z * s, c + axis.y * axis.y * (1.0 - c),       axis.y * axis.z * (1.0 - c) - axis.x * s,\n        axis.z * axis.x * (1.0 - c) - axis.y * s, axis.z * axis.y * (1.0 - c) + axis.x * s, c + axis.z * axis.z * (1.0 - c)\n    );\n    z = rot * z;\n}\n\nfloat sphere(vec3 p) {\n    p += vec3(-0.5, -1.1, 0.5);\n    vec3 s = vec3(1.0, 0.3, 1.0);\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat box(vec3 p, vec3 s) {\n    rotate(p, normalize(vec3(-1.0, 0.1, 0.1)), p.z * 3.0);\n    rotate(p, normalize(vec3(0.0, 0.0, -1.3)), p.y * 1.5);\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat julia(vec3 p) {\n    p *= 20.0;\n    rotate(p, normalize(vec3(0.2, 0.5, 0.8)), 0.4);\n    float len = length(p);\n    float scale = 1.1;\n    const int iterations = 5;\n    float a = 30.0;\n    float l = 0.0;\n    vec2 rotationAnimAmp = vec2(0.05, 0.06);\n    vec2 rotationPhase = vec2(\n        cos((iMouse.x / iResolution.x - 0.5) * 3.14) * 0.01,\n        0.15 + cos((iMouse.y / iResolution.y - 0.5) * 3.14) * 0.05\n    );\n    vec3 juliaOffset = vec3(-6.0, 0.1, -2.5);\n    float angleX = 6.2 * iMouse.x / iResolution.x;\n    float cosAngleX = cos(angleX);\n    float sinAngleX = sin(angleX);\n    float angleY = 6.1 * iMouse.y / iResolution.y;\n    float cosAngleY = cos(angleY);\n    float sinAngleY = sin(angleY);\n    for (int i = 0; i < iterations; i++) {\n        p = abs(p);\n        p = p * scale + juliaOffset;\n        {\n            float y = p.y * cosAngleX - p.z * sinAngleX;\n            float z = p.y * sinAngleX + p.z * cosAngleX;\n            p.y = y;\n            p.z = z;\n        }\n        pR(p.xz, rotationPhase.x * a * 2.1 + (iMouse.y / iResolution.y - 0.5) * 6.0);\n        pR(p.yz, rotationPhase.y * 3.14 + sin(a * (iMouse.x / iResolution.x - 0.5) * 3.14 + len) * rotationAnimAmp.x * (iMouse.x / iResolution.x - 0.5) * 6.0);\n        pR(p.zx, rotationPhase.y * 3.14 + sin(a * (iMouse.y / iResolution.y - 0.5) * 3.14) * rotationAnimAmp.x * (iMouse.y / iResolution.y - 0.5) * 6.0);\n        l = length6(p);\n    }\n    return l * pow(scale, -float(iterations)) - 2.9;\n}\n\nfloat fractal(vec3 p) {\n    float angle0 = 0.2;\n    float cosAngle0 = cos(angle0);\n    float sinAngle0 = sin(angle0);\n    float angleX = 6.2 * iMouse.x / iResolution.x;\n    float cosAngleX = cos(angleX);\n    float sinAngleX = sin(angleX);\n    float angleY = 6.1 * iMouse.y / iResolution.y;\n    float cosAngleY = cos(angleY);\n    float sinAngleY = sin(angleY);\n    {\n        float x = p.x * cosAngle0 - p.z * sinAngle0;\n        float z = p.x * sinAngle0 + p.z * cosAngle0;\n        p.x = x;\n        p.z = z;\n    }\n    for (int i = 0; i < 6; i++) {\n        {\n            float y = p.y * cosAngleX - p.z * sinAngleX;\n            float z = p.y * sinAngleX + p.z * cosAngleX;\n            p.y = y;\n            p.z = z;\n        }\n        {\n            float x = p.x * cosAngleY - p.z * sinAngleY;\n            float z = p.x * sinAngleY + p.z * cosAngleY;\n            p.x = x;\n            p.z = z;\n        }\n        float s1 = step(0.0, p.x + p.y);\n        p.xy = mix(-p.yx, p.xy, s1);\n        float s2 = step(0.0, p.y + p.z);\n        p.yz = mix(-p.zy, p.yz, s2);\n        float s3 = step(0.0, p.z + p.x);\n        p.zx = mix(-p.xz, p.zx, s3);\n        p -= 0.03;\n    }\n    return box(p, vec3(0.1, 0.6, 0.1));\n}\n\nfloat sdf(vec3 p) {\n    return julia(p);\n}\n\nfloat sampleDensity(vec3 p) {\n    float delta = 1.0;\n    return max(-sdf(p), 0.0) * 20.0 + delta;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0 * 2.0;\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 col = vec3(0.0);\n    vec3 camPos = vec3(0.0, 0.0, -2.0);\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(vec3(uv, 0.0) - camPos);\n    float time = iTime * 0.2;\n    vec3 transmittance = vec3(1.0);\n    rayPos += rayDir * (1.0 + randomFloat01(rngState));\n    for (int i = 0; i < RAY_ITER; i++) {\n        rayPos += rayDir * RAY_STEP_SIZE;\n        float density = sampleDensity(rayPos);\n        if (density == 0.0) {\n            continue;\n        }\n        vec3 dTrans = exp(-density * RAY_STEP_SIZE * WAVE_ATTEN);\n        vec3 lightDir = randomUnitVector(rngState);\n        vec3 lightRayPos = rayPos;\n        float shadowDensityAcc = 0.0;\n        vec3 lightIntensity = vec3(0.0);\n        for (int j = 0; j < LIGHT_ITER; j++) {\n            if (sphere(lightRayPos) < 0.0) {\n                lightIntensity = vec3(10.0);\n                break;\n            }\n            float shadowDensity = sampleDensity(lightRayPos) * LIGHT_STEP;\n            shadowDensityAcc += shadowDensity;\n            lightRayPos += lightDir * LIGHT_STEP;\n            float shadowScatterProbability = calculateScatterProbability(shadowDensity, LIGHT_STEP);\n            if (shadowScatterProbability > randomFloat01(rngState)) {\n                lightDir = sampleHenyeyGreenstein(lightDir, 0.6, rngState);\n            }\n        }\n\n        vec3 externalLight = exp(-shadowDensityAcc * WAVE_ATTEN) * density * lightIntensity;\n        externalLight = (externalLight - externalLight * dTrans) / density;\n        col += transmittance * externalLight;\n        transmittance *= dTrans;\n\n        if (length(transmittance) < 0.1) {\n            break;\n        }\n\n        float scatterProbability = calculateScatterProbability(density, RAY_STEP_SIZE);\n\n        if (scatterProbability > randomFloat01(rngState)) {\n            rayDir = sampleHenyeyGreenstein(rayDir, 0.6, rngState);\n        }\n\n    }\n\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n\n    vec4 lastFrameColor = texture(iChannel1, fragCoord / iResolution.xy);\n\n    float blend = (lastFrameColor.a == 0.0f || spacePressed || iMouse.z > 0.0) \n\n        ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    fragColor = vec4(col, blend);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}