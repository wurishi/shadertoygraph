{"ver":"0.1","info":{"id":"Wt33WS","date":"1577354913","viewed":101,"name":"cube (I)","username":"omis","description":"simple raymarching cube","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat rep(float x, float r)\n{\n\treturn mod(x, r) - r / 2.0;\n}\n\nfloat sdCube(vec3 p, vec3 b) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    float rp = .75;\n    p.x = rep(p.x, rp);\n    p.y = rep(p.y, rp);\n    p.z = rep(p.z, rp);\n    p.yz *= rot(iTime*0.5);\n    p.xz *= rot(iTime*0.5);\n\treturn sdCube(p, vec3(0.1));\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float tmin)\n{\n\tfloat t = tmin;\n    \n    for (int i = 0; i < 128; i++) \n    {\n    \tfloat d = map(ro + rd * t);\n        if (d < 0.0001*t) {\n        \tbreak;\n        }\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 raydir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = -2.0;\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n}\n\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = map(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( map(pos + eps_zero.xyy), map(pos + eps_zero.yxy), map(pos + eps_zero.yyx) ) - c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // camera\n    vec3 ro = vec3(sin(iTime), 0.0, -iTime);\n    vec3 ta = vec3(.0);\n    \n    // ray\n    vec3 rd = raydir(uv, ro, ta);\n    \n    \n    // render\n    float d = raymarch(ro, rd, 0.0);\n    vec3 p = ro + rd * d;\n    vec3 norm = calcNormal(p);\n    vec3 col = vec3(1.0-exp(d*0.25)) + norm;\n    \n\tcol = pow(col, vec3(2.0));    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}