{"ver":"0.1","info":{"id":"wdByRw","date":"1588251251","viewed":633,"name":"tribute to FF7 - cloud's sword","username":"Cewein","description":"the new remake made me look at another angle to the sword, so here it is.\n\nMusic credits: Final Fantasy OST, Nobuo Uematsu & Masashi Hamauzu ","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["reflection","cloud","music","texture","start","raymaching","sword","metal","finalfantasy","ff7"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a small tribute to FF7 : Cloud's buster sword\n// fell free to look around, there is mouse controle\n//\n// shader made by cewein\n//\n\n\n// signed distance functions\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 sdSword(vec3 pos)\n{\n    //sword\n    float sword;\n    vec3 sp = pos;\n    sp.y += 1.1; sp.xy *= rot(26.0);\n    \n    //blade\n    float blade = sdBox(sp, vec3(0.5,2.5,0.03));\n    float unBlade = sdBox(sp, vec3(0.5,2.5,0.025));\n    float sharpen = dot(sp + vec3(0.,1.3,0.), normalize(vec3(0.75,-0.7,8.0)));\n    unBlade = max(unBlade,sharpen);\n    sharpen = dot(sp + vec3(-.45,0.,0.), normalize(vec3(1,0.0,11.)));\n    unBlade = max(unBlade,sharpen);\n    \n    sharpen = dot(sp + vec3(0.,1.1,0.), normalize(vec3(0.75,-0.7,0.0)));\n    blade = max(blade,sharpen);\n    sharpen = dot(sp + vec3(-.25,0.,0.), normalize(vec3(1,0.0,0.)));\n    blade = max(blade,sharpen);\n    \n    \n    //blade hole\n    float hole1 = length(sp - vec3(0.,2.2,0.)) - 0.1;\n    float hole2 = length(sp - vec3(0.,1.9,0.)) - 0.1;\n    unBlade = max(unBlade,-hole1);\n    unBlade = max(unBlade,-hole2);\n    blade = max(blade,-hole1);\n    blade = max(blade,-hole2);\n    \n    sword = blade;\n    vec3 res = vec3(sword, 1.0,1.);\n    if(unBlade < blade)\n    {\n        sword = min(sword, unBlade);\n    \tres = vec3(sword, 4.0,1.);\n    }\n        \n    //guard\n    float guard = sdBox(sp - vec3(0.,2.5,0.), vec3(0.6,0.08,0.08));\n    float rm = sdBox(sp - vec3(0.,2.5,0.15), vec3(0.62,0.06,0.08));\n    guard = max(-rm,guard);\n    rm = sdBox(sp - vec3(0.,2.5,-.15), vec3(0.62,0.06,0.08));\n    guard = max(-rm,guard);\n    rm = sdBox(sp - vec3(.78,2.5,0.), vec3(0.2,0.06,0.08));\n    guard = max(-rm,guard);\n    rm = sdBox(sp - vec3(-.78,2.5,0.), vec3(0.2,0.06,0.08));\n    guard = max(-rm,guard);\n\tif( guard<sword)\n    {\n     \tsword = min(sword,guard);\n        res = vec3(sword, 2.0,-1.);\n    }\n    \n    //guard bolt\n    vec3 bp = sp;\n    bp.yz *= rot(90.0);\n    float bolts = sdVerticalCapsule(bp - vec3(-0.5,-.07,2.5), .14, 0.03);\n    float b = sdVerticalCapsule(bp - vec3(-0.3,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(-0.1,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(0.1,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(0.3,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(0.5,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    \n    if(bolts < sword)\n    {\n    \tsword = min(sword,bolts);\n    \tres = vec3(sword, 4.0,0.3);\n    }\n    \n    //handle\n   \tfloat handle = sdCappedCylinder(sp - vec3(0.,3.0,0.), 0.08, 0.4);\n    float handleDown = sdCappedCylinder(sp - vec3(0.,2.635,0.), 0.1, 0.05);\n    float handleUp = sdCappedCylinder(sp - vec3(0.,3.44,0.), 0.1, 0.05);\n    handleDown = min(handleDown,handleUp);   \n\tif(handle<sword)\n    {\n     \tsword = min(sword,handle);\n        res = vec3(sword, 3.0,-1.);\n    }\n    \n    if(handleDown<sword)\n    {\n        sword= min(sword,handleDown);\n        res = vec3(sword, 4.0,.3);\n    }\n    \n    //health ball\n    float sph = length(sp - vec3(0.,2.2,0.)) - .09;\n    if(sph  == sword)\n    {\n    \tsword = min(sword, sph);\n    \tres = vec3(sword, 5.0, -1.);\n    }\n    \n    return res;\n}\n\n\n//Mapping function\nvec3 map(in vec3 pos) \n{\n    //tm is the vec3(distance, id mat, boolean for reflection)\n    vec3 tm = sdSword(pos);\n    float flr = pos.y + 2.1;\n \tif(flr<tm.x)\n    {\n        tm.x = flr;\n        tm.y = 6.;\n        tm.z = -1.;\n    }\n    \n    return tm;\n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(map(pos + e.xyy).x-map(pos-e.xyy).x,\n                          map(pos + e.yxy).x-map(pos-e.yxy).x,\n                          map(pos + e.yyx).x-map(pos-e.yyx).x)\n                    );\n}\n\n//ray marching algorithms\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n    vec3 tm = vec3(0., -1., -1.);\n    vec3 vc = vec3(0.);\n    for(int i = 0; i<120; i++)\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 h = map(pos);\n        if(h.x < 0.0001) break;\n        tm.y = h.y;\n        tm.x += h.x;\n        tm.z = h.z;\n        if(tm.x > 200.)\n        {\n            tm.y = -1.; \n            break;\n        }\n        \n    }\n        \n    return tm;\n}\n\nvec3 hash33(vec3 p){\n    p  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n    return fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\n//thanks for the stars, check this shader out, it contain midgar\n//https://www.shadertoy.com/view/XllXWN\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*250.)-0.5;\n        vec3 id = floor(p*250.);\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*smoothstep(-0.1, 0., p.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, vec2 uv)\n{\n    float mult = 1.0;\n    vec3 col = stars(rd) * smoothstep(0.,.5, dot(rd,vec3(0.,1.,0.)));\n    vec3 density;\n    \n   \tvec3 tm = castRay(ro,rd);\n\n    vec3 pos = ro + tm.x*rd;\n    vec3 mat = vec3(0.01)* texture(iChannel2, (10. + pos.xz)/100.).x * smoothstep(10.,0.,length(pos));\n    vec3 sunDir = normalize(vec3( 1.0,0.5,.6));\n    \n    if(tm.y < 1.5)\n    {\n        vec3 pos = ro + tm.x*rd;\n        mat = vec3(0.025) * texture(iChannel0,pos.xy).x;\n    }\n    else if(tm.y < 2.5)\n    {\n        mat = vec3(.01);\n    }\n    else if(tm.y < 3.5)\n    {\n        mat = vec3(0.35, 0.20, 0.05)* texture(iChannel1,pos.xy).xyy;\n    }\n    else if(tm.y < 4.5)\n    {\n        mat = vec3(0.1);\n    }\n    else if(tm.y < 5.5)\n    {\n        mat = vec3(0.0,0.04,0.);   \n    }\n    \n    if(tm.y > 0.)\n    {\n        vec3 density;\n        vec3 norm = calcNormal(pos);\n        \n        vec3 volPos = vec3(0.95,.9,0.);\n        \n        vec3 tmp;\n        \n       \tfloat sunDif = clamp( dot(norm, sunDir),0.,1.);\n        float skyDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,1.,0.)),0.,1.);\n        float sunSha = step(castRay(pos + norm * 0.001, sunDir).y,0.);\n        float bouceDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,-1.,0.)),0.,1.);\n        \n        col =  mat * vec3(2.0)* sunDif * sunSha;\n        col += mat * vec3(0.5) * skyDif;        \n        col += mat * vec3(0.1) * bouceDif;\n        \n        if(tm.z > 0.)\n        {\n            vec3 ref = reflect(rd, norm);\n            vec3 spe = vec3(smoothstep(0.0,0.35,clamp( dot(ref, sunDir),0.,1.)));\n            float fre = clamp(1.0+dot(rd,norm), 0.,1.0);\n            spe *= mat + (1.0-mat)*pow(fre,5.0);\n            spe *= 100. * tm.z;\n            \n            col += mat*spe*sunSha;\n        }\n        \n    }\n\n    col += density;\n    \n    \n    col = pow(col, vec3(0.4545));\n    \n    return col;\n}\n \nvec3 getDir(in vec3 ro, in vec2 uv)\n{\n    vec3 ta = vec3(0.,0.5,0.);\n    \n    vec3 ww = normalize(ta-ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.0,0.))); //right\n    vec3 vv = normalize(cross(uu,ww)); //up\n    \n    return normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float angle = 10.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(5.0 * sin(angle),1.,5.0 * cos(angle));  \n    vec3 rd = getDir(ro, uv);\n    vec3 col = render(ro,rd, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}