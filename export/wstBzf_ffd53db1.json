{"ver":"0.1","info":{"id":"wstBzf","date":"1606174551","viewed":404,"name":"Folosh [Demosplash 2020]","username":"JacobC","description":"My entry to Demosplash 2020. http://www.demosplash.org/\nThe demo was developed with js, the original has sound.","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["3d","light","shadows","demosplash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Folosh [Demosplash 2020]\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n\n// To change number of particles go to Common\n\nfloat map(float i ,vec2 q)\n{\n    return 1. - 1. / (1. + q.x * i + q.y * i * i);\n}\n\nvec2 marchingScene(vec3 p)\n{\n    vec2 cylinder = vec2(objectSDF(p-vec3(0, -24, 0), vec4(20, 20, .1, 2)), 0.);\n    p -= objectPosition;\n    p.xy *= Rotation(T);\n    p.yz *= Rotation(T);\n    vec2 object = vec2(objectSDF(p, morphingValues), 1);\n    \n    return (cylinder.x < object.x) ? cylinder : object;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(marchingScene(p).x - \n                     vec3(marchingScene(p - e.xyy).x, marchingScene(p - e.yxy).x, marchingScene(p - e.yyx).x));\n}\n\n#define STEPS 128\n#define MIN_S .01\n#define MAX_S 999.\nvec2 marcher(vec3 o, vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec2 s = marchingScene(o + d * t);\n        t += s.x;\n        if (s.x < MIN_S)\n            return vec2(t, s.y);\n        if (t > MAX_S)\n            return vec2(-1);\n    }\n}\n\n#define SHADOW 30\n#define MIN_SH .2\n// A modify version from: https://iquilezles.org/articles/rmshadows\n// Instead of storing the min distance to the object i decided to accumulate the min distance for shadows\n// I did the same for sphere shadows function: float sphereShadow(vec3 o, vec3 d, int id, float k)\nfloat shadow(vec3 o, vec3 d, float k)\n{\n    float t = 0.;\n    float m = 1.;\n    for (int i = 1; i < SHADOW; i++)\n    {\n        float s = marchingScene(o + d * t).x;\n        m = m * map(s / t * k, vec2(.3,.4)); // Color accumulation\n        t += s;\n        if (s < MIN_SH)\n            return 0.;\n    }\n    return m;\n}\n\n// Cheap Ambient Occlusion: https://www.shadertoy.com/view/ttXfWX\n// Color bleeding https://www.shadertoy.com/view/WtSfzh\nvec4 colorBleeding_AO(vec3 o, int id, int f)\n{\n    // Particles, floor and wall AO and color bleeding\n    vec4 d = vec4(1);\n    for (int i = 0; i < particles + 2; i++)\n    {\n        if (i != id)\n        {\n            vec4 c = (i<particles)    ? texelFetch(iChannel0, ivec2(i, 0), 0): \n            \t\t (i == particles) ? vec4(0,-5025,0,5000): \n            \t\t\t\t\t\t\tvec4(0,0,-5060,5000);\n            float t = length(o - c.xyz) - c.w;\n            d.w *= map(t, (i >= particles) ? vec2(1) : vec2(.3));\n            d.xyz *= mix((i < particles + 1) ? mix(creamColor, backColor, float(i % 2)) :\n                         \t\t\t\t\t   particleColor, vec3(1), map(t, vec2(.3)));\n        }\n    }\n    \n    vec2 t = marchingScene(o);\n    // If its a particle it needs to obtain the AO and color bleeding from SDF surfaces\n    if (f < 0)\n    {\n    \td.w *= map(t.x, (t.y == 0.) ? vec2(9) : vec2(2));\n   \t\td.xyz *= mix((t.y == 0.) ? creamColor : objectColor, vec3(1), map(t.x, vec2(2)));\n    }\n    // If its one of the SDF surfaces just check the other SDF object for AO and color bleeding\n    if(f >= 0)\n    {\n        float a = objectSDF(o - vec3(0, -24, 0), vec4(20, 20, .1, 2));\n    \tfloat b = objectSDF(o - objectPosition, morphingValues);\n        float s = max(a, b);\n        d.w *= map(s, vec2(.1));\n    \td.xyz *= mix((a > b) ? creamColor : objectColor, vec3(1), map(s, vec2(.1)));\n    }\n    \n    return d;\n}\n\n// Sphere-Origin ray projection to Direction ray\n// Return normal and distance\nvec4 sphere(vec3 O, vec3 D, vec4 C)\n{\n    vec3 K = C.xyz - O;\n    float r = max(dot(normalize(K), D), 0.) * length(K);\n    vec3 U = O + D * r;\n    float v = length(U - C.xyz);\n    \n    // If doesn't hit the sphere returns the distance to the surface and -1\n    // to indicate that didn't hit but.\n    // The distance is used for soft shadows\n    if (v - C.w > 0.)\n        return vec4(U,-1);\n    \n    float t = r - sqrt(C.w * C.w - v * v);\n    \n    return vec4(((O + D * t) - C.xyz) / C.w, t);\n}\n\nfloat sphereShadow(vec3 o, vec3 d, int id, float k)\n{\n    vec4 t = vec4(1000);\n    float m = 1.;\n    \n    for (int i = 0; i < particles; i++)\n    {\n        if (i != id)\n        {\n            vec4 c = texelFetch(iChannel0, ivec2(i, 0), 0);\n            vec4 s = sphere(o, d, c);\n            \n            if (s.w != -1. && s.w < t.w)\n                return 0.;\n            float u = (length(s.xyz - c.xyz) - c.w) / length(s.xyz - o);\n            m = m * map(u * k, vec2(.3,.4)); // Color accumulation\n        }\n    }\n    \n    return max(m, 0.);\n}\n\nvec3 camera(vec2 p, vec3 o, vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0,1,0), w));\n    vec3 v = cross(w, u);\n    \n    return p.x * u + p.y * v - w;\n}\n\nvoid mainImage(out vec4 O, in vec2 F)\n{\n    vec2 uv = (F - R.xy*.5) / R.y;\n    vec3 col;\n    \n    float blackScreenEdges = smoothstep(.0, 1. / R.y, min(T*.1, .37) - abs(uv.y)) *(T > 90. ? 0. : 1.);\n    \n    if (blackScreenEdges > 0.)\n    {     \n        // Object attributes\n        morphingValues = texelFetch(iChannel0, ivec2(0, 2), 0);\n        objectPosition = texelFetch(iChannel0, ivec2(0, 3), 0).xyz;\n        \n        // Colors\n        backColor = texelFetch(iChannel0, ivec2(0, 4), 0).rgb;\n        particleColor = texelFetch(iChannel0, ivec2(0, 5), 0).rgb;\n        objectColor = texelFetch(iChannel0, ivec2(0, 6), 0).rgb;\n        \n        // Camera properties\n        vec3 origin = vec3(0, 20, 140);\n        vec3 target = vec3(0, 10, 0);\n        vec3 direction = normalize(camera(uv, origin, target));\n        \n        float maxDistance = 500.;\n        vec3 sphereNormal;\n        int ID = -1;\n        vec3 color;\n\n        // Marching to flying object and cylinder\n        vec2 m = marcher(origin, direction);\n        // Ray particles and big spheres(floor and wall) intersection\n        for(int i = 0; i < particles+2; i++)\n        {\n            vec4 particle = (i < particles) ? texelFetch(iChannel0, ivec2(i, 0), 0): \n            \t\t\t\t\t\t   \t\t  (i == particles) ? vec4(0, -5025, 0, 5000): \n            \t\t\t\t\t\t\t\t\t\t\t  \t\t vec4(0, 0, -5060, 5000);\n            vec4 s = sphere(origin, direction, particle);\n            if (s.w != -1. && s.w < maxDistance)\n            {\n                maxDistance = s.w;\n                sphereNormal = s.xyz;\n                ID = i;\n                color = (i < particles + 1) ? mix(creamColor, backColor, float(i % 2)) : particleColor;\n            }\n        }\n\n        vec3 lightPosition = vec3(80);\n        float shadowSoftness = 32.;\n\n        // If there is an intersection\n        if (ID != -1)\n        {\n            vec3 newOrigin = origin + direction * maxDistance;\n            vec3 newDirection = sphereNormal;\n\n            int objectID = -1; // static cylinder or flying object ID\n            // If Flaying object or static cylinder is in front of\n            if (m.x > 0. && m.x < maxDistance)\n            {\n                newOrigin = origin + direction * m.x;\n                newDirection = normal(newOrigin);\n                color = m.y == 0. ? creamColor : objectColor;\n                objectID = int(m.y);\n            }\n\n            // Color\n            vec3 lightDirection = normalize(lightPosition - newOrigin);\n            vec4 i = colorBleeding_AO(newOrigin, ID, objectID);\n            float s = sphereShadow(newOrigin, lightDirection, ID, shadowSoftness);\n            float p = shadow(newOrigin + newDirection, lightDirection, shadowSoftness * .5);\n\n            col += (max(dot(newDirection, lightDirection), 0.) * (s * p) + i.w) / 2. * color * i.xyz;\n        }\n        \n        O = vec4(sqrt(col) * blackScreenEdges, 1);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// To change number of particles go to Common\n\nfloat random(float i)\n{\n    return fract(sin(i * 8.233) * 43758.5453123);\n}\n\nfloat box(vec3 p, vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.) - k;\n}\n\n// Get the nearest surface point direction of the flying object, not just the center\nfloat object(vec3 p)\n{\n    p -= objectPosition;\n    p.xy *= Rotation(T);\n    p.yz *= Rotation(T);\n    float object = objectSDF(p, morphingValues);\n    \n    return object;\n}\n\nvec3 objectNormal(vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(object(p) - vec3(object(p - e.xyy), object(p - e.yxy), object(p - e.yyx)));\n}\n\n// Collisions \nfloat scene(vec3 p)\n{\n    float boxCollider = abs(box(p - vec3(0, 34., 0), vec3(120, 60, 60), 0.)); // Box collider to limit space\n    float r = boxCollider;\n    \n    for (int i = 0; i < int(particles); i++)\n    {\n        if (i != int(particleID))\n        {\n            vec4 properties = texelFetch(iChannel0, ivec2(i, 0), 0);\n            float particle = box(p - properties.xyz, vec3(properties.w), properties.w);\n            r = min(r, particle);\n        }\n    }\n    \n    float cylinder = objectSDF(p-vec3(0,-24,0),vec4(20,20, .1, 2.));// static cylinder at center below\n    p -= objectPosition;\n    p.xy *= Rotation(T);\n    p.yz *= Rotation(T);\n    float object = objectSDF(p, morphingValues); // Flying object\n    \n    r = min(r, cylinder);\n    r = min(r, object);\n    \n    return r;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(scene(p) - vec3(scene(p - e.xyy), scene(p - e.yxy), scene(p - e.yyx)));\n}\n\n// Changing color of the objects\n// colorI: input color\n// colorT: trnasition color\nvec3 colorTransition(vec3 colorI, vec3 colorT, float time, float transitionSpeed)\n{\n    return (floor(T) < time * 2.) ? colorI:\n    \t   (floor(T) < time * 3.) ? mix(colorI, colorT, \ttransitionSpeed):\n    \t   (floor(T) < time * 4.) ? mix(colorI, colorT.zyx, transitionSpeed):\n    \t   (floor(T) < time * 5.) ? mix(colorI, colorT.zxy, transitionSpeed):\n    \t   (floor(T) < time * 6.) ? mix(colorI, colorT.xzy, transitionSpeed):\n    \t   (floor(T) < time * 7.) ? mix(colorI, colorT.yzx, transitionSpeed):\n    \t   \t\t\t\t\t\t    mix(colorI, colorT.yxz, transitionSpeed * .1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv=F.xy/iResolution.xy;\n    \n    particleID = min(int(F.x), particles);\n    \n    // Particle attributes\n    particlePosition = vec3(particleID % 4, 30, random(float(particleID)));\n    particleVelocity = vec3(0);\n    particleRadius = (random(float(particleID)) + 4.);\n    \n    // Flying object attributes\n    objectPosition = vec3(0, -12, 0);\n    morphingValues = vec4(10, 10, 10, 0);\n    \n    // Colors\n    backColor = vec3(0,.3,.2);\n\tparticleColor = vec3(0,.2,.3);\n\tobjectColor = vec3(.6,1,.8);\n    \n    if (iFrame > 0)\n    {\n        // Particle attributes\n        int x = int(particleID);\n        particleRadius = texelFetch(iChannel0, ivec2(x, 0), 0).w;\n        particlePosition = texelFetch(iChannel0, ivec2(x, 0), 0).xyz;\n        particleVelocity = texelFetch(iChannel0, ivec2(x, 1), 0).xyz;\n        \n        // Flying object attributes\n        morphingValues = texelFetch(iChannel0, ivec2(0, 2), 0);\n        objectPosition = texelFetch(iChannel0, ivec2(0, 3), 0).xyz;\n        \n        // Colors\n        backColor = texelFetch(iChannel0, ivec2(0, 4), 0).rgb;\n        particleColor = texelFetch(iChannel0, ivec2(0, 5), 0).rgb;\n        objectColor = texelFetch(iChannel0, ivec2(0, 6), 0).rgb;\n    }\n\n    float timeLimit = 12.; // specifies base time to make transitions\n    float transitionTime = mod(T, timeLimit) * .2;\n    transitionTime = min(transitionTime, 1.);\n    \n    // Flying object morphing update\n    // Sphere -> Capsule -> Cylinder -> Disk -> Torus -> Pipe -> Sphere\n    morphingValues = floor(T) < timeLimit * 2. ? morphingValues:\n    \t\t\t\t floor(T) < timeLimit * 3. ? mix(morphingValues, vec4( 8,  8,  8, 16), transitionTime): // Capsule\n    \t\t\t\t floor(T) < timeLimit * 4. ? mix(morphingValues, vec4(25, 25, 10, 10), transitionTime): // Cylinder\n    \t\t\t\t floor(T) < timeLimit * 5. ? mix(morphingValues, vec4(25, 25,  5,  0), transitionTime): // Disk\n    \t\t\t\t floor(T) < timeLimit * 6. ? mix(morphingValues, vec4( 5, 30,  5,  0), transitionTime): // Torus\n    \t\t\t\t floor(T) < timeLimit * 7. ? mix(morphingValues, vec4( 5, 30,  5, 10), transitionTime): // Pipe\n    \t\t\t\t\t\t\t\t\t \t\t mix(morphingValues, vec4(10, 10, 10,  0), transitionTime * .1); // Sphere\n    \n    // Color update\n    backColor\t  = colorTransition(backColor, \t   vec3(.3, 0, .2), timeLimit, transitionTime);\n    particleColor = colorTransition(particleColor, vec3(.2, 0, .3), timeLimit, transitionTime);\n\tobjectColor   = colorTransition(objectColor,   vec3(1, .6, .8), timeLimit, transitionTime);\n    \n    // This was the original, just to remove code i decided\n    // to change a little the transition colors of the object\n    // objectColor = floor(T) < timeLimit * 2. ? objectColor:\n    // \t\t\t\t floor(T) < timeLimit * 3. ? mix(objectColor, vec3(.6, .8, 1), transitionTime):\n    // \t\t\t\t floor(T) < timeLimit * 4. ? mix(objectColor, vec3(.8, .6, 1), transitionTime):\n    // \t\t\t\t floor(T) < timeLimit * 5. ? mix(objectColor, vec3(1, .6, .8), transitionTime):\n    // \t\t\t\t floor(T) < timeLimit * 6. ? mix(objectColor, vec3(1, .8, .6), transitionTime):\n    // \t\t\t\t floor(T) < timeLimit * 7. ? mix(objectColor, vec3(.8, 1, .6), transitionTime):\n    // \t\t\t\t\t\t\t\t\t\t\t mix(objectColor, vec3(.6, 1, .8), transitionTime * .1);\n    \n    // Flying object position update\n    if (T > 4. && T < timeLimit)\n    \tobjectPosition.y += T * .05;\n    objectPosition.y = min(objectPosition.y, 24.);\n    if (T > timeLimit && T < timeLimit * 7.)\n    {\n        float t = T - timeLimit;\n        float m = min(t * .5, 1.);\n    \tobjectPosition.xz = vec2(sin(t) * mix(0., 80., m), cos(t) * mix(0., 12., m));\n    \tobjectPosition.y = 24. + sin(t * 2.) * mix(0., 12., m);\n    }\n    if (T > timeLimit * 7.)\n        objectPosition = mix(objectPosition, vec3(0, -12, 0), transitionTime * .1);\n    \n    // Particles acceleration\n    particleRadius += sin(T) * .01; // Particles size changing\n    vec3 i = objectNormal(particlePosition); // Nearest surface point of flying object to particle\n    if (T < timeLimit * 7. - 1.)\n    \tparticleVelocity -= i * .1;\n    else if (T > timeLimit * 7. - 1. && T < timeLimit * 7.)\n        particleVelocity -= -i * .4;\n    else\n        particleVelocity.y -= .1;\n    if (T > timeLimit && T < timeLimit * 8.)\n    {\n        particleVelocity.xz -= vec2(sin(T), cos(T)) * .01;\n    \tparticleVelocity += (random(floor(T) * float(particleID + 1)) * 2. - 1.) * .01;\n    }\n    particlePosition += particleVelocity;\n    \n    // Collision detection\n    float s = scene(particlePosition) - particleRadius;\n    vec3 n = normal(particlePosition);\n    if (s <= 0.)\n    {\n        particleVelocity = reflect(normalize(particleVelocity), n) * length(particleVelocity) * (T < timeLimit * 7. ? .6 : .8);\n        particlePosition += n * abs(s);\n    }\n    \n    // Output\n    int y=int(F.y);\n    O = (y == 0) ? vec4(particlePosition, particleRadius):\n    \t(y == 1) ? vec4(particleVelocity, \t\t\t  1):\n    \t(y == 2) ? vec4(morphingValues\t\t\t\t   ):\n    \t(y == 3) ? vec4(objectPosition, \t\t\t  1):\n    \t(y == 4) ? vec4(backColor, \t\t\t\t\t  1):\n    \t(y == 5) ? vec4(particleColor, \t\t\t\t  1):\n    \t\t\t   vec4(objectColor, \t\t\t\t  1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Change number of particles\n#define particles 56\n#define T iTime\n#define R iResolution.xy\n\nint particleID;\n\nfloat particleRadius;\nvec3 particlePosition;\nvec3 particleVelocity;\n\nvec3 objectPosition = vec3(0,-12,0);\n// transform from sphere to capsule, etc., in other words how the object chages\n// the morphing values are explain in objectSDF function\nvec4 morphingValues = vec4(10.,10.,10.,0.); // Sphere-Ccapsule-Cylinder-Disk-Torus-Pipe object\n\n// From here onward i will refere to just \"Flying object\" to the Sphere-Ccapsule-Cylinder-Disk-Torus-Pipe  \n\nvec3 creamColor = vec3(1, .9,.8); // ground, cylinder and half of the particles\nvec3 backColor;\nvec3 particleColor;\nvec3 objectColor;\n\nmat2 Rotation(float a)\n{\n    return mat2( cos(a), sin(a), \n                -sin(a), cos(a)\n               );\n}\n\n// This is the function that i use to discribe the Sphere-Capsule-Cylinder-Disk-Torus-Pipe\n// I use it like this because i want it the morphing to look smooth at each transition\n// and also \"easier\"\n// Morphing values\n// r.x: inner radius\n// r.y outer radius\n// r.z: roundness (round edges)\n// r.w: height\nfloat objectSDF(in vec3 p, in vec4 r)\n{\n    return length(vec2(max(abs(length(p.xz)-(r.y-(r.x+r.z)*.5))-(r.x-r.z)*.5,0.),max(abs(p.y)-r.w,0.)))-r.z;\n}","name":"Common","description":"","type":"common"}]}