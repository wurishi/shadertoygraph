{"ver":"0.1","info":{"id":"DtGfzK","date":"1702253384","viewed":30,"name":"Fork edfork edfilo 258","username":"edfilo","description":"it is possible in the world of hotdog pain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["flagship"],"hasliked":0,"parentid":"mtKBzy","parentname":"edfork"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright 2020 Simon Green (@simesgreen)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst int _Steps = 64;\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca * p.x - sa * p.y;\n    r.y = sa * p.x + ca * p.y;\n    r.z = p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\nfloat luminance(sampler2D tex, vec2 uv)\n{\n\tvec3 c = textureLod(tex, uv, 0.0).xyz;\n\treturn dot(c, vec3(0.33, 0.33, 0.33));\n}\n\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat heightField(vec3 p)\n{\n    // @TODO here you can read from the depth map texture \n\treturn luminance(iChannel0, worldToTex(p))*0.5;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n\t\t\t//hitPos = p;\n\t\t\t// interpolate based on height\n            hitPos = mix(pP, p, (pH - pP.y) / ((p.y - pP.y) - (h - pH)));\n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return vec3(0., 0., 0.);\n}\n\nconst vec3 boxMin = vec3(-1.0, -0.01, -1.0);\nconst vec3 boxMax = vec3(1.0, 0.5, 1.0);\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// rotate view\n    float ax =4.5;\n    float az = 1.;\n \n    \n    az = -(1.0 - mouse.x)*2.0 + 1.0 + .5 * sin(iTime);\n\t\n    \n    float ay = 0.;\n       \n    // @TODO this could be optimized out\n   // rd = rotateX(rd, ax);\n   // ro = rotateX(ro, ax);\n\n\t\n   // rd = rotateZ(rd, az);\n   // ro = rotateZ(ro, az);\n\t\n\t// intersect with bounding box\n    bool hit;\t\n\t\n\tfloat tnear, tfar;\n\thit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n\n\ttnear -= 0.0001;\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) / float(_Steps);\n\t\n    vec3 rgb = vec3(0., 0., 0.);\n    if(hit)\n    {\n    \t// intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n\t\thit = traceHeightField(ro, rd*stepSize, hitPos);\n\t\tif (hit) {\n\t\t \n\t\t  vec2 uv = worldToTex(hitPos);\n          \n\t\t  rgb = texture(iChannel0, uv).xyz;\n          \n\t\t}\n     }  \n     \n     fragColor = vec4(rgb, 1.0);\n\n    if (int(fragCoord.x) % 3 == 0) {\n      fragColor = vec4(rgb, 1.0);\n    } else {\n      fragColor = vec4(0., 0., 0., 1.);\n    }\n}\n","name":"Image","description":"","type":"image"}]}