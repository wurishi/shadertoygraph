{"ver":"0.1","info":{"id":"lt3SzX","date":"1480796528","viewed":198,"name":"#Devember 2016 - day 02","username":"theGiallo","description":"Experimenting with music.","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["tunnel","music","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ls2GW1","filepath":"https://soundcloud.com/jakechudnow/lions-tigers-and-apes?in=dvdrom000/sets/vsauce","previewfilepath":"https://soundcloud.com/jakechudnow/lions-tigers-and-apes?in=dvdrom000/sets/vsauce","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = vec4(0);\n    \n    float fft  = texture( iChannel1, vec2(q.x, 0.25) ).x;\n    float wave = texture( iChannel1, vec2(q.x, 0.75) ).x;\n    float graph = 1.0 - smoothstep( 0.0, 0.01, abs( q.y - wave ) );\n    col = graph * vec4( vec3(1.0) - vec3(0.0, 0.6, 1.0) * wave, 1.0 );\n    \n    graph = 1.0 - smoothstep( 0.0, 0.01, abs( q.y - pow(wave,4.0) * 2.0 ) );\n    col += graph * vec4( ORANGE_RGB, 1.0 );\n    \n    #if 1\n    float t = iTime;\n    vec2 center = vec2( sin( t ), cos( t ) ) * 0.1 * ( 1.0 - length( p ));\n    vec2 pc = p - center;\n    float a = atan( pc.y, pc.x );\n    float a01 = 0.5*a/PI+0.5;\n    float r = length( pc );\n    float distance = 1.0 / r;\n    vec2 uv_c = vec2( distance + t*0.1, a01 * 6.0 );\n    float mirror_x = mirror( uv_c.x * 0.02 + t * 0.05 );\n    float dw;\n    #if 0\n      dw = pow(texture( iChannel1, vec2( mirror_x, 0.25 ) ).x,4.0)*2.0;\n    #else\n      dw = texture( iChannel1, vec2( mirror_x, 0.25 ) ).x;\n    #endif\n    uv_c += dw;\n    col = texture( iChannel0, uv_c );\n    \n    float h = texture(iChannel1, vec2(decimal( dw + a01            ),0.75)).x * 0.25 +\n              texture(iChannel1, vec2(decimal( dw + a01 - 1.0/512.0),0.75)).x * 0.5  +\n              texture(iChannel1, vec2(decimal( dw + a01 + 1.0/512.0),0.75)).x * 0.25 ;\n    vec4 fft_col = rgb_from_hsv( vec4(sqrt(h),0.5, clamp(dw+0.1,0.0,1.0), 1.0) );\n    col *= fft_col;\n    \n    float b = 0.05;\n    vec4 fog_color = vec4(0.5,0.6,0.7,1.0);\n    col = col * fog_color * ( 1.0 - exp( -distance * b ) ) + col * exp( -distance * b );\n    #endif\n    \n    #if 0\n    if ( q.y > 0.5 )\n    {\n     col = rgb_from_hsv( vec4( sqrt( texture( iChannel1, vec2( mirror( q.x * 1.0 ), 0.75 ) ).x ), 1.0, 1.0, 1.0 ) );\n    } else\n    {\n    \t// col = vec4( texture( iChannel1, vec2( mirror( q.x * 10.0 ), 0.75 ) ).x );\n    \tcol = rgb_from_hsv( vec4( q.x, 1.0, 1.0, 1.0 ) );\n    }\n    #endif\n    \n     \n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}