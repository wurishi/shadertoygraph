{"ver":"0.1","info":{"id":"lfdBz8","date":"1732897530","viewed":19,"name":"ideas for caleb","username":"jakel101","description":"trying to make a reference idea for certain stream\n\nnot done yet. published unfinished - might revisit in a year","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["2d","game","textures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Apache 2.0 license, no patents :^\n// ideas of what could be done with shadercoding.\n/* desgin brief:: (cont.)\nvim colorschemes, trees, tokyo?  0:22:45 https://x.com/ThePrimeagen/status/1861750821504827569\nfractal trees? 1:08:45 https://x.com/ThePrimeagen/status/1861750821504827569\nHollow Knight style 5:00:11 https://x.com/ThePrimeagen/status/1854155062282531119\n*/\n\n\n// [ utils], partly done myself, partly copied\n\nvec3 hex2col(uint hex){\n    uint r = hex >> 16;\n    uint g = hex >> 8 ^ r<<8;\n    uint b = hex ^ r << 16 ^ g << 8;\n    \n    vec3 col;\n    col.r = float(r)/255.0;\n    col.g = float(g)/255.0;\n    col.b = float(b)/255.0;\n    return col;\n}\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 hash22(in uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n//todo: draw function with col inout and object col(already texture fitted), alpha\nvoid draw(inout vec4 col, vec4 obj, float alpha){\n    // col.a and obj.a holds depth\n    float front = float(obj.a > col.a);\n    col = mix(col, obj, clamp(0.0, 1.0, alpha*front));\n}\n\n\n// [ distance functions ]\n\nfloat sdCircle(vec2 pos, float rad){\n    return length(pos) -rad;\n}\n// with help from https://youtu.be/62-pRVZuS5c?si=cGF1eZBKKs1lXPHG\nfloat sdBox(vec2 pos, float width, float height){\n    vec2 dist = abs(pos) - vec2(width, height);\n    \n    return length(max(dist, 0.0)) + min(max(dist.x,dist.y),0.0);\n}\n// Isosceles  triangle(ref: https://www.shadertoy.com/view/MldcD7)\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// simple or random trees?\n// maybe fractals?\n// one ref: https://www.youtube.com/watch?v=LLZPnh_LK8c\nfloat sdTree(vec2 pos, float height){\n    // pos is kinda the position of the root\n    pos.y -= height;\n    float trunk = sdTriangleIsosceles(pos, vec2(height/20.0, -height));\n    float dist = trunk;\n    // tbd maybe a small loop or fract?\n    int num_leaves = int(height*(3.0+height))+1;\n    for (int i = 0; i < num_leaves; i++){\n        float width = 0.01+0.05*float(i+1);\n        float height = -0.08*float(i+i+1);\n        float leaf = sdTriangleIsosceles(pos - vec2(0.0, (-cos(abs(pos.x*2.9)-width*1.5))+1.0), vec2(width, height));\n        pos.y += 0.002*float(i+i*num_leaves);\n        dist = min(dist, leaf);\n    }\n    \n    return dist;\n    \n}\n\n\n// [ constructions? ]\n\n// instead of the fake 3D stuff make this an element directly with alpha mask?\nvec4 buildings(vec2 pos, vec3 wall_col, vec3 window_col, vec3 light_col){\n    float num_buildings = 2.5; //scale with uv.x so it's lie 3x or something\n    pos.x += iTime*0.1; // pseudo animation\n    vec2 build_uv = vec2(fract(pos.x*num_buildings)-0.5, pos.y+1.0);\n    // speudo hash\n    float height = hash22(uvec2(floor(pos.x*num_buildings)+100.0, 544)).x*1.6 + 0.5;\n    float building_dist = sdBox(build_uv, .45, height);\n    \n    // real numbers to hash after\n    float floors = (build_uv.y - height)*floor(height+10.0);\n    float rooms = build_uv.x*(1.0/0.45)*floor(height+3.5);\n    vec2 window_uv = fract(vec2(rooms,floors))-vec2(0.5);\n    float window_id = fract(dot(hash22(uvec2(rooms+254.0, floors+987.0)*uint(height*953.702)),vec2(12.34,56.78))); // bad hashes again\n    float window_dist = sdBox(window_uv,0.25, 0.3);\n    float window_mask = smoothstep(0.01, 0.0, window_dist);\n    \n    float lights_mask = float(window_id > 0.9);\n\n    float alpha = clamp(smoothstep(0.01, 0.0,building_dist), 0.0, 1.0);\n    vec3 col = wall_col;\n    col = mix(col, window_col, window_mask);\n    col = mix(col, light_col, lights_mask*window_mask);\n    \n    \n    //col = vec3(window_id);\n    return vec4(col, alpha);\n}\n\n\n// tbd with projection and sampling for craters?\nvec4 moon(vec2 pos, vec3 moon_col, vec3 crater_col){\n    vec3 col = moon_col;\n    float alpha = 0.0;\n    return vec4(col, alpha);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv from -1..1 for wide screen\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    // scene elements as distance functions\n    // .z component is depth/layer for potential parallax\n    vec3 moon_pos = vec3(-0.6, 0.3, -5.0);\n    float moon_dist = sdCircle(uv-moon_pos.xy, 0.4);\n    vec3 platform_pos = vec3(-0.7, -1.0, 1.0);\n    float platform_dist = sdBox(vec2(fract(uv.x+(iTime+3.0)*0.2)-0.5,uv.y - platform_pos.y), 0.4, 0.1);\n    vec3 caleb_pos = vec3(-1.0, max(-0.8, -(pow(mod(iTime, 5.0)-2.0,2.0))), 1.0);\n    float caleb_dist = sdBox(uv - caleb_pos.xy, 0.05, 0.1);\n    vec3 tree_pos = vec3(-iTime*0.2, -1.0, -2.0);\n    float tree_dist = sdTree(vec2(fract(uv.x+iTime*0.15)-0.5, uv.y - tree_pos.y) , sin((floor(uv.x+iTime*0.15))*444.0)*0.3+1.0);\n\n\n    // colors: https://github.com/folke/tokyonight.nvim/blob/main/lua/tokyonight/colors/night.lua\n    vec3 col_bg = hex2col(0x1A1B26u);\n    vec3 col_bg_dark = hex2col(0X16161Eu);\n    // more colors = https://github.com/folke/tokyonight.nvim/blob/main/lua/tokyonight/colors/storm.lua\n    vec3 col_blue = hex2col(0x7AA2F7u); // platform\n    vec3 col_blue0 = hex2col(0x3D59A1u);\n    vec3 col_blue1 = hex2col(0x2AC3dEu);\n    vec3 col_fg = hex2col(0xC0CAF5u); // cursor?\n    vec3 col_fg_gutter = hex2col(0x3B4261u);\n    vec3 col_orange = hex2col(0xFF9E64u);\n    vec3 col_yellow = hex2col(0xE0AF68u); // moon\n    \n    \n    vec4 bg_buildings = buildings(uv, col_blue0, col_bg, col_orange);\n    // gradient for the background\n    vec3 col = mix(col_fg_gutter, col_bg, uv.y);\n    \n    col = mix(col, col_yellow, smoothstep(0.05, 0.0, moon_dist));\n    col = mix(col, bg_buildings.rgb, bg_buildings.a);\n    col = mix(col, col_bg_dark, smoothstep(0.01, 0.0, tree_dist));\n    col = mix(col, col_fg, smoothstep(0.005, 0.0, caleb_dist));// * max(floor(mod(iTime*(1.0/0.53)-1.0,2.0)),float(caleb_pos.y > -0.8))); // blinking cursor?\n    col = mix(col, col_blue, smoothstep(0.005, 0.0, platform_dist));\n    \n    //col = bg_buildings.rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}