{"ver":"0.1","info":{"id":"dlffW4","date":"1693543916","viewed":57,"name":"Ray trace wow","username":"H4mm3r","description":"Wow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.;\n//const vec3 sphere = vec3(-0.0,0., -0.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/2.;\n    float w = 0.0001;\n    float range = 5.*float(iFrame);\n    vec3 ppos = vec3(0.);\n    vec3 lpos = ppos;\n    float lStr = 1.;\n    float fov = 1.;\n    float accuracy = range/(30.*fov);\n    float fog = 2.*fov;\n    vec4 sphere = vec4(sin(t),0.5,cos(t), 0.5);\n    vec4 sphere2 = vec4(cos(t),-0.5,sin(t), 0.5);\n    vec3 r = vec3(0.,0.,0.);    \n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    vec3 cos=vec3(cos(r.x),cos(r.y),cos(r.z));\n    vec3 sin=vec3(sin(r.x),sin(r.y),sin(r.z));\n    vec3 grad = vec3(uv.x, uv.y, fov)/accuracy;\n    grad= rX(grad, sin.x, cos.x);\n    grad= rY(grad, sin.y, cos.y);\n    grad= rZ(grad, sin.z, cos.z);\n    //grad= rZ(grad, sin.z, cos.z, fov);\n\n    //vec3 grad=vec3(uv.x,uv.y,1.)/accuracy;\n    vec3 ray = ppos;\n    vec3 n;\n    float l;\n    float ri;\n    float cri;\n    float bounces = 10.;\n    for(float i=0.;i<range;++i)\n    {\n        if(bounces > 0.)\n        {\n        ray+=grad;\n        if(ray.x < 2. && ray.x > -2. && ray.y < 2. && ray.y > -2. && ray.z < 2.1 && ray.z > 1.9)\n        {\n            n = vec3(0., 0., -1.);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        if(ray.x < 2.1 && ray.x > 1.9 && ray.y < 2. && ray.y > -2. && ray.z < 2. && ray.z > -2.)\n        {\n            n = vec3(-1., 0., 0.);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        if(ray.x > -2.1 && ray.x < -1.9 && ray.y < 2. && ray.y > -2. && ray.z < 2. && ray.z > -2.)\n        {\n            n = vec3(1., 0., 0.);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        if(ray.x < 2. && ray.x > -2. && ray.y < 2.1 && ray.y > 1.9 && ray.z < 2. && ray.z > -2.)\n        {\n            n = vec3(0., -1., 0.);\n            col = vec3(0.8);\n            --bounces;\n        }\n        if(ray.x < 2. && ray.x > -2. && ray.y > -2.1 && ray.y < -1.9 && ray.z < 2. && ray.z > -2.)\n        {\n            n = vec3(0., 1., 0.);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        if(ray.x < 2. && ray.x > -2. && ray.y < 2. && ray.y > -2. && ray.z < -1.9 && ray.z > -2.1)\n        {\n            n = vec3(0., 0., 1.);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        \n        \n        if(disE3(sphere2.xyz,ray) < sphere.w)\n        {\n            n = sNormal(ray-sphere2.xyz);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        if(disE3(sphere.xyz,ray) < sphere.w)\n        {\n            n = sNormal(ray-sphere.xyz);\n            grad = -2.*(dot(grad, n))*n+grad;\n            --bounces;\n        }\n        }\n        else \n            break;\n        l=i;\n    }\n    col *= (1.+dot(n, sNormal(lpos-ray)))*lStr/2.;\n    col *=(range*2.-l*fog)/(range*2.);\n    //if(uv.y<=lineGrad*uv.x+w && uv.y >= lineGrad*uv.x-w)\n        //col = vec3(1.);\n    //if(floor(uv.y/uv.x)==uv.y/uv.x)\n        //col = vec3(1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float disE3( vec3 a, vec3 b )\n{\n    return sqrt(pow(a.x-b.x,2.)+pow(a.y-b.y,2.)+pow(a.z-b.z,2.));\n}\nfloat disE3P( vec3 a, vec3 b )\n{\n    return sqrt(pow(a.x-b.x,2.)+pow(a.y-b.y,2.)+pow(a.z-b.z,2.));\n}\nfloat disE2(vec2 a, vec2 b)\n{\n    return sqrt(pow(a.x-b.x,2.)+pow(a.y-b.y,2.));\n}\nvec2 dirTo(vec3 a, vec3 b)\n{\n    return vec2(atan((a.x-b.x)/(a.z-b.z)),atan((a.y-b.y)/(a.z-b.z)));\n}\nvec3 rX(vec3 a, float sinx, float cosx)\n{\n    return vec3(a.x, a.y*cosx-a.z*sinx,a.z*cosx+a.y*sinx);\n}\nvec3 rY(vec3 a, float siny, float cosy)\n{\n    return vec3(a.x*cosy+a.z*siny,a.y, a.z*cosy-a.x*siny);\n}\nvec3 rZ(vec3 a, float sinz, float cosz)\n{\n    return vec3(a.x*cosz-a.y*sinz,a.y*cosz+a.x*sinz,a.z);\n}\nvec3 sNormal(vec3 p)\n{\n    float l = sqrt(dot(p,p));\n    return p/l;\n}\nvec3 vecTo(vec3 a)\n{\n    float l = sqrt(dot(a, a));\n    return a/l;\n}\n","name":"Common","description":"","type":"common"}]}