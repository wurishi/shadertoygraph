{"ver":"0.1","info":{"id":"4dKcRG","date":"1523028547","viewed":288,"name":"Eye Animation test","username":"twitchingace","description":"An attempt to mimic the sort of facial animation seen in Wind Waker. Keyframed blinking + pupil dilation.\n\nFor now I'm way too lazy to have the eyes properly focus, so Lonk is forever looking in the distance.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["eyes","eye","animation","face","windwaker","loz","eyebrow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tAn attempt to mimic the animation of Link's expressions in Wind Waker.\n\tThe whole thing is reasonably simple, but this code is an absolute mess.\n\tIt's mostly just a few keyframes (drawn via bezier curves and intersecting parabolas mostly),\n\t\tbasic lerp'd stuff.\n\n\tAs per usual, you're free to use this work in whatever you want, but I'd appreciate if\n\t\tyou credited me (my Shadertoy name and a link to this work is fine).\n**/\n\n/** TODO: \n\tMaybe add in more eyebrow shapes so we can actually tween\n\tAntialiasing would probably be nice\n\tAdd in the original colour gradient\n\tExtra, non-blink related, eyelid shapes\t\n**/\n\n// Shape map:\n// 0: standard eye\n// 1-3: blink stages\n\nfloat blinkStageDuration = 1./7.;\nfloat blinkDuration = .45;\nvec2 lPupilCenter = vec2(.23, .19);\nvec2 lEyeSize = vec2(0.09, 0.105);\n\nfloat rEyeOffset = 0.53;\nvec2 rPupilCenter = vec2(.76, .19);\nvec2 rEyeSize = vec2(0.09, 0.105);\n\nvec3 focusPoint;\nfloat pupilDilation = 1.0;\nvec3 skinColour = vec3(247.0, 219.0, 156.0)/255.;\n\n// Bezier drawing tech taken from https://www.shadertoy.com/view/MtS3Dy\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n\nbool paintScleras( in vec2 uv)\n{\n    vec2 tempUV = uv;\n    if (tempUV.x > 0.5) tempUV.x -= rEyeOffset;\n    float toSquare = tempUV.x * 1.8 - .42;\n    if ((tempUV.y >= .9 * toSquare*toSquare + .04) &&\n        (tempUV.y <= -1.0* toSquare*toSquare + .34))\n    {\n        return true;   \n    }\n\n \treturn false;  \n}\n\nbool paintPupil (in vec2 uv, in vec2 pupilCenter, in vec2 eyeSize)\n{\n\tvec2 dist = uv - pupilCenter - focusPoint.xy;\n\tvec2 part = vec2(dist.x/eyeSize.x / pupilDilation, dist.y/eyeSize.y / pupilDilation); // (x/a, y/b)\n\tfloat equation = part.x * part.x + part.y * part.y;\n\tif(equation < 1.0){ \n\t\treturn true;\n    }\n    \n    return false;\n}\n\nbool restrictPupil (in vec2 uv, in int shape1, in int shape2, in float tween){\n    vec2 tempUV = uv;\n    if (tempUV.x > 0.5) tempUV.x -= rEyeOffset;\n    float toSquare = tempUV.x * 1.8 - .42;\n    vec3 A,B,C,D;\n    if (shape1 == 0){\n        A.y = 0.9;\n        B.y = 0.04;\n        C.y = -1.0;\n        D.y = 0.34;\n    } else if (shape1 == 1){\n        A.y = .7;\n        B.y = 0.06;\n        C.y = -0.7;\n        D.y = 0.3;\n    } else if (shape1 == 2){\n        A.y = 0.5;\n        B.y = 0.1;\n        C.y = -0.4;\n        D.y = 0.24;\n    } else if (shape1 == 3){\n        A.y = 0.3;\n        B.y = 0.2;\n        C.y = -0.1;\n        D.y = 0.2;\n    }\n    \n    if (shape2 == 0){\n        A.z = 0.9;\n        B.z = 0.04;\n        C.z = -1.0;\n        D.z = 0.34;\n    } else if (shape2 == 1){\n        A.z = 0.7;\n        B.z = 0.06;\n        C.z = -0.7;\n        D.z = 0.3;\n    } else if (shape2 == 2){\n        A.z = 0.5;\n        B.z = 0.1;\n        C.z = -0.4;\n        D.z = 0.24;\n    } else if (shape2 == 3){\n        A.z = 0.3;\n        B.z = 0.2;\n        C.z = -0.1;\n        D.z = 0.2;\n    }\n    \n    A.x = mix(A.y, A.z, tween);\n    B.x = mix(B.y, B.z, tween);\n    C.x = mix(C.y, C.z, tween);\n    D.x = mix(D.y, D.z, tween);\n    \n    if ((tempUV.y <= A.x * toSquare*toSquare + B.x) ||\n            (tempUV.y >= C.x * toSquare*toSquare + D.x))\n    {\n    \treturn true;   \n    }\n    return false;\n}\n\nbool paintEyebrow (in vec2 uv, bool isRightBrow, int shape1, int shape2, float tween){\n    vec2 A1, A1Start, A1End, B1, B1Start, B1End, C1, C1Start, C1End;\n    vec2 A2, A2Start, A2End, B2, B2Start, B2End, C2, C2Start, C2End;\n    // Map the shape of the initial eyebrow to the three points\n    // defining the associated bezier curve\n    if (shape1 == 0){\n\t\tA1Start = vec2(0.44, 0.35);\n    \tB1Start = vec2(0.17, 0.52);\n    \tC1Start = vec2(0.03, 0.41);\n        \n        A2Start = vec2(0.44, 0.35);\n    \tB2Start = vec2(0.14, 0.61);\n    \tC2Start = vec2(0.03, 0.41);\n    }\n    \n    if (shape2 == 0){\n\t\tA1End = vec2(0.44, 0.35);\n    \tB1End = vec2(0.17, 0.52);\n    \tC1End = vec2(0.03, 0.41);\n        \n        A2End = vec2(0.44, 0.35);\n    \tB2End = vec2(0.14, 0.61);\n    \tC2End = vec2(0.03, 0.41);\n    }\n    \n    if (isRightBrow){\n        A1Start.x = 1. - A1Start.x;\n        B1Start.x = 1. - B1Start.x;\n        C1Start.x = 1. - C1Start.x;\n        A2Start.x = 1. - A2Start.x;\n        B2Start.x = 1. - B2Start.x;\n        C2Start.x = 1. - C2Start.x;\n        \n        A1End.x = 1. - A1End.x;\n        B1End.x = 1. - B1End.x;\n        C1End.x = 1. - C1End.x;\n        A2End.x = 1. - A2End.x;\n        B2End.x = 1. - B2End.x;\n        C2End.x = 1. - C2End.x;\n    }\n    \n    // Lerp between the expression we started in and the one we're going to\n    A1 = mix(A1Start, A1End, tween);\n    B1 = mix(B1Start, B1End, tween);\n    C1 = mix(C1Start, C1End, tween);\n    float d = approx_distance(uv, A1, B1, C1);\n    if (d < 0.0215)\n    {\n    \treturn true;\n    }\n    \n     // Lerp between the expression we started in and the one we're going to\n    A2 = mix(A2Start, A2End, tween);\n    B2 = mix(B2Start, B2End, tween);\n    C2 = mix(C2Start, C2End, tween);\n    d = approx_distance(uv, A2, B2, C2);\n    if (d < 0.0255)\n    {\n    \treturn true;\n    }\n    \n    return false;\n}\n\nbool paintEyelids (in vec2 uv, bool isRightLid, int shape1, int shape2, float tween){\n    \n    vec2 A1, A1Start, A1End, B1, B1Start, B1End, C1, C1Start, C1End;\n    // Map the shape of the initial eye to the three points\n    // defining the associated bezier curve\n    if (shape1 == 0){\n\t\tA1Start = vec2(0.01, 0.19);\n    \tB1Start = vec2(0.26, 0.5);\n    \tC1Start = vec2(0.47, 0.15);\n    } else if (shape1 == 1){\n   \t\tA1Start = vec2(0.01, 0.19);\n        B1Start = vec2(0.3,  0.44);\n    \tC1Start = vec2(0.47, 0.15);   \n    } else if (shape1 == 2){\n   \t\tA1Start = vec2(0.01, 0.19);\n        B1Start = vec2(0.30, 0.32);\n    \tC1Start = vec2(0.47, 0.15);   \n    } else if (shape1 == 3){\n   \t\tA1Start = vec2(0.01, 0.19);\n        B1Start = vec2(0.30, 0.23);\n    \tC1Start = vec2(0.47, 0.17);   \n    }\n    \n    if (shape2 == 0){\n\t\tA1End = vec2(0.01, 0.19);\n    \tB1End = vec2(0.26, 0.5);\n    \tC1End = vec2(0.47, 0.15);\n    } else if (shape2 == 1){\n   \t\tA1End = vec2(0.01, 0.19);\n        B1End = vec2(0.3,  0.44);\n    \tC1End = vec2(0.47, 0.15);   \n    } else if (shape2 == 2){\n   \t\tA1End = vec2(0.01, 0.19);\n        B1End = vec2(0.30, 0.32);\n    \tC1End = vec2(0.47, 0.15);   \n    } else if (shape2 == 3){\n   \t\tA1End = vec2(0.01, 0.19);\n        B1End = vec2(0.30, 0.23);\n    \tC1End = vec2(0.47, 0.17);   \n    } \n    \n    if (isRightLid){\n        A1Start.x = 1. - A1Start.x;\n        B1Start.x = 1. - B1Start.x;\n        C1Start.x = 1. - C1Start.x;\n        \n        A1End.x = 1. - A1End.x;\n        B1End.x = 1. - B1End.x;\n        C1End.x = 1. - C1End.x;\n    }\n    \n    // Lerp between the expression we started in and the one we're going to\n    A1 = mix(A1Start, A1End, tween);\n    B1 = mix(B1Start, B1End, tween);\n    C1 = mix(C1Start, C1End, tween);\n    float d = approx_distance(uv, A1, B1, C1);\n        if (d < 0.007 + 0.0025)\n        {\n            return true;\n        }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lEyeShapes = vec4(0);\n    vec4 rEyeShapes = vec4(0);\n    float lEyeTween = 0.;\n    float rEyeTween = 0.;\n    \n    // This doesn't *really* focus the eyes, but it makes them slide around together\n    // which I guess is close enough\n    focusPoint = vec3(sin(iTime * 1.4) * .08, cos(iTime * 0.6) * .07, 0.);\n    pupilDilation = abs(sin(iTime * 0.2 + 1.4)) * 0.5 + 0.7; \n    \n    // Blink every 4 seconds\n    if (int(floor(iTime)) % 4 == 0){\n        rEyeTween = fract(iTime);\n        lEyeTween = fract(iTime);\n        if (rEyeTween <= blinkDuration){\n            blinkStageDuration *= blinkDuration;\n            while (rEyeTween > blinkStageDuration){\n                rEyeTween -= blinkStageDuration;\n            }\n            rEyeTween /= blinkStageDuration;\n            if (fract(iTime) <= blinkStageDuration)\n            {\n                lEyeShapes.x = 0.;\n                lEyeShapes.y = 1.;\n                rEyeShapes.x = 0.;\n                rEyeShapes.y = 1.;\n            }\n            else if (fract(iTime) <= 2. * blinkStageDuration)\n            {\n                lEyeShapes.x = 1.;\n                lEyeShapes.y = 2.;\n                rEyeShapes.x = 1.;\n                rEyeShapes.y = 2.;\n            }\n            else if (fract(iTime) <= 3. * blinkStageDuration)\n            {\n                lEyeShapes.x = 2.;\n                lEyeShapes.y = 3.;\n                rEyeShapes.x = 2.;\n                rEyeShapes.y = 3.;\n            }\n            else if (fract(iTime) <= 4. * blinkStageDuration)\n            {\n                lEyeShapes.x = 3.;\n                lEyeShapes.y = 3.;\n                rEyeShapes.x = 3.;\n                rEyeShapes.y = 3.;\n            }\n            else if (fract(iTime) <= 5. * blinkStageDuration)\n            {\n                lEyeShapes.x = 3.;\n                lEyeShapes.y = 2.;\n                rEyeShapes.x = 3.;\n                rEyeShapes.y = 2.;\n            }\n            else if (fract(iTime) <= 6. * blinkStageDuration)\n            {\n                lEyeShapes.x = 2.;\n                lEyeShapes.y = 1.;\n                rEyeShapes.x = 2.;\n                rEyeShapes.y = 1.;\n            }\n            else {\n                lEyeShapes.x = 1.;\n                lEyeShapes.y = 0.;\n                rEyeShapes.x = 1.;\n                rEyeShapes.y = 0.;\n            }\n        }\n    }\n    \n    //lEyeShapes.xy = vec2(3., 3.);\n    //rEyeShapes.xy = vec2(3., 3.);\n    //rEyeTween = 0.;\n    //lEyeTween = 0.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Initial colour\n    vec3 pixelColour = skinColour;\n\n    // Add in the full iris shape in flat white\n    if (paintScleras(uv))\n    {\n    \tpixelColour = vec3(1.0);   \n    }\n    \n    // Add in full pupil\n    // TODO: bring in the gradient from the original game\n    if (paintPupil(uv, lPupilCenter, lEyeSize) ||\n        paintPupil(uv, rPupilCenter, rEyeSize)){\n    \tpixelColour = vec3(0.0);\n    }\n    \n    // Mask the iris and pupil to create the proper shape of the eye\n    if ((uv.x < 0.5 && restrictPupil(uv, int(lEyeShapes.x), int(lEyeShapes.y), lEyeTween)) ||\n        (uv.x > 0.5 && restrictPupil(uv, int(rEyeShapes.x), int(rEyeShapes.y), rEyeTween)))\n    {\n     \tpixelColour = skinColour;   \n    }\n    \n    // Paint the eyelids on\n    if (paintEyelids(uv, false, int(lEyeShapes.x), int(lEyeShapes.y), lEyeTween) ||\n        paintEyelids(uv, true,  int(rEyeShapes.x), int(rEyeShapes.y), rEyeTween)){\n        pixelColour = vec3(0.0);\n    }\n    \n    // TODO: Maybe actually add in extra shapes so we can tween for real sometime\n    if (paintEyebrow(uv, false, int(lEyeShapes.z), int(lEyeShapes.w), 0.) ||\n        paintEyebrow(uv, true, int(lEyeShapes.z), int(lEyeShapes.w), 0.)){\n\t\tpixelColour = vec3(0.0);\n    }\n \n\n    fragColor = vec4(pixelColour, 1.0);\n}","name":"Image","description":"","type":"image"}]}