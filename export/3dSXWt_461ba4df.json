{"ver":"0.1","info":{"id":"3dSXWt","date":"1555224063","viewed":773,"name":"Starfield sim v2.0","username":"alexxxor","description":"Everyone's favourite windows 3.1 screensaver with a bit of polish","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// divisions of grid\nconst float repeats = 30.;\n\n// number of layers\nconst float layers = 21.;\n\n// star colours\nconst vec3 blue = vec3(51.,64.,195.)/255.;\nconst vec3 cyan = vec3(117.,250.,254.)/255.;\nconst vec3 white = vec3(255.,255.,255.)/255.;\nconst vec3 yellow = vec3(251.,245.,44.)/255.;\nconst vec3 red = vec3(247,2.,20.)/255.;\n\n// spectrum function\nvec3 spectrum(vec2 pos){\n    pos.x *= 4.;\n    vec3 outCol = vec3(0);\n    if( pos.x > 0.){\n        outCol = mix(blue, cyan, fract(pos.x));\n    }\n    if( pos.x > 1.){\n        outCol = mix(cyan, white, fract(pos.x));\n    }\n    if( pos.x > 2.){\n        outCol = mix(white, yellow, fract(pos.x));\n    }\n    if( pos.x > 3.){\n        outCol = mix(yellow, red, fract(pos.x));\n    }\n    \n    return 1.-(pos.y * (1.-outCol));\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p+= dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22 (vec2 p){\n\tfloat n = N21(p);\n    return vec2 (n, N21(p+n));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = N21(i);\n    float b = N21(i + vec2(1.0, 0.0));\n    float c = N21(i + vec2(0.0, 1.0));\n    float d = N21(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat perlin2(vec2 uv, int octaves, float pscale){\n    float col = 1.;\n    float initScale = 4.;  \n    for ( int l; l < octaves; l++){\n        float val = noise(uv*initScale);\n        if (col <= 0.01){\n            col = 0.;\n            break;\n        }\n        val -= 0.01;\n        val *= 0.5;\n        col *= val;\n        initScale *= pscale;\n    }\n \treturn col;\n}\n\nvec3 stars(vec2 uv, float offset){\n    \n    float timeScale = -(iTime + offset) / layers;\n    \n    float trans = fract(timeScale);\n    \n    float newRnd = floor(timeScale);\n    \n    vec3 col = vec3(0.);\n   \n    \n    // translate uv then scale for center\n    uv -= vec2(0.5);\n    uv = scale( vec2(trans) ) * uv;\n    uv += vec2(0.5);\n    \n    // create square aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // add nebula colours\n    float colR = N21(vec2(offset+newRnd));\n    float colB = N21(vec2(offset+newRnd*123.));\n    \n    // generate perlin noise nebula on every third layer\n    if (mod(offset,3.) == 0.){\n    \tfloat perl = perlin2(uv+offset+newRnd,3,2.);\n    \tcol += vec3(perl*colR,perl*0.1,perl*colB);\n    }\n    \n    // create boxes\n    uv *= repeats;\n    \n    // get position\n    vec2 ipos = floor(uv);\n    \n    // return uv as 0 to 1\n    uv = fract(uv);\n    \n    // calculate random xy and size\n    vec2 rndXY = N22(newRnd + ipos*(offset+1.))*0.9+0.05;\n    float rndSize = N21(ipos)*100.+200.;\n    \n    \n    vec2 j = (rndXY - uv)*rndSize;\n    float sparkle = 1./dot(j,j);\n    \n    col += spectrum(fract(rndXY*newRnd*ipos)) * vec3(sparkle);\n    \n    \n\t// visualize layers\n    /*if ((uv.x > 9. || uv.y > 0.99) && ipos.y == 8.){\n        col += vec3(1.,0.,0.)*smoothstep(1.,0.5,trans);\n    }\n    if (mod(offset,3.) == 0.){\n    \tif (uv.x > 0.99 || uv.y > 0.99){\n        \tcol += vec3(1.,0.,0.)*smoothstep(0.2,0.1,trans);\n    \t}\n    }*/\n    \n   \tcol *= smoothstep(1.,0.8,trans);\t\n    col *= smoothstep(0.,0.1,trans);\n    return col;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n\t\n    for (float i = 0.; i < layers; i++ ){\n    \tcol += stars(uv, i);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}