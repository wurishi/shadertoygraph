{"ver":"0.1","info":{"id":"wlsBRX","date":"1597355377","viewed":314,"name":"Raymarching Pebbles","username":"athibaul","description":"Just raymarching a scene with pebbles, for fun and for learning about microfacet-based BRDFs.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture","heightmap","stone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just a little raymarching exercise\n// Main idea stolen from Shane\n// https://www.shadertoy.com/view/ldtGWj\n\n\nfloat height(vec3 point)\n{\n    return texture(iChannel0, point.xy).r;\n}\n\nfloat height2(vec3 point)\n{\n    return texture(iChannel0, point.xy).r + 0.08*texture(iChannel1, point.xy).r;\n}\n\nfloat map(vec3 point)\n{\n    // Approx distance from the modified plane\n    return 1. - point.z - 0.1*height2(point);\n}\n\nfloat curvature(vec3 pos, float dist)\n{\n    // Approximate curvature of the heightmap, for AO\n    vec2 e = vec2(dist, -dist);\n    return (\n        height(pos + e.xyy)\n        + height(pos + e.yyx)\n        + height(pos + e.yxy)\n        + height(pos + e.xxx)\n        - 4.*height(pos)\n        );\n}\n\nfloat calculateAO(vec3 pos)\n{\n    return clamp(1. //- pow(1.-height(pos), 3.)\n        - curvature(pos, 0.003)*8.\n        - curvature(pos, 0.02)*.7\n        - curvature(pos, 0.1)*.3,\n                 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat phongSpecular(in vec3 l, in vec3 normal, in vec3 v, float ap, float f0)\n{\n    // Phong specular BRDF\n    // Formulae from \n    // https://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\n    \n    vec3 h = normalize(l+v); // Half-vector\n    float dp = (ap+2.)/(2.*3.1416)*pow(dot(normal, h), ap); // microfacet distribution function\n    float gct = 1./dot(l,h); // Approximate Cook-Torrance geometry function\n\t// Schlick approximation of Fresnel reflectance\n    float fresnel = f0 + (1.-f0)*pow(1.-dot(l,h),5.);\n    \n    return dp*gct*fresnel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 in y, wider in x)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n  \tuv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float theta = cos(iTime*0.2);\n    // Ray direction\n    vec3 ray = normalize(vec3(uv.x, uv.y, 3.0));\n    ray.xy = mat2(cos(theta), sin(theta), -sin(theta), cos(theta)) * ray.xy;\n    \n    // Camera position\n    vec3 cam = vec3(iTime*0.1, 0.2*cos(iTime*0.5), 0.);\n    //vec3 cam = vec3(0.);\n    \n    // Raymarch to the surface of the heightMap\n    float d, t=0.;\n    for(int j=0; j<32; j++){\n        d = map(cam + t*ray);\n        if(d < 0.001) break; // Can't go any further\n        t += d*0.3;\n    }\n    vec3 sp = cam + t*ray;\n    vec3 normal = getNormal(sp);\n    vec3 diffuse = texture(iChannel1, sp.xy).rgb;\n    float ao = calculateAO(sp);\n    \n    // The light is near the camera\n    vec3 light = cam + 0.3*vec3(cos(iTime*3.), sin(iTime), -1.);\n    vec3 li = normalize(light - sp);\n    float ldist = length(light - sp);\n    diffuse *= dot(li, normal)/(ldist*ldist) * 2.5;\n    float specular = phongSpecular(-ray, normal, li, 60., 0.2);\n    \n    \n    \n    // Output to screen\n    //fragColor.rgb = (vec3(1)+normal)*.5;\n    //fragColor.rgb = diffuse;\n    //fragColor.rgb = vec3(ao) * diffuse;\n    //fragColor.rgb = vec3(specular);\n    \n    fragColor.rgb = vec3(ao) * (diffuse + 0.2*vec3(specular));\n    float lum = length(fragColor.rgb);\n    //fragColor.rgb = fragColor.rgb * (1.-exp(-lum))/lum * 1.4; // Custom tone mapping\n\t\n}","name":"Image","description":"","type":"image"}]}