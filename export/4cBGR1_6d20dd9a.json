{"ver":"0.1","info":{"id":"4cBGR1","date":"1703809659","viewed":58,"name":"penrose 3d","username":"DjinnKahn","description":"Penrose tiling grid traversal -- it's SLOOOOW, even after some pruning. But I love the resulting geometry. Use mouse to look around.\n\n(I haven't seen a 3-d penrose tiling like this before, so if you know of anything (shader or not), leave a comment!)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tiling","penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool isClockwise( vec2 a, vec2 b, vec2 c )\n{\n   return (b.x - a.x) * (c.y - a.y) < (b.y - a.y) * (c.x - a.x);\n}\nbool isIntersectionTimeValid( float t, float otherT )\n{\n   return otherT < 0. || t < otherT;\n}\nfloat intersectionTime( vec3 rayPos, vec3 rayDir, vec2 line0, vec2 line1 )\n{\n   vec2 k = vec2( line0.y - line1.y, line1.x - line0.x );\n   return dot( line0 - rayPos.xy, k) / dot(rayDir.xy, k);\n}\n\nconst int TILETYPE_FAT = 0;\nconst int TILETYPE_SKINNY = 1;\n\n// in triangle OAB, from which side did the ray come from?\n// this is important so that we don't attempt to intersect the ray with that side\nconst int RAYORIGIN_OTHER = 0;\nconst int RAYORIGIN_OA = 1;\nconst int RAYORIGIN_AB = 2;\nconst int RAYORIGIN_BO = 3;\n\nconst float PI = acos( 0. ) * 2.;\nconst float PHI = (sqrt( 5. ) + 1.) / 2.;\nconst vec2 O = vec2( 0., 0. );\nconst vec2 A = vec2( cos( 36. * PI / 180. ), sin( 36. * PI / 180. ) );\nconst vec2 B = vec2( A.x * 2., 0. );\nconst vec2 C = A / PHI;\nconst vec2 D = vec2( 1., 0. );\n\n// controls geometry *within* a penrose tile -- any value between 0 and 1 should work fine\nconst float INTRARHOMB_K0 = .8;\nconst float INTRARHOMB_K1 = .1;\nconst float INTRARHOMB_K2 = .95;\n\n//// these constants reveal the underlying penrose tiling better:\n//const float INTRARHOMB_K0 = .1;\n//const float INTRARHOMB_K1 = .9;\n//const float INTRARHOMB_K2 = .1;\n\nconst float LAYER_HEIGHT = 0.0004;\n\nbool hitsLineBeforeBoundaries( float lineHitTime, vec3 rayPos, vec3 rayDir, vec2 o, vec2 a, vec2 b, int rayOrigin )\n{\n   return lineHitTime > 0.\n      && (rayOrigin == RAYORIGIN_OA || isIntersectionTimeValid( lineHitTime, intersectionTime( rayPos, rayDir, o, a ) ))\n      && (rayOrigin == RAYORIGIN_AB || isIntersectionTimeValid( lineHitTime, intersectionTime( rayPos, rayDir, a, b ) ))\n      && (rayOrigin == RAYORIGIN_BO || isIntersectionTimeValid( lineHitTime, intersectionTime( rayPos, rayDir, b, o ) ));\n}\n\nfloat calcBoundaryHitTime( vec3 rayPos, vec3 rayDir, vec2 o, vec2 a, vec2 b, int rayOrigin )\n{\n   float ret = 1e20;\n   if ( rayOrigin != RAYORIGIN_OA ) { float t = intersectionTime( rayPos, rayDir, o, a ); if ( t > 0. ) ret = min( ret, t ); }\n   if ( rayOrigin != RAYORIGIN_AB ) { float t = intersectionTime( rayPos, rayDir, a, b ); if ( t > 0. ) ret = min( ret, t ); }\n   if ( rayOrigin != RAYORIGIN_BO ) { float t = intersectionTime( rayPos, rayDir, b, o ); if ( t > 0. ) ret = min( ret, t ); }\n   return ret;\n}\n\nstruct ShootRayParams\n{\n   vec3 pos;\n   vec3 dir;\n   int type;\n   int depth;\n   int innerness;\n   vec2 o, a, b;\n   int rayOrigin;\n};\n\nvec3 floorColor( float z )\n{\n    return sin( vec3( 0., 2., 4. ) + z * .6 ) * .4 + .6;\n}\n\nbool handleIntersection( vec3 p, int innerness, int prevInnerness, vec2 normal, inout vec3 color )\n{\n   //float prevGroundZ = groundZ;\n   float prevGroundZ = float( prevInnerness ) * LAYER_HEIGHT;\n   float groundZ = float( innerness ) * LAYER_HEIGHT;\n\n   bool hitSideWall = p.z < groundZ;\n   bool hitFloor = p.z < prevGroundZ;\n   if ( hitFloor )\n      color = floorColor( float( prevInnerness ) );\n   else if ( hitSideWall )\n      color = floorColor( float( prevInnerness ) - 1.5 ) + vec3( normalize( normal ).x * .3 );\n\n   bool keepGoing = !hitSideWall && !hitFloor;\n   return keepGoing;\n}\n\nbool canSkipThisTile( int maxInnerness, float minZ )\n{\n   float maxGroundZ = float( maxInnerness ) * LAYER_HEIGHT;\n   bool mightHitGround = minZ <= maxGroundZ;\n   return !mightHitGround;\n}\n\nbool shootRayWorker( ShootRayParams params, out ShootRayParams recurse0, out ShootRayParams recurse1, inout vec3 color )\n{\n   recurse0.depth = -1;\n   recurse1.depth = -1;\n   if ( params.depth == 0 )\n   {\n      //m_shootRayStartFunc( ray.p );\n\n      vec2 patternLine0 = params.type == TILETYPE_FAT ? mix( params.o, params.a, INTRARHOMB_K0 ) : mix( params.o, params.b, INTRARHOMB_K0 );\n      vec2 patternLine1 = params.type == TILETYPE_FAT ? mix( params.o, params.b, INTRARHOMB_K1 ) : mix( params.a, params.b, INTRARHOMB_K2 );\n      vec2 patternNormal = vec2( patternLine0.y - patternLine1.y, patternLine1.x - patternLine0.x );\n      bool q = dot( patternNormal, params.dir.xy ) > 0.;\n      if ( q )\n         patternNormal = -patternNormal;\n\n      float tPattern = intersectionTime( params.pos, params.dir, patternLine0, patternLine1 );\n\n      bool parity0 = q\n         == ((params.type == TILETYPE_FAT) == isClockwise( params.o, params.a, params.b ));\n\n      ////handle case where floor is hit *immediately*\n      //if ( params.rayOrigin == ORIGIN_OTHER )\n      //{\n      //   bool parity = isClockwise( patternLine0, patternLine1, params.pos.xy() ) == isClockwise( patternLine0, patternLine1, params.o );\n      //   bool keepGoing = m_shootRayPatternFunc( params.pos, params.innerness + (parity ? 0 : -1), params.innerness + (parity ? -1 : 0), vec2( 0, 0 ) );\n      //   if ( !keepGoing )\n      //      return false;\n      //}\n      if ( hitsLineBeforeBoundaries( tPattern, params.pos, params.dir, params.o, params.a, params.b, params.rayOrigin ) )\n         return handleIntersection( params.pos + params.dir * tPattern, params.innerness + (parity0 ? -1 : 0), params.innerness + (parity0 ? 0 : -1), patternNormal, color );\n\n      return true;\n   }\n\n   float boundaryHitTime = calcBoundaryHitTime( params.pos, params.dir, params.o, params.a, params.b, params.rayOrigin );\n   {\n      int maxInnerness = params.innerness + (params.depth + 1) / 2;\n      float minZ = min( params.pos.z, params.pos.z + params.dir.z * boundaryHitTime );\n      if ( canSkipThisTile( maxInnerness, minZ ) )\n         return true; // keep going, but skip my own descendents\n   }\n\n   vec2 c = mix( params.o, params.b, 1. / PHI );\n\n   // where is ray starting\n   bool oSide = isClockwise( params.a, c, params.pos.xy ) == isClockwise( params.a, c, params.o );\n\n   if ( params.type == TILETYPE_FAT && oSide )\n      recurse0 = ShootRayParams( params.pos, params.dir, TILETYPE_SKINNY, params.depth, params.innerness, params.o, c, params.a, params.rayOrigin == RAYORIGIN_OA ? RAYORIGIN_BO : params.rayOrigin == RAYORIGIN_BO ? RAYORIGIN_OA : params.rayOrigin );\n   if ( params.type == TILETYPE_FAT && !oSide )\n      recurse0 = ShootRayParams( params.pos, params.dir, TILETYPE_FAT, params.depth - 1, params.innerness + ((params.depth & 1) != 0 ? 1 : -1), params.b, c, params.a, params.rayOrigin == RAYORIGIN_BO ? RAYORIGIN_OA : params.rayOrigin == RAYORIGIN_AB ? RAYORIGIN_BO : params.rayOrigin );\n   if ( params.type == TILETYPE_SKINNY && oSide )\n      recurse0 = ShootRayParams( params.pos, params.dir, TILETYPE_FAT, params.depth - 1, params.innerness, params.a, c, params.o, params.rayOrigin == RAYORIGIN_OA ? RAYORIGIN_BO : params.rayOrigin == RAYORIGIN_BO ? RAYORIGIN_AB : params.rayOrigin );\n   if ( params.type == TILETYPE_SKINNY && !oSide )\n      recurse0 = ShootRayParams( params.pos, params.dir, TILETYPE_SKINNY, params.depth - 1, params.innerness, params.a, params.b, c, params.rayOrigin == RAYORIGIN_BO ? RAYORIGIN_AB : params.rayOrigin == RAYORIGIN_AB ? RAYORIGIN_OA : params.rayOrigin );\n\n   float tAC = intersectionTime( params.pos, params.dir, params.a, c );\n   bool crossAC = tAC > 0. && tAC < boundaryHitTime;\n   if ( crossAC )\n   {\n      vec3 newPos = params.pos + params.dir * tAC;\n\n      if ( params.type == TILETYPE_FAT && oSide )\n         recurse1 = ShootRayParams( newPos, params.dir, TILETYPE_FAT, params.depth - 1, params.innerness + ((params.depth & 1) != 0 ? 1 : -1), params.b, c, params.a, RAYORIGIN_AB );\n      if ( params.type == TILETYPE_FAT && !oSide )\n         recurse1 = ShootRayParams( newPos, params.dir, TILETYPE_SKINNY, params.depth, params.innerness, params.o, c, params.a, RAYORIGIN_AB );\n      if ( params.type == TILETYPE_SKINNY && oSide )\n         recurse1 = ShootRayParams( newPos, params.dir, TILETYPE_SKINNY, params.depth - 1, params.innerness, params.a, params.b, c, RAYORIGIN_BO );\n      if ( params.type == TILETYPE_SKINNY && !oSide )\n         recurse1 = ShootRayParams( newPos, params.dir, TILETYPE_FAT, params.depth - 1, params.innerness, params.a, c, params.o, RAYORIGIN_OA );\n   }\n   return true;\n}\n\nbool shootRay( ShootRayParams params, inout vec3 color )\n{\n   ShootRayParams stack[40];\n   stack[0] = params;\n   int stackSize = 1;\n\n   while ( stackSize > 0 )\n   {\n      ShootRayParams params = stack[--stackSize];\n      ShootRayParams recurse0;\n      ShootRayParams recurse1;\n      if ( !shootRayWorker( params, recurse0, recurse1, color ) )\n         return false;\n      if ( recurse1.depth >= 0 )\n         stack[stackSize++] = recurse1;\n      if ( recurse0.depth >= 0 )\n         stack[stackSize++] = recurse0;\n   }   \n   return true;\n}\n\nmat2 rot( float a ) { return mat2( cos(a), sin(a), -sin(a), cos(a) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy * 2. - 1.;\n    \n    float t = iTime;\n    vec3 eye = vec3( .7 + .06 * sin( t * .1 ), .3 + .06 * cos( t * .1 ), LAYER_HEIGHT * ( 50. + 10. * ( 1. + sin( t * .11 ) )) );\n    vec3 dir = vec3( uv.x, 4., uv.y );\n    \n    if ( iMouse.xy == vec2( 0. ) )\n    {\n        dir.yz *= rot( .8 - .4 * cos( t * .17 ) );\n        dir.xy *= rot( t * -.15 + 2.3 );\n    }\n    else\n    {    \n        dir.yz *= rot( .8 + -mouse.y * .4 );\n        dir.xy *= rot( mouse.x * .5 );\n    }\n    \n    vec3 color = vec3( .1 );\n    int depth = 16;\n    ShootRayParams params = ShootRayParams( eye, dir, TILETYPE_FAT, depth, 0, O, A, B, RAYORIGIN_OTHER );\n    shootRay( params, color );\n\n    // Output to screen\n    fragColor = vec4(vec3(color),1.0);\n}","name":"Image","description":"","type":"image"}]}