{"ver":"0.1","info":{"id":"4XfcWB","date":"1726595522","viewed":32,"name":"My second first shader","username":"pipboy3000","description":"My second first shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(in float t) {\n\n    vec3 a = vec3(0.0, 0.7843, 1.0);\n    vec3 b = vec3(0.608, -0.442, 0.388);\n    vec3 c = vec3(0.5176, 1.0, 0.9608);\n    vec3 d = vec3(0.9373, 0.0627, 0.0627);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nfloat sdHexagram(in vec2 p, in float r) {\n    const vec4 k = vec4(-0.5, 0.8660254038, 0.5773502692, 1.7320508076);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n    p -= vec2(clamp(p.x, r * k.z, r * k.w), r);\n    return length(p) * sign(p.y);\n}\n\nfloat sdPentagon(in vec2 p, in float r) {\n    const vec3 k = vec3(0.809016994, 0.587785252, 0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0 * min(dot(vec2(-k.x, k.y), p), 0.0) * vec2(-k.x, k.y);\n    p -= 2.0 * min(dot(vec2(k.x, k.y), p), 0.0) * vec2(k.x, k.y);\n    p -= vec2(clamp(p.x, -r * k.z, r * k.z), r);\n    return length(p) * sign(p.y);\n}\n\nfloat sdHexagon(in vec2 p, in float r) {\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m) {\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;  // m is between 2 and n\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat smin(float a, float b, float k) {\n    k *= 2.0;\n    float x = b - a;\n    return 0.5 * (a + b - sqrt(x * x + k * k));\n}\n\nmat2 rot2D(in float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat map(in vec3 p) {\n\n    vec3 rotatedP = p;\n    vec3 q = p;\n    q = fract(p) - 0.5;\n\n    rotatedP.xz *= rot2D(-iTime);\n    \n    // vec3 spherePos = vec3(0.0, 0.0, u_time);\n    // float sphere = sdSphere(spherePos , .5);\n\n    vec3 boxPos = vec3(0., 0., 0.);\n    float box = sdBox(q - boxPos, vec3(0.01, 0.46, .01));\n\n    float ground = p.y + 1.;\n\n    return box;\n\n    // return smin(box, sphere, 0.1);\n\n    // return sphere;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(iTime/5., iTime / 20., 0);\n    vec3 rayDirection = normalize(vec3(uv, 1));\n    rayDirection.xz *= rot2D(-iTime/10.);\n    rayDirection.xy *= rot2D(-iTime/10.);\n    float totalDistance = 0.;\n    vec3 col = vec3(0);\n\n    for(int i = 0; i < 80; i++) {\n\n        vec3 p = rayOrigin + rayDirection * totalDistance;\n\n        float d = map(p);\n\n        if(d < 0.05)\n            break;\n\n        totalDistance += d;\n\n        if(totalDistance > 500.)\n            break;\n    }\n\n    col = vec3(totalDistance * 0.08) * vec3(0.7,2,1.) * palette(iTime / 10.);\n    // col = palette(totalDistance / 10.);\n\n    vec3 inverted = vec3(1.) - col;\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}