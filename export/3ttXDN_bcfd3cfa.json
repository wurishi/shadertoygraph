{"ver":"0.1","info":{"id":"3ttXDN","date":"1580974236","viewed":249,"name":"path tracing & movable camera","username":"lqt0223","description":"for frame-rate, stop the shader playback and use move drag to move the camera","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["camera","tracing","path","movable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int DEPTH = 15;\nconst int SAMPLE = 20;\nconst float epsilon = 1e-4;\nconst float PI = 3.1415926;\n\nconst vec3 init_camera_pos = vec3(0,0,4);\nconst vec3 init_camera_dir = vec3(0,0,-1);\nconst vec3 init_light_dir = vec3(6.);\nconst float screen_dist = 4.;\n\nstruct Hit {\n  bool miss;\n  vec3 p;\n  vec3 normal;\n  float dist;\n  vec3 color;\n  int type; // 0 as default, 1 as lambertian, 2 as reflective, 3 as refractive\n};\n\nstruct Sphere {\n  vec3 c;\n  float r;\n  vec3 color;\n  int type;\n};\n\nconst Hit miss = Hit(true, vec3(0.),vec3(0.), 1000., vec3(0.), 0);\n\nvec2 rotate2d(vec2 st, vec2 o, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  mat2 t = mat2(c,-s,s,c);\n  return t * (st - o) + o;\n}\n\nfloat fray_sphere_sect(vec3 ro, vec3 rd, Sphere sp) {\n  vec3 oc = ro - sp.c;\n  float a = dot(rd, rd);\n  float b = 2.0 * dot(oc, rd);\n  float c = dot(oc, oc) - sp.r * sp.r;\n  float disc = b*b-4.*a*c;\n  if (disc > 0.) {\n    float t = (-b - sqrt(disc)) / (2. * a);\n    if (t > 0.) {\n      return t;\n    } else {\n      t = (-b + sqrt(disc)) / (2. * a);\n      if (t > 0.) {\n        return t;\n      } else {\n        return 10000.;\n      }\n    }\n  } else {\n    return 10000.;\n  }\n}\n\nHit ray_sphere_sect(vec3 ro, vec3 rd, Sphere sp) {\n  float t = fray_sphere_sect(ro,rd,sp);\n  if (t < 10000.) {\n    vec3 hp = ro + t * rd;\n    vec3 n = normalize(hp - sp.c);\n    return Hit(false, hp, n, t, sp.color, sp.type);\n  } else {\n    return miss;\n  }\n}\n\nHit ray_sphere4_sect(vec3 ro, vec3 rd, Sphere sp1, Sphere sp2, Sphere sp3, Sphere sp4) {\n  Hit result = miss;\n  vec3 oc;\n  int mini = -1;\n  float mint = 10000.0;\n\n  float t = fray_sphere_sect(ro,rd,sp1);\n  if (t<mint) {\n    mint=t;\n    mini=0;\n  }\n  t = fray_sphere_sect(ro,rd,sp2);\n  if (t<mint) {\n    mint=t;\n    mini=1;\n  }\n  t = fray_sphere_sect(ro,rd,sp3);\n  if (t<mint) {\n    mint=t;\n    mini=2;\n  }\n  t = fray_sphere_sect(ro,rd,sp4);\n  if (t<mint) {\n    mint=t;\n    mini=3;\n  }\n  if (mini==0){\n    return ray_sphere_sect(ro,rd,sp1);\n  } else if (mini==1) {\n    return ray_sphere_sect(ro,rd,sp2);\n  } else if (mini==2) {\n    return ray_sphere_sect(ro,rd,sp3);\n  } else if (mini==3) {\n    return ray_sphere_sect(ro,rd,sp4);\n  } else {\n    return miss;\n  }\n}\n\nfloat random1(float n){\n  return fract(sin(n) * 43758.5453123);\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nvec3 randomCosineWeightedHemispherePoint(vec3 rand, vec3 n) {\n  float r = rand.x * 0.5 + 0.5; // [-1..1) -> [0..1)\n  float angle = (rand.y + 1.0) * PI; // [-1..1] -> [0..2*PI)\n  float sr = sqrt(r);\n  vec2 p = vec2(sr * cos(angle), sr * sin(angle));\n  /*\n   * Unproject disk point up onto hemisphere:\n   * 1.0 == sqrt(x*x + y*y + z*z) -> z = sqrt(1.0 - x*x - y*y)\n   */\n  vec3 ph = vec3(p.xy, sqrt(1.0 - p*p));\n  /*\n   * Compute some arbitrary tangent space for orienting\n   * our hemisphere 'ph' around the normal. We use the camera's up vector\n   * to have some fix reference vector over the whole screen.\n   */\n  vec3 tangent = normalize(rand);\n  vec3 bitangent = cross(tangent, n);\n  tangent = cross(bitangent, n);\n  \n  /* Make our hemisphere orient around the normal. */\n  return tangent * ph.x + bitangent * ph.y + n * ph.z;\n}\n\nvec3 randomCustomWeightedHemispherePoint(vec3 rand, vec3 n) {\n  float r = rand.x * 0.5 + 0.5; // [-1..1) -> [0..1)\n  float angle = (rand.y + 1.0) * PI; // [-1..1] -> [0..2*PI)\n  float sr = pow(r, 6.);\n  vec2 p = vec2(sr * cos(angle), sr * sin(angle));\n  /*\n   * Unproject disk point up onto hemisphere:\n   * 1.0 == sqrt(x*x + y*y + z*z) -> z = sqrt(1.0 - x*x - y*y)\n   */\n  vec3 ph = vec3(p.xy, sqrt(1.0 - p*p));\n  /*\n   * Compute some arbitrary tangent space for orienting\n   * our hemisphere 'ph' around the normal. We use the camera's up vector\n   * to have some fix reference vector over the whole screen.\n   */\n  vec3 tangent = normalize(rand);\n  vec3 bitangent = cross(tangent, n);\n  tangent = cross(bitangent, n);\n  \n  /* Make our hemisphere orient around the normal. */\n  return tangent * ph.x + bitangent * ph.y + n * ph.z;\n}\n\nvec3 refr(vec3 ray, vec3 normal, float ri) {\n  float dt = dot(ray, normal);\n  float ni_over_nt;\n  vec3 n;\n  if (dt > 0.) {\n    n = -normal;\n    ni_over_nt = ri;\n  } else {\n    n = normal;\n    ni_over_nt = 1./ri;\n  }\n\n  float discriminant = 1. - ni_over_nt*ni_over_nt*(1. - dt*dt);\n  if (discriminant > 0.) {\n    return ri*(ray - n*dt)-n*sqrt(discriminant);\n  } else {\n    return reflect(ray, normal);\n  }\n}\n\nvoid ray_sphere4_sect_void(vec3 ro, vec3 rd, Sphere sp1, Sphere sp2, Sphere sp3, Sphere sp4, out vec3 color) {\n  vec3 ocolor = vec3(1);\n  Hit result;\n  for (int i = 0; i < DEPTH; i++) {\n    result = ray_sphere4_sect(ro, rd, sp1, sp2, sp3, sp4);\n    if (!result.miss) {\n      ro = result.p + 0.01 * result.normal;\n      // lambertian\n      if (result.type == 1) {\n        rd = randomCosineWeightedHemispherePoint(random3(result.p), result.normal);\n        ocolor *= result.color;\n      // reflective\n      } else if (result.type == 2) {\n        rd = reflect(rd, result.normal);\n        ocolor *= result.color;\n      // refractive\n      } else if (result.type == 3) {\n        rd = randomCustomWeightedHemispherePoint(random3(result.p),refr(rd, result.normal, 1.2));\n      }\n    } else {\n      break;\n    }\n  }\n\n  color = ocolor;\n}\n\nvoid trace_void(vec3 ro, vec3 rd, out vec3 color) {\n  Sphere sp1 = Sphere(vec3(0,0,0), 0.5, vec3(1.), 3);\n  Sphere sp2 = Sphere(vec3(-0.55,0,-1), 0.5, vec3(0.5,0.5,1.), 1);\n  Sphere sp3 = Sphere(vec3(0.55,0,-1), 0.5, vec3(0.5,1,0.5), 2);\n  Sphere sp4 = Sphere(vec3(0,-1000.51,-1), 1000., vec3(1,0.5,0.5), 1);\n  ray_sphere4_sect_void(ro, rd, sp1, sp2, sp3, sp4, color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st -= 0.5;\n  st.x *= iResolution.x / iResolution.y;\n  st.y = -st.y;\n\n  st.x *= 1.5;\n  st.y *= 1.5;\n\n  vec3 disp = vec3(iMouse.xy / iResolution.xy, 0.);\n  disp -= 0.5;\n  vec3 camera_pos = init_camera_pos;\n  vec3 camera_dir = init_camera_dir;\n  camera_dir.xz = rotate2d(camera_dir.xz, init_camera_pos.xz, -disp.x);\n  camera_dir.yz = rotate2d(camera_dir.yz, init_camera_pos.xz, -disp.y);\n\n  vec3 screen_orig = vec3(0,0,0);\n  camera_pos = screen_orig - screen_dist * camera_dir;\n\n  vec3 v = normalize(camera_dir);\n  vec3 up = vec3(0.,1.,0.);\n  vec3 r = normalize(cross(v, up));\n  vec3 u = normalize(cross(v, r));\n\n  mat4 basis = mat4(\n      r.x,r.y,r.z,0.,\n      u.x,u.y,u.z,0.,\n      v.x,v.y,v.z,0.,\n      0.,0.,0.,1.\n  );\n\n  mat4 translate = mat4(\n      1.,0.,0.,0.,\n      0.,1.,0.,0.,\n      0.,0.,1.,0.,\n      screen_orig.x,screen_orig.y,screen_orig.z,1.\n  );\n  mat4 view = translate * basis;\n  vec4 str = vec4(st, 0., 1.);\n  str = view * str;\n\n  vec3 result_color = vec3(0);\n\n  \n  for (int i = 0; i < SAMPLE; i++) {\n    vec3 rd = normalize(str.xyz + 0.01 * random3(vec3(float(i))) - camera_pos);\n    vec3 ro = camera_pos;\n    vec3 color;\n\n    trace_void(ro, rd, color);\n\tresult_color += color;\n  }\n  result_color /= float(SAMPLE);\n  \n  fragColor = vec4(result_color,1);\n}\n","name":"Image","description":"","type":"image"}]}