{"ver":"0.1","info":{"id":"sdd3W4","date":"1629904302","viewed":182,"name":"Growing trees","username":"kastorp","description":"another experiment on domain repetition\nhere another [url=https://www.shadertoy.com/view/Ndc3W7]example[/url] with more realistic trees","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","trees"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Growing Trees by kastorp\n\n//dean_the_coder  stuff\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nvec2 h22(vec2 v) {\n\tvec3 p = fract(v.xyx * vec3(.1031, .103, .0973));\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.xx + p.yz) * p.zy);\n}\n\nvec2 map(vec3 p);\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = (lp - p) / mxt;\n\tfor (float i = Z0; i < 2e2; i++) {\n\t\td = map(t * ld + p).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).x / h; }\n//\n\n//Blackle stuff\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(map(p).x - vec3(map(k[0]).x,map(k[1]).x,map(k[2]).x));\n}\n\n//Iq stuff\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    return vec2( tN, tF );\n}\n//Shane stuff\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Texture bump mapping. \nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(0.001, 0);  \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.    \n}\n\n//-------------------------------------------------\nvec2 plant(vec3 p,vec2 center) {\n    const float sh=.3; //shift\n    vec2 a =h22(center*1.1); \n    float\n     s =sin(a.y*20.+iTime/8.),\n     h = 5.5- s*s*s*s*3. +a.y*1.5, //height\n     v = .51 -.5*s,  //color\n     tk = max(+.05,+.85*smoothstep(.1,.4,v)* (1.-.1*fract(p.z*3.)-.1*fract(p.z*3.+.1))* smoothstep(h+.7,h-4.,p.z) *smoothstep(.1,0.2,p.z-3.7));  //thickness\n    vec3 s1= vec3(sin(a.x*25.),cos(a.x*25.),0)*sh; //bottom\n    vec3 s2= s1 + vec3(0,0,h); //top\n      \n    return vec2(sdCapsule(p- vec3(center, 0),s1,s2,tk),2.*v-v*v);\n}\n\n#define mmin(a,b) (a.x<b.x?a:b)\n\n\nvec2 edge(vec2 p) { //modified\n    return vec2((p.x < 0.) ? -1. : 1., (p.y < 0.) ? -1. : 1.);\n}\n\nvec2 map(vec3 p) {\n    vec2  d= vec2(p.z-3.7,0.);\n    vec2 center = floor(p.xy) + .5;\n    vec2 dir=edge(p.xy - center);\n    for(float i = -0.;i<2.;i++)for(float j = -0.;j<2.;j++)\n    {\n        vec2 pos = center + dir*vec2(i,j);    \n         //d = smin(d, plant(p,pos),0.2); \n         d = mmin(d, plant(p,pos)); \n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec2 uv = (fc-.5*R.xy)/R.y;\n    vec2 mouse = (iMouse.xy-0.5*R.xy)/R.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 ro = vec3(-25,0,10);    \n    float yrot = .45, zrot = iTime*.05;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-2.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(erot(cam,vec3(0,1,0),yrot),vec3(0,0,1),zrot);\n\n    vec3 p =ro;\n    bool hit = false;\n    vec2 d;\n    for (int i = 0; i < 100 && !hit; i++) {\n       d = map(p);\n        \n        //if inside a box, don't march after border\n        vec3 center = vec3(floor(p.xy) + .5,10.);\n        vec2 tb= boxIntersection(  p-center,  cam, vec3(.501,.501,10.) ) ;\n        if( tb.x<0. &&tb.y>0. && tb.y<d.x) d.x=tb.y;       \n        \n        hit = d.x*d.x < 1e-6;\n        p += d.x*cam;\n        if(distance(p,ro)>30.)break;\n    }\n    vec3 n = norm(p);\n    \n\n    vec3 lp=vec3(100, 200, 200), ld = normalize(lp - p);\n    vec3 col= mix(vec3(0.3,0.,0.),vec3(0.,.1,0.02), smoothstep(.1,.4,d.y)) ;\n    if(d.y<=0.){\n        n = doBumpMap( iChannel2, (p)*.25, n, 0.01);\n        col=min(vec3(0.5,0.8,0.0),tex3D( iChannel2, (p)*.25, n));\n    } else \n    {\n       n = doBumpMap( iChannel1, (p.zyx)*.25, n, 0.03*d.y);\n    }\n \n    \n    float ao = sat(mix(ao(p, n, .1), ao(p, n, .5), .7)),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.05 + .95 * shadow(p, lp)) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(cam, reflect(ld, n))), 10.) * .05;          \n    col*=(l1 + l2 * ao);\n    \n    col = mix(col,vec3(0.835,0.851,0.549),exp(min(0.,-5.+distance(ro,p)/5.))); //fog  \n    fragColor =  vec4(sqrt(col),0) ;\n    \n}\n","name":"Image","description":"","type":"image"}]}