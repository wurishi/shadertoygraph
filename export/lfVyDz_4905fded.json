{"ver":"0.1","info":{"id":"lfVyDz","date":"1731749256","viewed":36,"name":"SESSIONS 2024 Shader Jam final","username":"visy","description":"final form of the shader I made during Shader Jam at SESSIONS demoparty 2024","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["demoscene","shaderjam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate_x(float a) { \n    float sa = sin(a); float ca = cos(a); \n    return mat3(vec3(1., 0., 0.), vec3(0., ca, sa), vec3(0., -sa, ca)); \n}\nmat3 rotate_y(float a) { \n    float sa = sin(a); float ca = cos(a); \n    return mat3(vec3(ca, 0., sa), vec3(0., 1., 0.), vec3(-sa, 0., ca)); \n}\nmat3 rotate_z(float a) { \n    float sa = sin(a); float ca = cos(a); \n    return mat3(vec3(ca, sa, 0.), vec3(-sa, ca, 0.), vec3(0., 0., 1.)); \n}\n\n// SDF for rhombus-like shapes\nfloat sdf(vec3 pos, float size, float edge) {\n    pos = abs(pos);\n    pos *= rotate_y(pos.z * 0.1) * 0.8;\n    pos *= rotate_z(pos.y * 0.1) * 1.4 + cos(pos.z * 10.3) * 0.01;\n    pos *= rotate_x(pos.x);\n\n    pos = vec3(\n        pos.y + pos.z,\n        pos.x + pos.z,\n        pos.x + pos.y\n    );\n\n    pos -= clamp(pos, 0.0, size - edge);\n\n    return length(pos) - edge;\n}\n\n// Calculate normals for SDF\nvec3 calcNormal(vec3 p) {\n    float h = 1e-3;\n    return normalize(vec3(\n        sdf(p + vec3(h, 0, 0), 1.0, 0.2) - sdf(p - vec3(h, 0, 0), 1.0, 0.2),\n        sdf(p + vec3(0, h, 0), 1.0, 0.2) - sdf(p - vec3(0, h, 0), 1.0, 0.2),\n        sdf(p + vec3(0, 0, h), 1.0, 0.2) - sdf(p - vec3(0, 0, h), 1.0, 0.2)\n    ));\n}\n\n// Raymarching function\nfloat raymarch(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for (int i = 0; i < 20; i++) {\n        vec3 p = ro + rd * dist;\n        p = mod(p, 6.0) - cos(rd.z + 1.0) * 3.0;\n        float d = sdf(p, 3.0, 1.0);\n        if (d < 1e-3) return dist;\n        dist += d;\n        if (dist > 15.0) break;\n    }\n    return -1.0;\n}\n\n// Retrieve textures for overlays\nvec3 getTexture(vec2 uv, sampler2D tex) {\n    vec2 size = vec2(textureSize(tex, 0));\n    float ratio = size.x / size.y;\n    return texture(tex, vec2(uv.x, uv.y * ratio) - 0.5).rgb * 10.5;\n}\n\n// Main image function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = mod(iTime, 64.0);\n\n    // Camera setup\n    float z = t * 3.0;\n    vec3 ro = vec3(0.1 + cos(t * 3.5) * 0.5, sin(t * 3.5) * 0.5, z);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Raymarching\n    float result = raymarch(ro, rd);\n    if (result > 0.0) {\n        vec3 pos = ro + rd * result;\n        vec3 normal = calcNormal(pos);\n        vec3 lightDir = normalize(vec3(0.0, 1.0, -1.5 + cos(t * 0.5) * 2.0));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n\n        vec3 color = vec3(0.2 + result * cos(0.09 + mod(result, 1.0)) * 0.04,\n                          0.6 - result * 0.01,\n                          0.9 / cos(-result * 0.04)) * diffuse;\n\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}