{"ver":"0.1","info":{"id":"tslcz7","date":"1584478181","viewed":150,"name":"Torus Knot - Plane Intersection","username":"arifr123","description":"Try dragging the mouse.\nTry changing kp and kq.\nBased on my shader [url]https://www.shadertoy.com/view/wtcSW2[/url].","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["gradientdescent","torusknot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433\n\n#define sq(x) dot(x, x)\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\nvec2 perp(vec2 v)\n{\n    return (v * vec2(1, -1)).yx;\n}\n\nstruct TorusKnotParameters\n{\n    float kp;\n    float kq;\n    float r1;\n    float r2;\n    float r3;\n};\n\nvec3 torusKnot(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return sq(torusKnot(t, tkp) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nvec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)\n{\n    int sections = 1*int(max(tkp.kq,tkp.kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 1./(max(tkp.kq,tkp.kp)-0.75);\n    const int maxIterations = 900;//50\n    \n    float minDist;\n    float bestT;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        bool failed = false;\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotSqDistanceDerivative(t, p, tkp);\n            \n            if(abs(lerningRate*dt) < 0.003)break;\n            \n            t -= lerningRate*dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                failed = true;\n                break;\n            }\n        }\n        if(failed)continue;\n        \n        float sqDist = torusKnotSqDistance(t, p, tkp);\n        \n        if(sqDist <= sq(tkp.r3))\n        {\n            return vec3(t, sqDist, 1.);\n        }\n    }\n    \n    return vec3(0.);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    vec2 uv = 5.*fragCoord/iResolution.xy;\n    ivec2 kpkq = ivec2(uv) + 1;\n    uv = mod(uv, 1.);\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t*/\n    \n    \n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n\n    vec2 angles = /*false &&*/ iMouse.z > 0.5 ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : 1.5*iTime*vec2(0.3, 1);//PI*vec2(0.25, 0.25)*(sic(iTime) + vec2(0, 1))\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, sic1.y);\n    vec3 r = vec3(perp(sic0), 0);\n    vec3 u = cross(f, r);\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    float kp = 3., kq = 4., r1 = 0.25, r2 = 0.125, r3 = 0.05;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    /*\n    ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    kpkq /= gcd(kpkq);\n\t*/\n    /*\n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n    */\n    \n    TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 p = uv.x*r + uv.y*f;\n    \n    vec3 res = torusKnotSqDistanceMinimumInside(p, tkp);\n    \n    vec3 col = vec3(0);\n    \n    \n    if(res[2] > 0.5)\n    {\n        uv = fragCoord/iResolution.xy - 0.5;//[-0.5, 0.5] \n        p = (uv.x*r + uv.y*f);//square of size 1x1x1\n        \n        col = 2.*p + 0.5;\n        \n        float len = length(col);\n        col = normalize(col);\n        \n        col *= smoothstep(tkp.r3, tkp.r3 - 1./iResolution.y, sqrt(res[1]));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}