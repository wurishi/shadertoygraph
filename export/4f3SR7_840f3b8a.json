{"ver":"0.1","info":{"id":"4f3SR7","date":"1713707846","viewed":81,"name":"Pack rgba into single float","username":"mrboggieman","description":"Useful for cramming rgba from vec4 (8-bit precision per channel) into a single 32-bit float to minimize channel usage in buffers (32-bit per-channel)","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["pack","util"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int DELAY = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // change the channel to output based on time\n    int channel = int(iTime / float(DELAY)) % 4;\n    \n    vec4 textures = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // just sample and blend the next image in the channels\n    vec4 rgba = unpack_rgba(textures[channel]);    \n    vec4 next_rgba = unpack_rgba(textures[(channel + 1) % 4]);\n\n    vec4 result = mix(rgba, next_rgba, fract(iTime / float(DELAY)));\n    \n    // we should see no loss of precision in the output\n    fragColor = vec4(result.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // cram four full-rgb textures into this single buffer\n    float a = pack_rgba(texture(iChannel0, uv));\n    float b = pack_rgba(texture(iChannel1, uv));\n    float c = pack_rgba(texture(iChannel2, uv));\n    float d = pack_rgba(texture(iChannel3, uv));\n\n    fragColor = vec4(a, b, c, d);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// some methods to package colours from a vec4 (0-1) into a single 32-bit float\nfloat pack_rgba(in vec4 rgba) {\n    lowp int red = int(rgba.r * 255.0);\n    lowp int green = int(rgba.g * 255.0);\n    lowp int blue = int(rgba.b * 255.0);\n    lowp int alpha = int(rgba.a * 255.0);\n\n    return intBitsToFloat((red << 24) | (green << 16) | (blue << 8) | alpha);\n}\n\nvec4 unpack_rgba(in float col) {\n    highp int val = floatBitsToInt(col);\n\n    return vec4(\n        float((val >> 24) & 255) / 255.0,\n        float((val >> 16) & 255) / 255.0,\n        float((val >> 8) & 255) / 255.0,\n        float(val & 255) / 255.0\n    );\n}\n","name":"Common","description":"","type":"common"}]}