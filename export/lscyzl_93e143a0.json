{"ver":"0.1","info":{"id":"lscyzl","date":"1519798664","viewed":302,"name":"Worley Noise 2D","username":"Aethersong","description":"Worley Noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References\n// Worley Noise 2x2 Stefan Gustavson\n// https://thebookofshaders.com/12/\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 Permute( vec4 x )\n{\n return mod( ( 34.0 * x + 1.0 ) * x, 289.0 );   \n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 Cellular2x2( vec2 P )\n{\n\t#define K 0.142857142857 // 1/7\n\t#define K2 0.0714285714285 // K/2\n\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n    \n\tvec2 Pi = mod( floor( P ), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\n\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\n\tvec4 p = Permute( Pi.x + vec4(0.0, 1.0, 0.0, 1.0 ) );\n\tp = Permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n    \n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n    \n\t// Sort out the two smallest distances\n#if 0\n\t// Cheat and pick only F1\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated, F2 not computed\n#else\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n#endif\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\n\nfloat Worley2(vec2 n,float s)\n{\n    n /= s;\n    float dis = 1.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 p = floor(n)+vec2(x,y);\n            p = r(p)+vec2(x,y)-fract(n);\n            dis = min(dis, dot(p, p));\n            \n        }\n    }\n    return 1.0 - sqrt(dis);\n\t\n}\n\nfloat Worley(vec2 uv)\n{\n    // User Noise Adjust\n    return 1.0 - Cellular2x2(uv).x;\n    //return smoothstep(1.0, 0.0, Cellular2x2(uv).x);\n}\n\nfloat WorleyFBM(vec2 uv)\n{\n\tfloat amplitude = 0.5;\n    float gain = 0.5;\n    float lacunarity = 2.0;\n    \n    float value = 0.0;\n    \n    const int STEPS = 4;\n    for(int i = 0; i < STEPS; i++)\n    {\n     \tvalue += Worley2(uv, 2.0) * amplitude;\n        amplitude *= gain;\n        uv *= lacunarity;\n    }\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Calculate Noise\n    float tileCount = 16.0;\n    float n = WorleyFBM(uv * vec2(aspectRatio, 1.0) * tileCount + vec2(iTime, 0.0));  \n    \n    // Output to screen\n    fragColor = vec4(n, n, n, 1.0);\n}","name":"Image","description":"","type":"image"}]}