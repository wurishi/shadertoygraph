{"ver":"0.1","info":{"id":"XXjBDG","date":"1729882490","viewed":59,"name":"Evolving Topo Map Pseudo-Perlin","username":"h4znk0","description":"Originally based on \"isovalues 3\" by FabriceNeyret2 in 2017\n\nI've adapted the code to be more readable for my own educational purposes, and removed color for simplicity.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","contour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise3(vec3 x) {\n    // Split input into integer and fractional parts\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    // Smooth the fractional part to ensure continuity at borders\n    f = f * f * (3.0 - 2.0 * f);  // Alternative: use smoothstep()\n\n    // Hash function to generate pseudo-random values\n    #define hash3(p) fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453)\n\n\n    // Trilinear interpolation of the noise value\n    float n000 = hash3(p + vec3(0, 0, 0));\n    float n100 = hash3(p + vec3(1, 0, 0));\n    float n010 = hash3(p + vec3(0, 1, 0));\n    float n110 = hash3(p + vec3(1, 1, 0));\n    float n001 = hash3(p + vec3(0, 0, 1));\n    float n101 = hash3(p + vec3(1, 0, 1));\n    float n011 = hash3(p + vec3(0, 1, 1));\n    float n111 = hash3(p + vec3(1, 1, 1));\n\n    // Interpolate along the x-axis\n    float nx00 = mix(n000, n100, f.x);\n    float nx10 = mix(n010, n110, f.x);\n    float nx01 = mix(n001, n101, f.x);\n    float nx11 = mix(n011, n111, f.x);\n\n    // Interpolate along the y-axis\n    float nxy0 = mix(nx00, nx10, f.y);\n    float nxy1 = mix(nx01, nx11, f.y);\n\n    // Final interpolation along the z-axis\n    return mix(nxy0, nxy1, f.z);\n}\n\n// Macro to improve the noise function using a second shifted sample\n#define noise(x) (noise3(x) + noise3(x + 11.5)) / 2.0  // Pseudo-Perlin noise\n\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{ \n    vec2 R = iResolution.xy;\n    \n    \n    float n = noise(vec3(U * 8. / R.y, .02 * iTime));\n    \n    float v = sin(6.28 * 10. * n);\n    float t = iTime;\n    \n    v = smoothstep(1.,0., .5*abs(v)/fwidth(v));\n    \n    // Calculate the first term using the exponential decay and texture sampling\n    vec4 textureSample = exp(-33.0 / R.y) * texture(iChannel0, (U + vec2(1, sin(t))) / R);\n\n    // Compute the sine wave modulation\n    vec4 sineWave = 0.5 + 0.5 * sin(12.0 * n + vec4(0, 2.1, -2.1, 0));\n    \n    // Use 'mix' to blend the two terms with a weight of 'v'\n    O = mix(textureSample, vec4(1.0, 1.0, 1.0, 0), v);\n\n \n}","name":"Image","description":"","type":"image"}]}