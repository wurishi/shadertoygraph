{"ver":"0.1","info":{"id":"msfGzr","date":"1668655990","viewed":109,"name":"One Dice","username":"mmggww","description":"One Dice","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////\n//\n//\n//Reference: \n//     https://iquilezles.org/articles/distfunctions/\n//     https://www.shadertoy.com/view/Xds3zN\n//     https://www.youtube.com/watch?v=hUaYxqkrfjA\n//     https://www.youtube.com/watch?v=i12pFwXlOGw\n//\n/////////////////////////////////////////////////////\n\n#define MaxStep 256\n#define MaxDist 250.0\n#define FOV 1.0\n#define AA\n\n/////////////////////////////////////////////////////\nvec2 map(vec3 p)\n{\n    float dist;\n    float id;\n    vec2 rst = vec2(MaxDist, 0.0);\n    \n    //////////Plane\n    dist = sdPlane(-3.0, p);    \n    id = 1.0;\n    rst = vec2(dist, id);\n    \n    //////////Dice\n    vec3 d = vec3(sin(iTime), cos(iTime), sin(iTime));\n    d = normalize(d);\n    p = rot(d, iTime) * p;\n    rst = unionObj(rst, mapDice(p));\n        \n    return rst;\n}\n\n//Calculate Normal\n//Reference:\n//        https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 raymarch(vec3 pos, vec3 dir)\n{\n    vec2 hit, obj;\n    for(int i = 0; i < MaxStep; i++)\n    {\n        vec3 p = pos + dir * obj.x;\n        hit = map(p);\n        obj.x += hit.x;\n        obj.y = hit.y;\n        if(abs(hit.x) < EPSILON || obj.x > MaxDist)\n            break;\n    }\n    return obj;\n}\n\nvec3 getMaterial(vec3 p, float id)\n{\n    vec3 m;\n    switch(int(id))\n    {\n        case 1: \n            m = vec3(0.2 + 0.4 * mod(floor(p.x) + floor(p.z), 2.0));\n            break;\n        case 2: \n            m = vec3(1.0);\n            break;\n        case 3:\n            m = vec3(1.0, 0.1, 0.1);\n            break;\n        case 4:\n            m = vec3(0.04);\n            break;\n    }\n    return m;\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 getLight(vec3 p, vec3 view, vec3 lightPos, vec3 mat, vec3 lightCol, vec3 env)\n{\n    vec3 nor = getNormal(p);\n    vec3 light = normalize(lightPos - p);\n    vec3 rf = reflect(-light, nor);\n    vec3 finalCol;\n    \n    //diffuse\n    vec3 diff = clamp(dot(nor, light),0.0,1.0) * mat * lightCol * 0.8 + 0.2 * mat;\n    //specular\n    vec3 spec = lightCol * vec3(0.5) * pow(clamp(dot(rf, view), 0.0, 1.0), 20.0);\n    //env\n    vec3 ambient = mat * 0.05;\n    //AO\n    float ao = calcAO(p, nor);\n    //shadows\n    float d = raymarch(p + nor * 0.05, normalize(lightPos)).x;    \n    float shadow = 1.0;\n    if(d < length(p - lightPos))\n        shadow = 0.4;\n\n    finalCol = diff * shadow + (spec + ambient) * ao * shadow;\n    return  finalCol;\n}\n\nmat3 getCamera(vec3 pos, vec3 lookAt)\n{\n    vec3 forward = normalize(lookAt - pos);\n    vec3 right = normalize(cross(vec3(0,1,0), forward));\n    vec3 up = normalize(cross(forward, right));\n    return mat3(right, up, forward);\n}\n\nvec2 getUV(vec2 fragCoord)\n{\n    return (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n}\n\nvec3 render(vec3 camPos, mat3 camMat, vec3 lightPos, vec3 lightCol, vec2 fragCoord)\n{\n    vec2 uv = getUV(fragCoord);\n    vec3 camDir = camMat * normalize(vec3(uv, FOV));\n\n    vec3 col;\n    vec2 obj = raymarch(camPos, camDir);\n    vec3 bg = vec3(0.5, 0.8, 0.9);\n    if(obj.x < MaxDist)\n    {\n        vec3 p = camPos + camDir * obj.x;\n        vec3 mat = getMaterial(p, obj.y);\n        \n        vec3 c = getLight(p, -camDir, lightPos, mat, lightCol, bg);        \n        col += c;\n        //fog\n        col = mix(col, bg, 1. - exp(-0.0008 * obj.x * obj.x));\n    }\n    else\n    {\n        col += bg - max(0.95 * camDir.y, 0.0);\n    }\n    return col;\n}\n\n\n\nvec3 renderAA(vec3 camPos, mat3 camMat, vec3 lightPos, vec3 lightCol, vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n    \n    col += render(camPos, camMat, lightPos, lightCol, fragCoord + vec2( 0.125,  0.375));\n    col += render(camPos, camMat, lightPos, lightCol, fragCoord + vec2( 0.375, -0.125));\n    col += render(camPos, camMat, lightPos, lightCol, fragCoord + vec2(-0.125, -0.375));\n    col += render(camPos, camMat, lightPos, lightCol, fragCoord + vec2( 0.375, -0.125));\n    col = col / 4.0;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);    \n    \n    //Light\n    vec3 lightPos = vec3(10.0, 10.0, -10.0);    \n    vec3 lightCol = vec3(1.0);\n    \n    //Camera Pos\n    float a = iMouse.x/iResolution.x * 2.0 * PI;\n    float b = iMouse.y/iResolution.y;\n    vec3 camPos = vec3(sin(a)*5.0, 5.0*b, cos(a)*5.0);\n    \n    //Camera Dir\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    mat3 camMat = getCamera(camPos, lookAt);\n#ifdef AA\n    col = renderAA(camPos, camMat, lightPos, lightCol, fragCoord);\n#else\n    col = render(camPos, camMat, lightPos, lightCol, fragCoord);\n#endif\n\n    //gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPSILON 0.001\n#define PI 3.141592654\n\n\n\nvec2 unionObj(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 decObj(vec2 a, vec2 b)\n{\n    return a.x > b.x ? a : b;\n}\n\nmat3 rot(vec3 v, float a)\n{   \n    float c = cos(a);\n    float s = sin(a);\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    \n    mat3 r = mat3(vec3((1.0-c)*x*x + c,   (1.0-c)*y*x - s*z, (1.0-c)*z*x + s*y),\n                  vec3((1.0-c)*x*y + s*z, (1.0-c)*y*y + c,   (1.0-c)*z*y - s*x),\n                  vec3((1.0-c)*x*z - s*y, (1.0-c)*y*z + s*x, (1.0-c)*z*z + c));\n    \n    return r;\n}\n\n\n///////////////////////////////////////////////////// SDFs\nfloat sdSphere(vec3 c, float r, vec3 p)\n{\n    return length(p-c)-r;\n}\n\nfloat sdPlane(float py, vec3 p)\n{\n    return p.y - py;\n}\n\nfloat sdTorus(vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 mapDice(vec3 p)\n{\n    float dist;\n    float id;\n    vec2 rst = vec2(10000.0, 0.0);\n        \n    //////////RoundBox\n    dist = sdRoundBox(p, vec3(.8), 0.15);    \n    id = 2.0;\n    rst = unionObj(rst,vec2(dist, id));\n    \n    //////////One\n    dist = -sdSphere(vec3(0.0, 1.0, 0.0), 0.3, p);\n    id = 3.0;    \n    rst = decObj(rst,vec2(dist, id));\n    \n    //////////Two\n    dist =     -sdSphere(vec3(-0.4, 0.0, -1.0), 0.23, p);\n    dist = max(-sdSphere(vec3( 0.4, 0.0, -1.0), 0.23, p), dist);\n    id = 4.0;\n    rst = decObj(rst,vec2(dist, id));\n    \n    //////////Three\n    dist =     -sdSphere(vec3(1.0, 0.5, -0.5), 0.22, p);\n    dist = max(-sdSphere(vec3(1.0, 0.0,  0.0), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(1.0,-0.5,  0.5), 0.22, p), dist);\n    id = 4.0;\n    rst = decObj(rst,vec2(dist, id));\n    \n    //////////Four\n    dist =     -sdSphere(vec3( 0.44, 0.44, 1.0), 0.22, p);\n    dist = max(-sdSphere(vec3(-0.44, 0.44, 1.0), 0.22, p), dist);\n    dist = max(-sdSphere(vec3( 0.44,-0.44, 1.0), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(-0.44,-0.44, 1.0), 0.22, p), dist);\n    id = 3.0;\n    rst = decObj(rst,vec2(dist, id));\n    \n    //////////Five\n    dist =     -sdSphere(vec3(-1.0, 0.44, 0.44), 0.22, p);\n    dist = max(-sdSphere(vec3(-1.0,-0.44, 0.44), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(-1.0, 0.00, 0.00), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(-1.0, 0.44,-0.44), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(-1.0,-0.44,-0.44), 0.22, p), dist);\n    id = 4.0;\n    rst = decObj(rst,vec2(dist, id));    \n    \n    //////////Six    \n    dist =     -sdSphere(vec3( 0.34,-1.0,-0.5), 0.22, p);\n    dist = max(-sdSphere(vec3(-0.34,-1.0,-0.5), 0.22, p), dist);\n    dist = max(-sdSphere(vec3( 0.34,-1.0, 0.0), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(-0.34,-1.0, 0.0), 0.22, p), dist);\n    dist = max(-sdSphere(vec3( 0.34,-1.0, 0.5), 0.22, p), dist);\n    dist = max(-sdSphere(vec3(-0.34,-1.0, 0.5), 0.22, p), dist);\n    id = 4.0;\n    rst = decObj(rst,vec2(dist, id));\n    \n    return rst;\n}","name":"Common","description":"","type":"common"}]}