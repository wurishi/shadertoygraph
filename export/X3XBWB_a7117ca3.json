{"ver":"0.1","info":{"id":"X3XBWB","date":"1728899312","viewed":87,"name":"StarWave","username":"pascalchang","description":"two particle wave","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n\n    float t = iTime * 2.0; // 速度\n\n    float waveFrequency = 4.0;   // 控制波形的频率，决定波峰和波谷的密度\n    float amplitude = 0.1;       // 振幅，控制sin和cos函数上下波动的范围\n    float particleSpacing = 0.2; // 控制粒子的水平间隔\n    float separation = 0.05;     // 两排粒子之间的垂直间距\n\n    float brightnessFactor = 0.002;  // 基本亮度\n    float flickerSpeed = 5.0;        // 控制明暗变化的速度\n\n    for (float i = -1.0; i <= 1.0; i += particleSpacing) {\n        // 每个粒子的x坐标和根据sin函数变化的y坐标\n        float wave = amplitude * sin(waveFrequency * i + t); // sin波形\n        vec2 p = vec2(uv.x - i, uv.y - wave + separation);   // 上排保持一定的垂直距离\n\n        // 计算粒子到当前位置的距离\n        float d = length(p);\n\n        // 基于时间和位置动态调整亮度\n        float brightness = brightnessFactor * (0.5 + 0.5 * sin(flickerSpeed * (iTime + i))); \n        col += brightness / d;\n    }\n\n    for (float i = -1.0; i <= 1.0; i += particleSpacing) {\n        // 每个粒子的x坐标和根据cos函数变化的y坐标\n        float wave = amplitude * cos(waveFrequency * i + t); // cos波形\n        vec2 p = vec2(uv.x - i, uv.y - wave - separation);   // 下排保持一定的垂直距离\n\n        // 计算粒子到当前位置的距离\n        float d = length(p);\n\n        // 基于时间和位置动态调整亮度\n        float brightness = brightnessFactor * (0.5 + 0.5 * cos(flickerSpeed * (iTime + i))); \n        col += brightness / d;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}