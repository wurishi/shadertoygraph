{"ver":"0.1","info":{"id":"XtyBDD","date":"1546313480","viewed":293,"name":"Ribbon Shell Sculpture","username":"WB","description":"Raymarched sphere made of gradient noise that resembles some sort of abstract sculputre. Move mouse left/right to change thickness and up/down to change noise frequency.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","implicitsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define MIN_DIST 0.02\n#define _FoV 45.0\n#define _Epsilon 0.05\n\nconst vec3 _Center = vec3(0.0);\nconst float _Radius = 1.0;\nconst float _TextureScale = 0.5;\nconst float _SpecularExp = 50.0;\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(center - pos) - radius;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//X-axis rotation matrix\nvec3 rotateX(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(1.0, 0.0, 0.0,\n        \t\t\t0.0, cosTheta, -sinTheta,\n    \t\t\t    0.0, sinTheta, cosTheta);\n    \n    return rot * p;\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Fractal (pink) noise function S(f) ∝ 1/f^α, {0 <= α <=2}\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    for (int i = 1; i < octaves; i++)\n    {\n        val += noise(seed * freq * float(i)) / (pow(float(i), lac));\n    }\n\n    return val;\n}\n\nfloat map(vec3 pos)\n{   \n    float mX = iMouse.x/iResolution.x;\n    float thickness = mix(0.5, 0.9999, mX);\n    float mY = iMouse.y/iResolution.y;\n    float freq = mix(8.0, 1.0, mY);\n    float d1 = sdSphere(pos, _Center, _Radius);\n    float d2 = -sdSphere(pos, _Center, _Radius * thickness);\n    float df = max(d1, d2);\n    df = max(df, abs(noise(pos*freq)));\n    //df += cos(pos.y*16.0)/48.0;\n    //df += cos(pos.x*16.0)/48.0;\n    //df += cos(pos.z*16.0)/48.0;\n    \n    return df;\n}\n\nvec3 raymarch(vec3 pos, vec3 dir)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = map(pos);\n        \n        if (dist <= MIN_DIST)\n        {\n            return pos;\n        }\n        \n        pos += dir * dist * _Epsilon;\n    }\n    \n    return vec3(0.0);\n}\n    \n//Approximate surface normal using central difference\nvec3 calculateNormal(vec3 p)\n{\n    const float eps = 0.01;\n\n    return normalize(vec3(map(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n                          map(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n                          map(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    int i = 0;\n    float t = mint;\n    for(int i = 0; i < 64; i++)\n    {\n        if (t >= maxt)\n            break;\n        \n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n//Tri-planar texture mapping\nvec3 triPlanar(vec3 p, vec3 n, float k)\n{\n    vec2 xUV = p.zy/_TextureScale;\n    vec2 yUV = p.xz/_TextureScale;\n    vec2 zUV = p.xy/_TextureScale;\n    \n    vec3 colX = texture(iChannel0, xUV).rgb;\n    vec3 colY = texture(iChannel0, yUV).rgb;\n    vec3 colZ = texture(iChannel0, zUV).rgb;\n    \n    vec3 blend = pow(abs(n),vec3(k));\n    blend = blend/(blend.x + blend.y + blend.z);\n    \n    return colX * blend.x + colY * blend.y + colZ * blend.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0);\n        \n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    rayDir = rotateY(rayDir, iTime * 0.2);\n    rayOrigin = rotateY(rayOrigin, iTime * 0.2);\n    //rayDir = rotateX(rayDir, iTime * 0.1);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 start, end;\n    \n    if(raycastSphere(rayOrigin, rayDir, start, end, _Center, _Radius))\n    {\n        vec3 sp = raymarch(start, rayDir);\n\n        vec3 n = calculateNormal(sp);\n\n        vec3 r = rayOrigin - sp;\n        float atten = 1.0/dot(r,r);\n        \n        float nl = dot(n, -rayDir);\n        \n        vec3 h = (n-rayDir)/length(n-rayDir);     \n        float spec = pow(max(dot(n, h), 0.0), _SpecularExp) * max(0.0, nl);\n        \n        col = triPlanar(sp, n, 2.0); \n        \n        float d = length(r);\n       \tfloat shadow = softShadow(sp, -rayDir, 0.0001, d, 16.0);\n\n        //Lighting\n        //float flicker = ((1.0 + sin(iTime*2.0)/2.0) + (1.0 + sin(iTime*10.0)/4.0) + (1.0+sin(iTime*25.0)/8.0))*0.5;\n        col = vec3(0.1, 0.1,0.2) + col * (nl + spec) * atten * shadow * 15.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}