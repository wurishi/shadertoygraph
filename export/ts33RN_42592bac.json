{"ver":"0.1","info":{"id":"ts33RN","date":"1598142404","viewed":144,"name":"Character","username":"desertgreg","description":"Watched iq's shader breakdown, why not try to make a character in math! ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarchmodel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 BACKGROUND_COLOR = vec3(0.2,0.2,0.75);\nconst float MTL_BACKGROUND = 0.0;\nconst float MTL_GROUND = 1.0;\nconst float MTL_SKIN1 = 2.0;\nconst float MTL_EYE = 3.0;\nconst float MTL_NOSE = 4.0;\n\n\nconst float MTL_MIRROR = 3.0;\nconst float MTL_WATER = 4.0;\nconst float MTL_POOL_BOTTOM = 5.0;\n\nconst float kNoTransparency = -1.0;\nconst float kTransparency = 1.0;\nconst float kInverseTransparency = 0.0;\n\nfloat freqs[4];\nvec3 debug_out = vec3(0,0,0);\n\n\n\nfloat wigglies(vec3 p) {\n    return cos(p.x*3.0 + 2.0*iTime)*0.13;\n}\n\nfloat ripples(in vec3 p,vec3 pos, float amp, float freq) {\n    vec2 r = p.xz - pos.xz;\n    float dist = length(r);\n    float h = amp * sin(freq*(dist - 3.0*iTime));\n    return -pos.y + p.y + h; //(sin(sin(p.z*0.1253) - p.x*0.311)*0.61 + cos(p.z*0.53 + sin(p.x*0.127))*0.12)*1.7 + 0.2;\n}\n\nfloat water(in vec3 p)\n{\n    p.y -= 6.0;\n    float a = ripples(p,vec3(-2,-0.8,5),0.1,2.0);\n    float b = ripples(p,vec3(10.0,-0.8,1.0),0.1,3.0);\n    return a+b;\n}\n\n\n///////////////////////////////////////////\n//\n//  Scene Definition\n//\n///////////////////////////////////////////\nvec4 distf(in vec3 p, const float transparent_scale)\n{\n    const float FILLET = 0.75;\n    \n    vec2 result;\n    \n    // flat plane with rectangular solid subtracted for a swimming pool\n    vec2 ground = vec2(plane(p + 0.6*sin(p.x/4.0 + iTime) + 0.756*sin(p.z/6.0 + 2.0*sin(iTime)),vec3(0.0,1.0,0.0),0.0),MTL_GROUND);\n\tresult = ground;\n\n    vec3 blobbyp = p;\n    blobbyp.x = abs(p.x) - 10.0;\n\tblobbyp.y -= -8.0*iTime;\n    pModInterval(blobbyp.y,30.0);\n    blobbyp.xz -= 0.3*sin(blobbyp.y);\n    //blobbyp = blobbyp - vec3(12.0,abs(20.0*sin(iTime)) - 8.0,0.0);\n    vec2 blob = vec2(sdEllipsoid(blobbyp,vec3(3.0,5.0,3.0)),MTL_GROUND);\n    opSmoothUnion(result,blob,4.0);\n    \n    // Bunny head\n    float jumpt = abs(sin(4.0*iTime));\n    vec3 headp = p - vec3(0,8.0+5.0*jumpt,0) ;\n    //pModInterval1(headp.x,12.0,-5.0,5.0);\n    //pModInterval1(headp.z,12.0,0.0,5.0);\n    vec3 headtiltp = headp;\n    headtiltp.yz = rotate(headtiltp.yz,jumpt/2.0);\n    vec2 head = vec2(sdEllipsoid(headtiltp,vec3(6.0,4.0,4.0)), MTL_SKIN1);\n\n    // Body\n    vec3 bodyp = headp - vec3(0.0,-4.0,1.0);\n    bodyp.yz = rotate(bodyp.yz,0.2);\n    vec2 body = vec2(sdEllipsoid(bodyp,vec3(3.0,4.0,3.0)),MTL_SKIN1);\n    opSmoothUnion(body,head,1.5);\n    \n    // Tail\n    vec3 tailp = bodyp - vec3(0.0,-2.0,2.5);\n    vec2 tail = vec2(sdEllipsoid(tailp,vec3(1.5,1.5,1.5)),MTL_SKIN1);\n    opSmoothUnion(body,tail,0.2);\n    \n    // Arms, legs\n    vec3 symbodyp = bodyp;\n    symbodyp.x = abs(symbodyp.x);\n    vec3 armp = symbodyp;\n    armp = armp - vec3(2.0,-1.0,-1.0);\n    armp.xy = rotate(armp.xy,0.3-jumpt);\n    armp.x = armp.x - 1.0;\n    vec2 arm = vec2(sdEllipsoid(armp,vec3(2.0,1.0,1.0)),MTL_SKIN1);\n    opSmoothUnion(body,arm,0.2);\n\t\n    vec3 legp = symbodyp;\n    legp = legp - vec3(1.1,-3.0,-1.0);\n    legp.xy = rotate(legp.xy,0.3-jumpt);\n    vec2 leg = vec2(sdEllipsoid(legp,vec3(1.0,2.0,1.0)),MTL_SKIN1);\n    opSmoothUnion(body,leg,0.2);\n    \n    add(result,body);\n       \n    // nose\n    vec3 nosep = headtiltp - vec3(0.0,-0.4,-4.0);\n    vec2 nose = vec2(sdEllipsoid(nosep,vec3(0.4,0.4,0.4)),MTL_NOSE);\n    add(result,nose);\n    \n    // Symmetric face features\n\t// Eyes\n    vec3 symfacep = headtiltp;\n    symfacep.x = abs(symfacep.x);\n    vec3 eyep = symfacep - vec3(2.0,-0.2,-3.8);\n    vec2 eye = vec2(sdEllipsoid(eyep,vec3(0.3,0.5,0.3)),MTL_EYE);\n    vec2 eye_socket = vec2(sdEllipsoid(eyep - vec3(0.0,0.0,-0.1),vec3(0.9,1.3,0.4)),MTL_SKIN1);\n    \n    opSmoothSubtraction(result,eye_socket,0.1);\n    add(result,eye);\n    \n    // mouth, two half tori\n    vec3 mouthp = symfacep - vec3(0.5,-0.8,-3.8);\n    mouthp.yz = rotate(mouthp.yz,3.1415/2.0);\n    vec2 mouth = vec2(torus(mouthp,0.5,0.2),MTL_SKIN1);\n    vec2 clip = vec2(sdBox(mouthp-vec3(1.0,0.0,1.0),vec3(2.0,2.0,1.0)),MTL_SKIN1);\n    opSmoothSubtraction(mouth,clip,0.3);\n    //add(result,mouth);\n\n    // Ears\n    vec3 earp = symfacep - vec3(2.2,2.2,0.0);\n    earp.xy = rotate(earp.xy,0.4);\n    earp.xz = rotate(earp.xz,0.3);\n    earp.yz = rotate(earp.yz,0.5*jumpt);\n    vec2 ear = vec2(sdEllipsoid(earp,vec3(2.1,6.0,1.2)),MTL_SKIN1);\n    vec2 ear_minus = vec2(sdEllipsoid(earp - vec3(0.0,0.0,-0.6),vec3(1.8,5.0,0.85)),MTL_SKIN1);\n    opSmoothSubtraction(ear,ear_minus,0.3);\n    opSmoothUnion(result,ear,0.75);\n    \n\n\treturn vec4(result,0,0);  // todo: add uv coords!\n}\n\n\nC_PointLight get_point_light()\n{\n    C_PointLight result;\n\n    float x = 10.0 * sin(iTime * 0.7);\n    result.pos = vec3(x, 3.0, -2.0);\n    result.color = vec3(132.0, 6.0, 1.0) * 10.0;\n\t\n    return result;\n}\n\nC_DirectionalLight get_directional_light()\n{\n    C_DirectionalLight result;\n\n    result.dir = normalize(vec3(-0.2, -0.3, 0.5));\n    result.color = vec3(8.0, 7.5, 7.0);\n\n    return result;\n}\n\nvec3 get_sky_gradient( const in vec3 dir )\n{\n    const vec3 ctop = vec3(0.6, 0.8, 1.0);\n    const vec3 choriz = vec3(1.2,0.7,0.5); //ctop * 2.5;\n\n    float blend = clamp(dir.y, 0.0, 1.0);\n    return mix(choriz, ctop, blend);\n}\n\n\nfloat xyz_checkers(vec3 p,float size)\n{\n    float chessboard = floor(p.x/size) + floor(p.y/size) + floor(p.z/size);\n    //divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for odd numbers.\n    chessboard = fract(chessboard * 0.5);\n    //multiply it by 2 to make odd values white instead of grey\n    chessboard *= 2.0;\n    return chessboard;\n}\n\nfloat curvy_checkers(vec3 p, float size)\n{\n    float val = sin(p.x * PI/size) * sin(p.y * PI/size) * sin(p.z * PI/size);\n    return val;\n}\n\nC_Material get_material(const in C_HitInfo hitinfo)\n{\n    C_Material mat;\n    float mtl = hitinfo.mtl.x;\n    \n    if (mtl < 0.5)\n    {\n        mat.albedo = BACKGROUND_COLOR * 0.2*hitinfo.pos.y + 0.3;\n        mat.smoothness = 1.0;\n        mat.fR0 = 0.02;\n        mat.transparency = 0.0;\n    }\n    else if (mtl <= MTL_GROUND)\n    {\n        float c = curvy_checkers(hitinfo.pos,5.0);\n        c = smoothstep(c,-0.1,0.1);\n        mat.albedo = vec3(0.5, 1.0, 0.2) + c*vec3(0.3,0.3,0.3);\n        mat.smoothness = 0.7;\n        mat.fR0 = 0.4;\n        mat.transparency = 0.0;\n    }\n    else if (mtl <= MTL_SKIN1)\n    {\n        mat.albedo = vec3(0.4, 0.4, 0.4);\n        mat.smoothness = 0.1;\n        mat.fR0 = 0.0;\n        mat.transparency = 0.0;\n    }\n    else if (mtl <= MTL_EYE)\n    {\n        mat.albedo = vec3(0.01, 0.01, 0.01);\n        mat.smoothness = 0.1;\n        mat.fR0 = 0.2;\n        mat.transparency = 0.0;\n    }\n    else if (mtl <= MTL_NOSE)\n    {\n        mat.albedo = vec3(0.01, 0.01, 0.01);\n        mat.smoothness = 0.1;\n        mat.fR0 = 0.2;\n        mat.transparency = 0.0;\n    }\n\telse if (mtl <= MTL_MIRROR)\n    {\n        mat.albedo = vec3(0.1, 0.1, 0.1);\n        mat.smoothness = 1.0;\n        mat.fR0 = 1.0;\n        mat.transparency = 0.0;\n    }\n        else if (mtl <= MTL_WATER)\n    {\n        mat.albedo = vec3(1.0,1.0,1.0);\n        mat.smoothness = 1.0;\n        mat.fR0 = 0.01;\n        mat.transparency = 1.0;\n        mat.refractive_index = 1.0 / 1.3330;\n        \n        const float extinction_scale = 2.0;\n        const vec3 extinction = vec3(0.3,0.7,0.9);\n        mat.albedo = (vec3(1.0) - extinction) * extinction_scale;\n    }\n    else if (mtl <= MTL_POOL_BOTTOM)\n    {\n        vec3 wpos = hitinfo.pos;\n        wpos.y = 0.0;\n        float check = xyz_checkers(wpos,4.5); \n        \n        mat.albedo = mix(vec3(0.3,0.3,0.6),vec3(1.0,1.0,1.0),check); //check*vec3(check,check,check);\n\t\tmat.smoothness = 0.25;\n        mat.fR0 = 0.1;\n        mat.transparency = 0.0;\n    }\n    \n    return mat;\n}\n\n\n\n\n///////////////////////////////////////////\n//\n//  Raymarching engine\n//\n///////////////////////////////////////////\n\nvoid ray_march(const in C_Ray ray, out C_HitInfo result, const float transparent_scale) \n{\n    result.dist = ray.start_dist;\n    result.mtl = vec3(0,0,0);\n    \n    for (int i = 0; i < MAX_RAYCAST_STEPS; i++) {\n        result.pos = ray.origin + ray.dir * result.dist;\n        vec4 d = distf(result.pos,transparent_scale);\n        result.mtl = d.yzw;\n\n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(d.x) <= DIST_EPSILON) || (result.dist >= ray.length))\n        {\n            break;\n        }         \n\n        result.dist = result.dist + d.x*STEP_DAMPING;\n    }\n    \n    if (result.dist > ray.length)\n    {\n        result.dist = 1000.0;\n        result.pos = ray.origin + ray.dir * result.dist;\n        result.mtl.x = MTL_BACKGROUND;\n    }\n}\n\n\n#define NORMAL_EPS              0.001\nvec3 normal(in vec3 p, const float transparent_scale)\n{\n    vec2 d = vec2(NORMAL_EPS, 0.0);\n    return normalize(vec3(\n        distf(p + d.xyy,transparent_scale).x - distf(p - d.xyy,transparent_scale).x,\n        distf(p + d.yxy,transparent_scale).x - distf(p - d.yxy,transparent_scale).x,\n        distf(p + d.yyx,transparent_scale).x - distf(p - d.yyx,transparent_scale).x));\n}\n\nfloat get_shadow(const in vec3 pos, const in vec3 normal, const in vec3 light_dir, const in float light_dist )\n{\n    C_Ray shadowray;\n\tshadowray.dir = light_dir;\n\tshadowray.origin = pos;\n\tconst float fShadowBias = 0.05;\n\tshadowray.start_dist = fShadowBias / abs(dot(light_dir, normal));\n\tshadowray.length = light_dist - shadowray.start_dist;\n\t\n\tC_HitInfo shadowIntersect;\n\tray_march(shadowray, shadowIntersect, kNoTransparency);\n\t\t\n\tfloat fShadow = step(0.0, shadowIntersect.dist) * step(light_dist, shadowIntersect.dist );\n\n\treturn fShadow;        \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        vec4 h = distf(ro + rd*t,kNoTransparency);\n        if( h.x<0.001 )\n            return 0.0;\n        res = min( res, k*h.x/t );\n        t += h.x;\n    }\n    return res;\n}\n\n// use distance field to evaluate ambient occlusion\nfloat ambient_occlusion(const in C_HitInfo intersection, const in C_Surface surface)\n{\n#if ENABLE_AMBIENT_OCCLUSION    \n    vec3 pos = intersection.pos;\n    vec3 normal = surface.normal;\n    float ao = 1.0;\n    float dist = 0.0;\n\n    for(int i=0; i<=5; i++)\n    {\n        dist += 0.1;\n\t\tvec4 d = distf(pos + normal * dist, kNoTransparency);\n\t\tao *= 1.0 - max(0.0, (dist - d.x) * 0.2 / dist );                                  \n    }\n\n    return ao;\n#else\n    return 1.0;\n#endif    \n}\n\nvoid apply_atmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)\n{\n\tconst float kFogDensity = 0.015;\n\n    #if ENABLE_FOG\n    // fog\n    float fog_amount = exp(hitInfo.dist * -kFogDensity);\n    vec3 fog_color = get_sky_gradient(ray.dir);\n\n    #if ENABLE_DIRECTIONAL_LIGHT_FLARE\n    C_DirectionalLight dlight = get_directional_light();\n    float fdirdot = clamp(dot(-dlight.dir, ray.dir), 0.0, 1.0);\n    fog_color += dlight.color * pow(fdirdot, 10.0);\n    #endif \n\n    col = mix(fog_color, col, fog_amount);\n    #endif\n\n    // glare from light (a bit hacky - use length of closest approach from ray to light)\n    #if ENABLE_POINT_LIGHT_FLARE\n    C_PointLight plight = get_point_light();\n\n    vec3 to_light = plight.pos - ray.origin;\n    float pdot = dot(to_light, ray.dir);\n    pdot = clamp(pdot, 0.0, hitInfo.dist);\n\n    vec3 closest_point = ray.origin + ray.dir * pdot;\n    float dist = length(closest_point - plight.pos);\n    col += plight.color * 0.01/ (dist*dist);\n    #endif    \n}\n\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat schlick( const in vec3 halfvec, const in vec3 view, const in float fR0, const in float smoothness)\n{\n    float fdot = dot(halfvec, -view);\n    fdot = clamp((1.0 - fdot), 0.0, 1.0);\n    float fdotpow = pow(fdot, 5.0);\n    return fR0 + (1.0 - fR0) * fdotpow * smoothness;\n}\n\nvec3 fresnel(const in vec3 diffuse, const in vec3 specular, const in vec3 normal, const in vec3 view, const in C_Material material)\n{\n\tvec3 reflect = reflect(view,normal);\n\tvec3 halfvec = normalize(reflect + -view);\n    float fresnel_val = schlick(halfvec, view, material.fR0, material.smoothness * 0.9 + 0.1);\n    return mix(diffuse, specular, fresnel_val);    \n}\n\nfloat blinn_phong(const in vec3 incident_dir, const in vec3 light_dir, const in vec3 normal, const in float smoothness)\n{          \n    vec3 halfvec = normalize(light_dir - incident_dir);\n    float ndoth = max(0.0, dot(halfvec, normal));\n\n    float spec_power = exp2(4.0 + 6.0 * smoothness);\n    float spec_inten = (spec_power + 2.0) * 0.125;\n\n    return pow(ndoth, spec_power) * spec_inten;\n}\n\nC_Shading apply_point_light( const in C_PointLight light, const in vec3 pos, const in vec3 incident_dir, const in vec3 normal, const in C_Material material )\n{\n    C_Shading shading;\n    \n    vec3 to_light = light.pos - pos;\n    vec3 light_dir = normalize(to_light);\n    float light_dist = length(to_light);\n    \n    float atten = 1.0 / (light_dist * light_dist);\n    \n    float shadow = get_shadow( pos, normal, light_dir, light_dist );\n    vec3 incident_light = light.color * shadow * atten * max(0.0, dot(light_dir, normal));\n    \n    shading.diffuse = incident_light;                                  \n    shading.specular = blinn_phong( incident_dir, light_dir, normal, material.smoothness ) * incident_light;\n    \n    return shading;\n}  \n\nC_Shading apply_directional_light( const in C_DirectionalLight light, const in vec3 pos, const in vec3 incident_dir, const in vec3 normal, const in C_Material material )\n{\n    C_Shading shading;\n\n    const float kShadowRayLength = 50.0;      \n    vec3 light_dir = -light.dir;\n    float shadow = get_shadow( pos, normal, light_dir, kShadowRayLength );\n    vec3 incident_light = light.color * shadow * max(0.0, dot(light_dir, normal));\n    \n    shading.diffuse = incident_light;                                  \n    shading.specular = blinn_phong( incident_dir, light_dir, normal, material.smoothness ) * incident_light;\n    \n    return shading;\n}  \n\n\nvec3 shade_surface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)\n{\n    vec3 color;\n    \n    C_Shading shading;\n\n    shading.diffuse = vec3(0.0);\n    shading.specular = vec3(0.0);\n    \n    float ao = 1.0; //get_ambient_occlusion(hitInfo, surface);\n    vec3 vAmbientLight = get_sky_gradient(surface.normal) * ao;\n    \n    shading.diffuse += vAmbientLight;\n    shading.specular += surface.reflection;\n              \n    #if ENABLE_POINT_LIGHT\n    C_PointLight pointLight = get_point_light(); \n    C_Shading pointLighting = apply_point_light(pointLight, hitInfo.pos,ray.dir, surface.normal, material);\n    shading.diffuse += pointLighting.diffuse;\n    shading.specular += pointLighting.specular;\n    #endif\n\n    #if ENABLE_DIRECTIONAL_LIGHT\n\tC_DirectionalLight directionalLight = get_directional_light();\n    C_Shading directionLighting = apply_directional_light(directionalLight, hitInfo.pos, ray.dir, surface.normal, material);\n    shading.diffuse += directionLighting.diffuse;\n    shading.specular += directionLighting.specular;\n    #endif\n\n    vec3 diff_reflection = shading.diffuse * material.albedo;              \n\n    // swap diffuse for transmission\n    diff_reflection = mix(diff_reflection, surface.transmission, material.transparency);    \n\n    #ifdef ENABLE_SPECULAR\n    color = fresnel(diff_reflection , shading.specular, surface.normal, ray.dir, material);\n    #else\n    color = diff_reflection;\n    #endif\n    \n    return color;\n}\n\n\nvec3 get_scene_color_secondary(const in C_Ray ray);\n\nvec3 get_reflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )\n{\n    #ifdef ENABLE_REFLECTIONS    \n    {\n        // get colour from reflected ray\n        const float fSeparation    = 0.1;\n\n        C_Ray reflect_ray;\n        reflect_ray.dir = reflect(ray.dir, surface.normal);\n        reflect_ray.origin = hitInfo.pos;\n        reflect_ray.length = 16.0;\n        reflect_ray.start_dist = fSeparation / abs(dot(reflect_ray.dir, surface.normal));\n        \n        return get_scene_color_secondary(reflect_ray);      \n    }\n    #else\n        return get_sky_gradient(reflect(ray.dir, surface.normal));                              \n    #endif\n}\n\nvec3 get_transmission( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material )\n{\n    #ifdef ENABLE_TRANSPARENCY  \n    {\n        const float fSeparation = 0.05;\n\n        // Trace until outside transparent object\n        C_Ray refractray;\n        // we dont handle total internal reflection (in that case refract returns a zero length vector)\n        refractray.dir = refract(ray.dir, surface.normal, material.refractive_index);\n        refractray.origin = hitInfo.pos;\n        refractray.length = 16.0;\n        refractray.start_dist = fSeparation / abs(dot(refractray.dir, surface.normal));\n\n\t\t#ifdef DOUBLE_SIDED_TRANSPARENCY\n\t\t\n\t\t\tC_HitInfo hitInfo2;\n\t\t\tray_march(refractRay, hitInfo2, 32, kInverseTransparency);\n\t\t\tvec3 normal = normal(hitInfo2.pos, kInverseTransparency);\n\t\t\t\n\t\t\t// get colour from rest of scene\n\t\t\tC_Ray refractRay2;\n\t\t\trefract2.dir = refract(refractRay.vDir, vNormal, 1.0 / material.fRefractiveIndex);\n\t\t\trefract2.origin = hitInfo2.vPos;\n\t\t\trefract2.length = 16.0;\n\t\t\trefract2.start_distance = 0.0;//fSeparation / abs(dot(refractRay2.vDir, vNormal));\n\t\t\t\n\t\t\tfloat fExtinctionDist = hitInfo2.fDistance;\n\t\t\tvec3 color = get_scene_color_secondary(refract2);\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 color = get_scene_color_secondary(refractray);                                                                        \n\t\t\tfloat fExtinctionDist = 0.5;\n\t\t\n\t\t#endif\n                                \n        vec3 mtl_extinction = material.albedo;\n        // extinction should really be exp(-) but this is a nice hack to get RGB\n        vec3 cExtinction = (1.0 / (1.0 + (mtl_extinction * fExtinctionDist)));\t\t\n\t\t\n\t\t//vec3 cExtinction = exp2(-cMaterialExtinction * fExtinctionDist);\n                                \n        return color * cExtinction;\n    }\n    #else\n        return get_sky_gradient(reflect(ray.dir, surface.normal));                              \n    #endif\n}\n\n// no reflections, no transparency, used for secondary rays\nvec3 get_scene_color_secondary( const in C_Ray ray )\n{\n    C_HitInfo hitInfo;\n    ray_march(ray, hitInfo, kNoTransparency);\n\n    vec3 color;\n\n    if(hitInfo.mtl.x < 0.5)\n    {\n        color = get_sky_gradient(ray.dir);\n    }\n    else\n    {\n        C_Surface surface;        \n        surface.normal = normal(hitInfo.pos, kNoTransparency);\n\n        C_Material material = get_material(hitInfo);\n\n        // use sky gradient instead of reflection\n        surface.reflection = get_sky_gradient(reflect(ray.dir, surface.normal));\n        \n        material.transparency = 0.0;\n\n        // apply lighting\n        color = shade_surface(ray, hitInfo, surface, material);\n    }\n\n    apply_atmosphere(color, ray, hitInfo);\n\n    return color;\n}\n\nvec3 get_scene_color_primary( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    ray_march(ray, intersection,kTransparency);\n    \n    vec3 cScene;\n\n    if(intersection.mtl.x < 0.5)\n    {\n        cScene = get_sky_gradient(ray.dir);\n    }\n    else\n    {\n        C_Surface surface;\n        surface.normal = normal(intersection.pos,kTransparency);\n\n        C_Material material = get_material(intersection);\n\n        surface.reflection = get_reflection(ray, intersection, surface);\n\n        if(material.transparency > 0.0)\n        {    \n            surface.transmission = get_transmission(ray, intersection, surface, material);\n        }\n\n        // apply lighting\n        cScene = shade_surface(ray, intersection, surface, material);\n    }\n\n    apply_atmosphere(cScene, ray, intersection);\n\n    return cScene;\n}\n\nvec3 tonemap( const in vec3 color )\n{ \n    vec3 vResult = 1.0 -exp2(-color);\n    return vResult;\n}\n\n\n\n\n\n// Camera Model ray-generation\nconst float HFOV_DEG = 45.0;\nconst float HFOV = 3.1415*HFOV_DEG/180.0;\nconst float FOV_SCL = tan(HFOV*0.5);\n\nvec3 getRayDir(vec3 camPos, vec3 viewDir, vec2 pixelPos) {\n    vec3 camRight = normalize(cross(viewDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, viewDir));\n    return normalize(FOV_SCL*pixelPos.x*camRight + FOV_SCL*pixelPos.y*camUp + viewDir);\n}\n\n\n// Camera Model position and orientation\nconst float CAM_DIST = 30.0;\nconst float CAM_H = 12.0;\nconst vec3 CAM_LOOKAT = vec3(0,8,0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = gl_FragCoord.xy/iResolution.xy;\n    vec2 uv = -1.0+2.0*q;\n    uv.x *= iResolution.x/iResolution.y;\n\n \t// Get some fft values\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n    float ang = 0.8*(40.0 + iTime);\n    vec3 target = CAM_LOOKAT;\n    //target = vec3(3.0f*sin(5.0f*iTime) , 2.0f*cos(7.72f*iTime), 0.0f); // animate target\n    \n    vec2 nMouse =2.0*iMouse.xy / iResolution.xy - vec2(0.5);\n    ang = 3.1415/2.0 - nMouse.x * 3.1415/2.0;\n    float h = CAM_H * (nMouse.y + 0.85);\n    vec3 camPos = vec3(CAM_DIST*cos(ang), h, -CAM_DIST*sin(ang));\n    vec3 rayDir = getRayDir(camPos,normalize(target - camPos), uv);\n    \n    C_Ray cam_ray;\n    cam_ray.origin = camPos;\n    cam_ray.dir = rayDir;\n    cam_ray.start_dist = NEAR_CLIP_PLANE;\n    cam_ray.length = FAR_CLIP_PLANE;\n    \n    vec3 color = get_scene_color_primary(cam_ray);\n    color = tonemap(color);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n    //fragColor = vec4(debug_out,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// RayMarching info\n// https://iquilezles.org/articles/distfunctions\n// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n// http://mercury.sexy/hg_sdf/\n\n#define NEAR_CLIP_PLANE         1.0\n#define FAR_CLIP_PLANE          100.0\n#define MAX_RAYCAST_STEPS       2000\t\n#define STEP_DAMPING            0.25\t\n#define DIST_EPSILON            0.001\t\n\n#define ENABLE_FOG 1\n#define ENABLE_SPECULAR 1\n#define ENABLE_REFLECTIONS 1\n#define ENABLE_TRANSPARENCY 1\n#define ENABLE_AMBIENT_OCCLUSION 1\n\n#define ENABLE_POINT_LIGHT 0\n#define ENABLE_POINT_LIGHT_FLARE 0\n#define ENABLE_DIRECTIONAL_LIGHT 1\n#define ENABLE_DIRECTIONAL_LIGHT_FLARE 1\n\n\n\n\n\n\n\n\nstruct C_Ray\n{\n    vec3 origin;\n    vec3 dir;\n    float start_dist;\n    float length;\n};\n    \n    \nstruct C_HitInfo\n{\n    vec3 pos;\n    float dist;\n    vec3 mtl;\t\t// material id + uv\n};\n\nstruct C_Surface\n{\n    vec3 normal;\n    vec3 reflection;\n    vec3 transmission;    \n};\n\nstruct C_Material\n{\n    vec3 albedo;\n    float fR0;\n    float smoothness;\n    vec2 param;\n\n    float transparency;\n    float refractive_index;\n};\n\nstruct C_Shading\n{\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct C_PointLight\n{\n    vec3 pos;\n    vec3 color;\n};\n\nstruct C_DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\n\n//////////////////////////////////////////////////////\n// SDF Functions\n//////////////////////////////////////////////////////\n    \n    \nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\n\nfloat plane(vec3 p, vec3 n, float offs) {\n  return dot(p, n) - offs;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat cylinder(in vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat cylinder(in vec3 p, float r, float h) {\n    float d = cylinder(p, r);\n    return max(d, abs(p.y) - h*0.5);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat torus(vec3 p, float ri, float ro) {\n    vec2 q = vec2(length(p.xz) - ri, p.y);\n    return length(q) - ro;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\n// Repeat \nfloat pModInterval(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\treturn c;\n}\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\n\nvec2 add_transparent( const in vec2 v1, const in vec2 v2, const in float fTransparentScale )\n{    \n\t// Negate the distance to the transparency object if transparent scale is 0.0     \n\t// This allows us to ratrace \"out\" of transparency\n\tvec2 vScaled = vec2(v2.x * (fTransparentScale * 2.0 - 1.0), v2.y);\n                \n\t// The condition allows us to ignore transparency for secondary rays\n    return mix(v1, vScaled, step(vScaled.x, v1.x) * step(0.0, fTransparentScale));\n}\n\nvoid intersect(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\nvoid opSmoothUnion( inout vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    float val = mix( d2.x, d1.x, h ) - k*h*(1.0-h); \n    d1.x = val;\n}\n\nvoid opSmoothSubtraction( inout vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    float val = mix( d1.x, -d2.x, h ) + k*h*(1.0-h); \n    d1.x = val;\n}\n\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\nconst float PI=3.1415;\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\n\n//\n// Waves support\n//  \n// Physical constants\nconst float PIXELS_PER_METER = 25.0;\nconst float CELL_DIMENSION = 1.0 / PIXELS_PER_METER;\t// size of cell in meters\nconst float WAVE_C = 75.0;  // 25m/s waves?\n\n// Requirements:\n// WAVE_C < CELL_DIMENSION / TIMESTP\n// TIMESTEP < CELL_DIMENSION / WAVE_C\nconst float TIMESTEP = 0.5*CELL_DIMENSION / WAVE_C;  // 1000Hz update?\nconst float DAMPING = 0.999;\n\nconst float MOUSE_STR = 0.4;\nconst float MOUSE_R = 20.0;\n\n#define ROUNDED_RECT_BOUNDARY 1\n\nvoid mouse_disturbance(in vec2 pos, in vec2 mouse,float t,inout float h,inout float vel)\n{\n\tfloat atten = smoothstep(1.0,0.0,length(mouse.xy - pos) / MOUSE_R);\n    h += MOUSE_STR * atten * sin(15.0*t);\n    vel *= (1.0 - atten);\n}\n\nbool inside_pool(in vec2 uv)\n{\n    // Rounded rect boundary\n#if ROUNDED_RECT_BOUNDARY\n    vec2 p = uv - vec2(0.5,0.5);\n    vec2 box_size = vec2(0.3,0.3);\n    vec2 delta = abs(p) - box_size;\n    float r = 0.15;\n    float d = length(max(delta,0.0)) - r + min(max(delta.x,delta.y),0.0);\n    \n    p = uv - vec2(0.5,0.05);\n    float d2 = length(p) - 0.18;\n    d = max(-d2,d);\n    \n    return (d < 0.0);\n#endif\n}\n\n","name":"Common","description":"","type":"common"}]}