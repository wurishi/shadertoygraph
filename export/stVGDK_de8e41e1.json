{"ver":"0.1","info":{"id":"stVGDK","date":"1638382925","viewed":194,"name":" Alien landscape","username":"AnicetN","description":"INSA Lyon 3IF SI\n\nMove camera using mouse","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","reflection","waves","water","planet","daylightcycle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TURBULENCES //////////////////////////////////////////////////////////////////////////\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2 i = floor( p + (p.x+p.y)*K1 );\n        \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridged(in vec2 p) {\n    //r(p) = 2(0.5 −|0.5 −n(p)|)\n    return 2.*(0.5 - abs(0.5 - noise(p)));\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave, in bool useRidged) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        if (useRidged) {\n            res = res+amplitude*ridged(f*p);\n        } else {\n            res = res+amplitude*noise(f*p);\n        }\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\n// TRANSFORMATIONS //////////////////////////////////////////////////////////////////////\n\n// Rotation matrix around the X axis.\nmat3 xRotationMat(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 yRotationMat(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 zRotationMat(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// UTILITAIRES //////////////////////////////////////////////////////////////////////\n\nvec2 identifyMin(float a, float b, float c) {\n    float m = min(min(a, b), c);\n    if (m == a) return vec2(m, 0.);\n    if (m == b) return vec2(m, 1.);\n    if (m == c) return vec2(m, 2.);\n}\n\nvec2 identifyMin(float a, float b, float c, float d) {\n    vec2 im = identifyMin(a, b, c);\n    if (min(im.x, d) == d) return vec2(d, 3.);\n    return im;\n}\n\n// RAY MARCHING //////////////////////////////////////////////////////////////////////\n\n//// SETTINGS\n\nconst int Steps = 1000;\nconst float Epsilon = 0.001;\nconst float T=1.;\n\nconst float rA=5.0;\nconst float rB=200.0; \n\nconst float PI = 3.14;\n\nfloat time() {\n    return iTime+10.;\n}\n\n//// SDFs\n\nvec3 camPos() {\n    return vec3(-10., 8., 0.);\n}\n\nfloat sdfRelief(vec3 p) {\n    return p.y - turbulence(p.xz+vec2(120.), 5.5, 0.02, 0.38, 9, true);\n}\n\nfloat sdfMer(vec3 p) {\n    float level = -0.0;\n    return p.y - level - (\n        turbulence(p.xz+vec2(time()*0.8), 0.01, 1., 0.2, 1, false) +\n        turbulence(p.xz+vec2(10.)+vec2(time(), -time()), 0.01, 1., 0.2, 1, false)\n    );\n}\n\nfloat sdfSky(float dO) {\n    return rB - dO;\n}\n\nvec3 sunPos() {\n    return zRotationMat(time()/20. * 2. * PI)/*yRotationMat(time() * 2. * PI) \n        * zRotationMat(0.4*PI)*/\n        * vec3(0., rB, 0.) + camPos();\n}\n\nfloat sdfSun(vec3 p) {\n    return distance(p, sunPos()) - 5.;\n}\n\nvec2 object(vec3 p, float dO) {\n    return identifyMin(\n        sdfRelief(p),\n        sdfMer(p),\n        sdfSky(dO),\n        sdfSun(p)\n    );\n} \n\nvec3 objectNormal(vec3 p, float dO) {\n   float eps = Epsilon;\n   vec3 n;\n   float v = object(p, dO).x;\n   n.x = object(vec3(p.x+eps, p.y, p.z), dO+eps).x - v;\n   n.y = object(vec3(p.x, p.y+eps, p.z), dO+eps).x - v;\n   n.z = object(vec3(p.x, p.y, p.z+eps), dO+eps).x - v;\n   return normalize(n);\n}\n\nvec2 Trace(vec3 ro, vec3 rd)\n{\n    float id = 10.;\n    float dO = rA;\n    int s;\n\n    for(s = 0; s < Steps; s++) {\n       vec3 p = ro+dO*rd;\n\n       vec2 obj = object(p, dO);\n       float ds = obj.x;\n       id = obj.y;\n\n       dO += ds*T;\n\n       if (ds < Epsilon) {\n           break;\n       }\n\n       if (dO > rB) break;\n    }\n\n    return vec2(dO, id);\n}\n\nfloat sunOscilator() {\n    // 1. at midnight -> 0. at noon\n    return 0.5+cos(time()/20.*2.*PI)*0.5;\n}\n\nvec3 lightColor() {\n    vec3 zenithColor = vec3(1., 0.95, 0.9);\n    vec3 coucherColor = vec3(0.7, 0.3, 0.5);\n    vec3 moonlightColor = vec3(0.2, 0.2, 0.25);\n    return mix(mix(\n        moonlightColor,\n        coucherColor,\n        smoothstep(0.45, 0.55, sunOscilator())\n    ),\n        zenithColor,\n        smoothstep(0.5, 0.85, sunOscilator())\n    );\n}\n\nvoid phong(vec3 p, vec3 n, inout vec3 c, float reflectAmount) {\n    vec3 cws = c;\n    vec3 pL = p + vec3(0., 0.1, 0.);\n    vec3 rd = normalize(sunPos() - pL);\n\n    float obstacle = Trace(pL, rd).y;\n    vec3 shadowColor = vec3(0.078, 0.047, 0.109);\n    if (obstacle == 1. || obstacle == 0.) {\n        cws = mix( // OMBRE PAR BLOCAGE\n            cws,\n            shadowColor,\n            0.95\n        );\n    } else {\n        cws = mix( // OMBRE PAR DOT PRODUCT\n            cws,\n            shadowColor,\n            1.-clamp(dot(n, rd), 0.05, 1.)\n        );\n        \n        cws = mix( // REFLECTION DE PHONG\n            cws,\n            lightColor(),\n            smoothstep(0.995, 1., dot(n, rd))*reflectAmount\n        );\n    }\n    \n    c = mix(c, cws, smoothstep(0.4, 0.6, sunOscilator()));\n}\n\nvec3 shadeSky(vec3 p, vec3 rd, float dO) {\n    vec3 c = mix(mix(\n        vec3(0.8, 0.9, 0.99), // ATHMOSPHERE\n        vec3(0.45, 0.78, 1.),\n        smoothstep(10., 50., p.y)\n    ),\n        lightColor()*4., // SUN\n        smoothstep(-0.2, 2., 1.-dot(rd, p-sunPos()))\n    );\n    \n    c *= lightColor();\n    \n    // STARS\n    vec3 n = normalize(p - camPos());\n    float a1 = mix(\n        0.,\n        turbulence(n.xz*100., 1.4, 0.5, 0.6, 1, false),\n        smoothstep(0., 60., distance(camPos().y, p.y))\n    );\n    vec3 cws = mix(\n        c,\n        vec3(0.9, 0.9, 0.85),\n        smoothstep(0.8, 1.9, a1)\n        *(1.-smoothstep(0.5, 0.85, sunOscilator()))\n    );\n    \n    // PLANET\n    if(rd.z > 0.9 ){\n        float rand = turbulence(p.xy, 3., 0.05, 1., 4, false);\n        vec3 pColor = vec3(0.5,0.3,0.4);\n        c = mix(mix(\n            c,\n            pColor * vec3(0.8, 0.8, 0.9),\n            smoothstep(-0.5, 0.3, rd.x+rd.y)\n        ),\n            pColor,\n            smoothstep(0., 1., rd.x+rd.y)\n        );\n    } else {\n        c = cws;\n    }\n    \n    // CLOUDS\n\n    return c;\n}\n\nvoid shadeFog(vec3 p, float dO, inout vec3 c) {\n    c = mix( // BOTTOM FOG\n        c,\n        vec3(0.45, 0.78, 1.)*lightColor(),\n        (1.-smoothstep(-1., 3., p.y))*0.3\n    );\n    \n    c = mix( // DISTANCE FOG\n        c,\n        vec3(0.807, 0.917, 0.992)*lightColor(),\n        smoothstep(rB*0.5, rB*0.9, dO)*0.3\n    );\n}\n\nvec3 shadeRelief(vec3 p, vec3 n, float dO) {\n    float rand = turbulence(p.xz, 3., 0.5, 0.5, 10, false);\n    float randY = p.y+(rand/40.);\n    \n    vec3 c = mix(mix(mix(mix(\n        vec3(0.55,0.52,0.48), // DIRT\n        vec3(0.35, 0.5, 0.45), // GRASS\n        smoothstep(0.1, 0.5, randY)\n        * smoothstep(0.7, 0.9, dot(n, vec3(0., 1., 0.)))\n    ),\n       vec3(0.45, 0.55, 0.5), // GRASS 2\n       smoothstep(0.5, 1., randY)\n       * smoothstep(0.8, 0.95, dot(n, vec3(0., 1., 0.)))\n    ),\n       vec3(0.8,0.8,0.85), // SNOW\n       smoothstep(3., 3.6, randY)\n       * smoothstep(0.85, 1., dot(n, vec3(0., 1., 0.)))\n    ),\n       vec3(0.7,0.7,0.6), // BEACH\n       -smoothstep(0.1, 0.2, randY)\n    );\n\n    float crbNiv = smoothstep(0.9, 1., sin(p.y*20.))/(dO*0.1);\n    c = mix(\n        c,\n        vec3(0.3, 0.3, 0.2),\n        crbNiv\n    );\n\n    phong(p, n, c, 0.05);\n    c *= lightColor();\n    \n    return c;\n}\n\nvec3 reflection(vec3 p, vec3 n, vec3 incRd) {\n    vec3 rd = normalize(reflect(incRd, n));\n    vec3 pL = p + rd*0.001;\n\n    vec2 traceResult = Trace(pL, rd);\n    float dO = traceResult.x;\n    float id = traceResult.y;\n    if (id == 1.) {\n        return vec3(0.0,0.29,0.52);\n    }\n\n    vec3 rayFinalPos = pL+dO*rd;\n    n = objectNormal(rayFinalPos, dO);\n    \n    vec3 reflC;\n    if (id == 3.) {\n        reflC = shadeSky(rayFinalPos, rd, dO);\n    } else if (id == 2.) {\n        reflC = shadeSky(rayFinalPos, rd, dO);\n    } else {\n        reflC = shadeRelief(rayFinalPos, n, dO);\n    }\n    \n    shadeFog(rayFinalPos, dO, reflC);\n\n    return reflC;\n}\n\nvec3 shadeSea(vec3 p, vec3 n, vec3 rd) {\n    vec3 c = reflection(p, n, rd);\n    \n    float sdfRelief = sdfRelief(p);\n    \n    // DEEP WATERS\n    c = mix(c, vec3(0., 0., 0.1), sdfRelief*0.04);\n    \n    // COASTAL WATERS\n    float coastDistAtt = clamp(1.-sdfRelief*2., 0., 1.);\n    float coastWaves = smoothstep(0., 1., sin(coastDistAtt*15.-time()*3.));\n    c = mix(\n        c,\n        vec3(1.),\n        coastDistAtt*coastWaves\n    );\n\n    phong(p, n, c, 0.6);\n    c *= lightColor();\n    \n    return c;\n}\n\nvec3 Shade(vec3 p, vec3 n, vec3 rd, float dO, float id)\n{\n    vec3 c;\n    if (id == 3.) {\n        c = shadeSky(p, rd, dO);\n    } else if (id == 2.) {\n        c = shadeSky(p, rd, dO);\n    } else if (id == 1.){\n        c = shadeSea(p, n, rd);\n    } else {\n        c = shadeRelief(p, n, dO);\n    }\n    \n    shadeFog(p, dO, c);\n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 mouse = iMouse / iResolution.x;\n\n    vec3 camPos = camPos();\n    float camAngleY = -0.15*PI+mouse.x*-2.*PI;\n    float camAngleX = ((mouse.y)*1.2*PI) - 0.3*PI;\n\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = vec3(aspectRatio*pixel.x, pixel.y, 1.5);\n\n    ro = camPos;\n    rd = (yRotationMat(camAngleY) * xRotationMat(camAngleX) * rd);\n    rd = normalize(rd);\n\n    vec2 traceResult = Trace(ro, rd);\n    float dO = traceResult.x;\n    float id = traceResult.y;\n\n    vec3 rayFinalPos = ro+dO*rd;\n    vec3 n = objectNormal(rayFinalPos, dO);\n    vec3 rgb = Shade(rayFinalPos, n, rd, dO, id);\n\n    fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}