{"ver":"0.1","info":{"id":"XdsyR7","date":"1487507148","viewed":392,"name":"Raytrace Animated by Raymarching","username":"pix","description":"A behind the scene's view of ray tracing - showing line-sphere intersection. Ray marching is used in this toy. A pixel is drawn when the ray intersects.  Move the position (x,y) of the sphere with the mouse (with any mouse button down) .","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","phongshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst int MAX_ITERATIONS = 512;\n\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float MAXLEN = 1000.0;\n\nfloat noise(vec3 n) { return sin(n.x+n.y+n.z); }\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat4 rotateY(float theta) {\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\treturn mat4(vec4(c,0,s,0),vec4(0,1,0,0),vec4(-s,0,c,0),vec4(0,0,0,1));\n}\n\n\nfloat sph( vec3 pos, float radius ) {\n float dist = length( pos ) - radius;\n\treturn dist;\n}\n\nfloat box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  float dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\treturn dist;\n}\n\nfloat linex(vec3 pos, float len) {\n\treturn box(pos, vec3(len, 0.01, 0.01));\n}\n\n\nfloat repsph(vec3 pos, vec3 c, float radius) {\n\n\t//vec3 q = mod(p,c)-0.5*c;\n\tvec3 q = mod(pos,c)-0.5*c;\n\treturn sph(q, radius);\n}\n\nfloat line( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// Ray origin and direction, sphere position and radius\nfloat sphereIntersect(in vec3 rayO, in vec3 rayD, in vec3 pos, in float radius)\n{\n\tvec3 oc = rayO - pos;\n\tfloat b = 2.0 * dot(oc, rayD);\n\tfloat c = dot(oc, oc) - radius*radius;\n\tfloat h = b*b - 4.0*c;\n\tif (h < 0.0)\n\t{\n\t\treturn -1.0;\n\t}\n\tfloat t = (-b - sqrt(h)) / 2.0;\n\n\treturn t;\n}\n\nfloat dist_field2( vec3 pos ) {\n float sceneSph = sph(pos + vec3(0.0, 0.0, 10), 1.5);\n return sceneSph;\n}\n\nfloat ray_marching2( vec3 origin, vec3 dir, float start, float end, out int iters, out float depthHistory[MAX_ITERATIONS]) {\n\n\tfloat depth = start;\n\n\tfor ( iters = 0; iters < MAX_ITERATIONS; iters++ ) {\n   depthHistory[iters] = depth;\n   vec3 p = origin + dir * depth;\n\t\tfloat dist = dist_field2( p );\n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nvec3 rayDir(vec2 p, vec3 ro, vec3 ta) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n  \treturn rd;\n}\n\nfloat mymod(int x, int y) {\n    return float(x)-float(y) * floor(float(x)/float(y));\n}\n\n\nfloat dist_field( vec3 pos ) {\n\tpos = (inverse(rotateY(iTime/20.0))*vec4(pos,1.0)).xyz;\n\n\tvec2 fres = vec2(16.0,16.0);  // Resolution\n\tivec2 ires = ivec2(int(fres.x),int(fres.y));  \n\tfloat pixelTime = iTime*1.5;\n  \tvec2 pixelXY = vec2(float(mymod(int(pixelTime), ires.x)),\n\t                \t\t\tfloat(mymod(int(pixelTime/fres.y), ires.y)))-vec2(fres.x/2.0,fres.x/2.0);\n    \n\t// The ray\n\tvec3 ro = vec3(0.0, 0.0, 20.0);\n  \tvec3 rayEnd = vec3(pixelXY, 0.0);\n  \tvec3 rd = normalize(rayEnd - ro);\n\n\tfloat mouseScale = 50.0;\n\tfloat ballZ = -6.0;\n\tvec3 ballPos = pos - vec3(mouseScale*(iMouse.xy/iResolution.xy-0.5), ballZ);\n\n\tfloat ballSize = 4.0;\n\tfloat ball = sph(ballPos, ballSize);\n\n\n\t#define EPSILON 0.0001\n\n  \tfloat scene = repsph(pos-vec3(1.0, 1.0, 0.0), vec3(1.,1.,0.0), 0.1);\n\n\tfloat horizon = box(pos-vec3(0.5, 0.5, 0.0), vec3(fres/1.4, 1.0));\n\tscene = max(scene, horizon);\n\n\tfloat currentPixel;\n\n\tfloat tSphere = sphereIntersect(ro, rd, vec3(mouseScale*(iMouse.xy/iResolution.xy-0.5), ballZ), ballSize);\n\n\tif (tSphere > 0.0)\n\t{\n\t\tcurrentPixel = box(pos - vec3(pixelXY.x, pixelXY.y, 0.0), vec3(0.5, 0.5, 0.05));\n\n\t} else currentPixel = MAXLEN;\n\n  scene = min(scene, currentPixel);\n\n\t#define INFINITY 1000000.0\n\n\tfloat ray = line(pos, ro, ro+rd*INFINITY, 0.05);\n\tscene = min(scene, ray);\n\tscene = min(scene,ball);\n\treturn scene;\n}\n\n\nconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\nconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\nconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\nvec3 gradient( vec3 pos ) {\n\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\n\t\t)\n\t);\n}\n\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end, out int iters ) {\n\n\tfloat depth = start;\n\n\tfor ( int iters = 0; iters < MAX_ITERATIONS; iters++ ) {\n   vec3 p = origin + dir * depth;\n\t\tfloat dist = dist_field( p );\n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n\nvec3 phongShading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\n\tfloat shininess = 16.0;\n\n\tvec3 final = vec3( 0.0 );\n\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\n\t\tvec3 vl = normalize( light_pos - v );\n\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\n\t\tfinal += light_color * ( diffuse + specular );\n\t}\n\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\n\t\tvec3 vl = normalize( light_pos - v );\n\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\n\t\tfinal += light_color * ( diffuse + specular );\n\t}\n\n\treturn final;\n}\n\nvoid mainImage( out vec4 o,vec2 uv )\n{\n\n\tvec2 q = gl_FragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tfloat distanceFromOrigin = 30.0;\n  \tfloat upInTheAir = -3.0;\n\tvec3 ro = vec3(0.0, upInTheAir, distanceFromOrigin); \n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n  \tvec3 rd = rayDir(p, ro, ta);\n\n\tint i = 0;\n\tfloat depth = ray_marching( ro, rd, 0.0, MAXLEN , i);\n\n\tif ( depth >= MAXLEN ) {\n\t\to = vec4( 0.0, 0.4, 0.5, 1.0 );\n\t} else {\n\tvec3 pos = ro + rd * depth;\n\tvec3 n = gradient( pos );\n\to = vec4( phongShading( pos, n, ro ), 1.0 );\n }\n}\n","name":"Image","description":"","type":"image"}]}