{"ver":"0.1","info":{"id":"4cGGzD","date":"1713060938","viewed":107,"name":"球面细分","username":"shadertoyjiang","description":"xi\n错误原因，有些不是正三角形。\n解决方法，使用传统的比较四个三个形距离。最后也用三条线画岀。","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["xi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// 2024年4月7日09时47分53秒\n// 球面细分\n\nint obj;\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// 2024年4月7日11时53分12秒\nfloat dln(vec3 a, vec3 b, vec3 p)\n{\n        b-=a; p-=a;\n        return length(p - b * clamp( dot(b,p)/dot(b,b), 0., 1.));\n}\n\n\n\n\n// 2024年4月7日18时09分21秒\n// 新法正二十面体\nfloat d20x(vec3 p)\n{\n        // 正二十面体的折叠，以及\n        vec3 v = sqrt(vec3(.5-.1*sqrt(5.), 0., .5+.1*sqrt(5.))),\n             w = vec3(sqrt(3.)/3.), // nor(1)\n             e = (v.zxy + v.yzx) * .5,\n             n = normalize(cross(cross(e, v), e));\n        for(int i;i++<9;n=n.yzx)\n                if(dot(p, n)<0.)\n                        p=reflect(p, n);\n        float d2 = dot(p-v,w)-.16; // 一次成功 2024年4月7日18时26分55秒\n        obj=1;\n        float d3 = length(p)-length(v)*1.0182;\n        if(d3<d2)obj=2;\n        d2=max(d2,d3);\n        /////////\n        // 2024年4月7日18时34分29秒\n        //float d = 999.;\n        //d = min(d, dln(v,    v.yzx));\n        //d = min(d, dln(v.yzx,v.zxy));\n        //d = min(d, dln(v.zxy,v    ));\n        //return d-.05;\n        //\n        /////////\n        // 2024年4月7日18时27分57秒\n        vec3 a,b,c, ab, bc,ca;\n        int N = 5;\n        a = normalize(v), b = a.yzx, c=a.zxy;\n        \n        // 迭代\n        for(int i;i<N;i++)\n        {\n                ab=normalize(a+b),  \n                bc=normalize(b+c), \n                ca=normalize(c+a);\n                if     (dot(p,  cross(ab,bc))>0.) a= b, b=bc, c=ab;\n                else if(dot(p,  cross(bc,ca))>0.) a= c, b=ca, c=bc;\n                else if(dot(p,  cross(ca,ab))>0.) a= a, b=ab, c=ca;\n                else                              a=ab, b=bc, c=ca;\n        }\n        \n        //vec3 u=dot(v,w)*w;\n        //length(vec2(length(p-u),)\n        \n        // 显示\n        float d = 1e8;\n        \n        d = min(d, dln(a,b,p));\n        d = min(d, dln(b,c,p));\n        d = min(d, dln(c,a,p));\n        d-= .007; //.001;//.006   ;// \n            //mix(.007,.002,  clamp(.5+1e2*sin(iTime),0.,1.));\n        //if(abs(d-q)<1e-6)obj=1;\n        if(d<d2)obj=0;\n        return d;//min(d,d2);\n}\n\n\n\n\n\n\n\n\n\n\n/*\n\n// 2024年4月7日15时38分26秒 写完\n// 17:08 成CC\nfloat xf2(vec3 p)\n\n{\n\n        vec3 I = vec3(1),\n\n             O = vec3(0.,sqrt(5.)*.5-.5,sqrt(5.)*.5+.5),\n\n             n[3],c[3],m[3],h,cc,ca,cb; \n\n        // 第一次折叠向量\n\n        h=normalize(I - O    );\n        /*\n        n[0] = normalize(I - O    ),\n\n        n[1] = normalize(I - O.yzx),\n\n        n[2] = normalize(I - O.zxy);\n        \n        for(int i,k;i<9;i++)\n\n        {\n\n                k=i % 3;\n\n                if(dot(p, n[k])<0.)p =reflect(p, n[k]);\n\n        }* /\n        \n        \n        for(int i,k;i++<9;h=h.yzx)\n        {\n                if(dot(p, h)<0.)p =reflect(p, h);\n        }\n\n        \n\n        // 第一中点\n\n        //cc=c[0] = .5*(I + O    ),\n\n        //c[1] = .5*(I + O.yzx),\n\n        //c[2] = .5*(I + O.zxy);\n        \n        \n        \n        cc =  .5*(I + O    );\n        \n        \n        \n\n        int N=  2  ;\n        for(int i;i++<N;)\n        {\n                //m = c;\n                //c[0]=normalize(m[0]+m[1]);\n                //c[1]=normalize(m[1]+m[2]);\n                //c[2]=normalize(m[2]+m[0]);\n                cc=normalize(cc+cc.yzx);\n        }\n        ca=cc.yzx,  cb=cc.zxy;\n        \n        \n        /*\n        float dv = sqrt(10.+2.*sqrt(5.))/4.;\n\n        float df = (3.*sqrt(3.)+sqrt(15.))/12.;\n\n        float de = (sqrt(5.)+1.)/4.;\n        * /\n        \n\n        //vec3 c3 =(c[0]+c[1]+c[2])/3.,dl = c[0],dc=c[0]-c3;\n\n        //n[0] = normalize(dc*dc/dl-dc);\n        \n        \n        //n[0]=normalize(cross(cross(c[0],c[1]+c[2]),c[0]));\n        h=normalize(cross(cross(cc,ca+cb),cc));\n        \n\n        //n[1] = n[0].yzx;\n\n        //n[2] = n[0].zxy;\n        /*\n        for(int i,k;i<3*N+0;i++)\n\n        {\n\n                k=i % 3;\n\n                if(dot(p, n[k])<0.)p =reflect(p, n[k]);\n\n        }* /\n        \n        for(int i,k;i++<3*N+9;h=h.yzx)\n        {\n                if(dot(p, h)<0.)p =reflect(p, h);\n        }\n        \n        \n        \n        \n\n        //float q ;//= length(p)-1.1;\n\n        //return dot(p, normalize(I))-3.;//,-q);\n        \n        \n        //O = cc;\n        vec3 f=normalize(ca-cb);\n\n        \n        if(dot(p, cc)<dot(p, ca))p = reflect(p, normalize(cc-ca)); // 加减？\n\n        if(dot(p, cc)<dot(p, cb))p = reflect(p, normalize(cc-cb));\n\n        \n        p-=cc;\n        \n        return length(  p-dot(p,f)*f  )-.07;\n        \n        \n\n}\n/*\nfloat d20(vec3 p)\n{\n        vec3 I = vec3(1),\n             O = vec3(0.,sqrt(5.)*.5-.5,sqrt(5.)*.5+.5),\n             n[3]; \n        n[0] = normalize(I - O    ),\n        n[1] = normalize(I - O.yzx),\n        n[2] = normalize(I - O.zxy);\n        for(int i,k;i<9;i++)\n        {\n                k=i % 3;\n                if(dot(p, n[k])<0.)p =reflect(p, n[k]);\n        }\n        float q = length(p)-2.1;\n        return min(length(p-I*1.2)-.5   ,max(dot(p, normalize(I))-2.,-q));\n}\n\n\n\n\nfloat xifen(vec3 p)\n{       vec3 pf=p;\n        vec3 n[3],m[3],\n             I=vec3(1),\n             O = vec3(0.,sqrt(5.)*.5-.5,sqrt(5.)*.5+.5);\n        n[0] = normalize(O    ),\n        n[1] = normalize(O.yzx),\n        n[2] = normalize(O.zxy);\n        m=n;\n        // 细分\n        \n        int N=0;\n        for(int i;i++<N;)\n        {\n                m = n;\n                n[0]=normalize(m[0]+m[1]);\n                n[1]=normalize(m[1]+m[2]);\n                n[2]=normalize(m[2]+m[0]);\n        }\n        // 求解球面上一小等边三角形的顶点长度 与 线中点长度a 的比值 x\n        float a = length(n[0]), b = length(n[1]-n[0]), X=sqrt(a*a+b*b)/a;\n        \n        m=n;\n        // 求两三角形面中面的法向量\n        for(int i;i<3;i++)n[i]=normalize(I/sqrt(3.)-n[i]);\n        \n        \n        // 折叠\n        for(int i,k;i<3*(1+N)*6;i++)\n        {\n                k=i % 3;\n                if(dot(p, n[k])<0.)p =reflect(p, n[k]);\n        }\n        \n        float df= dot(p, normalize(I))-.7;\n        \n        for(int i;i<3;i++)\n        df =min(df, length(pf-m[i]))-.03;\n        n=m;\n        O = n[0];\n        //p=pf;\n        if(dot(p, O)<dot(p, n[1]))p = reflect(p, normalize(O-n[1])); // 加减？\n        if(dot(p, O)<dot(p, n[2]))p = reflect(p, normalize(O-n[2]));\n        \n        p=p-O-I/sqrt(3.);\n        vec3 f=normalize(n[1]-n[2]);\n        df = min(df, length(p-dot(p,f)*f)-.08);\n        \n        \n        \n        //df= min(df, min(dln(m[0],m[1],p),min(dln(m[1],m[2],p),dln(m[2],m[0],p))))-.03;\n\n        //p=pf;\n        //df= min(df, min(dln(m[0],m[1],p),min(dln(m[1],m[2],p),dln(m[2],m[0],p))))-.03;\n\n        return df;\n\n}\n\n\n*/\n\n\n\n\nfloat map(vec3 p)\n{\n        //return length(p)-1.;\n        float t = iTime+7.;\n        p.xy *= rot(t   );\n        p.yz *= rot(t*.7);\n        p.zx *= rot(t*.3);\n        //return xifen(p);\n        //return xf2(p);\n        return d20x(p);\n}\n\n\n\n\n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        O = vec4(.5);\n        vec2 R = iResolution.xy,\n             u = (U+U - R) / R.y;\n        vec3 eye = vec3(0,0,-1.5),p,\n             r   = normalize(vec3(u,1)),\n             sun = 5.*(cos(iTime+vec3(7,11,13))+0.6*vec3(-1,2,-3)),//vec3(-1,2,-3)/3.74,\n             e   = vec3(0,.0001,0),\n             n;\n        float d , t;\n        for(int i;i++<128 && t<3.;)\n        {\n                p = eye+r*t;\n                d = map(p);\n                if(d<.001)\n                {\n                        //int objf=obj;\n                        // phong\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);//map(p));\n                        vec3 sp = normalize(sun-p),ep=normalize(eye-p);\n                        float ln = max(0., dot(n,sp)),              // light norm\n                              ey = max(0., dot(ep, reflect(-sp,n))); // eye ray\n                        // 其它：半程更好？\n                        float ambt=.3, difu=.6, spec=80.;\n                        vec4  lightClr= vec4(2,.5,0,1)*1.3;\n                        O = lightClr * (ambt + difu*ln + pow(ey, spec));\n                        \n                        \n                        //obj=objf;\n                        if(obj==0)O=.3*O; //*vec4(1.,6,.7,1) ;\n                        if(obj==2)O=1.*(.9-O);\n                        //else      O*=.5;\n                        // 其它 阴影，AO 等。多次反射等。多光源,菲，材\n                        break;\n                }\n                t+=d*.8;\n        }\n}\n","name":"Image","description":"","type":"image"}]}