{"ver":"0.1","info":{"id":"4sBczW","date":"1491057646","viewed":238,"name":"Fractal Introduction ","username":"soma_arc","description":"For Everybody One Motion.  #motiongraphics\nhttps://twitter.com/motions_work/status/848104067985428481","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot","sierpinski","schottky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nmat2 getRotationMat2(float angleRadians){\n\treturn mat2(cos(angleRadians), -sin(angleRadians),\n                sin(angleRadians), cos(angleRadians));\n}\n\nvec2 circleInvert(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;\n}\n\n\nconst mat2 UNI_MAT = mat2(1, 0, 0, 1);\n\nconst float PI = 3.1415926535;\nconst float PI_2 = 3.1415926535/2.;\nconst float PI_4 = 3.1415926535/4.;\n\nfloat LINE_THRESHOLD = 0.0001;\nvec3 getLine(vec2 p1, vec2 p2){\n    float xDiff = p2.x - p1.x;\n    float yDiff = p2.y - p1.y;\n    if(abs(xDiff) < LINE_THRESHOLD){\n        //x = c\n        return vec3(1, 0, p1.x);\n    }else if(abs(yDiff) < LINE_THRESHOLD){\n        //y = c\n        return vec3(0, 1, p1.y);\n    }else{\n        //y = ax + b\n        return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);\n    }\n}\n\nfloat calcX(vec3 line, float y){\n    if(line.z == 0.){\n        return (y - line.y) / line.x;\n    }else{\n        return line.z;\n    }\n}\n\nfloat calcY(vec3 line, float x){\n    if(line.z == 0.){\n        return line.x * x + line.y;\n    }else{\n        return line.z;\n    }\n}\n\nvec2 calcIntersection(vec3 line1, vec3 line2){\n    if(line1.z == 0. && line2.z == 0.){\n        float x1 = 1.;\n        float x2 = 5.;\n        float y1 = calcY(line1, x1);\n        float y2 = calcY(line1, x2);\n\n        float x3 = 4.;\n        float x4 = 8.;\n        float y3 = calcY(line2, x3);\n        float y4 = calcY(line2, x4);\n\n        float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );\n        float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );\n        float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );\n\n        float lambda = ksi / delta;\n        float mu    = eta / delta;\n        return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));\n    }else{\n        if(line1.x == 1.){\n            return vec2(line1.z, calcY(line2, line1.z));\n        }else if(line1.y == 1.){\n            return vec2(calcX(line2, line1.z), line1.z);\n        }else if(line2.x == 1.){\n            return vec2(line2.z, calcY(line1, line2.z));\n        }\n        return vec2(calcX(line1, line2.z), line2.z);\n    }\n}\n\nvoid calcContactCircles(const vec3 commonCircle,\n                        out vec3 c1, out vec3 c2, out vec3 c3, out vec3 c4){\n    vec2 p = commonCircle.xy + vec2(0, commonCircle.z);\n\tvec2 q = commonCircle.xy + vec2(-commonCircle.z, 0);\n\tvec2 r = commonCircle.xy + vec2(0, -commonCircle.z);\n\tvec2 s = commonCircle.xy + vec2(commonCircle.z, 0);\n    vec2 pqMid = (p + q)/2.;\n    vec2 u = (pqMid - commonCircle.xy)/distance(commonCircle.xy, pqMid);\n    vec2 a = u * commonCircle.z * (sin(4.3) * 6. + 6.72) + commonCircle.xy;\n    c1.xy = a;\n    c1.z = distance(a, p);\n\n    vec3 aq = getLine(a, q);\n    vec3 qrMidPer = getLine(commonCircle.xy, (q + r) / 2.);\n    vec2 b = calcIntersection(aq, qrMidPer);\n    c2.xy = b;\n    c2.z = distance(b, q);\n\n    vec3 br = getLine(b, r);\n    vec3 rsMidPer = getLine(commonCircle.xy, (r + s) / 2.);\n    vec2 c = calcIntersection(br, rsMidPer);\n    c3.xy = c;\n    c3.z = distance(c, r);\n\n    vec3 cs = getLine(c, s);\n    vec3 spMidPer = getLine(commonCircle.xy, (s + p) / 2.);\n    vec2 d = calcIntersection(cs, spMidPer);\n    c4.xy = d;\n    c4.z = distance(d, s);\n}\n\nfloat rect(vec2 p, vec2 center, vec2 size) {\n\tvec2 hs = size / 2.;\n    p -= center;\n    p = abs(p);\n    return max(p.x - hs.x, p.y - hs.y);\n}\n\nfloat rectFrame(vec2 p, vec2 center, vec2 size, float thickness) {\n    float outer = rect(p, center, size);\n    float inner = rect(p, center, size - vec2(thickness));\n    return max(outer, -inner);\n}\n\nfloat rectFrameCorner(vec2 p, vec2 center, vec2 size,\n                      float thickness, float cornerLen){\n\tfloat frame = rectFrame(p, center, size, thickness);\n    float vRect = rect(p, center, vec2(size.x - 2. * cornerLen, size.y * 2.));\n    float hRect = rect(p, center, vec2(size.x * 2., size.y - 2. * cornerLen));\n    return max(max(frame, -vRect), -hRect);\n}\n\nfloat mandelRect(vec2 p, vec2 center, vec2 size) {\n    vec2 hs = size / 2.;\n    p -= center;\n    vec2 c = (p / hs - vec2(0.5, 0)) * 1.2;\n    vec2 pabs = abs(p);\n    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;\n    \n    vec2 z = vec2(0);\n    for(int i = 0 ; i < 256; i++){\n    \tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if( dot(z, z) > 4.0 ){\n        \treturn 1000.;\n        }\n    }\n    return -1.;\n    \n}\n\nfloat juliaRect(vec2 p, vec2 center, vec2 size) {\n    vec2 hs = size / 2.;\n    p -= center;\n    vec2 z = (p / hs) * 1.5;\n    vec2 pabs = abs(p);\n    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;\n    \n    vec2 c = vec2(-0.618, 0.);\n    for(int i = 0 ; i < 1024; i++){\n    \tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n\n        if( dot(z, z) > 4.0){\n        \treturn 1000.;\n        }\n    }\n    return -1.;\n}\n\nfloat shipRect(vec2 p, vec2 center, vec2 size) {\n    vec2 hs = size / 2.;\n    p -= center;\n    vec2 c = (p / hs) * 1.5;\n    vec2 pabs = abs(p);\n    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;\n    \n    vec2 z = vec2(0.);\n    for(int i = 0 ; i < 1024; i++){\n        z = abs(z);\n    \tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n\n        if( dot(z, z) > 4.0){\n        \treturn 1000.;\n        }\n    }\n    return -1.;\n}\n\nfloat gasketRect(vec2 p, vec2 center, vec2 size){\n    vec2 hs = size / 2.;\n    p -= center;\n    vec2 z = (p / hs) * 1.;\n    vec2 pabs = abs(p);\n    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;\n    \n\tvec2 a1 = vec2(0,1);\n\tvec2 a2 = vec2(-1,-1);\n\tvec2 a3 = vec2(1,-1);\n\tvec2 c;\n\tfloat dist, d;\n    float Scale = 2.;\n    const int maxN = 8;\n\tfor (int n = 0 ; n < maxN ; n++) {\n\t\t c = a1; dist = length(z-a1);\n\t     d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\tz = Scale*z-c*(Scale-1.0);\n\t}\n\n\treturn length(z) * pow(Scale, -float(maxN)) - 0.01;\n}\n\nfloat mengerRect(vec2 p, vec2 center, vec2 size){\n    vec2 hs = size / 2.;\n    p -= center;\n    vec2 z = (p / hs) * 1.;\n    vec2 pabs = abs(p);\n    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;\n    \n\tvec2 a1 = vec2(-1.,1);\n\tvec2 a2 = vec2(-1,-1);\n\tvec2 a3 = vec2(1,-1);\n    vec2 a4 = vec2(1, 1);\n\tvec2 c;\n\tfloat dist, d;\n    float Scale = 2.;\n    const int maxN = 8;\n\tfor (int n = 0 ; n < maxN ; n++) {\n\t\t c = a1; dist = length(z-a1);\n\t     d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n\n        z = Scale*z-c*(Scale-1.0);\n\t}\n\n\treturn length(z) * pow(Scale, -float(maxN)) - 0.01;\n}\n\n\nvec3 g_c1 = vec3(100, 100, 100);\nvec3 g_c2 = vec3(100, -100, 100);\nvec3 g_c3 = vec3(-100, 100, 100);\nvec3 g_c4 = vec3(-100, -100, 100);\n\n\nconst int MAX_ITERATIONS = 20;\nfloat iisRect(vec2 p, vec2 center, vec2 size){\n    vec2 hs = size / 2.;\n    p -= center;\n    vec2 pos = (p / hs) * 240.;\n    vec2 pabs = abs(p);\n    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;\n    \n    float invNum = 0.;\n    bool inFund = true;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        inFund = true;\n        if (distance(pos, g_c1.xy) < g_c1.z) {\n            pos = circleInvert(pos, g_c1);\n            inFund = false;\n            invNum++;\n        } else if (distance(pos, g_c2.xy) < g_c2.z) {\n            pos = circleInvert(pos, g_c2);\n            inFund = false;\n            invNum++;\n        } else if (distance(pos, g_c3.xy) < g_c3.z) {\n            pos = circleInvert(pos, g_c3);\n            inFund = false;\n            invNum++;\n        } else if (distance(pos, g_c4.xy) < g_c4.z) {\n            pos = circleInvert(pos, g_c4);\n            inFund = false;\n            invNum++;\n        }\n        if (inFund) break;\n    }\n\n    if(mod(invNum, 2.) == 0.) return 100.;\n    return -1.;\n}\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\n\nfloat decoratedFrame(vec2 pos, vec2 center, vec2 size,\n                     float thickness, float cornerLen) {\n\tfloat d = rectFrameCorner(pos, center, size, thickness, cornerLen);\n    d = min(d, rectFrameCorner(pos, center,\n                               size * 1.1, thickness, cornerLen * 0.75));\n    d = min(d, rectFrameCorner(pos, center, \n                               size * 1.1 * 1.1, thickness, cornerLen * 0.75 * 0.75));\n    return d;\n}\n\nvec3 sceneCol(vec2 pos, float t, float stepTime) {\n    /*\n\tfloat d = rectFrameCorner(pos, vec2(0), vec2(150, 150), 10., 20.);\n    d = min(d, rectFrameCorner(pos, vec2(0), vec2(165, 165), 10., 15.));\n    d = min(d, rectFrameCorner(pos, vec2(0), vec2(180, 180), 10., 10.));*/\n\n    float gasketStart = 0.;\n    float gasketX = mix(250., 0., circEasingIn(scene(t, gasketStart, stepTime)));\n    gasketX += mix(0., -250., \n                   circEasingIn(scene(t, gasketStart + 2. * stepTime, stepTime)));\n    \n        \n    float mandelStart = gasketStart + 3. * stepTime;\n    float mandelX = mix(250., 0., \n                        circEasingIn(scene(t, mandelStart, stepTime)));\n    mandelX += mix(0., -250., \n                   circEasingIn(scene(t, mandelStart + 2. * stepTime, stepTime)));\n    \n    \n    float circlesStart = mandelStart + 3. * stepTime;\n    float circlesX = mix(250., 0., \n                       circEasingIn(scene(t, circlesStart, stepTime)));\n    circlesX += mix(0., -250.,\n                  circEasingIn(scene(t, circlesStart + 2. * stepTime, stepTime)));\n\t\n\n    \n    float frameStart = circlesStart + 3. * stepTime;\n    float frameX = mix(250., 0., circEasingIn(scene(t, frameStart, stepTime)));\n    //frameX += mix(0., -250., circEasingIn(scene(t, 5.5, .5)));\n    \n    float frameScaleStep = stepTime / 3.;\n    float frameScaleDelay = stepTime / 5.;\n    float scale = 1.\n        + mix(0., 0.1, scene(t, gasketStart + 2. * stepTime - frameScaleDelay, frameScaleStep))\n        + mix(0., -0.1, scene(t, gasketStart + 2. * stepTime- frameScaleDelay + frameScaleStep, frameScaleStep))\n        + mix(0., 0.1, scene(t, mandelStart + 2. * stepTime - frameScaleDelay, frameScaleStep))\n        + mix(0., -0.1, scene(t, mandelStart + 2. * stepTime- frameScaleDelay + frameScaleStep, frameScaleStep))\n        + mix(0., 0.1, scene(t, circlesStart + 2. * stepTime - frameScaleDelay, frameScaleStep))\n        + mix(0., -0.1, scene(t, circlesStart + 2. * stepTime- frameScaleDelay + frameScaleStep, frameScaleStep))\n        + mix(0., 1., \n          \tcircEasingIn(scene(t, frameStart + 2. * stepTime, stepTime)));\n    mat2 m = getRotationMat2(mix(0., radians(90.),\n                            \tcircEasingIn(scene(t, frameStart + 2. * stepTime, stepTime))));\n\n    \n    float d = 9999999.;\n    d = min(d, mandelRect(pos, vec2(mandelX, 0), vec2(140, 140)));\n    d = min(d, iisRect(pos, vec2(circlesX, 0), vec2(100, 100)));\n    d = min(d, gasketRect(pos, vec2(gasketX, 0), vec2(100, 100)));\n    //d = min(d, mengerRect(pos, vec2(-50, 0), vec2(100, 100)));\n    \n    pos = m * pos;\n    pos /= scale;\n    d = min(d, decoratedFrame(pos, vec2(frameX, 0), vec2(75, 75), 5., 10.));\n\td = min(d, decoratedFrame(pos, vec2(0), vec2(150, 150), 10., 20.));\n    \n  \tif(d < 0.) return vec3(0);\n    return vec3(1);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    calcContactCircles(vec3(0, 0, 100.), g_c1, g_c2, g_c3, g_c4);\n    vec3 sum = vec3(0);\n    float stepTime = 0.48;\n    float t = mod(iTime, stepTime * 13.);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n\tfloat scaleFactor = 200.;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        \n        position = position * scaleFactor;\n        position = position;\n        \n    \tsum += sceneCol(position, t, stepTime);\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n","name":"Image","description":"","type":"image"}]}