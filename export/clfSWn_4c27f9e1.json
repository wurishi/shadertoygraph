{"ver":"0.1","info":{"id":"clfSWn","date":"1674859792","viewed":163,"name":"Trig & sqrt grid","username":"ChunderFPV","description":"Hybrid unit circle with square root grid. Updated June 29 2023.\n\nKey toggles:\nS: snapping & sqrt grid\nC: hybrid or standard trig\nM: metallic ratio circle","likes":7,"published":1,"flags":16,"usePreview":0,"tags":["grid","math","circle","trigonometry","roots","unit","metallic","fractions","ratios"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define L(p1,p2) smoothstep(px*3., 0., sdLine(u, p1, p2))    // line\n#define L2(x) smoothstep(1.5*fwidth(x), 0., abs(x))\n#define RND(n) ((abs(n) > 1.) ? round(n): 1./round(1./(n)))  // round to n or 1/n\n#define KT(i) texelFetch(iChannel0, ivec2(i, 2), 0).x        // key toggle\n\nfloat G(float x) // grid\n{\n    x = max(abs(x), 1./abs(x)); // reciprocals\n    return max(0., 1.-(abs(fract(x+.5)-.5)/fwidth(x)/1.5)) // lines\n         / sqrt(max(1., abs(x))) // darken\n         * .4; // brightness\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    return length(pa - ba*clamp(dot(pa,ba)/dot(ba,ba), 0., 1.));\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float S = 5.; // scale\n    bool key_s = KT(83) < 1.,\n         key_c = KT(67) > 0.,\n         key_m = KT(77) < 1.;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*S, // mouse coords\n         u = (U-.5*R)/R.y*S,         // screen coords\n         g = abs(fract(u+.5)-.5)/fwidth(u)/1.5; // xy grid\n    float x = u.x,\n          y = u.y,\n          px = length(fwidth(u))/1.414, // pixel radius\n          r = length(u),  // screen radius\n          xp = sign(m.x), // x polarity\n          yp = sign(m.y), // y polarity\n          l = 1e3,        // max line length\n          ma, ms, mc, mt, n, d, met;\n    \n    // snap to fractional sqrt\n    if (key_s)\n    {\n        m.x = sqrt(RND(m.x*m.x))*xp;\n        m.y = sqrt(RND(m.y*m.y))*yp;\n    }\n    \n    // values from mouse\n    ma = atan(m.y, m.x);\n    ms = sin(ma);\n    mc = cos(ma);\n    mt = m.y/m.x; // tan(ma)\n    \n    // colors\n    vec3 c     = vec3(0),\n         c_x   = vec3(.6, .4, .9),\n         c_y   = vec3(.8, .6, .1),\n         c_arc = vec3(.0, .9, .0),\n         c_sin = vec3(.9, .0, .0),\n         c_cos = vec3(.0, .5, .9),\n         c_tan = vec3(.9, .7, .6),\n         c_csc = vec3(.9, .6, .9),\n         c_sec = vec3(.1, .7, .7),\n         c_cot = vec3(.9, .6, .0),\n\t\t c_met = vec3(.7, .8, .9);\n    \n    // int grid\n    c += max(0., 1.-min(g.x, g.y))*.3;    // lines\n    c += max(0., 1.-max(g.x, g.y)/2.)*.5; // points\n    \n    // sqrt grids\n    if (key_s)\n    {\n        c += G( x*x );\n        c += G( y*y );\n        c += G( (x*x)/(y*y) );\n    }\n    \n    // unit circle\n    c += L2(1.-r)*.25;\n    c += pow(min(r, 1./r), 4.)*.25; // glow\n    \n    c = max(c, L(vec2(0), vec2(m))*.5); // radial to mouse xy\n    c = max(c, L2(1.-r)*step(1., ma/atan(y,x))*c_arc); // arc length\n    c = max(c, L(vec2(0, ms), vec2(mc, ms))*c_cos); // cos\n    c = max(c, L(vec2(mc, 0), vec2(mc, ms))*c_sin); // sin\n    \n    if (key_c) // standard\n    {\n        c = max(c, L(vec2(0), vec2(1./mc, 0))*c_sec); // sec\n        c = max(c, L(vec2(0), vec2(0, 1./ms))*c_csc); // csc\n        c = max(c, L(vec2(mc, ms), vec2(0, 1./ms))*c_cot); // cot\n        c = max(c, L(vec2(mc, ms), vec2(1./mc, 0))*c_tan); // tan\n    }\n    else // hybrid\n    {\n        c = max(c, L(vec2(0, m.y), vec2(m))*c_x); // x\n        c = max(c, L(vec2(m.x, 0), vec2(m))*c_y); // y\n        c = max(c, L(vec2(0), vec2(xp, min(l, mt/xp)))*c_sec); // sec\n        c = max(c, L(vec2(0), vec2(min(l, yp/mt), yp))*c_csc); // csc\n        c = max(c, L(vec2(0, yp), vec2(min(l, yp/mt), yp))*c_cot); // cot\n        c = max(c, L(vec2(xp, 0), vec2(xp, min(l, mt*xp)))*c_tan); // tan\n    }\n    \n    if (key_m) // metallic circle\n    {\n        n = 1./mt; // cot\n        d = sqrt(n*n+4.); // diameter\n        met = (n+d)/2.; // metallic ratio\n        r = length(vec2(x-n/2., y)) / d*2.; // circle coords\n        c = max(c, L2(1.-r)*c_met); // circle\n        c = max(c, L2(u.y)*step(1., met/u.x)*c_met); // dist from 0 to ratio\n    }\n    \n    C = vec4(c*sqrt(c)*1.4, 1);\n}","name":"Image","description":"","type":"image"}]}