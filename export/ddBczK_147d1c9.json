{"ver":"0.1","info":{"id":"ddBczK","date":"1687897654","viewed":59,"name":"three blobbies in a blobbifixion","username":"Tygrak","description":"blobby weird volumetric stuff","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 _cameraStartPos = vec3(0.0, 0.1, -35.0);\nconst int _maxIterations = 1024;\nconst float _maxDistance = 500.0;\nconst float EPS = 0.005;\nconst float GLOWY_MAT = -1.0;\n\n//start taken from template by Giraugh -- https://www.shadertoy.com/view/wlXBW8\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nvec3 MouseCameraOrigin(vec3 rayOrigin) {\n\tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayOrigin.yz *= Rot(rotY);\n    rayOrigin.xz *= Rot(rotX);\n\treturn rayOrigin;\n}\n\nvec3 MouseCameraDirection(vec3 rayDirection) {\n \tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayDirection.yz *= Rot(rotY);\n    rayDirection.xz *= Rot(rotX);\n    rayDirection = normalize(rayDirection);\n\treturn rayDirection;\n}\n//end taken from template by Giraugh -- https://www.shadertoy.com/view/wlXBW8\n\n\nstruct RayHit {\n\tvec3 p;\n\tfloat t;\n    int it;\n\tvec4 col;\n};\n\nstruct SDFResult {\n\tfloat d;\n    vec4 col;\n};\n\nconst RayHit MissedRayHit = RayHit(vec3(10000000000.0), 10000000000.0, -1, vec4(0.0));\n\nfloat opSMin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n\nvec2 opSMinColor(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    if (a < b) {\n        return vec2(a-s, m);\n    } else {\n        return vec2(b-s, 1.0-m);\n    }\n}\n\nvec3 opRep(vec3 p, float interval) {\n    vec2 q = mod(p.xz, interval) - interval * 0.5;\n    return vec3(q.x, p.y, q.y);\n}\n\nvec3 opToSphericalCoords(vec3 p) {\n    float r = length(p);\n    float theta = acos(p.z/r);\n    float phi = sign(p.y)*acos(p.x/length(vec2(p.x, p.y)));\n    return vec3(r, theta, phi);\n}\n\nvec3 opFromSphericalCoords(vec3 p) {\n    float r = length(p);\n    float theta = acos(p.z/r);\n    float phi = sign(p.y)*acos(p.x/length(vec2(p.x, p.y)));\n    return vec3(p.x*sin(p.y)*cos(p.z), p.x*sin(p.y)*sin(p.z), p.x*cos(p.y));\n}\n\nfloat dSphere(vec3 p, vec3 center, float radius) {\n    return length(p-center)-radius;\n}\n\nfloat dBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}\n\nfloat dCylinder(vec3 p, in vec3 c) {\n    p = p+vec3(c.x, 0, c.z);\n    return length(p.xz-c.xy)-c.z;\n}\n\nbool isMissedHit(RayHit hit) {\n    return (MissedRayHit.p == hit.p) && (MissedRayHit.t == hit.t);\n}\n\nSDFResult dScene(vec3 p) {\n    vec4 col = vec4(0.2, 0.8, 0.2, 2.0);\n    float d = 1000000.0;\n    //d = dSphere(p, vec3(0.0, -505.0, 0.0), 500.0);\n    vec3 pWeird = p;\n    //vec3 pWeird = opToSphericalCoords(p);\n    //pWeird = opFromSphericalCoords(vec3(pWeird.x+sin(iTime*0.17), pWeird.y+(iTime*0.25+p.x*0.001), pWeird.z+(iTime*0.333)));\n    float bigBall = dSphere(p, vec3(0.0), 16.0);\n    bigBall += abs(sin(p.x*1.7+iTime*0.03)*1.7+cos(p.z*1.37+iTime*0.037)*1.7+cos(p.y*0.7+iTime*0.057)*1.7);\n    bigBall += sin(length(p.xy)*sin(iTime*0.017)+length(p.xz)*sin(iTime*0.017)+length(p.yz)*sin(iTime*0.017)+iTime*0.05137);\n    d = bigBall;\n    col = vec4(0.125, 0.125, 0.125, 0.0)*(sin(iTime+bigBall*4.0)*0.5+0.5);\n    float ball1 = dSphere(pWeird, vec3(2.0-sin(iTime*0.5)*3.5, 0.0, 1.25), 6.0);\n    ball1 += sin(1.0*p.x+iTime*0.71)*sin(1.3*p.y+iTime*0.51)*sin(1.1*p.z+iTime*0.47);\n    ball1 += sin(p.x*sin(iTime)+p.z*cos(iTime))*0.25;\n    float ball2 = dSphere(pWeird, vec3(-2.0+sin(iTime*0.5)*3.5, 0.0, 1.25), 6.0);\n    ball2 += sin(1.0*p.x+iTime*0.271)*sin(1.2*p.y+iTime*0.91)*sin(1.0*p.z+iTime*0.357);\n    ball2 += sin(p.y*sin(iTime)+p.z*cos(iTime))*0.25;\n    float ball3 = dSphere(pWeird, vec3(0.0, 0.0, -2.5+sin(iTime*0.5)*3.5), 6.0);\n    ball3 += sin(0.8*p.x+iTime*0.371)*sin(0.7*p.y+iTime*0.31)*sin(1.4*p.z+iTime*0.757);\n    ball3 += sin(p.x*sin(iTime)+p.y*cos(iTime))*0.25;\n    vec2 smoothBalls = opSMinColor(ball1, ball2, 0.75);\n    if (smoothBalls.x < 0.0) {\n        col = mix(vec4(0.8, 0.8, 0.2, GLOWY_MAT), vec4(0.2, 0.8, 0.8, GLOWY_MAT), smoothBalls.y);\n    }\n    smoothBalls = opSMinColor(smoothBalls.x, ball3, 0.75);\n    if (smoothBalls.x < 0.0) {\n        col = mix(col, vec4(0.8, 0.2, 0.8, GLOWY_MAT), smoothBalls.y)*(sin(iTime+smoothBalls.x*4.0)*0.15+0.85);\n    }\n    //col *= vec4(pWeird, 1.0);\n    return SDFResult(d, col);\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        dScene(p + vec3(EPS, 0.0, 0.0)).d - dScene(p + vec3(-EPS, 0.0, 0.0)).d,\n        dScene(p + vec3(0.0, EPS, 0.0)).d - dScene(p + vec3(0.0, -EPS, 0.0)).d,\n        dScene(p + vec3(0.0, 0.0, EPS)).d - dScene(p + vec3(0.0, 0.0, -EPS)).d\n    ));\n}\n\nRayHit rayMarch(vec3 from, vec3 direction, float maxt) {\n\tRayHit result = MissedRayHit;\n\tfloat t = 0.0;\n\tfor (int iteration = 0; iteration < _maxIterations; iteration++) {\n        result.it = iteration;\n\t\tif (t > maxt) {\n\t\t\treturn result;\n\t\t}\n\t    vec3 p = from+t*direction;\n        SDFResult res = dScene(p);\n        float d = res.d;\n\t\tif (d < 0.025) {\n            float colMod = 0.5;\n            /*float colMod = abs(sin(p.x*p.z*p.y*2.5+iTime*1.7)*0.5\n                +sin(p.x*p.z*4.5+iTime*3.7)*0.4\n                +sin(p.y*p.z*4.5+iTime*2.7)*0.4\n                +sin(p.y*p.z*4.5+iTime*1.7)*0.4);\n            colMod = clamp(0.8, 1.0, colMod*0.5);*/\n            result.col += res.col*0.005*colMod*clamp(0.0, 1.0, abs(d));\n\t\t\tresult.p = p;\n\t\t\tresult.t = t;\n            t = t+0.025;\n\t\t} else {\n            t = t+d;\n        }\n\t}\n\treturn result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 rayOrigin = MouseCameraOrigin(_cameraStartPos);\n    vec3 rayDirection = normalize(MouseCameraDirection(vec3(uv.x, uv.y, 1)));\n    \n    vec3 col = vec3(0.0);\n    float iterationsAcc = 0.0;\n    float distanceAcc = 0.0;\n    for (int i = 0; i < 1; i++) {\n        RayHit result = rayMarch(rayOrigin, rayDirection, _maxDistance-distanceAcc);\n        iterationsAcc += float(result.it);\n        distanceAcc += result.t;\n        \n        if (isMissedHit(result)) {\n            //col += mix(vec3(0.1, 0.1, 0.6), vec3(0.0), 0.5+0.5*rayDirection.y);\n            break;\n        } else {\n            col += result.col.xyz*(1.0-float(i)/5.0);\n            vec3 n = getNormal(result.p);\n            if (result.col.a < 1.0) {\n                /*if (result.col.a == GLOWY_MAT) {\n                    float fresnel = 1.0-clamp(pow(dot(normalize(n), -rayDirection), 0.5), 0.0, 1.0);\n                    col += col*fresnel;\n                }*/\n                break;\n            } else {\n                rayDirection = normalize(reflect(rayDirection, n));\n                rayOrigin = result.p+rayDirection*0.1;\n            }\n        }\n    }\n    \n    //iterations glow\n    //col += vec3(iterationsAcc/100.0);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}