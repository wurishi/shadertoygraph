{"ver":"0.1","info":{"id":"cdK3zV","date":"1678850345","viewed":134,"name":"automata volume","username":"Carandiru","description":"An experiment with cellular automata and a 3D texture, referencing a bacterial growth ruleset.","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["volume","automata","cellular","textture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [automata volume]\n// \n// -interpolated between t0 volume and t1 volume (smooth) \n// -time controllable\n// -volumetric data\n\n// -tweak speed and scale in common tab\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 t0 = textureLod(iChannel0, uv, 0.0f);\n    vec4 t1 = textureLod(iChannel1, uv, 0.0f); //*ooops\n    \n    vec4 color = mix(t0, t1, fract(iTime));\n    color.rgb *= color.a;\n    \n    // color style\n    color.rgb = color.grb * vec3(1.0f, 0.15f, 0.35f);\n    // saturation\n    color.rgb *= color.rgb;\n    \n    // gamma\n    fragColor = vec4(pow(color.rgb, vec3(1.0f/2.2f)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TTT (0.0)\n\n// 26 neighbours + self at i==13 (*compiletime* offset)\n#define next_neighbour_offset(i) (ivec3((i / 9) - 1, (i / 3 % 3) - 1, (i % 3) - 1))\n\n#define T(i) (nbr[i] = textureLodOffset(iChannel1, uvw, 0., next_neighbour_offset(i)).r)\n\nvec3 rand23(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rgb ); \n}\nvec2 rand22(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rg ); \n}\nint rand21(vec2 uv, float maxi){ \n\n   return( int(textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).r * maxi) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 unit = 1.0f / iChannelResolution[1].xyz;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float nbr[27] = float[27](0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f);\n\n    float state = 0.0f;\n    \n    vec3 uvw;\n    if ( iFrame < 32 ) {\n        uv = uv * 2.0f - 1.0f;\n        \n        uvw = sqrt(vec3(uv.x*uv.x, uv.y*uv.y, TTT));\n        uvw = uvw * 2.0f - 1.0f;\n        \n        state = textureLod(iChannel1, uvw, 0.).r;\n\n        uvw = uvw * vec3(iResolution.xy, length(iResolution.xy));\n        uvw = uvw * unit;\n        uvw *= SCALE;\n    }\n    else {\n        vec4 samp = textureLod(iChannel0, uv, 0.0f);\n        uvw = samp.xyz * 2.0f - 1.0f;\n        // time controllable\n        state = mix(samp.w, textureLod(iChannel1, vec3(uvw.xy, uvw.z + (iTime + TTT) * SPEED * 5.0f), 0.).r, 0.5f);\n    }\n    \n    // unrolled and compile time constant for offset generated. skip 13, self.\n    T(0);  T(1);  T(2);  T(3);  T(4);  T(5);  T(6);  T(7);  T(8);\n    T(9);  T(10); T(11); T(12); T(14); T(15); T(16); T(17); T(18);\n    T(19); T(20); T(21); T(22); T(23); T(24); T(25); T(26); // 26 texel\n    \n    nbr[13] = nbr[26]; // to iterate only neighbours in array - 1\n    \n    float count = 0.0f;\n    for (int i = 0 ; i < 26 ; ++i) {\n    \n        count += ceil(nbr[i] - 0.5f);\n    }\n        \n    if (state - 0.5f >= 0.0f) { // On is >= 0.5f\n    \n        if (0.0f == (count - 26.0f)) {\n            // completely surrounded, survive\n        }\n        else {\n        \n            if (count - 1.0f >= 0.0f) { // have at least one non-empty neighbour\n              // do nothing, survive\n              state -= count / 26.0f * iTimeDelta;\n            }\n            else {\n                // die off\n                state = 0.0f;\n            }\n        }\n    }\n    else if (0.0f != (count - 26.0f)) { // not current on & has empty neighbour\n        // copy a neighbour \n        do {\n        \n            int n = max(0, int(count) - 1);\n            \n            if (nbr[n] - 0.5f >= state) { // On is >= current state\n                uvw = uvw + vec3(next_neighbour_offset(n)) * unit * iTimeDelta;\n                state = nbr[n];\n                break; // found a neighbour to copy\n            }\n            \n            --count;\n        }\n        while(count >= 0.0f);\n    }\n\n    fragColor = vec4(uvw * 0.5f + 0.5f, state);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define TTT (1.0)\n\n// 26 neighbours + self at i==13 (*compiletime* offset)\n#define next_neighbour_offset(i) (ivec3((i / 9) - 1, (i / 3 % 3) - 1, (i % 3) - 1))\n\n#define T(i) (nbr[i] = textureLodOffset(iChannel1, uvw, 0., next_neighbour_offset(i)).r)\n\nvec3 rand23(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rgb ); \n}\nvec2 rand22(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rg ); \n}\nint rand21(vec2 uv, float maxi){ \n\n   return( int(textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).r * maxi) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 unit = 1.0f / iChannelResolution[1].xyz;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float nbr[27] = float[27](0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f);\n\n    float state = 0.0f;\n    \n    vec3 uvw;\n    if ( iFrame < 32 ) {\n        uv = uv * 2.0f - 1.0f;\n        \n        uvw = sqrt(vec3(uv.x*uv.x, uv.y*uv.y, TTT));\n        uvw = uvw * 2.0f - 1.0f;\n        \n        state = textureLod(iChannel1, uvw, 0.).r;\n\n        uvw = uvw * vec3(iResolution.xy, length(iResolution.xy));\n        uvw = uvw * unit;\n        uvw *= SCALE;\n    }\n    else {\n        vec4 samp = textureLod(iChannel0, uv, 0.0f);\n        uvw = samp.xyz * 2.0f - 1.0f;\n        // time controllable\n        state = mix(samp.w, textureLod(iChannel1, vec3(uvw.xy, uvw.z + (iTime + TTT) * SPEED * 5.0f), 0.).r, 0.5f);\n    }\n    \n    // unrolled and compile time constant for offset generated. skip 13, self.\n    T(0);  T(1);  T(2);  T(3);  T(4);  T(5);  T(6);  T(7);  T(8);\n    T(9);  T(10); T(11); T(12); T(14); T(15); T(16); T(17); T(18);\n    T(19); T(20); T(21); T(22); T(23); T(24); T(25); T(26); // 26 texel\n    \n    nbr[13] = nbr[26]; // to iterate only neighbours in array - 1\n    \n    float count = 0.0f;\n    for (int i = 0 ; i < 26 ; ++i) {\n    \n        count += ceil(nbr[i] - 0.5f);\n    }\n        \n    if (state - 0.5f >= 0.0f) { // On is >= 0.5f\n    \n        if (0.0f == (count - 26.0f)) {\n            // completely surrounded, survive\n        }\n        else {\n        \n            if (count - 1.0f >= 0.0f) { // have at least one non-empty neighbour\n              // do nothing, survive\n              state -= count / 26.0f * iTimeDelta;\n            }\n            else {\n                // die off\n                state = 0.0f;\n            }\n        }\n    }\n    else if (0.0f != (count - 26.0f)) { // not current on & has empty neighbour\n        // copy a neighbour \n        do {\n        \n            int n = max(0, int(count) - 1);\n            \n            if (nbr[n] - 0.5f >= state) { // On is >= current state\n                uvw = uvw + vec3(next_neighbour_offset(n)) * unit * iTimeDelta;\n                state = nbr[n];\n                break; // found a neighbour to copy\n            }\n            \n            --count;\n        }\n        while(count >= 0.0f);\n    }\n\n    fragColor = vec4(uvw * 0.5f + 0.5f, state);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SPEED (0.0004) // order of magnitudes - lower values result in higher resolution, and vice versa   \n                       // the speed at which the scene animation is increased wih higher values, \"\"  \"\"  \"\"\n          \n#define SCALE (0.00175)","name":"Common","description":"","type":"common"}]}