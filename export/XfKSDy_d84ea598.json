{"ver":"0.1","info":{"id":"XfKSDy","date":"1715710661","viewed":124,"name":"Black Hole ODE Geodesic Solver","username":"KexxAlex","description":"Calculates the inflection of a light ray with numerical methods for schwarzschild metric","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","blackhole","pde","geodesic","ode","schwarzschild"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\n\nfloat newton( in float alpha, in float r0 )\n{\n    float sina = sin(alpha);\n    return alpha + 0.25*(3.0 + cos(2.0*alpha) - 4.0 * r0 * sina)/(cos(alpha)*(r0+sina));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = 4.0 * ratio * fragCoord/iResolution.xy - 2.0 * ratio; // y from -2.0 -> 2.0\n    \n    float r = length(uv);\n    \n    if (r <= 1.0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // The Black Hole is Black\n        return;\n    }\n\n    float alpha = newton(1.0/r, r); // three iterations of the newton method to solve (with Rs=1)\n    alpha = newton(alpha, r);       //     0 == -sin(alpha)/r + Rs/(2 r^2) * (1 + cos(alpha)^2)\n    alpha = newton(alpha, r);       // 1.0/r is the solution for small angle approx: sin(x) = x, cos(x) = 1\n    \n    /*\n    Light had direction (1,0) and now gets rotated by angle a:\n        (sin(a), cos(a)) / sin(a) = (1, cos(a)/sin(a))\n    We are only interested in the y-Component, x should be 1.\n    \n    Black Hole o at 0, light ray starting at -1, direction to 1.\n    No inflection at point +, with inflection at point @ and that's\n    were we are sampling the texture (x is the view direction)\n\n         x: 1    0   -1\n            +----o----|\n                /\n               /\n              /\n             /\n            @\n\n    */\n    uv *= (1.0 - 1.0 / tan(alpha)); // inflection\n    \n    uv = (uv+vec2(0.0,2.0))*0.125;\n    \n    vec3 color = texture(iChannel0, uv + vec2(iTime*0.0625, 0.0)).rgb;\n    color = pow(1.25*(color-0.0625), vec3(8.0*(1.0-1.0/r))); // brighten the image with lorentz^2 factor\n    \n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0); // Gamma Correction for Gamma=2.2\n}","name":"Image","description":"","type":"image"}]}