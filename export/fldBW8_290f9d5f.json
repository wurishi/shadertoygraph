{"ver":"0.1","info":{"id":"fldBW8","date":"1663021357","viewed":41,"name":"Lone Snowman","username":"ParkerWeiss","description":"A lonely Snowman","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["snowman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\n\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -.6, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  float d3 = sdSphere(p, 0.5, vec3(0, 1.5, 0));\n  \n  float var1 = min(d1, d2);\n  float var2 = min(d2, d3);  \n  float var3 = min(var1, var2);\n  \n  \n  return min(var3, sdFloor(p));\n  }\n  \n\nfloat rayCalc(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  float d;\n\n  for (int i = 0; i < 255; i++) {\n    \n    vec3 p = ro + depth * rd;\n    \n    d = scene(p);\n    depth += d;\n    if (d < .001 || depth > 255.0) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\n\n// found this normalize function from IQ, super helpful\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * .0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 7);\n  \n  vec3 rd = normalize(vec3(uv, -1));\n\n  float d = rayCalc(ro, rd);\n\n  if (d > 255.0) {\n    col = 0.1 + .5*cos(iTime+uv.xyx+vec3(0,2,4));; // ray didn't hit anything\n    col *= vec3(sin(texture(iChannel0, uv + iTime/30.0)));\n  } \n  \n  else {\n    \n    vec3 p = ro + rd * d;    \n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(2, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) *.3;\n\n    float dif = clamp(dot(normal, lightDirection), 0.0, 1.0) * 0.3 + 0.3;\n    \n   vec3 col2 = texture(iChannel1, uv).rgb;\n   vec3 col3 = vec3(sin(texture(iChannel0, uv + iTime/30.0)));\n    \n    col = vec3(dif) + vec3(0.38, 0.25, 0.20) + (.1 *col2) + .1*col3; \n  }\n\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}