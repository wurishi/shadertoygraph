{"ver":"0.1","info":{"id":"lXXfRS","date":"1728520478","viewed":25,"name":"Repelling Points on Sphere 2","username":"oneshade","description":"Attempting to stabilize the formation.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["sphere","moving","points","repelling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Repelling Points on Sphere\" by oneshade. https://shadertoy.com/view/sssfWM\n// 2024-10-09 23:56:19\n\n#define drawPoint3(p) drawSDF(length(uv - p.xy / (3.0 - p.z)) - 0.01 / (2.0 - p.z), vec3(1.0))\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float rot = 0.0;//-iTime;\n    float co = cos(rot), si = sin(rot);\n    mat2 rotMat = mat2(co, si, -si, co);\n\n    for (int i=0; i < NUM_POINTS; i++) {\n        vec3 p = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n\n        p.xz *= rotMat;\n        p.yz *= rotMat;\n\n        drawPoint3(p);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/4djSRW\nvec2 Hash12(in float p) {\n    vec3 p3 = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(0.0);\n    ivec2 iAddr = ivec2(addr);\n    if (iAddr.y < 2 && iAddr.x < NUM_POINTS) {\n        vec3 thisPos, thisVel;\n\n        if (iFrame == 0) {\n            vec2 rot = (Hash12(addr.x) - 0.5) * vec2(6.28, 3.14);\n            float cy = cos(rot.x), sy = sin(rot.x);\n            float cp = cos(rot.y), sp = sin(rot.y);\n            thisPos = vec3(cy * cp, sp, sy * cp);\n            thisVel = vec3(0.0);\n        } else {\n            thisPos = texelFetch(iChannel0, ivec2(iAddr.x, 0), 0).xyz;\n            thisVel = texelFetch(iChannel0, ivec2(iAddr.x, 1), 0).xyz;\n\n            // Calculate gradient of sum of inverse square falloffs from all the other points\n            vec3 grad = vec3(0.0);\n            for (int i = 0; i < NUM_POINTS; i++) {\n                if (i == iAddr.x) continue;\n                vec3 otherPos = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n                vec3 otherVel = texelFetch(iChannel0, ivec2(i, 1), 0).xyz;\n                vec3 posDiff = otherPos - thisPos;\n                float denom = dot(posDiff, posDiff) + 1.0;\n                grad += 2.0 * posDiff / (denom * denom);\n            }\n\n            thisVel -= grad * iTimeDelta;\n            thisPos += thisVel * iTimeDelta;\n            thisPos = normalize(thisPos);\n        }\n\n        if (iAddr.y == 0) data.xyz = thisPos;\n        if (iAddr.y == 1) data.xyz = thisVel;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_POINTS 20 //100\n#define SPEED 20.0","name":"Common","description":"","type":"common"}]}