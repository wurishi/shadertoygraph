{"ver":"0.1","info":{"id":"ddVGzw","date":"1678448971","viewed":86,"name":"Detour animation","username":"kokodayo","description":"This is an animation of an arrow indicating a detour","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["arrow","2dsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCapsule( in vec2 p, in float w, in float h)\n{\n    p.y = abs(p.y) - h;\n    return (p.y > 0.0 ? length(p) : abs(p.x)) - w;\n}\n\nfloat sdBox(in vec2 p, in vec2 a)\n{\n    vec2 q = abs(p)-a;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdArc( in vec2 p, in float an, in float l, float wi )\n{\n    // if perfectly straight\n    if( abs(an)<0.001 )\n    {\n        return sdCapsule(p, wi, l);\n    }\n    \n    float ra = l / an;\n    p.x -= ra;\n    p.y = abs(p.y);\n    vec2 sc = vec2(sin(an), cos(an));\n    vec2 cs = vec2(-cos(an),sin(an));\n    float d = dot(p,sc) > 0.0 ? length(p-cs*ra) : abs(length(p) - abs(ra));\n    return d - wi;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\nfloat sdArrowL(in vec2 p, float w, float h, float r,float bl, float a)\n{\n    p = rotate2d(a) * p;\n\n    p.x = abs(p.x);\n    float d1 = p.y+h/w*(p.x-w);\n    float d2 = abs(p.y)>r ? length(p - vec2(w, 0.0)) : abs(p.x-w);\n    float u = p.x < w ? abs(d1) - r : d2;\n    \n    if(d1 < 0.0)\n        u = min(sdBox(p - vec2(0.0, h - bl), vec2(r, bl)), u);\n    \n    return u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float as = 4.0 / iResolution.y; //For anti-aliasing\n    \n    // Animation Location\n    uv += vec2(0.0, 0.1);\n    \n    \n    /****** Parameters of the animation **********\n    wi: the width of the line\n    Arrow_color: the color of the arrow\n    an : the angle of the arc (Note: Less than 180 degrees)\n    ah : Length of the chord of a circular arc\n    hw&hl: control the size of the arrow\n    al : controls the length of the arrow\n    boxl : the length of the rectangle at the bottom of the arrow\n    */\n    float wi = 0.1;\n    vec4 Arrow_color = vec4(0.8,1.0,1.0,1.0); //CCFFFF\n    float an = radians(90.0) * sin(iTime);\n    float ah = 0.3;\n    float hw = 0.22;\n    float hl = 0.22;\n    float al = 0.25;\n    float box_l = 0.2;\n\n    /*****   2D SDF calculation *****/\n\n    float le = abs(an) > 0.002 ? abs(ah*an/sin(an)) : ah;\n    float ra = abs(le/an); //l=angle*r, r=l/angle\n    \n    //float Sphere_w = abs(an) > 0.002 ? (1.0 - cos(an))*ra : 0.0;\n    float Sphere_w = ah*tan(0.5*an);\n    \n    // Distance of the arc\n    float d1 = sdArc(uv + vec2(Sphere_w, 0.00), an, le, wi);\n\n    // The stationary rectangular area of the arrow\n    float d2 = sdBox(uv + vec2(0.0, box_l + ah), vec2(wi, box_l));\n    \n    // Distance of the arrow\n    float d3 = sdArrowL(uv - vec2(0.0, ah) - vec2(0.0, (2.0*al - hl)), hw, hl, wi, al, 0.0);\n    \n    // Graphics Fusion\n    float d = min(min(d1, d2), d3);\n    \n    // coloring\n    vec4 col = smoothstep(as, 0.00, d) * Arrow_color;\n\n\tfragColor = col;\n}","name":"Image","description":"","type":"image"}]}