{"ver":"0.1","info":{"id":"DsccRM","date":"1694827290","viewed":115,"name":"distance field gen testing","username":"Carandiru","description":"Fast Sweeping Method of distance field generation.\n[distance, smoothstep, inverse square]","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["distance","field","generation","eikonal","fsm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fast Sweeping Method of distance field generation.\n//\n// ChatGPT suggests FSM over jumpflooding, especially for large resolution / grid sizes!\n// \n// Testing....\n// [distance, smoothstep, inverse square]\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / R;\n                                                                   // odd - why?\n    vec4 sampling = textureLod(iChannel0, (fragCoord + vec2(iTime*100.0f, 0.0f)) / R, 0.0f);\n    \n    float d = sampling.x * length(R);\n    \n    float hw = 0.5f * d;\n    float att = 1.0f / (1.0f + d * d);\n    \n    vec3 color = vec3(0);\n    \n    if (uv.x < 1.0f/3.0f) {\n        att = 100.0f * sampling.x;\n    }\n    else if (uv.x < 1.0f/1.5f) {\n        att = smoothstep(hw, -hw, d * 2.0f - 1.0f);\n    }\n    \n\n    color = vec3(att);\n    \n    if (uv.y < 0.025f && uv.x > fract(sampling.g)) {\n        color += mix(vec3(0), vec3(pow(0.618034, iTime + 1.0f))*sampling.g, sampling.g);\n    }\n    color += mix(vec3(0), vec3(pow(0.618034, iTime + 1.0f))*sampling.w, sampling.w);\n    \n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fast Sweeping Method of distance field generation.\n//\n// ChatGPT suggests FSM over jumpflooding, especially for large resolution / grid sizes!\n// \n// Testing....\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / R;\n    \n    float bn = textureLod(iChannel2, (uv * R) / 1024.0f, 0.0f).r * 0.5f + 0.5f;\n    \n    float gridSize = length(R);\n    float invgridSize = (1.0f*bn)/gridSize;\n    \n    vec2 gridPos = vec2(uv * R);\n              \n    float minDistance = 1.0f;\n    float seed = 0.0f;\n    float complete = 0.0f;\n    \n    if (iFrame < 10) {\n        minDistance = step(0.5f, length(textureLod(iChannel1, uv, 0.0f).rgb));\n        invgridSize = 1.0f / gridSize;\n        seed = 1.0f - minDistance;\n    }\n    else {\n        minDistance = textureLod(iChannel0, gridPos/R, 0.0f).r;\n    }\n    \n    {\n        float readDistance = minDistance;\n        float sz = 64.0f;\n        \n        // Perform the fast sweeping \n        \n        // forward\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos + vec2(-1, 0), sz)/R, 0.0f).r + invgridSize);\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos + vec2( 1, 0), sz)/R, 0.0f).r + invgridSize);\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos + vec2( 0,-1), sz)/R, 0.0f).r + invgridSize);\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos + vec2( 0, 1), sz)/R, 0.0f).r + invgridSize);\n        \n        // reverse\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos - vec2(-1, 0), sz)/R, 0.0f).r + invgridSize);\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos - vec2( 1, 0), sz)/R, 0.0f).r + invgridSize);\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos - vec2( 0,-1), sz)/R, 0.0f).r + invgridSize);\n        minDistance = min(minDistance, textureLod(iChannel0, diamondize(gridPos - vec2( 0, 1), sz)/R, 0.0f).r + invgridSize);\n        \n        complete = 1.0f - (readDistance - minDistance);\n    }\n    \n\n    fragColor = vec4(minDistance, complete, 0.0f, seed);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define t iTime\n#define dt iTimeDelta\n#define ff float(iFrame)\n\n#define fma(a,b,c) (a*b+c)\nvec2 rotate( in vec2 p, in vec2 cossin )\n{\n\t#define c_ x\n\t#define s_ y\n\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\nvec2 rotate( in vec2 p, in float angle )\n{\n    return rotate(p, vec2(cos(angle), sin(angle)));\n}\n\nvec2 diamondize(in vec2 uv, in float resolution) // original - dominionxvii - https://www.shadertoy.com/view/dlBfz1\n{\n    vec2 diamondUV = rotate(uv, radians(45.));\n    diamondUV = floor(diamondUV * resolution) / resolution;\n    diamondUV = rotate(diamondUV, -radians(45.));\n    \n    return diamondUV;\n}","name":"Common","description":"","type":"common"}]}