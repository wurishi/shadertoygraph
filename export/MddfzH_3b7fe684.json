{"ver":"0.1","info":{"id":"MddfzH","date":"1524135508","viewed":408,"name":"Ammann-Beenker","username":"knighty","description":"A modification of the [url=https://www.shadertoy.com/view/XdtBzH]previous shader[/url] to draw [url=https://en.wikipedia.org/wiki/Ammann%E2%80%93Beenker_tiling]Amman-Beenker tilings[/url].\n[url=https://www.shadertoy.com/view/Mstfz4]light version[/url].\n","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["tiling","aperiodic","ammann","beenker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\n// Aperiodic tiling\n// Ammann-Beenker tilings\n// by knighty (april 2018)\n// Free stuff\n// Info: Uses cut and project method. The pixel is tested for which tile it \n//       belongs to. Unlike The usual method that draws the tiles \"one by one\"\n//       thus have cost proportionnal to the number of drawn tiles, the cost\n//       per pixel in this shader is bound by a -rather big- constant. \n//       ... WIP :o)\n//\n// Controls:\n// - Mouse click and drag: Pan.\n// - Upper left slider   : Zoom.\n// - Lower left sliders  : Translate the cutting plane along its \"complementary\n//                         Space\" -in the case a 2D space.\n//\n// Some references (both by Greg Egan.):\n// - https://plus.google.com/u/0/113086553300459368002/posts/VJBnyhxH44y\n//   (With a cool aniated gif that visually explains almost every thing.)\n// - https://plus.google.com/u/0/113086553300459368002/posts/aMm17RELcsJ\n//   (With links to articles and applets)\n//--------------------------------------------------------------------------\n\n// --- sliders and mouse widgets -------------------------------------------\n// By FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n\nvec2 R;// = iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { // display mouse states ( color )\n    vec4 mouse = UI(33);                       // current mouse pos\n    float k = length(mouse.xy/R.y-uv)/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy/R.y-uv)/Mradius;     // prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)/R.y-uv)/Mradius;  // drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { // display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l/Bradius);\n    }\n    return 0.;\n}        \n\n//------------------------------------------------------------------------------------   \n// The aperiodic tiling\n//------------------------------------------------------------------------------------\n//the two vectors defining the cut and project plane\n#define A 0.707107\n#define B 0.5\nconst vec4 udir = vec4(A,B,0,-B);\nconst vec4 vdir = vec4(0,B,A,B);\n//the 3 directions perpendicular to the cut and project plane\nconst vec4 u2dir = vec4(A,-B,0,B);\nconst vec4 v2dir = vec4(0,B,-A,B);\n#undef A \n#undef B \n\n//Cut and project plane origin\nvec4 CPO = vec4(0);\n\n//results of tiling search\nstruct Data{\n\tfloat dist;\n\tivec2 sides;\n\tvec2 posInTile;\n};\n\nvoid init(){\n\tfloat CP_tans_u2dir = UI(1).a; \n    float CP_tans_v2dir = UI(2).a;\n    CPO = CP_tans_u2dir * u2dir + CP_tans_v2dir * v2dir;\n}\n\n//Gives the coordinates of the point (x,y) on the \"cutting\" plane into the 5D space\nvec4 P2E4(vec2 z){\n\treturn CPO + z.x * udir + z.y * vdir;\n}\n\n//given a point p, return the nearest vertex in the lattice and the offset.\nvoid getRoundAndOffest(in vec4 p, out vec4 ip, out vec4 ofs){\n\tip = floor(p+vec4(.5));\n\tofs = p - ip;\n}\n\n//given a vector Ofs, return the vector of 1 when component >0 and -1 otherwise \nvec4 getOfsDir(vec4 ofs){\n\tvec4 dir;\n\tfor(int i=0; i<4; i++){\n\t\t//if(ofs[i]>0.) dir[i]=1.; else dir[i]=-1.;\n\t\tdir[i] = 2. * float(ofs[i] > 0.) - 1.;\n\t}\n\treturn dir;\n}\n\n//project the vector ofs onto the plane (udir,vdir)\nvec2 projectOfs(vec4 ofs){\n   //dot products\n\tvec2 pofs = vec2(0);\n    pofs.x = dot(ofs,udir);\n    pofs.y = dot(ofs,vdir);\n\treturn pofs;\n}\n\n//Distance from a to the parallelogramm defined\n//by u and v. a is expressed in the (u,v) basis\nfloat Dist22V2(vec2 a, float f){\n\tvec2 p = abs(a-vec2(.5))-vec2(.5);\n\treturn max(p.x,p.y)*f;//\n}\n\n//Finds if p is inside a the tile defined by (i,j,ip)\n//dir is not per se necessary it could be se to 1s\nData section(int i, int j, vec4 p, vec4 ip, mat2 m, float f, vec2 s){\n    //check intersection with dual\n    vec2 lhs = vec2(ip[i] - CPO[i], ip[j] - CPO[j]) + 0.5*s;\n\tvec2 z = lhs * m;\n\t\n    vec4  ofs, q;\n\tq = P2E4(z);\n\t//the intersection can be on a neighbouring tile!\n\tfor(int k=0; k<4; k++){\n\t\tq[k] = floor(q[k]+.5);\n\t\tif(k==i)      ofs[k]=p[k] - (ip[k] + .5 * (s.x - 1.));\n        else if(k==j) ofs[k]=p[k] - (ip[k] + .5 * (s.y - 1.));\n\t\telse          ofs[k]=p[k] - q[k];\n\t}\n\t\n\tvec2 pofs = projectOfs(ofs);\n\t\n\t//get the face corresponding to the intersected dual\n    vec2 pit = (m * pofs);\n    \n\tfloat dist   = Dist22V2(pit, f);\n\tData d1 = Data(dist, ivec2(i,j), pit);\n\treturn d1;\n}\n\n//\nData DE(vec2 z){\n\n\tvec4 p = P2E4(z);\n\t\n\tvec4 ip, ofs;\n\tgetRoundAndOffest(p,ip,ofs);\n\n    for(int i=0; i<3; i++)\n\t{\n\t\tfor(int j=i+1; j<4; j++)\n\t\t{\n\t\t\t//m and f can/should be precomputed!\n            // the inverse of m is used to test if:\n            // - the projection of p onto cutting plane is inside the current tile\n            // - the cut plane intersects the dual of the current tile\n            mat2 m = mat2(vec2(udir[i],vdir[i]), vec2(udir[j],vdir[j]));\n            // f is a correction factor to get the distance to the boundary of the tile\n    \t\tfloat f = dot(m[0],m[1]); f = sqrt(dot(m[0],m[0]) - f*f / dot(m[1],m[1]));\n            //We use the inverse of m in reality :D\n    \t\tm = inverse(m);\n            \n            vec2 s = vec2(1.,-1.);\n            //Scan the diffrent possible 4 directions\n            Data d1 = section(i, j, p, ip, m, f, s.xx);\n\t\t\tif(d1.dist < 0.) return d1;\n\n\t\t\td1 = section(i, j, p, ip, m, f, s.xy);\n\t\t\tif(d1.dist < 0.) return d1;\n\t\t\t\n\t\t\td1 = section(i, j, p, ip, m, f, s.yx);\n\t\t\tif(d1.dist < 0.) return d1;\n\n\t\t\td1 = section(i, j, p, ip, m, f, s.yy);\n\t\t\tif(d1.dist < 0.) return d1;\n\t\t}\n\t}\n\treturn Data(0., ivec2(0), vec2(0));\n}\n\nfloat getFaceSurf(int i, int j){\n\tvec2 u,v;\n\tu[0]=udir[i]; u[1]=vdir[i];\n\tv[0]=udir[j]; v[1]=vdir[j];\n\treturn abs(u[0]*v[1]-u[1]*v[0]);\n}\n\nfloat coverageFunction(float t){\n\t//this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t//the exact coverage function is:\n\t//t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))/PI;\n\t//this is a good approximation\n\treturn 1.-smoothstep(-1.,1.,t);\n\t//a better approximation:\n\t//t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1./8.+0.5;//but there is no visual difference\n}\n\n#define DRadius .75\n#define Width 2.\n#define BackgroundColor vec3(1)\n#define CurveColor vec3(0)\n#define Gamma 2.2\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td=d*1./pixsize;\n\tfloat v1=(d-0.5*lineWidth)/DRadius;\n\tfloat v2=(d+0.5*lineWidth)/DRadius;\n\treturn coverageFunction(v1)-coverageFunction(v2);\n}\n\nvec3 color(vec2 pos) {\n\tfloat pixsize=dFdx(pos.x);\n\tData data = DE(pos);\n\tfloat v=coverageLine(abs(data.dist), Width, pixsize);\n    \n\tvec3 faceCol = vec3(getFaceSurf(data.sides.x, data.sides.y)*1.8);\n    //vec3 faceCol = vec3(data.posInTile,0.);\n    //vec3 faceCol = texture(iChannel1,data.posInTile).rgb;\n    \n\tvec3 linCol = pow(mix(pow(BackgroundColor,vec3(Gamma)),pow(CurveColor,vec3(Gamma)),v),vec3(1./Gamma));\n\treturn linCol*faceCol;\n}\n//------------------------------------------------------------------------------------\nvec2 Pan(in vec2 p, in float scale)\n{\n    vec4 mouse = UI(35);//R.y;\n    p.xy -= mouse.xy * scale/100.;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Global variable init\n    R = iResolution.xy;\n    //--------------------\n    vec2 uv = fragCoord.xy/R.y;\n    //vec4 mouse = UI(33)/R.y;\n    \n\t// display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    //{ float s = aff_buttons(uv); if (s>0.) { fragColor = s*vec4(0,.2,1,1); return;}}\n    \n    float scale = exp(5.*(UI(3).a-0.));\n    vec2 p = scale * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tp = Pan(p,scale);\n    init();\n    vec3 col = color(p);//vec3(0.3 + p.y * 0.1);\n   \t\n   \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//By FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n//With some modifications\n\n// only line 0, pixels 0 to 33 of bufA are used\n// if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 1 // fake mouse motion if no user input\n#define Sradius .02  // influence radius for sliders\n#define Bradius .04  // influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\nvec2 R;// = iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\nbool insideSlider(vec2 U, vec4 S){\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Sradius && abs(U.x-S.x-l/2.)<l/2. ) return true;\n        if (S.z<0. && abs(U.x-S.x)<Sradius && abs(U.y-S.y-l/2.)<l/2. ) return true;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return true;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return true;\n    return false;       \n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    R = iResolution.xy;\n    \n    O = texture(iChannel0,U/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        add_slider (.05,.05,VERTIC,.5,.0); // --- define your sliders here ---\n        add_slider (.10,.05,VERTIC,.5,.0); // read value [0,1] in UI(i).a  , i=1..16\n        //add_slider (.15,.05,VERTIC,.5,.0);\n        add_slider (.05,.95,HORIZ,.5,.2);\n        //add_slider (.25,.05,VERTIC,.5,.99);\n        \n        //add_button ( .05,.95, -1.);          // --- define your buttons here ---\n        //add_button ( .15,.95, -1.);          // read value {-1,1} in UI(i+16).a , i=1..16\n        //add_button ( .25,.95, -1.);          \n        /*add_button ( 1.,.1, -1.);          */\n        \n        if (U==vec2(0,0)) O = vec4(nbS, nbB, 0., 0.);\n        if (U==vec2(35,0)) O = vec4(0.);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)==0. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (U==vec2(35,0)){\n        if(iMouse.z/iResolution.y > 0.3) O.xy = O.zw + iMouse.xy - iMouse.zw;\n        else O = O.xyxy;\n        return;\n    }\n    \n    if (iMouse.z>0. && U.y==0.) {          // --- let mouse trigers the right slider or button\n       \tvec4 M = iMouse/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n            if(insideSlider(M.zw, S)){\n    \t    \tfloat l = abs(S.z);\n\t        \tif (S.z>0. ) O.a = clamp((M.x-S.x)/l,0.,1.);\n    \t    \tif (S.z<0. ) O.a = clamp((M.y-S.y)/l,0.,1.);\n            }\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M.xy-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}","name":"Buf A","description":"","type":"buffer"}]}