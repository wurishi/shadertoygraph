{"ver":"0.1","info":{"id":"4cKcDc","date":"1732486053","viewed":216,"name":"Happy Squircle! ðŸŸªðŸŸ£ðŸ¦˜","username":"chronos","description":"It's a squircle you silly goose!","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["procedural","2d","animation","glow","bounce","happy","physics","squircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Happy Squircle! ðŸŸªðŸŸ£ðŸ¦˜ - by chronos\n    ------------------------------------------------\n    \n    Why is Squircle so happy?\n    \n    hmmm.... ðŸ¤”\n    \n    Update: Squircle is now extra mushy and melty ðŸ« \n    \n    ------------------------------------------------\n    self link: https://www.shadertoy.com/view/4cKcDc\n    ------------------------------------------------\n\n*/\n\n\nconst float max_height = 2.;\nconst float gravity = 1.5;\nconst float dampening_factor = 0.15;\nconst float horizontal_speed = 1.;\n\nconst float s = .025; // Bounce smoothing\nconst float squish = 0.125;\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(a*k) + exp(b*k))/k; \n}\n\n// Barbican cosine. Just like the regular cosing, but with all the smoothness--- taken oot!\nfloat sawcos(float x)\n{\n    const float PI = 3.14159265;\n    float t = .5*x/PI-.5;\n    return 4.*min(1.-fract(t), fract(t))-1.;\n}\n\nfloat get_height(float time)\n{\n    float height = max(max_height-floor(time*gravity)*dampening_factor, 0.25);\n    return height;\n}\n\n// *slaps function*: This little bad-boy is a parameterized parabolic arc for bouncing :)\nfloat bounce(float time)\n{\n    float height = get_height(time);\n    float y = 4.*pow(fract(gravity*time)-.5, 2.);\n    \n    // \"Well, this little maneuver is gonna cost us 51 years!\"\n    // And the maneuver is a smoothing function for the bounce so that \n    // the bounce acts more like an elastic bounce. It's not perfect but I think it works :)\n    // Added after suggestion by @ahs3n in the shadertoy discord to make the bounce softer.\n    // The parameter s controls the softness. s -> âˆž makes it floaty, s = 0 makes it a regular parabolic arc.\n    #if 1\n    {\n        y = 1.-y;\n        y = (sqrt(y*y + s)-sqrt(s))/(sqrt(1.+s)-sqrt(s));\n        y = 1.-y;\n    }\n    #endif \n    \n    return y = height - (1.+height)*y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float ps   = 2. / iResolution.y;\n    vec3 color = vec3(0);\n\n    float horizontal_pos = tanh(sawcos(iTime*horizontal_speed));\n    float t = 7.*horizontal_pos;\n    mat2 R = mat2(cos(t), sin(t), -sin(t), cos(t));\n\n    \n    if(length(iMouse.xy) < 10. || iMouse.z < 0.5)\n        mouse = vec2(\n            iResolution.x/iResolution.y * horizontal_pos, \n            bounce(iTime)\n        );\n\n    float p = 4.;\n    \n    // It go squish!\n    #if 1\n    float height = get_height(iTime);\n    uv.x *= 1.-(height+1.)*squish*pow(abs(cos(3.14159265 * iTime * gravity)), 32.);\n    mouse.x *= 1.-(height+1.)*squish*pow(abs(cos(3.14159265 * iTime * gravity)), 32.);\n    #endif\n    \n    float f = pow(\n        dot(\n            pow(abs(R*(uv-mouse)), vec2(p)),\n            vec2(1)\n            ), \n      1. / p);\n\n    float d = f - .5;\n    \n    float smax_strength = 15.;\n    d = smax(d, -(uv.y+1.), smax_strength);\n    d = smax(d, fragCoord.x/iResolution.x-1., smax_strength);\n    d = smax(d, -fragCoord.x/iResolution.x, smax_strength);\n    \n    float F = smoothstep(ps, -ps, d);\n\n    color += 6.*max(6.*(d+1.)*(-d), 0.);\n    color += min(.005/(max(d, .005/6.)), 2.);\n\n    color *= cos(iTime*1.333)*.5+.5;\n    color *= vec3(1, 0.01,.5);\n    color += 6.*max(6.*(d+1.)*(-d), 0.)*.0325 * mix(vec3(1, 0.01,.5), vec3(1.), .5);\n    #if 1\n    float intensity = length(color);\n    float desat_scale = 0.2;\n    float desat = tanh(desat_scale * (intensity - tanh(intensity)));\n    color = tanh(intensity) * normalize(mix(normalize(color), normalize(vec3(1,1,1)), desat));\n    #else\n    color = tanh(color);\n    #endif\n    \n    fragColor = vec4(sRGBencode(color), 1.0) + texture(iChannel0, fragCoord.xy/1024.)/255.;\n}","name":"Image","description":"","type":"image"}]}