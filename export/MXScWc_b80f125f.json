{"ver":"0.1","info":{"id":"MXScWc","date":"1727923197","viewed":35,"name":"Assignment3 - Exploding Galaxy","username":"macro","description":"Assignment for Intro to Modern Graphics Programming class","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["class"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 circleColorCenter = vec4(1.0f,0.0f,0.0f,1.0f);\nconst vec4 circleColorBorder = vec4(0.0f,1.0f,0.0f,1.0f);\nconst float particleSpread = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0; //set pixel coords to be -1 to 1\n    uv.x *= iResolution.x / iResolution.y; // adjust coords so that our image accounts for aspect ratio\n    \n    //uv = fract(uv);\n    // i tried a version of this with the nebula fracted across the screen but thought it was distracting to look at\n    \n    // creating our own variable for time that's adjusted from iTime to adjust the effects\n    float fixedTime = mod(iTime, 3.0); // using modulus so the effect repeats on screen every 3 seconds\n    if (fixedTime > 1.5)\n    {\n        fixedTime = fixedTime - 1.5;\n        fixedTime = 1.5 - fixedTime;\n        // these subtractions make it so that the time used in the rest of the shader moves backwards for the second half\n    }\n    \n    vec2 center = vec2(0.0, 0.0);\n    vec4 circleColor = vec4(0.0, 0.0, 0.0, 0.0); \n    vec4 finalColor =  vec4(0.0, 0.0, 0.0, 0.0);\n    // setting values before we enter the loop\n    \n    float i = 0.0;\n    while (i < 100.0)\n    {\n        // create a circle\n        float c2 = length(uv);\n        center = vec2(0.0, 0.0) + vec2(particleSpread * sin(i) * i * fixedTime, particleSpread * cos(i) * i * fixedTime);  \n        // this trig i * i creates this cool spiral effect\n        // inclusion of fixedTime means the circles get spread apart as the effect continues, making for the exploding effect\n        c2 = distance(uv, center);\n        // setting the location of the circle\n        \n        c2 = smoothstep(abs(cos(fixedTime) * 0.05) + 0.01, abs(sin(fixedTime) * 0.07) * -1.0 + 0.011, c2); \n        // okay this function gets me this sort of breathing circle. \n        // the cosine and sine waves are changing the step ranges to cause this breathing effect\n        // the absolute value makes the breathing effect only exist in positive range;\n        // if the step goes negative then the circle will appear and also it will invert which is silly\n        // the system helps display how the particles are dispersing over time\n        \n        circleColor = mix(circleColorCenter, circleColorBorder, (i * fixedTime / 50.0));\n        // interpolating the color between two outside color values. \n        // The fixed time will skew the colors based on progression of the effect;\n        // at the start more particles will prefer the center color, at the end more particles will prefer the border color, but both are represented\n        // makes this natural heat effect with the right colors, v cool\n         \n        finalColor = mix(finalColor, circleColor, c2); // add the circle to our final result\n        \n        i = i + 1.0; // creating 100 circles\n    } \n\n    // Output to screen\n    fragColor = vec4(finalColor);\n    \n    // I wanted to figure out a way to make the particles spin as they exploded but couldn't figure it out :(\n    // Used functions include: mod, length, distance, smoothstep, abs, cos, sin, mix\n    \n    // my brain processing the functions below :)\n    \n    // sin, cos, tan (the usual)\n    // step = something about locking to a value\n    // smoothstep = instead of locking to a value, lerps between two\n    // mod = modulus\n    // fract = cuts pieces out of a value but still not sure how this works\n    // abs = absolute value\n    // floor = set to 0 or 1 it seems\n    // ceil = similar to floor?\n    // mix = mix multiple colors. seems to be the way to have layers, can be used for other interpolation goals\n    // length = i'm really not sure. I know it's what sets up the circles though\n    // distance = distance between two values. Finishes circle set up, positions them there\n    \n    // distance + step = placing a circle basically\n}","name":"Image","description":"","type":"image"}]}