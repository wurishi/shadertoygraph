{"ver":"0.1","info":{"id":"WlSXWc","date":"1567245701","viewed":127,"name":"LiveCodingPractice011(1h)","username":"Hirai_worthless","description":"energy chamber","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\n\nmat2 genRot(float v){\n    return mat2(cos(v),-sin(v),sin(v),cos(v));\n}\n\nvec2 pMod(vec2 p,float c){\n    p *= genRot(PI / c);\n    float at = atan(p.y/p.x);\n    at = mod(at,2. * PI / c);\n    float r = length(p);\n    p = vec2(r * cos(at),r * sin(at));\n    p *= genRot(-PI / c);\n    return p;\n}\n\nfloat cube(vec3 a){\n    a = abs(a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat map(vec3 p){\n    vec3 q = p;\n    //p.xy *= genRot(p.z * 0.1 * PI);\n    p.xy = pMod(p.xy,12.);\n    p.xy = (fract(p.xy / 1.5+ .5) - .5) * 1.5;\n    p.z = fract(p.z + .5) - .5;\n    vec3 r = p;\n    float sp = cube(p - vec3(0.5,0.,0.)) - 0.05;\n    \n    float fi = length(p.xz - vec2(0.5,0.)) - 0.015+ 0.01 * floor(sin(p.y* 6. * PI + iTime));\n    fi = min(fi,length(p.yz) - 0.015 + 0.01 * floor(sin(p.x* 6. * PI + iTime)));\n    fi = min(fi,length(p.xy - vec2(0.5,0.)) - 0.015 + 0.01 * floor(sin(p.z* 6. * PI - iTime * 2.)));\n    fi = max(fi,-(length(q.xy) - 0.5));\n    sp = min(sp,fi);\n    float con = length(q.xy) - (0.2 + 0.1 * cos(iTime)* sin(atan(q.y/q.x) * 2. + q.z * PI + iTime * 2.));\n    float resl;\n    resl = min(sp,con);\n    return resl;\n}\nvec3 getNormal(vec3 p){\n    vec3 x = dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n    vec3 p;\n    float t = 0.;\n    for(int i = 0;i< 128; i++){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 n = getNormal(p);\n    return vec4(n,t);\n}\n\nvec3 cam(){\n    vec3 c = vec3(0.,0.,-1.5);\n    c += vec3(cos(iTime/2.),sin(iTime/2.),iTime * PI / 4.);\n    c.xy *= 1. + .5 * smoothstep(0.,1.,sin(iTime));\n    return c;\n}\nvec3 ray(vec2 uv, float z){\n    vec3 r = normalize(vec3(uv,z));\n    r.yz *= genRot(-PI/3.);\n    r.xy *= genRot(PI / 3.);\n    r.xy *= genRot(iTime/2.);\n    return r;\n}\n\nvec3 getColor(vec3 o,vec3 r,vec4 d){\n    float t = d.w;\n    vec3 n = d.xyz;\n    float rim = 1. - dot(r,n);\n    vec3 bc = vec3(rim);\n    vec3 p = o + r * t;\n    float at = atan(p.y/p.x) * 2.;\n    vec3 cc;\n    cc = cos(p);\n    cc = cc * 0.5 + 0.5;\n    cc = length(p.xy) < 0.4 ||\n     (fract(p.z + 0.1) < 0.2 &&\n     fract(length(p.xy)-iTime * 2. + at) < 0.4)\n     ? cc : vec3(0.);\n    bc += cc * 1.;\n    float fog = 1./(1.+t*t*0.1);\n    bc = mix(bc,vec3(0.),1.-fog);\n    return vec3(bc);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.x;\n    vec3 o = cam();\n    vec3 r = ray(uv,1.5);\n    vec4 d = trace(o,r);\n    // Time varying pixel color\n    vec3 col = getColor(o,r,d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}