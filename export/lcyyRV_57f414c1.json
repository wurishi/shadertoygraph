{"ver":"0.1","info":{"id":"lcyyRV","date":"1732093219","viewed":16,"name":"Spinning Bread Slices","username":"vitasa","description":"randomly spinning bread slices.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["background","slice","rotation","spin","spinning","bread"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash function to generate pseudo-random numbers\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D rotation function\nmat2 rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Signed distance function for an ellipse (oval)\nfloat sdEllipse(vec2 p, vec2 r) {\n    vec2 k = abs(p) / r;\n    return (length(k) - 1.0) * min(r.x, r.y);\n}\n\n// Signed distance function for a square (box)\nfloat sdSquare(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size / 2.0;\n    return max(d.x, d.y);\n}\n\n// Adjustable bread color parameter\nvec3 breadColor = vec3(0.95, 0.82, 0.63); // Set this to the desired color of the bread slices\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    // Adjust for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Number of slices\n    const int numSlices = 15;\n\n    // Initialize minimum distance to a large value\n    float d = 1e10;\n\n    // Loop over slices\n    for (int i = 0; i < numSlices; i++) {\n        // Generate pseudo-random parameters based on the slice index\n        float index = float(i);\n\n        // Random position\n        float randX = hash(index * 12.9898);\n        float randY = hash(index * 78.233);\n        vec2 position = vec2(randX * 2.0 - 1.0, randY * 2.0 - 1.0);\n        position.x *= iResolution.x / iResolution.y; // Adjust for aspect ratio\n\n        // Random size\n        float sizeFactor = 0.1 + 0.5 * hash(index * 93.433);\n        vec2 squareSize = vec2(sizeFactor, sizeFactor);\n        vec2 ovalRadii = vec2(sizeFactor * 0.6, sizeFactor * 0.3);\n\n        // Random initial rotation angle\n        float initialAngle = hash(index * 45.352) * 6.2831; // 0 to 2*pi\n\n        // Random rotation speed (from -0.5 to 0.5 radians per second)\n        float rotationSpeed = -0.5 + hash(index * 123.456) * 1.0;\n\n        // Compute total rotation angle\n        float angle = initialAngle + rotationSpeed * iTime;\n\n        // Random speed (from 0.1 to 0.3)\n        float speed = 0.1 + 0.2 * hash(index * 99.123);\n\n        // Adjust position over time to move slices from right to left\n        float newX = position.x - speed * iTime;\n\n        // Wrap the x-coordinate when it goes off-screen\n        float bound = 1.5 * iResolution.x / iResolution.y; // Adjust bound for aspect ratio\n        newX = mod(newX + bound, 2.0 * bound) - bound;\n\n        // Use the adjusted position\n        vec2 p = uv - vec2(newX, position.y);\n\n        // Apply rotation\n        p = rotate2D(angle) * p;\n\n        // Square parameters (body of the bread)\n        vec2 squareCenter = vec2(0.0, -ovalRadii.y);\n        float dSquare = sdSquare(p - squareCenter, squareSize);\n\n        // Oval parameters (top of the bread)\n        vec2 ovalCenter = vec2(0.0, squareSize.y / 2.0 - ovalRadii.y);\n        float dOval = sdEllipse(p - ovalCenter, ovalRadii);\n\n        // Combine the square and oval using union operation\n        float dSlice = min(dSquare, dOval);\n\n        // Update minimum distance\n        d = min(d, dSlice);\n    }\n\n    // Smooth edges for anti-aliasing\n    float thickness = 0.002;\n    float alpha = smoothstep(0.0, thickness, -d);\n\n    // Set the fragment color using the breadColor parameter\n    vec3 backgroundColor = vec3(0.55, 0.32, 0.13); \n    vec3 color = mix(backgroundColor, breadColor, alpha);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}