{"ver":"0.1","info":{"id":"4d3SW8","date":"1458877370","viewed":1181,"name":"Scottish Tartan Study","username":"Hanley","description":"Static Study in replicating this pattern: http://www.dreamstime.com/stock-image-vector-seamless-pattern-scottish-tartan-black-white-gray-red-image36714971\n\nDrag Mouse Horizontally to Zoom","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["study","pattern","cloth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159\n#define TWO_PI 6.283185\n\nfloat polygonDistanceField(in vec2 pixelPos, in int N) {\n    // N = number of corners\n    float a = atan(pixelPos.y, pixelPos.x) + PI/2.; // angle\n    float r = TWO_PI/float(N); // ~?\n    // shapping function that modulates the distances\n    float distanceField = cos(floor(0.5 + a/r) * r - a) * length(pixelPos);\n    return distanceField;\n}\n\nfloat minAngularDifference(in float angleA, in float angleB) {\n    // Ensure input angles are -Ï€ to Ï€\n    angleA = mod(angleA, TWO_PI);\n    if (angleA>PI) angleA -= TWO_PI;\n    if (angleA<PI) angleA += TWO_PI;\n    angleB = mod(angleB, TWO_PI);\n    if (angleB>PI) angleB -= TWO_PI;\n    if (angleB<PI) angleB += TWO_PI;\n\n    // Calculate angular difference\n    float angularDiff = abs(angleA - angleB);\n    angularDiff = min(angularDiff, TWO_PI - angularDiff);\n    return angularDiff;\n}\n\nfloat map(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\nfloat mapAndCap(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    float v = map(value, istart, istop, ostart, ostop);\n    v = max( min(ostart,ostop), v);\n    v = min( max(ostart,ostop), v);\n    return v;\n}\n\n\n// Matrix Transforms\nmat2 rotate2d(float angle);\nmat2 scale(vec2 scale);\n\n// Draw Scottish Subtile\nvec3 subsubtile(in vec2 st, in vec3 primaryColor, in vec3 secondaryColor) {\n    vec3 color = vec3(.2);\n\n    // divide into tiles\n    float divisions = 3.;\n    vec2 mst = st;\n    mst *= divisions;\n    // calculate index\n    float cellx = floor(mst.x);\n    float celly = floor(mst.y);\n    float colOffset = mod(celly, 3.)-1.;\n    int index = int(cellx + celly*divisions);\n    // tile\n    mst = mod(mst, 1.);\n\n    vec3 edgeColor = vec3(0.3);\n\n    // Determine fill color\n    color = primaryColor;\n    if (mod(cellx-colOffset, 3.) == 2.) {\n        color = secondaryColor;\n    }\n\n    // Draw Borders (Top and Left)\n    float edge = 0.;\n    float br = 0.18;\n    if (mst.x < br) {\n        edge += 1.;\n        if (mod(cellx-colOffset, 3.) == 1.) {\n            edge -= 1.;\n        }\n    }\n    if (mst.y > 1.-br) {\n        edge += 1.;\n        if (mod(cellx-colOffset, 3.) == 2.) {\n            if (primaryColor == secondaryColor) {\n                edge -= 1.;\n            }\n        }\n    }\n    if (edge >=1.) {\n        color = edgeColor;\n    }\n\n    return color;\n}\n\nvec3 subtile(in vec2 st, in vec3 primaryColor, in vec3 secondaryColor) {\n    vec3 color = vec3(.2);\n\n    // divide into tiles\n    float divisions = 3.;\n    vec2 mst = st;\n    mst *= divisions;\n    // tile\n    mst = mod(mst, 1.);\n\n    color = subsubtile(mst, primaryColor, secondaryColor);\n\n    return color;\n}\n\nvec3 largetile(in vec2 st) {\n    vec3 color = vec3(0.5);\n    \n    // require a 3 row space (in addition to the 9x9=81) for grey border\n    st *= 84./81.;\n    st.x -= 3./84.;\n\n    // divide into tiles\n    float divisions = 9.;\n    vec2 mst = st;\n    mst *= divisions;\n    // calculate index\n    float cellx = floor(mst.x);\n    float celly = floor(mst.y);\n    float colOffset = mod(celly, 3.)-1.;\n    int index = int(cellx + celly*divisions);\n    // tile\n    mst = mod(mst, 1.);\n\n    vec3 red = vec3(0.99, 0.2,0.2);\n    vec3 white = vec3(0.97);\n    vec3 grey = vec3(0.8);\n    vec3 black = vec3(0.05);\n\n    /*\n    vec3 primaryColor = white;\n    vec3 secondaryColor = white;\n\n    if (mod(celly, 2.) == 1.) {\n        primaryColor = red;\n    }\n    if (mod(cellx, 2.) == 1.) {\n        secondaryColor = red;\n    }\n\n    if (celly == 0. || celly == 1. || celly == 7. || celly == 8.) {\n        primaryColor = black;\n    }\n    if (cellx == 0. || cellx == 1. || cellx == 7. || cellx == 8.) {\n        secondaryColor = black;\n    }\n\n    if (celly == 9.) {\n        primaryColor = grey;\n    }\n    if (cellx == -1.) {\n        secondaryColor = grey;\n    }\n\t*/\n    \n    // More Compact Assignment of Colors by @FabriceNeyret2\n    vec3 primaryColor = \n        celly == 9. ? grey\n       \t\t: celly == 0. || celly == 1. || celly == 7. || celly == 8. ? black\n        \t\t: mod(celly, 2.) == 1. ? red\n        \t\t\t: white;\n    \n    vec3 secondaryColor = \n        cellx == -1. ? grey\n            : cellx == 0. || cellx == 1. || cellx == 7. || cellx == 8. ? black\n                : mod(cellx, 2.) == 1. ? red\n                \t: white;\n\n    // Create Subtile\n    color = subtile(mst, primaryColor, secondaryColor);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n  \tvec2 u_mouse = iMouse.xy;\n  \tvec2 u_resolution = iResolution.xy;\n    \n    vec3 color = vec3(0.2);\n    float t = u_time;\n    vec2 mouse_n = u_mouse.xy / u_resolution;\n\n    vec2 st = fragCoord.xy / u_resolution.xy;\n    st.x *= u_resolution.x / u_resolution.y; // quick aspect ratio fix\n    \n    st = st*2.-1.;\n    \n    // SCALE\n    // st = scale(vec2(mouse_n.x*0.95+0.05))*st;\n    // st = scale(vec2(0.15))*st;\n    // as @FabriceNeyret2 pointed out, the scale function can be replaced by simply multiplying the vector scale\n    st = vec2(mouse_n.x*0.95+0.05)*st;\n    \n    st = rotate2d(PI*1.9)*st;\n    st += .5;\n\n\n    float divisions = 9.;\n    vec2 mst = st;\n    mst *= divisions;\n    mst = mod(mst, 1.);\n\n    color = largetile(mst);\n    \n\n    // Render Color\n\tfragColor = vec4(color,1.0);\n}\n\n\n// rotate matrix\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle) );\n}\n\n// scale matrix\n// as @FabriceNeyret2 pointed out, the scale function can be replaced by simply multiplying the vector scale\n/*\nmat2 scale(vec2 scale) {\n    return mat2(scale.x, 0,\n                0, scale.y);\n}\n*/","name":"Image","description":"","type":"image"}]}