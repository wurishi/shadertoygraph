{"ver":"0.1","info":{"id":"Mdffz7","date":"1500449530","viewed":2257,"name":"NTSC Decoder","username":"xot","description":"Analog-style NTSC decoder. Generates Apple ][-like color bars signal in Buffer A. Then decodes it like a composite television signal, producing color artifacts from the original high-frequency signal.\n\nSimple version: https://www.shadertoy.com/view/3t2XRV","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["binary","video","nes","cga","apple","ntsc","composite","artifact","decoder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  NTSC Decoder\n//\n//  Decodes composite video signal generated in Buffer A.\n//\n//  copyright (c) 2017-2018, John Leffingwell\n//  license CC BY-SA Attribution-ShareAlike\n\n#define PI   3.14159265358979323846\n#define TAU  6.28318530717958647693\n\n//  TV-like adjustments\nconst float SAT = 1.0;      //  Saturation / \"Color\" (normally 1.0)\nconst float HUE = 0.0;      //  Hue / \"Tint\" (normally 0.0)\nconst float BRI = 1.0;      //  Brightness (normally 1.0)\n\n//  Filter parameters\nconst int   N   = 15;       //  Filter Width\nconst int   M   = N/2;      //  Filter Middle\nconst float FC  = 0.25;     //  Frequency Cutoff\nconst float SCF = 0.25;     //  Subcarrier Frequency\n\n//\tColorspace conversion matrix for YIQ-to-RGB\nconst mat3 YIQ2RGB = mat3(1.000, 1.000, 1.000,\n                          0.956,-0.272,-1.106,\n                          0.621,-0.647, 1.703);\n\n//\tTV-like adjustment matrix for Hue, Saturation, and Brightness\nvec3 adjust(vec3 YIQ, float H, float S, float B) {\n    mat3 M = mat3(  B,      0.0,      0.0,\n                  0.0, S*cos(H),  -sin(H), \n                  0.0,   sin(H), S*cos(H) );\n    return M * YIQ;\n}\n\n//\tHann windowing function\nfloat hann(float n, float N) {\n    return 0.5 * (1.0 - cos((TAU*n)/(N-1.0)));\n}\n\n//\tSinc function\nfloat sinc(float x) {\n    if (x == 0.0) return 1.0;\n\treturn sin(PI*x) / (PI*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 size = iChannelResolution[0].xy;\n\tvec2 uv = fragCoord.xy / size;\n    \n    if (uv.y < 0.1 || uv.y > 0.9) {\n        \n        //  Display original signal in the margins\n    \tfragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n        \n    } else {\n        \n\t    //  Compute sampling weights\n    \tfloat weights[N];\n    \tfloat sum = 0.0;\n    \tfor (int n=0; n<N; n++) {\n        \tweights[n] = hann(float(n), float(N)) * sinc(FC * float(n-M));\n        \tsum += weights[n];\n    \t}\n        \n        //  Normalize sampling weights\n        for (int n=0; n<N; n++) {\n            weights[n] /= sum;\n        }\n        \n        //\tSample composite signal and decode to YIQ\n        vec3 YIQ = vec3(0.0);\n        for (int n=0; n<N; n++) {\n            vec2 pos = uv + vec2(float(n-M) / size.x, 0.0);\n\t        float phase = TAU * (SCF * size.x * pos.x);\n            YIQ += vec3(1.0, cos(phase), sin(phase)) * texture(iChannel0, pos).rgb * weights[n];\n        }\n        \n        //  Apply TV adjustments to YIQ signal and convert to RGB\n        fragColor = vec4(YIQ2RGB * adjust(YIQ, HUE, SAT, BRI), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Apple II lores color bars generated by 4-bit patterns.\n//\n//  Generates a high-frequency, 1-bit deep lumanance signal.\n//  Color is generated by NTSC composite color artifacting.\n//\n//\tcopyright (c) 2017, John Leffingwell\n//  license CC BY-SA Attribution-ShareAlike\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixel = floor(fragCoord.x);\n   \tfloat value = floor(16.0 * fragCoord.x / iResolution.x);\n    float power = exp2(mod(pixel, 4.0));\n    float bitvalue = step(power, mod(value, 2.0 * power));\n\n    fragColor = vec4(vec3(bitvalue), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}