{"ver":"0.1","info":{"id":"cdBczw","date":"1687506688","viewed":69,"name":"tetrahedraon fractal","username":"MonterMan","description":"fractal","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nvec3 fold(vec3 p, vec3 n)\n{\n    return p - 2.0 * max(0.0, dot(p, n)) * n;\n}\n\nmat2 rotate2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nfloat sdFractal(vec3 p)\n{\n    vec3 tip = vec3(0, 1.0, 0);\n    \n    const int ITER_COUNT = 10;\n    for (int i = 0; i < ITER_COUNT; ++i)\n    {\n        // fold space\n        float theta = PI / 5.1;\n        vec3 symmetryN = vec3(sin(theta), -cos(theta), 0.0);\n        for (int j = 0; j < 3; ++j)\n        {\n            p = fold(p, symmetryN);\n            symmetryN.xz *= rotate2d(2.0*PI/3.0);\n        }\n\n        p += vec3(0, -0.1, 0);\n        float timeScale = 0.5;\n        float animTime = timeScale * iTime;\n        p.zx *= rotate2d(animTime);\n        p.xy *= rotate2d(animTime);\n        p.zy *= rotate2d(animTime);\n        p += vec3(0, 0.1, 0);\n\n        if (i != ITER_COUNT - 1)\n        {\n            p -= tip;\n            p *= 2.0;\n            p += tip;\n        }\n    }\n    \n    return length(p - tip) * pow(2.0, -float(ITER_COUNT)) - 0.001;\n}\n\nfloat map(vec3 p)\n{\n    return sdFractal(p);\n}\n\nvec3 calc_normal(vec3 p)\n{\n    vec2 e = vec2(0,0.0001);\n    return normalize(vec3(map(p+e.yxx), map(p+e.xyx), map(p+e.xxy)) - map(p));\n}\n\nfloat shadow(vec3 ro, vec3 l)\n{\n    float t = 0.0;\n    float k = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        vec3 p = ro + t * l;\n        float dist = map(p);\n        k = min(k, 2.0*dist/t);\n        if (dist < 0.001)\n        {\n            return 0.0;\n        }\n        t += dist;\n    }\n    return k;\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    float result = 1.0;\n    float tap = 0.1;\n    for (int i = 0; i < 2; ++i)\n    {\n        float tapDist = tap*float(i+1);\n        float dist = map(p + tapDist*n);\n        result = min(result, dist/tapDist);\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float viewAngle = 2.0*PI*iMouse.x / 800.0;\n    vec3 ro = 1.0*vec3(cos(viewAngle), 0.5, sin(viewAngle));\n    vec3 at = vec3(0);\n    vec3 camera_z = normalize(at - ro);\n    vec3 camera_x = normalize(cross(vec3(0,1,0), camera_z));\n    vec3 camera_y = cross(camera_z, camera_x);\n    vec3 rd = normalize(camera_x * uv.x + camera_y * uv.y + 1.3 * camera_z);\n    \n    vec3 l = normalize(vec3(-0.5, 0.5, -0.5));\n    vec3 ambient = vec3(0.2, 0.3, 0.4);\n    \n    vec3 col = ambient;\n    float t = 0.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float dist = map(p);\n        if (dist < 0.001)\n        {\n            vec3 albedo = vec3(0.99);\n            vec3 n = calc_normal(p);\n            float directLight = max(0.0, dot(l, n)) * shadow(p + 0.001*n, l);\n            col = albedo * (0.2*ambient*ao(p, n) + directLight);\n            break;\n        }\n        t += dist;\n    }\n\n    // Output to screen\n    //col = col / (0.5 + col);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}