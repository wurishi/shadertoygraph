{"ver":"0.1","info":{"id":"NlSyDh","date":"1649557295","viewed":78,"name":"2022-04-09 test","username":"mindseye","description":"Work in progress.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sphere intersection\n// Sphere radius in sphere.w.\n// Returns positive distance from rayPos to sphere, else -1.\nfloat raySphIntersect( in vec3 rayPos, in vec3 rayNorm, in vec4 sphere )\n{\n\tvec3 oc = rayPos - sphere.xyz;\n\tfloat b = dot(oc, rayNorm);\n\tfloat c = dot(oc, oc) - sphere.w*sphere.w;\n\tfloat h = b*b - c;\n\tif(h < 0.0) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// For a plane having normal plane.xyz, at distance plane.w from the origin.\n// Returns distance along the ray at which intersection occurs,\n// can be negative.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat rayPlaneIntersect(in vec3 rayPos, in vec3 rayNorm, in vec4 plane) {\n    vec3 planeNormal = plane.xyz;\n    float denom = dot(planeNormal, rayNorm);\n    vec3 planePoint = plane.w * planeNormal;\n    return dot(planePoint - rayPos, planeNormal) / denom;\n}\n\n// Intensity of a white light at light.xyz with intensity light.w.\nfloat pointLight(in vec3 matPosition, in vec3 matNormal, vec4 light) {\n  float ambient = 0.05;\n  float lightDistance = length(matPosition - light.xyz);\n  if (lightDistance < 0.0001) {\n    return ambient;\n  }\n  float dotFactor = dot(matNormal, normalize(light.xyz - matPosition));\n  if (dotFactor < 0.0) {\n    return ambient;\n  }\n  float lightIntensity = ambient + light.w * dotFactor / (lightDistance * lightDistance);\n  return lightIntensity;\n}\n\nvec3 reflectRay(in vec3 rayNormal, in vec3 matNormal) {\n    return normalize(2.0 * dot(-rayNormal, matNormal) * matNormal + rayNormal);\n}\n\nfloat step(in float x, in float y) {\n  if (x < y) return 0.0;\n  return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 screen = vec3((2.0*fragCoord.xy-iResolution.xy) / iResolution.y, 0);\n    vec3 screenRayNorm = normalize(vec3(screen.x, screen.y + 0.2, -2.0));\n\n    vec4 sphere = vec4(0, 1.2, -5, 2);\n    vec4 light = vec4(2.5, 0.3, -3, 2);\n    vec3 planeNorm = vec3(0, 1, 0);\n    vec4 plane0 = vec4(planeNorm, -1);\n\n    vec3 rayColor = vec3(0);\n    vec3 rayPos = screen;\n    vec3 rayNorm = screenRayNorm;\n    float rayEffect = 1.0;\n    bool hit = false;\n    for (int i = 0; i < 10; i++) {\n        // Hit the sphere?\n        float sphereDist = raySphIntersect(rayPos, rayNorm, sphere);\n        //sphereDist = 1000.0;\n        // Hit the plane?\n        float planeDist = rayPlaneIntersect(rayPos, rayNorm, plane0);\n        float reflectivity;\n        if ((sphereDist > 0.0) && ((sphereDist < planeDist) || (planeDist < 0.0))) {\n            vec3 intersect = rayPos + sphereDist * rayNorm;\n            vec3 intersectNorm = normalize(intersect - sphere.xyz);\n            vec3 materialColor = (vec3(1) -\n                sin((intersect.x + 3.0 * intersect.z) * 1.0) * vec3(0.75, 0, 0) +\n                sin(2.0 * iTime + (intersect.x + intersect.z) * 25.0) * vec3(1, 1, 0) +\n                sin(intersect.y * 2.0) * vec3(0, 1, 1));\n            reflectivity = max(sqrt(3.0) - 0.75 * length(materialColor), 0.0);\n            rayColor += rayEffect * materialColor * vec3(pointLight(intersect, intersectNorm, light));\n            rayPos += sphereDist * rayNorm;\n            rayNorm = reflectRay(rayNorm, intersectNorm);\n            hit = true;\n        } else if (planeDist > 0.0 && (planeDist < sphereDist || sphereDist < 0.0)) {\n            vec3 planeIntersect = rayPos + planeDist * rayNorm;\n            float materialColor = 0.1 + 0.4 * (\n                mod(\n                floor(mod(planeIntersect.x * 2.0, 2.0)) +\n                floor(mod(planeIntersect.z * 2.0, 2.0)),\n                2.0));\n            rayColor += rayEffect * materialColor * vec3(pointLight(planeIntersect, planeNorm, light));\n            rayPos += planeDist * rayNorm;\n            rayNorm = reflectRay(rayNorm, planeNorm);\n            reflectivity = 0.85;\n            hit = true;\n        } else {\n            break;\n        }\n        rayEffect *= reflectivity;\n        rayPos += 0.00001 * rayNorm;\n    }\n\n    if(hit) {\n        // Add some ambient light.\n        rayColor += 0.02;\n    } else {\n        rayColor = vec3(screen.xyx);\n    }\n\n    fragColor = vec4(rayColor, 1);\n}","name":"Image","description":"","type":"image"}]}