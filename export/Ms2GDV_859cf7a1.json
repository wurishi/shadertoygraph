{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Set this to 1.0 for crazy morphing animation.\n#define crazyAnim 0.0\n\nfloat PI=3.14159265;\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 255.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901);\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n\t//else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\t//else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// exponential smooth min (k = 32);\n/*float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}*/\n\n// This function basically is a procedural environment map that makes the sun and sky.\n// (I deleted the sky to make it more gloomy)\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.1 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn environmentSphereColor * 0.01 + sunCol * sunIntensity;\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n\t//vec3 center = vec3(0, 0, 0.0);\n\t//p -= center;\n\t//rad += sin(p.y * 32.0 - iTime * 8.0) * 0.01;\n\t// This makes a basic sphere.\n\treturn length(p) - rad;\n}\nfloat dSphereWave(vec3 p, float rad)\n{\n\t//vec3 center = vec3(0, 0, 0.0);\n\t//p -= center;\n\trad -= 0.05;\n\trad += sin(p.y * 8.0 - iTime * 2.0) * 0.03;\n\treturn length(p) - rad;\n}\n\nfloat dBox(vec3 pos)\n{\n\tfloat b = 0.8;\n\tvec3 center = vec3(0, 0, 0.0);\n\treturn length(max(abs(pos - center)-(b*(cos(pos.y))),0.0));\n}\n\nfloat dBoxSigned(vec3 p)\n{\n\t// This makes a twisted box that is cut off.\n\tfloat b = 0.8;\n\t//vec3 center = vec3(0, 0, 0.0);\n\tp = RotateY(p, (p.y * cos(iTime*crazyAnim)-0.24)*PI);\n\tvec3 d = abs(p /*- center*/) - b*abs(cos(p.y + 0.5));\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dFloor(vec3 p)\n{\n\treturn p.y + 2.0;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z + abs(p.y)*0.05;\n}\n\nfloat dJank(vec3 p)\n{\n\t//p += vec3(0.0, -1.54, 0.0);\n\tp += vec3(0.0, -1.62, 0.0);\n\t// This makes the janky blade object. It's really just a sphere subtracted from a cube,\n\t// but twisted and cut off.\n\treturn max(dBoxSigned(p), -dSphere(p, 1.0));\n}\n\nfloat dSquareJank(vec3 p)\n{\n\t// This copies 5 rotations of the basic janky blade object. The 5 rotations make most of a cube.\n\t// I use smin() function to smoothly blend between the 5 objects.\n\tfloat final = dJank(p);\n\t//const float blend = 7.0;// 0.41;\n\tconst float blend = 0.41;\n\tvec3 p2 = p.xzy * vec3(1.0, 1.0, -1.0);// RotateX(p, PI/2.0);\n\t//vec3 p2 = RotateX(p, PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.xzy * vec3(1.0, -1.0, 1.0);//  RotateX(p, -PI/2.0);\n\t//p2 = RotateX(p, -PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.yxz * vec3(1.0, -1.0, 1.0);// RotateZ(p, PI/2.0);\n\t//p2 = RotateZ(p, PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.yxz * vec3(-1.0, 1.0, 1.0);// RotateZ(p, -PI/2.0);\n\t//p2 = RotateZ(p, -PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.xyz * vec3(1.0, -1.0, -1.0);\n\t//final = smin(final, dJank(p2), blend);\n\treturn final;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\t//vec3 c = vec3(1.0, 1.0, 1.0)* 1.0;\n\t//vec3 q = mod(p,c)-0.5*c;\n\t//p = q;\n\n\t// This makes the janky-looking blade object.\n\tfloat final = dSquareJank(p);\n\t// This makes the wavy sphere on the inside.\n\tfinal = min(final, dSphereWave(p, 0.1 + sin(iTime*0.0) * 0.015 + 0.87));\n\t//final = smin(final, sdCylinder(p, vec3(0.0, 0.0, 0.001) ), 0.5);\n\t//final = min(final, dFloor(p));\n\treturn final;\n\t//return clamp((distance(pos, vec3(0, 0, 1.0)) - 1.0), 0.0, 1.0);\n\t//return dSphere(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(2.6); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\tvec3 iA, iB;\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 1.9, camPos, camPos+relVec,\n\t\t\t\t\t\t\t\t\t  iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.02;\n\tfloat t = 0.5;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 6.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n\t\tfor (int i = 0; i < 180; i++)\t// This is the count of how many times the ray actually marches.\n\t\t{\n\t\t\tif ((t > maxDepth) || (abs(dist) < 0.001))\n            {\n                break;\n                continue;\t// break DOESN'T WORK!!! ARRRGGG!\n            }\n\t\t\tpos = camPos + relVec * t;\n\t\t\t// *******************************************************\n\t\t\t// This is _the_ function that defines the \"distance field\".\n\t\t\t// It's really what makes the scene geometry.\n\t\t\t// *******************************************************\n\t\t\tdist = DistanceToObject(pos);\n\t\t\tinc = dist;\n\t\t\tt += inc * 0.45;\t// because deformations mess up distance function.\n\t\t\t\n\t//\t\tif ((t > maxDepth) || (abs(dist) < 0.001)) break;\n\t\t}\n\t}\n\telse\n\t{\n\t\tt = maxDepth + 1.0;\n\t}\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(1.0, 1.0, 0.0));\n\t// This sun color value will only be used as a backup in case no ray hits the object.\n\tvec3 finalColor = GetSunColorReflection(relVec, sunDir) + vec3(0.1, 0.1, 0.1);\n\n\t// calculate the normal from the distance field. The distance field is a volume, so if you\n\t// sample the current point and neighboring points, you can use the difference to get\n\t// the normal.\n\tvec3 smallVec = vec3(0.02, 0, 0);\n\tvec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n\t\t\t\t\t   dist - DistanceToObject(pos - smallVec.yxy),\n\t\t\t\t\t   dist - DistanceToObject(pos - smallVec.yyx));\n\tnormal = normalize(normal);\n\n\t// calculate the reflection vector for highlights\n\tvec3 ref = reflect(relVec, normal);\n\t\n\t// This is the rainbow coloring for the inside wavy sphere.\n\tvec3 spinner = abs(RotateY(normal * normal, iTime* 2.0)) * vec3(1.0, 1.0, 1.0);\n\tvec3 inner = abs(RotateY((-normal) * (-normal), iTime* 2.0)) * vec3(1.0, 1.0, 1.0);\n\t// get some texture on that inner wavy rainbow sphere.\n\tvec4 texX = texture(iChannel0, normal.yz);// * vec2(0.925, 0.0) + vec2(iTime*1.0, 0.0));\n\tvec4 texZ = texture(iChannel0, normal.xy);// * vec2(0.0, 0.925) + vec2(0.0, iTime*1.0));\n\tvec4 noise = mix(texX, texZ, abs(normal.z));\n\n\t// If a ray actually hit the object, let's light it.\n\tif (t <= maxDepth)\n\t{\n\t\tfinalColor = GetSunColorReflection(ref, sunDir)*0.68;// sunCol * max(0.0, dot(normal, -sunDir));\n\t\t// make a darker stripe in the middle, redder towards the top and bottom\n\t\tfinalColor *= vec3(0.3 + abs(pos.y*pos.y), 0.35, 0.3);\n\t\t// we need the glowy rainbow sphere to illuminate the blade object from the inside.\n\t\tvec3 innerLight = inner * 2.0 * max(0.0,dot(pos, -normal)) + vec3(1.0,1.0,1.0)*0.3;\n\t\tinnerLight *= (1.45 - length(pos));\n\t\tfinalColor += max(vec3(0,0,0),innerLight);\n\t\tfinalColor += vec3(0.02, 0.050, 0.09);\n\t\t//finalColor = sunCol * max(0.0, dot(normal, sunDir));\n\n\t\t// If we are inside a certain radius, call it the inner sphere and make it rainbow colors.\n\t\tif ((length(pos) < 1.0) || (length(pos.xz) < 0.5))\n\t\t{\n\t\t\tfinalColor = spinner*2.0 + vec3(1.0,1.0,1.0)*0.25;\n\t\t\tfinalColor += noise.xyz*0.15;\n\t\t}\n\t}\n\t//finalColor += hit*0.1;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Ms2GDV","date":"1394129693","viewed":1424,"name":"Scythe","username":"otaviogood","description":"This is my first attempt at ray marching.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}