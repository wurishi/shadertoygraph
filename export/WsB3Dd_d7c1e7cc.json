{"ver":"0.1","info":{"id":"WsB3Dd","date":"1550253633","viewed":103,"name":"Candyman LL","username":"Sciman101","description":"Candyman from Lethal League","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 headColor = vec3(.9,.9,0);\nconst vec3 mouthColor = vec3(.9,.2,0);\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n//Thanks iq\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - .1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    p.y = -p.y;\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nint mat;\n\n//Main scene functon\nfloat scene(vec3 p) {\n\n   //Head and mouth\n   float sphere = sdSphere(p,3.);\n    \n   vec3 q = p;\n   q.y *= 1.+abs(sin(iTime));\n   float wedge = sdTriPrism(q+vec3(-3,.5,0),vec2(2,5));\n    \n   //Hat\n    q = p;\n    q -= vec3(-.25,2.6,0);\n    q.xy = rotate(q.xy,-.15);\n   float hat = sdCappedCylinder(q,vec2(2.,.15));\n    hat = min(hat,sdSphere(q,1.5));\n    \n   //Eyes\n   p.z = abs(p.z);\n   float eyes = sdSphere(p+vec3(-1.5,-1.5,-1.5),1.);\n    \n    //Put it all together\n    \n   float result = max(sphere,-wedge);\n   result = min(result,eyes);\n    result = min(result,hat);\n    \n    if (result == sphere) {\n        mat = 0;\n    }else if (result == eyes){\n        mat = 2;\n    }else{\n        mat = 1;\n    }\n    \n   return result;\n    \n}\n\n//rotate and cameraspin from yx\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, -.3);\n    p.xz = rotate(p.xz, 17.+sin(iTime));\n}\n\nvec3 trace(vec3 cam, vec3 dir) {\n    //Perform raytrace\n    float t = 0.;\n    float k = 0.;\n    float closest = 500.;\n    vec3 h;\n    for(int i=0;i<100;++i) {\n        k=scene(cam+dir*t);\n        t+=k;\n        closest = min(k,closest);\n        if(k<.001)\n        {\n            h = cam+dir*t;\n            vec2 o=vec2(.02,0);\n            vec3 n= normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n\n            float light = dot(n,normalize(vec3(1,2,3)))*.5+1.0;\n            light = step(0.1,light);\n            \n            if (mat == 0) {\n                return headColor*light;\n            }else if (mat == 2) {\n                \n                //Pupils dynamically follow camera\n                \n                float d = dot(n,-dir);\n                \n                return vec3(1.-step(abs(1.-d),.05))*light;\n                \n                \n            }else if (mat == 1) {\n                return mouthColor*light;\n            }\n        }\n    }\n    \n    if (closest < .1) {\n        return vec3(0);\n    }else return vec3(.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n\n    //Multiply by aspect\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Define camera position and direction\n    vec3 cam = vec3(0,0,10);\n    vec3 dir = normalize(vec3(uv,-1));\n    \n    cameraspin(cam);\n    cameraspin(dir);\n    \n    fragColor.rgb = trace(cam,dir);\n    \n}","name":"Image","description":"","type":"image"}]}