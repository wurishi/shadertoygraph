{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// set this to 128 if you live in the future or have 1895719 GTX 780 in SLI\n#define TRACE_STEPS 64\n\n#define t (iTime)\n\nmat4 m_translation(vec3 tr) {\n\treturn mat4(\n\t\tvec4(1., 0., 0., 0.),\n\t\tvec4(0., 1., 0., 0.),\n\t\tvec4(0., 0., 1., 0.),\n\t\tvec4(tr, 1.));\n}\n\nmat3 m_rot_x(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat3(1., 0., 0., 0., c, s, 0., -s, c);\n}\n\nmat3 m_rot_y(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat3(c, 0., -s, 0., 1., 0., s, 0., c);\n}\n\nmat3 m_rot_z(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat3(c, s, 0., -s, c, 0., 0., 0., 1.);\n}\n\nmat4 m_look_at(in vec3 pos, in vec3 at, in vec3 up) {\n\tvec3 fwd = normalize(at - pos);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\treturn m_translation(pos)\n\t\t* mat4(vec4(right, 0.), vec4(up, 0.), vec4(fwd, 0.),\n\t\t\t  vec4(0., 0., 0., 1.));\n}\n\nvec4 noise4(in vec2 v) { return texture(iChannel0, v / 256., -100.); }\nfloat hash(float v) { return texture(iChannel0, vec2(v) / 256., -100.).r; }\nfloat hash(in vec2 v) { return texture(iChannel0, (v + .5) / 256., -100.).r; }\nfloat noise(in vec2 v) { return texture(iChannel0, v / 256., -100.).r; }\nfloat noise(in vec3 v) {\n\tv /= 256.;\n\treturn .5 * (\n\t\ttexture(iChannel0, v.xz, -100.).b +\n\t\ttexture(iChannel0, v.yx, -100.).g);\n}\nfloat hash(vec3 v) { return noise(vec2(dot(v, vec3(1., 51., 23.)), 0.)); }\nfloat noise(in float v) {\n\tfloat F = floor(v), f = fract(v);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(hash(F), hash(F+1.), f);\n}\nvec3 noise3(in float v) {\n\treturn vec3(noise(v), noise(v+17.3), noise(v+23.9));\n}\nvec3 noise3(in vec2 v) { return texture(iChannel0, v / 256., -100.).rgb; }\nvec3 noise3(in vec3 v) {\n\tv /= 256.;\n\treturn .5 * (\n\t\ttexture(iChannel0, v.xz, -100.).rgb +\n\t\ttexture(iChannel0, v.yx, -100.).abg);\n}\nfloat fnoise(in vec3 v) {\n\treturn .5 * noise(v) + .25 * noise(v * 2.01) + .125 * noise(v * 3.98);\n\t//return noise(v);// + .25 * noise(v * 2.01) + .125 * noise(v * 3.98);\n}\n\nfloat vmax(in vec3 v) {\n\treturn max(v.x, max(v.y, v.z));\n}\n\nfloat d_box(in vec3 at, in vec3 size) {\n\treturn vmax(abs(at)-size);\n}\n\nvec3 o_rep(in vec3 at, in vec3 rep) {\n\treturn mod(at - .5 * rep, rep) - .5 * rep;\n}\n\nfloat bld(in vec3 at, in vec3 size) {\n\tfloat bbox = d_box(at, size);\n\tif (bbox > 1.) return bbox;\n\t\n\tfloat rows = d_box(o_rep(at, vec3(1., 3., 1.)), vec3(1., .2, 1.));\n\tfloat cols = d_box(o_rep(at, vec3(4., 1., 5.)), vec3(.2, 1., .2));\n\t\n\treturn max(bbox, min(rows, cols));\n}\n\n#define SS 45.\n\nfloat wbld(in vec3 at) {\n\tvec2 s = floor(at.xz / SS), sid = s / 16.;\n\tvec3 sat = vec3(at.x - SS * (s.x + .5), at.y, at.z - SS * (s.y + .5));\n\tfloat height = 5. + hash(s+11.) * 36.;\n\tfloat X = (hash(s)-.5) * 20.;\n\tfloat Y = (hash(s+8.)-.5) * 20.;\n\tfloat rz = (hash(s+2.)-.5)*.6;\n\tfloat rx = (hash(s+3.)-.5)*.6;\n\tfloat W = 6. + hash(s+.4)*8.;\n\tfloat D = 3. + hash(s+.4)*6.;\n\t\n\tsat += vec3(X, 0., Y);\n\tmat3 mrot = m_rot_z(rz) * m_rot_x(rx);\n\t\n\tconst float ns_scale = .2;\n\tconst float ns_iso = .49;\n\tfloat hole = fnoise(at*ns_scale) - ns_iso;\t\n\t\n\treturn .9 * max(2. * hole / ns_scale, bld(sat * mrot, vec3(D, height, W)));\n}\n\nvec3 wbld_normal(in vec3 at) {\n\tconst float e = .005;\n\tvec3 n = normalize(vec3(\n\t\twbld(at+vec3(e, 0., 0.)) - wbld(at-vec3(e, 0., 0.)),\n\t\twbld(at+vec3(0., e, 0.)) - wbld(at-vec3(0., e, 0.)),\n\t\twbld(at+vec3(0., 0., e)) - wbld(at-vec3(0., 0., e))\n\t\t));\n\treturn normalize(n + (noise(18.*at)-.5));\n}\n\nfloat trace(in vec3 o, in vec3 d) {\n\tfloat L  = 0.;\n\tfor (int i = 0; i < TRACE_STEPS; ++i) {\n\t\tvec3 p = o + d * L;\n\t\tvec2 s = floor(p.xz / SS);\n\t\tvec3 sp = vec3(p.x - SS * (s.x + .5), p.y, p.z - SS * (s.y + .5));\n\t\tfloat d = wbld(p);\n\t\tconst float ST = SS*.5 + 6.;\n\t\tL += min(d, -max(abs(sp.x)-ST, abs(sp.z)-ST));\n\t\tif (d < .001 * L) break;\n\t}\n\treturn L;\n}\n\nfloat H(in vec3 at) {\n\tvec2 a = at.xz / 256. * .02;\n\treturn 9.-24. * (\n\t\t.5 * texture(iChannel0, a, -100.).r +\n\t\t.25 * texture(iChannel0, a * 1.93, -100.).r +\n\t\t.0625 * texture(iChannel0, a * 8.07, -100.).r);\n}\n\nvec3 ground_normal(in vec3 at) {\n\tvec3 tx = vec3(2., H(at+vec3(1.,0.,0.)) - H(at-vec3(1.,0.,0.)), 0.);\n\tvec3 tz = vec3(.0, H(at+vec3(0.,0.,1.)) - H(at-vec3(0.,0.,1.)), 2.);\n\treturn normalize(normalize(cross(tz, tx))\n\t\t+ 1.5 * (noise3(at.xz*21.)-.5));\n}\n\nfloat trace_ground(in vec3 o, in vec3 d) {\n\tfloat L = 0.;\n\tfor (int i = 0; i < 16; ++i) {\n\t\tvec3 p = o + d * L;\n\t\tfloat d = p.y - H(p);\n\t\tL += d * 2.;\n\t\tif (d < .001 * L) break;\n\t}\n\treturn L;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 wobble = 2. * noise3(t);\n\tvec3 eye = vec3(70., 38., -70.);\n\tif (iMouse.z > 0.) {\n\t\teye = vec3(70., 10. + iMouse.y / iResolution.y * 68., -70.);\n\t\teye *= m_rot_y(-iMouse.x / iResolution.x * 8.);\n\t}\n\tmat4 M = m_look_at(eye + wobble, vec3(0.), vec3(0., 1., 0.));\n\tvec3 o = (M * vec4(uv * .01, 0., 1.)).xyz;\n\tvec3 d = (M * normalize(vec4(uv, 2., 0.))).xyz;\n\t\n\tfloat L_b = trace(o, d);\n\tfloat L_g = trace_ground(o, d);\n\tfloat L = min(L_b, L_g);\n\tvec3 p = o + d * L;\n\tvec3 n = vec3(0.);\n\tvec3 c = vec3(0.);\n\tif (L_g < L_b) {\n\t\tn = ground_normal(p);\n\t\tc = mix(\n\t\t\tvec3(.0, .4, .05),\n\t\t\tvec3(.3, .35, .15), noise(p.xz*.2))\n\t\t\t* (.5+.5*noise(p.xz*8.));\n\t\tc += vec3(1.,0.,0.) * smoothstep(.4,.6,noise(p.xz*.3)) * smoothstep(.9,.91,noise(p.xz*8.));\n\t\tc += vec3(.5,.5,1.) * smoothstep(.4,.6,noise(p.xz*.2 + vec2(100.))) * smoothstep(.9,.91,noise(p.xz*11.));\n\t} else {\n\t\tn = wbld_normal(p);\n\t\tc = mix(vec3(.3, .3, .24) + vec3(.3) * noise(p*2.),\n\t\t\t\tvec3(.0, .4, .05),\n\t\t\t   mix(.01, .9,\n\t\t\t\t   smoothstep(.3, .7, noise(p.xz*18.))\n\t\t\t\t   *smoothstep(.5, .7, noise(p*.5))));\n\t}\n\t\n\tvec3 skycolor = mix(vec3(.53, .81, .92), vec3(0., .51, 1.), smoothstep(.05, .2, d.y));\n\t\n\tvec3 ldir = vec3(1.,1.2,.3);\n\tvec3 lcolor = vec3(.8);\n\t\n\tfloat klight = (trace(p + n*.02, ldir) < 100.) ? 0. : 1.;\n\tfloat occlusion = .0;\n\t\n\tfor (int i = 0; i < 8; ++i) {\n\t\tfloat f = float(i) * 6. / 8.;\n\t\tocclusion += smoothstep(0., f, wbld(p + n * f)) / 8.;\n\t}\n\t\n\tvec3 color = c * (vec3(.25) * occlusion + klight * lcolor * max(0.,dot(normalize(ldir), n)));\n\tcolor = mix(color, skycolor, clamp((L-150.) / 300.,0.,1.));\n\t\n\tfragColor = vec4(pow(color, vec3(1. / 2.2)), 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dB3Dw","date":"1388933699","viewed":2295,"name":"ruins","username":"w23","description":"This is glitchy and of no value!","likes":41,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","noise"],"hasliked":0,"parentid":"","parentname":""}}