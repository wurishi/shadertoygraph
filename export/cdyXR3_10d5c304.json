{"ver":"0.1","info":{"id":"cdyXR3","date":"1681350352","viewed":73,"name":"Black Glass sun","username":"Vulgent","description":"fff","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotate a 3D vector around an arbitrary axis\nvec3 rotateAroundAxis(vec3 v, vec3 axis, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mix(dot(v, axis) * axis, v, cosAngle) + sinAngle * cross(axis, v);\n}\n\n// Your signed distance function with more tendrils\n#define d(q) min( length(q) - 1.7, \\\n    min( \\\n        min( \\\n            abs(atan((q).y,length((q).xz)))<.1 ? ( length(q) * length( fract(vec2( atan((q).z,(q).x), atan((q).y,length((q).xz))-.42) /.628*2.) - .5) - .2 ) : 1e3, \\\n            abs(atan((q).x,length((q).yz)))<.1 ? ( length(q) * length( fract(vec2( atan((q).y,(q).z), atan((q).x,length((q).yz))-.42) /.628*2.) - .5) - .2 ) : 1e3 \\\n        ), \\\n        abs(atan((q).z,length((q).xy)))<.1 ? ( length(q) * length( fract(vec2( atan((q).x,(q).y), atan((q).z,length((q).xy))-.42) /.628*2.) - .5) - .2 ) : 1e3 \\\n    ) \\\n)\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 9.0;\n    vec3 R = vec3(1920.0, 1080.0, 1.0); // Resolution (Width, Height, Aspect Ratio)\n    U /= R.xy; // Normalize the coordinates\n    U.x *= R.x / R.y; // Adjust the aspect ratio\n    vec3 D = normalize(vec3(U, -2.5)); // Zoom out by changing the third component (e.g., from -12.0 * R.y to -2.5)\n    vec3 p = vec3(-10, -3.9, 80), q; // Move the sphere up and to the right by setting p to (-40, -30, 80);\n\n    float rotationSpeed = 0.5;\n    float angle = iTime * rotationSpeed;\n\n    vec3 axis1 = normalize(vec3(1.0, 0.0, 0.0));\n    vec3 axis2 = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 axis3 = normalize(vec3(0.0, 0.0, 1.0));\n\n    for (O = vec4(1); O.x > 0.0 && t > 0.01 && p.y > -4.0; O -= 0.001) {\n        q = rotateAroundAxis(p, axis1, angle);\n        q = rotateAroundAxis(q, axis2, angle);\n        q = rotateAroundAxis(q, axis3, angle);\n        t = d(q);\n        p += 0.03 * t * D;\n    }\n\n    // Color and shading calculations with a black and glassy look\n    D = vec3(-1, 1, 0) * 1e-3;\n    vec3 normal = normalize(D.xxy * d(q + D.xxy) + D.xyx * d(q + D.xyx) + D.yxx * d(q + D.yxx) + D.yyy * d(q + D.yyy));\n\n    vec3 lightDir1 = normalize(vec3(0.0, 1.0, 0.5)); // First light direction\n    float NdotL1 = max(0.0, dot(normal, lightDir1)); // Diffuse lighting from the first light\n\n    vec3 lightDir2 = normalize(vec3(0.5, 0.5, 0.5)); // Second light direction\n    float NdotL2 = max(0.0, dot(normal, lightDir2)); // Diffuse lighting from the second light\n\n    vec3 baseColor = vec3(0.0); // Black color\n\n    vec3 reflectedLightDir = reflect(-lightDir1, normal);\n    vec3 viewDir = normalize(-p);\n    float RdotV = max(0.0, dot(reflectedLightDir, viewDir));\n    float specular = pow(RdotV, 10.0); // Specular highlight\n\n    O.rgb = mix(baseColor, vec3(specular), NdotL1 + NdotL2);\n\n}\n\n","name":"Image","description":"","type":"image"}]}