{"ver":"0.1","info":{"id":"7tX3Wr","date":"1621884597","viewed":118,"name":"eclipse projection","username":"LazyScholar","description":"Draw the source image and the resulting image after projecting through a pinhole camera.\nThe projection is approximated by superimposing randomized point projections.\n\nuse: ←,→,↑,↓ and mouse\n\nMy first shader ever.\nSuggestions for improvement are welcome.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["mouse","simulation","random","aperture","accumulation","pinholecamera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Draw the source image and the resulting image of a eclipse\n    after projecting through a pinhole camera.\n    \n    Might not work correctly on CPU integrated graphic units.\n    And might not work on mobile devices at all.\n    \n    To interact with the shader:\n    \n    change moon possition use  : right mouse button\n    change moon radius use     : up/down arrow\n    change aperture radius use : left/right arrow\n    \n    The moon radius and the aperture radius are normalised to the sun radius.\n    And the size and light of the resulting image is normalized too.\n    Therefore the screen distances are not of importance.\n    \n    Remarks:\n    I created this shader in order to learn a bit about shaders and signed distance fields.\n    The initial inducement where a GeoGebra thread about the performance of one applet.\n        see: https://help.geogebra.org/topic/javascript-interrupt-progress-bar-performance\n    The core of the problem revolved around how one can simulate\n    the projected image of an eclipse falling through a pinhole camera with a given aperture.\n    For more information have a look at the website of the original poster.\n        see: http://www.fransvanschooten.nl/alhacen_uk.htm#cameraobscura\n    The main problem while using normal algorithms is that the counting of the accumulated\n    light on the image screen is a O(n^2) problem.\n    My idea where that the GPU parallelization in combination with a randomized accumulation\n    technique should lead to acceptable results (similar to ray marchers).\n    On the way of discovering shaders i read about signed distance fields on the website of\n    Inigo Quilez which are perfect to calculate the outer bounds of the projected image.\n        see: https://iquilezles.org/articles/distfunctions2d\n    I think it should be possible to analytically calculate the light intensity on each\n    image position. In order to have an analytical solution for the inner area.\n    That would be the next step which I can not find time for while job hunting.\n\n    Autor:   Duffek, Johann Antonio\n    Date:    2021-05-27\n    License: MIT\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // from \" Caustic Half Nephroid\": https://www.shadertoy.com/view/XddcDr1\n    vec4 buf = texelFetch(iChannel0, ivec2(fragCoord), 0);\n#if 1\n    fragColor = vec4(sqrt(buf.xyz), 1.); // brighten up the darker parts \n#else\n    fragColor = vec4(buf.xyz, 1.); // linear distribution dark ... light\n#endif\n}\n\n/*  \n    MIT License\n\n    Copyright (c) 2021 Johann Antonio Duffek\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this\n    software and associated documentation files (the \"Software\"), to deal in the Software\n    without restriction, including without limitation the rights to use, copy, modify, \n    merge, publish, distribute, sublicense, and/or sell copies of the Software, and to \n    permit persons to whom the Software is furnished to do so, subject to the following \n    conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies \n    or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A \n    PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF \n    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Draw the source image and the resulting image of a eclipse\n    after projecting through a pinhole camera.\n\n    The used parameters are defined above\n    The source and resulting images are normalized.\n\n    The resulting image is approximated by randomizing\n    point projections on the opening of the aperture.\n    The results are accumulated and will lead to the approximation.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // read parameters from \"texture memory\"\n    if ( iFrame > 0 ) {\n        mem_val = texelFetch( iChannel0, memoryPos, 0 )*memory_range-memory_min;\n        r_a = mem_val.r;\n        radius_moon = mem_val.g;\n        dFrame = int(mem_val.b);\n        aFrame = int(mem_val.a);\n    }\n\n    // from \"Input - Mouse\": https://www.shadertoy.com/view/Mss3zH\n    m = iMouse.xy == vec2(0.0) ? vec3(iResolution.x * 0.3,iResolution.y * 0.6,0.0) : m = iMouse.xyz;\n\n    // mouse button is down\n    if( m.z>0.0 ) {\n        dFrame = maxdFrame;\n        aFrame = maxdFrame+maxaFrame;\n    }\n    \n    // from \"Input - Keyboard\": https://www.shadertoy.com/view/lsXGzf\n    // and  \" KeyTesterV2\": https://www.shadertoy.com/view/XsycWw\n    if (texelFetch( iChannel2, ivec2(KEY_LEFT,0),0 ).x > 0.0) {\n        dFrame = maxdFrame;\n        aFrame = maxdFrame+maxaFrame;\n        r_a += -r_a_step;\n    }\n    if( texelFetch( iChannel2, ivec2(KEY_RIGHT,0),0 ).x > 0.0 ) {\n        dFrame = maxdFrame;\n        aFrame = maxdFrame+maxaFrame;\n        r_a += r_a_step;\n    }\n    if( texelFetch( iChannel2, ivec2(KEY_DOWN,0),0 ).x > 0.0 ) {\n        dFrame = maxdFrame;\n        aFrame = maxdFrame+maxaFrame;\n        radius_moon += -radius_moon_step;\n    }\n    if( texelFetch( iChannel2, ivec2(KEY_UP,0),0 ).x > 0.0 ) {\n        dFrame = maxdFrame;\n        aFrame = maxdFrame+maxaFrame;\n        radius_moon += radius_moon_step;\n    }\n    r_a = clamp(r_a, memory_min.x, memory_min.x+memory_range.x);\n    radius_moon = clamp(radius_moon, memory_min.y, memory_min.y+memory_range.y);\n    \n    // parameters of the screen\n    vec2 uv = fragCoord.xy;\n    vec2 center = iResolution.xy * 0.5;\n    float time = iTime;\n\n    // mid point and radius of sun\n    vec2 m_sun = vec2(center.x * 0.5, center.y);\n    float r_sun = m_sun.x * 0.9;\n\n    // mid point and radius of moon\n    vec2 m_moon = m.xy;\n    float r_moon = r_sun * radius_moon;\n\n    // randomization on the circle of the aperture\n    float k = 1.0/(1.0 + 2.0 * r_a);\n    vec2 N = uv.x > center.x ? hash22(uvec2(uv*(iTime+1.))) : vec2(0.0);\n    float r_a_p = r_sun*r_a*k*2.0;\n    float r_rand = r_a_p * sqrt(N.x);\n    float phi_rand = N.y * M_2PI;\n    vec2 A = r_rand *vec2(sin(phi_rand),cos(phi_rand));\n\n    // mid point and radius of projected sun\n    vec2 m_sun_p = vec2(center.x * 1.5, center.y);\n    vec2 m_sun_p_n = m_sun_p +  A;\n    float r_sun_p = r_sun * k;\n\n    // mid point and radius of projected moon\n    vec2 m_moon_p = m_sun_p + (m_sun - m_moon) * k;\n    vec2 m_moon_p_n = m_sun_p_n + (m_sun - m_moon) * k;\n    float r_moon_p = r_moon * k;\n    \n    // draw the projected image\n    float image_p = (r_a_p-sdf(uv,m_sun_p,m_moon_p,r_sun_p,r_moon_p))/(r_sun_p+r_a_p);\n#if 0\n    // draw light source\n    float image = (0.5-0.5*sign(sdf(uv,m_sun,m_moon,r_sun,r_moon)));\n    // draw the projected random image\n    float image_p_n = (0.5-0.5*sign(sdf(uv,m_sun_p_n,m_moon_p_n,r_sun_p,r_moon_p)));\n#else\n    // draw light source\n    float image = 0.0;\n    if ( length(uv  - m_sun) <= r_sun && length(uv  - m_moon) > r_moon) {\n        image = 1.0;\n    }\n    float image_p_n = 0.0;\n    // draw the projected random image\n    if ( length(uv  - m_sun_p_n) <= r_sun_p && length(uv  - m_moon_p_n) > r_moon_p) {\n        image_p_n = 1.0;\n    }\n#endif\n    // draw images with accumulation\n    if ( uv.x < center.x) {\n        fragColor = vec4(1.0*image,0.5*image,0.0, 1.0);\n    } else {\n        if ( dFrame == 0 ) {\n            // load old screen (iChannel0)\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            // from \"Caustic Half Nephroid\": https://www.shadertoy.com/view/XddcDr\n            fragColor = (fragColor*(float(maxaFrame-min(aFrame,maxaFrame)+1)) + \n                         vec4(1.0*image_p_n, 0.5*image_p_n, 0.0, 1.0))/(float(maxaFrame-min(aFrame,maxaFrame)+2));\n            //                        put here a small number like  _^_  *1.015 to have a brighter resulting image\n        } else {\n            image_p *= max(0.0,(float(dFrame)-2.0)/50.0);\n            image_p_n *= max(0.0,(float(dFrame)-2.0)/50.0);\n            fragColor = vec4(1.0*max(image,image_p), 0.5*max(image,image_p), 1.0*image_p_n, 1.0);\n        }\n    }\n\n    // draw text\n    // from \"iResolution, iMouse, iDate, etc\": https://www.shadertoy.com/view/llySRh\n    vec2 R = iResolution.xy, U;\n    vec2 UV = uv/iResolution.xy;\n    if ( dFrame > 5 ) {\n        U = ( UV - vec2(-.025,.01) ) * 32.;\n        low C(18) caps C(1) low C(16)C(5)C(18)C(20)C(21)C(18)C(5) caps C(-6)  // \"rAperture\"\n        U.x-=0.5;\n        fragColor += pFloat(U, r_a,iChannel3);\n        U = ( UV - vec2(-.025,.96) ) * 32.;\n        low C(18) caps C(13) low C(15)C(15)C(14) caps C(-6)  // \"rMoon\"\n        U.x-=0.5;\n        fragColor += pFloat(U, radius_moon,iChannel3); // a bit buggy if rMoon == 1.0 -> it shows 0000.0000\n        fragColor += draw_char(iChannel3).xxxx;\n    } else {\n        if ( aFrame > 0 ) {\n            U = ( UV - vec2(-.025,.01) ) * 32.;\n            low C(1) caps C(6) low C(18)C(1)C(13)C(5) caps C(-6)  // \"aFrame\"\n            U.x-=0.5;\n            fragColor += pInt(U, float(aFrame),iChannel3);\n            fragColor += draw_char(iChannel3).xxxx;\n        }\n    }\n    \n    // save parameters\n    if (ivec2(gl_FragCoord.xy) == memoryPos) {\n        mem_val.r = r_a;\n        mem_val.g = radius_moon;\n        mem_val.b = max(float(dFrame-1),0.0);\n        mem_val.a = max(float(aFrame-1),0.0);\n        fragColor = (mem_val+memory_min)/memory_range;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Default paramters to modify the approximation.\n    Those values are all normalized to the sun radius.\n*/\n// number of frames used to accumulate\nconst int maxaFrame = 5000;\n// number of frames before accumulate\nconst int maxdFrame = 50;\n// change per step for radius of the aperture\nconst float r_a_step = 0.05;\n// change per step for radius of the aperture\nconst float radius_moon_step = 0.05;\n// radius of the aperture\nfloat r_a = 0.55;\n// radius of the moon\nfloat radius_moon = 1.0;\n// frame counting down to start start of accumulation\nint dFrame = maxdFrame;\n// frame number used to count accumulated frames\nint aFrame = maxaFrame+maxdFrame;\n// mouse vector\nvec3 m = vec3(0.0);\n// memory vector\nvec4 mem_val = vec4(0.0);\n\n// constants\nconst float M_PI = 3.14159265358979323846264338327950288;\nconst float M_2PI = M_PI * 2.0;\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n// \"memory\" constants like pos, lower limit and range\n// from \"GLSL Shadertoy, how to storage variables data?\" : \n//      https://stackoverflow.com/questions/61219967/glsl-shadertoy-how-to-storage-variables-data\nconst ivec2 memoryPos = ivec2(1,1);\n// r_a | radius_moon | dFrame | aFrame\nconst vec4 memory_min =   vec4(0.05,0.05, 0.0,0.0);\nconst vec4 memory_range = vec4(2.00,2.00,float(maxdFrame),float(maxaFrame));\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\n    Calculate two independent random numbers from 0 to 1.\n    Used to randomize the aperture point location via radius and angle.\n    \n    Might not work on CPU integrated graphic units.\n*/\n// from \"Quality hashes collection WebGL2\" : https://www.shadertoy.com/view/Xt3cDn\n// license MIT -> see provided link\n#if 1\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n#else\n//XXHash32 based (https://github.com/Cyan4973/xxHash)\n//Slower, higher quality\nuint baseHash(uvec2 p) {\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n#endif\n\nvec2 hash22(uvec2 x) {\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\n    Helper function to determine if xy is left of line between two points.\n*/\nbool isleftof(vec2 xy, vec2 P1, vec2 P2){\n    return (xy.x - P1.x) * (P2.y - P1.y) - (xy.y - P1.y) * (P2.x - P1.x) < 0.0;\n}\n\n/*\n    Helper function to determine if xy is in circle.\n*/\nbool iscircle(vec2 xy, vec2 m, float r){\n    float x = xy.x - m.x;\n    float y = xy.y - m.y;\n    return x*x + y*y <= r*r;\n}\n\n/*\n    Signed distance field of sun moon.\n    Have a look at\n    [ https://iquilezles.org/articles/distfunctions2d ]\n    for a much simpler and easier definition.\n    \n    TODO: optimize and refactor\n*/\nfloat sdf(vec2 xy,vec2 m1, vec2 m2, float r1, float r2) {\n    float l = length(m2-m1);\n    \n    bool T1 = l < abs(r2-r1); // moon within sun\n    bool T2 = l > r1+r2; // moon outside of sun\n    bool T3 = r1 > r2; // moon smaller than sun\n    bool T = !T1 && !T2; // border intersection\n    \n    float sdfc1 = length(xy-m1) - r1;\n    float sdfc2 = length(xy-m2) - r2;\n    \n    bool c1 = iscircle(xy,m1,r1); // in sun\n    bool c2 = iscircle(xy,m2,r2); // in moon\n    if ( T ) {\n        // calculate position of circle intersections\n        float l1 = (r1*r1 - r2*r2 + l*l) / (2.0 * l);\n        float h = sqrt(r1*r1 - l1*l1);\n        vec2 e1 = (m2-m1) / l;\n        vec2 e2 = e1 * mat2(0,-1,1, 0);\n        vec2 S1 = m1 + e1 * l1 + e2 * h;\n        vec2 S2 = m1 + e1 * l1 - e2 * h;\n        \n        float sdfS1 = length(xy-S1);\n        float sdfS2 = length(xy-S2);\n        \n        // in triangle of intersections and center of sun\n        bool c = (l1 >= 0.0) ? isleftof(xy,S1,m1) && !(isleftof(xy,S2,m1)) : isleftof(xy,S1,m1) || !(isleftof(xy,S2,m1));\n        // c intersected with triangle of intersections and center of moon part1\n        bool a = isleftof(xy,m1,m2) && isleftof(xy,S1,m2) && c;\n        // c intersected with triangle of intersections and center of moon part1\n        bool b = !isleftof(xy,m1,m2) && !isleftof(xy,S2,m2) && c;\n        // outside of sun without c\n        bool d = !(c1) && !(c);\n        // inside moon but not a or d\n        bool e = c2 && !(a || b || d);\n        if ( a || b ) return min(sdfS1,sdfS2);\n        if ( e ) return -sdfc2;\n        if ( !(a || b || d || e) ) return max(sdfc1,-sdfc2);\n        return sdfc1;\n    }\n    if ( T1 && T3 ) {\n        return c1 ? max(sdfc1,-sdfc2) : sdfc1;\n    }\n    if ( T2 ) { return sdfc1; }\n    return r1;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\n    Everything bellow here is Font-Stuff shamelessly stolen from\n    \"iResolution, iMouse, iDate, etc\": https://www.shadertoy.com/view/llySRh\n*/\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c, sampler2D iChannel) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char(sampler2D iChannel) {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\n// --- display int4\nvec4 pInt(vec2 p, float n, sampler2D iChannel) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45, iChannel),\n        n = -n;\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), iChannel);\n    return v;\n}\n\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n, sampler2D iChannel) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45, iChannel), n = -n;\n    v += pInt(p,floor(n), iChannel); p.x -= 2.;\n    v += char(p, 46, iChannel);      p.x -= .5;\n    v += pInt(p,fract(n)*1e4, iChannel);\n    return v;\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc fragColor+= char(U,64+CAPS+c,iChannel3);\n// NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )","name":"Common","description":"","type":"common"}]}