{"ver":"0.1","info":{"id":"Nl3yDN","date":"1659886763","viewed":250,"name":"Simple CSG ","username":"kastorp","description":"simplified raytracing CSG where operations are on convex volumes \n[url=https://www.shadertoy.com/view/flccWs]here[/url] a path tracing version","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","csg"],"hasliked":0,"parentid":"NdtSWj","parentname":"Raytracing CSG"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//simple CSG by Kastorp\n//  basic intersection and subtraction operation are easier on convex volumes\n// and can be used to derive other shapes\n\nvoid trace(vec3 rd,vec3 ro ,out Hit  h) { \n    \n    //ground\n    span s1 = iPlane(ro,rd,vec3(0,1.,0),.01); \n    h=  getHit(s1,0);    \n    span s2,s3;\n    Hit h1;\n\n#if 1\n    // DICE= sphere * cube\n    s2= iBox(ro-vec3(0.,1.,0.),rd,vec3(1.,1.,1.));\n    s3= iSphere(ro-vec3(0.,1.,0.),rd,1.3);\n    h1 =getHit( Inter(s3,s2),2);   \n    h=nearestHit( h,h1);\n    \n    // LAMP= cube -sphere \n    s2= iBox(ro-vec3(3.,1.,0.),rd,vec3(1.,1.,1.));\n    s3= iSphere(ro-vec3(3.,1.,0.),rd,1.3);\n    h1 =getHit( Sub(s2,s3),1);    \n    h=nearestHit( h,h1);\n    \n    // RAMP= box * plane\n    s2= iBox(ro-vec3(-3.,1.,0.),rd,vec3(1.,1.,1.));\n    s3= iPlane(ro-vec3(-3.,-2.,0.),rd,normalize(vec3(1.,1.,0.)),2.);\n    h1 =getHit( Inter(s2,s3),3);    \n    h=nearestHit( h,h1);\n\n    // HEMISPHERE = sphere * plane\n    s2= iSphere(ro-vec3(3.,1.,3.),rd,1.);\n    s3= iPlane(ro-vec3(-3.,1.,0.),rd,normalize(vec3(0.,-1.,0.)),1.1);\n    h1 =getHit( Inter(s2,s3),3);    \n    h=nearestHit( h,h1);\n\n    // CUP = sphere -sphere\n    s2= iSphere(ro-vec3(0.,1.,3.),rd,1.);\n    s3= iSphere(ro-vec3(0.,1.5,3.),rd,1.);\n    h1 =getHit( Sub(s2,s3),1);    \n    h=nearestHit( h,h1);\n    \n    // UFO = sphere * sphere\n    s2= iSphere(ro-vec3(-3.,1.,3.),rd,1.);\n    s3= iSphere(ro-vec3(-3.,0.,3.),rd,1.);\n    h1 =getHit( Inter(s2,s3),2);    \n    h=nearestHit( h,h1);\n    \n    //POT = box - box\n    s2= iBox(ro-vec3(3.,1.,-3.),rd,vec3(1.,1.,1.));\n    s3= iBox(ro-vec3(3.,1.5,-3.),rd,vec3(.8,1.,.8));\n    h1 =getHit( Sub(s2,s3),2);    \n    h=nearestHit( h,h1);\n    \n    //POT2= box - sphere\n    s2= iBox(ro-vec3(0.,1.,-3.),rd,vec3(1.,1.,1.));\n    s3= iSphere(ro-vec3(0.,2.,-3.),rd,1.);\n    h1 =getHit( Sub(s2,s3),3);    \n    h=nearestHit( h,h1);\n\n    //MAGNET=box - box\n    s2= iBox(ro-vec3(-3.,1.,-3.),rd,vec3(1.,1.,.5));\n    s3= iBox(ro-vec3(-3.,1.5,-3.),rd,vec3(.5,1.,2.));\n    h1 =getHit( Sub(s2,s3),1);   \n    h=nearestHit( h,h1);\n    \n#else\n\n    // something more complex involving rotations\n\tmat3 rot = rotationAxisAngle( vec3(1,0,0), 1.57/2. ); //45Â° \n    //rot = rotationAxisAngle( normalize(vec3(0,1,0)),iTime )*rot;\n\tmat3 txx = inverse( rot );   \n    s2= iRBox(ro-vec3(0,2.,0),rd,vec3(2.1), rot); \n    s3= iBox(ro-vec3(0.,1.,0.),rd,vec3(2.,3.,2.));\n    s2=Inter(s3,s2);\n    s3= iBox(ro-vec3(0.,2.,0.),rd,vec3(1.8));\n    s2=Sub(s2,s3);\n    h1 =getHit(s2 ,1);    \n    h=nearestHit( h,h1);\n    \n    s2=iCylinder( ro,  rd, vec3(0,1,0),1.);\n    s3= iPlane(ro-vec3(0,5.,0.),rd,normalize(vec3(0.,-1.,0.)),1.);\n    h1 =getHit(Inter(s2,s3) ,1);    \n    h=nearestHit( h,h1);\n#endif\n}\n\nvec3[4] mat = vec3[4](vec3(0.1,0.5,0.1), //terrain\n                     vec3(0.9,0.4,0.4), // pink\n                      vec3(0.2,0.3,0.6), //blue\n                      vec3(0.7,0.5,0.0)); // yellow\n\n//------------------------------------\n\nvec3 lights(vec3 p, vec3 rd, float d, vec3 n) {\n    vec3 lightDir = normalize( vec3(8.,19.,18.) );\n\tvec3 ld = normalize(lightDir*16.5 - p);\n\n\tfloat ao = 1.,\n\tl1 = max(0., .5 + .5 * (dot(ld, n))),\n\t\n\tspe = max(0., dot(rd, reflect(ld, n))) * .5,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n   \n    vec3 pp=p+.001*n; \n    Hit h;\n    trace( ld, pp,h);\n\tl1 *=    smoothstep(.001,500.,  h.d  );\n         \n\tvec3 lig = ((l1 *.9+.1)* ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    vec2 m= iMouse.x>0.? +iMouse.xy/iResolution.xy:.5* vec2(iResolution.xy/iResolution.y) +vec2(iTime*.2,-.2);\n    float t= -.6+m.x*3.14;\n\tvec3 ro =2.*vec3(3.*cos(t), 1.+6.*m.y, 3.*sin(t));\n\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd =  getRayDir(ro, vec3(0,1,0), uv);\n        \n    Hit h;\n    trace(rd, ro,h);\n      \n    vec3 p=ro+rd*h.d; \n    vec3 alb=mat[h.id];\n    vec2 uvt= fract(h.fuv.yz)-.5;\n    if(uvt.x*uvt.y<0.)alb*=.75;\n    \n    vec3 col=lights(p, rd, h.d,h.n) * exp(-h.d * .085)*alb;\n    \n\tfragColor = vec4(pow(col, vec3(.5)), h.d);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define NOHIT 1e5\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\tvec3 fuv;  //face & uv \n};\n\nconst its  NO_its=its(NOHIT,vec3(0.),vec3(0.));\nstruct span\n{\n\tits n;\n\tits f;\n};\n/*----------------------------------\nREFERENCE TABLE\n(span 1= AB, span 2 = CD)\n\n-------Union---Inter----Sub--\nABCD | AB, CD |  -   | AB\nACBD | AD     | CB   | AC\nACDB | AB     | CD   | AC, DB\nCABD | CD     | AB   | -\nCADB | CB     | AD   | DB\nCDAB | CD, AB | -    | AB\n\nif result is a double span: \nuse first span if in front of the viewer, \notherwise use second span\n------------------------------------*/\n\nspan Inter(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t),\n         cp2= bvec4(\n                 (cp.x && !cp.z && cp.w), //span(b.n,a.f)\n                 (cp.x && !cp.z && !cp.w), //b\n                 (!cp.x && cp.y &&  cp.w), //a\n                 (!cp.x && cp.y &&  !cp.w) //span(a.n,b.f)\n              ); \n   \n   if(cp2.x)      return span(b.n,a.f);\n   else if(cp2.y) return b;\n   else if(cp2.z) return a;\n   else if(cp2.w) return span(a.n,b.f);\n   else           return span(NO_its,NO_its);\n}\n\nspan Sub(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t),\n        cp2 = bvec4(cp.x && cp.z, //a\n                (cp.x && !cp.z && cp.w) || (cp.x && !cp.z && !cp.w && b.n.t>0.), //span(a.n,b.n)\n                (cp.x && !cp.z && !cp.w && b.n.t<0.)|| (!cp.x && cp.y && !cp.w), //  span(b.f,a.f)\n                (!cp.x && cp.y && cp.w) //span(NO_its,NO_its)\n                ); \n   \n   if(cp2.y)      return span(a.n,b.n);\n   else if(cp2.z) return  span(b.f,a.f);\n   else if(cp2.w) return span(NO_its,NO_its);\n   else           return a;\n   \n}\n\n// useful if transparent \nspan Union(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   \n   if     (cp.x  && cp.z  && a.f.t>0.) return a;\n   else if(cp.x  && cp.z  && a.f.t<0.) return b;\n   else if(cp.x  && !cp.z && cp.w) return span(a.n,b.f);\n   else if(cp.x  && !cp.z && !cp.w) return a;\n   else if(!cp.x && cp.y  && cp.w) return b;\n   else if(!cp.x && cp.y  && !cp.w) return span(b.n,a.f);\n   else if(!cp.x && !cp.y  && a.f.t>0.) return b;\n   else /*if(!cp.x && !cp.y  && a.f.t<0.) */ return a;   \n}\n\n\n//-----------Intersection functions--(based on Iq)------------------\nspan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return span(NO_its,NO_its); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 oFuv=vec3(0.,atan(oNor.y,length(oNor.xz)),atan(oNor.z,oNor.x))*ra*1.5708  ;\n    vec3 fNor= normalize(ro-(b-h)*rd); \n    vec3 fFuv=vec3(0.,atan(fNor.y,length(fNor.xz)),atan(fNor.z,fNor.x))*ra*1.5708  ;\n    return span(its(-b-h,oNor,oFuv) , its(-b+h,-fNor,fFuv));\n}\n\nspan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF ) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    vec3 oFuv=vec3( dot(abs(oNor),vec3(1,5,9)+ oNor)/2.,dot(ro+rd*tN,oNor.zxy),dot(ro+rd*tN,oNor.yzx));      \n    vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    vec3 fFuv=vec3( dot(abs(fNor),vec3(1,5,9)+ fNor)/2.,dot(ro+rd*tF,fNor.zxy),dot(ro+rd*tF,fNor.yzx));\n    return  span(its(tN,oNor,oFuv) , its(tF,fNor,fFuv));\n}\n\nspan iRBox( in vec3 ro, in vec3 rd, vec3 boxSize,mat3 rot  ) {\n\tmat3 txx = inverse( rot );   \n    span s= iBox(txx*ro,txx*rd,boxSize);\n    s.n.n=(rot*s.n.n).xyz;\n    s.f.n=(rot*s.f.n).xyz;    \n    return s;\n}\n\n\n//  plane with thickness h\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d1= -dot(ro,n)/dot(rd,n),   d2= -(dot(ro-h*n,n))/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3  oFuv1=vec3(1.,dot(ro+d1*rd,u), dot(ro+d1*rd,v)),\n          oFuv2=vec3(2.,dot(ro+d2*rd,u), dot(ro+d2*rd,v));\n    vec3 oNor=n;\n    if(d1<d2) return span(its(d1,-oNor,oFuv1),its(d2,oNor,oFuv2));\n    return span(its(d2,oNor,oFuv2),its(d1,-oNor,oFuv1));\n}\n\n\nspan iCylinder( in vec3 ro, in vec3 rd, in vec3 n, float cr )\n{\n    \n    float card = dot(n,rd);\n    float caoc = dot(n,ro);\n    float a = 1.0 - card*card;\n    float b = dot( ro, rd) - caoc*card;\n    float c = dot( ro, ro) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return span(NO_its,NO_its); //no intersection\n    h = sqrt(h);\n    vec2 t =vec2(-b-h,-b+h)/a;\n    vec2 d= vec2(dot(ro +t.x*rd,n) ,dot(ro +t.y*rd,n) );\n    vec3 nN=normalize( ro +t.x*rd -d.x*n),\n         nF=normalize( ro +t.y*rd -d.y*n);\n    its iN= its( t.x, nN,vec3(0.,d.x,0.) ); //todo uv\n    its iF= its( t.y, nF,vec3(0.,d.y,0.) );\n    return  span(iN , iF );   \n}\n//---------mixed functions--------------------------\n\nstruct Hit{   \n    float d;\n    vec3 n;\n    vec3 fuv;\n    int id;\n};\n\n\nHit nearestHit( Hit a, Hit b)\n{   \n   if(a.d<b.d) return a;\n   else return b;\n}\n\n\n\n//------------------------------------\nHit getHit(span s, int mat){\n    \n    if(s.f.t < 0.  ) return Hit(NOHIT,vec3(0),vec3(0),0);\n    if(s.f.t >0.  &&  s.n.t<0.) return Hit(0.,vec3(0),vec3(0),0);\n    its ix = s.n;\n    return Hit( ix.t,ix.n,ix.fuv,mat);\n}\n\n// Iq \n\n\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c);\n}\n\n","name":"Common","description":"","type":"common"}]}