{"ver":"0.1","info":{"id":"WtKBzD","date":"1614179901","viewed":609,"name":"Pluto is made of","username":"miczac","description":"I applied a fluid simulation by Wyatt to a sphere then added some transparency and neon lights. I made this for an audiovisual piece https://youtu.be/q2JinWB7kUQ. See Common tab for explanations","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["transparency","fluid","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void Update(vec3 ro, vec3 rd)\n{\n    for(int obj = 0; obj < NUMBER_OF_OBJECTS; obj++)\n    {\n        vec2 flat_pos = texelFetch(iChannel0, ivec2(obj, 1), 0).zw;\n        float env = texelFetch(iChannel0, ivec2(obj, 0), 0).x;\n        vec3 sph_pos = to_polar(flat_pos);\n        env = pow(trapezoid(env, TRAPEZOID), 10.5);\n        float bounce = env*0.1;\n        sph_pos.xz = sph_pos.xz*bounce+sph_pos.xz;\n        //Positions: satellite distances, satellite positions\n        Positions[obj] = vec4(sphDistances(ro,rd,vec4(sph_pos,SAT_RADIUS)).x, sph_pos);\n        Notes[obj] = texelFetch(iChannel0,ivec2(obj,0),0);\n    }\n}\n\nfloat map(vec3 p)\n{\n    float res = 10000.;\n    //Pluto sphere\n    vec2 sph_uv = polar(p);\n    float thickness =0.01*smoothstep(0.1,0.5, Notes[4].x);\n    float wipe_thick = WIPE_THICKNESS * smoothstep(0.9,0.8, abs(p.y));\n    float wipe_bump = (1.-sphereWipeClean(Notes[4].x, p.y, wipe_thick))*WIPE_BUMP;\n    float water_bump =  texture(iChannel1,sph_uv).z*BUMP_STRENGTH;\n    vec3  noise_text = texture(iChannel3,sph_uv).xyz;\n    float noise_bump = length(noise_text.x)*0.01;\n    float rad = PLUTO_RADIUS+water_bump+noise_bump+wipe_bump;\n    float earth = length(p)-rad;\n    res = min(res, earth);\n    return res*0.7;\n}\n\n\nvec3 normal(in vec3 p, float d) {\n\tconst vec2 e = vec2(0.01, 0);\n\treturn normalize(vec3(d - map(p - e.xyy), d - map(p - e.yxy),\td - map(p - e.yyx)));\n}\n\n\nvec3 satellite_light(vec3 ro, vec3 rd, float falloff, float volume)\n{\n    vec3 res = vec3(0);\n    for(int obj = 0; obj < SATELLITES; obj++)\n    {\n        vec4 note = Notes[obj];\n        vec3 color = CALC_COLOR;\n        float light_distance = pow(abs(Positions[obj].x),1.5);\n        float neon = falloff/pow(light_distance,.42);\n        float trapez = 1.-trapezoid(note.x, TRAPEZOID);\n        float turn_on = pow(trapez+0.01,0.5);\n        neon =pow(neon*turn_on,5.4545)*(1.-note.x);\n        res += neon*color;\n    }\n    return pow(res, vec3(0.64545));\n}\n\nmat3 camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 lookat = vec3(0,0,0);\n    vec3 ro = vec3(-cos(iTime*0.48)*2.,cos(iTime*0.01),-sin(iTime*0.48)*2.);\n    //vec3 ro = vec3(0,0,-2.1);// \n\n    mat3 cam = camera(ro, lookat, CAMERA_TILT);\n    vec3 rd = cam * normalize(vec3(uv, 1));\n    Update(ro,rd);\n    float ray_dist = length(rd), layers = 0., hit_dist, accum_dist;\n    //light variables\n    float light_dist, surf_light;\n    float thresh_dist = 0.00525;    \n    vec3 satellite = satellite_light(ro,rd, 0.024, 1.);\n    for(float i=0.; i<TRANSPARENCY_PASSES; i++)\t\n    {\n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>81. || dot(col, vec3(.299, .587, .114)) > 1. || ray_dist> 16.) break;\n        //background, ideally not in the loop but it looks better this way\n        col += vec3(0.1, 0.2, 0.3)*0.0008 +pow(abs(rd.y),5.)*0.01;\n        vec3 p = ro + rd*ray_dist;\n        vec2 sph_uv = polar(p); \n        vec3 noise_text =  texture(iChannel3,mod(sph_uv+fract(iTime*0.01),1.)).xyz;\n        float wipe = Notes[4].x;\n        float wipe_neon = .51/length(p)*wipe;\n        float wiper = 1.-sphereWipeClean(wipe,p.y, WIPE_THICKNESS );\n        col += wiper*wipe_neon*vec3(0.1,0.01,0.5)*1.15;\n        float hit_dist = map(p);\n        accum_dist = (thresh_dist-abs(hit_dist)*31./32.)/thresh_dist;\n        if(accum_dist > 0.)\n        {\n            vec3 norm = normal(p,hit_dist)*sign(hit_dist);\n            vec3 light_pos = vec3(1,-1,1);\n            vec3 ld = p - light_pos;\n            light_dist = max(length(ld), 0.001);\n            ld /= light_dist;\n            surf_light = pow(max(dot(reflect(-ld, norm), -rd), 0.), 8.);\n\n            float bump =  texture(iChannel1,sph_uv).w*BUMP_STRENGTH;\n            vec3 color = texture(iChannel0,sph_uv).xyz;\n            //this next line is straight up from Shane's\n            vec3 surface = (vec3(0.2196, 0.4667, 0.8392)*surf_light)*accum_dist/(1. + light_dist*0.25 + light_dist*light_dist*0.05);\n            col += max(surface*0.051, min(vec3(1),color*5.*dot(norm,light_pos)));  \n            col += noise_text*0.005;\n        }\n        //add satellite light\n        col += satellite; \n        ray_dist += max(abs(hit_dist)*.55, thresh_dist*.25);\n        layers++;\n    }\n\n    col = encodeSRGB(col);\n    fragColor += vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nNOTE GENERATOR BUFFER: in this buffer I am generating random envelopes and pitch.\nPitch is the y texel position, envelopes are used to displace satellites from the sphere\nand to light them up\n\n*/\nvec2 R;\n\nvec4 TT ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, R.x-1.);\n    if(U.x < 0.) U.x == R.x-1.;\n    return texture(iChannel0,U/R);\n} // samples fluid\n\nvoid Update()\n{\n    for(int obj = 0; obj < NUMBER_OF_OBJECTS; obj++)\n    {\n        Notes[obj] = texelFetch(iChannel0,ivec2(obj,0),0);\n        Lines[obj] = texelFetch(iChannel0,ivec2(obj,1),0);\n    }\n}\n\nvec3 injectColor(vec2 uv, vec4 fluid)\n{\n    vec3 color = vec3(0);\n    for(int obj = 0; obj < SATELLITES; obj++)\n    {\n        vec4 note = Notes[obj];\n        bool note_on = 1.-trapezoid(note.x, TRAPEZOID) < .99;\n        if(!note_on) continue;\n        //amount of color injected depends on fluid pressure (fluid.x) and ink (fluid.w)\n        float thickness = .5*(0.5*fluid.y+.5*fluid.w+.5*fluid.z);\n        float dist = ln(uv, Lines[obj].xy*R, Lines[obj].zw*R)-thickness;\n        color += vec3(1.-clamp(dist,0.,1.))*CALC_COLOR;//CALC_COLOR*(1.-clamp(dist,0.,1.));\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iCoo = ivec2(fragCoord);\n    if(iCoo.y == 0 && iCoo.x < NUMBER_OF_OBJECTS)\n    {\n        float new_ramp     = envelope(iCoo.x, iTime);\n        vec4  prev_data    = iFrame < 1 ? vec4(0,0.5, 0.6, 1.) : texelFetch(iChannel0,iCoo,0);\n        float prev_env     = prev_data.x, \n              next_pitch   = prev_data.y,\n              curr_pitch   = prev_data.z,\n              prev_ramp    = prev_data.w;\n        bool trigger = new_ramp > prev_ramp;\n        float env = prev_env;\n        if(trigger)\n        {\n        //start a new envelope ramp, get a new pitch (y pos)\n            env = 1.;\n            curr_pitch = next_pitch;\n            next_pitch = abs(sin(iTime*Envelope_freq[iCoo.x])*0.085+0.5);\n        } \n        else {env = slide(env, 0., 1.,1./Envelope_dur[iCoo.x]);}\n\n        fragColor = vec4(env, next_pitch, curr_pitch, new_ramp);\n     }\n     else if (iCoo.y == 1 && iCoo.x < SATELLITES)\n     //save object path (on plane) on second row of pixels\n     {\n     //create 2 sets of texel coordinates, one slightly ahead of the other \n     //to draw line on fluid texture\n         vec4  data     = texelFetch(iChannel0, iCoo-ivec2(0,1), 0);\n         float env = data.x;\n          //avoid going past the texture edge by shrinking the range depending on the line length\n         float pos_x_behind = path_flat(iCoo.x,iTime)*(1.-LINE_LENGTH);\n         \n         float pos_x_ahead  = path_flat(iCoo.x,iTime);\n\n         float current_pitch = data.z;\n         float target_pitch  = data.y;\n         //object gradually moves to the next y position\n         float pitch_interpol = env > 0.5 ? 0. : 1.- trapezoid(env, TRAPEZOID);\n         float pos_y_behind  = mix(current_pitch,target_pitch, pitch_interpol);\n         float pos_y_ahead   =  mix(current_pitch,target_pitch, pitch_interpol - 0.01);\n         vec2  point_behind = vec2(pos_x_behind, pos_y_behind), point_ahead = vec2(pos_x_ahead, pos_y_ahead);\n         \n         fragColor = vec4(point_behind, point_ahead);\n     }\n     // add 1 to number of objects to avoid having the color texture read from the data pixels\n    else if(iCoo.x > NUMBER_OF_OBJECTS+1 || iCoo.y > 3)    \n    {\n        Update();\n        R = iResolution.xy;\n        vec2 U = fragCoord;\n        vec4 fluid = texture(iChannel2,U/R);\n        vec3 injected_color = injectColor(U,fluid );\n        vec3 \n            a = TT(U+vec2(1,0)).xyz,\n            b = TT(U-vec2(1,0)).xyz,\n            c = TT(U+vec2(0,1)).xyz,\n            d = TT(U-vec2(0,1)).xyz,\n            v = max(TT(U).xyz, injected_color);\n        //gamma correction learned here: https://www.shadertoy.com/view/lscSzl\n        a = pow(a,vec3(2)), b = pow(b,vec3(2)), c = pow(c,vec3(2)), d = pow(d,vec3(2)), v = pow(v,vec3(2));\n        vec3 blended_colors = mix(mix(mix(mix(a,b,0.5),c,0.5),d,0.5),v,0.5)*COLOR_FDBK;\n        blended_colors *= max(vec3(0),sin(1.5+5.*fluid.z+3.*(fluid.w)*fluid.w*injected_color));\n        fragColor = vec4(pow(blended_colors,vec3(0.5)),0.);\n        //blue horizontal light is triggerd by pixel (4, 0), this also wipes (as in erases) the color and fluid texture\n        float wipe = 1.-texelFetch(iChannel0, ivec2(4, 0),0).x;\n        fragColor = fragColor*vec4(wipeClean(wipe,fragCoord.y/iResolution.y, WIPE_THICKNESS, true));\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//from https://www.shadertoy.com/view/XtGcDK\nvec4 T ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, iResolution.x-1.);\n    if(U.x < 0.) U.x == iResolution.x-1.;\n    vec2 R = iResolution.xy;\n    return texture(iChannel0,U/R);\n} // samples fluid\n\nvec2 R;\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   \n\n    R = iResolution.xy;\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \tvec4 p;\n \tvec2 g = vec2(0);\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        g += vec2(a.z-c.z,b.z-d.z);\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \tQ = u; \n \tvec4 N = 0.25*(a+b+c+d);\n \tQ = mix(Q,N, vec4(0,0,1,0)); \n \tQ.xy -= g/10./float(I); \n \tQ.z += (p.x+p.y+p.z+p.w)/10.; \n \t\n \tQ.z *= 0.9999;\n    for(int i = 0; i <  SATELLITES; i++)\n    {\n        //pixel coordinates of line to be drawn\n        vec4 line = texelFetch(iChannel1,ivec2(i,1),0)*R.xyxy;\n        float env = texelFetch(iChannel1,ivec2(i,0),0).x;\n        float trapez = 1.-trapezoid(env,TRAPEZOID);\n        float q = ln(U,line.xy,line.zw);\n        vec2 m = line.xy-line.zw;\n        float l = length(m);\n        if (trapez< .99 && l>0.) \n        {\n            // accelerate fluid and add ink\n            Q.xyw = mix(Q.xyw,vec3(-normalize(m)*min(l,20.)/25.,1.),max(0.,9.*trapez-q)/25.); \n        }\n     }\n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n    //wipe is on iChannel1 (buff A)\n    float wipe = 1.-texelFetch(iChannel1, ivec2(4, 0),0).x;\n    float thickness = 0.2;\n    Q = Q*wipeClean(wipe,U.y/R.y, WIPE_THICKNESS, true);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nThis is a combination of a couple of ideas I used to make an audiovisual piece \nDo check it out here https://youtu.be/q2JinWB7kUQ. \nThere is a fluid simulation from Wyatt (https://www.shadertoy.com/view/XtGcDK) \nand transparency from Shane (https://www.shadertoy.com/view/Xd3SDs). \nI added sphere mapping, a way of coloring the fluid (on Buff A), neon lights, animation,\nand a way to wipe clean the texture at certain times.\n\nThere are 5 time-based events and 1 static liquid spherical canvas (Pluto).\n4 of the five events are rotating lights , the fifth is horizontal blue light that wipes \nout the color and fluid motion from the sphere (it is associated to a kick drum sound in the final render, see below).\nBuff A creates envelopes on the first 5 pixels of row 0, then uses those envelopes to draw a 2d path\nfor the satellites on row 1. The remainder of the buff is dedicated to coloring the fluid texture.\n\nBuff B adaped from Wyatt's shader:. Added a loop for multiple fluid triggers\nadded a wiping feature to\"clean up\" the fluid at certain times\n\nBuff C-D are extra feedback for fluid texture copied from Wyatt's shader\n*/ \n\n#define PI 3.14159265358\n//length of segment drawn on sphere\n#define LINE_LENGTH 0.021\n#define BUMP_STRENGTH .2\n#define NUMBER_OF_OBJECTS 5\nconst float fNUMBER_OF_OBJECTS = float(NUMBER_OF_OBJECTS);\n#define TRAPEZOID vec2(0.4, 0.6)\n#define MIN_DIST 0.001\n#define MAX_DIST 10.\n#define PLUTO_RADIUS 1.\n#define SAT_RADIUS 0.0019\n#define CALC_COLOR hash31(floor(note.z*20.)*0.01)\n#define COLOR_FDBK .89\n#define CAMERA_TILT 0.\n#define WIPE_BUMP 0.05\n#define WIPE_THICKNESS 0.05\n//reduce this value to get better FPS\n#define TRANSPARENCY_PASSES 150.\n\n\nvec4  Positions[NUMBER_OF_OBJECTS];\nvec4  Notes[NUMBER_OF_OBJECTS];      \nvec4  Lines[NUMBER_OF_OBJECTS];        \nfloat Envelope_freq[NUMBER_OF_OBJECTS] = float[NUMBER_OF_OBJECTS](0.45,0.75,0.5142,0.85,0.055);\nfloat Envelope_dur[NUMBER_OF_OBJECTS] = float[NUMBER_OF_OBJECTS](20.,10.,10.,10.,80.);\nfloat Revolution_freq[NUMBER_OF_OBJECTS] = float[NUMBER_OF_OBJECTS](0.147878,0.24546,0.2,0.117, 0.);\n//last object is horizontal blue light\nconst int SATELLITES = NUMBER_OF_OBJECTS - 1;\n\n\n \nfloat envelope(int obj, float time)\n{\n   float  freq = Envelope_freq[obj];\n   \n   return 1.-fract(freq*time);   \n}\n\nfloat path_flat(int obj, float time)\n{\n   float  freq = Revolution_freq[obj];\n   \n   return fract(freq*time);   \n}\n\n\nfloat trapezoid(float x, vec2 begin_end)\n{\n//given a 0-1 ramp draw a trapezoid \n    //since the incoming envelope is a ramp from 1 to 0, invert it (it makes more sense)\n    x = 1.-x;\n    float trapez = min(smoothstep(0., begin_end.x, x),smoothstep( 1.,begin_end.y, x)); \n    return trapez;\n\n}\n\nvec3 hash31( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\nfloat slide(float cur, float tar, float slu, float sld)\n{\n    //slide up or slide down\n    float del = (tar>cur) ?  slu : sld;\n \tcur += (tar - cur) * del;\n    return    cur;\n}\n\n//coordinate conversion: https://www.shadertoy.com/view/4lGcWc\n\nvec2 polar(vec3 U)\n{\n   return fract(vec2(\n        atan(U.z, U.x) / 2.,\n        atan(U.y, length(U.xz))\n    ) / PI + .5);\n}\n\nvec3 to_polar(vec2 uv)\n{\n\n    uv = vec2(2, 1) * (uv - .5) * PI;\n    return vec3(cos(uv.x), 0, sin(uv.x)) * cos(uv.y) + vec3(0, sin(uv.y), 0);\n}\n\nfloat ln (vec2 p, vec2 a, vec2 b) \n{ // returns distance to line segment \n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\n//https://iquilezles.org/articles/spherefunctions\nvec2 sphDistances( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\n//https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nfloat wipeClean(float wipe, float y, float thickness, bool bipolar)\n{\n    if(bipolar) y -= 0.5, wipe *= .3;\n    return smoothstep(0., thickness, length(wipe-abs(y)));\n}\n\nfloat sphereWipeClean(float wipe, float y, float thickness)\n{\n    //float no_poles = clamp(abs(y),0.,0.8); \n    //float no_poles = smoothstep(.9, 0.8,abs(y)); \n    return wipeClean(1.-wipe,y,thickness, false);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 T ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, iResolution.x-1.);\n    if(U.x < 0.) U.x == iResolution.x-1.;\n    vec2 R = iResolution.xy;\n    return texture(iChannel0,U/R);\n} // samples fluid\n\nvec2 R;\n\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{  \n    R = iResolution.xy;\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \tvec4 p;\n \tvec2 g = vec2(0);\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        g += vec2(a.z-c.z,b.z-d.z);\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \tQ = u; \n \tvec4 N = 0.25*(a+b+c+d);\n \tQ = mix(Q,N, vec4(0,0,1,0)); \n \tQ.xy -= g/10./float(I); \n \tQ.z += (p.x+p.y+p.z+p.w)/10.;\n  \tQ.z *= 0.9999;\n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 T ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, iResolution.x-1.);\n    if(U.x < 0.) U.x == iResolution.x-1.;\n    vec2 R = iResolution.xy;\n    return texture(iChannel0,U/R);\n} // samples fluid\nvec2 R;\n\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \tvec4 p;\n \tvec2 g = vec2(0);\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        g += vec2(a.z-c.z,b.z-d.z);\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \tQ = u; \n \tvec4 N = 0.25*(a+b+c+d);\n \tQ = mix(Q,N, vec4(0,0,1,0)); \n \tQ.xy -= g/10./float(I); \n \tQ.z += (p.x+p.y+p.z+p.w)/10.;\n  \tQ.z *= 0.9999;\n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n}","name":"Buffer D","description":"","type":"buffer"}]}