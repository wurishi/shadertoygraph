{"ver":"0.1","info":{"id":"3dVSRD","date":"1573537175","viewed":253,"name":"Trippy Happy Jumper","username":"jeanlescure","description":"More buffer experiments, remix of these shaders:\n\nhttps://www.shadertoy.com/view/3dVSzW\nhttps://www.shadertoy.com/view/Md2GRc\nhttps://www.shadertoy.com/view/3lsSzf","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","fractal","sdf","animation","trippy","happy","raymarc","remixhing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Display the mix of buffers\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    \n    if ((tot * vec3(255.0)).r > 0.0 || (tot * vec3(255.0)).g > 0.0 || (tot * vec3(255.0)).b > 0.0) {\n    \tfragColor = vec4(tot, 1.0);\n    } else {\n    \tfragColor = texture(iChannel1, fragCoord.xy / iResolution.xy) + texture(iChannel2, fragCoord.xy / iResolution.xy);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on: https://www.shadertoy.com/view/3lsSzf\n\n#define AA 1\n\n//------------------------------------------------------------------\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// https://iquilezles.org/articles/smin\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );\n\n    if( res.x-1.0 < pos.y ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n    \n\n    return res;\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.01);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.09,0.144,0.0036),vec3(0.1,0.36,0.04),res.z*res.z);\n            col = mix(col,vec3(0.09,0.14,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output\n    fragColor = vec4(tot*(tot*vec3(1.1)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Based on: https://www.shadertoy.com/view/Md2GRc\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 formula(in vec2 p, in vec2 c)\n{\n\tconst float n = 2.0;\n\tconst int iters = 12;\n\n\tfloat time = iTime*0.1;\n\tvec3 col = vec3(0);\n\tfloat t = 1.0;\n\tfloat dpp = dot(p, p);\n\tfloat lp = sqrt(dpp);\n\tfloat r = smoothstep(0.0, 0.2, lp);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t// The transformation\n\t\tp = abs(mod(p/dpp + c, n) - n/2.0);\n\t\t\n\t\tdpp = dot(p, p);\n\t\tlp = sqrt(dpp);\n\n\t\t//Shade the lines of symmetry black\n#if 0\n\t\t// Get constant width lines with fwidth()\n\t\tfloat nd = fwidth(dpp);\n\t\tfloat md = fwidth(lp);\n\t\tt *= smoothstep(0.0, 0.5, abs((n/2.0-p.x)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs((n/2.0-p.y)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs(p.x/md))\n\t\t   * smoothstep(0.0, 0.5, abs(p.y/md));\n#else\n\t\t// Variable width lines\n\t\tt *= smoothstep(0.0, 0.01, abs(n/2.0-p.x)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(n/2.0-p.y)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(p.x)*2.0) \n\t\t   * smoothstep(0.0, 0.01, abs(p.y)*2.0);\n#endif\n\n\t\t// Fade out the high density areas, they just look like noise\n\t\tr *= smoothstep(0.0, 0.2, lp);\n\t\t\n\t\t// Add to colour using hsv\n\t\tcol += hsv(1.0 - max(p.x, p.y) + t*2.0 + time, 2.0-lp+t, r);\n\t\t\n\t}\n\t\n\treturn (-cos(col/4.0)*0.5 + 0.5)*(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\tp *= 2.0;\n\tconst vec2 e = vec2(0.06545465634, -0.05346356485);\n\tvec2 c = iTime*e;\n\t//c = 8.0*iMouse.xy/iResolution.xy;\n\tfloat d = 1.0;\n\tvec3 col = vec3(0.0);\n\tconst float blursamples = 4.0;\n\tfloat sbs = sqrt(blursamples);\n\tfloat mbluramount = 1.0/iResolution.x/length(e)/blursamples*2.0;\n\tfloat aabluramount = 1.0/iResolution.x/sbs*4.0;\n\tfor (float b = 0.0; b < blursamples; b++) {\n\t\tcol += formula(\n\t\t\tp + vec2(mod(b, sbs)*aabluramount, b/sbs*aabluramount), \n\t\t\tc + e*mbluramount*b);\n\t}\n\tcol /= blursamples;\n    \n\tfragColor = vec4(col * vec3(0.5), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Based on: https://www.shadertoy.com/view/3dVSzW\n\n#define RADIUS  0.01\n#define SAMPLES 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pfragColor = vec3(0.0);\n\t\t\n\tfor (int i = -SAMPLES; i < SAMPLES; i++) {\n\t\tfor (int j = -SAMPLES; j < SAMPLES; j++) {\n\t\t\tpfragColor += texture(iChannel1, fragCoord.xy / iResolution.xy + vec2(i, j) * (RADIUS/float(SAMPLES))).rgb\n\t\t\t\t / pow(float(SAMPLES) * 2., 2.);\n\t\t}\n    }\n    \n    vec3 tot = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    \n    if ((tot * vec3(255.0)).r > 0.0 || (tot * vec3(255.0)).g > 0.0 || (tot * vec3(255.0)).b > 0.0) {\n    \tfragColor = vec4(tot, 1.0);\n    } else {\n    \tfragColor = (vec4(pfragColor * vec3(sin(iTime), cos(iTime), 1.0), 1.0) * vec4(vec3(0.8), 1.0));\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}