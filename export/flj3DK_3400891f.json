{"ver":"0.1","info":{"id":"flj3DK","date":"1624746805","viewed":125,"name":"DZ Livecode release event jam","username":"Exca","description":"Shader done at demozoo livecode website release partys shader jam.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","cube","colors","demozoo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tfragColor = texture(iChannel0, uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat beat;\nfloat beatStep;\nfloat fft;\nfloat fftS;\nfloat fftI;\nfloat glow;\n\nfloat diffuse(vec3 p, vec3 l, vec3 n)\n{\n  return max( dot(n, normalize(l-p)),0.0);\n}\n\nvec2 barrelDistortion(vec2 uv, float k)\n{\n  float rd = length(uv);    \n  float ru = rd * (1.0 + k * rd * rd);\n  uv /= rd;\n  uv *= ru;\n  return uv;\n}\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0, 0, 0, cos(x),-sin(x),0, sin(x),cos(x));\n  mat3 roty = mat3( cos(y), 0, sin(y), 0,1,0, -sin(y), 0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0, sin(z),cos(z), 0,0,0,1);\n  return rotx*roty*rotz*p;\n}\n\n\nvec3 repeat( vec3 p, vec3 c )\n{\n  vec3 q = mod( p + 0.5*c, c)-0.5*c;\n  return q;\n}\n\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward,right));\n  \n  return normalize( vec3( uv.x*right + uv.y* up + forward*fov ));\n}\n\nfloat cube( vec3 p, vec3 size)\n{\n  vec3 q = abs(p)-size;\n  return length( max(q,0.0)+min(max(q.x,max(q.y,q.z)),0.0));\n}\n\nfloat roundcube( vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p)-b;\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0))-r;\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p) -r;\n}\n\nvec3 map( vec3 p, out vec3 id)\n{\n  if(mod(beat,16.0) < 4.0)\n  {\n    p = rotate( p, 0.0, 0.0, p.z*-0.5);\n  }\n  else if(mod(beat,16.0) < 8.0)\n  {\n    p = rotate( p, 0.0, p.z*0.1, 0.0);   \n  }\n  else if(mod(beat,16.0) < 12.0)\n  {\n    p = rotate( p,  p.z*0.1, 0.0,sin(fftI)*p.z*0.1);   \n  }\n  else \n  {\n    p = rotate( p, 0.0, 0.0, p.z*0.1);   \n  }\n    \n  \n  \n  p+=vec3(-iTime,0,0);\n  id = floor(p *1.0 -0.5);\n  float idf = sin(id.x+id.y+id.z);\n  \n  float s1 = sphere(p, 0.5);\n  \n  vec3 cp = repeat(p, vec3(2.0, 2., 2.0));\n  cp = rotate(cp, id.x, id.y, id.z);\n  float c1 = roundcube(cp, vec3(\n    0.2+idf*0.1, \n    sin(fftI*10.0+idf)*0.1+ 0.2+idf*0.1,\n    0.2)\n    ,abs(sin(p.x+fftI)*fftS*8.0+cos(p.y-fftI)*fftS*8.0));\n  \n  return vec3(c1,0,0);\n}\n\nvec3 march( vec3 cam, vec3 rd, out float t, out vec3 p, out vec3 id)\n{\n  t = 0.0;\n  for(int i = 0; i < 200; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p, id);\n    /*float bx = cube(\n      repeat( p + vec3(1.0), vec3(2.0,0,0)),\n      vec3(0.00001,100,100));\n    float bz = cube(\n      repeat( p + vec3(1.0), vec3(0.0,0,2)),\n      vec3(100,100,0.00001));\n    float by = cube(\n      repeat( p + vec3(1.0), vec3(0.0,2,0)),\n      vec3(100,0.0001,100));\n    \n    float delta = min(max(0.1, bx), r.x);\n    delta = min( max(0.1, bz), delta);\n    delta = min( max(0.1, by), delta);\n    */\n    float delta = r.x;\n    t+=delta*0.5;\n    \n    if(r.x < 0.001)\n    {\n      return r;\n    }\n  }\n  return vec3(-1);\n}\n\nvec3 marchV( vec3 cam, vec3 rd, out float t)\n{\n  vec3 sum = vec3(0.);\n  t = 0.0;\n  vec3 id=vec3(0.);\n  for(int i = 0; i < 100; i++)\n  {\n    vec3 p = cam + rd*t;\n    vec3 r = map(p, id);\n    float d = max(0.1, r.x);\n    t+=d;\n    if(r.x < 0.01){\n      glow += abs(r.x);\n    }\n    if(r.x < 0.001)\n    {\n      sum.y+= 0.1*d;\n    }\n  }\n  return sum;\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 id = vec3(0.);\n  vec3 c = map(p,id);\n  vec2 e = vec2(0.001, 0.0);\n  return normalize( \n    vec3( \n      map(p+e.xyy,id).x,\n      map(p+e.yxy,id).x,\n      map(p+e.yyx,id).x\n    )-c.x\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  beat = floor(iTime*2.9166);\n  beatStep = fract( iTime*2.9166);\n  fft = texture(iChannel0, vec2(0.2,0.5)).r*0.0;\n  fftS = texture(iChannel0, vec2(0.2,0.5)).r*0.005;\n  fftI = texture(iChannel0, vec2(0.2,0.5)).r*0.0+iTime*0.4;\n  \n\n  //uv = barrelDistortion( uv, fftS*50.0);\n    \n  float time = iTime;\n  \n  vec3 cam = vec3(0,sin(floor(beat/8.0)),1);\n  vec3 target = vec3(0,0,10);\n  vec3 light1 = vec3(sin(time), 10, cos(time));\n  float fov = 2.2;\n  \n  vec3 c = vec3(0.0);\n  float travel = 0.0;\n  vec3 p = vec3(0.0);\n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  vec3 id = vec3(0.);\n  \n  vec3 obj = march( cam, rd, travel, p, id);\n  if(obj.y > -0.5)\n  {\n    vec3 n = normal(p);\n    \n    c = vec3(1.0)*diffuse(p, light1, n) * vec3( sin(id.x), cos(id.y), sin(-id.z));\n  }\n  \n  float vTravel = 0.0;\n  vec3 vol = marchV( cam, rd, vTravel);\n  \n  c = mix(c, vec3(0.0),  smoothstep( 15., 35., travel));\n  \n  c+=vol;//*fftS*300.0;\n  c*=0.7+glow;//*fftS*350.;\n  \n  vec3 prev = texture(iChannel1, (uv*0.9)*0.5+0.5 ).rgb;\n  \n  c = mix(c*c, c, fftS*55.0);\n  \n\tfragColor = vec4(c+prev*0.5,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}