{"ver":"0.1","info":{"id":"Xld3zM","date":"1468429082","viewed":263,"name":"Stereo Boxes","username":"zproxy","description":"// based upon\n// https://www.shadertoy.com/view/XsdXW2\n//  by Marqin","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["anaglyph","stereo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based upon\n// https://www.shadertoy.com/view/XsdXW2\n//  by Marqin\n\n\nconst int MaximumRaySteps = 128;\nconst float MinimumDistance = 0.00001;\n\n\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdBox( vec3 boxpos, vec3 p, vec3 b ) {\n    p -= boxpos;\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat boxLine( vec3 point, float z ) {\n    \n    float bsize = 0.9;\n    \n    vec3 box = vec3(0., bsize, z);\n    \n    float dist = sdBox(box, point, vec3(bsize));\n    \n    for( float i = 1.; i < 3.; i++ ) {\n        vec3 npos = vec3(box.x + i*2.*(bsize+0.35), box.y, box.z);\n        float newBox = sdBox(npos, point, vec3(bsize));\n        dist = min(dist, newBox);\n    }\n    \n    return dist;\n}\n\nfloat DistanceEstimator( vec3 point ) {\n    \n    float dist = min(boxLine(point, 0.), boxLine(point, 2.5));\n\n    return min(dist, sdPlane(point));\n}\n\n\nmat3 lookAt( vec3 origin, vec3 direction, float roll ) {\n    vec3 ww = normalize(direction);\n\tvec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll),0.0)));\n\tvec3 vv = normalize(cross(uu, ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getNormal( in vec3 pos ) {\n// from iq\n\tvec3 eps = vec3( MinimumDistance, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    DistanceEstimator(pos+eps.xyy) - DistanceEstimator(pos-eps.xyy),\n\t    DistanceEstimator(pos+eps.yxy) - DistanceEstimator(pos-eps.yxy),\n\t    DistanceEstimator(pos+eps.yyx) - DistanceEstimator(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nconst float k = 32.;\n\nfloat shadow( Ray r ) {\n    float dist = 2.*MinimumDistance;\n    float sh = 1.0;\n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n        vec3 newLocation = r.origin + dist * r.direction;\n\t\tfloat h = DistanceEstimator(newLocation);\n        if( h < MinimumDistance || dist > 10.)\n            return sh;\n        sh = min( sh, 32.*h/dist );\n        dist += h;\n    }\n    return sh;\n}\n\nvec3 shade(vec3 p) {\n    vec3 lightColor = vec3(0.9, 0.99, 0.99);\n\n    vec3 lightDir = normalize(vec3(sin(iTime/1.0), 0.6, -0.3));\n\n    \n    vec3 normal = getNormal(p);\n    vec3 light = lightColor * dot(normal, lightDir);\n   \n    return light* shadow(Ray(p, normalize(lightDir)));\n}\n\n\nvec3 trace( Ray r ) {\n\tfloat totalDistance = 0.0;\n    \n    float colour = 0.8;\n    \n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n\t\tvec3 newLocation = r.origin + totalDistance * r.direction;\n\t\tfloat distance = DistanceEstimator(newLocation);\n\t\ttotalDistance += distance;\n        if( distance < MinimumDistance ) {\n            if( newLocation.y <= MinimumDistance )\n            \tcolour = 1.0;\n        \tbreak;\n        }\n\t}\n   \n    return colour*shade(r.origin + totalDistance* r.direction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 uv = 2.*gl_FragCoord.xy/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 camL = vec3(2.*sin(iTime/1.5) - 1.0, 3, -3.);\n    vec3 dirL = vec3(1.,0.,0.) - camL;\n    mat3 cameraMatrixL = lookAt( camL, dirL, 0.0 );\n\n    vec3 camR = vec3(2.*sin(iTime/1.5) - 1.0, 3, -3.);\n    vec3 dirR = vec3(1.,0.,0.) - camR;\n    mat3 cameraMatrixR = lookAt( camR, dirR, 0.0 );\n\n    \n    \n    vec2 uvDiff = vec2(1);\n\n    float IPD = 0.02 * (1. + cos(iTime/1.5));\n    \n    // should be moving camera instead!\n    vec3 rd5L = normalize(cameraMatrixL * vec3(uv+ vec2(-IPD * uvDiff.x, 0.0 * uvDiff.y),1.0));\n    vec3 rd5R = normalize(cameraMatrixR * vec3(uv+ vec2(IPD * uvDiff.x, 0.0 * uvDiff.y),1.0));\n    \n   \n    vec3 t5L = trace(Ray(camL, rd5L));\n\tvec3 t5R = trace(Ray(camR, rd5R));\n\n    \n    fragColor = vec4(sqrt(t5L.r),  t5R.gb, 1.0);\n}","name":"Image","description":"","type":"image"}]}