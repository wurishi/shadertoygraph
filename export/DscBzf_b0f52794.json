{"ver":"0.1","info":{"id":"DscBzf","date":"1697536561","viewed":57,"name":"Trance-Planet blending pulse","username":"sstrix","description":"Fork Trance-Pla sstrix 357\nImplementing blendig (as mix blend mode type color from w3C css blending draft)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tranceplanet"],"hasliked":0,"parentid":"csycR3","parentname":"Trance-Planet"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// credit: https://www.shadertoy.com/view/4tGXzt\n// color space conversion: https://www.shadertoy.com/view/4dKcWK\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.75;\nconst float BRIGHTNESS = 1.6;\nconst float SPEED = .15;\n\n// color: #4285f4, rgb(67, 135, 244)\nconst vec3 BLENDCOL=vec3(67,135,244); // rgb in formato 0..255\nconst float BLENDSPEED = .12;\n\n\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\nvec3 RGB256toRGBBASE1(vec3 rgb256)\n{\n    return vec3(rgb256.r/256.,rgb256.g/256.,rgb256.b/256.);\n}\n\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\nvec3 doBlend(vec3 inCol, float targetHUE, float blendSpeed)\n{\n    vec3 blnd=RGBtoHSL(inCol);\n    float amount = cos(iTime * blendSpeed);\n    \n    float H=blnd.x;\n    float S=blnd.y;\n  \n    H=H-((H-targetHUE)*amount);\n    \n    blnd=vec3(H,S,blnd.z);\n    vec3 color=HSLtoRGB(blnd);\n     \n    return color;\n}\n\n\nfloat Lum(vec3 C)\n{\n    return 0.3 * C.r + 0.59 * C.g + 0.11 * C.b;\n}\n\nvec3 ClipColor(vec3 C)\n{\n        float L = Lum(C);\n        float n = min(min(C.r, C.g), C.b);\n        float x = max(max(C.r, C.g), C.b);\n        if(n < 0.)\n            C = L + (((C - L) * L) / (L - n));\n\n        if(x > 1.)\n            C = L + (((C - L) * (1. - L)) / (x - L));\n\n        return C;\n}\n\nvec3 SetLum(vec3 C, float l)\n{\n        float d = (l - Lum(C));\n        C.r = C.r + d;\n        C.g = C.g + d;\n        C.b = C.b + d;\n        return ClipColor(C);\n}\n\nfloat Cmax(vec3 C)\n{\n    return max(max(C.r, C.g), C.b);\n}\n\nfloat Cmin(vec3 C)\n{\n    return min(min(C.r, C.g), C.b);\n}\n\nfloat Cmid(vec3 C)\n{\n    return (C.r+C.g+C.b)/3.;\n}\n\n\nfloat Sat(vec3 C) {\n    return Cmax(C) - Cmin(C);\n}\n\nvec3 SetSat(vec3 C, float s)\n{\n        float Cmd = 0.;\n        float Cmx = 0.;\n        float Cmn = 0.;\n\n\n        if(Cmax(C) > Cmin(C))\n        {\n            float Cmd = (((Cmid(C) - Cmin(C)) * s) / (Cmax(C) - Cmin(C)));\n            float Cmx = s;   \n        }\n\n        // non chiaro!!!\n        return C;\n}\n\n\n\nvec3 doBlend2(vec3 inCol, float blendSpeed)\n{\n    // W3C: https://drafts.fxtf.org/compositing/#blendingcolor\n\n    vec3 blnd=RGBtoHSL(inCol);\n    float amount = cos(iTime * blendSpeed);\n    \n    float H=blnd.x;\n    float S=blnd.y;\n  \n    vec3 mask=RGB256toRGBBASE1(BLENDCOL);\n  \n    vec3 outCol=SetLum(mask, Lum(inCol));\n     \n   \n     return outCol;\n}\n\nvec3 blendColorW3C(vec3 inCol, float intensity)\n{\n    vec3 blend=doBlend2(inCol, BLENDSPEED);\n    \n    float r=blend.r*(1.-intensity)+inCol.r*intensity;\n    float g=blend.g*(1.-intensity)+inCol.g*intensity;\n    float b=blend.b*(1.-intensity)+inCol.b*intensity;\n    \n    return vec3(r,g,b);\n}\n\n// easing\n// https://github.com/glslify/glsl-easings\n// reference: https://easings.net/\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nfloat circularIn(float t) {\n  return 1.0 - sqrt(1.0 - t * t);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n    \n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n    \n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n    float blendIntensity = circularIn(abs(cos(iTime * BLENDSPEED)));\n    color=blendColorW3C(color, blendIntensity);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}