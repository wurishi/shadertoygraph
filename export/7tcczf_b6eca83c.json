{"ver":"0.1","info":{"id":"7tcczf","date":"1660238784","viewed":92,"name":"2022-08-11-miukusilmä","username":"leonarven","description":"45min exercise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["exercise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// @see https://www.shadertoy.com/view/4dS3Wd\n\n// @see Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013 @see https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n// ----------------------------------------------\n\n#define PI 3.1415926535\n\nvec3 eye_back_palette( float x, vec3 base ) {\n\n    x += 127.;\n    x *= 11.;\n       \n    float dv = length( sin( x * 10. + base ) + sin(10. * (x * sin( base / 2.0 )) + base) + sin( sqrt( 100. * x + 1. ) + base ));\n \n    vec3 col = clamp( vec3( abs( sin( dv * PI ))*.7, abs( sin( dv * PI + 2. * PI / 3.)), abs( sin( dv * PI + 4. * PI / 3. ))), 0.0, 1.0 );\n    \n    return (col * base) / max(max(base.r,base.g),base.b);\n}\n\nvec3 eye( in float a, in float r, in vec2 uv ) {\n\n    vec3 col = vec3(0,0,0);\n    \n    if (r < .3) {\n    \n        // mykiö\n        col = vec3(0);\n        \n    } else if (r < 1.) {\n\n        // Värikalvo  \n        col += vec3( eye_back_palette( ( a + sin( noise( vec2(11.*a, r * 6.) )) / PI / 6. ) / (2.*PI), (vec3(96,49,1) / 255.) ) / 2. );\n\n        // Sisäsyrjän vaalea rengas\n        vec3 innr = vec3(119,142,64)/140. * (1. + sin(  noise( 123. + vec2( uv.x, uv.y ) * 6. )));\n         \n        col += sqrt(innr) * max( 0., ((1. - (r + noise(vec2(a)) * .1) ) - .45) );           \n\n\n        // Vaaleita alueita ympäriinsä\n        col += (noise(vec2(a, r)*3.) + .5) / 5.;\n\n        // Vaaleita ja tummia pisteitä ympäriinsä\n        //col -= clamp( pow( (noise(vec2(a, r*.3)*40.)), 2.), -1., 0. );\n        \n        // Tummia pisteitä ympäriinsä\n        col -= pow( (noise(vec2(a, r)*40.)), 2.) / 4.;\n\n        // Värikalvon sisäsyrjän gradientti mykiön mustaan\n        if (r < .325) col -= (1. - (r - .3) * 40.);\n       \n        // Värikalvon ulkosyrjän tummentuva gradientti\n        if (r > .7) col *= cos( 7. * (r - .7) + ( noise(vec2(a / PI) * .10 ) ));\n\n        // Värikalvon ulkosyrjän gradientti valkuaiseen\n        if (r > .95) col += vec3( (r-.95) * 50. );\n        \n    } else {\n\n        // valkuainen\n        col = vec3(1);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float ratio = iResolution.x / iResolution.y;\n\n    vec2 uv = (fragCoord/iResolution.xy - .5) * 2.;\n    \n    uv.x = uv.x * ratio; // [ -1, 1 ]\n\n    float r = length( uv ); // [ 0, 1 ]\n    \n    float a = atan(uv.y, uv.x) + PI; // [ 0, 2PI ]\n  \n    vec3 col = eye( a, r, uv );\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}