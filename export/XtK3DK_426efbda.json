{"ver":"0.1","info":{"id":"XtK3DK","date":"1476828588","viewed":240,"name":"Music Self-Similarity","username":"metabog","description":"Self-similarity matrix reveals information about the structure of the song. Let it run for a while to see structure appear. \n\nIt's a bit slow and terrible but it's a first attempt. I had to hard code the song length. ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["music","audio","matrix","analysis","information","self","informationretrieval","similarity","structure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nWhat is this?\n\nA self-similarity matrix is a way of uncovering useful information about musical sections in a song. \nFor example, you can clearly see the relationship between verse, chorus, etc. This is done by comparing\neveryt FFT frame with every other FFT frame. I used cosine distance as a metric. \n\nOnce you have a SSM you can extract the boundaries by calculating novelty functions on the matrix,\ndecomposition, etc. One easy way is to run a sort of edge detector left-to-right, which will spike \nat boundaries.\n\nAs you'd expect, the diagonal of the matrix is the most similar, so it's all maximum valued. You\ncan also see 'off-diagonals', which show paths in the song that are similar. \n\nSimilarity matrix between two different songs is also the first step in doing Dynamic Time Warping\nfor automatic time alignment (aligning two versions of the same song).\n\nAfter the shader runs for a while you should be able to clearly see the distinct sections of the \ncool song. :)\n\nIt could be much faster if I didn't calculate all the distances again every frame but saved them instead,\nhowever I am too lazy.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float progress = iTime/205.0; //this is song length in seconds!\n\tprogress = clamp(progress,0.1,1.0);\n    \n    vec2 coord = (fragCoord.xy*progress)/iResolution.xy;    \n    float sum1 = 0.0;\n    float sum2 = 0.0;\n    float sum3 = 0.0;\n\n    //cosine distance\n    \n    for(float i=0.0; i<1.0; i+=0.05) //lower increment for higher res... but slower\n    {\n        float v1 = texture(iChannel0, vec2(coord.x,i)).x;\n        float v2 = texture(iChannel0, vec2(coord.y,i)).x;\n        sum1+=v1*v2;\n        sum2+=v1*v1;\n        sum3+=v2*v2;\n    }\n\t\n    sum2 = sqrt(sum2);\n    sum3 = sqrt(sum3);\n    \n    float cdist = sum1/(sum2*sum3 + 0.001);\n\tcdist = pow(cdist,256.0); //accentuate\n\tvec4 col = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    fragColor = clamp(col*cdist +\n                vec4(0.1),vec4(0.0),vec4(1.0))*2.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 read(vec2 fragCoord, vec2 pos)\n{\n    return texture(iChannel0,(fragCoord+pos)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iTime<0.2)\n    {\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n    \n \t\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tfloat progress = iTime/205.0; //this is song length in seconds!\n        float xprog = progress*iResolution.x;\n    \n    \tfloat val = 0.0; \n    \tvec4 current = read(fragCoord.xy,vec2(0.0,0.0));\n    \n   \t    vec4 s = texture(iChannel1, vec2(uv.y,0.0));\n\t\tif(fragCoord.x<xprog+0.5 && fragCoord.x>xprog-0.5)\n        \tval = s.x;\n        \n    \tfragColor = current + vec4(1.0)*val*0.3;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}