{"ver":"0.1","info":{"id":"MXSyRw","date":"1728958032","viewed":19,"name":"2d RT phase space v2","username":"saezhe","description":"2d regular temperament phase space\n\nnow with controls!\n\nEXPLORE TUNINGS\n\nThis graphic highlights which combinations of generators result in rank 2 temperaments that approximate notes in a target scale using low integer combinations of the generators.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["mouse","grid","visualization","zoom","render","multipass","wasd","pan","controls","hd","tuning","xenharmonics"],"hasliked":0,"parentid":"4fSBR3","parentname":"regular temperament phase space"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n2d regular temperament phase space\n\nEXPLORE TUNINGS\n\nControls:\n\nmove: WASD, zoom in:\tQ, out: E\nslow zoom:\t\t\t\tI/O\nreset viewport:\t\t\tR\nHD rendering toggle:\tT\ncrosshair toggle:\t\tF\ngrid toggle:\t\t\tG\ntoggle main rendering:\tP\n\nfor toggles that aren't working in low fps conditions,\npress and hold the key until the toggle updates.\n\nThis graphic highlights which combinations of generators result in\nrank 2 temperaments that approximate notes in a target scale using\nlow integer combinations of the generators.\n\nthe x and y axes are independent logarithmic generators which each\nrepresent one key step of an ismorphic keyboard lattice, which by\ndefault here is assumed to be hexagonal. (to alter this assumption,\nchange calls to isometricDist() into calls to cartesianDist() .)\n\nfor each point in the space, one can see information for the closest\napproximations to various scale degrees that are reached via close-by\ncombinations of generator key-steps. the default coded scale is the\nharmonics 8::16, so that intervals of\n1/1, 9/8, 5/4, 11/8, 3/2, 13/8, 7/4, 15/8, 2/1 are shown.\nto alter the scale, edit the\n#define RAW_SCALE_SIZE (currently 9)\nand the targetScaleRaw array accordingly.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool eRenToggle = GETVAL(REN_TOGGLE)>0.5;\n    float res_scale = eRenToggle?1.:RESOLUTION_SCALE;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(0.,0.,0.,0.);\n    col += textureLod(iChannel1,vec2(uv*res_scale),0.);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// state sourced from https://www.shadertoy.com/view/tdtBR7\n\n#define GETVAL(INDEX) texelFetch(iChannel0,ivec2(INDEX,0),0).x\n#define GETKEY(INDEX) (texelFetch(iChannel1,ivec2(INDEX,0),0).x>0.5)\n\n#define RESOLUTION_SCALE 0.428\n\n//W=87\n#define KEY_UP\t\t87\n//S=83\n#define KEY_DOWN\t83\n//A=65\n#define KEY_LEFT\t65\n//D=68\n#define KEY_RIGHT\t68\n\n\n//Q=81\n#define KEY_IN\t81\n//E=69\n#define KEY_OUT\t69\n\n//I=73\n#define KEY_SLOW_IN\t73\n//O=79\n#define KEY_SLOW_OUT\t79\n\n//R=82\n#define KEY_RESET\t82\n//T=84\n#define KEY_RENDER_TOGGLE\t84\n//F=70\n#define KEY_CROSSHAIR_TOGGLE\t70\n//G=71\n#define KEY_GRID_TOGGLE\t71\n\n//P=80\n#define KEY_PIPE_DISABLE\t80\n\n#define CAM_X\t0\n#define CAM_Y\t1\n// zoom\n#define CAM_Z\t2\n// toggles\n#define REN_TOGGLE 5\n#define CH_TOGGLE 7\n#define GRID_TOGGLE 9\n// signals\n// signal of overlayed frames\n// (if it is 0, then it has reset because the view has changed,\n// otherwise it counts how many frames it has been since the last change)\n#define PIPE_DISABLE 11\n#define SIG_FRAME_LAYERS 3\n// resolution state\n#define IRES_LENGTH 4\n// key states\n#define KEYPRESSED_RENTOGGLE 6\n#define KEYPRESSED_CHTOGGLE 8\n#define KEYPRESSED_GRIDTOGGLE 10\n// mouse state\n#define MOUSEPRESSED_X 12\n#define MOUSEPRESSED_Y 13\n\n\n// hash algorithm for randomness\n// from https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 1\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat rand(vec2 position, float time) {\n    float a = 0.;\n    for (int t = 0; t < ITERATIONS; t++) {\n        float v = float(t+1)*.152;\n        vec2 pos = (position * v + time * 1500. + 50.0);\n        a += hash12(pos.xy);\n    }\n    return a / float(ITERATIONS);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// method for statefulness sourced from https://www.shadertoy.com/view/tdtBR7\n\n#define SETVAL(INDEX,VAL) if(int(fragCoord.x)==INDEX) fragColor=vec4(VAL)\n\n#define CAM_INC 0.008\n#define ZOOM_INC pow(2.,0.06)\n#define SLOW_ZOOM_INC pow(2.,0.01)\n#define MOUSE_PAN_MULT -1.0\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat x = GETVAL(CAM_X);\n    float y = GETVAL(CAM_Y);\n    float zoom = GETVAL(CAM_Z);\n    float viewDifference = GETVAL(SIG_FRAME_LAYERS);\n    float renderToggle = GETVAL(REN_TOGGLE);\n    float crosshairToggle = GETVAL(CH_TOGGLE);\n    float gridToggle = GETVAL(GRID_TOGGLE);\n    float disablePipelines = 0.;\n    \n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    if(iTime<0.1 || GETKEY(KEY_RESET)) {\n        if (x!=600.||y!=600.||zoom!=1.) viewDifference=0.;\n    \ty = 600.;\n        x = 600.;\n        zoom = 1.;\n        renderToggle=0.;\n        crosshairToggle=1.;\n        gridToggle=1.;\n    }\n    if (iResolution.x != GETVAL(IRES_LENGTH)) viewDifference=0.;\n    \n    // render toggle rising edge (keydown) detector\n    bool isRenKeyDown = GETKEY(KEY_RENDER_TOGGLE);\n    if (GETVAL(KEYPRESSED_RENTOGGLE)<.5&&isRenKeyDown) {\n        viewDifference=0.;\n        renderToggle = 1.-renderToggle;\n    }\n    SETVAL(KEYPRESSED_RENTOGGLE,isRenKeyDown?1.:0.);\n    // crosshair toggle rising edge (keydown) detector\n    bool isCHKeyDown = GETKEY(KEY_CROSSHAIR_TOGGLE);\n    if (GETVAL(KEYPRESSED_CHTOGGLE)<.5&&isCHKeyDown) {\n        viewDifference=0.;\n        crosshairToggle = 1.-crosshairToggle;\n    }\n    SETVAL(KEYPRESSED_CHTOGGLE,isCHKeyDown?1.:0.);\n    // grid toggle rising edge (keydown) detector\n    bool isGridKeyDown = GETKEY(KEY_GRID_TOGGLE);\n    if (GETVAL(KEYPRESSED_GRIDTOGGLE)<.5&&isGridKeyDown) {\n        viewDifference=0.;\n        gridToggle = 1.-gridToggle;\n    }\n    SETVAL(KEYPRESSED_GRIDTOGGLE,isGridKeyDown?1.:0.);\n    \n    // handle movement first with mouse or otherwise with wasd\n    if (iMouse.w > 0.) {\n        SETVAL(MOUSEPRESSED_X,iMouse.x);\n        SETVAL(MOUSEPRESSED_Y,iMouse.y);\n    } else if (iMouse.z > 0.) {\n        float dx = (iMouse.x-GETVAL(MOUSEPRESSED_X));\n        float dy = (iMouse.y-GETVAL(MOUSEPRESSED_Y));\n        if (dx!=0.||dy!=0.) viewDifference=0.;\n        float invDisplaySquareSize =\n            1./min(iResolution.x,iResolution.y);\n        x+=MOUSE_PAN_MULT*1200.*invDisplaySquareSize*dx/zoom;\n        y+=MOUSE_PAN_MULT*1200.*invDisplaySquareSize*dy/zoom;\n        SETVAL(MOUSEPRESSED_X,iMouse.x);\n        SETVAL(MOUSEPRESSED_Y,iMouse.y);\n    }\n    \n\tif(GETKEY( KEY_UP )&&y<1200.) {\n        viewDifference=0.;\n        if (y+CAM_INC*1200./zoom>1200.)\n            {y = 1200.;}\n        else y = (y+CAM_INC*1200./zoom);\n    }\n    if(GETKEY( KEY_DOWN )&&y!=0.) {\n        viewDifference=0.;\n        if (y-CAM_INC*1200./zoom<0.)\n            {y = 0.;}\n        else y = (y-CAM_INC*1200./zoom);\n    }\n    if(GETKEY( KEY_LEFT )&&x!=0.) {\n        viewDifference=0.;\n        if (x-CAM_INC*1200./zoom<0.)\n            {x = 0.;}\n        else x = (x-CAM_INC*1200./zoom);\n    }\n    if(GETKEY( KEY_RIGHT )&&x!=1200.) {\n        viewDifference=0.;\n        if (x+CAM_INC*1200./zoom>1200.)\n            {x = 1200.;}\n        else x = (x+CAM_INC*1200./zoom);\n    }\n        \n    if(GETKEY(KEY_SLOW_IN)&&zoom!=48000.) {\n        viewDifference=0.;\n        if (zoom*SLOW_ZOOM_INC>48000.) {zoom = 48000.;}\n        else {zoom = zoom*SLOW_ZOOM_INC;}\n    }\n    if(GETKEY(KEY_SLOW_OUT)&&zoom!=1.) {\n        viewDifference=0.;\n        if (zoom/SLOW_ZOOM_INC<1.) {zoom = 1.;}\n        else {zoom = zoom/SLOW_ZOOM_INC;}\n    }\n    if(GETKEY(KEY_IN)&&zoom!=48000.) {\n        viewDifference=0.;\n        if (zoom*ZOOM_INC>48000.) {zoom = 48000.;}\n        else {zoom = zoom*ZOOM_INC;}\n    }\n    if(GETKEY(KEY_OUT)&&zoom!=.5) {\n        viewDifference=0.;\n        if (zoom/ZOOM_INC<.5) {zoom = .5;}\n        else {zoom = zoom/ZOOM_INC;}\n    }\n    \n    if(GETKEY(KEY_PIPE_DISABLE)) {\n        if (GETVAL(PIPE_DISABLE)<0.5) viewDifference=0.;\n        disablePipelines=1.;\n    } else {\n        if (GETVAL(PIPE_DISABLE)>0.5) viewDifference=0.;\n    }\n    \n    \n    SETVAL(CAM_X,x);\n    SETVAL(CAM_Y,y);\n    SETVAL(CAM_Z,zoom);\n    SETVAL(SIG_FRAME_LAYERS,viewDifference+1.);\n    SETVAL(IRES_LENGTH,iResolution.x);\n    SETVAL(REN_TOGGLE,renderToggle);\n    SETVAL(CH_TOGGLE,crosshairToggle);\n    SETVAL(GRID_TOGGLE,gridToggle);\n    SETVAL(PIPE_DISABLE,disablePipelines);\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 render(vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool eRenToggle = GETVAL(REN_TOGGLE)>0.5;\n    float res_scale = eRenToggle?1.:RESOLUTION_SCALE;\n    \n    if (fragCoord.x>iResolution.x*res_scale||fragCoord.y>iResolution.y*res_scale) {\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    \n    float numframes = GETVAL(SIG_FRAME_LAYERS);\n    /*if (numframes==1.) {\n        vec4 rencol = render(fragCoord/RESOLUTION_SCALE);\n        vec4 precol = textureLod(iChannel1,fragCoord.xy/iResolution.xy,0.);\n        fragColor = .8*rencol+.2*precol+.5*rencol*precol;\n        return;\n    }*/\n    if (numframes==1.) {\n        fragColor = render(fragCoord/res_scale);\n        return;\n    }\n    fragColor = (1./numframes)*render(fragCoord/res_scale)+(1.-1./numframes)*textureLod(iChannel1,fragCoord.xy/iResolution.xy,0.);\n    \n}\n\n// state sourced from https://www.shadertoy.com/view/tdtBR7\n\n#define tau 6.283185307179586\n\n// inputs arithmetic ratios\nfloat centserror(float a, float b) {\n    return 1200.0*(log2(b)-log2(a));\n}\n// inputs cents, subtracts them\nfloat trivialcentserror(float a, float b) {\n    return b-a;\n}\n\n//inputs arithmetic ratio, while mapping {1,2} to 2\nfloat octaveReduce(float a) {\n    if (a == 1.) {return 1.;}\n    else {return pow(2.,1.-mod(-log2(a),1.));}\n}\n\n#define OPT_CENTS_LIM 10.\n#define OPT_POINT_MODERATION 0.02\nfloat errToIntensity(float cents) {\n    return 1./(OPT_POINT_MODERATION+cents/OPT_CENTS_LIM);\n}\n\nfloat isometricDist(vec2 inp) {\n    return sqrt(pow(inp.x+inp.y/2.,2.)+pow(inp.y*sqrt(3.)/2.,2.));\n}\n\nfloat cartesianDist(vec2 inp) {\n    return sqrt(pow(inp.x,2.)+pow(inp.y,2.));\n}\n\nfloat fitness(vec3 inp) { // format: (distance, error, importance)\n    //return errToIntensity(inp.y); // just return error's intensity\n    return errToIntensity(inp.y)/(inp.x+1.)*inp.z; // alternative\n}\n\n// function source: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat atan3(vec2 st){\n    return mod(atan(st.y, st.x), tau);\n}\n\n\n#define RAW_SCALE_SIZE 9\n\nvec4 render(vec2 fragCoord) {\n\n    vec4 fragColor;\n    // external controls recieving:\n\tvec2 eCamera = vec2(GETVAL(CAM_X),GETVAL(CAM_Y));\n    float eZoom = GETVAL(CAM_Z);\n    \n    bool eRenToggle = GETVAL(REN_TOGGLE)>0.5;\n    float res_scale = eRenToggle?1.:RESOLUTION_SCALE;\n    \n    bool eCHToggle = GETVAL(CH_TOGGLE)>0.5;\n    bool eGridToggle = GETVAL(GRID_TOGGLE)>0.5;\n    \n    bool eDisablePipelines = GETVAL(PIPE_DISABLE)>0.5;\n    \n    float it = iTime+0.;\n    vec2 position = fragCoord.xy;\n    // fuzziness to get rid of aliasing\n    position += (vec2( rand(position, mod(it,1.)), rand(position, mod(it,1.)+1.) )-.5);\n    \n    // finding bearings and reference points for positioning the frame with respect to the screen resolution\n    float displaySquareSize = min(iResolution.x,iResolution.y);\n    vec2 displaySquarePixelsOffset = (iResolution.xy-vec2(displaySquareSize,displaySquareSize))/2.0;\n    // the bottom left here will actually be the bottom left of the center-square area on screen.\n    \n    // pan/zoom display settings\n    \n    // 2330\n    \n    /*\n    vec2 bottomLeftRep = vec2(0.,0.);\n    float squareSizeRep = 1200.;\n    //*/\n    \n    // pan from 600cents being in the middle\n    //vec2 pan = bottomleftrep+squaresizerep/2.0-vec2(600.0,600.0);\n    //float zoom = 1200.0/squaresizerep;\n    \n    \n    \n    // alternate settings order:\n    //*\n    \n    vec2 pan = eCamera-vec2(600.0,600.0);\n    float zoom = eZoom;\n    \n    // assorted examples of some interesting tunings i found while exploring\n    //vec2(193.86,115.35)\n    //vec2(193.4,123.96)\n    //vec2(703.67,380.73)\n    //vec2(544.89,295.62)\n    //vec2(264.4, 233.9)\n    //vec2(122.94, 115.59)\n    //vec2(339.06, 208.68)\n    //pan = vec2(339.06, 208.68)-vec2(600.0,600.0);\n    \n    //zoom = 3.+pow(abs(sin(it/10.0+2.)),4.)*20000.;\n    vec2 bottomLeftRep = vec2(600.,600.)-vec2(600.,600.)/zoom+pan;\n    float squareSizeRep = 1200.0/zoom;\n    //*/\n    \n    // sway-panning and zooming automatically:\n    /*\n    squareSizeRep = 4.0+1196.0*pow(cos(it/47.465-3.3),4.);\n    bottomLeftRep = vec2(0.,0)+vec2((1200.-squareSizeRep)*(sin(it/50.0+2.)*.5+.5),(1200.-squareSizeRep)*(cos(it/82.472)*.5+.5));\n    zoom=1200.0/squareSizeRep;\n    //*/\n    //bottomLeftRep/=2.; squareSizeRep/=2.;\n    \n    // other helpful values\n    //vec2 toprightrep = bottomleftrep+squaresizerep\n    //vec2 midpointrep = bottomleftrep+squaresizerep/2.0\n    \n    // cents per screen pixel\n    float pixelvalue = squareSizeRep/displaySquareSize;\n    \n    // calculation of local coordinates\n    \n    // local coordinates with the middle square being from 0 to 1\n    vec2 frag = (position-displaySquarePixelsOffset)/displaySquareSize;\n    // zoomed and panned interval cent-size coords\n    vec2 cents = bottomLeftRep+frag*squareSizeRep;\n    // arithmetic to cents fudger\n    //cents = 1200.*log2(cents/1200.+1.);\n    \n    if (cents.x<0.||cents.x>1200.||cents.y<0.||cents.y>1200.) {\n        //fragColor = vec4(abs(sin(cents.x)),abs(sin(cents.y)),abs(sin(cents.x+cents.y)),1.);\n        //float col = round(mod(cents.x+cents.y,1.)/2.+mod(cents.x-cents.y,1.)/2.);\n        float col = .25+.5*rand(position,mod(it,1.));\n        return vec4(col,col,col,1.);\n    }\n    \n\n    // vignette pixels rendering in general\n    if (!eRenToggle&&!eDisablePipelines) {\n        float V = 4.*pow(max(0.,length(frag-.5)-.5),1.6)\n            + rand(position, mod(it,1.));\n        if (V>1.) {\n            return vec4(.2,.1,.15,1.);\n        }\n    }\n    //return vec4(abs(cents.x/1200.),0.,abs(cents.y/1200.),1.);\n\n    // vec2 arith = vec2(pow(2.0,(cents.x/1200.0)),pow(2.0,(cents.y/1200.0)));\n\n    // target scale setup\n    float targetScaleRaw[RAW_SCALE_SIZE] = float[RAW_SCALE_SIZE]\n        (8.0,9.0,10.,11.,12.,13.,14.,15.,16.);\n    float targetScaleImportance[RAW_SCALE_SIZE] = float[RAW_SCALE_SIZE]\n        //(1.0,0.4,0.5,0.4,0.8,0.4,0.5,0.4,1.0);\n        (1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0);\n    // octave reduced version\n    float targetScale[RAW_SCALE_SIZE];\n    float base = targetScaleRaw[0];\n    for (int i = 0; i<RAW_SCALE_SIZE; i++) {\n        targetScale[i]=octaveReduce(targetScaleRaw[i]/base);\n    }\n    // remove any duplicates\n    int uniqueScaleDegrees = 0;\n    for (int i = 0; i<RAW_SCALE_SIZE; i++) {\n        // check for duplicates\n        // if duplicate, then uniqueScaleDegrees does not increment\n        bool dup = false;\n        for (int j = 0;j<uniqueScaleDegrees;j++) {\n            if (targetScale[i]==targetScale[j]) {\n                dup == true;\n                break; //do nothing but increment i\n            }\n        }\n        if (!dup) { // every time there's a new unique, the number variable is incremented\n            targetScale[uniqueScaleDegrees]=targetScale[i];\n            uniqueScaleDegrees++;\n            //int dups = RAW_SCALE_SIZE-uniqueScaleDegrees;\n\n        }\n\n    }\n    // cents values for ease\n    float targetScaleCents[RAW_SCALE_SIZE];\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        targetScaleCents[i]=1200.*log2(targetScale[i]);\n    }\n    \n    // canonical coloring for each scale degree\n    vec3 scaleColors[RAW_SCALE_SIZE];\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        if (targetScaleCents[i]==0.) {\n            scaleColors[i]=vec3(.75,.75,.75);\n        } else {\n            scaleColors[i]=hsv2rgb(vec3(targetScale[i]-1./6.,1.,1.) );\n        }\n    }\n    \n    // setup of possible linear combinations lattice\n\n    float n = 8.; // max radius lattice points are from origin (in isometric space)\n    float originalN = n;\n    // only show hign n near the middle of the screen, show lower n's as vignette\n    if (!eRenToggle) {\n        n = max(2.,n * 1. / max(1., pow(.75+.6*length(frag-.5),5.)));\n        // dither n based on position\n        n = n * (.6 + .4*rand(position, mod(it,1.)) );\n        \n        // dither n based on radius and position\n        //n = n*max(2.,1.-(pow(max(0.,length(frag-.5)-.5),2.)\n        //    * (.5+.5*rand(position, mod(it,1.)))));\n    }\n    // actual rendering\n\n    // loop through all lattice combinations, picking which ones are the smallest error and closest distance.\n    // a fitness function is needed to determine a pick's fitness depending on its distance and its error, and how important the scale degree is to approximate.\n\n    // greatest fitness lattice point for each scale degree,\n    vec2 winpoint[RAW_SCALE_SIZE];\n    // along with its distance, error, and score\n    vec4 winmetrics[RAW_SCALE_SIZE]; // format: (distance, error, score, signed error)\n    // or, an accumulated score list for each scale degree, across all lattice points.\n    float accum[RAW_SCALE_SIZE]; // there will be a sum of all individual items in this list at the end, too.\n    // for suspicion\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        accum[i]=0.;\n    }\n    int masterN=0; // normalizing factor\n\n    // bounding box to check for exact pixel line.\n    // size of box  / thickness of line\n    float lineSize = 1.+0.*(1.+pow(zoom/10000.,.5));\n    float lineBorderRatio = 4.;\n    vec2 centsA, centsB, centsC, centsD;\n    // bounding box arranged as:\n    // C D\n    // A B\n    // bounding box check success flag / which scale degree hit it\n    bool onLine[RAW_SCALE_SIZE]; // i assume this initializes to all false\n    bool onBorder[RAW_SCALE_SIZE]; // i assume this initializes to all false\n    //*\n    // loop through each scale degree\n    for (int k=0;k<uniqueScaleDegrees;k++) {\n        float tempN;\n        if (eRenToggle) {\n            if (targetScaleCents[k] == 0. || targetScaleCents[k] == 1200.) {\n                tempN=originalN*1.5;\n            } else {\n                tempN=originalN;\n            }\n        } else if (targetScaleCents[k] == 0. || targetScaleCents[k] == 1200.) {\n            tempN=min(originalN*1.5,n*2.);\n\n        } else {\n            tempN=n;\n        }\n        int N = int(ceil(tempN/sqrt(3.)*2.)); // radius of diamond lattice to generate to get all points within isometric radius\n        // actual size of full lattice is 1+2*N\n\n        // loop through potential lattice points\n\n        for (int i=-N;i<=N;i++) {\n            for (int j=-N;j<=N;j++) {\n                // immediately reject lattice points which can never produce positive intervals\n                if (i<=0&&j<=0) continue;\n                \n                float pointCents = cents.x*float(i)+cents.y*float(j);\n                // reject lattice points which don't happen to produce positive intervals\n                if (pointCents<-20.) continue;\n                \n                float dist = isometricDist(vec2(float(i),float(j)));\n                // immediately reject lattice points too far away isometrically\n                if (dist>float(tempN)) continue;\n                \n                float signedErr = pointCents-targetScaleCents[k];\n                float err = abs(signedErr);\n                float fit = fitness(vec3(dist,err,targetScaleImportance[k]));\n                \n                // check and update best fitness parallel arrays\n                if (fit>winmetrics[k].z) {\n                    winpoint[k].x=float(i); // lattice x\n                    winpoint[k].y=float(j); // lattice y\n                    winmetrics[k].x=dist; // distance\n                    winmetrics[k].y=err; // error\n                    winmetrics[k].z=fit; // score\n                    winmetrics[k].w=signedErr; // signed error\n                }\n                // update accumulator for pointscaledegree\n                accum[k]+=fit;\n                masterN+=1;\n                // check bounding box test for line intersection\n                // border first; if border fails then we can continue.\n                // cents values for each point in bounding box\n                centsA = vec2(cents.x - pixelvalue*lineSize*lineBorderRatio,\n                        cents.y - pixelvalue*lineSize*lineBorderRatio);\n                centsB = vec2(cents.x - pixelvalue*lineSize*lineBorderRatio,\n                        cents.y + pixelvalue*lineSize*lineBorderRatio);\n                centsC = vec2(cents.x + pixelvalue*lineSize*lineBorderRatio,\n                        cents.y - pixelvalue*lineSize*lineBorderRatio);\n                centsD = vec2(cents.x + pixelvalue*lineSize*lineBorderRatio,\n                        cents.y + pixelvalue*lineSize*lineBorderRatio);\n                // bounding box result cents\n                float pointCentsA = centsA.x*float(i)+centsA.y*float(j);\n                float pointCentsB = centsB.x*float(i)+centsB.y*float(j);\n                float pointCentsC = centsC.x*float(i)+centsC.y*float(j);\n                float pointCentsD = centsD.x*float(i)+centsD.y*float(j);\n                // which side of the line each point is on\n                bool sA = pointCentsA-targetScaleCents[k] >= 0.;\n                bool sB = pointCentsB-targetScaleCents[k] >= 0.;\n                bool sC = pointCentsC-targetScaleCents[k] >= 0.;\n                bool sD = pointCentsD-targetScaleCents[k] >= 0.;\n                \n                onBorder[k] = onBorder[k]||\n                    ( !(sA && sB && sC && sD) && (sA || sB || sC || sD) );\n                if (!onBorder[k]) continue;\n                \n                // actual line\n                // cents values for each point in bounding box\n                centsA = vec2(cents.x - pixelvalue*lineSize,\n                        cents.y - pixelvalue*lineSize);\n                centsB = vec2(cents.x - pixelvalue*lineSize,\n                        cents.y + pixelvalue*lineSize);\n                centsC = vec2(cents.x + pixelvalue*lineSize,\n                        cents.y - pixelvalue*lineSize);\n                centsD = vec2(cents.x + pixelvalue*lineSize,\n                        cents.y + pixelvalue*lineSize);\n                // bounding box result cents\n                pointCentsA = centsA.x*float(i)+centsA.y*float(j);\n                pointCentsB = centsB.x*float(i)+centsB.y*float(j);\n                pointCentsC = centsC.x*float(i)+centsC.y*float(j);\n                pointCentsD = centsD.x*float(i)+centsD.y*float(j);\n                // which side of the line each point is on\n                sA = pointCentsA-targetScaleCents[k] >= 0.;\n                sB = pointCentsB-targetScaleCents[k] >= 0.;\n                sC = pointCentsC-targetScaleCents[k] >= 0.;\n                sD = pointCentsD-targetScaleCents[k] >= 0.;\n                // if the points are not all on the same side,\n                // then the line intersect the bounding box\n                // (aka if some but not all of them are true; mass xor)\n                onLine[k] = onLine[k]||\n                    ( !(sA && sB && sC && sD) && (sA || sB || sC || sD) );\n            }\n        }\n    }\n    //*/\n    \n    vec3 col = vec3(0.,0.,0.);\n    \n    float normal;\n    \n    if (!eDisablePipelines) {\n        \n\n        // render pipelines\n        \n        float scoreWhiteBalance = 0.1;\n\n        // grand total of partial sums of scores from each lattice possibility\n        /*\n        float totalaccum = 0.;\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            totalaccum+=accum[i];\n        }\n        totalaccum /= float(masterN);\n        totalaccum *= 600.;\n        totalaccum -= 1.3;\n        col = vec3(totalaccum,totalaccum,totalaccum);\n        /**/\n\n        // sum of colored best scores\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            vec3 tempcol = scaleColors[i]*2.*scoreWhiteBalance;\n            col += tempcol*winmetrics[i].z;\n        }\n        //*/\n\n        // sum of inverted error (from 10 cents)\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            vec3 tempcol = scaleColors[i]*.6;\n            col += tempcol*max(0.,(10.-winmetrics[i].y)/20.);\n        }\n        //*/\n\n        // maximum of min error, colored by interval\n        /*\n        col = vec3(0.,0.,0.);\n        float maxe = 0.;\n        float colmax = 0.;\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            if (winmetrics[i].y>maxe) {\n                maxe=winmetrics[i].y;\n                vec3 tempcol = scaleColors[i];\n                //tempcol = vec3(1.,1.,1.);\n                colmax=1./(1.+max(((1./winmetrics[i].z-1.)-10.)/20.,0.));\n                col = tempcol*colmax;\n            }\n        }\n        //*/\n\n        // minimum of min error, colored by interval\n        /*\n        col = vec3(0.,0.,0.);\n        float mine = 1200.;\n        float colmin = 0.;\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            if (winmetrics[i].y<mine) {\n                mine=winmetrics[i].y;\n                vec3 tempcol = scaleColors[i];\n                colmin=1./(1.+max((1./winmetrics[i].z-1.)/5.,0.));\n                col = tempcol*colmin;\n            }\n        }\n        //*/\n\n        // min on r, max on g, and sum of best scores is b\n        // (needs two comment blocks above also decommented)\n        /*\n        col = vec3(colmin,colmax,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            col.z += winmetrics[i].z*1.;\n        }\n        //*/\n\n        // polar coordinates of winning point\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            float angle = 2.*(-0.5+mod(0.5+atan3(winpoint[i])/tau,1.));\n            col += winmetrics[i].z*hsv2rgb(vec3(angle,1.,scoreWhiteBalance));\n        }\n        //*/\n        \n        // polar coordinates of winning point, with score brightness, distance saturation\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            float angle = 2.*(-0.5+mod(0.5+atan3(winpoint[i])/tau,1.));\n            col += winmetrics[i].z*hsv2rgb(vec3(angle,1./(max(1.,winmetrics[i].x)),scoreWhiteBalance*(.5+.5/(max(1.,winmetrics[i].x)))));\n        }\n        //*/\n\n        // error and distance information from each note,\n        // error=hue red-green-blue (0 to 2/3)\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            float errhue = 2./3.*min(1.,max(0.,.5+.1*winmetrics[i].w));\n            col += pow(winmetrics[i].z,0.4)*hsv2rgb(vec3(errhue,2./(max(1.,winmetrics[i].x)),scoreWhiteBalance*(.5+.5/(max(1.,winmetrics[i].x)))));\n        }\n        //*/\n        // error=hue red-green-blue (0 to 2/3), distance=saturation \n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            float errhue = 2./3.*min(1.,max(0.,.5+.5*winmetrics[i].w));\n            col += pow(winmetrics[i].z,0.5)*hsv2rgb(vec3(errhue,1./(max(1.,winmetrics[i].x)),scoreWhiteBalance*(.5+.5/(max(1.,winmetrics[i].x)))));\n        }\n        //*/\n        // (/j) total error=hue red-green-blue (0 to 2/3)\n        /*\n        col = vec3(0.,0.,0.);\n        float errhue = 0.;\n        for (int i=0;i<uniqueScaleDegrees;i++) {\n            errhue += 2./3.*min(1.,max(0.,.5+.5*winmetrics[i].w));\n        }\n        col = hsv2rgb(vec3(errhue,1.,1.));\n        //*/\n        \n        // 10 cent range\n        /*\n        for (int i=0;i<uniqueScaleDegrees;i+=1) {\n            vec3 tempcol=scaleColors[i];\n            if (abs(winmetrics[i].y-9.5)<=.5) {\n                col += tempcol*.4;\n            }\n            if (winmetrics[i].y<=10.) {\n                col += tempcol*.2;\n            }\n            if (winmetrics[i].y<=squareSizeRep/200.) {\n                col += tempcol*.8;\n            }\n        }\n        //*/\n\n        // 10 cent glowing border\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=1;i<uniqueScaleDegrees;i+=1) {\n            vec3 tempcol=scaleColors[i];\n\n            col += .5*tempcol*(winmetrics[i].y*.5+.5)*.1*(.5-sign(winmetrics[i].y-10.)*.5);\n\n        }\n        //*/\n        \n        // 5 cent glowing border\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=1;i<uniqueScaleDegrees;i+=1) {\n            vec3 tempcol=scaleColors[i];\n\n            col += .4*tempcol*winmetrics[i].y*.2*(.5-sign(winmetrics[i].y-5.)*.5);\n\n        }\n        //*/\n        \n        // 1 cent glowing border\n        /*\n        col = vec3(0.,0.,0.);\n        for (int i=1;i<uniqueScaleDegrees;i+=1) {\n            vec3 tempcol=scaleColors[i];\n\n            col += .5*tempcol*winmetrics[i].y*(.5-sign(winmetrics[i].y-1.)*.5);\n\n        }\n        //*/\n\n        // mod cents lines\n        /*\n        //col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i+=1) {\n            vec3 tempcol=scaleColors[i];\n\n            col += .9*tempcol*(.1+.9/(1.+winmetrics[i].y)*mod(-winmetrics[i].y,1.));\n\n        }\n        //*/\n        \n        // cents boundary cents lines\n        /*\n        //col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i+=1) {\n            if (winmetrics[i].y < 5.) {\n                vec3 tempcol=scaleColors[i];\n\n                col += .5*tempcol*(1./(1.+.1*winmetrics[i].y)*max(0.,1.-8.*abs(mod(winmetrics[i].w+.5,1.)-.5)));\n            }\n        }\n        //*/\n\n        // striped cents lines\n        /*\n        //col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i+=1) {\n            vec3 tempcol=scaleColors[i];\n\n            col += .5*tempcol*pow(max(0.,1.-winmetrics[i].y/10.),2.)*(round(mod(-winmetrics[i].y/1.,1.)));\n\n        }\n        //*/\n        // signed cents lines\n        /*\n        //col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i+=1) {\n            if (winmetrics[i].y < 10.) {\n                vec3 tempcol=scaleColors[i];\n\n                col += .5*tempcol*pow(max(0.,1.-winmetrics[i].y/16.),2.)*(round(mod(-winmetrics[i].w/1.,1.)));\n            }\n        }\n        //*/\n        // bigger signed cents lines\n        /*\n        //col = vec3(0.,0.,0.);\n        for (int i=0;i<uniqueScaleDegrees;i+=1) {\n            if (winmetrics[i].y < 12.) {\n                vec3 tempcol=scaleColors[i];\n\n                col += .5*tempcol*pow(max(0.,1.-winmetrics[i].y/20.),2.)*(round(mod(-.5*winmetrics[i].w/1.,1.)));\n            }\n        }\n        //*/\n        \n        // 10 cent glowing border with 2 cent boundary lines\n        //*\n        col = vec3(0.,0.,0.);\n        for (int i=1;i<uniqueScaleDegrees;i+=1) {\n            if (winmetrics[i].y < 10.) {\n                vec3 tempcol=scaleColors[i];\n                col += .4*tempcol*winmetrics[i].y*.1*(.5-sign(winmetrics[i].y-10.)*.5);\n                col += .5*tempcol*(1./(1.+.1*winmetrics[i].y)*max(0.,1.-8.*abs(mod(winmetrics[i].w/2.+.5,1.)-.5)));\n            }\n        }\n        //*/\n        \n        \n        //col = vec3(1.,1.,1.);\n\n        // exact subcent perfectness lines\n        //*\n        if (zoom > 2.*originalN) {\n            vec3 tempcol = vec3(0.,0.,0.);\n            float paintN = 0.15;\n            for (int i=0;i<uniqueScaleDegrees;i++) {\n                if (winmetrics[i].y < 6.) {\n                    if (onLine[i]) {\n                        tempcol = scaleColors[i];\n                        paintN+=.5;\n                    } else if (onBorder[i]) {\n                        paintN+=.2;\n                    }\n                }\n            }\n            if (paintN>0.3) {\n                normal = 1.-(1.-1.*2.*originalN/zoom);\n                col = col*normal+(1.-normal)*(tempcol/paintN);\n            }\n        }\n        //*/\n        \n        \n        // sum of plain best error\n        //col = vec3(1.,1.,1.);\n        vec3 colmask = vec3(1.,1.,1.);\n        //*\n        //col = vec3(0.,0.,0.);\n        for (int i=1;i<uniqueScaleDegrees;i++) {\n            //vec3 w = vec3(1.,1.,1.)/float(uniqueScaleDegrees);\n            //col += w*1.-(.1*max(0.,winmetrics[i].y-10.));\n            vec3 w = vec3(1.,1.,1.);\n            colmask *= w*max(0.,(1.-(0.1*max(0.,winmetrics[i].y-5.))));\n        }\n        //*/\n        col *= .5;\n        col += .5*colmask;\n    \n    } // !eDisablePipelines\n    \n    //*\n    if (eGridToggle) {\n        // semitone grid\n        normal = (min(abs(mod(cents.x*.01+.5,1.)-.5),abs(mod(cents.y*.01+.5,1.)-.5)))/(.02*pixelvalue);\n        if (zoom > 1. && normal<1.) {\n            normal = 1.-.7*(1.-normal)*(1.-1./zoom);\n            col = col*normal+(1.-normal)*vec3(1.-col.x,1.-col.y,1.-col.z);\n        } else {\n        // decacent / dodecitone grid\n        normal = (min(abs(mod(cents.x*.1+.5,1.)-.5),abs(mod(cents.y*.1+.5,1.)-.5)))/(.16*pixelvalue);\n        if (zoom > 2.9 && normal<1.) {\n            normal = 1.-.7*(1.-normal)*(1.-2.9/zoom);\n            col = col*normal+(1.-normal)*vec3(1.-col.x,1.-col.y,1.-col.z);\n        } else {\n        // cent grid\n        normal = (min(abs(mod(cents.x+.5,1.)-.5),abs(mod(cents.y+.5,1.)-.5)))/(1.5*pixelvalue);\n        if (zoom > 29. && normal<1.) {\n            normal = 1.-.7*(1.-normal)*(1.-29./zoom);\n            col = (col*normal+(1.-normal)*2.*vec3(1.-col.x,1.-col.y,1.-col.z));\n        } else {\n        // decicent grid\n        normal = (min(abs(mod(cents.x*10.+.5,1.)-.5),abs(mod(cents.y*10.+.5,1.)-.5)))/(12.*pixelvalue);\n        if (zoom > 290. && normal<1.) {\n            normal = 1.-.7*(1.-normal)*(1.-290./zoom);\n            col = (col*normal+(1.-normal)*2.*vec3(1.-col.x,1.-col.y,1.-col.z));\n        } else {\n        // centicent grid\n        normal = (min(abs(mod(cents.x*100.+.5,1.)-.5),abs(mod(cents.y*100.+.5,1.)-.5)))/(120.*pixelvalue);\n        if (zoom > 1900. && normal<1.) {\n            normal = 1.-.7*(1.-normal)*(1.-2900./zoom);\n            col = (col*normal+(1.-normal)*2.*vec3(1.-col.x,1.-col.y,1.-col.z));\n        } // centi\n        } // deci\n        } // cent\n        } // deca\n        } // semitone\n    }\n    //*/\n    \n    // crosshair\n    //*\n    // square crosshair version\n    //if (abs(max(abs(frag.x-.5),abs(frag.y-.5))-.008)<.002) {\n    //    col = 0.2*(col*3.+vec3(1.-col.x,1.-col.y,1.-col.z));\n    //}\n    if (eCHToggle) {\n        if (abs(length(frag-vec2(.5,.5))-.008)<.002) {\n            col = 0.1*(col*3.+vec3(1.-col.x,1.-col.y,1.-col.z));\n        }\n        else if (max(abs(frag.x-.5),abs(frag.y-.5))<.002) {\n            col += vec3(.9,.9,.9);\n        }\n    }\n    //*/\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n    return fragColor;\n}","name":"Buffer B","description":"","type":"buffer"}]}