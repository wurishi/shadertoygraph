{"ver":"0.1","info":{"id":"dlSfWw","date":"1694099081","viewed":59,"name":"Reuleaux_Tetrahedron","username":"gPlatl","description":"Was searching for the algebraic surface definition of a Reuleaux Tetrahedron.\nCould not find anything suitable. \nHope the figure is implemented correctly.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","math","spheres","star","tetrahedron","surface","shape","algebraic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://shadertoy.com/view/mt2fR1\n//------------------------------------------\n// Reuleaux_Tetrahedron.glsl      \n//  an intersection shape of 4 spheres\n//   v1.0  2023-09-07  initial release\n//   v1.1  2023-09-08  pattern added\n// tags:  3d, math, spheres, star, shape\n//        algebraic, surface, tetrahedron\n//------------------------------------------\n\nconst vec3 color1 = vec3(.3, .3, .5);\n\nvec2 rotate(vec2 a, float b)\n{\n  float cb = cos(b), sb = sin(b);\n  return vec2(a.x * cb - a.y * sb,\n              a.x * sb + a.y * cb);\n}\n\nfloat sdTetrahedron(vec3 p)\n{\n  return (max(abs(p.x+p.y)-p.z, abs(p.x-p.y)+p.z)-1.)/sqrt(3.);\n}\n\nfloat sdTetrahedronStar(vec3 p)\n{\n  return (min(max(abs(p.x+p.y)-p.z,abs(p.y-p.x)+p.z),\n              max(abs(p.x+p.y)+p.z,abs(p.y-p.x)-p.z)\n             ) -1.) / sqrt(3.);\n}\n\nfloat sq(float x)   { return x*x; }\n\nfloat sdReuleauxTetrahedron (vec3 pos, float s)\n{\n  float a = 0.5,  r = 1.0;\n  float x1 = sq(pos.x-a), x2 = sq(pos.x+a);\n  float y1 = sq(pos.y-a), y2 = sq(pos.y+a);\n  float z1 = sq(pos.z-a), z2 = sq(pos.z+a);\n   \n  return sqrt(max(max(x1+y1+z1-r, x2+y2+z1-r)\n                , max(x1+y2+z2-r, x2+y1+z2-r))) -s;\n}\n\nfloat scene(vec3 p)\n{\n  return sdReuleauxTetrahedron (p, 1.5);\n  //return sdTetrahedronStar(p);\n  //return sdTetrahedron(p);\n}\n\nvec3 pattern( in vec2 uv )\n{\n  return vec3(0.6 + 0.4*smoothstep(-0.01,0.01\n             ,cos(uv.x*0.5)*cos(uv.y*0.5)))\n              * smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98\n             ,cos(uv.y));\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n  float t;\n  for(int i = 0; i < 100; ++i)\n  {\n    float k = scene(cam+dir*t);\n    t += k;\n    if (k < .001)\n    {\n      vec3 h = cam+dir*t;\n      vec2 o = vec2(.001, 0);\n   \t  vec3 n = normalize(vec3(\n      scene(h+o.xyy)-scene(h-o.xyy),\n      scene(h+o.yxy)-scene(h-o.yxy),\n      scene(h+o.yyx)-scene(h-o.yyx)));\n\n\t  if (iMouse.z > 0.5)   // mouse button pressed ?\n      {\n        const vec3 lightdir = normalize(vec3(1,5,2));\n        float light = dot(n,lightdir)+.14;\n        vec2 patternScale = vec2(24.0, 64.0);\n        return 0.2*light \n          + 0.5*pattern (patternScale*vec2(atan(h.y,h.x),h.z));\n      }\n      else return n*.55+.5;\n    }\n  }\n  return vec3(1);\n}\n\nvoid cameraSpin(inout vec3 p)\n{\n    p.xy = rotate(p.xy, iTime*.6);\n    p.yz = rotate(p.yz, iTime*.5);\n    p.xz = rotate(p.xz, iTime*.1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = (fragCoord -0.5*iResolution.xy) / iResolution.y;\n  vec3 dir = normalize(vec3(uv,4));\n  vec3 cam = vec3(0,0,-15.);\n  cameraSpin(cam);\n  cameraSpin(dir);\n\n  out_color.rgb = trace(cam,dir);\n  out_color.rgb *= pow(color1, vec3(2.*dot(uv,uv)));\n  out_color.rgb = pow(out_color.rgb,vec3(.45));\n}","name":"Image","description":"","type":"image"}]}