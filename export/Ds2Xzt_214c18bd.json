{"ver":"0.1","info":{"id":"Ds2Xzt","date":"1670736573","viewed":182,"name":"3D Fractal v6.75","username":"skintigh","description":"Drag mouse interface to rotate fractal. \nUse \"Presets\" slider to select different values, slide all the way to the left to manually adjust the other 4 sliders again.\nPress C for color changes\nP for color palette, G for gradient\n\n","likes":12,"published":1,"flags":48,"usePreview":1,"tags":["fractal"],"hasliked":0,"parentid":"Dd2Xzt","parentname":"3D Fractal V6.7"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////////\n//\n// Click and drag to move the fractal around\n// Press C to change color presets (which consist of a palette and color gradient)\n//   (You can also press P to change color palette and G to change the color gradient)\n//\n// Running slow? In a 800x450 window I get \n//    10.1 FPS when the browser is using the Intel on-chip GPU, \n//    60.0 FPS (the max possible for this display) when using the Nvidia GPU\n//\n// One of my computers used the GPU automatically, the other made me jump through hoops:\n//\n// Chrome:\n// If you have a GPU (and you want to use is for more speed/FPS)\n// you must edit graphics preferences in windows to make chrome use GPU\n// or this may run very slowly. See: https://www.amd.com/en/support/kb/faq/gpu-110\n// I think you also have to change Chrome grpahics settings, see:\n//     chrome://flags/#use-angle \n// must(?) set to OpenGL then go here and chect that it ignored you anyway under GL_RENDERER\n// \n// All on Windows:\n// You MUST set Windows \"Graphics Settings\" for the browser program to use the GPU\n// Then click ...->Exit in the browser to truly close it, then restart browser\n// \n// NVIDIA:\n// You might need to set NVIDIA Settings app to use the GPU in Chromem, but settings \n// in it are apparently ignored on my computer. \n//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n// 2 options you may change (then recompile, and then rewind):\n//#define animate_zoom //zoom to show fractalocityness\n//#define animate_shapes //sweep through numerous power2 shapes while rotating\n\n//fog options:\n//#define faintfog\n//#define fog2\n//#define fog3 // thickish fog\n\n// this is a work in progress, still experimenting with a lot of math and color schemes\n// pardon the hideous code.\n\n\nfloat SHININESS;\nfloat SHINE_MIX;\n\n//const int MAX_RAY_STEPS= 4*1000; // 55fps with 3*1000 40 with 4*1000\nconst int MAX_RAY_STEPS= 3*850;  // computation depth essentially. \n// 3*850 not enough for def at 0.40 z, nor 3000. 4000 works 56.7 FPS z+2.0. or issue with back wall?\n//default: 3*850 18z 40 FPS, 3*850 8 52.7 FPS, 3*850 5 57.3 FPS\nfloat clip_far = 5.0;  //max depth to draw. Greatly affects speed. Includes eye_z\n#define MAX_DEPTH_FUNCTION clip_far = eye_z + 2.4;\n//3*850 z+2 56.7 FPS so 0.6 FPS hit for +2.0\n// 4*1000 56.2 or .3 for z+2.4  3*850 z+2.4 56.5 FPS\n\n//maybe I need a min depth?! but clip at eye?\nconst float MIN_DEPTH = 2.4;\n// +2 works with def, preset 1, 3, 4, 5 6 7 8 9 10 ...all\n// eats last lobe with preset 2 \"spires\"\n\nconst float grad_step = 0.005;  //0.1 loses some detail 0.02 was default, 0.001 speckle, 0.005 kinda spec in small window\nconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\nconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\nconst vec3 dz = vec3( 0.0, 0.0, grad_step );\nconst vec3 delta_LUT[6] = vec3[6](dx, -dx, dy, -dy, dz, -dz);\n   \nfloat color_step = 0.02; //0.02 big patterns 0.2 bifur on skull spire boring 0.01 blob babies have coloring 0.0001 blob looks amazing but speckly  0.001 skull great up close but speckly far\n\nconst vec3 ddx2 = vec3( 1.0, 0.0, 0.0 );\nconst vec3 ddy2 = vec3( 0.0, 1.0, 0.0 );\nconst vec3 ddz2 = vec3( 0.0, 0.0, 1.0 );   \nconst vec3 color_delta_LUT_1[6] = vec3[6](ddx2, -ddx2, ddy2, -ddy2, ddz2, -ddz2);\n\n\n\n\n\nfloat frac_dist_2(vec3 f, inout bool hit, inout float dist) //returns distance\n{       \n    float sum;  \n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                f = vec3( Q*f.x*f.z + f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x + zz);\n                \n                //sum = abs(f[0]) + abs(f[1]) + abs(f[2]); //way faster approx but needs higher thresh, loses detail 42.5 fps when > 8. 45.8 fps > 4  11fps faster when >2 but details lost\n                // it also lengthens appendages in ^4\n                sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return sum;//  -1?0.0; // not in fractal  \n                }\n            }\n\n    // if I never exceeded threshold, I am in part of the fractal.\n    // n = max (or random depending on compiler?) sum will always be 0..2\n    hit = true;\n    dist = 0.;\n    return sum;\n}\n\n\n\n\nfloat frac_dist_3(vec3 f, inout bool hit, inout float dist) //returns distance\n{       \n    float sum;  \n        //case 3: // cubed\n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                f = vec3( Q*f.x*f.z + f.y*f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x*f.x + zz);\n                //5th\n                //f = vec3( Q*f.x*f.z + f.y*f.y*f.y*f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z*f.z*f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x*f.x*f.x*f.x + zz);\n                // assymetric. odd power can require more iters due to negative numbers\n                //f = vec3( Q*f.x*f.z + pow(abs(f.y),3.) + zz,   Q*f.x*f.y + pow(abs(f.z),3.) + zz,Q*f.y*f.z + pow(abs(f.x),3.) + zz);    \n                //symmetric. pow goes haywire with negative numbers\n                sum = length(f);\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return 0.0; // not in fractal \n                }\n            }             \n     // if I never exceeded threshold, I am in part of the fractal.\n    // n = max (or random depending on compiler?) sum will always be 0..2\n    hit = true;\n    dist = 0.;\n    return sum;\n}\n\n           \n            \n            \n//split into subfuncs for cleaner code? or will there be a speed hit? maybe return sum -1 for miss?\nfloat frac_dist(vec3 f, inout bool hit, inout float dist) //returns distance\n{       \n    float sum;  \n    switch(POWER)  //it's actually faster to use a switch than to hardcode a case. How???\n    {\n    \n        // 7.5s with 7.2 w/o\n        case 1://only shape i see at off 0.45 mult 4.46, mi 13 \n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n\n                f = vec3( Q*f.x*f.z + f.y + zz,  Q*f.x*f.y + f.z + zz,  Q*f.y*f.z + f.x + zz);  //22 0.33 +/-\n                //f = vec3( Q*f.x*f.z + f.y + zz,  Q*f.x*f.y + f.z + zz,  Q*f.y*f.z + f.x + zz);  //22 0.33 +/-\n                //f = vec3( Q*f.x*f.z + pow(abs(f.y),1.) + zz,   Q*f.x*f.y + pow(abs(f.z),1.) + zz,Q*f.y*f.z + pow(abs(f.x),1.) + zz);    \n                //some nead shapes, some like case 2, assymetric in one dir\n                sum = length(f); \n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return 0.0; // not in fractal\n                }\n            }\n            break;\n            \n        /* \n        case 2: //original math\n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                //orig\n                f = vec3( Q*f.x*f.z + f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x + zz);\n                \n                //sum = abs(f[0]) + abs(f[1]) + abs(f[2]); //way faster approx but needs higher thresh, loses detail 42.5 fps when > 8. 45.8 fps > 4  11fps faster when >2 but details lost\n                // it also lengthens appendages in ^4\n                sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return sum;//  -1?0.0; // not in fractal  \n                }\n            }\n            break;\n     *       \n        case 3: // cubed\n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                f = vec3( Q*f.x*f.z + f.y*f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x*f.x + zz);\n                //5th\n                //f = vec3( Q*f.x*f.z + f.y*f.y*f.y*f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z*f.z*f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x*f.x*f.x*f.x + zz);\n                // assymetric. odd power can require more iters due to negative numbers\n                //f = vec3( Q*f.x*f.z + pow(abs(f.y),3.) + zz,   Q*f.x*f.y + pow(abs(f.z),3.) + zz,Q*f.y*f.z + pow(abs(f.x),3.) + zz);    \n                //symmetric. pow goes haywire with negative numbers\n                sum = length(f);\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return 0.0; // not in fractal \n                }\n            }  \n            break;\n        */    \n        case 4: // 4th power\n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                f = vec3( Q*f.x*f.z + f.y*f.y*f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z*f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x*f.x*f.x + zz);\n                sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return 0.0; // not in fractal \n                }\n            }\n            break;\n            \n        case 5:     // power 2 plus power 3 for bonus crazy\n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                //f = vec3( Q*f.x*f.z + pow(abs(f.y),qwe) + zz,   \n                //          Q*f.x*f.y + pow(abs(f.z),qwe) + zz,\n                //          Q*f.y*f.z + pow(abs(f.x),qwe) + zz);\n                //boringf = vec3( Q*f.x*f.z + f.y*f.y + pow(abs(f.y),3.) + zz,  Q*f.x*f.y + f.z*f.z + pow(abs(f.z),3.) + zz,  Q*f.y*f.z + f.x*f.x+ pow(abs(f.x),3.) + zz);\n                f = vec3( Q*f.x*f.z + f.y*f.y*f.y + f.y*f.y + zz,  Q*f.x*f.y + f.z*f.z*f.z + f.z*f.z + zz,  Q*f.y*f.z + f.x*f.x*f.x + f.x*f.x + zz);\n                sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return 0.0; // not in fractal \n                }\n            }\n            break;\n            \n        case 6:                                         // weird, lumpy spirals\n            for (int n=0; n<MAX_FRAC_STEPS; n++)\n            {\n                f = vec3( Q*f.x*f.z +   f.y*f.y + zz,   \n                          Q* f.x*f.x + f.y*f.z + zz, \n                          Q*f.x*f.y +   f.z*f.z + zz);                  \n                sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n                if (sum > 2.)\n                {\n                    DIST_FUNC\n                    hit = false;\n                    return 0.0; // not in fractal \n                }\n            }\n            break;\n    }\n    \n    // if I never exceeded threshold, I am in part of the fractal.\n    // n = max (or random depending on compiler?) sum will always be 0..2\n    hit = true;\n    dist = 0.;\n    return sum;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// color palettes\n//////////////////////////////////////////////////////////////////////\nvec3 rainbow( in float t)// darkest is purple at pi?\n{\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.25,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.33,0.67);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n//math for other color palettes, faster to merge maybe?\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 partial_spectrum(in float t)\n{\n    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n}\n\nvec3 new_color(in float t) // black at pi   pink and cyan not the best\n{                        //a minimum          b mult        c tmult         d t offset\n    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n}\n\nvec3 new_color2(in float t) // black at pi   pink and cyan not the best\n{                        //a minimum          b mult        c tmult 0.01=100?            d t offset or inverse? 1 same as 0\n    return pal( t, vec3(0.00,0.00,0.00),vec3(1.00,1.00,1.00),vec3(0.18 ,1.0,1.),vec3(0.900, 0.25, 0.50) );\n}\n\nvec3 new_color3(in float t) // black at pi   pink and cyan not the best\n{                        //a minimum          b mult        c tmult 0.01=100?            d t offset or inverse? 1 same as 0\n    return pal( t, vec3(0.4,0.4,0.4),vec3(1.00,1.00,1.00),vec3(0.22,1.0,1.),vec3(0.750, 0.25, 0.50));\n}\n\n//////////////////////////////////////////////////////////////////////\n// reflections\n//////////////////////////////////////////////////////////////////////\n\nvec3 gradient_dist( vec3 pos ) { //calc reflect and color\n    bool  hit;\n    float v[6];\n    float dist[6];\n    for( int i=ZERO; i<6; i++ )\n        if ( POWER == 2)       v[i] = frac_dist_2( pos + delta_LUT[i], hit, dist[i]);\n        else if ( POWER == 3)  v[i] = frac_dist_3( pos + delta_LUT[i], hit, dist[i]);\n        else v[i] = frac_dist( pos + delta_LUT[i], hit, dist[i]);\n  \n\treturn normalize ( vec3(dist[0] - dist[1], dist[2] - dist[3], dist[4] - dist[5]) );\n}\n\nvec3 gradient_color_dist2(vec3 pos, inout vec3 color, float tin)//reflect and color from sums\n{\n    bool  hit;\n    \n    //first compute the reflection vector\n    // returns distance to v0, will always be 0..<2.  a-f can be larger    \n    float v[9];\n    float dist[9];\n       \n    for( int i=ZERO; i<6; i++ )\n        if ( POWER == 2)       v[i] = frac_dist_2( pos + delta_LUT[i], hit, dist[i]);\n        else if ( POWER == 3)  v[i] = frac_dist_3( pos + delta_LUT[i], hit, dist[i]);\n        else v[i] = frac_dist( pos + delta_LUT[i], hit, dist[i]);\n  \n\tvec3 n = normalize ( vec3(dist[0] - dist[1], dist[2] - dist[3], dist[4] - dist[5]) );    \n    \n    float v0,v1,v2,v3,v4,v5, v6, v7, v8 ;\n    \n    if ((AA_SET >= 2))//&&(AA_SET < 12))  //cube faces with color gradient\n    {\n        for( int i=ZERO; i<6; i++ )\n        if      ( POWER == 2) v[i] = frac_dist_2(pos + color_step*color_delta_LUT_1[i], hit, dist[i]);\n        else if ( POWER == 3) v[i] = frac_dist_3(pos + color_step*color_delta_LUT_1[i], hit, dist[i]);\n        else                  v[i] = frac_dist(pos + color_step*color_delta_LUT_1[i], hit, dist[i]);\n    }\n    // try corners of cube \n    \n    \n    switch (AA_SET)\n    {\n        //reuse gradient on cube faces\n        case 0: tin = (v0 + v1 + v2 + v3 + v4 + v5 ) / 6.0;\n        break;\n        case 1: tin = (v0 + v1 + v2 + v3 + v4 + v5 + tin) / 7.0; \n        break;\n\n        //use color step on cube faces\n        case 2: tin = (v0 + v1 + v2 + v3 + v4 + v5 ) / 6.0; // blue green, some speckles        \n        break;\n        case 3: tin = (v0 + v1 + v2 + v3 + v4 + v5 + tin) / 7.0; // bright, pinker speckly\n        break;\n        case 4: tin = (v0 + v1 + v2 + v3  ) / 4.0; // dark... asymetric\n        break;\n        case 5: tin = (v0 + v1 + v2 + v3 +tin  ) / 5.0; // brighter, purply, too speckly\n        break;\n        //case 6: tin = (a+b+c+d+e+f)/6.0;//using dist, very sensitive, too much? \n        case 6: tin = (dist[0]+dist[1]+dist[2]+dist[3]+dist[4]+dist[5])/6.0;//using dist, very sensitive, too much? \n\n        break;\n            //these were better when accidentally avg twice\n        //case 7:tin = (a+b+c+d+e+f+tin)/7.0/10.; //neat, colors like orig mandelbrot\n        case 7:tin = (dist[0]+dist[1]+dist[2]+dist[3]+dist[4]+dist[5]+tin)/7.0/10.; //neat, colors like orig mandelbrot\n        break;\n        //case 8: tin = (a+b+c+d+e+f+tin)/7.0/20.; //neat,  calmer too cool\n        case 8: tin = (dist[0]+dist[1]+dist[2]+dist[3]+dist[4]+dist[5]+tin)/7.0/20.; //neat,  calmer too cool\n        break;\n        //case 9: tin = (a+b+c+d+e+f+tin)/7.0/float(MAX_FRAC_STEPS)*8.; //neat, rainbowy, crazy\n        case 9: tin = (dist[0]+dist[1]+dist[2]+dist[3]+dist[4]+dist[5]+tin)/7.0/float(MAX_FRAC_STEPS)*8.; //neat, rainbowy, crazy\n        break;\n\n        //I'm using 6 pixels, the centers of the faces of a cube of vol 27\n        //AA was using 9 pixels from normal plane\n\n        //case 12: tin = (v0 + v1 + v2 + v3 + v4 + v5 + v6 +v7 +v8 ) / 9.0;    //pretends to be AA, but it's assymetric, neat veins on skull- blob\n        //break;\n    }\n\n\n    switch (COL_SET)\n    {\n        case 1: color = new_color3(PI*tin + PI);  // skull blob C nice  brighter than below, \n        break;\n        case 2: color = partial_spectrum(PI*tin/2. + PI);//was +3PI/2\n        break;\n        case 3: color = partial_spectrum(PI*tin + PI);//was +3PI/2\n        break;\n          \n        case 4: //color = rainbow(PI*tin/2. + 1.33*PI); //was -PI/4  purple edge\n                //color = rainbow(PI*tin/2. - 0.25*PI);// about the same, brighter?\n                color = rainbow(PI*tin    - 0.25*PI);// too busy?\n        break;\n        case 5: color = new_color3(1.*pow(tin+1. ,2.0)+ 3.14-1.);  //kinda boring but I like it\n                //very similar to 1\n        break;\n        \n        //cant get here\n        case 6: color =new_color3(0.5*  log(tin) ); //sometimes speckly but i like it\n                //color =rainbow(3.14+log(tin));// + -1.* 3.14/4. ); //looks like bad icecream, too busy for many\n                //color =rainbow(10.*log(tin+1.));// + -1.* 3.14/4. ); //looks like bad icecream\n                //must add inside log or mostly black? true for dist?\n         break;\n    }\n    \n    //todo test:\n    \n    //color =partial_spectrum(100.*  log(color_t+0.1) );\n    //color_t = max(color_t,0.);  //does nothing, min dist is 0\n    //color_t = max(color_t,0.1); //this changes the black only\n    \n    //color =new_color3(0.5*  log(color_t) ); //too much\n    return n;\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n// ray marching\n//////////////////////////////////////////////////////////////////////\n\n// o is location of ?\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n, inout vec3 col ) {\n    //adjust t to mid depth?\n    float t =0.;\n    bool hit = false;\n    float sum;\n    float dist, min_dist=999.;\n    for ( int i = 0; i < MAX_RAY_STEPS; i++ ) {  //i was 128, is distance z to compute shape?\n        vec3 v = o + dir * t; //actually faster than incemental!\n        if      (POWER==2) sum = frac_dist_2( v, hit, dist );\n        else if (POWER==3) sum = frac_dist_3( v, hit, dist );\n        else               sum = frac_dist( v, hit, dist );  //returns sum, hit, distance is 0 for hit, .125  to .125+(max-n)/2\n        min_dist = min(dist, min_dist);\n        if (( t > depth ) || ( hit)) // if I hit the fractal or the back wall\n            break;\n        t += RAY_STEP*dist;\n    }\n    \n   \n    if(COL_SET == 6) //Buddhabrot/Ganesh/Melinda Green. misses are used here too\n    {\n        float lum;\n        SHININESS = 5.0; // too much shine ruins the effect\n        SHINE_MIX = 0.6; // .25 cloudy  .5 kinda is too, the 3 colors are equally bright. not always\n        n = gradient_dist( o + dir * t); //sum is 0..2, dist for miss almost always max at back wall.\n        // dist is 0.125 + 0.5 * float( (MAX_FRAC_STEPS-n)*(MAX_FRAC_STEPS-n))/float(MAX_FRAC_STEPS) ; \n        // 0 for hit. for misss: return a minimum of .125\n        //dist max is .125+0.5*max_steps   The more steps it made, the closer it was so smaller distance \n        \n        if (hit) lum = 0.;\n        else  lum = (min_dist - 0.125)*2.0/float(MAX_FRAC_STEPS); // lum 0 closest 1 farthest\n        col=mix(vec3(0,0,0), col, 1.-lum*lum);   //lower fade, auras\n        return true;\n    }\n\n\n    //if no hit then pos is likely at back wall, dist is max, sum is > thresh(2)\n    if (!hit) return false; //tells shader to draw background if I didn't hit fractal\n\n    depth = t; //returns this\n    \n    if (COL_SET == 0) // if no color used\n        {\n        SHININESS = 1.0; //1 brighter 100 darker\n        SHINE_MIX = 1.0; //no color so make it shiney like silver\n        // add reflection NO color\n        //n =( gradient( o + dir * t ) ); //frac v4 made it darker? only made sense with dist\n        //n = ( gradient_float_hits( o + dir * t ) );//this one is brighter, also faster!\n        n = gradient_dist( o + dir * t);//, col, sum ); //the gradient of this pixel\n    }\n    \n    else if (COL_SET > 0 && COL_SET != 6)\n    {\n        SHININESS = 1.0;  //1 brighter 100 darker\n        SHINE_MIX = 0.5; //amount of glare seen instead of color\n\n        // add reflection and \"smoothed\" color  dark+bandy on oct w/ 0.02 grad\n        //n = gradient_color( o + dir * t, col, sum ); //shine and smoother colors hair faster than above?!?!?\n        //a little more sensible, bandy on octo\n        //n = gradient_color_float_hits( o + dir * t, col, sum ); //same speed but uses float version, darker\n\n        //n = gradient_color_dist( o + dir * t, col ); //the gradient of this pixel\n\n        //n = gradient_color_dist( o + dir * t, col, sum );//29.1fps    14.9 uglyish\n        n = gradient_color_dist2( o + dir * t, col, sum ); //28.9       14.8\n        //(vec3 pos, inout vec3 color, float tin)\n    }\n\n    #ifdef fog2\n    col=mix(BKGD_COLOR, col, clamp((2.+eye_z)/(t*t),0.0,1.0));\n    #endif\n    \n    //depth, n, col are returned as well\n    return true;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n// UI and Main\n///////////////////////////////////////////////////////////////\n\n///read info stored as pixel. Combine with buffer 2?\nfloat uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Load values from saved state! Stored as pixels in Buffer B.\n    COL_SET = int( 10.* texelFetch( iChannel2, ivec2(200,0), 0 ).r   );   \n    AA_SET = int( AA_MULT * texelFetch( iChannel2, ivec2(201,0), 0 ).r   );   \n\n    //Old way: read a slider. Convert all?\n    POWER =  int(uiSlider(4));   \n    vec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy ); // default ray origin\n    #ifdef animate_zoom\n        zz = 0.41;\n        Q = -2.6;\n        MAX_FRAC_STEPS = 16;\n        eye_z = 2./ iTime/iTime/iTime + 0.145;\n        vec3 eye = vec3(0.2540645, 0.2540645, eye_z -0.51425); //not a very interesting spot...\n        color_step = 0.01 *eye_z / iTime / iTime; //0.02\n\n        SET_RAY_STEP\n        RAY_STEP /= iTime*log(iTime);\n    #else\n        #ifdef animate_shapes\n            //MAX_FRAC_STEPS = 36;\n            //zz = 0.7+0.72*sin(iTime/6.) - 0.34;\n            \n            //MAX_FRAC_STEPS = 24;   //not bad\n            //zz = 0.7+0.76*sin(iTime/17.) - 0.36;\n\n\n            MAX_FRAC_STEPS = 20;   //not bad\n            zz = 0.7+0.76*sin(iTime/17.) - 0.36;\n            \n            //MAX_FRAC_STEPS = 16;\n            //zz = 0.9 + 0.80*sin(iTime/8.) - 0.55;\n            Q = -2.;\n            eye_z = 3.75;\n            SET_RAY_STEP\n            vec3 eye = vec3(0., 0., eye_z  ); //limb\n            mat3 rot = rotationXY( 10.*iTime * vec2( 0.01, 0.01 ) );\n            dir = rot * dir; //need to do this to keep it in center\n            eye = rot * eye;\n        #else\n            zz = uiSlider(0);\n            Q = -uiSlider(1);\n            eye_z  = uiSlider(2);\n\n            SET_RAY_STEP\n            if ((uiSlider(5) >= 12.)&&(uiSlider(5)<=14.)) RAY_STEP*=4.;\n            vec3 eye = vec3(0., 0., eye_z  ); //limb\n            MAX_FRAC_STEPS = int(uiSlider(3));\n\n        // rotate camera\n        if (iResolution.x < 400.){\n            mat3 rot = rotationXY((0.+iTime) * vec2( 0.05, -0.2 ) );\n            dir = rot * dir; //need to do this to keep it in center\n            eye = rot * eye;\n            COL_SET == 6;\n            POWER = 1 +int( \n                pow(\n                    float(\n                        int((float(POWER) + iTime/5.))%3\n                    )\n                , 2.0)\n            ); //1, 2 , 5\n        }\n        else if ((iMouse.x > float(BOX_WIDTH+BOX_OUTERMARGIN)) || (iMouse.y < (iResolution.y-(8. +NUM_SLIDERS)*float(BOX_OUTERMARGIN)) ) )\n        {\n            mat3 rot = rotationXY( 2.*( iMouse.xy*.25- iResolution.xy  ).yx * vec2( 0.01, 0.01 ) );\n            dir = rot * dir; //need to do this to keep it in center\n            eye = rot * eye;\n        }\n        #endif\n    #endif\n \n    dir = normalize(dir);\n    \n    MAX_DEPTH_FUNCTION\n    float depth = clip_far;\n    vec3 n = vec3( 0.0 );\n    vec3 color = vec3(0.,0.,0.);\n    \n    //negligible or negative improvement?\n    //if (eye_z > MIN_DEPTH)\n    //    eye = eye + dir*(eye_z-MIN_DEPTH); //51.2 with vs 51.0 without, 48.4to49.0 octo  25.9 vs 25.6 trillium 50.8 vs 50.9 zoomed out\n      \n      \n      \n      \n    //////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////\n    if (COL_SET == 6) \n    {\n        vec3 stepvec; //damnit now I need to save this as a state for preset 0...\n        //make vec4\n        int preset = int(uiSlider(5));   // using 39 with current settings (-25 0 1.5x 2x) looks great with crystaline\n        //could maybe double up all th colors.........\n        // -25 too much for curly, -20 is too?\n        switch(preset)\n        {\n            case 1: //curly\n            case 10: \n            case 15: //crys\n            stepvec = vec3(MAX_FRAC_STEPS-8,MAX_FRAC_STEPS+0,MAX_FRAC_STEPS+15);\n            break;            \n            case 3: //skull pretty good\n            case 6: //beeetle needs more extreme  9 dice too 12 lots more\n            case 7: //hairy bug  more also? ok??\n            stepvec = vec3(MAX_FRAC_STEPS+40,MAX_FRAC_STEPS+90,MAX_FRAC_STEPS+130);\n            break;\n            //4 mndblb  5c   8 spiky awesome  //10 dandy needs much less extreme //11 octo\n            //14 3rd donut\n            //default: stepvec = vec3(MAX_FRAC_STEPS-15, MAX_FRAC_STEPS*3/2, MAX_FRAC_STEPS*3/2+10);\n            default: stepvec = vec3(MAX_FRAC_STEPS*3/2+10+18, MAX_FRAC_STEPS*3/2, MAX_FRAC_STEPS );\n        }\n        float BKG = 0.;\n        vec3 FGD = vec3(1,1,1);        vec3 tempc = vec3(0.,0.,0.);\n        \n        \n        \n        \n        //compiles in 3.0-3.2s\n        /*\n        MAX_FRAC_STEPS = MAX_FRAC_STEPS - 18;\n \n        tempc = vec3(1,1,1);//much brighter\n        if (!ray_marching( eye, dir, depth, n, tempc)) //miss \n            color.b =  BKG;\n        else // hit\n            color.b = mix(tempc, shading(eye + dir * depth, n, dir, eye, SHININESS), SHINE_MIX).b; // add reflections\n\n \n        tempc = vec3(1,1,1);\n        depth = clip_far;\n        MAX_FRAC_STEPS = int(stepvec.y);\n        if ( !ray_marching( eye, dir, depth, n , tempc) )  //if didn't hit my object\n            color.g =  BKG;\n        else // it hit the fractal so shade away\n            color.g = mix(tempc, shading( eye + dir * depth, n, dir, eye, SHININESS), SHINE_MIX).g; // add reflections\n        \n        \n        tempc = vec3(1,1,1);\n        depth = clip_far;\n        MAX_FRAC_STEPS = int(stepvec.z);\n        if ( !ray_marching( eye, dir, depth, n , tempc) )  //if didn't hit my object\n            color.r =  BKG;\n        else // it hit the fractal so shade away\n            color.r = mix(tempc, shading(eye + dir * depth, n, dir, eye, SHININESS), SHINE_MIX).r; // add reflections\n        /**/   \n        \n        \n        \n        \n        //compiles in 1.8sec\n        for (int i=0; i<=2; i++){\n            tempc = vec3(1,1,1);//much brighter\n            depth = clip_far;\n            MAX_FRAC_STEPS = int(stepvec[i]);\n            if (!ray_marching( eye, dir, depth, n, tempc)) //miss \n                color[i] =  BKG;\n            else // hit\n                color[i] = mix(tempc, shading(eye + dir * depth, n, dir, eye, SHININESS), SHINE_MIX).b; // add reflections \n        }\n        /**/\n  } ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    \n    \n    \n    \n    \n    \n    \n    ////////// otherwise do normal raymarch\n\telse if ( !ray_marching( eye, dir, depth, n , color) )  //if didn't hit my object\n        color =  BKGD_COLOR;\n\telse // it hit the fractal so shade away\n    {\n        vec3 pos = eye + dir * depth;  //the position of the pixel in space\n        //n is the gradient of the pixel, dir is ray direction, eye is location of eye in space\n        \n        color = mix(color, shading( pos, n, dir, eye, SHININESS ), SHINE_MIX); // add reflections\n               \n        #ifdef fog3\n            //color = mix(BKGD_COLOR, color, clamp((dot(eye,pos)), 0.1 ,1.));//way too abrupt\n            //color = mix(BKGD_COLOR, color, clamp(1.-depth/4., 0.0 ,1.));//meh\n            color = mix(color, BKGD_COLOR, clamp(-0.2+log(depth), 0.0 ,1.));//meh\n        #endif\n\n        #ifdef faintfog\n            #ifdef rot\n                color = mix(color, BKGD_COLOR, clamp( 0.-0.5*(rot*pos).z , 0.0, 1.0) );\n            #else\n                color = mix(color, BKGD_COLOR, clamp( 0.-0.5*(pos).z , 0.0, 1.0) );\n            #endif\n        #endif\n\n    }\n    \n    //UI integration -- add the sliders if in normal mode\n    #if !defined(animate_zoom) && !defined(animate_shapes)\n     if (iResolution.x > 400.){ //hide menu in preview\n        vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n        color = mix(color, ui.rgb, ui.a*.3);  //place and fade the panel and sliders\n       }\n   #endif\n\n    fragColor = vec4( color, 0. );  // make vec4, this is what gets drawn\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this file alone takes 9.7-10 seconds to compile...\n\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\nint PRESET_SLIDER_ID = 5;\nint POWER_SLIDER_ID = 4;\n\n\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _lsl col += vec4( char(ch_lsl) );\n#define _lpa col += vec4( char(ch_lpa) );\n#define _rpa col += vec4( char(ch_rpa) );\n\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v,min_,max_,integer,clamp_) setCursor(x,y);print_slider(id,v,min_,max_,integer,clamp_);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n\nvoid setCursor(int x, int y)\n{\n    pos = vec2(float(x),iResolution.y-float(y));\n}\n\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);   //loop?\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\nfloat char(vec4 ch)\n{\n    float px = sprite(ch, vec2(8, 12), uv - pos);\n    pos.x += 8.;\n    return px;\n}\n\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return ch_0;\n}\n\nfloat print_float(float number)\n{\n    float result = 0.0;\n    if (number < 0.) \n    {\n        number = -number;\n        result += char(ch_dsh); //fix for neg\n    }\n    \n    for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 9.999); //fix for 0.09 problem\n        \n        if(i == -1)\n        {\n            result += char(ch_per);\n        }\n        \n        if((abs(number) > pow(10.0, float(i))) || i <= 0)\n        {\n            result += char(get_digit(digit));\n        }\n    } \n    return result;\n}\n\nfloat print_int(float number)\n{\n    float result = 0.0;\n    \n    for(int i = MAX_DIGIT;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) >= pow(10.0, float(i)) || i == 0) //fix to show 10 and not 0\n        {\n            result += char(get_digit(digit));\n        }\n    }   \n    return result;\n}\n\n\nvec3 widgetSelected()\n{\n    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;\n}\nvec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}\n\nfloat roundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    float d = (m.x > 0.0) ? length(q) : m.y; \n    return d - r;\n}\n\n\nvoid print_slider( int id, float v , float min_, float max_, bool integer, bool clamp_)\n{\n    vec2 puv = uv-vec2(.5);\n    vec3 select = widgetSelected();\n    float sl2 = SLIDER_LENGTHf/2.;\n    vec4 value = uiSlider(id);\n    if(value.a == 0.)\n        value.r = v;\n    \n    //Check if value changed\n    bool selected = ( select.r == .1 && select.g*255. == float(id) ); //???? button hold?\n    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.; \n    \n    \n    if(mouseAndNoSelect || selected){\n    \t//value.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTHf,0.,1.);  //???  breaks everything\n    \tvalue.g = (iMouse.x-pos.x-2.)/SLIDER_LENGTHf;\n        value.r = (max_-min_)*value.g + min_;\n        \n    }\n    \n    if( integer ){\n        value.r = floor(value.r);\n    }\n    \n    if( clamp_ ){\n        value.r = clamp(value.r,min_,max_);\n    }\n    \n    //value.g = 0.5;\n    value.g = clamp( (value.r - min_)/(max_ - min_) , 0. , 1. );\n    \n    \n    \n    //Draw slider\n    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,SLIDER_HEIGHTf), 5.);\n    float layer = clamp(sign(-d),0.,1.);\n    col.rgb += vec3((clamp( 1.6-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.g*SLIDER_LENGTHf))*.5 );\n\n\n//vec4 uiSlider(int id){return texture(iChan nel0, vec2(float(id)+.5,0.5)/iResolution.xy);}\n    if ( (id==PRESET_SLIDER_ID) || (uiSlider(PRESET_SLIDER_ID).r < 1.))// || (id==POWER_SLIDER_ID))\n        col.rgb += WIDGET_COLOR*vec3( clamp( 1.5-abs(d)*1.5 , 0., 1.) );\n    else\n        col.rgb += WIDGET_COLOR_LOCKED*vec3( clamp( 1.5-abs(d)*1.5 , 0., 1.) );\n    col.a += layer + clamp( 1.-abs(d) , 0., 1.);\n    \n    //Draw value\n    float oldx = pos.x;\n    bool touch = false;\n    \n    if (id!=PRESET_SLIDER_ID)\n        {\n        pos.x += SLIDER_LENGTHf-12.*4.;\n       \n        //uiSlider(4).r = 0;\n        //vec4 valueb = uiSlider(4);\n        //valueb.r = 0.0;\n            //Save value\n   // if(puv.x == float(4) && puv.y==0.)\n   //     uiSlider = vec4(0. ,0.,0.,1.);\n        \n        if (!integer) _float(value.r)    //fix for ints\n        else _int(value.r)\n        touch = true;\n         //not a preset any more...\n        //(puv.x == float(4) && puv.y==0.) col = vec4(3. ,0.,0.,1.); //preset\n    }\n    \n    \n    //*\n    else\n    {\n        //vec4 data1= vec4(0.41,2.6,22.,2.5);\n        switch(int(value.r))\n        {\n            case 0: \n                //pos.x += SLIDER_LENGTHf-12.*4.; _N _o _n _e;\n                \n                break;\n                \n            case 1: // .41 2.69 curly (smaller Q for fainter curls) fractal proof  x\n                pos.x += SLIDER_LENGTHf-12.*4.8; \n               //_C _u _r _l _y\n                // .41 2.69 curly (smaller Q for fainter curls) fractal proof  //.41 2.63 24?\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.41 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(2.60,0.,0.,1.);  // Q\n                if(puv.x == float(3) && puv.y==0.) col = vec4(30. ,0.,0.,1.);  // frac max step   was 34 \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.5 ,0.,0.,1.);  // pupil dist  \n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n\n\n                //value.r = 0.0; // this sets the slider back to 0 but erases name\n                break;\n                \n            case 2: \n                pos.x += SLIDER_LENGTHf-12.*4.9; // 1.07 2.09(2?) 2.10 spires\n                //_S _p _i _r _e _s\n                if(puv.x == float(0) && puv.y==0.) col = vec4(1.07 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(2.00,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(36. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.55 ,0.,0.,1.);  //  distance                       need to adjust iters\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n            case 3: //Q -3.5 zz 0.3 skul\n                pos.x += SLIDER_LENGTHf-12.*4.4; \n                //_S _k _u _l _l\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.3 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(2.5,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(36. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.4 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n            case 4: \n                pos.x += SLIDER_LENGTHf-12.*8.5; //Q -3.0 zz 0.35 wolf??\n                //_M _a _n _d _l _e _spc _B _l _o _b\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.35 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(3.0,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(30. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n             case 5: // 3.24 0.32 creepy curvy thing\n                pos.x += SLIDER_LENGTHf-12.*8.5; \n               // _C \n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.32 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(3.24,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(30. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n            case 6: //Q -4.0 zz 0.35 beetle\n                pos.x += SLIDER_LENGTHf-12.*7.; \n                //_B _e _e _t _l _e\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.35 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(4.0,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(36. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;  \n                \n            case 7: //Q -5 zz 0.3 hairy bug\n                pos.x += SLIDER_LENGTHf-12.*7.; \n                //_H _a _i _r _y _spc _b _u _g\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.35 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(5.0,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(36. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(1.5 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n\n            case 8: // spiky or maybe ferny?\n                pos.x += SLIDER_LENGTHf-12.*4.5; //Q -3.5 zz 0.3 ferny ??? //Q -5.5 zz 0.35 34 ferny ???\n                _S _p _i _k _y\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.35 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(5.50,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(30. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(1.0 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n            case 9: //Q -3.5 zz 0.3 dice\n                pos.x += SLIDER_LENGTHf-12.*4.; \n                //_D _i _c _e\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.35 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(6.0,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(36. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(1.2 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n                \n            case 10: // 1.92 .42 dandylion seeds\n                pos.x += SLIDER_LENGTHf-12.*11.; \n                //_D _a _n _d _y _l _i _o _n _spc _s _e _e _d _s\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.42 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(1.92 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(29. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(3. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n                \n            case 11: // around 3.17 ,\"9.86\" -.14 octroissan\n                pos.x += SLIDER_LENGTHf-12.*8.; \n               // _O _c _t _r _o _i _s _s _a _n _t\n                if(puv.x == float(0) && puv.y==0.) col = vec4(-.14 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(3.17 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(26. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(3. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n                \n            case 12: //with +0.1 // -0.6 lumpy donut -0.7 2 donuts -1 4 donuts\n                pos.x += SLIDER_LENGTHf-12.*7.5; \n                //_E _v _i _l _spc _D _o _n _u _t\n                if(puv.x == float(0) && puv.y==0.) col = vec4(-0.6 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(1.29 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(9. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(3. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n            case 13: \n                pos.x += SLIDER_LENGTHf-12.*8.; \n                //_y\n                if(puv.x == float(0) && puv.y==0.) col = vec4(-0.7 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(1.29 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(9. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(3. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n                \n            case 14: \n                pos.x += SLIDER_LENGTHf-12.*11.; \n                //_z\n                if(puv.x == float(0) && puv.y==0.) col = vec4(-1. ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(1.29 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(9. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(3. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(2.0 ,0.,0.,1.);  // power  \n                break;\n\n            case 15: \n                pos.x += SLIDER_LENGTHf-12.*12.5; \n                //_C _r _y _s _t _a _l _i _n _e _spc _E _n _t _i _t _y\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0. ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(1.5 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(31. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(5. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(1.0 ,0.,0.,1.);  // power  \n                break;\n\n            case 16: \n                pos.x += SLIDER_LENGTHf-12.*6.5; \n                //_T _r _i _l _l _i _u _m\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.58 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(1.0 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(60. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(4. ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(3.0 ,0.,0.,1.);  // power  \n                break;\n\n            case 17: \n                pos.x += SLIDER_LENGTHf-12.*6.5; \n                //_S _h _o _c _k _w _a _v _e\n                if(puv.x == float(0) && puv.y==0.) col = vec4(0.42 ,0.,0.,1.); //zz\n                if(puv.x == float(1) && puv.y==0.) col = vec4(5.22 ,0.,0.,1.); // Q                \n                if(puv.x == float(3) && puv.y==0.) col = vec4(11. ,0.,0.,1.);  // frac max step    \n                if(puv.x == float(2) && puv.y==0.) col = vec4(2.69 ,0.,0.,1.);  //  distance\n                if(puv.x == float(4) && puv.y==0.) col = vec4(1.0 ,0.,0.,1.);  // power  \n                break;\n\n// .13 1.98 shark faces\n\n\n//with +0.1\n// -4 lace diadem -3.5 diadem\n\n// with +0.05 and eye_z 4  and max iter 1000 instead of 500\n// -1.0 jagged donut -1.3 small slots, -4.0 diadem, -5 ring of rings, -7.0 ring of ring of rings\n\n// 2.0 spear\n\n//with +1\n// 1.07 snow  1.06 red snow with color2\n//28.0+0.225; //mace\n\n\n\n        }\n    }\n    \n//*/    \n/*\n    if(touch)          //not a preset any more...\n    {\n        if(puv.x == float(4) && puv.y==0.) col = vec4(3.3,0.,0.,1.); //preset\n        vec4 valueb= uiSlider(id);\n         //Slider(id) = valueb;\n        //ec4 uiSlider(int id){return texture(iChan nel0, vec2(float(id)+.5,0.5)/iResolution.xy);}\n        texture(iChan nel0, vec2(float(4)+.5,0.5)/iResolution.xy) =valueb;\n        }\n*/     \n    pos.x = oldx;\n    \n    //value.r = 333.333;\n    \n    //Save value\n    if(puv.x == float(id) && puv.y==0.)\n        col = vec4(value.r,0.,0.,1.);\n    \n    //Save selection\n    if(puv.x == 0. && puv.y == 2.)\n    {\n        if(iMouse.w<.5)\n            col = vec4(0.);\n        else if(mouseAndNoSelect)\n        \tcol = vec4(.1,float(id)/255.,0.,0.);\n    }\n}\n\n\nvoid print_box(vec2 p, vec2 s, vec4 c)\n{\n    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)\n        col += c;\n}\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n\n//_[a..Z] : write a character at the position of the cursor\n\n\n//#define begin BOX_OUTERMARGIN;\n#define POSCENTER(x) (SLIDER_BEGIN + SLIDER_LENGTH/2 -(x)*FONT_WIDTH)\n\n#define _l1 _box(vec2(BOX_OUTERMARGIN, iResolution.y-(2.-1.+NUM_SLIDERS)*float(SLIDER_SPACING)), vec2(BOX_WIDTHf,     (2.*NUM_SLIDERS-4.)*float(SLIDER_SPACING))   ,vec4(0.,0.08,0.,.3)) begin = BOX_OUTERMARGIN;\n#define _l2 _cursor(POSCENTER(4),begin) _G _e _o _m _e _t _r _y; begin += FONT_HEIGHT;\n\n\n\n\n#define _l3 _slider(SLIDER_BEGIN,begin, 0, 0.34, -0.7, 1.3, false , false ) _O _f _f _s _e _t    begin += SLIDER_SPACING;\n#define _l4 _slider(SLIDER_BEGIN,begin, 1,  2.0, 0.0, 9.0,  false , false ) _M _u _l _t _i _p _l _i _e _r\n#define _l5 _slider(SLIDER_BEGIN,begin, 3, 46.0, 1. , 60.,  true , false ) _M _a _x _spc _I _t _e _r _a _t _i _o _n \n#define _l6 _slider(SLIDER_BEGIN,begin, 4, 2.0, 1.0, 6.1,   true , false ) _P _o _w _e _r\n#define _l7 _slider(SLIDER_BEGIN,begin, 2,  3.0, 0.0, 8.0,  false , false ) _E _y _e _spc _D _i _s _t _a _n _c _e \n// _P _u _p _i _l _l _a _r _y _spc _d _i _s _t\n#define _l8 _slider(SLIDER_BEGIN,begin, 5, 0. , 0. , 17.9 , true , false ) _P _r _e _s _e _t\n#define _l9 _cursor(POSCENTER(19) ,begin)\n\n//void *cmds[2]   {1,2};//{ _l1 , _l2};\n\nint begin;\n//vec4 bounds = vec4(30,140,290,18);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    if (iFrame > 0 && (iMouse.z <= 0. || iMouse.y > bounds.y && iMouse.x > (bounds.z + bounds.x)) ) \n        {  \n        fragColor = texture(iChan nel0, fragCoord/iResolution.xy); \n        return;  \n    } //few extra fps?  gets confused by full screen change\n    */\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    float AA_SET;\n    \n    _l1\n    \n    //8.5 8.4 8.0 9.4 \n    _l2\n    //_cursor(POSCENTER(4),begin) \n    \n    \n    //8.8 8.9 s(6.7p)\n    //_G _e _o _m _e _t _r _y; \n    \n    //8.8s 9.6s (6.5p?)\n    //col += vec4( char(ch_G))+vec4( char(ch_e))+vec4( char(ch_o))+vec4( char(ch_m))+vec4( char(ch_e))+vec4( char(ch_r))+vec4( char(ch_y));\n    \n    //begin += FONT_HEIGHT;\n\n\n//col += vec4( char(ch_a)\n\n    _l3\n    _l4\n    begin += SLIDER_SPACING;\n    _l5\n    begin += SLIDER_SPACING;\n    _l6\n    begin += SLIDER_SPACING;\n    \n    //eye distance\n    _l7\n     begin += SLIDER_SPACING + 6;\n     \n    //preset  6.7 6.9 sec without this and begin...  26.8 with and without begin...\n    // removing just names: 8.8  8.1 sec\n    _l8\n    begin += SLIDER_SPACING;//FONT_HEIGHT*2;\n    // begin += FONT_HEIGHT+40;\n    \n    _l9\n    AA_SET = ( AA_MULT * texelFetch( iChannel2, ivec2(201,0), 0 ).r   );\n    float PAL_SET = ( 10.* texelFetch( iChannel2, ivec2(200,0), 0 ).r   );   \n    float COL_SET = ( COL_MULT * texelFetch( iChannel2, ivec2(202,0), 0 ).r   );       \n\n    if ((int(PAL_SET) == 0) || (int(PAL_SET) == 6))\n        {_spc _C _o _l _o _r _spc _int(COL_SET) _spc _spc _spc _lpa _P _a _l _e _t _t _e _spc _int(PAL_SET) _spc _spc _G _r _a _d _i _e _n _t _spc _N _lsl _A _rpa }\n    else\n        {_spc _C _o _l _o _r _spc _int(COL_SET) _spc _spc _spc _lpa \n        _P _a _l _e _t _t _e _spc _int(PAL_SET) _spc _spc _G _r \n        _a _d _i _e _n _t _spc _int(AA_SET) _rpa}\n  \n\n    fragColor = col.rgba;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//To do:\n    // remove sliders because they compile too slow? \n        //use hotkeys only\n        //first pare down colors\n    \n    //save state in another channel \n        // https://www.shadertoy.com/view/XdtSWn\n    // A button would be great...\n        //AA snapshot button?\n    // Radio buttons would be great\n    // AA if no movement since last frame?\n        //may need to save state\n    // change default frac                        X\n    // 0.2 color step great need diff color pallt X\n    // fix donut depth                            X\n    // color sliders red when locked              X\n    // add slider for zz, Q                       X\n        //rename? c and... Q?                     -\n    // x and y sliders, zoom                      X\n    // animate the zoom                           X\n        // started, should fork first             X\n    // animate zz and Q                           X\n        // fork                                   X\n    // presets                                    X\n    // maybe type in numbers\n    // min depth, max depth sliders               OBE\n    // colors and/or density based on depth?      X\n    // max iter slider                            X\n    // go over raymarch alg again\n    // need fractal to ignore clicks in UI        X\n    // nice to save dir state somehow\n    // need a new UI ...tried, failed             *\n    // need to add presets                        X\n        // radio button would be better\n    // estimate dist using n? more iters=closer?  X\n    //    max-n? 1/n?                             X\n    // fix the lights in place no...rotate light  X\n    // compute gradient by dist                   X\n    // figure out GPU reqs, clean up inst         X\n    // or adj shine and mix with no color         X\n    // bring back rot colored lights with ifdef\n    // color choices or UI too busy already?      \n    // AA? too slow?                              X\n    // football SDF as a starting pt for speed?\n\n\n// different interface \n    //https://www.shadertoy.com/view/lsSBRR\n\n// ray march code \n    //https://www.shadertoy.com/view/ts3XR7  \n    //https://www.shadertoy.com/view/WtGXDD\n    //https://www.shadertoy.com/view/4dSBz3\n        \n// AA code\n    //https://shadertoyunofficial.wordpress.com/    \n\n//anything similar applicable? if so, would it even help with my new distance alg?\n/*    #if 0\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n*/\nint COL_SET;// = 0;\nint AA_SET;\nconst float AA_MULT = 20.;\nconst float COL_MULT = 20.;\n\nconst int KEY_SPACE = 32;\nconst int KEY_A = 0x41;\nconst int KEY_P = 0x50;\nconst int KEY_G = 0x47;\nconst int KEY_C = 0x43;\n\n//const vec3 BKGD_COLOR = vec3(0.94,0.5,0.4); //salmon\n//const vec3 BKGD_COLOR = vec3(0.4,0.5,0.3); // olive drab\n//const vec3 BKGD_COLOR = vec3(0.5,0.5,0.5); // gray\nconst vec3 BKGD_COLOR = vec3(0.25,0.25,0.25); // dark gray\n\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nfloat zz = 0.334;\nfloat Q = -5.05;\nfloat eye_z = 1.0;   //larger numer == viewer stepping back\nint MAX_FRAC_STEPS = 46; // zz1.1: 96=dust, 64=thready, 56=waif, 48=spindly, 40=thicker spindles, 32=some holes, 24,20=chonky\nint POWER = 2;\nfloat RAY_STEP;\n\n#define ZERO (min(iFrame,0))\n\n// UI\n#define MAX_DIGIT 6\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 280\n#define FONT_HEIGHT    20\n#define FONT_WIDTH     8\n#define SLIDER_HEIGHTf 3.\n#define SLIDER_SPACING 23\n#define BOX_INNERMARGIN 16\n#define BOX_OUTERMARGIN 16\n\n#define SLIDER_LENGTHf float(SLIDER_LENGTH)\n#define SLIDER_BEGIN (BOX_INNERMARGIN+BOX_OUTERMARGIN)\n#define BOX_WIDTH (2*BOX_INNERMARGIN + SLIDER_LENGTH )\n#define BOX_WIDTHf float(BOX_WIDTH)\n#define WIDGET_COLOR_LOCKED vec3(1.,.3,.3)\n#define WIDGET_COLOR vec3(.3,1.,.3)\nfloat NUM_SLIDERS = 7.;\n\n//increasing max step loses some detail\n//#define SET_RAY_STEP RAY_STEP = 0.001 * log(1.+eye_z); // loses detail 60 fps  tril54\n#define SET_RAY_STEP RAY_STEP = 0.00025 * log(1.+eye_z); //49.7 fps\n//#define SET_RAY_STEP RAY_STEP = 0.000025 * log(1.+eye_z); //way too shallow 28.5\n//------------------------------------------------\n//#define DIST_FUNC dist = float(MAX_FRAC_STEPS - n);\n//60 fps loses detail spirals gone\n//#define DIST_FUNC dist = .1250 + float(MAX_FRAC_STEPS-n); // return a minimum of 1.0. The more steps it made, the closer it was so smaller distance \n//60 fps loses detail spirals gone           \n//#define DIST_FUNC dist = 1. + 5.*float(MAX_FRAC_STEPS-n)/ float(MAX_FRAC_STEPS); // slower and worse than #1\n// 32.5 fps, lost some detail\n\n\n//#define DIST_FUNC dist = 0.1 +  0.01*  pow(float(MAX_FRAC_STEPS-n-1), 2.0 ); \n//27.3 fps sharp very bright spirals   *** best looking   shockwave gone\n//#define DIST_FUNC dist = 0.25  +0.15*float(MAX_FRAC_STEPS-n-1); // 28.3 def fps\n//35.7 w air   32.2 now?  muddled a little on spirals shockwave gone\n//#define DIST_FUNC dist = 0.1333*float(MAX_FRAC_STEPS-n);// 25fps  .1333 24.6fps              .12 23.5fps\n//34.3 w air  32 now   brighter than above  shockwave gone\n//#define DIST_FUNC dist = 1. + 0.004444*pow(float(MAX_FRAC_STEPS-n-1), 2.0);// fixed holes, more detail lost 31fps def 26fps?\n//36 fps with air  35 now, dimmmer muddy spirals some detail lost? shockwave gone\n//#define DIST_FUNC dist = .1250 + 0.125 *float(MAX_FRAC_STEPS-n-1) ; // return a minimum of 1.0. The more steps it made, the closer it was so smaller distance \n//32.5 air  bright spirals   29.8 def now   shockwave gone     \n//#define DIST_FUNC dist = 0.25 +  0.5*float( ((MAX_FRAC_STEPS-n)*(MAX_FRAC_STEPS-n))/MAX_FRAC_STEPS) ;          \n//37 fps 28.6 now  shockwave works  loses a little detail? spirals muddy and lumpy\n\n\n//#define DIST_FUNC dist = 0.125 + 0.5 * float( ((MAX_FRAC_STEPS-n)*(MAX_FRAC_STEPS-n))/MAX_FRAC_STEPS ); \n//28.8 fps??? 21 now  shockwave works  spiral lunpy\n\n//super fast, loses detail on skull, bright spirals winner winner chicken dinner\n#define DIST_FUNC dist = 0.125 + 0.5 * float( (MAX_FRAC_STEPS-n)*(MAX_FRAC_STEPS-n))/float(MAX_FRAC_STEPS) ; // return a minimum of 1.0. The more steps it made, the closer it was so smaller distance \n//1:60 0.5: 51 FPS   new 52.5fps  shockwave works   spiral slightly lumpy\n\n//#define DIST_FUNC dist = 0.125 + 0.5* float( ((MAX_FRAC_STEPS-n)*(MAX_FRAC_STEPS-n))/MAX_FRAC_STEPS);//28 old champ\n//28.7   21 def now shockwave works  spiral lumpy.\n\n\n\n//#define DIST_FUNC dist = 0.1 +  0.01*  float((MAX_FRAC_STEPS-n-1) * (MAX_FRAC_STEPS-n-1) ); //good 40fps\n//41.7  41.7 now   bright spiral, little loss?  shockwave gone\n//#define DIST_FUNC dist = 0.1 +  0.01*  pow(float(MAX_FRAC_STEPS-n-1), 2.0 ); //good same as above\n//41.7 all @ 3x850   42.5 @ 3x550   looks and acts same\n\n\n\n//////////////////////////////////////////////////////////////////////\n// shading\n//////////////////////////////////////////////////////////////////////\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n\n\n// phong shading ? also light sources\nvec3 shading( vec3 pos, vec3 n, vec3 dir, vec3 eye, float SHININESS ) {\n\tvec3 final = vec3( 0.0 );\n\tvec3 ref = reflect( dir, n );\n    vec3 Ks = vec3( 0.5 );\n    vec3 Kd = vec3( 1.0 );\n\t\n\t// light 0\n\t{\n        //vec3 light_pos   = vec3( 20.0,20.0, 30.0 )\n\t\tvec3 light_pos   = vec3(-20,-20,-100 )*dir;  //rot light to keep it still   vec is pos in space\n\t\t//vec3 light_color = vec3( 0.9, 0.9, 1.0 );\n\t\tvec3 light_color = vec3( 1.0, 1.,1.);//was 1 .7 .7 for colorless\n\t\n\t\t//vec3 vl = normalize( light_pos - pos ); //pos doesnt do much?\n        vec3 vl =  normalize(light_pos); //hold it still...\n        \n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n\t\t\n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( SHININESS ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F ); //0.1 fps slower, fills in pic a lot\n\t\t//final += light_color * mix( diffuse, specular, vec3( 1.0,1.0,1.0) ); \n\t}\n\t\n    /*\n\t// light 1  5% drop in fps\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -30.0 );\n\t\tvec3 light_color = vec3( 0.9, 0.9, 1.);\n\t\n\t\tvec3 vl = normalize( light_pos - viewpos );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        \n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( SHININESS ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F );\n\t}\n*/\n    // add a teture map (will need to change channel num now)\n    //final += texture( iChan nel0, ref ).rgb * fresnel( Ks, n, -dir );//fills in dark areas\n    //final += texture( iChan nel0, ref ).rgb;\n\treturn final;\n}\n\n\n\n///////////////////////////////////////////////////////////////\n// dir and rot\n///////////////////////////////////////////////////////////////\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize( vec3( xy, -z ) );\n}\n    \n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\n\n\n\n\n\n\n\n\n//code graveyard\n\n/*\n#define (iResolution.y-(8. +NUM_SLIDERS)*float(BOX_OUTERMARGIN))\n#define (iResolution.y-(8. +NUM_SLIDERS)*float(BOX_OUTERMARGIN))\n\n    _box(vec2(BOX_OUTERMARGIN, iResolution.y-(2.+2.*NUM_SLIDERS)*float(BOX_OUTERMARGIN)),//bottom left      BOX_OUTERMARGIN), //start pos   bot left is 0,0?!?!?\n         vec2(BOX_WIDTHf,     2.42*NUM_SLIDERS*float(BOX_OUTERMARGIN)) //288 16  //length\n         ,vec4(0.,0.08,0.,.3))   //last digit is opaq\n*/\n        //ver4\n        /*\n        f = float[3]( Q*f[0]*f[2] +   f[1]*f[1] +zz, \n                        f[0]*f[0] + Q*f[1]*f[2] +zz, \n                      Q*f[0]*f[1] +   f[2]*f[2] +zz);\n        */\n/*        \n        weird, lumpy spirals\n        f = vec3( Q*f.x*f.z +   f.y*f.y + zz,   //about the same speed\n                   Q* f.x*f.x + f.y*f.z + zz, \n                  Q*f.x*f.y +   f.z*f.z + zz);  \n\n                f = vec3( Q*f.x*f.z + f.y*f.y + zz,   //same as ver4\n                          Q*f.x*f.y + f.z*f.z + zz,\n                          Q*f.y*f.z + f.x*f.x + zz);\n*/  \n       /* \n       f = vec3( Q*f.x*f.z + 0.*f.y*f.y + zz,   //stick bug\n                  Q*f.x*f.y + 0.*f.z*f.z + zz,\n                  Q*f.y*f.z + 0.*f.x*f.x + zz);  \n                  \n                \n  /*\n      f = vec3( Q*f.y*f.z + f.x*f.x + zz,   //looks the same\n                Q*f.x*f.z + f.y*f.y + zz,\n                Q*f.x*f.y + f.z*f.z + zz);             \n                  \n \n       f = vec3( Q*f.y*f.z + Q*f.x*f.x + zz,   //ugly\n                Q*f.x*f.z + Q*f.y*f.y + zz,\n                Q*f.x*f.y +Q* f.z*f.z + zz);             \n       */   \n// camera rotations\n//rot = rotationXY(vec2(-35.*DEG_TO_RAD, 45.*DEG_TO_RAD)); //dark side straight at camera\n//rot = rotationXY(vec2(145.*DEG_TO_RAD, 45.*DEG_TO_RAD));//light side pt at cam\n//rot = rotationXY(vec2(50.*DEG_TO_RAD, 45.*DEG_TO_RAD));// veritcal\n//rot = rotationXY(vec2(232.*DEG_TO_RAD, -20.*DEG_TO_RAD));\n\n\n\n/*\n// used only for microt stepping right meow\nfloat frac(vec3 f, inout bool hit) //returns length of k vector\n{       \n    float sum;\n    \n    for (int n=0; n<MAX_FRAC_STEPS; n++)\n    {\n        f = vec3( Q*f.x*f.z + f.y*f.y + zz,   //make me a matrix?\n                  Q*f.x*f.y + f.z*f.z + zz,\n                  Q*f.y*f.z + f.x*f.x + zz);\n                  \n        //sum = abs(f[0]) + abs(f[1]) + abs(f[2]); //way faster approx but needs higher thresh, loses detail 42.5 fps when > 8. 45.8 fps > 4  11fps faster when >2 but details lost\n        sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n        if (sum > 2.)\n        {\n            hit = false;\n            return 0.0; // not in fractal\n        }\n    }    \n    // if I never exceeded threshold, I am in part of the fractal.\n    // n = max (depending on compiler?) sum will always be 0..2\n    hit = true;\n    return sum;\n}\n*/\n\n/*\nfloat frac_float(vec3 f, inout float hit)\n{       \n    float sum;\n    \n    for (int n=0; n<MAX_FRAC_STEPS; n++)\n    {\n        f = vec3( Q*f.x*f.z + f.y*f.y + zz,   //make me a matrix?\n                  Q*f.x*f.y + f.z*f.z + zz,\n                  Q*f.y*f.z + f.x*f.x + zz);\n        //sum = abs(f[0]) + abs(f[1]) + abs(f[2]); //way faster approx but needs higher thresh, loses detail 42.5 fps when > 8. 45.8 fps > 4  11fps faster when >2 but details lost\n        sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n        if (sum > 2.)\n        {\n            hit = 1.;\n            return 0.0; // not in fractal\n        }\n    }    \n    // if I never exceeded threshold, I am in part of the fractal.\n    // n = max (depending on compiler?) sum will always be 0..2\n    hit = 0.;\n    return sum;\n}\n\nfloat frac_float_dist (vec3 f, inout float hit, inout float dist)\n{       \n    float sum;\n    \n    for (int n=0; n<MAX_FRAC_STEPS; n++)\n    {\n        f = vec3( Q*f.x*f.z + f.y*f.y + zz,   //make me a matrix?\n                  Q*f.x*f.y + f.z*f.z + zz,\n                  Q*f.y*f.z + f.x*f.x + zz);\n        //sum = abs(f[0]) + abs(f[1]) + abs(f[2]); //way faster approx but needs higher thresh, loses detail 42.5 fps when > 8. 45.8 fps > 4  11fps faster when >2 but details lost\n        sum = length(f); //44.2 fps when >4.  35.9 fps > 8  details same but body thicker?\n        if (sum > 2.)\n        {\n            hit = 1.;\n            //dist = float(MAX_FRAC_STEPS - 1 - n);\n            \nDIST_FUNC\n            return 0.0; // not in fractal\n        }\n    }    \n    // if I never exceeded threshold, I am in part of the fractal.\n    // n = max (depending on compiler?) sum will always be 0..2\n    hit = 0.;\n    dist = 0.0;\n    return sum;\n}\n\n\n*/\n\n/*\nvec3 gradient( vec3 pos ) { // just a reflection, calc from sums\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n    bool h = false;\n    if (true)\n\treturn normalize (  //this makes sense(?) when distance is returned, seemed to work with 1/0 but when sum???\n\t\tvec3(frac( pos + dx, h) - frac( pos - dx, h),            \n\t\t\t frac( pos + dy, h) - frac( pos - dy, h),\n\t\t\t frac( pos + dz, h) - frac( pos - dz, h))\n\t);\n    else\n    //not normalizing makes it very dark\n    \treturn vec3(frac( pos + dx, h) - frac( pos - dx, h),            \n\t\t\t frac( pos + dy, h) - frac( pos - dy, h),\n\t\t\t frac( pos + dz, h) - frac( pos - dz, h));\n\n}\n\nvec3 gradient_color(vec3 pos, inout vec3 color, float tin)//reflect and color from sums\n{\n    const vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n    bool h = false;    \n    float v0 = frac( pos + dx, h);\n    float v1 = frac( pos - dx, h);\n    float v2 = frac( pos + dy, h);\n    float v3 = frac( pos - dy, h);\n    float v4 = frac( pos + dz, h);\n    float v5 = frac( pos - dz, h);\n        \n    //use all 3D or asymmetric colors    \n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y + 1.0 *tin ); //meh busy \n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y + 6.0*tin  ) / 12.;     // meh ok with gradient 0.01 using rainbow it colors the center nice but the edges are blue\n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y + 1.0*tin  ) / 7.;     // meh\n    float t = (v0 + v1 + v2 + v3 + v4 + v5) / 6.0;     // sexy with new_color\n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y  ) / 0.6;     // sexy with log partial spectrum\n    \n    \n    \n    //if (t>2.0) t=2.; //this helps cap the inner crazy   //only when  /.6 removes all center color when /0.5\n    //if (t>1.0) t=1.0; //trims center colors\n    //if (t>6.28) t=6.28; //does nothing?\n    //if (t>3.14) t=3.14; //removes rainbows from partial spectrum, chops half the spectrum?\n    //t = min(t, 2.);\n    //maybe just get a new palette\n    \n    //color = partial_spectrum(log(t)); //sexy, but also busy at times   hot with cap\n    //color = partial_spectrum(3.14*t); //\n    \n    //color = new_color(3.14*t + 3.14); // not bad with no cap and /0.6  ok wiht 7/7\n    color = new_color2(3.14*t + 3.14); // not bad with no cap and /0.6  ok wiht 7/7\n    \n    \n    //color = rainbow(log(t/2.)); // too much? not bad with z +4tin\n    //color = rainbow(log(t)); //kinda busy even with z+4tin\n    //color = rainbow(log(t)*.314); // neat\n    //color = rainbow(t); //kinda busy even with z+4tin\n\treturn normalize (\n\t\tvec3( //this makes sense(?) when distance is returned, seemed to work with 1/0 but when sum???\n//also don't need to normalize if 1/0?\n\t\t\t//dist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tv0 - v1,            \n\t\t\tv2 - v3,            \n\t\t\tv4 - v5 \n\t\t)\n\t);\n}\n\nvec3 gradient_color_float_hits( vec3 pos, inout vec3 color, float tin ) //calc reflect and color\n{ // use hits as floats 1.0 0.0 to calculate reflction\n    const vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n    float a,b,c,d,e,f;    \n    float v0 = frac_float( pos + dx, a);\n    float v1 = frac_float( pos - dx, b);\n    float v2 = frac_float( pos + dy, c);\n    float v3 = frac_float( pos - dy, d);\n    float v4 = frac_float( pos + dz, e);\n    float v5 = frac_float( pos - dz, f);\n        \n    //use all 3D or asymmetric colors    \n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y + 1.0 *tin ); //meh busy \n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y + 6.0*tin  ) / 12.;     // meh ok with gradient 0.01 using rainbow it colors the center nice but the edges are blue\n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y + 1.0*tin  ) / 7.;     // meh\n    float t = (v0 + v1 + v2 + v3 + v4 + v5) / 6.0;     // sexy with new_color\n    //float t = (v0.y + v1.y + v2.y + v3.y + v4.y + v5.y  ) / 0.6;     // sexy with log partial spectrum\n    \n    \n    \n    //if (t>2.0) t=2.; //this helps cap the inner crazy   //only when  /.6 removes all center color when /0.5\n    //if (t>1.0) t=1.0; //trims center colors\n    //if (t>6.28) t=6.28; //does nothing?\n    //if (t>3.14) t=3.14; //removes rainbows from partial spectrum, chops half the spectrum?\n    //t = min(t, 2.);\n    //maybe just get a new palette\n    \n    //color = partial_spectrum(log(t)); //sexy, but also busy at times   hot with cap\n    //color = partial_spectrum(3.14*t); //\n    \n    //color = new_color(3.14*t + 3.14); // not bad with no cap and /0.6  ok wiht 7/7\n    //color = new_color2(3.14*t + 3.14); // not bad with no cap and /0.6  ok wiht 7/7\n    color = new_color3(3.14*t + 3.14); // not bad with no cap and /0.6  ok wiht 7/7\n    \n    \n    //color = rainbow(log(t/2.)); // too much? not bad with z +4tin\n    //color = rainbow(log(t)); //kinda busy even with z+4tin\n    //color = rainbow(log(t)*.314); // neat\n    //color = rainbow(t); //kinda busy even with z+4tin\n    \n    //this makes sense(?) when distance is returned, seemed to work with 1/0 but when sum???\n    //also don't need to normalize if 1/0?\n\treturn normalize ( vec3(a - b, c - d, e - f) );\n}\n\nvec3 gradient_float_hits( vec3 pos ) { //calc reflect and color\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n    float a,b,c,d,e,f;    \n    float v0 = frac_float( pos + dx, a);\n    float v1 = frac_float( pos - dx, b);\n    float v2 = frac_float( pos + dy, c);\n    float v3 = frac_float( pos - dy, d);\n    float v4 = frac_float( pos + dz, e);\n    float v5 = frac_float( pos - dz, f);\n    \n    //this makes sense(?) when distance is returned, seemed to work with 1/0 but when sum???\n    //also don't need to normalize if 1/0?\n\t//return normalize ( vec3(a - b, c - d, e - f) );\n    return normalize ( vec3(-a + b, -c+ d, -e + f) );\n}\n  */  ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//A second way to save state and provide an interface. Keyboard input\nconst float MAX_COLOR_SCM = 6. + 1.;\nconst float MAX_AA_SCM = 9. + 1.;\nfloat color_set =0.;\nfloat aa_set, pal_set = 6.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n    \n    vec2 uv = fragCoord.xy / iResolution.x;    \n    float dist = length(fragCoord );\n    \n    if (iFrame == 0){\n        pal_set = 6.;\n        aa_set = 0.;\n        color_set = 0.;\n    }\n    else{\n        pal_set = 10. * texelFetch( iChannel2, ivec2(200,0), 0 ).x;\n        aa_set = AA_MULT * texelFetch( iChannel2, ivec2(201,0), 0 ).x;\n        color_set = COL_MULT * texelFetch( iChannel2, ivec2(202,0), 0 ).x;\n    }\n    \n    if (texelFetch( iChannel1, ivec2(KEY_C,1), 0 ).x == 1.0){ //if key toggled\n        color_set = mod(color_set + 1., 17.);\n        if (color_set == 7.) color_set = 8.;\n        switch(int(color_set)){\n            case  1: pal_set=0.; aa_set=0.; break;\n            case  2: pal_set=1.; aa_set=7.; break; // a lot\n            case  3: pal_set=1.; aa_set=8.; break;\n            //case 17: pal_set=2.; aa_set=6.; break; // ok for donuts only\n            case  4: pal_set=2.; aa_set=7.; break;\n            case  5: pal_set=2.; aa_set=8.; break;\n            case  6: pal_set=2.; aa_set=10.; break;\n            //case 7: pal_set=2.; aa_set=11.; break;  ///same???\n            case  8: pal_set=3.; aa_set=7.; break;\n            case  9: pal_set=3.; aa_set=8.; break;\n            case 10: pal_set=3.; aa_set=9.; break;\n            case 11: pal_set=4.; aa_set=7.; break;\n            case 12: pal_set=4.; aa_set=8.; break;\n            case 13: pal_set=4.; aa_set=9.; break;\n            case 14: pal_set=5.; aa_set=7.; break;\n            case 15: pal_set=5.; aa_set=8.; break;\n            case 16: pal_set=5.; aa_set=9.; break;\n            case  0: pal_set=6.; aa_set=0.; break;\n          //case 18: pal_set=3.; aa_set=8.; break;\n          //case 19: pal_set=3.; aa_set=8.; break;\n        }\n    }  \n    else \n    {\n        if (texelFetch( iChannel1, ivec2(KEY_P,1), 0 ).x == 1.0) //if key toggled\n        { \n            pal_set = mod(pal_set + 1., MAX_COLOR_SCM);\n        }\n        else if (texelFetch( iChannel1, ivec2(KEY_G,1), 0 ).x == 1.0)\n        { //if key toggled\n            aa_set = mod(aa_set + 1., MAX_AA_SCM);\n        }\n    }\n    \n    \n    dist = length(fragCoord - vec2(200.,0.) );\n    if (dist < 0.95)\n        fragColor = vec4(pal_set/10.,0.,0.,1.); //draw pal_set\n    else \n    {\n        dist = length(fragCoord - vec2(201.,0.) ); //if id 1\n        if (dist < 0.95)\n            fragColor = vec4(aa_set/AA_MULT ,0.,0.,1.);\n        else \n        {\n            dist = length(fragCoord - vec2(202.,0.) ); //if id 1\n            if (dist < 0.95)\n                fragColor = vec4(color_set/COL_MULT ,0.,0.,1.);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}