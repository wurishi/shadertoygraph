{"ver":"0.1","info":{"id":"tlGGDR","date":"1578698081","viewed":181,"name":"Four Rhombus Tessellation","username":"revort","description":"Tessellates four rhombi, varying the angle inside the rhombus.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CS(a)        vec2( cos(a), sin(a) )\nfloat pi = 3.14159265358979;\nfloat sqrt_2 = 1.41421356237;\nfloat sqrt_half = 0.70710678118;\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat tesselatedRhombiPos(float theta1, vec2 p){\n    vec2 p_ = p;\n    p_ -= vec2(0.5,0.5);\n    p_ *= rot(-pi/4.0);\n    float d = sdRhombus(p_, CS(pi/4.0));\n    p_ = p;\n    p_ -= vec2(0.5+0.5*cos(theta1),1.0+0.5*sin(theta1));\n    p_ *= rot(-theta1/2.0);\n    d = min(d,sdRhombus(p_, CS(theta1/2.0)));\n    p_ = p;\n    p_ -=vec2(1.0+0.5*sin(theta1),0.5-0.5*cos(theta1));\n    p_ *= rot((pi-theta1)/2.0);\n    d = min(d,sdRhombus(p_, CS(theta1/2.0)));\n    p_ = p;\n    p_ -= vec2(1.0 + sqrt_half*cos(theta1-pi/4.0),1.0 + sqrt_half*sin(theta1-pi/4.0));\n    p_ *= rot(-theta1-pi/4.0);\n    d = min(d,sdRhombus(p_, CS(pi/4.0)));\n    return d;\n}\n\nvec2 opRep( in vec2 p, in vec2 c)\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat getTesselatedRhombusVal(vec2 p, float theta1){\n    vec2 a_vec = vec2(cos(theta1),1.0+sin(theta1));\n    vec2 b_vec = vec2(1.0+sin(theta1),-cos(theta1));\n    float angle = atan(a_vec.y,a_vec.x);\n    float len = length(a_vec);\n    vec2 offset = vec2(len,len);\n    vec2 p_ = p*rot(-angle);\n    p_ = opRep(p_, offset);\n    float val = tesselatedRhombiPos(theta1,(p_*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(offset.x,0.0))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(offset.x,0.0))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(0.0,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(0.0,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(offset.x,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(offset.x,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(-offset.y,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(-offset.y,offset.y))*rot(angle)));\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = iTime;\n    vec2 p = uv - vec2(0.5,0.5);\n    p *= iResolution.xy / iResolution.x * 12.0;\n    if (floor(mod(t/2.0,3.0))==1.0){\n        p *= rot(mod(t,2.0)*pi/4.0);\n    }\n    if (floor(mod(t/2.0,5.0))==1.0){\n        p = p + vec2(0.0,1.0);\n    }\n    float theta1 = mod(t,2.0)*pi/4.0;\n    float val = getTesselatedRhombusVal(p, theta1);\n    vec3 col = vec3(0.0);\n    col = mix(col,vec3(1.0),0.5 + 0.5*cos(val*pi*10.0));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}