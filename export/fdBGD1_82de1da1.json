{"ver":"0.1","info":{"id":"fdBGD1","date":"1617684178","viewed":62,"name":"SDF HomeWork 1","username":"ivanelgran","description":"sdf homework","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//// Based on www.shadertoy.com/view/XdSBDd\n//// Definitions\n\n#define CAMERA_SPEED 0.5\n\n#define MAX_DIST 50.0\n#define EPSILON 0.0001\n\n#define SHADOWS\n#define SHADOW_THRESHOLD 0.01\n#define SOFT_SHADOWS\n#define SHADOW_HARDNESS 50.0\n\n#define LIGHT_INTENSITY 25.0\n#define AMBIENT_LIGHT 0.05\n\n#define MAX_REFLECTIONS 2\n#define REFLECTION_THRESHOLD 0.01\n\n#define MAX_LIGHT_SOURCES 2\n\n#define FOG\n#define FOG_DISTANCE 25.0\n#define FOG_COLOR vec3(0.2, 0.25, 0.3)\n\n#define MATERIAL_LIGHTGRAY Material(vec3(0.9, 0.9, 0.9), 0.5, 8.0, 0.4)\n#define MATERIAL_GREEN Material(vec3(0.13, 0.556863, 0.137843), 0.8, 8.0, 0.0)\n#define MATERIAL_BLUE Material(vec3(0.0, 0.0, 0.956863), 0.8, 4.0, 0.2)\n#define MATERIAL_PURPLE Material(vec3(0.878431, 0.4, 1.0), 1.0, 8.0, 0.0)\n#define MATERIAL_YELLOW Material(vec3(1.0, 0.843137, 0.0), 1.0, 8.0, 0.5)\n#define MATERIAL_BROWN Material(vec3(0.64, 0.16, 0.16), 1.0, 8.0, 0.0)\n#define MATERIAL_DARKTAN Material(vec3(0.19, 0.41, 0.31), 0.9, 8.0, 0.1)\n#define MATERIAL_QUARTZ Material(vec3(0.85, 0.85, 0.95), 0.7, 8.0, 0.2)\n#define MATERIAL_COPPER Material(vec3(0.72, 0.45, 0.2), 1.0, 2.0, 0.1)\n#define MATERIAL_PINK Material(vec3(0.73, 0.16, 0.56), 0.8, 4.0, 0.0)\n#define MATERIAL_ANIMATE Material(vec3(0.73 * sin(iTime * 2.0), 0.16 * sin(iTime * 5.0), 0.56 * sin(iTime * 9.0)), 0.8, 4.0, 0.0)\n\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\nconst float pi = 3.1415926535897932384626433832795;\n//const vec3 EyeStartPosition = vec3(-12.0,-7.0,-8.0);\n\n\n//// Structs\n\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n    float reflectivity;\n};\n\nMaterial mats[10] = Material[](MATERIAL_LIGHTGRAY, MATERIAL_GREEN, MATERIAL_BLUE, MATERIAL_PURPLE, MATERIAL_YELLOW, MATERIAL_BROWN, MATERIAL_DARKTAN, MATERIAL_QUARTZ, MATERIAL_COPPER, MATERIAL_PINK);\n\nstruct MapInfo {\n    Material material;\n    float hit;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n\n    vec3 target;\n\n    float length;\n\nvec3 position;\n};\n\n//// Ray initializer\n\nRay initRayToTarget(vec3 origin, vec3 target) {\n    Ray ray;\n\n    // Init ray values\n    // Calculate ray direction\n    ray.direction = normalize(target - origin);\n\n    // Start a bit away from the origin so we don't hit whatever is at the start\n    ray.origin = origin + ray.direction * EPSILON;\n\n    ray.target = target;\n    ray.position = origin;\n\n    return ray;\n}\n\nRay initRayToDirection(vec3 origin, vec3 direction) {\n    Ray ray;\n\n    // Init ray values\n    ray.direction = direction;\n\n    ray.origin = origin + ray.direction * EPSILON;\n    ray.position = origin;\n\n    return ray;\n}\n\n//// Distance operations\n\nMapInfo opUnion(MapInfo o1, MapInfo o2) {\n    if (o1.hit < o2.hit) return o1;\n    return o2;\n}\n\nMapInfo opSubtract(MapInfo o1, MapInfo o2) {\n    if (-o1.hit > o2.hit) return MapInfo(o1.material, -o1.hit);\n    return o2;\n}\n\nMapInfo opIntersect(MapInfo o1, MapInfo o2) {\n    if (o1.hit > o2.hit) return o1;\n    return o2;\n}\n\n//// iquilezles.org/articles/distfunctions\n\nfloat opOnion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n//// Distance functions\n//// https://iquilezles.org/articles/distfunctions\n\nMapInfo plane(vec3 origin, int matId) {\n    return MapInfo(mats[matId], -origin.y);\n}\n\nMapInfo sphere(vec3 origin, float rad, int matId) {\n    return MapInfo(mats[matId], length(origin) - rad);\n}\n\nMapInfo box(vec3 origin, vec3 size, int matId) {\n    return MapInfo(mats[matId], length(max(abs(origin) - size, 0.0)));\n}\n\nMapInfo cyl(vec3 p, float h, float r, int matId)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return MapInfo(mats[matId], min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nMapInfo cone(in vec3 p, in vec2 c, float h, int matId)\n{\n  vec2 q = h*vec2(c.x/c.y,-1.0);   \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return MapInfo(mats[matId], sqrt(d)*sign(s));\n}\n\nMapInfo torus(vec3 p, vec2 t, int matId)\n{\n    vec4 w = opElongate( p, vec3(0.1,0.0,0.1) );\n    return MapInfo(mats[matId],  w.w + length( vec2(length(w.xz)-t.x,w.y) )-t.y);\n}\n\nMapInfo star(vec3 p, int matId) {\n    p.xy = repeatAng(p.xy, 5.0);\n    p.xz = abs(p.xz);\n    return MapInfo(mats[matId], starPlane(p, vec3(0.5, 0.25, 0.8), -0.15));\n}\n\n//// The main mapping function\n\nMapInfo map(vec3 origin) {\n    // Floor\n    MapInfo mapInfo = plane(origin, 0);\n    \n    // Christmas Tree\n    mapInfo = opUnion(mapInfo, cyl(origin + vec3(2.5, 1.0, 1.5), 0.5, 2.5, 5)); \n    mapInfo = opUnion(mapInfo, cone(rotateX(origin + vec3(2.5, 4.0, 1.5), pi), vec2(0.2, 0.28), 2.6, 1));\n    mapInfo = opUnion(mapInfo, cone(rotateX(origin + vec3(2.5, 5.0, 1.5), pi), vec2(0.18, 0.28), 2.6, 1));\n    mapInfo = opUnion(mapInfo, cone(rotateX(origin + vec3(2.5, 6.0, 1.5), pi), vec2(0.15, 0.28), 2.6, 1));\n    mapInfo = opUnion(mapInfo, cone(rotateX(origin + vec3(2.5, 7.0, 1.5), pi), vec2(0.11, 0.28), 2.6, 1));\n    mapInfo = opUnion(mapInfo, star(rotateY(rotateX(origin + vec3(2.5, 7.2, 1.5), pi), pi * sin(iTime * 1.0)), int(round(4.0 * sin(iTime * 1.0)))));\n    \n    // Christmas decorations\n    \n    mapInfo = opUnion(mapInfo, sphere(origin + vec3(3.5, 4.2, 2.3), 0.3, 6));\n    mapInfo = opUnion(mapInfo, sphere(origin + vec3(3., 2.2, 0.), 0.3, 5));\n    \n    mapInfo = opUnion(mapInfo, box(origin + vec3(1.5, 4.1, 1.5), vec3(0.3), 2));\n    \n    mapInfo = opUnion(mapInfo, opSubtract(\n        sphere(origin + vec3(3.5, 4.0, 0.5), 0.4, 3),\n        box(origin + vec3(3.5, 4.0, 0.5), vec3(0.3), 3))\n    );\n    mapInfo = opUnion(mapInfo, opSubtract(\n        sphere(origin + vec3(1.0, 2.2, 0.5), 0.4, 8),\n        box(origin + vec3(1.0, 2.2, 0.5), vec3(0.3), 8))\n    );\n    mapInfo = opUnion(mapInfo, opIntersect(\n        box(origin + vec3(4.0, 3.2, 1.5), vec3(0.3), 4),\n        sphere(origin + vec3(4.0, 3.2, 1.5), 0.4, 4))\n    );\n    \n    mapInfo = opUnion(mapInfo, opIntersect( \n        box(origin + vec3(2.0, 2.2, 3.3), vec3(0.3), 6),\n        sphere(origin + vec3(2.0, 2.2, 3.3), 0.4, 6))\n    );\n    \n    mapInfo = opUnion(mapInfo, torus(rotateX(origin + vec3(2.3, 3.2, 2.8), pi * 0.75), vec2(0.2,0.1), 2));\n    \n    mapInfo = opUnion(mapInfo, torus(rotateX(origin + vec3(2.4, 5.2, 0.7), pi * 0.28), vec2(0.2,0.1), 4));\n\n    return mapInfo;\n}\n\n//// Raymarching functions\n\nvec3 calcNormal(vec3 position) {\n    vec2 eps = vec2(0.0, 0.005);\n    return normalize(vec3(\n        map(position + eps.yxx).hit - map(position - eps.yxx).hit,\n        map(position + eps.xyx).hit - map(position - eps.xyx).hit,\n        map(position + eps.xxy).hit - map(position - eps.xxy).hit\n    ));\n}\n\nMapInfo trace(inout Ray ray) {\n    while(distance(ray.position, ray.origin) < MAX_DIST) {\n        // Get info about our position in relation to the map\n        MapInfo mapInfo = map(ray.position);\n        // If we hit something, return the info about our position on the map\n        if(mapInfo.hit < EPSILON) return mapInfo;\n\n        // Step forward along the ray, as far as our distance to the map\n        ray.position += ray.direction * mapInfo.hit;\n    }\n    // Return fog if we didn't hit anything\n    return MapInfo(Material(FOG_COLOR, 0.0, 0.0, 0.0), 1.0);\n}\n\n//// iquilezles.org/articles/rmshadows\n\nfloat softshadow(inout Ray ray, float softness) {\n    // While we're not past the target, do the stuff\n    // Subtract EPSILON * 2 so we don't get close enough to the original object to trigger the shadow\n    float penumbra = 1.0;\n    while(distance(ray.origin, ray.position) < distance(ray.origin, ray.target) - EPSILON * 2.0) {\n        // Get info about our position in relation to the map\n        MapInfo mapInfo = map(ray.position);\n        // If we hit something, make the color black (shadow)\n        if(mapInfo.hit < EPSILON) return 0.0;\n\n        #ifdef SOFT_SHADOWS\n            penumbra = min(penumbra, softness * mapInfo.hit / distance(ray.position, ray.target));\n        #endif\n\n        if(mapInfo.hit > SHADOW_THRESHOLD) ray.position += ray.direction * mapInfo.hit;\n        // Move a bit closer to the target\n        else ray.position += ray.direction * SHADOW_THRESHOLD;\n    }\n    // If we don't hit anything, the point is not in shadow so the shadow multiplier is 1.0\n    return penumbra;\n}\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2, vec3 EyeStartPosition)\n{   \n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv -= (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = -(fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye += u*speed;\n    if (isKeyHeld(KeyRight)) eye -= u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n        \n    #ifdef CAMERA_ANIMATE\n        Ray cameraRay = initRayToTarget(-vec3(\n            sin(iTime * CAMERA_SPEED) * 5.0,\n            5.0,\n            cos(iResolution * CAMERA_SPEED) * 10.0), -vec3(2.5, 1.0, 1.5)\n        );\n    #else\n        Ray cameraRay = initRayToTarget(eye, -vec3(0.0, -4.0, 0.0));\n    #endif\n    \n    cameraRay.direction = normalize(u * px.x + v * px.y + w);\n    // Ray generation\n    return cameraRay;\t\t\t\t\t\t//maxT\n}\n\n//// Main function\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 EyeStartPosition = vec3(-12.0,-4.0,-5.0);\n    vec3 LIGHT_COORDS[MAX_LIGHT_SOURCES] = vec3[](vec3(9.0, 5.0, 7.0 * -sin(iTime * 1.2)), vec3(-5.0, 5.0, -5.0 * -sin(iTime * 1.2) ));\n\n    vec3 eye; vec2 data;\n    Ray cameraRay = Camera(fragCoord, eye, data, EyeStartPosition);\n   \n    vec4 reflections[MAX_REFLECTIONS + 1];\n\n    // Background color\n    float reflectivity = 1.0;\n    for(int i = 0; i <= MAX_REFLECTIONS; i++) {\n        MapInfo mapInfo = trace(cameraRay);\n\n        if(mapInfo.hit < EPSILON) {\n            //// Lighting\n\n            vec3 normal = calcNormal(cameraRay.position);\n\n            \n            // Get color from map info\n                vec3 hitColor = mapInfo.material.color;\n            // Light stuff\n            for(int i = 0; i <= 1; i++) {\n                Ray lightRay = initRayToTarget(-LIGHT_COORDS[i], cameraRay.position);\n            \n                #ifdef SHADOWS\n                    // Trace shadows\n                    float shadow = softshadow(lightRay, SHADOW_HARDNESS);\n                #else\n                    float shadow = 1.0;\n                #endif\n                // Light fades by the inverse square of distance\n                float distanceFade =  LIGHT_INTENSITY / pow(distance(lightRay.origin, lightRay.target), 1.3);\n                // Multiply diffuse by shadow and distance fade\n                float diffuse = max(0.0, dot(-lightRay.direction, normal))\n                    * mapInfo.material.diffuse * shadow * distanceFade;\n                // Specular lighting factor\n                float specular = pow(diffuse, mapInfo.material.specular);\n\n                // Add lighting values\n                hitColor *= diffuse + specular + AMBIENT_LIGHT;\n            }\n            \n            \n            #ifdef FOG\n                // Add fog\n                float fogAmount = 1.0 - exp(-max(distance(cameraRay.origin, cameraRay.position) - FOG_DISTANCE, 0.0) * 0.15);\n                hitColor = mix(hitColor, FOG_COLOR, fogAmount);\n            #endif\n\n            reflections[i] = vec4(hitColor, mapInfo.material.reflectivity);\n\n            // Set the camera ray to the reflection off the surface, and repeat\n            cameraRay = initRayToDirection(\n                cameraRay.position + normalize(reflect(cameraRay.direction, normal)) * EPSILON,\n                normalize(reflect(cameraRay.direction, normal))\n            );\n        } else {\n            reflections[i] = vec4(mapInfo.material.color, 0.0);\n            break;\n        }\n    }\n\n    fragColor = vec4(reflections[MAX_REFLECTIONS].rgb, 1.0);\n\n    for(int i = MAX_REFLECTIONS - 1; i >= 0; i--) {\n        fragColor = mix(vec4(reflections[i].rgb, 1.0), fragColor, reflections[i].a);\n    }\n\n    // Gamma correction\n    fragColor = vec4(pow(clamp(fragColor.xyz, 0.0, 1.0), vec3(0.4545)), 1.0);\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI                      3.14159265\n\n//// github.com/dmnsgn/glsl-rotate\nmat3 rotation3dX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\n\n  \nmat3 rotation3dY(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotation3dZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, s, 0.0,\n\t\t-s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n}\n\nvec3 rotateX(vec3 v, float angle) {\n\treturn rotation3dX(angle) * v;\n}\n\nvec3 rotateY(vec3 v, float angle) {\n\treturn rotation3dY(angle) * v;\n}\n\nvec3 rotateZ(vec3 v, float angle) {\n\treturn rotation3dZ(angle) * v;\n}\n\n\n//// www.shadertoy.com/view/XlXGRM\nfloat starPlane(vec3 p, vec3 n, float offs) {\n  return dot(p, n) + offs;\n}\n\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}","name":"Common","description":"","type":"common"}]}