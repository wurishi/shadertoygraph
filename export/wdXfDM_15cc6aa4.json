{"ver":"0.1","info":{"id":"wdXfDM","date":"1588515154","viewed":288,"name":"Boner Style Skinning 2D","username":"spalmer","description":"a frag-shader-only 2D version of the skinning/boning technique I used long LONG ago.\nWill it cooperate with distance fields?  I think it will!\n","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["animation","skinning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Similar to my OLD method for skinned skeletal mesh animation.\n// Was used on Demise (Wizardry/Bard'sTale clone you never heard of)\n// I called it \"Boner\" for laughs.\n// Was helpful for the artists to rig their models really easily in 3DS MAX.\n// \"Boner II\" got used on a few Tony Hawk ports back in the Dreamcast era.\n// This is the same general idea, but only 2D and not using meshes at all,\n// but rather simple pill SDFs, noise, and textures.\n// As an example of skinned animation, it's truly simple,\n// and has quite a few limitations when used in production.\n// But it certainly can do the trick!\n\nconst int njoints = 4;\n\n// parent joint of joint - can try alternative hierarchies\nint[njoints] poseConnect = int[njoints] (\n    -1, 0, 1, 2 //1, -1, 1, 2 //1, 2, -1, 2 //1, 2, 3, -1 //\n    );\n\nvec2[njoints] poseRest = vec2[njoints] (\n    vec2(-1,0), vec2(-.33,0), vec2(.33,0), vec2(1,0)\n    );\nvec2[njoints] poseCurr;\n// the scheme results in having to index by the *child* joint index everywhere.\n// parent/child is a rather arbitrary distinction, could simply call \"other\".\n// in any case, the directionality should be consistent, either way.\n\nvoid InitPoseCurr()\n{\n  #if 0\n\tvec2[njoints] poseAnim = vec2[njoints] (\n    \tvec2(-.6,.3), vec2(-.4,-.3), vec2(.4,-.3), vec2(.6,.3)\n    );\n    for (int i = njoints; i-- > 0; ) {\n        poseCurr[i].x = mix(poseRest[i], poseAnim[i], abs(sin(iTime*.2))).x;\n        poseCurr[i].y = mix(poseRest[i], poseAnim[i],     sin(iTime*.2) ).y;\n    }\n  #else\n    float animangle = .7*sin(iTime*.2);\n    if (iMouse.z > 1.) animangle = ((iMouse.y * 2.) / iResolution.y - 1.) * 1.25;\n    vec2 cs = sin(vec2(1.57,0) + animangle);\n    mat2 R = mat2(cs.x, -cs.y, cs.y, cs.x), r = mat2(1);\n    poseCurr[0] = poseRest[0] + vec2(0, 1.4*cs.y);\n    for (int i = 1; i < njoints; ++i)\n        poseCurr[i] = poseCurr[i-1] + (r = r * R) * (poseRest[i] - poseRest[i-1]);\n  #endif\n}\n\n// distance to line segment ab from p\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a;\n    return length(p - b*clamp(dot(p,b) / max(1e-3,dot(b,b)), 0., 1.));\n}\n\nfloat tnoise(vec2 p)\n{\n    return texture(iChannel1, p).x * 2. - 1.;\n}\n\nfloat dshape(vec2 p)\n{\n    float dcap = dseg(p, vec2(-1,0), vec2(1,0));\n    dcap -= .25;\n    dcap += tnoise(p*32./iChannelResolution[1].y) * .03;\n    return dcap;\n}\n\nmat2 bone(int j, vec2[njoints] pose)\n{\n    return mat2(pose[max(0, poseConnect[j])], pose[j]);\n}\n\nmat2 inv(mat2 m)\n{\n  #if 1\n    // scaling m rows then transposing seems identical to inverse, as expected\n    m[0] /= dot(m[0],m[0]);\n    m[1] /= dot(m[1],m[1]);\n    mat2 i = transpose(m);\n  #else\n    // in other words, I'm pretty sure it's *not* the inverse implementation, after all.\n    mat2 i = inverse(m);\n  #endif\n    return i;\n}\n\nmat2 joint2world(mat2 bon)\n{\n   vec2 a = bon[0]\n      , b = bon[1]\n    , r = b - a;\n    if (dot(r,r) < 1e-7) r = vec2(1,0); // bugfix: avoid divide by zero!\n    vec2 d = normalize(r);\n    return mat2(r, vec2(-d.y, d.x));\n}\n\nvec2 worldToJoint(vec2 p, int j, vec2[njoints] pose)\n{\n\tmat2 b = bone(j, pose); // the two relevant segment points of the joint\n    mat2 j2w = joint2world(b);\n    return inv(j2w) * (p - b[0]);\n}\n\nvec2 jointToWorld(vec2 p, int j, vec2[njoints] pose)\n{\n\tmat2 b = bone(j, pose); // the two relevant segment points of the joint\n    mat2 j2w = joint2world(b);\n    return j2w * p + b[0];\n}\n\nconst float jointpoof = .01;\n\n// I was using custom meshes for the bones\n// but iq's sdRoundCone would be quite appropriate here\nfloat djoint(vec2 q, int i, vec2[njoints] pose)\n{\n    return dseg(q, pose[i], pose[max(0, poseConnect[i])]) - jointpoof;\n}\n\nfloat dAllJoints(vec2 q)\n{\n    float d = 3.4e38;\n    for (int i = njoints; i-- > 0; )\n        d = min(d, djoint(q, i, poseCurr));\n    return d;\n}\n\nvoid drawArrow(inout vec3 c, vec2 q, vec2 d, vec3 tint, float w)\n{\n    float s = dseg(q, vec2(0), d) - w;\n    float cov = clamp(.5 - .5*iResolution.y * s, 0., 1.);\n    c = mix(c, tint, cov);\n}\n\nvoid drawTripod(inout vec3 c, vec2 q, mat3x2 m)\n{\n    q -= m[2]; float w = 1.5/iResolution.y;\n    drawArrow(c, q, m[0], vec3(1,0,0), w);\n    drawArrow(c, q, m[1], vec3(0,1,0), w);\n//    drawArrow(c, q-m[0], m[1], vec3(0,0,1), w);\n}\n\n// how many bone weights to consider per pixel\nconst int nclosest = 2;\n\n// can adjust weighting falloff; helps isolate the bone influences.\nfloat hackw(float d, float d0)\n{\n     return pow(max(0., d), 2.); //max(0., d); //\n}\n    //d - d0; //d; // // HACK bring closest in to zero distance for weighting calcs\n\n// refactored merely to simplify closestJoints logic\nvoid insertCloser(int i, float d0, inout int[nclosest] n, inout float[nclosest] d)\n{\n\tfor (int j = 0; j < nclosest; ++j) {\n\t   \tif (d0 < d[j]\n\t\t || (d0 == d[j] && n[j] > i) // ties go to the smaller index\n\t\t//|| (d0 == 0. && d[j] == 0. && poseConnect[i] <= j)\n\t\t) {\n\t\t\tfor (int k = nclosest-1; --k >= j; ) { // insert, shift down\n\t\t\t\td[k+1] = d[k];\n\t\t\t\tn[k+1] = n[k];\n\t\t\t}\n\t\t\tn[j] = i; // insert\n\t\t\td[j] = d0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// track closest joints for weighting\nvoid closestJoints(vec2 q\n     , out   int[nclosest] n\n     , out float[nclosest] d\n     , out float[nclosest] w)\n{    \n    for (int j = nclosest; j-- > 0; ) {\n        n[j] = 0;\n        d[j] = 3.4e38;\n    }\n\t// for each animated joint,\n    for (int i = njoints; i-- > 0; ) {\n\t    // compute distance to pixel\n    \tfloat d0 =\n            poseConnect[i] < 0 \n            ? 3.4e38\n            : djoint(q, i, poseCurr);\n        d0 = max(d0, 0.);\n        insertCloser(i, d0, n, d);\n    }\n    for (int j = nclosest; j-- > 0; )\n        d[j] = max(0., d[j]); // seg poofed, can be negative\n    float t = 0.; // total distances for weighting\n    for (int j = nclosest; j-- > 0; )\n        t += hackw(d[j], d[0]);\n    t = max(t, 1e-3);\n    for (int j = nclosest; j-- > 0; ) {\n        w[j] = clamp((t - hackw(d[j], d[0])) / t, 0., 1.);\n    }\n    // TODO I may need to take bone relative angle vs. rest pose angle\n    // into account for the weighting to handle the scaling issues.\n // simply normalize the weights wrt one again, and handle special case of failure\n    float wtotal = 0.;\n    for (int j = nclosest; j-- > 0; )\n        wtotal += w[j];\n    if (wtotal == 0.)\n        w[0] = 1.;\n    else\n    for (int j = nclosest; j-- > 0; )\n        w[j] /= wtotal;\n}\n\nvec2 mapToRestPose(vec2 q\n     ,   int[nclosest] n\n     , float[nclosest] w)\n{\n    // trying to sum weighted position in rest pose from nearest joints\n    vec2 c = vec2(0);\n    for (int ci = nclosest; ci-- > 0; ) {\n        int i = n[ci];\n    \tvec2 l = worldToJoint(q, i, poseCurr);\n        c += jointToWorld(l, i, poseRest) * w[ci];\n    }\n    return c;\n}\n\n\nvec3 jointColor(int j)\n{\n    return max(vec3(0), cos(10.2*float(j) + vec3(0,2,4)));\n}\n\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy\n    , q = (p + p - r) / r.y;\n    q *= 1.25; // zoom so animation doesn't move offscreen HACK\n    vec3 c = .5 + .5*cos(iTime+q.xyx+vec3(0,2,4));\n    InitPoseCurr();\n\tfloat da = dAllJoints(q);\n\n      int[nclosest] n;\n    float[nclosest] d;\n    float[nclosest] w;\n    closestJoints(q, n, d, w);\n    vec2 qrest = mapToRestPose(q, n, w);\n    float cov = .5 - .5/32.*iResolution.y*dshape(qrest);\n    cov = clamp(cov, 0., 1.);\n  //  cov = pow(cov, 16.); // reshape curve of alpha falloff?\n        \n    vec3 tex = texture(iChannel0, qrest * 2.).rgb;\n    tex = pow(tex, vec3(2.2)); // from sRGB gamma\n   #if 0 // DEBUG visualize the weights, falloff\n    tex = vec3(0); for (int i = 0; i < nclosest; ++i) tex += cov*w[i]/float(nclosest) * jointColor(n[i]);\n   #endif\n    c = mix(c, tex, cov); //c *= cov; //\n   #if 1 // debug - draw all joints, and/or their coordinate frames\n    float danim = fract((sin(iTime*.2)*.5 + .5) * 3.);\n    if (iMouse.z <= 0.)\n    for (int i = 0; i < njoints; ++i) {\n        if (poseConnect[i] < 0) continue;\n\t\tmat2 b = bone(i, poseCurr); // the two relevant segment points of the joint\n   \t\tmat2 j2w = joint2world(b);\n        if (false || danim > .5 && danim < .7)\n        drawTripod(c, q, mat3x2(j2w[0], j2w[1], b[0]));\n    \t// outline the bone shape capsules\n        if (false || danim > .1 && danim < .4)\n        c += exp2(-iResolution.y*2.*abs(da - 0.*jointpoof)); // in white\n    //    c *= 1.-exp2(-iResolution.y*1.*abs(da - 0.*jointpoof)); // in black\n    }\n   #endif\n    c = pow(c, vec3(.4545)); // to sRGBish gamma\n    o = vec4(c, 1);\n}\n\n\n#if 0 // a lot of debugging crap when I was working on the weighting\n   #if 0 // HACK only keep closest bone, so I can debug that\n    for (int j = 1; j < nclosest; ++j) d[j] = 9e9;\n   #endif\n    // FIXME weighting borked; if only use closest bone,\n    // full weighting, it looks as expected.\n    // they should all add up to 1.0\n  #if 0 // HACK force nearest two both to .5, rest to 0.\n    // actually seems very similar to what I've been seeing,\n    // so I expect this is what's happening, that \n    // it's being averaged out so they all incorrectly get influence always\n    for (int j = 2; j < nclosest; ++j)\n        w[j] = 0.;\n    w[0] = w[1] = .5;\n  #elif 0 // HACK force nearest to 1., rest to 0.\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n    w[0] = 1.;\n  #elif 0 // even MOAR HACK - either 100,100,0 or 100,0,0\n    // at least it doesn't appear discontiguous!\n    // or at least it didn't!  but now is.  :(\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n\tif (d[0] - d[1] > -.001)    \n\t    w[0] = w[1] = 1.;\n    else\n        w[0] = 1.;\n  #elif 0 // MOAR HACK - either 80,80,0, or 100,0,0\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n\tif (d[0] - d[1] > -.001)    \n\t    w[0] = w[1] = .6;\n    else\n        w[0] = 1.;\n  #elif 0 // HACK either 50/50 or 100% - does not work as expected, for sure.  :(\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n\tif (d[0] - d[1] > -.001)    \n\t    w[0] = w[1] = .5;\n    else\n        w[0] = 1.;\n  #elif 0 // HACK any nonzero weight is set to 100%,\n    // because 100% is the only mapping that works.\n    // However, this approach does not work.  :(\n    for (int j = 0; j < nclosest; ++j)\n  \t\tif (w[j] > 0.) w[j] = 1.;  \n  #endif\n#endif\n\n","name":"Image","description":"","type":"image"}]}