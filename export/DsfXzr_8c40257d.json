{"ver":"0.1","info":{"id":"DsfXzr","date":"1668417144","viewed":101,"name":"Evolute Plotter (explicit)","username":"Envy24","description":"Template for plotting evolute for explicit functions.\nRedefine explicit(x), SCENE_SCALE, x0, to.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["template","plotter","curvature","graphs","explicit","evolute"],"hasliked":0,"parentid":"DsXXRr","parentname":"Curvature Plotter (explicit)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define SCENE_SCALE               ( 4.5 )\n#define RANGE                     ( AR*SCENE_SCALE )\n#define UNIT                      ( 3.*SCENE_SCALE / R.y )           // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define ORIGIN                    ( vec2(0) )\n\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat explicit(float x) { return sin(x)*x*x*0.1; }\nfloat dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.1; // or 1./128.\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n    /*Analytic derivative.*\n    return 0.1*(cos(x)*x*x+sin(x)*2.*x);\n    /**/\n}\nvec2 tangent(float x) { return vec2(1., dydx(x)); }\nvec2 gradient(float x) { return vec2(1., dydx(x)); }\nvec2 normal(float x) { vec2 T = tangent(x); return vec2(-T.y, T.x); }\nfloat ddydxx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.1; // or 1./64.\n    return (dydx(x+dx) - dydx(x-dx) ) / (2.*dx);\n    /*Analytic derivative.*\n    return 0.1*(4.*x*cos(x)-x*x*sin(x)+2.*sin(x));\n    /**/\n}\n/**/\nvec2 curvature(float t)\n{\n    float a = dydx(t), b = 1. + a*a,\n          K = ddydxx(t)/sqrt(b*b*b),\n          ROC = 1./K; // radius of curvature \n\n    return vec2(K, ROC);\n}\n/* mla's variant *\nvec2 curvature(float t) {\n  float eps = 0.1;\n  float f0 = explicit(t-eps), f1 = explicit(t), f2 = explicit(t+eps);\n  f0 -= f1; f2 -= f1;\n  vec2 c0 = vec2(-eps,f0), c2 = vec2(eps,f2);\n  vec3 circle = cross(vec3(c2,dot(c2,c2)), vec3(c0,dot(c0,c0)));\n  float k = 2.0*circle.z/length(circle.xy);\n  return vec2(k,1.0/k);\n}\n/**/\n\nvec2 evolute(float t)\n{\n    float a = dydx(t), b = ddydxx(t),\n          y = explicit(t),\n          x_offs = (a*(1.+a*a))/b,\n          y_offs = (1.+a*a)/b;\n    return vec2(t-x_offs, y+y_offs);\n}\n\nfloat evolute_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = evolute(linear_remap(from.x, from.x, from.y, to.x, to.y));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from.x, from.y, to.x, to.y);\n    \n        vec2 E = evolute(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    //float thickness = sinOSC(-5., 20., iTime)/R.y;\n    return minimal_distance;//-thickness;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n\n\n    /* Explicit function y=f(x) */\n         color = mix(color, vec3(1,0,0), draw_explicit_func(NDC, explicit(NDC.x), dydx(NDC.x)));\n\n\n\n    /* Define x0 */\n    float x0 = sinOSC(-RANGE, RANGE, iTime*0.15) * 0.5;\n\n\n\n    /* Evolute (parametric). */\n    vec2 from = vec2(-RANGE, RANGE), to = vec2(-4, 4);\n    color = mix( color, vec3(0,0.5,0.5), SMAA(evolute_sdf(NDC, from, to, 256.)) );\n\n\n\n    /* Circle of curvature. */\n    float y0 = explicit(x0);\n    vec2 data = curvature(x0);\n    vec2 C = vec2(x0, y0) + normalize(normal(x0))*data.y;   \n    color = mix(color, vec3(0,0,1), SMAA(abs(diskSDF_L2(NDC, C, abs(data.y)))) );\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(x0, y0), 2.*UNIT)) );\n    color = mix(color, vec3(0,0,0), SMAA(diskSDF_L2(NDC, C, 2.*UNIT)) );\n\n\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat linear_remap(\n    float val,\n    float fl,\n    float fr,\n    float tl,\n    float tr)\n{\n    val = (val - fl) / (fr - fl); // inverse linear map from [fl; fr] to [0; 1].\n    return val * (tr - tl) + tl;  // linear map from [0; 1] to [tl; tr].\n}","name":"Common","description":"","type":"common"}]}