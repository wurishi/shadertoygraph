{"ver":"0.1","info":{"id":"4tyXWc","date":"1486096858","viewed":90,"name":"Funky","username":"skimberk1","description":"Slowly learning","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define INFINITY 99999999999999999999999999999.0\n#define EPSILON 1.0\n#define MAX_STEPS 32\n\nfloat cube(vec3 p) {\n  return length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n}\n\nfloat opTwist(vec3 p) {\n  float c = cos(10.0 * p.y);\n  float s = sin(10.0 * p.y);\n  mat2  m = mat2(c, -s, s, c);\n  vec3  q = vec3(m * p.xz, p.y);\n  return cube(q);\n}\n\nfloat distanceFunction(vec3 pos) {\n  vec3 translatedPos = pos - vec3(3.0 * sin(1.0 * iTime), 2.0 * cos(1.0 * iTime), 2.0);\n\n  return opTwist(translatedPos);\n}\n\nvec3 createRay(vec2 pos) {\n  return normalize(vec3(pos, 1.0 / tan(M_PI / 8.0)));\n}\n\nvec3 approximateNormal(vec3 pos) {\n  float x = distanceFunction(vec3(pos.x + EPSILON, pos.y, pos.z))\n            - distanceFunction(vec3(pos.x - EPSILON, pos.y, pos.z));\n\n  float y = distanceFunction(vec3(pos.x, pos.y + EPSILON, pos.z))\n            - distanceFunction(vec3(pos.x, pos.y - EPSILON, pos.z));\n\n  float z = distanceFunction(vec3(pos.x, pos.y, pos.z + EPSILON))\n            - distanceFunction(vec3(pos.x, pos.y, pos.z - EPSILON));\n\n  return normalize(vec3(x, y, z));\n}\n\nvec3 march(vec3 origin, vec3 direction) {\n  vec3 pos = origin;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float distance = distanceFunction(pos);\n\n    pos += 0.6 * distance * direction;\n\n    if (distance < EPSILON) {\n      return pos;\n    }\n  }\n\n  return vec3(INFINITY);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 vPos = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n  vPos.x *= iResolution.x / iResolution.y;\n\n  vec3 origin = vec3(vPos, 0.0);\n  vec3 direction = createRay(vPos);\n\n  vec3 intersection = march(origin, direction);\n  vec3 normal = approximateNormal(intersection);\n  float distance = length(intersection - origin);\n\n  fragColor = vec4((1.0 + normal.x) / 2.0, (1.0 + normal.y) / 2.0, (1.0 + normal.z) / 2.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}