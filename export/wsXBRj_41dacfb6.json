{"ver":"0.1","info":{"id":"wsXBRj","date":"1588634154","viewed":292,"name":"Chain Link Fence SDF","username":"spalmer","description":"an analytical chain link fence texture, for posterity.  Fades to a transparency in the distance where it would alias.  I'm tired of everyone using poor quality alpha textures!\nLow lod still needs work.  Look with mouse.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","distance","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Chain Link wire fence as a signed distance field.\n// There are probably other kinds of wire fence,\n// but this kind is in use practically everywhere,\n// as it is apparently quite easy to produce.\n// It's really just an example of weaving.\n\n// still some quality work and cleanup to do,\n// but the basics are in and finally working!\n\n// fork of Frosted Glass Window (still private)\n// at https://shadertoy.com/view/WdjyzK\n// see Orbit Camera https://shadertoy.com/view/WlVGD1\n\n// see also Fabrice's try at https://shadertoy.com/view/tdBcW3\n// which is based on blackle's https://shadertoy.com/view/ttG3R1\n// interesting but too round and helixy, not quite right!\n// I didn't use any of their stuff, did something totally different.\n\n#define TFloor     iChannel0\n//#define TBlueNoise iChannel1\n#define TEnviroLo  iChannel2\n#define TEnviro    iChannel3\n\n#define IZERO min(iFrame, 0)\n\nconst int SSAA = 3; //1; //4; //6; // how strong is your GPU?  mine can't handle fullscreen above 3,\n// which actually gives it one sample per pixel in fullscreen here.\n// oh well, I tried!\n\nconst float tau = 2. * acos(-1.); // tau = 2*pi, so tau > pi   :)\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles in fullturns to yaw, pitch in radians\n    angles.y = .5 * clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * tau, 1.));\n} // returns forward vector camera aims along\n\n\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return ro.y <= 0. ? 0. : rd.y >= -5e-3 ? -1. : ro.y / -rd.y;\n}\n\nfloat tracePlaneZ(vec3 ro, vec3 rd)\n{\n    return ro.z / -rd.z;\n}\n\n\nvec3 cScene(vec3 hp) \n{\n\treturn normalize(vec3(vec2(.05) / (30.*length(fwidth(hp.xy))+1e-3) * // aa\n                          sin(128.*(hp.y-abs(hp.x))),                         \t \n                          sign(hp.z))); \n}\n\n// returns distance, objectid\nvec2 traceScene(vec3 ro, vec3 rd)\n{\n    float tplane = tracePlaneY(ro, rd);\n    float twall = tracePlaneZ(ro, rd);\n    float obj = -1.;\n    float d = 3.4e38;\n    if (tplane >= 0. && tplane < d) {\n        obj = 1.; d = tplane;\n    }\n    if (twall >= 0. && twall < d\n       && ro.y + rd.y * twall < 2.) {\n        obj = 2.; d = twall;\n    }\n    return vec2(d, obj);\n}\n\n// low detail in far distance - the trace method currently bypasses most of it\nfloat dWallLo(vec3 p)\n{\n    return length(max(vec3(0), abs(p - vec3(0,0,0)) - vec3(3e38,1,0))) - .1;\n}\n\nfloat dhalflink(vec3 p)\n{\n    vec2 r = sin(tau*.134 + vec2(.25*tau,0));\n    mat2 R = mat2(r.x, -r.y,\n                  r.y,  r.x);\n    vec3 f = p;\n    f.xy = R * f.xy;\n    const float rw = .03; // radius of wire\n    vec3 e = f;\n    float a = length(max(vec2(0), abs(e.yz) - vec2(.72,.0))) - rw;\n   \tfloat d = length(vec2(a, e.x)) - rw;\n    float g = -e.z;\n    return max(d, g);\n}\n\nfloat dlink(vec3 p)\n{\n    return min(dhalflink(p), dhalflink(vec3(-p.x, p.y, -p.z)));\n}\n\nfloat dlinksx4(vec3 p)\n{\n    p.xy += .5;\n    p.xy = fract(p.xy);\n    p.xy -= .5;\n    float d = 3.4e38;\n    for (float j = -.5; j <= .5 + 1e-3; j += 1.)\n    for (float i = -.5; i <= .5 + 1e-3; i += 1.)\n        d = min(d, dlink(p + vec3(i,j,0)));\n    return d;\n}\n\n// high detail close by\nfloat dChainLink(vec3 p)\n{\n    const float tiling = 6.;\n//    float dlo = dWallLo(p);\n//    return dlo; // HACK\n\t//if (dlo > .5) return dlo - .01;\n    const float s = sqrt(.5) * tiling;\n    p = tiling * p;\n    float d = dlinksx4(p);\n    d /= tiling;\n    return d;\n    //return max(d, dlo);\n}\n// hey, at least I got a decent signed distance field for it!\n\n// iq's looped simplex gradient, excellent!\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 q, float normal_precision)\n{\n    float h = normal_precision\n        * sqrt(1./3.) // .5773\n        ;\n    vec3 n = vec3(0);    \n    for (int i = IZERO; i < 4; ++i) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        n += dChainLink(q + e * h) * e;\n    }\n    return normalize(n);\n}\n\nvec3 nChainLink(vec3 p)\n{\n    return sceneNormal(p, .002);\n}\n\n// extremely simple ray marcher just for the chain links\nfloat traceChainLink(vec3 ro, vec3 rd, int niter)\n{\n    float t = 0.;\n    for (int i = IZERO + niter; i-- > 0; ) {\n        vec3 p = ro + rd * t;\n        float d = dChainLink(p);\n        if (d <= 1e-3)\n        \tbreak;\n        t += d;\n    }\n    return t;\n}\n\n// sun light dir\nconst vec3 L = normalize(vec3(.6));\n\nvec4 cWallLo(vec3 p)\n{\n    // TODO some anisotropic lighting fakery\n    return vec4(vec3(.15), .4);\n}\n\nvec4 cWallHi(vec3 p, vec3 rd, float startdepth)\n{\n    float backf = .05 / (abs(rd.z) + 1e-3);\n    float t = traceChainLink(p - rd * backf, rd, 32) - backf;\n    vec3 hp = p + rd * t;\n    if (abs(hp.z) > .1) return vec4(0);    \n    vec3 n = nChainLink(hp)\n        , h = normalize(L - rd);\n    float nl = dot(n, L); // lighting\n    vec3 r = reflect(rd, n);\n    nl = max(nl, 0.);\n    ; // ambient hax\n    float dtotal = startdepth + t\n    , nh = max(0., dot(n, h));\n    vec3 c = vec3(.04 * mix(nl, 1., .05)); // diff - mostly metal, so very little\n    c += .6 * pow(nh, 16.); // spec\n    // could use some AO or self-shadow on the reflection\n    c += .7 * pow(textureLod(TEnviro, r, 2.).rgb, vec3(2.2)); // refl\n    return vec4(c, 1) * exp2(-.2 * max(dtotal - 2., 0.));\n}\n\n// I had an idea for a cheap medium-lod effect\n// using two copies of a half-pattern of links\n// one bumpoffset one way and rotated 45 degrees,\n// and the other bumpoffset and rotated the other way!\n// where they are supposed to join/cross won't look\n// quite right, but you won't be nearby to examine closely.\n\n// TODO rename cChainLink or something \nvec4 cWall(vec3 p, vec3 rd, float d)\n{\n    vec4 clo = vec4(.5), chi = clo;\n    const float dnear = 8., dfar = 16.;\n    float fade = (d - dnear) / (dfar - dnear);\n    if (fade > 0.)\n    \tclo = cWallLo(p);\n    if (fade < 1.)\n        chi = cWallHi(p, rd, d);\n    return mix(chi, clo, clamp(fade, 0., 1.));\n}\n// FIXME fade is tuned for fullscreen;\n// doesn't quite fix the aliasing in small windows\n// needs fwidth somewhere lol, I'll get to it eventually\n\nvec3 cSky(vec3 rd) \n{\n    vec3 glare = pow(max(0., dot(rd, L)), 16.) * vec3(1.3, 1.0, .8);\n   \treturn pow(texture(TEnviro, rd).rgb, vec3(2.2))*.9 + glare;\n}\n\nfloat testShadowChainLink(vec3 p, vec3 l)\n{\n    float t = traceChainLink(p, l, 12);\n    vec3 h = p + l * t;\n    if (abs(h.z) < .03 && t > 0. && h.y < 2.)\n        return 0.;\n    return 1.;\n}\n\nvec3 cPlane(vec3 p)\n{\n    float shadow = 1.;\n    if (dot(p,p) < 2e2\n        && abs(p.z) < 1e1)\n        shadow = testShadowChainLink(p, L);\n    shadow = mix(1., shadow, exp2(-.2*length(p)));\n    shadow = mix(shadow, 1., .1); // just ambient\n    shadow = clamp(shadow, 0., 1.);\n    return pow(texture(TFloor, p.xz).rgb, vec3(2.2)) * shadow;\n}\n\nvec3 cBackground(vec3 ro, vec3 rd)\n{\n    if (rd.y >= 0.)\n        return cSky(rd);\n    float d = ro.y / -rd.y;\n    vec3 p = ro + d * rd;\n    return cPlane(p) * exp2(-.02 * d);\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd)\n{\n    vec3 c = vec3(0.); \n    vec2 hit = traceScene(ro, rd);\n    float d = hit.x;\n    float id = hit.y;\n    vec3 bg = cBackground(ro, rd);\n    if (id != 2.) // only render chain link if hit low lod fence\n        return bg;\n    vec3 p = ro + rd * d;\n    vec4 cl = cWall(p, rd, d);\n    return mix(bg, cl.rgb, cl.a); // alpha blend - premultiplied? idk yet\n}\n\n\nconst float orbit_scale = 2.; // of radius of object\n\n// vogel disc based super sampler\n// handles depth of field, blur, antialiasing effects\n// technique only works well for scenes simple enough\n// to be rendered many times per frame; more complex\n// scenes would require a temp buffer and some CoC work.\nvec3 RenderScene(vec3 ro, vec2 q, mat3 cam, float hfovy\n     , int supersamples, float focuscos, float focaldepth)\n{\n    const float phi = .5*(sqrt(5.) + 1.);\n\tvec3 c = vec3(0); float s = sqrt(max(0., 1. - focuscos*focuscos));\n\tfor (int i = supersamples; --i >= 0; ) {\n\t\tfloat f = (float(i) + .5) / float(supersamples); //float(i) / (float(supersamples) - .5); //\n        float a = phi * tau * f;\n\t\tvec2 vogeldisc = sin(a + vec2(.25*tau, 0)) * sqrt(f) * s;\n\t\tvec3 vd = normalize(vec3(q + vogeldisc, 1./sin(hfovy)))\n\t\t, rd = normalize(cam * vd) // view ray\n        , vj = cam * vec3(vogeldisc,0) // vogel disc jitter in world space\n        , vp = ro - vj * (1. * focaldepth) // + .5/iResolution.y)\n        ;\n\t\tc.rgb += RenderScene(vp, rd);\n\t}\n\treturn c / float(supersamples);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy\n    , M = iMouse.xy\n    , q = StoQ(   p, R)\n    , m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1. && iMouse.z <= 0.)\n        m = vec2(.2 + .02*iTime,-.15); // unattended, mouse in bottom left corner?\n    vec3 object_pos = vec3(0, 1, 0)\n    , camera_dir = OrbitCamera(m)\n    , camera_pos = object_pos - orbit_scale * camera_dir; // LookAt\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = tau/12.;\n    int ss = SSAA;\n    if (R.y > 1000.) ss /= 2;\n    else if (R.y > 600.) --ss;\n    if (iTimeDelta >= .034) ss = 1;\n    ss = max(ss, 1);\n    float \n        blur = 2. //4. //1. //0. //8. //\n      , foclen = mix(abs(camera_pos.z), orbit_scale, .5); //abs(camera_pos.z) + .2 //.5 //\n      ;\n    c.rgb = RenderScene(camera_pos, q, cam, hfovy\n            , ss, cos(hfovy * blur/iResolution.y), foclen);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // srgb-ish gamma output\n    c.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}