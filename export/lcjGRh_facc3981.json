{"ver":"0.1","info":{"id":"lcjGRh","date":"1703922815","viewed":38,"name":"moebius_transform_loxodromic","username":"hissanova","description":"Praticing writing moebius transformations.\nI used traditional Japanese colours.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["loxodrome","moebius","loxodromic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec2[4] K = vec2[4](vec2(-1, 0), vec2(-1, 0),\n                           vec2(1, 0), vec2(-1, 0));\nconst vec2[4] K_ = vec2[4](vec2(-1, 0), vec2(1, 0),\n                           vec2(-1, 0), vec2(-1, 0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    float f = 0.2, t = mod(f*iTime, log(1e9));\n    vec2[4] rot = vec2[4](vec2(cos(t), sin(t)), vec2(0.0, 0.0),\n                          vec2(0.0, 0.0),       vec2(cos(t), -sin(t)));\n    vec2[4] ext = vec2[4](vec2(exp(t), 0), vec2(0.0, 0.0),\n                          vec2(0.0, 0.0),       vec2(1, 0));\n    \n    uv = moebiusTransform(K_, uv);\n    uv = moebiusTransform(rot, uv);\n    uv = moebiusTransform(ext, uv);\n\n    vec3 col;\n    //Paint inside the grids.\n    vec2 wz = vec2(6.0*atan(uv.y, uv.x)/PI, 3.82*log(length(uv)));\n    ivec2 n = ivec2(int(floor(wz.x)), int(floor(wz.y)));\n    if ((n.x+n.y)%2==0){\n        col = USUMIDORI_GREEN;\n    } else {\n        col = NANOHANA_YELLOW;\n    }\n    //Paint the grid segments\n    vec2 eps = abs(fract(wz));\n    float min_dist = min(min(eps.x, eps.y), min((1.-eps.x), (1.-eps.y)));\n    float mixture_l = smoothstep(0.0, 0.05, min_dist);\n    col = mix(NIJI_RED, col, mixture_l);\n    //Paint the loxodromic curve.\n    float lox_width = 0.06, mixture = 1e3; \n    vec3 dists = vec3(abs(eps.x-eps.y), abs(1.+eps.x-eps.y), abs(1.-eps.x+eps.y));\n    for (int i=0;i<3;i++){\n        mixture = min(mixture,smoothstep(0.0, lox_width, dists[i]));\n    }\n    col = mix(KACHIKAESHI_BLUE, col, mixture);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926;\n\n\n//Define complex operations\n#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define conjugate(a) vec2(a.x,-a.y)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n\nvec2[4] mat_prod(vec2[4] m, vec2[4] n){\n    return vec2[4](product(m[0], n[0]) + product(m[1], n[2]),\n                   product(m[0], n[1]) + product(m[1], n[3]),\n                   product(m[2], n[0]) + product(m[3], n[2]),\n                   product(m[2], n[1]) + product(m[3], n[3]));\n}\n\nvec2[4] mat_inv(vec2[4] m){\n    vec2 det = product(m[0], m[3]) - product(m[1], m[2]);\n    return vec2[4](divide(m[3], det),\n                   -divide(m[1], det),\n                   -divide(m[2], det),\n                   divide(m[0], det));\n}\n\nvec2 moebiusTransform(vec2[4] m, vec2 z){\n    return divide((product(m[0], z) + m[1]), \n                  (product(m[2], z) + m[3]));\n}\n\nvec2[4] constructMoebius(vec2 p, vec2 q, vec2 r){\n    // p -> 0, q -> 1, r -> inf\n    vec2 k = divide((q - r), (q - p));\n    return vec2[4](k, - product(p, q), vec2(1,0), -r);\n}\n\n// Cayley matrix and its inverse.\nvec2[4] K1 = vec2[4](vec2(1, 0), vec2(0, -1),\n                         vec2(1, 0), vec2(0, 1));\nvec2[4] K1_ = vec2[4](vec2(0, 1), vec2(0, 1), \n                        vec2(-1, 0), vec2(1, 0));\n\n// Color values are taken from https://www.colordic.org/w\nconst vec3 NIJI_RED = vec3(0xf6,0xbf,0xbc)/255.;\nconst vec3 USUZAKURA_RED = vec3(0xfd,0xef,0xf2)/255.;\nconst vec3 GREEN = vec3(0.0,0.5,0.5) + 0.07;\nconst vec3 HISUI_GREEN = vec3(0x38, 0xb4, 0x8b)/255.;\nconst vec3 HANAROKUSHOU_GREEN = vec3(0x00, 0xa3, 0x81)/255.;\nconst vec3 USUMIDORI_GREEN = vec3(0x69,0xb0,0x76)/255.;\nconst vec3 LAWNGREEN = vec3(124,252,0)/255.;\nconst vec3 YAMABUKI_BRWON = vec3(0xc8, 0x99, 0x32)/255.;\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0); \nconst vec3 KANARIA_YELLOW = vec3(0xeb,0xd8,0x42)/255.;\nconst vec3 KARIYASU_YELLOW = vec3(0xf5,0xe5,0x6b)/255.;\nconst vec3 NANOHANA_YELLOW = vec3(0xff,0xec,0x47)/255.;\nconst vec3 URUSHI_BLACK = vec3(0x0d,0x00,0x15)/255.;\nconst vec3 KACHIKAESHI_BLUE = vec3(0x20,0x37,0x44)/255.;\nconst vec3 SHIRAUMENEZU_WHITE = vec3(0xe5,0xe4,0xe6)/255.;","name":"Common","description":"","type":"common"}]}