{"ver":"0.1","info":{"id":"MXffDl","date":"1729069470","viewed":81,"name":"Quantum Feathering","username":"8InfinityTaco8","description":"Here is a Cool effect I came up with playing around with some math by rotating the rays along the x y axis.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//const float PI = 3.141592;\nconst float fov = 1.; \nconst float raydist = 3.;\n\nfloat sdSphere(vec3 p, float s){\n    return length (p) - s;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2 (c, -s, s, c);\n}\n\n\n//Distance to the Scene\nfloat map(vec3 p){\n    vec3 spherePos = vec3(0.);\n    \n    vec3 a = vec3(sin(iTime) * .2, cos(iTime) * .2, 0); // Sphere position    float sphere = sdSphere(p - spherePos, 1.); // Sphere sdf\n    \n\n    p = fract(p) - .5; //Space Repetition(spaced repetition can be applied to all 3 axes or just a singular axes)\n    p.z = mod (p.z, .25) - .125; // spacing .25\n\n    float sphere = sdSphere(p - spherePos , .2);\n    return min(sphere, 2.);\n}\n\n\nvec3 pallete(float t){\n     vec3 a = vec3(0.500, 0.500, 0.500);\n     vec3 b = vec3(0.500, 0.500, 0.500); \n     vec3 c = vec3(1.000, 1.000, 1.000);\n     vec3 d = vec3(-0.500, 0.333, 0.667);\n\n    return a + b * cos (6.28318*(c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n   vec2 m = vec2(cos(iTime * .4), sin(iTime * .4)); \n\n   \n   //initialization\n   vec3 ro = vec3(0, 0, -raydist); // ray origin\n   vec3 rd = normalize(vec3(uv, fov)); // ray direction\n   vec3 col = vec3(0); // final pixel color\n   \n   float t = 0.; // total distance travelled\n   \n   //vertical camera rotation replace uv with m for mouse\n   ro.yz *= rot2D(atan(-m.y, -m.x));\n   rd.yz *= rot2D(atan(-m.y,-m.x));\n\n   //horizontal camera rotation\n   ro.xz *= rot2D(atan(-m.y, -m.x));\n   rd.xz *= rot2D(atan(-m.y, -m.x));\n   \n   //Raymarching\n   int i;\n   for (i = 0; i < 300; i++){\n       vec3 p = ro + rd * t; // position along the ray\n       \n       p.xy *= rot2D(t*.2 * m.x); // rotate ray around axis\n       \n       p.x *= cos(t*(m.x+1.))*.2;\n\n       p.y += sin(t*(m.y+1.))*.2; //wiggle ray\n       \n   \n       float d = map(p); // current distance to the scene\n       \n       t += d; // \"march\" the ray\n       \n       if (d < 0.001) break;\n       if (d > 300.) break;\n   }\n   \n   //coloring\n   col = vec3(t * 0.2); // color based on distance\n   col = pallete(t * 0.04 + float(i)*.001 + iTime *.4);\n   \n   fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}