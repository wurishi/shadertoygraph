{"ver":"0.1","info":{"id":"DdKyR1","date":"1696126371","viewed":211,"name":"Raindrops on Glass","username":"YeHaike","description":"Raindrops on glass by YeHaike, Copyright YeHaike All Rights Reserved(841660657@qq.com, NonCommercial, No Copy, No Modify)\nRefer to this: https://www.shadertoy.com/view/ltffzl","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["glass","rain","drop","sad","window","droplets","drops","raining"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raindrops on glass by YeHaike, Copyright YeHaike All Rights Reserved(841660657@qq.com, NonCommercial, No Copy, No Modify)\n// ShaderToy: https://www.shadertoy.com/view/DdKyR1\n// Completely reimplemented\n\n// Refer to this: https://www.shadertoy.com/view/ltffzl\n// {\n// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// }\n\n#define RandomSeed 4.3315\n// Number Scale Of Static Raindrops On Same Screen, Range: [0.0, 1.0]\n#define NumberScaleOfStaticRaindrops 0.35\n#define NumberScaleOfRollingRaindrops 0.35\n#define RaindropBlur 0.0\n#define BackgroundBlur 2.0\n#define StaticRaindropUVScale 20.0\n#define RollingRaindropUVScaleLayer01 2.25\n#define RollingRaindropUVScaleLayer02 2.25\n\n//\n//////////////////// 3D OpenSimplex2S noise with derivatives  ////////////////////\n//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////\n\n// Permutation polynomial hash credit Stefan Gustavson\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 os2NoiseWithDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 os2NoiseWithDerivatives_Fallback(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = os2NoiseWithDerivativesPart(X) + os2NoiseWithDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Might be good for terrain, or a time varying X/Y plane. Z repeats.\nvec4 os2NoiseWithDerivatives_ImproveXY(vec3 X) {\n    \n    // Not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    vec4 result = os2NoiseWithDerivativesPart(X) + os2NoiseWithDerivativesPart(X + 144.5);\n    \n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n//\n\n\nfloat GradientWave(float b, float t) \n{\n\treturn smoothstep(0., b, t)*smoothstep(1., b, t);\n}\n\nfloat Random(vec2 UV, float Seed) \n{\n    return fract(sin(dot(UV.xy*13.235, vec2(12.9898,78.233)) * 0.000001) * 43758.5453123 * Seed);\n}\n\nvec3 RandomVec3(vec2 UV, float Seed) \n{\n    return vec3(Random(UV, Seed), Random(UV * 2.0, Seed), Random(UV * 3.0, Seed));\n}\n\nvec4 RandomVec4(vec2 UV, float Seed) \n{\n    return vec4(Random(UV * 1.5, Seed), Random(UV * 2.5, Seed), Random(UV * 3.5, Seed), Random(UV * 4.5, Seed));\n}\n\nvec3 RaindropSurface(vec2 XY, float DistanceScale, float ZScale)\n{\n    /*\n    Given the following equation, where A,M, N and S are all constants and Z and t are intermediate variables.\n    \n    YeHaike's raindrop(Raindrop on glass) surface equation:\n    \n        Z = (1-(x/A)^2-(y/A)^2)^(A/2) \n        t=min(max((Z-M)/(N-M),0.0),1.0) \n        z=S*(t^2)*(3.0-2.0*t)\n    \n    Find the derivative of z with respect to x and y:\n    \n        t(x, y) = min(max(((1 - (x/A)^2 - (y/A)^2)^(A/2) - M) / (N - M), 0.0), 1.0)\n        N = 1.5\n        M = 0.5\n\n        When 0.0 < (Z - M)/(N - M) < 1.0：\n\n        ∂z/∂x = S*(6t - 8t^2) * (1/(N - M)) * (-x/A*(1 - (x/A)^2 - (y/A)^2)^((A/2)-1))\n\n        When (Z - M)/(N - M) ≤ 0.0 or (Z - M)/(N - M) ≥ 1.0：\n\n        ∂z/∂x = 0\n        \n        Similarly, we can find the partial derivative of z with respect to y：\n\n        When 0.0 < (Z - M)/(N - M) < 1.0：\n\n        ∂z/∂y = S*(6t - 8t^2) * (1/(N - M)) * (-y/A*(1 - (x/A)^2 - (y/A)^2)^((A/2)-1))\n\n        When (Z - M)/(N - M) ≤ 0.0 or (Z - M)/(N - M) ≥ 1.0：\n\n        ∂z/∂y = 0\n\n    This is the partial derivative of z with respect to x and y.\n    */\n    \n    float A = DistanceScale;\n    float x = XY.x;\n    float y = XY.y;\n    float N = 1.5;\n    float M = 0.5;\n    float S = ZScale;\n    \n    float TempZ = 1.0-pow(x/A,2.0)-pow(y/A,2.0);\n    float Z = pow(TempZ, A/2.0);\n    float ZInMAndN = (Z-M)/(N-M);\n    float t = min(max(ZInMAndN, 0.0), 1.0);\n    \n    float Height = S*t*t*(3.0-2.0*t);\n    \n    float Part01 = S*(6.0*t - 8.0*t*t);\n    float Part02 = 1.0/(N - M);\n    float Part03 = -1.0/A*pow(TempZ,A/2.0-1.0);\n    \n    float Part03OfX = x*Part03;\n    float Part03OfY = y*Part03;\n    \n    float TempValue = (ZInMAndN > 0.0 && ZInMAndN < 1.0) ? Part01*Part02 : 0.0;\n    \n    float PartialDerivativeX=TempValue*Part03OfX;\n    float PartialDerivativeY=TempValue*Part03OfY;\n    vec2 PartialDerivative = Height > 0.0 ? vec2(PartialDerivativeX, PartialDerivativeY) : vec2(0.0,0.0);\n    return vec3(Height, PartialDerivative);\n}\n\n// Map to range and clamp to [0.0,1.0]\nfloat MapToRange(float edge0, float edge1, float x)\n{\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t;\n}\n\n// x is in [0.0,1.0]\nfloat ProportionalMapToRange(float edge0, float edge1, float x)\n{\n    float t = edge0+(edge1-edge0)*x;\n    return t;\n}\n\n\n// Return: x is height; yz is normal\n// UVScale: Default is 20.0\nvec3 StaticRaindrops(vec2 UV, float Time, float UVScale) \n{\n    vec2 TempUV = UV;\n\tTempUV *= UVScale; //15.0\n       \n    vec2 ID = floor(TempUV);\n    vec3 RandomValue = RandomVec3(vec2(ID.x*470.15, ID.y*653.58), RandomSeed);\n    TempUV = fract(TempUV)-0.5;\n    vec2 RandomPoint = (RandomValue.xy-0.5)*0.25;\n    vec2 XY = RandomPoint - TempUV;\n    float Distance = length(TempUV-RandomPoint);  \n    \n    vec3 X = vec3(vec2(TempUV.x*305.0*0.02, TempUV.y*305.0*0.02), 1.8660254037844386);\n    vec4 noiseResult = os2NoiseWithDerivatives_ImproveXY(X);\n    float EdgeRandomCurveAdjust = noiseResult.w*mix(0.02, 0.175, fract(RandomValue.x));\n    \n    Distance = EdgeRandomCurveAdjust*0.5+Distance;\n    Distance = Distance* clamp(mix(1.0, 55.0,RandomPoint.x),1.0, 3.0);\n    float Height = smoothstep(.2, 0., Distance);\n    \n    float GradientFade = GradientWave(.0005, fract(Time*0.02+RandomValue.z));\n    \n    float DistanceMaxRange =  1.45 * GradientFade;\n    vec2 Direction = (TempUV-RandomPoint);\n    \n    float Theta = 3.141592653-acos(dot(normalize(Direction), vec2(0.0,1.0)));\n    Theta = Theta * RandomValue.z;\n    float DistanceScale = 0.2/(1.0-0.8*cos(Theta-3.141593/2.0-1.6));\n    float YDistance = length(vec2(0.0,TempUV.y)-vec2(0.0,RandomPoint.y));\n    \n    float NewDistance = MapToRange(0.0,DistanceMaxRange*pow(DistanceScale,1.0),Distance);\n\n    float Scale = 1.65*(0.2+DistanceScale*1.0)*DistanceMaxRange*mix(1.5,0.5,RandomValue.x);\n    vec2 TempXY = vec2(XY.x*1.0,XY.y)*4.0;\n    float RandomScale = ProportionalMapToRange(0.85,1.35,RandomValue.z);\n    TempXY.x = RandomScale*mix(TempXY.x ,TempXY.x / smoothstep(1.0,0.4,YDistance*RandomValue.z),smoothstep(1.0,0.0,RandomValue.x));\n    TempXY = TempXY + EdgeRandomCurveAdjust*1.0;\n    vec3 HeightAndNormal = RaindropSurface(TempXY, Scale,1.0);\n    HeightAndNormal.yz = -HeightAndNormal.yz;\n    \n    float RandomVisible = (fract(RandomValue.z*10.*RandomSeed) < NumberScaleOfStaticRaindrops ? 1.0f : 0.0f);\n    HeightAndNormal.yz = HeightAndNormal.yz*RandomVisible;\n    HeightAndNormal.x = smoothstep(0.0, 1.0, HeightAndNormal.x)*RandomVisible;\n\n    return HeightAndNormal;\n}\n\n\n// Return: x is height; yz is normal; w is trail.\n// UVScale: Default is 2.25\nvec4 RollingRaindrops(vec2 UV, float Time, float UVScale) \n{\n    vec2 LocalUV = UV*UVScale;\n    vec2 TempUV = LocalUV;\n\n    vec2 ConstantA = vec2(6.0, 1.0);\n    vec2 GridNum = ConstantA*2.0;\n    vec2 GridID = floor(LocalUV*GridNum);\n    \n    float RandomFloat = Random(vec2(GridID.x*131.26, GridID.x*101.81), RandomSeed);\n\n    float TimeMovingY = Time*0.85*ProportionalMapToRange(0.1,0.25,RandomFloat); //Time\n    LocalUV.y += TimeMovingY;\n    float YShift = RandomFloat;\n    LocalUV.y += YShift;\n    \n    \n    vec2 ScaledUV = LocalUV*GridNum;\n    GridID = floor(ScaledUV);\n    vec3 RandomVec3 = RandomVec3(vec2(GridID.x*17.32, GridID.y*2217.54), RandomSeed);\n    \n    vec2 GridUV = fract(ScaledUV)-vec2(0.5, 0.0);\n      \n    \n    float SwingX = RandomVec3.x-0.5;\n    \n    float SwingY = TempUV.y*20.0;\n    float SwingPosition = sin(SwingY+sin(GridID.y*RandomVec3.z+SwingY)+GridID.y*RandomVec3.z);\n    SwingX += SwingPosition*(0.5-abs(SwingX))*(RandomVec3.z-0.5);\n    SwingX *= 0.65;\n    float RandomNormalizedTime = fract(TimeMovingY+RandomVec3.z)*1.0; // Time\n    SwingY = (GradientWave(0.87, RandomNormalizedTime)-0.5)*0.9+0.5;\n    SwingY = clamp(SwingY,0.15,0.85);\n    vec2 Position = vec2(SwingX, SwingY);    \n    \n    \n    vec2 XY = Position - GridUV;\n    vec2 Direction = (GridUV-Position)*ConstantA.yx;\n    float Distance = length(Direction);\n   \n    //---------\n    vec3 X = vec3(vec2(TempUV.x*513.20*0.02, TempUV.y*779.40*0.02), 2.1660251037743386);\n    vec4 NoiseResult = os2NoiseWithDerivatives_ImproveXY(X);\n    float EdgeRandomCurveAdjust = NoiseResult.w*mix(0.02, 0.175, fract(RandomVec3.y));\n    \n    Distance = EdgeRandomCurveAdjust+Distance;\n    float Height = smoothstep(.2, 0., Distance);\n    float NewDistance = MapToRange(0.0,0.2,Distance);\n\n    \n    float DistanceMaxRange =  1.45;\n    \n    float Theta = 3.141592653-acos(dot(normalize(Direction), vec2(0.0,1.0)));\n    Theta = Theta * RandomVec3.z;\n    float DistanceScale = 0.2/(1.0-0.8*cos(Theta-3.141593/2.0-1.6));\n    float Scale = 1.65*(0.2+DistanceScale*1.0)*DistanceMaxRange*mix(1.0,0.25,RandomVec3.x*1.0);\n    vec2 TempXY = vec2(XY.x*1.0,XY.y)*4.0;\n    float RandomScale = ProportionalMapToRange(0.85,1.35,RandomVec3.z);\n    TempXY = TempXY*vec2(1.0,4.2) + EdgeRandomCurveAdjust*0.85;\n    vec3 HeightAndNormal = RaindropSurface(TempXY, Scale,1.0);\n\n    //----------\n        \n    // Trail\n    float TrailY = pow(smoothstep(1.0, SwingY, GridUV.y), 0.5);\n    float TrailX = abs(GridUV.x-SwingX)*mix(0.8,4.0,smoothstep(0.0,1.0,RandomVec3.x));\n    float Trail = smoothstep(0.25*TrailY, 0.15*TrailY*TrailY, TrailX);\n    float TrailClamp = smoothstep(-0.02, 0.02, GridUV.y-SwingY);\n    Trail *= TrailClamp*TrailY;\n    \n    float SignOfTrailX = sign(GridUV.x-SwingX);\n    vec3 NoiseInput = vec3(vec2(TempUV.x*513.20*0.02*SignOfTrailX, TempUV.y*779.40*0.02), 2.1660251037743386);\n    vec4 TrailNoiseResult = os2NoiseWithDerivatives_ImproveXY(NoiseInput);\n    float TrailEdgeRandomCurveAdjust = TrailNoiseResult.w*mix(0.002, 0.175, fract(RandomVec3.y));\n    float TrailXDistance = MapToRange(0.0,0.1,TrailEdgeRandomCurveAdjust*0.5+TrailX);\n    vec2 TrailDirection = SignOfTrailX*vec2(1.0,0.0) + vec2(0.0,1.0)*smoothstep(1.0, 0.0,Trail)*0.5;\n    vec2 TrailXY = TrailDirection*1.0*TrailXDistance;\n \n    vec3 TrailHeightAndNormal = RaindropSurface(TrailXY, 1.0,1.0);\n    \n    TrailHeightAndNormal = TrailHeightAndNormal * pow(Trail*RandomVec3.y, 2.0);\n    TrailHeightAndNormal.x = smoothstep(0.0, 1.0, TrailHeightAndNormal.x);\n    \n    //fragColor = vec4(TrailHeightAndNormal.yz,0.0, 1.0);\n    \n    // Remain Trail Droplets\n    SwingY = TempUV.y;\n    float RemainTrail = smoothstep(0.2*TrailY, 0.0, TrailX);\n    float RemainDroplet = max(0.0, (sin(SwingY*(1.0-SwingY)*120.0)-GridUV.y))*RemainTrail*TrailClamp*RandomVec3.z;\n    SwingY = fract(SwingY*10.0)+(GridUV.y-0.5);\n    vec2 RemainDropletXY= GridUV-vec2(SwingX, SwingY);\n    RemainDropletXY = RemainDropletXY * vec2(1.2,0.8);\n\n    RemainDropletXY = RemainDropletXY + EdgeRandomCurveAdjust*0.85;\n    vec3 RemainDropletHeightAndNormal = RaindropSurface(RemainDropletXY, 2.0*RemainDroplet,1.0);\n    \n    RemainDropletHeightAndNormal.x = smoothstep(0.0, 1.0, RemainDropletHeightAndNormal.x);\n    RemainDropletHeightAndNormal = TrailHeightAndNormal.x > 0.0 ? vec3(0.0,0.0,0.0) : RemainDropletHeightAndNormal;\n    \n    \n    vec4 ReturnValue;\n    ReturnValue.x = HeightAndNormal.x + TrailHeightAndNormal.x*TrailY*TrailClamp + RemainDropletHeightAndNormal.x*TrailY*TrailClamp;\n    \n    ReturnValue.yz = HeightAndNormal.yz + TrailHeightAndNormal.yz + RemainDropletHeightAndNormal.yz;\n    ReturnValue.w = Trail;\n    \n    float RandomVisible = (fract(RandomVec3.z*20.*RandomSeed) < NumberScaleOfRollingRaindrops ? 1.0f : 0.0f);\n    ReturnValue = ReturnValue * RandomVisible;\n    return ReturnValue;\n\n}\n\nvec4 Raindrops(vec2 UV, float Time, float UVScale00, float UVScale01, float UVScale02) \n{\n    vec3 StaticRaindrop = StaticRaindrops(UV, Time, UVScale00);\n    vec4 RollingRaindrop01 = RollingRaindrops(UV, Time, UVScale01);\n    //vec4 RollingRaindrop02 = RollingRaindrops(UV*1.7, Time, UVScale02);\n\n    \n    float Height = StaticRaindrop.x + RollingRaindrop01.x;// + RollingRaindrop02.x;\n    vec2 Normal = StaticRaindrop.yz + RollingRaindrop01.yz;// + RollingRaindrop02.yz;\n    float Trail = RollingRaindrop01.w;//(RollingRaindrop01.w + RollingRaindrop02.w)*0.5;\n    \n    return vec4(Height, Normal, Trail);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Time = iTime;\n    float ScaledTime = Time*0.2;\n    vec2 GlobalUV = fragCoord.xy/iResolution.xy;\n\tvec2 LocalUV = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\n    float RaindropsAmount = sin(Time*0.25)*0.5+0.5;\n    \n    float MaxBlur = mix(BackgroundBlur, BackgroundBlur*2.0, RaindropsAmount);\n    float MinBlur = RaindropBlur;\n       \n    float StaticRaindropsAmount = smoothstep(-0.5, 1.0, RaindropsAmount)*2.0;\n    float RollingRaindropsAmount01 = smoothstep(0.25, 0.75, RaindropsAmount);\n    float RollingRaindropsAmount02 = smoothstep(0.0, 0.5, RaindropsAmount);\n    \n    //\n    vec4 Raindrop = Raindrops(LocalUV, Time,\n        StaticRaindropUVScale, RollingRaindropUVScaleLayer01, RollingRaindropUVScaleLayer02); \n    //\n    \n    float RaindropHeight = Raindrop.x;\n    float RaindropTrail = Raindrop.w;\n    vec2 RaindropNormal = -Raindrop.yz;\n    RaindropNormal = RaindropHeight > 0.0 ? RaindropNormal*0.15 : vec2(0.0,0.0);\n\n    vec2 UVWithNormal = GlobalUV+RaindropNormal;\n    float EdgeColorScale = smoothstep(0.2, 0.0, length(RaindropNormal));\n    EdgeColorScale = RaindropHeight > 0.0 ? pow(EdgeColorScale,0.5)*0.2 + 0.8 : 1.0;\n\n    float Blur = mix(MinBlur, MaxBlur, smoothstep(0.0, 1.6, length(RaindropNormal)));\n    Blur = RaindropHeight > 0.0 ? Blur : MaxBlur;\n    Blur = ProportionalMapToRange(MinBlur, Blur, 1.0 - RaindropTrail);\n    EdgeColorScale = pow(EdgeColorScale, 0.85);\n    \n    vec3 FinalColor = textureLod(iChannel0, UVWithNormal, Blur).rgb * EdgeColorScale;\n    \n    fragColor = vec4(FinalColor, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}