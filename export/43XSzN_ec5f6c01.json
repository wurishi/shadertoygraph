{"ver":"0.1","info":{"id":"43XSzN","date":"1709411616","viewed":176,"name":"Grid of Life","username":"gwolf","description":"A simplified vesion of https://www.shadertoy.com/view/stsfRN .\nAllows to control size of cells and update frequency.\nPlay video instead of fixed cell color.","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["game","conway","gameoflife","cellularautomata","gol"],"hasliked":0,"parentid":"stsfRN","parentname":"Conway's Shader of Life"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float neighbor(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0).x;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 xy = ivec2(fragCoord);\n    vec4 f = texelFetch(iChannel0, xy, 0);\n    float state = f.x;\n    \n    // Compute time at which next update should be calculated\n    float nextTime = iFrame != 0 ? f.z : 0.0;\n    \n    // Only update if next time period reached\n    float newState = 0.0;\n    if (iTime >= nextTime)\n    {\n        float c = neighbor(xy.x - 1, xy.y - 1);\n        c+= neighbor(xy.x + 1, xy.y + 1);\n        c+= neighbor(xy.x - 1, xy.y    );\n        c+= neighbor(xy.x    , xy.y - 1);\n        c+= neighbor(xy.x + 1, xy.y    );\n        c+= neighbor(xy.x    , xy.y + 1);\n        c+= neighbor(xy.x - 1, xy.y + 1);\n        c+= neighbor(xy.x + 1, xy.y - 1);\n        \n        // A cell is born\n        if (c >= 2.5 && c <= 3.5) {newState = 1.0;}\n        // Cell stays alive\n        if (state > 0.5 && c >= 1.5 && c <= 2.5) {newState = 1.0;}\n        \n        // Update time counter\n        nextTime = nextTime + kStep < iTime ? iTime + kStep : nextTime + kStep;\n    } else {\n        newState = state;\n    }\n\n    // Random initialization\n    if (iFrame == 0) {\n        float t = mod(iTime, 83.10928) + 1e-3 * float(xy.y * nbCols + xy.x);\n        newState = fract(sin(mod(91.3458 * t, 6.28318530718)) * 47453.5453) > 0.8 ? 1.0 : 0.0;\n    }\n\n    fragColor = vec4(newState, 0.0, nextTime, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int nbRows = 9;\nconst int nbCols = 16;\nconst float kStep = 1.0/4.0;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Set background color\n    vec4 backgroundColor = vec4(0.0);\n    \n    // Compute size of grid\n    int size = min(int(iResolution.x) / nbCols,\n                   int(iResolution.y) / nbRows);\n    \n    ivec2 xy = ivec2(fragCoord.x, iResolution.y - fragCoord.y);\n    \n    // Return background color if not in grid\n    if (any(greaterThanEqual(xy, size * ivec2(nbCols, nbRows))))\n        fragColor = backgroundColor;\n    else {    \n        // Compute size of cell and cell border\n        ivec2 cell = xy / size;\n        ivec2 border = xy % size;\n        border = min(border, size - border);\n        float b = float(min(border.x, border.y));\n\n        // Read state from buffer\n        float f = texelFetch(iChannel0, cell, 0).x;\n\n        vec3 color;\n        vec2 uv = (fragCoord)/iResolution.xy;\n        if (f == 0.0 || b <= 0.04 * float(size))\n            color =  texture(iChannel2, uv).rgb * sin(iTime);\n        else\n        {\n            // color = vec3(0.5, 0.88, 0.4);\n            color = texture(iChannel1, uv).rgb;\n        }\n        fragColor.xyz = color;\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}