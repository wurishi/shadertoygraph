{"ver":"0.1","info":{"id":"fdy3zK","date":"1631791121","viewed":192,"name":"Spherical SSAO","username":"yunhai","description":"left is after SSAO,right is clear,\ntry to open ’SSAO_ALL‘ in ’Common‘\nso it's whole sphere sampled\n still many detail to optimise, though it's really fast\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["postprocess","ssao"],"hasliked":0,"parentid":"NdG3Ry","parentname":"RayMarching Env"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//My GAMES101 final project//\nconst float sampleTimes=30.;\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec4 col=texelFetch(iChannel0,ivec2(C),0);\n    float depth=col.w;\n    \n    //SSAO\n        float thetaTimes=13.,rTimes=sampleTimes/thetaTimes,r=SAMPLE_RADIUS,\n          ds=r/rTimes,dw=1./sampleTimes;\n    mat2x2 rot=getRotMat(360./thetaTimes);\n    vec2 dir=vec2(1,0);\n    float ssao=0.;\n    for(float i=0.;i<thetaTimes;i++)\n        for(float j=0.;j<rTimes;j++)\n        {\n            float l=(j+1.)*ds;\n            vec2 spuv=C/iR+dir*l;\n            float d=texture(iChannel0,spuv).w;\n            ssao+=(depth>(d+1.*EPS)?1.:0.)*exp(-l*1.7)*dw;\n            dir*=rot;\n        }\n    ssao=pow(((1.-ssao*.7)*1.2+.3),.3);\n    O.rgb=col.rgb*ssao;\n#ifndef SSAO_ALL\n    O.rgb=mix(O.rgb,col.rgb,smoothstep(iR.x*.5-3.,iR.x*.5+3.,C.x));\n#endif\n#ifdef DEPTH_ONLY\n    O.rgb=vec3(depth);\n#endif\n#ifdef SSAO_ONLY\n    O.rgb=vec3(ssao);\n#endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*-------------exp settings-------------*/\n//#define SSAO_ALL\n//#define DEPTH_ONLY\n//#define SSAO_ONLY\nconst float SAMPLE_RADIUS=.03;//0-1 scale\n/*-------------exp settings-------------*/\n#define iR iResolution.xy\n#define iT iTime\n#define iM iMouse\nconst float MAX_DIST=20.;\nconst float MIN_DIST=1e-4;\nconst float MAX_STEP=50.;\nconst float EPS=1e-4;\nconst float PI=3.14159265;\nconst float DTA=PI/180.;\nstruct Ray\n{\n    vec3 o,d;\n};\nstruct Cam\n{\n    vec3 pos,dir;\n}cam;\nstruct Point\n{\n    float d;\n    int id;\n};\nmat2x2 getRotMat(float r)\n{\n    r*=DTA;\n    float c=cos(r),s=sin(r);\n    return mat2x2(c,s,-s,c);\n}\nfloat sdCube(vec3 p,vec3 size)\n{\n    vec3 np=abs(p)-size*.5;\n    float o=length(max(np,vec3(0)));\n    float i=min(0.,max(np.x,max(np.y,np.z)));\n    return o+i;\n}\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*2021-10-8:\na new problem I found:\nwhen normal is close to(0,0,+-1), there will be a unresonable color change\ntry to delete \"//\" in line 19 of BufferA\n\n*/\n/*------------OBJ DEFINE------------*/\nconst int OBJ_NUM=4;\nconst int ID_BOUND=0;\nconst int ID_BOX=1;\nconst int ID_LOWCUBE=2;\nconst int ID_HIGHCUBE=3;\nPoint sdf(vec3 p)\n{\n    Point[OBJ_NUM] objs;\n    objs[ID_BOUND]=Point(-sdSphere(p-vec3(0,0,0),MAX_DIST),ID_BOUND);//Bound\n\n    /*--------add objects begin--------*/\n    vec3 np=p;  //np.xz*=getRotMat(10.*sin(iT));\n    objs[ID_BOX]=Point(-sdCube(np-vec3(0,0,.5),vec3(1.3,1.,2.2)),ID_BOX);\n    \n    np=p;np-=vec3(.23+cos(iT)*.1,-.42,.83);\n    mat2x2 rot=getRotMat(-20.);np.xz*=rot;\n    objs[ID_LOWCUBE]=Point(sdCube(np,vec3(.2)),ID_LOWCUBE);\n    \n    np=p;np-=vec3(-.13,-.28,1.2+sin(iT)*.3);\n    rot=getRotMat(20.);np.xz*=rot;\n    objs[ID_HIGHCUBE]=Point(sdCube(np,vec3(.1,.2,.1)*2.3),ID_HIGHCUBE);\n    /*--------add objects end--------*/\n    \n    Point tar=objs[ID_BOUND];\n    for(int i=1;i<OBJ_NUM;i++)\n    {\n        if(tar.d>objs[i].d)\n            tar=objs[i];\n    }\n    return tar;\n}\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(0,EPS);\n    float c=sdf(p).d;\n    return normalize(vec3(sdf(p+e.yxx).d-c,\n                          sdf(p+e.xyx).d-c,\n                          sdf(p+e.xxy).d-c));\n}\nstruct FragInfo\n{\n    vec3 worldPos,normal,kc;\n};\nvec3 pixelShade(FragInfo I)\n{\n    vec3 lightPos=vec3(0.,.4,1.2);\n    vec3 pl=lightPos-I.worldPos,ld;\n    float plLen=length(pl);\n    ld=pl/plLen;\n    vec3 diff=vec3(1)*max(dot(ld,I.normal),0.)/(plLen*plLen)*.08;\n    vec3 amb=vec3(.3);\n    return I.kc*(diff+amb);\n}\nvec4 render(Ray r)\n{\n    float d=0.;\n    Point point;\n    for(float i=0.;i<MAX_STEP;i++)\n    {\n        point=sdf(r.o+d*r.d);\n        if(abs(point.d)<MIN_DIST)\n            break;\n        float l=i/MAX_STEP;\n        d+=point.d*((1.-l*l*l)*0.5+0.5);\n        if(point.id==ID_BOUND)\n        {\n            d=MAX_DIST;\n            break;\n        }\n    }\n    vec3 pos=r.o+r.d*d;\n    vec3 nml=getNormal(pos);\n    vec3 col=vec3(0);\n    switch (point.id)\n    {\n        case ID_BOUND:\n            break;\n        case ID_BOX:\n            vec3 kc=mix(vec3(1),nml.x*vec3(1,0,0)-nml.x*vec3(0,1,0),\n                        step(.5,abs(nml.x)));kc=max(kc,0.);\n            col=pixelShade(FragInfo(pos,nml,kc));\n            break;\n        case ID_LOWCUBE:\n        case ID_HIGHCUBE:\n            col=pixelShade(FragInfo(pos,nml,vec3(1)));\n            break;\n    }\n    return vec4(col,dot(pos-cam.pos,cam.dir)/MAX_DIST*7.);//w is the depth\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    cam.pos=vec3(sin(iT)*.3,cos(iT)*.1-.1,-.2);cam.dir=vec3(0,0,1);\n    Ray r=Ray(cam.pos,normalize(vec3((C-iR*.5)/iR.y,1.)));\n    O=render(r);\n}","name":"Buffer A","description":"","type":"buffer"}]}