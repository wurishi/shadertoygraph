{"ver":"0.1","info":{"id":"3lV3zK","date":"1579813410","viewed":206,"name":"krap","username":"monsterkodi","description":"MOUSE rotate \nRIGHT  rotation \nDOWN  antialias \nUP       animation\n","likes":22,"published":1,"flags":16,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TOY  1\n\n#define MAX_STEPS 128\n#define MIN_DIST   0.005\n#define MAX_DIST  20.0\n#define SHADOW     0.4\n#define FLOOR      0.0\n\n#define PI 3.1415926535897\n#define ZERO min(iFrame,0)\n\n#define NONE  0\n#define PLANE 1\n#define HEAD  2\n#define BULB  3\n#define PUPL  4\n#define BBOX  6\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nsdf s;\nint mat;\nint AA = 2;\nvec2 frag;\nbool soft;\nfloat brth;\nbool animat;\nvec3 camPos;\nvec3 camTgt;\nvec3 camDir;\n\nvec3 pHead, nyHead, nzHead;\nvec3 pEyeT, pEyeL, pEyeR, nEyeL, nEyeR, pEarL, nEarL, pEarR, nEarR, pPupL, pPupR, pLnsL, pLnsR,\n     pLegL, nLegL, pLegR, nLegR, pLegF, nLegF; \n\nvec3 v0 = vec3(0,0,0);\nvec3 vx = vec3(1,0,0);\nvec3 vy = vec3(0,1,0);\nvec3 vz = vec3(0,0,1);\n    \nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\nfloat gradientNoise(vec2 uv)\n{\n    return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n}\n\n// 0000000    000   0000000   000  000000000  \n// 000   000  000  000        000     000     \n// 000   000  000  000  0000  000     000     \n// 000   000  000  000   000  000     000     \n// 0000000    000   0000000   000     000     \n\nfloat digitBin(const int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat digit(vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces)\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = fValue < 0.0;\n    fValue = abs(fValue);\n    \n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if (fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n        if (fDigitIndex > fBiggestIndex) \n        {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } \n        else \n        {\n            if (fDigitIndex == -1.0) \n            {\n                if (fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } \n            else \n            {\n                float fReducedRangeValue = fValue;\n                if (fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = digitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod(fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0)), 2.0));\n}\n\n//  0000000   000   000   0000000   000000000  \n// 000   000  000   000  000   000     000     \n// 000 00 00  000   000  000000000     000     \n// 000 0000   000   000  000   000     000     \n//  00000 00   0000000   000   000     000     \n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    vec4 qr;\n    float half_angle = deg2rad(angle * 0.5);\n    qr.x = axis.x * sin(half_angle);\n    qr.y = axis.y * sin(half_angle);\n    qr.z = axis.z * sin(half_angle);\n    qr.w = cos(half_angle);\n    return qr;\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 quat, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\nvec3 rotate(vec4 quat, vec3 o, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p-o, 0));\n    return o + quatMul(q_tmp, conj).xyz;\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{ \n    vec4 qr = quatAxisAngle(axis, angle);\n    vec4 qr_conj = quatConj(qr);\n    vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n    \n    vec4 q_tmp = quatMul(qr, q_pos);\n    qr = quatMul(q_tmp, qr_conj);\n    \n    return vec3(qr.x, qr.y, qr.z);\n}\n\nvec3 rotRayAngle(vec3 position, vec3 ro, vec3 rd, float angle)\n{ \n    return rotAxisAngle(position-ro, rd-ro, angle)+ro;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opUnion(float d1, float k, float d2) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opDiff(float d1, float k, float d2) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{   \n    return dot(n, p);\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, float rl, float rs)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-rl,abs(dot(n, q))))-rs;\n}\n\nfloat sdConeBend(vec3 p, vec3 a, vec3 b, float fa, float fb)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    vec3 n  = normalize(ab);\n    float l = length(ab);\n    float dp = dot(ab,ap);\n    float dn = dot(ab,ab);\n    float t = dp / dn;\n    float ct = clamp(t, -0.5, 10.0);\n    float ra = l*fa;\n    float rb = l*fb;\n    \n    vec3 lp = a+ab*clamp01(t);\n    return length(p-lp) - (ct*rb+(1.0-ct)*ra);\n}\n\n// 00000000  000   000  00000000  \n// 000        000 000   000       \n// 0000000     00000    0000000   \n// 000          000     000       \n// 00000000     000     00000000  \n\nvoid eye(vec3 pos, vec3 pupil, vec3 lens)\n{\n    float d = sdSphere(s.pos, pos, 0.35);\n    if (d > s.dist) return;\n    \n    d = opDiff(d, 0.05, sdSphere(s.pos, pupil, 0.15));\n\n    if (d < s.dist) { s.mat = BULB; s.dist = d; }\n    \n    d = min(d, sdSphere(s.pos, lens, 0.2));\n    \n    if (d < s.dist) { s.mat = PUPL; s.dist = d; }\n}\n\n// 000      00000000   0000000   \n// 000      000       000        \n// 000      0000000   000  0000  \n// 000      000       000   000  \n// 0000000  00000000   0000000   \n\nfloat leg(vec3 pos, vec3 n)\n{\n    float d = sdConeBend(s.pos, pos, pos+n*0.2, 2.1, 2.5);\n    \n    d = opDiff(d, 0.2, sdPlane(s.pos, pos+n*0.5, -n));\n    d = opDiff(d, 0.1, sdSphere(s.pos, pos+n*0.7, 0.4));\n    \n    return d;\n}\n\n// 00000000   0000000   00000000   \n// 000       000   000  000   000  \n// 0000000   000000000  0000000    \n// 000       000   000  000   000  \n// 00000000  000   000  000   000  \n\nfloat ear(vec3 pos, vec3 n)\n{\n    float d = sdConeBend(s.pos, pos, pos+n*0.23, 0.7, 1.1);\n    \n    d = opDiff(d, 0.25, sdSphere(s.pos, pos+n*(0.5 + 0.15*brth/2.0), 0.1));\n    \n    return d;\n}\n\n//  0000000   000   000  000  00     00  \n// 000   000  0000  000  000  000   000  \n// 000000000  000 0 000  000  000000000  \n// 000   000  000  0000  000  000 0 000  \n// 000   000  000   000  000  000   000  \n\nvoid anim()\n{\n    float tt = 1.0-fract(iTime*0.5);\n    float aa = cos(tt*tt*PI*2.0); \n    float ab = cos(tt*PI*2.0); \n    \n    brth = 1.0*mix(smoothstep(-0.8, 0.95, aa), ab, 0.3);\n    \n    vec3 hsh1 = hash31(floor(iTime*0.3));\n    vec3 hsh2 = hash31(floor(iTime));\n    \n    pEyeT = camPos + hsh1*2.0 + hsh2*0.5;\n}\n    \nvoid pose()\n{\n    pHead = vec3(0,1.35,-brth*0.015);\n    \n    nyHead = rotAxisAngle(vy, vx, -2.0*brth);\n    nzHead = rotAxisAngle(vz, vx, -2.0*brth);\n    \n    nEarL = rotAxisAngle(rotAxisAngle(nzHead, vx, -48.0), nyHead,  130.0);\n    nEarR = rotAxisAngle(rotAxisAngle(nzHead, vx, -48.0), nyHead, -130.0);\n  \n    pEarL = pHead + nEarL*1.1;\n    pEarR = pHead + nEarR*1.1;\n  \n    nEarL = normalize(nEarL+vec3( brth*0.2,0,0));\n    nEarR = normalize(nEarR+vec3(-brth*0.2,0,0));\n    \n    nEyeL = rotAxisAngle(rotAxisAngle(nzHead, vx, -42.0), nyHead,  48.0);\n    nEyeR = rotAxisAngle(rotAxisAngle(nzHead, vx, -42.0), nyHead, -48.0);\n    \n    pEyeL  = pHead + nEyeL*0.9;\n    pEyeR  = pHead + nEyeR*0.9;\n    \n    nLegL = rotAxisAngle(rotAxisAngle(vz, vx, 42.0 - 3.0*brth), nyHead,  120.0);\n    nLegR = rotAxisAngle(rotAxisAngle(vz, vx, 42.0 - 3.0*brth), nyHead, -120.0);\n    nLegF = rotAxisAngle(rotAxisAngle(vz, vx, 42.0 + 0.5*brth), nyHead,    0.0);\n    \n    vec3 nl = normalize(pEyeT - pEyeL);\n    vec3 nr = normalize(pEyeT - pEyeR);\n        \n    float pd = 0.3;\n    float ld = 0.16;\n\n    pPupL = pEyeL + pd*nl;\n    pPupR = pEyeR + pd*nr;\n    \n    pLnsL = pEyeL + ld*nl;\n    pLnsR = pEyeR + ld*nr;\n}\n\n// 000   000  00000000   0000000   0000000    \n// 000   000  000       000   000  000   000  \n// 000000000  0000000   000000000  000   000  \n// 000   000  000       000   000  000   000  \n// 000   000  00000000  000   000  0000000    \n\nvoid head()\n{        \n    float bd = sdSphere(s.pos, pHead, 2.3);    \n\n    if (bd > MIN_DIST*1.1) \n    {\n        if (bd < s.dist) { s.mat = BBOX; s.dist = bd; }\n        return;\n    }\n\n    float d = sdSphere(s.pos, pHead, 1.0+brth*0.01);\n\n    d = opUnion(d, 0.2, ear(pEarL, nEarL));\n    d = opUnion(d, 0.2, ear(pEarR, nEarR));\n            \n    d = opUnion(d, 0.15, sdTorus(s.pos, pEyeL, nEyeL, 0.4, 0.05));\n    d = opUnion(d, 0.15, sdTorus(s.pos, pEyeR, nEyeR, 0.4, 0.05));\n    \n    d = opUnion(d, 0.2, leg(pHead + nLegL, nLegL));\n    d = opUnion(d, 0.2, leg(pHead + nLegR, nLegR));\n    d = opUnion(d, 0.2, leg(pHead + nLegF, nLegF));\n    \n    if (d < s.dist) { s.mat = HEAD; s.dist = d; }\n        \n    eye(pEyeL, pPupL, pLnsL);\n    eye(pEyeR, pPupR, pLnsR);\n}\n\nvoid plane(vec3 pos)\n{        \n    if (camPos.y < FLOOR) return;\n    float d = sdPlane(s.pos, pos, vy);\n    if (d < s.dist) { s.mat = PLANE; s.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    s = sdf(1000.0, p, NONE);\n         \n    plane(v0);\n    head();\n\n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    float shade = 1.;\n    float dist = MIN_DIST;    \n    vec3 rd = (lp-ro);\n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/25.0;\n    rd /= end;\n    for (int i=0; i<25; i++)\n    {\n        float h = map(ro+rd*dist);\n        if (s.mat != BBOX)\n            shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat shiny(float rough, float NoH, const vec3 h) \n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * rough;\n    float k = rough / (oneMinusNoHSquared + a * a);\n    float d = k * k / PI;\n    return d;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 col)\n{\n    if (mat == NONE) return col;\n    \n    vec3 cr = cross(camDir, vec3(0,1,0));\n    vec3 up = normalize(cross(cr,camDir));\n    vec3 lp = 2.0 * (camPos + vec3(-0.5,1.0,0) + up*2.0); \n    vec3 l = normalize(lp-p);\n \n    float ambient = 0.005;\n    float dif = clamp(dot(n,l), 0.0, 1.0);\n    \n    if (mat == PUPL)\n    {\n        dif = clamp(dot(n,normalize(mix(camPos,lp,0.1)-p)), 0.0, 1.0);\n        dif = mix(pow(dif, 16.0), 1.0*dif, 0.2);\n        dif += 1.0 - smoothstep(0.0, 0.2, dif);\n        if (mat == PUPL) ambient = 0.1;\n    }\n    else if (mat == BULB)\n    {\n        dif = mix(pow(dif, 32.0), 3.0*dif+1.0, 0.2);\n        ambient = 0.2;\n    }\n    else if (mat == HEAD)\n    {\n        float exp = 1.5;\n        float smx = 0.27;\n        \n        vec3  n2c = normalize(camPos-p);\n        vec3  bcl = normalize(n2c + l);\n        float dnh = dot(n, bcl);\n        float shi = shiny(2.5, dnh, bcl);\n        \n        dif = pow(dif, exp);\n        dif = mix(dif, shi, smx);\n        ambient = 0.1;\n    }\n    \n    if (mat == HEAD || mat == PLANE || mat == BULB)\n    {\n        dif *= softShadow(p, lp, 6.0);        \n    }\n    \n    vec3 hl = v0;\n    if (mat == PUPL || mat == BULB)\n    {\n        hl = vec3(pow(clamp01(smoothstep(0.9,1.0,dot(n, l))), 20.0));\n    }\n    else if (mat == HEAD)\n    {\n        float hv = pow(clamp01(smoothstep(0.7,1.0,dot(n, l))), 1.2);\n        hl = col*hv*0.3;\n    }\n    \n    return col * clamp(dif, ambient, 1.0) + hl;\n}\n\n// 00000000   0000000    0000000   \n// 000       000   000  000        \n// 000000    000   000  000  0000  \n// 000       000   000  000   000  \n// 000        0000000    0000000   \n\nvec3 fog(vec3 col, vec3 bg, float dist)\n{\n    float f = smoothstep(5.0, MAX_DIST, dist);\n    return mix(col, bg, f);\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    frag = fragCoord;\n    bool dither = true;\n    bool camrot = texelFetch(iChannel0, ivec2(KEY_RIGHT, 2), 0).x < 0.5;\n    bool space  = texelFetch(iChannel0, ivec2(KEY_SPACE, 2), 0).x > 0.5;\n         soft   = texelFetch(iChannel0, ivec2(KEY_DOWN,  2), 0).x < 0.5;\n         animat = texelFetch(iChannel0, ivec2(KEY_UP,    2), 0).x < 0.5;\n          \n    if (!soft) \n    {\n        AA = 1;   \n    }\n    else\n    { \n        if (iTimeDelta < 0.02) AA = 3;\n    }\n         \n    float d;\n    vec3 cols = v0;\n    vec3 col, foc;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    float md = 5.5;\n    float mx = 2.0*(iMouse.x/iResolution.x-0.5);\n    float my = 2.0*(iMouse.y/iResolution.y-0.5);\n    \n    if (iMouse.z <= 0.0 && camrot)\n    {\n        float ts = 276.2;\n        mx = 0.3*sin(ts+iTime/12.0);\n        my = -0.20-0.10*cos(ts+iTime/8.0);\n    }\n    \n    camTgt = vec3(0,1.2,0); \n\n    camPos = rotAxisAngle(rotAxisAngle(vec3(0,0,md), vx, 89.0*my), vy, -180.0*mx);\n    \n    #ifndef TOY\n        if (space)\n        {\n            camTgt = iCenter;\n            camPos = iCamera;\n            camPos.x *= -1.0;\n            camTgt.x *= -1.0;\n        }\n    #endif\n    \n    camDir = normalize(camTgt-camPos);\n    \n    if (animat) { anim(); }\n    else { pEyeT = camPos; }\n    \n    pose();\n    \n    vec2 ao = vec2(0);\n    vec2 uv;\n    \n    for( int am=ZERO; am<AA; am++ )\n    for( int an=ZERO; an<AA; an++ )\n    {\n        if (AA > 1) ao = vec2(float(am),float(an))/float(AA)-0.5;\n\n        uv = (fragCoord+ao-.5*iResolution.xy)/iResolution.y;\n                \n        vec3 ww = normalize(camTgt-camPos);\n        vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize(cross(uu, ww));\n            \n        vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n        \n        d = rayMarch(camPos, rd);\n        mat = s.mat;\n        \n        vec3  p = camPos + d * rd;\n        vec3  n = getNormal(p);\n                \n        if      (mat == HEAD)  col = vec3(1.0, 0.6, 0.0);\n        else if (mat == PLANE) col = vec3(0.5, 0.0, 0.0);\n        else if (mat == PUPL)  col = vec3(0.1, 0.1, 0.5);\n        else if (mat == BULB)  col = vec3(1.0, 1.0, 1.0);\n        else if (mat == NONE)  col = vec3(0.22, 0.0, 0.0);\n        foc = vec3(0.22, 0.0, 0.0);\n    \n        col = getLight(p, n, col);\n            \n        if (mat != NONE)\n        {\n            col = fog(col, foc, d);\n        }\n            \n        cols += col;\n    }\n    \n    col = cols/float(AA*AA);\n    \n    col *= clamp(1.0-1.1*length((fragCoord-.5*iResolution.xy)/iResolution.xy), 0.0, 1.0);\n    \n    if (dither)\n    {\n        float dit = gradientNoise(fragCoord.xy);\n        col += vec3(dit/1024.0);\n    }\n    \n    #ifndef TOY\n    vec2  fontSize = vec2(20.0, 35.0);  \n    float isDigit = digit(fragCoord / fontSize, iFrameRate, 2.0, 0.0);\n    col = mix(col, vec3(1.0, 1.0, 1.0), isDigit);\n    #endif\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}