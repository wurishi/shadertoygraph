{"ver":"0.1","info":{"id":"NsKGWD","date":"1631590474","viewed":122,"name":"Cabin in the Woods","username":"andrew741","description":"A cabin deep in the woods during the summer with day turning to night, the peaceful twinkling stars and the glow of the cabin. Note that theres on trees because they'er very hard and slow with ray marching.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","sun","shading","specular","stars","moon","metal","emission","cabin","nigh","ligh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by Andrew\n\nThe summer cabin in the woods\n\nThis shader took about 5 hours and was done in a single day and shows a run down cabin with a sheet metal roof.\nLet the faint glow of the cabin and the twinkling stars bring you back to those wodnerful sumer nights under the stars.\nLet the moon fill your eyes as it falls beyond the horizon and the sun comes up to welcome a new day.\n\nThis shader uses a varient of ray marching called sphere tracing to render the scene.\n\nI have been working hard on a shader called \"through the cosmos\" and it will be ready sometime soon and goes from earth through two solar\nsytem.\n*/\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// 2d rotation matrix\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\n// takes a uv coord and mouse pos and converts it to the rays direction\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\n// takes in a vec3 and returns a randomized vec3 (from another shader)\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i                   );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w                   );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// gets the distance to the ground\nfloat dstGround(vec3 p)\n{\n    float dst = p.y - noised(p * 0.2 + vec3(0., 1., 0.)).r + 4.;\n    \n    return dst;\n}\n\n\n// gets the distance to a place with a linear slope across the x and z\nfloat dstPlane(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    vec2 np = p.xz - pos.xz;\n    float dstY = abs(p.y - (slope.x * np.x + slope.y * np.y + pos.y)) - 0.01;\n    float dstXZ = max(abs(np.x) - s.x, abs(np.y) - s.y);\n    return max(dstY, dstXZ) * 0.7;\n}\n\n\n// takes the plane and bends it into sheet metal\nfloat dstSheetMetal(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    float dst = dstPlane(p + vec3(0., sin(p.x * 23.) * 0.025, 0.), slope, pos, s);\n    return dst * 0.7;\n}\n\n\n// the same as the sheet metal but wooden planks, it also positions them virtically\nfloat dstWoodenPlank(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    float dst = dstPlane(vec3(p.x, p.z, p.y), slope, vec3(pos.x, pos.z, pos.y), s);\n    return dst;\n}\n\n\n// the same as the orther plank but a different direction (idk if its north, north would be positive z)\nfloat dstWoodenPlankNorth(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    float dst = dstPlane(vec3(p.z, p.x, p.y), slope, vec3(pos.z, pos.x, pos.y), s);\n    return dst;\n}\n\n\n// specular reflection and diffusion (im not using the diffusion in this shader, its a hit or miss)\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// stores info on a material\nstruct Mat\n{\n    vec3 col, normal, glow;\n    float smoothness;\n    SpecularLight specular;\n};\n\n\n// stores info on a ray (after having been simulated)\nstruct Ray\n{\n    Mat mat;\n    vec3 cp, ro, rd;\n    float dst;\n    bool collided;\n};\n\n\n// returns info on the hit object so the material can be created\nstruct MatProperties\n{\n    vec3 col;\n    float glow, smoothness, shade_strength;\n};\n\n\n/*\nvec4 GetDst(vec3 p)\n{\n    float dst1 = dstSheetMetal(p, vec2(0., 0.75), vec3(2.5, 0., -4.5), vec2(5.));\n    float dst2 = length(p) - 1.;\n    \n    float dst = min(dst1, dst2);\n    \n    vec3 emmision = vec3(0.);\n    if (dst == dst2) emmision = mix(vec3(1., 1., 0.), vec3(0.), pow(clamp(dst2 * 0.2, 0., 1.), 0.4));\n    \n    return vec4(emmision, dst);\n}\n*/\n\n\n// gets the distance to a cilander\nfloat distToCilander(vec3 p, vec3 lineA, vec3 lineB, float r) {\n\tvec3 LineLine = lineB - lineA;\n    vec3 LinePoint = p - lineA;\n    \n    float t = dot(LineLine, LinePoint) / dot(LineLine, LineLine);\n    \n    vec3 center = lineA + (t * LineLine);\n    \n    float x = length(p - center) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(LineLine);\n    float e = length(max(vec2(x, y), 0.));\n    \n    float i = min(max(x, y), 0.);\n    \n    return e + i;\n}\n\n\n// using triplanar mapping to find the uv coord for a texture on any surface\nvec2 GetUV(vec3 p, vec3 normal)\n{\n    // the sharpness of the blending between different axises\n    float blendSharpness = 100.;\n    // finding the different axise's color\n    vec2 colX = p.zy;\n    vec2 colY = p.xz;\n    vec2 colZ = p.xy;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\n// gets the distance to the walls of the cabin (wooden walls)\nfloat dstCabin(vec3 p)\n{\n    vec3 p2 = vec3(p.x, p.y, abs(p.z + 1.1) - 3.6);  // making 2 walls for the price of one using a repeating coordinate space\n    vec3 p3 = vec3(abs(p.x + 0.2) - 4.2, p.y, p.z);  // making 2 walls for the price of one using a repeating coordinate space\n    float dst1 = dstWoodenPlank(p2, vec2(0.1, 0.025), vec3(-2.  + 3., -0.75, -2.), vec2(0.25, 2.));\n    float dst2 = dstWoodenPlank(p2, vec2(-0.1, -0.1), vec3(-2.6 + 3., -0.75, -2.), vec2(0.25, 2.));\n    float dst3 = dstWoodenPlank(p2, vec2(0.1, 0.), vec3(-3.2 + 3.   , -0.75, -2.), vec2(0.25, 2.));\n    float dst4 = dstWoodenPlank(p2, vec2(0., 0.05), vec3(-3.8 + 3.  , -0.75, -2.), vec2(0.25, 2.));\n    float dst5 = dstWoodenPlank(p2, vec2(0.2, 0.), vec3(-4.4 + 3.   , -0.75, -2.), vec2(0.25, 2.));\n\n    float dst = min(min(dst1, dst2), min(dst3, min(dst4, dst5)));\n    \n    dst1 = dstWoodenPlankNorth(p3, vec2(0.1, 0.025), vec3(-2.5, -0.75, -1.  + 1.), vec2(0.25, 2.));\n    dst2 = dstWoodenPlankNorth(p3, vec2(-0.1, -0.1), vec3(-2.5, -0.35, -1.6 + 1.), vec2(0.25, 2.4));\n    dst3 = dstWoodenPlankNorth(p3, vec2(0.1, 0.)   , vec3(-2.5, -0.25, -2.2 + 1.), vec2(0.25, 2.75));\n    dst4 = dstWoodenPlankNorth(p3, vec2(0., 0.05)  , vec3(-2.5, -0.35, -2.8 + 1.), vec2(0.25, 2.4));\n    dst5 = dstWoodenPlankNorth(p3, vec2(0.2, 0.)   , vec3(-2.5, -0.75, -3.4 + 1.), vec2(0.25, 2.));\n    float dst6 = dstWoodenPlankNorth(p3, vec2(0.2, 0.)   , vec3(-2.5, 0.75, -2. + 0.25), vec2(2., 0.25));\n   \n    dst = min(min(min(dst1, dst2), min(dst3, min(dst4, min(dst5, dst6)))), dst);\n\n    return dst;\n}\n\n\n// gets the distance to the roof and floor of the cabin (sheet metal)\nfloat dstCabinRoof(vec3 p)\n{\n    vec3 p2 = vec3(p.x, p.y, abs(p.z) - 0.9);  // making 2 sides of the roof/floor for the price of one using a repeating coordinate space\n    float dst1 = dstSheetMetal(p2, vec2(0., -0.9), vec3(0., 2., 0.), vec2(2., 0.8));\n    float dst2 = dstSheetMetal(p2, vec2(-0.025, 0.1), vec3(0., -1., 0.), vec2(2., 0.8));\n    // the light bulb\n    float dst3 = distToCilander(p + vec3(0.3, -0.6, 0.0), vec3(0., 0., 0.), vec3(0., 0.2, 0.), 0.01);\n    \n    float dst = min(dst1, min(dst2, dst3));\n    \n    return dst;\n}\n\n\n// gets the distance to the scene (there is a commented out function where i was messing with emmition in other ways then im using now and the raw version was that but without emission, this is the left over from that failed atempt)\nfloat GetDstRaw(vec3 p)\n{\n    float dst1 = dstCabinRoof(p + vec3(-3.5, 2.8, 4.));\n    float dst2 = length(p + vec3(-3.56 , 2.8, 4.) + vec3(0.3, -0.6, 0.0)) - 0.02;\n    float dst3 = dstCabin(p + vec3(-3.5, 3., 3.));\n    float dst4 = dstGround(p);\n    \n    float dst = min(min(dst1, dst2), min(dst3, dst4));\n    \n    return dst;\n}\n\n\n// gets the material properties so the material can be created\nMatProperties GetMat(vec3 p, vec3 normal, vec3 sun_dir)\n{\n    float dst1 = dstCabinRoof(p + vec3(-3.5, 2.8, 4.));\n    float dst2 = length(p + vec3(-3.56 , 2.8, 4.) + vec3(0.3, -0.6, 0.0)) - 0.02;\n    float dst3 = dstCabin(p + vec3(-3.5, 3., 3.));\n    float dst4 = dstGround(p);\n    \n    float dst = min(min(dst1, dst2), min(dst3, dst4));\n    \n    // the strength of the light\n    vec3 l = mix(vec3(1.75, 1.25, 0.), vec3(0.), pow(clamp(dst2 * 0.2 + max(floor(dot(sun_dir, vec3(0., 1., 0.)) + 0.4), 0.), 0., 1.), 0.4));\n    // checking which surface was hit\n    if (dst == dst1)  // sheet metal\n    {\n        vec3 col = texture(iChannel0, GetUV(p, normal) * 0.2).rgb;\n        float mask = abs(max(col.r - col.g, col.r - col.b)) + 0.9;\n        return MatProperties(col + l / mask, l.r / mask * 0.5, mask, 0.);\n    }\n    else if (dst == dst2)  // light bulb\n    {\n        vec3 col = vec3(1., 1., 0.5) * 4.;\n        return MatProperties(col * clamp(l.r, 0., 1.), 0., 1., 1.);\n    }\n    else if (dst == dst3)  // wooden plank\n    {\n        vec3 col1 = texture(iChannel2, GetUV(p, normal) * 0.4).rgb;\n        vec3 col2 = texture(iChannel1, GetUV(p, normal) * 0.4).rgb;\n        vec3 col = mix(col1, col2, 0.3 + col2 * 0.1);\n        float mask = length(col);\n        return MatProperties(col + l * 2.5, l.r * 0.5, 1., 0.);\n    }\n    else if (dst == dst4)  // ground (grass)\n    {\n        vec3 col = (texture(iChannel3, GetUV(p, normal) * 0.6).r * 0.6 + 0.4) * vec3(0.2, 0.8, 0.2);\n        float mask = abs(max(col.r - col.g, col.r - col.b)) + 0.7;\n        return MatProperties(col + l / mask * 1.3, l.r / mask * 1.1, 1., 0.);\n    }\n\n    return MatProperties(vec3(0.), 0., 0., 0.);\n}\n\n\n// gets the normal of the scene at a given position\n/*\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDstRaw(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDstRaw(p - e.xyy),\n        GetDstRaw(p - e.yxy),\n        GetDstRaw(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n*/\nvec3 GetNormal ( vec3 z)\n{\n    float e   =  0.01;\n    float dx1 = GetDstRaw(z + vec3(e, 0, 0));\n    float dx2 = GetDstRaw(z - vec3(e, 0, 0));\n    float dy1 = GetDstRaw(z + vec3(0, e, 0));\n    float dy2 = GetDstRaw(z - vec3(0, e, 0));\n    float dz1 = GetDstRaw(z + vec3(0, 0, e));\n    float dz2 = GetDstRaw(z - vec3(0, 0, e));\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\n// marches a ray through the scene\nRay MarchRay(vec3 ro, vec3 rd, vec3 sun_dir)\n{\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    float total_s = 0.;\n    vec3 glow = vec3(0.);\n    bool collided = false;\n    for (int s = 0; s < 200; s++)  // 200 steps\n    {\n        //vec4 data = GetDst(p);\n        //dst = data.w;\n        dst = GetDstRaw(p);\n        //glow = max(data.rgb, glow);\n        p += rd * dst;\n        dfs += dst;\n        \n        total_s = float(s);\n        \n        if (dfs > 20.) break;\n        if (dst < 0.02)  // a percision of 0.02\n        {\n            collided = true;\n            break;\n        }\n    }\n    \n    //glow /= total_s;\n    if (collided)  // checking if the ray collided to know if the color/material should be found\n    {\n        vec3 normal = GetNormal(p);\n        \n        MatProperties matProps = GetMat(p, normal, sun_dir);\n        SpecularLight spec = Specular(matProps.smoothness, normal, rd, sun_dir);\n        Mat mat = Mat((matProps.col + spec.highlight * (1. - matProps.shade_strength)) * mix(max(dot(normal, sun_dir) * 0.7 + 0.3 + matProps.glow, 0.), 1., matProps.shade_strength), normal, glow, matProps.smoothness, spec);\n        return Ray(mat, p, ro, rd, dfs, collided);\n    }\n    else  // the ray did not hit and a blank material will be created as there is nothing to render\n    {\n        return Ray(Mat(vec3(0.), vec3(0.), glow, 0., SpecularLight(0., 0.)), p, ro, rd, dfs, collided);\n    }\n}\n\n\n// renders soft shadows (credit to some other shader for this function)\nfloat SoftShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDstRaw(ro + rd*t);\n        if( h<0.001 )\n        {\n            return 0.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\n// converts a vector3 to a float while randomizing it\nfloat hash31(vec3 p)\n{\n    return fract(sin(dot(p, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542);\n}\n\n\n// rendering the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv coordinate\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // the mouse position\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // the sun direction\n    vec3 sun_dir = normalize(vec3(0.5, sin(iTime * 0.2 - 1.), 0.));\n\n    // setting the fov based on the scene\n    if (iTime < 11.) uv *= 3.75;\n    else uv *= 2.;\n\n    // finding the ray's direction\n    vec3 rd = Transform(uv, m, 0.);\n    // finding the camera's position based on the scene\n    vec3 ro;\n    if (iTime < 11.) ro = vec3(3., -2.5, -4.);\n    else ro = vec3(0., -1.5, -1.);\n\n    // the color (setting it to the sky color for starters)\n    vec3 col = vec3(0.05, 0.05, (rd.y * sun_dir.y) * 0.8 + 0.2) * 1.6;\n    // adding the sun\n    col = max(mix(col, vec3(1.5), pow(max(dot(rd, sun_dir), 0.), 275.)), 0.);\n\n    // marching the ray\n    Ray ray = MarchRay(ro, rd, sun_dir);\n    // checking if the ray hit anything\n    if (ray.collided)\n    {\n        // adding soft shadows\n        float shadow = SoftShadow(ray.cp + ray.mat.normal * 0.05, sun_dir, 0.05, 15., 30.) * 0.6 + 0.4;\n        ray.mat.col *= shadow;\n        // setting the color to the objects color\n        col = ray.mat.col;\n        col = pow(col, vec3(1. / 1.6));\n    }\n    //col += ray.mat.glow;\n    \n    // if it didnt collide then stars are rendered\n    if (!ray.collided)\n    {\n        // noise to make the stars blink\n        float sky_noise = round(noised(rd * 25. + iTime * 0.25).r * 0.5 + 0.5);\n        // rendering the stars\n        col = mix(col, vec3(1.), ceil(pow(hash31(floor(rd * 200.) / 200.), 12000.)) * clamp(clamp(rd.y + 0.2, 0., 1.) * pow(1. - col.b, 7.), 0., 1.) * sky_noise);\n        \n        // adding the moon\n        // the moons position (you have to rotate the ray's direction to not distort the value)\n        vec3 mp = vec3(rd.x, rot2D(vec2(rd.y, rd.z), 0.9 + iTime * 0.1));\n        vec3 mp2 = vec3(rd.x, rot2D(vec2(rd.y, rd.z), 0.99 + iTime * 0.1));\n        mp2 = vec3(rot2D(vec2(mp2.x, mp2.y), -0.075), mp2.z);\n        // the mask for the moon\n        float moon_mask = smoothstep(0.2, 0.15, length(mp.xz)) * smoothstep(0.15, 0.2, length(mp2.xz));\n        // adding the moon to the final color\n        col = mix(col, vec3(1.), clamp(moon_mask * clamp(clamp(rd.y + 0.2, 0., 1.) * pow(1. - col.b, 7.), 0., 1.), 0., 1.));\n    }\n    \n    //col = col + (pow((1. - length(col)) * 0.35, 2.));\n    \n    // the final color\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}