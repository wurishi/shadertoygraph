{"ver":"0.1","info":{"id":"4lVXDW","date":"1484409541","viewed":324,"name":"Improved Displacement Mapping","username":"twitchingace","description":"A silly extension of my displacement mapped sphere to handle many spheres (with the same displacement, because I'm lazy) and lights, mostly just to get my fixed version visible.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","raymarch","displacement","sphere","mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 eye = vec3(0,0,10);\nvec3 lightPos = vec3(10., -2., 2.);\nvec3 light2Pos = vec3(0., -3., 0.);\n\nvec3 sphere1Pos = vec3(-1.5, 0., 1.);\nfloat sphere1Rad = .85;\nvec3 sphere2Pos = vec3(1.5, 0., -1.);\nfloat sphere2Rad = 0.4;\nvec3 sphere3Pos = vec3(0.2, 0., 0.);\nfloat sphere3Rad = .6;\n\nconst float maxIterations = 32.;\n\nstruct mat{\n\tfloat spec;\n    float diff;\n    float amb;\n    float shiny;\n};\n\nstruct ray{\n \tvec3 position;\n    vec3 direction;\n};\n    \nmat test = mat(.05,.8,.1,1.);\n\nvec3 getNormal(vec3 point, vec3 sphere, float s){\n    float epsilon = 0.00004; // How far in the plane to grab height from to recalc normals\n    // Convert the point into model coordinates.\n    vec3 p = point - sphere;\n    // Standard mapping of a point on a sphere to a UV\n    float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / s / .5 \n        \t+ iTime * .1;\n    float v = (.5 - asin(p.y) / 3.14159) / s / .5;\n    \n    // Get the height af (u,v), (u, v + epsilon), and (u + epsilon, v)\n    // So that we can construct two vectors to cross product\n    float d1 = texture( iChannel0,\n                           vec2(u,v)).r;\n    float d2 = texture( iChannel0,\n                           vec2(u,v + epsilon)).r;\n    float d3 = texture( iChannel0,\n                           vec2(u + epsilon,v)).r;\n    \n    // Construct points we can generate the normal from.\n    vec3 p1 = vec3(u, v, d1 * 0.1);\n    vec3 p2 = vec3(u, v + epsilon, d2 * 0.1);\n    vec3 p3 = vec3(u + epsilon, v, d3 * 0.1);\n    \n    // The normal for a un-displaced sphere\n    vec3 sphereNorm = p;\n    // A vector between a standard \"up\" vector and the normal for the displacement map\n    vec3 planeNorm = vec3(0., 0., 1.) - normalize(cross((p3-p1), (p2 - p1)));\n    \n    return normalize(planeNorm + sphereNorm); // Return a corrected normal\n}\n\nfloat distSphere( vec3 p, float s )\n{\n    // Standard UV wrapping for a sphere\n    float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / s / .5;\n    float v = (.5 - asin(p.y) / 3.14159) / s / .5;\n    float disp = texture( iChannel0,\n                           vec2(u + iTime * .1,v)).r;\n    \n    vec3 normal = p;\n    // The exponential smooths out the displacement so we don't have crazy looking poles\n\treturn length(p)-s - (disp * 0.1 * exp(1. - abs(normal.y))/exp(1.));\n}\n\nfloat distFunc(vec3 p, vec3 spherePos, float sphereRad)\n{\n    float d1 = distSphere(p - spherePos, sphereRad);\n    return d1;\n}\n\nray lookAt(in vec2 uv, in vec3 targetPoint){\n\tvec3 forward = normalize(targetPoint - eye);\n    vec3 up = vec3(0.,1.0,0.0);\n    vec3 right = cross(forward, up);\n    up = cross(forward, right);\n    vec3 ro = eye + forward * .1 + right * uv.x + up * uv.y;\n    vec3 rd = forward;\n    return ray(ro,rd);\n}\n\nvec3 rayMarch(ray marcher){\n    float epsilon = 0.001;\n    float t = 0., d, d2, d3;\n    vec3 targetSphere = sphere1Pos;\n    float targetRad = sphere1Rad;\n    vec3 point;\n    \n    for (float i = 0.; i < maxIterations; i++){\n        point = marcher.position + marcher.direction * t;\n        \n        // Figure out which sphere we're closest to\n        d = distFunc(point, sphere1Pos, sphere1Rad);\n        d2 = distFunc(point, sphere2Pos, sphere2Rad);\n        d3 = distFunc(point, sphere3Pos, sphere3Rad);        \n        if (d2 < d) {\n            d = d2;\n            targetSphere = sphere2Pos;\n            targetRad = sphere2Rad;\n        }\n        if (d3 < d) {\n        \td = d3;\n            targetSphere = sphere3Pos;\n            targetRad = sphere3Rad;\n        }\n        \n        if (d < epsilon){\n            vec3 p = point - targetSphere;\n            // UV wrapping so we can texture the sphere\n            float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / targetRad / .5;\n   \t \t\tfloat v = (.5 - asin(p.y) / 3.14159) / targetRad / .5;\n      \n            // Calc phong illumination\n            vec3 normal = getNormal(point, targetSphere, targetRad);\n            vec3 light1Dir = normalize(lightPos - point);\n            vec3 light2Dir = normalize(light2Pos - point);\n            vec3 viewDir = normalize(eye - point);\n            vec3 reflection1 = reflect(light1Dir, normal);\n            vec3 reflection2 = reflect(light2Dir, normal);\n            // Add the ambient component\n            float Ip = test.amb;\n            // Add the diffuse component\n            Ip += max(0., test.diff * dot(light1Dir, normal)) \n                + max(0., test.diff * dot(light2Dir, normal));\n            // Add the specular component\n            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny)) \n                + max(0., pow(test.spec * dot(reflection2, viewDir), test.shiny));\n            return Ip * texture(iChannel1, vec2(u + iTime * 0.1, v)).xyz;\n        }\n        t+=min(d, d2);\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(0, 1. * sin(iTime), 10.);\n    lightPos = vec3(0., cos(iTime + .2) * 6., 2. * sin(iTime + .2));\n    light2Pos = vec3(6. * sin(iTime), -3., .5 * cos(iTime));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    ray eyeRay = lookAt(uv, vec3(0)); \n\tfragColor = vec4(rayMarch(eyeRay),1.0);\n}","name":"Image","description":"","type":"image"}]}