{"ver":"0.1","info":{"id":"fdy3Rt","date":"1632331473","viewed":239,"name":"Alhambra Nasrid Birdie tiling","username":"curena","description":"Another Islamic Star Pattern, this is the so called \"Pajarita Nazarí\" (Nasrid Birdie). This variant of the birdie is based on a piece in the Alhambra's  Museum. Set \"schematic_view\" bool constant to \"true\" to show an scheme of the symmetry axes.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["wallpapergroupstesselationssymmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ISLAMIC STAR PATTERNS\n// Alhambra, Pajarita Nazarí (Nasrid Birdie)\n// the base symmetry group is 'p31m' \n//\n// Carlos Ureña, Sept. 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n\n// ------------------------------------------------------------------------------------\n// configurable constants (visualization)\n\nconst int   nspp_root       = 7 ;    // root of the number of samples per pixel \nconst float vis_wcc_sx      = 8.5 ;  // visible region in world coordinates, size in X\nconst float edge_width      = 0.02 ; // birdie arc width \nconst float ah_gap          = 0.00 ; // gap between arcs and hexagons\nconst bool  schematic_view  = false;  // set to true to highlight fundamental region and reflection axes\n\n// ------------------------------------------------------------------------------------\n// other (fixed) constants \n\n// related to antialiasing\n\nconst int   nspp        = nspp_root*nspp_root; // number of samples per pixel\nconst float nspp_root_f = float(nspp_root);    // root of number of samples per pixel (as a float)\n\n// values of sin & cos for relevant angles\n\nconst float \n   sin_30  =  0.5 ,\n   cos_30  =  0.86602540378, // == sqrt(1.0-cos_30*cos_30)\n   sin_60  =  cos_30 ,\n   cos_60  =  sin_30 ,\n   sin_120 =  cos_30 ,\n   cos_120 = -sin_30 ;\n\n\n// counterclockwise 2D rotation matrices for relevant angles\n// take into account that GLSL expect mat constructors call to have values in column order \n\nconst mat2 \n    rot_30  = mat2(  cos_30, sin_30, \n                    -sin_30, cos_30  ),\n                     \n    rot_60  = mat2(  cos_60, sin_60, \n                    -sin_60, cos_60  ),\n                          \n    rot_120 = mat2(  cos_120, sin_120, \n                    -sin_120, cos_120  );\n                            \n// some relevant real constants\n                              \nconst float \n    pi            = 3.14159265359 ,\n    root_of_2     = 1.41421356237 ,\n    root_of_2_inv = 1.0/root_of_2 ;\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through two points 'q1' and 'q2'\n// (only for points in the halfplane to the right of the line from p1 to p2)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPP( vec2 p, vec2 q1, vec2 q2, inout int mirror_count )\n{\n \tvec2   s = q2-q1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-q1,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1; \n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through point 'q' and parallel to normalized vector 'v'\n// (only for points in the halfplane to the right of the axis)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPN( vec2 p, vec2 q, vec2 v, inout int mirror_count )\n{\n \tvec2   n = vec2( v.y, -v.x ) ;\n    float  d = dot(p-q,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// ------------------------------------------------------------------\n// (inconditional) mirror reflection of 'p' around and axis through \n// point 'q' and parallel to normalized vector 'v'\n\nvec2 IncMirrorPN( vec2 p, vec2 q, vec2 v  )\n{\n \tvec2   n = vec2( v.y, -v.x ) ;\n    float  d = dot(p-q,n) ;\n    \n    return p-2.0*d*n ;\n    \n}\n\n//-------------------------------------------------------------------------------------\n// returns the signed distance between a point 'p' and the line through 'q' parallel\n// to normalized vector 'n'.\n// The distance is positive to the right of the line, negative to the left\n\nfloat SignedDistancePN( vec2 p, vec2 q, vec2 n )\n{\n    return dot( p-q, vec2( n.y, -n.x ) );\n}\n\n\n\n//-------------------------------------------------------------------------------------\n// returns ....\n\nfloat AbsDistancePV( vec2 p, vec2 q, vec2 v )\n{\n    return abs( dot( p-q, vec2( v.y, -v.x )/sqrt(dot(v,v)) ) );\n}\n\n//-------------------------------------------------------------------------------------\n// returns true iif 'p' is on the left side of the line through 'a' towards 'b' \n// returns false for the right side\n\nbool IsOnLeftSidePP( vec2 p, vec2 a, vec2 b )\n{\n   // use dot product of b-a and vector to the left direction\n   return 0.0 <= dot( p-a, vec2( a.y-b.y, b.x-a.x ) )  ;\n}\n//-------------------------------------------------------------------------------------\n// returns true iif 'p' is on the left side of the line through 'q' parallel to 'v' \n// ('v' is not neccesarily normalized)\n\nbool IsOnRightSidePV( vec2 p, vec2 q, vec2 v )\n{\n   // use dot product of p-q and vector to the right direction\n   return 0.0 <= dot( p-q, vec2( v.y, -v.x ) )  ;\n}\n\n//-------------------------------------------------------------------------------------\n// Conditional rotation \n//\n//  p            = point to rotate \n//  rot_center   = rotation center \n//  num_sectors  = number of rotation sectors  >1\n//  start_angle  = start angle (start of sector number 0, in radians, in the range -pi, +pi \n//  sector_num   = output sector number, between 0 and n-1\n//\n//  returns rotated point in the sector number 0\n\nvec2 ConditionalRotation( vec2 p, int num_sectors, float start_angle, \n                          inout int sector_num )\n{\n\n   // angle1 == p's angle, in the range [-pi,pi]\n   float angle1   = atan( p.y, p.x )  ; \n   \n   // angle2 == p's angle, but relative to 'start_angle', and in the range [0..2*pi]\n   float angle2 = ( start_angle <= angle1  ) \n                            ?  angle1 - start_angle \n                            :  2.0*pi - (start_angle - angle1) ; \n   \n   // angle3 == p's angle, in  [0,num_sectors) \n   float ns      = float( num_sectors ) ; // number of sectors (float)\n   float angle3  = (ns*angle2)/(2.0*pi) ; \n   \n   float sector_num_f = floor( angle3 );        // p's sector number (float, in 0..n-1)\n   float angle3_frac  = angle3 - sector_num_f ; // normalized angle inside the sector (in [0,1))\n   float rot_point_a  = start_angle + (angle3_frac*2.0*pi)/ns ; // angle of the point in the first sector\n   vec2  rot_point    = length( p )*vec2( cos(rot_point_a), sin(rot_point_a) ) ; // point in the first sector\n   \n   // output results \n   sector_num = int( sector_num_f );\n   return rot_point ;\n}\n\n//-------------------------------------------------------------------------------------\n// Compute pattern color at a point given in WCC\n\nvec4 PatternWCC( in vec2 point_wcc )\n{\n    // counters for the number of mirror transformations performed to take the point to the fundamental region\n    int msc1 = 0 ;\n    \n    // (t1,t2) --> translation symmetries vectors (both are normalized)\n    vec2  t1  = vec2( 1.0, 0.0 ),\n          t2  = vec2( cos_60, sin_60 );\n          \n    // compute pct = point coordinates in the translation vectors base\n    // (this code is generic, can be optimized and simplified for particular cases of (t1,t2), as this\n    \n    float d = dot(t1,t2);   // == cos_60 == 0.5 \n    \n    vec2  t1_dual     = t1-d*t2,      \n          t2_dual     = t2-d*t1 ;        \n    vec2  pct         = vec2( dot( point_wcc, t1_dual ), dot( point_wcc, t2_dual ));   \n    vec2  pct_inte    = floor( pct );\n    vec2  pct_frac    = pct - pct_inte ;\n    ivec2 pct_inte_i  = ivec2( int( pct_inte.x ), int( pct_inte.y ) ) ;\n    \n    // compute pc1 = point back in cartesian coordinates, inside de translation subgroup fundamental region\n    \n    vec2 pc1 = pct_frac.x*t1 + pct_frac.y*t2 ; \n    \n    // compute pc2 = point in the lower triangle (use  translation+rotation\n    bool in_upper_tri = IsOnRightSidePV( pc1, vec2( 1.0, 0.0 ), vec2( -cos_60, sin_60 ) );  \n    vec2 pc2 = pc1 ;\n    \n    // vertical distance from triangle center to triangle base horizontal edge\n    const float h = sin_60/3.0 ;\n    \n    // triangles centers (for both triangles in the translation fund. region)\n    const vec2 tri_cen        = vec2( 0.5, h );     // lower triangle center\n    const vec2 upper_tri_cen  = vec2( 1.0, 2.0*sin_60/3.0 ); // upper triangle center\n    \n    // if in upper triangle, make 'pc3' equal to pc2 180 rotated around the order-2 rotation symmetry center\n    // ('pc3' is relative to triangle center) (if p == tri.center or upper tri_cen, then pc3 = (0,0))\n    // ( this amounts to another conditional transformation)\n    \n    vec2 pc3 = in_upper_tri ? upper_tri_cen-pc2 : pc2-tri_cen ;\n         \n    \n    \n   // compute pc4 = pc3 but rotated so it lies in the first sector\n   // (get also the original sector number )\n   \n   int  sector_num  ;\n   const float sector_0_angle = -pi/2.0 ; // start angle for sector number 0 (-90)\n   //const float sector_0_angle = -2.0*pi/3.0 ; // start angle for sector number 0 (-120)\n   \n   \n   vec2 pc4 = ConditionalRotation( pc3, 3, sector_0_angle, sector_num );\n   \n   bool in_fund_region = pct_inte_i.x == 0 &&  pct_inte_i.y == 0 && \n                         sector_num == 0 && ! in_upper_tri ;\n   \n   bool in_schematic_view_edges = false ;\n    \n   if ( schematic_view )\n   {\n        // draw triangles center disk\n        //if ( length( pc4 ) < 0.02 )\n        //    return vec4( 0.6, 0.6, 0.6, 1.0 );\n           \n        // draw triangle edges\n        // w = half widths of debug edge bands\n        float dew = 0.002 ;\n\n        // distances to fundamental region edges\n        \n        const float \n           a0 = sector_0_angle ,\n           a1 = sector_0_angle + 2.0*pi/3.0 ;\n        float   \n           d1 = abs( SignedDistancePN( pc4, vec2( 0.0, 0.0 ), vec2( cos(a0), sin(a0) ) ) ), // distance to sector start radius\n           d2 = abs( SignedDistancePN( pc4, vec2( 0.0, 0.0 ), vec2( cos(a1), sin(a1) ) ) ), // distance to sector end radius\n           d3 = abs( SignedDistancePN( pc4, vec2( 0.0, -h ),  vec2(  1.0,     0.0   ) ) ),   // distance to triangle baseline edge\n           d4 = abs( SignedDistancePN( pc4, vec2( 0.5, -h ),  vec2( -cos_60, sin_60 ) ) );   // distance to right triangle edge \n        \n        float dmin = min( min( d1, d2 ), min( d3, d4 )) ;\n\n        in_schematic_view_edges = (dmin <= dew );\n   }\n   \n   // compute centers for the 4 arcs which partially overlap the fundamental region\n   \n   const float ca_radius = 0.5/(2.0*cos_30) ;  // circumference arc radius\n   \n   const vec2  \n      arc_center_1 = vec2( 0.0, -h ) + ca_radius * vec2( cos_30, -sin_30 ),\n      arc_center_2 = rot_120 * arc_center_1,\n      arc_center_3 = rot_120 * arc_center_2,        \n      arc_center_4 = vec2( 0.5, -h ) + ca_radius * vec2( 0.0, -1.0 ) ; \n   \n   float       \n      pc4_radius_1 = length( pc4 - arc_center_1 ),                 \n      pc4_radius_2 = length( pc4 - arc_center_2 ),                 \n      pc4_radius_3 = length( pc4 - arc_center_3 ),                \n      pc4_radius_4 = length( pc4 - arc_center_4 );                 \n   \n   bool        \n      in_birdie  = ( pc4_radius_1 <= ca_radius ), \n      in_arc     = ( abs( pc4_radius_1 - ca_radius ) <= 0.5*edge_width ) ||\n                   ( abs( pc4_radius_2 - ca_radius ) <= 0.5*edge_width ) ||\n                   ( abs( pc4_radius_3 - ca_radius ) <= 0.5*edge_width ) ||\n                   ( abs( pc4_radius_4 - ca_radius ) <= 0.5*edge_width ) ;\n   \n   //if ( in_upper_tri )\n   //   in_birdie = ! in_birdie ;\n      \n   // compute hex_vi == the vertexes defining the portion of the \n   //                   hexagon boundary inside the fund. reg. \n      \n      \n   // compute 'hex_v2', 'hex_v3', the two hexagon vertexes inside the fund. region\n  \n   const float acl    = length( arc_center_1 );\n   const vec2  acn    = arc_center_1/acl ;\n   const vec2  hex_v2 = acn*( acl - ca_radius - 0.5*edge_width-ah_gap );\n   vec2        hex_v3 = IncMirrorPN( hex_v2, vec2( 0.0, 0.0 ), vec2( cos_30, -sin_30 ) );\n   \n   // compute 'hex_v1' and then 'hex_v4' by using summetry\n   \n   const vec2  hex_v1 = vec2( 0.0, hex_v2.y ); // hex_v1 to the right of hex_v2\n   vec2        hex_v4 = IncMirrorPN( hex_v1, vec2( 0.0, 0.0 ), vec2( cos_30, -sin_30 ) );\n   \n    \n   // compute hexagon inclusion by using hexagon vertexes\n   \n   bool in_hexagon = IsOnLeftSidePP( pc4, hex_v1, hex_v2 ) &&\n                     IsOnLeftSidePP( pc4, hex_v2, hex_v3 ) &&\n                     IsOnLeftSidePP( pc4, hex_v3, hex_v4 ) ;\n                     \n   vec4 col ; // resulting color\n   \n   if ( schematic_view )\n      col = (in_arc || in_hexagon)\n                ? vec4( 1.0, 1.0, 1.0,  1.0 ) \n                : vec4( 0.7, 0.7, 0.7, 1.0 );\n   else\n      col = (in_arc || in_hexagon)\n                ? vec4( 1.0, 1.0, 0.9, 1.0 ) \n                : vec4( 0.3, 0.3, 0.3, 1.0 );\n   \n      \n   if ( schematic_view && in_fund_region )\n      col = (in_arc || in_hexagon) \n            ? vec4( 1.0, 0.7, 0.6, 1.0 ) \n            : vec4( 1.0, 0.2, 0.22, 1.0 );\n   \n   if ( in_schematic_view_edges )\n      col = vec4( 0.7, 0.4, 0.2, 1.0 );\n      \n   \n   \n   return col ;\n}\n\n\n//-------------------------------------------------------------------------------------\n// Compute anti-aliased pixel colors for a point given in device coordinates\n// point_dcc = integer pixel coordinates, starting at zero (device coordinates)\n\nvec4 AAPixelColor( in vec2 point_dcc )\n{\n    vec4 sum  = vec4( 0.0, 0.0, 0.0, 1.0 ); // sum of samples colours \n     \n    for( int i = 0 ; i < nspp_root ; i++ )\n    for( int j = 0 ; j < nspp_root ; j++ )\n    {\n       // compute sample position in device coordinates, then in world coordinates\n       vec2 sample_dcc = point_dcc + (vec2(float(i)+0.5,float(j)+0.5)/nspp_root_f) ;\n       vec2 sample_wcc = vis_wcc_sx*(sample_dcc-0.5*iResolution.xy)/iResolution.xx ;\n       \n       // add this sample color to 'sum' (rotated -30 deg so we match the original tiling)\n       sum = sum + PatternWCC( rot_30*sample_wcc ); \n    }\n    return sum/float(nspp_root*nspp_root) ;\n}\n//-------------------------------------------------------------------------------------\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = AAPixelColor( fragCoord ) ;\n    \n}","name":"Image","description":"","type":"image"}]}