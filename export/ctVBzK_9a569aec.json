{"ver":"0.1","info":{"id":"ctVBzK","date":"1702459344","viewed":62,"name":"Plastic Mountains","username":"Chroma_Crash","description":"Made with a slightly modified raymarcher to account for the inaccuracy of the sdf for the mountain plane offset with perlin noise. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","water","specular","mountains","diffuse","snow","primitive","plastic"],"hasliked":0,"parentid":"DtGBzy","parentname":"Sea of Spheres"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define STEPS 256\n#define MAX_MARCH 500.0\n#define HIT_DISTANCE 0.01\n\n#define LIGHT_DIRECTION normalize(vec3(0.8, 1, 1))\n#define LIGHT_COLOR vec3(1.2, 1, 1.2)\n#define AMBIENT 0.1\n\n#define DISTANCE 16.0\n#define ANGLE PI / 10.0\n\n#define PIXEL_SIZE 1.0\n\n\nstruct Material {\n    float diffuse;\n    float specular;\n    vec3 color;\n};\n\n#define MOUNTAIN Material(1.2, 0.4, vec3(0.65, 0.7, 0.4))\n#define WATER    Material(1.0, 1.0, vec3(0.6, 0.8, 1.2))\n#define TREE     Material(1.0, 0.0, vec3(0.8, 0.8, 0.3))\n\nMaterial[3] MATERIALS = Material[](MOUNTAIN, WATER, TREE);\n                         \nfloat samplePerlin(vec2 uv) {\n    float[5] zoom    = float[] (0.1, 0.02, 0.8, 2.0, 7.0);\n    float[5] weights = float[] (0.65, 0.25, 0.08, 0.03, 0.01);\n   \n    float value = 0.0;\n    \n    for (int i = 0; i < 5; i++) {\n        value += texture(iChannel0, uv * zoom[i]).x * weights[i];\n    }\n    \n    return value;\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdField(vec3 p) {\n    return p.y + samplePerlin(p.xz / 100.0) * 25.0;\n}\n\nfloat sdGrass(vec3 p) {\n    float fieldHeight = sdField(p);\n    if (fieldHeight - p.y > 9.9) {\n        return fieldHeight;\n    }\n    float grassHeight = (samplePerlin(p.xz) - 0.5) * 4.0;\n    return fieldHeight + grassHeight + 0.1;\n}\n\nfloat sdTree(vec3 p, vec2 s)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 select(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 camera(float time) {\n    return vec3(0, DISTANCE * 5.0 / 12.0, (time / 6.0) * 12.0);\n}\n\nvec2 world(vec3 p) {\n    vec2 res = vec2(p.y + 20.0, -1);\n    \n    float field = sdField(p);\n    float water = sdPlane(p + vec3(0, 15.0, 0));\n    //float grass = sdGrass(p);\n    \n    //res = select(res, vec2(grass, 2));\n    res = select(res, vec2(field, 0));\n    res = select(res, vec2(water, 1));\n    //res = select(res, vec2(trees, 2));\n\n    return res;\n}\n\nvec3 get_normal(in vec3 p) {\n    const vec3 s = vec3(-1.0, 0.0, 0.0);\n    \n    float g = world(p).x;\n    \n    float g_x = g - world(p - s.xyy).x;\n    float g_y = g - world(p - s.yxy).x;\n    float g_z = g - world(p - s.yyx).x;\n\n    vec3 normal = -1.0 * vec3(g_x, g_y, g_z);\n\n    return normalize(normal);\n}\n\nfloat specular(vec3 cam, vec3 pos, vec3 normal) {\n    vec3 viewDir = normalize(cam - pos);\n    vec3 reflectDir = reflect(-LIGHT_DIRECTION, normal);\n    \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 4.0);\n    return spec;\n}\n\nfloat diffuse(vec3 normal) {\n    float diffuse = (dot(LIGHT_DIRECTION, normal) + 1.0) / 2.0;\n    return diffuse;\n}\n\nvec4 raymarch(in vec3 ro, in vec3 rd) {\n    float traveled = 0.0;\n    \n    vec3 p = ro;\n    \n    float max_travel;\n    float num;\n\n    for (int i = 0; i < STEPS; i++) {\n        p = ro + traveled * rd;\n        \n        vec2 world = world(p);\n    \n        max_travel = world.x;\n        num = world.y;\n        \n        if (max_travel < HIT_DISTANCE && (max_travel > -HIT_DISTANCE || i < STEPS - 20)) {\n            return vec4(ro + (traveled + max_travel) * rd, world.y);\n        }\n        \n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        traveled += max_travel * 0.5;\n    }\n    if (max_travel < HIT_DISTANCE) {\n        return vec4(ro + (traveled + max_travel) * rd, num);\n    }\n    return vec4(p, -1);\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float traveled = 0.5;\n    \n    float res = 1.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec2 world = world(ro + traveled * rd);\n        \n        float max_travel = world.x;\n        \n        if (max_travel < HIT_DISTANCE) {\n            return 0.0;\n        }\n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        res = min(res, 1.0 * max_travel / traveled);\n        \n        traveled += max_travel;\n    }\n    \n    return res;\n}\n\nvec4 render(vec2 uv, float time) {\n    uv *= 0.6;\n\n    vec3 ro = camera(time);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float d = ANGLE;\n    \n    mat3 rx = mat3(1,       0,      0,\n                   0,  cos(d), sin(d),\n                   0, -sin(d), cos(d));\n                  \n    d = (-time / 6.0) - PI / 2.0;\n    \n    mat3 ry = mat3(cos(d), 0, -sin(d),\n                        0, 1,       0,\n                   sin(d), 0,  cos(d));\n                   \n    rd = ry * rx * rd;\n    \n    vec4 march = raymarch(ro, rd);\n    \n    vec3 pos = march.xyz;\n    vec3 normal = get_normal(pos);\n    \n    int num = int(march.w);\n    \n    float fog_mult = 0.9 * clamp(dot(rd, LIGHT_DIRECTION) / 2.0 + 1.2, 0.6, 1.2);\n    \n    if (num == -1) {\n        return vec4(LIGHT_COLOR * fog_mult, 1);\n    }\n    \n    Material material = MATERIALS[num];\n    \n    vec3 col = material.color;\n    \n    if (num == 0) {\n        float height = pos.y;\n        col = mix(col, vec3(0.3, 0.4, 0.2), clamp(height + 9.2 + normal.y * 6.0, 0.0, 1.0));\n        col = mix(col, vec3(0.4, 0.2, 0.1), clamp(4.4 - normal.y * 4.0 + (height + 7.7) * 0.2, 0.0, 1.0));\n        col = mix(col, vec3(1, 1, 1.2), clamp(normal.y * 6.0 + (height + 1.0) * 0.6, 0.0, 1.2));\n    }\n    if (num == 1) {\n        float dist = samplePerlin(pos.xz / 100.0) * 25.0 - 15.0;\n        col = mix(col, vec3(0.05, 0.05, 0.6), clamp((dist - 1.2) * 1.5, -0.4, 1.4));\n    }\n    \n    float lighting = max(AMBIENT, diffuse(normal) * material.diffuse) + specular(ro, pos, normal) * material.specular;\n    \n    float shadow_cast = shadow(pos, LIGHT_DIRECTION);\n    \n    float gamma_corrected = pow(shadow_cast * lighting + AMBIENT, 2.2);\n    \n    col = gamma_corrected * LIGHT_COLOR * col;\n    \n    float fog = clamp(2.0 * length(pos - ro) / MAX_MARCH, 0.0, 1.0);\n    col = mix(col, LIGHT_COLOR * fog_mult, fog);\n    \n    return vec4(col, 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec4 col = render(uv, iTime);\n\n    fragColor = col;\n}\n\n\n","name":"Image","description":"","type":"image"}]}