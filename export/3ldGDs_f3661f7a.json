{"ver":"0.1","info":{"id":"3ldGDs","date":"1577991730","viewed":141,"name":"Regular tilings","username":"voax","description":"Mosaics using the 3 regular tilings.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","tiling","mosaic","regular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float size = 100.0; // length of edges\nconst float sin30 = 0.5;\nconst float cos30 = 0.86602540378; // = sin60 = sqrt(3) / 2.0\nconst float sqrt3 = sqrt(3.0);\n\nivec2 hexCell(vec2 xy) {\n    vec2 n = xy / vec2(sqrt3 * size, size * 1.5);\n    \n    ivec2 i;\n    i.y = int(floor(n.y)); \n    \n    bool odd = i.y % 2 == 1;\n    if (odd) // odd rows\n    \tn.x -= 0.5;\n    \n    i.x = int(floor(n.x));\n    vec2 r = fract(n);\n\n    if (r.y > 2.0 / 3.0) {\n        // diagonal areas\n        float y = (r.y - 2.0 / 3.0) * 3.0;\n        if (r.x < 0.5) {\n            // top-left/bottom-right\n            float x = r.x * 2.0;\n            if (y > x) {\n                i.x += odd ? 0 : -1;\n                i.y += 1;\n            }\n        } else {\n            // top-right/bottom-left\n            float x = (r.x - 0.5) * 2.0;\n            if (x > 1.0 - y) {\n                i.x += odd ? 1 : 0;\n                i.y += 1;\n            }\n        }\n    }\n    \n    return i;\n}\n\nvec2 hexGrid(vec2 xy) {\n    ivec2 cell = hexCell(xy);\n    \n    vec2 result = vec2(cell) * vec2(sqrt3 * size, 1.5 * size);\n    if (cell.y % 1 == 0)\n        result.x += cos30 * size;\n    return result;\n}\n\nbool feq(float a, float b) {\n\treturn abs(a-b) < 1e-5;   \n}\n\nvec2 triangleCell(vec2 xy) {\n    vec2 pos = xy / vec2(size * sin30, size * cos30);\n    vec2 i = floor(pos);\n    vec2 r = fract(pos);\n    if(feq(mod(i.x, 2.), 1.) ^^ feq(mod(i.y, 2.), 1.)) { \n        if (r.x + r.y < 1.0)\n            i.x--; \n    } \n    else { \n        if(r.x - r.y < 0.0)\n            i.x--; \n    }\n    return i;\n}\n\nvec2 triangleGrid(vec2 xy) {\n    vec2 i = triangleCell(xy);\n    vec2 origin = vec2(i) * vec2(size * sin30, size * cos30);\n    float c = cos30 * 2.0 / 3.0;\n    if (feq(mod(i.y, 2.), 1.) ^^ feq(mod(i.x, 2.), 1.))\n        origin.y += size * cos30 * 2.0 / 3.0;\n    else\n        origin.y += size * cos30 - (0.5 * size) / cos30;\n    origin.x += 0.5 * size;\n    return origin;\n}\n\nvec2 rectCell(vec2 xy) {\n    return floor(xy / size);\n}\n\nvec2 rectGrid(vec2 xy) {\n    vec2 i = rectCell(xy);\n \treturn i * size + size / 2.0;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.5)\n        size = 1.0 + floor(iMouse.x * 50.0 / iResolution.x);\n    else\n        size = 1.0 + (1.0 + sin(iTime)) * 50.0;\n    \n    vec2 xy = fragCoord;\n    \n    float t = fract(iTime / 4.0);\n    if (t < 0.33)\n    \txy = hexGrid(xy);\n    else if (t < 0.66)\n    \txy = rectGrid(xy);\n    else\n        xy = triangleGrid(xy);\n\n    vec2 uv = xy/iResolution.xy;\n    \n    // vec3 col = texelFetch(iChannel0, ivec2(uv*vec2(textureSize(iChannel0, 0).xy)), 0).rgb; // for textures with mipmaps\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}