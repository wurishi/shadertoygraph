{"ver":"0.1","info":{"id":"wtScRt","date":"1595071897","viewed":136,"name":"julia's set","username":"CyanMARgh","description":"here is some sdf's and julia set on screen for example.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","julia","noob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0., .6, -5.5);\nfloat softShadow = 10.;\nfloat depthmax = 40.; \nconst float eps = 1e-4;\nvec3 backcol = vec3(1.,1.,1.)*1.;\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n//SDF operations\n//colored\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//uncolored\nfloat un(float d1, float d2){\n    return d1<d2?d1:d2;\n}\nfloat dif(float d1, float d2){\n    d2*=-1.;\n    return d1>d2?d1:d2;\n}\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//additioanal operations\nvec4 qxq( in vec4 a, in vec4 b){\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, \n        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );\n\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//SDF\nfloat sphere(vec3 pos){\n    return length(pos);\n}\nfloat plane(vec3 n, vec3 pos){\n    return dot(pos, n);\n}\nfloat capsule(vec3 a, vec3 b, float r1, float r2, vec3 p){\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\t\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                           return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat disk(vec3 p0, vec3 n, float r,vec3 p){\n    p-=p0;\n    float d = length(p);\n    float h = abs(dot(p,n));    \n    float R = sqrt(d*d-h*h)-r;\n    return (R>0.)?sqrt(h*h+R*R):h;\n}\nfloat loop(vec3 p0, vec3 n, float r,vec3 p){\n\tp-=p0;\n    float d = length(p);\n    float h = abs(dot(p,n));    \n    float R = sqrt(d*d-h*h)-r;\n    return sqrt(h*h+R*R);\n}\nfloat cylinder(vec3 a, vec3 b, float r, vec3 p){\n    p-=a;b-=a;\n    float k = dot(b,p)/dot(b,b);\n    float d1 = length(b*k-p)-r;\n    if(k>0.&&k<1.){\n        return d1;\n    }else{\n        float d2 = (abs(k-.5)-.5)*length(b);\n        if(d1>0.){            \n            return sqrt(d1*d1+d2*d2); \n        }else{\n            return d2;\n        }\n    }\n}\nfloat cut(vec3 p, float r){\n    p*=r;\n  \tfloat da = box(vec3(inf,1.0,1.0),p);\n\tfloat db = box(vec3(1.0,inf,1.0),p);\n\tfloat dc = box(vec3(1.0,1.0,inf),p);\n\treturn min(da,min(db,dc))/r;\n}\nfloat sponge(vec3 p, int L){\n\tfloat d = box(vec3(1.,1.,1.),p);\n    float s=1.;\n    float r=4.;\n    do{\n        d = max(-cut(p,r/(r-2.))/s,d);\n        p = mod((p+1.)*r,2.)-1.;   \n        s*=4.;L--;\n    }while(L>0&&length(p)<2.5);\n    return d;\n}\nfloat julia(int L, vec3 p){\n\tfloat t = iTime / 3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( p, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<L;i++){\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0){\n\t\t\tbreak;\n        }\n\t}\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n//color functions\nvec3 checkerboard(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return vec3(1.)*((d.x+d.y+d.z)%2==0?1.:.8);\n}\n//scene SDF\nvec4 map(vec3 p){\n    //\"room\"\n    vec4 d0 = vec4(.9,.9,1.,plane(vec3(0.,1.,0.),p)+1.5);\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(0.,0.,-1.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(1.,0.,0.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,box(vec3(1.,1.,1.),p-vec3(0.,-2.,0.))));\n    d0.xyz *= checkerboard(p);\n\n    p+=vec3(.0,.1,.0);\n    \n    //julia set\n    vec4 jul = vec4(1.,.6,.6,julia(8,p*.5-vec3(.0,.5,.0)));\n    d0 = cun(d0,jul);\n    \n    return d0;\n}\n//normal vector by point\nvec3 norm(vec3 pos){\n    const vec2 e = vec2(eps,0.);\n    float d = map(pos).w;\n    return normalize(vec3(\n        map(pos + e.xyy).w-d,\n        map(pos + e.yxy).w-d,\n        map(pos + e.yyx).w-d\n    ));\n}\n\n//color and length of ray\nvec4 rayCast(vec3 eye, vec3 dir){\n    vec3 pos; float depth=0.,dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n        depth += dist;\n        if (dist < eps){\n            break;\n        }else if(depth>depthmax){\n            depth = depthmax+eps;\n            break;\n        }\n    }\n    rc.w=depth;\n    return rc;\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //direction calculation\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float angle = (1.2+cos(iTime*.4))*.6;\n    eye.xz*=ro(angle);\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n\n    //raymarching\n    vec4 rc = rayCast(eye, dir);\n    float depth = rc.w;\n\n    vec3 pos = eye+dir*depth;\n    vec3 n = norm(pos);\n    pos+=eps*n;\n    \n    vec3 col = rc.xyz;\n    vec3 lighting = vec3(.25);\n\n    if (depth < depthmax){\n\n        // adding 3 point lights and one directional light\n        lighting += getLight(pos, vec3(6., 8., 0.), n, vec3(1.,.9,.9), 15.,false);\n        lighting += getLight(pos, vec3(6., 8., -10.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(-10., 10., -2.), n, vec3(1.,1.,1.), 30.,false);\n        lighting += getLight(pos, vec3(2., 13., -10.), n, vec3(1.,.9,.9), 120.,true);\n        \n        //lighting -= getOcc(pos, n);\n\t\tcol *= lighting;\n    }else{\n        col=backcol;\n    }\n    \n    //compositing color, lighting and fog\n    fragColor = vec4(1.5*log(1.+ col)*exp(-0.003*depth), 1.0);\n}","name":"Image","description":"","type":"image"}]}