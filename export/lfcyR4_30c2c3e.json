{"ver":"0.1","info":{"id":"lfcyR4","date":"1730301856","viewed":89,"name":" moving to","username":"nayk","description":"originals  https://www.shadertoy.com/view/lccyz8 and fractal 62","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["color","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define A(v) mat2(cos(m.v*3.1416 + vec4(0, -1.5708, 1.5708, 0)))  // rotate\n#define H2(v) (cos((v)*6.2832 + radians(vec3(-60, 0, 60)))*.5+.5)  \n\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n \n    //return vec3(0, 0, t); // Straight path.\n    return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n   \n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = ( C- .5*iResolution.xy ) / iResolution.y;\n    vec2 U=C;\n    vec4 C2= O;\n    float t = iTime/10.,\n          l = 50.,  // raymarch loop\n          a = 2.,   // aa loop\n          i, d, s;\n   \n    vec2 R = iResolution.xy, o,\n         m = (iMouse.z > 0.) ?  // clicking?\n                 (iMouse.xy - R/2.)/R.y:   // mouse coords\n                 vec2(.0, .00);  // default cam\n   \n    vec3 c = vec3(0), u, p, r, g;\n   \n    mat2 v = A(y),  // pitch\n         h = A(x);  // yaw\n   \n    for (int k = 0; k < int(a*a); k++) // aa loop\n    {\n        o = vec2(k%2, k/2)/a;  // aa offset\n        u = normalize(vec3(U - R/2. + o, R.y*.7));  // coords\n \n        d = 0.;\n        for (i = 0.; i++<l;) // raymarch\n        {\n            p = u*d;  // new coords\n            float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n    uv.xy*=ma;\n            p.y = abs(p.y);  // reflect y\n            p.xy += .5;  // shift\n            p.z += sqrt(2.*t*t*round(p.y));  // move z\n            p = abs(p-round(p));  // grid\n            s = smoothstep(.25, .3, max(p.x, max(p.y, p.z)));  // cubes (glass)\n            s = max(s, .24-max(p.x, max(p.y, p.z)));  // inner cubes (hologram)\n            if (s < 1e-3 || d > 1e3) break;  // limit break\n            d += s;  // add scene\n        }\n        c += d/l + max(.5-H(d), 0.);  // add objects & color\n    }\n   \n    c /= a*a;  // fix brightness after aa pass\n    r = H(length(u.xy))*.5+.5;  // color (radial)\n    c *= r;\n\n    p = abs(p-p.yzx)/p;  // adjust coords\n   \n   \n   \n    C2 = vec4(c + c*c, 1);\n      vec2 R2 = iResolution.xy, o2,\n         m2 = (iMouse.z > 0.) ?  // clicking?\n                 (iMouse.xy - R/2.)/R.y:   // mouse coords\n                 vec2(.0, .00);  // default cam\n   \n    vec3 c2 = vec3(0), u2,  g2;\n   \n    mat2 v2 = A(y),  // pitch\n         h2 = A(x);  // yaw\n    vec3 n1,q,r2=iResolution,\n    d2=normalize(vec3((C*2.-r2.xy)/r2.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.1,0.2,2.),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        n1=g*d2;\n     \n   \n// Screen coordinates.\nvec2 u = (C - iResolution.xy*0.5)/iResolution.y;\n\n// Camera Setup.\n    float speed = 22.0;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 1.); // Light position, somewhere near the moving camera.\n lk.z+=iTime*10.;\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, 1, 0);\n    vec2 a2 = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    loffs.xy = mat2(a2, -a2.y, a2.x)*loffs.xy;\n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 30.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r2 = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n       \n        n1.z+=iTime*20.;\n\n        a=30.;\n        n1=mod(n1-a,a*2.)-a;\n        s=3.;\n         n1*=r2;\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.5+sin(iTime*.0001)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.*3.+cos(iTime*.15),\n                    120.,\n                    8.+cos(iTime*.15)*5.\n                 )*c;\n         }\n         g+=e=length(n1.yzzz)/s;\n    }\n   \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.85)*10., 1.0);\n}\n","name":"Image","description":"","type":"image"}]}