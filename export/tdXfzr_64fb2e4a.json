{"ver":"0.1","info":{"id":"tdXfzr","date":"1588800981","viewed":82,"name":"561_Rabbitz_1","username":"mrabbitz","description":"Practice with Noise and UV Mapping.  2D worley noise is UV mapped to the plane, 2D 4-octave FBM is UV mapped to the sphere, and 3D Perlin noise is applied (not UV mapped) to the box.  All of it is animated using iTime.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\n////////////////////PERLIN//////////////////////////////////////////////////\n\nvec3 random3o3i(vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                        dot(p, vec3(269.5, 183.3, 765.54)),\n                        dot(p, vec3(420.69, 631.2, 109.21))))\n                        * 43758.5453);\n}\n\nfloat surflet3D(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3o3i(gridPoint) * 2. - vec3(1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlinNoise3D(vec3 uv) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet3D(uv, floor(uv) + vec3(dx, dy, dz));\n            }\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\n////////////////////WORLEY//////////////////////////////////////////////////\n\n\nfloat WorleyNoise2D(vec2 uv) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            \n            point = 0.5 + 0.5 * sin(iTime * 0.1 + 6.2831 * point); // 0 to 1 range\n            \n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n////////////////FBM//////////////////////////////////////////////////\n\n// random1o2i\nfloat noise2D(vec2 p) {\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453);\n}\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1.0, intY));\n    float v3 = noise2D(vec2(intX, intY + 1.0));\n    float v4 = noise2D(vec2(intX + 1.0, intY + 1.0));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    \n    return mix(i1, i2, fractY);\n}\nfloat fbm2D(float x, float y) {\n    float total = 0.0;\n    float persistence = 0.5;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\n////////////////////////////////////////////////////////////////\n\n\nconst int RAY_STEPS = 256;\n#define LIGHT_POS vec3(0.0, 2.45, 2.0)\n\nstruct Intersection\n{\n    vec3 p;\t\t// point of intersection in world space\n    float t;\t// t-value of ray to p\n    int objHit;\t// assign every object in scene a unique ID integer\n    vec3 color;\t// color of surface\n};\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}    \n    \n// Takes in direction, rotates it by a radians\n// result of applying a y rotation matrix to the vec3\n// rotates about y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat PlaneSDF(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz)+n.w;\n}\n\n#define BOX_SDF BoxSDF(pos + vec3(2.5, 0.0, 0.0), vec3(1.0))\n#define SPHERE_SDF SphereSDF(pos, 1.5, vec3(2.5, 0.0, 0.0))\n#define PLANE_SDF PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 3.0))\n\n#define BOX 0\n#define SPHERE 1\n#define PLANE 2\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPaletteWorley(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nconst vec3 a1 = vec3(0.5, 0.5, 0.5);\nconst vec3 b1 = vec3(0.5, 0.5, 0.5);\nconst vec3 c1 = vec3(1.0, 1.0, 1.0);\nconst vec3 d1 = vec3(0.0, 0.33, 0.67);\n\nvec3 colorPalettePerlin(float t) {\n    return a1 + b1 * cos(6.28 * (t * c1 + d1));\n}\n\nconst vec3 a2 = vec3(0.5, 0.5, 0.5);\nconst vec3 b2 = vec3(0.5, 0.5, 0.5);\nconst vec3 c2 = vec3(1.0, 1.0, 1.0);\nconst vec3 d2 = vec3(0.0, 0.1, 0.2);\n\nvec3 colorPaletteFBM(float t) {\n    return a2 + b2 * cos(6.28 * (t * c2 + d2));\n}\n\nvec3 ComputeMaterial(int objHit, vec3 pos, vec3 nor, vec3 light, vec3 view)\n{\n    switch(objHit)\n    {\n        case BOX:\n        pos = pos * 5.;\n        pos = (cos(iTime / 10.) * 10.) + pos;\n        return colorPalettePerlin(perlinNoise3D(pos));\n        break;\n    \tcase SPHERE:\n        \n        // vector from center of sphere to point of intersection\n        pos = normalize(pos - vec3(2.5, 0.0, 0.0));\n        \n        float phi = atan(pos.z, pos.x);\n        if (phi < 0.0)\n        {\n            phi += 2. * 3.14159;\n        }\n        float theta = acos(pos.y);\n        \n        vec2 newUV = vec2(1. - phi / (2. * 3.14159), 1. - theta / 3.14159);\n        \n        newUV *= 7.;\n        newUV = (cos(iTime / 10.) * 10.) + newUV;\n        \n    \treturn colorPaletteFBM(fbm2D(newUV.x, newUV.y));\n    \tbreak;\n    \tcase PLANE:\n        \n        // https://gamedev.stackexchange.com/questions/172352/finding-texture-coordinates-for-plane\n        vec3 e1 = normalize(cross(vec3(0.,1.,0.), vec3(1.,0.,0.)));\n        vec3 e2 = normalize(cross(vec3(0.,1.,0.), e1));\n        float u = dot(e1, pos);\n\t\tfloat v = dot(e2, pos);\n        \n    \treturn colorPaletteWorley(WorleyNoise2D(vec2(u, v) / 20.0));\n    \tbreak;\n    \tcase -1:\n    \t// Background\n    \treturn vec3(0.0);\n    \tbreak;\n\t}\n\treturn vec3(1.0);    \n}\n\nfloat SceneSDF(vec3 pos, vec3 lightPos)\n{\n    float t = BOX_SDF;\n    t = min(t,SPHERE_SDF);\n    t = min(t,PLANE_SDF);\n    return t;\n}\n\nvec3 ComputeNormal(vec3 pos, vec3 lightPos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx, lightPos) - SceneSDF(pos - offset.yxx, lightPos),\n                            SceneSDF(pos + offset.xyx, lightPos) - SceneSDF(pos - offset.xyx, lightPos),\n                            SceneSDF(pos + offset.xxy, lightPos) - SceneSDF(pos - offset.xxy, lightPos)\n                          )\n                    );\n}\n    \nvoid SceneSDF(vec3 pos, out float t, out int objHit, vec3 lightPos)\n{\n    t = BOX_SDF;\n    objHit = BOX;\n    \n    float t2;\n    if((t2 = SPHERE_SDF) < t)\n    {\n        t = t2;\n        objHit = SPHERE;\n    }\n    if((t2 = PLANE_SDF) < t)\n    {\n        t = t2;\n        objHit = PLANE;\n    }\n}\n    \nvoid RayMarch(vec3 origin, vec3 dir, out float t, out int objHit, vec3 lightPos)\n{\n    // starts slightly > 0\n    // so that if we march from a different point in the scene that isnt the camera\n    // we dont immediately intersect ourselves\n    t = 0.001;\n    // ray march not to a certain distance but for a certain number of iterations\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        // minimum distance that pos is from all SDFs in the scene\n        float m;\n        SceneSDF(pos, m, objHit, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // hit nothing\n    t = -1.0;\n    objHit = -1;\n}\n    \nIntersection SceneIntersection(vec3 eye, vec3 dir, vec3 lightPos)\n{\n    float t;\n    int objHit;\n    // Marches along ray to find point of intersection\n    RayMarch(eye, dir, t, objHit, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = ComputeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = ComputeMaterial(objHit, isect, nor, lightDir, normalize(eye - isect));\n        \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0));\n        \n    return Intersection(isect, t, objHit, surfaceColor);\n}\n    \nconst vec3 worldUp = vec3(0,1,0);\nvoid RayCast(vec2 ndc, out vec3 eye, out vec3 dir, out vec3 ref)\n{\n    eye = vec3(0.0, 5.0, 15.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.08) * distance(eye, ref);\n   \n    vec3 H = normalize(cross(worldUp, ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\n// mainImage: present in every single shader program on shadertoy\n// outputs: the fragment color for the fragment it is operating on\n// takes in: the pixel space coordinates of the fragment it is coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // iResolution: width and height of screen in pixels (on bottom toolbar of image output)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert to range -1 to 1 for x and y\n    // Normalized Device Coordinates w.r.t. the center of the screen being (0,0)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 eye, dir, ref;\n    int idx = 0;\n    for (float i = 0.0; i < 1.0; i += 0.5)\n    {\n        for (float j = 0.0; j < 1.0; j += 0.5)\n        {\n            RayCast(uv + vec2(i, j) / iResolution.xy, eye, dir, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir, LIGHT_POS);\n        }\n    }\n                                                                          \n    vec3 avgColor = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    \n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.);\n}","name":"Image","description":"","type":"image"}]}