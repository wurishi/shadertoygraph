{"ver":"0.1","info":{"id":"NtsyW7","date":"1648415465","viewed":60,"name":"Pattern animé","username":"vcarpintero","description":"pattern animé","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = 2.0*fragCoord/iResolution.xy-1.0;\n    vec2 uv =fragCoord/iResolution.xy;\n    //uv.x*=iResolution.x/iResolution.y;\n    float p_angle = atan(uv.x, uv.y);\n    float p_distance = length(uv)*2.0;\n    //vec2 st = vec2(p_distance, p_angle);\n    float t=iTime;\n    //vec3 col = texture(iChannel0,vec2(1.0/st.x + t*2.0,st.y+1.)).xyz;\n    //vec3 col= texture(iChannel0,vec2(1./st.x +t,st.y +sin(t*0.5)+0.5)).xyz;\n    vec3 col = texture(iChannel0,uv).xyz;\n    vec3 r = vec3(1.0,0.,0.);\n    vec3 grad = vec3(uv.y);\n    col += mix(col,r,grad);\n    //col += mix(uv.x, col,0.5)\n    //col *= min(st.x*.5,1.0);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float stroke(float x, float s, float w){\n    float d = step(s, x+w*.5)-step(s,x-w*.5);\n    return clamp(d,0.,1.);\n}\nfloat rectSDF (vec2 st, vec2 s){\n    st = st*2.-1.;\n    return max(abs(st.x/s.x), abs(st.y/s.y));\n}\nfloat fill(float x, float size){\n    return 1.-step(size,x);\n}\nfloat flip(float v, float pct){\n    return mix(v, 1.-v, pct);\n}\nfloat Union(float d1, float d2){\n    return min(d1,d2);\n}\nvec3 bridgeOP(vec3 c, float d, float s, float w){\n    c*= 1.-stroke(d,s,w*2.);\n    return c + stroke(d,s,w);\n}\nvec2 rotate(vec2 str, float a){\n    str-=0.5;\n    str = mat2(cos(a), -sin(a), sin(a), cos(a))*str;\n    return str+.5;\n}\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    _st.x += step(1., mod(_st.y,2.))*1.5;\n    _st.y += step(1., mod(_st.x,2.))*1.5;\n    return fract(_st);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n    // ----- VARIABLES --------\n    \n    float PI = 3.1415926535897932384626433832795;\n    \n    // ----- ESPACE MONDE --------\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    //vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x-=0.25;\n    st.x*= iResolution.x/iResolution.y;\n    //st*=3.;\n    //st = fract(st);\n    vec2 str = tile(st,8.);\n    float t = iTime;\n    str = rotate(str,PI*0.25);\n    //vec2 str = rotate(st, sin(t)*3.14*0.5);\n    \n    // ----- FORMES --------\n    \n    float rect = rectSDF(str,vec2(1.3));\n    rect +=sin((iTime*3.14*0.25)+0.5); // l animation fonctionne que si placer dans un buffer // ---------------------\n    vec3 strok = vec3(stroke(str.x,.5,.02));\n    \n    // ----- RENDU --------\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    //col+= vec3(0.614,0.246,0.017);\n    //col+=vec3(str,0.0);\n    col+= stroke(rect,.5,.1);\n    //col+= fill(strok,.5);\n    //col = bridgeOP(col, strok,.4,.08);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}