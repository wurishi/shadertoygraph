{"ver":"0.1","info":{"id":"7sffWB","date":"1654427824","viewed":156,"name":"convex polyhedron raytracing","username":"jtomsu","description":"Method for calculating intersection points with convex polyhedron, defined with half-planes. (So nothing special)\nSee `convexPolyhedronIntersect`","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","convex","polyhedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Method for calculating intersection points with convex polyhedron, defined with half-planes.\n\n\n// from 1 to 4\n#define NUM_SHADOW_SAMPLES 4\n// from 0 to 4\n#define NUM_REFLECTION_SAMPLES 4\n\n// #define MOUSE_CAMERA_ENABLED\n\n\n// https://iquilezles.org/articles/intersectors/\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersect( in vec3 ro, in vec3 rd, vec3 boxSize)  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    // if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\n\n// tn: previous near hit\nvoid convexPolyhedronIntersect(vec3 ro, vec3 rd, inout float _tn, inout vec3 _normal) {\n    \n// planes are defined by normal (xyz) and offset along the normal (w).\nvec4 convexPolyhedronPlanes[] = vec4[](\n#if 0\n    vec4(1, 0, 0, sin(iTime)+1.0),\n    vec4(0, 1, 0, sin(iTime)*2.0 + 2.0),\n    vec4(0, 0, 1, 1),\n    vec4(-1, 0, 0, 1),\n    vec4(0,-1, 0, 1),\n    vec4(0, 0,-1, 1),\n    vec4(0, 1,-1, sin(iTime) + 1.0),\n    vec4(cos(iTime*2.0), 0, sin(iTime*2.0), 0.5)\n#elif 0\n    // octahedron\n    vec4(1,1,1,1),\n    vec4(-1,1,1,1),\n    vec4(1,1,-1,1),\n    vec4(-1,1,-1,1),\n    vec4(1,-1,1,1),\n    vec4(-1,-1,1,1),\n    vec4(1,-1,-1,1),\n    vec4(-1,-1,-1,1)\n#elif 0\n    // box\n    vec4(1,0,0,1),\n    vec4(0,1,0,1),\n    vec4(0,0,1,1),\n    vec4(-1,0,0,1),\n    vec4(0,-1,0,1),\n    vec4(0,0,-1,1)\n#else\n    // ???\n    // non constant - super slow!\n    vec4(normalize(vec3(1,1,1)),1),\n    vec4(normalize(vec3(-1,1,1)),1),\n    vec4(normalize(vec3(1,1,-1)),1),\n    vec4(normalize(vec3(-1,1,-1)),1),\n    vec4(normalize(vec3(1,-1,1)),1),\n    vec4(normalize(vec3(-1,-1,1)),1),\n    vec4(normalize(vec3(1,-1,-1)),1),\n    vec4(normalize(vec3(-1,-1,-1)),1),\n    vec4(normalize(vec3(-1,1,.5)),0.5),\n    vec4(normalize(vec3(1,0.2,.2)),0.6),\n    vec4(normalize(vec3(1,-0.2,-.2)),0.6),\n    vec4(normalize(vec3(-1,-0.2,.2)),0.5),\n    vec4(normalize(vec3(0,-0.3,1)),0.7),\n    vec4(normalize(vec3(0.2, 1.0, 0)), sin(iTime) + 0.5)\n#endif\n);\n\n    // bounding box\n    vec2 boxhit = boxIntersect(ro, rd, vec3(1,1.6,1.8));\n    if(boxhit.x<boxhit.y && boxhit.y>0.0 && boxhit.x>0.0 && boxhit.x>_tn) {\n        // _tn = boxhit.x;\n        return;\n    }\n\n    // hit_t h = hit_t(-1e10, 1e10, vec3(0.0)); // boxIntersect(ro, rd, vec3(1.0));\n    float tn = -1e10;\n    float tf = 1e10;\n    vec3 normal = vec3(1.0);\n    \n    for(int i = 0; i < convexPolyhedronPlanes.length(); i++) {\n        vec4 plane = convexPolyhedronPlanes[i];\n\t\tfloat dir_normal_dot = -dot(rd, plane.xyz);\n        if(dir_normal_dot == 0.0f) continue;\n\t\tfloat t = (dot(ro, plane.xyz) - plane.w) / dir_normal_dot;\n\t\tbool is_plane_front = dir_normal_dot >= 0.0;\n        normal = is_plane_front && t>tn ? plane.xyz : normal;\n        tn = is_plane_front ? max(tn, t) : tn;\n        tf = is_plane_front ? tf : min(tf, t);\n    }\n    \n    if(tn<_tn && tn<tf && tn>0.0) {\n        _tn = tn;\n        _normal = normalize(normal);\n    }\n}\n\nvoid planeIntersect(vec3 ro, vec3 rd, vec4 plane, inout float tn, out vec3 normal) {\n    float t = (dot(ro, plane.xyz) - plane.w) / -dot(rd, plane.xyz);\n    if(t<tn && t>0.0) {\n        normal = plane.xyz;\n        tn = t;\n    }\n}\n\n// return: xyz: normal, w: near hit\nvec4 Raycast(vec3 ro, vec3 rd) {\n    float tn = 1e20;\n    vec3 n = vec3(0,1,0);\n    planeIntersect(ro, rd, vec4(0, 1, 0, -1), tn, n);\n    convexPolyhedronIntersect(ro - vec3(0,0.0,-0.5), rd, tn, n);\n    convexPolyhedronIntersect(ro - vec3(-2,-0.5,0), rd, tn, n);\n    convexPolyhedronIntersect(ro - vec3(1.0,0.5,2.0), rd, tn, n);\n    convexPolyhedronIntersect(ro - vec3(-2.0,3.5,-1.5), rd, tn, n);\n    convexPolyhedronIntersect(ro - vec3(-4.0,1.0,6.5), rd, tn, n);\n    convexPolyhedronIntersect(ro - vec3(-16.0,1.0,5.5), rd, tn, n);\n    convexPolyhedronIntersect(ro - vec3(9.0,1.0,-4.5), rd, tn, n);\n    // h = hit_op_union(h, boxIntersect(ro - vec3(30,0,30), rd, vec3(15,2,15)));\n    // h = hit_op_union(h, boxIntersect(ro - vec3(30,0,-40), rd, vec3(15,50,15)));\n    // h = hit_op_union(h, planeIntersect(ro, rd, vec4(0,0,1, -6)));\n    return vec4(n, tn);\n}\n\nconst vec3 sundir = normalize(vec3(0.3, 0.6, 0.8));\nconst vec3 suncol = vec3(1.0, 0.2, 0.0) * 10.0;\n\nvec3 SampleSky(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    col = mix(vec3(1,1,1), vec3(0.2,0.6,0.8), smoothstep(0.2, 0.8, rd.y*.5+.5));\n    col += smoothstep(0.47, 0.5, dot(rd, sundir) * 0.5) * suncol;\n    return col;\n}\n\nbool checker_pattern_3(const vec3 pos, const vec3 scale) {\n\treturn(bool(\n\t\tint(mod(pos.x, scale.x * 2.0) < scale.x) ^\n\t\tint(mod(pos.y, scale.y * 2.0) < scale.y) ^\n\t\tint(mod(pos.z, scale.z * 2.0) < scale.x)));\n}\n\n// xyz: color\n// w: roughness\nvec4 WorldPointMat(vec3 p) {\n    vec4 mat = vec4(0.0);\n    \n    mat.rgb = vec3(0.5);\n    mat.w = 0.1;\n    // TODO: antialiasing!\n    if(checker_pattern_3(p, vec3(0.5))) {\n        mat.rgb += vec3(0,0.5,1) * 0.8;\n        mat.w = 0.5;\n    }\n    \n    return mat;\n}\n\nvec3 Shading(vec3 ro, vec3 rd, vec3 p, vec4 rayhit, vec4 bluenoise) {\n    // ambient color\n    vec3 col = SampleSky(p, normalize(rayhit.xyz + vec3(0,0.5,0))) * 0.1;\n\n    // Shadow\n    vec4 r = Raycast(p, normalize(sundir - bluenoise.xyz*0.13));\n    if(r.w > 1e9)\n        col += max(0.0, dot(rayhit.xyz, sundir)) * suncol;\n       \n    return col;\n}\n\nvec3 ApplyFog(vec3 col, float t) {\n    // return col;\n    vec3 ext = exp2(-t*0.01*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58)*1.3; // 0.55\n}\n\n// https://github.com/dmnsgn/glsl-tone-map/blob/master/aces.glsl\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(uv, 0.0);\n    \n    ivec2 bluenoise_dim = ivec2(1024, 1024);\n    vec4 bluenoise = texelFetch(iChannel0, ivec2(fragCoord + vec2(fract(iTime*303.0), fract(-iTime*230.0+102.0))*2000.0) % bluenoise_dim, 0);\n    bluenoise = bluenoise * 2.0 - 1.0;\n    \n    vec2 nuv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    nuv += 0.9*bluenoise.zw / vec2(iResolution.xy); // add a bit of noise to help the aliasing\n    \n    // camera\n#ifdef MOUSE_CAMERA_ENABLED\n\tfloat an = 10.0 * iMouse.x / iResolution.x;\n    float yan = (10.0 * iMouse.y / iResolution.y) - 0.9;\n#else\n    float an = iTime * 0.5;\n    float yan = 1.0 + sin(iTime*0.3)*1.99;\n#endif\n\tvec3 ro = vec3(5.5*sin(an), yan,5.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( nuv.x*uu + nuv.y*vv + 1.0*ww);\n    \n    vec4 r = Raycast(ro, rd);\n    vec3 p = ro + rd*r.w + r.xyz*0.0002;\n\n    if(r.w < 1e9) {\n        vec4 mat = WorldPointMat(p);\n        col = mat.rgb;\n        \n        if(p.y < -0.999) col = vec3(0.1,1,0.5);\n        \n        vec3 irr = vec3(0.0);\n        for(int i = 0; i < NUM_SHADOW_SAMPLES; i++) {\n            irr += Shading(ro, rd, p, r, bluenoise);\n            bluenoise = bluenoise.wxyz;\n        }\n        irr /= float(NUM_SHADOW_SAMPLES);\n        \n        // Reflection\n        #if NUM_REFLECTION_SAMPLES > 0\n        vec3 rirr = vec3(0.0);\n        for(int i = 0; i < NUM_REFLECTION_SAMPLES; i++) {\n            vec3 rrd = reflect(normalize(rd + bluenoise.xyz*mat.w*0.5), r.xyz);\n            vec4 rr = Raycast(p, rrd);\n            vec3 rp = p + rrd*rr.w + rr.xyz*0.0002;\n            vec4 rmat = WorldPointMat(rp);\n            if(rr.w < 1e9) {\n                rirr += rmat.xyz * Shading(p, rrd, rp, r, bluenoise);\n                // fake 2nd bounce samples sky\n                rirr += SampleSky(rp, reflect(normalize(rrd + bluenoise.wyx*rmat.w), rr.xyz)) * 0.15;\n            } else {\n                rirr += SampleSky(p, rrd);\n            }\n            // bluenoise rotation\n            bluenoise = bluenoise.wxyz;\n        }\n        rirr /= float(NUM_REFLECTION_SAMPLES);\n        irr += rirr * 0.7;\n        #endif\n\n\n        // col += rcol*.5;\n        // col *= 0.5;\n        col *= irr * 0.5;\n        \n        col = ApplyFog(col, r.w);\n    } else {\n        col = SampleSky(ro, rd);\n    }\n    \n    col *= 0.8;\n    \n    // sun glare    \n    float sun = clamp( dot(sundir, rd), 0.0, 1.0 );\n    col += vec3(0.8,0.4,0.2)*pow(sun, 1.5 ) * 0.2;\n\n    // tonemapping\n    col = mix(col, aces(col), 0.5);\n\n    // gamma correction\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    // DEBUG\n    // col = r.xyz*.5+.5; // show normal\n    // col = vec3(pow(1.05, -r.w)); // show distance\n    // col = fract(p); // show world-space position\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}