{"ver":"0.1","info":{"id":"4td3Ws","date":"1472538434","viewed":1701,"name":"Terrain erosion","username":"wachel","description":"wait one minitue\n\nchange log\n31/8/6/2016 use time as random seed\n31/8/2016 change view point\n30/8/2016 fix bug:reset when resolution is changed\n","likes":46,"published":1,"flags":32,"usePreview":0,"tags":["fluid","erosion","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel2, uv).rgb;\n    fragColor = vec4(pow(clamp(color, 0., 1.), vec3(1./2.2)), 1.);\n    return;\n    \n    if(fragCoord.x < iMouse.x){\n        vec3 color = texture(iChannel0, uv).rgb * 5.0;\n        fragColor = vec4(pow(clamp(color, 0., 1.), vec3(1./2.2)), 1.);\n    }\n    else{\n        vec3 color = texture(iChannel1, uv).rgb;\n        fragColor = vec4(pow(clamp(color, 0., 1.), vec3(1./2.2)), 1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    //current\n    vec4 outflow = texture(iChannel0, uv);//outflow        \n    vec4 height = texture(iChannel1, uv);//main haight\n    float totalHeight = height.x + height.y;\n    float waterHeight = height.y;\n\n    //neighbour\n    vec4 heightL = texture(iChannel1,uv + vec2(-1.0,0.0) / iResolution.xy);\n    vec4 heightR = texture(iChannel1,uv + vec2( 1.0,0.0) / iResolution.xy);\n    vec4 heightB = texture(iChannel1,uv + vec2(0.0,-1.0) / iResolution.xy);\n    vec4 heightT = texture(iChannel1,uv + vec2(0.0, 1.0) / iResolution.xy);\n    vec4 totalHeightN = vec4(\n        heightL.x + heightL.y, \n        heightR.x + heightR.y, \n        heightB.x + heightB.y, \n        heightT.x + heightT.y\n    );\n\n    //outflowN\n    vec4 outflowL = texture(iChannel0,uv + vec2(-1.0,0.0) / iResolution.xy);\n    vec4 outflowR = texture(iChannel0,uv + vec2( 1.0,0.0) / iResolution.xy);\n    vec4 outflowB = texture(iChannel0,uv + vec2(0.0,-1.0) / iResolution.xy);\n    vec4 outflowT = texture(iChannel0,uv + vec2(0.0, 1.0) / iResolution.xy);\n\n    //\n    vec4 diffHeight = (vec4(totalHeight).xxxx - totalHeightN);\n\n    //damp\n    float flowdamp = 0.95;\n\n    float flowSpeed = 0.2;\n\n    vec4 distance = sqrt(diffHeight * diffHeight * iResolution.x + 1.0 * 1.0);\n\n\n    //\n    outflow *= flowdamp;\n    outflow += diffHeight * flowSpeed / distance;\n    outflow = max(outflow, vec4(0.00000000000001));\n\n    //\n    float outflowScale = waterHeight / (outflow.x + outflow.y + outflow.z + outflow.w);\n    outflowScale = min(1.0, outflowScale);\n    outflow *= outflowScale;\n\n    fragColor = outflow;\n\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define _EvaporateSpeed 0.00002\n#define _RainSpeed 0.000005\n#define _StartWater 0.0000\n\nfloat seed = 1.0;\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*(43758.5453123 * seed));\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvLastInfo0 = vec2(0.5,0.5) / iResolution.xy;\n    vec4 lastResolution = texture(iChannel2, uvLastInfo0);\n    if(iFrame == 0 || lastResolution.z > 0.5){\n        seed = iTime;\n        float h = 0.0;\n        float size = 3.0;\n        float scale = 0.5;\n        for(int i =0; i<9; i++){\n            h += (noise(uv * size) + 0.5) * scale;\n            size *= 2.3;\n            scale *= 0.5;\n        }\n        fragColor = vec4(h,_StartWater,0.0,h);\n        return;\n    }\n    else{\n    \n        //current\n        vec4 outflow = texture(iChannel0, uv);//outflow\n        vec4 height = texture(iChannel1, uv);//main\n        float terrainHeight = height.x;\n        float waterHeight = height.y;\n        float totalHeight = terrainHeight + waterHeight;\n\n        //neighbour\n        vec4 heightL = texture(iChannel1,uv + vec2(-1.0,0.0) / iResolution.xy);\n        vec4 heightR = texture(iChannel1,uv + vec2( 1.0,0.0) / iResolution.xy);\n        vec4 heightB = texture(iChannel1,uv + vec2(0.0,-1.0) / iResolution.xy);\n        vec4 heightT = texture(iChannel1,uv + vec2(0.0, 1.0) / iResolution.xy);\n        vec4 terrainN = vec4(heightL.x, heightR.x, heightB.x, heightT.x);\n        vec4 waterN = vec4(heightL.y, heightR.y, heightB.y, heightT.y);\n        vec4 sedimentN = vec4(heightL.z, heightR.z, heightB.z, heightT.z);\n   \t\tvec4 fluidN = waterN + sedimentN;\n\n        //inflow\n        vec4 outflowL = texture(iChannel0,uv + vec2(-1.0,0.0) / iResolution.xy);\n        vec4 outflowR = texture(iChannel0,uv + vec2( 1.0,0.0) / iResolution.xy);\n        vec4 outflowB = texture(iChannel0,uv + vec2(0.0,-1.0) / iResolution.xy);\n        vec4 outflowT = texture(iChannel0,uv + vec2(0.0, 1.0) / iResolution.xy);\n        vec4 inflow = vec4(outflowL.y, outflowR.x, outflowB.w, outflowT.z);\n\n        ////suspended\n        vec2 fluxOutflow = vec2(outflow.y - outflow.x, outflow.w - outflow.z);\n        vec2 fluxInflow = vec2(inflow.x - inflow.y, inflow.z - inflow.w);\n        vec2 flux = (fluxInflow + fluxOutflow) * 0.5 ;//\n        vec2 velocity = flux / (height.y + 0.000000001);\n\n        float sediment = height.z + dot(inflow * sedimentN / (waterN + vec4(0.000000001)), vec4(1));\n        sediment -= dot(outflow,vec4(1)) * height.z / (height.y + 0.000000001);\n        sediment = max(0.000000001, sediment);\n\n        //float4 srcHeight = tex2D(_MainTex, i.uv - flux * _MainTex_TexelSize.xy * 1000);\n        //float4 srcHeight = tex2D(_MainTex, i.uv - velocity * _MainTex_TexelSize.xy * 1);\n        //float suspendedSolid = height.z;\n\n        vec4 forwardHeight = texture(iChannel1, uv + normalize(flux) * 0.5 / iResolution.xy);\n        float abrupt = (height.x - forwardHeight.x) * (1.0 + height.w * 5.0);\n        float newCapacity = (abrupt + 0.0005) * pow(length(flux),1.0) * 200.0;\n        newCapacity = clamp(newCapacity,0.0,height.y * 0.5);\n\n        //update water\n        vec4 diffFlow = inflow - outflow;\n        waterHeight += dot(diffFlow,vec4(1.0));\n\n        //evaporate and rain\n        float x = 1.0 - (1.0 / (waterHeight * 10.0 + 1.0));//\n        waterHeight -= _EvaporateSpeed * x * 3.0;\t//evaporate\n        waterHeight += _RainSpeed;\t\t\t//rain\n        waterHeight = max(waterHeight, 0.0);\n\n        //update terrain height\n        float newTerrainHeight = height.x + (sediment - newCapacity);\n        //newTerrainHeight = lerp(newTerrainHeight,dot(terrainN,(1).xxxx) * 0.25,0.01);\n        newTerrainHeight = max(0.0, newTerrainHeight);\n        float sedimentChange = height.x - newTerrainHeight;\n        float newSuspendedSolid = sediment + sedimentChange;\n        waterHeight += sedimentChange;\n\n        fragColor = vec4(newTerrainHeight, waterHeight, newSuspendedSolid, mix(height.w,height.x,0.01));\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nfloat terrainH( in vec2 p)\n{\n    //return noise(p);\n    vec2 uv = p * 0.1 + vec2(0.5);;\n    if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\n    \t//uv.x *= iResolution.x/iResolution.y;\n\t\tvec4 height = texture(iChannel1,uv );//main haight\n    \tfloat h = height.x + height.y;\n    \treturn h * 1.8;\n    }\n    else{\n        return -1000.0;\n    }\n}\n\nvec4 terrainColor(in vec2 p)\n{\n    vec4 sandColor = vec4(0.9,0.70,0.4,0.0);//w is glossiness\n    vec4 waterColor = vec4(0.0,0.1,0.5,0.3);\n    //vec3 stoneColor = vec3(0.4,0.4,0.4);\n    vec4 stoneColor = vec4(texture(iChannel3,p).rgb * 0.5,0.0);\n    vec4 grassColor = vec4(0.2,0.4,0.0,0.0);\n    \n    vec2 uv = p * 0.1 + vec2(0.5);\n    \n\n    vec4 height = texture(iChannel1,uv );\n    float erosion = height.w + height.z - height.x;\n    vec4 color = mix(sandColor,grassColor,clamp(pow(-(height.y - 0.001) * 8000.0,3.0),0.0,1.0));\n    color = mix(color,stoneColor,pow(clamp(erosion * 1800.0,0.0,1.0),6.0));\n    color = mix(color,waterColor,pow(clamp(height.y * 400.0,0.0,1.0),3.0)); \n    return color;\n\n}\n\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 getSkyColor(in vec3 lightDir,in vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    vec3 sky0 = vec3(0.8,0.7,0.5) * 0.0;\n    vec3 sky1 = vec3(0.4,0.6,0.8) * 0.0;\n    col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n    col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    return col;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 0.1;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        col = getSkyColor(lightDir,rd);\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        vec3 normal = calcNormal( pos, t );\n        vec3 viewDir = -rd;\n        \n        vec3 refDir = reflect(rd,normal);\n        vec4 refColor = vec4(0);\n        float r = interesct(pos + normal * 0.00001,refDir,0.001,20.0);\n        if(r > tmax){\n            refColor = vec4(getSkyColor(lightDir,refDir),0.0);\n        }\n        else{\n            vec3 refPos = pos + r * refDir;\n            refColor = terrainColor(refPos.xz);\n        }\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec4 color = terrainColor(pos.xz);\n        vec3 diff = color.rgb * lambertian * lightColor;\n        vec3 spec = (specular1 * 0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * color.rgb;\n        col = shadow * (diff + spec) + ambient  + refColor.rgb * color.w * 0.3;\n\n    }\n    \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    vec2 uvLastInfo0 = vec2(0.5,0.5) / iResolution.xy;\n    vec4 lastResolution = texture(iChannel2, uvLastInfo0);\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5){    \n        if(length(lastResolution.xy - iResolution.xy) > 1.0){\n        \tfragColor = vec4(iResolution.xy,1.0,0.0);\n        }\n        else{\n            fragColor = vec4(iResolution.xy,0.0,0.0);\n        }\n        return;\n    }\n    \n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time * 0.1;\n    \tpitch = -0.6;        \n    }\n    else{\n        yaw = iMouse.x * 0.01;\n    \tpitch = clamp(iMouse.y/iResolution.y - 1.1,-PI * 0.5,PI * 0.5);\n    }\n    \n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    vec3 dir = vec3(cos(yaw) * cos(pitch),sin(pitch),sin(yaw) * cos(pitch));\n    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ro = ta - dir * 5.0;\n    mat3 cam = setCamera( ro, ta, 0.0 );\n\tvec3 rd = cam * normalize(vec3(p,2.0));\n\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4(col,1);\n}","name":"Buf C","description":"","type":"buffer"}]}