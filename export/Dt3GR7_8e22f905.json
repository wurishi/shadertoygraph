{"ver":"0.1","info":{"id":"Dt3GR7","date":"1682072679","viewed":125,"name":"Volume Cluster","username":"_pwd_","description":"Escaping the wire is not scheduled","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","3dnoise","aovolumetexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n//\n// Volume Cluster\n//\n// - Escaping the wire is not scheduled -\n//\n//\n// Based on gyabo´s formulas descriped in\n// here -> https://gyabo.sakura.ne.jp/progdx9.html\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT.   \n//\n//\n//\n\n\n//#define lensDistort\n\nvec3 rotate_pos(vec3 d,float rot) {\n  mat3 mtx = mat3(\n     cos(rot), -sin(rot), 0,\n     sin(rot),  cos(rot), 0,\n    0,       0,           1\n  );\n  return d * mtx;\n}\n\nfloat map(vec3 p) {\n  p += cos(iTime) * 0.05;\n  \n  p.x += 2.0;\n  p.y -= 1.5;\n\n//float d = textureLod(iChannel0, p / 800.0, 0.25 ).r;\n  float d = textureLod(iChannel0, p / 1500.0, 0.13 ).r;\n  float h = pow(d + 0.455, 46. + sin(iTime));\n  return abs(h) - dot(p.xy, p.xy);\n}\n\n\nvec4 raycast(int rep, vec3 eye, vec3 dir) {\n\n    vec4 q[5];\n    q[0] = vec4(-0.68570,  0.64828,  0.04532, -0.82974);\n    q[1] = vec4(-0.47256,  0.26486, -0.59222,  0.72482);\n    q[2] = vec4( 0.12552, -0.96567,  0.93915,  0.78464);\n    q[3] = vec4(-0.58102, -0.75943,  0.34094,  0.02020);\n    q[4] = vec4(-0.16101,  0.86682, -0.52985,  0.13193);\n\n    vec3 pao = vec3( 0.0 );\n    float ao = 0.0;\n    \n    dir *= 0.005;\n    vec3 dtdir = dir;\n    \n    for(int i = 0; 0.0 < map(eye) && i < rep; i++) {\n        eye += dir;\n        dir += dtdir;\n        dtdir *= 0.045;\n    }\n  \n    for(int j = 0; j < 64; j++) {\n        eye += (dir /= 1.05 ) * sign(map(eye));\n    }\n  \n    for(int j = 0; j < 5; j++) {\n        pao.x = map( eye + q[j].xyz * 0.01 ) * 10.0; \n        pao.y = map( eye + q[j].xyz * 0.01 ) * 10.0; \n        pao.z = map( eye + q[j].xyz * 0.01 ) * 10.0; \n        ao += vec3( pao /  sqrt(pao * pao + 1.) + 1. ).x;\n    }\n\n    for(int j = 0; j < 5; j++) {\n        pao.x = map( eye + q[j].xyz * 0.01 ) * 7.0; \n        pao.y = map( eye + q[j].xyz * 0.01 ) * 7.0; \n        pao.z = map( eye + q[j].xyz * 0.01 ) * 7.0; \n        ao += vec3( pao /  sqrt(pao * pao + 1.) + 1. ).x;\n    }  \n    \n    return vec4(eye, ao + ao );\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float count = iTime * 0.15;\n\tvec2 uv      = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tuv.y        *= iResolution.y / iResolution.x;\n\n\n    vec3 dir = normalize(vec3(uv * vec2(1.5, -1.5), 0.75));\n    dir = rotate_pos(dir.yzx, count);\n    dir = rotate_pos(dir.zxy, count);\n    dir = rotate_pos(dir.xyz, count);\n    \n    \n    #ifdef lensDistort\n    dir.z -= length(dir) * ( 0.16 * sin(iTime*.5) + 0.8); //lens distort\n    dir = normalize(dir);\n    #endif\n    \n    vec3 eye = vec3( -0.5, 1.5, -4.0*sin(iTime*.3) + 8.0  );    \n    vec3 ro  = eye;\n    ro += (dir * 0.05) *  texture(iChannel0,uv.xyx * 40.0).rrr * 20.0;\n\n  \n    vec4 caster = raycast(2250, ro, dir);\n    float  dist = length(caster.xyz - eye);\n\n    fragColor = vec4( vec3( dist * 0.7 ) * caster.w * 0.0029 * vec3(1.0, 2.0, 1.5 * sin( iTime * 0.5 ) + 3.0  ), dist );\n}","name":"Image","description":"","type":"image"}]}