{"ver":"0.1","info":{"id":"tdlXzr","date":"1557944884","viewed":518,"name":"A somewhat-PBR raymarcher","username":"Shimmen","description":"A basic example/template of 3D raymarching with materials that are somewhat physically based.\n\nFeatures:\n - Multiple bounces and IBL for last bounce\n - Multiple materials\n - Soft shadows","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","materials","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYMARCH_MAX_STEPS (256)\n#define EPSILON (0.0001)\n#define FAR_HIT (99999.0)\n#define NO_HIT  (99999.0)\n\n#define PI     (3.141592)\n#define TWO_PI (2.0 * PI)\n#define ONE_OVER_PI (1.0 / PI)\n\n/////////////////////////////////////////////////////\n\n#define Material vec4\n#define materialBaseColor(m) (m.rgb)\n#define materialMetallic(m) (m.a)\n\nconst Material materials[2] = Material[](\n\tvec4(0.955, 0.637, 0.538, 1.0),\n    vec4(1.000, 0.200, 0.300, 0.0)\n);\n\n// (only one indirect map available, so use some fixed roughness)\n// (the map is slightly blurred/low-res so I use 0.2 here)\nconst float roughness = 0.2;\n\n#define DIELECTRIC_REFLECTANCE (0.04)\n\n/////////////////////////////////////////////////////\n\nconst float environmentMultiplier = 0.35;\n\nconst vec3 lightPosition = vec3(-7.0, 5.0, 7.0);\nconst vec3 lightColor = 300.0 * vec3(1.0, 1.0, 0.87);\n\n/////////////////////////////////////////////////////\n\nfloat sphereSdf(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat boxSdf(vec3 p, vec3 b, float radius)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) - radius + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sceneSdf(vec3 p)\n{\n    return min(\n        sphereSdf(vec3(0.0, -0.5, 0.0) - p, 1.0),\n        boxSdf(vec3(0.0, -2.0, 0.0) - p, vec3(2.8, 0.01, 10.0), 0.2)\n    );\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    const vec2 eps = vec2(EPSILON, 0.0);\n    float dx = sceneSdf(p + eps.xyy) - sceneSdf(p - eps.xyy);\n    float dy = sceneSdf(p + eps.yxy) - sceneSdf(p - eps.yxy);\n    float dz = sceneSdf(p + eps.yyx) - sceneSdf(p - eps.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nMaterial sceneMaterial(vec3 p)\n{\n    float sphere = sphereSdf(p, 1.0);\n    float box = boxSdf(vec3(0.0, -2.0, 0.0) - p, vec3(1.8, 0.01, 10.0), 0.2);\n    int index = (sphere <= box) ? 0 : 1;\n    return materials[index];\n}\n\nfloat raymarch(vec3 origin, vec3 direction, float tMin, float tMax)\n{\n    float depth = tMin;\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; ++i)\n    {\n        float dist = sceneSdf(origin + depth * direction);\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (dist >= tMax)\n        {\n            return NO_HIT;\n        }\n    }\n    \n    return NO_HIT;\n}\n\nfloat hardShadow(vec3 origin, vec3 direction, float tMin, float tMax)\n{\n    float depth = tMin;\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; ++i)\n    {\n        float dist = sceneSdf(origin + depth * direction);\n        if (dist < EPSILON)\n        {\n            return 0.0;\n        }\n        \n        depth += dist;\n        \n        if (dist >= tMax)\n        {\n            return 1.0;\n        }\n    }\n    \n    return 1.0;\n}\n\n\n// From https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 origin, vec3 direction, float tMin, float tMax, float k)\n{\n    float result = 1.0;\n    float prevDist = 1e20;\n    \n    float depth = tMin;\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; ++i)\n    {\n        float dist = sceneSdf(origin + depth * direction);\n        if (dist < EPSILON)\n        {\n            return 0.0;\n        }\n        \n        float y = dist * dist / (2.0 * prevDist);\n        float d = sqrt(dist * dist - y * y);\n        result = min(result, k * d / max(0.0, depth - y));\n        prevDist = dist;\n        \n        depth += dist;\n        \n        if (dist >= tMax)\n        {\n            return result;\n        }\n    }\n    \n    return result;\n}\n\n/////////////////////////////////////////////////////\n\n//\n// The current BRDF model in use is based on the one from Filament,\n// documented here: https://google.github.io/filament/Filament.md#toc4.\n// It's licenced under the Apache License 2.0 which can be found\n// here: https://github.com/google/filament/blob/master/LICENSE.\n//\n\nfloat D_GGX(float NdotH, float a) {\n    float a2 = a * a;\n    float f = (NdotH * a2 - NdotH) * NdotH + 1.0;\n    return a2 / (PI * f * f);\n}\n\nvec3 D_GGX_importanceSample(vec2 xi, vec3 N, float a)\n{\n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    // from tangent-space vector to world-space sample vector\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\n    vec3 sampleVector = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVector);\n}\n\nvec3 F_Schlick(float VdotH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - VdotH, 5.0);\n}\n\nfloat V_SmithGGXCorrelated(float NdotV, float NdotL, float a) {\n    float a2 = a * a;\n    float GGXL = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n    float GGXV = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 specularBRDF(vec3 L, vec3 V, vec3 N, vec3 baseColor, float roughness, float metallic, out vec3 F)\n{\n    vec3 H = normalize(L + V);\n\n    float NdotV = abs(dot(N, V)) + 1e-5;\n    float NdotL = clamp(dot(N, L), 0.0, 1.0);\n    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n    float LdotH = clamp(dot(L, H), 0.0, 1.0);\n\n    // Use a which is perceptually linear for roughness\n    float a = roughness * roughness;\n\n    vec3 f0 = mix(vec3(DIELECTRIC_REFLECTANCE), baseColor, metallic);\n\n    F = F_Schlick(LdotH, f0);\n    float D = D_GGX(NdotH, a);\n    float V_part = V_SmithGGXCorrelated(NdotV, NdotL, a);\n\n    return F * vec3(D * V_part);\n}\n\nvec3 diffuseBRDF()\n{\n    return vec3(1.0) / vec3(PI);\n}\n\nvec3 ggxBrdfApproximation(vec3 specularColor, float roughness, float NdotV)\n{\n    // From https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;\n}\n\nvec3 noHitShade(vec3 direction)\n{\n    // Sample environment\n    return environmentMultiplier * texture(iChannel0, direction).rgb;\n}\n\nvec3 shadeDirect(vec3 position, vec3 N, vec3 V, Material m, bool iblIndirect)\n{\n    vec3 baseColor = materialBaseColor(m);\n    float metallic = materialMetallic(m);\n    \n    vec3 f0 = mix(vec3(DIELECTRIC_REFLECTANCE), baseColor, metallic);\n    float VdotN = max(0.0, dot(V, N));\n    \n    vec3 color = vec3(0.0);\n    \n    vec3 direct = vec3(0.0);\n    {\n    \tvec3 toLight = lightPosition - position;\n    \tfloat d = length(toLight);\n    \tvec3 L = normalize(toLight);\n\n    \tvec3 pos = position + EPSILON * N;\n    \tconst float hardness = 1.0;\n    \tfloat shadowFactor = softShadow(pos, L, EPSILON, d, hardness);\n\n    \tfloat atten = 1.0 / (d * d);\n    \tfloat NdotL = max(0.0, dot(N, L));\n\n    \t// Glossy direct light\n    \tvec3 F;\n    \tdirect += specularBRDF(L, V, N, baseColor, roughness, metallic, F);\n\n    \t// Diffuse direct light\n    \tdirect += (1.0 - F) * (1.0 - metallic) * diffuseBRDF() * baseColor;\n\n        color += direct * lightColor * shadowFactor * NdotL * atten;\n    }\n    \n\tvec3 indirect = vec3(0.0);\n    if (iblIndirect)\n    {\n        // (indirect so no L, use H == N)\n        float VdotH = VdotN;\n        vec3 F = F_Schlick(VdotH, f0);\n\n        // Diffuse indirect\n        {\n            // (sure, this isn't a real irradiance map, but it almost works..)\n            vec3 irradiance = environmentMultiplier * vec3(1.0 / PI) * texture(iChannel1, N).rgb;\n            indirect += baseColor * (vec3(1.0) - F) * irradiance;\n        }\n\n        // Glossy indirect\n        {\n            vec3 BRDF = ggxBrdfApproximation(F, roughness, VdotN);\n\n            vec3 L = reflect(-V, N);\n            indirect += environmentMultiplier * texture(iChannel0, L).rgb * BRDF;\n        }\n    }\n    color += indirect;\n    \n    return color;\n}\n\nvec3 shadeWithOneBounce(vec3 position, vec3 N, vec3 V, Material m)\n{   \n    vec3 baseColor = materialBaseColor(m);\n    float metallic = materialMetallic(m);\n    vec3 f0 = mix(vec3(DIELECTRIC_REFLECTANCE), baseColor, metallic);\n    \n    vec3 color = vec3(0.0);\n    color += shadeDirect(position, N, V, m, false);\n    \n    vec3 indirect = vec3(0.0);\n    {\n        // (perfect mirror reflections)\n        vec3 L = reflect(-V, N);\n        float NdotL = max(0.0, dot(N, L));\n\n        vec3 pos = position + EPSILON * N;\n        float dist = raymarch(pos, L, EPSILON, FAR_HIT);\n        \n        vec3 indirectLight = vec3(0.0);\n        if (dist == NO_HIT)\n        {\n            indirectLight += noHitShade(L);\n        }\n        else\n        {\n            \n            vec3 hitPos = pos + dist * L;\n        \tvec3 hitN = sceneNormal(hitPos);\n            vec3 hitV = normalize(-L);\n            Material hitMaterial = sceneMaterial(hitPos);\n            \n            indirectLight += NdotL * shadeDirect(hitPos, hitN, hitV, hitMaterial, true);\n        \t\n\t\t}\n        \n        // Glossy indirect light (quite hacky, but it looks good)\n    \tvec3 F = F_Schlick(NdotL, f0);\n    \tindirect += indirectLight;\n\n    \t// Diffuse indirect light\n    \tindirect += (1.0 - F) * (1.0 - metallic) * diffuseBRDF() * indirectLight;\n\n    }\n    color += indirect;\n\n    return color;\n}\n\n/////////////////////////////////////////////////////\n\nconst float GAMMA = 2.2;\nconst float EXPOSURE = 1.5;\n\nvec3 lookAt(vec3 eye, vec3 target, vec2 uv)\n{\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 forward = normalize(target - eye);\n    vec3 right = cross(forward, up);\n    up = cross(right, forward);\n \n    vec2 st = 2.0 * uv - 1.0;\n    st.x *= iResolution.x / iResolution.y;\n    \n    return normalize(2.0 * forward + st.x * right + st.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = 8.0 * vec3(cos(iTime / 3.0), 0.0, sin(iTime / 3.0));\n    vec3 target = 0.3 * vec3(0.0, 1.7 * cos(iTime / 1.4)*sin(iTime / 3.0), 0.0);\n    \n    // 4x SSAA\n    const int SPP = 4;\n    vec2 aaOffsets[SPP] = vec2[](vec2(-0.25, -0.25), vec2(-0.25, +0.25),\n                                 vec2(+0.25, +0.25), vec2(+0.25, -0.25));\n\n    vec3 color = vec3(0.0);\n    for (int s = 0; s < SPP; ++s)\n    {\n        vec2 uv = (fragCoord + aaOffsets[s]) / iResolution.xy;\n        vec3 rayDir = lookAt(eye, target, uv);\n\n        float dist = raymarch(eye, rayDir, EPSILON, FAR_HIT);\n        if (dist == NO_HIT)\n        {\n            color += noHitShade(rayDir);\n        }\n        else\n        {\n            vec3 hitPos = eye + dist * rayDir;\n        \tvec3 N = sceneNormal(hitPos);\n            vec3 V = normalize(-rayDir);\n            \n            Material material = sceneMaterial(hitPos);\n            color += shadeWithOneBounce(hitPos, N, V, material);\n        }\n    }\n    color /= float(SPP);\n    \n    // Apply basic exposure & tonemapping & gamma correction\n    color *= EXPOSURE;\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / GAMMA));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}