{"ver":"0.1","info":{"id":"4ffyDS","date":"1721557603","viewed":53,"name":"simple toy truck","username":"Hzzzch","description":"shape from:https://www.shadertoy.com/view/Xds3zN, light:https://www.shadertoy.com/view/lclcW8, scene:https://www.shadertoy.com/view/fdlGWX","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["toytruck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// scene copied from Nathan https://www.shadertoy.com/view/fdlGWX\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b , float r)\n{\n    vec3 d = abs(p) - b + r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial sphere1() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial sphere2() {\n  vec3 aCol = 0.4 * vec3(0, 0.5, 0.7);\n  vec3 dCol = 0.5 * vec3(0, 0.7, 0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial lightbottomfront() {\n  vec3 aCol = 0.4 *vec3(1., 1., 1.);\n  vec3 dCol = 0.5 *vec3(1., 1., 1.);\n  vec3 sCol = 0.6 *vec3(1., 1., 1.);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial lightbottomback() {\n  vec3 aCol = 0.4 *vec3(0., 0., 0.);\n  vec3 dCol = 0.5 *vec3(0., 0., 0.);\n  vec3 sCol = 0.6 *vec3(0., 0., 0.);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial lightfront() {\n  vec3 aCol = vec3(0.961,0.970,0.314);\n  vec3 dCol = vec3(0.961,0.970,0.314);\n  vec3 sCol = vec3(0.961,0.970,0.314);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial lightback() {\n  vec3 aCol = vec3(0.845,0.141,0.109);\n  vec3 dCol = vec3(0.845,0.141,0.109);\n  vec3 sCol = vec3(0.845,0.141,0.109);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial car() {\n  vec3 aCol = 0.4 * vec3(0.495,0.282,0.074);\n  vec3 dCol = 0.5 * vec3(0.615,0.550,0.092);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial wheel() {\n  vec3 aCol = 0.1 * vec3(0.485,0.278,0.140);\n  vec3 dCol = 0.5 * vec3(0.485,0.478,0.140);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial frame() {\n  vec3 aCol = 0.4 * vec3(0.295,0.168,0.044);\n  vec3 dCol = 0.5 * vec3(0.295,0.268,0.044);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial glass() {\n  vec3 aCol = 0.4 * vec3(0.645,0.824,0.945);\n  vec3 dCol = 0.5 * vec3(0.645,1.,0.945);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = 0.5 + 0.5 * vec3(-1. + mod(floor(p.x) + floor(p.z), 2.0));\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  //Surface sSphere1 = Surface(2, sdSphere(p - vec3(-2, 0, 0), 1.), sphere1());\n  //Surface sSphere2 = Surface(3, sdSphere(p - vec3(2, 0, 0), 1.), sphere2());\n  Surface sBody1 = Surface(4,sdRoundBox(p-vec3( 0.0, -0.2, 4.0), vec3(0.8,0.5,1.2),0.1),car());\n  Surface sFrame1 = Surface(5, sdBoxFrame(p-vec3( 0.0,0.7, 3.5), vec3(0.7,0.4,0.6), 0.015 ), frame());\n  Surface sGlassFront = Surface(6, sdBox(p-vec3( 0.0,0.7, 2.91), vec3(0.68,0.38,0.01)), glass());\n  Surface sGlassLeft = Surface(7, sdBox(p-vec3( -0.69,0.7, 3.5), vec3(0.01,0.38,0.58)), glass());\n  Surface sGlassRight = Surface(8, sdBox(p-vec3( 0.69,0.7, 3.5), vec3(0.01,0.38,0.58)), glass());\n  Surface sGlassBack = Surface(9, sdBox(p-vec3( 0.0,0.7, 4.09), vec3(0.68,0.38,0.01)), glass());\n  Surface sGlassAbove = Surface(10, sdBox(p-vec3( 0.0,1.08, 3.5), vec3(0.68,0.01,0.58)), glass());\n  Surface sWheel1 = Surface(11, sdCylinder(p-vec3( 0.8 , -0.6, 3.3), vec2(0.3,0.2)), wheel());\n  Surface sWheel2 = Surface(12, sdCylinder(p-vec3( -0.8 , -0.6, 3.3), vec2(0.3,0.2)), wheel());\n  Surface sWheel3 = Surface(13, sdCylinder(p-vec3( 0.8 , -0.6, 4.7), vec2(0.3,0.2)), wheel());\n  Surface sWheel4 = Surface(14, sdCylinder(p-vec3( -0.8 , -0.6, 4.7), vec2(0.3,0.2)), wheel());\n  Surface sFrontlightLeft1 = Surface(15,sdBox(p-vec3( 0.55, -0.2, 2.8), vec3(0.2, 0.1, 0.02)), lightbottomfront());\n  Surface sFrontlightLeft2 = Surface(16,sdBox(p-vec3( 0.55, -0.2, 2.78), vec3(0.1, 0.08, 0.02)), lightfront());\n  Surface sFrontlightRight1 = Surface(17,sdBox(p-vec3( -0.55, -0.2, 2.8), vec3(0.2, 0.1, 0.02)), lightbottomfront());\n  Surface sFrontlightRight2 = Surface(18,sdBox(p-vec3( -0.55, -0.2, 2.78), vec3(0.1, 0.08, 0.02)), lightfront());\n  Surface sBacklightLeft1 = Surface(15,sdBox(p-vec3( 0.55, 0., 5.2), vec3(0.2, 0.1, 0.02)), lightbottomback());\n  Surface sBacklightLeft2 = Surface(16,sdBox(p-vec3( 0.68, 0., 5.22), vec3(0.05, 0.08, 0.02)), lightback());\n  Surface sBacklightRight1 = Surface(17,sdBox(p-vec3( -0.55, 0., 5.2), vec3(0.2, 0.1, 0.02)), lightbottomback());\n  Surface sBacklightRight2 = Surface(18,sdBox(p-vec3( -0.68, 0., 5.22), vec3(0.05, 0.08, 0.02)), lightback());\n  Surface co = opUnion(sFloor, sBody1); // closest object\n  //co = opUnion(co, sSphere2);\n  //co = opUnion(co, sBody1);\n  co = opUnion(co, sFrame1);\n  co = opUnion(co,sGlassFront);\n  co = opUnion(co,sGlassBack);\n  co = opUnion(co,sGlassLeft);\n  co = opUnion(co,sGlassRight);\n  co = opUnion(co,sGlassAbove);\n  co = opUnion(co,sWheel1);\n  co = opUnion(co,sWheel2);\n  co = opUnion(co,sWheel3);\n  co = opUnion(co,sWheel4);\n  co = opUnion(co, sFrontlightLeft1);\n  co = opUnion(co, sFrontlightLeft2);\n  co = opUnion(co, sFrontlightRight1);\n  co = opUnion(co, sFrontlightRight2);\n  co = opUnion(co, sBacklightLeft1);\n  co = opUnion(co, sBacklightLeft2);\n  co = opUnion(co, sBacklightRight1);\n  co = opUnion(co, sBacklightRight2);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += abs(co.sd);\n    if ((abs(co.sd) < PRECISION && co.id != 6) || depth > MAX_DIST) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n  // background\n  vec3 bgColor = vec3(0.835, 1.0, 1.0);\n  //bgColor = vec3(0.5);\n  if (co.sd > MAX_DIST) return bgColor;\n  \n  // ambient\n  vec3 ambient = co.mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n  vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n  vec3 col = lightIntensity * (ambient + diffuse + specular);\n  \n  // fog\n  col = mix(col, bgColor, 1.0 - exp(-0.00002 * co.sd * co.sd * co.sd));\n  return col;\n\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < MAX_SHADOW_STEPS; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 ); // soft shadow\n  //return step(tmax - 0., t); //hard shadow\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(8. * cos(-iTime), 1.2, 8. * sin(-iTime));\n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n  vec3 normal = calcNormal(p); // surface normal\n\n  // light\n  vec3 lightPosition = 8. * vec3(cos(iTime), 1., sin(iTime));\n  vec3 lightDirection = normalize(p - lightPosition);\n  float lightIntensity = 0.9;\n      \n  // phone light model\n  col = phong(lightDirection, lightIntensity, normal, rd, co); \n      \n//*  // soft shaddow from iq\n  if (co.id == 1 && co.sd < 0.2 * MAX_DIST) {\n    float softShadow = clamp(softShadow(p, -lightDirection, 100.*PRECISION, length(p-lightPosition)), 0.2, 1.0);\n    col *= softShadow;\n  }\n/*/\n\n/*  // reflection;\n  if (co.id == 2 && scene(p).sd < 10. * PRECISION) {\n    vec3 reflRD = reflect(rd, normal);\n    vec3 reflRO = p + 1.1 * PRECISION * normal; // move origin a little bit away\n    // reflRO = p + 1.5 * PRECISION * reflRD; // not working\n    Surface reflCO = rayMarch(reflRO, reflRD);\n    vec3 reflP = reflRO + reflRD * reflCO.sd;\n    vec3 reflNormal = calcNormal(reflP);\n    reflCO.sd += co.sd;\n    vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n    col = mix(col, reflCol, 0.2);\n  }\n/*/\n\n//*  // refraction\n  if ((co.id  == 6 || co.id  == 7 ||co.id  == 8 ||co.id  == 9 ||co.id  == 10) && scene(p).sd < 10. * PRECISION) {\n    const float ETA = 1.; // glass 1.69, water 1.33，1.0 air\n    vec3 refrRD1 = refract(rd, normal, 1./ETA);\n    vec3 refrRO1 = p - 2.1 * PRECISION * normal; // move origin into the sphere\n    //refrRO1 = p + 5. * PRECISION * refrRD1; // not working\n    Surface refrCO1 = rayMarch(refrRO1, refrRD1);\n    vec3 refrP1 = refrRO1 + refrRD1 * refrCO1.sd;\n    vec3 refrN1 = calcNormal(refrP1);\n    \n    vec3 refrRD2 = refract(refrRD1, -refrN1, ETA);\n    vec3 refrRO2 = refrP1 + 4. * PRECISION * refrN1; // move origin outside the sphere\n    //refrRO2 = refrP1 + 5. * PRECISION * refrRD2; // not working\n    Surface refrCO2 = rayMarch(refrRO2, refrRD2);\n    vec3 refrP2 = refrRO2 + refrRD2 * refrCO2.sd;\n    vec3 refrN2 = calcNormal(refrP2);\n    refrCO2.sd += refrCO1.sd + co.sd;\n    \n    if ((refrCO2.id ==6 || refrCO2.id == 7 ||refrCO2.id == 8 ||refrCO2.id == 9 ||refrCO2.id == 10)  && scene(refrP2).sd < 10. * PRECISION) {\n        const float ETA = 1.; // glass 1.69, water 1.33，1.0 air\n        vec3 refrRD3 = refract(refrRD2, -refrN2, 1./ETA);\n        vec3 refrRO3 = p - 4. * PRECISION * (refrN2); // move origin into the sphere\n        //refrRO1 = p + 5. * PRECISION * refrRD1; // not working\n        Surface refrCO3 = rayMarch(refrRO3, refrRD3);\n        vec3 refrP3 = refrRO3 + refrRD3 * refrCO3.sd;\n        vec3 refrN3 = calcNormal(refrP3);\n    \n        vec3 refrRD4 = refract(refrRD3, -refrN3, ETA);\n        vec3 refrRO4 = refrP3 + 1.5 * PRECISION * refrN3; // move origin outside the sphere\n        //refrRO2 = refrP1 + 5. * PRECISION * refrRD2; // not working\n        Surface refrCO4 = rayMarch(refrRO4, refrRD4);\n        vec3 refrP4 = refrRO4 + refrRD4 * refrCO4.sd;\n        vec3 refrN4 = calcNormal(refrP4);\n        refrCO4.sd += refrCO3.sd + refrCO2.sd;\n        vec3 refrCol = phong(lightDirection, lightIntensity, refrN4, refrRD4, refrCO4);\n        col = mix(col, refrCol, 0.2);\n    }\n    else{\n        vec3 refrCol = phong(lightDirection, lightIntensity, refrN2, refrRD2, refrCO2);\n        col = mix(col, refrCol, 0.2);\n    }\n  }\n//*/\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}