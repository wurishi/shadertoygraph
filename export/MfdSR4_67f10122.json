{"ver":"0.1","info":{"id":"MfdSR4","date":"1713768979","viewed":170,"name":"interstellar poster","username":"loki123123","description":"A rough mimic","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"WlKXzm","parentname":"Orbital Megastructure"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define C(c) U.x-=.75; fragColor+= vec4(5.)*char(U,c)\n#define CR(c) U.x-=.75; fragColor-= vec4(5.)*char(U,c)\n#define UC(i) U+gridOffset(1.3800*i+4.2,2.0)\n\nfloat aastep(float threshold, float value) {\n  float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n  return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nvoid pR(inout vec2 p, float a) {\n  p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nvoid pR45(inout vec2 p) {\n  p = (p + vec2(p.y, -p.x)) * sqrt(0.5);\n}\n\n\nfloat sdBox(vec2 position, vec2 dimensions) {\n  vec2 d = abs(position) - dimensions;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRing(vec2 p, float r1, float r2) {\n  float lp = length(p);\n  return max(r1 - lp, lp - r2);\n}\n\nvoid pElongate(inout float p, float h) {\n  p -= clamp(p, -h, h);\n}\n\nfloat letterV(vec2 p);\n\nfloat letterA(vec2 p) {\n  p.x = abs(p.x);\n  float d = sdBox(p + vec2(0.0, 0.15), vec2(0.45, 0.048125));\n  p.y = -p.y;\n  return min(d, letterV(p));\n}\n\nfloat letterP(vec2 p);\n\nfloat letterB(vec2 p) {\n  p.y = abs(p.y);\n  return letterP(p);\n}\n\nfloat letterC(vec2 p) {\n  p.x -= 0.08;\n  p.y = abs(p.y);\n  vec2 q = p;\n  p.x = abs(p.x);\n  float d = sdRing(p, 0.9 - 0.08125 * 2.0, 0.9);\n  q.x -= 0.7;\n  pR45(q);\n  d = max(d, -q.y + 0.5);\n  return d;\n}\n\nfloat letterD(vec2 p) {\n  p.x += 0.165;\n  vec2 q = p;\n  p.x += 0.45;\n  float dEdge = sdBox(q + vec2(0.45, 0.0), vec2(0.08125, 0.8));\n  pElongate(p.x, 0.45);\n  float dBump = sdRing(p, 0.9 - 0.08125 * 2.0, 0.9);\n  float d = min(dBump, dEdge);\n  d = max(d, -q.x - 0.53);\n  return d;\n}\n\nfloat letterF(vec2 p);\n\nfloat letterE(vec2 p) {\n  p.y = abs(p.y);\n  return letterF(p);\n}\n\nfloat letterF(vec2 p) {\n  p.x -= 0.25;\n  float dTop = sdBox(p + vec2(0.325, -0.95 + 0.08125), vec2(0.565, 0.038125));\n  float dMid = sdBox(p + vec2(0.4, 0.0), vec2(0.45, 0.028125));\n  p.x += 0.9 - 0.08125;\n  float dSide = sdBox(p, vec2(0.08125, 0.9));\n  return min(dTop, min(dMid, dSide));\n}\n\nfloat letterG(vec2 p) {\n  float d = letterC(p);\n  d = min(d, sdBox(p + vec2(0.08125 - 0.75, 0.5), vec2(0.08125, 0.4)));\n  d = min(d, sdBox(p + vec2(-0.5, 0.1 + 0.08125), vec2(0.2, 0.08125)));\n  return d;\n}\n\nfloat letterH(vec2 p) {\n  p.x = abs(p.x);\n  float d = sdBox(p, vec2(0.6, 0.08125));\n  p.x -= 0.6 - 0.08125;\n  d = min(d, sdBox(p, vec2(0.08125, 0.9)));\n  return d;\n}\n\nfloat letterI(vec2 p) {\n  p.y = abs(p.y);\n  float d = sdBox(p, vec2(0.08125, 0.9));\n  p.y -= 0.9 - 0.008125;\n  d = min(d, sdBox(p, vec2(0.3, 0.008125)));\n  return d;\n}\n\nfloat letterJ(vec2 p) {\n  p.x -= 0.35;\n  float d = sdBox(p + vec2(0.0, -0.225), vec2(0.08125, 0.65));\n  p.x += 0.3 + 0.08125;\n  p.y += 0.5 - 0.08125;\n  float dRing = sdRing(p, 0.3, 0.3 + 0.08125 * 2.0);\n  dRing = max(dRing, p.y);\n  d = min(d, dRing);\n  return d;\n}\n\nfloat letterK(vec2 p) {\n  p.x -= 0.1;\n  vec2 q = p;\n  float d = sdBox(p + vec2(0.6, 0.0), vec2(0.08125, 0.9));\n  p.x += 0.5;\n  p.y = abs(p.y);\n  pR(p, 0.82);\n  d = min(d, sdBox(p, vec2(1.5, 0.08125)));\n  d = max(d, -0.9 + abs(q.y));\n  return d;\n}\n\nfloat letterL(vec2 p) {\n  p.x -= 0.25;\n  float dTop = sdBox(p + vec2(0.35, 0.9 - 0.038125), vec2(0.565, 0.038125));\n  p.x += 0.9 - 0.048125;\n  float dSide = sdBox(p, vec2(0.068125, 0.9));\n  return min(dTop, dSide);\n}\n\nfloat letterM(vec2 p) {\n  vec2 q = p;\n  p.x = abs(p.x);\n  float d = sdBox(p - vec2(0.7, 0.0), vec2(0.08125, 0.9));\n  pR(p, 1.1);\n  p.y += 0.18;\n  d = min(d, sdBox(p, vec2(1.3, 0.08125)));\n  d = max(d, q.y - 0.9);\n  return d;\n}\n\nfloat letterN(vec2 p) {\n  vec2 q = p;\n  vec2 m = p;\n  p.x = abs(p.x);\n  float d = sdBox(p - vec2(0.62, 0.0), vec2(0.018125, 0.9));\n  pR(q, -.9907);\n  p.y += 0.18;\n  d = min(d, sdBox(q, vec2(1.3, 0.078125)));\n  d = max(d, abs(m.y) - 0.9);\n  return d;\n}\n\nfloat letterO(vec2 p) {\n  pElongate(p.y, 0.25);\n  float d = sdRing(p, 0.65 - 0.08125 * 2.0, 0.65);\n  return d;\n}\n\nfloat letterP(vec2 p) {\n  p.x -= 0.05;\n  vec2 q = p;\n  p.x += 0.345;\n  float dEdge = sdBox(q + vec2(0.45, .0), vec2(0.048125, 0.9));\n  pElongate(p.x, 0.45);\n  float dBumps = sdRing(p - vec2(0.0, 0.5 - 0.048125), 0.45 - 0.048125 * 2.0, 0.48);\n  float d = min(dBumps, dEdge);\n  d = max(d, -q.x - 0.5053);\n  return d;\n}\n\nfloat letterQ(vec2 p) {\n  float d = letterO(p);\n  p += vec2(-0.6, 0.85);\n  pR45(p.yx);\n  d = min(d, sdBox(p, vec2(0.225, 0.08125)));\n  return d;\n}\n\nfloat letterR(vec2 p) {\n  p.x += 0.05;\n  vec2 q = p;\n  float d = letterP(p);\n  p.y += 0.5;\n  p.x -= 0.25;\n  pR(p, -0.9);\n  d = min(d, sdBox(p, vec2(0.7, 0.038125)));\n  d = max(d, -0.9 - q.y);\n  return d;\n}\n\nfloat letterSPortion(vec2 p) {\n  p.y -= 0.5 - 0.048125;\n  float d0 = sdRing(p, 0.5 - 0.048125 * 2.0, 0.5);\n  pR45(p);\n  return max(d0, -p.y - 0.2);\n}\n\nfloat letterS(vec2 p) {\n  pElongate(p.x, 0.1025);\n  float d = min(letterSPortion(p), letterSPortion(-p));\n  pR(p, -0.19);\n  d = min(d, sdBox(p, vec2(0.18, 0.048125)));\n  return d;\n}\n\nfloat letterT(vec2 p) {\n  float d = sdBox(p, vec2(0.08125, 0.9));\n  p.y -= 0.9 - 0.038125;\n  d = min(d, sdBox(p, vec2(0.65, 0.038125)));\n  return d;\n}\n\nfloat letterU(vec2 p) {\n  vec2 q = p;\n  p.y -= 0.5;\n  pElongate(p.y, 0.5);\n  float d = letterO(p);\n  return max(d, q.y - 0.9);\n}\n\nfloat letterV(vec2 p) {\n  p.x = abs(p.x);\n  p.x -= 0.35;\n  float d = sdBox(rotate2D(p, -1.171), vec2(1.5, 0.048125));\n  d = max(d, p.y - 0.9);\n  return d;\n}\n\nfloat letterW(vec2 p) {\n  p.y = -p.y;\n  return letterM(p);\n}\n\nfloat letterX(vec2 p) {\n  p = abs(p);\n  vec2 q = p;\n  pR(p, 0.9);\n  float d = sdBox(p, vec2(1.5, 0.08125));\n  d = max(d, q.y - 0.9);\n  return d;\n}\n\nfloat letterY(vec2 p) {\n  p.x = abs(p.x);\n  vec2 q = p;\n  pR(p, 0.9);\n  float d = sdBox(p, vec2(1.5, 0.08125));\n  d = min(d, sdBox(q + vec2(0.0, 0.5 - 0.08125), vec2(0.08125, 0.5)));\n  d = max(d, abs(q.y) - 0.9);\n  return d;\n}\n\nfloat letterZ(vec2 p) {\n  p.x -= 0.04;\n  vec2 q = p;\n  vec2 m = p;\n  p.y = abs(p.y);\n  float d = sdBox(p - vec2(0.0, 0.9 - 0.08125), vec2(0.62, 0.08125));\n  pR(q, 0.95);\n  p.y += 0.18;\n  d = min(d, sdBox(q, vec2(1.3, 0.08125)));\n  d = max(d, abs(m.y) - 0.9);\n  return d;\n}\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n} \nvec2 Hash22(vec2 p)\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,1311.7)),\n             dot(p,vec2(2169.5,183.3)));\n    return fract(sin(p)*11118.5453);\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0.,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\nvec2 gridOffset(float x, float y) {\n  vec2 uv = vec2(float(x) / 5.0, float(y) / 4.0);\n  uv = uv * 2.0 - 1.0;\n  uv *= 5.0;\n  uv.x = -uv.x;\n  return uv;\n}\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,1311.7)),\n             dot(p,vec2(2169.5,183.3)));\n    return fract(sin(p)*11118.5453);\n}\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (.5+.5*sin(0.+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nfloat noiseLayers(in vec2 p) {\n\n    // Normally, you'd just add a time vector to \"p,\" and be done with \n    // it. However, in this instance, time is added seperately so that \n    // its frequency can be changed at a different rate. \"p.z\" is thrown \n    // in there just to distort things a little more.\n    vec2 t = vec2(0., p.y +0.*.15);\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t).x * amp; // Add the layer to the total.\n        p *= 2.; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= .5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\tvec2 R = iResolution.xy;\n    vec2 uv = (fragCoord)/iResolution.xy;\n    uv-=vec2(0., .5);\n     uv.y/=iResolution.x/iResolution.y;\n     uv.y*=4.;\n     \n\n    float rd = noiseLayers(uv*vec2(4.,1.));\n     \n\trd = max(rd + dot(Hash22(uv)*2. - 1., vec2(.15)), 0.);\n    \n    float cy= abs(uv.y);\n    vec2 val = uv.x*3.1*(.1+pow(cos(cy),26.1)/2.+(vec2(1.)*sin(0.9*rd)-.5)*0.35);\n\n    fragColor =vec4(dot(val,val)) ;\n    fragColor*=abs(uv.y+.7)*abs(-.7+uv.y);\n    fragColor*=step(uv.y,.7)*step(-.7,uv.y);\n    float rad=9.01;\n    fragColor*=smoothstep(0.2,.25,uv.y*uv.y+pow((uv.x-rad),2.)-(rad*2.+46.354));\n    //fragColor *= step(1.+uv.y*uv.y-uv.x*uv.x,0.);        \n    uv.xy*=vec2(4.,1.)*8.3;\n    vec2 U = uv.xy;\n    float d = 999999.0;\n    d = min(d, letterI(UC(-1.)));\n    d = min(d, letterN(UC(0.)));\n    d = min(d, letterT(UC(1.)));\n    d = min(d, letterE(UC(2.)));\n    d = min(d, letterR(UC(3.)));\n\n    \n    fragColor.rgb+=vec3(1.0 - aastep(0.0, d) + 0.);\n    \n    d=99999.0;\n    d = min(d, letterS(UC(4.)));\n    d = min(d, letterT(UC(5.)));\n    d = min(d, letterE(UC(6.)));\n    d = min(d, letterL(UC(7.)));\n    d = min(d, letterL(UC(8.)));\n    d = min(d, letterA(UC(9.)));\n    d = min(d, letterR(UC(10.)));\n    \n    float c= 1.-vec3( aastep(0.0, d)-1. + 0.).x;\n   \n    fragColor.rgb*=(1.85-c)+step(c,0.3);\n    \n    fragColor*=pow(length((fragCoord)/iResolution.xy)+1.,1.130);\n    \n}\n\n\n","name":"Image","description":"","type":"image"}]}