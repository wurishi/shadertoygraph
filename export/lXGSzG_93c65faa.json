{"ver":"0.1","info":{"id":"lXGSzG","date":"1720092972","viewed":50,"name":"FractalFolding","username":"ozazl","description":"Fractal test, code was generated using claude sonette-3.5","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define PI 3.14159265359\n\n// Base shape: a sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// 4D rotation matrices\nmat4 rotationMatrix4D(int axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    if (axis == 0) return mat4(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1);\n    if (axis == 1) return mat4(c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1);\n    if (axis == 2) return mat4(c,0,0,-s, 0,1,0,0, 0,0,1,0, s,0,0,c);\n    if (axis == 3) return mat4(1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1);\n    if (axis == 4) return mat4(1,0,0,0, 0,c,0,-s, 0,0,1,0, 0,s,0,c);\n    return mat4(1,0,0,0, 0,1,0,0, 0,0,c,-s, 0,0,s,c);\n}\n\n// 4D folding function\nvec4 fold(vec4 p, float time) {\n    for (int i = 0; i < 6; i++) {\n        float angle = time * (float(i) * 0.1 + 0.2);\n        p = rotationMatrix4D(i, angle) * p;\n        p = abs(p) - 0.5;\n        if (p.w > p.z) p.zw = p.wz;\n        if (p.z > p.y) p.yz = p.zy;\n        if (p.y > p.x) p.xy = p.yx;\n    }\n    return p;\n}\n\n// Signed distance function for our fractal shape\nfloat getDistance(vec3 p) {\n    float scale = 2.0;\n    p /= scale;\n    \n    float base = sdSphere(p, 0.5);\n    vec4 p4 = vec4(p, 0.0);\n    \n    for (int i = 0; i < 5; i++) {\n        p4 = fold(p4, iTime * 0.1);\n        float d = sdSphere(p4.xyz, 0.4);\n        base = max(base, -d);\n    }\n    \n    return base * scale;\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDistance(p);\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// Calculate normal\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        getDistance(p - e.xyy),\n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx));\n    return normalize(n);\n}\n\n// Color palette function\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    // Improved camera setup\n    float time = iTime * 0.2;\n    float camDist = 5.0 + sin(time) * 2.0;\n    vec3 ro = vec3(camDist * sin(time), 3.0 + sin(time * 0.5), camDist * cos(time));\n    vec3 lookAt = vec3(0, 0, 0);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i - ro);\n    \n    float d = rayMarch(ro, rd);\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        // Enhanced lighting\n        vec3 lightPos = vec3(2.0 * sin(iTime), 5.0, 2.0 * cos(iTime));\n        vec3 l = normalize(lightPos - p);\n        float dif = clamp(dot(n, l), 0.1, 1.0);\n        float spec = pow(max(dot(r, l), 0.0), 32.0);\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n        \n        // Enhanced coloring\n        vec3 objColor = palette(length(p) * 0.1 - iTime * 0.1);\n        col = objColor * dif + vec3(0.8) * spec + vec3(0.1, 0.3, 0.5) * fresnel;\n        \n        // Ambient occlusion approximation\n        float ao = clamp(getDistance(p + n * 0.5) * 2.0, 0.0, 1.0);\n        col *= ao;\n    }\n    \n    // Improved background\n    vec3 bg = mix(vec3(0.0, 0.05, 0.1), vec3(0.1, 0.2, 0.3), smoothstep(-1.0, 1.0, uv.y));\n    col = mix(bg, col, smoothstep(0.0, 0.95, 1.0 - d / MAX_DIST));\n    \n    // Tone mapping and gamma correction\n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.4545));\n    \n    // Vignette effect\n    col *= 1.0 - smoothstep(0.5, 1.5, length(uv));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}