{"ver":"0.1","info":{"id":"4dcyRH","date":"1518147188","viewed":131,"name":"Speedy Spin","username":"kingish","description":"A cool speedy spinny animation.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*float gaussian1[121] = float [121]( 0.006849, 0.007239, 0.007559, 0.007795, 0.007941, 0.00799, 0.007941,\n                                       0.007795, 0.007559, 0.007239, 0.006849, 0.007239, 0.007653, 0.00799,\n                                       0.00824, 0.008394, 0.008446, 0.008394, 0.00824, 0.00799, 0.007653,\n                                       0.007239, 0.007559, 0.00799, 0.008342, 0.008604, 0.008764, 0.008819,\n                                       0.008764, 0.008604, 0.008342, 0.00799, 0.007559, 0.007795, 0.00824,\n                                       0.008604, 0.008873, 0.009039, 0.009095, 0.009039, 0.008873, 0.008604,\n                                       0.00824, 0.007795, 0.007941, 0.008394, 0.008764, 0.009039, 0.009208,\n                                       0.009265, 0.009208, 0.009039, 0.008764, 0.008394, 0.007941, 0.00799,\n                                       0.008446, 0.008819, 0.009095, 0.009265, 0.009322, 0.009265, 0.009095,\n                                       0.008819, 0.008446, 0.00799, 0.007941, 0.008394, 0.008764, 0.009039,\n                                       0.009208, 0.009265, 0.009208, 0.009039, 0.008764, 0.008394, 0.007941,\n                                       0.007795, 0.00824, 0.008604, 0.008873, 0.009039, 0.009095, 0.009039,\n                                       0.008873, 0.008604, 0.00824, 0.007795, 0.007559, 0.00799, 0.008342,\n                                       0.008604, 0.008764, 0.008819, 0.008764, 0.008604, 0.008342, 0.00799,\n                                       0.007559, 0.007239, 0.007653, 0.00799, 0.00824, 0.008394, 0.008446,\n                                       0.008394, 0.00824, 0.00799, 0.007653, 0.007239, 0.006849, 0.007239,\n                                       0.007559, 0.007795, 0.007941, 0.00799, 0.007941, 0.007795, 0.007559,\n                                       0.007239, 0.006849 );\n\nfloat gaussian2[25] = float[25](\n0.003765,\t0.015019,\t0.023792,\t0.015019,\t0.003765,\n0.015019,\t0.059912,\t0.094907,\t0.059912,\t0.015019,\n0.023792,\t0.094907,\t0.150342,\t0.094907,\t0.023792,\n0.015019,\t0.059912,\t0.094907,\t0.059912,\t0.015019,\n0.003765,\t0.015019,\t0.023792,\t0.015019,\t0.003765 );*/\n\nfloat gaussian1[9] = float[9](\n    \n0.024879,\t0.107973,\t0.024879,\n0.107973,\t0.468592,\t0.107973,\n0.024879,\t0.107973,\t0.024879 );\n\nfloat gaussian2[9] = float[9](\n    \n0.077847,\t0.123317,\t0.077847,\n0.123317,\t0.195346,\t0.123317,\n0.077847,\t0.123317,\t0.077847 );\n\nfloat gaussian3[9] = float[9](\n\n0.102059,\t0.115349,\t0.102059,\n0.115349,\t0.130371,\t0.115349,\n0.102059,\t0.115349,\t0.102059);\n\nvec2 getUV(int col, int row, vec2 resolution) {\n    return vec2(1.0 * float(col) / resolution[0], 1.0 * float(row) / resolution[1]);\n}\n\nvec3 convoluteKernel3(vec2 uv, vec2 resolution) {\n    const int size = 9;\n    int thisCol = int(uv[0] * resolution[0]);\n    int thisRow = int(uv[1] * resolution[1]);\n\n    int index = 0;\n    int col = thisCol - size/2;\n    int row = thisRow - size/2 - 1;\n\n    vec3 sum = vec3(0, 0, 0);\n    while(index < size) {\n        if(index % size == 0) {\n            row += 1;\n            col = thisCol - size/2;\n        }\n\n        sum += gaussian3[index] * vec3(texture(iChannel0, getUV(col, row, resolution)));\n        index += 1;\n        col += 1;\n    }\n\n    return sum;\n}\n\nvec3 convoluteKernel2(vec2 uv, vec2 resolution) {\n    const int size = 9;\n    int thisCol = int(uv[0] * resolution[0]);\n    int thisRow = int(uv[1] * resolution[1]);\n\n    int index = 0;\n    int col = thisCol - size/2;\n    int row = thisRow - size/2 - 1;\n\n    vec3 sum = vec3(0, 0, 0);\n    while(index < size) {\n        if(index % size == 0) {\n            row += 1;\n            col = thisCol - size/2;\n        }\n\n        sum += gaussian2[index] * vec3(texture(iChannel0, getUV(col, row, resolution)));\n        index += 1;\n        col += 1;\n    }\n\n    return sum;\n}\n\nvec3 convoluteKernel1(vec2 uv, vec2 resolution) {\n    const int size = 9;\n    int thisCol = int(uv[0] * resolution[0]);\n    int thisRow = int(uv[1] * resolution[1]);\n\n    int index = 0;\n    int col = thisCol - size/2;\n    int row = thisRow - size/2 - 1;\n\n    vec3 sum = vec3(0, 0, 0);\n    while(index < size) {\n        if(index % size == 0) {\n            row += 1;\n            col = thisCol - size/2;\n        }\n\n        sum += gaussian1[index] * vec3(texture(iChannel0, getUV(col, row, resolution)));\n        index += 1;\n        col += 1;\n    }\n\n    return sum;\n}\n\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return 6.0 * t * t * t * t * t - 15.0 * t * t * t * t + 10.0 * t * t * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(uv.x < 0.345 || uv.x > 0.655 || uv.y > 0.79 || uv.y < 0.21) {\n    \tfragColor = vec4(38,40,41,255) / 255.0;\n        return;\n    }\n    \n    float t = smootherstep(0.0, 1.0, fract(iTime / 4.0));\n    if(t > 0.3 && t < 0.7) {\n        fragColor = vec4(convoluteKernel3(uv + vec2(0.0,0.01), iResolution.xy), 1.0);\n    } else if((t > 0.2 && t < 0.3) || (t > 0.7 && t < 0.8)) {\n        fragColor = vec4(convoluteKernel2(uv + vec2(0.0,0.01), iResolution.xy), 1.0);\n\t} else if((t > 0.15 && t < 0.2) || (t > 0.8 && t < 0.9)) {\n        fragColor = vec4(convoluteKernel2(uv + vec2(0.0,0.01), iResolution.xy), 1.0);\n\t} else {\n    \tfragColor = texture(iChannel0, uv);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float EPSILON = 0.01;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 18.0;\nint MAX_MARCHING_STEPS = 10;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix(vec3 translation)\n{\n  return mat4(1,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              translation.x, translation.y, translation.z, 1);\n}\n\nstruct SDFData {\n    float SDV;\n    float id;\n};\n\nfloat TIMESPEED = 2.0;\n\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return 6.0 * t * t * t * t * t - 15.0 * t * t * t * t + 10.0 * t * t * t;\n}\n\nSDFData SDFScene(vec3 p, float time) {\n    float rotations[4] = float[](0.0,90.0,180.0,270.0);\n    float sections[3] = float[](0.0,60.0,120.0);\n    \n    float val = 1000000000.0f;\n    float alpha = 0.0;\n    \n    for(int i = 0; i < 4; ++i) {\n        for(int j = 0; j < 3; ++j) {\n            float t = smootherstep(0.0, 1.0, fract(iTime / 4.0));\n            \n            int kVal;\n            if(t < 0.1 || t > 0.90) {\n                kVal = 1;\n            } else if(t > 0.9 && t < 0.95) {\n                kVal = int(10.0 * t);\n            } else {\n                kVal = int(20.0 * t);\n            }\n            \n            for(int k = 0; k < kVal; k++) {\n          \t\tmat4 trans =  rotationMatrix(vec3(0,0,1), sections[j]) * \n                    rotationMatrix(vec3(1,0,0),\n                                   3600.0 * smootherstep(0.0, 1.0, fract((iTime - (float(k) * 0.01)) / 4.0)) + rotations[i]) *\n                    translationMatrix(vec3(0,2.62,0));\n                vec3 q = vec3(inverse(trans)*vec4(p,1));\n                float scale = 0.07;\n\n                float tempVal = scale * (length(q/scale) - 1.0);\n\n                if(tempVal < val) {\n                    val = tempVal;\n                    alpha = 1.0 / float(k);\n                }\n            }\n        }\n    }\n    \n\n\treturn SDFData(val, alpha);\n}\n\nSDFData raymarch(vec3 eye, vec3 marchingDirection, float start, float end, float time) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        SDFData data = SDFScene(eye + depth * marchingDirection, time);\n        float dist = data.SDV;\n        if (dist < EPSILON) {\n            return SDFData(depth, data.id);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return SDFData(end, 0.0f);\n        }\n    }\n    return SDFData(end, 0.0f);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat4(vec4(s, 0.0), vec4(u, 0.0), vec4(-f, 0.0), vec4(0.0, 0.0, 0.0, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(uv.x < 0.345 || uv.x > 0.655 || uv.y > 0.79 || uv.y < 0.21) {\n    \tfragColor = vec4(38,40,41,255) / 255.0;\n        return;\n    }\n\n    vec3 dir = rayDirection(70.0, vec2(iResolution.x,iResolution.y), vec2(gl_FragCoord.x, gl_FragCoord.y));\n    vec3 eye = vec3(4.5, 0.0, 14.0);\n    \n    eye = vec3(rotationMatrix(vec3(1,0,0), iTime*50.0) * vec4(eye,1));\n    \n    vec3 lightPosition = vec3(1,1,1);\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0, 0, 0), vec3(1.0, 0.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    SDFData data = raymarch(eye, worldDir, MIN_DIST, MAX_DIST, iTime);\n    float dist = data.SDV;\n    \n    if (dist > MAX_DIST - EPSILON) {\n    \tfragColor = vec4(38,40,41,255) / 255.0;\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    //vec3 normal = estimateNormal(p, iTime);\n    fragColor = vec4(220,220,200,255.0)/255.0;\n    //vec3 col = color * lambert(normal, eye - lightPosition);\n    //fragColor = vec4(color, max(data.id, 1.0));\n}","name":"Buf A","description":"","type":"buffer"}]}