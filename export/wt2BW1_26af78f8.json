{"ver":"0.1","info":{"id":"wt2BW1","date":"1598991954","viewed":109,"name":"spherical mandelbox","username":"sasha_sortai","description":"translating the mandelbox fractal to spherical geometry","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noneuclidean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Regular mandelbox\nvoid mandelbox_pln(inout vec2, float, float, float, vec2);\nvoid boxfold_pln(inout vec2, float);\nvoid inversion_pln(inout vec2, float);\nvoid scale_pln(inout vec2, float);\nvoid trans_pln(inout vec2, vec2);\n\n// Spherical mandelbox\nvoid mandelbox(inout vec3, float, float, float, vec2);\nvoid boxfold(inout vec3, float);\nvoid inversion(inout vec3, float);\nvoid scale(inout vec3, float);\nvoid trans(inout vec3, vec2);\n\n#define ITER 100\n\nconst float PI = acos(0.)*2.;\n\nconst float mult = 3.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool plane = mod(iTime/5.,1.)<.5;\n    //plane = false;\n    vec2 uv = (fragCoord-.5*iResolution.xy)*2./min(iResolution.x, iResolution.y);\n    //uv /= 40.;\n    \n    vec3 col = vec3(1);\n    \n    // Regular\n    if (plane)\n    {\n        vec2 p = uv*3.;\n        \n        float li = 2.;\n        \n        float fac = 1./.81;\n        for (int i = 0; i<ITER; i++)\n        {\n            if (max(abs(p.x),abs(p.y))>li)\n            {\n                fac *= .9 -.09/(max(abs(p.x),abs(p.y))-li+1.);\n                break;\n            }\n            mandelbox_pln(p, 1.2, 1., 1.4, iMouse.z<=0. ? vec2(cos(iTime),sin(iTime))*.5 :\n                         (iMouse.xy-.5*iResolution.xy)*3.*2./min(iResolution.x, iResolution.y)\n                         );\n            fac *= .9;\n        }\n        \n        col *= 1.-fac;\n        //col.b = (min(abs(p.x),abs(p.y))>li ? length(abs(p)-li) : max(abs(p.x),abs(p.y))-li);\n        col.b = max(abs(p.x),abs(p.y))-li;\n        //col = vec3(p,0);\n    }\n    // spherical\n    else if (length(uv*3./mult)<1.)\n    {\n        uv /= (mult/3.);\n        vec3 p = vec3(uv, sqrt(1.-dot(uv,uv)));\n        \n        float li = 2./mult;\n        \n        float fac = 1./.81;\n        for (int i = 0; i<ITER; i++)\n        {\n            if (max(acos(normalize(p.zx).x),acos(normalize(p.zy).x))>li)\n            {\n                fac *= .9 -.09/(max(acos(normalize(p.zx).x),acos(normalize(p.zy).x))-li+1.);\n                break;\n            }\n            //mandelbox(p, 1.2/mult, 1./mult, 1.4, vec2(cos(iTime),sin(iTime))*.5/mult);\n            mandelbox(p, 1.2/mult, 1./mult, 1.4, iMouse.z<=0. ? vec2(cos(iTime),sin(iTime))*.5/mult :\n                         (iMouse.xy-.5*iResolution.xy)*3.*2./min(iResolution.x, iResolution.y));\n            fac*=.9;\n            //float ang = acos(p.z); p.xy *= mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n        }\n        \n        //col = p;\n        col *= 1.-fac;\n        /*\n        col.b =\n            (\n                min(acos(normalize(p.zx).x),acos(normalize(p.zy).x))>li ?\n                acos( dot(vec3(abs(p.xy),p.z), vec3(vec2(sin(li)/sqrt(1.+sin(li)*sin(li))), cos(li)/sqrt(1.+sin(li)*sin(li))))):\n                max(acos(normalize(p.zx).x),acos(normalize(p.zy).x))-li\n            )*mult;\n\t\t*/\n        col. b = (max(acos(normalize(p.zx).x),acos(normalize(p.zy).x))-li)*mult;\n        //col = p * vec3(mult,mult,-.5);\n        //if (abs(length(uv)-1./mult)<.002) col = vec3(1);\n        //col.b = 100.*acos( dot(vec3(abs(p.xy),p.z), vec3(vec2(sin(li)/sqrt(1.+sin(li)*sin(li))), cos(li)/sqrt(1.+sin(li)*sin(li)))));\n        //col.rg=vec2(col.b);\n        //col.r = 1.-10.*distance(vec2(sin(li)/sqrt(1.+sin(li)*sin(li))),uv);\n    }\n    else col = vec3(0);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n// Spherical mandelbox\nvoid mandelbox(inout vec3 p, float bi, float ic, float sc, vec2 tr)\n{\n    boxfold(p, bi);\n    if (acos(p.z)<ic) inversion(p, ic);\n    scale(p, sc);\n    trans(p, tr);\n}\nvoid boxfold(inout vec3 p, float bi)\n{\n    if (length(p.xy)!=0.)\n    {\n        vec2 v2 = p.xy/(p.z+1.);\n        if (abs(v2.x)>tan(bi/2.)) v2.x += (sign(v2.x)*tan(bi/2.)-v2.x)*2.;\n        if (abs(v2.y)>tan(bi/2.)) v2.y += (sign(v2.y)*tan(bi/2.)-v2.y)*2.;\n        float l = length(v2);\n        p.xy = v2*sin(2.*atan(l))/l;\n        p.z = cos(2.*atan(l));\n    }\n}\nvoid inversion(inout vec3 p, float ic)\n{\n    if (length(p.xy)==0.) p.z *= -1.;\n    else\n    {\n        vec2 ve = vec2(p.z,length(p.xy));\n        ve = vec2(cos(ic),(cos(ic)-ve.x)/(ve.y*cos(ic)));\n        ve /= dot(ve,ve);\n        p = 2.*vec3(normalize(p.xy)*ve.y, ve.x) - p;\n        p.xy *= -1.;\n        p = normalize(p);\n    }\n}\nvoid scale(inout vec3 p, float sc)\n{\n    if (length(p.xy)!=0.)\n    {\n        if (abs(sc) != 1.)\n        {\n            p.z *= -1.;\n            vec2 ve = vec2(p.z,length(p.xy));\n            float sf = (1./sc+1.)/(1./sc-1.);\n            ve = vec2(1./sf,(1./sf-ve.x)/(ve.y));\n            ve /= dot(ve,ve);\n            p = 2.*vec3(normalize(p.xy)*ve.y, ve.x) - p;\n        }\n        else if (sc==-1.)\n        {\n            p.xy *= -1.;\n        }\n    }\n    \n}\n\nvoid trans(inout vec3 p, vec2 tr)\n{\n    if (length(tr)!=0.)\n    {\n        vec3 b0 = vec3(0,0,1);\n        vec3 b1 = vec3(normalize(tr),0);\n        vec3 b2 = cross(b0,b1);\n        vec3 tb = vec3(dot(p,b0), dot(p,b1), dot(p,b2));\n        float alpha = length(tr);\n        vec3 tmp = cos(alpha)*b0+sin(alpha)*b1;\n        b1 = cos(alpha)*b1-sin(alpha)*b0;\n        b0 = tmp;\n        p = b0*tb.x+b1*tb.y+b2*tb.z;\n    }\n}\n\n\n\n// Regular mandelbox\nvoid mandelbox_pln(inout vec2 p, float bi, float ic, float sc, vec2 tr)\n{\n    boxfold_pln(p, bi);\n    if (length(p)<ic) inversion_pln(p, ic);\n    scale_pln(p, sc);\n    trans_pln(p, tr);\n}\nvoid boxfold_pln(inout vec2 p, float bi)\n{\n    if (abs(p.x)>bi) p.x = 2.*sign(p.x)*bi-p.x;\n    if (abs(p.y)>bi) p.y = 2.*sign(p.y)*bi-p.y;\n}\nvoid inversion_pln(inout vec2 p, float ic)\n{\n    if (length(p)<ic) p /= dot(p,p)/(ic*ic);\n}\nvoid scale_pln(inout vec2 p, float sc)\n{\n    p *= sc;\n}\nvoid trans_pln(inout vec2 p, vec2 tr)\n{\n    p += tr;\n}\n","name":"Image","description":"","type":"image"}]}