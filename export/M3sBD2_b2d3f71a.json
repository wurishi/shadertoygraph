{"ver":"0.1","info":{"id":"M3sBD2","date":"1728959292","viewed":140,"name":"Loopless Rose of Circles","username":"pyBlob","description":"The difficult part was to find out how to derive \"i\" given \"length(uv)\" (hint: inspect the far intersection of circles with radius \"r2\" and center \"R(+-alpha) * vec2(r1, 0)\")","likes":14,"published":3,"flags":0,"usePreview":0,"tags":["circle","loopless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 2. * acos(-1.);\n#define R(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sqr(x) ((x)*(x))\n\nfloat ray(vec2 x)\n{\n    return length(vec2(min(0., x.x), x.y));\n}\n\nfloat rose(vec2 uv, float K, float r1, float r2)\n{\n    float y = length(uv);\n    float p = (sqr(r1) - sqr(r2) + sqr(y)) / (2. * y);\n    float i = floor(2.*K/tau * acos(clamp(p / r1, -1., 1.)));\n    float j = floor(2.*K/tau * atan(uv.y, uv.x));\n    i = (mod(i + j, 2.) == 0. ? i - j : -(1. + i + j)) / 2.;\n    return abs(length(uv - R(tau/K * i) * vec2(r1, 0)) - r2);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    float f = 4. / iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy / 2.) * f;\n\n    float t = 3.11 + (iTime - 10.) / 6.;\n    float r1 = sin(tau * t);\n    float r2 = abs(cos(tau * t));\n    float K = 2. + mod(7. * floor(2. * t), 11.);\n    uv *= R(cos(t) * 5.);\n\n    if (false) // polar slice\n        uv = fragCoord / iResolution.xy,\n        uv = vec2((r2 - r1) + 2. * r1 * uv.x, 0) * R(tau/K * uv.y),\n        f = length(fwidth(uv)) * .7;\n\n    float r = 1e9;\n    if (false)\n        for (float i=0. ; i<K ; i++) // loopy\n            r = min(r, abs(length(uv - R(tau/K * i) * vec2(r1, 0)) - r2));\n\n   //if (false)\n        r = min(r, rose(uv, K, r1, r2)); // loopless\n\n    float g = 1.;\n    g = .5;\n    if (false)\n        for (float i=g ; i*2.<K ; i+=g) // grid\n            r = min(r, abs(length(uv) - (cos(tau/K * i) * r1 + sqrt(sqr(r2) - sqr(sin(tau/K * i) * r1)))));\n\n    if (false)\n        r = min(r, ray(uv)), // grid\n        r = min(r, ray(R(tau/K * g) * uv));\n\n    if (false)\n        r = min(r, abs(length(uv) - (r2 - r1))),\n        r = min(r, abs(length(uv) - (r2 + r1)));\n\n    r = smoothstep(0., f, r-.5 * f);\n    fragColor = vec4(sqrt(vec3(r)), 1);\n}\n","name":"Image","description":"","type":"image"}]}