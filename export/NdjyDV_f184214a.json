{"ver":"0.1","info":{"id":"NdjyDV","date":"1644138098","viewed":337,"name":"Swirls planet","username":"trapped_in_a_while_loop","description":"Mouse: move light, Up: new seed, Down: new color, Right/Left: resolution. Enjoy.\n\nDemo for: https://github.com/tiawl/spaceporn\nUI inspired by: https://github.com/Deep-Fold/PixelPlanets\n\nIf you have any advice to improve it, I will be happy to read you.","likes":30,"published":1,"flags":48,"usePreview":0,"tags":["swirl","pixel","star","space","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define BufferAChannel  iChannel0\n# define BufferBChannel  iChannel1\n\n# define SWIRLS_RADIUS 0.5\n# define RADIUS 0.425\n\nuint seed;\nuint col_seed;\nfloat pix;\n\n// 3D hash function to simulate seeding:\n// https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3d(uvec3 v)\n{\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * v.z;\n  v.y += v.z * v.x;\n  v.z += v.x * v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y * v.z;\n  v.y += v.z * v.x;\n  v.z += v.x * v.y;\n\n  return v;\n}\n\n// https://www.shadertoy.com/view/XlGcRh\nfloat hash(vec2 s, uint hash_seed)\n{\n  float res;\n  uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y));\n  uvec3 p = pcg3d(uvec3(u.x, u.y, hash_seed));\n  res = float(p) * (1. / float(0xffffffffu));\n  return res;\n}\n\nfloat noise(vec2 coord, uint noise_seed)\n{\n  vec2 i = floor(coord);\n  vec2 f = fract(coord);\n  f = f * f * (3. - 2. * f);\n\n  float a = hash(i, noise_seed);\n  float b = hash(i + vec2(1., 0.), noise_seed);\n  float c = hash(i + vec2(0., 1.), noise_seed);\n  float d = hash(i + vec2(1., 1.), noise_seed);\n\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k)\n{\n  float h = max(k - abs(a - b), 0.);\n  return max(a, b) + h * h * 0.25 / k;\n}\n\nvec2 rotation(vec2 p, float a)\n{\n  return p * mat2(cos(a), -sin(a),\n                  sin(a),  cos(a));\n}\n\nvec2 spherify(vec2 uv, vec2 center, float radius)\n{\n  vec2 centered = (uv - center) * 2.;\n  float z = sqrt(radius * radius * 4. - dot(centered.xy, centered.xy));\n  vec2 sphere = centered / (z + 1.);\n  return sphere * 0.5 + 0.5;\n}\n\n// https://www.shadertoy.com/view/NsfyDs\nfloat circles( vec2 p, float r, uint s)\n{\n  vec2 i = floor(p), f = fract(p), h, a;\n  int k, q;\n\n  float d = 0., c, rad;\n  for (k = -1; k < 2; k++)\n  {\n    for (q = -1; q < 2; q++)\n    {\n      p = vec2(k, q);\n      rad = 0.2 + hash(i + p, s + 2u) * r;\n      h = vec2(hash(i + p, s + 89u), hash(i + p, s + 52u));\n\n      // movement\n      a = vec2(hash(i + p, s + 25u), hash(i + p, s + 215u));\n      a = 0.3 * cos(5. * (a.x - 0.5) * iTime * 0.5 + 6.3 * a.y + vec2(0., 11.));\n      p += 0.1 + 0.8 * h - f + a;\n\n      c = rad - length(p);\n      d = smax(d, c, 0.3);\n    }\n  }\n  return d;\n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat fbmCircles(vec2 p, uint se)\n{\n  float s = 1., d = 0.;\n  uint o = 2u;\n  for (uint i = 0u; i < o; i++)\n  {\n    float n = s * circles(p, 0.5, se + i);\n\n    d = smax(d, n, 0.3 * s);\n\n    p *= 2.;\n    s = 0.5 * s;\n  }\n  return d;\n}\n\n// original author warned against discontinuities that I did not fix:\n// https://www.shadertoy.com/view/fsKSWD\nvec2 swirls(vec2 p, uint se,  float sz, float ro)\n{\n  p *= 360. / sz;\n  \n  vec2 i = round(p), d, cc;\n  int k, q;\n  float r, h;\n  for (k = -1; k < 2; k++)\n  {\n    for (q = -1; q < 2; q++)\n    {\n      cc = i + vec2(k, q);\n      d = cc + vec2(hash(cc, se + 222u), hash(cc, se + 278u)) - vec2(0.5);\n      h = hash(cc, se + 72u)  * 2. - 1.;\n      p -= d;\n      r = ro * sign(h) * smoothstep(0., SWIRLS_RADIUS, (SWIRLS_RADIUS - length(p)) * abs(h));\n      p = rotation(p, r) + d;\n    }\n  }\n  return p / (360. / sz);\n}\n\n\nvec2 fbmSwirls(vec2 p, uint se)\n{\n  uint o = 3u;\n  p += vec2(iTime * 0.02, 0.);\n  float sz = 42., ro = 3.;\n  for (uint i = 0u; i < o; i++)\n  {\n    p = swirls(p, se + i, sz, ro);\n    sz *= 2.;\n  }\n  return p;\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n  vec3 rgb = clamp(abs(mod(c.x * 6.\n    + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n// https://www.slynyrd.com/blog/2018/1/10/pixelblog-1-color-palettes\nvec3 planet_color(float sm)\n{\n  float hu, sa, br;\n  if (col_seed < 1u)\n  {\n    hu = radians(6.2832 * (9. * hash(vec2(1.), col_seed)\n      + sm * (hash(vec2(10.), 5u) * 0.75 - 1.5)));\n  } else {\n    hu = radians(6.2832 * (9. * hash(vec2(1.), col_seed)\n      + sm * (hash(vec2(10.), col_seed) * 0.5)));\n  }\n  if (sm < 2.5)\n  {\n    sa = 0.2 + 0.15 * sm;\n  } else if (sm < 3.5) {\n    sa = 0.4;\n  } else if (sm < 4.5) {\n    sa = 0.5;\n  } else {\n    sa = 0.55 - 0.07 * (sm - 4.);\n  }\n  if (sm < 3.5)\n  {\n    br = 0.15 + 0.1 * sm;\n  } else if (sm < 6.5) {\n    br = 0.5 + 0.075 * (sm - 3.);\n  } else {\n    br = 0.7 + 0.1 * (sm - 6.);\n  }\n  return hsv2rgb(vec3(hu, sa, br));\n}\n\n// https://www.shadertoy.com/view/MslGWN\nvec3 nrand3(vec2 co)\n{\n  float a = hash(co, 98u);\n  float b = hash(co, 99u);\n  float c = mix(a, b, 0.5);\n  return vec3(c);\n}\n\n// https://www.shadertoy.com/view/MslGWN\nvec4 stars(vec2 uv)\n{\n  vec3 rnd = nrand3(uv);\n  float r = rnd.y;\n  vec4 starcolor = vec4(r * r * r * r * r);\n\n  if (starcolor.x > 0.3)\n  {\n    float brighness_variance = max(0.15, hash(uv, 94u) / 2.);\n    return starcolor + vec4(abs(sin((iTime * 10. + hash(uv, 94u)) *\n      (hash(uv, 95u) + 1.))) * brighness_variance\n      - (brighness_variance / 2.));\n  } else {\n    return vec4(0.);\n  }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n  seed = uint(round(abs(texelFetch(BufferAChannel, ivec2(u), 0).x)));\n  col_seed = uint(round(abs(texelFetch(BufferAChannel, ivec2(u), 0).y)));\n  pix = round(texelFetch(BufferAChannel, ivec2(u), 0).z);\n  \n  vec2 text = texelFetch(BufferBChannel, ivec2(u), 0).yz;\n  if (text.y > 0.)\n  {\n    O = vec4((0.6 + 0.6 * cos(6.3 *\n      ((u.x * 6. - iResolution.x * 0.25) / (3.14 * iResolution.y)) + vec4(0, 23, 21, 0))\n      * 0.85 + 0.15) * text.x);\n    return;\n  }\n  \n  vec2 bU = u / iResolution.y;\n  vec2 U = floor(bU * pix);\n  bool dith = mod(U.x + U.y, 2.) < 1.;\n  U /= pix;\n\n  if (distance(U, iResolution.xy / (2. * iResolution.y)) > RADIUS)\n  {\n    U *= iResolution.y;\n    float sta = stars(U).x * noise(U * 0.1, 182u);\n    O = vec4(sta * vec3(2. * noise(U * 0.025, 47u),\n      1.5 * noise(U * 0.025, 52u), 3.), 1.);\n    return;\n  }\n\n  U = spherify(U, iResolution.xy / (2. * iResolution.y), RADIUS);\n  vec2 aU = fbmSwirls(U, seed + 151u);\n  float g = fbmCircles(aU * 10. + vec2(iTime * 0.2, 0.), seed + 151u);\n  g = smax(-1.23, g, 3.1);\n\n  float sm = sqrt(sqrt(max(g, 0.025))) * 12.;\n\n  // light and dithering\n  float d_light = distance(U, iMouse.xy / iResolution.xy) / sqrt(RADIUS);\n  float light_b =\n    max(0.8 - d_light + (noise(U * 15., seed + 15u) - 0.5) * 0.2, 0.05);\n  light_b = sqrt(light_b);\n  sm = dith ? 0.98 * sm * light_b : sm * light_b;\n\n  sm = sm - mod(sm, sqrt(sqrt(light_b))) + 1.;\n\n  O = vec4(planet_color(sm), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define BufferAChannel  iChannel0\n# define KeyboardChannel iChannel1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  fragColor =   texelFetch(BufferAChannel, ivec2(fragCoord), 0);\n  float up =    texelFetch(KeyboardChannel, ivec2(KEY_UP, 0), 0).x;\n  float down =  texelFetch(KeyboardChannel, ivec2(KEY_DOWN, 0), 0).x;\n  float right = texelFetch(KeyboardChannel, ivec2(KEY_RIGHT, 0), 0).x;\n  float left =  texelFetch(KeyboardChannel, ivec2(KEY_LEFT, 0), 0).x;\n  if ((up > 0.5) && (sign(fragColor.x) < 0.5))\n  {\n    fragColor.x = abs(fragColor.x);\n    fragColor.x += 10.;\n  } else if ((up < 0.5) && (sign(fragColor.x) > 0.5)) {\n    fragColor.x = -1. * fragColor.x;\n  }\n  if ((down > 0.5) && (sign(fragColor.y) < 0.5))\n  {\n    fragColor.y = abs(fragColor.y);\n    fragColor.y += 1.;\n  } else if ((down < 0.5) && (sign(fragColor.y) > 0.5)) {\n    fragColor.y = -1. * fragColor.y;\n  }\n  if ((right > 0.5) && (fragColor.z < iResolution.y))\n  {\n    fragColor.z += 5.;\n  }\n  if ((left > 0.5) && (fragColor.z > 50.))\n  {\n    fragColor.z -= 5.;\n  }\n  if ((iFrame < 1) || (fragColor.w != iResolution.y))\n  {\n    fragColor = vec4(0., 0., 100., iResolution.y);\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"# define KEY_LEFT  37\n# define KEY_UP    38\n# define KEY_RIGHT 39\n# define KEY_DOWN  40","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    --------------------------------------------------------------------------------------------\n       until mainImage function: dirty copy-pasting from https://www.shadertoy.com/view/Xd2fzK\n    --------------------------------------------------------------------------------------------\n*/\n\n# define BufferBChannel  iChannel0\n# define KeyboardChannel iChannel1\n# define fontChannel     iChannel2\n# define BufferAChannel  iChannel3\n# define SPACE_CHAR 0x02U\n# define STOP_CHAR 0x0AU\n\nconst int[] FONT_NB = int[](0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x93);\n\nvec4 fontCol;\nvec3 fontColFill;\nvec3 fontColBorder;\nvec4 fontBuffer;\nvec2 fontCaret;\nfloat fontSize;\nfloat fontSpacing;\nvec2 fontUV;\n\nfloat log10(float x)\n{\n  if (x < 9.5)\n  {\n    return 0.;\n  } else if (x < 99.5) {\n    return 1.;\n  } else if (x < 999.5) {\n    return 2.;\n  } else if (x < 9999.5) {\n    return 3.;\n  } else if (x < 99999.5) {\n    return 4.;\n  } else {\n    return floor(log(x) / log(10.));\n  }\n}\n\nvec4 fontTextureLookup(vec2 xy){\n  float dxy = 1024. * 1.5;\n  vec2 dx = vec2(1., 0.) / dxy;\n  vec2 dy = vec2(0., 1.) / dxy;\n  return (\n           texture(fontChannel, xy + dx + dy) +\n           texture(fontChannel, xy + dx - dy) +\n           texture(fontChannel, xy - dx - dy) +\n           texture(fontChannel, xy - dx + dy) +\n      2. * texture(fontChannel, xy)\n  ) / 6.;\n}\n\nvoid drawStr4(uint str)\n{\n  if (str < 0x100U)\n  {\n    str = str * 0x100U + SPACE_CHAR;\n  }\n    \n  if (str < 0x10000U)\n  {\n    str = str * 0x100U + SPACE_CHAR;\n  }\n  \n  if (str < 0x1000000U)\n  {\n    str = str * 0x100U + SPACE_CHAR;\n  }  \n  \n  for (int i = 0; i < 4; i++)\n  {\n    uint xy = (str >> 8 * (3 - i)) % 256U;\n    if (xy != SPACE_CHAR)\n    {\n      vec2 K = (fontUV - fontCaret) / fontSize;\n      if (length(K) < 0.6)\n      {\n        vec4 Q = fontTextureLookup((K + vec2(float(xy / 16U) + 0.5,\n          16. - float(xy % 16U) - 0.5)) / 16.);\n        fontBuffer.rgb += Q.rgb * smoothstep(0.6, 0.4, length(K));\n\n        if (max(abs(K.x), abs(K.y)) < 0.5)\n        {\n          fontBuffer.a = min(Q.a, fontBuffer.a);\n        }\n      }\n    }\n      \n    if (xy != STOP_CHAR)\n    {\n      fontCaret.x += fontSpacing * fontSize;\n    }\n  }\n}\n\nvoid beginDraw()\n{\n  fontBuffer = vec4(0., 0., 0. , 1.);\n  fontCol = vec4(0.);\n  fontCaret.x += fontSpacing * fontSize / 2.;\n}\n\nvoid endDraw()\n{\n  float a = smoothstep(1., 0., smoothstep(0.51, 0.53, fontBuffer.a));\n  float b = smoothstep(0., 1., smoothstep(0.48, 0.51, fontBuffer.a));\n    \n  fontCol.rgb = mix(fontColFill, fontColBorder, b);\n  fontCol.a = a;\n}\n\nvoid _(uint str)\n{\n  beginDraw();\n  drawStr4(str);\n  endDraw();\n}\n\nvoid _(uvec2 str)\n{\n  beginDraw();\n  drawStr4(str.x);\n  drawStr4(str.y);\n  endDraw();\n}\n\nvoid _(uvec3 str)\n{\n  beginDraw();\n  drawStr4(str.x);\n  drawStr4(str.y);\n  drawStr4(str.z);\n  endDraw();\n}\n\nvoid _(uvec4 str)\n{\n  beginDraw();\n  drawStr4(str.x);\n  drawStr4(str.y);\n  drawStr4(str.z);\n  drawStr4(str.w);\n  endDraw();\n}\n\nvec2 viewport(vec2 b)\n{\n  return (b / iResolution.xy - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n}\n\n/*\n   ---------------------------------------------------------------------------------------\n    end of copy-pasting\n   ---------------------------------------------------------------------------------------\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float pix = round(texelFetch(BufferAChannel, ivec2(fragCoord), 0).z);\n\n  fragColor =   texelFetch(BufferBChannel, ivec2(fragCoord), 0);\n  float up =    texelFetch(KeyboardChannel, ivec2(KEY_UP, 0), 0).x;\n  float down =  texelFetch(KeyboardChannel, ivec2(KEY_DOWN, 0), 0).x;\n  float right = texelFetch(KeyboardChannel, ivec2(KEY_RIGHT, 0), 0).x;\n  float left =  texelFetch(KeyboardChannel, ivec2(KEY_LEFT, 0), 0).x;\n\n  vec2 coord = viewport(fragCoord);\n  fontCaret = vec2(-0.8, 0.4);\n  fontSize = 0.1;\n  fontSpacing = 0.45;\n  fontUV = coord;\n  fontColFill = vec3(1.);\n  fontColBorder = vec3(0.);\n    \n  if (up > 0.5)\n  {\n    _(uvec2(0xE4567702, 0x35565646));\n    fragColor = vec4(iTime, fontCol.x, fontCol.w, 0.);\n  } else if (down > 0.5) {\n    _(uvec3(0xE4567702, 0x34F6C6F6, 0x27020202));\n    fragColor = vec4(iTime, fontCol.x, fontCol.w, 0.);\n  } else if ((left > 0.5) || (right > 0.5)) {\n    float chars = log10(pix) + 1.;\n    fontCaret.x -= 0.05 * (4. - chars);\n    float p = pix, power;\n    int str = 0x02020202;\n    while (chars > 0.5)\n    {\n      chars -= 1.;\n      power = pow(10., chars);\n      str = (str << 8) + FONT_NB[int(p / power)];\n      p = floor(mod(p, power));\n    }\n    _(uvec3(str, 0x02079687, 0x56C63702));\n    fragColor = vec4(iTime, fontCol.x, fontCol.w, 0.);;\n  }\n    \n  if ((iTime - fragColor.x > 1.) || (iFrame < 1))\n  {\n    fragColor = vec4(0.);\n  }\n}","name":"Buffer B","description":"","type":"buffer"}]}