{"ver":"0.1","info":{"id":"cl23Wz","date":"1673144756","viewed":74,"name":"Secant method","username":"zenzicubic","description":"A secant method  fractal from z^3 - 1, based on my Newton shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","secant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n#define ITERS 250\n#define TOL 1e-10\n#define NUMROOTS 3\n\nvec3 colors[NUMROOTS] = vec3[](\n    vec3(0.475,0.78,0.773),\n    vec3(0.451,0.671,0.518),\n    vec3(0.216,0.153,0.447)\n);\n\nvec2 roots[NUMROOTS];\n\n// complex number utils\nvec2 fromRoot(float n, float k)\n{\n    float t = (2.0 * PI * k) / n;\n    return vec2(cos(t), sin(t));\n}\n\nvec2 cmul(vec2 a, vec2 b) \n{\n    float c = a.x * b.x - a.y * b.y;\n    float d = a.y * b.x + a.x * b.y;\n    return vec2(c, d);\n}\n\nvec2 cdiv(vec2 a, vec2 b) \n{\n    float d = a.y * b.x - a.x * b.y;\n    float l = dot(b, b);\n    return vec2(dot(a, b) / l, d / l);\n}\n\n\nvec3 brighten(vec3 col, float fac) \n{\n    float r = clamp(col.x * fac, 0., 1.);\n    float g = clamp(col.y * fac, 0., 1.);\n    float b = clamp(col.z * fac, 0., 1.);\n    return vec3(r, g, b);\n}\n\nvec2 f(vec2 z) \n{\n    vec2 prod = vec2(1, 0);\n    for (int i = 0; i < NUMROOTS; i ++)\n    {\n        prod = cmul(prod, z - roots[i]);\n    }\n    return prod;\n}\n\nvec2 scale(vec2 c)\n{\n    return (2. * c - iResolution.xy) / iResolution.y;\n}\n\nvec4 test(vec2 z)\n{\n    float dist, col;\n    \n    float t = 0.2 * iTime;\n    float r = cos(t * 3.);\n    \n    vec2 tz, lz = z + vec2(cos(t) * r, sin(t) * r);\n    for (int i = 0; i < ITERS; i ++) \n    {\n        tz = z;\n        z -= cmul(f(z), cdiv(z - lz, f(z) - f(lz)));\n        lz = tz;\n        for (int j = 0; j < NUMROOTS; j ++)\n        {\n            dist = distance(z, roots[j]);\n            if (dist < TOL) \n            {\n                col = 1. - (float(i) / float(ITERS));\n                return vec4(colors[j], col);\n            }\n        }\n    }\n    return vec4(colors[0], 0.);\n}\n\nvoid fillRoots() \n{\n    for (int i = 0; i < NUMROOTS; i ++) \n    {\n        roots[i] = fromRoot(float(NUMROOTS), float(i));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fillRoots();\n    vec2 z = scale(fragCoord);\n\n    vec4 col_raw = test(z);\n    vec3 col = brighten(col_raw.xyz, col_raw.w);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}