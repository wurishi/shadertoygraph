{"ver":"0.1","info":{"id":"MlKyWR","date":"1544809581","viewed":158,"name":"Miniplanet","username":"Peetu","description":"Raymarching a Miniplanet created using 3d noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float end = 100.0;\nconst float start = 0.01;\nconst float PI = 3.14159265359;\nconst vec3 randomVec = vec3(123.345, 512.134, 42.514);\nconst float SPHERE_SIZE = 0.45;\n\nfloat star(vec2 p) {\n    return 1. - length(p) * 400.;\n}\n\nfloat random (float seed) {\n    vec2 st = vec2(seed * 24.511, seed * 952.123); \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 bg(vec2 p) {\n    float f = 0.;\n    p = mod(p, vec2(1.));\n    \n    for(int i = 1; i < 300; i++) {\n        float fi = float(i);\n        vec2 starLoc = vec2(random(fi), random(fi + 41.6));\n        f += max(0., star(abs(p - starLoc)));\n    }\n    return vec3(f);\n}\nfloat displace(vec3 p) {\n    \n    return texture(iChannel0, p*.3).r*0.16 - .07 - texture(iChannel0, p*1.8).r*0.005;\n}\n\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.23/k;\n}\n\nmat3 rotationMatrixY(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nmat3 rotationMatrixX(float rad) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(rad), -sin(rad)),\n        vec3(0.0, sin(rad), cos(rad))\n    ); \n}\n\nmat3 rotationMatrixZ(float rad) {\n    return mat3(\n        vec3(cos(rad), -sin(rad), 0.0),\n        vec3(sin(rad), cos(rad), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec3 seaColor(vec3 p) {\n    \n    float y = mod(p.y+.1+iTime/40., .1);\n    \n\tvec3 col;\n    float offset = .05;\n    float amp = 0.015 * length(p.yz);\n    float freq = 100.- abs(p.y)*SPHERE_SIZE;\n    col = vec3(35./255., 80./255., 92./255.);\n\t\n    if(abs(sin(p.x*freq)* amp - y + offset)<0.01) {\n    \tcol += max(0.0, .9 - abs(p.y*p.y) / (SPHERE_SIZE*SPHERE_SIZE));\n\t} \n       \n    return col;\n}\n\nvec3 rockColor(vec3 p) {\n    vec3 baseCol = vec3(156./255., 149./255., 134./255.);\n\tfloat ran = texture(iChannel0, p*.54).r * 5.;\n    return vec3(0.3) + ran * vec3(0.05, 0.01, 0.02);\n}\n\nvec3 snowColor(vec3 p) {\n    return vec3(.85);\n   \n}\n\nfloat planetSDF(vec3 p){\n\treturn length(p) - SPHERE_SIZE;   \n}\n\nvec4 sceneSDF(vec3 p) {\n    float planet = planetSDF(p);\n    float dist = planet - displace(p);\n    if(dist > planet){\n        //SEA\n    \treturn vec4(seaColor(p), planet);   \n    }else if(dist < planet - 0.09 + abs(p.y)*0.1){\n    \treturn vec4(snowColor(p), dist);\n    }else{\n        //MOUNTAIN\n    \treturn vec4(rockColor(p), dist); \n    }\n}\n\nvec4 rayMarch(vec3 eye, vec3 rayDir) {\n    float depth = start;\n    for(int i = 0; i < 255; i++) {\n   \t\tvec4 data = sceneSDF(eye + rayDir * depth);\n        float dist = data.w;\n        \n        if(dist < EPSILON){\n \t      \treturn vec4(data.xyz, depth);   \n        }else if(depth >= end) {\n        \treturn vec4(vec3(0.0), end);   \n        }\n        \n        depth += dist * 0.5;\n    }\n    return vec4(vec3(0.0), end);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float E = 0.1;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + E, p.y, p.z)).w - sceneSDF(vec3(p.x - E, p.y, p.z)).w,\n        sceneSDF(vec3(p.x, p.y + E, p.z)).w - sceneSDF(vec3(p.x, p.y - E, p.z)).w,\n        sceneSDF(vec3(p.x, p.y, p.z + E)).w - sceneSDF(vec3(p.x, p.y, p.z - E)).w\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    mat3 rot = rotationMatrixX(iTime * 0.25) * rotationMatrixY(iTime * 0.13);  \n    vec3 eye = rot * vec3(-0.5+uv.x-0.25, -0.5+uv.y, -8.0);\n    vec3 rayDir = rot * vec3(0., 0., 1.0);\n    \n    vec4 data = rayMarch(eye, rayDir);\n    float depth = data.w;\n    \n    vec3 col;\n   \n   \tif(depth >= end - EPSILON) {\n        vec3 hitPos = eye + 10. * rayDir;\n    \tcol = bg(vec2(atan(hitPos.x/hitPos.z), atan(hitPos.y/max(abs(hitPos.x), abs(hitPos.z)))));\n    }else{\n        vec3 normal = estimateNormal(eye + depth * rayDir);\n        vec3 light = vec3(-1.0, -.4, .9) * rotationMatrixZ(iTime * 0.5);\n        float diffuse = clamp(dot(normal, -light), 0.0, 1.0) * .8;\n        float i = 0.1 + diffuse;\n        col = data.xyz * i;\n    }\n    \n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}