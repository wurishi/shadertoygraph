{"ver":"0.1","info":{"id":"llffRB","date":"1512265307","viewed":1038,"name":"Atmospheric Scattering Nebula","username":"QuBr","description":"Little test demo to help me better understand raymarching, very unfinished and WIP","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","nebula","atmosphericscattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define noiseResInverse      1.0 / 32.0\n\n#define PI                   radians(180.0)\n\n#define rayleighCoefficient  vec3(4.847e-6, 1.149e-5, 2.87e-5 )\n#define mieCoefficient       3e-6\n#define nebulaCoeff          rayleighCoefficient\n\n\n#define Nebula_Quality 20\n#define Nebula_Radius  1.0\n\n\nmat2 rotate(float rad) {\n\treturn mat2(\n\tvec2(cos(rad), -sin(rad)),\n\tvec2(sin(rad),  cos(rad))\n\t);\n}\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract(dot(a, vec2(0.5, a.y * 0.75)));\n}\n\nfloat bayer4(vec2 a)   { return bayer2( 0.5  *a) * 0.25     + bayer2(a); }\nfloat bayer8(vec2 a)   { return bayer4( 0.5  *a) * 0.25     + bayer2(a); }\nfloat bayer16(vec2 a)  { return bayer4( 0.25 *a) * 0.0625   + bayer4(a); }\nfloat bayer32(vec2 a)  { return bayer8( 0.25 *a) * 0.0625   + bayer4(a); }\nfloat bayer64(vec2 a)  { return bayer8( 0.125*a) * 0.015625 + bayer8(a); }\nfloat bayer128(vec2 a) { return bayer16(0.125*a) * 0.015625 + bayer8(a); }\n\nfloat Get3DNoise(vec3 pos) { // True 3D\n    pos = pos * noiseResInverse;\n    \n    return texture(iChannel0, pos).x;\n}\n\nbool raySphereIntersect(vec3 rayDirection, vec3 sphere, float radius, out vec2 hit) {\n\thit = vec2(0.0);\n    \n\tfloat b = dot(sphere, rayDirection);\n\tfloat c = dot(sphere, sphere) - radius * radius;\n\t\n\tfloat d = b * b - c;\n\n    //if (dot(rayDirection, normalize(sphere)) > 1.0) return false;\n\n\tif (d < 0.0) {\n        return false;\n\t}\n    \n\td = sqrt(d);\n\t\n\thit = vec2(-b - d, -b + d);\n    return true;\n}\n\n\nfloat hgPhase(float RoL, float g) {\n\treturn (1.0 / (4.0 * PI)) * ((1.0 - g*g) / pow(1.0 + g*g - 2.0 * g * RoL, 1.5));\n}\n\nfloat nebulaFBM(vec3 position) {\n    position *= 1.0;\n    position += 6.0;\n\n    float coverage = 0.22;\n\n    float noise = 0.0;\n    float a = 1.0;\n\n    mat2 rotMat = rotate(0.8);\n\n    for (int i = 0; i < 4; i ++) {\n        noise       += texture(iChannel0, position * noiseResInverse).x * a;\n        position.xy *= rotMat;\n        position.yz *= rotMat;\n        position    *= 3.5;\n        a           *= 0.4;\n    }\n\n    noise *= 0.25;\n    noise  = max(noise - coverage, 0.0) * 200000000.0 + 50000.0;\n\n    return noise;\n}\n\nfloat getNebulaVolume(vec3 ray, float distFromCenter) {\n    ray.xy = (ray.xy - vec2(0.0, 1.0)) * rotate(iTime * 0.1) + vec2(0.0, 1.0);\n    \n    float gradient     = smoothstep(1.0, 0.0, distFromCenter / Nebula_Radius);\n\n    float opticalDepth = nebulaFBM(ray) * gradient;\n\n    return opticalDepth;\n}\n\nvec3 calculateStarlightVisibility(vec3 ray, const vec4 nebula, float startingOpticalDepth, float distFromCenter) {\n    const int   samples  = 15;\n          float stepSize = (nebula.a * 2.0) / float(samples);\n   \t\n    float dirSwitch = -1.0;\n    if (ray.y > nebula.y) dirSwitch = 1.0;\n\n    vec3 centralRay   = ray - nebula.xyz; //centralize ray on star\n    vec3 rayDirection = -normalize(centralRay) * stepSize;\n         ray         += rayDirection * 0.5;\n\n    float opticalDepth = -startingOpticalDepth;\n\n    for (int i = 0; i < samples; i++, ray += rayDirection) {\n        opticalDepth -= getNebulaVolume(ray, distFromCenter);\n    }\n    \n    return exp(nebulaCoeff * stepSize * opticalDepth);\n}\n\nvoid renderNebula(inout vec3 color, in vec3 worldSpace, in float dither) {\n    const vec3  starColor  = vec3(0.5, 0.7, 1.0) * 1.0;\n    const float starRadius = 0.015;\n    \n\tconst vec3 a = -nebulaCoeff / log(2.0);\n\tconst vec3 b = -1.0 / nebulaCoeff;\n\tconst vec3 c =  1.0 / nebulaCoeff;\n\n    const vec3  nebulaCenter   = normalize(vec3(0.0, 1.0, 0.0));\n    const float nebulaDiameter = Nebula_Radius * 2.0;\n    const float nebulaScale    = 1.0;\n    \n    vec2 depths;\n    bool intersected   = raySphereIntersect(worldSpace, nebulaCenter, Nebula_Radius, depths);\n    //     depths = max(depths, 0.0);\n    \n    if (!intersected) return;\n\n    float stepSize = (depths.y - depths.x) / float(Nebula_Quality);\n\n    vec3  rayOrigin    = worldSpace * max(1.0 - Nebula_Radius, 0.0);\n    vec3  rayIncrement = worldSpace * stepSize;\n\n    vec3  ray          = rayOrigin + rayIncrement * dither;\n\n    float phase        = hgPhase(dot(nebulaCenter, worldSpace), 0.85) * PI;\n    vec3  scatter      = vec3(0.0);\n    vec3  transmission = vec3(1.0);\n\n    for (int i = 0; i < Nebula_Quality; i++, ray += rayIncrement) {\n        float distFromCenter = distance(ray, nebulaCenter);\n\n        float lightFalloff   = inversesqrt(0.1 + distFromCenter * nebulaScale);\n        \n        if (distFromCenter > Nebula_Radius) continue;\n\n        if (distFromCenter < starRadius) {\n            color = starColor;\n            break;\n        }\n\n        float opticalDepth   = getNebulaVolume(ray, distFromCenter) * stepSize;\n\n        if (opticalDepth <= 0.0) continue;\n\n        vec3  nebulaLighting = calculateStarlightVisibility(ray, vec4(nebulaCenter, Nebula_Radius), opticalDepth, distFromCenter) * lightFalloff * starColor * phase * nebulaCoeff;\n\n        scatter      += nebulaLighting * (exp2(a * opticalDepth) * b + c) * transmission;\n        transmission *= exp(-nebulaCoeff * opticalDepth);\n    }\n\n    color = color * transmission + scatter;\n}\n\nvoid reinhardTonemap(inout vec3 color) {\n\n    color *= 8.0;\n\n    //color  = max0(color - 0.005);\n    color  = color / (1.0 + color) * 1.08;\n    \n    float luminance = dot(color, vec3(0.2125, 0.7154, 0.0721));\n    color = mix(vec3(luminance), color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv.x, 1.0, uv.y));\n    \n    float dither = bayer128(gl_FragCoord.xy);\n    \n\tfragColor = vec4(vec3(0.0),1.0);\n    renderNebula(fragColor.xyz, rayDirection, dither);\n    reinhardTonemap(fragColor.xyz);\n}","name":"Image","description":"","type":"image"}]}