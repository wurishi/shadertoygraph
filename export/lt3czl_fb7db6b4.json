{"ver":"0.1","info":{"id":"lt3czl","date":"1533766274","viewed":117,"name":"Iterative Histogram 2D","username":"nalivai","description":"The smiley XY coordinates are saved in RG channels.\nB channel is set to something small like 0.001.\nThe fragments are sorted and if RG values of a pair of fragments are equal they are merged.\nB channel of the new fragment is the sum of old B channels.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["iteratrive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 frag = texture(iChannel0,uv);\n    frag.rg = frag.rg*frag.rg*(iMouse.z>0.0 ? 0.0 : 1.0);\n    frag.b = iMouse.z>0.0 ? sqrt(sqrt(sqrt(frag.b))) : frag.b;\n    fragColor = frag;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n#define C 0.1\n#define ESIZE 0.075\n#define EDIST 0.15\n#define FSIZE 0.9\n\n//pseudo random\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame<2)\n    {\n    float Ri = sqrt(rand(uv*PI));\n    float Re = sqrt(0.5+0.5*rand(uv*PI));\n    float Rf = sqrt(0.9+0.1*rand(uv*PI));\n    float rat = iResolution.y/iResolution.x;\n    float phi = 2.0*PI*rand(uv+iMouse.xy*0.1);\n        \n    //SMILE\n    float X = 0.5+0.5*Ri*sin(phi)*(1.0-C)*0.5*rat;\n    float Y = 0.5+0.5*Ri*cos(phi)*C+1.5*C*cos(2.0*X*PI)-C;\n\tfloat ch = rand(uv*PI*1.01);\n    //NOSE\n    if(ch>0.7)\n    {\n    X = 0.5+0.5*Re*sin(phi)*C*rat;\n    Y = 0.5+0.5*Re*cos(phi)*C; \n    }\n    //EYES\n    if(ch>0.8)\n    {\n    X = 0.5+0.5*Re*sin(phi)*ESIZE*rat-EDIST*rat;\n    Y = 0.75+0.5*Re*cos(phi)*ESIZE; \n    }\n    if(ch>0.85)\n    {\n    X = 0.5+0.5*Re*sin(phi)*ESIZE*rat+EDIST*rat;\n    Y = 0.75+0.5*Re*cos(phi)*ESIZE; \n    }\n    //FACE\n    if(ch>0.9)\n    {\n    X = 0.5+0.5*Rf*sin(phi)*FSIZE*rat;\n    Y = 0.5+0.5*Rf*cos(phi)*FSIZE; \n    }\n  \n    fragColor = vec4(X,Y,0.0001,1.0);\n    }\n    else\n    {\n    fragColor = texture(iChannel0,uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define T(U) texture(iChannel0,uv+(U))\n\n/*\nV 0.1 (acceleration necessary)\nThe smiley XY coordinates are saved in RG channels.\nB channel is set to something small like 0.001.\nThe fragments are sorted and if RG values of a pair of fragments are equal they are merged.\nB channel of the new fragment is the sum of old B channels.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 FC = floor(fragCoord);\n    vec2 W = iResolution.xy;\n    float WX = iResolution.x;\n    float WY = iResolution.y;\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 center = texture(iChannel0,uv);\n    vec2 dx = vec2(texel.x,0.0);\n    vec2 dy = vec2(0.0,texel.y);\n    vec4 dxp = T(dx);\n    vec4 dxm = T(-dx);\n    vec4 dyp = T(+dy);\n    vec4 dym = T(-dy);\n    float swap = 1.0;\n    float sxm = 1.0;//floor(dxm.r*WX)>fragCoord.x-1.0 ? 1.0 : -1.0;\n    float sxp = 1.0;//floor(center.r*WX)>fragCoord.x ? 1.0 : -1.0;\n    float sym = 1.0;//floor(dym.g*WY)>fragCoord.y-1.0 ? 1.0 : -1.0;\n    float syp = 1.0;//floor(center.g*WY)>fragCoord.y ? 1.0 : -1.0;\n    bool v16v8 = iFrame%16 == iFrame%8 || true;\n    bool v31v8 = iFrame%31 == iFrame%8;\n    float m = 1.0;\n    if(iFrame%8<4)\n    {\n        // X sorting\n    if((iFrame + int(fragCoord.x))%4==0 && int(fragCoord.x)!=int(WX)-1)\n    {\n    if(floor(dxp.rg*W) == floor(center.rg*W) && center.b!=0.0 && dxp.b!=0.0)\n    { \n     if(sxp>0.0)\n     {\n       center *= 0.0; \n     }\n        else\n        {\n        center.b+=dxp.b;\n        }\n\n    };\n        \n    }\n    else if((iFrame + int(fragCoord.x))%4==1 && int(fragCoord.x)!=0)\n    {\n    if(floor(dxm.rg*W) == floor(center.rg*W) && center.b!=0.0 && dxm.b!=0.0)\n    {\n     if(sxm>0.0)\n     {\n    center.b += dxm.b;\n     }\n        else\n        {\n        center*=0.0;\n        }\n\n    };\n    }\n    else if((iFrame + int(fragCoord.x))%4==2 && int(fragCoord.x)!=int(WX)-1)\n    {\n        if((floor(dxp.r*WX)<FC.x+1.0 && floor(center.r*WX)>FC.x)\n          || (floor(dxp.r*WX)<floor(center.r*WX) && dxp.b!=0.0)\n          || (center.b==0.0 && floor(dxp.r*WX)<=FC.x+1.0))\n          \n           {\n           center=dxp;\n           }\n\n    }\n    else if((iFrame + int(fragCoord.x))%4==3 && int(fragCoord.x)!=0)\n           {\n        if((floor(dxm.r*WX)>FC.x-1.0 && floor(center.r*WX)<FC.x)\n          || (floor(dxm.r*WX)>floor(center.r*WX) && center.b!=0.0) \n          || (dxm.b==0.0 && floor(center.r*WX)<=FC.x))\n           {\n           center=dxm;\n           }\n           }\n    }\n    else\n    {\t//Y sorting\n    if((iFrame + int(fragCoord.y))%4==0 && int(fragCoord.y)!=int(WY)-1)\n    {\n    if(floor(dyp.rg*W) == floor(center.rg*W))\n    {\n     if(syp>0.0)\n     {\n       center *= 0.0; \n     }\n        else\n        {\n        center.b+=dyp.b;\n        }\n\n     }\n    }\n    else if ((iFrame + int(fragCoord.y))%4==1 && int(fragCoord.y)!=0)\n    {\n    if(floor(dym.rg*W) == floor(center.rg*W))\n    {\n                     if(sym>0.0)\n     {\n    center.b += dym.b;\n     }\n        else\n        {\n        center*=0.0;\n        }\n    }\n    }\n    else if ((iFrame + int(fragCoord.y))%4==2 && int(fragCoord.y)!=int(WY)-1)\n    {\n        if((floor(dyp.g*WY) < FC.y+1.0 && floor(center.g*WY) > FC.y) ||\n          (floor(dyp.g*WY)<floor(center.g*WY) && dyp.b!=0.0) ||\n          (center.b==0.0 && floor(dyp.g*WY)< FC.y+1.0))\n           {\n           center=dyp;\n           }\n\n    }\n    else if((iFrame + int(fragCoord.y))%4==3 && int(fragCoord.y)!=0)\n    {\n        if((floor(dym.g*WY) > FC.y-1.0 && floor(center.g*WY) < FC.y) ||\n          (floor(dym.g*WY)>floor(center.g*WY) && center.b!=0.0) ||\n          (dym.b==0.0 && floor(center.g*WY) < FC.y ))\n          \n           {\n           center=dym;\n           }\n\n    }\n        // Y sum\n        \n    };\n    fragColor = center;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 frag = texture(iChannel0,uv);\n    vec4 frag2 = texture(iChannel1,uv);\n    fragColor = frag*0.9 + frag2*0.1;\n}","name":"Buffer C","description":"","type":"buffer"}]}