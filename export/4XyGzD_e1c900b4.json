{"ver":"0.1","info":{"id":"4XyGzD","date":"1717343360","viewed":120,"name":"Shaded Heightmap Island","username":"dangerdave","description":"[Control the light direction by dragging your mouse!]\n\nThis shader uses various noise textures to create an island. Some additional effects like subtle ocean waves, underwater terrain and raytraced shadows are employed to make it look kinda nice.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","terrain","heightmap","island"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Made by David Holzapfel (dangerdave)\n * \n * Inspired by a series of videos by https://www.youtube.com/@BarneyCodes,\n * specifically this video: https://www.youtube.com/watch?v=fZh2p0odPyQ\n *\n * Note: you might see blinking seams moving along with the clouds. To get rid of\n *   these, disable the clouds feature by commenting out the '#define ENABLE_CLOUDS'\n *   below.\n *\n * Control the sunlight direction by dragging your mouse on the shader.\n * Many options and features can be configured by adjusting the constants and #defines\n * right below, I encourage you to play with these values :)\n */\n\n// Terrain colors\nconst vec4 uColWater = vec4(40.0, 157.0, 166.0, 255.0) / 255.0;\nconst vec4 uColSand = vec4(196.0, 199.0, 109.0, 255.0) / 255.0;\nconst vec4 uColGrass1 = vec4(120.0, 199.0, 90.0, 255.0) / 255.0;\nconst vec4 uColGrass2 = vec4(52.0, 97.0, 45.0, 255.0) / 255.0;\nconst vec4 uColMountain = vec4(110.0, 112.0, 103.0, 255.0) / 255.0;\nconst vec4 uColSnow = vec4(207.0, 224.0, 227.0, 255.0) * 0.9 / 255.0;\n\n// Other colors\nconst vec4 uWavePeakColor = vec4(208.0, 242.0, 245.0, 255.0) / 255.0;\n\n// Comment out these defines to disable specific features of the shader\n#define ENABLE_SHADOWS\n#define ENABLE_WAVES\n#define ENABLE_SHORE_WAVES\n#define ENABLE_CLOUDS\n#define ENABLE_EDGE_FALLOFF\n#define ENABLE_TERRAIN_COLORS\n\n#define ENABLE_SOFT_SHADOWS\n#define ENABLE_GAUSSIAN_BLUR_FOR_SHADOWS\n\n// Configure terrain\n#define TERRAIN_NOISE_SCALE 0.35\n#define TERRAIN_NOISE_OFFSET vec2(0.3, -0.08)\n#define TERRAIN_NOISE_BIAS 0.0\n#define TERRAIN_NOISE_AMPLITUDE 1.0\n#define TERRAIN_MIN_HEIGHT -0.1\n\n#define ASPECT_RATIO_AWARE_FALLOFF\n\n// Configure clouds\n#define CLOUDS_MAX_INTENSITY 0.5\n#define CLOUDS_SCALE 0.15\n\n// Configure waves\n#define SHORE_WAVE_RANGE 0.05\n#define MIN_SHORE_WAVE_STRENGTH 0.15\n\n// Wind direction is used by waves and clouds\n#define WIND_DIRECTION vec2(0.447, 0.894)\n\n// These values define which heightmap levels correspond to which terrain color\n#define WATER_LEVEL    0.07195\n#define BEACH_LEVEL    0.17\n#define GRASS_LEVEL_1  0.26\n#define GRASS_LEVEL_2  0.42\n#define MOUNTAIN_LEVEL 0.75\n\n// Map logical textures to Shadertoy's texture channels\n#define uHeightmap iChannel0\n#define uTerrainGrain iChannel1\n#define uWavemap iChannel2\n#define uClouds iChannel2\n#define uCloudsMask iChannel3\n#define uShoreWaveOffset iChannel0\n\n// These defines allow for a manual application of a blur kernel, because \n// I suck at matrices\n#define BLUR_KERNEL_OFFSET 0.0025\n#define BLUR_COMP(uv, xoff, yoff, weight) (weight * light(vec2(uv.x + xoff * BLUR_KERNEL_OFFSET, uv.y + yoff * BLUR_KERNEL_OFFSET)))\n\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n\n// Determine global light direction, controlled by mouse input\nvec3 sunDir() {\n    return normalize(vec3(iResolution.xy / 2.0 - iMouse.xy, -50.0));\n}\n\n// Wrap given coordinates to the 0.0 to 1.0 range\nvec2 uvWrap(vec2 uv) {\n    return vec2(fract(uv.x), fract(uv.y));\n}\n\n// Return falloff factor to flatten out terrain the further you sample from the center\nfloat falloff(vec2 p) {\n    #ifndef ENABLE_EDGE_FALLOFF\n        return 1.0;\n    #else\n        const vec2 center = vec2(0.5);\n\n        float dx = center.x - p.x;\n        float dy = center.y - p.y;\n        \n        #ifdef ASPECT_RATIO_AWARE_FALLOFF\n        dx = dx / ASPECT_RATIO;\n        #endif\n        \n        float d = sqrt(dx * dx + dy * dy);\n\n\n        float falloffByDistance = smoothstep(1.0, -0.15, d / 0.5);\n        return clamp(falloffByDistance, 0.0, 1.0);\n    #endif\n}\n\n// Get the heightmap value at that point, modified by a distance falloff factor\nfloat height(vec2 p) {\n    float noiseValue = texture(uHeightmap, TERRAIN_NOISE_OFFSET + p * TERRAIN_NOISE_SCALE).x;\n    noiseValue *= 12.0 * noiseValue * noiseValue * noiseValue;\n    noiseValue = mix(TERRAIN_MIN_HEIGHT, 1.0, noiseValue);\n    \n    noiseValue = (TERRAIN_NOISE_BIAS + noiseValue * TERRAIN_NOISE_AMPLITUDE);\n    if (noiseValue > 0.0)\n        return noiseValue * falloff(p);\n    return noiseValue;\n}\n\n// Calculate local gradient, i.e. direction of steepest ascend\nvec2 grad(vec2 p) {\n    const float GRAD_SAMPLE_DELTA = 0.005;\n    \n    float dhx = height(vec2(p.x + GRAD_SAMPLE_DELTA, p.y)) \n        - height(vec2(p.x - GRAD_SAMPLE_DELTA, p.y));\n    float dhy = height(vec2(p.x, p.y + GRAD_SAMPLE_DELTA)) \n        - height(vec2(p.x, p.y - GRAD_SAMPLE_DELTA));\n    return normalize(vec2(dhx, dhy));\n}\n\n// Calculate normal vector at given position\nvec3 normal(vec2 p) {\n    const float NORMAL_SAMPLE_DELTA = 0.005;\n    vec2 sx1 = vec2(p.x - NORMAL_SAMPLE_DELTA, p.y);\n    vec2 sx2 = vec2(p.x + NORMAL_SAMPLE_DELTA, p.y);\n    vec2 sy1 = vec2(p.x, p.y - NORMAL_SAMPLE_DELTA);\n    vec2 sy2 = vec2(p.x, p.y + NORMAL_SAMPLE_DELTA);\n    vec3 px1 = vec3(sx1, height(sx1));\n    vec3 px2 = vec3(sx2, height(sx2));\n    vec3 py1 = vec3(sy1, height(sy1));\n    vec3 py2 = vec3(sy2, height(sy2));\n    \n    return normalize(cross(px2 - px1, py2 - py1));\n}\n\n// Calculate water color at given point.\n// Additionaly query two samples of the wave texture in iChannel2 moving in different\n// directions to simulate surface waves\nvec4 water(vec2 p) {\n    #ifndef ENABLE_WAVES\n        return uColWater;\n    #else\n        vec4 wColor = uColWater;\n        const float wavespeed = 0.005;\n        vec2 sampleP = p + vec2(wavespeed, wavespeed * 2.0) * iTime;\n        float w1 = texture(uWavemap, sampleP).x;\n        w1 = mix(0.9, 1.0, w1);\n\n        sampleP = p.yx + vec2(-wavespeed * 1.5, wavespeed) * iTime;\n        float w2 = texture(uWavemap, sampleP).x;\n        w2 = mix(0.9, 1.0, w2);\n\n        float w = min(w1, w2);\n        \n        wColor = wColor * w;\n        \n        #ifdef ENABLE_SHORE_WAVES\n            float d = (WATER_LEVEL - height(p)) / SHORE_WAVE_RANGE;\n            float randomOffset = texture(uShoreWaveOffset, p).x * 5.;\n            float wave = 0.7 + 0.3 * sin(randomOffset + d * 7.0 + 1. * iTime);\n\n            float d2 = (2.0 * d - 1.0);\n            float shoreClosenessFactor = (1.0 - d2 * d2) * clamp(1.0 - d, 0.0, 1.0);\n            \n            float windAlignFactor = max(0.0, dot(-grad(p), WIND_DIRECTION));\n            windAlignFactor = mix(MIN_SHORE_WAVE_STRENGTH, 1.0, windAlignFactor);\n\n            float waveFactor = min(shoreClosenessFactor, windAlignFactor);\n            wColor = mix(wColor, uWavePeakColor, wave * waveFactor);\n        #endif\n\n        return wColor;\n    #endif\n}\n\n// Calculate clouds. Works similarly to waves in that a texture is sampled twice\n// with different movement directions, but instead of directly layering them we\n// take a blend between the two weighted by a time-periodic factor\nfloat clouds(vec2 uv) {\n    #ifndef ENABLE_CLOUDS\n        return 0.0;\n    #else\n        const vec2 moveDir = WIND_DIRECTION * 0.045;\n        const vec2 maskMoveDir = vec2(-2.0, 0.5) * 0.02;\n\n        vec2 sampleP = (uv + moveDir * iTime) * CLOUDS_SCALE;\n        float cloud1 = texture(uClouds, sampleP).x;\n\n        sampleP = (uv + moveDir * iTime + vec2(0.4, -1.0) * 0.02 * iTime) * CLOUDS_SCALE;\n        float cloud2 = texture(uClouds, sampleP).x;\n\n        float mixFactor =  2.0 * sin(iTime * 0.05) * cos(iTime * 0.15) + 1.0;\n        float cloud = mix(cloud1, cloud2, mixFactor);\n\n        cloud *= 1.2;\n        \n        sampleP = (uv + maskMoveDir * iTime) * CLOUDS_SCALE;\n        float cloudMask = texture(uCloudsMask, sampleP).x;\n        \n        cloud *= cloudMask;\n\n        return mix(0.0, CLOUDS_MAX_INTENSITY, clamp(cloud * cloud, 0.0, 1.0));\n    #endif\n}\n\n// Returns the light level at a given terrain position by raytracing towards the global\n// light direction, with a value lower than 1.0 being return when the ray hits terrain\n// before reaching the sky\nfloat light(vec2 p) {\n    const float FULL_LIGHT = 1.0;\n    const float SHADOW = 0.65;\n    const float WEAK_SHADOW = 0.85;\n\n    const float MAX_PATH_LENGTH_FOR_WEAK_SHADOW = 0.3;\n\n    vec3 origin = vec3(p.x, p.y, height(p) + 0.01);\n    vec3 curr = origin;\n\n    vec3 traceDir = -normalize(sunDir());\n\n    const float _ceiling = 1.1;\n    const float minStep = 0.0002;\n    const int maxStepCount = 500;\n\n    for (int i = 0; i < maxStepCount; i++) {\n        float currHeight = height(curr.xy);\n\n        if (curr.z < currHeight) {\n            #ifdef ENABLE_SOFT_SHADOWS\n            float pathLength = length(origin - curr);\n            float t = clamp(pathLength / MAX_PATH_LENGTH_FOR_WEAK_SHADOW, 0.0, 1.0);\n            return mix(SHADOW, WEAK_SHADOW, t);\n            #else\n            return SHADOW;\n            #endif\n        }\n\n        if (curr.z >= _ceiling)\n            return FULL_LIGHT;\n\n        float deltaHeight = abs(currHeight - curr.z);\n        float step = max(minStep, deltaHeight / 3.0);\n\n        curr = curr + traceDir * step;\n    }\n\n    return FULL_LIGHT;\n}\n\n// This returns a sort of ambient light based on the terrain normal and the global light\n// direction for additional detail in the terrain\nfloat normalLight(vec2 p) {\n    const float FULL_LIGHT = 1.0;\n    const float SHADOW = 0.9;\n\n    vec3 n = normal(p);\n\n    float lightness = dot(-normalize(sunDir()), n);\n\n    return mix(SHADOW, FULL_LIGHT, lightness);\n}\n\n// This function is given a color value and a light direction and modulates the color\n// based on that. Currently the only point of this function is to tint the light color\n// towards red the flatter the global light vector is (i.e. everything is more red when\n// the sun is setting / rising)\nvec4 lightModulate(vec4 l) {\n    vec3 xyFlattened = normalize(vec3(sunDir().xy, 0.0));\n    float lightFlatness = abs(dot(xyFlattened, sunDir()));\n    lightFlatness = smoothstep(0.7, 1.3, lightFlatness);\n    l.r = mix(l.r, max(l.r, 0.7), lightFlatness);\n    return l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // This section maps the fragCoord to a square of normalized 0.0 to 1.0 values for\n    // both x and y. This makes it resolution independent and also centers the island\n    //fragCoord = (fragCoord.xy / 9.0 - vec2(-200., -200.));\n    float xOffset = (ASPECT_RATIO - 1.0) / 2.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x = uv.x * ASPECT_RATIO - xOffset;\n    \n    float h = height(uv);\n    // We modifiy the sampled terrain height with an additional noise map to introduce\n    // more detail in the terrain colors, leading to a nice dithering effect.\n    // This modification is only applied to the color banding, this prevents shadows\n    // from becoming too noisy\n    float biomeH = h + texture(uTerrainGrain, uvWrap(uv * 10.0)).x * 0.09;\n\n    #ifdef ENABLE_TERRAIN_COLORS\n        // Progressively set the target terrain color based on the sampled height value\n        // These defines are used to keep this section clean and readable, but this might\n        // be changed at some point since it's not really intuitive\n        fragColor = uColSnow;\n        if (biomeH < MOUNTAIN_LEVEL) { fragColor = uColMountain; }\n        if (biomeH < GRASS_LEVEL_2) { fragColor = uColGrass2; }\n        if (biomeH < GRASS_LEVEL_1) { fragColor = uColGrass1; }\n        if (biomeH < BEACH_LEVEL) { fragColor = uColSand; }\n        if (biomeH < WATER_LEVEL) { fragColor = uColWater; }\n\n        // If we are underwater, tint the terrain color towards the water color\n        if (h < WATER_LEVEL) {\n            vec4 waterCol = water(uv);\n            // The higher this value is the more actual terrain is coming through\n            float subsurfaceness = h / (2.2 * WATER_LEVEL);\n            vec4 blueTint = vec4(waterCol.xyz, 0.0) * 0.33;\n            fragColor = mix(waterCol, uColSand + blueTint, subsurfaceness);\n        }\n    #else\n        fragColor = vec4(h, h, h, 1.0);\n    #endif\n    \n    #ifdef ENABLE_SHADOWS\n        // Get normal light\n        float normLight = normalLight(uv);\n\n        // Calculate sun light, either by sampling once or multiple times with gaussian blur,\n        // depending on settings\n        float sunLight = 0.0;    \n\n        #ifdef ENABLE_GAUSSIAN_BLUR_FOR_SHADOWS\n            sunLight += BLUR_COMP(uv, -1.0, -1.0, 1.0 / 16.0);\n            sunLight += BLUR_COMP(uv,  0.0, -1.0, 1.0 /  8.0);\n            sunLight += BLUR_COMP(uv,  1.0, -1.0, 1.0 / 16.0);\n            sunLight += BLUR_COMP(uv, -1.0,  0.0, 1.0 /  8.0);\n            sunLight += BLUR_COMP(uv,  0.0,  0.0, 1.0 /  4.0);\n            sunLight += BLUR_COMP(uv,  1.0,  0.0, 1.0 /  8.0);\n            sunLight += BLUR_COMP(uv, -1.0,  1.0, 1.0 / 16.0);\n            sunLight += BLUR_COMP(uv,  0.0,  1.0, 1.0 /  8.0);\n            sunLight += BLUR_COMP(uv,  1.0,  1.0, 1.0 / 16.0);\n        #else\n            sunLight = light(uv);\n        #endif\n\n        // Get the final light as the geometric mean of normal and sun light\n        // This is not based on some kind of physics at all, I just like the way it works out\n        float totalLight = sqrt(normLight * sunLight);\n\n        if (h < WATER_LEVEL) {\n            float diff = abs(h - WATER_LEVEL);\n            totalLight = clamp(totalLight += diff * 3.0 ,0.0, 1.0);\n        }\n\n        // Modulate the terrain color via the light direction and determine intensity\n        // by final light level\n        fragColor = lightModulate(fragColor) * totalLight;\n    #endif\n\n    // Mix the final color towards white based on local cloud density\n    float cloud = clouds(uv);\n    fragColor = mix(fragColor, vec4(1.0), cloud);\n}","name":"Image","description":"","type":"image"}]}