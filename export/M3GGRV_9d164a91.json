{"ver":"0.1","info":{"id":"M3GGRV","date":"1717889063","viewed":97,"name":"Mandelbrot Tunnel Explosion","username":"shlick","description":"Mandel Tunnel Explosion","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","explosion","loop","trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set the resolution and center of the Mandelbrot\n    vec2 resolution = iResolution.xy;\n    \n    // Set the zoom level\n    float baseZoom = 250.;\n    \n    // Normalize the fragment coordinates and center the Mandelbrot set\n    vec2 uv = (fragCoord - resolution * 0.5) / resolution.y;\n    \n    // Define rainbow colors\n    vec3 rainbowColors[7];\n    rainbowColors[0] = vec3(1.0, 0.0, 0.0); // Red\n    rainbowColors[1] = vec3(1.0, 0.5, 0.0); // Orange\n    rainbowColors[2] = vec3(1.0, 1.0, 0.0); // Yellow\n    rainbowColors[3] = vec3(0.0, 1.0, 0.0); // Green\n    rainbowColors[4] = vec3(0.0, 0.0, 1.25); // Blue\n    rainbowColors[5] = vec3(0.29, 0.0, 0.51)*1.5; // Indigo\n    rainbowColors[6] = vec3(0.56, 0.0, 1.0)*1.0; // Violet\n\n    // Define the gradient colors\n    vec3 gradientStart = vec3(0.0);\n    vec3 gradientEnd = vec3(1.0);\n    float loopSpeed = 4.;\n\n    // Calculate the angle step between each Mandelbrot set\n    float angleStep = radians(360.0 / 7.0);\n    \n    // Set the base radius from the center for each Mandelbrot set\n    float baseRadius = 0.01; // Base radius\n    \n    // Initialize the final color\n    vec3 finalColor = vec3(0.0);\n    \n    // Initialize Fibonacci sequence variables\n    float fib1 = 1.0;\n    float fib2 = 1.0;\n    \n    // Define the number of iterations for the spiral\n    int spiralIterations = 12;\n    \n    // Loop over each Mandelbrot set in the spiral\n\n    for(int k = 0; k < spiralIterations; k++) {\n        for(int j = 0; j < 7; j++) {\n            // Parameters for the current Mandelbrot set\n            float angle = float(j) * angleStep - 1.57079632679;\n            mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n            vec2 offset = vec2(cos(angle), sin(angle)) * baseRadius;\n            vec2 rotatedUV = rotation * (uv - offset);\n            vec2 c = rotatedUV * baseZoom - vec2(0.5, 0.0);\n            vec2 z = vec2(0.0, 0.0);\n            int maxIterations = int(30.*1.5/(sqrt(baseZoom + 1.)));\n            if(maxIterations > 20){\n                maxIterations = 20;\n            } else if(maxIterations <= 0){\n                maxIterations = 0;\n            }\n            \n            int iterations = 0;\n            \n            // Mandelbrot iteration for the current set\n            if(baseZoom > 0.2){\n                if(baseZoom > 1000.){\n                    break;\n                }\n                for(int i = 0; i < maxIterations; i++) {\n                    float x = (z.x * z.x - z.y * z.y) + c.x;\n                    float y = (z.y * z.x + z.x * z.y) + c.y;\n\n                    z = vec2(x, y);\n\n                    if(dot(z, z) > 4.0) break;\n\n                    iterations++;\n                }\n\n                // Get the edge color for the current Mandelbrot set\n                vec3 edgeColor = rainbowColors[j];\n                gradientStart = edgeColor;\n\n                // Calculate the brightness based on the distance to the center\n                float distanceToCenter = length(uv);\n                float brightness = 1.0 - distanceToCenter;\n\n                // Calculate the gradient based on the distance to the center\n                vec3 gradientColor = mix(gradientEnd, gradientStart, brightness);\n\n                // Color the pixel based on the iterations\n                vec3 color;\n                if(iterations == maxIterations) {\n                    color = vec3(0.0); // Inside Mandelbrot set\n                } else {\n                    color = edgeColor * (float(iterations) / float(maxIterations));\n                }\n                // Apply the gradient color\n                color *= gradientColor;\n\n                // Accumulate the color\n                finalColor += color;\n            } else {\n                break;\n            }\n\n            // Update radius and zoom based on Fibonacci sequence\n            float nextFib = fib1 + fib2;\n            fib1 = fib2;\n            fib2 = nextFib;\n            // Change to control speed of zoom and radius increase\n            //baseRadius += (baseRadius/baseZoom) * 1. ;\n            //baseZoom *= sqrt(0.025*((iTime)+1.));\n            //baseZoom *= 500.*(sin(sqrt(0.025*((iTime)+1.) + 1.)));\n            baseZoom *= 0.825*(sqrt(0.5*cos(iTime/loopSpeed) + 1.0));\n        }\n        \n        \n    }\n    \n    // Output the final color\n    fragColor = vec4(1. - exp2( -finalColor ), 1.0)*1.5;\n}\n","name":"Image","description":"","type":"image"}]}