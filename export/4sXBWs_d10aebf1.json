{"ver":"0.1","info":{"id":"4sXBWs","date":"1498692621","viewed":662,"name":"Tusi-Couple","username":"unbird","description":"Special case of a so-called hypotrochoid (inner circle has half the radius of the outer one) called a Tusi-couple:\nhttps://en.wikipedia.org/wiki/Tusi_couple.\n\nUpdate 3: Configurable 2nd point, ellipse path now derived. Todo: Select point with mouse","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","animation","gear","trochoid","tusi","hypotrochoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Tusi-couple\n\n\tUsing basic sdf shapes to render gear animation\n*/\n\n// Parameters\n\n// 2nd Tusi position (relative to the inner wheel). Set 0 to disable\n\nconst vec2 relativePos = vec2(0.5, -1.7);\n\n#define SHOWAXIS false\n\n// constants\n#define M_PI 3.1415926535897932384626433832795\n\nconst vec4 Red = vec4(1,0,0,1);\nconst vec4 LightRed = vec4(1,0.8,0.8,1);\nconst vec4 Yellow = vec4(1,1,0,1);\nconst vec4 Green = vec4(0,1,0,1);\nconst vec4 LightGreen = vec4(0.8,1.0,0.8,1);\nconst vec4 Blue = vec4(0,0,1,1);\nconst vec4 LightBlue = vec4(0.8,0.8,1,1);\nconst vec4 White = vec4(1,1,1,1);\nconst vec4 Gray = vec4(0.5,0.5,0.5,1);\nconst vec4 Black = vec4(0,0,0,1);\nconst vec4 TransparentWhite = vec4(1,1,1,0);\nconst vec4 Brown = vec4(0.8, 0.4, 0.2,1);\n\nvec4 Dark(vec4 color)\n{\n\treturn vec4(color.rgb * 0.7, color.a);\n}\n\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n    float a = min(d1 * sign(d2), d2 * sign(d1));\n    float b = max(d1 * sign(d2), d2 * sign(d1));\n    \n    if (sign(d1) == sign(d2))\n    \treturn a;\n    else\n    \treturn b;\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat signxx(float x)\n{\n    return x > 0.0 ? 1.0 : -1.0;\n}\n\n// --- ellipse\n// Created by Inigo Quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// unbird parameters to change shape\nfloat ellipse(vec2 P, vec2 ab)\n{\n/*\n    // Alternate version (approximation)\n    float a = 1.0;\n    float b = 3.0;\n    float r = 0.9;\n    float f = length( p*vec2(a,b) );\n    f = length( p*vec2(a,b) );\n    f = f*(f-r)/length( p*vec2(a*a,b*b) );\n    return f;\n*/\n\n    //vec2 ab = vec2(size/3.0, size/2.0);\n    vec2 p = abs( P );\n    if( p.x > p.y ){\n        p = p.yx;\n        ab = ab.yx;\n    }\n    // unbird: slight modification to make inverted shape and ellipse line not produce artifacts at main axis\n    if(p.x < 0.0001)\n    {\n        return p.y - ab.y;\n    }\n    // unbird: another edge case. Perfect circles fail (one should use an actual circle). \n    if(abs(ab.x - ab.y) < 0.005)\n        ab.x += 0.005;\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;\n    float n = ab.y*p.y/l;\n    float m2 = m*m;\n    float n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n    float c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if(d < 0.0)\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt(1.0 - co*co);\n    vec2 closestPoint = vec2(ab.x*co, ab.y*si);\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\nfloat ellipseLine(vec2 pos, vec2 ab, float width)\n{\n    return abs(ellipse(pos, ab)) - width;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir) + 0.0001;\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\nfloat ellipseLineSafe(vec2 pos, vec2 ab, float width)    \n{\n    vec2 aab = abs(ab);\n    if(aab.x < 0.1 || aab.y < 0.1)\n    {\n        return lineDist(pos, -ab, ab, width);\n    }\n    return abs(ellipse(pos, ab)) - width;\n}\n\n\nfloat polygon(vec2 p, float radius, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));    \n    \n    // plane equation for border (note half angle otherwise the ends don't match)\n    part *= 0.5;\n    vec2 plane = vec2(cos(part), sin(part));\n    \n\treturn dot(p, plane) - radius;\n}\n\n// get normalized slice of circle\nfloat circleMod(vec2 p, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n\treturn angle / part;\n}\n\n// arbitrary \"polygon\". Has to be used with circleMod and some function which has f'(0) = f'(1), e.g. sin(x*2*pi)\nfloat polyShape(vec2 p, float radius, int n, float offset)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));    \n    \n    // plane equation for border (note half angle otherwise the ends don't match)\n    part *= 0.5;\n    vec2 plane = vec2(cos(part), sin(part));\n    \n\treturn length(p) - radius - offset;\n}\n\nfloat star(vec2 p, float radius, float innerradius, int n)\n{\n    // similar to polygon\n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));            \n    float halfpart = 0.5 * part;\n    \n    // define 3 point of first \"tooth\" of the star\n    vec2 A = vec2(innerradius, 0);\n    vec2 B = vec2(cos(part), sin(part)) * innerradius;\n    vec2 C = vec2(cos(halfpart), sin(halfpart)) * radius;\n    \n    // derive plane equations thereof (normals and offsets)\n    vec2 plane1 = A - C;\n    plane1 = normalize(vec2(-plane1.y, plane1.x));\n    float p1c = dot(C, plane1);\n    \n    vec2 plane2 = C - B;\n    plane2 = normalize(vec2(-plane2.y, plane2.x));\n    float p2c = dot(C, plane2);\n    \n    // combine the planes\n\treturn max(dot(p, plane2) - p2c, dot(p, plane1) - p1c);\n}\n\n\nfloat spikesDist(vec2 p, float radius, int n, float width)\n{\n    // similar to polygon\n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(-cos(angle), sin(angle));            \n    \n    width *= 0.5;\n    \n    float leftspike = abs(p.y) - width;    \n    \n    //part *= 0.5;\n    vec2 normal = vec2(sin(part), cos(part));\n    \n    float rightspike = -dot(p, normal) - width;\n    //return rightspike;      \n    //return leftspike;      \n    \n    return max(min(leftspike, rightspike), circleDist(p, radius));\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\tdist -= width * 0.5;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\tdist -= 5.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\nvec2 lissajous(float x, float alpha, float phase)\n{\n    return vec2(sin(alpha*x + phase), cos(x));\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvoid blend(inout vec4 back, float alpha, vec4 color)\n{\n    float a = saturate(alpha);\n    // basic alpha blending\n    color = mix(color, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(alpha, 1.5));\n    back = mix(back, color, (1.0-a) * color.a);\n}\n\nvec2 cis(float alpha)\n{\n    return vec2(cos(alpha), sin(alpha));\n}\n\nfloat radial(vec2 p, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    return abs(angle - part * 0.5) / part / 0.5;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\t\n\tfloat fall = saturate((range - ld)/range);\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (fall + source) * color;\n}\n\n\nfloat bar(vec2 p, vec2 start, vec2 end, float width)\n{\n    return\n        merge(\n        merge(lineDist(p, start, end, width), \n              circleDist(p - start, 1.5 * width)),\n              circleDist(p - end, 1.5 * width));\n}\n\nfloat sceneDist(vec2 p, inout vec4 color)\n{    \n    float time = iTime;\n    \n\tvec2 center = iResolution.xy / 2.0;\n    vec2 amplitudes = center *0.7;\n\n    float maxdim = min(iResolution.x, iResolution.y);\n    float outerradius = maxdim * 0.45;\n    \n    float pointsize = maxdim * 0.007;\n    \n\tint cogn = 64;\n\tvec2 cogp = translate(p, center);\n\tfloat cogx = circleMod(cogp, cogn);    \n\tfloat c1 = -polyShape(cogp, outerradius, cogn, outerradius*0.03*cos(2.0*M_PI*cogx));\n    \n    c1 = intersect(c1, circleDist(cogp, maxdim * 0.5));\n    \n\t//float c1 = -circleDist(\t\ttranslate(p, center), outerradius);\n    float spikes = radial(translate(p, center), 10);\n    blend(color, c1, mix(Gray, Dark(Gray), spikes < 0.5 ? 0.0 : 1.0));        \n    \n    \n    float innerradius = outerradius * 0.5;\n    vec2 wheelpos = cis(time) * (outerradius - innerradius) + center;\n    float wheelratio = outerradius / innerradius;\n    float wheelrotation = time;\n\n\tint cogn2 = cogn / 2;\n\tvec2 cogp2 = rotateCW(translate(p, wheelpos), time);\n\tfloat cogx2 = circleMod(cogp2, cogn2);    \n\tfloat c2 = polyShape(cogp2, innerradius, cogn2, outerradius*0.03*cos(2.0*M_PI*cogx2));    \n    \n    float spikeradius = innerradius * 0.9;\n    float c2Spikes = spikesDist(cogp2, spikeradius, 10, innerradius * 0.1);\n    \n    c2 = merge(mergeExclude(c2, circleDist(cogp2, spikeradius*0.9)), c2Spikes);\n    \n\t//float c2 = circleDist(cogp2, innerradius);\n    float spikes2 = radial(rotateCW(translate(p, wheelpos), time), 5);\n    blend(color, c2, mix(Red, Dark(Red), spikes2 < 0.5 ? 0.0 : 1.0));            \n    \n    float phase = 0.0;\n    vec2 tusipos = wheelpos + cis(-time + phase) * innerradius * 0.6;    \n    \n    float tt = bar(p, wheelpos, tusipos, pointsize*2.0);\n    blend(color, tt, Gray);    \n    \n\tfloat t3 = star(\trotateCW(translate(p, tusipos), time), pointsize*4.0, pointsize*2.0, 12);\n    blend(color, t3, LightRed);    \n    \n    \n    //vec2 ellipseSize = vec2(0.8, 0.1);\n    vec2 ellipseSize = vec2(0.8, 0.2);\n    float ell = ellipseLine( translate(p, center), ellipseSize*outerradius, 3.0);\n    //float ell = -ellipse( translate(p, center), ellipseSize*outerradius);\n    blend(color, ell, vec4(Yellow.rgb, 0.5));    \n          \t\n    color += drawLight(p, tusipos, Yellow, pointsize*10.0, pointsize*0.1);\n    \n    float tusi2limit = pointsize * 5.0;\n    \n    blend(color, boxDist(p, vec2(tusi2limit), 1.0), Dark(Red));\n    \n    \n    //vec2 tusipos2 = iMouse.xy;\n    //if(iMouse.x > tusi2limit && iMouse.y > tusi2limit)\n    //if(iMouse.x > tusi2limit && iMouse.y > tusi2limit)    \n    if(length(relativePos) > 0.001)\n    {   \n        vec2 tusipos2 = wheelpos + rotateCCW(relativePos, time) * innerradius;    \n\n\t\tblend(color, bar(p, wheelpos, tusipos2, pointsize*2.0), Gray);                   \n\t\tblend(color, star(\trotateCW(translate(p, tusipos2), time), pointsize*4.0, pointsize*2.0, 12), LightRed);    \n        \n\n        float offsetAngle = atan(relativePos.y, relativePos.x) * 0.5;\n        float  offsetAngle2 = offsetAngle + M_PI * 0.5;\n\n        vec2 major = cis(offsetAngle) * innerradius + rotateCCW(relativePos, offsetAngle) * innerradius;\n        vec2 minor = cis(offsetAngle2) * innerradius + rotateCCW(relativePos, offsetAngle2) * innerradius;\n\n        if(SHOWAXIS)\n        {\n        \tblend(color, lineDist(p, center, center + major, 2.0), vec4(Green.rgb, 0.25));\n        \tblend(color, lineDist(p, center, center + minor, 2.0), vec4(LightGreen.rgb, 0.25));\n        }\n        \n\n        ellipseSize = vec2(length(major), length(minor));\n        ell = ellipseLineSafe( rotateCCW(translate(p, center), offsetAngle), ellipseSize, 2.5);        \n        blend(color, ell, vec4(Green.rgb, 0.5));    \n        \n\n        color += drawLight(p, tusipos2, Green, pointsize*10.0, pointsize*0.1);\n    }\n    \n    \n        \n\treturn 0.0;\n}\n\nfloat sceneDist(vec2 p)\n{\n    vec4 dummy;\n    return sceneDist(p, dummy);\n}                    \n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\n\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t// background\t\n\tvec4 col = vec4(0.15, 0.15, 0.4, 1.0);\n    // vignette\n    //col *= (1.0 - length(c - p)/iResolution.x);\n    \n\t// grid\n\t//col *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n    \n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p, col);\n        \n    \n\t// ambient occlusion\n\t//col *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\t// shape fill\n    \n\t//col = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t// shape outline\n\t//col = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 0.8));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}