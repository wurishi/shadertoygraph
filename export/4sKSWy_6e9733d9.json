{"ver":"0.1","info":{"id":"4sKSWy","date":"1480204277","viewed":387,"name":"Spherical harmonics, Grace","username":"xchip","description":"quick test to play with spherical harmonics \nuse the mouse to spin the sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gracecathedral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Raul Aguaviva - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Just a quick test to get the irradiance encoded in SH.\n//\n//\n//\n//\n// Thanks to Matt Pharr for his excellent PBR book and in special for the SH chapter.\n// Also thanks to Inigo Quilez for his SH code\n\n#define SAMPLECOUNT 1024\n\n\n////////////////////////////////////////////////////////////////////\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SphericalHarmonic( in int l, in int m, in vec3 n ) \n{ \n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    \n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    \n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return  -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return  -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\nstruct SphericalHarmonicsCoeffs\n{\n    float v[9];\n};\n\n\n//=====================================================\n\n// Sphere intersection\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nfloat Scene(in vec3 pos, in vec3 dir, out vec3 normal)\n{\n   float tmin = 1e10;\n    \n    pos+=dir*0.0001; //just to avoid self intersections\n\n   vec4 sph = vec4( cos( 0.*.5* iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(0.,1.2,0.0), 1.0 );\n   float t2 = sphIntersect( pos, dir, sph );        \n   if( t2>0.0 && t2<tmin )\n   {\n       tmin = t2;\n       vec3 pos = pos + tmin*dir;\n       normal = normalize( pos - sph.xyz );\n   }      \n    \n   t2 = iPlane( pos, dir );\n   if( t2>0.0 && t2<tmin )\n   {\n       tmin = t2;\n       normal = vec3(0.0,1.0,0.0);\n   }    \n    \n    \n    return tmin;    \n}\n\nfloat SceneViz(in vec3 pos, in vec3 dir)\n{\n    vec3 normal;\n    float res = Scene(pos, dir, normal);\n    return res!=1e10?1.:0.;//step(0.0,res);    \n}\n\n\n//=====================================================\n\nfloat GetIrradiance(in SphericalHarmonicsCoeffs L, vec3 n )\n{\n    float r = 0.0;\n    r += 3.141593 * L.v[0] * SphericalHarmonic(0,  0, n);\n\n    r += 2.094395 * L.v[1] * -SphericalHarmonic(1, -1, n);\n    r += 2.094395 * L.v[2] * SphericalHarmonic(1,  0, n);\n    r += 2.094395 * L.v[3] * -SphericalHarmonic(1,  1, n);\n\n    r += 0.785398 * L.v[4] * SphericalHarmonic(2, -2, n);\n    r += 0.785398 * L.v[5] * -SphericalHarmonic(2, -1, n);\n    r += 0.785398 * L.v[6] * SphericalHarmonic(2,  0, n);\n    r += 0.785398 * L.v[7] * -SphericalHarmonic(2,  1, n);\n    r += 0.785398 * L.v[8] * SphericalHarmonic(2,  2, n);   \n    return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor = vec3(0.0,0.0,0.0);\n    float t1 = Scene( ro, rd, nor );\n    if( t1>0.0 && t1<tmin)\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        \n\n        //nor = nor.xzy;\n        \n        SphericalHarmonicsCoeffs Grace_r, Grace_g, Grace_b;\n        Grace_r.v[0] =  0.78908;   Grace_g.v[0] =  0.43710;   Grace_b.v[0] =  0.54161; \n        Grace_r.v[1] =  0.39499;   Grace_g.v[1] =  0.34989;   Grace_b.v[1] =  0.60488; \n        Grace_r.v[2] = -0.33974;   Grace_g.v[2] = -0.18236;   Grace_b.v[2] = -0.26940;\n        Grace_r.v[3] = -0.29213;   Grace_g.v[3] = -0.05562;   Grace_b.v[3] =  0.00944;\n        Grace_r.v[4] = -0.11141;   Grace_g.v[4] = -0.05090;   Grace_b.v[4] = -0.12231;\n        Grace_r.v[5] = -0.26240;   Grace_g.v[5] = -0.22401;   Grace_b.v[5] = -0.47479;\n        Grace_r.v[6] = -0.15570;   Grace_g.v[6] = -0.09471;   Grace_b.v[6] = -0.14733;\n        Grace_r.v[7] =  0.56014;   Grace_g.v[7] =  0.21444;   Grace_b.v[7] =  0.13915;\n        Grace_r.v[8] =  0.21205;   Grace_g.v[8] =  0.05432;   Grace_b.v[8] = -0.30374;\n\n        float tx = iMouse.x/10.;\n        float ty = iMouse.y/10.;\n        //nor = vec3(cos(tx) * nor.x - sin(tx)* nor.y, sin(tx) * nor.x + cos(tx) * nor.y, nor.z);\n        \n        nor = vec3(cos(tx) * nor.x - sin(tx)* nor.z, nor.y, sin(tx) * nor.x + cos(tx) * nor.z);\n        //nor = vec3(nor.x, cos(ty) * nor.y - sin(ty)* nor.z, sin(ty) * nor.y + cos(ty) * nor.z);\n        \n        //nor = nor.xzy;\n        \n        col.r = GetIrradiance(Grace_r, nor);\n        col.g = GetIrradiance(Grace_g, nor);\n        col.b = GetIrradiance(Grace_b, nor);\n        \n        //col = vec3(nor.z,nor.z,nor.z);\n    }\n    else \n    {\n    }\n   \n    // col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}