{"ver":"0.1","info":{"id":"MccXD2","date":"1714924426","viewed":91,"name":"Polygon line splitting","username":"mrboggieman","description":"Split up a concave polygon using lines. Drag the mouse to control one of the lines\n1 - toggle slicing lines\n2 - toggle intersections\n3 - toggle clipped polygon","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["triangle","geometry","polygon","algorithm","clipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// utils\nconst float EPSILON = 0.0001;\n\nstruct Line {\n   vec2 a;\n   vec2 b;\n};\n\nfloat det2(in vec2 a, in vec2 b) {\n    return determinant(mat2(a, b));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 closestPointOnLine(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nbool pointInsideLine(in Line line, in vec2 pos) {\n    return det2(pos - line.a, line.b - line.a) < 0.0;\n}\n\nint intersectLines(in Line line1, in Line line2, out vec2 collision) {\n    float c = det2(line1.a, line1.b);\n    float d = det2(line2.a, line2.b);\n    float e = det2(line1.a - line1.b, line2.a - line2.b);\n    \n    if (abs(e) < EPSILON) {\n        return 0;\n    }\n    \n    collision = vec2(\n        det2(vec2(c, line1.a.x - line1.b.x), vec2(d, line2.a.x - line2.b.x)) / e,\n        det2(vec2(c, line1.a.y - line1.b.y), vec2(d, line2.a.y - line2.b.y)) / e\n    );\n    \n    // ensure the collision point is in the 0-1 range of our line (must be more efficient way of doing this)\n    if ((dot(collision - line1.a, line1.b - line1.a) < 0.0) || (distance(collision, line1.a) > distance(line1.a, line1.b))) {\n        return 0;\n    }\n\n    return int(sign(e));\n}\n\nfloat distanceToLine(in Line line, in vec2 pos) {\n    return distance(closestPointOnLine(line, pos), pos);\n}\n\nfloat distanceToLineSegment(in Line line, in vec2 pos) {\n    return distance(clamp(closestPointOnLine(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n\n// START\nconst float LINE_THICKNESS = 0.003;\nconst float VERTEX_SIZE = 0.02;\nconst int MAX_LINES = 10;\n\nstruct LineVec {\n    Line[MAX_LINES] lines;\n    int num_lines;\n};\n\nstruct SliceResult {\n    LineVec lines;\n    vec2 in_point;\n    vec2 out_point;\n};\n\nSliceResult slicePolygon(in LineVec lines, in Line cutting_line) {\n    Line[MAX_LINES] new_lines;\n    int num_new_lines = 0;\n    vec2 in_point;\n    vec2 out_point;\n    \n    for (int i=0; i<lines.num_lines; i++) {\n        vec2 intersection;\n        Line line = lines.lines[i];\n        int dir = intersectLines(line, cutting_line, intersection);\n\n        switch (dir) {\n            case 0:\n                // determine if the line is inside or outside by checking the center of the line\n                if (!pointInsideLine(cutting_line, mix(line.a, line.b, 0.5))) {\n                    new_lines[num_new_lines] = line;\n                    num_new_lines++;\n                }\n                break;\n            case -1:\n                // break the line into two keeping the first part\n                new_lines[num_new_lines] = Line(line.a, intersection);\n                num_new_lines++;\n                \n                in_point = intersection;\n                break;\n            case 1:\n                // break the line into two keeping the second part\n                new_lines[num_new_lines] = Line(intersection, line.b);\n                num_new_lines++;\n\n                out_point = intersection;\n                break;\n        }\n    }\n    \n    if (length(in_point) > 0.0 && length(out_point) > 0.0) {\n        new_lines[num_new_lines] = Line(in_point, out_point);\n        num_new_lines++;\n    }\n    \n    return SliceResult(\n        LineVec(new_lines, num_new_lines),\n        in_point,\n        out_point\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float pixel_size = 1.5/iResolution.y;\n    \n    // original shape\n    vec2[] vertices = vec2[](\n        vec2(0.5, 0.2),\n        vec2(0.1, 0.7),\n        vec2(0.6, 0.8),\n        vec2(1.4, 0.2)\n    );\n    \n    Line[MAX_LINES] lines;\n    int num_lines = 4;\n    \n    lines[0] = Line(vertices[0], vertices[1]);\n    lines[1] = Line(vertices[1], vertices[2]);\n    lines[2] = Line(vertices[2], vertices[3]);\n    lines[3] = Line(vertices[3], vertices[0]);\n    \n    Line[] cutting_lines = Line[](\n        Line(vec2(0.3, 0.3), length(iMouse.xy) > 10.0 ? iMouse.xy / iResolution.y: vec2(1.4,0.7)),\n        Line(vec2(0.2, 0.9), vec2(1.4,0.3)),\n        Line(vec2(1.2, 0.4), vec2(0.4,0.1)),\n        Line(vec2(0.8, 0.1), vec2(0.2, 0.4)),\n        Line(vec2(1.4, 0.8), vec2(0.8, 0.2))\n    );\n\n    // slice the polygon over and over\n    vec2[cutting_lines.length()*2] intersections;\n    LineVec sliced_lines = LineVec(lines, num_lines);\n\n    for (int i=0; i<cutting_lines.length(); i++) {\n        SliceResult sliced_polygon = slicePolygon(sliced_lines, cutting_lines[i]);\n        intersections[i*2] = sliced_polygon.in_point;\n        intersections[i*2+1] = sliced_polygon.out_point;\n        sliced_lines = sliced_polygon.lines;\n    }\n    \n    vec3 col = vec3(0.0);\n\n    // render the original shape\n    for (int i=0; i<num_lines; i++) {\n        col = mix(col, vec3(1.0), smoothstep(pixel_size, 0.0, distanceToLineSegment(lines[i], uv) - LINE_THICKNESS));\n    }\n\n    // render the cutting lines\n    if (texelFetch(iChannel0, ivec2(49, 2), 0).r < 1.0) {\n        for (int i=0; i<cutting_lines.length(); i++) {\n            col = mix(col, vec3(1.0, 0.0, 0.0), smoothstep(pixel_size, 0.0, distanceToLine(cutting_lines[i], uv) - LINE_THICKNESS));\n        }\n    }\n\n    // render the new lines that have been cut up\n    if (texelFetch(iChannel0, ivec2(51, 2), 0).r < 1.0) {\n        bool insidePolygon = sliced_lines.num_lines != 0;\n\n        for (int i=0; i<sliced_lines.num_lines; i++) {\n            if (pointInsideLine(sliced_lines.lines[i], uv)) {\n                insidePolygon = false;\n            }\n        }\n    \n        // draw the fill for the split polygon\n        if (insidePolygon) {\n            col = vec3(0.3, 0.0, 0.3);\n        }\n        \n        // draw the lines for the split polygon\n        for (int i=0; i<sliced_lines.num_lines; i++) {\n            col = mix(col, vec3(1.0, 0.0, 1.0), smoothstep(pixel_size, 0.0, distanceToLineSegment(sliced_lines.lines[i], uv) - LINE_THICKNESS));\n        }\n    }\n\n    // draw the intersections\n    if (texelFetch(iChannel0, ivec2(50, 2), 0).r < 1.0) {\n        for (int i=0; i<intersections.length(); i++) {\n            vec2 intersection = intersections[i];\n            if (length(intersection) > 0.0) {\n                col = mix(col, vec3(0.0, 0.0, 1.0), smoothstep(pixel_size, 0.0, distance(intersection, uv) - VERTEX_SIZE));\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}