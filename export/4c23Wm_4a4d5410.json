{"ver":"0.1","info":{"id":"4c23Wm","date":"1704454936","viewed":21,"name":"Raymarching Demo - Materials","username":"SardineMilk","description":"Basic raymarching example\nRefactored code\nPlan to add lighting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t) {\n    //[[0.610 0.498 0.650] [0.388 0.498 0.350] [0.530 0.498 0.620] [3.438 3.012 4.025]]\n    vec3 a = vec3(0.61, 0.5, 0.65);\n    vec3 b = vec3(0.388, 0.498, 0.35);\n    vec3 c = vec3(0.53, 0.498, 0.62);\n    vec3 d = vec3(2., 0., 0.);\n\n    return a + b*cos( 6.28318*(c*t*d) );\n    }\n\n\nfloat sdfSmoothUnion(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdfUnion( const float a, const float b ) {\n    return min(a, b);\n}\n\nfloat sdfDifference( const float a, const float b) {\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b ) {\n    return max(a, b);\n}\n\n\nfloat sdWorms(vec3 p) {\n\tfloat s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.) - 1.0) - 0.2;\n\tfloat s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.) - 1.0) - 0.2;\n    return min(s1, s2);\n}\n\n\nfloat sdSphere(vec3 point, vec3 centre, float radius) {\n    return length(point - centre) - radius;\n}\n\n\nfloat sdTiledSphere(vec3 point, vec3 centre, float radius) {\n    vec3 tiledPoint = mod(point - centre + 0.5, 1.) - 0.5;\n    return length(tiledPoint) - radius;\n}\n\n\nfloat sdPlane( vec3 point, vec3 normal, float height )\n{\n  // normal must be normalized\n  return dot(point, normal) + height;\n}\n\n\nfloat sdBox( vec3 point, vec3 centre, vec3 size )\n{\n  vec3 q = abs(point - centre) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// Calculate the Signed Distance Field for the scene\n\nfloat map(vec3 point, out vec3 color) {\n    float signedDistance;\n\n    // Define Sphere1\n    vec3 sphere1Position = vec3(1., sin(iTime) - 1., 7.);\n    float sphere1Radius = .5;\n    vec3 sphere1Color = vec3(1.0, 0.0, 0.0);\n    float sphere1Distance = sdSphere(point, sphere1Position, sphere1Radius); \n    \n    // Define Sphere2\n    vec3 sphere2Position = vec3(sin(iTime) * 2., -sin(iTime) / 5. +.5, 7.);\n    float sphere2Radius = .75;\n    vec3 sphere2Color = vec3(0.0, 1.0, 0.0);\n    float sphere2Distance = sdSphere(point, sphere2Position, sphere2Radius); \n    \n    // Define Box\n    vec3 boxPosition = vec3(-0.5, -1.125, 7.5);\n    vec3 boxSize = vec3(1., 1., 1.);\n    vec3 boxColor = vec3(0.0, 0.0, 1.0);\n    float boxDistance = sdBox(point, boxPosition, boxSize);\n    \n    // Define Plane\n    vec3 planeNormal = normalize(vec3(0., 1., 0.));  // Direction plane faces - Must be normalized\n    float planeHeight = 1.5;\n    vec3 planeColor = vec3(0.5, 0.5, 0.5);\n    float planeDistance = sdPlane(point, planeNormal, planeHeight);\n    \n\n    signedDistance = sdfSmoothUnion(sphere1Distance, sphere2Distance, 0.5);\n    signedDistance = sdfSmoothUnion(signedDistance, planeDistance, 0.25);\n    signedDistance = sdfSmoothUnion(signedDistance, boxDistance, 0.25);\n\n    // Get Color\n    float minDist = min(planeDistance, min(boxDistance, min(sphere1Distance, sphere2Distance)));        \n    \n    if (minDist == sphere1Distance) color = sphere1Color;\n    if (minDist == sphere2Distance) color = sphere2Color;\n    if (minDist == boxDistance) color = boxColor;\n    if (minDist == planeDistance) color = planeColor; \n    \n    return signedDistance;\n}\n\n\nvec3 calculateLighting(vec3 point, vec3 materialColor) {\n    vec3 color;\n    \n    color = materialColor;\n\n    return color;\n}\n\n\nconst float FOV = 90.;\nint maxMarchingSteps = 2555;  // Maximum number of times ray is marched until loop breaks\nfloat maxDistance = 1000.0;  // Maximum distance to object for a miss\nfloat minDistance = 0.00005;  // Minimum distance to object for a hit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    // Shifted so (0, 0) is the centre rather than bottom-left\n    vec2 shiftedCoord = fragCoord - (iResolution.xy / 2.0);\n    vec2 uv = shiftedCoord / iResolution.y;   \n    \n    vec3 rayPosition = vec3(uv.x, uv.y, 0.0);\n    \n    vec3 rayDirection = vec3(0.0, 0.0, 1.0);\n    rayDirection.xy = uv.xy * atan(radians(FOV / 2.));\n    rayDirection = normalize(rayDirection);\n    \n    // Default colour for a miss\n    vec3 col = vec3(0., 0., 0.);\n    \n    for (int i = 0; i < maxMarchingSteps; i++)  // March the ray forwards  \n    {        \n        // Distance to nearest object\n        vec3 objectColor;  // Color of the hit object\n        float signedDistance = map(rayPosition, objectColor);\n\n        if (signedDistance > maxDistance) break;  // If the ray misses\n           \n        if (signedDistance < minDistance) {  // If the ray touches something\n        \n            //col = vec3(1., 1., 1.);\n            //col = palette((float(i) * 0.04) - (rayPosition.z * 0.25) - (signedDistance * 1. + 1.));\n            //col = palette(rayPosition.z * 0.25);\n            //col = palette(signedDistance * 3500. + 1.);\n            //col = palette(float(i) * 0.008 + 0.6);\n            //col = palette(float(i) * .001);        \n\n            col = calculateLighting(rayPosition, objectColor);\n            col -= vec3(float(i) / 2555. * 10.); \n            col /= length(rayPosition) / 5.;      \n\n            break;\n        } \n\n            rayPosition += rayDirection * signedDistance;  // Move the ray\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}