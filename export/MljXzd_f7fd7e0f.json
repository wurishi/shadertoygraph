{"ver":"0.1","info":{"id":"MljXzd","date":"1446593954","viewed":328,"name":"Raycast spheres","username":"Swax97","description":"A super simple raycaster, interact with the mouse.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycast","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float VIEW = 6.0;\nconst float LIMIT = 0.01;\nconst float RADIUS = 0.5;\n\n\nconst float pi = 3.1415927;\n\n\n//distance function\nfloat dist(vec3 p){\n    //mod causes infinitly many zeros\n    return length(fract(p) * 2.0 - 1.0) - RADIUS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //scale:\n\tvec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //caster origin/delta\n    vec3 p = vec3(0.0, 0.0, iTime * 0.25);\n    vec3 d = normalize(vec3(uv, 1.));//imperfect FOV causes stretching\n    \n    //theta for rotation\n    float t = (iMouse.x / iResolution.x - 0.5) * 4.0;\n    float ct = cos(t), st = sin(t);\n    d.xz *= mat2(ct, -st, st, ct);\n    \n    //cast\n    float m = 1.0, l = 0.0;\n    \n    for (int i = 0; i < 200; i++){\n        //if close enough or out of view\n        if (m < LIMIT || l > VIEW) break;\n        m = dist(p + d * l);//evaluate distance\n        l += m * 0.5;//increment length of ray\n    }\n    \n    //intersection\n    if (m < LIMIT){\n        //surface normal\n        vec3 n = (fract(p+d*l) * 2.0 - 1.0) / RADIUS;\n        \n        //light source is the camera, plug in -delta as the lighting vector\n        float light = dot(n, -d) * 0.5 + 0.5;\n        \n        //Poorly written algorithm:\n        float speed = sin(floor(p.x+d.x*l+100.)*floor(p.y+d.y*l+100.)*floor(p.z+d.z*l)*8.0) * 2.0;\n        \n        //spherical texture coords\n        float u = atan(n.z, n.x) / pi * 2.0 + iTime * speed;\n\t\tfloat v = asin(n.y) / pi * 2.0 + 0.5;\n        \n        //draw color from texture, with lighting\n        vec4 tex = texture(iChannel0, vec2(u, v));\n        fragColor = vec4(tex * light * (1.0 - l / VIEW));\n    }\n}","name":"","description":"","type":"image"}]}