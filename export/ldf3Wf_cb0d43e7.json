{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"music","id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define USE_BRANCHLESS_DDA false\n\n// give planet surface at radial angle\nvec4 planetSample(ivec3 p)\n{\n\tvec3 pp = vec3(p)/iChannelResolution[0].xyx;\n\tfloat s = atan(pp.z,pp.x)/3.14159;\n\tfloat t = pp.y-0.5;\n\treturn texture(iChannel0, vec2(s,t)/10.0);\n}\n\n// give nyanness of space\nvec4 nyanSample(ivec3 p)\n{\n\tvec2 pp = vec2(p.zy)/iChannelResolution[1].xy + vec2(0.1,0.5);\n    pp.y = mod(pp.y, 1.0);\n    pp.x = mod(-pp.x, 1.0/6.4);\n    float frame = floor(iTime*8.0);\n    pp.x = fract(pp.x);\n    return texture(iChannel1, pp.xy+vec2(fract(frame/6.0)*.938,0.0));\n}\n\n// return if a block exists at the position\nbool notEmptyPlanet(ivec3 p)\n{\n\tvec4 samp = planetSample(p);\n\tif (length(vec3(p))<20.0+10.0*length(samp.rgb*samp.a)) return true;\n\t\n\treturn false;\n}\n\n// return if a block exists at the position\nbool notEmptyNyan(ivec3 p)\n{\n\tif (p.x==35 || p.x == -35) {\n\t\tvec4 nyan = nyanSample(p);\n\t\tif (nyan.a>0.0) return true;\n\t}\n\treturn false;\n}\n\n\n// return location of first non-empty block\n// marching accomplished with fb39ca4's non-branching dda: https://www.shadertoy.com/view/4dX3zl\nivec3 intersect(vec3 ro, vec3 rd, out bool success, bool isPlanet)\n{\n\tsuccess = false;\n\tivec3 mapPos = ivec3(floor(ro + 0.));\n\tvec3 deltaDist = abs(vec3(length(rd)) / rd);\n\tivec3 rayStep = ivec3(sign(rd)+0.0);\n\tvec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\tfor (int i = 0; i < 128; i++) {\n        if (isPlanet) {\n\t\t\tif (notEmptyPlanet(mapPos)) {success = true; continue;}\n        } else {\n            if (notEmptyNyan(mapPos)) {success = true; continue;}\n        }\n        \n\t\tif (USE_BRANCHLESS_DDA) {\n\t\t\tbvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\t\tmask.x = b1.x && b2.x;\n\t\t\tmask.y = b1.y && b2.y;\n\t\t\tmask.z = b1.z && b2.z;\n\t\n\t\t\t//All components of mask are false except for the corresponding largest component\n\t\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(mask) * rayStep;\n\t\t\t\n\t\t} else {\n\t\t\tif (sideDist.x < sideDist.y) {\n\t\t\t\tif (sideDist.x < sideDist.z) {\n\t\t\t\t\tsideDist.x += deltaDist.x;\n\t\t\t\t\tmapPos.x += rayStep.x;\n\t\t\t\t\tmask = bvec3(true, false, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sideDist.y < sideDist.z) {\n\t\t\t\t\tsideDist.y += deltaDist.y;\n\t\t\t\t\tmapPos.y += rayStep.y;\n\t\t\t\t\tmask = bvec3(false, true, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mapPos;\n}\n\nvoid cameraTransformPlanet( inout vec3 ro, inout vec3 rd )\n{\n\tfloat c = cos(-iTime);\n\tfloat s = sin(-iTime);\n    mat3 rot = mat3(\n\t\t  c,  0.0,   s,\n\t\t0.0,  1.0,  0.0,\n\t\t -s,  0.0,   c\n\t);\n\tro *= rot;\n\trd *= rot;\n}\n\nvoid cameraTransformNyan( inout vec3 ro, inout vec3 rd )\n{\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy/2.0) / iResolution.yy;\n\tuv.y = -uv.y;\n\t\n\tvec3 ro = vec3(0.0,0.0,-80.0);\n\tvec3 rd = normalize(vec3(uv,1.0));\n\tcameraTransformPlanet(ro,rd);\n\tro += 40.0*rd; // cull area between camera and scene\n\t\n\tbool success;\n\tvec3 c;\n\tivec3 p = intersect(ro,rd, success, true);\n\tif (success)\n\t\tc = planetSample(p).rgb;\n\telse\n    {\n        vec3 ro2 = vec3(0.0,0.0,iTime*20.0);\n\t\tvec3 rd2 = normalize(vec3(uv*2.5,1.0));\n        cameraTransformNyan(ro2, rd2);\n        \n        p = intersect(ro2,rd2, success, false);\n\t\tif (success)\n\t\t\tc = nyanSample(p).rgb;\n\t\telse\n\t\t\tc = vec3(0.1);\n    }\n\t\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldf3Wf","date":"1380512785","viewed":1276,"name":"Nyaniverse","username":"SudoNhim","description":"It's the nyan planet with a nyan cat in geostationary orbit.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","nyan","cubes"],"hasliked":0,"parentid":"","parentname":""}}