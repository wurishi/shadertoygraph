{"ver":"0.1","info":{"id":"3t3yR8","date":"1608415523","viewed":167,"name":"ancient fortress","username":"sukupaper","description":"This shader is mainly a first try to render \"pseudo realistic\" (or at least convincing) procedural textures and I wasn't focused at all on optimisation or code readability","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fortress"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float aa = 1./max(iResolution.x,iResolution.y);\n\n    vec2 s = vec2(0.,aa + length(st)*.0005);\n    vec3 col = vec3(\n        texture(iChannel0,st - s.yx).r,\n        texture(iChannel0,st + s.xy).g,\n        texture(iChannel0,st - s.xy).b\n    );\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Author: paperu\n// Title: ancient fortress\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec4 mod289(vec4 g){return g-floor(g*(1./289.))*289.;}vec4 permute(vec4 g){return mod289((g*34.+1.)*g);}vec4 taylorInvSqrt(vec4 g){return 1.79284-.853735*g;}vec2 fade(vec2 g){return g*g*g*(g*(g*6.-15.)+10.);}float cnoise(vec2 g){vec4 v=floor(g.rgrg)+vec4(0.,0.,1.,1.),d=fract(g.rgrg)-vec4(0.,0.,1.,1.);v=mod289(v);vec4 r=v.rbrb,a=v.ggaa,p=d.rbrb,e=d.ggaa,c=permute(permute(r)+a),f=fract(c*(1./41.))*2.-1.,t=abs(f)-.5,b=floor(f+.5);f=f-b;vec2 m=vec2(f.r,t.r),o=vec2(f.g,t.g),l=vec2(f.b,t.b),u=vec2(f.a,t.a);vec4 n=taylorInvSqrt(vec4(dot(m,m),dot(l,l),dot(o,o),dot(u,u)));m*=n.r;l*=n.g;o*=n.b;u*=n.a;float i=dot(m,vec2(p.r,e.r)),x=dot(o,vec2(p.g,e.g)),s=dot(l,vec2(p.b,e.b)),S=dot(u,vec2(p.a,e.a));vec2 I=fade(d.rg),y=mix(vec2(i,s),vec2(x,S),I.r);float q=mix(y.r,y.g,I.g);return 2.3*q;}\n\nvec2 idBrick(in vec2 p, in vec2 ratio) { p *= ratio; p.x += .5*floor(p.y); return floor(p); }\nvec2 brick(in vec2 p, in vec2 ratio) { p *= ratio; p.x += .5*floor(p.y); return (fract(p)  - .5)/ratio; }\nfloat brickTex(in vec2 p, in vec2 ratio, in float radius, in float spaces) { return length(max(abs(brick(p, ratio)) - 1./ratio*.5 + radius + spaces,0.)) - radius; }\n\nfloat t;\n#define P 6.283185307\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat sph(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 s, in float r) { return length(max(abs(p) - s,0.)) - r; }\n\nvec3 map;\nint matId = 0;\nfloat distFromTower, distFromSphere, distFromHole;\nfloat df(in vec3 p, in bool normalMode) {\n    vec3 pSol = p;\n    p.x = mod(p.x,3.) - 1.5;\n    float r = 0., r0 = 0.;\n    vec2 realMap = vec2(p.x + p.z, p.y);\n    if(normalMode) {\n        r = brickTex(realMap*10., vec2(1.), .04, -.015);\n        r0 = cnoise(realMap*11.) + cnoise(realMap*80.)*.5;\n    \tmap = pSol;\n    }\n    float towers = box(p, vec3(.85,10.85,.85), .5 - r*.1) + rand(idBrick(realMap*10., vec2(1.)))*.025;\n    towers = min(towers,-p.z - r*.1);\n    distFromTower = towers;\n    float sphere = sph(p + vec3(0.,-0.75,1.),.55 + r0*.005);\n    float minusBox = min(box(p,vec3(.025,.8,1.5),.01),box(p,vec3(.2,.025,1.5),.01));\n    distFromSphere = min(sphere,minusBox);\n    distFromHole = minusBox;\n    float d = min(towers, sphere);\n    matId = d<= -minusBox ? 3 : d==towers ? 0 : d==sphere ? 2 : 4;\n    d = max(d, -minusBox);\n    d -= -p.y*.025*-p.z;\n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p, true); vec2 u = vec2(0.,.001); return normalize(vec3(df(p + u.yxx, true),df(p + u.xyx, true),df(p + u.xxy, true)) - d); }\n\n#define MAX_D 20.\n#define LIM .001\n#define MAX_IT 70\nstruct rmRes { vec3 pos; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    vec3 p = c + r;\n    int it;\n    bool hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p, false);\n        if(d < LIM) { hit = true; break; }\n        if(distance(c,p) > MAX_D) break;\n        p += d*r;\n        it = i;\n    }\n    rmRes res;\n    res.pos = p;\n    res.hit = hit;\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    t = iTime;\n    vec2 m = (iMouse.x == 0. && iMouse.y == 0.) ? vec2(0.) : iMouse.xy/iResolution.xy - .5;\n    \n    vec3 c = vec3(0.,0.,-8.);\n    vec3 r = normalize(vec3(st,1.15));\n    \n\tfloat angle = -.7 + cos(t*.1)*.1;\n    r.zy *= rot(-m.y*1.5);\n    r.zx *= rot(-m.x*.5);\n    c.xz = vec2(cos(angle),sin(angle))*8.;\n    r.xz *= rot(-angle - P*.25);\n    r.zy *= rot(-angle*.1);\n    \n    c.x += t*.2;\n\n    rmRes res = rm(c,r);\n    \n    vec3 skyColor = mix(vec3(0.807,0.866,0.990),vec3(0.955,1.000,0.655),r.y*1.);\n    vec3 color = skyColor;\n    \n    if(res.hit) {\n        float dist = distance(res.pos,c);\n        vec3 l = normalize(vec3(-0.156,0.161,-0.746));\n        vec3 n = normal(res.pos);\n        float a = dot(n,l);\n        vec2 realMap = vec2(res.pos.x + res.pos.z, res.pos.y);\n        \n        if(matId == 0) {\n            float n0 = cnoise(realMap*2.),\n                n1 = cnoise(realMap*5.),\n                n2 = cnoise(realMap*15.),\n                n3 = cnoise(realMap*40.),\n                n4 = cnoise(realMap*180.);\n\n            color = vec3(0.565,0.463,0.325)\n                - max(n0-map.y*.125 - .01,0.2)*vec3(0.594,0.400,1.000)\n                - n1*vec3(0.189,0.111,0.195)\n                - n2*vec3(0.120,0.109,0.116)\n                - n3*.09\n                - n4*vec3(0.455,0.180,0.282);\n            color = clamp(color,-.1,1.);\n        \tcolor += clamp(pow(a,8.),0.,1.)*vec3(0.105,0.102,0.085);\n            color *= smoothstep(-.1,.1,distFromSphere);\n        } else if(matId == 2) {\n            float n0 = cnoise(realMap*100.) + 1.;\n            color = mix(vec3(0.430,0.250,0.217),vec3(0.775,0.389,0.130),1. - n0*.4);\n        \tcolor += clamp(pow(a,5.),0.,1.)*vec3(0.255,0.244,0.231);\n            color = mix(vec3(0.030,0.165,0.059),color, smoothstep(-.01,.12,min(distFromTower,distFromHole)));\n        } else if(matId == 3) {\n            color = vec3(0.030,0.165,0.059);\n        }\n        \n        color *= max(a,.4)*1.5;\n        color += skyColor*.1;\n        \n        color = mix(color, skyColor, clamp(-res.pos.y - 1.5 + cnoise(realMap*.1 + t*.05)*1.5,0.,1.));\n        color *= 1. - clamp(cnoise(map.xz*.2 - t*.12)*.5,.0,1.5)*clamp(map.y + 3.,0.,1.);\n        color = mix(color,skyColor,clamp(dist*dist*.002,0.,1.));\n    }\n\n    fragColor = vec4(color*color*1.75,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}