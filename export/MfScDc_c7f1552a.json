{"ver":"0.1","info":{"id":"MfScDc","date":"1723067003","viewed":127,"name":"Slime Mold Attempt","username":"chronos","description":"Slime Mold Attempt","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["simulation","slime","trail","particle","mold","physarum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\n    Slime Mold Attempt by chronos\n    -----------------------------------------------------\n    \n    Tried just implementing this from a high level description I saw,\n    so I have no idea what the details of the algo or the parameters should be\n    to produce interesting behaviour.\n    \n    I do know that it ideally shouldn't annihilate any colliding particles though,\n    but currently I don't use any method to conserve particles, I just keep at most\n    one particle per pixel.\n    \n    Any ideas of how to improve it are welcome! :)\n    \n    \n    self link: https://www.shadertoy.com/view/MfScDc\n    \n\n*/\n\n// This just displays the particles and trail,\n// The simulation code is in Buffer A :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0);\n    \n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    float particle = float(length(bufA.rg) < 1e6);\n    color += particle + bufA.w;\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    \n    float step_size = 1.;              // Speed of particles, in pixels, (make sure it's within the search window!)\n    float sight_range = 2.;            // how far ahead they sample the trail, in pixels\n    float diffusion_strength = 1./5.;  // how fast the trail diffuses over time, as gaussian variance\n    float sight_angle = PI / 8.;       // angle between trail sample locations for each particle\n    float turn_rate = 0.495*sight_angle;// how fast the particle can turn, in radians per frame\n    float trail_strength = 0.05;       // multiplier for the trail left behind by particles\n    float trail_dissipation = 0.01;    // proportion of the trail that fades away each frame\n    float new_trail_width = .5;       // adjusts the variance of the gaussian the particle leaves behind\n\n    // Initialize output variables for particles and trail. Large values are used if there is no particle.\n    vec2 particle_pos = vec2(9e9);\n    float particle_angle = 9e9;\n    float trail = 0.;\n\n    if(iFrame < 10) // Initial trail and particles\n    {\n        vec2 uv = (2.*fragCoord.xy- iResolution.xy)/iResolution.y;\n     \n        if(iChannelResolution[1].x > 0. && iChannelResolution[2].x > 0.) // If noise textures are loaded, we use them\n        {\n            vec4 rgbanoise = texelFetch(iChannel2, ivec2(fragCoord)%256, 0);\n            vec4 bluenoise = texelFetch(iChannel1, ivec2(fragCoord)%1024, 0);\n            trail += rgbanoise.g * 0.1;\n            if(rgbanoise.r > .985 && length(uv) < 1. && length(uv) > .5)\n            {\n                particle_pos = fragCoord;\n                particle_angle = 2. * PI * bluenoise.r;\n                trail = 1.;\n            }\n        }\n        else // Fallback to using my own crappy implementation of the  fract-sin hash :P\n        {\n            float hash = fract(31415.9265 * sin(dot(fragCoord.xy, vec2(1.61803398875, 31.14159265))));\n            trail += hash * 0.1;\n            if(length(uv) < 1. && length(uv) > .5 && hash > 0.985)\n            {\n                hash = fract(31415.9265 * sin(123.123 + dot(fragCoord.yx, vec2(1.61803398875, 31.14159265))));\n                particle_pos = fragCoord;\n                particle_angle = 2. * PI * hash;\n                trail = 1.;\n            }\n        }\n    }\n    else // particle and trail simulation\n    {\n        vec4 bufA = vec4(0);\n    \n        float kernel_sum = 0.;\n        \n        float new_trail = 0.;\n    \n        for(int i = -5; i <= 5; i++)\n        for(int j = -5; j <= 5; j++)\n        {\n            vec2 ij = vec2(i, j);\n            \n            vec4 samp = texelFetch(iChannel0, ivec2(fragCoord + ij + iResolution.xy)%ivec2(iResolution.xy), 0);\n            \n            float neighbor_angle = samp.z;\n            vec2 neighbor_pos = samp.xy;\n            float neighbor_trail = samp.w;\n            \n            float kernel = exp(-dot(ij, ij) / diffusion_strength);\n            \n            trail += neighbor_trail * kernel; // diffuse\n            kernel_sum += kernel;\n            \n            if(neighbor_pos.x  < 1e6)\n            {\n            \n                new_trail += exp(-dot(ij, ij) / new_trail_width);\n            \n                vec2 v = vec2(cos(neighbor_angle), sin(neighbor_angle)) * step_size;\n\n                vec2 offset = mod(neighbor_pos + v + iResolution.xy, iResolution.xy) - fragCoord;\n\n                if(\n                    -0.5 <= offset.x && offset.x < 0.5 \n                    &&\n                    -0.5 <= offset.y && offset.y < 0.5 \n                    )\n                {\n                    particle_pos = mod(neighbor_pos + v + iResolution.xy, iResolution.xy);\n                    particle_angle = neighbor_angle;\n                }\n            }\n        }\n    \n        trail /= kernel_sum;\n        trail *= 1.-trail_dissipation;\n        trail += new_trail * trail_strength;\n        \n        if(particle_pos.x < 1e6)\n        {\n            float dir_left = particle_angle - sight_angle;\n            float dir_fwd = particle_angle;\n            float dir_right = particle_angle + sight_angle;\n            \n            vec2 v_left = vec2(cos(dir_left), sin(dir_left)) * sight_range;\n            vec2 v_fwd = vec2(cos(dir_fwd), sin(dir_fwd)) * sight_range;\n            vec2 v_right = vec2(cos(dir_right), sin(dir_right)) * sight_range;\n        \n            float samp_left  = texelFetch(iChannel0, ivec2(particle_pos + v_left) % ivec2(iResolution.xy), 0).w;\n            float samp_fwd   = texelFetch(iChannel0, ivec2(particle_pos + v_fwd) % ivec2(iResolution.xy), 0).w;\n            float samp_right = texelFetch(iChannel0, ivec2(particle_pos + v_right) % ivec2(iResolution.xy), 0).w;\n            \n            if(samp_fwd >= samp_left && samp_fwd >= samp_right)\n                particle_angle += 0.;\n            else if(samp_left > samp_fwd && samp_left >= samp_right)\n                particle_angle -= turn_rate;\n            else\n                particle_angle += turn_rate;\n        }\n        \n    }\n    \n    fragColor = vec4(particle_pos, particle_angle, trail);\n}","name":"Buffer A","description":"","type":"buffer"}]}