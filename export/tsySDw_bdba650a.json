{"ver":"0.1","info":{"id":"tsySDw","date":"1574160304","viewed":323,"name":"AMAZE Ray Marching Workshop","username":"enci","description":"A simple shader for a ray marching workshop at AMAZE 2019 festival","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","temple","procedrual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TAU (2.0*PI)\n#define EPSILON 0.0001\n#define MAX_STEPS 264\n#define SPEED 0.5\n#define LIGHT_SPEED 10.0\n#define LIGHT_RADIUS 0.6\n#define MAX_FLT  65504.0\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n///// Shapes /////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCylinderY(vec3 p, vec3 c)\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCylinderZ(vec3 p, vec3 c)\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\nfloat sdCylinderX(vec3 p, vec3 c)\n{\n  return length(p.zy-c.xy)-c.z;\n}\n\n///// Combine shapes /////////////////////////////////////////////////////////////////////////////////////////\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat opUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nvoid opRepeat(inout float coor, float repeat)\n{\n  coor = mod(coor + repeat * 0.5, repeat) - repeat * 0.5;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n///// My scene /////////////////////////////////////////////////////////////////////////////////////////\n\nvec4 getLightPos()\n{  \n  float x = iTime * SPEED * 12.0 + 18.0;\n  return vec4(\n    x,\n    sin(x * (PI / 6.0)) * 2.0 + 3.0,\n    sin(x * (PI / 12.0) + PI * 0.5) * 13.0 + 6.0,\n    LIGHT_RADIUS * 0.5 + abs(sin(x * (PI / 3.0))) * LIGHT_RADIUS * 0.5);\n}\n\nfloat floorSdf(vec3 pos)\n{\n  opRepeat(pos.x, 1.0);\n  opRepeat(pos.z, 1.0);\n  return sdRoundBox(pos, vec3(0.45, 0.2, 0.45), 0.05);\n}\n\nfloat debugPillarSdf(vec3 pos)\n{\n  opRepeat(pos.x, 12.0);\n  float c0 = sdCylinderY(pos, vec3(6.0, 6.0, LIGHT_RADIUS * 0.1));\n  //float c1 = sdCylinderY(pos, vec3(0.0, 6.0 + LIGHT_RADIUS, LIGHT_RADIUS * 0.1));\n  return c0;\n}\n\nfloat ceilingSdf(vec3 pos)\n{ \n  pos -= vec3(6.0, 5.0, 6.0);\n  float b = sdPlane(pos, vec4(0.0, -1.0, 0.0, 0.0)); \n  const float repeat = 12.0;\n  opRepeat(pos.x, repeat);\n  opRepeat(pos.z, repeat);\n  float cz = sdCylinderZ(pos, vec3(0.0, 0.0, 5.0));\n  float cx = sdCylinderX(pos, vec3(0.0, 0.0, 5.0));\n  float c = min(cz, cx);   \n  return opSubtraction(c, b);\n}\n\nfloat pillarsSdf(vec3 pos)\n{\n  const float repeat = 12.0;\n  opRepeat(pos.x, repeat);\n  opRepeat(pos.z, repeat);\n\n  float d = MAX_FLT;\n  float pillar = sdBox(pos, vec3(1.0, 5.0, 1.0));\n  float base = sdBox(pos, vec3(1.5, 0.5, 1.5));  \n  float top = sdBox(pos - vec3(0.0, 4.5, 0.0), vec3(1.25, 0.2, 1.25));\n  d = opUnionStairs(pillar, base, 0.5, 3.0);\n  d = opUnionStairs(d, top, 0.3, 2.0);\n  return d;\n}\n\nfloat sdf(vec3 pos)\n{    \n  float d = MAX_FLT;\n  d = floorSdf(pos);\n  d = min(d, pillarsSdf(pos));\n  d = min(d, ceilingSdf(pos));\n  //d = min(d, debugPillarSdf(pos));\n  vec4 light = getLightPos();\n  d = min(d, sdSphere(pos - light.xyz, light.w));\n  return d;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0; // Stores current distance along ray\n     \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float res = sdf(rayOrigin + rayDir * t);\n        if (res < (EPSILON * t))\n        {\n            return t;\n        }\n        t += res;\n    }\n     \n    return -1.0;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = sdf(pos);\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( sdf(pos + eps_zero.xyy), sdf(pos + eps_zero.yxy), sdf(pos + eps_zero.yyx) ) - c);\n}\n\nfloat trPlane(vec3 rayOrigin, vec3 rayDir, vec4 normal)\n{  \n\tfloat d = dot(normal.xyz, rayDir);\n\n  // Normal and ray perpendicular \n\tif (d == 0.0)\n\t\treturn -1.0;\n\t\n\tfloat t = (normal.w - dot(normal.xyz, rayOrigin)) / d;\n\n\t// Behind ray\n  if (t <= 0.0)\n  \treturn -1.0;\n\t\n\treturn t;\n}\n\nvoid debugPlane(inout vec3 color, vec3 rayOrigin, vec3 rayDir, float dist)\n{\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  float t = trPlane(rayOrigin, rayDir, vec4(up, 0.0));  \n\n  if(t > 0.0 && (t < dist || dist == -1.0))\n  {\n    vec3 pos = rayOrigin + rayDir * t;\n    float d = sdf(pos);\n\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\t  col *= 1.0 - exp(-2.0 * abs(d));\n\t  col *= 0.8 + 0.2 * cos(20.0 * d);\n\t  col = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 0.15, abs(d)) );\n    color = col;\n  }\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{ \n\tfloat t = castRay(rayOrigin, rayDir);\n\n\t//vec3 L = normalize(vec3(sin(iTime)*1.0, cos(iTime*0.5)+0.5, -0.5));\n  vec3 color;\n  vec3 backColor = vec3(0.35, 0.35, 0.35);\n\n  if (t == -1.0)\n  {\n    color = backColor;\n  }\n  else\n  {\n      vec3 pos = rayOrigin + rayDir * t;\n      //vec3 objectSurfaceColour = vec3(0.9, 0.7, 0.7);\n      vec3 objectSurfaceColour = vec3(1.0, 1.0, 1.0);\n      vec3 ambient = vec3(0.02, 0.021, 0.02);\n      vec3 N = calcNormal(pos);\n\n      vec4 lightInfo = getLightPos();\n      vec3 light = lightInfo.xyz - pos;\n      float d = length(light);\n      vec3 L = normalize(light);\n\n      if(d < lightInfo.w * 1.01)\n      {\n        color = vec3(1.0, 1.0, 1.0);        \n      } \n      else\n      {\n        float intensity = 0.4 + (1.0 + sin( iTime * LIGHT_SPEED * 2.0 )) * 0.0;\n        intensity *= 0.5 / clamp((d * d), 0.0, 1.0);\n        // L is vector from surface point to light, N is surface normal. N and L must be normalized!\n        float NoL = max(dot(N, L), 0.0);\n        vec3 LDirectional = vec3(0.9, 0.9, 0.8) * NoL;\n        vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n\n        float shadowCast = castRay(lightInfo.xyz - L * (lightInfo.w + 0.5), -L);\n        if(shadowCast <= (d - (lightInfo.w + 0.51)))\n          intensity *= 0.3;\n\n        vec3 diffuse = objectSurfaceColour * (LDirectional + LAmbient) * intensity;\n\n        color = mix(diffuse, backColor, saturate(t / 200.0));\n      }\n  }\n\n  color = pow(color, vec3(0.4545));\n  debugPlane(color, rayOrigin, rayDir, 5.0);\n \t\n  return color;\n}\n\nvec3 calculateCameraPos()\n{  \n  return vec3(iTime * SPEED * 12.0, 3.0, 6.0);\n}\n\nvec2 barrelDistortion(vec2 uv, float k)\n{\n  float rd = length(uv);    \n  float ru = rd * (1.0 + k * rd * rd);\n  uv /= rd;\n  uv *= ru;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec3 cameraPos = calculateCameraPos();\n  vec3 lookAt =  cameraPos + vec3(10.0, 0.0, 0.0);\n\n  vec2 uv = normalizeScreenCoords(fragCoord);  \n  uv = barrelDistortion(uv, 0.25);\n\n  vec3 rayDir = getCameraRayDir(uv, cameraPos, lookAt);\n    \n  vec3 col = render(cameraPos, rayDir);\n    \n  fragColor = vec4(col,1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}