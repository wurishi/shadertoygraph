{"ver":"0.1","info":{"id":"wtVSDW","date":"1582857435","viewed":99,"name":"material test","username":"pedrofuentes","description":"testing shading, SSS, and soft SDF based shadows","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sss","sdf","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map(vec3 p){\n    p -= vec3(0,0,8.0f);\n    float sint = sin(iTime*3.4f*.25f)*.25f;\n    p.xz *= rotAxis(iTime*.5f);\n    float times = 5.;\n    float blob = length(p + vec3(sin(p.x*times)*sint, sin(p.y*times)*sint,sin(p.z*times)*sint))-1.5f;\n\tfloat sph = length(p-vec3(0,-78,0))-75.;\n    \n    return min(blob, sph);\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e = vec2(0.001f,0.0f);\n\treturn normalize(vec3(\n        \tmap(p + e.xyy) - map(p - e.xyy),\n            map(p + e.yxy) - map(p - e.yxy),\n            map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid raymarch(vec3 ro, vec3 rd, out float t, out vec3 p){\n    t=0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        p = ro + t * rd;\n        float d = map(p);\n        if(d < MIN_DIST) break;\n        t+=d;\n        if(t > MAX_DIST) break;\n    }\n}\n\nfloat shadowFactor(vec3 ro, vec3 rd){\n\tfloat minD = 1.;\n    float t = MIN_DIST;\n    for(int i = 0; i < MAX_STEPS; i++){\n    \tfloat d = map(ro + rd*t);\n        minD = min(minD, MAX_DIST * d/t);\n        if(minD < MIN_DIST) break;\n        t += clamp(d, MIN_DIST, .25);\n    }\n   \n    return clamp(minD,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse/iResolution.xyxy;\n    vec3 ro = vec3(0,0,2);\n    vec3 rd = normalize(vec3((2.0*fragCoord - iResolution.xy)/iResolution.y, 1.5f));\n    float t;\n    vec3 p;\n    vec3 nor = vec3(0.,0.,0.);\n    \n    \n    vec3 col = vec3(0.,0.,0.);\n    \n    raymarch(ro, rd, t, p);\n    \n    vec3 sunCol = vec3(.95,.98,.85);\n    vec3 skyCol = vec3(.25,.2,.8);\n    vec3 grassCol = vec3(.3,.4,.2);\n    float fresnel = clamp(1.-dot(-rd,nor),0.,1.);\n    //lightByMouse\n    \n    vec3 lightDir = normalize(vec3(.3f,.3f,.8f));\n    \n    //fake light for when no mouse is ever been used\n    if(mouse.x < 0.01 && mouse.y < 0.01){\n    \tmouse.x = .9;\n        mouse.y = .9;\n    }\n    \n\tlightDir.xz *= rotAxis((mouse.x/2.+1.)*3.14);\n    lightDir.zy *= rotAxis((mouse.y/2.+1.)*3.14 + .23f);\n    \n    //normal\n    if(t < MAX_DIST)\n    \tnor = calcNormal(p);\n    \n    //material diffuse vs specular factor\n    float specF = .5f;\n    float diffF = 1.-specF;\n    \n    //ambient top\n    col += skyCol * clamp(dot(vec3(0,1,0), nor),0.0f,1.0f) * diffF;\n    \n    //ambient bottom\n    col += grassCol * 0.5f * clamp(dot(vec3(0,-1,0), nor),0.0f,1.0f) * diffF;\n\t    \n    //soft shadow factor\n    float sf = shadowFactor(p+.1*nor, lightDir);\n\n    //diff direct\n    col += sf * sunCol * clamp(dot(lightDir, nor),0.0f,1.0f)*diffF;\n    \n    //spec direct\n    vec3 spec = sf * fresnel * sunCol * clamp(dot(lightDir, reflect(rd, nor)),0.,1.);\n    \n    vec3 sssCol = vec3(0.83,.48,0.75);\n    if(t < 32.)//if its a solid object\n    {\n        if(p.y>-2.){//if it's the upper object\n            //SSS\n            rd = refract(rd, nor, 1.0/1.5);\n            float sssStep = 0.;\n            float sssT = .1;\n            rd = -lightDir;\n            for(float i = 0.; i < MAX_SSS_STEPS; i++){\n                sssStep += map(p + sssT*rd);\n                sssT += .1;\n            }\n            float sssCont = 1.-sssStep/MAX_SSS_STEPS;\n            sssCont *= sssCont;\n            sssCont = clamp(sssCont,0.,1.);\n\n            col += vec3(sssCont,sssCont,sssCont) * sssCol * sunCol;\n            //kind of real looking specular shine\n            col += spec*spec*specF;\n        }\n        else {\n            //the floor has a very unreal art directed specular shine\n        \tcol += spec * spec;\n        }\n\t}\n    else{\n        //cool background radial gradients\n        col += vec3(.7,.3,.8) * clamp(dot(-lightDir,rd), 0.,1.)*3.;\n        col += spec * spec;\n        t = 32.;\n    }\n    \n    //contrast color grading\n    col=mix(col,col*col*col,.75);\n    \n    //uniform color grading\n    col += vec3(.1,.3,.45)*.35;\n    \n    //depth... just for postprocessing if i feel like im going to do focus lens VFX or something\n    float depth = t/MAX_DIST;\n    \n    fragColor = vec4(col,depth);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define time iTime;\n\nconst float MAX_DIST = 32.0f;\nconst int MAX_STEPS = 128;\nconst float MIN_DIST = 0.001f;\nconst float MAX_SSS_STEPS = 16.0f;\n\nmat2 rotAxis( float t){\n\tfloat s = sin(t);\n    float c = cos(t);\n    return mat2(c,-s,s,c);\n}","name":"Common","description":"","type":"common"}]}