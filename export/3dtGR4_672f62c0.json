{"ver":"0.1","info":{"id":"3dtGR4","date":"1567945657","viewed":271,"name":"3D Mobius Transform","username":"skye_adaire","description":"Uses the 3D Mobius transform to invert the model. Distance estimations are taken in the local space of the 4D hypersphere. The hypersphere is performing a single rotation in the YW plane. See my other shaders for more background.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["julia","mobius","quaternion","dual","set","automatic","hypercomplex","differentiation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define Quaternion vec4\n\nQuaternion H_negate(Quaternion h)\n{\n    return -h;\n}\n\nQuaternion H_conjugate(Quaternion h)\n{\n    return Quaternion(h[0], -h[1], -h[2], -h[3]);\n}\n\nReal H_sqnorm(Quaternion h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Quaternion h)\n{\n    return length(h);\n}\n\nQuaternion H_inverse(Quaternion h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nQuaternion H_normalize(Quaternion h)\n{\n    return normalize(h);\n}\n\nQuaternion H_add(Quaternion lhs, Quaternion rhs)\n{\n    return lhs + rhs;\n}\n\nQuaternion H_subtract(Quaternion lhs, Quaternion rhs)\n{\n    return lhs - rhs;\n}\n\nQuaternion H_multiply(Quaternion lhs, Quaternion rhs)\n{\n    Complex lhs_0 = Complex(lhs[0], lhs[1]);\n    Complex lhs_1 = Complex(lhs[2], lhs[3]);\n    Complex rhs_0 = Complex(rhs[0], rhs[1]);\n    Complex rhs_1 = Complex(rhs[2], rhs[3]);\n\n    return Quaternion(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nQuaternion H_divide(Quaternion lhs, Quaternion rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Quaternion h)\n{\n    return H_norm(h) < eps32;\n}\n\nstruct PolarQuaternion\n{\n    Real norm;\n    Real angle;\n    vec3 axis;//normalized\n};\n\nPolarQuaternion H_toPolar(Quaternion h)\n{\n    PolarQuaternion result;\n    Real vectorLength2 = dot(h.yzw, h.yzw);\n\n    if(H_isZero(vectorLength2))\n    {\n        result.axis = vec3(0);\n    }\n    else//normalize the vector part\n    {\n        result.axis = h.yzw / sqrt(vectorLength2);\n    }\n\n    result.norm = sqrt(H_sq(h[0]) + vectorLength2);\n\n    if(H_isZero(result.norm))\n    {\n        result.angle = 0.0;\n    }\n    else\n    {\n        result.angle = acos(h[0] / result.norm);\n    }\n\n    return result;\n}\n\nQuaternion H_toCartesian(PolarQuaternion p)\n{\n    return p.norm * Quaternion(cos(p.angle), sin(p.angle) * p.axis);\n}\n\nQuaternion H_versor(Real angle, vec3 axis)\n{\n    return H_toCartesian(PolarQuaternion(1.0, angle / 2.0, axis));\n}\n\nPolarQuaternion H_power(PolarQuaternion polar, Real exponent)\n{\n    polar.norm = pow(polar.norm, exponent);\n    polar.angle = polar.angle * exponent;\n    return polar;\n}\n\nQuaternion H_power(Quaternion h, Real exponent)\n{\n    if(H_isZero(exponent))\n    {\n        return Quaternion(1,0,0,0);\n    }\n    else\n    {\n        return H_toCartesian(H_power(H_toPolar(h), exponent));\n    }\n}\n\nQuaternion H_sq(Quaternion h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\n#define DualQuaternion mat2x4\n\nDualQuaternion D_add(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs + rhs;\n}\n\nDualQuaternion D_subtract(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs - rhs;\n}\n\nDualQuaternion D_multiply(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualQuaternion D_divide(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualQuaternion D_power(DualQuaternion d, Real exponent)\n{\n    return DualQuaternion(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\n//the 3-plane centered at the origin with normal 0, 0, 0, 1\nbool intersectHyperplane(vec4 rayPosition, vec4 rayDirection, out float t)\n{\n    t = -rayPosition[3] / rayDirection[3];\n\n    return t > 0.0 && !isinf(t);\n}\n\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the sphere centered at the origin with radius 1\nbool intersectHypersphere(vec4 rayPosition, vec4 rayDirection, out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayPosition);\n    float c = dot(rayPosition, rayPosition) - 1.0;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nmat3 rotation3XZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat4 rotation4YW(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n        1, 0, 0, 0,\n        0, c, 0, -s,\n        0, 0, 1, 0,\n        0, s, 0, c);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat getJuliaDE(DualQuaternion dd, vec3 inPosition, out vec3 outNormal, out int i)\n{\n    Quaternion c = Quaternion(inPosition, 0);\n\n    //directional derivatives\n    DualQuaternion dx = DualQuaternion(c, Quaternion(1,0,0,0));\n    DualQuaternion dy = DualQuaternion(c, Quaternion(0,1,0,0));\n    DualQuaternion dz = DualQuaternion(c, Quaternion(0,0,1,0));\n\n    for(i = 0; i <= 20; i++)\n    {\n        if(H_sqnorm(dx[0]) > 16.0)\n        {\n            break;\n        }\n\n        dx = D_add(D_multiply(dx, dx), dd);\n        dy = D_add(D_multiply(dy, dy), dd);\n        dz = D_add(D_multiply(dz, dz), dd);\n    }\n\n    //the final position is the same for all partials\n    vec3 fp = dx[0].xyz;\n    float r = H_norm(dx[0]);\n    \n    float dr = length(vec3(H_norm(dx[1]), H_norm(dy[1]), H_norm(dz[1])));\n    outNormal = normalize(vec3(dot(fp, dx[1].xyz), dot(fp, dy[1].xyz), dot(fp, dz[1].xyz)));\n\n  \t//return 0.5 * log(r) * r / dr;//better for low iteration counts\n    return 0.5 * r / dr;\n}\n\nvec3 mobius(vec3 p, vec4 pole, vec4 translationInv, mat4 rotationInv)\n{\n    //geometric stereo projection\n    vec4 p4 = vec4(p, 0);\n    vec4 d4 = normalize(pole - p4) * (length(p4) < 1.0 ? -1.0 : 1.0);\n        \n    //transform the ray to sphere space\n    vec4 p4t = rotationInv * (translationInv + p4);\n    vec4 d4t = rotationInv * d4;\n\n    float ts;\n    intersectHypersphere(p4t, d4t, ts);//must hit\n\n    //stereo intersect the sphere's local hyperplane\n    vec4 p4s = p4t + ts * d4t;\n    vec4 d4s = normalize(vec4(0,0,0,1) - p4s);\n\n    float tp;\n    intersectHyperplane(p4s, d4s, tp);//must hit\n\n    return vec3(p4s + tp * d4s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //view basis\n    mat3 viewTransform = rotation3XZ(iTime * 0.1);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 2);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n    \n    //transform hypersphere local to global\n    float angle = iTime * 0.4;\n    mat4 rotation = rotation4YW(angle);\n    vec4 translation = vec4(0, 0, 0, 0);//1.0 + cos(iTime*0.4 + tau32/2.0));\n    vec4 pole = translation + vec4(0, 0, 0, 1);\n    \n    //transform hypersphere global to local\n    mat4 rotationInv = rotation4YW(-angle);\n    vec4 translationInv = -translation;\n    vec4 poleInv = vec4(0, 0, 0, 1);\n    \n    //julia constant\n    float time = 0.2 * iTime;\n    float ct = cos(time);\n    float st = sin(time);\n    Quaternion d = Quaternion(0, ct, st, 0);\n    DualQuaternion dd = DualQuaternion(d, Quaternion(0));\n\n    //ray march the distance field\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    \n    //last julia outputs\n    int iEscape;\n    vec3 globalNormal;\n    \n    for(i = 0; i < 400; i++)\n    {\n        p = srp + t * srd;\n        \n        p = mobius(p, pole, translationInv, rotationInv);\n        \n        float de = getJuliaDE(dd, p, globalNormal, iEscape);\n        \n        if(de < 0.001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    //color the intersection\n    vec4 color = vec4(0);\n    \n    if(hit)\n    {\n        float escape = 0.7 * float(iEscape) / float(20) + 0.2;\n        vec3 surfaceColor = hsv2rgb(vec3(escape, 1, 1));\n\n        vec3 bottomLightDirection = normalize(vec3(-1,-1,-1));\n        vec3 bottomLight = 0.6 * clamp(dot(globalNormal, bottomLightDirection), 0.0, 1.0) * vec3(1, 1, 1);\n        color += vec4(bottomLight * surfaceColor, 1);\n\n        vec3 spotLight1Position = vec3(10);\n        vec3 spotLight1Color = 1.5 * vec3(1, 1, 1);\n        vec3 spotLight1Direction = normalize(spotLight1Position - p);\n        float spotLight1Incidence = clamp(dot(globalNormal, spotLight1Direction), 0.0, 1.0);\n        float spotLight1Blocked = 1.0;\n        vec3 spotLight = spotLight1Blocked * spotLight1Incidence * spotLight1Color;\n        color += vec4(spotLight * surfaceColor, 1);\n    }\n    \n    color = pow(color, vec4(0.4545));\n    \n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"}]}