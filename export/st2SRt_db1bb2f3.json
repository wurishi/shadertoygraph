{"ver":"0.1","info":{"id":"st2SRt","date":"1628416571","viewed":74,"name":"For Winnie","username":"caorenxxy","description":"For Winnie","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hearsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://mathworld.wolfram.com/HeartSurface.html\n\nfloat f(vec3 p) {\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\nfloat f1(vec3 p) {\n    p = p - vec3(-1.5, 0.0 , 0.0);\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\nfloat f2(vec3 p) {\n    p = p - vec3(1.5, 0.0 , 0.0);\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\nfloat bin(float x, float z){\n\tfloat left = 0.0, right = 1.0, mid;\n    for(int i = 0; i < 15; ++i){\n    \tmid = (left + right) * 0.5;\n        if(f(vec3(x, mid, z)) <= 0.0)\n            left = mid;\n        else \n            right = mid;\n    }\n    return mid;\n    \n}\n\n//binary search for intersection\nfloat bin1(float x, float z){\n\tfloat left = 0.0, right = 1.0, mid;\n    for(int i = 0; i < 15; ++i){\n    \tmid = (left + right) * 0.5;\n        if(f1(vec3(x, mid, z)) <= 0.0)\n            left = mid;\n        else \n            right = mid;\n    }\n    return mid;\n    \n}\n\nfloat bin2(float x, float z){\n\tfloat left = 0.0, right = 1.0, mid;\n    for(int i = 0; i < 15; ++i){\n    \tmid = (left + right) * 0.5;\n        if(f2(vec3(x, mid, z)) <= 0.0)\n            left = mid;\n        else \n            right = mid;\n    }\n    return mid;\n    \n}\n\n// Analytical gradient\n// (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2) \n// (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)\n// (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))\nvec3 normal(vec2 p) {\n    vec3 v = vec3(p.x, bin(p.x, p.y), p.y);\n    vec3 vv = v * v;\n    vec3 vvv = vv * v;\n    float a = -1.0 + dot(vv, vec3(1, 2.25, 1));\n   \ta *= a;\n    \n  \treturn normalize(vec3(\n        -2.0 * v.x * vvv.z +  6.0 * v.x * a,\n      -0.225 * v.y * vvv.z + 13.5 * v.y * a,\n      v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));\n}\n\n//numeric gradient\nvec3 normal1(vec2 p){\n\tvec3 v = vec3(p.x, bin1(p.x, p.y), p.y);\n    float delta = 0.00005;\n    float gradx = (f1(vec3(v.x + delta, v.y, v.z)) - f1(vec3(v.x - delta, v.y, v.z))) / (2.0 * delta);\n    float grady = (f1(vec3(v.x, v.y + delta, v.z)) - f1(vec3(v.x, v.y - delta, v.z))) / (2.0 * delta);\n    float gradz = (f1(vec3(v.x, v.y, v.z + delta)) - f1(vec3(v.x, v.y, v.z - delta))) / (2.0 * delta);\n    return normalize(vec3(gradx, grady, gradz));\n}\n\nvec3 normal2(vec2 p){\n\tvec3 v = vec3(p.x, bin2(p.x, p.y), p.y);\n    float delta = 0.00005;\n    float gradx = (f2(vec3(v.x + delta, v.y, v.z)) - f2(vec3(v.x - delta, v.y, v.z))) / (2.0 * delta);\n    float grady = (f2(vec3(v.x, v.y + delta, v.z)) - f2(vec3(v.x, v.y - delta, v.z))) / (2.0 * delta);\n    float gradz = (f2(vec3(v.x, v.y, v.z + delta)) - f2(vec3(v.x, v.y, v.z - delta))) / (2.0 * delta);\n    return normalize(vec3(gradx, grady, gradz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 p = vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0);\n    \n    float s = sin(iTime * 5.0);\n    s *= s;\n    s *= s;\n    s *= 0.08;\n    vec3 tp = p * vec3(1.0 + s, 1.0 - s, 0.0) * 2.0;\n    \n    vec3 c;\n    if (f1(tp.xzy) <= 0.0) {\n        vec3 n = normal1(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 32.0);\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        c = diffuse * vec3(1.0, 0.0, 0.0) + specular * vec3(0.8) + rim * vec3(0.5);\n    }\n\telse if (f2(tp.xzy) <= 0.0) {\n        vec3 n = normal2(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 32.0);\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        c = diffuse * vec3(1., 0.0, 0.0) + specular * vec3(0.8) + rim * vec3(0.5);\n    }\n    else    c = vec3(1.0, 0.8, 0.7 - 0.07 * p.y) * (1.0 - 0.15 * length(p));\n    \n\tfragColor = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}