{"ver":"0.1","info":{"id":"slyfDV","date":"1665258217","viewed":58,"name":"Simple 3d scene (Raymarching)","username":"azeem","description":"Learning shaders :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"NlKBzt","parentname":"Basic RayMarching using SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 32  //increase it for good result but bad performance\n#define MAX_DIST 50\n#define PI 3.14159265359\n#define cameraZ 1.5    //decrease it to move camera forward\nfloat weirdStructure(float y,vec3 p){    \n    float fd;\n    float h1=.13;\n    float w1=.026;\n    float b1=w1;\n    vec3 s1=vec3(0.05,y+h1+.01,-0.1);\n    float d1=roundBoxSDF(p,s1,vec3(w1,h1,b1), w1/5.);\n    float n=6.;\n    for(float i=1.0;i<n-.001;i++){\n        vec3 s2=vec3(s1.x,s1.y-h1+2.*h1*i/n,s1.z);\n        float w2=w1*1.3;\n        float b2=b1/(2.5+.75*sin(iTime));\n        float h2=b2;\n        float d2=roundBoxSDF(  vec3(p.x,p.y,p.z),s2,vec3(w2,h2,b2),0.);\n        float d3=roundBoxSDF( vec3(p.x,p.y,p.z),s2,vec3(b2,h2,w2),0.);\n        fd=smin(fd,min(d2,d3),.015);\n    }\n    d1=smin( d1, sphSDF(p,vec3(s1.x,s1.y+.21,s1.z),.08),.06);\n    return smax(d1,-fd,.01);\n}\nfloat fourBalls(float y, vec3 p){\n    float h=.07;\n    vec3 centre=vec3(-0.15,y+.025+h,0.1);\n    centre=p-centre;\n    float t=iTime*.5;\n    centre.xz*=mat2(cos(t),sin(t),-sin(t),cos(t));\n    centre=p+centre;\n    float r=0.008;\n    float radii=h;//.1;\n    vec3 b1=vec3(centre.x,centre.y+radii*sin(iTime),centre.z+radii*cos(iTime ) );\n    float d1= sphSDF(p,b1,r);\n    \n    vec3 b2=vec3(centre.x+radii*cos(iTime),centre.y,centre.z+radii*sin(iTime) );\n    float d2= sphSDF(p,b2,r); \n    \n    vec3 box=vec3( centre.xyz     );\n    float d3=cubeBoxSDF(p,box,vec3(radii*1.1),radii/30.);\n    return min(d3,min(d1,d2));\n}\nvec2 distanceToScene(vec3 p){\n    vec2 fd;\n    //four legs\n    vec3 s1=vec3(.2,0.0-.02,0.2);\n    float h1=.4;\n    float r1=0.03;\n    s1.y-=h1/2.;\n    float d1=capSDF(vec3(abs(p.x),p.y,abs(p.z)),s1,h1,r1);\n    \n    //table top  id 2\n    vec3 s2=vec3(0.,h1/2.+.03,0.);\n    float ra2=.2;\n    float rb2=0.002;\n    float h2=0.01;\n    float d2=roundCylSDF(p,s2,ra2,rb2,h2);\n    fd=vec2(smin(d1,d2,.05),2.);\n    \n    //bowl id 3\n    vec3 s3=vec3(0.15,s2.y+.165,0.2);\n    float r3=0.14;\n    float h3=s3.y-.5;\n    float t3=0.007;\n    float d3=hollowSphSDF(p,s3,r3,h3,t3);\n    fd=vec2(min(fd.x,d3),fd.x<d3?fd.y:3.0);\n   \n    //four balls id 4\n    float d4=fourBalls(s2.y,p);\n    fd=vec2(min(fd.x,d4),fd.x<d4?fd.y:4.0);\n    \n    //whatever that is id 5\n    float d5=weirdStructure(s2.y,p);\n    fd=vec2(min(fd.x,d5),fd.x<d5?fd.y:5.0);\n    \n    //plane id 6\n    float plane=p.y+.02*simplex3d(p*10.)+.25;\n    return vec2(min(fd.x,plane),fd.x<plane?fd.y:6.);\n}\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(distanceToScene(p+h.xyy).x - distanceToScene(p-h.xyy).x,\n                           distanceToScene(p+h.yxy).x - distanceToScene(p-h.yxy).x,\n                           distanceToScene(p+h.yyx).x - distanceToScene(p-h.yyx).x ) );\n}\nvec2 marchRay(vec3 rayO, vec3 rayD){\n    float dis=0.;\n    float id;\n    vec2 d;\n    vec3 p=rayO+rayD*dis;\n    for(int i=0;i<STEPS;i++){\n        p = rayO+rayD*dis;\n        d=distanceToScene( p);\n        if(abs(d.x)<.001)break;\n        dis+=d.x;\n        if( int(dis)> MAX_DIST)break;\n    }\n    return vec2(dis,d.y);\n}\nfloat checkShadow(vec3 rayO,vec3 rayD){\n    float dis=0.;\n    float closestDist=1e4;//for soft shadows\n    vec3 p=rayO+rayD*dis;\n    for(int i=0;i<STEPS;i++){\n        p = rayO+rayD*dis;\n        float d=distanceToScene(p).x;\n        closestDist=min(closestDist,5.*d/dis);\n        if(d<.001)break;\n        dis+=d;\n        if( int(dis)> MAX_DIST)break;\n    }\n    return int(dis)>MAX_DIST?smoothstep(0.00001,.3,closestDist):0.0;\n    return int(dis)> MAX_DIST?1.:0.0; //normal shadow\n}\nvec3 getColor(float y){\n    if(y<1.5)return vec3(.2,.8,.6);\n    else if(y<2.5)return vec3(164,116,73)/255./2.5;\n    else if(y<3.5) return vec3(.8,.1,.0)/2.5;\n    else if(y<4.5) return vec3(.2,.3,.9);\n    else if(y<5.5) return vec3(.3,.6,.6)/1.8;\n    else if(y<6.5) return vec3(.3);\n    else vec3(0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 rayO = vec3(0., 0.8, cameraZ);//camera pos\n    vec3 lookPoint = vec3(0);//where to look\n    float zoom=1.;\n    \n    //mouse camera binding//copied\n    vec2 mouseUV = iMouse.xy/iResolution.xy;if (mouseUV == vec2(0.0)||iFrame<1) mouseUV = vec2(0.5);float cameraRadius = 1.;rayO.yz = rayO.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));rayO.xz = rayO.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lookPoint.x, lookPoint.z);\n    vec3 rayD= camera(rayO, lookPoint) * normalize(vec3(uv, -zoom)); // ray direction\n\n    vec3 col=vec3(.0);\n\n    vec2 dis=marchRay(rayO,rayD);\n    vec3 p=rayO+dis.x*rayD;\n    if(int(dis.x)<MAX_DIST){\n        vec3 mate=getColor(dis.y);\n        vec3 normal=calcNormal(p);\n        vec3 light_dir = normalize(vec3(.6, .3, .8));       \n        //orbiting sun\n        light_dir = normalize(vec3(sin(iTime*.5), .4, cos(iTime*.5)));\n        vec3 light_col=vec3(7.,5.,3.);\n        float light_dif = clamp(dot(normal, light_dir),0.,1.);\n        float isShadow=checkShadow(p+normal*0.01,light_dir);\n        col= mate*light_dif*light_col*isShadow;\n\n        vec3 sky_col=vec3(0.5,0.8,0.9);//sky light, is everywhere from above\n        float sky_dif=clamp((.5+.5*dot(normal,vec3(0.,1.,0.))),0.,1.0);\n        col+=mate*sky_col*sky_dif;\n\n        vec3 bou_col=vec3(.4);//bouncing light against the plane\n        float bou_dif=clamp( (.5+.5*dot(normal,vec3(0.,-1.,0.)) ),0.,1.0);\n        col+= mate*bou_dif*bou_col;\n    }\n    col/=max(pow(length(p-rayO)/4.,3.),1.);\n    col = pow( col, vec3(1.0/2.2) );//gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float roundBoxSDF( vec3 p,vec3 c, vec3 b, float r )\n{\np=p-c;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat capSDF( vec3 p,vec3 c, vec3 a, vec3 b, float r )\n{\np=p-c;\nvec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat cubeBoxSDF( vec3 p,vec3 c, vec3 b, float e )\n{\n    p=p-c;\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}float octSDF( vec3 p,vec3 c, float s)\n{\n  p = abs(p-c);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}float hollowSphSDF( vec3 p,vec3 c, float r, float h, float t )\n{\n  p=p-c;\n  //h=h-p.y;//don't know if this line  works or not\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat roundCylSDF( vec3 p,vec3 c, float ra, float rb, float h )\n{\n  p=p-c;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat capSDF( vec3 p, vec3 c, float h, float r )\n{\n  p.y -= clamp( p.y-c.y, 0.0, h );\n  return length( p-c ) - r;\n}float priSDF( vec3 p,vec3 c, vec2 h )\n{\n  vec3 q = abs(p-c);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}const float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = max( k-abs(a-b), 0.0 )/k;\nreturn min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nfloat smin2( float a, float b, float k )\n{\nfloat res = exp2( -k*a ) + exp2( -k*b );\nreturn -log2( res )/k;\n}\nvec2 hash( vec2 p ) // replace this by something better\n{\np = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\nreturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\nconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\nconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\nvec2  i = floor( p + (p.x+p.y)*K1 );\nvec2  a = p - i + (i.x+i.y)*K2;\nfloat m = step(a.y,a.x); \nvec2  o = vec2(m,1.0-m);\nvec2  b = a - o + K2;\nvec2  c = a - 1.0 + 2.0*K2;\nvec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\nvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\nreturn dot( n, vec3(70.0) );\n}\nfloat interPlane(vec3 n, float s, vec3 rayO, vec3 rayD) \n{ \nreturn (s-dot(rayO,n))/dot(rayD,n);\n}\nfloat smax(float a, float b, float k){\nreturn -smin(-a,-b,k);\n}\nfloat planeSDF( vec3 p, vec3 n, float h )\n{\nvec3 m=normalize(n);\nreturn dot(p,m) + h;\n}\nfloat cubeSDF(vec3 p, vec3 c, float s){\nvec3 q = abs(p-c) - s;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sphSDF(vec3 p,vec3 c,float r){\n//float cc=0.003;\n//p+=  cc*simplex3d(p*50.);\nreturn length(p-c)-r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}