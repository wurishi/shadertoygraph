{"ver":"0.1","info":{"id":"XfG3RK","date":"1712944899","viewed":51,"name":"center cloud","username":"cabbibo","description":"a cloud at the center of things\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Understanding spikey ball\" by cabbibo. https://shadertoy.com/view/XljXzy\n// 2024-04-12 17:57:31\n\n/*\n\n\n\tTrying to understand the spikey cloud ball shader:\n\thttps://www.shadertoy.com/view/MljXDw\n\n\n*/\n\n// port from http://glslsandbox.com/e#1802.0 with some modifications\n//--------------\n// Posted by las\n// http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*/\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n// Getting a few different noises\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n\n\nfloat spikeball(vec3 p) {\n   vec3 q=p;\n   p = normalize(p);\n\n    \n   //b = length( p ) - .5;\n   return length(q)-2.5;//*pow(1.5,b.x*(1.-mix(.3, 1., sin(iTime*2.)*.5+.5)*b.x));\n}\n\nfloat map(vec3 p) {\n   p.z += 6.;\n  // R(p.xy, iTime);\n   //R(p.xz, iTime);\n   return -spikeball(p * .1) + spikeball(p)+  fpn(p*10. + vec3(0.,0.,-iTime *4.)) * 3.45 +  fpn(p*50. + vec3(0.,0.,-iTime *20.)) * 1.45+  fpn(p*200. + vec3(0.,0.,-iTime *40.)) * .45;\n}\n\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),map(p+e.yxy) - map(p-e.yxy),map(p+e.yyx) - map(p-e.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,5.);\n   vec3 d = vec3((gl_FragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n  // d *=1;\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./128.) {\n\t   if(!((i<1.) && (l>=0.001*r) && (r < 10.)&& (td < .95)))\n\t\t   break;\n      \n      // evaluate distance function\n      l = map(p) * 0.2;\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      const float h = .4;\n      ld = (h - l) * step(l, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w* hsv( w * w * 5. , 1. , w * w * 50. ); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./1000.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.03);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }     \n   \n   //tc /= 3.;\n      \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}","name":"Image","description":"","type":"image"}]}