{"ver":"0.1","info":{"id":"ltjSzR","date":"1441142128","viewed":609,"name":"Magic Box Movement","username":"Mx7f","description":"Magic box (https://www.shadertoy.com/view/4ljGDd) with varying parameters","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["fractal","magicbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\n// Modified to have varying parameters\n\nconst int MAGIC_BOX_ITERS = 13;\n\n#define PI 3.14159265\nfloat magicBox(vec3 p, float magic) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - magic;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nmat3 xRot(float a)\n{\n \treturn mat3(1, \t\t0, \t\t0,\n               0, \t\tcos(a), -sin(a),\n               0,\t\tsin(a),\tcos(a));\n}\n\nmat3 yRot(float a)\n{\n \treturn mat3(cos(a), \t\t0, \t\t-sin(a),\n               0, \t\t\t1, \t\t0,\n               sin(a),\t\t0,\t\tcos(a));\n}\n\nmat3 zRot(float a)\n{\n \treturn mat3(cos(a), -sin(a),\t\t0,\n               sin(a),\tcos(a),\t\t0,\n              \t0,\t\t0,\t\t\t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    float t = (iTime+25.0)*0.02;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += t*5.0;\n\n    \n    float alpha = (sin(t)+1.0 * PI);\n    float beta = (sin(t)+1.0 * PI);\n    float gamma = (sin(t)+1.0 * PI);\n    \n    // A varying 3x3 unitary matrix, used to avoid artifacts from slicing the\n\t// volume along the same axes as the fractal's bounding box. \n    mat3 M = xRot(alpha) * yRot(beta) * zRot(gamma);\n    float MAGIC_BOX_MAGIC = sin(t*10.0)*0.2 + 0.5;\n    \n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    \n    float result1 = magicBox(p, MAGIC_BOX_MAGIC);\n    \n    mat3 M2 = xRot(alpha+0.1) * yRot(beta+0.1) * zRot(gamma+0.1);\n    mat3 M3 = xRot(alpha+0.2) * yRot(beta+0.4) * zRot(gamma+0.5);\n    \n    vec3 p2 = 0.5*M2*vec3(uv, 0.0);\n    vec3 p3 = 0.5*M3*vec3(uv, 0.0);\n    \n    float result2 = magicBox(p2, MAGIC_BOX_MAGIC);\n    float result3 = magicBox(p3, MAGIC_BOX_MAGIC);\n    \n    vec3 result = vec3(result1, result2, result3) * 0.03;\n    \n\tfragColor = vec4(result,1.0);\n}","name":"","description":"","type":"image"}]}