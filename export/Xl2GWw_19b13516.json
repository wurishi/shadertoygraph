{"ver":"0.1","info":{"id":"Xl2GWw","date":"1429533160","viewed":119,"name":"_rayMarcher_cr_DE","username":"foad1989","description":"rm_cr_DE","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rmcrde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define degToRad(x) x * pi * inv_180\n#define prec 0.0001\n#define epsilon vec3(0.0, prec, 0.0)\n// #define CRUDE\nconst float pi = 3.14159265359;\nconst float inv_pi = 0.31830988618;\nconst float inv_180 = 0.00555555555;\nconst int sierp_iters = 10;\n\nfloat sierp_DE(in vec3 p)\n{\n    vec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = sierp_iters;\n    float alpha = 0.5 * iTime;\n    //float alpha = 0.25 * pi;\n\tfloat dist, d;\n    \n    for(int i = 0; i < sierp_iters; i++)\n    {\n        c = a1; dist = length(p-a1);\n\t    d = length(p-a2); if (d < dist) { c = a2; dist=d; }\n\t\td = length(p-a3); if (d < dist) { c = a3; dist=d; }\n\t\td = length(p-a4); if (d < dist) { c = a4; dist=d; }\n        p = p - c;\n        //p.x = p.x * cos(alpha) - p.y * sin(alpha);\n        //p.y = p.y * cos(alpha) + p.x * sin(alpha);\n        p = 2.0*p-c;        \n\t}\n\treturn length(p) * pow(2.0, float(-n));\n}\nfloat sierp_fold_DE(vec3 z)\n{\n    float r;\n    for(int i = 0; i < sierp_iters; i++) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*2.0 - 1.;\n    }\n    return (length(z)) * pow(2.0, float(-sierp_iters));\n}\n/*float menger_DE(inv vec3 p)\n{\n    \n}*/\n\nfloat unsigned_box_DE(in vec3 p)\n{\n    vec3 abc = vec3(1.0, 1.0, 1.0);\n\treturn length(max(abs(p) - abc, 0.0));\n}\n\nfloat signed_box_DE(in vec3 p)\n{\n    vec3 abc = vec3(1.0, 1.0, 1.0);\n    vec3 d = p - abc;\n    return min(max(max(d.x, d.y), d.z), 0.0) + length(max(d, 0.0));\n}\n\nfloat sphere_DE(in vec3 p) \n{\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    float r = 0.2 + 0.25 * (sin(5.0 * iTime) + 1.0);\n    //float r = 1.0;\n    return length(p - pos) - r;\n}\n\nfloat instance_DE(vec3 p)\n{\n    p.xz = mod(p.xz, 2.0) - vec2(1.0);\n  \treturn sphere_DE(p);\n    //return sierp_DE(p);\n}\n\n\nfloat DE_selector(in vec3 p) \n{\n   \t//return sphere_DE(p);\n    //return box_DE(p);\n    //return sierp_DE(p);\n    return instance_DE(p);\n    //return sierp_fold_DE(p);\n}\n\nvec3 grad_at_p(in vec3 p) {\n    // when calculating de partials we don't devide by 'espsilon' since we \n    // normalize the gradient vector and therefore it has no effect >>> vec3(1/h * (dx, dy, dz)) == vec3(dx, dy, dz)\n\tfloat dx = DE_selector(p + epsilon.yxx) - DE_selector(p - epsilon.yxx);\n    float dy = DE_selector(p + epsilon.xyx) - DE_selector(p - epsilon.xyx);\n    float dz = DE_selector(p + epsilon.xxy) - DE_selector(p - epsilon.xxy);\n    return normalize(vec3(dx, dy, dz));\n}\n\nconst float THRESHOLD = 0.001;\nconst float max_dist = 50.0;\nconst int max_iters = 256;\nvec3 rm(in vec3 ro, in vec3 rd, out bool hit)\n{\n    vec3 p;\n    float distGone = 0.0;\n    for(int i = 0; i < max_iters; i++)\n    {\n        p = ro + rd * distGone;\n        float dist = DE_selector(p);\n        if(abs(dist) <= THRESHOLD || distGone > max_dist)\n            break;\n        distGone += dist;\n    }\n    if(distGone < max_dist) {\n        hit = true;\n        return p;\n    } else {\n        hit = false;\n    \treturn vec3(0.0);\n    }\n}\n\nvec3 rm_crude(in vec3 ro, in vec3 rd, out bool hit) \n{\n    vec3 p;\n\tfloat stepSize = 0.001;\n    float distGone = 0.0;\n    for(int i = 0; i < max_iters; i++)\n    {\n       \tp = ro + rd * distGone;\n        float dist = DE_selector(p);\n        if(dist <= 0.0) {\n         \thit = true;\n            return p;\n        }\n       \tdistGone += stepSize;\n    }\n    hit = false;\n    return vec3(0.0);\n}\n\nfloat kd = 0.5;\nfloat ka = 0.3;\nfloat ks = 1.5;\nvec3 cd = vec3(0.3, 0.1, 0.4);\nvec3 ambient_brdf_rho = ka * cd;\nvec3 diffuse_brdf_f = kd * cd * pi;\nvec3 glossy_brdf_f = ks * cd;\nfloat phong_exp = 100.0;\nvec3 ambient_light_L = vec3(0.1, 1.2, 0.2);\nvec3 directional_light_dir = vec3(0.5773, 0.5773, 0.5773);\nvec3 directional_light_L = vec3(1.5, 1.5, .0);\nvec3 matte(vec3 p, vec3 n) {\n\tvec3 L = ambient_brdf_rho * ambient_light_L;\n    // TODO: for loop many light\n    float ndotwi = dot(n, -directional_light_dir);\n    if(ndotwi > 0.0)\n    {  \n        L += diffuse_brdf_f * directional_light_L * ndotwi;\n    }\n    return L;\n}\n\nvec3 phong(vec3 p, vec3 n, vec3 ro) {\n\tvec3 L = ambient_brdf_rho * ambient_light_L;\n    // TODO: for loop many light\n    vec3 wi = -directional_light_dir;\n    vec3 wo = -ro;\n    float ndotwi = dot(n, wi);\n    if(ndotwi > 0.0)\n    {\n        vec3 r = -wi + 2.0 * n * dot(n, wi);\n        glossy_brdf_f *= pow(max(0.0, dot(r, wo)), phong_exp);\n        L += (diffuse_brdf_f + glossy_brdf_f) * directional_light_L * ndotwi;\n    }\n    return L;\n}\n\nvec3 compute_color(in vec3 ro, in vec3 rd) \n{\n    bool hit = false;\n    vec3 hitPt;\n#ifdef CRUDE\n    hitPt = rm_crude(ro, rd, hit);\n#else\n    hitPt = rm(ro, rd, hit);\n#endif\n    // return hit ? grad_at_p(hitPt) : vec3(0.0);\n    // return hit ? vec3(1.0) : vec3(0.0);\n    // return hit ? matte(hitPt, grad_at_p(hitPt)) : vec3(0.0);\n    return hit ? phong(hitPt, grad_at_p(hitPt), rd) : vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // complete camera system(ortho and pers)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    // vec3 lookat = vec3(0.0, 0.0, 4.0);\n    // vec3 eye = vec3(0.0, 5.0, 3.0);\n    float roll = degToRad(-20. * iTime);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    // GLSL stores in column major\n    mat2 rot = mat2(cos(roll), sin(roll), -sin(roll), cos(roll));\n    up = vec3(rot * up.xy, 0.0);\n    vec3 eye = vec3(2.0 * cos(iTime), 0.0, 2.0 * sin(iTime));\n    // vec3 eye = vec3(0.0, 2.0, 10.0 * iTime);\n    // vec3 eye = vec3(2.0, 0.0, 2.0);\n    vec3 w = normalize(eye - lookat);\n    vec3 u = normalize(cross(up, w));\n \tvec3 v = normalize(cross(w, u));\n    vec2 scale = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 onpln = (uv - vec2(0.5, 0.5)) * scale;\n    // pixel size\n    float psize = 1.0;\n    // distance from view plane\n    float camDistPln = 1.0; \n    vec3 p_ortho = vec3(onpln * psize, camDistPln);\n    vec3 rd_ortho = -w;\n    vec3 rd_pers = normalize(-camDistPln * w + psize * onpln.x * u + psize * onpln.y * v);\n    vec3 color = compute_color(eye, rd_pers);\n    //vec3 color = compute_color(p_ortho, rd_ortho);\n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}