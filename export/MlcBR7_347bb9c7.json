{"ver":"0.1","info":{"id":"MlcBR7","date":"1539054489","viewed":211,"name":"Windwaker water","username":"Veggiebob","description":"Tried to make windwaker water texture. It turned out okay.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["water","textures","windwaker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE 3.\n#define EPSILON 0.001\n#define sky_fade vec3(1., 1., 1)\n#define sun vec3(50., 50., 0.)\n#define suncol  vec3(10., 10., 0.)\n#define nsuncol normalize(suncol)\n#define suncolcontrast 0.5+(nsuncol-0.5)*2.\nstruct Ray {\n    vec3 end;\n    float dist;\n    float material;\n};\n\n//yo this struct Ray messes up the format badly\nvec3 moonTexture (vec3 p){\n    return texture(iChannel2, p.xz).rrr-0.5;\n}\nfloat compoundSine (vec2 v){\n    float x = v.x;\n    float z = v.y;\n\tfloat y = 0.0;\n    //thank you to \n    //https://medium.com/@gordonnl/the-ocean-170fdfd659f1\n    //for nice wave functions (he's pretty creative)\n    y += (sin(x * 1.0 / SCALE + iTime * 1.0) + sin(x * 2.3 / SCALE + iTime * 1.5) + sin(x * 3.3 / SCALE + iTime * 0.4)) / 3.0;\n    y += (sin(z * 0.2 / SCALE + iTime * 1.8) + sin(z * 1.8 / SCALE + iTime * 1.8) + sin(z * 2.8 / SCALE + iTime * 0.8)) / 3.0;\n    //y += texture(iChannel2, v*0.01+rotate2d(vec2(1., 0.), y*0.2-iTime*0.1)*0.5).r*0.05;\n    return y;\n}\nfloat moon (vec3 p){\n    return length(p-vec3(3., 10., -5.))-1.;\n}\nfloat sunsdf (vec3 p) {\n    return length(p-sun)-3.;\n}\nvec2 sdf (vec3 p){\n    float type = 0.;\n    float total = p.y-compoundSine(p.xz);\n    float m = moon(p);\n    if(m<total){\n        total = m;\n        for(float i = 0.; i<3.; i++)\n            total -= texture(iChannel3, p*pow(2., i)*0.1).r*pow(0.5, i)*0.1;\n        type = 1.;\n    }\n    float s = sunsdf(p);\n    if(s<total){\n        total = s;\n        type = 2.;\n    }\n    //total -= (sin(p.y*15.)+1.)*0.1*max(p.y, 0.);\n    return vec2(total, type);\n}\nRay golf (vec3 o, vec3 r){\n    Ray ra;\n    vec3 p = vec3(0.);\n    float d = 0.;\n    float mater = 0.;\n    vec2 s;\n    for(int i = 0; i<72; i++){\n        p = o+r*d;\n        s = sdf(p);\n        d+=s.x*0.9;\n        mater = s.y;\n    }\n    ra.end = p;\n    ra.dist = d;\n    ra.material = mater;\n    return ra;\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)).x - sdf(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sdf(vec3(p.x, p.y + EPSILON, p.z)).x - sdf(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sdf(vec3(p.x, p.y, p.z + EPSILON)).x - sdf(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n//credit to IQ for these functions (especially the no-tiling function)\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\nvec3 textureNoTile( in vec2 x, float v )\n{\n    float k = texture( iChannel2, 0.005*x ).x; // cheap (cache friendly) lookup\n    \n    vec2 duvdx = dFdx( x );\n    vec2 duvdy = dFdx( x );\n    \n    float l = k*8.0;\n    float i = floor( l );\n    float f = fract( l );\n    \n    vec2 offa = sin(vec2(3.0,7.0)*(i+0.0)); // can replace with any other hash\n    vec2 offb = sin(vec2(3.0,7.0)*(i+1.0)); // can replace with any other hash\n\n    vec3 cola = textureGrad( iChannel0, x + v*offa, duvdx, duvdy ).xyz;\n    vec3 colb = textureGrad( iChannel0, x + v*offb, duvdx, duvdy ).xyz;\n    \n    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x-=0.5;\n    mouse*=-1.;\n    uv-=0.5;\n    vec3 camera = vec3(0., 3., 0.);\n    vec3 ray = vec3(uv.x, -1., uv.y);\n    ray.yz = rotate2d(ray.yz, mouse.y*4.);\n    ray.xz = rotate2d(ray.xz, mouse.x*5.);\n    Ray v;\n    vec3 col = vec3(0., 0.5, 1.);\n    v = golf(camera, ray);\n    //float f = smoothstep( 0.4, 0.6, sin(iTime) );//demo\n    if(v.material == 0.)\n        col = textureNoTile(v.end.xz*0.5, 0.6);//get the ocean texture\n    else\n    if(v.material == 1.)\n        col = moonTexture(v.end);\n    else\n    if(v.material == 2.)\n        col = suncol;\n    //col = max(min(col/compoundSine(v.xz), 1.), 0.);\n    //diffusion lighting\n    vec3 normal = estimateNormal(v.end);\n    vec3 toSun = normalize(sun-v.end);\n    col += dot(-ray, normal)*0.4;\n    //col += dot(ray, toSun);\n\n    //specular lighting\n    \n    //viewer speculars\n    //float refdot = dot(reflect(-ray, normal), ray);\n    //col += max(pow(refdot, 4.), 0.)*0.4;\n    \n    //sun speculars\n\tfloat refdot = dot(reflect(ray, normal), toSun);\n    refdot = max(refdot, 0.);\n    col*=0.7;\n    col += pow(refdot, 2.)*normalize(suncol)*0.6;\n    \n    \n    //reflections\n    //col += texture(iChannel1, reflect(ray, normal)).rgb*0.5;\n    //distance fog\n    \n    float p = pow(0.99, v.dist*3.);\n    col = sky_fade*(1.-p)+p*col;\n    if(v.dist>500.){\n        col = sky_fade-ray.y*0.3;\n    }\n    col += -ray.y*0.1;\n    //col*=1./(1.+v.dist*0.1);\n    //col += pow(1.1, v.w*0.01);\n    //col+=v.w*0.01;\n    \n    col += pow(dot(ray, normalize(sun-camera)), 1.)*0.1*nsuncol;//+texture(iChannel1, uv).rrr;\n    //col = texture(iChannel0, uv+0.5).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define zoom 1.7\nvec3 getOceanCol (vec2 uv) {\n    float col = texture(iChannel0, uv*0.3).r;\n    float compare = texture(iChannel2, uv*0.3).r;\n    col = smoothstep(0.0, 1., abs(col-compare)*2.);\n    col = 0.03/col;\n    return vec3(col, col, 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float r = texture(iChannel1, uv*0.2+iTime*0.02).r*0.3;\n    uv = rotate2d(uv, r/max(length(uv), 0.1));//warp space-time :))\n    \n   \tvec3 col = getOceanCol(uv*zoom);\n    col = 0.5+(col-0.5)*10.;//contrast\n    col = clamp(col, 0., 1.);\n    \n    vec3 shadow = getOceanCol(uv*zoom+0.5);\n    shadow = 0.5+(shadow-0.5)*10.;//contrast\n    shadow = clamp(shadow, 0., 1.);\n    shadow = 0.5+(shadow-0.5)*0.1;\n    \n    col.gb+=shadow.gb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 rotate2d (vec2 uv, float angle) {\n    float ang = atan(uv.y, uv.x);\n    float l = length(uv);\n    return vec2(cos(ang+angle)*l, sin(ang+angle)*l);\n}\nfloat weight (float x, float a, float b) {\n    return min(x, 0.)*b+max(x, 0.)*a;\n}","name":"Common","description":"","type":"common"}]}