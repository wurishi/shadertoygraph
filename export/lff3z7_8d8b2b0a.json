{"ver":"0.1","info":{"id":"lff3z7","date":"1702888709","viewed":99,"name":"Twisted torus MIPT","username":"polinavenberg","description":"MIPT homework 1: twisted figure with gradient color","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["torus","gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.01\n#define STEPS 64\n\nfloat mobius(vec3 p, float b) {\n\tfloat x = p.x, y = p.y, z = p.z;\n\tfloat xx = x*x, yy = y*y, zz = z*z, y3 = yy*y, x3 = xx*x;\n\tfloat xy = xx+yy, b2 = b*2.0, zxy = z*(xx*y*3.0-y3), xyy = x*yy*3.0-x3;\n    float k1 = (2.0*zxy+xyy*(xy-zz+1.0))*(b-0.1)-xy*xy*(b2+0.2);\n    float k2 = b*xy*0.2+(b2-0.2)*(zxy+xyy)-xy*(b+0.1)*(xy+zz+1.0);\n\treturn k1*k1-xy*k2*k2;\n}\n\nvec3 gradient(vec3 p, float b) {\n\tvec2 q = vec2(0.0, EPS);\n\treturn vec3(mobius(p+q.yxx, b) - mobius(p-q.yxx, b), \n\t\t\t    mobius(p+q.xyx, b) - mobius(p-q.xyx, b),\n\t\t\t    mobius(p+q.xxy, b) - mobius(p-q.xxy, b));\n}\n\nfloat torus(vec3 p) {\n\tvec2 t = vec2(1.0, 0.3);\n  \tvec2 q = vec2(length(p.xy)-t.x,p.z);\n  \treturn length(q)-t.y;\n}\n\nmat3 rotY(float ang) {\n\treturn mat3(cos(ang), 0.0, sin(ang), 0.0, 1.0, 0.2, -sin(ang), 0.0, cos(ang));\n}\n\nmat3 rotX(float ang) {\n\treturn mat3(1.0, 0.0, 0.0, 0.2, cos(ang), -sin(ang), 0.0, sin(ang), cos(ang));\n}\n\nvec3 shade(vec3 p, vec3 rd, float b, vec2 uv) {\n\tvec3 col = cos(iTime + uv.xyx + vec3(1.0, 3.0, 3.0));\n\tvec3 n = normalize(-gradient(p, b));\n\tcol += 2.0*pow(clamp(1.0+dot(n, rd), 0.0, 1.0), 2.0);\n    \n\treturn col/(col+1.0);\n\n}\n\nvec3 background(vec3 rd) {\n    float k = rd.x*0.5;\n    vec3 col = mix(vec3(0.0, 0.1, 0.3), cos(iTime + vec3(1.0, 3.0, 3.0)), k) * 1.2;\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fc = fragCoord.xy / iResolution.xy;\n\tvec2 uv = -1.0+2.0*fc;\n\tuv.x *= iResolution.x/iResolution.y;\t\n\t\n\tvec2 mouse = iMouse.xy/iResolution.xy + 0.3*iTime;\n\t\n\tmat3 m = rotY(mouse.x)*rotX(mouse.y);\n\tvec3 ro = m*vec3(0.0, 0.0, 2.0);\n\tvec3 rd = m*normalize(vec3(uv, -1.0));\n\t\n\tfloat d = 10.0, t1 = 0.0;\n\tvec3 p = ro, col = vec3(1.0);\n\t\n\tfor (int i = 0; i < STEPS; ++i) {\n\t\tif (d < EPS) continue;\n\t\td = torus(p);\n\t\tt1 += d; p = ro + t1*rd;\n\t}\n    \n    col=vec3(0.0);\n    col += background(rd);\n    float b = 0.005;\n\t\n\tif (d < EPS) {\t\n\n        float t2 = t1; d = mobius(p, b);\n\t\tfor (int i = 0; i < 2*STEPS; ++i) {\n\t\t\tif (d > 0.0) continue;\n\t\t\td = mobius(p, b);\n\t\t\tt2 += 2.0*EPS; p = ro + t2*rd;\n\t\t}\n        \n\n        if (d > 0.0) {\n\t\t\tfor (int i = 0; i < STEPS; ++i) {\n\t\t\t\td = 0.5*(t1+t2); p = ro + d*rd;\n\t\t\t\tif (mobius(p, b) > 0.0) t2 = d; else t1 = d;\n\t\t\t}\n\t\t\tcol = shade(ro+d*rd, rd, b, uv);\n\t\t}\n\t}\n    \n    col *= pow(30.0*fc.x*(1.0-fc.x)*fc.y*(1.0-fc.y), 0.5);\n    \n\t\n\tfragColor = vec4(sqrt(col), 0.0);\n}","name":"Image","description":"","type":"image"}]}