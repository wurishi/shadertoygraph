{"ver":"0.1","info":{"id":"tlXGzS","date":"1556659823","viewed":97,"name":"RayWa","username":"ankd","description":"The name of era of japan changed to \"Reiwa\" and I made this by \"Ray\"marching.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nmat2 rotate(in float r){\n    float c=cos(r), s=sin(r);\n    return mat2(c, -s, s, c);\n}\nfloat hash(in vec2 n){\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*46123.9878);\n}\nvec3 hash3(in vec2 n){\n    return vec3(\n            hash(n+vec2(1.0)),\n            hash(n+vec2(10000.0)),\n            hash(n+vec2(100.0))\n        );\n}\nfloat usin(in float x){\n  return 0.5+0.5*sin(x);\n}\nfloat easeInOut(in float x, in float e){\n    float x2 = x*2.0;\n    return x<0.5 ? 0.5*pow(x2, e) : 1.0-0.5*pow(2.0-x2, e);\n}\n\n\nfloat sdSphere(in vec3 p, in float r){\n    return length(p) - r;\n}\nfloat sdPlane(in vec3 p, in float h){\n    return p.y - h;\n}\nfloat sdBox(in vec3 p, in vec3 b){\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat rei(in vec3 p){\n    vec3 q = p;\n    float res,d;\n\n    // top obj\n    q.x = abs(q.x);\n    q.y -= 0.6;\n    q.xy *= rotate(PI*0.25);\n    d = sdBox(q, vec3(1.0, 0.1, 0.1));\n    res = d;\n\n    // point\n    q = p;\n    q -= vec3(0., 0.1, 0.);\n    q.xy *= rotate(PI*0.25);\n    d = sdBox(q, vec3(0.1));\n    res = min(res,d);\n\n    // bottom obj\n    q = p;\n    d = sdBox(q-vec3(0., -0.2, 0.), vec3(0.4, 0.1, 0.1));\n    d = min(d, sdBox(q-vec3(0.3, -0.5, 0.), vec3(0.1, 0.2, 0.1)));\n    d = min(d, sdBox(q-vec3(0.2, -0.6, 0.), vec3(0.15, 0.1, 0.1)));\n    d = min(d, sdBox(q-vec3(-0.15, -0.55, 0.), vec3(0.1, 0.28, 0.1)));\n    res = min(res,d);\n\n    return res;\n}\nfloat wa(in vec3 p){\n    vec3 tmp_p = p;\n    vec3 q;\n    float res,d;\n\n    // left obj (nogi_hen)\n    p = tmp_p-vec3(-0.4, 0., 0.);\n    q = p;\n    d = sdBox(q-vec3(-0.02, 0.45, 0.), vec3(0.25, 0.08, 0.1));\n    d = min(d, sdBox(q-vec3(0., 0.05, 0.), vec3(0.4, 0.1, 0.1)));\n    d = min(d, sdBox(q-vec3(0., -0.2, 0.), vec3(0.08, 0.6, 0.1)));\n    q.x = abs(q.x);\n    q.xy *= rotate(PI*0.25);\n    d = min(d, sdBox(q, vec3(0.5, 0.08, 0.1)));\n    res = d;\n\n    // right obj (tsukuri)\n    p = tmp_p-vec3(0.4, 0., 0.);\n    q = p - vec3(0., -0.2, 0.);\n    d = max(-sdBox(q, vec3(0.2, 0.25, 0.2)), sdBox(q, vec3(0.3, 0.35, 0.1)));\n    res = min(res, d);\n\n    return res;\n}\n\nfloat reiwa(in vec3 p){\n    vec3 q = p;\n    float t = iTime*0.8;\n    float it = floor(t);\n    float ft = fract(t);\n\n    float d_rei = rei(q);\n    float d_wa = wa(q);\n    float d_reiwa = min(rei(q-vec3(-0.9, 0., 0.)), wa(q-vec3(0.8, 0., 0.)));\n\n    float pattern = floor(mod(t, 3.0));\n    float pct = easeInOut(ft, 8.0);\n    return  pattern<1.0 ? mix(d_rei, d_wa, pct) :\n            pattern<2.0 ? mix(d_wa, d_reiwa, pct) :\n                          mix(d_reiwa, d_rei, pct);\n}\n\nvec3 opRep(in vec3 p, in vec3 c){\n    return mod(p-0.5*c, c) - 0.5*c;\n}\n\nvec2 map(in vec3 p){\n    vec3 q = p;\n\n    for(int i=0;i<2;i++){\n        q = abs(q) - vec3(4.0);\n        q.xy *= rotate(iTime*0.2);\n        q.yz *= rotate(iTime*0.3);\n        q.zx *= rotate(iTime*0.1);\n    }\n    q = opRep(q, vec3(5.0+floor(q)));\n    q = mix(p, q, easeInOut(usin(iTime*0.5), 4.0));\n    vec2 res = vec2(reiwa(q), 1.0);\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD=0.5, maxD=20.0;\n    float d = minD, m = -1.0;\n    for(int i=0;i<32;i++){\n        vec2 tmp = map(ro + rd*d);\n        if(tmp.x<0.001 || maxD<tmp.x) break;\n        d += tmp.x;\n        m = tmp.y;\n    }\n    if(maxD<d) m = -1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 e = vec2(1.0, -1.0)*0.0001;\n    return normalize(vec3(\n            e.xyy*map(p+e.xyy).x +\n            e.yxy*map(p+e.yxy).x +\n            e.yyx*map(p+e.yyx).x +\n            e.xxx*map(p+e.xxx).x\n        ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n  vec3 color = vec3(0.0);\n\n  vec2 res = castRay(ro, rd);\n  float d = res.x;\n  float m = res.y;\n\n  vec3 pos = ro + rd*d;\n  vec3 nor = calcNormal(pos);\n\n  vec3 lp = vec3(1.0);\n  vec3 ld = normalize(lp - pos);\n\n  color =\n      m==1.0 ? mix(vec3(1.), vec3(0.1, 0.4, 0.9), exp(-0.2*length(pos-lp)))*clamp(dot(ld, nor), 0., 1.):\n               vec3(1.0);\n\n  return color;\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float t = iTime*1.4 + 1.0*sin(iTime*0.8);\n    float it = floor(t);\n    float ft = fract(t);\n    ft = sqrt(ft);\n\n    vec3 ro1 = hash3(vec2(it))*2.0-1.0;\n    vec3 ro2 = hash3(vec2(it+1.0))*2.0-1.0;\n    vec3 roa = mix(ro1, ro2, ft)*mix(3.0, 1.0, easeInOut(clamp(iTime*0.1, 0., 1.), 4.0));\n    vec3 rob = vec3(0., 0., 1.0+sin(iTime*0.2));\n\n    vec3 tar = vec3(0.);\n    vec3 rda = lookAt(roa, tar, 0.)*normalize(vec3(p, 1.0));\n    vec3 rdb = lookAt(rob, tar, 0.)*normalize(vec3(p, 1.0));\n\n    vec3 colora = render(roa, rda);\n    vec3 colorb = render(rob, rdb);\n\n    vec3 color = mix(colora, colorb, easeInOut(usin(iTime*0.45), 6.0));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}