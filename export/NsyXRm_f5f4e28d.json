{"ver":"0.1","info":{"id":"NsyXRm","date":"1634388206","viewed":73,"name":"Bad Raymarching Implementation","username":"big_chonk","description":"Me trying to make a simple raymarching shader.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings\n#define CONTROL_SMOOTHING_WITH_MOUSE\n\nconst vec4 lightBlue = vec4(0.4, 0.6, 1.0, 1);\nconst vec4 darkBlue = vec4(0.0, 0.3, 0.8, 1);\nconst vec4 orange = vec4(1.0f, 0.55, 0.35, 1);\nconst vec4 yellow = vec4(1.0f, 0.75, 0.35, 1);\n\nvec4 GetColor(vec2 uv)\n{\n    Ray ray = GetRayFromUV(uv, iResolution);\n\n    float distanceToObject = 0.;\n    float distanceTravelled = 0.;\n    vec3 point = ray.origin;\n\n    // vec4 color = mix(darkBlue, lightBlue, uv.y);\n    vec4 color = vec4(0);\n            \n#   ifdef CONTROL_SMOOTHING_WITH_MOUSE\n    float smoothing = iMouse.x / iResolution.x;\n#   else\n    float smoothing = 0.5f;\n#   endif\n\n    float seed = 0.1 * iTime;\n    \n    // March the ray\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        point += ray.direction * distanceToObject;\n        \n        distanceToObject = MinDistanceToObject(point, seed, smoothing);\n        distanceTravelled += distanceToObject;\n        \n        if (distanceToObject <= MIN_DISTANCE)\n        {\n            vec3 normal = GetNormal(point, seed, smoothing);\n            float diffuse = dot(normal, vec3(0, -1, 0));\n            color = diffuse * darkBlue;\n            break;\n        }\n        \n        if (distanceToObject <= GLOW_DISTANCE)\n        {\n            color += (GLOW_DISTANCE - distanceToObject) * lightBlue;\n            continue;\n        }\n        \n        if (distanceToObject >= MAX_DISTANCE)\n            break;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    fragColor = GetColor(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS    256\n#define MAX_DISTANCE 100.\n#define MIN_DISTANCE .01\n#define GLOW_DISTANCE .25\n\n#define NUM_SPHERES 10\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n#define HASHSCALE 0.1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat srandom(float seed)\n{\n    // Returns 1D perlin noise\n    return perlinNoise1D(seed);\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nRay GetRayFromUV(vec2 uv, vec3 iResolution)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv -= vec2(0.5 * aspectRatio, 0.5);\n\n    const vec3 origin = vec3(0, 0, -1);\n    vec3 rayPoint = vec3(uv, 0);\n    \n    Ray ray;\n    \n    ray.origin    = origin;\n    ray.direction = normalize(rayPoint - origin);\n    \n    return ray;\n}\n\nfloat MinDistanceToObject(vec3 point, float seed, float smoothing)\n{\n    float minDistance = MAX_DISTANCE;\n\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float rand = srandom(seed);\n        vec3 center = vec3(3. * rand, 3. * srandom(seed + 15.), srandom(seed + 30.) + 3.);\n        float radius = 0.5 * rand + 0.5;\n        seed += 400.;\n\n        float dist = length(center - point) - radius;\n        minDistance = smin(minDistance, dist, smoothing);\n    }\n    \n    return minDistance;\n}\n\nvec3 GetNormal(vec3 point, float seed, float smoothing)\n{\n    float dist = MinDistanceToObject(point, seed, smoothing);\n    vec2 offset = vec2(MIN_DISTANCE, 0);\n    \n    vec3 n = vec3(\n        MinDistanceToObject(point - offset.xyy, seed, smoothing),\n        MinDistanceToObject(point - offset.yxy, seed, smoothing),\n        MinDistanceToObject(point - offset.yyx, seed, smoothing)\n    ) - dist;\n    \n    return normalize(n) / MIN_DISTANCE;\n}","name":"Common","description":"","type":"common"}]}