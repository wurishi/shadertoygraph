{"ver":"0.1","info":{"id":"3djSzz","date":"1552727209","viewed":2432,"name":"Atmospheric Scattering Skybox","username":"FMS_Cat","description":"Used as envMap for glTF standard materials in VRoid Hub\nhttps://hub.vroid.com\n\nI have no% confidence the implementation is perfect","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["atmosphereskyskybox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*!\n * (c) 2019 FMS_Cat, MIT License\n * https://opensource.org/licenses/MIT\n *\n * Based on \"Accurate Atmospheric Scattering\" from GPU Gems2\n * https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\n *\n * ThreePlanet.js implementation helps me so much\n * https://github.com/idflood/ThreePlanet.js\n */\n\n#define LIGHT_DIR normalize( vec3( -3.0, 3.0, -3.0 ) )\n#define CAMERA_HEIGHT 1.000001\n#define INV_WAVE_LENGTH vec3( 5.60204474633241, 9.4732844379203038, 19.643802610477206 )\n#define INNER_RADIUS 1.0\n#define OUTER_RADIUS 1.025\n#define ESUN 10.0\n#define KR 0.0025\n#define KM 0.0015\n#define SCALE_DEPTH 0.25\n#define SAMPLES 2\n#define G -0.99\n#define GROUND_COLOR vec3( 0.37, 0.35, 0.34 )\n#define GAMMA 1.0 / 2.2\n\n#define PI 3.14159265\n\nmat2 rotate2D( float t ) {\n    return mat2( cos( t ), -sin( t ), sin( t ), cos( t ) );\n}\n\nfloat scale( float fCos ) {\n    float x = 1.0 - fCos;\n    return SCALE_DEPTH * exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * ( -6.80 + x * 5.25 ) ) ) );\n}\n\nvec2 getIntersections( vec3 pos, vec3 dir, float dist2, float rad2 ) {\n    float B = 2.0 * dot( pos, dir );\n    float C = dist2 - rad2;\n    float det = max( 0.0, B * B - 4.0 * C );\n    return 0.5 * vec2(\n        ( -B - sqrt( det ) ),\n        ( -B + sqrt( det ) )\n    );\n}\n\nfloat getRayleighPhase( float fCos2 ) {\n    return 0.75 * ( 2.0 + 0.5 * fCos2 );\n}\n\nfloat getMiePhase( float fCos, float fCos2, float g, float g2 ) {\n    return 1.5 * ( ( 1.0 - g2 ) / ( 2.0 + g2 ) ) * ( 1.0 + fCos2 )\n        / pow( 1.0 + g2 - 2.0 * g * fCos, 1.5 );\n}\n\nvec3 uvToRayDir( vec2 uv ) {\n    vec2 v = PI * ( vec2( 1.5, 1.0 ) - vec2( 2.0, 1.0 ) * uv );\n    return vec3(\n        sin( v.y ) * cos( v.x ),\n        cos( v.y ),\n        sin( v.y ) * sin( v.x )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Variables\n    float fInnerRadius2 = INNER_RADIUS * INNER_RADIUS;\n    float fOuterRadius2 = OUTER_RADIUS * OUTER_RADIUS;\n    float fKrESun = KR * ESUN;\n    float fKmESun = KM * ESUN;\n    float fKr4PI = KR * 4.0 * PI;\n    float fKm4PI = KM * 4.0 * PI;\n    float fScale = 1.0 / ( OUTER_RADIUS - INNER_RADIUS );\n    float fScaleOverScaleDepth = fScale / SCALE_DEPTH;\n    float fG2 = G * G;\n\n    // Light diection\n    vec3 v3LightDir = LIGHT_DIR;\n    if ( 0.5 < iMouse.z ) {\n\t\tvec2 m = iMouse.xy / iResolution.xy;\n        v3LightDir = uvToRayDir( m );\n    }\n\n    // Ray initialization\n    vec2 v2uv = fragCoord.xy / iResolution.xy;\n\n    vec3 v3RayOri = vec3( 0.0, CAMERA_HEIGHT, 0.0 );\n    float fRayPhi = PI * ( 3.0 / 2.0 - 2.0 * v2uv.x );\n    float fRayTheta = PI * ( v2uv.y );\n    vec3 v3RayDir = vec3(\n        sin( fRayTheta ) * cos( fRayPhi ),\n        -cos( fRayTheta ),\n        sin( fRayTheta ) * sin( fRayPhi )\n    );\n    float fCameraHeight = length( v3RayOri );\n    float fCameraHeight2 = fCameraHeight * fCameraHeight;\n\n    vec2 v2InnerIsects = getIntersections( v3RayOri, v3RayDir, fCameraHeight2, fInnerRadius2 );\n    vec2 v2OuterIsects = getIntersections( v3RayOri, v3RayDir, fCameraHeight2, fOuterRadius2 );\n    bool isGround = 0.0 < v2InnerIsects.x;\n\n    if ( v2OuterIsects.x == v2OuterIsects.y ) // vacuum space\n        {\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n    }\n\n    float fNear = max( 0.0, v2OuterIsects.x );\n    float fFar = isGround ? v2InnerIsects.x : v2OuterIsects.y;\n    vec3 v3FarPos = v3RayOri + v3RayDir * fFar;\n    vec3 v3FarPosNorm = normalize( v3FarPos );\n\n    vec3 v3StartPos = v3RayOri + v3RayDir * fNear;\n    float fStartPosHeight = length( v3StartPos );\n    vec3 v3StartPosNorm = v3StartPos / fStartPosHeight;\n    float fStartAngle = dot( v3RayDir, v3StartPosNorm );\n    float fStartDepth = exp( fScaleOverScaleDepth * ( INNER_RADIUS - fStartPosHeight ) );\n    float fStartOffset = fStartDepth * scale( fStartAngle );\n\n    float fCameraAngle = dot( -v3RayDir, v3FarPosNorm );\n    float fCameraScale = scale( fCameraAngle );\n    float fCameraOffset = exp( ( INNER_RADIUS - fCameraHeight ) / SCALE_DEPTH ) * fCameraScale;\n\n    float fTemp = scale( dot( v3FarPosNorm, v3LightDir ) ) + scale( dot( v3FarPosNorm, -v3RayDir ) );\n\n    float fSampleLength = ( fFar - fNear ) / float( SAMPLES );\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleDir = v3RayDir * fSampleLength;\n    vec3 v3SamplePoint = v3StartPos + v3SampleDir * 0.5;\n\n    vec3 v3FrontColor = vec3( 0.0 );\n    vec3 v3Attenuate;\n    for ( int i = 0; i < SAMPLES; i ++ )\n        {\n        float fHeight = length( v3SamplePoint );\n        float fDepth = exp( fScaleOverScaleDepth * ( INNER_RADIUS - fHeight ) );\n        float fLightAngle = dot( v3LightDir, v3SamplePoint ) / fHeight;\n        float fCameraAngle = dot( v3RayDir, v3SamplePoint ) / fHeight;\n        float fScatter = isGround\n            ? fDepth * fTemp - fCameraOffset\n            : ( fStartOffset + fDepth * ( scale( fLightAngle ) - scale( fCameraAngle ) ) );\n        v3Attenuate = exp( -fScatter * ( INV_WAVE_LENGTH * fKr4PI + fKm4PI ) );\n        v3FrontColor += v3Attenuate * ( fDepth * fScaledLength );\n        v3SamplePoint += v3SampleDir;\n    }\n\n    v3FrontColor = clamp( v3FrontColor, 0.0, 3.0 );\n    vec3 c0 = v3FrontColor * ( INV_WAVE_LENGTH * fKrESun );\n    vec3 c1 = v3FrontColor * fKmESun;\n\n    if ( isGround )\n        {\n        vec3 v3RayleighColor = c0 + c1;\n        vec3 v3MieColor = clamp( v3Attenuate, 0.0, 3.0 );\n        fragColor = vec4( 1.0 - exp( -( v3RayleighColor + GROUND_COLOR * v3MieColor ) ), 1.0 );\n        fragColor.xyz = pow( fragColor.xyz, vec3( GAMMA ) );\n        return;\n    }\n\n    float fCos = dot( -v3LightDir, v3RayDir );\n    float fCos2 = fCos * fCos;\n\n    fragColor = vec4(\n        getRayleighPhase( fCos2 ) * c0 + getMiePhase( fCos, fCos2, G, fG2 ) * c1,\n        1.0\n    );\n    fragColor.xyz = pow( fragColor.xyz, vec3( GAMMA ) );\n}\n","name":"Image","description":"","type":"image"}]}