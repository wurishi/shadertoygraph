{"ver":"0.1","info":{"id":"MdfBRl","date":"1497458104","viewed":597,"name":"Energy Rails","username":"esmelusina","description":"Using the waveform distortion technique from this one: https://www.shadertoy.com/view/4dVXDt, applied it to work arbitrarily over bezier curves and distort more heavily around a point. Use mouse to move yellow dot.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["procedural","wave","interactive","bezier","distortion","smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on the one found here: https://www.shadertoy.com/view/4dVXDt\n// Extended to use arbitrary bezier curves as a proof of concept\n\n\n//solver for cubic root\nfloat cuberoot( float x ){\n    return (1.-2.*float(x<0.0))*pow(abs(x),1.0/3.0);\n}\n\n// solver for cubic function (needed for bezier curve distance)\n// A B C are the terms, r are the resulting roots, return is the number of roots\nint solveCubic(float a, float b, float c, out float r[3]) {\n    float p = b - a*a / 3.;\n    float q = a * (2.*a*a - 9.*b) / 27. + c;\n    float p3 = p*p*p;\n    float d = q*q + 4.*p3 / 27.;\n    float offset = -a / 3.;\n    if(d >= 0.) { // Single solution\n        float z = sqrt(d);\n        float u = (-q + z) / 2.;\n        float v = (-q - z) / 2.;\n        u = cuberoot(u);\n        v = cuberoot(v);\n        r[0] = offset + u + v;\n        return 1;\n    }\n    float u = sqrt(-p / 3.);\n    float v = acos(-sqrt( -27. / p3) * q / 2.) / 3.;\n    float m = cos(v), n = sin(v)*1.732050808;\n    r[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n    return 3;\n}\n\n// Distance to nearest point on a QB curve\n// Technically also calculates the nearest point, but it isn't inherently useful.\nfloat findNearestPoint(in vec2 x, in vec2 P0, in vec2 P1, in vec2 P2) {\n    float d0 = length( P0-x );\n    float d2 = length( P2-x );\n\n    float dis = min( d0, d2 );\n\n    vec2 a = P0 - 2.0*P1 + P2;\n    vec2 b = 2.0*(P1 - P0);\n    vec2 c = P0;\n\n    float k3 = 2.0*dot(a,a);\n    float k2 = 3.0*dot(a,b);\n    float k1 = dot(b,b) + 2.0*dot(c-x,a);\n    float k0 = dot(c-x,b);\n\n    float res[3];\n    int n = solveCubic( k2/k3, k1/k3, k0/k3,  res );\n    for( int i=0; i<3; i++ )\n    {\n        float t = res[i];\n        if( t>=0.0 && t <=1.0 )\n        {\n            vec2 pos = (1.0-t)*(1.0-t)*P0 +  2.0*t*(1.0-t)*P1 + t*t*P2;            \n            dis = min( dis, length( pos - x ) );\n        }\n    }\n    return dis;\n}\n\n// Wave-form function\nfloat waves(vec2 coord, vec2 coordMul1, vec2 coordMul2, vec2 phases, vec2 timeMuls, float time) {\n    return 0.5 * (sin(dot(coord, coordMul1) + timeMuls.x * time + phases.x) + cos(dot(coord, coordMul2) + timeMuls.y * time + phases.y));\n}\n\n// Initialize some curves to work with-- old glsl setup\n// these should come in as uniforms\nvec2 curves[9];\nvoid initCurves(inout vec2 c[9]) {\n    c[0] = vec2(0.5,0.0);\n    c[1] = vec2(0.5,1.0);\n    c[2] = vec2(0.0,1.0);\n\n    c[3] = vec2(0.5,0.0);\n    c[4] = vec2(0.5,1.0);\n    c[5] = vec2(1.0,1.0);\n\n    c[6] = vec2(0.0,1.0);\n    c[7] = vec2(1.0,1.0);\n    c[8] = vec2(1.0,0.0);\n}\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n// hash instead of noise sampling\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//  mag is distortion amount, phase is a temporal offset, freq is the wiggle speed\n// setup a dz for a third dimension\nvec2 distort(in vec2 coord, float mag, float phase, float freq)\n{\n    vec2 noiseSampleDirection = vec2(1.0, 0.319);\n    vec2 sampleLocation1 = noiseSampleDirection * phase;\n    vec2 sampleLocation2 = vec2(1.0, 0.8) - noiseSampleDirection * phase;\n    vec3 noise1 = texture(iChannel0, sampleLocation1).rgb;\n    vec3 noise2 = texture(iChannel0, sampleLocation2).rgb;    \n    \n    vec3 n1 = hash31(phase);\n    vec3 n2 = hash31(1.0+phase);\n\n    // Would rather distort relative to world center rather than fixed directions\n    \t// (you'll notice the waves will lean/move toward the bottom left corner\n    float dx = 0.0 + 0.6 * waves(coord,\n                                    vec2(1.9 + 0.4 * n1.r, 1.9 + 0.4 * n1.g) * 3.3,\n                                    vec2(5.7 + 1.4 * n1.b, 5.7 + 1.4 * n2.r) * 2.8,\n                                    vec2(n1.r - n2.r, n1.g + n2.b) * 5.0,\n                                    vec2(1.1), iTime*freq);\n    float dy = 0.5 + 0.7 * waves(coord,\n                                    vec2(-1.7 - 0.9 * n2.g, 1.7 + 0.9 * n2.b) * 3.1,\n                                    vec2(5.9 + 0.8 * n1.g, -5.9 - 0.8 * n1.b) * 3.7,\n                                    vec2(n1.g + n2.g, n1.b - n2.r) * 5.0,\n                                    vec2(-0.9), iTime*freq);\n   \n   float amt = dx*dy;\n\n   return coord + normalize(vec2(dx,dy))*amt*mag;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // I wrote this in glsl 1.2 originally, this isn't necessary in 3.0\n    initCurves(curves);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// additively build the color for the pixel from the rails\n    vec3 col = vec3(0.);\n\n    // the base colors for the rails\n    vec3 tint1 = vec3(0.4,0.3,0.7);\n    vec3 tint2 = vec3(0.6,0.6,0.4);\n    \n    //an alternator to switch between colors\n    int alt = 0;    \n    \n    // Distortion points-- could increase base distortion and have points of non-distortion\n    vec2 pod1 = iMouse.xy/iResolution.xy;\n    vec2 pod2 = vec2(.5f+.4f*sin(iTime),.5f+.4f*cos(iTime));\n    \n    \n    for(float i = .6; i < 6.; i+=0.5)\n    {\n        // uv, in this sense, represents the fragment's position in world-space\n        // need to find out where the fragment is in world space for this to work properly in 3d\n        float df1 = pow(.000001, length(uv-pod1));\n        float df2 = pow(.000001, length(uv-pod2));\n        \n        // Distort the point according to time, hashing function, frequency, magnitude (in loop)\n        // need to project into world space for it to work properly, this is in UV space for now.\n        // adding a 3rd component is also totally possible!  \n        \n\t\t// Distort our position\n        vec2 muv = distort(uv, 0.03+df1+df2, i*1.7, i*1.4);\n        \n        \n        // in this case, fixed to deal with 3 curves-- this is 1.2 glsl- some loop limitations are imposed\n        // hardcoded curve data\n        // We are coloring based on distance from the curve,\n        // in this case, the 1's complement is sufficient in UV space\n        float d0 = 1.0-findNearestPoint(muv, curves[0],curves[1],curves[2]);\n        float d1 = 1.0-findNearestPoint(muv, curves[3],curves[4],curves[5]);\n        float d2 = 1.0-findNearestPoint(muv, curves[6],curves[7],curves[8]);        \n        float amt = max(d2,max(d0,d1));\n        \n        amt = pow(amt,80.0+i*80.);\n\n        //amt = smoothstep(-0.0003,0.0003, pow(max(d0,d1),0.3));\n        \n        vec3 tint;\n        if(alt == 0) tint=tint1;\n        if(alt == 1) tint=tint2;\n        col += amt*tint*.7;\n        alt++;\n        if(alt > 1) alt = 0;\n    }\n\n    fragColor = vec4(col*vec3(.7,.5,.6),1.);\n    \n  \t// this is for the pods\n    if(length(uv-pod1) < .017)\n        fragColor = vec4(1.,1.,.2,1.);\n    if(length(uv-pod2) < .017)\n        fragColor = vec4(.2,1.,1.,1.);\n}","name":"Image","description":"","type":"image"}]}