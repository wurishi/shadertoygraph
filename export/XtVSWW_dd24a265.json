{"ver":"0.1","info":{"id":"XtVSWW","date":"1484391762","viewed":169,"name":"Strange fractal","username":"stduhpf","description":"Its a Knighty's pleudeo kleinian mod.\nThhs formula can produce really interesting shapes, but when i go too far from the origin, the DE starts to be innacurate.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","experiment","kleinian","glitched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define s vec3(.75,.75,.8)\n#define fr_it 8\n#define scale .7\n#define maxi .75\n\n#define stereo\n\n\nvec2 map(vec3 p) //distance to the fractal\n{\n\n    float k=1.;\n    for( int i =0;i<fr_it;i++)\n    {\n        p=2.*clamp(p,-s,s)-p;//boxfold (repetition)\n        //p=mod(p+s,2.*s)-s; //infinite repetition\n    p-=sign(p)*.03;\nfloat a = float(i)*acos(-1.)/4.;\nvec2 x = vec2(cos(a),sin(a));\n    p.yz*=mat2(x,-x.y,x.x);\n        float f = max(scale/dot(p,p),maxi);\n        p*=f;\n        k*=f*1.1;\n    }\n    return vec2(max(length(p.xz)-.9,length(p.xz)*abs(p.y)/length(p))/k,\n(length(p.xz)-.4 >(abs(p.y)/length(p)))?1:2);\n}\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  r = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.002*t;\n        \n         r = map( ro+rd*t );\n\t    float h = r.x;\n        if( h<precis||t>maxd ) break;\n        t += .8*h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2( t, r.y );\n}\n\nvec3 normal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\nfloat ao(vec3 p, vec3 n)\n{\n    const float ao_it =8.;\n    float d=0.;\n    float sm =0.;\n    for(float i=1.;i<ao_it;i++)\n    {\n        d+=.08;\n        float h = map(p+d*n).x;\n        sm+=(d-h)/pow(2.,i);\n    }\n    return 1.-sm*4.;\n\n}\nvec3 getCol(float i)\n{\n    if(i==1.)\n        return vec3(.3,.28,.04);\n     if(i==2.)\n        return vec3(.01,.2,.4);\n return vec3(0);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 ro = s;\n    ro.z=40.*sin(.01*iTime);\n    vec2 mse=3.14*(2.*iMouse.xy-iResolution.xy)/iResolution.x;\n    if(iMouse.xy==vec2(0))\n        mse=vec2(-2.3,-.7);\nmat3 r = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nr*= mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    \n#ifdef stereo\n    ro+=r*vec3(0,0,.02*(float(uv.x>0.)-.5));\n    uv.x=uv.x*2.+(uv.x>0.?-1.:1.)*iResolution.x/iResolution.y;\n\tuv.y*=2.;\n#endif\n    \n    \n    vec3 rd = normalize(vec3(uv,1))*r;\n    vec3 c=vec3(0);\n    \n    vec2 i = intersect(ro,rd);\n    if(i.y!=0.)\n    {\n        vec3 p = ro+i.x*rd,\n        n=normal(p,i.x);\n        c= getCol(i.y);\n        float l =dot(n,-rd)*ao(p,n);\n        c*=l*4.;\n        //c=vec3(ao(p,n));\n    }\n    c=mix(c,vec3(.5,.55,.6),i.x<0.?1.:i.x/20.);\n    \n\tfragColor = pow(vec4(c,1.0),vec4(1.5));\n}","name":"Image","description":"","type":"image"}]}