{"ver":"0.1","info":{"id":"WtB3Rm","date":"1558807117","viewed":193,"name":"Mergelife","username":"kabacis","description":"Implementation of MergeLife cellular automaton. https://www.heatonresearch.com/mergelife/","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","automata","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0;\n    \n    if (length(fragCoord - vec2(0, iResolution.y)) < min(iResolution.x, iResolution.y)*0.85) {\n        scale = 0.25;\n    }\n    vec4 c0 = texelFetch( iChannel0, ivec2(fragCoord * scale), 0);\n    vec4 c1 = texelFetch( iChannel1, ivec2(fragCoord * scale), 0);\n    vec4 c2 = texelFetch( iChannel2, ivec2(fragCoord * scale), 0);\n    if (c0 == c2) {\n        /*if (int(fragCoord.x) % 2 == 0) {\n        \tfragColor = c0;\n        } else {\n            fragColor = c1;\n        }*/\n        // try to reduce some of the flickering without making picture too blurry\n        fragColor = 0.5 * (c1 + c0); \n    } else {\n        fragColor = c0;\n    }\n    //fragColor = fragColor.zzzz;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Rule {\n   int[8] v;\n};\n\nconst int rule_frames = 300;\nconst bool random_rules = true;\n\nconst int[] rules = int[](\n    // some interesting rules from https://www.heatonresearch.com/mergelife/ml-gallery.html\n    // one rule per line\n    0xcb97,0x6a74,0x88c0,0x28aa,0x1b6a,0x834b,0x4fe8,0x60ac, \n    0xe542,0x5f79,0x9341,0xf31e,0x6c6b,0x7f08,0x8773,0x7068,\n\t0xa07f,0xc000,0x0000,0x0000,0x0000,0x0000,0xff80,0x807f,\n\t0x6eb6,0xba3d,0x70b4,0xac6f,0xbaae,0x2604,0x8529,0x8998,\n\t0xea44,0x55df,0x9025,0xbead,0x5f6e,0x45ca,0x6168,0x275a,\n\t0x1c48,0x9004,0x8831,0x41be,0x2804,0x8f50,0x9901,0xdb18,\n\t0x6007,0x7d42,0x05e5,0x1b9b,0x2899,0xe043,0x1cd4,0x2f7b,\n\t0x2085,0xc66a,0x84d8,0xfbE8,0xb3c0,0x70e4,0x0e2e,0x799c,\n\t0x6da1,0x0852,0x5e0f,0x2Ad9,0xc902,0xf8a0,0x78fd,0x4473,\n\t0xbf51,0x3628,0x3bcf,0x1ee1,0x5b18,0x7b95,0x7898,0x6a9a,\n    0x2152,0x9b71,0xabb7,0x162a,0x45ff,0xdd03,0xfe15,0x957e,\n\t0xef12,0xd680,0x9430,0x8853,0xa368,0x55f9,0x7451,0x7c44,\n\t0xf81b,0x38d1,0x7f60,0x62ad,0x850b,0x2085,0xddff,0x8154,\n\t0x8503,0x5eb6,0x084c,0x04df,0x7657,0xa5b3,0x6044,0x3524,\n\t0x4d56,0xd1e3,0x4acb,0x60d6,0x5e2f,0x5fbf,0x33ad,0xe266,\n    0x6639,0xE9FE,0x797D,0xEC06,0x6949,0x6AF5,0x4E05,0x7556,\n\t0x9d78,0x97dC,0x8F8F,0x1dab,0x96aa,0xcc5d,0xc54a,0x516d,\n\t0x35F5,0xE05F,0xF4C8,0x9C8F,0x6B43,0x5528,0x87DD,0x22FC,\n\t0x6769,0xBdD6,0x7d03,0x564e,0xa5ec,0xcae2,0x54c4,0x8F0c\n);\n\n\nfloat randv(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nRule randRule() {\n    Rule r;\n    for (int i=0; i<8; i++) {\n    \tr.v[i] = int(float(0x100) * randv(vec2(iTime, i*5))) * 256 +\n                 int(float(0x100) * randv(vec2(iTime, i*7)));\n    }\n    return r;\n}\n\nint[8] sortRule(int[8] base_rule)\n{\n    int a[8];\n    for (int i=0; i<8; i++) {\n        a[i] = (base_rule[i] << 8) + i;\n    }\n    for (int i=0; i<8; i++) {\n        for (int j=0; j<7; j++) {\n            if (a[j] > a[j+1]) {\n                int t = a[j];\n                a[j] = a[j+1];\n                a[j+1] = t;\n            }\n        }\n    }\n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame % rule_frames == 0){  \n        \n        if (int(fragCoord.x) < 9 && int(fragCoord.y) == 0) {\n            int[8] rule = int[8](0xcb97, 0x6a74, 0x88c0, 0x28aa, 0x1b6a, 0x834b, 0x4fe8, 0x60ac);\n            int rule_index = (iFrame / rule_frames);\n            int rule_count = rules.length() / 8;\n            if (random_rules && rule_index >= rule_count) {\n                rule = randRule().v;\n            } else {\n                rule_index = rule_index % rule_count;\n                for (int j=0; j<8; j++) {\n                    rule[j] = rules[rule_index * 8 + j];\n                }\n            }\n            int a[8] = sortRule(rule);\n            int i = int(fragCoord.x);\n            if (i < 8) {\n                int v= a[i];\n            \tfragColor = vec4(float((v >> 16) & 0xff)/255.0, float((v >> 8) & 0xff)/256.0, float((v >> 0) & 0xff)/256.00, 0 );\n            } else {\n                fragColor = vec4(1);\n            }\n        } else {\n            fragColor = vec4(0);\n        }\n    } else {\n        ivec2 p = ivec2(fragCoord);\n        if (p.x < 8) {\n            fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n        } else {\n            fragColor = vec4(0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 getv(ivec2 d, vec2 fragCoord)\n{\n\tivec2 size = ivec2(iResolution);\n    \n    ivec2 p = ivec2(fragCoord)+d;\n    \n    bvec2 lt = lessThan(p, ivec2(0));\n    bvec2 gt = greaterThanEqual(p, size);\n    \n    p = p + (ivec2(lt) * size) - (ivec2(gt) * size);\n    \n    return texelFetch( iChannel1, p, 0 );\n}\n\n\nvec4 getv2(ivec2 p)\n{\n    return texelFetch( iChannel0, p, 0 );\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(float v) {\n    int i = int(v) % 8;\n    return vec4(i & 1, (i >> 1) & 1, (i >> 2) & 1, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 t = getv(ivec2(0), fragCoord);\n    fragColor= t;\n    \n    bool need_refresh = getv2(ivec2(8, 0)).x > 0.0;\n\t \n    if(need_refresh || iFrame == 0 || (length(iMouse.xy-fragCoord))<5.0)\n    {\n        fragColor.x=rand(fragCoord+vec2(123.0, 321.0));\n        fragColor.y=rand(-fragCoord.yx);\n        fragColor.z=rand(-fragCoord+ vec2(53.0, 4689.0));\n    }\n    else if (iFrame > 2)\n    {\n     \n        vec4 r0[8];\n        float alpha[8];\n        float beta[8];\n        float col[8];\n        for (int j=0; j<8; j++) {\n        \tvec4 r0 =getv2(ivec2(j, 0));\n            alpha[j] = r0.x * 8.0 * 255.0;\n            beta[j] = r0.y * 256.0;\n            if (beta[j] > 127.0) {\n            \tbeta[j] -= 256.0;\n            }\n            col[j]=r0.z*256.0;\n        }\n        \n\t\tvec4 u=vec4(0.0);\n       \n        u += getv(ivec2(-1, -1), fragCoord);\n        u += getv(ivec2( 0, -1), fragCoord);\n        u += getv(ivec2( 1, -1), fragCoord);\n        \n        u += getv(ivec2(-1,  1), fragCoord);      \n        u += getv(ivec2( 0,  1), fragCoord);\n        u += getv(ivec2( 1,  1), fragCoord);\n        \n        u += getv(ivec2(-1,  0), fragCoord);\n        u += getv(ivec2( 1,  0), fragCoord);\n        float s = floor(((u.x + u.y + u.z)*255.0)/3.0);\n     \n        vec4 res = fragColor;\n        vec4 d = vec4(0);\n        bool done = false;\n        for (int i=0; i<8; i++) {\n            if (!done && s < alpha[i]) {\n                float b = float(beta[i]);\n                if (b < 0.0) {\n                    vec4 k = getColor(col[i] + 1.0);\n                    d = (k - res) * (-b)/128.0;\n                } else {\n                    vec4 k = getColor(col[i]);\n                    d = (k - res) * b/127.0;\n                }\n                done = true;\n                //break; doesn't work\n            }\n        }\n        d = floor(d * 255.0)/255.0;\n        //d=getv(ivec2(-1, 0), fragCoord);\n        fragColor = t + d;\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}