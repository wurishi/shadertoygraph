{"ver":"0.1","info":{"id":"msjXzW","date":"1670184400","viewed":154,"name":"Ray distance to box","username":"kastorp","description":"projecting each box to the plane orthogonal to the ray, we can get its distance from ray using 2d sdf","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["ray","projection","distance","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Ray Distance to Box\" by kastorp\n//------------------------------------\nfloat segment(vec2 p,vec2 a,vec2 b) {\n    float l= length(b - a);\n    vec2 n=normalize(b - a),\n         cp=mix(a, b, clamp(dot(p - a, n) / l, 0., 1.));\n    return length(p- cp);\n}\n#define MAXD 1000.\n\n\n\nvec4 sphere3D(vec2 p, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 n1 =normalize(cross(rd,vec3(0,0,1))),n2=cross(rd,n1);\n    vec3 ro=n1*p.x+n2*p.y;\n    vec3 oc = ro + ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(length(oc-b*rd)-ra,vec3(0)); // no intersection\n    h = sqrt( h );\n    float t =-b-h;\n    vec3 n = normalize( ro + t * rd+ce);\n    return vec4( t- MAXD, n);\n    \n}    \n\n\n// p  = ray position in orthogonal plane \n// rd = ray direction \n// b  = box size \n// c  = box center position\n//return: x = distance or 0; yzw= hit normal\nvec4 box3d(vec2 p,vec3 rd, vec3 b, vec3 c,float rt ){\n\n//vec4 segment3d(vec2 p,vec3 rd,vec2 h,float sc,  vec2 b1, vec2 b2 ){\n//     vec3 c=vec3((b1+b2)*.5,h.x);\n//     vec3 b=vec3(length(b1-b2),sc,h.y);\n//     vec2 nm=normalize(b2-b1);\n//     mat3 rm=mat3(nm.x,nm.y,0,-nm.y,nm.x,0,0,0,1);\n     \n     if(rd.x==0. || rd.y==0. || rd.z==0.) rd=normalize(rd +vec3(1e-5));//avoid singularity\n     mat3 rm=mat3(cos(rt),sin(rt),0,-sin(rt),cos(rt),0,0,0,1);\n     rd*=rm;c*=rm;\n     vec3 n1 =normalize(cross(rd,vec3(0,0,1))),n2=cross(rd,n1);\n\n     //usual intersection without distance:\n     vec3 ro=n1*p.x+n2*p.y+MAXD*rd;\n     vec3 mask = 1./rd; \n     vec3 n = mask*(ro+c);   \n     vec3 k = abs(mask)*b*.5;\n     vec3 t1 = -n - k;\n     vec3 t2 = -n + k;\n     float tN = max( max( t1.x, t1.y ), t1.z );\n     float tF = min( min( t2.x, t2.y ), t2.z ); \n     \n     \n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    if(tN<tF ) return vec4(tN,oNor);\n    \n\n     //initialization, could be done once for all boxes\n     mat3 m=transpose(mat3(n1,n2,rd));                           \n     vec3 s=sign(rd);\n     mat3 ms= mat3(m[0]*s.x, m[1]*s.y, m[2]*s.z);//switch box orientation                                               \n    \n   \n     vec2 v0=ms[0].xy*b.x,v1=ms[1].xy*b.y,v2=ms[2].xy*b.z; //the 3 front vectors    \n     p+=(ms*b).xy*.5+(m*c).xy; //position is centered to closest box vertex   \n     #define cr( a, b) (a.y*b.x-a.x*b.y) \n     vec3 cm=-vec3(cr(p,v0),cr(p,v1),cr(p,v2))*cr(v0,v1), //which side of the vector\n          cf=step(vec3(0.),cm)*step(cm.yzx,vec3(0.)); //get current face\n          \n     vec4 v = cf.x*vec4(v0,v1) +  cf.y*vec4(v1,v2) +cf.z* vec4(v2,v0); //branchless selector   \n     float d= segment(p,v.xy,v.xy+v.zw); //could be reduced to one segment, but it's not worth\n     d= min(d,segment(p,v.zw,v.xy+v.zw));     \n      \n    return vec4(d,vec3(0));\n}\n\n\n#define mmin(rd,d1,d2) (d1.x<d2.x ? d1:d2)\nvec4 map(vec2 p,vec3 rd,vec3 ro,out vec3 pos){\n\n    vec3 n1 =normalize(cross(rd,vec3(0,0,1))),n2=cross(rd,n1);\n    vec2 sh= vec2(dot(n1,ro),dot(n2,ro));\n    p-=sh;\n    \n    vec4 d= box3d(p,rd,vec3(1.,1.,.4),vec3(0,0,.2),0.);    \n    d=mmin(rd,d,box3d(p,rd,vec3(.5,.5,.8),vec3(0,0,.8),0.));\n    d=mmin(rd,d,box3d(p,rd,vec3(.2,1.,1.),vec3(1,0,.5),0.));\n    d=mmin(rd,d,box3d(p,rd,vec3(.2,1.,1.),vec3(-1,0,.5),0.));\n    d=mmin(rd,d,box3d(p,rd,vec3(1.,.2,1.),vec3(0,1,.5),0.5));\n    d=mmin(rd,d,box3d(p,rd,vec3(1.,.2,1.),vec3(0,-1,.5),-0.5));\n    d=mmin(rd,d,box3d(p,rd,vec3(2.2,2.6,.2),vec3(0,0,-.101),0.));\n    d=mmin(rd,d,sphere3D(p,rd,vec3(0,0,1.4),.2));\n            \n    pos=n1*p.x+n2*p.y+(MAXD+d.x)*rd;    \n    return d;   \n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 0, 1), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 R=iResolution.xy, M=iMouse.xy;\n    vec2 p= (I - .5 * R) / R.y;\n    vec2 a = vec2(1,-1); \n    float t=3.14*(.5+.4*cos(iTime)),an=-.87 -sin(iTime)*.4;    \n   \n    if(iMouse.z>0.001){t=M.x/R.x*3.14;an=-1.+M.y/R.y;}\n\n#if 1\n    vec3 ro=-vec3(cos(t)*cos(an),sin(t)*cos(an),sin(an))*4.,\n        rd = - getRayDir(ro, vec3(0), p);\n    p*=0.;\n#else\n    vec3 rd =-vec3(cos(t)*cos(an),sin(t)*cos(an),sin(an)),\n         ro=vec3(0);\n    p*=5.;\n#endif\n\n    vec3 pos;\n    vec4 d=map( p,rd,ro,pos);\n    if(d.x<0.) {\n    \n        vec3 nor=d.yzw;\n        O.xyz = (vec3(1,.5,.5)*.9 + .1*step(pos,vec3(0.)))* \n                (dot(nor,normalize(vec3(1,.6,-.8)))*.4+.6); \n        O.w=1.;\n        return;\n    }\n     \n    vec3 col =  vec3(0.3) ;\n\tcol *= 1.0 - exp(-2.0*abs(d.x));\n\tcol *= 0.2 + 0.8*cos(80.0*d.x-iTime*20.);\n\tcol = mix( col, vec3(.9,.9,0), smoothstep(0.1,0.,abs(d.x)) );\n    \n\n\tO = vec4(col,1.0);\n}\n ","name":"Image","description":"","type":"image"}]}