{"ver":"0.1","info":{"id":"dl2XWh","date":"1676263231","viewed":59,"name":"[Murilo] Ray marching demo","username":"murilomsq","description":"Ray marching demo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 400\n#define MAX_DIST 500.\n#define SURF_DIST .01\n#define RES iResolution.xy\n#define BG_COLOR vec3(0.05, 0.15, 0.2)\n#define PI 3.14159265359\n\n\n\nmat2 Rot(float a);\nvec3 fxaa(vec2 p);\n\nfloat smoothMin(float dstA, float dstB, float k){\n    float h = max(k - abs(dstA - dstB), 0.) / k;\n    return min(dstA, dstB) - h*h*h*1./6.;\n}\nfloat smoothMin(float dstA, float dstB){\n    float h = max(1. - abs(dstA - dstB), 0.);\n    return min(dstA, dstB) - h*h*h*1./6.;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)- t.x,p.y);\n  return length(q)-t.y;\n }\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(-3.*.8*sin(iTime),2,0. ,1);\n    vec4 sphere1 = vec4(3.*.8*sin(iTime),2,0. ,1);\n    \n    vec4 sphere2 = vec4(0, 3.+ 0.8*cos(iTime),0 ,1);\n    vec4 sphere3 = vec4(0, 1.- 0.8*cos(iTime),0 ,1);\n    \n    vec3 torusPos = (p-vec3(0,2.,0));\n    torusPos.zy = Rot(iTime)* torusPos.zy;\n    \n    float dT = sdTorus(torusPos, vec2(2., 0.5));\n    float dS = length(p - sphere.xyz) - sphere.w;\n    float dS1 = length(p - sphere1.xyz) - sphere1.w;\n    float dS2 = length(p - sphere2.xyz) - sphere2.w;\n    float dS3 = length(p - sphere3.xyz) - sphere3.w;\n    float dP = p.y+1.;\n    \n    \n    float s2s3 = smoothMin(dS2, dS3);\n    \n    \n    float d = min(dP, smoothMin(smoothMin(dS1, dS),smoothMin(s2s3,dT)));\n    return d;\n}\n\n\nfloat RayMarch(vec3 r0, vec3 rd){\n    float d0 = .0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = r0 + rd * d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(dS < SURF_DIST) {\n            break;\n        }\n        if(d0 > MAX_DIST){\n            d0 = 400.;\n            break;\n        }\n    }\n    return d0;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\n\n//Helper ggx's\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 GetLight(vec3 p, vec3 ro){\n    vec3 lightPos = vec3(-5,10,-5); \n    vec3 albedo = vec3(0.9,0.05,0.05);\n    float metallic = 0.2f;\n    float roughness = 0.8f;\n    float ao = 1.0f;\n\n    vec3 L = normalize(lightPos - p); //light pointing vector\n    vec3 N = GetNormal(p); // Surface normal vector\n    vec3 V = normalize(ro-p); // view vector\n    vec3 F0 = vec3(0.04);\n    vec3 H = normalize(V + L);\n    F0 = mix(F0, albedo, metallic);\n\n    vec3 Lo = vec3(0.0);\n\n    //Reflectance equation\n    float dist = length(lightPos - p);\n    float attenuation =1.0 / (dist * dist);\n    vec3 radiance = vec3(5000.0, 5000.0, 5000.0) * attenuation;\n    \n    \n    //Calculating Cook-Torrance specular part of BRDF\n\n    float NDF = DistributionGGX(N, H, roughness);\n    float G = GeometrySmith(N, V, L, roughness);\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n    \n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n    vec3 specular = numerator/denominator;\n\n    // add to outgoing radiance L0\n    float NdotL = max(dot(N,L), 0.0);\n    Lo +=  (kD * albedo/ PI + specular) * radiance * NdotL;\n\n    vec3 ambient = vec3(0.13) * albedo * ao;\n    vec3 color = ambient + Lo;\n    \n    color = color / (color + vec3(1.0)); //HDR tonemapping\n    color = pow(color, vec3(1.0/2.2));  // gamma correction\n\n\n    return color;\n    \n    //////////////////////////////////////\n    \n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0,4,-5);\n    ro.yz *= Rot(-m.y +.4);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,2,0), .7);\n\n    float d = RayMarch(ro, rd);\n\n\n    vec3 p = ro + rd * d;\n\n    vec3 light = GetLight(p, ro);\n\n    if(d == 400.){\n      light = BG_COLOR;  \n    }\n\n    col = vec3(light); \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}