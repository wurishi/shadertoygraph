{"ver":"0.1","info":{"id":"ll3yR4","date":"1531722360","viewed":111,"name":"miniDiaTest","username":"ide","description":"diatest","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["dia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rendering parameters\n#define RAY_LENGTH_MAX\t\t20.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t40\n#define COLOR\t\t\t\tvec3 (0.8, 0.8, 0.9)\n#define ALPHA\t\t\t\t0.9\n#define REFRACT_INDEX\t\tvec3 (2.407, 2.426, 2.451)\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n\n// Math constants\n#define DELTA\t0.001\n#define PI\t\t3.14159265359\n\n// Rotation matrix\n\n// Rotation matrix (rotation on the Y axis)\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n// Distance to the scene\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\nfloat getDistance (in vec3 p) {\n\n\tfloat topCut = p.y - 1.0;\n\tfloat angleStep = PI / (0.5);\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tvec3 q = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.5;\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\n\tq = vRotateY (p, angle);\n\tfloat topB = dot (q, normalTopB) - 1.85;\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistance (p + h.xxx) +\n\t\th.xyy * getDistance (p + h.xyy) +\n\t\th.yxy * getDistance (p + h.yxy) +\n\t\th.yyx * getDistance (p + h.yyx)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nfloat raycast (in vec3 origin, in vec3 direction, in vec4 normal, in float color, in vec3 channel) {\n\n\t// The ray continues...\n\tcolor *= 1.0 - ALPHA;\n\tfloat intensity = ALPHA;\n\tfloat distanceFactor = 1.0;\n\tfloat refractIndex = dot (REFRACT_INDEX, channel);\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tvec3 refraction = refract (direction, normal.xyz, distanceFactor > 0.0 ? 1.0 / refractIndex : refractIndex);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t}\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\tnormal.w += distMin;\n\t\t\tif (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (dist >= 0.0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tnormal.xyz = distanceFactor * getNormal (origin);\n\n\t\t// Basic lighting\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat localColor = (AMBIENT + relfectionDiffuse) * dot (COLOR, channel) + relfectionSpecular;\n\t\t\tcolor += localColor * (1.0 - ALPHA) * intensity;\n\t\t\tintensity *= ALPHA;\n\t\t}\n\t}\n\n\t// Get the background color\n\tfloat backColor = dot (texture (iChannel0, direction).rgb, channel);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * intensity;\n}\n\n// 主要函数\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// 重新映射坐标范围\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\t\n\n\t// 设定相机位置和方向\n\tvec3 origin = vec3(0.,0.,-5.);\n\tvec3 direction = normalize (vec3 (frag, -3.0)-origin);\n\n\t// 初始化初始射线\n\tvec4 normal = vec4 (0.0);\n    \n    float test=1./40.;\n\tfloat dist = RAY_LENGTH_MAX;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (origin);\n\t\tfloat distMin = max (dist, DELTA);\n\t\tnormal.w += distMin;\n\t\tif (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * distMin;\n        test+=1./40.;\n\t}\n\n\t// Check whether we hit something\n\tif (dist >= 0.0) {\n\t\tfragColor.rgb = vec3(0.,0.,0.);\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin);\n\n\t\tfragColor.r = raycast (origin, direction, normal, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\tfragColor.g = raycast (origin, direction, normal, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\tfragColor.b = raycast (origin, direction, normal, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t}\n\n\t// Set the alpha channel\n    fragColor.rgb=vec3(test);\n\tfragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}