{"ver":"0.1","info":{"id":"WdBcW1","date":"1586886544","viewed":227,"name":"Spiral SDF","username":"babopicasso","description":"Simple raymarcher, now with a way faster spiral SDF.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This code isn't really cleaned up or optimized at all.\n\n#define MAX_STEPS 128\n#define MIN_DIST_SURF 0.0001\n#define MAX_DIST 100.\n#define AA 1\n#define REFLECTIONS 128\n#define SHOW_NORMALS 0 // Change this to 1 to show normals\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\n// This function finds the closest distance to a parametric\n// curve of the form (cos(t), t, sin(t))\nfloat sdSpiral(vec3 p, float r, float e, float th, out vec3 normal) {\n    float phi = atan(p.z, p.x);\n    \n    float n = floor((p.y * e) / (PI2));\n    \n    float t = n * PI2 + phi;\n    \n    if(abs(phi) < PI && (t + PI) / e < p.y) t += 2. * PI;\n    \n    vec3 ph = p - vec3(r * cos(t), t / e, r * sin(t));\n        \n    normal = normalize(ph);\n    \n    return length(ph) - th;\n}\n\nfloat minDistance(in vec3 p) {\n    vec3 n;\n    return min(sdSpiral(p, 2., 5., 0.5, n), sdPlane(p, vec3(0, 1, 0), 4.));\n}\n\nvec3 getNormal(vec3 p) {\n    if(round(p.y * 10.) / 10. == -4.) return vec3(0, 1, 0);\n    \n    vec3 n;\n    \n    sdSpiral(p, 2., 5., 0.5, n);\n    \n    return n;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    float d;\n    float td = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n       \td = minDistance(ro);\n        \n        td += d;\n        ro += rd * d;\n        \n        if(td > MAX_DIST) return vec3(1. / 0.);\n        if(d < MIN_DIST_SURF) return ro;\n    }\n    \n    return vec3(1. / 0.);\n}\n\n// Copied from Inigo Quilez's webpage https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = minDistance(ro + rd*t);\n        if( h<MIN_DIST_SURF )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd, vec3 lightDir) {\n    vec3 p = march(ro, rd);\n    \n    if(p == vec3(1. / 0.)) return texture(iChannel0, rd).rgb;\n    \n    vec3 n = getNormal(p);\n    \n    if(SHOW_NORMALS == 1) return n;\n    \n    float shadow = min(1., 0.5 + softshadow(p, lightDir, 0.1, MAX_DIST, 10.));\n    \n    if(round(p.y * 10.) / 10. == -4.) {\n        p = march(ro, rd);\n        return texture(iChannel0, rd).rgb * shadow;\n    }\n    \n    vec3 r = reflect(rd, n);\n    vec3 spec = march(p + n * 0.01, r);\n    vec3 ns = getNormal(spec);\n    \n    for(int i = 0; i < REFLECTIONS; i++) {\n        if(spec != vec3(1. / 0.) && round(spec.y * 10.) / 10. != -4.) {\n            r = reflect(r, ns);\n            spec = march(p + ns * 0.0000001, r);\n            ns = getNormal(spec);\n        } else { \n            break;\n            return vec3(1, 0, 1);\n            \n        }\n    }\n    \n    return texture(iChannel1, r).rgb * shadow;\n}\n\nmat3 lookAt(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec3 lightDir = normalize(vec3(20, 100, -2));\n    vec3 col = vec3(0);\n    \n    for(int i = 0; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            vec2 o = vec2(float(i), float(j)) / float(AA) - 0.5;\n            vec2 p = (2.*fragCoord-iResolution.xy) / iResolution.y;\n            \n            vec3 ro = vec3(50. * cos(iMouse.x / iResolution.x * 6.28), 20. + (2. * iMouse.y - iResolution.y) / iResolution.y * 20., 50. * sin(iMouse.x / iResolution.x * 6.28));\n    \t\tvec3 rd = normalize(lookAt(ro, vec3(0, 5., 0), 0.) * vec3(p, 2.5));\n            \n            col += rayMarch(ro, rd, lightDir);\n        }\n    }\n    \n    col /= float(AA) * float(AA);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}