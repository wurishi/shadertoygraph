{"ver":"0.1","info":{"id":"dl2yWD","date":"1691809337","viewed":36,"name":"Ray-Arrow intersection","username":"Envy24","description":"Ray-Arrow intersection. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","intersection","approximation","cone","normal","cylinder","arrow"],"hasliked":0,"parentid":"dtSyWD","parentname":"Ray-Cone intersection (unit) imp"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec3 get_background() { return vec3(.1, .4, .6); }\n\n#define NUM_OF_OBJECTS ( 1 )\nmat4 FWDs[NUM_OF_OBJECTS]; // per object forward transformations.\nmat4 BWDs[NUM_OF_OBJECTS]; // per object backward transformations.\n\nvoid init_scene()\n{    \n    vec2 M = iMouse.xy == vec2(0) ? vec2(0) : (2.*iMouse.xy/iResolution.xy) - 1.,\n         R = vec2( M.x, M.y );\n    FWDs[0] = \n        iMouse.z > 0. ? \n            fwd_srt_transform(vec3(1,1,1), vec3(-R.y*6.,0,-R.x*6.), vec3(0)) :\n            fwd_srt_transform(vec3(1,1,1), vec3(0,0,3.141592/2.), vec3(0));\n            //fwd_srt_transform(vec3(1), vec3(0), vec3(0));\n    BWDs[0] = inverse(FWDs[0]);\n}\n\nHIT find_closest_intersection(RAY ray)\n{   \n    HIT c_hit;\n    c_hit.hit_dist = 9e5; c_hit.hit_something = false;\n    \n    for (int i = 0; i < NUM_OF_OBJECTS; ++i)\n    {\n        // Apply inverse transform.\n        RAY r = apply_transform_to_ray(ray, BWDs[i]);\n\n        // Intersect with simplified primitive.\n        HIT hit = ray_arrow_int(r, 1. + sin(iTime*3.), 0.5 + 1. + sin(iTime));\n        //HIT hit = ray_arrow_int(r, 2.0, 0.5);\n        \n        // Hit something closer?\n        if (c_hit.hit_dist > hit.hit_dist)\n        {\n            c_hit = hit;\n            c_hit.hitted_idx = i;\n        }\n    }\n    \n    // Recover hit_point and normal in world coordinates.\n    int idx = c_hit.hitted_idx;\n    c_hit.hit_point = apply_transformation_to_point(c_hit.hit_point, FWDs[idx]);\n    c_hit.hp_normal = apply_transformation_to_normal(c_hit.hp_normal, BWDs[idx]); // https://www.shadertoy.com/view/mtjczz\n    return c_hit;\n}\n\nvec3 lambert(RAY ray, HIT hit) // lambert reflectance model\n{\n    vec3 light_pos = vec3(2,2,2),\n         hp_to_l = normalize(light_pos - hit.hit_point),\n         obj_col = 1.-get_background();\n\n    float diffuse = max(dot(hp_to_l, hit.hp_normal), 0.);\n    \n    return hit.hit_something == true ?\n        obj_col * diffuse :\n        get_background();\n}\n\nvec3 scene(vec2 SC)\n{\n    init_scene();\n\n    // Generate primary ray.\n    vec2 MP = iMouse.xy == vec2(0) ?\n        vec2(0) :\n        map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n    //RAY ray = perspective_camera(SC, vec3(0,0,20.), vec3(0), iResolution.xy);\n    RAY ray = orthographic_camera(SC, vec3(0,0,30.), vec3(0), iResolution.xy);\n\n    // Trace scene.\n    HIT hit = find_closest_intersection(ray);\n    \n    // Process lights.\n    return lambert(ray, hit);\n}\n\n// Basic anti-aliasing (supersample).\nvec3 OSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = 1., inv = 1./(2.*order + 1.), blur = 1.;\n\n    for (float y = -order; y <= order; y += 1.0)\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            vec2 offset = (blur*vec2(x, y)) * inv;\n            col += scene(SC + offset);\n        }\n        \n    order = 2.*order + 1.;\n    return col / (order*order);  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    //O = vec4(scene(SC),1.0);\n    O = vec4(OSSAA(SC), 1.0);\n    \n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false);\n    \n    // Camera look_at.\n    O = mix(O, vec4(0,1,0,1), smoothstep(3., 0., length(SC - 0.5*iResolution.xy) - 2.));\n    O = mix(O, vec4(0,1,0,1), smoothstep(4./iResolution.y, 0., length(NDC - vec2(-0.5,0)) - 0.01));\n    O = mix(O, vec4(0,1,0,1), smoothstep(4./iResolution.y, 0., length(NDC - vec2(-1.,0)) - 0.01));\n    O = mix(O, vec4(0,1,0,1), smoothstep(4./iResolution.y, 0., length(NDC - vec2(-0.25,0)) - 0.01));\n    O = mix(O, vec4(0,1,0,1), smoothstep(4./iResolution.y, 0., length(NDC - vec2(-0.75,0)) - 0.01));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Structures.\nstruct RAY\n{\n    vec3 position;\n    vec3 direction;\n};\nstruct HIT\n{\n    bool hit_something;\n    float hit_dist;\n    vec3 hit_point;\n    vec3 hp_normal;\n    int hitted_idx;\n};\n\n// Cameras.\nRAY perspective_camera(vec2 SC, vec3 position, vec3 look_at, vec2 resolution)\n{\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = position;\n\n    vec3 f = normalize(look_at - camera);               // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n        \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = resolution.x / resolution.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n\n    return RAY(\n        camera,\n        normalize(uv.x * r + uv.y * u + f * zFocalLength));\n}\nRAY orthographic_camera(vec2 SC, vec3 pos, vec3 look_at, vec2 resolution)\n{\n    vec3 vp = pos;                 // viewport and camera position\n    \n    vec3 f = normalize(look_at - vp);                   // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n    \n    float aspectRatio = resolution.x / resolution.y;\n    float orthographicScale = 14.;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n   \n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n     \n    RAY ray;\n    return RAY(\n        vp + uv.x * r + uv.y * u,\n        f);\n}\n\n// Ray-Object intersection routines.\nHIT ray_unit_cone_XZ_int(RAY ray, float r)\n{\n    // Cone definition:\n    // pos = vec3(0), height = 1, r = 1 (at base)\n    // equatuion: x^2 + z^2 = y^2\n    float A = ray.position.x, B = ray.direction.x,\n          F = ray.position.z, G = ray.direction.z,\n          C = ray.position.y, D = ray.direction.y,        \n          a = B*B + G*G - D*D,\n          b = 2. * (A*B + F*G - C*D),\n          c = A*A + F*F - C*C;\n    \n    HIT hit;\n    /* Solve A*t^2 + B*t + C = 0 */\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0. ||             // no real roots?\n       (c < 0. && C <= 0. && C >= -1.))  // inside cone?\n        // Delete last condition if you want allow interior hits.\n    {\n        hit.hit_something = false; \n        return hit; \n    }\n    \n    float sqrt_D = sqrt(discriminant),\n          rootA = (-b + sqrt_D) / (2. * a),\n          rootB = (-b - sqrt_D) / (2. * a);\n    /**/\n    float rootC = (-1.-ray.position.y)/ray.direction.y;\n    \n    // Mark negative roots as \"infinite\"\n    rootA = rootA < 0. ? 9e5 : rootA;\n    rootB = rootB < 0. ? 9e5 : rootB;\n    rootC = rootC < 0. ? 9e5 : rootC;\n    \n    vec3 hpA = ray.position + ray.direction * rootA,\n         hpB = ray.position + ray.direction * rootB,\n         hpC = ray.position + ray.direction * rootC;\n    \n    // Drop off roots with hits out of cone bounds.\n    rootA = hpA.y > 0. || hpA.y < -1. ? 9e5 : rootA;\n    rootB = hpB.y > 0. || hpB.y < -1. ? 9e5 : rootB;\n    rootC = dot(hpC.xz, hpC.xz) > 1. ? 9e5 : rootC;\n\n    // Pick smallest root.\n    float root = min(rootA, min(rootB, rootC));\n    \n    if (root == 9e5) // \"Infinite\" root?\n    {\n        hit.hit_something = false;\n        return hit;\n    }\n\n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = root == rootC ?\n        vec3(0,-1,0) :reflect(\n                        -normalize(hit.hit_point),\n                         normalize(vec3(hit.hit_point.x, 0., hit.hit_point.z))); // geometric\n\n    return hit;\n}\nHIT ray_cylinder_XZ_int(RAY ray, float hh, float r)\n{     \n    // Cylinder definition:\n    // pos = vec3(0), radius = r, height = 2*hh,\n    // equation: x^2 + z^2 = r^2\n\n    float k = ray.position.x, l = ray.direction.x,\n          m = ray.position.z, n = ray.direction.z,\n          a = l*l + n*n,\n          b = 2. * (k*l + m*n),\n          c = k*k + m*m - r*r;\n    \n    /* Solve a*t^2 + b*t + c = 0 */\n    float discriminant = b * b - 4.0 * a * c,\n          sqrt_D = sqrt(discriminant),\n          sign_b = b >= 0.? 1. : -1.,\n          root = min(\n            -(b + sign_b*sqrt_D) / (2.*a),\n            -(2.*c) / (b+sign_b*sqrt_D));      \n    /**/\n    HIT hit; \n    \n    vec3 hpA = ray.position + ray.direction * root;\n    \n    // Check Ray-Disk intersection.\n    if (abs(hpA.y) >= hh)\n    {\n        float offs = hpA.y >= 0. ? hh : -hh,\n              root1 = (offs-ray.position.y)/ray.direction.y;\n        \n        vec3 hpB = ray.position + ray.direction * root1;\n\n        if (dot(hit.hp_normal, ray.direction) > .0 || // back face of disk?    \n            root1 < 0. ||                             // behind camera?\n            hpB.x*hpB.x + hpB.z*hpB.z > r*r ||        // no disk hit?\n            discriminant < 0.)                        // no cylinder hit?\n        {\n            hit.hit_something = false; \n            return hit; \n        }\n\n        hit.hit_point = hpB;\n        hit.hp_normal = hpA.y >= 0. ? vec3(0,1,0) : vec3(0,-1,0);\n        hit.hit_dist = root1;\n        hit.hit_something = true;\n        \n        return hit;\n    }\n\n    if (root < 0. ||       // inside cylinder?\n        discriminant < 0.) // no real roots?\n    {\n        hit.hit_something = false; \n        return hit; \n    }\n\n    // Side hit.\n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = hpA;\n    hit.hp_normal = -normalize(vec3(0,hit.hit_point.y,0) - hit.hit_point);\n    \n    return hit;\n}\n// Starts at vec3(0) and points to vec3(0) + vec3(0,len,0);\nHIT ray_arrow_int(RAY ray, float len, float r)\n{\n    RAY s_ray = ray;\n        s_ray.position.y -= max(2.*len, r);\n        s_ray.position /= r;\n    RAY t_ray = ray;\n        t_ray.position.y -= max(len - r*0.5, 0.);\n\n    HIT hitA = ray_unit_cone_XZ_int(s_ray, r),\n        hitB = ray_cylinder_XZ_int(t_ray, max(len-r*0.5, 0.), r*.5);\n    \n    if (hitA.hit_something == false)\n        return hitB;\n    else if (hitB.hit_something == false)\n        return hitA;\n    else if (hitA.hp_normal == vec3(0,-1,0))\n        return hitB;\n\n   return hitA;\n}\n\n/*\n    Matricies for column vectors and row major matricies,\n    because i prefer this variant)\n    \n    Multiplication order:\n    T2 * T1 * T0 * V;\n    \n    Representation for points and directions\n    in homogeneous coordinates:\n        Points     p = vec4(p.xyz, 1),\n        Direction  d = vec4(p.xyz, 0).\n*/\nmat4 scale(vec3 s)\n{\n    mat4 M = mat4(\n        s.x,   0,   0, 0,\n          0, s.y,   0, 0,\n          0,   0, s.z, 0,\n          0,   0,   0, 1);\n    return transpose(M);\n}\nmat4 rotX(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         1, 0,  0, 0,\n         0, c, -s, 0,\n         0, s,  c, 0,\n         0, 0,  0, 1);\n    return transpose(M);\n}\nmat4 rotY(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, 0, s, 0,\n         0, 1, 0, 0,\n        -s, 0, c, 0,\n         0, 0, 0, 1);\n    return transpose(M);\n}\nmat4 rotZ(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, -s, 0, 0,\n         s,  c, 0, 0,\n         0,  0, 1, 0,\n         0,  0, 0, 1);\n    return transpose(M);\n}\nmat4 translate(vec3 t)\n{\n    mat4 M = mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0,   1);\n    return transpose(M);\n}\nmat4 fwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return translate(t) * rotX(r.x) * rotY(r.y) * rotZ(r.z) * scale(s);\n}\nmat4 bwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return inverse(translate(t) * rotX(r.x) * rotY(r.y) * rotZ(r.z) * scale(s));\n}\nRAY apply_transform_to_ray(RAY ray, mat4 T)\n{\n    vec4 P = vec4(ray.position + ray.direction, 1);   \n         P = T * P;\n         \n    RAY res;\n    res.position = (T * vec4(ray.position, 1.)).xyz;\n    res.direction = normalize(P.xyz - res.position);\n    return res;\n}\nvec3 apply_transformation_to_normal(vec3 normal, mat4 T)\n{\n    mat3 SR = mat3(T[0].xyz, T[1].xyz, T[2].xyz);\n    // https://paroj.github.io/gltut/Illumination/Tut09%20Normal%20Transformation.html   \n    normal = normal * transpose(inverse(SR));\n    \n    return normalize(normal);\n}\nvec3 apply_transformation_to_point(vec3 p, mat4 T) { return (T * vec4(p, 1.)).xyz; }","name":"Common","description":"","type":"common"}]}