{"ver":"0.1","info":{"id":"WlGfDW","date":"1614309707","viewed":92,"name":"hexagonal nearest sampling","username":"BigotedSJW","description":"test for hex\nderived from https://www.redblobgames.com/grids/hexagons/\n\nI do not fully understand what I have done here.\nThere must be a much less taxing way to do this.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagon","nyancat","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 pixel_to_hex(vec2 point);\n\nvec2 pixel_to_hex_orthog(vec2 uv);\n\nvec2 hex_round(vec2 hex);\n\nvec2 cube_to_evenr(vec3 cube);\n\nvec3 cube_from_axial(vec2 hex);\n\nvec3 evenr_to_cube(vec2 hex);\n\nconst vec2 SHIFT_BY_HALFSTEP = vec2(.5);\n\nconst float frameOffsets[6] = float[6](\n    41./256.,\n    81./256.,\n    121./256., \n    161./256.,\n    201./256.,\n    241./256.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wunit = 56./(iResolution.y);\n    \n    vec2 sample1coord = pixel_to_hex_orthog(fragCoord) + SHIFT_BY_HALFSTEP;\n    vec2 sample2coord = pixel_to_hex_orthog(fragCoord + SHIFT_BY_HALFSTEP) + SHIFT_BY_HALFSTEP;\n    \n    int frameId = int(mod(iTime*12.,6.));\n    \n    vec2 scaledToPopTart1=vec2(1./256., 1./32.)*(sample1coord);\n    vec2 scaledToPopTart2=vec2(1./256., 1./32.)*(sample2coord);\n    \n    vec2 frameOffset = vec2(frameOffsets[frameId],0.);\n    \n    vec4 tex = 0.5*( //sampling twice seems not to help with hexagon edge artifacts\n         texture(iChannel0, scaledToPopTart1 + frameOffset)\n       + texture(iChannel0, scaledToPopTart2 + frameOffset)\n    );\n    \n    vec3 background = vec3(mod(sample1coord.x + iTime*18., 16.)/16., 0., scaledToPopTart1.y);\n    \n    fragColor = vec4(mix(background, tex.rgb, tex.a * step(-40.,sample1coord.x)), 1.);\n}\n\nvec2 pixel_to_hex_orthog(vec2 fragCoord){\n    float wunit = 56./(iResolution.y);\n    \n    vec2 uv = fragCoord*wunit;\n    vec2 qr = pixel_to_hex(uv);\n    vec2 rounded = hex_round(qr);\n    vec3 from_axial = cube_from_axial(rounded);\n    vec3 rotated = -from_axial.yzx;\n    vec2 to_evenr = cube_to_evenr(rotated);\n    \n    return to_evenr; // how does this get flipped in the X direction?\n}\n\nvec3 cube_round(vec3 coords){\n    vec3 naiveRound = round(coords);\n    vec3 diff = abs(coords-naiveRound);\n    \n    if(diff.x > diff.y && diff.x > diff.z){\n        return vec3(\n            - naiveRound.y - naiveRound.z,\n            naiveRound.yz);\n    } else if(diff.y > diff.z) {\n        return vec3(\n            naiveRound.x,\n            - naiveRound.x - naiveRound.z,\n            naiveRound.z);\n    } else {\n        return vec3(\n            naiveRound.xy,\n            - naiveRound.x - naiveRound.y);\n    }\n}\n\nvec2 axial_from_cube(vec3 cube){\n    return cube.xz;\n}\n\nvec3 cube_from_axial(vec2 hex){\n    return vec3(hex.x, - hex.x - hex.y, hex.y);\n}\n\nvec2 hex_round(vec2 hex){\n    return axial_from_cube(\n        cube_round(\n            cube_from_axial(hex)\n        )\n    );\n}\n\nvec2 pixel_to_hex(vec2 point){\n    mat2 rebasis = mat2(\n        2./3., -1./3.,\n        0., 1./sqrt(3.)\n    );\n    return rebasis * point;\n}\n\nvec2 cube_to_evenr(vec3 cube){\n    float col = cube.x + (cube.z + mod(cube.z,2.))*0.5;\n    return vec2(cube.z, col);\n}\n\nvec3 evenr_to_cube(vec2 hex){\n    float x = hex.y - (hex.x + mod(hex.x, 2.))*0.5;\n    return vec3(x, hex.x, -x - hex.x);\n}","name":"Image","description":"","type":"image"}]}