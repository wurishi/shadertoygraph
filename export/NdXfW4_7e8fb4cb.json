{"ver":"0.1","info":{"id":"NdXfW4","date":"1645529397","viewed":172,"name":"- EXP - Parametric Lens Focus","username":"yuempek","description":"Parametric Lens Focus, \nmouse up/down : focus\nmouse left/right : rotate plane","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["lens","bokeh","effect","focus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Yunus Emre Pektas, 2022 - https://yuempek.github.com/\n// I am the sole copyright owner of this work.\n// You cannot sell this work. I share this work for educational purposes.\n// You can link to it, through an URL, proper attribution and unmodified screenshot,\n// as part of your educational material. \n// Please contact me if you are interested in with this work.\n// yuempek @(gmail/twitter/instagram/github/linkedin/shadertoy)\n\n\n#define normal(v) v/length(v)\n\n\n// po = plane origin\n// np = normal of plane\n// ro = ray origin\n// r = ray\n// nr = normal of ray = r/length(r)\n\n\n// sd = sensor distance\n// sp = sensor point\n// lp = lens point\n// fp = focal point\n// fd = focal distance\n// fp = -sp * fd/sd\n// ray = fp - lp\n// d = distance of render plane \n\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\n// irp() = intersect ray and plane\n// irp(po, np, ro, nr) = dot(po - ro, np)/dot(nr, np)\n\nvec4 irp(vec3 po, vec3 np, vec3 ro, vec3 nr){\n    float d = dot(po - ro, np)/dot(nr, np);\n    return vec4(ro + d * nr, d);\n}\n\n\nvec4 getColor(vec3 po, vec3 np, vec3 ro, vec3 nr){\n        vec4 color = texture(iChannel0, irp(po, np, ro, nr).xy);\n\n        // for bokeh\n        // increase intensity of source. \n        // long exposure = too much photon\n        float intensity = 10.0;\n        float threshold = 0.8;\n        //color.rgb *= 1.0 + intensity*(1.0-step(color.rgb, vec3(threshold)));  // if (tex > threshold) text = text*intensity;\n\n        //color.rgb = pow(color.rgb, vec3(3.0))* intensity;\n        \n        // value bigger than threshold\n        // coefficient smoothly increase from 0 to 1\n        // coef =             -> 1..intensity;\n        // smoothstep         -> 0..1\n        // *(intensity - 1.0) -> 0..(intensity-1)\n        // + 1                -> 1..intensity\n        color.rgb *= smoothstep(vec3(threshold), vec3(1.0), color.rgb)*(intensity - 1.0) + 1.0; \n        return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo = mo * 2.0 - 1.0; // -1..+1\n    //mo.xy = mo.yx;\n    \n    \n    if(all(lessThan(iMouse.xy , vec2(2)))) \n        mo = vec2(sin(iTime));\n    \n    vec2 uv = (fragCoord - 0.5)/iResolution.x;\n    uv = uv * 2.0 - 1.0; // -1..+1\n    uv = uv * 0.035/2.0; // *sensorwidth/2\n    \n    \n    float sd = 0.150;                //sensor distance (meter) (or focal length)\n    vec3  sp = vec3(uv, sd);        //sensor point\n    vec3  lp = vec3(0);            //lens point\n    float fd = 10.0 + mo.y*2.0;   //focal distance (meter)\n    fd += (abs(mo.x)*2.0)*(mo.y + 1.0);\n    float  d = 10.0;             //distance of render plane  (meter)\n    vec3  fp = sp * fd/sd;      //focal point\n    float ls = 0.060;          //lens radius size \n    \n\n    \n    vec4 color = vec4(0);\n    float w = 0.0;\n    \n    vec3 po = vec3(0, 0, d);\n    vec3 np = normalize(vec3(sin(-mo.x)*5.0, 0.0, 1.0));\n    \n    \n        \n    vec3 ro;\n    vec3 ray;\n    vec3 nr;\n    \n    \n    // !!!! select a lens shape !!!!\n    //#define SQUARE\n    //#define HONEYCOMB \n    #define PHYLLOTAXIS\n\n    \n    #if defined (SQUARE)\n    for (float lx = -1.0; lx <= 1.0; lx += 0.5)\n        for (float ly = -1.0; ly <= 1.0; ly += 0.5) {\n            \n            vec3 offset = vec3(lx, ly, 0.0);\n            ro = lp + offset*ls; //get next lens point\n            ray = fp - ro; //ray from lens point to focal point\n            nr = normalize(ray);\n            color += getColor(po, np, ro, nr);\n        }\n    #elif defined (HONEYCOMB)\n    \n      for (int i = 0; i < lpArray.length(); i++) {\n              \n          ro = lpArray[i]*ls; //get next lens point\n          ray = fp - ro; //ray from lens point to focal point\n          nr = normalize(ray);\n          color += getColor(po, np, ro, nr);\n      }\n    \n    #elif defined (PHYLLOTAXIS)\n        // Golden Angle = PI*(3-sqrt(5))\n        #define GOLDEN_ANGLE 2.39996\n\n        mat2 rotate = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n        int lpCount = 100;\n        \n        float normalizeCoef = sqrt(float(2*lpCount)); \n         \n        vec2 vec = vec2(0.0, 1.0);\n        \n        for (int j = 0; j < lpCount; j++)\n        {  \n            float radius = (sqrt(float(2*j))-1.0)/normalizeCoef * ls;\n            vec *= rotate;\n            \n            ro = vec3(vec * radius, 0.0); //get next lens point\n            ray = fp - ro; //ray from lens point to focal point\n            nr = normalize(ray);\n            color += getColor(po, np, ro, nr);\n        }\n    #endif\n\n    \n    \n    fragColor = vec4(color/color.w);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 1+3n(n+1);\n\n#define HONEYCOMB37\n\n#ifdef HONEYCOMB19\nconst vec3 lpArray[19] = vec3[19](\nvec3(0.000, 0.000, 0.0),\nvec3(0.500, 0.000, 0.0),\nvec3(-0.500, 0.000, 0.0),\nvec3(0.250, 0.433, 0.0),\nvec3(-0.250, 0.433, 0.0),\nvec3(0.250, -0.433, 0.0),\nvec3(-0.250, -0.433, 0.0),\nvec3(-0.000, 0.866, 0.0),\nvec3(-0.000, -0.866, 0.0),\nvec3(1.000, 0.000, 0.0),\nvec3(-1.000, 0.000, 0.0),\nvec3(0.750, 0.433, 0.0),\nvec3(-0.750, 0.433, 0.0),\nvec3(0.750, -0.433, 0.0),\nvec3(-0.750, -0.433, 0.0),\nvec3(0.500, 0.866, 0.0),\nvec3(-0.500, 0.866, 0.0),\nvec3(0.500, -0.866, 0.0),\nvec3(-0.500, -0.866, 0.0)\n);\n#endif\n\n#ifdef HONEYCOMB37\nconst vec3 lpArray[37] = vec3[37](\nvec3(0.000, 0.000, 0.0),\nvec3(0.333, 0.000, 0.0),\nvec3(-0.333, 0.000, 0.0),\nvec3(0.167, 0.289, 0.0),\nvec3(-0.167, 0.289, 0.0),\nvec3(0.167, -0.289, 0.0),\nvec3(-0.167, -0.289, 0.0),\nvec3(-0.000, 0.577, 0.0),\nvec3(-0.000, -0.577, 0.0),\nvec3(0.667, 0.000, 0.0),\nvec3(-0.667, 0.000, 0.0),\nvec3(0.500, 0.289, 0.0),\nvec3(-0.500, 0.289, 0.0),\nvec3(0.500, -0.289, 0.0),\nvec3(-0.500, -0.289, 0.0),\nvec3(0.333, 0.577, 0.0),\nvec3(-0.333, 0.577, 0.0),\nvec3(0.333, -0.577, 0.0),\nvec3(-0.333, -0.577, 0.0),\nvec3(0.167, 0.866, 0.0),\nvec3(-0.167, 0.866, 0.0),\nvec3(0.167, -0.866, 0.0),\nvec3(-0.167, -0.866, 0.0),\nvec3(1.000, 0.000, 0.0),\nvec3(-1.000, 0.000, 0.0),\nvec3(0.833, 0.289, 0.0),\nvec3(-0.833, 0.289, 0.0),\nvec3(0.833, -0.289, 0.0),\nvec3(-0.833, -0.289, 0.0),\nvec3(0.667, 0.577, 0.0),\nvec3(-0.667, 0.577, 0.0),\nvec3(0.667, -0.577, 0.0),\nvec3(-0.667, -0.577, 0.0),\nvec3(0.500, 0.866, 0.0),\nvec3(-0.500, 0.866, 0.0),\nvec3(0.500, -0.866, 0.0),\nvec3(-0.500, -0.866, 0.0)\n);\n#endif","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// logic    \n    // foreach lp\n    //   po = [0 0 d];\n    //   np = [0 0 1];\n    //   ro = lp;\n    //   nr = normal(ray);\n    //   color = sum(texture(irp(po, np, ro, nr).xy)\n    // color /= lp.length;\n    \n    \n    // This is a typical camera model (sensor + lens + object)\n    // I modelled the lens with discrete points centered on origin.\n    //\n    //\n    ////                  points on lens                                          \n    ////                         .                                        ooo    \n    ////                                                                 o\\o/o   \n    ////   sensor                .                                        o\\o    \n    ////      |                    (0,0)                                   H     \n    ////      |___sensor dist ___./____________focal distance______________H     \n    ////      |                                                                  \n    ////      |                  .                                               \n    ////                                                                         \n    ////                         .                                               \n    ////  \n\n\n    // For each sensor point calculated from pixels, \n    // we find the focused point of the sensor point \n    // with triangle similarity on lens origin \n    // with using focused distance and sensor distance.  \n    //\n    //    \n    ////                       pl(i)                                             \n    ////                         .                                 ________. fp \n    ////                                                __________/        |    \n    ////   sensor                .           __________/                   |    \n    ////      |                    _________/                              |    \n    ////      |________sd________./__________________fd____________________|    \n    ////      |         ________/                                               \n    ////   ps !________/         .                                              \n    ////                                                                        \n    ////                         .                                              \n    ////\n\n    // Then we throw ray from each point on lens to this point. \n    // Because all rays should be focused on the same point. \n    //\n    ////                       pl(i)                                             \n    ////                       __._________________________________________. fp \n    ////                    __/                                            |    \n    ////   sensor        __/     .                                         |    \n    ////      |       __/                                                  |    \n    ////      |______/_sd________. __________________fd____________________|    \n    ////      | __/                                                             \n    ////   ps !/                 .                                              \n    ////                                                                        \n    ////                         .                                              \n    ////\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    discard;\n}","name":"Buffer A","description":"","type":"buffer"}]}