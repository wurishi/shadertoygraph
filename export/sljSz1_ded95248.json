{"ver":"0.1","info":{"id":"sljSz1","date":"1627124330","viewed":64,"name":"Primitives dance","username":"noocar","description":"Some SDF practice.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.835, 1, 1);\nconst vec3 LIGHT_POSITION = vec3(0.);\n\n\nstruct Material {\n    uint id;\n    vec3 color;\n};\n\nstruct Surface {\n    float dist;\n    Material material;\n};\n\n\n// Random\nvec3 hash3( uint n ) {\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n// ----------\n\n\n// Transforms\nmat4 scale(vec3 s)\n{\n    return mat4(\n        vec4(s.x, 0, 0, 0),\n        vec4(0, s.y, 0, 0),\n        vec4(0, 0, s.z, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotation(vec3 r)\n{\n    float cx = cos(r.x);\n    float sx = sin(r.x);\n    float cy = cos(r.y);\n    float sy = sin(r.y);\n    float cz = cos(r.z);\n    float sz = sin(r.z);\n    return mat4(\n        vec4(cy*cz, -cy*sz, sy, 0),\n        vec4(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy, 0),\n        vec4(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy, 0),\n        vec4(0, 0, 0, 1)\n    );     \n}\n\nmat4 translation(vec3 t)\n{\n    return mat4(\n        vec4(1, 0, 0, t.x),\n        vec4(0, 1, 0, t.y),\n        vec4(0, 0, 1, t.z),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 identity() {\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 loockAt(vec3 pos, vec3 target) {\n\tvec3 dir = normalize(target - pos);\n\tvec3 right = normalize(cross(vec3(0., 1., 0.), dir));\n\tvec3 uu = normalize(cross(dir, right));\n\t\n\treturn mat4(\n        vec4(-right, 0.), \n        vec4(uu, 0.),\n        vec4(-dir, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\nvec3 applyPoint(mat4 m, vec3 v)\n{\n    vec4 v4 = vec4(v, 1.);\n    v4 = v4 * m;\n    return v4.xyz / v4.w;\n}\n\nvec3 applyVector(mat4 m, vec3 v)\n{\n    vec4 v4 = vec4(v, 0.);\n    v4 = v4 * m;\n    return v4.xyz;\n}\n// ----------\n\n\n// Signed Distance Functions\n// https://iquilezles.org/articles/distfunctions\nSurface sdSphere(vec3 p, float s, Material material)\n{\n    float d = length(p)-s;\n    return Surface(d, material);\n}\n\nSurface sdBox(vec3 p, vec3 b, Material material)\n{\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return Surface(d, material);\n}\n\nSurface sdTorus(vec3 p, vec2 t, Material material)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Surface(d, material);\n}\n\nSurface sdCone(vec3 p, vec2 c, float h, Material material)\n{\n    float q = length(p.xz);\n    float d = max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n    return Surface(d, material);\n}\n\nSurface sdTriPrism(vec3 p, vec2 h, Material material)\n{\n    vec3 q = abs(p);\n    float d = max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    return Surface(d, material);\n}\n\nSurface sdCappedCylinder(vec3 p, float h, float r, Material material)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    float di = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return Surface(di, material);\n}\n\nSurface sdSolidAngle(vec3 p, vec2 c, float ra, Material material)\n{\n  // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), p.y );\n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    float d = max(l,m*sign(c.y*q.x-c.x*q.y));\n    return Surface(d, material);\n}\n\nSurface sdUnion(Surface obj1, Surface obj2) {\n    if (obj2.dist < obj1.dist) return obj2;\n    return obj1;\n}\n// ----------\n\n\nmat4 randomOrbitRotation(uint seed)\n{\n    vec3 rnd = hash3(seed);\n    float radius = mix(10., 30., rnd.x);\n    float ors = mix(.1, .4, rnd.z); // orbit rotation speed\n    float lrs = mix(.3, .6, rnd.y); // local rotation speed\n    mat4 rt = translation(vec3(0., 0., 1.) * radius);  // radius translation\n    mat4 o = rt * rotation(rnd * PI2);  // orbit\n    vec3 wp = applyPoint(o, vec3(0., 0., 1.)); // position World Space\n    mat4 or = rotation(vec3(0., iTime * PI2 * ors, 0.)); // orbit rotation\n    mat4 lr = rotation(rnd * iTime * PI2 * lrs); // local rotation\n    mat4 m = loockAt(wp, vec3(0.)) * or * rt * lr; // result matrix\n\n    return m;\n}\n\n\nSurface sdScene(vec3 p) {\n    Material mt = Material(0U, vec3(0.));\n    Surface s = Surface(MAX_DIST, mt);\n    s = sdUnion(s, sdSphere(p, 1.5, mt)); // center\n\n    // Boxes\n    mt = Material(1U, vec3(.9, .3, .1));\n    for (int i = 1; i <= 10; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface box = sdBox(applyPoint(m, p), vec3(1), mt);\n        s = sdUnion(s, box);\n    }\n    \n    // Toruses\n    mt = Material(2U, vec3(.2, .4, .1));\n    for (int i = 11; i <= 20; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface torus = sdTorus(applyPoint(m, p), vec2(1., .3), mt);\n        s = sdUnion(s, torus);\n    }\n    \n    // Cones\n    mt = Material(3U, vec3(.1, .2, .6));\n    for (int i = 21; i <= 30; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface cone = sdCone(applyPoint(m, p), vec2( .5, .2), 3., mt);\n        s = sdUnion(s, cone);\n    }\n    \n    // Prisms\n    mt = Material(4U, vec3(.4, .2, .3));\n    for (int i = 41; i <= 50; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface prism = sdTriPrism(applyPoint(m, p), vec2(1., 1.4), mt);\n        s = sdUnion(s, prism);\n    }\n    \n    // Cylinders\n    mt = Material(5U, vec3(.7, .2, .6));\n    for (int i = 51; i <= 60; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface cylinder = sdCappedCylinder(applyPoint(m, p), .7, 1., mt);\n        s = sdUnion(s, cylinder);\n    }\n    \n    // Angles\n    mt = Material(6U, vec3(.5, .9, .9));\n    for (int i = 61; i <= 70; i++) {\n        mat4 m = randomOrbitRotation(uint(i));\n        Surface angle = sdSolidAngle(applyPoint(m, p), vec2(3,4)/5.0, 2.5, mt);\n        s = sdUnion(s, angle);\n    }\n    \n    return s;\n}\n\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.dist;\n        if (co.dist < PRECISION || depth > end) break;\n    }\n\n    co.dist = depth;\n\n    return co;\n}\n\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).dist +\n        e.yyx * sdScene(p + e.yyx).dist +\n        e.yxy * sdScene(p + e.yxy).dist +\n        e.xxx * sdScene(p + e.xxx).dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, 50); // ray origin that represents camera position\n    vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n    if (co.dist > MAX_DIST) {\n        col = BACKGROUND_COLOR;\n    }\n    else {\n        vec3 p = ro + rd * co.dist; // point on the surface we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightDirection = normalize(LIGHT_POSITION - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n        col = dif * co.material.color + BACKGROUND_COLOR * .2; // Add a bit of background color to the diffuse color\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}