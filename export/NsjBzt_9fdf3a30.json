{"ver":"0.1","info":{"id":"NsjBzt","date":"1646872990","viewed":273,"name":"RGBW playground","username":"stduhpf","description":"Matching \"unbound\" RGB colors as best as possible with RGBW output.\nleft RGB columns and the top bars are interactive sliders.\nsee https://www.shadertoy.com/view/7sBfWW for more details","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ui","blackbody"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define INT_MATH\n\nconst mat3 xyz = mat3(3.240479, -1.537150, -0.498535, -0.969256, 1.875992, 0.041556, 0.055648, -0.204043, 1.057311);\n\nvec3 rgblackbodyUv(float x) {\n    vec3 col = texture(iChannel0, vec2(x, 1.)).rgb;\n\n    col = col * xyz;\n    {// slightly adjust xyz to rec.709 transform so that the computed 6500K blackbody correspond exactly to rec.709 white point (D65)\n        //otherwise there's a slight difference (maybe due to D65 not actually being a pure blackbody)\n        float x = TTouv(6500.); // == 0.5\n        vec3 d65 = texture(iChannel0, vec2(x, 1.)).rgb * xyz;\n        col.rgb /= d65;\n    }\n\n    return col / max(col.r, max(col.g, col.b)); //could also normalize using luminance instead of max\n}\n\n// rec.709 primaries relative luminance (or luma)\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\nconst ivec3 luma_int = ivec3(255. * luma);\n\nvec3 getCol() {\n    vec4 c = texture(iChannel0, vec2(1.5) / iChannelResolution[0].xy);\n    if(c.a <= 0.)\n        return rgblackbodyUv(abs(fract(iTime * .1) * 2. - 1.)) * (sin(iTime) * .3 + .3);\n    return c.rgb;\n}\n\nfloat getWhiteInt() {\n    return texture(iChannel0, vec2(3.5) / iChannelResolution[0].xy).r;\n}\n\nfloat getTempC() {\n    return texture(iChannel0, vec2(5.5) / iChannelResolution[0].xy).r;\n}\n\nfloat getW_alg() {\n    float phase = texture(iChannel0, vec2(7.5) / iChannelResolution[0].xy).r;\n    return phase >= 0. ? phase : .5 + .5 * sin(iTime * .25);\n}\n\nint idot_2(ivec3 a, ivec3 b) {\n    return a.r * b.r + a.g * b.g + a.b * b.b;\n}\n\n#ifdef INT_MATH\n// aproximation using integer math \n// (hardware should support signed 25 bit integers at least (signed 32 bits is plently) for 0-255 range output)\nconst int MAXRGB = 255;\nivec4 RGBW_max_int(ivec3 target, ivec3 whitePrimary) {\n    bool noW = whitePrimary.r + whitePrimary.g + whitePrimary.b <= 0;\n    if(noW)\n        return ivec4(target, MAXRGB);\n\n    int whiteLuminance = idot_2(whitePrimary, luma_int);\n    ivec3 target_wb = (target * MAXRGB) / whitePrimary;\n\n    int white = min(MAXRGB, min(target_wb.r, min(target_wb.g, target_wb.b)));\n\n    ivec3 rgb = target - (whitePrimary * white) / MAXRGB;\n\n    ivec3 overshoot = max(rgb, MAXRGB) - MAXRGB;\n\n    white += (MAXRGB * idot_2(overshoot, luma_int)) / whiteLuminance;\n    rgb = min(rgb, MAXRGB);\n\n    int whiteOvershoot = max(white, MAXRGB) - MAXRGB;\n    ivec3 headroom = MAXRGB - rgb;\n    rgb += (headroom * min((whiteOvershoot * whiteLuminance) / idot_2(luma_int, headroom), MAXRGB)) / MAXRGB;\n    white = min(white, MAXRGB);\n\n    return ivec4(rgb, white);\n}\nivec4 RGBW_min_int(ivec3 target, ivec3 whitePrimary) {\n    bool noW = whitePrimary.r + whitePrimary.g + whitePrimary.b <= 0;\n    if(noW)\n        return ivec4(target, MAXRGB);\n\n    int whiteLuminance = idot_2(whitePrimary, luma_int);\n    ivec3 overshoot_wb = (max(target - MAXRGB, 0) * MAXRGB) / whitePrimary;\n\n    int white = max(overshoot_wb.r, max(overshoot_wb.g, overshoot_wb.b));\n\n    ivec3 rgb = target - (whitePrimary * white) / MAXRGB;\n\n    ivec3 undershoot = min(rgb, 0);\n\n    white += (MAXRGB * idot_2(undershoot, luma_int)) / whiteLuminance; // adding negative value here (needs signed ints)\n    rgb = max(rgb, 0);\n\n    int whiteOvershoot = max(white, MAXRGB) - MAXRGB;\n    ivec3 headroom = MAXRGB - rgb;\n    rgb += (headroom * min((whiteOvershoot * whiteLuminance) / idot_2(luma_int, headroom), MAXRGB)) / MAXRGB;\n    white = min(white, MAXRGB);\n\n    return ivec4(rgb, white);\n}\n#endif\n\n/*\n    This Algorithm maximises the utilisation of the white channel\n    It could be usefull for applications where higher CRI is better\n    The downside is that if the white lightsource stops working,\n    the colors will look completely different\n*/\nvec4 RGBW_max(vec3 target, vec3 whitePrimary) {\n    #ifdef INT_MATH\n    return vec4(RGBW_max_int(ivec3(round(target * 255.)), ivec3(round(whitePrimary * 255.)))) / 255.;\n    #endif\n    bool noW = dot(whitePrimary, whitePrimary) == 0.;\n    if(noW)\n        return vec4(target, 1);\n\n    float whiteLuminance = dot(whitePrimary, luma);\n\n    vec3 target_wb = target / whitePrimary; //colors mapped to a similar colorspace, but with W as whitepoint (kinda like a color temperature change)\n\n    float white = min(min(target_wb.r, min(target_wb.g, target_wb.b)), 1.); //baseline amount of W\n\n    vec3 rgb = target - white * whitePrimary; //remaining colors after removing the baseline\n\n    //the following only changes anything if some component of c is gerater than 1.\n    //this means that the input color has at least one component above 1+w*W\n\n    //this is the part that \"desaturates\" colors that still overshoot the RGB space after removing baseline,towards W\n    //the luminance of the output will match the input as long as the original input is within the [vec3(0),1+W] range \n    white += dot(max(rgb, 1.) - 1., luma) / whiteLuminance; //anything above 1. is converted to white while preserving luminance\n    rgb = min(rgb, 1.); // removes the extra colors that got converted to white\n\n    // \"refinement\" step, where the extra white gets converted back to colors if there is still some non-full channels\n    float whiteOvershoot = max(white, 1.) - 1.;\n    rgb += (1. - rgb) * min(whiteOvershoot * whiteLuminance / dot(luma, 1. - rgb), 1.);\n    white = min(white, 1.);\n\n    return vec4(rgb, white);\n}\n\n/*\n    This Algorithm minimises the utilisation of the white channel\n    It could be usefull for applications where putting too much \n    strain on a single source might damage it. Plus the colors stay\n    close to the original colors if the white lightsource breaks\n    The downside is that the CRI is typically worse\n*/\nvec4 RGBW_min(vec3 target, vec3 whitePrimary) {\n    #ifdef INT_MATH\n    return vec4(RGBW_min_int(ivec3(round(target * 255.)), ivec3(round(whitePrimary * 255.)))) / 255.;\n    #endif\n    bool noW = dot(whitePrimary, whitePrimary) == 0.;\n    if(noW)\n        return vec4(target, 0);\n\n    float whiteLuminance = dot(whitePrimary, luma);\n\n    vec3 overshoot_wb = max(target - 1., 0.) / whitePrimary; //overshoot of colors mapped to a similar colorspace, but with W as whitepoint (kinda like a color temperature change)\n\n    float white = max(max(overshoot_wb.r, overshoot_wb.g), overshoot_wb.b);//baseline amount of W\n\n    vec3 rgb = target - white * whitePrimary;\n\n    //the following only changes anything if some component of c is lower than 0.\n    //this means that the input color has at least one component under 1-w*W\n\n    //this is the part that \"desaturates\" colors that still overshoot the RGB space after removing baseline,towards W\n    //the luminance of the output will match the input as long as the original input is within the [vec3(0),1+W] range \n\n    vec3 undershoot = min(rgb, 0.); // negative channels only\n    float undershootLuminance = dot(undershoot, luma);  // negative luminance of the negative channels\n\n    white += undershootLuminance / whiteLuminance; // remove some white according to the luminance requirements\n    rgb = max(rgb, 0.);// adds back the missing colors that got removed from white\n\n    // \"refinement\" step, where the extra white gets converted back to colors if there is still some non-full channels\n    float whiteOvershoot = max(white, 1.) - 1.;\n    rgb += (1. - rgb) * min(whiteOvershoot * whiteLuminance / dot(luma, 1. - rgb), 1.);\n    white = min(white, 1.);\n\n    return vec4(rgb, white);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float wi = getWhiteInt();\n    float Tc = getTempC();\n    float T = uvToT(Tc);\n\n    float ma = 5.;\n\n    vec3 t = clamp(getCol(), 0., 1.) * ma;\n    vec3 t0 = t;\n\n    vec3 W = rgblackbodyUv(Tc) * wi * .5; //varying the white max brightness over time\n\n    //this algorithm breaks if W is outside the RGB gamut (even in cases where there is a solution), so we force positive coordinates\n    //otherwise whites under 1900K would not work\n    W = max(W, 1e-6);\n\n    // If there is a way to reproduce input with RGBW\n    // then all the possible outputs are a linear mix of the outputs with\n    // the lowest value of w, and the one with highest w\n    float W_usage = getW_alg();\n    vec4 minresult = RGBW_min(t0, W);\n    vec4 maxresult = RGBW_max(t0, W);\n    #ifdef INT_MATH\n    //int-based lerp\n    const int steps = 4194303; // result*steps should never overflows\n    int Wusage = int(W_usage*float(steps));\n\n    ivec4 inresult = ivec4(minresult*255.);\n    ivec4 axresult = ivec4(maxresult*255.);\n    ivec4 iresult = (inresult * Wusage + axresult * (steps - Wusage))/steps;\n    vec4 result = vec4(iresult)/255.;\n    #else\n    vec4 result = mix(minresult, maxresult, W_usage);\n    #endif\n\n    result = clamp(result, 0., 1.);//should not change anything\n\n    vec3 c = result.rgb;\n    float w = result.w;\n\n    vec3 t1 = c + w * W;//final reconstructed color\n\n    vec2 ar = vec2(10, 1.15) / iResolution.xy;\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = ar * fragCoord.xy - vec2(0., .05);\n\n    vec2 id = floor(uv);\n    if(id.y > 0.) {\n    //top sliders\n        float idy = floor((uv.y - 1.) * 20.);\n        if(idy == 0.) {\n        // white relative intensityintensity\n            float d = abs(uv.x - wi);\n            fragColor.rgb = 2. * uv0.x * W / wi;\n            if(d < .075)\n                fragColor = vec4(step(.025, d));\n        } else {\n        //color temperature\n            fragColor.rgb = rgblackbodyUv(uv0.x) * wi * .5 / ma;\n            float d = abs(uv0.x - Tc);\n            if(d < .0075)\n                fragColor = vec4(step(.0025, d));\n        }\n    } else {\n        if(id.y < 0.) {\n            float d = abs(uv0.x - W_usage);\n            if(d < .0075)\n                fragColor = vec4(step(.0025, d));\n        } else {\n            if(id.x == 0.) { //differences between input and output\n                fragColor = clamp(vec4((t1 - t0) * sign(uv.y - .5) / ma, 1.), 0., 1.);\n                if(uv.x > .5)\n                #ifdef INT_MATH\n                    fragColor = step(vec4(.5/255.), fragColor);\n                #else\n                    fragColor = step(vec4(.0001), fragColor);\n                #endif\n            }\n\n            uv.y *= ma;\n            float i = step(abs(uv.y - 1.), .005 * ma); //white line to indicate the maximum color reachable with only R, G, and B\n            vec4 ii = vec4(.5 + .5 * step(.005 * ma, min(abs(uv.y - W), abs(uv.y - (W + 1.)))), 1);\n            if(id.x == 1.)\n                fragColor = ii * vec4(1, 0, 0, 0) * (step(uv.y, t0.r) + 1. - ii) + i;//input red\n            if(id.x == 2.)\n                fragColor = ii * vec4(0, 1, 0, 0) * (step(uv.y, t0.g) + 1. - ii) + i;//input green\n            if(id.x == 3.)\n                fragColor = ii * vec4(0, 0, 1, 0) * (step(uv.y, t0.b) + 1. - ii) + i;//input blue\n            uv.y /= ma;\n\n            #if 0 \n            // fake subpixels\n            vec2 cc = floor(mod(fragCoord, vec2(2.)));\n            vec4 mask = vec4(cc.x < .5 && cc.y < .5, cc.x > .5 && cc.y < .5, cc.x < .5 && cc.y > .5, cc.x > .5 && cc.y > .5);\n\n            t1 = mask.rgb * c + W * mask.w * w;\n            t0 /= 4.;\n            #endif\n\n            if(id.x == 4.)\n                fragColor = (vec4(t0, 1.) / ma);//input color\n            if(id.x == 5.)\n                fragColor = (vec4(t1, 1.) / ma);//output color\n\n            if(id.x == 6.)\n                fragColor = vec4(1, 0, 0, 0) * step(uv.y, c.r) / ma;//output red\n            if(id.x == 7.)\n                fragColor = vec4(0, 1, 0, 0) * step(uv.y, c.g) / ma;//output green\n            if(id.x == 8.)\n                fragColor = vec4(0, 0, 1, 0) * step(uv.y, c.b) / ma;//output blue\n            if(id.x == 9.)\n                fragColor = vec4(W / ma, 0) * step(uv.y, w);//output white\n        }\n    }\n    if(iMouse.z < .1 * iResolution.x && iMouse.z > 0. && floor(iMouse.y * ar.y - .05) == 0.)\n        fragColor = vec4(dot(fragColor.rgb, luma)); //grayscale when clicking left\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//black-body radiation\n\nfloat blackbody(float wl, float T){\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n   \twl*=1e-9;\n    return  2.*h*(c*c)/(wl*wl*wl*wl*wl*(exp(h*c/(T*wl*k))-1.));\n}\n\n\nfloat gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\n\n\nvec3 lambdatoXYZ(float wl){\n    return vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl, -0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl,0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\n\n\n\n\n#define lmin 300.\n#define lmax 800.\n\nvec3 blackbody(float t,float h, int samples){\n    float l = lmin;\n    float lstep = (lmax-lmin)/(float(samples));\n    l+=lstep*h;\n    vec3 col = vec3(0);\n    float s=0.;\n    for(int i=0;i<samples;i++){\n        col+=lambdatoXYZ(l)*blackbody(l,t);\n        l+=lstep;\n        s++;\n    }\n    return col/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    ivec2 pixel = ivec2(floor(fragCoord.xy));\n    vec2 ar = vec2(10,1.15)/iResolution.xy;\n    vec4 m = iMouse*vec4(ar,ar)-vec4(0,.05,0,.05);\n    \n    if(iMouse.w>0.){\n        // keep last click coordinates\n        if(pixel==ivec2(9)){\n            fragColor.xy = m.zw;\n        }\n    }else{\n        m.zw = texture(iChannel0,vec2(9.5)/iChannelResolution[0].xy).xy;\n    }\n    \n    if(iMouse.xy!=vec2(0.)){\n    \n        vec4 id = floor(m);\n        if(id.w==0.){\n            if(pixel==ivec2(1)){\n                if(id.z==1.){\n                    fragColor.r = m.y;\n                    fragColor.a=1.;\n                }\n                if(id.z==2.){\n                    fragColor.g = m.y;\n                    fragColor.a=1.;\n                }\n                if(id.z==3.){\n                    fragColor.b = m.y;\n                    fragColor.a=1.;\n                }\n            }\n        }else{\n            if(id.w<0.){\n                 if(pixel==ivec2(7)){\n                     fragColor.r = m.x*.1;\n                 }\n            }else{\n                float idy = floor((m.w-1.)*20.);\n\n                if(pixel==ivec2(3)&&idy==0.){\n                    fragColor.r = m.x;\n                }\n                if(pixel==ivec2(5)&&idy!=0.){\n                    fragColor.r = m.x*.1;\n                }\n            }\n        }\n    }\n   \n    if(iFrame<1){\n        fragColor=vec4(0);\n        if(pixel==ivec2(1)){\n            fragColor.rgb=vec3(.25,.1,.6);\n            fragColor.a=-1.;\n            }else{\n             if(pixel==ivec2(7)){\n                 fragColor.r = -0.5;\n             }\n            if(pixel==ivec2(3)){\n                fragColor.r = 2.;\n            }\n            if(pixel==ivec2(5)){\n                fragColor.r = TTouv(6500.);\n            }\n        }\n    }\n     if(int(floor(iResolution.y))-1==pixel.y&&iFrame<10){\n        fragColor += vec4(blackbody(uvToT(fragCoord.x/iResolution.x),fract((.5+.5*sqrt(5.))*float(iFrame)),16),1);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float Tstart = 500.;\nconst float Tmid = 6500.;\nfloat Tscale = 2.*log(Tmid/Tstart);//1.*log(Tend/Tstart)\n\nfloat TTouv(float x){\n    return log(x/Tstart)/Tscale;\n} \n\n\nfloat uvToT(float x){\n    return Tstart*exp(Tscale*x);\n} \n","name":"Common","description":"","type":"common"}]}