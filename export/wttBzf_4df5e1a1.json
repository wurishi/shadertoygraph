{"ver":"0.1","info":{"id":"wttBzf","date":"1613209136","viewed":145,"name":"Spell Test","username":"RiceFields","description":"test","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["blur","magic","shapes","spell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat SDFCircle(vec2 uv) {\n    return length(uv-0.5f)*2.0;\n}\n\nfloat SDFPoly(vec2 uv, int numVertex) {\n    uv = uv*2.0f - 1.0f; // remap\n    // polar cooridnates\n    float a = atan(uv.x, uv.y) + PI;\n    float v = TWO_PI/float(numVertex);\n    // Shaping function that modulates the distance\n  \treturn cos(floor(0.5f+a/v)*v-a)*length(uv);\n}\n\n// Anti-alias step\nfloat aastep(float threshold, float value) {\n    float afwidth = 2.0/iResolution.y;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat stroke(float f, float size, float width) {\n    return aastep(size, f+width*0.5f) - aastep(size, f-width*0.5f);\n}\n\nfloat fill(float f, float size) {\n    return 1.-aastep(size, f);\n}\n\nvec3 bridge(vec3 color, float f, float size, float width) {\n    return color * (1.0f - stroke(f, size, width*2.0f)) + stroke(f, size, width);\n}\n\nfloat flip(float v, float f) {\n return mix(v, 1.0f - v, f);\n}\n\nvec2 rotate2d(vec2 uv, float angle) {\n    mat2 mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); \n    return 0.5f + (mat*(uv-0.5f));\n}\n\nvec2 scale2d(vec2 uv, float scale) {\n    mat2 mat = mat2(scale, 0.0, 0.0, scale);\n    return 0.5f + (mat*(uv-0.5f));\n}\n\nvec3 triStar(vec2 uv, float size, float width) {\n    uv.y = flip(uv.y, step(0.5f, uv.x)); // flip y if x > 0.5f\n    vec3 st1 = vec3(stroke(SDFPoly(uv, 3), size, width));\n    return bridge(st1, SDFPoly(rotate2d(uv, 1.05f), 3), size, width);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.35f; // magic subtraction to get the shapes on center for now\n    \n    vec2 ruv = rotate2d(uv, sin(iTime)*PI);\n    vec2 rruv = rotate2d(uv, cos(iTime)*PI);\n    //ruv = scale2d(ruv, sin(iTime));\n    \n    vec3 star = triStar(ruv, 0.3f, 0.015f);\n    star += triStar(rruv, 0.26f, 0.015f);\n    star += stroke(SDFCircle(uv), 0.2f, 0.015f);\n    star += stroke(SDFCircle(uv), 0.45f, 0.02f);\n    star += stroke(SDFCircle(uv), 0.55f, 0.02f);\n    \n    uv = rotate2d(uv, -iTime*PI);\n    star += fill(SDFCircle(uv), 0.14f);\n    uv = rotate2d(uv, -0.5f);\n    star -= fill(SDFCircle(uv+vec2(0.03f, 0.0f)), 0.13f);\n    star = clamp(star, vec3(0.0f), vec3(1.0f));\n\n    fragColor = vec4(star*vec3(1.0f, 1.0f, 1.0f), 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}