{"ver":"0.1","info":{"id":"WdKyDz","date":"1602791824","viewed":218,"name":"Gaussian-weighted median filter","username":"Hatchling","description":"General filter which returns the median, minimum or maximum around a pixel neighborhood. Uses gaussian weighting.\n\nTop = Gaussian blur.\n\nMiddle = From left to right, returns the minimum, median, and maximum pixel values within a window of size 1.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["median","min","max","gaussianweighted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    weightedMedian\n    (\n        iChannel0, \n        fragColor, \n        fragCoord,\n        \n        // Sampling distance scaled to emphasize effect.\n        3,\n        \n        // Minimum filter at left, median in center, maximum filter at right.\n        fragCoord.x/iResolution.x, \n        \n        // Window size varies vertically:\n        // Sampling width of N at top, (all samples considered, functions as a Gaussian filter)\n        // Sampling width of 1 at center,\n        // Sampling width of 0 at bottom.\n        fragCoord.y/iResolution.y\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float phi = (sqrt(5.)+1.)/2.;\n\nfloat pm(int index)\n{\n    index += 1;\n    bool positive = index % 2 == 0;\n    int exponent = index / 2;\n    \n    return pow(phi, float(positive ? exponent : -exponent));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates for channel, in texel space.\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    // Coordinates for buffer, in texel space. \n    vec2 uv2 = fragCoord/iResolution.xy;\n    \n    /*int pmi = 0;\n    float random1 = UnsignedFrac(dot(vec3(uv2, iTime), vec3(pm(++pmi), pm(++pmi), pm(++pmi)))* 1.0);\n    float random2 = UnsignedFrac(dot(vec3(uv2, iTime), vec3(pm(++pmi), pm(++pmi), pm(++pmi)))* 2.0);\n    float random3 = UnsignedFrac(dot(vec3(uv2, iTime), vec3(pm(++pmi), pm(++pmi), pm(++pmi)))* 4.0);\n    float random4 = UnsignedFrac(dot(vec3(uv2, iTime), vec3(pm(++pmi), pm(++pmi), pm(++pmi)))* 8.0);\n    float random5 = UnsignedFrac(dot(vec3(uv2, iTime), vec3(pm(++pmi), pm(++pmi), pm(++pmi)))* 16.0);\n    \n    uint state1 = uint(random1 * float(0xffff));\n    uint state2 = uint(random2 * float(0xffff));\n    uint state3 = uint(random3 * float(0xffff));\n    uint state4 = uint(random4 * float(0xffff));\n    uint state5 = uint(random5 * float(0xffff));\n    \n    uint state = state1 ^ state2 ^ state3 ^ state4 ^ state5;\n    \n    float random = RandomFloat01(state);*/\n        \n    vec3 col = texture(iChannel0, uv).rgb;// + vec3(random - 0.5);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const int radius = 2;\nconst float stdev = float(radius) * 0.75;\nconst int boxWidth = radius * 2 + 1;\nconst int count = boxWidth*boxWidth;\n\nstruct WeightedSample\n{\n    vec3 color;\n    float lum;\n    float weight;\n};\n\nWeightedSample colors[count];\n\nfloat luminance(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nfloat gaussian(float sqrMag) \n{\n    return exp(-sqrMag/(stdev*stdev));\n}\n\n// I didn't write this, but I forget the source I copied it from.\nvoid sort(inout WeightedSample values[count])\n{\n\tint inc = count / 2;\n\twhile (inc > 0)\n\t{\n\t\tfor (int i = inc; i < count; ++i)\n\t\t{\n\t\t\tWeightedSample tmp = values[i];\n\t\t\tint j = i;\n\t\t\twhile (j >= inc && values[j - inc].lum > tmp.lum)\n\t\t\t{\n\t\t\t\tvalues[j] = values[j - inc];\n\t\t\t\tj -= inc;\n\t\t\t}\n\t\t\tvalues[j] = tmp;\n\t\t}\n\t\tinc = int(float(inc) / 2.2 + 0.5);\n\t}\n}\n\nvoid weightedMedian( sampler2D tex, out vec4 fragColor, in vec2 fragCoord, in int spread, in float minOrMax, in float wi)\n{\n    int index = 0;\n    for(int x = -radius; x <= radius; x++)\n    for(int y = -radius; y <= radius; y++)\n    {\n        vec3 color = texelFetch(tex, ivec2(fragCoord) + ivec2(x,y) * spread, 0).rgb;\n        float weight = gaussian(float(x*x+y*y));\n        \n        \n        colors[index] = WeightedSample(color, luminance(color), weight);\n        index++;\n    }\n    \n    sort(colors);\n    \n    float starts[count];\n    float ends[count];\n    \n    float sum = 0.;\n    for(int i = 0; i < count; i++)\n    {\n        starts[i] = sum;\n        sum += colors[i].weight;\n        ends[i] = sum;\n    }\n    \n    vec3 colorAccum = vec3(0);\n    float colorWeight = 0.;\n    \n    // The range 0 to 1 gets mapped to 0 to sum,\n    // but where 0.5 gets mapped to 1.\n    float ratio = 1. / float(sum);\n    float exponent = -log(ratio)/log(2.);\n    float windowSize = pow(wi, exponent) * float(sum);\n    \n    float windowStart = minOrMax * (sum - windowSize);\n    float windowEnd = windowStart + windowSize;\n    \n    // Weigh the samples by how much they overlap with the window.\n    for(int i = 0; i < count; i++)\n    {\n        if(windowStart >= ends[i])\n            continue;\n        \n        if(windowEnd <= starts[i])\n            break;\n        \n        float s = max(windowStart, starts[i]);\n        float e = min(windowEnd, ends[i]);\n        \n        float w = e-s;\n        \n        colorAccum += colors[i].color * w;\n        colorWeight += w;\n    }\n    \n    vec3 col = colorAccum / colorWeight;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// RNG algorithm credit: https://www.shadertoy.com/view/wtSyWm\nuint hash(inout uint seed)\n{\n    seed = (seed * uint(0x27d4eb2d)) ^ seed;\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(hash(state)) / 4294967296.0;\n}\n\nfloat UnsignedFrac(float x) { return x - floor(x); }\n","name":"Common","description":"","type":"common"}]}