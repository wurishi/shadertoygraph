{"ver":"0.1","info":{"id":"lflcR8","date":"1720800145","viewed":68,"name":"hex at you","username":"pb","description":"hex repeat in one plane, making use of quaternionic z^2+c in fractal formula","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","4d","exp"],"hasliked":0,"parentid":"M3VXDK","parentname":"tangled space"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos(  h*h/3. + vec3(0,1,4)   )*.9 + .4 )\n\n#define H2(h)  (  cos(  h*h * vec3(.001)   )*.7 + .5 )\n\n//formula for mapping scale factor \n#define M(c)  log(c)\n\n#define R iResolution\n\n//polar repeat by fabriceneyret2\nvec2 polarRep(vec2 U, float n) {\n    n = 6.283/n;\n    float a = atan(U.y, U.x),\n          r = length(U);\n    a = mod(a+n/2.,n) - n/2.;\n    U = r * vec2(cos(a), sin(a));\n    return .5* ( U+U - vec2(1,0) );\n}\n\n\nvoid mainImage( out vec4 O, vec2 U) {\n  \n    O = vec4(0);\n    \n    vec3 c=vec3(0);\n    vec4 rd = normalize( vec4(U-.5*R.xy, .5*R.y, R.y))*2000.;\n    \n    float sc,dotp,totdist=0., tt=iTime, t=0.;\n    \n    for (float i=0.; i<60.; i++) {\n        \n        vec4 p = vec4( rd*totdist);\n        \n        p.z += -9.5 + mod(iTime*2.,30.);\n        \n        p.xz *= rot( 3.14/2. );\n\n        p.yzw = (p.xyz); \n        p.zw  *= rot( 3.14/2. );\n     \n        sc = 1.; \n\n        p.zw *= rot(tt/3. + sin(tt/6.) );\n        \n        p.wz = polarRep(p.wz,6.);  //hex is so much nicer than square\n   \n        vec4 w = p;\n     \n        for (float j=0.; j<7.; j++) {\n          \n            p = abs(p)*.7;\n                        \n            dotp = max(1./dot(w,w),.1);\n            \n            sc *= dotp ; \n            \n            p = p * dotp  - .9*vec4(.5,.5,.3,.3);\n            \n            w = vec4(0);\n            //quaternionic mandelbrot iterations\n            for (float k=0.; k<4.;  k++) {\n                w =\n                    vec4( w.x*w.x-w.y*w.y-w.z*w.z-w.w*w.w,\n                       2.*w.x*w.y,\n                       2.*w.x*w.z,\n                       2.*w.x*w.w ) - .35*p;\n                                  \n            }\n        }\n         \n        float dist = abs( length(p.zw) -.1)/sc ;  //funky distance estimate\n        float stepsize = dist/200. + 8e-6;     \n        totdist += stepsize;                  //move the distance along rd\n        \n        //accumulate color, fading with distance and iteration count\n        c +=\n             .5e-1* \n             mix( vec3(1), H(M(sc)),.9) * exp(-i*i*stepsize*1e1);\n    }\n    \n    c = 1. - exp(-c*c);\n    O = ( vec4(c,0) );\n               \n}","name":"Buffer A","description":"","type":"buffer"}]}