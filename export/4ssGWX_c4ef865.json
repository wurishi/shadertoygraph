{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define AMBIENT 0.01\n#define GAMMA (1.0/2.2)\n#define TINY_AMOUNT 0.001\n#define MAX_TRACE_DEPTH 6\n#define FOCUS_DISTANCE 4.0\n#define APERTURE 0.01\n#define SAMPLES_PER_PIXEL 32\n\nvec3 LightPos = vec3( 5.0,3.0,2.0);\nvec3 LightCol = vec3(70.0);\n \nvec2 Pixel;\n \nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\nstruct Intersection\n{\n  bool Intersected;\n  vec3 Intersection;\n  vec3 Normal;\n };\n \n struct Material\n {\n  vec3 Colour;\n  float Reflection;\n  float Specular;\n  float Sharpness;\n };\n \nfloat Rand( float n)\n{\n\t return fract(sin(n)*43758.5453123) ;\n}\n\nvec3 RotateY(vec3 v , float a)\n{\n\tv = vec3( v.x*cos(a) - v.z*sin(a) , v.y , v.x*sin(a) + v.z*cos(a) );\n\treturn v;\n}\n\n\nRay CreatePrimaryRay2(float t , vec2 screen, int N)\n{\n\tRay r;\n\tfloat cYaw = t*0.25;\n    r.Origin = vec3(0.0,1.0,-4.0);\n\tr.Direction = normalize( vec3( screen.x , screen.y , 1) );\n\n\tvec3 A = r.Origin;\n\tvec3 B = r.Origin + r.Direction * FOCUS_DISTANCE;\n\t\n\tA = A + APERTURE * vec3( Rand(float(N)+screen.x)-0.5 , Rand(float(N)+screen.y)-0.5 , 0.0 );\t\n\t\n\tr.Origin = RotateY( A , cYaw );\n\tr.Direction = RotateY( normalize(B-A) , cYaw );\n\n\treturn r;\n}\n\n float TracePlane( Ray r , inout Intersection iSec , vec3 normal , float distance)\n {\n\tiSec.Intersected = false;\n\tfloat d = - r.Origin.y / r.Direction.y;\n\t if( d > 0.0 )\n\t {\n\t\t iSec.Intersected = true;\n\t\t iSec.Intersection = r.Origin + d * r.Direction;\n\t\t iSec.Normal = vec3(0.0,1.0,0.0);\n\t }\n\t return d;\n }\n \n float TraceSphere( Ray r , inout Intersection iSec , vec3 centre , float radius)\n {\n\tiSec.Intersected = false;\n\tfloat d=0.0,t0,t1;\n\tr.Origin -= centre;\n    float a = dot(r.Direction, r.Direction);\n    float b = 2.0 * dot(r.Direction, r.Origin);\n    float c = dot(r.Origin, r.Origin) - (radius * radius);\n    float disc = b * b - 4.0 * a * c;\n    if (disc < 0.0)\n        return -1.0;\n    float distSqrt = sqrt(disc);\n    float q;\n    if (b < 0.0)\n        q = (-b - distSqrt)/2.0;\n    else\n        q = (-b + distSqrt)/2.0;\n    t0 = q / a;\n    t1 = c / q;\n    if (t0 > t1)\n    {\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    if (t1 < 0.0)\n\t\treturn t0;\n    iSec.Intersected = true;\n\tiSec.Intersection = r.Origin + t0 * r.Direction + centre;\n\tiSec.Normal = normalize(r.Origin + t0*r.Direction);\n\treturn t0;\n }\n \n void Trace( Ray r , inout Intersection iSec, out Material m )\n {\n\tiSec.Intersected = false;\n\tfloat D , Dmin;\n\tDmin = 1000000.0;\n\tIntersection iTemp;\n\t\n\tD = TracePlane(r , iTemp , vec3(0.0,1.0,0.0) , 0.0);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tfloat q = sin(iTime*0.1) * 0.5;\n\t\tif( (fract(iTemp.Intersection.x)+q < 0.5 && fract(iTemp.Intersection.z)+q < 0.5) ||\n\t\t    (fract(iTemp.Intersection.x)+q >= 0.5 && fract(iTemp.Intersection.z)+q >= 0.5))\n\t\t\tm.Colour = vec3(0.4);\n\t\telse\n\t\t\tm.Colour = vec3(0.02);\n\t\tm.Reflection = 0.2;\n\t\tm.Specular = 0.3;\n\t\tm.Sharpness = 2.0;\n\t\tiSec = iTemp;\n\t}\n\t\n\tD = TraceSphere(r , iTemp , vec3(0.0,1.0 + 0.4 * sin( iTime ),0.0) , 0.6);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tm.Colour = vec3(0.01,0.01,0.1);\n\t\tm.Reflection = 0.6;\n\t\tm.Specular = 0.6;\n\t\tm.Sharpness = 50.0;\n\t\tiSec = iTemp;\n\t\tiSec.Normal += vec3( Rand( iSec.Intersection.x ) , \n\t\t\t\t\t\t     Rand( iSec.Intersection.y ) , \n\t\t\t\t\t\t\t Rand( iSec.Intersection.z ) ) * 0.1 - 0.05;\n\t\tiSec.Normal = normalize( iSec.Normal );\n\t}\n\t \n\tD = TraceSphere(r , iTemp , vec3(1.5,0.4,0.0) , 0.4);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tm.Colour = vec3(0.1,0.01,0.01);\n\t\tm.Reflection = 0.6;\n\t\tm.Specular = 0.6;\n\t\tm.Sharpness = 50.0;\n\t\tiSec = iTemp;\n\t\tiSec.Normal += vec3( 0.0 , sin(iSec.Intersection.y*150.0 + 10.0*iTime) , 0.0 ) * 0.05 - 0.025;\n\t\tiSec.Normal = normalize( iSec.Normal );\n\t}\n\t \n\tD = TraceSphere(r , iTemp , vec3(0.0,0.4,1.5) , 0.4);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tm.Colour = vec3(0.01,0.1,0.01);\n\t\tm.Reflection = 0.6;\n\t\tm.Specular = 0.6;\n\t\tm.Sharpness = 50.0;\n\t\tiSec = iTemp;\n\t}\n\t \n\tD = TraceSphere(r , iTemp , vec3(-1.5,0.4,0.0) , 0.4);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tm.Colour = vec3(0.1,0.1,0.01);\n\t\tm.Reflection = 0.6;\n\t\tm.Specular = 0.6;\n\t\tm.Sharpness = 50.0;\n\t\tiSec = iTemp;\n\t\tiSec.Normal += vec3( sin(iSec.Intersection.x*150.0) , \n\t\t\t\t\t\t\t 0.0 , \n\t\t\t\t\t\t     cos(iSec.Intersection.y*150.0) ) * 0.05 - 0.025;\n\t\tiSec.Normal = normalize( iSec.Normal );\n\t}\n\t \n\tD = TraceSphere(r , iTemp , vec3(0.0,0.4,-1.5) , 0.4);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tm.Colour = vec3(0.1,0.01,0.1);\n\t\tm.Reflection = 0.6;\n\t\tm.Specular = 0.6;\n\t\tm.Sharpness = 50.0;\n\t\tiSec = iTemp;\n\t}\n\t\n\t float a = iTime * 2.0;\n\tD = TraceSphere(r , iTemp , vec3(2.0*cos(a),0.2,2.0*sin(a)) , 0.2);\n\tif( iTemp.Intersected && D < Dmin )\n\t{\n\t\tDmin = D;\n\t\tm.Colour = vec3(sin(a),sin(a+2.1),sin(a+4.2))*0.1+0.3;\n\t\tm.Reflection = 0.1;\n\t\tm.Specular = 0.6;\n\t\tm.Sharpness = 50.0;\n\t\tiSec = iTemp;\n\t}\n }\n \n vec4 CalcColour(Ray r , Intersection iSec, Material m)\n {\n\t vec3 lDir = normalize(LightPos - iSec.Intersection);\n\n \t // Ambient\n \tvec3 c = m.Colour * AMBIENT;\n\n\t \n\n\t// Shadow ray\n\tRay sr;\n\tIntersection si;\n\tMaterial sm;\n\n\tsr.Origin = iSec.Intersection + lDir * TINY_AMOUNT;\n\tsr.Direction = lDir;\n\t \n\tTrace( sr , si , sm );\n\t\n\tfloat lFactor = 1.0/pow(length(LightPos - iSec.Intersection),2.0);\n\t \n\t if( !si.Intersected )\n\t {\n\t \n\t\n\t \n\t// diffuse\n\tc += m.Colour * lFactor * LightCol * clamp( dot( iSec.Normal , lDir ) , 0.0 , 1.0); \n\n\t// specular\n\tvec3 rDir = reflect( r.Direction , iSec.Normal );\n\tc += m.Specular * lFactor * LightCol * pow( clamp( dot( lDir , rDir ) , 0.0 , 1.0 ) , m.Sharpness );\n\t }\n\t \n\treturn vec4(c,1.0);\n }\n \n \n vec4 TracePixel( Ray ray )\n {\n  float coefficient = 1.0;\n  vec4 col = vec4(0.0);\n  Material mat;\n  Intersection iSec;\n  for(int i=0; i<MAX_TRACE_DEPTH; i++)\n  {\n    Trace( ray , iSec , mat );\n    if( iSec.Intersected )\n\t\tcol += coefficient * CalcColour( ray , iSec , mat );\n\tcoefficient *= mat.Reflection;\n\tif( !iSec.Intersected || coefficient < 0.01 )\n\t break;\n\tray.Direction = reflect( ray.Direction , iSec.Normal );\n\tray.Origin = iSec.Intersection + TINY_AMOUNT * ray.Direction;\n\tiSec.Intersected = false;\n  }\n  return col;\n } \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n   Pixel = vec2( 1.0 / iResolution.x , 1.0 / iResolution.y );  \n     \n   vec2 screen = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n   screen.x *= iResolution.x / iResolution.y;\n   vec4 c = vec4(0.0);\n\tvec4 avg = vec4(0.0);\n\t vec4 oldAvg = vec4(-1000.0);\n\t int count = 0;\n\t for(int s=0;s<SAMPLES_PER_PIXEL;s++)\n   {\n     vec2 AAscreen = screen + 0.3*Pixel * vec2( Rand(float(s)*3.14+screen.x) , Rand(float(s)*1.863+screen.y) );\n\t Ray primaryRay = CreatePrimaryRay2( iTime , AAscreen , s);\n     \n\t c += TracePixel(primaryRay);\n\t avg = c / float(s+1);\n\t if( s>3 && length( oldAvg-avg) < 0.02 )\n\t\t break;\n\t oldAvg = avg;\n\t   count++;\n   }\n   fragColor = vec4( pow(avg.xyz,vec3(GAMMA)) , 1.0 );\n }","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssGWX","date":"1380651252","viewed":794,"name":"RSOCP","username":"scott","description":"First go at this - the obligatory reflective sphere over a checkered plane :-)\nNot optimised at all, just got it working...","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","dof","spheres","reflections","aa"],"hasliked":0,"parentid":"","parentname":""}}