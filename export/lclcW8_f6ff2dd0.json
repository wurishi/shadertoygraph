{"ver":"0.1","info":{"id":"lclcW8","date":"1721094605","viewed":59,"name":"[ARTS1308] Reflection Refraction","username":"ARTS1308","description":"Scene based on Nathan's tutorial https://inspirnathan.com/posts/59-shadertoy-tutorial-part-13\ncombined lighting, shadow, reflection, and refraction.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial","colors","inspirnathan"],"hasliked":0,"parentid":"fdlGWX","parentname":"Ray Marching with Unique Colors"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// scene copied from Nathan https://www.shadertoy.com/view/fdlGWX\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial sphere1() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial sphere2() {\n  vec3 aCol = 0.4 * vec3(0, 0.5, 0.7);\n  vec3 dCol = 0.5 * vec3(0, 0.7, 0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = 0.5 + 0.5 * vec3(-1. + mod(floor(p.x) + floor(p.z), 2.0));\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphere1 = Surface(2, sdSphere(p - vec3(-2, 0, 0), 1.), sphere1());\n  Surface sSphere2 = Surface(3, sdSphere(p - vec3(2, 0, 0), 1.), sphere2());\n\n  Surface co = opUnion(sFloor, sSphere1); // closest object\n  co = opUnion(co, sSphere2);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += abs(co.sd);\n    if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n  // background\n  vec3 bgColor = vec3(0.835, 1.0, 1.0);\n  //bgColor = vec3(0.5);\n  if (co.sd > MAX_DIST) return bgColor;\n  \n  // ambient\n  vec3 ambient = co.mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n  vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n  vec3 col = lightIntensity * (ambient + diffuse + specular);\n  \n  // fog\n  col = mix(col, bgColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd));\n  return col;\n\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < MAX_SHADOW_STEPS; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 ); // soft shadow\n  //return step(tmax - 0., t); //hard shadow\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(5. * cos(-iTime), 0., 5. * sin(-iTime));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n  vec3 normal = calcNormal(p); // surface normal\n\n  // light\n  vec3 lightPosition = 4. * vec3(cos(iTime), 1., sin(iTime));\n  vec3 lightDirection = normalize(p - lightPosition);\n  float lightIntensity = 0.9;\n      \n  // phone light model\n  col = phong(lightDirection, lightIntensity, normal, rd, co); \n      \n//*  // soft shaddow from iq\n  if (co.id == 1 && co.sd < 0.2 * MAX_DIST) {\n    float softShadow = clamp(softShadow(p, -lightDirection, 100.*PRECISION, length(p-lightPosition)), 0.2, 1.0);\n    col *= softShadow;\n  }\n//*/\n\n//*  // reflection;\n  if (co.id == 2 && scene(p).sd < 10. * PRECISION) {\n    vec3 reflRD = reflect(rd, normal);\n    vec3 reflRO = p + 1.1 * PRECISION * normal; // move origin a little bit away\n    // reflRO = p + 1.5 * PRECISION * reflRD; // not working\n    Surface reflCO = rayMarch(reflRO, reflRD);\n    vec3 reflP = reflRO + reflRD * reflCO.sd;\n    vec3 reflNormal = calcNormal(reflP);\n    reflCO.sd += co.sd;\n    vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n    col = mix(col, reflCol, 0.2);\n  }\n//*/\n\n//*  // refraction\n  if (co.id == 3 && scene(p).sd < 10. * PRECISION) {\n    const float ETA = 1.69; // glass 1.69, water 1.33ï¼Œ1.0 air\n    vec3 refrRD1 = refract(rd, normal, 1./ETA);\n    vec3 refrRO1 = p - 2.1 * PRECISION * normal; // move origin into the sphere\n    //refrRO1 = p + 5. * PRECISION * refrRD1; // not working\n    Surface refrCO1 = rayMarch(refrRO1, refrRD1);\n    vec3 refrP1 = refrRO1 + refrRD1 * refrCO1.sd;\n    vec3 refrN1 = calcNormal(refrP1);\n    \n    vec3 refrRD2 = refract(refrRD1, -refrN1, ETA);\n    vec3 refrRO2 = refrP1 + 2.1 * PRECISION * refrN1; // move origin outside the sphere\n    //refrRO2 = refrP1 + 5. * PRECISION * refrRD2; // not working\n    Surface refrCO2 = rayMarch(refrRO2, refrRD2);\n    vec3 refrP2 = refrRO2 + refrRD2 * refrCO2.sd;\n    vec3 refrN2 = calcNormal(refrP2);\n    refrCO2.sd += refrCO1.sd + co.sd;\n    vec3 refrCol = phong(lightDirection, lightIntensity, refrN2, refrRD2, refrCO2);\n    col = mix(col, refrCol, 0.2);\n  }\n//*/\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}