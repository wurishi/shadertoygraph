{"ver":"0.1","info":{"id":"4fcfW8","date":"1732991540","viewed":121,"name":"Blob: A von Neumann CA family","username":"laserbat","description":"While less visually impressive than some other rule families I shared, it is notable for exhibiting a wide variety of behaviors even when restricted to \"just\" 16 states. This feature makes it somewhat more amenable to exploration using Golly.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 norm_coord = fragCoord / iResolution.xy;\n\n    fragColor.a = 0.0;\n    fragColor.rgb = unpack(hash(2 * pack(texture(iChannel0, norm_coord * SCALE).rgb)));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int get_index(int count, int nudge) {\n    if ((count == 2 && nudge <= 1) || \n        (count == 3) || \n        (count == 4 && nudge == 2)) {\n        return 1;\n    }\n    if (count == 4 && nudge == 1) {\n        return 2;\n    }\n    if (count == 5 && nudge == 0) {\n        return 3;\n    }\n    return 0;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 norm_coord = fragCoord / (iResolution.xy);\n\n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0) {\n        fragColor.rgb = unpack(noise(norm_coord));\n        return;\n    }\n    \n    int vals[5];\n    int uniques[5];\n    int count = 0;\n    int nudge = 0;\n\n    // Populate vals with the cell itself and its 4 orthogonal neighbors\n    vec2 pixel = vec2(1.0) / (iResolution.xy);\n    \n    vals[0] = pack(texture(iChannel0, norm_coord).rgb);\n    vals[1] = pack(texture(iChannel0, norm_coord + vec2(0.0, pixel.y)).rgb);\n    vals[2] = pack(texture(iChannel0, norm_coord + vec2(pixel.x, 0.0)).rgb);\n    vals[3] = pack(texture(iChannel0, norm_coord - vec2(0.0, pixel.y)).rgb);\n    vals[4] = pack(texture(iChannel0, norm_coord - vec2(pixel.x, 0.0)).rgb);\n\n    // Sort the array using a sorting network\n    swap(0,3); swap(1,4);\n    swap(0,2); swap(1,3);\n    swap(0,1); swap(2,4);\n    swap(1,2); swap(3,4);\n    swap(2,3);\n    \n    // Extract unique values from the sorted array\n    nudge = uniques[0] = vals[0];\n    count = 1;\n    \n    // Since the array is sorted, we can just compare adjacent elements\n    for (int i = 1; i < 5; i++) {\n        if (vals[i] != vals[i-1]) {\n            uniques[count] = vals[i];\n            count += 1;\n            nudge ^= vals[i];\n        }\n    }\n    \n    nudge = nudge % 3;\n    \n    fragColor.rgb = unpack(uniques[get_index(count, nudge)]);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SCALE (1.0/4.0)\n\n#define swap(x, y) if (vals[x] > vals[y]) {int t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n\n#define D 256\n#define M (D * D * D)\n\nint hash(int x) {\n    x++;\n    x ^= x >> 17;\n    x *= 0xed5ad4bb;\n    x ^= x >> 11;\n    x *= 0xac4c1b51;\n    x ^= x >> 15;\n    x *= 0x31848bab;\n    x ^= x >> 14;\n    return x;\n}\n\nvec3 unpack(int val){\n    vec3 res;\n    \n    res.r = float(val % D) / float(D);\n    val /= D;\n    res.g = float(val % D) / float(D);\n    val /= D;\n    res.b = float(val % D) / float(D);\n\n    return res;\n}\n\nint pack(vec3 val){\n    int res;\n    \n    res += int(float(D) * val.b);\n    res *= D;\n    res += int(float(D) * val.g);\n    res *= D;\n    res += int(float(D) * val.r);\n\n    return res;\n}\n\nint noise(in vec2 co){\n    int x = int(co.x * float(M));\n    int y = int(co.y * float(M));\n    int z = int(iDate.a);\n    int w = int(fract(iDate.a) * float(M));\n    int res = hash(x + hash(y + hash(z + hash(w))));\n    \n    return res;\n}","name":"Common","description":"","type":"common"}]}