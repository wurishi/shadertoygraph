{"ver":"0.1","info":{"id":"ddKGD1","date":"1678474592","viewed":277,"name":"Correct Sphere Soft shadow","username":"Poisson","description":"A new way to make analytical sphere soft shadows, now the penumbra is inside so it's more realistic.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracer","shadow","sphere","raytraced","ao","occlusion","aa","ambient","analytical","soft","analytic","pbr","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4 // antialiasing\n\n// ray sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if (h<0.) return -1.;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// sphere soft shadow function\n// k is the softness of the shadow\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    #if 1\n    // correct soft shadow, penumbra inside\n    \n    // distance\n    // float d = length(cross(oc, rd)) - sph.w;\n    float d = sqrt(max(0.,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt(max(h,0.)); // intersection distance\n            \n    float res = b>0. ? 1. : .5+.5*clamp(k*d/t, -1., 1.);\n    \n    #elif 0\n    // cheap approximation, penumbra inside\n    \n    float res = b>0. ? 1. : .5+.5*clamp(k*h/b, -1., 1.);\n    \n    #elif 0\n    // old way, penumbra outside\n    \n    // distance\n    // float d = length(cross(oc, rd)) - sph.w;\n    float d = sqrt(max(0.,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt(max(h,0.)); // intersection distance\n    \n    float res = b>0. ? 1. : clamp(k*d/t, 0., 1.);\n    \n    #endif\n    return res*res*(3.-2.*res); // S curve\n}\n\n// sphere occlusion\n// thanks to iq: https://www.shadertoy.com/view/4d2XWV\nfloat sphOcclusion(vec3 p, vec3 n, vec4 sph) {\n    vec3 r = sph.xyz - p;\n    float l = length(r);\n    return dot(n,r) * sph.w*sph.w/(l*l*l);\n}\n\n// sphere\nconst vec4 sph = vec4(0,0,0,.5);\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0); // background\n        \n    float t = 1e10; // final distance\n    vec3 n; // normal\n    float occ = 1.; // occlusion\n    \n    // sphere\n    float t1 = sphIntersect(ro, rd, sph);\n    if (t1>0.) {\n        t = t1;\n        vec3 p = ro + rd*t;\n        n = (p - sph.xyz) / sph.w;\n        occ = .5+.5*n.y; // plane occlusion\n    }\n    \n    // plane\n    float t2 = (-.5-ro.y) / rd.y;\n    if (t2>0. && t2<t) {\n        t = t2;\n        vec3 p = ro + rd*t;\n        n = vec3(0,1,0);\n        occ = 1.-sphOcclusion(p, n, sph); // sphere occlusion\n    }\n    \n    if (t<1e10) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        \n        const vec3 lig = vec3(.57735); // light direction\n        float dif = clamp(dot( n, lig), 0., 1.); // diffuse light\n        float bac = clamp(dot(-n, lig), 0., 1.); // bac light\n        float bou = .5-.5*n.y; // bounce light\n        \n        float k = .5+12.*(.5+.5*sin(2.*iTime)); // shadow softness\n        float sha = sphSoftShadow(p, lig, sph, k); // shadow\n        \n        col = vec3(0);\n        col += vec3(1,.8,.6) * dif*sha; // direct light\n        col += .25*vec3(1,.8,.6) * occ*(.5+bac)*bou; // indirect light\n        col += .2*vec3(.3,.6,1) * occ; // sky light\n        \n        col = mix(col, vec3(0), 1.-exp(-t*t*.02)); // fog\n    }\n    \n    return 1.5*col/(1.+col); // tonemapping\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    \n    float an = .2*iTime + m.x*3.141592; // camera xz rotation\n    vec3 ro = vec3(2.5*sin(an),1,2.5*cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n        vec3 col = render(ro, rd); // render\n\n        col = pow(col, vec3(.4545)); // gamma correction\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}