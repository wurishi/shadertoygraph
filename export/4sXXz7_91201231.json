{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Created by inigo quilez - iq/2013\n// Edited by Steven An - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 lig = normalize( vec3(0.3,0.9,0.7) );\n\nconst float PI = 3.14129;\nconst float TPI = 2. * PI;\n\n//#define STEREO \nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise2d(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise1d(float x) {\n    return snoise2d(vec2(0.0, x));\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\n#ifdef STEREO\n#define lodbias -5.0\n#else\n#define lodbias 0.0\n#endif\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz, lodbias );\n\tvec4 y = texture( sam, p.zx, lodbias );\n\tvec4 z = texture( sam, p.xy, lodbias );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n// I think this is just a rotation matrix - haven't analyzed it really.\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n//\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\t// This just adds more high frequency noise to the surface. \n\tfloat n = noise( p*5.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nconst float satradius = 5.0;\nconst float satRotSpeed = 3.14*0.1;\n\nvec3 yRot( vec3 p, float rads ) {\n    return vec3(\n        p.x*cos(rads) - p.z*sin(rads),\n        p.y,\n        p.x*sin(rads) + p.z*cos(rads) );\n}\n\nconst float SATBUMP = 1.;\n\nfloat planetSDF( in vec3 p )\n{\n    p = yRot(p, iTime*satRotSpeed);\n\tconst float bandFreq = 8.0;\n\tvec3 spotDir = normalize(vec3(0.0,1.0,0.0));\n\tfloat noisePart = SATBUMP * 0.005 * noise(5.0*p) * sin(3.0*bandFreq*dot(normalize(p),spotDir));\n\treturn length(p) - satradius + noisePart;\n}\n\nfloat unionn( float a, float b ) { return min(a,b); }\nfloat subtract( float a, float b ) { return max(-a, b); }\nfloat intersect( float a, float b ) { return max(a, b); }\n\nfloat sceneSDF( in vec3 pos )\n{\n    return planetSDF(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n\tfloat precis = 0.001;\t\t\t\t\t\t\n    float distToSurf = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( abs(distToSurf)<precis||t>maxd ) continue;//break;\n\t    distToSurf = sceneSDF( ro+rd*t );\n        t += distToSurf;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           sceneSDF(pos+eps.xyy) - sceneSDF(pos-eps.xyy),\n           sceneSDF(pos+eps.yxy) - sceneSDF(pos-eps.yxy),\n           sceneSDF(pos+eps.yyx) - sceneSDF(pos-eps.yyx) ) );\n\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = sceneSDF(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n    //time *= 0.;\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nvec3 blendrings( vec3 col, float t, vec3 ro, vec3 rd )\n{\n    // TODO: lighting/shadows?\n    \n    const float ringrad = satradius*2.1;\n    \n    float tring = -ro.y/rd.y;\n   \tvec3 pring = ro + tring*rd;\n    pring = yRot(pring, iTime*PI/20.);\n    float r = length(pring.xz);\n    \n    if( (tring < t || t <= 0.0) && r <= ringrad )\n    {\n        float noise = snoise1d(r*0.4 + 573.62);\n\n        float normnoise = noise * 0.5 + 0.5;\n        float edgesoft = 0.1;\n        float denstart = 0.4;\n        float density = smoothstep(denstart, denstart+edgesoft, normnoise);\n\n        // more high freq radial noise on top\n        density += snoise1d(r*0.8)*0.3;\n\n        density = clamp(density, 0., 1.);\n\n        // soften outer edge\n        density *= 1.0 - smoothstep(ringrad*0.98, ringrad, r);\n\n        // soften inner edge, against planet\n        density *= smoothstep(satradius, satradius*1.05, r);\n\n        vec3 ringcol = mix( vec3(1.0, 0.3, 0.0), vec3(1.0, 0.2, 0.0), snoise1d(r)*0.5+0.5 );\n        ringcol = mix(vec3(0.0,0.0,0.0), ringcol, pow(r/ringrad,2.0));\n        ringcol *= mix(0.95, 1.0, snoise2d(pring.xz*5.));\n\n        // darken towards the middle\n        ringcol *= smoothstep(ringrad-satradius*1.2, ringrad, r);\n        ringcol *= 0.9;\n\n\n        //col += density*ringcol;\n        col = mix( col, ringcol, density);\n    }\n \treturn col;\n}\n\nvec2 curl2d(in vec2 p)\n{\n    const float E = 0.9;\n    float x = snoise2d(p);\n    float xey = snoise2d(p+vec2(0., E));\n    float xex = snoise2d(p+vec2(E, 0.));\n    \n    return vec2( xex-x, -(xey-x) ) / E;\n}\n\nvec3 saturn_gradient(in vec3 pos, in vec3 rd)\n{\n    // shades of orane\n    vec3 albedo = mix( vec3(0.8,0.6,0.0), vec3(0.7,0.7,1.0), snoise2d( vec2(0.0, pos.y*1.2) ) );\n    \n    // some blue as we go lower\n    albedo += vec3(0,0.5,0.8) * smoothstep(0., -2., pos.y);\n        \n    return albedo;\n}\n\nvec3 shade_saturn( in vec3 pos, in vec3 rd )\n{\n    float t = iTime;\n    vec3 p = pos;\n    \n    // rotate the flow map a bit\n    p = yRot(p, iTime * PI/20.);\n    \n    // to spherical\n    float r = length(p);\n    float phi = atan(p.x, p.z);\n    float theta = acos(p.y/r);\n    \n    // to UV\n    vec2 uv = vec2( phi/PI - 0.5, -(theta/PI - 0.5) );\n    \n    // backwards curl advection\n    for( int i = 0; i < 20; i++ ) {\n        vec2 duv = curl2d(uv*20.)*.0004*.5;\n        uv += duv;\n    }\n    \n    // back to spherical\n    phi = (uv.x+0.5) * PI;\n    theta = (-uv.y+0.5) * PI;\n    \n    // add some ripple in opposite direction so it can flow through the warp\n    theta += sin(TPI*phi/(0.1*PI) + t*(1.3*PI)) * PI*0.005;\n    \n    // back to cartesian\n    p = vec3(\n        r * sin(theta) * cos(phi),\n        r * cos(theta),\n        r * sin(theta) * sin(phi));\n\n    vec3 alb = saturn_gradient( p, rd );\n    \n    // make the center glow a bit\n\tvec3 nor = pos/length(pos);    \n    alb += vec3(1,0.8,0.5) * smoothstep(1.5, 0.0, abs(pos.y)) * pow(dot(nor,-rd),1.0);\n    \n    return alb;\n\n}\n\nvec2 hash( vec2 p )\n{\n\treturn texture( iChannel0, (p+0.5)/200.0, -100.0 ).xy;\n}\n\nvec3 voronoi( in vec2 x, out vec2 cpId )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n\t\t\n        if( dot(mr-r,mr-r)>0.000001 )\n\t\t{\n        // distance to line\t\t\n        float d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        md = min( md, d );\n\t\t}\n    }\n\t\n\tcpId = n+mg;\n\n    return vec3( md, mr );\n}\n\nvec4 stars(vec3 rd)\n{\n    float t = iTime;\n    \n    float r = length(rd);\n    float phi = atan(rd.x, rd.z);\n    float theta = acos(rd.y/r);\n    vec2 polar = vec2(phi, theta);\n\n    vec2 cpid;\n    const float zoom = 0.18;\n    vec3 c = voronoi( polar/zoom, cpid );\n\tfloat centerDist = length( c.yz );\n\tfloat borderDist = c.x;\n    \n    const float minsize = 0.005;\n    float size = mix(minsize, 0.05, snoise2d(cpid*20.0)*0.5+0.5);\n    float sharp = mix(0.3, 0.9, snoise2d(cpid*10.0)*0.5+0.5);\n    \n    float flickerFreq = mix(1., 2., snoise2d(cpid*15.0)*0.5+0.5);\n    const float flickerAmt = 0.2;\n    size += minsize * snoise1d(t*flickerFreq);\n       \n    return vec4(1., 1., 0.8, smoothstep(0., 1., pow(centerDist/size, sharp)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\t\n    // camera\t\n\tfloat time = 2.7+iTime;\n    \n    // TEMP freeze camera\n    time *= 0.1;\n    \n\tvec3 ro = path( time+0.0 );\n\tvec3 camTarget = path( time+1.6 );\n\t//camTarget.y *= 0.3 + 0.25*cos(0.11*time);\n\tcamTarget.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.001*time);\n\t\n\t// TEMP\n\troll = -200.0;\n\tcamTarget = vec3(0,0,0);\n\t\n\t// stop going into the planet\n\tro = normalize(ro)*max( 10.0, length(ro));\n\t\n\t// camera tx\n\tvec3 cw = normalize(camTarget-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; // put focus plane behind Mike\n\tro -= 0.2*cu*eyeID;    // eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    // sky\t \n\tvec3 col = vec3(0.1,0.01,0.01) - rd.y*0.1;\n    col *= 0.9;\n    \n\tvec3 bcol = col;\n\n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd)+0.0;\n\n    if( t>0.0 )\n\t{\n        // we've hit saturn\n        \n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 ref = reflect( rd, nor );\t// not used?\n\t\t\n\t\t// Perturb the normal by sampling 3D noise\n\t\t// This is largely responsible for the rough, crumbly look of the volcanic rock. Very cool!\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.2*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        // lighting\n\t\tfloat dif = sqrt(clamp( dot( nor, lig ), 0.0, 1.0 ));\n\t\tfloat sha = 0.0;\n\t\tif( dif>0.01)\n\t\t\tsha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        //float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 2.5;\n\n\t\tcol = vec3(0.8);\n\t\t\n\t\tfloat cd = length(pos);\n\n        // shade Saturn\n        vec3 albedo = shade_saturn(pos, rd);\n        vec3 brdf =\tdif * albedo;\n        brdf += 0.1 * amb * albedo;\n\n        // anti-rim lighting\n        brdf -= pow(1.0-clamp(dot(nor,-rd),0.,1.),1.9);\n\n        // light/surface interaction\t\t\n        col = brdf * col;\n\t\t\n\t\t// atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n\t}\n    else {\n        // hit space - do stars!\n        vec4 colstars = stars(rd);\n        col = mix(colstars.rgb, col, colstars.a);\n    }\n    \n    // rings - ray trace directly on to the y=0 plane\n    // TODO: bind lights here\n    col = blendrings(col, t, ro, rd);\n\n    // film grain over everything\n    col *= mix(0.95, 1.0, snoise2d(p*50.0));\n \n    if(false && fragCoord.x < 200.) {\n        vec2 c = curl2d(fragCoord.xy*.025)*0.5+0.5;\n        fragColor = vec4( c, 0., 1.);\n    }\n    else {\n\t\tfragColor = vec4( col, 1.0 );\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sXXz7","date":"1398147685","viewed":956,"name":"Saturn Take 2","username":"steverock","description":"Trying to produce something more like this image: http://nssdc.gsfc.nasa.gov/image/planetary/saturn/saturn_false.jpg","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""}}