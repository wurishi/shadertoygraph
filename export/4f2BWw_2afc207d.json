{"ver":"0.1","info":{"id":"4f2BWw","date":"1728160254","viewed":50,"name":"Dancing Donuts","username":"nilberlin","description":"so shy they are! !","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["rotating"],"hasliked":0,"parentid":"MfBfDm","parentname":"NeonTenti"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nvec3 neonColor(float t) {\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (t * vec3(1.0, 1.0, 0.5) + vec3(0.0, 0.33, 0.67)));\n    return pow(color, vec3(0.6)); // Restore original color intensity for a balanced vibrancy\n}\n\nvoid drawRings(vec2 uv, inout vec3 col, float timeOffset) {\n    // Original pulsating rings\n    for (int i = 0; i < 15; i++) {\n        float t = (iTime + timeOffset) * (0.6 + 0.2 * sin(iTime)); // Modulate speed in sync with music\n        t += float(i) * PI / 7.5;\n        float d = sdCircle(uv, 0.1 + 0.03 * sin(t * 3.0));\n        vec3 ringColor = neonColor(float(i) / 15.0 + (iTime + timeOffset) * 0.2);\n        col += ringColor * smoothstep(0.01, 0.0, abs(d)) * 0.7; // Sharper, more intense rings\n    }\n    \n    // Additional outer rings for a larger effect\n    for (int i = 15; i < 25; i++) {\n        float t = (iTime + timeOffset) * (0.5 + 0.2 * sin(iTime)); // Modulate speed in sync with music\n        t += float(i) * PI / 6.0;\n        float d = sdCircle(uv, 0.3 + 0.05 * sin(t * 2.0)); // Larger rings further out\n        vec3 ringColor = neonColor(float(i) / 25.0 + (iTime + timeOffset) * 0.15);\n        col += ringColor * smoothstep(0.015, 0.0, abs(d)) * 0.5; // Softer outer rings\n    }\n}\n\nvoid drawNotes(vec2 uv, inout vec3 col) {\n    // Draw musical notes circling around the speakers\n    for (int i = 0; i < 10; i++) {\n        float angle = iTime * 0.5 + float(i) * PI / 5.0;\n        vec2 notePos = vec2(cos(angle), sin(angle)) * (0.6 + 0.1 * sin(iTime + float(i)));\n        notePos += vec2((i % 2 == 0 ? -0.35 : 0.35), 0.0); // Position notes further away from the center\n        float d = sdCircle(uv - notePos, 0.03);\n        vec3 noteColor = neonColor(float(i) / 10.0 + iTime * 0.3);\n        col += noteColor * smoothstep(0.02, 0.0, abs(d)) * 0.8; // Pulsating notes with vibrant colors\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0.0, 0.0, 0.0); // Black background\n    \n    // Apply rotation to the entire UV space\n    float rotationSpeed = 0.15 + 0.05 * sin(iTime * 0.5); // Varying rotation speed\n    float angle = iTime * rotationSpeed;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv *= rot;\n    \n    // Draw left speaker rings with a larger offset to avoid overlapping\n    vec2 leftUV = uv + vec2(0.4, 0.0); // Move further to the left\n    drawRings(leftUV, col, 0.0);\n    \n    // Draw right speaker rings with a larger offset to avoid overlapping\n    vec2 rightUV = uv - vec2(0.4, 0.0); // Move further to the right\n    drawRings(rightUV, col, 1.0); // Time offset for different animation phase\n    \n    // Draw musical notes dancing around the speakers\n    drawNotes(uv, col);\n    \n    // Enhance background with subtle starfield for more cosmic vibe\n    for (int i = 0; i < 100; i++) {\n        vec2 starPos = vec2(hash21(vec2(i, i * 2)) * 2.0 - 1.0, hash21(vec2(i * 3, i * 5)) * 2.0 - 1.0);\n        float starFlicker = sin(iTime * (3.0 + hash21(starPos) * 5.0)) * 0.5 + 0.5;\n        col += vec3(0.8, 0.8, 1.0) * pow(smoothstep(0.05, 0.0, length(uv - starPos)), 10.0) * starFlicker * 0.3;\n    }\n    \n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}