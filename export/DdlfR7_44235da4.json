{"ver":"0.1","info":{"id":"DdlfR7","date":"1690741004","viewed":243,"name":"Grass sdf attempt","username":"Langwedocjusz","description":"Heavilly based on https://www.shadertoy.com/view/dd2cWh\nMore detailed description on top of the 'Image' tab","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["sdfgrass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Heavilly based on \"grass field with blades\" by MonterMan:\n//https://www.shadertoy.com/view/dd2cWh\n//\n//The main thing i tried to do with this is to modify his grass blade sdf\n//to make it more 'artist-friendly' that is generalize it with intuitive parameters\n//like width at base and slanting angle\n\n//My generalized sdf is in the \"Common\" tab\n//Buffer A visualizes 2d section of the sdf\n//Buffer B raymarches a field of such blades exactly as in MonsterMan's shader\n//albeit in a simplified, stripped down version\n\n//TO-DO:\n//* Generate more interesting grass population\n//  Value noise could be used to determine rotation and slant to nicely simulate\n//  grass growing in clumps.\n//* Sort out numerical artifacts in raymarching\n//* Extend the range of angles supported by the 2d sdf\n//* MAYBE add antialiasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float fac = smoothstep(0.5-0.001, 0.5+0.001, uv.x);\n    \n    vec4 graph_2d = texture(iChannel0, uv);\n    vec4 raymarch = texture(iChannel1, uv);\n    \n    fragColor = mix(graph_2d, raymarch, fac);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rgb(X, Y, Z) vec3(X, Y, Z)/255.0\n\nfloat LineFactor(float coord, float halfwidth)\n{\n    return smoothstep(-halfwidth, 0.0,  coord) \n         * smoothstep(-halfwidth, 0.0, -coord);\n}\n\nvec3 VisualizeSDF(float sd)\n{\n    const vec3 red1  = rgb(156, 60, 16);\n    const vec3 red2  = rgb(222, 100, 44);\n    const vec3 blue1 = rgb(10, 59, 99);\n    const vec3 blue2 = rgb(60, 190, 230);\n    \n    const float freq = 50.0;\n    float fac = 0.5 * sin(freq * sd) + 0.5;\n    \n    vec3 base = (sd < 0.0)\n              ? mix(blue1, blue2, fac)\n              : mix(red1, red2, fac);\n              \n    return mix(base, vec3(0.0), LineFactor(sd, 0.005));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.5 * fragCoord/iResolution.xy - vec2(0.1, 0.25);\n    uv.x *= (iResolution.x/iResolution.y);\n    \n    float slant = 0.25*(PI - 1.0)*sin(0.5*iTime) + 0.25*(PI + 1.0);\n    float base_width = 0.07;\n    \n    float sd = sdGrassBlade2d(uv, slant, base_width);\n    \n    vec3 col = VisualizeSDF(sd);\n    \n    //Frame around [0,1] x [0,1] box\n    col = mix(col, vec3(1.0), LineFactor(uv.x      , 0.005));\n    col = mix(col, vec3(1.0), LineFactor(uv.x - 1.0, 0.005));\n    col = mix(col, vec3(1.0), LineFactor(uv.y      , 0.005));\n    col = mix(col, vec3(1.0), LineFactor(uv.y - 1.0, 0.005));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\nfloat opSubtract(float d1, float d2);\nfloat sdEllipse( vec2 p, vec2 ab );\n\nfloat sdGrassBlade2d(vec2 p, float slant, float base_width)\n{   \n    //Warning: this sdf by design violently breaks down for blades approaching vertical\n    slant = max(0.5, slant);\n\n    float s = sin(PI-slant), c = cos(PI-slant);\n    \n    //Factor scaling verical axes of the ellipses\n    //to make y coord of the intersection always equal to 1.0\n    float vert_fac = 1.0/s;\n\n    //Initial, larger ellipse \n    //It is placed at the lower right cornet, with horizontal axis = 1.0\n    float dist = sdEllipse(p - vec2(1.0, 0.0), vec2(1.0, vert_fac));\n    \n    //Computing minor axis of the smaller ellipse such that it intersects\n    //the larger one at the given angle (slant), but keeping width of the\n    //base fixed\n    float C = 1.0 - base_width;\n    \n    float r = (1.0 + C*C + 2.0*C*c)/(2.0 + 2.0*C*c);\n    \n    //Constructing the smaller ellipse\n    vec2 axes = vec2(r, r*vert_fac);\n    \n    vec2 offset = (1.0 - r) * vec2(c, vert_fac * s);\n    vec2 center = vec2(1.0, 0.0) + offset;\n    \n    //Carving out the smaller ellipse\n    dist = opSubtract(dist, sdEllipse(p - center, axes));\n    \n    //Removing everything below the y=0.0 plane\n    dist = opSubtract(dist, p.y);\n    \n    //Removing everything above the tip using\n    //sdf of a plane that is touched by the tip at a right angle\n    vec2 org = vec2(1.0, 0.0);\n    vec2 dir = normalize(vec2(-1.0, c));\n    \n    dist = opSubtract(dist, dot(p-org, dir));\n    \n    return dist;\n}\n\nfloat opSubtract(float d1, float d2) \n{ \n    return max(d1,-d2);\n}\n\n//Ellipse SDF by Inigo Quilez: https://www.shadertoy.com/view/4lsXDN\nfloat sdEllipse( vec2 p, vec2 ab )\n{\n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// hash function credit: https://www.shadertoy.com/view/4djSRW\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rotate2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s,s, c);\n}\n\nvec2 opRepeat(vec2 p, vec2 period, out vec2 outId)\n{\n    outId = floor((p+0.5*period)/period);\n    return mod(p+0.5*period, period) - 0.5*period;\n}\n\nfloat sdGrassBlade(vec3 p, float thickness)\n{   \n    float base_width = 0.07;\n    float slant = 0.25*(PI - 1.0)*sin(0.5*iTime) + 0.25*(PI + 1.0);\n    \n    float dist2d = max(0.0, sdGrassBlade2d(p.xy, slant, base_width));\n    \n    return sqrt(dist2d*dist2d + p.z*p.z) - thickness;\n}\n\nfloat Map(vec3 p)\n{\n    vec2 grassId;\n    float repeatPeriod = 0.25;\n    p.xz = opRepeat(p.xz, vec2(repeatPeriod), grassId);\n    \n    float dist = 1e30;\n    \n    for (int dy = -1; dy <= 1; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            vec3 neighborP = p - vec3(dx, 0, dy) * repeatPeriod;\n            vec2 neighborId = grassId + vec2(dx, dy);\n            \n            vec4 rand = hash42(neighborId);\n            neighborP.xz *= rotate2d(rand.z*6.28);\n            neighborP.xz += (rand.xy - 0.5) * repeatPeriod;\n            \n            dist = min(dist, sdGrassBlade(neighborP/sqrt(rand.w), 0.002));\n        }\n    }\n\n    return dist;\n}\n\nvec3 Norm(vec3 p)\n{\n    vec2 h = vec2(0.0, 0.001);\n    \n    return normalize(vec3(\n        Map(p+h.yxx) - Map(p-h.yxx),\n        Map(p+h.xyx) - Map(p-h.xyx),\n        Map(p+h.xxy) - Map(p-h.xxy)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= (iResolution.x/iResolution.y);\n\n    if (uv.x < 0.0)\n    {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n\n    vec3 col = vec3(0.0);\n    \n    vec3 org = vec3(0.0, 2.0, -3.0);\n    vec3 dir = normalize(vec3(uv, 1.4));\n    \n    float ang = 0.5;\n    float s = sin(ang), c = cos(ang);\n    dir.yz *= mat2(c, -s, s, c);\n    \n    bool hit = false; float t = 0.0;\n    \n    if (dir.y <= 0.0)\n    {\n        for (int i=0; i<128; i++)\n        {\n            vec3 p = org + t*dir;\n            \n            if (p.y < 0.0 || p.z > 30.0) break;\n        \n            float sd = Map(p);\n        \n            if (abs(sd) < 0.01)\n            {\n                hit = true;\n                break;\n            }\n        \n            t += sd;\n        }\n    }\n    \n    \n    if (hit)\n    {\n        vec3 p = org + t*dir;\n        vec3 n = Norm(p);\n        vec3 ldir = normalize(vec3(1.0, 1.0, -1.0));\n        \n        float dif = dot(ldir, n);\n        float ao = clamp(p.y, 0.0, 1.0);\n        \n        col = vec3(ao*dif);\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}