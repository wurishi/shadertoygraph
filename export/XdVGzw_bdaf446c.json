{"ver":"0.1","info":{"id":"XdVGzw","date":"1453742228","viewed":346,"name":"Day 004 - Soft Shadows","username":"mwalczyk","description":"Soft Shadows - Day 004","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Much love / credit to @cabbibo for his SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n\n#define PI 3.14159\n\nconst float MAX_TRACE_DIST = 20.0;\t// Max trace distance\nconst float MIN_HIT_DIST = 0.001;\t// Precision of the intersection\nconst int MAX_NUM_STEPS = 100;\t\t// Max number of steps we take along a ray\n\n// Polynomial smooth min (k = 0.1) and opBlend from IQ\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opBlend(float a, float b)\n{\n    // Added this for the animation\n    float k = (sin(iTime * 4.0) + 1.0) / 2.0;\n    k = max(0.2, k);\n\n\treturn smin(a, b, k);\n}\n\nvec2 opU( vec2 a, vec2 b )\n{\n\treturn (a.x < b.x) ? a : b;\n}\n\nfloat sdPlane(in vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p, float s)\n{\n  \t// Domain deformation based on sinusoidal funcs\n    // See IQ's website, per-usual...guy is a genius!\n  \tfloat freq = 4.0 * pow(sin(iTime), 2.0);\n    float d1 = length(p) - s;\n  \tfloat d2 = 0.3*sin(freq * p.x) * sin(freq * p.y + 0.8) * sin(freq * p.z + 0.3); \n  \n   \treturn d1 + d2;\n}\n\nvec2 map(in vec3 pos)\n{\n    // This is where we actually define all of the properties of \n    // the objects in our scene and perform any unions, intersections, \n    // deformations, etc.\n    \n    float sphere1 = sdSphere(pos - \tvec3(0.5, 0.0, 0.0), \t1.5);\n    float sphere2 = sdSphere(pos - \tvec3(-0.5, 0.0, 0.0), \t1.5);\n\n    vec2 res = vec2( \t  sdPlane(pos - vec3(0.0, -2.0, 0.0)),       1.0 ); \n    res = opU( res, vec2( opBlend(sphere1, sphere2), \t\t\t\t 2.0 ));\n    \n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\t\n    // min and max are 0.02 and 2.5\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; ++i)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\t// 8.0 seems to control the softness\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n// Calculate the normal of the surface at position pos\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\n// Calculate intersections\nvec2 calcIntersection(in vec3 ro, in vec3 rd)\n{\n    // This is where we do the actual \"marching\"\n    \n    float h =  MIN_HIT_DIST * 2.0;\t// Distance to the closest surface, which we overwrite each iteration\n    float t = 0.0;\t\t\t\t\t// Total distance traveled along the ray\t\t\t\t\t\t\n\tfloat finalDist = -1.0;\t\t\t// We haven't hit anything yet, so make this negative\n    float id = -1.0;\t\t\t\t// We haven't hit anything yet, so make this negative\n    \n    for(int i = 0; i < MAX_NUM_STEPS; ++i)\n    {\n        // Are we close enough to the surface? OR\n        // Have we traveled far enough to safely say we won't hit anything?\n    \tif(h < MIN_HIT_DIST || t > MAX_TRACE_DIST) break;\n        \n        vec2 distToClosest = map(ro + rd * t);\n        h = distToClosest.x;\t// The distance\n        id = distToClosest.y;\t// The object id\n        t += h;\t\t\t\t\t// Clever optimization: see literature on \"Distance Aided Raymarching\"\n    }\n    \n    if(t < MAX_TRACE_DIST) finalDist = t;\n    if(t > MAX_TRACE_DIST) id = -1.0;\n    return vec2(finalDist, id);\n}\n\n// Calculate the color at the ray position\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv)\n{\n    // Make a corny ass background gradient\n    float ssDistToCenter = length(uv);\n    vec3 bgColor1 = vec3(0.6, 0.2, 0.9);\n    vec3 bgColor2 = vec3(0.0, 0.2, 0.8); \n    vec3 surfaceColor = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n    \n    vec2 results = calcIntersection(ro, rd);\n    float t = results.x;\t\t\t\t\t\t// Where along our ray did we hit?\n    float id = results.y;\t\t\t\t\t\t// What did we hit?\n    \n    if(t > -0.5)\n    {\n    \t// Here, we could use the 'id' to change lighting / material \n   \t\t// params on a per-object basis\n   \t\tvec3 lightPos = vec3(1.0, 4.0, 3.0);\n   \t \tvec3 pos = ro + rd * t;\n        \n        vec3 n = calcNormal(pos);\n        vec3 diffColor = vec3(0.8, 0.0, 0.1);\n        \n        if( id < 1.5 )\n        {    \n            // The only object that has an 'id' less than 1.5 is the floor\n            float f = mod( floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n            diffColor = 0.4 + 0.1 * f * vec3(1.0);\n        }\n    \t\n    \tvec3 l = normalize(lightPos - pos);       \n    \tfloat diffStrength = max(dot(n, l), 0.0);\n        float ambientStrength = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        vec3 ambientColor = vec3(0.50,0.70,1.00);\n        \n    \tdiffColor *= softshadow( pos, lightPos, 0.02, 2.5 );\n        ambientColor *= ambientStrength * 0.2;\n        \n    \tsurfaceColor = diffStrength * diffColor + ambientColor;\n        \n    }\n    \n    return surfaceColor;\n}\n    \nmat3 setCamMatrix(in vec3 ro, in vec3 ta, float roll)\n{\n\tvec3 ww = normalize(ta - ro);\t// Look-at direction, normalized\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Need to review this calculation...\n   \tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    float radius = 7.0;\n    float camX = radius * cos(iTime * 0.5);\n    float camZ = radius * sin(iTime * 0.5);\n   \n    vec3 ro = vec3(camX, 0.0, camZ);\t\t\t\t\t\t\t\t\t// Ray origin\n\tvec3 ta = vec3(0.0);\t\t\t\t\t\t\t\t\t\t\t// Look-at position\n    mat3 cameraMatrix = setCamMatrix(ro, ta, 0.0);\t\t\t\t\t// Position, look-at, roll\n    \n    float lensLength = 2.0;\n    vec3 rd = normalize(cameraMatrix * vec3(p.xy, lensLength));\t\t// Ray direction\n    \n    vec3 color = render(ro, rd, p);\n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}