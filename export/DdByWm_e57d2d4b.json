{"ver":"0.1","info":{"id":"DdByWm","date":"1687750376","viewed":46,"name":"self aliasing fake hyperobjectoO","username":"graygoose","description":"it's only ever really rotating clockwise. There's a lot of effects you can get out of just tuning constants, or holding certain vars. This will momentarily pass some very cool ones, but never stay anywhere interesting.\n\nvar names are deceptive, sorry.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shutter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n// set to 0 to see the base object being...slice-jected?\n#define ENABLE_SLICES 1\n#define TICKRATE 1000.0\n\n#define SAMPLES 100\n// All iTime constants can be fine-tuned against each other. Also consider tuning the blur strength.\n#define BLUR_STR (abs(sin(iTime*0.23)*cos(iTime*0.15)) / float(SAMPLES))\n\n/// varying most constants or holding them produce very interesting sets of dynamics\n#define SPOKE_WIDTH 0.033*abs(1.2-abs(sin(iTime*0.27)))\n#define SPOKE_SPACING 0.035\n\n// vestigial, behaves as an offset\n#define ROTATION_SHUTTER_DIFF 14.0\n// mostly a speed factor right now - it's tied to \"tickrate\"\n#define ROTATION_SHUTTER_FACTOR 180.0\n#define ROT (ROTATION_SHUTTER_FACTOR - ROTATION_SHUTTER_DIFF) / TICKRATE\n#define SPD (ROTATION_SHUTTER_FACTOR + ROTATION_SHUTTER_DIFF) / TICKRATE\n\n// Try float(i) - w/ 1000 samples it is weird, for sure.\n#define ROT_ACC_FACT 1.0\n\nvec4 getSpokeColor(vec2 uv, vec2 wheelCenter, float rotation, float wheelRadius) {\n    vec2 wheelUV = uv - wheelCenter;\n    if (length(wheelUV) < wheelRadius) {\n        float normalizedAngle = mod(atan(wheelUV.y, wheelUV.x) + rotation, 2.0 * PI) / (2.0 * PI);\n        float spokePattern = mod(normalizedAngle, SPOKE_SPACING) < SPOKE_WIDTH ? 1.0 : 0.0;\n        return mix(vec4(0,0,0,1), vec4(1), spokePattern);\n    }\n    return vec4(0,0,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy,\n     wheelCenter = vec2(0.5);\n    float rotation = iTime * ROT * 2.0 * PI,\n     shutterPhase = mod(iTime, SPD) / SPD,\n     wheelRadius = 0.3;\n     \n\n#if ENABLE_SLICES\n    vec2 blurDirection = vec2(cos(rotation), sin(rotation)),\n     blurAmount = BLUR_STR * blurDirection;\n    vec4 blurColor = vec4(0.);\n    for (int i = 0; i < SAMPLES; ++i) {\n        vec2 offsetUV = uv + blurAmount * float(i - SAMPLES / 2);\n        blurColor += getSpokeColor(offsetUV, wheelCenter, rotation / ROT_ACC_FACT, wheelRadius);\n    }\n    vec4 color = blurColor / float(SAMPLES); // Try dividing samples by 2\n#else\n    vec4 color = getSpokeColor(uv, wheelCenter, rotation, wheelRadius);\n#endif\n    fragColor = color;\n}\n\n\n// P.S The tetris-like effect this fairly acutely produces goes freaking hard. \n// If you make sure the spokes never become wide enough to remove all spacing, it will produce a better effect sooner.","name":"Image","description":"","type":"image"}]}