{"ver":"0.1","info":{"id":"4s3cDf","date":"1520366499","viewed":625,"name":"Corridor of Sillyness","username":"stellabialek","description":"I might be addicted to making silly dancing blob guys...","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","voronoi","noise","heightfield","fbm","corridor","stones","vines","moldy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\nconst float PIHALF = PI / 2.0;\nconst float EPSILON = 0.00001;\nconst float INFINITY = 1000000000.0;\n\nconst float drawDist = 60.0;\nconst float thickness = 0.2;\nconst float lampSpacing = 4.0;\nconst vec3 lPos = vec3(lampSpacing, 3.0, -2.0);\n\nconst vec3 cStonesA = vec3(0.9, 1.0, 0.8);\nconst vec3 cStonesB = cStonesA * vec3(1.4, 1.3, 1.4);\nconst vec3 cVines = vec3(0.3, 0.5, 0.1);\nconst vec3 cLamps = vec3(2.0, 2.0, 2.0);\nconst vec3 light = vec3(1.1, 1.1, 1.0);\nconst vec3 shadow = vec3(0.0, 0.08, 0.06);\nconst vec3 bg = cStonesB * shadow;\n\nfloat smootherstep(float a, float b, float x)\n{\n    x = clamp((x - a)/(b - a), 0.0, 1.0);\n    return x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\n\nfloat rand(float seed)\n{\t\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nvec2 rep(vec2 p, vec2 r)\n{\n\treturn mod(p,r)-r/2.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdCapsule(vec2 p, float r, float h)\n{\n\tp.y -= smoothstep(0.0, h, abs(p.y))*h*sign(p.y);\n\treturn sdCircle(p, r);\n} \n\nvec2 rotate(vec2 p, float angle)\n{\n\tmat2 mat = mat2(cos(angle),-sin(angle),\n\t\t\t\t\tsin(angle),cos(angle));\n\treturn mat * p;\n}\n\nfloat dancers(vec2 p, float t, inout vec3 c)\n{\t\t\n\tfloat cutoff = 1.0 - step(1.0, abs(p.y));\n\tfloat f = ((p.y+0.6)/1.2)*sin(t); \n\tp.x += cos(t)*0.2;\n\tp = rep(p, vec2(1.5, 0.0));\n\tp = rotate(p, f);\n\tvec2 op = p;\n\tp.x *= mix(1.0, 0.8, abs(f));\n\tfloat body = sdCapsule(p, 0.2, 0.4);\n\t\n\tfloat eyes = 1.0 - smoothstep(0.02, 0.05, length(p+vec2(0.1, -0.46)));\n\teyes += 1.0 - smoothstep(0.02, 0.05, length(p+vec2(-0.1, -0.46)));\n\tfloat mouth = sdCircle((p+vec2(0.0, -0.4))*vec2(1.0, 0.6+cos(t*2.0)*0.2), 0.03);\n\t\n\tp = op;\n\tp.y -= 0.1;\n\tp = rotate(p, sin(t*2.0)*0.5 * smoothstep(0.2, 0.6, abs(p.x)) + PIHALF);\n\tfloat arms = sdCapsule(p, 0.05, 0.4);\n\t\n\tp = op;\n\tp.y += 0.4;\n\tp = rotate(p, PIHALF - p.x*3.0);\n\tfloat legs = sdCapsule(p, 0.1, 0.3);\n\n\tbody = max(body, -mouth);\n\tbody = smin(body, arms, 0.1);\n\tbody = smin(body, legs, 0.2);\n\tbody = 1.0 - smoothstep(-0.02, 0.02, body);\n\t\n\tfloat dancers = (body + eyes)*cutoff;\n\tc = mix(c, cLamps, eyes*cutoff*0.4);\n\treturn dancers * 0.1;\n}\n\nvec2 spiralCoords(vec2 p, float turns) \n{\n\tp = vec2(atan(p.x, p.y)/TWOPI + 0.5, length(p)*turns);\n    float s = p.y+p.x;\n    float l = (floor(s)-p.x);\n    float d = fract(s);\n    return vec2(l, d);\n}\n\nfloat spiral(vec2 p)\n{\n\tfloat t = 0.05;\n\tfloat s = 0.3;\n\tp = spiralCoords(p,2.0);\n\tfloat d = smoothstep(0.5-t-s, 0.5-t, p.y);\n\td *= 1.0 - smoothstep(0.5+t, 0.5+t+s, p.y);\n\td *= 1.0 - smoothstep(1.0,1.1, p.x);\n\treturn 1.0 - d;\n}\n\nfloat ornament(vec2 p)\n{\n\tvec2 op = p;\n\t\n\t//swirls\n\tp += vec2(1.0, -0.1);\n\tfloat d = spiral(p);\n\tp += vec2(-2.0, 0.2);\n\tp *= -1.0;\n\td = min(d, spiral(p));\n\n\t//connection piece\n\tp = op;\n\tfloat c = abs(p.y - mix(-0.65, 0.65, smootherstep(-1.0, 1.0, p.x)));\n\tc = smoothstep(0.00, 0.15, c);\n\tc += smoothstep(1.0, 1.1, abs(p.x));\n\t\t\n\td = min(d, c);\n\treturn 1.0 - d;\n}\n\nfloat border(vec2 p, float t, inout vec3 c)\n{\n\tp.y = abs(p.y);\n\tp.y -= 1.4;\t\n\tvec2 op = p;\n\t\n\tp *= 3.0;\n\tp = rep(p, vec2(4.0, 0.0));\n\tfloat ornament = ornament(p);\n\tp.x = abs(p.x);\n\tfloat points = 1.0 - smoothstep(0.0, 0.15, distance(p,vec2(2.0,0.0)));\t\n\t\n\tp = op;\n\tp.y = abs(p.y);\n\tfloat lines = 1.0 - smoothstep(0.02,0.1, abs(p.y - 0.5));\n\tfloat border = 1.0 - smoothstep(0.1, 0.6, p.y);\n\t\n\treturn ornament*0.1 + lines * 0.2 + points * 0.1 + border * 0.9;\n}\n\nfloat pnorm(vec2 v, float p)\n{\n\treturn pow(pow(v.x,p)+pow(v.y,p),1.0/p);\n}\n\nfloat lamps(vec2 p, float t)\n{\n\tp.y -= lPos.y;\n\tp.x -= lampSpacing;\n\tp = rep(p, vec2(lampSpacing*2.0, 0.0));\n\treturn smoothstep(0.0, 1.0, length(p));\n}\n\nfloat stones(vec2 p, float t, inout vec3 c)\n{\n\tvec2 op = p;\n\tfloat n = texture(iChannel0, op*0.6).x;\n\t\n\tp.x *= 0.4;\n\tp.x += fract(floor(p.y)/2.0);\n\tfloat r = rand(floor(p));\n\tp = fract(p);\n\tp -= vec2(0.5);\n\tp = abs(p);\n\tfloat h = 1.0 - smoothstep(0.3,0.52,pnorm(p,mix(3.0, 6.0, r)));\n\th *= mix(0.6, 1.0, r);\n\t//clean up in the middle\n\th *= step(2.0, abs(op.y));\n\th += n*0.05;\n\th -= smoothstep(0.5, 1.0, n)*0.06;\n\t\n\tfloat lamps = lamps(op, t);\n\th *= smoothstep(0.2,0.4, lamps);\n\tlamps= 1.0 - smoothstep(0.0, 0.4, lamps);\n\th += lamps;\n\tc = mix(cStonesA, cStonesB, n);\n\tc = mix(c, cLamps, lamps);\n\treturn h*0.9;\n}\n\nfloat vines(vec2 p, float t, inout vec3 c)\n{\n\tvec2 bS = texture(iChannel0, p*0.4).xy;\n\tvec2 bL = texture(iChannel0, p*0.08).xy;\n\tfloat h = (bS.y + (bS.x-0.5)*0.8)/1.4;\n\th = smoothstep(0.0,1.0, h);\n\th /= 2.0;\n\th *= smoothstep(0.55, 0.65, bL.x);\n\th *= smoothstep(1.0, 2.0, abs(p.y));\n\tc = mix(c, cVines, h);\n\treturn h*0.1;\n}\n\nfloat heightField(vec2 p, float t, out vec3 c)\n{\n\tfloat h = stones(p,t, c);\n\th += border(p, t, c);\n\th += dancers(p,t, c);\n\th += vines(p,t, c);\n\treturn h;\n}\n\nfloat heightField(vec2 p, float t)\n{\n\tvec3 c;\n\treturn heightField(p, t, c);\n}\n\nvec4 sampleNeighbours(vec2 uv, float t)\n{\n\tvec2 d = vec2(0.01, 0.0);\n\tvec4 s;\n\ts.x = heightField(uv - d.xy, t);\n\ts.y = heightField(uv + d.xy, t);\n\ts.z = heightField(uv - d.yx, t);\n\ts.w = heightField(uv + d.yx, t);\n\treturn s;\n}\n\nvec3 getNormal(vec4 s)\n{\t\n\tvec2 d = vec2(0.01, 0.0);\n\tfloat dx = s.x - s.y;\n\tfloat dy = s.z - s.w;\n\t\n\tvec3 x = vec3(2.0 * d.x, dx * 0.0, dx*thickness);\n\tvec3 y =  vec3(0.0, d.x * 2.0, dy*thickness);\n\t \n\treturn normalize(cross(y, x));\t\n}\n\nfloat lambert(vec3 p, vec3 n, vec3 lPos)\n{\n\tvec3 l = lPos - p;\n\tfloat i = max(0.0, dot(normalize(l), n));\n\tl.y *= 0.6;\n\ti *= 1.0 - pow(length(l/(lampSpacing*1.5)),2.0);\n\treturn clamp(i,0.0,1.0);\n}\n\nfloat ambientOcclusion(float h, vec4 s)\n{\n\tfloat ao = max(s.x - h,0.0);\n\tao += max(s.y - h,0.0);\n\tao += max(s.z - h,0.0);\n\tao += max(s.w - h,0.0);\n\treturn 1.0 - smoothstep(0.0, 0.2, ao);\n}\n\nvec3 rep(vec3 p, vec3 r)\n{\n\treturn mod(p, r)-0.5*r;\n}\n\nfloat intensity(vec3 p, float h, float t)\n{\n\tvec4 s = sampleNeighbours(p.xy, t);\n\tvec3 n = getNormal(s);\t\t\t\t\n\tvec3 lp = rep(p, vec3(lampSpacing*2.0, 0.0, 0.0));\n\tfloat i = lambert(lp, n, lPos);\n\ti += lambert(lp, n, lPos * vec3(-1.0, 1.0, 1.0));\n\ti = mix(0.05, 1.0, i);\n\ti *= ambientOcclusion(h,s);\n\treturn i;\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n};\n\nray createRay(float fov, vec2 coord, vec2 res)\n{\n\tray r;\n\tr.o = vec3(iTime, 0.0, -5.0);\n\tfloat fx = tan(radians(fov) / 2.0) / res.x;\n\tvec2 d = fx * ( coord.xy * 2.0 - res);\n\tr.d = normalize(vec3(d, 1.0));\n\tr.d = rotateX(r.d, 0.1 + 0.2*sin(iTime));\n\tr.d = rotateY(r.d, -0.7 + 0.16*cos(iTime));\n\treturn r;\n}\n\nstruct plane\n{\n\tvec3 n;\n\tfloat d;\n};\nconst plane frontPlane = plane(vec3(0.0, 0.0, -1.0), 0.0);\t\nconst plane backPlane = plane(vec3(0.0, 0.0, -1.0), thickness);\t\n\nfloat intersectPlane(ray r, plane pl)\n{\n\tfloat d = dot(pl.n, r.d);\n\tif(abs(d) < EPSILON)\n\t\treturn -INFINITY;;\n\treturn (-pl.d - dot(pl.n, r.o)) / d;\n}\n\nfloat map01(float min, float max, float t)\n{\n\treturn clamp((t - min )/ (max - min),0.0,1.0);\n}\n\nfloat vignette(vec2 uv)\n{\n\tfloat v = pnorm((uv-vec2(0.5))*2.0,6.0);\n\tv = smoothstep(0.9, 1.2, v);\n\treturn v;\n}\t\n\nvec3 corridor(ray r, vec2 uv)\n{\n\tfloat time = iTime * 3.0;\n\t\t\n\tfloat front = intersectPlane(r, frontPlane);\n\tfloat back = intersectPlane(r, backPlane);\n\t\n\tvec3 color = bg;\t\n\tif(front > 0.0 && back > 0.0 && back < drawDist)\n\t{\t\n\t\tvec3 p = r.o + front * r.d;\n\t\tfloat h = 0.0;\n\t\twhile(p.z < thickness)\n\t\t{\n\t\t\tfloat ph = 1.0 - map01(0.0, thickness, p.z);\n\t\t\th = heightField(p.xy, time, color);\n\t\t\tif(ph <= h) break;\n\t\t\tp += r.d * 0.01;\n\t\t}\n\t\tfloat i = intensity(p, h, time);\n\t\tcolor = mix(color * shadow, color * light, i);\t\t\n\t}\n\tfloat fog = map01(drawDist/10.0, drawDist, back);\n\treturn mix(color, bg, max(fog,vignette(uv)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\t\n\tray r = createRay(70.0, gl_FragCoord.xy, iResolution.xy);\n\tvec3 color = corridor(r,uv);\n\t\t\n\tfragColor = vec4(color,1.0);\t\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\nconst float INFINITY = 1000000000.0;\n\nfloat smootherstep(float a, float b, float x)\n{\n    x = clamp((x - a)/(b - a), 0.0, 1.0);\n    return x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\n\nvec2 smootherstep(float a, float b, vec2 i)\n{\n\treturn vec2(smootherstep(a, b, i.x), smootherstep(a, b, i.y));\n}\n\nfloat rand(float seed)\n{\t\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed, float f)\n{\n\tseed = mod(seed, f);\n\treturn rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nvec2 rand2D(vec2 seed, float f)\n{\n\tfloat r = rand(seed, f) * TWOPI;\n\treturn vec2(cos(r), sin(r));\n}\n\nvec2 rand2D01(vec2 seed, float s)\n{\n\tvec2 r = rand2D(seed, s);\n\treturn (r + vec2(1.0))/2.0;\n}\n\nfloat voronoi(vec2 x, float scale)\n{\n\tx *= scale;\n\tvec2 i = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 mn; //closest neighbour\n\tvec2 mc; //closest center\n    float dc = INFINITY; //distance to center\n    for( int x=-1; x<=1; x++ )\n    for( int y=-1; y<=1; y++ )\n    {\n        vec2 n = vec2(x,y);\n        vec2 c = n + rand2D01(i+n,scale) - f;\n        float d = dot(c,c);\n        if( d<dc ){ dc = d; mc = c; mn = n;}\n    }\n    float db = INFINITY; //distance to border\n    for( int x=-2; x<=2; x++ )\n    for( int y=-2; y<=2; y++ )\n    {\n        vec2 n = mn + vec2(x,y);\n        vec2 c = n + rand2D01(i+n,scale) - f;\n        float d = dot(0.5*(mc+c), normalize(c-mc));\n        db = min(db,d);\n    }\n\treturn 1.0 - mix(db, 0.5-dc, db*2.0)*2.0;\n}\n\nfloat gradientNoise(vec2 coord, float frequency)\n{\n\tvec2 i = coord * frequency;\n\tvec2 f = fract(i);\t\n\ti = floor(i);\n\t\n\tvec2 g00 = rand2D(i,frequency);\n\tvec2 g01 = rand2D(i + vec2(0.0, 1.0),frequency);\n\tvec2 g10 = rand2D(i + vec2(1.0, 0.0),frequency);\n\tvec2 g11 = rand2D(i + vec2(1.0, 1.0),frequency);\n\t\n\tfloat v00 = dot(g00, f);\n\tfloat v10 = dot(g10, f - vec2(1.0, 0.0));\n\tfloat v01 = dot(g01, f - vec2(0.0, 1.0));\n\tfloat v11 = dot(g11, f - vec2(1.0, 1.0));\n\n\tf = smootherstep(0.0, 1.0, f);\n\tfloat x1 = mix(v00, v10, f.x);\n\tfloat x2 = mix(v01, v11, f.x);\n\t\n\tfloat n =  mix(x1, x2, f.y);\t\n\treturn n;\t\n}\n\nfloat fbm(vec2 coord, float frequency)\n{\n\tint octaves = 4;\n\tfloat lacunarity = 2.0;\n\tfloat gain = 0.8;\n\n\tfloat amplitude = 0.5;\n\t\n\tfloat n = 0.5;\n\t\n\tfor(int i = 0; i < octaves; i++)\n\t{\n\t\tn += gradientNoise(coord, frequency) * amplitude;\n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\treturn n;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =fragCoord.xy / iResolution.xy;\n    \n    float fbm = fbm(uv,12.0);\n\tfloat voronoi = voronoi(uv, 12.0);\n    \n    fragColor = vec4(fbm,voronoi,0.0,0.0);\n}","name":"Buf A","description":"","type":"buffer"}]}