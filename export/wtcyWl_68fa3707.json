{"ver":"0.1","info":{"id":"wtcyWl","date":"1610571873","viewed":54,"name":"Blue Mandelbulb","username":"rmheuer","description":"Raymarcher with basic light rendering a mandelbulb","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst int MAX_STEPS = 1000;\nconst float EPSILON = 0.001;\n\nmat4 rotate(float a) {\n    float sine = sin(a);\n    float cosine = cos(a);\n    mat4 mat = mat4(\n    cosine, 0, sine, 0,\n    0, 1, 0, 0,\n    -sine, 0, cosine, 0,\n    0, 0, 0, 1\n    );\n    return inverse(mat);\n}\n\nfloat sdfMandelbulb( vec3 p )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    //resColor = vec4(m,trap.yzw);\n\n    return 0.25*log(m)*sqrt(m)/dz;}\n\nfloat sceneSDF( vec4 pos )\n{\n    // SDF of sphere with radius 1\n    return sdfMandelbulb((rotate(iTime / 3.0) * pos).xyz / 2.0) * 2.0;\n}\n\nfloat raymarch( in float start, in float end, in vec4 eyePos, in vec4 viewRay ) \n{\n    float depth = start;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        float dist = sceneSDF(eyePos + depth * viewRay);\n        \n        if (dist < EPSILON) \n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end)\n        {\n            return end;\n        }\n    }\n    \n    return end;\n}\n\nvec4 estimateNormal(vec4 p) \n{\n    return normalize(vec4(\n        sceneSDF(vec4(p.x + EPSILON, p.y, p.z, p.w)) - sceneSDF(vec4(p.x - EPSILON, p.y, p.z, p.w)),\n        sceneSDF(vec4(p.x, p.y + EPSILON, p.z, p.w)) - sceneSDF(vec4(p.x, p.y - EPSILON, p.z, p.w)),\n        sceneSDF(vec4(p.x, p.y, p.z + EPSILON, p.w)) - sceneSDF(vec4(p.x, p.y, p.z - EPSILON, p.w)),\n        sceneSDF(vec4(p.x, p.y, p.z, p.w + EPSILON)) - sceneSDF(vec4(p.x, p.y, p.z, p.w - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec4 eye = vec4(0, 0, -4, 0);\n    float aspect = iResolution.x / iResolution.y;\n    vec4 ray = normalize(vec4(((fragCoord.xy / iResolution.xy) - vec2(0.5)) * vec2(aspect, 1), 1, 0));\n\n    float march = raymarch(EPSILON, 100.0, eye, ray);\n\n    if (march > 100.0 - 1.0) \n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    const vec3 surfaceColor = vec3(0.5, 0.5, 1.0);\n    const float ambientLight = 0.2;\n    vec4 lightPos = vec4(0.0, 2.0, -4.0, 0.0);\n    \n    vec4 collisionPoint = eye + march * ray;\n    vec4 normal = estimateNormal(collisionPoint);\n    vec4 toLight = normalize(lightPos - collisionPoint);\n    float ndotl = dot(normal, toLight);\n    vec3 color = surfaceColor * clamp(ndotl, ambientLight, 1.0);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}