{"ver":"0.1","info":{"id":"4lSBDK","date":"1517158461","viewed":204,"name":"Water Floor","username":"domvalles","description":"Water Floor shader, cut off top part of fbm with some domain distortion. Might switch to voronoi. Undecided.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1457\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    float value = mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n    return value;\n}\n\n#define NUM_ITERATIONS 3\n\nfloat fbm(in vec2 uv){\n \n float amplitude = .5;\n float gain = .5;\n float lacunarity = 2.;\n float frequency = 1.;\n    \n float res = 0.;\n for (int x = 0; x < NUM_ITERATIONS; x++){\n\tres += amplitude * noise(frequency*uv);\n\tfrequency *= lacunarity;\n\tamplitude *= gain;\n }\n return res;\n}\n\n#define EPS 1.e-1\n#define NORMAL(UV,FUNC)\tvec2 dx = vec2(EPS,0.); vec3 t = vec3(EPS, FUNC(uv+dx),0.); vec3 s = vec3(-EPS, FUNC(uv-dx),0.); vec3 uv_dx = normalize((t - s)); vec2 dz = vec2(0.,EPS);t = vec3(0., FUNC(uv+dz),EPS);s = vec3(0.,FUNC(uv-dz),-EPS); vec3 uv_dz = normalize((t - s)); vec3 normal = cross(uv_dx, uv_dz); \n\nvec2 getGradient(in vec2 uv)\n{\n vec2 uv_dx2 = vec2(uv.x + EPS, uv.y);\n vec2 uv_dx1 = vec2(uv.x - EPS, uv.y);\n vec2 uv_dy2 = vec2(uv.x, uv.y + EPS);\n vec2 uv_dy1 = vec2(uv.x, uv.y - EPS);\n float dx = (fbm(uv_dx2) - fbm(uv_dx1))/2.*EPS;\n float dy = (fbm(uv_dy2) - fbm(uv_dy1))/2.*EPS;\n return vec2(dx,dy)*100.;\n}\n\nvec3 getNormal(in vec2 uv)\n{\n    //dx\n    vec2 dx = vec2(EPS,0.);\n    vec3 t = vec3(EPS,fbm(uv+dx),0.);\n    vec3 s = vec3(-EPS, fbm(uv-dx),0.);\n    vec3 uv_dx = normalize((t - s));\n    \n    //dy\n    vec2 dz = vec2(0.,EPS);\n    t = vec3(0.,fbm(uv+dz),EPS);\n    s = vec3(0.,fbm(uv-dz),-EPS);\n    vec3 uv_dz = normalize((t - s));\n    return cross(uv_dx, uv_dz);\n}\n\nvec3 blue = vec3(40.,134.,150.)/255.*.8;\nvec3 sunDir = normalize(vec3(1.,1.,1.));\n\nvec2 rotateOrigin(in vec2 uv, float rotation)\n{\n    mat2 rotate = mat2(cos(rotation),-sin(rotation),\n        \tsin(rotation),cos(rotation));\n    return rotate*uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 10.;\n    //uv += vec2(1.,0.)*iTime;\n    vec2 gradient = getGradient(uv);\n    float fbm = abs(-.5 + fbm(uv + .12*fbm( uv + vec2(1.,1.)*iTime)));\n    float gLength = length(gradient);\n    float st = smoothstep(0.,1., ((.041 - fbm)/gLength)/((.041-.02)));\n    //float st = step(fbm, .04);\n    //vec3 normal = -getNormal(uv);\n    //vec3 refrac = refract(vec3(0.,1.,0.), normal, 1.33/1.);\n    //float sn = clamp(dot(sunDir, refrac), 0., 1.);\n    //float res = step(sn, .001);\n    vec3 col;\n    col = mix(blue, vec3(1.), st);\n    vec4 color = vec4(col, 1.);\n\tfragColor = color;\n   // fragColor = vec4(gradient, 0.,1.);\n}","name":"Image","description":"","type":"image"}]}