{"ver":"0.1","info":{"id":"XltyD4","date":"1532685658","viewed":118,"name":"2D DFT Test #1","username":"archibate","description":"inspired by [url]https://www.shadertoy.com/view/MscGWS[/url].\noriginal data is shown in red&green.\nby default, DFT result is shown in blue, for the magnitude.\ncheck Buf A for more origins.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","fft","frequency","fourier","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n#define TAU (8.*atan(1.))\n#define DX .003\n\nvec2 fft(vec2 uv)\n{\n    vec2 x_col = (texture(iChannel0, uv).xy - .5) * 2.;\n    vec2 y_col = (texture(iChannel1, uv).xy - .5) * 2.;\n    vec2 col = cmul(x_col, y_col) / DX;\n    return col;\n}\n\nvec3 rainbow(float x)\n{\n    vec3 col = vec3(0);\n    col.r = cos(x * TAU - (0.0/3.0)*TAU);\n    col.g = cos(x * TAU - (1.0/3.0)*TAU);\n    col.b = cos(x * TAU - (2.0/3.0)*TAU);\n    \n    return col * 0.5 + 0.5;\n}\n\n#define LOGI(x) (log((x)/DX) / log(.11/DX/DX))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 col = fft(mod(uv - .5, 1.));\n    \n    // four value display modes:\n    //fragColor = vec4(col * .5 + .5, 0., 1.); // display in red/green for real/imagine compoments\n    //fragColor = 4. * vec4(vec3(length(col)), 1.); // display in the magnitude of complex value\n    fragColor = 2. * vec4(vec3(LOGI(length(col))), 1.); // same as above, but log is taken\n    //fragColor = vec4(rainbow(atan(col.y, col.x) / (TAU * .5) + .5), 1.); // display in the phase of complex value\n    \n    fragColor.rg = texture(iChannel2, uv).rg; // display the original data\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU (8.*atan(1.))\n\nvec2 stepsm(float edgcent, vec2 x)\n{\n    return smoothstep(edgcent * 0., edgcent * .4, x) *\n           (1. - smoothstep(edgcent * .6, edgcent * 1., x));\n}\n\nfloat sinc(float x)\n{\n    return (x == 0.0) ? 1.0 : sin(x)/x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float alpha = .3 * (uv.x * iMouse.x + uv.y * iMouse.y) + iTime * 10.;\n    vec2 alphav = vec2(alpha, alpha + TAU * .25);\n    \n#if 0 /* also set this to 1! */\n    // four wave modes, uncomment to use it as a origin data.\n    // move mouse around to change the wave frequency on both directions.\n    vec2 col = cos(alphav);\n    //vec2 col = vec2(sinc(60. * length(uv.xy - iMouse.xy / iResolution.xy)), 0);\n    //vec2 col = -1. + 2. * step(TAU * .5, mod(alphav, TAU));\n    //vec2 col = -.5 + 2. * stepsm(TAU * .5, mod(alphav, TAU));\n    //uv -= iMouse.xy/iResolution.xy; vec2 col = vec2(6., 0.) * smoothstep(0., 1., .7 - mod(4. * length(uv), 1.));\n    col = .5 + .5 * col;\n#else\n    vec2 col = vec2(texture(iChannel0, uv).rg);\n#endif\n    \n    fragColor = vec4(col, 0., 1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 fft(vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 col = .5 * fft(uv) + .5;\n    fragColor = vec4(col, 0, 1.);\n}\n\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n#define TAU (8.*atan(1.))\n#define DX .003\n\nvec2 fft(vec2 uv)\n{\n    vec2 complex = vec2(0,0);\n    \n    for(float x = 0.; x < 1.; x += DX)\n    {\n        float a = TAU * uv.x * x / DX;\n        vec2 pos = mod(vec2(x, uv.y), 1.);\n        vec2 samp = texture(iChannel0, pos).xy - .5;\n        complex += cmul(samp, vec2(cos(a), sin(a)));\n    }\n    \n    return complex * DX;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 fft(vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 col = .5 * fft(uv) + .5;\n    fragColor = vec4(col, 0, 1.);\n}\n\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n#define TAU (8.*atan(1.))\n#define DX .003\n\nvec2 fft(vec2 uv)\n{\n    vec2 complex = vec2(0,0);\n    \n    for(float y = 0.; y < 1.; y += DX)\n    {\n        float a = TAU * uv.y * y / DX;\n        vec2 pos = mod(vec2(uv.x, y), 1.);\n        vec2 samp = texture(iChannel0, pos).xy - .5;\n        complex += cmul(samp, vec2(cos(a), sin(a)));\n    }\n    \n    return complex * DX;\n}","name":"Buf C","description":"","type":"buffer"}]}