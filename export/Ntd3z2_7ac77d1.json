{"ver":"0.1","info":{"id":"Ntd3z2","date":"1706564332","viewed":132,"name":"IK Chain 2D","username":"spalmer","description":"golfing and simplifying ruojake's Wowie! inverse kinematics toy.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","ik","inversekinematics","joints"],"hasliked":0,"parentid":"stdGDN","parentname":"Wowie!"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just a fork of ruojake's cute toy,\n// but removed all the cuteness\n// so as to expose the core algorithm.\n\n// Wowie! by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0  https://creativecommons.org/licenses/by-sa/4.0/\n\nconst int nArm = 3; //2; //6; //\n\nstruct Seg\n{\n    vec2 p0, p1;\n    float len, r, c;\n};\n\nvoid solveIK(vec2 root, vec2 target, inout Seg segs[nArm], float relax)\n{\n    for (int i = nArm; i-- > 0; ) {\n        Seg si = segs[i];\n        si.p1 = mix(target, si.p1, relax);\n        si.p0 = si.p1 + normalize(si.p0 - si.p1) * si.len;\n        target = si.p0;\n        segs[i] = si;\n    }\n    \n    vec2 dir = normalize(segs[0].p1 - segs[0].p0);\n    \n    for (int i = 0; i < nArm; ++i) {\n        Seg si = segs[i];\n        si.p0 = root;\n        \n        vec2 newDir = normalize(si.p1 - si.p0);\n        float t = dot(dir, newDir) * -.5 + .5;\n        //t = mix(t, 1., relax);\n        t *= si.c;\n        \n        newDir = normalize(mix(newDir, dir, t));\n        \n        si.p1 = si.p0 + newDir * si.len;\n        \n        dir = newDir;\n        root = si.p1;\n        segs[i] = si;\n    }\n}\n\n\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a;\n    return length(p - clamp(dot(p, b) / dot(b, b), 0., 1.) * b);\n}\n\nfloat aa(float x)\n{\n    return clamp(.5 - .5 * x / fwidth(x), 0., 1.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy,\n        q = (p - r * .5) / r.y;\n\n    Seg segs[nArm] = Seg[]\n    (\n        Seg(vec2(0, -.45),  vec2(-.2,-.45), .1, .025, .1),\n        Seg(vec2(-.2,-.45), vec2(-.35, -.3), .2, .015, .04),\n        Seg(vec2(-.35,-.3), vec2(-.37, -.3), .02, .02, .0)\n    );\n    \n    for (int i = nArm; i-- > 1; segs[i-1].p1 = segs[i].p0);\n    float totalLen = 0.;\n    for (int i = nArm; i-- > 0; totalLen += (segs[i].len = distance(segs[i].p0, segs[i].p1)));\n\n    vec2 target = vec2(sin(iTime), sin(iTime * 1.331)) * .4,\n        root = segs[0].p0; //vec2(0,-.5);\n        \n        if (iMouse.z > 0.) target = (iMouse.xy - r * .5) / r.y;\n        \n    float relax = clamp(1. - 1.4*totalLen / (0.01 + distance(root, target)), 0.0, 1.0);\n    \n    // TODO some anticipation of the target, perhaps?\n    // lack of prior frame state is a real problem!\n    // perhaps go ahead and use BufferA to hold state?\n    // real IK needs prior state or it will always be\n    // jerky and weird.\n\n    solveIK(root, target, segs, relax);\n    // again to smooth out kinks that happen first time   :(\n    // even that's insufficient.\n    //solveIK(root, target, segs, .8 * relax);\n\n    float d = 9e9; // distance to segs\n    for (int i = 0; i < nArm; ++i)\n        d = min(d, dseg(q, segs[i].p0, segs[i].p1) - segs[i].r);\n    // distance to ball\n    float b = length(q - target) - .04;\n    \n    vec3 c = vec3(.1,.05,.01); // bg color   \n    c = mix(c, vec3(.6,.45,0), aa(d)); // draw\n    c = mix(c, vec3( 1,.4,.8), aa(b));\n    \n    o = vec4(sqrt(c), 1); // gamma\n}","name":"Image","description":"","type":"image"}]}