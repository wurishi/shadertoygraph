{"ver":"0.1","info":{"id":"tssSzM","date":"1551015781","viewed":2021,"name":"Old CRT screen emulation","username":"Lovax","description":"SacrÃ© Jean-Claude","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing","crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Post-processing shader aiming to emulate old CRT screens\n// The goal wasn't to be as realistic as possible but to\n// simply have a good-looking shader which is optimised for SPEED\n\n// MIT License (c) do whatever you want with this shit\n\n#define PI 3.14159265359\n\n// Emulated CRT resolution\n#define FAKE_RES (iResolution.xy/6.0)\n\n// ------ PARAMETERS ------\nvec2 fishEye = vec2(-0.03,-0.05); // Fish-eye warp factor\nfloat crtOutIntensity = 1.1; // intensity of crt cell outline\nfloat crtInIntensity = 0.9; // intensity of crt cell inside\nfloat scanIntensity = 1.1; // intensity of scanlines\nfloat aberrationIntensity = 1.5; // Intensity of chromatic aberration\nint monochromeAberrations = 0;\nfloat grainIntensity = 0.3; // Intensity of film grain\nfloat haloRadius = 1.8; // Radius of the ellipsis halo\nfloat blurIntensity = 0.4; // Intensity of the radial blur\nfloat scratchesIntensity = 3.; // Intensity of screen scratches\n// ------------------------\n\n\nvec3 surface(vec2 uv) {\n\treturn texture(iChannel0, uv).rgb;\n}\n\n// Fish-eye effect\nvec2 fisheye(vec2 uv){\n  uv = uv*2.0 - 1.0;    \n  uv *= vec2(1.0+(uv.y*uv.y)*fishEye.x,1.0+(uv.x*uv.x)*fishEye.y);\n  return uv*0.5 + 0.5;\n}\n\n// Scanlines chromatic aberration\nvec3 aberration(vec2 uv) {\n    float o = sin(uv.y * iResolution.x * PI);\n    o *= aberrationIntensity / iResolution.x;\n    vec3 newVec = vec3(surface(vec2( uv.x+o, uv.y+o )).x, surface(vec2( uv.x, uv.y+o )).y, surface(vec2( uv.x+o, uv.y )).z);\n    if (monochromeAberrations > 0) {\n        newVec = newVec / 3.0\n            + vec3(surface(vec2( uv.x, uv.y+o )).x, surface(vec2( uv.x+o, uv.y+o )).y, surface(vec2( uv.x+o, uv.y )).z) / 3.0\n            + vec3(surface(vec2( uv.x+o, uv.y )).x, surface(vec2( uv.x+o, uv.y )).y, surface(vec2( uv.x+o, uv.y+o )).z) / 3.0;\n    }\n    return newVec;\n}\n\n// Draw smoothed scanlines\nfloat scanLines(vec2 uv){\n  float dy = uv.y * FAKE_RES.y;\n  dy = fract(dy) - 0.5;\n  return exp2(-dy*dy*scanIntensity);\n}\n\n// CRT cells\nvec3 crt(vec2 xy){\n  xy=floor(xy*vec2(1.0,0.5));\n  xy.x += xy.y*3.0;\n  vec3 c = vec3(crtOutIntensity,crtOutIntensity,crtOutIntensity);\n  xy.x = fract(xy.x/6.0);\n    \n  if(xy.x < 0.333)\n      c.r=crtInIntensity;\n  else if(xy.x < 0.666)\n      c.g=crtInIntensity;\n  else \n      c.b=crtInIntensity;\n  return c;\n}    \n\n// from rez in Glenz vector form Hell\nfloat rand(in vec2 p,in float t) {\n\treturn fract(sin(dot(p+mod(t,1.0),vec2(12.9898,78.2333)))*43758.5453);\n}\n\n// Film grain\nfloat grain(vec2 uv) {\n    return 1.0-grainIntensity+grainIntensity*rand(uv,iTime);\n}\n\n// Halo\nfloat halo(vec2 uv) {    \n    return haloRadius-distance(uv,vec2(0.2,0.5))-distance(uv,vec2(0.8,0.5));\n}\n\n// Screen scratches\nvec3 screenshit(vec2 uv) {\n\tfloat c = 0.5*texture(iChannel1,uv).r + 0.3*texture(iChannel1,uv*5.0).r + 0.2*texture(iChannel1,uv/2.0).r;\n    c = (max(c, 0.78)-0.78)*scratchesIntensity;\n    return vec3(smoothstep(0.,1.,c));\n}\n\n// Radial blur\nvec3 blur(vec2 uv) {\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec2 d = (vec2(0.5,0.5)-uv)/32.;\n    float w = 1.0;\n    vec2 s = uv;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 res = surface(vec2(s.x,s.y));\n        col += w*smoothstep( 0.0, 1.0, res );\n        w *= .985;\n        s += d;\n    }\n    col = col * 4.5 / 32.;\n\treturn blurIntensity*vec3( 0.2*col + 0.8*surface(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fisheye(fragCoord/iResolution.xy);\n    fragColor.rgb = aberration(uv) + screenshit(uv) + blur(uv);\n    fragColor.rgb *= scanLines(uv) * crt(fragCoord) * grain(uv) * halo(uv) * 0.6;\n}\n\n","name":"Image","description":"","type":"image"}]}