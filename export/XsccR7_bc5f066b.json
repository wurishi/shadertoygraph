{"ver":"0.1","info":{"id":"XsccR7","date":"1518133847","viewed":431,"name":"bubbling beaker gif recreation","username":"wpchop","description":"An attempt to recreate this gif: https://giphy.com/gifs/reaction-chemical-loading-icon-B17JxNP2XT3kA\n","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bubbles","chemical","flask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst vec3 L_BLUE = vec3(113.0/255.0,236.0/255.0,254.0/255.0);\nconst vec3 D_BLUE = vec3(41.0/255.0,172.0/255.0,253.0/255.0);\nconst vec3 TEAL = vec3(79.0/255.0,137.0/255.0, 148.0/255.0);\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// a is starting position, b is ending, r is radius\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat blackBeaker(vec3 samplePoint) {\n\n    float triangle = sdTriPrism(samplePoint, vec2(0.38,0.1));\n   \tfloat rectangle = udBox(samplePoint, vec3(0.12, 0.35, 0.1));\n    float triBB = udBox(samplePoint, vec3(1.0,0.35,0.1));\n    triangle = opI(triangle, triBB);\n                                \n    // bottom of beaker                        \n    float capsule1 = sdCapsule(samplePoint, vec3(-0.25, -0.25, 0.0), vec3(0.25, -0.25, 0.0),0.1);\n    // top of beaker\n    float capsule2 = sdCapsule(samplePoint, vec3(- 0.14, 0.33, 0.0), vec3(0.14, 0.33, 0.0), 0.025);\n    float body = opU(opU(triangle, capsule1), capsule2);\n    \n    float beaker = opU(rectangle, body);\n    \n    return beaker;\n}\n\n\nfloat liquid(vec3 samplePoint) {\n    float time1 = sin(2.5 * iTime);\n    float time2 = cos(4.0 * iTime + 1.0);\n    float time3 = cos(3.5 * iTime);\n    float time4 = sin(4.3 * iTime);\n   \n    vec3 spPoint = samplePoint;\n    \n    samplePoint = samplePoint/0.75 + vec3(0.0,0.02,0.0);\n    float triangle = sdTriPrism(samplePoint, vec2(0.38,0.1));\n    \n    // top of water\n    float triBB = udBox(samplePoint + vec3(0.0,0.16,0.0), vec3(1.0,0.15,0.1));\n    vec3 wHeight = vec3(0.0,0.05,0.0);\n    float wave1 = sdSphere(samplePoint + wHeight + vec3(0.15,0.0,0.0) * time1\n                           -vec3(0.01,0.07,0.0) * time4, 0.08);\n    float wave2 = sdSphere(samplePoint - vec3(0.0, 0.1, 0.0) * time2  + \n        \t\t\t\t\tvec3(0.1,0.0,0.0) * time1 , 0.06) ;\n    float wave3 = sdSphere(samplePoint + wHeight + vec3(0.1,0.02,0.0) * time3, 0.09);\n    float smoo = smin(wave1, triBB, 0.1);\n    float smooth2 = smin(wave2, triBB, 0.1);\n    float smooth3 = smin(wave3, triBB, 0.1);\n    float smooth4 = smin(smooth3, smoo,0.1);\n    \n    triBB = opU(opU(opU(triBB, smooth4), smooth2), smooth3);\n        \n    // cut off triangle    \n    triangle = opI(triangle, triBB);\n    \n    float capsule1 = sdCapsule(samplePoint, vec3(-0.25, -0.25, 0.0), vec3(0.25, -0.25, 0.0),0.1);\n\tfloat body = opU(triangle, capsule1);\n    \n    // making bubbles\n    float time = mod(iTime, 2.3);\n    spPoint += vec3(0.0,-0.5,0.0) * time;\n    float sphere = sdSphere(spPoint, 0.045);\n    \n    \n    body *=0.75;\n    float flask = opU(body, sphere);\n    //flask = opU(flask, wave1);\n    return flask;    \n}\n\nfloat darkLiquid(vec3 samplePoint) {\n    float time = sin(iTime) - 0.8;\n    float time1 = cos(2.5 * iTime);\n    float time2 = sin(1.0 * iTime - 2.0);\n    float time3 = sin(4.5 * iTime);\n    float time4 = cos(2.3 * iTime);\n\n    vec3 spPoint = samplePoint;\n    \n    samplePoint = samplePoint/0.75 + vec3(0.0,0.02,0.0);\n    float triangle = sdTriPrism(samplePoint, vec2(0.38,0.1));\n    \n    // top of water\n    float triBB = udBox(samplePoint + vec3(0.0,0.13,0.0), vec3(1.0,0.15,0.1));\n    vec3 wHeight = vec3(0.0,0.02,0.0);\n    float wave1 = sdSphere(samplePoint + wHeight + vec3(0.15,0.0,0.0) * time1\n                           -vec3(0.01,0.07,0.0) * time4, 0.08);\n    float wave2 = sdSphere(samplePoint - vec3(0.0, 0.1, 0.0) * time2  + \n        \t\t\t\t\tvec3(0.1,0.0,0.0) * time1 , 0.06) ;\n    float wave3 = sdSphere(samplePoint + wHeight + vec3(0.1,0.02,0.0) * time3, 0.09);\n    float smoo = smin(wave1, triBB, 0.1);\n    float smooth2 = smin(wave2, triBB, 0.1);\n    float smooth3 = smin(wave3, triBB, 0.1);\n    float smooth4 = smin(smooth3, smoo,0.1);\n    \n    triBB = opU(opU(opU(triBB, smooth4), smooth2), smooth3);\n        \n    // cut off triangle    \n    triangle = opI(triangle, triBB);\n    \n    float capsule1 = sdCapsule(samplePoint, vec3(-0.25, -0.25, 0.0), vec3(0.25, -0.25, 0.0),0.1);\n\tfloat body = opU(triangle, capsule1);\n    \n    // rescale\n    body *=0.75;\n    \n    // making bubbles\n    spPoint += vec3(0.05,0.0,0.0) * time2;\n    float sphere = sdSphere(spPoint + vec3(0.0,-0.2,0.0) * 1.8 * mod(iTime, 2.0), 0.03);\n    \n    body = opU(body, sphere);\n    return body;   \n}\n\nfloat lightBubbles(vec3 samplePoint) {\n    float time = mod(iTime, 3.2);\n    float time2 = mod(iTime, 1.8);\n    float time3 = mod(iTime, 4.0);\n    \n    vec3 place = vec3(0.0, 0.2, 0.0);\n    vec3 place2 = vec3(0.05,0.2,0.0);\n    vec3 place3 = vec3(-0.07,0.15,0.0);\n    vec3 dir = vec3(0.0,-0.4, 0.0) * time;\n    float sphere = sdSphere(samplePoint + place2 + dir, 0.03);\n    float sphere2 = sdSphere(samplePoint + place + dir * 0.7, 0.02);\n    float sphere3 = sdSphere(samplePoint + place3 + dir * 0.4, 0.025);\n    \n    float light = opU(opU(sphere, sphere2), sphere3);\n    \n    vec3 p = vec3(0.1, 0.2, 0.0);\n    vec3 p2 = vec3(0.02,0.23,0.0);\n    vec3 p3 = vec3(-0.1,0.22,0.0);\n    vec3 d = vec3(0.0,-0.5, 0.0) * time2;\n    vec3 d1 = vec3(0.0,-0.4,0.0) * time3;\n    float s = sdSphere(samplePoint + p + d* 0.2, 0.03);\n    float s2 = sdSphere(samplePoint + p2+ d1 * 0.3, 0.02);\n    float s3 = sdSphere(samplePoint + p3 + d * 0.25 + d1 * 0.1, 0.025);\n    float bottom = opU(opU(s, s2), s3);\n\n   \treturn opU(light, bottom);\n    \n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n \tfloat beaker = blackBeaker(samplePoint);\n    float liquid = liquid(samplePoint + vec3(0.0,0.0,-8.0));\n    float darkLiquid = darkLiquid(samplePoint + vec3(0.0,0.0,-5.0));\n    float lightBubbles = lightBubbles(samplePoint + vec3(0.0,0.0,-10.0));\n                                      \n    return opU(opU(opU(beaker, liquid), darkLiquid), lightBubbles);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start,\n                                float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 samplePt = vec3(eye + depth * marchingDirection);\n        float dist = sceneSDF(samplePt);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    \n    \n    // Transform to NDC\n    vec2 srcPt = uv * 2.0 - 1.0; \n    float sx = srcPt.x;\n\tfloat sy = srcPt.y;\n    srcPt.x *= aspect;\n    \n    ////////////////////// Camera stuff\n    // camera position\n\tvec3 c_pos = vec3(0.0, 0.0, 15.0);\n    // camera target\n    vec3 c_targ = vec3(0.0, 0.0, 0.0);\n    // camera direction\n    vec3 c_dir = normalize(c_targ - c_pos);\n    // camera right\n    vec3 c_right = vec3(1.0,0.0,0.0);\n    // camera up\n    vec3 c_up = cross( c_right, c_dir);\n    \n    // compute the ray direction\n    vec3 r_dir = normalize(c_dir);\n\n    // THE CAMERA EYE\n    vec3 eye = c_pos + c_right * sx * aspect + c_up * sy;\n        \n   \tfloat dist = shortestDistanceToSurface(eye, r_dir, MIN_DIST, MAX_DIST); \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(1.0);\n        return;\n    }\n    if (dist > 13.0) {\n        fragColor = vec4(0.2,0.2,0.2,1.0);\n        return;\n    } else if (dist > 7.0) {\n        // darker liquid\n     \tfragColor = vec4(TEAL, 1.0);\n        return;\n    } else if (dist > 6.5) {\n         // transform y coordinate for blue gradient\n    \tfloat yCoord = (uv.y - 0.36)/ 0.14;\n    \n    \tvec3 color = yCoord * L_BLUE + (1.0 - yCoord) * D_BLUE;\n    \tfragColor = vec4(color, 1.0);  \n        return;\n    }\n    \n    // water inside\n    float liquidTop = 0.36;\n    float liquidBottom = 0.51;\n    \n    // transform y coordinate for blue gradient\n    float yCoord = (uv.y - 0.36)/ 0.14;\n    \n    vec3 color = yCoord * L_BLUE + (1.0 - yCoord) * D_BLUE;\n    //fragColor = vec4(color, 1.0);    \n    fragColor = vec4(L_BLUE, 1.0);\n    \n   \n}","name":"Image","description":"","type":"image"}]}