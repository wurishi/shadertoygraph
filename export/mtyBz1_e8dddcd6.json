{"ver":"0.1","info":{"id":"mtyBz1","date":"1702682514","viewed":73,"name":"Extraterrestrial Sundial","username":"gunthern","description":"Sundial from another world.\n\nSorry for the low framerate, I really like the refraction but it can be disabled in Buffer A by commenting out #define REFRACTION. You can also disable all the light reflection and refraction by changing NUM_BOUNCES to 0.","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["raymarched","sundial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv1 = (fragCoord+vec2(1,0))/iResolution.xy;\n    vec2 uv2 = (fragCoord+vec2(0,1))/iResolution.xy;\n    vec2 uv3 = (fragCoord+vec2(-1,0))/iResolution.xy;\n    vec2 uv4 = (fragCoord+vec2(0,-1))/iResolution.xy;\n    \n    // Quick and very dirty AA using buffer sampling\n    vec4 AA0 = texture(iChannel0, uv0, 0.0);\n    vec4 AA1 = texture(iChannel0, uv1, 0.0);\n    vec4 AA2 = texture(iChannel0, uv2, 0.0);\n    vec4 AA3 = texture(iChannel0, uv3, 0.0);\n    vec4 AA4 = texture(iChannel0, uv4, 0.0);\n    \n    fragColor = (AA0 + AA1 + AA2 + AA3 + AA4) / 5.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define  MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n#define NUM_BOUNCES 1\n#define REFRACTION\n#define EPSILON 0.0001\n#define SPEED iTime*0.33\n\n// Some nice moments\n//#define iTime 3.75\n//#define iTime 14.4\n//#define iTime 54.5\n//#define iTime 60.25\n//#define iTime 281.0\n\n// Surface constructor\nstruct Surface {\n\n    float dist;\n    vec3 col;\n    float spec;\n    vec3 refl;\n    vec3 refr;\n    vec3 emissive;\n    \n};\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Smooth min\nSurface smin(Surface a, Surface b, float k) {\n    \n    float h = clamp(0.5 + 0.5*(b.dist - a.dist)/k, 0.0, 1.0);\n\n    float d = mix(b.dist, a.dist, h) - k*h*(1.0-h);\n    \n    return Surface(\n        d,\n        mix(b.col, a.col, h),\n        mix(b.spec, a.spec, h),\n        mix(b.refl, a.refl, h),\n        mix(b.refr, a.refr, h),\n        mix(b.emissive, a.emissive, h)\n    );\n    \n}\n\n// Radial UV from https://www.shadertoy.com/view/XdXXzf\nvec2 radialUV(in vec2 uv)\n{\n    vec2 rUV = vec2(0.0);\n    rUV.x = atan(uv.x, uv.y) * 0.159 + 0.5;\n    rUV.y = length(uv) * 0.6;\n    \n    return rUV * 2.0;\n}\n\n// Displacement\nfloat displace(in vec3 p, in float d)\n{\n    float d1 = sin(0.9*p.x) * sin(0.7*p.y) * sin(0.5*p.z);\n    return d + d1;\n}\n\n// 2D Rounded Box SDF\nfloat sdRoundedBox(in vec2 p, in vec2 b, in vec4 r)\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// Sphere SDF\nfloat sdSphere(vec3 p, float r, vec3 c) {\n    \n    return length(p-c.xyz)-r;\n    \n}\n\n// Pyramid SDF\nSurface sdPyramid(vec3 p, float h, vec3 col, float spec, vec3 refl, vec3 refr, vec3 emissive)\n{\n\n    float m2 = h*h + 0.25;\n    \n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    float dist = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    \n    return Surface(dist, col, spec, refl, refr, emissive);\n}\n\n// Plane SDF\nSurface sdPlane(vec3 p, vec3 col, float spec, vec3 refl, vec3 refr, vec3 emissive) {\n\n    float planeDistance = p.y;\n    \n    return Surface(planeDistance, col, spec, refl, refr, emissive);\n\n}\n\n// Scene\nSurface GetDistColor(vec3 p, vec3 rd) {\n    \n    // \"Alien\" characters mapped radially around sundial\n    vec2 rUV = radialUV(p.xz);\n    float planeTextCol = texture(iChannel0, rUV).r;\n    // Restrict texture space\n    float planeTextEmit = \n        planeTextCol * max((1.0 - (length(p) - 2.2)) * clamp(length(p) - 2.0, 0.0, 1.0), 0.0);\n        planeTextCol*= max((1.0 - (length(p) - 2.5)) * clamp(length(p) - 1.5, 0.0, 1.0), 0.0);\n    // Add slight glow to text\n    float planeTextGlow = clamp((1.0 - (length(p) - 2.2)) * clamp(length(p) - 1.75, 0.0, 1.0), 0.0, 0.3);\n    planeTextEmit += planeTextGlow;\n    // Fade texture radially with sundial shadow\n    float timeMod = (SPEED*(1.0/3.14159) + rUV.x + 1.0);\n    float planeTextFade = abs(mod(timeMod * -1.0, 2.0));// * sin(timeMod * 1.5708)) * 2.0;\n    planeTextCol *= planeTextFade;\n    planeTextEmit *= planeTextFade;\n    \n    // Add \"cursor\" to start of character sweep\n    float planeTextCursor = floor(mod(timeMod * -1.0, 2.0) * 0.501) * 10.0 \n        * max((1.0 - (length(p) - 2.2)) * clamp(length(p) - 1.7, 0.0, 1.0), 0.0);\n        \n    planeTextCol += planeTextCursor;\n    planeTextEmit += planeTextCursor;\n    // Pyramid rotation (also used for glow)\n    vec3 pyramidRot = p * rotateY(iTime * 0.1);\n    // Add \"glow\" from pyramid\n    float planeGlow = \n        pow(1.0 - clamp(\n            sdRoundedBox(\n                pyramidRot.xz,\n                vec2(0.7) + sin(iTime)*0.05 + cos(iTime*1.6)*0.08,\n                vec4(-2.0)),\n        0.0, 1.0), 1.3);\n    \n    float planeColDistFade = (smoothstep(1.0 - (length(p) - 90.0), 1.0 - (length(p) - 20.0), 12.0));\n    vec3 planeCol =\n        max(\n        // Text\n        vec3(planeTextCol)*vec3(0.3, 1.0, 0.8)\n        // Glow\n        + planeGlow * vec3(1.0, 1.0, 0.0)\n        // Blue\n        , vec3(0.3, 0.5, 0.7)) * planeColDistFade\n        // Gray\n        + (1.0 - planeColDistFade) *\n        vec3(0.1, 0.12, 0.1);\n    vec3 planeEmit = \n        // Text\n        planeTextEmit * vec3(0.2, 0.5, 1.0)\n        // Glow\n        + planeGlow * vec3(1.0, 0.0, 0.0);\n    \n    // Plane surface\n    Surface plane = \n        sdPlane(p, planeCol, 8.0, vec3(0.02), vec3(0.0), planeEmit);\n    // Slight warp to plane surface\n    plane.dist += (sin(p.x * 8.0) + sin(p.z * 9.0)) * 0.0002;\n    // Plane background displacement\n    plane.dist -= \n        texture(iChannel2, (p.xz+iTime*0.75) * 0.01).r\n        * (smoothstep(length(p) - 20.0, length(p) - 60.0, 12.0)) * 10.0\n        * (smoothstep(length(p) - 90.0, length(p) - 80.0, 12.0));\n    \n    // Pyramid surface\n    Surface pyramid = \n        sdPyramid(\n            pyramidRot, // Rotating pyramid space\n            1.0, // Height\n            vec3(1.0, 1.0, 0.0), // Color\n            1.0, // Specularity\n            vec3(0.55), // Reflection\n            vec3(0.0), // Refraction\n            vec3(1.0, 0.0, 0.0) // Emission\n        ); \n    \n    // Bubble surfaces\n    vec3 bubbleCol = vec3(0.2, 0.33, 0.5);\n    vec3 bubbleRefl = vec3(0.2, 0.2, 0.33);\n    vec3 bubbleRefr = vec3(0.8, 1.0, 0.6);\n    \n    float bubble00 = \n        sdSphere(p, 0.5, vec3(-1.7, min(tan(iTime*0.3) - 0.6, 100.0), 0.0)); \n    bubble00 = displace(p + cos(iTime*0.4), bubble00);\n    \n    float bubble01 = \n        sdSphere(p, 0.65, vec3(1.4, min(tan(iTime*0.25 - 3.2) - 0.6, 100.0), 1.0)); \n    bubble01 = displace(p + cos(iTime*0.3), bubble01);\n    \n    float bubble02 = \n        sdSphere(p, 0.35, vec3(0.0, min(tan(iTime*0.15 - 8.0) - 0.6, 100.0), -3.8)); \n    bubble02 = displace(p + cos(iTime*0.666), bubble02);\n    \n    // Combine bubbles\n    Surface bubbles = \n    Surface(min(min(bubble00, bubble01), bubble02),\n        bubbleCol, 8.0, bubbleRefl, bubbleRefr, vec3(0.0));\n    \n    // Combine bubbles with plane, pyramid\n    return smin(smin(plane, pyramid, 0.01), bubbles, 1.5);\n}\n\nSurface RayMarch(vec3 ro, vec3 rd, float side){\n\n    float dO = 0.0;\n    Surface distColor;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        distColor = GetDistColor(p, rd);\n        distColor.dist *= side;\n        float dS = distColor.dist;\n        \n        dO += dS;\n        if (dO > MAX_DIST) break;\n    }\n    \n    vec3 col = distColor.col; \n    float spec = distColor.spec;\n    vec3 refl = distColor.refl;\n    vec3 refr = distColor.refr;\n    vec3 emissive = distColor.emissive;\n    \n    return Surface(dO, col, spec, refl, refr, emissive);\n}\n\nvec3 GetNormal(vec3 p, vec3 rd) {\n    float d = GetDistColor(p, rd).dist;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistColor(p-e.xyy, rd).dist,\n        GetDistColor(p-e.yxy, rd).dist,\n        GetDistColor(p-e.yyx, rd).dist);\n        \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 GetLight(vec3 p, vec3 c, vec3 lp, vec3 rd) {\n    vec3 l = normalize(lp - p);\n    vec3 n = GetNormal(p, rd); \n    \n    float diff = dot(n, l);\n    float d = RayMarch(p + n*SURFACE_DIST*3.0, l, 1.0).dist;\n    if (d<length(lp-p) && d>0.01) diff *= 0.01;\n    \n    return diff * c;\n}\n\nvec3 GetSpecular(vec3 p, vec3 c, vec3 lp, vec3 ro, float sp, vec3 rd) {\n    \n    vec3 l = normalize(lp - p);\n    vec3 h = normalize(l + normalize(ro - p));\n    vec3 n = GetNormal(p, rd);\n    \n    return c * pow(max(0.0, dot(n, h)), sp);\n}\n\nvec3 Render(\n        inout vec3 ro,\n        inout vec3 rd,\n        inout vec3 bounce,\n        bool doRefl,\n        bool doRefr,\n        bool last\n    ) {\n\n    vec3 col = vec3(0.0);\n    float spec = 0.0;\n    vec3 emissive = vec3(0.0);\n    bounce = vec3(0.0);\n    \n    // Main light color\n    vec3 lc = \n        vec3(\n            0.1 + 0.5 * (cos(SPEED) + 1.0)*0.75,\n            0.2 + 0.25* (cos(SPEED) + 1.0)*0.75,\n            0.2 + 0.5 * (sin(SPEED) + 1.0)*0.75);\n    \n    // Raymarch and get color\n    Surface rs = RayMarch(ro, rd, 1.0);\n    float d = rs.dist;\n    \n    // Reflection texture mult\n    float cubeMapIntensity = ((sin(SPEED) + 1.0) * 0.1);\n    \n    // ior\n    float ior = 1.04;\n    \n    if (d < MAX_DIST) {\n    \n        col = rs.col;\n        spec = rs.spec;\n        emissive = rs.emissive;\n\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p, rd);\n        \n        // Reflection\n        if (doRefl && length(rs.refl) > EPSILON) {\n            vec3 reflection = reflect(rd, n);\n            rd = reflection;\n        \n            ro = p + n*SURFACE_DIST*3.0;\n            float fresnel = pow(1.0 - dot(n, -rd), 2.0);\n            bounce = clamp(rs.refl + fresnel*rs.refl, 0.0, 1.0);\n        }\n        \n        // Refraction\n        if (doRefr && length(rs.refr) > EPSILON) {\n            vec3 rdIn = refract(rd, n, 1.0/ior);\n            \n            vec3 roIn = p - n*SURFACE_DIST*30.0;\n            float dIn = RayMarch(roIn, rdIn, -1.0).dist;\n            \n            vec3 roOut = roIn + rdIn * dIn;\n            vec3 nOut = -GetNormal(roOut, rdIn);\n            \n            vec3 rdOut = refract(rdIn, nOut, ior);\n            if(dot(rdOut, rdOut)<EPSILON) rdOut = reflect(rdIn, nOut);\n            \n            ro = roOut - nOut*SURFACE_DIST*3.0;\n            rd = rdOut;\n            bounce = rs.refr;\n        }\n\n        // Main light position\n        vec3 lp = vec3(30.0 * sin(SPEED), 5.0, -30.0 * cos(SPEED)) * 0.2;\n\n        // Diffuse lighting\n        vec3 l0 = GetLight(p, lc, lp, rd);\n        l0 = clamp(l0, 0.0, 1.0);\n\n        // Specular lighting\n        vec3 s0 = GetSpecular(p, lc, lp, ro, spec, rd);\n        s0 = clamp(s0, 0.0, 1.0);\n\n        vec3 lightingPass = min(l0 + s0, 1.0);\n\n        // Emissive\n        lightingPass = clamp(lightingPass + emissive, 0.04, 1.0);\n\n        // Final color\n        col = vec3(max(min(lightingPass * col, 1.0), 0.0));\n        \n        // If last bounce, reflect / refract cubemap\n        if (last) {\n            vec3 reflTex = \n                texture(iChannel1, reflect(rd, GetNormal(p, rd))).rgb * cubeMapIntensity;\n            col += reflTex * rs.refl;\n\n            vec3 refrTex = \n                texture(iChannel1, refract(rd, GetNormal(p, rd), 1.0/ior)).xyz * cubeMapIntensity;\n            col += refrTex * rs.refr;\n        }\n    \n    }\n    \n    else {\n        \n        vec3 p = (ro + rd * d);\n        vec3 n = GetNormal(p, rd);\n        \n        vec3 bgTex = \n            texture(iChannel1, reflect(rd, n*SURFACE_DIST*3.0)).rgb * cubeMapIntensity;\n        bgTex = bgTex*0.5 + bgTex*lc*0.5;\n        col += bgTex;\n        \n    }\n    \n    //col = vec3(spec * 0.1);\n    //col = vec3(bounce);\n    //col = emissive;\n    \n    return col;\n    \n}\n\n// Mouse rotation from the Art of Code https://www.shadertoy.com/view/sdsXWr\nmat2 mouseRot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Ray origin and mouse rotation\n    vec2 m = iMouse.xy/iResolution.xy - 0.5;\n    vec3 ro = vec3(0.0, 1.0, -5.0);\n    if (iMouse.z > 0.0) {\n        ro.yz *= mouseRot(-m.y*3.14 + 1.2);\n        ro.xz *= mouseRot(-m.x*6.2831);\n        ro.y = max(ro.y, 1.0);\n    }\n    \n    // Ray direction\n    vec3 rd = GetRayDir(uv, ro, vec3(0.0, 0.5, 0.0), 1.0);\n    \n    // Color, reflection, refraction\n    vec3 refl = vec3(0.0);\n    vec3 filt = vec3(1.0);\n    vec3 reflRO = ro;\n    vec3 reflRD = rd;\n    \n    vec3 col = Render(reflRO, reflRD, refl, true, false, false);\n    \n    // Reflection\n    for (int i=0; i<NUM_BOUNCES; i++) {\n        filt *= refl;\n        vec3 bounce = filt * Render(reflRO, reflRD, refl, true, false, i==NUM_BOUNCES-1);\n        col += bounce;\n    }\n    \n#if defined REFRACTION\n    vec3 refr = vec3(0.0);\n    filt = vec3(1.0);\n    vec3 refrRO = ro;\n    vec3 refrRD = rd;\n    vec3 refrCol = vec3(0.0);\n    \n    Render(refrRO, refrRD, refr, false, true, false);\n    \n    // Refraction\n    for (int i=0; i<NUM_BOUNCES; i++) {\n        filt *= refr;\n        vec3 bounce = filt * Render(refrRO, refrRD, refr, false, true, i==NUM_BOUNCES-1);\n        refrCol += bounce;\n    }\n    \n    // Add refraction in\n    col += refrCol;\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}