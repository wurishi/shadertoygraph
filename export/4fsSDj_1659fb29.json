{"ver":"0.1","info":{"id":"4fsSDj","date":"1705738816","viewed":80,"name":"NewRadarGraph","username":"w359405949","description":"a new radar graph\nbase on:\nhttps://www.shadertoy.com/view/tldGz4","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int N = 20;\nfloat a = 3.1415/ 10.;\n    \nfloat center=2.;\nfloat lim=31.;\nfloat[N] ivss;\n\nvec2[N] poly;\nvec2[N] polylines;\n    \nvec2[N] bg;\nvec2[N] raylines;\nvec2[N] bglines1;\nvec2[N] bglines2;\nvec2[N] bglines3;\n\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if ((cond.x && cond.y && cond.z) || ( !cond.x && !cond.y && !cond.z)) s *= -1.;\n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdRayLines(in vec2[N] v, in vec2 p )\n{\n    float s = 1.0;\n    for( int i=0; i < N; i++)\n    {\n        vec2 a = v[i];\n        vec2 pa = p-a, ba = -a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        s = min(length( pa - ba*h ), s);\n    }\n    return s;\n}\n\nfloat sdPolyLines(in vec2[N] v, in vec2 p )\n{\n    float s = 1.0;\n    for( int i=0; i < N; i++)\n    {\n        vec2 a = v[i];\n        vec2 b = v[(i+1) % N];\n        vec2 pa = p-a, ba = b-a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        s = min(length(pa - ba * h), s);\n    }\n    return s;\n}\n\nvoid GeneratePrimitives()\n{\n    for (int i=0;i<N;i++){\n        float fi = float(i);\n        float ivs = ivss[i] * lim;\n        \n    \tpoly[i] = vec2(sin(fi*a), cos(fi*a))/(lim+center)*(ivs+center);\n        polylines[i] = poly[i];\n        \n        bg[i] = vec2(sin(fi*a), cos(fi*a))/(lim+center)*(lim+center);    \n        raylines[i] = bg[i];\n        bglines1[i] = bg[i];\n        bglines2[i] = bg[i] * 0.666;\n        bglines3[i] = bg[i] * 0.333;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivss[0] = 0.1;\n    ivss[1] = 0.2;\n    ivss[2] = 0.3;\n    ivss[3] = 0.4;\n    ivss[4] = 0.5;\n    ivss[5] = 0.6;\n    ivss[6] = 1.0;\n    GeneratePrimitives();\n\t\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat sdf_poly = sdPoly(poly, p);\n    float sdf_polylines = sdPolyLines(polylines, p);\n    float sdf_bg = sdPoly(bg, p);\n    float sdf_raylines = sdRayLines(bg, p);\n    float sdf_bglines1 = sdPolyLines(bglines1, p);\n    float sdf_bglines2 = sdPolyLines(bglines2, p);\n    float sdf_bglines3 = sdPolyLines(bglines3, p);\n    \n    sdf_poly = smoothstep(0.02, 0.0, sdf_poly);\n    sdf_polylines = smoothstep(0., 0.02, sdf_polylines);\n    \n    sdf_bg = smoothstep(0.02, 0.0, sdf_bg);\n    sdf_raylines = smoothstep(0., 0.02, sdf_raylines);\n    sdf_bglines1 = smoothstep(0., 0.02, sdf_bglines1);\n    sdf_bglines2 = smoothstep(0., 0.02, sdf_bglines2);\n    sdf_bglines3 = smoothstep(0., 0.02, sdf_bglines3);\n    \n    vec3 color_poly = vec3(0., 1., 0.);\n    color_poly *= sdf_poly;\n    color_poly *= sdf_polylines;\n    \n    vec3 color_bg = vec3(1., .1, .1);\n    color_bg *= sdf_bg;\n    color_bg *= sdf_raylines;\n    color_bg *= sdf_bglines1;\n    color_bg *= sdf_bglines2;\n    color_bg *= sdf_bglines3;\n    \n    \n    vec3 color = vec3(0., 0., 0.);\n    color = mix(color, color_bg, sdf_bg);\n    color = mix(color, color_poly, sdf_poly * 0.9);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}