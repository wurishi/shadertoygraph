{"ver":"0.1","info":{"id":"4dScWV","date":"1493765536","viewed":170,"name":"My First Signed-Distance-Func","username":"loolo78","description":"My first \"signed-distance-function\" shader. It's a cube!\n\nThank you to http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions for teaching me.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    // Start depth\n    float depth = start;\n    // Keep looking for where the marching ray hits a surface\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        // Get the distance from marching ray point to surface of box\n        float dist = boxSDF(eye + marchingDirection * depth, vec3(0.5));\n        // If we've hit near the surface, return this distance\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        // Didn't find anything, let's go to where we found something\n        depth += dist;\n        // We're at the end, stop\n        if (depth > end)\n        {\n            return end;\n        }\n    }\n    // Ran out of steps before we hit the end, just return end\n    return end;\n}\n\n/**\n    fov:         Field of View of camera\n    screen_size: Screen size\n    fragCoord:   Screen coord of pixel\n    return:      Direction of rendering ray of the projection camera\n */\nvec3 rayDirection(float fov, vec2 screen_size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - screen_size / 2.0;\n    float z = (screen_size.y / 2.) / tan(radians(fov) / 2.);\n    return normalize(vec3(xy,-z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 march_dir = rayDirection(60., iResolution.xy, gl_FragCoord.xy);\n    float dist = shortestDistanceToSurface(\n        vec3(\n                cos(iTime) * 1.,\n                0,\n                (sin(iTime)+2.) * 2.\n            ), \n        march_dir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    fragColor = vec4(2./dist);\n}","name":"Image","description":"","type":"image"}]}