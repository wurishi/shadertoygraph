{"ver":"0.1","info":{"id":"flfXR4","date":"1626664871","viewed":131,"name":"8-ball","username":"wadetb","description":"Ask Magic 8-ball your question and let the GPU predict the answer.\n\nCLICK to activate or CLICK+DRAG to move the camera.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["8ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// 8-ball by @wadetb in 7/2021 - my first (and probably only) ShaderToy\n//\n// I wanted to create something a little different, more utilitarian, to compensate\n// for aesthetics, while getting to try the ray-marched merged analytic SDF techniques \n// made famous by @iq. Really impressed by the depth of this field and what\n// is possible with elegant math tricks - from soft shadows with penumbra to CSG and \n// smoothing. However the limitation laid out in @iq's \"Interior Distance\" article\n// seems to inhibit generalization vs. data-driven SDFs.\n//\n// Anyway, the participating media effects were a pleasure since I worked on that in games\n// way back when, but never had the budget to trace through the medium towards the light :) \n//\n// On the less pleasant side the camera controls took a shockingly long time (like, days)\n// to figure out and I had to watch a YouTube video (credited below) to remember how to \n// write a verlet integrator.\n//\n// Reference:\n// https://en.wikipedia.org/wiki/Magic_8-Ball\n//\n// Credits:\n// Many articles and videos and shaders by @iq\n// Much inspiration from @P_Malin\n// https://www.youtube.com/watch?v=Ff0jJyyiVyw by The Art of Code\n// https://www.shadertoy.com/view/4dtGD2 by @Hamneggs\n// https://www.shadertoy.com/view/wssBR8 by @suyoku\n// https://www.youtube.com/watch?v=3HjO_RGIjCU by Coding Math\n//\n\n//------------------------------------------------------------------\n//\n// Font code by @Hamneggs inspired by P_Malin\n// https://www.shadertoy.com/view/4dtGD2\n//\n\n#define _f float\nconst lowp _f CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n              CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n              CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n              CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n              CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n              CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n              CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n              CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n              CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f);\n#undef _f\n\nfloat getBit( in float map, in float index ) {\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv ) {\n    uv = (uv - pos) / size;  \n    float res = step(0.0, min(uv.x,uv.y)) - step(1.0, max(uv.x,uv.y));\n    res *= getBit( char, 4.0*floor(uv.y*5.) + floor(uv.x*4.) );\n    return clamp(res, 0., 1.);\n}\n\n//------------------------------------------------------------------\n//\n// SDFs by @iq\n// https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Xds3zN\n//\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat remap(float l, float mn, float mx, float a, float b) {\n    return mix( a, b, clamp((l-mn) / (mx-mn), 0., 1.) );\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  return dot(p,n) + h;\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvec2 opU( vec2 d1, vec2 d2 ) { return d1.x<d2.x?d1:d2; }\nvec2 opS( vec2 d1, vec2 d2 ) { return -d1.x>d2.x?vec2(-d1.x,d1.y):d2; }\nvec2 opSS( vec2 d1, vec2 d2, float k ) {\n    float h = clamp(.5 - .5*(d2.x+d1.x)/k,0.,1.);\n    return vec2(mix(d2.x, -d1.x, h) + k*h*(1.-h), d1.y); \n}\n\n#define ZERO (min(iFrame,0))\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n//------------------------------------------------------------------\n//\n// Globals\n//\n\nvec4 cm;\nvec4 p0;\nvec4 p1;\nvec4 p2;\n\n//------------------------------------------------------------------\n//\n// Shapes\n//\n\nvec2 mapDie( in vec3 pos ) {\n    vec3 op = pos;\n         //op.y -= .92 + .6*exp(-.5*pow((fract(iTime*.1)*2.-1.)*2.,4.));\n         op -= (p0.xyz+p1.xyz+p2.xyz)*.33333 - vec3(0,.2,0);\n         //op.y -= 1.52;\n\n    vec3 m = (p1.xyz+p2.xyz)*.5;\n    vec3 z = normalize(m - p0.xyz);\n    vec3 x = normalize(p2.xyz - m);\n    vec3 y = normalize(cross(x, z));\n         x = normalize(cross(z, y));\n    op *= mat3(x, y, z);\n    \n    op.z = -op.z;\n    op.yz *= r2d(PI/3.1);\n    op.xz *= r2d(-PI/4.);\n    op *= .6;\n    \n    vec2 uv = op.xz*r2d(PI/4.)*vec2(-.4,.4);\n    float c=0., cx=0., cy=-.0265;\n    #define S() cx += .003;\n    #define L(n) cx = -(.006*float(n)/2.); cy -= 0.006;\n    #define C(g) c += drawChar(g, vec2(cx,cy), vec2(.005,.005), uv); cx += .006;\n    #define D(t,c) if (now > t) { C(c) }\n\n    float now = iTime - cm.z - 15.;        \n\n    //\n    // Python snippet to produce messages:\n    //\n    \n    /*\n    s = '...'\n    print(''.join(\n    \t\t[\"L({})\".format(sum([.5 if c == ' ' else 1 for c in l])) + \n    \t\t \"\".join([\"S()\" if c == ' ' else \"C(CH_{})\".format(c) \n    \t\t \tfor c in l.upper()]) +\n    \t\t \"\\n\"\n    \t\tfor l in s.split('\\n')]))\n    */\n\n    float msg = trunc(mod(cm.w, 5.));\n    if (msg == 0.) {\n        L(5) C(CH_S) C(CH_I) C(CH_G) C(CH_N) C(CH_S)\n        L(5) C(CH_P) C(CH_O) C(CH_I) C(CH_N) C(CH_T)\n        L(5.5) C(CH_T) C(CH_O) S() C(CH_Y) C(CH_E) C(CH_S)\n    }\n    else if (msg == 1.) {\n        L(3)C(CH_H)C(CH_O)C(CH_W)\n        L(8.5)C(CH_C)C(CH_O)C(CH_U)C(CH_L)C(CH_D)S()C(CH_Y)C(CH_O)C(CH_U)\n        L(7.5)C(CH_E)C(CH_V)C(CH_E)C(CH_N)S()C(CH_A)C(CH_S)C(CH_K)\n        if (cm.z > 0.) {\n            L(10) D(0.,CH_Y) D(.2,CH_O) D(.4,CH_U) S() \n                  D(.8,CH_M) D(1.,CH_O) D(1.2,CH_N) D(1.4,CH_S) D(1.6,CH_T) D(1.8,CH_E) D(2.,CH_R)\n        }\n    }\n    else if (msg == 2.) { // from teddy\n        L(7)C(CH_A)C(CH_L)C(CH_R)C(CH_I)C(CH_G)C(CH_H)C(CH_T)\n        L(6)C(CH_B)C(CH_U)C(CH_S)C(CH_T)C(CH_E)C(CH_R)\n        L(9.5)C(CH_Y)C(CH_O)C(CH_U)S()C(CH_F)C(CH_I)C(CH_G)C(CH_U)C(CH_R)C(CH_E)\n        L(5.5)C(CH_I)C(CH_T)S()C(CH_O)C(CH_U)C(CH_T)\n    }\n    else if (msg == 3.) {\n        L(3)C(CH_A)C(CH_S)C(CH_K)\n        L(4)C(CH_Y)C(CH_O)C(CH_U)C(CH_R)\n        L(3)C(CH_M)C(CH_O)C(CH_M)\n    } else if (msg == 4.) {\n        L(2)C(CH_M)C(CH_Y)\n        L(7)C(CH_S)C(CH_O)C(CH_U)C(CH_R)C(CH_C)C(CH_E)C(CH_S)\n        L(3)C(CH_S)C(CH_A)C(CH_Y)\n        L(5)C(CH_M)C(CH_A)C(CH_Y)C(CH_B)C(CH_E)\n    }\n\n    vec2 od = vec2(sdOctahedron(op, .18)-.01, c>0. && op.y>0. ? 3.:4.);\n\n    // debug physics:\n    //od = opU(od, vec2(sdSphere(pos-p0.xyz, .02), 1.));\n    //od = opU(od, vec2(sdSphere(pos-p1.xyz, .02), 1.));\n    //od = opU(od, vec2(sdSphere(pos-p2.xyz, .02), 1.));\n    \n    return od;\n}\n\nvec2 mapBall( in vec3 pos ) {\n    vec2 uv = (pos-vec3(0,1.15,0)).xy;\n    \n    float c = 3.;\n    c = length(uv)<.62 ? 4.:c;\n    float l1 = length(uv*vec2(.8,1.)-vec2(0,.19));\n    float l2 = length(uv*vec2(.8,1.)+vec2(0,.19));\n    \n    c = l1>.12 && l1<.26 ? 3.:c;\n    c = l2>.12 && l2<.26 ? 3.:c;\n\n    vec2 os = vec2(sdSphere(pos-vec3(0,1,0), 1.03), c);\n    vec2 oc = vec2(sdSphere(pos-vec3(0,2.25,0), .56), c);\n    vec2 outer = opSS(oc, os, .05);\n\n    vec2 ic = vec2(sdCappedCylinder(pos-vec3(0,1.77,0), .5, .1)-.02, 2.);\n\n    return opU(outer, ic)*vec2(1.2,1.);\n}\n\nvec2 map( in vec3 pos ) {\n    return mapBall( pos );\n}\nvec2 mapInterior( in vec3 pos ) {\n    return mapDie( pos );\n}\n\n//------------------------------------------------------------------\n//\n// Rendering\n//\n\nvec2 raycast( in vec3 ro, in vec3 rd ) {\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 20.0;\n\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 ) {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, -1.0 );\n    }\n\n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ ) {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) ) { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\nvec2 raycastInterior( in vec3 ro, in vec3 rd ) {\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.;\n    float tmax = 20.0;\n\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 ) {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 0.0 );\n    }\n\n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ ) {\n        vec2 h = mapInterior( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) ) { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 renderInterior( in vec3 ro, in vec3 rd ) {\n    vec2 resi = raycastInterior(ro, rd);\n    float ti = resi.x;\n    float mi = resi.y;\n\n    float f = min(.45,exp(6.*-ti));\n\n    vec3 col = mi == 2. ? vec3(0.369, 0.382, 0.228) :\n               mi == 3. ? vec3(.45,.45,.45) : \n               mi == 4. ? vec3(0.398, 0.282, 0.091) : \n               vec3(0);\n         col = mix(vec3(0.1,0.1,0.7), col, f);\n\n    return col;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ ) {\n        float h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos ) {\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.22*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n    x = p + f;\n    return textureLod(iChannel0, (x+.5)/32.,0.).x;\n}\n\nfloat density( in vec3 pos ) {\n    vec3 dpos = pos*3.5;\n         dpos += vec3(1.,0,0)*iTime*.3;\n         \n    float d = 8.1;\n          d *= smoothstep(.9*(pos.y-.1), .96*(pos.y-.1), noise(dpos));\n          d = length(pos) < 2. ? d : 0.;\n          \n    return d;\n}\n\nvec3 fog( in vec3 ro, in vec3 rd, in float t, in vec3 lin ) {\n    vec3 lig = normalize( vec3(-0.5, 0.4, -0.6) );\n    vec3 pos = ro + rd*t;\n\n    float vis = 1.;\n    vec3 ins = vec3(0);\n\n    float fts = length(ro)-2. + -.1 + noise(pos*1000.)*.1;\n    for (int fti = 1; fti < 60; fti++) {\n        float ft = fts + 3.*pow(float(fti)/60.,2.);\n        if (ft>t) break;\n\n        vec3 fpos = ro + ft*rd;\n        float pft = fts + 3.*pow(float(fti-1)/60.,2.);\n        float dft = ft - pft;\n\n        float d = density(fpos);\n\n        vis *= exp(-d * dft);\n\n        if (d > 0.01) {\n            float svis = 1.;\n            for (int sti = 1; sti < 10; sti++) {\n                float pst = .01 + 2.*pow(float(sti-1)/10.,4.);\n                float st = .01 + 2.*pow(float(sti)/10.,4.);\n                vec3 spos = fpos + st*lig;\n                svis *= exp(-density(spos) * (st-pst));\n            }\n\n            float shadow = 1.;\n                  shadow *= calcSoftshadow( fpos, lig, 0.02, 2.5 );\n                  shadow *= calcAO( fpos, vec3(0,1,0) );\n                  shadow *= svis;\n\n            float cosphi = dot(lig, rd);\n            float a = 0.2;\n            float phase = (1.-a*a) / pow(abs(1.+a*a-2.*a*cosphi), 1.5) * .25*PI;\n\n            vec3 l = d*.02*vec3(1.30,1.00,0.70) * phase;\n                 l *= shadow;\n\n            ins += l * exp(-d * dft) * vis;\n        }\n    }\n    return ins + mix(.8*vec3(0.6, 0.7, 0.9), lin, vis);\n}\n\nvec3 render( in vec3 ro, in vec3 rd ) {  \n    vec2 res = raycast(ro, rd);\n  \n    vec3  col = vec3(.1, .1, .1);\n    float s = .2;\n    \n    float t = res.x;\n    float m = res.y;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = m == 0. ? vec3(0,1,0) : calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    if (m == 2.) { // 0 1 2 3 4 5 6 7 8 9 10\n        vec3 rdi = refract(rd, nor, 1./1.333); // https://en.wikipedia.org/wiki/List_of_refractive_indices\n        if (dot(rdi, rdi) > 0.) {\n            float ti = clamp(raycastInterior(pos, rdi).x,.1,0.6);\n            vec3 sum = vec3(0);\n            for (int i = 0; i < 11; i++) {\n                float bl = smoothstep(.04,3.4,ti)*float(i-5);\n                      bl = .05*(1.-exp(-1.2*ti))*float(i-5);\n                vec3 spos = pos;\n                     spos.x += .15*bl;\n                     spos.y += .08*bl;\n                sum += renderInterior(spos, rdi);\n            }\n            col = sum/11.;\n        } else {\n            col = vec3(0.1,0.1,0.7);\n        }\n        s = .02;\n    }\n    else {\n        col = m == 3. ? vec3(0,0,0) :\n              m == 4. ? vec3(.6,.6,.6) : \n              col;\n    }\n\n    float occ = calcAO( pos, nor );\n\n    vec3 dif = col;\n         dif *= occ;\n\n    vec3 spe = vec3(pow(texture(iChannel1, ref).x, 3.5));\n         spe *= occ;\n         spe *= s;\n\n    vec3 lin = vec3(0.);\n         lin += dif;\n         lin += spe;\n         lin = fog(ro, rd, t, lin);\n\n    return clamp(lin, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    cm = texelFetch(iChannel2, ivec2(0), 0);\n    p0 = texelFetch(iChannel2, ivec2(1, 0), 0);\n    p1 = texelFetch(iChannel2, ivec2(2, 0), 0);\n    p2 = texelFetch(iChannel2, ivec2(3, 0), 0);\n\n    vec2 mo;\n    mo = abs(cm.xy);\n    if (iMouse.z > 0.)\n         mo += (iMouse.xy-abs(iMouse.zw))/iResolution.xy;\n    mo.y = clamp(mo.y, .01, 1.);\n    \n    vec3 ta = vec3(0,remap(mo.y,.7,.3,1.,1.5),0);\n    float d = remap(mo.y,.3,.7,.34,2.8);\n    float x = remap(mo.y,.3,.7,1.,0.);\n    float h = .2+min( x*x/(.5*.5), 1.+(2.0/.5)*max(x-.5,0.0)*exp(-6.1*max(x-.5,0.0)));\n    float a = 7.0*mo.x;\n    float fl = remap(mo.y,.4,.3,2.5,2.75);\n\n    vec3 ro = ta + vec3( d*cos(a), h, d*sin(a) );\n    vec3 cz = normalize(ta-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = cross(cx,cz);\n    mat3 ca = mat3(cx, cy, cz);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p, fl) );\n\n    vec3 col = render( ro, rd );\n    \n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord-.5), 0);\n\n    vec4 cm = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 p0 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 p1 = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 p2 = texelFetch(iChannel0, ivec2(3, 0), 0);\n\n    // camera\n    if (iFrame == 0) \n        cm = vec4(-.73,1,0,0);\n    if (iMouse.z < 0. && cm.y <= 0.) {\n        cm.xy = abs(cm.xy) + (iMouse.xy-abs(iMouse.zw))/iResolution.xy;\n        cm.y = clamp(cm.y, .01, 1.);\n        if (abs(iMouse.xy) == abs(iMouse.zw)) {\n            cm.z = iTime;\n        }\n    }\n    if (iMouse.z > 0. && cm.y > 0.) {\n        cm.y = -cm.y;\n        cm.z = 0.;\n    }\n\n    if (cm.z != 0.) {\n        float t = smoothstep(0.,1.,(iTime - cm.z)/7.);\n        cm.x = -.73 - .175*t;\n        cm.y = .7 - .4*t;\n    }\n\n    vec2 mo = abs(cm.xy);\n    if (iMouse.z > 0.)\n         mo += (iMouse.xy-abs(iMouse.zw))/iResolution.xy;\n    mo.y = clamp(mo.y, .01, 1.);\n\n    // die\n    float b = 1.1;\n    float t = 1.75;\n    float fr = .99;\n    float bo = .4;\n    float l = .41;\n    float r = .4;\n    if (p0.y < b) {\n        cm.w = float(iFrame);\n        p0.xyz = vec3(-.3,b+.08*rand(iTime+0.), .3);\n        p1.xyz = vec3(  0,b+.08*rand(iTime+1.),-.3);\n        p2.xyz = vec3( .3,b+.08*rand(iTime+2.), .3);\n        mat2 rm = r2d(.1*rand(iTime*3.));\n        p0.xz *= rm;  p1.xz *= rm;  p2.xz *= rm;\n        p0.w = p0.y;  p1.w = p1.y;  p2.w = p2.y;\n        p0.z -= 0.1;  p1.z -= 0.1;  p2.z -= 0.1;\n    }\n    else {\n        float p0vy = (p0.y - p0.w)*fr;\n        float p1vy = (p1.y - p1.w)*fr;\n        float p2vy = (p2.y - p2.w)*fr;\n\n        p0.w  = p0.y; p1.w  = p1.y; p2.w  = p2.y;\n        p0.y += p0vy; p1.y += p1vy; p2.y += p2vy;\n\n        if (mo.y<.45) {\n            p0.y += .012*(.25-.165*smoothstep(1.0,1.6,p0.y))*iTimeDelta;\n            p1.y += .012*(.25-.167*smoothstep(1.0,1.6,p1.y))*iTimeDelta;\n            p2.y += .012*(.25-.169*smoothstep(1.0,1.6,p2.y))*iTimeDelta;\n        }\n        else {\n            p0.y -= .1*(.25-.165*smoothstep(1.0,1.6,p0.y))*iTimeDelta;\n            p1.y -= .1*(.25-.177*smoothstep(1.0,1.6,p1.y))*iTimeDelta;\n            p2.y -= .1*(.25-.189*smoothstep(1.0,1.6,p2.y))*iTimeDelta;\n        }\n\n        vec3 d01 = (length(p1.xyz-p0.xyz)-l)*r*normalize(p1.xyz-p0.xyz);\n        p0.xyz += d01;\n        p1.xyz -= d01;\n\n        vec3 d12 = (length(p2.xyz-p1.xyz)-l)*r*normalize(p2.xyz-p1.xyz);\n        p1.xyz += d12;\n        p2.xyz -= d12;\n\n        vec3 d20 = (length(p0.xyz-p2.xyz)-l)*r*normalize(p0.xyz-p2.xyz);\n        p2.xyz += d20;\n        p0.xyz -= d20;\n\n        if (p0.y > t) {\n            p0.w = t + abs(p0.y - p0.w)*bo;\n            p0.y = t;\n        }\n        if (p1.y > t) {\n            p1.w = t + abs(p1.y - p1.w)*bo;\n            p1.y = t;\n        }\n        if (p2.y > t) {\n            p2.w = t + abs(p2.y - p2.w)*bo;\n            p2.y = t;\n        }\n    }\n\n    if (ivec2(fragCoord-.5) == ivec2(0,0)) fragColor = cm;\n    if (ivec2(fragCoord-.5) == ivec2(1,0)) fragColor = p0;\n    if (ivec2(fragCoord-.5) == ivec2(2,0)) fragColor = p1;\n    if (ivec2(fragCoord-.5) == ivec2(3,0)) fragColor = p2;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}