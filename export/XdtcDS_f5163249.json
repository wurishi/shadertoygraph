{"ver":"0.1","info":{"id":"XdtcDS","date":"1521043968","viewed":213,"name":"Fractal soundscape","username":"BenWheatley","description":"Work in progress; sound shader using Perlin noise to determine pitch at any given (quantized) moment, then quantizing the Perlin noise into pentatonic scale notes (sharp/flat notes on a piano).","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["procedural","sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst int MIN_OCTAVE = 1;\nconst int MAX_OCTAVE = 8;\n\n// Perlin noise functions\n\nfloat cosineInterpolate(float a, float b, float x) {\n\tfloat ft = x * PI;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\n\treturn a*(1.0-f) + b*f;\n}\n\nfloat seededRandom(float seed) {\n    int x = int(seed);\n    x = x << 13 ^ x;\n    x = (x * (x * x * 15731 + 789221) + 1376312589);\n    x = x & 0x7fffffff;\n    return float(x)/1073741824.0;\n}\n\n// The magic constants are essentially arbitary:\n// they define the scale of the largest component of the Perlin noise\nfloat perlinNoise(float time) {\n    float sum = 0.0;\n    for (int octave=MIN_OCTAVE; octave<MAX_OCTAVE; ++octave) {\n        float sf = pow(2.0, float(octave));\n        \n\t\tfloat new_t = sf*time*16.0;\n        \n        float new_t_floor = floor(new_t);\n\t\tfloat fraction_t = new_t - new_t_floor;\n        \n        float t1 = seededRandom( sf *  new_t_floor      );\n\t\tfloat t2 = seededRandom( sf * (new_t_floor+1.0) );\n        \n        float i1 = cosineInterpolate(t1, t2, fraction_t);\n\t\t\n        sum += i1/sf;\n    }\n    return sum/2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float p = perlinNoise(uv.y+iTime);\n    vec3 col = vec3(p, 0.5 + 0.5*sin((uv.x-iTime)*20.0), 0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst int MIN_OCTAVE = 1;\nconst int MAX_OCTAVE = 8;\n\n// Perlin noise functions\n\nfloat cosineInterpolate(float a, float b, float x) {\n\tfloat ft = x * PI;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\n\treturn a*(1.0-f) + b*f;\n}\n\nfloat seededRandom(float seed) {\n    int x = int(seed);\n    x = x << 13 ^ x;\n    x = (x * (x * x * 15731 + 789221) + 1376312589);\n    x = x & 0x7fffffff;\n    return float(x)/1073741824.0;\n}\n\n// The magic constants are essentially arbitary:\n// they define the scale of the largest component of the Perlin noise\nfloat perlinNoise(float time) {\n    float sum = 0.0;\n    for (int octave=MIN_OCTAVE; octave<MAX_OCTAVE; ++octave) {\n        float sf = pow(2.0, float(octave));\n        \n\t\tfloat new_t = sf*time*16.0;\n        \n        float new_t_floor = floor(new_t);\n\t\tfloat fraction_t = new_t - new_t_floor;\n        \n        float t1 = seededRandom( sf *  new_t_floor      );\n\t\tfloat t2 = seededRandom( sf * (new_t_floor+1.0) );\n        \n        float i1 = cosineInterpolate(t1, t2, fraction_t);\n\t\t\n        sum += i1/sf;\n    }\n    return sum/2.0;\n}\n\n// Basic sound functions\n\nfloat sinWave(float pitch, float time) {\n    return sin( (2.0*PI*pitch) * time);\n}\n\nfloat simpleHarmonics(float primePitch, float regularPowerDivision, int numberOfDivisions, float time) {\n    float sum = 0.0;\n    for (int i=0; i<numberOfDivisions; ++i) {\n        sum += sinWave(primePitch * pow(2.0, float(i)), time) * pow(regularPowerDivision, float(i));\n    }\n    return sum;\n}\n\nfloat squareWave(float pitch, float time) {\n    if (sinWave(pitch, time)>0.0) {\n        return 1.0;\n    }\n    return -1.0;\n}\n\n// Misc functions\n\nfloat logBase(float base, float x) {\n    return log(x)/log(base);\n}\n\nfloat quantizePitch(float pitch) {\n    return pow(0.943874, floor(logBase(0.943874, pitch)));\n    return pitch;\n}\n\nfloat frequencyFromMIDINoteNumber(int p) {\n    return 440.0 * pow(2.0, float(p-69)/12.0);\n}\n\nint MIDINumberFromBlackNote(int i) {\n    int octave = i/5;\n    int offset = i - (octave*5);\n    \n    switch (offset) {\n    case 0: offset = 1; break;\n    case 1: offset = 3; break;\n    case 2: offset = 6; break;\n    case 3: offset = 8; break;\n    case 4: offset = 10; break;\n    }\n    \n    return (octave*12) + offset;\n}\n\n// Main function\n\nvec2 mainSound( in int samp,float t) {\n    float fast_t = 3.0*t;\n    float qt = floor(fast_t);\n    float emphasis = 1.0;\n    if (mod(qt, 4.0)>=0.5) {\n       emphasis = 0.5; \n    }\n    \n    vec2 o = vec2(0, 0);\n    \n    const float harmonies = 4.0;\n        \n    for (float i=0.0; i<harmonies; i+=1.0) {\n        float harmony_offset = i*2.0;\n        int blackNoteNumber = int(20.0 + 10.0*perlinNoise(qt+harmony_offset) + i);\n        float f = frequencyFromMIDINoteNumber( MIDINumberFromBlackNote(blackNoteNumber) );\n\n        float qf = quantizePitch(f);\n        float a = 1.0-(fast_t-qt);\n\n        float voltage = a*simpleHarmonics(f, 0.33, 8, t);\n        voltage *= emphasis;\n        float position = perlinNoise(100.0+t*2.0);\n        o += vec2( voltage*position, voltage*(1.0-position) );\n    }\n    \n    return o/harmonies;\n    \n    /* Examples:\n    \trandom MIDI note:\n    float f = frequencyFromMIDINoteNumber(int(36.0 + 24.0*perlinNoise(qt)));\n    \tWave generators:\n    return vec2( sinWave(f, t), sinWave(f, -t) );\n    return vec2( simpleHarmonics(440.0, 0.5, 8, t)*exp(-t) );\n    return vec2( squareWave(440.0, t)*exp(-t) );\n\t*/\n}\n","name":"Sound","description":"","type":"sound"}]}