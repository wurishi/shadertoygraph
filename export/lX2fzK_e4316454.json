{"ver":"0.1","info":{"id":"lX2fzK","date":"1729712745","viewed":114,"name":"Basic06","username":"42n4","description":"Task from thebookofshaders.com/07/","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["test","gear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//inspired by gear function from https://www.shadertoy.com/view/Msf3D7\n//and thebookofshaders.com/07/\n#define PI 3.14159265359\n\nfloat plot (float pct, float eps, vec2 st){\n  return  smoothstep( -eps, 0., st.y - pct) -\n          smoothstep( 0., eps, st.y - pct);\n}\n\nfloat white_square(vec2 move, vec2 size, float margin, vec2 st){\n    // bottom-left\n    vec2 bl;\n    bl = smoothstep(0.,margin,st-move);\n    float pct = bl.x * bl.y;\n\n    // top-right\n    vec2 tr;\n    //tr = smoothstep(1.-move-size,1.-move-size+margin,1.-st);\n    tr = smoothstep(0.,-margin,st-move-size);\n    pct *= tr.x * tr.y;\n    return pct;\n}\n\nvec3 color_square(vec3 colorin, vec2 move, vec2 size, float margin, vec2 st){\n    vec3 color_pct = vec3(0);\n    float pct = white_square(move, size, margin, st);\n    color_pct = pct * colorin;\n    return color_pct;\n}\n\nfloat dot_circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nfloat white_circle(vec2 move, float r, float margin, vec2 st){\n    return 1.-smoothstep(-margin,+margin,distance(st,move)-r);\n}\n\nvec3 color_circle(vec3 colorin, vec2 move, float r, float margin, vec2 st){\n    float pct = white_circle(move, r, margin, st);\n    return pct * colorin;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat stepfunc(float a)\n{\n\treturn step(a, 0.0);\n}\n\nfloat white_gear(vec2 move, float size, float teeth_no, float ang, bool right, vec2 st){\n    vec2 pos = move-st;\n    float r = length(pos)*0.6/size;\n    float a = atan(pos.y,pos.x), f=0., v=0., w=0.;\n    if(right)\n        f = cos(a*teeth_no+ang+iTime);\n    else\n        f = cos(a*teeth_no+ang-iTime);\n    f = smoothstep(-.5,0.7, f)*0.2+0.5;\n    v = r - 0.1;\n\tv = min(v, v-f);\n\tw = r - 0.4;\n\tv = max(v, -w);\n    return stepfunc(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y from 0 to 1)\n    vec2 st = fragCoord/iResolution.y;\n    float t = 0.5*iTime;\n    float frame[10]; \n    vec3 color[10];\n    vec3 color1 = vec3(0.95, 0.7, 0.2);\n    vec3 color2 = vec3(0.149,0.141,0.912);\n    vec3 color3 = vec3(1.00,0.833,0.224);\n    vec3 color4 = vec3(0.30,0.833,0.224);\n    vec3 color5 = vec3(0.90,0.13,0.324);\n    vec2 move1 = vec2(0.1,0.1), size1 = vec2(0.5,.5),\n    move2 = vec2(0.5,0.5), size2 = vec2(0.4,0.4),\n    move3 = vec2(0.8,0.5);\n    float pct[10]; \n    pct[0] = white_square(move1, size1, 0.01, st);\n    pct[1] = white_square(move2, size2, 0.01, st);\n    pct[2] = white_circle(move3, 0.3, 0.003, st);\n    pct[3] = white_gear(vec2(0.333,0.5), 0.2, 10., 1., true, st);\n    pct[4] = white_gear(vec2(0.8,0.5), 0.2, 10., 2.15, false, st);\n    pct[5] = white_gear(vec2(.5665, 0.5), 0.3, 10.0, 1., true, st);\n    pct[6] = white_circle(vec2(.5665, 0.5), 0.3, 0.01, st);\n    pct[6] = plot(pct[6], 0.1, st);\n    color[0] = color4;\n    color[1] = color2;\n    color[2] = color3;\n    color[3] = color1;\n    color[4] = color1;\n    color[5] = color5;\n    color[6] = vec3(1);\n    frame[0] = pct[0]*(1.-pct[1])*(1.-pct[2])*(1.-pct[3])*(1.-pct[5]);\n    frame[1] = pct[1]*(1.-pct[2])*(1.-pct[3])*(1.-pct[5]);\n    frame[2] = pct[2]*(1.-pct[3])*(1.-pct[4])*(1.-pct[5]);\n    frame[3] = pct[3]*(1.-pct[5]);\n    frame[4] = pct[4]*(1.-pct[5]);\n    frame[5] = pct[5];\n    frame[6] = pct[6];    \n    vec3 shape = vec3(0);\n    for(int i=0; i < 6; i++)\n       shape += frame[i]*color[i];\n    // Output to screen\n    fragColor = vec4(shape,1.0);\n}","name":"Image","description":"","type":"image"}]}