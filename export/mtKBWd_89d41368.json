{"ver":"0.1","info":{"id":"mtKBWd","date":"1702674340","viewed":29,"name":"Mandel Cube %scouttea","username":"scouttea","description":"The Mandelbrot set where each iteration is visualized by a separated plane closely stacked together\nCan be moved around with the mouse","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","mandelbrot","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Coordinate Mapping\n    // ============================\n\n    // uv alternative where the coordinate grid is not stretched i.e. a square is square\n    // and (-1,-1) to (1,1) is on screen\n    vec2 ab = (2.*fragCoord - iResolution.xy )/min(iResolution.x,iResolution.y);\n    // Same but for mouse pos\n    vec2 mn = (2.*iMouse.xy - iResolution.xy )/min(iResolution.x,iResolution.y);\n    \n    // Rotation\n    // ============================\n    \n    // See https://www.desmos.com/3d/3743fa9787\n    // alpha = the amount of rotation\n    float alpha = -.75*length( mn );\n    // D = the direction in the XY plane onto which we want to rotate the z vector to\n    vec3 D = vec3( normalize(mn), 0. );\n    // v1 = ortogonal to D and inside the xy plane\n    vec3 v1 = vec3( -D.y, D.x, 0. );\n    // v2 = z vector\n    vec3 v2 = vec3( 0.,0.,1. );\n    \n    //rX rotated X vector\n    vec3 rX = v1 * v1.x + v1.y * ( D * cos( alpha ) - v2 * sin( alpha ) );\n    //rY rotated Y vector\n    vec3 rY = v1 * v1.y + v1.x * ( v2 * sin( alpha ) - D * cos( alpha ) );\n    //rZ rotated Z vector\n    vec3 rZ = D * sin( alpha ) + v2 * cos( alpha );\n    \n    // Plane intersection\n    // ============================\n    // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n    \n    // Plane offset\n    vec3 p0 = vec3(0.,0.,.25);\n    // Plane Normal\n    vec3 n = rZ;\n    \n    //Ray Start\n    vec3 l0 = vec3( ab, 0. );\n    // Ray direction\n    // Perspective\n    vec3 l = l0 + vec3( 0.,0.,1. );\n    // Orthogonal\n    //vec3 l = + vec3( 0.,0.,1. );\n    \n    //intersection point\n    float t = dot( p0 - l0, n ) / dot( l, n );\n    vec3 p = l0 + l * t;\n    \n    // Plane Mapping\n    // ============================\n    // Map plane to plane local coordinates\n    \n    // local x\n    float lx = dot( p - p0, rX );\n    // local y\n    float ly = dot( p - p0, rY );\n    \n    // Plane offsets short cut\n    // ============================\n    float delta = dot( rZ * .01, n ) / dot( l, n );\n    float drx = dot( delta * l, rX );\n    float dry = dot( delta * l, rY );\n    \n    fragColor = vec4(vec3(1.), 1.);\n    \n    float i = 0.;\n    while( i < 512. )\n    {\n        if( lx < 1. && -1. < lx )\n        if( ly < 1. && -1. < ly )\n        {\n            vec2 uv = vec2( (lx + 1.) / 2., (ly + 1.) / 2. );\n            vec4 data = texture(iChannel0, uv);\n            if( data.x <= i )\n            { // Hit\n                if( data.x != i ) fragColor.xyz *= .95; //shadows\n                break;\n            }\n        }\n        \n        \n        lx += drx;\n        ly += dry;\n        \n        i+=1.;\n        \n        fragColor.xyz *= .99;\n    }\n    \n    fragColor.xyz *= vec3(0.8,0.5,0.5);\n    \n    if( i >= 512. ) fragColor.xyz = vec3(0.5,0.7,0.9);\n}\n\n//// Mapped coords such that the square (-1,-1) -> (1,1) fits on screen\n//    vec2 ab = (2.*fragCoord - iResolution.xy )/min(iResolution.x,iResolution.y);","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint mandelbrotCalculation( vec2 c )\n{\n    vec2 z = vec2(0.0);\n    \n    uint i;\n    \n    for( i=0u; i<512u; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>4. ) break;\n    }\n    \n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ab = 2.1 * ( 2.*fragCoord.xy / iResolution.xy - vec2(1.) );\n\n    uint result = mandelbrotCalculation( ab );\n\n    // Output to screen\n    fragColor = vec4(float(result),0.,0.,0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}