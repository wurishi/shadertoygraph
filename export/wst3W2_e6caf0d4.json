{"ver":"0.1","info":{"id":"wst3W2","date":"1569621050","viewed":1086,"name":"Recursion!","username":"AntoineC","description":"An exercice in recursive futility...\n\nPress Space bar to switch between Light and Dark themes!","likes":57,"published":1,"flags":48,"usePreview":0,"tags":["2d","text","recursive","shadertoy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, vec2 u) {o=texture(iChannel0,u/iResolution.xy).rgbb;}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Recursion!\" by Antoine Clappier - Sep 2019\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n#define Width 1072.0\n#define Height 603.0\n#define ratio (iResolution.x/Width)\n#define cp(xx,yy) (round(vec2((xx),(yy))*iResolution.x/1072.0))\n#define cs(w,h) (floor(vec2((w),(h))*iResolution.x/(2.*1072.0)))\n\n//#define rgb(r,g,b) vec3(r,g,b)/255.\n\n\n#define SearchF vec3(1.0)\n\nfloat dp;\n\n// -------------------------\n// IQ's signed distances\nfloat sdBox(vec2 p, float x, float y, float w, float h)\n{\n    vec2 d = abs(p-vec2(x,y)-0.5*vec2(w,-h))-0.5*vec2(w,h);\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundBox(vec2 p, float x, float y, float w, float h, float r)\n{\n    vec2 d = abs(p-vec2(x,y)-0.5*vec2(w,-h))-0.5*vec2(w,h)+r;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n// ---------------------------\n\nfloat sdLine(vec2 p, vec2 a,vec2 b)\n{ \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n\nvoid Fill(in float sd, in vec3 color, inout vec3 o)\n{\n    o = mix(color, o, smoothstep(0., dp, sd));\n}\n\nvoid Stroke(in float sd, in vec3 fill, in vec3 stroke, inout vec3 o)\n{\n    o = mix(fill,   o, smoothstep(-0.5*dp, 0.5*dp, sd));\n    o = mix(stroke, o, smoothstep( 0.0, dp, abs(sd)));\n}\n\nvoid FillBox(vec2 p, float x, float y, float w, float h, vec3 fill, inout vec3 o)\n{\n    float sd = sdBox(p, x,y, w,h);\n    Fill(sd, fill, o);\n}\n\nvoid FillRbox(vec2 p, float x, float y, float w, float h, float r, vec3 fill, inout vec3 o)\n{\n    float sd = sdRoundBox(p, x,y, w,h, r);\n    Fill(sd, fill, o);\n}\n\nvoid FillRtbox(vec2 p, float x, float y, float w, float h, float r, vec3 fill, inout vec3 o)\n{\n    float s = sdRoundBox(p, x, y, w, 2.0*r, r);\n    s = min(s, sdBox(p, x, y-r, w, h-r));\n    Fill(s, fill, o);\n}\n\nvoid FillRbbox(vec2 p, float x, float y, float w, float h, float r, vec3 fill, inout vec3 o)\n{\n    float s = sdRoundBox(p, x, y, w, h, r);\n    s = min(s, sdBox(p, x, y, w, r));\n    Fill(s, fill, o);\n}\n\nvoid StrokeRbox(vec2 p, float x, float y, float w, float h, float r, vec3 fill, vec3 stroke, inout vec3 o)\n{\n    float sd = sdRoundBox(p, x,y, w,h, r);\n    Stroke(sd, fill, stroke, o);\n}\n\nvoid FillDisk(vec2 p, float r, vec3 fill, inout vec3 o)\n{\n    float s = length(p) - r;\n    Fill(s, fill, o);\n}\n\n\n// IQ's heart\nvoid Heart(vec2 p, vec3 color, inout vec3 o)\n{\n    float size = 1./12.;\n    p *= size;\n    p.y = -0.1 - p.y*1.2 + abs(p.x)*(1.0-abs(p.x));\n    float r = length(p);\n\tfloat d = 0.5;\n    \n    o = mix(color, o, smoothstep(-size*dp, size*dp, r-d));\n}\n\n\nvoid Share(vec2 p, vec3 color, inout vec3 o)\n{\n    float size = 1./12.0;\n    p *= size;\n\n    float r = 0.16;\n    float s;\n    s = length(p-vec2(0.05+r, 0.5)) - r;\n    s = min(s, length(p-vec2(0.95-r, 0.8)) - r);\n    s = min(s, length(p-vec2(0.95-r, 0.2)) - r);\n    s = min(s, sdLine(p, vec2(0.05+r, 0.5), vec2(0.95-r, 0.8)) - r/3.); \n    s = min(s, sdLine(p, vec2(0.05+r, 0.5), vec2(0.95-r, 0.2)) - r/3.); \n\n    o = mix(color, o, smoothstep(-size*dp, size*dp, s));\n}\n\nvoid FullScreen(vec2 p, vec3 color, inout vec3 o)\n{\n    float s = sdBox(p, 0.,0., 14.,14.);\n    s = max(s, -sdBox(p, -1.,-6., 16.,2.));\n    s = max(s, -sdBox(p, 6., 1., 2.,16.));\n    s = max(s, -sdBox(p, 4.,-4., 6.,6.));\n    o = mix(color, o, smoothstep(0., dp, s));\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// Additional spacing based on typeface weight:\n#define WeightWidth(weight) (0.05*0.4*(weight))\n\n// Char spacing:\n#define CharSpacing(size, weight) ((size)*(0.38 + 2.0*WeightWidth(weight)))\n\n\n\n// Draw a glyph:\n//  ascii:  ASCII character value\n//  p:      pixel coordinate. (0,0) is left border and base line of char (corrected for weight).\n//  eps:    pixel size.\n//  coord:  coordinate of the character. \n//  color:  color.\n//  size:   font size.\n//  weight: Typeface weight [0.20 3], regular 1.\n//  o:      frag color (in/out).\nvoid Glyph(int ascii, vec2 p, float eps, float x, vec3 color, float size, float weight, inout vec3 o)\n{\n    // Scaling:\n    p   /= size;\n    eps /= size;\n    \n    // Weight width:\n    float weightWidth = WeightWidth(weight);\n\n    // Typeface Width (condensed = 1.5):\n    //p.x *= 1.5;\n    \n    // Set char position:\n    float charSpacing = CharSpacing(size, weight) / size; // divide by size since p is already scaled\n    float dx = 0.31 - weightWidth; // bottom left corner of char\n    float dy = 0.24 - weightWidth; \n    p += vec2(dx - charSpacing*x, dy);\n\n    // Italic:\n    //p.x += -0.30*(p.y-dy);\n    \n    // Is uv inside of [0 1] for both components?\n    if(all(greaterThanEqual(vec4(p,1,1), vec4(0,0,p))))\n    {\n        // Get the distance (.w component of the sprite sheet):\n        float g = texture(iChannel0, 0.0625*(p + vec2(ascii - ascii/16*16,15 - ascii/16))).w;\n\n        // Fill interior:\n        float b = 0.5*0.95 + weightWidth;\n        float c = smoothstep(b + 0.7*eps, b - 0.7*eps , g);\n        \n        // Add to output:\n        //o = mix(mix(o, vec3(1.,0.,0.), 0.20), color, c);\n        o = mix(o, color, c);\n    }\n}\n\n\n\n#define Upk0(idx, code, next) (x < 0 ? 0u : ((x) < (idx) ? code : (next)))\n#define Upk(idx, code, next) ((x) < (idx) ? code : (next))\n\n#define Decode4(len, c0) Upk0(len, c0, 0u)\n#define Decode8(len, c0, c1) Upk0(4, c0, Upk(len, c1, 0u))\n#define Decode12(len, c0, c1, c2) Upk0(4, c0, Upk(8, c1, Upk(len, c2, 0u)))\n#define Decode16(len, c0, c1, c2, c3) Upk0(4, c0, Upk(8, c1, Upk(12, c2, Upk(len, c3, 0u))))\n#define Decode20(len, c0, c1, c2, c3, c4) Upk0(4, c0, Upk(8, c1, Upk(12, c2, Upk(16, c3, Upk(len, c4, 0u)))))\n#define Decode24(len, c0, c1, c2, c3, c4, c5) Upk0(4, c0, Upk(8, c1, Upk(12, c2, Upk(16, c3, Upk(20, c4, Upk(len, c5, 0u))))))\n\nvoid Text4(vec2 p, float eps, vec2 pp, vec3 color, float size, float weight, inout vec3 o,\n           int len, uint c0)\n{\n    p      -= vec2(pp.x, pp.y);   int x    = int(floor(p.x/CharSpacing(size, weight)));\n    uint v  = Decode4(len, c0);          int char = int((v >> uint(8*(3-x%4))) & 0xffu);\n    if(char != 0) { Glyph(char, p, eps, float(x), color, size, weight, o); }\n}\n\nvoid Text8(vec2 p, float eps, vec2 pp, vec3 color, float size, float weight, inout vec3 o,\n           int len, uint c0, uint c1)\n{\n    p      -= vec2(pp.x, pp.y);   int x    = int(floor(p.x/CharSpacing(size, weight)));\n    uint v  = Decode8(len, c0, c1);      int char = int((v >> uint(8*(3-x%4))) & 0xffu);\n    if(char != 0) { Glyph(char, p, eps, float(x), color, size, weight, o); }\n}\n\nvoid Text12(vec2 p, float eps, vec2 pp, vec3 color, float size, float weight, inout vec3 o,\n            int len, uint c0, uint c1, uint c2)\n{\n    p      -= vec2(pp.x, pp.y);   int x    = int(floor(p.x/CharSpacing(size, weight)));\n    uint v  = Decode12(len, c0, c1, c2); int char = int((v >> uint(8*(3-x%4))) & 0xffu);\n    if(char != 0) { Glyph(char, p, eps, float(x), color, size, weight, o); }\n}\n\nvoid Text16(vec2 p, float eps, vec2 pp, vec3 color, float size, float weight, inout vec3 o,\n            int len, uint c0, uint c1, uint c2, uint c3)\n{\n    p      -= vec2(pp.x, pp.y);   int x    = int(floor(p.x/CharSpacing(size, weight)));\n    uint v  = Decode16(len, c0, c1, c2, c3); int char = int((v >> uint(8*(3-x%4))) & 0xffu);\n    if(char != 0) { Glyph(char, p, eps, float(x), color, size, weight, o); }\n}\n\nvoid Text20(vec2 p, float eps, vec2 pp, vec3 color, float size, float weight, inout vec3 o,\n            int len, uint c0, uint c1, uint c2, uint c3, uint c4)\n{\n    p      -= vec2(pp.x, pp.y);   int x    = int(floor(p.x/CharSpacing(size, weight)));\n    uint v  = Decode20(len, c0, c1, c2, c3, c4); int char = int((v >> uint(8*(3-x%4))) & 0xffu);\n    if(char != 0) { Glyph(char, p, eps, float(x), color, size, weight, o); }\n}\n\nvoid Text24(vec2 p, float eps, vec2 pp, vec3 color, float size, float weight, inout vec3 o,\n            int len, uint c0, uint c1, uint c2, uint c3, uint c4, uint c5)\n{\n    p      -= vec2(pp.x, pp.y);   int x    = int(floor(p.x/CharSpacing(size, weight)));\n    uint v  = Decode24(len, c0, c1, c2, c3, c4, c5); int char = int((v >> uint(8*(3-x%4))) & 0xffu);\n    if(char != 0) { Glyph(char, p, eps, float(x), color, size, weight, o); }\n}\n\n// -----------------------------------------------------------------------------\n\nvoid ShowTime(vec2 p, vec3 color, inout vec3 o)\n{\n    p -= vec2(105., 246.);\n    int t = int(round(iTime*100.0));\n    float x = 7.;\n\n    Glyph(0x30 + t%10, p, dp, x, color, 13., 2.0, o); x--; t /= 10;\n    Glyph(0x30 + t%10, p, dp, x, color, 13., 2.0, o); x--; t /= 10;\n    Glyph(0x2e       , p, dp, x, color, 13., 2.0, o); x--;\n    Glyph(0x30 + t%10, p, dp, x, color, 13., 2.0, o); x--; t /= 10;\n    if(t > 0) { Glyph(0x30 + t%10, p, dp, x, color, 13., 2.0, o); x--; t /= 10; }\n    if(t > 0) { Glyph(0x30 + t%10, p, dp, x, color, 13., 2.0, o); x--; t /= 10; }\n    if(t > 0) { Glyph(0x30 + t%10, p, dp, x, color, 13., 2.0, o); x--; t /= 10; }\n}\n\n\nvoid BufA(vec2 p, vec3 color, inout vec3 o)\n{\n    p -= vec2(623.,92.);\n    float k = 2.8;\n    float s;\n    s =         sdRhombus(p, vec2(28.0,7.0));   p.y -= 5.0;\n    s = max(s, -sdRhombus(p, vec2(28.0,7.0)));  p.y -= 3.0;\n    s = min(s,  sdRhombus(p, vec2(28.0,7.0)));  p.y -= 5.0;\n    s = max(s, -sdRhombus(p, vec2(28.0,7.0)));  p.y -= 3.0;\n    s = min(s,  sdRhombus(p, vec2(28.0,7.0)));  p.y -= 5.0;\n    s = min(s,  sdLine(p-vec2(44.,9.), vec2(-k,-k), vec2(k,k)) - 0.7);\n    s = min(s,  sdLine(p-vec2(44.,9.), vec2(-k, k), vec2(k,-k)) - 0.7);\n    s = min(s,  abs(length(p-vec2(44.,9.))-5.5) - 0.7 );\n    o = mix(vec3(1), o, smoothstep(-dp, dp, s));\n\n\tp += vec2(5.5, 8.0);\n    p.x *= 0.5;\n    Glyph(0x42, p, dp, 0., vec3(0), 13., 1.6, o);\n    p.x /= 0.5;\n\n\tp -= vec2(48.0, -48.0);\n    p.x += 0.18*p.y;\n    Glyph(0x23, p, dp, 0., color, 18., 2.0, o);\n}\n\n\nvoid ChannelBox(vec2 p, int idx, vec3 color1, vec3 color2, inout vec3 o)\n{\n    FillRtbox(p, 0.,  0., 110., 60., 4., vec3(0), o);\n    FillRbbox(p, 0., -60., 110., 25., 4., color1, o);\n    Text12(p, dp, vec2(5., -78.), color2, 14., 1.6, o, 10, 0x69436861u, 0x6e6e656cu, uint((0x30 + idx)<<24));\n}\n\n// --------------------------------------------------------------------\n// shader:\n#define TAU 6.28318530718\n\n\nconst vec3 BackColor\t= vec3(0.0, 0.4, 0.58);\nconst vec3 CloudColor\t= vec3(0.18,0.70,0.87);\n\n\nfloat Func(float pX)\n{\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\n}\n\n\nfloat FuncR(float pX)\n{\n\treturn 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));\n}\n\n\nfloat Layer(vec2 pQ, float pT)\n{\n\tvec2 Qt = 3.5*pQ;\n\tpT *= 0.5;\n\tQt.x += pT;\n\n\tfloat Xi = floor(Qt.x);\n\tfloat Xf = Qt.x - Xi -0.5;\n\n\tvec2 C;\n\tfloat Yi;\n\tfloat D = 1.0 - step(Qt.y,  Func(Qt.x));\n\n\t// Disk:\n\tYi = Func(Xi + 0.5);\n\tC = vec2(Xf, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+ pT/80.0));\n\n\t// Previous disk:\n\tYi = Func(Xi+1.0 + 0.5);\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));\n\n\t// Next Disk:\n\tYi = Func(Xi-1.0 + 0.5);\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));\n\n\treturn min(1.0, D);\n}\n\n\n\nvec3 Shader(vec2 UV)\n{\n\t// Render:\n\tvec3 Color= BackColor;\n\n\tfor(float J=0.0; J<=1.0; J+=0.2)\n\t{\n\t\t// Cloud Layer: \n\t\tfloat Lt =  iTime*(0.5  + 2.0*J)*(1.0 + 0.1*sin(226.0*J)) + 17.0*J;\n\t\tvec2 Lp = vec2(0.0, 0.3+1.5*( J - 0.5));\n\t\tfloat L = Layer(UV + Lp, Lt);\n\n\t\t// Blur and color:\n\t\tfloat Blur = 4.0*(0.5*abs(2.0 - 5.0*J))/(11.0 - 5.0*J);\n\n\t\tfloat V = mix( 0.0, 1.0, 1.0 - smoothstep( 0.0, 0.01 +0.2*Blur, L ) );\n\t\tvec3 Lc=  mix( CloudColor, vec3(1.0), J);\n\n\t\tColor =mix(Color, Lc,  V);\n\t}\n\n\treturn Color;\n}\n// --------------------------------------------------------------------\n\n#define rgb(r,g,b) (vec3(float(r),float(g),float(b))/255.)\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    // Load time and dectect pause:\n    //  (from a Morimea idea, see comments) \n     bool paused = (iTime == texelFetch(iChannel2,ivec2(1,0),0).a);\n \n    // Switch mode:\n    float mode = texture(iChannel2, vec2(0)).w;\n\tif(texelFetch( iChannel3, ivec2(32,0), 0 ).x > 0.5 && 10.*iTime - floor(mode) > 5.0)\n    {\n        mode = fract(mode) == 0. ? 0.5 : 0.0;\n        mode += floor(10.*iTime);\n    }\n    \n    \n    vec2 v;\n    dp = Width/iResolution.x;\n    v = dp*(fragCoord + 0.5);\n    \n    vec3 c = vec3(0.,1.,0.);\n\n    // Colors\n\tvec3 cBack, cTopBar, cBotBar, cText0, cText1, cTextS, cBar, cTabP, cTab, cTabO, \n         cTabS, cSep, cEditor, cCode, cNum, cNumB;\n    \n    if(fract(mode) == 0.0)\n    {\n        cBack   = rgb(189,189,189);\n        cTopBar = rgb(64,64,64);\n        cBotBar = rgb(170,170,170);\n        cText0  = rgb(0,0,0);\n        cText1  = rgb(255,255,255);\n        cTextS  = rgb(153,153,153);\n        cBar    = rgb(240,240,240);\n        cTabP   = rgb(176,176,176);\n        cTab    = rgb(140,140,140);\n        cTabO   = rgb(247,176,48);\n        cTabS   = rgb(247,176,48);\n        cSep    = rgb(219,219,219);\n        cEditor = rgb(255,255,255);\n        cCode   = rgb(76,76,76);\n        cNum    = rgb(115,115,115);\n        cNumB   = cBar;\n    }\n    else\n    {\n        cBack   = rgb(16,16,16);\n        cTopBar = rgb(56,56,56);\n        cBotBar = rgb(56,56,56);\n        cText0  = rgb(176,176,176);\n        cText1  = rgb(255,255,255);\n        cTextS  = rgb(153,153,153);\n        cBar    = rgb(64,64,64);\n        cTabP   = rgb(64,64,64);\n        cTab    = rgb(64,64,64);\n        cTabO   = rgb(176,80,16);\n        cTabS   = rgb(64,64,64);\n        cSep    = rgb(219,219,219);\n        cEditor = rgb(0,0,0);\n        cCode   = rgb(170,170,170);\n        cNum    = rgb(170,170,170);\n        cNumB   = rgb(0,0,0);\n    }\n    \n \n    // Back texture:\n    c = cBack.r+0.15*texture(iChannel1, 0.007*v.yx/dp).rrr;\n    c = cBack.r+0.07*texture(iChannel1, 0.007*v.yx/dp).rrr;\n    \n    // Top and bottom banners:\n    c = mix(c, cTopBar, step(Height - 44., v.y)); \n    c = mix(c, cBotBar, step(v.y, 22.));\n    \n    \n    // Top Banner:\n    // \"Shadertoy\"\n    vec2 it = v - vec2(29., 576.);\n    it.x -= 0.15*it.y;\n    Text12(it, dp, vec2(0), cText1, 24., 2.0, c, 9, 0x53686164u, 0x6572746fu, 0x79000000u);\n    //  - Search box:\n    StrokeRbox(v, 170., 592.0, 300., 22., 5., vec3(1.0), vec3(0.0), c);\n    it = v - vec2(180., 576.);\n    it.x -= 0.3*it.y;\n    Text12(it, dp, vec2(0), cTextS, 14., 1.0, c, 9, 0x53656172u, 0x63682e2eu, 0x2e000000u);\n    //  - \"Browse   New   Sign In\"\n    Text24(v, dp, vec2(907., 578.), cText1, 14., 2.0, c, 22, 0x42726f77u, 0x73652020u, 0x204e6577u, 0x20202053u, 0x69676e20u, 0x496e0000u);\n   \n    // Bottom banner\n    // \"Documentation\"\n    Text16(v, dp, vec2(37., 6.), cText0, 14., 1.5, c, 13, 0x446f6375u, 0x6d656e74u, 0x6174696fu, 0x6e000000u);\n    // \"Terms & Privacy\"\n    Text16(v, dp, vec2(138., 6.), cText0, 14., 1.5, c, 15, 0x5465726du, 0x73202620u, 0x50726976u, 0x61637900u);\n    // \"Feedback   Events\"\n    Text20(v, dp, vec2(250., 6.), cText0, 14., 1.5, c, 17, 0x46656564u, 0x6261636bu, 0x20202045u, 0x76656e74u, 0x73000000u);\n    // \"Roadmap   About\"\n    Text16(v, dp, vec2(376., 6.), cText0, 14., 1.5, c, 15, 0x526f6164u, 0x6d617020u, 0x20204162u, 0x6f757400u);\n    // \"by Beautypi\"\n    Text12(v, dp, vec2(988., 6.), cText0, 14., 1.5, c, 11, 0x62792042u, 0x65617574u, 0x79706900u);\n\n    \n    // Shader player\n    //  - Shader\n    vec3 cs = Shader(2.0*(v-vec2(36.,+264.)-0.5*vec2(500.,281.))/500.);\n    c = mix(cs, c, smoothstep(0., dp, sdRoundBox(v, 36., 545., 500., 285., 4.)));\n    \n    //  - Player\n    FillRbbox(v, 36., 263., 500., 24., 4., cBar, c);\n    //  - Rewind:\n    Text4(v, dp, vec2(59., 243.), cText0, 24., 1.0, c, 1, 0x02000005u);\n    FillBox(v, 58., 257., 3., 13., cText0, c);\n    //  - Play:\n    if(paused)\n    {\n        Text4(v, dp, vec2(86., 243.), cText0, 24., 1.0, c, 1, 0x05000005u);\n    }\n    else\n    {\n        FillBox(v, 86., 257., 3., 13., cText0, c);\n        FillBox(v, 92., 257., 3., 13., cText0, c);\n    }\n    \n    //FillBox(v, 86., 257., 3., 13., cText0, c);\n    //FillBox(v, 92., 257., 3., 13., cText0, c);\n    // Time:\n    ShowTime(v, cText0, c);\n    // \"60.0 fps   640 x 360\"\n    Text20(v, dp, vec2(186., 246.),cText0, 13., 2.0, c, 20, 0x36302e30u, 0x20667073u, 0x20202036u, 0x34302078u, 0x20333630u);\n    // \"REC\"\n    Text4(v, dp, vec2(427.5, 243.), cText0, 10., 1.3, c, 3, 0x52454300u);\n    FillDisk(v-vec2(434.,256.), 3.8, cText0, c);\n    //// \"VR\"\n    //FillDisk(vec2(1.3*(v.x-432.),v.y-252.), 6.0, cText0, c);\n    //FillDisk(vec2(1.3*(v.x-439.),v.y-252.), 6.0, cText0, c);\n\t//FillBox(v, 430.5, 258.0, 8., 5., cText0, c);\n    //Text4(v, dp, vec2(431.5, 250.), cText1, 8., 1.6, c, 3, 0x56520000u);\n    //  - Sound\n    Glyph(31, vec2(480.-v.x, v.y-246.), dp, 0., cText0, 22., 1.0, c);\n    //  - Fullscreen\n    FullScreen(v - vec2(511.,259.), cText0, c);\n\n    // Info:\n    //  - \"Recursion!\"\n    Text12(v, dp, vec2(36., 210), cText0, 20., 1.3, c, 10, 0x52656375u, 0x7273696fu, 0x6e210000u);\n    //  - Share:\n    Share(v - vec2(480., 211.), cText0, c);\n    //  - Love:\n    Heart(v - vec2(511., 217.), cText0, c);\n    //  - Love count:\n    Text4(v, dp, vec2(526., 212.), cText0, 14., 1.0, c, 1, 0x38000000u);\n\t\n \t//  - \"Views: 42, Tags: 2d\"\n    Text20(v, dp, vec2(36., 190.), cText0, 12., 1.0, c, 19, 0x56696577u, 0x733a2034u, 0x322c2054u, 0x6167733au, 0x20326400u);\n    //  - \"Created by\"\n    Text12(v, dp, vec2(366., 190.), cText0, 12., 1.0, c, 10, 0x43726561u, 0x74656420u, 0x62790000u);\n    //  - \"AntoineC\"\n    Text8(v, dp, vec2(420., 190.), cText0, 12., 2.0, c, 8, 0x416e746fu, 0x696e6543u);\n    //  - \"in 2019-09-25\"\n    Text16(v, dp, vec2(468., 190.), cText0, 12., 1.0, c, 13, 0x696e2032u, 0x3031392du, 0x30392d32u, 0x37000000u);\n\n    // \"An exercise in recursive\"\n    Text24(v, dp, vec2(36., 160.), cText0, 12., 1.0, c, 24, 0x416e2065u, 0x78657263u, 0x69736520u, 0x696e2072u, 0x65637572u, 0x73697665u);\n    // \"futility...\"\n    Text12(v, dp, vec2(162., 160.), cText0, 12., 1.0, c, 11, 0x66757469u, 0x6c697479u, 0x2e2e2e00u);\n\n    //  - \"Comments (0)\"\n    Text12(v, dp, vec2(36., 99.), cText0, 12., 1.0, c, 12, 0x436f6d6du, 0x656e7473u, 0x20283029u);\n    //  - \"Sign in\"\n    Text8(v, dp, vec2(36., 72.), cText0, 12., 2.0, c, 7, 0x5369676eu, 0x20696e00u);\n    //  - \"to post a comment\"\n    Text20(v, dp, vec2(79., 72.), cText0, 12., 1.0, c, 17, 0x746f2070u, 0x6f737420u, 0x6120636fu, 0x6d6d656eu, 0x74000000u); \n\n\n    \n     \n    // --------------------------\n\n    \n    // IDE:\n    //  - + Tab\n    FillRtbox(v, 566., 540., 42., 22., 8., cTabP, c);\n    Text4(v, dp, vec2(581., 521.), cText0, 28., 1.5, c, 1, 0x2b000000u);\n    // \"Buffer A\"\n    FillRtbox(v, 613., 540., 70., 22., 8., cTab, c);\n    Text8(v, dp, vec2(628., 526.), cText1, 12., 2.1, c, 8, 0x42756666u, 0x65722041u);    \n    //  - Buf B Tab\n    FillRtbox(v, 688., 540., 70., 22., 8., cTab, c);\n    Text8(v, dp, vec2(628.+75., 526.), cText1, 12., 2.1, c, 8, 0x42756666u, 0x65722042u);    \n    //  - Image Tab\n    FillRtbox(v, 763., 540., 70., 22., 8., cTabO, c);\n    Text8(v, dp, vec2(634.+2.*75., 526.), cText1, 12., 2.1, c, 5, 0x496d6167u, 0x65000000u);\n\n    \n    //  - Orange separator\n    FillBox(v, 566., 518., 470., 4., cTabS, c);\n\n    //  - Shader inputs dropdown\n    FillRbox(v, 566., 509., 470., 20., 4., cBar, c);\n    Text16(v, dp, vec2(580., 497.), cText0, 12., 1.0, c, 13, 0x53686164u, 0x65722049u, 0x6e707574u, 0x73000000u);\n    \n    //  - Editor\n    FillRbbox(v, 566., 485., 470., 334., 4., cBar, c);\n    FillRbbox(v, 566., 485., 470., 310., 4., cNumB, c);\n\t//  - Code:\n    FillBox(v, 600., 485., 10., 310., cSep, c);\n    FillBox(v, 602., 485., 434., 310., cEditor, c);\n    // \"> Compiled is 0.5 secs\"\n    Text24(v, dp, vec2(576., 159.), cText0, 12., 1.0, c, 22, 0x2020436fu, 0x6d70696cu, 0x65642069u, 0x6e20302eu, 0x35207365u, 0x63730000u);\n    Text4(v, dp, vec2(570., 156.), cText0, 24., 1.0, c, 4, 0x05000000u);\n    //  - Text size menu\n    StrokeRbox(v, 951., 170., 36., 17., 5., cBar, vec3(0.5), c);\n    Text4(v, dp, vec2(960., 158.), cText0, 12., 1.0, c, 4, 0x53202076u);\n    Text4(v, dp, vec2(1006., 156.), cText0, 18., 1.0, c, 4, 0x3f000000u);\n\t//  - Full screen\n    //FullScreen(v - vec2(919.,169.), cText0, c);\n    \n\n    ChannelBox(v - vec2(566. + 0.*119., 132.), 0, cBar, cText0, c);\n    BufA(v, cText0, c);\n    ChannelBox(v - vec2(566. + 1.*119., 132.), 1, cBar, cText0, c);\n    ChannelBox(v - vec2(566. + 2.*119., 132.), 2, cBar, cText0, c);\n    ChannelBox(v - vec2(566. + 3.*119., 132.), 3, cBar, cText0, c);\n\n    // Source:\n    // \"void mainImage(out vec4 \"\n    Text24(v, dp, vec2(608., 472.), cCode, 12., 1.0, c, 24, 0x766f6964u, 0x206d6169u, 0x6e496d61u, 0x6765286fu, 0x75742076u, 0x65633420u);\n    // \"o, vec2 u) {o=texture(iC\"\n    Text24(v, dp, vec2(729., 472.), cCode, 12., 1.0, c, 24, 0x6f2c2076u, 0x65633220u, 0x7529207bu, 0x6f3d7465u, 0x78747572u, 0x65286943u);\n    // \"hannel0,u/iResolution.xy\"\n    Text24(v, dp, vec2(850., 472.), cCode, 12., 1.0, c, 24, 0x68616e6eu, 0x656c302cu, 0x752f6952u, 0x65736f6cu, 0x7574696fu, 0x6e2e7879u);\n    // \").rgbb;}\"\n    Text8( v, dp, vec2(971., 472.), cCode, 12., 1.0, c, 8, 0x292e7267u, 0x62623b7du);\n\n    // \"78 / 14734 chars\"\n    Text16(v, dp, vec2(776., 159.), cText0, 12., 1.0, c, 16, 0x3738202fu, 0x20313437u, 0x33342063u, 0x68617273u);\n\n    o = vec4(c, mode);\n    \n    // Store time:\n    if(ivec2(fragCoord) == ivec2(1,0)) { o.w=iTime; }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float sdBox(vec2 p, vec2 s)\n{\n    vec2 d = abs(p-s)-s;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 o, in vec2 v )\n{\n    float dv = 1072. / iResolution.x;\n    v *= dv;\n\n    vec2 s = vec2(1072.0, 603.);\n    vec3 c = texture(iChannel0, v/s).rgb;\n    float f = 2.0;\n    c *= 0.5 +0.5*smoothstep(0.0, f+dv, abs(sdBox(v, 0.5*s)));\n    \n    float ratio = 501.0/s.x;\n    v -= vec2(35., 263.);\n    for(float r=0.; r<floor(4.0*(1.0+cos(3.14159+0.5*iTime))); r++)\n    {\n        s *= ratio;\n        if(v.x>=0.0 && v.x<s.x && v.y>=0.0 && v.y<s.y)\n        {\n            c = texture(iChannel0, v/s).rgb;\n            c *= 0.5 +0.5*smoothstep(0.0, f+dv, abs(sdBox(v, 0.5*s)));\n        }\n        v -= vec2(35., 263.)*pow(ratio, r+1.0);\n        f *= ratio;\n    }\n\n    o = vec4(c,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}