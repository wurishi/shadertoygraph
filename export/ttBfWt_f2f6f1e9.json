{"ver":"0.1","info":{"id":"ttBfWt","date":"1604253871","viewed":197,"name":"3d_four_noises23","username":"edwardbraed","description":"Four 3D noises (value, perlin, simplex, cellular) for visual comparison.\nUncomment \"NO_EFFECTS\" (and change other defines), to see the difference\n2d version - https://www.shadertoy.com/view/3lSfDt","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["perlin","simplex","value","cellular","elements"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OCTAVES 1\n#define SCALE 8.0\n#define SPEED 0.2\n#define POINTS_IN_CELL 2.0\n\n//#define NO_EFFECTS\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec3 quantic(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat rand1(float n)\n{ \n\treturn fract(sin(dot(n, 12.9898)) * 43758.5453);\n}\n\nfloat rand3(vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(12.9898, 4.1414, 17.9361))) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------\n//- Value noise --------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nfloat valueNoise3(vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 lp = p - ip;\n    vec3 q  = quantic(lp);\n    \n    float v1 = rand3(ip); //+ vec3(0.0, 0.0, 0.0);\n    float v2 = rand3(ip     + vec3(1.0, 0.0, 0.0));\n    float v3 = rand3(ip     + vec3(0.0, 1.0, 0.0));\n    float v4 = rand3(ip     + vec3(1.0, 1.0, 0.0));\n    \n    float v5 = rand3(ip     + vec3(0.0, 0.0, 1.0));\n    float v6 = rand3(ip     + vec3(1.0, 0.0, 1.0));\n    float v7 = rand3(ip     + vec3(0.0, 1.0, 1.0));\n    float v8 = rand3(ip     + vec3(1.0, 1.0, 1.0));\n    \n\treturn mix(mix(mix(v1,v2,q.x), mix(v3,v4,q.x), q.y),\n               mix(mix(v5,v6,q.x), mix(v7,v8,q.x), q.y), q.z);\n}\n\nfloat valueFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        #ifdef NO_EFFECTS\n        \tres += valueNoise3(pos) * amplitude;\n        #else\n        \tres += abs((0.5 - valueNoise3(pos)) * amplitude * 2.0);\n        #endif\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Perlin noise -------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec3 perlinVector3(vec3 p)\n{\n    float rv = rand3(p);\n    \n    if     (rv < 0.166) return vec3( 1.0,  0.0,  0.0);\n    else if(rv < 0.332) return vec3(-1.0,  0.0,  0.0);\n    else if(rv < 0.498) return vec3( 0.0,  1.0,  0.0);\n    else if(rv < 0.664) return vec3( 0.0, -1.0,  0.0);\n    else if(rv < 0.830) return vec3( 0.0,  0.0,  1.0);\n    \t\t\t\t\treturn vec3( 0.0,  0.0, -1.0);\n}\n\nfloat perlinNoise3(vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 lp = p - ip;\n    vec3 q  = quantic(lp);\n    \n    vec3 nv1 = perlinVector3(ip); // + vec3(0.0, 0.0, 0.0);\n    vec3 nv2 = perlinVector3(ip      + vec3(1.0, 0.0, 0.0));\n    vec3 nv3 = perlinVector3(ip      + vec3(0.0, 1.0, 0.0));\n    vec3 nv4 = perlinVector3(ip      + vec3(1.0, 1.0, 0.0));\n    vec3 nv5 = perlinVector3(ip      + vec3(0.0, 0.0, 1.0));\n    vec3 nv6 = perlinVector3(ip      + vec3(1.0, 0.0, 1.0));\n    vec3 nv7 = perlinVector3(ip      + vec3(0.0, 1.0, 1.0));\n    vec3 nv8 = perlinVector3(ip      + vec3(1.0, 1.0, 1.0));\n    \n    vec3 dv1 = vec3(lp); // - vec3(0.0, 0.0, 0.0);\n    vec3 dv2 = vec3(lp      - vec3(1.0, 0.0, 0.0));\n    vec3 dv3 = vec3(lp      - vec3(0.0, 1.0, 0.0));\n    vec3 dv4 = vec3(lp      - vec3(1.0, 1.0, 0.0));\n    vec3 dv5 = vec3(lp      - vec3(0.0, 0.0, 1.0));\n    vec3 dv6 = vec3(lp      - vec3(1.0, 0.0, 1.0));\n    vec3 dv7 = vec3(lp      - vec3(0.0, 1.0, 1.0));\n    vec3 dv8 = vec3(lp      - vec3(1.0, 1.0, 1.0));\n    \n    float v1 = dot(nv1, dv1);\n    float v2 = dot(nv2, dv2);\n    float v3 = dot(nv3, dv3);\n    float v4 = dot(nv4, dv4);\n    float v5 = dot(nv5, dv5);\n    float v6 = dot(nv6, dv6);\n    float v7 = dot(nv7, dv7);\n    float v8 = dot(nv8, dv8);\n    \n\treturn mix(mix(mix(v1,v2,q.x), mix(v3,v4,q.x), q.y),\n               mix(mix(v5,v6,q.x), mix(v7,v8,q.x), q.y), q.z);\n}\n\nfloat perlinFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        #ifdef NO_EFFECTS\n        \tres += (perlinNoise3(pos) + 0.5) * amplitude;\n        \t//res += (0.5 + perlinNoise3(pos) * 0.5) * amplitude;\n        #else\n        \tpos.z *= 1.0 - amplitude;\n        \tres += max(perlinNoise3(pos) * amplitude, 0.0);\n        #endif\n        //res += abs(perlinNoise3(pos) * amplitude * 2.0);\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    \n    return max(res / ma, 0.0);\n}\n\n//----------------------------------------------------------------------------------\n//- Simplex noise ------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec3 simplexVector3(vec3 p)\n{   \n    const vec3 vecs[12] =  vec3[12]( vec3( 1.0,  1.0,  0.0),\n                                     vec3(-1.0,  1.0,  0.0),\n                                     vec3( 1.0, -1.0,  0.0),\n                                     vec3(-1.0, -1.0,  0.0),\n                                     vec3( 1.0,  0.0,  1.0),\n                                     vec3(-1.0,  0.0,  1.0),\n                                     vec3( 1.0,  0.0, -1.0),\n                                     vec3( 1.0,  0.0, -1.0),\n                                     vec3(-1.0,  0.0, -1.0),\n                                     vec3( 0.0,  1.0,  1.0),\n                                     vec3( 0.0, -1.0,  1.0),\n                                     vec3( 0.0, -1.0, -1.0) );\n    \n    return vecs[int(rand3(p) * 12.0)];\n}\n\n\n// this realization from: \n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\nfloat simplexNoise3(vec3 p)\n{\n    const float K1 = 0.33333333; // 1.0 / 3.0 (skew factor)\n    const float K2 = 0.16666667; // 1.0 / 6.0 (unskew factor)\n    \n    float s = (p.x + p.y + p.z) * K1;\n    vec3 i = floor(p + s);\n    \n    float t = (i.x + i.y + i.z) * K2;\n    vec3 ti = i - t;\n    vec3 a = p - ti;\n    \n    vec3 o1, o2;\n    if(a.x > a.y)\n    {\n        if(a.y > a.z)\n            { o1 = vec3(1.0, 0.0, 0.0); o2 = vec3(1.0, 1.0, 0.0); } // X Y Z order\n        else if(a.x > a.z)\n            { o1 = vec3(1.0, 0.0, 0.0); o2 = vec3(1.0, 0.0, 1.0); } // X Z Y order\n        else\n            { o1 = vec3(0.0, 0.0, 1.0); o2 = vec3(1.0, 0.0, 1.0); } // Z X Y order \n    }\n    else\n    {\n        if(a.y < a.z) \n            { o1 = vec3(0.0, 0.0, 1.0); o2 = vec3(0.0, 1.0, 1.0); } // Z Y X order\n        else if(a.x < a.z) \n            { o1 = vec3(0.0, 1.0, 0.0); o2 = vec3(0.0, 1.0, 1.0); } // Y Z X order\n        else\n            { o1 = vec3(0.0, 1.0, 0.0); o2 = vec3(1.0, 1.0, 0.0); } // Y X Z order\n    }\n    \n    vec3 b = a - o1 + K2;\n    vec3 c = a - o2 + 2.0 * K2;\n    vec3 d = a - 1.0 + 3.0 * K2;\n    \n    \n    vec3 g1 = simplexVector3(i);\n    vec3 g2 = simplexVector3(i + o1);\n    vec3 g3 = simplexVector3(i + o2);\n    vec3 g4 = simplexVector3(i + 1.0);\n    \n    float t1 = 0.5 - (a.x * a.x) - (a.y * a.y) - (a.z * a.z);\n    float t2 = 0.5 - (b.x * b.x) - (b.y * b.y) - (b.z * b.z);\n    float t3 = 0.5 - (c.x * c.x) - (c.y * c.y) - (c.z * c.z);\n    float t4 = 0.5 - (d.x * d.x) - (d.y * d.y) - (d.z * d.z);\n    \n    float n1 = float(t1 > 0.0) * (t1 * t1 * t1 * t1 * dot(g1, a));\n    float n2 = float(t2 > 0.0) * (t2 * t2 * t2 * t2 * dot(g2, b));\n    float n3 = float(t3 > 0.0) * (t3 * t3 * t3 * t3 * dot(g3, c));\n    float n4 = float(t4 > 0.0) * (t4 * t4 * t4 * t4 * dot(g4, d));\n        \n    return 70.0 * (n1 + n2 + n3 + n4); // return a value in a range [-1.0 - 1.0]\n}\n\nfloat simplexFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        #ifdef NO_EFFECTS\n        \tres += (0.5 + simplexNoise3(pos) * 0.5) * amplitude;\n        #else\n        \tres += abs(simplexNoise3(pos) * amplitude);\n        #endif\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Cellular noise -----------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nfloat calcCell(vec3 pos, vec3 ipos)\n{\n    float md = 1.0; // min distance\n    for(float x = 0.1; x < POINTS_IN_CELL; x++)\n    {   \n        float ptX = rand3(ipos + x);\n        float ptY = rand1(ptX);\n        float ptZ = rand1(ptY);\n        \n        md = min(md, distance(pos, ipos + vec3(ptX, ptY, ptZ)));\n    }\n    return md;\n}\n\nfloat calcCells(vec3 pos)\n{\n    float res = 1.0;\n    \n    vec3 ipos = floor(pos);\n    \n    // front side (z=-1)\n    res = min(res, calcCell(pos, ipos + vec3(-1.0, -1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0, -1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0, -1.0, -1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  0.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  0.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  0.0, -1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  1.0, -1.0)));\n    \n    // center side (z=0)\n    res = min(res, calcCell(pos, ipos + vec3(-1.0, -1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0, -1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0, -1.0,  0.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  0.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  0.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  0.0,  0.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  1.0,  0.0)));\n    \n    // back side   (z=1)\n    res = min(res, calcCell(pos, ipos + vec3(-1.0, -1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0, -1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0, -1.0,  1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  0.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  0.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  0.0,  1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  1.0,  1.0)));\n    \n    return res;\n}\n\nfloat cellularFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        res += calcCells(pos) * amplitude;\n        //res += max(0.45, calcCells(pos) * amplitude);\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n\n//----------------------------------------------------------------------------------\n//- Effects ------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec3 seaEffect(vec3 pos)\n{\n    pos.z = iTime * 0.2;\n    pos.xy += vec2(iTime * 0.4);\n    return vec3(0.4, 0.7, 0.7) * 2.0 * cellularFBM3(pos, 1);\n}\n\nvec3 toxicEffect(vec3 pos)\n{\n    pos.z = iTime * 0.03;\n    return mix(vec3(0.0, 0.5, 0.0), vec3(0.05, 0.0 , 0.0), simplexFBM3(pos, 6) * 4.2) * 2.0;\n}\n\nvec3 cloudEffect(vec3 pos)\n{\n    pos.z = iTime * 0.8;\n    pos.xy += -iTime * 0.2;\n    return vec3(0.6, 0.6, 1.0) + vec3(perlinFBM3(pos * 0.5, 6));\n}\n\nvec3 fireEffect(vec3 pos)\n{\n    pos.z = iTime * 0.1;\n    return mix(vec3(1.0, 1.0, 0.0), vec3(0.7, 0.0, 0.0), valueFBM3(pos, 6) * 8.0) * 1.5;\n}\n\n//----------------------------------------------------------------------------------\n//- Main ---------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = calcAspect(iResolution.xy);\n\n    vec3 nPos = vec3(vec2(uv * aspect * vec2(SCALE)), iTime * SPEED) * 1.5;\n\t\n    \n    vec3 rgb;\n    \n    #ifdef NO_EFFECTS\n        if(uv.x < 0.5 && uv.y < 0.5)\n            rgb = vec3(valueFBM3(nPos, OCTAVES));\n        else if(uv.x > 0.5 && uv.y < 0.5)\n            rgb = vec3(perlinFBM3(nPos, OCTAVES));\n        else if(uv.x > 0.5 && uv.y >= 0.5)\n            rgb = vec3(simplexFBM3(nPos, OCTAVES));\n        else\n            rgb = vec3(cellularFBM3(nPos, OCTAVES));\n    #else\n        if(uv.x < 0.5 && uv.y < 0.5)\n            rgb = fireEffect(nPos);\n        else if(uv.x > 0.5 && uv.y < 0.5)\n            rgb = cloudEffect(nPos);\n        else if(uv.x > 0.5 && uv.y >= 0.5)\n            rgb = toxicEffect(nPos);\n        else\n            rgb = seaEffect(nPos);\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}