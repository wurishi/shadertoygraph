{"ver":"0.1","info":{"id":"fdKyRR","date":"1654303731","viewed":68,"name":"CS77 - Final Project Water 2","username":"selim5","description":"Waves ~","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cs77"],"hasliked":0,"parentid":"7ddcWl","parentname":"Fork CS77 - Fin stjepanvrb 879"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A documented version of \"Seascape\" for learning purposes.  Original shader page here:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME;\n\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = 1.0-e.y,2.0;\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n\n    vec2 uv = p.xz;\n    //uv.x *= 0.75;\n    uv.x = abs(mod(abs(uv.x)/iResolution.x,iResolution.x));\n    uv.y = abs(mod(abs(uv.y)/iResolution.y,iResolution.y));\n    \n    vec4 color = texture(iChannel0, uv);\n    float h = color.x;\n\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    vec2 uv = p.xz;\n    //uv.x *= 0.75;\n    uv.x += 2.*sin(uv.x*0.5);\n    uv.x = abs(mod(abs(uv.x)/iResolution.x,iResolution.x));\n    uv.y = abs(mod(abs(uv.y)/iResolution.y,iResolution.y));\n    \n    \n    vec4 color = texture(iChannel0, uv);\n    float h = color.y;\n\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    //eps = 1.;\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     float EPSILON_NRM\t= 0.1 / iResolution.x;\n    float SEA_TIME = iTime * SEA_SPEED;\n\n\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 0.3 + iMouse.x*0.01; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n\n    // bteitler: Calculated a vector that smoothly changes over time in a sinusoidal (wave) pattern.  \n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);\n    \n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5, at x 0 (zero), and flies over the ocean in the z axis over time.\n    vec3 ori = vec3(0.0,3.5,time*5.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    // dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n\n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n        \n    // post\n    \n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// RANDOM \nfloat g_seed = 1.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\n\n// COMPLEX NUMBERS\nstruct complex\n{\t\n\tfloat real;\n\tfloat im;\n};\n\ncomplex mul(complex c0, complex c1)\n{\n\tcomplex c;\n\tc.real = c0.real * c1.real - c0.im * c1.im;\n\tc.im   = c0.real * c1.im + c0.im * c1.real;\n\treturn c;\n}\n\ncomplex add(complex c0, complex c1)\n{\n\tcomplex c;\n\tc.real = c0.real + c1.real;\n\tc.im   = c0.im   + c1.im;\n\treturn c;\n}\n\ncomplex conj(complex c)\n{\n\tcomplex c_conj = complex(c.real, -c.im);\n\t\n\treturn c_conj;\n}\n\n#define TIME  1.                              // 0 or 1 or speed\nconst float Z = 1., Z2 = 1., Z3 = 1.;         \n// overload via defines                  \n//#define Z     floor(exp2(4.*iMouse.y/R.y))  // Z: big pixels (lower FFT resolution )\n//#define Z2 Z                                // Z2: scale spectrum\n//#define Z3 4. // Z2.                        // Z3: scale space output\n#define MOUSE 1      // mouse controls what    1: lobe position 2: scale\n\n#define R  iResolution.xy\n#define SIZE   ( 2.*floor( R.x/(Z)/4. *1. ) ) // FFT resolution\n                                   // .8 if bandguard requires\n#define SIZEt  ( (Z) * SIZE )                 // subwindow visible size\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\n\nuniform sampler2D noise_r0;\nuniform sampler2D noise_i0;\nuniform sampler2D noise_r1;\nuniform sampler2D noise_i1;\n\nint N = 256;\nfloat L = 1000.;\nfloat amplitude = 60.;\nfloat intensity = 56.;\nvec2 direction = vec2(1.,0.);\nfloat l;\nfloat alignment;\nfloat t;\n\nconst float g = 9.81;\n\n\n// Box-Muller-Method\n\nvec4 gaussRND(vec2 coord)\n{\t\n\tvec2 texCoord = vec2(coord)/float(N);\n\t\n\t//float noise00 = clamp(texture(noise_r0, texCoord).r, 0.001, 1.0);\n\t//float noise01 = clamp(texture(noise_i0, texCoord).r, 0.001, 1.0);\n\t//float noise02 = clamp(texture(noise_r1, texCoord).r, 0.001, 1.0);\n\t//float noise03 = clamp(texture(noise_i1, texCoord).r, 0.001, 1.0);\n\t\n    float noise00 = clamp(rand1(g_seed), 0.001, 1.0);\n\tfloat noise01 = clamp(rand1(g_seed), 0.001, 1.0);\n\tfloat noise02 = clamp(rand1(g_seed), 0.001, 1.0);\n\tfloat noise03 = clamp(rand1(g_seed), 0.001, 1.0);\n    \n\tfloat u0 = 2.0*M_PI*noise00;\n\tfloat v0 = sqrt(-2.0 * log(noise01));\n\tfloat u1 = 2.0*M_PI*noise02;\n\tfloat v1 = sqrt(-2.0 * log(noise03));\n\t\n\tvec4 rnd = vec4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));\n\t\n\treturn rnd;\n}\n\n\nvec4 get_h0k_tilde(vec2 coord, float L)\n{\n\tvec2 x = vec2(coord) - float(N)/2.0;\n\t\n\tvec2 k = vec2(2.0 * M_PI * x.x/L, 2.0 * M_PI * x.y/L);\n\n\tfloat L_ = (intensity * intensity)/g;\n\tfloat mag = length(k);\n\tif (mag < 0.0001) mag = 0.0001;\n\tfloat magSq = mag * mag;\n\t\n\t//sqrt(Ph(k))/sqrt(2)\n\tfloat h0k = clamp(sqrt((amplitude/(magSq*magSq)) * pow(dot(normalize(k), normalize(direction)), 2.) * \n\t\t\t\texp(-(1.0/(magSq * L_ * L_))) * exp(-magSq*pow(l,2.0)))/ sqrt(2.0), -4000.0, 4000.0);\n\t\n\t//sqrt(Ph(-k))/sqrt(2)\n\t//float h0minusk = clamp(sqrt((amplitude/(magSq*magSq)) * pow(dot(normalize(-k), normalize(direction)), 2) * \n\t\t\t\t\t //exp(-(1.0/(magSq * L_ * L_))) * exp(-magSq*pow(l,2.0)))/ sqrt(2.0), -4000.0, 4000.0);\n\t\n\tvec4 gauss_random = gaussRND(x);\n\t\n\treturn vec4(gauss_random.xy * h0k, 0., 1.);\n}\n\nvec4 get_minus_h0k_tilde(vec2 coord, float L)\n{\n\tvec2 x = vec2(coord) - float(N)/2.0;\n\t\n\tvec2 k = vec2(2.0 * M_PI * x.x/L, 2.0 * M_PI * x.y/L);\n\n\tfloat L_ = (intensity * intensity)/g;\n\tfloat mag = length(k);\n\tif (mag < 0.0001) mag = 0.0001;\n\tfloat magSq = mag * mag;\n\t\n\t//sqrt(Ph(-k))/sqrt(2)\n\tfloat h0minusk = clamp(sqrt((amplitude/(magSq*magSq)) * pow(dot(normalize(-k), normalize(direction)), 2.) * \n\t\t\t\t\t exp(-(1.0/(magSq * L_ * L_))) * exp(-magSq*pow(l,2.0)))/ sqrt(2.0), -4000.0, 4000.0);\n\t\n\tvec4 gauss_random = gaussRND(x);\n\t\n\treturn vec4(gauss_random.zw * h0minusk, 0., 1.);\n}\n\nvec4 get_hkt(vec2 coord, float L) {\n    vec2 x = vec2(coord) - float(N)/2.0;\n\t\n\tvec2 k = vec2(2.0 * M_PI * x.x/L, 2.0 * M_PI * x.y/L);\n\t\n\tfloat magnitude = length(k);\n\tif (magnitude < 0.00001) magnitude = 0.00001;\n\t\n\tfloat w = sqrt(g * magnitude);\n\t\n    vec4 h0k_tilde = get_h0k_tilde(coord, L);\n\tcomplex fourier_amp = complex(h0k_tilde.r, \n\t\t\t\t\t\t\th0k_tilde.g);\n\t\n    vec4 minus_h0k_tilde = get_minus_h0k_tilde(coord, L);\n\tcomplex fourier_amp_conj = conj(complex(minus_h0k_tilde.r, \n\t\t\t\t\t\t\t\tminus_h0k_tilde.g));\n\t\t\n\tfloat cosinus = cos(w*t);\n\tfloat sinus   = sin(w*t);\n\t\t\n\t// euler formula\n\tcomplex exp_iwt = complex(cosinus, sinus);\n\tcomplex exp_iwt_inv = complex(cosinus, -sinus);\n\t\n\t// dy\n\tcomplex h_k_t_dy = add(mul(fourier_amp, exp_iwt), (mul(fourier_amp_conj, exp_iwt_inv)));\n\t\n\t// dx\n\tcomplex dx = complex(0.0,-k.x/magnitude);\n\tcomplex h_k_t_dx = mul(dx, h_k_t_dy);\n\t\n\t// dz\n\tcomplex dy = complex(0.0,-k.y/magnitude);\n\tcomplex h_k_t_dz = mul(dy, h_k_t_dy);\n\t\t\n\treturn vec4(h_k_t_dy.real, h_k_t_dy.im, 0., 1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime/.5;\n    g_seed = (fragCoord.x*fragCoord.y)/(fragCoord.x+fragCoord.y);\n    fragColor = get_hkt(fragCoord, L);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define tex(ch,x,y)  texelFetch(ch, ivec2(x,y), 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x)*vec2(cos(b), sin(b)); } \n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O-=O; \n\n\n    for(float n = 0.; n < SIZE; n++)  {\n        vec2 xn = tex(iChannel0, n+.5, uv.y).xy,\n             yn = tex(iChannel1, uv.x, n+.5).zw,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n    O /= SIZE*.5;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(vec4((length(color.xy))));\n}\n","name":"Buffer C","description":"","type":"buffer"}]}