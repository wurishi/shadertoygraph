{"ver":"0.1","info":{"id":"XstGz2","date":"1450955597","viewed":553,"name":"Interlace for performance","username":"104","description":"Drawing every other pixel each frame, using discard. I would expect a performance increase but I don't. Any ideas why?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["interlace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// i want to use 'discard' to only draw half the pixels for each frame.\n// so I draw every other pixel each frame, occasionally changing parity\n// to draw the others. The result is a sort of interlacing effect.\n\n// I would expect this to almost double the framerate for shaders,\n// but actually I don't find much performance change at all. No idea why.\n\n\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    // copy & paste this to the top of any shader to apply the interlace effect.\n    //-------------------------------------------\n    {\n        const float interval = 80.;//milliseconds per parity change. normally should be once per frame\n        const float interlaceSize = 4.;//pixels; should be divisible by 2\n        // is this pixel allowed to draw this frame?\n        vec2 z2 = sign(sin(i/interlaceSize * 6.2831853));\n        float z = clamp(z2.x*z2.y,0.,1.);// creates a checkerboard pattern; think xor pattern\n        float parity = sign(fract(iTime*1000./interval)-.5)*.5+.5;\n        // parity is 0 or 1\n        if(z == parity)\n        {\n            discard;\n            return;\n        }\n    }\n    //-------------------------------------------\n\n    \n    \n    // the actual effect I want to display\n    i=(i-.5*(o.xy=iResolution.xy))/o.y;\n\to=i.xyyy+1.-length(i+mod(i.x+i*i.yx+iTime*.2,.1));\n}\n\n","name":"","description":"","type":"image"}]}