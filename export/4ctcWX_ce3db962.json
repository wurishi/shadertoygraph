{"ver":"0.1","info":{"id":"4ctcWX","date":"1731266765","viewed":34,"name":"Rendu_final","username":"amine830","description":"mini ray tracing project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\nconst float PI = 3.1415926535897932384626433832795;\n\n// Fonction pour générer un nombre pseudo-aléatoire\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// Struct pour définir un materieau\nstruct Material {\n    vec3 ambient;    // Coefficient ambiant (k_a)\n    vec3 diffuse;    // Coefficient diffus (k_d)\n    vec3 specular;   // Coefficient spéculaire (k_s)\n    float shininess; // Shininess (α)\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n};\n\nstruct Object {\n    Material material;\n    int textureType; // 0 for none, 1 for marble, 2 for wood, etc.\n};\n\n//Definir des bjets avec différents types de texture\nObject normalObj = Object(Material(vec3(0.2, 0.2, 0.2), vec3(0.4, 0.5, 0.5), vec3(0.5, 0.5, 0.9), 32.0), 0);\nObject marbleObj = Object(Material(vec3(0.2, 0.2, 0.2), vec3(0.4, 0.5, 0.5), vec3(0.5, 0.5, 0.9), 32.0), 1);\nObject   woodObj = Object(Material(vec3(0.2, 0.2, 0.2), vec3(0.4, 0.5, 0.5), vec3(0.5, 0.5, 0.9), 32.0), 2);\nObject  metalObj = Object(Material(vec3(0.3, 0.3, 0.3), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0), 64.0), 3);\nObject  stoneObj = Object(Material(vec3(0.2, 0.2, 0.2), vec3(0.5, 0.5, 0.5), vec3(0.4, 0.4, 0.4), 20.0), 4);\nObject  glassObj = Object(Material(vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.9), vec3(0.8, 0.9, 1.0), 128.0), 5);\nObject   blueObj = Object(Material(vec3(0.1, 0.1, 0.3), vec3(0.2, 0.2, 0.6), vec3(0.5, 0.5, 0.9), 32.0), 6);\nObject  greenObj = Object(Material(vec3(0.1, 0.3, 0.1), vec3(0.2, 0.6, 0.2), vec3(0.5, 0.9, 0.5), 32.0), 7);\nObject    redObj = Object(Material(vec3(0.3, 0.1, 0.1), vec3(0.6, 0.2, 0.2), vec3(0.9, 0.5, 0.5), 32.0), 8);\nObject   cyanObj = Object(Material(vec3(0.1, 0.3, 0.3), vec3(0.2, 0.6, 0.6), vec3(0.5, 0.9, 0.9), 32.0), 9);\nObject yellowObj = Object(Material(vec3(0.3, 0.3, 0.1), vec3(0.6, 0.6, 0.2), vec3(0.9, 0.9, 0.5), 32.0), 10);\nObject mgentaObj = Object(Material(vec3(0.3, 0.1, 0.3), vec3(0.6, 0.2, 0.6), vec3(0.9, 0.5, 0.9), 32.0), 11);\n\n// Modified object function to return both Val and Object\nstruct ValObject {\n    Val val;\n    Object obj;\n};\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n// Function to create a rotating camera\nRay CreateRotatingCameraRay(vec2 m, vec2 p, float time)\n{\n    float a = 0.2 * time; // Angle based on time for smooth rotation\n    float le = 3.5;\n\n    // Origin\n    vec3 ro = vec3(37., 0., 15.);\n    ro *= Rz(a);\n\n    // Target point\n    vec3 ta = vec3(0., 0., 1.);\n\n    // Orthonormal frame\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(p.x * u + p.y * v + le * w);\n    return Ray(ro, rd);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 n, vec3 o)\n{\n    return Val(dot((p-o),n),1);\n}\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p,vec3 c,float r)\n{\n  return Val(length(p-c)-r,1);\n}\n\n// Cube\n// p : point\n// c : center of the cube\n// size : half dimensions of the cube (half-width, half-height, half-depth)\nVal Cube(vec3 p, vec3 c, vec3 size)\n{\n    // Calculer la différence entre le point et le centre du cube\n    vec3 d = abs(p - c) - size;\n\n    // Calculer la distance signée\n    // Si le point est à l'extérieur du cube, on calcule la distance euclidienne au bord\n    float outsideDist = length(max(d, vec3(0.0)));\n\n    // Si le point est à l'intérieur du cube, on prend la distance maximale des composantes négatives\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0);\n\n    // La distance signée est la combinaison de la distance extérieure et intérieure\n    float dist = outsideDist + insideDist;\n\n    // Retourner la distance signée et le coût (ici 1)\n    return Val(dist, 1);\n}\n\n// Ellipsoid\n// p : point\n// c : center of the ellipsoid\n// radii : radii along x, y, and z axes (half-width, half-height, half-depth)\nVal Ellipsoid(vec3 p, vec3 c, vec3 radii)\n{\n    // Appliquer la mise à l'échelle inverse pour ramener l'ellipsoïde à une sphère\n    vec3 scaledPoint = (p - c) / radii;\n\n    // Calculer la distance signée pour une sphère de rayon 1 dans l'espace transformé\n    float distance = length(scaledPoint) - 1.0;\n\n    // Retourner la distance signée et le coût (ici 1)\n    return Val(distance, 1);\n}\n\n// Cylinder\n// p : point\n// c : center of the base of the cylinder\n// r : radius of the cylinder\n// h : height of the cylinder\nVal Cylinder(vec3 p, vec3 c, float r, float h)\n{\n    // Déplacer le point p par rapport au centre du cylindre\n    vec3 d = p - c;\n    \n    // Distance au cylindre dans le plan XY (ignorer la composante z pour cette étape)\n    vec2 d_xy = vec2(d.x, d.y);\n    float distanceToSides = length(d_xy) - r;\n\n    // Distance dans la direction z, calculée pour la hauteur\n    float distanceToCaps = abs(d.z) - h;\n\n    // Distance totale combinée\n    float outsideDist = length(max(vec2(distanceToSides, distanceToCaps), vec2(0.0)));\n    float insideDist = min(max(distanceToSides, distanceToCaps), 0.0);\n\n    // La distance signée est la combinaison des distances extérieure et intérieure\n    float dist = outsideDist + insideDist;\n\n    // Retourner la distance signée et le coût (ici 1)\n    return Val(dist, 1);\n}\n\n// Torus\n// p : point\n// c : center of the torus\n// R : radius of the big circle (grand cercle)\n// r : radius of the tube (petit cercle)\nVal Torus(vec3 p, vec3 c, float R, float r)\n{\n    // Déplacer le point p par rapport au centre du tore\n    vec3 d = p - c;\n\n    // Calculer la distance au grand cercle (projeté dans le plan XY)\n    vec2 q = vec2(length(vec2(d.x, d.y)) - R, d.z);\n\n    // Calculer la distance signée au petit cercle\n    float distance = length(q) - r;\n\n    // Retourner la distance signée et le coût (ici 1)\n    return Val(distance, 1);\n}\n\n// Capsule\n// p : point\n// a : first endpoint of the capsule\n// b : second endpoint of the capsule\n// r : radius of the capsule\nVal Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    // Direction du segment AB\n    vec3 ab = b - a;\n    \n    // Projection du point p sur le segment AB\n    float t = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    \n    // Point projeté le long du segment AB\n    vec3 closestPoint = a + t * ab;\n    \n    // Calculer la distance du point p au point projeté\n    float distance = length(p - closestPoint) - r;\n    \n    // Retourner la distance signée et le coût (ici 1)\n    return Val(distance, 1);\n}\n\n// ---------------------------------------------\n//           OPERATORS :\n// ---------------------------------------------\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a,Val b)\n{\n  return Val(min(a.v,b.v),a.c+b.c+1);\n}\n\n// Intersection\n// a,b : field function of left and right sub-trees\nVal Intersection(Val a, Val b)\n{\n  return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n\n// Difference\n// a,b : field function of left and right sub-trees\nVal Difference(Val a, Val b)\n{\n  return Val(max(a.v, -b.v), a.c + b.c + 1);\n}\n\n// ---------------------------------------------\n//           TRANSFORMATIONS :\n// ---------------------------------------------\n\n// TRANSLATION :\n// p : point à transformer\n// translation : vecteur de translation\nvec3 Translate(vec3 p, vec3 translation)\n{\n    return p - translation; // Appliquer la translation inverse sur le point\n}\n\n// ROTATIONS :-------------------------\nmat3 RotX(float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, ca, -sa,\n        0.0, sa, ca\n    );\n}\nmat3 RotY(float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return mat3(\n        ca, 0.0, sa,\n        0.0, 1.0, 0.0,\n        -sa, 0.0, ca\n    );\n}\nmat3 RotZ(float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return mat3(\n        ca, -sa, 0.0,\n        sa, ca, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n//----------------------------------------------\n\n// SCALE (homothétie)\n// p : point à transformer\n// scale : vecteur d'échelle (pour chaque axe)\nvec3 Scale(vec3 p, vec3 scale)\n{\n    return p / scale; // Appliquer l'inverse de l'échelle sur le point\n}\n\n// -----------------------------------------------------------------------------------------\n\n// Combiner les transformations : Translation, Rotation, Scaling\n// p : point à transformer\n// translation : vecteur de translation\n// scale : vecteur d'échelle\n// rotationAngle : angle de rotation (en radians)\nvec3 Transform(vec3 p, vec3 translation, vec3 scale, vec3 rotationAngles) {\n    // Convertir les angles de rotation de degrés en radians\n    float rx = rotationAngles.x * (PI / 180.0);\n    float ry = rotationAngles.y * (PI / 180.0);\n    float rz = rotationAngles.z * (PI / 180.0);\n\n    // Appliquer les rotations (rotation sur l'axe X, puis Y, puis Z)\n    mat3 rotationMatrix = RotX(rx) * RotY(ry) * RotZ(rz);\n\n    // Appliquer l'homothétie\n    vec3 scaledPoint = p / scale;\n\n    // Appliquer la rotation\n    vec3 rotatedPoint = rotationMatrix * scaledPoint;\n\n    // Appliquer la translation\n    vec3 transformedPoint = rotatedPoint + translation;\n\n    return transformedPoint;\n}\n\n// -----------------------------------------------------------------------------------------\n//                BRUIT & TURBULANCE\n// -----------------------------------------------------------------------------------------\n\n// Hash function\nfloat Hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// Smooth interpolation function (Cubic Hermite interpolation)\n// Apply smooth step to a float\nfloat SmoothStep(float t) {\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Overload to apply smooth step to a vec3\nvec3 SmoothStep(vec3 t) {\n    return vec3(SmoothStep(t.x), SmoothStep(t.y), SmoothStep(t.z));\n}\n\n\n// 3D Noise function\nfloat Noise(vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    // Use smoother interpolation for the fractional part\n    fp = SmoothStep(fp);\n\n    float res = mix(\n        mix(\n            mix(Hash(ip.x + ip.y * 157.0 + ip.z * 113.0),\n                Hash(ip.x + 1.0 + ip.y * 157.0 + ip.z * 113.0),\n                fp.x),\n            mix(Hash(ip.x + (ip.y + 1.0) * 157.0 + ip.z * 113.0),\n                Hash(ip.x + 1.0 + (ip.y + 1.0) * 157.0 + ip.z * 113.0),\n                fp.x),\n            fp.y),\n        mix(\n            mix(Hash(ip.x + ip.y * 157.0 + (ip.z + 1.0) * 113.0),\n                Hash(ip.x + 1.0 + ip.y * 157.0 + (ip.z + 1.0) * 113.0),\n                fp.x),\n            mix(Hash(ip.x + (ip.y + 1.0) * 157.0 + (ip.z + 1.0) * 113.0),\n                Hash(ip.x + 1.0 + (ip.y + 1.0) * 157.0 + (ip.z + 1.0) * 113.0),\n                fp.x),\n            fp.y),\n        fp.z);\n    return res;\n}\n\n// Deformation function\nvec3 Deform(vec3 p, float intensity) {\n    // Calculate noise value based on the point\n    float noiseValue = Noise(p);\n\n    // Apply deformation using the noise and the intensity\n    // We avoid normalizing p to prevent uniform stretching\n    return p + intensity * noiseValue *p;\n}\n\n// ------------------------------------------------------------------------------\nfloat NoiseTurb(vec3 p)\n{\n    // Fonction de bruit simple\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\nfloat Turbulence(vec3 p, float scale, int octaves)\n{\n    // Fonction pour créer de la turbulence avec plusieurs octaves\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float turbulence = 0.0;\n\n    for (int i = 0; i < octaves; i++)\n    {\n        turbulence += abs(NoiseTurb(p * frequency)) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return turbulence * scale;\n}\n\nvec3 AddTurbulence(vec3 p, float scale, int octaves)\n{\n    // Appliquer la déformation via la turbulence\n    float deformation = Turbulence(p, scale, octaves);\n    return p + vec3(deformation);\n}\n\n// ----------------------------------------------------------\n\n// Noise function for smooth noise\nfloat Noise2(vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float res = mix(\n        mix(\n            mix(Hash(ip.x + ip.y * 157.0 + ip.z * 113.0),\n                Hash(ip.x + 1.0 + ip.y * 157.0 + ip.z * 113.0),\n                fp.x),\n            mix(Hash(ip.x + (ip.y + 1.0) * 157.0 + ip.z * 113.0),\n                Hash(ip.x + 1.0 + (ip.y + 1.0) * 157.0 + ip.z * 113.0),\n                fp.x),\n            fp.y),\n        mix(\n            mix(Hash(ip.x + ip.y * 157.0 + (ip.z + 1.0) * 113.0),\n                Hash(ip.x + 1.0 + ip.y * 157.0 + (ip.z + 1.0) * 113.0),\n                fp.x),\n            mix(Hash(ip.x + (ip.y + 1.0) * 157.0 + (ip.z + 1.0) * 113.0),\n                Hash(ip.x + 1.0 + (ip.y + 1.0) * 157.0 + (ip.z + 1.0) * 113.0),\n                fp.x),\n            fp.y),\n        fp.z);\n    return res;\n}\n\n// Fractional Brownian Motion (fBM) - layering noise at different frequencies\nfloat fBM(vec3 p, int octaves) {\n    float total = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < octaves; i++) {\n        total += Noise2(p * frequency) * amplitude;\n        amplitude *= 0.5;  // Decrease amplitude\n        frequency *= 2.0;  // Increase frequency\n    }\n\n    return total;\n}\n\n// Turbulence function (absolute value of fBM)\nfloat Turbulence(vec3 p, int octaves) {\n    float total = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < octaves; i++) {\n        total += abs(Noise(p * frequency)) * amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n\n    return total;\n}\n\n// Marble texture function using turbulence\nvec3 MarbleTexture(vec3 p) {\n    // Controls the \"vein\" frequency and distortion\n    float frequency = 5.0;\n    float turbulenceValue = Turbulence(p, 5); // Using 5 octaves of turbulence\n    float marblePattern = sin(p.x * frequency + turbulenceValue * 10.0);  // Sin wave for marble veining\n\n    // Convert the pattern to a color (black and white marble for simplicity)\n    vec3 baseColor = vec3(0.9, 0.9, 0.9);  // White base marble\n    vec3 veinColor = vec3(0.1, 0.1, 0.1);  // Dark veins\n\n    // Interpolate between the base and vein color based on the marble pattern\n    return mix(veinColor, baseColor, marblePattern * 0.5 + 0.5);\n}\n \n// Example for wood texture (rings using fBM)\nvec3 WoodTexture(vec3 p) {\n    float scale = 1.0;  // Scale to control the number of rings\n    float woodPattern = fract(p.x * scale + fBM(p, 10));  // fBM to add irregularity to rings\n\n    // Convert the pattern to wood-like colors\n    vec3 lightWood = vec3(0.9, 0.8, 0.2);\n    vec3 darkWood = vec3(0.4, 0.2, 0.1);\n\n    return mix(darkWood, lightWood, woodPattern);\n}\n\nvec3 MetalTexture(vec3 p) {\n    // Texture métallique avec des variations subtiles de gris\n    float pattern = sin(p.x * 10.0) * sin(p.y * 10.0) * 0.5 + 0.5;\n    return mix(vec3(0.7, 0.7, 0.7), vec3(0.9, 0.9, 0.9), pattern);\n}\nvec3 StoneTexture(vec3 p) {\n    // Texture pierre avec des variations rugueuses\n    float noise = fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n    return mix(vec3(0.5, 0.5, 0.5), vec3(0.3, 0.3, 0.3), noise);\n}\nvec3 GlassTexture(vec3 p) {\n    // Texture transparente avec reflets bleutés\n    float pattern = fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n    return mix(vec3(0.8, 0.9, 1.0), vec3(0.9, 1.0, 1.0), pattern);\n}\n\n\n// Function pour récupérer la texture selon le type d'objet\nvec3 GetTextureColor(vec3 p, int textureType) {\n    switch (textureType) {\n        case 1:\n            return MarbleTexture(p);    // Glass object texture\n        case 2:\n            return WoodTexture(p);      // // Wood object texture\n        case 3:\n            return MetalTexture(p);     // Metal object texture\n        case 4:\n            return StoneTexture(p);     // Stone object texture\n        case 5:\n            return GlassTexture(p);     // Glass object texture\n        case 6:\n            return vec3(0.1, 0.1, 0.3); // Blue object color\n        case 7:\n            return vec3(0.1, 0.3, 0.1); // Green object color\n        case 8:\n            return vec3(0.3, 0.1, 0.1); // Red object color\n        case 9:\n            return vec3(0.1, 0.3, 0.3); // Cyan object color\n        case 10:\n            return vec3(0.3, 0.3, 0.1); // Yellow object color\n        case 11:\n            return vec3(0.3, 0.1, 0.3); // Magenta object color\n        default:\n            return vec3(1.0); // Couleur par défaut si aucune texture spécifique\n    }\n}\n\nbool RaySphereIntersection(Ray ray, vec3 center, float radius, out float t) {\n    vec3 oc = ray.o - center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(oc, ray.d);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        t = t1 > 0.0 ? t1 : t2;\n        return t > 0.0;\n    }\n    return false;\n}\n\n\n// ------------------------------------------------------\n//           RENDU\n// -----------------------------------------------------\n\nvec3 sceneBoundingSphereCenter = vec3(0.0, 0.0, 0.0);\nfloat sceneBoundingSphereRadius = 20.0;\nbool withTexture=true;\n\nValObject object(vec3 p) {\n        vec3 deformedPoint = Deform(p, 0.2);         // 0.1 est l'intensité de la déformation\n    vec3 turbPoint = AddTurbulence(p, 0.00, 4);  // Ajouter de la turbulence au point déformé\n    vec3 turbDeformPoint = AddTurbulence(p, 0.00, 4);\n\n    // ------------------------------ FORMES DE BASE -------------------------------------------\n\n    // Sol sans texture\n    Val ground = Plane(deformedPoint, vec3(0., 0., 1.), vec3(0.0, 0.0, -2.5));\n    ValObject groundObj;\n    groundObj.val = ground;\n    groundObj.obj = normalObj;  // Pas de texture\n\n    // Cube avec couleur bois\n    vec3 cubeCenter1 = vec3(-13.0, 3.0, 0.0);\n    vec3 cubeSize1 = vec3(2.0, 2.0, 2.0);\n    Val cubeVal1 = Cube(p, cubeCenter1, cubeSize1);\n    ValObject cubeObj1;\n    cubeObj1.val = cubeVal1;\n    cubeObj1.obj = woodObj;\n\n    // Cube avec couleur bleue\n    vec3 cubeCenter2 = vec3(5.0, 3.0, 0.0);\n    vec3 cubeSize2 = vec3(2.0, 2.0, 2.0);\n    Val cubeVal2 = Cube(p, cubeCenter2, cubeSize2);\n    ValObject cubeObj2;\n    cubeObj2.val = cubeVal2;\n    cubeObj2.obj = blueObj;\n\n    // Sphère avec couleur bleue\n    vec3 sphereCenter1 = vec3(-15.0, -3.0, 1.0);\n    float sphereRadius1 = 3.0;\n    Val sphereVal1 = Sphere(p, sphereCenter1, sphereRadius1);\n    ValObject sphereObj1;\n    sphereObj1.val = sphereVal1;\n    sphereObj1.obj = blueObj;\n\n    // Sphère avec couleur jaune\n    vec3 sphereCenter2 = vec3(0.5, -9.0, 2.0);\n    float sphereRadius2 = 3.0;\n    Val sphereVal2 = Sphere(p, sphereCenter2, sphereRadius2);\n    ValObject sphereObj2;\n    sphereObj2.val = sphereVal2;\n    sphereObj2.obj = yellowObj;\n\n    // Ellipsoïde avec couleur verte\n    vec3 ellipsoidCenter1 = vec3(0.0, 8.0, 1.0);\n    vec3 ellipsoidRadii1 = vec3(1.0, 3.5, 1.0);\n    Val ellipsoidVal1 = Ellipsoid(p, ellipsoidCenter1, ellipsoidRadii1);\n    ValObject ellipsoidObj1;\n    ellipsoidObj1.val = ellipsoidVal1;\n    ellipsoidObj1.obj = greenObj;\n\n    // Ellipsoïde avec couleur cyan\n    vec3 ellipsoidCenter2 = vec3(12.0, 3.0, 1.0);\n    vec3 ellipsoidRadii2 = vec3(3.0, 3.5, 5.0);\n    Val ellipsoidVal2 = Ellipsoid(deformedPoint, ellipsoidCenter2, ellipsoidRadii2);\n    ValObject ellipsoidObj2;\n    ellipsoidObj2.val = ellipsoidVal2;\n    ellipsoidObj2.obj = cyanObj;\n\n    // Cylindre avec couleur jaune\n    vec3 cylinderCenter1 = vec3(-8.0, 2.0, 1.5);\n    float cylinderRadius1 = 2.0;\n    float cylinderHeight1 = 3.0;\n    Val cylinderVal1 = Cylinder(turbDeformPoint, cylinderCenter1, cylinderRadius1, cylinderHeight1);\n    ValObject cylinderObj1;\n    cylinderObj1.val = cylinderVal1;\n    cylinderObj1.obj = yellowObj;\n\n    // Cylindre avec couleur verte\n    vec3 cylinderCenter2 = vec3(6.0, -4.0, 1.5);\n    float cylinderRadius2 = 2.5;\n    float cylinderHeight2 = 3.0;\n    Val cylinderVal2 = Cylinder(p, cylinderCenter2, cylinderRadius2, cylinderHeight2);\n    ValObject cylinderObj2;\n    cylinderObj2.val = cylinderVal2;\n    cylinderObj2.obj = greenObj;\n\n    // Torus avec couleur rouge\n    vec3 torusCenter1 = vec3(-7.0, 10.0, -0.9);\n    float bigRadius1 = 3.0;\n    float tubeRadius1 = 1.7;\n    Val torusVal1 = Torus(p, torusCenter1, bigRadius1, tubeRadius1);\n    ValObject torusObj1;\n    torusObj1.val = torusVal1;\n    torusObj1.obj = redObj;\n    \n    vec3 trans = vec3(0.0, 0.0, -2.0);\n    vec3 scale = vec3(1.0, 1.0, 1.0);\n    vec3 rot = vec3(45, 45, 0);\n    vec3 t = Transform(p, trans, scale, rot);\n    // Torus avec couleur magenta\n    vec3 torusCenter2 = vec3(7.0, 10.0, -0.9);\n    float bigRadius2 = 3.0;\n    float tubeRadius2 = 0.7;\n    Val torusVal2 = Torus(t, torusCenter2, bigRadius2, tubeRadius2);\n    ValObject torusObj2;\n    torusObj2.val = torusVal2;\n    torusObj2.obj = mgentaObj;\n\n    // Capsule avec couleur cyan\n    vec3 capsuleStart1 = vec3(-15.0, -10.0, 4.0);\n    vec3 capsuleEnd1 = vec3(-11.0, -3.0, 6.5);\n    float capsuleRadius1 = 1.3;\n    Val capsuleVal1 = Capsule(turbPoint, capsuleStart1, capsuleEnd1, capsuleRadius1);\n    ValObject capsuleObj1;\n    capsuleObj1.val = capsuleVal1;\n    capsuleObj1.obj = cyanObj;\n\n    // Capsule avec couleur red\n    vec3 capsuleStart2 = vec3(8.0, -10.0, 3.0);\n    vec3 capsuleEnd2 = vec3(11.0, -3.0, 3.5);\n    float capsuleRadius2 = 1.3;\n    Val capsuleVal2 = Capsule(p, capsuleStart2, capsuleEnd2, capsuleRadius2);\n    ValObject capsuleObj2;\n    capsuleObj2.val = capsuleVal2;\n    capsuleObj2.obj = woodObj;\n\n    // Union des objets avec leurs couleurs respectives\n    ValObject combinedObj1;\n    combinedObj1.val = Union(Union(Union(Union(Union(Union(Union(Union(Union(Union(Union(Union(groundObj.val, cubeObj1.val), cubeObj2.val), sphereObj1.val), sphereObj2.val), ellipsoidObj1.val), ellipsoidObj2.val), cylinderObj1.val), cylinderObj2.val), torusObj1.val), torusObj2.val), capsuleObj1.val), capsuleObj2.val);\n\n    // Affectation de la couleur en fonction de l’objet avec la plus haute priorité\n    if (capsuleObj2.val.v < capsuleObj1.val.v && capsuleObj2.val.v < torusObj2.val.v && capsuleObj2.val.v < torusObj1.val.v && capsuleObj2.val.v < cylinderObj2.val.v && capsuleObj2.val.v < cylinderObj1.val.v && capsuleObj2.val.v < ellipsoidObj2.val.v && capsuleObj2.val.v < ellipsoidObj1.val.v && capsuleObj2.val.v < sphereObj2.val.v && capsuleObj2.val.v < sphereObj1.val.v && capsuleObj2.val.v < cubeObj2.val.v && capsuleObj2.val.v < cubeObj1.val.v && capsuleObj2.val.v < groundObj.val.v) {\n        combinedObj1.obj = capsuleObj2.obj;\n    } else if (capsuleObj1.val.v < torusObj2.val.v && capsuleObj1.val.v < torusObj1.val.v && capsuleObj1.val.v < cylinderObj2.val.v && capsuleObj1.val.v < cylinderObj1.val.v && capsuleObj1.val.v < ellipsoidObj2.val.v && capsuleObj1.val.v < ellipsoidObj1.val.v && capsuleObj1.val.v < sphereObj2.val.v && capsuleObj1.val.v < sphereObj1.val.v && capsuleObj1.val.v < cubeObj2.val.v && capsuleObj1.val.v < cubeObj1.val.v && capsuleObj1.val.v < groundObj.val.v) {\n        combinedObj1.obj = capsuleObj1.obj;\n    } else if (torusObj2.val.v < torusObj1.val.v && torusObj2.val.v < cylinderObj2.val.v && torusObj2.val.v < cylinderObj1.val.v && torusObj2.val.v < ellipsoidObj2.val.v && torusObj2.val.v < ellipsoidObj1.val.v && torusObj2.val.v < sphereObj2.val.v && torusObj2.val.v < sphereObj1.val.v && torusObj2.val.v < cubeObj2.val.v && torusObj2.val.v < cubeObj1.val.v && torusObj2.val.v < groundObj.val.v) {\n        combinedObj1.obj = torusObj2.obj;\n    } else if (torusObj1.val.v < cylinderObj2.val.v && torusObj1.val.v < cylinderObj1.val.v && torusObj1.val.v < ellipsoidObj2.val.v && torusObj1.val.v < ellipsoidObj1.val.v && torusObj1.val.v < sphereObj2.val.v && torusObj1.val.v < sphereObj1.val.v && torusObj1.val.v < cubeObj2.val.v && torusObj1.val.v < cubeObj1.val.v && torusObj1.val.v < groundObj.val.v) {\n        combinedObj1.obj = torusObj1.obj;\n    } else if (cylinderObj2.val.v < cylinderObj1.val.v && cylinderObj2.val.v < ellipsoidObj2.val.v && cylinderObj2.val.v < ellipsoidObj1.val.v && cylinderObj2.val.v < sphereObj2.val.v && cylinderObj2.val.v < sphereObj1.val.v && cylinderObj2.val.v < cubeObj2.val.v && cylinderObj2.val.v < cubeObj1.val.v && cylinderObj2.val.v < groundObj.val.v) {\n        combinedObj1.obj = cylinderObj2.obj;\n    } else if (cylinderObj1.val.v < ellipsoidObj2.val.v && cylinderObj1.val.v < ellipsoidObj1.val.v && cylinderObj1.val.v < sphereObj2.val.v && cylinderObj1.val.v < sphereObj1.val.v && cylinderObj1.val.v < cubeObj2.val.v && cylinderObj1.val.v < cubeObj1.val.v && cylinderObj1.val.v < groundObj.val.v) {\n        combinedObj1.obj = cylinderObj1.obj;\n    } else if (ellipsoidObj2.val.v < ellipsoidObj1.val.v && ellipsoidObj2.val.v < sphereObj2.val.v && ellipsoidObj2.val.v < sphereObj1.val.v && ellipsoidObj2.val.v < cubeObj2.val.v && ellipsoidObj2.val.v < cubeObj1.val.v && ellipsoidObj2.val.v < groundObj.val.v) {\n        combinedObj1.obj = ellipsoidObj2.obj;\n    } else if (ellipsoidObj1.val.v < sphereObj2.val.v && ellipsoidObj1.val.v < sphereObj1.val.v && ellipsoidObj1.val.v < cubeObj2.val.v && ellipsoidObj1.val.v < cubeObj1.val.v && ellipsoidObj1.val.v < groundObj.val.v) {\n        combinedObj1.obj = ellipsoidObj1.obj;\n    } else if (sphereObj2.val.v < sphereObj1.val.v && sphereObj2.val.v < cubeObj2.val.v && sphereObj2.val.v < cubeObj1.val.v && sphereObj2.val.v < groundObj.val.v) {\n        combinedObj1.obj = sphereObj2.obj;\n    } else if (sphereObj1.val.v < cubeObj2.val.v && sphereObj1.val.v < cubeObj1.val.v && sphereObj1.val.v < groundObj.val.v) {\n        combinedObj1.obj = sphereObj1.obj;\n    } else if (cubeObj2.val.v < cubeObj1.val.v && cubeObj2.val.v < groundObj.val.v) {\n        combinedObj1.obj = cubeObj2.obj;\n    } else if (cubeObj1.val.v < groundObj.val.v) {\n        combinedObj1.obj = cubeObj1.obj;\n    } else {\n        combinedObj1.obj = groundObj.obj;\n    }\n\n    // ------------------------------ FORMES DE BASE 2 -------------------------------------------\n\n    // Cube avec texture glasse\n    vec3 cubeCenter = vec3(0.0, 9.0, -0.6);\n    vec3 cubeSize = vec3(2.0, 3.0, 1.0);\n    Val cubeVal = Cube(p, cubeCenter, cubeSize);\n    ValObject cubeObj;\n    cubeObj.val = cubeVal;\n    cubeObj.obj = glassObj;\n\n    // Sphère avec texture marbre\n    vec3 sphereCenter = vec3(-7.0, -9.0, 1.0);\n    float sphereRadius = 3.0;\n    Val sphereVal = Sphere(p, sphereCenter, sphereRadius);\n    ValObject sphereObj;\n    sphereObj.val = sphereVal;\n    sphereObj.obj = marbleObj;\n\n    // Ellipsoïde avec texture métal\n    vec3 ellipsoidCenter = vec3(6.0, 9.0, 1.0);\n    vec3 ellipsoidRadii = vec3(3.0, 3.5, 2.0);\n    Val ellipsoidVal = Ellipsoid(deformedPoint, ellipsoidCenter, ellipsoidRadii);\n    ValObject ellipsoidObj;\n    ellipsoidObj.val = ellipsoidVal;\n    ellipsoidObj.obj = woodObj;\n\n    // Cylindre avec texture pierre\n    vec3 cylinderCenter = vec3(6.0, -4.0, 1.5);\n    float cylinderRadius = 2.0;\n    float cylinderHeight = 3.0;\n    Val cylinderVal = Cylinder(p, cylinderCenter, cylinderRadius, cylinderHeight);\n    ValObject cylinderObj;\n    cylinderObj.val = cylinderVal;\n    cylinderObj.obj = woodObj;\n\n    // Torus\n    vec3 torusCenter = vec3(-7.0, 10.0, -0.9);\n    float bigRadius = 3.0;\n    float tubeRadius = 0.7;\n    Val torusVal = Torus(p, torusCenter, bigRadius, tubeRadius);\n    ValObject torusObj;\n    torusObj.val = torusVal;\n    torusObj.obj = woodObj;\n\n    // Capsule\n    vec3 capsuleStart = vec3(8.0, -10.0, 3.0);\n    vec3 capsuleEnd = vec3(11.0, -3.0, 3.5);\n    float capsuleRadius = 1.3;\n    Val capsuleVal = Capsule(p, capsuleStart, capsuleEnd, capsuleRadius);\n    ValObject capsuleObj;\n    capsuleObj.val = capsuleVal;\n    capsuleObj.obj = marbleObj;\n\n    // Union des objets avec leurs textures respectives\n    ValObject combinedObj2;\n    combinedObj2.val = Union(Union(Union(Union(Union(Union(groundObj.val, cubeObj.val), sphereObj.val), ellipsoidObj.val), cylinderObj.val), torusObj.val), capsuleObj.val);\n\n    // Affectation de la texture en fonction de l’objet avec la plus haute priorité\n    if (capsuleObj.val.v < torusObj.val.v && capsuleObj.val.v < cylinderObj.val.v && capsuleObj.val.v < ellipsoidObj.val.v && capsuleObj.val.v < sphereObj.val.v && capsuleObj.val.v < cubeObj.val.v && capsuleObj.val.v < groundObj.val.v) {\n        combinedObj2.obj = capsuleObj.obj;\n    } else if (torusObj.val.v < cylinderObj.val.v && torusObj.val.v < ellipsoidObj.val.v && torusObj.val.v < sphereObj.val.v && torusObj.val.v < cubeObj.val.v && torusObj.val.v < groundObj.val.v) {\n        combinedObj2.obj = torusObj.obj;\n    } else if (cylinderObj.val.v < ellipsoidObj.val.v && cylinderObj.val.v < sphereObj.val.v && cylinderObj.val.v < cubeObj.val.v && cylinderObj.val.v < groundObj.val.v) {\n        combinedObj2.obj = cylinderObj.obj;\n    } else if (ellipsoidObj.val.v < sphereObj.val.v && ellipsoidObj.val.v < cubeObj.val.v && ellipsoidObj.val.v < groundObj.val.v) {\n        combinedObj2.obj = ellipsoidObj.obj;\n    } else if (sphereObj.val.v < cubeObj.val.v && sphereObj.val.v < groundObj.val.v) {\n        combinedObj2.obj = sphereObj.obj;\n    } else if (cubeObj.val.v < groundObj.val.v) {\n        combinedObj2.obj = cubeObj.obj;\n    } else {\n        combinedObj2.obj = groundObj.obj;\n    }\n\n    // ------------------------------ FORMES COMPLEXES -------------------------------------------\n\n    // Tasse (avec texture céramique)\n    Val demiTasse = Difference(\n        Torus(Transform(p, vec3(0.0, 0.0, 0.0), vec3(1.0), vec3(90, 0, 0)), vec3(-2.2, 2.0, 1.0), 1.4, 0.3),\n        Cube(Transform(p, vec3(0.0, 1.0, -2.0), vec3(1.0), vec3(0, 0, 0)), vec3(0.2, 0.0, 0.0), vec3(2.0, 2.0, 2.0))\n    );\n\n    Val demiTasse2 = Difference(\n        Cylinder(p, vec3(0.0, -1.0, 2.0), 2.0, 2.0),\n        Cylinder(p, vec3(0.0, -1.0, 2.2), 1.7, 2.0)\n    );\n\n    Val tasseVal = Union(demiTasse, demiTasse2);\n    ValObject tasseObj;\n    tasseObj.val = tasseVal;\n    tasseObj.obj = marbleObj; // Céramique\n\n    // Assiette avec texture porcelaine\n    Val hollowAssiette = Difference(\n        Cylinder(p, vec3(0.0, 0.0, 0.1), 4.5, 0.4),\n        Cylinder(p, vec3(0.0, 0.0, 0.2), 3.8, 0.35)\n    );\n    Val assietteVal = Union(hollowAssiette, Torus(p, vec3(0.0, 0.0, 0.3), 4.6, 0.2));\n    ValObject assietteObj;\nassietteObj.val = assietteVal;\nassietteObj.obj = marbleObj; // Porcelaine\n\n// Union des objets complexes avec leurs textures respectives\nValObject combinedObj3;\ncombinedObj3.val = Union(Union(Union(tasseObj.val, assietteObj.val), combinedObj2.val), combinedObj1.val);\n\n// Affectation de la texture en fonction de l’objet avec la plus haute priorité\nif (tasseObj.val.v < assietteObj.val.v && tasseObj.val.v < combinedObj2.val.v && tasseObj.val.v < combinedObj1.val.v) {\n    combinedObj3.obj = tasseObj.obj;\n} else if (assietteObj.val.v < combinedObj2.val.v && assietteObj.val.v < combinedObj1.val.v) {\n    combinedObj3.obj = assietteObj.obj;\n} else if (combinedObj2.val.v < combinedObj1.val.v) {\n    combinedObj3.obj = combinedObj2.obj;\n} else {\n    combinedObj3.obj = combinedObj1.obj;\n}\n\nreturn combinedObj3;\n}\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  ValObject val=object(p);\n  float v=val.val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).val.v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).val.v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).val.v-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray,float e,out float t,out int s,out int c) {\n    bool h=false;\n  \n    // Start at the origin\n    t=0.0;\n    c=0;\n  \n    for(int i=0;i<Steps;i++) {\n        s=i;\n        vec3 p=Point(ray,t);\n        ValObject val=object(p);\n        float v=val.val.v;\n        c+=val.val.c;\n        // Hit object\n        if(v<0.) {\n            h=true;\n            break;\n        }\n        // Move along ray\n        t+=max(Epsilon,v);\n        // Escape marched too far away\n        if(t>e) {\n            break;\n        }\n    }\n    return h;\n}\n\n// ---------------------------------------------\n//           Lighting\n// ---------------------------------------------\n\n// Background color\n// ray : Ray \nvec3 background(Ray ray)\n{\n  return mix(vec3(.245,.55,.99),vec3(.365,.69,.99),ray.d.z*.5+.5);\n}\n\n// Fonction de calcul de l'ombre pour une source ponctuelle\n// p : Point à tester\n// n : Normale au point\n// l : Direction vers la source de lumière (ou la position de la source pour les sources ponctuelles)\nfloat Shadow(vec3 p, vec3 n, vec3 l)\n{\n    float t;\n    int s;\n    int c;\n\n    // Lancer un rayon depuis le point \"p\" légèrement décalé par la normale \"n\" dans la direction \"l\"\n    bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c);\n\n    // Si le rayon ne touche aucun objet, pas d'ombre\n    if (!hit) {\n        return 1.0; // Point éclairé\n    }\n    \n    return 0.0; // Point dans l'ombre\n}\n\n// Génération d'une direction aléatoire sur la sphère\nvec3 randomSphereDirection()\n{\n    float u = rand(vec3(1.0));  // Générer un nombre aléatoire basé sur un vecteur\n    float v = rand(vec3(2.0));\n    float theta = 2.0 * PI * u;\n    float phi = acos(2.0 * v - 1.0);\n    \n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n\n    return vec3(x, y, z);\n}\n\n// Fonction de calcul de l'occlusion ambiante\n// p : Point sur la surface\n// n : Normale au point\n// Fonction de calcul de l'occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n)\n{\n    int numSamples = 16;  // Nombre d'échantillons pour l'occlusion\n    float occlusionFactor = 2.0;  // Facteur d'occlusion\n    float radius = 0.6;  // Rayon pour tester l'occlusion\n\n    // Pour chaque échantillon, on tire un rayon dans une direction aléatoire autour de la normale\n    for (int i = 0; i < numSamples; ++i)\n    {\n        // Générer une direction aléatoire pour l'échantillon\n        vec3 randomDir = normalize(n + randomSphereDirection());\n\n        // Lancer un rayon depuis \"p\" dans la direction \"randomDir\" pour tester la géométrie environnante\n        float t;\n        int s;\n        int c;\n        bool hit = SphereTrace(Ray(p + Epsilon * n, randomDir), radius, t, s, c);\n\n        // Si le rayon rencontre un objet à une courte distance, on considère cela comme une occlusion\n        if (hit && t < radius)\n        {\n            occlusionFactor += 1.0;\n        }\n    }\n\n    // Calculer la contribution finale de l'occlusion (normaliser par le nombre d'échantillons)\n    occlusionFactor = 1.0 - (occlusionFactor / float(numSamples));\n    return occlusionFactor;\n}\n\nvec3 Shade(vec3 p,vec3 n,Ray eye, Object obj)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(Ray(p,n));\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n\n    // Get the texture color for the object\n    vec3 textureColor = GetTextureColor(p, obj.textureType);\n    diffuse *= textureColor; \n  \n  // Specular\n  vec3 r=reflect(eye.d,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\nvec3 ShadeLocal(vec3 p, vec3 n, Ray eye, Object obj) {\n    // Source lumineuse ponctuelle\n    const vec3 lightPos = vec3(5., 10., 25.);\n    vec3 lPoint = normalize(lightPos - p);  // Direction de la lumière ponctuelle\n    \n    // Source lumineuse directionnelle\n    const vec3 lightDir = normalize(vec3(-0.5, -0.5, -0.7));\n    vec3 lDirectional = -lightDir;\n    \n    // Calcul de l'ombre pour la source ponctuelle et directionnelle\n    float shadowPoint = Shadow(p, n, lPoint);\n    float shadowDirectional = Shadow(p, n, lDirectional);\n    \n    // Lumière ambiante (sans occlusion)\n    vec3 ambient = obj.material.ambient;\n\n    // Récup la texture/couleur de l'objet\n    vec3 textureColor = GetTextureColor(p, obj.textureType);\n    \n    // Lumière diffuse et spéculaire pour la source ponctuelle\n    float diffPoint = max(dot(n, lPoint), 0.1);\n    vec3 diffusePoint = obj.material.diffuse * diffPoint * textureColor;\n    \n    vec3 rPoint = reflect(-lPoint, n);\n    vec3 v = normalize(-eye.d);  // Direction de vue\n    float specPoint = pow(max(dot(rPoint, v), 0.0), obj.material.shininess);\n    vec3 specularPoint = obj.material.specular * specPoint;\n    \n    // Lumière diffuse et spéculaire pour la source directionnelle\n    float diffDirectional = max(dot(n, lDirectional), 0.0);\n    vec3 diffuseDirectional = obj.material.diffuse * diffDirectional;\n    \n    vec3 rDirectional = reflect(-lDirectional, n);\n    float specDirectional = pow(max(dot(rDirectional, v), 0.0), obj.material.shininess);\n    vec3 specularDirectional = obj.material.specular * specDirectional;\n    \n    // Combiner les composants de lumière avec les ombres\n    vec3 color = ambient +\n         (diffusePoint + specularPoint) +\n        shadowDirectional * (diffuseDirectional + specularDirectional);\n    \n    return color;\n}\n\n\nvec3 ShadeWithOcclusion(vec3 p, vec3 n, Ray eye, Object obj) {\n    // Source lumineuse ponctuelle\n    const vec3 lightPos = vec3(5., 10., 25.);\n    vec3 lPoint = normalize(lightPos - p);\n    \n    // Source lumineuse directionnelle\n    const vec3 lightDir = normalize(vec3(-0.5, -0.5, -0.7));\n    vec3 lDirectional = -lightDir;\n\n    // Calcul de l'ombre\n    float shadowPoint = Shadow(p, n, lPoint);\n    float shadowDirectional = Shadow(p, n, lDirectional);\n    \n    // Calcul de l'occlusion ambiante\n    float ao = AmbientOcclusion(p, n);\n\n    // Lumière ambiante avec occlusion\n    vec3 ambient = obj.material.ambient * ao;\n\n    // Get the texture color for the object\n    vec3 textureColor = GetTextureColor(p, obj.textureType);\n\n    // Lumière diffuse et spéculaire pour la source ponctuelle\n    float diffPoint = max(dot(n, lPoint), 0.1);\n    vec3 diffusePoint = obj.material.diffuse * diffPoint * textureColor;\n    \n    vec3 rPoint = reflect(-lPoint, n);\n    vec3 v = normalize(-eye.d);\n    float specPoint = pow(max(dot(rPoint, v), 0.0), obj.material.shininess);\n    vec3 specularPoint = obj.material.specular * specPoint;\n\n    // Lumière diffuse et spéculaire pour la source directionnelle\n    float diffDirectional = max(dot(n, lDirectional), 0.0);\n    vec3 diffuseDirectional = obj.material.diffuse * diffDirectional * textureColor;\n    \n    vec3 rDirectional = reflect(-lDirectional, n);\n    float specDirectional = pow(max(dot(rDirectional, v), 0.0), obj.material.shininess);\n    vec3 specularDirectional = obj.material.specular * specDirectional;\n\n    // Combinaison des contributions lumineuses avec occlusion ambiante\n    vec3 color = ambient +\n        /*shadowPoint */ (diffusePoint + specularPoint) +\n        shadowDirectional * (diffuseDirectional + specularDirectional);\n    \n    // Appliquer l'occlusion ambiante au résultat\n    color *= ao;\n\n    return color;\n}\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\nvoid mainImage(out vec4 color, in vec2 pxy) {  \n    vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n\n    //Ray ray = CreateRay(iMouse.xy / iResolution.xy, pixel);\n    Ray ray = CreateRotatingCameraRay(iMouse.xy / iResolution.xy, pixel, iTime);\n\n    // Initialisation de la couleur d'arrière-plan\n    vec3 rgb = background(ray);\n\n    // Trace ray and check for hit\n    float t = 0.0;\n    int s = 0;\n    int c;\n\n    // Vérification de l'intersection avec la sphère englobante\n    if (RaySphereIntersection(ray, sceneBoundingSphereCenter, sceneBoundingSphereRadius, t)) {\n        bool hit = SphereTrace(ray, 100., t, s, c);\n        if (hit) {\n            vec3 p = Point(ray, t);\n            vec3 n = ObjectNormal(p);\n\n            // Récupérer l'objets et ses props\n            ValObject valObj = object(p);\n\n            /////////////////////////////////////\n            // Choisir le modèle d'éclairement //\n            /////////////////////////////////////\n\n            // Modéle d'éclairement basique\n            rgb=Shade(p,n,ray,valObj.obj);\n            \n            // Modéle de Phong classique\n            //rgb = ShadeLocal(p, n, ray, valObj.obj);\n\n            // Modèle avec occlusion ambiante\n            rgb = ShadeWithOcclusion(p, n, ray, valObj.obj);\n\n            // Uncomment this line to shade image with false colors representing the number of steps\n            //rgb=ShadeSteps(s,Steps);\n    \n            // Uncomment this line to shade cost\n            //rgb=ShadeSteps(c,500);\n        }\n    }\n\n    color = vec4(rgb, 1.);\n}\n","name":"Image","description":"","type":"image"}]}