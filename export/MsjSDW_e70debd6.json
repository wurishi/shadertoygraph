{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Blobs\n// Ghkaeitq\n\nconst int Steps = 1264;\nconst float Epsilon = 0.025; // Marching epsilon\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment skelton\n// pa : point A\n// pb : Point B\n// p : point\n// e : energy\n// R : radius\nfloat segment( in vec3 p, in vec3 a, in vec3 b, float e, float R )\n{    \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return e*falloff(length( pa - ba*h ), R);   \n}\n    \n// Potential field\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = -0.5;\n\n  v+=point(p,vec3( -0.5, -1.0, 8.0),1.0,2.5);\n  v+=point(p,vec3( -3.5, -1.0, 8.0),1.0,2.5);\n  v+=point(p,vec3( -2.0, 5.0, 10.0),1.0,1.5);\n  v+= segment(p,vec3( -2.0, 1.0, 8.0),vec3( -2.0, 5.0, 10.0),1.0,2.5);\n  return v;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// a : ray origin\n// u : ray direction\nvec3 Trace(vec3 a, vec3 u, out bool hit)\n{\n  hit = false;\n  vec3 p = a;\n  for(int i=0; i<Steps; i++)\n  {\n    if (!hit) {\n      float v = object(p);\n      if (v > 0.0) {\n        hit = true;\n      }\n      p += Epsilon*u;\n    }\n  }\n  return p;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(1.0, 0.2, 0.8), vec3(1.0, 0.5, 0.8), rd.y*0.5+0.5);\n}\n\n// Lighting\n// p : point,\n// n : normal at point\nvec3 shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -5.0));\n  vec3 ro = vec3(0.0, 1.2, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n  vec3 pos = Trace(ro, rd, hit);\n\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n    // Shade\n    rgb = shade(pos, n);\n  }\n\n  fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjSDW","date":"1412274119","viewed":195,"name":"My first Shader GhkÂ®","username":"Ghkaeitq","description":"Hello world","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["stupid"],"hasliked":0,"parentid":"","parentname":""}}