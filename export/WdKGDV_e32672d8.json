{"ver":"0.1","info":{"id":"WdKGDV","date":"1570993224","viewed":123,"name":"Truchet Knitting Snakes","username":"azirafail","description":"truchet experiments","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise2(vec2 uv)\n{\n    return fract(sin(uv.x * 8989.) * 52423. + cos(uv.y * 4917.) * 68159.);\n}\n\nfloat mh(vec2 v)\n{\n    return abs(v.x) + abs(v.y);\n}\n\nfloat PI = 3.142;\n\nstruct snakeUvs {\n    vec2 stuv, cuv, suv, tuv, flipper;\n    bool flipped;\n};\n\nsnakeUvs getSnakeUvs(vec2 wuv, float offset)\n{\n    // truchet\n    \n    vec2 otuv = fract(wuv);\n    vec2 tuv = otuv;\n    vec2 c = floor(wuv);\n    \n    float n = noise2(c);\n\n    bool flip = n < 0.5;\n    \n    if (flip) \n    {\n        tuv.x = 1. - tuv.x;\n        otuv.x = -otuv.x;\n    }\n    \n    if (mh(tuv) > 1.) \n    {\n       tuv -= 1.;\n       otuv -= 1.;\n    }\n    \n    if (flip)\n    {\n        otuv = vec2(-1. - otuv.x, otuv.y);\n    }\n    \n    float d = length(tuv);\n    \n    vec2 suv;\n    suv.y = 2.*atan(tuv.y/tuv.x)/PI - .5;\n    suv.x = -(d * 3. - 1.5);\n    \n    \n    vec2 flipper = vec2(1.,1.);\n    if (mod(c.x+c.y,2.) == 0.) \n    {\n        flipper.y = - 1.;\n    }\n    if ((mod(mh(c),2.) == 0.) ^^ flip )\n    {\n        flipper.x = - 1.;\n    }\n    \n    suv *= flipper;\n    \n    \n    vec2 stuv = vec2(suv.x, fract(suv.y * 2. + offset)-.5);\n    \n    snakeUvs uvs;\n    uvs.stuv = stuv;\n    uvs.cuv = otuv;\n    uvs.suv = suv;\n    uvs.tuv = tuv;\n    uvs.flipper = flipper;\n    uvs.flipped = flip;\n    \n    return uvs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    vec2 wuv1 = uv * (6. + 2. * sin(iTime / 5.)) + vec2(0.6,0.5) * iTime;\n    vec2 wuv2 = wuv1 + vec2(- 76.5,39.5);\n    \n    vec2 ctuv = fract((wuv1 + .25) * 2.);\n    vec2 cti = floor((wuv1 + .25) * 2.);\n    \n    bool over = mod(mh(cti), 4.) > 2.;\n    \n    \n    snakeUvs uvs1 = getSnakeUvs(wuv1, iTime * 3.);\n    snakeUvs uvs2 = getSnakeUvs(wuv2, iTime * 1.);\n    \n    vec2 stuv1 = uvs1.stuv;\n    vec2 stuv2 = uvs2.stuv;\n    \n    vec2 stxy1 = uvs1.cuv;\n    vec2 stxy2 = uvs2.cuv;\n    \n    stuv1.x *= -1.5-uv.y;\n    stuv2.x *= 1.5-uv.y;\n    stuv1.x *= 2.+sin(wuv1.x / (4.5 + sin(wuv1.y / 30.)));\n    stuv2.x *= 2.+sin(wuv2.x / (3.8 + sin(wuv2.y / 70.)));\n    \n    //col.rg = stuv1 + stuv2;\n    float mask1 = smoothstep(.5,0.45,abs(stuv1.x));\n    float mask2 = smoothstep(.5,0.45,abs(stuv2.x));\n    \n    if (over)\n    {\n      mask2 *= 1. - mask1;\n    }\n    else {\n      mask1 *= 1. - mask2;\n    }\n    \n    vec2 luv = mask1 * stuv1 + mask2 * stuv2;\n    \n    float rope = cos(luv.x * 2. * PI / 2.) * sin(fract((luv.x - luv.y) * 2.) * PI);\n    col += vec3(.7,.1,.2) * mask1 * rope;\n    col += vec3(.4,.1,.6) * mask2 * rope;\n    \n    col.rgb += vec3(luv.x);\n\n    vec2 norm = (stxy1 * 5.*(uvs1.stuv.x*sign(uvs1.stuv.x * (length(stxy1) - 0.5))) *  mask1 + stxy2 * 5.*(uvs2.stuv.x*sign(uvs2.stuv.x * (length(stxy2) - 0.5))) * mask2);\n    \n    vec2 fwd = normalize(vec2(luv.y, -luv.x));\n \n    norm -= 0.8 * fwd * (fract((luv.x - luv.y) * 3.) - 0.5);\n    \n    \n   \tfloat illum1 = clamp(dot(norm, vec2(1. * sin(iTime / 3.),1. * cos(iTime / 3.))), 0.,1.);\n   \tfloat illum2 = clamp(dot(norm, vec2(1. * sin(iTime / 5.),1. * cos(iTime / 3.))), 0.,1.);\n    \n    col.rgb = col.rgb * 0.4 \n        + (col.rgb * 0.7 * illum1 +  illum1 * illum1) * vec3(1.,.5,0.)\n        + (col.rgb * 0.7 * illum2 +  illum2 * illum2) * vec3(0.,.5,.8);\n    \n    //col.rg = norm;\n    //col.b = illum;\n    \n    \n    //col.g = length(tuv);\n  \t//col.rg = suv;\n    \n    fragColor.rgb = col;\n}","name":"Image","description":"","type":"image"}]}