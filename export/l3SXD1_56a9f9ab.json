{"ver":"0.1","info":{"id":"l3SXD1","date":"1710770981","viewed":133,"name":"flower bed","username":"totan","description":"To put many flower, I used \"for\". but it increases the amount of calculation.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    fragColor=1.*texture(iChannel0,uv,0.);\n    fragColor+=0.5*texture(iChannel0,uv,2.5);//minmapを重ねてミスト補正\n    fragColor+=0.5*texture(iChannel0,uv,4.5);\n    \n    fragColor.xyz*=0.5;\n    \n        \n    fragColor.w=1.;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n#define Res iResolution\n#define iMAX 100.0\n#define REACH 0.001\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define T 6.283185307  //pie*2.\n#define P 3.141592654  //pie\n\nvec3 lightCol = vec3(-0.3,0.7,1.0)*1.;\nvec3 diffCol  = vec3(0.8,.9,1.0)*1.5;\nvec3 lightDir = normalize(vec3(-.16,.23,.07));\n\nstruct RAY{\n    vec3 p;\n    vec3 dir;\n    vec3 Ndir;\n    vec2 tex;\n    float obj;\n    float total_d;\n    vec3 tCol;\n};RAY ray;\n\nfloat hash(float n){return fract(sin(n+648.)*12.123);}\n\nfloat petalDcp(in vec2 uv, in float w){\n\tuv.x = abs(uv.x) + .25 + .25*w;\n\treturn length(uv) - .5;\n}\n\n#define b 0.5\nfloat flower(in vec3 p, in float aIt, in float m){\n    //cutting\n\tp.xy = p.xy*rot(   (T/aIt)*(-floor((atan(p.x, p.y)/T + .5)*aIt) - 0.5) - P   );\n\t\n\tp.y -= 0.45;\n\tp.z -= b;\n\tp.zy *= rot((m - .015)*2.);\n\tfloat pDcp = petalDcp(p.xy, m);\n\tp.x = abs(p.x);\n\tp.xz *= rot(-.25);\n\tfloat c1 = length(p.yz) - b;\n\treturn max(max(pDcp, abs(c1) - .015), p.z);\n}\n#define cut 3.\n#define cut2 cut*0.5\nint m=0; //color_num\nfloat MAP(in vec3 p){\n    p.y -= texture(iChannel0,p.xz*0.0625).r*0.045\n          +texture(iChannel0,p.xz*0.001).g *1.2;\n    vec3 Pos=p;\n    \n    float h = 1.;\n    Pos.y -= 2.;\n    float y = max(Pos.y,-2.)+2.;\n    \n    float d,d2,d3=1000000000000.;\n    \n    for(float i=0.0;i++<3.;){\n        vec3 p0 = Pos;\n        p0.xz += vec2(i/0.6, i/1.5);\n        vec2 mas = p0.xz;\n        p0.xz = mod(p0.xz+cut2,cut) - cut2;\n        mas -= p0.xz;\n        float rang = hash(mas.y*12.+mas.x*1.+float(i)*56.);\n        p0.y += rang*1.5;\n        p0 *= rang*0.6+1.;\n        p0.xy  =(p0.xy+vec2(0,2))*rot(cos(iTime+mas.x*0.2+rang*0.1)*-0.15+0.15)-vec2(0,2);\n        p0.xz *= rot(rang*T);\n        p0.xy *= rot(y*.1);\n        p0.y = -p0.y;\n        p0 = p0.xzy;\n        \n        d = flower(p0,5.0+mod(floor(rang*452.),3.),0.1);\n        \n\n        d2 = length(p0.xy)-0.03;\n        d2 = max(d2,abs(p0.z-.23-h)-h);\n        \n        d3 = min(min(d,d2), d3);\n        int flowerCol = int(rang*43.)%3 + 2;\n        m=min(d,d2)>d3 ? m : (d>d2 ? 1:flowerCol);\n        \n    }\n    \n\n    if(p.y<d3){\n        ray.tex = p.xz;\n        m=0;\n    }\n    d3 = min(d3,p.y-texture(iChannel1,p.xz*0.0625).r*0.5+0.3);\n    return d3*0.7;\n    \n}\nvec3 getNormal(float d){\n    //vec3 p=ray.p;\n    const vec2 e = vec2(0.01,0.0);\n    #if 1\n    return normalize(\n        vec3(MAP(ray.p + e.xyy) - MAP(ray.p - e.xyy),\n             MAP(ray.p + e.yxy) - MAP(ray.p - e.yxy),\n             MAP(ray.p + e.yyx) - MAP(ray.p - e.yyx)));\n    #else   \n    return normalize(\n        vec3(MAP(ray.p + e.xyy),\n             MAP(ray.p + e.yxy),\n             MAP(ray.p + e.yyx) )-MAP(ray.p));\n    #endif\n            \n}\n\nbool RM(){\n    vec3 dir = ray.dir;\n    float t_d=0.0,d;\n    for(float i=0.0;i++<iMAX;){\n        t_d += d = min(MAP(ray.p),1.5);\n        ray.p += dir*d;\n        if(d < REACH){\n            ray.total_d=t_d;\n            return true;\n            \n        }\n    }\n    ray.Ndir=getNormal(d);\n    ray.total_d=t_d;\n    return t_d>10.?false : true;\n}\n\n\nconst vec3[5] col_list = vec3[](vec3(.2, .8, .2), vec3(0.1,.3,0.2),\n      vec3(1.1, 1., .05), vec3(1., .1, .2), vec3(.05, .1, 1.));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-Res.xy*0.5)/Res.y;\n    vec3 dir = normalize(vec3(uv,1.0)),\n         pos = vec3(0.0+iTime-3.,5.1,-7.);\n    \n    //\n    dir.yz *= rot(-0.0);\n    ray.dir = dir;\n    ray.p = pos;\n    ray.obj = 1.0;\n    ray.tCol = vec3(0.0);\n    ray.total_d = 0.0;\n    vec3 ambCol = vec3(1.0);\n    \n    if( RM() ){\n        ambCol = col_list[m];\n    }\n    else{\n        if(dir.y > -pos.y/140.){\n            ambCol = vec3(0,0.23,.3)*5.3;\n            ray.p = vec3(54335435.);\n        }\n        else ambCol = col_list[0];\n    }\n    \n    \n    //get color---------------------------------------------------------------------\n    vec3 bg = mix(ambCol,lightCol,clamp(dot(ray.p-pos,lightDir)*.2,-.5,1.5));\n    bg = ambCol;\n    \n    // reflection\n    vec3 n = getNormal(1.);\n    vec3 R = normalize(reflect(ray.p-pos,n));\n    //vec4 refl = myenv(ray.p,R,1.);\n    \n    vec3 col = vec3(1);\n    \n    // ambient occlusion\n    float ao = 1.;\n    \n    ao = min(ao,MAP(ray.p+n*.08)/.08);\n    ao = min(ao,MAP(ray.p+n*.04)/.04);\n    ao = min(ao,MAP(ray.p+n*.02)/.02);\n    ao = ao*.8+.2;\n    //\n    \n    \n    float diff = clamp(dot(n,lightDir),0.,1.);\n    \n    // mix diffuse, ambient, ao\n    col *= diffCol-.1+.1*(n*.5+.5);\n    col *= ao;\n    col *= lightCol*diff*(1.-ambCol)+ambCol;\n    \n    // depth fog\n    col = mix(bg,col,exp(-length(ray.p-pos)/32.));\n    fragColor.xyz = col*.5;\n        \n    fragColor.w = 1.;\n}","name":"Buffer A","description":"","type":"buffer"}]}