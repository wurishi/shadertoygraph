{"ver":"0.1","info":{"id":"tscGRl","date":"1569079584","viewed":237,"name":"Unfalling Hearts - Voulitsa","username":"Jercieblue","description":"Gia tin voulitsa pou einai arostoula!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hearts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 colors[5] = vec3[5](\n    vec3(0.969, 0.706, 0.831),\n    vec3(0.933, 0.522, 0.714),\n    vec3(0.886, 0.373, 0.616),\n    vec3(0.839, 0.251, 0.529),\n    vec3(0.765, 0.122, 0.424)\n);\n\nfloat seed = 3265.0;\n\nfloat N31(vec3 v) {\n    return fract(sin(v.x * 345.74 + v.y * 798.54 + v.z* 175.87) * seed);\n}\n\nfloat N21(vec2 v) {\n    return fract(sin(v.x * 345.74 + v.y * 798.54 ) * seed);\n}\n\nvec2 N22(vec3 v) {\n    float x = N31(v);\n    float y = N31(v * x);\n    return vec2(x, y);\n}\n\nvec3 N33(vec3 v) {\n    float x = N31(v);\n    float y = N31(v * x);\n    float z = N31(v * y);\n    return vec3(x, y, z);\n}\n\nfloat Noise2(vec2 v) {\n    vec2 lv = fract(v);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    vec2 id = floor(v);\n    float c = \n        mix(\n            mix(N21(id + vec2(0,0)), N21(id + vec2(1,0)), lv.x),\n            mix(N21(id + vec2(0,1)), N21(id + vec2(1,1)), lv.x), \n        lv.y);\n    return c;\n}\n\n\nfloat SmoothNoise2(vec2 v){\n    float n = 0.0;\n    float o = 1.0;\n    float av = 0.0;    \n    for (float i = 1.0; i < 4.0; i += 1.0) {\n        n += Noise2(v * o) / pow(2.0, i);\n        o *= 2.0;\n        av += 1.0 / pow(2.0, i);\n    }\n    return n / av;\n}\n\nfloat Noise3(vec3 v) {\n    vec3 lv = fract(v);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    vec3 id = floor(v);\n\n    float c = mix(\n        mix(\n            mix(N31(id + vec3(0,0,0)), N31(id + vec3(1,0,0)), lv.x),\n            mix(N31(id + vec3(0,1,0)), N31(id + vec3(1,1,0)), lv.x), lv.y),\n        mix(\n            mix(N31(id + vec3(0,0,1)), N31(id + vec3(1,0,1)), lv.x),\n            mix(N31(id + vec3(0,1,1)), N31(id + vec3(1,1,1)), lv.x), lv.y), lv.z);\n\n    return c;\n}\n\nfloat SmoothNoise3(vec3 v){\n    float n = 0.0;\n    float o = 1.0;\n    float av = 0.0;    \n    for (float i = 1.0; i < 64.0; i += 1.0) {\n        n += Noise3(v * o) / pow(2.0, i);\n        o *= 2.0;\n        av += 1.0 / pow(2.0, i);\n    }\n    return n / av;\n}\n\nfloat smax(float a, float b, float k){\n    float h = clamp((b-a) / k + 0.5, 0.0, 1.0);\n    return mix(a,b,h) + h * (1.0 - h) * k * 0.5;\n}\n\nfloat HeartDist(vec2 uv, vec2 o, float r, float bias){\n    vec2 s = vec2(0.7, 1.0) / r;\n    uv = o + uv * s;\n   \tfloat b = r * bias;\n    uv.y -= smax(sqrt(abs(uv.x))*0.5,b,0.1);\n    //uv.y -= sqrt(abs(uv.x))*0.5;\n    uv.y += b;\n    float d = length(uv);\n    return smoothstep(r + b, r - b, d);\n}\n\nvec4 DrawHeart(vec2 uv, float r, float bias){\n    vec3 c = vec3(0.0);\n    float d = HeartDist(uv, vec2(0,0.1), r, bias);\n    float alpha = d;\n    c += mix(colors[4], colors[2], pow(d,1.0));\n    \n    return vec4(c, step(0.1,alpha));\n}\n\nvoid DrawHearts(in vec2 uv, inout vec3 color) {\n    uv /= 128.0;\n    vec4 c = vec4(0.0);\n    float layers = 12.0;\n    float layer_time = 16.0;\n    float layer_spawn = layer_time / layers;\n    float time = -iTime*2.0;\n    for (float i = layers - 1.0; i >= 0.0; i--) {\n        float lt = mod(time, layer_time) + i * layer_time;\n        vec2 luv = fract(uv * lt*4.0) - 0.5;\n        vec2 id = floor(uv * lt*4.0)-0.5;\n        float tt = floor(time / (layer_time)) - i;\n        float fade_time = \n            smoothstep(0.0,0.1, lt / (layers * layer_time))*\n            smoothstep(1.0,0.5, lt / (layers * layer_time));\n        if (N31(vec3(id, floor(tt))) > 0.9){\n            vec4 sc = DrawHeart(luv, 0.2, 0.2);\n\t\t\tc = mix(c, sc, sc.a * fade_time);\n        }\n        \n    }\n    color = mix(color, c.rgb,c.a);\n}\n\nvec3 DrawHeartLight(vec2 uv, float r, float bias, float time, vec2 id){\n    float i = time*(sin((N21(id) + iTime)*2.0)*0.5+0.5);\n    float to_center = length(uv);\n    float atten = 1.0 / (1.0 + to_center*to_center*to_center*500.0)*0.25;\n    return vec3(1.0) * atten*i;\n}\n\nvoid DrawLights(in vec2 uv, inout vec3 color) {\n    uv /= 128.0;\n    vec3 c = vec3(0.0);\n    float layers = 12.0;\n    float layer_time = 16.0;\n    float layer_spawn = layer_time / layers;\n    float time = -iTime*2.0;\n    for (float i = layers - 1.0; i >= 0.0; i--) {\n        float lt = mod(time, layer_time) + i * layer_time;\n        vec2 luv = fract(uv * lt*4.0) - 0.5;\n        vec2 id = floor(uv * lt*4.0)-0.5;\n        float tt = floor(time / (layer_time)) - i;\n        float fade_time = \n            smoothstep(0.0,0.1, lt / (layers * layer_time))*\n            smoothstep(1.0,0.5, lt / (layers * layer_time));\n        if (N31(vec3(id, floor(tt))) > 0.9){\n            vec3 sc = DrawHeartLight(luv, 0.2, 0.2,fade_time, id)*fade_time;\n\t\t\tc += sc;\n        }\n        \n    }\n    color += c;\n}\n\n\n\n\nvoid DrawClouds(vec2 uv, inout vec3 color) {\n    float time = iTime*0.5;\n    \n    float c = SmoothNoise3(vec3(uv*8.0, time*0.5));\n    \n    vec3 cloud_color =pow(mix(colors[1],colors[4],c),vec3(2.0));\n    color += cloud_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xy * 2.0 / aspect;\n    \n    vec3 c = vec3(0.0);\n    \n    float big_heart_mask = clamp(HeartDist(uv/16.0, vec2(0.0,0.05),0.20, 0.4), 0.0, 1.0);\n    DrawClouds(uv,c);\n    c = (c - vec3(big_heart_mask*0.5)) ;\n    DrawLights(uv,c);\n    DrawHearts(uv,c);\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}