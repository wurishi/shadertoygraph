{"ver":"0.1","info":{"id":"3sGSzw","date":"1573582323","viewed":123,"name":"Why pmod is heavier than ForLoop","username":"ankd","description":"(2019/11/14) atan() in pmod is heavier than a few for loops.\n-----\nI try to implement polar mod, I think polar mod is faster than for loop replication, but it's didn't happen while OBJ_NUM is small. \nWhat is the cause?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","replication","pmod","forloop","polarmod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TEST_ITR    ... testing count using for loop.\n// OBJ_NUM     ... as the name suggests.\n// ENABLE_PMOD ... when is defined it, use polar mod. \n//                 please comment out to compare.\n// ANIMATE     ... object animate.\n#define TEST_ITR 50\n#define OBJ_NUM 12\n//#define ENABLE_PMOD\n#define ANIMATE\n\nconst float PI = acos(-1.);\nconst float TWO_PI = 2.*PI;\n\nmat2 rotate(float a) { float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }\n// polar mod definition\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + PI / r;\n    float n = TWO_PI / r;\n    a = floor(a / n) * n;\n    return rotate(-a)*p;\n}\n\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\n#define repeat(p,c) mod(p,c)-0.5*c\nfloat object( in vec3 p ) {\n\tfloat res = 1e4;\n#ifdef ANIMATE\n    p.z -= mod(iTime, 1.);\n#endif\n    p.z = repeat(p.z, 1.);\n\n    for(int j=0;j<TEST_ITR;j++) {\n#ifdef ENABLE_PMOD\n\t    p.xy = pmod(p.xy, float(OBJ_NUM));\n\t    res = min(res, sphere(p-vec3(0., 1., 0.), 0.2));\n#else\n\t    for(int i=0;i<OBJ_NUM;i++) {\n\t        float fi = float(i);\n\t        float theta = fi * 2.*PI / float(OBJ_NUM);\n\t       \tvec3 o = vec3(cos(theta), sin(theta), 0.);\n\t        float r = 0.2;\n\t\t    res = min(res, sphere(p-o, r));\n\t    }\n#endif\n    }\n    return res;\n}\n\nfloat oMarch(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    for(int i=0;i<100;i++) {\n    \tfloat d = object(ro + rd*t);\n        if(d<1e-4) break;\n        t += d;\n    }\n    if(tmm.y<t) return -1.;\n    return t;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv) {\n\tvec2 cmm = vec2(0., 10.);\n    float t = oMarch(ro, rd, cmm);\n    vec3 col;\n    if(t<0.) {\n        col = vec3(0.);\n    } else {\n\t    col = vec3(exp(-.1*t));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(p, -1.));\n    \n    vec3 col = render(ro, rd, uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}