{"ver":"0.1","info":{"id":"tsyBR3","date":"1607613347","viewed":101,"name":"Real-time ball 3","username":"lechuga2000","description":"Real-time ball 3","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sphere","ball","realtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Eye\nconst float eyeRadius = 5.0;\nconst float eyeSpeed = 0.3;\n\nvec3 eye;\n\n// Light\nvec3 lightPosition;\n\n// Ball\nconst vec3 ballCenter = vec3(1.0, 0.0, 0.0);\n\nconst float ball1Radius = 2.0;\nconst vec3 ball1MaterialAmbient = vec3(0.1745, 0.01175, 0.01175);\nconst vec3 ball1MaterialDiffuse = vec3(0.61424, 0.04136, 0.04136);\nconst vec3 ball1MaterialSpecular  = vec3(0.727811, 0.626959, 0.626959);\nconst float ball1MaterialShininess = 128.0;\n\nconst float ball2Radius = 1.5;\nconst vec3 ball2MaterialAmbient = vec3(0.01175, 0.01175, 0.1745);\nconst vec3 ball2MaterialDiffuse = vec3(0.04136, 0.04136, 0.61424);\nconst vec3 ball2MaterialSpecular  = vec3(0.626959, 0.626959, 0.727811);\nconst float ball2MaterialShininess = 100.0;\n\nvec3 color(in vec3 lightPosition, in vec3 normal, in vec3 materialAmbient, in vec3 materialDiffuse\n               , in vec3 materialSpecular, in float materialShininess, in vec3 rayIntersection)\n{\n  vec3 L = normalize(lightPosition - rayIntersection);\n  vec3 E = normalize(eye - rayIntersection);\n  vec3 R = normalize(-reflect(L, normal));\n\n  vec3 Idiffuse = clamp(materialDiffuse * max(dot(normal, L), 0.0), 0.0, 1.0);\n  vec3 Ispecular = clamp(materialSpecular * pow(max(dot(R, E), 0.0), 0.3 * materialShininess), 0.0, 1.0);\n\n  return clamp(materialAmbient + Idiffuse + Ispecular, 0.0, 1.0);\n}\n\nvec3 ball1Color(in vec3 lightPosition, in vec3 rayIntersection)\n{\n  vec3 normal = normalize(rayIntersection - ballCenter);\n\n  return color(lightPosition, normal, ball1MaterialAmbient, ball1MaterialDiffuse, ball1MaterialSpecular\n                     , ball1MaterialShininess, rayIntersection);\n}\n\nvec3 ball2Color(in vec3 lightPosition, in vec3 rayIntersection)\n{\n  vec3 normal = normalize(rayIntersection - ballCenter);\n\n  return color(lightPosition, normal, ball2MaterialAmbient, ball2MaterialDiffuse, ball2MaterialSpecular\n                     , ball2MaterialShininess, rayIntersection);\n}\n\nint ballIntersection(in vec3 rayOrigin, in vec3 rayDirection, in vec3 center, in float radius, out float t1\n                      , out float t2)\n{\n  vec3 m = rayOrigin - center;\n\n  float a = dot(rayDirection, rayDirection);\n  float b = 2.0 * dot(rayDirection, m);\n  float c = dot(m, m) - pow(radius, 2.0);\n\n  float det = pow(b, 2.0) - 4.0 * a * c;\n  if (det < 0.0)\n  {\n    return 0;\n  }\n  else\n  {\n    float aa = 0.5 / a;\n    float sqrtDet = sqrt(det);\n\n    float tt1 = aa * (-b - sqrtDet);\n    float tt2 = aa * (-b + sqrtDet);\n\n    t1 = min(tt1, tt2);\n    t2 = max(tt1, tt2);\n\n    float time = iTime / radius;\n\n    vec3 ballRay1 = m + t1 * rayDirection;\n    vec2 d1 = ballRay1.xy + 5.0e-1 * sin(2.0e-1 * time);\n    float dv1 = sin(1.0e1 * ballRay1.x + time)\n           + sin(1.0e1 * (ballRay1.x * sin(5.0e-1 * time) + ballRay1.y * cos(5.0e-1 * time)) + time)\n           + sin(sqrt(1.0e2 * dot(d1, d1)) + time);\n    float f1 = 5.0e-1 * sin(3.0 * dv1);\n\n    vec3 ballRay2 = m + t2 * rayDirection;\n    vec2 d2 = ballRay2.xy + 5.0e-1 * sin(2.0e-1 * time);\n    float dv2 = sin(1.0e1 * ballRay2.x + time)\n           + sin(1.0e1 * (ballRay2.x * sin(5.0e-1 * time) + ballRay2.y * cos(5.0e-1 * time)) + time)\n           + sin(sqrt(1.0e2 * dot(d2, d2)) + time);\n    float f2 = 5.0e-1 * sin(3.0 * dv2);\n\n    if (f1 > 0.0)\n    {\n      return 1;\n    }\n    else if (f2 > 0.0)\n    {\n      return 2;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n}\n\nvec4 render(in vec3 rayDirection)\n{\n  const float lightRadius = 5.0e-2;\n\n  float t11, t12;\n  int ballI1 = ballIntersection(eye, rayDirection, ballCenter, ball1Radius, t11, t12);\n  \n  float t21, t22;\n  int ballI2 = ballIntersection(eye, rayDirection, ballCenter, ball2Radius, t21, t22);\n  \n  if (ballI1 == 1 && t11 > 0.0)\n  {\n    return vec4(ball1Color(lightPosition, eye + t11 * rayDirection), 1.0);\n  }\n  else if (ballI2 == 1 && t21 > 0.0)\n  {\n    return vec4(ball2Color(lightPosition, eye + t21 * rayDirection), 1.0);\n  }\n  else if (ballI2 == 2 && t22 > 0.0)\n  {\n    return vec4(ball2Color(lightPosition, eye + t22 * rayDirection), 1.0);\n  }\n  else if (ballI1 == 2 && t12 > 0.0)\n  {\n    return vec4(ball1Color(lightPosition, eye + t12 * rayDirection), 1.0);\n  }\n  else\n  {\n    return texture(iChannel0, rayDirection);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n    \n  eye = vec3(eyeRadius * sin(eyeSpeed * iTime), 0.0, eyeRadius * cos(eyeSpeed * iTime));\n    \n  lightPosition = vec3(5.0, max(2.0, 10.0 - iTime), 5.0);\n  \n  vec3 rayDirection1 = eyeRadius > 0.0 ? -normalize(eye) : normalize(eye);\n  vec3 rayDirection2 = cross(rayDirection1, vec3(0.0, -1.0, 0.0));\n  vec3 rayDirection3 = cross(rayDirection1, rayDirection2);\n\n  vec3 rayDirection = normalize(rayDirection1 + uv.x * rayDirection2 + uv.y * rayDirection3);\n  \n  vec3 rayAntialiasing2 = rayDirection2 / iResolution.x;\n  vec3 rayAntialiasing3 = rayDirection3 / iResolution.y;\n\n  fragColor = render(rayDirection);\n  for (int j = -1; j < 2; ++j)\n  {\n    for (int i = 0; i < 2; ++i)\n    {\n      fragColor += render(rayDirection + float(i) * rayAntialiasing2 + float(j) * rayAntialiasing3);\n    }\n  }\n  fragColor *= 0.2;\n}","name":"Image","description":"","type":"image"}]}