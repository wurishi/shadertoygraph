{"ver":"0.1","info":{"id":"ltlczB","date":"1505462151","viewed":531,"name":"Watch me model Pepe to sad music","username":"MathEin","description":"An emotional journey.\nI cri evritim. \n\nMy very first SDF (Sad Distance Frog) renderer.","likes":17,"published":1,"flags":64,"usePreview":0,"tags":["sdf","sad","meme","pepe","verysad","saddest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MslSWX","filepath":"https://soundcloud.com/unikofficial/sad-violin-melody-air-horn-full","previewfilepath":"https://soundcloud.com/unikofficial/sad-violin-melody-air-horn-full","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 ColourSkin = vec3(0.25,0.5,0.2)*vec3(0.25,0.5,0.2);\nconst vec3 ColourLips = vec3(0.56,0.28,0.2)*vec3(0.56,0.28,0.2);\nconst vec3 ColourWhite = vec3(1.0);\nconst vec3 ColourBlack = vec3(0.0);\nconst float MaterialInnerEye = 1.0;\nconst float MaterialOuterEye = 0.0;\nconst float MaterialSkin = 2.0;\nconst float MaterialLips = 3.0;\n\nconst vec3 LightColour = vec3(1.0,1.0,0.8);\n\nconst float timeStartEyeDetail = 3.2;\nconst float timeStartMouthDetail = 9.6;\n\n\n// Generic SDF stuff (obviously not by me)\nfloat Sphere(vec3 point, vec3 center, float radius) \n{\n    return length(point - center) - radius;\n}\nfloat Ellipsoid( in vec3 p, vec3 center, in vec3 r )\n{\n    return (length( (p-center)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\nvec4 Bezier( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 UnionRound( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\nvec2 Union( vec2 a, vec2 b )\n{\n    return vec2(min( a.x, b.x ), b.y);\n}\n\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\nvec2 SubstractRound( vec2 a, vec2 b, float r )\n{\n\treturn vec2(SubstractRound(a.x,b.x,r), SubstractRound(a.y,b.y,r));\n}\n\n\n// Animation stuff\nfloat DO(float value, float t, float minT)\n{\n    float dt = clamp(t-minT,0.0,1.0);\n\treturn mix(3.0,value, dt); \n}\nvec2 DO(vec2 value, float t, float minT)\n{\n\treturn vec2(DO(value.x, t, minT),value.y);\n}\n\n\n// Pepe SDF\nvec2 doEye(vec3 P, float t)\n{\n    float outerSocket = Ellipsoid( P, vec3(0.25,0.35,0.6), vec3(0.6,0.4,0.5));\n    float innerSocket = Ellipsoid( P, vec3(0.25,0.37,0.75), vec3(0.5,0.22,0.4));\n    vec2 innerEye = vec2(Ellipsoid( P, vec3(0.26,0.35,0.8), vec3(0.4,0.2,0.36)), MaterialInnerEye);\n    vec2 outerEye = vec2(Ellipsoid( P, vec3(0.25,0.37,0.75), vec3(0.5,0.22,0.4)), MaterialOuterEye);\n    \n    outerSocket = DO(outerSocket, t, timeStartEyeDetail);    \n    innerSocket = DO(innerSocket, t, timeStartEyeDetail+1.6);\n    innerEye = DO(innerEye, t, timeStartEyeDetail+2.4);\n    outerEye = DO(outerEye, t, timeStartEyeDetail+3.2);\n    \n    vec2 eyeSocket = vec2(SubstractRound(\n        outerSocket,\n        innerSocket,\n        0.05 ), MaterialSkin);\n    vec2 eye = UnionRound(innerEye, outerEye, 0.001);\n\n    // Eyelid detail\n    const float eyelidHeight = 0.58;\n    const float eyelidThickness = 0.05;\n    \n    vec3 a = vec3(0.0,eyelidHeight-0.05,1.0);\n    vec3 b = vec3(0.5,eyelidHeight,1.0);\n    vec3 c = vec3(0.7,eyelidHeight-0.15,0.85);\n    vec4 eyeLidA = Bezier( P, a, b, c );\n    vec2 eyelidDetailA = vec2(eyeLidA.x-eyelidThickness, MaterialSkin);\n    \n    a = vec3(0.0,eyelidHeight-0.43,1.0);\n    b = vec3(0.5,eyelidHeight-0.47,1.1);\n    c = vec3(0.7,eyelidHeight-0.3,0.85);\n    vec4 eyeLidB = Bezier( P, a, b, c );\n    vec2 eyelidDetailB = vec2(eyeLidB.x-eyelidThickness, MaterialSkin);   \n    \n    \n    eyelidDetailA = DO(eyelidDetailA, t, timeStartEyeDetail+4.0);\n    eyelidDetailB = DO(eyelidDetailB, t, timeStartEyeDetail+4.8);\n    vec2 eyelidDetail = UnionRound(eyelidDetailA, eyelidDetailB, 0.01);\n    \n    return UnionRound(UnionRound(eye,eyeSocket,0.01), eyelidDetail, 0.05);\n}\n\nvec2 doMouth( vec3 P, float t )\n{    \n    float thickness = 0.1;\n    float mouthHeight = -0.3;\n    float bottomMouthHeight = mouthHeight-0.1;\n    \n    vec3 a = vec3(0.0,mouthHeight,1.3);\n    vec3 b = vec3(0.3,mouthHeight,1.3);\n    vec3 c = vec3(0.6,mouthHeight+0.05,1.1);\n    vec4 mouthBezierA = Bezier( P, a, b, c );\n    \n    b = c + (c-b); a = c;\n    c = vec3(1.0,mouthHeight-0.2,0.50);\n    vec4 mouthBezierB = Bezier( P, a, b, c );\n    \n    float topMouthA = mouthBezierA.x - thickness;\n    float topMouthB = mouthBezierB.x-thickness;\n    topMouthA = DO(topMouthA, t, timeStartMouthDetail);\n    topMouthB = DO(topMouthB, t, timeStartMouthDetail+0.8);\n    \n    float topMouth = Union(topMouthA, topMouthB);\n    \n    a = vec3(0.0,bottomMouthHeight,1.3);\n    b = vec3(0.3,bottomMouthHeight,1.3);\n    c = vec3(0.6,bottomMouthHeight+0.05,1.1);\n    vec4 mouthBezierC = Bezier( P, a, b, c );\n    \n    b = c + (c-b); a = c;\n    c = vec3(1.0,mouthHeight-0.2,0.50);\n    vec4 mouthBezierD = Bezier( P, a, b, c );  \n    \n    float bottomMouthA = mouthBezierC.x - thickness;\n    float bottomMouthB = mouthBezierD.x - thickness;    \n    bottomMouthA = DO(bottomMouthA, t, timeStartMouthDetail+1.6);\n    bottomMouthB = DO(bottomMouthB, t, timeStartMouthDetail+2.4);\n    \n    float bottomMouth = Union(bottomMouthA,bottomMouthB);\n    \n    vec2 fullLips = vec2(Union(topMouth, bottomMouth), MaterialLips);\n    \n    return fullLips;\n}\nvec2 doMouthDetail(vec3 P, float t)\n{\n    float mouthHeight = -0.4;\n    vec3 a = vec3(0.95,mouthHeight+0.1,0.4);\n    vec3 b = vec3(1.15,mouthHeight,0.3);\n    vec3 c = vec3(0.95,mouthHeight-0.2,0.4);\n    vec4 detailBezier = Bezier( P, a, b, c );\n    float detail = detailBezier.x - 0.1;    \n    detail = DO(detail, t, timeStartMouthDetail+3.2);    \n    \n    return vec2(detail, MaterialSkin);\n}\n\nvec2 doPepe(vec3 P, float t)\n{\n    vec3 symmetricP = vec3(abs(P.x), P.y, P.z);\n    \n    vec2 mainHead = vec2(Ellipsoid( P, vec3(0.0,0.0,0.05), vec3(1.0,0.8,1.0)), MaterialSkin);\n    //return mainHead;\n    vec2 bottomHead = vec2(Ellipsoid( P, vec3(0.0,-0.35,0.15), vec3(0.75,0.5,0.75)*1.5), MaterialSkin);\n    vec2 backHead = vec2(Ellipsoid( P, vec3(0.0,-0.4,-0.35), vec3(1.0,0.8,0.75)), MaterialSkin);\n    \n    \n    vec2 eyeSocket = vec2(Ellipsoid( symmetricP, vec3(0.25,0.5,0.2), vec3(0.6,0.6,0.6)), MaterialSkin);\n\tvec2 eye = doEye(symmetricP, t);\n    \n    vec2 mouth = doMouth(symmetricP, t);\n    vec2 mouthDetail = doMouthDetail(symmetricP, t);\n    \n    mainHead = DO(mainHead, t, 0.0);\n    bottomHead = DO(bottomHead, t, 0.8);\n    backHead = DO(backHead, t, 1.6);\n    eyeSocket = DO(eyeSocket, t, 2.4);\n\n    \n    vec2 fullHead = UnionRound(\n        UnionRound(mainHead,bottomHead,0.1), \n        backHead, 0.2);\n    fullHead = UnionRound(fullHead, mouthDetail, 0.1);\n\n    \n    return UnionRound(\n        \t\tUnionRound(\n            \t\tUnionRound(fullHead,eyeSocket,0.1), \n            \t\tmouth, 0.01),\n        \t\teye, 0.05); \n}\n\nvec2 Scene( vec3 P )\n{\n\treturn doPepe(P, iTime);\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    Scene( pos + eps.xyy ).x - Scene( pos - eps.xyy ).x,\n\t    Scene( pos + eps.yxy ).x - Scene( pos - eps.yxy ).x,\n\t    Scene( pos + eps.yyx ).x - Scene( pos - eps.yyx ).x );\n\treturn normalize( normal );\n}\n\n// Ray marching stuff from iq\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{  \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = Scene(ro + rd*t ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.004, 0.1 );\n\t\tif( res<0.001 ) break;\n    }\n    return clamp(res*res,0.0,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.0;\n    \n\tvec2 h = vec2(1.0,0.0);\n    vec2 t = vec2(0.0);\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h.x < 0.001 || t.x > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t.x );\n        t = vec2(t.x+h.x, h.y);\n    }\n\n    if ( t.x > maxd )\n    {\n        t.x = -1.0;\n    }\n\t\n    return t;\n}\n\nfloat rainAmount(vec2 frag)\n{\n    // Rain from: https://www.shadertoy.com/view/XdSGDc\n    \n\tfloat dis = 1.;\n    \n    float result = 0.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\n\t\t\tfloat f = pow(dis, .145)+.25;\n\n\t\t\tvec2 st =  f * (frag * vec2(1.5, .05)+vec2(-iTime*.1+frag.y*.5, iTime*.12));\n\t\t\tf = (texture(iChannel3, st * .5, -99.0).x + texture(iChannel3, st*.284, -99.0).y);\n\t\t\tf = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, frag.y*.4+.05);\n\n\t\t\tresult += 0.25*f;\n\t\t\n\t\tdis += 3.5;\n\t}    \n    \n    return result;\n}\n\nvec3 doAtmosphere(vec3 colour, \n                  vec2 frag,\n                  vec3 O, vec3 D, float rayDist)\n{\n    // cone light from https://www.shadertoy.com/view/llBGzm\n    \n    vec3 lightPos = vec3(-0.2, 6.0, -0.3);\n    float intensity = 10.0;\n    \n    float originAlong = dot(lightPos - O, D); \n    vec3 originNearest = O + D * originAlong;\n\n    vec3 normal = vec3(0.0, -1, 0.0);\n    intensity *= pow(max(0.0, dot(normal, normalize(originNearest - lightPos))), 10.0); \n    intensity /= pow(1.0 + distance(lightPos, originNearest) * 1.1, 2.0); \n    \n    float rain = rainAmount(frag)*0.8+0.2;\n    colour += rain*LightColour*intensity;\n    \n    return colour;\n}\n\n\n\n\n// Specular from http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nvec2 ggx_fv(float LoH, float a)\n{\n    float LoH5 = pow(1.0- LoH, 5.0);\n    \n    float k = a*0.5;\n    float k2 = k*k;\n    float ik2 = 1.0-k2;\n    float vis = 1.0/(LoH*LoH*ik2+k2);\n    \n    return vec2(vis, LoH5*vis);\n}\nfloat ggx_d(float NoH, float alpha)\n{\n    float alphaSqr = alpha*alpha;\n    float denom = NoH*NoH*(alphaSqr-1.0)+1.0;\n    return alphaSqr/(3.14159*denom*denom);\n}\nfloat shade_specular(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    vec3 H = normalize(-V+L);\n    float LoH = clamp(dot(L,H),0.0,1.0);\n    float NoH = clamp(dot(N,H),0.0,1.0);\n    float NoL = clamp(dot(L,N),0.0,1.0);  \n    \n    float alpha = roughness*roughness;\n\tfloat D = ggx_d(NoH, alpha);\n    vec2 fv = ggx_fv(LoH, alpha);\n    float FV = F0*fv.x + (1.0-F0)*fv.y;\n    //return D;\n    return NoL*D*FV;\n}\n\nvec3 shade(vec3 V, vec3 P, vec3 N, float material)\n{\n    vec3 R = reflect(V, N);\n    \n    vec3 diffuseLighting = vec3(0.0);\n    vec3 specularLighting = vec3(0.0);\n    \n    // Material parameters\n    vec3 albedo = mix( ColourWhite, ColourBlack, smoothstep(MaterialOuterEye, MaterialInnerEye, material));\n    albedo = mix( albedo, ColourSkin, smoothstep(MaterialInnerEye, MaterialSkin, material));\n    albedo = mix( albedo, ColourLips, smoothstep(MaterialSkin, MaterialLips, material)); \n    float roughness = 0.5*clamp((smoothstep(0.0, MaterialSkin, material))+0.1, 0.0, 1.0);\n    \n    // Lighting\n    float NoV = clamp(-dot(N, V),0.0,1.0);\n    float fresnel = 0.04+0.8*pow(1.0-NoV, 5.0);    \n    \n    {\n        vec3 lightDirection = normalize(vec3(-0.3,1.0,0.1));\n        vec3 L = lightDirection;\n        float NoL = clamp(dot(L,N),0.0,1.0);\n        float shadow = 3.0*NoL*calcSoftShadow(P+N*0.05, lightDirection, 3.0);\n        diffuseLighting += LightColour*shadow;\n        specularLighting += LightColour*shade_specular(N,V,L, roughness, 0.04);\n        \n    }\n        \n    diffuseLighting += 0.1*mix( vec3(1.0,0.71,0.51 )*0.5, LightColour*2.0, N.y*0.5+0.5 ); // ambient light\n    \n    // Outlines\n    float outerEdge = pow(smoothstep(0.0,0.2, NoV), 4.0);\n    float materialEdge = abs(fract(material)-0.5)*2.0;\n    float edge = (outerEdge*materialEdge)*0.8+0.2;    \n    \n    return (albedo*diffuseLighting + specularLighting)*edge;\n}\n\nvec3 render( vec2 uv, in vec3 ro, in vec3 rd )\n{ \n    vec3 colour = vec3(0.0);\n    \n    vec3 V = rd;\n    vec2 hit = castRay(ro, rd);\n    float depth = hit.x;\n    if(hit.x>0.0)\n    {\n        vec3 pos = ro + hit.x * rd;\n        vec3 normal = SceneNormal( pos );\n        colour = shade(rd, \n                       pos, normal, hit.y);\n    }\n    else\n    {\n        depth = 100.0;\n    }\n    \n    \n    colour = doAtmosphere(colour, \n                          uv,\n                          ro, rd, depth);\n    return colour;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // camera\t\n    vec3 ro = vec3( 3.5*cos(6.0*mo.x+iTime*0.1), 2.0*mo.y+0.2, 3.0 + 4.0*sin(6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.1, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) ); \n    \n    vec3 colour = render(uv, ro, rd);\n    colour = pow(colour, vec3(0.4545));\n    \n    fragColor.rgb = colour;\n}","name":"Image","description":"","type":"image"}]}