{"ver":"0.1","info":{"id":"wsd3DS","date":"1570832209","viewed":106,"name":"signed_distance_effect","username":"hyunxi","description":"distanc field for a couple of shapes, effect created through sdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["signeddistance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COLOR_RED vec3(1.,0.,0.)\n#define COLOR_GREEN vec3(0., 1.,0.)\n#define COLOR_BLUE vec3(0.,0.,1.)\n#define COLOR_BLACK vec3(0.,0.,0.)\n#define COLOR_GREY vec3(0.5,0.5,0.5)\n#define COLOR_WHITE vec3(1.,1.,1.)\n\nfloat sdf_sDimond(vec2 uv , vec2 center , float radius)\n{\n    //the corner is not proper\n    vec2 basisVector = normalize(vec2(1.0));\n\tfloat d = dot(abs(uv-center), basisVector);\n    d-=radius;\n    return d;\n}\n\nfloat sdf_circle(vec2 uv , vec2 center , float radius)\n{\n\tfloat distance = length(uv-center)-radius;\n    return distance;\n}\n\nfloat df_lineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //p is uv coordinate,\n    //a is the two points for the line segment\n    p -= a, b -= a; //get vector ap , and vector ab\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    // the b' coorperate vectore which is used to calculate the distance vector\n    return length(p - b * h);                      \n    // dist to segment\n}\n\nfloat sdf_rectagle(vec2 uv,vec2 center,vec2 halfSize)\n{\n    uv-=center;\n    //rectangle signed distance field\n    float c = 0.;\n    vec3 col = vec3(0.);\n    float wd = abs(uv.x)-halfSize.x;\n    float hd = abs(uv.y)-halfSize.y;\n    \n    //get the inside -df\n    //if (wd<0. && hd<0.)\n    //{\n    //    c =max (wd, hd);\n    //}\n    //optimize to \n    //max(wd, hd) get the shortest inside value (minus)\n    //min (0. value) limit the value to be minus, if value larger than 0, 0 is the result\n    float c1 = min (0.,max(wd, hd));  \n\n\n    //get outside df\n    //euqale to : if(wd>0 || hd>0)\n    float c2 = max(max(wd, hd),0.);  \n    \n    //fix corner   \n    if (wd>0. && hd>0.)\n    {\n        c2 = length(abs(uv)-halfSize);\n    }    \n    \n\t//signed distance\n    c =c1 + c2;\n\n    return c;\n}\n\nfloat aaf_step( float x0, float x)\n{\n    return smoothstep(x0 ,x0 +fwidth(x) , x) ;   \n}\n\n\nfloat df_fill(float radius, float blur, float mask)\n{  \n    //mask range : 0 ~ n\n    //radius : size of the shape , this is where the step happens\n    \n    if (blur <.002)\n    {\n        //for shape\n        mask = aaf_step( radius, mask);\n        //for line\n        //mask = smoothstep( 0., radius*2., mask);   // antialiased draw. r >= 1.5\n    }\n    else\n    {\n        mask = smoothstep (radius, radius+blur ,mask);\n    }\n    \n    \n    return mask;\n}\n\nvec3 sdf_colorFill(vec3 in_c, vec3 out_c, vec3 line_c, float line_thickness, float line_blur , float radius, float d)\n{\n    float m;\n\tvec3 c = out_c;\n    //draw the line\n    if (line_thickness >0.001)\n    {\n        m = smoothstep(radius+line_thickness-line_blur/2.,radius+line_thickness+line_blur/2., d);\n    \tc = mix(line_c , out_c , vec3(m));\n    }\n    \n    if (line_blur <0.002)\n    {\n        float pixel_width = 1.5/iResolution.y;\n        line_blur = pixel_width;\n    }\n    m = smoothstep(radius-line_blur/2.,radius+line_blur/2., d); \n    c = mix(in_c , c , vec3(m));\n    return c; \n}\n\nvec3 sdf_Neon(vec3 NeonC, float radius, float d)\n{\n    //make both inside outside positive\n    float t = abs(d-radius);\n    //infinity when t is close to 0 with sharp falloff\n    t = pow(1./t,0.8);\n    //control the glow range\n    t *=.01;\n    //add in color\n    vec3 col = vec3(t) * NeonC;\n\treturn col;\n}\n\nvec3 sdf_Neon_stroke(vec3 NeonC, float line_thickness,  float radius, float d)\n{\n    vec3 col = vec3(0.);\n    vec3 neonColor = vec3(0.3,0.1,0.15);\n    line_thickness/=2.;\n    //optimize : \n    //if ((d- line_thickness <radius  ) &&(d+line_thickness>radius))   \n    \n    //optimize : create smooth edge\n    //if (abs(d-radius)<line_thickness)\n    //    m = 1.;\n    \n    //d[1,0,1] \n    d = smoothstep(0.,line_thickness,abs(d-radius));\n        \n\t//minus one to eliminate the ouside, should be a better way here\n    float t = 1./d -1.; //[infinity, 0]\n    //adjust falloff of neon\n    t = pow(t,1.);\n\n    col = vec3(t)*NeonC;\n    \n\treturn col;\n}\n\nvec3 sdf_edgeGradient(float radius, float d)\n{\n    \n    //todo\n    //make function color hue = f(d)\n    vec3 col = vec3(d,0.,0.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1.,1.,1.);\n    vec2 R = iResolution.xy;\n    // Normalized uv\n    vec2 uv = (2.*fragCoord - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    float m =0.;\n    vec2 c = vec2(.1,.3);\n    float r = .15;\n    \n    \n\t\n    // rectangle distance field\n    vec2 r1_r = vec2(0.05,0.04);\n    vec2 r2_r = vec2(0.07,0.04);\n    float r1 = sdf_rectagle(uv,vec2(0.,0.),r1_r);\n    float r2 = sdf_rectagle(uv,c, r2_r);\n    //merge two sdh\n    m = min (r1,r2);\n    //color fill signed distance field\n    float line_thickness = 0.06;\n    float shadow_distance = 0.06;\n    float line_blur = 0.04;\n    float radius = 0.2;\n    \n    //dimond\n    //m = sdf_sDimond(uv,c, r);\n        \n    //cicle\n    //m = sdf_circle (uv,c,r);\n    \n    //line seg\n    //m = df_lineSeg(uv,vec2(0.,0.),vec2(.2,.5));\n    \n    //shape creation\n    //m = df_fill(1./iResolution.y,0., m);\n    \n    //color space -> sRGB\n    //m = pow(m,1./2.2);\n    \n    \n    //sdf fill\n\t//vec3 col = sdf_colorFill(COLOR_RED,COLOR_BLACK,COLOR_BLUE,line_thickness,line_blur, radius, m);\n    \n    //sdf neon stroke\n    //vec3 neon_color = vec3(.05, 0.01, 0.2);\n    //vec3 col = sdf_Neon_stroke(neon_color,line_thickness, radius, m);\n    \n    //edge texture\n    //vec3 col = sdf_edgeGradient(radius, m);\n    \n    //vec3 col = COLOR_BLACK;\n    //col = sdf_colorFill(col,COLOR_BLACK,COLOR_BLUE,line_thickness,line_blur, radius, m);\n    \n    //**simple shadow example**//\n    //shadow layer\n    \tm = sdf_sDimond(uv-vec2(0.02 , -0.03),c, r);\n    \tcol = sdf_colorFill(COLOR_BLACK,col,COLOR_BLUE,0.,0., radius, m);\n    //shapeLayer\n   \t\tm = sdf_sDimond(uv,c, r);\n    \tcol = sdf_colorFill(COLOR_RED,col,COLOR_BLUE,0.,0., radius, m);\n    //**simple shadow example**//\n    \n    // Output to screen\n    col = pow(col,vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}