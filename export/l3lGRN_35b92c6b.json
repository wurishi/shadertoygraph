{"ver":"0.1","info":{"id":"l3lGRN","date":"1707225035","viewed":89,"name":"Rain Splotches","username":"FiveLimbedCat","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRIDSIZE (1.0/30.0)\n#define RADIUS_MIN 0.2\n#define RADIUS_MAX 0.5\n#define LIFETIME 2.0\n#define DENSITY 0.1\n#define RAIN_STAY 0.5\n\n#define RIPPLE_H .2\n#define RIPPLE_WIDTH 0.5\n#define RIPPLE_R 1.0\n#define RIPPLE_LIFETIME .1\n\n#define SHOW_RIPPLE 0\n\n// https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\nfloat rain_fade_curve(float normalised_t)\n{\n    if(normalised_t < RAIN_STAY)\n        return 1.0;\n    \n    float val = mix(1.0, 0.0, (normalised_t - RAIN_STAY) / (1.0 - RAIN_STAY));\n    return val * val;\n}\n\nfloat smoothstep_deriv(float x)\n{\n    return 6.0 * x * (1. - x);\n}\n\nfloat ripple_deriv(float x){\n    return (x < .5 ? smoothstep_deriv(x * 2.) : -smoothstep_deriv(2. - x * 2.));\n}\n\nvec3 udn_blend(vec3 n1, vec3 n2)\n{\n    return normalize(n1 + vec3(n2.xy, 0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 grid_uv = uv / GRIDSIZE;\n    ivec2 grid = ivec2(grid_uv);\n    grid_uv -= vec2(grid);\n    \n#if SHOW_RIPPLE == 0\n    vec3 col = vec3(0.0);\n#else\n    vec3 col = vec3(0.0, 0.0, 1.0);\n#endif\n    \n    for(int i = -1; i <= 1; i++)\n        for(int j = -1; j <= 1; j++){\n            ivec2 grid_curr = grid + ivec2(i, j);\n            float t_offset = float(iqint3(uvec2(grid_curr))) * (1.0/float(0xffffffffu));\n\n            float residual = mod((iTime / LIFETIME + t_offset), 1.0f);\n            uint timestep = uint(iTime / LIFETIME + t_offset);\n            uvec3 hash = pcg3d(uvec3(grid_curr, timestep));\n            vec3 float_hash = vec3(hash) * (1.0/float(0xffffffffu));\n            if(float_hash.z < DENSITY){\n                vec2 to_centre = vec2(i, j) + float_hash.xy - grid_uv;\n                float dist_sqr = dot(to_centre, to_centre);\n                \n                #if SHOW_RIPPLE == 0\n                float drop_radius = mix(RADIUS_MIN, RADIUS_MAX, float(iqint3(hash.yz)) * (1.0/float(0xffffffffu)));\n                if(dist_sqr < drop_radius * drop_radius)\n                    col = max(col, vec3(rain_fade_curve(residual)));\n                #else\n                float ripple_lifetime = residual / RIPPLE_LIFETIME;\n                if(ripple_lifetime < 1.){\n                    float ripple_radius = mix(0., RIPPLE_R, ripple_lifetime);\n                    float ripple_inner_radius = ripple_radius - RIPPLE_WIDTH;\n                    \n                    float band_lerp = (sqrt(dist_sqr) - ripple_inner_radius) / RIPPLE_WIDTH;\n                    if(band_lerp > 0. && band_lerp < 1.){\n                        // band_lerp = sqrt(band_lerp);\n                        \n                        float deriv = ripple_deriv(band_lerp) * mix(RIPPLE_H, 0., ripple_lifetime * ripple_lifetime);\n                        \n                        vec3 grad = vec3(normalize(to_centre), -deriv);\n                        vec3 bitangent = vec3(-grad.y, grad.x, 0);\n                        vec3 normal = normalize(cross(grad, bitangent));\n                        \n                        col = udn_blend(col, normal);\n                    }\n                       \n                }\n                \n                #endif\n            }\n        }\n\n#if SHOW_RIPPLE == 1\n    col = col * .5 + .5;\n#endif\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}