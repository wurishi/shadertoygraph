{"ver":"0.1","info":{"id":"4X3SWj","date":"1719530761","viewed":60,"name":"Raymarched Cloud","username":"GoodName","description":"Use the mouse to look around it (a little messed up might fix it later).\nA raymarched volumetric cloud to try out raymarching for the first time. NOTE: some unnecessary code is left in for testing purposes.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0. )/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    //q.x = mod(p.x, 3.) - 1.5;\n    //q.z = mod(p.z, 3.) - 1.5;\n    float s1 = sdEllipsoid(q - vec3(0, 0., 0), vec3(5, 2., 3.5)); \n    float s2 = sdEllipsoid(q - vec3(.5, .7, 0), vec3(3.2, 2.5, 1.5));\n    float s3 = sdEllipsoid(q - vec3(-.5, -1.1, 1.), vec3(1., 1., 1.5));\n    return smin(smin(s1, s2, 1.5), s3, 1.5);\n    \n   //return sdBox(q - vec3(0., 2., 0.), vec3(3., 3., 3.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / 100.;\n\n    bool cloud = false;\n    float density = 0.;\n    \n    vec3 light = vec3(1., 5., 1.);\n    float lightIntensity = 7.;\n    \n    vec3 ro = vec3(0, 0, -7. /*+ float(iFrame)/25.*/);       \n    vec3 rd = normalize(vec3(uv, 1)); \n    vec3 col = vec3(0);               \n    float d;\n\n    float t = 0.; \n    \n    ro.xz *= rot2D(/*0.785398*/-m.x);\n    rd.xz *= rot2D(/*0.785398*/-m.x);\n    \n    ro.yz *= rot2D(/*0.785398*/-m.y);\n    rd.yz *= rot2D(/*0.785398*/-m.y);\n    \n\n    vec3 p;\n    bool done = false;\n    \n    float darkness = 0.;\n    vec3 blend = vec3(.1, .5, 1.);\n    \n    if (true)\n    {\n        for (int i = 0; i < 80; i++) {\n            p = ro + rd * max(t, .2);     \n\n            d = map(p);         \n\n            t += d;                 \n\n            if (d < .001)\n            {\n                cloud = true;\n                break;\n            }\n            if (t > 50.) \n            {\n                done = true;\n                break;    \n            }\n        }\n\n        if (cloud == true)\n        { \n            int count = 0;\n            \n            do\n            {\n                t += .05;\n                p = ro + rd * t;\n\n                d = map(p);\n                density += texture(iChannel0,vec3((p.x/20.)+float(iTime/50.), vec3(p/20.).yz)).r * .04;\n                \n                if (d < .01)\n                {\n                    int lightCount = 0;\n                    count++;\n                    float d2;\n                    float t2 = 0.;\n                    vec3 ld = normalize(vec3(light-p));\n                    \n                    do\n                    {\n                        d2 = map(vec3(p + ld * t2));\n                        t2 += .1;\n                        lightCount++;\n                        \n                    }while(d2 < 0.);\n                    \n                    darkness += float(lightCount)/(10.*lightIntensity);\n                }\n            } while (d < 0. && density < 1.);\n            darkness = darkness / float(count);\n        }\n    }\n    \n    density = pow(2., (density-1.) * 5.) - .1;\n    \n    float lighting = 1.-darkness;\n    \n    blend = vec3(.1, .5, 1.);\n    \n    if (cloud == false) col = vec3(.1, .5, 1.);\n    else col = vec3(blend.x + density * (lighting-blend.x), blend.y + density * (lighting-blend.y), blend.z + density * (lighting-blend.z));\n\n    fragColor = vec4(col, .1);\n}\n\n","name":"Image","description":"","type":"image"}]}