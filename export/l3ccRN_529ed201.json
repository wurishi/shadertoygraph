{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = iResolution.xy * 0.5;\n    vec2 toPixel = fragCoord - center;\n    float distFromCenter = length(toPixel);\n\n    fragColor = vec4(1.0); // White background\n  \n    // Settings:\n    float baseArmWidth = 15.0;\n    float transitionArmWidth = 22.5;\n    float maxArmLength = 250.0;\n\n    float scale = 0.5; // Scaling factor for size reduction\n\n    float armWidth = (distFromCenter >= baseArmWidth*scale && distFromCenter < transitionArmWidth*scale) ? baseArmWidth * scale: 2.5 *scale;\n    float scaledMaxArmLength = maxArmLength * scale;\n\n    // Mouse Arm\n    bool isOnFirstArm = false;\n    if(iMouse.x > 0.0) {\n      vec2 mouseDir = normalize(iMouse.xy - center);\n      float mouseDist = dot(toPixel, mouseDir);\n      vec2 mouseProjected = center + mouseDir * mouseDist;\n      if(mouseDist >= baseArmWidth *scale && mouseDist <= scaledMaxArmLength &&\n         length(fragCoord - mouseProjected) <= armWidth) {\n        fragColor = vec4(0.0);\n        isOnFirstArm = true;\n       }\n    }\n\n    // Fixed Arm\n    bool isOnSecondArm = false;\n    vec2 arm2Dir = vec2(1.0, 0.0);\n    float arm2Dist = dot(toPixel, arm2Dir);\n    vec2 arm2Projected = center + arm2Dir * arm2Dist;\n    if(arm2Dist >= baseArmWidth*scale && arm2Dist <= scaledMaxArmLength &&\n        length(fragCoord - arm2Projected) <= armWidth) {\n        fragColor = vec4(0.0);\n        isOnSecondArm = true;\n    }\n\n    // Contact Check\n    if((isOnFirstArm || isOnSecondArm) && distFromCenter >= baseArmWidth*scale && distFromCenter < 30.0*scale) {\n        bool touchingOtherArm = false;\n        for(int i = -1; i <= 1; i++) {\n            for(int j = -1; j <= 1; j++) {\n                if(i == 0 && j == 0) continue;\n                vec2 checkPos = fragCoord + vec2(float(i), float(j));\n                float checkDist = length(checkPos - center);\n                if(checkDist >= baseArmWidth*scale && checkDist < 30.0*scale) {\n\n                   vec2 toCheck = checkPos - center;\n\n                    // Check if the neighbor is part of the other arm (using the same drawing logic)\n                    if (isOnFirstArm) {\n                        float checkArm2Dist = dot(toCheck, arm2Dir);\n                        vec2 checkArm2Projected = center + arm2Dir * checkArm2Dist;\n                        if(checkArm2Dist >= baseArmWidth *scale && checkArm2Dist <= scaledMaxArmLength &&\n                           length(checkPos - checkArm2Projected) <= armWidth) {\n                            touchingOtherArm = true;\n                          }\n                     } else {\n                        if(iMouse.x > 0.0) {\n                            vec2 mouseDir = normalize(iMouse.xy - center);\n                            float checkArm1Dist = dot(toCheck, mouseDir);\n                            vec2 checkArm1Projected = center + mouseDir * checkArm1Dist;\n                            if(checkArm1Dist >= baseArmWidth *scale && checkArm1Dist <= scaledMaxArmLength &&\n                               length(checkPos - checkArm1Projected) <= armWidth) {\n                                touchingOtherArm = true;\n                            }\n                        }\n                    }\n\n                }\n               if(touchingOtherArm) break;\n            }\n           if(touchingOtherArm) break;\n        }\n\n        if(touchingOtherArm) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"l3ccRN","date":"1734790673","viewed":87,"name":"Mech. Acute Marker 1","username":"Chimel","description":"Mechanical Acute ( < 90°) angle detector, where the arms start to overlap at a < 90° the pixels turn red.\n\nCurious if there is a way to make this 'semi-CA-ish' concept faster than Geometric angle detection.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["detector","acute","semica"],"hasliked":0,"parentid":"","parentname":""}}