{"ver":"0.1","info":{"id":"tlSczt","date":"1595076120","viewed":238,"name":"Superior Ecopoiesis","username":"kesson","description":"A Shader experiment, following the articles of the master. Links in the code.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","noise","fbm","warp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Shader experiment\n//\n// Special thanks to Inigo Quilez for his articles\n// Sources:\n// https://iquilezles.org/articles/raymarchingdf\n// https://iquilezles.org/articles/smin\n// https://iquilezles.org/articles/fbm\n// https://iquilezles.org/articles/warp\n// https://iquilezles.org/articles/morenoise\n// https://iquilezles.org/articles/terrainmarching\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define RAYMARCH_MAX_STEPS \t\t128\n#define RAYMARCH_MAX_DIST \t\t200.0\n#define RAYMARCH_SURFACE_DIST \t0.0001\n#define NUM_SATELLITES 32.0\n#define NOISE_OCTAVES 8\n#define FBM_OCTAVES 4\n#define PI 3.14159265359\n\n//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec3 noised( in vec2 x ) {\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel1, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel1, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel1, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel1, (p+ivec2(1,1))&255, 0 ).x;\n\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat fbm( in vec2 x) {\n    float a = 0.2;\n    float t = 0.0;\n    for( int i=0; i < FBM_OCTAVES; i++ ) {\n        t += a*noise(vec2(x));\n        x = x * 2.0;\n        a *= 0.4;\n    }\n    return t;\n}\n\nvec2 getAngle(vec3 p) {\n    float theta = asin(p.z / length(p));\n    float phi = atan(p.y, p.x);\n    return vec2(theta, phi);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat getSatellite(vec3 p, float i) {\n  float t = iTime * 0.123;\n  float t2 = iTime * 0.1543;\n  float t3 = iTime * 0.5;\n  float dFromP = (1.0 - fract(t2 + hash(i))) * 4.0;\n  float theta = t3 + i;\n  float phi = t2 + i;\n  float x = dFromP * sin(theta) * cos(phi);\n  float y = dFromP * sin(theta) * sin(phi);\n  float z = dFromP * cos(theta);\n  vec4 satellite = vec4(x, y, z,  hash(i) * 0.1);\n  return length(p - satellite.xyz) - satellite.w;\n}\n\nfloat getPlanet(vec3 p) {\n  vec2 uv = (p.xz / 6.0) + 0.5;\n  float t = iTime * 0.01;\n  float m = 1.0;\n  float v = 1.0;\n  vec3 n = vec3(0.2);\n  vec2 nst = 1.0 + abs(sin(0.0 + getAngle(p)));// + iTime * 0.1;\n  nst = fract(nst + t);\n  nst.x *= 1.243;\n  nst.y *= 1.234;\n  for (int i = 0; i < NOISE_OCTAVES; i++) {\n    n += noised(nst * m) * v;\n    m *= 2.0;\n    v *= 0.6;\n  }\n  vec4 sphere = vec4(n.xyz, 1.0 + n.z);\n  return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat getDist(vec3 p) {\n    float planetDist = getPlanet(p);\n    float sd1 = getSatellite(p, 0.0);\n    for (float i = 0.0; i < NUM_SATELLITES; i++) {\n      sd1 = smin(sd1, getSatellite(p, i), 0.5);\n    }\n    return smin(planetDist, sd1, 2.0);\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, in int mr ) {\n    float t = RAYMARCH_SURFACE_DIST;\n\tfor( int i=0; i<RAYMARCH_MAX_STEPS; i++ ) {\n        vec3 pos = ro + t*rd;\n\t\tfloat h = getDist(pos);\n        if (abs(h) < RAYMARCH_SURFACE_DIST) {\n            mr = 1;\n            break;\n        }\n\n        if (abs(h) > RAYMARCH_MAX_DIST) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(0.01, 0.0);\n\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n\n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0.01, 1.0);\n\n    int mr = 0;\n    float d = raycast(p + RAYMARCH_SURFACE_DIST * 2.0, lightPos, mr);\n    if (d < length(lightPos-p)) dif *= 0.15;\n\n    return dif;\n}\n\nvoid camera( in float an, in vec2 uv, out vec3 ro, out vec3 rd ) {\n    // Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\n    float cd = 0.001;\n    cd = 3.025 + (sin(an) + 2.0);\n    ro = vec3( cd*cos(an+sin(iTime*0.5)*0.1), (((sin(an) * 0.5) + 0.5) * 2.0), cd*sin(an+cos(iTime*0.5)*0.1) ) * 1.0;\n    ro += noise(iTime*0.51)*0.51;\n    ro.x += 2.75;\n    ro.y -= 0.0;\n    vec3 ta = vec3( cos(an+sin(iTime*0.5)*0.1), 0.0, sin(an+cos(iTime*0.5)*0.1) );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n    float an = 0.5;\n    an = -iTime * 0.2;\n    \n    vec3 ro, rd;\n    camera(an, uv, ro, rd);\n    \n    // FBM, the background\n    vec2 st = vec2(rd.x * 8.0, rd.y * 4.0);\n\n    vec3 color = vec3(0.0);\n    vec3 fCol = vec3(0.0);\n\n    // First layer of warping\n    vec2 q = vec2(fbm( st ),\n             \t\t\tfbm( st + vec2(1.0) ) );\n\n    // Second layer of warping\n    vec2 r = vec2(fbm( st + q + vec2(1.7, 9.2) + 1.250 * iTime ),\n             \t\t\tfbm( st + q + vec2(8.3, 2.8) + 1.2 * iTime ) );\n\n    // float f = fbm(st + vec2(fbm(st + vec2(fbm(st + r)))));\n    float f = fbm(st + r);\n\n    color = mix(vec3(0.0),\n                vec3(0.666667,0.498039,0.498039)*0.5,\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.5),\n                clamp(length(r.x),0.0,1.0));\n\n    color = pow(color, vec3(2.0));\n\n\n    int mr = 0;\n    float d = raycast(ro, rd, mr);\n\n    if (d < 12.0) {\n      float ld = 7.5 + (sin(an) + 1.0);\n      float lan = iTime * 0.123;\n      vec3 lp =  vec3(ld*sin(lan), 3.0, ld*cos(lan) );\n\n      vec3 p = ro + rd * d;\n\n      vec2 uvT = abs(sin(getAngle(p)));\n      uvT = fract(uvT + iTime * 0.05);\n\n      fCol = texture(iChannel0, uvT).rgb;\n\n      float dif = clamp(getLight(p, lp), 0.0, 1.0);\n      fCol *= vec3(dif);\n\n    } else {\n      fCol += color;\n    }\n\n    float dMask = smoothstep(5.0, 8.0, d);\n\n    fCol = pow(fCol, vec3(0.6)); // gamma correction\n\n    fragColor = vec4(fCol,  dMask);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//  Blur  effect\n//  Edited  from  https://www.shadertoy.com/view/XdfGDH\n\nfloat  normpdf(in float  x,  in float  sigma)  {\n    return  0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2  uv = fragCoord / iResolution.xy;\n    \n    vec3  c = texture(iChannel0, uv).rgb;\n    \n    vec2  center = vec2(0.5, 0.5);\n\n    float  d = smoothstep(0.3, 1.0, 0.1 + distance(center, uv));\n\n    //  grain  effect\n    float  strength = 12.0;\n    float  x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3  grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n    const int  mSize = 11;\n    const int  kSize = (mSize - 1) / 2;\n    float  kernel[mSize];\n    vec3  final_colour = vec3(0.0);\n\n    //create  the  1-D  kernel\n    float  sigma = 0.001 + texture(iChannel0, uv).w * 4.0;//7.0;\n    float  Z = 0.0;\n    for (int  j = 0; j <= kSize; ++j) {\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n    }\n\n    //get  the  normalization  factor  (as  the  gaussian  has  been  clamped)\n    for (int  j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read  out  the  texels\n    for (int  i = -kSize; i <= kSize; ++i) {\n        for(int  j = -kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize + j] * kernel[kSize + i] * texture(iChannel0, (gl_FragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n                }\n    }\n\n    vec3  c_step_1 = final_colour / (Z * Z);\n\n    float  nd = 1.0 - d;\n    vec3 c_step_2 = clamp(c_step_1 * nd, 0.0, 1.0);\n\n    // I don't like the image too clean\n    c_step_2 += grain * 1.0;\n\n    fragColor = vec4(c_step_2, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}