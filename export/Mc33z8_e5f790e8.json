{"ver":"0.1","info":{"id":"Mc33z8","date":"1711990683","viewed":12,"name":"casserole_magique #3","username":"casserole_magique","description":"raytracer","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF 3.402823466e+38\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define NITER 60\n#define FOCAL_DISTANCE 4.5\n#define DIV_AT_OR 0.02\n\nuint rng_state;\n\nuint pcg_hash(uint i)\n{\n    uint state = i * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nvoid set_seed(uint seed)\n{\n    rng_state = pcg_hash(seed);\n}\n\nuint pcg_rand()\n{\n    rng_state = pcg_hash(rng_state);\n    return rng_state;\n}\n\nfloat randf(float minf, float maxf)\n{\n    float r = float(pcg_rand() % 16777216u) / 16777216.;\n    return r * (maxf - minf) + minf;\n}\n\nvec2 rand_vec2()\n{\n    float r = pow(randf(0., 1.), 2.);\n    float theta = randf(0., TAU);\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec3 rand_dir()\n{\n    float phi = randf(-PI, PI);\n    float S = randf(-1., 1.);\n    float C = sqrt(1. - S*S);\n    \n    return vec3(C * cos(phi), C * sin(phi), S);\n}\n\n\nstruct Material {\n    vec4 color;\n};\n\nstruct Sphere {\n    vec3 p;\n    float r;\n    Material material;\n};\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir;\n};\n\nstruct SphereHit {\n    bool didHit;\n    bool inside;\n    float dst;\n    vec3 p;\n    vec3 n;\n};\n\nstruct HitInfo {\n    bool didHit;\n    float dst;\n    vec3 p;\n    vec3 n;\n    Material material;\n};\n\n\n// from Inigo Quilez' website\nSphereHit raySphere(Ray ray, Sphere sphere)\n{\n    SphereHit hit;\n    vec3 aro = ray.ori - sphere.p; // adjusted ray origin to relocate the sphere at (0,0,0)\n\n    float b = dot( aro, ray.dir );\n    vec3 qc = aro - b * ray.dir;\n    float h = sphere.r * sphere.r - dot( qc, qc );\n\n    if( h >= 0. )\n    {\n        h = sqrt(h);\n        hit.dst = -b - h;\n        if( hit.dst < 0. )\n        {\n            hit.dst = -b + h;\n            if( hit.dst >= 0. )\n            {\n                hit.inside = true;\n                hit.didHit = true;\n            }\n        }\n        else hit.didHit = true;\n        \n        hit.p = ray.ori + hit.dst * ray.dir;\n        hit.n = normalize(hit.p - sphere.p);\n        if( hit.inside ) hit.n *= -1.;\n    }\n\n    return hit;\n}\n\n\nint nSphere = 3;\nSphere[] spheres = Sphere[]( \n    Sphere( vec3(-1,1,-1),          1.,     Material( vec4(1,0,0,0) ) ),\n    Sphere( vec3(.5,0,12),     .8,     Material( vec4(0,0,1,0) ) ),\n    Sphere( vec3(1,-2,15),     1.5,    Material( vec4(0,1,0,0) ) )\n);\n\nHitInfo rayCast(Ray ray)\n{\n    HitInfo closest;\n    closest.dst = INF;\n    \n    for(int i = 0; i < nSphere; i++)\n    {\n        Sphere sphere = spheres[i];\n        SphereHit sphereHit = raySphere(ray, sphere);\n        \n        if(sphereHit.didHit && sphereHit.dst < closest.dst)\n        {\n            closest.didHit = true;\n            closest.dst = sphereHit.dst;\n            closest.p = sphereHit.p;\n            closest.n = sphereHit.n;\n            closest.material = sphere.material;\n        }\n    }\n    return closest;\n}\n\n\nvec3 sky = normalize(vec3(0,1,0));\nvec3 skyBox(vec3 rd)\n{\n    float skyIntensity = dot(sky, rd);\n    skyIntensity = smoothstep(-0.1, -.075, skyIntensity);\n    return mix(vec3(0.318,0.318,0.318), vec3(0.373,0.722,0.980), skyIntensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_seed(uint(fragCoord.x * 3607. + fragCoord.y * 19503. + iTime * 0.));\n    \n    vec2 pix = (fragCoord * 2. - iResolution.xy) / iResolution.y; // pixel coordinates\n    vec2 mouse = (iMouse.xy * 2. - iResolution.xy) / iResolution.y; // mouse coordinates\n    vec3 col;\n    \n    vec3 light = normalize(vec3(1, 2, 0));\n    \n    vec3 cp = 20. * normalize(vec3(cos(.5 * iTime),0,sin(.5 * iTime))); // camera position\n    vec3 cd = normalize(-cp); // camera direction (normalized)\n\n    // camera local coordinates system\n    vec3 u = normalize(vec3(-cd.z, 0, cd.x)); // or u = cross(cd, vec3(0, 1, 0));\n    vec3 v = cross(u, cd);\n    \n    float fov = 0.5; // field of view\n    vec3 rd = normalize(cd + fov * (pix.x * u + pix.y * v)); // center ray direction\n    \n    // center ray local coordinates system\n    vec3 ru = normalize(vec3(-rd.z, 0, rd.x)); // or ru = cross(rd, vec3(0, 1, 0));\n    vec3 rv = cross(u, rd);\n    \n    // optical parameters\n    float eps = DIV_AT_OR; // delta between the origin points\n    float fd = FOCAL_DISTANCE; // focal distance\n    \n    vec3 fp = cp + rd * fd; // focal point\n    \n    int niter = NITER;\n    float total_weight = 0.;\n    \n    for(int i = 0; i < niter; i++)\n    {\n        vec3 partial_col;\n        vec2 rnudge = rand_vec2();\n        rnudge = pow(length(rnudge), 2.) * normalize(rnudge);\n        \n        vec3 offset = eps * normalize(rnudge.x * ru + rnudge.y * rv);\n        \n        \n        Ray ray;\n        ray.ori = cp + offset;\n        ray.dir = normalize(fp - ray.ori);\n\n        HitInfo hit = rayCast(ray);\n        if(hit.didHit)\n        {\n            partial_col = hit.material.color.xyz;\n            partial_col *= dot(hit.n, light);\n        }\n        else\n        {\n            partial_col = skyBox(ray.dir);\n        }\n        partial_col = clamp(partial_col, 0., 1.);\n        \n        float weigth = exp(-10. * length(rnudge)); // am not a good enough probabilist to find a good value for that, maybe what i did is not even changing anything\n        col += partial_col * weigth;\n        total_weight += weigth;\n    }\n    \n    col /= total_weight;\n\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}