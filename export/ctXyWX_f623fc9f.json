{"ver":"0.1","info":{"id":"ctXyWX","date":"1691240254","viewed":68,"name":"Ray-Cylinder intersection (inf)","username":"Envy24","description":"Can someone help with normal approximation artifacts?\n\nHold LMB to change normal from exact to approximate.\nHow to apply scaling, rotation, and translation showed here: https://www.shadertoy.com/view/mtXyDS","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","intersection","approximation","normal","infinite","cylinder"],"hasliked":0,"parentid":"ctXcDB","parentname":"0. Raytracer (base)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec3 get_background() { return vec3(.1, .4, .6); }\n\nHIT find_closest_intersection(RAY ray)\n{\n    HIT closest_hit;\n    closest_hit.hit_dist = 9e5;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n        HIT hit;\n        switch(i)\n        {\n        case 0: hit = ray_infinite_cylinder_XZ_int(ray); break;\n        case 1: hit = ray_infinite_cylinder_XY_int(ray); break;\n        case 2: hit = ray_infinite_cylinder_YZ_int(ray); break;\n        }\n        \n        if (hit.hit_something == true &&\n            closest_hit.hit_dist > hit.hit_dist)\n        {\n            closest_hit = hit;\n        }\n    }\n    return closest_hit;\n}\n\n// You can also approximate normal like in \n// raymarching, but this routine less stable.\n// Only for static scenes.\nvec3 approximate_normal(RAY ray, HIT hit)\n{\n    const vec2 e = vec2(0.01, 0);\n    RAY ray_;\n    ray_.position = hit.hit_point - ray.direction*0.5;\n    \n    ray_.direction = ray.direction + e.xyy;\n    HIT hit_0 = find_closest_intersection(ray_);\n    \n    ray_.direction = ray.direction + e.yxy;\n    HIT hit_1 = find_closest_intersection(ray_);\n    \n    vec3 r = normalize(hit_0.hit_point - hit.hit_point),\n         u = normalize(hit_1.hit_point - hit.hit_point),\n         f = normalize(cross(r, u));\n    //return f;   \n    return f * ( dot(ray.direction, f) >= 0. ? -1. : 1. ); // small improvment\n}\n\nvec3 lambert(RAY ray, HIT hit) // lambert reflectance model\n{\n    vec3 light_pos = vec3(sin(iTime)*10.,10,10),\n         hp_to_l = normalize(light_pos - hit.hit_point),\n         obj_col = 1.-get_background(); \n      \n    float diffuse = iMouse.z > 0. ?\n        max(dot(hp_to_l, approximate_normal(ray, hit)), 0.) :\n        max(dot(hp_to_l, hit.hp_normal), 0.);\n    \n    return hit.hit_something == true ?\n        obj_col * diffuse :\n        get_background();\n}\n\nvec3 scene(vec2 SC)\n{\n    // Generate primary ray.\n    vec2 MP = iMouse.xy == vec2(0) ?\n        vec2(0) :\n        map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n    RAY ray = perspective_camera(SC, vec3(30,20,10), vec3(MP, 0), iResolution.xy);\n\n    // Trace scene.\n    HIT hit = find_closest_intersection(ray);\n    \n    // Process lights.\n    return lambert(ray, hit);\n}\n\n// Basic anti-aliasing (supersample).\nvec3 OSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = 1.,          // [0; inf)\n    inv = 1./(2.*order + 1.),\n    blur = 1.;                 // (0, inf)\n\n    for (float y = -order; y <= order; y += 1.0)\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            vec2 offset = (blur*vec2(x, y)) * inv;\n            col += scene(SC + offset);\n        }\n        \n    order = 2.*order + 1.;\n    return col / (order*order);  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    //O = vec4(scene(SC),1.0);\n    O = vec4(OSSAA(SC), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Structures.\nstruct RAY\n{\n    vec3 position;\n    vec3 direction;\n};\nstruct HIT\n{\n    bool hit_something;\n    float hit_dist;\n    vec3 hit_point;\n    vec3 hp_normal;\n};\n\n// Cameras.\nRAY perspective_camera(vec2 SC, vec3 position, vec3 look_at, vec2 resolution)\n{\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = position;\n\n    vec3 f = normalize(look_at - camera);               // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n        \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = resolution.x / resolution.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n\n    return RAY(\n        camera,\n        normalize(uv.x * r + uv.y * u + f * zFocalLength));\n}\n\n// Ray-Object intersection routines.\nHIT ray_infinite_cylinder_XZ_int(RAY ray)\n{\n    // Cylinder definition:\n    // pos = vec3(0), radius = 1\n    // equation: x^2 + z^2 = r^2\n\n    float k = ray.position.x, l = ray.direction.x,\n          m = ray.position.z, n = ray.direction.z,\n          a = l*l + n*n,\n          b = 2. * (k*l + m*n),\n          c = k*k + m*m - 1.; // 1 is squared cylinder radius\n    \n    /* Solve a*t^2 + b*t + c = 0 */\n    float discriminant = b * b - 4.0 * a * c,\n          sqrt_D = sqrt(discriminant),\n          sign_b = b >= 0.? 1. : -1.,\n          root = min(\n            -(b + sign_b*sqrt_D) / (2.*a),\n            -(2.*c) / (b+sign_b*sqrt_D));      \n    /**/\n        \n    HIT hit;\n    \n    if (discriminant < 0. || // no real roots?\n        root < 0.)           // behind camera?\n    { \n        hit.hit_something = false; \n        return hit; \n    }\n    \n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = -normalize(vec3(0,hit.hit_point.y,0) - hit.hit_point);\n    \n    return hit;\n}\nHIT ray_infinite_cylinder_XY_int(RAY ray)\n{\n    // Cylinder definition:\n    // pos = vec3(0), radius = 1\n    // equation: x^2 + y^2 = r^2\n    \n    float k = ray.position.x, l = ray.direction.x,\n          m = ray.position.y, n = ray.direction.y,\n          a = l*l + n*n,\n          b = 2. * (k*l + m*n),\n          c = k*k + m*m - 1.;\n    \n    /* Solve a*t^2 + b*t + c = 0 */\n    float discriminant = b * b - 4.0 * a * c,\n          sqrt_D = sqrt(discriminant),\n          sign_b = b >= 0.? 1. : -1.,\n          root = min(\n            -(b + sign_b*sqrt_D) / (2.*a),\n            -(2.*c) / (b+sign_b*sqrt_D));\n    /**/\n        \n    HIT hit;\n    \n    if (discriminant < 0. || // no real roots?\n        root < 0.)           // behind camera?\n    { \n        hit.hit_something = false; \n        return hit; \n    }\n    \n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = -normalize(vec3(0,0,hit.hit_point.z) - hit.hit_point);\n    \n    return hit;\n}\nHIT ray_infinite_cylinder_YZ_int(RAY ray)\n{\n    // Cylinder definition:\n    // pos = vec3(0), radius = 1\n    // equation: y^2 + z^2 = r^2\n\n    float k = ray.position.y, l = ray.direction.y,\n          m = ray.position.z, n = ray.direction.z,\n          a = l*l + n*n,\n          b = 2. * (k*l + m*n),\n          c = k*k + m*m - 1.;\n    \n    /* Solve a*t^2 + b*t + c = 0 */\n    float discriminant = b * b - 4.0 * a * c,\n          sqrt_D = sqrt(discriminant),\n          sign_b = b >= 0.? 1. : -1.,\n          root = min(\n            -(b + sign_b*sqrt_D) / (2.*a),\n            -(2.*c) / (b+sign_b*sqrt_D));\n    /**/\n        \n    HIT hit;\n    \n    if (discriminant < 0. || // no real roots?\n        root < 0.)           // behind camera?\n    { \n        hit.hit_something = false; \n        return hit; \n    }\n    \n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = -normalize(vec3(hit.hit_point.x,0,0) - hit.hit_point);\n    \n    return hit;\n}","name":"Common","description":"","type":"common"}]}