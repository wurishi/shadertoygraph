{"ver":"0.1","info":{"id":"WssSDs","date":"1552879664","viewed":212,"name":"Music 0.0003","username":"znsoft333","description":"another convert of my old tracker music format to glsl","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);//C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n    int s = getSeqPos(iTime);\n\tint p = getPatPos(iTime);\n    //Instrument ins = createInstrument( 0, s, p);\n    //* sin(float(ins.alldata[1]))\n    //fragColor = sin(vec4(dot(fragCoord-iTime,fragCoord + iTime)* sin(float(ins.alldata[1]))  ));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    \n    \n    \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime*(((p%4)==0)?iTime:0.)),1.0);\n    \n    fragColor += vec4(0.,0.,smoothstep( 0.6 , 0.99,  Sawtooth(uv.x*12.)/(2.5*uv.y-.8) ),1.);\n     fragColor += vec4(0.,smoothstep( 0.6 , 0.99,  sawmsaw(uv.x,12.,.1)/(1.7*uv.y-.8) ),0.,1.);\n    fragColor *= iTime * 0.01;\n    //random generated shaders https://js1k.com/2018-coins/demo/3063\n    fragColor*=sin((vec4((float(iFrame)*((gl_FragCoord.x/iResolution.x)+((iTime*(gl_FragCoord.x/iResolution.x))/(((((gl_FragCoord.y/iResolution.y)-(gl_FragCoord.y/iResolution.y))+(gl_FragCoord.x/iResolution.x))*(((float(iFrame)-(gl_FragCoord.y/iResolution.y))+(abs(2.35)*max(fract((min(6.18,((gl_FragCoord.y/iResolution.y)/((((gl_FragCoord.x/iResolution.x)+4.94)-5.62)-(iTime/iTime))))*sin(((reflect(sin(iTime),(gl_FragCoord.x/iResolution.x))*iTime)+((gl_FragCoord.y/iResolution.y)/atan(iTime)))))),((acos((gl_FragCoord.y/iResolution.y))/float(iFrame))/(((gl_FragCoord.y/iResolution.y)-float(iFrame))-7.57/sin(iTime))))))/iTime))+(gl_FragCoord.x/iResolution.x))))),(gl_FragCoord.y/iResolution.y),1.86,(float(iFrame)+(cos(iTime)+7.78/sin(iTime))))*iTime));\n      fragColor*=log(vec4((gl_FragCoord.x/iResolution.x),((gl_FragCoord.y/iResolution.y)+(((8.87/sin(iTime)*(gl_FragCoord.y/iResolution.y))+max((mod(iTime,(gl_FragCoord.x/iResolution.x))-(tan((iTime-(gl_FragCoord.x/iResolution.x)))+(gl_FragCoord.y/iResolution.y))),((((gl_FragCoord.y/iResolution.y)-7.28)+sin(float(iFrame)))/float(iFrame))))-iTime)),(min(mod((6.72-(gl_FragCoord.y/iResolution.y)),5.82),3.80)-sin(pow(0.19/sin(iTime),mod((gl_FragCoord.x/iResolution.x),(gl_FragCoord.y/iResolution.y))))),(gl_FragCoord.x/iResolution.x)));\n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define char int\n #define ARRAY []=char[](\n #define bpm 90.\n #define tracks 6\n #define trackLen 12\n #define instrNums 4\n// every pattern is only 16 bytes \nconst char patterns ARRAY 60,48,36,48,63,51,39,51,67,55,43,55,63,51,39,51 , 65,53,41,53,1,53,41,53,65,53,41,53,63,51,39,51 , 67,55,43,55,1,55,43,55,63,51,39,51,1,51,39,51 , 60,48,36,1,48,48,1,1,48,1,48,1,1,1,1,1 , 4,8,11,14,19,24,30,38,42,47,52,58,63,69,69,69 , 70,70,70,70,70,70,70,70,70,70,70,70,68,68,68,68 , 68,69,72,77,83,87,91,91,91,91,91,91,91,91,91,88 , 113,113,113,113,113,113,113,113,113,113,112,112,111,110,110,113 , 106,99,85,76,69,61,53,50,49,49,53,56,58,59,60,60 , 0,0,0,0,94,0,0,0,0,0,0,0,94,0,0,0 , 23,0,0,0,23,0,0,0,23,0,0,0,23,0,0,0 , 23,0,0,0,0,0,0,0,23,0,23,0,23,0,23,23 , 60,0,0,0,63,0,0,0,67,0,0,0,0,0,0,0 , 65,0,0,0,65,0,0,0,63,0,0,0,67,0,0,0 , 62,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0 );\n// sequence tab of pattern number is 2d array where x is number of track and y is sequence row value is number of pattern\n//  zero mean no pattern \nconst char seqPat ARRAY 1,5,9,10,11,0 , 2,6,6,10,11,0 , 3,7,7,10,11,0 , 4,8,8,0,0,0 , 1,9,0,0,0,13 , 2,7,9,10,11,14 , 3,9,7,10,12,15 , 4,6,8,0,0,0 , 1,6,8,0,0,0 , 2,6,9,0,0,0 , 3,9,6,0,0,0 , 4,7,6,12,12,0 );\n//instrument synt 2d array x is parameter of instrument, y number of instrument.   when value < 0 than get value byte from track pattern at current sequence row\nconst char instr ARRAY 1,-1,0,63,30,0,-2,1,0,59,2,1,10,90,-3,3, 3,-4,1,126,20,0,0,34,0,31,0,0,0,122,124,0 , 0,-5,45,100,50,0,31,0,0,0,0,0,0,0,0,0,  6,-6,0,63,30,0,-2,1,0,59,2,1,10,90,-3,3 );\n\n\n\n#define resoDeep 10000.0\n#define bps 4. * bpm  / 60.0\n#define PI2 6.2831 \n// if value of field < 0 that mean get value for this field from track number abs()\nstruct Instrument{\n/*\t0  int osc; //0 - sin; 1 - fract ; sqr ; noice ; saw ; saw * saw ;  FM\n    1  int note;\n    2  int toNote;//note decay\n    3  int offset;//offset frequency\n    4  int volume;\n    5  int len;/// not use \n    6  int attack; ///  \n    7  int decay; /// \n    8  int sustain; /// not use \n    9  int phase;\n    10 int delay; /// \n    11 int echos;/// not use if 0\n    12 int fade;\n    13 int reso;\n    14 int resoLevel;/// not use if 0\n    15 int filter;///  balance between hi pass and lo pass reso filter  (0 = lo pass, 128 = hi pass)\n*/\n    char[16] alldata;\n    bool isPrev;\n};\n    \n\n//get position in sequence of patterns\nint getSeqPos(float t){\n   // return int(floor(bps * t/16.0)); \nreturn (int(floor(bps * t ))/16)% trackLen;\n}    \n//get position of note in pattern\nint getPatPos(float t){\n    return int(floor(bps * t))%16;\n\n}  \n//get position in note\nfloat getNotePos(float t){\n    return fract(bps * t);\n}    \n//get value from channel/track\nchar getCurValue(int seqPos, int patPos, int track){\n\tchar patN = seqPat[(track-1)+seqPos*tracks];\n    if(patN==0) return 0;\n\treturn patterns[(patN-1)*16+patPos];\n}\n  \n\n//calc note\nfloat ntof(float n)\n{\n    \t//return 440.0 * pow(2.0, (n-128. ) / 12.0) ;\n\treturn 440.0 * pow(2.0, (n-128. ) / 12.0) * bps ;\n    \t//return 23.0 * pow(2.0, (n ) / 12.0) * bps ;\n}\n   \n\nfloat FM(float t,float f,float p){\n\n    return sin(f*PI2*t+  // base freq\n                    (3.124+7.14*sin(t/PI2))\n                    *sin(p*f*PI2*t)// FM Modulation\n                   );\n\n}\n\nfloat tri(float t,float f, float p)\n{\n    return abs(fract(t * f - p) )*2.0-1.0;\n}\n\nfloat Sawtooth(float x)\n{\n    \n\treturn (0.5 - (x - floor(x / PI2) * PI2) / PI2);\n}\n\nfloat saw(float t,float f, float p)\n{\n    //return Sawtooth(t * f + p);\n\treturn fract(t * f + p) * 2.0 - 1.0;\n}\n\nfloat sqr(float t,float f, float p)\n{\n    return step(fract(t * f), p+.5)*2.0-1.0;\n}\n\n\n\nfloat sawmsaw(float t,float f, float p){\n\t//return saw(t, f,p ) * saw(t , (f+p*128.) , p);\n    \treturn saw(t, f-p,p ) * saw(t , (f+p*128.) , p);\n}\n\nfloat sinw(float t,float f, float p){\n\treturn sin( t*f*PI2+p*PI2);\n}\n\n\n\nfloat noise(float t,float f, float p){\n    return fract(sin(fract(floor(f * t* 4.)/f)*PI2)*3110.)* 2.0 - 1.0;//managed noice quantization\n}\n\nfloat decay2(float time,float len,float param){\n    return exp(param * time*4.0);\n\n}\n\n//https://www.shadertoy.com/view/ldfSW2\n// quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s / c) * c;\n}\n\n//https://www.shadertoy.com/view/ldfSW2\n//resonant lowpass filter's frequency response\nfloat _filter(float h, float cut, float res)\n{\n\tcut -= 20.0;\n\tfloat df = max(h - cut, 0.0), df2 = abs(h - cut);\n\treturn exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\nvec2 zfilter(vec2 h, float cut, float res,float time)\n{\n    h += fract(time * res);\n\treturn h * cut+h;\n}\n\n/*\nvec2 hfilter(vec2 h, float cut, float r,float time)\n{\n\nfloat c = tan(pi * cut / iSampleRate);\n\nc = ( c + r ) * c;\nfloat a1 = 1.0 / ( 1.0 + c );\nfloat b1 = ( 1.0 - c );\n\nout(n) = ( a1 * out(n-1) + in - in(n-1) ) * b1;\n    \n    \n    \n    \n}*/\n\n/*float sawmsaw(float t,float f, float p){\n\treturn (fract(t*(f-p))*fract(t*(f+p)))* 2.0 - 1.0;\n}\n\n\n */\n\nfloat osc(int type,float time,float freq,float phase){\n    //0 - sin; 1 - fract ; 2sqr ; 3noice ; 4saw ; 5saw * saw ;  FM\n\tif(type == 0)return sinw(time, freq, phase);\n    if(type == 1)return tri(time, freq, phase);\n\tif(type == 2)return sqr(time, freq, phase);\n\tif(type == 3)return noise(time, freq, phase);\n    if(type == 4)return saw(time, freq, phase);\n\tif(type == 5)return sawmsaw(time, freq, phase);\n\tif(type == 6)return FM(time, freq, phase);\n\t\n    return 0.0;\n}\n\nfloat osc303(int type,float basefreq, float tnote, float t, float q, float f, float phase,float hpf)\n{\n\tfloat buf0,buf1,y;\n    f = f/128.;\n    q = q/128.;\n    //set feedback amount given f and q between 0 and 1\n\tfloat fb = q + q/(1.0 - f);\n\n    \n    // for(float h = bps; h >= 0.; h-= bps/128.)   \n    \n    for(float h = tnote; h >= 0.; h-= bps/resoDeep)\n\t{\n       \n        y = osc(type,tnote-h,basefreq,phase);\n\n\t\tbuf0 += f * (y - buf0 + fb * (buf0 - buf1));\n\t\tbuf1 += f * (buf0 - buf1);\n\n\t}\n    \n    \n\treturn mix(buf1,y-buf0,hpf);//303 <|> hpf\n} \n\nvec2 finstrument(float time,float t,int type,float note,float offset,float phase,float attack,float decay,float notedecay,float cut,float res ,float hpf, bool isPrev){\n    float freq = ntof(note);\n    freq+=offset;\n    float freqTo = ntof(notedecay);\n    float deltaFreq = freqTo - freq;\n    if(notedecay>0.)\n    freq += (deltaFreq * time);\n    float y;\n\tif(cut!=.0&&res!=.0) y = osc303(type, freq, time,  t, cut, res, phase,hpf); else y = osc(type,time,freq,phase);\n        vec2 v = vec2(y*sin(phase+hpf),y*cos(phase));\n        v = clamp(v,vec2(-1.),vec2(1.));\n    if(attack>0.)v *=  decay2(1.- time,0.,1. - attack);\n    if(decay>0.)v *= decay2(time,0.,decay);\n    if(hpf>0.)v = zfilter(v, hpf, freq+hpf, time); \n    //v *= decay2(time,0.,smoothstep(0.99,0.999,time));\n    v = clamp(v,vec2(-1.),vec2(1.));\n\treturn v;\n}\n\n\nvec2 instrument(float time,float t,int type,int note,int offset, int vol, int phase,int attack,int decay,int notedecay,int cut,int res, int hpf, bool isPrev){\n\tif(note ==0) return vec2(.0);\n    \n    float n = float(note);\n    float p = float(phase)/128.0;\n    float d = float(decay)/128.0;\n    float n2 = float(notedecay);\n    float c = float(cut);\n    float r = float(res);\n    float o = float(offset-63);\n    float a = float(attack)/128.;\n    float z = float(hpf)/128.;\n    \n    return finstrument(time, t, type,n,o,p,a,d ,n2,c,r,z,isPrev);\n}\n\n\nvec2 getSample(Instrument i, float t){\nfloat n = getNotePos(t);\nvec2 y = instrument(n,t,i.alldata[0], i.alldata[1], i.alldata[3], i.alldata[4],i.alldata[9],i.alldata[6],i.alldata[7],i.alldata[2],i.alldata[13],i.alldata[14], i.alldata[15],  i.isPrev);\nreturn y;\n}\n\n\nInstrument createInstrument(int i, int s, int p){\n    Instrument ins;\n        for(int j=0;j<16;j++){\n        char value = instr[i*16+j];\n        if(value<0) value = getCurValue(s, p, -value);\n \t\t\tins.alldata[j]=value;\n        }\n    ins.isPrev = false;\n    return ins;\n}    \n\n\n\n\nvec2 getSampleAll(float t)\n{\n    \n    vec2 smp = vec2(0.);\n    for(int i=0;i<instrNums;i++){\n\n    int s = getSeqPos(t);\n\tint p = getPatPos(t);\n\n        \n    Instrument ins = createInstrument( i, s, p);\n        if(ins.alldata[1]<0){\n            if(p>0)p--;else if(s>0) s--; else continue; \n            ins = createInstrument( i, s, p);\n        ins.isPrev = true;\n        }\n        float d = 0.;\n        float amp =  float(ins.alldata[4])/128.;;//vol\n        float da = float(ins.alldata[12])*bps/128.;//fade\n        float dd = float(ins.alldata[10])*bps/31.;//delay\n            for(int e=0;e<=ins.alldata[11]%3;e++){// echos limit of 3 \n    \t\t\tsmp += getSample(ins,t-d) * amp;// ,0.5);\n                 s = getSeqPos(t-d);\n\t \t\t\tp = getPatPos(t-d);\n                ins = createInstrument( i, s, p);\n                amp *=da; \n                d+=dd;\n            }\n    \n    \n    }   \n    return smp;\n}  \n\nvec2 mainSound( in int samp,float time)\n{\n\n    return getSampleAll( time) ;\n}","name":"Common","description":"","type":"common"}]}