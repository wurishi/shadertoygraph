{"ver":"0.1","info":{"id":"Nt23DK","date":"1624747211","viewed":81,"name":"Tim Apple's Tunnel","username":"visy","description":"tunnel","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.001\n#define FAR_CLIPPING_PLANE 1000.0\n#define NUMBER_OF_MARCH_STEPS 600\n#define EPSILON 0.15\n#define DISTANCE_BIAS 0.2\n\nfloat time = 0.0;\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nconst float kHashScale1 = 443.8975;\n\nfloat hash11(float p) {\n  vec3 p3 = fract(vec3(p) * kHashScale1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nvec2 scene1(vec3 pos)\n{\n    vec3 translate = vec3(-0.1, fract(pos.z), 0.);\n\n    vec3 opos = pos - translate;\n\n    float finalDist = sdSphere(cos(opos*0.2),1.1+sin(pos.z*0.01+cos(pos.x*1.1)*0.1)*0.2)*3.91;\n    \t\n    return vec2(finalDist, 0.0);\n}\n\n\nvec2 scene(vec3 pos) {\n    float mat = 0.0;\n\tvec2 res1 = scene1(pos);\n    mat = res1.y;\n\treturn vec2(res1.x,mat);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat err(float dist){ return min(EPSILON, pow(dist*0.02, 2.0)); }\n\nvec3 discontinuity_reduction(vec3 origin, vec3 direction, vec3 position){ for(int i = 0; i < 3; i++)position = position + direction * (scene(position).x - err(distance(origin, position))); return position; }\n\n\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.0;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        //pos = discontinuity_reduction(position,direction,pos);\n        vec2 result = scene(pos);\n\n        if(result.x < EPSILON)\n        {\n            return vec3(total_distance, acc,result.y);\n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec3(FAR_CLIPPING_PLANE, acc, 0.0);\n}\n\nvec3 normal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n    time = fmod(iTime,30.0);\n\n    vec3 direction = normalize(vec3(uv, 0.0));\n    float cx = 0.0;\n    float cy = 0.0;\n    float cz = -time*1.9;\n    \n    vec3 camera_origin = vec3(cx, cy, cz);\n\tvec3 lookAt = vec3(cx,cy,cz+0.1);\n    \n    vec3 forward = normalize(lookAt-camera_origin);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    float FOV = 5.;\n\n    vec3 ro = camera_origin;\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec3 result = raymarch(ro, rd);\n            \n    float fog = pow(1.0 / (1.0 + result.x), 0.2);\n    \n    vec3 materialColor = vec3(1.0, 1.0, 1.0);\n\t\t\n\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    float occ = calcAO( intersection, nrml );\n    vec3 light_dir = normalize(vec3(0.5,0.3,-1.0));\n    vec3 ref = reflect( rd, nrml );\n    float dom = smoothstep( -0.1, 0.9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0.0, 0.3 ),32.0);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.4,0.6);\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 ambient_color = vec3(1.0,1.0, 1.0);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*occ*fog+dom*0.2+spe*0.3;\n\tif (result.x >= FAR_CLIPPING_PLANE) outColor = vec3(0.0);\n\tfragColor = vec4(outColor, 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}