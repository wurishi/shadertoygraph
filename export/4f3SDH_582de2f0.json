{"ver":"0.1","info":{"id":"4f3SDH","date":"1713931128","viewed":138,"name":"Supersonic wind tunnel 2","username":"ukeshet","description":"Controls (Mach, angle, timestep) added to tunnel 1 (https://www.shadertoy.com/view/4cdXz7)\nSolver and visualization: de Laval nozzle 2 (https://www.shadertoy.com/view/lcdXRn)\nAggressive control changes after run already started require lowering timestep.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","physics","wing","finitedifferences","idealfluid","windtunnel"],"hasliked":0,"parentid":"4cdXz7","parentname":"Supersonic wind tunnel"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compressible 2D ideal flow simulation of objects in a variable wind.\n// Here: standard bullet (22mm Para) vs. wing (NACA 2315: not supersonic). \n// V2: switched to square grid cells, added controls and adaptive color scales.\n// Demo for ICP + Astrophysics 1 courses, by ukeshet.\n//\n// 2D compressible solver from de Laval nozzle (https://www.shadertoy.com/view/XcyGW3)\n// Blob visualization from de Laval nozzle 2 (https://www.shadertoy.com/view/lcdXRn)\n// V1 (wing vs. sphere): Supersonic wind tunnel (https://www.shadertoy.com/view/4cdXz7)\n// See also V3 (+object selection, colorbar,zoon): https://www.shadertoy.com/view/XfdXDM\n//\n// Buffer A sets up initial and boundary conditions. Revise for different objects.\n// Buffer B is a simple 2D ideal fluid solver.\n// Buffer C traces T-blobs (moving at 3*velocity) and monitors controls.\n//\n// Controls: M=Mach number, theta=wind angle (above horizon, deg), delta=time step (cell units).\n// Moving controls aggressively after run already started could crash the solver.\n// Lowering the time step (delta control) slows the evolution but stabilizes the solver. \n// Visualization cycles through field views unless you click on a field name or elsewhere.\n\n#define y0 .71\n#define y1 .64\n#define y2 .57\n#define y3 .50\n#define y4 .43\n#define y5 .36\n#define ysh -.36\n#define Btxt .0 \n\nvec2 uv, k;\n\nvec4 K(int c) { // Type a character\n    vec2 p=(uv-k)*22.; k.x+=.02;\n    if (p.x<.0||p.x>1.||p.y<0.||p.y>1.) return vec4(0.);\n    return textureGrad(iChannel1,p/16.+fract(vec2(c+64,15-(c+64)/16)/16.),dFdx(p/16.),dFdy(p/16.));\n}\n\nvec3 CP(float x) { // Heat color palette\n    x=smoothstep(0.,1.,x);\n    float x2=x*x, x4=x2*x2, x8=x4*x4;\n    return vec3(x,x2,x8*x8);\n}\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n    uv = Coo.xy/iResolution.y;\n    float T, dx, dy, Lx=iResolution.x/iResolution.y, AspR, t=mod(iTime,27.);\n    dx=dy=1./iResolution.y; AspR=dy/dx;\n    vec2 Rn[4], str=vec2(1./Lx,1.);\n    Dx=round(iResolution.y/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    vec4 A=texture(iChannel0, uv*str);\n    vec4 Ranges=texture(iChannel2, vec2(0.05,.95));\n    float v0=M0*pow(G*P0/rho0,.5);\n    for (int j=0;j<=3;j++) Rn[j]=Sunpack(Ranges[j]);\n    if (uv.x<Bx) Col=vec4(0.);\n    else Col = vec4(log(A.z/min(.95*rho0,Rn[1].x))/log(max(1.05*rho0,Rn[1].y)/min(.95*rho0,Rn[1].x)),\n                    log(A.w/min(.95*P0,Rn[2].x))/log(max(1.05*P0,Rn[2].y)/min(.95*P0,Rn[2].x)),\n                    (length(A.xy)-max(.05*v0,Rn[0].x))/(max(1.05*v0,Rn[0].y)-max(.05*v0,Rn[0].x)),1.);\n    int V; // visualization status flag\n    if ((uv.x<Bx) && ordQ(y5,uv.y-ysh,y1)) Col*=0.; // Text box and text:\n    k=vec2(Btxt,ysh+.64); Col += vec4((K(6)+K(41)+K(37)+K(44)+K(36)+K(51)+K(250)).x);\n    k=vec2(Btxt,ysh+.57); Col += vec4(0.,(K(16)+K(50)+K(37)+K(51)+K(51)+K(53)+K(50)+K(37)).x,0.,1.);\n    k=vec2(Btxt,ysh+.51); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)).x,1.);\n    k=vec2(Btxt,ysh+.45); Col += vec4((K(4)+K(37)+K(46)+K(51)+K(41)+K(52)+K(57)).x,0.,0.,1.);\n    k=vec2(Btxt,ysh+.39); Col += vec4(vec2((K(20)+K(37)+K(45)+K(48)+K(232)+K(54)+K(234)+K(243)+K(233)).x),0.,1.);\n    vec2 M=iMouse.xy/iResolution.y; \n    if(iMouse.z<=0. || M.y>y0+ysh || M.x>Bx) V=0; \n        else if ordQ(y1,M.y-ysh,y0) V=5;\n        else if ordQ(y2,M.y-ysh,y1) V=1;\n        else if ordQ(y3,M.y-ysh,y2) V=2;\n        else if ordQ(y4,M.y-ysh,y3) V=3;\n        else if ordQ(y5,M.y-ysh,y4) V=4; \n    if (V==5 || ((V==0) && ordQ(7.5,t,15.))) {       // show (rho,P,M)\n        if ((uv.x<Bx) && ordQ(y5,uv.y-ysh,y4)) Col*=0.; }\n    if (V==1 || (V==0 && ordQ(15.,t,19.))) {         // show (0,P,0)\n        Col.xz*=0.; if ((uv.x<Bx) && (ordQ(y5,uv.y-ysh,y2) || ordQ(y1,uv.y-ysh,y0))) Col*=0.; }\n    if (V==2 || (V==0 && ordQ(19.,t,23.))) {         // show (0,0,Mach)\n        Col.xy*=0.; if ((uv.x<Bx) && (ordQ(y5,uv.y-ysh,y3) || ordQ(y2,uv.y-ysh,y0) )) Col*=0.; }\n    if (V==3 || (V==0 && t>23.)) {                   // show (rho,0,0)\n        Col.yz*=0.; if ((uv.x<Bx) && (ordQ(y5,uv.y-ysh,y4) || ordQ(y3,uv.y-ysh,y0))) Col*=0.; }\n    float dyB1=dyBN1(uv-vec2(Lx*Wx0,Wy0)), dyT1=dyTN1(uv-vec2(Lx*Wx0,Wy0));\n    float dyB2=dyBN2(uv-vec2(Lx*Px0,Py0)), dyT2=dyTN2(uv-vec2(Lx*Px0,Py0));\n    if (V==4 || (V==0 && ordQ(0.,t,7.5))) {          // show T blobs\n        if ((uv.x>Bx) || ordQ(y4,uv.y-ysh,y5) ) {\n            Col=vec4(0.,0.,0.,1.);\n            if ( (Separatrix==false || abs(uv.y-.5)>.5*Dy) \n            // && (length(uv-vec2(Lx*Bx0,By0))>Br+.5*Dx) // Ball (not used at present)\n                && ( (uv.x-Lx*Px0<PxL) || (uv.x-Lx*Px0>PxR) || (dyB2<-.5*Dx) || (dyT2>+.5*Dx)) \n                && ( (uv.x-Lx*Wx0<WxL) || (uv.x-Lx*Wx0>WxR) || (dyB1<-.5*Dx) || (dyT1>+.5*Dx)) )  {   // plot blobs\n                for(float ix=-1.; ix<1.5; ix+=1.) for(float iy=-1.; iy<1.5; iy+=1.) {\n                    vec2 uv1=uv+vec2(Dx*ix,Dy*iy);\n                    if (ordQ(0.,uv1.x,Lx) && ordQ(0.,uv1.y,1.)) {\n                        vec4 B=texture(iChannel2,uv1*str);\n                        for (int j=0; j<4; j++) {\n                            vec3 q=unpack(B2i(B[j]));\n                            if (length(uv-vec2(Dx*floor(uv1.x/Dx),Dy*floor(uv1.y/Dy))-vec2(Dx*q.x,Dy*q.y))<.005*(1.-.8*log(1.*A.z/rho0)))\n                                Col.xyz=max(Col.xyz,CP(log(A.w/A.z/min(.9*P0/rho0,Rn[3].x))/log(max(1.1*P0/rho0,Rn[3].y)/min(.9*P0/rho0,Rn[3].x))));\n                        }}}}}\n        if ((uv.x<Bx) && ordQ(y4,uv.y-ysh,y0)) Col*=0.;\n    }\n    if (ordQ(WxL,uv.x-Lx*Wx0,WxR)) {  // mark wing\n        if (ordQ(dyT1,0.,dyB1)) Col=vec4(0.);\n        if ((abs(AspR*dyB1)<dy) || (abs(AspR*dyT1)<dy)) Col=vec4(1.); }\n    if (ordQ(PxL,uv.x-Lx*Px0,PxR)) {  // mark bullet \n        if (ordQ(dyT2,0.,dyB2)) Col=vec4(0.);\n        if ((abs(AspR*dyB2)<dy) || (abs(AspR*dyT2)<dy) \n            || (abs(uv.y-Py0)<PxW*PGd1 && abs(dxLN2(uv-vec2(Lx*Px0,Py0)))<dx) \n            || (abs(uv.y-Py0)<2.*dy && abs(uv.x-Lx*Px0)<dx)) Col=vec4(1.); }\n    // if (abs(length(uv-vec2(Lx*Bx0,By0))-Br)<1.1*dy) Col=vec4(1.);     // mark ball (unused)\n    if (Separatrix && uv.x>Bx && ordQ(.5-dy,uv.y,.5+dy)) Col=vec4(1.);   // mark separatrix\n\n    // The rest displays controls: Mach number, angle theta, time step parameter delta.\n    vec4 Ctrl=texture(iChannel2, vec2(0.,0.)); \n    float hM=hM(Ctrl.x), hT=hT(Ctrl.y), hC=hC(Ctrl.z);\n\n    if (abs(abs(uv.x-.25*Bx)-ClLdW)<dy && abs(uv.y-ClH1)<CldH) Col=vec4(1.);\n    if (abs(abs(uv.y-ClH1)-CldH)<dy && abs(uv.x-.25*Bx)<ClLdW) Col=vec4(1.);\n    if (iMouse.z>0. && max(abs(M.x-.25*Bx),abs(M.y-hM))<ClBdW)\n        {if (max(2.*abs(uv.x-.25*Bx+ClBdW),abs(uv.y-hM))<ClBdH) Col=vec4(1.,0,0,1.);}\n    else \n        if (max(abs(uv.x-.25*Bx+ClBdW),abs(uv.y-hM))<ClBdH) Col=vec4(1.,0,0,1.);\n    if (max(abs(uv.x-.25*Bx),abs(uv.y-hM))<ClBdW && length(uv-vec2(.25*Bx,hM))<.035) Col=vec4(.5,.0,.5,1.);\n    k=vec2(.125*Bx,hM-ClTdH); Col += vec4(K(13).x);\n    k=vec2(.005,.67); Col += vec4((K(240+int(Ctrl.x))+K(238)+K(240+int(mod(10.*Ctrl.x,10.)))).x);\n\n    if (abs(abs(uv.x-.75*Bx)-ClLdW)<dy && abs(uv.y-ClH1)<CldH) Col=vec4(1.);\n    if (abs(abs(uv.y-ClH1)-CldH)<dy && abs(uv.x-.15)<ClLdW) Col=vec4(1.);\n    if (iMouse.z>0. && max(abs(M.x-.75*Bx),abs(M.y-hT))<ClBdW)\n        {if (max(2.*abs(uv.x-.75*Bx+ClBdW),abs(uv.y-hT))<ClBdH) Col=vec4(1.,0,0,1.);}\n    else \n        if (max(abs(uv.x-.75*Bx+ClBdW),abs(uv.y-hT))<ClBdH) Col=vec4(1.,0,0,1.);\n    if (max(abs(uv.x-.75*Bx),abs(uv.y-hT))<ClBdW && length(uv-vec2(.75*Bx,hT))<.035) Col=vec4(.5,.0,.5,1.);\n    k=vec2(.625*Bx,hT-ClTdH); Col += vec4(K(69).x);\n    k=vec2(.115,.67); Col += vec4((K(240+int(abs(Ctrl.y)/10.))+K(240+int(mod(abs(Ctrl.y),10.)))).x);\n\n    if (abs(abs(uv.x-.5*Bx)-ClLdW)<dy && abs(uv.y-ClH2)<CldH) Col=vec4(1.);\n    if (abs(abs(uv.y-ClH2)-CldH)<dy && abs(uv.x-.1)<ClLdW) Col=vec4(1.);\n    if (iMouse.z>0. && max(abs(M.x-.5*Bx),abs(M.y-hC))<ClBdW)\n        {if (max(2.*abs(uv.x-.5*Bx+ClBdW),abs(uv.y-hC))<ClBdH) Col=vec4(1.,0,0,1.);}\n    else \n        if (max(abs(uv.x-.5*Bx+ClBdW),abs(uv.y-hC))<ClBdH) Col=vec4(1.,0,0,1.);\n    if (max(abs(uv.x-.5*Bx),abs(uv.y-hC))<ClBdW && length(uv-vec2(.5*Bx,hC))<.035) Col=vec4(.5,.0,.5,1.);\n    k=vec2(.375*Bx,hC-ClTdH); Col += vec4(K(67).x);\n    k=vec2(.035,.35); Col += vec4((K(238)+K(240+int(mod(10.*Ctrl.z,10.)))+K(240+int(mod(100.*Ctrl.z,10.)))+K(240+int(mod(1000.*Ctrl.z,10.)))).x);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common: Geometry and parameter setup.\n// ______________________________________\n\n#define pi  3.14159265358979\n#define Deg 0.01745329251994\n#define ordQ(i,j,k) (i<=j? (j<=k? true:false) : false)\n\n// Time stepping (CFL) parameter:\n#define CFL0 .07 // lower value if code crashes on your setup.\n\n// Hydro params:\n#define rho0 1.\n#define P0 1.\n#define M0 2.\n#define T0 0.\n#define G 1.4 // adiabatic index\n\n// Separate objects?\n#define Separatrix true\n\n// T-blob visualization\n#define SU 3.\n#define DT .05\n#define Nx 40.\n#define Ny 40.\nfloat Dx,Dy;\n\n// Controls\n#define Bx .20 \n#define Mmax 10.\n#define Tmax 20.\n#define Cmax .3\n#define ClH1 .85\n#define ClH2 .53\n#define CldH .12\n#define CldW .03\n#define ClLdW .005\n#define ClBdW .03\n#define ClBdH .01\n#define ClTdH .02\nfloat hM(float M) { return ClH1+CldH*log(M*10./Mmax)/log(10.); }\nfloat hT(float T) { return ClH1+CldH*T/Tmax; }\nfloat hC(float C) { return ClH2+CldH*log(C*10./Cmax)/log(10.); }\n\n\n\n// Wing 1 (NACA 2315) geometry:\n#define Wdx .22\n#define Wx0 (.75-.28*Wdx)\n#define Wy0 .25\n#define WxL (-.5*Wdx)\n#define WxR (+.5*Wdx)\n#define Wm .02\n#define Wp .3\n#define Wt .15\n\nfloat dyTN1(vec2 xy) { // Oriented distance from top edge of object 1\n    float Wc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) Wc=(Wm/Wp/Wp)*(2.*Wp*x1-x2);\n    else Wc=(Wm/(1.-Wp)/(1.-Wp))*(1.-2.*Wp+2.*Wp*x1-x2);\n    return xy.y-((+5.*Wt*(.2969*pow(x1,.5)-.126*x1-.3516*x2+.2843*x2*x1-.1015*x2*x2)+Wc)*Wdx); \n}\n\nfloat dyBN1(vec2 xy) { // Oriented distance from bottom edge of object 1\n    float Wc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) Wc=(Wm/Wp/Wp)*(2.*Wp*x1-x2);\n    else Wc=(Wm/(1.-Wp)/(1.-Wp))*(1.-2.*Wp+2.*Wp*x1-x2);\n    return xy.y-((-5.*Wt*(.2969*pow(x1,.5)-.126*x1-.3516*x2+.2843*x2*x1-.1015*x2*x2)+Wc)*Wdx); \n}\n\nvec2 NormT1(vec2 xy) { // Normal to top edge of object 1\n    float dWc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*Wp*Wp);\n    else dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*(-1.+Wp)*(-1.+Wp));\n    float a=atan(dWc + Wt*(.63+(3.516*x1)/Wdx-(4.2645*x2)/Wdx/Wdx+(2.03*x1*x2)/(Wdx*Wdx*Wdx)-.74225/pow(x1/Wdx,.5)));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB1(vec2 xy) { // Normal to bottom edge of object 1\n    float dWc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*Wp*Wp);\n    else dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*(-1.+Wp)*(-1.+Wp));\n    float a=atan(dWc - Wt*(.63+(3.516*x1)/Wdx-(4.2645*x2)/Wdx/Wdx+(2.03*x1*x2)/(Wdx*Wdx*Wdx)-.74225/pow(x1/Wdx,.5)));\n    return vec2(-sin(a),cos(a));\n}\n\n\n// Bullet (9mm para) geometry:\n\n#define Px0 .75\n#define Py0 .7505\n#define PxW .06\n#define PxL -PxW\n#define PxR 0.\n#define PGa0 -0.9593547317\n#define PGa1 0.3796971491\n#define PGa2 1.00765454176\n#define PGa3 0.1\n#define PGb0 -0.6499357907\n#define PGb1 0.2804347826\n#define PGc1 0.5125832490\n#define PGc2 -0.0018639770\n#define PGc3 0.7279912002\n#define PGc4 1.2399299790\n#define PGc5 0.4\n#define PGd1 0.25358466168\n\n\nfloat dyTN2(vec2 xy) { // Oriented distance from top edge of bullet\n    float x=xy.x/PxW;\n    if (x<PGa0)\n        return xy.y-PxW*(PGa1*pow(PGa2+x,PGa3));\n    if (x<PGb0)\n        return xy.y-PxW*PGb1;\n    return xy.y-PxW*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5);\n}\n\nfloat dyBN2(vec2 xy) { // Oriented distance from bottom edge of bullet\n    float x=xy.x/PxW;\n    if (x<PGa0)\n        return xy.y+PxW*(PGa1*pow(PGa2+x,PGa3));\n    if (x<PGb0)\n        return xy.y+PxW*PGb1;\n    return xy.y+PxW*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5);\n}\n\nfloat dxLN2(vec2 xy) { // Oriented distance from left edge of bullet\n    return -PxW-xy.x;\n}\n\nvec2 NormT2(vec2 xy) { // Normal to top edge of bullet\n    float a, x=xy.x/PxW;\n    if (x<PGa0)\n        a=(PGa3*PGa1*pow(PGa2+x,PGa3-1.));\n    else if (x<PGb0)\n        a=.5*pi;\n    else a=PGc5*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5-1.)*(-1.+PGc3*PGc4*pow(-x,PGc4-1.));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB2(vec2 xy) { // Normal to bottom edge of bullet\n    float a, x=xy.x/PxW;\n    if (x<PGa0)\n        a=-(PGa3*PGa1*pow(PGa2+x,PGa3-1.));\n    else if (x<PGb0)\n        a=-.5*pi;\n    else a=-PGc5*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5-1.)*(-1.+PGc3*PGc4*pow(-x,PGc4-1.));\n    return vec2(-sin(a),cos(a));\n}\n\n\n// Ball geometry (not presently used):\n\n#define Bx0 .75\n#define By0 .7505\n#define Br .02\n#define BxL -Br\n#define BxR +Br\n\nfloat dyTN3(vec2 xy) { // Oriented distance from top edge of object 2\n    if (xy.y<0.) return -777.;\n    return length(xy)-Br;\n}\n\nfloat dyBN3(vec2 xy) { // Oriented distance from bottom edge of object 2\n    if (xy.y>0.) return +777.;\n    return Br-length(xy);\n}\n\nvec2 NormT3(vec2 xy) { // Normal to top edge of object 2\n    float a=atan(xy.y/xy.x);\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB3(vec2 xy) { // Normal to bottom edge of object 2\n    float a=atan(xy.y/xy.x);\n    return vec2(-sin(a),cos(a));\n}\n\n\n// Sample packing/unpacking:\n#define B2f(i) intBitsToFloat(i)\n#define B2i(f) floatBitsToInt(f)\n#define Spack(qx, qy) intBitsToFloat((B2i(qx)&0xFFFF0000)|((B2i(qy)>>16)&0xFFFF))\n#define Spack2(q) intBitsToFloat((B2i(q.x)&0xFFFF0000)|((B2i(q.y)>>16)&0xFFFF))\n#define Sunpack(Q) vec2(B2f(B2i(Q)&0xFFFF0000), B2f((B2i(Q)&0xFFFF)<<16))\n\n// T-blob packing/unpacking:\n#define B1 14\n#define B2 14\n#define B3 4\nfloat b1=float((1<<B1)), b2=float((1<<B2)), b3=float((1<<B3));\n#define pack(qx,qy,qT) intBitsToFloat( (int(b1*qx)<<(B2+B3)) | (int(b2*qy)<<B3) | int(b3*qT) )\n#define unpack(Q) vec3(float(((Q>>(B2+B3))&((1<<B1)-1)))/b1,float(((Q>>B3)&((1<<B2)-1)))/b2,float(Q&((1<<B3)-1))/b3)\n\n// Hash\nfloat h(float I, float F) {\n    float combined = log(abs(I))/53.432 - log(abs(F))/23.364;\n    combined = fract(sin(combined*8264.2352)*4758.5453);\n    return fract(combined);\n}\n#define pack01 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N11*Dx,(1.+floor(uv.y/Dy))*n11*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N12*Dx,(1.+floor(uv.y/Dy))*n12*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N13*Dx,(1.+floor(uv.y/Dy))*n13*Dy)) )\n#define pack02 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N21*Dx,(1.+floor(uv.y/Dy))*n21*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N22*Dx,(1.+floor(uv.y/Dy))*n22*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N23*Dx,(1.+floor(uv.y/Dy))*n23*Dy)) )\n#define pack03 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N31*Dx,(1.+floor(uv.y/Dy))*n31*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N32*Dx,(1.+floor(uv.y/Dy))*n32*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N33*Dx,(1.+floor(uv.y/Dy))*n33*Dy)) )\n#define pack04 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N41*Dx,(1.+floor(uv.y/Dy))*n41*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N42*Dx,(1.+floor(uv.y/Dy))*n42*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N43*Dx,(1.+floor(uv.y/Dy))*n43*Dy)) )\n\n// Hash parameters (meaningless):\n#define n11 25236.264\n#define n12 46247.964\n#define n13 85446.343\n#define n21 74447.543\n#define n22 89345.434\n#define n23 78446.211\n#define n31 27242.754\n#define n32 93546.123\n#define n33 62147.141\n#define n41 57342.548\n#define n42 17445.547\n#define n43 56781.135\n#define N11 12411.346\n#define N12 76235.373\n#define N13 33743.748\n#define N21 72361.843\n#define N22 26898.834\n#define N23 58133.782\n#define N31 81345.853\n#define N32 82788.286\n#define N33 17457.842\n#define N41 14825.174\n#define N42 45856.723\n#define N43 56823.432\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Initial and boundary conditions.\n// Presently sets up the double-nozzle problem.\n// ____________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float dx, dy, Lx=iResolution.x/iResolution.y, AspR;\n    vec2 uv = Coo.xy/iResolution.y, str=vec2(1./Lx,1.);\n    dx=dy=1./iResolution.y; AspR=dy/dx;\n    vec2 Asp=vec2(1.,AspR);\n\n    vec4 Ctrl=texture(iChannel1, vec2(0.,0.));\n    vec2 vIn=Ctrl.x*sqrt(G)*vec2(-cos(Ctrl.y*Deg),sin(Ctrl.y*Deg));\n\n    Col = texture(iChannel0, uv*str); // Fetch pixel and neighbors\n    vec4 AR=texture(iChannel0, (uv+vec2(dx,.0))*str);\n    vec4 AL=texture(iChannel0, (uv-vec2(dx,.0))*str);\n    vec4 AU=texture(iChannel0, (uv+vec2(.0,dy))*str);\n    vec4 AD=texture(iChannel0, (uv-vec2(.0,dy))*str);\n\n    float dyB=AspR*dyBN1(uv-vec2(Lx*Wx0,Wy0)),  dyT=AspR*dyTN1(uv-vec2(Lx*Wx0,Wy0));\n    float dyB2=AspR*dyBN2(uv-vec2(Lx*Px0,Py0)), dyT2=AspR*dyTN2(uv-vec2(Lx*Px0,Py0));\n    //float dyB2=AspR*dyBN2(uv-vec2(Lx*Bx0,By0)), dyT2=AspR*dyTN2(uv-vec2(Lx*Bx0,By0));\n\n    // Boundary conditions\n    if (uv.x<1.1*dx)                           // Left boundary\n        Col = vec4(-abs(AR.x),AR.yzw);                     // outflow\n    if (uv.x>Lx-1.1*dx)                        // Right boundary\n        Col = vec4(vIn,rho0,P0);                           // ambient inflow\n    if (Separatrix && ordQ(-dy,uv.y-.5,dy))    // Separatrix\n            Col = vec4(0.,0.,rho0,P0);                     // ambient stationary\n    if (uv.y<1.1*dy || (Separatrix && ordQ(dy,uv.y-.5,2.1*dy)) ) {     // Bottom boundary\n        if (Ctrl.y<=0.) Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow\n        else Col = vec4(vIn,rho0,P0); }                    // ambient inflow\n    if (uv.y>1.-1.1*dy || (Separatrix && ordQ(-2.1*dy,uv.y-.5,-dy))) { // top boundary                        // Top boundary\n        if (Ctrl.y>=0.) Col = vec4(AD.x,+abs(AD.y),AD.zw); // outflow\n        else Col = vec4(vIn,rho0,P0); }                    // ambient inflow\n\n    // Wing:\n    vec2 uvW=uv-vec2(Lx*Wx0,Wy0);\n    if ordQ(WxL,uvW.x,WxR+1.1*dx) {            // Wing region\n        if ordQ(dyT,0.,dyB)                    // inside wing \n            Col = vec4(0.,0.,rho0,P0);         // steady ambient\n        else {                                 // outside wing \n            if ordQ(dyT-1.1*dy,0.,dyB) Col = vec4(AU.xy-NormT1(uvW)*Asp*dot(AU.xy,NormT1(uvW)*Asp),AU.zw); // slip\n            if ordQ(dyT,0.,dyB+1.1*dy) Col = vec4(AD.xy-NormB1(uvW)*Asp*dot(AD.xy,NormB1(uvW)*Asp),AD.zw); // slip\n            if (ordQ(WxR,uvW.x,WxR+1.1*dx) && (abs(uvW.y)<2.1*dy)) Col = vec4(0.,AR.yzw);                  // nose slip\n        }\n    }\n\n    // Bullet:\n    vec2 uvP=uv-vec2(Lx*Px0,Py0);\n    if ordQ(PxL,uvP.x,PxR+1.1*dx) {            // Wing region\n        if ordQ(dyT2,0.,dyB2)                  // inside wing \n            Col = vec4(0.,0.,rho0,P0);         // steady ambient\n        else {                                 // outside wing \n            if ordQ(dyT2-1.1*dy,0.,dyB2) Col = vec4(AU.xy-NormT2(uvP)*Asp*dot(AU.xy,NormT2(uvP)*Asp),AU.zw); // slip\n            if ordQ(dyT2,0.,dyB2+1.1*dy) Col = vec4(AD.xy-NormB2(uvP)*Asp*dot(AD.xy,NormB2(uvP)*Asp),AD.zw); // slip\n            if (ordQ(PxR,uvP.x,PxR+1.1*dx) && (abs(uvP.y)<2.1*dy)) Col = vec4(0.,AR.yzw);                    // nose slip\n            if (ordQ(PxL-1.1*dx,uvP.x,PxL) && (abs(uvP.y)<PxW*PGd1)) Col = vec4(0.,AL.yzw);                  // tail slip\n        }\n    }\n\n    // Ball (not used at present):\n    //vec2 uvB=uv-vec2(Lx*Bx0,By0);\n    //if ordQ(BxL,uvB.x,BxR+1.1*dx) {            // ball region\n    //    if ordQ(dyT2,0.,dyB2)                  // inside ball\n    //        Col = vec4(0.,0.,rho0,P0);         // steady ambient\n    //    else {                                 // outside ball\n    //        if ordQ(dyT2-1.1*dy,0.,dyB2) Col = vec4(AU.xy-NormT2(uvB)*Asp*dot(AU.xy,NormT2(uvB)*Asp),AU.zw); // slip\n    //        if ordQ(dyT2,0.,dyB2+1.1*dy) Col = vec4(AD.xy-NormB2(uvB)*Asp*dot(AD.xy,NormB2(uvB)*Asp),AD.zw); // slip\n    //        if (ordQ(BxR,uvB.x,BxR+1.1*dx) && (abs(uvB.y)<2.1*dy))\n    //           Col = vec4(0.,AR.yzw);     // nose slip\n    //   }\n    //}\n\n    if (iTime<.1) {  // Initial conditions\n        float rho=rho0, P=P0;\n        vec2 vi=vIn; //=M0*sqrt(G)*vec2(-cos(T0*Deg),sin(T0*Deg));\n        if (ordQ(WxL,uvW.x,WxR) && ordQ(dyT,0.,dyB)) { // inside wing \n            vi = vec2(0.);\n        }\n        if (ordQ(PxL,uvP.x,PxR) && ordQ(dyT,0.,dyB)) { // inside bullet\n            vi = vec2(0.);\n        }\n        //if (length(uvB)<=Br) { // inside ball (not used at present)\n        //    vi = vec2(0.);}\n        Col = vec4(vi,rho,P);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: 2D ideal fluid solver, by ukeshet.\n// Simplest version: nearest neighbors only, operator splitting, donor-cell advection.\n// ____________________________________________________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float CV = 1./(G-1.);\n    float minV = .01;\n\n    vec4 Ctrl=texture(iChannel1, vec2(0.,0.));\n    float CFL=Ctrl.z;\n\n    // Grid\n    float dx, dy, dt; // lower CFL (defined in Common line 6) if crash.\n    vec2 uv = Coo.xy/iResolution.y, str=vec2(iResolution.y/iResolution.x,1.);\n    dx = dy = 1./iResolution.y; dt = CFL*min(dx,dy);\n\n    // Fetch pixel and neighbours\n    vec4 A = texture(iChannel0, uv*str);\n    vec4 AR = texture(iChannel0, (uv+vec2(dx,.0))*str);\n    vec4 AL = texture(iChannel0, (uv-vec2(dx,.0))*str);\n    vec4 AU = texture(iChannel0, (uv+vec2(.0,dy))*str);\n    vec4 AD = texture(iChannel0, (uv-vec2(.0,dy))*str);\n\n    // Edge veclocities\n    float uR = .5*(AR.x+A.x), uL = .5*(AL.x+A.x);\n    float vU = .5*(AU.y+A.y), vD = .5*(AD.y+A.y);\n\n    // Mass flux\n    float frhoR = uR*(step(0.,uR)*A.z + step(uR,0.)*AR.z);\n    float frhoL = uL*(step(0.,uL)*AL.z + step(uL,0.)*A.z);\n    float frhoU = vU*(step(0.,vU)*A.z + step(vU,0.)*AU.z);\n    float frhoD = vD*(step(0.,vD)*AD.z + step(vD,0.)*A.z);\n    float rho2 = A.z - dt*( (frhoR-frhoL)/dx + (frhoU-frhoD)/dy );\n    rho2 = max(minV,rho2);\n\n    // x-momentum flux\n    float fpxR = uR*(step(0.,uR)*A.z*A.x + step(uR,0.)*AR.z*AR.x);\n    float fpxL = uL*(step(0.,uL)*AL.z*AL.x + step(uL,0.)*A.z*A.x);\n    float fpxU = vU*(step(0.,vU)*A.z*A.x + step(vU,0.)*AU.z*AU.x);\n    float fpxD = vD*(step(0.,vD)*AD.z*AD.x + step(vD,0.)*A.z*A.x);\n    float vx2 = ( A.z*A.x - dt*( (fpxR-fpxL)/dx + (fpxU-fpxD)/dy + (AR.w-AL.w)/dx/2. ) )/rho2;\n\n    // y-momentum flux\n    float fpyR = uR*(step(0.,uR)*A.z*A.y + step(uR,0.)*AR.z*AR.y);\n    float fpyL = uL*(step(0.,uL)*AL.z*AL.y + step(uL,0.)*A.z*A.y);\n    float fpyU = vU*(step(0.,vU)*A.z*A.y + step(vU,0.)*AU.z*AU.y);\n    float fpyD = vD*(step(0.,vD)*AD.z*AD.y + step(vD,0.)*A.z*A.y);\n    float vy2 = ( A.z*A.y - dt*( (fpyR-fpyL)/dx + (fpyU-fpyD)/dy + (AU.w-AD.w)/dy/2. ) )/rho2;\n\n    // Total energy*density\n    float erho = CV*A.w+.5*A.z*(A.x*A.x+A.y*A.y);\n    float erhoR = CV*AR.w+.5*AR.z*(AR.x*AR.x+AR.y*AR.y);\n    float erhoL = CV*AL.w+.5*AL.z*(AL.x*AL.x+AL.y*AL.y);\n    float erhoU = CV*AU.w+.5*AU.z*(AU.x*AU.x+AU.y*AU.y);\n    float erhoD = CV*AD.w+.5*AD.z*(AD.x*AD.x+AD.y*AD.y);\n\n    // Energy flux\n    float feR = uR*(step(0.,uR)*erho + step(uR,0.)*erhoR);\n    float feL = uL*(step(0.,uL)*erhoL + step(uL,0.)*erho);\n    float feU = vU*(step(0.,vU)*erho + step(vU,0.)*erhoU);\n    float feD = vD*(step(0.,vD)*erhoD + step(vD,0.)*erho);\n    float erho2 = erho - dt*( (feR-feL)/dx + (feU-feD)/dy +\n                              (AR.w*AR.x-AL.w*AL.x)/dx/2. + (AU.w*AU.y-AD.w*AD.y)/dy/2. );\n\n    // Reconstruct pressure\n    float P2 = (erho2 - .5*rho2*(vx2*vx2+vy2*vy2))/CV;\n    P2 = max(minV,P2);\n\n    Col = vec4(vx2,vy2,rho2,P2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: controls + temperature blob evolution.\n// ________________________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo)\n{\n    float dx, dy, dt, Lx=iResolution.x/iResolution.y;\n    vec2 uv=Coo.xy/iResolution.y, str=vec2(iResolution.y/iResolution.x,1.);\n    dx=dy=1./iResolution.y; \n    vec4 Ctrl=texture(iChannel1, vec2(0.,0.));\n    dt=Ctrl.z*min(dx,dy);\n    \n    Dx=round(iResolution.y/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    if (iFrame<1) {\n        if (uv.x<Bx) {   // Left of box\n            if (uv.y<.1) // controls here\n                Col=vec4(M0,T0,CFL0,0.);\n            if (uv.y>.9) // colormap sampling here\n                Col=vec4(Spack2(M0*pow(G*P0/rho0,.5)*vec2(.5,2.)),Spack2(rho0*vec2(.5,2.)),\n                         Spack2(P0*vec2(.5,2.)),Spack2(P0/rho0*vec2(.5,2.)));\n        } \n        else  Col=vec4(pack01,pack02,pack03,pack04);\n    } else {\n        vec4 B=texture(iChannel1, uv*str);\n        for (int j=0; j<4; j++) {\n            vec2 cell=vec2(Dx*floor(uv.x/Dx),Dy*floor(uv.y/Dy));\n            vec3 q=unpack(B2i(B[j]));\n            float rx=Dx*q.x, ry=Dy*q.y;\n            vec4 A=texture(iChannel0, (cell+vec2(rx,ry))*str);\n                rx+=A.x*dt*SU;\n                ry+=A.y*dt*SU;\n            float crossed, qT=q[2];\n            if (abs(crossed=floor(rx/Dx))>0.) { // blob crossed to next cell\n                ry=Dy*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                rx=Dx*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            if (abs(crossed=floor(ry/Dy))>0.) { // blob crossed to next cell\n                rx=Dx*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                ry=Dy*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            Col[j]=pack(fract(rx/Dx),fract(ry/Dy),qT);\n\n            if (uv.x<.2 && uv.y<.1) { // controls here\n                Col=B;\n                if (iMouse.z>0.) {\n                    vec2 M=iMouse.xy/iResolution.y;\n                    if (abs(M.x-.25*Bx)<CldW && abs(M.y-ClH1)<CldH)\n                        Col.x=(Mmax/10.)*pow(10.,(M.y-ClH1)/CldH);\n                    if (abs(M.x-.75*Bx)<CldW && abs(M.y-ClH1)<CldH)\n                        Col.y=Tmax*(M.y-ClH1)/CldH;\n                    if (abs(M.x-.5*Bx)<CldW && abs(M.y-ClH2)<CldH)\n                        Col.z=(Cmax/10.)*pow(10.,(M.y-ClH2)/CldH);\n                }\n            }\n        }\n            \n        if (uv.x<.2 && uv.y>.9) { // colormap sampling here\n            vec4 Smin=vec4(7.e17), Smax=vec4(-7.e-17);\n            for (float x=2.*dx; x<Lx; x+=(Lx-4.*dx)/1.)\n                for (float y=2.*dy; y<1.; y+=(1.-4.*dx)/1.) {\n                    vec4 Samp=texture(iChannel0, vec2(x,y));\n                    Smin=min(Smin,vec4(length(Samp.xy),Samp.zw,Samp.w/Samp.z));\n                    Smax=max(Smax,vec4(length(Samp.xy),Samp.zw,Samp.w/Samp.z));\n                }\n            vec4 objXY=vec4(Wx0,Wy0,Bx0,By0);\n            for (int obj=0; obj<=1; obj++)\n                for (float r=.07; r<0.21; r+=.05)\n                    for (float phi=-1.0*pi; phi<=.99*pi; phi+=pi/6.) {\n                        vec4 Samp=texture(iChannel0, vec2(objXY[2*obj]+r*cos(phi),objXY[2*obj+1]+r*sin(phi)));\n                        Smin=min(Smin,vec4(length(Samp.xy),Samp.zw,Samp.w/Samp.z));\n                        Smax=max(Smax,vec4(length(Samp.xy),Samp.zw,Samp.w/Samp.z));\n                }\n            vec4 pSamp=texture(iChannel1, vec2(0.05,.95));\n            for (int j=0;j<=3;j++) {\n                vec2 Sampj=Sunpack(pSamp[j]);\n                Col[j]=Spack(.99*Sampj[0]+.01*Smin[j],.99*Sampj[1]+.01*Smax[j]);\n            }\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}