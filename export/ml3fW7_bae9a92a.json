{"ver":"0.1","info":{"id":"ml3fW7","date":"1701302324","viewed":80,"name":"More Planets","username":"Chroma_Crash","description":"Structs are pretty cool. I'm sampling from the perlin and bubble textures by projecting them from a \"cylinder\" composed of the wrapped texture to the sphere. Bayer dithering is also epic.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","lighting","perlin","pixel","earth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n#define PIXEL_SIZE 4.0\n\n#define YSCALE 0.3\n\n#define TOTAL_PLANETS 3\n\n#define LIGHT_DIRECTION normalize(vec3(1, -0.5, 0.4))\n\nstruct Planet {\n    vec2 position;\n    float size;\n    float rotation;\n    float clouds;\n    float offset;\n    float[3] levels;\n    vec3[4] colors;\n    bool emitting;\n    float bayer;\n};\n\nconst vec3[4]  EARTH_COLORS =  vec3[4] (vec3(72, 74, 119), vec3(77, 101, 180), vec3(35, 144, 99), vec3(30, 188, 115));\nconst float[3] EARTH_LEVELS = float[3] (             0.35,               0.45,             0.53);\n\nconst vec3[4]  MOON_COLORS =  vec3[4] (vec3(69, 41, 63), vec3(107, 62, 117), vec3(127, 112, 128), vec3(155, 171, 178));\nconst float[3] MOON_LEVELS = float[3] (             0.3,                0.5,                0.6);\n\nconst vec3[4]  SUN_COLORS =  vec3[4] (vec3(245, 125, 74), vec3(285, 185, 84),  vec3(255, 231, 134), vec3(155, 171, 178));\nconst float[3] SUN_LEVELS = float[3] (               0.4,                0.5,                 1.0);\n\n#define EARTH Planet(vec2(0.4,  0.5), 0.15, -0.2, 0.60, 0.0, EARTH_LEVELS, EARTH_COLORS, false,  0.0)\n#define MOON  Planet(vec2(0.9,  0.8), 0.06, 0.15,  6.0, 0.5,  MOON_LEVELS,  MOON_COLORS, false,  0.0)\n#define SUN   Planet(vec2(1.8, -0.6), 1.09, 0.10,  6.0, 0.0,   SUN_LEVELS,   SUN_COLORS,  true, 0.07)\n\n\nPlanet[TOTAL_PLANETS] PLANETS = Planet[] (EARTH, MOON, SUN);\n\n\nvec3 spherePosition(vec2 uv, vec2 center, float size, float rotate) {\n    // UV relative to center of planet\n    vec2 zero = uv - center;\n    \n    // Rotate UV for more dynamic planets\n    float angle = atan(zero.y, zero.x);\n    angle += rotate;\n    zero = length(zero) * vec2(cos(angle), sin(angle));\n    \n    // Localize UV to (-1, 1)\n    vec2 local = zero / size;\n    \n    // Find z position on sphere from 1^2 = z^2 + y^2 + x^2\n    float z = sqrt(1.0 - pow(local.x, 2.0) - pow(local.y, 2.0));\n    \n    vec3 position = vec3(local.x, local.y, z);\n    \n    return position;\n}\n\n\nvec2 transform(vec3 position, float offset, float size) {\n    // Find xz distance from center of sphere\n    float xzDist = sqrt(pow(position.x, 2.0) + pow(position.z, 2.0));\n    \n    // Project sphere point onto cylinder\n    vec3 cylinder = position / xzDist;\n    \n    // Use angle of cylinder projection to find X coordinate on texture\n    float x = atan(cylinder.x, cylinder.z) / (2.0 * PI) + iTime * 0.005 / size;\n    // Y point can be taken directly from cylinder, \n    // but squished to prevent too much texture wrapping\n    float y = cylinder.y * YSCALE + offset;\n    \n    return vec2(x, y);\n}\n\n// Both samplePerlin and sampleClouds just sample the textures\n// at multiple zoom levels with multiple weights for large\n// scale form and small scale detail\nfloat samplePerlin(vec2 uv) {\n    float[4] zoom    = float[] (0.1, 0.2, 0.6, 1.0);\n    float[4] weights = float[] (0.4, 0.3, 0.2, 0.1);\n    \n    float value = 0.0;\n    \n    for (int i = 0; i < 4; i++) {\n        value += texture(iChannel0, uv * zoom[i]).x * weights[i];\n    }\n    \n    return value;\n}\n\nfloat sampleClouds(vec2 uv) {\n    float[2] zoom    = float[] (0.1, 1.0);\n    float[2] weights = float[] (0.4, 0.6);\n    \n    float value = 0.0;\n    \n    for (int i = 0; i < 4; i++) {\n        vec4 cloud = texture(iChannel1, uv * zoom[i]);\n        float v = (cloud.x + cloud.y + cloud.z) / 3.0;\n        value += v * weights[i];\n    }\n    \n    return value;\n}\n\n// Compute intersection of UV point with planet, and determine color\n// according to value of perlin sample and color levels\nvec3 planet(vec2 uv, Planet planet) {\n    float dist = distance(uv, planet.position);\n    \n    if (dist < planet.size) {\n        vec3 sphere = spherePosition(uv, planet.position, planet.size, planet.rotation);\n        vec2 transformed = transform(sphere, planet.offset, planet.size);\n        \n        float value = samplePerlin(transformed.xy);\n        float bayer = texture(iChannel2, uv * (iResolution.y / (PIXEL_SIZE * 8.0))).x;\n        value += planet.bayer * bayer - planet.bayer / 2.0;\n        \n        vec3 col = planet.colors[3] / 255.0;\n        for (int i = 0; i < 3; i++) {\n            if (value < planet.levels[i]) {\n                col = planet.colors[i] / 255.0;\n                break;\n            }\n        }\n        \n        float cloud = sampleClouds(transformed.xy);\n\n        if (cloud > planet.clouds) {\n            col = vec3(0.8, 0.8, 0.8);\n        }\n        \n        float lighting = dot(LIGHT_DIRECTION, sphere) / 2.0 + 0.5;\n        \n        if (!planet.emitting) {\n            col *= lighting;\n        }\n        else {\n            col *= lighting + 1.0;\n        }\n        \n        return col;\n    }\n    else {\n        return vec3(0, 0, 0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float PIXEL_SIZE = floor(iResolution.y / IMAGE_HEIGHT);\n    vec2 uv = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE / iResolution.y;\n    \n    vec3 col = vec3(0, 0, 0);\n    for (int i = 0; i < TOTAL_PLANETS; i++) {\n        col += planet(uv, PLANETS[i]);\n    }\n\n    fragColor = vec4(col, 1);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}