{"ver":"0.1","info":{"id":"4djfz3","date":"1501466046","viewed":189,"name":"Calm Blue Ocean","username":"purrrcy","description":"Some fun with SDF water and a very simple day/night cycle","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","water","spheremarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The number of seconds for the sun to do one lap.\n#define DAY_NIGHT_CYCLE_PERIOD 32.\n\nstruct Sdf {\n    float dist;\n    float material;\n};\n\nSdf sdfSky(vec3 point) {\n    float d = length(point);\n\treturn Sdf(140. - d, 0.);\n}\n\nSdf sdfSphere(vec3 point, vec3 origin, float radius) {\n    vec3 po = point - origin;\n    float d = length(po);\n\treturn Sdf(d - radius, 1.);\n}\n\nSdf sdfPlane(vec3 point, vec3 normal, float D) {\n    float d = dot(point, normal) - D;\n\treturn Sdf(d, 1.);\n}\n\nfloat wave(float offset, float frequency, float dir, vec3 p) {\n\treturn cos(offset + frequency * dot(p.xz, vec2(cos(dir), sin(dir))));\n}\n\nfloat wave(float offset, float frequency, vec3 origin, vec3 p) {\n\treturn cos(offset + frequency * distance(p, origin));\n}\n\n\nfloat waves(float t, vec3 p) {\n\tfloat d = 0.;\n    //d += 0.10 * (sin(t * 0.5 + p.x) + cos(t * 0.3 + p.z));\n\t//d += 0.33 * (sin(t * .2 + p.x * 0.13) + cos(t * 0.17 + p.z * .2));\n    \n\td += 0.33 * wave(t * 1.1, 0.1, 2.0, p);\n\td += 0.37 * wave(t * .53, 0.13, 2.3, p);\n\td += 0.33 * wave(t * .33, 0.25, 0.3, p);\n\td += 0.31 * wave(t * .25, 0.33, 0.6, p);\n\n\td += 0.13 * wave(-t * 0.63, 0.6, vec3(80., 0.0, 50.), p);\n\t//d += 0.12 * wave(-t * 2.1, 0.2, vec3(-20., 0.0, -90.), p);\n\n\t\n    //d += 0.33 * wave(-t * 3.3, 0.6, vec3(80., 0.0, 30.), p);\n\n\t//d += 0.13 * wave(t * 1.3, 1.0, -0.6, p);\n\t//d += 0.7 * wave(t * 0.4, 0.2, 1.7, p);\n\t//d += 0.15 * wave(1.42 + t * 4.4, 0.2, vec3(1., 3.0, .0), p);\n\n    return d * 0.45;\n}\n\nSdf sdfWave(vec3 point, vec3 normal, float D) {\n    float d = dot(point, normal) - D\n        + waves(iTime, point);\n\treturn Sdf(d, 1.);\n}\n\nSdf pickClosest(Sdf a, Sdf b) {\n    float aOrB = step(b.dist, a.dist);\n    return Sdf(mix(a.dist, b.dist, aOrB),\n               mix(a.material, b.material, aOrB));\n}\n\nstruct Intersection {\n    vec3 normal;\n    float depth;\n    float material;\n};\n\nSdf world(vec3 p) {\n    Sdf closest = sdfSky(p);\n    Sdf ground = sdfWave(p, vec3(0., 1., 0.), -2.);\n\n    closest = pickClosest(closest, ground);\n    return closest;\n}\n\nvec3 worldNormal(vec3 p) {\n    //iq's trick\n    vec2 e = vec2(1.0, -1.0) * 0.0125;\n    return normalize(e.xyy * world(p + e.xyy).dist + \n\t\t\t\t\t e.yyx * world(p + e.yyx).dist + \n\t\t\t\t\t e.yxy * world(p + e.yxy).dist + \n\t\t\t\t\t e.xxx * world(p + e.xxx).dist );\n}\n    \nIntersection trace(vec3 rayOrigin, vec3 rayDirection, float startDepth) {\n    \n    float depth = startDepth;\n    \n    Sdf closest = Sdf(0., 0.);\n\n    for (int j = 0; j < 10; ++j) {        \n        for (int i = 0; i < 8; ++i) {\n\n            vec3 marched = rayOrigin + rayDirection * depth;\n\t\t\tclosest = world(marched);\n\n            depth += closest.dist;\n        }\n\t    if ((closest.dist * closest.dist) < 0.0001) {\n\t\t    vec3 normal = worldNormal(rayOrigin + rayDirection * depth);\n\t    \treturn Intersection(normal, depth, closest.material);\n    \t}\n    }\n    \n\tvec3 normal = worldNormal(rayOrigin + rayDirection * depth);\n    return Intersection(normal, depth, closest.material);\n}\n\nstruct SurfaceIntersection {\n    vec3 normal;\n    vec3 origin;\n    vec3 reflectionDirection;\n    vec3 refractionDirection;\n    \n    float NdotV;\n    float NdotT;\n};\n\nSurfaceIntersection surface(Intersection i, vec3 rayOrigin, vec3 rayDirection) {\n    vec3 V = -rayDirection;\n\tvec3 R = reflect(rayDirection, i.normal);\n\tvec3 T = refract(rayDirection, i.normal, 1.0 / 1.5);\n\n    return SurfaceIntersection(i.normal,\n                               rayOrigin + rayDirection * i.depth,\n                               R,\n                               T,\n                   \t\t\t   max(0., dot(i.normal, V)),\n                               max(0., dot(i.normal, -T)));\n}\n\nvec3 sunDirection() {\n    float t = iTime * (6.283 / DAY_NIGHT_CYCLE_PERIOD) + 1.2;\n    //t = 3.;\n    return normalize(vec3(0.2 * cos(t) + sin(t), .2 + .8 * cos(t), 0.2 * sin(t)));\n}\n\nvec3 skyColorDiffuse(vec3 direction) {\n    //direction = normalize(direction);\n\tvec3 L = sunDirection();\n    vec3 bgDay = mix(vec3(0.6, 0.7, .8), vec3(0.7, 0.8, .9), direction.y);\n    vec3 bgNight = mix(vec3(.075, .15, .15), vec3(.1, .2, .3), direction.y);\n    //vec2 polar = atan(direction.yy, direction.xz);\n    //vec3 bgStars = .3 * texture(iChannel1, polar.xy).rgb;\n    \n    vec3 bg = mix(bgNight, bgDay, smoothstep(-.2, .2, L.y));\n    //bg = mix(bgStars, bg, smoothstep(-.8, -.3, L.y));\n\n \n    // TODO: should do some atmospheric refraction here\n    float RdotL = max(0., dot(direction, L));\n    vec3 sun = mix(vec3(0.), vec3(0.3, 0.2, 0.), pow(RdotL, 2.));\n \n    \n\treturn bg + sun;\n}\n\nvec3 skyColorSpec(vec3 direction) {\n\tvec3 L = sunDirection();\n\n    // TODO: should do some atmospheric refraction here\n    float RdotL = max(0., dot(direction, L));\n    vec3 sunColor = mix(vec3(.8, .6, .1), vec3(.8, .2, .1), pow(1. - L.y, 2.));\n    vec3 sunSpot = sunColor * 13. * pow(RdotL, 250.);\n \n\treturn skyColorDiffuse(direction) + sunSpot;\n}\n\n\nvec3 Fresnel(vec3 n1, vec3 n2, float NdotV) {\n\tvec3 R0 = (n1 - n2) / (n1 + n2);\n    R0 = R0 * R0;\n    return R0 + (vec3(1.) - R0) * pow(1. - NdotV, 5.);\n}\n\nvec3 colorAtSurface(SurfaceIntersection surf) {\n\n    vec3 indirectSky = skyColorDiffuse(surf.normal) * .4;\n    \n    vec3 indirect = mix(vec3(0.0, 0.0, 0.2), vec3(0.1, 0.1, 0.4), max(0., surf.origin.y * 0.15 + .6));\n\treturn indirectSky + indirect;\n}\n\nvec3 colorAt(vec3 rayOrigin, vec3 rayDirection) {\n    \n    //find intersection in scene\n    vec3 origin = rayOrigin;\n    vec3 direction = rayDirection;\n    vec3 color = vec3(0.);\n    \n    vec3 intensity = vec3(1.);\n\tIntersection intersection = trace(origin, direction, 1.);\n    for (int i = 0; i < 3; ++i) {\n    \tif (intersection.material < 1.) {\n    \t\tcolor += skyColorSpec(direction) * intensity;\n            return color;\n        } else {\n\t\t    SurfaceIntersection surf = surface(intersection, origin, direction);\n    \t\tvec3 F = Fresnel(vec3(1.), vec3(1.4, 1.3, 1.4), surf.NdotV);\n            F += min(vec3(1.), pow(intersection.depth * 0.0045, 2.));\n            vec3 T = (1. - F) * intensity;\n            // mix in a surface layer and a deep ocean layer by the incidence\n            // of the refracted ray.\n            color += T * mix(colorAtSurface(surf), vec3(.01, .01, .1), surf.NdotT);\n            intensity *= F;\n            origin = surf.origin;\n            direction = surf.reflectionDirection;\n            intersection = trace(origin, direction, 24.);\n        }\n    }\n    // treat last hit as sky for the remaining intesity\n    color += skyColorDiffuse(direction) * intensity;\n    return color;\n}\n\nvec3 rotateX(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x, v.y * c - v.z * s, v.y * s + v.z * c);\n}\n\nvec3 rotateY(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}\n\nvec3 rotateZ(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x * c - v.y * s, v.x * s + v.y * c, v.z);\n}\n\nvec3 colorAtScreenCoord(vec2 uv) {\n    vec3 ray = normalize(vec3(uv, -1.4));\n    ray = rotateX(ray, .05 + (iMouse.y / iResolution.y) * 0.45);\n    \n    vec3 origin = vec3(0., 4., 5.);\n    origin = rotateY(origin, -1.9);\n    ray = rotateY(ray, -1.9);\n    \n\treturn colorAt(origin, normalize(ray));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy / iResolution.xy) - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.);\n    // do a silly spiral pattern AA\n    const int spp = 5; \n    const float sppF = 1. / float(spp);\n    for (int i = 0; i < spp; ++i) {\n        float rad = 3.141592 * (float(i) * 2.1 * sppF);\n        vec2 offset = float(i) * (sppF * 6. / iResolution.x) * vec2(cos(rad), sin(rad));\n\t    color += colorAtScreenCoord(uv + offset) * sppF;\n    }\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}