{"ver":"0.1","info":{"id":"4lt3DX","date":"1472100777","viewed":379,"name":"hexagonal tile science","username":"ollj","description":"on the quest for a branchless modular/tiny hex-tiling function that reurns TileID, ditanceToCenter and ditanceToBorder.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tiling","hex","tile","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//trying to learn and optimize hexTile functions...\n/*\n//the shortest code only returns HexTileID.xy, but with <155 chars.\n//https://www.shadertoy.com/view/ldcXW8 \nvoid mainImage(out vec4 o,vec2 i){\n i=i/.1/iResolution.y;\n o.xy-=step(i-=o.xy=ceil(i+=i.x*=.577),mod(o.x+o.y,3.)+--i.yx);\n o=mod(o.yyxy,sin(iTime)*.5+.5);\n}\n//but is not utilized or inttegrated in all others, while it easily could be.\n*/\n\n//most used code is a bit inefficient. (see below)\n//most code lacks a \"distance to border value\n\n/*\n//iq hex function is broken in its \"distance to center\" value.\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//return vec4 hexTile: cellId.xy,distanceToBorder.z,distnaceToCenter.z\nvec4 hex2(vec2 p){const float s=.5773503;\n vec2 q=vec2(p.x*2.*s,p.y+p.x*s),i=floor(q),f=fract(q),m=step(f.xy,f.yx);\n float v=mod(i.x+i.y,3.),a=step(1.,v),b=step(2.,v),\n e=dot(m,1.-f.yx+a*(f.x+f.y-1.)+b*(f.yx-2.*f.xy));// distance to borders\n p=vec2(q.x+floor(.5+p.y/1.5),4.*p.y/3.)*.5+.5;// distance to center (incorrect but close)\n return vec4(i+a-b*m,e,p);}\n//here \"p\" is incorrect, but iq never reads p, so no oneelse noticed?\n*/\n\n//distance to center function appears to be an unpredictable branch?\n//i disagree with that notion. there must be a branchless solution..\n\n//hexagonal tiling tuts            \n//https://www.shadertoy.com/view/4dKXR3\n//https://www.shadertoy.com/view/XdKXz3\n//https://www.shadertoy.com/view/lsKSRt\n\n//this is commonly used yet inefficient code:\n//still useful by breaking its symetries more.\nvoid mainImage(out vec4 r,vec2 i){\n const float w=1.53,q=w*.5;\n vec2 v=iResolution.xy,\n u=i=(i-v/2.)/v.y*5.*q;   //center\n u*=mat2(1.,-1./w,0.,2./w);   \n vec3 g=vec3(u,1.-u.xy);//to hex\n u=floor(g).xy*mat2(1.,.5,0.,q);//cell id\n vec2 a=u+vec2(1,0),b=u+vec2(.5,q),c=u+vec2(1.5,q);\n float f=length(u-i),k=length(a-i),h=length(b-i),j=length(c-i),//screenspace distance to nodes\n d=min(min(f,k),min(h,j));//closest node: d=dist, t=TileCoord\n vec2 t=(d==f?u:d==k?a:d==h?b:c);u=i-t;\n t=t*.25+vec2(.5);//shift to visible range\n r=vec4(t.xy,length(u.xy),1.);\n}\n\n//note to self:\n//i posibly just want to know my .xy position within a hex tiles coordinates.\n//that would allow me to warp back into the same tile when ever i leave it.","name":"Image","description":"","type":"image"}]}