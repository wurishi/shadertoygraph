{"ver":"0.1","info":{"id":"MlXyWB","date":"1506225744","viewed":58,"name":"[HP] Gel","username":"radikai","description":"Playing with path tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["anothertest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kTwoPi            6.28318530718\n#define kPi               3.14159265359\n#define kHalfPi           1.57079632679\n#define kQuarterPi        0.78539816339\n\n#define kDeg2Rad          (kPi/180.0)\n#define kRad2Deg          (180.0/kPi)\n\n#define kTextColor1       vec3(1.00, 0.75, 0.75)\n#define kTextColor2       vec3(0.75, 1.00, 0.75)\n#define kTextColor3       vec3(0.75, 0.75, 1.00)\n#define kTextSize         8.0\n\n#define kStepCount        64\n#define kBounceCount      16\n#define kGradEps          0.0001\n#define kPrecis           0.0002\n#define kTMax             32.0\n\n#define kSeed             123.0\n\n#define kCamDist          4.0\n#define kCamFov           70.0\n\n#define kRefractIdx       1.021\n#define kInvRefractIdx    (1.0 / kRefractIdx)\n\n#define kIdCube           1\n\n#define kForceScene       1\n#define kForceCost        0\n#define kMaxSteps         (4 * kStepCount)\n\n#define kSimpleScene      0\n\n#define kTest             1\n\nvec2 uAspect;\nvec3 uMouse;\nvec2 uUv;\n\n// --------------------------------------------------------------------------------\n// Debug print\n// --------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/4sBSWW\nfloat digitBin(const int x)\n{\n\treturn x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// https://www.shadertoy.com/view/4sBSWW\nfloat printValue(const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces)\n{\n\tif ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tfloat fReducedRangeValue = fValue;\n\t\t\t\t// jpr: fixed negative values\n\t\t\t\tif(fDigitIndex < 0.0) { fReducedRangeValue = mod( fValue, sign(fValue) ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n\t\t\t\tfCharBin = digitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n\t\t}\n\t}\n\treturn floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nstruct Debug_t {\n\tfloat unset;\n\tvec3 value1, value2, value3;\n} gDbg = Debug_t(1.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\nvoid setDebugVectors(const vec3 value1, const vec3 value2, const vec3 value3)\n{\n\tgDbg.value1 = mix(gDbg.value1, value1, gDbg.unset);\n\tgDbg.value2 = mix(gDbg.value2, value2, gDbg.unset);\n\tgDbg.value3 = mix(gDbg.value3, value3, gDbg.unset);\n\tgDbg.unset = 0.0;\n}\n\nvoid drawDebugVectors(inout vec3 col, in vec2 fragCoord)\n{\n\tcol = mix(col, kTextColor1, printValue((fragCoord - vec2(0.0,   25.0)) / kTextSize, gDbg.value1.x, 4.0, 3.0));\n\tcol = mix(col, kTextColor1, printValue((fragCoord - vec2(0.0,   15.0)) / kTextSize, gDbg.value1.y, 4.0, 3.0));\n\tcol = mix(col, kTextColor1, printValue((fragCoord - vec2(0.0,    5.0)) / kTextSize, gDbg.value1.z, 4.0, 3.0));\n\n\tcol = mix(col, kTextColor2, printValue((fragCoord - vec2(80.0,  25.0)) / kTextSize, gDbg.value2.x, 4.0, 3.0));\n\tcol = mix(col, kTextColor2, printValue((fragCoord - vec2(80.0,  15.0)) / kTextSize, gDbg.value2.y, 4.0, 3.0));\n\tcol = mix(col, kTextColor2, printValue((fragCoord - vec2(80.0,   5.0)) / kTextSize, gDbg.value2.z, 4.0, 3.0));\n\n\tcol = mix(col, kTextColor3, printValue((fragCoord - vec2(160.0, 25.0)) / kTextSize, gDbg.value3.x, 4.0, 3.0));\n\tcol = mix(col, kTextColor3, printValue((fragCoord - vec2(160.0, 15.0)) / kTextSize, gDbg.value3.y, 4.0, 3.0));\n\tcol = mix(col, kTextColor3, printValue((fragCoord - vec2(160.0,  5.0)) / kTextSize, gDbg.value3.z, 4.0, 3.0));\n}\n\n// --------------------------------------------------------------------------------\n// Math\n// --------------------------------------------------------------------------------\n\nmat3 rotateX(float a)\n{\n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a));\n}\n\nmat3 rotateY(float a)\n{\n\treturn mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\n\nmat3 rotateZ(float a)\n{\n\treturn mat3(cos(a), sin(a), 0.0, -sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n}\n\nhighp float rand1d(float v)\n{\n\thighp float a  = 12.9898;\n\thighp float c  = 43758.5453;\n\thighp float dt = v * a;\n\thighp float sn = mod(dt, 3.14);\n\treturn fract(sin(sn) * c);\n}\n\nhighp float rand2d(vec2 v)\n{\n\thighp float a  = 12.9898;\n\thighp float b  = 78.233;\n\thighp float c  = 43758.5453;\n\thighp float dt = dot(v.xy, vec2(a, b));\n\thighp float sn = mod(dt, 3.14);\n\treturn fract(sin(sn) * c);\n}\n \n// --------------------------------------------------------------------------------\n// SDF\n// --------------------------------------------------------------------------------\n\nstruct Sample_t {\n\tfloat d;\n\tint id;\n};\n\t\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nSample_t front(Sample_t s1, Sample_t s2)\n{\n\tif (s1.d < s2.d)\n\t\treturn s1;\n\telse\n\t\treturn s2;\n}\n\nSample_t map(vec3 p)\n{\n#if !kSimpleScene\n\tvec3 mp = mod(clamp(p, -2.0, 2.0), vec3(0.5)) - 0.25;\n\tp.xz = mp.xz;\t\n#endif\n\tSample_t s = Sample_t(sdRoundBox(p, vec3(0.1, 0.2, 0.1), 0.05), kIdCube);\n\treturn s;\n}\n\n// --------------------------------------------------------------------------------\n// Ray marching\n// --------------------------------------------------------------------------------\n\nstruct Hit_t {\n\tvec3 rayPos, rayDir; // viewspace ray position and direction\n\tfloat rayLen;        // sum of ray lengths over bounces\n\tfloat internalLen;   // sum of interior ray lengths\n\tvec3 normal;         // surface normal\n\tint id;              // object id\n\tint steps;           // step count\n\tvec3 bn1;\n};\n\n// https://www.shadertoy.com/view/Xds3zN\nvec3 grad(vec3 p)\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(p+eps.xyy).d - map(p-eps.xyy).d,\n        map(p+eps.yxy).d - map(p-eps.yxy).d,\n        map(p+eps.yyx).d - map(p-eps.yyx).d );\n    return normalize(nor);\n}\n\n\nHit_t march(const Hit_t hit, const float tMin, const float tMax, const float stepAlpha, const bool internal, const int bounce, const bool debug)\n{\n\tfloat t = tMin;\n\tvec3 p;\n\tSample_t s;\n\tint i = 0;\n\tfor (; i < kStepCount; ++i) {\n\t\tp = hit.rayPos + t * hit.rayDir;\n\t\ts = map(p);\n\t\tt += stepAlpha * (internal ? -s.d : s.d); // sdf is negative inside the volume; flip sign to continue forward \n\t\tif (abs(s.d) < (kPrecis * t) || t > tMax)\n\t\t\tbreak;\n\t}\n    if (i == kStepCount)\n        t = tMax;\n\treturn Hit_t(p, hit.rayDir, hit.rayLen + t, hit.internalLen + (internal ? t : 0.0), grad(p), s.id, hit.steps + i, vec3(0));\n}\n\nHit_t marchTransparent(in vec3 origin, in vec3 dir, const float tMin, const float tMax, const float stepAlpha, const bool debug)\n{\n\tbool internal = false;\n\tint i = 1;\n\n\tHit_t hit = Hit_t(origin, dir, 0.0, 0.0, vec3(0), 0, 0, vec3(0));\n    hit = march(hit, tMin, tMax, stepAlpha, false, 0, debug);\n    vec3 bn1 = hit.normal;\n\n    for (; i < kBounceCount; ++i) {\n        if (hit.rayLen >= kTMax) break;\n        if (mod(float(i), 2.0) == 1.0)\n\t        bn1 = hit.normal;\n\n\t\tfloat refractiveIndex = internal ? kInvRefractIdx : kRefractIdx;\n\t\tvec3 refractiveDir = refract(hit.rayDir, internal ? -hit.normal : hit.normal, refractiveIndex);\n        if (refractiveDir == vec3(0)) {\n            hit.rayDir = reflect(hit.rayDir, internal ? -hit.normal : hit.normal);\n        } else {\n            hit.rayDir = refractiveDir;\n            internal = !internal;\n        }\n\n        float separation = 0.0075;\n        float startDistance = separation / abs(dot(dir, hit.normal));\n\n\t\thit.rayPos += startDistance * hit.rayDir;\n\t\thit = march(hit, tMin, tMax, stepAlpha, internal, i, debug);\n\t}\n\n    if (debug) { setDebugVectors(vec3(i, hit.steps, hit.rayLen), hit.rayPos, hit.rayDir); }\n    hit.bn1 = bn1;\n    return hit;\n}\n\n// --------------------------------------------------------------------------------\n// Materials\n// --------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n\treturn a + b*cos(6.28318*(c*t+d));\n}\n\nfloat rand(float s){\n    return fract(sin(s * 12.9898) * 43758.5453);\n}\n\nvec3 shade(in vec3 camDir, Hit_t hit, in vec2 fragCoord, const bool debug)\n{\n    vec3 col = vec3(0.3, 0.5, 0.8) * clamp(vec3(2.0 * pow(hit.internalLen, 1.8)), 0.0, 2.0);\n    col += 0.15 * clamp(hit.internalLen, 0.0, 1.0) * rand(hit.rayPos.x);\n    col = clamp(col, 0.0, 1.0);\n    return col * vec3(1.5 * dot(hit.bn1, -camDir) - 0.5);\n}\n\nvec3 cost(in vec3 camDir, Hit_t hit, in vec2 fragCoord, const bool debug)\n{\n\tfloat t = float(hit.steps) / float(kMaxSteps);\n\tvec3 col = pal(t, vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(0.5,0.5,0.5),vec3(0.5,0.0,0.75));\n\treturn col;\n}\n\n// --------------------------------------------------------------------------------\n// Entrypoint\n// --------------------------------------------------------------------------------\n\nvec3 getColor(in vec2 fragCoord, const bool debug)\n{\n\tvec2 uv     = fragCoord.xy / iResolution.xy;\n\tuv          = uv * 2.0 - 1.0;\n\tuv.y       *= uAspect.y;\n\n\tmat3 view   = rotateY(kPi * uMouse.x) * rotateX(kQuarterPi * max(1.0 - uMouse.y, 0.0));\n\tvec3 origin = view * vec3(0.0, 0.0, -kCamDist + uMouse.y);\n\tvec3 dir    = view * normalize(vec3(uv, 1.0 / tan(kDeg2Rad * kCamFov / 2.0)));\n\n\tHit_t hit = marchTransparent(origin, dir, 0.0, kTMax, 1.0, debug);\n\n#if kForceScene\n\tvec3 col = shade(dir, hit, fragCoord, debug);\n#elif kForceCost\n\tvec3 col = cost(dir, hit, fragCoord, debug);\n#else\n\tvec3 col  = (uMouse.z == 1.0)\n\t\t? cost(hit, fragCoord, debug)\n\t\t: shade(hit, fragCoord, debug);\n#endif\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tuAspect     = iResolution.xy / iResolution.x;\n\n\tuMouse.xy   = iMouse.xy / iResolution.xy;\n\tuMouse.xy   = uMouse.xy * 2.0 - 1.0;\n\tuMouse.z    = 1.0 - step(iMouse.z, 0.0);\n\n    bool down = (iMouse.z > 0.0);\n    if (!down) {\n        uMouse.xy = vec2(sin(0.1 * iTime), cos(0.2 * iTime));\n    }\n\n    vec3 col    = getColor(fragCoord, false);\n\n#if kTest\n    vec3 test   = getColor(iMouse.xy, true);\n\tdrawDebugVectors(col, fragCoord);\n#endif\n\n    col = pow(col,vec3(0.4545));\n\tfragColor.rgb = col;\n}\n","name":"Image","description":"","type":"image"}]}