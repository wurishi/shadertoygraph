{"ver":"0.1","info":{"id":"l3V3zK","date":"1717941502","viewed":89,"name":"PsyXo","username":"maxiie","description":"Psychedelic Webcam Shader","likes":0,"published":1,"flags":34,"usePreview":0,"tags":["psychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fmod(float t,float a){\n  return fract(t/a)*a;\n}\n\n#define N 7.0\n\n// shuffling parts of the image\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 v = fragCoord/iResolution.xy;\n\n    \n    // sample texture and output to screen\n    \n    fragColor=texture(iChannel0,v);\n    vec4 webc=texture(iChannel1,v+sin(iTime*3.)/30.);\n    fragColor*=webc;\n    \n    fragColor.xyz=rgb2hsv(fragColor.xyz);\n    fragColor.x+=length(v+sin(iTime*100.));\n    fragColor.x*=sin(iTime*10.)*100.;\n    fragColor.xyz=hsv2rgb(fragColor.xyz);\n    fragColor+=webc*sin(iTime*100.);\n    fragColor/=1.+sin(iTime*100.);\n    fragColor.xyz+=rgb2hsv(fragColor.xyz);\n    fragColor.z=clamp(fragColor.z,0.3,0.7);\n    fragColor.y=clamp(fragColor.y,0.3,0.9);\n    fragColor.xyz=hsv2rgb(fragColor.xyz);\n   \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Made via ShaderToy\n// update v1.0.0 init\n// update v1.0.0 got rid of needless color function\n\n// Animations, one at a time\nbool POWERS = true;\n\n// Constants\nbool COLORBAND = false;\nbool ZOOM = true;\n\nfloat SLOWTIME = 3.0;\nfloat ZOOM_MAG = 1.0;\nfloat RADIUS = 20.0;\nfloat COLORFULL = 0.0;\nfloat SPEED = 1.0;\n\nint ITERATIONS = 900;\n\n// POSITIONS\n\n// ZOOMS\n//vec2 zoomPosition = vec2(.65, .45);\nvec2 zoomPosition = vec2(0.0);\n\n// STARTING\nvec2 startingPosition = vec2(0.2, 0);\n\n\n// Helper Functions\nvec2 complexPow(vec2 z, float n){\n    float theta = atan(z.y, z.x);\n    float r = length( z );\n    return pow(r, n) * vec2(cos(theta * n), sin(theta * n));\n}\n\nfloat frac(float f){\n    return f - floor(f);\n}\n\n// COLOR FUNCTIONS\nvec3 mandelColor(float iteration,vec3 ax, vec3 bx){\n    float sn = iteration/float(ITERATIONS) * float(COLORFULL);\n    float t = frac(sn + .5);\n    vec3 a = vec3(.5);\n    vec3 b = vec3(.5);\n    vec3 c = vec3(1);\n    vec3 d = vec3(.0, .1, .2);\n    \n    vec3 color = ax;\n    \n    if(iteration != float(ITERATIONS)){\n        color = bx;\n    }\n    \n    return color;\n}\n\nvec3 blackWhite(float iteration, bool middleWhite, bool reverse){\n    if(iteration == float(ITERATIONS) && !middleWhite){\n        return vec3(0.0, 0.0, 0.0);\n    }else if(reverse){\n        return vec3(1.0 - iteration/float(ITERATIONS) * COLORFULL);\n    }\n    return vec3(iteration/float(ITERATIONS) * COLORFULL);\n}\n\n// MANDEL\nfloat mandelBrot(vec2 z_0, float i_m, float a) {\n    z_0 = 2.5 * z_0 - startingPosition;\n    \n    if(ZOOM){\n        z_0 = z_0/ZOOM_MAG - zoomPosition;\n    }else{\n        z_0 = z_0 / pow(iTime, 2.0) - zoomPosition;\n    }\n    \n    vec2 z_n = z_0;\n    float i_z = 0.0;\n    float m_z = dot(z_0, z_0);\n    \n    while(i_z < i_m && m_z < RADIUS){\n        if(POWERS){\n            z_n = complexPow(z_n, 1.0 + a) + z_0;\n        }else{\n            z_n = complexPow(z_n, 1.0 + a) + tan(a) * z_n + z_0;\n        }\n        \n        i_z += 1.0;\n        m_z = dot(z_n, z_n);\n    }\n    \n    if(i_z == float(ITERATIONS)){\n        return float(ITERATIONS);\n    }\n    \n    if(COLORBAND){\n        return i_z;\n    }\n    \n    return float(i_z + 1.0 - (log(log(m_z))/log(1.0 + a)));\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    float a = sin(SPEED * iTime / SLOWTIME)*10.+10.;\n   \n    \n    float iterations = mandelBrot(uv, float(ITERATIONS), a);\n    \n    float iTIME=iTime*2.;\n    //vec3 color = blackWhite(iterations, false, false);  // BLACK AND WHITE (WHITE CENTER)\n    vec3 color = mandelColor(iterations,vec3(sin(iTIME*7.847),sin(iTIME*3.847),sin(iTIME*2.847)),vec3(sin(iTIME*7.847+83.4345),sin(iTIME*3.847+37.29),sin(iTIME*2.847+8738.2344)));\n    \n    a = sin(SPEED * iTime / SLOWTIME*1.5)*10.+10.;\n   \n    iTIME*=1.1;\n     iterations = mandelBrot(-uv, float(ITERATIONS),a);\n    \n    \n    //vec3 color = blackWhite(iterations, false, false);  // BLACK AND WHITE (WHITE CENTER)\n    color =color+mandelColor(iterations, vec3(sin(iTIME*7.847),sin(iTIME*3.847),sin(iTIME*2.847)),vec3(sin(iTIME*7.847+83.4345),sin(iTIME*3.847+37.29),sin(iTIME*2.847+8738.2344)));\n    \n    \n    a = sin(SPEED * iTime / SLOWTIME*2.7)*10.+10.;\n    iTIME*=1.1;\n     iterations = mandelBrot(uv, float(ITERATIONS),a);\n    //vec3 color = blackWhite(iterations, false, false);  // BLACK AND WHITE (WHITE CENTER)\n    color =color+mandelColor(iterations, vec3(sin(iTIME*7.847),sin(iTIME*3.847),sin(iTIME*2.847)),vec3(sin(iTIME*7.847+83.4345),sin(iTIME*3.847+37.29),sin(iTIME*2.847+8738.2344)));\n    \n    \n    a = sin(SPEED * iTime / SLOWTIME*3.9)*10.+10.;\n    iTIME*=1.1;\n     iterations = mandelBrot(-uv, float(ITERATIONS),a);\n    //vec3 color = blackWhite(iterations, false, false);  // BLACK AND WHITE (WHITE CENTER)\n    color =color+mandelColor(iterations, vec3(sin(iTIME*7.847),sin(iTIME*3.847),sin(iTIME*2.847)),vec3(sin(iTIME*7.847+83.4345),sin(iTIME*3.847+37.29),sin(iTIME*2.847+8738.2344)));\n    \n    fragColor = vec4(color/4., 1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float fmod(float t,float a){\n  return fract(t/a)*a;\n}\n\n#define N 7.0\n\n// shuffling parts of the image\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 v = fragCoord/iResolution.xy+iTime*3.;\n    vec2 v2 = fragCoord/iResolution.xy+iTime*21.3456;\n\n    \n    // sample texture and output to screen\n    \n    fragColor=texture(iChannel0,vec2(fmod(v.x*1.,1.),fmod(v.y*1.,1.)))*24.;\n    fragColor+=texture(iChannel0,vec2(fmod(v.x*2.,1.),fmod(v.y*2.,1.)))*10.;\n    fragColor+=texture(iChannel0,vec2(fmod(v.x*4.,1.),fmod(v.y*4.,1.)))*4.;\n    fragColor+=texture(iChannel0,vec2(fmod(v.x*8.,1.),fmod(v.y*8.,1.)))*3.;\n    fragColor+=texture(iChannel0,vec2(fmod(v.x*8.,1.),fmod(v.y*8.,1.)))*2.;\n    fragColor+=texture(iChannel0,vec2(fmod(v.x*16.,1.),fmod(v.y*16.,1.)));\n    fragColor+=texture(iChannel0,vec2(fmod(v.x*32.,1.),fmod(v.y*32.,1.)));\n    //fragColor+=texture(iChannel1,vec2(fmod(v.x*2.,1.),fmod(v.y*2.,1.)))*12.;\n    //fragColor+=texture(iChannel1,vec2(fmod(v2.x*2.+1.,1.),fmod(v2.y*2.+1.,1.)))*6.;\n    fragColor/=21.;\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}