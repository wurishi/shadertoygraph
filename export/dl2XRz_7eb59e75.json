{"ver":"0.1","info":{"id":"dl2XRz","date":"1675621346","viewed":244,"name":"D&D Dice","username":"kastorp","description":"using an octahadron, and axis symmetry, to calculate face coordinates ","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["icosahedron","dice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//D&D Dice by kastorp\n//------------------------------\n\n\n\n//#define SPHERE //same but spherical\n\n\n// ICOSAHEDRON map function. xy=uv, z=face distance, w=face id, \nvec4 ico(in vec3 pos){\n  \n  // setup constants\n  const float pi = 3.14159;\n  const float k = (sqrt(5.0) - 1.0) / 2.0; //golden ratio  - 1\n  const float side=1.+k*k; //triangle side length\n  const vec3 e3 = vec3(.0, 0.0, 1.0);\n  const vec3 V1 = vec3(0.0,  1.0, k); //one of the 3 vertexes inside octahedron quadrant\n  const vec3 G = vec3(1.+k) / 3.0;   //central face barycenter\n  const vec3 P12 = normalize(cross(V1.zxy - e3, V1 - e3)); //the normal of one of the lateral faces\n  const vec3 P123 = normalize(G); //the normal of the central face\n \n   vec2 uv=vec2(0);\n   float id=0.,fl=1.;  \n   \n   float t = 1e10;   \n   vec3 va=V1,vb= V1.zxy,vc= V1.yzx;\n\n   // OCTAHEDRON symmetry\n   vec3 p = abs(pos);\n   \n   //barycenter coordinates on central triangle\n   vec3 q=(vec3(dot(p,cross(va,vb)),dot(p,cross(vb,vc)),dot(p,cross(vc,va))))/side;   \n   if(all(greaterThanEqual(q,vec3(0.)))) {\n       //inside central triangle    \n       id=dot(vec3(1,2,4),sign(pos))*.5+4.5;   //face id 1-8\n       t= dot(p - G, P123); //face distance\n       if(pos.x*pos.z*pos.y<0.) fl=-1.; //flip x axis\n   }\n   else {\n       //inside one of the 3 semi-faces\n       //use AXIS symmetry\n       id=9.;\n       if(q.y<0.){p=p.yzx;pos=pos.yzx;id+=4.;} //120° rotation \n       else if(q.z<0.){p=p.zxy;pos=pos.zxy;id+=8.;} //inverse 120° rotation \n\n       t= dot(p - vec3(0,0,1), P12); //face distance\n       vc = vb*vec3(-1, 0, 1); //3-rd vertex is specular\n       if(pos.x<.0){ vb*=vec3(-1, 0, 1);;vc*=vec3(-1, 0, 1);} //flip 2-nd and 3-rd vertexes \n       id+=dot(vec3(0,1,2),sign(pos))*.5+1.5; //face id 9-12 (or 13-16 or 17-20)\n       fl=-sign(pos.y*pos.z);  //flip x axis \n       \n       //recalc face barycenter coordinates\n       q=(vec3(dot(p,cross(va,vb)),dot(p,cross(vb,vc)),dot(p,cross(vc,va))))/side;\n       \n   }  \n   q/=(q.x+q.y+q.z);\n\n   //uv coordinates, where center is in(0,0)\n   uv=(vec2(q.y+q.z*.5,q.z*sqrt(3.)/2.)-vec2(.5,.5/sqrt(3.)))*vec2(fl,1);  \n \n   return vec4(uv*side,t,id);\n}\n\n\nfloat map(in vec3 p){\n\n    vec4 t= ico(p);\n#ifdef SPHERE \n    t.z=length(p)-1.;\n#endif    \n   \n   if(t.z<.1){\n   t.z= min(max(\n       max(t.z,-opExtrude(t.z, length(t.xy)-.27,.03)), \n      -opExtrude(t.z, -hex(t.xy*6.315)/6.315,.03)),\n      \n    // t.z= min(t.z,sBox(vec3(t.z-.2,t.xy*rot(iTime*5.)),vec3(.05,.25,.25)));\n    opExtrude(t.z+.03, sInt(iChannel3,t.xy*2. +vec2(t.w>9.? .25:.0,.0),t.w)/2.,.03));\n    }\n    return t.z;\n}\n\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  vec3 n;\n  n.x = map(p + eps.xyy) - map(p - eps.xyy);\n  n.y = map(p + eps.yxy) - map(p - eps.yxy);\n  n.z = map(p + eps.yyx) - map(p - eps.yyx);\n  return normalize(n);\n}\n\n\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; \n  const float precis = 0.001;  \n  float t = 0.0; \n  float result = -1.0,h=maxd;\n  for(int i = 0; i < 100; i++){\n    if(h < precis || t > maxd){ break; }\n    h = map(camera + t * ray);\n    t += h;\n  }\n  if(t < maxd){ result = t; }\n  return result;\n}\n\nvec3 transform(in vec3 p){\n  float angleX =  iTime * 0.6;\n  float angleY =  iTime * 0.4;\n  p.yz *=rot(angleX);  \n  p.zx *= rot(angleY);\n  return p;\n}\n\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n\n  vec3 ray = transform(normalize(vec3(p, -1.8)));\n  vec3 camera =transform( vec3(0.0, 0.0, 2.7));\n  vec3 light = transform(normalize(vec3(1., 1., 1.0)));\n      \n  //background\n  color = mix(vec3(0.1, 0.4, 0.5), vec3(.9,.7,.7),.5 + p.y * 0.5);\n  float t = march(ray, camera);\n  \n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    t = march(light, pos+n*.01);\n    if(t>0. && t<1e5) diff*=.5;\n    \n    vec4 co = ico(pos);    \n    vec3 baseColor=  (.5 + .4*cos(vec3(0,2,4)+co.xyx*3.14 /.5));  \n    \n    baseColor=mix(baseColor,vec3(1),smoothstep(0.0,-0.001,sInt(iChannel3,co.xy*2. +vec2(co.w>9.? .25:.0,.0),co.w)/2.));\n    baseColor *= diff;\n    \n    \n    // fadeout effect.\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  fragColor = vec4(color, 1.0);\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nfloat letter(sampler2D chn,vec2 p,int ch){\n    ch+=48;\n    if(max(abs(p.x),abs(p.y))>.5)  return length(p)-.3;\n    vec2 cp = vec2(ivec2(ch%16, 15-ch/16));\n    vec4 d= textureLod(chn, (p+ cp + 0.5)/16., 0.) ;\n    vec2 grad=vec2(-1,1) *(d.yz-vec2(.5))*2.;\n    float dst=(d.w-.501) ;\n    return dst;\n}\nfloat sInt(sampler2D chn,vec2 p, float n) {\n    float d=1e5;\n    if (n < 0.)  p += vec2(-.5,0), n = -n;\n    \n    for (float i = (n>9.?1.:0.); i>=0.; i--)  n /=  9.999999, d=min(d,\n    \n   letter(chn, p - .5*vec2(i,0), int(fract(n)*10.) )\n    \n    );\n    return d;\n}\n//David Hoskins Hash without sin\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nfloat sBox(vec3 p,vec3 b){\n    p=abs(p)-b;\n    return max(max(p.x,p.y),p.z);\n}\n//Iq\nfloat opExtrude( in float  z, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\n\n#define TAU 6.2832\nvec3 tri(vec2 uv){ \n    const mat2 sk = mat2(2./sqrt(3.),0,1./sqrt(3.),1),ski = inverse(sk); float d=1./6.;\n    float sd =step(fract(uv*sk).x ,fract(uv*sk).y)*2.-1.;\n    vec2  c = floor(uv*sk) +vec2(.5) + sd*d*vec2(-1,1) ;c*=ski;\n    return vec3(c,sd);\n}\nfloat hex(vec2 uv){\n    vec3 t = tri(uv); \n    float tk=.05;\n    float d=1e5;    \n    for(int i=0;i<3;i++){\n        d=min(d,max((uv.x-t.x)*t.z,abs(t.y-uv.y)-tk));\n        uv = t.xy+ (uv-t.xy)*rot(TAU/3.);        \n    }\n    return d;\n}","name":"Common","description":"","type":"common"}]}