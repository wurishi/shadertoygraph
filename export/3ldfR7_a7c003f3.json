{"ver":"0.1","info":{"id":"3ldfR7","date":"1612441532","viewed":92,"name":"Cartesian Plane","username":"Elieder","description":"Just some test with lines and circles to make a cartesian plane.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circles","lines","cartesianplane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n *  Copyright (c) 2020, Elieder Sousa\n *  eliedersousa<at>gmail<dot>com\n *  \n *  Distributed under the MIT license.\n *  \n *  @date       04/02/2021\n *  @brief      (PORTUGUESE COMMENTS) Aqui eu mostro como criar um plano cartesiano no Shadertoy. \n *  \n */ \n\n// Variáveis globais.\nconst float smoothFactor = .008;\n\nfloat Circle( vec2 uv, vec2 pos, float radius) {\n\n    // Fazemos a translação da coordenada para calcular com base na posição\n    // Alargamos o plano multiplicando pelo tamanho\n    // E calculamos a distância do nosso ponto até o centro do eixo \n    //uv -= pos;\n    //float dist = length( uv );\n\n    // Porém, assim é melhor:\n    float dist = length( uv - pos );\n\n    // Este if abaixo é praticamente a mesma coisa que:\n    // dist = smoothstep( radius, radius - 0.00000001 , dist );\n\n    /*\n    if( dist < radius ) {\n        dist = 1.;\n    } else {\n        dist = 0.;\n    }\n    */\n\n    // smothstep( min, max, input );\n    // Se dist for menor que radius, retorna 0.\n    // Se dist for maior que radius + smoothFactor, retorna 1.\n    // Qualquer valor entre radius e radius + smoothFactor retorna uma curva suave\n\n    // Se fizessemos dist = smoothstep( radius, radius + smoothFactor, dist );\n    // Ficaria errado, pois a função pintaria toda a parte de fora de branco\n    // Isso cancelaria qualquer outra manipulação de cor que fizessemos depois disso\n    dist = smoothstep( radius, radius - smoothFactor, dist );\n    return dist;    \n}\n\n// Cria uma linha na posição especificada\n// LineDebug( uv.x , .4 );\nfloat LineDebug( float axis, float pos ) {\n    float blur = .002;\n    float bias = pos + .004;\n    float l1 = smoothstep( pos - blur, pos + blur, axis);\n    float l2 = smoothstep( bias + blur, bias - blur, axis);\n\n    return l1 * l2;\n}\n\nfloat PlanoCartesiano( vec2 uv, vec2 center ) {\n    float c = LineDebug( uv.y, center.x );\n    c += LineDebug( uv.x, center.y );\n    return c;\n}\n\n// Lembre-se:\n// fragColor é a cor final do pixel: vec4( red, green, blue, alpha );\n// fragCoord é a coordenada do pixel que está sendo processado no momento: vec2(x, y);\n// iResolution é o tamanho da nossa tela: vec2( width, height );\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Setup da nossa tela de desenho.\n    vec2 uv = fragCoord / iResolution.xy;   // Normalização\n    uv -= .5;                               // Centralização do eixo de coordenadas\n    uv.x *= iResolution.x / iResolution.y;  // Aspect-Ratio\n\n    // Declaração de variáveis e vetores.\n    vec3 color = vec3( 0. );\n\n    // Desenha alguns círculos.\n    color += vec3(Circle(uv, vec2(.3,.3), .1), .0, .0);\n    color += vec3(.0, Circle(uv, vec2(.0,-.3), .05), .0);\n    color += vec3(.0, .0, Circle(uv, vec2(-.7,.1), .25));\n\n    // Desenha o nosso plano cartesiano.\n    color += PlanoCartesiano( uv, vec2(.0, .0)) * .4;\n\n    // Retorna qual cor este pixel deve ter.\n    fragColor = vec4( color, 1. );\n\n}","name":"Image","description":"","type":"image"}]}