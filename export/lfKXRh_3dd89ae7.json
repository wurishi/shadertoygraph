{"ver":"0.1","info":{"id":"lfKXRh","date":"1717405379","viewed":149,"name":"yellowTerrain","username":"dmc203","description":"Just to learn RayMarching \nVideoLink https://www.youtube.com/watch?v=BFld4EBO2RE&t=1466s","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//光照方向\nconst float theta = 1.2;\nconst float alpha = -2.0;\nvec3 lightDir = vec3(sin(theta)*sin(alpha),cos(theta),sin(theta)*cos(alpha));\n\n\n//矩阵定义\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}                       \n//哈希随机值\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n//FBM\n//FBM\nint fbmDepth;\nint setDepthWithDistance(float t,float depth)\n{\n    \n    float res = pow(2.0,-t * 0.0005)*depth;\n    return fbmDepth = int(floor(res));\n}\n\nfloat fbm( in vec2 x )\n{\n    // h(x)=b*s*g(f*x)\n    float f = 1.6;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<5; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\n//\nvec3 fbmd( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=0; i<fbmDepth; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*x;\n        m = f*m;\n    }\n\treturn vec3( a, d );\n}\nvec4 fbmcloud( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n// 环境\nconst float kMaxHeight = 840.0;\nconst float SkyHeight = 2500.0;\n\n\nvec4 terrainMapD( in vec2 p )\n{\n    vec3 e = fbmd( p/2000.0 + vec2(1.0,-2.0) );\n    e.x  = 600.0*e.x + 600.0;\n    e.yz = 600.0*e.yz;\n    e.yz /= 2000.0;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\nconst vec3 skycolor = vec3(0.21,0.586,1.1);\nvec3 renderSky(vec3 ro,vec3 rd)\n{\n    vec3 col = skycolor - rd.y*0.4;\n    \n    float sun = clamp(dot(lightDir,rd),0.0,1.0);\n    col += 0.2*vec3(1.0,0.6,0.3)*pow( sun , 32.0);\n    return col;\n}\n//光线步进\n\nfloat raymarchCloud( in vec3 ro, in vec3 rd)\n{\n    // raymarch\n    //步进距离\n    float hei = SkyHeight-ro.y;\n    //光线和向上方向的夹角\n    float angle = dot(rd,vec3(0.0,1.0,0.0));\n    float t = hei/tan(angle);\n    vec3 pos = ro + t*rd;\n    float col = fbm(pos.xz/2000.0+vec2(iTime/5.0,0.0));\n    float fog = exp(-0.0001*distance(ro,pos));\n    return (fog)*smoothstep(-0.3,0.4,col)+(1.0-fog)*1.0;\n\n}\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.00025*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); // 0.55\n}\n\nfloat raymarchingShadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float k = 32.0;\n    float res = 1.0;\n    float t = mint;\n    float th;\n    for(int i ; i<=128 ; i++)\n    {\n        th = 0.001*t;\n        vec3 pos = ro + t * rd;\n        float terrainHeight = terrainMapD(pos.xz).x;\n        float dis = pos.y - terrainHeight;\n        if(dis<=th){\n            return 0.0;\n        }\n        res = min( res, 32.0*dis/t );\n        if( res<0.0001 || pos.y>kMaxHeight ) break;\n        t += clamp( dis, 2.0+t*0.1, 100.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\nfloat raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    // raymarch\n    float dis, th;\n\n    float t = tmin; \n    \n    float ot = t;\n    float odis = 0.0;\n    //float odis2 = 0.0;\n    for( int i=0; i<400; i++ )\n    {\n        //当位置（pos.y）与高度(hei)的差值小于th时就可以采样,t为步进长度\n        //t为当前步进的长度，th随t递增用于控制采样精度随距离递减\n        //步进距离 dt = dis*0.8*(1.0-0.75*env.y)受到场景做性能优化\n        th = 0.01*t;\n\n        vec3  pos = ro + t * rd;\n        setDepthWithDistance(t,15.0);\n        float env = terrainMapD( pos.xz ).x;\n        float hei = env;\n\n        // terrain\n        dis = pos.y - hei;\n        //步进点距离地形较近时\n        if( dis<th ) break;\n        ot = t;\n        odis = dis;\n        t += dis * 0.75;\n        if( t > tmax )break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)/(dis-odis); // linear interpolation for better accuracy\n    \n    return t;\n}\n//fog\nconst float speed = 1.0;\nconst vec3 terraincol=vec3(194.0/254.999 , 142.0/254.999 , 0.6);\n\nvec4 cameraRender(in vec2 uv)\n{\n    vec2 o = vec2(-0.5,-0.5);\n    vec2 dirpos = (2.0*(uv)-iResolution.xy)/ iResolution.y;\n    //相机位置\n    float time = iTime;\n    vec3 ro = vec3(-9000.0, 680.9 + iTime, 300.0+iTime);\n    vec3 ta = vec3(ro.x+0.5, ro.y, ro.z-1.0); \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    //将光线应用相机的移动矩阵\n    vec3 raydir = ca * normalize( vec3(dirpos,1.5));\n    const float tmax = 4000.0;\n    float resT=2000.0;\n    vec3 col = renderSky( ro , raydir );\n    \n    vec3 lightDir = vec3(sin(theta)*sin(alpha),cos(theta),sin(theta)*cos(alpha));\n    //CloudMarching\n    float cloud = raymarchCloud(ro,raydir);\n    col += cloud*0.5;\n    col = col + pow(max(dot(lightDir,raydir),0.0)*0.5,256.0);\n    //地形步进\n    float t = raymarchTerrain( ro, raydir, 0.0 , tmax );\n    //alpha += iTime;\n\n    if( t>0.0 )\n    {\n        resT = t;\n        vec3 pos  = ro + resT*raydir;\n        vec3 tnor = terrainNormal( pos.xz );\n        vec3 Abedo =vec3(2.51 , 1.13 , 0.23);\n        //// lithing\n        col = vec3(0.16);\n        //环境光\n        vec3 lin =vec3(0.0);\n        float ambient = smoothstep(-0.0,1.2,tnor.y);\n        //shadow\n        float isShadow = raymarchingShadow(pos , lightDir , 0.0 , tmax);\n        vec3 shadow = vec3(isShadow);\n        // 漫反射\n        vec3 dif = Abedo * max( dot(tnor, lightDir),0.0 )*shadow;\n        //背面光照\n        float back = clamp(dot(normalize(vec3(-lightDir.x, 0.0, lightDir.z )), tnor ), 0.0, 1.0 );\n        lin += dif;\n        lin += ambient*vec3(0.35,0.2,0.1)*1.0;\n        lin += back*vec3(0.4,0.4,0.6)*0.1;\n        col *= lin;\n        //反射光\n        col += (1.0 + tnor.y ) / 2.0 * (skycolor/16.0);\n        col += dot(tnor , -lightDir)*vec3(0.51 , 0.43 , 0.23)/12.0;\n        \n        float coe = exp(-t*0.0001);\n        vec3 fogcol = vec3(1.3,1.0,1.0);\n        col = (1.0-coe)*fogcol + coe*col;\n    }\n    //色调映射和gamma矫正\n    col=(col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14);\n    col*=1.0;\n    col = pow(col,vec3(1.0/2.2));\n    vec3 glowdir =lightDir;\n    vec3 glow = vec3(1.0,0.64,0)*0.2*pow(max(dot(raydir,glowdir),0.0),2.0);\n    col+=glow;\n    return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = cameraRender(fragCoord);\n}","name":"Image","description":"","type":"image"}]}