{"ver":"0.1","info":{"id":"XftcWN","date":"1730739514","viewed":143,"name":"Test: Bitonic pixel sorting","username":"Mitsync","description":"Implementation of bitonic merge sort. Buffer A preps the image including calculating the value to be sorted by, buffer B does the sorting using feedback. Sorting a 4k image takes 78 iterations of bitonic sort, so 78 frames.","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["pixel","sort","sorting","algorithm","merge","pixelsort","bitonic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just copies the output of buffer A (actual sorting) to the main image\n// Can't do the sorting in here directly because we can't read this output back\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define UPTHRESH 0.7\n#define LOWTHRESH 0.2\n\n// Find 'value' of a pixel used for sorting order within its span\nfloat val ( in vec4 col ) { return lum(col); }\n\n// Sample function that includes UV mapping (fit source vertically, tile horizontally)\nvec4 fetch( in vec2 coord ) {\n    vec2 uv = coord / iResolution.y;\n    vec2 target_uv = uv * vec2(iChannelResolution[1].y/iChannelResolution[1].x, 1.0);\n    //return col(target_uv);\n    return texture(iChannel1, target_uv);\n}\n\n// Generates the image that will be sorted\n// Pre-calculates the 'value' of each pixel in the original image \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Copy colour over first\n    fragColor.rgb = fetch(fragCoord).rgb;\n    \n    // Then loop to count what vertical span this pixel is in\n    float span = 0.;\n    float v;\n    float x = fragCoord.x;\n    for (float i = 0.; i < fragCoord.y; i++) {\n        v = val(fetch(vec2(x, i+0.5)));\n        // If value of this pixel is within band do NOT sort (by giving each pixel its own span)\n        if (LOWTHRESH < v && v < UPTHRESH) { span += 1.; }\n        // If value of this pixel is within band DO sort (by giving each pixel outside its own span)\n        //if (!(LOWTHRESH < v && v < UPTHRESH)) { span += 1.; }\n    }\n    \n    fragColor.w = val(fragColor) + span;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 col( in float y) { return vec4(y, y, y, 1.0); }\nvec4 col( in float u, in float v ) { return vec4(u, v, 0.0, 1.0); }\nvec4 col( in vec2 uv) { return vec4(uv, 0.0, 1.0); }\n\nfloat lum ( in vec3 col ) { return dot(col, vec3(0.299, 0.578, 0.114)); }\nfloat lum ( in vec4 col ) { return dot(col, vec4(0.299, 0.578, 0.114, 0.0)); }","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float triangle( in float n ) { return n*(n+1.)/2.; }\nfloat invtriangle( in float y ) { return sqrt(2.*y+0.25)-0.5; }\n\n// Sort\n// Inspired by https://poniesandlight.co.uk/reflect/bitonic_merge_sort/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    \n    float stage = float((iFrame%192)) - 64.;\n    if (stage < 0.) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord) % ivec2(iChannelResolution[1]), 0);\n        return;\n    }\n    \n    // Swap some directions based on if we're sorting X or Y right now\n    // 78 stages is what's needed for 4096 pixels\n    //bool y = stage >= 78.;\n    //if (y) { stage -= 78.; }\n    bool y = true;\n    \n    float index = y ? fragCoord.y : fragCoord.x;\n    \n    // Get the macrostage, pos in that macrostage and height\n    float exp_stage = invtriangle(stage);\n    float ms = floor(exp_stage);\n    float ms_f = fract(exp_stage);\n    float h = pow(2.0, (triangle(ms + 1.) - stage));\n    float block = floor(index / h);\n    float in_block = mod(index, h);\n    \n    float itc;\n    // If stage is exactly a triangle number do a flip\n    if (ms_f == 0.) {\n        itc = h - in_block - 1.;\n    }\n    // Otherwise do a disperse\n    else {\n        itc = mod((in_block + h/2.), h);\n    }\n    // Move to correct block\n    itc += block * h;\n    // If outside the input data don't do anything (the other end won't be attempted at all)\n    if (itc >= (y ? iResolution.y : iResolution.x)) { itc = index; }\n    \n    // Compare and swap current pixel and the one we just calculated\n    vec4 currCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 otherCol;\n    if (y) {otherCol = texelFetch(iChannel0, ivec2(fragCoord.x, int(itc)), 0);}\n    else   {otherCol = texelFetch(iChannel0, ivec2(int(itc), fragCoord.y), 0);}\n    bool swap = (index>itc) ? (currCol.w < otherCol.w) : (currCol.w > otherCol.w);\n    fragColor = swap ? otherCol : currCol;\n}","name":"Buffer B","description":"","type":"buffer"}]}