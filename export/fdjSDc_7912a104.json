{"ver":"0.1","info":{"id":"fdjSDc","date":"1621175998","viewed":57,"name":"Lisboa Tiles","username":"phreax","description":"Tiles inspired by tiled facades in Lisboa. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Made together with my friend doktormanhattan while staying in Lisboa in 2021\n*/\n\nfloat Tau = 6.28318530718;\n\n#define SIN(x) (sin(x)*.5 +.5)\n\nfloat pDomrep(inout float p, float c) {\n\tp += .5 * c;\n\tfloat i = floor(p/c);\n\tp = mod(p, c) - .5 * c;\n\treturn i;\n}\n\nvec2 pDomrep(inout vec2 p, vec2 c) {\n\tp += .5 * c;\n\tvec2 i = floor(p/c);\n\tp = mod(p, c) - .5 * c;\n\treturn i;\n}\n\nvec2 pDomrep(inout vec2 p, float cx, float cy) {\n\treturn pDomrep(p, vec2(cx, cy));\n}\n\nvec3 pDomrep(inout vec3 p, vec3 c) {\n\tp += .5 * c;\n\tvec3 i = floor(p/c);\n\tp = mod(p, c) - .5 * c;\n\treturn i;\n}\n\nvec3 pDomrep(inout vec3 p, float cx, float cy, float cz) {\n\treturn pDomrep(p, vec3(cx, cy, cz));\n}\n\nfloat pDomrepMirror(inout float p, float c) {\n\tfloat i = pDomrep(p, c);\n\tp *= mod(i, 2.) * 2. - 1.;\n\treturn i;\n}\n\nvec2 pDomrepMirror(inout vec2 p, vec2 c) {\n\tvec2 i = pDomrep(p, c);\n\tp *= mod(i, 2.) * 2. - 1.;\n\treturn i;\n}\n\nvec3 pDomrepMirror(inout vec3 p, vec3 c) {\n\tvec3 i = pDomrep(p, c);\n\tp *= mod(i, 2.) * 2. - 1.;\n\treturn i;\n}\n\nvec2 pDomrepGrid(inout vec2 p, vec2 c) {\n\tvec2 i = pDomrepMirror(p, c);\n\tp -= .5 * c;\n\tif (p.x > p.y) {\n\t\tp.xy = p.yx;\n\t}\n\treturn floor(.5 * i);\n}\n\nvec3 pDomrepGrid(inout vec3 p, vec3 c) {\n\tvec3 i = pDomrepMirror(p, c);\n\tp -= .5 * c;\n\tif (p.x < p.y) {\n\t\tif (p.y > p.z) {\n\t\t\tif (p.x < p.z) {\n\t\t\t\tp = p.xzy;\n\t\t\t} else {\n\t\t\t\tp = p.zxy;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (p.z < p.y) {\n\t\t\tp = p.zyx;\n\t\t} else {\n\t\t\tif (p.z < p.x) {\n\t\t\t\tp = p.yzx;\n\t\t\t} else {\n\t\t\t\tp = p.yxz;\n\t\t\t}\n\t\t}\n\t}\n\treturn floor(.5 * i);\n}\n\nvoid pTrans(inout float p, float d) {\n\tp -= d;\n}\n\nvoid pTrans(inout vec2 p, vec2 d) {\n\tp -= d;\n}\n\nvoid pTrans(inout vec2 p, float x, float y) {\n\tpTrans(p, vec2(x, y));\n}\n\nvoid pTrans(inout vec3 p, vec3 d) {\n\tp -= d;\n}\n\nvoid pTrans(inout vec3 p, float x, float y, float z) {\n\tpTrans(p, vec3(x, y, z));\n}\n\nvec2 unitVector(float phi) {\n\treturn vec2(cos(phi), sin(phi));\n}\n\nfloat pDomrepAngleWithAtan(inout vec2 p, float repetitions, float radius, float preCalcAtan) {\n\tfloat at = preCalcAtan;\n\tfloat cAngle = Tau / repetitions;\n\tfloat i = pDomrep(at, cAngle);\n\n    for(float k = 0.; k < 1.; k+=1.){\n        p = abs(p-0.2);\n        p -= 0.2;\n    }\n\tfloat r = length(p);\n\tp = r * unitVector(at);\n\n\tpTrans(p.x, radius);\n\treturn i;\n}\n\nfloat pDomrepAngle(inout vec2 p, float repetitions, float radius) {\n\treturn pDomrepAngleWithAtan(p, repetitions, radius, atan(p.y, p.x));\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// domrep from cell start to (inclusively) end\nfloat pDomrepInterval(inout float p, float c, float start, float end) {\n\tp += .5 * c;\n\tfloat i = floor(p/c);\n\tp = mod(p, c) - .5 * c;\n\n\tif (i > end) {\n\t\tp += c * (i - end);\n\t\ti = end;\n\t} else if (i < start) {\n\t\tp += c * (i - start);\n\t\ti = start;\n\t}\n\n\treturn i;\n}\n\n// domrep from cell start to (inclusively) end\nvec2 pDomrepInterval(inout vec2 p, vec2 c, vec2 start, vec2 end) {\n\tp += .5 * c;\n\tvec2 i = floor(p/c);\n\tp = mod(p, c) - .5 * c;\n\n\tif (i.x > end.x) {\n\t\tp.x += c.x * (i.x - end.x);\n\t\ti.x = end.x;\n\t} else if (i.x < start.x) {\n\t\tp.x += c.x * (i.x - start.x);\n\t\ti.x = start.x;\n\t}\n\n\tif (i.y > end.y) {\n\t\tp.y += c.y * (i.y - end.y);\n\t\ti.y = end.y;\n\t} else if (i.y < start.y) {\n\t\tp.y += c.y * (i.y - start.y);\n\t\ti.y = start.y;\n\t}\n\n\treturn i;\n}\n\n// domrep from cell start to (inclusively) end\nvec3 pDomrepInterval(inout vec3 p, vec3 c, vec3 start, vec3 end) {\n\tp += .5 * c;\n\tvec3 i = floor(p/c);\n\tp = mod(p, c) - .5 * c;\n\n\tif (i.x > end.x) {\n\t\tp.x += c.x * (i.x - end.x);\n\t\ti.x = end.x;\n\t} else if (i.x < start.x) {\n\t\tp.x += c.x * (i.x - start.x);\n\t\ti.x = start.x;\n\t}\n\n\tif (i.y > end.y) {\n\t\tp.y += c.y * (i.y - end.y);\n\t\ti.y = end.y;\n\t} else if (i.y < start.y) {\n\t\tp.y += c.y * (i.y - start.y);\n\t\ti.y = start.y;\n\t}\n\n\tif (i.z > end.z) {\n\t\tp.z += c.z * (i.z - end.z);\n\t\ti.z = end.z;\n\t} else if (i.z < start.z) {\n\t\tp.z += c.z * (i.z - start.z);\n\t\ti.z = start.z;\n\t}\n\n\treturn i;\n}\n\n// unions two objects and adds n columns within a radius of r\n// use only with orthogonal objects\nfloat opUnionColumns(float f1, float f2, float r, float n) {\n\t// SpeckrÃ¶llchen\n\tfloat f_min = min(f1, f2);\n\tif (f1 < 2.*r && f2 < 2.*r) {\n\t\tvec2 q = vec2(f1, f2);\n\t\t//float radius = sqrt(2.) * .5 * r / (n + sqrt(2.) - 1.);\n\t\t//q.x -= radius;\n\t\tfloat radius = sqrt(.5) * r / (n + sqrt(.5) - 1.);\n\t\tq.y -= r - radius;\n\t\t//pRot(q, -Tau / 8.);\n        q *= rot(Tau / 8.);\n\t\tpDomrepInterval(q.x, 2. * radius, 0., n-1.);\n\t\tfloat f_columns = length(q) - radius;\n\t\tf_columns = min(f_columns, q.y);\n\t\treturn min(f_columns, f_min);\n\t}\n\treturn f_min;\n}\n\nfloat curve(float t, float d) {\n    t /= d;\n    return mix(floor(t), floor(t)+1., pow(smoothstep(0., 1., fract(t)), 10.));\n}\n\n\nfloat coloredTiles(vec2 uv, float off, float rep) {\n\n    float tt = iTime + off;\n    float iAngle = pDomrepAngle(uv, rep, 0.3);\n    uv.y *= mod(iAngle, 2.) * 2. - 1.;\n\n    vec2 uvPlane = uv;\n       \n    uvPlane *= 2.;\n       \n    pDomrepMirror(uvPlane, vec2(0.6, 0.3));\n    uvPlane = rot(curve(tt, 1.)) * uvPlane; \n\n    \n    uvPlane -= vec2(.1, .05);\n\n    float distPlane = abs(abs(uvPlane.x)-.05) -.01;\n    \n    \n    float distPlane2 = abs(length(uvPlane) - .3*(1.+0.2*SIN(tt*6.)))-0.01;\n    \n    \n    float dist = opUnionColumns(distPlane, distPlane2, .1, 3.);\n    \n    dist = abs(dist) - 0.001;\n    \n      \n    float inOut = (smoothstep(0.0, 0.008, dist) + 0.8* pow(smoothstep(0.008, 0.03+0.05*SIN(tt*15.), dist), 1./2.2))/1.8;\n    \n    return inOut;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    uv -= 0.05;\n\n    pDomrepMirror(uv, vec2(1./2.));\n    \n    float tilesBlue = coloredTiles( uv, 0., 6.);\n    float tilesOrange = coloredTiles( uv, 2.5, 4.);\n    \n    vec3 blue =  vec3(0.122,0.494,0.820);\n    vec3 orange = vec3(0.996,0.655,0.063);\n    vec3 background = vec3(1.000,0.988,0.961);\n    vec3 col;\n    \n    col = mix(blue, background, tilesBlue) + mix(orange, background, tilesOrange) - 1.;\n    // col = pow(col, vec3(1.5))+.1;\n    // Output to screen\n    \n    vec2 pGrid = abs(uv);\n    float distGrid = min(pGrid.x, pGrid.y);\n    \n   // \n    col *= 0.5 + .5*sqrt(15.0*distGrid*(.9-distGrid));\n    col += 1.-smoothstep(0., 0.01, distGrid);\n \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}