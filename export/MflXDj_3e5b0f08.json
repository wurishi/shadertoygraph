{"ver":"0.1","info":{"id":"MflXDj","date":"1705759801","viewed":192,"name":"TRIOPTIMUM ","username":"chronos","description":"Please be patient, it takes a little while to get going!\nAnimation lasts about the duration of the song, roughly 4.5 mins / 270 secs.\nSee description in the Image tab! ","likes":12,"published":1,"flags":96,"usePreview":0,"tags":["grid","sound","retro","music","glitch","effects","cyberpunk","corruption","shock","system","hacker","trioptimum","systemshock","shodan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n        TRIOPTIMUM by chronos\n  \n      \n      Please be patient, it takes a little while to get going!\n      \n      To ensure that it syncs up better, please restart the shader immediately after the song starts.\n      \n      If the sound doesnt play, try refreshing, restarting or changing browser,\n      checking/disabling extensions or pressing pause/play on the soundcloud buffer.\n      On some browsers, like firefox, you may have to open a menu in the address bar\n      to give permission to the tab/site to autoplay sound.\n      The soundcloud buffer is in iChannel3 in buffer C.\n      \n      Inspired by the game System Shock.\n      \n      \n      Song: System Shock Intro Theme (Greg LoPiccolo Cover), by Single point postulate\n*/\n\n\nfloat geometric_mean(vec2 v) { return sqrt(v.x * v.y); }\nvec4 face(vec2 uv)\n{\n    vec3 color = vec3(0);\n\n    uv.x = 1.1 * abs(uv.x);\n    uv.y *= 0.9;\n    uv.y += 0.235;\n    \n    vec3 draw_color = vec3(1);\n    \n    float pix_size = 2. / iResolution.y;\n    float ps;\n    float alpha = 0.;\n    \n    mat2 R45 = mat2(1,1,-1,1) / sqrt(2.);\n    \n    float dist = length((R45 * uv) * vec2(2., 1.) - vec2(0.,0)) - 1.;\n    ps = pix_size*geometric_mean(vec2(2., 1.));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    // forehead\n    dist = length(uv * vec2(1.275, 2.2) - vec2(0.,1.2)) - 1.;\n    ps = pix_size*geometric_mean(vec2(1.275, 2.2));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    // jaw\n    dist = length(uv * vec2(2.5, 3.3) - vec2(0.,-1.1)) - 1.;\n    ps = pix_size*geometric_mean(vec2(3., 3.2));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    // outer jaw\n    dist = length((R45 * (uv- vec2(.4,-.25))) * vec2(6., 2.) ) - 1.;\n    ps = pix_size*geometric_mean(vec2(3., 3.2));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    // side of head / temple\n    dist = length((uv- vec2(.65,.35)) * vec2(6., 2.25) ) - 1.;\n    ps = pix_size*geometric_mean(vec2(6., 2.25));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    // top side of scalp\n    dist = length((transpose(R45) * (uv - vec2(.52, +.81))) * vec2(8., 2.9)) - 1.;\n    ps = pix_size*geometric_mean(vec2(8., 3.));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    // top head\n    dist = length((uv- vec2(0.,.95)) * vec2(2., 6.) ) - 1.;\n    ps = pix_size*geometric_mean(vec2(8., 3.));\n    alpha = max(alpha, smoothstep(ps, -ps, dist));\n    \n    color = mix(color, draw_color, alpha);\n    \n    return vec4(color, alpha);\n}\n\nvec4 head(vec2 uv)\n{\n    vec2 UV = uv;\n\n    vec3 color = vec3(0);\n\n    vec4 Face = face(.68*(UV-vec2(0., .24)));\n    \n    color += vec3(0., 4., 2.2)/255.*Face.rgb * (1.-length(UV*.65)) \n    * smoothstep(1.75, 0.25, dot(UV, vec2(1.,-1)))\n    * smoothstep(1.75, 0.25, dot(UV, vec2(-1.,-1)));\n\n\n///////////////////\n// EYES\n////////////////\n\n    float scale = 1.75;\n    float offset = 1.6 / scale;\n    \n    uv.x -= offset;\n    uv.y -= .3;\n    uv *= scale;\n    \n    uv.x += 1.6;\n    uv.x = sqrt(uv.x*uv.x + 0.0025);\n    uv.x -= 1.6;\n    uv.x *= -1.;\n    uv.x -=.5;\n    \n\n    float angle = 25. * (PI/180.);\n    float c = cos(angle), s = sin(angle);\n    mat2 R = mat2(c,s,-s,c);\n\n    vec2\n        p0  =R*vec2(-1,-1) * 0.55,\n        p1  =R*vec2(0.85,1) * 0.7, \n        p2  =R*vec2(0.1, 0.01),    // iris pos\n        p3  =p2-vec2(-0.05,-0.015);   // pupil pos\n\n    float \n        r0  =1.,\n        r1  =1.,\n        r2  =.33, // iris about half of size of visible eye whites\n        r3  = r2 * .34;  // pupil (0.2 to 0.7 times the size of iris. 0.34 from reference (1.7/5.))\n        \n\n    float d0 = length(p0 - uv) - r0;\n    float d1 = length(p1 - uv) - r1;\n    float d2 = length(p2 - uv) - r2;\n    float d3 = length(p3 - vec2(1.4,.55)*uv) - r3;\n    \n    float dist = max(d0,d1);\n    \n    vec3 iris = pow(vec3(0,115,0)/255., vec3(2.2));\n    vec3 whites = pow(vec3(0,83,7)/255., vec3(2.2));\n    vec3 pupil = vec3(0);\n    \n    color += 6.*whites / (4.+ 400. * max(dist, 0.0001));\n    \n    float ps = 2. / iResolution.y;\n    float alpha = smoothstep(ps, -ps, dist);\n    color = mix(color, \n    whites\n    , alpha\n    );\n    \n    alpha = min(alpha, smoothstep(ps, -ps, d2));\n    color = mix(color, \n        (.05+.95*smoothstep(0.,r2/4., -d2))\n        *\n        iris\n        , alpha);\n    \n    alpha = min(alpha, smoothstep(ps, -ps, d3));\n    color = mix(color, pupil, alpha);\n\n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix_size = 2. / iResolution.y;\n    vec2 UV = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = UV;\n    vec3 color = vec3(0);\n    \n    vec3 trioptimum_green0 = hex_to_linear(0x01AC12);\n    vec3 trioptimum_green1 = hex_to_linear(0x68FD79);\n    \n    vec2 image_uv = fragCoord.xy/iResolution.xy;\n    \n    float pixelation_t = smoothstep(79., 80., iTime);\n    vec2 pixelation_res =\n        iResolution.xy/(vec2(1200.,675.)/100.)\n        ;\n    vec2 pixelated_uv = round(pixelation_res * fragCoord.xy/iResolution.xy) / pixelation_res;\n    \n    image_uv = mix(pixelated_uv, image_uv, pixelation_t);\n    \n    // Block glitches\n    {\n        float block_res = 40.;\n        float time_res = 17.;\n        vec2 block_uv = round(block_res * UV) / block_res;\n        float t_quantized = floor(iTime * time_res) / time_res; // quantizes fractional part of seconds in steps\n        float t2 = floor(iTime * time_res * 1.5);\n        float block_glitch_t = fract(iTime/10.) * 10.;\n        float block_glitch_gate = (block_glitch_t < .4) ? 1. : 0.;\n        vec2 block_glitch_uv = image_uv;\n        \n        float glitch_area_size = 0.1;\n        \n        int cnt = 0;\n        float rnd0 = hash(vec3(t2,t2, ++cnt));\n        float rnd1 = hash(vec3(t2,t2, ++cnt));\n        \n        for(int i = 0;  i < 3; i++)\n        {\n            float rnd2 = hash(vec3(t_quantized,t_quantized, ++cnt));\n            float rnd3 = hash(vec3(t_quantized,t_quantized, ++cnt));\n\n            vec2 block_glitch_pos = vec2(rnd0, rnd1);\n            vec2 block_glitch_pos0 = block_glitch_pos + glitch_area_size * (-1.+2.*fract(block_glitch_pos + vec2(1234.72, 256.38) * rnd2));\n            vec2 block_glitch_pos1 = block_glitch_pos + glitch_area_size * (-1.+2.*fract(block_glitch_pos + vec2(1234.72, 256.38) * rnd3));\n            if(distance(block_uv, block_glitch_pos0) <= 1./block_res)\n            {\n                block_glitch_uv = block_glitch_pos1;\n            }\n            if(distance(block_uv, block_glitch_pos1) <= 1./block_res)\n            {\n                block_glitch_uv = block_glitch_pos0;\n            }\n        }\n        image_uv = mix(image_uv, block_glitch_uv, block_glitch_gate);\n    }\n    \n    float distortion_t = iTime * 0.5;\n    vec2 uv_distortion = vec2(1,0) * \n        3. * sin(UV.y * PI - iTime * PI * 2. + 3.*sin(iTime * 10.))\n        *\n        pow(\n            max(\n            (\n                sin(0.1+sin(20.* PI * (UV.y + distortion_t)))\n                +\n                1.15*cos(39. * (UV.y + 0.235 * distortion_t))\n                +\n                1.425*sin(cos(14. * (UV.y + 1.5 * distortion_t)))\n                *\n                1.425*cos(sin(11. * (UV.y + 4.9 * PI * distortion_t)))\n                )\n                /5.\n            ,\n                0.\n            )\n        ,\n            19.\n        )\n        ;\n        \n    float persistent_distortion_t = UV.y + 1.5*(mod(iTime+10., 20.)-1.);\n    float persistent_distortion = \n        gaussian(35.*(persistent_distortion_t)) * sin(70.*persistent_distortion_t) * cos(UV.y * PI * .5);\n    \n    uv_distortion += 0.01*persistent_distortion;\n    \n    image_uv += uv_distortion;\n    \n    color = texture(iChannel0, image_uv).rgb;\n    \n    // wireframe planet\n    {\n        vec2 planet_uv = vec2(3.6,2.)*round(pixelation_res * UV / vec2(3.6,2.)) / pixelation_res;\n        planet_uv = mix(planet_uv, UV, pixelation_t);\n        float pix_size = mix(dot(1./pixelation_res, vec2(0.5)), 2. / iResolution.y, pixelation_t);\n        \n        float alpha = planet_alpha(planet_uv, pix_size, iTime);\n        vec3 planetcolor = vec3(1./255.,1.,0.075);\n        color = mix(color, planetcolor, .25 * alpha);\n    }\n    \n    // Bio monitor\n    {\n        vec2 monitor_uv = 3.*round(pixelation_res * UV / 3.) / pixelation_res;\n        \n        monitor_uv = mix(monitor_uv, UV, pixelation_t);\n        \n        float monitor_t = pow(min(iTime / 80., 1.), 1./1.8);\n        monitor_uv -= vec2(-1.15,-.725) * monitor_t;\n        monitor_uv *= mix(1., 1.25, monitor_t);\n        \n        float pix_size = mix(dot(3./pixelation_res, vec2(0.5)), 2. / iResolution.y, pixelation_t);\n        vec4 monitor = bio_monitor(monitor_uv, pix_size, iTime);\n        \n        color += monitor.rgb;\n    }\n    \n    \n    // Noise\n    {\n        vec2 noise_uv = fragCoord.xy/iResolution.xy;\n        noise_uv = mix(pixelated_uv, noise_uv, pixelation_t);\n        float line_noise = texture(iChannel1, uv_distortion + vec2(0.01, 1) * .5 * noise_uv).r;\n        float dot_noise0 = texture(iChannel1, uv_distortion + .25 * noise_uv).r;\n        float dot_noise1 = texture(iChannel1, uv_distortion + .05 * noise_uv + 0.25).r;\n\n        vec3 noise_color = vec3(0);\n        float noise_strength = .5;\n        \n        noise_color += 0.10 * dot_noise0 * trioptimum_green0;\n        noise_color += 1.00 * dot_noise0 * dot_noise1 * trioptimum_green1;\n        noise_color += 0.05 * line_noise * trioptimum_green0;\n        color += noise_strength * noise_color;\n    }\n    \n    // Vignette\n    {\n        vec2 vignette_uv = fragCoord.xy / iResolution.xy;\n        vignette_uv *= (1.-vignette_uv) * 4.;\n\n        float vignette = vignette_uv.y * vignette_uv.x;\n        vignette = 1.-pow(1.-vignette, 16.);\n        vignette = mix(vignette, 1., 0.15);\n        color *= vec3(vignette);\n    }\n    \n    vec4 bufC = texture(iChannel2, fragCoord.xy / iResolution.xy);\n    float flash_detection = bufC.a;\n    vec3 flash_color = .5 * trioptimum_green1 * flash_detection\n    * \n    (1.-length(fragCoord.xy / iResolution.xy - .5))\n    * (.8 + .2*(texture(iChannel1, fragCoord.xy / iResolution.xy).r) ) // throw in some noise for good measure\n    ;\n    color += flash_color;\n    \n    // Circuit flash & pulse\n    vec4 bufD = texture(iChannel3, image_uv);\n    float pulse_pos = length(UV) - mod(iTime-PI/24., (2. * PI)/3.)*2.;\n    float grid_pulse = pow(smoothstep(0.,-0.005,pulse_pos)*gaussian(pulse_pos, 0.75), 9.);\n    vec3 pulse_color = mix(trioptimum_green1, vec3(1), pow(smoothstep(0.0, 1.05, grid_pulse), 20.));\n    float circuit_flash_alpha = flash_detection * bufD.a * smoothstep(0.5, 3., length(2. * fragCoord.xy/iResolution.xy-1.) );\n    vec3 circuit_flash_color = trioptimum_green1 + grid_pulse * pulse_color;\n    color = mix(color, circuit_flash_color, circuit_flash_alpha);\n        \n    // Someone is watching you...\n    {\n        vec2 shodan_uv = vec2(3.6,2.)*round(pixelation_res * UV / vec2(3.6,2.)) / pixelation_res;\n        shodan_uv = mix(shodan_uv, UV, pixelation_t);\n        float shodan_t = mod(iTime, 20.);\n        float shodan_gate = gaussian(shodan_t-7., 0.5); \n        vec4 shodan = head(shodan_uv) * shodan_gate;\n        color += 0.0125 * shodan.rgb;\n    }\n    \n    // Final tonemapping, sRGB encoding and dithering\n    float bluenoise_dither = bufC.b;\n    float tonemap_crunch = 2.;\n    color = pow(tanh(pow(color, vec3(tonemap_crunch))), vec3(1./tonemap_crunch));\n    color = sRGBencode(color);\n    color += bluenoise_dither;\n    fragColor = vec4(color, 1);\n    \n}\n\n\n\n\n// Copyright 2024\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train AI / machine-learning systems on it.\n// you can link to it, through an URL, proper attribution and unmodified screenshot.\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float percent = .01;\n\nconst float line_size = 3. * percent;\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\n#define DEBUG 0\n\nconst float END_OF_SONG = 274.;\n\nmat2 rot(float rad)\n{\n    float c = cos(rad), s = sin(rad);\n    return mat2(c,-s,s,c);\n}\n\nconst float PI = 3.14159265;\n\nvec3 hex_to_linear(int hex)\n{\n    vec3 result = vec3(hex>>24 & 0xFF, hex>>8 & 0xFF, hex & 0xFF);\n    return sRGBdecode(result/255.);\n}\n\nvec2 get_normal(vec2 a, vec2 b)\n{\n    return normalize((b-a).yx * vec2(-1,1));\n}\n\nconst float debug_alpha = 0.25;\n\nfloat sixty_degrees_in_rad = PI/3.;\n\nfloat gaussian(float x) { return exp(-x*x); }\nfloat gaussian(float x, float std) { return gaussian(x/std); }\nfloat gaussian(float x, float std, float mean) { float z = (x-mean)/std; return gaussian(z); }\n\nfloat gaussian(vec2 v) { return exp(-dot(v,v)); }\n\n// Just yanked this from one of my previous shaders.\n// Idk how I came up with this. I think it may just be repeated xorshift star or PCG hash that I repeated three times,\n// to incorporate all the channels, where the bits are just shoved into the mantissa of a float at the end.\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\n// read in order: \"project p onto n\", \"project p onto segment from a to b\", etc.\nfloat scalarproject(vec2 p, vec2 v)         { return dot(p, v) / dot(v,v);       }\nfloat scalarproject(vec2 p, vec2 a, vec2 b) { return scalarproject(p-a, b-a);    }\nvec2 lineproject(vec2 p, vec2 a, vec2 b)    { return scalarproject(p, a, b) * (b-a) + a; }\nvec2 linereject(vec2 p, vec2 a, vec2 b)     { return p - lineproject(p, a, b);   }\nvec2 segproject(vec2 p, vec2 a, vec2 b)     { return clamp(scalarproject(p, a, b), 0., 1.) * (b-a) + a; }\nvec2 segreject(vec2 p, vec2 a, vec2 b)      { return p-segproject(p, a, b);      }\nfloat segdist(vec2 p, vec2 a, vec2 b)       { return length(segreject(p, a, b)); }\nfloat linedist(vec2 p, vec2 a, vec2 n)      { return abs(scalarproject(p-a, n)); }\n\nfloat circledist(vec2 p, vec2 center, float radius) { return distance(p, center) - radius; }\n\nfloat circuitboard_dist(vec2 UV, vec2 resolution)\n{   \n    vec2 num_cells = vec2(4, 8);\n    vec2 cells = floor(UV * num_cells) / num_cells;\n    \n    vec2 cell_idx = floor(UV * num_cells);\n    vec2 cell_uv  = fract(UV * num_cells);\n    \n    vec2 cell_size = vec2(resolution.xy / num_cells);\n    \n    float radius = 1.5 * percent;\n    \n    float thickness = radius / 4.;\n    \n    int i = 0;\n    float rnd0 = hash(vec3(cell_idx, ++i));\n    \n    // horizontal line through cell center\n    \n    vec2 cell_center = ((cell_idx * cell_size) + cell_size*.5 ) / resolution.xy;\n    vec2 cell_left   = cell_center + cell_size * .5*vec2(-1,  0) / resolution.xy;\n    vec2 cell_right  = cell_center + cell_size * .5*vec2( 1,  0) / resolution.xy;\n    vec2 cell_bottom = cell_center + cell_size * .5*vec2( 0, -1) / resolution.xy;\n    vec2 cell_top     = cell_center + cell_size * .5*vec2( 0,  1) / resolution.xy;\n    \n    float rnd1 = hash(vec3(cell_idx, ++i));\n    if(rnd1 < .5) // horizontal flip\n    {\n        vec2 tmp = cell_left;\n        cell_left = cell_right;\n        cell_right = tmp;\n    }\n    \n    float rnd2 = hash(vec3(cell_idx, ++i));\n    if(rnd2 < .5) // vertical flip\n    {\n        vec2 tmp = cell_top;\n        cell_top = cell_bottom;\n        cell_bottom = tmp;\n    }\n    \n    float rnd3 = hash(vec3(cell_idx, ++i));\n    if(rnd3 < .2) // rot 90\n    {\n        vec2 tmp = cell_top;\n        cell_top = cell_right;\n        cell_right = cell_bottom;\n        cell_bottom = cell_left;\n        cell_left = tmp;\n    }\n        \n    vec2 cell_center_left    = mix(cell_center, cell_left, .66);\n    vec2 cell_center_right   = mix(cell_center, cell_right, .66);\n    vec2 cell_center_bottom  = mix(cell_center, cell_bottom, .66);\n    vec2 cell_center_top     = mix(cell_center, cell_top, .66);\n    \n    float dist = 0.;\n    float mindist = 9e9;\n    \n    dist = segdist(UV, cell_left, cell_center_left)-thickness;\n    mindist = min(dist, mindist);\n        \n    dist = segdist(UV, cell_right, cell_center_right)-thickness;\n    mindist = min(dist, mindist);\n    \n    dist = segdist(UV, cell_top, cell_center_top)-thickness;\n    mindist = min(dist, mindist);\n\n    dist = segdist(UV, cell_bottom, cell_center_bottom)-thickness;\n    mindist = min(dist, mindist);\n    \n    if(rnd0 < 0.5)\n    {\n        float dist = linedist(UV, cell_center, get_normal(cell_left, cell_right))-thickness;\n        mindist = min(dist, mindist);\n        \n        vec2 circle_pos0 = cell_center_bottom;\n        vec2 circle_pos1 = cell_center_top;\n        \n        dist = circledist(UV, circle_pos0, radius);\n        mindist = min(dist, mindist);\n        \n        dist = circledist(UV, circle_pos1, radius);\n        mindist = min(dist, mindist);\n    }\n    else\n    {\n        float dist = segdist(UV, cell_center_right, cell_center_bottom)-thickness;\n        mindist = min(dist, mindist);\n\n        dist = segdist(UV, cell_center_top, cell_center_left)-thickness;\n        mindist = min(dist, mindist);\n    }\n    return mindist;\n}\n\nfloat circuitboard_alpha(vec2 UV, float pix_size, vec2 resolution)\n{\n    float ps = pix_size;\n    float dist = circuitboard_dist(UV, resolution);\n    float alpha = smoothstep(1.5 * ps, 0., dist);\n    return alpha;\n}\n\nvec3 rot(vec3 p, vec3 ax, float angle)\n{\n    ax = normalize(ax);\n    vec3 proj = dot(ax, p) * ax;\n    vec3 rejection = p-proj;\n    float c = cos(angle), s = sin(angle);\n    vec3 normal = cross(ax, p);\n    \n    return proj + normal * s + rejection * c;\n}\n\nvec2 perspective(vec3 p) \n{ \n    float focal = 8.;\n    return focal * p.xy / (focal + p.z);    \n}\n\nfloat planet_alpha(vec2 uv, float pix_size, float time)\n{\n    float mindist = 9e9;\n    \n    vec3 rot_axis = vec3(-1.,0.,1.);\n    float rot_angle = radians(45.);\n    \n    vec3 translation = vec3(min(1.5 * time, 80.)/4.) * vec3(-.19, 0.08,-.75);\n    \n    int subdivs = 12;\n    \n    for(int i = 0; i < subdivs; i++)\n    {\n        float angle = 2. * PI * float(i)/float(subdivs);\n        float c = cos(angle), s = sin(angle);\n        vec3 a  = vec3(c,s, 0.);\n\n        angle = 2. *  PI * float(i+1)/float(subdivs);\n        c = cos(angle); s = sin(angle);\n        vec3 b  = vec3(c,s, 0.);\n            \n        for(int j = 0; j < subdivs/2; j++)\n        {\n            float angle2 = 2. *  PI * float(j)/float(subdivs) - time;\n            float c2 = cos(angle2), s2 = sin(angle2);\n            mat2 R = mat2(c2, s2, -s2, c2);\n            \n            vec3 a2 = a; a2.xz = R * a.xz;\n            vec3 b2 = b; b2.xz = R * b.xz;\n            \n            vec2 p0 = perspective(rot(a2, rot_axis, rot_angle) - translation);\n            vec2 p1 = perspective(rot(b2, rot_axis, rot_angle) - translation);\n            float d = segdist(uv, p0, p1);\n            mindist = min(mindist, d);\n            \n            angle2 = 2.* PI * float(j+1)/float(subdivs) - time;\n            c2 = cos(angle2); s2 = sin(angle2);\n            R = mat2(c2, s2, -s2, c2);\n            \n            vec3 a3 = a; a3.xz = R * a.xz;\n            vec3 b3 = b; b3.xz = R * b.xz;\n            \n            vec2 p2 = perspective(rot(a3, rot_axis, rot_angle)-translation);\n            d = segdist(uv, p0, p2);\n            mindist = min(mindist, d);\n        }\n    }\n\n    const float percent = 0.01;\n    float linethickness = pix_size * .75;\n    float alpha = smoothstep(pix_size + linethickness/2., linethickness/2., mindist);\n    \n    float alpha_reduction_t = min(1.5 * time, 80.)/80.;\n    alpha = mix(alpha, alpha*0.5, alpha_reduction_t);\n    \n    return alpha;\n}\n\nvec3 bio_monitor_grid(vec3 color, vec2 uv, float subdivs, float pix_size)\n{\n    pix_size *= subdivs;\n    vec2 f = fract(uv * subdivs); // centered on zero, linear from -0.5 to 0.5\n    f = min(f, 1.-f);\n    float s = min(f.x, f.y);\n    \n    float linethickness = .5 * percent;\n    \n    float alpha = debug_alpha * smoothstep(pix_size + linethickness/2., linethickness/2., s);\n    \n    return mix(color, vec3(1), alpha);\n}\n\nvec4 bio_monitor(vec2 uv, float pix_size, float Time)\n{\n    vec3 color = vec3(0);\n    \n    vec3 linecolor = vec3(1./255.,1.,0.075);\n    vec3 dotcolor = vec3(1./255.,1.,0.075);\n    \n    float mask = gaussian(length(uv / vec2(.8, .5)), 1.);\n    \n    color = mask * 0.1 * linecolor * bio_monitor_grid(color, uv, 10., pix_size);\n    \n    float mindist = 9e9;\n    \n    vec2 points[13] = vec2[13]\n    (\n        vec2( -2.0,  0.0),\n        vec2( 2.5,  0.0),\n        vec2( 4.5,  1.0),\n        vec2( 6.0,  0.0),\n        vec2( 7.7,  0.0),\n        vec2( 8.3, -1.4),\n        vec2( 9.0,  9.0),\n        vec2( 9.6, -2.7),\n        vec2(10.0, 0.),\n        vec2(12.8, 0.),\n        vec2(15.0, 1.5),\n        vec2(16.0, 0.),\n        vec2(20.0, 0.)\n    );\n    \n    for(int i = 1; i < 13; i+=1)\n    {\n        vec2 a = points[i-1]; \n        vec2 b = points[i-0];\n        \n        a /= 18.;\n        b /= 18.;\n        \n        a.x = 2. * (a.x) - 1.;\n        b.x = 2. * (b.x) - 1.;\n        \n        mindist = min(mindist, segdist(uv, a, b));\n    }\n        \n    float linethickness = .75 * percent;\n    float alpha = smoothstep(pix_size + linethickness/2., linethickness/2., mindist);\n    \n    float time = Time * .91+0.01;\n    \n    float pulse_pos  = mod(1.6 + uv.x - time, 1.6)-1.6;\n    float grid_pulse = smoothstep(-0.1, -.15,pulse_pos) * gaussian(pulse_pos, .5);\n\n    vec3 pulse_color = mix(linecolor, vec3(1), 0.5*pow(smoothstep(.5,0.16, abs(pulse_pos)), 20.));\n    \n    color = mix(color, pulse_color, alpha * grid_pulse * mask);\n    \n    vec2 dotpos0 = vec2(mod(time-1.6-0.1,3.2)-1.6, 0.);\n    vec2 dotpos1 = vec2(mod(time    -0.1,3.2)-1.6, 0.);\n    \n    for(int i = 1; i < 13; i+=1)\n    {\n        vec2 a = points[i-1]; \n        vec2 b = points[i-0];\n        \n        a /= 18.;\n        b /= 18.;\n        \n        a.x = 2. * (a.x) - 1.;\n        b.x = 2. * (b.x) - 1.;\n        \n        if(dotpos0.x >= a.x && dotpos0.x < b.x)\n        {\n            dotpos0.y = mix(a.y, b.y, (dotpos0.x - a.x) / (b.x-a.x));\n        }\n        if(dotpos1.x >= a.x && dotpos1.x < b.x)\n        {\n            dotpos1.y = mix(a.y, b.y, (dotpos1.x - a.x) / (b.x-a.x));\n        }\n    }\n    \n    float dot_radius = 2. * percent;\n    float dotdist = length(uv - dotpos0);\n    \n    dotcolor = mix(vec3(1), dotcolor, 0.5*smoothstep(0., 1., 3.*dotdist));\n    float dotalpha =  gaussian(uv.x, 1.)/(12. + 400.* dotdist);\n    color += dotcolor * dotalpha * mask;\n        \n    dotdist = length(uv - dotpos1);\n    \n    dotcolor = mix(vec3(1), dotcolor, 0.5*smoothstep(0., 1., 3.*dotdist));\n    dotalpha =  gaussian(uv.x, 1.)/(12. + 400.* dotdist);\n    color += dotcolor * dotalpha * mask;\n    \n    return vec4(color, alpha);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec3 debug_line(vec3 color, vec2 a, vec2 b, vec2 uv)\n{\n    float pix_size = 2. / iResolution.y;\n    vec2 n = get_normal(a,b);\n    return mix(color, vec3(1), debug_alpha * smoothstep(pix_size, .25*pix_size,  abs(dot(get_normal(a,b), (uv - a)))));\n}\n\nvec3 debug_grid(vec3 color, vec2 uv, float subdivs)\n{\n    float pix_size = subdivs * 2. / iResolution.y;\n    vec2 f = fract(uv * subdivs); // centered on zero, linear from -0.5 to 0.5\n    f = min(f, 1.-f);\n    float s = min(f.x, f.y);\n    float alpha = debug_alpha * smoothstep(pix_size, .5*pix_size, s);\n    return mix(color, vec3(1), alpha);\n}\n\nvec3 debug_point(vec3 color, vec2 p, vec2 uv)\n{\n    float pix_size = 2. / iResolution.y;\n    float point_size = 4. * pix_size;\n    return mix(color, vec3(1), debug_alpha * smoothstep(point_size + pix_size, point_size, length(uv - p)));\n}\n\nfloat line(vec2 uv, vec2 p, vec2 n)\n{\n    float pix_size = 2. / iResolution.y;\n    float d = dot(uv-p, normalize(n));\n    float s = smoothstep(line_size+pix_size, line_size-pix_size, abs(d));\n    return s;\n}\n\nfloat halfspace(vec2 uv, vec2 p, vec2 n)\n{\n    float pix_size = 2. / iResolution.y;\n    float d = dot(uv-p, normalize(n));\n    float s = smoothstep(-pix_size, pix_size, d);\n    return s;\n}\n\nvec4 particle_storm(vec2 uv, float speed, float transition_time_offset, float twist)\n{\n    float angle = (atan(uv.y, uv.x)+PI)/(2. * PI);\n    float radius = length(uv);\n    \n    float time_offset = (speed +1.) * transition_time_offset;\n    \n    vec2 tunnel_uv = vec2(angle, -0.2 / radius - 0.25 * (speed * iTime - time_offset));\n    \n    tunnel_uv.x = fract(tunnel_uv.x + .17 / (1e-6 + radius) * twist);\n    \n    float lane_count = mix(30., 15., twist);\n    float lane_index = floor(tunnel_uv.x * lane_count);\n    \n    vec2 lane_uv = fract(tunnel_uv * vec2(lane_count, 1.));\n    \n    vec4 noise = texelFetch(iChannel0, ivec2(lane_index, 0), 0);\n    \n    float lane_offset = noise.r;\n    \n    lane_uv.y -= (speed * iTime - time_offset ) * (1.5 + 0.5 * (2. * noise.g - 1.));\n    \n    lane_uv.y = fract(lane_uv.y + lane_offset);\n    \n    float lane_stretch = 1. + 0.25 * noise.b;\n    \n    lane_uv.y *= lane_stretch;\n    \n    float g = gaussian(4.*PI * (lane_uv-0.5));\n    \n    vec3 particle_color = vec3(0.01, 0.78, 0.1);\n    \n    particle_color = mix(particle_color, mix(vec3(0.01, 0.95, 0.2),vec3(1),0.75), pow(g, 6.));\n    \n    float particles = g * mix(smoothstep(0.55, 0.5, lane_uv.y), 1., twist);\n    \n    float alpha = radius * radius * particles;\n        \n    return vec4(particle_color * alpha, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix_size = 2. / iResolution.y;\n    vec2 UV = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = UV;\n    vec3 color = vec3(0);\n\n    \n    vec3 trioptimum_green0 = hex_to_linear(0x01AC12);\n    vec3 trioptimum_green1 = hex_to_linear(0x68FD79);\n\n    // Unscientific color adjustment :)\n    trioptimum_green0 = pow(trioptimum_green0, vec3(1.9));\n    trioptimum_green1 = pow(trioptimum_green1, vec3(1.9));\n\n    float pulse_time = max(0., sin(iTime * 3.));\n\n//////////\n    // GRID\n    // Animate ascent\n    {\n        uv.y +=2.;\n        uv.y -= 2. * min(iTime/80., 1.);\n        float depth = abs(1. - uv.y * 5.);\n        float speed  = 1./7.;\n        \n        \n            float particle_t = mod(iTime, END_OF_SONG);\n            float fadeout = smoothstep(226., 224., particle_t);\n            float storm_gate0 = smoothstep(166., 167., particle_t);\n            speed *= mix(1., 1.5, storm_gate0 * fadeout);\n        \n        \n        vec3 grid_color = mix(trioptimum_green0, trioptimum_green1, 0.2);\n        \n        vec2 grid_uv = vec2(.2, 1.)*uv/depth;\n        float grid_mask = smoothstep(.1, -.9, uv.y);\n        float grid_alpha = debug_grid(color, (grid_uv + vec2(0., speed * iTime - speed * 225.)), 30.).r;\n        \n        float pulse_pos = length(grid_uv-vec2(0.,-0.165)) - mod(iTime-PI/24., (2. * PI)/3.)/3.;\n        float grid_pulse = pow(smoothstep(0.,-0.005,pulse_pos)*gaussian(pulse_pos, 0.075), 9.);\n        \n        \n        grid_alpha = debug_grid(color, grid_pulse*0.01 + (grid_uv + vec2(0., speed * iTime)), 30.).r;\n        color = mix(color, grid_color, grid_alpha * grid_mask);\n        \n        color += mix(trioptimum_green1, vec3(1), 0.33) * 5. * grid_pulse * grid_mask * (0.975*grid_alpha+0.025);\n    }\n    \n    {\n    \n        // layered noise\n        {\n            float noise = 0.;\n\n            vec2 storm_uv = fragCoord.xy / iResolution.xy;\n            \n            storm_uv.y -=2.;\n            storm_uv.y += 2. * min(iTime/80., 1.);\n            \n            float mask = \n                smoothstep(0.5, 1.,length(storm_uv - vec2(0.5, 0.)))\n                *smoothstep(0.2, 0.5, storm_uv.y)\n                ;\n            float distortion = mix(1., .5, storm_uv.y);\n            vec2 distorted_uv = storm_uv;\n            distorted_uv.x -= 0.5;\n            distorted_uv.x *= distortion;\n            distorted_uv.x += 0.5;\n            \n            float layers = 9.;\n            for(float i = layers; i >= 1.; i--)\n            {\n                float f = texture(iChannel1, pow(.5,i) + pow(.5,i)*distorted_uv).a;\n                noise += (2. * f - 1.) * pow(.5,layers-i);\n            }\n            noise = abs(noise);\n            noise = pow(max(1.-tanh(noise), 0.),25.) + .1*pow(max(1.-tanh(.2*noise), 0.),10.);\n            \n            float storm_alpha = noise * mask;\n            vec3 storm_color = mix(mix(trioptimum_green0, trioptimum_green1, noise), vec3(1), noise);\n            storm_color = pow(storm_color, vec3(2.2));\n            \n            #if 0\n            color = mix(color, storm_color, storm_alpha);\n            #else\n            color += 2. * storm_color * pow(storm_alpha, 1.5);\n            #endif\n            \n        }\n    }\n///////////\n// Laser storm\n///////////\n    \n    {\n        vec2 particlestorm_uv = UV;\n        \n        particlestorm_uv.y -= 0.25;\n        \n        float particle_t = mod(iTime, END_OF_SONG);\n        \n        float fadeout = smoothstep(230., 220., particle_t);\n        \n        float storm_gate2 = smoothstep(79., 80., particle_t);\n        float storm_gate1 = smoothstep(105., 106., particle_t);\n        float storm_gate0 = smoothstep(166., 167., particle_t);\n        \n        float particle_speed = mix(1., 1.5, storm_gate0);\n                \n        float twist = storm_gate0 * smoothstep(196.5, 195.5, particle_t);\n        \n        vec2 particlestorm_uv0 = particlestorm_uv;\n        vec2 particlestorm_uv1 = .5*particlestorm_uv.yx * vec2(-1., 1.);\n        vec2 particlestorm_uv2 = .25*particlestorm_uv*vec2(cos(PI + PI*storm_gate0),1);\n        \n        vec4 particles = \n            fadeout * storm_gate0 * particle_storm(particlestorm_uv0, particle_speed, 167., twist)\n            +\n            fadeout * storm_gate1 * particle_storm(particlestorm_uv1, particle_speed, 167., twist)\n            +\n            fadeout * storm_gate2 * particle_storm(particlestorm_uv2, particle_speed, 167., twist)\n            ;\n        \n        color += particles.rgb * mix(0.45, 0.55, storm_gate0);\n    }\n\n \n ///////////\n // TRIOPTIMUM LOGO\n //////////////\n    vec3 trioptimum_green = mix(trioptimum_green0, trioptimum_green1, pulse_time);\n\n    vec3 linecolor = trioptimum_green;\n        \n    uv = UV;\n   \n    // Animate descent\n    uv.y += 2. * min(iTime/80., 1.) - 2.;\n    \n    vec2 rot_anim = vec2(cos(iTime), 1.);\n    \n    uv /= rot_anim;\n    \n    // Perspective\n    {\n        float focal = 0.5;\n        float depth = 0.8 - focal * uv.x * sin(iTime);\n        uv /= depth;\n    }\n    /////////\n    \n    \n    float scale = 1./4.;\n    float len = sqrt(3.) * scale; // length of short sides\n    float ratio = 3.; // factor of how much longer the long sides are than the short sides\n    \n    // compute vertical midpoint\n    float halfheight = \n    (\n        sqrt(pow(ratio * len, 2.) - pow(ratio * len / 2., 2.))\n        +\n        sqrt(pow(len, 2.) - pow(len / 2., 2.))\n    ) / 2.;\n    \n    \n    // Init helpers\n    vec2 dir = vec2(1,0);\n    float c = cos(PI/3.), s = sin(PI/3.);\n    mat2 R = mat2(c, s, -s, c);\n    \n    // start at a point to be the bottom left corner\n    vec2 q0 = vec2(-len/2., - halfheight);\n    \n    vec2 prev = q0;\n    vec2 next = prev;\n    \n    float alpha_outer = 1.;\n    float alpha_inner = 1.;\n    \n    float alpha_center = 1.;\n    \n    float thickness = 0.25 * scale;\n    \n    \n    vec2 tricenter =  vec2(0);\n    for(int i = 0; i < 6; i++)\n    {\n        // go forward\n        next = prev + dir * len * ( (i&1)>0 ? ratio : 1.);\n        \n        // rotate 60 degrees\n        dir = R * dir;\n                \n        vec2 n = get_normal(prev, next);\n        \n        alpha_outer *= halfspace(uv, prev - thickness * n, n);\n        alpha_inner *= halfspace(uv, prev + thickness * n, n);\n        \n        tricenter += prev;\n        \n        prev = next;\n    }\n    \n    float alpha = alpha_outer - alpha_inner;\n    color = mix(color, linecolor, alpha);\n    \n    \n    tricenter /= 6.;\n    for(int i = 0; i < 6; i++)\n    {\n        // go forward\n        next = prev + dir * len * ( (i&1)>0 ? ratio : 1.);\n        \n        // rotate 60 degrees\n        dir = R * dir;\n        \n        vec2 n = get_normal(prev, next);\n        \n        float size = 3.9;\n        vec2 center_flipped = prev - 2.525 * tricenter;\n        center_flipped *= -1.;\n        center_flipped += 2.525 * tricenter;\n        center_flipped *= 1./size;\n        alpha_center *= halfspace(uv, center_flipped, -n);\n        \n        prev = next;\n    }\n    color = mix(color, linecolor, alpha_center);\n    \n    float alpha_bars = 0.;\n    float bar_scale = 1.;\n    mat2 R2 = R * R;\n    for(int i = 0; i < 6; i++)\n    {\n        // go forward\n        next = prev + dir * len * ( (i&1)>0 ? ratio : 1.);\n        \n        // rotate 60 degrees\n        dir = R * dir;\n        \n        vec2 n = get_normal(prev, next);\n        \n        \n        if( (i&1) > 0)\n            alpha_bars += \n                (\n                halfspace(uv, prev + bar_scale * n * thickness * 1.5, n)\n                -\n                halfspace(uv, prev + bar_scale * n * thickness * 2.5, n)\n                +\n                halfspace(uv, prev + bar_scale * n * thickness * 3., n)\n                -\n                halfspace(uv, prev + bar_scale * n * thickness * 4., n)\n                +\n                halfspace(uv, prev + bar_scale * n * thickness * 4.5, n)\n                -\n                halfspace(uv, prev + bar_scale * n * thickness * 5.5, n)\n                )\n                *  halfspace(uv, prev + thickness * transpose(R2) * n , transpose(R2) * n)\n                *  halfspace(uv, next + thickness * R2 * n , R2 * n)\n                ;\n                \n        prev = next;\n    }\n    color = mix(color, linecolor, alpha_bars);\n        \n    // Output in linear space\n    fragColor = vec4(color, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix_size = 2. / iResolution.y;\n    vec2 UV = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = UV;\n    vec3 color = vec3(0);\n    float noise = hash(vec3(uv, iFrame));\n    \n    color.r += pow(noise, 100.);\n    color.g += noise;\n    color.b += pow(noise, 1.175);\n    \n    float noise2 = dot(color, vec3(1, .01, 0.9));\n    \n    float exp_falloff = (iFrame < 1) ? noise2 : mix( texelFetch(iChannel0, ivec2(fragCoord.xy), 0).a, noise2, 0.06);\n    fragColor = vec4(color, exp_falloff);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldd3Rs","filepath":"https://soundcloud.com/user-772201973/system-shock-intro-theme-greg-lopiccolo-cover","previewfilepath":"https://soundcloud.com/user-772201973/system-shock-intro-theme-greg-lopiccolo-cover","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv = fragCoord.xy/iResolution.xy;\n    \tvec2 smp_uv = vec2(uv.x, .999);\n        vec2 fft_uv = vec2(uv.x, 0.001);\n        \n        float smp = texture(iChannel3, smp_uv).r; // Audio sample\n        float fft = texture(iChannel3, fft_uv).r; // Fourier coefficient sample\n        \n        vec3 color = vec3(0);\n        \n        #if DEBUG\n        color.r += (smp > uv.y) ? 1. : 0.;\n        color.g += (fft > uv.y) ? 1. : 0.;\n        #endif\n        \n        float mask_width  = 0.01;\n        \n        float[6] mask_pos = float[6](0.5335, 0.5662, 0.785, 0.831, 0.91, 0.965);\n        float[6] mask_height = float[6](0.67, 0.75, 0.7, 0.63, 0.5, 0.45);\n        \n        float anti_detector_rcp_std = 2.;\n        \n        float detection_pattern_t = mod(iTime, END_OF_SONG);\n        if( detection_pattern_t > 80.\n            &&\n            detection_pattern_t < 167.\n            )\n        {\n            mask_pos    = float[6](0.1855, 0.37, 0.555, 0.74, 0.834, 0.925);\n            mask_height = float[6](0.99, 0.83, 0.76, 0.645, 0.41,  0.495);\n            \n            anti_detector_rcp_std = 1.5;\n        }\n        \n        float detector = 0.;\n        for(int i = 0; i < 6; i++)\n            detector += mask_height[i] * gaussian(uv.x, mask_width, mask_pos[i]);\n        \n        float anti_detector = 0.65 * gaussian(anti_detector_rcp_std * uv.x);\n        \n        #if DEBUG\n        color += (detector > uv.y) ? 1. : 0.;\n        #endif\n        \n        color = mix(color, vec3(0.), (anti_detector > uv.y) ? 1. : 0.);\n        \n        float detector_sum = 0.;\n        float anti_detector_sum = 0.;\n        \n        float detector_norm = 0.;\n        float anti_detector_norm = 0.;\n        \n        for(int i = 0; i < 6; i++)\n        {\n            float detector_sample = \n                texture(iChannel3, vec2(mask_pos[i], 0.001)).r\n                / \n                max(mask_height[i] * gaussian(mask_pos[i], mask_width, mask_pos[i]), 1e-6);\n                \n            detector_sum += detector_sample;\n            \n            detector_norm += mask_height[i];\n        }\n        \n        for(float i = 0.; i < .58; i+=0.05)\n        {\n            float antidetector_sample = \n                texture(iChannel3, vec2(i, 0.001)).r\n                /\n                max(0.65 * gaussian(anti_detector_rcp_std * i), 1e-6);\n                \n            anti_detector_sum += antidetector_sample;\n            \n            anti_detector_norm += 0.65 * gaussian(anti_detector_rcp_std * i);\n        }\n        \n        if(anti_detector_sum <  5.8/*2e-2 * 0.58/0.05*/) // experimented to find this, otherwise some issue when audio is 0\n        {\n            fragColor = vec4(0);\n            return;\n        }\n        \n        float detection = detector_sum / max(anti_detector_sum, 1e-6);\n        float detection_gain = 8.;\n        detection *= (anti_detector_norm / max(detector_norm, 1e-6));\n        detection =  pow(detection, detection_gain);\n        \n        color += (1.-length(uv-.5)) * detection;\n        \n        #if DEBUG\n        fragColor.rgb = color;\n        #else\n        fragColor.b = 1./255.*(-.5 + texelFetch(iChannel3, (iFrame * 51 + ivec2(fragCoord.xy))%textureSize(iChannel3, 0), 0)[iFrame%4]);\n        #endif\n        fragColor.a = detection;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix_size = 2. / iResolution.y;\n    float ps = pix_size;\n    vec2 uv = (2. * fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0);\n\n    vec2 UV = (fragCoord.xy)/iResolution.y;\n        \n    pix_size = 1. / iResolution.y;\n    \n    vec3 linecolor = vec3(1);\n\n    float alpha = circuitboard_alpha(UV, pix_size, iResolution.xy);\n    color = mix(color, linecolor, alpha);\n    \n    fragColor = vec4(color, alpha);\n}","name":"Buffer D","description":"","type":"buffer"}]}