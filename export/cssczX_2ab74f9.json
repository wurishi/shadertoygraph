{"ver":"0.1","info":{"id":"cssczX","date":"1687050610","viewed":119,"name":"Croissant by Path Tracing","username":"guhcalm","description":"SDF's used\n- Croissant by iq: https://www.shadertoy.com/view/lsl3W2\n\nPost-Processing\n- Chromatic aberration;\n- Vignetting;\n- ACES tone mapping;","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 PincushionDistortion(vec2 uv, float strength) {\n  vec2 st = uv - 0.5;\n  float uvA = atan(st.x, st.y);\n  float uvD = dot(st, st);\n  return 0.5 + vec2(sin(uvA), cos(uvA)) * sqrt(uvD) * (1.0 - strength * uvD);\n}\nvec3 ChromaticAbberation(vec2 uv, sampler2D sampler) {\n  float amount = .5;\n  return vec3(\n    texture(sampler, PincushionDistortion(uv, 0.3 * amount)).r,\n    texture(sampler, PincushionDistortion(uv, 0.15 * amount)).g,\n    texture(sampler, PincushionDistortion(uv, 0.075 * amount)).b\n  );\n}\n#define ACESFilmic(color) (color * (2.51 * color + .03)) / (color * (2.43 * color + .59) + .14)\n#define Contrast(color) color * color * (3. -2. * color)\n#define HighlightRolloff(color) 1.85 * color / (1. + color)\nvec3 FilmGrain(vec2 uv, vec3 color) {\n  float seed = dot(uv, vec2(12.9898, 78.233));\n  float noise = .7978845608028654 * exp(-(pow(fract(sin(seed) * 43758.5453), 2.) / .5));\n  vec3 grain = vec3(noise) * (1.0 - color);\n  return color + noise * .075;\n}\n#define Vignetting(uv, color) color * (.5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .25))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 color = ChromaticAbberation(uv, iChannel0) / texture(iChannel0, uv).w;\n  \n  color = Vignetting(uv, color);\n  color = ACESFilmic(color);\n  color = FilmGrain(uv, color);\n  \n  color = Contrast(color);\n  color = HighlightRolloff(color);\n  fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Geometry Pass */\nGeometry getGeometry(Ray camera) {\n  Geometry geometry;\n  geometry.depth = getDepth(camera);\n  if (geometry.depth < 1.) {\n    geometry.position = getPosition(camera, geometry.depth);\n    geometry.normal = getNormal(geometry.position);\n    geometry.material = Material(vec3(1), 0., 0., .05);\n  }\n  return geometry;\n}\n\n/* Path Trace Pass */\nvec3 Tracer(in Ray camera) {\n  vec3 color = vec3(1);\n  for (int i; i < 16; i++) { \n    Geometry geometry = getGeometry(camera);\n    if (geometry.depth == 1.) return color * toLinear(texture(iChannel1, camera.direction));\n    color *= geometry.material.albedo;\n    camera.origin = geometry.position + geometry.normal * .0001;\n    vec3 diffuseDirection = getRandomCosineDirectionVector(geometry.normal);\n    vec3 specularDirection = reflect(camera.direction, geometry.normal);\n    float specularProbability = .6;\n    camera.direction = specularProbability >= hash() ? specularDirection : diffuseDirection;\n  }          \n  return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //time = iTime;\n  vec2 mo = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n  vec3 color;\n  const int AA = 2;\n  for (int i; i < AA; i++) {\n    seed = float(i) + iTime + hash(fragCoord / iResolution.xy);     \n    vec2 off = vec2(hash(), hash()) - .5;  \n    float an = -mo.x * 3.141592 * 2. - 1.5;\n    vec3 origin = 4.5 * vec3(sin(an), .3 + .7 * mo.y, cos(an));\n    vec3 target = vec3(0);\n    vec2 uv = (fragCoord + off - .5 * iResolution.xy) / iResolution.y;\n    color += Tracer(getCamera(uv, origin, target));\n  }\n  vec4 lastFrame = texture(iChannel0, vec2(fragCoord.xy / iResolution.xy));\n  fragColor = vec4(toScreen(color / float(AA)), 1) + lastFrame * step(iMouse.z, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Ray { vec3 origin; vec3 direction; };\nstruct Material { vec3 albedo; float roughness; float metalness; float reflectance; };\nstruct Geometry { vec3 position; vec3 normal; float depth; Material material; };\n\n#define toLinear(color) pow(vec3(color), vec3(2.2))\n#define toScreen(color) pow(vec3(color), vec3(1. / 2.2))\n#define saturate(value) clamp(value, 0., 1.)\n\nconst float PI = 3.14159265359;\nconst float EPSILON = .001;\nconst float NEAR = .001;\nconst float FAR = 8.;\nfloat time;\n\n/* SDF's */\n#define qSquare(a) vec4(a.x * a.x - dot(a.yzw, a.yzw), 2. * a.x * a.yzw)\n#define qCube(a) (a * (4. * a.x * a.x - dot(a, a) * vec4(3, 1, 1, 1)))\n#define lengthSquared(a) dot(a, a)\nfloat Croissant(in vec3 p) {\n  vec4 c = vec4(-.1, .6, .9, -.3) + .1 * sin(vec4(3, 0, 1, 2) + .5 * vec4(1, 1.3, 1.7, 2.1) * 0.);\n  vec4 z = vec4(p, .2);\n  float m2 = 0.;\n  float dz2 = 1.;\n  for(int i; i < 10; i++) {\n\tdz2 *= 9. * lengthSquared(qSquare(z));\n\tz = qCube(z) + c;\n\tm2 = dot(z, z);\t\t\n    if(m2 > 10000.) break;\n  }\n  float t = .25 * log(m2) * sqrt(m2/dz2);\n  return t;\n}\nfloat Tower(in vec3 pos) {\n  const float RADIUS = .3492;\n  const float SCALE = 2.04348;\n  const int ITERATIONS = 10;\n  vec3 p = pos * mix(.5, 2., smoothstep(0., 1., sin(time) * .5 + .5));\n  float s = 2.;\n  for (int i; i < ITERATIONS; i++) {\n    p = abs(p);\n    p += vec3(0.0365, -1.8613, 0.0365);\n    float r2 = dot(p, p);\n    float k = clamp(max(RADIUS / r2, RADIUS), 0., 1.);\n\tp *= k;\n    s *= k;\n    p = p * SCALE / RADIUS;\n    s *= abs(SCALE) / RADIUS;\n    p += vec3(-.5, -1.3028, -.5);\n  }\n  return (length(p) - abs(SCALE - 1.0)) / s - pow(abs(SCALE), float(1 - ITERATIONS));\n}\nfloat SDF(in vec3 p) { \n  //return Tower(p * .5);\n  return Croissant(p * .5); \n}\n\n/* Ray Cast | by Ray Marching  */\nfloat RayCast(in Ray ray, const int STEPS, const float NEAR) {\n  float distance;\n  for(int step; step < STEPS; step++) {\n    float march = SDF(ray.origin + ray.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march;\n    if (distance >= FAR) break;\n  }\n  return FAR;\n}\n\n/* Depth Pass | by Ray Marching  */\nfloat getDepth(in Ray camera) { return saturate(RayCast(camera, 500, EPSILON) / FAR); }\n\n\n/* Position Pass | by Depth + View Relation */\nvec3 getPosition(Ray camera, float depth) {\n  return camera.origin + camera.direction * depth * FAR;\n}\n\n/* Normal Pass | by SDF Gradient */\nvec3 getNormal(vec3 p) {\n  vec2 e = vec2(EPSILON, 0);\n  return normalize(vec3(\n    SDF(p + e.xyy) - SDF(p - e.xyy),\n    SDF(p + e.yxy) - SDF(p - e.yxy),\n    SDF(p + e.yyx) - SDF(p - e.yyx)\n  ));\n}\n\n/* Path Trace Utils */\nfloat seed;\nfloat hash() { return fract(sin(seed += .1) * 4568.7564); }\nvec3 getRandomCosineDirectionVector(vec3 n) {\n  float u = hash();\n  float v = hash();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 rr = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  rr *= sign(dot(n, rr));\n  return normalize(n + rr);\n}\nfloat hash(vec2 x) { return fract(sin(dot(x, vec2(127.1, 311.7))) * 4568.7564); }\n\n/* View Projection | Camera */\nRay getCamera(vec2 uv, vec3 origin, vec3 target) {\n  vec3 w = normalize(target - origin); // forward vector\n  vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n  vec3 v = cross(u, w); // up vector\n  return Ray(origin, mat3(u, v, w) * normalize(vec3(uv, 1.5)));\n}","name":"Common","description":"","type":"common"}]}