{"ver":"0.1","info":{"id":"ftSGWy","date":"1624565360","viewed":190,"name":"SESH maybe?","username":"MeDope","description":"I know skull is so bad sorry","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["music","bones","sesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4lfSDS","filepath":"https://soundcloud.com/teamsesh/oxygen","previewfilepath":"https://soundcloud.com/teamsesh/oxygen","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Each sdf below by IQ\nfloat dot2(vec2 x)\n{\n    return dot(x,x);\n}\n\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox(vec2 p, vec2 o)\n{\n    p = abs(p) - o;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 47758.5453); \n}\n\nfloat valuenoise2D(vec2 p, float seed)\n{\n    vec2 id = floor(p) + seed;\n    p = fract(p);\n    p = p * p * (3.0 - 2.0 * p);\n    float n00 = hash21(id);\n    float n01 = hash21(id + vec2(0.0, 1.0));\n    float n10 = hash21(id + vec2(1.0, 0.0));\n    float n11 = hash21(id + vec2(1.0, 1.0));\n    return mix(mix(n00, n10, p.x), mix(n01, n11, p.x), p.y);\n}\n\nfloat st0(float d)\n{\n    return clamp(d / fwidth(d) + 0.5, 0.0, 1.0);\n}\n\nfloat sD(vec2 p)\n{\n    p *= 1.0 + (valuenoise2D(p * 50.0, 5.97)*2.0-1.0)*0.1;\n    return min(\n    sdBezier(p, vec2(0.03, 0.0), vec2(0.07, -0.04), vec2(0.01, -0.1)), \n    sdBezier(p, vec2(0.04, 0.1), vec2(-0.01, 0.04), vec2(0.03, 0.0)));\n}\n\nfloat getd(vec2 uv)\n{\n    vec2 ouv = uv;\n    uv.y += texture(iChannel0, uv*2.0-vec2(-0.2,0.0)).r*0.02;\n    uv *= 1.0 + (valuenoise2D(uv * 50.0, 0.95)*2.0-1.0)*0.05;\n    \n    float d = 1e5;\n    d = min(d, sdSegment(uv, vec2(0.17,0.0), vec2(0.17,0.2)));\n    d = min(d, sdSegment(uv, vec2(0.11,0.1), vec2(0.17,0.09)));\n    d = min(d, sdSegment(uv, vec2(0.11,0.02), vec2(0.11,0.22)));\n\n    d = min(d, sdSegment(uv, vec2(-0.06,0.06), vec2(-0.06,0.23)));\n    d = min(d, sdSegment(uv, vec2(-0.06,0.06), vec2(-0.02,0.08)));\n    d = min(d, sdSegment(uv, vec2(-0.06,0.14), vec2(-0.025,0.156)));\n    d = min(d, sdSegment(uv, vec2(-0.06,0.23), vec2(-0.02,0.237)));\n    \n    uv = ouv;\n    uv.y += texture(iChannel0, uv * 0.1 + vec2(0.0)).r*0.01;\n    d = min(d, sD(uv - vec2(0.02,0.15)));\n    d = min(d, sD(uv - vec2(-0.16,0.1)))-0.013;\n\n    uv = ouv - vec2(0,-0.02);\n    uv *= 1.0 + (valuenoise2D(uv * 60.0, 1.54)*2.0-1.0)*0.05;\n    uv.y -= uv.x*0.2;\n    d = min(d, sdBox(uv-vec2(0,-0.06), vec2(0.013))-0.07);\n    d = min(d, length(uv-vec2(0,-0.12))-0.06);\n    d = min(d, length(uv-vec2(0,-0.16))-0.038);\n    d = min(d, length(uv-vec2(0,-0.194))-0.011);\n    uv = ouv;\n    uv.y -= uv.x*0.3;\n    uv.y += texture(iChannel0, abs(uv*0.1)).r*0.01;\n    uv.y += (valuenoise2D(uv.xx * 140.0, 1.47)*2.0-1.0)*0.009;\n    d = max(d, -sdSegment(uv, vec2(-0.5, -0.17), vec2(0.5, -0.17))+0.01);\n    uv = ouv;\n    uv.y -= uv.x*0.2;\n    uv *= 1.0 + (valuenoise2D(uv * 140.0, 54.0) * 2.0 - 1.0) * 0.15 * abs(uv.x*10.0);\n    d = max(d, -sdBox(uv-vec2(0.03,-0.08), vec2(0.01, 0.0))+0.016);\n    d = max(d, -sdBox(uv-vec2(-0.03,-0.08), vec2(0.01, 0.0))+0.016);\n    uv = ouv;\n    uv *= 1.0 + (valuenoise2D(uv * 150.0, 5.0)*2.0-1.0)*0.05;\n    d = max(d, -sdBox(uv-vec2(0.003, -0.115), vec2(0.0, 0.0))+0.012);\n    d = max(d, -sdBox(uv-vec2(0.003, -0.1), vec2(0.0, 0.0))+0.007);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x, ouv = uv;\n    vec3 col = vec3(0.2,0.2,0.2);\n    \n    float d = getd(uv);\n    col = mix(col, vec3(0), st0(-d));\n    d = getd(uv+vec2(0.0075,-0.0075));\n    col = mix(col, vec3(1), st0(-d));\n    col += vec3(0.1,0.2,3.0)*pow(0.001/abs(d), 0.45)*pow(texture(iChannel0, vec2(0.001,0.0)).r, 3.0);\n    \n    col = pow(col, vec3(1.2));\n    uv.y -= (texture(iChannel0, fragCoord.xx/iResolution.xx).r*2.0-1.0)*0.01;\n    col += vec3(0.1,0.2,3.0)*0.001/clamp(uv.y+0.28, 0.0, 1.0);\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}