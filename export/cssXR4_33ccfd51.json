{"ver":"0.1","info":{"id":"cssXR4","date":"1668577044","viewed":121,"name":"Gauss-Kronrod Quadrature","username":"Envy24","description":"Green - f(x)\nBlue - exact definite integral of f(x)\nRed - numerical definite integral of f(x) calculated with Gauss-Kronrod Quadrature.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["numerical","integral","gauss","integration","quadrature","definite","kronrod"],"hasliked":0,"parentid":"flccDS","parentname":"Gauss-Chebyshev Quadrature"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define ORIGIN vec2(35.0, 0.0)\n#define GSCALE                    ( 25.0 )\n#define UNIT                      ( 3.0*GSCALE / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Redefine this macroses for your function.\n#define integ(x)         ( -cos(x) + 1. )  // analytic definite integral form a to b of func(x) (by default a = 0 = const).\n#define func(x)          ( sin(x) )\n#define deriv(x)         ( cos(x) )\n\n/*\n    Description: https://en.wikipedia.org/wiki/Gauss%E2%80%93Kronrod_quadrature_formula#CITEREFLaurie1997\n    More Nodes and Weights: https://www.advanpix.com/2011/11/07/gauss-kronrod-quadrature-nodes-weights/\n                            https://keisan.casio.com/exec/system/1289382036\n*/\nfloat GaussKronrodQuadrature15(float a, float b)\n{\n    const float xs[7] = float[7](\n        0.991455371120813, 0.949107912342759,\n        0.864864423359769, 0.741531185599394,\n        0.586087235467691, 0.405845151377397,\n        0.207784955007898  //0.000000000000000\n        );\n    const float ws[7] = float[7](\n        0.022935322010529, 0.063092092629979,\n        0.104790010322250, 0.140653259715525,\n        0.169004726639267, 0.190350578064785,\n        0.204432940075298  //0.209482141084728\n    );  \n    \n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n          \n    float I = func(mean)*0.209482141084728;\n    for (int i = 0; i < 7; ++i)\n    {\n        float x0 = mean + hwidth * xs[i],\n              x1 = mean - hwidth * xs[i];\n              I += (func(x0)+func(x1))*ws[i];\n    }\n\n    return I * mean;\n}\n// https://www.shadertoy.com/view/st3yzs\nfloat GaussLegandreQuadrature7(float a, float b)\n{\n    const float xs[3] = float[3](\n        0.949107912342759, 0.741531185599394,\n        0.405845151377397  //0.000000000000000\n        );\n    const float ws[3] = float[3](\n        0.129484966168870, 0.279705391489277,\n        0.381830050505119  //0.417959183673469\n    );  \n    \n    float hwidth = (b-a)*0.5,\n          mean = (b+a)*0.5;\n          \n    float I = func(mean)*0.417959183673469;\n    for (int i = 0; i < 3; ++i)\n    {\n        float x0 = mean + hwidth * xs[i],\n              x1 = mean - hwidth * xs[i];\n              I += (func(x0)+func(x1))*ws[i];\n    }\n\n    return I * mean;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, GSCALE, -ORIGIN, true);\n    \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, func(NDC.x), deriv(NDC.x));\n         color.rg -= draw_func(NDC, integ(NDC.x), func(NDC.x));\n         \n    float a = 0.,  b = NDC.x, y = 0., yn = 0., dx = 0.1;\n         \n    float xs[16];\n    float ws[16];\n    //                      current                 min and max orders.\n    float order = clamp(1. + floor(mod(iTime, 8.)), 1.,     15.);\n    \n    // Gauss-Kronrod quadrature width order 15.\n    y = GaussKronrodQuadrature15(a, b);\n    yn = GaussKronrodQuadrature15(a, b + dx);\n    \n    // Gauss-Legendre quadrature with order 7.\n    //y = GaussLegandreQuadrature7(a, b);\n    //yn = GaussLegandreQuadrature7(a, b+dx);\n    \n    // Error estimate.\n    //y = abs(GaussLegandreQuadrature7(a, b) - GaussKronrodQuadrature15(a, b));\n    //yn = abs(GaussLegandreQuadrature7(a, b+dx) - GaussKronrodQuadrature15(a, b + dx));\n         \n    color.gb -= draw_func(NDC, y, (y-yn)/dx);\n    \n    /* Gauss-Kronrod quadrature width order 15 can be used to estimate definite integrals\n       from range [0; 44], or with ranges of width 44. */\n    color.g -= vertical_line(NDC, 44.);\n        \n    /* Cells */\n    NDC = fract(NDC); \n    color -= vertical_line(NDC, 0.)*.1;  color -= horizontal_line(NDC, 0.)*.1; // comment this line if you not use mod\n    color -= vertical_line(NDC, -1.)*.1; color -= horizontal_line(NDC, -1.)*.1;         \n    color -= vertical_line(NDC, 1.)*.1;  color -= horizontal_line(NDC, 1.)*.1;\n    /* */ \n   \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}