{"ver":"0.1","info":{"id":"MdjcRV","date":"1492966883","viewed":144,"name":"Holey Cubes","username":"space928","description":"experiment","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float blurSize = 1.0/512.0;\nconst float intensity = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n   vec2 uv = fragCoord.xy / iResolution.xy;\n    \n   int j;\n   int i;\n\n   //thank you! http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/ for the \n   //blur tutorial\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n    vec4 sum = vec4(0.0);\n   sum += texture(iChannel0, vec2(uv.x - 4.0*blurSize, uv.y)) * 0.05;\n   sum += texture(iChannel0, vec2(uv.x - 3.0*blurSize, uv.y)) * 0.09;\n   sum += texture(iChannel0, vec2(uv.x - 2.0*blurSize, uv.y)) * 0.12;\n   sum += texture(iChannel0, vec2(uv.x - blurSize, uv.y)) * 0.15;\n   sum += texture(iChannel0, vec2(uv.x, uv.y)) * 0.16;\n   sum += texture(iChannel0, vec2(uv.x + blurSize, uv.y)) * 0.15;\n   sum += texture(iChannel0, vec2(uv.x + 2.0*blurSize, uv.y)) * 0.12;\n   sum += texture(iChannel0, vec2(uv.x + 3.0*blurSize, uv.y)) * 0.09;\n   sum += texture(iChannel0, vec2(uv.x + 4.0*blurSize, uv.y)) * 0.05;\n\t\n\t// blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture(iChannel0, vec2(uv.x, uv.y - 4.0*blurSize)) * 0.05;\n   sum += texture(iChannel0, vec2(uv.x, uv.y - 3.0*blurSize)) * 0.09;\n   sum += texture(iChannel0, vec2(uv.x, uv.y - 2.0*blurSize)) * 0.12;\n   sum += texture(iChannel0, vec2(uv.x, uv.y - blurSize)) * 0.15;\n   sum += texture(iChannel0, vec2(uv.x, uv.y)) * 0.16;\n   sum += texture(iChannel0, vec2(uv.x, uv.y + blurSize)) * 0.15;\n   sum += texture(iChannel0, vec2(uv.x, uv.y + 2.0*blurSize)) * 0.12;\n   sum += texture(iChannel0, vec2(uv.x, uv.y + 3.0*blurSize)) * 0.09;\n   sum += texture(iChannel0, vec2(uv.x, uv.y + 4.0*blurSize)) * 0.05;\n\n   //increase blur with intensity!\n   fragColor = texture(iChannel0, uv);     \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int MARCHSTEPS =  128;\nfloat MAX_DIST = 16.0;\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = fract(p) * 2.0 - 1.0;\n    \n  return length(max(abs(q)-b,0.0))-r;\n}\n\nfloat sphere(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    return length(q) - 0.3;\n}\n\n// Return 2x2 rotation matrix\n// With vector swizzle/mask can use as a 3x3 xform\n// For y, you need to invert \n// angle in radians\n// ========================================\nmat2 Rot2(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n        \n        p = vec3(p.xz*Rot2(fract(iTime/3.0)*3.141592), p.y);\n        \n        float d = udRoundBox(p, vec3(0.15), 0.1);\n        d = max(d, -sphere(p));\n        \n        t += d * 0.5;\n        /*if((abs(r.x) <= 0.01) || (res.hd >= ray.rl) || (i > maxIter))\n            break;\n        res.hd = res.hd + r.x;*/\n    }\n    return t;\n}\n\nconst float blurSize = 1.0/512.0;\nconst float intensity = 0.35;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(sin(fract(iTime)*3.141592), iTime*0.4, fract(iTime*0.0)*3.141592);\n    /*o *= mat3(cos(iTime*0.1), 1.0, -sin(iTime*0.1),\n             1.0, 0.0, 1.0,\n             sin(iTime*0.1), 1.0, cos(iTime*0.1));*/\n    vec3 t = vec3(trace(o, r));\n    t *= vec3(1.0, 0.6, 0.4);\n                  \n    vec3 fog = 1.0 / (1.0 + t * t * 0.01);// * vec3(sin(t.zzz+iTime*5.0));\n    fragColor = vec4(fog,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}