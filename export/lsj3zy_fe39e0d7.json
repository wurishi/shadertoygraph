{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define fbm2(g) fbm3(vec3(g, 0.0))\n\nvec3 gum_colours[4];\nvec3 gum_ramps[4];\n\nvec2 tc=vec2(0.0);\nfloat time = 0.0;\nfloat colour = 0.0;\nfloat ss = 1.0;\nfloat is_choc = 0.0;\nfloat t_per_target = 3.0;\nvec3 l = normalize(vec3(10.0,30.0,0.0));\nfloat icing_factor = 0.0;\n\nvec3 gumColour(float i)\n{\n\tif(i < 1.0)\n\t\treturn vec3(0.11,0,0.002);\n\telse if(i < 2.0)\n\t\treturn vec3(0.002, 0.06, 0.0);\n\telse if(i < 3.0)\n\t\treturn vec3(0.0,0.02, 0.11);\n\telse\n\t\treturn vec3(0.11,0.012, 0);\n}\n\nvec3 gumRamp(float i)\n{\n\tif(i < 1.0)\n\t\treturn vec3(0.8,1,1);\n\telse if(i < 2.0)\n\t\treturn vec3(0.8,0.8,1);\n\telse if(i < 3.0)\n\t\treturn vec3(1,0.8,1);\n\telse\n\t\treturn vec3(0.8,0.8,1);\n}\n\n// Noise functions from IQ.\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nfloat smN2(vec2 p)\n{\n\treturn noise(vec3(p,0.0));\n}\n\nfloat smN3(vec3 p)\n{\n\treturn noise(p);\n}\n\nfloat fbm3(vec3 p)\n{\n\tfloat f = 0.0, x;\n\tfor(int i = 1; i <= 9; ++i)\n\t{\n\t\tx = exp2(float(i));\n\t\tf += (noise(p * x) - 0.5) / x;\n\t}\n\treturn f;\n}\n\nvec2 rotate(float a, vec2 v)\n{\n\treturn vec2(cos(a) * v.x + sin(a) * v.y,\n\t\t\t\tcos(a) * v.y - sin(a) * v.x);\n}\n\nfloat sugarybit(vec2 p)\n{\n\tp = clamp(p, vec2(-1.0), vec2(1.0));\n\tvec2 o = vec2(0.0, 0.0);\n\tfloat a = 1.0 - pow((1.0 - pow(abs(p.x), 8.0)) * (1.0 - pow(abs(p.y + o.y), 8.0)) * 0.95, 0.5);\n\tfloat b = pow((1.0 - pow(abs(p.x), 8.0)) * (1.0 - pow(abs(p.y), 8.0)), 4.0);\n\treturn a * b * 3.0;\n}\n\nfloat sugarlayer(vec2 t, float ndotv)\n{\n\tvec2 t2 = t.xy * 8.0;\n\tvec2 p = fract(t2) - vec2(0.5);\n\tvec2 c = floor(t2);\n\tfloat a = c.x + c.y * 5.0;\n\tvec2 o = vec2(cos(c.y * 53.0), sin(c.x * 125.0)) * 2.5;\n\tvec2 s = 1.0 + vec2(smN2(c), smN2(c + vec2(100.0)));\n\t\n\tfloat fres = mix(1.0, pow(1.0 - ndotv, 4.0), 0.9) * 25.0;\n\t\n\treturn sugarybit(rotate(a, p * s * 4.0 + o)) * max(0.0, smN2(t2.xy * 5.0) - 0.5) * fres;\n}\n\nvec3 saturatecol(vec3 c)\n{\n\treturn pow(c, gumRamp(colour));\n}\n\nfloat sprinkles2(vec2 coord, float ndotv)\n{\n\tfloat sprinkle = 0.0;\n\t\n\tfor(int i = 0; i < 4; ++i)\n\t\tsprinkle += sugarlayer((coord + vec2(float(i) * 10.45)) * (1.0 + float(i) * 0.2), ndotv) * pow(1.0 - float(i) / 4.0, 4.0);\n\t\n\treturn sprinkle;\n}\n\nfloat sprinkles(vec2 coord, float ndotv)\n{\n\treturn sprinkles2(coord * 0.75, ndotv) + sprinkles2(coord * 2.0, ndotv) * 0.3;\n}\n\nvec3 gummy(vec3 no, vec3 vo, vec3 v)\n{\n\tfloat ndotv = dot(no,-v);\n\t\n\tfloat s0 = sprinkles(vec2(atan(no.z, no.x), asin(no.y)) * 0.75, ndotv);\n\tfloat s1 = sprinkles(vo.xz, ndotv);\n\t\n\tfloat sprinkle = mix(s0, s1, smoothstep(0.3, 0.5, no.y));\n\t\n\tfloat ss = clamp((no.y -0.3) * 5.0, 0.0, 1.0);\n\t\n\tvec3 tex = saturatecol(mix(mix(vec3(0.5),gumColour(colour),0.98) * (0.1 + pow((1.0 - abs(tc.x)) * 0.5, 0.2)), vec3(2.0),\n\t\t\t\t\t\t\t   sprinkle * ss));\n\t\n\ttex *= 1.05 - ndotv;\n\ttex+=vec3(pow(1.0 - ndotv, 8.0)) * 0.01;\n\t\n\treturn tex;\n}\n\nmat3 rotateXMat(float a)\n{\n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a));\n}\n\nmat3 rotateYMat(float a)\n{\n\treturn mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\n\nfloat de(vec3 p)\n{\n\tp.y*=1.3;\n\t\n\tvec3 fp=floor(p/3.0);\n\t\n\tis_choc=step(0.0,cos(fp.x*10.0-fp.z*103.0)+0.1);\n\t\n\tfloat ff=smN3(p*30.0)*0.001*is_choc-pow(max(0.0,smN3(p*5.0)),5.0)*(0.01+0.05*(1.0-is_choc));\n\t\n\tcolour=mod(fp.x+sin(fp.z)*3.0,4.0);\n\tp.xz=mod(p.xz,vec2(3.0))-vec2(1.5);\n\t\n\tss=mix(0.7,1.0,0.5+0.5*cos(fp.z*7.0+fp.x*9.0));\n\t\n\tfloat sp=length(p)-ss;\n\tfloat pl=-p.y;\n\t\n\tfloat d=(length(vec2(max(0.0,sp),max(0.0,pl)))-0.1+ff)*0.6;\n\t\n\treturn d;\n}\n\nvec3 marble(vec2 p)\n{\n\tp.x+=2.0;\n\tfloat border_size=0.015;\n\tfloat corner_size=0.015;\n\t\n\tvec2 c0=floor(p);\n\tvec2 c1=(p-c0)-vec2(0.5);\n\tvec2 rc1=(c1.x*vec2(1.0)+c1.y*vec2(1.0,-1.0))*0.6;\n\t\n\tvec3 ccol=mix(vec3(1.0,1.0,0.5)*0.1,vec3(max(0.0,fbm2(p)*0.5)),0.75);\n\tvec3 pat=mix(vec3(1.0,1.0,0.6)*0.4,vec3(1.0,1.0,0.8)*0.7,1.0-smoothstep(0.4,0.8,0.5+fbm2(c0*2.0+p*1.0+cos(p.yx*2.0)*0.4)))+\n\t\tvec3(max(0.0,fbm2(p*0.7)*1.0))+vec3(smoothstep(0.2,0.3,fbm2(-p)))*0.2;\n\tvec3 bcol=mix(pat,vec3(1.0,1.0,0.5)*0.1,0.5);\n\t\n\tfloat br=max(smoothstep(0.5-border_size,0.5,abs(c1.y)),smoothstep(0.5-border_size,0.5,abs(c1.x)));\n\tfloat cr=max(smoothstep(0.5-corner_size,0.5,abs(rc1.y)),smoothstep(0.5-corner_size,0.5,abs(rc1.x)));\n\treturn mix(pat,mix(bcol,ccol,cr),max(cr,br))*0.8;\n}\n\nvec3 cameraPos(float t)\n{\n\treturn vec3(t*0.6,6.0+cos(t*4.0)*0.03,0.0);\n}\n\nvec3 targetPos(float ti)\n{\n\tvec3 target=cameraPos(ti*t_per_target)*vec3(1.0,0.0,0.0)+vec3(cos(ti*20.0)*4.0,0.0,-7.0+cos(ti*14.0)*3.0);\n\ttarget.xz=floor(target.xz/3.0)*3.0+vec2(1.5);\n\treturn target;\n}\n\nfloat cameraZoom(float ti)\n{\n\treturn mix(3.0,3.5,0.5+0.5*cos(ti*30.0))*1.4;\n}\n\nvec3 trace(vec3 ro, vec3 rd, inout float t, float max_t)\n{\n\t\n\tfor(int i=0;i<100;i+=1)\n\t{\n\t\tfloat d=de(ro+rd*t);\n\t\tif(t>max_t)\n\t\t\treturn vec3(0.0);\n\t\tif(abs(d)<1e-4)\n\t\t\tbreak;\n\t\tt=min(max_t+1e-3,t+d);\n\t}\n\t\n\tvec3 rp=ro+rd*t;\n\tvec3 col=vec3(0.2,0.1,0.05)*0.1;\n\t\n\tfloat e=1e-3, c=de(rp);\n\tvec3 n=normalize(vec3(de(rp+vec3(e,0.0,0.0))-c,de(rp+vec3(0.0,e,0.0))-c,de(rp+vec3(0.0,0.0,e))-c));\n\tvec3 v=rd;\n\t\n\tvec3 h=normalize(l-rd);\n\t\n\tif(is_choc<0.5)\n\t{\n\t\tvec3 chocolour;\n\t\t\n\t\tif(mod(floor(rp.x/3.0),2.0)>0.5)\n\t\t{\n\t\t\tfloat r=pow(distance(rp.xz,floor(rp.xz/3.0)*3.0+vec2(1.5))*0.6,2.0);\n\t\t\tchocolour=mix(vec3(2.0,2.0,1.3)*2.0,vec3(1.3,0.6,0.2)*0.6,smoothstep(0.5+r,0.6+r,0.4+fbm2(rp.xz*10.0)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchocolour=mix(vec3(1.3,0.6,0.2),vec3(2.0,2.0,1.3)*2.0,smoothstep(0.7,0.9,0.5+0.5*cos(rp.x*10.0+sin(rp.z*5.0))));\n\t\t}\n\t\t\n\t\tcol=(0.1*chocolour*vec3(0.5+0.5*dot(n,l))+0.06*vec3(1.0,1.0,0.5)*vec3(pow(clamp(0.5+0.5*dot(h,n),0.0,1.0),20.0)))*\n\t\t\t(1.0+0.6*pow(dot(n,-rd),2.0));\n\t}\n\telse\n\t{\n\t\tcol = gummy(n, rp, v) * 5.0 + 0.1*vec3(smoothstep(0.5,0.6,pow(clamp(0.5+0.5*dot(h,n),0.0,1.0),256.0)));\n\t}\n\t\n\tcol *= mix(1.0,pow(max(0.0,rp.y),0.5),0.6);\n\t\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime=iTime;\n\t\n\ttc=fragCoord.xy/iResolution.xy*2.0-vec2(1.0);\n\t\n\tfloat ti=floor(time/t_per_target);\n\tfloat tf=fract(time/t_per_target);\n\t\n\tvec3 camo=cameraPos(time);\n\tvec3 camt=mix(targetPos(ti-1.0),targetPos(ti),smoothstep(0.3,0.7,tf));\n\tvec3 camd=normalize(camt-camo);\n\t\n\tvec3 camu=normalize(cross(camd,vec3(0.0,1.0,0.0)));\n\tvec3 camv=normalize(cross(camu,camd));\n\tcamu=normalize(cross(camd,camv));\n\t\n\tmat3 m=mat3(camu,camv,camd);\n\t\n\tvec2 q=tc.xy*0.5+vec2(0.5);\n\tvec2 p=tc.xy;\n\tvec3 ro=camo;\n\t\n\tp.x*=iResolution.x/iResolution.y;\n\t\n\tfloat zoom=mix(cameraZoom(ti-1.0),cameraZoom(ti),smoothstep(0.7,0.9,tf));\n\t\n\tvec3 rd=m*normalize(vec3(p,zoom));\n\t\n\tfloat t=max(0.0,(1.0-ro.y)/rd.y);\n\t\n\tfloat t2=max(0.0,(-0.01-ro.y)/rd.y);\n\t\n\tvec3 col = trace(ro, rd, t, t2);\n\t\n\tvec3 rp=ro+rd*t;\t\n\n\ticing_factor=clamp(rp.y*2.0,0.0,1.0);\n\t\n\tif(t > 0.0 && t2 < t)\n\t{\n\t\tvec2 c=ro.xz+rd.xz*t2;\n\t\tvec2 xc=c*0.8;\n\t\tfloat x=step(0.5,fract(xc.x+0.5*step(0.5,fract(xc.y))));\n\t\tvec3 cc=mix(vec3(1.0),vec3(1.0,1.0,0.5)*0.5,x);\n\t\tcc=mix(cc,vec3(0.9,0.9,0.5),pow(0.3+0.5*smN2(xc*10.0+vec2(cos(xc.y*2.0)*3.0,cos(xc.x*1.0)*4.0)),4.0));\n\t\t\n\t\tvec3 h=normalize(l-rd);\n\t\tvec3 r=reflect(rd,vec3(0.0,1.0,0.0));\n\t\tfloat rt=0.0;\n\t\tcc=marble(rotate(2.0,xc*0.5));\n\t\t\n\t\tc=fract(c/3.0);\n\t\tcol=cc*0.8*mix(gumColour(colour)*2.0*is_choc,vec3(1.0),smoothstep(0.33,0.53,distance(vec2(0.5),c)/ss));\n\t\ticing_factor=1.0;\n\t}\n\n\tfloat icing=1.0-iMouse.x/iResolution.x*icing_factor;\n\tcol=mix(col,vec3(1.0),\n\t\t0.9*smoothstep(0.5,0.7,-0.25*icing+0.35+fbm2(rp.xz*4.2))+0.9*smoothstep(0.5,0.7,-0.25*icing+0.3+fbm2(rp.xz*10.1)));\n\t\n\tfragColor.rgb=sqrt(col * 1.4);\n\t\n\t// IQ's vignet.\n\tfragColor.rgb *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsj3zy","date":"1390423577","viewed":5673,"name":"Unlimited Confectionery","username":"fizzer","description":"Some candy-like materials. The shading is not exactly physically-based :)\nUse the mouse to spill some icing sugar.","likes":84,"published":1,"flags":0,"usePreview":0,"tags":["raymarched","chocolate","candy","sweets","sugar"],"hasliked":0,"parentid":"","parentname":""}}