{"ver":"0.1","info":{"id":"WdlBW8","date":"1588145528","viewed":506,"name":"2d Pixel Lighting Test","username":"natethegreat2525","description":"2d pixel lighting test for future reference. Just throwing around some ideas. Mostly this solves the problem of how to light surrounding 2d terrain while also allowing some nice soft shadows.","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["2d","lighting","pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nbool inWall(vec2 pos) {\n    return texture(iChannel0, pos/iResolution.xy).x > .5;\n}\n\nfloat getLight(vec2 pos, vec2 lpos) {\n    vec2 dir = pos-lpos;\n    float dist = length(dir);\n    float light = 3./pow(dist,.5);\n    float dotf = dist*.2;\n    int dot = int(dotf);\n    float walls = 0.;\n    for (int i = 0; i <= dot; i++) {\n        vec2 p = lpos + (float(i)/dotf)*dir;\n        if (inWall(p)) {\n            walls++;\n            if (walls > 4.) {\n                break;\n            }\n        }\n    }\n    \n    return light * (5.-walls)/5.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec3 light = texture(iChannel2, coord/iResolution.xy).rgb;\n    if (inWall(coord)) {\n        fragColor = texture(iChannel1, coord*4./iResolution.xy);\n        fragColor.xyz *= light*2.;\n        return;\n    }\n    \n    \n    fragColor = vec4(vec3(light), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool inWall(vec2 pos) {\n    return texture(iChannel0, pos/iResolution.xy).x > .5;\n}\n\nvec3 getLight(vec2 pos, vec2 lpos, vec3 col) {\n    vec2 dir = pos-lpos;\n    float dist = length(dir);\n    float light = 3./sqrt(dist);\n    float dotf = dist*.2;\n    int dot = int(dotf);\n    for (int i = 1; i <= dot; i++) {\n        vec2 p = lpos + (float(i)/dotf)*dir;\n        if (inWall(p)) {\n            return vec3(0.);\n        }\n    }\n    \n    return light * col;\n}\n\n#define RAD 5.\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    float time = iTime * .5;\n    vec2 light1Pos = iResolution.xy * (vec2(.5) + vec2(cos(time), sin(time))*.3);\n    vec2 light2Pos = iResolution.xy * (vec2(.5) + vec2(cos(time*.4), sin(time*.8))*.4);\n    // need to add light together in squared space then squareroot again to properly add light values\n    vec3 light = sqrt(pow(getLight(coord, iMouse.xy, vec3(1)), vec3(2.)) +\n                      pow(getLight(coord, light1Pos, vec3(1, 1, 0)), vec3(2.)) +\n                     pow(getLight(coord, light2Pos, vec3(0, 1, 1)), vec3(2.)));\n    \n    vec3 oldLightU = texelFetch(iChannel2, ivec2(coord.x, coord.y+RAD), 0).rgb;\n    vec3 oldLightD = texelFetch(iChannel2, ivec2(coord.x, coord.y-RAD), 0).rgb;\n    vec3 oldLightL = texelFetch(iChannel2, ivec2(coord.x+RAD, coord.y), 0).rgb;\n    vec3 oldLightR = texelFetch(iChannel2, ivec2(coord.x-RAD, coord.y), 0).rgb;\n    \n    vec3 maxAround = max(max(oldLightU, oldLightD), max(oldLightL, oldLightR));\n    \n    vec3 oldLightUR = texelFetch(iChannel2, ivec2(coord.x-RAD, coord.y+RAD), 0).rgb;\n    vec3 oldLightDR = texelFetch(iChannel2, ivec2(coord.x-RAD, coord.y-RAD), 0).rgb;\n    vec3 oldLightUL = texelFetch(iChannel2, ivec2(coord.x+RAD, coord.y+RAD), 0).rgb;\n    vec3 oldLightDL = texelFetch(iChannel2, ivec2(coord.x+RAD, coord.y-RAD), 0).rgb;\n    \n    vec3 maxAroundDiag = max(max(oldLightUR, oldLightDR), max(oldLightUL, oldLightDL));\n    \n    maxAround = max(maxAround, maxAroundDiag*.94);  // multiplier should be .9 ^ (1/sqrt(2)), not sure why but had to tweak to .94 to remove artifacts\n    light = max(light, clamp(maxAround, 0., 1.)*.9);\n    fragColor = vec4(light, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}