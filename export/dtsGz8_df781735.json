{"ver":"0.1","info":{"id":"dtsGz8","date":"1671318456","viewed":99,"name":"sniper scope aim","username":"ianertson","description":"Simple sniper scope aim thing","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["scope","weapon","sniper","aim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scope(\nvec2 uv,\nvec2 res,\nfloat radiusScalar,\nfloat smoothness\n) {\n    uv *= res;\n    \n    vec2 center = (res / 2.0);\n  \n    // ======== circle\n    float rat = res.x / res.y;\n    float radius = rat * radiusScalar;\n    \n    float dist = distance(uv, center);\n    float circle = 1.0 - float(dist < radius);\n    \n    circle *= smoothstep(0.0, 1.0, (dist - radius) * clamp(1.0 - smoothness, 0.0, 1.0));\n    \n    // ======== center point\n    float radius2 = radius / 32.0;\n    float dx = (center.x+(radius2/(rat*2.0))) - uv.x;\n    float dy = center.y - uv.y;\n    float centerPoint = float(\n        dx >= (-radius2/2.0) && dx <= (radius2/2.0) &&\n        dy >= (-radius2/2.0) && dy <= (radius2/2.0)\n    );\n    \n    // ======== lines\n    float thick = 4.0;\n    vec2 lineH = vec2(0, center.y);\n    vec2 lineV = vec2(center.x, 0);\n    \n    float lineHLeft = float(uv.x < (center.x - (radius/2.0))) * (thick);\n    float lineHRight = float(uv.x > (center.x + (radius/2.0))) * (thick);\n    float lineVBot = float(uv.y < (center.y - (radius/2.0))) * (thick);\n    float lineVTop = float(uv.y > (center.y + (radius/2.0))) * (thick);\n    \n    float line = float(uv.y >= (lineH.y-(lineHLeft+lineHRight)) && uv.y <= lineH.y+thick+(lineHLeft+lineHRight)) +\n    float(uv.x >= (lineV.x-(lineVBot+lineVTop)) && uv.x <= lineV.x+thick+(lineVBot+lineVTop));\n    \n    line *= max(0.0, 1.0 - pow(1.0 / (dist/10.0), 2.0));\n   \n    \n    return (circle + centerPoint + line);\n}\n\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 background(in vec2 fragCoord) {\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec2 orientation = vec2(cos(iTime*0.5)*0.5, max(0.3, 0.4 + sin(iTime*0.1)*0.5));\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., orientation.y));\n  ro.xz *= rotate2d(mix(-PI, PI, orientation.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -0.5));\n  \n  return texture(iChannel0, rd).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n      vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5);\n    \n    uv = 0.5 + uv * 0.5;\n\n    float s = scope(fragCoord/iResolution.xy, iResolution.xy, iResolution.x/7.0, 0.95);\n\nvec3 bg = background(fragCoord);\n    vec3 col = mix(bg, vec3(0.0), s);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}