{"ver":"0.1","info":{"id":"DslGDH","date":"1666074198","viewed":136,"name":"3D_raymarching_scene","username":"zhxmdefj","description":"A simple test to buid raymarching scene with shading.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by Kelvin_Z\n//2022.10.18\n\n#define AA_QUALITY 0\n#define ENABLE_POST_PROCESSING 1\n#define ENABLE_CAMERA_MOVEMENT 0\n#define ENABLE_SHADOWS 1\n#define SHADOW_FALLOFF 0.05\n#define SHADOW_OPACITY 0.8\n\n// 基元\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 radii)\n{\n    return length(vec2(length(p.xz) - radii.x, p.y)) - radii.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n// bool运算\nfloat opS(float d1, float d2)\n{\n    return max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// 平滑最小值min(k = 0.1)\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n// 混合\nvec2 opBlend(vec2 d1, vec2 d2)\n{\n    float k = 2.0;\n    float d = sminCubic(d1.x, d2.x, k);\n    float m = mix(d1.y, d2.y, clamp(d1.x-d,0.0,1.0));\n    return vec2(d, m);\n}\n\n// 主要函数sdf\nvec2 sdf(vec3 pos)\n{\n    vec2 res =         vec2(sdSphere(pos-vec3(3.5,-0.5,10), 2.5),    5.0);\n    res = opBlend(res, vec2(sdSphere(pos-vec3(-3.5, -0.5, 10), 2.5), 8.0));\n    res = opU(res, vec2(sdPlane(pos, vec4(0, 1.4, 0, 10)),           -0.5));\n    \n    vec2 shapeA = vec2(sdBox(pos-vec3(9, -3.0, 8), vec3(1.5)),  1.5);\n    vec2 shapeB = vec2(sdSphere(pos-vec3(9, -3.0, 8), 1.5),        3.0);\n    res = opU(res, mix(shapeA, shapeB, sin(iTime)*1.0));\n    \n    float radius = (sin(iTime*1.6)*0.3+0.15)+1.3;\n    res = opU(res, vec2(opS(sdBox(pos -  vec3(-9, 4.5, 12), vec3(1,1,1)),     \n                            sdSphere(pos-vec3(-9, 4.5, 12), radius)),8.0));\n\n    return res;\n}\n\n// 法线计算\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = sdf(pos).x;\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( \n        sdf(pos + eps_zero.xyy).x, \n        sdf(pos + eps_zero.yxy).x, \n        sdf(pos + eps_zero.yyx).x) - c);\n}\n\n// 射线投射\nstruct IntersectionResult\n{\n    float minDist;\n    float mat;\n    int steps;\n};\n\nIntersectionResult castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float tmax = 100.0;\n    float t = 0.0;\n    \n    IntersectionResult result;\n    result.mat = -1.0;\n    \n    for (result.steps = 0; result.steps < 128; result.steps++)\n    {\n        vec2 res = sdf(rayOrigin + rayDir * t);\n        if (res.x < (0.0001*t))\n        {\n            //小于阈值，求交点\n            result.minDist = t;\n            return result;\n        }\n        else if (res.x > tmax)\n        {\n            //过远停止步进\n            result.mat = -1.0;\n            result.minDist = -1.0;\n            return result;\n        }\n        t += res.x;\n        result.mat = res.y;\n    }\n    \n    result.minDist = t;\n    return result;\n}\n\n// 3D纹理贴图\nvec3 triplanarMap(vec3 surfacePos, vec3 normal, float scale)\n{\n\t// Take projections along 3 axes, sample texture values from each projection, and stack into a matrix\n\tmat3x3 triMapSamples = mat3x3(\n\t\ttexture(iChannel0, surfacePos.yz * scale).rgb,\n\t\ttexture(iChannel0, surfacePos.xz * scale).rgb,\n\t\ttexture(iChannel0, surfacePos.xy * scale).rgb\n\t\t);\n\n\t// Weight three samples by absolute value of normal components\n\treturn triMapSamples * abs(normal);\n}\n\n// 棋盘地板 https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return clamp(0.5 - 0.5*i.x*i.y,0.0,1.0);\n}\n\n// 远处雾气效果\nvec3 fogColor = vec3(0.30, 0.36, 0.60);\nvec3 applyFog(vec3 rgb, float dist)\n{\n    float startDist = 80.0;\n    float fogAmount = 1.0 - exp(-(dist-8.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// 随机函数\nfloat rand(vec2 coord)\n{\n    return fract(sin(dot(coord.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 渲染循环\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    // 天空盒\n    vec3 col = fogColor - rayDir.y * 0.4;\n\n    IntersectionResult res = castRay(rayOrigin, rayDir);\n    float t = res.minDist;  // 到平面距离\n    float m = res.mat;      // 纹理ID\n    float steps = float(res.steps);\n    \n    #define SHOW_STEP_COUNT 0\n#if SHOW_STEP_COUNT\n    return vec3(steps/350., 0.0, 0.0);\n#endif\n\n    vec3 N = vec3(0.0, 1.0, 0.0);\n    vec3 L = normalize(vec3(sin(iTime), 0.9, -0.5));\n\n    if (m > -1.0)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        if (m > -0.5)\n        {\n            N = calcNormal(pos);\n            \n            col = vec3(0.18*m, 0.6-0.05*m, 0.2+0.2*N.y)*0.8+0.2;\n\t\t\t\n        \t// L is vector from surface point to light, N is surface normal. N and L must be normalized!\n            float NoL = max(dot(N, L), 0.0);\n            vec3 LDirectional = vec3(1.25, 1.2, 0.8) * NoL;\n            vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n            vec3 diffuse = col * (LDirectional + LAmbient);\n            \n            vec3 texSample = triplanarMap(pos, N, 0.2);\n            // Only apply texture to materials > 4.5\n        \tcol = mix(diffuse, diffuse*texSample, step(4.5, m));\n            \n            // Visualize normals:\n          \t//col = N * vec3(0.5) + vec3(0.5);\n        }\n        else\n        {\n            // Ground plane\n            float grid = checkersGradBox(pos.xz*0.2) * 0.03 + 0.1;\n            col = vec3(grid, grid, grid);\n            \n#if ENABLE_SHADOWS\n            float shadow = 0.0;\n            float shadowRayCount = 2.0;\n            for (float s = 0.0; s < shadowRayCount; s++)\n            {\n                vec3 shadowRayOrigin = pos + N * 0.01;\n                float r = rand(vec2(rayDir.xy)) * 2.0 - 1.0;\n                vec3 shadowRayDir = L + vec3(1.0 * SHADOW_FALLOFF) * r;\n                IntersectionResult shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n                if (shadowRayIntersection.mat != -1.0)\n                {\n                    shadow += 1.0;\n                }\n            }\n            \n    \t\tvec3 cshadow = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            col = mix(col, col*cshadow*(1.0-SHADOW_OPACITY), shadow/shadowRayCount);\n#endif\n        }\n\n        col = applyFog(col, pos.z);\n    }\n    \n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n\tvec3 camUp = normalize(cross(camForward, camRight));\n\n    // fPersp controls the camera's field of view. Try changing it!\n    float fPersp = 1.5;\n\tvec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n\treturn vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y; // Correct for aspect ratio\n    return result;\n}\n\nvec4 getSceneColor(vec2 fragCoord)\n{ \n    vec3 camPos = vec3(0, 0, -7);\n#if ENABLE_CAMERA_MOVEMENT\n    camPos += vec3(sin(iTime*0.5)*0.5, cos(iTime*0.5)*0.1, 0.0);\n#endif\n    vec3 at = vec3(0, 0, 0);\n    \n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 rayDir = getCameraRayDir(uv, camPos, at);\n    \n    vec3 col = render(camPos, rayDir);\n    \n    return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    \n#if AA_QUALITY > 1\n    float AA_size = float(AA_QUALITY);\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < AA_size; aaY++)\n    {\n        for (float aaX = 0.0; aaX < AA_size; aaX++)\n        {\n            fragColor += getSceneColor(fragCoord + vec2(aaX, aaY) / AA_size);\n            count += 1.0;\n        }\n    }\n    fragColor /= count;\n#else\n    fragColor = getSceneColor(fragCoord);\n#endif\n    \n    \n#if ENABLE_POST_PROCESSING\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screenCoord = fragCoord/iResolution.xy;\n\n    // Vignette\n    float radius = 0.8;\n    float d = smoothstep(radius, radius-0.5, length(screenCoord-vec2(0.5)));\n    fragColor = mix(fragColor, fragColor * d, 0.5);\n    \n    // Contrast\n    float constrast = 0.3;\n    fragColor = mix(fragColor, smoothstep(0.0, 1.0, fragColor), constrast);\n    \n    // Colour mapping\n    fragColor *= vec4(0.90,0.96,1.1,1.0);\n#endif\n    \n    fragColor = pow(fragColor, vec4(0.4545)); // Gamma correction (1.0 / 2.2)\n}","name":"Image","description":"","type":"image"}]}