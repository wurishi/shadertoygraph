{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// **************************************************************************\n// DEFINITIONS\n// **************************************************************************\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define ONE_OVER_PI 0.3183099\n#define ONE_OVER_TWO_PI 0.159154\n#define PI_OVER_TWO 1.570796\n    \n#define EPSILON 0.0001\n#define BIG_FLOAT 1000000.0\n\n// **************************************************************************\n// OPTIMIZATION DEFS\n// **************************************************************************\n\n// Adjust number of polar march steps number based on performance of \n// graphics cards.\n\n//#define NUM_POLAR_MARCH_STEPS 128\n//#define NUM_POLAR_MARCH_STEPS 64\n#define NUM_POLAR_MARCH_STEPS 32\n//#define NUM_POLAR_MARCH_STEPS 8\n\n// **************************************************************************\n// GLOBALS\n// **************************************************************************\n\n// the beat ourpithyator is about 125 beats per minute, so we have all timing\n// based events based on multiples of that beat rate.\n\n// Music events of ourpithyator\n#define OURPITHYATOR_START 6.\n#define OURPITHYATOR_SOFTDROP 13.\n#define OURPITHYATOR_TICKSTART 28.\n#define OURPITHYATOR_FIRSTDROP 45.\n#define OURPITHYATOR_SLIDINGSCALE 79.\n#define OURPITHYATOR_INCEPTIONHONK 87.\n#define OURPITHYATOR_FINALHONK 163.\n\n// - - - - - - - - - - - - -\n// Audio based signals\nfloat g_beatRate = 125./60.;\nfloat g_time = 0.;\nfloat g_audioResponse = 1.;\n\n// audio signals\nfloat g_bassBeat = 0.;\nfloat g_audioFreqs[4];\n\n// - - - - - - - - - - - - -\n// pool Surface properties\n\nfloat g_poolSurfaceFacingKr = .3;\nfloat g_poolSurfaceEdgeOnKr = 1.;\nfloat g_poolSurfaceIOR = 1.33;\n\n// - - - - - - - - - - - - -\n// Orb properties\n\n//   dimensions of the orb\nfloat g_orbOuterRadius = 30.;\nfloat g_orbCenterRadius = 12.;\nvec3 g_orbPosition = vec3(0.);\n\n//   surface projerteis of the orb\nfloat g_orbSurfaceFacingKr = .1;\nfloat g_orbSurfaceEdgeOnKr = 1.2;\nfloat g_orbIOR = 1.33;\n\nvec2 g_numOrbCells = vec2(12., 128.);\nvec2 g_numOrbsChangeRate = vec2(0.);\n\n//   properties of the \"spark\" lines\nfloat g_sparkColorIntensity = 1.;\nvec2 g_sparkRotationRate = vec2(0.);\n\nfloat g_sparkWidth = 0.45;\nfloat g_sparkColorMixLeadingLimit = 0.;\nfloat g_sparkColorMixTrailingLimit = 0.;\nfloat g_sparkColorMixInterval = 0.;\n\n// - - - - - - - - - - - - -\n// Camera properties\nvec3 g_camOrigin = vec3(0., 0., -120.);\n    \n// point the camera is pointing at\nvec3 g_camPointAt = vec3( 0.0, 0.0, 0.0 );\n    \n// frame of reference for camera's up position\n// Put in a little \"dutch angle\" to make the image a bit more interesting\nvec3 g_camUpDir = vec3( 0.025, 1.0, 0.0 );\n\nfloat g_camYRotationRate = 0.;\nfloat g_camXRotationRate = 0.;\n\n// **************************************************************************\n// MATH UTILITIES\n// **************************************************************************\n\n// XXX: To get around a case where a number very close to zero can result in \n// erratic behavior with sign, we assume a positive sign when a value is \n// close to 0.\nfloat zeroTolerantSign(float value)\n{\n    // DEBRANCHED\n    // Equivalent to:\n    // if (abs(value) > EPSILON) { \n    //    s = sign(value); \n    // }\n    return mix(1., sign(value), step(EPSILON, abs(value)));\n}\n\n// convert a 3d point to two orb coordinates. First coordinate is latitudinal\n// angle (angle from the plane going through x+z) Second coordinate is azimuth\n// (rotation around the y axis)\n\n// Range of outputs := ([PI/2, -PI/2], [-PI, PI])\nvec2 cartesianToPolar( vec3 p ) \n{    \n    return vec2(PI/2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n// Convert a polar coordinate (x is latitudinal angle, y is azimuthal angle)\n// results in a 3-float vector with y being the up axis.\n\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 polarToCartesian( vec2 angles )\n{\n    float cosLat = cos(angles.x);\n    float sinLat = sin(angles.x);\n    \n    float cosAzimuth = cos(angles.y);\n    float sinAzimuth = sin(angles.y);\n    \n    return vec3(cosAzimuth * cosLat,\n                sinLat,\n                sinAzimuth * cosLat);\n}\n\n// Rotate the input point around the y-axis by the angle (given in radians)\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotateAroundYAxis( vec3 point, float angle )\n{\n    float cosangle = cos(angle);\n    float sinangle = sin(angle);\n    return vec3(point.x * cosangle  + point.z * sinangle,\n                point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle (given in radians)\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotateAroundXAxis( vec3 point, float angle )\n{\n    float cosangle = cos(angle);\n    float sinangle = sin(angle);\n    return vec3(point.x,\n                point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n// Returns the floor and ceiling of the given float\nvec2 floorAndCeil( float x ) \n{\n    return vec2(floor(x), ceil(x));\n}\n\n// Returns the floor and ceiling of each component in respective\n// order (floor(p.x), ceil(p.x), floor(p.y), ceil(p.y)) \nvec4 floorAndCeil2( vec2 p ) \n{\n    return vec4(floorAndCeil(p.x), \n                floorAndCeil(p.y));\n}\n\n// Returns 2 floats, the first is the rounded value of float.  The second\n// is the direction in which the rounding took place.  So if rounding \n// occurred towards a larger number 1 is returned, otherwise -1 is returned. \nvec2 round_and_direction( float x ) \n{\n    return vec2(floor(x+0.5), sign(fract(x)-0.5));\n}\n\n// Returns 4 floats, \n// the first is the rounded value of p.x\n// the second is the direction in which the rounding took place for p.x\n// So if rounding occurred towards a greater number 1 is returned, \n// otherwise -1 is returned\n// the third is the rounded value of p.y.  \n// the fourth is the direction in which the rounding took place for p.y\nvec4 round_and_direction2( vec2 p ) \n{\n    return vec4(round_and_direction(p.x), round_and_direction(p.y));\n}\n\n// Given the vec3 values, mix between them such that \n//  result=v1 at mod(x,4)=0,3\n//  result=v2 at mod(x,4)=1\n//  result=v3 at mod(x,4)=2\n\nvec3 periodicmix(vec3 v1, \n                 vec3 v2, \n                 vec3 v3, \n                 float x)\n{\n    float modx = mod(x, 3.);\n    return mix(v1, \n                mix(v2, \n                    mix(v3, \n                        v1,\n                        clamp(modx - 2., 0., 1.)), \n                    clamp(modx - 1., 0., 1.)), \n                clamp(modx, 0., 1.));\n}\n\n// **************************************************************************\n// SIGNAL FUNCTIONS\n// **************************************************************************\n\n\n// Returns a noise wave within the range [-1, 1] for which\n// each octave has a different scale on the phaseOffset.  The\n// phaseOffset is usually a dimension of time.\nvec3 phasedfractalwave(vec3 p, float phaseOffset)\n{       \n\n    // rotation matrix for noise octaves\n    mat3 octaveMatrix = mat3( 0.00,  0.80,  0.60,\n                              -0.80,  0.36, -0.48,\n                              -0.60, -0.48,  0.64 );\n\n    vec3 signal = .5 * sin(p + phaseOffset);\n    p = octaveMatrix*p*1.32;    \n    signal += .3 * sin(p + 2.2 * phaseOffset);\n    p = octaveMatrix*p*1.83;\n    signal += .2 * sin(p + 5.4 * phaseOffset);\n\n    signal /= 1.0;\n    return signal;\n}\n\n// Periodic saw tooth function that repeats with a period of \n// 4 and ranges from [-1, 1].  \n// The function starts out at 0 for x=0,\n//  raises to 1 for x=1,\n//  drops to 0 for x=2,\n//  continues to -1 for x=3,\n//  and then rises back to 0 for x=4\n// to complete the period\n\nfloat sawtooth( float x )\n{\n    float xmod = mod(x+3.0, 4.);\n    return abs(xmod-2.0) - 1.0;\n}\n\nvec3 xyz2rgb(vec3 xyz)\n{               \n    // Taken from XYZ to sRGB transformation:\n    // reference: http://en.wikipedia.org/wiki/SRGB    \n    mat3 xyz2rgbMat = mat3( 3.2404190, -1.5371500, -0.4985350,\n                           -0.9692560,  1.8759920,  0.0415560,\n                            0.0556480, -0.2040430,  1.0573110);\n     \n    vec3 color = xyz * xyz2rgbMat;\n\n    // Get sRGB out of its gamma space\n    color = pow(color, vec3(1./2.2));\n    return clamp(color, vec3(0.), vec3(1.));\n}\n\nvec3 blackBodyColor(float T)\n{\n    \n    float x = 0.;\n    float y = 0.;\n\n    // Cubic approximation of the Planckian Locus as a function of temperature\n    // reference: http://en.wikipedia.org/wiki/Planckian_locus\n    \n    // The approximation puts the color in CIE xyY space (Y is luminance, x\n    // and y are perseptively measured values that can be transformed into\n    // sRGB)\n    float T2 = T * T;\n    float T3 = T2 * T;\n\n    // DEBRANCHED\n    // Equivalent to :\n    // if (T < 4000.) {\n    //     x = (-0.2661239e9/T3 - 0.2343580e6/T2 + 0.8776956e3/T + .179910);\n    //     float x2 = x * x;\n    //     float x3 = x2 * x;\n    //     if (T < 2222.) {\n    //         y = -1.1063814*x3 - 1.34811020*x2 + 2.18555832*x - 0.20219683;\n    //     } else {\n    //         y = -0.9549476*x3 - 1.37418593*x2 + 2.09137015*x - 0.16748867;\n    //     }\n    // } else if (4000. <= T) {\n    //     x = (-3.0258469e9/T3 + 2.1070379e6/T2 + 0.2226347e3/T + .240390); \n    //     float x2 = x * x;\n    //     float x3 = x2 * x;\n    //     y = 3.0817580*x3 - 5.87338670*x2 + 3.75112997*x - 0.37001483;          \n    // }\n\n    float isTlt4000 = step(-4000., -T);\n    float isTlt2222 = step(-2222., -T);\n\n    float xlt4000 = (-0.2661239e9/T3 - 0.2343580e6/T2 + 0.8776956e3/T + .179910);\n    float xlt4000_2 = xlt4000 * xlt4000;\n    float xlt4000_3 = xlt4000_2 * xlt4000;\n    float ylt2222 = -1.1063814*xlt4000_3 - 1.34811020*xlt4000_2 + 2.18555832*xlt4000 - 0.20219683;\n    float ygt2222 = -0.9549476*xlt4000_3 - 1.37418593*xlt4000_2 + 2.09137015*xlt4000 - 0.16748867;\n\n    float xgt4000 = (-3.0258469e9/T3 + 2.1070379e6/T2 + 0.2226347e3/T + .240390); \n    float xgt4000_2 = xgt4000 * xgt4000;\n    float xgt4000_3 = xgt4000_2 * xgt4000; \n    float ygt4000 = 3.0817580*xgt4000_3 - 5.87338670*xgt4000_2 + 3.75112997*xgt4000 - 0.37001483;  \n    \n    x = mix(xgt4000, xlt4000, isTlt4000);\n    y = mix(mix(ygt2222, ylt2222, isTlt2222), ygt4000, isTlt4000);\n\n    // XXX: This smoothstep cheat from 1666 to 14000 is a cheat that looks\n    // perceptively good.  What I should be doing is calculating the maximum\n    // wavelength using Wien's displacement law and then finding the intensity\n    // by plugging that wavelength into Planck's law:\n    // http://en.wikipedia.org/wiki/Black-body_radiation\n    \n    // Translate from CIE xyY to CIE XYZ space which can then be transferred\n    // to sRGB space.\n    float Y = pow(smoothstep(1666., 14000., T), .25);  \n    float X = (Y/y) * x;\n    float Z = (Y/y) * ( 1. - x - y );\n\n    return xyz2rgb(vec3(X, Y, Z));\n\n}\n\n\n// **************************************************************************\n// INTERSECT UTILITIES\n// **************************************************************************\n\n// intersection for a sphere with a ray.\n//\n// If negateDiscriminant is set, this will act as if we're tracing a \n// \"black hole\" like effect where the hole size is the radius.\n//\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\n\nvec3 intersectSphere(vec3 rayOrigin,                 \n                     vec3 rayDir, \n                     float radius,\n                     vec3 sphereCenter,\n                     float negateDiscriminant)\n{\n\n    // Calculate the ray origin in object space of the sphere\n    vec3 ospaceRayOrigin = rayOrigin - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0*dot(ospaceRayOrigin, rayDir);\n    float c = dot(ospaceRayOrigin, ospaceRayOrigin) - radius*radius;\n    float discr = mix(1., -1., step(0.5, negateDiscriminant)) * (b*b - 4.0*a*c); // discriminant\n\n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (discr > 0.) {\n    //     ...\n    // }\n\n    float isdiscrgtZero = step(0., discr);\n\n    // Real root of disc, so intersection\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/(2.0 * a);\n    tmax = (-b + sdisc)/(2.0 * a); \n\n    float hit = max(step(0., tmin), step(0., tmax));\n\n    return mix(vec3(0.), vec3(hit, tmin, tmax), isdiscrgtZero);\n}\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the origin and has the specified normal.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\nvec2 intersectDSPlane(vec3 origin,\n                      vec3 dir,\n                      vec3 planeNormal,\n                      vec3 planeOffset)\n{\n    float dirDotN = dot(dir, planeNormal);\n    // if the ray direction is parallel to the plane, let's just treat the \n    // ray as intersecting *really* far off, which will get culled as a\n    // possible intersection.\n\n    float denom = zeroTolerantSign(dirDotN) * max(abs(dirDotN), EPSILON);\n    float t = min(BIG_FLOAT, -dot(planeNormal, (origin - planeOffset)) / denom);    \n    return vec2(step(EPSILON, t), t);\n\n}\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html Does an\n// intersection test against a plane that is assumed to  be single sided and\n// passes through a planeOffset and has the specified normal.\n\n// References: \n// http://www.geometrictools.com/Documentation/IntersectionLineCone.pdf\n// http://www.geometrictools.com/LibMathematics/Intersection/Intersection.html\n//\n// Does an intersection with an infinite cone centered at the origin and \n// oriented along the positive y-axis extending to infinite.  Returns the \n// minimum positive value of t if there is an intersection.  \n\n// This function works by taking in the latitudinal parameters from -PI/2 to\n// PI/2 which correspond to the latitudinal of the x-z plane.  The reference\n// provided assumes the angle of the cone is determined based on the cone angle\n// from the y-axis.  So instead of using a cosine of the angle as described in\n// the reference, we use a sine of the angle and also consider whether the\n// angle is positive or negative to determine which side of the pooled cone\n// we are selecting.\n//\n// If the angle of the z-x plane is near zero, this function just does a an\n// intersection against the x-y plane to handle the full range of possible\n// input.  This function clamps any angles between -PI/2 and PI/2.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\nvec2 intersectSimpleCone(vec3 origin,\n                         vec3 dir,\n                         float coneAngle)\n{\n    \n    // for convenience, if coneAngle ~= 0., then intersect\n    // with the x-z plane.      \n    float axisDir = zeroTolerantSign(coneAngle);\n    float clampedConeAngle = clamp(abs(coneAngle), 0., PI/2.);    \n    \n    float t = 0.;\n\n    if (clampedConeAngle < EPSILON) {\n        t = -origin.y / dir.y;\n        return vec2(step(0., t), t);\n    }\n    \n    // If coneAngle is 0, assume the cone is infinitely thin and no\n    // intersection can take place\n    if (clampedConeAngle < EPSILON) {\n        return vec2(0.);\n    }\n    \n    float sinAngleSqr = sin(clampedConeAngle);\n    sinAngleSqr *= sinAngleSqr;\n\n    // Quadric to solve in order to find values of t such that \n    // origin + direction * t intersects with the pooled cone.\n    // \n    // c2 * t^2 + 2*c1*t + c0 = 0\n    //\n    // This is a little math trick to get rid of the constants in the \n    // classic equation t = ( -b +- sqrt(b^2 - 4ac) ) / 2a\n    // by making b = 2*c1, you can see how this helps divide out the constants\n    // t = ( -2 * c1 +- sqrt( 4 * c1^2 - 4 * c2c0) / 2 * c2\n    // see how the constants drop out so that\n    // t = ( -c1 +- sqrt( c1^2 - c2 * c0)) / c2\n\n    // Lots of short cuts in reference intersection code due to the fact that\n    // the cone is at the origin and oriented along positive y axis.\n    // \n    // A := cone aligned axis = vec3(0., 1., 0.)\n    // E := origin - coneOrigin = origin\n    // AdD := dot(A, dir) = dir.y\n    // AdE := dot(A, E) = origin.y\n    // DdE := dot(dir, E) = dot(dir, origin)\n    // EdE := dot(E, E) = dot(origin, origin)\n    \n    float DdO = dot(dir, origin);\n    float OdO = dot(origin, origin);\n    \n    float c2 = dir.y * dir.y - sinAngleSqr;\n    float c1 = dir.y * origin.y - sinAngleSqr * DdO;\n    float c0 = origin.y * origin.y - sinAngleSqr * OdO;\n\n    float discr = c1*c1 - c2*c0;\n    float hit = 0.;\n\n    // if c2 is near zero, then we know the line is tangent to the cone one one\n    // side of the pool.  Need to check if the cone is tangent to the negative\n    // side of the cone since that could still intersect with quadric in one\n    // place.\n    if (abs(c2) > EPSILON) {\n    \n        if (discr < 0.0) {\n            \n            return vec2(0.);\n            \n        } else {\n    \n            // Real root of disc, so intersection may have 2 solutions, fine the \n            // nearest one.\n            float sdisc = sqrt(discr);\n            float t0 = (-c1 - sdisc)/c2;\n            float t1 = (-c1 + sdisc)/c2;\n    \n            // a simplification we can make since we know the cone is aligned\n            // along the y-axis and therefore we only need to see how t affects\n            // the y component.\n            float intersectPt0y = origin.y + dir.y * t0;\n            float intersectPt1y = origin.y + dir.y * t1;    \n            \n            // If the intersectPts y value is greater than 0. we know we've\n            // intersected along the positive y-axis since the cone is aligned\n            // along the y-axis\n    \n            // If the closest intersection point is also a valid intersection\n            // have that be the winning value of t.\n            \n            if ((t0 >= 0.) &&\n                (axisDir * intersectPt0y > 0.)) {\n                t = t0;\n                hit = 1.;\n            }\n            \n            if ((t1 >= 0.) &&\n                ((t1 < t0) || (hit < .5)) &&\n                (axisDir * intersectPt1y > 0.)) {\n                t = t1;     \n                hit = 1.;\n            }\n    \n        } \n\n    } else if (abs(c1) > EPSILON) {\n        // This is the code to handle the case where there  is a ray that is on\n        // the pooled cone and intersects at the very tip of the cone at the\n        // origin.\n        float t0 = -0.5 * c0 / c1;\n        \n        float intersectPty = origin.y + dir.y * t0;\n        if (( t0 >= 0.) && (axisDir * intersectPty > 0.)) {\n            t = t0;\n            hit = 1.;\n        }       \n    }\n    \n    return vec2(hit, t);\n\n}\n\n// Returns the vector that is the shortest path from the bounded line segment\n// u1->u2 to the line represented by the line passing through v1 and v2.  \n//\n// result.x is the distance of the shortest path between the line segment and\n// the unbounded line\n//\n// result.y = is the value of t along the line segment of ba [0,1] that \n// represents the 3d point (p) of the shortest vector between the two line \n// segments that rests on the vector between u1 anb u2 such that \n//    p = u1 + (u2-u1) * t\n//\n// result.z = is the value of t along the line passing through v1 and v2 such\n// that q represents the closest point on the line to the line segment u2<-u1:\n//    q = v1 + (v2-v1) * t\n// t is unbounded in this case but is parameterized such that t=0 at v1 and t=1\n// at v2.\n\nvec3 segmentToLineDistance( vec3 u1, \n                            vec3 u2, \n                            vec3 v1, \n                            vec3 v2 )\n{\n    vec3 u = u2 - u1;\n    vec3 v = v2 - v1;\n    vec3 w = u1 - v1;\n    \n    // For the maths:\n    // http://geomalgorithms.com/a07-_distance.html#dist3D_Segment_to_Segment\n    float a = dot(  u, u );\n    float b = dot(  u, v ); \n    float c = dot(  v, v );   \n    float d = dot(  u, w );\n    float e = dot(  v, w ); \n    \n    // just a way of calculating two equations with one operation.\n    // th.x is the value of t along ba\n    // th.y is the value of t along wv \n\n    // when a*c - b*b is near 0 (the lines are parallel), we will just assume\n    // a close line is the distance between u1 and v1\n    float denom = (a * c - b * b);\n\n    // DEBRANCHED\n    // Equivalent to:\n    // vec2 th = (abs(denom) < EPSILON ? vec2(0.) : \n    //                                  vec2( b*e - c*d, a*e - b*d ) / denom);\n\n    float clampedDenom = sign(denom) * max(EPSILON, abs(denom));\n    vec2 th = mix( vec2( b*e - c*d, a*e - b*d ) / clampedDenom, \n                   vec2(0.),\n                   step(abs(denom), EPSILON));\n\n    // In the case where the line to line comparison has p be a point that lives\n    // off of the bounded segment u2<-u1, just fine the closest path between u1\n    // and u2 and pick the shortest\n\n    float ifthxltZero = step(th.x, 0.);\n    float ifthxgt1 = step(1., th.x);\n\n    // DEBRANCHED\n    // Equivalent to:\n    // if (th.x < 0.) {\n    //     th.x = 0.;\n    //     th.y = dot(v, u1-v1) / c; // v . (u1<-v1) / v . v\n    // } else if (th.x > 1.) {\n    //     th.x = 1.;\n    //     th.y = dot(v, u2-v1) / c; // v . (u2<-v1) / v . v\n    // }\n    \n    th.x = clamp(th.x, 0., 1.);\n    th.y = mix(th.y, dot(v, u1-v1) / c, ifthxltZero);\n    th.y = mix(th.y, dot(v, u2-v1) / c, ifthxgt1);\n    \n    // p is the nearest clamped point on the line segment u1->u2\n    vec3 p = u1     + u  * th.x;\n    // q is the nearest unbounded point on the line segment v1->v2\n    vec3 q = v1     + v  * th.y;\n    \n    return vec3(length(p-q), th.x, th.y);\n}\n\n\n// Returns the vector that is the shortest path from the 3D point to the line\n// segment as well as the parameter t that represents the length along the line\n// segment that p is closest to.\n\n// Returned result is:\n\n// result.xyz := vector of the path from p to q where q is defined as the point\n// on the line segment that is closest to p.\n// result.w   := the t parameter such that a + (b-a) * t = q \n\nvec4 segmentToPointDistance( vec3 a, \n                             vec3 b, \n                             vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / max(EPSILON, dot(ba, ba));\n    t = clamp(t, 0., 1.);\n    vec4 result = vec4(ba * t + a - p, t);\n    return result;\n}\n\n// Returns the vector that is the shortest path from the 3D point to the  line\n// that passes through a and b as well as the parameter t that represents the\n// length along the line that p is closest to.\n\n// Returned result is:\n\n// result.xyz := vector of the path from p to q where q is defined as the point\n// on the line segment that is closest to p.\n// result.w   := the t parameter such that a + (b-a) * t = q \n\nvec4 lineToPointDistance( vec3 a, \n                          vec3 b, \n                          vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / dot(ba, ba);\n    vec4 result = vec4(ba * t + a - p, t);\n    return result;\n}\n\n// **************************************************************************\n// SHADING UTILITIES\n// **************************************************************************\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 I, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(1. - dot(-I, N), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// Classic formula for desaturating a color:\n// http://www.gamedev.net/topic/373341-colormath-desaturation/\nvec3 desat(vec3 color, float desatAmt)\n{\n    vec3 gray = vec3(dot(color, vec3(0.3, .59, .11)));\n    return mix(color, gray, desatAmt);\n}\n\n\n// **************************************************************************\n// AUDIO UTILITIES\n// **************************************************************************\n\nfloat getAudioScalar(float t)\n{\n\n    float audioScalar =  10. *  g_audioFreqs[0] * sin(-2.  * \n        (g_beatRate * g_time - PI_OVER_TWO * t));\n\n    audioScalar +=       5. *  g_audioFreqs[1] * sin(-4.  * \n        (g_beatRate * g_time - PI_OVER_TWO * t));\n\n    audioScalar +=       5. *  g_audioFreqs[2] * sin(-8.  * \n        (g_beatRate * g_time - PI_OVER_TWO * t));\n\n    audioScalar +=       5. *  g_audioFreqs[3] * sin(-16. * \n        (g_beatRate * g_time - PI_OVER_TWO * t));\n\n    return (audioScalar + 10.)/20.;\n}\n\n// **************************************************************************\n// TRACE UTILITIES\n// **************************************************************************\n\n// This ray structure is used to march the scene and accumulate all final\n// results.\n\nstruct SceneRayStruct {\n    vec3 origin;        // origin of the ray - updates at refraction, \n                        // reflection boundaries\n    vec3 dir;           // direction of the ray - updates at refraction, \n                        // reflection boundaries\n\n    float marchDist;    // current march distance of the ray - updated during\n                        // tracing\n    float marchMaxDist; // max march distance of the ray - does not update\n\n    vec4 color;         // accumulated color and opaqueness of the ray - updated\n                        // during tracing\n\n    vec4 debugColor;    // an alternative color that is updated during\n                        // traversal if it has a non-zero opaqueness, then it\n                        // will be returned to the frame buffer as the current\n                        // frag color. Alpha is ignored when displaying to the \n                        // frag color.\n};\n\n// Function used to determine if we should discontinue marching down this \n// ray.  Returns true when the ray should be terminated.\nbool shouldTerminateSceneRay(SceneRayStruct sceneRay)\n{\n    return ((sceneRay.marchDist >= sceneRay.marchMaxDist) || \n            (sceneRay.color.a > 0.95) ||\n            (sceneRay.debugColor.a > 0.));\n}\n\n// This ray structure is used to march through a space that represents the\n// interior of the orbs and is chopped up into cells whose boundaries are\n// aligned with the azimuthal and latitudinal angles of the sphere.\n\n// Looking at a cross section of the orb from the azimuthal direction (from\n// top down). You can see how in this case of a sphere divided into 8\n// subdomains, the cell coordinates wrap at the back of the sphere.\n\n//\n//        . * ' * .\n//      *   8 | 1   *\n//    *  \\    |    /  *\n//   /  7  \\  |  /  2  \\\n//  *________\\|/________*\n//  *        /|\\        *\n//   \\  6  /  |  \\  3  /\n//    *  /    |    \\  *\n//      *   5 | 4   *\n//        ' * . * ' \n//\n//        V Front V\n\n\n// Looking at a cross section of the orb from the side split down the center.\n// You can see in this example of the latitudinal cells having 4 subdomains\n// (or cells), the latitudinal cells are divided by cones originating from the\n// sphere center.\n\n//\n//        . * ' * .\n//      * \\   4   / *\n//    *    \\     /    *\n//   /  3   \\   /   3  \\\n//  *________\\ /________*\n//  *        / \\        *\n//   \\  2   /   \\   2  /\n//    *    /     \\    *\n//      * /   1   \\ *\n//        ' * . * '\n//\n//        V Bottom V\n\nstruct OrbRayStruct {\n    vec3 origin;                  // origin of the ray to march through the\n                                  // orb space - does not update\n    \n    vec3 dir;                     // direction of the ray to march through the\n                                  // orb space - does not update\n\n    float marchDist;              // current march distance of the ray through\n                                  // the sphere - updated during tracing\n\n    float marchNextDist;          // represents the next extent of the current\n                                  // cell so we can create a line segment on\n                                  // the ray that represents the part of the\n                                  // line that is clipped by the orb cell\n                                  // boundaries.  We then use this line\n                                  // segment to perform a distance test  of\n                                  // the spark\n\n    float marchMaxDist;           // max march distance of the ray - does not \n                                  // update represents the other side the sphere\n \n    int azimuthalOrbCellMarchDir; // when marching through the orb cells, we\n                                  // keep track of which way the ray is going\n                                  // in the azimuthal direction, so we only\n                                  // need to test against one side of the\n                                  // orb cell - a plane that lies on the\n                                  // y-axis and is rotated  based on the\n                                  // current cell.  This avoids precision\n                                  // issues calculated at beginning of\n                                  // traversal and used through out the\n                                  // iterations.\n\n    vec2 orbCellCoords;     \n                                  // Keep track of the current orb cell\n                                  // we're in: x is the latitudinal cell number\n                                  // y is the azimuthal cell number\n\n    vec4 color;                   // accumulated color and opaqueness of the ray\n                                  // marching the orbs.\n\n    vec4 debugColor;              // an alternative color that is updated during\n                                  // traversal if it has a non-zero opaqueness,\n                                  // then it will be returned to the frame\n                                  // buffer as the current frag color\n\n};\n    \n// Function used to determine if we should discontinue marching down this \n// ray.  Returns true when the ray should be terminated.\nbool shouldTerminateOrbRay(OrbRayStruct orbRay)\n{\n    return ((orbRay.marchDist >= orbRay.marchMaxDist) || \n            (orbRay.color.a > 0.95) ||\n            (orbRay.debugColor.a > 0.));\n}\n\n\n// Function used for ray marching the interior of the orb.  The sceneRay is \n// also passed in since it may have some information we want to key off of.\n//\n// Returns the OrbRayStruct that was passed in with certain parameters\n// updated.\nOrbRayStruct rayMarchOrbInterior(in OrbRayStruct orbRay)\n{    \n    \n    // Before marching into the orb coordinates, first determine if the orbRay\n    // is casting in the direction of the sphere where the \"angle\" is increasing\n    // along the azimuthal direction, in which case we assume we are marching\n    // along the azimuthal cells in a positive direction.\n\n    vec3 orbRayEnd = orbRay.origin + orbRay.dir * orbRay.marchMaxDist;\n    vec4 ltpresult = lineToPointDistance(orbRay.origin, orbRayEnd, vec3(0.));\n    vec3 ltp = ltpresult.xyz;\n    vec3 rdircrossltp = normalize(cross(orbRay.dir, ltp));\n        \n    orbRay.azimuthalOrbCellMarchDir = (dot(rdircrossltp, \n                                      vec3(0., 1., 0.)) > 0.) ? 1 : -1;  \n\n\n    // ------------------------------------------------------------\n    // Convert the cartesian point to orb space within the range\n    // Latitudinal    := [-PI/2, PI/2]\n    // Azimuth        := [-PI, PI]\n    vec2 orbRayOriginPt = cartesianToPolar(orbRay.origin);                \n    \n    //\n    // convert orb coordinates into number of spark domains       \n    // Latitudinal    := [-PI/2, PI/2]\n    // Azimuth        := [-PI, PI]\n    // LatdDomains    := [-numLatdDomains/2., numLatdDomains/2.] \n    // AzimuthDomains := [-numAzimDomains/2., numAzimDomains/2.]\n    // In order to avoid confusion        \n\n    orbRayOriginPt -= g_sparkRotationRate * g_time;\n    orbRayOriginPt *= g_numOrbCells * vec2(1./PI, 1./TWO_PI);\n\n    vec4 rOrbRayOriginPtResults = round_and_direction2(orbRayOriginPt);\n    vec2 cellCoords = vec2(rOrbRayOriginPtResults.xz);                        \n    cellCoords -= vec2(.5,.5) * rOrbRayOriginPtResults.yw;\n\n    orbRay.orbCellCoords = cellCoords;\n\n    // ------------------------------------------------------------\n    // March through the orb cells a fixed number of steps - can control\n    // quality knob by adjusting\n    \n    // Define the 3 spark colors that we'll be mixing between:\n\n    // XXX: the interpolation between colors is not correct (would be best to be \n    // in a perceptually linear space).  For next time...\n\n    vec3 sparkci1 = vec3(1.1, 0.5, 0.5);\n    vec3 sparkco1 = vec3(1.2, 1.2, 2.3);\n\n    vec3 sparkci2 = vec3(0.5, 0.2, 0.6);\n    vec3 sparkco2 = vec3(0.6, 0.8, 1.2);\n\n    vec3 sparkci3 = vec3(1.2, 0.8, 1.4);\n    vec3 sparkco3 = vec3(1.7, 1.3, 0.9);\n\n    for ( int i = 0; i < NUM_POLAR_MARCH_STEPS; i++)\n    {\n        // If orbRay color has near opaque opacity, no need to continue marching\n        if (shouldTerminateOrbRay(orbRay)) continue;\n        \n        vec3 marchPoint = orbRay.origin + orbRay.dir * orbRay.marchDist;\n        \n        // Convert the cartesian point to orb space within the range\n        // Latitudinal    := [-PI/2, PI/2]\n        // Azimuth        := [-PI, PI]\n        vec2 orbMarchPt = cartesianToPolar(marchPoint);                \n        \n        // convert orb coordinates into number of cell domains       \n        // From:\n        // Latitudinal    := [-PI/2, PI/2]\n        // Azimuth        := [-PI, PI]\n        // To:\n        // LatdDomains    := [-numLatdDomains/2., numLatdDomains/2.] \n        // AzimuthDomains := [-numAzimDomains/2., numAzimDomains/2.]\n\n        orbMarchPt -= g_sparkRotationRate * g_time;\n        orbMarchPt *= g_numOrbCells * vec2(ONE_OVER_PI, ONE_OVER_TWO_PI);\n\n        vec2 orbSparkStart = orbRay.orbCellCoords;     \n        \n        // convert back into orb coordinate range \n        // Latitudinal      := [-PI/2, PI/2]\n        // Azimuth        := [-PI, PI] \n        vec2 remapOrbSparkStart = orbSparkStart * vec2(PI, TWO_PI) / \n                                            g_numOrbCells;\n                \n        remapOrbSparkStart += g_sparkRotationRate * g_time;     \n                \n        // ------------------------------------------------------------------\n        // Spark color contribution\n\n        vec3 sparkDir = polarToCartesian(remapOrbSparkStart);\n        vec3 sparkOrigin = g_orbCenterRadius * sparkDir;\n        vec3 sparkEnd = g_orbOuterRadius * sparkDir;\n                \n        vec3 sparkResult = segmentToLineDistance(sparkOrigin,\n                                                 sparkEnd,\n                                                 orbRay.origin,\n                                                 orbRayEnd);\n\n        vec3 sparkColor = vec3(0.);\n        float sparkOpacity = 0.;        \n\n        float sparkSeed = (orbRay.orbCellCoords.x + g_numOrbCells.x *.5)/(g_numOrbCells.x);\n        float sparkSeedMix = step(1. - mod(g_time, g_sparkColorMixInterval)/g_sparkColorMixInterval, \n                                            sparkSeed);\n\n        float sparkColorMix = mix(g_sparkColorMixTrailingLimit,\n                                  g_sparkColorMixLeadingLimit,\n                                  sparkSeedMix);\n        \n        vec3 sparkColorInner = periodicmix(sparkci1, \n                                           sparkci2, \n                                           sparkci3, \n                                           sparkColorMix);\n\n        vec3 sparkColorOuter = periodicmix(sparkco1, \n                                           sparkco2, \n                                           sparkco3, \n                                           sparkColorMix);\n\n        float sparkGlowExtent = g_sparkWidth;\n\n        float audioScale = 1. + 2. * getAudioScalar(sparkResult.y);\n        audioScale = audioScale + .5 * g_bassBeat;\n        sparkGlowExtent *= audioScale;\n\n        float sparkAlphaExtent = 1.15 * sparkGlowExtent;\n        float sparkAttenuate = abs(sparkResult.x);\n\n        float sparkAmt = 1. * smoothstep(sparkAlphaExtent, \n                                         0., \n                                         sparkAttenuate);               \n        \n        // Multiply the spark color based on a black body curve.  The \n        // inputs to blackBodyColor is temperature in Kelvins.  The idea is\n        // that the spark is \"hotter\" towards the center.\n        \n        sparkColor = blackBodyColor(2000. + \n                                    10000. * sparkResult.y * audioScale) * \n                      mix(sparkColorInner, \n                          sparkColorOuter, \n                          sparkResult.y);\n\n        float sparkCorePresence = pow(smoothstep(sparkGlowExtent, \n                                           0., \n                                           sparkAttenuate),2.);\n\n        sparkColor = (g_sparkColorIntensity * (1. - orbRay.color.a) * \n                      sparkColor * sparkCorePresence);\n\n        sparkOpacity = ((1. - orbRay.color.a) * \n                        smoothstep(sparkAlphaExtent, \n                                   0., \n                                   sparkAttenuate));\n        \n\n        // ------------------------------------------------------------------\n        // Compute the cell bound marching\n        \n        // Test the boundary walls of a polar cell represented by the floor or ceil\n        // of the polarized march pt.  The boundary walls to test are determined\n        // based on how we're marching through the orb cells.\n\n        // Remember that x is the latitudinal angle so to find it's boundary, we\n        // intersect with a cone.  y is the azimuth angle so we can more simply\n        // intersect the plane that is perpendicular with the x-z plane and\n        // rotated around the y-axis by the value of the angle.\n\n        // Remember to remap the floors and ceils to   \n        // Latitudinal      := [-PI/2, PI/2]\n        // Azimuth          := [-PI, PI]\n        vec4 orbCellBounds = floorAndCeil2(orbRay.orbCellCoords) *\n            vec2(PI, TWO_PI).xxyy / g_numOrbCells.xxyy;\n        \n        orbCellBounds += g_sparkRotationRate.xxyy * g_time;\n        \n        float nextRelativeDist = orbRay.marchMaxDist - orbRay.marchDist;\n        float t = BIG_FLOAT;        \n        vec2 cellCoordIncr = vec2(0.);\n\n        // Intersect with the planes passing through the origin and aligned\n        // with the y-axis.  The plane is a rotation around the y-axis based\n        // on the  azimuthal boundaries.  Remember we know which direction the\n        // ray is traveling so we only need to test one side of the cell.        \n        float orbNextCellAzimAngle = (orbRay.azimuthalOrbCellMarchDir < 0 ? \n                                        orbCellBounds.z : orbCellBounds.w);\n\n        vec3 orbNextCellAzimBound = vec3(-sin(orbNextCellAzimAngle), \n                                          0., \n                                          cos(orbNextCellAzimAngle));\n\n        vec2 intersectResult = intersectDSPlane(marchPoint, orbRay.dir, \n                                                orbNextCellAzimBound, vec3(0.) );\n\n        // DEBRANCHED\n        // Equivalent to:\n        //\n        // if ((intersectResult.x > 0.5) && (nextRelativeDist > intersectResult.y)) {\n        //    nextRelativeDist = intersectResult.y;\n        //    cellCoordIncr = vec2(0., orbRay.azimuthalOrbCellMarchDir);            \n        // }\n\n        float isAzimPlaneHit = intersectResult.x * step(intersectResult.y, nextRelativeDist);\n        nextRelativeDist = mix(nextRelativeDist, intersectResult.y, isAzimPlaneHit);\n        cellCoordIncr = mix(cellCoordIncr, vec2(0., orbRay.azimuthalOrbCellMarchDir), isAzimPlaneHit);\n        \n        // XXX Future work: It would be nice if we only test one side of the\n        // cell wall in the latitudinal direction based on the direction of the\n        // orb ray as it marches through the cells, like what I'm doing with the\n        // azimuthal direction. But due to some shader issues and the extra\n        // complexity this adds to the  code, this seems like a more stable\n        // approach.  If we do go down this road, you could determine which\n        // direction the ray is travelling but you'll need to test if that ray\n        // crosses the \"dividing plane\" since the \"negative\" direction will\n        // become the \"positive\" direction at  that point.  Perhaps this\n        // indicates I need to rethink how the  orb cell coordinates are\n        // defined.  I think solving this problem will get to the bottom of the\n        // flickering that happens.\n\n        // Test the top of the current orb cell\n        intersectResult = intersectSimpleCone(marchPoint, orbRay.dir, orbCellBounds.x);\n\n        // DEBRANCHED\n        // Equivalent to:\n        //\n        // if ((intersectResult.x > 0.5) && (nextRelativeDist > intersectResult.y)) {\n        //    nextRelativeDist = intersectResult.y;\n        //    cellCoordIncr = vec2(-1., 0.);            \n        // }\n        \n        float isTopConeHit = intersectResult.x * step(intersectResult.y, nextRelativeDist);\n        nextRelativeDist = mix(nextRelativeDist, intersectResult.y, isTopConeHit);\n        cellCoordIncr = mix(cellCoordIncr, vec2(-1, 0.), isTopConeHit);\n\n        // Test the bottom of the current orb cell\n        intersectResult = intersectSimpleCone(marchPoint, orbRay.dir, orbCellBounds.y);\n\n        // DEBRANCHED\n        // Equivalent to:\n        //\n        // if ((intersectResult.x > 0.5) && (nextRelativeDist > intersectResult.y)) {\n        //    nextRelativeDist = intersectResult.y;\n        //    cellCoordIncr = vec2(-1., 0.);            \n        // }\n\n        float isBottomConeHit = intersectResult.x * step(intersectResult.y, nextRelativeDist);\n        nextRelativeDist = mix(nextRelativeDist, intersectResult.y, isBottomConeHit);\n        cellCoordIncr = mix(cellCoordIncr, vec2(1, 0.), isBottomConeHit);\n        \n        // ------------------------------------------------------------------\n        // Update orbRay for next march step\n\n        // We now know what cell we're going to march into next\n        // XXX: There is a fudge factor on the EPSILON here to get around some\n        // precision issues we're seeing with intersecting the simple cones. \n        // This probably indicates there is something flawed in the cell logic\n        // traversal.\n        orbRay.marchNextDist = min(orbRay.marchMaxDist, orbRay.marchDist + nextRelativeDist + 35. * EPSILON);\n        orbRay.orbCellCoords += cellCoordIncr;\n\n        // Make sure that y wraps (the azimuthal dimension) when you've reached\n        // the extent of the number of orb cells\n        orbRay.orbCellCoords.y = mod(orbRay.orbCellCoords.y + g_numOrbCells.y/2., \n                                     g_numOrbCells.y) - g_numOrbCells.y/2.;\n        \n        orbRay.marchDist = orbRay.marchNextDist;        \n        \n        // ------------------------------------------------------------------\n        // Shade the center of the orb interior itself (only if this cell's\n        // march has intersected with that center interior).  Avoid an if \n        // statement here by having the signal that drives the presense of \n        // this color come on only when the ray is intersecting that orb\n        // interior.\n\n        vec3 orbCenterColor = sparkColorInner * blackBodyColor(14000.);\n        vec3 marchExit = orbRay.origin + orbRay.dir * orbRay.marchNextDist;  \n\n        vec4 segToPtResult = segmentToPointDistance(marchPoint,\n                                                    marchExit,\n                                                    vec3(0.));\n        \n        float distToCenter = length(segToPtResult.xyz);\n\n        float centerOrbProximityMask = smoothstep(g_orbCenterRadius + 1., \n                                                  g_orbCenterRadius, \n                                                  distToCenter);\n\n        float sparkOriginGlowMaxDist = mix(2.5, 0.5, \n                                           smoothstep(8., \n                                                      128., \n                                                      min(g_numOrbCells.x, \n                                                          g_numOrbCells.y)));\n        \n        float sparkOriginGlow = min(sparkOriginGlowMaxDist, abs(sparkOriginGlowMaxDist - \n                                      distance(segToPtResult.xyz, sparkOrigin)));\n        \n        sparkOriginGlow = pow(sparkOriginGlow, 3.);\n\n        // Spark origin contribution\n        sparkColor += .06 * centerOrbProximityMask * sparkOriginGlow * orbCenterColor;\n        sparkOpacity += .06 * centerOrbProximityMask * sparkOriginGlow;\n        \n        float isMarchIntersectingCenterOrb = smoothstep(g_orbCenterRadius + .1, \n                                                        g_orbCenterRadius, distToCenter);\n\n        float centerOrbGlow = .4 * g_sparkColorIntensity * max(0., \n                    1. - dot(-normalize(segToPtResult.xyz), orbRay.dir));\n\n        centerOrbGlow = pow(centerOrbGlow, .6);\n\n        // Center orb glow - independent of sparks\n        sparkColor += max(0., (1. - sparkOpacity)) * orbCenterColor * centerOrbGlow * isMarchIntersectingCenterOrb;\n                \n        orbRay.color.rgb += (1. - orbRay.color.a) * sparkColor;\n        orbRay.color.a += (1. - orbRay.color.a) * sparkOpacity;\n                                \n        // If we want to terminate march (because we intersected the center orb), \n        // then make sure to make the alpha for this orb ray 1. \n        orbRay.color.a += (1. - orbRay.color.a) * isMarchIntersectingCenterOrb;        \n\n    }\n    \n    return orbRay;\n}\n\nSceneRayStruct traceHorizon(SceneRayStruct ray)\n{\n\n    // Simple infinite horizon lookup.\n    vec3 hitPoint = ray.origin + 2000. * ray.dir;\n\n    vec3 horizonColor = vec3(0.1,0.5, 0.9);\n    vec3 skyColor = vec3(0.1, 0.1, 0.3);\n    ray.color.rgb += (1. - ray.color.a) * mix(horizonColor, \n                                              skyColor, \n                                              smoothstep(0., 900., abs(hitPoint.y)));\n    ray.color.a = 1.;\n\n    return ray;\n}\n\nSceneRayStruct tracePoolSurface(SceneRayStruct ray)\n{\n\n    // pool plane direction and offset into the ground\n    vec2 intersectResult = intersectDSPlane(ray.origin, ray.dir,\n                                             vec3(0., 1., 0.),                                             \n                                             vec3(0., -42, 0.)); \n\n\n    vec3 hitPoint = ray.origin + ray.dir * intersectResult.y;\n    vec3 hitNormal = vec3(0., 1., 0.);\n\n    // bump mapping\n    float perturbStepOff = smoothstep(2000., 200., distance(g_camOrigin, hitPoint));\n    vec3 perturb = perturbStepOff * phasedfractalwave(.0125 * hitPoint, .5 * g_time);\n    perturb.y = 0.;\n    hitNormal += .2 * perturb;\n    hitNormal = normalize(hitNormal);\n    \n    vec3 reflectDir = reflect(ray.dir, hitNormal);\n\n    // Trace the reflection of the orb in the plane.\n    SceneRayStruct reflRay = SceneRayStruct(hitPoint, // origin\n                                            reflectDir, // direction\n                                            0., // current march depth\n                                            BIG_FLOAT, // max march depth                                            \n                                            vec4(0.), // color\n                                            vec4(0.)); // debug color\n\n    // If the orb was not scene in the pool plane, then continue the ray\n    // into the horizon.\n    reflRay = traceHorizon(reflRay);\n\n    // Apply a fresnel effect as if the pool was made of water.  We are\n    // cheating the fresnel effect a bit by specifying a facing kr and an\n    // edge on kr.  More creative control.\n    float reflectRatio = fresnel(ray.dir,\n                               hitNormal, \n                               1. / g_poolSurfaceIOR).x;\n\n    // The pool plane is fully opaque.\n    ray.color.rgb += intersectResult.x * (1. - ray.color.a) * \n        mix(g_poolSurfaceFacingKr, g_poolSurfaceEdgeOnKr, reflectRatio) * \n        reflRay.color.rgb;\n\n    ray.color.a = mix(ray.color.a, 1., intersectResult.x);\n\n    return ray;\n}\n\nSceneRayStruct traceOrbWarp(SceneRayStruct ray)\n{\n\n    // --------------------------------------------------------------------\n    // Intersect the warp around the orb\n\n    vec3 intersectResult = intersectSphere(ray.origin, ray.dir,\n                                            g_orbOuterRadius,\n                                            g_orbPosition, 1.);\n\n    if (intersectResult.x > .5) {       \n        // Apply the warp to the ray and let it continue tracing.\n        vec3 hitPoint = ray.origin + intersectResult.y * ray.dir;\n\n        vec3 ohitPoint = hitPoint - g_orbPosition;\n        vec3 hitNormal = normalize(ohitPoint);\n        vec3 reflectDir = normalize(reflect(ray.dir, hitNormal));   \n\n        ray.origin = hitPoint;\n        ray.dir    = reflectDir;\n    }\n        \n    return ray;\n}\n\n\nSceneRayStruct traceOrb(SceneRayStruct ray)\n{\n\n    // --------------------------------------------------------------------\n    // Intersect Orb test    \n\n    vec3 intersectResult = intersectSphere(ray.origin, ray.dir,\n                                            g_orbOuterRadius,\n                                            g_orbPosition, 0.);\n\n                                      \n    if (intersectResult.x > 0.5) {\n        ray.marchDist += intersectResult.y;\n\n        vec3 hitPoint = ray.origin + intersectResult.y * ray.dir;\n\n        // Translate the hit point into object space of the sphere, we march\n        // the interior assuming the sphere is at the origin.\n        vec3 ohitPoint = hitPoint - g_orbPosition;\n        \n        vec3 hitNormal = normalize(ohitPoint);\n        \n        // --------------------------------------------------------------------\n        // Environment map reflection on orb surface\n\n        vec3 reflectDir = normalize(reflect(ray.dir, hitNormal));   \n\n        SceneRayStruct reflRay = SceneRayStruct(hitPoint, // origin\n                                                reflectDir, // direction\n                                                0., // current march depth\n                                                BIG_FLOAT, // max march depth\n                                                vec4(0.), // color\n                                                vec4(0.)); // debug color\n\n        reflRay = tracePoolSurface(reflRay);\n        reflRay = traceHorizon(reflRay);\n\n        vec3 reflColor = reflRay.color.rgb * reflRay.color.a;\n        // Add the environment look up (heavily desaturated), to make the \n        // rim more interesting on the orb.\n        reflColor += .8 * desat(texture(iChannel0, reflectDir).rgb, .6);        \n\n        float reflectRatio = fresnel(ray.dir, \n                                     hitNormal, \n                                     1. / g_orbIOR).x;\n\n        ray.color.rgb += (mix(g_orbSurfaceFacingKr, g_orbSurfaceEdgeOnKr, reflectRatio) * \n                          reflColor);\n        ray.color.a += (1. - ray.color.a) * reflectRatio;\n\n        // --------------------------------------------------------------------\n        // Calculate the interior distance to march\n         \n        vec3 refractDir = normalize(refract(ray.dir, hitNormal, 1. / g_orbIOR));    \n            \n        // Consider the interior sphere when ray marching?\n        vec3 innerIntersectResult = intersectSphere(ohitPoint, refractDir, \n                                                    g_orbCenterRadius,\n                                                    vec3(0.), 0.);\n            \n        float interiorSphereHitDist = mix(BIG_FLOAT, innerIntersectResult.y, innerIntersectResult.x);\n\n        // --------------------------------------------------------------------\n        // Orb Interior Shading     \n\n        float rayExtent = min(interiorSphereHitDist, intersectResult.z - intersectResult.y);\n        \n\n        OrbRayStruct orbRay = OrbRayStruct(ohitPoint, // origin\n                                           refractDir, // dir\n                                           0., // ray parameterized start\n                                           0., // the next ray march step\n                                           rayExtent, // ray parameterized end\n                                           0, //  azimuthalOrbCellMarchDir\n                                           vec2(0.), // orbCellCoords\n                                           vec4(0.), // color\n                                           vec4(0.));  // debugColor \n\n        orbRay = rayMarchOrbInterior(orbRay); \n\n        // --------------------------------------------------------------------\n        // Transfer the orb ray march results to the scene ray trace IF we actually\n        // intersected with the orb at all. \n\n        ray.color.rgb += (1. - ray.color.a) * orbRay.color.rgb;\n        ray.color.a += (1. - ray.color.a) * orbRay.color.a;\n\n        ray.debugColor += orbRay.debugColor;\n\n        // Update the ray to be refracted out the back and reset the march\n        // distance.\n        ray.origin = ray.origin + refractDir * rayExtent;\n        vec3 exitNormal = normalize(-ray.origin);\n\n        ray.dir = refract(refractDir, exitNormal, 1. / g_orbIOR);\n        ray.marchDist = 0.;\n        ray.marchMaxDist = BIG_FLOAT;\n\n        reflectRatio = fresnel(refractDir, \n                               -exitNormal, \n                               1. / g_orbIOR).x;\n\n        ray.color.a += (1. - ray.color.a) * \n            mix(g_orbSurfaceEdgeOnKr, g_orbSurfaceFacingKr, (1. - reflectRatio));\n    }\n        \n    return ray;\n}\n\n\nSceneRayStruct traceScene(SceneRayStruct ray)\n{\n\n    // Perform the tracing of the scene, first by finding any orb to\n    // trace, then if the ray still has \"transparency\" worth \n    // tracing, continue to trace the pool plane and then the horizon.\n    // The order of tracing calls is important since recursion \n    // isn't possible.   \n    \n    ray = traceOrb(ray);\n    \n    ray = traceOrbWarp(ray);\n\n    ray = tracePoolSurface(ray);\n        \n    ray = traceHorizon(ray);\n\n    return ray;\n}\n\n\n// **************************************************************************\n// MAIN\n// **************************************************************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tg_time = iTime;\n\tg_numOrbsChangeRate = vec2(g_beatRate * 0.05, g_beatRate * 0.0625);\n\tg_sparkRotationRate = vec2(.0, g_beatRate * .25);\n \tg_camYRotationRate = -0.0625 * g_beatRate;\n \tg_camXRotationRate = 0.125 * g_beatRate;\n    \n    // --------------------------------------------------------------------\n    // Place for animating global state\n\n    float numOrbCellsXChangeTime = max(0., g_time - OURPITHYATOR_START);\n    g_numOrbCells.x = 8. + 4. * (5. * (sawtooth( g_numOrbsChangeRate.x * \n                                                 numOrbCellsXChangeTime + 1.)) +\n                                    5.);\n    \n    float numOrbCellsYChangeTime = max(0., g_time - OURPITHYATOR_FIRSTDROP);\n    g_numOrbCells.y = 8. + 8. * pow(2., floor(3. * sawtooth( g_numOrbsChangeRate.y * \n                                                        numOrbCellsYChangeTime + 4.) + \n                                        3.));\n    \n    // Would be nice if I could find a way to ramp off of the beat better, but that\n    // would require some history knowledge.\n    g_bassBeat = smoothstep(0.91, 1.03, texture( iChannel1, vec2( 0.01, 0.1 ) ).r);\n    \n    // Round off the pop by raising the beat to a tweaked power\n    g_bassBeat = pow(g_bassBeat, 0.5) * g_audioResponse;\n    \n    g_audioFreqs[0] = pow(texture( iChannel1, vec2(0.2, 0.05)).r, 0.5) * g_audioResponse;\n    g_audioFreqs[1] = pow(texture( iChannel1, vec2(0.4, 0.05)).r, 0.5) * g_audioResponse;\n    g_audioFreqs[2] = pow(texture( iChannel1, vec2(0.6, 0.05)).r, 0.5) * g_audioResponse;\n    g_audioFreqs[3] = pow(texture( iChannel1, vec2(0.8, 0.05)).r, 0.5) * g_audioResponse;\n    \n    g_orbOuterRadius = 40. * mix(1., 1.05, g_bassBeat); \n    g_orbCenterRadius = 5. * mix(1., .98, g_bassBeat); \n    g_sparkColorIntensity = mix(1., 1.4, g_bassBeat);\n    \n    float colorChangeRate = 1.;\n    // offset spark color mix by 2 seconds to hit the first electronic flange\n    // event.\n    float sparkColorMixModTime = mod(g_time + 2., colorChangeRate * 52. / g_beatRate);\n\n    // The following bit of logic is used to have the sparks transition from one\n    // color to the next in a vegas like strobe.  The idea is that the  first\n    // set of sparks transition using the leading limit and then the  sparks\n    // catch up to the trailing limit.  The sweep through the orb spark cells is\n    // carefully timed to these transitions and the spark color mix interval.\n    g_sparkColorMixInterval = colorChangeRate * 4. / g_beatRate;\n\n    g_sparkColorMixLeadingLimit = smoothstep(colorChangeRate * 16. / g_beatRate ,  \n                                         colorChangeRate * 17. / g_beatRate, \n                                         sparkColorMixModTime) +\n                              smoothstep(colorChangeRate * 32. / g_beatRate ,  \n                                         colorChangeRate * 33. / g_beatRate, \n                                         sparkColorMixModTime) +\n                              smoothstep(colorChangeRate * 48. / g_beatRate ,  \n                                         colorChangeRate * 49. / g_beatRate, \n                                         sparkColorMixModTime);\n\n    g_sparkColorMixTrailingLimit = smoothstep(colorChangeRate * 19. / g_beatRate ,  \n                                         colorChangeRate * 20. / g_beatRate, \n                                         sparkColorMixModTime) +\n                              smoothstep(colorChangeRate * 35. / g_beatRate ,  \n                                         colorChangeRate * 36. / g_beatRate, \n                                         sparkColorMixModTime) +\n                              smoothstep(colorChangeRate * 51. / g_beatRate ,  \n                                         colorChangeRate * 52. / g_beatRate, \n                                         sparkColorMixModTime);\n    \n    g_orbPosition = g_camPointAt;\n    g_orbPosition += vec3(20. * cos(.4 * g_time), \n                         20. * (.5 * sin(.5 * g_time) + .5), \n                         -20. * sin(.4 * g_time) + 0.);\n    \n\n    // Shake the camera's focus object a bit with the bass beat - imagine the\n    // beat shaking the camera holder.  So we precalculate the camera dimensions\n    // here pre-shake and then once again when we determine the final values\n    \n    // calculate the rayDirection that represents mapping the image plane\n    // towards the scene\n    vec3 cameraZDir = normalize( g_camPointAt - g_camOrigin );\n    vec3 cameraXDir = normalize( cross(cameraZDir, g_camUpDir) );\n    vec3 cameraYDir = cross(cameraXDir, cameraZDir);\n    g_camPointAt += 0.2 * cameraYDir * sin(16. * g_beatRate * g_time) * g_bassBeat;\n\n    // --------------------------------------------------------------------\n    \n    // Shift p so it's in the range -1 to 1 in the x-axis and 1./aspectRatio\n    // to 1./aspectRatio in the y-axis (a reminder aspectRatio := width /\n    // height of screen)\n    \n    // I could simplify this to:\n    // vec2 p = fragCoord.xy / iResolution.xx; <- but that's a bit obtuse\n    // to read.\n\n    vec2 p = fragCoord.xy / iResolution.xy;      \n    float aspectRatio = iResolution.x / iResolution.y;\n    p = 2.0 * p - 1.0;\n    p.y *= 1./aspectRatio;\n    \n    // Do the same to the click position\n    vec2 click = iMouse.xy / iResolution.xy;    \n    click = 2.0 * click - 1.0;\n    click.y *= 1./aspectRatio;\n    \n    // camera movement  \n    float xrot = 1. * PI_OVER_TWO * (.25 * sin(g_camXRotationRate * g_time + \n                                         TWO_PI * click.y + PI_OVER_TWO) + .1);\n    g_camOrigin = rotateAroundXAxis( g_camOrigin, xrot);\n    g_camOrigin = rotateAroundYAxis( g_camOrigin, \n                            g_camYRotationRate * g_time - PI * click.x);\n    \n    // re-calculate the rayDirection that represents mapping the  image plane\n    // towards the scene - post beat.\n    cameraZDir = normalize( g_camPointAt - g_camOrigin );\n    cameraXDir = normalize( cross(cameraZDir, g_camUpDir) );\n    cameraYDir = normalize( cross(cameraXDir, cameraZDir) );\n    \n    // cheap way to provide a focal length by adjusting.  Make the constant in\n    // front of cameraZDir (camFocalLengthScalar) bigger to tighten focus,\n    // smaller to  widen focus.\n\n    vec2 uv = p*0.5+0.5;\n    float vignet = 0.2 + 0.8 * pow(10.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.3);\n    float camFocalLengthScalar = vignet;\n    vec3 camRayDir = normalize( p.x*cameraXDir + p.y*cameraYDir + \n                                camFocalLengthScalar * cameraZDir );    \n    \n    // Construct scene ray shooting from the camera\n    SceneRayStruct ray = SceneRayStruct(g_camOrigin, // origin\n                                        camRayDir, // direction\n                                        0., // current march depth\n                                        BIG_FLOAT, // max march depth\n                                        vec4(0.), // color\n                                        vec4(0.)); // debug color\n    \n    // Perform the trace on the scene.  The ray will have the final\n    // color in ray.color.\n    ray = traceScene(ray);\n\n    vec4 tracedColor = ray.color;\n\n    // multiply the alpha onto the color.  If you want info on why I do this,\n    // consult the source paper:\n    // http://graphics.pixar.com/library/Compositing/paper.pdf\n    tracedColor.rgb *= min(1., tracedColor.a);\n\n    // --------------------------------------------------------------------\n    // color-grading - simple color adjustment curve\n    tracedColor.rgb = pow(tracedColor.rgb, vec3(1.4));\n    \n    // vigneting\n    tracedColor *= vignet;\n    \n    fragColor = tracedColor;\n    \n    // Debug color's alpha is not multiplied during final output.  If it is \n    // non-zero, then the debugcolor is respected fully \n    fragColor.rgb = mix(fragColor.rgb, ray.debugColor.rgb, \n                           step(EPSILON, ray.debugColor.a));\n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mss3DS","date":"1378789973","viewed":1763,"name":"Audio Synth Orb","username":"mplanck","description":"This started as trying to mimic a plasma ball and turned into something entirely different.  Adjust NUM_POLAR_MARCH_STEPS depending on compute power.","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","accelerationstructures","audiosync"],"hasliked":0,"parentid":"","parentname":""}}