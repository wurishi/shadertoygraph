{"ver":"0.1","info":{"id":"lfGGWd","date":"1713419870","viewed":109,"name":"Liminal Drops V2","username":"FatLenny","description":"@kishimisu youtube tutorial for raymarching","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial","canvas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Liminal Drops V1\" by FatLenny. https://shadertoy.com/view/lcV3Dc\n// 2024-04-18 05:57:31\n\n// Fork of \"Liminal Drops\" by FatLenny. https://shadertoy.com/view/Xcc3zN\n// 2024-04-17 19:21:00\n\n// Fork of \"Basic Raymarching Shader\" by None. https://shadertoy.com/view/-1\n// 2024-03-26 05:42:39\n\n    //DEFINING OBJECTS IN OUR SCENE\nvec3 hash( vec3 p )      // this hash is not production ready, please\n{                        // replace this by something better\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n    // this function takes a 3D point as input and returns the distance to the nearest object in the scene\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d );                   \n}\n\nfloat sdSphere(vec3 p, float s) {\n   \n    \n    // for now, returns distance to a sphere of radius 1.0 located at the origin\n    return length(p) - s;  \n    \n}\n\nfloat sdCube( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle))\n               + cross(axis, p) *sin(angle);\n}\n\n//SMOOTH COMBINING OF SHAPES WHERE K IS SMOOTHIG FACTOR\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.2, 0.4, 0.55);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat map(vec3 p) {\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;// Normalize mouse position to fit canvas\n    //vec3 spherePos = vec3(mp.x,mp.y, 1.0);// Initialize position at zero\n    //vec3 spherePos = vec3(0, 0, 0);// Initialize position at zero\n    \n    vec3 pNoise = p;\n    vec3 pNoise2 = p;\n    vec4 fullNoise = noised(pNoise+iTime*0.5+iTime*0.5);\n    vec4 fullNoise2 = noised(pNoise+iTime*0.5-iTime*0.8);\n    pNoise = fullNoise.yzw;\n    pNoise2 = fullNoise2.yzw;\n     \n    \n    vec3 fs = p;\n    fs.x += 3.5;\n    fs.z -= 2.2;\n    fs.y += iTime;\n    fs.y = mod(fs.y, 13.0) - 6.5;\n    \n    //float angle = iTime;\n    //float ssc = 0.5; // Sphere scaling factor\n    //float csc = 2.0; // Cube scaling factor\n    \n    float sphere = sdSphere(fs, 1.5);// Return a new sphere whose old location has been \n \n    vec3 es = p;\n    es.x += 3.5;\n    es.z -= 2.2;\n    es.y += iTime;\n    es.y = mod(es.y, 13.0) - 6.5;\n \n    float sphere2 = sdSphere(es, 2.0);// clone sphere for effects\n    \n    // MOUSE SPHERE\n    vec3 mfs = p;\n    mfs.x -= 2.0;\n    mfs.x -= 6.25-1.0;\n    mfs.z -= 5.2;\n    mfs.z -= 10.25-1.0;\n    mfs.y -= iTime*5.0;\n    mfs.y = mod(mfs.y, 3.0) - 1.5;\n    \n    //float angle = iTime;\n    //float ssc = 0.5; // Sphere scaling factor\n    //float csc = 2.0; // Cube scaling factor\n    \n    float msphere = sdSphere(mfs, 0.3);// Return a new sphere whose old location has been \n     \n    //MOUSE SPHERE EFFECTS \n    vec3 mes = p;\n    mes.x -= 2.0;\n    mes.x -= 6.25-1.0;\n    mes.z -= 5.2;\n    mes.z -= 10.25-1.0;\n    mes.y -= iTime*5.0-1.2;\n    mes.y = mod(mes.y, 3.0) - 1.5;\n \n    float msphere2 = sdSphere(mes, 1.5);// clone sphere for effects\n     \n    \n    vec3 cs = p;\n    cs.y -= 3.5;\n    cs.xz = fract(cs.xz) - 0.5;\n       \n    vec3 cs2 = p;\n    cs2.y -= 2.5;\n    cs2.xz = fract(cs2.xz) - 0.5;\n    \n    \n    \n    float cubesky = sdCube(cs, vec3(1.0));\n    \n    vec3 cg = p;\n    cg.y += 3.5;\n    cg.xz = fract(cs.xz) - 0.5;\n    \n    float cubeground = sdCube(cg, vec3(1.0));\n    //vec3 ct = p;// Vector used to transform the cube\n\n    //vec3 fc = ct;// Vector used to fractalize the cube\n    //vec3 fp = p;// Vector used to fractalize the scene\n    \n    \n    //ct.y += 0.5;\n    \n    \n    //ct.z -= iTime * 0.8;\n    \n    //ct.xz = fract(ct.xz) - 0.5;\n    \n    //ct.yz *= rot2d(angle);// Rotate around x axis\n    //ct.xz *= rot2d(angle);// Rotate around y axis\n    //ct.xy *= rot2d(angle);// Rotate around z axis\n   \n   \n    // Order of operations for transformations is important because you will get a \n    // different outcome depending on the order they are applied in\n   \n    \n    \n   \n    //float cube = sdCube(ct, vec3(0.1));\n    \n    \n    float ground = p.y + 4.5;// The ground is wherever is directly under the ray, ot its y position plus an offset\n    float mground = p.y + 4.5;\n    ground += pNoise.z*0.03;\n    //cubesky += pNoise2.y*0.2;\n    cubesky -= sin(sint(cubesky, pNoise2.z*0.2,1.0));\n    \n    \n    float skyhole;\n    float groundhole;\n    \n    skyhole = ssub(msphere2, cubesky, 0.5);\n    groundhole = ssub(sphere2, ground, 2.0);    \n     \n    float skydrip;\n    float grounddrip;\n    \n    float shapes;\n\n    \n    skydrip = smin(sphere, skyhole, 2.0);\n    grounddrip = smin(msphere, groundhole, 2.0);\n    \n    shapes = min(skydrip, grounddrip);\n  \n    return shapes;// Combining all of our shapes and the ground with smoothing \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float fov = 1.0;\n    \n    // INITIALIZATION FOR RAYMARCHING\n\n    // fragCoord holds coords of every pixel\n    vec2 uv =(fragCoord *2.0 - iResolution.xy) / iResolution.y; \n    \n    vec3 uvNoise = vec3(uv,0.0);\n    vec4 fullNoise = noised(uvNoise+iTime*0.005+iTime*0.05);\n    uvNoise = fullNoise.yzw;\n    \n    // Normalize mouse position to fit canvas\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mp2 = (iMouse.zw * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // corresponds to the camera's curent position in our world\n    vec3 ro = vec3(0, 0, -3);// Ray origin \n  \n    // we can use UV as x and y coords because we decided to alignd the world x and y axis with our UV coords\n    // this allows each pizel to have a unique direction spreading out from the center of our screen\n    // this effectively creates a virtual canvas to project the world to\n    // Step 1: \n    // vec3 rayDirection = vec3(uv, 1);\n    \n    // now we normalize the vectors to ensure they all have a length of 1.0 which is crucial for distance calcs    \n    // step 2:\n    vec3 rd = normalize(vec3(uv * fov, 1)); // Ray direction\n\n    // this represents the final pixel color once we have completed the raymarch\n    vec3 col = vec3(0.0);   \n    \n    //create a float to keep track of the current distance the point has traveled from rayOrigin \n    float dt = 0.0;// Distance traveled\n    \n    // CAMERA ROTATION\n    \n    // Vertical rotation\n    ro.yz *= rot2d(+0.4);\n    rd.yz *= rot2d(+0.4);\n    ro.yz *= rot2d(-0.1);\n    rd.yz *= rot2d(-0.1);\n    \n    // Horizontal rotation\n    //ro.xz *= rot2d(-mp.x*2.0);\n    //rd.xz *= rot2d(-mp.x*2.0);\n    ro.xz *= rot2d(-mp.x*4.0);\n    rd.xz *= rot2d(-mp.x*4.0);\n    \n    // END OF INITIALIZATION\n\n    // BEGIN RAYMARCHING\n    \n    // i represents the current raymarching step with a max of 80 iterations\n    // the max iterations affects the QUALITY of the result and the PERFORMANCE\n    // too few steps may not allow the ray to reach an object, while too many will impast shader performance\n    // this parameter needs to be adjusted to fit your specific scene\n    int i;\n    for(i = 0; i < 80; i++)\n    {\n    \n        // create a vec3 that indicates the position along the ray based on its distance from the origin\n        // we use this point to compute the distance to the closest object in the scene\n        // the point starts at the ray's origin because distTraveled is initialized to 0.0\n        // we do this using signed distance functions (SDF)\n        // info on SDF related to raymarching: https://iquilezles.org/articles/distfunctions/\n        vec3 p = ro + rd * dt;// Position along ray\n\n        // use mapDistance function to get the distance to the scene given our current position along the ray\n        // this value represents the distance the point can travel in any direction until encountering an object\n        float ds = map(p); // Distance to scene\n\n        // here we are \"marching\" the ray forward based on the distance we got from getDistance()\n        // in other words we are calculating the distance to the closest object in the scene\n        // we then use this distance to \"safely\" march the ray forward, knowing we will not hit an object at that distance\n        // now we repeat the for loop until we either hit an object or exceed the max marching steps we set \n        dt += ds;\n        \n        // This stuups the raymarching when the distance to the object is so small that we nonnot need to do 80 iterations\n        // withouy this the max number of iterations would be performed every time and could greatly reduce performance \n        // if the threshold is set too high, you will lose deatil\n        // if too low the performance gains will be negligible\n        //finalColor = vec3(i) / 80.0;\n        if (ds < 0.001) break;\n        \n        // stops loop early if the ray has travaeled too far by putting a cap on the distance it is allowed to travel\n        if (dt > 100.0) break;\n        \n        // we can combine the previous 2 checks into one line: if(distanceToScene < 0.001 || distTraveled > 100.0) break;\n        \n    }\n    \n    //COLORING\n    \n    // this outputs a greyscale image based on distance from the origin\n    // by default this will display any value greater than 1 as pureb white, so we need to fix that\n    // we can either move the camera closer to the objects or divide distTraveled by an arbitrary number until we can see things\n    // here I am using the divide by an arbitrary number method\n    col = palette(dt * 0.006 + float(i)*0.005);\n     \n    // fragColor holds RGB and alpha values of a pixel\n    // we use finalColor as the output of our shader instead of displaying the UV coords like it normally would\n    fragColor = vec4(col, 1);\n\n\n}","name":"Image","description":"","type":"image"}]}