{"ver":"0.1","info":{"id":"sldGDn","date":"1636020201","viewed":97,"name":"OK HSL Test","username":"wnu","description":"implemented from https://bottosson.github.io/posts/colorpicker/ Thank you Björn Ottosson, this way of picking color is awesome!\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["color","hsl","okhsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.141592653589793\n#define FLT_MAX 3.402823466e+38\n\n// code from https://www.shadertoy.com/view/XljGzV\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n//Code from https://www.shadertoy.com/view/WtccD7\n\n// i think I have to include this\n\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\nfloat f_inv(float x)\n{\n    if (x >= 0.04045)\n        return pow((x + 0.055)/(1. + 0.055),2.4);\n    else \n        return x / 12.92;\n}\n\nvec3 f_inv3(vec3 x)\n{\n    vec3 o = vec3(0.);\n    o.x = f_inv(x.x);\n    o.y = f_inv(x.y);\n    o.z = f_inv(x.z);\n    return o;\n}\n\n//Code from https://bottosson.github.io/posts/colorpicker/ \n\n//Copyright (c) 2021 Björn Ottosson\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of\n//this software and associated documentation files (the \"Software\"), to deal in\n//the Software without restriction, including without limitation the rights to\n//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n///of the Software, and to permit persons to whom the Software is furnished to do\n//so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206;\n\tfloat k_2 = 0.03;\n\tfloat k_3 = (1.+ k_1) / (1. + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nstruct Cs { float C_0; float C_mid; float C_max; };\nstruct LC { float L; float C; };\nstruct RGB { float r; float g; float b; };\nstruct Lab { float L; float a; float b; };\nstruct ST { float S; float T; };\n\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328 * a - 0.80936493 * b > 1.)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277; k1 = +1.76576728; k2 = +0.59662641; k3 = +0.75515197; k4 = +0.56771245;\n\t\twl = +4.0767416621; wm = -3.3077115913; ws = +0.2309699292;\n\t}\n\telse if (1.81444104 * a - 1.19445276 * b > 1.)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515; k1 = -0.45954404; k2 = +0.08285427; k3 = +0.12541070; k4 = +0.14503204;\n\t\twl = -1.2684380046; wm = +2.6097574011; ws = -0.3413193965;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652; k1 = -0.00915799; k2 = -1.15130210; k3 = -0.50559606; k4 = +0.00692167;\n\t\twl = -0.0041960863; wm = -0.7034186147; ws = +1.7076147010;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774 * a + 0.2158037573 * b;\n\tfloat k_m = -0.1055613458 * a - 0.0638541728 * b;\n\tfloat k_s = -0.0894841775 * a - 1.2914855480 * b;\n\n\t{\n\t\tfloat l_ = 1. + S * k_l;\n\t\tfloat m_ = 1. + S * k_m;\n\t\tfloat s_ = 1. + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3. * k_l * l_ * l_;\n\t\tfloat m_dS = 3. * k_m * m_ * m_;\n\t\tfloat s_dS = 3. * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6. * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6. * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6. * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5 * f * f2);\n\t}\n\n\treturn S;\n}\n\nRGB oklab_to_linear_srgb(Lab c)\n{\n\tfloat l_ = c.L + 0.3963377774 * c.a + 0.2158037573 * c.b;\n\tfloat m_ = c.L - 0.1055613458 * c.a - 0.0638541728 * c.b;\n\tfloat s_ = c.L - 0.0894841775 * c.a - 1.2914855480 * c.b;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n    \n    RGB o;\n    o.r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;\n    o.g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;\n    o.b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;\n\n\treturn o;\n}\n\n\n//cbrt from https://www.shadertoy.com/view/wts3RX\n\n\nfloat cbrt( float x )\n{\n\tfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\n\tfor( int i = 0; i < 2; ++i )\n    \ty = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < 0; ++i )\n    {\n    \tfloat y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\nLC find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n    Lab lab;\n    lab.L =  1.;\n    lab.a = S_cusp * a;\n    lab.b = S_cusp * b;\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tRGB rgb_at_max = oklab_to_linear_srgb(lab);\n\tfloat L_cusp = cbrt(1. / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n    LC lc;\n    lc.L = L_cusp;\n    lc.C = C_cusp;\n\n\treturn lc;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, LC cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.C * L0 / (C1 * cusp.L + cusp.C * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.C * (L0 - 1.) / (C1 * (cusp.L - 1.) + cusp.C * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774 * a + 0.2158037573 * b;\n\t\t\tfloat k_m = -0.1055613458 * a - 0.0638541728 * b;\n\t\t\tfloat k_s = -0.0894841775 * a - 1.2914855480 * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1. - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3. * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3. * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3. * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6. * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6. * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6. * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1.;\n\t\t\t\tfloat r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt;\n\t\t\t\tfloat r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1.;\n\t\t\t\tfloat g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt;\n\t\t\t\tfloat g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5 * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s - 1.;\n\t\t\t\tfloat b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.7076147010 * sdt;\n\t\t\t\tfloat b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.7076147010 * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0. ? t_r : FLT_MAX;\n\t\t\t\tt_g = u_g >= 0. ? t_g : FLT_MAX;\n\t\t\t\tt_b = u_b >= 0. ? t_b : FLT_MAX;\n                \n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tLC cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nST to_ST(LC cusp)\n{\n\tfloat L = cusp.L;\n\tfloat C = cusp.C;\n    \n    ST st;\n    st.S = C / L;\n    st.T = C / (1. - L);\n\treturn st;\n}\n\nST get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993 + 1. / (\n\t\t+7.44778970 + 4.15901240 * b_\n\t\t+ a_ * (-2.19557347 + 1.75198401 * b_\n\t\t\t+ a_ * (-2.13704948 - 10.02301043 * b_\n\t\t\t\t+ a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642 + 1. / (\n\t\t+1.61320320 - 0.68124379 * b_\n\t\t+ a_ * (+0.40370612 + 0.90148123 * b_\n\t\t\t+ a_ * (-0.27087943 + 0.61223990 * b_\n\t\t\t\t+ a_ * (+0.00299215 - 0.45399568 * b_ - 0.14661872 * a_\n\t\t\t\t\t)))\n\t\t);\n        \n    ST st;\n    st.S = S;\n    st.T = T;\n\n\treturn st;\n}\n\n\n\nCs get_Cs(float L, float a_, float b_)\n{\n\tLC cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1., L, cusp);\n\tST ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.S), (1. - L) * ST_max.T);\n\n\tfloat C_mid;\n\t{\n\t\tST ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.S;\n\t\tfloat C_b = (1. - L) * ST_mid.T;\n\t\tC_mid = 0.9 * k * sqrt(sqrt(1. / (1. / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST.\n\t\tfloat C_a = L * 0.4;\n\t\tfloat C_b = (1. - L) * 0.8;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1. / (1. / (C_a * C_a) + 1. / (C_b * C_b)));\n\t}\n    \n    Cs cs;\n    cs.C_0 = C_0;\n    cs.C_mid = C_mid;\n    cs.C_max = C_max;\n\n\treturn cs;\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308 >= a ? 12.92 * a : 1.055 * pow(a, .4166666666666667) - .055;\n}\n\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n    \n\n\tif (l == 1.0)\n\t{\n\t\treturn vec3(1., 1., 1.);\n\t}\n\n\telse if (l == 0.)\n\t{\n\t\treturn vec3( 0., 0., 0. );\n\t}\n\n\tfloat a_ = cos(2. * pi * h);\n\tfloat b_ = sin(2. * pi * h);\n\tfloat L = toe_inv(l);\n\n\tCs cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.C_0;\n\tfloat C_mid = cs.C_mid;\n\tfloat C_max = cs.C_max;\n\n    // Interpolate the three values for C so that:\n    // At s=0: dC/ds = C_0, C=0\n    // At s=0.8: C=C_mid\n    // At s=1.0: C=C_max\n\n\tfloat mid = 0.8;\n\tfloat mid_inv = 1.25;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1. - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1. - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1. - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1. - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1. - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1. - k_2 * t);\n\t}\n    \n    Lab lab;\n    lab.L = L;\n    lab.a = C*a_;\n    lab.b = C*b_;\n\n\tRGB rgb = oklab_to_linear_srgb(lab);\n    \n    \n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = hsl2rgb(vec3(uv.x,0.5,uv.x));\n    \n    float off = 0.5;\n    float theta = 2.*3.141592653589793*uv.y;\n    float chroma = 0.2*.33;\n    float L = uv.x;\n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 Lab = vec3(L,a,b);\n    \n    //col = linear_srgb_from_oklab(Lab);\n    ////col = pow(col,vec3(1./2.2));\n    \n    col = okhsl_to_srgb(vec3(uv.y+iTime/10.,0.6,uv.x));\n    \n    //col = pow(col,vec3(1./2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}