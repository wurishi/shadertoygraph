{"ver":"0.1","info":{"id":"flcXDN","date":"1643114893","viewed":122,"name":"Reintegration tracking test","username":"muph","description":"Reintegration tracking of virtual particles\nhttps://michaelmoroz.github.io/Reintegration-Tracking/","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fluid","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 col, in vec2 fpos ) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fpos/iResolution.xy;\n\n    vec2 wpos = fpos / 20.;\n    ivec2 ipos = ivec2(wpos);\n    Particle p = getParticle(ch0, ipos);\n\n    \n    // Output to screen\n    if (p.Mass > 0.) {\n        col = vec4(pow(p.Mass, 0.25));\n    }\n    \n    float dist = length(wpos - p.Pos);\n    if (dist < p.Mass*.4) {\n        float g = p.Pressure;\n        col = vec4(sqrt(1. - g), sqrt(g), 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define texel(channel, pos) texelFetch(channel, ivec2(pos), 0)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define for_neighbors(i,j) range(i,-1,1) range(j,-1,1)\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define dt 0.1\n#define fluid_density 1.5\n#define velocity_cap (1./dt)\n\nvec2 decode(float data) {\n    uint a = floatBitsToUint(data);\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\nfloat encode(vec2 x) {\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    uint X = uint(round(x.x)) + 65535u*uint(round(x.y));\n    return uintBitsToFloat(X); \n}\n\nstruct Particle {\n    vec2 Pos;\n    vec2 Vel;\n    float Mass;\n    float Pressure;\n};\n\nvec4 encodeParticle(Particle p, ivec2 pos) {\n    p.Pos = clamp(p.Pos - vec2(pos), vec2(.0), vec2(2.0));\n    return vec4(encode(p.Pos), encode(p.Vel), p.Mass, p.Pressure);\n}\nParticle getParticle(sampler2D ch, ivec2 pos) {\n    Particle p;\n    vec4 data = texel(ch, pos);\n    p.Pos = decode(data.x) + vec2(pos);\n    p.Vel = decode(data.y);\n    p.Mass = data.z;\n    p.Pressure = data.w;\n    return p;\n}\n\n// Calculate elastic collision between two particles\nParticle bounceElastic(Particle p1, Particle p2) {\n    \n    float m1 = p1.Mass;\n    float m2 = p2.Mass;\n    \n    p1.Vel = (m1 - m2) / (m1 + m2) * p1.Vel + (2. * m2) / (m1 + m2) * p2.Vel;\n\n    return p1;\n}\n\n// Calculate overlap of two axis-aligned boxes\n// @param a Center of box a. (side=1)\n// @param b Center of box b. (side=r)\n// @param r Side length of box b.\n// @returns vec3(center.x, center.y, area)\nvec3 overlap(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}//*/\n\nParticle MovementSolid(sampler2D ch, ivec2 pos) {\n\n    Particle p;\n    p.Mass = 0.;\n    \n    for_neighbors(x,y) {\n        // neighbor particle\n        Particle p_n = getParticle(ch, pos + ivec2(x,y));\n        p_n.Pos += p_n.Vel*dt; // integrate velocity\n        \n        if (ivec2(p_n.Pos) == pos && p_n.Mass > p.Mass) {\n            p = p_n;\n        }\n    }\n    \n    p.Pressure = 0.;\n    \n    for_neighbors(x,y) {                \n        Particle p_n = getParticle(ch, pos + ivec2(x,y));\n        p_n.Pos += p_n.Vel*dt; // integrate velocity\n        \n        float dist = length(p_n.Pos - p.Pos);\n        \n        if (p_n.Mass > 0.1 && dist > 0.01 && dist < 1.5) {\n            p = bounceElastic(p, p_n);\n            p.Pressure = 0.5;\n        }        \n    }\n    \n    // borders\n    if ((p.Vel.x > 0. && p.Pos.x > 39.5)\n     || (p.Vel.x < 0. && p.Pos.x < 00.5)) p.Vel.x *= -1.;\n    \n    if ((p.Vel.y > 0. && p.Pos.y > 22.0)\n     || (p.Vel.y < 0. && p.Pos.y < 00.5)) p.Vel.y *= -1.;\n    \n    \n    \n    // cap velocity\n    if (length(p.Vel) > velocity_cap) {\n        p.Vel *= velocity_cap / length(p.Vel);\n    }\n    \n    return p;\n}\n\nParticle MovementFluid(sampler2D ch, ivec2 pos) {\n    Particle p;\n\n    // weighted average by mass:\n    for_neighbors(x,y) {\n    \n        // neighbor particle\n        Particle p_n = getParticle(ch, pos + ivec2(x,y));\n        \n        // integrate velocity\n        p_n.Pos += p_n.Vel*dt;\n    \n        float diffusion = (.02 + sqrt(p_n.Mass)) / fluid_density;\n        \n        vec3 ovrlp = overlap(p_n.Pos, vec2(pos) + vec2(.5), diffusion);\n        float overlapRelArea = ovrlp.z;\n        vec2 overlapCenter = ovrlp.xy;\n        \n        float overlapMass = overlapRelArea * p_n.Mass;\n        \n        p.Mass += 1. * overlapMass;\n        p.Pos += overlapCenter * overlapMass;\n        p.Vel += p_n.Vel * overlapMass;\n    }\n    \n    // divide by weight to get average\n    if (p.Mass != 0.0) {\n        p.Vel /= p.Mass;\n        p.Pos /= p.Mass;\n    }\n    \n    // cap velocity\n    if (length(p.Vel) > velocity_cap) {\n        p.Vel *= velocity_cap / length(p.Vel);\n    }\n    \n    return p;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 col, in vec2 fpos ) {\n    ivec2 ipos = ivec2(fpos);\n\n    if (iFrame == 1) {\n        if (ipos == ivec2(8,20)) {\n            Particle p;\n            p.Pos = vec2(ipos) + vec2(.5,.5);\n            p.Vel = vec2(.5, -.3);\n            p.Mass = 1.;\n            col = encodeParticle(p, ipos);\n        }\n        \n        if (ipos == ivec2(8,2)) {\n            Particle p;\n            p.Pos = vec2(ipos) + vec2(.1,.5);\n            p.Vel = vec2(.5, .9);\n            p.Mass = 1.;\n            col = encodeParticle(p, ipos);\n        }\n        \n    } else {\n    \n        // Change here!\n    \n        //Particle p = MovementSolid(ch0, ipos);\n        Particle p = MovementFluid(ch0, ipos);\n       \n        if (iFrame == 240) {\n            if (ipos == ivec2(30,3)) {\n                p.Pos = vec2(ipos) + vec2(.5,.5);\n                p.Vel = vec2(-.5, .9);\n                p.Mass = 1.;\n            }\n        }\n        \n        if (p.Mass != 0.) {\n            p.Vel.y -= 0.015 *dt;\n        }\n        \n        col = encodeParticle(p, ipos);        \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}