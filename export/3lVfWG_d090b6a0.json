{"ver":"0.1","info":{"id":"3lVfWG","date":"1614986304","viewed":56,"name":"Worley Noise -- T2","username":"Rugged","description":"Worley noise that changes. This is my basis of Worley noise for me to use in future projects;","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise","random","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//number of points (cannot be greater than (RES.x * RES.y) - offset)\n#define count 10\n//offset for different points (must be greater than or equal to 0)\n#define offset 0\n\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\nfloat max3(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //easier to reference version of iResolution.xy\n    vec2 res = iResolution.xy;\n    \n    //unit vector coordinates\n    vec2 uv = fragCoord / res;\n        \n    //initialize the color\n    vec3 col = vec3(0.);\n    \n    //float version of count for calculations\n    float c = float(count);\n    \n    //the unit vector dimensions of 1 pixel\n    vec2 pix = 1. / iResolution.xy;\n    \n    //amount of advances (down the list of points) per second\n    int oT = int(iTime * 1.);\n    \n    \n    //the closest point from the current pixel\n    float miD = 1.;\n    //the color of the point at minimum distance\n    vec3 miC = vec3(0.);\n    //the coordinate of the closest ponit\n    vec2 miP = vec2(1.);\n    \n    //the second closest point from the current pixel\n    float miD2 = 1.;\n    //the color of the point at second closest distance\n    vec3 miC2 = vec3(0.);\n    //the coordinate of the second closest ponit\n    vec2 miP2 = vec2(1.);\n    \n    //get the psuedorandom color at each point and make a point on the screen\n    for(int i = offset + oT; i < count + offset + oT; i++){\n        //float verson of i for calculations\n        float ii = float(i);\n            \n        //current pixel location (dist per pixâ€”uv * <x, y>)\n        vec2 cp = pix * vec2(mod(ii, res.x), floor(ii / res.x));\n            \n        //gets the position vector of the point using the color\n        vec2 p = texture(iChannel0, cp).xy;\n        \n        //convert p.y into THETA\n        p.y *= 6.28;\n        \n        //makes the dispersion not so biased towards PI (radians)\n        p *= p;\n        \n        \n        //convert from cylindical coordinates: p.x = rho, p.y = theta\n        //also center in the middle of screen \n        vec2 p2 = vec2(p.x * cos(p.y), p.x * sin(p.y)) + vec2(.5);\n        \n        \n        \n        \n        //distance to point from pixel\n        float d = distance(uv, p2);\n        \n        \n        \n        //checks if the current distance is less than closest\n        if(d < miD){\n            //sets the second closest to the previous closest\n            miD2 = miD;\n            miP2 = miP;\n            miC2 = miC;\n            \n            //sets the new closest\n            miD = d;\n            miP = p2;\n            //miC = texture(iChannel0, cp).xyz;\n            miC = vec3(texture(iChannel0, cp).xyz);\n            \n            \n            \n            //make the colors more vibrant\n            \n            miC /= max3(miC);\n            \n            /*\n            miC.y *= miC.y;\n            miC.z *= miC.z * miC.z;\n            */\n            \n            \n        }\n        \n        if(d > miD && d < miD2){\n            //checks to see if current point is second closest\n            miD2 = d;\n            miP2 = p2;\n            miC2 = vec3(texture(iChannel0, cp).xyz);\n            \n            \n            \n            //make the colors more vibrant\n            \n            miC2 /= max3(miC2);\n            \n            /*\n            miC2.y *= miC2.y;\n            miC2.z *= miC2.z * miC2.z;\n            */\n            \n            \n        }\n            \n       \n    }\n    \n    col = mix(miC, vec3(0.),pow(miD / miD2, 1.));;\n    \n    \n    //shows the points\n    /*\n    if(distance(miP, uv) < 0.004){\n        col = vec3(1.);\n    }\n    */\n    \n    \n    //uncomment line below to see the buffer\n    //col = texture(iChannel0, uv).xyz;\n        \n    fragColor = vec4(col, 1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(13.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //unit vector\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //keep data persistent\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    //if its the first frame, generate the color noise\n    if(iFrame == 0){\n        //psuedorandom color for each pixel\n        col = vec3(hash3(uv), hash3(uv.xx), hash3(uv / uv.yx));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}