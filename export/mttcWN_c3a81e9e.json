{"ver":"0.1","info":{"id":"mttcWN","date":"1730260242","viewed":105,"name":"Cascaded blur in one texture","username":"fishy","description":"It's like the thing where they use multiple render targets to progressively downsample a texture but this just uses one texture over multiple frames, so each \"cascade\" of the bloom texture is a frame behind the last","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["blur","bloom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define bloom(tile, coeff) (textureBc(iChannel1, getTile(fragCoord/iResolution.xy, tile))*coeff)\n\nvec3 tmo(vec3 c)\n{\n    // Color cross-talk\n    c *= mat3(vec3(1.000, 0.150, 0.050),\n              vec3(0.100, 1.000, 0.125),\n              vec3(0.035, 0.100, 1.000));\n    // Reinhard^2 operator on the result\n    c = c*c / (c*c + 1.0);\n    return pow(c, vec3(0.4545));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n#ifndef DEBUG\n    fragColor = texture(iChannel0, uv)*0.5;\n    for(float i = 0.0; i < 16.0; i++)\n    {\n        fragColor += bloom(i, exp2(-i));\n    }\n    fragColor.rgb = tmo(fragColor.rgb);\n#else\n    fragColor.rgb = tmo(0.1*textureBc(iChannel1, getTile(fragCoord/iResolution.xy, iMouse.y/iResolution.y*25.0)).rgb);\n    vec2 bl = getTile(vec2(0, 1).xx, iMouse.y/iResolution.y*10.0);\n    vec2 br = getTile(vec2(0, 1).yx, iMouse.y/iResolution.y*10.0);\n    vec2 tl = getTile(vec2(0, 1).xy, iMouse.y/iResolution.y*10.0);\n    vec2 tr = getTile(vec2(0, 1).yy, iMouse.y/iResolution.y*10.0);\n    fragColor.rgb = texture(iChannel1, uv).rgb;\n    \n    if (uv.x > bl.x && uv.x < br.x && uv.y > bl.y && uv.y < tl.y)\n        fragColor.r += 1.0;\n#endif\n    //fragColor.rgb = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hue(float x)\n{\n    return pow(sin(x + vec3(0, 1.5, 9.8))*0.5+0.5, vec3(1.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    uv *= 2.7;\n    mo *= 2.7;\n    vec2 ouv2 = uv;\n    float i = floor(uv.y+0.5);\n    uv.y = fract(uv.y+0.5)-0.5;\n    vec2 p = cos(iTime*5.0+i)*vec2(1, 0)+vec2(2, 0);\n    vec2 puv = uv-p;\n    fragColor = vec4(0);\n    fragColor.rgb += smoothstep(0.01, 0.0, length(ouv2 - mo)) * hue(iTime) * 5000.0;\n    if(uv.x>0.0)\n        fragColor.rgb += smoothstep(0.2+10.0/iResolution.y, 0.2, length(puv))*hue(atan(puv.y, puv.x)+iTime*5.0*i)*5.0*(i+2.0);\n    else\n        fragColor.rgb += smoothstep(0.11, 0.1, fract(uv.x*(sin(iTime*10.0+ouv.y*0.5)+1.5)*0.2+0.05))*hue(ouv.y*5.0+iTime)*50.0;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// the biggest optimization here would be switching to a two-pass blur I think\n\n#define BLUR_EXTENT 0.001\n#define BLUR_RES 4.0\n\nfloat kernel(vec2 x)\n{\n    x *= 0.71;\n    float a = 1.0 - dot(x, x);\n    return a*a;\n}\n\nvec4 blur(sampler2D tex, vec2 uv, float tile)\n{\n    vec4 fragColor = vec4(0);\n    float s = 0.0;\n\n    for(float x = 0.0; x < BLUR_RES; x++)\n    for(float y = 0.0; y < BLUR_RES; y++)\n    {\n        vec2 o = (vec2(x, y)/BLUR_RES-0.5)*2.0;\n        vec2 buv = uv + o*BLUR_EXTENT*vec2(1, iResolution.x/iResolution.y);\n        buv = fract(getTile(buv, tile-2.0));\n        float w = kernel(o);\n        fragColor += texture(tex, buv)*w;\n        s += w;\n    }\n\n    return fragColor / s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float size = exp2(floor(log2(1.-uv.x)));\n    float tile = 1.0/log2(1.0/size);\n    vec2 tuv = vec2(fract(uv.x/size), uv.y/size - 1.0);\n    if(tile == 1.0)\n    {\n        fragColor = blur(iChannel0, tuv, tile);\n    }\n    else\n    {\n        fragColor = blur(iChannel1, uv, tile);\n    }\n    if (tuv.x < 0.0 || tuv.x > 1.0 || tuv.y < 0.5 / iResolution.y || tuv.y > 1.0)\n        fragColor = vec4(0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define DEBUG\n\nvec4 cubic(float v)\n{\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBc(sampler2D sampler, vec2 texCoords, int lod)\n{\n\n   vec2 texSize = vec2(textureSize(sampler, lod));\n   vec2 invTexSize = 1.0 / texSize;\n   \n   texCoords = texCoords * texSize - 0.5;\n\n   \n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2(-0.5, 1.5).xyxy;\n    \n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n    \n    offset *= invTexSize.xxyy;\n    \n    vec4 sample0 = textureLod(sampler, offset.xz, float(lod));\n    vec4 sample1 = textureLod(sampler, offset.yz, float(lod));\n    vec4 sample2 = textureLod(sampler, offset.xw, float(lod));\n    vec4 sample3 = textureLod(sampler, offset.yw, float(lod));\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec4 textureBc(sampler2D sampler, vec2 texCoords)\n{\n    return textureBc(sampler, texCoords, 0);\n}\n\nvec2 snap(vec2 p, vec2 size)\n{\n    return floor(p * size) / size;\n}\n\nvec2 getTile(vec2 p, float tile)\n{\n    float tileWidth = 1.-exp2(-floor(tile));\n    return vec2(p/exp2(floor(tile))/2.+vec2(tileWidth, (1.0 - tileWidth)*0.5));\n}\n\n","name":"Common","description":"","type":"common"}]}