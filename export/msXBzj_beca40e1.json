{"ver":"0.1","info":{"id":"msXBzj","date":"1689022196","viewed":17,"name":"7/10/23","username":"flooferdoodle","description":"Layering of some sin functions with some chromatic aberration effects","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["chromaticaberration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float luminance(vec3 v){\n    return 0.2126*v.r + 0.7152 * v.g + 0.0722 * v.b;\n}\n\nfloat sinNoise(float t){\n    return sin(0.2*t) + 0.5*cos(t-2.) + sin(0.5*t);\n}\n\nvec2 spiral(vec2 st){\n    return st + vec2(-st.y,st.x)/length(st) * 0.5 * sinNoise(iTime * 0.5);\n}\n\nfloat rings(vec2 st){\n    return 0.04/smoothstep(0.0,0.3,abs(sin(length(st)*8. + iTime)/8.));\n}\n\nfloat fractLayer(vec2 st, float fraction){\n    return rings(fract((st * exp(length(st)) * fraction)) * 2. - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvOrig = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv = spiral(uvOrig);\n    \n    vec3 finalCol;\n    \n    for(float i = 0.2; i < 1.2; i+= 0.6){\n        vec3 col = vec3(fractLayer(uv,i), fractLayer(uv*1.01,i), fractLayer(uv*1.02,i));\n        finalCol += col * (2.2-i)/4.;\n    }\n    \n    //finalCol.r = fractLayer(uv,1.);\n    //finalCol.g = fractLayer(uv*1.01,1.);\n    //finalCol.b = fractLayer(uv*1.02,1.);\n    \n    //finalCol *= 0.1/length(uvOrig);\n    \n    float mask = smoothstep(0.,1.,0.8/length(uvOrig));\n    \n    //finalCol *= pow(mask,10.);\n        \n    \n\n    // Output to screen\n    fragColor = vec4(finalCol,1.);\n}","name":"Image","description":"","type":"image"}]}