{"ver":"0.1","info":{"id":"lsVSDW","date":"1464546642","viewed":194,"name":"Radiolarian seamless loop","username":"udart","description":"Based on this model:\nhttps://www.shadertoy.com/view/Mdt3RX","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","animation","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\n#define t iTime\n\n#define EXO_SPIKE 1.\n\n\nvec2 rot2D(vec2 p, float angle) {\n\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n        \n    \n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nvec3 pModDodecahedron(inout vec3 p) {\n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    p.z = abs(p.z);\n    \n    pR(p.xz, -halfDdihedral);\n    pR(p.xy, faceAngle / 4.);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n    \n    return p;\n}\n\nvec3 pModIcosahedron(inout vec3 p) {\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float sides = 3.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n\n    p.z = abs(p.z);    \n    pR(p.yz, halfDdihedral);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n     \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n  \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n\n\treturn p;\n}\n\nfloat spikeModel(vec3 p, float spikeLen) {\n    pR(p.zy, PI/2.);\n    return fCone(p, 0.25, spikeLen);\n}\n\nfloat spikesModel(vec3 p, float spikeLen) {\n    float smoother = 0.6;\n    \n    pModDodecahedron(p);\n    \n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    float spikeA = spikeModel(p, spikeLen);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = spikeModel(p, spikeLen);\n\n    pR(p.xy, -faceAngle);\n    pR(p.zy, dihedral);\n    \n    float spikeC = spikeModel(p, spikeLen);\n    \n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            smoother\n       \t),\n        smoother\n   \t);\n}\n\n\nfloat exoHolesModel(vec3 p, float dist) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += dist;\n    return length(p) - 2.2;\n}\n\nfloat coreModel(vec3 p, float interval) {\n    float outerInterval = min(interval*1.02,2.5);\n    outerInterval = interval > 6.5 ? 0.0001 : outerInterval;\n    float outer = length(p) - outerInterval;\n    \n    float thickness = 0.28;\n    float inner = outer + thickness;\n    \n    float spikeLength = 1.0 + interval;\n    float spikeLFinish = interval > 7.2 ? 1.0 : 3.0 - interval/3.0;\n    spikeLength = interval > 3.0 ? spikeLFinish : spikeLength;\n\tfloat spikes = spikesModel(p, spikeLength);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n    \n    float shell = max(-inner, outer);\n\n    float dist = 6.0 - interval/2.0;\n    dist = interval > 6.5 ? 6.0 : dist;\n    float holes = exoHolesModel(p, dist);\n\tshell = fOpIntersectionRound(-holes, shell, thickness/2.0);\n\n\treturn shell;\n}\n\n\n\n// Based on Template 3D by iq: https://www.shadertoy.com/view/ldfSWs\n\nfloat doModel(vec3 p) {\n    float interval = 9.0 - mod(iTime*3.0, 9.0);\nfloat intervalPhase = 9.0 - mod(iTime*3.0+4.5, 9.0);\n\n    \n    p.y -= 2.5;\n       \n    p.xz = rot2D(p.xz, interval * 180.0 / 9.0);\n    \n    float core = coreModel(p, interval);\n    float core2 = coreModel(p, intervalPhase);\n    return min(core, core2);\n\t//return core;\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float an = 10.0 * mouse.x + PI / 2.;\n    //an = 10.;\n\n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - mouse.y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(mouse.y * PI / 2.),\n        cos(an)\n    ) * d;\n\n   \tcamTar = vec3(0);\n}\n\n\n\nvec3 doMaterial(in vec3 pos, in vec3 nor) {\n    return vec3(0.85, 0.85, 0.9);\n}\n\n\nfloat doRulerModel(vec3 p) {\n    return 1000.0;\n    float t = 0.1;\n    return abs(p.y) - mod(t/5., 1.);\n}\n\nfloat rule(float d, float scale) {\n    return mix(1., .35, smoothstep(.6, 1., abs(fract(d * scale) * 2. - 1.)));\n}\n\nvec3 rulerColor(float t) {\n    t = clamp(log(t+1.0), 0.0, 1.0);\n    return mix(mix(vec3(0.,.1,1.), vec3(1.,.1,0.), t*5.), vec3(1.0), smoothstep(.2,.5,t));\n}\n\nvec3 doRulerMaterial(vec3 p, float d, float t) {\n    float lt = log(t) / log(10.0);\n    float s = pow(10.0, -floor(lt));\n    float m = smoothstep(0.0, 0.33, fract(lt));\n    float r = rule(d, s * 10.) * mix(rule(d, s * 100.0), rule(d, s), m);\n    return mix(rulerColor(s * d), rulerColor(s * d * 0.1), m) * 0.8 * r;\n}\n\nfloat doCombinedModels(vec3 p) {\n    return min(doModel(p), doRulerModel(p));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd);\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    //vec3 lig = normalize(vec3(1.1, 0.7, 0.9));\n    vec3 lig = normalize(vec3(0.0,1.0,0.8)); \n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0;\n    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n    lin += dif * vec3(2.) * sha;\n\n    // ambient light\n    //-----------------------------\n    //lin += vec3(0.5);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal * lin;\n\n    // fog\n    //-----------------------------\n    //col *= exp(-0.01 * dis * dis);\n\n    //Specular\n    float nrm = (60.0 + 8.0) / (3.1415 * 8.0);\n    col += pow(max(dot(reflect(rd,nor),lig),0.0),60.0) * nrm;\n \n//////experiment\n    \n    float fresnel = 1.0 - max(dot(nor,rd),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n    \n    //sky color\n\tvec3 e = reflect(rd,nor);\n    \n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    //Reflected\n    vec3 reflected = ret*0.1;\n\n    //color\n    vec3 base = vec3(0.01,0.01,0.01);\n    vec3 scolor = vec3(0.01,0.01,0.01);\n\n    float diffuse = pow(dot(nor,lig) * 0.4 + 0.6,80.0)*200.0;\n  \t\n    //Refracted\n    vec3 refracted = base + diffuse * scolor * 0.32 * lin + col*1.4; \n    \n\t//Experiment - overwrite color\n\tcol = mix(refracted,reflected,fresnel);    \n    \n    //col = vec3(reflected);\n    \n    \n    return col;\n}\n\nvec3 calcIntersection(in vec3 ro, in vec3 rd) {\n    const float maxd = 10.0;    // max trace distance\n    const float precis = 0.00001; // precission of the intersection\n    vec3 p;\n    float h = precis * 2.0;\n    float d, r;\n    float t = 0.0;\n    float res = -1.0;\n    for (int i = 0; i < 70; i++) // max number of raymarching iterations is 90\n    {\n        if (h < precis || t > maxd) break;\n        p = ro + rd * t;\n        r = doRulerModel(p);\n        d = doModel(p);\n        h = min(d, r);\n        t += h;\n    }\n\n    if (t < maxd) res = t;\n    return vec3(res, r < d ? 1.0 : 0.0, d);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float eps = 0.002; // precision of the normal computation\n\n    const vec3 v1 = vec3(1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3(1.0, 1.0, 1.0);\n\n    return normalize(v1 * doCombinedModels(pos + v1 * eps) + \n                     v2 * doCombinedModels(pos + v2 * eps) +\n                     v3 * doCombinedModels(pos + v3 * eps) + \n                     v4 * doCombinedModels(pos + v4 * eps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.5; // selfintersection avoidance distance\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps\n        h = doModel(ro + rd * t);\n        res = min(res, 4.0 * h / t); // 64 is the hardness of the shadows\n        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n          float circle(in vec2 _st, in float _radius, float gradient){\n              vec2 dist = _st-vec2(0.5);\n            return 1.-smoothstep(_radius-(_radius*gradient),\n                                   _radius+(_radius*gradient),\n                                   dot(dist,dist)*4.0);\n          }\n\n          vec3 radialGradient(vec2 st, float radius, float gradientWidth, vec3 innerColor, vec3 outerColor) {\n              float circleMix = circle(st,radius, gradientWidth);\n            return mix(outerColor, innerColor, circleMix);\n          }\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 realUv = uv;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3;\n        \n    // ray\n    //vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);   \n    vec3 ang = vec3(0.0, 0.3, 0.0);\n    vec3 ori = vec3(0.0,4.5, 7.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n\n    //\n \n    vec3 color = radialGradient(realUv, 0.3, 3.5,vec3(1.0, 0.97, 0.95), vec3(0.5, 0.49, 0.475));\n\n    vec3 t = calcIntersection(ori, dir);\n    if (t.x > -0.5) {\n        // geometry\n        vec3 pos = ori + t.x * dir;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal;\n        if (t.y > 0.) {\n            mal = doRulerMaterial(pos, t.z, t.x);\n        \t//mal = doLighting(pos, nor, rd, t.x, mal);\n        } else {\n            mal = doMaterial(pos, nor);\n        }\n        \n        color = doLighting(pos, nor, dir, t.x, mal);\n    }\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}","name":"Image","description":"","type":"image"}]}