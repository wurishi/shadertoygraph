{"ver":"0.1","info":{"id":"lXB3zK","date":"1708649258","viewed":262,"name":"TAA Without Input Motion Vectors","username":"Zentient","description":"Requires 2 extra buffers, 1 to store the previous frame, and one to calculate motion vectors and AA. Note that they must be set to mipmap.\nClockwise from top left: Current frame; TAA; Difference between current frame and TAA; Motion Vectors","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["antialiasing","temporal","denoising"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Loosely based on: https://cg.ivd.kit.edu/publications/2021/repro_no_motion/2021_no_motion_vectors.pdf\n//Calculates motion vectors very differently\n//settings in buffer C\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    if(0.33334 <= uv.y && uv.y <= 0.66667)\n    {\n       vec3 sharp = col - texture(iChannel0, uv, 1.0).rgb;\n       col = clamp(col + 0.0 * sharp, 0.0, 1.0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n/*Caveats:\n    Doesn't do well with diagonal motion\n    0.9-1.2ms on gtx 970, not great but could be worse.\n    Fast motion can cause flickering\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Previous frame\nconst float frameAcc = 1.0; //How much of the previous frame stays\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel1, uv).rgb;\n    vec3 colP = texture(iChannel0, uv).rgb;\n    if(uv.y >= 0.5, uv.x >= 0.5) {col = mix(col, colP, frameAcc);}//Remove this line if not displaying motion vectors\n    //col = mix(col, colP, 0.0);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Current Frame, renderer goes here, doesn't work well on shadertoy with videos due to frame matching issues.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vel = iMouse.xy / iResolution.xy;\n    if(iMouse.xy == vec2(0.0)) {vel = vec2(0.5);}\n    vec2 uv = 8.0 * vel * vec2(sin(0.1 * iTime), cos(0.1 * iTime)) + fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv * 2.0).rgb;\n    float noise = fract(sin(dot((iTime*5.0) * fragCoord.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    noise *= noise;\n    vec2 circlePos = vec2(cos(iTime) * iResolution.x, sin(iTime) * iResolution.y);\n    vec2 circle2 = vec2(sin(iTime) * iResolution.x, cos(2.0 * iTime) * iResolution.y);\n    circlePos = 0.5 * (iResolution.xy) + 0.5 * circlePos;\n    circle2 = 0.5 * (iResolution.xy) + 0.5 * circle2;\n    \n    if(distance(fragCoord.xy, circlePos) <= 40.0) {col = vec3(1.0);}\n    if(distance(fragCoord.xy, circle2) <= 60.0) {col = vec3(0.0);}\n    \n    //col = mix(col, vec3(noise), 0.5);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//Prevents unecesarry blurring. set to 0 to disable, 1 to enable\nconst int selectiveAA = 1;\n\nconst float lodDiv = 0.0; //Max LOD value for calc\nconst float thrHold = 1.0; //How picky the selector is, 0.0 - 1;\n\nvec2 calcVectors(vec2 coord, float lod)\n{\n    float lodVal = (lod + 1.0);\n    vec2 uv = floor(coord / lodVal) * lodVal / iResolution.xy;\n    \n    \n    //Translation vectors\n    vec2 transXY0 = vec2(0.0, 1.0) * pow(2.0, lodVal) * 0.5;  //Up\n    vec2 transXY1 = vec2(1.0, 0.0) * pow(2.0, lodVal) * 0.5;  //Right\n    vec2 transXY2 = vec2(0.0, -1.0) * pow(2.0, lodVal) * 0.5; //Down\n    vec2 transXY3 = vec2(-1.0, 0.0) * pow(2.0, lodVal) * 0.5; //Left\n\n    transXY0 /= iResolution.xy;\n    transXY1 /= iResolution.xy;\n    transXY2 /= iResolution.xy;\n    transXY3 /= iResolution.xy;\n    \n    vec3 A0;\n    vec3 B0;\n    A0 = texture(iChannel0, uv, lod).rgb;//previous frame, LOD\n    B0 = texture(iChannel1, uv, lod).rgb;//current frame,  LOD\n    float sErr = distance(A0, B0);//Stationary Error\n    \n    \n    A0 = texture(iChannel0, uv, lod).rgb;//previous frame, LOD\n    B0 = texture(iChannel1, uv  + transXY0, lod).rgb;//current frame,  LOD\n    float uErr = distance(A0, B0);// +Y Error\n    \n    \n    A0 = texture(iChannel0, uv, lod).rgb;//previous frame, LOD\n    B0 = texture(iChannel1, uv + transXY1, lod).rgb;//current frame,  LOD\n    float rErr = distance(A0, B0);// +X Error\n    \n    \n    A0 = texture(iChannel0, uv, lod).rgb;//previous frame, LOD\n    B0 = texture(iChannel1, uv + transXY2, lod).rgb;//current frame,  LOD\n    float dErr = distance(A0, B0);// -Y Error\n    \n    \n    A0 = texture(iChannel0, uv, lod).rgb;//previous frame, LOD\n    B0 = texture(iChannel1, uv + transXY3, lod).rgb;//current frame,  LOD\n    float lErr = distance(A0, B0);// -X Error\n    \n    \n    //Calculate motion vectors from error\n    vec2 vectors = vec2(\n        sErr * (rErr - lErr),\n        sErr * (uErr - dErr));\n    \n    return lodVal * vectors;\n\n}\n\nvec2 accVec(vec2 coord, float iter)\n{\n    float i;\n    vec2 vectors;\n    for(i = 0.0; i <= iter; i++)\n    {\n        //vectors += calcVectors(coord, i);\n        vectors = calcVectors(coord, i);\n        if (distance(vectors, vec2(0.0)) < 1.0) {return vectors * pow(i + 1.0, 2.0);}\n    }\n    return vectors * pow((i + 1.0), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec3 frameA = texture(iChannel0, uv, 0.0).rgb;//Buffer A, previous frame\n    vec3 frameB = texture(iChannel1, uv, 0.0).rgb;//Buffer B, current frame\n    vec2 vectors = accVec(fragCoord.xy, lodDiv);\n    vec3 col;\n    \n    \n    if(uv.y <= 0.5 && uv.x <= 0.5)\n    {\n        col = vec3(vectors, 1.0);\n        col = 0.5 + 0.5 * col;\n        \n    }\n    else if(uv.x > 0.5)\n    {\n        col = texture(iChannel0, uv + (vectors / iResolution.xy), 0.0).rgb;\n        \n        if(selectiveAA > 0)\n        {\n            float weight = clamp(distance(vectors, vec2(0.0)), 0.0, 1.0);\n            weight = pow(weight, thrHold);\n            col = mix(frameB, col, weight);\n            \n        }\n        else {col = mix(col, frameB, 0.2);}\n        \n    }\n    if(uv.x > 0.5 && uv.y < 0.5){col = frameB - col;}\n    if(uv.x < 0.5 && uv.y > 0.5) {col = frameB;}\n    \n    \n        \n\n    // Output to screen\n    fragColor = vec4(clamp(col, 0.0, 1.0),1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}