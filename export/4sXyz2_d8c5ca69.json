{"ver":"0.1","info":{"id":"4sXyz2","date":"1488888506","viewed":21551,"name":"Organic segment test","username":"Zavie","description":"Playing around with a segment SDF to get something a little more life-like.","likes":26,"published":3,"flags":0,"usePreview":0,"tags":["test","sdf","demoscene","organic","segment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nAn experiment at creating an organic looking segment.\n\nThe function was used for modelling the statue of Poseidon in the\ntemple scene of the 64kB intro \"H - Immersion\", by Ctrl-Alt-Test.\n\n > http://www.ctrl-alt-test.fr/?page_id=444\n > https://www.youtube.com/watch?v=27PN1SsXbjM\n\n-- \nZavie / Ctrl-Alt-Test\n\n*/\n\nvec3 debugDistance(float d, vec3 color)\n{\n    float iso =\n        smoothstep(0.92, 0.98, abs(fract(d) * 2. - 1.)) +\n        smoothstep(0.8, 0.95, abs(fract(5.*d) * 2. - 1.))*0.5;\n    return mix(vec3(1.), color, iso)* mix(0.8, 1., float(d > 0.)) * smoothstep(0.02,0.06, abs(d));\n}\n\nfloat exponentialSmoothMmin(float a, float b, float k)\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat polynomialSmoothMmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat segmentDistance(vec2 p, vec2 a, vec2 b, out float h)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\th = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n\treturn length(ap - ab * h);\n}\n\nvec4 limb(vec2 p, vec2 a, vec2 b, float ra, float rb, float fill, float k)\n{\n\tfloat da = length(a - p) - ra;\n\tfloat db = length(b - p) - rb;\n    float h;\n    float dmid = segmentDistance(p, a, b, h);\n\n    float bump = sin(2.*3.14159265358979 * (pow(h, 0.9) - 0.25)) * 0.5 + 0.5;\n    dmid -= mix(ra, rb, h + fill * bump);\n\n    float d = exponentialSmoothMmin(dmid, min(da, db), k);\n    return vec4(d, da, db, dmid);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 8.*fragCoord.xy / iResolution.y;\n\n    vec2 p1 = vec2(sin(2.*iTime), cos(iTime))+vec2(3.);\n    vec2 p2 = vec2(sin(3.*iTime), cos(1.2*iTime))+vec2(10., 4.);\n    \n    vec4 d = limb(uv, p1, p2, 0.85, 1.5, 0.8, 5.);\n\n    \n    vec3 color = 1.\n        * debugDistance(d.x, vec3(0.8, 0.8, 0.8))\n        * debugDistance(d.y, vec3(0.8, 0.5, 1.))\n        * debugDistance(d.z, vec3(0.5, 0.8, 1.))\n        * debugDistance(d.w, vec3(0.5, 1.0, 0.5))\n        ;\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}