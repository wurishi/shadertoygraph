{"ver":"0.1","info":{"id":"WtdGWB","date":"1577454019","viewed":308,"name":"Terrain Day/Night Cycle","username":"Tara","description":"My first shader here on shadertoy. It's not finished.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","raymarching","terrain","lighting","cycle","night","day"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: Add linear space lighting!\n// TODO: Add little trees everywhere.\n// TODO: Maybe animate day/night cycle.\n// TODO: Add a moon with light.\n// Could we place the camera on the mountains and make it look into the sky?\n// TODO: Implement a mode that shows the different effects side by side.\n// TODO: Implement max view distance (used for fog and ray marching).\n// TODO: Step out of terrain using binary search.\n// TODO: Use a more detailed height function only for shading (like for computing normals)! Ray march simpler geometry.\n// TODO: Don't fade to black! Just use some ambient lighting.\n\n// Settings:\nconst float gamma = 2.2;\n\nconst float max_view_distance = 10.0;\n\n//const vec3 light_direction = normalize(vec3(0.5, 0.25, 0.25));\nconst float time_scale = 0.25;\n\n//const vec3 sky_color = vec3(0.3, 0.7, 0.9);\nconst vec3 sky_color_noon = vec3(0.3, 0.7, 0.9);\nconst vec3 sky_color_evening = vec3(0.5, 0.3, 0.1);\nconst vec3 sky_color_night = vec3(0.1, 0.05, 0.15) * 2.0;\n\n//vec3 light_color = vec3(1.0, 0.5, 0.2) * light_color_blend_factor;\nconst vec3 light_color_noon = vec3(1.0, 0.5, 0.2);\nconst vec3 light_color_evening = vec3(0.8, 0.1, 0.05);\nconst vec3 light_color_night = vec3(0.0);\n\nconst vec3 moon_color = vec3(0.05, 0.1, 0.1);\n\n\n//const float fog_strength = 0.11;\nconst float fog_exponent = 2.0;\n\nconst float water_height = 0.8;\n\nconst float terrain_height_multiplicator = 6.0;\n\n\n\nfloat adjusted_time;\nfloat adjusted_time_for_sun;\n\nvec3 light_direction;\nfloat light_exponent;\n\nfloat is_day;\n\nfloat noon_night_factor;\t// 1.0 = noon, 0.0 = night\nfloat noon_evening_factor;\t// 1.0 = noon, 0.0 = evening\n\nvec3 light_color;\nvec3 sky_color;\n\nvec2 fragCoord;\n\nconst int coordinate_count =  64;\nvec3 coordinates[coordinate_count];\n\n\nvoid initialize_global_variables(vec2 pFragCoord)\n{\n    // Initialize the array (since WebGL doesn't allow array initializers):\n    coordinates[ 0 ] = vec3( -0.435885996181 , 0.79720633541 , 0.0972253052385 );\n    coordinates[ 1 ] = vec3( -0.32218308746 , 0.100646505563 , 0.582645225292 );\n    coordinates[ 2 ] = vec3( 0.587014777685 , 0.41111934478 , 0.547503737761 );\n    coordinates[ 3 ] = vec3( -0.192455452266 , 0.321063732913 , 0.668652567224 );\n    coordinates[ 4 ] = vec3( -0.259779617945 , 0.909626864008 , 0.0836824717262 );\n    coordinates[ 5 ] = vec3( 0.348649506252 , 0.103790885936 , 0.904378113197 );\n    coordinates[ 6 ] = vec3( -0.542650115811 , 0.0736718130349 , 0.397151757271 );\n    coordinates[ 7 ] = vec3( -0.474716167394 , 0.118343120088 , 0.570445920116 );\n    coordinates[ 8 ] = vec3( -0.836441325058 , 0.171629770526 , 0.0597544063084 );\n    coordinates[ 9 ] = vec3( 0.0824315685125 , 0.505680845825 , 0.662611320344 );\n    coordinates[ 10 ] = vec3( 0.516123186703 , 0.55815762739 , 0.411018332295 );\n    coordinates[ 11 ] = vec3( -0.724799879376 , 0.423272250814 , 0.448164544035 );\n    coordinates[ 12 ] = vec3( -0.0110437238687 , 0.0904558337167 , 0.231594212451 );\n    coordinates[ 13 ] = vec3( 0.546531423419 , 0.321583514112 , 0.512659552736 );\n    coordinates[ 14 ] = vec3( 0.368589954248 , 0.0182021895091 , 0.880833172129 );\n    coordinates[ 15 ] = vec3( 0.47525253334 , 0.271287592025 , 0.000334496440065 );\n    coordinates[ 16 ] = vec3( 0.44673660601 , 0.132552497011 , 0.340585192841 );\n    coordinates[ 17 ] = vec3( -0.403804494418 , 0.0104325320551 , 0.159902664933 );\n    coordinates[ 18 ] = vec3( -0.338579360521 , 0.716322524047 , 0.542091484806 );\n    coordinates[ 19 ] = vec3( 0.308210916814 , 0.743567127819 , 0.472326208485 );\n    coordinates[ 20 ] = vec3( 0.814788310063 , 0.449353375014 , 0.340846719572 );\n    coordinates[ 21 ] = vec3( -0.544006155176 , 0.711118594385 , 0.132489899091 );\n    coordinates[ 22 ] = vec3( -0.114345207769 , 0.0808582423255 , 0.0592533221037 );\n    coordinates[ 23 ] = vec3( -0.0956105901715 , 0.886967062617 , 0.296750041926 );\n    coordinates[ 24 ] = vec3( 0.125465786235 , 0.249375761939 , 0.39086839732 );\n    coordinates[ 25 ] = vec3( -0.507001597684 , 0.478280151596 , 0.442128006659 );\n    coordinates[ 26 ] = vec3( 0.767372362554 , 0.34981180972 , 0.216480512037 );\n    coordinates[ 27 ] = vec3( 0.729037025717 , 0.488650315003 , 0.0447790563882 );\n    coordinates[ 28 ] = vec3( 0.545055293632 , 0.328506679918 , 0.0161990255662 );\n    coordinates[ 29 ] = vec3( 0.0613031135758 , 0.891064511104 , 0.391832390956 );\n    coordinates[ 30 ] = vec3( 0.490558372066 , 0.237016279151 , 0.0603644616935 );\n    coordinates[ 31 ] = vec3( 0.0670590641368 , 0.150548596978 , 0.496247392186 );\n    coordinates[ 32 ] = vec3( 0.342684862582 , 0.682876750055 , 0.151397259036 );\n    coordinates[ 33 ] = vec3( -0.651487774333 , 0.201712081807 , 0.246829681649 );\n    coordinates[ 34 ] = vec3( 0.561837936205 , 0.251550371306 , 0.355580475726 );\n    coordinates[ 35 ] = vec3( 0.192999232894 , 0.392428615732 , 0.0121078124268 );\n    coordinates[ 36 ] = vec3( -0.105851736143 , 0.163824018243 , 0.236916795307 );\n    coordinates[ 37 ] = vec3( -0.0611750509214 , 0.224873171348 , 0.617895466387 );\n    coordinates[ 38 ] = vec3( -0.109924322491 , 0.508071654989 , 0.505581327183 );\n    coordinates[ 39 ] = vec3( -0.706387045519 , 0.0671452123745 , 0.459796670999 );\n    coordinates[ 40 ] = vec3( -0.278160406844 , 0.289551453062 , 0.160872443354 );\n    coordinates[ 41 ] = vec3( 0.516576843643 , 0.817085834323 , 0.190027033479 );\n    coordinates[ 42 ] = vec3( -0.0942554687146 , 0.878813661213 , 0.214972046973 );\n    coordinates[ 43 ] = vec3( -0.221374373075 , 0.803633365667 , 0.299755346538 );\n    coordinates[ 44 ] = vec3( -0.299462216003 , 0.0720235031843 , 0.36211897975 );\n    coordinates[ 45 ] = vec3( 0.553343181571 , 0.493244437329 , 0.164447492472 );\n    coordinates[ 46 ] = vec3( -0.20136124794 , 0.0760260274291 , 0.534534862455 );\n    coordinates[ 47 ] = vec3( 0.905190222495 , 0.0807321460953 , 0.39235689531 );\n    coordinates[ 48 ] = vec3( -0.728666867176 , 0.38048529455 , 0.226800106991 );\n    coordinates[ 49 ] = vec3( -0.527457489355 , 0.367359870805 , 0.286014828375 );\n    coordinates[ 50 ] = vec3( 0.325761364504 , 0.470935422995 , 0.770885656739 );\n    coordinates[ 51 ] = vec3( -0.511384831071 , 0.50189485858 , 0.565409920223 );\n    coordinates[ 52 ] = vec3( -0.518815864857 , 0.0632066994837 , 0.405086346674 );\n    coordinates[ 53 ] = vec3( 0.115312716748 , 0.105398362421 , 0.954708709816 );\n    coordinates[ 54 ] = vec3( -0.285700995513 , 0.0113348478119 , 0.4620339652 );\n    coordinates[ 55 ] = vec3( -0.0374130136703 , 0.630623418764 , 0.577124020836 );\n    coordinates[ 56 ] = vec3( 0.193453243995 , 0.355055361228 , 0.123825538219 );\n    coordinates[ 57 ] = vec3( 0.681642806219 , 0.522843493246 , 0.489964036509 );\n    coordinates[ 58 ] = vec3( -0.294839413327 , 0.557820363593 , 0.351222001041 );\n    coordinates[ 59 ] = vec3( 0.577147207709 , 0.463873007553 , 0.356984090391 );\n    coordinates[ 60 ] = vec3( -0.700910394348 , 0.213528376537 , 0.0842103964106 );\n    coordinates[ 61 ] = vec3( -0.62990341948 , 0.559561713285 , 0.460576905302 );\n    coordinates[ 62 ] = vec3( -0.097357826252 , 0.707750175458 , 0.258790836913 );\n    coordinates[ 63 ] = vec3( -0.638795681624 , 0.467053715637 , 0.308126560401 );\n    \n    // Initialize the other variables:\n    fragCoord = pFragCoord;\n    \n\tadjusted_time = iTime * time_scale;\n    //adjusted_time = 1.2;\t// Static value for debugging purposes.\n    \n\tadjusted_time_for_sun = mod(adjusted_time, 3.1415926535897932384626433832795);\n\n\tlight_direction = normalize(vec3(cos(adjusted_time_for_sun) * 2.0, sin(adjusted_time_for_sun) * 2.0, 1.5));\n\tlight_exponent = 2.0;\n\n\tis_day = step(0.0, sin(adjusted_time));\n\t\n\t\n\t\t\n\t//noon_night_factor = sin(adjusted_time) * 0.5 + 0.5;\t// 1.0 = noon, 0.0 = night\n\t\n\tnoon_evening_factor = max(sin(adjusted_time), 0.0);\t// 1.0 = noon, 0.0 = evening\n\tnoon_night_factor = noon_evening_factor * noon_evening_factor;\t// 1.0 = noon, 0.0 = night\n\n\tlight_color = mix(light_color_night, mix(light_color_evening, light_color_noon, noon_evening_factor), noon_night_factor);\n\tsky_color = mix(sky_color_night, mix(sky_color_evening, sky_color_noon, noon_evening_factor), noon_night_factor);\n\n\t// Turn the sun into a moon:\n\tlight_color = mix(moon_color, light_color, is_day);\n\t//sky_color = mix(moon_color, sky_color, is_day);\n    \n    // This is used to darken the light at sunset and sunrise to\n    // make the transition between sun and moon less obvious.\n    //const float threshold = 0.2;\n    float light_brightness = pow(abs(sin(adjusted_time_for_sun)), 0.5);\n    \n\t//sky_color *= light_brightness;\n\tlight_color *= light_brightness;\n}\n\n\n\n//vec3 light_color = mix(light_color_evening, light_color_day, light_color_blend_factor);\n\n\n\nmat3 construct_around_vector(vec3 vector)\n{\n\tvec3 smallest_component_vector;\n\n\tif((abs(vector.x) < abs(vector.y))&&(abs(vector.x) < abs(vector.z)))\t// TODO: PERFORMANCE: The \"abs()\" calls could be pretty slow! Use squared values instead? Or do two checks per value?\n\t{\n\t\tsmallest_component_vector = vec3(1.0, 0.0, 0.0);\n\t}\n\telse if(abs(vector.y) < abs(vector.z))\n\t{\n\t\tsmallest_component_vector = vec3(0.0, 1.0, 0.0);\n\t}\n\telse\n\t{\n\t\tsmallest_component_vector = vec3(0.0, 0.0, 1.0);\n\t}\n\n\t// TODO: PERFORMANCE: Is this a way to avoid computing two cross products? http://stackoverflow.com/questions/19337314/generate-random-point-on-a-2d-disk-in-3d-space-given-normal-vector\n\t// TODO: PERFORMANCE: The cross product with \"smallest_component_vector\" can be simplified, because two components are always zero.\n\n\tvec3 vector_x = normalize(cross(vector, smallest_component_vector));\t// We must to normalize the result here, because the two vectors are not orthogonal.\n\tvec3 vector_z = cross(vector_x, vector);\t// The two vectors are orthogonal unit vectors, that's why no normalization is required.\n\n\treturn(mat3(vector_x, vector, vector_z));\n}\n\n\nvec3 to_linear_space(vec3 color)\n{\n\treturn(pow(color, vec3(gamma)));  \n}\n\nvec3 to_gamma_space(vec3 color)\n{\n\treturn(pow(color, vec3(1.0 / gamma)));\n}\n\nfloat hash(vec2 P)\n{\n\t// gridcell is assumed to be an integer coordinate\n\t\n\t//const vec2 OFFSET = vec2(16.0, 19.0);\n\t\n\t//const vec2 OFFSET = vec2(166.0, 19.0);\n\t//const float DOMAIN = 4.0;\n\t\n\tconst vec2 OFFSET = vec2(131.0, 149.0);\n\tconst float DOMAIN = 16.0;\n\t\n\t/*\n\tconst vec2 OFFSET = vec2(124.0, 326.0);\n\tconst float DOMAIN = 8.0;\n\t*/\n\tconst float DOMAIN_SQUARED = DOMAIN * DOMAIN;\n\tconst float SOMELARGEFLOAT = 1.0 / 951.135664;\n\n\tP = mod(P, DOMAIN);\t// truncate the domain (same as the above)\n\tP += OFFSET.xy;\t// offset to interesting part of the noise\n\tP *= P;\t// calculate and return the hash\n\t\n\treturn(fract(P.x * P.y * SOMELARGEFLOAT));\n}\n\n\nfloat mod289(float x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod289(vec4 x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 perm(vec4 x)\n{\n\treturn(mod289(((x * 34.0) + 1.0) * x));\n}\n\nfloat noise_3d(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return(o4.y * d.y + o4.x * (1.0 - d.y));\n}\n\nfloat noise(vec3 p)\n{\n    p.y = 0.0;\n    \n    return(noise_3d(p));\n}\n\nfloat detailed_noise_flat(vec2 p)\n{\n\t//return(noise(p));\n    p *= 0.3;\n\t\n\tvec3 p3 = vec3(p.x, 0.0, p.y);\n    \n\t/*\n\tfloat n = (//noise(p3) +\n\t\t\t0.5 * noise(p3 * 2.0) +\n\t\t\t0.25 * noise(p3 * 4.0) +\n\t\t\t0.125 * noise(p3 * 8.0) +\n\t\t\t0.0625 * noise(p3 * 16.0) +\n\t\t\t0.03125 * noise(p3 * 32.0)\n\t\t\t//+ 0.015625 * noise(p3 * 64.0)\n    \t\t);\n    \n    */\n    /*\n\tfloat n = (//noise(p3) +\n       \t\t//-0.8 * noise(p3 * 0.5) + \t// Large scale variation.\n\t\t\t0.2 * pow(1.0 + noise(p3 * 2.0), 1.5) +\n\t\t\t0.1 * pow(1.0 + noise(p3 * 4.0), 1.5) +\n\t\t\t0.125 * noise(p3 * 8.0) +\n\t\t\t0.0625 * noise(p3 * 16.0) +\n\t\t\t0.03125 * noise(p3 * 32.0)\n\t\t\t//+ 0.015625 * noise(p3 * 64.0)\n    \t\t);\n    */\n    \n    float val1 = noise(p3 * 1.0);\n        \n\tfloat n = (\n       \t\t -0.2 * noise(p3 * 0.25) + \t// Large scale variation.\n\t\t\t0.5 * pow(noise(p3 * 1.0), 2.0) +\n\t\t\t+ 0.5 * pow(noise(p3 * 0.5 + 0.25), 2.0)+\n\t\t\t0.25 * noise(p3 * 4.0) +\n\t\t\t0.125 * noise(p3 * 8.0)*val1 +\n\t\t\t0.0625 * noise(p3 * 16.0)* (1.0 - val1) +\n\t\t\t0.03125 * noise(p3 * 32.0) * (1.0 - val1) +\n\t\t\t0.015 * noise(p3 * 64.0) * pow(1.0 - val1, 1.5)\t/// Only add this to the lower layers.\n    \t\t);\n    \n    \n    return(n);\n}\n\nfloat detailed_noise_3d(vec3 p)\n{\n    p *= 0.3;\n    \n    float val1 = noise_3d(p);\n        \n\tfloat n = (\n       \t\t -0.2 * noise_3d(p * 0.25) + \t// Large scale variation.\n\t\t\t0.5 * pow(noise_3d(p * 1.0), 2.0) +\n\t\t\t+ 0.5 * pow(noise_3d(p * 0.5 + 0.25), 2.0)+\n\t\t\t0.25 * noise_3d(p * 4.0) +\n\t\t\t0.125 * noise_3d(p * 8.0)*val1 +\n\t\t\t0.0625 * noise_3d(p * 16.0)* (1.0 - val1) +\n\t\t\t0.03125 * noise_3d(p * 32.0) * (1.0 - val1) +\n\t\t\t0.015 * noise_3d(p * 64.0) * pow(1.0 - val1, 1.5)\t/// Only add this to the lower layers.\n    \t\t);\n    \n    \n    return(n);\n}\n\nfloat detailed_noise(vec3 p)\n{\n\treturn(detailed_noise_flat(p.xz));\n}\n\nfloat camera_noise(vec3 p)\n{\n\t//return(noise(p));\n    p *= 0.3;\n    \n\t\n\tfloat n = (\n\t\t\t0.5 * noise(p * 2.0) +\n\t\t\t0.25 * noise(p * 4.0) +\n\t\t\t0.125 * noise(p * 8.0)\n    \t\t);\n    \n    return(n);\n}\n/*\nfloat noise1(vec3 p)\n{\n\t//return(noise(p));\n    p *= 0.01;\n    \n\t\n\tfloat n = 0.5 * noise(p * 2.0);\n    \n    return(n * n * n * n * 4.0);\n}\n*/\nfloat calculate_shadow(vec3 start_position, vec3 light_direction, float max_distance)\n{\n    const float step_size = 0.15;\n    light_direction *= step_size;\n    \n    float occlusion_factor = 1.0;\n    float travelled_distance = 0.0;\n\tconst float k = 4.0;\t// Higher value = harder shadows\n    \n    for(int i=0; i<32; ++i)\n    {\n\t\tstart_position += light_direction;\n        travelled_distance += step_size;\n\t\t\n        float sample_height = detailed_noise_flat(start_position.xz) * terrain_height_multiplicator;\n        \n        float distance_to_surface = start_position.y - sample_height;\t// This is just an approximation!\n\n\t\tocclusion_factor = min(occlusion_factor, k * distance_to_surface / travelled_distance);\n        \n        // Early exit:\n        if(distance_to_surface < 0.0)\n        {\n        \tbreak;   \n        }\n    }\n    \n    return(max(occlusion_factor, 0.0));\n}\n\nvec3 generate_random_coordinate_in_hemisphere(float random1, float random2, float random3)\n{\n\t// TODO: Use my approach from the path tracer instead?\n\t\n    float phi = 6.283185307179586476925286766559 * random1;\n\tfloat costheta = random2;\n\tfloat theta = acos(costheta);\n\t\n\tvec3 p;\n\t\n\tp.x = sin(theta) * cos(phi);\n\tp.y = sin(theta) * sin(phi);\n\tp.z = cos(theta);\n\n\tp.y = abs(p.y);\t// Mirror along Y so we sample a hemisphere instead of a sphere.\n\n\tfloat r = pow(random3, 1.0 / 3.0);\n\t\n\tp *= r;\n        \n    return(p);\n}\n\n\nvec3 get_next_on_sphere2(float random1, float random2, float random3)\n{\n    float phi = 6.283185307179586476925286766559 * random1;\n\tfloat costheta = random2;\n\tfloat theta = acos(costheta);\n\t\n\tvec3 p;\n\tp.x = sin(theta) * cos(phi);\n\tp.y = sin(theta) * sin(phi);\n\tp.z = cos(theta);\n\n\tfloat r = pow(random3, 1.0 / 3.0);\n\t\n\tp *= r;\n        \n    return(p);\n}\n\t\nvec3 get_next_on_sphere(float random1, float random2)\n{\n    vec3 vector;\n\n    vector.z = random1 * 2.0 - 1.0;\n    float theta = random2 * 6.283185307179586476925286766559;\n    float temp = sqrt(1.0 - vector.z * vector.z);\n\n    vector.x = temp * cos(theta);\n    vector.y = temp * sin(theta);\n\n    //return(normalize(vector));\t// TODO: PERFORMANCE: Does this vector need to be normalized?\n    return(vector);\t// TODO: PERFORMANCE: Does this vector need to be normalized?\n}\n\nvec3 generate_random_coordinate_in_hemisphere2(vec3 normal, float random1, float random2, float random3)\n{\n    //vec3 vector = get_next_on_sphere(random1, random2);\n    vec3 vector = get_next_on_sphere2(random1, random2, random3);\n    \n    //vector.y = abs(vector.y);\n    \n   // vector *= pow(random3, 1.0 / 3.0)\n        \n    float sign_multiplicator = 1.0 - 2.0 * step(dot(normal, vector), 0.0);\t// Compute the sign of the dot product (without branching). Results in either \"-1.0f\" or \"1.0f\".\n    \n    // TODO: Theoretically this needs a fourth random number!\n    sign_multiplicator *= pow(random3, 1.0 / 3.0);\t// This makes the distribution uniform inside the hemisphere.\n    \n    vector *= sign_multiplicator;\t// Flip the sign if neccessary, so we sample the hemisphere instead.\n   \n            \n    return(vector);\n}\n\n\nvec3 calculate_colored_ambient_occlusion3(vec3 start_position, vec3 normal, float max_distance,\n                                          vec3 light_direction, vec3 light_color, vec3 sky_color)\n{\n    const float radius = 1.5;\n    const float step_size = 0.1;\n   \n\t\n    float random = hash(fragCoord.xy);\n    \n    /*\n    // Add a random offset per pixel, so the AO banding disappears.\n    vec3 hash_coordinate = floor(start_position * 1024.0);\n    start_position.x += (hash(hash_coordinate.yx) - 0.5) * radius * 0.5;\n    start_position.y += (hash(hash_coordinate.xz) - 0.5) * radius * 0.5;\n    start_position.z += (hash(hash_coordinate.zy) - 0.5) * radius * 0.5;\n    */\n    \n    // TODO: We could take the sky color and light direction into account to calculate colored AO.\n    \n\n        \n    //float center_height = detailed_noise_flat(start_position.xz);\n    \n\tvec3 occlusion_sum = vec3(0.0);\n\tfloat sample_count = 0.0;\n    \n\t\n    /*\n    for(int x=-radius; x<=radius; ++x)\n    for(int y=0; y<=radius; ++y)\n    for(int z=-radius; z<=radius; ++z)\n        */\n    \n    vec3 unoccluded_direction = vec3(0.0);\n    \n    //const int samples = 5;\n    \n    float blend_factor_sum = 0.0;\n    float sky_visibility = 0.0;\n    float horizon_occlusion_sum = 0.0;\n    \n    float smallest_horizon = 9999.9;\n    \n    //const int samples = coordinate_count;\n    const int samples = 1;\n    \n    for(int x=-samples; x<=samples; ++x)\n    for(int z=-samples; z<=samples; ++z)\n    {\n        if((z == 0)&&(x == 0))\n        {\n            continue;\n        }\n        \n      \t// TODO: Exclude center sample!\n        \n        float normalized_hash_offset = float(x) / float(samples);\n        float random1 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 7.0);\n        float random2 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 13.0);\n        float random3 = fract(random + (normalized_hash_offset + 0.7692307692307692307692307692308) * 19.0);\n        \n        //random1 = random2 = random3;\n        \n        \n        vec3 sample_offset = vec3(float(x) * step_size, 0.0, float(z) * step_size);\n        \n        \n        \n        float angle = random * 1.5707963267948966192313216916398;\t// Rotate only by 180Â° because that's enough since we're sampling using a symmetric.\n        float cs = cos(angle);\n        float sn = sin(angle);\n        \n        float rotated_x = sample_offset.x * cs - sample_offset.z * sn; // now x is something different than original vector x\n\t\tfloat rotated_z = sample_offset.x * sn + sample_offset.z * cs;\n        \n        sample_offset.x = rotated_x;\n        sample_offset.z = rotated_z;\n        \n        \n        \n        \n        \n        vec3 sample_coordinate = start_position + sample_offset;\n        sample_coordinate.y = detailed_noise_flat(sample_coordinate.xz) * terrain_height_multiplicator;\n        \n        vec3 sample_coordinate2 = start_position - sample_offset;\n        sample_coordinate2.y = detailed_noise_flat(sample_coordinate2.xz) * terrain_height_multiplicator;\n        \n        \n        \n        vec3 center_to_sample = sample_coordinate - start_position;\n        \n        vec3 n_center_to_sample = normalize(center_to_sample);\n        float cosine = dot(n_center_to_sample, normal);\t// max() not required since we're sampling a hemisphere.\n        \n        float color_blend_factor = max(dot(n_center_to_sample, light_direction), 0.0);\n        color_blend_factor = pow(color_blend_factor, light_exponent);\n        \n        vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n                \n        float sample_weight = cosine;\n        sample_weight = 1.0;\n        \n        float squared_radius = radius * radius;\n\t\tfloat squared_distance = dot(center_to_sample, center_to_sample);\n        sample_weight = max(0.0, 1.0 - squared_distance / squared_radius);\t// Falloff to zero towards \"radius\".\n        \n        sample_weight *= cosine;\t// max() not required since we're sampling a hemisphere.\n        \n        sample_weight = 1.0;\n        \n        // Crytek's method:\n        float sample_unoccluded = step(sample_coordinate.y, start_position.y);\t// 1.0 if unoccluded, 0.0 if occluded.\n       \tvec3 sample_occlusion = sample_color * sample_unoccluded;\n        \n        \n        sample_weight = sample_unoccluded;\n        unoccluded_direction += n_center_to_sample * sample_weight;\n        \n\n        \n        color_blend_factor *= sample_unoccluded;\t// No sun in occluded areas!\n        \n        \n        blend_factor_sum += color_blend_factor * sample_weight;\n        sky_visibility += sample_unoccluded * sample_weight;\n        \n        \n\t\tocclusion_sum += sample_color * sample_unoccluded * sample_weight;\n\t\t//occlusion_sum += sample_occlusion * sample_weight;\n\t\t\n        \n        \n        ////////////////////////////////////////////\n        sample_weight = 1.0;\n        //sample_weight = sample_unoccluded;\n        \n        //vec3 n_center_to_sample = normalize(center_to_sample);\n        vec3 center_to_sample2 = sample_coordinate2 - start_position;\n        vec3 n_center_to_sample2 = normalize(center_to_sample2);\n        \n        float horizon = dot(n_center_to_sample, n_center_to_sample2) * 0.5 + 0.5;\n        horizon = max(dot(n_center_to_sample, -n_center_to_sample2), 0.0);\n        \n        horizon_occlusion_sum += horizon;\n        \n        smallest_horizon = min(smallest_horizon, horizon);\n        ////////////////////////////////////////////\n        \n        \n        \n        sample_count += sample_weight;\n    }\n\t\n    horizon_occlusion_sum /= sample_count;\n    \n\tocclusion_sum /= sample_count;\n\tsky_visibility /= sample_count;\n    blend_factor_sum /= sample_count;\n    \n    \n    //return(vec3(smallest_horizon));\n    return(vec3(horizon_occlusion_sum));\n    \n   \n    unoccluded_direction = normalize(unoccluded_direction / sample_count);\n    \n    return(vec3(max(dot(unoccluded_direction, -light_direction), 0.0)));\n    \n    //return(vec3(max(dot(unoccluded_direction, normal), 0.0)));\n    return(unoccluded_direction * 0.5 + vec3(0.5));\n    \n    /*\n    float color_blend_factor = max(dot(unoccluded_direction, light_direction), 0.0);\n    color_blend_factor = pow(color_blend_factor, light_exponent);\n    vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n\n    occlusion_sum = sample_color;\n    */\n    \n    //occlusion_sum = normal * 0.5 + vec3(0.5);\n    //occlusion_sum = vec3(normal.y);\n    \n   \t//blend_factor_sum = pow(blend_factor_sum, light_exponent);\n    \n    //return(occlusion_sum);\n    \n    \n    return(vec3(sky_visibility));\n    //return(vec3(blend_factor_sum));\n    \n    vec3 indirect_light = mix(sky_color, light_color, blend_factor_sum);\t// Calculate light color\n   \tindirect_light *= sky_visibility;\t// Add sky occlusion\n    \n    return(indirect_light);\n    \n    \n    return(vec3(occlusion_sum));\n}\n\nvec3 calculate_colored_ambient_occlusion(vec3 start_position, vec3 normal, float max_distance,\n                                          vec3 light_direction, vec3 light_color, vec3 sky_color)\n{\n    const float radius = 1.5;\n    \n\tmat3 normal_matrix = construct_around_vector(normal);\n\t\n\tmat4 hemisphere_matrix = mat4(vec4(normal_matrix[0], 0.0),\n                                  vec4(normal_matrix[1], 0.0),\n                                  vec4(normal_matrix[2], 0.0),\n                                  vec4(start_position, 1.0));\n    // TODO: Improve this randomization!\n\t\n    float random = hash(fragCoord.xy);\n    float random1 = random;\n    float random2 = hash(fragCoord.xy * 16.0 + 16.0);\n    float random3 = hash(fragCoord.xy * 32.0 + 32.0);\n    \n    /*\n    // Add a random offset per pixel, so the AO banding disappears.\n    vec3 hash_coordinate = floor(start_position * 1024.0);\n    start_position.x += (hash(hash_coordinate.yx) - 0.5) * radius * 0.5;\n    start_position.y += (hash(hash_coordinate.xz) - 0.5) * radius * 0.5;\n    start_position.z += (hash(hash_coordinate.zy) - 0.5) * radius * 0.5;\n    */\n    \n    // TODO: We could take the sky color and light direction into account to calculate colored AO.\n    \n\n        \n    //float center_height = detailed_noise_flat(start_position.xz);\n    \n\tvec3 occlusion_sum = vec3(0.0);\n\tfloat sample_count = 0.0;\n    \n\t\n    /*\n    for(int x=-radius; x<=radius; ++x)\n    for(int y=0; y<=radius; ++y)\n    for(int z=-radius; z<=radius; ++z)\n        */\n    \n    vec3 unoccluded_direction = vec3(0.0);\n    \n    //const int samples = 5;\n    \n    float blend_factor_sum = 0.0;\n    float sky_visibility = 0.0;\n    \n    //const int samples = coordinate_count;\n    const int samples = 16;\n    for(int i=0; i<samples; ++i)\n    {\n        /*\n        float x = 1.0 - 2.0 / float(samples) * float(i);\n        float y = mod(1.0 - 2.0 / float(samples) * float(i * 2), 1.0);\n        float z = mod(1.0 - 2.0 / float(samples) * float(i * 4), 1.0);\n        */\n        \n       \n        /*\n        const float pi = 3.1415926535897932384626433832795;\n        const float _2pi = 6.283185307179586476925286766559;\n        \n        float factor = 1.0 / float(samples) * float(i);\n        \n        vec3 random_coordinate;\n        random_coordinate.x = sin((random1 + factor) * _2pi);\n        random_coordinate.y = abs(sin((random2 + factor) * _2pi));\n        random_coordinate.z = cos((random1 + factor) * _2pi);\n        \n        random_coordinate *= random3 * radius;\n        \n\t\tvec3 sample_coordinate = (hemisphere_matrix * vec4(random_coordinate, 1.0)).xyz;\n        */\n        \n        \n        /*\n        vec3 random_coordinate = coordinates[i];\n        \n        \n        float angle = random1 * 6.283185307179586476925286766559 + float(i) * float(samples);\n        float cs = cos(angle);\n        float sn = sin(angle);\n        \n        float x = random_coordinate.x * cs - random_coordinate.z * sn; // now x is something different than original vector x\n\t\tfloat z = random_coordinate.x * sn + random_coordinate.z * cs;\n        \n        random_coordinate.x = x;\n        random_coordinate.z = z;\n\n        random_coordinate *= radius;\n       \n\t\tvec3 sample_coordinate = (hemisphere_matrix * vec4(random_coordinate, 1.0)).xyz;\n        */\n        \n        \n        /*\n        float hash_offset = float(i);\n        float normalized_hash_offset = float(i) / float(samples);\n        float random1 = hash(fragCoord.xy + hash_offset * 3.0);\n        float random2 = hash(fragCoord.xy * 7.0 + hash_offset * 13.0);\n        float random3 = hash(fragCoord.xy * 13.0 + hash_offset * 21.0);\n        \n        random1 = fract(random1 + normalized_hash_offset);\n        random2 = fract(random2 + normalized_hash_offset);\n        random3 = fract(random3 + normalized_hash_offset);\n        */\n        \n        float normalized_hash_offset = float(i) / float(samples);\n        float random1 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 7.0);\n        float random2 = fract(random + (normalized_hash_offset + 0.1415926535897932384626433832795) * 13.0);\n        float random3 = fract(random + (normalized_hash_offset + 0.7692307692307692307692307692308) * 19.0);\n        \n        //random1 = random2 = random3;\n        \n        vec3 sample_coordinate = start_position + generate_random_coordinate_in_hemisphere2(normal, random1, random2, random3) * radius;\n        \n        \n        \n        \n        float sample_height = detailed_noise_flat(sample_coordinate.xz) * terrain_height_multiplicator;\n        \n        //vec3 sample_position = vec3(sample_coordinate.x, sample_height, sample_coordinate.z);\n      \n        //float color_blend_factor = dot(normal, light_direction) * 0.5 + 0.5;\n        \n        //float color_blend_factor = max(dot(normal, light_direction), 0.0);\n        \n        vec3 center_to_sample = sample_coordinate - start_position;\n        \n        vec3 random_direction = normalize(center_to_sample);\n        float cosine = dot(random_direction, normal);\t// max() not required since we're sampling a hemisphere.\n        \n        float color_blend_factor = max(dot(random_direction, light_direction), 0.0);\n        color_blend_factor = pow(color_blend_factor, light_exponent);\n        \n        vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n                \n        float sample_weight = cosine;\n        sample_weight = 1.0;\n        \n        float squared_radius = radius * radius;\n\t\tfloat squared_distance = dot(center_to_sample, center_to_sample);\n        sample_weight = max(0.0, 1.0 - squared_distance / squared_radius);\t// Falloff to zero towards \"radius\".\n        \n        sample_weight *= cosine;\t// max() not required since we're sampling a hemisphere.\n        \n        // Crytek's method:\n        float sample_unoccluded = step(sample_height, sample_coordinate.y);\t// 1.0 if unoccluded, 0.0 if occluded.\n       \tvec3 sample_occlusion = sample_color * sample_unoccluded;\n        \n        /*\n        sample_weight = sample_unoccluded;\n        unoccluded_direction += random_direction * sample_unoccluded;\n        */\n\n        \n        color_blend_factor *= sample_unoccluded;\t// No sun in occluded areas!\n        \n        \n        blend_factor_sum += color_blend_factor * sample_weight;\n        sky_visibility += sample_unoccluded * sample_weight;\n        \n        \n\t\tocclusion_sum += sample_color * sample_unoccluded * sample_weight;\n\t\t//occlusion_sum += sample_occlusion * sample_weight;\n\t\tsample_count += sample_weight;\n    }\n\t\n\tocclusion_sum /= sample_count;\n\tsky_visibility /= sample_count;\n    blend_factor_sum /= sample_count;\n    \n    \n    /*\n    unoccluded_direction = normalize(unoccluded_direction / sample_count);\n    \n    float color_blend_factor = max(dot(unoccluded_direction, light_direction), 0.0);\n    color_blend_factor = pow(color_blend_factor, light_exponent);\n    vec3 sample_color = mix(sky_color, light_color, color_blend_factor);\n\n    occlusion_sum = sample_color;\n    */\n    \n    //occlusion_sum = normal * 0.5 + vec3(0.5);\n    //occlusion_sum = vec3(normal.y);\n    \n   \t//blend_factor_sum = pow(blend_factor_sum, light_exponent);\n    \n    //return(occlusion_sum);\n    \n    \n    //return(vec3(occlusion_sum2));\n    //return(vec3(blend_factor_sum));\n    \n    vec3 indirect_light = mix(sky_color, light_color, blend_factor_sum);\t// Calculate light color\n   \tindirect_light *= sky_visibility;\t// Add sky occlusion\n    \n    return(indirect_light);\n    \n    \n    return(vec3(occlusion_sum));\n}\n\nvec3 calculate_normal(vec3 p_center, float step_size)\n{\n    step_size *= 0.2;\n\n    p_center.y = detailed_noise_flat(p_center.xz) * terrain_height_multiplicator;\n\n    vec3 p_x = p_center + vec3(step_size, 0.0, 0.0);\n    p_x.y = detailed_noise_flat(p_x.xz) * terrain_height_multiplicator;\n\n    vec3 p_z = p_center + vec3(0.0, 0.0, step_size);\n    p_z.y = detailed_noise_flat(p_z.xz) * terrain_height_multiplicator;\n\n    vec3 normal = cross(p_center - p_z,\n                        p_center - p_x);\n    \n    return(normalize(normal));\n}\n\nvec3 shade_pixel(vec3 intersection_point, vec3 ray_direction, float step_size)\n{\n    //vec3 normal = calculate_normal(intersection_point, step_size);\n    \n    vec3 normal;\n    if(intersection_point.y < water_height)\t// If water was hit:\t// TODO: Integrate this into the height function!\n    {\n        // TODO: Calculate correct intersection point!\n    \tintersection_point.y = water_height - step_size * 0.05;\n        \n    \tnormal = vec3(0.0, 1.0, 0.0);\n        // TODO: Calculate proper water normal!\n        // TODO: We could actually just trace from the eye to the water instead.\n        \n        // TODO: Move the noise based on time and on the Y axis.\n        vec3 noise_sample_position;\n        noise_sample_position.x = intersection_point.x * 250.0 + adjusted_time * 50.0;\n        noise_sample_position.y = adjusted_time * 50.0;\n        noise_sample_position.z = intersection_point.z * 250.0 + adjusted_time * 50.0;\n        \n        vec3 normal_offset;\n        normal_offset.x = detailed_noise_3d(noise_sample_position) - 0.5;\n        normal_offset.z = detailed_noise_3d(noise_sample_position + vec3(0.0, 13.0, 0.0)) - 0.5;\n        normal_offset.xz *= 0.05;\n        \n        //normal_offset.y = max(1.0 - dot(normal_offset.xz, normal_offset.xz), 0.0);\n        normal_offset.y = 0.5;\n        \n        normal = normalize(normal_offset);\n    }\n    else\n    {\n    \tnormal = calculate_normal(intersection_point, step_size);\n    }\n    \n \tfloat noise_for_rock_color = detailed_noise(intersection_point * 36.0 + vec3(10.0));\n    float noise_for_grass_color = detailed_noise(intersection_point * 40.0 + vec3(10.0));\n\n    float noise_for_rock = detailed_noise(intersection_point * 5.0 + vec3(40.0));\n    float noise_for_snow = detailed_noise(intersection_point * 10.0 + vec3(20.0));\n\n    //noise_for_snow += (texture(iChannel0, intersection_point.xz * 0.5).r * 0.5 - 0.5);\n    //noise_for_snow *= smoothstep(0.0, 0.4, texture(iChannel1, intersection_point.xz * 0.05).r);\n\n\n    vec3 grass_color = vec3(0.6 * intersection_point.y * 0.4, 0.5 * intersection_point.y * 0.4 + 0.15, 0.1);\n   // grass_color = mix(grass_color * 0.7,\n   //                   grass_color,\n   //                   smoothstep(0.2, 0.9, noise_for_grass_color * intersection_point.y));\n    \n    grass_color = 1.2 * grass_color * texture(iChannel1, intersection_point.xz).r;\n\t/*\n    vec3 rock_color = vec3(0.55, 0.55, 0.5) * 0.7;\n    vec3 rock_color2 = vec3(0.55, 0.52, 0.45) * 0.85;\n    rock_color = mix(rock_color,\n                     rock_color2,\n                     smoothstep(0.3, 0.7, noise_for_rock_color * intersection_point.y * 0.5));\n    */\n    vec3 rock_color = vec3(0.55, 0.55, 0.5) * (texture(iChannel0, intersection_point.xz).r * 0.75 + 0.25);\n\n\n    vec3 albedo = mix(grass_color,\t// Grass\n                      rock_color,\t// Rock\n                      min(max(intersection_point.y * 0.28 - 0.35 + (noise_for_rock * 0.4 - 0.2), 0.0) * 15.0, 1.0));\n\n    float snow_strength = min(max(intersection_point.y * 0.3 - 0.5 + (noise_for_snow * 0.4 - 0.2), 0.0) * 20.0, 1.0);\n    \n    //snow_strength -= pow(max(dot(normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5, 0.0), 8.0) * 200.0;\t// Surfaces that don't point up shouldn't get snow.\n    snow_strength *= smoothstep(0.35, 0.45, max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0));\t// Surfaces that don't point up don't get snow.\n    \n    snow_strength = clamp(snow_strength, 0.0, 1.0);\n    \n    albedo = mix(albedo,\n                 vec3(0.75, 0.95, 1.0),\t// Snow\n                 snow_strength);\n\n\n   \n\n\n    float lambert = max(dot(normal, light_direction), 0.0);\n\n\n    vec3 ambient = calculate_colored_ambient_occlusion(intersection_point, normal, 1.0,\n                                                       light_direction, light_color, sky_color);\n   \n\n    float direct_occlusion = calculate_shadow(intersection_point, light_direction, 10.0);\n    lambert *= direct_occlusion;\n\n    vec3 half_vector = normalize(-ray_direction + light_direction);\n\n    float specular_exponent = 2.0;\n    float specular_mask = direct_occlusion * 4.0;\n    \n    if(intersection_point.y < water_height)\t// If water was hit:\t// TODO: Integrate this into the height function!\n    {\n        lambert = max(lambert - 0.75, 0.0) * 4.0;\n        specular_exponent = 640.0;\n        albedo = mix(vec3(0.1, 0.8, 1.0), albedo, 0.25);\n        \n        const float shore_threshold = 0.125;\n        \n        float adjusted_water_height = water_height;\n        adjusted_water_height += sin(detailed_noise_flat(intersection_point.xz * 16.0 + vec2(adjusted_time * 16.0, adjusted_time * 8.0)) * 3.142) * shore_threshold * 0.5;\n        \n        \n        float water_surface_to_ground_distance = adjusted_water_height - detailed_noise_flat(intersection_point.xz) * terrain_height_multiplicator;\n        \n       \n        float shore_factor = 1.0 - smoothstep(0.0, shore_threshold, water_surface_to_ground_distance);\n        albedo = mix(albedo, vec3(1.0), shore_factor);\n    }\n    else\n    {\n        specular_mask *= snow_strength;\n    }\n    \n    float specular = pow(max(dot(half_vector, normal), 0.0), specular_exponent);\n    specular *= specular_mask;\n\n    vec3 result = albedo * (light_color * lambert + ambient);\n\n    //fragColor.rgb += to_linear_space(light_color * specular);\n    result += light_color * specular;\n    \n\n    //fragColor.rgb = vec3(direct_occlusion);\n    //fragColor.rgb = vec3(specular);\n    //fragColor.rgb = vec3(normal.x);\n\n\n    //result = ambient;\n\n    //fragColor.rgb = vec3(normal.x);\n    //fragColor.rgb = vec3(normal.x);\n    //fragColor.rgb = vec3(normal.z);\n\n\n\n    /*\n    fragColor = mix(vec4(0.1, 0.3, 0.0, 1.0),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    fragColor.y);\n    */\n    \n    //return(vec3(lambert));\n    return(result);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\tinitialize_global_variables(fragCoord);\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t//fragColor = vec4(detailed_noise(vec3(uv * 10.0, 0.0)));\n\tfragColor.rgb = sky_color;\n    \n\t//vec3 eye_offset = vec3(10.0, 6.0, sin(iTime * 0.1) * 10.0);\n\t//vec3 eye_offset = vec3(5.0, 3.0, 0.0);\n\tvec3 eye_offset = vec3(5.0, 6.0, 0.0);\n    \n    float angle = iTime * 0.03;\n    vec3 look_direction_on_ground = vec3(sin(angle), 0.0, cos(angle));\n    vec3 look_direction_on_ground_perpendicular = vec3(-look_direction_on_ground.z, 0.0, look_direction_on_ground.x);\n    //vec3 up_vector = cross(look_direction_on_ground, look_direction_on_ground_perpendicular);\n    vec3 up_vector = vec3(0.0, 1.0, 0.0);\n    \n    \n    mat3 rotation_matrix = mat3(look_direction_on_ground_perpendicular,\n                                up_vector,\n                                look_direction_on_ground);\n    \n    \n    //eye_offset.xz = vec2(-cos(angle), sin(angle)) * 4.0;\t// Go around in circle.\n    eye_offset.xz = vec2(cos(angle), sin(angle)) * 10.0;\t// Rotate around weirdly.\n\n    //eye_offset += vec3(0.0, camera_noise(vec3(eye_offset.x, 0.0, eye_offset.z)), 0.0);\n    \n    \n    vec3 eye_position = eye_offset;\n   \n    vec3 ray_start = eye_position;\n\t/*\n\tvec3 look_direction = vec3(0.0, -1.25, 0.0);\n    vec3 ray_direction = normalize(vec3(uv * 2.0 - vec2(1.0), 1.0) + look_direction);\n    */\n    vec3 look_direction = rotation_matrix * vec3(vec3(uv * 2.0 - vec2(1.0), 1.0));\n    look_direction.y -= 0.95;\n    vec3 ray_direction = normalize(look_direction);\n   \n    \n    const int raymarch_samples = 64;\n    const int inverse_raymarch_samples = 10;\n    \n    const float step_size = max_view_distance / float(raymarch_samples);\n        \n    vec3 ray_increment = ray_direction * step_size;\n    vec3 inverse_ray_increment = -ray_increment / float(inverse_raymarch_samples);\n    \n    // Add a random offset to fight precision issues (dithering):\n    //ray_start += ray_increment * hash(fragCoord.xy);\n    \n    float terrain_height;\n    vec3 intersection_point = vec3(9999.9);\n    \n    float accumulated_cloud_density = 0.0;\n    \n    for(int i=0; i<raymarch_samples; ++i)\n    {\n\t\tray_start += ray_increment;\n                \n        // TODO: Randomize colors by applying the noise function!\n\n        /*\n        float cloud_density = max((noise_3d(ray_start * 1.1) - 0.25) * 1.33333, 0.0);\t// Large scale to vary where clouds are.\n        cloud_density *= noise_3d(ray_start * 2.0);\t// Rough cloud shape.\n        cloud_density *= noise_3d(ray_start * 5.0);\t// Detailed cloud shape.\n        \n        \n        float eye_to_sample_distance = distance(eye_position, ray_start);\n        float blend_factor = eye_to_sample_distance / max_view_distance;\n        blend_factor = pow(blend_factor, fog_exponent);\n\t\tcloud_density *= 1.0 - blend_factor;\n        \n        accumulated_cloud_density += cloud_density * 0.15;\n        */\n\n\t\t\n        terrain_height = detailed_noise_flat(ray_start.xz) * terrain_height_multiplicator;\n        \t\t\n       \t// float sample_height = noise1(ray_start);\n\t\tif(ray_start.y < terrain_height)\n\t\t{\n            // Step backwards and out of the surface:\n            for(int j=0; j<inverse_raymarch_samples; ++j)\n            {\n\t\t\t\tray_start += inverse_ray_increment;\n\t\t\t\tterrain_height = detailed_noise_flat(ray_start.xz) * terrain_height_multiplicator;\n                if(ray_start.y >= terrain_height)\n                {\n                \tbreak;   \n                }\n            }\n            \n       \t\tintersection_point = vec3(ray_start.x, terrain_height, ray_start.z);\n\t\t\tbreak;\n\t\t}\n    }\n    \n    if(intersection_point.x < 9000.0)\t// This avoids calling \"shade_pixel()\" for sky pixels.\n    {\n        fragColor.rgb = shade_pixel(intersection_point, ray_direction, step_size);\n    }\n\n    // Now add some fog:    \n    float eye_to_sample_distance = distance(eye_position, ray_start);\n    \n    //float blend_factor = min(eye_to_sample_distance * fog_strength, 1.0);\n    float blend_factor = eye_to_sample_distance / max_view_distance;\n    blend_factor = pow(blend_factor, fog_exponent);\n    fragColor.rgb = mix(fragColor.rgb, sky_color, blend_factor);\n                        \n    // TODO: Properly blend sun color with sky!\n    \n    // Add some sun to the fog:\n    float sun_brightness = dot(light_direction, ray_direction) * 0.5 + 0.5;\n    fragColor.rgb += light_color * pow(sun_brightness, light_exponent);\n    \n    // Apply fake exposure control, to make the snow less blown out:\n    float brightness = (light_color.r + light_color.g + light_color.b) / 3.0;\n    fragColor.rgb = fragColor.rgb / (0.5 + 1.5 * brightness);\n   \n    /*\n    // Add clouds:\n    accumulated_cloud_density = pow(accumulated_cloud_density, 2.0);\n    //fragColor.rgb = mix(vec3(1.0), fragColor.rgb, 1.0 / (1.0 + accumulated_cloud_density));\n    \n    float cloud_blend_factor = min(accumulated_cloud_density * 10.0, 1.0) * (1.0 - blend_factor);\n    vec3 cloud_color = mix(vec3(1.0), sky_color, blend_factor);\n    fragColor.rgb = mix(fragColor.rgb, cloud_color, cloud_blend_factor);\n    */\n    \n    // Crappy tonemapping to make it look more realistic:\n    //fragColor.rgb = pow(fragColor.rgb, vec3(1.0 + fragColor.rgb));\n    //float m = max(fragColor.r, max(fragColor.g, fragColor.b));\n    \n    // Reinhard tonemapping:\n    vec3 original_color = fragColor.rgb;\n    float m = (fragColor.r + fragColor.g + fragColor.b) / 3.0;\n    fragColor.rgb /= m;\n    m = (m / (1.0 + m));\n    fragColor.rgb *= m;\n    \n    fragColor.rgb = mix(original_color, fragColor.rgb, 0.5);\n    \n    //fragColor.rgb = vec3(accumulated_cloud_density);\n    \n    // TODO: How does shadertoy treat gamma?\n    //fragColor.rgb = to_gamma_space(fragColor.rgb);\n}","name":"Image","description":"","type":"image"}]}