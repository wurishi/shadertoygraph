{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Copyright (c) 2013 Andrew Baldwin (twitter: baldand, www: http://thndl.com)\n// License = Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\n// \"Foggy Fields\"\n// An attempt at \"cheap\" volumetric atmosphere on top of a large distance-field, er, field.\n\n// Uncomment this if you have a faster GPU\n//#define HIGH_QUALITY\n\n// Uncomment this if you have a slower GPU\n//#define LOW_QUALITY\n\n#define HILLS\n#define FOG\n\n#ifndef LOW_QUALITY\n  #define SHADOW\n  #define MAX_DISTANCE 2000.\n  #define MAX_ITERATIONS 400\n  #define MAX_DETAIL .001\n\n  #ifdef HIGH_QUALITY\n    #define AO\n    #define DENSER_FIELD\n  #endif\n#else\n  #define MAX_DISTANCE 250.\n  #define MAX_ITERATIONS 200\n  #define MAX_DETAIL .001\n#endif\n\nfloat rnd(vec2 n)\n{\n  return fract(sin(dot(n.xy, vec2(12.345,67.891)))*12345.6789);\n}\n\nfloat rnd2(vec3 n)\n{\n  return fract(sin(dot(n.xyz, vec3(12.345,67.891,40.123)))*12345.6789);\n}\n\nvec3 rnd3(vec3 n)\n{\n\tvec3 m = floor(n)*.00001 + fract(n);\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec3 mp = (31415.9+m)/fract(p*m);\n\treturn fract(mp);\n}\n\nfloat saw(float t)\n{\n\treturn abs(fract(t*.5)*2.-1.)*2.-1.;\n}\n\nfloat csin(float t)\n{\n\tfloat f = fract(t);\n\tf = abs(f*2.-1.);\n    f = f*f*(3.0-2.0*f);\n\treturn f;\n}\n\nfloat distline(float x,float o)\n{\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\tfloat m = .91456789+o*0.345678;\n\tfloat a = fract(i*m+0.5678);//rnd(vec2(i,o));\n\tfloat b = fract((i+1.)*m+0.5678);//rnd(vec2(i+1.,o));\n\treturn mix(a,b,f);\n}\n\nfloat obj2(vec3 pos, vec3 opos,float h)\n{\n\tvec3 coord = floor(pos);\n\tpos.x += rnd(coord.xz)*.5-.25;\n\tpos.z += rnd(coord.xz+1.)*.5-.25;\n\tpos.x += .1*distline(pos.y*2.,coord.x*100.+coord.z)-.05;\n\tpos.z += .1*distline(pos.y*2.,coord.x*103.+coord.z*3.)-.05;\n\tfloat w = .02+.02*step(h-1.,pos.y-1.)*csin(pos.y*2.+.5);//.1+.1*csin(max(pos.y+.4+h,0.));\n\tfloat b = length(pos.xz-coord.xz-.5)-w;/*-w*distline(pos.y*5.,floor(pos.x)*100.+floor(pos.z))*/;\n\treturn b;\n}\n\nfloat mud(vec3 pos)\n{\n\treturn .1*csin(pos.x*1.+distline(pos.z,1.1))*csin(pos.z*1.1+distline(pos.x,1.2));\n}\n\nfloat height(vec3 pos) \n{\n#ifdef HILLS\n\treturn -9.*csin(.006*((pos.x+.5)))*csin(.005*((pos.z+.5)))-40.*csin(.001*(pos.x+.5))*csin(.001*(pos.z+.5));\n#else\n\treturn 0.;\n#endif\n}\n\nfloat gridheight(vec3 pos)\n{\n#ifdef HILLS\n\treturn -9.*csin(.006*floor((pos.x+.5)))*csin(.005*floor((pos.z+.5)))-40.*csin(.001*floor(pos.x+.5))*csin(.001*floor(pos.z+.5));\n#else \n\treturn 0.;\n#endif\n\t\n}\n\nvec2 map(vec3 pos, float time)\n{\n\tvec3 floorpos = pos;\n\tfloorpos.y -= height(pos);\n\tvec2 res = vec2(floorpos.y+1.+mud(pos),0.);\n\n\tif (floorpos.y<4.) {\n\t\tfloat cut = -floorpos.y-0.;\n\t\tvec2 fieldscale = pos.xz*.004;\n\t\tvec2 fieldindex = floor(fieldscale);\n\t\tvec2 fieldpos = fract(fieldscale);\n\t\tfloat fieldtype = mod(fieldindex.x+fieldindex.y,3.);\n\t\tcut += fieldtype;\n\t\tcut = mix(-floorpos.y-1.1,cut,step(.05,fieldpos.x)*step(.05,fieldpos.y));\n\t\tvec3 opos = pos;\n\t\tpos.y -= gridheight(pos);\n\t\tfloat b = obj2(pos,opos,fieldtype);\n#ifdef DENSER_FIELD\n\t\tb = min(b,obj2(pos+2.5,opos+2.5,.5));\n\t\tb = min(b,obj2(pos+5.3,opos+5.3,.3));\n#endif\n\t\tb = max(b,-cut);\n\t\tif (b<res.x) {\n\t\t\tres.x = b;\n\t\t\tres.y = 5.+fieldtype;\n\t\t}\n\t\tif (b>3.) res.y=4.;\n\t} else {\n\t\tres.y = 4.;\n\t}\n\t\t\n\t\n\treturn res;\n}\n\nvec3 normal(vec3 pos, float time)\n{\n\tvec3 eps = vec3(0.001,0.,0.);\n\tfloat dx = map(pos+eps.xyy,time).x;\n\tfloat dy = map(pos+eps.yxy,time).x;\n\tfloat dz = map(pos+eps.yyx,time).x;\n\tfloat mdx = map(pos-eps.xyy,time).x;\n\tfloat mdy = map(pos-eps.yxy,time).x;\n\tfloat mdz = map(pos-eps.yyx,time).x;\n\treturn normalize(vec3(dx-mdx,dy-mdy,dz-mdz));\n}\n\nfloat density(vec3 pos) {\n\tpos += 1.512123;\n\treturn clamp((4.*rnd2(floor(pos*.1))+2.*rnd2(floor(pos*1.))+4.*rnd2(floor(pos*500.)))*max(distline(pos.y-height(pos)*clamp(1.-pos.y*.05,0.2,1.)+iTime*.2,0.)-.4+.4*saw(iTime*.1),0.)*10.,0.,100.);\n}\n\nvec3 model(vec3 rayOrigin, vec3 rayDirection,float time)\n{\n\tfloat t = 0.;\n\tvec3 p;\n\tfloat d = 0.;\n\tbool nothit = true;\n\tvec2 r;\n\tfloat scatter = 0.;\n\t//float iters = 0.;\n\tfor (int i=0;i<MAX_ITERATIONS;i++) {\n\t\tif (nothit) {\n\t\t\tt += d*.5;\n\t\t\tp = rayOrigin + t * rayDirection;\n#ifdef FOG\n\t\t\tfloat den = density(p);\n\t\t\tscatter += d*den;\n#endif\n\t\t\t\n\t\t\tr = map(p,time);\n\t\t\td = r.x;\n\t\t\tnothit = d>t*MAX_DETAIL && t<MAX_DISTANCE;\n\t\t\t//iters += 1.;\n\t\t}\n\t}\n\tt += d*.5;\n\tp = rayOrigin + t * rayDirection;\n\t// Now calculate the amount of scatter between there and\n\tvec3 n = normal(p,time);\n\tfloat lh = abs(fract(iTime*.1)*2.-1.);\n\tlh = 79.*lh*lh*(3.-2.*lh);\n\tvec3 lightpos = vec3(2500.,2500.,2500.);\n\tvec3 lightdist = lightpos - p;\n\tfloat light = clamp(2.+t*.1,0.,40.)+dot(lightdist,n)*5./length(lightdist);\n#ifdef AO\n\t// AO\n\tfloat at = 0.2;\n\tfloat dsum = d;\n\tvec3 ap;\n\tfor (int i=0;i<4;i++) {\n\t\tap = p + at * n;\n\t\tfloat ad = map(ap,time).x;\n\t\tdsum += ad/(at*at);\n\t\tat += 0.1;\n\t}\n\tfloat ao = clamp(dsum*.1,0.,1.);\n\tlight = light*ao;\n#endif\n#ifdef SHADOW\n\t// March for shadow\n\tvec3 s;\n\tfloat st;\n\tfloat sd=0.;\n\tfloat sh=1.;\n\tst=.3;//+.5*rnd2(p+.0123+fract(iTime*.11298923));\n\tvec3 shadowRay = normalize(lightpos-p);\n\tnothit = true;\n\tfor (int i=0;i<40;i++) {\n\t\tif (nothit) {\n\t\t\tst += sd*.5;\n\t\t\ts = p + st * shadowRay;\n\t\t\tsd = map(s,time).x;\n\t\t\tsh = min(sh,sd);\n\t\t\tnothit = sd>0.001;\n\t\t}\n\t}\n\tlight = 2.0*light * clamp(sh,0.1,1.);\n#endif\n\tvec3 m;\n\tm=.5+.2*abs(fract(p)*2.-1.);\n\tm=vec3(0.);//vec3(.05,.4,.0);\n\tif (r.y==0.) {\n\t\tm=vec3(.08,0.05,0.0);\n\t} else if (r.y==2.) {\n\t\tm=.3+vec3(m.x+m.y+m.z)*.333;\n\t} else if (r.y==3.) {\n\t\tm=vec3(1.,0.,0.);\n\t} else if (r.y==4.) {\n\t\tm=vec3(.2,.7,.7);\n\t} else if (r.y==5.0) {\n\t\tm=vec3(.15,.5,.05);\n\t} else if (r.y==6.0) {\n\t\tm=vec3(.41,.4,.05);\n\t} else if (r.y==7.0) {\n\t\tm=vec3(.21,.3,.05);\n\t}\n\t//m=vec3(iters*.001);\n\tvec3 c = vec3(clamp(1.*light,0.,10.))*vec3(m)+vec3(scatter*.001);\n\treturn c; \n}\n\nvec3 camera(in vec2 sensorCoordinate, in vec3 cameraPosition, in vec3 cameraLookingAt, in vec3 cameraUp)\n{\n\tvec2 uv = 1.-sensorCoordinate;\n\tvec3 sensorPosition = cameraPosition;\n\tvec3 direction = normalize(cameraLookingAt - sensorPosition);\n\tvec3 lensPosition = sensorPosition + 2.*direction;\n\tconst vec2 lensSize = vec2(1.);\n    vec2 sensorSize = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 offset = sensorSize * (uv - 0.5);\n\tvec3 right = cross(cameraUp,direction);\n\tvec3 rayOrigin = sensorPosition + offset.y*cameraUp + offset.x*right;\n\tvec3 rayDirection = normalize(lensPosition - rayOrigin);\n\t// Render the scene for this camera pixel\n\tfloat rt = 0.;//fract(iTime);\n\tvec3 colour = vec3(0.);\n\tcolour = 1.*max(model(rayOrigin, rayDirection,iTime),vec3(0.));\n\t// Post-process for display\n\tvec3 toneMapped = colour/(1.+colour);\n\t// Random RGB dither noise to avoid any gradient lines\n\tvec3 dither = vec3(rnd3(vec3(uv.xy,iTime)))/255.;\n\t// Return final colour\n\treturn toneMapped + dither;\n}\n\t\t\nvec3 world(vec2 fragCoord)\n{\n\t// Position camera with interaction\n\tfloat anim = saw(iTime*.1);\n\tfloat rotspeed = 10.*iMouse.x/iResolution.x+6.282*fract(iTime*.01);\n\tfloat radius = (1.+iMouse.y/iResolution.y)*10.;//10.+5.*sin(iTime*.2);\n\tvec3 base = vec3(iTime*3.298,0.,iTime*10.);\n\tvec3 cameraTarget = vec3(0.,-2.,0.)+base;\n\tvec3 cameraPos = vec3(radius*sin(rotspeed),0.,radius*cos(rotspeed))+base;\n\tfloat h = height(cameraPos)+5.+10.*csin(iTime*.013);\n\tcameraTarget.y += h;\n\tcameraPos.y += h;\n\tvec3 cameraUp = vec3(0.,1.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\treturn camera(uv,cameraPos,cameraTarget,cameraUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(world(fragCoord),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfGR7","date":"1365762326","viewed":885,"name":"Foggy Fields","username":"baldand","description":"An attempt at \"cheap\" volumetric atmosphere on top of a large distance-field, er, field.\nMouse to look around","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefields","volumetricfog"],"hasliked":0,"parentid":"","parentname":""}}