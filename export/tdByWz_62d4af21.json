{"ver":"0.1","info":{"id":"tdByWz","date":"1586443800","viewed":559,"name":"O'Hare Main Characters","username":"pronce","description":"The main characters from my 4k exe graphics entry for Revision 2020 with a little cleanup for better readability. Also added some comments. Feel free to shoot me questions. Click and drag to zoom in. Follow me: https://www.instagram.com/thomas_obermaier","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["fur","dog","animal","revision","photorealistic","4kexegfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tNotes:\n\tSome implementations and interfaces are not clean. Remember that this is just a slightly\n\treformatted version of a 4k executable graphics shader. \n\n*/\n\n// global values\nfloat lib_random_seed = 0.0;\nfloat lib_gn_lookup[9];\t\t\t\t// simple lookup table for noise layers (only created once)\n\n/*\n\tLibrary Functions and Macros\n\n\tSome of them are freely floating around the internet without beeing able to credit the original author. Kudos to everyone.\n\tI tried to add source/copyright information and credits whereever possible.\n*/\n#define PI 3.14159265\n#define ASPECT_RATIO 1.77777778\n#define C_D vec2(1.0 / 1920.0, 1.0 / 1080.0)\n\n// this seems to float around everywhere. it's not great but super handy\n#define R(x) fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453) \n#define R3(x) fract(sin(dot(x, vec3(12.9898, 78.233, 113.0)))*43758.5453123)\n\n// Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// just added some global (ugly) seed control\nfloat lib_noise(vec2 st)\n{\n    vec3 i = floor(vec3(st, lib_random_seed));\n    vec3 f = fract(vec3(st, lib_random_seed));\n\n    // Four corners in 2D of a tile\n    float a = R3(i);\n    float b = R3((i + vec3(1.0, 0.0, 0.0)));\n    float c = R3((i + vec3(0.0, 1.0, 0.0)));\n    float d = R3((i + vec3(1.0, 1.0, 0.0)));\n\n    // Smooth Interpolation\n    vec2 u = smoothstep(0.0, 1.0, f.xy);\n\n    // Mix 4 coorners percentages\n    return (mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y) * 2.0 - 1.0;\n}\n\n// simple rotation matrix\nvec2 lib_rotate(vec2 u, float a)\n{\n    float s = sin(a); float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * u;\n}\n\n// a derived noise pattern suitable for hair\nfloat lib_hair_noise_pattern(vec2 s)\n{\n    float n = 0.0;\n    for(float i = 1.0; i < 5.0; i++)\n    {\n\t    n += lib_noise(s * i + R(vec2(i / 3.0, 0.0)) * 100.0) / i;\n    }\n    return clamp((n + 1.0) / 2.0, 0.0, 1.0);    \n}\n\n// voronoise by IQ (https://iquilezles.org/articles/voronoise)\nfloat lib_iq_cell(vec2 x, float u, float v)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat k = 1.0 + 63.0 * pow(1.0 - v, 6.0);\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n\t\n    for(int j = -2; j <= 2; j++)\n\t{\n\t\tfor(int i=-2; i <= 2; i++)\n\t\t{\n            vec2 g = vec2(i, j);\n            vec2 h = p + g;\n            vec3 o = fract(sin(vec3(dot(h,vec2(127.1, 311.7)), \n            \t\t\t\tdot(h,vec2(269.5, 183.3)), \n            \t\t\t\tdot(h,vec2(419.2, 371.9)))) * 43758.5453) * \n            vec3(u, u, 1.0);\n            vec2 r = g - f + o.xy;\n            float d = dot(r, r);\n            float ww = pow(1.0 - smoothstep(0.0, 1.414, sqrt(d)), k);\n            va += o.z * ww;\n\t\t\twt += ww;\n\t\t}\n\t}\n\t\n    return clamp(va/wt,0.0, 1.0);\n}\n\n/*\n\tDrawing of shapes\n\n\tThe basic shape of the dog and hare is made of a few ellipses and polygons that are created in a separate tool.\n\tVertex data is packed as integers with offsets and in a range of 0...500. packs well and gives acceptable accuracy\n\tfor 4k. Code is generated from my 4k graphics editor and updated for the shader.\n*/\n#define Z vec2(1.922, 1.081) * 2.0\n#define Bunny01 0\n#define Bunny02 1\n#define Bunny03 2\n#define Bunny04 3\n#define Bunny05 4\n#define Leg1 5\n#define Leg2 6\nint indices[8] = int[8](0, 22, 26, 42, 50, 66, 80, 86);\nvec2 shapes[86] = vec2[86](vec2(263,85),vec2(6,-10),vec2(5,10),vec2(-10,13),vec2(1,10),vec2(11,-7),vec2(4,18),vec2(-11,15),vec2(-7,22),\n                           vec2(21,-13),vec2(-3,29),vec2(-21,-7),vec2(-7,37),vec2(45,10),vec2(3,19),vec2(-44,7),vec2(38,24),vec2(-44,-28),\n                           vec2(-18,13),vec2(41,61),vec2(-21,23),vec2(-22,-76),vec2(53,-60),vec2(17,-18),vec2(6,14),vec2(-12,27),\n                           vec2(-33,105),vec2(-3,-111),vec2(-14,19),vec2(-5,107),vec2(-16,-5),vec2(13,-99),vec2(-13,-11),vec2(-15,98),\n                           vec2(-13,-31),vec2(16,-53),vec2(1,-25),vec2(-25,47),vec2(0,-20),vec2(16,-35),vec2(-12,14),vec2(6,-10),\n                           vec2(-2,57),vec2(-1,-25),vec2(-10,0),vec2(-1,20),vec2(-13,6),vec2(0,-22),vec2(-6,5),vec2(1,13),vec2(72,-24),\n                           vec2(-14,-10),vec2(0,-15),vec2(9,-3),vec2(-3,-17),vec2(-9,4),vec2(-3,-18),vec2(9,-7),vec2(3,-10),vec2(-13,1),\n                           vec2(2,-12),vec2(10,4),vec2(1,-6),vec2(-10,-4),vec2(4,-3),vec2(3,1),vec2(-2,74),vec2(23,-5),vec2(4,-38),\n                           vec2(-17,-1),vec2(2,-23),vec2(16,5),vec2(3,-15),vec2(-18,-9),vec2(1,-19),vec2(13,1),vec2(1,-15),vec2(-16,0),\n                           vec2(-3,-7),vec2(12,-1),vec2(24,76),vec2(6,-39),vec2(4,-15),vec2(-17,5),vec2(2,-22),vec2(18,-1));\n\nvoid sh_unpack()\n{\n    for(int i = 1; i < 86; i++) \n        shapes[i]+=shapes[i-1];\n}\n\nbool sh_point_in_triangle(vec2 s, vec2 a, vec2 b, vec2 c)\n{\n\ta *= Z;\n\tb *= Z;\n\tc *= Z;\n    vec2 as = s-a;\n    bool s_ab = (b.x-a.x) * as.y - (b.y - a.y) * as.x > 0.0;\n    if((c.x - a.x) * as.y - (c.y - a.y) * as.x > 0.0 == s_ab) return false;\n    if((c.x - b.x) * (s.y - b.y) - (c.y - b.y)*(s.x - b.x) > 0.0 != s_ab) return false;\n    return true;\n}\n\nbool sh_point_in_quad(vec2 s, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n  return sh_point_in_triangle(s, a, b, c) || sh_point_in_triangle(s, a, c, d);\n}\n\nfloat sh_draw_shape(float q, vec2 s, int id)\n{\n\tint ptSize = indices[id+1] - indices[id];\n\tfor(int i = indices[id]; i < indices[id] + 2 * (ptSize / 2) - 2; i+=2)\n\t\tif(sh_point_in_quad(s, shapes[i], shapes[i + 1], shapes[i + 2], shapes[i + 3])) \n\t\t\treturn 1.0;\n\treturn q;\n}\n\nvec2 sh_draw_ellipse(vec2 u, vec2 position, float radius, float yFactor, float a)\n{\n    u -= position;\n    u.y /= ASPECT_RATIO;\n    u = lib_rotate(u, a);\n    u /= vec2(1.0, yFactor);\n\n    float l=length(u) / radius;\n    return vec2(l < 1.0 ? 1.0 : 0.0 ,max(0.0, 1.0 - l));\n}\n\n/*\n\n\t2D texture generators for colors and fur\n\n*/\n// global variables that can be adjusted during runtime (for size reasons they're global, don't do that!)\nfloat HAIR_LENGTH = 100.0;\nfloat TOUSLE = 0.0;\nfloat BORDER = 1.5;\nfloat hairtexture(vec2 uv, float a)\n{\n    // the fur thingy basically works like that: stretch some hair noise in one axis, render stretches with some variation in patches\n    // and rotate each pattern along the parameter. since the rotation happens around the patch center, you can create fur-like transitions.\n    // transitions are enhanced by overlapping patterns. the code below is already simplified for 4k, i might release the fur pattern\n    // with a functional breakdown in the future if you're interested! let me know in the comments\n\tvec2 offsets[9] = vec2[9](vec2(0.0), vec2(0.5), vec2(-0.5),\n                              vec2(0.5, 0.0), vec2(-0.5, 0.0),\n                              vec2(0.0, 0.5), vec2(0.0, -0.5),\n                              vec2(0.5, -0.5), vec2(-0.5, 0.5));\n\n    float f = 0.0;\n    for(int i = 0; i < 9; i++)\n    {\n        lib_random_seed++;\n        vec2 u = uv * 10.0 + offsets[i];\n        vec2 o = floor(u);\n        vec2 hp = fract(u) - vec2(0.5);\n        hp = lib_rotate(hp, a + sin(R(o) * 5.0) * TOUSLE);   \n        float h =  max(0.0, 1.0 - min(1.0 - smoothstep(0.0, 2.3, lib_hair_noise_pattern((hp + o) * vec2(1.0 / HAIR_LENGTH, 0.5) * 70.0)), 1.0));\n        h = pow(h * max(1.0 - length(hp) * BORDER, 0.0), 1.0 / 3.0);\n        f = max(f, mix(h, h * lib_gn_lookup[int(lib_random_seed) % 4], h));\n    } \n    lib_random_seed = 0.0;\n    \n    return f;\n}\n\nfloat globalHair = 0.0;\nvec3 getDogColor(vec2 u, float h)\n{\n  vec3 dogLightBaseColor = mix(vec3(0.91, 0.84, 0.95),\n                           vec3(0.75, 0.67, 0.79),\n                           lib_gn_lookup[2]);   \n  h *= h;       \n  h = min(1.0, h * 3.0);\n \n  dogLightBaseColor += vec3(u.y * u.y * lib_gn_lookup[3]) * 0.1 * vec3(1.0, u.y, 0.5);\n  \n  h = mix(h, globalHair, 0.3 * lib_gn_lookup[6]);\n  \n  return dogLightBaseColor * h * vec3(1.0, 0.85, 0.8);\n}\n\n\n/*\n\n\tThe actual rendering of the dog and hare characters\n\n\tthis is basically just procedural drawing. plain simple and forward. some color adjustments went back and forth and it\n\tmight be possible to simplify the underlying patterns a lot!\n\n\tdraw the shapes and ellipses, some shapes are blurred a little to mimic smooth transitions. everything gets colored\n\tand hairs are applied to match the current orientation of the real hairs in the reference. \n\n*/\nvec3 add_dog(vec2 s, vec2 u, vec3 col)\n{\n\t// generate a global hair pattern\n\tTOUSLE = 1.0;\n\tHAIR_LENGTH=10.0;\n\tglobalHair = hairtexture(u, lib_gn_lookup[2] * 3.0);\n\n\n\tfloat r = 0.0;\n\n\t// dog shadow\n\tcol = mix(col, vec3(0.0), sh_draw_ellipse(u, vec2(0.42, 0.22), 0.2, 0.15 + 0.3 * lib_gn_lookup[2], -0.05).y * 0.3);\n\n\t// forehead/ears mask\n\tfloat qw = 0.0;\n\tfor(int x = -4; x <= 4; x++) \n\t{\n\t\tfor(int y = -4; y <= 4; y++)\n\t\t{\n\t\t\tvec2 q=u + vec2(x, y) * C_D * 2.0;\n\t\t\tqw = sh_draw_ellipse(q, vec2(0.472, 0.735), 0.07, 0.6, 1.15).x;\n\t\t\tqw = max(qw, sh_draw_ellipse(q, vec2(0.52, 0.731), 0.065, 0.58, -1.45).x);\n\t\t\tqw = max(qw, sh_draw_ellipse(q, vec2(0.547, 0.69), 0.03, 0.4, -1.45).x);\n\t\t\tr += qw;\n\t\t}\n\t}\n\tr /= 81.0;\n\n    // some transition masks to mix different hair styles together\n\tfloat head_topToBottom = clamp((0.86 - u.y) / 0.25, 0.0, 1.0);\n\tfloat head_leftToRight = clamp((0.56 - u.x) / 0.14, 0.0, 1.0);\n\tfloat centerEyes = min(1.0, sh_draw_ellipse(u - vec2(lib_gn_lookup[3]) * 0.01, vec2(0.487, 0.74), 0.06, 0.7, -0.5).y * 2.0);\n\n\tfloat hr = 0.0;\n\tfloat crazyNoseHairBlendMask = 0.0;\n\tif(r > 0.0)\n\t{\n\t\tHAIR_LENGTH=30.0;\n\t\tTOUSLE=sin(head_leftToRight*PI)*.5;\n\t\tHAIR_LENGTH=30.0;\n\t\tBORDER=2.0;\n\t\thr = hairtexture(u, 1.6 + head_leftToRight * PI) * (1.0 - centerEyes * head_topToBottom);\n\n\t\tfloat frontHair = hairtexture(u, head_topToBottom - 2.0);\n\t\tfrontHair = max(0.0, (frontHair - 0.1) * centerEyes * (1.0 - head_topToBottom * 1.1) * 2.0);\n\n\t\thr = max(hr, frontHair);\n\t\tcrazyNoseHairBlendMask = min(1.0, pow(frontHair * 3.0, 3.0));\n\t\tcol=mix(col, getDogColor(u,hr), r);\n\t}\n\n\t// dog body\n\tr=0.0;\n\tvec2 qq=vec2(0.0);\n\tvec2 rq=vec2(0.0);\n\tfor(int x = -4; x <= 4; x++) \n\t{\n\t\tfor(int y = -4; y <= 4; y++)\n\t\t{\n\t\t\tvec2 q=u+vec2(x,y) * C_D * 2.0;\n\t\t\tqq = sh_draw_ellipse(q, vec2(0.473, 0.3272), 0.04, 1.2, 0.0);\n\t\t\tqq = max(qq, sh_draw_ellipse(q, vec2(0.49, 0.46), 0.04, 1.2, 0.0));\n\t\t\tqq = max(qq, sh_draw_ellipse(q, vec2(0.49, 0.46), 0.04, 1.2, 0.0));\n\t\t\tqq = max(qq, sh_draw_ellipse(q, vec2(0.52, 0.32), 0.04, 1.4, 0.0));\n\t\t\tqq = max(qq, sh_draw_ellipse(q, vec2(0.445, 0.25), 0.03, 0.3, 0.0));\n\t\t\trq += qq;\n\t\t}\n\t}\n\trq /= vec2(81.0);\n\t\n\tHAIR_LENGTH=3.0;\n\thr = hairtexture(u, pow(lib_gn_lookup[1], 0.5) * 30.141) * 0.5;\n\tcol = mix(col, vec3(getDogColor(u, hr) * pow(pow(1.0 - rq.y, 0.1), 3.0)), rq.x);\n\n\t// dog legs\n\tfloat q=0.0;\n\tqw=0.0;\n\tfor(int x = -4; x <= 4; x++) \n\t{\n\t\tfor(int y = -4; y <= 4; y++)\n\t\t{\n\t\t\tvec2 p=s + vec2(x, y);\n\t\t\tq = sh_draw_shape(q, p, Leg1);\n\t\t\tq = sh_draw_shape(q, p, Leg2);\n\t\t\tqw += q;\n\t\t\tq = 0.0;\n\t\t}\n\t}\n\tqw /= 81.0;\n\tfloat legDown = clamp((0.44 - u.y) / 0.28, 0.0, 1.0);\n\tHAIR_LENGTH=10.0 + legDown * legDown * 70.0;\n\tTOUSLE=0.2;\n\tBORDER=2.0;\n\thr = hairtexture(u, u.x * 10.0 - u.y * 0.5) * (1.0 - pow(1.0 - legDown, 2.0));\n\tcol=mix(col, getDogColor(u, hr), qw);\n\n\n\t// bunny\n\tqw = 0.0;\n\tfor(int x = -4; x <= 4; x++) \n\t{\n\t\tfor(int y = -4; y <= 4; y++)\n\t\t{\n\t\t\tvec2 p = s + vec2(x,y);\n\t\t\tfor(int i = 0; i < 5; i++) q = sh_draw_shape(q, p, Bunny01+i);\n\t\t\tqw += q;\n\t\t\tq = 0.0;\n\t\t}\n\t}\n\tqw /= 81.0;\n\n\tfloat hairMix = lib_iq_cell((u-vec2(.075, 0.13)) * 5.0, 1.0, 0.3);\n\tHAIR_LENGTH=10.0;\n\tTOUSLE=0.3;\n\tfloat bc = hairtexture(u, 1.0);\n\tif(u.x > 0.47)\n\tHAIR_LENGTH=8.0;\n\telse\n\t{\n\t\tHAIR_LENGTH=7.0 + (.47 - u.x) * 10.0;\n\t\tTOUSLE = 0.3 + (0.47 - u.x) * 4.0;\n\n\t}\n\tbc = mix(bc, hairtexture(u, -1.0 - lib_gn_lookup[3] * 0.9), hairMix);\n\tvec3 bunnyPalette=mix(vec3(0.627, 0.40f, 0.36), vec3(0.9, 0.8, 0.72), hairMix * lib_gn_lookup[5]);\n\tbunnyPalette = mix(vec3(1.15, 0.9, 0.8) * 1.3, bunnyPalette, lib_gn_lookup[6] * u.x);\n\tvec3 bunnyCol = vec3(bc*(1.0 - r)) * bunnyPalette;\n\tcol = mix(col, bunnyCol * pow(hairMix * (0.1 + lib_gn_lookup[4]), 0.2), qw);\n\n\t// snout color\n\tcol = mix(col, vec3(0.1, 0.08, 0.06) * col, sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.39, 0.44), 0.1, 0.3, -0.9).y * qw);\n\tcol = mix(col, col * 3.0, sh_draw_ellipse(u+vec2(lib_gn_lookup[6]) * 0.01, vec2(0.415, 0.46), 0.035, 0.3, 0.0).y*qw);\n\tcol = mix(col, col * 3.0, sh_draw_ellipse(u+vec2(lib_gn_lookup[6]) * 0.01, vec2(0.415, 0.47), 0.02, 0.4, 0.9).y*qw);\n\tcol = mix(col, vec3(0.1, 0.1, 0.06) * col, (1.0 - pow(1.0 - sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.41, 0.46), 0.02, 0.3, -0.9).y, 1.5)) * qw);\n\tcol = mix(col, vec3(0.1, 0.1, 0.06) * col, (1.0 - pow(1.0 - sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.41, 0.46), 0.02, 0.3, 0.5).y, 1.2)) * qw);\n\n\t// ear color\n\tcol = mix(col, vec3(.92, 0.89, 0.96), sh_draw_ellipse(u + vec2(lib_gn_lookup[5]) * 0.015, vec2(0.35, 0.54), 0.08, 0.3, 0.0).y * qw);\n\n\t// neck color splotch\n\tcol = mix(col, vec3(0.92, 0.89, 0.96)*col * 1.6, (1.0 - pow(1.0 - sh_draw_ellipse(u+vec2(lib_gn_lookup[6]) * 0.005, vec2(0.4, 0.53), 0.1, 0.3, 1.0).y, 1.2)) * qw);\n\tcol = mix(col, vec3(0.1) * col * 1.6, pow(sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.41, 0.52), 0.06, 0.4, -1.5).y, 1.5) * qw);\n\n\t// feet color splotch\n\tcol = mix(col, vec3(0.92, 0.89, 0.96) * col * 2.5, (1.0 - pow(1.0 - sh_draw_ellipse(u+vec2(lib_gn_lookup[6]) * 0.005, vec2(0.47, 0.35), 0.08, 0.5, 0.5).y, 1.2)) * qw);\n\tcol = mix(col, vec3(dot(col,vec3(1.0 / 3.0))) * 1.3, sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.55, 0.32), 0.05, 0.25, -1.3).y * qw);\n\tcol = mix(col, vec3(0.1, 0.08, 0.06)*col, sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.56, 0.32), 0.03, 0.25, -1.3).y * qw);\n\n\t// other splotches\n\tcol = mix(col, vec3(0.9, 0.7, 0.6)*col, sh_draw_ellipse(u, vec2(0.448, 0.41), 0.1, 0.25, 1.3).y * qw);\n\tcol = mix(col, vec3(dot(col,vec3(1./3.)))*1.3, sh_draw_ellipse(u, vec2(0.56, 0.48), 0.06, 0.8, 0.8).y * qw);\n\n\t// flowr\n\tcol = mix(col, vec3(dot(col,vec3(1.0 / 3.0))) * 3.0, sh_draw_ellipse(u+vec2(lib_gn_lookup[6]) * 0.005, vec2(0.6, 0.4), 0.02, 1.0, 0.0).y * qw);\n\tcol = mix(col, vec3(0.2) * col, sh_draw_ellipse(u + vec2(lib_gn_lookup[6]) * 0.005, vec2(0.595, 0.41), 0.03, 0.5, -0.3).y * qw);\n\n\t// bite shadow\n\tcol = mix(col, col * 0.6, sh_draw_ellipse(u, vec2(0.492, 0.625), 0.08, 0.5, 0.0).y * qw * 3.0);\n\n\t// final colors\n\tcol = mix(col, vec3(dot(col,vec3(1.0 / 3.0))), pow(lib_iq_cell(u * 40.0, 1.0, 1.0), 2.0) * qw * 0.5);\n\n\n\tvec3 sl = vec3(0.0);\n\tBORDER=0.1;\n\tr=0.0;\n\n\t// dog snout\n\tfloat noseRight=clamp((0.542 - u.x) / 0.1, 0.0, 1.0);\n\tfloat noseDown = clamp((0.74 - u.y) / 0.15, 0.0, 1.0);\n\tfor(int x = -4; x <= 4; x++) \n\t{\n\t\tfor(int y = -4; y <= 4; y++)\n\t\t{\n\t\t\tvec2 q=u + vec2(x, y) * C_D * 2.0;\n\t\t\tfloat qw = 0.0; \n\t\t\tqw = clamp((1.0 - length(vec2(0.5, 0.66) - q + vec2(lib_gn_lookup[2]) * -0.02) / 0.05) * 5.0, 0.0, 1.0);\n\t\t\tqw = max(qw, 1.0 - length(vec2(0.5, 0.72) - q + vec2(lib_gn_lookup[2]) * -0.01) / 0.06);\n\t\t\tr += qw;\n\t\t}\n\t}\n\tr /= 81.0;\n\n\tif(r > 0.0)\n\t{\n\t\tTOUSLE=1.0;\n\t\tBORDER=1.5;\n\t\tHAIR_LENGTH=20.0;\n\n\t\thr = hairtexture(u,noseRight * 3.0);\n\t\thr *= pow(max(noseDown, hr), 0.8);\n\t\n\t\tfloat nose = pow(1.0 - sh_draw_ellipse(u, vec2(0.5, 0.61), 0.018, 0.95, 0.0).y, 2.9 + lib_gn_lookup[7]);\n\t\tfloat noseGlint = pow(1.0 - sh_draw_ellipse(u, vec2(0.5, 0.616), 0.016, 1.0, 0.0).y, 2.9 + lib_gn_lookup[7]);\n\n\t\tsl = getDogColor(u, hr*nose)*pow(noseDown, 0.3) * 2.2;\n\t\tsl = mix(vec3(0.2, 0.15, 0.15), sl, pow(1.0 - sh_draw_ellipse(u, vec2(0.5, 0.65), 0.1 * noseDown, 0.4, 1.6).y, 2.0));\n\t\tsl += vec3(0.25, 0.25, 0.3) * (1.0 - noseGlint);\n\t\tsl *= nose;\n\n\t\tr *= max(0.0, 1.0 - crazyNoseHairBlendMask * 2.2);\n\t}\n\n\treturn  mix(col, sl, r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized uv coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    // correct aspect ratio in case the viewport is scaled (phones, etc)\n    uv.x -= 0.5;\n    uv.x *= (iResolution.x / iResolution.y) / ASPECT_RATIO;\n    uv.x += 0.5;\n    \n    // click+zoom\n    if(iMouse.z > 0.0)\n    {\n        vec2 p = iMouse.xy/iResolution.xy;\n        uv -= vec2(p);\n        uv *= 0.25;\n        uv += vec2(p);\n    }\n    \n    // restored fullHD pixel coordinates for reference\n    vec2 sc = uv * vec2(1920.0, 1080.0);\n    \n    //unpack compressed shape data\n    sh_unpack();\n    \n    // build a global lookup table for noise in different resolutions\n\tfor(int i = 0; i < 9; i++) lib_gn_lookup[i] = max(0.0, lib_hair_noise_pattern(uv * pow(2.0,  float(i) + 1.0)));\n\n    // generate backdrop\n    vec2 d3 = mix(uv * 2.0,\n                  vec2(uv.x - 0.5, 1.0) * 4.0 * pow(uv.y, 0.5),\n                  uv.y);\n    vec3 col = vec3(mix(vec3(0.6, 0.62, 0.64) * 0.75,\n                    vec3(0.8, 0.8, 0.76),\n        \t\t\tlib_iq_cell(d3, 1.0, 1.0)));\n    col = mix(col * vec3(1.05, 1.05, 1.1), col, uv.y) * 0.85;\n    col *= 1.0 - pow(length(uv - vec2(0.5)), 3.0);\n    col *= 1.0 + uv.y * 0.2;\n    \n    // render the dog on top of the background image\n  \tcol = add_dog(sc, uv, col); \n    \n    // apply color correction\n  \tcol = max(vec3(0.0), col.rgb - vec3(0.1)) + vec3(0.08);\t// adjust black/white point\n  \tcol = pow(col.rgb, vec3(0.91, 0.92, 0.9)); \t\t\t\t// apply some cheap color curves\n  \tcol *= 1.3;\t\t\t\t\t\t\t\t\t\t\t\t\t// enhance brightness\n    col += vec3(R(uv)) * 0.05;\t\t\t\t\t\t\t\t\t// add some noise. makes it feel 'alive'\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}