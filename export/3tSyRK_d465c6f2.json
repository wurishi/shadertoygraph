{"ver":"0.1","info":{"id":"3tSyRK","date":"1594751646","viewed":53,"name":"jep_colorbands","username":"Eindacor_DS","description":"a fun one, for to to","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct harmonicSettings\n{\n    float rowCount; \t\t\t\t\t\t// number of vertical divisions\n    float cycleTime; \t\t\t\t\t\t// duration for the sync of all rows\n    float oscillationsPerCycleOfSlowest;  \t// oscillations of the slowest band per cycle\n    float thickness;\t\t\t\t\t\t// thickness of horizontal bands\n    bool showThickness;\n    bool showShade;\n    bool showMirror;\n};\n    \nvec3 rotateColor(vec3 color, float rotationX, float rotationY, float rotationZ) {\n    vec3 deNormalized = (color * 2.f) - vec3(1.f);\n    \n    mat3 rotationXMatrix = mat3(\n        1.f, 0.f, 0.f,\n    \t0.f, cos(rotationX), -sin(rotationX),\n    \t0.f, sin(rotationX), cos(rotationX)\n    ); \n    \n    mat3 rotationYMatrix = mat3(\n    \tcos(rotationY), 0.f, sin(rotationY),\n        0.f, 1.f, 0.f,\n        -sin(rotationY), 0.f, cos(rotationY)\n    );\n    \n    mat3 rotationZMatrix = mat3(\n    \tcos(rotationZ), -sin(rotationZ), 0.f,\n        sin(rotationZ), cos(rotationZ), 0.f,\n        0.f, 0.f, 1.f\n    );\n    \n    return ((deNormalized * rotationXMatrix * rotationYMatrix * rotationZMatrix) + vec3(1.f)) / 2.f;\n}\n    \nvec3 getColor(harmonicSettings settings, vec2 uv, float renderTime)\n{\n    int primaryIndex = 2;\n    int secondaryIndex = int(mod(float(primaryIndex) + 1.f, 3.f));\n    int tertiaryIndex = int(mod(float(secondaryIndex) + 1.f, 3.f));\n    \n    float rowIndex = floor(uv.y * settings.rowCount);    \n    float oscillations = settings.oscillationsPerCycleOfSlowest + rowIndex;\n    \n    float period = settings.cycleTime / oscillations; \n    \n    float twoPiR = 6.28318531;\n     \n    if (settings.showThickness)\n    {\n    \tsettings.thickness = settings.thickness * (1. - 2. * abs(uv.x - .5));\n    }\n     \n    // normalizes -1,1 sin values to 0,1\n    float xPos = (sin(twoPiR * renderTime / period) + 1.) / 2.;\n    \n    float baseColorVal = .5;\n    vec3 color = vec3(baseColorVal);\n    color[primaryIndex] = 1.f;\n    \n    float band1Delta = abs(xPos - uv.x);\n    if (band1Delta < settings.thickness)\n    {\n        color[secondaryIndex] += (1.f - band1Delta/settings.thickness/2.f) * 1.f - baseColorVal;\n    }\n    \n    float band2Delta = abs(xPos - (1. - uv.x));\n    if (true ||settings.showMirror && band2Delta < settings.thickness)\n    {\n        color[tertiaryIndex] += (1.f - band2Delta/settings.thickness/2.f) * 1.f - baseColorVal;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float renderTime = iTime;\n    uv.y += renderTime * .05;\n\n    // settings: rowCount, cycleTime, oscillations, thickness, showThickness, shade, mirror\n    harmonicSettings preset00 = harmonicSettings(8., 200., 4., .5, true, true, true);  \n    harmonicSettings preset01 = harmonicSettings(40., 120., 30., .25, true, true, true);\n    harmonicSettings preset02 = harmonicSettings(120., 120., 10., .25, true, true, true);\n    harmonicSettings preset03 = harmonicSettings(200., 200., 10., .25, false, true, false);\n    harmonicSettings preset04 = harmonicSettings(120., 240., 10., .02, true, true, true);\n    harmonicSettings preset05 = harmonicSettings(12., 1200., 10., .4, true, true, true);\n    \n    vec3 color = getColor(harmonicSettings(20., 200., 2., .3, true, true, true), uv, renderTime);\n    //vec3 color = getColor(preset00, uv, renderTime);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}