{"ver":"0.1","info":{"id":"wdlyRn","date":"1585064229","viewed":147,"name":"Ray March test 1","username":"bgold","description":"Some initial tests in raymarching, trying out SDFs that also return a surface normal. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RATE 0.5\n#define STEPS 20\n\nvec3 rotx(in vec3 r, float a) {\n    return vec3(r.x, cos(a)*r.y+sin(a)*r.z, cos(a)*r.z-sin(a)*r.y);\n}\nvec3 roty(in vec3 r, float a) {\n    return vec3(cos(a)*r.x+sin(a)*r.z, r.y, cos(a)*r.z-sin(a)*r.x);\n}\n\nvec4 dist_s(in vec3 x, in vec3 s, in float rad) { \n    vec3 norm = normalize(x-s);\n    float d = distance(x,s) - rad;\n    return vec4(norm, d);\n}\n\nvec4 dist_c(in vec3 x, in vec3 c, in float side) {\n    vec3 norm = normalize(trunc(normalize(x-c)/side));\n    norm = norm;\n    //norm = normalize(trunc(norm*1.732));\n    vec3 dv = max((x-c)-side, -side-(x-c));\n    float d = max(max(dv.x,dv.y),dv.z);\n    return vec4(norm,d);\n}\n\nvec3 transform(in vec3 x) {\n    return rotx(roty(x,iTime*RATE), iTime/4.1*RATE);\n}\nvec3 transform2(in vec3 x) {\n    return rotx(roty(x,iTime/1.1*RATE), iTime/4.2*RATE);\n}\n\nvec4 estdist(in vec3 x) {\n    vec3 xform = transform(x);\n    vec3 c = vec3(2.5,3.5,5.5);\n    xform = mod(xform + 0.5*c,c)-0.5*c;\n    vec4 obj1 = dist_s(xform, vec3(0,0,0), 0.8);\n    vec4 obj2 = dist_c(xform, vec3(0,0,0), 0.55);\n    vec4 obj3 = dist_s(xform, vec3(0,0.6,0), 0.45);\n    vec4 obj4 = dist_s(xform, vec3(0,-0.6,0), 0.45);\n    vec3 norm = normalize( obj1.xyz*0.9 + obj2.xyz*0.1 );\n    return vec4(norm, max(max(max(obj1.w,obj2.w),-obj3.w),-obj4.w));\n}\n\nvec4 march(in vec3 start, in vec3 dir) {\n    vec3 x = start;\n    vec4 rval;\n    float dx;\n    vec3 norm;\n    for (int i=0; i<STEPS; i++) {\n        rval = estdist(x);\n        if (rval.w < 0.001) break;\n/*       \n\t\tif (rval.w > 10.0) {\n            rval = estdist(cross(x,-dir));\n            break;\n        }\n*/\n        x = x + rval.w * dir;\n    }\n    float dist = distance(start,x);\n    norm = rval.xyz;    \n    return vec4(norm,dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5))*2.0 * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec3 campos = vec3(0,0,1.5);\n    vec2 distortion = sin(uv*vec2(11.0,9.0)+iTime*vec2(10.0,12.0))/5.0;\n    vec3 camdir = normalize(vec3(uv,0)-campos);\n    \n    vec4 m = march(campos, camdir);\n    vec3 result = campos + m.w*camdir;\n    vec3 normdistort = sin(transform2(result) * 200.0)*0.1;\n    \n    vec3 norm = normalize(m.xyz + normdistort);\n\n    vec3 lightdir = normalize(vec3(1.1, -0.9, -1.2));\n    float shade1 = pow(0.5 - 0.5 * dot(norm, transform2(lightdir)), 1.5);\n    vec3 col1 = shade1 * vec3(1.0,0.5,1.0);\n    float shade2 = pow(0.5 - 0.5 * dot(norm, transform(lightdir)), 5.5)*0.4;\n    vec3 col2 = shade2 * vec3(1.0,1.0,0.0);\n    vec3 amb = vec3(1.0, 1.0, 1.0) * 0.3;\n    vec3 col3 = vec3(0.0,0.0,1.0) * pow(0.5 - 0.5 * dot(transform(normalize(vec3(0.2,0.2,-1.0))),norm), 100.5);\n    \n    float edge = pow(1.0 / abs(dot(transform2(camdir), norm)),0.3);\n    \n\n    // Output to screen\n    fragColor = vec4(clamp((col1+col2+col3+amb)/4.0*edge, 0.0, 1.0),1.0);\n}","name":"Image","description":"","type":"image"}]}