{"ver":"0.1","info":{"id":"st2yRy","date":"1650653389","viewed":106,"name":"Phase portrait","username":"akoylasar","description":"Phase portrait visualizer","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["vectorfield","phaseportrait","systemofdifferentialequations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022-2022 Fouad Valadbeigi (akoylasar@gmail.com).\n\n#define RES 23.\n#define dt .0001\n\n/*\nmat2 getSysOfODEs() {\n    // Representing system of ODEs: \n    // x1d = 2.0 * x1 + x2;\n    // x2d = x1 + 2.0 * x2;\n    const mat2 A = mat2(-1., 2., // column (not row!)\n                        3., 4.);\n    return A;\n}\n*/\n\nmat2 getSysOfODEs() {\n    float t = .75 + .25 * sin(iTime * .9);\n    vec2 c0 = mix(vec2(-1., 2.), vec2(2., 1.), t);\n    vec2 c1 = mix(vec2(3., 4.), vec2(1., 2), t);\n    return mat2(c0, c1);\n}\n\n                              \nvec2 solve(vec2 p) {\n    vec2 xdot = getSysOfODEs() * p;\n    return dt * xdot + p;\n}\n\n\nbool eigenVectors(out vec4 v) {\n    mat2 A = getSysOfODEs();\n    float a = A[0][0];\n    float b = A[1][0];\n    float c = A[0][1];\n    float d = A[1][1];\n    \n    float delta = sqrt(pow(a + d, 2.) - 4. * (a * d - b * c));\n    if (delta < 0.) return false;\n    float lambda0 = (a + d + delta) / 2.;\n    float lambda1 = (a + d - delta) / 2.;\n    \n    float a0 = a - lambda0;\n    float a1 = a - lambda1;\n    \n    v.xy = normalize(vec2(1., -a0 / b));\n    v.zw = normalize(vec2(1., -a1 / b));\n    \n    return true; \n}\n\n\nvec3 drawVector(vec2 p, vec2 v) {\n    vec3 q = vec3(p, 0.); vec3 m = vec3(v, 0.);\n    float d1 = length(cross(q, m));\n    float R0 = iResolution.y * .01 / RES;\n    return mix(vec3(0., 0., .5), vec3(0.), smoothstep(.01 * R0, .02 * R0, d1));\n}\n\n\nvec2 field(vec2 p) {\n    return normalize(solve(p) - p);\n}\n\n\nvec3 drawArrow(vec2 p, vec2 c, vec2 v) {\n    float R0 = 1. / RES;\n\n    // base (red point)\n    float d0 = distance(p, c);\n    vec4 base = mix(vec4(1., 0., 0., 1.), vec4(0.), smoothstep(.12 * R0, .219 * R0, d0));\n    \n    // body\n    vec3 q = vec3(p - c, 0.); vec3 m = vec3(v, 0.);\n    float d1 = length(cross(q, m));\n    float cosTheta = dot(normalize(q), m);\n    \n    float angleCutoff = step(0., cosTheta);\n    float radCutoff = 1. - smoothstep(.8 * R0, .9 * R0, length(q));\n    vec3 body = mix(vec3(.5), vec3(0.), smoothstep(.1 * R0, .2 * R0, d1)) * angleCutoff * radCutoff;\n\n    return mix(base.rgb, body, 1. - base.a);\n}\n\n\nvec3 drawPhasePortrait(vec2 p, vec2 c) {\n    vec2 v = normalize(field(c));\n    vec3 col = drawArrow(p, c, v);\n    \n    vec4 ev;\n    if (eigenVectors(ev)) {\n        col += drawVector(p, ev.xy);\n        col += drawVector(p, ev.zw);\n    }\n    \n    vec2 pv = abs(normalize(field(p)));\n    col += .2 * vec3(pv.x, 0., pv.y);\n    return col;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ar = iResolution.y / iResolution.x; \n    vec2 g = fragCoord / iResolution.xy * vec2(1., ar);\n    mat3 m = mat3(2.,  0.,   0.,\n                  0.,  2.,   0.,\n                  -1., -ar,  1.);\n                  \n    vec3 p = m * vec3(g, 1.);\n    vec3 c = m * vec3(floor(g * RES) / RES + .5 / RES, 1.);\n    \n    \n    fragColor = vec4(drawPhasePortrait(p.xy, c.xy), 1.);\n}","name":"Image","description":"","type":"image"}]}