{"ver":"0.1","info":{"id":"Mdjyzt","date":"1493405153","viewed":123,"name":"Sketch 001","username":"Rackdoll","description":"My first raymarch sketch. Lovin' it.\nLearning thru concepts from other shaders here on shadertoy,\nand my engine work @ home.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tMy First RM Expertiment\n\tLearning as i go thru shadertoy &\n    using concepts from my own engine.\n\tRackdoll@2019\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\n\n//Primitives, thnx mercury!\nfloat SDFSphere( vec3 p, float s )\n{\n\treturn length(p) - s;    \n}\n\nfloat SDFTorus( vec3 p, vec2 s )\n{\n    vec2 q = vec2(length(p.xz)-s.x,p.y);\n    return length(q)-s.y;\n}\n\nfloat SDFBox( vec3 p, float s )\n{\n    return length( max( abs(p) - s, 0.0 ) ); \n}\n\n\n//ROTATIONS\nvec3 rotateX( vec3 p, float a )\n{\n \treturn mat3( 1.0, 0.0, 0.0,\n                     0.0, cos(a), -sin(a),\n                     0.0, sin(a), cos(a) ) * p;\n}\nvec3 rotateY( vec3 p, float a )\n{\n \treturn mat3( cos(a), 0.0, sin(a),\n                    0.0, 1.0,    0.0,\n                -sin(a), 0.0,  cos(a) ) * p;\n}\nvec3 rotateZ( vec3 p, float a )\n{\n \treturn mat3( cos(a), -sin(a), 0.0,\n                 sin(a), cos(a),  0.0,\n                        0.0, 0.0, 1.0 ) * p;\n}\n\n\n\n\n\nvec2 map( vec3 p )\n{\n\n    float id = 0.0;\n    \n\n    vec3 p_rot = rotateX( p, iTime / 3.0 );\n    p_rot      = rotateZ( p_rot, iTime/ 3.0  );\n    \n    float torus  = SDFTorus( p_rot, vec2( 0.20, 0.05 ) );\n    float sphere = SDFSphere( p, 0.4 ); \n    \n    \n    p_rot = rotateX( p, -iTime / 10.0 );\n    p_rot = rotateZ( p_rot, -iTime/ 10.0 );\n    float box    = SDFBox( p_rot, 0.3 );\n\n    //create scene\n    float scene = max( -sphere, box );\n    scene       = min( scene, torus );\n \n    //get id\n    if(scene == box || scene > box) id = 1.0;\n    if(scene == torus) id = 2.0;\n    \n    \n\treturn vec2(scene, id);    \n}\n\n//normals.\nvec3 normal( vec3 p )\n{\n\tvec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);\n}\n\nvec2 RM( vec3 RO, vec3 RD )\n{\n    float depth = 0.0;\n \tfor( int i= 0; i < MAX_MARCHING_STEPS; ++i )\n    {\n    \tvec3 ray    = RO + ( depth * RD);\n        vec2 scene = map( ray ); \n        \n        \n        if( scene.x < EPSILON )\n        {\n            \n         \treturn vec2( depth, scene.y);   \n        }\n            \n        \n        depth += scene.x;\n        if( depth >= MAX_DIST )\n        {\n        \treturn vec2(MAX_DIST,0);    \n        }\n        \n    }\n    return vec2(MAX_DIST,0);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec2 r2d( vec2 p, float a )\n{\n    return p * cos( a ) + sin( a ) * vec2( p.y, -p.x );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2( fragCoord.x / iResolution.x, fragCoord.y / iResolution.y );\n    vec2 middle = vec2( 1.0, 0.5 );\n    \n\t\n    //ray direction / origin\n    vec3 RD = rayDirection(45.0,iResolution.xy,fragCoord );\n    vec3 RO = vec3( 0, 0, 3.0 );\n\n    vec2 value = RM( RO, RD );\n    \n    //nothing hit.\n    if( value.x > MAX_DIST - EPSILON )\n    {\n        \n        vec2 uv2 = uv;\n        uv2.y -= 0.5;\n        \n        uv2 *= vec2( iResolution.x / iResolution.y, 1 );\n        uv2.s +=  iTime * 0.15;\n        uv2.t +=  -0.05 + sin(iTime * 3.0 + uv.x *5.0) * 0.1;\n        \n        \n        \n        float cellSize = 0.15;\n        vec2 c = floor( uv2 / cellSize );\n        vec2 p = mod(  uv2 / cellSize, vec2(1.));\n        p -= vec2(0.5 );\n        \n        \n        \n        if( c.y > 0.5 || c.y < -2.5) \n        {\t\n         \tfragColor = vec4(0, 0, 0 , 1.0 ); \n        \treturn;   \n        }\n\n        float a = min( max( (cos( iTime ) * c.y  * 2.0) * (sin( iTime *c.x) ), -3.12), 3.12 );\n        a = cos( iTime + c.x ) * 3.12 * sin( iTime + c.y ) * 2.0;\n       \n        if( c.y < -1.0  && c.y > -5.0) a = -0.05 + sin(iTime * 3.0 + uv.x *5.0) *2.0;\n        if( c.y > -0.5  && c.y < 5.0) a = -0.05 + sin(-iTime * 3.0 + uv.x *5.0) *2.0;\n        p = r2d( p, a);\n        \n        float l  = length( p );\n        float l2 = length( middle - (uv*vec2( iResolution.x / iResolution.y, 1 )));\n        float l3 = length( middle - p ) ;\n        \n        \n        vec3 col = ( p.x < 0.0) ? vec3( l2, l3-l, l ): vec3(l, l2, l3-l);\n        col *= l2 * l2;\n        if(  l > 0.5 ) col = vec3(0);\n\n\n    \tfragColor = vec4(col * (1.0-length(p)) , 1.0 ); \n        return;\n    }\n    \n    //something hit.\n   \n    // -> lighting\n    vec3 ray   = RO + ( RD * value.x );\n\tvec3 light = RO + vec3(0.0, 1.0, -1.0 );\n    vec3 N     = ray;\n    vec3 L     = normal( vec3( light - ray ) );\n\n    //diffuse\n    float diffuseWeight = max( dot( vec4(N, 1.0), vec4(L, 1.0) ), 0.0 );\n\n    //specular\n    vec3 viewEye = normal( -ray );\n    vec3 halfVec = normal( viewEye + L );\n    float specularWeight = pow( max ( dot( reflect( -L, normal(N)), -RD ), 0.0 ), 5.0 );\n    \n    //attenuation\n    float len = length( light - ray );\n    float lightRadius = 2.0;\n    float lightCutOff = 0.5;\n    float d = max( len - lightRadius, 0.0 );\n    float denom  = d/lightRadius + 1.0;\n    float attenuationWeight = 1.0 / (denom*denom);\n    attenuationWeight       = ( attenuationWeight -lightCutOff) / (1.0-lightCutOff);\n    attenuationWeight       = max( attenuationWeight, 0.0);\n    \n    \n    \n    vec3 ambient  = vec3( 0.0, 0, 0 );\n\tvec3 diffuse  = vec3( 1.0, 0.0, 0.0 ) * diffuseWeight * attenuationWeight;\n    vec3 specular = vec3( 1.0, 1.0, 1.0 ) * specularWeight * attenuationWeight; \n\n    vec3 c     = vec3(0);\n    if( value.y == 1.0 ) c = vec3(0.0, 0.0, 0.5 );\n    if( value.y == 2.0 ) c = vec3(0.0, 0.0, 1.0 );\n    vec3 color = (c + diffuse + specular) * attenuationWeight;\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}