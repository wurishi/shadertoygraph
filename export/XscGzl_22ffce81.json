{"ver":"0.1","info":{"id":"XscGzl","date":"1451525890","viewed":905,"name":"Dynamic, improved Perlin noise","username":"mw","description":"3D Perlin noise","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","perlin","implementation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**\n * Linearly Re-maps a value from one range to another\n */\nfloat map(float value, float old_lo, float old_hi, float new_lo, float new_hi)\n{\n\tfloat old_range = old_hi - old_lo;\n    if (old_range == 0.0) {\n\t    return new_lo; \n\t} else {\n\t    float new_range = new_hi - new_lo;  \n\t    return (((value - old_lo) * new_range) / old_range) + new_lo;\n\t}\n}\n\n/**\n * The canonical GLSL hash function\n */\nfloat hash(float x)\n{\n\treturn fract(sin(x) * 43758.5453123);\n}\n\n/** \n * Nothing is mathematically sound about anything below: \n * I just chose values based on experimentation and some \n * intuitions I have about what makes a good hash function\n */\nvec3 gradient(vec3 cell)\n{\n\tfloat h_i = hash(cell.x);\n\tfloat h_j = hash(cell.y + pow(h_i, 3.0));\n\tfloat h_k = hash(cell.z + pow(h_j, 5.0));\n    float ii = map(fract(h_i + h_j + h_k), 0.0, 1.0, -1.0, 1.0);\n    float jj = map(fract(h_j + h_k), 0.0, 1.0, -1.0, 1.0);\n\tfloat kk = map(h_k, 0.0, 1.0, -1.0, 1.0);\n    return normalize(vec3(ii, jj, kk));\n}\n\n/**\n * Perlin's \"ease-curve\" fade function\n */\nfloat fade(float t)\n{\n   \tfloat t3 = t * t * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    return (6.0 * t5) - (15.0 * t4) + (10.0 * t3);        \n}    \n\n/**\n * The meat of it:\n *\n * It helps to visualize the unit cube:\n *\n *      (0,1,1)----------------(1,1,1)\n *        /|                     /|\n *       / |                    / |\n *      /  |                   /  |\n *     /   |                  /   |\n * (0,1,0)-+--------------(1,1,0) |\n *    |    |                 |    |\n *    |    |                 |    |\n *    |    |                 |    |\n *    | (0,0,1)--------------+-(1,0,1)\n *    |   /                  |   /\n *    |  /                   |  /\n *    | /                    | /\n *    |/                     |/ \n * (0,0,0)----------------(1,0,0)\n */\nfloat noise(in vec3 coord)\n{\n    vec3 cell = floor(coord);\n    vec3 unit = fract(coord);\n   \n    vec3 unit_000 = unit;\n    vec3 unit_100 = unit - vec3(1.0, 0.0, 0.0);\n    vec3 unit_001 = unit - vec3(0.0, 0.0, 1.0);\n    vec3 unit_101 = unit - vec3(1.0, 0.0, 1.0);\n    vec3 unit_010 = unit - vec3(0.0, 1.0, 0.0);\n    vec3 unit_110 = unit - vec3(1.0, 1.0, 0.0);\n    vec3 unit_011 = unit - vec3(0.0, 1.0, 1.0);\n    vec3 unit_111 = unit - 1.0;\n\n    vec3 c_000 = cell;\n    vec3 c_100 = cell + vec3(1.0, 0.0, 0.0);\n    vec3 c_001 = cell + vec3(0.0, 0.0, 1.0);\n    vec3 c_101 = cell + vec3(1.0, 0.0, 1.0);\n    vec3 c_010 = cell + vec3(0.0, 1.0, 0.0);\n    vec3 c_110 = cell + vec3(1.0, 1.0, 0.0);\n    vec3 c_011 = cell + vec3(0.0, 1.0, 1.0);\n    vec3 c_111 = cell + 1.0;\n\n    float wx = fade(unit.x);\n    float wy = fade(unit.y);\n    float wz = fade(unit.z);\n \n    float x000 = dot(gradient(c_000), unit_000);\n\tfloat x100 = dot(gradient(c_100), unit_100);\n\tfloat x001 = dot(gradient(c_001), unit_001);\n\tfloat x101 = dot(gradient(c_101), unit_101);\n\tfloat x010 = dot(gradient(c_010), unit_010);\n\tfloat x110 = dot(gradient(c_110), unit_110);\n\tfloat x011 = dot(gradient(c_011), unit_011);\n\tfloat x111 = dot(gradient(c_111), unit_111);\n   \n    // (0,0,0) - (1,0,0)\n    // (0,0,1) - (1,0,1)\n    // (0,1,0) - (1,1,0)\n    // (0,1,1) - (1,1,1)\n    float y0 = mix(x000, x100, wx);\n    float y1 = mix(x001, x101, wx);\n    float y2 = mix(x010, x110, wx);\n    float y3 = mix(x011, x111, wx);\n    \n\tfloat z0 = mix(y0, y2, wy);\n    float z1 = mix(y1, y3, wy);\n    \n    return mix(z0, z1, wz);\n}\t\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float freq = 1.0 / 64.0;\n    if (iMouse.y != 0.0) {\n    \tfreq = 1.0 / iMouse.y;\n    }\n\n    float blendAmount = 0.0;\n  \tif (iMouse.x != 0.0) {\n    \tblendAmount = iMouse.x / iResolution.x;\n    } \n    \n    vec3 coord = vec3(fragCoord.xy, float(iFrame) * 0.75);\n    float v = noise(coord * freq);\n    \n    float v_0 = map(v, -1.0, 1.0, 0.0, 1.0);\n    float v_1 = 1.0 - abs(v);\n    float v_p = mix(v_0, v_1, blendAmount);\n\n\tfragColor = vec4(v_p, v_p, v_p, 1.0);\n}","name":"Image","description":"","type":"image"}]}