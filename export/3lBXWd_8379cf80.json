{"ver":"0.1","info":{"id":"3lBXWd","date":"1567453157","viewed":243,"name":"Liquid metal tori","username":"kubamaruszczyk1604","description":"ray marching, reflections, hard shadows","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","shadows","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float FOV_DEG = 80.0;\nconst int MAX_STEPS = 200;\nconst vec3 LIGHT_POS =  vec3(-25.0,19.5,-20.0);\n\n// Consts & Enums\nconst float EPS = 0.001;\nconst float DEG_TO_RAD = 0.0174533;\nconst float M_PI = 3.141592653;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int NO_HIT = 0;\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n// polynomial smooth min\n// From https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 ApplyFog(in vec3 rgb, // original color of the pixel\n               in float distance) // camera to point distance\n{\n    float fogAmount = 1.0 - exp(-distance * 0.05);\n    vec3 fogColor =  vec3(0.03, 0.00, 0.02)*1.5;\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// SDFs\nfloat SphereSDF(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\n\nfloat TorusSDF(vec3 p, float R, float r)\n{\n    \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r;\n    \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{\n    \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float py = p.y*2.0;\n    float c = cos(amount*py);\n    float s = sin(amount*py);\n    \n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\n\nvec3 CheckerBoard2(vec2 uv, vec3 col1, vec3 col2, float granularity)\n{\n   granularity *=0.5;\n   float uplusv = (floor(uv.x*granularity)+ floor(uv.y*granularity));\n   return mix(col1, col2, mod(uplusv, 2.0));\n   \n}\n//o.x = diffuse coefficient; o.y = specular coefficient\nvec2 PhongModel(vec3 L, vec3 V, vec3 N)\n{\n    vec2 o = vec2(0);\n    L = normalize(L);\n    N = normalize(N);\n    o.x = max(0.0,dot(N,L));\n    \n    vec3 R = L- 2.0 * dot(L, N) * N;\n    R = normalize(R);\n    o.y = pow(dot(R,-V),100.0);  \n    o.y = max(0.01,o.y);\n   return o;\n}\n\n\n//o.x = diffuse coefficient; o.y = specular coefficient\nvec2 BlinnPhongModel(vec3 L, vec3 V, vec3 N)\n{\n    vec2 o = vec2(0);\n    L = normalize(L);\n    N = normalize(N);\n    o.x = max(0.0,dot(N,L));\n    \n    vec3 H = L+V /length(L+V);\n    H = normalize(H);\n    o.y  =  max(pow(dot(H,N),100.0),0.01);  \n   return o;\n}\n\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(0.4,0.2,0.4);;\n        pn =  Twist(pn+vec3(0,-0.2,-0.3),sin(iTime*0.2)*0.6);//CreateRotationY(iTime)* vec4(p,0);  \n  \n      float sd = BoxSDF(pn.xyz,vec3(0.75)); \n      float  torus = TorusSDF(CreateRotationY(iTime*-0.9)*(p + vec3(8.0*sin(iTime*0.35),-1.5,0.0)) ,2.09,0.45);\n      float  torus2 = TorusSDF(CreateRotationY(iTime*0.4)*(p + vec3(-8.0*sin(iTime*0.35),-1.5,0.0)) ,2.09,0.45);\n      float  torus3 = TorusSDF(CreateRotationY(iTime*-1.4)*(p + vec3(0.0,-10.0*abs(sin(iTime*0.35)),0.0)) ,2.09,0.45);\n      float  torus4 = TorusSDF(CreateRotationY(iTime*0.4)*(p + vec3(0.0,-6.0*abs(sin(iTime*0.2)),-8.0*sin(iTime*0.35))) ,2.09,0.45);\n      float  torus5 = TorusSDF(CreateRotationY(iTime*-0.4)*(p + vec3(0.0,-6.0*abs(sin(iTime)),8.0*sin(iTime*0.35))) ,2.09,0.45);\n      float  torus6 = TorusSDF(CreateRotationY(iTime*0.4)*(p + CreateRotationY(iTime*0.4)*vec3(8.0*sin(iTime*0.35),-1.5,3.0)) ,2.09,0.45);\n    \n      sd = smin(torus,sd,3.0);//*abs(sin(iTime)));  \n      sd = smin(torus2,sd,3.0);\n      sd = smin(torus3,sd,3.0);\n      sd = smin(torus4,sd,3.0);\n      sd = smin(torus5,sd,3.0);\n      sd = smin(torus6,sd,3.0);\n      //sd = min(torus,sd); \n      float pd =  PlaneSDF(p,5.2); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;    \n       int closest = 0; \n        \n       float sd = CombineSDF(p, closest);\n        \n        \n      if(sd < EPS)\n      {\n          hit = closest;\n          return t;\n      }\n      t += sd;\n      \n    }\n    return 0.0;\n}\n\nint InShadow(vec3 p, vec3 L, out float t)\n{\n    int shadowHit = NO_HIT;\n    Ray sr;\n    sr.Direction = L;\n    sr.Orgin =p + vec3(0.05);     \n    t =  Trace(sr,shadowHit);\n    return shadowHit;\n}\n\nvec3 GetPlaneColor(vec3 hitAt, vec3 L, vec3 N, vec3 V)\n{\n  \n    vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;  \n    vec3 col = CheckerBoard2(planeUV, vec3(0.1), vec3(0.5),30.0);\n    col =  0.6*col + 0.4*texture(iChannel1,V).xyz;\n    //Shadows\n    float shadowT = 0.0;\n    int shadowHit = InShadow(hitAt, L,shadowT);\n    if(shadowHit > 0)\n    {\n       col *= 0.3;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Move coords to -1..1 space    \n    uv = uv * 2.0 - 1.0;\n    \n    // aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0);\n    \n    uv *=fovDist;\n\n    Ray r;\n    r.Direction = CreateRotationX(-0.4) * normalize(vec3(uv,1.0));\n    r.Direction *= CreateRotationY(-iTime*0.1);\n    r.Orgin = CreateRotationY(iTime*0.1)*vec3(-0.0,7.0,-12.0);\n\n    vec3 col = vec3(0);  \n    int hit = NO_HIT;  \n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction *t; \n    vec3 lDir = LIGHT_POS-hitAt; \n    lDir = normalize(lDir);\n    \n    if(hit == OBJECT) \n    {\n        vec3 N = GetNormal(hitAt);\n        float s = (1.0+sin(hitAt.y))/2.0;\n        vec2 dCoeff = PhongModel(lDir, r.Direction, N);\n        col =  vec3(1.0,0.0,s)*dCoeff.x + vec3(1.0)*dCoeff.y;\n        \n        // Shadows\n        float shadowT = 0.0;\n        int shadowHit = InShadow(hitAt+ vec3(0.2)*lDir, lDir,shadowT);\n        if(shadowHit > 0)\n        {\n           col *= 0.1; \n        }\n        \n        //Reflections\n        Ray reflR;\n        int reflHit =0;\n        reflR.Direction = reflect(r.Direction,N);\n        reflR.Orgin = hitAt + reflR.Direction* 0.1;\n        float rt = Trace(reflR,reflHit);\n        vec3 reflHitAt = reflR.Orgin + reflR.Direction*rt;\n        if(reflHit == FLOOR_PLANE)\n        {\n           vec3 N = GetNormal(reflHitAt);\n           col =  GetPlaneColor(reflHitAt, lDir, N, reflR.Direction);\n        }\n        else //if(reflHit ==0)\n        {\n          \n           col = 0.2*col + 0.8*texture(iChannel0, normalize(reflR.Direction)).xyz;\n        }\n\n    }\n\n    else if(hit == FLOOR_PLANE) \n    {\n        vec3 N = GetNormal(hitAt);   \n        col = GetPlaneColor(hitAt, lDir, N, r.Direction);\n    }\n    \n    else // NO HIT\n    {\n        col = texture(iChannel0, normalize(r.Direction)).xyz;\n        col = ApplyFog(col,70.0);\n\n    }\n    \n    col = ApplyFog(col,length(r.Orgin - hitAt));\n    \n    // Apply gamma correction\n    fragColor = vec4(pow(col,vec3(1.0/1.6)),1.0);\n    //Vignettes\n    fragColor*= 1.1 - pow(length(uv)*0.6,2.9);\n}","name":"Image","description":"","type":"image"}]}