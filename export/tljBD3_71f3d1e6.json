{"ver":"0.1","info":{"id":"tljBD3","date":"1600050057","viewed":111,"name":"raytracing-by Jordan","username":"jorge2017a1","description":"//Made by Jordan Duty(AKA djdduty) May 14, 2014.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracingbyjordan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Made by Jordan Duty(AKA djdduty) May 14, 2014.\n\n#define M_PI 3.141592653589793238462643383279\n\nstruct Ray\n{\n\tvec3 Dir;\n\tvec3 Pos;\n};\n\t\nstruct Sphere\n{\n\tvec3 Pos;\n\tvec3 Color;\n\tfloat Rad;\n\tfloat Reflection;\n};\n\nconst int numSpheres = 7;\nSphere spheres[numSpheres];\n\nvec3 LightPos = vec3(0,-3,10);\n\t\nvec3 Intersects(Sphere s, Ray r)\n{\n\tfloat t0, t1;\n\tvec3 l = s.Pos - r.Pos;\n\tfloat tca = dot(l, r.Dir);\n\tif(tca < 0.0) return vec3(0,0,-1.0);\n\tfloat d2 = dot(l, l) - tca*tca;\n\tif(d2 > s.Rad*s.Rad) return vec3(0,0,-1.0);\n\tfloat thc = sqrt((s.Rad*s.Rad) - d2);\n\treturn vec3(tca-thc, tca+thc, 1);\n}\n\t\nfloat mix2(float a, float b, float c)\n{\n\treturn b*c+a*(1.0-c);\t\n}\n\nvec3 Trace3(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\treturn Color;\n}\n\nvec3 Trace2(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tbool inside = false;\n\tif(dot(r.Dir, nhit) > 0.0) nhit *= -1.0, inside = true;\n\t\n\tif(s.Reflection > 0.0)\n\t{\n\t\tfloat facingratio = dot((r.Dir*-1.0), nhit);\n\t\tvec3 refldir = r.Dir - nhit * 2.0 * dot(r.Dir, nhit);\n\t\trefldir = normalize(refldir);\n\t\tRay rd;\n\t\trd.Pos = phit;\n\t\trd.Dir = refldir;\n\t\tvec3 refl = Trace3(rd);\n\t\tfloat param1 = (1.0-s.Reflection);\n\t\tfloat param2 = s.Reflection;\n\t\tColor.x = (param1 * Color.x + param2 * refl.x);\n\t\tColor.y = (param1 * Color.y + param2 * refl.y);\n\t\tColor.z = (param1 * Color.z + param2 * refl.z);\n\t}\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\t\n\treturn Color;\n}\n\nvec3 Trace(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n    \n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n    \n    \n\tif(col==false) return vec3(0,0,0);\n    \n    \n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n    \n\tbool inside = false;\n\tif(dot(r.Dir, nhit) > 0.0) nhit *= -1.0, inside = true;\n\t\n\tif(s.Reflection > 0.0)\n\t{\n\t\tfloat facingratio = dot((r.Dir*-1.0), nhit);\n\t\tvec3 refldir = r.Dir - nhit * 2.0 * dot(r.Dir, nhit);\n\t\trefldir = normalize(refldir);\n\t\tRay rd;\n\t\trd.Pos = phit;\n\t\trd.Dir = refldir;\n\t\tvec3 refl = Trace2(rd);\n\t\tfloat param1 = (1.0-s.Reflection);\n\t\tfloat param2 = s.Reflection;\n\t\tColor.x = (param1 * Color.x + param2 * refl.x);\n\t\tColor.y = (param1 * Color.y + param2 * refl.y);\n\t\tColor.z = (param1 * Color.z + param2 * refl.z);\n\t}\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\t\n\treturn Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tspheres[0].Pos = vec3(5,0,-0);\n\tspheres[0].Color = vec3(0.9,0.1,0.1);\n\tspheres[0].Rad = 4.0;\n\tspheres[0].Reflection = 0.4;\n\t\n\tspheres[1].Pos = vec3(-5,0,-0);\n\tspheres[1].Color = vec3(0.3,0.3,0.3);\n\tspheres[1].Rad = 4.0;\n\tspheres[1].Reflection = 0.3;\n\t\n\tspheres[2].Pos = vec3(-5,1004,-0);\n\tspheres[2].Color = vec3(0.1,0.1,0.1);\n\tspheres[2].Rad = 1000.0;\n\t//spheres[2].Reflection = 0.15;\n    spheres[2].Reflection = 0.28;\n\t\n\tspheres[3].Pos = vec3(-5,0,-1040);\n\tspheres[3].Color = vec3(0.5,0.5,0.5);\n\tspheres[3].Rad = 1000.0;\n\tspheres[3].Reflection = 0.05;\n\t\n\tspheres[4].Pos = vec3(1020,0,-0);\n\tspheres[4].Color = vec3(0.9,0.9,0.0);\n\tspheres[4].Rad = 1000.0;\n\tspheres[4].Reflection = 0.05;\n\t\n\tspheres[5].Pos = vec3(-1020,0,-0);\n\tspheres[5].Color = vec3(0.2,0.2,0.7);\n\tspheres[5].Rad = 1000.0;\n\tspheres[5].Reflection = 0.05;\n\t\n\tspheres[6].Pos = vec3(-5,0,1040);\n\tspheres[6].Color = vec3(0.0,0.8,0.4);\n\tspheres[6].Rad = 1000.0;\n\tspheres[6].Reflection = 0.05;\n\t\n\tfloat invWidth = 1.0 / iResolution.x;\n\tfloat invHeight = 1.0 / iResolution.y;\n\tfloat fov = 60.0; \n\tfloat aspectratio = iResolution.x/iResolution.y;\n\tfloat angle = tan(M_PI * 0.5 * fov / 180.0);\n\t\n\tvec3 sinTime = vec3(sin(iTime*2.0));\n\t\n\tvec3 camTrans = vec3(20.0*cos(0.5*iTime), 0, 20.0*sin(0.5*iTime));\n\tvec3 camDir = camTrans - vec3(0);\n\t\n\tcamTrans.y = -5.0;\n\tLightPos.y = -10.0;//camTrans;\n\t\n\tmat3 rot;\n\tvec3 f = normalize(camTrans);\n\tvec3 u = vec3(0,1,0);\n\tvec3 s = normalize(cross(f,u));\n\tu = cross(s,f);\n\trot[0][0] = s.x; rot[1][0] = s.y; rot[2][0] = s.z;\n\trot[0][1] = u.x; rot[1][1] = u.y; rot[2][1] = u.z;\n\trot[0][2] = f.x; rot[1][2] = f.y; rot[2][2] = f.z;\n\t\n\tRay R;\n\tfloat xx = (2.0 *((fragCoord.x+0.5) * invWidth) -1.0)*angle*aspectratio;\n\tfloat yy = (1.0-2.0*((fragCoord.y+0.5)*invHeight))*angle;\t\n\tR.Pos = camTrans;\n\tR.Dir = vec3(xx,yy,-1) * rot;\n\tR.Dir = normalize(R.Dir);\n\t\n    \n    vec3 col=Trace(R);\n    col=pow(col, vec3(0.45454));\n\tfragColor = vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}