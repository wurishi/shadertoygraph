{"ver":"0.1","info":{"id":"mlXXRn","date":"1674170746","viewed":66,"name":"waffle cube maze","username":"kastorp","description":"fork of https://www.shadertoy.com/view/dlj3Dd","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","short"],"hasliked":0,"parentid":"dlj3Dd","parentname":"waffle sphere maze 1b"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fork of https://www.shadertoy.com/view/dlj3Dd\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))               // rotation \n#define H(p)    fract(1e4*sin(dot(p,R.xy-17.)))\n#define CUBE\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,m, h,h1,h2,h3,r,w,\n            k=.7/32.; //k=.7/(32. +16.*sin(iTime*4.)); //wall thickness\n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n     \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        r = length(q),\n        a = abs(q), \n        m = max(a.x, max(a.y,a.z)), \n        q= m==a.x ? q.yzx : m==a.y ? q.xzy : q.xyz,        \n#ifdef CUBE\n        U=q.xy, r=m,\n#else \n        U = vec2(atan(q.x,q.z),atan(q.y,q.z))*q.z*4./3.1416,// cube-sphere mapping\n#endif\n        U *= 8./m, \n            h = H(floor(U)),\n            //h1 = H(vec2(floor(U.x),floor(U.y))),h2 = H(vec2(floor(U.x),floor(U.y))), h3 = H(floor(U)),\n            q.xy = ( fract(U) - .5 ) *k*2.,                \n            // wall = random tile diagonal (check 4 taps)\n            w=min(min(abs((q.x-k)+sign(h-.5)*(q.y-k)),abs((q.x-k)+sign(h-.5)*(q.y+k))),\n                   min(abs((q.x+k)+sign(h-.5)*(q.y-k)), abs((q.x+k)+sign(h-.5)*(q.y+k)))),\n        t = min ( r-1.3, max( r-1.5 , w) ),                   \n        p += .5*t*D;  // step forward = dist to obj    \n   \n   O *= O*O*1.5;                                           // color scheme\n    O*= .9+.1*cos(vec4(2,0,4,0)+ w*500.);  \n  // O *= .5+.5*vec4(m==a.x, m==a.y, m==a.z, 0)* (.4+.6*mod(ceil(U.x)+ceil(U.y),2.));  // debug\n}\n\n","name":"Image","description":"","type":"image"}]}