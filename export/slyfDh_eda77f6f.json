{"ver":"0.1","info":{"id":"slyfDh","date":"1665117686","viewed":64,"name":"swoopy truchet (multiscale v1)","username":"zammers","description":"I attempted to replicate this: https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\nUnfortunately forgot about the \"winged\" sections until mostly done, so I've now got a very nice single scale pattern and a very strange multiscale.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["experiment","truchet","tiling","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment to turn on multiscale mode, comment to turn on single scale mode\n//#define MULTISCALE\n\n// There's still some discontinuity between the nubs and what they attach to, because for some reason the\n// nubs are either just barely differently sized or have a different range of values and get fuzzier faster\n\n// vec2 -> bool\nbool N2B(vec2 id) {\n    id = fract(id*vec2(129.36, 984.57));\n    id += dot(id, id+58.02);\n    return fract(id.x * id.y) > .5;\n}\n\n// vec2 -> bvec4\nbvec4 N2B4(vec2 id) {\n    return bvec4(N2B(id), N2B(id+238.5439), N2B(id+129.438), N2B(id+393.4389));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    uv += iTime * .5; // move across screen\n    \n    vec2 gv0 = 2.*fract(uv*5.)-1.; // single scale\n    vec2 id0 = 2.*floor(uv*5.)-1.;\n    \n    vec2 gv4 = 2.*fract(uv*4.)-1.; // multiscale\n    vec2 id4 = 2.*floor(uv*4.)-1.;\n    vec2 gv2 = 2.*fract(uv*8.)-1.;\n    vec2 id2 = 2.*floor(uv*8.)-1.;\n    vec2 gv1 = 2.*fract(uv*16.)-1.;\n    vec2 id1 = 2.*floor(uv*16.)-1.;\n    \n    \n    // set correct local id and local coordinates\n    #ifdef MULTISCALE\n    vec2 id = N2B(id4) ? id4 : N2B(id2) ? id2 : id1;\n    vec2 gv = N2B(id4) ? gv4 : N2B(id2) ? gv2 : gv1;\n    #else\n    vec2 id = id0;\n    vec2 gv = gv0;\n    #endif\n    \n    \n    /* // Display different sizes of tiles in different colors\n    vec3 col = vec3(0);\n    if(N2B(id4))      col = vec3(1,gv4.x,gv4.y);\n    else if(N2B(id2)) col = vec3(gv2.x,1,gv2.y);\n    else              col = vec3(gv1.x,gv1.y,1);\n    */\n    \n    \n    float d = 1.;\n    float a = .01;\n    float w = 1./3.;\n    //                  s, t, p, q\n    //                  l, r, u, d\n    //bvec4 edges = bvec4(1, 0, 1, 0); // draw lines between edges\n    // special: two curves(0100), other two curves(0010), and crossroads(1000)\n    // 0001 is 1111 without the center\n    bvec4 edges = N2B4(id);\n\n\n    // circles\n    float ur = sign(gv.x + gv.y + a); // 1 if top right\n    float dr = sign(gv.x - gv.y - a); // 1 if down right\n    float r = sign(gv.x + a*a);       // 1 if right\n    float u = sign(gv.y + a*a);       // 1 if top\n    vec2 cc = vec2((ur + dr)*.5, (ur - dr)*.5); // side circle center\n    \n    // I hate lines 74-78 but I cannot think of a way to reorganize it so that it's still understandable\n    // one- and two-curve rules\n    float hside = (!edges.s && !edges.q && (edges.t != edges.p)) ? (edges.t ?  ur : dr) : (edges==bvec4(0,0,0,1) || edges.t && edges.s ? r : edges.t ? 1. : -1.); // horizontal side of diagonal (\\ if t, / if p)\n    float vside = (!edges.s && !edges.q && (edges.t != edges.p)) ? (edges.p ? -dr : ur) : (edges==bvec4(0,0,0,1) || edges.p && edges.q ? u : edges.p ? 1. : -1.); // vertical side of diagonal   (\\ if t, / if p)\n    \n    if(edges!=bvec4(0,0,0,0) && edges!=bvec4(1,0,0,0) && edges!=bvec4(1,1,0,0) && edges!=bvec4(0,0,1,1))\n    d = length(gv - vec2(hside, vside)) - 1.;\n    \n    // lines\n    bool horz = edges.s && edges.t || edges==bvec4(1,0,0,0); // horizontal line\n    bool vert = edges.p && edges.q || edges==bvec4(1,0,0,0); // vertical line\n    \n    if(vert && abs(gv.x) < w || horz && abs(gv.y) < w) d=0.; // if it's on the line, shade it\n    \n    \n    \n    // use shape or use side circle\n    d = min(d, length(gv - cc) + a);\n    d = abs(d) - w;\n    \n    \n    float m = smoothstep(-.01, .01, d);\n    #ifdef MULTISCALE\n    if(!N2B(id4) && N2B(id2)) m = 1. - m; // invert\n    #endif\n    vec3 col = vec3(m);\n    \n    \n    \n    //if(gv.x > .95 || gv.y > .95) col = vec3(1,0,0); // show gridlines\n    //vec3 col = vec3(length(gv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}