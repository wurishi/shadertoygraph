{"ver":"0.1","info":{"id":"DlGBWd","date":"1703003003","viewed":109,"name":"Analytic Segment Light Integral","username":"chronos","description":"Was inspired to solve this when studying analytical solutions of special cases of the rendering equation.\nUnless I'm mistaken, this computes the radiant flux of a non-self occluding line segment light source.\nMaybe useful? ¯\\_(ツ)_/¯","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["line","distance","function","analytic","segment","itegral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\n// \n// a, b : endpoints of line segment\n// p    : point where we evaluate\n//\n// returns: analytical integral of 1/r(t) dt from t = 0 to t = 1, where r(t) = (1.-t) * a + t * b = mix(a,b,t) or lerp(a,b,t);\n//          i.e the integral along the line segment ab of the distance function from p\n//\nfloat analytical_solve(vec2 a, vec2 b, vec2 p)\n{\n    // Indefinite integral used to solve is\n    //\n    //       integral 1/sqrt(x^2 + y^2) dx = atanh(x / sqrt(x^2 + y^2))\n    // \n    // (according to wolfram alpha)\n    //\n    // Some related integrals are:\n    //      integral 1/(1 + t^2) = atan(t)\n    // and\n    //      integral 1/sqrt(1 + t^2) = asinh(t)\n    // \n    // The 3D version of this function with square falloff instead of linear falloff should use the indefinite integral:\n    // \n    //      integral 1/(x^2 + y^2 + z^2) dx = atan(x, sqrt(y^2 + z^2)) / sqrt(y^2 + z^2)\n    //\n    // Looks like wolfram alpha even can compute the simplified diffuse rendering equation (with normal N) as:\n    // \n    //       integral dot(N, (x,y,z)) / dot((x,y,z), (x,y,z)) dx = \n    //       0.5 * N.x *log(x^2+y^2+z^2) + (N.y * y + N.z * z) * atan(x / sqrt(y^2 + z^2)) / sqrt(y^2 + z^2)\n    \n    \n    \n    \n    // Algo: \n    // 0. Center coordinate system at p:\n    \n    a = a-p;\n    b = b-p;\n    p *= 0.;\n    \n    vec2 ab = b-a;\n    float len_ab = length(ab);\n    \n    // 1. Detect co-linear edge case:\n    float abs_det = abs(a.x*b.y - a.y*b.x) / len_ab; // offset from line, i.e height of parallelogram\n    const float eps =  0.001;\n    if( abs_det < eps)\n    {\n        // Detect if p lies directly on line segment\n        float l = -dot(a, ab);\n        if(l >= 0. && l <= dot(ab,ab)) return 1./(eps);\n        \n        // Integral of 1/t dt, from t = length(a) to length(b) = log(length(b)) - log(length(a))\n        return abs(log(length(b)) - log(length(a))) / len_ab;\n    }\n    \n    // 2. Find y^2 as distance squared from p to projection, c, onto line segment ab:\n    vec2 c = (dot(p-a, ab) / dot(ab,ab)) * ab + a;\n    float y2 = dot(c,c);\n    \n    // 3. Find x1 and x2 as position of a and b along line from point c with direction d = (b-a)/length(b-a)\n    vec2 d = normalize(ab);\n    float x1 = dot(a-c, d);\n    float x2 = dot(b-c, d);\n    \n    // 4. Evaluate indefinite integral at endpoints:\n    float F_x1 = atanh(x1 / sqrt(x1*x1 + y2));\n    float F_x2 = atanh(x2 / sqrt(x2*x2 + y2));\n    \n    return (F_x2 - F_x1) / len_ab;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float pix_size = 2. / iResolution.y;\n\n    if(length(iMouse.xy) < 10.) mouse.xy = vec2(0);\n\n    vec3 color = vec3(0);\n\n    float radiant_power = 0.05;\n    \n    float c = cos(iTime), s = sin(iTime);\n    mat2 R = mat2(1.);//mat2(c, s, -s, c);\n    vec2 a = R * vec2(-.75, 0);\n    vec2 b = R * vec2( .75, 0);\n    \n    if(mouse.x > uv.x)\n    {\n        // Increase number of points by 10 each second, and reset when 100 points added\n        int N = 4 + ((10*(iFrame/60)) % 100);\n        for(int i = 0; i < N; i++)\n        {\n            float t = float(i) / float(N-1);\n            vec2 light_pos = mix(a, b, t);\n            vec2 offset = uv - light_pos;\n            float linear_falloff = length(offset);\n            float radiance = radiant_power / linear_falloff;\n            color += radiance / float(N);\n        }\n    }\n    else\n    {\n        color += radiant_power * analytical_solve(a,b, uv);\n    }\n\n    //color = vec3(0.5 + .5*sin(1./color.r * 10.));\n\n    // Draw black separator line\n    color *= .5 + .5*smoothstep( pix_size, 2.*pix_size, abs(mouse.x - uv.x));\n\n    // I want your eyes to have nice pixels :)\n    color = tanh(color);\n    color = sRGBencode(color);\n    color += -.5/255. + (1./255.) * texelFetch(iChannel0, (ivec2(fragCoord)+iFrame*ivec2(iResolution.xy))%ivec2(textureSize(iChannel0, 0)), 0).rgb;    \n    color = clamp(color, 0., 1.);\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}