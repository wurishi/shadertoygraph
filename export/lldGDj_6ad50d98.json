{"ver":"0.1","info":{"id":"lldGDj","date":"1472011007","viewed":1383,"name":"test multipass raytrace","username":"wachel","description":"thank for the demo https://www.shadertoy.com/view/4dtGWB\nand the tutorial https://www.shadertoy.com/view/XllGW4\nand tutorial https://www.shadertoy.com/view/Xl2XWt","likes":50,"published":1,"flags":32,"usePreview":1,"tags":["raytrace","pbr","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color = texture(iChannel0, uv).rgb;\n    \n\tfragColor = vec4(pow(clamp(color, 0., 1.), vec3(1./2.2)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//thank for the demo https://www.shadertoy.com/view/4dtGWB\n//and the tutorial https://www.shadertoy.com/view/XllGW4\n//and https://www.shadertoy.com/view/Xl2XWt\n\n#define PI 3.141592654\n#define MAX_BOUNCE 4\n#define MIN_DISTANCE 0.003\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Mat{\n    vec3 color;\n    float metallic;\n    float glossiness;\n};\nvoid makeMat(out Mat mat,vec3 color,float metallic,float glossiness){\n    mat.color = color;\n    mat.metallic = metallic;\n    mat.glossiness = glossiness;\n}\n\n//=================\n\nvec2 sdBox( vec3 p, vec3 size ,vec3 pos,int mat)\n{\n  vec3  di = abs(p - pos) - size;\n  float mc = max(di.x,max(di.y,di.z));\n  float d = min(mc,length(max(di,0.0)));\n  return vec2(d,mat);\n}\n\nvec2 sdSphere( vec3 p,vec3 pos, float r ,int mat) {\n    float d = length(p - pos) - r;\n    return vec2(d,mat);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ,vec3 pos,int mat)\n{\n    p = p - pos;\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 map( in vec3 p )\n{\n    vec2 d \t= sdBox(p,vec3(1.2,0.2,1.2),vec3(0,-0.21,0),0);\n    \n    for(int i = 0; i<5; i++){\n        d = opU(d,sdSphere(p,vec3(0.8,0.2,-1.0 + 0.5 * float(i)) ,0.2,1 + i));//mat=1~5\n    }\n\n    for(int i = 0; i<5; i++){\n        d = opU(d,sdSphere(p,vec3(-0.8,0.2,-1.0 + 0.5 * float(i)) ,0.2,6 + i));//mat=6~10\n    }\n    \n    d = opU(d,sdSphere(p,vec3(-0.1,0.30,-0.5) ,0.3,11)); \n    d = opU(d,sdSphere(p,vec3(-0.3,0.15,0.3),0.15 ,12)); \n    d = opU(d,sdSphere(p,vec3(0.2,0.205,0.0) ,0.2,13)); \n\n    float mat = d.y;\n    vec4 res = vec4( d.x, 1.0, 0.0, mat );\n    return res;\n}\n\n//=================\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i<100; i++ )\n    {\n\t\tif( h.x<MIN_DISTANCE || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nvec3 getBackground( vec3 rd ) {\n    //return mix( vec3(0.1,0.05,0.0), vec3(0.2, 0.3, 0.4), 0.5 + 0.5*dir.y );\n    return texture(iChannel1, rd).xyz; \n}\n\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nMat getMat(int index){\n    Mat mat;\n    if(index ==0)     \t{\n        makeMat(mat,vec3(0.90,0.10,0.00),0.0,0.5);\n    }\n    else if(index >= 1 && index <= 5)\t{\n        float glossiness = (float(index) - 1.0) / 4.0;\n        makeMat(mat,vec3(0.80,0.80,0.80),1.0,glossiness);\n    }\n    else if(index >= 6 && index <=10)\t{\n        float glossiness = (float(index) - 6.0) / 4.0;\n        makeMat(mat,vec3(0.80,0.80,0.80),0.0,glossiness);\n    }\n    else if(index == 11){\n        makeMat(mat,vec3(0.00,0.60,0.90),0.0,0.5);\n    }\n    else if(index == 12){\n        makeMat(mat,vec3(0.0,0.0,0.0),0.0,0.95);\n    }\n    else if(index == 13){\n        makeMat(mat,vec3(1.00,0.80,0.50),1.0,0.5);\n    }\n    return mat;   \n}\n\nvec3 randDir(vec3 ref, float glossiness)\n{\n    vec3 w = ref;//normalize(mix(nor,ref,glossiness));\n    vec3 u = normalize(cross(vec3(w.y,w.z,w.x), w));\n    vec3 v = normalize(cross(w, u));\n\n    float shininess = pow(8192.0, glossiness);\n\n    float a = acos(pow(1.0 - rand() * (shininess + 1.0) / (shininess + 2.0), 1.0 / (shininess + 1.0)));\n    a *= PI * 0.5;\n    float phi = rand() * PI * 2.0;\n    vec3 rlt = (u * cos(phi) + v * sin(phi)) * sin(a) + w * cos(a);\n\n    return rlt;\n}\n\nfloat fresnelSchlick(float InCosine, float normalReflectance)\n{\n    float oneMinusCos = 1.0 - InCosine;\n    float oneMinusCosSqr = oneMinusCos * oneMinusCos;\n    float fresnel = normalReflectance +\n        (1.0 - normalReflectance) * oneMinusCosSqr * oneMinusCosSqr * oneMinusCos;\n\n    return fresnel;\n}\n\n//=========================\n\n// light\nvec3 light = normalize(vec3(0.8,0.5,0.2));\n//vec3 lightColor = vec3(0.8,0.6,0.6);\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 pos = ro;\n    vec3 dir = rd; \n\n\tvec3 finalLight = vec3(0.0);\n    vec3 frac = vec3(1.0);\n    for(int i= 0; i<MAX_BOUNCE; i++){\n        vec4 tmat = intersect(pos,dir);\n        if(tmat.x > 0.0){\n            Mat mat = getMat(int(tmat.w));\n            pos += tmat.x*dir;\n            vec3 nor = calcNormal(pos);\n            float r = mix(0.15,1.0,mat.metallic);\n\t\t\tr = fresnelSchlick(dot(nor,-dir),r);\n            if(rand() > r){//diffuse\n                vec4 tshadow = intersect(pos + nor * MIN_DISTANCE,randDir(light,0.995));//softshadow\n                float shadow = tshadow.x>0.0?0.0:1.0;\n                vec3 diff = mat.color * shadow * max(dot(nor,light),0.0);                \n                finalLight += diff * frac;\n                frac *= mat.color;\n                dir = randDir(reflect(dir,nor),r);\n            }\n            else{//spec\n            \tvec3 refColor = mix(vec3(1.0),mat.color,mat.metallic);\n                frac *= refColor;\n                dir = randDir(reflect(dir,nor),mat.glossiness);\n            }            \n            \n\n            pos += nor * MIN_DISTANCE;\n        }\n        else{\n            vec3 bkgColor = getBackground(dir);\n            finalLight += bkgColor * frac;\n            finalLight += pow(max(dot(dir,light),0.0),50.0);\n            break;\n        }\n    }\n    return finalLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    \n    float weight = 1.0;\n    //if mouse moved,reset weight\n    {\n        vec2 uvMouse = vec2(0.5,0.5) / iResolution.xy;\n        vec4 lastMouse = texture(iChannel0, uvMouse);\n        float mouseMove = length(lastMouse.xy * iResolution.xy - iMouse.xy);\n        if(mouseMove > 1.0 || iFrame == 0){\n            weight = 1.0;\n        }\n        else{\n            weight = lastMouse.z;\n        }\n        weight = max(weight,0.0001);\n\n        if(fragCoord.x == 0.5 && fragCoord.y == 0.5){\n            fragColor = vec4(iMouse.xy/iResolution.xy,1.0/(1.0/weight + 1.0) ,0.0);\n            return;\n        }\n    }\n    \n    vec2 p0 = fragCoord.xy + vec2(rand(),rand());//anti-aliasing\n    vec2 p1 = -1.0 + 2.0 * p0 / iResolution.xy;\n    p1.x *= iResolution.x/iResolution.y;\n\n    float yaw = iMouse.x * 0.05;\n    float pitch = clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n       \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p1.x*uu + p1.y*vv + 2.5*ww );\n\n    vec3 col = render( ro, rd );\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastColor = texture(iChannel0, uv);\n    \n    fragColor = vec4(mix(lastColor.xyz,col,weight),1);\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}