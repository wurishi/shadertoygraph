{"ver":"0.1","info":{"id":"wsffDN","date":"1588291067","viewed":846,"name":"cam filter fluid(virtual BG)","username":"sidchou","description":"cam filter fluid sid\n\nvoronoi: https://www.shadertoy.com/view/3dlBWS\nfilter: https://www.shadertoy.com/view/WdjfDR\n\nexternal reference: \nturbulent fluid jet: https://www.shadertoy.com/view/3dtSD7\nrandom: https://www.shadertoy.com/view/4ssXRX\n","likes":9,"published":1,"flags":34,"usePreview":0,"tags":["test","filter","fluid","camera","background","turbulence","jet","virtual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//turbulence https://www.shadertoy.com/view/3dtSD7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\t// vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // ivec2 ifc = ivec2(round(fragCoord)); \n    \n    // direct image flow visualization (but w/heavy spurious numerical diffusion)\n    vec3 sceneColor = vec3(texture(iChannel2, fragCoord / iResolution.xy));\n   \tvec4 fluid = vec4(clamp(sceneColor, 0., 1.), 1);  \n\n    vec4 cam = texture(iChannel3, fragCoord / iResolution.xy);\n\tfloat n = step(0.1,cam.r+cam.g+cam.b);\n    fragColor = mix (fluid, cam, n);\n    \n    fragColor = fluid;\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//vec4 BGColor = vec4(.9,.59,.9,1.);\nvec4 BGColor = vec4(.9,.8,.9,1.);\nvec4 BGColorOffset; \n//vec4 BGColor = vec4(.8,.7,.3,1.);\nvec4 sat = vec4(.8,.8,.8,1.);\nvec4 brightness = vec4(.3,.3,.3,0.);\nvec4 Rgb2Hsb (vec4 _color) {\n    vec4 color = _color;\n    color /= 255.0;   \n    vec4 hsb = _color;\n\n    \n    float maxColorValue = max (color.r, max (color.g, color.b) );\n    float minColorValue = min (color.r, min(color.g, color.b) );\n    float delta = maxColorValue - minColorValue;\n    \n    hsb.b = maxColorValue;\n    hsb.g = (maxColorValue == 0.0) ? 0.0 : delta / maxColorValue;\n    \n    if (hsb.g == 0.0)\n        return color;\n    \n    if (color.r == maxColorValue)\n\t\thsb.r = (color.g - color.b) / delta;\n\telse if (color.g == maxColorValue)\n\t\thsb.r = 2.0 + (color.b - color.r) / delta;\n\telse if (color.b == maxColorValue)\n\t\thsb.r = 4.0 + (color.r - color.g) / delta;\n\n\thsb.r *= 60.0;\n\n\tif (hsb.r < 0.0)\n\t\thsb.r += 360.0;\n\treturn hsb;\n}\n\nvec4 Hsb2Rgb (vec4 _hsb) {\n    vec4 hsb = _hsb;\n    vec4 rgb;\n    \n    if (hsb.g == 0.0) \n    \treturn hsb;\n    else {\n        float f; float p; float q; float t; int i;\n\n        if (hsb.r == 360.0)\n            hsb.r = 0.0;\n        else if (hsb.r > 360.0)\n            hsb.r -= 360.0;\n        hsb.r /= 60.0;\n    \n        i = int(hsb.r);\n\n        f = hsb.r - float(i);\n        p = hsb.b * (1.0 - hsb.g);\n        q = hsb.b * (1.0 - hsb.g*f);\n        t = hsb.b * (1.0 - hsb.g*(1.0 - f));\n        \n        \n        if (i == 0) {\n            rgb.r=hsb.b;\n            rgb.g=t;\n            rgb.b=p;\n        } else if (i==1) {\n            rgb.r=q;\n            rgb.g=hsb.b;\n            rgb.b=p;\n        } else if (i==2) {\n            rgb.r=p;\n            rgb.g=hsb.b;\n            rgb.b=t; \n        } else if (i==3) {\n            rgb.r=p;\n            rgb.g=q;\n            rgb.b=hsb.b;\n        } else if (i==4) {\n            rgb.r=t;\n            rgb.g=p;\n            rgb.b=hsb.b;\n        } else if (i==5) {\n            rgb.r=hsb.b;\n            rgb.g=p;\n            rgb.b=q;\n        } \n    }\n    \n   \treturn rgb*255.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.z > 0.5){\n        BGColor.rg = iMouse.xy/iResolution.xy;\n    }//else{BGColor.ba = iMouse.xy/iResolution.xy;}\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 lastframe = texture(iChannel1,uv);\n    vec4 cam = texture(iChannel0,uv);\n    //cam = mix(cam,lastframe,0.5);\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec4 detect = cam;\n    \n    vec4 len = vec4(length(uv));\n    detect += 2.*len*len*len;\n    vec4 hsb = Rgb2Hsb(detect);\n    hsb +=vec4(29.,.5,.0,0.);\n    vec4 col = Hsb2Rgb(hsb);\n    float _d = step(col.r,BGColor.r)*step(col.g,BGColor.g)*step(col.b,BGColor.b);\n    detect = step(col,BGColor);\n    cam *= _d;   \n    //cam = step(0.1,cam - cam*step(cam.r*cam.g*cam.b,0.05))+cam;\n    \n\n    //len = step(0.5,len);\n  \t//fragColor = col;\n    //fragColor = step(col,BGColor)*col;\n    //fragColor = vec4(_d);\n    //fragColor = step(0.,uv.x)*fragColor+step(uv.x,0.)*BGColor;\n    fragColor = cam;\n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Vorticity particles\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Set to false for a simpler simuation of a circular Kelvin-Helmhotz shear instability.\n    bool jet = true;\n    \n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    if (iFrame < 10 && !jet) {\n        vec3 sceneColor;\n        float initpack = 1.0;\n        float stagger = trunc(fragCoord.y / 4.) / iResolution.y;\n        if (false) {\n            // linear shear (classic K-H) \n\t\t\tsceneColor = vec3((uv[0] + stagger) / initpack + 0.05*0., -0, 0.05);\n        } else {\n            // rotational shear\n        \tfloat coord = 2.*3.14159 * (uv[0] + stagger) / initpack / aspect * 1.004;\n        \tfloat circrad = 0.4;\n\t\t\tsceneColor = vec3(sin(coord)*circrad, cos(coord)*circrad, -0.05); \n        }\n\n        \n\t\tfragColor = vec4(sceneColor, 1);\n    } else {\n\t    ivec2 ifc = ivec2(round(fragCoord)); \n\t    vec4 puvc = texelFetch(iChannel0, ifc, 0);\n        \n        vec2 pxy = vec2(puvc) * iResolution.y + iResolution.xy*.5;\n        ivec2 ipxy = ivec2(round(pxy));\n\t    vec2 uvipxy = (vec2(ipxy) - iResolution.xy*.5) / iResolution.y;\n\n\t    vec2 vxvy = vec2(texture(iChannel1, pxy / vec2(iResolution)));\n        \n        float dt = 0.0001 ; // iTimeDelta * 0.01;\n        \n        \n        fragColor = puvc + dt * vec4(vxvy, 0, 0);\n        \n        // Wrap the particles around if they manage to get out (not entirely physical)\n        aspect = 1./1.0 * .99 * aspect;\n        float aspy = .99;\n        if (fragColor[0] > aspect * .5) fragColor[0] -= aspect;\n        if (fragColor[0] <= -aspect * .5) fragColor[0] += aspect;\n        if (fragColor[1] > aspy * .5) fragColor[1] -= aspy;\n        if (fragColor[1] <= -aspy * .5) fragColor[1] += aspy;\n\n        if (abs(fragCoord.x + fragCoord.y / iResolution.y * 20. - iMouse.x) < 1.0 && iMouse[2] > 0.) {\n\t\t\tvec2 muv = (vec2(iMouse) - iResolution.xy*.5) / iResolution.y;\n            fragColor = vec4(muv, fragColor[2], fragColor[3]); \n        \n        }        \n    }\n\n    if (jet) {\n        vec3 sceneColor;\n        float stagger = trunc(fragCoord.y / 4.) / iResolution.y;\n        \n        if (iFrame == int(round((aspect*.5 + uv[0] + stagger) * 100.))) {\n        //if (false){   \n            if (int(round(mod(fragCoord.x / 2., 2.))) == 0) {\n                fragColor = vec4(aspect*.49, -0.1, .2, 1); \n            } else {\n                fragColor = vec4(aspect*.49, 0.1, -.2, 1); \n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Velocity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // No-flux boundary conditions:\n    // (set these to true to keep the flow boxed in -- computationally expensive, tho)\n    bool boxx = true;\n    bool boxy = true;\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 vxvy = vec2(0.0);        \n    \n    float aspect = 1./1.0 *  .99/.98 * .98 * float(iResolution.x) / float(iResolution.y);\n    float aspy = .98;\n    float rfac = 0.05; // divergence fudge factor for approximate no flux\n    \n   \tint subsamp = 2;\n    int n = int(iResolution.x) / subsamp - 1; // / 2.);\n    int nv = 3; \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < nv; j++) {\n        \n        vec4 puvc = texelFetch(iChannel1, ivec2(i * subsamp, j * subsamp), 0);\n        vec2 puv = vec2(puvc); //vec2(puvc[0], puvc[1]);\n        \n        vec2 duv = uv - puv;\n        float d2 = dot(duv, duv);\n        \n        if (sqrt(d2) > 0.01) {\n        \tvxvy += puvc[2] * vec2(-duv[1], duv[0]) / d2;\n        }\n        \n\n        if (boxy) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(puv[0], aspy - puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }\n\n\n        if (boxy) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(puv[0], -aspy - puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }        \n\n    \n        if (boxx) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(aspect - puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }      \n\n        if (boxx) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(-aspect - puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }                        \n        }\n      }\n    }\n    vec4 camTex = texture(iChannel2,fragCoord.xy/iResolution.xy);\n    \n\tvxvy.g += camTex.r*5.;\n    \n    fragColor = vec4(vxvy, 0., 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//color pick\nvec3 color(float t) {\n    vec3 col;\n\tvec3 a = vec3(0.15,0.26,0.91);\n    vec3 b = vec3(0.34,0.78,0.94);\n    vec3 c = vec3(0.89,0.25,0.91);\n    \n    col = step(t,0.333)*a;\n    col +=step(0.333,t)*step(t,0.667)*b;\n    col +=step(0.667,t)*c;\n    \n    return col;\n}\n\n//hash (random) function\nvec2 hash( vec2 p ) {\n    p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); \n    return fract(p);}\n\n// return distance as x, and xy as y\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n    vec2 mg, mr;\n    \n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        \n        vec2  r = g - f + o;\n        //o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n \n\t    //vec2  r = g - f; // square\n\t\tfloat d = dot( r, r );\n\n        if( d<m.x ){\n\t\t\tmr = r;\n\t\t\tmg = g;\n            m = vec3( d, o.x,o.y);\n        }    \n    }\n    \n    \n    //distance to\n    float md = 8.0 ;\n  for( int j=-2; j<=2; j++ ){\n\tfor( int i=-2; i<=2; i++ ){\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n        //o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        \n        o =  sin( iTime + 6.2831*o );\n        vec2 r =  g - f + o;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n  }\n\n\n    return vec3( sqrt(m.x), m.y*m.z, md );\n}\n//https://www.shadertoy.com/view/4ssXRX\n    float nrand( vec2 n ) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//random\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\n\n\n\n\n// Advection flow tracking\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    float dt = 0.0001 ;\n    \n\tvec4 outcolor;\n    if (iFrame < 10) {\n        //init image\n        // inverse displacement map (but with numerical diffusion spuriously smoothing the map)\n        outcolor = vec4(uv, 0, 0); \n        outcolor = texture(iChannel2,fragCoord.xy / iResolution.xy);\n    } else {\n        //ivec2 ifc = ivec2(round(fragCoord)); \n\n        vec2 vxvy = vec2(texture(iChannel0, fragCoord / vec2(iResolution)));\n\n        vec2 newFragCoord = fragCoord - dt * vxvy * vec2(iResolution);\n\n        outcolor = texture(iChannel1, newFragCoord / vec2(iResolution));\n    }\n    \n    //Background\n\tvec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    p.x-=iTime*.01;\n    p.y-=iTime*.005;\n    \n\n    // voronoi patterm\n\tvec3 c = voronoi(10.*p);\n    c.y += floor(iTime/5.);\n    \n    //randomize order\n    vec2 hashing = hash(vec2(0.,c.y))*30.;\n\tc.y *= hashing.x*hashing.y;\n    c.y = fract(c.y);\n    \n    // colorize\n    vec3 col;\n    col = vec3(c.y);\n    col = vec3(color(c.y));\n\t\n    //edge\n    vec3 edge = vec3(smoothstep( 0.17, 0.2,c.z));     \n    col = min(col,edge);\n    \n    vec4 bg = vec4(col,1.);    \n        \n        //iimage\n        float ran = n1rand(fragCoord.xy / iResolution.xy);\n \n    \t\n    \tvec2 uv_ = fragCoord.xy / iResolution.xy;\n        vec4 cam = texture(iChannel3, fragCoord / iResolution.xy);\n        float n = step(0.1,cam.r+cam.g+cam.b);\n    \n    \t//vec4 preMixcam = mix (texture(iChannel2,uv_), cam, n);\n    \tvec4 preMixcam = mix (bg, cam, n);\n\n    \n    \toutcolor = mix(outcolor,cam,ran*step(ran,.6)*n);\n    \n        ran = step(ran,0.15)*ran;\n    \n\t\t//vec4 sprinkles = texture(iChannel2,uv_);\n        //outcolor = mix(outcolor,sprinkles,ran);\n\t\toutcolor = mix(outcolor,bg,ran);\n\n\n    fragColor = outcolor;\n\n}","name":"Buffer C","description":"","type":"buffer"}]}