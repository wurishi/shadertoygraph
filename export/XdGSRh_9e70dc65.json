{"ver":"0.1","info":{"id":"XdGSRh","date":"1463063101","viewed":316,"name":"Voxel CA","username":"akohdr","description":"Local rule automata viewed through voxel space.  State maintained in buffer loop of tiled 2D z-slices.\niMouse.x rotates and iMouse.y controls view culling.  Upper iMouse.y shows underlying 2D state space.\n","likes":5,"published":1,"flags":96,"usePreview":0,"tags":["voxel","particles","automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldf3WB","filepath":"https://soundcloud.com/khairou/crazy-frog-popcorn-remix","previewfilepath":"https://soundcloud.com/khairou/crazy-frog-popcorn-remix","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n\n//#define SINGLE_CELL\n#define EYE 90\n#define RES  iResolution.xy\n#define FRES vec3(33,47,89)\n#define FDIM vec3(floor(RES/FRES.xy),FRES.z)\n\nbool isVoxel(out vec4 k, const in vec4 P)\n{\n    vec3 H = FRES/2.;\n    //if(any(greaterThan(abs(P.xyz),H))) return false; \t// bounds check, kills repetition \n    vec4 p = P + vec4(H.xyz,0);  \t\t\t\t\t\t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    vec2 p2 = FRES.xy * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FRES.xy);\n\n    k = texture(iChannel0, p2/RES);\n    return k.x + k.y + k.z>3.*iMouse.y/RES.y;\t// mouse controled culling\n//    return k.x + k.y + k.z>0.;\t// anything but black\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float Rx = iResolution.x, Ry = iResolution.y;\n    \n    if((iMouse.z>0.) && (iMouse.y>250.)){\n        k = texture(iChannel0,P/RES); return;}  // show underlying state space\n    \n    //float T = 9.*iMouse.x/Rx;\t\t// mouse rotate\n    //float T = iTime/8.;\t\t// slow rotate\n    //float T = 2.;\t\t\t\t\t// fixed view\n\tfloat T = iMouse.z>0. ? 5.*iMouse.x/Rx : iTime/6.;  //combo\n    \n    vec2 h = vec2(0,.5),\n         u = (P - h*Ry)/Rx - h.yx;\n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<256; i++) {\n        float a=s.x, b=s.y, c=s.z;\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n        \n        if(isVoxel(k, vec4(f, T))) {\n            k += m.x>.0 ? vec4(0) : m.y>.0 ? vec4(.6) : vec4(.3); return; }//early exit\n    }\n    //k = vec4(0,.2,.3,1);\t\t\t// background\n    k = texture(iChannel1, P/RES/3.)/3.;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n//\n#define RES  iResolution.xy\n#define FRES vec3(33,47,89)\n#define FDIM vec3(floor(RES/FRES.xy),FRES.z)\n\n#define BLK vec4(.0,.0,.0,1.)\n#define GRY vec4(.2,.2,.2,1.)\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.1,.1,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,.8,.0,1.)\n#define ORG vec4(.4,.1,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n#define ANY vec4(-1)\n\n#define QK(q,K) if(q){k=K;return;}\n#define VX(x,y,z,K) if(length(q.xyz - vec3(x,y,z)+.25)<.5)k=K;\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    float z = p.z, w = FDIM.x;\n    vec2 FR = FRES.xy;\n    return FR * floor(vec2(mod(z,w), z/w)) + mod(p.xy, FR);\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    vec2 f = floor(p/FRES.xy);\n    return vec4(mod(vec3(p, FDIM.x*f.y + f.x),FRES), 0);//iTime);\n}\n\nvoid init(out vec4 k, const in vec2 p, const in vec4 q, vec2 uv);\nvoid applyLocalRules(inout vec4 k, const in vec4 q);\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n//    QK(any(lessThan(p,vec2(1))), BLK) QK(any(greaterThan(p,RES)), BLK) // FIX clamp induced beaming\n\n    vec4 q = prj2Dto4D(p);\t\t\t\t\t\t\t// 4D state position\n    vec2 uv = p/RES;\n    if(iTime<2.) { init(k,p,q,uv); return;}\t// init() condition\n    k = texture(iChannel0, uv);\t\t\t\t\t// retrieve prior state\n\n    applyLocalRules(k, q);\n}\n\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 p, const in float n, const in vec4 K)\n{\n    if(K==ANY) return false;\n    float s = mod(n,9.);\n    vec4 dp = floor(vec4(s/3., n/9., mod(s,3.), 1))-1.; // neighbor relative offset\n\n    vec4 nk = texture(iChannel0, prj4Dto2D(p+dp)/RES); //neighbor color\n    return nk.rgb != K.rgb;\n}\n\nvoid applyRule(const in vec4 p, const in vec4 r[28], inout vec4 k)\n{\n//    for(int i=1; i<28; i++) // TODO try manually unrolling loop\n//        if(!match(p, float(i-1), r[i])) return;\n        \n    // WOW speed increase is massive (compilation can be pig)\n    if(noMatch(p, 0.,  r[1])) return;\n    if(noMatch(p, 1.,  r[2])) return;\n    if(noMatch(p, 2.,  r[3])) return;\n    if(noMatch(p, 3.,  r[4])) return;\n    if(noMatch(p, 4.,  r[5])) return;\n    if(noMatch(p, 5.,  r[6])) return;\n    if(noMatch(p, 6.,  r[7])) return;\n    if(noMatch(p, 7.,  r[8])) return;\n    if(noMatch(p, 8.,  r[9])) return;\n    if(noMatch(p, 9., r[10])) return;\n    if(noMatch(p,10., r[11])) return;\n    if(noMatch(p,11., r[12])) return;\n    if(noMatch(p,12., r[13])) return;\n    if(noMatch(p,13., r[14])) return;\n    if(noMatch(p,14., r[15])) return;\n    if(noMatch(p,15., r[16])) return;\n    if(noMatch(p,16., r[17])) return;\n    if(noMatch(p,17., r[18])) return;\n    if(noMatch(p,18., r[19])) return;\n    if(noMatch(p,19., r[20])) return;\n    if(noMatch(p,20., r[21])) return;\n    if(noMatch(p,21., r[22])) return;\n    if(noMatch(p,22., r[23])) return;\n    if(noMatch(p,23., r[24])) return;\n    if(noMatch(p,24., r[25])) return;\n    if(noMatch(p,25., r[26])) return;\n    if(noMatch(p,26., r[27])) return;\n    \n    k = r[0];\n}\n\n// mini-DSL for rule definitions ===========================================================\n// ( 3x3x3 tensors & graphical symbols in Mathematica are more eloquent )\n#define APPLY(f) f(r);applyRule(q,r,k);\n#define RULE(n) void n(out vec4 r[28]){clrRule(r,ANY);\n#define WHEN r[14]=\n#define OUT  r[0]=\n\nvoid clrRule(out vec4 k[28], const in vec4 K)\n{\n    k[0]=K;k[1]=K;k[2]=K;k[3]=K;k[4]=K;k[5]=K;k[6]=K;k[7]=K;k[8]=K;k[9]=K;\n    k[10]=K;k[11]=K;k[12]=K;k[13]=K;k[14]=K;k[15]=K;k[16]=K;k[17]=K;k[18]=K;k[19]=K;\n    k[20]=K;k[21]=K;k[22]=K;k[23]=K;k[24]=K;k[25]=K;k[26]=K;k[27]=K;\n}\n\n\n// local rules =============================================================================\n\nRULE(ruleRED)\t\t\t// rule name\n    WHEN BLK;\t\t\t// antecedent (center)\n\t OUT RED;\t\t\t// consequent (center evolution)\n    \tr[13] = RED;\t// qualifiers (optional, all must be satifisfied to evolve)\n}\n\nRULE(ruleBLU)\t\t\tWHEN BLK;\tOUT BLU;\tr[11] = BLU;}\nRULE(ruleGRN)\t\t\tWHEN BLK;\tOUT GRN;\tr[ 5] = GRN;}\nRULE(rulePRP)\t\t\tWHEN BLK;\tOUT PRP;\tr[15] = PRP;}\nRULE(ruleYEL)\t\t\tWHEN BLK;\tOUT YEL;\tr[17] = YEL;}\nRULE(ruleCYN)\t\t\tWHEN BLK;\tOUT CYN;\tr[23] = CYN;}\nRULE(ruleRED_ORG_GRN)\tWHEN RED;\tOUT GRN;\tr[15] = ORG;}\nRULE(ruleGRN_ORG_PRP)\tWHEN GRN;\tOUT PRP;\tr[23] = ORG;}\nRULE(ruleGRN_ORG_YEL)\tWHEN GRN;\tOUT YEL;\tr[17] = ORG;}\nRULE(ruleBLU_ORG_GRN)\tWHEN BLU;\tOUT GRN;\tr[17] = ORG;}\nRULE(rulePRP_ORG_CYN)\tWHEN PRP;\tOUT CYN;\tr[13] = ORG;}\nRULE(ruleCYN_ORG_RED)\tWHEN CYN;\tOUT RED;\tr[ 5] = ORG;}\nRULE(ruleYEL_ORG_CYN)\tWHEN YEL;\tOUT CYN;\tr[11] = ORG;}\nRULE(ruleCYN_ORG_BLU)\tWHEN CYN;\tOUT BLU;\tr[11] = ORG;}\n\nvoid applyLocalRules(inout vec4 k, const in vec4 q)\n{\n    if(!(k==ORG || k==GRY)) k=BLK;  // clear everything except... (comment to view trails)\n    \n    vec4 r[28];\n    APPLY(ruleRED)\n    APPLY(ruleGRN)\n    APPLY(ruleBLU)\n    APPLY(rulePRP)\n    APPLY(ruleCYN)\n    APPLY(ruleYEL)\n    APPLY(ruleGRN_ORG_YEL)\n    APPLY(ruleRED_ORG_GRN)\n    APPLY(ruleGRN_ORG_PRP)\n    APPLY(ruleBLU_ORG_GRN)\n    APPLY(rulePRP_ORG_CYN)\n    APPLY(ruleCYN_ORG_RED)\n    APPLY(ruleYEL_ORG_CYN)\n    APPLY(ruleCYN_ORG_BLU)\n}\n\n\n// automata initial condition ==============================================================\nvoid init(out vec4 k, const in vec2 p, const in vec4 q, vec2 uv)\n{\n    k = BLK;\n    //k = texture(iChannel1, uv);  // add some noise (iMouse.y controls culling)\n    \n    // temporary initial axis (removed by clear everything rule)\n    for(int i=18; i<29; i++){\n        float j = float(i-17);\n        VX(j,1,17, RED-.1)\n        VX(1,j,17, GRN-.1)\n        VX(1,1, i, BLU-.1)\n    }\n\n    // create some loops of differing sizes\n    for(float i=0.; i<12.; i+=3.) {\n        // loop corners\n        VX(25.-i,     5, 85., ORG)\n        VX(25.-i, 23.-i, 84., ORG)\n        VX(25.-i, 22.-i, 24., ORG)\n        VX(25.-i,     4, 25., ORG)\n\n        VX( 6,     9, 37.-i, ORG)\n        VX( 6, 32.-i, 37.-i, ORG)\n        VX(32, 32.-i, 37.-i, ORG)\n        VX(32,     8, 37.-i, ORG)\n\n        // add some runners\n        VX(25.-i, 5, 45.-i, RED)\t\t// seems to be x/y drift along z-direction, hmmm?!\n        VX(25.-i, 5, 39.-i, RED)\n        VX(24.-i, 8, 37.-i, BLU)\n    }\n    \n    // voxel volume bounds\n    vec3 b = FRES-vec3(1,1,18);\n    VX(   1,   1,  17, GRY)\n    VX( b.x,   1,  17, GRY)\n    VX( b.x, b.y, b.z, GRY)\n    VX( b.x, b.y,  17, GRY)\n    VX(   1, b.y,  17, GRY)\n    VX(   1, b.y, b.z, GRY)\n    VX( b.x,   1, b.z, GRY)\n    VX(   1,   1, b.z, GRY)\n}\n","name":"Buf A","description":"","type":"buffer"}]}