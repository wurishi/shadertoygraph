{"ver":"0.1","info":{"id":"mlXXW8","date":"1674656431","viewed":114,"name":"Rotation with shears","username":"jmpep","description":"Click + Move the mouse to move the different regions.\n\nWhite - interpolated rotation using rotation matrix\nRed - interpolated rotation using shears (should be equivalent to the rotation)\nGreen - nearest-neighbor rotation\nBlue - nearest-neighbor shears","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["rotation","shear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://cohost.org/tomforsyth/post/891823-rotation-with-three\n\n#define TO_RAD  0.01745329251\n#define PI      3.14159265359\n#define TWO_PI  6.28318530718\n#define PI_HALF 1.57079632679\n\nvec2 rotate_image(float angle_rad, vec2 uv) {\n    vec2 uv_centered = uv * 2.0 - vec2(1.0);\n    mat2 rot = mat2(cos(-angle_rad), sin(-angle_rad), -sin(-angle_rad), cos(-angle_rad));\n    uv_centered = rot * uv_centered;\n    \n    return (uv_centered + vec2(1.0)) / 2.0;\n}\n\nvec2 nearest_neighbor(vec2 uv, ivec2 size) {\n    ivec2 texel = ivec2(uv * vec2(size));\n    return (vec2(texel) + vec2(0.5)) / vec2(size);\n}\n\nvec2 shear_x(float angle_rad, vec2 uv) {\n    vec2 uv_centered = uv * 2.0 - vec2(1.0);\n    float amount = -tan(-angle_rad / 2.0);\n    uv_centered = vec2(uv_centered.x + amount*uv_centered.y, uv_centered.y);\n    \n    return (uv_centered + vec2(1.0)) / 2.0;    \n}\n\nvec2 shear_y(float angle_rad, vec2 uv) {\n    vec2 uv_centered = uv * 2.0 - vec2(1.0);\n    float amount = sin(-angle_rad);\n    uv_centered = vec2(uv_centered.x, uv_centered.y + amount*uv_centered.x);\n    \n    return (uv_centered + vec2(1.0)) / 2.0;    \n}\n\nvec2 shear_x_nn(float angle_rad, vec2 uv, ivec2 size) {\n    ivec2 texel = ivec2(uv * vec2(size));\n    float amount = -tan(-angle_rad / 2.0);\n    texel.x += int(amount * float(texel.y - size.y / 2));\n     \n    return (vec2(texel) + vec2(0.5)) / vec2(size);    \n}\n\nvec2 shear_y_nn(float angle_rad, vec2 uv, ivec2 size) {\n    ivec2 texel = ivec2(uv * vec2(size));\n    float amount = sin(-angle_rad);\n    texel.y += int(amount * float(texel.x - size.x / 2));\n     \n    return (vec2(texel) + vec2(0.5)) / vec2(size);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Use a square viewport\n    if (fragCoord.x >= iResolution.y) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Compute UV in [0, 1) range\n    vec2 uv = (fragCoord/iResolution.yy);\n    \n    // Compute angle in [-pi, pi) range\n    float angle_rad = (iTime * 10.0) * TO_RAD;\n    angle_rad = angle_rad - floor(angle_rad / TWO_PI) * TWO_PI - PI;\n\n    ivec2 size = textureSize(iChannel0, 0).xy;\n    \n    \n    // Compute the rotated UVs using rotation\n    vec2 uv_rotated = rotate_image(angle_rad, uv);\n    vec2 uv_rotated_nn = nearest_neighbor(uv_rotated, size);\n    \n    // if angle in the (pi, 2/3*pi) range, fli,p x and y.\n    if (angle_rad <= -PI_HALF || angle_rad >= PI_HALF) {\n        uv.x = 1.0 - uv.x;\n        uv.y = 1.0 - uv.y;\n        angle_rad += PI;\n        if (angle_rad > PI) angle_rad -= TWO_PI;\n    }\n    \n    // Compute the rotated UVs using shears\n    vec2 uv_shear = shear_x(angle_rad, uv);\n    uv_shear      = shear_y(angle_rad, uv_shear);\n    uv_shear      = shear_x(angle_rad, uv_shear);\n    \n    vec2 uv_shear_nn = shear_x_nn(angle_rad, uv, size);\n    uv_shear_nn      = shear_y_nn(angle_rad, uv_shear_nn, size);\n    uv_shear_nn      = shear_x_nn(angle_rad, uv_shear_nn, size);\n\n    // Sample the images\n    vec3 image_rotation = texture(iChannel0, uv_rotated).xyz;\n    vec3 image_shear = texture(iChannel0, uv_shear).xyz;\n\n    vec3 image_rotation_nn = texture(iChannel0, uv_rotated_nn).xyz;\n    vec3 image_shear_nn = texture(iChannel0, uv_shear_nn).xyz;\n    \n    // Show the images    \n    vec3 color = vec3(0.0);\n    \n    vec2 mouse_coordinates = iMouse.xy;\n    if (iMouse.z < 1.0) {\n        mouse_coordinates = iResolution.yy / 2.0;\n    }\n    \n    // .. border colors\n    if (fragCoord.x < mouse_coordinates.x && fragCoord.y >= mouse_coordinates.y) color = vec3(1.0, 1.0, 1.0);\n    if (fragCoord.x > mouse_coordinates.x && fragCoord.y >= mouse_coordinates.y) color = vec3(1.0, 0.0, 0.0);\n    if (fragCoord.x < mouse_coordinates.x && fragCoord.y <= mouse_coordinates.y) color = vec3(0.0, 1.0, 0.0);\n    if (fragCoord.x > mouse_coordinates.x && fragCoord.y <= mouse_coordinates.y) color = vec3(0.0, 0.0, 1.0);\n    \n    // .. the actual images\n    if (fragCoord.x < mouse_coordinates.x - 4.0) {\n        if (fragCoord.y < mouse_coordinates.y - 4.0) {\n            color = image_rotation_nn;\n        } else if (fragCoord.y > mouse_coordinates.y + 4.0) {\n            color = image_rotation;\n        }\n    } else if (fragCoord.x > mouse_coordinates.x + 4.0) {\n        if (fragCoord.y < mouse_coordinates.y - 4.0) {\n            color = image_shear_nn;\n        } else if (fragCoord.y > mouse_coordinates.y + 4.0) {\n            color = image_shear;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}