{"ver":"0.1","info":{"id":"4slyzf","date":"1489959241","viewed":238,"name":"pbr bender","username":"ZeBestNickname","description":"pbr with golden bender head as reference. Roughness oscillates between 0 and 1 over time. Think I did things correctly, not too sure tho..","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["pbribl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//general constants\n#define EPSILON 0.001\n#define PI 3.141592\n\n//material constants\n#define LIGHT 0\n#define BENDER 1\n#define EYES 2\n#define TEETH 3\n\nvec3 light_pos;\nfloat threshold = EPSILON;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix(vec3 translation)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                translation.x, translation.y, translation.z, 1.0);\n}\n\n//sdfs and smin taken from iq's sdf tutorial https://iquilezles.org/articles/distfunctions\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float s, vec3 c)\n{\n    return length(p - c)-s;\n}\n\nfloat sdCone(vec3 p, vec3 c)\n{\n    p = floor(p);\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h, vec2 scale)\n{\n    p.xz *= scale;\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat light(vec3 p)\n{\n    return sdSphere(p, 0.05, light_pos);\n}\n\nfloat teeth(vec3 p)\n{\n    p.z += cos(p.x * 1.2);\n    \n    vec4 transformed = rotationMatrix(vec3(1, 0, 0), PI / 2.0) * translationMatrix(vec3(0, 0.1, -0.4)) * vec4(p, 1);\n    p = transformed.xyz;\n    \n    return sdCappedCylinder(p, vec2(0.3, 0.1), vec2(0.6, 1.5));\n}\n\nfloat antenna(vec3 p)\n{\n    p -= vec3(0, 1.25, 0);\n    \n    float d;\n    \n    d = sdCappedCylinder(p, vec2(0.1, 0.1), vec2(1, 1));\n    d = smin(d, sdCappedCylinder(p, vec2(0.04, 0.5), vec2(1, 1)), 0.1);\n    d = min(d, sdSphere(p, 0.1, vec3(0, 0.55, 0)));\n    \n    return d;\n}\n\nfloat eyes(vec3 p, inout int hit_obj)\n{\n    p -= vec3(0.0, 0.45, -0.4);\n    \n    float d;\n    \n    d = udRoundBox(p, vec3(0.4, 0.08, 0.3), 0.2);\n    d = max(d, -udRoundBox(p + vec3(0, 0, 0.2), vec3(0.4, 0.08, 0.3), 0.1));\n    \n    hit_obj = d < threshold && hit_obj < 0 ? BENDER : hit_obj;\n    \n    vec3 leftp = p + vec3(-0.21, -0.1, 0.25);\n    vec3 rightp = p + vec3(0.21, -0.1, 0.25);\n    \n    vec4 transformedl = rotationMatrix(vec3(1, 0, 0), PI / 2.0) * translationMatrix(vec3(0, 0.1, -0.4)) * vec4(leftp, 1);\n    vec4 transformedr = rotationMatrix(vec3(1, 0, 0), PI / 2.0) * translationMatrix(vec3(0, 0.1, -0.4)) * vec4(rightp, 1);\n    \n    leftp = transformedl.xyz;\n    rightp = transformedr.xyz;\n    \n    d = min(d, sdCapsule(leftp, vec3(0, 0.4, 0), vec3(0, -0.4, 0), 0.2));\n    d = min(d, sdCapsule(rightp, vec3(0, 0.4, 0), vec3(0, -0.4, 0), 0.2));\n    \n    hit_obj = d < threshold && hit_obj < 0 ? EYES : hit_obj;\n    \n    return d;\n}\n\nfloat bender(vec3 p, inout int obj_hit)\n{\n    p += vec3(0, 0.75, 0);\n    float d;\n    \n    d = sdCapsule(p, vec3(0, 0.7, 0), vec3(0, -0.6, 0), 0.6);\n    d = max(d, -sdBox(p + vec3(0, 0.85, 0), vec3(1, 0.4, 1)));\n    obj_hit = d < threshold && obj_hit < 0 ? BENDER : obj_hit;\n    \n    float newd = max(d, -teeth(p));\n    obj_hit = newd < threshold && newd > d ? TEETH : obj_hit;\n    d = newd;\n    \n    d = min(d, antenna(p)); \n    obj_hit = d < threshold && obj_hit < 0 ? BENDER : obj_hit;\n    \n    d = min(d, eyes(p, obj_hit));\n    \n    return d;\n}\n\nfloat scene(vec3 p, out int obj_hit){\n    obj_hit = -1;\n    float d;\n\n    //d = sdSphere(p, 2.0, vec3(0, 0, 0));\n    //obj_hit = d < threshold && obj_hit < 0 ? BENDER : obj_hit;\n    d = bender(p, obj_hit);\n    \n    d = min(d, light(p));\n    obj_hit = d < threshold && obj_hit < 0 ? LIGHT : obj_hit;\n\n    return d;\n}\n\nvec3 normal(vec3 p){\n    int obj_hit;\n    float dfdx = scene(p + vec3(EPSILON, 0, 0), obj_hit) - scene(p - vec3(EPSILON, 0, 0), obj_hit);\n    float dfdy = scene(p + vec3(0, EPSILON, 0), obj_hit) - scene(p - vec3(0, EPSILON, 0), obj_hit);\n    float dfdz = scene(p + vec3(0, 0, EPSILON), obj_hit) - scene(p - vec3(0, 0, EPSILON), obj_hit);\n    \n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nvec4 albedoCol(int material, vec3 n, vec3 v, vec3 p)\n{\n    vec4 albedo;\n    if(material == LIGHT)\n    {\n        albedo = vec4(1, 1, 1, 1);\n    }\n    else if(material == BENDER)\n    {\n        albedo = vec4(1.0, 0.82, 0.15, 1);\n    }\n    else if(material == TEETH)\n    {\n        bool black = mod(p.x, 0.2) <= 0.025 || mod(p.y, 0.2) <= 0.025;\n        albedo = black ? vec4(0.1, 0.1, 0.1, 1.0) : vec4(1, 1, 1, 1);\n    }\n    else if(material == EYES)\n    {\n        bool black = dot(n, -v) > 0.975;\n        albedo = black ? vec4(0, 0, 0, 1) : vec4(1, 1, 1, 1);\n    }\n    else\n    {\n        albedo = vec4(0, 0, 0, 1);\n    }\n    \n    return pow(albedo, vec4(2.2));\n}\n\nvoid materialProperties(int material, out float ka, out float kd, out float ks, out float rough, out float metallic,\n                       out vec2 refract_idx)\n{\n    if(material == BENDER)\n    {\n        ks = 0.8;\n        kd = 1.0;\n        ka = 0.2;\n        rough = (sin(iTime * 0.2) + 1.0) / 2.0;\n        metallic = 1.0;\n        refract_idx.x = 0.28;\n        refract_idx.y = 2.93;\n    }\n    else if(material == TEETH)\n    {\n        ks = 0.3;\n        ka = 0.1;\n        kd = 0.7;\n        rough = 0.5;\n        metallic = 0.5;\n        refract_idx.x = 1.5;\n        refract_idx.y = 1.0;\n    }\n    else if(material == EYES)\n    {\n        ks = 0.2;\n        ka = 0.2;\n        kd = 0.6;\n        rough = 0.75;\n        metallic = 0.5;\n        refract_idx.x = 1.5;\n        refract_idx.y = 1.0;\n    }\n    else\n    {\n        ks = 0.33;\n        ka = 0.33;\n        kd = 0.33;\n        rough = 1.0;\n        metallic = 0.0;\n        refract_idx.x = 1.5;\n        refract_idx.y = 0.0;\n    }\n}\n\nvec4 lambertian(vec4 albedo, vec3 l, vec3 n, float diffuse_power)\n{\n    return albedo * clamp(dot(-l, n), 0.0, 1.0) * diffuse_power / PI;\n}\n\n//rescaled schlick's approximation proposed by Lazanyi and Szirmay-Kalos which takes into account k\n//allows for a lot less fudging of f0\nvec3 schlicksApprox(vec3 h, vec3 v, vec2 refract_idx, vec3 spec_col)\n{\n    float numer = (refract_idx.x - 1.0) * (refract_idx.x - 1.0) + 4.0 * refract_idx.x * pow(1.0 - dot(h, -v), 5.0) + \n        refract_idx.y * refract_idx.y;\n    \n    float den = (refract_idx.x + 1.0) * (refract_idx.x + 1.0) + refract_idx.y * refract_idx.y;\n    \n    return numer / den * spec_col;\n}\n\nfloat trowbridgeReitz(vec3 h, vec3 n, float roughness)\n{\n    float rough2 = roughness * roughness;\n    float noh = clamp(dot(n, h), 0.0, 1.0);\n    float den = noh * noh * (rough2 - 1.0) + 1.0;\n    return rough2 / (PI * den * den);\n}\n\nfloat smith(vec3 v, vec3 l, vec3 n, float roughness)\n{\n    float nov = dot(-v, n);\n    float nol = clamp(dot(-l, n), 0.0, 1.0);\n    vec3 h = normalize(-l - v);\n    float voh = dot(-v, h);\n    float noh = dot(n, h);\n    \n    float g_min = min(nov, nol);\n    return clamp(2.0 * noh * g_min / voh, 0.0, 1.0);\n}\n\nvec4 cookTorrance(vec4 spec_col, vec3 l, vec3 n, vec3 v, float roughness, vec2 refract_idx, float spec_power)\n{\n    vec3 h = normalize(-l - v);\n    \n    vec3 fresnel = schlicksApprox(h, v, refract_idx, spec_col.rgb);\n    float ndf = trowbridgeReitz(h, n, roughness);\n    float geom_attenuation = smith(v, l, n, roughness);\n    \n    float nol = dot(n, -l);\n    float nov = dot(n, -v);\n    \n    vec3 power = fresnel * ndf * geom_attenuation / (4.0 * nol * nov) * nol;\n    \n    return vec4(spec_col.rgb * spec_power * power, spec_col.a);\n}\n\nfloat glow(float dist_to_light)\n{\n    float t = 1.0 - clamp(dist_to_light, 0.0, 0.2) / 0.2;\n    t *= t;\n    \n    return t;\n}\n\nfloat ao(vec3 p, vec3 n, float delta, float intensity)\n{\n    float r = 0.0;\n  \n    for(int i = 0; i < 2; i++)\n    {\n        float t = float(i) * delta;\n        vec3 d = n * t;\n        int obj_hit;\n        r += 1.0 / (1.0 + t) * (t - scene(p + d, obj_hit));\n    }\n    return max(0.0, 1.0 - intensity * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rotation = (iMouse.xy / iResolution.xy - 0.5) * 2.0;\n    mat4 transform = rotationMatrix(vec3(0, 1, 0), rotation.x) * rotationMatrix(vec3(1, 0, 0), rotation.y);\n\n    vec4 l_col = vec4(1, 1, 1, 1);\n    float max_light_dist = 20.0;\n\n    float smaller = min(iResolution.x, iResolution.y);\n    float x_half = iResolution.x / (smaller * 2.0);\n    float y_half = iResolution.y / (smaller * 2.0);\n    \n    vec3 rd = (transform * vec4(normalize(vec3(fragCoord.xy / smaller - vec2(x_half, y_half), 1.0)), 1)).xyz;\n    vec3 r0 = (transform * vec4(0, 0, -5, 1)).xyz;\n    \n    light_pos = (rotationMatrix(vec3(0, 1, 0), iTime * 0.5) * vec4(2, 1, 0, 1)).xyz;\n    \n    vec3 p;\n    float curr_dist = 1.0;\n    float dist_to_light = 99999.0;\n    fragColor = vec4(0, 0, 0, 0);\n    bool hit = false;\n    int obj_hit;\n    \n    for(int i = 0; i < 75; ++i){\n        threshold = EPSILON * curr_dist * 2.0;\n        p = rd * curr_dist + r0;\n        \n        float d = scene(p, obj_hit);\n        dist_to_light = min(dist_to_light, light(p));\n        \n        if(d < threshold){\n            hit = true;\n            break;\n        }\n        \n        curr_dist += d * 0.5;\n    }\n    \n    fragColor = pow(texture(iChannel0, -rd), vec4(2.2));\n    \n    if(hit)\n    {\n        vec3 n = normal(p);\n        vec3 ldir = normalize(p - light_pos);\n        float falloff = 1.0 - clamp(length(light_pos - p), 0.0, max_light_dist) / max_light_dist;\n\n        float rough;\n        float ks, ka, kd;\n        float metallic;\n        vec2 refract_idx;\n        materialProperties(obj_hit, ka, kd, ks, rough, metallic, refract_idx);\n\n        vec4 albedo = albedoCol(obj_hit, n, rd, p);\n        vec4 tinted = mix(vec4(1), albedo, metallic) * l_col;\n\n        //hack for rough ibl\n        vec3 reflected = reflect(-rd, n);\n        \n        vec4 highres = pow(texture(iChannel0, reflected), vec4(2.2));\n        vec4 lowres = pow(texture(iChannel1, reflected), vec4(2.2));\n        \n        vec4 env_col = mix(highres, lowres, rough) * tinted;\n\n        vec3 h = normalize(reflect(rd, n) - rd);\n        env_col.rgb *= schlicksApprox(h, rd, refract_idx, tinted.rgb);\n\n        vec4 ambient = ka * albedo;\n        vec4 diffuse = lambertian(albedo, ldir, n, falloff) * kd;\n        diffuse = mix(env_col, diffuse, 1.0 - metallic);\n\n        vec4 specular = cookTorrance(tinted, ldir, n, rd, rough, refract_idx, falloff * ks);\n        \n        float ambient_occ = ao(p, n, 0.1, 5.0);\n\n        fragColor = specular + diffuse + ambient;\n        fragColor *= ambient_occ;\n    }\n    \n    fragColor += glow(dist_to_light) * l_col;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"}]}