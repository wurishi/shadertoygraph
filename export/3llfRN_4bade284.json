{"ver":"0.1","info":{"id":"3llfRN","date":"1596189717","viewed":256,"name":"Dark","username":"kesson","description":"Tribute to Dark, the series.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","noise","fbm","warp","dark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Based on https://www.shadertoy.com/view/ttlyWB\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n    fragColor = col;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision mediump float;\n\n#define MAX_STEPS 100\n#define MAX_DIST 12.\n#define SURF_DIST .001\n#define GYROID_DETAILS 6\n\nmat2 rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b) {\n  vec3 st = p * s;\n\n  float lx = 1.0 + ((sin(iTime * 0.00576) * 0.5) + 0.5) * 0.25;\n  float ly = 1.0 + ((cos(iTime * 0.00565) * 0.5) + 0.5) * 0.25;\n\n  float ls = max(lx, ly);\n\n  return abs(dot(sin(st * lx), cos(st.zxy * ly)) - b) / (s * ls) - t;\n}\n\nvec3 transform(vec3 p) {\n  p.xy *= rotate(p.z * 0.1);\n  p.z -= iTime * 0.25;\n  p.y -= 0.3;\n  return p;\n}\n\nfloat GetDist(vec3 p) {\n  p = transform(p);\n\n  float s = 10.798;\n  float t = 0.03;\n  float b = 0.3;\n  float m = 0.5;\n\n  float s1 = 1.0 + ((sin(iTime * 0.01) * 0.5) + 0.5);\n  float g1 = sdGyroid(p, s1, 0.03, 1.5);\n\n  for (int i = 0; i < GYROID_DETAILS; i++) {\n    if (i <= 1)\n      g1 -= sdGyroid(p, s, t, b) * m;\n    else\n      g1 += sdGyroid(p, s, t, b) * m;\n    s *= 1.75;\n    m *= 0.75;\n  }\n\n  float d = g1 * 0.7;\n\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = GetDist(p);\n    dO += dS;\n    if (dO > MAX_DIST || abs(dS) < SURF_DIST)\n      break;\n  }\n\n  return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n  float d = GetDist(p);\n  vec2 e = vec2(.01, 0);\n\n  vec3 n = d - vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n\n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p), r = normalize(cross(vec3(0, 1, 0), f)),\n       u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u,\n       d = normalize(i);\n  return d;\n}\n\nvec3 bg(vec3 rd) {\n  vec3 col = vec3(0.0);\n  float t = iTime * 0.2;\n\n  float y = clamp(smoothstep(0.3, 1.0, rd.y * 0.5 + 0.5), 0.1, 1.0);\n  col += y * vec3(0.05, 0.05, 0.05) * 2.0;\n\n  return col;\n}\n\nvec3 getDiff(vec3 p, vec3 rd) {\n  vec3 n = GetNormal(p);\n  return reflect(rd, n);\n}\n\n// Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\nvoid camera(float cd, vec2 uv, float an, out vec3 ro, out vec3 rd) {\n  ro = vec3(cd * cos(an), cd * sin(0.0), cd * sin(an));\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n  rd = normalize(uv.x * uu + uv.y * vv + 2.0 * ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  vec3 col = vec3(0.0);\n\n  float t = iTime * 0.001;\n\n  uv += sin(uv * 20. + t) * .01;\n\n  float an = 3.1415 / 2.0; //-iTime * 0.05;\n\n  vec3 ro, rd;\n  float cd = 0.01;            // camera distance\n  camera(cd, uv, an, ro, rd); // get the camera\n\n  float d = RayMarch(ro, rd);\n\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 dr = getDiff(p, rd);\n\n        p = transform(p);\n\n        float dif = dot(n, normalize(vec3(0.0, 0.0, 1.0))) * .5 + .5;\n        col *= dif;\n        col += dif * 0.2;\n\n        float b = sdGyroid(p, 10.798, 0.03, 0.3);\n        col *= smoothstep(-0.05, 0.1, b);\n\n        float cw = -0.02 + smoothstep(0.0, -0.5, n.y) * 0.02;\n        float c = smoothstep(cw, -0.03, b);\n        float cc = 1.0 - (sdGyroid(p + t, 6.789, 0.03, 0.3) * 6.0);\n        float cc2 = 1.0 - (sdGyroid(p - t * 0.5, 3.789, 0.03, 0.3) * 2.0);\n        col += c * vec3(1.0, 0.4, 0.2) * cc * cc2 * 4.0;\n    }\n\n    col = mix(col, bg(rd), smoothstep(0.0, MAX_DIST, d));\n\n    float a = smoothstep(6.0, MAX_DIST * 0.5, d);\n    col = pow(col, vec3(0.75));\n\n  \tfragColor = vec4(col, a);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//  Blur  effect\n//  Edited  from  https://www.shadertoy.com/view/XdfGDH\n\nfloat  normpdf(in float  x,  in float  sigma)  {\n    return  0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2  uv = gl_FragCoord.xy / iResolution.xy;\n    \n    vec3  c = texture(iChannel0, uv).rgb;\n\n    //  grain  effect\n    float  strength = 10.0;\n    float  x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3  grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n    const int  mSize = 11;\n    const int  kSize = (mSize - 1) / 2;\n    float  kernel[mSize];\n    vec3  final_colour = vec3(0.0);\n\n    //create  the  1-D  kernel\n    float  sigma = 0.001 + texture(iChannel0, uv).w * 10.0;//7.0;\n    float  Z = 0.0;\n    for (int  j = 0; j <= kSize; ++j) {\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n    }\n\n    //get  the  normalization  factor  (as  the  gaussian  has  been  clamped)\n    for (int  j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read  out  the  texels\n    for (int  i = -kSize; i <= kSize; ++i) {\n        for(int  j = -kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize + j] * kernel[kSize + i] * texture(iChannel0, (gl_FragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n                }\n    }\n\n    vec3  c_step_1 = final_colour / (Z * Z);\n\n    vec3 c_step_2 = clamp(c_step_1, 0.0, 1.0);\n\n    // I don't like the image too clean\n    c_step_2 += grain * 1.0;\n\n    fragColor = vec4(c_step_2, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// KIFS Fractal\n// Thanks to The Art Of Code\n// https://www.youtube.com/watch?v=il_Qg9AqQkE\n\n#define PI 3.1415\n#define NUM_ITERATIONS 1\n\nvec2 getPolar(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvec2 st(vec2 uv) {\n    uv *= 1.15;\n    \n    vec3 col = vec3(0.0);\n    \n    uv.x = abs(uv.x);\n    uv.y += tan(0.833333* PI) * 0.5;\n    \n    vec2 n = getPolar(0.833333* PI);\n    uv -= n * max(0.0, dot(uv-vec2(0.5, 0.0), n)) * 2.0;\n    \n    n = getPolar(0.666666 * ((sin(iTime*0.1) * 0.5 + 0.5) * PI));\n    float scale = 1.0;\n    uv.x += 0.5;\n    for (int i = 0; i < NUM_ITERATIONS; i++) {\n        uv *= 3.0;\n        scale *= 3.0;\n       \tuv.x -= 1.5;\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0.0, dot(uv, n)) * 2.0;\n    }\n    \n    uv /= scale;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = texture(iChannel0, st(uv) + 0.25).rgb;\n\n    fragColor = vec4(col,1.0);\n\n}","name":"Buffer C","description":"","type":"buffer"}]}