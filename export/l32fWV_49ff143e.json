{"ver":"0.1","info":{"id":"l32fWV","date":"1729963398","viewed":339,"name":"Toon Leaves","username":"SL0ANE","description":" 在考虑像素画渲染的时候希望树叶的轮廓能被强调出来","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","cartoon","anime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LEAF_LENGTH 0.15\n#define LEAF_WIDTH 0.05\n#define LEAF_LENGTH_DELTA 0.02\n#define LEAF_WIDTH_DELTA 0.01\n\n#define BACKGROUND_COLOR vec4(0.9725, 0.9294, 0.8118, 1.0)\n\n#define LEAF_COLOR_0 vec3(0.7686, 0.7882, 0.3176)\n#define LEAF_COLOR_1 vec3(0.3176, 0.3490, 0.2901)\n\n// #define LEAF_COLOR_0 vec3(0.8471, 0.4, 0.3725)\n// #define LEAF_COLOR_1 vec3(0.3490, 0.2431, 0.3255)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y + vec2(iResolution.x / iResolution.y * -0.5, -0.5);\n    float col = 0.0;\n    float dis = 65535.0;\n    \n    float phi = 3.14159265359 * (3.0 - sqrt(5.0));\n    int numPoints = 128;\n    \n    float leafSpin = iTime * 0.1;\n    vec3 normal = vec3(1.0);\n    int id = -1;\n    \n    for (int i = 0; i < numPoints; ++i) {\n    \n        float y = 1.0 - float(i) / float(numPoints - 1) * 2.0;\n        float r = sqrt(1.0 - y * y);\n        float theta = float(i) * phi;\n\n        vec3 originalCenter = vec3(cos(theta) * r, y, sin(theta) * r);\n        vec3 offset = perlin(originalCenter, vec3(8.0), vec3(65535.0), vec3(0.0)) * originalCenter;\n        originalCenter += offset * 0.8;\n        vec3 center = originalCenter / 4.0f;\n        \n        float leaveLength = (hash13(center) - 0.5 * 2.0) * LEAF_LENGTH_DELTA + LEAF_LENGTH;\n        float leaveWidth = (hash13(center + vec3(0.2, 0.3, 0.7)) - 0.5 * 2.0) * LEAF_WIDTH_DELTA + LEAF_WIDTH;\n\n        float cosSpin = cos(leafSpin);\n        float sinSpin = sin(leafSpin);\n        float newX = center.x * cosSpin - center.z * sinSpin;\n        float newZ = center.x * sinSpin + center.z * cosSpin;\n        center.x = newX;\n        center.z = newZ;\n        \n        vec2 dir = normalize(mix(normalize(center.xy), vec2(0.0, -1.0), 0.32)); \n        float sdf = sdOrientedVesica(uv, center.xy + leaveLength / 2.0 * dir, center.xy - leaveLength / 2.0 * dir, leaveWidth);\n        \n        if(sdf <= 0.0f && center.z < dis)\n        {\n            dis = center.z;\n            col = center.z * 2.0 + 0.5;\n            id = i;\n            normal = normalize(originalCenter);\n        }\n    }\n    \n    if(id == -1)\n    {\n        fragColor = BACKGROUND_COLOR;\n        return;\n    }\n    \n    float lightSpin = iTime * -1.5 + 2.0;\n    vec3 lightDir = normalize(vec3(cos(lightSpin), -1, sin(lightSpin)));\n    \n    float ndotl = dot(-lightDir, normal);\n    ndotl *= smoothstep(0.8, 0.6, col);\n    ndotl = clamp(ndotl, 0.0, 1.0);\n    ndotl = pow(ndotl, 1.0 / 2.2);\n    ndotl += hash13(normal + vec3(0.1, 0.2, 0.8)) / 4.0;\n    ndotl = floor(ndotl * 4.0) / 4.0;\n    ndotl = clamp(ndotl, 0.0, 2.0);\n    \n    if(hash13(normal + vec3(0.3, 0.2, 0.7)) > 0.9) ndotl += 1.0 / 4.0;\n    \n    vec3 outputColor = mix(LEAF_COLOR_1, LEAF_COLOR_0, ndotl);\n    \n    fragColor = vec4(outputColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"uint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat perlin(vec3 p, vec3 freq, vec3 rep, vec3 offset)\n{\n    p += offset / freq;\n    p *= freq;\n    vec3 gridSet = floor(p) + vec3(0.0, 0.0, 0.0);\n    vec3 dirSet = fract(p) - vec3(0.0, 0.0, 0.0);\n    // 必要时保证噪声在连接处连续\n    gridSet = mod(gridSet, rep * freq);\n    \n    vec3 gridLevel_000 = hash33(gridSet);\n    vec3 gridLevel_001 = hash33(gridSet + vec3(0.0, 0.0, 1.0));\n    vec3 gridLevel_010 = hash33(gridSet + vec3(0.0, 1.0, 0.0));\n    vec3 gridLevel_011 = hash33(gridSet + vec3(0.0, 1.0, 1.0));\n    vec3 gridLevel_100 = hash33(gridSet + vec3(1.0, 0.0, 0.0));\n    vec3 gridLevel_101 = hash33(gridSet + vec3(1.0, 0.0, 1.0));\n    vec3 gridLevel_110 = hash33(gridSet + vec3(1.0, 1.0, 0.0));\n    vec3 gridLevel_111 = hash33(gridSet + vec3(1.0, 1.0, 1.0));\n    \n    float product_000 = dot(gridLevel_000, dirSet);\n    float product_001 = dot(gridLevel_001, dirSet - vec3(0.0, 0.0, 1.0));\n    float product_010 = dot(gridLevel_010, dirSet - vec3(0.0, 1.0, 0.0));\n    float product_011 = dot(gridLevel_011, dirSet - vec3(0.0, 1.0, 1.0));\n    float product_100 = dot(gridLevel_100, dirSet - vec3(1.0, 0.0, 0.0));\n    float product_101 = dot(gridLevel_101, dirSet - vec3(1.0, 0.0, 1.0));\n    float product_110 = dot(gridLevel_110, dirSet - vec3(1.0, 1.0, 0.0));\n    float product_111 = dot(gridLevel_111, dirSet - vec3(1.0, 1.0, 1.0));\n    \n    float t_0 = pow(dirSet.x, 3.0) * (6.0 * pow(dirSet.x, 2.0) - 15.0 * dirSet.x + 10.0);\n    float t_1 = pow(dirSet.y, 3.0) * (6.0 * pow(dirSet.y, 2.0) - 15.0 * dirSet.y + 10.0);\n    float t_2 = pow(dirSet.z, 3.0) * (6.0 * pow(dirSet.z, 2.0) - 15.0 * dirSet.z + 10.0);\n    \n    float mix_x0 = mix(product_000, product_100, t_0);\n    float mix_x1 = mix(product_010, product_110, t_0);\n    float mix_y0 = mix(mix_x0, mix_x1, t_1);\n    \n    float mix_x2 = mix(product_001, product_101, t_0);\n    float mix_x3 = mix(product_011, product_111, t_0);\n    float mix_y1 = mix(mix_x2, mix_x3, t_1);\n    \n    return mix(mix_y0, mix_y1, t_2);\n}\n\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w )\n{\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n}","name":"Common","description":"","type":"common"}]}