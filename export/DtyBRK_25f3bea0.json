{"ver":"0.1","info":{"id":"DtyBRK","date":"1702246325","viewed":29,"name":"Pointalism Concept 2","username":"roey_shap","description":"Uncomment line 38 for strange results. Playing with it, pretty interesting water colory results.\n¯\\_(ツ)_/¯","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SNAP_VALUE 0.025\n#define INV_SQRT_2 0.70710678118\n#define timeScale 10.0\n\nvec2 roundTo(vec2 val, float snapVal)\n{\n    return round(val / snapVal) * snapVal;\n}\n\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\n// 'Marsaglia's xorshf generator' from https://stackoverflow.com/questions/1046714/what-is-a-good-random-number-generator-for-a-game\nint xorshf96(int val) {          //period 2^96-1\n    int x=123456789 + val, y=362436069-val, z=521288629*val;\n    int t;\n    x ^= x << 16;\n    x ^= x >> 5;\n    x ^= x << 1;\n\n   t = x;\n   x = y;\n   y = z;\n   z = t ^ x ^ y;\n\n  return z;\n}\n\n\nfloat pseudoRandom(vec2 uv)\n{\n    //return fract(float(xorshf96(int(((uv.x * sin(iTime)) + (cos(iTime * cos(iTime + uv.y)))) * 100.0))) / map(-1.0, 1.0, sin(iTime), 2.0, 4.0));\n    return map(0.0, 10.0 - 1.0, float(int(fract(uv.x * 0.4695 * cos(sin(exp(-iTime - uv)) * uv.y * 100.0)) * 100.0) % int(sin(map(-1.0, 1.0, sin(iTime / 100.0), 0.4, 10.0) + (10.0 * uv.x) + 2.0 * uv.y * iTime) * 10.0)), 0.0, 1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float smallerAxisValue = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / smallerAxisValue;\n    float posRanOffset = map(0.0, 1.0, pseudoRandom(1.0 - uv), -1.0, 1.0) * 0.005;\n    uv += posRanOffset * 2.0;\n    //vec2 uvCenter = (fragCoord - 0.5 * iResolution.xy) / smallerAxisValue;\n//the goal is to make dots, we need to \"floor to\" in a radial manner\n    vec2 targetUV = roundTo(uv, SNAP_VALUE);        \n    vec3 sampleColor = texture(iChannel0, targetUV).rgb;\n    vec3 col = vec3(1.0);\n    float timeLerpValue = map(-1.0, 1.0, sin(iTime), 0.0, 1.0); //clamp(map(0.0, 60.0 / timeScale, iTime, 0.0, 1.0), 0.0, 1.0);\n    float pointRadius = mix(0.0, map(0.0, 1.0, pseudoRandom(targetUV), 0.5, 1.0) * SNAP_VALUE * INV_SQRT_2, timeLerpValue);\n            //mix(SNAP_VALUE, map(0.0, 1.0, pseudoRandom(targetUV), 0.0, 0.5), timeLerpValue);\n    float strengthFromCenter = exp(-length(uv - targetUV));\n    col = mix(col, sampleColor, strengthFromCenter);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}