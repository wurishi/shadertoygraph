{"ver":"0.1","info":{"id":"wtSGzc","date":"1560474505","viewed":1018,"name":"infinite webcam","username":"cmarangu","description":"webcam code credit to https://www.shadertoy.com/view/Msl3zB\n\nall other code credit to me from scratch >:D","likes":9,"published":1,"flags":2,"usePreview":0,"tags":["fractal","webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n///*\n// Conformal Map Version\n// 2023 April 15th\n\n#define arg mod(float(iFrame)/30., 1.)\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307816\n// i know more\n#define TAU (2.*PI)\n\n\n// conformap transforms\n\n#define complex_exp(z) vec3(exp(z.x)*vec2(cos(z.y), sin(z.y)), floor(z.y/TAU) )\n#define complex_ln(Z) vec3(\\\n\tlog(length(Z.xy)),\\\n\tmod(atan(Z.y, Z.x), TAU)+Z.z*TAU,\\\n\tZ.z\\\n)\n\nvec3 complex_multZK (vec3 z, vec3 k) {\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\tfloat ph = mod(atan(k.y, k.x), TAU)+z.z*TAU;\n\treturn vec3(\n\t\t(length(z.xy)*length(k.xy))*vec2(cos(th+ph), sin(th+ph)),\n\t\tfloor(th/TAU+ph/TAU)\n\t);\n}\n\nvec3 complex_powZK (vec3 z, vec3 k) {\n\tfloat th = mod(atan(z.y, z.x), TAU)+z.z*TAU;\n\treturn vec3(\n\t\tpow(length(z.xy), k.x)*vec2(cos(th*k.x), sin(th*k.x)),\n\t\tfloor(th*k.x/TAU)\n\t);\n}\n\n\n#define scl (10./TAU*vec2(iResolution.y/iResolution.x, 1.))\n#define zoom .5\n#define pan vec2(0., 0.)\n\nvec3 inv_f (vec3 z) {\n    //\n    z.xy -= pan;\n    z.xy /= zoom;\n    //\n    z = complex_multZK(z, vec3(1., 1., 0.));\n    //\n    #if 1\n    // mobius\n    z = complex_multZK(\n        z - vec3(1., 0., 0.),\n        complex_powZK(z - vec3(-1., 0., 0.), vec3(-1., 0., 0.))\n    );\n    #endif\n    \n    #if 0\n    // complex tangent\n    // 2i*z then e^z then blah\n    // tan(z) = blah(  iz-i/-z-1  )\n    z = complex_multZK(z, vec3(0., 2., 0.));\n    z = complex_exp(z);\n    phaselvl[lvli] = z.z;\n    ++lvli;\n    z = complex_multZK(\n    \tvec3(0., -1., 0.)+complex_multZK(z, vec3(0., 1., 0.)),\n    \tcomplex_powZK(\n    \t\tvec3(-1., 0., 0.)+complex_multZK(z, vec3(-1., 0., 0.)),\n    \t\tvec3(-1., 0., 0.)\n    \t)\n    );\n    phaselvl[lvli] = z.z;\n    ++lvli;\n    #endif\n    \n    #if 1\n    z = complex_ln(z);\n    //z.xy = vec2(z.x-z.y, z.x+z.y);\n    #endif\n    //\n    z.xy *= scl;\n    //\n    z = complex_multZK(z, vec3(1., 3., 0.));\n    //\n    z.x += arg;\n    //\n    //\n    return z;\t\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = vec2(fragCoord-iResolution.xy/2.)/iResolution.y;\n    //vec3 z = inv_f(vec3(screen.x, screen.y, 0.));\n    vec3 z = inv_f(vec3(screen.x, screen.y, 0.));\n    z.x = fract(z.x); z.y = fract(z.y);\n    //\n    //fragColor.rgb = vec3(min(z.x, z.y), z.x, max(z.x, z.y));\n    //fragColor.rgb = texture(iChannel0, screen.xy*vec2(1.,iResolution.x/iResolution.y)).rgb;\n    fragColor.rgb = texture(iChannel0, z.xy).rgb;\n    fragColor = vec4(fragColor.rgb, 1.);\n}\n\n/**/\n\n\n\n\n\n\n/*\n// transverse mercator version\n// 2020 2/19\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307816406286\n// i know more\n\nfloat sech (float x) {\n    return 2.*cosh(x)/(cosh(2.*x)+1.);\n}\nvec2 inv_f (vec2 z) {\n    // inverse transverse mercator\n    // thanks wikipedia\n    z = vec2(z.y, z.x+iTime*.2)*3.;\n    z = vec2(\n        atan(sinh(z.x)/cos(z.y)),\n        asin(sech(z.x)*sin(z.y))\n    )/PI*4.;\n    z = vec2(z.x+z.y, z.x-z.y);\n    return vec2(fract(z.x), fract(z.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord-iResolution.xy/2.)/iResolution.y*2.;\n    vec2 z = inv_f(screen);\n    // vec3 retina = vec3(min(z.x, z.y), z.x, max(z.x, z.y));\n    vec3 retina = texture(iChannel0, inv_f(screen)).rgb;\n    fragColor = vec4(retina, 1.);\n}\n/**/\n\n// old (fractal) version (scroll down for others)\n// made 2019 9/8 I think\n// see https://www.shadertoy.com/view/WljGRh\n/*\n\n\n// set it equal to (subdivisions-2)/subdivisions\nfloat shrink = 5.0/7.0;\n\n// typically an integer from 1 to ∞\nint subdivisions = 7;\n\nvec3 col(vec2 p) {\n    p.x = mod(p.x+1e3, 1.0);\n    p.y = mod(p.y+1e3, 1.0);\n    float zx = log(abs(p.x*2.0-1.0))/log(shrink);\n    float zy = log(abs(p.y*2.0-1.0))/log(shrink);\n    \n    float t = mod(iTime, 1.0);\n    \n    float z = min(zx, zy);\n    z = z+t;\n    \n    float x0 = 1.0/2.0-pow(shrink, floor(z))*1.0/2.0;\n    float px = (abs(p.x)-x0)*pow(1.0/shrink, floor(z));\n    \n    float y0 = (1.0/2.0)*(1.0-pow(shrink, floor(z)));\n    float py = (abs(p.y)-y0)*pow(1.0/shrink, floor(z));\n    \n    px = 0.5+(px-0.5)*pow(shrink, t);\n    py = 0.5+(py-0.5)*pow(shrink, t);\n    \n    vec2 p2 = vec2(\n        mod(abs(px*float(subdivisions)), 1.0),\n        mod(abs(py*float(subdivisions)), 1.0)\n    );\n    \n    return texture(iChannel0, p2).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // Output to screen\n    fragColor = vec4(col(uv),1.0);\n    \n\n}\n\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n// circle inversion version\n// see https://www.shadertoy.com/view/3lXXR8\n/*\nvec2 invrted(vec2 p, vec2 cc, float cr) {\n\tfloat r2 = cr*cr/length(p-cc);\n\treturn cc+r2*vec2(p-cc)/length(p-cc);\n}\n\nvec3 col(vec2 p) {\n    p.x = mod(p.x+1000.0+iTime*0.3*.0, 1.0);\n    p.y = mod(p.y+1000.0+sin(iTime)*0.0, 1.0);\n    float th = sin(atan(p.y-0.5, p.x-0.5)*2.0)/2.0+0.5;\n    float rd = length(vec2(p.x-0.5, p.y-0.5));\n    // th = p.x;\n    // rd = p.y;\n    return texture(iChannel0, p).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.x;\n    \n    vec2 maus = (iMouse.xy-iResolution.xy/2.0)/iResolution.x;\n    \n    vec2 p = invrted(\n        uv,\n        maus,\n        length(maus)*length(maus)*12.0\n    );\n    \n    // Output to screen\n    fragColor = vec4(col(p),1.0);\n    \n\n}\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n// old (tunnel) version\n// see https://www.shadertoy.com/view/3t2GR1\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.1415926;\n    // 535897932384626433832795028841971693993751058209749\n    // ima bit rusty i know 370ish digits\n\tfloat squish = 1.0;\n    float squash = 1.1;\n    vec2 center = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    vec2 xy = vec2(\n        (fragCoord.x-center.x)/squash,\n    \t(fragCoord.y-center.y)/squish\n    );\n    \n    // ↓ for convenience\n    float x = xy.x;\n    float y = xy.y;\n    \n    float zr = iTime+500.0/sqrt(x*x+y*y);\n    float zt = mod(3.1415*2.0+1.0*atan(y,x), 3.141*2.0);\n    \n    // it makes it be all checkerboardy\n    float czk1 = 1.0/PI;\n    float czk2 = 30.0/PI;\n    // zr = floor(zr*czk1)/czk1;\n    // zt = floor(zt*czk2)/czk2;\n    \n    float parx = 0.5 + 0.5*cos(zt*16.0+zr);\n    float pary = 0.5 + 0.5*cos(zt*16.0+zr*16.0);\n    \n    float t1 = 2.0/3.0;\n    float t2 = 4.0/9.0;\n    parx = mod(zr*1.0+zt, PI*t1)/PI/t1;\n    pary = mod(zt+zt, PI*t2)/PI/t2;\n    \n    // a differet textrue thingy\n    // parx = mod(zt*12.0+zr*6.0, PI*2.0)/PI/2.0;\n    // pary = mod(zt*6.0+zr, PI*2.0)/PI/2.0;\n    \n    \n    // ugly black fog at the horizon. yuck.\n    // float fog = 5.0;\n    \n    // if (abs(y)<fog) {\n    //     parx = parx*sqrt(y/fog);\n    //     pary = pary*sqrt(y/fog);\n    // }\n    \n    // vec3 col = vec3(min(parx, pary), parx, max(parx, pary));\n\tvec3 col = texture(iChannel0, vec2(parx, pary)).xyz;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n/**/","name":"Image","description":"","type":"image"}]}