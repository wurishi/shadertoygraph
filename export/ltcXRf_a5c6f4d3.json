{"ver":"0.1","info":{"id":"ltcXRf","date":"1480822910","viewed":1603,"name":"Exploding Star.","username":"slembcke","description":"Hacking on Duke's Dusty Nebula 4: https://www.shadertoy.com/view/MsVXWW\n\nI wanted to experiment with changing the raymarching scheme a bit. Ended up adding a star, and making it more explodey. Might try adding self occlusion next.","likes":77,"published":1,"flags":0,"usePreview":1,"tags":["nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hacked up version of https://www.shadertoy.com/view/MsVXWW\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n//=====================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p){\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++){\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p){\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++){\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p){\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz); // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123 + 100.0)*4.0; // large scale features\n    final -= SpiralNoise3D(p); // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p){\n\tR(p.xz, iTime*0.4);\n    \n    float r = length(p);\n    float star = r + 0.5;\n    float noise = 1.0 + pow(abs(NebulaNoise(p/0.5)*0.5), 1.5);\n    return mix(star, noise, smoothstep(0.45, 1.5, r) - smoothstep(2.0, 3.0, r));\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far){\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif(delta < 0.0) return false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nconst vec3 starColor = vec3(1.0, 0.5, 0.25);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.0));\n\tvec3 ro = vec3(0.0, 0.0, -4.0);\n\t\n    const float rot = 0.01;\n    R(rd.yz, -iMouse.y*rot);\n    R(rd.xz,  iMouse.x*rot);\n    R(ro.yz, -iMouse.y*rot);\n    R(ro.xz,  iMouse.x*rot);\n\t\n    int steps = 0;\n    const int max_steps = 64;\n    const float max_advance = 1.0;\n    \n    float t = 0.0;\n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist)){\n        float dither = 0.5 - 1.5*texture(iChannel0, fragCoord.xy/256.0).r;\n        t = min_dist + max_advance*dither;\n\n        for(int i = 0; i < max_steps; i++){\n            if(sum.a > 0.95 || t > max_dist) break;\n            \n            vec3 pos = ro + t*rd;\n            float dist = map(pos);\n\t\t\tfloat advance = clamp(0.05*dist, 0.01, max_advance);\n            \n            float density = max(1.2 - dist, 0.0);\n            vec3 emit = starColor*(110.0*advance*density/dot(pos, pos));\n            float block = 1.0 - pow(0.05, density*advance/0.05);\n            sum += (1.0 - sum.a)*vec4(emit, block);\n\n            t += advance;\n            steps = i;\n        }\n\n\t}\n\t\n//    fragColor = vec4(vec3(smoothstep(min_dist, max_dist, t)), 1.0); return;\n//    fragColor = vec4(vec3(sum.a), 1.0); return;\n//    fragColor = vec4(vec3(float(steps)/float(max_steps)), 1.0); return;\n    \n    sum.rgb = pow(sum.rgb, vec3(2.2));\n    sum.rgb = sum.rgb/(1.0 + sum.rgb);\n    fragColor = vec4(sum.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}