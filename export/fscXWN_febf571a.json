{"ver":"0.1","info":{"id":"fscXWN","date":"1633106210","viewed":82,"name":"Coast","username":"1rosehip","description":"Coast","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define NUM_LAYERS 5.0\n#define NUM_OCTAVES 5\n\n\nmat2 getRotationMatrix(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s,\n                s, c);\n}\n\n\nfloat random(vec2 pos) {\n    pos = fract(pos * vec2(123.34, 456.21));\n    pos += dot(pos, pos + 45.32);\n    return fract(pos.x * pos.y);\n}\n\n\nfloat circle(vec2 uv, float radius, float smoothThickness){\n    return smoothstep(radius - smoothThickness, radius + smoothThickness, length(uv));\n}\n\n\nfloat createDrop(vec2 uv, float width) {\n    float soft = 0.0;\n    float drop = circle(uv, 0.1, 0.001);\n    return 1.0 - drop;\n}\n\nvec3 createLayer(vec2 uv){\n    vec3 result = vec3(0);\n    vec2 copies = fract(uv);\n    vec2 index = floor(uv);\n    for(float y=-1.0; y<=1.0; y++) {\n    \tfor(float x=-1.0; x<=1.0; x++) {\n            vec2 offset = vec2(x, y);\n    \t\tfloat rnd = random(index + offset);\n            float size = fract(rnd * 345.32);\n            float drop = createDrop(copies - offset - vec2(rnd, fract(rnd * 34.0)) + 0.5, 0.005);\n            result += drop * size * vec3(0.4706, 0.4706, 0.4706);\n        }\n    }\n\n    return result;\n}\n\n\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n    if(aspect > 1.0) {\n        uv-= 0.5;\n        uv.x *= aspect;\n        uv+= 0.5;\n    }\n    if(aspect < 1.0) {\n        uv-= 0.5;\n        uv.y *= 1.0 / aspect;\n        uv+= 0.5;\n    }\n\n   \n    float time = iTime * 0.01;\n    vec3 color = vec3(0.0275, 0.0275, 0.2902);\n    mat2 matr = getRotationMatrix(10.0 * 3.14 / 180.0);\n    uv = (matr * (uv - 0.5)) + 0.5;\n    float strength = smoothstep(0.2, 1.0, uv.y);\n\n    vec2 surface = strength * vec2(\n        mix(-0.3, 0.3, fbm(8.0 * uv + iTime * 0.1)), \n        mix(-0.3, 0.3, fbm(1.5 * uv + iTime * 0.1))\n    );\n    uv = refract(vec2(0.0), surface, 1.0 / 1.333);\n    \n    for(float i=0.0; i<1.0; i += 1.0 / NUM_LAYERS) {\n        float depth = fract(i);\n        float scale = mix(55.0, 10.0, depth);\n        vec2 offset = vec2(0.0, mod(time, 1000.0) * (depth + 0.3) * 0.6);\n        vec3 layer = createLayer((uv + offset) * scale);\n        color = mix(color, vec3(1.0, 1.0, 1.0), layer);\n    }\n\n    fragColor = vec4(color, 1.0); \n}\n\n","name":"Image","description":"","type":"image"}]}