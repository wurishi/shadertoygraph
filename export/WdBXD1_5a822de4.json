{"ver":"0.1","info":{"id":"WdBXD1","date":"1553813838","viewed":1208,"name":"Dripping","username":"Squiggle","description":"A little for-fun shader I started working on a while back. All I can see is how many things I want to change and do differently... but, such is the curse of the artist, right?","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["dripping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TODO\n// - stop using SDF thickness to control ceiling thickness\n// - ceiling thickness based on where drips are instead of a sine wave\n// - simple paint drip transition shader fork\n// - motion phases: \n//    * drip grow - base drip y (bdy) from len to bounce, tapering to a min size\n//                - falling drip at bdy+n1 growing in size, tail tapering to min size at bdy+n1-n2\n//    * drip detach and recede when ( n1-n2 == bdy )\n//                - base drip recedes quickly, n1 increases & n2 decreases sharply and linearly\n\n\nconst float PI = 3.14159265359;\n\nfloat seed = 0.25;\n\nfloat dripDistance = 0.1;\nfloat density = 0.75;\n\nfloat bCurve = 1.5;\nfloat bFreq = 3.5;\nfloat bRange = 0.35;\n\nfloat fallSpeed = 6.0;\n\nfloat sdfWidth = 0.18;\n\n\nfloat rand( float x, float y ){\n    return texture( iChannel0, vec2(x,y) / (iResolution.x / iResolution.y) ).r;\n}\n\nfloat dripSDF( vec2 uv )\n{   \n    float s = sdfWidth * abs((1.0-uv.y)-0.75) + 0.05;\n    float o = 1.0;\n    float drip = 999.0;\n    \n    float x = uv.x - sdfWidth;\n    x += dripDistance - mod(x, dripDistance);\n    \n    x -= dripDistance; //ungh... this is dirty... I'll fix it later\n    for( int i=0; i<1000; i++ )\n    {\n        if( x > uv.x + sdfWidth ) break;\n        \n        x += dripDistance;\n        float isLine = round(rand(x, seed) + density-0.5);\n        if( isLine == 0.0 ) continue;\n        \n        float y = rand(seed,x) * 0.8 + 0.1;\n        //y *= abs(sin(x*3.0))*0.5 + 0.5;\n        float animTime = iTime+(y*10.0);\n        float bounce = 0.0 - (bCurve * mod(animTime, bFreq)) * exp(1.0-bCurve*mod(animTime, bFreq));\n        y += bounce * bRange;\n        y = min(y,uv.y);\n        \n        float f = y + mod(animTime, bFreq) * fallSpeed * bRange;\n        \n        //float d = min( distance(vec2(x,y),uv), distance(vec2(x,f),uv) );\n        float d = distance(vec2(x,y),uv);\n        \n        o *= clamp(d/s,0.0,1.0);\n        drip = min( drip, distance(vec2(x,f),uv) );\n    }\n    \n    o = min( o, clamp(drip/s,0.0,1.0) );\n    \n    s = sin(uv.x*20.0+ iTime * 0.2)*0.3 + 0.4;\n    return o * clamp(distance(0.0, uv.y)/s,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y; //square\n    uv.y = 1.0 - uv.y; //flip\n    \n\tvec3 col = vec3(0.0); \n    \n    \n    float c = 1.0/sdfWidth * 0.025;\n    float w = 0.03;\n    \n    if( iMouse.z > 0.0 ){\n        density = iMouse.y/iResolution.y;\n        c = iMouse.x/iResolution.x;\n    }\n    \n    float d = dripSDF(uv);\n    \n \n    col.b = 1.0 - smoothstep( c - w, c + w, d );\n    //col.r = d;\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(rand(uv.x, uv.y));\n}","name":"Image","description":"","type":"image"}]}