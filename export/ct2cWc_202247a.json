{"ver":"0.1","info":{"id":"ct2cWc","date":"1692375609","viewed":108,"name":"Collision avoidance","username":"mfnch","description":"Use assisted braking to keep a ball inside an area rather than computing collisions with the walls. I may use this technique for a relativistic game. See https://relativisticgame.net/articles/dynamics-latency.html\n  Arrows: move\n  Space: stop","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2023 Matteo Franchin\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// INTRO\n// =====\n//\n// This is a simple attempt to implement a collision avoidance algorithm.\n// The idea is that, rather than handling the collisions of an object with its container,\n// the object automatically brakes to avoid collisions. This idea emerged after my struggles\n// implementing collisions for a relativistic rigid body with its environment.\n// Relativistic correct collisions involving a Born-rigid body are absolutely non-trivial to\n// implement and get right. They also lead anyway to a situation where the body can penetrate\n// the container's walls after acquiring sufficient speed. You can find more information\n// in a couple of articles I wrote:\n//\n//   - https://relativisticgame.net/articles/game-physics.html\n//   - https://relativisticgame.net/articles/dynamics-latency.html\n//\n// The solution, I hope, is to do what demoed in this little shadertoy example, that implements\n// the idea for classical mechanics. The body automatically brakes as necessary to avoid\n// the collisions. I describe the algorithm here:\n//\n//   - https://relativisticgame.net/articles/collision-avoidance.html\n//\n// You can fine-tune the parameters of the algorithm in the \"Common\" tab.\n//\n// This implementation is quite conservative. It reduces the maximum allowed speed close to the\n// walls. This causes the ball to get stuck in there. I think it is possible to improve this\n// issue by replacing the SDF description of the room with a function that provides the \"safe\"\n// speeds evaluated along different directions, thus allowing the player to accelerate also close\n// to the borders as long as the ball is far from a corner.\n//\n// CONTROLS\n// ========\n//\n// Use the arrows to move the ball, use the space bar to stop it.\n// The ball turns red to show how strongly the collision avoidance algorithm is braking.\n//\n// CHANGELOG\n// =========\n//\n// 2023-08-18: Initial version\n// 2023-08-21: Bugfix: clamp the acceleration after mix() so it never exceeds maxAcceleration\n\nvoid loadState(out State state) {\n  vec4 positionAndVelocity = texelFetch(iChannel0, ivec2(0, 0), /*LOD*/ 0);\n  state.position = positionAndVelocity.xy;\n  vec4 accelerationAndCriticality = texelFetch(iChannel0, ivec2(1, 0), /*LOD*/ 0);\n  state.criticality = accelerationAndCriticality.z;\n}\n\nvec3 drawWithBorder(vec3 bgColor, vec3 objectColor, float border, float pixelSize, float d) {\n  vec3 c = objectColor * (1.0 + 0.4 * smoothstep(border, border + pixelSize, -d));\n  return mix(c, bgColor, smoothstep(0.0, pixelSize, d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  float pixelSize = 4.0 / iResolution.y;\n\n  State state;\n  loadState(state);\n  vec2 ballPosition = state.position;\n\n  // Ball shadow\n  float shadow = 0.0;\n  const vec2 shadowDirection = vec2(1.0, -1.0) * (0.3 * ballRadius);\n  const vec2 shadowLength = ballRadius * vec2(0.75, 1.5);\n\n  shadow = 0.75 * smoothstep(shadowLength.y, shadowLength.x,\n                            length(uv - (ballPosition + shadowDirection)));\n\n  // Stage shadow\n  {\n    float d = sdStage(uv - shadowDirection);\n    shadow = max(shadow, (sdStage(uv) > 0.0) ? 0.5 * smoothstep(0.04, 0.0, d) : 0.0);\n  }\n\n  vec3 color = (1.0 - shadow) * vec3(0.25, 0.125, 0.25);\n\n  const float border = 0.015;\n\n  // Stage\n  {\n    float d = sdStage(uv);\n    color = drawWithBorder(color, vec3(0.5, 0.25, 0.5), border, pixelSize, d);\n  }\n\n  // Ball\n  {\n    float d = length(uv - ballPosition) - ballRadius;\n    vec3 ballColor = mix(vec3(1.0, 0.75, 0.25), vec3(1.0, 0.2, 0.0), state.criticality);\n    color = drawWithBorder(color, ballColor, border, pixelSize, d);\n  }\n\n  // Vignetting\n  vec2 q = fragCoord / iResolution.xy;\n  color *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.125);\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// See the \"Image\" tab for an introduction.\n\nconst float maxAcceleration = 10.0;\nconst float joystickAcceleration = 5.0;\nconst float ballRadius = 0.05;\nconst float repulsionStrength = 0.1;\nconst float repulsionBorder = 2.0 * ballRadius;\nconst float safetyFactor2 = 0.1;\n\nstruct State {\n  vec2 position;\n  vec2 velocity;\n  vec2 acceleration;\n  float criticality;\n};\n\n// From https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// SDF of the room where the ball can move.\n\nconst float centralRadius = 0.4;\nconst vec2 corridorSize = vec2(0.625, 0.15);\nconst vec2 roomsSize = vec2(0.375, 0.75);\n\n// Room layout: the SDF is not correct in the inside due to using min().\nfloat sdStageOutside(vec2 position) {\n  vec2 roomsCenter = vec2(corridorSize.x + roomsSize.x, 0.0);\n  float d = sdBox(abs(position) - roomsCenter, roomsSize);\n  d = min(d, sdBox(position, vec2(1.0, 0.15)));\n  d = min(d, length(position) - 0.4);\n  return -d;\n}\n\n// Same layout as above, but with accurate interior.\nfloat sdStageInside(vec2 position) {\n  vec2 p = abs(position);\n  float d = min(2.0 * roomsSize.x + corridorSize.x - p.x, roomsSize.y - p.y);\n  float x0 = sqrt(centralRadius * centralRadius - corridorSize.y * corridorSize.y);\n  d = min(d, sdBox(p - vec2(0.5 * (corridorSize.x + x0), roomsSize.y),\n                   vec2(0.5 * (corridorSize.x - x0), roomsSize.y - corridorSize.y)));\n  if (p.x <= x0) {\n    if (p.x * corridorSize.y - p.y * x0 < 0.0)\n      d = min(d, centralRadius - length(p));\n    else\n      d = length(p - vec2(x0, corridorSize.y));\n  }\n  return d;\n}\n\nfloat sdStage(vec2 position) {\n  float dInside = sdStageInside(position);\n  float dOutside = sdStageOutside(position);\n  return (dInside > 0.0) ? dInside : dOutside;\n}\n\nvec3 gradStage(vec2 position) {\n  float d = 0.001;\n  float s10 = sdStage(position + vec2(d, 0.0));\n  float s01 = sdStage(position + vec2(0.0, d));\n  float s00 = sdStage(position);\n  return vec3(s00, (s10 - s00) / d, (s01 - s00) / d);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MIT License\n// Copyright © 2023 Matteo Franchin\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// See the \"Image\" tab for introduction.\n// See the \"Common\" tab for the algorithm parameters.\n\nvoid loadState(out State state) {\n  vec4 positionAndVelocity = texelFetch(iChannel0, ivec2(0, 0), /*LOD*/ 0);\n  state.position = positionAndVelocity.xy;\n  state.velocity = positionAndVelocity.zw;\n  vec4 accelerationAndCriticality = texelFetch(iChannel0, ivec2(1, 0), /*LOD*/ 0);\n  state.acceleration = accelerationAndCriticality.xy;\n  state.criticality = accelerationAndCriticality.z;\n}\n\nvoid storeState(out vec4 fragColor, in vec2 fragCoord, in State state) {\n  ivec2 texelPosition = ivec2(fragCoord - 0.5);  // Subtract 0.5 to center exactly the sampling position.\n  fragColor = (texelPosition == ivec2(0, 0)) ? vec4(state.position, state.velocity) : fragColor;\n  fragColor = (texelPosition == ivec2(1, 0)) ? vec4(state.acceleration, state.criticality, 0.0) : fragColor;\n}\n\nvec2 getJoystick() {\n  const ivec2 kKeyLeft = ivec2(37, 0);\n  const ivec2 kKeyRight = ivec2(39, 0);\n  const ivec2 kKeyUp = ivec2(38, 0);\n  const ivec2 kKeyDown = ivec2(40, 0);\n  float horizontal =\n    (texelFetch(iChannel1, kKeyRight, /*LOD*/ 0).x -\n     texelFetch(iChannel1, kKeyLeft, /*LOD*/ 0).x);\n  float vertical =\n    (texelFetch(iChannel1, kKeyUp, /*LOD*/ 0).x -\n     texelFetch(iChannel1, kKeyDown, /*LOD*/ 0).x);\n  vec2 d = vec2(horizontal, vertical);\n  return d / max(0.01, length(d)); \n}\n\nbool getButton() {\n  const ivec2 kKeySpace = ivec2(32, 0);\n  return texelFetch(iChannel1, kKeySpace, /*LOD*/ 0).x != 0.0;\n}\n\n// This function takes the position, velocity and acceleration (from state)\n// and amends the acceleration (in state) to prevent collisions.\n// Approach: https://relativisticgame.net/articles/collision-avoidance.html\n// This implementation does not use dt, nor the gradient of the room's SDF.\n// Future implementations may do so...\nvoid collisionAvoidance(inout State state, in float dt) {\n  vec3 sdfAndGrad = gradStage(state.position);\n  float s = sdfAndGrad.x - ballRadius;\n\n  if (s <= 0.0) {\n    state.acceleration = repulsionStrength * sdfAndGrad.yz * maxAcceleration;\n    return;\n  }\n\n  float v2 = dot(state.velocity, state.velocity);\n  float maxV2 = 2.0 * s * maxAcceleration;\n  if (v2 < safetyFactor2 * maxV2)\n    return;\n\n  // criticality goes from 0 to 1 as the situation becomes more and more critical,\n  // i.e. close to the point where a collision with the walls is inevitable.\n  state.criticality = (v2 >= maxV2) ? 1.0 : ((v2 / maxV2 - safetyFactor2) / (1.0 - safetyFactor2));\n  vec2 correction = -maxAcceleration * normalize(state.velocity);\n  vec2 acceleration = mix(state.acceleration, correction, state.criticality);\n  \n  // Make sure the final acceleration doesn't exceed the allowed one.\n  float accelerationNorm = length(acceleration);\n  state.acceleration =\n    (accelerationNorm <= maxAcceleration) ?\n    acceleration : acceleration * (maxAcceleration / accelerationNorm);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  State state;\n  loadState(state);\n\n  float dt = iTimeDelta;\n  if (getButton()) {\n    state.velocity = vec2(0.0);\n    state.acceleration = vec2(0.0);\n  } else {\n    state.acceleration = joystickAcceleration * getJoystick();\n    collisionAvoidance(state, dt);\n  }\n  state.velocity += state.acceleration * dt;\n  state.position += state.velocity * dt;\n\n  storeState(fragColor, fragCoord, state);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}