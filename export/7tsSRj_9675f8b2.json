{"ver":"0.1","info":{"id":"7tsSRj","date":"1626104891","viewed":278,"name":"Star Stacks","username":"nr4","description":"Stacked stars similiar to the effect shown in \"Garlic Rulez\" by Team210 (1st in the combined PC-64k+4k compo at Underground Conference 11).\n","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","demoscene","voxel","spheretracing","stars","64k","team210"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Star Stacks\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst float fsaa = 144.;\nconst vec3 c = vec3(1.,0.,-1.);\nfloat scale,\n    alternateScale,\n    nbeats;\nconst float bpm = .5*149.,\n    spb =  60. / bpm;\nconst float tmax = 90.;\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sync tools\n    float stepTime = mod(iTime+.5*spb, spb)-.5*spb;\n    nbeats = (iTime-stepTime+.5*spb)/spb + smoothstep(-.2*spb, .2*spb, stepTime);\n    scale = smoothstep(-.3*spb, 0., stepTime)*smoothstep(.3*spb, 0., stepTime);\n    alternateScale = mix(smoothstep(-.4*spb, -.5*spb, stepTime),smoothstep(-.5*spb, -.4*spb, stepTime), mod(round((iTime-stepTime)/spb), 2.));\n\n    // SSAA\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*mix(3.,20.,2.*abs(fragCoord.y/iResolution.y-.5))*exp(-abs(1.e-2*length(fragCoord.xy)/iResolution.y-.5))/max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec2 uv2 = uv;\n    fragColor = vec4(1.2*col, 1.);\n    \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0;\n    vig = pow(vig, 0.2);\n    fragColor *= vig; \n\n    // team210 watermark\n    float d = d210(8.*(uv2-.5*vec2(iResolution.x/iResolution.y,1.)+vec2(.1,.04)));\n    fragColor.rgb = mix(fragColor.rgb, mix(fragColor.rgb, c.xxx, .5), sm(d));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Star Stacks\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = 3.14159,\n    PHI = 1.618,\n    bpm = .5*149.,\n    spb =  60. / bpm,\n    minimalTimeStep = spb/8.;\nmat3 RR = mat3(1.),\n    RRA = mat3(1.);\nfloat scale,\n    nbeats;\nconst float tmax = 80.521;\n\n// iq's smoothmin\nfloat smoothmin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smoothmax(float a, float b, float k)\n{\n    return a + b - smoothmin(a,b,k);\n}\n\nfloat zextrude(float z, float d2d, float h)\n{\n    vec2 w = vec2(d2d, abs(z)-0.5*h);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// iq's hexagon pattern\nvoid dhexagonpattern(in vec2 p, out float d, out vec2 ind) \n{\n    vec2 q = vec2( p.x*1.2, p.y + p.x*0.6 );\n    \n    vec2 pi = floor(q);\n    vec2 pf = fract(q);\n\n    float v = mod(pi.x + pi.y, 3.0);\n\n    float ca = step(1.,v);\n    float cb = step(2.,v);\n    vec2  ma = step(pf.xy,pf.yx);\n    \n    d = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n    ind = pi + ca - cb*ma;\n    ind = vec2(ind.x/1.2, ind.y);\n    ind = vec2(ind.x, ind.y-ind.x*.6);\n}\n\nmat3 rot3(in vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat mfnoise(vec2 x, float d, float b, float e)\n{\n    float n = 0.;\n    float a = 1., nf = 0., buf;\n    for(float f = d; f<b; f *= 2.)\n    {\n        n += a*lfnoise(f*x-2.*iTime);\n        a *= e;\n        nf += 1.;\n    }\n    return n * (1.-e)/(1.-pow(e, nf));\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6.0 - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cc.y);\n}\n\nvec3 rgb2hsv(vec3 cc)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g));\n    vec4 q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Distance to line segment\nfloat linesegment(in vec2 x, in vec2 p1, in vec2 p2)\n{\n    vec2 da = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n}\n\n// Distance to star\nfloat star(in vec2 x, in float r1, in float r2, in float N)\n{\n    N *= 2.;\n    float p = atan(x.y,x.x),\n        k = pi/N,\n    \tdp = mod(p+pi, 2.*k),\n    \tparity = mod(round((p+pi-dp)*.5/k), 2.),\n        dk = k,\n        dkp = mix(dk,-dk,parity);\n    \n    vec2 p1 = r1*vec2(cos(k-dkp),sin(k-dkp)),\n        p2 = r2*vec2(cos(k+dkp),sin(k+dkp)),\n        dpp = p2-p1,\n        n = normalize(p2-p1).yx*c.xz, \n        xp = length(x)*vec2(cos(dp), sin(dp));\n    float t = dot(xp-p1,dpp)/dot(dpp,dpp);\n    float r = mix(1.,-1.,parity)*dot(xp-p1,n);\n    if(t < 0.)\n        return sign(r)*length(xp-p1);\n    else if(t > 1.)\n        return sign(r)*length(xp-p2);\n    else\n\t    return r;\n}\n\n// Scene marching information\nstruct SceneData\n{\n    float\n\n        // Material for palette\n        material,\n    \n        // Distance\n        dist,\n    \n        // Light accumulation for clouds\n        accumulation,\n    \n        // Reflectivity\n        reflectivity,\n    \n        // Transmittivity\n        transmittivity,\n    \n        // Illumination\n        specular,\n    \n        // Diffuse\n        diffuse;\n};\n\nSceneData defaultMaterial(float d)\n{\n    return SceneData(1.3, d, 1., .1, .1, .5, 1.);\n}\n\nSceneData add(SceneData a, SceneData b)\n{\n    if(a.dist < b.dist) return a;\n    return b;\n}\n\nfloat rj;\n\nfloat holeSDF(vec3 x, float zj)\n{\n    float r = lfnoise(.5*nbeats*c.xx-zj),\n        s = lfnoise(.5*nbeats*c.xx+1337.-zj);\n        \n    // star effect\n    float ag = mix(2.,12.,.5+.5*r)*zj*r;\n    mat2 RB = mat2(cos(ag), sin(ag), -sin(ag), cos(ag));\n    float da = -abs(star(RB*(x.xy-vec2(r,s)*.5), abs(1.*r+.1*zj), abs(1.*s-.1*zj), round(5.+r+s)))+.05-.1*zj,\n        db = abs(mod(da, .2))-.09*2.1;\n    rj = da - db;\n    \n    return db;\n}\n\nSceneData scene(vec3 x)\n{\n    SceneData sdf = SceneData(0., x.z+.5, 0., 0., 0., .7, 1.);\n\n    float dz = .03,\n        z = mod(x.z, dz) - .5 * dz,\n        zj = x.z - z,\n        zjz = zj / dz;\n\n    if(zj <= 0.)\n    {\n        float d = zextrude(z, -holeSDF(x, zj), .5*dz)-.15*dz;\n        sdf = add(\n            sdf,\n            SceneData(-1.+3.*abs(zjz/.5*dz), d, 0., 0., 0., .7, 1.)\n        );\n    }\n\n    return sdf;\n}\n\nvec3 normal(vec3 x)\n{\n    float s = scene(x).dist,\n        dx = 5.e-5;\n    return normalize(vec3(\n        scene(x+dx*c.xyy).dist, \n        scene(x+dx*c.yxy).dist, \n        scene(x+dx*c.yyx).dist\n    )-s);\n}\n\nvec3 palette(float scale)\n{\n    const int N = 4;\n    vec3 colors[N] = vec3[N](\n        vec3(1.00,0.22,0.30),\n        c.yyy,\n        vec3(0.13,0.44,0.66),\n        vec3(0.00,0.80,0.73)\n    );\n    float i = mod(floor(scale), float(N)),\n        ip1 = mod(i + 1., float(N));\n    return mix(colors[int(i)], colors[int(ip1)], fract(scale));\n}\n\nbool ray(out vec3 col, out vec3 x, inout float d, vec3 dir, out SceneData s, vec3 o, vec3 l, out vec3 n)\n{\n    for(int i=0-min(iFrame, 0); i<250+min(iFrame,0); ++i)\n    {\n        x = o + d * dir;\n        s = scene(x);\n        \n        if(s.dist < 1.e-4) \n        {\n            // Blinn-Phong Illumination\n            n = normal(x);\n\n            if(s.material == 0.)\n            {\n                col = c.yyy;\n            }\n            else \n            {\n                col = palette(s.material+rj*10. - length(x.xy));\n            }\n\n            col = .2 * col\n                + s.diffuse * col*max(dot(normalize(l-x),n),0.)\n                + s.specular * col*pow(max(dot(reflect(normalize(l-x),n),dir),0.),2.);\n\n            return true;\n        }\n        \n        d += min(s.dist,s.dist>1.e0?1.e-2:5.e-3);\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rotation tools\n    RR = rot3(iTime*vec3(0.,0.,.6));\n    RRA = rot3(iTime*vec3(.7,.9,1.32));\n\n    // Sync tools\n    float stepTime = mod(iTime, spb)-.5*spb;\n    nbeats = .5*iTime;\n    scale = smoothstep(-.3*spb, 0., stepTime)*smoothstep(.3*spb, 0., stepTime);\n\n    // Marching tools\n    float d = 0.,\n        d1;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 o = RR*c.yzx,\n        col = c.yyy,\n        c1 = c.yyy,\n        x,\n        x1,\n        n,\n        n1,\n        r = RR*c.xyy,\n        t = c.yyy,\n        dir = normalize(uv.x * r + uv.y * cross(r,normalize(t-o))-o),\n        l = c.zzx;\n    SceneData s, \n        s1;\n\n    d = -(o.z)/dir.z;\n    x = o + d * dir;\n        \n    // Material ray\n    if(ray(col, x, d, dir, s, o, l, n))\n    {\n        s1 = s;\n        d1 = d;\n        n1 = n;\n        \n        // Ambient occlusion from iq\n        float occ = 0.;\n        for(int i=0; i<32; ++i)\n        {\n            float h = .01 + 4.0*pow(float(i)/31.0,2.0);\n            vec2 an = hash22( hash12(iTime*c.xx)*c.xx + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n            vec3 dir2 = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n            dir2 *= sign( dot(dir2,n) );\n            occ += clamp( 5.0*scene( x + h*dir2 ).dist/h, -1.0, 1.0);\n        }\n        col = mix(.5*col, col, clamp(occ/32.,0.,1.));\n        \n        // Soft shadow from iq\n        if(x.z <= .0)\n        {\n            // Soft Shadow\n            o = x;\n            dir = normalize(l-x);\n            d1 = 1.e-2;\n            \n            {\n                float res = 1.0;\n                float ph = 1.e20;\n                for(int i=0; i<150; ++i)\n                {\n                    x = o + d1 * dir;\n                    s = scene(x);\n                    if(s.dist < 1.e-4) \n                    {\n                        res = 0.;\n                        break;\n                    }\n                    if(x.z >= .0)\n                    {\n                        res = 1.;\n                        break;\n                    }\n                    float y = s.dist*s.dist/(2.0*ph)/12.;\n                    float da = sqrt(s.dist*s.dist-y*y);\n                    res = min( res, 100.0*da/max(0.0,d1-y) );\n                    ph = s.dist;\n                    d1 += min(s.dist,s.dist>5.e-1?1.e-2:5.e-3);\n                }\n                col = mix(.5*col, col, res);\n            }\n        }\n    }\n\n    s = s1;\n\n    // Color drift\n    if(s.material != 0.)\n    {\n        c1 = rgb2hsv(col);\n        c1.r = pi*lfnoise(.1*nbeats*c.xx);\n        col = mix(col, hsv2rgb(c1),.5);\n        \n        // Gamma\n        col = col + col*col + col*col*col;\n    }\n    \n    // Highlights\n    col = mix(col, mix(col, col + col*col + col*col*col,.5), smoothstep(.9, 1.4, abs(dot(c.xzx, n))));\n\n    fragColor = mix(texture(iChannel0, fragCoord.xy/iResolution.xy), vec4(clamp(col,0.,1.),1.), .5);\n}","name":"Buffer A","description":"","type":"buffer"}]}