{"ver":"0.1","info":{"id":"DdsGWj","date":"1666820589","viewed":131,"name":"Twirl and spiral transform","username":"Envy24","description":"Spiral transform source: https://www.shadertoy.com/view/mdf3Dj\nLeft: with atan, Right: without","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spiral","transforms","twirl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define PI                        ( 3.1415926535897932 )\n#define TX0(SC)                   ( texture(iChannel0, (SC/R.xy)) )\n\nvec2 twirl(vec2 NDC, vec2 C, float maxDistance, float phase)\n{\n    NDC -= C;\n\n    float length_ = length(NDC);\n    float alpha = atan(NDC.y, NDC.x) + phase * ((maxDistance - length_) / maxDistance);\n\n    return vec2(\n        length_ <= maxDistance ?\n            C.x + length_ * cos(alpha) :\n            C.x + NDC.x,\n        length_ <= maxDistance ?\n            C.y + length_ * sin(alpha) :\n            C.y + NDC.y);\n}\n\n// source: https://www.shadertoy.com/view/mdf3Dj\nvec2 spiral(vec2 NDC, vec2 C, float theta)\n{\n    NDC -= C;\n\n    float strength = 1. - length(NDC) * 0.5;\n\n    return vec2( \n        NDC.x * cos(theta * strength) - NDC.y * sin(theta * strength),\n        NDC.x * sin(theta * strength) + NDC.y * cos(theta * strength)\n       );\n}\n\nvec2 twirl_from_spiral(vec2 NDC, vec2 C, float maxDistance, float phase)\n{\n    NDC -= C;\n\n    float length_ = length(NDC),\n          strength = \n              length_ > maxDistance ?\n                  0. :\n                  (maxDistance - length_) / maxDistance,\n          c = cos(phase * strength),\n          s = sin(phase * strength);\n\n    return vec2( \n        NDC.x * c - NDC.y * s,\n        NDC.x * s + NDC.y * c\n       );\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    return ((2. * (SC - MOUSE_OFFSET) - R.xy) / R.y) * scale - origin;\n}\nvec2 unmap_from_centered_ndc(in vec2 NDC, in float scale, in vec2 origin)\n{\n    return ((((NDC + origin) / scale) * R.y) + R.xy) * 0.5 + MOUSE_OFFSET;       \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float x_origin = SC.x > R.x * 0.5 ? (AR-(2.*AR)/11.) : (-AR+(2.*AR)/11.) ;\n    vec2 NDC = map_to_centered_ndc(SC, 1.5, vec2(x_origin, 0));\n\n    float max_dist = 1., phase = iTime * 0.5;\n    NDC = \n        SC.x > R.x * 0.5 ?\n            twirl(NDC, vec2(0), max_dist, phase) :\n            //spiral(NDC, vec2(0), iTime);\n            twirl_from_spiral(NDC, vec2(0), max_dist, phase);\n            \n    SC = unmap_from_centered_ndc(NDC, 1., vec2(0));\n\n    O = TX0(SC);\n}","name":"Image","description":"","type":"image"}]}