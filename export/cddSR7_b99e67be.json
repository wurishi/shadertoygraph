{"ver":"0.1","info":{"id":"cddSR7","date":"1679581798","viewed":166,"name":"alien huds","username":"Carandiru","description":"procedural, randomized alien interface / hud generator ((cellular automata based)","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["volume","alien","automata","cellular","textture"],"hasliked":0,"parentid":"cdK3zV","parentname":"automata volume"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NlSyzW\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// procedural, randomized alien interface / hud generator ((cellular automata based)\n\n// -interpolated between t0 volume and t1 volume (smooth) \n// -time controllable\n// -volumetric data\n\n// -tweak speed and scale in common tab\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 t0 = textureLod(iChannel0, uv, 0.0f);\n    vec4 t1 = textureLod(iChannel1, uv, 0.0f);\n    \n    vec4 color = mix(t0, t1, mod(iTime, 4.0f));\n    color.rgb *= color.a;\n    \n    // color style\n    color.rgb = color.grb * vec3(1.0f, 0.15f, 0.35f);\n    // saturation\n    color.rgb *= color.rgb;\n    // flicker\n    color.rgb = mix(color.rgb * 0.15f, color.rgb * 2.0f, fract(iTime));\n    // inverse to orange\n    color.rgb = 1.0f - color.rgb;\n    \n    vec3 orig = color.rgb;\n    \n    // pixel grid\n    color.rgb *= abs(sin(uv.x * 10000.0f * iResolution.x/iResolution.y)); \n    color.rgb *= abs(sin(uv.y * 10000.0f)); \n    \n    // highlights\n    color.rgb += mix(vec3(0), pow(orig, vec3(5.0f)), smoothstep(0.5f, 1.0f, 1.0f - dot(orig, LUMA)));\n    \n    // gamma\n    color.rgb = pow(color.rgb, vec3(1.0f/2.2f));\n    \n    fragColor = vec4(color.rgb,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NlSyzW\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// procedural, randomized alien interface / hud generator ((cellular automata based)\n\n\n#define TTT (0.0)\n\n// 26 neighbours + self at i==13 (*compiletime* offset)\n#define next_neighbour_offset(i) (ivec3((i / 9) - 1, (i / 3 % 3) - 1, (i % 3) - 1))\n\n#define T(i) (nbr[i] = textureLodOffset(iChannel1, uvw, 0., next_neighbour_offset(i)).r)\n\nvec3 rand23(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rgb ); \n}\nvec2 rand22(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rg ); \n}\nint rand21(vec2 uv, float maxi){ \n\n   return( int(textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).r * maxi) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 unit = 1.0f / iChannelResolution[1].xyz;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float nbr[27] = float[27](0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f);\n\n    float state = 0.0f;\n    \n    vec3 uvw;\n    uv = uv * 2.0f - 1.0f;    \n    uvw = sqrt(vec3(uv.x*uv.x, uv.y*uv.y, 0.5f));\n    uvw = uvw * 0.5f + 0.5f;\n    uvw *= SCALE;\n    \n    vec3 color = vec3(0);\n    if ( iFrame < 32 ) {\n        state = textureLod(iChannel1, uvw + float(iFrame)*(1.0f/32.0f), 0.).r;\n    }\n    else {\n        vec4 samp = textureLod(iChannel0, uv, 0.0f);\n           \n        color = samp.xyz;\n        \n        // time controllable\n        state = mix(samp.w, textureLod(iChannel1, vec3(uvw.xy, uvw.z + (iTime + TTT) * SPEED), 0.).r, 0.5f);\n        color += state;\n    }\n    \n    // unrolled and compile time constant for offset generated. skip 13, self.\n    T(0);  T(1);  T(2);  T(3);  T(4);  T(5);  T(6);  T(7);  T(8);\n    T(9);  T(10); T(11); T(12); T(14); T(15); T(16); T(17); T(18);\n    T(19); T(20); T(21); T(22); T(23); T(24); T(25); T(26); // 26 texel\n    \n    nbr[13] = nbr[26]; // to iterate only neighbours in array - 1\n    \n    float count = 0.0f;\n    for (int i = 0 ; i < 26 ; ++i) {\n    \n        count += ceil(nbr[i] - 0.5f);\n    }\n        \n    if (state - 0.1f >= 0.0f) { // On is >= 0.5f\n    \n        if (0.0f == (count - 26.0f)) {\n            // completely surrounded, survive\n            color.b = 1.0f;\n        }\n        else {\n        \n            if (count - 1.0f >= 0.0f) { // have at least one non-empty neighbour\n              // do nothing, survive\n              state -= count / 26.0f * iTimeDelta;\n            }\n            else {\n                // die off\n                state = 0.0f;\n            }\n        }\n    }\n    else if (0.0f != (count - 26.0f)) { // not current on & has empty neighbour\n        // copy a neighbour \n        do {\n        \n            int n = max(0, int(count) - 1);\n            \n            if (nbr[n] - 0.5f >= state) { // On is >= current state\n                state = nbr[n];\n                color.g = state;\n                break; // found a neighbour to copy\n            }\n            \n            --count;\n        }\n        while(count >= 0.0f);\n    }\n\n    fragColor = vec4(color, state);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NlSyzW\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// procedural, randomized alien interface / hud generator ((cellular automata based)\n\n\n#define TTT (1.0)\n\n// 26 neighbours + self at i==13 (*compiletime* offset)\n#define next_neighbour_offset(i) (ivec3((i / 9) - 1, (i / 3 % 3) - 1, (i % 3) - 1))\n\n#define T(i) (nbr[i] = textureLodOffset(iChannel1, uvw, 0., next_neighbour_offset(i)).r)\n\nvec3 rand23(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rgb ); \n}\nvec2 rand22(vec2 uv){ \n\n   return( textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).rg ); \n}\nint rand21(vec2 uv, float maxi){ \n\n   return( int(textureLod(iChannel2, (uv * iResolution.xy) / 1024.0f, 0.0f).r * maxi) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 unit = 1.0f / iChannelResolution[1].xyz;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float nbr[27] = float[27](0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f);\n\n    float state = 0.0f;\n    \n    vec3 uvw;\n    uv = uv * 2.0f - 1.0f;    \n    uvw = sqrt(vec3(uv.x*uv.x, uv.y*uv.y, 0.5f));\n    uvw = uvw * 0.5f + 0.5f;\n    uvw *= SCALE;\n    \n    vec3 color = vec3(0);\n    if ( iFrame < 32 ) {\n        state = textureLod(iChannel1, uvw + float(iFrame)*(1.0f/32.0f), 0.).r;\n    }\n    else {\n        vec4 samp = textureLod(iChannel0, uv, 0.0f);\n           \n        color = samp.xyz;\n        \n        // time controllable\n        state = mix(samp.w, textureLod(iChannel1, vec3(uvw.xy, uvw.z + (iTime + TTT) * SPEED), 0.).r, 0.5f);\n        color += state;\n    }\n    \n    // unrolled and compile time constant for offset generated. skip 13, self.\n    T(0);  T(1);  T(2);  T(3);  T(4);  T(5);  T(6);  T(7);  T(8);\n    T(9);  T(10); T(11); T(12); T(14); T(15); T(16); T(17); T(18);\n    T(19); T(20); T(21); T(22); T(23); T(24); T(25); T(26); // 26 texel\n    \n    nbr[13] = nbr[26]; // to iterate only neighbours in array - 1\n    \n    float count = 0.0f;\n    for (int i = 0 ; i < 26 ; ++i) {\n    \n        count += ceil(nbr[i] - 0.5f);\n    }\n        \n    if (state - 0.1f >= 0.0f) { // On is >= 0.5f\n    \n        if (0.0f == (count - 26.0f)) {\n            // completely surrounded, survive\n            color.b = 1.0f;\n        }\n        else {\n        \n            if (count - 1.0f >= 0.0f) { // have at least one non-empty neighbour\n              // do nothing, survive\n              state -= count / 26.0f * iTimeDelta;\n            }\n            else {\n                // die off\n                state = 0.0f;\n            }\n        }\n    }\n    else if (0.0f != (count - 26.0f)) { // not current on & has empty neighbour\n        // copy a neighbour \n        do {\n        \n            int n = max(0, int(count) - 1);\n            \n            if (nbr[n] - 0.5f >= state) { // On is >= current state\n                state = nbr[n];\n                color.g = state;\n                break; // found a neighbour to copy\n            }\n            \n            --count;\n        }\n        while(count >= 0.0f);\n    }\n\n    fragColor = vec4(color, state);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\n#define SPEED (0.01111111 * GOLDEN_RATIO_ZERO) // order of magnitudes - lower values result in higher resolution, and vice versa   \n                       // the speed at which the scene animation is increased wih higher values, \"\"  \"\"  \"\"\n          \n#define SCALE (GOLDEN_RATIO_ZERO * exp(-1.0))\n","name":"Common","description":"","type":"common"}]}