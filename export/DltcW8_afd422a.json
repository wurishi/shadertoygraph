{"ver":"0.1","info":{"id":"DltcW8","date":"1699360426","viewed":33,"name":"triangles around a sphere","username":"siers","description":"triangles around a sphere\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","triangle","sphere"],"hasliked":0,"parentid":"DtcyDr","parentname":"basic-ass triangle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float radian = 3.14159 * 2.;\n\n// https://codeplea.com/triangular-interpolation\nvec3 barycentric(in vec3 p1, in vec3 p2, in vec3 p3, in vec2 p) {\n  float w1 = ((p2.y-p3.y)*(p.x-p3.x)+(p3.x-p2.x)*(p.y-p3.y)) / ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n  float w2 = ((p3.y-p1.y)*(p.x-p3.x)+(p1.x-p3.x)*(p.y-p3.y)) / ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n  return vec3(w1, w2, 1.0 - w1 - w2);\n}\n\nfloat barycentricZ(in vec3 p1, in vec3 p2, in vec3 p3, in vec2 p) {\n  vec3 b = barycentric(p1, p2, p3, p);\n  if (min(b.x, min(b.y, b.z)) > 0.)\n    return dot(vec3(p1.z, p2.z, p3.z), b);\n  else\n    return -999.0;\n}\n\nvec3 triangle(in vec3 p1, in vec3 p2, in vec3 p3, in vec2 pos, in vec3 bg)\n{\n  // copy google colorpicker's rgb in format \"r, g, b\" and run this\n  // ruby -e \"puts('  vec3 col = vec3(%s);' % eval('[%s]' % %x{xclip -o}).map{|x| '%0.2f' % (x/255.0) }.join(', '))\"\n  vec3 col1 = vec3(0.88, 0.75, 0.96);\n  vec3 col2 = vec3(0.86, 0.80, 0.54);\n  vec3 col3 = vec3(0.88, 0.60, 0.38);\n\n  vec3 tri = barycentric(p1, p2, p3, pos);\n  return min(tri.x, min(tri.y, tri.z)) > 0. ? col1 * tri.x + col2 * tri.y + col3 * tri.z : bg;\n}\n\n// https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\n// place triIdx'th triangle vertex (side length = 1) at z = 'radius' and rotate it\nvec3 transform(float yangle, float zangle, int triIdx) {\n  float tTime = iTime * 0.0;\n  vec3 triVert = vec3(cos(vec2(0, radian / 4.0) + radian * (tTime + float(triIdx)) / 3.0), 0.);\n\n  float radius = 5.;\n  mat4 m = rotationMatrix(vec3(0., 1., 0.), yangle);\n  mat4 m2 = rotationMatrix(vec3(0., 0., 1.), zangle);\n  vec4 rot = m2 * (m * vec4(triVert.xy, radius, 0.));\n  vec3 w = rot.xyz + vec3(0, 0, (-radius * 1.5));\n\n  mat3 proj = mat3(vec3(1. / w.z, 0, 0), vec3(0, 1. / w.z, 0), vec3(0, 0, 1));\n  return proj * w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv;\n  uv = 2.1 * (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\n  int subCount = 5;\n  int triCount = subCount * subCount;\n  vec3[3 * 25] tris; // second number must equal triCount\n\n  for (int i = 0; i < triCount; i++) {\n    float t = iTime * 0.1;\n    float subring = float(i / subCount) / float(subCount);\n    float ring = float(i % subCount) / float(subCount) + subring / float(subCount);\n    float yangle = radian * (t + ring), zangle = radian * (t + subring);\n      for (int j = 0; j < 3; j++) tris[i * 3 + j] = transform(yangle, zangle, j);\n  }\n\n  // find top triangle\n  int i = -1;\n  for (int j = 0; j < triCount; j++) {\n    float prev = barycentricZ(tris[i*3], tris[i*3+1], tris[i*3+2], uv);\n    float curr = barycentricZ(tris[j*3], tris[j*3+1], tris[j*3+2], uv);\n    if ((curr != -999. && prev < curr)) i = j;\n  }\n\n  // find color of uv inside the triangle at tris[i]\n  fragColor = vec4(triangle(tris[i*3], tris[i*3+1], tris[i*3+2], uv, vec3(0, 0, 0)), 0.);\n}\n","name":"Image","description":"","type":"image"}]}