{"ver":"0.1","info":{"id":"dsdXz8","date":"1679413845","viewed":97,"name":"Orbit Camera SDF","username":"dzufque","description":"SDF raymarching with orbit camera","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Constants\nconst int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float PRECISION=.0001;\nconst float EPSILON=.0005;\nconst float PI=3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// Camera control\nvec2 cameraAng = vec2(0.5, 0.5);\nbool isDragging = false;\nvec2 startDraggingPos = vec2(-1);\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    vec3 ambient;\n    float smoothness;\n};\n\nstruct Surface{\n    float sd;   // signed distance value\n    Material mat;\n};\n\n// Rotate around a circular path\nmat2 rotate2d(float theta){\n    float s = sin(theta),c=cos(theta);\n    return mat2(c,-s,s,c);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(1.,0.,0.),\n        vec3(0.,c,-s),\n        vec3(0.,s,c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(c,0.,s),\n        vec3(0.,1.,0.),\n        vec3(-s,0.,c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(c,-s,0.),\n        vec3(s,c,0.),\n        vec3(0.,0.,1.)\n    );\n}\n\n// Identity matrix.\nmat3 identity(){\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n}\n\n\nSurface minWithColor(Surface obj1,Surface obj2){\n    if(obj2.sd<obj1.sd) return obj2;\n    return obj1;\n}\n\n\nfloat sdf(vec3 p){\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n\n    return length(max(abs(p) - vec3(1.0),0.0)) + min(max(abs(p.x) - 1.0,max(abs(p.y) - 1.0,abs(p.z) - 1.0)),0.0);\n}\n\nSurface map(vec3 p){\n    Material mat = Material(vec3(1.0), vec3(1.0), vec3(1.0), 10.0);\n    float d = sdf(p);\n\n    Surface co = Surface(d, mat);\n\n    return co;\n}\n\nvec3 grad( in vec3 p )\n{\n    return vec3(\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\n    );\n}\n\nmat3 camera(vec3 cameraPos,vec3 lookAtPoint){\n    vec3 cd = normalize(lookAtPoint-cameraPos);      // camera direction\n    vec3 cr = normalize(cross(vec3(0.,1.,0.),cd)); // camera right\n    vec3 cu = normalize(cross(cd,cr));               // camera up\n\n    return mat3(-cr,cu,-cd);\n}\n\nSurface rayMarch(vec3 ro,vec3 rd,float start,float end){\n    float depth = start;\n    Surface co; // closest object\n\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n        vec3 p = ro + depth*rd;\n        co = map(p);\n        depth += co.sd;\n        if(co.sd<PRECISION||depth>end)  break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 lighting(vec3 p,vec3 n,vec3 eye,Material mat){\n    vec3 ambient = vec3(.5);\n\n    vec3 lights_pos[2];\n    lights_pos[0] = vec3(4.,2.,2.);\n    lights_pos[1] = vec3(-4.,-2.,-2.);\n\n    vec3 lights_color[2];\n    lights_color[0] = vec3(1.,1.,1.);\n    lights_color[1] = vec3(1.,1.,1.);\n\n    vec3 Ip = mat.ambient*ambient;\n\n    for(int i=0;i<2;i++){\n        vec3 Lm = normalize(lights_pos[i] - p);\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm); // reflect(-Lm, n)\n        vec3 V  = normalize(eye - p);\n\n        float LN = dot(Lm,n);\n        float RV = dot(Rm,V);\n\n        if(LN<0.) // Light not visible\n        Ip+=vec3(0.,0.,0.);\n        else if(RV<0.)// opposite direction as viewer, apply only diffuse\n        Ip+=lights_color[i]*(mat.diffuse*LN);\n        else\n        Ip+=lights_color[i]*(mat.diffuse*LN+mat.specular*pow(RV,mat.smoothness));\n    }\n\n    return Ip;\n}\n\nvec3 calcNormal(in vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\n    ));\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n   \nvoid mainImage(out vec4 c, vec2 p)\n{\n\tvec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n        vec2 mouseUV = vec2(0.5);\n        mouseUV = iMouse.xy/iResolution.xy;  // [0,1]\n\n\n        vec3 backgroundColor = vec3(.835, 1.0, 1.0);\n        vec3 col    = vec3(0.0);\n        \n        // default ray dir\n        vec3 dir = ray_dir( 45.0, iResolution.xy, gl_FragCoord.xy );\n\n        // default ray origin\n        \n\n        // ray marching\n        vec3 lookAt = vec3(0.0);\n        vec3 eye    = vec3(0,0,5.0);\n\n        float cameraRadius = 10.0;\n        vec2 cameraAng = vec2(1.1, 0.0);\n        // rotate camera\n        mat3 rot = (rotateY(cameraAng.x)*rotateX(cameraAng.y));\n        dir = rot * dir;\n        eye = rot * eye;\n        //eye = (rotateY(cameraAng.x)*rotateX(cameraAng.y)) * eye * cameraRadius + lookAt;\n        //eye =  eye * cameraRadius + lookAt;\n        // eye.yz =   rotate2d( u_cameraAng.x ) * eye.yz * cameraRadius + vec2(lookAt.y, lookAt.z);\n        // eye.xz =  rotate2d( u_cameraAng.y ) * eye.xz + vec2(lookAt.x, lookAt.z);\n        \n        //vec3 rayDir = camera(eye, lookAt) * normalize(vec3(uv,-1));// ray direction\n        \n        Surface co = rayMarch(eye, dir, MIN_DIST, MAX_DIST);// closest object\n        \n        if(co.sd > MAX_DIST){\n            col = backgroundColor;  // ray didn't hit anything\n        }\n        else{\n            vec3 p = eye + dir*co.sd;  // point from ray marching\n            vec3 normal = calcNormal(p);\n            \n            col = lighting(p, normal, eye, co.mat);\n        }\n        \n        c = vec4(col, 1.0);\n        return;\n}","name":"Image","description":"","type":"image"}]}