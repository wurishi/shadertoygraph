{"ver":"0.1","info":{"id":"NdtGR2","date":"1630357133","viewed":87,"name":"Piston","username":"mkorenchan","description":"Attempt of recreating that one piston shader that was featured on the front page recently","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Michael Korenchan\n// University of Illinois at Urbana-Champaign\n\n// Created in about an hour on a monday evening because I was told \"I couldn't do it that fast\"\n\n#define RAYMARCH_STEPS 100.\n#define RAYMARCH_MAX_DIST 10000.\n#define RAYMARCH_MIN_DIST 0.00001\n#define FLT_MAX 3.40282e+038\n#define saturate(f) clamp(f,0.,1.)\n#define sdot(a,b) clamp(dot(a,b),0.,1.)\n#define PI 3.14159265358979\n#define SPEED 8.\n\nstruct RayMarchResult {\n    float t;\n    vec3 p;\n};\n\nfloat noise(vec2 p) {\n    p += .1;\n\tp = fract(p*vec2(322.24, 64.23));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nmat2 rot(float a) {\n    float s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotate(vec3 p, int axis, float angle) {\n    if (axis == 0) p.yz *= rot(angle);\n    else if (axis == 1) p.xz *= rot(angle);\n    else p.xy *= rot(angle);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n//// SDFS\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return distance(p,sphere.xyz)-sphere.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPistonBase(vec3 p, float time) {\n    p.xy *= rot(-time);\n    float h = .05;\n    float dxy = smin(length(p.xy-vec2(.15,0)) - .1, length(p.xy) - .16, .1);\n    float dz = abs(p.z) - h/2.;\n    return min(max(dxy, dz),0.) + length(max(vec2(dxy,dz),0.));\n}\n\nfloat sdPistonNeck(vec3 p, float time) {\n    vec3 p1 = vec3(.2,0,0);\n    vec3 p2 = vec3(0,.4,0);\n    // transform endpoints\n    p1.xy *= rot(time);\n    p2.y += .15*sin(time);\n    \n    //float edpts = min(sdSphere(p,vec4(p1,.1)), sdSphere(p,vec4(p2,.1)));\n    float boxlen = distance(p1,p2);\n    float angle = -asin((p1-p2).x)/boxlen;\n    p -= (p1+p2)/2.;\n    p.xy *= rot(angle);    \n    \n    float neck = sdRoundBox(p, vec3(.02,boxlen/2.+.01,.02), .01);\n    return neck;\n}\n\nfloat sdPistonCap(vec3 p, float time) {\n    p.y -= .4 + .15*sin(time);\n    return sdRoundedCylinder(p, .07, .01, .07);\n}\n\nfloat sdAxles(vec3 p, float time) {\n    float base1 = sdRoundedCylinder(p.xzy-vec3(0,.1,0), .02, .01, .05);\n    float base2 = sdRoundedCylinder(p.xzy+vec3(0,.1,0), .02, .01, .05);\n    float end  = sdRoundedCylinder(rotate(p.xzy,1, -time)-vec3(.2,0,0), .02, .01, .15);\n    \n    float d = base1;\n    d = min(d, base2);\n    d = min(d, end);\n    return d;\n}\n\nfloat sdfPiston(vec3 p, float time) {\n    float neck  = sdPistonNeck(p, time);\n    float base1 = sdPistonBase(p + vec3(0,0,.1), time);\n    float base2 = sdPistonBase(p - vec3(0,0,.1), time);\n    float axles = sdAxles(p, time);\n    float cap   = sdPistonCap(p, time);\n    float d = FLT_MAX;\n    d = min(d, neck);\n    d = min(d, base1);\n    d = min(d, base2);\n    d = min(d, cap);\n    d = min(d, axles);\n    return d;\n}\n\nfloat sdf(vec3 p) {\n    float d = FLT_MAX;\n    float piston1 = sdfPiston(p, SPEED*(iTime+PI/3.));\n    float piston2 = sdfPiston(p+vec3(0,0,.3), SPEED*iTime);\n    float piston3 = sdfPiston(p-vec3(0,0,.3), SPEED*(iTime+PI/4.));\n    d = min(d, piston1);\n    d = min(d, piston2);\n    d = min(d, piston3);\n    return d;\n}\n\nRayMarchResult rayMarch(vec3 pos, vec3 dir) {\n    float t = 0.;\n    vec3 p = pos;\n    \n    for (int i = 0; i < 100; i++) {\n        float d = sdf(p);\n        t += d;\n        p = pos + t * dir;\n        if (d < 0.001) {\n            break;\n        }\n        if (d > 10000.) {\n            t = -1.;\n            break;\n        }\n    }\n    return RayMarchResult(t, p);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0001, 0.);\n    vec3 d = sdf(p)-vec3(sdf(p-e.xyy),sdf(p-e.yxy),sdf(p-e.yyx));\n    return normalize(d);\n}\n\nfloat shade(RayMarchResult res) {\n    vec3 lightDir = vec3(0,1,0);\n    vec3 normal = getNormal(res.p);\n    return sdot(lightDir,normal);\n}\n\nvec4 mainColor(vec2 uv) {\n    vec3 pos = vec3(0,0.2,1.5);\n    vec3 dir = normalize(vec3(uv,-1));\n    mat2 r = rot(iMouse.x/100.);\n    pos.xz *= r;\n    dir.xz *= r;\n    \n    RayMarchResult res = rayMarch(pos,dir);\n    vec4 cubeCol = res.t >= 0. ? 2.5*texture(iChannel0, reflect(dir, getNormal(res.p))) : texture(iChannel0,dir);\n    return cubeCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    \n    // antialiasing isn't working yet.\n    float numSamples = 8.;\n    vec4 col = vec4(0);\n    for (float i = 0.; i < numSamples; i += 1.) col += mainColor(uv + noise(uv*(i+1.))/iResolution.xy);\n    fragColor = col / numSamples;\n}","name":"Image","description":"","type":"image"}]}