{"ver":"0.1","info":{"id":"lt3yWN","date":"1532627972","viewed":159,"name":"swapsort","username":"timeiskey","description":"sorting algo,\nprobably should get rid of almost all the ifs. (redundant computation but no branching pls)\nprobably have to keep the mod tho (figure out floatmod me pls)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 whoShouldBeHereLeft( vec2 uv, vec2 cellDim )\n{\n\t//\tcheck yourself\n    vec4 centerCell = texture(iChannel0, uv);\n    float centerCellBright = (centerCell.r + centerCell.g + centerCell.b) / 3.0;\n    \n    // check right\n    vec4 rightCell = texture(iChannel0, uv + vec2(cellDim.x, 0.0));\n    float rightCellBright = (rightCell.r + rightCell.g + rightCell.b) / 3.0;\n    \n    if( centerCellBright < rightCellBright )\n    {\n    \treturn centerCell;\n    }\n    else\n    {\n    \treturn rightCell;\n    }\n\n}\n\nvec4 whoShouldBeHereRight( vec2 uv, vec2 cellDim  )\n{\n\t//\tcheck yourself\n    vec4 centerCell = texture(iChannel0, uv);\n    float centerCellBright = (centerCell.r + centerCell.g + centerCell.b) / 3.0;\n    \n    // check left\n    vec4 leftCell = texture(iChannel0, uv - vec2(cellDim.x, 0.0));\n    float leftCellBright = (leftCell.r + leftCell.g + leftCell.b) / 3.0;\n\n    if( centerCellBright > leftCellBright )\n    {\n    \treturn centerCell;\n    }\n    else\n    {\n    \treturn leftCell;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cellDim = 1.0/iResolution.xy;\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 newPixelCol = texture(iChannel0, uv);\n    if( (iFrame % 2) == 0 )\n    {\n    \tif( (int(floor(fragCoord.x)) % 2) == 0 )\n        {\n        \tnewPixelCol = whoShouldBeHereLeft( uv, cellDim );\n        }\n        else\n        {\n        \tnewPixelCol = whoShouldBeHereRight( uv, cellDim );\n        }\n    }    \n    else\n    {\n    \tif( (int(floor(fragCoord.x)) % 2) == 1 )\n        {\n        \tnewPixelCol = whoShouldBeHereLeft( uv, cellDim );\n        }\n        else\n        {\n        \tnewPixelCol = whoShouldBeHereRight( uv, cellDim );\n        }\n    }\n    \n    if( iFrame < 10 )\n    {\n\t\tfragColor = texture(iChannel1, uv);\n    }\n    else\n    {\n        fragColor = newPixelCol;\n    \t//fragColor = newPixelCol*0.96 + texture(iChannel1, uv) * 0.1;\n    }\n    \n}\n\n","name":"Buf A","description":"","type":"buffer"}]}