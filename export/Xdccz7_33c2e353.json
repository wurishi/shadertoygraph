{"ver":"0.1","info":{"id":"Xdccz7","date":"1518142570","viewed":103,"name":"Spindle of Death-CIS 566","username":"jamie2719","description":"CIS 566 project 2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.15926\n\nmat4 rotate(vec3 rot) {\n\tmat4 rx = mat4(vec4(1, 0, 0, 0),\n\t\t\t\t\tvec4(0, cos(rot.x * PI/180.0), sin(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, -sin(rot.x * PI/180.0), cos(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 ry = mat4(vec4(cos(rot.y * PI/180.0), 0, -sin(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\t\tvec4(sin(rot.y * PI/180.0), 0, cos(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 rz = mat4(vec4(cos(rot.z * PI/180.0), sin(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(-sin(rot.z * PI/180.0), cos(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\t\t\t\t\t\n\treturn rz * ry * rx;\n\t\n}\n\nmat4 translate(vec3 trans) {\n\treturn mat4(vec4(1, 0, 0, 0),\n\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\tvec4(trans.x, trans.y, trans.z, 1));\n}\n\n\n\nfloat sdSphere( vec3 p, float s, vec3 trans, vec3 rot, vec3 rot1) \n{\n    \n    p = vec3(rotate(rot1) * vec4(p, 1));\n    p = vec3(rotate(rot) * vec4(p, 1));\n   \tp = vec3(translate(trans) * vec4(p, 1));\n    \n    \n    \n  \treturn length(p)-s;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t, vec3 trans, vec3 rot )\n{\n    p = vec3(rotate(rot) * vec4(p,1));\n    p = vec3(translate(trans) * vec4(p,1));\n    \n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat ringSDF(vec3 p) {\n    float ringRotSpeed = clamp(fract(iTime * .25) * 4.0 - 1.0, 0.0, 1.0) + floor(iTime * .25);\n    \n    p = vec3(rotate(vec3(90.0 * ringRotSpeed, 0, 0)) * vec4(p,1));\n    \n    float centerRing =  sdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90, 0, 90));\n    float ring1 =\t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 67.5));\n    float ring2 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 45));\n    float ring3 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 22.5));\n    float ring4 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 0));\n    float ring5 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, -22.5));\n    float ring6 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, -45));\n    float ring7 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, -67.5));\n    float ring8 = \t\tsdTorus(p, vec2(5, .03), vec3(0, 0, 0), vec3(90.0, 0, 90));\n    centerRing = unionSDF(centerRing, ring1);\n    centerRing = unionSDF(centerRing, ring2);\n    centerRing = unionSDF(centerRing, ring3);\n    centerRing = unionSDF(centerRing, ring4);\n    centerRing = unionSDF(centerRing, ring5);\n    centerRing = unionSDF(centerRing, ring6);\n    centerRing = unionSDF(centerRing, ring7);\n    centerRing = unionSDF(centerRing, ring8);\n    \n    return centerRing;\n}\n\nfloat ballSDF(vec3 p) {\n    float ringRotSpeed = clamp(fract(iTime * .25) * 4.0 - 1.0, 0.0, 1.0) + floor(iTime * .25);\n    p = vec3(rotate(vec3(90.0 * ringRotSpeed, 0, 0)) * vec4(p,1));\n    //130\n    \n    float centerBall = sdSphere(p, .5,  vec3(0, 5, 0), vec3(125.0 * iTime, 0, 0), vec3(0, 0, 0));\n    float ball1 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-109.0 * iTime, 0, 0), vec3(0, -22.5, 0));\n    float ball2 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-111.0 * iTime, 0, 0), vec3(0, -45, 0));\n    float ball3 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-113.0 * iTime, 0, 0), vec3(0, -67.5, 0));\n    float ball4 = sdSphere(p, .2,  vec3(0, 5, 0), vec3(-115.0 * iTime, 0, 0), vec3(0, -90, 0));\n    float ball5 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 123.0 * iTime, 0, 0), vec3(0, 22.5, 0));\n    float ball6 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 121.0 * iTime, 0, 0), vec3(0, 45, 0));\n    float ball7 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 119.0 * iTime, 0, 0), vec3(0, 67.5, 0));\n    float ball8 = sdSphere(p, .2,  vec3(0, 5, 0), vec3( 117.0 * iTime, 0, 0), vec3(0, 90, 0));\n   \n    centerBall = unionSDF(centerBall, ball1);\n    centerBall = unionSDF(centerBall, ball2);\n    centerBall = unionSDF(centerBall, ball3);\n    centerBall = unionSDF(centerBall, ball4);\n    centerBall = unionSDF(centerBall, ball5);\n    centerBall = unionSDF(centerBall, ball6);\n    centerBall = unionSDF(centerBall, ball7);\n    centerBall = unionSDF(centerBall, ball8);\n    \n    \n    return centerBall;\n}\n\n\n\n\nvec3 toWorldSpace(vec3 p, vec3 eye, vec3 ref) {\n\tfloat fov = 75.0;\n\n\tfloat sx = (p.x);\n    float sy = (p.y);\n    float A = iResolution.x / iResolution.y;\n    float alpha = fov / 2.0 * (3.159 / 180.0);\n    vec3 forward = normalize(ref - eye);\n   \tvec3 right = normalize(cross(vec3(0, 1, 0), forward));\n   \tvec3 localUp = normalize(cross(forward, right));\n    \n\n    //convert screen point to world point\n    float len = .1;//length(forward);\n    vec3 V = (localUp * len * tan(alpha));\n    vec3 H = right * A * len *tan(alpha);\n\n    return vec3(eye + len * forward + sx * H + sy * V); //world point \n}\n\nfloat raymarch(vec3 p, vec3 eye, vec3 ref) {\n    //get ray from world point\n    vec3 dir = normalize(p - eye);\n    vec3 origin = eye;\n    \n    \n    \n    float rings;\n    float balls;\n    vec3 minInter; \n    vec3 intersection;\n    float intersected = 0.0; //0 if not intersected, 1 if intersected ring, 2 if intersected balls\n    float t = 0.005;\n\tfor (int i = 0; i < 64; i++) {\n\t\tintersection = origin + dir * t;\n\t\t\n        \n        rings = ringSDF(intersection);\n        balls = ballSDF(intersection);\n\t\t\n\t\tif(rings <= .001) {\n\t\t\tintersected = 1.0;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n        else if(balls <= .001) {\n            intersected = 2.0;\n            break;\n        }\n\t\tt += unionSDF(balls, rings);\n\t}\n   \treturn intersected;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt *= iResolution.x / iResolution.y;\n    \n    vec3 eye =  vec3(0, 0, -7);\n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    \n    \n    vec3 p = toWorldSpace(vec3(scrPt, 1), eye, ref);\n    \n    \n    float val = raymarch(p, eye, ref);\n    \n    vec3 col;\n    if(val == 2.0) {\n        col = vec3(1, 1, 1);\n    }\n    else if(val == 1.0) {\n        col = vec3(0, 0, 0);\n    }\n    else {\n        col = vec3(.2, .2, .2);\n    }\n    \n    fragColor = vec4(col,1);\n     \n\n\n    \n}","name":"Image","description":"","type":"image"}]}