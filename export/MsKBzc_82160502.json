{"ver":"0.1","info":{"id":"MsKBzc","date":"1530005931","viewed":405,"name":"Enter the Pipotron","username":"CoyHot","description":"A 3D looking  tunnel effect, only created using 2D tricks and a lot of UV distorsions.\nThe code is fully commented to understand how it works ... and to play with it by changing some values.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","tunnel","oldschool","pipotron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------- Enter the Pipotron -------------\n// ------------ A 'Only 2D' timewarp tunnel ---------\n//  ----- Francois 'CoyHot' Grassard, June 2018 ----\n//     A tunnel effect only created with 2D tricks  \n// --------------------------------------------------\n\nvec2 rot (vec2 uv,float angle)\n{\n    return uv*mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = ((fragCoord.xy / iResolution.xy)-0.5)/vec2(iResolution.y / iResolution.x, 1);\n    \n    float gridSize = 50.; // Higher value mean more triangular shapes\n    float angle = 3.1416/6.; // Angle used to simulate the reflection\n    float refFactor = 0.65; // Initial reflection factor (on the ground)\n\n    uv = rot(uv,sin(iTime)/10.); // Rotating the whole image a bit\n    uv = rot(uv,sin((uv.y*4.+iTime/2.)*10.)/300.); // Add a tiny distortion to whole structure\n    \n\tuv.y += cos(uv.y*1.1); // Simulate the lens distortion\n    uv.y -= 0.9; // Offset to move the horizon down\n   \n    if (uv.y+abs(uv.x)/3.8 < -0.20) // Define the ground shape\n    {\n        refFactor = 3.; // Factor used to reduce the luminosity of the reflection on the ground\n\t}   \n\n    float transFac = smoothstep(-0.1,-0.25,uv.y+abs(uv.x)/3.8)+0.75; // Fake Wall/Ground Ambien Occlusion\n\n    uv.x = -abs(uv.x); // Symetrize to lines to create a triangular shape\n    uv.y += 0.2; // Align the whole shape to fil the fake reflection\n    uv =rot(uv,-angle*3.5); // Rotate the shapes to create the reflection\n\n\tuv.y *= 0.9; // Strech uv verticaly a bit, to enhance the fake lens effect\n\n    uv.x = -abs(uv.x);\n    uv.y = abs(uv.y+0.2);\n    \n    uv =rot(uv,-angle*1.4); // Change the 1.4 valu to tweak the \"verticality\" of the structure\n\n    uv.y -= 0.35;   // Offset do define if we gonna catch the lines from the top (tiny/slow)\n    \t\t\t\t// or from the bottom (big/fast) of the image.\n    \n    uv.y /= exp(uv.y); // Strech lines to make them accelerate (to simulate the perspective of the tunnel), from the bottom to the top\n    \n    float zDepth = 1.-(length (vec2(uv.x,uv.y-(5./7.)))*(1.+(abs(sin(iTime/2.))-0.35))); // Create a fake (animated) Z-Depth, only based on UV\n\n    uv.y -=(iTime/7.0); // Move the lines UP (and make you fly through the tunnel) \n\n\n    float hLine = sin(uv.y*gridSize); // Draw the lines\n\tfloat grid = clamp(((hLine))*1.25,0.,1.);  // Clamp the result to avoid negative values\n    \n    vec3 gridColor = vec3(grid/(refFactor*transFac)); // Dim the reflection off the ground\n\n    \n    // Create a small bevel on the edges shape\n    uv.y -= 0.01; // Offset the UV (so, go a few milliseconds away in the future) \n    hLine = sin(uv.y*gridSize);\n\tgrid = clamp(((hLine))*2.25,0.,1.0);   \n    gridColor += vec3(grid/(refFactor*transFac)/5.,0.25,0.); // Add this \"echo shape\"\n\n\n    // Add a thickness to the shapes   \n    uv.y -= 0.025; // Offset the UV (and travel to the future ... but far away than previously)\n    hLine = sin(uv.y*gridSize);    \n\tgrid = clamp(((hLine))*2.25,0.,1.0);   \n    gridColor += vec3(grid/(refFactor*transFac)/6.);// Add this \"echo shape\"\n\n    gridColor *= vec3(zDepth); //Multiply the image by the Z-Depth Mask\n    \n\t// AND FINALY : Add more colors !\n    gridColor += (vec3(sin(uv.x)/2.,abs(sin(uv.y*10.)/15.),0.1))*(abs(sin(iTime)+1.5));\n\n    // Output to screen\n    fragColor = vec4(gridColor,1.0);\n}","name":"Image","description":"","type":"image"}]}