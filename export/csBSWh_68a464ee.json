{"ver":"0.1","info":{"id":"csBSWh","date":"1679408955","viewed":58,"name":"volumetric or something","username":"ekicam2","description":"Wanted to do volumetrics since I remember, it's somehow a big moment for me :)\nHope you enjoy it as much as me.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 150\n#define SINGLE_STEP 0.01\n#define EPSILON 0.0001\n\n// SDF lib\n\nfloat sphereSDF(vec3 p, float r) {\n    return distance(p, vec3(0)) - r;\n}\n\nfloat boxSDF( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat intersectSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat diffSDF(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n\n// scene creation\n\nfloat sceneDist(vec3 p);\n\nvec3 sceneNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return normalize(vec3(\n        sceneDist(p + e.xyy) - sceneDist(p - e.xyy),\n        sceneDist(p + e.yxy) - sceneDist(p - e.yxy),\n        sceneDist(p + e.yyx) - sceneDist(p - e.yyx)));\n}\n\nstruct MarchResult {\n    vec3 p;\n    float d;\n    float r;\n};\n\nbool originTargetMarch(vec3 o, vec3 t) {\n    vec3 d = normalize(t-o);\n    for(int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = o + d*SINGLE_STEP*float(i);\n        if(sceneDist(p) < EPSILON) {\n            return true;\n        }\n    }\n    return false;\n}\n\nMarchResult originDirMarch(vec3 o, vec3 d, vec3 l) {\n    float r = 0.0;\n    for(int i = 0; i < MAX_STEPS; ++i) {\n        float dist = float(i)*SINGLE_STEP;\n        vec3 p = o + d*dist;\n        \n        if(!originTargetMarch(p, l)) {\n            r += (1./16.); // accumulate radiation\n        }\n        \n        if(sceneDist(p) < EPSILON) {\n            return MarchResult(p, dist, (r/float(MAX_STEPS)));\n        }\n    }\n    return MarchResult(vec3(0.0), -1.0, (r/float(MAX_STEPS)));\n}\n\n//\n\nfloat sceneDist(vec3 p) {\n    p.y -= 0.45;\n    p.z -= 0.3;\n    float spheres_d = intersectSDF(\n                    sphereSDF(p - vec3(-0.55, -.75, 0.0), 0.5),\n                    sphereSDF(p - vec3(0.55, -0.8, 0.0), 0.5));\n    float box_d = boxSDF(p - vec3(-0.0, -0.05, 0.15), vec3(0.35));\n    //box_d = unionSDF(box_d, boxSDF(p - vec3(0.60, -0.05, -0.2), vec3(0.35)));\n    \n    return unionSDF(spheres_d, box_d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.08);\n\n    // remap from -1.0 to 1.0\n    uv = (uv - vec2(0.5)) * 2.0;\n    // aspect ratio correction\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 origin = vec3(0.0, 0.0, -1.0);\n    vec3 eye_dir = (vec3(uv.xy, 1.0)); // why normalizing direction makes artifacts?\n    \n    vec3 light_p = vec3(\n        sin(iTime), \n        sin(iTime*2.)*0.5, \n        cos(iTime));\n    \n    MarchResult r = originDirMarch(origin, eye_dir, light_p);\n    if(r.d != -1.0) {\n        vec3 n = sceneNormal(r.p);\n        vec3 l = normalize(light_p-r.p);\n        float shadow = originTargetMarch(r.p-eye_dir*SINGLE_STEP, light_p) ? 0.0 : 1.0;\n        col = mix(vec3(0.1), vec3(1.0), shadow * max(0.0, dot(n,l)));\n    } else {\n        col += vec3(r.r);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}