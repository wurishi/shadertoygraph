{"ver":"0.1","info":{"id":"WdVyWw","date":"1610767480","viewed":110,"name":"Low-Poly Paradise","username":"jcf1","description":"Socially distant with a pineapple under the sea.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","lowpoly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All References:\n// \"Cartoon low poly tree\" by PaulsenDesign: https://www.turbosquid.com/3d-models/free-3ds-model-trees-scene/961487\n// \"1D, 2D & 3D Value Noise\" by morgan3d: https://www.shadertoy.com/view/4dS3Wd\n// \"Triangle - distance 3D\" by iq: https://www.shadertoy.com/view/4sXXRN\n// \"Triangle - intersection\" by iq: https://www.shadertoy.com/view/MlGcDz\n// \"triIntersect test for OBJ Model\" by yasuo: https://www.shadertoy.com/view/WdBGWR\n\n//========== Time of Day ==========\n\n//Option to toggle flower clouds \n#define FLOWERS 1\n\n//Options to only show one time of day, priority in order\n#define SUNRISE 0\n#define DAY 0\n#define SUNSET 0\n#define NIGHT 0\n\n//Length of one part of the day\nconst float TOD_TIME = 5.0;\n\n//Time to transition from one part of the day to another\nconst float TRANSITION_TIME = 5.0;\n\n//How Long a flower stays one color\nconst float FLOWER_COLOR_TIME = 20.0;\n\n//Time to transition from one flower color to another\nconst float FLOWER_COLOR_TRANSITION = 5.0;\n\n//======== Flower Settings ========\n\nconst float small_x_min = -0.079;\nconst float small_x_max = 1.071;\nconst float medium_x_min = -0.1059;\nconst float medium_x_max = 1.086;\nconst float large_x_min = -0.154;\nconst float large_x_max = 1.14;\n\nfloat small_size = 0.15;\nfloat medium_size = 0.2;\nfloat large_size = 0.3;\n \t\nint small_blur = 2;\nint medium_blur = 3;\nint large_blur = 5;\n\nfloat small_speed = 60.0;\nfloat medium_speed = 60.0;\nfloat large_speed = 60.0;\n\nfloat small_y = 0.87;\nfloat medium_y = 0.7;\nfloat large_y = 0.75;\n\nfloat small_rot = 1.0;\nfloat medium_rot = 3.0;\nfloat large_rot = 2.0;\n\nfloat small_offset = 5.0;\nfloat medium_offset = 20.0;\nfloat large_offset = 40.0;\n\n//Flower Colors\nconst vec3 blue = vec3(0.10196078431, 0.11372549019, 0.84705882352);\nconst vec3 pink = vec3(0.9765625, 0.78515625, 0.99609375);\nconst vec3 orange = vec3(0.9140625, 0.734375, 0.40234375);\nconst vec3 purple = vec3(0.5546875, 0.3984375, 0.63671875);\nconst vec3 red = vec3(0.89803921568, 0.09803921568, 0.19215686274);\nconst vec3 neon = vec3(0.74117647058, 1.0, 0.14901960784);\nconst vec3 green = vec3(0.13725490196, 0.5294117647, 0.18823529411);\n\nconst int small_num_flower_colors = 4;\nconst int medium_num_flower_colors = 4;\nconst int large_num_flower_colors = 4;\n\nconst vec3 small_flower_colors[small_num_flower_colors] = vec3[](purple,neon,red,orange);\nconst vec3 medium_flower_colors[medium_num_flower_colors] = vec3[](green,red,neon,pink);\nconst vec3 large_flower_colors[large_num_flower_colors] = vec3[](blue,pink,orange,neon);\n\n//CONSTANTS\nconst float ISLAND_RADIUS = 6.0;\nconst vec2 ISLAND_CENTER  = vec2(0.0, -8.3);\nconst float pi = \t\t\t3.1415926535;\n\n//======================= Island Noise =======================\n// Code for noise from \"1D, 2D & 3D Value Noise\" by morgan3d\n// Link: https://www.shadertoy.com/view/4dS3Wd\n    \nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x, float size) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\tfloat a = hash(i);\n    float b = hash(i + vec2(size, 0.0));\n    float c = hash(i + vec2(0.0, size));\n    float d = hash(i + vec2(size, size));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x, float size) {\n    int octaves = 2;\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < octaves; ++i) {\n\t\tv += a * noise(x, size);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n    \n//================ iq code ======================\n// Triangle distance code from \"Triangle - distance 3D\" by iq\n// Link: https://www.shadertoy.com/view/4sXXRN\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p ) {\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n// Triangle intersect code from \"Triangle - intersection\" by iq \n// Link: https://www.shadertoy.com/view/MlGcDz\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n  \n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n//=========================================================\n\n//Distance between island center and given point using pythagorean theorem\nfloat distCenter(in vec2 p) {\n\treturn sqrt( pow( (p.x - ISLAND_CENTER.x), 2.0 ) + pow( (p.y - ISLAND_CENTER.y), 2.0 ) );\n}\n\nfloat island_height(in vec2 xz, in float dis) {\n    float island_rad = ISLAND_RADIUS + 0.0;\n    float t = (sqrt( pow(island_rad, 2.0) - pow(dis, 2.0))) / island_rad;\n    float h = ((t * 2.1) + (fbm(xz, 1.0) * t * 1.6));\n    h *= 0.95;\n   \tif(dis > ISLAND_RADIUS) return 0.0;\n    return h;\n}\n\nfloat ocean_height(in vec2 xz) {\n    vec2 q = iTime*0.6 + xz;\n\tfloat h = sin(sin(q.x)*sin(q.y)) * sin(cos(q.x)*cos(q.y));\n    h = (h+1.0)/2.0;\n    h += 0.001;\n    h *= 1.2;\n    return h;\n}\n\n//=================== Shading ==========================\n\nvec3 timeOfDay(in vec3 sunrise, in vec3 day, in vec3 sunset, in vec3 night) {\n    if((SUNRISE + DAY + SUNSET + NIGHT) > 0) {\n        if(SUNRISE > 0) { return sunrise; }\n        if(DAY > 0) { return day; }\n        if(SUNSET > 0) { return sunset; }\n        if(NIGHT > 0) { return night; }\n    }\n    \n    float total = (TOD_TIME + TRANSITION_TIME) * 4.0;\n    float _half = total * 0.5;\n    float quarter = _half * 0.5;\n    \n   \tfloat new_time = mod(iTime, total);\n    \n    vec3 color1 = vec3(0,0,0);\n    vec3 color2 = vec3(0,0,0);\n    if(new_time < _half) {\n        if(new_time < quarter){\n            color1 = sunrise;\n            color2 = day;\n        } else {\n        \tnew_time -= quarter;\n            color1 = day;\n            color2 = sunset;\n        }\n    } else {\n        new_time -= _half;\n        if(new_time < quarter) {\n            color1 = sunset;\n            color2 = night;\n        } else {\n            new_time -= quarter;\n            color1 = night;\n            color2 = sunrise;\n        }\n    }\n    \n    if(new_time < TOD_TIME) {\n    \treturn color1;\n    } else {\n    \treturn mix(color1,color2,(new_time-TOD_TIME)/TRANSITION_TIME);\n    }\n}\n\nvoid shadeTreeLeaves(vec3 norm, inout vec3 col) {\n    vec3 sunrise = mix(vec3(0.739,0.396,0.0314),vec3(0.929,0.576,0.055), norm);\n    vec3 day = mix(vec3(0.818,0.494,0.09),vec3(1.0,0.71,0.137), norm);\n    vec3 sunset = mix(vec3(0.659, 0.337, 0.0), vec3(1.0,0.62,0.22), norm);\n    vec3 night = mix(vec3(0.418,0.286,0.055),vec3(0.647,0.247,0.051), norm);\n    col = timeOfDay(sunrise, day, sunset, night);\n}\n\nvoid shadeTreeTrunk(vec3 norm, inout vec3 col) {\n    vec3 sunrise = vec3(0.6,0.384,0.082);\n    vec3 day = vec3(0.678,0.455,0.141);\n    vec3 sunset = vec3(0.529,0.416,0.157);\n    vec3 night = vec3(0.318,0.243,0.067);\n    col = timeOfDay(sunrise, day, sunset, night);\n}\n\nvoid shadeOcean(vec3 norm, inout vec3 col) {\n    float multi = pow(norm.y, 6.0);\n    \n    vec3 sunrise = vec3(0.149,0.161,1.0) * multi;\n    vec3 day = vec3(0.059,0.623,1.0) * multi;\n    vec3 sunset = vec3(0.082,0.325,0.847) * multi;\n    vec3 night = vec3(0.188,0.024,0.778) * multi;\n    col = timeOfDay(sunrise, day, sunset, night);\n}\n\nvoid shadeIsland(vec3 norm, inout vec3 col) {\n    float multi = mix(0.4, 1.0, pow(((norm.y * 0.7) + (norm.x + 0.3)), 1.25));\n    \n    vec3 sunrise = vec3(0.502,0.729,0.212) * multi;\n    vec3 day = vec3(0.25,0.91,0.235) * multi;\n    vec3 sunset = vec3(0.112,0.776,0.296) * multi;\n    vec3 night = vec3(0.155,0.35,0.294) * multi;\n    col = timeOfDay(sunrise, day, sunset, night);\n}\n\nvec3 drawSky(in vec2 p) {\n    float new_y = pow(p.y,2.0);\n    \n    vec3 sunrise = mix(vec3(0.929,0.531,0.082), vec3(0.391, 0.723, 0.871), new_y);\n    vec3 day = mix(vec3(0.769,0.898,0.988), vec3(0.122, 0.604, 0.949), new_y);\n    vec3 sunset = mix(vec3(1.0,0.608,0.188), vec3(0.259,0.043,0.758), new_y);\n    vec3 night = mix(vec3(0.067,0.443,1.0),vec3(0.157,0.0,0.529), new_y);\n\treturn timeOfDay(sunrise,day,sunset,night);\n}\n\n//==================== Ray March Code ====================\n\n// Based on code from \"triIntersect test for OBJ Model\" by yasuo\n// Link: https://www.shadertoy.com/view/WdBGWR\nbool intersect_tree(in vec3 ro, in vec3 rd, inout vec3 col) {\n    float tmin = 1000.0;\n\tint index = 0;\n    float ypos = 2.0;\n    float xpos = ISLAND_CENTER.x;\n    float zpos = ISLAND_CENTER.y;\n    \n    bool test_tree = false;\n    bool test_trunk = false;\n    vec3 norm;\n    for(int i = 0; i<num_faces_trunk/3; i++){\n        int f1 = faces_trunk[index];\n        int f2 = faces_trunk[index+1];\n        int f3 = faces_trunk[index+2];\n        \n        vec3 v0 = vec3(vertices[(f1*3)-3],vertices[((f1*3)-3)+1],vertices[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices[(f2*3)-3],vertices[((f2*3)-3)+1],vertices[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices[(f3*3)-3],vertices[((f3*3)-3)+1],vertices[((f3*3)-3)+2]);\n        \n        v0 += vec3(xpos,ypos,zpos);\n        v1 += vec3(xpos,ypos,zpos);\n        v2 += vec3(xpos,ypos,zpos);\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            norm = normalize(cross( (v1 - v0), (v2 - v0) ) );\n            test_trunk = true;\n            tmin = res.x;\n        }\n        index += 3;\n    }\n    \n    xpos += sin(iTime*0.2)/4.0;\n    ypos += sin(iTime*0.2)/10.0;\n    index = 0;\n    for(int i = 0; i<num_faces_tree/3; i++){\n        int f1 = faces_tree[index];\n        int f2 = faces_tree[index+1];\n        int f3 = faces_tree[index+2];\n        \n        vec3 v0 = vec3(vertices[(f1*3)-3],vertices[((f1*3)-3)+1],vertices[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices[(f2*3)-3],vertices[((f2*3)-3)+1],vertices[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices[(f3*3)-3],vertices[((f3*3)-3)+1],vertices[((f3*3)-3)+2]);\n        \n        v0 += vec3(xpos,ypos,zpos);\n        v1 += vec3(xpos,ypos,zpos);\n        v2 += vec3(xpos,ypos,zpos);\n    \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            norm = normalize(cross( (v1 - v0), (v2 - v0) ) );\n            test_tree = true;\n            tmin = res.x;\n        }\n        index += 3;\n    }\n\t\n    if(test_tree) {\n        shadeTreeLeaves(norm, col);\n        return true;\n    }else if(test_trunk) {\n        shadeTreeTrunk(norm, col);\n        return true;\n    }\n    return false;\n}\n\nbool traceScene(in vec3 ro, in vec3 rd, inout vec3 col) {\n    float mint = 0.01;\n    float maxt = 18.0;\n    \n    float t = mint;\n    float h = 0.5;\n    vec3 norm;\n    \n   \tfloat OCEAN_SIZE = 1.0;\n    \n    //Saves if corresponding vertex is an ocean vertex for shading purposes\n    bool islandShade;\n    \n    //Need to find way to know what is being hit for shading purposes\n    for( int i = 0; i < 75; i++ ) {\n        vec3 p = ro + rd * t;\n        if(h < 0.001 || t > maxt) {\n            break;\n        }\n        vec2 q0 = floor(vec2(p.x/OCEAN_SIZE, p.z/OCEAN_SIZE));\n    \tvec2 q1 = q0 + vec2(OCEAN_SIZE, 0.0);\n   \t\tvec2 q2 = q0 + vec2(0.0, OCEAN_SIZE);\n        \n   \t\tfloat x_frac = p.x - q0.x * OCEAN_SIZE;\n   \t\tfloat z_frac = p.z - q0.y * OCEAN_SIZE;\n   \t\tif((x_frac + z_frac) > OCEAN_SIZE) {\n   \t\t\tq0 += vec2(OCEAN_SIZE);\n            \n            //Switch values here for the normal calculation later\n            vec2 temp = q1;\n            q1 = q2;\n            q2 = temp;\n    \t}\n        \n        float d0 = distCenter(q0);\n        float d1 = distCenter(q1);\n        float d2 = distCenter(q2);\n        \n        vec3 o_p0,o_p1,o_p2;\n        vec3 i_p0,i_p1,i_p2;\n        float o_h, i_h;\n        \n       \to_p0 = vec3(q0.x, ocean_height(q0), q0.y);\n        o_p1 = vec3(q1.x, ocean_height(q1), q1.y);\n        o_p2 = vec3(q2.x, ocean_height(q2), q2.y);\n        o_h = udTriangle(o_p0,o_p1,o_p2,p);\n            \n        i_p0 = vec3(q0.x, island_height(q0, d0), q0.y);\n        i_p1 = vec3(q1.x, island_height(q1, d1), q1.y);\n        i_p2 = vec3(q2.x, island_height(q2, d2), q2.y);\n        i_h = udTriangle(i_p0,i_p1,i_p2,p);\n        \n        vec3 p0,p1,p2;\n        if(o_h < i_h) {\n        \tp0 = o_p0;\n            p1 = o_p1;\n            p2 = o_p2;\n            h = o_h;\n            islandShade = false;\n        } else {\n            p0 = i_p0;\n            p1 = i_p1;\n            p2 = i_p2;\n            h = i_h;\n            islandShade = true;\n        }\n        \n        norm = normalize(cross( (p0 - p1), (p2 - p1) ) );\n        t += h;\n    }\n    \n    if( t > maxt ) {\n    \treturn false;   \n    }\n\t\n    vec3 pos = ro + rd * t;\n    if(islandShade) {\n\t\tshadeIsland(norm, col);\n    }else {\n        shadeOcean(norm, col);\n    }\n    return true;\n}\n\n//========================== Background Code ==========================\n\nbool drawFlower(vec2 p, float size, vec3 flower_col, vec3 sky_col, int blur, float rot, inout vec3 col) {\n    float len = length(p);\n    float middle = 0.3;\n    float petals = 5.0;\n    float petal_sharpness = 0.16;\n    float angle = 0.5;\n    \n    float bordersize = 0.17;\n    float o_dotsize = size * 0.045;\n    float i_dotsize = size * 0.025;\n    \n    float half_thick = bordersize / 2.0;\n    float mid_point = size * (middle + petal_sharpness * sin( sin( (atan(p.y, p.x) * petals + rot) - 1.4 )));\n    float o_border = size * ((middle + half_thick) + petal_sharpness * sin( sin( (atan(p.y, p.x) * petals + rot) - 1.4 )));\n    float i_border = size * ((middle - half_thick) + petal_sharpness * sin( sin( (atan(p.y, p.x) * petals + rot) - 1.4 )));\n    \n    col = vec3(0.0);\n        \n    bool result = false;\n    \n   \tfor( int j=0; j<blur; j++ )\n    for( int i=0; i<blur; i++ )\n    {\n        vec2 st = (p + (vec2(float(i-4),float(j-4)) / iResolution.xy ));\n        float t = length(st);\n        vec3 co = sky_col;\n        if((t > i_border && t < o_border) || (t > i_dotsize && t < o_dotsize)) {\n        \tif( (abs(t - mid_point) <  half_thick && (t - mid_point > 0.0)) || (t > i_dotsize && t < o_dotsize)) {\n        \t\tresult = true;\n            \tco = flower_col;\n            }\n        }\n        col += co;\n    }\n    \n    col = col / float(blur * blur);\n    col = mix(col, sky_col, 0.4);    \n    return result;\n}\n\nvec3 hitBackground(in vec2 screenCoord) {\n\tvec3 sky_col = drawSky(screenCoord);\n    \n    //Option to toggle flowers off\n    if(FLOWERS == 0) { return sky_col; }\n    \n    float small_time = mod(iTime+small_offset, small_speed);\n\tfloat medium_time = mod(iTime+medium_offset, medium_speed);\n\tfloat large_time = mod(iTime+large_offset, large_speed);\n    \n\tfloat small_x = mix(small_x_max,small_x_min,(small_time/small_speed));\n\tfloat medium_x = mix(medium_x_max,medium_x_min,(medium_time/medium_speed));\n\tfloat large_x = mix(large_x_max,large_x_min,(large_time/large_speed));\n    \n    vec2 small_q = screenCoord - vec2(small_x, small_y);\n\tvec2 medium_q = screenCoord - vec2(medium_x, medium_y);\n\tvec2 large_q = screenCoord - vec2(large_x, large_y);\n    \n    float transition = mod(iTime,FLOWER_COLOR_TIME+FLOWER_COLOR_TRANSITION) - FLOWER_COLOR_TIME;\n    transition = sign(transition) < 0.0 ? 0.0 : transition/FLOWER_COLOR_TRANSITION;\n    \n    float small_color = mod(floor(iTime/(FLOWER_COLOR_TIME+FLOWER_COLOR_TRANSITION)),float(small_num_flower_colors));\n    float medium_color = mod(floor(iTime/(FLOWER_COLOR_TIME+FLOWER_COLOR_TRANSITION)),float(medium_num_flower_colors));\n    float large_color = mod(floor(iTime/(FLOWER_COLOR_TIME+FLOWER_COLOR_TRANSITION)),float(large_num_flower_colors));\n    \n    vec3 small_flower_col = mix(small_flower_colors[int(small_color)],small_flower_colors[int(mod(small_color+1.0,float(small_num_flower_colors)))],transition);\n    vec3 medium_flower_col = mix(medium_flower_colors[int(medium_color)],medium_flower_colors[int(mod(medium_color+1.0,float(medium_num_flower_colors)))],transition);\n    vec3 large_flower_col = mix(large_flower_colors[int(large_color)],large_flower_colors[int(mod(large_color+1.0,float(large_num_flower_colors)))],transition);\n        \n    //Check if a flower is hit\n    vec3 col;\n    if(drawFlower(small_q, small_size, small_flower_col, sky_col, small_blur, small_rot, col)) {\n        return col;\n    } else if(drawFlower(medium_q, medium_size, medium_flower_col, sky_col, medium_blur, medium_rot, col)) {\n    \treturn col;\n    }\n    drawFlower(large_q, large_size, large_flower_col, sky_col, large_blur, large_rot, col);\n    return col;\n}\n\n//=================== Main Methods ===================\n\nvec3 trace(in vec3 ro, in vec3 rd, in vec2 screenCoord) {\n\tvec3 col;\n    \n    //Hits island or ocean\n    if(traceScene(ro, rd, col)) {\n       \treturn col;\n    //Hits Tree\n    } else if(intersect_tree(ro, rd, col)) {\n        return col;\n    }\n    \n    //Hits background\n    return hitBackground(screenCoord);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Set Up Camera\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro = vec3(0.0, 1.4, 0.0 );\n\tvec3 rd = normalize( vec3(p, -1.0) );\n    vec2 screenCoord = fragCoord / iResolution.xy;\n\t\n    fragColor.xyz = trace(ro, rd, screenCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// \"Cartoon low poly tree\" by PaulsenDesign\n// https://www.turbosquid.com/3d-models/free-3ds-model-trees-scene/961487\n\nconst int num_vertices = 348;\nconst int num_faces_tree = 480;\nconst int num_faces_trunk = 162;\n\nconst float vertices[348] = float[](\n0.471610862068966,-0.14918,0.08488000000000001,1.0155308620689663,-0.15012000000000003,0.08088000000000001,0.9385908620689662,0.59694,0.022320000000000003,0.5476708620689664,\n0.43636,0.020680000000000004,1.0195508620689662,-0.16852,-0.5412,0.9415508620689661,0.58552,-0.43928000000000006,0.4756108620689659,-0.16758,\n-0.5372,0.5506508620689665,0.42494,-0.44092000000000003,0.719010862068966,1.40958,0.10216000000000001,0.3528108620689665,1.40958,0.10216000000000001,\n0.719010862068966,1.40958,-0.26404,0.3528108620689665,1.40958,-0.26404,0.44623086206896617,2.54246,0.1263,0.18733086206896632,\n2.54246,0.1263,0.44623086206896617,2.54246,-0.13260000000000002,0.18733086206896632,2.54246,-0.13260000000000002,0.30279086206896655,2.8251600000000003,\n0.10522000000000001,0.5195308620689659,2.8251600000000003,0.10522000000000001,1.3043908620689664,4.78846,-0.028960000000000003,1.1623908620689662,4.78846,-0.028960000000000003,\n0.5195308620689659,2.8251600000000003,-0.11152000000000001,1.3043908620689664,4.78846,-0.17096,0.30279086206896655,2.8251600000000003,-0.11152000000000001,1.1623908620689662,\n4.78846,-0.17096,-0.8577891379310337,3.84732,-0.13682000000000002,-0.8577891379310337,3.84732,-0.06308000000000001,-0.9888891379310337,3.7700200000000006,\n-0.14734,-0.9888891379310337,3.7700200000000006,-0.05258000000000001,-1.4838091379310343,4.591620000000001,-0.10494000000000002,-1.4838091379310343,4.591620000000001,-0.09498000000000001,\n-1.5376491379310337,4.55988,-0.09928000000000001,-1.5376491379310337,4.55988,-0.10062,-1.298269137931034,5.9813600000000005,-0.6559,-1.9247091379310342,\n5.602,-0.7898000000000001,-1.249789137931034,5.67286,0.028460000000000003,-2.2877891379310342,5.25942,-0.141,-2.455289137931034,5.91592,\n0.33634000000000003,-1.9493691379310343,5.46316,0.7763200000000001,-0.741829137931034,5.962720000000001,-0.3758,-1.195529137931034,5.49336,0.61766,\n-0.6793091379310341,5.57604,0.45366,-0.588449137931034,5.53842,-1.02912,-0.0763491379310338,5.1360600000000005,0.09670000000000001,-0.42938913793103384,\n5.166720000000001,-0.77578,-1.421709137931034,5.829560000000001,-1.3645200000000002,-1.1667291379310336,5.0551,-1.3624,-1.904329137931034,5.035880000000001,\n-1.31756,-2.0212691379310335,5.28502,-0.73324,-2.689409137931034,4.7118,-0.5214000000000001,-2.558749137931034,4.914840000000001,0.22794,\n-2.1001891379310336,4.17762,-0.45274000000000003,-2.5786291379310344,4.12044,0.5131800000000001,-2.207209137931034,4.70992,0.73698,-2.010089137931034,\n4.592860000000001,1.05716,-1.337589137931034,5.06926,1.21076,-1.9405491379310342,4.42112,1.4135400000000002,-1.3211891379310339,4.3871,\n1.25468,-0.5830091379310339,5.1477200000000005,0.98916,-0.19504913793103357,4.98386,0.07406,-0.5395091379310337,4.3708599999999995,0.77452,\n-0.3120691379310337,3.843,0.21156000000000003,-0.29990913793103363,4.32748,-0.5038,-0.36832913793103406,4.48256,-0.8972,-0.2176491379310342,\n3.90828,-0.36338000000000004,-0.8147091379310339,4.01322,-0.8383200000000001,-1.1742491379310338,4.29656,-1.14414,-1.8493491379310336,4.87614,\n-1.18798,-1.6887691379310341,4.112760000000001,-0.60518,-1.2361691379310338,3.68468,0.28524,-1.3011291379310337,3.6423000000000005,1.01902,\n-1.923929137931034,3.9297400000000007,0.73704,-0.7295891379310341,3.9983199999999997,0.17438,-1.0010291379310339,3.8051200000000005,-0.35484000000000004,-1.814789137931034,\n3.68202,0.015359999999999999,1.4483308620689663,4.8239600000000005,-1.4212600000000002,0.672830862068966,4.6676,-1.2295800000000001,1.523730862068966,5.30258,\n-0.7566600000000001,0.30083086206896614,5.19962,-0.6134400000000001,0.3611708620689662,6.0169,-1.00016,0.8455708620689664,6.078600000000001,-0.26264,\n2.071550862068966,4.9379800000000005,-1.17042,1.6235708620689662,5.75422,-0.26364000000000004,2.1636908620689663,5.5107800000000005,-0.35236,2.0286308620689666,\n4.07394,-1.0987,2.6346108620689663,4.804460000000001,-0.0398,2.1402508620689664,4.08772,-0.5893200000000001,1.1742508620689662,4.11294,\n-1.6768999999999998,1.2478908620689664,3.66624,-0.9089600000000001,0.4727908620689661,3.8848599999999998,-0.97692,0.49963086206896606,4.58784,-0.9153800000000001,\n-0.31706913793103414,4.6711,-0.36210000000000003,-0.016409137931033515,5.44406,-0.13174,0.1791508620689662,4.32202,0.26532,-0.19506913793103353,\n5.323160000000001,0.7658,0.3781908620689663,5.7327200000000005,0.38656,0.6040908620689663,5.926200000000001,0.6978800000000001,1.4555108620689663,6.13764,\n0.43236,0.6872308620689666,6.158760000000001,1.06102,1.3073508620689662,5.836220000000001,1.10026,2.2370508620689664,5.7778,0.35228000000000004,\n2.4678508620689663,4.73754,0.07356,2.0549908620689665,5.17924,0.97464,2.0774308620689665,4.33016,1.20336,2.1056508620689662,\n3.8944400000000003,0.36560000000000004,2.0139508620689663,3.6184800000000004,-0.0015400000000000001,2.107530862068966,3.7977400000000006,0.84766,1.4342108620689662,3.55346,\n0.40508,1.0812908620689663,3.497,-0.07924,0.5097508620689659,3.9136400000000005,-0.7488800000000001,0.5734108620689661,4.0426400000000005,0.30598000000000003,\n1.075110862068966,4.5539000000000005,1.25394,1.1055108620689662,5.23972,1.6776800000000003,0.47987086206896595,5.274100000000001,1.1630200000000002,1.6712508620689661,\n4.47754,0.97494,1.2576308620689662,3.9521,0.8323800000000001,0.424670862068966,4.44452,1.02534);\n\nconst int faces_tree[480] = int[](\n33,34,35,34,36,37,34,37,35,35,37,38,33,35,39,\n35,38,40,35,40,39,39,40,41,33,39,42,39,41,43,\n39,43,42,42,43,44,33,42,45,42,44,46,42,46,45,\n45,46,47,33,45,34,45,47,48,45,48,34,34,48,36,\n36,49,50,49,51,52,49,52,50,50,52,53,38,54,55,\n54,53,56,54,56,55,55,56,57,41,58,59,58,57,60,\n58,60,59,59,60,61,44,62,63,62,61,64,62,64,63,\n63,64,65,47,66,67,66,65,68,66,68,67,67,68,51,\n53,54,50,54,38,37,54,37,50,50,37,36,57,58,55,\n58,41,40,58,40,55,55,40,38,61,62,59,62,44,43,\n62,43,59,59,43,41,65,66,63,66,47,46,66,46,63,\n63,46,44,51,49,67,49,36,48,49,48,67,67,48,47,\n69,70,71,70,57,56,70,56,71,71,56,53,69,72,70,\n72,61,60,72,60,70,70,60,57,69,73,72,73,65,64,\n73,64,72,72,64,61,69,74,73,74,51,68,74,68,73,\n73,68,65,69,71,74,71,53,52,71,52,74,74,52,51,\n75,76,77,76,78,79,76,79,77,77,79,80,75,77,81,\n77,80,82,77,82,81,81,82,83,75,81,84,81,83,85,\n81,85,84,84,85,86,75,84,87,84,86,88,84,88,87,\n87,88,89,75,87,76,87,89,90,87,90,76,76,90,78,\n78,91,92,91,93,94,91,94,92,92,94,95,80,96,97,\n96,95,98,96,98,97,97,98,99,83,100,101,100,99,102,\n100,102,101,101,102,103,86,104,105,104,103,106,104,106,105,\n105,106,107,89,108,109,108,107,110,108,110,109,109,110,93,\n95,96,92,96,80,79,96,79,92,92,79,78,99,100,97,\n100,83,82,100,82,97,97,82,80,103,104,101,104,86,85,\n104,85,101,101,85,83,107,108,105,108,89,88,108,88,105,\n105,88,86,93,91,109,91,78,90,91,90,109,109,90,89,\n111,112,113,112,99,98,112,98,113,113,98,95,111,114,112,\n114,103,102,114,102,112,112,102,99,111,115,114,115,107,106,\n115,106,114,114,106,103,111,116,115,116,93,110,116,110,115,\n115,110,107,111,113,116,113,95,94,113,94,116,116,94,93);\n\nconst int faces_trunk[162] = int[](\n1,2,3,1,3,4,2,5,6,2,6,3,5,7,8,\n5,8,6,7,1,4,7,4,8,4,3,9,4,9,10,\n3,6,11,3,11,9,6,8,12,6,12,11,8,4,10,\n8,10,12,9,13,14,9,14,10,11,15,13,11,13,9,\n11,12,16,11,16,15,10,14,16,10,16,12,17,18,19,\n17,19,20,18,21,22,18,22,19,21,23,24,21,24,22,\n23,17,20,23,20,24,13,18,17,13,17,14,21,18,13,\n21,13,15,23,21,15,23,15,16,17,23,25,17,25,26,\n23,16,27,23,27,25,16,14,28,16,28,27,14,17,26,\n14,26,28,29,26,25,29,25,30,25,27,31,25,31,30,\n31,27,28,31,28,32,28,26,29,28,29,32);","name":"Common","description":"","type":"common"}]}