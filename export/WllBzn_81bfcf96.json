{"ver":"0.1","info":{"id":"WllBzn","date":"1595856274","viewed":76,"name":"The croco","username":"MonsieurSoleil","description":"Why on earth did i do that ???","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingtest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\nstruct matter\n{\n    float m;\n    int type;\n    bool reflected;\n    float shad;\n};\n    \nvec3 hash33(vec3 p)\n{\n  \tuvec3 q = uvec3(ivec3(p)) * UI3;\n    q = (q.x ^ q.y ^ q.z) * UI3;\n    return -1. + 2.0 * vec3(q) * UIF;\n}\n\nfloat worleyNoise(vec3 uv, float freq, bool tileable)\n{\n \tvec3 id = floor(uv);\n    vec3 p = fract(uv);\n    float minDist = 10000.0;\n    \n    for(float x = -1.; x <= 1.; ++x)\n    {\n     \tfor(float y = -1.; y <= 1.; ++y)\n        {\n         \tfor(float z = -1.; z <= 1.; ++z)\n            {\n             \tvec3 offset = vec3(x, y, z);\n                vec3 h = vec3(0.);\n                if(tileable)\n                    h = hash33(mod(id + offset, vec3(freq))) * 0.4 + 0.3;\n                else \n\t\t\t\t\th = hash33(id + offset) * 0.4 + 0.3;\n                h += offset;\n                vec3 d = p - h;\n                minDist = min(minDist, dot(d, d));\n\n            }\n        }\n    }\n\n\treturn 1.0 - minDist;\n}\n\nfloat worleyFbm(vec3 p, float freq, bool tileable)\n{\n    float fbm = worleyNoise(p * freq, freq, tileable) * .625 +\n\t\t\t\tworleyNoise(p * freq * 2.0, freq, tileable) * .25 +\n        \t\tworleyNoise(p * freq * 4.0, freq, tileable) * .125;\n    \n    return max(0., fbm * 1.1 - 0.1);\n}\n    \nvec3 tonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n    \nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n    \nmat2 rot(float a)\n{\n \tfloat ca = cos(a);\n    float sa = sin(a);\n    \n    return mat2(ca, sa, -sa, ca);\n}\n    \nvec2 hash( vec2 p )\n{\n    p= vec2( dot(p, vec2(127.11, 351.5)),\n       \t\tdot(p, vec2(2.65, 183.1)));\n    \n    return -1.0 + 2.0 * fract( sin(p) * 45687.2365);\n}\n\nvec2 hash22(vec2 x)\n{\n \treturn fract( sin( vec2( dot(x, vec2(12.4, 16.4)), dot(x, vec2(23.1, 28.37)))) * 12.4);   \n}\n\nvec3 random3f( vec3 p )\n{\n\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,4512.0,121546.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n    \nconst float pi = 3.14159;\n\nfloat gg = 0.0;\n\nfloat opSJ(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat opSS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5 * (d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat cyl(vec2 p, float s)\n{\n    return length(p) - s;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n \tfloat mat01, mat02, eye, museauHaut, museauBas, bouche, iris;\n    \n    vec3 p01 = p;\n    p01 = vec3(abs(p.x), p.yz);\n    vec3 p02 = p01, p03 = p01, p04 = p, p05 = p, p06 = p;\n    \n    // Tete globale\n    mat01 = sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.5,3.25),  1.5, 0.5);\n    \n     //Coupe tête\n//\tmat01 = max(mat01, - box(p - vec3(0.0, -2.25, 0.0), vec3(15.0, 1.5, 15.0)));\n\n    //\tFormation Tete museau\n\t//mat01 = opSS(sphere(p - vec3(0.0, 1.55, 1.55), 0.45), mat01, 0.4);\n    //mat01 = opSS(sphere(p - vec3(0.0, 1.75, 1.25), 0.45), mat01, 0.3);\n    \n    \n    \n   \tmat01 = opSS(sdRoundCone(p, vec3(0.0,1.5,2.5), vec3(0.0,1.7,-1.0),  0.5, 0.5), mat01, 0.6);\n   \n    //mat01 = opSS(sphere(p - vec3(0.0, 1.85, 1.4), 1.05), mat01, 0.2);\n    \n    mat01 = opSS(cyl(p02.xz - vec2(1.5, 1.55), 0.3), mat01, 1.1);\n\tmat01 = opSS(cyl(p02.xz - vec2(1.2, 2.25), 0.3), mat01, 1.1);\n    mat01 = opSS(cyl(p02.xz - vec2(1.2, 1.05), 0.2), mat01, 0.7);\n    \n    \n    mat01 = opSS(sdRoundCone(p02, vec3(1.25,1.0,2.5), vec3(1.25,1.0,-1.0),  0.5, 0.1), mat01, 0.5);\n    \n    //mat01 = opSS(sphere(p - vec3(0.0, 1.75, 2.65), 1.0), mat01, 0.4);\n    \n    p03 -= vec3(0.3, 1.0, 3.3);\n    p03.xy *= rot(0.6);\n    //mat01 = opSJ(sdEllipsoid(p03 , vec3(0.25, 0.05, 0.2)), mat01, 0.4);\n\n    \n    // Machoire bas\n    mat01 = opSS(sdRoundCone(p, vec3(0.0,-0.0,3.5), vec3(0.0,-0.5,-0.0),  0.5, 0.7), mat01, 0.6);\n    p04.zy *= rot(0.1);\n    p04.zy *= rot(-0.4 * abs(sin(iTime * 1.75)));\n    \n    bouche = sdRoundCone(p04, vec3(0.0,0.2,3.0), vec3(0.0,-0.4,-0.0),  0.4, 0.7);\n    bouche = max(bouche, -box(p04 + vec3(0.0, -0.65, 0.0), vec3(2.0, 0.5, 5.0)));\n    \n    bouche = opSJ(sdEllipsoid(p04 - vec3(0.22, -0.0, 3.3), vec3(0.10, 0.200, 0.20)), bouche, 0.3);\n    bouche = opSJ(sdEllipsoid(p04 - vec3(-0.22, -0.0, 3.3), vec3(0.10, 0.200, 0.20)), bouche, 0.3);\n    \n    mat01 = min(mat01, bouche);\n    \n    //Tête nuque\n    mat01 = opSS(sphere(p - vec3(1.5, 0.55, -1.05), 0.6), mat01, 0.6);\n    mat01 = opSS(sphere(p - vec3(-1.5, 0.55, -1.05), 0.6), mat01, 0.6);\n    \n\tmat01 = opSS(sphere(p - vec3(0.0, 1.05, -1.50), 1.0), mat01, 0.4);\n    \n    //Coup corps\n    mat01 = opSJ(sdRoundCone(p, vec3(0.0,-2.0,0.25), vec3(0.0,-0.5, -0.5),1.2, 1.1), mat01, 0.7);\n\n    // Yeux\n    eye = sphere(p02 - vec3(0.85, 0.7, 0.455), 0.225);\n    iris = sphere(p02 - vec3(0.88, 0.72, 0.66), 0.080);\n    mat01 = opSJ(sdEllipsoid(p02 - vec3(0.28, 0.8, 3.4), vec3(0.15, 0.250, 0.25)), mat01, 0.2);\n    mat01 = opSS(cyl(p02.yz - vec2(1.35, 1.45), 0.35), mat01, 0.4);\n    \n    mat01 = max(mat01, -sdEllipsoid(p02 - vec3(0.52, 0.8, 3.55), vec3(0.2, 0.05, 0.14)));\n    \n    //mat01 = opSS(sphere(p - vec3(0.0, -0.55, -2.0), 1.45), mat01, 0.3);\n    \n    /*mat01 = opSS(sphere(p - vec3(0.0, 0.4, 1.25), 0.5), mat01, 0.5);\n\n    //Creux museau\n    //mat01 = min(sdRoundCone(p, vec3(0.0,0.65,2.25), vec3(0.0,0.9,0.5),  0.5, 0.2), mat01);\n    mat01 = opSS(sdRoundCone(p, vec3(0.0,1.1,2.25), vec3(0.0,0.9,0.5),  0.30, 0.2), mat01, 0.8);\n\n        //Creux tete\n        mat01 = opSS(sdRoundCone(p, vec3(0.0,1.7,-0.9), vec3(0.0,1.3,2.05),  1.2, 0.2), mat01, 0.8);\n        //mat01 = min(sdRoundCone(p, vec3(0.0,1.7,-0.5), vec3(0.0,1.4,2.05),  0.6, 0.2), mat01);\n\n        //CreuxCils\n        mat01 = opSS(sdRoundCone(p, vec3(1.5,0.3,-0.1), vec3(0.8,0.05,0.65), 0.25, 0.1), mat01, 0.25);\n        mat01 = opSS(sdRoundCone(p, vec3(-1.5,0.3,-0.1), vec3(-0.8,0.05,0.65), 0.25, 0.1), mat01, 0.25);\n\n        // Joues\n        mat01 = opSJ(mat01, sphere(p + vec3(0.8, 0.5, 0.0), 0.3), 0.8);\n        mat01 = opSJ(mat01, sphere(p + vec3(-0.8, 0.5, 0.0), 0.3), 0.8);\n\n\n\n        // Bouche\n        mat01 = opSS(sdRoundCone(p, vec3(0.0,-0.5,2.45), vec3(0.0,-0.5,0.6),  0.5, 0.7), mat01, 0.6);\n        //mat01 = min(sdRoundCone(p, vec3(0.0,-0.5,2.45), vec3(0.0,-0.5,0.6),  0.6, 0.7), mat01);\n\n        p05.yz *= rot(0.5 * abs(sin(iTime * 4.0)) + 0.0);\n        bouche = max(sdRoundCone(p05, vec3(0.0,-0.4,0.4), vec3(0.0,-0.3,1.5),  0.75, 0.5), -box(p05 - vec3(0.0, -0.05, 0.0), vec3(2.0, 0.3, 2.2)));\n\n        mat01 = opSJ(bouche, mat01, 0.15);\n\n            //Bouts naseaux\n            p03 = vec3(abs(p.x), p.yz);\n        p04 = p03;\n\n        p04 -= vec3(0.26, 0.295, 2.45);\n        p04.xy *= rot(-0.7);\n\n        mat01 = opSJ(sdEllipsoid(p04, vec3(0.25,0.15,0.25)), mat01, 0.28);\n\n\n\n            //Creux naseaux\n            p03 -= vec3(0.4, 0.215, 2.850);\n        p03.xy *= rot(-0.4);\n        mat01 = opSS(sdEllipsoid(p03, vec3(0.2,0.1,0.1)), mat01, 0.01);\n\n\n            // Ajustements\n            p06 = vec3(abs(p.x), p.yz);\n        float d1 = length(p06.xz - vec2(1.2, 1.85)) - 0.4;\n        mat01 = opSS(d1, mat01, 0.5);\n\n        float d2 = length(p.yz - vec2(1.3, 1.25)) - 0.3;\n        mat01 = opSS(d2, mat01, 0.9);\n\n        float d3 = length(p06.xz - vec2(1.2, 1.05)) - 0.2;\n        mat01 = opSS(d3, mat01, 0.2);\n\n        float d4 = length(p.yz - vec2(0.7, -0.85)) - 0.3;\n        mat01 = opSS(d4, mat01, 0.8);*/\n            //p03.zy *= rot(sin(iTime));\n\n            //museauHaut = sdCappedCone(p, vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), 0.15, 0.05);\n            /*museauHaut = box(p01 + vec3(0.0, -0.2, -1.5), \n        vec3(0.5 * (clamp(abs(1.0 - pow((p.y * 3.0), 2.6)) * \n        (abs(sin(1.0 - (p.z * 0.35)) * 1.0)), 0.0, 1.0 ))\n        , 0.055, \n        0.8 * (clamp(1.0 - p.y, 0.0, 1.0))));\n\n        museauBas = box(p03 + vec3(0.0, 0.1, -1.5), \n        vec3(0.5 * sin(1.0 - (p.z * 0.35))\n        , 0.055, \n        0.8));*/\n\n\n\n\n        \n\n       /*p02.xy *= rot(-0.1);\n        mat01 = min(mat01, sdEllipsoid(p02 - vec3(0.35, 0.7, 0.65), vec3(0.05, 0.1, 0.2)));*/\n\n\n        mat.m = mat01;\n\n        if(mat.m < 0.05)\n        {\n\n            float up = clamp(((p.y + 0.95) * 0.3), 0.0, 2.0);\n            if(up > 0.0)\n            {\n                vec3 v = voronoi(16.0*p);\n                mat.m -= 0.025 * (v.y-v.x) * up;\n                mat.type = 0;   \n            }\n        }\n\n        if(eye < 0.01)\n        {\n            mat.type = 1;   \n        }\n    \n        if(iris < 0.01)\n        {\n            mat.type = 2;   \n        }\n\n        mat.m = min(eye, mat.m);\n     \tmat.m = min(iris, mat.m);\n}\n\nvec3 normals(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n    \n    matter m01, m02, m03, m04;\n    \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n    \n    return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n\nvec3 subsurface( vec3 p, vec3 dir )\n{\nvec3 density = pow(vec3(0.7, 0.5, 0.4), vec3(0.4));\n  float confidence = .01;\n  vec3 visibility = vec3(1.0);\n    \n    matter m01;\n  map(m01, p);\n  float lastVal = m01.m; \n  float soft = 0.0;\n  for(int i = 1; i < 15; ++i)\n  {\n    if( visibility.x < confidence )\n    {\n      continue;\n    }\n    map(m01, p);\n    float val = m01.m;\n    \n    vec3 softened = pow(density, vec3(smoothstep(soft, -soft, val)));\n    \n    if( (val-soft) * lastVal < 0.0 )\n    {\n      float transition = -min(val-soft, lastVal)/abs(val-soft-lastVal);\n      visibility *= pow(softened, vec3(transition));\n    }\n    \n    else if( val-soft < 0.0 )\n    {\n      visibility *= softened;\n    }\n    \n    soft += 0.1;\n    lastVal = val+soft;\n    p += dir * 0.4;\n  }\n  \n  return visibility;\n}\n\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0)\n{\n  float alpha = rough*rough;\n  float asqrt = alpha*alpha;\n  vec3 h = normalize(v + l);\n  \n  float dnl = clamp(dot(n, l), 0.0, 1.0);\n  float dnv = clamp(dot(n, v), 0.0, 1.0);\n  float dnh = clamp(dot(n, h), 0.0, 1.0);\n  float dlh = clamp(dot(l, h), 0.0, 1.0);\n  \n  float f, d, vis;\n  float den = dnh*dnh*(asqrt - 1.0) + 1.0;\n  d = asqrt/(pi * den * den);\n  dlh = pow(1.0 - dlh, 5.0);\n  f = f0 + (1.0 - f0)*dlh;\n  float k = alpha/1.0;\n  vis = G1V(dnl, k)*G1V(dnv, k);\n  \n  \n  float spec = dnl * d * f *vis;\n  return spec;\n}\n\nfloat getao(vec3 p, vec3 n, float h)\n{\n  matter m01;\n  map(m01, p+n*h);\n  return clamp(m01.m / h, 0.0, 1.0);\n}\n\nfloat shadow(vec3 p, vec3 l, int stepC, float limit)\n{\n  matter m01;\n  for(int i = 0; i < stepC; ++i)\n  {\n     map(m01, p);\n    float d = m01.m;\n    \n    if(d < limit)\n    {\n      return 0.0;\n      break;\n    }\n    if(d > 20.0)\n    {\n     \treturn 1.0;   \n    }\n    \n    p += d * l;\n  }\n  \n   return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 l = vec3(0.0, 1.5, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 o = vec3(5.0 * cos(iTime * 0.3), 1.5, 5.0 * sin(iTime * 0.3)), t = vec3(0.0, 0.5, 1.2);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p = dir * 0.5 + o;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    matter mat;\n    float dd = 0.0, shad = 0.0;\n    \n    for(int i = 0; i< 150; ++i)\n    {\n\t\tmap(mat, p);\n        \n        if(mat.m < 0.01)\n        {\n            shad = 1.0;\n            break;\n        }\n        \n        //col += gg *0.00375 * vec3(1.0);\n        \n        p += dir * mat.m * 0.75;\n        dd += mat.m* 0.75;\n        \n        /*if(dd >= 15.0)\n            break;*/\n    }\n    \n    vec3 n = normals(p);\n    float range = sqrt(dot(uv,uv));\n    //col += vec3(1.0) * clamp(dot(l, n), 0.0, 1.0) * shad;\n    float fog = clamp(dd/100.0, 0.0, 1.0);\n    //hsl(60,56%,91%)\n    vec3 Fogcolor = mix(vec3(0.5), vec3(0.2), pow(range * 0.75, 1.2));\n        \n     vec3 skycolor = mix(vec3(0.08, 0.38, 0.15), vec3(0.9, 0.85, 0.7), pow(1.0-(clamp(uv.y+0.5, 0.0, 1.0)), 0.7));\n    \n   if(shad >= 0.0)\n  {\n      \n    vec3 n = normals(p);\n    vec3 ld = normalize(l);\n    float fresnel = pow( max(0.0, 1.0 + dot(n, dir)), 3.0 );\n    \n    \n    vec3 albedo = vec3(1.0);\n    \n    vec3 lamb = vec3(max(0.0, dot(n, ld)));\n    float spec = ggx(n, dir, ld, 3.0, fresnel);\n\t\n    vec3 ss = subsurface(p, dir);\n\n    \n      \n\n    \n      \n      if(mat.type == 1 || mat.type == 2)\n      {\n          //lamb = mix(lamb, ss, 0.0);\n\t\t\t//col += (vec3(1.0) * spec + (lamb * vec3(1.0))) * 1.0;\n    \t\t//col += (vec3(1.0) * fresnel) * 1.0;\n          \t//col = vec3(1.0);\n          col = mat.type == 1 ? vec3(0.8, 0.6, 0.2) : vec3(0.0);\n          \n          \n      } else {\n          float up = clamp(((p.y + 0.85) * 1.5), 0.0, 1.0);\n\n          if(up > 0.0)\n          {\n              float r = worleyFbm(vec3(p.x, p.z, 1.0), 3.5, true);\n              float g = worleyFbm(vec3(p.x, p.z, 1.0), 0.5, true);\n              \n              skycolor = mix(skycolor, /*vec3(0.27, 0.44, 0.3)*/ vec3(0.05), g * up * 1.5);\n              skycolor = mix(skycolor, /*vec3(0.27, 0.44, 0.3)*/ vec3(0.67, 0.5, 0.1), r * up * 0.4);\n          }\n          \n          lamb = mix(lamb, ss, 0.2);\n          //float s = shadow(p + n * 0.15, l, 30, 0.075);\n          col += (vec3(1.0) * spec + (lamb * skycolor)) * 0.7;\n\n        //color += ((lamb * albedo));\n        //col += (skycolor * fresnel) * 1.0;\n          \n         float ao = 0.0;\n          for(int i = 0; i < 4; ++i)\n          {\n\t\t\t\n            ao += getao(p, n, float(i) * 0.50);\n          }\n          ao /= 4.0;\n          col *= ao;\n\t\t\n          \t\n          //col += clamp(dot(n, l), 0.0, 1.0) * vec3(1.0, 0.8, 0.6) * s;\n          //col += clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.0, 1.0) * vec3(0.5, 0.5, 1.0) * 0.5;\n          \n      }\n    \n  }\n   \tcol += fog * Fogcolor * 0.5;\n\n    col = tonemapACES(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}