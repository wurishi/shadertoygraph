{"ver":"0.1","info":{"id":"NtVcRw","date":"1661195190","viewed":312,"name":"Raytracing Textures and Cubemaps","username":"Poisson","description":"A simple raytracer with soft shadow, (fake) reflections, cubemaps, and biplanar mapping;","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracer","ray","texture","shadow","cubemap","textures","box","skybox","softshadow","cubemaps","biplanarmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU 6.283185\n#define SOFT_SHADOW_SAMPLES 16 // soft shadows quality\n#define AA 3 // antialiasing / set it to 1 if you have a slow computer\n\n// rotation function\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct Ray {\n    vec3 o, d; // origin and direction\n};\n\nstruct Camera {\n    vec3 o, d; // origin and direction\n    float z; // zoom\n};\n\n//ray setup function\nRay getRay(vec2 uv, Camera c) {\n    vec3 f = normalize(c.d - c.o);\n    vec3 s = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, s);\n    vec3 i = normalize(f*c.z + uv.x*s + uv.y*u);\n    \n    return Ray(c.o, i);\n}\n\nstruct Record {\n    float t;\n    vec3 p, n; // position and normal\n    int tex; // texture\n};\n\n// sphere intersection function\nbool iSphere(vec3 c, float s, Ray r, inout Record rec) {\n    float t = dot(c - r.o, r.d);\n    vec3 p = r.o + r.d * t;\n    float a = length(p - c);\n    if (s*s - a*a > 0.0) {\n        float b = sqrt(s*s - a*a);\n        t -= b;\n        if (t > 1e-6 && t < rec.t) {\n            rec.t = t;\n            rec.p = r.o + r.d * t;\n            rec.n = normalize(rec.p - c);\n            rec.tex = 1;\n            return true;\n        }\n    }\n    return false;\n}\n\n// plane intersection function\nbool iPlane(vec3 n, float h, float s, Ray r, inout Record rec) {\n    float t = (-h - dot(n, r.o)) / dot(n, r.d);\n    vec3 p = r.o + r.d * t;\n    \n    if (t > 1e-6 && t < rec.t && length(p) < s+sin(p.x)*sin(p.z)) {\n        rec.t = t;\n        rec.p = p;\n        rec.n = n;\n        rec.tex = 2;\n        return true;\n    }\n    return false;\n}\n\n// box intersection function by iq: https://www.shadertoy.com/view/ld23DV\nbool iBox(vec3 p, vec3 s, Ray r, inout Record rec) {\n    vec3 m = 1./r.d;\n    vec3 n = m*(r.o - p);\n    vec3 k = abs(m)*s;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if( tN>tF || tF<1e-6) {\n        return false;\n    }\n    if (tN > 1e-6 && tN < rec.t) {\n        rec.t = tN;\n        rec.p = r.o + r.d * tN;\n        rec.n = -sign(r.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        rec.tex = 0;\n        return true;\n    }\n}\n\n// intersect scene\nbool intersect(Ray r, out Record rec) {\n    rec.t = 1e10;\n    bool hit = false;\n\n    hit = iPlane(vec3(0,1,0), .5, 5., r, rec) || hit;\n    hit = iBox(vec3(0), vec3(.5,.25,.75), r, rec) || hit;\n    hit = iSphere(vec3(0,.9+.2*sin(2.5*iTime),0), .3, r, rec) || hit;\n    \n    return hit;\n}\n\n// biplanar mapping\nvec3 applyTexture(sampler2D tex, vec3 p, vec3 n, float k) {\n     p = .5+.5*p;   \n     \n     vec3 xy = texture(tex, p.xy).rgb;\n     vec3 xz = texture(tex, p.xz).rgb;\n     vec3 yz = texture(tex, p.yz).rgb;\n            \n     n = abs(n);\n     n = pow(n, vec3(k));\n     n /= dot(n, vec3(1));\n            \n     return xy*n.z + xz * n.y + yz*n.x;\n}\n\n// soft shadow\nfloat calcSoftshadow(vec3 ro, vec3 rd, int q, float k) {\n    Ray r;\n    r.o = ro;\n    Record rec;\n    float res = 1.;\n    for (int i = 0; i < q; i++) {\n        float o = float(i)/float(q);\n        r.d = normalize(rd + o*k*vec3(0,1,0)); \n        if (intersect(r, rec)) res -= 1./float(q);\n    }\n    return res;\n}\n\nvec3 render(Ray r) {\n    Record rec;\n    bool hit = intersect(r, rec);\n        \n    vec3 col = texture(iChannel3, r.d).rgb;\n    if (hit) {\n        // color / lighting\n        vec3 lig = normalize(vec3(-3,4,-1) - rec.p);\n        float dif = clamp(dot(rec.n, lig), 0., 1.); // difuse lighting\n        float sha = calcSoftshadow(rec.p, lig, SOFT_SHADOW_SAMPLES, .1);\n        float occ = .5+.5*rec.n.y; // fake occlusion\n        float fre = pow(1.+dot(r.d, rec.n), 2.);\n\n        if (rec.tex == 0) {\n            col = applyTexture(iChannel0, rec.p, rec.n, 32.);\n        } else if (rec.tex == 1) {\n            col = applyTexture(iChannel1, rec.p, rec.n, 16.);\n        } else if (rec.tex == 2) {\n            col = applyTexture(iChannel2, rec.p*.5, rec.n, 16.);\n        }\n        \n        float ref = calcSoftshadow(rec.p, reflect(r.d, rec.n), SOFT_SHADOW_SAMPLES, .0);\n        \n        vec3 refTex = texture(iChannel3, reflect(r.d, rec.n)).rgb;\n        col += 1.5*refTex*ref*fre; // fake reflections\n        col *= dif * sha + occ * vec3(.05,.1,.15);\n    }\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // antialiasing by iq\n    vec3 tot = vec3(0);\n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n        vec2 o = vec2(i, j) / float(AA) - .5;\n        vec2 uv = (fragCoord + o - .5 * iResolution.xy) / iResolution.y;\n\n        vec3 camPos = vec3(0,mouse.y * 2.,-2);\n        camPos.xz *= rot(-mouse.x*TAU - .5*iTime);\n        \n        Ray r = getRay(uv, Camera(camPos, vec3(0,.25,0), .9));\n;\n        vec3 col = render(r);\n        \n        col = pow(col, vec3(.4545)); // gamma corection\n        col *= 1.-.15*dot(uv,uv); // vignetting\n        tot += col;\n    }\n    }\n    tot /= float(AA*AA);\n        \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}