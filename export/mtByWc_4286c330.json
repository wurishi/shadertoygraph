{"ver":"0.1","info":{"id":"mtByWc","date":"1692351747","viewed":451,"name":"cubePlane 3D","username":"linround","description":"渲染了立方体的三个面。","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3dcubetransparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926\n#define TWO_PI 6.28318530718\n\nconst vec3 projectPoint = vec3(0.,0.,100.);\nconst vec3 viewPlane = vec3(0.,0.,5.);\n\n\nmat4 roateMat(in vec3 u,in float theta){\n    float c = cos(theta) ;\n    float s = sin(theta);\n    u = normalize(u);\n    // 以下是构建一个三维旋转矩阵的列\n    vec4 c0 = vec4(u.x*u.x*(1.0-c)+c,u.x*u.y*(1.-c)+u.z*s,u.x*u.z*(1.-c)-u.y*s,0.0);\n    vec4 c1 = vec4(u.x*u.y*(1.-c)-u.z*s,u.y*u.y*(1.-c)+c,u.y*u.z*(1.-c)+u.x*s,0.0);\n    vec4 c2 = vec4(u.z*u.x*(1.-c)+u.y*s,u.z*u.y*(1.-c)-u.x*s,u.z*u.z*(1.-c)+c,0.0);\n    vec4 c3 = vec4(0.,0.,0.,1.);\n    return mat4(c0,c1,c2,c3);\n}\n\n\n// 点的正交投影\nvec2 pointOrthographic(in vec3 point){\n    return vec2(point.x,point.y);\n}\n\n// 计算投影缩放后的比例\n// s 是投影前的三维空间坐标\n// t 是投影后的三维空间坐标\n// 计算得到 投影后/投影前 的比例\nfloat getAspect(in vec3 s,in vec3 t){\n    float aspect = (t.x-projectPoint.x)/(s.x-projectPoint.x);\n    return aspect;\n}\n\n// A B C 是未投影平面中不共线的三个顶点\n// 求一个面上某个点的坐标\nvec3 zFix(in vec3 point,in vec3 A,in vec3 B,in vec3 C,in float aspect){\n    // 平面中的两个向量\n    vec3 v0 = B-A;\n    vec3 v1 = C-A;\n    // 求两个向量构成的平面的法向量\n    vec3 normal = cross(v1,v0);\n    float d = -normal.x*A.x-normal.y*A.y-normal.z*A.z;\n    float x = projectPoint.x + (point.x-projectPoint.x)*aspect;\n    float y = projectPoint.y + (point.y-projectPoint.y)*aspect;\n    float z = -(normal.x*x+normal.y*y+d)/normal.z;\n\n    return vec3(x,y,z);\n}\n\n\n// 点的透视投影\n// 这里不考虑斜切的情况\nvec2 pointPerspective(vec3 point){\n\n    // 利用相似三角形原理\n    float aspect = (viewPlane.z - projectPoint.z)/(point.z-projectPoint.z);\n    float x = aspect * (point.x-projectPoint.x)+projectPoint.x;\n    float y = aspect * (point.y-projectPoint.y)+projectPoint.y;\n    return vec2(x,y);\n}\n\n\n// 定义立方体的八个顶点\nvec3 vertexCubes[8] = vec3[](\n    vec3(1.,1.,1.),\n    vec3(-1.,1.,1.),\n    vec3(-1.,1.,-1.),\n    vec3(1.,1.,-1.),\n    vec3(1.,-1.,-1.),\n    vec3(1.,-1.,1.),\n    vec3(-1.,-1.,1.),\n    vec3(-1.,-1.,-1.)\n);\n\n// 定义三角形顶点\n// 依次定义 前后 上下 左右\nint triangleVertexA[12] = int[](2,3,0,0,   0,0,4,4,   1,1,0,0);\nint triangleVertexB[12] = int[](3,7,1,6,   1,2,5,6,   2,7,3,5);\nint triangleVertexC[12] = int[](7,4,6,5,   2,3,6,7,   7,6,4,4);\n// 定义每个三角形的颜色\nconst float transparency = 0.5;\nvec4 triangleColor[12] = vec4[](\n    vec4(0.5,0.5,0.5,transparency), // 前\n    vec4(0,1,0,transparency), // 前\n    vec4(1,1,1,transparency), // 后\n    vec4(0,0,1,transparency), // 后\n\n    vec4(1,0,1,transparency), // 上\n    vec4(0,1,0,transparency), // 上\n    vec4(1,1,0,transparency), // 下\n    vec4(1,0,0,transparency), // 下\n\n    vec4(1,0,0,transparency), // 左\n    vec4(1,1,0,transparency), // 左\n    vec4(1,0,1,transparency), // 右\n    vec4(0,0,1,transparency)  // 右\n);\n\n\nbool sameSide(in vec2 uv,in vec3 A,in vec3 B,in vec3 C){\n    vec3 p = vec3(uv,0.0);\n    // 以A为起点 AB为某一边\n    // AC和Ap 分别与AB 边进行叉乘\n    // 最终根据两者的叉乘结果 来判断 点p 和 点C 是否在AB边的同一侧\n    vec3 side = B-A;\n    vec3 n1 = cross(side,C-A);\n    vec3 n2 = cross(side,p-A);\n    if(dot(n1,n2)>=0.){\n        return true;\n    }\n    return false;\n\n}\nbool inSide(vec3 triangleVertex[3],in vec2 uv){\n\n    if(\n    sameSide(uv,triangleVertex[0],triangleVertex[1],triangleVertex[2]) &&\n    sameSide(uv,triangleVertex[1],triangleVertex[2],triangleVertex[0]) &&\n    sameSide(uv,triangleVertex[2],triangleVertex[0],triangleVertex[1])\n    ){ return true; }\n\n    return false;\n}\nvec3[3] projectVertex(in vec3 triangle[3]){\n    vec2 A = pointPerspective(triangle[0]);\n    vec2 B = pointPerspective(triangle[1]);\n    vec2 C = pointPerspective(triangle[2]);\n    return vec3[3](\n    vec3(A,0.0),\n    vec3(B,0.0),\n    vec3(C,0.0)\n    );\n}\n\n\nvec3 renderTriangle(in vec2 st ){\n    vec3 color = vec3(0.0);\n    vec3 sourceTriangle[3];\n\n    mat4 roate = roateMat(vec3(sin(iTime)*2.,1,0),iTime*PI/4.0);\n    float size = 2.0;\n    for(int i=0;i<8;i++){\n        vertexCubes[i] =(roate*vec4(vertexCubes[i],0.0)).xyz;\n    }\n    float deepth = -100.;\n    for(int i=0;i<12;i++){\n        // 获取三角形的三个顶点\n\n        sourceTriangle[0] = vertexCubes[triangleVertexA[i]];\n        sourceTriangle[1] = vertexCubes[triangleVertexB[i]];\n        sourceTriangle[2] = vertexCubes[triangleVertexC[i]];\n        vec3[3] targetTriangle = projectVertex(sourceTriangle); // 对坐标点进行投影\n\n        // 投影后判断坐标点是否在当前三角形内部\n        if(inSide(targetTriangle,st)){\n            float aspect = getAspect(sourceTriangle[0],targetTriangle[0]);\n            vec3 point = zFix(\n                vec3(st,viewPlane.z),\n                sourceTriangle[0],\n                sourceTriangle[1],\n                sourceTriangle[2],\n                aspect\n            );\n            float z = point.z;\n            if(z>=deepth){\n                deepth = z;\n                color = mix(color,triangleColor[i].xyz,triangleColor[i].w);\n            }\n        }\n    }\n\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    // 将范围转换为[-1,1]\n    st = (st*2.0)-1.0;\n    st.x = st.x*iResolution.x/iResolution.y;\n    // 将范围转换为[-2,2]\n    st*=2.0;\n    vec3 color = renderTriangle(st);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}