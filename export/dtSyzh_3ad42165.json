{"ver":"0.1","info":{"id":"dtSyzh","date":"1692162777","viewed":64,"name":"light2d_4_reflection","username":"shicz86","description":"2d ray marching\nthis demo can be optimised,but i just want to translate the orginal c version to shadertoy.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec4 data = texture(iChannel0,uv);\n    vec3 col = data.xyz/data.w;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ref:https://zhuanlan.zhihu.com/p/30961545\n\n// light2d_1_basic        https://www.shadertoy.com/view/DtSczR\n// light2d_2_csg          https://www.shadertoy.com/view/mlSyzz\n// light2d_3_shape        https://www.shadertoy.com/view/ctjyzR\n// light2d_4_reflection   https://www.shadertoy.com/view/dtSyzh\n// light2d_5_refraction   https://www.shadertoy.com/view/ctjcRc\n// light2d_6_fresnel      https://www.shadertoy.com/view/Dl2czt\n// light2d_7_beer-lambert https://www.shadertoy.com/view/dl2yWG\n\n#define TWO_PI 6.28318530718f\n#define N 64\n#define MAX_STEP 64\n#define MAX_DISTANCE 5.0f\n#define EPSILON 1e-6f\n#define SHOW_NORMAL 0\n#define MAX_DEPTH 4\n#define BIAS 1e-4f\n\nstruct Result\n{\n    float sd;\n    float emissive;\n    float reflectivity;\n};\n\nfloat random (vec2 pos) \n{\n    return fract(sin(dot(pos.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// n should be a normalized vector\nvec2 Reflect(vec2 i,vec2 n)\n{\n    return i-2.0f*dot(i,n)*n;\n}\n\nResult unionOp(Result a,Result b)\n{\n    if(a.sd<b.sd)\n        return a;\n    else\n        return b;\n}\n\nResult intersectOp(Result a,Result b)\n{\n    Result r;\n    float sd;\n    if(a.sd>b.sd)\n    {\n        r = b;\n        sd = a.sd;\n    }\n    else\n    {\n        r = a;\n        sd = b.sd;\n    }\n    r.sd = sd;\n    return r;\n}\n\nResult subtractOp(Result a,Result b)\n{\n    Result r = a;\n    float sd;\n    if(a.sd>-b.sd)\n        sd = a.sd;\n    else\n        sd = -b.sd;\n    r.sd = sd;\n    return r;\n}\n\nfloat CircleSDF(vec2 pos,vec2 center,float r)\n{\n    return length(pos-center)-r;\n}\n\nfloat PlaneSDF(vec2 pos,vec2 p,vec2 n)\n{\n    return dot(pos-p,n);\n}\n\nfloat SegmentSDF(vec2 pos,vec2 a,vec2 b)\n{\n    vec2 v = pos-a;\n    vec2 u = b-a;\n    float t = max(min(dot(v,u)/dot(u,u),1.0f),0.0f);\n    return length(v-u*t);\n}\n\nfloat CapsuleSDF(vec2 pos,vec2 a,vec2 b,float r)\n{\n    return SegmentSDF(pos,a,b)-r;\n}\n\nfloat BoxSDF(vec2 pos,vec2 c,float theta,vec2 s)\n{\n    float costheta = cos(theta);\n    float sintheta = sin(theta);\n    float dx = abs((pos.x-c.x)*costheta+(pos.y-c.y)*sintheta)-s.x;\n    float dy = abs((pos.y-c.y)*costheta-(pos.x-c.x)*sintheta)-s.y;\n    float ax = max(dx,0.0f);\n    float ay = max(dy,0.0f);\n    return min(max(dx,dy),0.0f)+sqrt(ax*ax+ay*ay);\n}\n\nfloat TriangleSDF(vec2 pos,vec2 a,vec2 b,vec2 c)\n{\n    float d = min(min(SegmentSDF(pos,a,b),SegmentSDF(pos,b,c)),SegmentSDF(pos,c,a));\n    float sd;\n    if((b.x-a.x)*(pos.y-a.y)>(b.y-a.y)*(pos.x-a.x) &&\n        (c.x-b.x)*(pos.y-b.y)>(c.y-b.y)*(pos.x-b.x) &&\n        (a.x-c.x)*(pos.y-c.y)>(a.y-c.y)*(pos.x-c.x))\n    {\n        sd = -d;\n    }\n    else\n        sd = d;\n    return sd;\n}\n\nResult scene(vec2 pos)\n{\n    //Result a = Result(CircleSDF(pos,vec2(-0.1f,0.2f),0.1f),2.0f,0.0f);\n    //Result b = Result(BoxSDF(pos,vec2(0.0f,-0.3f),-TWO_PI/16.0f,vec2(0.1f,0.1f)),0.0f,0.9f);\n    //Result c = Result(BoxSDF(pos,vec2(0.3f,0.0f),-TWO_PI/16.0f,vec2(0.1f,0.1f)),0.0f,0.9f);\n    //return unionOp(unionOp(a,b),c);\n    \n    Result d = Result(CircleSDF(pos,vec2(-0.1f,0.3f),0.1f),2.0f,0.0f);\n    Result e = Result(PlaneSDF(pos,vec2(0.0f,0.0f),vec2(0.0f,1.0f)),0.0f,0.9f);\n    Result f = Result(CircleSDF(pos,vec2(0.0f,0.0f),0.4f),0.0f,0.9f);\n    return unionOp(d,subtractOp(e,f));\n}\n\nvec2 estimateNormal(vec2 p)\n{\n    return normalize(vec2(\n        (scene(vec2(p.x+EPSILON,p.y)).sd-scene(vec2(p.x-EPSILON,p.y)).sd),\n        (scene(vec2(p.x,p.y+EPSILON)).sd-scene(vec2(p.x,p.y-EPSILON)).sd)\n    ));\n}\n\nfloat trace(vec2 origin,vec2 dir)\n{\n    float t = 0.0f;\n    float sum = 0.0f;\n    float factor = 1.0f;\n    for(int depth=0;depth<MAX_DEPTH;depth++)\n    {\n        bool findHit = false;\n        for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;i++)\n        {\n            vec2 pos = origin+dir*t;\n            Result r = scene(pos);\n            if(r.sd<EPSILON)\n            {\n                sum += r.emissive*factor;\n                if(r.reflectivity>0.0f)\n                {\n                    // reset t,origin,dir when hit\n                    // update factor\n                    t = 0.0f;\n                    vec2 normal = estimateNormal(pos);\n                    origin = pos+normal*BIAS;\n                    dir = Reflect(dir,normal);\n                    factor = r.reflectivity;\n                    //factor *= r.reflectivity;\n                    findHit = true;\n                }\n                break;\n            }\n            t += r.sd;\n        }\n        if(!findHit)\n            break;\n    }\n    return sum;\n}\n\n// https://stackoverflow.com/questions/33270823/how-to-cast-int-to-float-in-glsl-webgl\nfloat lightSample(vec2 pos)\n{\n    float sum = 0.0f;\n    float n_float = float(N);\n    float rand = random(pos)+iTime;\n    for(int i=0;i<N;i++)\n    {\n        float i_float = float(i);\n        //float rand = random(pos+random(vec2(i_float,i_float)));\n        //float a = TWO_PI*rand;// uniform sampling\n        //float a = TWO_PI*i_float/n_float; // stratified sampling\n        float a = TWO_PI*(i_float+rand)/n_float; // jittered sampling\n        sum += trace(pos,vec2(cos(a),sin(a)));\n    }\n    return sum/n_float;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n#if SHOW_NORMAL\n    vec2 normal = estimateNormal(uv);\n    normal.y = -normal.y;\n    normal = normal*0.5+0.5;\n    vec3 col = vec3(normal.x,normal.y,0.0);\n    fragColor = vec4(col,1.0);\n#else\n    float col = lightSample(uv);\n    vec4 data = texture(iChannel0,fragCoord/iResolution.xy);\n    if(iFrame==0)\n    {\n        data=vec4(0.);\n    }\n    data += vec4(vec3(col),1.0);\n    fragColor = data;\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}