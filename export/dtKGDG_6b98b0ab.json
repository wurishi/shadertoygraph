{"ver":"0.1","info":{"id":"dtKGDG","date":"1684600893","viewed":101,"name":"tunnel effect on texture","username":"manji369","description":"kaleidoscope effect on texture","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The main function that is called for each pixel on the screen\nvoid mainImage(out vec4 o, vec2 p)\n{\n    // Normalize the coordinates of the pixel to the range [-1, 1] to allow for rotation\n    // This makes the code resolution-independent\n    p = (2. * p - iResolution.xy) / iResolution.y;\n\n    // Calculate the distance of the pixel from the center of the screen\n    float r = length(p);\n\n    // Add a time-dependent offset to the x and y coordinates to create the rotation\n    float x = p.x * cos(iTime) - p.y * sin(iTime);\n    float y = p.x * sin(iTime) + p.y * cos(iTime);\n\n    // Calculate the texture coordinate based on the rotation and distance from the center\n    vec2 uv = vec2(atan(y, x) / (2. * 3.1415) + .5, r);\n\n    // Sample the texture to get the color of the pixel\n    // The RGB components of the texture determine the color of the pixel\n    // The alpha component of the texture determines the transparency of the pixel\n    // Setting the alpha component to 1. creates a fully opaque tunnel effect\n    o = texture(iChannel0, uv) * vec4(1., 1., 1., 1.);\n}","name":"Image","description":"","type":"image"}]}