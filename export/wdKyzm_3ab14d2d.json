{"ver":"0.1","info":{"id":"wdKyzm","date":"1602528302","viewed":152,"name":"Runge-Kutta Clouds","username":"nr4","description":"Cloud tricks with the double pendulum attractor.\nClick+drag to disturb the system time-dependently at a specific point.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["multipass","ode","runge","kutta"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Multipass Pendulum Attractor\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * ============= Usage: ==============\n * -- Play with the settings in Common.\n * -- Press alt + the down arrow to reset the simulation.\n * -- Click and drag to disturb the system (with a time-dependent perturbation)\n */\n\n// Palette\nvoid color(in float scale, out vec3 col)\n{\n    if(scale <= .2)\n        col = mix(vec3(0.05,0.05,0.05), vec3(0.05,0.05,0.05), scale*5.);\n    else if(scale <= .4)\n        col = mix(vec3(0.05,0.05,0.05), vec3(0.95,0.93,0.83), (scale-.2)*5.);\n    else if(scale <= .6)\n        col = mix(vec3(0.95,0.93,0.83), vec3(0.96,0.21,0.19), (scale-.4)*5.);\n    else if(scale <= .8)\n        col = mix(vec3(0.96,0.21,0.19), vec3(0.05,0.05,0.05), (scale-.6)*5.);\n    else col = mix(vec3(0.05,0.05,0.05), vec3(0.05,0.05,0.05), (scale-.8)*5.);\n}\n\nconst float fsaa = 128.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n\t        vec4 state = texture(iChannel0, fragCoord/iResolution.xy+3.*vec2(i,j)/max(bound, 1.)/iResolution.xy);\n     \t\tvec3 cola;\n            color(sqrt(abs(min(state[1]/state[3],state[0]/state[1]))), cola);\n            col += cola;\n        }\n    col /= fsaa;\n    \n    col = col + .3*sqrt(col);\n    \n    fragColor = vec4(clamp(col,0.,1.),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Multipass Pendulum Attractor\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Simulation Resolution in steps per pass\nconst int res = 1;\n\n// Lengths\nfloat L1 = 3.;\nfloat L2 = 2.;\n\n// Masses\nfloat M1 = 13.5;\nfloat M2 = 0.5;\n\n// Constants\nfloat G = 9.81;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Multipass Pendulum Attractor\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n//runge kutta params\nfloat h = 1.e-2;\n\n//math params\nfloat PI = acos(-1.);\n\n/* Evaluate system of differential equations\n * params:\n * tp[0]: theta1\n * tp[1]: theta2\n * tp[2]: ptheta1\n * tp[3]: ptheta2\n */\nvec4 eval(in vec4 tp)\n{\n    float p0w = (L1*L2*(M1+M2*pow(sin(tp[0]-tp[1]),2.)));\n    float C1 = tp[2]*tp[3]*sin(tp[0]-tp[1])/p0w;\n    float C2 = (L2*L2*M2*tp[2]*tp[2]+L1*L1*(M1+M2)*tp[3]*tp[3]-L1*L2*M2*tp[2]*tp[3]*cos(tp[0]-tp[1]))*sin(2.*(tp[0]-tp[1]))/(2.*p0w*p0w);\n    \n    vec4 ret;\n    \n    ret[0] = (L2*tp[2]-L1*tp[3]*cos(tp[0]-tp[1]))/(L1*p0w);\n    ret[1] = (L1*(M1+M2)*tp[3]-L2*M2*tp[2]*cos(tp[0]-tp[1]))/(L2*M2*p0w);\n    ret[2] = -(M1+M2)*G*L1*sin(tp[0])-C1+C2;\n    ret[3] = -M2*G*L2*sin(tp[1])+C1-C2;\n    \n    return ret;    \n}\n\nconst vec3 c = vec3(1.,0.,-1.);\nvoid rand(in vec2 x, out float n)\n{\n    x += 400.;\n    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid lfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    rand(i, v1.x);\n    rand(i+c.xy, v1.y);\n    rand(i+c.yx, v2.x);\n    rand(i+c.xx, v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n}\n\nvoid mfnoise(in vec2 x, in float d, in float b, in float e, out float n)\n{\n    n = 0.;\n    float a = 1., nf = 0., buf;\n    for(float f = d; f<b; f *= 2.)\n    {\n        lfnoise(f*x, buf);\n        n += a*buf;\n        a *= e;\n        nf += 1.;\n    }\n    n *= (1.-e)/(1.-pow(e, nf));\n}\n\n// Move one simulation step forward in the Runge-Kutta(4) method\nvec4 step_rk4(in vec4 tp)\n{\n    vec4 k1 = eval(tp);\n    vec4 k2 = eval(tp + h/2.*k1);\n    vec4 k3 = eval(tp + h/2.*k2);\n    vec4 k4 = eval(tp + h*k3);\n    return tp + h/6.*(k1+2.*k2+2.*k3+k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    h /= float(res);\n    vec2 n;\n    mfnoise(uv-iTime, 12., 1200., .45, n.x);\n    mfnoise(uv-1337.-iTime, 12., 1200., .45, n.y);\n    \n    if(iFrame == 0 || texelFetch( iChannel1, ivec2(40,1),0 ).x != 0.)\n    {\n        fragColor = vec4(2.*PI*(uv-.5), 0.,0.);\n    }\n    else\n    {\n        fragColor = texture(iChannel0, uv);\n        \n\t\tconst float fsaa = 4.;\n\t\tvec4 col = vec4(0.);\n        float bound = sqrt(fsaa)-1.;\n        for(float i = -.5*bound; i<=.5*bound; i+=1.)\n            for(float j=-.5*bound; j<=.5*bound; j+=1.)\n            {\n                vec4 state = texture(iChannel0, uv+3.*vec2(i,j)/max(bound, 1.)/iResolution.xy);\n                col += state;\n            }\n        col /= fsaa;\n        col.zw += .1 * n;\n        col.xy += .05 * n.yx;\n        fragColor = col;\n        if(length(iMouse.xy/iResolution.xy - uv) < .05)\n        {\n            fragColor = vec4(5.*n,fragColor.zw);\n        }\n        \n        for(int i=0; i<res; ++i)\n\t        fragColor = step_rk4(fragColor);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Multipass Pendulum Attractor\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(iFrame == 0 || texelFetch( iChannel1, ivec2(40,1),0 ).x != 0.)\n        fragColor = abs(texture(iChannel0,uv));\n    else\n        fragColor = max(abs(texture(iChannel0,uv)), abs(texture(iChannel1,uv)));\n}","name":"Buffer B","description":"","type":"buffer"}]}