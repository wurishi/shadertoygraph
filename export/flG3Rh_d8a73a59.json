{"ver":"0.1","info":{"id":"flG3Rh","date":"1663506608","viewed":303,"name":"3D Character Controller","username":"TheTurk","description":"Move: W, A, S, D or arrow keys and mouse\nJump: Space\nCamera: C\nFly: F\nVisualize Collision Mesh: V\nGenerates a mesh from the underlying distance field, so that collisions work with any distance field even if it is not exact.","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["3d","mouse","game","collision","sdf","camera","keyboard","physics","firstperson","jump","character","move","movement","controller","wasd","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const ivec3 directions[9] = ivec3[9](\n    ivec3(0, -1, 0),\n    ivec3(0, -1, -1),\n    ivec3(0, 0, -1),\n    \n    ivec3(0, 0, -1),\n    ivec3(-1, 0, -1),\n    ivec3(-1, 0, 0),\n    \n    ivec3(-1, 0, 0),\n    ivec3(-1, -1, 0),\n    ivec3(0, -1, 0)\n);\n\nvec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nbool keyIsToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nbool intersectBox(vec3 rayOrigin, vec3 rayDirection, vec3 halfSize, inout float t1, inout float t2) {\n    vec3 a = -rayOrigin / rayDirection;\n    vec3 b = halfSize / abs(rayDirection);\n    vec3 near = a - b;\n    vec3 far = a + b;\n    t1 = max(near.x, max(near.y, near.z));\n    t2 = min(far.x, min(far.y, far.z));\n    if (t2 < 0.0 || t2 < t1) {\n        return false;\n    }\n    return true;\n}\n\nSDF SceneEvaluateCharacter(vec3 position) {\n    vec3 characterPosition = read(bufferOffsetCharacterPosition).xyz;\n    vec3 column1 = read(bufferOffsetCharacterOrientation).xyz;\n    vec3 column2 = read(bufferOffsetCharacterOrientation + ivec2(1, 0)).xyz;\n    vec3 column3 = read(bufferOffsetCharacterOrientation + ivec2(2, 0)).xyz;\n    mat3 characterOrientation = mat3(column1, column2, column3);\n    position -= (characterPosition + vec3(0.0, colliderRadius, 0.0));\n    position = position * characterOrientation;\n    SDF body = SDFSphere(position, colliderRadius);\n    body.material = 3.0;\n    return body;\n}\n\nSDF SceneEvaluate(vec3 position) {\n    SDF scene = SceneEvaluateTerrain(position);\n    SDF obstacles = SceneEvaluateObstacles(position);\n    scene = SDFUnion(scene, obstacles);\n    bool thirdPersonMode = !keyIsToggled(67);\n    if (thirdPersonMode) {\n        SDF character = SceneEvaluateCharacter(position);\n        scene = SDFUnion(scene, character);\n    }\n    return scene;\n}\n\nvec3 SceneGetNormal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        SceneEvaluate(position + vec3(epsilon, 0, 0)).d - SceneEvaluate(position + vec3(-epsilon, 0, 0)).d,\n        SceneEvaluate(position + vec3(0, epsilon, 0)).d - SceneEvaluate(position + vec3(0, -epsilon, 0)).d,\n        SceneEvaluate(position + vec3(0, 0, epsilon)).d - SceneEvaluate(position + vec3(0, 0, -epsilon)).d\n    );\n    return normalize(gradient);\n}\n\nstruct Hit {\n    float t;\n    SDF field;\n};\n\nbool RendererRaycast(vec3 rayOrigin, vec3 rayDirection, inout Hit hit) {\n    int stepCount = 256;\n    float maximumDistance = 100.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        SDF field = SceneEvaluate(currentPosition);\n        if (field.d < 0.001 * max(t, 1.0)) {\n            hit.t = t;\n            hit.field = field;\n            return true;\n        }\n        t += field.d;\n    }\n    hit.t = t;\n    hit.field = SDF(t, 0.0);\n    return true;\n}\n\nfloat RendererGetShadow(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 64;\n    float t = 0.03;\n    float maximumDistance = 20.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        SDF field = SceneEvaluate(currentPosition);\n        if (field.d < 0.001) {\n            return 0.0;\n        }\n        t += field.d;\n    }\n    return 1.0;\n}\n\nvec3 RendererGetColorCollisionMesh(vec3 rayOrigin, vec3 rayDirection) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 meshPosition = read(bufferOffsetMeshPosition).xyz;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    if (intersectBox(rayOrigin - meshPosition, rayDirection, vec3(halfGridSize * cellSize + 0.025), t1, t2)) {\n        int gridSize = int(gridSize);\n        int offset = min(iFrame, 0);\n        for (int k = offset; k < gridSize; k++) {\n            for (int j = offset; j < gridSize; j++) {\n                for (int i = offset; i < gridSize; i++) {\n                    ivec3 cellCoordinates = ivec3(i, j, k);\n                    vec4 cell = texelFetch(iChannel0, convertCellCoordinatesToTextureCoordinates(cellCoordinates), 0);\n                    int edgeMask = int(cell.w);\n                    if (edgeMask == 0) {\n                        continue;\n                    }\n                    vec3 center = cell.xyz - rayOrigin;\n                    float t = dot(center.xyz, rayDirection);\n                    float d = length(rayDirection * t - center) - 0.03;\n                    if (d < 0.0) {\n                        color += vec3(0.4, 0.0, 0.0);\n                    }\n                }\n            }\n        }\n    }\n    return color;\n}\n\nvec3 RendererGetColor(vec3 rayOrigin, vec3 rayDirection) {\n    vec3 colorCollisionMesh = vec3(0.0);\n    if (keyIsToggled(86)) {\n       colorCollisionMesh = RendererGetColorCollisionMesh(rayOrigin, rayDirection);\n    }\n    \n    Hit hit;\n    RendererRaycast(rayOrigin, rayDirection, hit);\n    vec3 color = vec3(0.6, 0.7, 0.8) - 0.97 * rayDirection.y;\n    if (hit.t > 0.0) {\n        vec3 position = rayOrigin + rayDirection * hit.t;\n        vec3 baseColor = vec3(0.2);\n        if (hit.field.material == 1.0) {\n            vec2 d = fract(position.zx * 0.5) - 0.5;\n            float mask = step(d.x * d.y, 0.0);\n            baseColor += vec3(0.1) * mask;\n        }\n           \n        vec3 lightDirection = vec3(0.57735, 0.57735, -0.57735);\n        vec3 normal = SceneGetNormal(position);\n        float diffuseAngle = max(dot(normal, lightDirection), 0.0);\n        float shadow = RendererGetShadow(position, lightDirection);\n        diffuseAngle *= shadow;\n  \n        // diffuse\n        color = vec3(0.8, 0.7, 0.5) * diffuseAngle * baseColor;\n        // ambient\n        color += 0.5 * vec3(0.4, 0.6, 0.8) * ((normal.y + 1.0) * 0.5) * baseColor;\n        color = mix(color, vec3(0.6, 0.7, 0.8), 1.0 - exp(-0.0025 * hit.t * hit.t));\n        // collision mesh\n        if (hit.field.material != 3.0) {\n            color += colorCollisionMesh;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cameraPosition = read(bufferOffsetCameraPosition).xyz;\n    vec3 column1 = read(bufferOffsetCameraOrientation).xyz;\n    vec3 column2 = read(bufferOffsetCameraOrientation + ivec2(1, 0)).xyz;\n    vec3 column3 = read(bufferOffsetCameraOrientation + ivec2(2, 0)).xyz;\n    mat3 cameraOrientation = mat3(column1, column2, column3);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(1);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayOrigin = cameraPosition;\n            vec3 rayDirection = normalize(vec3(uv, fieldOfView));\n            rayDirection = cameraOrientation * rayDirection;\n            vec3 color = RendererGetColor(rayOrigin, rayDirection);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n    // gamma\n    result = pow(result, vec3(0.4545));\n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 vertices[8] = vec3[8](\n    vec3(0.0, 0.0, 0.0), // back bottom left\n    vec3(1.0, 0.0, 0.0), // back bottom right\n    vec3(0.0, 1.0, 0.0), // back top left\n    vec3(1.0, 1.0, 0.0), // back top right\n    vec3(0.0, 0.0, 1.0), // front bottom left\n    vec3(1.0, 0.0, 1.0), // front bottom right\n    vec3(0.0, 1.0, 1.0), // front top left\n    vec3(1.0, 1.0, 1.0)  // front top right\n);\n\nconst int edges[24] = int[24](\n    0, 1, // back bottom\n    0, 2, // back left\n    0, 4, // bottom left\n\n    6, 7, // front top\n    4, 6, // front left\n    2, 6, // top left\n     \n    2, 3, // back top\n    1, 3, // back right\n    3, 7, // top right\n        \n    4, 5, // front bottom\n    5, 7, // front right\n    1, 5  // bottom right\n);\n\nvec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nSDF SceneEvaluate(in vec3 position) {\n    SDF scene = SceneEvaluateTerrain(position);\n    SDF obstacles = SceneEvaluateObstacles(position);\n    scene = SDFUnion(scene, obstacles);\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (!(fragCoord.x < gridSize && fragCoord.y < gridSize * gridSize)) {\n        discard;\n    }\n    \n    vec3 meshPosition = read(bufferOffsetMeshPosition).xyz;\n    vec3 position = convertTextureCoordinatesToCellCoordinates(floor(fragCoord)) - halfGridSize;\n         \n    float values[8];\n    for (int i = 0; i < 8; i++) {\n        values[i] = SceneEvaluate((position + vertices[i]) * cellSize + meshPosition).d; \n    }\n   \n    int edgeMask = 0;\n    vec3 intersection = vec3(0.0);\n    float intersectionCount = 0.0;\n    int j = 0;\n    for (int i = 0; i < 24; i += 2) {\n        float value1 = values[edges[i]]; \n        float value2 = values[edges[i + 1]];\n        if (value1 < 0.0 != value2 < 0.0) {\n            vec3 vertex1 = vertices[edges[i]]; \n            vec3 vertex2 = vertices[edges[i + 1]];\n            vec3 vertex3 = vertex1 - value1 / (value2 - value1) * (vertex2 - vertex1);\n            intersection += vertex3;\n            intersectionCount += 1.0;\n            edgeMask |= 1 << j;\n        }\n        j += 1;\n    }\n    \n    intersection = (position + intersection / intersectionCount) * cellSize + meshPosition;\n    fragColor = vec4(intersection.x, intersection.y, intersection.z, edgeMask);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float PI = 3.141592;\n\nconst float gridSize = 8.0;\nconst float halfGridSize = 4.0;\nconst float cellSize = 1.0 / 8.0;\n\nfloat colliderRadius = 0.25;\nfloat fieldOfView = 1.5; // 67 degrees; 1.0 / tan(angle * 0.5 * PI / 180.0) \n\nfloat friction = 15.0;\nfloat gravity = 15.0;\nbool stickToGround = true;\nfloat walkSpeed = 4.0;\nfloat flySpeed = 10.0;\nfloat groundAcceleration = 20.0;\nfloat airAcceleration = 5.0;\nbool turnWithMouse = true;\nfloat mouseSensitivity = 0.25;\n\nconst ivec2 bufferOffsetCharacterPosition = ivec2(0, 0);\nconst ivec2 bufferOffsetCharacterVelocity = ivec2(1, 0);\nconst ivec2 bufferOffsetCharacterOrientation = ivec2(2, 0);\nconst ivec2 bufferOffsetCameraPosition = ivec2(0, 1);\nconst ivec2 bufferOffsetCameraOrientation = ivec2(1, 1);\nconst ivec2 bufferOffsetProgramState = ivec2(0, 2);\nconst ivec2 bufferOffsetMeshPosition = ivec2(0, 3);\nconst ivec2 bufferOffsetCameraRotation = ivec2(0, 4);\nconst ivec2 bufferOffsetLastMouseState = ivec2(0, 5);\n\nivec2 convertCellCoordinatesToTextureCoordinates(ivec3 cellCoordinates) {\n   return ivec2(cellCoordinates.x, cellCoordinates.z * int(gridSize) + cellCoordinates.y); \n}\n\nvec3 convertTextureCoordinatesToCellCoordinates(vec2 textureCoordinates) {\n    float z = floor(textureCoordinates.y / gridSize);\n    return vec3(textureCoordinates.x, textureCoordinates.y - z * gridSize, z);\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nstruct SDF {\n    float d;\n    float material;\n};\n\nSDF SDFBox(vec3 position, vec3 halfSize, float chamferRadius) {\n    position = abs(position) - halfSize + chamferRadius;\n    float d = length(max(position, 0.0)) + min(max(position.x, max(position.y, position.z)), 0.0) - chamferRadius;\n    return SDF(d, 0.0);\n}\n\nSDF SDFSphere(vec3 position, float radius) {\n    float d = length(position) - radius;\n    return SDF(d, 0.0);\n}\n\nSDF SDFSegment(vec3 position, vec3 start, vec3 end, float radius) {\n    position = position - start;\n    end = end - start;\n    float height = min(max(dot(position, end) / dot(end, end), 0.0), 1.0);\n    float d = length(position - end * height);\n    return SDF(d - radius, 0.0);   \n}\n\nSDF SDFUnion(SDF a, SDF b) {\n    if (a.d < b.d) {\n        return a;\n    }\n    return b;\n}\n\nSDF SceneEvaluateTerrain(vec3 position) {\n    float height = 0.0;\n    return SDF(position.y - height, 1.0); \n}\n\nSDF SceneEvaluateObstacles(vec3 position) {\n    position -= vec3(1.0, 0.0, 8.0);\n    position = rotationMatrixAxisAngle(vec3(0, 1, 0), PI / 4.0) * position;\n    vec3 position1 = rotationMatrixAxisAngle(vec3(1, 0, 0), PI / 6.0) * position;\n    SDF box1 = SDFBox(position1 - vec3(-3.0, 0.2, 0.0), vec3(1.0, 0.5, 2.0), 0.025);\n    box1.material = 2.0;\n    vec3 position2 = rotationMatrixAxisAngle(vec3(1, 0, 0),  PI / 4.0) * position;\n    SDF box2 = SDFBox(position2 - vec3(0.0, 0.2, 0.0), vec3(1.0, 0.5, 2.0), 0.025);\n    box2.material = 2.0;\n    vec3 position3 = rotationMatrixAxisAngle(vec3(1, 0, 0), PI / 3.0) * position;\n    SDF box3 = SDFBox(position3 - vec3(3.0, 0.2, 0.0), vec3(1.0, 0.5, 2.0), 0.025);\n    box3.material = 2.0;\n    return SDFUnion(SDFUnion(box1, box2), box3);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const ivec3 directions[9] = ivec3[9](\n    ivec3(0, -1, 0),\n    ivec3(0, -1, -1),\n    ivec3(0, 0, -1),\n    \n    ivec3(0, 0, -1),\n    ivec3(-1, 0, -1),\n    ivec3(-1, 0, 0),\n    \n    ivec3(-1, 0, 0),\n    ivec3(-1, -1, 0),\n    ivec3(0, -1, 0)\n);\n\nbool keyIsPressed(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.0;\n}\n\nbool keyIsToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nbool checkBufferOffset(vec2 fragCoord, ivec2 offset) {\n    return int(fragCoord.x) == offset.x && int(fragCoord.y) == offset.y;\n}\n\nvoid write(vec4 value, ivec2 offset, inout vec4 fragColor, vec2 fragCoord) {\n    if (checkBufferOffset(fragCoord, offset)) {\n        fragColor = value;\n    }\n}\n\nvec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nstruct Camera {\n    vec3 position;\n    mat3 orientation;\n};\n\nvoid CameraLoadState(out Camera camera) {\n    camera.position = read(bufferOffsetCameraPosition).xyz;\n    vec3 column1 = read(bufferOffsetCameraOrientation).xyz;\n    vec3 column2 = read(bufferOffsetCameraOrientation + ivec2(1, 0)).xyz;\n    vec3 column3 = read(bufferOffsetCameraOrientation + ivec2(2, 0)).xyz;\n    camera.orientation = mat3(column1, column2, column3);\n}\n\nvoid CameraSaveState(Camera camera, inout vec4 fragColor, vec2 fragCoord) {\n    write(vec4(camera.position, 0.0), bufferOffsetCameraPosition, fragColor, fragCoord);\n    write(vec4(camera.orientation[0], 0.0), bufferOffsetCameraOrientation, fragColor, fragCoord);\n    write(vec4(camera.orientation[1], 0.0), bufferOffsetCameraOrientation + ivec2(1, 0), fragColor, fragCoord);\n    write(vec4(camera.orientation[2], 0.0), bufferOffsetCameraOrientation + ivec2(2, 0), fragColor, fragCoord);\n}\n\nstruct Character {\n    vec3 position;\n    vec3 velocity;\n    mat3 orientation;\n};\n\nvoid CharacterLoadState(out Character character) {\n    character.position = read(bufferOffsetCharacterPosition).xyz;\n    character.velocity = read(bufferOffsetCharacterVelocity).xyz;\n    vec3 column1 = read(bufferOffsetCharacterOrientation).xyz;\n    vec3 column2 = read(bufferOffsetCharacterOrientation + ivec2(1, 0)).xyz;\n    vec3 column3 = read(bufferOffsetCharacterOrientation + ivec2(2, 0)).xyz;\n    character.orientation = mat3(column1, column2, column3);\n}\n\nvoid CharacterSaveState(Character character, inout vec4 fragColor, vec2 fragCoord) {\n    write(vec4(character.position, 0.0), bufferOffsetCharacterPosition, fragColor, fragCoord);\n    write(vec4(character.velocity, 0.0), bufferOffsetCharacterVelocity, fragColor, fragCoord);\n    write(vec4(character.orientation[0], 0.0), bufferOffsetCharacterOrientation, fragColor, fragCoord);\n    write(vec4(character.orientation[1], 0.0), bufferOffsetCharacterOrientation + ivec2(1, 0), fragColor, fragCoord);\n    write(vec4(character.orientation[2], 0.0), bufferOffsetCharacterOrientation + ivec2(2, 0), fragColor, fragCoord);\n}\n\nSDF SceneEvaluate(in vec3 position) {\n    SDF scene = SceneEvaluateTerrain(position);\n    SDF obstacles = SceneEvaluateObstacles(position);\n    scene = SDFUnion(scene, obstacles);\n    return scene;\n}\n\nvec3 SceneGetNormal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        SceneEvaluate(position + vec3(epsilon, 0, 0)).d - SceneEvaluate(position + vec3(-epsilon, 0, 0)).d,\n        SceneEvaluate(position + vec3(0, epsilon, 0)).d - SceneEvaluate(position + vec3(0, -epsilon, 0)).d,\n        SceneEvaluate(position + vec3(0, 0, epsilon)).d - SceneEvaluate(position + vec3(0, 0, -epsilon)).d\n    );\n    return normalize(gradient);\n}\n\nstruct Hit {\n    float t;\n    float fraction;\n    vec3 normal;\n};\n\nbool SceneRaycast(vec3 rayOrigin, vec3 rayDirection, float maximumDistance, inout Hit hit) {\n    int stepCount = 16;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        SDF field = SceneEvaluate(currentPosition);\n        if (field.d < 0.001) {\n            hit.t = t;\n            hit.fraction = t / maximumDistance;\n            hit.normal = SceneGetNormal(currentPosition);\n            return true;\n        }\n        t += field.d * 0.5;\n        if (t > maximumDistance) {\n            return false;\n        }\n    }\n    hit.t = t;\n    hit.fraction = t / maximumDistance;\n    hit.normal = SceneGetNormal(rayOrigin + rayDirection * t);\n    return true;\n}\n\nbool SceneRaycast(vec3 from, vec3 to, inout Hit hit) {\n    float maximumDistance = length(to - from);\n    vec3 rayDirection = normalize(to - from);\n    return SceneRaycast(from, rayDirection, maximumDistance, hit);\n}\n\nstruct Contact {\n    vec3 normal;\n    float penetrationDistance;\n};\n\nbool SceneContactTest(vec3 center, float radius, vec3 point1, vec3 point2, vec3 point3, inout Contact contact) {\n    vec3 position1 = center - point1;\n    vec3 end1 = point2 - point1;\n    vec3 position2 = center - point2;\n    vec3 end2 = point3 - point2;\n    vec3 position3 = center - point3;\n    vec3 end3 = point1 - point3;\n    vec3 normal = cross(end1, end3);\n    if (dot(cross(normal, end1), position1) < 0.0 && \n        dot(cross(normal, end2), position2) < 0.0 &&\n        dot(cross(normal, end3), position3) < 0.0) {\n        normal /= length(normal);\n        float d = dot(center - point1, normal);\n        normal *= sign(d);\n        d = abs(d);\n        if (d < radius) {\n            contact.normal = normal;\n            contact.penetrationDistance = abs(d - radius);\n            return true;\n        }\n        return false;\n    } \n    vec3 normal1 = position1 - end1 * clamp(dot(position1, end1) / dot(end1, end1), 0.0, 1.0);\n    float d1 = dot(normal1, normal1);\n    vec3 normal2 = position2 - end2 * clamp(dot(position2, end2) / dot(end2, end2), 0.0, 1.0);\n    float d2 = dot(normal2, normal2);\n    vec3 normal3 = position3 - end3 * clamp(dot(position3, end3) / dot(end3, end3), 0.0, 1.0);\n    float d3 = dot(normal3, normal3);\n    float d = d1;\n    normal = normal1;\n    if (d2 < d) {\n        d = d2;\n        normal = normal2;\n    }\n    if (d3 < d) {\n        d = d3;\n        normal = normal3;\n    }\n    d = sqrt(d);\n    if (d < radius) {\n        contact.normal = normal / d;\n        contact.penetrationDistance = abs(d - radius);\n        return true;\n    }\n    return false;\n}\n\nbool SceneContactTest(vec3 center, float radius, inout Contact contact) {  \n    contact.penetrationDistance = -1.0;\n    bool success = false;  \n    int gridSize = int(gridSize);\n    int offset = min(iFrame, 0) + 1;\n    for (int k = offset; k < gridSize; k++) {\n        for (int j = offset; j < gridSize; j++) {\n            for (int i = offset; i < gridSize; i++) {\n                ivec3 cellCoordinates = ivec3(i, j, k);\n                vec4 cell1 = texelFetch(iChannel0, convertCellCoordinatesToTextureCoordinates(cellCoordinates), 0);\n                int edgeMask = int(cell1.w);\n                if (edgeMask == 0) {\n                    continue;\n                }\n                for (int edge = 0; edge < 3; edge++) {\n                    if ((edgeMask & (1 << edge)) == 0) {\n                        continue;\n                    }\n                    vec4 cell2 = texelFetch(iChannel0, convertCellCoordinatesToTextureCoordinates(cellCoordinates + directions[edge * 3]), 0);\n                    vec4 cell3 = texelFetch(iChannel0, convertCellCoordinatesToTextureCoordinates(cellCoordinates + directions[edge * 3 + 1]), 0);\n                    vec4 cell4 = texelFetch(iChannel0, convertCellCoordinatesToTextureCoordinates(cellCoordinates + directions[edge * 3 + 2]), 0);\n                    Contact currentContact;\n                    if (SceneContactTest(center, radius, cell1.xyz, cell2.xyz, cell3.xyz, currentContact)) {\n                        if (currentContact.penetrationDistance > contact.penetrationDistance) {\n                            contact = currentContact;\n                            success = true;\n                        }\n                    }\n                    if (SceneContactTest(center, radius, cell1.xyz, cell3.xyz, cell4.xyz, currentContact)) {\n                        if (currentContact.penetrationDistance > contact.penetrationDistance) {\n                            contact = currentContact;\n                            success = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return success;\n}\n\nvoid CharacterUpdate(inout Character character, Camera camera, float deltaTime) {\n    bool leftPressed = keyIsPressed(65) || keyIsPressed(37);\n    bool rightPressed = keyIsPressed(68) || keyIsPressed(39);\n    bool upPressed = keyIsPressed(87) || keyIsPressed(38);\n    bool downPressed = keyIsPressed(83) || keyIsPressed(40);\n    bool spacePressed = keyIsPressed(32);\n    float xAxis = (leftPressed ? -1.0 : 0.0) + (rightPressed ? 1.0 : 0.0);\n    float yAxis = (upPressed ? 1.0 : 0.0) + (downPressed ? -1.0 : 0.0);\n\n    bool isFlying = keyIsToggled(70);\n    if (isFlying) {\n        character.velocity = camera.orientation * vec3(xAxis, 0.0, yAxis) * flySpeed;\n        character.position += character.velocity * deltaTime;\n    } else {\n        vec3 up = vec3(0.0, 1.0, 0.0);\n\n        Contact contact;\n        bool touchesGround = SceneContactTest(character.position + vec3(0.0, colliderRadius, 0.0) + vec3(0.0, -0.02, 0.0), colliderRadius, contact);\n   \n        Hit hit;\n        float groundClearance = 1.0;\n        if (SceneRaycast(character.position, character.position + vec3(0.0, -1.0, 0.0), hit)) {\n            groundClearance = hit.t;\n        } \n\n        if (touchesGround && groundClearance < 0.2) {\n            float speed = length(character.velocity);\n            if (speed > 0.0001) {\n                float minimumSpeed = 0.5; // minimum speed for friction calculation\n                float newSpeed = max(speed - max(speed, minimumSpeed) * friction * deltaTime, 0.0);\n                character.velocity *= newSpeed / speed;\n            }\n            vec3 verticalVelocity = dot(character.velocity, up) * up;\n            vec3 horizontalVelocity = character.velocity - verticalVelocity;\n            vec3 impulse = character.orientation * vec3(turnWithMouse ? xAxis : 0.0, 0.0, yAxis) * groundAcceleration * walkSpeed;\n            horizontalVelocity += impulse * deltaTime; \n            if (length(horizontalVelocity) > walkSpeed) { // limit horizontal speed to walk speed\n                horizontalVelocity = normalize(horizontalVelocity) * walkSpeed; \n            }\n            character.velocity = horizontalVelocity + verticalVelocity;\n            if (!stickToGround) {\n                character.velocity += (-up * gravity) * deltaTime; \n            }\n        } else {\n            vec3 verticalVelocity = dot(character.velocity, up) * up;\n            vec3 horizontalVelocity = character.velocity - verticalVelocity;\n            vec3 impulse = character.orientation * vec3(turnWithMouse ? xAxis : 0.0, 0.0, yAxis) * airAcceleration * walkSpeed;\n            horizontalVelocity += impulse * deltaTime;  \n            if (length(horizontalVelocity) > walkSpeed) { // limit horizontal speed to walk speed\n                horizontalVelocity = normalize(horizontalVelocity) * walkSpeed; \n            }\n            character.velocity = horizontalVelocity + verticalVelocity;\n            character.velocity += (-up * gravity) * deltaTime; \n        }\n  \n        if (spacePressed) {\n            if (groundClearance < 0.2) {\n                vec3 verticalVelocity = dot(character.velocity, up) * up;\n                character.velocity -= verticalVelocity;\n                character.velocity += up * 5.0; \n            }\n        }\n\n        int stepCount = 10;\n        float stepSize =  deltaTime / float(stepCount);\n        for (int i = 0; i < stepCount; i++) { \n            character.position += character.velocity * stepSize;\n            vec3 center = character.position + vec3(0.0, colliderRadius, 0.0);\n            Contact contact;\n            if (SceneContactTest(center, colliderRadius, contact)) {\n                 character.position += contact.normal * (contact.penetrationDistance + 0.001);\n                 vec3 perpendicularVelocity = dot(character.velocity, contact.normal) * contact.normal;\n                 character.velocity -= perpendicularVelocity;\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x > 8.0 || fragCoord.y > 8.0) {\n        discard;\n    }\n    \n    if (fragCoord.y > 2.0 && fragCoord.x > 1.0) {\n        discard;\n    }\n   \n    Character character;\n    CharacterLoadState(character);\n    Camera camera;\n    CameraLoadState(camera);\n    float programState = read(bufferOffsetProgramState).x;\n    if (programState == 0.0) {\n        programState = 1.0;\n        character.position.y = 0.0;\n    } \n    vec3 characterPosition = character.position + vec3(0.0, colliderRadius, 0.0);\n    vec3 meshPosition = round(characterPosition / cellSize) * cellSize;\n    vec3 cameraRotation = read(bufferOffsetCameraRotation).xyz;\n    vec4 currentMouseState = iMouse;\n    vec4 lastMouseState = read(bufferOffsetLastMouseState);\n    \n    float deltaTime = 1.0 / 60.0;\n    \n    if (turnWithMouse) {\n        if (currentMouseState.z > 0.0 && lastMouseState.z > 0.0) { // only if mouse is pressed and was pressed before\n            vec2 delta = currentMouseState.xy - lastMouseState.xy;\n            float pitch = clamp(cameraRotation.x - delta.y * deltaTime * mouseSensitivity, -PI * 0.5, PI * 0.5);\n            float yaw = cameraRotation.z + delta.x * deltaTime * mouseSensitivity;\n            cameraRotation = vec3(pitch, 0.0, yaw);\n        }\n    } else {\n        bool leftPressed = keyIsPressed(65) || keyIsPressed(37);\n        bool rightPressed = keyIsPressed(68) || keyIsPressed(39);\n        float xAxis = (leftPressed ? -1.0 : 0.0) + (rightPressed ? 1.0 : 0.0);\n        float yaw = cameraRotation.z + xAxis * deltaTime * 3.0;\n        cameraRotation = vec3(0.0, 0.0, yaw);\n    }\n\n    mat3 orientation = rotationMatrixAxisAngle(vec3(0.0, 1.0, 0.0), cameraRotation.z);\n    character.orientation = orientation;\n    orientation *= rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), cameraRotation.x);\n    camera.orientation = orientation;\n  \n    CharacterUpdate(character, camera, deltaTime);\n     \n    bool firstPersonMode = keyIsToggled(67);\n    if (firstPersonMode) {\n        camera.position = character.position + vec3(0.0, 1.5, 0.0);\n    } else {\n        camera.position = character.position + camera.orientation * vec3(0.0, 1.5, -3.0);\n    }\n    \n    CharacterSaveState(character, fragColor, fragCoord);\n    CameraSaveState(camera, fragColor, fragCoord);\n    write(vec4(programState, 0.0, 0.0, 0.0), bufferOffsetProgramState, fragColor, fragCoord);\n    write(vec4(meshPosition, 0.0), bufferOffsetMeshPosition, fragColor, fragCoord);\n    write(vec4(cameraRotation, 0.0), bufferOffsetCameraRotation, fragColor, fragCoord);\n    write(currentMouseState, bufferOffsetLastMouseState, fragColor, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"}]}