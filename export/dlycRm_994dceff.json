{"ver":"0.1","info":{"id":"dlycRm","date":"1700044345","viewed":48,"name":"Electric field simulator","username":"Speilkoun","description":"This shader compute a 2D electric field on Maxwell's equations.\nIt is far from perfect for now.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["electricfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 color, in vec2 coord)\n{\n    vec2 ef;\n    ef = texture(iChannel0, coord/iResolution.xy).xy;\n    \n    color = vec4(\n        min(1e2*length(ef), 1.),\n        min(1e0*length(ef), 1.),\n        min(1e-2*length(ef), 1.),\n        1\n    );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define get_e(pos)  texture(ef, pos).xy\n#define get_prev_e(pos)  texture(ef, pos).zw\n\n#define EPSILON 1e-2\n\n#define WORLD_DIM 2\n#define complex vec2\n\nconst float world_u0 = .1;\nconst float world_e0 = .1;\nconst float world_delta_x = 1.;\n\nfloat charges(vec2 pos, float t)\n{\n    float charge_x;\n\tt /= 3.;\n\twhile(t > 1.)\n\t\tt -= 1.;\n\tt *= 2.;\n\tcharge_x = (t < 1. ? t : 2.-t) / 10.  + .4;\n    \n\tif(abs(pos[0] - charge_x) < EPSILON && abs(pos[1] - .5) < EPSILON)\n\t\treturn 1.;\n\telse\n\t\treturn 0.;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 world_compute_cycle_element(\n\tvec2 position,\n    vec2 world_dim,\n    float iTime,\n    float iTimeDelta,\n    sampler2D ef\n)\n{\n\tint tmp, j;\n\tvec2 grad_charge;\n\tvec2 lapl;\n\tvec2 h;\n\n\t// Compute the charge's gradient and the electric field's laplacien\n\tlapl = vec2(0.);\n\th = vec2(0.);\n\tfor(j = 0; j < WORLD_DIM; j ++) {\n\t\th[j] = world_delta_x/world_dim[j];\n\t\tgrad_charge[j] =\n\t\t\tcharges(h + position, iTime) - charges(position, iTime); \n\t\tlapl +=\n\t\t\tget_e(position + h) + get_e(position - h) - get_e(position)*2.;\n\t\th[j] = 0.;\n\t}\n\tgrad_charge /= world_delta_x;\n\tlapl /= (world_delta_x*world_delta_x);\n \n    vec2 ret =\n        get_e(position)*2. -\n        get_prev_e(position) +\n\t\t(lapl - grad_charge / world_e0) *\n\t\t\t(iTimeDelta*iTimeDelta / (world_u0 * world_e0));\n \n\treturn vec4(ret, get_e(position));\n}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    if(iFrame <= 1) {\n        color = vec4(0);\n        return;\n    }\n    \n    color = world_compute_cycle_element(\n        coord/iResolution.xy, iResolution.xy,\n        iTime, iTimeDelta,\n        iChannel0\n    );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}