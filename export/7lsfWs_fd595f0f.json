{"ver":"0.1","info":{"id":"7lsfWs","date":"1651763293","viewed":58,"name":"Page de fleurs","username":"LoganOracio","description":"No b*tches ?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","smin"],"hasliked":0,"parentid":"NlsfDs","parentname":"Hex Voronoi/Worley"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NOISE_STRENGTH .3\n#define NOISE_SCALE .07\n#define ROTATION_MAGNITUDE .12\n#define ANIMATION_SPEED 1.4\n#define SMOOTH .15\n#define THRESHOLD -.3\n\nuvec3 murmurHash32(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec3 hash32(vec2 src) {\n    uvec3 h = murmurHash32(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nuvec3 murmurHash31(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec3 hash31(float src) {\n    uvec3 h = murmurHash31(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nfloat flower(vec2 uv,float seed)\n{\n    float h = hash11(seed);\n    vec3 mon_gros_zgeg = hash31(h);\n    float p = length(uv + ((mon_gros_zgeg.xy-.4)*.03))*.5*(mon_gros_zgeg.z*.1+.9);\n    for (int i = 0; i < 6; i++)\n    {\n        h = hash11(h);\n        mon_gros_zgeg = hash31(h);\n        p = smin(p,length(rotate(float(i)*-1.0471975512)*uv+vec2(.0,-.55)+ ((mon_gros_zgeg.xy-.5)*.06))*(mon_gros_zgeg.z*.1+.95),.3);\n    }\n    \n    return p;\n}\n\n/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright Â© 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\nvec2 simplex2(vec3 uv)\n{\n    return 1.0+vec2(simplex3d(uv),simplex3d(uv+64.0));\n}\nvec2 cell(vec2 v)\n{\n    v.y*=1.1547;\n    v.x-=v.y*.5;\n    vec2 f = floor(v);\n    vec2 c = fract(v);\n    \n    float mx = mod(f.x,3.0);\n    if(mx==0.0)\n    {\n        f.y-=2.0;\n    }\n    else if(mx==2.0)\n    {\n        f.y+=2.0;\n    }\n    float my = mod(f.y,3.0);\n    if(my==0.0)\n    {\n        f.x += 1.0;\n    }\n    else if(my==1.0)\n    {\n        f.y += 1.0;\n    }\n    else if(c.x+c.y>1.0)\n    {\n        f.x += 1.0;\n        f.y += 1.0;\n    }\n    if(mx==0.0)\n    {\n        f.y+=2.0;\n    }\n    else if(mx==2.0)\n    {\n        f.y-=2.0;\n    }\n    \n    f.x+=f.y*.5;\n    f.y/=1.1547;\n    return f;\n}\n\nvec3 hex_voronoi(vec2 uv,float randomness, float animation, vec2 noise_offset, float noise_size)\n{\n    vec2 coords[5];\n    coords[0] = cell(uv);\n    coords[1] = cell(uv+vec2(0.0,1.0));\n    coords[2] = cell(uv+vec2(1.,1.0));\n    coords[3] = cell(uv+vec2(1.,-0.5));\n    coords[4] = cell(uv+vec2(-.5,1.5));\n    \n    \n    vec2 points[5];\n    vec3 rands[5];\n    \n    for(int i = 0; i < 5; i++)\n    {\n        points[i] = .3*simplex2(32.*vec3(coords[i]+noise_offset,.0))-randomness*simplex2(noise_size*vec3(coords[i]+noise_offset,ANIMATION_SPEED*animation))+coords[i];\n    }\n    \n    \n    int p = 0;\n    float min_dist = 5.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float dist = length(uv-points[i]);\n        if(dist < min_dist)\n        {\n            min_dist = dist;\n            p = i;\n        }\n    }\n    vec3 rand = hash32(coords[p]);\n    vec2 outp = points[p];\n    rand.y *= .6;\n    rand.y += .7;\n    return vec3((uv-outp)*rotate(rand.x*739.0+ROTATION_MAGNITUDE*6.2831*simplex3d(noise_size*vec3(outp+noise_offset,ANIMATION_SPEED*-animation)))/rand.y,rand.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/120.*rotate(iTime*.03)+iTime*.75;\n    \n    bool inside = false;\n    \n    vec3 temp = hex_voronoi(uv,NOISE_STRENGTH,2.*iTime,vec2(0.),NOISE_SCALE);\n    float outp = flower(1.6*temp.xy,temp.z);\n    \n    temp = hex_voronoi(uv+vec2(.5,.85),NOISE_STRENGTH,2.*iTime,vec2(-.5,-.85),NOISE_SCALE);\n    outp = min(outp,flower(2.3*temp.xy,temp.z));\n    \n    temp = hex_voronoi(uv+vec2(-.5,.85),NOISE_STRENGTH,2.*iTime,vec2(.5,-.85),NOISE_SCALE);\n    outp = min(outp,flower(2.3*temp.xy,temp.z));\n    \n    temp = hex_voronoi(uv+vec2(.55,.3),NOISE_STRENGTH,2.*iTime,vec2(-.55,-.3),NOISE_SCALE);\n    outp = min(outp,flower(3.3*temp.xy,temp.z));\n\n    temp = hex_voronoi(uv+vec2(.95,.55),NOISE_STRENGTH,2.*iTime,vec2(-.95,-.55),NOISE_SCALE);\n    outp = min(outp,flower(3.3*temp.xy,temp.z));\n\n    temp = hex_voronoi(uv+vec2(-.55,.3),NOISE_STRENGTH,2.*iTime,vec2(.55,-.3),NOISE_SCALE);\n    outp = min(outp,flower(3.3*temp.xy,temp.z));\n      \n    temp = hex_voronoi(uv+vec2(-.95,.55),NOISE_STRENGTH,2.*iTime,vec2(.95,-.55),NOISE_SCALE);\n    outp = min(outp,flower(3.3*temp.xy,temp.z));\n     \n    temp = hex_voronoi(uv+vec2(.0,.625),NOISE_STRENGTH,2.*iTime,vec2(.0,-.625),NOISE_SCALE);\n    outp = min(outp,flower(3.3*temp.xy,temp.z));\n     \n    temp = hex_voronoi(uv+vec2(.0,1.075),NOISE_STRENGTH,2.*iTime,vec2(.0,-1.075),NOISE_SCALE);\n    outp = min(outp,flower(3.3*temp.xy,temp.z));\n    \n    float p = fwidth(outp);\n\n    outp = smoothstep(1.,.3,(outp-.126)/p)-smoothstep(-.3,-1.,(outp-.129)/p);\n\n    fragColor = vec4(vec3(1.-outp),1.);\n}","name":"Image","description":"","type":"image"}]}