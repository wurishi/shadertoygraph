{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"vec3 rotateX(float a, vec3 v)\n{\n\treturn vec3(v.x, cos(a) * v.y + sin(a) * v.z,\n\t\t\t\tcos(a) * v.z - sin(a) * v.y);\n}\n\n\nvec3 rotateY(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.z, v.y,\n\t\t\t\tcos(a) * v.z - sin(a) * v.x);\n}\n\n//Normals and shadows don't work on windows with angle ;) try turn it on with another system\n\n//-------------\n//#define NORMALS\n//-------------\n\n\n//#define SHADOWS\n//#define STEREO\n\nfloat stereoBase = 1.4; //distance between \"eyes\"\n\n//#define TERRACES\n\n\n////////////////////////\n// Noise framework\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 2d noise function\nfloat noise( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// Fractional Brownian motion\nfloat fbm( vec2 p )\n{\n  float f = 0.5000*noise( p ); p = m2*p;\n  f += 0.2500*noise( p ); p = m2*p;\n  f += 0.1666*noise( p ); p = m2*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\n///////////////\n\n\n\n\nconst vec3 boxMinimum = vec3 ( -80, -50, -40 );\nconst vec3 boxMaximum = vec3 (  80, 40, 60 );\n\nconst vec3 Zero  = vec3 ( 0.0, 0.0, 0.0 );\nconst vec3 Unit  = vec3 ( 1.0, 1.0, 1.0 );\nconst vec3 AxisX = vec3 ( 1.0, 0.0, 0.0 );\nconst vec3 AxisY = vec3 ( 0.0, 1.0, 0.0 );\nconst vec3 AxisZ = vec3 ( 0.0, 0.0, 1.0 );\n\nstruct SRay\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nfloat calcFunction ( in vec3 p )\n{\n\tvec3 p_orig = p;\n\tfloat hard_floor = -18.;\n\tfloat d = p.y-1.;\n/*\td -= clamp((hard_floor - p_orig.y)*3., 0.0, 1.0)*5.;\n\t  \n\td += noise(p*4.03)*0.25;\n\td += noise(p*1.967)*0.5;\n\td += noise(p*1.023)*1.;*/\n\np += vec3(0., 0., 4.+(iTime*4.+150.));\n\n\td += noise(p*0.47)*2.;\n\n\t//p += vec3(20., 55., -3.);\n#ifdef TERRACES\n\td -= clamp((-25. - p_orig.y)*2., 0.0, 1.0)*3.;\t\n\td -= clamp((-20. - p_orig.y)*2., 0.0, 1.0)*3.;\t\n\td -= clamp((-15. - p_orig.y)*2., 0.0, 1.0)*3.;\t\n#endif\t\n\t\n\td += noise(p*0.265)*4.;\n\t//p += vec3(35., 90., 3.);\n\t\n\tp += vec3(noise(p.zyx*0.013)*300.,noise(p.xyz*0.013)*300.,noise(p.xzy*0.013)*300.);\n\t\n\td += noise(p*0.121)*8.;\n\t\n\tp += vec3(86., -7.+iTime*1.1, 12.);\n\t\n\t\n\td += noise(p*0.065)*16.;\n\t\n\td += noise(p*0.032)*32.;\n\n\treturn d;\n}\n\n\n#define STEP 0.05 /* Step for numerical estimation of a gradient */\n\nvec3 calcNormal ( in vec3 point )\n{\n    /* We calculate normal by numerical estimation of a gradient */\n    \n #ifdef NORMALS \n    float A = calcFunction ( point + AxisX * STEP ) - \n              calcFunction ( point - AxisX * STEP );\n\n    float B = calcFunction ( point + AxisY * STEP ) -\n              calcFunction ( point - AxisY * STEP );\n\n    float C = calcFunction ( point + AxisZ * STEP ) -\n              calcFunction ( point - AxisZ * STEP );\n\n    return normalize ( vec3 ( A, B, C ) );\n #else\n\treturn AxisY;\n #endif\n}\n\n\nbool intersectBox ( in SRay ray       /* ray origin and direction */,\n                    in vec3 minimum   /* minimum point of a box */,\n                    in vec3 maximum   /* maximum point of a box */,\n                    out float start   /* time of 1st intersection */,\n                    out float final   /* time of 2nd intersection */ )\n{\n    vec3 OMIN = ( minimum - ray.Origin ) / ray.Direction;\n    vec3 OMAX = ( maximum - ray.Origin ) / ray.Direction;\n    \n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    \n    final = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    start = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );    \n  \n    return final > start;\n}\n\t\t\t\t\t\t\t  \n#define INTERVALS 120\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t  \nbool intersectSurface ( in SRay ray      /* ray origin and direction */,\n                        in float start   /* time when a ray enters a box */,\n                        in float final   /* time when a ray leaves a box */,\n                        out float val    /* time of ray-surface hit */ )\n{\n    float step = ( final - start ) / float ( INTERVALS );\n\n    //----------------------------------------------------------\n\n    float time = start;\n\n    vec3 point = ray.Origin + time * ray.Direction;\n\n    //----------------------------------------------------------\n    \n    float right, left = calcFunction ( point );\n\n    //----------------------------------------------------------\n\tbool hit = false;\n\n    for ( int i = 0; i < INTERVALS; ++i )\n    {\n\t\tif(hit) continue;\n        time += step;\n\n        point += step * ray.Direction;\n\n        right = calcFunction ( point );\n        \n        if ( left * right < 0.0 )\n        {\n            val = time + right * step / ( left - right );\n\n\t\t\thit = true;\n        }\n        \n        left = right;\n    }\n\n    return hit;\n}\n\n\n/* Phong material of surface */\n\n#define AMBIENT 0.6\n#define DIFFUSE 1.0\n#define SPECULAR 0.2\n#define SHININESS 80.0\n\n#define EPSILON 0.01\n\nconst vec3 lightPosition = vec3(10., -10., -30.); \nvec3 cameraPosition = vec3(-4., -6., -17.);\n\n/* Computes lighting in an intersection point and its final color */\n\nvec3 phong ( in vec3 point    /* intersection point with surface */,\n             in vec3 normal   /* normal to the surface in this point */,\n             in vec3 color    /* diffuse color in this point */ )\n{\n#ifdef NORMALS\n    vec3 light = normalize ( lightPosition - point );\n\tfloat L = length(lightPosition - point);\n    \n    vec3 view = normalize ( cameraPosition - point );\n    \n    vec3 refl = reflect ( -view, normal );\n    \n    //--------------------------------------------------------------------\n   \n    float diffuse = max ( dot ( light, normal ), 0.0 );\n\n    float specular = pow ( max ( dot ( refl, light ), 0.0 ), SHININESS );\n    \n    //--------------------------------------------------------------------   \n    \n    vec3 col =  AMBIENT * Unit +\n\t\t\t\tDIFFUSE * diffuse * color +\n\t\t\t\tSPECULAR * specular * Unit;\n#else\n\tvec3 light = normalize ( lightPosition - point );\n\tvec3 col = color+clamp(-point.y, 0., 0.5)*max ( dot ( light, normal ), 0.0 );\n\t\n#endif\n\t\n#ifdef SHADOWS\n\tif ( intersectSurface ( ray, 0.3, L, t ) )\n\t\tcol = AMBIENT * Unit + DIFFUSE * diffuse * color *0.2; \n#endif\t\n\n\t\n\treturn col;\n\n}\n\n\nSRay generateRay(vec2 fragCoord)\n{\n    vec2 coords = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tcoords.x *= iResolution.x / iResolution.y;\n\t\n\tfloat a = -3.141592 / 3. + iMouse.y/1000.;\n\tfloat b = 3.141592 / 8. - iMouse.x/1000.;\n\tvec3 view = rotateY(b, vec3(0, sin(a), cos(a)));\n\tvec3 side = rotateY(b, AxisX);\n\tvec3 up = cross(view, side);\n    \n    vec3 direction = view -\n                     side * coords.x +\n                     up * coords.y;\n\t\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\tcameraPosition += stereoBase*side*isCyan; \n    #endif\n   \n    return SRay ( cameraPosition, normalize ( direction ) );\n}\n\n\nvec3 raytrace ( in SRay ray )\n{\n    vec3 result = vec3(0.8, 1.0, 1.0);\n    float start, final, time;\n\n\n    if ( intersectBox ( ray, boxMinimum, boxMaximum, start, final ) )\n    {\n        if ( intersectSurface ( ray, start, final, time ) )\n        {\n            vec3 point = ray.Origin + ray.Direction * time;\n                    \n            vec3 normal = calcNormal ( point );\n\n            vec3 color = vec3(( point - boxMinimum ) /\n                ( boxMaximum - boxMinimum ));\n\t\t\t\n\t\n\t\t\tvec3 fog = result;\n\t\t\tvec3 col = phong ( point, normal, color );\n\t\t\t\t\t\t\n\t\t\t\n\t\t\tresult = 1.0 * mix(fog, col, 3.*exp(-time * time * 0.0005));\n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    SRay ray = generateRay(fragCoord);\n\t\n\tvec2 coords = fragCoord.xy / iResolution.xy;\n\t\n    float v = 1.0 - pow(distance(coords, vec2(0.5)), 2.0) * 0.5;\n\t\n\tvec3 color = raytrace( ray );\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\tcolor *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n    \n    fragColor = vec4 ( color*v, 1.0 );\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXGzM","date":"1368282807","viewed":698,"name":"perlin terrain","username":"megaton","description":"I've tried to make some procedural perlin terrain as described in GPU Gems 3 (http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html). ","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["perlinterrain"],"hasliked":0,"parentid":"","parentname":""}}