{"ver":"0.1","info":{"id":"XtVcDK","date":"1537823778","viewed":123,"name":"HMN","username":"MonterMan","description":"HMN.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hmn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926\n#define _dot(a, b) max(0.0, dot(a, b))\n\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * pi * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * 0.5 * pi * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nvec4 quat(in vec3 axis, in float angle)\n{\n    return vec4(axis * sin(angle/2.0), cos(angle/2.0));\n}\n\nvec4 qmul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.xyz*q2.w + q2.xyz*q1.w + cross(q1.xyz, q2.xyz), q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n\nvec4 qinv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec3 qrot(in vec3 p, in vec4 q)\n{\n    return qmul(qmul(q, vec4(p, 0.0)), qinv(q)).xyz;\n}\n\nvec4 qmix(in vec4 q1, in vec4 q2, in float t)\n{\n    return normalize(q1 * (1.0 - t) + q2 * t);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat m(in vec3 p)\n{\n    float height = 2.0;\n    float width = 0.4;\n    float gap = 1.0;\n    \n    return min(sdBox(p - vec3(0, height - 3.0*width, 0), 0.5*vec3(2.0*gap+width, width, width)),\n               min(sdBox(p - vec3(-gap, 0, 0), 0.5*vec3(width, height, width)), \n                   min(sdBox(p, 0.5*vec3(width, height, width)),\n                       sdBox(p - vec3(gap, 0, 0), 0.5*vec3(width, height, width)))));\n}\n\nfloat bridge(in vec3 p)\n{\n    vec4 q = quat(vec3(0, 0, -1), 0.235*pi);\n    q = qmul(q, quat(vec3(0, 1, 0), 0.5*pi));\n    \n    p = qrot(p, q);\n    return sdBox(p, vec3(1.265, 0.2, 0.2));\n}\n\nfloat hmn(in vec3 p)\n{\n    vec4 orientations[3];\n    orientations[0] = qmul(quat(vec3(0, 1, 0), 0.5*pi), quat(vec3(1, 0, 0), 0.5*pi));\n    orientations[1] = quat(vec3(0), 0.0);\n    orientations[2] = quat(vec3(0, 1, 0), 0.5*pi);\n    \n    float time = mod(iTime + 5.0, 6.0);  \n    if (mod(time, 2.0) >= 1.0)\n    {\n        time = floor(time) + 1.0;\n    }\n    int i = int(floor(0.5 * time));\n    int i_next = i + 1;\n    float t = fract(time);\n    i = i % 3;\n    i_next = i_next % 3;\n    \n    vec4 orientation = qmix(orientations[i], orientations[i_next], elasticInOut(t));\n    p = qrot(p, orientation);\n    \n    float front = m(p - vec3(0, 0, -1.0));\n    float back = m(p - vec3(0, 0, 1.0));\n    return min(bridge(p), min(front, back));\n}\n\nfloat scene(in vec3 p)\n{\n    float ground = p.y;\n    return min(ground, hmn(p - vec3(0, 1.4, 0)));\n}\n\nvec3 scene_n(in vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(scene(p + e.yxx), scene(p + e.xyx), scene(p + e.xxy)) - scene(p));\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float res = 1.0;\n    \n    float t = 0.01;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > 20.0) break;\n        \n        float d = scene(p + t*l);\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 16.0*d/t);\n    }\n    return res;\n}\n\nvec3 render(in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 at = vec3(0, 1.2, 0);\n    vec3 ro = vec3(0, 1.2, -4.0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n    \n    int matid = -1;\n    float t = 0.01;\n    float t_max = 20.0;\n    int iter = 0;\n    for (int i = 0; i < 128; ++i)\n    {\n        iter = i;\n        \n        if (t > t_max) break;\n        \n        float d = scene(ro + t*rd);\n        if (d < 0.001)\n        {\n            matid = 0;\n            break;\n        }\n        t += d;\n    }\n    \n    vec3 background = vec3(0.1);\n    vec3 col = background;\n    if (matid != -1)\n    {\n        vec3 p = ro + t*rd;\n        vec3 n = scene_n(p);\n        vec3 l = normalize(vec3(0.5, 0.8, -1.1));\n        vec3 sun = vec3(2);\n        vec3 albedo = vec3(0.9, 0.2, 0.2);\n        if (abs(p.y) < 0.01)\n        {\n            albedo = vec3(1);\n        }\n        \n        float occ = 1.0 - float(iter) / 128.0;\n        vec3 diffuse = 0.8 * shadow(p, l) * _dot(n, l) * sun;\n        vec3 ambient = occ * vec3(0.2);\n        \n        col = (diffuse + ambient) * albedo;\n        \n        col = mix(col, background, pow(clamp(t / t_max, 0.0, t_max), 2.0)); \n    }\n    \n    col = 1.0-exp(-col);\n    col = sqrt(col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 col = vec3(0.0);  \n    #define AA 1\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n\t    col += render(fragCoord + (vec2(i,j)/float(AA)));\n    }\n\tcol /= float(AA*AA);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}