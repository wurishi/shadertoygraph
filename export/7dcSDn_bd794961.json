{"ver":"0.1","info":{"id":"7dcSDn","date":"1633705373","viewed":120,"name":"Plumbing Maze 2D","username":"spalmer","description":"riffing on Plumbing Maze, this time in 2D for some reason with false 3D perspective like old Wolf3D game, but it's not a DDA, it's actually a 2D ray marcher / sphere caster.  arrow keys move, mouse looks, space for map","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["firstperson","maze","explore"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D version of Plumbing Maze https://shadertoy.com/view/tdSBDt\n// first-person wolf3d-style view, like https://shadertoy.com/view/ttyXRR\n\n// TODO can try putting goal and auto-solving\n// using Djikstra field, or even put monsters\n// and have them chase you!\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    float bluenoiz = texelFetch(iChannel2, ivec2(mod(q, iChannelResolution[2].xy)), 0).g;\n    o = texelFetch(iChannel0, ivec2(0), 0); // data pixel\n    bool attract = abs(iMouse.z) < 4.; //iMouse.z == 0.; //\n    vec2 R = iResolution.xy, p = o.xy, v = o.zw;\n    //if (attract) v = sin(.2*iTime + vec2(0,11));\n    vec3 c = vec3(1);\n    vec2 u = (2.*q-R)/R.y\n    , r = normalize(vec2(u.x,2));\n    r = vec2(r.x*v.y + r.y*v.x, r.y*v.y - r.x*v.x); // rotate to world\n    float per = dot(r, v)\n    , zoomy = .04 // keeping walls short since can't look up&down\n    , z = texelFetch(iChannel0, ivec2(q.x, 1), 0).x\n    , d = .5 - abs(u.y) * zoomy * z * per\n    // proper antialiasing\n    , blur = abs(dFdy(d))\n    , f = clamp(.5 - d/blur, 0., 1.)\n    //, fog = exp2(-.01*z) // needs more work to obtain floor/ceiling hit distance\n    ;\n    float lum = .5;\n    vec2 g = normalize(gScene(p + r * z, .02)); // gradient\n    lum = mix(.5, 1., dot(g, vec2(.5, .866))); // \"lighting\"\n    lum = mix(lum, clamp(.5 + u.y * zoomy * z, 0., 1.), .5);\n    lum = mix(lum, .4 + .5 * step(0., u.y), f); // blend walls and floor/ceiling\n    c *= lum; // no color (yet)\n    //c *= fog;\n   #if 1 // top-down map overlay, toggle w space bar\n    if (texelFetch(iChannel1, ivec2(32,2), 0).r > .5 || attract) {\n        q = (q - .5*R).yx * vec2(1,-1) * mat2(v.x,-v.y,v.y,v.x) + .5*R;\n        c = mix(c, vec3(1,.1,0), clamp(5.5 - distance(q, .5*R), 0., 1.));\n        float x = dScene(q + p - .5*R);\n        c.rg *= 1. - clamp(.5 - 50.*x, 0., 1.) * .2;\n        c.b -= pow(clamp(dot(v, normalize(q - .5*R)), 0., 1.), 4.); // show facing\n    }\n   #endif\n    c += .5/256. * (bluenoiz * 2. - 1.);\n    o = vec4(c, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// maze from https://shadertoy.com/view/tdSBDt, which is from https://shadertoy.com/view/WdfyWH\n\n#define R iResolution\n#define L length\n\n#define Z 4.\n\n// tiling\n#define T(_) (mod((_) + 50., 100.) - 50.)\n#define D(_) L(T(_))\n\n// converted to 2D\nfloat dMaze(vec2 q)\n{\n    float U = Z, d = U/2.;\n    q -= vec2(U)*.125;\n    vec2 e = vec2(.5, 0)\n    , i = floor(q / U + .5) * U;\n    for (float x = -2.; x < 3.; ++x) {\n        float u = x;\n        vec2 p = i + (x*x > 1. ? vec2(0,.5*u) : vec2(u,0)) * U\n        , v = q - p;\n        // determines maze branching\n        v *= step(D(p), vec2(D(p + e), D(p + e.yx))) * 2. - 1.;\n    \tif (.5 < fract(sin((p.x+47.*p.y)*99.)*3e4)) v = v.yx;\n        if (v.y > 0.) v.y = max(0., v.y - U);\n        d = min(d, L(v));\n    }\n    return d;\n}\n\nfloat dScene(vec2 p)\n{\n    float S = 15.; // scale\n    p /= S;\n    float\n      dm = dMaze(p) // medial axis maze skeleton\n    , dr = dm - .99 // thick round pills\n    , dt = abs(dr + .2) - .2 // thin walled pipes\n    , dh = max(abs(T(p.x)), abs(T(p.y)))-10. // big squares!\n    , ds = max(-dh, dt) // just the pipes\n    ;\n    return ds*S; \n}\n\n// central difference gradient for clean collisions - probably overkill for rendering\nvec2 gScene(vec2 p, float e)\n{\n    return vec2(dScene(p+vec2(e,0)), dScene(p+vec2(0,e))) \n         - vec2(dScene(p-vec2(e,0)), dScene(p-vec2(0,e))); // / 2. / e;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// steerable 2D camera, collision w maze, depth circle cast ray marching\n\n// mostly just fills BufferA with white, except data pixel 0,0 is camera pos,dir\n// and row 1 holds the (1-dimensional) raw floating point trace distances.\n// could totally do something more worthwhile with this buffer!\n\n// I'm sure I got the idea for packing the distances into a row\n// from unnick https://shadertoy.com/view/wtXSW8 but it's a \n// fairly obvious optimization, in hindsight.\n\nconst int kLf = 37, kRt = 39, kUp = 38, kDn = 40, kZ = 90, kX = 88; // arrow keys, Z,X\n#define K(i) texelFetch(iChannel1, ivec2(i,0), 0).x\n\nfloat tScene(vec2 o, vec2 d, int it)\n{\n    float h = 9., t = 0.;\n    while (it-- > 0 && abs(h) > 1e-4 * t)\n        t += (h = dScene(o + d * t)) * .9;\n    return min(t, 1e3);\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    vec4 d = texelFetch(iChannel0, ivec2(0), 0); // fetch prior data\n    if (iFrame == 0) d = vec4(0,0,0,1); // initialize\n    vec2 p = d.xy, v = d.zw; // extract\n    if (ivec2(q) != ivec2(0) && int(q.y) != 1) { o = vec4(1); return; } // non-data pixels\n    // keyboard in iChannel1 control\n    vec2 m = vec2(K(kRt)-K(kLf), K(kUp)-K(kDn));\n #if 0\n    // keyboard look\n    v *= mat2(cos(vec4(0,1,3,0)*acos(0.) + 1.5*iTimeDelta*(K(kZ)-K(kX))));\n #else\n    // mouse look\n    bool attract = abs(iMouse.z) < 2.; //iMouse.z == 0.; //\n    if (attract) v = sin(iTime * .2 + vec2(0,11));\n    else v = sin(iMouse.x * 12. / iResolution.x - vec2(0,11));\n #endif\n    m = vec2(m.x*v.y + m.y*v.x, m.y*v.y - m.x*v.x); // rotate to world\n    p += 100. * min(1./30., iTimeDelta) * m;\n    vec2 g = gScene(p, .04);\n    // collide w maze using dScene(p)\n    float x = dScene(p);\n    p += g * max(0., 5.5 - x) / (length(g) + 1e-7);\n    // only after final movement can we raycast\n    // to find wall distances for each column,\n    // otherwise would get lag.\n    if (int(q.y) == 1) {\n        vec2 R = iResolution.xy\n        , u = (2.*q-R)/R.y\n        , r = normalize(vec2(u.x,2));\n        r = vec2(r.x*v.y + r.y*v.x, r.y*v.y - r.x*v.x); // rotate to world\n        float per = dot(r, v)\n        , t = tScene(p, r, 96); // / per;\n        o = vec4(t, 0, 0, 0); return; \n    }\n    o = vec4(p,v); // pack into pixel\n}","name":"Buffer A","description":"","type":"buffer"}]}