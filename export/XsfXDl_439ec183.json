{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n\nLets try out this distance field raymarching stuff, in the style of iq.\n\nExtremely unfinished and messy, but the basic idea - using randomly generated BSP splits to\ngenerate interesting shapes that resemble rock formations - seems to show some potential, if I\ncan get rid of all the artifacts.\n\nThe real fun would be if I could get a nice displacement working on top of all this.\n\nA great deal of optimization should be possible once I clean up some of this horrible mess.\n\nDaniel \"Asteropaeus\" Dresser\n\n*/\n\n\nconst float heightCap = 0.5;\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nvec2 getCell( vec3 p, out vec3 normals[6], out vec3 centers[6], out float hardnesses[6] )\n{\n\thardnesses[0] = hardnesses[1] = hardnesses[2] = hardnesses[3] = 0.002;\n\tnormals[0] = vec3(1,0,0);\n\tnormals[1] = vec3(1,0,0);\n\tnormals[2] = vec3(0,1,0);\n\tnormals[3] = vec3(0,1,0);\n\tcenters[0] = vec3(-1,0,0);\n\tcenters[1] = vec3(1,0,0);\n\tcenters[2] = vec3(0,-1,0);\n\tcenters[3] = vec3(0,1,0);\n\t\t\n\tvec3 splitAxis = vec3( 1.0, 0.0, 0.0 );\n\t//vec3 splitCenter = vec3(0.0, 0.0001 * iMouse.x / iResolution.x, 0.0);\n    //vec3 splitCenter = vec3(0.000007);\n    vec3 splitCenter = vec3(0.000027 + 0.000001 * floor(iTime / 20.0));\n\tfloat splitSize = 0.9;\n\tvec2 rockId = splitCenter.xy;\n\t\n\tfloat curAxis = 1.0;\n\tfor( float i = 0.0; i < 10.0; i += 1.0 )\n\t{\n\t\tcurAxis *= -1.0;\n        \n\t\tsplitAxis = vec3( normalize( curAxis * vec2(splitAxis.y, -splitAxis.x ) + 0.0 * 0.35 * vec2( hash( splitCenter.xy ), hash( splitCenter.xy + vec2( 0.1, 0.0 ) ) ) ),\n                         0.2 * hash( splitCenter.xy + vec2( 3.1, 3.0 ) ) );\n\n\t\t   \n\t\tfloat axisDot = dot( p - splitCenter, splitAxis);\n\t\tfloat dist = abs( axisDot );\n\t\t\n\t\t\n\t\tvec3 newSplitCenter = vec3( splitCenter.xy + sign( axisDot ) * splitAxis.xy * splitSize * ( 1.0 + 0.3 * hash( splitCenter.xy + vec2(0.7, sign(axisDot)))), 0.0 );\n\t\t//if( hash( newSplitCenter + vec2(0.2,0.7 ) ) > 0.3 * max( 1.0, 7.0 - i ) )\n        \n\t\t\n\t\tfloat splitPick = hash( splitCenter.xy + vec2(0.2,0.7 ) ) > 0.0 ? 1.0 : -1.0;\n        float hardness = hash( splitCenter.xy + vec2(0.2,0.7 ) ) > -( 1.0 - 1.9 * pow( 8.0 * length( rockId - newSplitCenter.xy ), 2.0 ) ) ? 1.0 : 0.0;\n\t\tif( axisDot * splitPick < 0.0 && hardness == 0.0 )\n\t\t//if( axisDot > 0.0 )\n\t\t{\n\t\t\trockId = newSplitCenter.xy;\n\t\t\thardnesses[0] = hardnesses[1] = hardnesses[2] = hardnesses[3] = 0.02;\n\t\t}\n        hardness = 0.02 * ( 1.0 - hardness ) + 0.002;\n\t\tif( curAxis > 0.0 )\n\t\t{\n\t\t\tif( axisDot > 0.0 )\n\t\t\t{\n                if( dot(centers[0] - splitCenter, splitAxis) < 0.0 )\n                {\n                    normals[0] = splitAxis;\n                    centers[0] = splitCenter;\n                    hardnesses[0] = hardness;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                if( dot(centers[1] - splitCenter, splitAxis) > 0.0 )\n                {\n\t\t\t\t\tnormals[1] = splitAxis;\n\t\t\t\t\tcenters[1] = splitCenter;\n    \t            hardnesses[1] = hardness;   \n                }\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif( axisDot > 0.0 )\n\t\t\t{\n                if( dot(centers[2] - splitCenter, splitAxis) < 0.0 )\n                {\n                    normals[2] = splitAxis;\n                    centers[2] = splitCenter;\n                    hardnesses[2] = hardness;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                if( dot(centers[3] - splitCenter, splitAxis) > 0.0 )\n                {\n\t\t\t\t\tnormals[3] = splitAxis;\n\t\t\t\t\tcenters[3] = splitCenter;\n                \thardnesses[3] = hardness;\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tsplitCenter = newSplitCenter;\n\t\tsplitSize *= sqrt(0.5) * ( 1.0 + 0.0 * hash( splitCenter.xy + vec2(0.5,0.5) ) );\n\t}\n    \n    float eccentricity = 2.0 * (0.5 - length( rockId ));\n    normals[4] = normalize( vec3( eccentricity * 0.4 * hash(rockId + vec2(6.0)), 0.1 + eccentricity * 0.6 * hash(rockId + vec2(5.0)), 1.0 ) );\n    centers[4] = vec3( rockId.xy, eccentricity * eccentricity * eccentricity* 0.15 + 0.2 * hash(rockId + vec2(4.0)) );\n    \n    float extraChunkOffset = 0.1 * hash(splitCenter.xy + vec2(14.0));\n    centers[5] = vec3( splitCenter.xy, dot(centers[4] - splitCenter, normals[4]) / normals[4].z + extraChunkOffset );\n    normals[5] = normalize( vec3( hash(splitCenter.xy + vec2(15.0)), hash(splitCenter.xy + vec2(16.0)), 2.0 ) );\n                      \n    if( extraChunkOffset < 0.0 )\n    {\n        vec3 swap = normals[4];\n        normals[4] = normals[5];\n        normals[5] = swap;\n        swap = centers[4];\n        centers[4] = centers[5];\n        centers[5] = swap;\n    }\n    //normals[4] = vec3( 0.0, 0.0, 1.0 );\n    //normals[4] = vec3( 0.0, 0.0, 1.0 );\n    //float softnessBoost = 0.05 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 11.0 ) ) + 1.0), 3.0 );\n    hardnesses[0] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 11.0 ) ) + 1.0), 3.0 ) );\n    hardnesses[1] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 12.0 ) ) + 1.0), 3.0 ) );\n    hardnesses[2] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 13.0 ) ) + 1.0), 3.0 ) );\n    hardnesses[3] = max( hardnesses[0], 0.03 * pow( 0.5 * ( hash( splitCenter.xy + vec2( 12.0, 14.0 ) ) + 1.0), 3.0 ) );\n    //0.03 * ( 1.0 - closestHardness1 ) + 0.002 + softnessBoost;\n    \n    return length( splitCenter ) > 1.00 ? vec2(1e38) : rockId;\n}\n\nfloat cellMap( vec3 p, vec3 normals[6], vec3 centers[6], float hardnesses[6], vec2 rockId, float flip )\n{\n    if( rockId.x == 1e38 ) return 1e38;\n    float closestDist1 = 1e38;\n    float closestDist2 = 1e38;\n    float closestHardness1 = 1e38;\n    float closestHardness2 = 1e38;\n\n\n    float dir = -1.0;\n    for( int i = 0; i < 4; i += 1 )\n    {\n        dir *= -1.0;\n        float dist = dir * dot( p - centers[i], normals[i]);\n        if( dist < closestDist1 )\n        {\n            closestDist2 = closestDist1;\n            closestHardness2 = closestHardness1;\n            closestDist1 = dist;\n            closestHardness1 = hardnesses[i];\n        }\n        else if( dist < closestDist2 )\n        {\n            closestDist2 = dist;\n            closestHardness2 = hardnesses[i];\n        }\n    }\n\n    /*float softnessBoost = 0.1 * pow( 0.5 * ( hash( rockId + vec2( 12.0, 11.0 ) ) + 1.0), 3.0 );\n    float softness1 = 0.03 * ( 1.0 - closestHardness1 ) + 0.002 + softnessBoost;\n    float softness2 = 0.03 * ( 1.0 - closestHardness2 ) + 0.002 + softnessBoost;*/\n    float softness1 = closestHardness1;\n    float softness2 = closestHardness2;\n    \n    \n\n    if( softness2 > softness1 )\n    {\n    \tfloat swap = softness1;\n        softness1 = softness2;\n        softness2 = swap;\n        \n        swap = closestDist1;\n        closestDist1 = closestDist2;\n        closestDist2 = swap;\n    }\n\n\n    softness1 = max( softness1, closestDist1 );\n    softness2 = max( softness2, closestDist2 );\n\n    float softness = min( softness1, softness2 );\n    float verticalDist1 = -dot( p - centers[4], normals[4] );\n    float verticalDist2 = -dot( p - centers[5], normals[5] );\n    float pickSide = ( verticalDist2 <  verticalDist1 || verticalDist1 > 0.0 ) ? 1.0 : -1.0;\n    float verticalDist = pickSide == flip ? verticalDist1 :\n    \tmin( -verticalDist1, verticalDist2 );\n    //float verticalDist = verticalDist1;\n    \n\n    float bigRadAxis1 = softness1 - closestDist1;\n    float bigRadAxis2 = softness1 - verticalDist;\n    float bigRadAxis1Clamp = max( 0.0, bigRadAxis1);\n    float bigRadAxis2Clamp = max( 0.0, bigRadAxis2);\n    float bigRad = sqrt( bigRadAxis1Clamp * bigRadAxis1Clamp + bigRadAxis2Clamp * bigRadAxis2Clamp );\n    bigRad = bigRad > 0.0 ? bigRad : max( bigRadAxis1, bigRadAxis2 );\n    \n    float smallRadAxis1 = softness2 - closestDist2;\n    float smallRadAxis2 = softness2 - ( softness1 - bigRad );\n    float smallRadAxis1Clamp = max( 0.0, smallRadAxis1 );\n    float smallRadAxis2Clamp = max( 0.0, smallRadAxis2 );\n    float smallRad = sqrt( smallRadAxis1Clamp * smallRadAxis1Clamp + smallRadAxis2Clamp * smallRadAxis2Clamp );\n    smallRad = smallRad > 0.0 ? smallRad : max( smallRadAxis1, smallRadAxis2 );\n    //smallRad = min( smallRad, 0.0 );\n\n    //return bigRad - softness1;\n    return smallRad - softness2;\n}\n\nfloat getOcclusion( vec3 pos, vec3 nor, float stepLength, vec2 self )\n{\n    const float lookupRad = 0.06;\n    const int lookupSamples = 16;\n    const int steps = 4;\n    float ret = 0.0;\n    vec2 prevId = vec2( 0.0 );\n    for( int l = 0; l < lookupSamples; l++ )\n    {\n        float hardnesses[6];\n        vec3 normals[6];\n        vec3 centers[6];\n        float angle = float(l) / float(lookupSamples) * 2.0 * 3.14159265;\n        vec2 rockId = getCell( pos + lookupRad * vec3( sin( angle ), cos(angle), 0.0 ), normals, centers, hardnesses );\n        if( rockId == prevId ) continue;\n        prevId = rockId;\n        float flip = rockId != self ? 1.0 : -1.0;\n\n        float accum = 0.0;\n        for( int i = 0; i < steps; i++ )\n        {\n            float dist = float(i) * stepLength;\n            float cellDist = cellMap( pos + nor * dist, normals, centers, hardnesses, rockId, flip );\n            accum += max( 0.0, (dist - cellDist) / dist );\n        }\n        ret = max( ret, accum );\n\n    \t/*float step = 8.;\n    \tfloat ao = 0.;\n    \tfloat dist;\n    \tfor (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t\tao += max(0., (dist - map(p + n * dist).y) / dist);*/\n    }\n    //return 1. - ao * 0.1;\n    return 0.2 * ret;\n}\n\n\nfloat trace( vec3 camPos, vec3 camDir, float t, float reflT, vec3 reflDir, out vec3 hit, out float hardnesses[6], out vec3 normals[6], out vec3 centers[6], out vec2 rockId )\n{\n    float marchThroughBorder = 0.0001;\n    float status = 1.0;\n    for( float j = 0.0; j < 40.0; j += 1.0 )\n    {\n        float curCellStartT = t;\n        //march += camDir * 0.005;\n        t += marchThroughBorder;\n        if( reflT < t )\n        {\n            /*camPos = camPos + camDir * reflT;\n            camDir = reflDir;\n            t = marchThroughBorder;\n            status = -1.0;\n            reflT = 1e38;*/\n            hit = camPos + camDir * reflT;\n            return -1.0;\n        }\n\n        vec3 march = camPos + camDir * t;\n\n\n        if( ( abs( march.x ) > 1.0 && march.x * camDir.x > 0.0 ) ||\n            ( abs( march.y ) > 1.0 && march.y * camDir.y > 0.0 ) || march.z > heightCap) break;\n\n        rockId = getCell( march, normals, centers, hardnesses );\n\n\n        float sideDot0 = dot( camDir, normals[0] );\n        float sideDot1 = dot( camDir, normals[1] );\n        float sideDot2 = dot( camDir, normals[2] );\n        float sideDot3 = dot( camDir, normals[3] );\n        float sideDot4 = dot( camDir, normals[4] );\n        float sideDot5 = dot( camDir, normals[5] );\n        float cellExitDist = reflT;\n        if( sideDot0 < 0.0 ) cellExitDist = min( cellExitDist, dot( normals[0], centers[0] - camPos) / sideDot0 ); \n        if( sideDot1 > 0.0 ) cellExitDist = min( cellExitDist, dot( normals[1], centers[1] - camPos) / sideDot1 );\n        if( sideDot2 < 0.0 ) cellExitDist = min( cellExitDist, dot( normals[2], centers[2] - camPos) / sideDot2 );\n        if( sideDot3 > 0.0 ) cellExitDist = min( cellExitDist, dot( normals[3], centers[3] - camPos) / sideDot3 );\n        t = max( t, min( sideDot4 > 0.0 ? 0.0 : dot( normals[4], centers[4] - camPos) / sideDot4,\n                        sideDot5 > 0.0 ? 0.0 : dot( normals[5], centers[5] - camPos) / sideDot5 ) );\n        //hitColor = normals[3] * 0.5 + vec3(0.5);\n        //hitColor = vec3( cellExitDist * 0.1 );\n        //break;\n\n        float dist = 1e38;\n        float mapTol = 0.001;\n        for( float k = 0.0; k < 20.0; k += 1.0 )\n        {\n            dist = cellMap( camPos + camDir * t, normals, centers, hardnesses, rockId, 1.0 );\n            if( dist < mapTol || t + dist > cellExitDist ) break;\n            t += dist;\n        }\n\n        if( dist < mapTol && t < reflT)\n        {\n            /*vec2 checkRockId = getCell( camPos + camDir * t, normals, centers, hardnesses );\n            if( checkRockId != rockId )\n            {\n                //reflectionMult *= vec3( 1.0, 0.0, 0.0 );\n                //t = curCellStartT * 0.75 + t * 0.25;\n                //t = curCellStartT + 0.1;\n                continue;\n\n            }*/\n            \n            hit = camPos + camDir * t;\n            //hitColor = reflectionMult * vec3( 0.8 );\n            return status;\n            //break;\n        }\n\n        t = cellExitDist;\n    }\n    \n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - vec2(1)) * vec2( 1.0, 1.0 );\n    \n    float camAngle = ( iMouse.z < 0.0 ? 0.0 : iMouse.x - iMouse.z ) / iResolution.x * 4.0 * 3.1415926 - 0.1 + iTime / 20.0 * 2.0 * 3.14159265;\n    float camDistance = max( 16.0 * ( iMouse.w < 0.0 ? 0.0 : iMouse.y - iMouse.w ) / iResolution.y + 2.1, 0.0001 );\n    //float camAngle = abs( iMouse.x ) / iResolution.x * 4.0 * 3.1415926 - 2.6 + 2.0;\n    //float camDistance = max( 16.0 * abs (iMouse.y ) / iResolution.y - 1.0, 0.0001 ) ;\n    vec3 camPos = vec3( sin( camAngle ) * camDistance, cos( camAngle ) * camDistance, 0.35 );\n    vec3 camForward = normalize( vec3( 0.0, 0.0, 0.0 ) - camPos );\n    vec3 camRight = normalize( cross( vec3( 0.0, 0.0, 1.0 ), camForward ) );\n    vec3 camUp = normalize( cross( camForward, camRight ) );\n    \n    vec3 camDir = normalize( camForward + 0.3 * iResolution.x / iResolution.y * camRight * uv.x + 0.3 * camUp * uv.y );\n\t\n    float waterHitT = -camPos.z / camDir.z;\n    vec3 waterHit = camPos + waterHitT * camDir;\n    vec3 waterNorm = normalize( vec3( 0.0, 0.03 * sin( 120.0 * waterHit.y + 2.0 * iTime ) + 0.1 * sin( 10.0 * waterHit.y + iTime ), 1.0 ) );\n    vec3 reflDir = reflect( camDir, waterNorm );\n    \n    \n    \n    /*float shortestStartIntersection = (1.0 - camPos.x ) / camDir.x;\n    shortestStartIntersection = min( shortestStartIntersection, (-1.0 - camPos.x ) / camDir.x );\n    shortestStartIntersection = min( shortestStartIntersection, (1.0 - camPos.y ) / camDir.y );\n    shortestStartIntersection = min( shortestStartIntersection, (-1.0 - camPos.y ) / camDir.y );*/\n    \n\n    vec3 reflectionMult = vec3( 1.0 );\n    \n    \n    vec3 hitColor = vec3( -1.0 );\n    /*if( camDir.z > 0.0 )\n    {\n        hitColor = vec3( 0.3, 0.3, 0.8 );\n    }\n    else*/\n    {\n        float t = max( (-sign( camDir.x ) - camPos.x ) / camDir.x, (-sign( camDir.y) - camPos.y ) / camDir.y );\n    \tt = max( t, (heightCap - camPos.z ) / camDir.z );\n        \n        //float waterDist = ( -camPos.z ) / camDir.z;\n        \n        vec3 cellTracingCamDir = camDir;\n        vec3 cellTracingCamPos = camPos;\n        float status = 1.0;\n        vec3 hit = waterHit;\n        if( waterHitT < t )\n        {\n            //cellTracingCamPos = waterHit;\n            //cellTracingCamDir = reflDir;\n            //t = max( (-sign( cellTracingCamDir.x ) - cellTracingCamPos.x ) / cellTracingCamDir.x, (-sign( cellTracingCamDir.y) - cellTracingCamPos.y ) / cellTracingCamDir.y );\n            // //reflectionMult = vec3( 0.5 );\n            //hit = waterHit;\n            status = -1.0;\n            //waterHitT = 1e38;\n        }\n\n        \n        //shortestStartIntersection = 1.0;\n        //vec3 march = camPos + camDir * ( shortestStartIntersection + marchThroughBorder );\n\n        float hardnesses[6];\n        vec3 normals[6];\n        vec3 centers[6];\n        vec2 rockId;\n\n        \n        if( status > 0.0 )\n        {\n\t\t\tstatus *= trace( cellTracingCamPos, cellTracingCamDir, t, waterHitT, reflDir, hit, hardnesses, normals, centers, rockId );\n        }\n        /*if( dot( hit - cellTracingCamPos, cellTracingCamDir ) > waterHitT )\n        {\n\t\t\thit = cellTracingCamPos + waterHitT * cellTracingCamDir;\n        \tstatus = -1.0;\n        }*/\n    \n\t\tvec3 sunDir = normalize( vec3( 1.0, 1.0, 1.0 ) );\n        //if( hitColor.x >= 0.0 )\n        //if( status != 0.0 )\n        {\n            \n            //vec3 march = camPos + camDir * t;\n            vec3 nor;\n            if( status == 1.0 )\n            {\n                vec3 eps = vec3( 0.001, 0.0, 0.0 );\n                nor = normalize( vec3(\n                    cellMap( hit + eps.xyy, normals, centers, hardnesses, rockId, 1.0 ) - cellMap( hit - eps.xyy, normals, centers, hardnesses, rockId, 1.0 ),\n                    cellMap( hit + eps.yxy, normals, centers, hardnesses, rockId, 1.0 ) - cellMap( hit - eps.yxy, normals, centers, hardnesses, rockId, 1.0 ),\n                    cellMap( hit + eps.yyx, normals, centers, hardnesses, rockId, 1.0 ) - cellMap( hit - eps.yyx, normals, centers, hardnesses, rockId, 1.0 )\n                ) );\n            }\n            else\n            {\n                nor = vec3( 0.0, 0.0, 1.0 );\n                rockId = vec2( 0.0 );\n            }\n\n            //nor = vec3( 0.0, 0.0, 1.0 );\n\n            \n            float test = hit.x;\n            float occlMult = 1.0 - getOcclusion( hit, nor, 0.01, rockId );\n            occlMult = occlMult > 0.0 ? occlMult : 1.0;\n            hitColor = mix( vec3( 0.2, 0.2, 0.3 ), vec3 ( 0.2, 0.2, 0.19 ), -nor.z * 0.5 + 0.5 ) * max( 0.0, occlMult );\n            \n            float shadow = max( 0.0, trace( hit, sunDir, 0.01, 1e38, vec3( 0.0 ), hit, hardnesses, normals, centers, rockId ) );\n            //float shadow = 0.0;\n\n            hitColor += vec3( 0.65, 0.6, 0.45 ) * max( 0.0, dot( normalize(nor), sunDir ) ) * ( 1.0 - shadow );\n            \n            //hitColor.z = sin( test );\n            //hitColor *= status < 0.0 ? 0.5 : 1.0;\n        }\n        /*else\n        {\n            vec3 halfAng = normalize( sunDir - camDir );\n            hitColor = vec3( 0.1, 0.1, 0.5 ) + pow( max( 0.0, dot( halfAng, waterNorm ) ), 8.0 );\n        }*/\n    }\n    //if( hitColor == vec3( -1.0 ) ) hitColor = vec3( 0.1, 0.1, 0.5 );\n\n\t//vec3 material = vec3( 0.7 + 0.3 * hash(rockId + vec2(1.0)) );\n\t//material.xy = vec2( 0.0 );\n\t//float mask = clamp( edgemask * 1000.0, 0.0, 1.0 );\n\t//fragColor = vec4( mix( vec3( 0.4, 0.35, 0.25 ), mix( 1.0, 0.4 + 0.6 * pow( clamp( edgemask, 0.0, 1.0 ), 0.4), 20.0 * softness ) * material, mask ), 1.0);\n    const float gamma = 1.0 / 2.4;\n    fragColor = vec4( pow( hitColor.x, gamma ), pow( hitColor.y, gamma ), pow( hitColor.z, gamma ), 1.0 );\n\t//fragColor += 1.0 * vec4( closestDist1 / softness1, closestDist2 / softness2, 0.0, 1.0);\n\t//fragColor = vec4( 0.0 );\n\t//fragColor += 0.5 * vec4( clamp( closestDist1 / softness1, 0.0, 1.0), clamp( closestDist2 / softness2, 0.0, 1.0 ), 0.0, 1.0);\n\t//fragColor = vec4( vec3( 0.0 ) * ( 1.0 - binary_edge ) + binary_edge * vec3( 0.7 + 0.3 * hash(rockId + vec2(1.0)) ), 1.0);\n\t//fragColor = vec4( vec3( 0.5 ) * min( 1.0, 1.0 - edgemask * 1000.0 ), 1.0 );\n    //fragColor = vec4( iMouse.z, -iMouse.z * 0.001, iMouse.z * 0.01, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfXDl","date":"1407662638","viewed":4938,"name":"Rock Shapes WIP","username":"asteropaeus","description":"Was hoping to have my first real shadertoy demo out in time to commemorate the Siggraph Hackathon, even if my schedule may not let me make it. As it turns out, this is quite unfinished:  buggy, slow, messy, and no texturing.  But it was sure fun!","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}