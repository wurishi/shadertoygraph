{"ver":"0.1","info":{"id":"ssfGRX","date":"1617127932","viewed":200,"name":"Rendering God Rays","username":"PartyGodTroy","description":"Its what you get when an analogue TV doesn't have signal and the tv isnt frozen, \n\nMaybe your have one of those multi monitors on the frits, this is a result of modding and adding to the coord","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raynoise"],"hasliked":0,"parentid":"7dfGRX","parentname":"Standard Noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based on https://www.youtube.com/watch?v=ybbJz6C9YYA&t=513s\n\nfloat rand(vec2 coord)\n{\n    coord = mod(coord,10000.0);\n    return \n        fract // The fractional part\n        (\n            sin // of the the sin of\n            (\n                // the dot product of the coordinate and this constant vector2\n                dot(coord, vec2( 12.9898, 78.233))\n            ) \n            * 43758.5453\n        );\n}\n\nvec2 rand2(vec2 coord) \n{\n    coord = mod(coord,10000.0);\n    return \n    fract // The fractional Part \n    (\n      sin // the sin sin(x), sin(y)\n      (\n          vec2 // \n          (\n                  // the dot product of the coordinate and this constant vector2\n                dot(coord, vec2(127.1,311.7)),\n                dot(coord, vec2(269.5,183.3))\n          )\n      ) \n    ) * 4.0; // times 4\n            \n}\n// Blocky Noise\nfloat value_noise(vec2 coord){\n    vec2 i = floor(coord);// what square we are in\n    vec2 f = fract(coord);// what is the position in the squire\n    \n    float tl = rand(i);\n    float tr = rand(i + vec2(1.0,0.0)); // Top right of the square\n    float bl = rand(i + vec2(0.0,1.0)); // bottom right of the square\n    float br = rand(i + vec2(1.0,1.0)); // bottom left of the square\n    // cubic function to haf color fall off could also be liner\n    vec2 cubic = f * f * (3.0 - 2.0 * f); \n    \n    float topmix = mix(tl,tr,cubic.x);\n    float botmix = mix(bl,br,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    \n    return wholemix;\n    \n}\n\nfloat perlin_noise(vec2 coord){\n\n    float rotation = 2.0 * 3.14; // amout of radiants corners can deviat\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i) * rotation;\n    float tr = rand(i + vec2(1.0,0.0)) * rotation; // Top right of the square\n    float bl = rand(i + vec2(0.0,1.0)) * rotation; // bottom right of the square\n    float br = rand(i + vec2(1.0,1.0)) * rotation ; // bottom left of the square\n    // rotate random vectors\n    vec2 tlvec = vec2(-sin(tl), cos(tl));\n    vec2 trvec = vec2(-sin(tr), cos(tr));\n    vec2 blvec = vec2(-sin(bl), cos(bl));\n    vec2 brvec = vec2(-sin(br), cos(br));\n    \n    //\n    float tldot = dot(tlvec, f);\n    float trdot = dot(trvec, f -  vec2(1.0,0.0));\n    float bldot = dot(blvec, f -  vec2(0.0,1.0));\n    float brdot = dot(brvec, f -  vec2(1.0,1.0));\n    \n     // cubic function to haf color fall off could also be liner\n    vec2 cubic = f * f * (3.0 - 2.0 * f); \n    \n    float topmix = mix(tldot,trdot,cubic.x);\n    float botmix = mix(bldot,brdot,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    return wholemix + 0.5;//added becaus dot produts can be negative\n}\n\n\nfloat perlin_noise_alt(vec2 coord){\n\n    float rotation = 2.0 * 3.14; // amout of radiants corners can deviat\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i) * rotation;\n    float tr = rand(i + vec2(1.0,0.0)) * rotation; // Top right of the square\n    float bl = rand(i + vec2(0.0,1.0)) * rotation; // bottom right of the square\n    float br = rand(i + vec2(1.0,1.0)) * rotation ; // bottom left of the square\n    // rotate random vectors\n    vec2 tlvec = vec2(-sin(tl), cos(tl));\n    vec2 trvec = vec2(-sin(tr), cos(tr));\n    vec2 blvec = vec2(-sin(bl), cos(bl));\n    vec2 brvec = vec2(-sin(br), cos(br));\n    \n    //dot product can be used instead of adding 0.5\n    float tldot = abs(dot(tlvec, f));\n    float trdot = abs(dot(trvec, f -  vec2(1.0,0.0)));\n    float bldot = abs(dot(blvec, f -  vec2(0.0,1.0)));\n    float brdot = abs(dot(brvec, f -  vec2(1.0,1.0)));\n    \n     // cubic function to haf color fall off could also be liner\n    vec2 cubic = f * f * (3.0 - 2.0 * f); \n    \n    float topmix = mix(tldot,trdot,cubic.x);\n    float botmix = mix(bldot,brdot,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    return wholemix;\n}\n\n\n// also known an worley or voranoy\nfloat cell_noise(vec2 coord){\n    vec2 i = floor(coord);// what square we are in\n    vec2 f = fract(coord);// what is the position in the square\n    \n    float min_dist = 99999.0;\n    for(float x = -1.0; x <= 1.0; x++)\n    {\n        for(float y = -1.0; y <= 1.0; y++)\n        {\n            //random point in the squire, or neightboring squaire\n            vec2 node = rand2(i + vec2(x,y)) +  vec2(x,y);\n            float dist =\n            sqrt\n            (\n                 ((f - node).x * (f - node).x) +\n                 ((f - node).y * (f - node).y) \n            );\n            \n            min_dist = min(min_dist,dist);\n\n        }\n    }\n    return min_dist;\n}\n\nvec2 god_ray(vec2 coord, vec2 fragCoord, float time){\n    return (coord/fragCoord.x * 100.0) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 coord = uv * 100.0;\n    \n    float value =  cell_noise(god_ray(coord, fragCoord, iTime) * (sin(iTime/10.10)));\n    // SEIZER WARNING lightning cos(perlin_noise(coord)+ tan(iTime));\n    // Waves on the beach = mix(tan(perlin_noise(coord)+ sin(iTime)),perlin_noise(coord), cos(iTime));\n\n    // Output to screen\n    fragColor = vec4(vec3(value/3.0, value/2.0, value/10.0), 0.0);\n}\n","name":"Image","description":"","type":"image"}]}