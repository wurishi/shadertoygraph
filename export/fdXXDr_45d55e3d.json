{"ver":"0.1","info":{"id":"fdXXDr","date":"1618494169","viewed":175,"name":"Haru86_Hexagon","username":"Haru86_","description":"Haru86_Hexagon","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat rand(vec2 st)\n{\nreturn fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 pmod(vec2 p, float n)\n{\nfloat a = (2.0 * PI) / n;\nfloat t = atan(p.x, p.y) - PI / n;\nt = mod(t, a) - PI / n;\nreturn vec2(length(p) * cos(t), length(p) * sin(t));\n}\n\nfloat cube(vec3 p, vec3 s)\n{\np = abs(p);\nreturn length(max(p - s, 0.0));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\nconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\np = abs(p);\np.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\nvec2 d = vec2(\n    length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n    p.z - h.y);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n#define rootT 1.73205080757\n\n\nfloat hex(vec3 p) {\n    p.yz *=rot(PI / 2.0); \n\n    float r = 5.;\n    float l = 5.;\n    p.xy = abs(p.xy);\n    float offset = 0.5;\n\n    vec3 pos1 = p;\n    vec3 pos2 = p;\n    vec2 off1 = vec2(2.0, 2.0 * rootT) * r+vec2(offset, offset);\n\n    vec2 id1 = floor(pos1.xy / off1);\n    vec2 id2 = floor((pos1.xy+0.5* off1) / off1);\n\n    float str = 1.5;\n    float randZ1 = rand(id1)* str;\n    float randZ2 = rand(id2)* str;\n\n\n    pos1.xy = mod(pos1.xy, off1) - off1 * 0.5;\n    pos2.xy = mod(pos2.xy + 0.5 * off1, off1) - off1 * 0.5;\n\n    pos1.z += randZ1;\n    pos2.z += randZ2;\n\n    float d1 = sdHexPrism(pos1, vec2(r, l));\n    float d2 = sdHexPrism(pos2, vec2(r, l));\n\n\n\n\n    d1 = min(d1, d2);\n\n    return d1;\n}\n\nfloat Torus(vec3 p,vec2 size)\n{\n    return length(vec2(length(p.xy)-size.x,p.z))-size.y;\n}\n\nfloat Box(vec3 p,vec3 size)\n{\n    return length(max(abs(p)-size,0.0));\n}\n\nfloat flower(vec3 p)\n{\n    p.xy*=rot(iTime);\n    p.xz*=rot(iTime);\n    p.yz*=rot(iTime);\n    \n    float radius=1.0;\n    \n    vec3 pos=p;\n        float time=iTime*2.;\n    float r=floor(time)+pow(fract(time),.1);\n   \n    \n    for(int i=0;i<3;i++)\n    {\n        pos=abs(pos)-radius;\n        if(pos.x<pos.y)pos.xy=pos.yx;\n        if(pos.x<pos.z)pos.xz=pos.zx;\n        if(pos.y<pos.z)pos.yz=pos.zy;\n        pos.xy-=.01;\n        \n        pos.xy*=rot(r);\n        pos.xz*=rot(r);\n        pos.y-=0.5;\n        \n        //pos.yz*=rot(PI/3.);\n    }\n    \n    float h=2.0;\n    pos.x-=clamp(pos.x,-h,h);\n    \n    float d4=Torus(pos,vec2(0.5,0.35));\n    float d5=Box(pos,vec3(0.1,0.1,4.0));\n    return d4;\n}\n\nfloat map(vec3 p)\n{\n    vec3 pos=p;\n    \n    p.z -= iTime*20.;\n    float off = 16.;\n\n    float d1 = hex(p- vec3(0.0, off, 0.0));\n    float d2 = hex(p+vec3(0.0, off,0.0));\n\n    float d3=flower(pos);\n    //return d1;\n    return min(min(d1,d2),d3);\n}\n\n\nvec3 gn(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n         vec2 uv = (fragCoord*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n       // uv*=rot(iTime);\n        vec3 col=vec3(0.);\n\n         float radius=15.;\n       float speed=-.25;\n        vec3 ta=vec3(0.);\n        vec3 ro=vec3(cos(iTime*speed)*radius,0.0,sin(iTime*speed)*radius);\n        //sin(iTime*0.5)*0.25\n        //vec3 ro=vec3(0.,0.,15.0);\n        vec3 cDir=normalize(ta-ro);\n        vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n        vec3 cUp=cross(cDir,cSide);\n        float depth=1.;\n        vec3 rd=vec3(uv.x*cSide+uv.y*cUp+cDir*depth);\n\n        float d, t, acc, flash = 0.0;\n        float adjD = 1.;\n\n        for (int i = 0; i < 80; i++)\n        {\n            d = map(ro + rd * t);\n            if (d < 0.001 )break;\n            t += d * adjD;\n            acc += exp(-1.0 * d);\n\n\n        }\n\n        vec3 refRo = ro + rd * t;\n        vec3 n = gn(refRo);\n        rd = reflect(rd, n);\n        //rd = refract(rd, n,0.5);\n        ro = refRo;\n        t = 0.1;\n        float acc2 = 0.0;\n        for (int i = 0; i < 40; i++) {\n            d = map(ro + rd * t);\n            if (d < 0.001)break;\n            t += d* adjD;\n            acc2 += exp(-1.0 * d);\n        }\n\n\n\n\n        col = acc* vec3(1.0,1.,1.) *0.02;\n        col += acc2 * vec3(1.,1.,1.) * 0.02;\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}