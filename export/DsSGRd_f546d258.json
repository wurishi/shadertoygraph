{"ver":"0.1","info":{"id":"DsSGRd","date":"1668000209","viewed":120,"name":"Walking Voxel Space","username":"midorikuma","description":"liminal","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 trans(vec3 p){\n    return vec3(p.x,p.y,mod(p.z, 20.0)-10.0);\n}\nfloat sdBox1(vec3 p){\n    p+=vec3(-2.0,0.0,0.0);\n    vec3 q = abs(trans(p)) - vec3(0.5,0.5,0.5);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox2(vec3 p){\n    p+=vec3(3.0,0.0,6.0);\n    vec3 q = abs(trans(p)) - vec3(0.5,3.0,1.5);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTorch(vec3 p){\n    float d=5.0/16.0;\n    p+=vec3(-2.0,-0.5-d,0.0);\n    vec3 q = abs(trans(p)) - vec3(0.2,1.0,0.2)*d;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdFloor(vec3 p){\n    return dot(p, vec3(0.0, 1.0, 0.0)) + 0.5;\n}\nfloat distFunc(vec3 p){\n    float d0 = sdFloor(p);\n    float d1 = sdBox1(p);\n    float d2 = sdBox2(p);\n    float d3 = sdTorch(p);\n    return min(d0,min(d3,min(d1, d2)));\n}\n\nvec3 genNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 genColor(vec3 p){\n    vec3 m = mod(abs(p),1.0);\n    vec3 mt = floor(m*16.0);\n    vec3 col;\n    if(p.y<-0.499){\n        col = vec3(0.4,0.75-rand(mt.xz+mt.y)*0.2,0.4);\n    }else if(0.0<p.x){\n        col = vec3(0.7,0.6,0.5)-rand(mt.xz+mt.y)*0.3;\n        if(0.501<p.y){\n            col = vec3(0.9,0.7,0.0)-rand(mt.xz+mt.y)*0.3;\n        }\n        if(1.0<p.y){\n            col = vec3(2.0,1.8,0.0)-rand(mt.xz+mt.y)*0.3;\n        }\n    }else if(p.x<0.0){\n        col = vec3(0.9,0.9,0.9)-rand(mt.xz+mt.y)*0.3;\n    }\n    float noise = 1.0-rand(m.xy)*0.3;\n    vec3 colp = step(0.9,rand(m.xy+0.1))*vec3(1.0,0.0,1.0)*0.3;\n    vec3 colb = step(0.8,rand(mt.xz+mt.y*0.1))*vec3(1.0,1.0,1.0)*0.1;\n    vec3 lit = clamp(5.0-length(trans(p+vec3(-2.0,-0.5,0.0))), 0.0, 5.0)*vec3(1.0,0.6,0.0)*0.1;\n    return col*noise+colp+colb+lit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime/acos(-1.0)*15.0;\n    vec3 cPos = vec3(cos(t)*0.1,  cos(t*2.0)/2.0*0.1, mod(iTime*3.0,20.0));\n    cPos+=vec3(0.0,1.5,0.0);\n    vec3 cDir = vec3(0.0,0.0,1.0);\n    vec3 cUp  = vec3(0.0,  0.6,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    float tmp, dist;\n    tmp = 0.0;\n    vec3 dPos = cPos;\n    for(int i = 0; i < 256; i++){\n        dist = distFunc(dPos);\n        tmp += dist;\n        dPos = cPos + tmp * ray;\n    }\n    \n    vec3 lightDir = vec3(-0.57, 1.57, 0.57);\n    vec3 normal = genNormal(dPos);\n    vec3 color = genColor(dPos);\n    color *= clamp(dot(lightDir, normal), 0.6, 1.0);\n    color -= length(dPos-cPos)/25.0;\n    vec2 rs = abs(gl_FragCoord.xy / iResolution.xy*2.0-1.0);\n    color += length(rs)*0.15-0.1;\n    color *= float(rs.x<iResolution.y/iResolution.x/3.0*4.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}