{"ver":"0.1","info":{"id":"MXKGDh","date":"1717609372","viewed":84,"name":"4o","username":"erpprog","description":"generated by gpt-4o","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GPT-4o\n// CC0: Custom Shader for Demoscene Festival\n// Inspired by advanced shader techniques and aiming for a complex, visually stunning effect\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// Function to generate random vectors\nvec3 rand(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n                          dot(p, vec3(269.5, 183.3, 246.1)),\n                          dot(p, vec3(113.5, 271.9, 124.6))))*43758.5453);\n}\n// Function to generate procedural noise\nfloat noise(vec3 p) {\n    vec3 ip = floor(p);\n    vec3 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    float res = mix(mix(mix( dot(rand(ip), u-vec3(0,0,0) ), \n                               dot(rand(ip+vec3(1,0,0)), u-vec3(1,0,0) ), u.x),\n                          mix( dot(rand(ip+vec3(0,1,0)), u-vec3(0,1,0) ), \n                               dot(rand(ip+vec3(1,1,0)), u-vec3(1,1,0) ), u.x), u.y),\n                     mix(mix( dot(rand(ip+vec3(0,0,1)), u-vec3(0,0,1) ), \n                               dot(rand(ip+vec3(1,0,1)), u-vec3(1,0,1) ), u.x),\n                          mix( dot(rand(ip+vec3(0,1,1)), u-vec3(0,1,1) ), \n                               dot(rand(ip+vec3(1,1,1)), u-vec3(1,1,1) ), u.x), u.y), u.z);\n    return res;\n}\n\n\n\n// Function to create smooth oscillations\nfloat smoothOsc(float x) {\n    return 1.3+pow(x,0.232) + sin(x/2.0) * sin(x)*cos(x);\n}\n\n// Main function to render the image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / RESOLUTION.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= RESOLUTION.x / RESOLUTION.y;\n\n    float time = TIME * 0.65;\n    // Base coordinate transformation\n    float angle = atan(uv.y, uv.x) + time;\n    float radius = length(uv);\n    vec2 p = vec2(cos(angle), sin(angle)) * radius;\n\n    // Generate complex noise pattern\n    vec3 pos = vec3(p * 3.0, time * 0.5);\n    float n = noise(pos);\n    \n    // Apply swirling and twisting effect\n    angle += n * TAU;\n    p = vec2(cos(angle), sin(angle)) * radius;\n\n    // Color manipulation based on noise\n    vec3 color1 = vec3(0.2, 0.4, 0.8) * smoothOsc(time * 0.1);\n    vec3 color2 = vec3(0.8, 0.2, 0.6) * smoothOsc(time * 0.15 + PI);\n    vec3 color = mix(color1, color2, n);\n\n    // Add additional transformation for more complexity\n    p *= ROT(time * 0.2);\n    n = noise(vec3(p * 5.0, time * 0.5));\n    color = mix(color, vec3(0.0), smoothstep(0.0, 1.0, radius) * (1.0 - n));\n\n    // Introduce dynamic swirling effect\n    float swirl = sin(time + radius * 5.0);\n    p *= ROT(swirl * 0.3);\n    n = noise(vec3(p * 6.0, time));\n    color = mix(color, vec3(0.5, 0.3, 0.7) * smoothOsc(time * 0.2 + PI / 2.0), n);\n\n    // Final color blending with dynamic changes\n    color = mix(color, color1, sin(n * PI * 2.0 + time * 0.5) * 0.5 + 0.5);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}