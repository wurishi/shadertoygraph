{"ver":"0.1","info":{"id":"msdSDN","date":"1680298142","viewed":37,"name":"tartan_v2","username":"fishbrains","description":"doing it again but using if statements for the masks. it makes a lot more sense this way, i guess it works mostly for simple stuff.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pattern","tartan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\n// from book of shaders\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\n// from book of shaders\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\n// from book of shaders\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat drawLine( float a, float b, float w ) {\n    return step(a, b) + step(b, a-w);\n}\n\nfloat drawTexture(vec2 st, float w) {\n    st = rotate2D(st, PI*0.25);\n    float lines = 1.;\n    for(int i=0;i<50;++i) {\n        lines *= drawLine(float(i)/20., st.x, w);\n    }\n    return lines;\n}\n\nvec3 tartan(vec2 st) {\n    vec3 color = vec3(1.);\n    \n    float red = (drawLine(.1, st.y, .05) * drawLine(.81, st.y, .05) * drawLine(.6, st.x, .05) * drawLine(-.11, st.x, .05));\n    float redtexture = red + drawTexture(st, .02);\n    float grey = (drawLine(.4, st.x, .25) * drawLine(1.109, st.x, .25) * drawLine(.9, st.y, .25) * drawLine(.2, st.y, .25));\n    float greytexture = grey + drawTexture(st, .02);\n    float black = drawLine(.5, st.x, .15) * drawLine(1.21, st.x, .15);\n    float blacktexture = black + drawTexture(st, .035);\n    \n    color = mix(vec3(0.585,0.585,0.585), color, grey);\n    color = mix(vec3(0.800,0.800,0.800), color, greytexture);\n    color = mix(vec3(0.665,0.000,0.000), color, red);\n    color = mix(vec3(0.), color, blacktexture);\n    return color;\n}\n\nvec3 tartan2(vec2 st) {\n    vec3 color = vec3(0.);\n\n    float red = (drawLine(.1, st.y, .05) * drawLine(.81, st.y, .05) * drawLine(.6, st.x, .05) * drawLine(-.11, st.x, .05));\n    float grey = (drawLine(.4, st.x, .25) * drawLine(1.109, st.x, .25) * drawLine(.9, st.y, .25) * drawLine(.2, st.y, .25));\n    float greytexture = grey + drawTexture(st, .03);\n    float black = drawLine(.5, st.x, .15) * drawLine(1.21, st.x, .15);\n    float blacktexture = black + drawTexture(st, .035);\n    \n    vec3 redmask = vec3(1.-red);\n    vec3 greytexturemask = vec3(1.-greytexture)*red*black;\n    vec3 blackmask = vec3(1.-black)*blacktexture*red;\n    vec3 bgmask = vec3(red*greytexture*blacktexture);\n    \n    if (redmask.r > 0.) {\n        color = vec3(0.665,0.000,0.000);\n    } else if (greytexturemask.r > 0.) {\n        color = vec3(0.800,0.800,0.800);\n    } else if (bgmask.r > 0.) {\n        color = vec3(1.);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    st = tile(st,5.);\n\n    // Use a matrix to rotate the space 45 degrees\n    st = rotate2D(st,PI*0.25);\n\n    color = tartan2(st);\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}