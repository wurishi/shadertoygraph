{"ver":"0.1","info":{"id":"Ws3yzs","date":"1601542644","viewed":271,"name":"Basic : Reintegration Track. SPH","username":"Gijs","description":"All credit to @michael0884 aka Mykhailo Moroz. https://michaelmoroz.github.io/Reintegration-Tracking/ . Use your mouse!","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["2d","fluid","tracking","sph","reintegration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Particle getParticle(ivec2 cell){\n\treturn decodeParticle(texelFetch(iChannel0, cell, 0), cell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 cell = ivec2(fragCoord);\n    Particle P = getParticle(cell);\n\n    fragColor = mix(\n        vec4(0),\n        vec4(pow(abs(P.velocity)/maxvelocity,vec2(.5)), 1., 1),\n        P.mass\n    );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Handles velocity integration & tracking of the particles\n//Conserves mass & momentum\n\nParticle getParticle(ivec2 cell){\n\treturn decodeParticle(texelFetch(iChannel0, cell, 0), cell);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 cell  = ivec2(fragCoord);\n    \n    vec2  position = vec2(0);\n    vec2  velocity = vec2(0);\n    float mass = 0.;\n    \n    for(int dx=-R; dx<=R; dx++){\n    for(int dy=-R; dy<=R; dy++){  \n        ivec2 neighbour = cell + ivec2(dx,dy);\n        //outside domain\n        if(neighbour.x<0 || \n           neighbour.y<0 || \n           neighbour.x>=int(iResolution.x) || \n           neighbour.y>=int(iResolution.y)\n        ) continue;\n\t\tParticle P = getParticle(neighbour);\n        \n        //integrate velocity\n        P.position += P.velocity*dt;\n        \n        //distribution boxes\n        Box cellbox = Box(vec2(cell),vec2(cell)+1.);\n        Box partbox = Box(P.position - D, P.position + D);\n        \n        //move the particle box within the domain, otherwise we lose stuff :(\n        if(partbox.min.x<0.) partbox.max.x -= partbox.min.x, partbox.min.x = 0.;\n        if(partbox.min.y<0.) partbox.max.y -= partbox.min.y, partbox.min.y = 0.;\n        if(partbox.max.x>iResolution.x) partbox.min.x -= partbox.max.x-iResolution.x, partbox.max.x = iResolution.x;\n        if(partbox.max.y>iResolution.y) partbox.min.y -= partbox.max.y-iResolution.y, partbox.max.y = iResolution.y;\n        \n        Box   overlap           = intersectBox(cellbox, partbox);\n        vec2  overlapCenter     = centerBox(overlap); \n        float overlapArea       = areaBox(overlap);\n        float overlapNormalized = overlapArea/areaBox(partbox);\n        \n        float overlapMass = overlapNormalized*P.mass;\n        \n        mass     += overlapMass;\n        position += overlapMass*overlapCenter;\n        velocity += overlapMass*P.velocity;\n    }\n    }\n    \n    if(mass>0.){\n        position /= mass;\n        velocity /= mass;\n    }\n    \n    fragColor = encodeParticle(Particle(position,velocity,mass), cell);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Size of the neighbourhood that is considered in all calculations (Particle Tracking & SPH)\nconst int R = 2;\n\n//The distribution radius, in some sense the size of the particles\nconst float D = .55;\n\n//the time step\nconst float dt = 1.;\n\n//The size of the kernel used in the SPH calculations\nconst float h = 1.;\n\n//Pi\nconst float pi = 3.1415;\n\n//density of the fluid \nconst float fluid_density = .7;\n\n//viscosity of the fluid (currently broken??)\nconst float viscosity = .0;\n\n//gravity\nconst vec2 gravity = vec2(0,-0.00001);\n\n//maximum velocity the particles may travel at\nconst float maxvelocity = 1.;\n\n//Now, a rule of thumb is that 'maxvelocity*dt' should but at most 'R - D', otherwise particles are lost while tracking\n//Another rule is that 'dt' should but at most '1/maxvelocity' otherwise the fluid simulation becomes unstable\n\n//particle with pos in [0,1], vel in [-maxvelocity,maxvelocity], and mass any float\nstruct Particle {\n    vec2  position;\n    vec2  velocity;\n    float mass;\n};\n    \nstruct Box{\n    vec2 min;\n    vec2 max;\n};\n\nBox intersectBox(Box A, Box B){\n\treturn Box(max(A.min, B.min), min(A.max, B.max));   \n}\n\nfloat areaBox(Box A){\n\treturn max(A.max.x-A.min.x,0.)*max(A.max.y-A.min.y,0.);\n}\n\nvec2 centerBox(Box A){\n    return (A.min+A.max)*.5;\n}\n\n// decodes a float, which currently should only be interpreted as a bitstring,\n// into two floats in the range [-1,1]\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpackSnorm2x16(X); // clamp(float(int) / 32767.0, -1.0, 1.0)\n}\n\n// encodes two floats in the range[-1,1] into a bitstring,\n// which is represented as a float\nfloat encode(vec2 x)\n{\n    uint X = packSnorm2x16(x); // round(clamp(float, -1.0, 1.0) * 32767.0)\n    return uintBitsToFloat(X); \n}\n    \nParticle decodeParticle(vec4 c, ivec2 cell){\n    vec2  position = decode(c.x)+vec2(cell);\n    vec2  velocity = decode(c.y)*maxvelocity;\n    float mass = c.z;\n    return Particle(position,velocity,mass);\n}\n\nvec4 encodeParticle(Particle p, ivec2 cell){\n\tfloat x = encode(p.position-vec2(cell));\n    float y = encode(p.velocity)/maxvelocity;\n    float z = p.mass;\n    return vec4(x,y,z,0.);\n}\n\n//Guassian kernel\nfloat Kernel(float r){\n\treturn exp(-r*r/(h*h))/(pi*h*h);\n}\n\nfloat DerivativeKernel(float r){\n\treturn -2.*r/(h*h)*Kernel(r);\n}\n\n//Density to pressure\nfloat Pf(float density){\n    return 0.04*density*(density/fluid_density - 1.); //water pressure\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//does the fluid simulation by changing the velocities of the particles accordingly\n\nParticle getParticle(ivec2 cell){\n\treturn decodeParticle(texelFetch(iChannel0, cell, 0),cell);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 cell  = ivec2(fragCoord);\n    \n    Particle P1 = getParticle(cell);\n    \n    //initial state\n    if(iFrame==0){\n    \tP1.position = fragCoord;\n        P1.velocity = cos(fragCoord*.1);\n        P1.mass = .3;\n    }\n\n    //only simulate of their is mass here\n    if(!(P1.mass>0.)){\n        fragColor = encodeParticle(P1, cell);\n       \treturn;\n    }\n    \n    vec2 force = vec2(0);\n    \n    for(int dx=-R; dx<=R; dx++){\n    for(int dy=-R; dy<=R; dy++){\n        if(dx==0&&dy==0) continue;\n        ivec2 neighbour = cell + ivec2(dx,dy);\n        //outside domain\n        if(neighbour.x<0 || \n           neighbour.y<0 || \n           neighbour.x>=int(iResolution.x) || \n           neighbour.y>=int(iResolution.y)\n        ) continue;\n\t\tParticle P2 = getParticle(neighbour);\n        \n        //delta vector, distance and normal vector between P1 and P2\n            vec2 delta = P1.position-P2.position;\n            float dist = length(delta);\n            vec2 normal = delta/dist;\n\n        //Kernel related calculations\n            float W     = Kernel(dist);\n            //float dW    = DerivativeKernel(dist);  \n            //gradW is the gradient of Kernel(dist) w.r.t P1.pos\n            //its equivalent to dW * normal but the normal calculation has a nasty division\n            vec2  gradW = -delta*2./(h*h)*W;\n        \n        //Density and pressure calculation\n            float dens1 = P1.mass/1.; //aproximate density by dividing the mass of the particle by the size of the cell(1x1)\n            float dens2 = P2.mass/1.;\n            float pres1 = Pf(dens1);\n            float pres2 = Pf(dens2);\n\n        //pressure\n            //below the standard SPH pressure force, but it doesn't want to work at all\n            //force += - P1.mas * P2.mas * (pres1/(dens1*dens1) + pres2/(dens2*dens2)) *  gradW;\n            //this is one michael0884 uses and it works fine\n            force += - .5 * P2.mass * P1.mass * (pres1 + pres2) *  gradW;\n        \n        //viscosity\n            //below the standard SPH viscosity force\n        \t//doesn't seem to be working properly\n            force += viscosity * P1.mass * 2. * dot(P1.velocity - P2.velocity, delta)/(dist*dist) * gradW;\n        \n       \t//gravity\n        \tforce += P1.mass * gravity;\n        \n        //border forces\n        \tforce.y += P1.mass * exp(-P1.position.y);\n        \tforce.x += P1.mass * exp(-P1.position.x);\n        \tforce.y -= P1.mass * exp(-iResolution.y+P1.position.y);\n        \tforce.x -= P1.mass * exp(-iResolution.x+P1.position.x);\n    }\n    }\n    \n    //integrate acceleration\n    P1.velocity += force/P1.mass*dt;\n    \n    //interactivity\n    if(iMouse.z>0.){\n        float d = distance(fragCoord,iMouse.xy);\n        P1.velocity += (iMouse.xy-iMouse.zw)/(d*d*d+1.)*10.;\n    }\n       \n    //exceed max velocity\n    float l = length(P1.velocity);\n    if(l>maxvelocity) P1.velocity *= maxvelocity/l;\n    \n    //problems\n    if(any(isnan(P1.velocity))) P1.velocity = vec2(0.);\n    if(isnan(P1.mass)) P1.mass = 0.;\n    \n    fragColor = encodeParticle(P1, cell);\n}","name":"Buffer C","description":"","type":"buffer"}]}