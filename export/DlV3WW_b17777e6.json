{"ver":"0.1","info":{"id":"DlV3WW","date":"1717980102","viewed":83,"name":"Endless Julia Set Zoom","username":"amhall","description":"Fake infinite zoom of a z^2 + C Julia set.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mandelbrot","zoom","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Endless Julia Set Zoom\n// Anthony Hall\n\n// Julia sets of z^n + C are not perfectly self-similar. A repeating structure\n// approaches perfect self-similarity the deeper you zoom into it, i.e. the\n// visual distortion between subsequent \"levels\" becomes less noticeable.\n\n// So what this does is keeps looping a zoom that already starts a bit deep.\n// The depth is hand picked to balance performance vs visible distortion/\n// noticeable deviation from perfect self similarity when it loops.\n\n// To calculate the scale/rotation per \"level\", I rendered a 10k x 10k\n// version and measured the pixel coordinates of the same feature at adjacent\n// \"levels.\" I zoomed extra deep with doubles for this render so it could be\n// nearly (visually) perfectly self similar for the reference measurements.\n\n\n// Supersample grid size\n// Both the fancy and fast versions attempt to counteract aliasing with their render styles\nconst int ss = 1;\n\n// Comment out for less dense set (better performance)\n#define DENSER\n\n// Don't calculate derivative, only escape time (better performance, fewer colors though)\n//#define FAST\n\n// In debug, one level is added to zoom while mouse is pressed, to test loop seamlessness\n//#define DEBUG\n\n\n// Define the measurements of the reference structures\n#ifdef DENSER\n\n    // I know we use floats here but I'm leaving the double precision values I used to take the measurements\n    const vec2 C = vec2(0.3969907407407407, -0.4270833333333333);\n    const vec2 center = vec2(-0.1096924336304171, 0.5471112657459059);\n    \n    // Measured pixel offset of reference structure\n    const vec2 outerRef = vec2(2387, 8764) - vec2(5000);\n    \n    // Measured pixel offset of the next structure down\n    const vec2 innerRef = vec2(4933, 7646) - vec2(5000);\n    \n    // Iteration difference between reference structure and the next structure down\n    // It's no coincidence that this matches the period of this Julia set\n    const int endIterOffset = 5;\n    \n#else\n\n    const vec2 C = vec2(0.28125, -0.6956018518518519);\n    const vec2 center = vec2(0.07665130412604315, 0.6031390607067878);\n    const vec2 outerRef = vec2(634.5, 8695.5) - vec2(5000);\n    const vec2 innerRef = vec2(4072, 7446) - vec2(5000);\n    const int endIterOffset = 4;\n    \n#endif\n\nconst float startScale = 1e-3;\nconst float endScale = startScale * (length(innerRef) / length(outerRef));\nconst float endRot = atan(outerRef.y, outerRef.x) - atan(innerRef.y, innerRef.x); // flipped because measurement coords have inverted y\n    \n    \n// Globals/\"uniforms\" calculated in mainImage()\nfloat scale = 1.0;\nfloat rotTheta = 0.0;\nmat2 rot = mat2(1.0);\nfloat iterOffset = 0.0;\n\n\nconst float pi = radians(180.0);\nconst float tau = radians(360.0);\n\n\n// Complex arithmetic\nvec2 cSquare(vec2 c)\n{\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\nvec2 cMul(vec2 c1, vec2 c2)\n{\n    return vec2(c1.x*c2.x - c1.y*c2.y, c1.x*c2.y + c2.x*c1.y);\n}\nvec2 cDiv(vec2 c1, vec2 c2)\n{\n    return cMul(c1, vec2(c2.x, -c2.y) / dot(c2, c2));\n}\n\n// Overlay blend mode found in most image editing applications\nvec3 overlayBlend(vec3 base, vec3 top)\n{\n    return mix(\n        2.0 * base * top,\n        1.0 - 2.0 * (1.0 - base) * (1.0 - top),\n        greaterThan(base, vec3(0.5)));\n}\n\n// Actual main shader\nvec3 image(vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    #ifdef FAST\n        \n        // When iter count reaches this threshold, the glow is fully bright\n        // Increase the threshold away from the screen center for better AA\n        \n        #ifdef DENSER\n            float iterGlowThreshold = mix(99.0, 92.0, length(uv)) + iterOffset;\n        #else\n            float iterGlowThreshold = mix(63.0, 60.0, length(uv)) + iterOffset;\n        #endif\n        \n        // No point computing further when we are guaranteed to be fully glowing\n        int maxIters = int(ceil(iterGlowThreshold));\n        \n    #else\n    \n        const int maxIters = 200; // Overkill but they're disconnected sets so we can't overcompute\n        \n    #endif\n    \n    const float escapeR = 10.0;\n    \n    vec2 z = center + scale * rot * uv;\n    vec2 dz = vec2(1, 0);\n    float zz; // z.z\n    int iters;\n    float smoothIters;\n    \n    for (iters = 0; iters < maxIters; iters++)\n    {\n        #ifndef FAST\n            dz = 2.0 * cMul(z, dz);\n        #endif\n        z = cSquare(z) + C;\n        zz = dot(z, z);\n        if (zz >= escapeR * escapeR)\n            break;\n    }\n    \n    if (iters == maxIters)\n    {\n        smoothIters = float(iters);\n    }\n    else\n    {\n        // Offset so smoothIters accurately reflects actual iteration count\n        // (i.e. boundary between escaped points and stable points is continuous)\n        // This is very important for FAST mode\n        smoothIters = float(iters) + 1.0\n            - (log2(log2(zz)) - log2(log2(escapeR)) - 1.0);\n    }\n    \n    #ifdef FAST\n    \n        const float kBright = 20.0;\n        float dist = max(0.0, iterGlowThreshold - smoothIters);\n        float intensity = kBright / (kBright + dist);\n        \n        // 3x smoothstep so the transition to the brightest value is less abrupt\n        for (int i = 0; i < 3; i++)\n        {\n            intensity = intensity * intensity * (3.0 - 2.0 * intensity);\n        }\n\n        // Blue glow\n        return pow(vec3(intensity), vec3(8.0, 2.0, 1.0));\n        \n    #else\n\n        vec2 gradient = cDiv(z, dz);\n        float theta = atan(gradient.y, gradient.x); // \"Escape direction\"\n\n        // Rainbow cosine palette\n        vec3 rainbow = 0.5 + 0.5 * cos(theta - rotTheta\n            + (0.2 * vec3(-1, 0, 1) - 0.2 * iTime) * tau);\n             \n        // Distance estimator from iq\n        // https://iquilezles.org/articles/distancefractals/\n        float dist = log2(zz) * sqrt(zz / dot(dz, dz));\n        dist = dist / scale; // Make it zoom invariant\n\n        const float kBright = 0.015;\n        float intensity = kBright / (dist + kBright);\n\n        return overlayBlend(vec3(intensity), rainbow);\n\n    #endif\n}\n\n// Calculate uniforms and supersample image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Depth measured in \"levels\" (from one island to the next smallest one)\n    float apparentDepth = iTime / 1.5;\n    float depth = fract(apparentDepth);\n\n    #ifdef DEBUG\n        depth += float(iMouse.z > 0.0);\n    #endif\n    \n    scale = exp2(mix(log2(startScale), log2(endScale), depth));\n    rotTheta = endRot * depth - 0.5 * apparentDepth; // Slow down the spin (and make the loop not obvious)\n    rot = mat2(cos(rotTheta), sin(rotTheta), -sin(rotTheta), cos(rotTheta));\n    iterOffset = float(endIterOffset) * depth;\n\n    vec3 color = vec3(0.0);\n    for (int y = 0; y < ss; y++)\n    {\n        for (int x = 0; x < ss; x++)\n        {\n            const float increment = 1.0 / float(ss);\n            const float offset = 0.5 * increment - 0.5;\n            vec2 subFragCoord = fragCoord + offset + increment * vec2(x, y);\n            color += image(subFragCoord);\n        }\n    }\n    color /= float(ss * ss);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}