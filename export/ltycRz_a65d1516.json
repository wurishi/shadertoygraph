{"ver":"0.1","info":{"id":"ltycRz","date":"1534835050","viewed":946,"name":"MultiJulia v:(0.0.0)","username":"Chris_M_Thomasson","description":"An initial try at an exploded Julia set wrt my:\n\nhttp://www.fractalforums.com/index.php?action=gallery;sa=view;id=20582\n\nexperiment using a vector field.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["fractal","experiment","field","vector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nExploding Julia Hyperbolic Vector v:(0.0.0)\n\nby: Chris M. Thomasson\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 16\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    float eps = 0.00001;\n    vec2 g = vec2(eps, eps);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        if (mass == 0.0) mass = 0.00001;\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    float s = 1.0;\n    float t = iTime * .1;\n    vec2 jc = vec2(-1.6 + abs(cos(iTime * .01)), 0.0);\n    vec3 xxxcolor = vec3(0, 0, 0);\n    \n    vec2 zcopy = z;\n    \n    // Augment z with some Mandelbrot iterations\n    for (int i = 0; i < 9; ++i)\n    {\n        z = ct_cmul(z, z);\n    \tz = z + jc;\n        \n        if (length(z) > 2.0)\n        {\n            xxxcolor += vec3(float(i) * .07, 0, 0);\n            //z = zcopy;\n            //break;\n            \n            float xmin = .14;\n            float xmax = .16;\n            float xdif = xmax - xmin;\n            \n            z = z * .01;\n        }\n        \n        else\n        {\t\n            xxxcolor += vec3(.01, .01, .01);\n        }\n    }\n\n    \n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = 0.0;\n\n    vec2 rc = vec2(\n        vn[0] * cos(a) - vn[1] * sin(a),\n        vn[0] * sin(a) + vn[1] * cos(a)\n    );\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float scale = float(CT_N);\n    \n    float color = mod(npi * scale, 1.0);\n    \n    if (color < abs(sin(iTime * .2)) * .05 + .95)\n    //if (color < 1.0)\n    {\n        color = 1.0 - color;\n    }\n    \n    else\n    {\n        color = 0.0;\n    }\n    \n    return vec4(\n        color + (abs(vn.x) * abs(sin(iTime)) * .2),\n        color + (abs(vn.y) * abs(cos(iTime)) * .1),\n        color + (abs(vn.x * vn.y) * .1),\n        1.0\n    );\n\n}\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    \n    const int n = CT_N;\n    float scale = 1.0;\n    \n    float my_time = 0.0;\n    \n    float r = 0.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28 + abs(cos(my_time * .1)) * 1.0;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec2(cos(angle) * r, sin(angle) * r), \n            -1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cmx = ct_plane2d_project(plane, vec2(iMouse));\n        vec2 cm = vec2(0.0, sin(iTime * 3.0) * .4);\n        g_vfp[n] = ct_vfpoint(\n            cm, \n            1.5\n        );\n    }\n    \n    \n    vec2 rc = rotate(c, iTime);\n\n    \n    return ct_vpixel(rc, rc, 128, 2.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0, \n        0.0, \n        .01 + abs(sin(iTime * .03)) * 100.0\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}