{"ver":"0.1","info":{"id":"WltGRH","date":"1575626839","viewed":146,"name":"AA is hard, notes","username":"Carandiru","description":"some first-hand trials and errors\nconcluding with some notes on usage of smoothstep\nmaybe helpful to some else whos trying to figure it out too.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// some (hopefully correct) observations on using smoothstep and comparing with aaStep\n\n\n//smooth version of step - https://www.ronja-tutorials.com/2019/11/29/fwidth.html\n// produces a harder cut off in conparison with smoothstep, if smoothstep can't be used use this\n// usage:\n// float aa = aaStep(0.25f, gradient); // harder cut off\n// -or-\n// float aa = smoothstep(0.24f, 1.0f, gradient); // smoother cut off\n//\n// gradient *= aa;  // applying cutoff (hardly)\n// -or-\n// gradient = (gradient - aa * 0.5f) * aa;  // applying cutoff (smoothly)\n//\n// **** to remember:\n// float aa = smoothstep(0.0f, gradient, gradient);  ** pretty much equals gradient** so the line below this does nothing\n//  gradient *= aa;\n// -however-\n// float aa = smoothstep(0.0f, 1.0f, gradient);\t**actually smooths and remaps the gradient to the smoothstep function\n//  gradient *= aa; // apply smoothstep to original grasdient\n// -and-\n// *** if the value of second parameter is smaller than first parameter into smoothstep\n// there will be an undesired \"inverse\" cutoff ***\n// if the value for the second parameter is larger than 1.0f, the result is no longer normalized in the range 0..1.0\n// ie.) smoothstep(0.0f, 1.5f, gradient) requires : smoothstep(0.0f, 1.5f, gradient) / (1.5f*1.5f)  to normalize again\n// I dunno about you but negative values are way outside the scope of smoothstep\n// #### use smoothstep rather than aaStep, only use aaStep in special cases where a smoother, but harder cutoff is needed (in comparison to step())\n// or if \"linearerity\" is critically important and smoothstep is introducing unsightly waves of discontuity ####\n\n//smooth version of step - https://www.ronja-tutorials.com/2019/11/29/fwidth.html\nfloat aaStep(in float compValue, in float gradient){\n  float halfChange = fwidth(gradient) * 0.5f;\n  //base the range of the inverse lerp on the change over one pixel\n  float lowerEdge = compValue - halfChange;\n  float upperEdge = compValue + halfChange;\n  //do the inverse interpolation\n  return( clamp((gradient - lowerEdge) / (upperEdge - lowerEdge), 0.0f, 1.0f) );\n}\n\nvec2 rotate( in vec2 p, in float angle )\n{\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(p.x * cossin.c_+ p.y * cossin.s, p.x * -cossin.s_+ p.y * cossin.c_) );\n\n\t#undef c_\n\t#undef s_\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv * 2.0f - 1.0f;\n    \n    uv = rotate(uv, (sin(iTime * 0.5f)));\n    \n    uv = uv * (1.0f/0.5f);\n    //uv = uv * 0.5f + 0.5f;\n    //uv = uv * 2.0f - 1.0f;\n    \n    float gradient = length(uv);// + 0.5f - uv.y;\n    gradient = (gradient*0.5f);\n    //gradient = fract(gradient) * 1.618f;\n    \n    // Time varying pixel color\n    //float aa = aaStep(0.05f, gradient);\n    float aa = smoothstep(0.0f, 1.0f, gradient);\n    gradient *= aa;\n\t//gradient = (gradient - aa * 0.5f) * aa;\n    \n    // Output to screen\n    fragColor = vec4(vec3(gradient),1.0);\n}","name":"Image","description":"","type":"image"}]}