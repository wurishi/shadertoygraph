{"ver":"0.1","info":{"id":"MttSWS","date":"1481497423","viewed":2853,"name":"Progressive Lightmap Render","username":"huwb","description":"Accumulates diffuse-only GI into a lightmap for the scene. Gathers radiance in UV space - rays cast for each lightmap texel, accumulated over time. Move light with mouse, scene converges when light is stationary.","likes":55,"published":1,"flags":32,"usePreview":0,"tags":["gi","global","illumination","diffuse","lightmap","caching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// gather version of an experiment i did in unity: https://twitter.com/hdb1/status/805887693905391616\n\n// this caches gi in the lightmap (diffuse only). each frame it pumps energy\n// into the scene from the light and gathers illumination from surfaces.\n\n// the lightmap is object space, so no screen space artifacts.\n// the disadvantage is that there needs to be a geometry raytrace/march on the gpu.\n\n// when lighting changes slowly (time of day comes to mind), a system like this\n// could work well (especially if lightmap resolution varied adaptively based\n// on distance to viewer) - provided that scene can be efficiently raytraced on gpu..\n\n// i think this implementation is probably suffering badly from incoherent samples from the\n// lightmap texture - the performance is not as good as i had hoped. it also\n// seems to scale much worse with the amount of geometry than i had hoped.\n// i plan to look into these issues when i get access to some proper hardware (instead of\n// my crappy laptop).\n\n#define DIST_MAX 1000.\nfloat LM_RES;\n\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n#define LIGHTR 0.25\n\nstruct Quad\n{\n    vec3 p;\n    vec3 n;\n    vec2 scl;\n    vec2 uv_c; // uv ceneter\n    vec2 uv_wh; // wh of quad in uv space\n    int col; // color\n};\n\nvec3 l2w( vec3 l,vec3 normal )\n{\n\tvec3 binormal,tangent;\n\tif( abs(normal.x) > abs(normal.z) )\n\t{\n\t\tbinormal.x = -normal.y;binormal.y =  normal.x;binormal.z =  0.;\n\t}\n\telse\n\t{\n\t\tbinormal.x =  0.;binormal.y = -normal.z;binormal.z =  normal.y;\n\t}\n\tbinormal = normalize(binormal);\n\ttangent = cross( binormal, normal );\n\treturn l.x*tangent + l.y*normal + l.z*binormal;\n}\n\n#define QUAD_COUNT 10\nQuad quads[QUAD_COUNT];\n\nvec3 GetColor( int idx )\n{\n    if( idx == 0 ) return WHITECOLOR; //vec3(1.,.99,.8); // white\n    if( idx == 1 ) return REDCOLOR; //vec3(1.,.3,.3); // red\n    if( idx == 2 ) return GREENCOLOR;//vec3(.3,1.,.3); // green\n    return vec3(.3,.3,1.); // blue\n}\n\nvoid InitScene()\n{\n    LM_RES = .75*iResolution.y;\n    \n    // current lightmap packing:\n    //         ___\n    //        | T |\n    //     ___|___|___\n    //    | L | B | R |\n    //    |___|___|___|\n    //Box +XYZ| F |\n    //    -X Z|___|\n    //\n    \n    // block - first because a hit on this is likely to be closer than background walls,\n    // so only compute local frame etc once\n    vec3 bc = vec3(0.,-3.5,0.);\n    quads[ 0] = Quad( bc+vec3(0.,0.,-1.5),\tvec3(0.,0.,-1.),\tvec2(3.),\tvec2(2.5/9.,.5/6.),\tvec2(1./9.,1./6.),\t3 );\n    quads[ 1] = Quad( bc+vec3(1.5,0.,0.),\tvec3(1.,0.,0.),\t\tvec2(3.),\tvec2(.5/9.,1.5/6.),\tvec2(1./9.,1./6.),\t3 );\n    quads[ 2] = Quad( bc+vec3(-1.5,0.,0.),\tvec3(-1.,0.,0.),\tvec2(3.),\tvec2(.5/9.,.5/6.),\tvec2(1./9.,1./6.),\t3 );\n    quads[ 3] = Quad( bc+vec3(0.,1.5,0.),\tvec3(0.,1.,0.),\t\tvec2(3.),\tvec2(1.5/9.,1.5/6.),vec2(1./9.,1./6.),\t3 );\n    quads[ 4] = Quad( bc+vec3(0.,0.,1.5),\tvec3(0.,0.,1.),\t\tvec2(3.),\tvec2(2.5/9.,1.5/6.),vec2(1./9.,1./6.),\t3 );\n    \n    // floor\n    quads[ 5] = Quad(\tvec3(0.,-5.,0.),\tvec3(0.,1.,0.),\t\tvec2(10.),\tvec2(0.5,1./6.),\tvec2(1./3.,1./3.),\t0 );\n    // back\n    quads[ 6] = Quad(\tvec3(0.,0.,5.),\t\tvec3(0.,0.,-1.),\tvec2(10.),\tvec2(0.5,.5),\t\tvec2(1./3.,1./3.),\t0 );\n    // ceil\n    quads[ 7] = Quad(\tvec3(0.,5.,0.),\t\tvec3(0.,-1.,0.),\tvec2(10.),\tvec2(0.5,5./6.),\tvec2(1./3.,1./3.),\t0 );\n    // left wall\n    quads[ 8] = Quad(\tvec3(-5.,0.,0.),\tvec3(1.,0.,0.),\t\tvec2(10.),\tvec2(1./6.,.5),\t\tvec2(1./3.,1./3.),\t1 );\n    // right wall\n    quads[ 9] = Quad(\tvec3(5.,0.,0.),\t\tvec3(-1.,0.,0.),\tvec2(10.),\tvec2(5./6.,.5),\t\tvec2(1./3.,1./3.),\t2 );\n    // front\n    //quads[10] = Quad(\tvec3(1000.,0.,-5.),\tvec3(0.,0.,1.),\t\tvec2(0.),\tvec2(100./6.,.5),\tvec2(1./3.,1./3.),\t0 );\n    \n    // bring in by a FULL pixel on each edge to stop lerping into the lightmap for another quad\n    for( int i = 0; i < QUAD_COUNT; i++ )\n    {\n        quads[i].uv_wh -= 3./LM_RES;\n    }\n}\n\nvoid InitScene();\nint pickQuad( vec2 lightmapUV );\nint pickedQuad = -1;\nfloat castRay( vec3 ro, vec3 rd, out vec2 uv, out vec3 col );\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    \n    fragColor = vec4(0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // draw lightmap in corner\n    if( iResolution.y > 250. && fragCoord.x<LM_RES/2. && fragCoord.y<LM_RES/2. )\n    {\n        uv = fragCoord/(LM_RES/2.) * LM_RES/iResolution.xy;\n        //uv.x = 1. - uv.x;\n        fragColor = textureLod( iChannel0, uv, 0. );\n        \n\t\tfragColor.xyz = pow( clamp(fragColor.xyz,0.0,1.0), vec3(0.45) );\n        return;\n    }\n    \n    /*\n\t// picking quads from lightmap made it really slow (on my laptop)\n    pickedQuad = -1;\n    vec2 mlmuv;\n    if( iMouse.z > 0. && (mlmuv=iMouse.xy/(LM_RES/2.)).x < 1. && mlmuv.y < 1. )\n    {\n        pickedQuad = pickQuad( mlmuv );\n    }\n    //*/\n\n    \n    uv.x = .5 + (uv.x-.5)*iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.,0.,-35.);\n    vec3 rd = normalize(vec3( .35*vec2(uv-.5), 1. ));\n\n    // visualise light\n    vec3 lc = vec3(-2.,-3.,-1.5);\n    if( iMouse.z > 0. )\n\t\tlc = vec3(22.*(iMouse.x/iResolution.x-.5),-6.+12.*iMouse.y/iResolution.y,-3.+6.*iMouse.x/iResolution.x);\n    float sphDist = iSphere( ro, rd, vec4(lc,LIGHTR));\n    \n    vec2 htuv; vec3 col; float geomDist;\n    if( (geomDist=castRay( ro, rd, htuv, col )) < DIST_MAX )\n    {\n        if( sphDist > 0. && sphDist < geomDist )\n        {\n\t        // not tone mapped etc for now - just return white.\n            fragColor = vec4(1.); return;\n        }\n        \n        vec2 lmuv = htuv * LM_RES/iResolution.xy;\n        fragColor = textureLod( iChannel0, lmuv, 0. );\n        fragColor.xyz *= col;\n        \n\t\tfragColor.xyz = pow( clamp(fragColor.xyz,0.0,1.0), vec3(0.45) );\n    }\n    else\n    {\n        if( sphDist > 0. )\n        {\n\t        // not tone mapped etc for now - just return white.\n            fragColor = vec4(1.); return;\n        }\n    }\n\n    return;\n}\n\n\n\n// will return either NaN or negative number if no intersection!\nfloat rayPlane( vec3 ro, vec3 rd, vec3 po, vec3 pn )\n{\n    return -dot( ro - po, pn ) / dot( rd, pn );\n}\n// if this returns false, uv will be incorrect (offset by 0.5)\nbool rayQuadUV( vec3 ro, vec3 rd, vec3 po, vec3 pn, vec2 psz, out vec2 uv, out float rt )\n{\n    rt = rayPlane( ro, rd, po, pn );\n    if( !(rt > 0.) ) return false; // NaN caught here!\n    vec3 pos = ro + rt * rd;\n    float x = dot(pos - po, l2w( vec3(1.,0.,0.), pn ) );\n    float y = dot(pos - po, l2w( vec3(0.,0.,1.), pn ) );\n    uv = vec2(x,y)/psz;\n    if( abs(uv.x) >= .5001 || abs(uv.y) >= .5001 ) return false;\n    uv += .5;\n    return true;\n}\n\nfloat castRay( vec3 ro, vec3 rd, out vec2 uv, out vec3 col )\n{\n    uv = vec2(0.);\n    \n    float rt = DIST_MAX;\n    for( int i = 0; i < QUAD_COUNT; i++ )\n    {\n        vec2 uvi; float rti;\n        if( rayQuadUV( ro, rd, quads[i].p, quads[i].n, quads[i].scl, uvi, rti ) \n          && rti < rt )\n        {\n            uv = quads[i].uv_c + (uvi-.5)*quads[i].uv_wh;\n            col = GetColor(quads[i].col);\n            rt = rti;\n        }\n    }\n    \n    return rt;\n}\n\nint pickQuad( vec2 lightmapUV )\n{\n    for( int i = 0; i < QUAD_COUNT; i++ )\n    {\n        if( abs(lightmapUV.x-quads[i].uv_c.x) < quads[i].uv_wh.x/2.\n         && abs(lightmapUV.y-quads[i].uv_c.y) < quads[i].uv_wh.y/2. )\n        {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this buffer has one job - it records how much time passed since the mouse state changed in pixel 0,0.\n// this weights lighting contribution (large at first, falling off over time)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x > 1. || fragCoord.y > 1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec4 lastMouseState = textureLod(iChannel0,fragCoord/iResolution.xy,0.);\n    \n    float timeSinceMouseChanged = lastMouseState.w;\n    \n    timeSinceMouseChanged += iTimeDelta;\n    \n    // if mouse state changed or first frame, set timer to 0\n    vec3 stateOffset = lastMouseState.xyz - iMouse.xyz;\n    if( dot( stateOffset, stateOffset ) > 0.001 || iFrame == 0 )\n        timeSinceMouseChanged = 0.;\n    \n    // record current mouse state and running total time since last change\n    fragColor = vec4( iMouse.xyz, timeSinceMouseChanged );\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// this buffer is the lightmap render.\n// the lightmap is square, the number of pixels used is LM_RES below.\n\n// i came up with a rough approach for tweaking the convergence variables, similar in spirit\n// to the recommended steps for tweaking PID controllers.\n\n// step 1 - set this as high as your gpu can take before the framerate suffers. i like\n// to have at least 50fps\n#define INDIRECT_RAYS 20\n#define DIRECT_RAYS 20\n// step 2 - starting convergence rate. low values give poor responsiveness to lighting changes,\n// while high values give a fizzy/noisy result while the mouse is moving the lighting. i like\n// to set this as high as possible\n#define START_CONV .4\n// step 3 - after the mouse has settled, the image will start to converge. set this speed\n// to as high as possible, before the scene starts failing to converge. watch for bright spots\n// from the light being close to the wall failing to disappear after the light moves.\n#define CONV_SPEED 5.\n\n#define PI 3.14159\n#define DIST_MAX 1000.\nfloat LM_RES;\n\n#define LIGHTCOLOR vec3(16.86, 14.76, 10.2)*1.3*9.\n#define LIGHTR 0.25\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\n\n// borrowed from https://www.shadertoy.com/view/4dBXWw\nfloat seed, seed2, haltonIndex;\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\nvec3 uniformHemisphere(float u1, float u2);\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n );\nvec3 l2w(vec3 l,vec3 normal);\n//vec2 Halton();\n\nstruct Quad\n{\n    vec3 p;\n    vec3 n;\n    vec2 scl;\n    vec2 uv_c; // uv center\n    vec2 uv_wh; // wh of quad in uv space\n    int col;\n};\n\n#define QUAD_COUNT 10\nQuad quads[QUAD_COUNT];\n\nvec3 GetColor( int idx )\n{\n    if( idx == 0 ) return WHITECOLOR; //vec3(1.,.99,.8); // white\n    if( idx == 1 ) return REDCOLOR; //vec3(1.,.3,.3); // red\n    if( idx == 2 ) return GREENCOLOR;//vec3(.3,1.,.3); // green\n    return vec3(.3,.3,1.); // blue\n}\n\nvoid InitScene()\n{\n    // current lightmap packing:\n    //         ___\n    //        | T |\n    //     ___|___|___\n    //    | L | B | R |\n    //    |___|___|___|\n    //Box +XYZ| F |\n    //    -X Z|___|\n    //\n    \n    // block - first because a hit on this is likely to be closer than background walls,\n    // so only compute local frame etc once\n    vec3 bc = vec3(0.,-3.5,0.);\n    quads[ 0] = Quad( bc+vec3(0.,0.,-1.5),\tvec3(0.,0.,-1.),\tvec2(3.),\tvec2(2.5/9.,.5/6.),\tvec2(1./9.,1./6.),\t3 );\n    quads[ 1] = Quad( bc+vec3(1.5,0.,0.),\tvec3(1.,0.,0.),\t\tvec2(3.),\tvec2(.5/9.,1.5/6.),\tvec2(1./9.,1./6.),\t3 );\n    quads[ 2] = Quad( bc+vec3(-1.5,0.,0.),\tvec3(-1.,0.,0.),\tvec2(3.),\tvec2(.5/9.,.5/6.),\tvec2(1./9.,1./6.),\t3 );\n    quads[ 3] = Quad( bc+vec3(0.,1.5,0.),\tvec3(0.,1.,0.),\t\tvec2(3.),\tvec2(1.5/9.,1.5/6.),vec2(1./9.,1./6.),\t3 );\n    quads[ 4] = Quad( bc+vec3(0.,0.,1.5),\tvec3(0.,0.,1.),\t\tvec2(3.),\tvec2(2.5/9.,1.5/6.),vec2(1./9.,1./6.),\t3 );\n    \n    // floor\n    quads[ 5] = Quad(\tvec3(0.,-5.,0.),\tvec3(0.,1.,0.),\t\tvec2(10.),\tvec2(0.5,1./6.),\tvec2(1./3.,1./3.),\t0 );\n    // back\n    quads[ 6] = Quad(\tvec3(0.,0.,5.),\t\tvec3(0.,0.,-1.),\tvec2(10.),\tvec2(0.5,.5),\t\tvec2(1./3.,1./3.),\t0 );\n    // ceil\n    quads[ 7] = Quad(\tvec3(0.,5.,0.),\t\tvec3(0.,-1.,0.),\tvec2(10.),\tvec2(0.5,5./6.),\tvec2(1./3.,1./3.),\t0 );\n    // left wall\n    quads[ 8] = Quad(\tvec3(-5.,0.,0.),\tvec3(1.,0.,0.),\t\tvec2(10.),\tvec2(1./6.,.5),\t\tvec2(1./3.,1./3.),\t1 );\n    // right wall\n    quads[ 9] = Quad(\tvec3(5.,0.,0.),\t\tvec3(-1.,0.,0.),\tvec2(10.),\tvec2(5./6.,.5),\t\tvec2(1./3.,1./3.),\t2 );\n    // front\n    //quads[10] = Quad(\tvec3(1000.,0.,-5.),\tvec3(0.,0.,1.),\t\tvec2(0.),\tvec2(100./6.,.5),\tvec2(1./3.,1./3.),\t0 );\n    \n    // bring in by HALF a pixel on each edge to stop lerping into the lightmap for another quad\n    for( int i = 0; i < QUAD_COUNT; i++ )\n    {\n        quads[i].uv_wh -= 1./LM_RES;\n    }\n}\n\n\n// uv - lightmap uv in [0,1]^2\n// out - world position\nvec3 uvToWorld( vec2 uv, out vec3 n )\n{\n    for( int i = 0; i < QUAD_COUNT; i++ )\n    {\n        vec2 uvoff = (uv - quads[i].uv_c)/quads[i].uv_wh;\n        if( abs(uvoff.x) < .5\n         && abs(uvoff.y) < .5 )\n        {\n            n = quads[i].n;\n            uvoff *= quads[i].scl;\n            vec3 u = l2w( vec3(1.,0.,0.), quads[i].n );\n            vec3 v = l2w( vec3(0.,0.,1.), quads[i].n );\n            return quads[i].p + uvoff.x * u + uvoff.y * v;\n        }\n    }\n    \n    return n = vec3(0.);\n}\n\n// will return either NaN or negative number if no intersection!\nfloat rayPlane( vec3 ro, vec3 rd, vec3 po, vec3 pn )\n{\n    return -dot( ro - po, pn ) / dot( rd, pn );\n}\n// if this returns false, uv will be incorrect (offset by 0.5)\nbool rayQuadUV( vec3 ro, vec3 rd, vec3 po, vec3 pn, vec2 psz, out vec2 uv, out float rt )\n{\n    rt = rayPlane( ro, rd, po, pn );\n    if( !(rt > 0.) ) return false; // NaN caught here!\n    vec3 pos = ro + rt * rd;\n    float x = dot(pos - po, l2w( vec3(1.,0.,0.), pn ) );\n    float y = dot(pos - po, l2w( vec3(0.,0.,1.), pn ) );\n    uv = vec2(x,y)/psz;\n    if( abs(uv.x) >= .5001 || abs(uv.y) >= .5001 ) return false;\n    uv += .5; \n    return true;\n}\n// rd does not have to be normalized - this is used as an optimisation in the primary light raycast\nfloat castRay( vec3 ro, vec3 rd, out vec2 uv, out vec3 col, out vec3 n )\n{\n    uv = vec2(0.); n = uv.xxx;\n    \n    float rt = DIST_MAX;\n    for( int i = 0; i < QUAD_COUNT; i++ )\n    {\n        vec2 uvi; float rti;\n        if( rayQuadUV( ro, rd, quads[i].p, quads[i].n, quads[i].scl, uvi, rti ) \n          && rti < rt )\n        {\n            uv = quads[i].uv_c + (uvi-.5)*quads[i].uv_wh;\n            col = GetColor(quads[i].col);\n            n = quads[i].n;\n            rt = rti;\n        }\n    }\n    \n    return rt;\n}\n\n//vec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), 2.0+dot(p,vec2(11.0,47.0)), 3.0+dot(p,vec2(41.0,29.0)), 4.0+dot(p,vec2(23.0,31.0))))*103.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LM_RES = .75*iResolution.y;\n    \n    fragColor.w = 0.;\n    \n    vec2 uv = fragCoord/LM_RES;\n    \n    if( uv.x >= 1. || uv.y >= 1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    InitScene();\n    \n    vec3 n;\n    vec3 pos = uvToWorld( uv, n );\n    if( dot(pos,pos) < 0.0001 ) // zero position means this lightmap texel is not being used\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    seed = 1.19364353*(fragCoord.x + LM_RES*fragCoord.y) + float(iFrame)/60.*12.37929;\n    haltonIndex = 1.;\n    \n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    seed2 = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\n\n    vec3 addLight = vec3(0.);\n    \n    // cast a ray in a random direction to collect radiance\n    for( int i = 0; i < INDIRECT_RAYS; i++ )\n    {\n        // from https://www.shadertoy.com/view/4tcXD2\n        // doesn't need pdf term - cancels out: http://www.rorydriscoll.com/2009/01/07/better-sampling/\n        vec3 dir = cosWeightedRandomHemisphereDirection( n );\n\n        vec2 hituv; vec3 col; vec3 n;\n        float dist = castRay( pos, dir, hituv, col, n );\n        if( dist < DIST_MAX && dot( n, dir ) < 0. )\n        {\n\t\t    vec2 LM_UV_SCALE = LM_RES/iResolution.xy;\n            addLight += col * textureLod( iChannel0, hituv*LM_UV_SCALE, 0. ).xyz;\n        }\n    }\n    addLight /= float(INDIRECT_RAYS);\n    \n    // sample random point on sphere light\n    vec3 lc = vec3(-2.,-3.,-1.5);\n    vec2 m = iMouse.xy;\n    //m = iResolution.xy/2. + vec2(100.*sin(4.*iTime),0.);\n    if( iMouse.z > 0. && (m.x > LM_RES/2. || m.y > LM_RES/2.) )\n        lc = vec3(22.*(m.x/iResolution.x-.5),-6.+12.*m.y/iResolution.y,-3.+6.*m.x/iResolution.x);\n    \n    vec3 directLight = vec3(0.);\n    for( int i = 0; i < DIRECT_RAYS; i++ )\n    {\n        vec3 lp = LIGHTR*normalize(vec3(rnd(),rnd(),rnd())-.5) + lc;\n        vec3 lv = (lp-pos);\n        float ldp = dot(lv,n);\n        if( ldp < 0. )\n            continue;\n\n        vec2 luv; vec3 col, ln;\n        float first_coll = castRay( pos, lv, luv, col, ln ); // lv is NOT normalised..\n        if( first_coll > 1. ) // lv is NOT normalised..\n        {\n            vec3 nlv = normalize(lv);\n            float cos_a_max = sqrt(1. - clamp(LIGHTR * LIGHTR / dot(lc-pos, lc-pos), 0., 1.));\n            float weight = 2. * (1. - cos_a_max);\n\n            directLight +=  LIGHTCOLOR * (weight * clamp(dot( nlv, n ), 0., 1.));\n        }\n    }\n    addLight += directLight / float(DIRECT_RAYS);\n    \n    float btnTime = textureLod(iChannel1,.5/iResolution.xy, 0.).w;\n    float convergeFactor = START_CONV / (CONV_SPEED*btnTime+1.);\n    \n    fragColor.xyz = mix( textureLod( iChannel0, fragCoord/iResolution.xy, 0. ).xyz, addLight, convergeFactor );\n}\n\n// from reindeer: https://www.shadertoy.com/view/4tl3z4\nvec2 hash2() {\n    return fract(sin(vec2(seed2+=0.1,seed2+=0.1))*vec2(43758.5453123,22578.1459123));\n}\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {\n  \tvec2 r = hash2();\n    //vec2 r = Halton();\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\n/*\n// from http://www.rorydriscoll.com/2009/01/07/better-sampling/ \nvec3 cosineSampleHemisphere(float u1, float u2)\n{\n    const float r = Sqrt(u1);\n    const float theta = 2 * kPi * u2;\n \n    const float x = r * Cos(theta);\n    const float y = r * Sin(theta);\n \n    return Vector3(x, y, Sqrt(Max(0.0f, 1 - u1)));\n}\n*/\n\nvec3 uniformHemisphere(float u1, float u2)\n{\n\tfloat r=sqrt(1.-u1*u1);\n\tfloat phi=2.*PI*u2;\n\treturn vec3(r*cos(phi),u1, r*sin(phi));\n}\n\nvec3 l2w( vec3 l,vec3 normal )\n{\n\tvec3 binormal,tangent;\n\tif( abs(normal.x) > abs(normal.z) )\n\t{\n\t\tbinormal.x = -normal.y; binormal.y = normal.x; binormal.z = 0.;\n\t}\n\telse\n\t{\n\t\tbinormal.x = 0.; binormal.y = -normal.z; binormal.z = normal.y;\n\t}\n\tbinormal = normalize(binormal);\n\ttangent = cross( binormal, normal );\n\treturn l.x*tangent + l.y*normal + l.z*binormal;\n}\n\n/*\nvec2 Halton( float index, float base );\nvec2 Halton()\n{\n    vec2 result = vec2( Halton(haltonIndex,2.), Halton(haltonIndex,3.) );\n    haltonIndex++;\n    return result;\n}\nfloat Halton( float index, float base )\n{\n    float result = 0.;\n    float f = 1.;\n    float i = index;\n    \n    for( int c = 0; c < 32; c++ )\n    {\n        f /= base;\n        i = floor( i / base );\n        result += f * mod(i, base);\n        if( i == 0. ) break;\n    }\n    \n    return result;\n}\n*/\n","name":"Buf B","description":"","type":"buffer"}]}