{"ver":"0.1","info":{"id":"DslGR2","date":"1666489573","viewed":275,"name":"80s anime tech lights","username":"y2k_cyborg","description":"Supposed to emulate the look of glowy blinking lights in old anime","likes":8,"published":3,"flags":32,"usePreview":0,"tags":["retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From https://www.shadertoy.com/view/lsBfRc\n#define colorRange 0.4\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // avoid a teensy little bug in the bloom I can't diagnose\n    uv *= .9;\n    uv += .1;\n    \n    // Q: how to scale the bloom extent vs amount?\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 cols[6] = vec3[]( vec3(1,0,0), vec3(1,1,0), vec3(0,1,0), vec3(0,1,1), vec3(0,0,1), vec3(1,0,1) );\nfloat col_prob[6] = float[]( 2./12., 6./12., 7./12., 9./12., 11./12., 1. );\n\nvec3 colAt(vec3 p) {\n    // colour\n    // scale to avoid obvious correlation\n    // with other quantities\n    float hv = hash13(p * 2.7512649);\n    int ci = 5;\n    \n    for (int i = 0; i < 6; ++i) {\n        if (hv < col_prob[i]) {\n            ci = i;\n            break;\n        }\n    }\n    \n    return (cols[ci] * .6 + vec3(.3));\n}\n\n\nfloat inRectAt(vec3 f, vec3 p) {\n    // Does it exist?\n    const float pa = .1;\n    \n    // Scale to prevent obvious correlation    \n    float a = hash13(p * 1.157894);\n    if (a > pa) { return 0.; }\n    \n    // Random values we'll use for w,h,x,y\n    vec4 e = hash43(p);\n    \n    // Split the extent into width, height, and centroid x,y; apply appropriate scalings to each; then construct t,b,l,r\n    // extents can spill 1 grid cell over, but not 2\n    // grid cell center is at 0,0\n    // min size: 0.3 or higher?\n    // max size: somewhere between 1.5 and 3.0\n    // pos: +/- (3 - size) / 2\n    vec2 wh = .3 + 1.7 * e.xy;\n    vec2 xy = (vec2(3.) - wh) * (e.zw - .5);\n    \n    vec2 u = vec2(-1., 1.);\n    vec4 lrbt = xy.xxyy + .5 * u.xyxy * wh.xxyy;\n    vec4 extent = lrbt;\n    \n    // In time - grid is 1 second, similar logic\n    vec2 eT = hash23(p * 3.353546);\n    float d = 1.0 + 2.0 * eT.x;\n    float t = (3. - d) * (eT.y - .5);\n    //t = round(t * 5.) / 5.;\n    vec2 ba = vec2(t) + .5 * u.xy * vec2(d);\n    vec2 extentT = ba;\n\n    \n    if (f.x < extent.x) { return 0.; }\n    if (f.x >  extent.y) { return 0.; }\n    if (f.y < extent.z) { return  0.; }\n    if (f.y >  extent.w) { return 0.; }\n    if (f.z < extentT.x) { return 0.; }\n    if (f.z >  extentT.y) { return 0.; }\n    \n    // brightness goes up and down\n    // return 1.;\n    return smoothstep(0.,1.,clamp(10. * abs(f.z - t) / d, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uvw = vec3(fragCoord/iResolution.x, iTime*0.3);\n    \n    // Grid scale\n    uvw.xy *= 20.;\n    uvw.z *= 1.;\n    vec3 uvwi = round(uvw);\n    vec3 uvwf = uvw - uvwi;\n    \n    vec3 col = vec3(0.,0.,0.);\n    \n    for (int xi = -1; xi <= 1; ++xi) {\n        for (int yi = -1; yi <= 1; ++yi) {\n            for (int zi = -1; zi <= 1; ++zi) {\n                vec3 d = vec3(xi,yi,-zi);\n                vec3 i = uvwi + d;\n                vec3 f = uvwf - d;\n                \n                // arbitrary winner if already set\n                float b = inRectAt(f,i);\n                if (b>0.) {\n                    col = colAt(i) * b;\n                    //col += colAt(i);\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash functions from https://www.shadertoy.com/view/4djSRW\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// From https://www.shadertoy.com/view/lsBfRc\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}