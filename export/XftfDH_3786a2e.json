{"ver":"0.1","info":{"id":"XftfDH","date":"1733038085","viewed":90,"name":"fractalic rubik","username":"nayk","description":" source https://www.shadertoy.com/view/XXsBz8  and fractal 62","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["color","rubik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat velocity = 0.4, seed = 100., strength = 0.1;\nfloat dcount = 199.;\n\nvec2 travelPath(float t, float i) {\n    float ni = i + seed;\n\n    float rand1 = texture(iChannel0, vec2(ni, 0.3)).x;\n    float rand2 = texture(iChannel0, vec2(ni, 0.6)).x;\n\n    vec2 newPos = vec2(\n        fract((2. * rand1 - 1.) * t),\n        fract((2. * rand2 - 1.) * t)\n    );\n   \n    // padding for apparent teleportation\n    newPos = (newPos - 0.5) * 2.1;\n   \n    return newPos;\n}\n\n#define TAU 6.283185\n#define PI 3.141592\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat boxSd(vec3 p, vec3 s) {\n    p = abs(p) - s;\nreturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat atan2(in float y, in float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nstruct Hit {\n    float dist;\n    vec3 normal;\n};\n\nfloat sphereSd(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Hash functions from https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p) {\nvec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat smin(float a, float b, float k) {\n    float m = 1. / (1. + pow(k, a - b));\n    return a * m + b * (1. - m);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat gyroidSd(vec3 p) {\n    return dot(sin(p), cos(p.yzx));\n}\n\nstruct CubeRot {\n    bool mid;\n    mat3 trans;\n};\n\nfloat anim(float x) {\n    return (1. - cos(pow(x, 5.) * 5.)) * (1. - x) + x;\n}\n\nbool isCenterCube;\n\nfloat cubeSd(vec3 p) {\n    p.xz *= rot(iTime * .6);\n    p.xy *= rot(iTime * 1.1);\n   \n    float ssD = abs(boxSd(p, vec3(2.))) - .1;\n\n    float t = iTime * 3.,\n        rotId = floor(t), rotTime = pow(fract(t), 2.);\n\n    int swi = int(floor(hash11(rotId) * 5.999)),\n        swt = swi % 3, swd = swi / 3;\n\n    if (swt == 0) p.xy = p.yx;\n    else if (swt == 1) p.xz = p.zx;\n    else p.yz = p.zy;\n       \n    if (swd == 1) p.x *= -1.;\n   \n    bool mid = floor(hash11(rotId) * 1.4) == 1.;\n\n    if (!mid && p.x < -.5 || mid && abs(p.x) < .5) {\n        p.yz *= rot(rotTime * PI / 2.);\n    }\n\n    p += vec3(1.5);\n\n    vec3 oid = floor(p),\n        id = clamp(oid, vec3(0.), vec3(2.)),\n        uv = fract(p) - vec3(.5) + oid - id;\n\n    isCenterCube = id == vec3(1);\n\n\n    float d = sphereSd(uv, 2.) - .05;\n\n    return d;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 uv2 = (C * 2.0 - iResolution.xy) / iResolution.y;\n       uv2*=4.;\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));\n     vec2 k;\n      for (float i=0.;i<dcount;i++) {\n        float f = i / dcount,\n              t = iTime * velocity + seed;\n   \n        k = travelPath(t, p.x*cos(iTime));}\n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1.1,.5,5.),H(g*.1),.8)*10./e/8e3\n    )\n    {\n     \n    float cube =cubeSd(vec3(uv2,1.));\n    vec2 c12 = travelPath(10.,5.);\n   \n        p=g*d;\n       p.xz *= rot(-iTime * .6);\n    p.xy *= rot(-iTime * 1.1);\n        a=35.;\n       \n        p=mod(p-a,a*2.)-a;\n        s=2.;\n     \n        for(int i=0;i++<10;){\n       \n            p=.13-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n                 \n            s*=e=1.7+sin(iTime*.005)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 )-cube*20.1 ;\n         }\n         g+=e=length(p.yzzz)/s;\n    }\n      uv2 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n    O*= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.15)*10., 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}