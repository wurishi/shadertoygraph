{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define PI 3.1415926535897932384626433832795\n#define TAU (2.0*PI)\n\n\n\nfloat getTimeAngle(float time, float period) {\n    time = time/period;\n    \n    float timeAngle = (time-floor(time)-0.5)*TAU;\n    \n    return timeAngle;\n}\n\n\nfloat angleFunc(float angle, float timeAngle, float nSpikes, float angularFreq) {\n\n    \n    angle = angle*nSpikes;\n    \n    float angleOffset = cos(timeAngle)*PI;\n    \n    float angleResult = angularFreq*(timeAngle+angle)+angleOffset;\n\n    \n    if (abs(angleResult) > PI*angularFreq) \n    {\n        float sign = angleResult/abs(angleResult);\n        angleResult = angleResult-TAU*sign*angularFreq;\n    }\n    \n    \n    return angleResult;\n    \n\n}\n\nfloat radiusFunc(float angle, float circleScale) {\n\n    float angleLims = abs(angle) < PI ? 1.0 : 0.0;\n \n    \n    float radiusResult = 0.5*((cos(angle)+1.0))*angleLims*circleScale;\n    \n    return radiusResult;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 mouseUV = (2.0*iMouse.xy/iResolution.xy)-1.0;\n    float mouseDown = iMouse.z;\n\n    float speed = 0.6; //0.0 to 1.0\n    float period = 5.0;\n    float nSpikes = 2.0;\n    \n    float angularFreq = 4.0;\n    float circleScale=0.2;\n    float circleAmplitude = 1.1;\n    float radFuncAmplitude = 2.0;\n    \n    float timeSeriesScale = 0.5;\n    float timeSeriesThickness = 0.015;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.y = ((uv.y * 2.0)-1.0);\n    uv.x = (uv.x * 2.0) - 1.0;\n    \n    float yAbs = uv.y;\n    \n    uv.y = uv.y/aspect;\n\n    // Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n\n    float timeAngle = getTimeAngle(iTime, period);\n\n    \n    //background colour\n    fragColor = vec4(1.0-col, 0.01)*0.2;\n\n    float yPos = 0.0;\n    \n    //Where the tail of the snake is pointing. Trig functions to 'randomly' oscillate in x and y\n    vec2 origin = vec2((sin(iTime*0.8)+sin(iTime*0.55+PI/2.0))/2.0, 0.6*(1.0+(cos(iTime*0.9)+sin(iTime*0.45+PI/2.0))/4.0));\n    origin.x = mouseDown > 0.0 ? origin.x+mouseUV.x : origin.x;\n    origin.y = mouseDown > 0.0 ? origin.y+0.3*mouseUV.y : origin.y;\n    \n    while (yPos <= 1.0) {\n    \n        \n        //A point between the origin and the current pixel\n        vec2 newUV = uv - yPos*origin*2.0;\n    \n        //Color waves moving backwards over time\n        vec3 newCol = 0.5 + 0.5*cos(TAU*yPos +iTime*-5.0+newUV.xyx+vec3(0,2,4));\n        \n        //Add some wiggle to the snake\n        newUV.y += -0.1* (sin(-iTime*0.2*PI*3.0+yPos*TAU)+sin(PI*1.3 +-iTime*0.11*PI*3.0+yPos*PI));\n        newUV.x += -0.02* (cos(-iTime*0.14*PI*3.0+(1.0-yPos)*TAU)+cos(PI*1.3 +-iTime*0.19*PI*2.0+yPos*PI));\n        \n        //The angle from the centre of the current point\n        float angle1 = atan(newUV.y, newUV.x)+((0.5*cos(iTime*TAU*0.2))+1.0)*PI+((-0.5*yPos+(iTime*0.22-floor(iTime*0.22)))*-TAU);\n        angle1 = angle1 > PI ? angle1 - TAU : angle1;\n        angle1 = angle1 < -PI ? angle1 + TAU : angle1;\n        \n        float angleUnit = abs((angle1)/PI);\n        \n        \n        //Get frequency and time series data from buffer\n        float fft = texture( iChannel0, vec2(angleUnit, yPos)).x;\n        float fftLinear =  texture( iChannel0, vec2((0.5*newUV.x+1.0)/2.0,yPos*(1.0-speed))).y;\n        \n        //Get result of function transforming angle\n        float angleResult = angleFunc(angle1,timeAngle, nSpikes, angularFreq);\n        \n        //Multiplier to reduce size/opacity towards back of the snake\n        float sizeMult = 3.0+yPos*15.0;\n        \n        //Calculate the radius at the angle calculated (function of frequency data and a rotating sine function)\n        float radiusResult = radiusFunc(angleResult, circleScale*(sizeMult/30.0));\n        \n        //Only apply this to relevant pixels \n        float mask1 = sizeMult*length(newUV)-(radiusResult*radFuncAmplitude)-fft*circleAmplitude < 0.4 ? 1.0 : 0.0;\n        \n        //Mask for time series data (The lines)\n        float linMask = abs(0.5+newUV.y-0.2*newUV.x*cos(angle1) - fftLinear*timeSeriesScale) < timeSeriesThickness ? 1.0 : 0.0;\n        \n        //colour for the lines, getting more purple further back\n        vec4 red = vec4(1.0-sizeMult/23.0,0.0,sizeMult/23.0,1.0-sizeMult/17.0);\n        \n        //Add them all together\n        fragColor += mask1*vec4(newCol, 0.9)*0.2*(1.0-yPos)+linMask*red*0.17;\n        \n        //Smaller increment gives smoother visuals but kills performance\n        yPos += 0.02;\n    \n    }\n    \n\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float lineHeight = 1.0/iResolution.y;\n    \n    \n    \n    float splashPeriod = 0.3;\n    int nSplash = 5;\n    \n    float loopPeriod = float(nSplash)*splashPeriod;\n    \n    float timeSlow = iTime/loopPeriod;\n    float time = timeSlow-floor(timeSlow);\n    \n    float splashNow = floor(time*float(nSplash));\n\n    vec4 prevColor = texture( iChannel1, vec2(uv.x, uv.y-0.005));\n    \n    \n    \n    float fft  = texture( iChannel0, vec2(uv.x,0.0) ).x;\n    float timeData = texture( iChannel0, vec2(uv.x,1.0) ).x;\n    \n    \n    vec4 liveColor = vec4(fft, timeData, 0.0, 0.0);\n    float mask = uv.y < 0.01 ? 1.0 : 0.0;\n    fragColor = liveColor*mask+ prevColor*(1.0-mask);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4fyfDV","date":"1734519875","viewed":38,"name":"SnekViz","username":"thejohobro","description":"Some visualisations of audio. Might not play automatically so pause and resume the shader if there is no audio.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"","parentname":""}}