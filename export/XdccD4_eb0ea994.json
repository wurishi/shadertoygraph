{"ver":"0.1","info":{"id":"XdccD4","date":"1518796256","viewed":180,"name":"Symbol Of Chaos","username":"lsdlive","description":"Still training my geometry.\nI tried a better lighting setup for this one. I found this shader from vgs ( https://www.shadertoy.com/view/4slSD8) best fits what I need, it's simple & very efficient, so I reimplemented this setup in my shader.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159\n#define TWO_PI 2.*PI\n\n// geometry functions from iq / mercury\nvoid amod(inout vec2 p, float c) {\n\tfloat m = TWO_PI / c;\n\tfloat a = mod(atan(p.x, p.y) - m*.5, m) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat length8(vec2 p) {\n\tp = pow(p, vec2(8.));\n\treturn pow(p.x + p.y, 1. / 8.);\n}\n\nfloat torus82(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n\t// c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c, vec2(q, p.z));\n}\n\n// iq via leon/koltes\nfloat smoo(float a, float b, float r) {\n\treturn clamp(.5 + .5*(b - a) / r, 0., 1.);\n}\n\nfloat smin(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(b, a, h) - r*h*(1. - h);\n}\n\nfloat smax(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(a, b, h) + r*h*(1. - h);\n}\n\nfloat de(vec3 p) {\n\tp.xz *= r2d(iTime);\n\tp.zy *= r2d(iTime);\n\n\tfloat d = torus82(p.yzx, vec2(1., .1));\n\n\tamod(p.xy, 8.);\n\td = smin(d, box(p, vec3(1.3, .1, .1)), .1);\n\n\tp.x -= 1.7;\n\tp.xy *= r2d(-PI*.5);\n\n\td = smin(d, max(cone(p.zxy, normalize(vec2(.4, .2))), -p.y - .4), .1);\n\treturn d;\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*de(pos + e.xyy) +\n\t\te.yyx*de(pos + e.yyx) +\n\t\te.yxy*de(pos + e.yxy) +\n\t\te.xxx*de(pos + e.xxx));\n}\n\n// 3 point lights setup, strongly inspired from: iq/vgs\n// https://www.shadertoy.com/view/4slSD8\nvec3 shade(vec3 p, vec3 rd) {\n\tvec3 n = normal(p);\n    \n    // I consider all my lights to be white vec3(1.) to simplify equations\n\tvec3 diff_mat = vec3(.7, .1, .1);\n\tvec3 spe_mat = vec3(.5);\n\tfloat roughness = 8.;// metal range\n\n    // top right light: vec3(1.)\n\tvec3 l = normalize(vec3(1.));\n\tvec3 h = normalize(l - rd);\n\tfloat dotNL = max(0., dot(n, l)); // lambert\n\tfloat dotNH = pow(max(dot(n, h), 0.), roughness);// blinn-phong\n\tvec3 col = diff_mat * dotNL + spe_mat * dotNH;\n\n    // front light (-rd)\n\tdotNL = max(0., dot(n, -rd)); // lambert\n    // notice with -rd, dotNL = dot(n, h)\n\tdotNH = pow(dotNL, roughness);// blinn-phong\n\tcol += diff_mat * dotNL + spe_mat * dotNH;\n\n\t// back light, rim or fresnel in other shaders\n\tcol += 2.5 * pow(clamp(1. + dot(n, rd), 0., 1.), 3.);\n\n\t//col *= .33;\n\t// reinhard tone mapping\n\t// gives softer colors\n\tcol /= (col + 1.);\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n\n\tvec3 ro = vec3(0, 0, 3.5);\n\tvec3 rd = normalize(vec3(uv, -1));\n\tvec3 p;\n\n\tfloat t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (d<.001 || t>100.) break;\n\t\tt += d;\n\t}\n\n\tvec3 col = vec3(.9, .9, .8);\n\tif (t <= 100.) {\n\t\tcol = shade(p, rd);\n        //col = smoothstep(0., 1., col);// increase brightness, but I prefer without\n\t}\n\n\t// iq's vignetting\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}