{"ver":"0.1","info":{"id":"7ld3RB","date":"1636330470","viewed":110,"name":"Galactic Collapse","username":"dominionxvii","description":"Spiral Galaxy go schwoop!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","space","galaxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool IsInFrame(vec2 uv)\n{\n   return (uv.x > 0. && uv.y > 0. && uv.x < 1. && uv.y < 1.);\n}\n\nvec4 LightStreak(vec2 uv, vec2 dir, vec2 dirTan)\n{\n   vec4 sum = vec4(0.0);\n\n   float streakLen = 0.125;\n   int count = 50; //boost for bootiful\n   float steps = streakLen / float(count);\n   \n   float disto = 0.05;\n   float distoSpeed = 0.1;\n   float intensity = 1.25;\n\n   for(int i = 0; i < count; i++)\n   {\n       float xnoise1 = fbm_4r(vec3(uv * 2.0, iTime * distoSpeed), m3);\n       float xnoise2 = snoise(vec3(uv * 1.0, iTime * distoSpeed * 0.5));\n       float xnoise = mix(xnoise1, xnoise2, 0.5);\n       \n       vec2 uv2 = uv + dir * float(i) * steps + dirTan * disto * xnoise;\n       float iratio = 1. - (float(i) / float(count - 1));\n       \n       bool verticalStreakInRange = dir.y == -1. && dir.x == 0.0 && uv2.y >= 0.;\n       bool radialStreakInRange = IsInFrame(uv2);\n       \n       if(verticalStreakInRange || radialStreakInRange)\n       {\n           vec4 col = texture(iChannel0, uv2);\n           sum += saturate(vec4(col.rgb * col.a, col.a)) * iratio;\n       }\n     }\n \n   float filterNoise = norm(fbm_4r(vec3(uv * 5., iTime * 0.3), m3));\n   return (sum / float(count)) * filterNoise * intensity;\n}\n\nvec4 ShockWave(vec2 uv, vec2 fragCoord, float inward, float ratio)\n{\n    vec2 uvdir = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = ratio;\n    \n    vec2 dir = inward * (uvdir);\n \n    \n    float dist = distance(uvdir, vec2(0));\n\n    float distRatio = 1. - saturate(dist * 1.0);\n    distRatio = easeInCubic(distRatio);\n    \n    float len = 0.1;\n    uv = uv + dir * t * len;\n   \n    float fade = 1.0 - t;\n    return texture(iChannel0, uv) * fade * distRatio;\n}\n\n\n\nvec4 FinalPopEffect2(vec2 uv, vec2 fragCoord, vec4 col, float t)\n{\n    float intensity = DASRCurve(t, 0.1, 0.12, 0.2, 2.3);\n\n    float maxdur = 2.7;\n    float splitTime = 1.7;\n    float pop = DASRCurve(t, splitTime + .3, 2.3, 2.67, maxdur);\n    //pop = easeInOutCubic(pop) * 0.31;\n    //pop = easeOutCubic(pop);\n\n    //pop *= 0.25;\n    vec2 uvDir2 = normalize((fragCoord-0.5*iResolution.xy)/iResolution.y);\n\n    //uvDir.y /= iResolution.x;\n    float minfade = ((texture(iChannel0, uv).a == -1.) ? 0. : 1.0); \n    float popfade = mix(minfade, 1.0, saturate(t - 0.5));\n\n    float popfinalIntenisty = DASRCurve(t, splitTime, splitTime + 0.05, splitTime + 0.1, 9999.);\n\n    //vec2 uvsamp = uv - uvDir2 * pop;\n    \n    vec2 normUv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 uvDir3 = normalize(normUv);\n    //uvDir3.x *= (iResolution.y / iResolution.x);\n    //uvDir3.y /= (iResolution.x / iResolution.y);\n\n    //uv2.x *= (iResolution.y / iResolution.x);\n    //uv2.y *= (iResolution.x / iResolution.y);\n\n    vec2 uvsamp = uv - normalize(uvDir3) * (pop * 0.1);   \n\n    float distIntensity = distance(uvsamp, vec2(0.5));\n    distIntensity = Remap(0.1, 0.3, 1., 0., distIntensity);\n    distIntensity = easeInOutCubic(distIntensity);\n    \n    //distIntensity = pow(distIntensity, 0.2);\n    vec4 mirror1 = texture(iChannel0, uvsamp);\n    //vec4 mirror2 = texture(iChannel0, uv - uvDir2 * pop * 2.0);\n    \n    float tt =  saturate(popfinalIntenisty) * 0.5;\n    //float tt =  saturate(popfinalIntenisty * distIntensity);\n\n    col = mix(col, mirror1, tt);\n    //col += mirror2  * popfinalIntenisty;\n\n   \n\n    fragCoord = Rotate2D(fragCoord, radians(45.));\n\n    if(t >= maxdur)\n    {\n       col = vec4(0.0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n   vec2 uv = fragCoord/iResolution.xy;\n\n   vec2 center = vec2(0.5, 0.5);\n   vec4 text = texture(iChannel0, uv);\n   bool isBlackHole = text.a == -1.;\n   vec4 col = text;\n   \n   vec2 uvDir = -normalize(uv - 0.5);\n\n   if(!isBlackHole)\n   {   \n       col += LightStreak(uv, vec2(0.0, -1.0), vec2(1.0, 0.0));\n       col = saturate(col);\n\n       col += LightStreak(uv, uvDir, Rotate2D(uvDir, PI / 2.0));\n       col = saturate(col);\n\n       if(!IsOverPulseCount(iTime))\n       { \n           float shockWaveRatio = (BlackHoleRatio(iTime));\n           col += ShockWave(uv, fragCoord, 1.0, shockWaveRatio) * 2.75;\n           col = saturate(col);\n\n           col += ShockWave(uv, fragCoord, -1.0, shockWaveRatio) * 0.75;\n           col = saturate(col);\n       }\n   }\n   \n   if(IsOverPulseCount(iTime))\n   {\n        //White blast\n        float t = TimeSinceLastPulseCount(iTime);\n        float intensity = DASRCurve(t, 0.0, 0.02, 0.1, 1.3);\n\n        if(!isBlackHole)\n        { \n           col += ShockWave(uv, fragCoord, 2.0, t) * intensity;\n           col = saturate(col);\n        }\n\n        col += text * easeOutCubic(intensity);\n        col += easeOutQuad(intensity);\n\n        col = saturate(col);\n\n        float maxDur = 2.7;\n        if(t >= maxDur)\n        {  \n           col = vec4(0.0);\n        }\n   }\n   \n   col = saturate(col);   \n   fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n#define TAU 6.2831\n\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n//[-1, 1] -> [0, 1]\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat Luminance(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722; \n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec2 saturate(vec2 x)\n{\n    return vec2(saturate(x.x), saturate(x.y));\n}\n\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\n\nvec4 GetCol(int r, int g, int b)\n{\n    return vec4(r, g, b, 1.) / 255.;\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\nvec3 unlerp(vec3 x, vec3 fromMin, vec3 fromMax)\n{\n    return vec3(\n        unlerp(x.x, fromMin.x, fromMax.x),\n        unlerp(x.y, fromMin.y, fromMax.y),\n        unlerp(x.z, fromMin.z, fromMax.z));       \n}\n\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\nvec3 project(vec3 a, vec3 b)\n{\n    return (dot(a, b)/dot(b,b))*b;\n}\n\nvec3 reject(vec3 a, vec3 b)\n{\n    return a - project(a, b);\n}\nvec3 RotateAroundAxis(vec3 p, vec3 axis, float a)\n{\n    vec3 parallel = project(p, axis);\n    vec3 orthogonal = reject(p, axis);\n    vec3 vcross = cross(p, axis);\n    return parallel + orthogonal * cos(a) + vcross * sin(a);\n}\n\nfloat cheapNoise(vec2 v)\n{\n    return \n        0.333 * sin(v.x * 3.151) +\n        0.333 * sin(v.y * 8.357) + \n        0.333 * cos((v.x + v.y) * 3.723);\n\n}\n\n\nvec3 cheapNoise(vec3 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.y, v.z + t + 252.)),\n        cheapNoise(vec2(v.z, v.x + t + 623.))\n        );\n}\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec2 Rotate2D(vec2 p, float a)\n{\n    return RotateZ(vec3(p, 0.0), a).xy;\n}\n\nfloat SignedAngle(vec2 uv)\n{\n    float x = acos(dot(normalize(uv), vec2(0., 1.0)));   \n    return x * sign(uv.x); //add signed angles\n}\n\nfloat SignedAngleNorm(vec2 uv)\n{\n    float x = SignedAngle(uv);\n    return (x + PI * 0.5) / PI; //normalizing\n}\n\n//quats\n\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\n\nvec4 qLookAt(vec3 forward, vec3 up)\n{\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward, right));\n\n    float m00 = right.x;\n    float m01 = right.y;\n    float m02 = right.z;\n    float m10 = up.x;\n    float m11 = up.y;\n    float m12 = up.z;\n    float m20 = forward.x;\n    float m21 = forward.y;\n    float m22 = forward.z;\n\n    float num8 = (m00 + m11) + m22;\n    vec4 q = vec4(0., 0., 0., 1.);\n    if (num8 > 0.0)\n    {\n        float num = sqrt(num8 + 1.0);\n        q.w = num * 0.5;\n        num = 0.5 / num;\n        q.x = (m12 - m21) * num;\n        q.y = (m20 - m02) * num;\n        q.z = (m01 - m10) * num;\n        return q;\n    }\n\n    if ((m00 >= m11) && (m00 >= m22))\n    {\n        float num7 = sqrt(((1.0 + m00) - m11) - m22);\n        float num4 = 0.5 / num7;\n        q.x = 0.5 * num7;\n        q.y = (m01 + m10) * num4;\n        q.z = (m02 + m20) * num4;\n        q.w = (m12 - m21) * num4;\n        return q;\n    }\n\n    if (m11 > m22)\n    {\n        float num6 = sqrt(((1.0 + m11) - m00) - m22);\n        float num3 = 0.5 / num6;\n        q.x = (m10 + m01) * num3;\n        q.y = 0.5 * num6;\n        q.z = (m21 + m12) * num3;\n        q.w = (m20 - m02) * num3;\n        return q;\n    }\n\n    float num5 = sqrt(((1.0 + m22) - m00) - m11);\n    float num2 = 0.5 / num5;\n    q.x = (m20 + m02) * num2;\n    q.y = (m21 + m12) * num2;\n    q.z = 0.5 * num5;\n    q.w = (m01 - m10) * num2;\n    return q;\n}\n\n//FBMs\n\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n        \nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n    }\n\nfloat pnoise(vec2 P, vec2 rep)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\n const mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                  -0.80,  0.36, -0.48,\n                  -0.60, -0.48,  0.64 );\nconst mat2 m2  = mat2( 0.00,  0.80,\n                  -0.80,  0.36);\n                  \n       \n     \nfloat fbm_4r( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n    }\n\treturn a;\n}\n\nfloat fbm_4r( in vec3 x, mat3 rot)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4pr( in vec2 x, mat2 rot, vec2 rep)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = pnoise(x, rep);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\nfloat fmb4_3x( in vec3 x)\n{\n    return fbm_4(x + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat fmb4r_3x( in vec3 x, mat3 rot)\n{\n    return fbm_4r(x + vec3(fbm_4r(x + vec3(fbm_4r(x, rot), rot), rot)));\n}\n\nfloat fmb4_3x( in vec3 x, vec3 offset)\n{\n    return fbm_4(x + offset + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\n\nfloat cellfbmr( in vec2 x, mat2 rot, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\n\n\nconst float MAXPULSECOUNT = 5.;\nconst float TIMESPEED = 0.5;\nconst float MAXTIME = 20.;\nconst float SIMULATEPULSE = 0.;\n\nfloat AjustedTime(float iTime)\n{\n   return mod(iTime, MAXTIME);\n}\n\nfloat BlackHolePulseCount(float iTime)\n{\n    return SIMULATEPULSE + floor(AjustedTime(iTime) * TIMESPEED + 0.5);\n}\n\nfloat BlackHoleRatioUnEase(float iTime)\n{\n    return fract(AjustedTime(iTime) * TIMESPEED + 0.5);\n}\n\nfloat BlackHoleRatio(float iTime)\n{\n    return easeOutQuad(easeOutQuad(BlackHoleRatioUnEase(AjustedTime(iTime))));\n}\n\nfloat TimeSinceLastPulseCount(float iTime)\n{\n    float adjTime = AjustedTime(iTime);\n    float time = BlackHolePulseCount(adjTime) - MAXPULSECOUNT + BlackHoleRatioUnEase(adjTime);\n    return max(0.0, time);\n}\n\nbool IsOverPulseCount(float iTime)\n{\n    bool overPulseCount = BlackHolePulseCount(AjustedTime(iTime)) >= MAXPULSECOUNT;\n    return overPulseCount;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//uncomment for hd\n//#define HD\n\n\nvec3 camPos;\n\nstruct RayHit\n{\n    float dist;\n    int id;\n};\n\nvec4 GetColorPallet(int id)\n{\n    switch(id)\n    {\n       case 0: return GetCol(68, 65, 250);\n       case 1: return GetCol(150, 255, 173);\n       case 2: return GetCol(150, 255, 173);\n       case 3: return GetCol(68, 65, 250);\n    }\n    return vec4(1.0);\n}\n\nRayHit DistanceFunction(vec3 pos)\n{\n    RayHit hit;\n\n    vec3 posField = pos;  \n    float xzLength = length(pos.xz);\n    //posField.y -= pow(xzLength0.3;\n    \n    if(!IsOverPulseCount(iTime))\n    {\n        float amp = 0.15 * (1. - BlackHoleRatio(iTime));\n        posField.y += amp * sin(xzLength + 15. * BlackHoleRatio(iTime) + iTime * 0.5 + pos.x * 0.4);   \n    }\n\n    //float fieldDist = sdBox(posField, vec3(35., 2., 15.));\n    float fieldDist = sdPlane(posField, vecY(1.0), 0.0);\n    hit.id = 0;\n    hit.dist = fieldDist;\n \n\n    return hit;     \n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    \n    float distX1 = DistanceFunction(p+h.xyy).dist;\n    float distX2 = DistanceFunction(p-h.xyy).dist;\n    \n    float distY1 = DistanceFunction(p+h.yxy).dist;\n    float distY2 = DistanceFunction(p-h.yxy).dist;\n    \n    float distZ1 = DistanceFunction(p+h.yyx).dist;\n    float distZ2 = DistanceFunction(p-h.yyx).dist;\n\n    return normalize( vec3(distX1 - distX2,\n                           distY1 - distY2,\n                           distZ1 - distZ2));\n}\n\nRayHit Raymarch(vec3 ro, vec3 rd)\n{\n    vec3 currentPos = ro;\n    float currentDist = 0.;\n    RayHit hit;\n    hit.dist = 9999.;\n    for(int i = 0; i < 100; i++)\n    { \n        RayHit currentHit = DistanceFunction(currentPos);\n        float dist = currentHit.dist;\n        currentPos += rd * dist;   \n        currentDist += dist;\n        \n        if(dist < 0.0001)\n        {\n            hit.dist = currentDist;\n            hit.id = currentHit.id;\n            break;\n        }\n    }\n    \n    return hit;\n}\n\nvec4 GetCosmicColor(vec2 uv, vec4 col1, vec4 col2, float time)\n{\n   float t = time * 0.1;\n   vec2 rep = vec2(1.0, 2.0);\n   float noise1 = pnoise(vec2(uv.x * 2.0, uv.y + sin(4. * TAU * t) * 0.3), rep);\n   float noise2 = pnoise(vec2(uv.x, uv.y + sin(2. * TAU * t) * 0.1), rep);\n      \n   float noiseMix = mix(noise1, noise2, norm(sin(t)));\n   return mix(col1, col2, noiseMix);\n}\n\nvec4 GetCosmicSignifiance(vec2 uv, float time)\n{\n   vec4 col1 = GetColorPallet(0);\n   vec4 col2 = GetColorPallet(1);\n   vec4 col3 = GetColorPallet(2);\n   vec4 col4 = GetColorPallet(3);\n   vec2 uv2 = vec2(uv.x * 2.0, uv.y * 2.);\n      \n   return mix(GetCosmicColor(uv, col4, col2, time), GetCosmicColor(uv2, col1, col4, time), 0.25);\n}\n\nfloat GetCosmicDarkness(vec2 uv, vec3 pos, float time)\n{      \n    vec2 rep = vec2(2., 2.); \n    \n    float darkness1 = pnoise(vec2(uv.x * 2.0, uv.y * 1.0), rep);\n    float darkness2 = pnoise(vec2(uv.x * 2.0, uv.y), rep);       \n    \n#ifdef HD\n    vec3 pos1 = RotateY(pos * 4.0, -iTime * 0.2);\n    float darkness3 = fmb4r_3x(vec3(uv, 0), -m3);     \n    \n    vec3 pos2 = RotateY(pos, -iTime * 0.15);    \n    float darkness4 = fmb4r_3x(vec3(uv, 0) + vecY(iTime * 0.25), m3);       \n#else\n    float darkness3, darkness4 = 0.;\n#endif \n    \n    \n    float dark = mix(darkness1, darkness2, norm(sin(time)));\n\n    float intensity = saturate(darkness1 + 0.25 * (darkness3 + darkness4));\n    return pow(intensity, 1.2) * 0.8;\n}\n\nvec4 GenerateStarLayer(vec2 uv, vec3 pos)\n{\n    //stupid offset because cellular doesnt loop\n    uv.x += .5;\n    float scale = 35.;\n    uv = vec2(uv.x * scale * 5.5, uv.y * scale);\n    float cell = cellular(uv).x;\n    \n    //float shineSin = ((uv.x + uv.y) * 55.1 + iTime * 25.5);\n    float shine = 1.0;// Remap(shineSin, -0.1, 1.0, 0.5, 1.0);\n    \n    float starSize = 0.05;\n    float fadeDist = starSize * 19.;\n\n    if(cell < starSize)\n    {\n        return vec4(1.) * shine;\n    }\n    else if(cell < fadeDist)\n    {\n        float intensity = 1. - unlerp(cell, starSize, fadeDist);\n        intensity = pow(intensity, 1.) * shine * 0.15;\n        intensity = saturate(intensity);\n        return vec4(intensity, intensity, intensity, 1.0);\n    }\n    else\n    {\n        return vec4(0);\n    }\n}\n\nvec4 GetCosmicStars(vec2 uv, vec3 pos, float time)\n{\n    vec2 starUv1 = uv / 2. + vec2(0, time * 0.01);\n    vec2 starUv2 = uv / 4. + vec2(0, time * 0.03);\n    vec2 starUv3 = uv / 8. + vec2(0, time * 0.05);\n\n    vec4 stars1 = GenerateStarLayer(starUv1, pos);\n    vec4 stars2 = GenerateStarLayer(starUv2, pos);\n    vec4 stars3 = GenerateStarLayer(starUv3, pos);\n\n    //stars1.rgb *= 0.5;\n    //stars2.rgb *= 0.75;\n\n    vec4 stars = stars1 + stars2 + stars3;\n    return stars;\n}\n\n\nvec4 GetColor(vec3 pos, vec3 rd, vec3 normal, int id, float speed)\n{\n    float endOfTime = TimeSinceLastPulseCount(iTime);\n    float endOfTimeFade = endOfTime * 9.;\n    \n    float time = iTime * speed;\n    float fadeMinDist = 15. - endOfTimeFade;\n    float fadeMaxDist = 25. - endOfTimeFade;\n    float fade = 1.0;\n    \n    float dist = length(pos);\n    //Distance fade\n    if(dist > fadeMinDist)\n    { \n        fade = 1.0 - saturate(unlerp(dist, fadeMinDist, fadeMaxDist));      \n    }\n    \n    float x = SignedAngleNorm(pos.xz);\n    \n    \n    float y = length(pos.xz);\n    if(IsOverPulseCount(iTime))\n    {\n        float timeSince = TimeSinceLastPulseCount(iTime);\n        //Absorbing space and time\n        y += iTime * 3.0 + pow(timeSince + 1.0, 2.5);\n    }\n    else\n    {\n        //doing a pulse absorbsion\n        float fractTime = BlackHoleRatio(iTime);\n        float pulseCount = BlackHolePulseCount(iTime);\n        y += (pulseCount + fractTime) * 2.;\n    }\n    \n    float twirl = pow(y, 0.5);\n    x += (-time * 0.2 + twirl);\n    //y += y  + time * 0.2 + x * 1.0; \n    vec2 uv = vec2(x, y  + time * 0.2 + x * 1.0);\n    \n    //keep for visual niceness lol\n    uv = mod(uv, 2.0);\n    //return vec4(uv.x, uv.y, 1.0, 1.0);\n\n    vec4 stars = GetCosmicStars(uv, pos, time);\n    vec4 grad = GetCosmicSignifiance(uv, time);\n    float dark = GetCosmicDarkness(uv, pos, time) +\n                 GetCosmicDarkness(vec2(x * 4.0, y * 1.0), pos, time) * 0.5 -\n                 GetCosmicDarkness(uv * 8.0, pos, time) * 0.25;\n        \n    vec4 galaxy = (stars + grad) * dark;\n    \n    return saturate(galaxy * fade * 1.5);\n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\nvec4 RenderAtUv(vec3 camPos, vec4 camRot, vec2 uv, float speed)\n{\n    vec3 ro, rd;\n    PerspectiveCam(camPos, camRot, uv, ro, rd);\n    \n    RayHit hit = Raymarch(ro, rd);\n    vec3 pos = ro + rd * hit.dist;\n    vec3 normal = calcNormal(pos);   \n    return GetColor(pos, rd, normal, hit.id, speed);\n}\n\n\nvec4 RenderAtUvAntiAliasing(vec3 camPos, vec4 camRot, vec2 uv, vec2 fragCoord, float speed)\n{\n    vec4 colorSum = vec4(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n    colorSum += RenderAtUv(camPos, camRot, uv, speed);\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5), speed);\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5), speed);\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, nextUv, 0.5), speed);\n    colorSum /= 4.0;\n    return colorSum;\n}\n\nvec4 BlackholeDistortion(inout vec2 uv)\n{      \n    vec2 center = vec2(0.0);\n    float angle01 = SignedAngleNorm(uv * 2.0 - 1. + 0.001);\n    float loop = 5.0;\n    float giggle = 0.0075 * pnoise(vec2(angle01 * loop, iTime * 32.25), vec2(loop, 53.0));\n    \n    float fractTime = BlackHoleRatio(iTime);\n    giggle *= fractTime; //grow more and more shaky\n    float pulseCount = BlackHolePulseCount(iTime);\n    \n    if(IsOverPulseCount(iTime))\n    {\n        pulseCount = 0.;\n        //Blackhole collapsing\n        fractTime = 2.0 - TimeSinceLastPulseCount(iTime) * 0.5;\n    }\n    \n    float horizon = 0.000 + giggle * 0.1  + fractTime * 0.2 + pulseCount * 0.05 * fractTime;\n    float radius = 0.005 + giggle + pulseCount * 0.05 * fractTime;\n    float totalradius = (radius + horizon);\n   \n    //Make this will make this a circle\n    float openAnim =  fractTime * 0.02;\n    float dist = distance(uv, center) - openAnim;\n\n    if(dist < totalradius)\n    {\n        if(dist < radius)\n        {\n            float smoothdelta = 0.003;\n            float col = smoothstep(radius - smoothdelta, radius, dist);\n            uv = center;\n            return vec4(col, col, col, 1.0);\n        }\n        \n        float ratio1 = Remap(radius, totalradius, 0.15, 1., dist);\n        float ratio2 = Remap(radius, totalradius, 1., 0., dist);\n\n        float ratio = easeOutQuad(ratio1);\n        ratio2 = easeInQuad(ratio2);\n        uv = Rotate2D(uv, -ratio2 * PI * 2.0 * fractTime);\n        \n        vec2 uvnorm = normalize(uv);\n        \n        float uvStretch = Remap(0., 1.0, -0.6, 1., ratio);\n        vec2 uv2 = center + uvnorm * uvStretch * horizon; \n        \n        uv = mix(uv2, uv, ratio1);\n        \n        float whitehole = 0.0755 - TimeSinceLastPulseCount(iTime) * 0.02;\n        if(dist < radius + whitehole)\n        {\n            float whiteholeIntensity = Remap(radius, radius + whitehole, 0., 1., dist);\n            whiteholeIntensity = pow(whiteholeIntensity, 0.35);\n            return vec4(1. - whiteholeIntensity);\n        }\n        \n    }\n    return vec4(0.0);\n}\n\nvec4 innerBlackHole(vec2 uv)\n{\n    float i = length(uv) * 5.;\n    return vec4(0.0, i / 2.0, i, 0.0) * .0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 olduv = uv;\n    vec4 extraCol = BlackholeDistortion(uv);\n    \n    if(uv.x == 0.0 && uv.y == 0.0)\n    {\n        fragColor = innerBlackHole(olduv);\n        fragColor += vec4(extraCol.rgb, 0.0);\n        fragColor = saturate(fragColor);\n        fragColor.a = -1.;\n        return;\n    }\n   \n    float y = 10. - iTime * 0.5;\n    y = max(y, 3.0);\n    \n    float angle = 0.0; //(iMouse.x / iResolution.x) * TAU;\n    float dist = 10.0 - y / 2.0;\n    vec3 xz = vec3(dist * sin(angle), 0, dist * cos(angle));\n    \n    camPos = xz + vecY(y);\n    \n    if(IsOverPulseCount(iTime))\n    {\n        float t = TimeSinceLastPulseCount(iTime);\n        float intensity = DASRCurve(t, 0.0, 0.02, 0.1, 1.5) * 0.25;\n        camPos += intensity * cheapNoise(vec3(0.0), iTime * 100.);\n        \n        uv += intensity * 0.15 * cheapNoise(vec3(uv.xxy), iTime * 5.).xy;\n        uv += intensity * 0.05 * cheapNoise(vec3(0.), iTime * 5.).xy;\n    }\n    else\n    {\n        float fractTime = 1.0 - BlackHoleRatio(iTime);\n        camPos += 0.45 * pow(fractTime, 1.) * cheapNoise(camPos, iTime * 100.);\n    }\n           \n           \n    vec3 camDir = normalize(-camPos);\n    vec4 camRot = qLookAt(camDir, vecY(-1.0));\n\n    \n#ifdef HD  \n    fragColor = RenderAtUvAntiAliasing(camPos, camRot, uv, fragCoord, 0.15) + extraCol;  \n#else\n    fragColor = RenderAtUv(camPos, camRot, uv, 0.15) + extraCol; \n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}