{"ver":"0.1","info":{"id":"dlcfzr","date":"1700868671","viewed":33,"name":"Triflake Equalizer ","username":"tassel","description":"Triflake equalizer basen on the triflake fractal algoritm","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["fractal","eq","triflake","eqaulizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdc3RX","filepath":"https://soundcloud.com/chiptune/unreal-superhero-3?si=74ac688e06084d0491b610e30376da40","previewfilepath":"https://soundcloud.com/chiptune/unreal-superhero-3?si=74ac688e06084d0491b610e30376da40","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n----------------------------------------------------------------------------\nTriflake Equalizer - Need to .....\nI really had a blast here. I messed up. I'm tired. need to sleepÂ¨now. ;)\n\nMusic: Unreal Superhero 3 by REZ / https://soundcloud.com/chiptune\n----------------------------------------------------------------------------\n*/\n\n// Constants\n#define PI 3.14159265359\n\n// Function to create a triflake pattern\nfloat triflake(vec2 p, float size, int iterations) {\n    float angle = PI / 3.0;\n    vec2 offset = vec2(0.5, 0.5);\n    \n    for (int i = 0; i < iterations; i++) {\n        p -= offset;\n        p = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * p;\n        p += offset;\n    }\n    \n    return smoothstep(size, size + 0.1, length(p - offset));\n}\n\n// Function to create a rainbow gradient\nvec3 RainbowGradient(float t, float hue) {\n    vec3 rainbowColor = vec3(\n        1.0 + 0.5 * sin(t * 6.0 + hue),\n        0.5 + 1.0 * sin(t * 6.0 + 2.0 + hue),\n        0.5 + 0.5 * sin(t * 6.0 + 4.0 + hue)\n    );\n    return rainbowColor;\n}\n\n// Function to apply bloom\nvec3 applyBloom(vec2 uv, vec3 originalColor, float bloomIntensity) {\n    vec3 blurredColor = vec3(0.0);\n\n    // Blur the bright parts of the image (adjust blur size as needed)\n    for (float i = -5.0; i <= 5.0; i++) {\n        for (float j = -5.0; j <= 5.0; j++) {\n            vec2 offset = vec2(i, j) / iResolution.xy;\n            blurredColor += texture(iChannel0, uv + offset).rgb;\n        }\n    }\n\n    blurredColor /= 128.0;  // Number of samples\n\n    // Combine the original color with the blurred bright parts\n    vec3 finalColor = originalColor + blurredColor * bloomIntensity;\n\n    return finalColor;\n}\n\n// Function to modify the hue of a color\nvec3 modifyHue(vec3 color, float hue) {\n    // Convert RGB to HSL\n    float maxVal = max(max(color.r, color.g), color.b);\n    float minVal = min(min(color.r, color.g), color.b);\n    float delta = maxVal - minVal;\n\n    float hueValue = 0.0;\n    if (delta > 0.0) {\n        if (maxVal == color.r) {\n            hueValue = mod((color.g - color.b) / delta, 6.0);\n        } else if (maxVal == color.g) {\n            hueValue = (color.b - color.r) / delta + 2.0;\n        } else {\n            hueValue = (color.r - color.g) / delta + 4.0;\n        }\n    }\n\n    // Modify the hue\n    hueValue = mod(hueValue + hue, 6.0);\n\n    // Convert HSL back to RGB\n    float c = (1.0 - abs(2.0 * color.b - 1.0)) * delta;\n    float x = c * (1.0 - abs(mod(hueValue, 2.0) - 1.0));\n    float m = color.b - 0.5 * c;\n\n    if (hueValue < 1.0) {\n        return vec3(c + m, x + m, m);\n    } else if (hueValue < 2.0) {\n        return vec3(x + m, c + m, m);\n    } else if (hueValue < 3.0) {\n        return vec3(m, c + m, x + m);\n    } else if (hueValue < 4.0) {\n        return vec3(m, x + m, c + m);\n    } else if (hueValue < 5.0) {\n        return vec3(x + m, m, c + m);\n    } else {\n        return vec3(c + m, m, x + m);\n    }\n}\n\n    // Main shader entry point\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n        // Get pixel coordinates normalized between 0 and 1\n        vec2 uv = fragCoord / iResolution.xy;\n\n        // Get the audio input value for the current pixel\n        float audioValue = texture(iChannel0, uv).r;\n\n        // Triflake visualization based on the audio input\n        float triflakePattern = triflake(uv, 0.15 + audioValue * 0.2, 5);\n\n        // Hue parameter (adjust as needed)\n        float hue = 51.5;\n\n        // RGB \"rainbow\" gradient for the triflake visualization\n        vec3 RGBColor = RainbowGradient(triflakePattern, hue);\n\n        // Modify hue of the RGB color\n        RGBColor = modifyHue(RGBColor, hue);\n\n        // Mix the RGB colors with the triflake visualization\n        vec3 color = mix(vec3(0.0), RGBColor, triflakePattern);\n\n        // Apply bloom with a certain intensity\n        float bloomIntensity = 0.5; // Adjust as needed\n        vec3 finalColor = applyBloom(uv, color, bloomIntensity);\n\n        // Set the final color, black outside the visualization area\n        fragColor = vec4(finalColor, 1.0 - step(triflakePattern, 0.1));\n    }\n","name":"Image","description":"","type":"image"}]}