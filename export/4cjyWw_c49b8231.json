{"ver":"0.1","info":{"id":"4cjyWw","date":"1722436874","viewed":32,"name":"CIE XY Gamut Explorer","username":"ARPP3","description":"Approximation of the visible light spectrum, some color spaces and their primaries. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["visualization","color","colorspace","gamut","ciexyz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/************************************\n *  CIE XY Color Space Visualizer   *\n ************************************\n\nA simple visualization tool! Feel free to use this for debugging. The UVs used are in the xyY coordinate space.\n\nKey features:\n- Visualize common color gamuts:\n  * Rec.709 (Blue)\n  * Rec.2020 (Orange)\n  * ACES AP1 (Magenta)\n  * ACES AP0 (Green)\n  * DCI-P3 (Yellow)\n- Determine if a point falls within the visible spectrum (approximation)\n\nAgain, the visible light spectrum is an approximation! But I am open to any suggestion how to make it more accurate. \nI just did my best to fit some curves to the spectral locus, and it works well enough for me.\n\n*/\n\nfloat GetTriangleDistance(vec2[3] v, vec2 p)\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=2; i<3; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s * sqrt(d);\n}\n\nvoid AddRec709Triangle(inout vec3 fragColor, in vec2 p, vec3 color)\n{\n    vec2[] v = vec2[](\n        vec2(0.6400f, 0.3300f), // R\n        vec2(0.3000f, 0.6000f), // G\n        vec2(0.1500f, 0.0600f) // B\n    );\n    \n    float lineThickness = 1.0-smoothstep(0.0,0.002,abs(GetTriangleDistance(v, p)));\n    fragColor = mix(fragColor, color, lineThickness);\n}\n\nvoid AddRec2020Triangle(inout vec3 fragColor, in vec2 p, vec3 color)\n{\n    vec2[] v = vec2[](\n        vec2(0.7080f, 0.2920f), // R\n        vec2(0.1700f, 0.7970f), // G\n        vec2(0.1310f, 0.0460f) // B\n    );\n    \n    float lineThickness = 1.0-smoothstep(0.0,0.002,abs(GetTriangleDistance(v, p)));\n    fragColor = mix(fragColor, color, lineThickness);\n}\n\nvoid AddACESAP1Triangle(inout vec3 fragColor, in vec2 p, vec3 color)\n{\n    vec2[] v = vec2[](\n        vec2(0.7130f, 0.2930f), // R\n        vec2(0.1650f, 0.8300f), // G\n        vec2(0.1280f, 0.0440f)  // B\n    );\n    \n    float lineThickness = 1.0-smoothstep(0.0,0.002,abs(GetTriangleDistance(v, p)));\n    fragColor = mix(fragColor, color, lineThickness);\n}\n\nvoid AddACESAP0Triangle(inout vec3 fragColor, in vec2 p, vec3 color)\n{\n    vec2[] v = vec2[](\n        vec2(0.7347f, 0.2653f), // R\n        vec2(0.0000f, 1.0000f), // G\n        vec2(0.0001f, -0.0770f) // B\n    );\n    \n    float lineThickness = 1.0-smoothstep(0.0,0.002,abs(GetTriangleDistance(v, p)));\n    fragColor = mix(fragColor, color, lineThickness);\n}\n\nvoid AddDCIP3Triangle(inout vec3 fragColor, in vec2 p, vec3 color)\n{\n    vec2[] v = vec2[](\n        vec2(0.6800f, 0.3200f), // R\n        vec2(0.2650f, 0.6900f), // G\n        vec2(0.1500f, 0.0600f)  // B\n    );\n    \n    float lineThickness = 1.0-smoothstep(0.0,0.002,abs(GetTriangleDistance(v, p)));\n    fragColor = mix(fragColor, color, lineThickness);\n}\n\n\nfloat IsInSpectralLocus(vec2 p)\n{\n    // Transform the coordinates into rotated and scaled coordinate space\n    vec2 transformedP = vec2(\n        (p.x * 1.23f) *  0.90556881693f - (p.y * 1.24f) * -0.42419938448f + -0.165f,\n        (p.x * 1.23f) * -0.42419938448f + (p.y * 1.24f) *  0.90556881693f +  0.092f\n    );\n    \n    if (transformedP.x < 0.0f) return 0.0f;\n    \n    // Functions that are below the curve\n    float isBelow = 1.0f;\n    \n    if (transformedP.x > 0.335f)\n    {\n        isBelow = step(transformedP.y, 1.0f - ((sqrt(pow((transformedP.x - 0.335f) / 0.4f, 2.3f) + 0.04f) - 0.2f)));\n    }\n    else\n    {\n        isBelow = step(transformedP.y, mix(\n            0.84 * sqrt(transformedP.x / 0.3f) + 0.13f,\n            1.0f - pow(((transformedP.x - 0.335f) / 0.38f), 2.0f), \n            transformedP.x / 0.335f));\n    }\n    \n    // Functions that are above the curve\n    float isAbove = step(0.0f, transformedP.y) * step(0.13 - (sqrt(transformedP.x) / 1.3f), transformedP.y);\n    \n    return isBelow * isAbove;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec2 coord = fragCoord / iResolution.xy;\n    coord.x = (coord.x - 0.5f) * aspectRatio + 0.5f;\n\n    // Background color\n    vec3 imageColor = ApplyGamma(xyYToRGB(vec3(coord, 1.0f)), 2.4f);\n    \n    imageColor = mix(vec3(1.0f, 1.0f, 1.0f), imageColor.rgb, IsInSpectralLocus(coord));\n    \n    // Blend over grid lines\n    imageColor *= 1.0f - CreateGrid(coord) * 0.2f;\n    \n    // Gammuts\n    AddRec709Triangle(imageColor.rgb, coord, vec3(0.0f, 0.4f, 1.0f));    // Blue\n    AddRec2020Triangle(imageColor.rgb, coord, vec3(1.2f, 0.6f, 0.1f));   // Orange\n    AddACESAP1Triangle(imageColor.rgb, coord, vec3(1.0f, 0.0f, 1.0f));   // Magenta\n    AddACESAP0Triangle(imageColor.rgb, coord, vec3(0.0f, 1.0f, 0.0f));   // Green\n    AddDCIP3Triangle(imageColor.rgb, coord, vec3(1.0f, 1.0f, 0.0f));     // Yellow\n    \n\n    // Output to screen\n    fragColor = vec4(imageColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float CreateGrid(vec2 uv)\n{\n    vec2 grid = fract(uv * 10.0f); // Units are 0-1, so add 10 steps\n    vec2 lines = smoothstep(0.02, 0.0, min(grid, 1.0 - grid));\n    \n    return max(lines.x, lines.y);\n}\n\nvec3 xyY2XYZ(vec3 xyY)\n{\n\tfloat d = max(xyY.y, 1e-7);\n\treturn vec3(\n\txyY.x * xyY.z / d,\n\txyY.z,\n\t(1.0 - xyY.x - xyY.y) * xyY.z / d);\n}\n\nvec3 xyYToRGB(vec3 xyY)\n{\n    vec3 XYZ = xyY2XYZ(xyY);\n\n    // XYZ to RGB matrix\n    mat3 XYZtoRGB = mat3(\n         3.2404542, -1.5371385, -0.4985314,\n        -0.9692660,  1.8760108,  0.0415560,\n         0.0556434, -0.2040259,  1.0572252\n    );\n\n    vec3 rgb = XYZ * XYZtoRGB;\n\n\tfloat maxChannel = max(rgb.r, max(rgb.g, rgb.b));\n\treturn rgb / max(maxChannel, 1.0f);\n}\n\nvec3 ApplyGamma(vec3 color, float gamma)\n{\n    return vec3(\n        pow(max(color.r, 0.0f), 1.0f / gamma),\n        pow(max(color.g, 0.0f), 1.0f / gamma),\n        pow(max(color.b, 0.0f), 1.0f / gamma)\n    );\n}\n","name":"Common","description":"","type":"common"}]}