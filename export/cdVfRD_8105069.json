{"ver":"0.1","info":{"id":"cdVfRD","date":"1698002946","viewed":41,"name":"22. Scratchy","username":"Ladus","description":"Inktober 2023 Day 22.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["inktober","scratchy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define aa 2./iResolution.y\n#define PI 3.14159265359\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nmat2 rotate(vec2 direction) { \n    float a = atan(direction.x,direction.y);\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat ScratchMask(vec2 p, vec2 start, vec2 end, float progression) {\n    vec2 gradient = (p-start)*rotate(end-start);\n    gradient /= distance(start,end);\n    gradient = clamp(gradient,0.,1.);\n    vec2 rGradient = 1.-gradient;\n    \n    float sdf = sdSegment(p, start, end);\n    float scratch = min(gradient.y + sdf*-1., gradient.y + smoothstep(0.,.1,sdf)*-1.);\n    float rScratch = min(rGradient.y + sdf*-1., rGradient.y + smoothstep(0.,.1,sdf)*-1.);\n    scratch = min(scratch, rScratch)*3.;\n    \n    return smoothstep(0.1-aa,0.1+aa,scratch) * smoothstep(1.-progression,1.-progression,1.-gradient.y);\n}\n\nfloat ScratchesMask(vec2 p, vec2 start, vec2 end, float progression) {\n    float offset = 0.3;\n    // center scratch\n    float s = ScratchMask(p, start, end, progression);\n    \n    // two side scratches\n    vec2 direction = normalize(end-start);\n    vec2 perp = vec2(direction.y, -direction.x);\n    float dist = distance(start,end);\n    // Make them a bit shorter\n    vec2 secondaryStart = start + direction*dist*0.2;\n    vec2 secondaryEnd = end - direction* dist*0.2;\n    \n    \n    s += ScratchMask(p, secondaryStart + perp*offset, secondaryEnd + perp*offset, progression);\n    s += ScratchMask(p, secondaryStart + perp*-offset, secondaryEnd + perp*-offset, progression);\n    \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ((fragCoord/iResolution.xy) - vec2(0.5,0.5)) * 2.;\n    p.x *= iResolution.x / iResolution.y;\n    float loopingTime = fract(iTime/4.);\n    float timeLine = loopingTime*6.;\n    \n    // scratch 1\n    float sMask1 = ScratchesMask(p, vec2(-1.,0.9), vec2(1.,-0.9), timeLine*4.) * 1.-(clamp((timeLine-.5)*.5,0.,1.));\n    \n    // scratch 2\n    float sMask2 = ScratchesMask(p, vec2(1.,0.9), vec2(-1.,-0.9), (timeLine-1.)*4.) * 1.-(clamp((timeLine-1.5)*.5,0.,1.));\n    \n    // Output to screen\n    fragColor = vec4(mix(vec3(0.05,0.0,0.01), vec3(1.,0.2,0.2), clamp(max(sMask1,sMask2),0.,1.)),1.0);\n}","name":"Image","description":"","type":"image"}]}