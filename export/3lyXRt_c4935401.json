{"ver":"0.1","info":{"id":"3lyXRt","date":"1583493682","viewed":1946,"name":"Screen Space Reflections","username":"Eikins","description":"SSR technique explanation.\n\nThe original Z, normal and frame buffers are generated using ray-casting.\n\nThey're not perfect yet, I'm still trying to figure the depthStep computation.\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raycastscreenspacereflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ===== PARAMS =====\n\n// Define the raymarch algorithm\n// Screen space still have an issue with depth length\n// MARCH_SCREEN_SPACE | MARCH_WORLD_SPACE\n#define MARCH_WORLD_SPACE\n\nconst float _MaxDistance = 15.0;\nconst float _Step = 0.05;\nconst float _Thickness = 0.0006;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel2, uv);\n    \n    // Fragment shader, this part is used to get the pixels of the ground\n    // Get the ground in our case\n    if(col == (.5 + -.5 * dot(vec3(0.0, 1.0, 0.0), LIGHT_DIRECTION)) * vec4(.1, .1, .1, 1.0)) {\n        \n        // SSR Goes there\n        \n        // We sample the Depth (Buffer A), the normal (Buffer B)\n       \t// And gather the view ray intersection\n        \n        // ===== VIEW RAY =====\n        vec3 eye = EYE_POS + vec3(3.0 * cos(iTime), 1.0 * sin(iTime), 0.0);\n      \t// Pixel coordinates mapped to [-aspectRatio, aspectRatio] x [-1, 1]\n    \tvec2 r_uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n        vec3 r_dir = vec3(r_uv.x * CAMERA.X + r_uv.y * CAMERA.Y + NEAR_DISTANCE * CAMERA.Z);\n\t\tRay ray = Ray(eye, normalize(r_dir));\n        // ====================\n        \n        float aspect = iResolution.x / iResolution.y;\n        \n        float depth = texture(iChannel0, uv).x;\n        vec3 normal = texture(iChannel1, uv).xyz;\n        \n        \n        vec3 view      = ray.dir * length(r_dir) * depth * FAR_DISTANCE / NEAR_DISTANCE;\n        vec3 position  = ray.origin + view;\n        vec3 reflected = reflect(normalize(view), normal);\n              \n        \n        vec2 reflectionUV = uv;\n        float atten = 0.0f;\n        \n        #ifdef MARCH_SCREEN_SPACE\n \n            // ===== Project onto screen space =====\n            // We generated everything with raytracing, but in realtime apps, just use \n            // The camera projection-view matrix here (_ProjectionView * position)\n            // Instead, i'll compute the projection by hand\n            vec2 screenStart = projectOnScreen(eye, position);\n            vec2 screenEnd   = projectOnScreen(eye, position + reflected);\n            vec2 screenDir   = (screenEnd - screenStart).xy;\n        \n            // ===== Ray march in screen space =====\n            float reflectedDepth = dot(reflected, CAMERA.Z) / FAR_DISTANCE;\n            float depthStep = reflectedDepth;\n\n            float currentDepth = depth;\n            vec2 march = screenStart;\n\n            for(float i = 0.0; i < _MaxDistance; i += _Step) {\n                march += screenDir * _Step;\n                vec2 marchUV;\n                marchUV.x = map(march.x, -aspect, aspect, 0.0, 1.0); \n                marchUV.y = map(march.y, -1.0, 1.0, 0.0, 1.0); \n                float targetDepth = texture(iChannel0, marchUV).x;\n                float depthDiff = currentDepth - targetDepth;\n                if(depthDiff > 0.0 && depthDiff < depthStep) {\n                    reflectionUV = marchUV;\n                    atten = 1.0 - i / _MaxDistance;\n                    break;\n                }\n                currentDepth += depthStep * _Step;\n            }\n       \t\n        #endif\n        #ifdef MARCH_WORLD_SPACE\n        \n            vec3 marchReflection;\n            float currentDepth = depth;\n            for(float i = _Step; i < _MaxDistance; i+= _Step) {\n                marchReflection = i * reflected;\n\t\t\t\tfloat targetDepth = dot(view + marchReflection, CAMERA.Z) / FAR_DISTANCE;\n                vec2 target = projectOnScreen(eye, position + marchReflection);\n                target.x = map(target.x, -aspect, aspect, 0.0, 1.0); \n                target.y = map(target.y, -1.0, 1.0, 0.0, 1.0); \n                float sampledDepth = texture(iChannel0, target).x;\n                float depthDiff = sampledDepth - currentDepth;\n                if(depthDiff > 0.0 && depthDiff < targetDepth - currentDepth + _Thickness) {\n                    reflectionUV = target;\n                    atten = 1.0 - i / _MaxDistance;\n                    break;\n                }\n                currentDepth = targetDepth;\n                if(currentDepth > 1.0) {\n                    atten = 1.0;\n                    break;\n                }\n            }\n        \n        #endif\n\n        fragColor = vec4(reflectionUV - uv, 0., 1.);\n    \tfragColor = vec4(texture(iChannel2, reflectionUV).rgb * atten + col.rgb, 1.0); \n    } else {\n    \tfragColor = vec4(col.rgb, 1.);\n    }\n    \n    //fragColor = texture(iChannel0, uv);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/1.6));\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DIST_MIN 1e-5\n#define DIST_MAX 1e+5 \n\n#define OBJECT_TYPE_NONE -1\n#define OBJECT_TYPE_PLANE 0\n#define OBJECT_TYPE_SPHERE 1\n\nstruct Frame {\n    vec3 X, Y, Z;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere \n{\n\tvec3 center;\n\tfloat radius;\n    vec3 col;\n};\n    \nstruct Plane {\n    vec3 normal;\n    float offset;\n    vec3 col;\n};\n    \n// ===== SCENE =====\n#define PLANE_COUNT 3\n#define SPHERE_COUNT 2\n    \nFrame CAMERA = Frame(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\nvec3 EYE_POS = vec3(0, 1.0, -5.0);\nconst float NEAR_DISTANCE = 2.0f;\nconst float FAR_DISTANCE = 50.0f;\n\nconst vec4 DEFAULT_COLOR = vec4(.45, .85, .92, 1);\nconst vec3 LIGHT_DIRECTION = normalize(vec3(0.5, -1.0, 1.0));\n\nconst Plane[PLANE_COUNT] planes = Plane[](\n    Plane(vec3(0.0, 1.0, 0.0), 3.0, vec3(0.1, 0.1, 0.1)),\n    Plane(vec3(1.0, 0.0, 0.0), 5.0, vec3(0.9, 0.15, 0.15)),\n    Plane(vec3(0.0, 0.0, -1.0), 10.0, vec3(0.0, 0.22, 0.6)));\nconst Sphere[SPHERE_COUNT] spheres = Sphere[](\n    Sphere(vec3(-1.0, 1.0, 11.0), 2.0, vec3(1.0, 0.0, 0.0)),\n\tSphere(vec3(3.0, -2.5, 8.0), 1.0, vec3(0.0, 1.0, 0.0)));\n    \n// struct for remembering intersected object\nstruct ISObj \n{\n\tfloat dist;  // distance to the object\n\tint type;    // type (-1=nothing,0=plane, 1=sphere)\n\tint id;      // object ID\n};\n    \nISObj intersectPlane(in Plane p, in Ray r, in int id) {\n    float t = - (p.offset + dot(r.origin, p.normal)) / dot(r.dir, p.normal);\n    \n    if (t < 0.0) {\n        return ISObj(DIST_MAX, OBJECT_TYPE_NONE, -1);\n    } else {\n    \treturn ISObj(t, OBJECT_TYPE_PLANE, id);\n    }\n\n}\n    \nISObj intersectSphere(in Sphere s, in Ray r, in int id) {\n    vec3 offset = (r.origin - s.center);\n\tfloat a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(offset, r.dir);\n    float c = dot(offset, offset) - s.radius * s.radius;\n    \n    float det = sqrt(b*b - 4.0*a*c);\n    \n    if (det < 0.0) {\n        return ISObj(DIST_MAX, OBJECT_TYPE_NONE, -1);\n    } else {\n        float t = min(- b - det, - b + det) / (2.0 * a);\n    \treturn ISObj(t, OBJECT_TYPE_SPHERE, id);\n    }\n\n}\n\nvec3 computeSphereNormal(in Sphere s, in Ray r, in float dist) {\n    return normalize((r.origin + r.dir * dist) - s.center);\n}\n\nvec2 projectOnScreen(vec3 eye, vec3 point) {\n\tvec3 toPoint = (point - eye);\n    point = (point - toPoint * (1.0 - NEAR_DISTANCE / dot(toPoint, CAMERA.Z)));\n    point -= eye + NEAR_DISTANCE * CAMERA.Z;\n    return point.xy;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// define DEPTH_BUFFER | Z_BUFFER | NORMAL_BUFFER | BASIC_SHADING \n#define Z_BUFFER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 eye = EYE_POS + vec3(3.0 * cos(iTime), 1.0 * sin(iTime), 0.0);\n      \n    // Pixel coordinates mapped to [-aspectRatio, aspectRatio] x [-1, 1]\n    vec2 uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n\n    Ray ray = Ray(eye, normalize(vec3(uv.x * CAMERA.X + uv.y * CAMERA.Y + NEAR_DISTANCE * CAMERA.Z)));\n\n    ISObj nearestObj = ISObj(FAR_DISTANCE, -1, -1);\n    \n    for (int i = 0; i < PLANE_COUNT; i++) {\n   \t\tISObj raycast = intersectPlane(planes[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    for (int i = 0; i < SPHERE_COUNT; i++) {\n   \t\tISObj raycast = intersectSphere(spheres[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    #ifdef DEPTH_BUFFER\n        fragColor = vec4(nearestObj.dist, nearestObj.dist, nearestObj.dist, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #ifdef Z_BUFFER\n    \tfloat z = dot(ray.dir * nearestObj.dist, CAMERA.Z);\n        fragColor = vec4(z, z, z, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #if defined(NORMAL_BUFFER) || defined(BASIC_SHADING)\n        vec3 normal;\n        if (nearestObj.type == OBJECT_TYPE_PLANE) {\n            normal = planes[nearestObj.id].normal;\n        } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n            normal = computeSphereNormal(spheres[nearestObj.id], ray, nearestObj.dist);\n        } else {\n            normal = vec3(0.0, 0.0, 0.0);\n        }\n\n        #ifdef NORMAL_BUFFER\n        \tfragColor = vec4(normal, 1.0);\n        #endif\n    \n        #ifdef BASIC_SHADING\n    \t\tvec4 color;\n            if (nearestObj.type == OBJECT_TYPE_PLANE) {\n                color = vec4(planes[nearestObj.id].col, 1.0);\n            } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n                color = vec4(spheres[nearestObj.id].col, 1.0);\n            } else {\n                fragColor = DEFAULT_COLOR;\n                return;\n            }\n        \tfragColor = (.5 + -.5 * dot(normal, LIGHT_DIRECTION)) * color;\n        #endif\n    \n    #endif\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// define DEPTH_BUFFER | Z_BUFFER | NORMAL_BUFFER | BASIC_SHADING \n#define NORMAL_BUFFER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 eye = EYE_POS + vec3(3.0 * cos(iTime), 1.0 * sin(iTime), 0.0);\n      \n    // Pixel coordinates mapped to [-aspectRatio, aspectRatio] x [-1, 1]\n    vec2 uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n\n    Ray ray = Ray(eye, normalize(vec3(uv.x * CAMERA.X + uv.y * CAMERA.Y + NEAR_DISTANCE * CAMERA.Z)));\n\n    ISObj nearestObj = ISObj(FAR_DISTANCE, -1, -1);\n    \n    for (int i = 0; i < PLANE_COUNT; i++) {\n   \t\tISObj raycast = intersectPlane(planes[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    for (int i = 0; i < SPHERE_COUNT; i++) {\n   \t\tISObj raycast = intersectSphere(spheres[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    #ifdef DEPTH_BUFFER\n        fragColor = vec4(nearestObj.dist, nearestObj.dist, nearestObj.dist, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #ifdef Z_BUFFER\n    \tfloat z = dot(ray.dir * nearestObj.dist, CAMERA.Z);\n        fragColor = vec4(z, z, z, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #if defined(NORMAL_BUFFER) || defined(BASIC_SHADING)\n        vec3 normal;\n        if (nearestObj.type == OBJECT_TYPE_PLANE) {\n            normal = planes[nearestObj.id].normal;\n        } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n            normal = computeSphereNormal(spheres[nearestObj.id], ray, nearestObj.dist);\n        } else {\n            normal = vec3(0.0, 0.0, 0.0);\n        }\n\n        #ifdef NORMAL_BUFFER\n        \tfragColor = vec4(normal, 1.0);\n        #endif\n    \n        #ifdef BASIC_SHADING\n    \t\tvec4 color;\n            if (nearestObj.type == OBJECT_TYPE_PLANE) {\n                color = vec4(planes[nearestObj.id].col, 1.0);\n            } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n                color = vec4(spheres[nearestObj.id].col, 1.0);\n            } else {\n                fragColor = DEFAULT_COLOR;\n                return;\n            }\n        \tfragColor = (.5 + -.5 * dot(normal, LIGHT_DIRECTION)) * color;\n        #endif\n    \n    #endif\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// define DEPTH_BUFFER | Z_BUFFER | NORMAL_BUFFER | BASIC_SHADING \n#define BASIC_SHADING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 eye = EYE_POS + vec3(3.0 * cos(iTime), 1.0 * sin(iTime), 0.0);\n      \n    // Pixel coordinates mapped to [-aspectRatio, aspectRatio] x [-1, 1]\n    vec2 uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n\n    Ray ray = Ray(eye, normalize(vec3(uv.x * CAMERA.X + uv.y * CAMERA.Y + NEAR_DISTANCE * CAMERA.Z)));\n\n    ISObj nearestObj = ISObj(FAR_DISTANCE, -1, -1);\n    \n    for (int i = 0; i < PLANE_COUNT; i++) {\n   \t\tISObj raycast = intersectPlane(planes[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    for (int i = 0; i < SPHERE_COUNT; i++) {\n   \t\tISObj raycast = intersectSphere(spheres[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    \n    #ifdef DEPTH_BUFFER\n        fragColor = vec4(nearestObj.dist, nearestObj.dist, nearestObj.dist, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #ifdef Z_BUFFER\n    \tfloat z = dot(ray.dir * nearestObj.dist, CAMERA.Z);\n        fragColor = vec4(z, z, z, FAR_DISTANCE) / FAR_DISTANCE;\n    #endif\n    \n    #if defined(NORMAL_BUFFER) || defined(BASIC_SHADING)\n        vec3 normal;\n        if (nearestObj.type == OBJECT_TYPE_PLANE) {\n            normal = planes[nearestObj.id].normal;\n        } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n            normal = computeSphereNormal(spheres[nearestObj.id], ray, nearestObj.dist);\n        } else {\n            normal = vec3(0.0, 0.0, 0.0);\n        }\n\n        #ifdef NORMAL_BUFFER\n        \tfragColor = vec4(normal, 1.0);\n        #endif\n    \n        #ifdef BASIC_SHADING\n    \t\tvec4 color;\n            if (nearestObj.type == OBJECT_TYPE_PLANE) {\n                color = vec4(planes[nearestObj.id].col, 1.0);\n            } else if (nearestObj.type == OBJECT_TYPE_SPHERE) {\n                color = vec4(spheres[nearestObj.id].col, 1.0);\n            } else {\n                fragColor = DEFAULT_COLOR;\n                return;\n            }\n        \tfragColor = (.5 + -.5 * dot(normal, LIGHT_DIRECTION)) * color;\n        #endif\n    \n    #endif\n\n}","name":"Buffer C","description":"","type":"buffer"}]}