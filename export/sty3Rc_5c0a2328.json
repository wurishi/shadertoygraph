{"ver":"0.1","info":{"id":"sty3Rc","date":"1641266988","viewed":155,"name":"yichen's raymarcher","username":"Yichen","description":"my first attempt at a raymarcher\ndrag the mouse to rotate the screen","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarcher","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// drag mouse to rotate scene\n\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define MAX_STEPS 100\n#define NUM_BOUNCES 3\n\nconst int MAT_METAL = 1;\nconst int MAT_PLASTIC = 2;\nconst int MAT_DIFFUSE = 3;\nconst int MAT_GROUND = 4;\n\nstruct ray {\n    vec3 o, d;\n};\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nray reflectRay(ray r, vec3 n, vec3 pos) {\n    r.o = pos + n*MIN_DIST*3.;\n    r.d = r.d - 2.*dot(r.d, n)*n;\n    return r;\n}\n\n// SDFs\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p)-radius;\n}\n\nfloat boxSDF( vec3 p, vec3 b, float r) {\n  b *= 0.5;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0)-r;\n}\n\nfloat planeSDF(vec3 p, vec3 n, float h) {\n    return dot(p,n) - h;\n}\n\nfloat capsuleSDF(vec3 p, vec3 a, vec3 b, float radius) {\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    float t = dot(ap, ab)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c)-radius;\n}\n\nfloat torusSDF(vec3 p, vec2 radius) {\n  vec2 q = vec2(length(p.xz)-radius.x,p.y);\n  return length(q)-radius.y;\n}\n\nfloat cappedCylinderSDF(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h*0.5);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 getScene(vec3 p) {\n\n    float pd = planeSDF(p, vec3(0.,1.,0.), -0.5);\n    float sd = sphereSDF(p, 0.3);\n    float bd = boxSDF(p-vec3(-.4, 0., .7), vec3(0.5), 0.05);\n    float cd = capsuleSDF(p-vec3(0.2, -.2, -.8), vec3(0., 0., 0.), vec3(.6, .0, .2), .1);\n    float cyd = cappedCylinderSDF(p-vec3(.5, 0., 0.), .2, .8)-.01;\n    float td = torusSDF(p-vec3(-.5, -.2, -.4), vec2(0.3, .15));\n    float flatboxd = boxSDF(p-vec3(0.,-.55,0.), vec3(4, .1, 4.), .01);//+0.005*(sin(6.*p.x)+1.);\n    \n    float d = min(min(min(min(td, cyd), bd), flatboxd), cd);\n    \n    // materials\n    int mat = 0;\n    if (d==td) mat = MAT_METAL;\n    else if (d==cyd) mat = MAT_METAL;\n    else if (d==bd) mat = MAT_DIFFUSE;\n    else if (d==flatboxd) mat = MAT_GROUND;\n    else if (d==cd) mat = MAT_PLASTIC;\n    \n    return vec2(d, mat);\n    \n}\n\n// Ray Marching\n\nray getRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookAt - camPos);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = normalize(cross(f, r));\n    vec3 c = camPos + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    a.d = normalize(i-camPos);\n    \n    return a;\n}\n\nvec2 raymarch(ray r, float depth) {\n    \n    vec2 scene;\n    vec3 p;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n        p = r.o+r.d*depth;\n        scene = getScene(p);\n        if (scene.x < abs(MIN_DIST)) break;\n        else depth += scene.x;\n    }\n    \n    return vec2(depth, scene.y);\n\n}\n\n// Lighting\n\nvec3 estimateNormal(vec3 pos) {\n    vec2 EPSILON = vec2(0.0001, 0.);\n    \n    return normalize(vec3(getScene(pos+EPSILON.xyy).x-getScene(pos-EPSILON.xyy).x,\n    getScene(pos+EPSILON.yxy).x-getScene(pos-EPSILON.yxy).x,\n    getScene(pos+EPSILON.yyx).x-getScene(pos-EPSILON.yyx).x));\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 light) {\n    return clamp(dot(n, normalize(light-p)), 0., 1.);\n}\n\n// Render and Shade\n\nvec3 render(inout ray r, inout float ref) {\n    \n    ref = 0.;\n    vec2 scene = raymarch(r, 0.);\n    vec3 col = texture(iChannel0, r.d).rgb;\n    if (scene.x < MAX_DIST) { \n        vec3 pos = r.o + r.d*scene.x;\n        vec3 normal = estimateNormal(pos);\n\n        // lighting\n        vec3 light = vec3(sin(iTime), 1., cos(iTime));\n        float dif = diffuse(pos, normal, light);\n        \n        float fresnel = pow(1.-dot(normal, -r.d), 5.);\n        \n        // materials\n        int mat = int(scene.y);\n        if (mat == MAT_METAL) {\n            col = vec3(dif*0.2);\n            ref = 0.9;\n        }\n        else if (mat == MAT_PLASTIC) {\n            col = dif*vec3(.9, .3, .6);\n            ref = mix(0.05, 0.5, fresnel);\n        }\n        else if (mat == MAT_DIFFUSE) {\n            col = dif*vec3(.3, .2, .9);\n            ref = 0.;\n        }\n        else if (mat == MAT_GROUND) {\n            col = dif*vec3(.9, .7, .4);\n            ref = mix(0.015, .5, fresnel);\n        }\n        else {\n            col = vec3(1., .2, .7); // bright pink: no material\n        }\n\n        // ray march shadows\n        ray sr = ray(pos, normalize(light-pos));\n        float s = min(raymarch(sr, 0.1).x, 1.);\n        col *= s;\n        \n        // reflect ray for bounces\n        r = reflectRay(r, normal, pos);\n    }\n    \n    return col;\n\n}\n\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // set up uv and mouse coords\n    vec2 uv = fragCoord.xy/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // set up camera\n    vec3 camPos = vec3(2.2, 1., -.7);\n    camPos.yz *= rotate(-m.y*3.14+1.);\n    camPos.xz *= rotate(-m.x*6.2831+3.14);\n    vec3 lookAt = vec3(0., 0., 0.);\n    float zoom = 1.;\n    \n    // generate ray\n    ray r = getRay(uv, camPos, lookAt, zoom);\n    \n    // render\n    float ref = 0.; // reflection coefficient\n    float fil = 1.; // filter to decrease reflection\n    vec3 col = render(r, ref); // render with no bounces\n    vec3 bounce;\n    for (int i = 0; i < NUM_BOUNCES; i++) {\n        fil *= ref;\n        bounce = fil*render(r, ref);\n        col += bounce;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}