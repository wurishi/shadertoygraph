{"ver":"0.1","info":{"id":"7l3fWB","date":"1663614613","viewed":54,"name":"Linear Remez Approximation","username":"Envy24","description":"Green - f(x).\nBlue - p(x) (approximation).\nRed - max(abs(f(x)-p(x)).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["approximation","linear","lp","norm","polynomial","metric","l1","l2","linf","remez"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// Define function that you want to approximate and first derivative\n#define func(x) ( exp(x) )\n#define dfdx(x) ( exp(x) )\n\n// Approximation polynomial\nfloat poly(float c[2], float x) { return c[0]*x+ c[1]; }\n\n// First derivative of approximation polynomial\nfloat dpdx(float c[2], float x) { return c[0]; }\n\n// L-metric.\nfloat L(float c[2], float x) { return abs(func(x) - poly(c, x)); }\n\n// First derivative of L-metric.\nfloat dLdx(float c[2], float x) { return dfdx(x) - dpdx(c, x); }\n\n/* Stupid search for x value where L(x) is max on [xl, xr]. */\nfloat findMax(\n    float xl, float xr, float c[2])\n{\n    int count = 10;\n    float max_abs = 0., best_x = 0., dx = (xr-xl)/float(count - 1);\n    \n    for (int i = 0; i < count; ++i)\n    {\n        float x = xl + float(i)*dx;\n        float y = L(c, x);\n        \n        max_abs = max(max_abs, y);\n            \n        best_x = \n            y == max_abs ?\n                x :\n                best_x;\n    }\n    \n    return best_x;\n}\n\nvoid RemezApproximation(\n    inout float c[2],\n    in float x[3])\n{\n    float tolerance = 1e-7;\n    int max_num_of_iteration = 3;\n    for (int i = 0; i < max_num_of_iteration; ++i)\n    {\n        // Define system of equations\n        mat3 M = transpose(mat3(\n        //  a     b    L\n            x[0], 1.,  1.,\n            x[1], 1., -1.,\n            x[2], 1.,  1.));\n        M = inverse(M);\n        // Evaluate f(x) at roots.\n        vec3 V = vec3(func(x[0]), func(x[1]), func(x[2]));\n        // Solve system of 3 linear equations with 3 unknowns.\n        vec3 R = M * V;\n        // Save new coeffitients (a, b)\n        c[0]=R[0]; c[1]=R[1];\n        // Find x value where L(x) is max on [xl, xr]\n        float new_x = findMax(x[0], x[2], c);\n        // Approximation is good enough? \n        if (abs(L(c, new_x) - abs(R[2])) < tolerance) { return; }\n        \n        for (int k = 0; k < 2; ++k)\n        {\n            // Should replace one of this roots?\n            if ((new_x >= x[k]) && (new_x <= x[k + 1]))\n            {\n                // Calculate distances.\n                float d0 = abs(x[k] - new_x);\n                float d1 = abs(x[k + 1] - new_x);\n                // Left root is closer to new root?\n                if (d0 < d1) { x[k] = new_x; }\n                else { x[k+1] = new_x; }\n                break;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = (TO_CENTERED_NDC(SC) + vec2(0., 0.5)) * 3.5;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);         \n\n    /* Remez approximation setup */\n         const int count = 3; // DON'T CHANGE\n         //                                 a   b\n         float c[count-1] = float[count-1]( 1., 1. );\n         // Try different intervals [xl, xr].\n         float x[count], xl = -1., xr = sinOSC(-3., 2., iTime*0.25);\n         \n         float dx_ = (xr-xl) / float(count-1);\n         \n         for (int i = 0; i < count; ++i)\n         {\n             // Can be any values at [xl, xr] which satisfy constrain x[i] < x[i+1]\n             x[i] = xl + float(i) * dx_;\n         }\n         \n         // Calculate polynomial coefficients.\n         RemezApproximation(c, x);  \n    /* Function. */\n         color.rb -= draw_explicit_func(NDC, func(NDC.x), dfdx(NDC.x));       \n    /* Calculated approximation polynomial. */\n         float dx = 0.01, y_c = poly(c, NDC.x), y_n = poly(c, NDC.x+dx);\n         color.rg -= draw_explicit_func(NDC, y_c, (y_n-y_c)/dx);\n    /* L1-metric. */\n         y_c = L(c, NDC.x), y_n = L(c, NDC.x+dx);\n         color.gb -= draw_explicit_func(NDC, y_c, (y_n-y_c)/dx);\n    /* dL1dx. *\n         y_c = dLdx(c, NDC.x), y_n = dLdx(c, NDC.x+dx);\n         color = mix(color, vec3(1,0,1), draw_explicit_func(NDC, y_c, (y_n-y_c)/dx));     \n    /* x-value where L1(x) is maximal at [xl; xr]. */\n         float r = findMax(xl, xr, c);\n               y_c = L(c, r);\n         color = mix(color, vec3(.5,0,1), SMAA(diskSDF_L2(NDC, vec2(r, y_c), 2.*UNIT)));\n    /* Approximation interval. */\n         color -= vertical_line(NDC, xl)*0.4; color -= vertical_line(NDC, xr)*0.4;\n    /**/\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}","name":"Common","description":"","type":"common"}]}