{"ver":"0.1","info":{"id":"3dlfD8","date":"1588177986","viewed":330,"name":"Training : matching pic","username":"MonsieurSoleil","description":"https://www.flickr.com/photos/pandadumpster/6283971381/\nTry to match this picture\n\nOk I went freestyle a little bit leter on...","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["challenge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nconst float GA = 2.399; \n\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec4 dof(vec2 uv, float rad, float focusDistance, float maxVal)\n{\n\n\tvec4 texFetch = texture(iChannel0, uv);\n\n\tfloat diff = maxVal *  abs(focusDistance - fract(texFetch.x * 10000.0));\n\ttexFetch.x -= fract(texFetch.x * 10000.0);\n\t\n\tvec3 acc = texFetch.xyz;\n    vec2 pixel = vec2(diff * 1080.0f/1920.0f, diff);\n\t\n\tvec2 angle=vec2(0.0,rad);\n\t\n    float r = 1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        r += 1.0/r;\n\t\t\n\t    angle *= rot;\n        vec4 col = texture(iChannel0,uv + pixel * (r-1.) * angle);\n\t\tacc+=col.xyz;\n\t}\n\t\n\tfloat gamma = 2.2;\n\treturn vec4(tonemapACES(acc/80.), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1.0 / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    \n    vec4 mainColor = dof(fragCoord.xy *pp, 2.5, 0.2, 0.00015);\n    \n    fragColor = vec4(mainColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// sub surface scattering https://www.shadertoy.com/view/XscyRs + https://www.shadertoy.com/view/lllBDM\n\nfloat gg = 0.0;\n\n#define time iTime\n\nconst float pi = 3.14159;\n\nstruct matter {\n float mat;\n    int material;\n};\n    \nmatter matterInit()\n{\n \tmatter m;\n    m.mat = 0.0;\n    m.material = 0;\n    \n    return m;\n    \n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat rnd(vec2 uv)\n{\n   return fract(\n                dot(\n                    sin(uv*754.2697 + uv.yx * 942.742), \n                    vec2(3847.6511)\n                  )\n              );\n}\n\nfloat rnd(float t)\n{\n   return fract(sin(t * 425.65211) * 562.145);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nmatter map(vec3 p)\n{\n  matter m = matterInit();\n  float mat = 0.0;\n  \n \n\n    vec3 p2 = p;\n    vec3 p3 = p;\n\n\n    p3.xz *= rot(-0.6);\n\n    //building1\n    mat = box(p + vec3(-4.0, 0.0, 2.0), vec3(4.0, 15.0, 3.0));\n    mat = min(mat, box(p + vec3(8.0, 0.0, -2.0), vec3(2.0, 45.0, 2.0))); \n\n    vec3 p4 = p;\n    p4.xyz = (fract(p4.xyz/0.7 - 0.5) - 0.5) * 0.7;\n    mat = opSmoothIntersection(box(p4 + vec3(0.0, 0.0, 0.0), vec3(0.3, 0.35, 0.3)), mat, 0.1);\n\n    m.mat = mat;\n\n    mat = box(p3 + vec3(5.0, 4.0, -9.0), vec3(4.0, 10.0, 5.0)); \n    vec3 p5 = p3;\n    p5.xyz = (fract(p5.xyz/0.9 - 0.5) - 0.5) * 0.9;\n    mat = opSmoothIntersection(box(p5 + vec3(0.0, 0.0, 0.0), vec3(0.45, 0.45, 0.45)), mat, 0.1);\n\n    m.mat = min(m.mat, mat);\n\n\n    if(m.mat < 0.01)\n    {\n        m.material = 1;\n    }\n\n\n\n    float matGG = box(p + vec3(4.0, -2.0, -1.0), vec3(0.05, 10.0, 0.05));\n    gg += 0.1/(0.9+matGG*matGG);\n    return m;\n}\n\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0)\n{\n  float alpha = rough*rough;\n  float asqrt = alpha*alpha;\n  vec3 h = normalize(v + l);\n  \n  float dnl = clamp(dot(n, l), 0.0, 1.0);\n  float dnv = clamp(dot(n, v), 0.0, 1.0);\n  float dnh = clamp(dot(n, h), 0.0, 1.0);\n  float dlh = clamp(dot(l, h), 0.0, 1.0);\n  \n  float f, d, vis;\n  float den = dnh*dnh*(asqrt - 1.0) + 1.0;\n  d = asqrt/(pi * den * den);\n  dlh = pow(1.0 - dlh, 5.0);\n  f = f0 + (1.0 - f0)*dlh;\n  float k = alpha/1.0;\n  vis = G1V(dnl, k)*G1V(dnv, k);\n  \n  \n  float spec = dnl * d * f *vis;\n  return spec;\n}\n\nvec3 calcNormals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.00);\n  return normalize(map(p).mat - vec3(map(p-uv.xyy).mat, map(p-uv.yxy).mat, map(p-uv.yyx).mat));\n}\n\nfloat getao(vec3 p, vec3 n, float h)\n{\n  return clamp(map(p+n*h).mat / h, 0.0, 1.0);\n}\n\nfloat shadow(vec3 p, vec3 l, int stepC, float limit)\n{\n  for(int i = 0; i < stepC; ++i)\n  {\n    float d = map(p).mat;\n    \n    if(d < limit)\n    {\n      return 0.0;\n      break;\n    }\n    if(d > 20.0)\n    {\n     \treturn 1.0;   \n    }\n    \n    p += d * l;\n  }\n  \n   return 1.0;\n}\n\nfloat lines(vec2 uv, float details)\n{\n\tuv *= details;\n    uv = fract(uv) - 0.5;\n    return smoothstep(0.1, 0.15, abs(uv.y)) * smoothstep(0.1, 0.15, abs(uv.x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 light = vec3(4., 15.5, 2.0);\n    \n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n  float commonAngle = 0.5;\n  \n  vec3 ori = vec3(cos(commonAngle) * 15.5, -15.5, sin(commonAngle) * 15.5), target = vec3(0.0);\n  vec3 forward = normalize(target - ori);\n  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n  vec3 up = normalize(cross(forward, right));\n  vec3 dir = normalize(forward + right * uv.x + up * uv.y);\n  vec3 p = ori + 0.5 * dir;\n  \n  vec3 color = vec3(0.0);\n  \n  float shad = 0.0;\n  matter mat = matterInit();\n  float d = 0.0;\n  float RealDistance = 0.0f;\n  for(int i = 0; i < 120; ++i)\n  {\n    mat = map(p);\n    \n    if(mat.mat < 0.001) \n    {\n        if(mat.material == 1) {\n            mat.mat = 0.1;\n\n            //https://www.shadertoy.com/view/Wsy3zm\n        \tvec3 n = calcNormals(p);\n        \tdir = reflect(dir,n);\n        } else {\n            shad = pow(1.0-(d*float(i)/500.0), 2.0);\n        \tbreak;\n        }\n       \n    }\n      \n    color += vec3(1.0, 0.15, 0.0) * gg * (0.0025 + 0.005  * abs(cos(iTime * 0.2)));\n    d+=mat.mat * 0.8;\n    p += mat.mat * dir* 0.8;\n    RealDistance = d;\n  }\n  \n  float rand = pow(rnd(uv), 2.0);\n  \n  // Volumetric\n  const int volumetricSteps = 50;\n  float voldist = 35.0;\n  float stepsize = voldist/float(volumetricSteps);\n  vec3 lr = dir * stepsize;\n  vec3 lp = ori + lr* rand;\n  float stepdist = stepsize* rand;\n  vec3 atcol = vec3(0.0);\n  \n  for(int i = 0; i < volumetricSteps; ++i)\n  {\n    if(stepdist > d)\n    {\n      break;\n    }\n    vec3 lv = light - lp;\n    float ldist = length(lv);\n    lv = normalize(lv);\n    \n    \n    float shadowV = shadow(lp, lv, 20, 0.1);\n    atcol += 0.7/(0.05+ ldist*ldist) * shadowV;\n      \n    lp+=lr;\n    stepdist += stepsize;\n  }\n  \n  float fog = 0.0;\n  if(RealDistance >= 120.0f)\n  {\n      RealDistance = 99.0f;\n  } else {\n      fog = 1.0 - clamp((RealDistance / 100.0), 0.0, 1.0);\n  }\n  \n  \n   vec3 skycolor = mix(vec3(0.0, 0.2, 0.6) * 0.5, mix(vec3(1.0, 0.0, 0.3) * 0.5, vec3(0.0, 0.0, 0.0), pow(1.0-(clamp(uv.y+0.4, 0.0, 1.0)), 8.0) ) , pow(1.0-(clamp(uv.y+0.8, 0.0, 1.0)), 0.7));\n   \n   if(shad >= 0.0 && fog > 0.2)\n  {\n   vec3 FresnelColor = vec3(-0.3);\n      \n    vec3 n = calcNormals(p);\n    float ao = getao(p + n *0.1, n, 0.5) + getao(p + n *0.1, n, 1.0) + getao(p + n *0.1, n, 2.0);\n      ao /= 3.0;\n      \n    vec3 ld = normalize(light);\n    float fresnel = pow( max(0.0, 1.0 + dot(n, dir)), 3.0 );\n    \n    \n    vec3 albedo = vec3(0.3);\n    \n    vec3 lamb = vec3(max(0.0, dot(n, ld)));\n    float spec = ggx(n, dir, ld, 3.0, fresnel);\n\t\n\t\n\n    color += (vec3(1.0) * spec + (lamb * albedo)) * 0.7 * ao;\n\n    color = clamp(color + (FresnelColor * fresnel) * 1.0, vec3(0.0), vec3(1.0));\n\n  }\n  \n  \n\tcolor += pow(1.0 - fog, 8.0) * 0.4 * skycolor;\n \n\tcolor += atcol * pow(0.8, cos(iTime * 0.8) * 1.5 + 0.1);\n\t\n\t\n\t\n\tcolor.x = round(color.x*10000.0) * 0.0001;\n/* \n    this portion of code is useless,where i have to put his, \n    i couldn't get alpha from any buffer, \n    so i had to hide the distance value into red color.\n*/\n\t\n\tcolor.x += ( clamp((length(p-ori)/100.0) * 0.0001, 0.000001, 0.0000999f));\n\n  \n  \n  fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}