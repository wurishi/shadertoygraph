{"ver":"0.1","info":{"id":"fdBGz3","date":"1653472155","viewed":50,"name":"buffer 2 by XNikon","username":"xnikon","description":"CG","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);// / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\nvec3 CAMERA_POS = vec3(0, 1.2, -6);\nconst vec3 Light1_pos = vec3(2, 1, 0);\nconst float Light1_r = 0.5;\nconst vec3 Light1_col = vec3(1,1,0);\nconst float Light1_int = 10.0;\nconst vec3 Light2_pos = vec3(-1, 1.5, 1);\nconst float Light2_r = 0.25;\nconst vec3 Light2_col = vec3(0,1,1);\nconst float Light2_int = 20.0;\nconst float k = 0.1;\nvec3 randDir;\n\nfloat powf(float x, int a) {\n    float q = x;\n    int i = a;\n    while (i-- > 1) q *= x;\n    return a == 0 ? 0.0 : q;\n}\n\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1, 57, 21)) + vec4(0, 57, 21, 78);\n\tvec3 f = cos((p-i)*acos(-1.0))*(-0.5) + 0.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.0 + a)*(1.0 + a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}\n\nstruct Material {\n    float emission;\n    float diffusion;\n    float reflection;\n    float refraction;\n    float n;\n    int spectral_exp;\n    vec3 col;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material m;\n};\n\nstruct Light {\n    Sphere sphere;\n    float intensity;\n};\n\nstruct Triangle {\n    vec3 vertecies[3];\n};\n\nstruct Pyramid {\n    vec3 vertecies[5];\n    Material m;\n};\n\nstruct Scene {\n    Light[2] lights;\n    Pyramid pyramid;\n} scene;\n\nfloat flame(vec3 p)\n{\n    float d = length(vec3(0, 1, 0) - p*vec3(1, 0.7, 1)) - 1.0;\n\treturn d + (noise(p + vec3(0, 5, 0)) + noise(p * 3.0)* 0.5)* 0.25 *(p.y) ;\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n    float k = 64.0;\n\t\n\tfor(int i = 0; i < int(k); i++)\n\t{\n\t\td = min(150.0 - length(p), abs(flame(p))) + eps;\n\t\tp += d * dir;\n\t\tif (d > eps)\n\t\t{\n            glowed = glowed || flame(p) < 0.0;\n\t\t\tglow = glowed ? float(i)/k : 0.0;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nfloat tracePlane(vec3 camPos, vec3 dir, out vec3 N) {\n    float t = (-1.0 - camPos.y)/ dir.y;\n    vec3 worldPos = t * dir + camPos;\n    if (t < 0.0 || dot(worldPos.xz, worldPos.xz) > 100.0) return INF;\n    N = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir, Triangle tr, out vec3 N)\n{\n    const float EPSILON = 0.0000001;\n    vec3 vertex0 = tr.vertecies[0];\n    vec3 vertex1 = tr.vertecies[1];  \n    vec3 vertex2 = tr.vertecies[2];\n    vec3 edge1 = vertex1 - vertex0;\n    vec3 edge2 = vertex2 - vertex0;\n    vec3 h = cross(dir, edge2);\n    float a = dot(edge1, h);\n    if (a > -EPSILON && a < EPSILON) return INF;\n    float f = 1.0/a;\n    vec3 s = pos - vertex0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0) return INF;\n    vec3 q = cross(s, edge1);\n    float v = f * dot(dir, q);\n    if (v < 0.0 || u + v > 1.0) return INF;\n    float t = f * dot(edge2, q);\n    if (t < EPSILON) return INF;\n    vec3 v1 = vertex2 - vertex0;\n    vec3 v2 = vertex1 - vertex0;\n    N = normalize(cross(v1,v2));\n    return t;\n}\n\nfloat tracePyramid(vec3 pos, vec3 dir, Pyramid p, out vec3 N) {\n    Triangle t1 = Triangle(vec3[3](p.vertecies[0], p.vertecies[1], p.vertecies[2]));\n    Triangle t2 = Triangle(vec3[3](p.vertecies[0], p.vertecies[2], p.vertecies[3]));\n    Triangle t3 = Triangle(vec3[3](p.vertecies[0], p.vertecies[3], p.vertecies[4]));\n    Triangle t4 = Triangle(vec3[3](p.vertecies[0], p.vertecies[4], p.vertecies[1]));\n    Triangle t5 = Triangle(vec3[3](p.vertecies[1], p.vertecies[2], p.vertecies[3]));\n    Triangle t6 = Triangle(vec3[3](p.vertecies[3], p.vertecies[4], p.vertecies[1]));\n    Triangle tr[6] = Triangle[6](t1, t2, t3, t4, t5, t6);\n    vec3 tmpN;\n    float t = INF;\n    for (int i = 0; i < tr.length(); i++) {\n        float triangleT = traceTriangle(pos, dir, tr[i], tmpN);\n        if (triangleT < t) {\n            t = triangleT;\n            N = tmpN;\n        }\n    }\n    return t;\n}\n\n\nfloat traceSphere(vec3 camPos, vec3 dir, Sphere s, out vec3 N) {\n    vec3 pos = camPos - s.pos;\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + s.radius * s.radius;\n    if (D < 0.0) return INF;\n    float t = -b - sqrt(D);\n    t = t < 0.0 ? -b + sqrt(D) : t;\n    if (t < 0.0) return INF;\n    N = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceScene(vec3 pos, vec3 dir, out vec3 N, out Material m) {\n    vec3 tmpN;\n    float t = INF;\n    float pyrT = tracePyramid(pos, dir, scene.pyramid, tmpN);\n    if (pyrT < t) {\n        t = pyrT;\n        N = tmpN;\n        m = scene.pyramid.m;\n    }\n    return t;\n}\n\nbool isOccluded(vec3 pos, Light light) {\n    vec3 dir = light.sphere.pos - pos + randDir * light.sphere.radius;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 tmpN;\n    Material tmpM;\n    float t = traceScene(pos + dir * 1e-3, dir, tmpN, tmpM);\n    return t < dist;\n}\n\nvec3 computeLight(vec3 pos, vec3 dir, vec3 N, Material m) {\n    vec3 lightPower = vec3(0);\n    vec3 spectralLight = vec3(0);\n    for (int i = 0; i < scene.lights.length(); i++) {\n        vec3 toLight = scene.lights[i].sphere.pos - pos;\n        float att = isOccluded(pos, scene.lights[i]) ? 0.5 : scene.lights[i].intensity / dot(toLight, toLight);\n        lightPower += max(0.0, dot(N, normalize(toLight))) * att * scene.lights[i].sphere.m.col;\n        spectralLight += powf(max(0.0, dot(dir, reflect(normalize(toLight), N))), m.spectral_exp) * vec3(1) * att;\n    }\n    lightPower += texture(iChannel1, N).rgb * 0.1;\n    return m.col * lightPower + spectralLight;\n}\n\nvec3 refraction(vec3 v, vec3 N, float n1, float n2) {\n    if (dot(v,N) < 0.0) N = -N;\n    float cosA = dot(v, N);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tg = normalize(v - cosA*N);\n    float sinB = sinA/n2 * n1;\n    float cosB = sqrt(1.0 - sinB*sinB);\n    return sinB * tg + cosB * N;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    //init\n    CAMERA_POS = vec3(0, 1.2, -6);\n    float val = 17.5;\n    val = iTime;\n    CAMERA_POS = vec3(6.0 * sin(val / 2.0), 1.2, 6.0 * cos(val / 2.0));\n    vec2 screenUV = fragCoord/iResolution.xy;\n    vec3 randV = vec3(rand(float(iFrame)), rand(float(iFrame +5)), rand(float(iFrame + 15)));\n    randDir = normalize(randV - 0.5);\n    Material emissive = Material(1.0, 0.0, 0.0, 0.0, AIR_N, 0, vec3(0));\n    Material diffusive = Material(0.0, 1.0, 0.0, 0.0, AIR_N, 0, vec3(0));\n    Material reflective = Material(0.0, 0.0, 1.0, 0.0, AIR_N, 0, vec3(0));\n    Material refractive = Material(0.0, 0.0, 0.0, 1.0, GLASS_N, 0, vec3(0));\n    Material glass = Material(0.0, 0.4, 1.0, 1.0, GLASS_N, 50, vec3(1));\n    Material light1_m = emissive;\n    light1_m.col = Light1_col;\n    Material light2_m = emissive;\n    light2_m.col = Light2_col;\n    Light light1 = Light(Sphere(Light1_pos, Light1_r, light1_m), Light1_int);\n    Light light2 = Light(Sphere(Light2_pos, Light2_r, light2_m), Light2_int);\n    Light lights[2] = Light[2](light1, light2);\n    float ang = 0.5;\n    mat2 rot = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    vec2 pyrXZ1 = rot * vec2(1, -1);\n    vec2 pyrXZ2 = rot * vec2(1, 1);\n    vec2 pyrXZ3 = rot * vec2(-1, 1);\n    vec2 pyrXZ4 = rot * vec2(-1, -1);\n    Pyramid pyramid = Pyramid(vec3[5](vec3(0., 1., 0.), vec3(pyrXZ1.x, -0.99, pyrXZ1.y),\n            vec3(pyrXZ2.x, -0.99, pyrXZ2.y), vec3(pyrXZ3.x, -0.99, pyrXZ3.y),\n            vec3(pyrXZ4.x, -0.99, pyrXZ4.y)), glass);\n    scene.lights = lights;\n    scene.pyramid = pyramid;\n    \n    //calculate coord and viewVec\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randV.xy - 0.5) * 2.0)/iResolution.x;\n    vec3 front = normalize(vec3(-CAMERA_POS));\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up* uv.y);\n    \n    //trace\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    float n1 = AIR_N;\n        float n2 = AIR_N;\n    vec3 col = vec3(0);\n    \n    \n    for (int j = 0; j < 10; j++) {\n        float t = INF;\n        bool intersect;\n        vec3 N;\n        vec3 tmpN;\n        \n        Material material;\n        \n        \n        //trace lights(models)\n        for (int i = 0; i < lights.length(); i++) {\n            float lightT = traceSphere(curPos, curDir, lights[i].sphere, tmpN);\n            if (lightT < t) {\n                t = lightT;\n                N = tmpN;\n                material = lights[i].sphere.m;\n            }\n        }\n        \n        //traceScene\n        Material tmpM;\n        float sceneT = traceScene(curPos, curDir, tmpN, tmpM);\n        if (sceneT < t) {\n            t = sceneT;\n            N = tmpN;\n            material = tmpM;\n        }\n        \n        vec3 worldPos = t * curDir + curPos;\n        //trace plane\n        float planeT = tracePlane(curPos, curDir, tmpN);\n        if (planeT < t) {\n            t = planeT;\n            N = tmpN;\n            worldPos = t * curDir + curPos;\n            material = diffusive;\n            material.col = texture(iChannel0, worldPos.xz * 0.1).rgb;\n        }\n        \n        //calculate color\n        bool isEmissive = material.emission > 0.0;\n        bool isDiffusive = material.diffusion > 0.0;\n        bool isReflective = material.reflection > 0.0;\n        bool isRefractive = material.refraction > 0.0;\n        if (isReflective) {\n            n1 = n2;\n            n2 = material.n;\n        }\n        float R = powf((n1-n2)/(n1+n2), 2);\n        bool reflAndRefr = isReflective && isRefractive;\n        isReflective = (reflAndRefr && randV.x * 0.2 < R) || (!reflAndRefr && isReflective);\n        isRefractive = (reflAndRefr && !isReflective) || (!reflAndRefr && isRefractive);\n        \n        if (isEmissive) {\n            col +=  material.col * material.emission * k;\n        }\n        else if (isDiffusive) {\n            col += computeLight(worldPos, curDir, N, material) * material.diffusion * k;\n        }\n        if (isReflective) {\n            curDir = reflect(curDir,N);\n            curPos = worldPos + curDir * 1e-3;\n        }\n        else if (isRefractive) {\n            curDir = refraction(curDir, N, n1, n2);\n            curPos = worldPos + curDir * 1e-3;\n            \n            if (n1 == AIR_N && n2 == GLASS_N) {\n                vec4 p = raymarch(curPos + vec3(2.5, 7, -13), curDir);\n                float glow = p.w;\n                vec3 flamecol = mix( vec3(0.1, 0.5, 1), vec3(1, 0.5, 0.1), p.y * 0.022 + 2.5) ;\n                col += mix(vec3(0), flamecol, pow(glow * 2.0, 4.0));\n            }\n        }\n\n        if (t == INF) {\n            col += k * texture(iChannel1, curDir).rgb;\n        }\n    }\n        \n    fragColor = vec4(col, 1.0);\n             \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv) ;//+ texture(iChannel1,uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}