{"ver":"0.1","info":{"id":"MslcRj","date":"1488994345","viewed":296,"name":"Ray tracing - refraction","username":"MulattoKid","description":"Implementation of refraction from the ground up","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAY_T_MIN 0.0001\n#define RAY_T_MAX 1000.0\n#define ASPECT_RATIO iResolution.x / iResolution.y\n#define FOV 70.0\n\n//To change what material the sphere is made of (or the area around it), change the paramateres that are passed into\n//refractionDirection() which is called in intersectSphere()\n#define AIR 1.0002926\n#define WATER 1.333\n#define OLIVE_OIL 1.47\n#define WINDOW_GLASS 1.52\n#define CUBIX_ZIRCONIA 2.15\n#define DIAMOND 2.42\n\n//Camera\nvec3 origin = vec3(0.0, 0.0, -2.0);\nvec3 at = vec3(0.0, 0.0, 0.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\n\n//Ray\nvec3 direction = vec3(0.0);\nfloat t = RAY_T_MAX;\n\n//Sphere\nvec3 center = vec3(0.0, 0.0, 0.0);\nfloat radius = 0.5;\n\nvec3 intersectionPoint(vec3 rayOrigin, float t)\n{\n\treturn rayOrigin + (direction * t);\n}\n\nvec3 refractionDirection(vec3 normal, vec3 incidentVector, float incidentAngle, float refractiveIndexFrom, float refractiveIndexTo)\n{\n    float angleOut = asin((refractiveIndexFrom / refractiveIndexTo) * sin(incidentAngle));\n    vec3 parallelVector = (-incidentVector) + normal * (dot(incidentVector, normal));\n    parallelVector = parallelVector / sin(incidentAngle); //normalize\n    vec3 direction = (-normal * cos(angleOut)) - (parallelVector * sin(angleOut));\n    \n    return direction;\n}\n\nvec4 intersectColor()\n{\n    return texture(iChannel0, direction * vec3(1.0, -1.0, 1.0));\n}\n\nvec4 intersectSphere(vec3 origin)\n{\n\t//Transform the ray so we can consider origin-centered sphere\n\tvec3 localOrigin = origin - center;\n\n\t//Calculate quadratic coefficients\n\tfloat a = pow(abs(length(direction)), 2.0);\n\tfloat b = 2.0 * dot(direction, localOrigin);\n\tfloat c = pow(abs(length(localOrigin)), 2.0f) - sqrt(radius);\n\n\t//Check whether we intersect\n\tfloat discriminant = pow(abs(b), 2.0) - (4.0 * a * c);\n\tif (discriminant < 0.0)\n\t\treturn intersectColor();\n\n\t//Find the two points of intersection, t1 = close, t2 = far, t1 might be equal to t2 if there is only one solution\n\tfloat t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n\tif (t1 > RAY_T_MIN && t1 < RAY_T_MAX)\n\t\tt = t1;\n\telse\n\t\treturn intersectColor();\n\n    //Calculate necessary elements for reflection ray    \n    vec3 intersectionPointIn = intersectionPoint(origin, t);\n    vec3 normalAtPointIn = normalize((intersectionPointIn - center) / radius);\n    \n    //Ray inside sphere\n    float incidentAngle = acos(dot(direction, normalAtPointIn));\n    direction = refractionDirection(normalAtPointIn, direction, incidentAngle, AIR, CUBIX_ZIRCONIA);\n    vec3 toCenter = normalize(center - intersectionPointIn);\n    vec3 positionOffset = toCenter * 0.000001;\n    vec3 newPosition = intersectionPointIn + positionOffset;\n    \n    //Calculate quadratic coefficient - no need to test\n\ta = pow(abs(length(direction)), 2.0);\n\tb = 2.0 * dot(direction, newPosition);\n\tc = pow(abs(length(newPosition)), 2.0) - sqrt(radius);\n\tdiscriminant = pow(abs(b), 2.0) - (4.0 * a * c);\n\tt = (-b + sqrt(discriminant)) / (2.0 * a); //why + and not -\n    \n    vec3 newIntersectionPoint = intersectionPoint(newPosition, t);     \n    vec3 newNormalAtPoint = normalize((center - newIntersectionPoint) / radius); //why center-newIntersectionPoint??\n\tfloat newIncidentAngle = acos(dot(direction, newNormalAtPoint));\n    direction = refractionDirection(newNormalAtPoint, direction, newIncidentAngle, CUBIX_ZIRCONIA, AIR);\n    \n    return intersectColor();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = vec2(fragCoord.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    float h = tan(FOV);\n    float w = h * ASPECT_RATIO;\n    float d = 0.5;\n\t\n    direction = normalize(center - origin);\n\tdirection = normalize((direction * d) + (screenCoord.x * w * normalize(cross(direction, up))) + (screenCoord.y * h * up));\n    vec4 reflectColor = intersectSphere(origin);    \n    \n\tfragColor = reflectColor;\n}\n","name":"Image","description":"","type":"image"}]}