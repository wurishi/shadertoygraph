{"ver":"0.1","info":{"id":"Xt23zy","date":"1430056585","viewed":544,"name":"Two floating cubes","username":"luutifa","description":"The only thing I dislike here are the speculars on the floor plane, but I have yet no idea how to handle different materials and textures and mapping for different objects.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#ifdef GL_ES\n    precision highp float;\n#endif\n\n#define ITR 40\n#define EPSILON 0.001\n#define PI 3.14159265\n#define NUM_LIGHTS 4\n#define MAX_MARCH_LENGTH 30.0\n\n#define TRY_DRAW_LIGHTSOURCES //comment to hide light sources\n\n//-----------------------------------------------------------------------------\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n//-----------------------------------------------------------------------------\n\nfloat plane(vec3 p) {\n    return p.y;\n}\n\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos) -r;\n}\n\nfloat tunnel(vec3 pos, float r) {\n    return -(length(vec3(pos.xy,0.0))-r);\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 cam = vec3(0.0, 3.0, 0.0);\nvec3 lights[NUM_LIGHTS*2];\nvec3 normal;\n\nfloat scene(vec3 pos) {\n    return min(\n        plane(pos),\n        min(\n            box(getYRotMat(iTime*0.33)*getXRotMat(iTime)*(pos-vec3(1.4, 1.3+sin(iTime)*0.5, 5.0-sin(iTime*0.2)*0.2)), vec3(0.4, 0.4, 0.4)),\n            box(getYRotMat(iTime*0.6)*getXRotMat(iTime*0.4)*(pos-vec3(-1.4, 1.0+cos(iTime)*0.3, 5.0)), vec3(0.4, 0.4, 0.4))\n        )\n    );\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p+e.xyy), scene(p+e.yxy), scene(p+e.yyx)) - scene(p)) / e.x;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    float h;\n    for(int i=0;i<ITR;i++)\n    {\n        h = scene(ro + rd*t);\n        if(h<EPSILON)\n            return 0.0;\n        t += h;\n        res = min(res, k*h/t);\n        if(t > maxt)\n            break;\n    }\n    return res;\n}\n\nvec3 light(vec3 pos, vec3 light, vec3 color) {\n    float nmLight = max(dot(normalize(pos-light), -normal), 0.0);\n    return (1.0/length(pos-light)) * nmLight * softShadow(pos, normalize(light-pos), 0.1, length(light-pos), 18.0) * color * texture(iChannel0, pos.xz*0.2).rgb + pow(nmLight, 200.0)*color;\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 spos) {\n    vec3 l=vec3(0.0);\n    for (int i=0; i<NUM_LIGHTS; i++) {\n        l += light(pos, lights[i*2], lights[i*2+1]);\n        \n        #ifdef TRY_DRAW_LIGHTSOURCES\n            if (length(pos-spos) > length(lights[i*2]-spos))\n                l += pow(max(dot(normalize(spos-lights[i*2]), -dir), 0.0), 2000.0)*lights[i*2+1];\n        #endif\n    }\n    return l;\n}\n\nvec3 march(vec3 origin, vec3 direction) {\n    float t;\n    float dist;\n    for (int i=0; i<ITR; i++) {\n        dist = scene(origin+direction*t);\n        t += dist;\n        if (t > MAX_MARCH_LENGTH)\n            break;\n    }\n    return origin + direction*t;\n}\n\nvec3 getImage(vec2 screenPos) {\n    vec3 screenDir = getXRotMat(-0.5)*normalize(vec3(screenPos*0.5, 1.0));\n    vec3 pos = march(cam, screenDir);\n    normal = normalize(grad(pos)); //Global normal, declared after distfield tools\n    vec3 reflectDir = normalize(reflect(screenDir, normal));\n    return lighting(pos, screenDir, cam)*0.7 + lighting(march(pos+reflectDir*EPSILON, reflectDir), reflectDir, pos)*0.3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lights[0] = vec3(sin(iTime*0.3+(PI/3.0))*3.0, 2.0, 6.0);\n    lights[1] = vec3(1.0, 1.0, 0.6)*3.0;\n    \n    lights[2] = vec3(sin(iTime*0.5)*4.0, 2.5+cos(iTime*0.2)*0.4, 3.5+cos(iTime*0.5)*6.0);\n    lights[3] = vec3(1.0, 0.5, 0.0)*4.0;\n    \n    lights[4] = vec3(sin(iTime*0.3+(PI/3.0))*1.0, 3.0, 4.5);\n    lights[5] = vec3(1.0, 1.0, 0.8)*0.6;\n    \n    lights[6] = vec3(sin(iTime*0.5)*1.0, 5.5+cos(iTime*0.2)*1.4, cos(iTime*0.6));\n    lights[7] = vec3(1.0, 0.7, 0.6)*4.0;\n    \n    //lights[4] = vec3(0.0, 5.0+sin(iTime*0.2)*2.0, 2.0);\n    //lights[5] = vec3(0.6, 0.6, 0.8);\n    \n    vec2 pos = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    fragColor = vec4(vec3(getImage(pos)), 1.0);\n}\n","name":"","description":"","type":"image"}]}