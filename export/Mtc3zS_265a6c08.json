{"ver":"0.1","info":{"id":"Mtc3zS","date":"1471108060","viewed":4439,"name":"Twisted Disco World","username":"zguerrero","description":"Playing around with distance field, trying some random stuff.\nYou can click and drag to look around!","likes":89,"published":1,"flags":32,"usePreview":0,"tags":["ray","marching","glow","distance","field","disco","world","twist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 dirtTex = texture(iChannel2, vec2(uv.x*iResolution.x/iResolution.y, uv.y)*1.5);\n    float dirt = (dirtTex.x+dirtTex.y+dirtTex.z)/3.0;\n    vec4 c = clamp(texture(iChannel0, uv),0.0, 1.0);\n    vec4 glow = clamp(texture(iChannel1, uv),0.0, 1.0);\n    \n    float vign = length(uv - vec2(0.5));\n    \n\tfragColor = c + glow + glow*dirt*dirt*dirt*vign*2.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float EPSILON = 0.001;\nconst float pi = 3.14159265359;\nfloat anmSpeed = 2.0;\nfloat scrollSpeed = 2.0;\nfloat squareHeight = 0.45;\nfloat squareClamp = 0.5;\nfloat squareSize = 10.0;\nfloat squareProportion = 0.7;\nfloat twistAmount = 2.0;\nfloat twistSpeed = 0.2;\nfloat reflAmount = 1.0;\nfloat reflSharpness = 0.3;\nfloat reflFresnel = 1.0;\nfloat specAmount = 300.0;\nfloat specPow = 10.0;\nfloat selfIllum = 0.5;\nfloat diffuseMul = 0.0;\nfloat lightAtten = 0.5;\nfloat lightMul = 1.0;\nvec3 color1 = vec3(0.0,0.0,0.1);\nvec3 color2 = vec3(0.25,1.0,0.25);\nvec3 lightColor = vec3(1.0,1.0,1.0);\nfloat fogDensity = 0.5;\nfloat fogDistance = 0.5;\nvec3 skyColor1 = vec3(0.0,0.0,0.0);\nvec3 skyColor2 = vec3(0.5,0.5,2.0); \nfloat centerSize = 0.01;\n\n\nfloat rand2(vec2 uv)\n{   \n    float X = fract(sin(dot(uv ,vec2(12.9898,78.233))) * 43758.5453);   \n    float Y = fract(sin(dot(uv ,vec2(12.9898,78.233))*2.0) * 43758.5453);\n    \n    return (X+Y)/2.0;\n} \n\n//https:www.shadertoy.com/view/XsBXWt\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 calcSquares(vec2 uv, vec3 lightPos)\n{\n    vec2 flooruv = floor(uv);\n    float r1 = rand2(flooruv - vec2(5.0,3.0));\n    float r2  = rand2(flooruv + vec2(4.0,7.0));\n    float r3  = rand2(flooruv + vec2(15.0,-50.0));\n    \n    float r = mix(mix(r1, r2, sin(iTime*anmSpeed)*0.5+0.5), \n        r3, sin(iTime*anmSpeed*2.4)*0.5+0.5)\n        +(1.0 - clamp(length(lightPos),0.0,1.0))*0.35;\n    \n    vec2 fractuv = clamp(sin(fract(uv)*pi),0.0, squareClamp)*r*squareHeight;\n    float sq = fractuv.x*fractuv.y*0.5;\n    \n    return vec2(sq, smoothstep(squareProportion, 1.0, r));  \n}\n\n//float sdPlane( vec3 p, vec4 n )\n//{\n//return dot(vec4(p, 1.0), n);\n//}\n\nvec2 distfunc(vec3 pos, vec3 lightPos)\n{\n    pos.xy *= rot(pos.z*sin(iTime*twistSpeed)*twistAmount);\n    vec2 squares = calcSquares(pos.xz*squareSize + vec2(0.0, iTime*scrollSpeed), lightPos);\n    //Simplified calcule thanks to Shane's advice\n    //float p1 = sdPlane(pos - vec3(0.0, squares.x, 0.0), normalize(vec4(0.0,1.0,0.0,0.2)));\n    //float p2 = sdPlane(pos + vec3(0.0, squares.x, 0.0), normalize(vec4(0.0,-1.0,0.0,0.2)));\n    \n    return vec2(0.2 - abs(pos.y) - squares.x, squares.y);\n}\n\nvec3 rayMarch(vec3 rayDir, vec3 cameraOrigin, vec3 lightPos)\n{\n    const int MAX_ITER = 50;\n\tconst float MAX_DIST = 10.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tvec2 dist = vec2(EPSILON, 0.0);\n    \n    for(int i = 0; i < MAX_ITER; i++)\n\t{\n\t\tdist = distfunc(pos, lightPos - pos);\n\t\ttotalDist += dist.x;\n\t\tpos += dist.x*rayDir;\n        \n        if(dist.x < EPSILON || totalDist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return vec3(dist.x, totalDist, dist.y);\n}\n\nvec3 skyBox(vec3 rayDir)\n{\n    float circle = mix(abs(rayDir.y), length(rayDir.xy), abs(sin(iTime*twistSpeed)));\n    vec3 center = mix(skyColor2, skyColor1, smoothstep(circle,0.0,centerSize));\n    vec3 skyColor = mix(skyColor2, skyColor1, circle);\n    return skyColor*0.25 + center;\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 calculateNormals(vec3 pos, vec3 lightPos)\n{\n\tvec2 eps = vec2(0.0, EPSILON*2.0);\n\tvec3 n = normalize(vec3(\n\tdistfunc(pos + eps.yxx, lightPos).x - distfunc(pos - eps.yxx, lightPos).x,\n\tdistfunc(pos + eps.xyx, lightPos).x - distfunc(pos - eps.xyx, lightPos).x,\n\tdistfunc(pos + eps.xxy, lightPos).x - distfunc(pos - eps.xxy, lightPos).x));\n\treturn n;\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat calcReflexion(vec3 pos, vec3 rayDir, float mint, float tmax, vec3 lightPos)\n{\n\tfloat res = 0.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tvec2 dist = distfunc( pos + rayDir*t, lightPos);\n        res = mix(res, dist.y, float(i)*(reflSharpness/20.0));\n        t += clamp( dist.x, 0.02, 0.05 );\n        if( dist.x < EPSILON || t > tmax ) break;\n    }\n    return res;\n\n}\n\nvec3 lighting(vec3 pos, vec3 rayDir, float c, vec3 lightPos)\n{\n    vec3 n = calculateNormals(pos, lightPos);\n    \n    vec3 diffuseColor = mix(color1, color2, c);\n    \n    float atten = 1.0 - clamp(length(lightPos*lightAtten),0.0, 1.0);\n\n\tfloat diff = max(0.0, dot(normalize(lightPos), n))*atten;\n\tfloat fresnel = smoothstep(0.0, reflFresnel, 1.0 - dot(n, -rayDir));\n\tvec3 r = reflect(normalize(rayDir), n);\n    float refl = calcReflexion(pos + n*0.15, r, 0.01, 20.0, lightPos);\n    vec3 reflColor = mix(color1, color2, refl);\n\tfloat spec = pow(max (0.0, dot (r, normalize(lightPos))), specPow);\n\n\tvec3 res = diffuseColor*diffuseMul;\n\tres += diff*lightColor*lightMul*diffuseColor;\n    res += spec*lightColor*diff*fresnel*specAmount;\n    res\t+= reflColor*fresnel*reflAmount;\n    res += diffuseColor*selfIllum;\n \n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    vec3 cameraOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 cameraTarget = cameraOrigin;\n    \n    if(iMouse.z > 0.5)\n    {\n         vec2 mInput = vec2((iMouse.x/iResolution.x)*2.0-1.0, (iMouse.y/iResolution.y)*2.0-1.0)*10.0;\n\t\t cameraTarget += cameraOrigin + vec3(cos(mInput.x), mInput.y, sin(mInput.x));\n    }\n    else\n    {\n        cameraTarget += vec3(0.0,0.0,1.0);\n    }\n    \n\tvec2 screenPos = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n\tmat3 cam = setCamera(cameraOrigin, cameraTarget, 0.0 );\n   \tvec3 lightPos = cameraOrigin;\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos.xy,1.0) );\n    vec3 dist = rayMarch(rayDir, cameraOrigin, lightPos);\n    \n    vec3 sky = skyBox(rayDir);\n    vec3 res;\n\tif(dist.x < EPSILON)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        float fog = clamp(dist.y*fogDensity-fogDistance, 0.0, 1.0);\n        res = mix(lighting(pos, rayDir, dist.z, lightPos - pos), sky, fog);\n    }\n    else\n    {\n        res = sky;       \n    }\n    \n\tfragColor = vec4(res, 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Bloom Blur Pass1\nvec2 sampleDist = vec2(3.0,3.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex /= 25.0;\n    \n\tfragColor = tex;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Bloom Blur Pass2\nvec2 sampleDist = vec2(6.0,6.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex /= 25.0;\n    \n\tfragColor = tex;\n}","name":"Buf C","description":"","type":"buffer"}]}