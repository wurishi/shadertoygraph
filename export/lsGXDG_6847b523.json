{"ver":"0.1","info":{"id":"lsGXDG","date":"1466272991","viewed":230,"name":"Flappy Yellow Submarine","username":"iguillen","description":"Just the 100000th attempt at porting the classic from 3 years ago.\n\nTry to avoid the obstacles.\nSpace to jump.\nIntro to reset.\n\nAuthor: Ibon Guillen","likes":3,"published":1,"flags":112,"usePreview":0,"tags":["game","flappy","pgatr","submarine","dontworthyourtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsf3DX","filepath":"https://soundcloud.com/daxbillybob/beatles-yellow-submarine-8-bit","previewfilepath":"https://soundcloud.com/daxbillybob/beatles-yellow-submarine-8-bit","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ibon Guillen - 2016\n// WTFPL License - v2\n//\n// Code extracted from third sources\n// can have it's own licence\n\n// Rendering\n\n// Heavily inspired by the work of Inigo Quilez\n// Bricks game: https://www.shadertoy.com/view/MddGzf\n// Raymarching: https://www.shadertoy.com/view/Xds3zN\n\n//---------------------------------------------------------------------------------//\n\n// Constants\nconst vec3 subColor  = vec3(1.0, 1.0, 0.0);\nconst vec3 obstColor = vec3(0.8, 0.5, 0.2);\n\nconst float distSub  = 0.2;\n\n// Game states\n#define STARTED  0.0\n#define PLAYING  1.0\n#define FINISHED 2.0\n\n//---------------------------------------------------------------------------------//\n\n// Storage addresses\nconst vec2 txGameState = vec2(0.0, 0.0);\nconst vec2 txGameScore = vec2(1.0, 0.0);\nconst vec2 txSubmarine = vec2(2.0, 0.0);\n\nconst vec2 txObstacle1 = vec2(3.0, 0.0);\nconst vec2 txObstacle2 = vec2(4.0, 0.0);\nconst vec2 txObstacle3 = vec2(5.0, 0.0);\nconst vec2 txObstacle4 = vec2(6.0, 0.0);\nconst vec2 txObstacle5 = vec2(7.0, 0.0);\nconst vec2 txObstacle6 = vec2(8.0, 0.0);\nconst vec2 txObstacle7 = vec2(9.0, 0.0);\n\n// Storage and load functions\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//---------------------------------------------------------------------------------//\n\n// Read Worley values\n\nvec3 worleyColor( in vec2 uv )\n{\n    return texture( iChannel1, uv ).xyz;\n}\n\n//---------------------------------------------------------------------------------//\n\n// Read Game values\n\nvec3 gameColor( in vec2 uv )\n{\n    return texture( iChannel2, uv ).xyz;\n}\n\n//---------------------------------------------------------------------------------//\n\n// Drawing time\n// From: https://www.shadertoy.com/view/MddGzf\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    \n    if( digitID>0.0 && digitID<maxDigits ) {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n//---------------------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 outColor = vec3(0.0);\n    \n    //---------------------------------------------------//\n    \n    // Load game state\n    vec2  gameState = loadValue( txGameState ).xy;\n    float state     = gameState.x;\n    \n    vec2  gameScore = loadValue( txGameScore ).xy;\n    float points    = gameScore.x;\n    \n    //---------------------------------------------------//\n    \n    // Drawing\n    \n    // Water\n    {\n    \toutColor = worleyColor( uv ); \n    }\n    \n    // Game\n    {\n        vec3 game = gameColor( uv );\n        \n        if (game != vec3(0.0)) {\n    \t\toutColor = game.xyz; \n        }\n    }\n    \n    // Check end game\n    if (state == FINISHED) {\n         outColor = mix( outColor, vec3(1.0,0.5,0.2), 0.6);\n    }\n    \n    // Score\n    {\n        float f = PrintInt( (uv - vec2(-0.005,0.9))*20.0, points );\n        outColor = mix( outColor, vec3(1.0,1.0,1.0), f );\n    }\n    \n    //---------------------------------------------------//\n    \n    fragColor = vec4(outColor, 1.0);\n    //fragColor = texture( iChannel0, uv );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Ibon Guillen - 2016\n// WTFPL License - v2\n//\n// Code extracted from third sources\n// can have it's own licence\n\n// Gameplay Logic\n\n// Heavily inspired by the work of Inigo Quilez\n// https://www.shadertoy.com/view/MddGzf\n\n//---------------------------------------------------------------------------------//\n\n// Constants\nconst float gameSpeed =  1.2;\n\nconst float gravity   = 0.0001;\nconst float jump      = 0.0050;\n\nconst float obstSpeed = 0.005;\n\nconst float numObst   = 7.0;\nconst float disObst   = 0.65;\n\nconst float subHeight = 0.08;\nconst float subWidth  = 0.1;\nconst float subDist   = 0.2;\n\nconst float sizeObst     = 0.1;\nconst float apertureObst = 0.4;\n\nconst float heightObst1 = 0.2;\nconst float heightObst2 = 0.4;\nconst float heightObst3 = 0.6;\nconst float heightObst4 = 0.4;\nconst float heightObst5 = 0.6;\nconst float heightObst6 = 0.4;\nconst float heightObst7 = 0.6;\n\n// Game states\n#define NULL    -1.0\n#define STARTED  0.0\n#define PLAYING  1.0\n#define FINISHED 2.0\n\n//---------------------------------------------------------------------------------//\n\n// Storage addresses\nconst vec2 txGameState = vec2(0.0, 0.0);\nconst vec2 txGameScore = vec2(1.0, 0.0);\nconst vec2 txSubmarine = vec2(2.0, 0.0);\n\nconst vec2 txObstacle1 = vec2(3.0, 0.0);\nconst vec2 txObstacle2 = vec2(4.0, 0.0);\nconst vec2 txObstacle3 = vec2(5.0, 0.0);\nconst vec2 txObstacle4 = vec2(6.0, 0.0);\nconst vec2 txObstacle5 = vec2(7.0, 0.0);\nconst vec2 txObstacle6 = vec2(8.0, 0.0);\nconst vec2 txObstacle7 = vec2(9.0, 0.0);\n\n// Storage and load functions\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//---------------------------------------------------------------------------------//\n\n// Key addresses\nconst float KEY_SPACE  = 32.5/256.0;\nconst float KEY_RETURN = 13.5/256.0;\n\nconst float KEY_LEFT   = 37.5/256.0;\nconst float KEY_UP     = 38.5/256.0;\nconst float KEY_RIGHT  = 39.5/256.0;\nconst float KEY_DOWN   = 40.5/256.0;\n\n// Read key functions\n\nfloat getKey(float key) {\n    return texture( iChannel1, vec2(key,0.25) ).x;\n}\n\n//---------------------------------------------------------------------------------//\n\nvoid checkDist(inout float obstDist, inout float obstScore, inout float points)\n{\n    // Score a point\n    if (obstDist < subDist && obstScore == 1.0) {\n    \tpoints += 1.0;\n        obstScore = 0.0;\n    }\n    \n    // Reset obstacle\n    if (obstDist < -disObst) {\n        obstDist = (numObst - 1.0) * disObst;\n        obstScore = 1.0;\n    }\n}\n\n//---------------------------------------------------------------------------------//\n\nfloat checkColision(in vec2 obstPos, in float subPos)\n{\n\tfloat maxSubX = subDist + subHeight/2.0 ;\n    float minSubX = subDist - subWidth - subHeight/2.0;\n    \n    float maxObstX = obstPos.x + sizeObst/3.0;\n    float minObstX = obstPos.x - sizeObst/3.0;\n    \n    if ((maxSubX > minObstX || minSubX > maxObstX) && minSubX < maxObstX ) {\n        float maxSubY = subPos + subHeight/2.0 + subHeight/12.0;\n        float minSubY = subPos - subHeight/2.0 - subHeight/12.0;;\n        \n        float maxObstY = obstPos.y + apertureObst/2.0 - sizeObst/3.0;\n    \tfloat minObstY = obstPos.y - apertureObst/2.0 + sizeObst/3.0;\n        \n        if (maxSubY > maxObstY || minSubY < minObstY) {\n            return 1.0;\n        }\n    }\n    \n    return 0.0;\n}\n\n\n//---------------------------------------------------------------------------------//\n\n// Read Game values\n\nvec3 gameColor( in vec2 uv )\n{\n    return texture( iChannel2, uv ).xyz;\n}\n\n//---------------------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x > 10.0 || fragCoord.y > 1.0 ) discard;\n    \n    //---------------------------------------------------//\n    \n    // Load game\n    vec2  gameState = loadValue( txGameState ).xy;\n    float state     = gameState.x;\n    \n    vec2  gameScore = loadValue( txGameScore ).xy;\n    float points    = gameScore.x;\n    \n    // Load submarine state\n    vec2  submarine    = loadValue( txSubmarine ).xy;\n    float subPosition  = submarine.x;\n    float subVelocity  = submarine.y;\n    \n    // Load obstacles state\n    vec2  obstacle1     = loadValue( txObstacle1 ).xy;\n    float obst1Position = obstacle1.x;\n    float obst1Score    = obstacle1.y;\n    \n    vec2  obstacle2     = loadValue( txObstacle2 ).xy;\n    float obst2Position = obstacle2.x;\n    float obst2Score    = obstacle2.y;\n    \n    vec2  obstacle3     = loadValue( txObstacle3 ).xy;\n    float obst3Position = obstacle3.x;\n    float obst3Score    = obstacle3.y;\n    \n    vec2  obstacle4     = loadValue( txObstacle4 ).xy;\n    float obst4Position = obstacle4.x;\n    float obst4Score    = obstacle4.y;\n    \n    vec2  obstacle5     = loadValue( txObstacle5 ).xy;\n    float obst5Position = obstacle5.x;\n    float obst5Score    = obstacle5.y;\n    \n    vec2  obstacle6     = loadValue( txObstacle6 ).xy;\n    float obst6Position = obstacle6.x;\n    float obst6Score    = obstacle6.y;\n    \n    vec2  obstacle7     = loadValue( txObstacle7 ).xy;\n    float obst7Position = obstacle7.x;\n    float obst7Score    = obstacle7.y;\n    \n    //---------------------------------------------------//\n    \n    // Get user input\n    float spaceKey = getKey( KEY_SPACE );\n    float introKey = getKey( KEY_RETURN );\n\n    //---------------------------------------------------//\n    \n    // Avoid restarting the game\n    if ( state == STARTED ) {\n        state = PLAYING;\n    }\n    \n    // Reset\n    if ( iFrame == 0 || introKey == 1.0 ) {\n    \tstate = STARTED;\n    }\n    \n    if ( state == STARTED ) {\n        // Submarine\n        subPosition = 0.5;\n        subVelocity = 0.0;\n        \n        // Obstacles\n        obst1Position = disObst;\n        obst1Score    = 1.0;\n        \n        obst2Position = obst1Position + disObst;\n        obst2Score    = 1.0;\n        \n        obst3Position = obst2Position + disObst;\n        obst3Score    = 1.0;\n        \n        obst4Position = obst3Position + disObst;\n        obst4Score    = 1.0;\n        \n        obst5Position = obst4Position + disObst;\n        obst5Score    = 1.0;\n        \n        obst6Position = obst5Position + disObst;\n        obst6Score    = 1.0;\n        \n        obst7Position = obst6Position + disObst;\n        obst7Score    = 1.0;\n        \n        // Game state\n        points = 0.0;\n    }\n    \n    //---------------------------------------------------//\n    \n    if ( state == PLAYING ) {\n        // Check colisions\n        vec2 pos1 = vec2(obst1Position, heightObst1);\n        \n        if (checkColision(pos1, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        vec2 pos2 = vec2(obst2Position, heightObst2);\n        \n        if (checkColision(pos2, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        vec2 pos3 = vec2(obst3Position, heightObst3);\n        \n        if (checkColision(pos3, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        vec2 pos4 = vec2(obst4Position, heightObst4);\n        \n        if (checkColision(pos4, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        vec2 pos5 = vec2(obst5Position, heightObst5);\n        \n        if (checkColision(pos5, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        vec2 pos6 = vec2(obst6Position, heightObst6);\n        \n        if (checkColision(pos6, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        vec2 pos7 = vec2(obst7Position, heightObst7);\n        \n        if (checkColision(pos7, subPosition) == 1.0) {\n            state = FINISHED;\n        }\n        \n        // Check boundaries\n        if (subPosition > 1.0 || subPosition < 0.0) {\n            state = FINISHED;\n        }\n    }\n    \n    //---------------------------------------------------//\n    \n    // Game logic\n    if ( state == PLAYING ) {\n        // Submarine\n        \n        // Update position\n        subPosition += subVelocity*gameSpeed;\n        \n        // Update velocity\n        subVelocity -= gravity;\n        \n        if (spaceKey == 1.0) {\n        \tsubVelocity = jump;\n        }\n        \n        // Obstacles\n        obst1Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst1Position, obst1Score, points);\n        \n        obst2Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst2Position, obst2Score, points);\n        \n        obst3Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst3Position, obst3Score, points);\n        \n        obst4Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst4Position, obst4Score, points);\n        \n        obst5Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst5Position, obst5Score, points);\n        \n        obst6Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst6Position, obst6Score, points);\n        \n        obst7Position -= obstSpeed*gameSpeed;\n        \n        checkDist(obst7Position, obst7Score, points);\n    }\n    \n    //---------------------------------------------------//\n    \n\t// store game state\n    fragColor = vec4(0.0);\n \n    if (state == STARTED) {\n    \tstoreValue( txGameState, vec4(PLAYING, 0.0, 0.0, 0.0), fragColor, fragCoord );\n    } else if (state == FINISHED) {\n        storeValue( txGameState, vec4(FINISHED, 0.0, 0.0, 0.0), fragColor, fragCoord );\n    }\n    \n    storeValue( txGameScore, vec4(points, 0.0,  0.0, 0.0), fragColor, fragCoord );\n    \n    storeValue( txSubmarine, vec4(subPosition, subVelocity, 0.0, 0.0), fragColor, fragCoord );\n    \n    storeValue( txObstacle1, vec4(obst1Position, obst1Score, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txObstacle2, vec4(obst2Position, obst2Score, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txObstacle3, vec4(obst3Position, obst3Score, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txObstacle4, vec4(obst4Position, obst4Score, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txObstacle5, vec4(obst5Position, obst5Score, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txObstacle6, vec4(obst6Position, obst6Score, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txObstacle7, vec4(obst7Position, obst7Score, 0.0, 0.0), fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Ibon Guillen - 2016\n// WTFPL License - v2\n//\n// Code extracted from third sources\n// can have it's own licence\n\n// Worley pattern\n// Inspired by: https://iquilezles.org/articles/voronoilines\n// And its implementation: https://www.shadertoy.com/view/ldl3W8\n\n//---------------------------------------------------------------------------------//\n\n// Constants\n\nconst vec3 inColor     = vec3(  0.0/255.0, 125.0/255.0, 255.0/255.0);\nconst vec3 borderColor = vec3(102.0/255.0, 255.0/255.0, 255.0/255.0);\n\nconst float numCells   = 8.0;\n\n//---------------------------------------------------------------------------------//\n\n// Function for generating random adyacent points\n\nvec2 hash2( in vec2 p )\n{\n    float r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n//---------------------------------------------------------------------------------//\n\n#define ANIMATED\n\nfloat voronoiDistance( in vec2 pos )\n{\n    vec2 integ = floor( pos );\n    vec2 decim = fract( pos );\n    \n    float dist2 = 1000.0;\n    \n    // Evaluate adyacent points\n    for (float i = -1.0; i <= 1.0; i++) {\n        for (float j = -1.0; j <= 1.0; j++) {\n            // Adyacent cell\n            vec2 cell = vec2(i, j);\n            \n            // Random displacement\n            vec2 despl = hash2( integ + cell );\n            #ifdef ANIMATED\n            despl = 0.5 + 0.5*sin( iTime + 6.2831*despl );\n            #endif\n\n            // Direction vector\n            vec2 dir = cell + despl - decim;\n            \n            // Get min dist\n            float currDist2 = dot(dir, dir);\n            dist2 = min(dist2, currDist2);\n        }\n    }\n\n    return sqrt(dist2);\n}\n\nvec3 worley( in vec2 pos )\n{\n\tfloat dist = voronoiDistance( pos );\n\n    vec3 color = mix(inColor, borderColor, smoothstep(0.0,1.0,0.6*dist));\n    \n    return color;\n}\n\n//---------------------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    fragColor = vec4(worley( numCells*uv ),1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Ibon Guillen - 2016\n// WTFPL License - v2\n//\n// Code extracted from third sources\n// can have it's own licence\n\n// Game rendering\n\n// Heavily inspired by the work of Inigo Quilez\n// Bricks game: https://www.shadertoy.com/view/MddGzf\n// Raymarching: https://www.shadertoy.com/view/Xds3zN\n\n//---------------------------------------------------------------------------------//\n\n// Constants\nconst vec3 subColor  = vec3(1.0, 1.0, 0.0);\nconst vec3 obstColor = vec3(0.8, 0.5, 0.2);\n\nconst float subHeight = 0.08;\nconst float subWidth  = 0.1;\nconst float subDist   = 0.2;\n\nconst float sizeObst     = 0.1;\nconst float apertureObst = 0.4;\n\nconst float heightObst1 = 0.2;\nconst float heightObst2 = 0.4;\nconst float heightObst3 = 0.6;\nconst float heightObst4 = 0.4;\nconst float heightObst5 = 0.6;\nconst float heightObst6 = 0.4;\nconst float heightObst7 = 0.6;\n\n\n// Game states\n#define STARTED  0.0\n#define PLAYING  1.0\n#define FINISHED 2.0\n\n//---------------------------------------------------------------------------------//\n\n// Storage addresses\nconst vec2 txGameState = vec2(0.0, 0.0);\nconst vec2 txGameScore = vec2(1.0, 0.0);\nconst vec2 txSubmarine = vec2(2.0, 0.0);\n\nconst vec2 txObstacle1 = vec2(3.0, 0.0);\nconst vec2 txObstacle2 = vec2(4.0, 0.0);\nconst vec2 txObstacle3 = vec2(5.0, 0.0);\nconst vec2 txObstacle4 = vec2(6.0, 0.0);\nconst vec2 txObstacle5 = vec2(7.0, 0.0);\nconst vec2 txObstacle6 = vec2(8.0, 0.0);\nconst vec2 txObstacle7 = vec2(9.0, 0.0);\n\n// Storage and load functions\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//---------------------------------------------------------------------------------//\n\n// Drawing functions\n\n// Distance functions\n\n// From: https://iquilezles.org/articles/distfunctions\n\nfloat drawCapsule( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat drawSubmarine( in vec2 uv, in vec2 pos )\n{\n    vec2  a = vec2(pos.x - subWidth, pos.y);\n    vec2  b = vec2(pos.x, pos.y);\n\n\t// Main body\n    float r1 = subHeight/2.0;\n    float f1 = max(0.0, drawCapsule(uv, a, b, r1));\n    \n    vec2  c = vec2(pos.x, pos.y + subHeight/1.2);\n    \n    // Prow\n    float r2 = subHeight/6.0;\n    float f2 = max(0.0, drawCapsule(uv, b, c, r2));\n    \n    vec2 d = vec2(pos.x - subWidth - r1/2.0, pos.y + subHeight/2.0);\n    vec2 e = vec2(pos.x - subWidth - r1/2.0, pos.y - subHeight/2.0);\n    \n    // Poop\n    float r3 = subHeight/10.0;\n    float f3 = max(0.0, drawCapsule(uv, d, e, r3));\n    \n    return min(f1, min(f2, f3));\n}\n\nfloat drawObstacle( in vec2 uv, in vec2 pos )\n{\n    vec2  a = vec2(pos.x, 2.0);\n    vec2  b = vec2(pos.x, pos.y + apertureObst/2.0);\n    vec2  c = vec2(pos.x, pos.y - apertureObst/2.0);\n    vec2  d = vec2(pos.x, -2.0);\n    \n    float f1 = max(0.0, drawCapsule(uv, a, b, sizeObst/2.0));\n    float f2 = max(0.0, drawCapsule(uv, c, d, sizeObst/2.0));\n    \n    return min(f1, f2);\n}\n\n//---------------------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 outColor = vec3(0.0);\n    \n    //---------------------------------------------------//\n    \n    // Load game state\n    vec2  gameState = loadValue( txGameState ).xy;\n    float state     = gameState.x;\n    \n    // Load submarine state\n    vec2  submarine = loadValue( txSubmarine ).xy;\n    float subPosition  = submarine.x;\n    \n    // Load obstacles state\n    vec2  obstacle1     = loadValue( txObstacle1 ).xy;\n    float obst1Position = obstacle1.x;\n    \n    vec2  obstacle2     = loadValue( txObstacle2 ).xy;\n    float obst2Position = obstacle2.x;\n    \n    vec2  obstacle3     = loadValue( txObstacle3 ).xy;\n    float obst3Position = obstacle3.x;\n    \n    vec2  obstacle4     = loadValue( txObstacle4 ).xy;\n    float obst4Position = obstacle4.x;\n    \n    vec2  obstacle5     = loadValue( txObstacle5 ).xy;\n    float obst5Position = obstacle5.x;\n        \n    vec2  obstacle6     = loadValue( txObstacle6 ).xy;\n    float obst6Position = obstacle6.x;\n    \n    vec2  obstacle7     = loadValue( txObstacle7 ).xy;\n    float obst7Position = obstacle7.x;\n    \n    //---------------------------------------------------//\n    \n    // Drawing\n    \n    float fObst = 1.0;\n    \n    // Obstacles\n    {\n        // Obstacle 1\n        vec2 pos1   = vec2(obst1Position, heightObst1);\n        \n        fObst = drawObstacle( uv, pos1 );\n        \n        // Obstacle 2\n        vec2 pos2   = vec2(obst2Position, heightObst2);\n        \n        if ( fObst != 0.0 ) {\n            fObst = drawObstacle( uv, pos2 );\n        }\n        \n        // Obstacle 3\n        vec2 pos3   = vec2(obst3Position, heightObst3);\n        \n        if ( fObst != 0.0 ) {\n            fObst = drawObstacle( uv, pos3 );\n        }\n        \n        // Obstacle 4\n        vec2 pos4   = vec2(obst4Position, heightObst4);\n        \n        if ( fObst != 0.0 ) {\n            fObst = drawObstacle( uv, pos4 );\n        }\n        \n        // Obstacle 5\n        vec2 pos5   = vec2(obst5Position, heightObst5);\n        \n        if ( fObst != 0.0 ) {\n            fObst = drawObstacle( uv, pos5 );\n        }\n        \n        // Obstacle 6\n        vec2 pos6   = vec2(obst6Position, heightObst6);\n        \n        if ( fObst != 0.0 ) {\n            fObst = drawObstacle( uv, pos6 );\n        }\n        \n        // Obstacle 7\n        vec2 pos7   = vec2(obst7Position, heightObst7);\n        \n        if ( fObst != 0.0 ) {\n            fObst = drawObstacle( uv, pos7 );\n        }\n        \n        if ( fObst == 0.0 ) {\n            outColor = obstColor;\n        }\n    }\n    \n    float fSub = 1.0;\n    \n    // Submarine\n    {\n        vec2 posSub = vec2(subDist, subPosition);\n        \n        fSub = drawSubmarine( uv, posSub );\n        \n        if ( fSub == 0.0 ) {\n            outColor = subColor;\n        }\n    }\n    \n    // Check colisions\n    if (fSub == 0.0 && fObst == 0.0) {\n        outColor = vec3(1.0, 0.0, 0.0);\n    }\n    \n    //---------------------------------------------------//\n    \n    fragColor = vec4(outColor, 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}