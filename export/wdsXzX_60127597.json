{"ver":"0.1","info":{"id":"wdsXzX","date":"1552245324","viewed":82,"name":"Mashgraf_02","username":"aorlova","description":"Mashgraf, доп.часть","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["k"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 dir;  \n};\n\nstruct Light {\n    vec3 color;\n    vec3 dir;     \n};\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\nstruct Intersect {\n    float len;\n    vec3 nl;  \n    Material materl;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 pos;    \n    Material materl;\n};\n    \nstruct Plane {\n    vec3 nl;\n    Material materl;\n};\n\n \n//////////////////////////////////////////////////\n    \nconst float eps = 0.001;\n\nconst float pi = 3.141519;\n\nconst int Const = 1500;\n\nconst vec3 ambient = vec3(0.2, 0.2, 0.5) * 20.0;\n\nconst Intersect miss = Intersect(0.0, vec3(0.0),\n                                 Material(vec3(0.3), 0.0, 0.0));\n\n//////////////////////////////////////////////////\n\nIntersect intersect(Ray ray, Sphere sphere) \n{\n    vec3 oc = sphere.pos - ray.origin;\n    float l = dot(ray.dir, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) \n    {\n        return miss;\n    }\n    float len = l - sqrt(det);\n    if (len < 0.0) \n    {\n        len = l + sqrt(det);\n    }\n    if (len < 0.0)\n    {\n        return miss;\n    }\n    return Intersect(len, \n                     (ray.origin + len*ray.dir - sphere.pos) / sphere.radius,\n                     sphere.materl);\n}\n\n\nIntersect intersect(Ray ray, Plane plane) \n{\n    float len = -dot(ray.origin, plane.nl) / dot(ray.dir, plane.nl);\n    if (len < 0.0) \n        return miss;\n    return Intersect(len, plane.nl, plane.materl);\n}\n\n\nIntersect trace(Ray ray) \n{\n    \n    const int pieces_spheres = 2;\n    Sphere spheres[pieces_spheres];\n    \n    //-----------------------------------------\n    \n    spheres[0].radius = 1.0;\n    spheres[0].pos = vec3(-1.5, 3.1+ 2.1*sin(iTime), -1.5);\n    spheres[0].materl = Material(vec3(0.0, 0.2, 1.0), 0.0, 1.0);\n  \n    spheres[1].radius = 1.3;\n    spheres[1].pos = vec3(1.5-2.0*sin(iTime), 1.3, 1.5);\n    spheres[1].materl = Material(vec3(1.0, 0.0, 0.5), 0.5, 0.15);\n    \n    \n    Intersect intersection = miss;\n    Intersect plane = intersect(ray,\n                                Plane(vec3(0, 1, 0), \n                                Material(vec3(1.0, 1.0, 1.0),\n                                0.85, 0.0))); \n    \n                  \n    if (plane.materl.diffuse > 0.0)\n    { \n        intersection = plane; \n    }\n    if (plane.materl.specular > 0.0)\n    {\n        intersection = plane;\n    }\n    \n \n    for (int i = 0; i < pieces_spheres; i++) \n    {\n        Intersect sphere = intersect(ray, spheres[i]);\n        if (sphere.materl.diffuse > 0.0)\n        {\n            intersection = sphere;\n            \n        }\n        if (sphere.materl.specular > 0.0)\n        {\n            intersection = sphere;\n           \n        }\n            \n    }\n \n    return intersection;\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec3 pos, in float rad)\n{\n    float k = 2.5;\n\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    \n    float d = -rad + sqrt( max(0.0,rad*rad-h));\n    float t = -b     - sqrt( max(0.0,h) );\n    return (t<0.0) ? 1.0 : smoothstep( 0.0, 1.0, k*d/t );\n\n}\n\n\nvec3 radiance(Ray ray) \n{\n    const int pieces_lights = 3;\n    Light lights[pieces_lights];\n    \n    lights[0].color = vec3(1.0, 0.0, 0.0) *120.0;\n    lights[0].dir = normalize(vec3(-1.0, 4.5, 8.0));\n    \n    lights[1].color = vec3(0.0, 1.0, 0.0) * 120.0;\n    lights[1].dir = normalize(vec3(-0.4, 0.75, 0.1));\n    \n    lights[2].color = vec3(0.0, 0.0, 1.0) * 120.0;\n    lights[2].dir = normalize(vec3(0.4, 0.75, 0.1));\n    \n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n\n    for (int i = 0; i <= Const; ++i) \n    {\n        Intersect hit = trace(ray);\n        if (hit.materl.diffuse > 0.0 || hit.materl.specular > 0.0)\n        {\n            vec3 r0 = hit.materl.color.rgb*hit.materl.specular;\n            float hv = clamp(dot(hit.nl, -ray.dir), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 7.0);\n            mask *= fresnel;\n            for (int j = 0; j <= pieces_lights; ++j)\n            {\n            \n                if (trace(Ray(ray.origin + hit.len * ray.dir + eps *\n                          lights[j].dir, lights[j].dir)) == miss) \n            \n                {\n                \n                    color += sphSoftShadow(ray.origin + hit.len * ray.dir\n                                       + eps * lights[j].dir,\n                                       lights[j].dir,\n                                       vec3(1.5-2.0*sin(iTime), 1.3, 1.5),\n                                       1.35)\n                             *sphSoftShadow(ray.origin + hit.len * ray.dir\n                                       + eps * lights[j].dir,\n                                       lights[j].dir,\n                                       vec3(-1.5, 3.1+ 2.1*sin(iTime), -1.5),\n                                       1.15)\n                             * lights[j].color\n                             * hit.materl.color.rgb \n                             * hit.materl.diffuse\n                             * (1.0 - fresnel) *mask/(fresnel);\n                }\n            }\n            \n            vec3 reflection = reflect(ray.dir, hit.nl);\n            ray = Ray(ray.origin + hit.len * ray.dir + eps *\n                      reflection, reflection);\n            \n        \n        }\n        else \n        {\n            vec3 sptlight1 = vec3(1e5)\n                * pow(abs(dot(ray.dir, lights[0].dir)), 900.0);\n            vec3 sptlight2 = vec3(1e4) \n                * pow(abs(dot(ray.dir, lights[1].dir)), 500.0);\n            vec3 sptlight3 = vec3(1e6) \n                * pow(abs(dot(ray.dir, lights[2].dir)), 400.0);\n            vec3 sptlight = sptlight1 + sptlight2 + sptlight3;\n      \n            color += mask *(ambient + sptlight);\n            break;\n        }\n    }\n    return color;\n}\n\nmat3 CameraMatrix(vec3 camF)\n{\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    \n    vec3 camR = normalize(cross(camF, camUp));\n    \n    return mat3(camR, camUp, camF);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    float delt = mouse.x * pi * 2.0;\n    \n    vec3 CamF = vec3(1.0 * cos(delt),    \n                     0.0, 1.0 * sin(delt));\n    vec3 CamP = vec3(-12.0 * cos(delt)+cos(delt),\n                     1.0, -5.0 * sin(delt)-cos(delt));\n    mat3 camMat = CameraMatrix(CamF);\n\n    vec3 rd = camMat*normalize(vec3(p.x, p.y, 2.0));\n    Ray ray = Ray(CamP, rd); //ro rd\n\n    vec3 col = vec3(pow(radiance(ray) * 0.0075, vec3(0.5)));\n     \n    col = pow(col, vec3(0.55));\n    fragColor = vec4(col, 1.0);\n    \n    \n   \n}","name":"Image","description":"","type":"image"}]}