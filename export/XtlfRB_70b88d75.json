{"ver":"0.1","info":{"id":"XtlfRB","date":"1513173819","viewed":536,"name":"Neutron Box","username":"shau","description":"A quick one using a mask for volumetric shadows","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime * 0.4\n#define EPS 0.005\n#define FAR 20.0 \n#define PI 3.14159265359\n\n//compact 2 axis rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//wireframe edges\nfloat tex(vec3 rp) {\n    float tx = clamp(step(0.8, abs(rp.x)) + step(0.8, abs(rp.y)), 0.0, 1.0);\n    tx *= step(0.1, abs(rp.x)) * step(0.1, abs(rp.y));\n    return tx;\n}        \n\n// Cube mapping routine from Fizzer\n// I'm not sure where I got this from\nfloat fizz(vec3 rp) {\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f);\n}\n\n//IQ - Box and Sphere functions\nvec2 boxIntersection(vec3 ro, vec3 rd, vec3 boxSize) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    //vec3 outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    float fzN = fizz(ro + rd * tN); //wireframe near face\n    return vec2(tN, fzN);\n}\n\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s + noise((p * 5.) + T) * 0.1;\n}\n\nfloat map(vec3 rp) {\n\n    float sphere = sdSphere(rp, 1.2);    \n    \n    rp = abs(rp);\n    float ns = sdBox(rp - vec3(2.0, 2.0, 1.2), vec3(0.2, 0.2, 1.0));\n    ns = min(ns, sdBox(rp - vec3(1.2, 2.0, 2.0), vec3(1.0, 0.2, 0.2)));\n    ns = min(ns, sdBox(rp - vec3(2.0, 1.2, 2.0), vec3(0.2, 1.0, 0.2)));\n             \n    return min(sphere, ns);\n}\n\nfloat march(vec3 ro, vec3 rd, float maxStep, float ls, float la) {\n \n    float t = 0.0;\n    float li = 0.0;\n    \n    for (int i = 0; i < 24; i++) {\n        vec3 rp = ro + rd * t;\n        float ns = map(rp);\n        if (ns < EPS || t > FAR) break;\n        \n        vec2 box = boxIntersection(rp, normalize(-rp), vec3(2.2));\n        float ld = sdSphere(rp, 1.2);\n        float fli = 1.0 * ls / (1.0 + ld * ld * la);\n        if (box.x > 0.0 && box.x < ld) {\n            fli *= (1.0 - box.y);\n        }\n        \n        li += fli;\n        \n        t += min(ns, maxStep);\n    }\n    \n    return li;\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    ro = lookAt + vec3(3.0, 1.0, -6.0);\n    \n    ro.xz *= rot(T);\n    ro.yz *= rot(T * 0.3);\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro, rd;\n    setupCamera(uv, ro, rd);\n    \n    pc = vec3(0.0, 1.0, 0.0) * march(ro, rd, 4.0, 0.03, 0.05);\n    \n    fragColor = vec4(pc, 1.0);\n}","name":"Image","description":"","type":"image"}]}