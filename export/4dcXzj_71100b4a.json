{"ver":"0.1","info":{"id":"4dcXzj","date":"1460175031","viewed":497,"name":"Shiny Animated Voronoi","username":"tomator","description":"Lighting using procedural voronoi bumpmap--\nClick to move light; tweak variables at the top in Buffer A + Image.\n\nVoronoi functionality inspired by and partially based on shaders by various shadertoy users, whose code I learned from.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","noise","interactive","lighting","animated","bumpmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* AMBIENT LIGHT */\n#define _AMBIENT\t0., .05, .1\n\n/* DIFFUSE LIGHT */\n#define _DIFFUSE\t0., (sin(iTime)*.4+.7)*.85, (sin(iTime+3.141592653)*.4+.7)*.75\n#define _DIFINTENSITY 1.1\n#define _LIGHTSIZE 4.\n\n/* SPECULAR HIGHLIGHTS */\n#define _SPECCOL\t0., .75, 1.\n#define _SPECEXP\t128.\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy; //Normal UVs\n    vec2 uvs = 1./iResolution.xy;\t\t   //Pixel coord in [0..1] range\n    vec2 co = fragCoord.xy/iResolution.yy; //Square UVs\n    \n    float n = texture(iChannel0, vec2(uv.x,uv.y+uvs.y)).r;\t\t //Sample Moore neighborhood\n    float ne = texture(iChannel0, vec2(uv.x+uvs.x,uv.y+uvs.y)).r;\n    float e = texture(iChannel0, vec2(uv.x+uvs.x,uv.y)).r;\n    float se = texture(iChannel0, vec2(uv.x+uvs.x,uv.y-uvs.y)).r;\n    float s = texture(iChannel0, vec2(uv.x,uv.y-uvs.y)).r;\n    float sw = texture(iChannel0, vec2(uv.x-uvs.x,uv.y-uvs.y)).r;\n    float w = texture(iChannel0, vec2(uv.x-uvs.x,uv.y)).r;\n    float nw = texture(iChannel0, vec2(uv.x-uvs.x,uv.y+uvs.y)).r;\n    \n    float dx = (nw+2.*w+sw)-(ne+2.*e+se); //Sobel operator x\n    float dy = (sw+2.*s+se)-(nw+2.*n+ne); //Sobel operator y\n    float dz = texture(iChannel0,uv).r*.5+.5; //Height\n    \n    vec3 nm = normalize(vec3(dx,dy,dz)); //Convert heightmap to normalmap\n    \n    vec3 lp = vec3((iMouse.xy/iResolution.yy),1.5); //Light position\n    vec3 lv = normalize(vec3(lp.x-co.x,lp.y-co.y,lp.z-dz)); //Calculate light vector\n    float li = pow(_DIFINTENSITY-(distance(lp,vec3(co,dz))/_LIGHTSIZE),3.); //Calculate light intensity\n    \n    float dif = dot(lv,nm); //Diffuse lighting\n    float sp = pow(dot(lv,nm),_SPECEXP); //Specular lighting\n    \n    vec3 res = vec3(_AMBIENT)+vec3(dif)*vec3(_DIFFUSE)*li+vec3(sp)*vec3(_SPECCOL)*li; //Add lighting results together\n\to = vec4(res,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* GENERAL VARIABLES */\n#define _VORONOI_DENSITY 10.\t/* Larger number = smaller cells */\n//#define _VORONOI_INVERT \t/* Invert the result or not? */\n\n/* DISTANCE FUNCTIONS */\n#define _VORONOI_DIST_EUCLIDIAN \t\t/* Euclidian distance function (standard) */\n//#define _VORONOI_DIST_EUCLIDSQD \t\t/* Euclidian distance function without sqrt */\n//#define _VORONOI_DIST_MANHATTAN \t\t/* Manhattan a.k.a. Taxicab distance function */\n//#define _VORONOI_DIST_CHEBYSHEV \t\t/* Chebyshev a.k.a. Chess distance function */\n//#define _VORONOI_DIST_PYRAMIDAL \t\t/* Triangular distance function (produces isometric boxes) */\n\n/* RETURN TYPES */\n#define _VORONOI_F1 \t\t\t\t/* First feature point (standard) */\n//#define _VORONOI_F2 \t\t\t\t/* Second feature point */\n//#define _VORONOI_F2MINUSF1  \t\t/* Second minus first point */\n//#define _VORONOI_F1PLUSF2   \t\t/* First + second point averaged */\n\nvec2 rand2( vec2 co )\n{\n    //Crude PRNG function -- It seems to be rather widespread across the internet\n\treturn fract(sin(vec2(dot(co,vec2(12.9898,78.233)),dot(co,vec2(15.9113,77.173))))*43758.5453);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n  \tvec2 co = fragCoord.xy / iResolution.yy; //Square fractional coords\n    vec2 p = floor(co*_VORONOI_DENSITY);\n    vec2 f = fract(co*_VORONOI_DENSITY);\n    vec2 res = vec2(16.);\n    for(float x=-2.; x<=2.; x++) //Sample 5*5 = 25 points for their distances\n    for(float y=-2.; y<=2.; y++)\n    {\n        vec2 c = vec2(x,y); //Current relative \"cell\"\n        vec2 ofs = .5+.5*sin(iTime+6.2831*rand2(p+c)); //Animated offsets for points\n        vec2 r=c-f+ofs; //New offset point\n        float dst = //Find distance from (0,0)\n        #ifdef _VORONOI_DIST_EUCLIDIAN\n        \tsqrt(r.x*r.x+r.y*r.y);\n        #endif\n        #ifdef _VORONOI_DIST_EUCLIDSQD\n        \tr.x*r.x+r.y*r.y;\n        #endif\n        #ifdef _VORONOI_DIST_MANHATTAN\n        \tabs(r.x)+abs(r.y);\n        #endif\n        #ifdef _VORONOI_DIST_CHEBYSHEV\n        \tmax(abs(r.x),abs(r.y));\n        #endif\n        #ifdef _VORONOI_DIST_PYRAMIDAL\n        \tmax(abs(r.x)-r.y,r.y);\n        #endif            \n        if(dst<res.x) //Store closest & 2nd closest feature points\n        {\n            res.y = res.x;\n            res.x = dst;\n        } else if(dst<res.y)\n        \tres.y = dst;\n    }    \n    float val =\n    #ifdef _VORONOI_F1\n        res.x;\n    #endif\n    #ifdef _VORONOI_F2\n        res.y;\n    #endif\n    #ifdef _VORONOI_F2MINUSF1\n        res.y-res.x;\n    #endif\n    #ifdef _VORONOI_F1PLUSF2\n        (res.x+res.y)*.5;\n    #endif\n    #ifdef _VORONOI_INVERT\n    val = 1.-val;\n    #endif\n    o = vec4(vec3(clamp(val,0.,1.)),1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}