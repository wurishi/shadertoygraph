{"ver":"0.1","info":{"id":"4f2BRt","date":"1730903900","viewed":98,"name":"simplex noise progress","username":"kofi","description":"trying to create hex pattern without tutorials (yet)","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["noise","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RATIO iResolution.y/iResolution.x\n#define PI 3.1415926\nfloat noise(vec2 coords) {\n    return fract(sin(dot(coords.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat smoothing(float t) {\n    return t*t*(3.-2.*t);\n}\nfloat simplex(vec2 pos) {\n    pos.x /= cos(PI/6.);\n\n    pos.y += sin(PI/6.)*pos.x;\n\n    vec2 b = round(pos);\n\n    vec3 col = vec3((abs(b-pos).x < .02) || (abs(b-pos).y < .02) || (abs(fract(pos.x)-fract(pos.y)) < .02) ? 1.0 : (fract(pos.x) < fract(pos.y)) ? .25 : .75);\n\n    col = vec3(noise((fract(pos.x) < fract(pos.y)) ? floor(pos) : ceil(pos)), 0., .5);\n\n    float trVert = ceil(fract(pos.x)-fract(pos.y));\n\n    vec3 c = vec3(\n\n        noise(floor(pos)), \n\n        noise(floor(pos + 1.)), \n\n        noise(floor(pos) + vec2(trVert, 1.-trVert)));\n\n    vec2 v[3];\n\n    v[0] = floor(pos);\n\n    v[1] = floor(pos + 1.);\n\n    v[2] = floor(pos) + vec2(trVert, 1.-trVert);\n\n    vec3 interp = vec3(\n\n        ((v[1].y-v[2].y)*(pos.x-v[2].x)\n\n        +(v[2].x-v[1].x)*(pos.y-v[2].y))/\n\n        ((v[1].y-v[2].y)*(v[0].x-v[2].x)\n\n        +(v[2].x-v[1].x)*(v[0].y-v[2].y)),\n\n        ((v[2].y-v[0].y)*(pos.x-v[2].x)\n\n        +(v[0].x-v[2].x)*(pos.y-v[2].y))/\n\n        ((v[1].y-v[2].y)*(v[0].x-v[2].x)\n\n        +(v[2].x-v[1].x)*(v[0].y-v[2].y)),\n\n        0.\n\n    );\n\n    interp.z = 1.-interp.x-interp.y;\n    return c[0]*interp.x+c[1]*interp.y+c[2]*interp.z;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 10.*fragCoord/iResolution.xy-.5;\n    \n    uv.x /= RATIO;\n\n\n    //uv *= 30.;\n        //uv.x += iTime;\n    /*\n    uv.x /= cos(PI/6.);\n    uv.y += sin(PI/6.)*uv.x;\n\n    vec2 b = round(uv);\n    vec3 col = vec3((abs(b-uv).x < .02) || (abs(b-uv).y < .02) || (abs(fract(uv.x)-fract(uv.y)) < .02) ? 1.0 : (fract(uv.x) < fract(uv.y)) ? .25 : .75);\n    col = vec3(noise((fract(uv.x) < fract(uv.y)) ? floor(uv) : ceil(uv)), 0., .5);\n    float trVert = ceil(fract(uv.x)-fract(uv.y));\n    vec3 c = vec3(\n        noise(floor(uv)), \n        noise(floor(uv + 1.)), \n        noise(floor(uv) + vec2(trVert, 1.-trVert)));\n    vec2 v[3];\n    v[0] = floor(uv);\n    v[1] = floor(uv + 1.);\n    v[2] = floor(uv) + vec2(trVert, 1.-trVert);\n    vec3 interp = vec3(\n        ((v[1].y-v[2].y)*(uv.x-v[2].x)\n        +(v[2].x-v[1].x)*(uv.y-v[2].y))/\n        ((v[1].y-v[2].y)*(v[0].x-v[2].x)\n        +(v[2].x-v[1].x)*(v[0].y-v[2].y)),\n        ((v[2].y-v[0].y)*(uv.x-v[2].x)\n        +(v[0].x-v[2].x)*(uv.y-v[2].y))/\n        ((v[1].y-v[2].y)*(v[0].x-v[2].x)\n        +(v[2].x-v[1].x)*(v[0].y-v[2].y)),\n        0.\n    );\n    interp.z = 1.-interp.x-interp.y;\n    \n    */\n\n    fragColor = vec4(vec3(simplex(uv)),1.0);\n}","name":"Image","description":"","type":"image"}]}