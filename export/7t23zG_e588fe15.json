{"ver":"0.1","info":{"id":"7t23zG","date":"1624189322","viewed":119,"name":"Sampling techniques","username":"Envy24","description":"Visualization of sampling techniques.\n\nLeft: regular grid\nMiddle: random grid\nRight: jittered grid","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["visualization","random","sampling","regular","jittered"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float drawRegularSamples(\n    vec2 uv,\n    uint xNumOfSamples,\n    uint yNumOfSamples)\n{\n    float tMin = 99999999.0;\n\n    float xStep = 1.0 / float(xNumOfSamples);\n    float yStep = 1.0 / float(yNumOfSamples);\n\n    float xShift = xStep * 0.5;\n    float yShift = yStep * 0.5;\n\n    for (uint y = 0u; y < yNumOfSamples; ++y)\n    {\n        for (uint x = 0u; x < xNumOfSamples; ++x)\n        {\n            vec2 s = vec2(xShift + float(x) * xStep, yShift + float(y) * yStep);\n\n            tMin = min(smoothCircleSDF(uv.x, uv.y, s.x, s.y, 0.002, 0.009), tMin);\n        }\n    }\n    \n    return tMin;\n}\n\nfloat drawRandomSamples(vec2 uv, uint numOfSamples)\n{\n    float tMin = 99999999.0;\n\n    uint x = uint(uv.x);\n    uint y = uint(uv.y);\n\n    uint t = uint(1.0 + iTime * 1.1);\n\n    for (uint i = 0u; i < numOfSamples; ++i)\n    {\n        vec2 rand = \n            (vec2(1.0, 1.0) +\n            vector2HashUI32((i + 1u) * t * 345u, (i + 1u)  * t * 75673u)) * 0.5;\n        \n        tMin = min(smoothCircleSDF(uv.x, uv.y, rand.x, rand.y, 0.002, 0.009), tMin);\n    }\n    \n    return tMin;\n}\n\nfloat drawJitterSamples(\n    vec2 uv,\n    uint xNumOfSamples,\n    uint yNumOfSamples,\n    float range)\n{\n    float tMin = 99999999.0;\n\n    float xStep = 1.0 / float(xNumOfSamples);\n    float yStep = 1.0 / float(yNumOfSamples);\n\n    float xShift = xStep * 0.5;\n    float yShift = yStep * 0.5;\n    \n    uint t = uint(1.0 + iTime * 1.1);\n\n    for (uint y = 0u; y < yNumOfSamples; ++y)\n    {\n        for (uint x = 0u; x < xNumOfSamples; ++x)\n        {\n            uint i = y * yNumOfSamples + x;\n        \n            vec2 s = vec2(xShift + float(x) * xStep, yShift + float(y) * yStep);\n            \n            vec2 rand = vector2HashUI32((i + 1u) * t * 345u, (i + 1u)  * t * 75673u);\n                \n            s.x += range * rand.x / float(xNumOfSamples * 2u);\n            s.y += range * rand.y / float(yNumOfSamples * 2u);\n\n            tMin = min(smoothCircleSDF(uv.x, uv.y, s.x, s.y, 0.002, 0.009), tMin);\n        }\n    }\n    \n    return tMin;\n}\n\nfloat drawNRooksSamples(vec2 uv)\n{\n    float tMin = 99999999.0;\n\n    uint x = uint(uv.x);\n    uint y = uint(uv.y);\n\n    uint t = uint(1.0 + iTime * 1.1);\n\n    const uint numOfSamples = 2u;\n    float invNum = 1.0 / float(numOfSamples);\n    vec2 samples[numOfSamples];\n  \n    for (uint i = 0u; i < numOfSamples; ++i)\n    {\n        vec2 rand = \n            (vec2(1.0, 1.0) +\n            vector2HashUI32((i + 1u) * t * 345u, (i + 1u)  * t * 75673u)) * 0.5;\n    \n       //rand.x = (1.0 + rand.x) * 0.5;\n       //rand.y = (1.0 + rand.y) * 0.5;\n    \n       samples[i].x = (float(i) + rand.x) * invNum;\n       samples[i].y = (float(i) + rand.y) * invNum;  \n    }\n    \n    /* shuffle */\n    for (uint i = 0u; i < numOfSamples; ++i)\n    {\n        uint xRandomIdx = hashUI32(i + uint(t)) % numOfSamples;\n        uint yRandomIdx = hashUI32(i + uint(t * 2u)) % numOfSamples;\n        \n        float tmp = samples[i].x;\n        samples[i].x = samples[xRandomIdx].x;\n        samples[xRandomIdx].x = samples[i].x;\n                \n        tmp = samples[i].y;\n        samples[i].y = samples[yRandomIdx].y;\n        samples[yRandomIdx].y = samples[i].y;\n    }\n    \n    /* visualization */\n    for (uint i = 0u; i < numOfSamples; ++i)\n    {\n        tMin = min(smoothCircleSDF(uv.x, uv.y, samples[i].x, samples[i].y, 0.002, 0.009), tMin);\n    }\n    \n    return tMin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 3.0;\n\n    float gray = 0.0;\n    \n    uint numOfSamples = 2u;\n\n    if (uv.x < 1.0) { \n        gray = 1.0 - drawRegularSamples(vec2(uv.x, uv.y), numOfSamples, numOfSamples); \n    } \n    else if (uv.x < 2.0) { \n        gray = drawRandomSamples(vec2(uv.x - 1.0, uv.y), numOfSamples * numOfSamples); \n    }\n    else { \n        gray = 1.0 - drawJitterSamples(vec2(uv.x - 2.0, uv.y), numOfSamples, numOfSamples, 1.0); \n        //gray = 1.0 - drawNRooksSamples(vec2(uv.x - 2.0, uv.y));\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \n    Returns hash in range [0; UINT32_MAX].\n*/\nuint hashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 12345u;\n    const uint enthropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    return value * value * value;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * enthropy2 + x;\n    uint value1 = x * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nfloat smoothCircleSDF(\n    float x,\n    float y,\n    float cx,\n    float cy, \n    float r,\n    float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = x - cx;\n    float _y = y - cy;\n    \n    // Signed distance.\n    float d =  sqrt(_x * _x + _y *_y) - r;\n     \n    // Smoothstep interpolation.\n    return smoothstep(0.0, smoothness, d);\n}","name":"Common","description":"","type":"common"}]}