{"ver":"0.1","info":{"id":"sdGGDV","date":"1632246708","viewed":450,"name":"Right Angled Hexagons","username":"stevejtrettel","description":"Parameterizing a 3-dimensional subset of the Teichmuller space of the genus 2 surface (the surfaces with zero twist parameter, which are tiled by four congruent right angled hexagons).","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"fdG3DV","parentname":"Hyperbolic Octagon Reflections"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A tiling of the hyperbolic plane by right angled hexagons determines a genus 2 surface\n//doubling such a hexagon along a triplet of alternating sides gives a pair of pants,\n//and doubling that pair of pants across its boundary gives a genus 2 surface\n\n\n\nfloat PI=3.14159;\n\n//------------------------------------------\n//Define hyperbolic half spaces, reflections\n//------------------------------------------\n\n//vertical line to reflect in\n//side=+1 means the half space contains points to the right, -1 to the left\nstruct Line{\n    float pos;\n    float side;\n};\n\n\n//semicircle centered on real line to reflect in\n//side =+1 means the halfspace contains points below, -1 means above\nstruct Circle{\n    float center;\n    float radius;\n    float side;\n};\n\n\n\n//reflection in vertical line defining a half space\n//this is done by conjugating reflection in the line x=0\n//by the translation taking this line there\nvoid invert(inout vec2 p, Line line){\n\n    p.x -= line.pos;\n    p.x *= -1.;\n    p.x += line.pos;\n\n}\n\n//reflection in a circle defining a half space\n//this is done by conjugating inversion in the unit circle\n//with a similarity transformation taking the given circle to the unit circle\nvoid invert(inout vec2 p, Circle circle){\n\n    p.x -= circle.center;\n    p /= circle.radius;\n    p /= dot(p,p);\n    p *= circle.radius;\n    p.x += circle.center;\n\n}\n\n//check if inside a half space bounded by a line:\nbool inside(vec2 p, Line line){\n    if(line.side>0.){//check if we are on the right side\n        return p.x>line.pos;\n    }\n    else{//check if we are on the left side\n        return p.x<line.pos;\n    }\n}\n\n//check if inside a half space bounded by a circle\nbool inside(vec2 p, Circle circle){\n    if(circle.side>0.){//check if we are inside the semicircle\n        return length(p-vec2(circle.center,0))<circle.radius;\n    }\n    else{//check if we are outside the semicircle\n        return length(p-vec2(circle.center,0))>circle.radius;\n    }\n}\n\n\n//check if we are inside\nvoid reflectIn(inout vec2 p, Circle circle, inout float invCount){\n    if(!inside(p,circle)){\n        invert(p,circle);\n        invCount+=1.;\n    }\n}\n\nvoid reflectIn(inout vec2 p, Line line, inout float invCount){\n    if(!inside(p,line)){\n        invert(p,line);\n        invCount+=1.;\n    }\n}\n\n\n\n//------------------------------------------\n//some hyperbolic geometry\n//------------------------------------------\n\n//do a rotation in the upper half plane of angle theta about i\nfloat rot(float x, float theta){\n    float c=cos(theta/2.);\n    float s=sin(theta/2.);\n    mat2 mat=mat2(c,s,-s,c);\n    vec2 p=mat*vec2(x,1.);\n    return p.x/p.y;\n}\n\n\n//the above is only a rotational mobius transformation applied to the real line\n//this is a general mobius transformation applied to points in upper half space\n//do the mobius transformation ((a,b),(c,d)).z\nvec2 mobiusTransf(vec4 mob, vec2 z){\n    float a=mob.x;\n    float b=mob.y;\n    float c=mob.z;\n    float d=mob.w;\n    float Z2=length(z)*length(z);\n    float term1=c*z.x+d;\n    float term2=c*z.y;\n    float denom=term1*term1+term2*term2;\n\n    term1=a*c*Z2+b*d+(a*d+b*c)*z.x;\n    term2=(a*d-b*c)*z.y;\n\n    return vec2(term1,term2)/denom;\n}\n\n\n//measure the distance to a vertical line geodesic\nfloat dist(vec2 p, Line line){\n    //translate line to oriign\n    p.x-=line.pos;\n    float secTheta=length(p)/abs(p.y);\n    return acosh(secTheta);\n}\n\n//measure the distance to a circle geodesic\nfloat dist(vec2 p, Circle circle){\n    float end1=circle.center-circle.radius;\n    float end2=circle.center+circle.radius;\n    vec4 mob=vec4(1.,-end1,1.,-end2);\n\n    //do the mobius transformation making this segment vertical:\n    vec2 z=mobiusTransf(mob, p);\n\n    //now measure the distance to this vertical line\n    return dist(z,Line(0.,1.));\n}\n\n\n\n\n//------------------------------------------\n//set up the fundamental domain\n//------------------------------------------\n\n\n//Give names to the sides of the shape\nCircle C0,C1,C2,L12,L20;\nLine L01;\n\n//function that defines these sides\n//a right angled hexagon is determined by three moduli\n//here we list them as a,b,h: these directly specify the \"C-Circles\"\n//then we build the \"L-Circles\" from them\nvoid setUpFD(float a, float b, float h){\n\n    C0=Circle(0.,1.,1.);\n    C1=Circle(0.,a,-1.);\n    C2=Circle(h,b,-1.);\n\n    //the radius of the short circles depends on these as calculated:\n    //Lij is the circle intersecting Ci and Cj orthogonally\n\n    float u=(h*h+a*a-b*b)/(2.*h);\n    float r=sqrt(u*u-a*a);\n    float v=(h*h+1.-b*b)/(2.*h);\n    float R=sqrt(v*v-1.);\n\n    L01=Line(0.,1.);\n    L12=Circle(u,r,-1.);\n    L20=Circle(v,R,-1.);\n}\n\n\n//takes in 3 floats all in (0,1) and puts them into an acceptable triple (a,b,h)\n//rules: x is in (0,1): this just becomes a.\n//given a, the value of h is constrained to lie in (a,1)\n//thus y is sent to h=a+(1-a)y\n//given a,h, the radius b is constrained so that the circle endpoints h-b, h+b lie in the\n//interval (a,1)\n//thus h-b>a, and h+b<1.  Re-arranging, b<h-a, and b<1-h.  Thus b<min(h-a,1-h)\n//so we send z to b=min(h-a,1-h)z\nvec3 parametersFD(float x, float y, float z){\n\n    float a=x;\n    float h=a+(1.-a)*y;\n    float b=min(h-a,1.-h)*z;\n\n    return vec3(a,b,h);\n}\n\n\n//measuring the distance tot edes which are exterior to the entire surface fundamental domain\n//not drawing the internal edges that we reflect in from the hexagon tile\nfloat edgeDistance(vec2 p){\n\n    float d1=dist(p,C1);\n    float d12=dist(p,L12);\n    float d2=dist(p,C2);\n    float d20=dist(p,L20);\n    float d01=dist(p,L01);\n\n    //this is the minimum distance away from any edge that we care about\n    float d=min(min(d1,d12),min(d2,d20));\n\n    return d;\n}\n\n\n\n//------------------------------------------\n//reflect points into fundamental domain\n//------------------------------------------\n\n\n//this function takes in a point p, and looks at each side of the fundamental domain\n//if p is not within the half space defined by that side, we reflect it\n//if p is already in that half space, we leave it alone\nvoid reflectInFD(inout vec2 p,inout float invCount){\n\n    reflectIn(p,C0,invCount);\n    reflectIn(p,C1,invCount);\n    reflectIn(p,C2,invCount);\n    reflectIn(p,L01,invCount);\n    reflectIn(p,L12,invCount);\n    reflectIn(p,L20,invCount);\n\n}\n\n\n//while the program's reflection group algorithm will use just the right angled hexagon\n//throughout most computation, we will at times want to draw a fundamental domain for the surface\n//which consists of 4 hexagons.\n//this function reflects in the two internal walls, to help with that\nvoid reflectInternally(inout vec2 p){\n\n    if(!inside(p,C0)){\n        invert(p,C0);\n    }\n\n    if(!inside(p,L01)){\n        invert(p,L01);\n    }\n}\n\n\n\n//this function checks if p is inside our fundamental domain or not\nbool insideFD(vec2 p){\n    bool within=inside(p,C0);\n    within=within&&inside(p,C1);\n    within=within&&inside(p,C2);\n    within=within&&inside(p,L01);\n    within=within&&inside(p,L12);\n    within=within&&inside(p,L20);\n    return within;\n}\n\n\n\n\n//move into the fundamental domain\n//this combines the two functions above: it iteratively reflects in the sides,\n//then checks if you ended up inside the FD\n//if you do, it stops.\nvoid moveToFD(inout vec2 p,inout float invCount){\n\n\n    for(int i=0;i<25;i++){\n\n        reflectInFD(p,invCount);\n\n        if(insideFD(p)){\n            return;\n        }\n\n    }\n\n    invCount=-1.;\n\n}\n\n\n\n\n\n//------------------------------------------\n//prepare the screen pixels for computation\n//------------------------------------------\n\n\n\n//just packing the sinusoidal oscillation which oscillates between a and b into its own function\nfloat osc(float a,float b, float t){\n    return abs(b-a)/2.*(1.+sin(t))+a;\n}\n\n\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizedFragCoord(vec2 fragCoord){\n\n    // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5));\n\n    //rescale this how you like\n    uv = 4.*vec2(1,iResolution.y/iResolution.x)*uv;\n\n    return uv;\n}\n\n\n//starting from Poincare Disk:\nvec2 toUHP(vec2 uv){\n\n    //move to half plane\n    float Re = 2.*uv.x;\n    float Im = 1.-dot(uv,uv);\n    vec2 temp=vec2(1.-uv.y,uv.x);\n    float Scale = dot(temp,temp);\n    vec2 p = 1./Scale*vec2(Re,Im);\n\n    return p;\n\n}\n\n\n//this function takes coordinates in poincare disk,\n//uses mouse position to make a mobius transformation\nvec2 mouseTransform(vec2 z){\n    if (iMouse.x > 10.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        // Unit disc inversion\n        m /= dot(m,m);\n        z -= m;\n        float k = (dot(m,m)-1.0)/dot(z,z);\n        z *= k;\n        z += m;\n    }\n    return z;\n}\n\n\n//transformations done at setup in the Poincare Disk model\nvec2 transformPD(vec2 z){\n\n    if (iMouse.z > 0.) {\n        z=mouseTransform(z);\n    }\n    else{\n        //do a rotation slowly\n        float c=cos(iTime/6.);\n        float s=sin(iTime/6.);\n        z=mat2(c,s,-s,c)*z;\n    }\n\n    return z;\n}\n\n\n\n//transformations done in setup to the Upper Half Plane Model\nvec2 transformUHP(vec2 p){\n\n    //if there is no mouse press\n    if (iMouse.z < 0.) {\n        //apply a hyperbolic\n        p*=osc(0.4,0.8,iTime/2.);\n\n        //reflect up to the upper half plane:\n        p.y=abs(p.y);\n    }\n\n    return p;\n\n}\n\n\n\n//------------------------------------------\n//assigning color to points in the fundamental domain\n//------------------------------------------\n\n\n//get the color of the edges\nvec3 edgeColor(vec2 p, bool insideDisk){\n\n    if(insideDisk) return vec3(170,210,255)/255.;\n    if(!insideDisk) return 0.35*vec3(140,60,40)/255.;\n\n    return vec3(0.);\n}\n\n\n\n//get the color for the interior tiles\nvec3 tilingColor(float invCount,bool insideDisk){\n\n    vec3 tilingColor;\n\n    if(invCount<0.){\n        //if we didnt get into the fundamental domain\n        //color it black//BETTER: A DEBUG COLOR\n        tilingColor=vec3(0,0,0);\n    }\n\n    else {\n        //we did get into the fundamental domain:\n        float parity=mod(invCount, 2.);\n\n        if (insideDisk){\n            if (parity==0.){\n                tilingColor=vec3(116, 161, 250)/255.;\n            }\n            else { //parity=1.\n                tilingColor=vec3(120, 170, 250)/255.;\n            }\n        }\n\n        //if we are outside, make complementary colored.\n        else {\n            if (parity==0.){\n                tilingColor=0.25*vec3(230,129,56)/255.;\n            }\n            else { //parity=1.\n                tilingColor=0.25*vec3(230,99,90)/255.;\n            }\n        }\n    }\n\n    return tilingColor;\n\n}\n\n\n\n//get a color for a point in the fundamental domain\nvec3 getColor(vec2 p,float invCount,bool insideDisk,bool insideDomain){\n\n    bool onEdge=(edgeDistance(p)<0.05);\n\n    if(onEdge){\n        return edgeColor(p, insideDisk);\n    }\n    else if(insideDomain){\n        return tilingColor(invCount,insideDisk)+vec3(0.3,0,0);\n    }\n    else{\n        return tilingColor(invCount,insideDisk);\n    }\n\n    return vec3(0.);\n}\n\n\n//------------------------------------------\n//making the main image\n//------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord);\n\n    //keep track of if we start outside the poincare disk\n    bool insideDisk=(length(uv)<1.);\n\n    //apply a mobius transformation from mouse position\n    //this is done in disk model still\n    uv=transformPD(uv);\n\n    //map to upper half plane for computation:\n    vec2 p = toUHP(uv);\n\n    //apply some transformations in the UHP model\n    p=transformUHP(p);\n\n    //setup the fundamental domain we are working with\n    float x=osc(0.1,0.9,iTime/3.);\n    float y=osc(0.2,0.8,iTime);\n    float z=osc(0.2,0.8,iTime/2.);\n    vec3 params=parametersFD(x,y,z);\n    setUpFD(params.x,params.y,params.z);\n\n\n    //before changing p around, separately make a copy to color the original fundamental domain\n    vec2 q=p;\n    //reflect in the two internal walls: this gets one full copy of the fundamnetal domain\n    reflectInternally(q);\n    bool insideDomain=insideFD(q)&&insideDisk&&(edgeDistance(q)>0.05);\n\n    //reflect into the fundamental domain\n    float invCount=0.;\n    moveToFD(p,invCount);\n\n    // color the pixel based on this\n    vec3 col=getColor(p,invCount,insideDisk,insideDomain);\n\n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}