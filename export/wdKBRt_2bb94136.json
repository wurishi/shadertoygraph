{"ver":"0.1","info":{"id":"wdKBRt","date":"1607793473","viewed":141,"name":"2 point light  & quadratic cube","username":"CY5","description":"2 point light source and quadratic cube","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pointlight","quadraticcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// RayMarching lookup angles,plane,sphere map and rand \n// in below src code taken from iq shadertoy demo\n \n\n//2 point light source demo  c = c0+1/(kc+kl*d+kq*d*d)\n// and quadratic cube\n#define PT   1\n#define SPH  2\n#define PLN  3\n#define CUBE 4\n\n\nvec3  ptLight1Col = vec3(0.764,0.413,0.294);//cyan\nvec3  ptLight2Col = vec3(0.464,0.213,0.294);//magento\n\nvec2 randState;\n\nfloat rand()\n{\n   randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n   randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);        \n    \n   return randState.x;\n}\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 col;\n};\n\nstruct Ob\n{\n    float t;\n    vec3  c;\n    PointLight  ptL; \n    int prop;\n};\n\nfloat mapPlane(vec3 p)\n{\n    float r = 0.5;\n    float l = p.y + (r);\n    return l;\n}\nfloat quadEq(float t)\n{\n    return 1.2*t*t+1.0*t+0.01;\n}\nfloat mapCube(vec3 p, float r)\n{\n    //p=p-vec3(0.5,0.47,2.0);\n    p = p - vec3(0.5,0.47,0.5);\n    vec3 t = vec3(quadEq(p.x),quadEq(p.y),quadEq(p.z));\n    return length(t)-r;\n}\nOb map(vec3 p)\n{\n    Ob o; \n    float tme = iTime*0.5;\n    vec3 pt2 = vec3(0.9*cos(tme),-0.3*sin(tme/2.0),0.8*sin(tme));\n    vec3 pt1 = vec3(0.9*sin(tme),-0.3*sin(tme/2.0),0.8*cos(tme));\n    \n    vec3 mov = p-pt1;\n    vec3 mov1 =  p-pt2;\n    float sph= length(p-vec3(0.0,0.0,0.1))-0.25;\n    float p1 = length(mov)-0.02;\n    float p2 =  length(mov1)-0.02;\n    float pl = mapPlane(p);\n    float cb = mapCube(p,0.25);\n    o.t = min(min(sph,pl),cb);\n    o.t = min(min(p1,p2),o.t);\n    \n    o.ptL.pos = min(mov,mov1);\n    vec3 A= ptLight2Col*(1.0-p2)+ptLight1Col*p2;\n    vec3 B= ptLight1Col*(1.0-p1)+ptLight2Col*p1;\n    \n    o.ptL.col = mix(A,B,0.5);\n    \n    /*vec3 mn = normalize(o.ptL.pos);\n    vec3 dirPt = normalize(pt2 - pt1);\n    float an = dot(mn, dirPt);\n    vec3 A= ptLight1Col;\n    vec3 B= ptLight2Col;\n    o.ptL.col = mix(A,B,an);*/\n    \n    if (sph < pl && sph < cb)\n    {\n        o.c = vec3(0.1,0.1,0.2);\n        o.prop = SPH;\n    \n    }\n    else if (pl < sph && pl < cb)\n    {\n        o.c = vec3(0.1,0.2,0.1);\n        o.prop = PLN;\n    }\n    else if (cb < sph && cb < pl)\n    {\n        o.c = vec3(0.8,0.2,0.5);\n        o.prop = CUBE;\n    }\n    if (p1 < sph && p1 < pl && p1 < cb && p1 < p2)\n    {\n        o.c = ptLight1Col;\n        o.prop = PT;\n        \n    }\n    else if (p2 < sph && p2 < pl  && p2 < cb &&  p2 < p1)\n    {\n        o.c = ptLight2Col;\n        o.prop = PT;\n    }\n    return o;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(map(pos+e.xyy).t-map(pos-e.xyy).t,\n                          map(pos+e.yxy).t-map(pos-e.yxy).t,\n                          map(pos+e.yyx).t-map(pos-e.yyx).t));\n}\n\n\nvoid castRay(in vec3 ro, vec3 rd,inout Ob o)\n{\n    float t =0.0;\n    for(int i=0;i<100;i++)\n    {\n        vec3 pos = ro+t*rd;\n        o = map(pos);\n        float h = o.t;\n        if (h<0.001)\n            break;\n        t+=h;\n        if (t>20.0) break;\n    }\n    if (t>20.0) t=-0.1;\n    o.t =t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    randState = (2.0*fragCoord-iResolution.xy)/iResolution.y ;\n    /*float an = 10.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(2.0*cos(an),-0.3,2.0*sin(an));*/\n    \n    float an = 10.0*fract(0.05*iTime)+iMouse.x/iResolution.x;\n    float up = cos(iTime)-an;\n    vec3 ro = vec3(2.0*cos(an),-0.3*up,2.0*sin(an));\n    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n                        \n    vec3 rd = normalize(p.x*uu+p.y*vv+1.5*ww);\n    \n    vec3 col = vec3(0.0)-0.7*rd.y;\n    \n    Ob o;\n    castRay(ro, rd,o);\n    if (o.t > 0.0) \n    {\n        vec3 pos = ro + o.t*rd;\n        \n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = o.c;\n        nor +=normalize(vec3(0.0,0.0,0.5));\n        vec3 sun_light = (o.ptL.pos);\n        float sun_shad = step(o.t,0.0);\n        \n        float kc=0.3, kl=0.3,kq = 0.03;\n        \n        float d = length(sun_light);\n        vec3 oc = o.ptL.col;\n\n        if (o.prop == SPH)\n        {\n            \n            mate  += ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n            float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n            float boun_dif = clamp(0.9-0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n            \n            col = mate*sun_dif*sun_shad;   \n            col +=mate*sky_dif;    \n            col +=mate*boun_dif; \n        }\n        else if (o.prop == PLN)\n        {\n            mate = ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n            float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n            float boun_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n            col = mate*sun_dif*sun_shad;   \n            col +=mate*sky_dif;    \n            col +=mate*boun_dif;\n        }\n        else if (o.prop == CUBE)\n        {\n            mate = ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n            float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n            float boun_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n            col = mate*sun_dif*sun_shad;   \n            col +=mate*sky_dif;    \n            col +=mate*boun_dif;\n        }\n        else if (o.prop == PT)\n        {\n        \n            vec3 sun_light = o.ptL.pos;\n            \n            float d = length(sun_light-pos);\n            \n            mate += ((1.0/(kc+kl*d+kq*d*d))*o.ptL.col);\n            col = mate;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}