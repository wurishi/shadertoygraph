{"ver":"0.1","info":{"id":"4scfW2","date":"1526764549","viewed":219,"name":"Fractal Terrain Attempt #1","username":"oalpha","description":"An attempt at fractal terrain using ray marching and perlin noise.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal","noise","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct distanceestimation {\n    vec3 p;\n    vec3 s;\n    vec3 d;\n    float l;\n    vec3 n;\n};\nfloat Fuv(vec2 uv) {\n    return texture(iChannel0, Mod(uv, 1.0)).x;\n}\nfloat Fxuv(vec2 uv) {\n    return (Fuv(uv + i2 / iChannelResolution[0].x) - Fuv(uv - i2 / iChannelResolution[0].x)) * 0.5;\n}\nfloat Fyuv(vec2 uv) {\n    return (Fuv(uv + j2 / iChannelResolution[0].y) - Fuv(uv - j2 / iChannelResolution[0].y)) * 0.5;\n}\nfloat Fxyuv(vec2 uv) {\n    return (Fxuv(uv + j2 / iChannelResolution[0].y) - Fxuv(uv - j2 / iChannelResolution[0].y)) * 0.5;\n}\n#define BICUBIC_METHOD 1\n#if BICUBIC_METHOD == 0\nfloat bicubic(vec2 uv) {\n    vec2 res0 = iChannelResolution[0].xy;\n    uv *= res0;\n    vec2 l = floor(uv);\n    vec2 f = fract(uv);\n    mat4 D = mat4(\n        Fuv((l - 1.0) / res0),\n        Fuv((l - i2) / res0),\n        Fuv((l - i2 + j2) / res0),\n        Fuv((l - i2 + 2.0 * j2) / res0),\n        Fuv((l - j2) / res0),\n        Fuv(l / res0),\n        Fuv((l + j2) / res0),\n        Fuv((l + 2.0 * j2) / res0),\n        Fuv((l + i2 - j2) / res0),\n        Fuv((l + i2) / res0),\n        Fuv((l + 1.0) / res0),\n        Fuv((l + 1.0 + j2) / res0),\n        Fuv((l + 2.0 * i2 - j2) / res0),\n        Fuv((l + 2.0 * i2) / res0),\n        Fuv((l + i2 + 1.0) / res0),\n        Fuv((l + 2.0) / res0)\n    );\n    mat4 Dt = transpose(D);\n    mat4 X = mat4(\n        vec4(0.0),\n        D[2] - D[0],\n        D[3] - D[1],\n        vec4(0)\n    );\n    mat4 Y = transpose(mat4(\n        vec4(0.0),\n        Dt[2] - Dt[0],\n        Dt[3] - Dt[1],\n        vec4(0)\n    ));\n    mat2 XY = mat2(\n        Y[2].yz - Y[0].yz,\n        Y[3].yz - Y[1].yz\n    );\n    mat4 a = mat4(\n        1.0, 0.0, -3.0, 2.0,\n        0.0, 0.0, 3.0, -2.0,\n        0.0, 1.0, -2.0, 1.0,\n        0.0, 0.0, -1.0, 1.0\n    );\n    mat4 A = a *  mat4(\n        D[1][1], D[2][1], X[1][1], X[2][1],\n        D[1][2], D[2][2], X[1][2], X[2][2],\n        Y[1][1], Y[2][1], XY[0][0], XY[1][0],\n        Y[1][2], Y[2][2], XY[0][1], XY[1][1]\n    ) * transpose(a);\n    vec4 x = vec4(1.0, f.x, f.x * f.x, f.x * f.x * f.x);\n    vec4 y = vec4(1.0, f.y, f.y * f.y, f.y * f.y * f.y);\n    return dot(x, A * y);\n}\n#else\nfloat bicubic(vec2 uv) {\n    vec2 res0 = iChannelResolution[0].xy;\n    uv *= res0;\n    vec2 l = floor(uv * res0) / res0;\n    vec2 f = fract(uv);\n    mat4 a = mat4(\n        1.0, 0.0, -3.0, 2.0,\n        0.0, 0.0, 3.0, -2.0,\n        0.0, 1.0, -2.0, 1.0,\n        0.0, 0.0, -1.0, 1.0\n    );\n    mat4 A = a *  mat4(\n        Fuv(l),              Fuv(l + j2 / res0),   Fxuv(l)            ,  Fxuv(l + j2 / res0),\n        Fuv(l + i2 / res0),  Fuv(l + 1.0 / res0),  Fxuv(l + i2 / res0),  Fxuv(l + 1.0 / res0),\n        Fyuv(l),             Fyuv(l + j2 / res0),  Fxyuv(l),             Fxyuv(l + j2 / res0),\n        Fyuv(l + i2 / res0), Fyuv(l + 1.0 / res0), Fxyuv(l + i2 / res0), Fxyuv(l + 1.0 / res0)\n    ) * transpose(a);\n    vec4 x = vec4(1.0, f.x, f.x * f.x, f.x * f.x * f.x);\n    vec4 y = vec4(1.0, f.y, f.y * f.y, f.y * f.y * f.y);\n    return dot(x, A * y);\n}\n#endif\nfloat DistanceEstimator(inout distanceestimation d) {\n    vec2 uv = d.p.xy * 0.125;\n    //float displacement = fbm(uv) * 0.5;\n    //#define SIMPLE\n    #define SIMPLE\n    #ifdef SIMPLE\n    vec2 res0 = iChannelResolution[0].xy;\n    uv *= res0;\n    vec2 luv = floor(uv);\n    vec2 fuv = fract(uv);\n    float displacement = 0.0;\n    #ifdef CURVE\n    #undef CURVE\n    #endif\n    #define CURVE(h) curve3(h)\n    vec4 X = CURVE(vec4(\n        1.0 - fuv.x,\n        fuv.x,\n        1.0 - fuv.x,\n        fuv.x\n    ));\n    vec4 Y = CURVE(vec4(\n        1.0 - fuv.y,\n        1.0 - fuv.y,\n        fuv.y,\n        fuv.y\n    ));\n    vec4 F = X * Y;\n    displacement += texture(iChannel0, Mod(luv / res0, 1.0)).x * F.x;\n    displacement += texture(iChannel0, Mod((luv + i2) / res0, 1.0)).x * F.y;\n    displacement += texture(iChannel0, Mod((luv + j2) / res0, 1.0)).x * F.z;\n    displacement += texture(iChannel0, Mod((luv + 1.0) / res0, 1.0)).x * F.w;\n    #else\n    float displacement = bicubic(uv);\n    #endif\n    displacement *= 1.5;\n    d.s = vec3(d.p.xy, displacement);\n    d.l = d.p.z - displacement;\n    return d.l;\n}\nvec3 normal(vec3 p) {\n    float diff = 0.00001;\n    distanceestimation d = distanceestimation(\n        vec3(0.0), //p\n        vec3(0.0), //s\n        vec3(0.0), //d\n        0.0, //l\n        vec3(0.0) //n\n    );\n    d.p = p - diff * i3;\n    float nx = DistanceEstimator(d);\n    d.p = p + diff * i3;\n    float px = DistanceEstimator(d);\n    d.p = p - diff * j3;\n    float ny = DistanceEstimator(d);\n    d.p = p + diff * j3;\n    float py = DistanceEstimator(d);\n    d.p = p - diff * k3;\n    float nz = DistanceEstimator(d);\n    d.p = p + diff * k3;\n    float pz = DistanceEstimator(d);\n    return normalize(vec3(\n        px - nx,\n        py - ny,\n        pz - nz\n    ));\n}\nstruct point {\n    vec3 source;\n    vec3 direction;\n    vec3 position;\n    vec3 normal;\n    float marchlength;\n    int iterations;\n    float closestlength;\n    float closestdistance;\n    float penumbra;\n};\nvoid trace(inout point tracePoint, float k) {\n    float pdis = 1e20, dis;\n    tracePoint.direction = normalize(tracePoint.direction);\n    tracePoint.iterations = 0;\n    distanceestimation d = distanceestimation(\n        vec3(0.0),\n        vec3(0.0),\n        tracePoint.direction,\n        0.0,\n        vec3(0.0)\n    );\n\tfor (int steps = 0; steps < MaximumRaySteps; steps++) {\n        if(\n            tracePoint.iterations == 0\n            || abs(dis) > MinimumDistance\n            && tracePoint.marchlength < MaximumDistance\n            && length(Center - tracePoint.position) < MaximumRadius\n        ) {\n            tracePoint.position = tracePoint.source + tracePoint.marchlength * tracePoint.direction;\n            d.p = tracePoint.position;\n            dis = DistanceEstimator(d);\n            tracePoint.normal = d.n;\n            tracePoint.marchlength += dis;\n            float y = dis*dis/(2.0*pdis);\n\t\t\tfloat d = sqrt(dis*dis-y*y);\n            pdis = dis;\n            if(steps == 0) {\n                tracePoint.closestdistance = d;\n                tracePoint.closestlength = max(0.0,tracePoint.marchlength-y);\n                tracePoint.penumbra = k * d/max(0.0,tracePoint.marchlength-y);\n            }\n            else {\n                if(d < tracePoint.closestdistance) {\n                    tracePoint.closestdistance = d;\n                    tracePoint.closestlength = max(0.0,tracePoint.marchlength-y);\n                }\n                tracePoint.penumbra = min(tracePoint.penumbra, k * d/max(0.0,tracePoint.marchlength-y));\n            }\n            tracePoint.iterations++;\n        }\n\t}\n    if(length(Center - tracePoint.position) > MaximumRadius || tracePoint.marchlength > MaximumDistance) {\n        tracePoint.position = vec3(0.0);\n        tracePoint.iterations = MaximumRaySteps;\n    }\n}\n#define AMBIENT_LIGHT   0\n#define POINT_LIGHT     1\n#define CONE_LIGHT      2\n#define DIRECTION_LIGHT 3\nstruct light {\n    int type;\n    vec3 position;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    float falloff;\n    float spread;\n    float taper;\n};\nlight ambientLight(vec3 color, float intensity) {\n    return  light(\n        AMBIENT_LIGHT, // type\n        vec3(0.0), // position (N/A)\n        color, // color\n        intensity, // intensity\n        vec3(0.0), //direction (N/A)\n        0.0, // falloff (N/A)\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\nlight ambientLight(float color, float intensity) {\n    return ambientLight(vec3(color), intensity);\n}\nlight pointLight(vec3 position, vec3 color, float intensity, float falloff) {\n    return light(\n        POINT_LIGHT, // type\n        position, // position\n        color, // color\n        intensity, // intensity\n        vec3(0.0), //direction (N/A)\n        falloff, // falloff\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\nlight pointLight(vec3 position, float color, float intensity, float falloff) {\n    return pointLight(position, vec3(color), intensity, falloff);\n}\nlight directionLight(vec3 direction, vec3 color, float intensity) {\n    return light(\n        DIRECTION_LIGHT, // type\n        vec3(0.0), // position (N/A)\n        color, // color\n        intensity, // intensity\n        direction, //direction\n        0.0, // falloff (N/A)\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\n#define LAMBERT_DIFFUSE   0\n#define ORENNAYAR_DIFFUSE 1\n#define PHONG_SPECULAR 0\nstruct material {\n    float roughness;\n    vec3 ambientalbedo;\n    int diffusetype;\n    vec3 diffusealbedo;\n    int speculartype;\n    vec3 specularalbedo;\n};\nstruct lightpath {\n    point p;\n    light l;\n    vec3 normal;\n    float ilength;\n    vec3 iray;\n    vec3 vray;\n    vec3 rray;\n    vec2 incident;\n    vec2 view;\n    vec2 reflected;\n    float energy;\n};\nlightpath Lightpath(point p, light l, vec3 n) {\n    vec3 i = vec3(0.0);\n    float il = 0.0;\n    if(l.type == DIRECTION_LIGHT) {\n        i = -l.direction;\n        il = 0.0;\n    }\n    else {\n        i = l.position - p.position;\n        il = length(i);\n        i = normalize(i);\n    }\n    vec3 v = -p.direction;\n    vec3 r = 2.0 * dot(i, n) * n - i;\n    vec3 t = normalize(cross(cross(n, i), n));\n    vec3 tv = normalize(cross(cross(n, v), n));\n    vec3 tr = normalize(cross(cross(n, r), n));\n    float energy;\n    if(l.type != DIRECTION_LIGHT) {\n        energy = l.intensity / pow(il, l.falloff);\n        if(l.type == CONE_LIGHT)\n            energy *= pow((l.spread - acos(dot(-i, l.direction))) / l.spread, l.taper);\n    }\n    else\n        energy = l.intensity;\n    return lightpath(\n        p,\n        l,\n        n,\n        il,\n        i,\n        v,\n        r,\n        vec2(dot(n, i), 0.0), // incident\n        vec2(dot(n, v), dot(t, tv)), // view\n        vec2(dot(n, r), dot(t, tr)), // reflected\n        energy\n    );\n}\nmat3 lookAt(vec3 camera, vec3 target, vec3 up, float film, vec2 fov) {\n    vec3 z = normalize(camera - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return film * mat3(\n        fov.x,0.0,0.0,\n        0.0,fov.y,0.0,\n        0.0,0.0,1.0\n    ) * mat3(x, y, -z);\n}\nvec3 lambert(material m, lightpath lp) {\n    return m.diffusealbedo / PI * lp.l.color * lp.energy * lp.incident.x;\n}\nvec3 orennayar(material m, lightpath lp) {\n    float roughness = tan(0.999 * m.roughness * PI / 2.0);\n    float A = 1.0 - 0.5 * m.roughness / (m.roughness + 0.33);\n    float B = 0.45 * m.roughness / (m.roughness + 0.09);\n    float ca = max(lp.incident.x, lp.view.x);\n    float cb = min(lp.incident.x, lp.view.x);\n    float sa = sqrt(1.0 - ca * ca);\n    float tb = sqrt(1.0 / (cb * cb) - 1.0);\n    return m.diffusealbedo / PI * lp.l.color * lp.energy * lp.incident.x * (A + (B * max(0.0, lp.view.y) * sa * tb));\n}\nvec3 phong(material m, lightpath lp) {\n    float shininess = tan(0.999 * (1.0 - m.roughness) * PI / 2.0);\n    return m.specularalbedo / PI * lp.l.color * lp.energy * lp.incident.x * pow(dot(lp.rray, lp.vray), shininess);\n}\nvoid lighting(inout vec3 r, inout vec3 a, material m, light l, point p, vec3 n) {\n    if(l.type == AMBIENT_LIGHT)\n        a = clamp(a + m.ambientalbedo / PI * l.color * l.intensity, 0.0, 1.0);\n    else {\n        lightpath lp =  Lightpath(p, l, n);\n        vec3 L = vec3(0.0);\n        if(m.diffusetype == LAMBERT_DIFFUSE)\n            L = lambert(m, lp);\n        else if(m.diffusetype == ORENNAYAR_DIFFUSE)\n            L = orennayar(m, lp);\n        vec3 S;\n        if(m.speculartype == PHONG_SPECULAR)\n            L += phong(m, lp);\n        if(false && length(L) > 0.0001) {\n            point sp = point(\n                p.position + lp.iray * 0.01, // source\n                lp.iray, // direction\n                vec3(0.0), // position\n                vec3(0.0), // normal\n                0.0, // marchlength\n                0, // iterations\n                0.0, // closestlength\n                0.0, // closestdistance\n                0.0 // penumbra\n            );\n            trace(sp, 1.0);\n            float sf = exm1_ex(sp.penumbra);\n            sf = 1.0;\n            if(sp.iterations < MaximumRaySteps && sp.marchlength < lp.ilength)\n                sf = 0.0;\n            L *= sf;\n        }\n        r = clamp(r + L, 0.0, 1.0);\n        r = r + L;\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    float h = 2.0 / iResolution.x;\n    //uv.x *= iResolution.x / uResolution.y;\n    float t = 1.0 * iTime * 0.25;\n    //t = 0.;\n    \n    vec3 camera = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t),  cos(t), 0.0,\n           0.0,     0.0, 0.75\n    ) * vec3(3.0, -5.0, 4.0) * 0.5;\n    mat3 raycaster = lookAt(\n        camera,\n        vec3(0.0, 0.0, 0.1), // target\n        vec3(0.0, 0.0, 1.0), // up\n        0.5, // film\n        vec2(1.0) // fov\n    );\n    \n    light la = ambientLight(1.0, 0.0);\n    light lp1 = pointLight(\n        vec3(-32.0, 16.0, 20.0), // position\n        vec3(0.86, 0.91,\t0.96), // color\n        2560.0, // intensity\n        2.0 // falloff\n    );\n    light lp2 = pointLight(\n        vec3(64.0, 96.0, 8.0), // position\n        vec3(1.0,0.97,\t0.86), // color\n        128000.0, // intensity\n        2.0 // falloff\n    );\n    light lp3 = pointLight(\n        vec3(0.5, 0.7, 1.0), // position\n        //vec3(1.0, 0.8, 0.85), // color\n        vec3(1.0, 0.89, 0.85), // color\n        7.5, // intensity\n        1.125 // falloff\n    );\n    material m = material(\n        0.0, // roughness\n        vec3(1.0), // ambientalbedo\n        //LAMBERT_DIFFUSE, // diffusetype\n        ORENNAYAR_DIFFUSE, // diffusetype\n        vec3(.3), // diffusealbedo\n        PHONG_SPECULAR, // speculartype\n        vec3(0.) // specularalbedo\n    );\n    vec3 bg = vec3(0.53, 0.81, 0.98);\n    \n    #define SAMPLES 1\n    vec3 pixel = vec3(0.0);\n    \n    float fsn = float(SAMPLES);\n    float factor = 1.0 / (fsn * fsn);\n    for(int i = 0; i < SAMPLES; i++)\n        for(int j = 0; j < SAMPLES; j++) {\n            vec2 cuv = uv + h * (factor * vec2(float(i), float(j)) - 0.5 + 0.5 / fsn);\n            point p = point(\n                camera, // source\n                raycaster * vec3(cuv, 1.0), // direction\n                vec3(0.0), // position\n                vec3(0.0), // normal\n                0.0, // marchlength\n                0, // iterations\n                0.0, // closestlength\n                0.0, // closestdistance\n                0.0 // penumbra\n            );\n            trace(p, 1.0);\n\n            vec3 v;\n            if(p.iterations < MaximumRaySteps) {\n                vec3 n = p.normal;\n                if(length(n) < 0.001)\n                    n = normal(p.position);\n                vec3 reflection = vec3(0.0), ambient = vec3(0.0);\n                lighting(reflection, ambient, m, lp1, p, n);\n                lighting(reflection, ambient, m, lp2, p, n);\n                lighting(reflection, ambient, m, lp3, p, n);\n                lighting(reflection, ambient, m, la, p, n);\n                float occlusion = 1.0 - float(p.iterations) / float(MaximumRaySteps);\n                \n                // Output to screen\n                v = clamp((reflection + ambient), 0.0, 1.0);\n                //v = vec3(occlusion);\n                //v = n * 0.5 + 0.5;\n                //v = normalize(p) * 0.5 + 0.5;\n                //v = normalize(p) / length(p) * 0.5 + 0.5;\n                //v = mix(v, bg, log(clamp(p.marchlength - 100.0, 0.0, 1.0) + 1.0));\n            }\n            else {\n                v = vec3(0.0);\n                v = bg;\n            }\n            pixel += v * factor;\n        }\n    fragColor = vec4(pixel, 1.0);\n    //fragColor = texture(iChannel0, fragCoord.xy);\n    //fragColor = texture(iChannel0, Mod(uv, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592653589793238462643383279\n#define PI2 6.283185307179586476925286766559\n\n#define i2 vec2(1.0, 0.0)\n#define j2 vec2(0.0, 1.0)\n#define i3 vec3(1.0, 0.0, 0.0)\n#define j3 vec3(0.0, 1.0, 0.0)\n#define k3 vec3(0.0, 0.0, 1.0)\n#define i4 vec4(1.0, 0.0, 0.0, 0.0)\n#define j4 vec4(0.0, 1.0, 0.0, 0.0)\n#define k4 vec4(0.0, 0.0, 1.0, 0.0)\n#define l4 vec4(0.0, 0.0, 0.0, 1.0)\n\n#define duo(a, b) a##b\n#define Iterations 1\n#define fIterations float(Iterations)\n#define Power 8.0\n#define Bailout 2.0\n\n#define MaximumRaySteps 200\n#define MaximumDistance 100.0\n#define MinimumDistance 0.001\n#define MaximumRadius 100.0\n\n#define Center vec3(0.0)\n\n#define CURVE(h) curve5(h)\n#undef CURVE\n#define CURVE(h) curve3(h)\n//#undef CURVE\n//#define CURVE(h) h\n\nfloat Dot(vec2 v) {\n    return dot(v, v);\n}\nfloat Dot2(vec2 a, vec2 b) {\n    float d = dot(a, b);\n    return d * d;\n}\nfloat triple(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\nfloat red_e(vec2 v, float f) {return dot(v, vec2(f));}\nfloat red_e(vec3 v, float f) {return dot(v, vec3(f));}\nfloat red_e(vec4 v, float f) {return dot(v, vec4(f));}\nfloat sum_e(vec2 v) {return red_e(v, 1.0);}\nfloat sum_e(vec3 v) {return red_e(v, 1.0);}\nfloat sum_e(vec4 v) {return red_e(v, 1.0);}\nfloat prod_e(vec2 v) {return v.x * v.y;}\nfloat prod_e(vec3 v) {return v.x * v.y * v.z;}\nfloat prod_e(vec4 v) {return v.x * v.y * v.z * v.w;}\nfloat exm1_ex(float x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec2 exm1_ex(vec2 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec3 exm1_ex(vec3 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec4 exm1_ex(vec4 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nfloat Mod(float a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, vec2  b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, float b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, vec3  b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, float b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, vec4  b) {return a - floor(a / b) * b;}\n\nfloat curve3(float a) {return a * a * (3.0 - 2.0 * a);}\nvec2  curve3(vec2  a) {return a * a * (3.0 - 2.0 * a);}\nvec3  curve3(vec3  a) {return a * a * (3.0 - 2.0 * a);}\nvec4  curve3(vec4  a) {return a * a * (3.0 - 2.0 * a);}\nfloat curve5(float a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec2  curve5(vec2  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec3  curve5(vec3  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec4  curve5(vec4  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(\n         c, -s,\n         s,  c\n    );\n}\nmat3 rotX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(\n         1.0,  0.0,  0.0,\n         0.0,    c,   -s,\n         0.0,    s,    c\n    );\n}\nmat3 rotY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(\n           c,  0.0,    s,\n         0.0,  1.0,  0.0,\n          -s,  0.0,    c\n    );\n}\nmat3 rotZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(\n           c,  -s, 0.0,\n           s,   c, 0.0,\n         0.0, 0.0, 1.0\n    );\n}\nmat4 rotXY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n         1.0, 0.0, 0.0, 0.0,\n         0.0, 1.0, 0.0, 0.0,\n         0.0, 0.0,   c,  -s,\n         0.0, 0.0,   s,   c\n    );\n}\nmat4 rotYZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n           c, 0.0, 0.0,  -s,\n         0.0, 1.0, 0.0, 0.0,\n         0.0, 0.0, 1.0, 0.0,\n           s, 0.0, 0.0,   c\n    );\n}\nmat4 rotZW(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n           c,  -s, 0.0, 0.0,\n           s,   c, 0.0, 0.0,\n         0.0, 0.0, 1.0, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotWX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n         1.0, 0.0, 0.0, 0.0,\n         0.0,   c,  -s, 0.0,\n         0.0,   s,   c, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotYW(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n           c, 0.0,   s, 0.0,\n         0.0, 1.0, 0.0, 0.0,\n          -s, 0.0,   c, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotZX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n         1.0, 0.0, 0.0, 0.0,\n         0.0,   c, 0.0,   s,\n         0.0, 0.0, 1.0, 0.0,\n         0.0,  -s, 0.0,   c\n    );\n}\nmat3 euler_zyx(vec3 a) {return rotX(a.x) * rotY(a.y) * rotZ(a.z);}\nmat4 rot(vec4 a) {return rotXY(a.x) * rotYZ(a.y) * rotZW(a.z) * rotWX(a.w);}\n\nfloat randSin(float x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec2  randSin(vec2  x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec3  randSin(vec3  x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec4  randSin(vec4  x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\n#define RAND randSin\n\nfloat rand(vec2  v, float o, float r, vec2 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nvec2  rand(vec2  v, float o, float r, mat2 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nfloat rand(vec3  v, float o, float r, vec3 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nvec3  rand(vec3  v, float o, float r, mat3 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nfloat rand(vec4  v, float o, float r, vec4 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nvec4  rand(vec4  v, float o, float r, mat4 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nvec2  randRot(vec2  v, mat2 d, vec4 s) {return rot(rand(v, 0.0, PI2, d[0], s)) * vec2(1.0, 0.0);}\nvec3  randRot(vec3  v, mat3 d, vec4 s) {return euler_zyx(rand(v, 0.0, PI2, d, s)) * vec3(1.0, 0.0, 0.0);}\nvec4  randRot(vec4  v, mat4 d, vec4 s) {return rot(rand(v, 0.0, PI2, d, s)) * vec4(1.0, 0.0, 0.0, 0.0);}\n\nfloat perlinGradient(vec2 p, mat2 d, vec4 s) {\n    vec2 r = floor(p);\n    vec2 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++) {\n        vec2 b = vec2(i, j);\n        vec2 B = 1.0 - b;\n        vec2 R = r + b;\n        o += dot(randRot(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o;\n}\nfloat perlinGradient(vec3 p, mat3 d, vec4 s) {\n    vec3 r = floor(p);\n    vec3 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++) {\n        vec3 b = vec3(i, j, k);\n        vec3 B = 1.0 - b;\n        vec3 R = r + b;\n        o += dot(randRot(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o;\n}\nfloat perlinGradient(vec4 p, mat4 d, vec4 s) {\n    vec4 r = floor(p);\n    vec4 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++)\n    for(float l = 0.0; l < 2.0; l++) {\n        vec4 b = vec4(i, j, k, l);\n        vec4 B = 1.0 - b;\n        vec4 R = r + b;\n        o += dot(randRot(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o;\n}\n\nfloat triangle(vec2 a, vec2 b, vec2 c) {\n    vec2 B = b - a, C = c - a;\n    return sqrt(Dot(B) * Dot(C) - Dot2(B, C)) / 2.0;\n}\nfloat tetrahedron(vec3 a, vec3 b, vec3 c, vec3 d) {\n    vec3 B = b - a, C = c - a, D = d - a;\n    return abs(triple(B, C, D)) / 6.0;\n}\nfloat pentachoron(vec4 a, vec4 b, vec4 c, vec4 d, vec4 e) {\n    vec4 B = b - a, C = c - a, D = d - a, E = e - a;\n    return (\n        B.x * triple(C.yzw, D.yzw, E.yzw) -\n        C.x * triple(B.yzw, D.yzw, E.yzw) +\n        D.x * triple(B.yzw, C.yzw, E.yzw) -\n        E.x * triple(B.yzw, C.yzw, D.yzw)\n    ) / 24.0;\n}\n\nivec3 sortD(vec3 v) {\n    if(v.x >= v.y && v.x >= v.z && v.y >= v.z)\n        return ivec3(1, 2, 3);\n    if(v.x >= v.y && v.x >= v.z && v.z >= v.y)\n        return ivec3(1, 3, 2);\n    if(v.y >= v.z && v.y >= v.x && v.z >= v.x)\n        return ivec3(2, 3, 1);\n    if(v.y >= v.z && v.y >= v.x && v.x >= v.z)\n        return ivec3(2, 1, 3);\n    if(v.z >= v.x && v.z >= v.y && v.x >= v.y)\n        return ivec3(3, 1, 2);\n    if(v.z >= v.x && v.z >= v.y && v.y >= v.x)\n        return ivec3(3, 2, 1);\n}\nivec4 sortD(vec4 v) {\n    float x = v.x, y = v.y, z = v.z, w = v.w;\n    if(\n        x >= y && x >= z && x >= w &&\n        y >= z && y >= w &&\n        z >= w\n    )\n        return ivec4(1, 2, 3, 4);\n    if(\n        x >= y && x >= z && x >= w &&\n        y >= z && y >= w &&\n        w >= z\n    )\n        return ivec4(1, 2, 4, 3);\n    if(\n        x >= y && x >= z && x >= w &&\n        z >= y && z >= w &&\n        y >= w\n    )\n        return ivec4(1, 3, 2, 4);\n    if(\n        x >= y && x >= z && x >= w &&\n        z >= y && z >= w &&\n        w >= y\n    )\n        return ivec4(1, 3, 4, 2);\n    if(\n        x >= y && x >= z && x >= w &&\n        w >= y && w >= z &&\n        y >= z\n    )\n        return ivec4(1, 4, 2, 3);\n    if(\n        x >= y && x >= z && x >= w &&\n        w >= y && w >= z &&\n        z >= y\n    )\n        return ivec4(1, 4, 3, 2);\n    if(\n        y >= x && y >= z && y >= w &&\n        x >= z && x >= w &&\n        z >= w\n    )\n        return ivec4(2, 1, 3, 4);\n    if(\n        y >= x && y >= z && y >= w &&\n        x >= z && x >= w &&\n        w >= z\n    )\n        return ivec4(2, 1, 4, 3);\n    if(\n        y >= x && y >= z && y >= w &&\n        z >= x && z >= w &&\n        x >= w\n    )\n        return ivec4(2, 3, 1, 4);\n    if(\n        y >= x && y >= z && y >= w &&\n        z >= x && z >= w &&\n        w >= x\n    )\n        return ivec4(2, 3, 4, 1);\n    if(\n        y >= x && y >= z && y >= w &&\n        w >= x && w >= z &&\n        x >= z\n    )\n        return ivec4(2, 4, 1, 3);\n    if(\n        y >= x && y >= z && y >= w &&\n        w >= x && w >= z &&\n        z >= x\n    )\n        return ivec4(2, 4, 3, 1);\n    if(\n        z >= x && z >= y && z >= w &&\n        x >= y && x >= w &&\n        y >= w\n    )\n        return ivec4(3, 1, 2, 4);\n    if(\n        z >= x && z >= y && z >= w &&\n        x >= y && x >= w &&\n        w >= y\n    )\n        return ivec4(3, 1, 4, 2);\n    if(\n        z >= x && z >= y && z >= w &&\n        y >= x && y >= w &&\n        x >= w\n    )\n        return ivec4(3, 2, 1, 4);\n    if(\n        z >= x && z >= y && z >= w &&\n        y >= x && y >= w &&\n        w >= x\n    )\n        return ivec4(3, 2, 4, 1);\n    if(\n        z >= x && z >= y && z >= w &&\n        w >= x && w >= y &&\n        x >= y\n    )\n        return ivec4(3, 4, 1, 2);\n    if(\n        z >= x && z >= y && z >= w &&\n        w >= x && w >= y &&\n        y >= x\n    )\n        return ivec4(3, 4, 2, 1);\n    if(\n        w >= x && w >= y && w >= z &&\n        x >= y && x >= z &&\n        y >= z\n    )\n        return ivec4(4, 1, 2, 3);\n    if(\n        w >= x && w >= y && w >= z &&\n        x >= y && x >= z &&\n        z >= y\n    )\n        return ivec4(4, 1, 3, 2);\n    if(\n        w >= x && w >= y && w >= z &&\n        y >= x && y >= z &&\n        x >= z\n    )\n        return ivec4(4, 2, 1, 3);\n    if(\n        w >= x && w >= y && w >= z &&\n        y >= x && y >= z &&\n        z >= x\n    )\n        return ivec4(4, 2, 3, 1);\n    if(\n        w >= x && w >= y && w >= z &&\n        z >= x && z >= y &&\n        x >= y\n    )\n        return ivec4(4, 3, 1, 2);\n    if(\n        w >= x && w >= y && w >= z &&\n        z >= x && z >= y &&\n        y >= x\n    )\n        return ivec4(4, 3, 2, 1);\n}\n\nfloat simplexGradient(vec2 p, mat2 d, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    vec2 L = floor(P);\n    vec2 f = fract(P);\n    vec2 c1 = L;\n    vec2 c2 = c1 + (f.x >= f.y ? i2 : j2);\n    vec2 c3 = L + 1.0;\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    float A = triangle(c1, c2, c3);\n    float w1 = CURVE(triangle(p, c2, c3) / A);\n    float w2 = CURVE(triangle(c1, p, c3) / A);\n    float w3 = CURVE(triangle(c1, c2, p) / A);\n    //#define WEIGHT2\n    #ifdef WEIGHT2\n    return vec3(w1 + w2 + w3) * 0.5;\n    #else\n    #define GRADIENT2\n    #ifdef GRADIENT2\n    float v1 = dot(randRot(c1, d, s), p - c1);\n    float v2 = dot(randRot(c2, d, s), p - c2);\n    float v3 = dot(randRot(c3, d, s), p - c3);\n    return (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return vec3(w1 > w2 && w1 > w3 ? v1 : w2 > w1 && w2 > w3 ? v2 : v3);\n    #endif\n    #endif\n}\nfloat simplexGradient(vec3 p, mat3 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = 1.0 / 3.0, unskew = 1.0 / 6.0;\n    #define SKEW\n    #ifdef SKEW\n    vec3 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec3 L = floor(P);\n    vec3 f = fract(P);\n    ivec3 o = sortD(f);\n    vec3 c1 = L;\n    vec3 c2 = c1 + (o.x == 1 ? i3 : o.x == 2 ? j3 : k3);\n    vec3 c3 = c2 + (o.y == 1 ? i3 : o.y == 2 ? j3 : k3);\n    vec3 c4 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    #endif\n    float V = tetrahedron(c1, c2, c3, c4);\n    float w1 = CURVE(tetrahedron(p, c2, c3, c4) / V);\n    float w2 = CURVE(tetrahedron(c1, p, c3, c4) / V);\n    float w3 = CURVE(tetrahedron(c1, c2, p, c4) / V);\n    float w4 = CURVE(tetrahedron(c1, c2, c3, p) / V);\n    //#define WEIGHT3\n    #ifdef WEIGHT3\n    //if(o.x == 1)\n    //    return o.y == 2 ? i3 : 1.0 - i3;\n    //else if(o.x == 2)\n    //    return o.y == 3 ? j3 : 1.0 - j3;\n    //else if(o.x == 3)\n    //    return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec3 g1 = randRot(c1, d, s);\n    vec3 g2 = randRot(c2, d, s);\n    vec3 g3 = randRot(c3, d, s);\n    vec3 g4 = randRot(c4, d, s);\n    vec3 d1 = p - c1;\n    vec3 d2 = p - c2;\n    vec3 d3 = p - c3;\n    vec3 d4 = p - c4;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4);\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nfloat simplexGradient(vec4 p, mat4 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = (sqrt(5.0) - 1.0) / 4.0, unskew = (1.0 - 1.0 / sqrt(5.0)) / 4.0;\n    #define SKEW\n    #ifdef SKEW\n    vec4 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec4 L = floor(P);\n    vec4 f = fract(P);\n    ivec4 o = sortD(f);\n    vec4 c1 = L;\n    vec4 c2 = c1 + (o.x == 1 ? i4 : o.x == 2 ? j4 : o.x == 3 ? k4 : l4);\n    vec4 c3 = c2 + (o.y == 1 ? i4 : o.y == 2 ? j4 : o.y == 3 ? k4 : l4);\n    vec4 c4 = c3 + (o.z == 1 ? i4 : o.z == 2 ? j4 : o.z == 3 ? k4 : l4);\n    vec4 c5 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    c5 -= sum_e(c5) * unskew;\n    #endif\n    float V = pentachoron(c1, c2, c3, c4, c5);\n    float w1 = CURVE(pentachoron(p, c2, c3, c4, c5) / V);\n    float w2 = CURVE(pentachoron(c1, p, c3, c4, c5) / V);\n    float w3 = CURVE(pentachoron(c1, c2, p, c4, c5) / V);\n    float w4 = CURVE(pentachoron(c1, c2, c3, p, c5) / V);\n    float w5 = CURVE(pentachoron(c1, c2, c3, c4, p) / V);\n    //#define WEIGHT3\n    #ifdef WEIGHT3\n    if(o.x == 1)\n        return o.y == 2 ? i3 : 1.0 - i3;\n    else if(o.x == 2)\n        return o.y == 3 ? j3 : 1.0 - j3;\n    else if(o.x == 3)\n        return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4 + w5) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec4 g1 = randRot(c1, d, s);\n    vec4 g2 = randRot(c2, d, s);\n    vec4 g3 = randRot(c3, d, s);\n    vec4 g4 = randRot(c4, d, s);\n    vec4 g5 = randRot(c5, d, s);\n    vec4 d1 = p - c1;\n    vec4 d2 = p - c2;\n    vec4 d3 = p - c3;\n    vec4 d4 = p - c4;\n    vec4 d5 = p - c5;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    float v5 = dot(g4, d5);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4 + v5 * w5) / (w1 + w2 + w3 + w4 + w5);\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    float v5 = rand(c5, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\n\n#define NOISE perlinGradient\n//#undef  NOISE\n//#define NOISE simplexGradient\n#define NOISEITERATIONS 1\nfloat fbm(vec2 p, mat2 ss, float as, mat2 d, vec4 s) {\n    float o = 0.0, a = 1.0;\n    vec4 cs = s;\n    for(int i = 0; i < NOISEITERATIONS; i++) {\n        o += NOISE(p, d, s) * a;\n        p *= ss;\n        a *= as;\n        cs = (cs, 1234.5678, 5678.9012, s);\n    }\n    return o;\n}\nfloat fbm(vec3 p, mat3 ss, float as, mat3 d, vec4 s) {\n    float o = 0.0, a = 1.0;\n    vec4 cs = s;\n    for(int i = 0; i < NOISEITERATIONS; i++) {\n        o += NOISE(p, d, s) * a;\n        p *= ss;\n        a *= as;\n        cs = (cs, 1234.5678, 5678.9012, s);\n    }\n    return o;\n}\nfloat fbm(vec4 p, mat4 ss, float as, mat4 d, vec4 s) {\n    float o = 0.0, a = 1.0;\n    vec4 cs = s;\n    for(int i = 0; i < NOISEITERATIONS; i++) {\n        o += NOISE(p, d, s) * a;\n        p *= ss;\n        a *= as;\n        cs = (cs, 1234.5678, 5678.9012, s);\n    }\n    return o;\n}\nfloat fbm1(vec4 p, mat4 d, vec4 ss) {\n    float o = 0.0, s = 1.0, a = 1.0;\n    vec4 cs = ss;\n    o += NOISE(p * s, d, ss) * a;\n    s *= 2.0;\n    a *= 0.25;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += pow(1.0 - abs(NOISE(p * s, d, ss)), 2.0) * a;\n    s *= 2.0;\n    a *= 0.25;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += pow(1.0 - abs(NOISE(p * s, d, ss)), 2.0) * a;\n    s *= 2.0;\n    a *= 0.5;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += NOISE(p * s, d, ss) * a;\n    return o;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 d4 = mat4(\n        84.4239141, 72.1623789, 54.2539214, 94.8233014,\n        45.8097063, 19.6603408, 41.9881591, 17.7513314,\n        70.6492482, 72.8228071, 31.9941736, 29.7793959,\n        68.9614210, 33.3000043, 38.8602285, 67.0907920\n    );\n    mat3 d3 = mat3(\n        14.4239141, 22.1623789, 14.2539214,\n        45.8097063, 19.6603408, 21.9881591,\n        20.6492482, 32.8228071, 31.9941736\n    );\n    mat2 d2 = mat2(\n        84.4239141, 72.1623789,\n        45.8097063, 19.6603408\n    );\n    mat4 s = mat4(\n        8442.39141, 7216.23789, 5425.39214, 9482.33014,\n        4580.97063, 1966.03408, 4198.81591, 1775.13314,\n        7064.92482, 7282.28071, 3199.41736, 2977.93959,\n        6896.14210, 3330.00043, 3886.02285, 6709.07920\n    );\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    #define SAMPLES 1.0\n    vec3 color = vec3(0.0);\n    if(iFrame == 0) {\n        for(float i = 0.0; i < SAMPLES; i++)\n            for(float j = 0.0; j < SAMPLES; j++) {\n                vec2 cuv = uv + ((vec2(i, j) + 0.5) / SAMPLES - 0.5) / iResolution.xy;\n                cuv *= pow(2.0, 2.0);\n                float t = iTime * 0.125;\n                vec2 tl = 5.0 * rot(t / 5.0) * i2;\n                color += fbm1(vec4(cos(uv.x * PI2), sin(uv.x * PI2), cos(uv.y * PI2), sin(uv.y * PI2)), d4, s[0]) / (SAMPLES * SAMPLES);\n            }\n        fragColor = vec4(color * 0.5 + 0.5,1.0);\n    }\n    else\n    \tfragColor = texture(iChannel0, fragCoord / iChannelResolution[0].xy);\n}","name":"Buffer A","description":"","type":"buffer"}]}