{"ver":"0.1","info":{"id":"MtGSDt","date":"1486409469","viewed":325,"name":"Square spiral test","username":"nomadiclizard","description":"Playing with 2D","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a spiral of successive twisted squares\n\n// a twisted square can be defined as a transformation (rotation and scaling) of the unit square\n// so the inverse matrix will be calculated to turn a point (x,y) back onto this unit square\n// the point is then coloured if it is within a certain distance of the edge of the unit square\n// to do this I clamp a function f(x) that peaks at (0,1) and goes <=0 quickly between them\n// e.g. f(x) = -(x^100-1)^2+1\n// each pixel is then an accumulation of all the squares in the spiral multiplied by a colour\n// which can be parameterised to give ripples outwards \n\n#define pi 3.14159265\n#define twoPi (2.0 * pi)\n\n// matrix to scale and rotate a unit square\nmat2 square(float scale, float angle)\n{\n    mat2 mrot = mat2(cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n    mat2 mscale = mat2(scale, 0.0,\n                       0.0, scale);\n    return mrot * mscale;\n}\n\n// colour function returns 1 when within step of the unit square\nfloat colour(float x, float y)\n{\n    float step = 0.02;\n    if((x >= -1.0 && x <= -1.0 + step) || (x <= 1.0 && x >= 1.0 - step)) {\n         if(y >= -1.0 && y <= 1.0) {\n             return 1.0;\n         }\n    } else if((y >= -1.0 && y <= -1.0 + step) || (y <= 1.0 && y >= 1.0 - step)) {\n        if(x >= -1.0 && x <= 1.0) {\n             return 1.0;\n         }\n    }\n    return 0.0;\n}\n\n// smooth version of above\nfloat colour2(float x, float y)\n{\n    float xx = x * x;\n    float yy = y * y;\n    float xxxx1 = (pow(xx, 8.0) - 1.0);\n    float yyyy1 = (pow(yy, 8.0) - 1.0);\n    float xy = (1.0 - xxxx1 * xxxx1) * step(-yy, 0.0);\n    float yx = (1.0 - yyyy1 * yyyy1) * step(-xx, 0.0);\n    return clamp(xy + yx, 0.0, 1.0);\n}\n\nconst float speed = 0.15;\nconst float scalem = 0.08;\nconst float anglem = 0.25;\nconst float angles = 0.03;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    for (int i = 0; i < 55; i++) {\n        float ii = pow(1.1, float(i) + fract(iTime * speed)) * 0.1;\n        float scale = scalem * ii;\n        float angle = twoPi * (anglem * ii + iTime * angles);\n    \tmat2 s = square(scale, angle);\n    \tmat2 is = inverse(s);\n    \tvec2 p = is * uv;\n        float intensity = 0.4 * colour2(p.x, p.y);\n        fragColor += clamp(vec4(intensity * sin(-iTime + ii), intensity * sin(-1.5 * iTime + ii), intensity * sin(-2.0 * iTime + ii), 0.0), 0.0, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}