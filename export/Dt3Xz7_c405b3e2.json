{"ver":"0.1","info":{"id":"Dt3Xz7","date":"1685149290","viewed":204,"name":"SL2Z - Tiling UHP","username":"stevejtrettel","description":"Test at getting SL2Z up and running","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"7sG3DG","parentname":"SL2Z Tiling Shader"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//vertical line to reflect in\nstruct Line{\nfloat pos;\n};\n\n\n//semicircle centered on real line to reflect in\nstruct Circle{\nfloat center;\nfloat radius;\n};\n\n\n\n\n//turn a real number into a complex number\nvec2 toC( float x ){\n    return vec2(x,0);\n}\n\n\n\n//reflection in vertical line\nvoid invert(inout vec2 p, Line line){\n\n    p.x -= line.pos;\n    \n    p.x *= -1.;\n    \n    p.x += line.pos;\n    \n}\n\n\n\n//reflection in a circle\nvoid invert(inout vec2 p, Circle circle){\n\n    p.x -= circle.center;\n    \n    p /= circle.radius;\n    p /= dot(p,p);\n    p *= circle.radius;\n    \n    p.x += circle.center;\n \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//complex multiplication\nvec2 mult( vec2 z, vec2 w )\n{\n    float re = z.x*w.x - z.y*w.y;\n    float im = z.x*w.y + z.y*w.x;\n\n    vec2 res = vec2(re, im);\n    return res;\n}\n\n\n//complex conjugation, negates imaginary party\nvec2 conj( vec2 z )\n{\n    vec2 res = vec2(z.x,-z.y);\n    return res;\n}\n\n\n//inverse of the complex number z\nvec2 invert( vec2 z )\n{\n    float mag2 = dot(z,z);\n    vec2 res = conj(z)/mag2;\n    return res;\n}\n\n\n//compute the quotient z/w\nvec2 divide( vec2 z, vec2 w )\n{\n    return mult(z,invert(w));\n}\n\n\n//this is a general mobius transformation applied to points in upper half space\n//do the mobius transformation ((a,b),(c,d)).z\nvec2 applyMobius(vec4 mob, vec2 z){\n    float a=mob.x;\n    float b=mob.y;\n    float c=mob.z;\n    float d=mob.w;\n\n    vec2 num = a*z+toC(b);\n    vec2 denom = c*z + toC(d);\n\n    vec2 res = divide(num,denom);\n\n    return res;\n\n}\n\n\n\n\n//measure the distance to a point\nfloat dist(vec2 z, vec2 p){\n\n    //just directly using distance function in UH\n    vec2 rel = z-p;\n    float num = dot(rel,rel);\n    float denom = 2.*z.y*p.y;\n    return acosh(1.+num/denom);\n\n}\n\n\n//measure the distance to a geodesic\nfloat dist(vec2 z, Line line){\n\n        //translate to the origin\n        z.x-=line.pos;\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n    \n    \n  \n    \n\n\nfloat dist(vec2 z, Circle circle){\n    \n    //build mobius transformation taking geo to (0,infty)\n        vec4 mob=vec4(1.,-(circle.center-circle.radius),1.,-(circle.center+circle.radius));\n        z = applyMobius(mob, z);\n\n        //now measure the distance to this vertical line\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n}\n\n\n\n\n\n\n\n\n//set up the fundamental domain\nLine Side1=Line(0.);\nLine Side2=Line(0.5);\nCircle Side3=Circle(0.,1.);\n\n\nvoid reflectInSides(inout vec2 p,inout float invCount){\n    \n    if(p.x<0.){\n        invert(p,Side1);\n        invCount+=1.;\n        }\n   \n   if(p.x>0.5){\n        invert(p,Side2);\n        invCount+=1.;\n        }\n     \n    if(length(p)<1.){\n        invert(p,Side3);\n        invCount+=1.;\n        }\n}\n\n\n\nbool insideFD(vec2 p){\n    return (p.x>0.)&&(p.x<0.5)&&(length(p)>1.);\n}\n\n\n\n\n//move into the fundamental domain\nvoid moveToFD(inout vec2 p,inout float invCount){\n  \n    \n    for(int i=0;i<100;i++){\n    \n        reflectInSides(p,invCount);\n    \n    if(insideFD(p)){\n            break;\n         }\n  \n    }\n}\n\n\n\nvec2 normalizedFragCoord(vec2 fragCoord, bool disk){\n\n // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5,0.));\n    if(disk){\n        uv =(fragCoord/iResolution.xy-vec2(0.5));\n    }\n    \n    //rescale this\n    uv = 4.*vec2(1,iResolution.y/iResolution.x)*uv;\n    \n    \n    return uv;\n}\n\n\nvec2 toUHP(vec2 uv){\n\n//starting from Poincare Disk:\n    float Re = 2.*uv.x;\n    float Im = 1.-dot(uv,uv);\n    vec2 temp=vec2(1.-uv.y,uv.x);\n    float Scale = dot(temp,temp);\n    return 1./Scale*vec2(Re,Im);\n\n    //return uv;\n  }\n\n\n\n\n\n//WHERE DO WE DRAW IT?\nbool disk = false;\n\n\n//colors\nvec3 edgeColor = vec3(170, 210, 255)/255. + vec3(0.2,0.05,0.05);\nvec3 tileColor = vec3(170, 210, 255)/255.;\nvec3 tileColor2 = vec3(140, 190, 250)/255.;\n\n//change out the colors for black and white: comment the above out and\n//uncomment these instead:\n//vec3 edgeColor = vec3(0.2);\n//vec3 tileColor = vec3(0.9);\n//vec3 tileColor2 = vec3(0.8);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord,disk);\n    \n    //UNCOMMENT THIS LINE TO DRAW PICTURE IN POINCARE DISK INSTEAD\n    vec2 p = uv;\n    bool insideDisk;\n    if(disk){\n     p = toUHP(uv);\n     insideDisk = length(uv)<1.;\n    }\n   \n    //reflect into the triangle\n    float invCount=0.;\n    moveToFD(p,invCount);\n\n    // color the pixel based on this\n    float parity = mod(invCount,2.);\n    vec3 col;\n    if(parity==1.){\n        col = tileColor;\n    }\n    \n    else{\n        col = tileColor2;\n    }\n\n    \n    if(dist(p,Line(0.5))<0.02){\n    col=edgeColor;\n    }\n    \n    if(dist(p,Circle(0.,1.))<0.02){\n    col=edgeColor;\n    }\n    \n    if(disk && !insideDisk){\n        col *= 0.25;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}