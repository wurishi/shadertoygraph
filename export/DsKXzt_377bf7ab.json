{"ver":"0.1","info":{"id":"DsKXzt","date":"1682014616","viewed":27,"name":"1st_assignment_FMSDMF","username":"dxhell0o0","description":"ARI","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raycast","camera","postprocess","buffer","lesson"],"hasliked":0,"parentid":"msdXDn","parentname":"CG2023 04"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n//blurry\n    int k = 0;\n    ivec2 pix = ivec2(fragCoord);\n    fragColor = vec4(0);\n    for(int i = -k; i <= k; ++i)\n    {\n        for(int j = -k; j <= k; ++j)\n        {\n            fragColor += texelFetch(iChannel0,pix+ivec2(i,j),0);\n        }\n    }\n    fragColor /= float((2*k+1)*(2*k+1));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n\nconst int spheresNo = 3;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\n// const int triangleNo = 1;\n// Triangle triangles[triangleNo];\n\nconst int tetrahedronNo = 2;\nTetrahedron tetrahedrons[tetrahedronNo];\n\nconst int materialNo = 5;\nMaterial materials[materialNo];\n\n\n\n// Some examples of materials\n// const Material CHROME = Material(vec3(0.9,0.92,0.95), 1.0, 0.0);\n// const Material RED_PLASTIC = Material(vec3(0.95,0.3,0.2), 0.0, 0.1);\n// const Material RED_METAL = Material(vec3(0.95,0.3,0.2), 1.0, 0.2);\n// const Material BLUE_GRIME = Material(vec3(0.0,0.4,0.7), 0.0, 1.0);\n// const Material BLACK_PLASTIC = Material(vec3(0), 0.0, 0.0);\n// const Material GREEN_PLASTIC = Material(vec3(0.2,0.9,0.2), 0.6, vec3(1), 0.0);\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-18,8,5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax,s.materialId); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.materialId);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t, plane.materialId);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n    vec3 a = triangle.a;\n    vec3 b = triangle.b;\n    vec3 c = triangle.c;\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ap = ray.p0 -a ;\n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap, ab);\n    float t = dot(g,ac)/dot(f,ab);\n    float u = dot(f,ap)/dot(f,ab);\n    float v = dot(g,ray.v)/dot(f,ab);\n    if(t >= 0. && u>=0. && v>=0. && u+v<=1.) {\n        vec3 n = normalize(cross(ab,ac));\n        return TraceResult(n,t, triangle.materialId);\n    }\n    return TraceResult(vec3(0),-1., triangle.materialId); \n}\n\nTraceResult intersectTetrahedron(Ray ray, Tetrahedron tetrahedron) \n{\n    Triangle subTriangles[4];\n    subTriangles[0] = Triangle(tetrahedron.a, tetrahedron.b, tetrahedron.c, tetrahedron.materialId);\n    subTriangles[1] = Triangle(tetrahedron.a, tetrahedron.b, tetrahedron.d, tetrahedron.materialId);\n    subTriangles[2] = Triangle(tetrahedron.a, tetrahedron.c, tetrahedron.d, tetrahedron.materialId);\n    subTriangles[3] = Triangle(tetrahedron.d, tetrahedron.b, tetrahedron.c, tetrahedron.materialId);\n\n    vec3 center = ((tetrahedron.a + tetrahedron.b + tetrahedron.c + tetrahedron.d) /4.);\n    vec3 ca = tetrahedron.a - center;\n    vec3 cd = tetrahedron.d - center;\n    int iTr = -1;\n    TraceResult tr[4];\n    for (int i = 0; i < 4; i++)\n    {\n        tr[i] = intersectTriangle(ray, subTriangles[i]);\n        if (tr[i].t > 0.)\n        {\n            if (iTr < 0) {\n                iTr = i;\n            }\n            else {\n                if(tr[i].t < tr[iTr].t) {\n                    iTr = i;\n                }\n            }\n        }\n        if(i < 3)\n        {\n            tr[i].n = dot(tr[i].n, ca) < 0. ? -tr[i].n : tr[i].n;\n        } \n        else\n        {\n            tr[i].n = dot(tr[i].n, cd) < 0. ? -tr[i].n : tr[i].n;\n        }\n    }\n    if(iTr >= 0) return tr[iTr];\n\n    return TraceResult(vec3(0), -1., 0);\n}\n\nfloat Fresnel(vec3 v, vec3 n, float n1, float n2)\n{\n    vec3 t = normalize(refract(v, n, n1/n2));\n    float ci = max(dot(v,n), 0.);\n    float ct = max(-dot(t,n),0.);\n    float Rs = (n1*ci-n2*ct)/(n1*ci+n2*ct); Rs *= Rs;\n    float Rp = (n1*ct-n2*ci)/(n1*ct+n2*ci); Rp *=Rp;\n    return 0.45*0.5*(Rp+Rs)+0.55*sqrt(0.5*(Rs*Rs+Rp*Rp)); //approx\n}\n\nvec3 radiance(vec3 n, vec3 l, vec3 v, vec3 k_d, float light_int, float roughness, float n1, float n2) //n:normal, l: point to light, v: point to view\n{\n    \n    float m = 1. - roughness/7.; //[0,1]\n    vec3 h = normalize(l+v); //half vector\n    float hn = max(dot(h,n), 0.0), vn = max(dot(v,n),0.0);\n    float ln = max(dot(l,n), 0.0), vh = max(dot(v,h),0.0);\n\n    // Geometric Attenutation Factor\n    float G = min( min(2.*hn*vn/vh, 2.*hn*ln/vh),1.0);\n\n    // Microfacet density, normal distribution\n    float hn2 = hn*hn, m2 = m*m; //tan(acos(hn)) optimized away\n    float D = exp((hn2-1.)/(hn2*m2)) / (m2*hn2*hn2*pi);\n\n    float R_spec = Fresnel(l,n, n1, n2); //Fresnel reflectance ratio\n    // float R_spec = R0_spec + (1.-R0_spec)*pow(1.-ln,5.); //Schlick approx\n\n    // Cook-Torrance BRDF\n    vec3 brdf_spec = vec3(R_spec*D*G/(vn*ln));\n\n    // Lambertian BRDF\n    vec3 brdf_diff = k_d*(1.-R_spec);\n\n    // Punctual Light Source\n    return (brdf_spec+brdf_diff)*light_int*ln;\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < tetrahedronNo; ++i)\n    {\n        TraceResult res2 = intersectTetrahedron(ray, tetrahedrons[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n\n    return res;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\nconst vec3 DIELECTRIC_F0 = vec3(0.03);\n#define MIN_BLUR 1.\n#define MAX_BLUR 64.\n#define GAMMA 2.2\n// vec3 getSpecularLightColor( vec3 rd, float roughness )\n// {\n//     roughness = clamp(roughness, 0.0, 1.0);\n//     float lod = log2(mix(MIN_BLUR, MAX_BLUR, roughness));\n//     // The large cubemap does not capture well high-intensity lights,\n//     // so mix it with the small version.\n//     vec3 t0 = pow(textureLod(iChannel2, rd.xzy, lod).rgb, vec3(GAMMA));\n//     vec3 t1 = pow(textureLod(iChannel3, rd.xzy, lod).rgb, vec3(GAMMA));\n//     vec3 col = mix(t0, t1, roughness);\n//     // White balance\n//     vec3 wb = pow(vec3(205.,159.,147.)/255.,vec3(-GAMMA));\n//     return 3.0*wb*col;\n// }\n\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n    vec3 p = ray.p0 + ray.v*tr.t; // hit point\n    vec3 n = tr.n; // normal vector\n\n    // add material\n    Material material = materials[tr.materialId];\n    \n    const int lightNo = 3;\n    vec3 lightPos[lightNo];\n\n    lightPos[0] = vec3(20.,10.,20.);\n    lightPos[1] = vec3(-5, 10., 10);\n    lightPos[2] = vec3(10,10,-10);\n    float lightIntensity = 0.95;\n    \n    vec3 l[lightNo];//vector: surface point -> light\n    float lightDist[lightNo];\n    Ray shadowray[lightNo];\n    TraceResult res[lightNo];\n    vec3 col = vec3(0);\n    for (int i = 0; i < lightNo; i++) {\n        l[i] = lightPos[i] - p;\n        lightDist[i] = length(l[i]);\n        l[i] /= lightDist[i];// normalized direction to the light\n        shadowray[i] = Ray(p+0.001*n, 0.001, l[i], lightDist[i]); // p+0.001*n: prevent surface and ray points overlapping\n\n        res[i] = raycast(shadowray[i]);\n\n       \n\n        if(res[i].t==shadowray[i].tmax)\n        {\n\n            //Ambient\n            vec3 k_a = material.emission;\n            float I_a = 0.2; // ambient intensity\n\n            //diffuse (for refraction)\n\n            //Lambertian reflection formula\n            // vec3 k_d = vec3(1./pi);\n            vec3 k_d = material.color;\n\n            //specular (for reflection)\n            float ph = 100.;\n            vec3 toEye = -ray.v;\n            // vec3 k_s = vec3(0.4);\n            vec3 k_s = vec3(material.metalness);\n\n            float costheta = max(dot(n,l[i]),0.);\n            vec3 toLight = normalize(lightPos[i] - p);\n            vec3 h = normalize(toLight+toEye); \n            /* \n                Blinn-Phong Reflection = Ambient + Diffuse + Specular\n                L = L_a + L_d + L_s\n                L_a = k_a*I_a\n                L_d = k_d(I/r^2)max(0,n*l)\n                L_s = k_s(I/r^2)max(0,n*h)^p\n                k_s:reflection factor, p:smoothness, the larger the smaller light spot\n            */\n\n            \n            float si = pow(clamp(dot(h,n),0.,1.),ph); //Blinn-Phong\n\n\n            vec3 L_s = si*k_s;\n            vec3 L_d = k_d*costheta;\n\n            //sum\n            // col += (k_d + si*k_s + material.metalness)*costheta;\n            // col += (k_d*costheta + k_s*si)*lightIntensity;\n            // vec3 CT = radiance(n, l[i], toEye, k_d, lightIntensity, material.roughness, 1.2, 1.);\n            // col += CT;\n            \n            col += (L_d + L_s)*lightIntensity;\n\n        }\n    }\n    return vec4(col,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n   \n\n    //equilateral triangle\n    float lpc = 2.; // distance of triangle vetex to center\n    // float edgeLength = 3.;\n    // float h = sqrt(3.)/2.*edgeLength;\n    vec2 center = vec2(5,5);\n\n    vec2 ca = center + vec2(lpc*cos(iTime), lpc*sin(iTime));\n    vec2 cb = center + vec2(lpc*cos(iTime+2./3.*PI), lpc*sin(iTime+2./3.*PI));\n    vec2 cc = center + vec2(lpc*cos(iTime-2./3.*PI), lpc*sin(iTime-2./3.*PI));\n\n    //3d height\n    float center_h = 6.; //center sphere center height\n    float t_c_dist = 1.5; //tetrahedron dist to center sphere\n    float th = 3.;\n    float ty1 = center_h + t_c_dist -.4*cos(iTime);\n    float ty2 = center_h - t_c_dist +.4*cos(iTime);\n\n    float dist1 = 5.;\n    float dist2 = 10.;\n    float speed1 = 3.;\n    float speed2 = 2.;\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), 0);\n\n    spheres[0] = Sphere(vec3(center.x,center_h,center.y), 1.f, 1); // center ball\n    spheres[1] = Sphere(vec3(center.x + dist1*sin(iTime*speed1),center_h, center.y + dist1*cos(iTime*speed1)), .7, 3); // surround ball\n    spheres[2] = Sphere(vec3(center.x + dist2*sin(-iTime*speed2),center_h, center.y + dist2*cos(-iTime*speed2)), .9, 4); // surround ball\n\n    tetrahedrons[0] = Tetrahedron(vec3(ca.x,ty1,ca.y), vec3(cb.x,ty1,cb.y),vec3(cc.x,ty1,cc.y),vec3(center.x,ty1+th,center.y), 2);\n    tetrahedrons[1] = Tetrahedron(vec3(ca.x,ty2,ca.y), vec3(cb.x,ty2,cb.y),vec3(cc.x,ty2,cc.y),vec3(center.x,ty2-th,center.y), 2);\n\n    // Materials\n    vec2 uv = fragCoord / iResolution.xy;\n    materials[0] = Material(vec3(0.4,0.4,0.4), 7., vec3(0.4,0.4,0.4), 0.02);// 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    // materials[0] = Material(vec3(0.2,0.9,0.2), 4, texture(iChannel2,uv).rgb, 0.02);\n    materials[1] = Material(vec3(0.95,0.3,0.2), 0.0, vec3(0.98,0.82,0.76), 0.7);\n    // materials[1] = Material(vec3(0.99,0.8,0.06), 0.6, vec3(0.99,0.8,0.06), 0.7);\n    materials[2] = Material(vec3(0.0,0.4,0.7), 0.0, vec3(0.2,0.2,0.2), 0.7);\n    materials[3] = Material(vec3(0.2,0.6,0.2), 7.0, vec3(0.2,0.6,0.2), 0.02);\n    materials[4] = Material(vec3(0.99,0.8,0.06), 0., vec3(0.99,0.8,0.06), 0.05);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // fragColor = 0.2*prev + 0.8*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int materialId;\n};\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int materialId;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    int materialId;\n};\n\nstruct Triangle\n{\n    vec3 a,b,c;\n    int materialId;\n};\n\nstruct Tetrahedron\n{\n    vec3 a,b,c,d;\n    int materialId;\n};\n\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,~7]\n    vec3  emission;\t    // [0, inf] ambient color (rgb value)\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n","name":"Common","description":"","type":"common"}]}