{"ver":"0.1","info":{"id":"WtXBWB","date":"1598276143","viewed":331,"name":"Crazy sun system","username":"savegor","description":"This is a simulation of planets movement. The simpliest Euler method is used for solving Newton's equations of motion, so the trajectories are completely unstable.. You can control this tiny world by mouse. Actually, you can only try to do it.. Have fun!","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["particlesplanetsdynamics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 getPlanetColor(vec2 sun, vec4 sun_view, int index, vec2 pixel) {\n    vec4 planet = get_coords(index);\n   \tvec4 view = get_view(index);\n\n    vec2 diff = planet.xy - pixel;\n    float sqrdist = dot(diff, diff);\n        \n    float rad = view.w;\n\n    float planet_factor = smoothstep(0.8, 1.1, rad * rad / sqrdist);\n    vec4 color;\n    color.xyz = view.xyz * planet_factor;\n    \n    vec2 psun = sun - pixel;\n    vec2 pplan = planet.xy - pixel;\n    \n    float lenpsun = sqrt(dot(psun, psun));\n    float lenpplan = sqrt(dot(pplan, pplan));\n    \n    //float shadow_switch =  sign(dot(psun, pplan));\n    float shadow_switch =  smoothstep(-0.3, 0.3, dot(psun, pplan) / lenpsun / lenpplan);\n    \n    float lighting = (1.0 - SHADOW_STRENGTH) - SHADOW_STRENGTH * shadow_switch;\n    \n    color.xyz *= lighting;\n    \n    color.xyz += planet_factor * max(0.0, lighting) * sun_view.xyz * 500.0 / dot(psun, psun);\n    \n\tcolor.w = planet_factor;\n    return color;\n}\n\n\nfloat noise(vec2 r) {\n    //float cosa = r.x/r.y;\n    float alpha = atan(r.x/r.y);\n    alpha *= sin(3.3434 * alpha);\n    alpha += iTime;\n    return 0.55 * abs(fract(2.0 * cos(15.0 * alpha)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // draw sun\n    vec4 sun = get_coords(0);\n    \n    vec4 sun_view = get_view(0);\n    \n    vec2 diff = sun.xy - fragCoord;\n    float sqrdist = dot(diff, diff);\n    float sun_rad = sun_view.w + noise(diff);\n    vec4 color = vec4(sun_view.xyz * sun_rad * sun_rad / sqrdist, 1.0);\n    \n    float pixel_inside_planet = 0.0;\t\n    // draw planets\n    for(int i = 1; i < N; ++i) {\n        vec4 planet_data = getPlanetColor(sun.xy, sun_view, i, fragCoord);\n        color.xyz += planet_data.xyz;\n        pixel_inside_planet = max(pixel_inside_planet, planet_data.w);\n    }\n    \n    fragColor = color;\n    \n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor += texture(iChannel1, uv) * (1.0 - pixel_inside_planet);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int N = 9;\n\nconst float USE_AUTO_CENTERING = 1.0; // 0.0 for disable this\n\nconst float SHADOW_STRENGTH = 0.2;\nconst float TRACK_STRENGTH = 0.2;\nconst float TRACK_TIME = 500.0;\nconst float TRACK_DIFF = 1.0 / TRACK_TIME;\n\nconst float DT = 0.01;\nconst float PLANET_SCALE = 2.5;\nconst float G = 1.0;\n\nconst float TSHIFT = 0.1;\n\n\n#define get_coords(index) texture(iChannel0,vec2(TSHIFT,float(index)+TSHIFT)/iResolution.xy);\n#define get_prevc(index) texture(iChannel0,vec2(1.0 + TSHIFT,float(index)+TSHIFT)/iResolution.xy);\n#define get_view(index) texture(iChannel0,vec2(2.0 + TSHIFT,float(index)+TSHIFT)/iResolution.xy);\n#define get_data(index) texture(iChannel0,vec2(3.0 + TSHIFT,float(index)+TSHIFT)/iResolution.xy);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat noise(vec2 st) {\n    return abs(fract(100.0 * sin(-130.0 + 0.0001 * -iTime * st.x * st.y)));\n}\n\n\nfloat calc_velocity(float dist, float star_mass) {\n \treturn sqrt(star_mass * G / dist);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) {\n        int index = int(fragCoord.y + TSHIFT);\n        \n        if(index < N) {\n            int cindex = int(fragCoord.x + TSHIFT);\n            \n            vec2 crd = vec2(0.0, 0.0);\n            vec2 vel = vec2(0.0, 0.0);\n            \n            // color + rad\n            vec4 view = vec4(0.0, 1.0, 0.0, 1.0);\n            vec4 data = vec4(1000.0, 0.0, 0.0, 0.0);\n            \n            \n            \n            float width = iResolution.x;\n            float height = iResolution.y;\n            \n            float sun_mass = 200000.0;\n            float sun_x = 0.5 * width;\n            float sun_y = 0.5 * height;\n            \n            // sun\n            if(index == 0) {\n                crd = vec2(sun_x, 0.5 * height);\n                view = vec4(1.4, 0.95,0.675, 10.0);\n                data.x = sun_mass;\n            }\n            \n            float AU = width / 5.0;\n            \n            // mercury\n            if(index == 1) {\n                float planet_x = sun_x - AU * 0.3871;\n                \n                crd = vec2(planet_x, 0.5 * height);\n                float dist = abs(sun_x - planet_x);\n                vel = vec2(0.0, calc_velocity(dist, sun_mass));\n                           \n                view = vec4(1.0, 0.85, 0.675, 1.5);\n            }\n            \n            // venus\n            if(index == 2) {\n                float planet_y = sun_y + AU * 0.7232;;\n                crd = vec2(0.5 * width, planet_y);\n                float dist = abs(sun_y - planet_y);\n                vel = vec2(calc_velocity(dist, sun_mass), 0.0);\n\t\t\t\t\n                data = vec4(2000.0, 0.0, 0.0, 0.0);\n                view = vec4(0.6, 0.85, 0.675, 4.0);\n            }\n            \n            // earth\n            if(index == 3) {\n                float planet_x = sun_x + AU;\n                crd = vec2(planet_x, 0.5 * height);\n                float dist = abs(sun_x - planet_x);\n                vel = vec2(0.0, -calc_velocity(dist, sun_mass));\n                \n                view = vec4(0.0, 0.65, 0.975, 4.5);\n                data = vec4(4000.0, 0.0, 0.0, 0.0);\n\n            }\n            \n            // mars\n            if(index == 4) {\n                float planet_y = sun_y - AU * 1.5236;\n                crd = vec2(0.5 * width, planet_y);\n                float dist = abs(sun_y - planet_y);\n                vel = vec2(-calc_velocity(dist, sun_mass), 0.0);\n                \n                view = vec4(1.0, 0.385, 0.375, 3.0);\n                data = vec4(2000.0, 0.0, 0.0, 0.0);\n\n            }\n\t\t\t\n            \n            // mercury 2\n            if(index == 5) {\n                float planet_x = sun_x - AU * 1.8871;\n                \n                crd = vec2(planet_x, 0.5 * height);\n                float dist = abs(sun_x - planet_x);\n                vel = vec2(0.0, calc_velocity(dist, sun_mass));\n                           \n                view = vec4(0.0, 0.85, 1.0, 1.5);\n            }\n            \n             // venus 2\n            if(index == 6) {\n                float planet_y = sun_y + AU * 2.0;\n                crd = vec2(0.5 * width, planet_y);\n                float dist = abs(sun_y - planet_y);\n                vel = vec2(calc_velocity(dist, sun_mass), 0.0);\n\t\t\t\t\n                data = vec4(2000.0, 0.0, 0.0, 0.0);\n                view = vec4(0.0, 0.85, 0.0, 4.0);\n            }\n            \n            // earth 2\n            if(index == 7) {\n                float planet_x = sun_x + AU * 2.234;\n                crd = vec2(planet_x, 0.5 * height);\n                float dist = abs(sun_x - planet_x);\n                vel = vec2(0.0, -calc_velocity(dist, sun_mass));\n                \n                view = vec4(1.0, 1.0, 1.0, 3.5);\n                data = vec4(5000.0, 0.0, 0.0, 0.0);\n\n            }\n            \n            // mars 2\n            if(index == 8) {\n                float planet_y = sun_y - AU * 2.7236;\n                crd = vec2(0.5 * width, planet_y);\n                float dist = abs(sun_y - planet_y);\n                vel = vec2(-calc_velocity(dist, sun_mass), 0.0);\n                \n                view = vec4(0.2, 0.2, 0.2, 5.0);\n                data = vec4(2000.0, 0.0, 0.0, 0.0);\n\n            }\n\t\t\t\n            \n            view.w *= PLANET_SCALE;\n            \n            switch(cindex) {\n                // coordinates\n            \tcase 0: fragColor = vec4(crd ,vel); break;\n                // prev coordinates\n                case 1: fragColor = vec4(crd ,vel); break;\n                // view\n                case 2: fragColor = view;        break;\n                // other data, mass etc\n                case 3: fragColor = data;        break;\n\n            }\n            \n        }\n    }\n    else {\n        int index = int(fragCoord.y + TSHIFT);\n        int cindex = int(fragCoord.x + TSHIFT);\n                \n        if(index < N && (cindex < 4)) {\n\t\t\tvec4 cur_planet = get_coords(index);\n            vec4 cur_view = get_view(index);\n            vec4 cur_data = get_data(index);\n\t\t\t\n            // mouse control\n            if( iMouse.z > 0.0) {\n                 int mouse_on_index = -1;\n                \n                 // searching for covered plantet\n                 for(int i = 0; i < N; i++) {\n                     vec4 pi = get_prevc(i);\n                 \t vec2 pos_i = pi.xy;                  \n                     vec2 diff = iMouse.zw - pos_i;\n                     \n                     if(dot(diff, diff) < 100.0) {\n                     \tmouse_on_index = i;    \n                     }\n                 }\n\n                // if there is no covered planets - move all\n                // move only found one otherwise \n                if(cindex == 0 && (mouse_on_index == -1 || mouse_on_index == index)) {\n                    vec2 dmouse = iMouse.xy - iMouse.zw;\n                    vec4 prev_pos = get_prevc(index);\n               \n                    // prev_pos.xy += dmouse; // it was broken after a while, TODO: fix\n                    \n                    fragColor = prev_pos;\n                    \n                }\n                else {\n                \tfragColor = texture(iChannel0, fragCoord / iResolution.xy); \n                }\n            }\n            else {\n                // calcluate the next position\n                // (prev is used only for correct mouse control)\n                if(cindex < 2) {\n                    cur_planet.xy += DT * cur_planet.zw;\n\n                    for(int j = 0; j < N; j++) {\n                        if(j != index) {\n                            vec4 pj = get_coords(j);\n                            vec2 pos_j = pj.xy;\n\t\t\t\t\t\t\tvec4 view_j = get_view(j);\n\t\t\t\t\t\t\tvec4 data_j = get_data(j);\n\n                            float mass_j = data_j.x;\n\n                            vec2 rij = pos_j - cur_planet.xy;\n\n                            float dist = sqrt(dot(rij, rij));\n\n                            vec2 accel = G * mass_j * rij / (dist * dist * dist);\n\t\t\t\t\t\t\t\n                            // simple collision handling\n                            float maxdist = cur_view.w + view_j.w;\n                            float collision_factor = sign(dist - 1.1 * maxdist);\n\n                            accel *= collision_factor;\n                            \n                            // apply calculated acceleration\n                            cur_planet.zw += accel * DT;\n                        }\n                    }\n                }\n                \n                // auto centering\n                vec4 sun = get_coords(0);\n                vec2 diff = iResolution.xy * 0.5 - sun.xy;\n                \n                vec2 shift = 0.005 * diff;\n                \n                cur_planet.xy += shift * USE_AUTO_CENTERING;\n                \n                switch(cindex) {\n                    case 0: fragColor = cur_planet; break;\n                    case 1: fragColor = cur_planet; break;\n                    case 2: fragColor = cur_view; break;\n                    case 3: fragColor = cur_data; break;\n                }\n            }\n            \n        }\n        else {\n       \t\tfragColor = texture(iChannel0, fragCoord / iResolution.xy); \n        }        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// track handling\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if(iMouse.z > 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    else {\n        fragColor = texture(iChannel1, uv);\n        fragColor.xyz -= vec3(TRACK_DIFF) * (fragColor.x + fragColor.y + fragColor.z);\n        fragColor.xyz = max(fragColor.xyz, vec3(0.0, 0.0, 0.0));\n        for(int i = 1; i < N; ++i) {\n            vec4 p = get_coords(i);\n            vec4 view = get_view(i);\n            vec2 pos = p.xy;\n            vec2 diff = abs(pos - fragCoord);\n            float dist = dot(diff, diff);\n            float intensity = min(1.0 / (30.0 * max(0.2, dist)), 1.0);\n            fragColor.xyz += view.xyz * intensity;\n            //}\n        }\n        fragColor.xyz = min(vec3(1.0), fragColor.xyz);\n\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}