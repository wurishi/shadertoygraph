{"ver":"0.1","info":{"id":"mlBGW1","date":"1673576073","viewed":57,"name":"Interaction of Color - Ch5","username":"bestknighter","description":"This is a shader version of the exercises found on Chapter 5 of the book Interaction of Color, by Josef Albers. 50th Anniversary Edition.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["color","exercise","interactionsofcolor","colorstudy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/******************************************************\n * Differently from the exercise found on chapter 4,  *\n * this one is harder to replicate in shader form.    *\n * That is because you'll already know the answer     *\n * beforehand. It can still be useful for validating  *\n * what is thought and expected, though.              *\n *                                                    *\n * Feel free to play around with all 2 colors!        *\n * The colors below should be described using values  *\n * between 0 and 1. Click on image to separate the    *\n * squares from each other.                           *\n *                                                    *\n * The goal of this exercise is to familiarize        *\n * yourself with how hard (or easy) it is to notice   *\n * the difference in lightness between two arbitrary  *\n * colors.                                            *\n * Lighter == closer to white                         *\n *                                                    *\n *                                                    *\n * As Albers himself says in his book:                *\n *                                                    *\n *  |  It should be clear that, with these exercises  *\n *  |  and all others to follow, whether or not we    *\n *  |  arrive at a pleasant or harmonious color       *\n *  |  combination is unimportant.                    *\n *                                                    *\n ******************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ar = iResolution.x/iResolution.y;\n    vec3 leftColor = vec3(\n        0.80, // HUE\n        0.60, // SATURATION\n        0.55  // LIGHTNESS\n    );\n    \n    vec3 rightColor = vec3(\n        0.35, // HUE\n        0.60, // SATURATION\n        0.35  // LIGHTNESS\n    );    \n    \n    fragColor = render(\n        fragCoord/iResolution.xy,\n        iResolution.xy,\n        hsl2rgb(leftColor),\n        hsl2rgb(rightColor),\n        int(iMouse.z <= 0.0)\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/***\nMIT License\n\nCopyright (c) 2023 Gabriel F B Barbosa                                     \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n***/\n\n// Although credits are not required,\n// they're strongly encouraged and very much appreciated!\n\nfloat ar;\n\n//  Function from Wikipedia\n//  https://www.wikiwand.com/en/HSL_and_HSV\nvec3 hsl2rgb( in vec3 hsl ) {\n    float a = hsl[1]*min(hsl[2], 1.0-hsl[2]);\n    \n    float k0 = mod(      hsl[0]*12.0, 12.0);\n    float k4 = mod(4.0 + hsl[0]*12.0, 12.0);\n    float k8 = mod(8.0 + hsl[0]*12.0, 12.0);\n    \n    return vec3(\n        hsl[2] - a*clamp(-1.0, 1.0, min(k0 - 3.0, 9.0 - k0)),\n        hsl[2] - a*clamp(-1.0, 1.0, min(k8 - 3.0, 9.0 - k8)),\n        hsl[2] - a*clamp(-1.0, 1.0, min(k4 - 3.0, 9.0 - k4))\n    );\n}\n\nvec4 over(vec4 under, vec4 over) {\n    return over + under*(1.0-over.a);\n}\n\nfloat smoothpass(float center, float thickness, float feather, float x) {\n    return smoothstep(center-feather, center, x + thickness/2.0) -\n           smoothstep(center, center+feather, x - thickness/2.0);\n}\n\nfloat rotatedSquare(vec2 uv, vec2 pos, float size){\n    vec2 dist = (pos-uv)*vec2(ar, 1.0);\n    return smoothstep(size+0.0025, size-0.0025, abs(dist.x) + abs(dist.y));\n}\n\nvec4 render(vec2 uv, vec2 res, vec3 rgbLeft, vec3 rgbRight, int isOverlaping) {\n    vec4 composite = vec4(vec3(0.0), 1.0);\n    \n    float size = min(res.y/2.0-(2.0*20.0), res.x/4.0-(1.0*20.0));\n    composite = over(composite, vec4(rgbLeft, 1.0)*rotatedSquare(uv, vec2((20.0+size)/res.x, 0.5), size/res.y));\n    vec2 rightSqXs = vec2(\n        1.0-((20.0+size)/res.x),\n        (20.0+2.33*size)/res.x\n    );\n    composite = over(composite, vec4(rgbRight, 1.0)*rotatedSquare(uv, vec2(rightSqXs[isOverlaping], 0.5), size/res.y));\n    \n    return composite;\n}\n","name":"Common","description":"","type":"common"}]}