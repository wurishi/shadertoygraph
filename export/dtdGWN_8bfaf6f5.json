{"ver":"0.1","info":{"id":"dtdGWN","date":"1682480164","viewed":72,"name":"Sphere Intersection by ChatGPTÂ ","username":"invivel","description":"Sphere Intersection by ChatGPT","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","intersection","chatgpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool intersectRaySphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius, out float t)\n{\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(oc, rayDirection);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0)\n    {\n        // No intersection\n        return false;\n    }\n    \n    float sqrtDiscriminant = sqrt(discriminant);\n    float t1 = (-b - sqrtDiscriminant) / (2.0 * a);\n    float t2 = (-b + sqrtDiscriminant) / (2.0 * a);\n    \n    if (t1 > t2)\n    {\n        // Swap t1 and t2 to make sure t1 is the smaller value\n        float temp = t1;\n        t1 = t2;\n        t2 = temp;\n    }\n    \n    if (t2 < 0.0)\n    {\n        // Both intersection points are behind the ray\n        return false;\n    }\n    \n    // Store the intersection point along the ray in the 't' output variable\n    t = t1;\n    \n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Ray origin (camera position)\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    \n    // Ray direction (normalized)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    \n    // Sphere properties\n    vec3 sphereCenter = vec3(0.0, 0.0, 4.0);\n    float sphereRadius = 1.0;\n    \n    // Light properties\n    vec3 lightDirection = normalize(vec3(1.0,-1.0, 0.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float ambientStrength = 0.1;\n    float specularStrength = 0.5;\n    float shininess = 32.0;\n    \n    // Intersection test\n    float t;\n    bool hit = intersectRaySphere(rayOrigin, rayDirection, sphereCenter, sphereRadius, t);\n    \n    if (hit)\n    {\n        // Calculate normal at intersection point on the sphere\n        vec3 sphereNormal = normalize(rayOrigin + t * rayDirection - sphereCenter);\n        \n        // Calculate light direction\n        vec3 lightDir = -lightDirection;\n        \n        // Calculate ambient light contribution\n        vec3 ambient = ambientStrength * lightColor;\n        \n        // Calculate diffuse light contribution\n        float diffuseFactor = max(dot(sphereNormal, lightDir), 0.0);\n        vec3 diffuse = diffuseFactor * lightColor;\n        \n        // Calculate specular light contribution\n        vec3 viewDir = normalize(rayOrigin - (sphereCenter + t * rayDirection));\n        vec3 reflectDir = reflect(-lightDir, sphereNormal);\n        float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n        vec3 specular = specularStrength * specularFactor * lightColor;\n        \n        // Combine lighting contributions with sphere color\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0); // Sphere base color\n        vec3 lighting = ambient + diffuse + specular;\n        fragColor = vec4(sphereColor * lighting, 1.0);\n    }\n    else\n    {\n        // If no intersection, set color to black\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}