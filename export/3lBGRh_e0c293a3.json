{"ver":"0.1","info":{"id":"3lBGRh","date":"1558365477","viewed":188,"name":"Simplex Noise Explained","username":"DanielMz25","description":"Simplex Noise explanation.\nThis is not original simplex noise. It's still unfinished. Gradients - Noise transition is ugly.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["simplexnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 gradients[4] = vec2[4](\n    vec2(1.0,1.0),vec2(1.0,-1.0),\n    vec2(-1.0,-1.0),vec2(-1.0,1.0));\n\nconst float pi = 3.141592653589793238462643383279502884157169399375105820974944592307816406286208998628034825342117067982148086513282;\n\nconst vec3 rainbowColors[6] = vec3[6](\n    vec3(1.0,0.0,0.0),vec3(1.0,0.5,0.0),vec3(1.0,1.0,0.0),\n    vec3(0.0,0.75,0.0),vec3(0.0,0.75,1.0),vec3(0.5,0.0,1.0));\n    \nfloat hash(vec2 v)\n{\n    float h = v.x * 1.0071 + v.y * 0.9873;\n    h = fract((h+0.00103)*v.x*0.927) + fract((h+0.0010421)*v.y*1.0219);\n    h = fract(h*2184.72427142 + 1.732);\n    h = fract(h * 21982.623632 + 4.637235);\n    return h;\n}\n\n\n\nvec3 rainbow(float f)\n{\n    f = clamp(f,0.0,1.0);\n    f = f*6.0;\n    float ff = floor(f);\n\treturn mix(rainbowColors[int(ff)],rainbowColors[int(min(4.99,ff))+1],f-ff);\n}\n\nfloat sFac(float f)\n{\n    return 0.5-cos(clamp(f,0.0, 1.0)*pi)*0.5;\n}\n\nfloat grid(vec2 uv, vec2 size)\n{\n\tvec2 uv0 = floor(uv);\n    \n    return step(uv.x - uv0.x, size.x) \n        + step(uv.y - uv0.y, size.y);\n}\n\nfloat vector(vec2 v0, vec2 v, vec2 uv, float dotSize, float lineWidth)\n{\n    vec2 v1 = uv - v0;\n    float v1Len = length(v1);\n    \n    float dotVal = step(v1Len, dotSize);\n    \n    vec2 vDot = vec2(dot(v1,v) , dot(vec2(-v.y,v.x),v1));\n    \n    float vecVal = step(vDot.x,0.0)*step(abs(vDot.y), lineWidth)*step(v1Len, length(v));\n        \n    return max(dotVal, vecVal);\n}\n\nfloat gradient(vec2 v0, vec2 v, vec2 uv)\n{\n    vec2 v1 = v0 - uv;   \n    return dot(v1,v);\n}\n\nfloat pNoiseTransition(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    vec2 fac = uv-v0;\n    vec2 facSmooth = vec2(sFac(fac.x),sFac(fac.y));\n    vec2 fac2 = vec2(step(0.5,fac.x),step(0.5,fac.y));\n    \n    float transition = (clamp(sin(iTime)*0.5+0.5,0.3,0.7)-0.3)/0.4;\n    \n    //fac = mix(facSmooth,fac2,1.0-transition);\n    \n    fac = (fac-0.5)*pow(32.0,transition)+0.5;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    float g = mix(g01,g23,fac.y);\n    \n    return g*0.5+0.5;\n}\n\nfloat pNoise(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    vec2 fac = uv-v0;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    float g = mix(g01,g23,fac.y);\n    \n    return g*0.5+0.5;\n}\n\nconst float unskewVal = (3.0-sqrt(3.0))/6.0;\nconst float skewVal = (sqrt(3.0)-1.0)/2.0;\nconst float xyDelta = 1.0 - 2.0*unskewVal;\n\nfloat sNoise(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    p0*=p0;\n    p1*=p1;\n    p2*=p2;\n    \n    float ret = 0.0;\n    \n    ret += p0*p0*gradient(uv0, gradients[int(hash(i0)*4.0)], uv);\n    ret += p1*p1*gradient(uv1, gradients[int(hash(i1)*4.0)], uv);\n    ret += p2*p2*gradient(uv2, gradients[int(hash(i2)*4.0)], uv);\n        \n    return 0.5+ret*25.0;\n}\n\nfloat sNoiseTransition(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    float transition = (clamp(sin(iTime)*0.5+0.5,0.3,0.7)-0.3)/0.4;\n    \n\tfloat pp0 = mix(pow(p0,4.0),step(max(p1,p2), p0)*0.034, transition);    \n    float pp1 = mix(pow(p1,4.0),step(max(p0,p2), p1)*0.034, transition);\n    float pp2 = mix(pow(p2,4.0),step(max(p1,p0), p2)*0.034, transition);\n    \n    p0=pp0;\n    p1=pp1;\n    p2=pp2;\n    /*\n    \n    float tr0 = pow(25.0,transition);\n    float tr1 = 0.315*(pow(transition,0.4));\n    float tr2 = 0.05*(transition);\n    \n    p0 = clamp(p0-tr1,0.0,0.5);\n    p1 = clamp(p1-tr1,0.0,0.5);\n    p2 = clamp(p2-tr1,0.0,0.5);\n    \n    p0 = clamp(p0*tr0,0.0,0.5-tr2);\n    p1 = clamp(p1*tr0,0.0,0.5-tr2);\n    p2 = clamp(p2*tr0,0.0,0.5-tr2);\n    \n    p0 = pow(p0,4.0);\n    p1 = pow(p1,4.0);\n    p2 = pow(p2,4.0);*/\n    \n\t/*p0 = step(0.013,p0)*0.04;\n    p1 = step(0.013,p1)*0.04;\n    p2 = step(0.013,p2)*0.04;*/\n    \n    float ret = 0.0;\n    \n    ret += p0*gradient(uv0, gradients[int(hash(i0)*4.0)], uv);\n    ret += p1*gradient(uv1, gradients[int(hash(i1)*4.0)], uv);\n    ret += p2*gradient(uv2, gradients[int(hash(i2)*4.0)], uv);\n        \n    return 0.5+ret*25.0;\n}\n\nfloat simplexGrid(vec2 uv, vec3 size)\n{\n    vec2 u_uv = uv;\n    \n\tuv = uv + (uv.x+uv.y) * skewVal;\n    vec2 uv0 = floor(uv);\n    \n    vec2 u_uv0 = uv0 - (uv0.x+uv0.y)*unskewVal;\n    u_uv = u_uv - u_uv0;\n    \n    return step(uv.x - uv0.x, size.x) \n        + step(uv.y - uv0.y, size.y)\n        + step(abs(u_uv.x-u_uv.y),size.z);\n}\n\nfloat simplexVectors(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    float ret = 0.0;\n    \n    if(p0 > p1 && p0 > p2)\n        ret = vector(uv0, gradients[int(hash(i0)*4.0)], uv, 0.06, 0.03);\n    else if(p1 > p0 && p1 > p2)\n        ret = vector(uv1, gradients[int(hash(i1)*4.0)], uv, 0.06, 0.03);\n    else\n        ret = vector(uv2, gradients[int(hash(i2)*4.0)], uv, 0.06, 0.03);\n        \n    return ret;\n}\n\nfloat simplexGradients(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    float ret = 0.0;\n    \n    if(p0 > p1 && p0 > p2)\n        ret = gradient(uv0, gradients[int(hash(i0)*4.0)], uv);\n    else if(p1 > p0 && p1 > p2)\n        ret = gradient(uv1, gradients[int(hash(i1)*4.0)], uv);\n    else\n        ret = gradient(uv2, gradients[int(hash(i2)*4.0)], uv);\n        \n    return 0.5+ret*0.5;\n}\n\nvec3 rainbowNoise(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tvec3 g0 = rainbow(gradient(v0, gradients[int(hash(v0)*4.0)], uv)*0.5+0.5);\n\tvec3 g1 = rainbow(gradient(v1, gradients[int(hash(v1)*4.0)], uv)*0.5+0.5);\n    vec3 g2 = rainbow(gradient(v2, gradients[int(hash(v2)*4.0)], uv)*0.5+0.5);\n    vec3 g3 = rainbow(gradient(v3, gradients[int(hash(v3)*4.0)], uv)*0.5+0.5);\n    \n    vec2 fac = uv-v0;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    vec3 g01 = mix(g0,g1,fac.x);\n    vec3 g23 = mix(g3,g2,fac.x);\n    \n    vec3 g = mix(g01,g23,fac.y);\n    \n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/50.0 + 2.0*iTime*0.1;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float transition = (clamp(sin(iTime*0.5)*0.25+0.5,0.3,0.7)-0.3)/0.4;\n    \n    float gridRet = simplexGrid(uv,vec3(0.05,0.05,0.025))*transition*0.5;\n    \n    float vecRet = simplexVectors(uv) * transition;\n   \n    //float gradRet = simplexGradients(uv);\n    float gradRet = sNoiseTransition(uv);\n    \n    float NoGrad = clamp(1.0 - gridRet - vecRet, 0.0 ,1.0);\n    \n    // Output to screen\n    //fragColor = vec4(vec3(gridRet),1.0);\n    //fragColor = vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,vecRet,vecRet,1.0);\n    //fragColor = vec4(vec3(sNoise(uv)),1.0);\n    fragColor = vec4(vec3(gradRet)*NoGrad,1.0) + vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,0.0,0.0,1.0);\n    //fragColor = vec4(rainbowNoise(uv)*NoGrad,1.0) + vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,0.0,0.0,1.0);\n\t//fragColor = vec4(vec3(gradRet),1.0);\n    //fragColor = vec4(vec3((pNoise(uv)*0.5+pNoise(uv*2.26+320.0)*0.25+pNoise(uv*4.12+128.0)*0.125)*0.5+0.5),1.0);\n}","name":"Image","description":"","type":"image"}]}