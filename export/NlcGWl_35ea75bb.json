{"ver":"0.1","info":{"id":"NlcGWl","date":"1637555507","viewed":109,"name":"Pointed hexagon tunnel","username":"HaleyHalcyon","description":"a","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"sltGD2","parentname":"starburst hexagon tunnel"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n// i want to use hex codes like in image editing programs,\n// so here's an improved macro by FabriceNeyret2\n#define HEX(x) vec3( ( ivec3(x) >> ivec3(16,8,0) ) & 255 ) / 255.\n\nvec3 color(float x){\n    const int colorCount = 5;\n    vec3[] c = vec3[](\n        vec3(0),\n        HEX(0xa0ffe0),\n        HEX(0x8000a0),\n        HEX(0x7080F0),\n        vec3(1)\n    );\n    x = fract(-x);\n    x = x * x * x * float(colorCount);\n    int lo = 1048576 + int(floor(x));\n    \n    return mix(\n        c[lo % colorCount],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\nfloat shape(vec2 uv, float angle) {\n    float a = atan(uv.y, uv.x) + angle;\n    float d = length(uv);\n    return d * (1. + 0.5 * abs(sin(a * 3.))); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 3.0);\n  // make the center of the canvas (0.0, 0.0) and\n  // make the long edge of the canvas range from -1.0 to +1.0\n  // we'll use the scale variable later for antialiasing bc it's the size of one pixel\n  float scale = max(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n\n  // i blend each square's color in order to antialias this shader\n  // are you proud of me yet Fabrice\n  vec3 col = vec3(0., 0., 0.);\n  float opacity = 0.;\n  float colOffset = 0.03;\n  const float iters = 48.;\n  float size = 1.3;\n  float sizeMult = 0.88;\n  float angleOffset = 0.03 * (2.0 + sin(time * TAU));\n  float evenOffset = (1. + sin(time * TAU));\n  // i know, loops in glsl code, ew right\n  for (float i = 0.; i < iters; i++) {\n      // subtract from size and multiply by scale to get\n      // a nice \"pixels from boundary\" value\n      float dist = (shape(\n          uv, -time * TAU + angleOffset * i + evenOffset * mod(i, 2.)\n      ) - size) * -scale;\n      //dist /= 8.; // antialias debug\n      vec3 thisColor = color(time * 3. + colOffset * i);\n      if (\n          dist <= 0.\n      ) {\n          col += (1. - opacity) * thisColor;\n          opacity = 1.;\n      } else if (\n          dist < 1.\n      ) {\n          float newOpacity = max(0., (1. - dist) * (1. - opacity));\n          col += newOpacity * thisColor;\n          opacity += newOpacity;\n      } else {\n          // do nothing\n      }\n      // i'm not sure if this saves time for gpu calculation\n      // but i'm doing it anyway because it pleases me:\n      if (opacity >= 1.) {break;}\n      \n      size *= sizeMult; // better than calling pow()\n  }\n  \n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}","name":"Image","description":"","type":"image"}]}