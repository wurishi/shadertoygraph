{"ver":"0.1","info":{"id":"4cXXDs","date":"1707732489","viewed":23,"name":"[inspirnathan] 07 - Rotation3D","username":"hrst4","description":"[inspirnathan] 07 - Rotation3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\n#define PART 3\n/*\nBonjour, chers amis ! Bienvenue dans la huitième partie de ma série de tutoriels Shadertoy.\nDans ce tutoriel, nous allons apprendre à faire pivoter des objets 3D à l'aide de matrices de transformation.\n\n# Setup initial\n\nCréons un nouveau shader et utilisons le code de la fin de la partie 7 de cette série Shadertoy.\nCependant, nous allons supprimer les sphères.\n\n\n*/\n\n#if PART == 0\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nUne fois le code exécuté, vous devriez voir un sol carrelé et un arrière-plan bleu clair.\nhttps://inspirnathan.com/_nuxt/img/img-1.3a58ba8.png\n\n# Ajouter un cube\n\nEnsuite, nous allons ajouter un cube en utilisant une liste de SDF 3D provenant du site web d'Inigo Quilez.\nDans la section \"Primitives\", vous trouverez un SDF intitulé \"Box - exact\" que nous utiliserons pour rendre un cube.\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nPour que cela soit compatible avec le code que nous avons appris dans le tutoriel précédent et pour ajouter \nune couleur unique à l'objet, nous devons retourner une valeur de type Surface au lieu d'une valeur flottante. \n\nNous ajouterons également deux paramètres à la fonction : offset et color.\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col)\n{\n  p = p - offset;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nLe premier paramètre, p, est le point d'échantillonnage et le second, b, est une variable vec3 qui représente \nles limites de la boîte. \n\nUtilisez les composantes x, y et z pour contrôler la largeur, la hauteur et la profondeur de la boîte. \nSi ces trois composantes ont la même valeur, nous obtenons un cube.\n\nInsérons un cube dans notre scène 3D :\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0)));\n  return co;\n}\n\nCe cube aura pour dimensions 1x1x1, aura pour position (0, 0.5, -4) et sera de couleur rouge.\nhttps://inspirnathan.com/_nuxt/img/img-2.37ce0dc.png\n\n*/\n\n#elif PART == 1\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col)\n{\n  p = p - offset;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\n\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Matrices de rotation\nEn algèbre linéaire, les matrices de transformation sont utilisées pour effectuer diverses opérations sur des formes 2D et 3D : \nétirement, compression, rotation, shearing et réflexion. Chaque matrice représente une opération.\n\nEn multipliant les points d'un graphique (ou les points d'échantillonnage dans notre code GLSL) par une matrice de transformation, \nnous pouvons effectuer n'importe laquelle de ces opérations. Nous pouvons également multiplier n'importe laquelle de ces\nmatrices de transformation pour créer de nouvelles matrices de transformation qui effectuent plus d'une opération.\n\nLa multiplication des matrices n'étant pas commutative, l'ordre dans lequel nous multiplions les matrices a de l'importance. \nSi vous faites pivoter une forme avant de le shearing, vous obtiendrez un résultat différent de celui que vous obtiendriez \nsi vous effectuez le shear d'abord avant de la faire pivoter. \n\nDe même, si vous faites pivoter une forme sur l'axe des x puis sur l'axe des z, \nvous obtiendrez un résultat différent si vous avez inversé l'ordre de ces opérations.\n\nUne matrice de rotation est un type de matrice de transformation. \nJetons un coup d'œil aux matrices de rotation que nous utiliserons dans ce tutoriel.\n\nhttps://inspirnathan.com/_nuxt/img/img-3.702bd68.png\n\nDans l'image ci-dessus, nous avons trois matrices de rotation, une pour chaque axe en 3D. \nElles nous permettent de faire tourner une forme autour d'un axe comme s'il s'agissait d'un gymnaste se balançant\nautour d'une barre ou d'un poteau.\n\nEn haut de notre code, ajoutons des fonctions pour les matrices de rotation sur chaque axe. \nNous ajouterons également une fonction qui renvoie une matrice d'identité afin de pouvoir choisir de n'effectuer \naucune sorte de transformation.\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nNous devons maintenant ajuster la fonction sdBox pour qu'elle accepte les transformations matricielles \ncomme autre paramètre. \n\nNous allons multiplier le point d'échantillonnage par la matrice de rotation. \n\nCette transformation sera appliquée après que le point d'échantillonnage aura été déplacé vers une certaine\ncoordonnée mondiale définie par le décalage.\n\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nNous devons ensuite modifier la fonction sdScene pour insérer un nouveau paramètre dans l'appel à la fonction sdBox :\n\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), rotateX(iTime)));\n  return co;\n}\n\nNous pouvons utiliser rotateX, rotateY et rotateZ pour faire tourner le cube sur l'axe x, l'axe y et l'axe z, \nrespectivement. \n\nL'angle sera fixé à iTime, ce qui nous permettra d'animer la rotation du cube en fonction du temps. \n\nLe point de pivot du cube sera son propre centre.\n\nVoici un exemple de rotation du cube sur l'axe x à l'aide de rotateX(iTime) dans l'appel à la fonction sdBox.\nhttps://inspirnathan.com/_nuxt/img/gif-1.caacb2e.gif\n\nVoici un exemple de rotation du cube sur l'axe des y en utilisant rotateY(iTime) dans l'appel à la fonction sdBox.\nhttps://inspirnathan.com/_nuxt/img/gif-2.fbe7695.gif\n\nVoici un exemple de rotation du cube sur l'axe z en utilisant rotateZ(iTime) dans l'appel à la fonction sdBox.\nhttps://inspirnathan.com/_nuxt/img/gif-3.6f34ef7.gif\n\nPour éviter toute rotation, nous pouvons faire appel à la fonction d'identité :\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), identity())); // By using the identity matrix, the cube's orientation remains the same\n  return co;\n}\n\nVous pouvez également combiner des transformations matricielles individuelles en les multipliant.\nLe cube tournera alors simultanément sur tous les axes.\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(\n      p,\n      vec3(1),\n      vec3(0, 0.5, -4),\n      vec3(1, 0, 0),\n      rotateX(iTime) * rotateY(iTime) * rotateZ(iTime) // Combine rotation matrices\n  ));\n  return co;\n}\n\n\n\n*/\n\n#elif PART == 2\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(\n      p,\n      vec3(1),\n      vec3(0, 0.5, -4),\n      vec3(1, 0, 0),\n      rotateX(iTime)*rotateY(iTime)*rotateZ(iTime) // Combine rotation matrices\n  ));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nRotation autour d'un point de pivot\n\nSi nous voulions donner l'impression que le cube tourne autour d'un point de pivot externe qui n'est pas le centre du cube, \nnous devrions modifier la fonction sdBox pour déplacer le cube d'une certaine distance après la transformation.\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform - vec3(3, 0, 0); // Move the cube as it is rotating\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSi nous utilisons rotateY(iTime) dans la fonction sdScene, le cube semble tourner autour de l'axe y \nle long d'un point de pivot situé à une certaine distance du cube. Dans cet exemple, nous utilisons vec3(3, 0, 0) \npour maintenir le cube à une distance de 3 unités pendant qu'il tourne autour du point pivot situé à \n(0, 0.5, -4), qui est le décalage que nous avons attribué à sdBox dans la fonction sdScene.\n\nhttps://inspirnathan.com/_nuxt/img/gif-5.e8a5960.gif\n\nVoici le code complet utilisé pour créer l'image ci-dessus :\n\n*/\n\n\n#elif PART == 3\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform - vec3(3, 0, 0); // Move the cube as it is rotating\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), rotateY(iTime)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n\n/*\n# Conclusion\nDans ce tutoriel, nous avons appris à faire pivoter notre cube sur chaque axe dans l'espace 3D. \nNous avons également appris à faire pivoter les cubes autour d'un point de pivot externe pour donner \nl'impression qu'ils tournent autour d'un point dans l'espace.\n\nCe que vous avez appris aujourd'hui peut également s'appliquer à tous les autres objets 3D. \nNous avons choisi un cube plutôt qu'une sphère car il est plus facile de vérifier si nos matrices de \nrotation fonctionnent avec des cubes plutôt qu'avec des sphères.\n*/\n\n\n\n#endif","name":"Image","description":"","type":"image"}]}