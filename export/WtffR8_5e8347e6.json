{"ver":"0.1","info":{"id":"WtffR8","date":"1595916411","viewed":100,"name":"Moon Fishing","username":"makkotech","description":"by rakurai5","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define TAU 6.28318530718\n#define Octaves 4\n#define PI2 6.28318530718\n\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\nfloat opSubtraction(float d1, float d2) { return max(d1, -d2); }\nfloat opOnion(float d, float thikness) { return abs(d) - thikness; }\n\nfloat noise(vec2 pixuv, float t, vec2 p){\n    vec2 p2 = mod(pixuv*TAU, TAU)-250.0;\n\tvec2 s = vec2(p2);\n\tfloat c = 1.0;\n\tfloat inten = 0.005;\n    \n    for (int n = 0; n < Octaves; n++) \n\t    {\n\t\t    float ti = t * (1.0 - (3.0 / float(n+1)));\n\t\t    s = p + vec2(cos(ti - s.x) + sin(ti + s.y), sin(ti - s.y) + cos(ti + s.x));\n\t\t    c += 1.0/length(vec2(p2.x / (sin(s.x+t)/inten),p2.y / (cos(s.y+t)/inten)));\n\t    }\n\t    c /= float(Octaves);\n\t    c = 1.17-pow(c, 1.4);\n    return c;\n}\n\nfloat moon(vec2 st){\n    float s = smoothstep(1.21, 1.2, length(st-vec2(0.15, .15)));\n    s *= smoothstep(.80, .81, length(st-vec2(.40, 0.75)));\n    return s;\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRect(vec2 p, vec2 r)\n{\n    vec2 d = abs(p) - r;\n    return length(max(d, 0.0))\n        + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdHook(vec2 p, float s)\n{\n    float base = opUnion(sdCircle(p, s * 0.7), sdRect(p - vec2(0, -1.5) * s, vec2(0.3, 1.0) * s));\n    float hookCircle = opOnion(sdCircle(p - vec2(0, -3.3) * s, s), 0.25 * s);\n    float mask = sdRect(p - vec2(-1.2, -3) * s, vec2(1, 1.1) * s);\n    float hook = opSubtraction(hookCircle, mask);\n    return opUnion(base, hook);\n}\n\nfloat sdline(vec2 p)\n{\n    float line = sdRect(p - vec2(0.13, 0.1), vec2(0.002, 0.55));\n    \n    return line;\n}\n\nfloat rand(int seed, float ray) {\n\treturn mod(sin(float(seed)*363.5346+ray*674.2454)*6743.4365, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    uv.x += 0.0035 * cos(uv.y * 100.0 + iTime * PI2);\n    uv.x += 0.0015 * cos(uv.y * 250.0 + iTime * PI2);\n    \n    vec2 uvn = gl_FragCoord.xy/iResolution.y;\n    \n    vec2 uv2 = -1.0 + 2.0*gl_FragCoord.xy / iResolution.xy;\n\tuv2.x *=  iResolution.x / iResolution.y;\n    \n    vec2 p = gl_FragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*= 10.0;\n    vec2 pixuv = vec2((gl_FragCoord.xy / iResolution.xy-0.5).x * 1.0, (gl_FragCoord.xy / iResolution.xy-0.5).y * 1.0);\n    \n    float n = noise(pixuv, iTime * 0.25, p);\n    vec3 back = vec3(n) * vec3(0.0,0.3,1.0);\n    back = pow(back,vec3(1.0,0.8,0.85));\n    back *= 2.0;\n\n    // bubbles by inigo quilez https://www.shadertoy.com/view/4dl3zn\n    vec3 bcol = vec3(0.0);\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n\t\tfloat rad = 0.025 + 0.025*siz+sin(iTime/6.+pha*500.0+siz)/30.0;\n\t\tvec2  pos = vec2( pox+sin(iTime/10.+pha+siz), -1.0-rad + (2.0+2.0*rad)\n\t\t\t\t\t\t *mod(pha+0.1*(iTime/5.0)*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv2 - pos );\n\t\tvec3  col = mix( vec3(0.15,0.15,0.25*sin(iTime/6.0)), \n\t\t\t\t\t\tvec3(0.25,0.4,0.85*sin(iTime/9.0)), \n\t\t\t\t\t\t0.5+0.5*sin(float(i)*1.2+1.9));\n        \n\t\tfloat f = length(uv2-pos)/rad;\n\t\tf = sqrt(clamp(1.0+(sin((iTime/7.0)+pha*500.0+siz)*0.5)-f*f,0.0,1.0));\n\t\tbcol += col.zyx *(1.0-smoothstep( rad*0.85, rad, dis )) * f;\n\t}\n\n    vec3 col = vec3(0.0, .35 + uv.y * .55, .95 + uv.y * .25);\n    \n    vec3 moon = vec3(moon(uv+vec2(0.1,0.6)));\n    moon *= back;\n    \n    col += moon;\n    col += bcol;\n    \n    vec2 lPos = vec2(1.2,0.6);\n    \n    if (sdline(uvn - lPos) < 0.0)\n    {\n        col = vec3(1.0);\n    }\n    \n    if (sdHook(uvn - lPos - vec2(0.13, -0.45), 0.01) < 0.0)\n    {\n        col = vec3(0.1);\n    }\n    \n    vec2 position = ( gl_FragCoord.xy / iResolution.xy ) - vec2(0.1, 1.5);\n\tposition.y *= iResolution.y/iResolution.x;\n\tfloat ang = atan(position.y, position.x);\n\tfloat dist = length(position);\n\tvec3 Light = vec3(0.15, 0.5, 0.8) * (pow(dist, -1.0) * 0.2) + dist * vec3(0.02, 0.1, 0.35);\n\tfor (float ray = 0.0; ray < 100.0; ray += 1.0) {\n\t\tfloat rayang = rand(5234, ray)*10.0+iTime*0.15*(rand(2500, ray)-rand(4000, ray));\n\t\trayang = mod(rayang, PI*2.0) + PI * 0.5;\n\t\tif (rayang < ang - PI) {rayang += PI*2.0;}\n\t\tif (rayang > ang + PI) {rayang -= PI*2.0;}\n\t\tfloat brite = .20 - abs(ang - rayang);\n\t\tbrite -= dist * 0.05;\n\t\tif (brite > 0.0) {\n\t\t\tLight += vec3(0.0, 0.25+0.4*rand(4567, ray), 0.25+0.4*rand(5000, ray)) * brite;\n\t\t}\n\t}\n    \n    col *= Light;\n    \n    col *= uvn.y * 1.5;\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}