{"ver":"0.1","info":{"id":"lljSDm","date":"1444416972","viewed":341,"name":"trees and houses","username":"mattz","description":"Trying to play around with composition and color a bit.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["trees","geometric","houses","pinksky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Just fooling around after looking at artwork on http://www.89a.co.uk/\n//\n// Many things borrowed from iq below: distance functions, raymarching, etc.\n// Also borrowed Dave_Hoskins' noise function to randomize house locations.\n\nconst int rayiter = 60;\nconst float maxd = 40.0;\nvec3 L = normalize(vec3(-1.1, 0.6, 2.0));\nconst float precis = 0.005;\n\n#define SKY_COLOR 0.0\n#define GROUND_COLOR 1.0\n#define TREE_COLOR 2.0\n#define TRUNK_COLOR 3.0\n#define HOUSE_COLOR 4.0\n#define ROOF_COLOR 5.0\n\nvec3 color(float t) {\n\n    if (t == SKY_COLOR) {\n        return vec3(1.0, 0.8, 0.7);\n    } else if (t == GROUND_COLOR) {\n        return vec3(0.5, 0.25, 0.3);\n    } else if (t == TREE_COLOR) {\n        return vec3(0.1, 0.3, 0.25);\n    } else if (t == TRUNK_COLOR) {\n        return vec3(0.15, 0.1, 0.1);\n    } else if (t == HOUSE_COLOR) {\n        return vec3(0.85, 0.5, 0.0);\n    } else {// if (t == ROOF_COLOR) {\n        return vec3(0.95, 0.75, 0.1);\n    } \n\n}\n\nvec2 opU(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdRoof(vec3 p, float s) {\n\n    p.y -= s;\n    float k = dot(vec2(abs(p.z), p.y), vec2(0.7071067811865475));\n    float l = -p.y-s;\n    float w = abs(p.x)-s;\n    return max(k, max(l, w));\n\n}\n\n/* Many distance functions adapted from \n   https://iquilezles.org/articles/distfunctions\n*/\nfloat sdCube(vec3 p, float r) {    \n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0));    \n}\n\n\nfloat sdBox(in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),.0) +\n        length(max(d,.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec2 h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),.0) + length(max(d,.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdSquareCone( vec3 p, vec2 c) {\n    \n    p.xy = abs(p.xy);\n    return dot(vec2(max(p.x, p.y), p.z), c);\n    \n    \n}\n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\nmat3 rotZ(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\n/// From https://www.shadertoy.com/view/4djSRW\n\n// *** Use these for integer ranges, ie Value-Noise/Perlin functions.\n#define MOD3 vec3(.0631,.07369,.08787)\n#define MOD4 vec4(.0631,.07369,.08787, .09987)\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\nvec2 map(in vec3 pos) {\n\n    float p = 6.0;\n\n    vec2 rval = vec2(pos.y, GROUND_COLOR);\n    rval.x = max(rval.x, length(pos.xyz)-14.0);\n    \n    for (float dx=-0.0; dx<2.0; ++dx) {\n        for (float dz=-0.0; dz<2.0; ++dz) {\n\n            vec2 g = floor((pos.xz+0.5*p)/p) + vec2(dx, dz);\n            vec2 k = hash22(g+vec2(0.455));\n            vec3 q = pos;\n            vec2 r = p*g - 0.5*p;\n\n            if (length(r) < 12.0) { \n\n                q.xz -= p*(g - 0.5*k);\n                q.xz += vec2(0.3, 2.4);\n\n                rval = opU(rval, vec2(sdCube(q-vec3(0,1.0,0), 1.0), \n                                      HOUSE_COLOR));\n\n                rval = opU(rval, vec2(sdRoof(q-vec3(0,2.0,0), 1.1), \n                                      ROOF_COLOR));\n\n                rval = opU(rval, vec2(sdBox(q-vec3(0.7,2.2,0.25), vec3(0.2, 1.3, 0.2)), \n                                      HOUSE_COLOR));\n\n                vec2 s = vec2(sdSquareCone((q - vec3(-2.0, 5.0-(k.x+k.y), 1.5)) .xzy, \n                                           normalize(vec2(6.0, 1.0))), \n                              TREE_COLOR);\n                \n                s.x = max(s.x, -q.y+0.7);\n                \n                rval = opU(rval, s);\n\n                rval = opU(rval, vec2(sdBox(q - vec3(-2.0, 0.0, 1.5), vec3(0.15, 1.0, 0.15)), \n                                      TRUNK_COLOR));\n\n\n            }\n\n        }\n    }\n\n    return rval;\n\n}\n\n\nvec3 trace(vec3 ro, vec3 rd) {\n\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ ) {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;\n    }\n\n    if (t > maxd) { m = -1.0; }\n\n    return vec3(t, m, h);\n\n}\n\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.05, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\n\n\nvec3 shade(vec3 ro, vec3 rd) {\n\n    vec3 tm = trace(ro, rd);\n    if (tm.y < 0.0) { return color(0.0); }\n\n    vec3 pos = ro+tm.x*rd;\n    vec3 n = calcNormal(pos);\n\n    float nDotL = clamp(dot(n,L), 0.0, 1.0);\n\n    vec3 direct = color(tm.y);\n\n    vec3 tm2 = trace(pos+precis*n, L);\n\n    const float amb = 0.2;\n    const float diff = 1.0-amb;\n\n    if (abs(tm2.z) < 3.0*precis) {        \n        direct *= amb;\n    } else {\n        direct *= nDotL*diff + amb;\n    }\n\n    return direct;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const float yscl = 720.0;\n    const float f = 40.0;\n\n    vec3 pos = vec3(0.0, 0.0, 14.5);\n    vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 rz = normalize(tgt - pos);\n    vec3 rx = normalize(cross(rz,up));\n    vec3 ry = cross(rx,rz);\n\n    float thetax = -0.5;\n    float thetay = 0.4;\n\n    if (iMouse.y > 10.0 || iMouse.x > 10.0) { \n        thetax += (iMouse.y - 0.5*iResolution.y) *  3.0/iResolution.y; \n        thetay += (iMouse.x - 0.5*iResolution.x) * -1.8/iResolution.x; \n    } else {\n        thetay -= 0.1*iTime;\n    }\n\n    mat3 Rx = rotX(thetax);    \n    mat3 Ry = rotY(thetay);\n    mat3 R = Ry*Rx;\n\n    L = R*L;    \n\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * yscl / iResolution.y;\n\n    vec3 rd = normalize(tgt - pos);\n    vec3 ro = pos + mat3(rx,ry,rz)*vec3(uv/f,0);\n\n    rd = R*rd;\n    ro = R*(ro-tgt) + tgt;\n\n    fragColor.xyz = pow(shade(ro, rd), vec3(0.45));\n\n}\n\n\n","name":"","description":"","type":"image"}]}