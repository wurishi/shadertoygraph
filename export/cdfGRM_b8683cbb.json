{"ver":"0.1","info":{"id":"cdfGRM","date":"1669777184","viewed":64,"name":"Game Of Life 1","username":"Avicky","description":"John Conway's Game of Life\nWith reference and reverence to Art of Code, Marteen. Grateful","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["firstattempt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel1, uv/SIZE).rgb;// color here is called from using the background in iChannel (cheap way to get color)\n    //uv coordinate of the vec3 is beign divide to increase its visibility, where size =4, its displaying only 1/4th of the whole vector.\n    \n    //uv.x = abs(uv.x);\n    //uv.x -= .5;\n    //uv.y = abs(uv.y);\n    vec2 gv = fract(fragCoord/SIZE) -.5; //draw a bunch of circles vertically across the screen.\n    float d = length(gv); // centre of the disk to be in the middle of each box, measurement of centre of disk to edge.\n    col *=smoothstep(.1, .0, d- .4); //funtion used to call out a circle.\n   //col.rg = gv;\n\n   fragColor = vec4(col,1.0); // output fragcolor to the screen.\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat hash1( float w )\n{\n    return fract(sin(w)*138.5453123);\n}\n\n\nint GetNeigbors(ivec2 p) { \n//ivec is a vector integer and p =position - how many neighbours are there  \n    int num = 0;\n                         \n   for(int y=-1; y<=1; y++) \n                                  {           //Check the neighbour pixel by pixel staring with -1 for both x and y if alive or dead.\n       for(int x=-1; x<=1; x++)           {\n           if(x==0&&y==0) continue;\n           num += texelFetch(iChannel1, \n               p+ivec2(x, y), 0).r > .5 ? 1 : 0;  //if position + ivec is true then make cell alive, \n                                                                           //else dead. The pixels are initialised to black and white\n                                                                           //this call is checking the solidity of the color, if its 50% \n                                                                       //lighther than black then alive else dead.(first call to iChannel)\n                           }\n        \n                                   }\n    \n    return num;\n                                            }  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec2 uv = fragCoord/iResolution.xy;\n     vec4 col = vec4(0);\n    // uv.x = abs(uv.x); \n    // uv.x -= .5;\n    //uv.y = abs(uv.y);\n     \n     if(iFrame<10)   //number of frame per second-\n            col = texture(iChannel0, uv);   //initialize color of red, change after the first 10 second.\n     else if(iFrame % SPEED != 0) // % operator divides iframe by 10, gives reminder - modula operation. After every 10 frames the, \n     //reminder = 0. This operation is to slow down the pixel movement so one can make sense of the acitivities on the screen.\n            col = texture(iChannel1, uv); // color is the color of background gotten from ichannel1 and texture coordinate.\n            \n     else {                // do life!     \n        bool alive = texelFetch(iChannel1, ivec2(fragCoord), 0).r > .5;// checking if the current pixel is alive - \n                                                                        //textelfetch takes pixel coordinate\n        int num = GetNeigbors(ivec2 (fragCoord));\n        \n       \n//LETS PLAY, GAME OF LIFE!!\n       int next = 0; //apply the rules. Start with a dead cell.\n        \n       if(alive && (num==2 || num==3)) //any cell with 2 or 3 life neigbours survives. rule (1)\n         next = 1;\n       else if(!alive && num==3)//if not but has 3 neigbours exactly, it survives to next generation.  rule (2)\n            next = 1;\n        else \n            next = 0;//the cell is dies. rule (3)\n            \n        col = vec4(next); \n   \n        float f = 0.1;   \n        if( iFrame==0 ) f = step(0.9, hash1(fragCoord.x*13.0+hash1\n       (fragCoord.y*71.1)));  \n    }\n    //Altering the funtion of the mouse\n        if(iMouse.z>0.5 && length \n        (iMouse.xy/SIZE-fragCoord.xy)<BRUSH_SIZE) col = vec4(1); //if the pixel coordinate, fragcoord, is \n                                                 //smaller than 2 pixels,then put all of the values to one, give life to the dead cells.\n    \n  \n        fragColor = col;\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//global variable are kept in a common tab.\n\n#define SIZE 10.\n#define BRUSH_SIZE 1.\n#define SPEED 20 \n\n//size = pixel size\n//brush size = Mouse size\n//SPEED - controls the speed of the pixels. Invese of speed, the bigger is slower.","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 old = texture(iChannel1, uv);  //*.90;\n    vec4 new = texture(iChannel0, uv);\n    \n      \n    fragColor = mix(old, new, 0.1);\n}","name":"Buffer B","description":"","type":"buffer"}]}