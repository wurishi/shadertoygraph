{"ver":"0.1","info":{"id":"X3GGz3","date":"1717957191","viewed":51,"name":"matrix noise","username":"magandalf","description":"as base for this noise used grid of matrix","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DEPTH 7\n\n\nmat3 mmix(mat3 a, float t)\n{\n    a[0] = mix(vec3(1.0, 0.0, 0.0), a[0], t);\n    a[1] = mix(vec3(0.0, 1.0, 0.0), a[1], t);\n    a[2] = mix(vec3(0.0, 0.0, 1.0), a[2], t);\n    return a;\n}\n\n\nvec3 hash1(vec3 p)\n{\n    p = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz+33.33);\n    return fract((p.xxy + p.yxx)*p.zyx);\n}\n\nvec3 hash2(vec3 p)\n{\n    p = fract(p * vec3(.7758, .89873, .073));\n    p += dot(p, p.zxy+33.33);\n    return fract((p.zxy + p.yyz)*p.xzz);\n}\n\nvec3 hash3(vec3 p)\n{\n    p = fract(p.yzx * vec3(.3454, .864, .73));\n    p += dot(p, p.zyx+33.33);\n    return fract((p.xyy + p.yzx)*p.zyz);\n}\n\n\nmat3 hm(vec3 p)\n{\n    return mat3(\n        hash1(p+0.1),\n        hash2(p+0.2),\n        hash3(p+0.3)\n    );\n}\n\n\nfloat area(vec3 p)\n{\n    return abs(p.x * p.y * p.z);\n}\n\n\nfloat noise3d(vec3 p)\n{\n    vec3 rnd = normalize(vec3(0.7851, 0.125891, 0.9812));\n    \n    // rnd = sin(10.1 * (p - 0.5)) * 0.5 + 0.5;\n    \n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    // apply all this matrix\n    rnd *= mmix(hm(i + vec3(0.0, 0.0, 0.0)), area(f - vec3(1.0, 1.0, 1.0)));\n    rnd *= mmix(hm(i + vec3(1.0, 0.0, 0.0)), area(f - vec3(0.0, 1.0, 1.0)));\n    rnd *= mmix(hm(i + vec3(0.0, 1.0, 0.0)), area(f - vec3(1.0, 0.0, 1.0)));\n    rnd *= mmix(hm(i + vec3(1.0, 1.0, 0.0)), area(f - vec3(0.0, 0.0, 1.0)));\n    rnd *= mmix(hm(i + vec3(0.0, 0.0, 1.0)), area(f - vec3(1.0, 1.0, 0.0)));\n    rnd *= mmix(hm(i + vec3(1.0, 0.0, 1.0)), area(f - vec3(0.0, 1.0, 0.0)));\n    rnd *= mmix(hm(i + vec3(0.0, 1.0, 1.0)), area(f - vec3(1.0, 0.0, 0.0)));\n    rnd *= mmix(hm(i + vec3(1.0, 1.0, 1.0)), area(f - vec3(0.0, 0.0, 0.0)));\n    \n    return (rnd.x * rnd.y * rnd.z) * .333;\n}\n\nfloat noise(vec3 xyz)\n{\n    mat3 m = mat3(\n        vec3(0.5501241,  0.0852899,  0.8307160),\n        vec3(-0.8130569,  -0.1722604,  0.5561158),\n        vec3(0.1905305,  -0.9813522,  -0.0254190)\n    );\n    m *= 2.0;\n    float amp = 1.0;\n    float fin = 0.0;\n    float div = 0.0;\n   \n    //float h = noise3d(xyz * 0.33);\n    \n    for (int i = 0; i < DEPTH; ++i)\n    {\n        div += amp;\n        fin += amp * noise3d(xyz);\n        xyz *= m;\n        amp /= 1.25;\n    }\n    \n    return fin / div;// * h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / sqrt(iResolution.x * iResolution.y);\n\n    uv += 10.0 * vec2(iMouse.xy) / sqrt(iResolution.x * iResolution.y);\n\n    // Time varying pixel color\n    float grey = noise(vec3(uv * 1.5, 100.0 + 0.01 * float(iTime)));\n\n    grey *= 2.8;\n    \n    if (grey > 1.0)\n    {\n        grey = 1.0;\n    }\n\n    vec3 col = vec3(grey);\n\n    if (0.0 <= grey && grey < 0.5) // water\n        { col = mix(vec3(0.000,0.000,0.000), vec3(0.000,0.000,1.000), (grey - 0.0) / 0.5); }\n    else if (0.5 <= grey && grey < 0.53) // sand\n        { col = mix(vec3(1.000,0.784,0.000), vec3(1.000,0.969,0.000), (grey - 0.5) / 0.03); }\n    else if (0.53 <= grey && grey < 0.75) // forests\n        { col = mix(vec3(0.086,0.400,0.000), vec3(0.473,0.800,0.141), (grey - 0.53) / 0.22); }\n    else if (0.75 <= grey && grey < 0.85) // rocks\n        { col = mix(vec3(0.580,0.580,0.580), vec3(0.243,0.243,0.255), (grey - 0.75) / 0.1); }\n    else if (0.85 <= grey && grey <= 1.0) // snow\n        { col = mix(vec3(0.894,0.906,0.902), vec3(1.000,1.000,1.000), (grey - 0.85) / 0.15); }\n    else { col = vec3(1.000,0.000,0.000); }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}