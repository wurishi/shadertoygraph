{"ver":"0.1","info":{"id":"4f2czV","date":"1722620019","viewed":47,"name":"Sinuous hexamarch","username":"Tivi","description":"Hexagon grid marching with sinewave offset grid columns (+ overlapping static square grid)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Stole from iquilez\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    //#if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    //#else\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    //vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    //#endif\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves=8;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(f*x).x;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// hex-xy conversion stole from https://www.redblobgames.com/grids/hexagons/#rounding\n\nvec2 cube_to_axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.y;\n    return vec2(q, r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n    float q = hex.x;\n    float r = hex.y;\n    float s = -q-r;\n    return vec3(q, r, s);\n}\n    \nvec3 cube_round(vec3 frac)\n{\n    float q = round(frac.x);\n    float r = round(frac.y);\n    float s = round(frac.z);\n\n    float q_diff = abs(q - frac.x);\n    float r_diff = abs(r - frac.y);\n    float s_diff = abs(s - frac.z);\n\n    if (q_diff > r_diff && q_diff > s_diff)\n        q = -r-s;\n    else if (r_diff > s_diff)\n        r = -q-s;\n    else\n        s = -q-r;\n\n    return vec3(q, r, s);\n}\n\nvec2 axial_round(vec2 hex){\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\n\nvec2 xyToHex(vec2 point)\n{\n    float size = 1.;\n    float q = (sqrt(3.)/3. * point.x  -  1./3. * point.y) / size;\n    float r = (                        2./3. * point.y) / size;\n    return axial_round(vec2(q, r));\n}\n\n#define BIGFLOAT (100000.)\n// return normal + t\n\n\nvec4 traverse_square(vec3 ro, vec3 rd)\n{\n\n    vec3 ro_ = ro;\n    vec3 cell = floor (ro_);\n    vec3 normal;\n    float t = BIGFLOAT;\n    for (int i=0; i<300; i++)\n    {\n        // Forward march\n        vec3 plane;\n        plane.x = rd.x<0. ? cell.x : cell.x+1.;\n        plane.y = rd.y<0. ? cell.y : cell.y+1.;\n        plane.z = rd.z<0. ? cell.z : cell.z+1.;\n        vec3 planet = abs((plane-ro_)/rd);\n        vec3 step = rd / abs(rd);\n        normal = vec3(0.,0.,1.);\n        float t_ = planet.z;\n        if (planet.x < planet.y && planet.x < planet.z)\n        {\n            cell.x += step.x;\n            normal = vec3(1.,0.,0.);\n            t_ = planet.x;\n        }\n        else if(planet.y < planet.z)\n        {\n            cell.y += step.y;\n            normal = vec3(0.,1.,0.);;\n            t_ = planet.y;\n        }\n        else\n        {\n            cell.z += step.z;\n        }\n        normal *= -step;\n        \n        //if (cell.y < sin(cell.x*0.5)*1.6f + cos(cell.x*0.2-cell.z*0.4)*0.8f)\n        float h = fbm(cell.xz,0.8)*5. - length(cell.xz)*0.22;\n        if (cell.y < h)\n        {\n            //hit = ro + rd*t;\n            t = t_;\n            break;\n        }\n        if (cell.y > 20. && rd.y > 0.) break;\n        \n        \n    }\n    return vec4(normal, t);\n}\n\nfloat thingy(vec2 cell, float time)\n{\n    return sin(cell.x*0.2 + time)*1.2 + 1.4*cos(cell.y*0.3 + time*0.8);\n}\n\nvec4 traverse(vec3 ro, vec3 rd, float time)\n{\n\n    vec3 ro_ = ro;\n    //vec3 cell = floor (ro_);\n    vec2 hex = xyToHex(ro.xz);\n    vec3 cell = vec3(hex, floor(ro.y-thingy(hex, time))).xzy;\n    vec3 normal;\n    float t = BIGFLOAT;\n    for (int i=0; i<300; i++)\n    {\n        float size = 1.;\n        float cellx = size * (sqrt(3.) * cell.x  +  sqrt(3.)/2. * cell.z);\n        float cellz = size * (                          3./2. * cell.z);\n        vec3 cellCtr = vec3(cellx, cell.y+0.5+thingy(vec2(cell.x,cell.z), time), cellz);\n        // Forward march\n        vec3 slabdir_x = vec3(1.,0.,0.);\n        vec3 slabdir_y = vec3(0.,1.,0.);\n        vec3 slabdir_z = normalize(vec3(-sqrt(3.)/2.,0.,3./2.)); \n        vec3 slabdir_w = normalize(vec3(sqrt(3.)/2.,0.,3./2.));\n        float cellR = sqrt(3.)/2.;\n        float cellCtr_z = dot(slabdir_z, cellCtr);\n        float cellCtr_w = dot(slabdir_w, cellCtr);\n        \n        vec4 plane;\n        \n        vec4 ro_slab = vec4(ro.x, ro.y, dot(ro,slabdir_z), dot(ro,slabdir_w));\n        vec4 rd_slab = vec4(rd.x, rd.y, dot(rd,slabdir_z), dot(rd,slabdir_w));\n        plane.x = rd.x<0. ? cellCtr.x - cellR : cellCtr.x + cellR;\n        plane.y = rd.y<0. ? cellCtr.y - 0.5: cellCtr.y + 0.5;\n        plane.z = rd_slab.z<0. ? cellCtr_z - cellR : cellCtr_z + cellR;\n        plane.w = rd_slab.w<0. ? cellCtr_w - cellR : cellCtr_w + cellR;\n        vec4 planet = abs((plane-ro_slab)/rd_slab);\n        vec4 step = rd_slab / abs(rd_slab);\n\n        normal = vec3(0.,0.,1.);\n        float t_ = planet.z;\n        bool vert = false;\n        if (planet.x < planet.y && planet.x < planet.z && planet.x < planet.w)\n        {\n            cell.x += step.x;\n            normal = -vec3(1.,0.,0.);\n            if (rd.x<0.) normal *= -1.f;\n            t_ = planet.x;\n        }\n        else if(planet.y < planet.z && planet.y < planet.w)\n        {\n            vert = true;\n            cell.y += step.y;\n            normal = -vec3(0.,1.,0.);\n            if (rd.y<0.) normal *= -1.f;\n            t_ = planet.y;\n        }\n        else if(planet.z < planet.w)\n        {\n            cell.x -= step.z;\n            cell.z += step.z;\n            normal = -slabdir_z;\n            if (rd_slab.z<0.) normal *= -1.f;\n            t_ = planet.z;\n        }\n        else\n        {\n            cell.z += step.w;\n            normal = -slabdir_w;\n            if (rd_slab.w<0.) normal *= -1.f;\n            t_ = planet.w;\n        }\n        //normal *= -step;\n        \n        //if (cell.y < sin(cell.x*0.5)*1.6f + cos(cell.x*0.2-cell.z*0.4)*0.8f\n        \n        cellx = size * (sqrt(3.) * cell.x  +  sqrt(3.)/2. * cell.z);\n        cellz = size * (                          3./2. * cell.z);\n        if (!vert) cell.y = floor(ro.y+rd.y*t_ - thingy(vec2(cell.x,cell.z),time));\n        cellCtr = vec3(cellx, cell.y+0.5, cellz);\n        float h = fbm(cellCtr.xz,0.8)*5. - length(cellCtr.xz)*0.22;\n        if (cellCtr.y < h+2.)\n        {\n            //hit = ro + rd*t;\n            t = t_;\n            break;\n        }\n        if (cell.y > 20. && rd.y > 0.) break;\n        \n        \n    }\n    vec4 squaregridhit = traverse_square(ro,rd);\n    if (squaregridhit.w < t) return squaregridhit;\n    return vec4(normal, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5 + mo.x*200.;\n\n    // Camera stoel IIRC from iquilez\n    // camera\t\n    vec3 ta = vec3( 0.25, -0.75, -0.75 );\n    vec3 ro = ta + vec3( 35.*cos(0.1*time), 30, 35.*sin(0.1*time) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // focal length\n    const float fl = 2.5;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    rd = normalize(rd);\n   \n    \n    vec3 planehit = ro - rd * (ro.y / rd.y);\n    \n    //vec2 xy = floor(planehit.xz*1.f);\n    \n    //vec3 col_ = 0.5 + 0.5*cos(xy.xyy);\n    vec3 xy = floor(vec3(planehit.x-planehit.z,planehit.x+planehit.z,planehit.x));\n    \n    vec3 col_ = 0.5 + 0.5*cos(xy.xyz);\n    fragColor = vec4(col_,1.0);\n    if(false)return;\n    \n    vec4 fuu = traverse(ro, rd, time);\n\n    float t = fuu.w;\n    vec3 normal = fuu.xyz;\n    vec3 hit = ro+t*rd;\n    vec3 cell = floor(hit);\n    \n    vec3 sun = vec3(20.f,25.f,20.f);\n    vec3 shadow_rd = normalize(sun-hit);\n    vec4 bar = traverse(hit + 0.01*shadow_rd, shadow_rd, time);\n    float shadow_occ = 1.f;\n    if (bar.w != BIGFLOAT)\n        shadow_occ = 0.f;\n    \n    float ambient = 0.1;\n    \n    vec3 lightdir = normalize(sun-hit);\n    \n\tfloat spec = max(pow( max(0.,dot( -rd ,normalize(2.0*dot(lightdir,normal)*normal + (lightdir))) ), 100.0),0.)*2.;\n        //spec=0.;\n        \n    float diff = shadow_occ* (0.8)*clamp(dot(normal, normalize(sun-hit)), 0., 1.);\n        \n    float light = pow( ambient+spec+diff, 1.0/2.2 ); // (thanks to spalmer for reminding that gamma correction is nice!)\n    vec3 col = clamp((10.f+cell)/20.f,0.1,1.) *vec3(1.f,1.,0.5)* (light);\n    col = clamp(col,0.,1.);\n    //col=normalize(normal)*0.5+0.5;\n    //col = ((10.f+cell)/20.f);// * ((hit.z)/20.f);\n    //col = ((cell)/20.f);// * ((hit.z)/20.f);\n    //col = ((10.f+cell)/20.f) * (hit.y-cell.y+0.2) *(shadow_occ+0.2);\n    //col = max(0.,0.5+0.5*dot(vec3(0.3,0.7,0.4), normal)) * vec3(0.15, 0.2, 0.3);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}