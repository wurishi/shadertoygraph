{"ver":"0.1","info":{"id":"sdBBzt","date":"1647449885","viewed":49,"name":"Diffuse test","username":"Pikachuxxxx","description":"Simple diffuse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(vec2 uv, float r)\n{\n    float x = uv.x;\n    float y = uv.y;\n        \n    return length(vec2(x, y)) - r;\n}\n\n////////////////////////////////////////////\n\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.1\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r; // p is the test point and r is the radius of the sphere\n}\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n  float r = 1.; // radius of sphere\n  return normalize(\n    e.xyy * sdSphere(p + e.xyy, r) +\n    e.yyx * sdSphere(p + e.yyx, r) +\n    e.yxy * sdSphere(p + e.yxy, r) +\n    e.xxx * sdSphere(p + e.xxx, r));\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdSphere(p, 1.);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n  \n  return depth;\n}\n\n\nvec3 getBackgroundColor(vec2 uv) {\n    uv += 0.5; // remap uv from <-0.5,0.5> to <0,1>\n    vec3 gradientStartColor = vec3(1., 0., 1.);\n    vec3 gradientEndColor = vec3(0., 1., 1.);\n    return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 backgroundColor = vec3(0.835, 1, 1);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    // Color\n    vec3 col = vec3(0.0);\n    \n    // Ray origin\n    vec3 ro = vec3(0, 0, 5);\n    // Ray Direction : each ray is shot towards the scene into the Z\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    \n    if (d > 100.0) {\n      col = vec3(0.6); // ray didn't hit anything\n    }\n    else {\n      vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        \n        vec3 lightPosition = vec3(0, 2, 4);\n        vec3 lightDirection = normalize(lightPosition - p);\n        \n        // Calculate diffuse reflection by taking the dot product of \n        // the normal and the light direction.\n        float dif = clamp(dot(normal, lightDirection), 0., 1.);\n\n    col = vec3(vec3(0.3, 0.7, 1.0f) * dif);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}