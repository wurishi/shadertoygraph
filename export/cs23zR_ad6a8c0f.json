{"ver":"0.1","info":{"id":"cs23zR","date":"1667129435","viewed":325,"name":"Nek'o'Lantern :3","username":"Artemis152","description":"Jack-'o'-Lantern x Cat.\n\nBased on this drawing I drew 2 years ago: [url=https://cdn.discordapp.com/attachments/939579082730012732/1035190602255577098/nekolantern_pad.png]here[/url]\n\nDrag to orbit;","likes":25,"published":1,"flags":32,"usePreview":1,"tags":["raymarch","cat","outlines","halloween","toon","pumpkin","npr"],"hasliked":0,"parentid":"ddlGDB","parentname":"Nek'o'Lantern-wip"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//check Buffer A for actual scene definition, rendering and settings\n\nvoid mainImage( out vec4 fragColor, in vec2 uv)\n{\n    //downscale(uv);\n    vec2 s = 1. / iResolution.xy;\n    \n    vec2 tUV = uv * s;\n    vec3 col = texture(iChannel0, tUV).rgb;\n    \n    //col = vec3(0.5);\n    \n    // Vertical blurring\n    vec3 glow =  blurX(iChannel1, tUV, s*.6);\n    //glow = vec3(0.);\n    \n    glow = col.rgb * glow * 1.;\n    col.rgb += glow * .6;\n    //col.rgb = glow.rgb;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PIh 1.57079632679\n#define PI 3.141592653589793238\n#define TAU 6.283185\n\nfloat rand(vec2 n) {     return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n//\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat2 rotd(float a)\n{\n    return rot(radians(a));\n}\n\n\nvec2 rotate(vec2 v, float a) {\n    return rot(a) * v;\n}\n\nvec3 pol2Cart(float rX, float rY, float d)\n{\n    return normalize(vec3(\n        sin(rX),\n        sin(rY),\n        cos(rX)\n    )) * d;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat box(vec3 p, float e)\n{\n    vec3 d = abs(p) - e;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\nfloat triPrism( vec3 p, vec3 h )\n{\n    p.y /= h.y;\n    vec3 q = abs(p);\n    return max(q.z-h.z,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5) * 0.8;\n}\n//\n\n//based on above\nfloat smoothTriPyramid( vec3 p, vec3 h )\n{\n    h.x *= smoothstep(-h.z, h.z, p.z);\n    p.y /= h.y;\n    vec3 q = abs(p);\n    return max(q.z-h.z,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5) * 0.8;\n}\n\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    return max(length(p.zx) - h.x, abs(p.y) - h.y);\n}\n\n// taken from https://www.shadertoy.com/view/4tSyzy and turned into multi-pass(+20fps)\n#define pow2(x) (x * x)\n\nconst int samples = 30;\nconst float sigma = float(samples) * 0.3;\n#define BLURSCALE 2.\n\nfloat gaussian(vec2 i) {\n    return 1.0 / (2.0 * PI * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec3 blurX(sampler2D sp, vec2 uv, vec2 scale) {\n    vec3 col = vec3(0.0);\n    float accum = 0.0;\n    float weight;\n    vec2 offset;\n    scale *= BLURSCALE;\n    \n    for (int x = -samples / 2; x < samples / 2; ++x) {\n        offset = vec2(x, 0);\n        weight = gaussian(offset);\n        vec3 c = texture(sp, uv + scale * offset).rgb;\n        //if(length(c.rgb) < 0.8) c.rgb = vec3(0.);\n        col += c * 2. * weight;\n        accum += weight;\n    }\n    \n    return col / accum;\n}\n\nvec3 bloomY(sampler2D sp, vec2 uv, vec2 scale) {\n    vec3 col = vec3(0.0);\n    float accum = 0.0;\n    float weight;\n    vec2 offset;\n    scale *= BLURSCALE;\n    \n    for (int y = -samples / 2; y < samples / 2; ++y) {\n        offset = vec2(0, y);\n        weight = gaussian(offset);\n        vec3 c = texture(sp, uv + scale * offset).rgb;\n        if(length(c.rgb) < 0.7917) c.rgb = vec3(0.);\n        col += c * 2. * weight;\n        accum += weight;\n    }\n    \n    return col / accum;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//MAIN SCENE\n\n//sets \"lighting\"\n// 1 - Day\n// 2 - Dusk\n// anything else - Animation\n#define DAYCYCLE 0\n\n#if DAYCYCLE==1\n    #define duskmix(a, b) a\n#elif DAYCYCLE==2\n    #define duskmix(a, b) b\n#else\n    #define duskmix(a, b) mix(a, b, smoothstep(0.2, 0.9, sin((max(iTime, 2.) - 2. - PIh) * .6) * .5 + .5))\n#endif\n\n#define MAX_STEPS 80\n#define MAX_DIST 15.\n#define SURF_DIST 0.001\n\n//Set 1 to turn off AA on low performance, big performance hog\n//Set 2 for 2x AA and so on\n#define AA 1\n\n//#define MY_AA //should be kept turned off\n\n//comment to disable shadow\n#define SHADOW\n\n//#define DISABLE_GLOW\n\n//#define SHOW_TREE\n\n//left is +, right is -\n#define FANG_POS + \n\n//material ids\n#define NONE -1\n#define GROUND 0\n#define PUMPSKIN 1\n#define PUMPINT 2\n#define STALK 3\n#define GLOW 4\n#define OUTLINE 5\n#define TREE 6\n\nstruct RMObj\n{\n    int id;\n    float d;\n};\n\nstruct RMOut\n{\n    RMObj o;\n    \n    vec3 p;\n};\n\n/*\nconst vec3 Color[] = vec3[](\n    vec3(.13, .02, .13),\n    vec3(.35, .14, .2),\n    vec3(.7, .4, .2),\n    vec3(1., .6,.3),\n    vec3(.4, 1., .2) * .8,\n    vec3(1., .8,.3) * 1.,\n    vec3(0.)\n);\n*/\n\nvec3 GetColor(RMOut dat)\n{\n    vec3 col;\n    //vec3 norm = GetSceneNormal(dat.p);\n    \n    switch(dat.o.id)\n    {    \n        case GROUND:\n             col = vec3(.35, .14, .2);\n             break;\n             \n        case PUMPSKIN:\n            col = vec3(.7, .4, .2);\n            //col *= max(.2, dot(norm, vec3(0., 0., 1.))\n             //* .5 + .5\n            //);\n            break;\n            \n        case PUMPINT:\n            col = vec3(1., .6,.3) * 1.3;\n            //col *= max(.9, dot(norm , normalize(-dat.p)) * .5 + .5);\n            break;\n            \n         case STALK:\n            col = vec3(.4, 1., .2) * .8;\n            //col *= max(.0, dot(norm, vec3(0., 0., 1.)) * .5 + .5);\n            break;\n            \n        case GLOW:\n            col = vec3(1., .8,.3) * ((sin(iTime*6.) + cos(iTime*1.2)) * .1 + 1.2);\n            break;\n            \n         case OUTLINE:\n             col = vec3(0.);\n             break;\n             \n         case TREE:\n             col = vec3(.5, .2, .1);\n             break;\n        \n         default:\n            return vec3(.13, .02, .13)\n            //#ifdef DUSK\n                * duskmix(1., 2.2);\n            //#endif\n            ;\n    }\n    //col *= obj.point.y;\n    return col;\n}\n\n\nRMObj mino(RMObj a, RMObj b)\n{\n    if (a.d < b.d) \n        return a;\n    return b;\n}\n\nRMObj CatEar(vec3 p)\n{\n    p.x = abs(p.x);\n    RMObj o;\n    o.id = PUMPSKIN;\n    \n    p.xz *= rotd(60.);\n    vec3 pos = p - vec3(0.4,.62,.34);\n    \n    pos.xz *= rotd(-40.);\n    pos.yx *= rotd(-20.);\n    pos.xy *= rotd(10.);\n    o.d = smoothTriPyramid(pos, vec3(.6, 1., .4));\n    \n    pos -= vec3(0., 0.2, 0.2);\n    o.d = smin(o.d, sphere(pos, .15), 0.2);\n    \n    return o;\n}\n\nfloat EarHole(vec3 p)\n{\n    p.x = abs(p.x);\n    \n    p.xz *= rotd(60.);\n    vec3 pos = p - vec3(0.35,.6,.4);\n    \n    pos.xz *= rotd(-40.);\n    pos.yx *= rotd(-20.);\n    pos.xy *= rotd(10.);\n    pos.yz *= rotd(40.);\n    float d = triPrism(pos, vec3(.21, .8, .6));\n    \n    \n    pos -= vec3(0., 0.07, 0.35);\n    d = smin(d, sphere(pos, .125), 0.1);\n    \n    return d;\n}\n\nfloat Mouth(vec3 p)\n{\n    float d;\n    d = sphere(vec3(abs(p.x), p.y, p.z)  - vec3(0.11, -0.4, 0.9), .1);\n    d = smin(sphere(p - vec3(0., -0.4, 0.9), .05), d, .5);\n    d = smax(d, p.y + .3, .03);\n    d = smax(-sphere(vec3(abs(p.x), p.y, p.z)  - vec3(0.1, -0.15, 0.9), .2),\n        d, .01);\n    return d;\n}\n\n//might be optimized using bounds\nfloat PumpkinOut(vec3 p, float sm)\n{\n    p.y *= 0.9;\n    \n    vec3 pSize = vec3(1.,.9,.4);\n    float d = ellipsoid(p, pSize);\n    float l = 6.;\n    mat2 mRot = rot(PI / l);\n    for(float i = 1.; i < l; i++)\n    {\n        p.xz *= mRot;\n        d = smin(d, ellipsoid(p, pSize), sm);\n    }\n    \n    float ct = ellipsoid(p - vec3(0.,1.,.0), vec3(.3,.4,.3));\n    ct = min(ct, ellipsoid(p + vec3(0.,1.,.0), vec3(.5,.4,.5)));\n    \n    d = smax(d, -ct, .4);\n    \n    return d;\n}\n\nRMObj Pumpkin(vec3 p)\n{\n    p /= .96;\n    RMObj o;\n    o.id = PUMPINT;\n    float d = PumpkinOut(p, 0.01),\n          dO = d;\n          \n    //float\n    //cut = sphere(p - vec3(0.,1.4,0.), 1.);\n    //cut = max(-cut, PumpkinOut(p * 1.1, 0.02)); // pumpkin inside\n    //cut = max(cut, -sphere(p - vec3(0.,1.42,0.), 1.));\n    \n    //d = max(d, -cut);\n    \n    //d = cut;\n    \n    o.d = abs(d) - .05;\n    //o.d *= 1.1;\n    if(d > 0.)\n        o.id = PUMPSKIN;\n    return o;\n}\n\nfloat Stalk(vec3 p)\n{\n    if(p.y < .7 || p.x*p.z > .2) //optimizes noise function usage\n        return MAX_DIST;\n            \n    p -= vec3(0., 1.1, 0.);\n    float disp = noise(p * vec3(1., .35, 1.) * 30.) * .03;\n    float off = noise(vec3(0., p.y, 0.) * 5.) * .2; //not using 1d noise because got good values right away and negligible performance difference\n    p.x +=  off - .07;\n    return cylinder(p, vec2(0.12-p.y/10., 0.4)) + disp - .03;\n}\n\nRMObj NekoLantern(vec3 p)\n{\n    \n    //RMObj a = smin(box(p, 1.), sphere(p, 1.), .7);\n    RMObj b = Pumpkin(p);\n    b.d = smin(CatEar(p).d, b.d,0.02);\n    float comp = b.d;\n    \n    float cut;\n    //inside\n    cut = PumpkinOut(p * 1.1, 0.01);\n    \n    //eyes\n    vec3 eyePos = vec3(abs(p.x), p.y, p.z) - vec3(.44,.4,.84);\n    cut = min(sphere(eyePos,.24), cut);\n    \n    //nose\n    cut  = min(triPrism(p - vec3(0., 0., 1.), vec3(.12, -0.8, .5)), cut);\n    \n    //mouth\n    cut = min(Mouth(p), cut);\n    \n    //earholes\n    cut = min(EarHole(p), cut);\n    //b.d = min(EarHole(p), b.d);\n    \n    b.d = max(-cut, b.d);\n    \n    if(b.d - comp > 0.012)\n#ifndef DISABLE_GLOW\n        b.id = PUMPINT;\n#else\n        b.id = PUMPINT;\n#endif\n        \n        \n    comp = b.d;\n    \n    //fang :D\n    vec3 fangPos = p - vec3(FANG_POS 0.111, -0.35, .894);\n    fangPos.xz *= rotd(FANG_POS 32.);\n    b.d = min(triPrism(fangPos, vec3(.07, -0.8, .014)), b.d);\n    if(b.d != comp)\n        b.id = PUMPINT;\n    \n    comp = b.d;\n    //stalk\n    b.d = min(Stalk(p), b.d);\n    \n    if(b.d != comp)\n        b.id = STALK;\n    \n    return b;\n}\n\nRMObj PumpkinGlow(vec3 p)\n{\n    RMObj s;\n    s.d = PumpkinOut(p * 1.11, 0.02);\n    s.id = GLOW;\n    return s;\n}\n\nRMObj Tree(vec3 p)\n{\n    RMObj o;\n    p -= vec3(-2., 1.5, 0.);\n    float disp = noise(p * vec3(1., .35, 1.) * 30.) * .06;\n    float off = noise(vec3(0., p.y*.4, 0.) * 5.) * .2;\n    p.x +=  off;\n    o.d = cylinder(p, vec2(.5-p.y/30., 3.));\n    o.d += disp - .029;\n    o.d *= .55;\n    o.id = TREE;\n    return o;\n}\n\nRMObj Ground(vec3 p)\n{\n    //p.y += noise(p*7.) * .1;\n    RMObj o;\n    o.id = GROUND;\n    o.d = max(p.y + .81, length(p.xz) - 8.);\n    return o;\n}\n\nRMObj GetSceneDist(vec3 p)\n{\n    RMObj o = NekoLantern(p);\n    o = mino(o, Ground(p));\n#ifndef DISABLE_GLOW\n    o = mino(o, PumpkinGlow(p));\n#endif\n#ifdef SHOW_TREE\n    o = mino(o, Tree(p));\n#endif\n    return o;\n}\n\nvec3 GetSceneNormal(vec3 p)\n{\n\tfloat d = GetSceneDist(p).d;\n    vec2 e = vec2(.01, 0.00);\n    \n    vec3 n = d - vec3(\n        GetSceneDist(p-e.xyy).d,\n        GetSceneDist(p-e.yxy).d,\n        GetSceneDist(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\nRMOut March(vec3 ro, vec3 rd)\n{\n    RMOut o;\n    float dS, dO;\n    RMObj dObj;\n    vec3 p;int it = 0;\n    int bId = -1;\n    for(; it < MAX_STEPS; it++)\n    {\n        p = ro + rd * dO;\n        dObj = GetSceneDist(p);\n        dS = dObj.d;\n                \n        dO += dS;\n                \n        if(dO>MAX_DIST)\n        {\n            o.o.id = NONE;\n            break;\n        }\n        \n        if(abs(dS)<SURF_DIST)\n        {\n           o.o = dObj;\n        }\n        \n        if(abs(dS) < SURF_DIST * 12.)\n        {\n            if(bId == -1)\n                bId = dObj.id;\n            else if(bId != dObj.id)\n            {\n                o.o.id = OUTLINE;\n                break;\n            }\n        }\n    }\n    \n    o.o.d = dO;\n    o.p = p;\n    //o.id = 0;\n    return o;\n}\n\nfloat shadow(vec3 p)\n{\n    vec3 lg = vec3(-1.,2.4,2.);\n    \n    vec3 rd = normalize(lg - p);\n    \n    //return(GetSceneDist(p).d < dist) ? 0.1 : 1.;\n    RMOut sr = March(p + rd * SURF_DIST, rd);\n        \n    if (sr.o.d - 1. < distance(p, lg))\n      return 0.6;\n      \n    return 1.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n\tvec2 m = vec2(0.063,.51);\n    if(iMouse.z > 0.)\n    {\n        m = iMouse.xy/iResolution.xy;\n        m.x = m.x * 2. - 1.;\n        m.y = (1. - m.y) / 3. + .5;\n    }\n    else\n        m.x -= (max(0., iTime - 2.) * .125);\n    \n    float zoom = 2.5;\n    vec3 ro = vec3(0., 0., 7.);\n    ro.yz *= rot(-m.y*PI+1.5);\n    ro.xz *= rot(-m.x*TAU);\n    \n    \n    vec3 lookat = vec3(0., 0.35, 0.),\n         f = normalize(lookat - ro),\n         r = normalize(cross(vec3(0., 1., 0.), f)),\n         u = cross(f, r),\n         cc = ro + f * zoom;\n    \n    vec3 col = vec3(0.);\n    RMOut shadowRes; //only calculate shadow once with anti aliasing\n    \n#if AA>1\n    float aa = float(AA);\n    for(float m = 0.; m < aa; ++m)\n    for(float n = 0.; n < aa; ++n)\n    {\n        #ifdef MY_AA\n        vec3 i = cc + (uv.x + m/aa/iResolution.y * .5) * r + (uv.y + m/aa/iResolution.y * .5) * u;\n        #else\n        vec2 o = (vec2(float(m),float(n)) / aa - 0.5) / iResolution.y;\n        vec3 i = cc + (uv.x + o.x) * r + (uv.y + o.y) * u;\n        #endif\n        \n#else\n        vec3 i = cc + uv.x * r + uv.y * u;\n#endif\n        vec3 rd = normalize(i - ro);\n        \n        RMOut s = March(ro, rd);\n        shadowRes = s;\n        vec3 coli = \n            GetColor(s)\n            //Color[s.o.id + 1]\n            ;\n        \n        if(s.o.id != NONE && s.o.id != GLOW)\n        {            \n            if(s.o.id != GROUND)\n            {\n                //main outline\n                float ol = dot(-rd, GetSceneNormal(s.p));\n                coli *= ol < 0.16 ? 0. : 1.;\n            }\n        }\n        \n        //coli *= softshadow(s.p, -rd, .008, 1., 32.);\n        \n        coli += .1;\n        col += coli;\n#if AA > 1\n    }\n    col /= float(AA * AA);\n#endif\n\n    if(shadowRes.o.id != NONE && shadowRes.o.id != GLOW)\n    {\n        #ifdef SHADOW\n        float shade = shadow(shadowRes.p);\n        if(shadowRes.o.id == PUMPINT)\n            shade = clamp(0., 1., shade * 1.3);\n        col *= shade;\n        #endif\n    }\n    \n    col = duskmix(pow(col, vec3(0.4545)), col);\n    col -= .3;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Horizontal blurring + boom cutoff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 s = 1. / iResolution.xy;   \n   vec2 pos = fragCoord.xy * s;\n   fragColor = vec4(bloomY(iChannel0, pos, s), 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}