{"ver":"0.1","info":{"id":"DlScWR","date":"1691630409","viewed":26,"name":"Ray-Infinite Cones (2d slice)","username":"Envy24","description":"See Image tab header.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","ray","intersection","infinite","cones"],"hasliked":0,"parentid":"dlSyRw","parentname":"Ray-Cylinder (2d slice)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Scene defined in 3d, but you see a slice for some z value.\n    Mouse.y changes z coordinate for slice.\n    Both cones are visible.\n    Version without switch can be finded in Common tab.\n    \n    Debug:\n        Lower left dot - last executed branch (case),\n        Lower right dot - picked root (if any).\n    \n    In 3d: https://www.shadertoy.com/view/mlfcWf\n    \n    Cone is much harder for me to do, then cylinder)\n*/\n\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 2.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n \nstruct RAY\n{\n    vec3 position;\n    vec3 direction;\n};\nstruct HIT\n{\n    bool hit_something;\n    float hit_dist;\n    vec3 hit_point;\n    vec3 hp_normal;\n    int hitted_idx;\n};\nvec3 debug_color = vec3(0);\nvec3 root_color = vec3(0);\n\nHIT ray_infinite_cones_XZ_int(RAY ray)\n{\n    // Cone definition:\n    // pos = vec3(0)\n    // equatuion: x^2 + z^2 = y^2\n\n    float A = ray.position.x, B = ray.direction.x,\n          F = ray.position.z, G = ray.direction.z,\n          C = ray.position.y, D = ray.direction.y,        \n          a = B*B + G*G - D*D,\n          b = 2. * (A*B + F*G - C*D),\n          c = A*A + F*F - C*C;\n    \n    HIT hit;\n    /* Solve A*t^2 + B*t + C = 0 */\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.) // no real roots?\n    {\n        debug_color = vec3(1,0,0); // red\n        hit.hit_something = false; \n        return hit; \n    }\n    \n    float sqrt_D = sqrt(discriminant),\n          rootA = (-b + sqrt_D) / (2. * a),\n          rootB = (-b - sqrt_D) / (2. * a);\n    /**/             \n       \n    float root;\n    int root_case =             // How to read:\n        int(rootA > 0.) |        // 0b0x\n        (int(rootB > 0.) << 1);  // 0bx0\n        \n    switch(root_case)\n    {\n    case 0: // 0b00, rootA < 0, rootB < 0., noo roots to pick, cone behind camera.   \n        debug_color = vec3(0,1,0); // green\n        \n        hit.hit_something = false; \n        return hit;\n    case 1: // 0b01, rootA > 0, rootB < 0, pick positive root.\n    case 2: // 0b10, rootA < 0, rootB > 0, pick positive root.\n        root = max(rootA, rootB);\n        \n        debug_color = vec3(0,0,1); // blue\n        break;\n    case 3: // 0b11, rootA > 0, rootB > 0, pick smallest root.\n        root = min(rootA, rootB);\n        \n        debug_color = vec3(1,1,0); // yellow\n        break;\n    }\n    \n    vec3 hpA = ray.position + ray.direction * rootA,\n         hpB = ray.position + ray.direction * rootB,\n         cam = ray.position;\n         \n    int orientation_case =                         // How to read:    \n        int(dot(cam.xz, cam.xz) < cam.y*cam.y) |   // 0b000x // Camera is inside?      \n        (int(dot(cam, vec3(0,1,0)) > 0.) << 1) |   // 0b00x0 // Camera is on side T?      \n        (int(hpA.y > 0.) << 2) |                   // 0b0x00 // hpA on side T?        \n        (int(hpB.y > 0.) << 3);                    // 0bx000 // hpB on side T?\n    \n    switch (orientation_case)\n    {\n    case 15: // 0b1111, inside, cam on T, both hps on T.\n    case 1:  // 0b0001, inside, cam not on T, both hps not on T.\n        debug_color = vec3(0,1,1); // cyan\n        hit.hit_something = false;\n        return hit;\n    case 7:  // 0b0111, inside, cam on T, hpA on T.\n    case 11: // 0b1011, inside, cam on T, hpB on T.\n        debug_color = vec3(1,0,1); // magenta\n        root = min(hpA.y, hpB.y) == hpA.y ?\n            rootA : rootB;\n\n        break;\n    case 5: // 0b0101, inside, cam not on T, hpA on T\n    case 9: // 0b1001, inside, cam not on T, hpB on T\n        debug_color = vec3(0.5,0,0.5); // purple\n        root = max(hpA.y, hpB.y) == hpA.y ?\n            rootA : rootB;\n\n        break;\n    }\n       \n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = reflect(\n        -normalize(hit.hit_point),\n         normalize(vec3(hit.hit_point.x, 0., hit.hit_point.z))); // geometric\n    //hit.hp_normal = normalize(\n    //    vec3(2.*hit.hit_point.x*root + hit.hit_point.x,\n    //        -2.*hit.hit_point.y*root + hit.hit_point.y,\n    //         2.*hit.hit_point.z*root + hit.hit_point.z)); // parametric\n    \n   root_color = root == rootA ?\n       vec3(1,0,0) : vec3(0,0,1);\n    \n    return hit;\n}\n\nfloat implicit(float x, float y, float z) \n{   \n   return x*x + z*z - y*y; \n}\nfloat implicitAA( in vec3 P )\n{\n    float coverage = 0., // You can cheat and set this variable to some negative value.\n          th = 6.,        // thickness\n          c = implicit(P.x, P.y, P.z) >= 0. ? 1. : -1.; // only sign\n    \n    vec2 ps = vec2(0.35*SCENE_SCALE/iResolution.y); // affects thickness and artifacts\n   \n    // Supersampling.\n    for (float y = -th; y <= th; y += 1.)\n        for (float x = -th; x <= th; x += 1.)\n        {\n            vec3 p = P + vec3(x, y, 0)*vec3(ps, 0);\n            float n = implicit(p.x, p.y, p.z);\n            \n            /* 1. Filled shape *\n            coverage += n >= 0.0 ? 0.0 : 1.0;\n            /* 2. Shape contour */\n            n = n >= 0.0 ? 1. : -1.;\n            coverage += c == n ? 0. : 1.;\n            /**/\n        }\n  \n    // Convert coverage into intensity (.35 is arbitrary weight for AA).\n    return smoothstep(0., th*th, coverage*0.35);\n}\n \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :  \n              map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    // Z for slice.\n    float //z_coord = 0.;\n          z_coord = MP.y;\n          \n    // Draw 2d slice.\n    vec3 point3d = vec3(NDC, z_coord);\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF(NDC, vec2(0), 0.02)));\n    color = mix(color, vec3(0,0,1), implicitAA(point3d));\n\n    // Ray position, direction.\n    float T = iTime * 0.2;\n    vec3 //r_orig = vec3(-0.5, 1, z_coord),\n         r_orig = vec3(2. * cos(T), 2. * sin(cos(T*2.5)), z_coord),\n         //r_orig = vec3(MP, z_coord),\n         r_dir = normalize(vec3(0.5, 0.2, z_coord) - r_orig);\n         //r_dir = normalize(vec3(MP, z_coord) - r_orig);\n         \n    color = mix(color, vec3(0.5), SMAA(diskSDF(NDC, r_orig.xy, 0.03)));  \n    color = mix(color, vec3(0.7), SMAA(segmentSDF(NDC, r_orig.xy, (r_orig+r_dir*100.).xy, 0.)));\n    color = mix(color, vec3(1,0,1), SMAA(arrowSDF(NDC, r_orig.xy, (r_orig+r_dir).xy, 0.)));\n    \n    // Intersection.\n    RAY ray = RAY(r_orig, r_dir);\n    HIT hit = ray_infinite_cones_XZ_int(ray);\n    \n    // Color for last executed branch.\n    color = mix(color, debug_color, SMAA(diskSDF(NDC, vec2(-4, -2), 0.1)));\n    \n    if (hit.hit_something == true)\n    {\n        color = mix(color, root_color, SMAA(diskSDF(NDC, vec2(-3, -2), 0.1)));\n    \n        color = mix(color, vec3(0, 0.5, 0.5), SMAA(diskSDF(NDC, hit.hit_point.xy, 0.03)));\n        color = mix(color, vec3(0, 0.5, 0.5), SMAA(arrowSDF(NDC, hit.hit_point.xy, hit.hit_point.xy + hit.hp_normal.xy, 0.)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0475, //      U--\n         U = C + up  * 0.030,  // B----C----E\n         D = C - up  * 0.030;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.0475 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n/**\nHIT ray_cone_XZ_int(RAY ray)\n{\n    // Cone definition:\n    // pos = vec3(0)\n    // equatuion: x^2 + z^2 = y^2\n\n    float A = ray.position.x, B = ray.direction.x,\n          F = ray.position.z, G = ray.direction.z,\n          C = ray.position.y, D = ray.direction.y,        \n          a = B*B + G*G - D*D,\n          b = 2. * (A*B + F*G - C*D),\n          c = A*A + F*F - C*C;\n    \n    // Solve A*t^2 + B*t + C = 0\n    float discriminant = b * b - 4.0 * a * c,\n          sqrt_D = sqrt(discriminant),\n          rootA = (-b + sqrt_D) / (2. * a),\n          rootB = (-b - sqrt_D) / (2. * a);\n    //             \n       \n    HIT hit;\n        \n    if (discriminant < 0. ||       // no real roots?\n        rootA < 0. && rootB < 0.)  // behind camera?\n    { \n        debug_color = vec3(1,0,0); // red\n        hit.hit_something = false; \n        return hit; \n    }\n       \n    float root;\n    if (rootA > 0. && rootB < 0.)\n    {\n        debug_color = vec3(0,1,0); // green\n        root = rootA;\n        root_color = vec3(1,0,0);\n    }\n    else if (rootA < 0. && rootB > 0.)\n    {\n        debug_color = vec3(0,0,1); // blue\n        root = rootB;\n        root_color = vec3(0,0,1);\n    }\n    else\n    {\n        debug_color = vec3(1,1,0); // yellow\n        root = min(rootA, rootB);\n        \n        root_color = root == rootA ?\n            vec3(1,0,0) : vec3(0,0,1);\n    }\n\n    vec3 cam = ray.position;\n    bool cam_is_inside = dot(cam.xz, cam.xz) < cam.y*cam.y;\n    bool cam_on_side_A = dot(cam, vec3(0,1,0)) > 0.;\n    \n    if (cam_is_inside)\n    {        \n        vec3 hpA = ray.position + ray.direction * rootA;\n        vec3 hpB = ray.position + ray.direction * rootB;\n    \n        if (cam_on_side_A)\n        {\n            debug_color = vec3(0.5,0.5,0);\n        \n            if (hpA.y > 0. && hpB.y > 0.)\n            {\n                hit.hit_something = false;\n                return hit;\n            }\n            \n            float y = min(hpA.y, hpB.y);\n            root = y == hpA.y ?\n                rootA : rootB;\n                \n            root_color = root == rootA ?\n                vec3(1,0,0) : vec3(0,0,1);\n        }\n        else\n        {\n            debug_color = vec3(0,0.5,0.5);\n        \n            if (hpA.y < 0. && hpB.y < 0.)\n            {\n                hit.hit_something = false;\n                return hit;\n            }\n            \n            float y = max(hpA.y, hpB.y);\n            root = y == hpA.y ?\n                rootA : rootB;\n        }\n    }\n    \n    hit.hit_something = true;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = reflect(\n        -normalize(hit.hit_point),\n         normalize(vec3(hit.hit_point.x, 0., hit.hit_point.z))); // geometric\n    //hit.hp_normal = normalize(\n    //    vec3(2.*hit.hit_point.x*root + hit.hit_point.x,\n    //        -2.*hit.hit_point.y*root + hit.hit_point.y,\n    //         2.*hit.hit_point.z*root + hit.hit_point.z)); // parametric\n    \n    return hit;\n}\n/**/","name":"Common","description":"","type":"common"}]}