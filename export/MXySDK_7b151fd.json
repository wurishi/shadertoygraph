{"ver":"0.1","info":{"id":"MXySDK","date":"1720576465","viewed":183,"name":"ğ™°ğš‚ğ™²ğ™¸ğ™¸ ğ™µğš’ğš•ğšğšğš› ğ™¾_ğš˜","username":"___lampada","description":"An ASCII filter based on the genius implementation by movAX13h and inspired by Acerola video on ASCII rendering. You can find the original ones here: \n- https://www.shadertoy.com/view/lssGDj\n- https://www.youtube.com/watch?v=gg40RWiaHRY","likes":7,"published":1,"flags":2,"usePreview":0,"tags":["filter","ascii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nASCII filter. Current version from July 7, 2024.\nBased on the genius implementation by movAX13h and inspired by Acerola's video on ASCII rendering.\nOriginal ones here: \n- movAX13h : https://www.shadertoy.com/view/lssGDj\n- Acerola  : https://www.youtube.com/watch?v=gg40RWiaHRY\n\nI plan to try implementing the border detection to render ASCII borders, so expect some update someday.\n\nFor more ASCII bitmap generation: https://thrill-project.com/archiv/coding/bitmap/\n\nFor this version, I focused on understanding the basic ideas and implementing it \nin a legible way for me. For this, I have implemented: \n- A helper grayscale function; \n- A downsampled uv function to help downsample the coordinates, therefore the image; \n- The original character function, that now deals more clearly with spacing and modulates \nsome more the original code.\n*/\n\n#define CHAR_SIZE 5.0\n#define SPACING 1.0\n\nfloat grayscale(vec3 p){\n    /*Convertes a given pixel to grayscale.\n    Parameters\n    ----------\n    \n    p : vec3\n        rgb pixel.\n    */\n    return 0.299*p.r + 0.587*p.g + 0.114*p.b;\n}\n\nvec2 downsampled_uv(vec2 coord, float d){\n    /*Maps the current position to a downsampled position\n    \n    Parameters\n    ----------\n    \n    coord : vec2\n        Current pixel position.\n    d : float\n        downsample proportion (image will be d times smaller)\n    */\n\n    // Below line maps the current position to a downsampled uv\n    // mod(fragCoord.x, d) is the distance from the current position from the target\n    // position, so it is just subtracted.\n    return vec2( coord.x - mod(coord.x, d), coord.y - mod(coord.y, d) ) / iResolution.xy; \n}\n\nfloat character(uint char, vec2 p){\n    /*Returns if current pixel corresponds to character bounds\n    \n    Parameters\n    ----------\n    \n    char : uint\n        character 2^25 (5x5) bitmap value. \n    p : vec2\n        fragment position.\n    */\n    vec2 local_p = vec2( mod(p.x + 0.5, CHAR_SIZE + 2.0*SPACING), // ALWAYS sum +0.5\n                         mod(p.y + 0.5, CHAR_SIZE + 2.0*SPACING));// ALWAYS sum +0.5\n    \n    //Checks if pixel position is beyond character limits, if yes then returns 0.0\n    if(local_p.x < SPACING || local_p.x > CHAR_SIZE + (SPACING - 1.0)) \n        return 0.0;\n    if(local_p.y < SPACING || local_p.y > CHAR_SIZE + (SPACING - 1.0))\n        return 0.0;\n    \n    //Starts at bottom-left position\n    uint start = 16u; //0b0000000000000000000010000\n    uint bit_pos = start >> int(local_p.x - SPACING); // x offset\n    bit_pos = bit_pos << int(CHAR_SIZE*(local_p.y - SPACING)); // y offset\n    uint result = bit_pos & char; // acts as a mask to filter only the pixel value\n    \n    // bitshifts to the most significant bit so it does not overflow the output\n    return float(result >> int( CHAR_SIZE-(local_p.x - (SPACING - 1.0)) ) +\n                           int( CHAR_SIZE*(local_p.y - (SPACING)      ) )  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float levels_size = 8.0;\n\n    vec2 uv = downsampled_uv(fragCoord, CHAR_SIZE + 2.0*SPACING);\n\n  /*char levels    =        (  , .  , :     , >       , *      , o        , @        , â–„       )*/\n    uint levels[8] = uint[8](0u, 16u, 65600u, 4357252u, 163153u, 15255086u, 13195790u, 1048544u);\n\n    vec3 tex = texture(iChannel0, uv).rgb;\n    float gray = grayscale(tex);\n    \n    float ds = 1.0/levels_size; //levels size\n    \n    uint final_value = 0u;\n    for(float i = 0.0; i < levels_size; i++) //Runs for every intensity level\n        if(gray > 0.0 + i*ds) final_value = levels[int(i)];\n\n    fragColor = vec4( tex*character(final_value, fragCoord) , 1.0);\n}","name":"Image","description":"","type":"image"}]}