{"ver":"0.1","info":{"id":"ctyfRW","date":"1701871230","viewed":67,"name":"Remix - Angular Grid + Color Viz","username":"MV10","description":"A cool combo my stand-alone music viz app coughed up last night. Combines iz's audio variant on his Angular Grid, post-processed by gPlatl's [url=https://www.shadertoy.com/view/ltyGR3]Cheap Color Visualizer[/url] originally by stduhpf in grayscale.","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["2d","sound","normalmapping","angulargrid"],"hasliked":0,"parentid":"mlfSWn","parentname":"Angular Beat Box Grid"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// gPlatl's Really Cheap Color Visualizer https://www.shadertoy.com/view/ltyGR3\n// which colorizes studuhpf's grayscale Really Cheap Visualizer https://www.shadertoy.com/view/MlV3DW\n\n#define usemic false // for some reason the mic input does not work the same as soundcloud or the basic sound input\n#define n 7.         // number of rays\n#define T(v) 0.8*texture(iChannel0,abs((v)-fract(p))) \n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    float time = iTime*0.05;\n    vec2 R = iResolution.xy;\n    u = (u + u - R) / R.y;\n    float t = cos(time+length(u)*20.*sin(time*14.))/10.;\n    u *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    vec2 p = vec2(exp2(length(u))-16.0*time,0.5*n*atan(u.y,u.x)/acos(-1.));\n    o.r = T(usemic ? 0.98 : 0.3).r; \n    o.g = T(usemic ? 0.79 : 0.5).r; \n    o.b = T(usemic ? 0.86 : 0.7).r; \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ms33zf","filepath":"https://soundcloud.com/george-acosta-official/19-1","previewfilepath":"https://soundcloud.com/george-acosta-official/19-1","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Originally Buffer A tab from iz's Angular Beat Box Grid https://www.shadertoy.com/view/mlfSWn\n\nfloat hash(in float _x) { return fract(5313.235 * mod(_x, 0.75182) * mod(_x, 0.1242)); }\nfloat noise(in float _x) { float i = floor(_x); float f = fract(_x); return mix(hash(i), hash(i + 1.), 3.*f*f - 2.*f*f*f); }\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ATR(_aid, _layer, _f) if (coord.x == _aid && coord.y == _layer) { ctrl.r = _f; }\n#define ATF(_aid, _layer, _f) if (coord.x == _aid && coord.y == _layer) { ctrl = _f; }\n#define LIGHT 4\n#define RAD_COLS 5\n#define FRAME_CONSTS 6\n#define SOUND 7\n#define TTIME 10\n#define GRID_COL 12\n#define GRID_COL2 13\n#define GRID_COL3 14\n#define GRID_COL4 15\n\n#define SOUND_BIN_SIZE 4.\nconst float N_BINS = 512. / SOUND_BIN_SIZE;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ctrl;\n    ivec2 coord = ivec2(fragCoord);\n    // float t[3] = float[3](iTime, iTime - 3., iTime - 6.); - crashes mobile browsers\n    float t0 = iTime;\n    float t1 = iTime - 3.;\n    float t2 = iTime - 6.;\n    \n    for (int layer = 0; layer < 3; layer++)\n    {\n        float t = layer == 0 ? t0 : layer == 1 ? t1 : t2;\n        // transform states\n        ATR(0,layer, noise(t * 0.18 + 1.3))\n        ATR(1,layer, cos(6.28 * noise(t * 0.1 + 193.)))\n        ATR(2,layer, sin(6.28 * noise(t * 0.1 + 35.)))\n        ATR(3,layer, noise(t * 0.1 + 17.))\n        ATR(4,layer, noise(t * 0.13 + 31.))\n        ATR(5,layer, noise(t * 0.21 + 73.))\n        ATR(6,layer, noise(t * 0.1 + 23.))\n        \n        //\n        ATR(7,layer, 0.1 + 0.1 * noise(t * 0.25 + 21.))\n        ATR(8,layer, noise(t * 0.5 + 3.2))\n        ATR(9,layer, noise(t * 0.5 + 4.7))\n        ATR(10,layer, noise(t * 0.1))\n        ATR(11,layer, noise(t * 0.25 + 321.23) * 0.5)\n        ATR(12,layer, 1.5 * PULSE_T(mod(t, 30.), 1.25, 8., 16.))\n        ATR(13,layer, 4.*t)\n        ATR(14,layer, noise(0.025 * t));\n        ATR(15,layer, 10. * PULSE_T(mod(t, 25.), 0.5, 10., 11.))\n    }\n    \n    // constants\n    ATF(0,LIGHT, vec4(0., 0., 5., 0.2));\n    ATF(1,LIGHT, vec4(0., 0.25, 3., 0.2));\n    ATF(2,LIGHT, vec4(-1., -1., 3., 0.2));\n    ATF(3,LIGHT, vec4(1., -1., 3., 0.2));\n    \n    // radial light colors\n    // https://www.shutterstock.com/blog/neon-color-palettes #12\n    ATF(0,RAD_COLS, vec4(0.808, 0.588, 0.984, 1.));\n    ATF(1,RAD_COLS, vec4(1.0, 0.561, 0.812, 1.));\n    ATF(2,RAD_COLS, vec4(0.0, 0.761, 0.729, 1.));\n    ATF(3,RAD_COLS, vec4(0.012, 0.478, 0.565, 1.));\n    \n    ATR(0, FRAME_CONSTS, PULSE_T(mod(t0, 60.), 10., 55., 1.));\n    ATR(1, FRAME_CONSTS, PULSE_T(mod(t0, 60.), 15., 55., 1.));\n    \n    // palettes\n    // may be set on frame 0 only\n    ATF(0, GRID_COL, vec4(1.0, 0.9607843137254902, 0.9215686274509803, 1.0));\n    ATF(1, GRID_COL, vec4(0.9977854671280277, 0.9275663206459055, 0.8573471741637831, 1.0));\n    ATF(2, GRID_COL, vec4(0.9955709342560554, 0.8907958477508651, 0.7855132641291811, 1.0));\n    ATF(3, GRID_COL, vec4(0.9933564013840831, 0.842076124567474, 0.6880738177623991, 1.0));\n    ATF(4, GRID_COL, vec4(0.9921568627450981, 0.7769934640522875, 0.5727028066128412, 1.0));\n    ATF(5, GRID_COL, vec4(0.9921568627450981, 0.7016993464052288, 0.45090349865436374, 1.0));\n    ATF(6, GRID_COL, vec4(0.9921568627450981, 0.6280507497116494, 0.34226835832372166, 1.0));\n    ATF(7, GRID_COL, vec4(0.9914186851211073, 0.550726643598616, 0.23277201076509035, 1.0));\n    ATF(8, GRID_COL, vec4(0.9648442906574395, 0.47100346020761247, 0.14197616301422528, 1.0));\n    ATF(9, GRID_COL, vec4(0.9314417531718571, 0.39298731257208774, 0.06426758938869671, 1.0));\n    ATF(10, GRID_COL, vec4(0.8782929642445213, 0.31990772779700116, 0.024405997693194924, 1.0));\n    ATF(11, GRID_COL, vec4(0.7898039215686274, 0.26076124567474046, 0.006320645905420991, 1.0));\n    ATF(12, GRID_COL, vec4(0.6768627450980392, 0.22089965397923875, 0.010749711649365626, 1.0));\n    ATF(13, GRID_COL, vec4(0.5844059976931949, 0.186159169550173, 0.013471741637831602, 1.0));\n    ATF(14, GRID_COL, vec4(0.4980392156862745, 0.15294117647058825, 0.01568627450980392, 1.0));\n    \n    ATF(0, GRID_COL3, vec4(1.0, 0.9607843137254902, 0.9411764705882353, 1.0));\n    ATF(1, GRID_COL3, vec4(0.9977854671280277, 0.9142791234140715, 0.8747404844290657, 1.0));\n    ATF(2, GRID_COL3, vec4(0.9950634371395617, 0.8596539792387543, 0.7986620530565167, 1.0));\n    ATF(3, GRID_COL3, vec4(0.990634371395617, 0.7777162629757786, 0.6901499423298731, 1.0));\n    ATF(4, GRID_COL3, vec4(0.9882352941176471, 0.6866743560169165, 0.5778854286812765, 1.0));\n    ATF(5, GRID_COL3, vec4(0.9882352941176471, 0.5958785082660515, 0.4738023836985775, 1.0));\n    ATF(6, GRID_COL3, vec4(0.9865897731641676, 0.5067281814686659, 0.38123798539023457, 1.0));\n    ATF(7, GRID_COL3, vec4(0.9835755478662053, 0.4127950788158401, 0.28835063437139563, 1.0));\n    ATF(8, GRID_COL3, vec4(0.9570011534025374, 0.3087120338331411, 0.22191464821222606, 1.0));\n    ATF(9, GRID_COL3, vec4(0.9167704728950405, 0.21145713187235693, 0.16401384083044987, 1.0));\n    ATF(10, GRID_COL3, vec4(0.8370472895040368, 0.13394848135332565, 0.13079584775086506, 1.0));\n    ATF(11, GRID_COL3, vec4(0.7504959630911188, 0.08332179930795848, 0.10412918108419839, 1.0));\n    ATF(12, GRID_COL3, vec4(0.6663437139561708, 0.06339100346020761, 0.08641291810841982, 1.0));\n    ATF(13, GRID_COL3, vec4(0.5412226066897348, 0.03321799307958477, 0.06869665513264128, 1.0));\n    ATF(14, GRID_COL3, vec4(0.403921568627451, 0.0, 0.05098039215686274, 1.0));\n    \n    ATF(0, GRID_COL2, vec4(0.9686274509803922, 0.984313725490196, 1.0, 1.0));\n    ATF(1, GRID_COL2, vec4(0.9132641291810842, 0.9488811995386389, 0.9822837370242214, 1.0));\n    ATF(2, GRID_COL2, vec4(0.8584083044982699, 0.9134486735870818, 0.9645674740484429, 1.0));\n    ATF(3, GRID_COL2, vec4(0.8052595155709343, 0.8780161476355247, 0.9468512110726643, 1.0));\n    ATF(4, GRID_COL2, vec4(0.7309496347558632, 0.8394771241830065, 0.9213225682429834, 1.0));\n    ATF(5, GRID_COL2, vec4(0.6423683198769704, 0.8018300653594771, 0.890319108035371, 1.0));\n    ATF(6, GRID_COL2, vec4(0.5356862745098039, 0.746082276047674, 0.8642522106881968, 1.0));\n    ATF(7, GRID_COL2, vec4(0.41708573625528644, 0.6806305267204922, 0.8382314494425221, 1.0));\n    ATF(8, GRID_COL2, vec4(0.32628988850442137, 0.6186236063052672, 0.802798923490965, 1.0));\n    ATF(9, GRID_COL2, vec4(0.24004613610149955, 0.5537716262975779, 0.7667973856209152, 1.0));\n    ATF(10, GRID_COL2, vec4(0.16696655132641292, 0.48069204152249134, 0.7291503267973857, 1.0));\n    ATF(11, GRID_COL2, vec4(0.09942329873125721, 0.4047520184544406, 0.6798154555940024, 1.0));\n    ATF(12, GRID_COL2, vec4(0.044059976931949255, 0.3338869665513264, 0.6244521337946944, 1.0));\n    ATF(13, GRID_COL2, vec4(0.03137254901960784, 0.2613148788927335, 0.5281199538638985, 1.0));\n    ATF(14, GRID_COL2, vec4(0.03137254901960784, 0.18823529411764706, 0.4196078431372549, 1.0));\n    \n    ATF(0, GRID_COL4, vec4(0.9686274509803922, 0.9882352941176471, 0.9607843137254902, 1.0));\n    ATF(1, GRID_COL4, vec4(0.9287658592848904, 0.9727335640138408, 0.9142791234140715, 1.0));\n    ATF(2, GRID_COL4, vec4(0.8828143021914648, 0.9546943483275664, 0.8621914648212226, 1.0));\n    ATF(3, GRID_COL4, vec4(0.8163783160322953, 0.9281199538638985, 0.7913264129181085, 1.0));\n    ATF(4, GRID_COL4, vec4(0.7371472510572856, 0.895517108804306, 0.7108342945021145, 1.0));\n    ATF(5, GRID_COL4, vec4(0.6529950019223376, 0.8600845828527489, 0.6288965782391387, 1.0));\n    ATF(6, GRID_COL4, vec4(0.5573241061130334, 0.8164244521337947, 0.546958861976163, 1.0));\n    ATF(7, GRID_COL4, vec4(0.45176470588235296, 0.7670895809304115, 0.4612072279892349, 1.0));\n    ATF(8, GRID_COL4, vec4(0.3388235294117647, 0.7117262591311034, 0.40584390618992694, 1.0));\n    ATF(9, GRID_COL4, vec4(0.2378316032295272, 0.6523798539023453, 0.3510495963091119, 1.0));\n    ATF(10, GRID_COL4, vec4(0.17139561707035755, 0.581514801999231, 0.2979008073817762, 1.0));\n    ATF(11, GRID_COL4, vec4(0.09527104959630911, 0.5091118800461361, 0.24059976931949248, 1.0));\n    ATF(12, GRID_COL4, vec4(0.017762399077277974, 0.44267589388696654, 0.18523644752018453, 1.0));\n    ATF(13, GRID_COL4, vec4(0.0, 0.3574625144175317, 0.14352941176470588, 1.0));\n    ATF(14, GRID_COL4, vec4(0.0, 0.26666666666666666, 0.10588235294117647, 1.0));\n    \n    // sound\n    // change frequency\n    const float beat = 1.30434;\n    const float cf = beat*0.25;\n    vec4 lt0 = texelFetch(iChannel0, ivec2(0, TTIME), 0);\n    vec4 ct;\n    ct.x = int(t0 * cf) != int(lt0.x * cf) ? t0 : lt0.x;\n    ct.y = int(t0 * 2. * cf) != int(lt0.y * cf) ? t0 : lt0.y;\n    ct.z = int(t0 * 4. * cf) != int(lt0.z * cf) ? t0 : lt0.z;\n    ct.w = int(t0 * 8. * cf) != int(lt0.w * cf) ? t0 : lt0.w;\n    \n    ATF(0, TTIME, ct);\n    \n    if (fragCoord.x < N_BINS)\n    {\n        vec2 sound;\n        \n        for (float is = 0.0; is < SOUND_BIN_SIZE; is++)\n        {\n          sound.x += texture(iChannel1, vec2((fragCoord.x*N_BINS + is)/iResolution.x, 0.0)).x;\n          sound.y += texture(iChannel1, vec2((fragCoord.x*N_BINS + is)/iResolution.x, 1.0)).y;\n        }\n        \n        sound /= SOUND_BIN_SIZE;\n\n        if (coord.y == SOUND) \n        { \n           vec4 lsnd = texture(iChannel0, vec2(fragCoord.xy/iResolution.xy));\n           ctrl.x = int(t0 * cf) != int(lt0.x * cf) ? sound.x : 0.9 * lsnd.x;\n           ctrl.y = int(t0 * 2. * cf) != int(lt0.y * cf) ? sound.x : 0.9  * lsnd.x;\n           ctrl.z = int(t0 * 4. * cf) != int(lt0.z * cf) ? sound.x : 0.85 * lsnd.z;\n           ctrl.w = int(t0 * 8. * cf) != int(lt0.w * cf) ? sound.x : 0.8  * lsnd.w;\n        }\n    }\n        \n    fragColor = vec4(ctrl);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Originally Image tab from iz's Angular Beat Box Grid https://www.shadertoy.com/view/mlfSWn\n\nfloat hash(in float _x) { return fract(5313.235 * mod(_x, 0.75182) * mod(_x, 0.1242)); }\nfloat noise(in float _x) { float i = floor(_x); float f = fract(_x); return mix(hash(i), hash(i + 1.), 3.*f*f - 2.*f*f*f); }\nvec3 smbox(in vec2 _f, in vec2 _t, in float _eps, in vec2 _uv) { vec2 bin = smoothstep(_f - _eps, _f, _uv) - smoothstep(_t, _t + _eps, _uv); return vec3(bin, bin.x * bin.y);}\n\n#define ANIM_T(_t, _e, _p) (smoothstep(_p - _e, _p, _t) - smoothstep(_p, _p + _e, _t))\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ASYM_PULSE_T(_t, _ea, _pa, _eb, _pb) (smoothstep(_pa - _ea, _pa, _t) - smoothstep(_pb, _pb + _eb, _t))\n\n#define ROT2D(p2d, ang) (cos(ang) * p2d.xy + sin(ang) * vec2(p2d.y, -p2d.x))\n#define TEX_LIGHT 4\n#define DF(_x, _m) 6. * (_x * _m - (_x * _x) / (_m * _m) )\n#define DRV(_x, _m) DF(_x, _m) * (step(0., _x) - step(_m, _x)) + (1. - DF(_x, _m)) * (step(1. - _m, _x) - step(1., _x))\n\n#define GET_PALETTE(_f) ((_f < 0.25) ? 0 : (_f < 0.5) ? 1 : (_f < 0.75) ? 2 : 3)\n\n//const vec4 lights[NLIGHTS] = vec4[NLIGHTS](vec4(0., 0., 5., 1.));\nconst vec2 vhex = normalize(vec2(1., 0.5));\nconst float hexh = 0.8660254037; // = sqrt(3) / 2;\nconst float inv_hexh = 1.15470053837;\nconst vec2 hexGrid = vec2(3., sqrt(3.));\n\n#define GRID_SIZE 5.\n#define N_RAD_COLS 4\n#define TEX_RAD_COLS 5\n#define TEX_FRAME_CONSTS 6\n#define TEX_SOUND 7\n#define TEX_GRID_COL 12\n#define TEX_GRID_COL2 13\n#define TEX_GRID_COL3 14\n#define TEX_GRID_COL4 15\n\n#define SOUND_BINS 128.\n\n#define FLW(_grid) ASYM_PULSE_T(mod(_grid.y + floor(_grid).x, 15.), 0.2, 2.5, 0.2, 2.6)\n#define RMARGIN(_grid) 0.05 * (1. + 0.5 * FLW(_grid))\n#define radialLine(_grid) ANIM_T(fract(_grid.x), RMARGIN(_grid), 0.5) * mix(0.9, 1.0, 0.5 + 0.5 * sin(6.28 * fract(_grid.y)))\n\n#define TR(_i, _layer) texelFetch(iChannel0, ivec2(_i, _layer), 0).r\n#define TF(_i, _layer) texelFetch(iChannel0, ivec2(_i, _layer), 0)\n\n#define N_GRID_COLS 15.\n\n#define CLT(_id, _noise, _c) TF(int(hash(_id) * _noise * N_GRID_COLS), _c).rgb\n\n//#define V_MOBILE\n\nvec4 hexgrid(in vec2 _uv)\n{\n  vec4 res;\n  vec2 a = mod(_uv + 0.5 * hexGrid, hexGrid) - 0.5 * hexGrid;\n  vec2 b = mod(_uv, hexGrid) - hexGrid * 0.5;\n  \n  vec2 fa = vec2(dot(abs(a), vhex), abs(a.y));\n  vec2 fb = vec2(dot(abs(b), vhex), abs(b.y));\n  \n  float ma = max(fa.x, fa.y);\n  float mb = max(fb.x, fb.y);\n  \n  vec2 bord;\n  vec2 id;\n  \n  if (ma < mb)\n  {\n    bord = fa;\n    id = floor((_uv + 0.5 * hexGrid) / hexGrid);\n  }\n  else\n  {\n    bord = fb;\n    id = floor(_uv/hexGrid) + vec2(123., 273.);\n  }\n  \n  res.x = min(ma, mb);\n  res.y = min(1. - bord.x, 1. - bord.y);\n  res.zw = id;\n  \n  return res;\n}\n\nvec2 transformUV(in vec2 uv, in float _t, in float _layer)\n{\n    uv *= (1. + 1.5 * TR(0,_layer) * length(uv));\n    vec2 st = uv - 0.2 * (_layer + 1.) * vec2(TR(1,_layer), TR(2,_layer));\n    uv.xy = ROT2D(st, TR(3,_layer));\n\n    float alpha = atan(abs(uv.y), uv.x);\n    float rad = length(uv);\n    vec2 angUv = vec2(alpha, rad);\n    vec2 angUv2 = vec2(atan(abs(angUv.y), angUv.x), length(angUv));\n    vec2 angUv3 = vec2(atan(angUv2.y, angUv2.x), length(angUv2));\n    vec2 angUv4 = vec2(atan(angUv3.y, angUv3.x), length(angUv3));\n\n    vec2 uva = mix(angUv, angUv2, TR(4, _layer));\n    vec2 uvb = mix(angUv3, angUv3, TR(5, _layer));\n\n    uv = mix(uva, uvb, TR(6, _layer));\n    \n    return uv * GRID_SIZE;\n}\n\nfloat filteredRadialLines(in vec2 uv, in float time, float invRes)\n{\n    vec2 uvh = transformUV(uv + vec2(1.25, 1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n    vec2 uvl = transformUV(uv + vec2(-1.25, 1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n    vec2 uvr = transformUV(uv + vec2(1.25, -1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n    vec2 uvd = transformUV(uv + vec2(-1.25, -1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n\n    float yh = radialLine(uvh);\n    float yl = radialLine(uvl);\n    float yr = radialLine(uvr);\n    float yd = radialLine(uvd);\n\n    return 0.25 * (yh + yl + yr + yd);\n}\n\nvec4 angularLayer(in vec2 uv, in vec2 grid, in float layer, float invRes, float radline)\n{ \n    vec2 igrid = floor(grid);\n    vec2 fgrid = fract(grid);\n    float gid = abs(igrid.x * 1000. + igrid.y);\n    \n    float margin = TR(7, layer);\n    \n    vec3 inside = smbox(vec2(margin), vec2(1. - margin), margin, fgrid);\n    \n    // analytical derivatives.\n    float dx = DRV(fgrid.x, margin);\n    float dy = DRV(fgrid.y, margin);\n    vec3 grad = normalize(vec3(dx, dy, iResolution.y * length(grid)));\n    \n    // numerical derivatives (not used).\n    //vec3 grad = normalize(vec3(dFdx(inside.x), dFdy(inside.y), 2.));\n    \n    // beat\n    float id_beat_cf = hash(gid);\n    vec4 beat = TF(mod(gid * 13., SOUND_BINS), TEX_SOUND);\n    // base to treble\n    vec4 bf;\n    bf.x = (1. + TR(20, layer)) * PULSE_T(id_beat_cf, 0.1, 0.01, 0.25);\n    bf.y = PULSE_T(id_beat_cf, 0.1, 0.25, 0.5);\n    bf.z = PULSE_T(id_beat_cf, 0.1, 0.5, 0.75);\n    bf.w = PULSE_T(id_beat_cf, 0.1, 0.75, 0.95);\n    \n    float border = 1. - (1. + noise(fgrid.x*20.)) * inside.z;\n\n    vec2 roadGrid = grid + vec2(0.5);\n    roadGrid.y += TR(13,layer);\n    vec2 iroadGrid = floor(roadGrid);\n    vec2 froadGrid = fract(roadGrid);\n    int rrID = int(iroadGrid.x);\n    float flowCf = ASYM_PULSE_T(mod(roadGrid.y + iroadGrid.x, 15.), 0.2, 2.5, 0.2, 2.6);\n    float roadMargin = 0.05 * (1. + 0.3 * flowCf);\n    float yroad = radline;\n    float shRoad = (1. + 0.2 * flowCf) * ANIM_T(froadGrid.x, roadMargin*3., 0.5);\n\n    ///\n    float attenuation = floor(max(grid.x, grid.y));\n    \n    float attCf = 1./(1. + invRes * attenuation * attenuation);\n    float intensity;\n    float spec;\n    for (int il = 0; il < 4; il++)\n    {\n      vec4 light = TF(il, TEX_LIGHT);\n      vec3 pl = normalize(light.xyz - vec3(uv, 0.));\n      float f = clamp(abs(dot(pl, grad)), 0., 1.);\n      intensity += light.w * f * attCf;\n      spec += light.w * clamp(dot(normalize(-reflect(pl, grad)), (vec3(TR(8,layer), TR(9,layer), -3.))), 0., 1.);\n    }\n    \n    float ns = TR(10,layer);\n    int palette = GET_PALETTE(TR(14, layer));\n    vec3 col = CLT(gid, ns, TEX_GRID_COL + palette);\n    \n#ifndef V_MOBILE\n    if (layer < 0.5)\n    {\n        // AA\n        // Smoothing raw color, before lighting.\n        float im = 0.05;\n        float flow = clamp((fgrid.y - im) / im, 0., 1.);\n        float fhigh = clamp((fgrid.y - (1. - im)) / im, 0., 1.);\n        vec3 colH = CLT(gid + 1., ns, TEX_GRID_COL + palette);\n        vec3 colL = CLT(gid - 1., ns, TEX_GRID_COL + palette);\n        col = mix(col, colH, 0.5 * fhigh);\n        col = mix(colL, col, 0.5 + 0.5 * flow);\n    }\n#endif\n    \n    vec4 road_beat = TF(rrID * 6 + 70, TEX_SOUND);\n    yroad *= (1. + road_beat[rrID % N_RAD_COLS]);\n    \n    col *= (1. + 1. * (inside.z) * dot(bf, beat));\n    // shadow y - angular sections\n    col -= TR(11,layer) * mod(igrid.x, 2.);\n    // waves\n    col *= (1. - border) + border * (0.75 * col);\n     // x - radial shadow lines.\n    col = mix(col, (shRoad) * col, shRoad * shRoad * (1. - 0.5 * TR(12,layer)));\n    \n    // x - radial colored lines.\n    col = mix(col, yroad * (1. + 0.5*flowCf) * TF(rrID % N_RAD_COLS, TEX_RAD_COLS).rgb, yroad);\n    // lighting.\n    col = intensity*col + spec * vec3(0.97, 0.87, 0.65);\n    \n    // \n    //col = 0.5 * grad + 0.5;\n    \n    return vec4(col, yroad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    float invRes = 1./iResolution.y;\n    \n    vec4 fcol;\n    float t = iTime;\n    \n    vec2 grid0 = transformUV(uv, t, 0.);\n    vec2 grid1 = transformUV(uv, t - 3., 1.);\n    vec2 grid2 = transformUV(uv, t - 6., 2.);\n   \n#ifndef V_MOBILE\n    // AA - filtered radial lines\n    // for layer 0 using 4 samples to draw the radial lines.\n    float rdl0 = filteredRadialLines(uv, t, invRes);\n#else\n    float rdl0 = radialLine((grid0 + 0.5));\n#endif\n    float rdl1 = radialLine((grid1 + 0.5));\n    float rdl2 = radialLine((grid2 + 0.5));\n    \n    vec4 c0 = angularLayer(uv, grid0, 0., invRes, rdl0);\n    vec4 c1 = angularLayer(uv, grid1, 1., invRes, rdl1);\n    vec4 c2 = angularLayer(uv, grid2, 2., invRes, rdl2);\n    \n    float f1 = TR(0, TEX_FRAME_CONSTS);\n    float f2 = TR(1, TEX_FRAME_CONSTS);\n    \n    fcol = c0;\n    fcol = mix(fcol, c1, 0.2 * f1);\n    fcol = mix(fcol, c2, 0.2 * f2);\n    \n    fcol.rgb = pow(fcol.rgb, vec3(2.2));\n    \n    fragColor = vec4(fcol);\n}","name":"Buffer B","description":"","type":"buffer"}]}