{"ver":"0.1","info":{"id":"NltfW4","date":"1675356635","viewed":256,"name":"Dead GPU glitch 02","username":"Oneleven","description":"Another somewhat realistish approach to screen glitch. This time using Morton Code for flattening 2d pixel positions into one dimensional array of indexes, which is closer to what GPU actually does.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["glitch","gpu","dead"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n\n//Morton Code by Suslik\n//https://www.shadertoy.com/view/NtVcDm\n\n//0b0000dcba -> 0b0d0c0b0a\nuint SpreadBits(uint x)\n{\n  x &= 0x0000ffffu;                   // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\n//0b0d0c0b0a -> 0b0000dcba\nuint GatherBits(uint x)\n{\n  x &= 0x55555555u;                   // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  x = (x ^ (x >>  1u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x >>  2u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x >>  4u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x >>  8u)) & 0x0000ffffu; // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  return x;\n}\n\n//0bhgfedcba -> (0b0000geca, 0b0000hfdb)\nuvec2 MortonToVec2(uint morton)\n{\n\n    uvec2 res;\n    res.x = GatherBits(morton >> 0);\n    res.y = GatherBits(morton >> 1);\n    return res;\n}\n\n//(0b0000dcba, 0b0000hgfe) -> 0bhdgcfbea\nuint Vec2ToMorton(uvec2 vec)\n{\n  return SpreadBits(vec.x) | (SpreadBits(vec.y) << 1);\n}\n\n\nfloat hash11(float u, float seed)\n{\n    return fract(sin(u)*999999.9999 + seed * 1.61803398875);\n}\n\n//Hash without Sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat noise(float u, float size, float seed)\n{\n    float zoom = u * size;\n    float index = floor(zoom);\n    float progress = fract(zoom);\n    progress = smoothstep(0.0, 1.0, progress);\n    float value = mix(hash11(index, seed), hash11(index + 1.0, seed), progress);\n    return value;\n}\n\nfloat posterize(float u, float steps)\n{\n    return floor(u*steps + 0.5)/steps;\n}\n\nfloat threshold(float u, float edge)\n{\n    return u * step(edge, u);\n}\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{   \n    \n    float i = float(Vec2ToMorton(uvec2(fragCoord)));\n    \n    float n1 = noise(i, 1e-3, floor(iTime*0.1619));\n    n1 = posterize(n1, 4.0);\n    n1 = threshold(n1, 0.7);\n    \n    float n2 = noise(i, 1e-5, floor(iTime*3.12349));\n    n2 = posterize(n2, 20.0);\n    n2 = threshold(n2, 0.9);\n    \n    float n3 = noise(i, 1e3, floor(iTime*0.12349));\n    n3 = threshold(n3, 0.90);\n    \n    float n4 = noise(i, 0.01, floor(iTime*0.029)) * 1.0;\n    \n    i += n1 * 40.0 + n2 * 1000.0 + n3 * 100.0;\n    \n    vec2 uv = vec2(MortonToVec2(uint(i)))/R;\n    vec3 col = mix(texture(iChannel0, uv).rgb, hash31(i), step(hash11(floor(iTime), 1.0) * 0.1 + 0.88, n4));\n    \n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}