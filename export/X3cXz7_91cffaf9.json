{"ver":"0.1","info":{"id":"X3cXz7","date":"1718821145","viewed":80,"name":"Flooded Cave","username":"Mcthouacbb","description":"Ray marching a thingy","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DIST = 64.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265358979323;\n\n// partially inspired by full spectrum cyber\n\nvec2 curve(float t) {\n    t = t / 5.0;\n    return 1.5 * vec2(sin(t + cos(t) - 2.0 * sin(t + 0.5)), sin(t) * cos(t + sin(t) / 2.0) - t);\n}\n\nfloat box2d(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) - min(max(d.x, d.y), 0.0);\n}\n\nfloat repeatedBox(vec2 p) {\n    const vec2 BOX_SIZE = vec2(0.5, 0.5);\n    p -= 2.0 * BOX_SIZE * floor((p + BOX_SIZE) / (2.0 * BOX_SIZE));\n    return box2d(p, BOX_SIZE);\n}\n\nfloat infCylinder(vec3 p, vec3 c) {\n    return length(p.xy - c.xy) - c.z;\n}\n\nfloat infBox(vec3 p, vec3 c) {\n    return box2d(p.xy - c.xy, vec2(c.z));\n}\n\n// from hash without sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// taken from some inigo quilez shadertoy example\nfloat noise3(vec3 p)\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n    vec3 u = f*f*(3.0-2.0*f);\n\n    float u0 = mix( mix( hash13( i + vec3(0,0,0) ), \n                         hash13( i + vec3(1,0,0) ), u.x),\n                    mix( hash13( i + vec3(0,1,0) ), \n                         hash13( i + vec3(1,1,0) ), u.x), u.y);\n                         \n    float u1 = mix( mix( hash13( i + vec3(0,0,1) ), \n                         hash13( i + vec3(1,0,1) ), u.x),\n                    mix( hash13( i + vec3(0,1,1) ), \n                         hash13( i + vec3(1,1,1) ), u.x), u.y);\n    return mix(u0, u1, u.z);\n}\n\nfloat tunnelWidth(float z) {\n    return 2.0 + sin(z) / 3.0;\n}\n\nfloat sdf(vec3 p) {\n    float capsule = -infCylinder(p, vec3(curve(p.z), tunnelWidth(p.z)));\n    capsule -= noise3(p) / 1.4;\n    capsule -= noise3(2.0 * p) / 4.2;\n    return 0.4 * capsule;\n}\n\nfloat waterSdf(vec3 p) {\n    float water = p.y - curve(p.z).y + 0.6 + noise3(vec3(5.0 * p.xz + 3.0 * vec2(sin(iTime), cos(iTime)), iTime / 3.0)) / 8.0 + (sin(p.z - 2.0 * iTime) + sin(2.0 * p.x)) / 8.0;\n    return 0.7 * water;\n}\n\n\nvec3 raymarch(vec3 ro, vec3 rd, inout float outDist) {\n    float d = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < 128; i++) {\n        float dist = sdf(p);\n        if (dist < EPSILON)\n            break;\n        d += dist;\n        p += rd * dist;\n    }\n    outDist = d;\n    return p;\n}\n\nvec3 raymarchWater(vec3 ro, vec3 rd, inout float outDist) {\n    float d = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < 48; i++) {\n        float dist = waterSdf(p);\n        if (dist < EPSILON)\n            break;\n        d += dist;\n        p += rd * dist;\n    }\n    outDist = d;\n    return p;\n}\n\n// from https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*h ) + \n                      k.yyx*sdf( p + k.yyx*h ) + \n                      k.yxy*sdf( p + k.yxy*h ) + \n                      k.xxx*sdf( p + k.xxx*h ) );\n}\nvec3 calcNormalWater(vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*waterSdf( p + k.xyy*h ) + \n                      k.yyx*waterSdf( p + k.yyx*h ) + \n                      k.yxy*waterSdf( p + k.yxy*h ) + \n                      k.xxx*waterSdf( p + k.xxx*h ) );\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(rr, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  return mat3(uu, vv, ww);\n}\n\nvec2 rot2d(vec2 x, float a) {\n    return mat2(\n        cos(a), -sin(a),\n        sin(a), cos(a)) * x;\n}\n\nvec3 ptCol(vec3 pt, vec3 ro, vec3 rd, vec3 normal) {\n    const vec3 LIGHT_DIR = normalize(vec3(1.0, 0.0, -1.0));\n    float col = 0.1 * dot(normal, -rd) + 0.3;\n    vec3 baseCol = normalize(rd + normal);\n    baseCol *= vec3(1.0, 0.8, 0.8);\n    baseCol.xz = rot2d(baseCol.xz, iTime / 3.0);\n    \n    baseCol = 0.5 * baseCol + 0.5;\n    baseCol /= (baseCol.x + baseCol.y + baseCol.z) / 3.0;\n    float factor = smoothstep(0.15, 0.0, repeatedBox(pt.xy) * 2.0);\n    col += factor * 2.0;\n    baseCol = mix(baseCol, vec3(1.0, 1.0, 1.0), clamp(0.2 + factor * 2.0, 0.0, 1.0));\n    return col * baseCol;\n}\n\nvec3 render(vec2 uv) {\n    vec3 ro = vec3(curve(iTime), iTime);\n    vec3 rd = vec3(uv, 1.0);\n    rd = calcLookAtMatrix(ro, vec3(curve(iTime + 2.0), iTime + 2.0), 0.0) * rd;\n    \n    float dist;\n    vec3 p = raymarch(ro, rd, dist);\n    \n    vec3 normal = calcNormal(p);\n    \n    float waterDist;\n    vec3 pWater = raymarchWater(ro, rd, waterDist);\n    \n    vec3 originalCol;\n    if ((waterSdf(pWater) < EPSILON || waterDist < 16.0) && waterDist < dist) {\n        vec3 waterNormal = calcNormalWater(pWater);\n        // 0.75 = 1 / 1.333 = water index of refraction / air index of refraction\n        vec3 refracted = refract(rd, waterNormal, 0.75);\n        \n        float dist3;\n        vec3 p2 = raymarch(pWater, refracted, dist3);\n        \n        float factor = exp(-dist3 / 1.5 - 0.3);\n        originalCol = ptCol(p2, ro, rd, calcNormal(p2)) * factor + vec3(0.137, 0.537, 0.854901961) * (1.0 - factor);\n    } else {\n        originalCol = ptCol(p, ro, rd, normal);\n    }\n    return originalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    uv = uv * 2.0;\n    uv = uv - iResolution.xy / iResolution.yy;\n    \n    vec3 col = render(uv / 1.4);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}