{"ver":"0.1","info":{"id":"Dd3Xz7","date":"1679541187","viewed":140,"name":"Brain in a box","username":"ianertson","description":"Use the mouse to look around :)","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raymarching","ray","raymarch","sdf","brain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Ray marcher ID's\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX1 2\n#define ID_BRAIN 3\n#define ID_WATER 4\n\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nvec3 knoise(in vec3 p, in float phase) {\n    float x1 = exp(sin(p.z+phase)-1.);\n    float y1 = exp(sin(p.x+phase)-1.);\n    float z1 = exp(sin(p.y+phase)-1.);\n    \n    float x2 = exp(cos(p.x+(x1*3.14))-1.);\n    float y2 = exp(cos(p.y+(y1*3.14))-1.);\n    float z2 = exp(cos(p.z+(z1*3.14))-1.);\n    \n    vec3 a = vec3(x1, y1, z1);\n    vec3 b = vec3(x2, y2, z2) * 2.0 - 1.0;\n    \n    return clamp(cross(a, b), -1., 1.);\n}\n\nvec3 knoise(in vec3 p, in float phase, in float freq, const in int octaves) {\n    vec3 n = vec3(0.0);\n    float div = 0.0;\n    float amp = 1.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * knoise(p*freq, phase); div += amp; amp /= 2.0; freq *= 2.0;\n        float a = (float(i)/float(octaves))*1.6;\n        p.yz *= rot(cos(a)+(n.x*0.6*n.z));\n        p.xz *= rot(sin(a)+(n.y*0.6*n.z));\n    }\n    \n    return n/div;\n}\n\nfloat brainSDF(in vec3 p, in float r) {\n    if (p.y > r+0.5) return p.y;\n    bool noBumps = p.y < (r*0.2);\n    vec4 bumps = noBumps ? vec4(0.0) : wave(p.xz*16., 1.0212459, 0.5);\n    vec3 n = noBumps ? vec3(0.): knoise(bumps.xyz, 0.032152, 0.5, 3);\n    p.y -= smoothstep(0.0, 1.0, max(0.0, dot(p, vec3(0, -1., 0))))*0.6;\n    float sp = sphereSDF(p, r);\n    p.xz = abs(p.xz)-0.1;\n    float mx = smoothstep(0.0, 0.5, p.z + smoothstep(0.0, 1.9, 2.0*max(0.0, -p.y+0.1)));\n    float d = mix(sphereSDF(p, r), sp, mx)/2.2;\n    float topBump = ((abs(n.y)-0.6) * smoothstep(0.0, 1.6, max(0.0, p.y-(r/3.))))*0.7;\n    d -= topBump;\n    return d/(1.05+(topBump*0.33));\n}\n\nfloat waterSDF(in vec3 p, in vec3 s) {\n    if (p.y > (s.y*2.)+1.) return p.y; // optimize\n    if (abs(p.x) > s.x*2.1 || abs(p.z) > s.z*2.1) return FAR; // optimize\n    float div = 0.0;\n    if (p.y > 0.25) {\n        float time = T*0.2;\n        vec3 shift = vec3(cos(time), sin(time), sin(time+0.0238124));\n        vec3 n = knoise((p*1.5)+shift, 0.329214, 0.6, 6);\n        float h = ((n.x+n.y+n.z)/3.)*smoothstep(0.0, 1.0, max(0.0, p.y));\n        p.y -= h;\n        div = h;\n    }\n    \n    float d = boxSDF(p - vec3(0, s.y, 0), s);\n    return d / (1.0 + (div*0.15));\n}\n\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    bool isShadow = data.isShadow;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    // ground\n    float ground = groundSDF(p);\n\n    // box & brain\n    vec3 boxSize = vec3(1.0);\n    float box1 = boxSDF(p - vec3(0., boxSize.y+0.05, 0), boxSize)-0.05;\n    float boxInside = boxSDF(p - vec3(0., boxSize.y+0.05, 0), boxSize*0.9)-0.01;\n    box1 = max(box1, -boxInside)-0.02;\n    vec3 brainPos = vec3(0, boxSize.y+0.05, 0);\n    vec3 brainRot = vec3(0, T*0.5, 0);\n    Object oBrain = Object(brainPos, brainRot, 1.0);\n    vec3 brainP = p - brainPos;\n    brainP = pointRot(brainP, brainRot);\n    float brain = brainSDF(brainP, 0.45);\n    Object oBox = Object(vec3(0.0), vec3(0.0), 0.5);\n    \n    vec3 waterSize = vec3(boxSize.x*0.86, boxSize.y*0.5, boxSize.z*0.86);\n    float water = waterSDF(p-vec3(0, 0.059, 0), waterSize);\n    water = max(water, -brain);\n    Object oWater = Object(vec3(0.0), vec3(0.0), 0.5);\n    \n    SAMPLE(water, oWater, ID_WATER);\n    SAMPLE(ground, o, ID_GROUND);\n    \n    SAMPLE(box1, oBox, ID_BOX1);\n    SAMPLE(brain, oBrain, ID_BRAIN);\n    \n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    float sig = data.sig;\n    int steps = data.steps;\n    for (int i = ZERO; i < steps; i++) {\n        vec3 p = ro+rd*d;\n        float next = sig*sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    Data tmp = data;\n    vec3 n = normalize(sdf(tmp, p) - vec3(\n        sdf(tmp, p - e.xyy),\n        sdf(tmp, p - e.yxy),\n        sdf(tmp, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\n// Rendering\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    mat2x3 hf1 = snoise2x3(uv, 0.000321, 0.0, 64.0, 6);\n    vec3 c1 = vec3(0.15, 0.89, 0.1);\n    vec3 c2 = vec3(0.43, 0.92, 0.1);\n    vec3 c3 = vec3(0.41, 0.5, 0.21);\n    vec3 c4 = vec3(0.6, 0.8, 0.2);\n    \n    vec3 col = mix4(c1, c2, c3, c4, vec4(hf1[0].xyz, hf1[1].x));\n    \n    m.spec = clamp(hf1[0].x*hf1[0].x, 0.0, 1.0);\n    m.spec = m.spec*m.spec;\n    return col;\n}\n\n//#define DEBUG_TEXTURE brainTexture\n\nvec3 brainTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    \n    vec3 c1 = rgb(210, 124, 111);\n    vec3 c2 = rgb(217, 96, 65);\n    vec3 c3 = rgb(196, 173, 146);\n    vec3 c4 = rgb(117, 119, 133);\n\n\n    vec3 c5 = rgb(223, 63, 73);\n    vec3 c6 = rgb(151, 91, 125);\n    vec3 c7 = rgb(160, 45, 74);\n    vec3 c8 = rgb(124, 48, 60);\n    \n    vec3 hf1 = snoiseWarp(uv, 0.000321, 0.5, 100.0, 6, 0.02);\n    vec3 hf2 = snoiseWarp(uv, 7.778834, 1.7, 64.0, 6, 0.15);\n    vec3 lf1 = snoiseWarp(uv, 16.668829, 0.5, 8.0, 6, 0.15);\n    vec3 lf1s = smoothstep(0.4, 0.7, lf1);\n    \n    vec3 lf2 = snoise(uv, 24.8427283, 0.5, 8.0, 6);\n    vec3 lf2s = smoothstep(0.4, 0.7, lf2);\n    \n    float yy = smoothstep(0.0, 1.0, max(0.0, p.y));\n    \n    vec3 baseCol = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    \n    vec3 crackCol1 = mix(mix(mix(c5, c6, hf2.x), c7, hf2.y), c8, hf2.z);\n    vec3 crackCol2 = mix(mix(mix(c5, c6, lf1s.x), c7, lf1s.y), c8, lf1s.z);\n    \n    col += baseCol;\n    \n    float cracks = (1.0-smoothstep(0.02, 0.04, abs(lf2.x*2.0-1.0)))*lf1s.y;\n    cracks *= (1.0 + (yy*0.5));\n    col = mix(col, crackCol1, cracks);\n    \n    vec4 bumps = wave(uv.xy*64., 1.0212459, 0.5);\n    vec3 bb = snoise(bumps.xy, 36.9882738, 1., 8.0, 6);\n    \n    bb*=smoothstep(0.2, 0.2, length(bumps.xy));\n    float cracks2 = max(0.0, length(bb))*lf2s.z;\n    cracks2 *= (1.0 + yy);\n    \n    col = mix(col, crackCol2, cracks2);\n\n    m.z = clamp(1.0-((cracks+cracks2)*0.5), 0.0, 1.0);\n    \n    m.spec = clamp(1.0-0.5*(cracks+cracks2),0.2, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = grassTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoBox1(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = vec3(0.3);\n    data.m.ior = 1.523;\n    return col;\n}\n\nvec3 getAlbedoBrain(inout Data data) {\n    vec3 p = pointRot(data.p-data.o.p, data.o.r);\n    vec3 n = pointRot(data.n, data.o.r);\n    vec2 uv = boxUv(p, n)/2.;\n    vec3 col = brainTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.n.z, 0.5, 0.5);\n   // data.m.rough = 1.0;\n    return col;\n}\n\nvec3 getAlbedoWater(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = vec3(0.0, 0, 1.);\n    data.m.ior = 1.33;\n    data.m.rough = 0.1352;\n    data.m.metallic = 0.09;\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX1: return getAlbedoBox1(data); break;\n        case ID_BRAIN: return getAlbedoBrain(data); break;\n        case ID_WATER: return getAlbedoWater(data); break;\n\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\n#define NUM_LIGHTS 1\n\n\n#if NUM_LIGHTS == 1\n#define ITER_LIGHTS(col) {    col += forEachLight(light, data, ro, rd, diffuse);}\n#else\n#define ITER_LIGHTS(col) {    for (int i = ZERO; i < NUM_LIGHTS; i++) {        Light light = lights[i];        col += forEachLight(light, data, ro, rd, diffuse);    }}\n#endif\n\nbool raycast(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}\n\n\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 2.0, LIGHT_AMBIENT);\n    const bool withSky = true;\n    for (int i = ZERO; i < 4 && data.steps > 1; i++) {\n        if (raycast(data, lights, withSky, col, ro, rd)) {\n            if (data.m.rough < 0.993) {\n                Data data2 = NEW_DATA;\n                data2.sig = data.sig;\n                data2.skip = data.skip;\n                data2.steps = data.steps/2;\n\n                vec3 reflectionCol = vec3(0.0);\n                vec3 dir = reflect(rd, data.n);\n                float metallic = data.m.metallic;\n                float rough = data.m.rough;\n                vec3 diffuse = col;\n\n                float NdotV = dot(data.n, dir);\n                vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n                vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n                \n                if (length(F) > 0.09 && (1.0 - NdotV > 0.09)) {\n                    raycast(data2, lights, withSky, reflectionCol, data.p+(data.n*NEAR*2.), dir);\n                \n                    col += reflectionCol * F;\n                }\n            }\n            if (data.m.ior > 0.0002) {\n                float ior = data.m.ior;\n                Data enter = NEW_DATA;\n                enter.steps = data.steps/2;\n                enter.sig = -data.sig;\n                vec3 enterDir = refract(rd, data.n, 1.0/ior);\n                raycast(enter, lights, false, col, data.p+((data.n*NEAR*8.)*enter.sig), enterDir);\n\n                Data leave = NEW_DATA;\n                leave.steps = data.steps;\n                leave.skip = data.id;\n                // I thought the one below was supposed to be just ior and not 1.0/ior,\n                // but that doesn't look right.\n                vec3 leaveDir = refract(enterDir, enter.n*enter.sig, 1.0/ior);\n                if (length(leaveDir) <= 0.00001) {\n                     leaveDir = reflect(enterDir, enter.n*enter.sig);\n                     leave.skip = -1;\n                     leave.sig = data.sig;\n                }\n                \n                data = NEW_DATA;\n                data.sig = leave.sig;\n                data.steps = leave.steps;\n                data.skip = leave.skip;\n                ro = enter.p;\n                rd = leaveDir;\n               /* if (raycast(leave, lights, withSky, refractCol, enter.p, leaveDir)\n                    && leave.id != data.id && leave.id == ID_WATER && leave.m.ior > 0.0002 && i <= 0) {\n                    int skip = data.id;\n                    data = NEW_DATA;\n                    data.skip = skip;\n                } else {\n                    col += refractCol;\n                    break;\n                }*/\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n        \n        data.steps -= 5;\n    }\n    \n    depth = data.d / FAR;\n    \n    return col;\n}\n\n// Camera\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -4.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        float Y = 0.9;\n        ro.y += Y;\n        ro.y = max(ro.y, Y);\n    } else {\n        float time = T*0.67;\n        ro.xz = vec2(cos(time), sin(time))*3.9;\n        ro.y += 2.7;\n        rd = look(uv, vec3(0, 0.5, 0),ro);\n    }\n    \n    \n    \n    return Ray(ro, rd);\n}\n\nvec4 blit(in vec2 fc) {\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    O = blit(fc);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 40.0\n#define STEPS 70\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n#ifndef HW_PERFORMANCE\nuniform sampler2D iChannel3;\nuniform float iTime;\nuniform vec4 iMouse;\nuniform vec2 iResolution;\n#endif\n\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Object { vec3 p; vec3 r; float alpha; };\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0), 1.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    int steps;\n    float sig;\n    bool isShadow;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 0, 0, STEPS, 1.0, false, NEW_MATERIAL, NEW_OBJECT)\n\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Utilities\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec4 m) {  \n    return ((c1 * m.x) + (c2 * m.y) + (c3 * m.z) + (c4 * m.w))/4.;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\n// Noise functions\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21Fast(in vec2 p, in float seed) {\n    vec2 p2 = fract((p-(0.1+seed*3.339291))*10.2283821915);\n    float d1 = fract(dot(p-fract(seed*16.49289125), p2*2.0-1.0));\n    return fract(cos(d1*6.28) * dot(p-p2, vec2(42.9238125, 49.7728382)));\n}\n\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\nvec3 koch(in vec2 uv, in float iterations) {\n    vec2 uu = uv;\n    vec2 dir = vec2(sin(2.0943951023931953), cos(2.0943951023931953));\n    uv.x += 0.5;\n    float div = 1.0;\n    float dd1 = 0.0;\n    float dd2 = 0.0;\n    for (float i = 0.0; i < iterations; i+=1.0) {\n        uv *= 3.; div *= 3.;\n        uv.x = abs(uv.x-1.5)-0.5;\n        uv -= dir*min(0., dot(uv, dir))*2.;     \n        float dp = dot(uv, dir);\n        float dist = distance(uv, uu+0.5);\n        dd1 += exp(atan(dp-0.5, dist)-0.5);\n        dd2 += abs(dp-0.5)/dist;\n    }\n    return clamp(\n        vec3(\n            vec2(dd1, dd2)/iterations,\n            smoothstep(3.0/R.y, 0.0, length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0))/div)\n        ),\n        0.0,\n        1.0\n    );\n}\n\nvec3 kochStar(in vec2 uv, in float iterations) {\n    uv.x = abs(uv.x);\n    uv.y += -0.28867513459481287;\n    vec2 dir = vec2(sin(2.6179938779914944), cos(2.6179938779914944));    \n    return koch(uv-dir*max(0.0, dot(uv-vec2(0.5, 0.), dir))*2.0, iterations);\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\n\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nmat2x3 NOISE2x3(in vec2 p, in float seed, in float lod) {\n    vec3 a = textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb;\n    vec3 b = textureLod(iChannel3, (p.yx + (fract((seed+8.79894883)*10.2381285123)*1.9287827185))/256.0, lod).rgb;\n\n    return mat2x3(\n        vec3(a.x, b.y, a.z), vec3(b.x, a.y, b.z)\n    );\n}\n\nmat2x3 mix2x3(mat2x3 a, mat2x3 b, float m) {\n    return mat2x3(\n        mix(a[0], b[0], m),\n        mix(a[1], b[1], m)\n    );\n}\n\nmat2x3 snoise2x3(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix2x3(\n        mix2x3(NOISE2x3(id, seed, lod), NOISE2x3(id + vec2(1, 0), seed, lod), lv.x),\n        mix2x3(NOISE2x3(id + vec2(0, 1), seed, lod), NOISE2x3(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nmat2x3 snoise2x3(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    mat2x3 n = mat2x3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise2x3(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nmat2x3 snoiseWarp2x3(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    mat2x3 n = mat2x3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise2x3(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n[0].xy*n[0].z)+(n[1].xy*n[1].z)*warp;\n    }\n    return n / div;\n}\n\nfloat voronoi(in vec2 p, in float seed, out vec2 id){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                id = offset;\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\nfloat noise(in vec2 uv, in float seed) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(hash21Fast(id, seed), hash21Fast(id+vec2(1, 0), seed), lv.x),\n        mix(hash21Fast(id+vec2(0, 1), seed), hash21Fast(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\n\nvec4 wave(in vec2 uv, in float seed, in float eps){\n  float a1 = noise(vec2(uv.x, uv.y + eps), seed);\n  float a2 = noise(vec2(uv.x, uv.y - eps), seed);\n  float b1 = noise(vec2(uv.x + eps, uv.y), seed);\n  float b2 = noise(vec2(uv.x - eps, uv.y), seed);\n  float a = (a1 - a2) / (2.0 * eps);\n  float b = (b1 - b2) / (2.0 * eps);\n  float c = (a1 - b1) / (2.0 * eps);\n  float d = (a2 - b2) / (2.0 * eps);\n  return clamp(vec4(a, b, c, d), 0.0, 1.0);\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\n#else\nfloat sdf(inout Data data, in vec3 p);\n#endif\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip, in float sig) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    data.isShadow = true;\n    \n    float d = 0.0;\n    float r = 1.0;\n    float alpha = 0.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        alpha += max(0.0, 1.0-(1.0/(1.0+max(0.0, -next))));\n        alpha *= (2.0+alpha)*(2.0+alpha);\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) break;\n    }\n    r += clamp(alpha, 0.0, 1.0);\n    return clamp(r + 0.77*(d / (1.0 + d)), AMBIENT, 1.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id, data.sig);\n        \n    return (diffuse + spec) * att * shadow; \n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n","name":"Common","description":"","type":"common"}]}