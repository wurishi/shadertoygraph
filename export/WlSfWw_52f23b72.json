{"ver":"0.1","info":{"id":"WlSfWw","date":"1599017076","viewed":40,"name":"Truchet Classic","username":"jasonzil","description":"Trying out some truchet tiles","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["random","truchet","pipes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A basic Truchet tiler for Computational Form\n// \n//\tNUM defines scale\n//  UST_TIME lets you create random tiles and pause on one, use 1 or 0 as value\n//\n\n\n#define NUM 5.\t\t\t//scale size\n#define COL_OFF .64\t\t//hue offset\n#define USE_TIME 1\t\t//create new tiles or not\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat sdCircle( vec2 p , vec2 offSet, float r){\n\treturn length ( p - offSet) - r;\n}\n\n//give it a uv position\nfloat truchetTile(vec2 p, vec2 cell)\n{\n    float r = 1./100000.; ///why is this... the value I have to use?\n    \n    float pipe = 0.;\n    float pipe2 = 0.;\n    #if USE_TIME\n        if (gold_noise(cell+ floor(iTime*.7), .3) > .5){\n    #else\n    \tif (gold_noise(cell+ 1.,3.) > .5){\n    #endif\n        pipe =  min(sdCircle( p, vec2(0,0), 0.),  1.-sdCircle( p, vec2(0,0), 0.));\n\t\tpipe2 = min(sdCircle( p, vec2(1,1), 0.),1.-sdCircle( p, vec2(1,1), 0.));\n    }else{\n        pipe =  min(sdCircle( p, vec2(1,0), 0.),  1.-sdCircle( p, vec2(1,0), 0.));\n        pipe2 = min(sdCircle( p, vec2(0,1), 0.),1.-sdCircle( p, vec2(0,1), 0.));\n    }\n    \n    float sizeMod = .4 + .045*sin(.3*iTime);\n    float thickness = .05;\n    float blur = 10.0;\n\tfloat value = max(smoothstep(sizeMod,sizeMod+thickness, pow(pipe,1.)),smoothstep( sizeMod ,sizeMod+thickness, pipe2));\n    return pow(max(value,0.),blur);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvLoop = fract((uv) * NUM);\n    vec2 uvCells = floor(uv * NUM);\n    \n    vec3 color = vec3(.784, .635, .784);\n    vec3 bg = vec3(.294,0.,.51);\n    \n    float colOffset = COL_OFF;\n    float bgOffset = COL_OFF;\n    vec3 hsvC = rgb2hsv(color);\n    vec3 hsvBG = rgb2hsv(bg);\n    hsvC = fract( hsvC + colOffset);\n    hsvBG = fract( hsvBG + bgOffset);\n    color = hsv2rgb(hsvC);\n    bg = hsv2rgb(hsvBG);\n    float inPipe = truchetTile(uvLoop, uvCells);\n    color = color * inPipe + (1.-inPipe) * bg;\n    \n    fragColor.xyz = color;\n}","name":"Image","description":"","type":"image"}]}