{"ver":"0.1","info":{"id":"stKGzy","date":"1637971287","viewed":285,"name":"Voronoz","username":"kastorp","description":"something\nmouse down=donuts, up=cylinders, left=few, right=many","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","extrusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Voronoz by Kastorp\n//----------------------------\n\nvec3 erot(vec3 p, vec3 ax, float ro) { //@Blackle\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat xt( in vec3 p, in float sdf, in float h ){//@iq\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 hash22(vec2 p) //@Dave_Hoskins \n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voro(vec2 p){\n    float  d=1e5;\n    vec2 s=step(vec2(.5),fract(p));    \n    for(float i=-1.+s.x;i<2.+s.x;i++)for(float j=-1.+s.y;j<2.+s.y;j++) d=min(d,length(fract(p)-vec2(i,j)-.5+ \n        hash22(floor(p)+vec2(i,j) )\n        //mix( hash22(floor(p)+vec2(i,j) ), hash22(.5 +floor(p)+vec2(i,j) ),.5+.5*sin(iTime*.5))\n        ));\n    return d;\n}\n\nfloat kk;\nfloat scene(vec3 p){\n     if(p.z>.65) return (p.z-.6); //+10% framerate\n    float z =.3, h=iMouse.z>0.? .2-iMouse.x/iResolution.x*.1:.1,  d=1e5, s=voro(p.xy/z), tk=iMouse.z>0.?-1.+iMouse.y/iResolution.y*2.:0.;    \n    for( float k = -.5+fract(iTime)*h;k<.5;k+=h) { \n       float d1=  -h*.1*(1.1-tk)+xt(p+vec3(0,0,k*.2), -.0001+abs(s-k-.5)*z ,.5);\n       if(d1<d){kk=k;d=d1;}\n    }\n    return d;\n}\n\nvec3 norm(vec3 p) {//@blackle\n    mat3 k = mat3(p,p,p)-mat3(0.001);    \n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = scene(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(1.,0,3.)+vec3(0,.2,0)*iTime;\n    \n    float yrot =.8;\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 80 && !hit; i++) {\n        float dist =scene(p); \n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (dist>5. ||hit) break;\n    }\n    float k=kk;\n    vec3 n = norm(p);\n    vec3 ld= normalize(vec3(0,1,.5));\n    \n    vec3 base = (.5+sin(vec3(3,2,1)*k*4.)*.5);\n    float diff = pow(dot(n, ld) * .5 + .5,2.0);\n    float ao = getAmbiantOcclusion(p, n, 40.0);\n    float spec= pow(max(dot(-cam, reflect(-ld, n)), 0.0), 32.0);     \n    \n    bool sh =false;\n    if(hit){\n       \n        p+=n*.002;\n        for (int i = 0; i < 50 && !sh; i++) {\n            float dist = scene(p);\n            sh = dist*dist < 1e-6;\n            p+=dist*ld;\n            if (dist>2. ||sh) break;\n        }\n    }\n    vec3 col = (base *diff) * (sh?.4:1.) +(sh?0.:spec) ;\n    col = clamp(col, 0., 1.);\n \n    \n    fragColor = smoothstep(-.02,1.05,sqrt(vec4(col,1))) * (1.- dot(uv,uv)*.5);\n}","name":"Image","description":"","type":"image"}]}