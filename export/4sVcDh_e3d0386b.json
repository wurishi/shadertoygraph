{"ver":"0.1","info":{"id":"4sVcDh","date":"1521877495","viewed":1034,"name":"Ray tracer.","username":"Pr0fed","description":"At last. First one working. Thx to Peter Shirley's \"Raytracing in one weekend\" and Shadertoy, a lot of to learn from examples.","likes":18,"published":1,"flags":32,"usePreview":1,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = pow(texture(iChannel0, uv), vec4(0.4545));\n    \n\tfragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Hopefully this one would grow to something bigger.\n// Going to add lights and other stuff from Peter Shirley's books.\n// I'm still learning.\n\n// Set it bigger to less noise and accurate render. (but comment MOVEMENT).\n#define MAX_WEIGHT 1\n\n#define MAX_DISTANCE 50.0\n\n#define SAMPLES 25\n#define MAX_BOUNCES 15\n#define NUM_SPHERES 7\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n// Materials\n#define LAMB 0\n#define METAL 1\n#define DIEL 2\n#define EMISSIVE 3\n\n// Comment to stop.\n#define MOVEMENT\n\nconst float GAMMA = 2.2;\n\n///-- Scene Objects -------------------------------------------------------\n\nstruct Material\n{\n\tint type;\n    vec3 albedo;\n    \n    // value corresponds to a material. \n    //\n    // Roughness for metal.\n    // Refract index for dielectrics.\n    // Color multiplier for current fake emission mat.\n    float v; \n};\n    \nstruct Sphere\n{\n\tvec3 c;\n    float r;\n    Material mat;\n};\n\n// Just for the sake of simplicity.\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Spheres on scene declaration.\nSphere scene[NUM_SPHERES];\n\n///-------------------------------------------------------------------------\n\n///-- Helper Functions -----------------------------------------------------\n    \nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\nfloat random() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\n// The point where we intersected something.\nvec3 getHitPoint(Ray ray, float t) \n{\n \treturn ray.origin + t * ray.direction;   \n}\n\n// Shlick's formula for transparent materials like glass.\nfloat schlick(float cosine, float IOR) \n{\n \tfloat r0 = (1.0 - IOR) / (1.0 + IOR);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\n///--------------------------------------------------------------------------\n\n///-- MAIN FUNCTIONS --------------------------------------------------------\n\n// Ray tracing function.\nbool hitScene(Ray ray, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out Material material, out Sphere sphere)\n{\n    // By default we assume that we are at max distance\n    // and didn't hit anything.\n    float closestSoFar = tMax;\n    bool isHit = false;\n    \n    // Intersection with spheres.\n    // Looping through all, caching the closest 't' point.\n    // which is a distance from ray origin and later used to get hit point.\n    for (int i = 0; i < NUM_SPHERES; i++) \n    {\n        Sphere sphere = scene[i];\n        \n        // Sphere intersection formula.\n        vec3 oc = ray.origin - sphere.c;\n        float a = dot(ray.direction, ray.direction);\n        float b = dot(oc, ray.direction);\n        float c = dot(oc, oc) - sphere.r * sphere.r;\n        float discriminant = b * b - a * c;\n        \n        if (discriminant > 0.0001) \n        {\n            // We only need the closer side of a sphere.\n\t\t\tfloat t = (-b - sqrt(discriminant)) / a;\n            \n            if (t < tMin) \n            {\n                t = (-b + sqrt(discriminant)) / a;\n            }\n            \n            // If we hit sphere, which is closest so far,\n            // we set it to closest, and re-set output\n            // materials and other stuff.\n            if (t > tMin && t < closestSoFar) \n            {\n                closestSoFar = t;\n                isHit = true;\n                \n                vec3 p = getHitPoint(ray, t);\n                position = p;\n                normal = (p - sphere.c) / sphere.r;\n                material = sphere.mat;\n            }\n        }\n    }\n    \n    return isHit;\n}\n\n// Main tracing function.\nvec3 trace(Ray ray) \n{\n    vec3 normal, position;\n    Material material;\n    Sphere sphere;\n    \n    vec3 color = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n       \n    // So for each bounce, we try to hit anything\n    // on the scene (spheres only yet), and then we \n    // apply the material of that object to properly\n    // color it. After all (when the bounce hit nothing)\n    // we multiply the rest of attenuation by \"sky\" color.\n    for (int b = 0; b < MAX_BOUNCES; b++) \n    {\n        if (hitScene(ray, 0.001, MAX_DISTANCE, position, normal, material, sphere)) \n        {\n            // Lambertian material.\n            if (material.type == LAMB) \n            {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(position, direction);\n                color *= material.albedo * attenuation;\n                attenuation *= material.albedo;\n            }\n            \n            // Metallic material.\n            else if (material.type == METAL)\n            {\n                vec3 reflected = reflect(ray.direction, normal);\n                vec3 direction = randomUnitVector() * material.v + reflected;\n                \n                if (dot(direction, normal) > 0.0) \n                {\n               \t\tray = Ray(position, direction);\n                \tcolor *= material.albedo * attenuation;\n               \t \tattenuation *= material.albedo;\n                }\n            }\n            \n            // Dielectric material.\n            else if (material.type == DIEL)\n            {\n                 vec3 outward_normal;\n                 vec3 reflected = reflect(ray.direction, normal);\n                 float ni_over_nt;\n\n                 vec3 refracted;\n                 \n                 attenuation = vec3(1.0, 1.0, 1.0); \n                \n                 float reflect_prob;\n                 float cosine;\n\n                 if (dot(ray.direction, normal) > 0.) \n                 {\n                      outward_normal = -normal;\n                      ni_over_nt = material.v;\n                      cosine = dot(ray.direction, normal) / length(ray.direction);\n                      cosine = sqrt(1. - material.v * material.v * (1. - cosine * cosine));\n                 }\n                \n                 else \n                 {\n                      outward_normal = normal;\n                      ni_over_nt = 1.0 / material.v;\n                      cosine = -dot(ray.direction, normal) / length(ray.direction);\n                 }\n\n                 refracted = refract(normalize(ray.direction), normalize(outward_normal), ni_over_nt);\n                 if (length(refracted) > 0.0) \n                 {\n                     reflect_prob = schlick(cosine, material.v);\n                 }\n\n\n                 else reflect_prob = 1.0;\n\n                 if (random() < reflect_prob)\n                    ray = Ray(position, reflected);\n\n                 else ray = Ray(position, refracted);\n\n                 color *= material.albedo * attenuation;\n                 attenuation *= material.albedo;\n            }\n            \n            // Emissive material. (WIP)\n            // Obviously emissiveness doesn't work like this.\n            // And i'm not yet sure how it should be properly\n            // implemented, but i like the simplicity of a fake.\n            else if (material.type == EMISSIVE)\n            {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(position, direction);                \n                color *= material.albedo * attenuation;\n                attenuation *= material.albedo * material.v;\n            }\n        }\n        \n        // At the end we mix with \"sky\" color which is an iChannel1.\n        else \n        {\n            vec3 skyColor = texture(iChannel1, -ray.direction).rgb;\n            skyColor = pow(skyColor, vec3(GAMMA));\n            color = attenuation * skyColor;\n        }\n    }\n    \n    return color;\n}\n\n///-------------------------------------------------------------------------\n\n// Putting it all somewhere on the scene.\nvoid SceneFill() \n{\n    // Main spheres.\n\tscene[0] = Sphere(vec3(0.0, 1.0, 3.0), 1.0, Material(LAMB, vec3(0., 0.9, 0.9), 0.0));\n    scene[1] = Sphere(vec3(0.0, 1.0, 0.0), 1.0, Material(METAL, vec3(0.9, 0.9, 0.9), 0.5));\n    scene[2] = Sphere(vec3(0.0, 1.0, -3.0), 1.0, Material(DIEL, vec3(0.9, 0.9, 0.3), 1.517));\n    // Negative radius hack sphere inside main (DIEL) one for correct reflection.\n    scene[3] = Sphere(vec3(0.0, 1.0, -3.0), -0.9, Material(DIEL, vec3(0.9, 0.9, 0.56), 1.517));\n    \n    scene[4] = Sphere(vec3(0.0, 0.3, -1.5), 0.3, Material(EMISSIVE, vec3(0.83, 0.2, 0.2), 20.));\n    scene[5] = Sphere(vec3(0.0, 0.3, 1.5), 0.3, Material(EMISSIVE, vec3(0.2, 0.83, 0.2), 20.));\n    \n    // A thin metal disk under main spheres, play with roughness!\n    scene[6] = Sphere(vec3(0., -1e3, 0.), 1e3, Material(METAL, vec3(0.7, 0.75, 0.8), 0.25));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization and seed.\n    SceneFill();\n    seed = iTime;\n    \n    #ifdef MOVEMENT\n    \n    // Just a bit of movement.\n    \n    scene[0].c.z *= sin(iTime);\n    scene[0].c.x = cos(iTime) * 0.6;\n    \n    scene[1].c.x = -cos(iTime) * 1.4;\n    \n    scene[2].c.z *= sin(iTime);\n    scene[2].c.x = cos(iTime) * 2.6;\n    \n    scene[3].c.z *= sin(iTime);\n    scene[3].c.x = cos(iTime) * 2.6;\n    \n    scene[4].c.z *= sin(iTime);\n    scene[4].c.x = cos(iTime) * 4.6;\n    \n    scene[5].c.z *= sin(iTime);\n    scene[5].c.x = -cos(iTime) * 4.6;\n\n    #endif\n    \n    // Basic normalization.\n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n    vec2 mousePos = iMouse.xy / iResolution.xy;  \n    \n    if (all(equal(mousePos, vec2(0.0)))) \n    {\n        mousePos = vec2(0.63, 0.27); // Default position.\n    }\n    \n    float x = cos(mousePos.x * 10.0) * dist;\n    float z = sin(mousePos.x * 10.0) * dist;\n    float y = mousePos.y * 10.0;\n        \n    vec3 origin = vec3(x, y, z);\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    // We add random amount for a better AA. More samples - smoother.\n    for (int s = 0; s < SAMPLES; s++) \n    {        \n     \tvec3 direction = lowerLeft - origin;\n        direction += horizontal * (pixelSize.x * random() + UV.x);\n        direction += vertical * (pixelSize.y * random() + UV.y);\n        color += trace(Ray(origin, direction));\n    }\n    \n    color /= float(SAMPLES);\n    \n    vec3 previousColor = texture(iChannel0, UV).rgb;\n    \n    float weight = min(float(iFrame + 1), float(MAX_WEIGHT));\n    \n    // Resetting weight on mouse change.\n    if (!all(lessThanEqual(iMouse.zw, vec2(0.0)))) \n    {\n        weight = 1.0;\n    }\n    \n    vec3 newColor = mix(previousColor, color, 1.0 / weight);\n    \n    fragColor = vec4(newColor, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}