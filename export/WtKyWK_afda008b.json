{"ver":"0.1","info":{"id":"WtKyWK","date":"1611778678","viewed":92,"name":"Cellular automation – Rule 30","username":"endymion","description":"First attempt at running Rule 30 as part of Genuary 2021-02. \nHuge props to *microwerx* for a bunch of inspiration for this code (https://www.shadertoy.com/view/4dVczK).","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cellular","rule30","automation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * @main\n * Renders output from Buffer A\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * @overview\n * @src https://www.shadertoy.com/view/4dVczK\n * First attempt at running Rule 30 as part of Genuary 2021-02. \n * Huge props to *microwerx* for a bunch of inspiration for this code. \n */\n\n/**\n * @const\n * Colors\n */\nconst vec3 colorBlack = vec3(0.0);\nconst vec3 colorWhite = vec3(1.0);\n\n/**\n * @const\n * Texel states\n */\nconst int painted = 1;\nconst int blank = 0;\n\n/**\n * @const\n * @src https://mathworld.wolfram.com/Rule30.html\n * Rule 30 – basically the first three values are the arguments, the 4th value the outcome\n */\nconst ivec4 rule30set[8] = ivec4[8](\n  ivec4(painted, painted, painted, blank),\n  ivec4(painted, painted, blank, blank),\n  ivec4(painted, blank, painted, blank),\n  ivec4(painted, blank, blank, painted),\n  ivec4(blank, painted, painted, painted),\n  ivec4(blank, painted, blank, painted),\n  ivec4(blank, blank, painted, painted),\n  ivec4(blank, blank, blank, blank)\n);\n\n/**\n * @function\n * Loops through the rules array and outputs the color\n * based on the given parent's states\n */\nvec3 rule30(int a, int b, int c) {\n  for (int i = 0; i < 8; i++) {\n    if (rule30set[i].xyz == ivec3(a, b, c)) \n      return rule30set[i].w == painted ? colorBlack : colorWhite;\n  }\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n  \n  // Set fallback colors of parent pixels to white\n  vec3 va = colorWhite;\n  vec3 vb = colorWhite;\n  vec3 vc = colorWhite;\n  \n  // Get texture from buffer (self)\n  vec3 original = texture(iChannel0, uv).rgb;\n  ivec2 iuv = ivec2(fragCoord);\n  ivec2 iwh = ivec2(iChannelResolution[0].xy);\n\n  // Load parent texel color values\n  if (iuv.x > 0 && iuv.x < iwh.x - 1) {\n    va = texelFetch(iChannel0, iuv + ivec2(-1, 1), 0).rgb;\n    vb = texelFetch(iChannel0, iuv + ivec2( 0, 1), 0).rgb;\n    vc = texelFetch(iChannel0, iuv + ivec2( 1, 1), 0).rgb;\n  }\n  \n  // Determine texel state based on the red channel \n  // we could use any channel here, since we're\n  // painting with black. \n  int a = (va.r < 0.5) ? painted : blank;\n  int b = (vb.r < 0.5) ? painted : blank;\n  int c = (vc.r < 0.5) ? painted : blank;\n  \n  // Look up current fragment's color\n  vec3 color = rule30(a, b ,c);\n\n  // Retain rows from previous render\n  if (iuv.y == iwh.y - 1) {\n    fragColor = vec4(original, 1.0);\n  } else {\n    fragColor = vec4(color, 1.0);\n  }\n\n  // Seed with black at the beginning, then use white for the rest\n  if (iTime < 0.1) {\n    if ((iuv.y == iwh.y - 1) && iuv.x == (iwh.x >> 1)) {\n      fragColor = vec4(colorBlack, 1.0);\n    } else {\n      fragColor = vec4(colorWhite, 1.0);\n    }\n  }\n}","name":"Buffer A","description":"","type":"buffer"}]}