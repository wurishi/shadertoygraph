{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec3 camUp = vec3(0.0, 1.0, 0.0);\nvec3 camDir= vec3(0.0, 0.0, 1.0);\nvec3 camPos= vec3(0.0, -0.96, -1.76);\n\nvec3 lightPos= vec3(-2.36, 5.75, -7.3);\n\n\n#define TAO 6.283\nconst int MAX_ITER = 100;\nfloat PI=3.14159265;\n//--------------------------------------------------\n#define time iTime\n\nvec3 getNormal(in vec3 p);\n\n//ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ\n//-------------------------------------------------Ð›Ð°Ð¼Ð±ÐµÑ€Ñ‚\nvec3 getlightingLambert(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n  //  const vec3 diffColor = vec3 ( 0.5, 0.0, 0.0 );\n\n    vec3 n2   = normalize ( normal);\n    vec3 l2   = normalize ( lightDir-pos );\n    vec3 diff = color * max ( dot ( n2, l2 ), 0.0 );   \n    return diff;\n}\n//-------------------------------------------------Ð¿Ð¾ Ð¤Ð¾Ð½Ð³Ñƒ\nvec3 getlightingPhong(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   vec3 specColor = vec3(1.0, 0.97, 0.94);\n   float  specPower = 36.0;\n       \n    vec3   l = normalize (lightDir-pos);   \n    vec3   v = normalize(pos-pos);\n\n    vec3   n = normalize (normal);        \n    vec3   r = reflect ( -l, n ); \n    vec3 diff = color * max ( dot ( n, l ), 0.0 );\n    vec3 spec = specColor * pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    \n    return diff + spec;\n}\n//------------------------------------------\nvec2 rot(vec2 p,float r){\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n//------------------------------------------\nvec2 rotsim(vec2 p,float s){\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n//------------------------------------------\nvec3 sim(vec3 p,float s){\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n//------------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//--------------------------------------------------\nfloat trunkCone( vec3 p, float c )\n{\n float q = length(p.xz);\n return q + p.y * c;\n\n}\n//----------------------------------------------------\nvec3 background(vec3 rd)\n{\n\n   float sky = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n   float ground = max(0.0, -dot(rd,  vec3(0.0, 6.7, 2.0)));\n   vec3 bFon =  pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +   pow(sky, 1.) * vec3(0.4, 0.3, 0.2);\n   return bFon ;\n\n}\n//-------------------------------------------------- \nvec3 getmaterial( in vec3 p,  in float mat)\n{\n \n vec3 pos = p; \n vec3 color = vec3(1.);\n  \n\n vec3 colorObject = vec3(0.5, 0.4, 0.3);\n vec3 colorObject1;\n   \n   if (mat == 0.)\n      return vec3(0.4662, 0.4565, 0.4488);\n   else if (mat == 1.)\n      return vec3(1.0, 1.0, 1.0);   \n   else if (mat == 2.)\n   {\n\n     float r = pow(colorObject.r, cos(iTime * 0.5)); \n     float g = pow(colorObject.g, cos(iTime * 0.3));\n     float b = pow(colorObject.b, cos(iTime * 0.7));  \n     colorObject1 = vec3(r, g, b);\n     return colorObject1;         \n   }\n    else if (mat == 3.) // ÑÑ‚Ð²Ð¾Ð»\n      return vec3(0.7218, 0.4581, 0.0983);  \n   else if (mat == 4.) // Ð¸Ð³Ð»Ñ‹\n      return vec3(0.5, 0.6, 0.2);     \n   \n   else   \n      return vec3(0.3, 0.9,0.5);\n}\n\n//------------------------------------------------\n//ÐžÐ±ÑŠÐµÐºÑ‚Ñ‹\n//----------------------------------------------------\nvec2 rotate1(vec2 v, float angle) \n{return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nvec2 kaleido(vec2 v, float power)\n{return rotate1(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\nvec2 kaleido6(vec2 v)\n{return rotate1(v,floor(0.5+atan(v.x,-v.y)*0.95493)*1.0472);}\n\nvec2 kaleido12(vec2 v)\n{return rotate1(v,floor(0.5+atan(v.x,-v.y)*1.90986)*0.5236);}\n\n\nmat2 r45=mat2(0.7071,0.7071,-0.7071,0.7071);\nmat2 r30=mat2(0.866,0.5,-0.5,0.866);\nmat2 rtrn=mat2(0.9689,-0.2474,0.2474,0.9689);\n//----------------------------------------------------Ð’ÐµÑ‚ÐºÐ¸ Ñ‘Ð»ÐºÐ¸\nfloat branch(in vec3 pos, inout float trunk )\n{\n float d = 1.0;\n\n   for(int i=0;i<2;i++)\n   {\n      vec3 z=pos;\n\n      float c=floor(z.y*4.); \n      z.yz=rotate1(z.yz,-z.z*0.79*(1.0+c*0.1)); \n      float bm = -z.y - 2.0;\n      z.y=mod(z.y,0.25)-0.05;      \n      if(i==1)                    \n        z.xz=z.xz*rtrn;\n      z.xz=kaleido(z.xz,2.0-c); \n      z.yz=rtrn*z.yz;\n      bm=max(bm,-z.z+c*0.086);\n      trunk=min(trunk,max(max(abs(z.x),abs(z.y)),bm))-0.001-z.z*0.003;\n      float c2=floor(z.z * 16.0); \n      z.z=mod(z.z,0.0625)-0.049; \n      z.xy=rotate1(z.xy,c2*0.25);  \n      z.xy=kaleido12(z.xy);\n      z.yz=z.yz*r30;   \n      d=min(d,max(max(max(abs(z.x),abs(z.z)),-z.y-0.05+c*0.005),bm));\n   }\n \n \n return d;\n}\n\n//----------------------------------------------------\nvec2 tree(in vec3 pos)\n{\n   float d=1.;\n   float material = 0.;\n   float trunk = trunkCone( pos, 0.025 );  // Ð¡Ñ‚Ð²Ð¾Ð»\n   d =  branch(pos, trunk );               // Ð’ÐµÑ‚ÐºÐ¸\n   if(trunk<d)\n   {\n      d=trunk;\n      material = 3.;\n   }\n   else\n   {\n      material = 4.;\n   }\n   float result = max(0.0,max(d,max(pos.y,-pos.y-2.0)));\n   return vec2(result, material);\n}\n//----------------------------------------------------\n//Star\nvec2 star(vec3 p)\n{\n  p.y=p.y - 0.07;\n  p= p * 10.0;\n  float l=length(p);\n  if (l  < 2.0)\n  {\n  p.xy=rotsim(p.xy,5.0);\n  p.y=p.y-2.0; \n  p.z=abs(p.z);\n  p.x=abs(p.x);\n  return vec2(dot(p,normalize(vec3(2.0,1,3.0))) / 10.0, 2.);\n  } else return vec2((l-1.9)/4.0, 2.0);\n}\n//----------------------------------------------------\n//Snow\nfloat makeshowflake(vec3 p)\n{\n  return length(p)- 0.02;\n}\n//----------------------------------------------------\nfloat makeShow(vec3 p,float tx,float ty,float tz)\n{\n  p.y=p.y+time*tx;\n  p.x=p.x+time*ty;\n  p.z=p.z+time*tz;\n  p=sim(p,8.0);\n  return makeshowflake(p);\n}\n//----------------------------------------------------\nvec2 show(vec3 p)\n{\n  float f=makeShow(p,1.11, 1.03, 1.38);\n  f=min(f,makeShow(p,1.72, 0.74, 1.06));\n  f=min(f,makeShow(p,1.93, 0.75, 1.35));\n\n  return vec2(f,1.0);\n}\n//----------------------------------------------------\nvec4 swag(vec2 pos)\n{\n \n  vec3 camSide = cross(camDir, camUp);\n  mat4 cm=mat4(\n    camUp.x,   camUp.y,   camUp.z,   -dot(camUp,camPos),\n    camSide.x,   camSide.y,   camSide.z,   -dot(camSide,camPos),\n    camDir.x, camDir.y, camDir.z, -dot(camDir,camPos),\n    0.0,   0.0,   0.0,   1.0);\n\n  vec4 pc=vec4(0,0,0,0);\n  const float maxl=64.0;\n  for(float i=0.0;i<maxl;i++)\n  {\n\n   vec4 pt=vec4(\n    sin(i*PI*2.0*7.0/maxl) * 0.75 * (1.0-i/maxl), /* Ð¨Ð¸Ñ€Ð¸Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð¾ X  */\n    i/maxl * 2.1, /*Ð’Ñ‹ÑÐ¾Ñ‚Ð° ÐºÐ¾Ð½ÑƒÑÐ° */\n    cos(i*PI*2.0*7.0/maxl) * 0.75 * (1.0-i/maxl),  /* Ð¨Ð¸Ñ€Ð¸Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð¾ Z */\n    1.0);\n    \n  pt=pt*cm;\n  vec2 vPos = pos;\n vPos.y += 1.28;\n\n  vec2 xy=(pt/(-pt.z )).yx + vPos;\n\n  float c;\n  c= 0.2/length(xy); \n\n pc+=vec4(\n          (sin(i*5.0+time*10.0)*0.5 + 0.5) * c,\n          (cos(i*3.0+time*8.0)*0.5 + 0.5) * c,\n          (sin(i*6.0+time*9.0)*0.5 + 0.5) * c ,0.0);\n  }\n  pc=pc/maxl; \n\n  pc=smoothstep(0.0,1.0,pc); \n  \n  return pc;\n \n}\n//----------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nvec2 renderFunction(in vec3 pos)\n{\n  vec2 result;\n  vec3 pos1 = pos;\n //   pos1 = rotationCoord(pos, 3.);\n  vec2 treeMy = tree(pos1);\n  vec2 starMy = star(pos1);\n  vec2 showMy = show(pos1);\n\n\n  if(treeMy.x < starMy.x)\n      result = treeMy;\n  else\n      result = starMy;  \n  if(result.x > showMy.x)\n      result = showMy; \n \n \n  return result;\n}\n//-------------------------------------------------\nvec3 getNormal(in vec3 p)\n{\n  const float e = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        renderFunction(p+vec3(e,0.0,0.0)).x - renderFunction(p+vec3(-e,0.0,0.0)).x,\n        renderFunction(p+vec3(0.0,e,0.0)).x - renderFunction(p+vec3(0.0,-e,0.0)).x,\n        renderFunction(p+vec3(0.0,0.0,e)).x - renderFunction(p+vec3(0.0,0.0,-e)).x\n      )\n    );\n}\n//-------------------------------------------------\nfloat rndStart(vec2 co)\n{return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n//-------------------------------------------------\nvec4 render(in vec3 posOnRay, in vec3 camPos, in vec3 rayDir, out vec2 object)\n{ \n  vec4 color = vec4(0.0);\n  float t = 0.0;\n  vec3 normal;\n  vec3 lightDir = lightPos;\n  vec4 colorMirror = vec4(0.);\n  \n  //--------------Ð¦Ð²ÐµÑ‚ Ñ„Ð¾Ð½Ð°\n  vec3 bcol = background(rayDir);                      \n                      \n  for(int i=0; i<MAX_ITER; ++i)\n  {\n\n    object = renderFunction(posOnRay); // ÐžÐ±ÑŠÐµÐºÑ‚ Ð¸ ÐµÐ³Ð¾ Ñ†Ð²ÐµÑ‚\n//------------------    \n\n  if(abs(object.x) < 0.004)\n  {\n    normal = normalize(getNormal(posOnRay));   \n    //----------------- \n    vec3 materialColor = getmaterial(posOnRay.xyz, object.y); \n    if(object.y == 2.0)\n       color.rgb = getlightingPhong(posOnRay, normal, lightDir, materialColor); // ÐŸÐ¾ Ð¤Ð¾Ð½Ð³Ñƒ\n    else \n       color.rgb = getlightingLambert(posOnRay, normal, lightDir, materialColor); \n\n    return color;\n  }    \n//------------------\n    t = object.x;\n   posOnRay = posOnRay + t*rayDir;  \n  }\n\n  \n  color.rgb+=bcol*(1.0-clamp(color.w,0.0,1.0));\n  return vec4(color.rgb, 1.0);\n}\n//-------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos =   ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\n  vec3 camSide = cross(camDir, camUp);\n  vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir);\n\n  float t = 0.0, s = 0.1;\n  vec2 object = vec2(1., 1.);\n//------------------------------\n  vec3 posOnRay = camPos;\n//------------------------------ \n  vec4 color = vec4(0.);\n\n  color= render(posOnRay, camPos, rayDir, object);\n//------------------------------\n   vec3 light_color = vec3(0.9, 0.5, 0.1);\n   float c = 0.075/(length(pos - vec2(0.48, 0.66)));\n   //Ð»ÑƒÐ½Ð°\n   vec4 moon = smoothstep(0.95,1.05,c) * vec4(1.0) + vec4(vec3(c) * light_color, 1.0);\n//-----------------------------\nvec4 swagMy =  swag(pos); // Ð³Ð¸Ñ€Ð»ÑÐ½Ð´Ð°\n//-----------------------------\n\n     fragColor =color + moon + swagMy; \n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llf3RN","date":"1419137809","viewed":1381,"name":"My tree","username":"Lio","description":"The starting material - https://www.shadertoy.com/view/lts3zr  https://www.shadertoy.com/view/4dlGRn\nSimply decorate the Christmas tree :)\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}