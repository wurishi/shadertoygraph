{"ver":"0.1","info":{"id":"XtSXzd","date":"1445821428","viewed":606,"name":"Sunset Test","username":"phi16","description":"simple raymarch program for first test (too much fake)\n","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"struct Collide{\n    float d;\n    int type;\n};\nfloat noise(vec3 x ){//https://www.shadertoy.com/view/4dsXWn\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nCollide distF(vec3 p){\n    float z=0.0;\n    z += noise(vec3(p.xz,iTime*2.0));\n    z += noise(vec3(p.xz,iTime+1.0/3.0));\n    z += noise(vec3(p.xz,iTime*0.5+2.0/3.0));\n    float planeD = p.y+1.0+z/8.0;\n    float d = planeD;\n    int t = 1;\n    return Collide(d,t);\n}\nfloat eps = 1e-2;\nvec3 normal(vec3 p){\n    vec2 e = vec2(1,0); // wow\n    return normalize(vec3(\n        distF(p+e.xyy).d-distF(p-e.xyy).d,\n        distF(p+e.yxy).d-distF(p-e.yxy).d,\n        distF(p+e.yyx).d-distF(p-e.yyx).d));\n}\nvec3 dome(vec3 v){\n    if(v.x<0.0)v.x*=-1.0;\n    v.y+=0.05;\n    v=normalize(v);\n    vec3 d=v;\n    float e = dot(v,vec3(1,0,0));\n    if(e>0.95)d=vec3(1,0.5,0);\n    d+=vec3(1,1,1)*pow(1.0-abs(e-0.95),13.0)*0.8;\n    d+=vec3(1,0.5,0.5)*pow(1.0-abs(v.y-0.05),70.0);\n    return d;\n}\nvec3 render(vec3 p,vec3 v,vec3 n,int t){\n    if(t<1){\n        return vec3(1,1,0);\n    }else{\n        vec3 def=vec3(0,0,5);\n        def += vec3(1,1,1)*(p.y+2.0);\n        def *= max(1.0,pow(p.x/5.0,0.1));\n        vec3 rColor = dome(reflect(v,n));\n        def *= rColor*0.5+0.5;\n        return def;\n    }\n}\nvec4 shoot(vec3 p,vec3 v){\n\tCollide dist;\n    dist.type=-1;\n    vec3 cur = p;\n    v = normalize(v);\n    float befR = -1.0, befDist = -1.0;\n    bool maxIter=true;\n    for(int i=0;i<50;i++){\n        Collide d = distF(cur);\n        if(abs(d.d) < eps){\n            dist = d;\n            maxIter=false;\n            break;\n        }\n     \tcur += d.d*v;\n    }\n    if(maxIter){\n        float u = p.y-1.0;\n        float len = u*v.x/v.y;\n        if(len>0.0){\n            len=sqrt(len*len+u*u);\n        \tdist=Collide(len,1);\n        }\n    }\n    if(dist.type<0)return vec4(dome(v),1);\n    else return vec4(render(cur,v,normal(cur),dist.type),1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv*=2.0;\n    uv-=1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 pos = vec3(0,0,0);\n    vec3 dir = vec3(1,uv.y,uv.x);\n    fragColor = shoot(pos,dir);\n}","name":"","description":"","type":"image"}]}