{"ver":"0.1","info":{"id":"WsjfzV","date":"1590429258","viewed":200,"name":"Prep for Outline 2020/23 may MS.","username":"MonsieurSoleil","description":"That was the expecxted Result !!!!!!!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["livecoding","preparation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define mod01 floor(mod(time, 4.0))\n#define mod02 floor(mod(time * 2.0, 2.0))\n#define mod03 floor(mod(time  * 8.0, 16.0))\n\n\nfloat gg = 0.0;\n\nstruct matter\n{\n  float mat;\n  int type;\n};\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, -sa, sa, ca);\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 r)\n{\n  p = abs(p) - r;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat Infbox(vec3 p, vec2 r)\n{\n  p.xz = abs(p.xy) - r;\n  return max(p.x, p.y);\n}\n\nfloat terrain(vec3 p)\n{\n    return p.y + 0.8;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 - 0.5 * ( a - b )/k, 0.0, 1.0);\n    return mix(b , a, h) - k*h*(1.0*h);\n}\n\nvec3 opRepLimit(vec3 p, float c, vec3 l)\n{\n \treturn p - c * clamp(round(p/c), -l, l);   \n}\n\nvec2 opRepID(vec2 p, float repeat)\n{\n  return (floor(abs(p) / repeat - 0.5) - 0.5) * repeat;\n}\n\nvec2 opRep(vec2 p, float repeat)\n{\n  return (fract(abs(p) / repeat - 0.5) - 0.5) * repeat; \n}\n\nfloat opRep(float p, float repeat)\n{\n  return (fract(abs(p) / repeat - 0.5) - 0.5) * repeat;\n}\n\nmatter map(vec3 p)\n{\n  matter m;\n  \n  float mat01, mat02;\n  vec3 p02 = p;\n  vec3 p03 = p;\n  vec3 p04 = p;\n  \n  p02.z = opRep(p.z, 1.0);\n  vec2 gID = opRepID(p.xz, 2.0);\n  \n  vec3 scale = vec3(0.5, 0.05 + mod01 * 0.05 + mod02 * 0.1 + mod03 * 0.1, 100000000000.0);\n  \n  p.xy *= rot(sin(p.z * 0.1 + time) * ((mod01 * 0.5) + 2.0));  \n  p02.xy *= rot(sin(p.z * 0.02 + time) * ((mod01 * 0.1) + 2.0));  \n  p02.xz *= rot(sin(p.z * 0.01 + time) * 0.5);  \n  \n  p03.xy *= rot(sin(p.z * 0.02 + time) * ((mod01 * 0.1) + 5.0));  \n  //p02.xz *= rot(sin(p.z * 0.01 + time) * 0.5);  \n  p04.xy *= rot(sin(p.z * 0.01 + time) * ((mod03 * 0.5) + .0));  \n  mat01 = box(p + vec3(1.0, 4.0, 0.0), scale * 0.5);\n  \n  //mat01 = Infbox(p, vec2(1.5));\n  mat02 = box(p02 + vec3(0.2, 6.0, 0.0), scale * 0.5);\n  mat02 = min(mat02, box(p02 + vec3(10, 6.0, 0.0), scale * 0.2));\n  mat02 = min(mat02, box(p02 + vec3(2.0, 1.0, 0.0), scale * 0.2));\n  mat02 = min(mat02, box(p02 + vec3(2.0, 1.0, 0.0), scale * 0.2));\n  mat02 = min(mat02, box(p03 + vec3(10.0, 5.0, 0.0), scale * 0.2));\n  \n  gg += 0.1/(0.9+mat01*mat01);\n  \n  m.mat = min(mat01, mat02);\n  m.mat = min(m.mat, -box(p04, vec3(7.0 + abs(sin(time * 0.1)) * 5.0, 7.0 + abs(sin(time * 0.1)) * 5.0, 100000000000.0)));\n  \n  if(m.mat < 0.001)\n  {\n    m.type = 1;\n  }\n\n  return m;\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  return vec3(map(p).mat - vec3(map(p - uv.xyy).mat, map(p - uv.yxy).mat, map(p - uv.yyx).mat));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec3 l = normalize(vec3(0.0, 10.0, -5.0));\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, -1.0, 1.0 + (time * 0.3)), t = vec3(0.0, -1.0, (time * 0.3));\n  vec3 fr = normalize( t - o );\n  vec3 ri = normalize( cross(vec3(0.0, 1.0, 0.0), fr) );\n  vec3 up = normalize( cross(fr, ri) );\n  vec3 dir = normalize( fr + uv.x * ri + uv.y * up );\n  vec3 p = o + dir * 0.5;\n  \n  vec3 col = vec3(0.0);\n  matter m;\n  float shad = 0.0;\n  float d = 0.0;\n  \n  for(int i = 0; i < 100; ++i)\n  {\n    /*\n    p.xy *= rot(sin(time * 0.0001) * 0.1);\n    p.xz *= rot(sin(time * 0.0001) * 0.05);\n    p.yz *= rot(sin(time * 0.0001) * 0.01);\n    */\n    \n    m = map(p);\n    \n    if(m.mat < 0.001)\n    {\n      if(m.type == 1)\n      {\n        m.mat = 0.5;\n        \n        vec3 n = normals(p);\n        dir = reflect(dir, n);\n      } else {\n        \n         break;\n      }\n      \n      shad = clamp(1.0 - pow((float(i)/500.0), 2.0),0.0,1.0);\n    }\n    \n    p += dir * m.mat;\n    d += m.mat;\n    \n    col += mix(vec3(1.0, 0.5, 1.0), vec3( 1.0, 0.5, 0.0), sin(time + (p.z * 0.01))) * gg * 0.004;\n  }\n  \n  vec3 n = normals(p);\n\n  float fog = clamp(1.0 - (d/100.0), 0.0, 1.0);\n  vec3 sky = mix(vec3(0.5, 0.3, 0.3), vec3(0.8, 0.4, 0.1), uv.y - 0.5); \n  \n  col += shad * vec3(1.0)  * clamp(dot(n, l), 0.0, 1.0);\n  col += sky * 1.0;\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}