{"ver":"0.1","info":{"id":"DlBGRV","date":"1673515484","viewed":96,"name":"Where is Wall-E?","username":"deamonpog","description":"EVE robot from Wall-E movie is travelling in the endless dunes, searching fro Wall-E","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["toon","walle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT License Copyright (c) 2022 Chathura Jayalath\n// WIP\n\n#define SPEED 1.0\n#define COLSKY  vec3(0.3,0.86,0.98)\n#define COLGRND vec3(0.91,0.75,0.48)\n#define COLSKIN vec3(0.8, 0.91, 0.96)\n#define COLEYES vec3(0.10, 0.37, 1.0)\n\n#define TAU 6.283185\n#define PI  3.141593\n\n#define SIN(x) (sin(mod(x,TAU)))\n#define COS(x) (cos(mod(x,TAU)))\n\nfloat N21_1(vec2 p);\nfloat N21_2(vec2 p);\nfloat SmoothNoise21(vec2 uv);\n\nfloat smoother(float v)\n{\n    return v * v * (3.0 - 2.0 * v);\n}\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat ellipticCurve(vec2 pos, vec2 offset)\n{\n    vec2 p = pos - offset - vec2(0.5, 0);\n    float curve = p.x * p.x * p.x - 2.0 * p.x + 0.8 - p.y * p.y;\n    return curve;\n}\n\nfloat ellipse(vec2 pos, vec2 offset, float a, float b, float r)\n{\n    vec2 p = pos - offset;\n    return p.x * p.x / a + p.y * p.y / b - r;\n}\n\nfloat square(vec2 pos, vec2 offset, float r)\n{\n    vec2 p = pos - offset;\n    return max(p.x*p.x , p.y*p.y) - r;\n}\n\nfloat circle(vec2 pos, vec2 offset, float r)\n{\n    vec2 p = pos - offset;\n    return p.x * p.x + p.y * p.y - r;\n}\n\nfloat dunes(vec2 p, vec2 rnd)\n{\n    return (rnd.y - rnd.x) * smoother(p.x) +  rnd.x - p.y;\n}\n\nfloat f2col(float f, float thickness)\n{\n    float v = abs(f);\n    return saturate( 1.0 - v / thickness );\n}\n\nfloat drawECOval(vec2 pos, vec2 offset, float r)\n{\n    pos *= 1./r;\n    offset *= 1./r;\n    float v = ellipticCurve(pos, offset);\n    float c = f2col(v, 0.01);\n    c = ceil(1.0 - pos.x + offset.x) * c; // removing unrequired part\n    return c;\n}\n\nfloat drawTriangle(vec2 pos, float a, float b, float c)\n{\n    float v = max(0.0, b - abs(pos.x - a) - pos.y);\n    float fil = ceil(v * (pos.y - c));// f2col(v, 0.01);\n    return fil;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------- SETUP UV COORD SYSTEM -------//\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; //  0,0 is at center\n    uv *= 4.0; // zoom\n    float loc = iTime * SPEED; // current location on x-axis\n    uv += vec2(loc, 0.1); // pan\n    \n    // Background Color\n    vec3 col = vec3(0); \n    \n    //--------- LOCAL COORD UV GRID -------//\n    // We only need a grid along x axis (local y-axis will be same as global).\n    vec2 luv = vec2(fract(uv.x), uv.y);\n    vec2 id = floor(uv);\n    \n    //----- CREATE DUNE ----//\n    // Interpolate between cells for random values to have common values on edges\n    float n1 = N21_1(id + vec2(-1,0)) * 0.5;\n    float n2 = N21_1(id) * 0.5;\n    float n3 = N21_1(id + vec2(1,0)) * 0.5;\n    vec2 dunePos = vec2(n1 + n2, n2 + n3);\n    // Create piecewice function which combines all dunes seamless due to smoothing\n    float v = dunes(luv, dunePos);\n    col += f2col(v, 0.01);\n    col += saturate(1.0 - ceil(v)) * COLSKY;\n    col += saturate(ceil(v)) * COLGRND;\n    \n    \n    //------ WALKER -----//\n    float hoverBounce = abs(SIN(iTime));\n    float upBounce = 0.1;\n    float armBounce = 0.1;\n    float eyeBlink = 1.0; // pulse func here\n    vec3 eyeColor = COLEYES; // random noise func here\n    \n    // head\n    v = ellipse(uv, vec2(loc, upBounce * hoverBounce + 0.1), 1.5, 1.0, 0.05);\n    col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = COLSKIN;\n    \n    // face\n    v = ellipse(uv, vec2(loc + 0.07, upBounce * hoverBounce + 0.1), 1.5, 1.0, 0.025);\n    //col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = vec3(0.4);\n    \n    // eyes\n    v = ellipse(uv, vec2(loc + 0.01, upBounce * hoverBounce + 0.1), 1.5, eyeBlink, 0.002);\n    //col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = eyeColor;\n    v = ellipse(uv, vec2(loc + 0.19, upBounce * hoverBounce + 0.1), 1.5, eyeBlink, 0.002);\n    //col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = eyeColor;\n    \n    // arm back\n    v = ellipse(uv, vec2(loc + 0.2 + (armBounce * hoverBounce), upBounce * hoverBounce - 0.6), 0.2, 2.0, 0.07);\n    col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = COLSKIN;\n    \n    // body\n    v = ellipse(uv, vec2(loc, 0.12 * abs(SIN(iTime + 0.2)) - 0.6), 1.0, 2.0, 0.1);\n    col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = COLSKIN;\n    \n    // arm front\n    v = ellipse(uv, vec2(loc - 0.2 - (armBounce * hoverBounce), upBounce * hoverBounce - 0.6), 0.2, 2.0, 0.07);\n    col += f2col(v, 0.005);\n    if(saturate(ceil(v)) == 0.0) col = COLSKIN;\n    \n    // shadow\n    v = ellipse(uv, vec2(loc, - 1.4), 2.0, 1.0, 0.05 + 0.025 * hoverBounce);\n    if(saturate(ceil(v)) == 0.0) col = vec3(0);\n    \n    // ------ DEBUG ------//\n    //col = vec3(0); col.rg += luv;\n    //if(luv.x > 0.98) col = vec3(1,0,1); // grid\n    //col += f2col(uv.x, 0.01) * vec3(0,1,0); // yaxis\n    //col += f2col(uv.y, 0.01) * vec3(0,1,0); // xaxis\n    \n    fragColor = vec4(col,1.0);\n}\n\nfloat N21_1(vec2 p)\n{\n    return fract(SIN(p.x * 997.0 + p.y * 9011.0) * 1051.0);\n}\n\nfloat N21_2(vec2 p)\n{\n    return fract(SIN(p.x * 9971.0 + p.y * 901.0) * 101.0);\n}\n\nvec2 mysmoothedge2(vec2 p)\n{\n    return p * p * (3.0 - 2.0 * p);\n}\n\nfloat SmoothNoise21(vec2 uv)\n{\n    vec2 luv = fract(uv * 10.0); // local coordinate system\n    luv = mysmoothedge2(luv);\n    vec2 id = floor(uv * 10.0);\n    \n    float bl = N21_2(id);\n    float br = N21_2(id + vec2(1,0));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = N21_2(id + vec2(0,1));\n    float tr = N21_2(id + vec2(1,1));\n    float t = mix(tl, tr, luv.x);\n    \n    float c = mix(b, t, luv.y);\n    \n    return c;\n}\n\n","name":"Image","description":"","type":"image"}]}