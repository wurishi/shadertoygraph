{"ver":"0.1","info":{"id":"dssBD7","date":"1689105125","viewed":563,"name":"Beyond A Colder War, Intro Scene","username":"msm01","description":"A Shadertoy fanart, an hommage to Charles Stross, to H.P. Lovecraft, to Science-Fiction... and maybe something more.\n\nThanks for watching and if you don't get it, see the comments in the code for details and read \"A Colder War\" !\n\nIa ! Yog-Sothoth !","likes":49,"published":1,"flags":96,"usePreview":1,"tags":["2d","rings","space","planet","fanart","story","txt","lovecraft","stross"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ms33Dr","filepath":"https://soundcloud.com/skaven252/inconsequentialize","previewfilepath":"https://soundcloud.com/skaven252/inconsequentialize","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A Colder War, by Charles Stross, is a short story set in a world where\n// the Miskatonic Antarctica Expedition really happened in the 1930ies as\n// described in \"At The Mountains Of Madness\" by H.P. Lovecraft.\n// But the action takes place much later, during the 1980ies, at the peak\n// of Cold War, and explores what would have happened if archeological\n// artifacts (i.e. \"ancient technology\") had replaced nukes in the global\n// strategic game...\n\n// If you're a Cthulhu Mythos fan, try it ! It's entertaining, funny (in\n// a sick, twisted, post-Lovecraftian sort-of way) plus it's filled with\n// references. You can actually read it online for free :\n// www.infinityplus.co.uk/stories/colderwar.htm\n\n// This shader is a fanart for this story. At the beginning, it was just\n// another attempt at 2D space art but, as I added more details, it\n// started to make sense : it could be a scene taken from \"A Colder War\",\n// or more accurately, from its sequel. Set in 1996, it would be a story\n// paying tribute to this great period with all the related iconography :\n// green military footage (the Gulf War), emerging computer graphics, led\n// displays, and old technology pushed to new heights... like a freaking\n// Super-Concorde with nuclear propulsion, orbital capability, optical\n// cloaking, and a few other tricks up his wings !\n// Which, by the way, would provide outstanding action scenes in case of\n// Mi-Go infestation ! So I added Lovecraft's favorite crustaceous fungi\n// into the shader. They swarm around the shrines of Draxakar like radio-\n// active fireflies, and there must be a good reason for this... as Roger\n// will soon learn.\n\n// Anyway. Sorry for the (messy, at times seemingly illogical) code : I\n// try to do things with some structure, but inspiration is doing its own\n// non-linear thing, I keep adding small details and my left brain has to\n// tie it all together afterwards.\n// Also I'm trying new things here so if you enjoy this kind of content,\n// please say it loud in the comments. It might influence what I have in\n// store for you (i.e. the coming shaders may or may not include some\n// story, depending on how well this one is received) I have MANY other\n// 2D shaders to come, which are begging for some explanatory text... and\n// extra-planetary fiction. :)\n\n// Also : yes, someday I might really write \"Beyond a Colder War\". In the\n// beginning, I had no inspiration, but after a while, that changed... I\n// guess thinking about 90ies technology and a nuclear Super Concorde is\n// just too enticing ! Skaven's soundtrack certainly had an effect too.\n// Btw, have you listened to his lastest music, \"Exhumed Glory\" ? Or\n// \"Loserboy\" ? These go straight into the \"Beyond A Colder War\" album...\n// ...with \"Inconsequentialize\", of course !\n// If I ever write the damn thing, it will obviously be released as a\n// fanfic too and free to read online. Don't hold your breath, though :\n// I'm quite slow and my health ain't what it used to be. But inspiration\n// is there, and I get stronger flashes these days, sooooo... I guess you\n// never know. :)\n\n// Sorry for talking too much.\n\n// Use this code as you wish, just try to give proper credit when so.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// Music is \"Inconsequentialize\" by Skaven, thanks A LOT for sharing your\n// productions with a creator-friendly licence. Your music ROCKS, man !\n// https://soundcloud.com/skaven252/inconsequentialize\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 p = fragCoord.xy/iResolution.xy;\n     \n     vec4 col = texture(iChannel0,p);\n\n     // -sigh- \"At last it is done...\"\n     fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\nint  TxtIntro[860] = int [] ( 65, 68, 32, 49, 57, 57, 54, 46, 32, 88, 75, 45, 77, 97, 115, 97, 100, 97, 44, 32, 108, 97, 115, 116, 32, 114, 101, 102, 117, 103, 101, 32, 111, 102, 32, 116, 104, 101, 32, 104, 117, 109, 97, 110, 32, 114, 97, 99, 101, 44, 32, 104, 97, 115, 32, 102, 97, 108, 108, 101, 110, 46, 32, 65, 110, 100, 32, 110, 111, 119, 32, 119, 104, 97, 116, 39, 115, 32, 108, 101, 102, 116, 32, 111, 102, 32, 109, 97, 110, 107, 105, 110, 100, 32, 105, 115, 32, 111, 110, 32, 116, 104, 101, 32, 114, 117, 110, 46, 46, 46, 32, 83, 117, 114, 118, 105, 118, 111, 114, 115, 32, 109, 117, 115, 116, 32, 102, 108, 101, 101, 32, 116, 104, 114, 111, 117, 103, 104, 32, 116, 104, 101, 32, 103, 97, 116, 101, 115, 32, 116, 111, 32, 104, 111, 115, 116, 105, 108, 101, 32, 119, 111, 114, 108, 100, 115, 32, 102, 117, 108, 108, 32, 111, 102, 32, 114, 97, 100, 105, 97, 116, 105, 111, 110, 115, 44, 32, 112, 111, 105, 115, 111, 110, 32, 103, 97, 115, 32, 97, 110, 100, 32, 103, 97, 108, 97, 99, 116, 105, 99, 32, 104, 111, 114, 114, 111, 114, 115, 32, 98, 101, 121, 111, 110, 100, 32, 105, 109, 97, 103, 105, 110, 97, 116, 105, 111, 110, 46, 32, 66, 117, 116, 32, 75, 45, 84, 104, 117, 108, 117, 32, 105, 115, 32, 99, 108, 111, 115, 105, 110, 103, 32, 105, 110, 32, 58, 32, 109, 111, 115, 116, 32, 104, 117, 109, 97, 110, 115, 32, 99, 97, 110, 32, 102, 101, 101, 108, 32, 105, 116, 115, 32, 104, 117, 110, 103, 101, 114, 32, 97, 108, 114, 101, 97, 100, 121, 32, 103, 110, 97, 119, 105, 110, 103, 32, 97, 116, 32, 116, 104, 101, 105, 114, 32, 115, 111, 117, 108, 46, 32, 77, 97, 100, 110, 101, 115, 115, 32, 115, 116, 114, 105, 107, 101, 115, 32, 108, 105, 107, 101, 32, 97, 32, 100, 105, 115, 101, 97, 115, 101, 32, 97, 110, 100, 32, 117, 110, 100, 101, 114, 109, 105, 110, 101, 115, 32, 116, 104, 101, 32, 101, 110, 116, 105, 114, 101, 32, 101, 118, 97, 99, 117, 97, 116, 105, 111, 110, 46, 32, 84, 104, 101, 32, 115, 116, 97, 114, 115, 32, 104, 97, 118, 101, 32, 110, 111, 32, 109, 101, 114, 99, 121, 46, 32, 73, 110, 32, 97, 32, 112, 97, 110, 105, 99, 44, 32, 115, 99, 111, 117, 116, 32, 109, 105, 115, 115, 105, 111, 110, 115, 32, 97, 114, 101, 32, 115, 101, 110, 116, 32, 105, 110, 116, 111, 32, 116, 104, 101, 32, 103, 97, 116, 101, 115, 44, 32, 100, 101, 101, 112, 101, 114, 32, 116, 104, 97, 110, 32, 101, 118, 101, 114, 32, 98, 101, 102, 111, 114, 101, 46, 32, 70, 49, 49, 55, 115, 44, 32, 70, 49, 53, 115, 44, 32, 70, 49, 52, 115, 44, 32, 111, 108, 100, 32, 83, 82, 55, 49, 115, 32, 97, 110, 100, 32, 110, 117, 99, 108, 101, 97, 114, 32, 83, 117, 112, 101, 114, 32, 67, 111, 110, 99, 111, 114, 100, 101, 32, 83, 83, 84, 79, 115, 32, 101, 113, 117, 105, 112, 101, 100, 32, 119, 105, 116, 104, 32, 97, 100, 118, 97, 110, 99, 101, 100, 32, 99, 108, 111, 97, 107, 105, 110, 103, 46, 32, 66, 117, 116, 32, 82, 111, 103, 101, 114, 32, 107, 110, 111, 119, 115, 46, 46, 46, 32, 84, 104, 105, 115, 32, 105, 115, 32, 106, 117, 115, 116, 32, 100, 101, 108, 97, 121, 105, 110, 103, 32, 116, 104, 101, 32, 105, 110, 101, 118, 105, 116, 97, 98, 108, 101, 46, 32, 83, 111, 32, 119, 104, 101, 110, 32, 104, 101, 39, 115, 32, 115, 101, 110, 116, 32, 116, 111, 32, 105, 110, 118, 101, 115, 116, 105, 103, 97, 116, 101, 32, 115, 116, 114, 97, 110, 103, 101, 32, 102, 105, 110, 100, 105, 110, 103, 115, 32, 111, 110, 32, 112, 108, 97, 110, 101, 116, 32, 88, 75, 45, 51, 55, 50, 48, 32, 45, 99, 111, 100, 101, 110, 97, 109, 101, 32, 68, 114, 97, 120, 97, 107, 97, 114, 45, 32, 104, 101, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 101, 120, 112, 101, 99, 116, 32, 116, 111, 32, 99, 111, 109, 101, 32, 98, 97, 99, 107, 46, 46, 46, 32, 65, 32, 115, 101, 113, 117, 101, 108, 32, 116, 111, 32, 67, 104, 97, 114, 108, 101, 115, 32, 83, 116, 114, 111, 115, 115, 39, 115, 32, 101, 112, 105, 99, 32, 76, 111, 118, 101, 99, 114, 97, 102, 116, 105, 97, 110, 32, 116, 97, 108, 101, 44, 32, 119, 104, 105, 99, 104, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 101, 120, 105, 115, 116, 46, 46, 46, 32, 121, 101, 116, 32, 33, 32, 58, 41 );\nint  TxtTitle1[ 6] = int [] ( 66, 69, 89, 79, 78, 68 );\nint  TxtTitle2[12] = int [] ( 65, 32, 67, 79, 76, 68, 69, 82, 32, 87, 65, 82 );\nint  TxtIRView[43] = int [] ( 67, 97, 109, 32, 48, 53, 32, 45, 32, 68, 114, 97, 120, 97, 107, 97, 114, 32, 77, 105, 115, 115, 105, 111, 110, 32, 35, 48, 50, 32, 45, 32, 71, 114, 111, 117, 110, 100, 32, 84, 101, 97, 109 );\n\nvec2  Centrage;\nvec2  last_p;\nint   Level;\nfloat SeqLength = 38.51;\nfloat Shadow;\n\nfloat TiltX;\nfloat AltiY;\nfloat TimeVar;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Short, basic functions.\nmat2  r2d( float a ){ float c = cos(a), s = sin(a); return mat2( c, s, -s, c ); }\nfloat noise(vec2 st) { return fract( sin( dot( st.xy, vec2(12.9898,78.233)))*43758.5453123 ); }\n\nfloat traceChar( in vec2 v,float charac, vec2 PosTxt)\n{\n      float colorChar = 0.0;\n      v = vec2(v.x, 1.0-v.y);\n      if( v.x > PosTxt.x && v.x < PosTxt.x + 1.0/16.0 )\n      {\n          if( v.y > PosTxt.y && v.y < PosTxt.y + 1.0/16.0 )\n          {\n              vec2 Disp = vec2(mod(float(charac),16.0),floor(float(charac) / 16.0))/16.0;\n              colorChar = texture(iChannel3,vec2(Disp.x + (v.x - PosTxt.x),-Disp.y - (v.y - PosTxt.y) )).x;\n          };\n      };\n      return colorChar;\n}\n\n// Basic Geometry Functions, Thanks Iq, Shadertoy, Et Alia...\n\nfloat sdCircle(in vec2 p, float radius, vec2 pos, float prec)\n{\n      return smoothstep(0.0,prec,radius - length(pos-p));\n}\n\nfloat dis_e(vec2 center, float a, float b, vec2 coord)\n{\n      float x2 = (coord.x-center.x)*(coord.x-center.x);\n      float y2 = (coord.y-center.y)*(coord.y-center.y);\n      float a2 = a*a;\n      float b2 = b*b;\n      float d = 1.0;\n      d = x2/a2+y2/b2;\n      return d;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n      vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n      vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n      vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n      vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n      vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n      float s = sign( e0.x*e2.y - e0.y*e2.x );\n      vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                       vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                       vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n      return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n      vec2 d = abs(p)-b;\n      return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat metaDiamond(vec2 p, vec2 pixel, float r, float s)\n{\n      vec2 d = abs(r2d(s)*(p-pixel));\n      return r / (d.x + d.y);\n}\n\n// Original code starts !\n\nvec4 drawAtmoGradient(in vec2 p)\n{\n     return mix( vec4(1.00,0.50,0.20,1.00),vec4(0.025,0.025,0.10,1.00),0.64*sqrt(abs(p.y)));\n}\n\n// This is not really fbm, more like \"single octave smoothed noise\"\n// But it's going to be used in ad-hoc fbm functions later on (jungle canopy, mountains, etc).\nfloat fbm(in vec2 p)\n{\n      return mix(noise(vec2(floor(p.x))),noise(vec2(floor(p.x + 1.0))), smoothstep(0.0,1.0,fract(p.x)));\n}\n\nfloat drawStars(in vec2 p)\n{\n      float Disp_Star =       0.000;\n      float Buff_Star =       0.000;\n      float PosX_Star =       0.000;\n      float PosY_Star =       0.000;\n      float Dist_Star =       0.000;\n      float Magn_Star =       0.000;\n\n      for( float j = 0.0; j < 100.0 ; j++ )\n      {\n           PosX_Star  = mod((7.0*noise(vec2(j))-3.5) - Disp_Star,7.0) - 3.5;\n           PosY_Star  = 0.5+3.5*noise(vec2(j + 176.0));\n           Dist_Star  = length(p - vec2(PosX_Star,PosY_Star));\n           Magn_Star  = 0.00005*noise(vec2(j + 4.0));\n           if( length(vec2(PosX_Star,PosY_Star) - vec2( 0.0, 1.7)) > 0.8\n            && length(vec2(PosX_Star,PosY_Star) - vec2( 1.7, 2.5)) > 0.1 )\n           {\n               if( mod(j,20.0)!=0.0 )\n               {\n                   // Normal Star\n                   Buff_Star += Magn_Star*pow(Dist_Star,-1.6);\n               }else{\n                   // Bigger star with cross\n                   Buff_Star += metaDiamond(p,vec2(PosX_Star,PosY_Star),0.005,0.0);\n               };\n           };\n      };\n      return Buff_Star;\n}\n\n// Pylons and totems built by Mi-Go tribes (?) to praise Yog-Sothoth\nvec4 drawPylons(in vec2 p, vec4 c, float TimeVar)\n{\n     float Disp_Pylon = TimeVar;\n     float PosX_Pylon =     0.0;\n     float PosY_Pylon =     0.0;\n     float Rand_Pylon =     0.0;\n\n     for( float j = 0.0; j < 10.0 ; j+=1.0 )\n     {\n          PosX_Pylon = mod((10.0*noise(vec2(j+50.0))-5.0) - Disp_Pylon,10.0) - 5.0;\n          PosY_Pylon = 0.0;\n          Rand_Pylon = 0.3+0.4*noise(vec2(j));\n          c = mix( c,\n                     vec4(1.0,0.7,0.4,1.0) - texture(iChannel0,abs(2.0*(p - vec2(PosX_Pylon,3.0*Rand_Pylon)) )),\n                     smoothstep(0.005,0.0,sdTriangle(p, vec2(-0.02 + PosX_Pylon,              PosY_Pylon),\n                                                        vec2( 0.02 + PosX_Pylon,              PosY_Pylon),\n                                                        vec2(        PosX_Pylon, Rand_Pylon + PosY_Pylon))));\n      };\n      return c;\n}\n\n// Adding octaves and tweaking freq,amp,speed until it fits !\n// i.e. ad-hoc hand-made \"fbm\".\nfloat FirstTreeLine(in vec2 p, float TimeVar)\n{\n      return   0.100*fbm(vec2(  1.0*(p + 0.25*TimeVar)))\n             + 0.050*fbm(vec2( 10.0*(p + 0.25*TimeVar)))\n             + 0.015*fbm(vec2(100.0*(p + 0.25*TimeVar)))\n             + 0.050;\n}\n\nfloat SecondTreeLine(in vec2 p, float TimeVar)\n{\n      return   0.050*fbm(vec2(  1.0*(p + 0.15*TimeVar)))\n             + 0.020*fbm(vec2( 10.0*(p + 0.15*TimeVar)))\n             + 0.010*fbm(vec2(100.0*(p + 0.15*TimeVar)))\n             + 0.150;\n}\n\nfloat ThirdTreeLine(in vec2 p, float TimeVar)\n{\n      return   0.070*fbm(vec2(  1.0*(p + 0.05*TimeVar)))\n             + 0.008*fbm(vec2( 10.0*(p + 0.05*TimeVar)))\n             + 0.004*fbm(vec2(100.0*(p + 0.05*TimeVar)))\n             + 0.210;\n}\n\nfloat Mountains(in vec2 p, float TimeVar)\n{\n      p.x += 100.35; // just for varying the noise signal...\n      return   0.250*fbm(vec2(  1.0*(p + 0.025*TimeVar)))\n             + 0.020*fbm(vec2( 10.0*(p + 0.025*TimeVar)))\n             + 0.200;\n}\n\nfloat MountainsFar(in vec2 p, float TimeVar)\n{\n      p.x += 15.00; // just for varying the noise signal...\n      return   0.200*fbm(vec2(  1.0*(p + 0.0125*TimeVar)))\n             + 0.050*fbm(vec2( 10.0*(p + 0.0125*TimeVar)))\n             + 0.15;\n}\n\nfloat MountainsTex(in vec2 p, float TimeVar)\n{\n      return  0.5*fbm(vec2( 20.5*(p + 0.025*TimeVar))) + 0.15;\n}\n\nfloat Clouds(in vec2 p, float TimeVar)\n{\n      return 0.25*fbm(vec2(  2.0*(p + 0.0125*TimeVar))) + 0.25;\n}\n\nfloat WeedsLine(in vec2 p, float TimeVar)\n{\n      return   0.0500*fbm(vec2(   1.0*(p + TimeVar)))\n             + 0.0250*fbm(vec2( 100.0*(p + TimeVar)))\n             + 0.0125*fbm(vec2( 250.0*(p + TimeVar)))\n             + 2.5300;\n}\n\nvec4 drawRingPlanet(in vec2 p, float TimeVar)\n{\n     // Gas Giant + Terminator\n     vec4 RP = texture(iChannel0,vec2(0.07*p.x - 0.0015*TimeVar,p.y))\n              *sdCircle(p,0.8,vec2(0.0,0.0),0.01)\n              *smoothstep(1.0,0.0,sdCircle(p,0.88,vec2( 0.020,-0.1),0.1));\n\n     // Closest Part Of Ring\n     if( p.y < 0.0 ) RP += (1.0+5.0*p.y)*smoothstep(0.12,0.0,abs(1.0 - dis_e(vec2(0.0, 0.000), 1.8, 0.14, p)))  // Smaller Ring\n                         + (1.0+3.0*p.y)*smoothstep(0.12,0.0,abs(1.0 - dis_e(vec2(0.0,-0.005), 2.0, 0.20, p))); // Bigger Ring\n\n     // Furthest Part Of Ring\n     if( p.y > 0.0 && length(p) > 0.8 ) RP += smoothstep(0.12,0.0,abs(1.0 - dis_e(vec2(0.0, 0.000), 1.8, 0.14 + 0.14*p.y, p)))\n                                            + smoothstep(0.12,0.0,abs(1.0 - dis_e(vec2(0.0,-0.005), 2.0, 0.20 - 0.10*p.y, p)));\n     return RP;\n}\n\nvec4 drawMagSphere(in vec2 p, float TimeVar)\n{\n     // Awful mashup of old code and new code. It just works.\n     float HeightMagSphere = 0.78 + 0.01*cos(0.1*iTime);\n     vec4 ColorMag = texture(iChannel0,0.2*vec2(p.x,p.y + 0.05*iTime))*fbm(vec2(20.0*p.x - 1.0*iTime));\n     float MagSphere = texture(iChannel0,vec2(p.x + 0.01*TimeVar,0.01*p.y + 0.01*TimeVar)).x\n                      *smoothstep(0.0,1.0,1.0-10.0*(abs(p.y)-(HeightMagSphere + 0.05*fbm(vec2(60.0*p.x + 0.5*TimeVar)))));\n     MagSphere *= smoothstep(0.0,0.2,abs(p.y) - HeightMagSphere + 0.1);\n     MagSphere *= smoothstep(0.05,0.0,abs(p.x) - sqrt(0.8*0.8-HeightMagSphere*HeightMagSphere));\n     p = abs(p);\n     MagSphere += ColorMag.x*smoothstep(0.125,0.0,abs(p.y - 2.0*sqrt(p.x - 0.02) - 0.8))\n                 *smoothstep(0.9 - 0.5*fbm(vec2(0.2*iTime)),0.0,p.x)*smoothstep(0.0,0.2,length(p)-0.8);\n     MagSphere += ColorMag.x*smoothstep(0.025,0.0,abs(p.y - 0.95*sqrt(p.x - 0.05) - 0.8))\n                 *smoothstep(0.9 - 0.5*fbm(vec2(0.2*iTime)),0.0,p.x)*smoothstep(0.0,0.2,length(p)-0.8);\n     return vec4(0.0,MagSphere,0.0,1.0);\n}\n\n// Look, I swear there is a valid chain of events that justifies everything in\n// the next procedure. In fact there may be several of them.... which explains\n// why it looks so messy, yet somehow succeeds at displaying STEP-PYRAMIDS !!!\n// IN FAKE 3D ! WITH FREAKING DEATH MASKS ON THE WALLS ! ENERGY BEAMS ! AND MI-GO !\n// IN A CAVE ! WITH A BOX OF SCRAPS !\n// Also, French croissant in your face ! :D\n\nvec4 drawShrines(in vec2 p, vec4 c, float TimeVar)\n{\n     Shadow = 1.0;\n     // We're gonna display 10 Step-Pyramids on a threadmill, it's gonna be fun ! :)\n     // Also we're going to draw each step as a triangle slice becauuuuuuuse...\n     // ...it's harder that way and slower too. What could go wrong ?\n     for( float k = 0.0 ; k < 10.0 ; k+=1.0 )\n     {\n          // Define Step-Pyramids characteristics...\n          float Temple_X = mod((20.0*noise(vec2(k+1050.2))-10.0) - (0.08 + 0.0025*k)*TimeVar,20.0) - 10.0;\n          float Temple_Size  = 1.2 + 0.4*noise(vec2(k+241.1));\n          float height_steps = 0.13;\n          float Temple_Style = 3.0+ ceil(3.0*fbm(vec2(4.1*k)));\n          float Temple_Y     =  0.0;\n\n          if(abs(Temple_X)< 1.0 && abs(Temple_X) < Shadow)Shadow = abs(Temple_X);\n\n          if( k == 9.0){ Temple_Style = 8.0; Temple_Size = 2.0;}; // at least one Class-VIII Step-Pyramid...\n\n          vec2 TranscendVec  = vec2(0.0); // Texture Offset for special effect\n\n          float ChooseTex = mod(k,3.0);\n\n          if( Temple_Style == 8.0 ) // Special Effects When Class-VIII Step-Pyramid (SP)...\n          {\n              ChooseTex = 0.0;\n              float fbm2 = fbm(vec2(TimeVar + 100.0*Temple_Style));\n              float fbm3 = fbm(vec2(0.5*TimeVar + 100.0*Temple_Style));\n\n              c += vec4(1.0,0.9,0.8,0.0)*metaDiamond(p,vec2( Temple_X,(Temple_Style+0.5)*height_steps),0.04 + 0.01*sin(20.0*TimeVar),0.0);\n\n              vec2 PosFungi01 = vec2( Temple_X,2.0 + 1.0*fbm3);\n              float DistFungi01  = length(p - PosFungi01);\n              if(p.y < PosFungi01.y && fbm2 > 0.5)c += 0.7*smoothstep(0.01,0.00,abs(p.x-Temple_X)-0.01*fbm(vec2(10.0*p.y - 20.0*TimeVar)));\n              if(DistFungi01< 0.4)c += vec4(0.15,0.15,1.0,1.0)\n                                      *metaDiamond(p,PosFungi01,0.09 + 0.005*sin(25.0*TimeVar + 200.0*Temple_Style),0.0)\n                                      *smoothstep(0.2,0.0,DistFungi01 - 0.2);\n              vec2 PosFungi02 = vec2( Temple_X -0.7 + 1.4*fbm(vec2(0.5*TimeVar + 200.0*Temple_Style)),\n                                      0.8 + 0.8*fbm(vec2(0.3*TimeVar + 20.0*Temple_Style)));\n              float DistFungi02  = length(p - PosFungi02);\n              if(DistFungi02< 0.8)c += vec4(0.15,0.15,1.0,1.0)\n                                      *metaDiamond(p,PosFungi02,0.07 - 0.05*fbm(vec2(1.0*TimeVar)),2.5*fbm(vec2(5.0*TimeVar)))\n                                      *smoothstep(0.4,0.0,DistFungi02 - 0.4);\n              c += 2.0*fbm2*vec4(0.15,0.15,1.0,1.0)*smoothstep(0.0,0.8,1.0-(20.0 + 30.0*fbm2)*abs(p.x-Temple_X));\n          };\n\n          // Don't compute pyramids that are out of the window ! :D\n          // This is actually ad-hoc masking... Not a great practice.\n          if( abs(p.x - Temple_X) < Temple_Size && p.y < height_steps*(Temple_Style + 2.0) )\n          {\n              // Make the temple texture scroll when in infrared for extra-spookyness\n              // i.e. those shrines are \"active\" in ways we don't normally see...\n              if(mod(TimeVar,SeqLength) > SeqLength/2.0 && Temple_Style==8.0)TranscendVec += vec2(0.1*TimeVar,0.0);\n\n              for( float j = 0.0; j < Temple_Style ; j+=1.0 )\n              {\n                   if( (p.y - height_steps) >= height_steps*j && (p.y - height_steps) <= height_steps*(j+1.0) )\n                   {\n                       vec4  Front_Texture; // Front Texture\n                       vec4  Back_Texture; // Back Texture\n                       // Strangely enough, the human mind will make up faces everywhere provided we\n                       // give him a few hints of symetry, so we do exactly that : by mirroring textures\n                       // and having a proper level of detail (zoom), we can use innocent looking patterns\n                       // (i.e. Shadertoy generic textures) and conjure up demons, skulls and menacing faces\n                       // for close to zero computing cost. This also makes excellent mayan-style\n                       // or Giger-esque decorations, according to your sensibility. And the best part ?\n                       // Most of the effect is actually happening in your brain...\n                       float SkullsAndDemons;\n                       float Space = 0.1;\n                       float Ratio = 2.0;\n                       if(mod((p.x - Temple_X)/Space,2.0)<1.0)SkullsAndDemons = mod(abs(p.x - Temple_X + k),Space);\n                       else SkullsAndDemons = Space-mod(abs(p.x - Temple_X + k),Space);\n                       // Here I initially had a simple switch with a sampler2d variable, but it didn't\n                       // compile on Shadertoy. So I had to unroll the whole thing. Never could figure\n                       // this one out ! It worked at home, though.\n                       // I guess it's not very elegant, but it would allow to specifically customize\n                       // every case in clear, soooo it's not that stupid... It bothers me though. :-/\n                       if( ChooseTex == 0.0)\n                       {\n                           Front_Texture = texture(iChannel0,vec2(SkullsAndDemons,Ratio*p.y + 0.5*Temple_Style) + TranscendVec);\n                           Back_Texture  = texture(iChannel0,2.0*vec2(p.x - Temple_X,p.y));\n                       }else{\n                           if( ChooseTex == 1.0)\n                           {\n                               Front_Texture = texture(iChannel1,vec2(SkullsAndDemons,Ratio*p.y + 0.5*Temple_Style) + TranscendVec);\n                               Back_Texture  = texture(iChannel1,2.0*vec2(p.x - Temple_X,p.y));\n                           }else{\n                               Front_Texture = texture(iChannel2,vec2(SkullsAndDemons,Ratio*p.y + 0.5*Temple_Style) + TranscendVec);\n                               Back_Texture  = texture(iChannel2,2.0*vec2(p.x - Temple_X,p.y));\n                           };\n                       };\n                       vec4 ColorGlint = vec4(0.8,0.6,0.3,1.0);\n                       // Back of the SP\n                       c = mix(c,(ColorGlint+0.7*Back_Texture) - 0.3*smoothstep(0.02,0.0,p.y - height_steps*(j+1.0)),\n                                       smoothstep(0.01,0.0,sdTriangle(p,     vec2(Temple_X - Temple_Size/2.0 - 0.100*Temple_X,Temple_Y               - height_steps*j),\n                                                                             vec2(Temple_X + Temple_Size/2.0 - 0.100*Temple_X,Temple_Y               - height_steps*j),\n                                                                             vec2(Temple_X +                              0.0,Temple_Y + Temple_Size - height_steps*j))));\n                       // Lines on the sides\n                       c -= vec4(0.5)*smoothstep(0.005,0.0,abs(sdTriangle(p, vec2(Temple_X - Temple_Size/2.0 - 0.033*Temple_X,Temple_Y               - height_steps*j),\n                                                                             vec2(Temple_X + Temple_Size/2.0 - 0.033*Temple_X,Temple_Y               - height_steps*j),\n                                                                             vec2(Temple_X +                              0.0,Temple_Y + Temple_Size - height_steps*j))));\n                       c -= vec4(0.5)*smoothstep(0.005,0.0,abs(sdTriangle(p, vec2(Temple_X - Temple_Size/2.0 - 0.066*Temple_X,Temple_Y               - height_steps*j),\n                                                                             vec2(Temple_X + Temple_Size/2.0 - 0.066*Temple_X,Temple_Y               - height_steps*j),\n                                                                             vec2(Temple_X +                              0.0,Temple_Y + Temple_Size - height_steps*j))));\n\n                       // Front of the SP\n                       float PyramidStage = sdTriangle(p, vec2(Temple_X - Temple_Size/2.0,Temple_Y               - height_steps*j),\n                                                          vec2(Temple_X + Temple_Size/2.0,Temple_Y               - height_steps*j),\n                                                          vec2(Temple_X +             0.0,Temple_Y + Temple_Size - height_steps*j));\n\n                       float AdditionalDeco = smoothstep(0.01,0.0,abs(p.y - height_steps*(j+1.97)))*smoothstep(0.0,0.75,abs(p.x-Temple_X));\n\n                       // Add some highlights on each step\n                       c = mix(c,ColorGlint*(0.1+0.05*j) + 0.5*Front_Texture\n                                       - 0.1*smoothstep(0.025,0.0,p.y - height_steps*(j+1.0))\n                                       + 1.0*ColorGlint*AdditionalDeco,\n                                       smoothstep(0.001,0.0,PyramidStage));\n                       c += 1.0*ColorGlint*smoothstep(0.005,0.0,abs(PyramidStage))*smoothstep(0.0,0.025,p.y - height_steps*(j+1.0));\n                   };\n                   if( Temple_Style == 8.0 )\n                   {\n                       c += vec4(1.0,0.5,0.2,1.0)*metaDiamond(p,vec2( Temple_X,6.1*height_steps),0.015,0.0)\n                                                 *smoothstep(0.1,0.0,length(p-vec2(Temple_X,6.1*height_steps)));\n                       if( j < 7.0 && p.y < height_steps*(j+1.0))\n                       {\n                           c+= (1.0+(1.0-Shadow))*vec4(1.0,1.0,0.1,1.0)*texture(iChannel0,p*vec2(1.0,0.1) + vec2((0.08 + 0.0025*k)*TimeVar,0.01*TimeVar + 0.1*j))*smoothstep(0.1,0.00,abs(p.x-Temple_X) - 0.03*(5.0-j));\n                           c+= 0.28*vec4(1.0,0.5,0.2,1.0)*smoothstep(0.2,0.00,abs(p.x-Temple_X) - 0.05*(5.0-j));\n                       };\n                   };\n              };\n              // Add Stairs (...which begs the question : if the Mi-Go built these structures, why the steps ? These morons can fly, FFS ?!)\n              if( Temple_Style < 6.0 || Temple_Style == 8.0)\n              {\n                  float S = abs(p.x - Temple_X) - 0.1 + 0.55*p.y/Temple_Style - 0.04*mod(p.y,height_steps);\n                  float Stairs  = smoothstep(0.01,0.0,S);\n                  float Ramps   = smoothstep(0.005,0.0,abs(S));\n                  c = mix(c,0.9*texture(iChannel2,p + vec2((0.08 + 0.0035*k)*TimeVar,0.0) ) + 0.1*sin(750.0*p.y),\n                                                            0.45*Stairs*smoothstep(0.001,0.0,p.y - Temple_Style*height_steps));\n                  c = mix(c,0.1*texture(iChannel2,p + vec2((0.08 + 0.0025*k)*TimeVar,0.0) ),0.5*Ramps*smoothstep(0.001,0.0,p.y - Temple_Style*height_steps));\n              };\n          };\n     };\n     return c;\n}\n\nvec4 drawTunnel(in vec2 p, vec4 CS,sampler2D tex, float TimeVar)\n{\n     // Modified tunnel effect for the Nebula\n     float angle = atan(p.y/p.x);\n     float dist  = length(p);\n     vec3  Tunnel;\n     Tunnel = texture( tex,vec2( 0.080*(1.0/dist) + 0.3  + 0.01*TimeVar, angle/PI + 1.5*dist + 0.01*TimeVar)).xyz;\n     Tunnel += smoothstep(0.2,0.0 ,dist);\n     Tunnel -= smoothstep(0.0,0.05,dist);\n     return vec4(clamp(Tunnel,0.0,1.0),1.0);\n}\n\nvec4 drawSpacePlane(in vec2 p, vec4 col, float TimeVar)\n{\n     // It is 2023 and we still have no SSTO spaceplane.\n     // if it does not make you angry, well it should.\n     // Less bloody cubesats, more spaceplanes !\n     vec2 PosSpaceplane = vec2( 0.8*cos(0.1*TimeVar), 1.5 + 0.35*sin(0.1*TimeVar));\n\n     float ProfilContrail = 0.005*fbm(vec2(10.0*p.x + 10.0*TimeVar));\n     float Contrail       = smoothstep(0.0,0.005,abs(p.y - (PosSpaceplane.y - 0.02)) - ProfilContrail);\n\n     // Contrail, because even with a cloaking hull, water vapor\n     // in the atmosphere does not care...\n     col += 0.25*smoothstep(0.3,0.0,p.x-PosSpaceplane.x + 0.65)*(1.0-vec4(Contrail));\n\n     // 3-Triangles Super Concorde\n     float SC01 = 0.0;\n     SC01 = min(smoothstep(0.0,0.005, sdTriangle( p - PosSpaceplane,\n                                                  vec2(-0.30, 0.0 ),\n                                                  vec2( 0.32, 0.005 ),\n                                                  vec2(-0.36,-0.04))),\n                smoothstep(0.0,0.002, sdTriangle( p - PosSpaceplane,\n                                                  vec2(-0.45, 0.0 ),\n                                                  vec2(-0.30, 0.0 ),\n                                                  vec2(-0.33,-0.02))));\n     SC01 = min(SC01,smoothstep(0.0,0.005, sdTriangle( p - PosSpaceplane,\n                                                  vec2(-0.39, 0.0 ),\n                                                  vec2(-0.36, 0.05),\n                                                  vec2(-0.30, 0.0 ))));\n     SC01 = 1.0-SC01;\n\n     // Oscillating Cloaking Factor due to high EM levels and faulty breakers...\n     float CloakingFactor = 0.25 + 0.25*sin(-PI/2.0+0.5*TimeVar);\n     // Clipping the tail of Super Concorde for signature profile...\n     if(p.y < (PosSpaceplane.y + 0.04))col = mix(col,vec4(0.0),CloakingFactor*SC01);\n\n     return col + CloakingFactor*abs(sin(4.0*TimeVar))*metaDiamond(p,PosSpaceplane + vec2(-0.36,0.05),0.003,5.0*TimeVar);\n}\n\nvec4 drawArcadesOfYuk(in vec2 p, vec4 c, float TimeVar)\n{\n     // Draw \"The Arcades of Yuk\". Time Of Construction : Unknown.\n     float fbmArk = fbm(vec2(20.0*p.x + 16.0*TimeVar));\n     float noise1 = noise(vec2(floor(5.0*p.x + 4.0*TimeVar)));\n     c = mix(c,0.8*texture(iChannel1,vec2(mod(0.5*p.x + 0.4*TimeVar,3.4),p.y)),\n               smoothstep(0.01,0.0, p.y - 2.654 + 0.1*noise1 + 0.005*fbmArk)\n              *smoothstep(0.0,0.01, p.y - (1.90 + 0.5*abs(cos((p.x - 0.15 + 0.8*TimeVar)*PI/3.4 + PI/2.0)) + 0.01*fbmArk)));\n\n     if( p.y < 3.0 + 0.05*sin((10.0*3.4/PI)*(p.x + 0.8*TimeVar))) // Top Columns\n     {\n         if( mod(p.x - 0.02*sin(10.0*p.y + PI/4.0) + 0.8*TimeVar,3.4) - 0.3 + 0.04*sin(10.0*p.y + PI/4.0) < 0.0 )\n         {\n             if( p.y > 0.25)\n             {\n                 c = texture(iChannel1,vec2(0.05*sin(mod(p.x + 0.8*TimeVar,3.4)*PI/0.3),0.5*p.y + 0.85))\n                    *smoothstep(1.0,0.0,0.8*sin(PI*mod(p.x + 0.8*TimeVar,3.4)/0.3));\n             }else{\n                 c = texture(iChannel2,vec2(0.1*sin(mod(p.x + 0.8*TimeVar,3.4)*PI/0.3),p.y))\n                    *smoothstep(1.0,0.0,0.8*sin(PI*mod(p.x + 0.8*TimeVar,3.4)/0.3));\n             };\n         };\n     };\n\n     // Weeds have grown on top...\n     c = mix(c,\n               vec4(0.7,1.0,0.5,1.0)*(0.5+0.5*texture(iChannel0,vec2(1.0*p.x + 0.8*TimeVar,0.1*p.y))),\n               smoothstep(0.01,0.0,(p.y - 1.01*WeedsLine(1.0*p + vec2(100.0),0.8*TimeVar)))*\n               smoothstep(0.0,0.01,p.y - (2.65 - 0.1*noise1)));\n\n     // Top\n     float fbmTop = fbm(vec2(20.0*p.x + 16.0*TimeVar));\n     c = mix(c,\n               0.2*texture(iChannel1,vec2(mod(0.5*p.x + 0.4*TimeVar,3.4),p.y)),\n               smoothstep(0.01,0.00, p.y - (2.65 - 0.1*noise1 - 0.005*fbmTop))*\n               smoothstep(0.00,0.01, p.y - (2.0 + 0.5*abs(cos((p.x - 0.15 + 0.8*TimeVar)*PI/3.4 + PI/2.0)) - 0.02*fbmTop)));\n\n     return c;\n}\n\nvec4 drawPentag(in vec2 p, vec4 CS)\n{\n     p += vec2(0.0,-1.7);\n     p *= r2d(- 0.3*TimeVar);\n\n     CS *= fbm(vec2(2.0*TimeVar));\n     float Penta;\n     vec4 Penta_Color = vec4(0.0,0.0,0.0,1.0);\n     // Lets draw a protection seal...\n     for( int i =0; i< 5; i++)\n     {\n          Penta = p.x + 0.35;\n          Penta_Color += CS*smoothstep(0.007,0.0,abs(p.y-Penta));\n          Penta_Color += 0.25*CS*smoothstep(0.07,0.0,abs(p.y-Penta));\n          p *= r2d(PI*2.0/5.0);\n     };\n     // Draw Echo Lines (\"Repel Vaporous Emanations 75% more !\",\n     // 1985, Egon Spengler, Peter Venkman, Ray Stantz et alia)\n     /*p *= r2d(0.6*iTime); // counter-rotating echo lines...\n     for( int i =0; i< 15; i++)\n     {\n          Penta = p.x + 0.3;\n          Penta_Color += 0.5*CS*(1.0-smoothstep(0.0,0.004,abs(p.y-Penta)));\n          p *= r2d(PI*2.0/15.0);\n     };*/\n     Penta_Color += CS*smoothstep(0.005,0.00,abs(length(p) - 0.8) - 0.003);\n     return Penta_Color;\n}\n\nvec4 drawTitle(vec4 c, float TimeVar)\n{\n     vec2 logo_p = last_p;\n\n     vec4 ColorBeyond = vec4(0.70,1.00,0.00,1.00);\n     vec4 ColorACW    = vec4(0.99,0.50,0.20,1.00);\n\n     if( mod(TimeVar,SeqLength/2.0) > SeqLength/4.0)\n     {\n         ColorBeyond = vec4(0.99,0.50,0.20,1.00);\n         ColorACW    = vec4(0.70,1.00,0.00,1.00);\n     };\n\n     logo_p = last_p*3.2;  // Re-init !\n     logo_p *= r2d(TiltX);\n     logo_p *= (1.0+0.3*AltiY);\n     c += drawPentag(logo_p,ColorBeyond);\n     logo_p = last_p*3.2;  // Re-init !\n\n     logo_p = last_p + vec2(0.0,-0.15);\n\n     float EyeBlower = clamp(0.25*(sin(100.0*length(logo_p-vec2(0.5*sin(TimeVar),0.5*cos(TimeVar))) - 10.0*TimeVar)),0.0,1.0);\n\n     c -= 0.5*smoothstep(0.15,0.0,abs(logo_p.y-0.015*fbm(vec2(2.0*logo_p.x+10.0*TimeVar)) - 0.27) - 0.1);\n\n     Centrage = vec2(-0.171, 0.795);\n\n     // Beyond - Blur\n\n     for( float k = 0.0 ; k < 20.0 ; k++ )\n          for( float i = 0.0; i < 6.0; i++ )\n               c += (0.2-k*0.01)*(ColorBeyond-EyeBlower)*traceChar(logo_p*(1.4*0.35 + k*0.008),float(TxtTitle1[int(i)]), Centrage + vec2(0.056*mod(i,33.0),0.0));\n\n     // Beyond - Clear\n\n     for( float i = 0.0; i < 6.0; i++ )\n          c += 2.0*(ColorBeyond - EyeBlower)*traceChar(logo_p*1.4*0.35,float(TxtTitle1[int(i)]), Centrage + vec2(0.056*mod(i,33.0),0.0));\n\n     // A Colder War\n\n     Centrage = vec2(-0.445, 0.200);\n\n     for( float i = 0.0; i < 12.0; i++ )\n          c += 2.5*( ColorACW - EyeBlower)*traceChar(logo_p*1.4,float(TxtTitle2[int(i)]), Centrage + vec2(0.076*mod(i,33.0),0.4));\n\n     return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 p = vec2( (iResolution.x/iResolution.y) * (fragCoord.x - iResolution.x/2.0) / iResolution.x,\n                    fragCoord.y / iResolution.y);\n\n     // Prepare for a lot of seemingly arbitrary (and stupid) decisions :\n     // you know... ART ! :D It doesn't make sense, and it doesn't need to !\n     // Here goes :\n\n     TimeVar = mod(1.0*iTime,278.437);\n\n     TiltX = -0.0001*(iMouse.x - iResolution.x/2.0);\n     AltiY =  0.0020*(iMouse.y - iResolution.y/2.0);\n\n     // Save before screwing up (...because we will , my precious, we will)\n     last_p = p;\n\n     // Render with lower rez when \"military imaging\". It's 1996 after all...\n     if( mod(TimeVar,SeqLength) > SeqLength/2.0){ p = 0.004*floor(250.0*p); };\n\n     // Zoom just a bit...\n     p = p * 3.2;\n\n     // Small Gate-Travel effect at the beginning...\n     // It costs nothing and doesn't look bad. :)\n     if(TimeVar<SeqLength/8.0)p.x = (r2d(3.0*(TimeVar-SeqLength/8.0)/length(p - vec2(0.0,1.5)))*p).x;\n\n     // User-induced chaos reduced to a minimum this time.\n     p *= r2d(TiltX);\n     p *= (1.0+0.3*AltiY);\n\n     // The World begins in darkness.\n     // Wether it also ends that way is ours to decide.\n     vec4 col = vec4(0.0,0.0,0.0,1.0);\n\n     // Tunnel Nebula\n     vec4 Nebula = vec4(0.0,0.0,0.0,1.0);\n     Nebula += 0.08*drawTunnel(0.025*(p + vec2( 0.0,-0.5)), vec4(1.0), iChannel0,TimeVar);\n     Nebula += 0.08*drawTunnel(0.025*(p + vec2( 0.0,-0.5)), vec4(1.0), iChannel2,TimeVar);\n     col += 0.6*Nebula*smoothstep(0.0,0.02,length(p-vec2(0.0, 1.7))-0.78);\n\n     // Atmosphere\n     col += drawAtmoGradient(p);\n\n     // \"THE STARS ARE RIGHT. THEY HAVE NO MERCY !\" ...tagline of the movie poster !\n     col += drawStars(p);\n\n     // Add green glow over the poles since the star is flaring (\"Check your fucking dosimeters, marines !\")\n     col += 0.25*abs(sin(0.15*TimeVar))*drawMagSphere(r2d(1.1*PI)*(p + vec2( 0.0,-1.7)),TimeVar);\n     // Draw the Giant and Rings (thanks Bonestell for inspiration)\n     col += 0.7*drawRingPlanet(r2d(1.1*PI)*(p + vec2( 0.0,-1.7)),TimeVar);\n     // Satellite 1\n     col += 0.5*clamp(sdCircle(p,0.10,vec2(1.700,2.50), 0.01) - sdCircle(p,0.10,vec2(1.705,2.51), 0.01),0.0,1.0);\n\n     // Add colors in atmo (better colors)\n     col *= 2.00;\n     col += vec4(1.0,1.0,0.0,1.0)*smoothstep(0.0,1.0,1.0-0.85*sqrt(p.y));\n     // Add low clouds on the horizon...\n     col += smoothstep(0.08,-0.04,abs(p.y - 0.45))*smoothstep(0.09,0.0,p.y-Clouds(p + vec2(50.0),TimeVar));\n\n     // Draw the main sun\n     col += vec4(1.0,0.9,0.7,1.0)*sdCircle(p,0.4,vec2(0.0,0.35),0.05);\n     // Draw the distant sun\n     col += metaDiamond(p,vec2( 0.0,0.80),0.02,0.0);\n\n     // Distant Mountains\n     col = mix(col,vec4(0.7,0.4,0.3,1.0),smoothstep(0.03,0.0,p.y - MountainsFar(p + vec2(400.0),TimeVar)));\n\n     // Draw Mountains and slanted shadows...\n     col = mix( col,\n                vec4(0.4,0.2,0.2,1.0)-0.05*smoothstep(0.00,0.1,p.y - MountainsTex(p + vec2(0.5*p.y,800.0),TimeVar)),\n                smoothstep(0.01,0.0,p.y - Mountains(p + vec2(400.0),TimeVar)));\n\n     // Draw Distant Jungle Line\n     col = mix(col,\n               vec4(0.2,0.3,0.2,1.0)*(0.5+0.5*texture(iChannel0,0.1*(p + vec2(0.05*TimeVar,0.0)))),\n               smoothstep(0.01,0.0,p.y - ThirdTreeLine(p + vec2(100.0),TimeVar)));\n\n     // Draw le Super Concorde\n     col = drawSpacePlane(p*1.4,col,TimeVar);\n\n     // Draw The Ten Thousand Shrines Of Yuk (*tribal screams of madness*)\n     col = drawShrines(p,col,TimeVar);\n\n     // Draw the Pylons of Yog-Sothoth (*louder tribal screams of madness*)\n     if(p.y<0.6)col = drawPylons(p,col,0.12*TimeVar);\n\n     // Draw Medium Jungle Line\n     col = mix(col,vec4(0.3,0.4,0.3,1.0)*(0.7+0.3*texture(iChannel0,1.0*(p + vec2(0.15*TimeVar,0.0)))),\n           smoothstep(0.008,0.0,p.y - SecondTreeLine(p + vec2(1.0),TimeVar)));\n\n     // Draw Front Jungle Line\n     col = mix(col,vec4(0.5,0.6,0.5,1.0)*(0.6+0.4*texture(iChannel0,4.0*(p + vec2(0.25*TimeVar,0.0)))),\n           smoothstep(0.008,0.0,p.y - FirstTreeLine(p + vec2(1.0),TimeVar)));\n\n     p *= 1.0/(1.0+0.2*AltiY);\n\n     col = drawArcadesOfYuk(p*(1.1+0.5*AltiY),col,TimeVar);\n\n     col -= 0.15*(1.0-Shadow);\n\n     p *= r2d(-1.0*TiltX);\n\n     // Texts\n\n     p = last_p*3.2;  // Re-init !\n\n     // \"Level\" tells which song sequence we are currently in\n     // Each sequence is divided into 2 parts : first one normal rendering, second one tactical imaging.\n     Level = int(floor(TimeVar/SeqLength));\n\n     // Tactical imaging sequences\n     if( mod(TimeVar,SeqLength) > SeqLength/2.0)\n     {\n         if( Level != 0 ) // Except for Title Screen...\n         {\n             // Print references for military archives...\n             Centrage = vec2(-0.602+0.028*last_p.x/2.0,0.4);\n             for( float i = 0.0; i < 43.0; i++ )\n                  col += 2.5*vec4(0.0,1.0,0.0,1.0)*traceChar(last_p*1.9,float(TxtIRView[int(i)]), Centrage + vec2(0.028*mod(i,43.0),0.5));\n         };\n\n         if(int(mod(TimeVar/SeqLength,2.0))>0)\n         {\n            // Yellow-Green Color (old night-vision color scheme)\n            col = vec4(0.4*col.g,0.6*col.g,0.0,1.0);\n         }else{\n            // Greyscale (cheap combat cameras)\n            col = 0.75*col.yyyy;\n         };\n\n         // EyeBlower / Interferences (\"The gas giant's magnetosphere makes everything worse !\")\n         col -= 0.005*(sin(80.0*length(p-vec2(0.5*sin(TimeVar),0.5*cos(TimeVar))) - 20.0*TimeVar) + sin(80.0*length(p-vec2(0.0,0.0)) - 20.0*TimeVar));\n         // Old LED Matrix Display\n         if(mod(fragCoord.y,4.0) > 2.0 && mod(fragCoord.x,4.0) > 2.0) col = clamp(col*2.5,0.0,1.0);\n\n         // Title logo BEYOND A COLDER WAR\n         if( Level == 0 || Level >= 7 )col = drawTitle(col,TimeVar);\n\n     }else{\n         // Color Keying for normal view... I went for a red-orange apocalyptic feel.\n         col *= vec4(1.0,0.7,0.5,1.0);\n     };\n\n     if( mod(TimeVar,SeqLength) < SeqLength/2.0)\n     {\n         if( Level >= 7 )col = drawTitle(col,TimeVar);\n\n         // Draw Comic Panel\n\n         // Getting text coords by sequence...\n         vec2 TxtSpan = vec2(0,0);\n         switch( Level )\n         {\n                 case 0 : TxtSpan = vec2(  0.0,  0.0);break;\n                 case 1 : TxtSpan = vec2(  0.0,238.0);break;\n                 case 2 : TxtSpan = vec2(239.0,423.0);break;\n                 case 3 : TxtSpan = vec2(424.0,594.0);break;\n                 case 4 : TxtSpan = vec2(595.0,774.0);break;\n                 case 5 : TxtSpan = vec2(  0.0,  0.0);break;\n                 case 6 : TxtSpan = vec2(  0.0,  0.0);break;\n                 case 7 : TxtSpan = vec2(775.0,860.0);break;\n         };\n         if( Level != 7 )\n         {\n             // Opening Texts\n             Centrage = vec2(0.0,-2.80);\n         }else{\n             // Ending Text\n             Centrage = vec2(0.0,-0.63);\n         };\n\n         if( (Level > 0 && Level < 5) || Level == 7)\n         {\n             // draw text panels\n             col = mix(col,vec4(0.0,0.0,0.0,1.0), 0.5*smoothstep(0.02,0.0,    sdBox(p + vec2(-0.05,Centrage.y + ((TxtSpan.y - TxtSpan.x)/50.0) * 0.0625/2.0 + 0.025 ), vec2( 60.0*0.028       , ((TxtSpan.y - TxtSpan.x)/50.0 + 1.0) * 0.0625))-0.005));\n             col = mix(col,vec4(1.0,1.0,0.9,1.0),     smoothstep(0.01,0.0,    sdBox(p + vec2( 0.00,Centrage.y + (TxtSpan.y - TxtSpan.x)/50.0 * 0.0625/2.0 - 0.05  ), vec2( 60.0*0.028       , ((TxtSpan.y - TxtSpan.x)/50.0 + 1.0) * 0.0625))-0.005));\n             col = mix(col,vec4(0.0,0.0,0.0,1.0),     smoothstep(0.01,0.0,abs(sdBox(p + vec2( 0.00,Centrage.y + (TxtSpan.y - TxtSpan.x)/50.0 * 0.0625/2.0 - 0.05  ), vec2( 60.0*0.028 - 0.01, ((TxtSpan.y - TxtSpan.x)/50.0 + 1.0) * 0.0625  -0.005)))));\n         };\n\n         // Draw Text in the Panel\n         // Once again, with hand-masking to speed things up a little bit...\n\n         vec4 AHC;\n         if( Level != 7 )\n         {\n             Centrage = vec2(0.0 - 56.0*0.028/2.0,-0.57);\n             AHC = vec4(-17.0*0.028,17.0*0.028,0.77,0.93);\n         }else{\n             Centrage = vec2(0.0 - 56.0*0.028/2.0, 0.61);\n             AHC = vec4(-17.0*0.028,17.0*0.028,0.15,0.25);\n         };\n         float LineHeight = 0.0;\n         float CurrentPos = 0.0;\n         int   CursorPos  = 0;\n         if( last_p.y > AHC[2] && last_p.y < AHC[3] && last_p.x > AHC[0] && last_p.x < AHC[1] )\n         {\n             for( float i = TxtSpan.x ; i < TxtSpan.y; i++ )\n             {\n                  if(TxtIntro[int(i)]!=32)col -= traceChar(last_p*1.7,float(TxtIntro[int(i)]), Centrage + vec2(CurrentPos ,0.0 + LineHeight));\n                  if( CursorPos > 50 && TxtIntro[int(i)]==32){ CurrentPos = 0.0; LineHeight += 0.05; CursorPos = 0; }else{ CursorPos += 1; CurrentPos += 0.028; };\n             };\n         };\n     };\n\n     // Resetting p\n     if( mod(TimeVar,SeqLength) > SeqLength/2.0) p = last_p * 3.2;\n\n     // Draw panel borders...\n     col = mix( col, vec4(1.0,1.0,0.9,1.0),smoothstep(0.00,0.01,    sdBox(p + vec2(0.0,-3.2/2.0),vec2(1.6*iResolution.x/iResolution.y - 0.07,1.6*1.0-0.07))));\n     col = mix( col, vec4(0.0,0.0,0.0,1.0),smoothstep(0.01,0.00,abs(sdBox(p + vec2(0.0,-3.2/2.0),vec2(1.6*iResolution.x/iResolution.y - 0.05,1.6*1.0-0.05)))));\n\n     // \"I have harnessed the shadows that stride from world to world to sow death and madness !\"\n     fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}