{"ver":"0.1","info":{"id":"cstcWB","date":"1695417385","viewed":208,"name":"Pixel Rain","username":"Domenic3000","description":"pixel rain","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["pixel","rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec2 p) {\n    return fract(sin(dot(p, vec2(256.315, 568.146)))*38554.14159);\n}\n\nvec3 getColorFromNoise(vec2 p) {\n    float r = noise(p + vec2(13.31, 57.87));\n    float g = noise(p + vec2(45.32, 98.21));\n    float b = noise(p + vec2(78.12, 23.54));\n    return vec3(r, g, b);\n}\n\nvec3 sampleGradient(float t) {\n    vec3 colorStart = vec3(1.000,0.000,0.000); // Example: light blue\n    vec3 colorEnd = vec3(0.067,0.000,1.000);   // Example: darker blue\n    return mix(colorStart, colorEnd, t);\n}\n\nfloat getBrightnessFromNoise(vec2 p) {\n    return mix(0.5, 1.5, noise(p + vec2(89.65, 41.23)));\n}\n\n// Helper function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Helper function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Adjust Brightness, Contrast, Hue, Saturation\nvec3 adjustBCSH(vec3 col, float brightness, float contrast, float hue, float saturation) {\n    // Adjust brightness\n    col = col + brightness;\n\n    // Adjust contrast\n    col = (col - 0.5) * contrast + 0.5;\n\n    // Convert to HSV for hue and saturation adjustments\n    vec3 hsv = rgb2hsv(col);\n\n    // Adjust hue\n    hsv.x = fract(hsv.x + hue);\n\n    // Adjust saturation\n    hsv.y *= saturation;\n\n    // Convert back to RGB\n    col = hsv2rgb(hsv);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y -=.5;\n    uv.y/=1.1;\n    uv.x*=1000.;\n    float t = iTime/50.;\n\n    vec2 fuv = floor(uv);\n    float bright = 0.9/getBrightnessFromNoise(fuv);\n    float wNoise = noise(fuv);\n    \n    float speedVariation = mix(0.5, 1.5, noise(fuv + vec2(12.34, 56.78))); // Different offsets to get a new noise value\n    wNoise -= t * speedVariation;\n    \n    vec2 sub = fract(uv - vec2(wNoise));\n    sub.y = .24 - sub.y;\n    float rain = sub.y;\n    float glow = smoothstep(.22, 1., rain)*50.;\n    rain = clamp(rain, 0., 1.);  \n    \n    float gradientFactor = fract(fuv.x * 1000.3); // Adjust the multiplier for gradient frequency\n    vec3 RrainColor = getColorFromNoise(fuv)*.2;\n    \n    vec3 rainColor = sampleGradient(gradientFactor);\n    rainColor = (rainColor + RrainColor)/2.;\n    \n    vec3 col = rain * rainColor * bright* 2.3;\n    \n    float thresholdForGlow = 1.5; // You can adjust this value to suit your needs\n    if (bright > thresholdForGlow) {\n        float glow = smoothstep(.22, 1., rain) * 50.;\n        col += glow * 6.;\n    }\n    \n    float brightness = 0.00;\n    float contrast = 1.10;\n    float hue = 1.0 - iTime/80.;\n    float saturation = 1.30;\n    \n    \n    col = adjustBCSH(col, brightness, contrast, hue, saturation);\n    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}