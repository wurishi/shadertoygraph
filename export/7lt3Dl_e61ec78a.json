{"ver":"0.1","info":{"id":"7lt3Dl","date":"1637723247","viewed":120,"name":"Path Tracing - Andrew","username":"andrew741","description":"Path tracing and global illumination. This has taken quite a while and I hope you enjoy it. If you have any suggestions then feel free to tell me. There are options for different scenes and render settings at the top of Common.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// the longer it runs the less noise\n// options for rendering in Common\n\n\n// functions for color grading\n\nvec3 RGBtoHSV(vec3 rgb)  // converts rgb to hsv (hue, saturation, value), used for saturation and HDR settings\n{\n    float h, s, v;\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n    float mx = max(r, max(g, b));\n    float mn = min(r, min(g, b));\n    float df = mx-mn;\n    if (mx == mn) h = 0.;\n    else if (mx == r) h = mod((60. * ((g - b) / df) + 360.), 360.);\n    else if (mx == g) h = mod((60. * ((b - r) / df) + 120.), 360.);\n    else if (mx == b) h = mod((60. * ((r - g) / df) + 240.), 360.);\n    if (mx == 0.) s = 0.;\n    else s = df / mx * 100.;\n    v = mx * 100.;\n    return vec3(h, s, v);\n}\n\nvec3 HSVtoRGB(vec3 hsv)  // converts hsv (hue, saturation, value) to rgb, used for saturation and HDR settings\n{\n    float H = hsv.x;\n    float S = hsv.y;\n    float V = hsv.z;\n    float s = S / 100.;\n    float v = V / 100.;\n    float C = s * v;\n    float X = C * (1. - abs(mod(H / 60., 2.) - 1.));\n    float m = v-C;\n    float r,g,b;\n    if(H >= 0. && H < 60.)\n    {\n        r = C;\n        g = X;\n        b = 0.;\n    }\n    else if(H >= 60. && H < 120.)\n    {\n        r = X;\n        g = C;\n        b = 0.;\n    }\n    else if(H >= 120. && H < 180.)\n    {\n        r = 0.;\n        g = C;\n        b = X;\n    }\n    else if(H >= 180. && H < 240.)\n    {\n        r = 0.;\n        g = X;\n        b = C;\n    }\n    else if(H >= 240. && H < 300.)\n    {\n        r = X;\n        g = 0.;\n        b = C;\n    }\n    else\n    {\n        r = C;\n        g = 0.;\n        b = X;\n    }\n    float R = r + m;\n    float G = g + m;\n    float B = b + m;\n    return vec3(R, G, B);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float gamma = texture(iChannel1, vec2(0)).r * 0.75 + 0.25;\n    \n    vec3 col = texture(iChannel2, uv).gba;  // texture(iChannel0, uv).rgb / texture(iChannel0, uv).a;// / max(texture(iChannel1, vec2(0)).r, 1.);\n    col = texture(iChannel0, uv).rgb / texture(iChannel0, uv).a;// / max(texture(iChannel1, vec2(0)).r, 1.);\n    \n    // tone mapping and exposure correction\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    float tms = TONE_MAPPING_STRENGTH;\n    col = pow(mix(col, clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.), tms), vec3(gamma));\n    \n    vec3 hsv = RGBtoHSV(col);\n#ifdef BOOST_SATURATION\n    hsv.g *= SATURATION;\n#endif\n    //\n#ifdef HDR\n    hsv.b = smoothstep(MIN_BRIGHTNESS, MAX_BRIGHTNESS, hsv.b) * BRIGHTNESS_RANGE;\n#endif\n    col = HSVtoRGB(hsv);\n    col *= TINT;\n    \n    //col = texture(iChannel0, uv).rgb / texture(iChannel0, uv).a;\n    \n    fragColor = vec4(col, 1.);\n#ifdef FALSE_COLOR\n    float v = RGBtoHSV(col).b * 0.01;\n    if (v <= 0.1)\n    {\n        color = vec4(mix(vec3(0., 0., 0.9), vec3(0., 0.9, 0.9), smoothstep(0., 0.1, v)), 1.);\n    }\n    else if (v < 0.4 && v > 0.1)\n    {\n        color = vec4(mix(vec3(0., 0.9, 0.9), vec3(0.5, 0.5, 0.5), smoothstep(0.1, 0.4, v)), 1.);\n    }\n    else if (v >= 0.4 && v <= 0.6)\n    {\n        fragColor = vec4(0.5);\n    }\n    else if (v > 0.6 && v < 0.9)\n    {\n        color = vec4(mix(vec3(0.5, 0.5, 0.5), vec3(0.9, 0.9, 0.), smoothstep(0.6, 0.9, v)), 1.);\n    }\n    else\n    {\n        color = vec4(mix(vec3(0.9, 0.9, 0.), vec3(0.9, 0.2, 0.2), smoothstep(0.9, 1., v)), 1.);\n    }\n    \n#endif\n    //fragColor = vec4(texture(iChannel2, uv).r);\n    }\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 Refract(vec3 I, vec3 N, float eta)\n{\n    vec3 R;\n    float k = 1. - eta * eta * (1. - dot(N, I) * dot(N, I));\n    if (k < 0.)\n        R = vec3(0.);\n    else\n        R = I * eta - N * (eta * dot(N, I) + sqrt(k));\n    return R;\n}\n\nvec3 Reflect(vec3 rd, vec3 normal)\n{\n    float dn = dot(rd, normal) * 2.;\n    return rd - normal * dn;\n}\n\n/*\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec2 random(float s)\n{\n    vec2 co = vec2(s, s+0.1);\n    vec2 p = co;\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    vec2 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\nvec2 random(vec2 co)\n{\n    vec2 p = co;\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    vec2 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\n\nvec2 hash2(float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n*/\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\nconst float PHI = 1.61803398874989484820459; // Φ = Golden Ratio \n\nfloat gold_noise(in vec2 xy, in float seed)  // huge credit to https://www.shadertoy.com/view/ltB3zD for this function, this has to be the best random number generator\n{\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n\nvec2 random2(vec2 xy)  // huge credit to https://www.shadertoy.com/view/ltB3zD for this function, this has to be the best random number generator\n{\n    return vec2(gold_noise(xy, fract(iTime)+1.0),\n            gold_noise(xy, fract(iTime)+2.0));\n}\n\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, vec2 rv2) {\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\n\n// a random function\nvec3 random(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n    return output_;\n}\n\n\n// for specular lighting\nfloat Specular(float smoothness, vec3 normal, vec3 rd)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    return exp(-specularExponent * specularExponent);\n}\n\n\nstruct RayOut\n{\n    vec3 col;\n    bool collided;\n};\n\n\nvec3 random3(vec3 co)\n{\n    float x = gold_noise(co.xz, co.y);\n    float y = gold_noise(co.xy, co.z);\n    float z = gold_noise(co.yz, co.x);\n    return vec3(x, y, z);\n}\n\n\n// casting a ray which bounces\nRayOut BounceRay(vec3 rd, vec3 ro, float pixel_id)\n{\n    vec3 finalColor = vec3(0.);\n    \n    float absorbed_light = 1.;\n    float absorbed_color = 1.;\n\n    vec3 p = ro;\n    vec3 dir = rd;\n    \n    bool collided = true;\n    \n    vec3 lastPos;\n    CollitionPoint shadow;\n    CollitionPoint lastHit;\n    CollitionPoint hitPoint;\n        \n    float total_added = 0.;\n    \n    int numSamples = 0;\n    int timesSampled = 0;\n    \n    float randomOdd;\n    float bounceChance;\n    \n    vec3 finalLight = vec3(1.);\n    float accumulated_light = 0.;\n    \n    float lastRandomOdd;\n    float lastBounceChance;\n    \n    float pdf = 1. / (2. * 3.14159);\n    \n    // bouncing the ray\n    for (int s = 0; s < BOUNCES; s++)\n    {\n        float nlight = 0.;\n        lastPos = p;\n        //lastHit = hitPoint;\n        lastHit = hitPoint;\n        hitPoint = CastRay(p, dir);\n        if (hitPoint.dst != 0.)\n        {\n            p = hitPoint.pos;\n            vec3 sun_direction = sun_dir + random3(vec3(iTime, pixel_id, numSamples)) * sun_size;  // softening the shadows\n        #ifdef scene1\n            //\n        #else\n            shadow = CastRay(p - dir * 0.001, sun_direction);\n            //nlight = max(dot(sun_dir, hitPoint.normal), 0.);// + Specular(hitPoint.roughness, hitPoint.normal, dir);\n            if (shadow.dst == 0. || shadow.dst > 9999999999.) nlight = 1.;\n        #endif\n            \n            lastRandomOdd = randomOdd;\n            lastBounceChance = bounceChance;\n            \n            vec2 distribution = random2(vec2(pixel_id + fract(float(numSamples) / float(BOUNCES) * 22536.24886520562699) * 234.12289656426, hitPoint.normal.x + hitPoint.normal.y + hitPoint.normal.z));\n            \n            float fresnelChance = fresnel(dir, hitPoint.normal, hitPoint.ior);\n            bounceChance = clamp(fresnelChance * smoothstep(1., 0., hitPoint.roughness) + (1. - hitPoint.roughness) * 0.35, 0., 1.);\n            randomOdd = gold_noise(vec2(pixel_id, float(numSamples)), iTime);\n            \n            if (hitPoint.ior == 0.) bounceChance = 0.;\n            if (hitPoint.roughness == 0.) bounceChance = 1.;\n            \n            /*\n            if (hitPoint.light > 0. && s == 0)\n            {\n                finalLight = hitPoint.col * (hitPoint.light + 1.);\n                finalColor = hitPoint.col * (hitPoint.light + 1.);\n                numSamples = BOUNCES - 1;\n                break;\n            }\n            */\n            \n            p -= dir * E;\n                        \n            if (hitPoint.transmissive)\n            {\n                float ior = CastRayThrough(p, dir).indexRefraction;\n\n                if (randomOdd < bounceChance)\n                {\n                    dir = Reflect(dir, hitPoint.normal);\n                    p += dir * (E * 2.);\n                }\n                else\n                {\n                    vec3 np = p + dir * E;\n                    vec3 ndir = Refract(dir, hitPoint.normal, 1. / ior);\n                    CollitionPointTransmissive collitionPointTransmissive = CastRayThrough(np, ndir);\n                    \n                    np += ndir * (collitionPointTransmissive.dstThrough - E);\n                    vec3 _ndir = Refract(ndir, -collitionPointTransmissive.normal, ior);\n                    if (dot(ndir, _ndir) == 0.)\n                    {\n                        p = np;\n                        dir = Reflect(ndir, -collitionPointTransmissive.normal);\n                        CollitionPointTransmissive collitionPointTransmissive = CastRayThrough(p, dir);\n                        p += dir * (collitionPointTransmissive.dstThrough + (E * 2.));\n                        dir = Refract(dir, -collitionPointTransmissive.normal, ior);\n                        p += dir * (E * 2.);\n                    }\n                    else\n                    {\n                        dir = _ndir;\n                        p = np + ndir * (E * 3.);\n                    }\n                }\n            }\n            \n            //if ((lastHit.ior == 0s. || lastRandomOdd >= lastBounceChance))\n            \n            else if (randomOdd < bounceChance && hitPoint.ior != 0.)\n            {\n                dir = Reflect(dir, hitPoint.normal);\n            }\n            else\n            {\n                dir = cosWeightedRandomHemisphereDirection(hitPoint.normal, distribution);\n            }\n            \n            if (!hitPoint.transmissive || (randomOdd < bounceChance && hitPoint.ior != 0.))\n            {\n                accumulated_light += hitPoint.light + nlight;\n                vec3 sky_color = mix(texture(iChannel1, dir).rgb, vec3(1., 0.9, 0.2) * 2. + texture(iChannel1, dir).rgb, smoothstep(0., 1., pow(max(dot(dir, sun_dir), 0.), 275.)));  // smoothstep(0., 1., pow(max(dot(dir, sun_dir), 0.), 275.))\n                float lightContribution = dot(dir, hitPoint.normal);  // cos(acos(dot(dir, hitPoint.normal) / (length(dir) * length(hitPoint.normal))));  (those two are the same, the other one is just simplified)\n                hitPoint.light = hitPoint.light / pdf;\n                vec3 light_p2 = nlight * dot(dir, sun_direction) * sky_color / pdf;\n                // cos theta (for light distribution based on the bounce) (its the same as dot(normal, dir) i think)\n                finalColor += hitPoint.col                  * lightContribution * absorbed_color * (1. - bounceChance) * hitPoint.roughness;  // * ((hitPoint.light * absorbed_light + 1.));\n                float scalar = 0.85;\n                finalLight *= hitPoint.col * (hitPoint.light + light_p2) * lightContribution * absorbed_light * (1. - bounceChance) * hitPoint.roughness + scalar;\n                absorbed_light *= clamp((1. - hitPoint.roughness + ((1. - bounceChance) * 0.5) * hitPoint.roughness), 0., 1.);\n                absorbed_color *= clamp((1. - hitPoint.roughness + ((1. - bounceChance) * 0.5) * hitPoint.roughness), 0., 1.);\n                //absorbed_light *= clamp(((1. - hitPoint.roughness) * 0.75 + 0.25 + (bounceChance * 0.5) / hitPoint.roughness), 0., 1.);\n                //absorbed_color *= clamp(((1. - hitPoint.roughness) * 0.75 + 0.25 + (bounceChance * 0.5) / hitPoint.roughness), 0., 1.);\n            }\n            else\n            {\n            #ifdef COLORED_CAUSTICS\n                finalLight *= hitPoint.col;\n            #endif\n                //\n            }\n            \n            if (max(absorbed_light, absorbed_color) < ABSORBTION_THRESHOLD) break;\n        }\n        else\n        {\n            if (s == 0) collided = false;\n            else if (!(max(absorbed_light, absorbed_color) < ABSORBTION_THRESHOLD))\n            {\n                vec3 sky_color = mix(texture(iChannel1, dir).rgb, vec3(1., 0.9, 0.2) * 2. + texture(iChannel1, dir).rgb, smoothstep(0., 1., pow(max(dot(dir, sun_dir), 0.), 275.)));  // smoothstep(0., 1., pow(max(dot(dir, sun_dir), 0.), 275.))\n                // the light contribution i think is the same as dot(sun, dir)\n                float lightContribution = dot(dir, hitPoint.normal);  // cos(acos(dot(dir, lastHit.normal) / (length(dir) * length(lastHit.normal))));\n                finalColor += sky_color * lightContribution * absorbed_color * 0.5;\n                finalLight += sky_color * lightContribution * absorbed_light * 0.5;  // max(dot(dir, sun_dir), 0.)\n                accumulated_light += length(sky_color);\n            }\n            break;\n        }\n        numSamples ++;\n    }\n\n    // idk if this is needed\n    if (accumulated_light == 0.) finalLight = vec3(0.);\n    \n    // finding the final color\n    if (!collided)\n    {\n        finalColor = mix(texture(iChannel1, dir).rgb, vec3(1., 0.9, 0.2) * 2. + texture(iChannel1, dir).rgb, smoothstep(0., 1., pow(max(dot(dir, sun_dir), 0.), 275.)));  // smoothstep(0., 1., pow(max(dot(dir, sun_dir), 0.), 275.))\n        finalColor = pow(finalColor, vec3(1. / (texture(iChannel3, vec2(0)).r * 0.75 + 0.25)));\n    }\n    else\n    {\n        finalColor *= finalLight;\n    }\n        \n    return RayOut(max(finalColor, 0.), collided);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    // setting up the camera\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 uv = ((fragCoord.xy + jitter) - iResolution.xy * 0.5) / iResolution.y * FOV;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 1, -1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n#ifdef scene3\n    ro = vec3(-1., 2., -3.);\n#endif\n    //\n#ifdef scene1\n    ro = vec3(0., 0.1, -0.4);\n#endif\n    //\n#ifdef scene2\n    ro = vec3(0., 0., 0.);\n#endif\n    //\n#ifdef scene4\n    ro = vec3(0., 1., 0.);\n#endif\n    //\n#ifdef scene5\n    ro = vec3(7.5, 5., 7.5);\n#endif\n\n    vec3 col = vec3(0.);\n\n    // taking multiple samples\n    int num_samps = int(clamp(texture(iChannel2, fragCoord.xy / iResolution.xy).r, MIN_SAMPLE_SCAlER, 1.) * MAX_SAMPLES_PP);\n    if (iTime < 0.25) num_samps = 0;\n    for (int samp = 0; samp < num_samps; samp++)\n    {\n        vec3 r = random(vec3(uv.x, uv.y, iTime));\n        RayOut ray = BounceRay(rd, ro, fract(r.x * 265.108723689612) * 125.21986432 + fract(r.y * 522.21457328754236) * 212.4348962352346 + fract(r.z * 245.2289368346) * 174.2398216053642 + fract(float(samp) * 337.2628617372345) * 162.2589624738456);\n        col += ray.col;\n        if (!ray.collided)\n        {\n            num_samps = 1;\n            break;\n        }\n    }\n    \n    // returning the final color\n    if (!(iMouse.z <= 0.))\n    {\n        fragColor = vec4(col, num_samps);\n    }\n    else\n    {\n        fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).rgb + col, texture(iChannel0, fragCoord.xy / iResolution.xy).a + float(num_samps));\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define PI 3.14159\n\n\n// returns the desntiy of the atmosphere (found on yt not my out but i did modify it)\nfloat Density(float dstToPlannet, float r, float fallOff)\n{\n    float density_fall_off = fallOff;\n    float h = dstToPlannet / r;\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// not my own again but i did heavily modify it\nfloat opticalDepth(vec3 ro, vec3 rd, float rayLength, float ps, float r, float fallOff)\n{\n    vec3 p = ro;\n    float step_size = rayLength / 36.;\n    vec3 v3_step_size = rd * step_size;\n    float odepth = 0.;\n    float ldense;\n    // stepping throught the atmosphere\n    for (int s = 0; s < 35; s++)\n    {\n        p += v3_step_size;\n        ldense = Density(length(p) - ps, r, fallOff);\n        odepth += ldense * step_size;\n    }\n    return odepth;\n}\n\n\n// From https://www.shadertoy.com/view/4sjBDG\nfloat numericalMieFit(float costh)\n{\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    float bestParams[10];\n    bestParams[0]=9.805233e-06;\n    bestParams[1]=-6.500000e+01;\n    bestParams[2]=-5.500000e+01;\n    bestParams[3]=8.194068e-01;\n    bestParams[4]=1.388198e-01;\n    bestParams[5]=-8.370334e+01;\n    bestParams[6]=7.810083e+00;\n    bestParams[7]=2.054747e-03;\n    bestParams[8]=2.600563e-02;\n    bestParams[9]=-4.552125e-12;\n    \n    float p1 = costh + bestParams[3];\n    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\n    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\n    return dot(expValues, expValWeight);\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame < 1)\n    {\n        // Ray direction as color\n        vec3 col = vec3(0.);\n\n        vec3 rd = rayDir;\n        vec3 ro = vec3(0., 3959. + 0.00113636, 0.);\n\n        float time = 3.;\n\n        vec2 dstAtmo = RaySphere(rd, ro, vec3(0.), 3959. + 30.);\n        float f = 500.;\n        float r = 3959. + 30.;\n\n        vec3 cp = ro + rd * dstAtmo.x;\n        vec3 exit = ro + rd * dstAtmo.x + rd * dstAtmo.y;\n        float dstThrough = length(exit - cp);\n        exit = ro + rd * (dstAtmo.x + dstAtmo.y);\n        float stepSizeF = dstThrough / 36.;\n        vec3 stepSize = rd * stepSizeF;\n\n        vec3 p = cp;\n\n        // the scattering coeficents\n        float scatteringStrength = 2.5;  // the amount of separation of the colors (create nice bands)\n        vec3 scatteringCoefficents = pow(vec3(400) / vec3(700, 530, 440), vec3(4.)) * scatteringStrength;  // finding the different scattering coefficents for different wavelengths of light (red, green, blue in this case)\n        \n        float a = acos(dot(rd, sun_dir)/(length(rd)*length(sun_dir)));\n        //float rayLeighPhase = 3. * (1. + pow(cos(a), 2.)) / (16. * PI);  // (3*(1+cos(a)^2))/16π\n        float mu = dot(rd, sun_dir);\n        float mumu = mu * mu;\n        float g = 0.8;\n        float gg = g * g;\n        float rayLeighPhase = 1. - (3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)));\n        \n        rayLeighPhase = numericalMieFit(dot(sun_dir, rd));\n        //3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n\n        // the density\n        float density;\n        // the distance to the sun\n        float sun_length;\n        // the transmittance\n        vec3 transmittance;\n        // the optical depths \n        float sunRayOpticalDepth;\n        float veiwRayOpticalDepth;\n        // the inscattered light\n        vec3 inScatteredLight = vec3(0.);\n        // stepping throught the atmosphere\n        for (float s = 0.; s < 35.; s++)\n        {\n            // (3*(1+cos(a)^2))/16π\n            // moving the ray\n            p += stepSize;\n            // finding the distance through the atmosphere in the direction of the sun\n            sun_length = RaySphere(sun_dir, p, vec3(0.), r).y;\n            // finding the optical depth for the view ray and sun ray\n            sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length, 3959., r, f) * 0.025;\n            veiwRayOpticalDepth = opticalDepth(p, -rd, stepSizeF * s, 3959., r, f) * 0.025;\n            // finding the transmittance\n            //fragColor = vec4(rayLeighPhase);\n            //break;\n            transmittance = exp(vec3(-(sunRayOpticalDepth + veiwRayOpticalDepth)) * scatteringCoefficents) * (rayLeighPhase * 0.5 + 0.5);  //  * rayLeighPhase\n            density = Density(length(p) - 3959., r, f);\n\n            // finding the amount of addition light\n            inScatteredLight += vec3(density) * transmittance * scatteringCoefficents * (stepSizeF * 0.075);\n        }\n        // adding the atmosphere to the color\n        col = col + inScatteredLight;\n\n    #ifdef scene5\n        col = vec3(0.);\n    #endif\n        fragColor = vec4((col),1.0);\n    }\n    else fragColor = texture(iChannel0, rayDir);\n}\n\n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define sun_dir normalize(vec3(sin(2.75), 1.5, cos(2.75)))  // if changed then you have to restart render (so iTime is 0.) otherwise the sky wont change\n\n#define scene1  // there are 5 scenes, you can chose any one of them (scene1, scene2, and scene3)\n\n// Preformance and Render Quality Settings (other than MAX_SAMPLES_PP all the values should be perfect overall for the best rendering)\n#define MIN_SAMPLE_SCAlER 3./8.  // (min_samples/MAX_SAMPLES is the lowest) 1 means off, the minimum amount of samples per pixel (MAX_SAMPLES_PP * value)\n#define MAX_SAMPLES_PP 8.  // the maximum samples per pixel, the heigher the better quality but also worse preformace (ussually is less due to adaptive sampling)\n#define BOUNCES 4  // the maximum bounces of a ray of light (more is slower but better looking)\n\n#define ABSORBTION_THRESHOLD 0.1  // The minimum amount of light that can exsist before the ray is deleted, lower is better looking but slower (at some point so much light has been absorbed that continuing to simulate the ray would have no effect)\n#define E 0.025  // 00000025 the amount a sample point is pushed away from a surface before testing for a new collition (too low or high creates errors)\n\n// Visual Effects (Requires restarting the render)\n#define sun_size 0.2  // scales the size of the softening of the suns shadows (0 = hard, >0.75 = way to soft)\n#define COLORED_CAUSTICS  // if defined the transmissive objects will be colored and so will their caustics (truer to reality but increases noise)\n#define FOV 3.25  // the feild of veiw (in no specific unit)\n\n// Saturation Settings\n#define BOOST_SATURATION  // if defined the saturation will be boosted by the number above\n#define SATURATION 1.75  // (1 is normal) the saturation of the colors\n\n// HDR settings\n#define HDR  // (dosent work well on scene5) if defined the HDR will be used\n#define MIN_BRIGHTNESS -15.  // the min brightness (the brightness level which represents zero)\n#define MAX_BRIGHTNESS 175.  // the max brightness (the brightness level which represents white)\n#define BRIGHTNESS_RANGE 130.  // the max brightness (on screen brightness)\n\n#define NO_ADAPTIVE_EXPOSURE  // (dosent work well on scene5) if defined gamma will be 1 (aka no the base color/gamma) gamma (can also be contrast)\n#define EXPOSURE 0.7  // the exposure if its not adaptive\n\n// Color Settings\n#define TONE_MAPPING_STRENGTH 1.  // the strength of the tone mapping\n#define TINT vec3(1.15, 1., 0.9)  // the tint of the colors (currently a warm tint)  // cool tint: vec3(0.8, 0.85, 1.)\n//#define FALSE_COLOR  // if defined it will show the false color (can be used to adjust the hdr to look better)\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// ray sphere function\nvec2 RaySphere(vec3 rd, vec3 ro, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\n// functions for collition with flat planes\nfloat RayPlaneZ(vec3 ro, vec3 dir, vec3 p, vec2 s)\n{\n    // front or back\n    float depth = (p.z - ro.z) / dir.z;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.xy + dir.xy * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n}\n\n\nfloat RayPlaneX(vec3 ro, vec3 dir, vec3 p, vec2 s)\n{\n    // left or right\n    float depth = (p.x - ro.x) / dir.x;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.yz + dir.yz * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n}\n\n\nfloat RayPlaneY(vec3 ro, vec3 dir, vec3 p, vec2 s)\n{\n    // top or bottom\n    float depth = (p.y - ro.y) / dir.y;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.xz + dir.xz * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n}\n\n\nfloat\nintersect_plane(\n    vec3 ro,\n    vec3 rd,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(rd, normal);\n    float t = dot(center - ro, normal) / denom;\n\treturn t > 0.0 ? t : 99999999999999999.;\n}\n\n\nvec2 RayBox(vec3 boundsMin, vec3 boundsMax, vec3 ro, vec3 rd)\n{\n    vec3 t0 = (boundsMin - ro) / rd;\n    vec3 t1 = (boundsMax - ro) / rd;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float dstA = max(max(tmin.x, tmin.y), tmin.z);\n    float dstB = min(tmax.x, min(tmax.y, tmax.z));\n    \n    float dstToBox = max(0., dstA);\n    float dstInsideBox = max(0., dstB - dstToBox);\n    return vec2(dstToBox, dstInsideBox);\n}\n\n\nfloat RayTriangle(vec3 P1, vec3 P2, vec3 P3, vec3 R1, vec3 R2)\n{\n    vec3 Normal = normalize(cross(P2 - P1, P3 - P1));\n\n    float Dist1 = dot(R1 - P1, Normal);\n    float Dist2 = dot(R2 - P1, Normal);\n\n    if (Dist1 * Dist2 >= 0.) return 99999999999999999.;\n\n    if (Dist1 == Dist2) return 99999999999999999.;\n\n    vec3 IntersectPos = R1 + (R2 - R1) * (-Dist1 / (Dist2 - Dist1));\n\n    vec3 vTest = cross(Normal, P2 - P1);\n    if (dot(vTest, IntersectPos - P1) < 0.) return 99999999999999999.;\n\n    vTest = cross(Normal, P3 - P2);\n    if (dot(vTest, IntersectPos - P2) < 0.) return 99999999999999999.;\n\n    vTest = cross(Normal, P1 - P3);\n    if (dot(vTest, IntersectPos - P1) < 0.) return 99999999999999999.;\n\n    return length(IntersectPos - R1);\n}\n\n\nvec3 TriangleNormal(vec3 vert1, vec3 vert2, vec3 vert3)\n{\n    vec3 line1 = vert2 - vert1;\n    vec3 line2 = vert3 - vert1;\n\n    vec3 normal;\n    normal.x = line1.y * line2.z - line1.z * line2.y;\n    normal.y = line1.z * line2.x - line1.x * line2.z;\n    normal.z = line1.x * line2.y - line1.y * line2.x;\n    return normal;\n}\n\n\n// the data for a point of collition\nstruct CollitionPoint\n{\n    vec3 pos, col, normal;\n    float dst, roughness, light, shadowScaler, ior;\n    int id;\n    bool transmissive;\n};\n\n\nstruct CollitionPointTransmissive\n{\n    float dstThrough, indexRefraction;\n    vec3 normal;\n};\n\n\nCollitionPointTransmissive CastRayThrough(vec3 ro, vec3 rd)\n{\n#ifdef scene1\n    vec2 dst1 = RaySphere(rd, ro, vec3(0.2, 0., 0.5), 0.15);\n    vec2 dst2 = RaySphere(rd, ro, vec3(0.35, 0.25, 0.), 0.15);\n    \n    float dst = min(dst1.x, dst2.x);\n    \n    float indexRef = -1.;\n    vec3 normal = vec3(0.);\n    \n    if (dst == dst1.x)\n    {\n        dst = dst1.y;\n        indexRef = 1.65;\n        vec2 d = RaySphere(rd, ro, vec3(0.2, 0., 0.5), 0.15);\n        normal = normalize((ro + rd * (d.x + d.y)) - vec3(0.2, 0., 0.5));\n    }\n    if (dst == dst2.x)\n    {\n        dst = dst2.y;\n        indexRef = 1.15;\n        vec2 d = RaySphere(rd, ro, vec3(0.35, 0.25, 0.), 0.15);\n        normal = normalize((ro + rd * (d.x + d.y)) - vec3(0.35, 0.25, 0.));\n    }\n    \n    return CollitionPointTransmissive(dst, indexRef, normal);\n#endif\n    //\n#ifdef scene2\n    float dst1 = RaySphere(rd, ro, vec3(-1.5, -0.2, -1.75), 0.75).y;\n    \n    float dst = dst1;\n    \n    float indexRef = -1.;\n    vec3 normal = vec3(0.);\n    \n    if (dst == dst1)\n    {\n        indexRef = 1.45;\n        vec2 d = RaySphere(rd, ro, vec3(-1.5, -0.2, -1.75), 0.75);\n        normal = normalize((ro + rd * (d.x + d.y)) - vec3(-1.5, -0.2, -1.75));\n    }\n\n    return CollitionPointTransmissive(dst, indexRef, normal);\n#endif\n    //\n#ifdef scene3\n    return CollitionPointTransmissive(0., 0., vec3(0.));\n#endif\n    //\n#ifdef scene4\n    return CollitionPointTransmissive(0., 0., vec3(0.));\n#endif\n    //\n#ifdef scene5\n    return CollitionPointTransmissive(0., 0., vec3(0.));\n#endif\n    //\n}\n\n\nfloat fresnel(vec3 rd, vec3 normal, float ior) \n{ \n    float cosi = dot(rd, normal); \n    float etai = 1.;\n    float etat = ior; \n    if (cosi > 0.)\n    {\n        float etai_ = etai;\n        etai = etat;\n        etat = etai_;\n    } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0., 1. - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.)\n    { \n        return 1.;\n    }\n    else\n    { \n        float cost = sqrt(max(0., 1. - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return (Rs * Rs + Rp * Rp) / 2.; \n    } \n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nvec3 BoxNormalSDF(vec3 p, vec3 box_pos, vec3 box_size)\n{\n\tfloat d = sdBox(p - box_pos, box_size);\n    vec2 e = vec2(0.00001, 0);\n    \n    vec3 normal = d - vec3(\n        sdBox((p - e.xyy) - box_pos, box_size),\n        sdBox((p - e.yxy) - box_pos, box_size),\n        sdBox((p - e.yyx) - box_pos, box_size));\n    \n    return normalize(normal);\n}\n\n\n\nvec3 BoxNormal(vec3 box_min, vec3 box_max, vec3 hitPoint)\n{\n    vec3 box_size = (box_max - box_min) * 0.5;\n    vec3 midPoint = box_min + box_size;\n    vec3 normal = BoxNormalSDF(hitPoint, midPoint, box_size);\n    return normal;\n}\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// finds the position where a given ray hits the scene\nCollitionPoint CastRay(vec3 ro, vec3 rd)\n{\n#ifdef scene1\n    float dst1 = intersect_plane(ro, rd, vec3(0., -0.5, 0.), vec3(0., 1., 0.));\n    float dst2 = intersect_plane(ro, rd, vec3(0., 0.5, 0.), vec3(0., -1., 0.));\n    float dst3 = RayPlaneY(ro, rd, vec3(0., 0.4, -0.), vec2(0.1));\n    float dst4 = intersect_plane(ro, rd, vec3(0.5, 0., 0.), vec3(-1, 0., 0.));\n    float dst5 = intersect_plane(ro, rd, vec3(-0.5, 0., 0.), vec3(1, 0., 0.));\n    float dst6 = RaySphere(rd, ro, vec3(0., 0., 0.05), 0.1).x;\n    float dst7 = intersect_plane(ro, rd, vec3(0., 0., -0.5), vec3(0., 0., 1));\n    float dst8 = RaySphere(rd, ro, vec3(0.2, 0., 0.5), 0.15).x;\n    vec2 dstB  = RayBox(vec3(-0.45, -2., -0.2), vec3(-0.2, -0.1, 0.), ro, rd);\n    vec2 dstB2 = RayBox(vec3(-0.45, 0.3, -0.4), vec3(-0.4, 0.35, 1.5), ro, rd);\n    vec2 dstB3 = RayBox(vec3(0.45, 0.375, -0.1), vec3(0.4, 0.425, 1.5), ro, rd);\n    float dst9  = (dstB.y == 0. ) ? 99999999999. : dstB.x ;\n    float dst10 = (dstB2.y == 0.) ? 99999999999. : dstB2.x;\n    float dst11 = RaySphere(rd, ro, vec3(0.35, 0.25, 0.), 0.15).x;\n    float dst12 = (dstB3.y == 0.) ? 99999999999. : dstB3.x;\n    \n    float dst = min(min(min(min(min(min(min(min(min(min(min(dst1, dst2), dst3), dst4), dst5), dst6), dst7), dst8), dst9), dst10), dst11), dst12);\n    \n    vec3 hitPoint = ro + rd * dst;\n    if (dst < 999999.)\n    {\n        float diffuse = 0.6;\n        if (dst == dst1 ) return CollitionPoint(hitPoint, vec3(0.2, 0.8, 0.2), vec3(0.,  1., 0.)  , dst, diffuse, 0., 0., 0., 0, false);\n        if (dst == dst2 ) return CollitionPoint(hitPoint, vec3(0.9, 0.2, 0.2), vec3(0., -1., 0.)  , dst, diffuse, 0., 0., 0., 1, false);\n        if (dst == dst3 ) return CollitionPoint(hitPoint, vec3(1., 0.95, 0.9)  , vec3(0., (rd.y > 0.) ? -1. : 1., 0.), dst, diffuse,(rd.y > 0.) ? 64. : 0., 1., 0., 2, false);\n        if (dst == dst4 ) return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.8), vec3(-1., 0., 0.)  , dst, diffuse, 0., 0., 0., 3, false);\n        if (dst == dst5 ) return CollitionPoint(hitPoint, vec3(0.2, 0.2, 0.8), vec3(1., 0., 0.)   , dst, diffuse, 0., 0., 1.45, 4, false);\n        if (dst == dst6 ) return CollitionPoint(hitPoint, vec3(0.8, 0.8, 0.2), normalize(hitPoint - vec3(0., 0., 0.05)), dst, 0.95, 0., 0., 0., 5, false);\n        if (dst == dst7 ) return CollitionPoint(hitPoint, vec3(0.8, 0.8, 0.2), vec3(0., 0., 1.)   , dst, diffuse, 0., 0., 1.45, 6, false);\n        if (dst == dst8 ) return CollitionPoint(hitPoint, vec3(0.9, 0.35, 0.35), normalize(hitPoint - vec3(0.2, 0., 0.5)), dst, 1., 0., 0., 1.65, 7, true);\n        if (dst == dst9 ) return CollitionPoint(hitPoint, vec3(0.8, 0.8, 0.8), BoxNormal(vec3(-0.45, -2., -0.2), vec3(-0.2, -0.1, 0.) , hitPoint), dst, 0.6, 0., 0., 1.45, 8, false);\n        if (dst == dst10) return CollitionPoint(hitPoint, vec3(0.95, 0.2, 0.95), BoxNormal(vec3(-0.45, 0.3, -0.4), vec3(-0.4, 0.35, 1.5), hitPoint), dst, 0.5, 2.5, 0., 0., 9, false);\n        if (dst == dst11) return CollitionPoint(hitPoint, vec3(0.35, 0.95, 0.35), normalize(hitPoint - vec3(0.35, 0.25, 0.)), dst, 1., 0., 0., 1.45, 10, true);\n        if (dst == dst12) return CollitionPoint(hitPoint, vec3(0.2, 0.95, 0.95), BoxNormal(vec3(0.45, 0.375, -0.1), vec3(0.4, 0.425, 1.5), hitPoint), dst, 0.5, 2.25, 0., 0., 11, false);\n    }\n    return CollitionPoint(vec3(0.), vec3(0.), vec3(0.), 0., 0., 0., 0., 0., -1, false);\n#endif\n    //\n#ifdef scene2\n    float dst1 = RayPlaneY(ro, rd, vec3(0., -1., 2.), vec2(4., 4.));\n    float dst2 = RayPlaneZ(ro, rd, vec3(0., -2., 2.), vec2(4., 4.));\n    float dst3 = RayPlaneX(ro, rd, vec3(-4., -2., 2.), vec2(6., 4.));\n    float dst4 = RayPlaneX(ro, rd, vec3(4., -2., 2.), vec2(6., 4.));\n    float dst5 = RayPlaneY(ro, rd, vec3(-4., 1., -2.), vec2(4., 4.));\n    float dst6 = RaySphere(rd, ro, vec3(0., -3959. - 2., 0.), 3959.).x;\n    float dst7 = 9999999999999999999999999999.;  // RaySphere(rd, ro, sun_dir * (147.5 * 100000.), 696000.).x;  // 9999999999999999999999999999.;\n    float dst8 = RaySphere(rd, ro, vec3(-1.5, -0.2, -1.75), 0.75).x;\n    \n    float dst = min(min(min(min(min(min(min(dst1, dst2), dst3), dst4), dst5), dst6), dst7), dst8);\n    \n    vec3 hitPoint = ro + rd * dst;\n    if (dst == dst1 && dst < 999999.)      return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.2), vec3(0., (rd.y < 0.) ? 1. : -1., 0.), dst, 0.75, 0., 0., 0., 0, false);\n    else if (dst == dst2 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.2, 0.8, 0.8), vec3(0., 0., (rd.z < 0.) ? 1. : -1.), dst, 0.95, 0., 0., 0., 1, false);\n    else if (dst == dst3 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.2, 0.8, 0.2), vec3((rd.x < 0.) ? 1. : -1., 0., 0.), dst, 0.9, 0., 0., 0., 2, false);\n    else if (dst == dst4 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.8), vec3((rd.x < 0.) ? 1. : -1., 0., 0.), dst, 0.7, 0., 0., 0., 3, false);\n    else if (dst == dst5 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.2, 0.2, 0.8), vec3(0., (rd.y < 0.) ? 1. : -1., 0.), dst, 0.89, 0., 0., 0., 4, false);\n    else if (dst == dst6 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.2, 0.8, 0.2), normalize(hitPoint - vec3(0., -3959. - 2., 0.)), dst, 0.6, 0., 0., 0., 5, false);\n    else if (dst == dst7 && dst < 999999999999999999999999999.) return CollitionPoint(hitPoint, vec3(1., 0.85, 0.2), normalize(hitPoint - sun_dir * (147.5 * 100000.)), dst, 1., 2250., 1., 0., 6, false);\n    else if (dst == dst8 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.8, 0.8, 0.2), normalize(hitPoint - vec3(-1.5, -0.2, -1.75)), dst, 0.25, 0., 0., 1.45, 7, false);\n    return CollitionPoint(vec3(0.), vec3(0.), vec3(0.), 0., 0., 0., 0., 0., -1, false);\n#endif\n    //\n#ifdef scene3\n    float dst1 = RaySphere(rd, ro, vec3(0, 0, 6), 2.).x;\n    float dst2 = RaySphere(rd, ro, vec3(0, -20, 0), 20.).x;\n    float dst3 = RayPlaneZ(ro, rd, vec3(1.6, 0.25, -2), vec2(1., 1.));\n    float dst4 = 9999999999999999999999999999.;  // RaySphere(rd, ro, sun_dir * (147.5 * 100000.), 696000.).x;\n    \n    float dst = min(min(min(dst1, dst2), dst3), dst4);\n    \n    vec3 hitPoint = ro + rd * dst;\n    if (dst == dst1 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.9, 0.1, 0.525), normalize(hitPoint - vec3(0,0,6)), dst, 0.75, 0., 0., 0., 0, false);\n    else if (dst == dst2 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.9, 0.1, 0.525), normalize(hitPoint - vec3(0,-20,0)), dst, 0.6, 0., 0., 0., 1, false);\n    else if (dst == dst3 && dst < 999999.) return CollitionPoint(hitPoint, vec3(0.9, 0.1, 0.525), vec3(0,0, (rd.z < 0.) ? 1. : -1.), dst, 0.6, 0., 0., 0., 2, false);\n    else if (dst == dst4 && dst < 999999999999999999999999999.) return CollitionPoint(hitPoint, vec3(1., 0.85, 0.2), normalize(hitPoint - sun_dir * (147.5 * 100000.)), dst, 1., 10000000000., 1., 0., 3, false);\n    return CollitionPoint(vec3(0.), vec3(0.), vec3(0.), 0., 0., 0., 0., 0., -1, false);\n#endif\n    //\n#ifdef scene4\n    vec2 box1  = RayBox(vec3(-2,-1,-3), vec3(2,0,1) , ro, rd);\n    vec2 box2  = RayBox(vec3(-3,0,-2) , vec3(-2,3,1), ro, rd);\n    vec2 box3  = RayBox(vec3(-2,0,1)  , vec3(2,1,2) , ro, rd);\n    vec2 box4  = RayBox(vec3(-2,2,1)  , vec3(2,3,2) , ro, rd);\n    vec2 box5  = RayBox(vec3(-2,1,1)  , vec3(-1,2,2), ro, rd);\n    vec2 box6  = RayBox(vec3(1,1,1)   , vec3(2,2,2) , ro, rd);\n    vec2 box7  = RayBox(vec3(3,0,-2)  , vec3(2,3,1) , ro, rd);\n    vec2 box8  = RayBox(vec3(-3,0,-2) , vec3(0,3,-3), ro, rd);\n    vec2 box9  = RayBox(vec3(1,0,-2)  , vec3(2,3,-3), ro, rd);\n    vec2 box10 = RayBox(vec3(-2,2,-2) , vec3(3,3,-3), ro, rd);\n    float dst1  = (box1.y  == 0.) ? 99999999999. : box1.x;\n    float dst2  = (box2.y  == 0.) ? 99999999999. : box2.x;\n    float dst3  = (box3.y  == 0.) ? 99999999999. : box3.x;\n    float dst4  = (box4.y  == 0.) ? 99999999999. : box4.x;\n    float dst5  = (box5.y  == 0.) ? 99999999999. : box5.x;\n    float dst6  = (box6.y  == 0.) ? 99999999999. : box6.x;\n    float dst7  = (box7.y  == 0.) ? 99999999999. : box7.x;\n    float dst8  = (box8.y  == 0.) ? 99999999999. : box8.x;\n    float dst9  = (box9.y  == 0.) ? 99999999999. : box9.x;\n    float dst10 = (box10.y == 0.) ? 99999999999. : box10.x;\n    \n    float dst = min(min(min(min(min(min(min(min(min(dst1, dst2), dst3), dst4), dst5), dst6), dst7), dst8), dst9), dst10);\n    vec3 hitPoint = ro + rd * dst;\n    \n    vec3 normal1  = BoxNormal(vec3(-2,-1,-3), vec3(2,0,1) , hitPoint);\n    vec3 normal2  = BoxNormal(vec3(-3,0,-2) , vec3(-2,3,1), hitPoint);\n    vec3 normal3  = BoxNormal(vec3(-2,0,1)  , vec3(2,1,2) , hitPoint);\n    vec3 normal4  = BoxNormal(vec3(-2,2,1)  , vec3(2,3,2) , hitPoint);\n    vec3 normal5  = BoxNormal(vec3(-2,1,1)  , vec3(-1,2,2), hitPoint);\n    vec3 normal6  = BoxNormal(vec3(1,1,1)   , vec3(2,2,2) , hitPoint);\n    vec3 normal7  = BoxNormal(vec3(3,0,-2)  , vec3(2,3,1) , hitPoint);\n    vec3 normal8  = BoxNormal(vec3(-3,0,-3) , vec3(0,3,-2), hitPoint);\n    vec3 normal9  = BoxNormal(vec3(1,0,-3)  , vec3(2,3,-2), hitPoint);\n    vec3 normal10 = BoxNormal(vec3(-2,2,-3) , vec3(3,3,-2), hitPoint);\n    \n    float diffuse = 0.5;\n    \n    if (dst < 999999.)\n    {\n        if (dst == dst1 ) return CollitionPoint(hitPoint, vec3(0.8, 0.8, 0.8), normal1 , dst, diffuse, 0., 0., 0., 1 , false);\n        if (dst == dst2 ) return CollitionPoint(hitPoint, vec3(0.2, 0.8, 0.2), normal2 , dst, diffuse, 0., 0., 0., 2 , false);\n        if (dst == dst3 ) return CollitionPoint(hitPoint, vec3(0.2, 0.2, 0.8), normal3 , dst, diffuse, 0., 0., 0., 3 , false);\n        if (dst == dst4 ) return CollitionPoint(hitPoint, vec3(0.2, 0.2, 0.8), normal4 , dst, diffuse, 0., 0., 0., 4 , false);\n        if (dst == dst5 ) return CollitionPoint(hitPoint, vec3(0.2, 0.2, 0.8), normal5 , dst, diffuse, 0., 0., 0., 5 , false);\n        if (dst == dst6 ) return CollitionPoint(hitPoint, vec3(0.2, 0.2, 0.8), normal6 , dst, diffuse, 0., 0., 0., 6 , false);\n        if (dst == dst7 ) return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.2), normal7 , dst, diffuse, 0., 0., 0., 7 , false);\n        if (dst == dst8 ) return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.2), normal8 , dst, diffuse, 0., 0., 0., 8 , false);\n        if (dst == dst9 ) return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.2), normal9 , dst, diffuse, 0., 0., 0., 9 , false);\n        if (dst == dst10) return CollitionPoint(hitPoint, vec3(0.8, 0.2, 0.2), normal10, dst, diffuse, 0., 0., 0., 10, false);\n    }\n    \n    return CollitionPoint(vec3(0.), vec3(0.), vec3(0.), 0., 0., 0., 0., 0., -1, false);\n#endif\n    //\n#ifdef scene5\n    vec3 pos0 = vec3(-1., 0., -1.5) * 1.;\n    vec3 pos1 = vec3(11., 6., -0.5) * 1.5;\n\n    float dst0 = RaySphere(rd, ro, pos0, 5.25).x;\n    float dst1 = RaySphere(rd, ro, pos1, 6.).x;\n\n    float dst = min(dst0, dst1);\n    vec3 hitPoint = ro + rd * dst;\n\n    vec3 normal0 = normalize(hitPoint - pos0);\n    vec3 normal1 = normalize(hitPoint - pos1);\n\n    if (dst < 99999999999.)\n    {\n        vec3 hitPoint2 = hitPoint * 0.6 - 15.;\n        float c = (noised(hitPoint2).r+noised(hitPoint2*2.+10.).r*0.5+noised(hitPoint2*4.-10.).r*0.25+noised(hitPoint2*8.+20.).r*0.125+noised(hitPoint2*16.-20.).r*0.0625) / 1.935;\n        c = c * 0.35 + 0.1;\n        hitPoint2 = hitPoint * 0.4 + 5.;\n        if(dst==dst0) return CollitionPoint(hitPoint,vec3(c) * (0.25+0.75*smoothstep(0.1, 0., 1./1.935*(noised(hitPoint2).r+noised(hitPoint2*2.+10.).r*0.5+noised(hitPoint2*4.-10.).r*0.25+noised(hitPoint2*8.+20.).r*0.125+noised(hitPoint2*16.-20.).r*0.0625))),normal0,dst,0.2,0.,0.,0.,0,false);\n        if(dst==dst1) return CollitionPoint(hitPoint,vec3(c) * (0.25+0.75*smoothstep(0.1, 0., 1./1.935*(noised(hitPoint2).r+noised(hitPoint2*2.+10.).r*0.5+noised(hitPoint2*4.-10.).r*0.25+noised(hitPoint2*8.+20.).r*0.125+noised(hitPoint2*16.-20.).r*0.0625))),normal1,dst,0.2,0.,0.,0.,1,false);\n    }\n    return CollitionPoint(vec3(0.),vec3(0.),vec3(0.),0.,0.,0.,0.,0.,-1,false);\n#endif\n    //\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x < 2. && fragCoord.y < 2.)\n    {\n        float gamma = 0.;\n        float steps = 32.;\n        float max_bright = 0.;\n        float step_size = 1. / steps;\n        for (float x = 0.; x < 1.; x += step_size)\n        {\n            for (float y = 0.; y < 1.; y += step_size)\n            {\n                vec3 pixelColor = texture(iChannel0, vec2(x, y)).rgb / texture(iChannel0, vec2(x, y)).a;\n                float l = length(clamp(pixelColor, 0., 10.));\n                gamma += l;\n                max_bright = max(l, max_bright);\n            }\n        }\n        gamma /= steps * steps;\n    #ifdef NO_ADAPTIVE_EXPOSURE\n        gamma = EXPOSURE;\n    #endif\n        fragColor = vec4(gamma, gamma, gamma, mix(max_bright, gamma, 0.1));\n    }\n    else fragColor = vec4(0.);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// adaptive sampling (more noisy rejoins get more rays and less noisy rejoins get less to render the scene quicker)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 image_uv = fragCoord/iResolution.xy;\n\n    float id = texture(iChannel1, image_uv).a;\n\n    // finding the average over a very small area\n    float v = 0.0015;\n    float s = 0.0005;\n    float sampled = 0.;\n    vec3 average = vec3(0.);\n    for (float x = -v; x < v; x+=s)\n    {\n        for (float y = -v; y < v; y+=s)\n        {\n            if (texture(iChannel1, image_uv + vec2(x, y)).a == id)\n            {\n                float scalar = smoothstep(1., 0., length(vec2(x,y)/v));\n                average += texture(iChannel0, image_uv + vec2(x, y)).rgb / texture(iChannel0, image_uv + vec2(x, y)).a * scalar;\n                sampled += scalar;\n            }\n        }\n    }\n\n    average /= sampled;\n\n    // comparing the average to the origonal color (non noisy surfaces should be very similar except on edges of surfaces or shadows)\n    // exctra rays being cast at the edge of an object wont cause any errors\n    float noise = length(texture(iChannel0, image_uv).rgb / texture(iChannel0, image_uv).a - average);  // 0 means its noisy and 1 means clean\n    noise = pow(noise, 0.45);\n\n    // bright areas tend to be less noisy compared to darker ones and this is also being acounted for\n    float noise_scalar = noise;//(noise + 0.4 * (pow(smoothstep(1., 0., length(texture(iChannel0, image_uv).rgb / texture(iChannel0, image_uv).a)), 10.)));\n    \n    fragColor = vec4(clamp(noise_scalar, 0., 1.), average.x, average.y, average.z);\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// keeps the id of each object in the scene for the adaptive sampling and gamma\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setting up the camera\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * FOV;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 1, -1) * 10.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n#ifdef scene3\n    ro = vec3(-1., 2., -3.);\n#endif\n    //\n#ifdef scene1\n    ro = vec3(0., 0.1, -0.4);\n#endif\n    //\n#ifdef scene2\n    ro = vec3(0., 0., 0.);\n#endif\n    //\n#ifdef scene4\n    ro = vec3(0., 1., 0.);\n#endif\n    //\n#ifdef scene5\n    ro = vec3(7.5, 5., 7.5);\n#endif\n    int id = 0;//CastRay(ro, rd).id;\n    \n    fragColor = vec4(id);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}