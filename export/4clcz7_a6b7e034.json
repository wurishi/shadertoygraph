{"ver":"0.1","info":{"id":"4clcz7","date":"1720959052","viewed":53,"name":"Stellar Marching","username":"filmotion","description":"Authors : Marceau Cottrez - Gabriel BARDINET\ncloud function origin : https://www.shadertoy.com/view/cljXWV","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 70\n#define STAR_RANGE 0.05\n#define VELOCITY 0.025\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\n\nfloat hash(vec3 p) {\n    p = fract(p * vec3(.1031, .11369, .13787));\n    p += dot(p, p.yzx + 19.19);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec3 random_star_position(vec3 ind) {\n    return vec3(\n        hash(ind * 1.23 + vec3(1.11, 3.67, 4.6)), \n        hash(ind * 1.45 + vec3(12.21, 65.15, 123.47)), \n        hash(ind * 1.67 + vec3(0.1, 0.2, 0.3))\n    ) * STAR_RANGE;\n}\n\nvec3 absolute_star_position(vec3 ind) {\n    return random_star_position(ind) + ind * vec3(STAR_RANGE);\n}\n\nfloat find_nearest_star_distance(out vec3 nearestStar, vec3 position) {\n    vec3 initialGrid = floor(position / vec3(STAR_RANGE));\n    float star_dist = 1e10;\n\n    for (int x = -1; x <= 1; x++) {\n         for (int y = -1; y <= 1; y++) {\n             for (int z = -1; z <= 1; z++) {\n                vec3 ind = initialGrid + vec3(x, y, z);\n                float dist = distance(absolute_star_position(ind), position);\n                if (dist < star_dist) {\n                    nearestStar = ind;\n                    star_dist = dist;\n                }\n            }\n        }\n    }\n\n    return star_dist;\n}\n\nvec3 star_color(in vec3 ind) {\n    float hue = hash(ind);  // generate hue value in the range [0, 1]\n    vec3 col;\n    if (hue < 0.5) {\n        // Orange hues\n        col = vec3(1.0, hue * 2.0, 0.0);\n    } else {\n        // Blue hues\n        col = vec3(0.0, (1.0 - hue) * 2.0, 1.0);\n    }\n    return col;\n}\n\nvec3 ray_dir(vec2 size, vec2 pos) {\n    vec2 xy = pos - size * 0.5;\n    float cot_half_fov = tan(radians(90.0 - 45.0 * 0.5));\n    float z = size.y * 0.5 * cot_half_fov;\n    return normalize(vec3(xy, -z));\n}\n\n// Dust effect\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec3 l = vec3(1.0);\n\nvec2 cloud(in vec3 p) {\n    float s = 4.0, e, f, o;\n    for (e = p.y / 2.0 - 0.8, f = -0.5; s < 4e2; s *= 1.6)\n        p.xz *= rot(1.0),\n        e += abs(dot(sin(p * s) / s, l)),\n        f += abs(dot(sin(p * s * 0.5) / s, l));\n    o = 1.0 + (f > 0.1? e : -exp(-f * f));\n    return vec2(max(o, 0.0), min(f, max(e, 0.000001)));\n}\n\n\n\nvec3 march(vec3 eye, vec3 dir, float time) {\n    vec3 col = vec3(0.0);\n    vec3 dust_col = vec3(0.0);\n    float t = 0.0;\n    float dt = 0.035;\n\n    for (int i = 0; i < MAX_STEP; i++) {\n        // Compute the distance to the nearest star\n        vec3 ind0;\n        float d = find_nearest_star_distance(ind0, eye + t * dir);\n        t += d;\n\n        // Break if t exceeds the threshold\n        if (t >= 4.) break;\n\n        // Calculate light contribution from the star\n        float l = 1.0 / (10000. * d);\n        l *= pow(1.1, -l * 1.0);\n        col += clamp(vec3(l), 0.0, 1.0) * star_color(ind0);\n\n        vec2 v = cloud(eye + t * dir);\n        float c = v.x;\n        float f = v.y;\n\n        // Update time step\n        t += dt * 1. * f;\n        dt *= 1.035;\n\n        // Accumulate dust color\n        dust_col = 0.99 * dust_col + 0.05 * vec3(c * c * c, c * c, c);\n    }\n\n    // Apply logarithmic scaling and clamp the dust color\n    dust_col = 0.5 * (log(-1.0 + dust_col));\n    dust_col = clamp(dust_col, 0.0, 1.0);\n\n    // Blend the dust effect with the star color\n    col += dust_col * 0.8;\n\n    return col;\n}\n\nmat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}\nvoid Camera(in vec2 fragCoord, out vec3 rd) \n{\n    vec2 m = load(ivec2(1,1)).xy/iResolution.x;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    rd = CameraRotation(m) * rd;\n}\n\n\n// Main image function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    float sensitivity = 0.9;\n    vec3 dir;\n    Camera(fragCoord, dir);\n    vec3 eye = vec3(0., 0., -iTime * VELOCITY);\n    vec3 col = march(eye, dir, iTime);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n\n    fragColor = load(fragCoord);\n\n    if (iTime == 0.0 || iFrame == 0) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        return;\n    }\n\n    vec2 pm = load(PMOUSE).xy;\n    vec3 vm = load(VMOUSE).xyz;\n\n    if (iMouse.z > 0.0) {\n        store(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n    } else if (vm.z != 0.0) {\n        store(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}