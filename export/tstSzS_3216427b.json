{"ver":"0.1","info":{"id":"tstSzS","date":"1572307844","viewed":80,"name":"Totally Ported Well","username":"copperTones","description":"i've done a raymarcher in unity, but i can't just copy-paste-change, b/c it spans across several files, and most of that would be redundant.\nuse wasd, shift, space, and mouse to control.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["test","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define arb_mirror(x, n) (x - 2.*n*min(dot(x, n), 0.))\n\n#define MARCH_itr 200\n#define MARCH_eps 1e-4\n#define MARCH_maxl 1e1\n#define MARCH_norm vec3(MARCH_eps, MARCH_maxl, MARCH_itr).xyyz\n\nvec3 CAM_pos = vec3(0, 2, -5);\nmat3 CAM_mat = mat3(0);\n#define CAM_zoom 2.\n\n#define COLOR_method 1//set 0-2\n\n\nstruct Ray {\n\tvec3 pos;\n\tvec3 vel;\n};\nRay Perspective(vec2 uv) {//mostly ripped from my own unity code\n\tRay result;\n\tresult.pos = CAM_pos;\n\tresult.vel = normalize(vec3(uv, CAM_zoom));\n\tresult.vel = CAM_mat * result.vel;\n\treturn result;\n}\nRay Orthographic(vec2 uv) {\n\tRay result;\n\tresult.pos = vec3(uv*CAM_zoom, 0.) + CAM_pos;\n\tresult.vel = vec3(0, 0, 1);\n\tresult.vel = CAM_mat * result.vel;\n\treturn result;\n}\n\nfloat DistF(vec3 pos) {\n    vec3 qos = floor(pos/5.)*10.;\n    pos = mod(pos, 5.)-2.5;\n    vec3 bp = abs(pos-.5);\n    float s = length(pos+.5) - 1.,\n        b = max(max(bp.x, bp.y), bp.z) - 1.;\n\treturn min(min(s,b), 1.);//easy 'take out mod() artifacts'\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord - iResolution.xy/2.;\n    uv *= 2./R;//scale by x\n    \n    CAM_pos = buf(0.).xyz;\n    CAM_mat = euler(buf(1.).xyz);\n    \n    \n    Ray ray = Perspective(uv);\n    vec4 dist = vec4(1, 0, MARCH_maxl, 0);//dist, total, min, steps\n    for (int i = 0; i < MARCH_itr && dist.x > MARCH_eps && dist.y < MARCH_maxl; i++) {\n    \tdist.x = DistF(ray.pos);\n        dist.y += dist.x;\n        dist.z = min(dist.x, dist.z);\n        dist.w++;\n        \n        ray.pos += dist.x*ray.vel;\n    }\n    dist /= MARCH_norm;\n    dist.y = min(dist.y, 1.);//removes sky artifacts\n    \n    \n\t#if COLOR_method == 0\n    #define sky vec3(.1, .1, .2)\n\tif (dist.x < 1.)//hit\n        color.xyz = mix(vec3(1.), sky, dist.y);\n    else\n        color.xyz = sky;\n    vec4 t = texture(iChannel0, coord/R/10.);\n    color = mix(color, 5.*abs(t), .2);\n    \n    #elif COLOR_method == 1\n    color.xyz = mix(\n        mix(vec3(.1, 0, .1), vec3(1, 1, 0), dist.w),\n        mix(vec3(1, 0, 0), vec3(0, 0, 1), dist.w),\n        pow(.01, dist.y));\n    \n    #elif COLOR_method == 2\n    float glow = min(1./dist.w, 1.);\n    color.xyz = dist.w<.15?\n        mix(vec3(1, 1, 1), vec3(.95, .9, .5), dist.y):\n    \tvec3(.1, .1, .15);\n    #endif\n    //color = vec4(uv, 0, 1);\n    //color = dist.yzwx;\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nyes... i know... \ni shouldn't be relting on the gpu\nto store/write variables on textures.\ni just couldn't resist trying\n*/\n#define key(k) texelFetch(iChannel1, ivec2(k, 0), 0).x\n#define MOV_speed 5.\nvec2 mouse() {\n    vec2 m = iMouse.xy - iResolution.xy/2.;//center\n    m.x *= pi*2./iResolution.x;\n    m.y *= -pi/iResolution.y;\n    return m;\n}\nvec3 keys() {\n\treturn MOV_speed*vec3(//ascii keys\n        key(0x44) - key(0x41),//d, a\n        key(0x20) - key(0x10),//space, shift\n        key(0x57) - key(0x53));//w, s\n}\n\nvoid mainImage(out vec4 vars, vec2 coord) {\n    float pos   = coord.x==0.5? 1.: 0.;\n    float euler = coord.x==1.5? 1.: 0.;//used to calc mat\n    \n    vec3 mov = rotY(mouse().x)*keys();\n    \n    vars = vec4(0);\n    vars.xyz += pos*  (buf(0).xyz + iTimeDelta*mov);\n    vars.xyz += euler*vec3(mouse().yx, 0);//(buf(1).xyz + iTimeDelta*vec3(.1));\n}\n\n//vec3(0, 2, -5)\n//vec3(pi/12., iTime, 0)","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.1416\n#define R iResolution.x//normalize axis\n#define buf(x) texelFetch(iChannel0, ivec2(x), 0)\n\nmat3 rotX(float a) {\n\treturn mat3(1, 0, 0,\n               0, cos(a), sin(a),\n               0, -sin(a), cos(a));\n}\nmat3 rotY(float a) {\n    mat3 x = rotX(a);\n\treturn mat3(x[2].zxy, x[0].zxy, x[1].zxy);\n}\nmat3 rotZ(float a) {\n    mat3 x = rotX(a);\n\treturn mat3(x[1].yzx, x[2].yzx, x[0].yzx);\n}\nmat3 euler(vec3 ang) {\n\treturn rotY(ang.y) * rotX(ang.x) * rotZ(ang.z);\n}","name":"Common","description":"","type":"common"}]}