{"ver":"0.1","info":{"id":"43ffWr","date":"1728319643","viewed":9,"name":"cloud split","username":"secondthumb","description":"cloud split","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cloud Cubes Moving Across the Sky Shader\n\n// Author: [Your Name]\n// Description: The sky is filled with multiple cloud cubes with space between them.\n// Each cube lazily floats across the scene from one side to the other.\n\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DIST 0.01\n\n// Improved hash function for noise\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + vec3(0.1, 0.2, 0.3));\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// Gradient noise function\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Compute gradients\n    float n000 = hash(i + vec3(0.0, 0.0, 0.0));\n    float n100 = hash(i + vec3(1.0, 0.0, 0.0));\n    float n010 = hash(i + vec3(0.0, 1.0, 0.0));\n    float n110 = hash(i + vec3(1.0, 1.0, 0.0));\n    float n001 = hash(i + vec3(0.0, 0.0, 1.0));\n    float n101 = hash(i + vec3(1.0, 0.0, 1.0));\n    float n011 = hash(i + vec3(0.0, 1.0, 1.0));\n    float n111 = hash(i + vec3(1.0, 1.0, 1.0));\n\n    // Smooth interpolation\n    vec3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n    float n00 = mix(n000, n100, u.x);\n    float n10 = mix(n010, n110, u.x);\n    float n01 = mix(n001, n101, u.x);\n    float n11 = mix(n011, n111, u.x);\n\n    float n0 = mix(n00, n10, u.y);\n    float n1 = mix(n01, n11, u.y);\n\n    return mix(n0, n1, u.z);\n}\n\n// Fractal Brownian Motion with improved parameters\nfloat fbm(vec3 p) {\n    float total = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    for(int i = 0; i < 6; i++) {\n        total += amplitude * noise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n// Cloud density function with multiple cubes moving across the scene\nfloat cloudDensity(vec3 p) {\n    // Parameters\n    float cubeSpacing = 10.0;  // Spacing between cubes\n    float cubeSize = 2.0;      // Half-size of the cube\n    float movementSpeed = 0.5; // Movement speed of the cubes\n    float sceneWidth = cubeSpacing * 6.0; // Width of the scene in x-direction\n\n    // Compute grid coordinates (cell indices)\n    vec3 cell = floor(vec3(p.x, p.y, p.z) / cubeSpacing);\n\n    // Random offset per cube to create variation in movement direction\n    float cellRandom = hash(cell);\n\n    // Determine movement direction (e.g., along the x-axis)\n    vec3 movementDir = vec3(1.0, 0.0, 0.0); // Move along x-axis\n\n    // Initial cube position\n    vec3 cubePos = cell * cubeSpacing;\n\n    // Apply movement to the cube position\n    cubePos += movementDir * (iTime * movementSpeed + cellRandom * cubeSpacing * 6.0);\n\n    // Wrap around when cube moves beyond scene bounds\n    cubePos = mod(cubePos - movementDir * (sceneWidth / 2.0), movementDir * sceneWidth) + movementDir * (-sceneWidth / 2.0);\n\n    // Compute local position within the cube\n    vec3 localPos = p - cubePos;\n\n    // Define cube boundaries with rounded edges\n    vec3 q = abs(localPos) - vec3(cubeSize);\n    float cube = length(max(q, 0.0)) - 0.3;\n    if (cube > 0.5) return 0.0;\n\n    // Apply noise to create cloud texture\n    float n = fbm(localPos * 2.0 + vec3(0.0, iTime * 0.3, 0.0));\n    float density = smoothstep(0.5, 0.7, n);\n\n    return density;\n}\n\n// Sun function for the background\nvec3 sunDirection = normalize(vec3(-0.5, 0.5, -1.0));\n\nfloat sun(vec3 rd) {\n    float sunIntensity = max(dot(rd, sunDirection), 0.0);\n    return pow(sunIntensity, 500.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Adjust aspect ratio\n\n    // Camera setup\n    vec3 camPos = vec3(0.0, 2.0, -20.0);\n    vec3 camTarget = vec3(0.0, 2.0, 0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camDir, camUp));\n    camUp = cross(camRight, camDir);\n\n    // Ray direction\n    vec3 rayDir = normalize(uv.x * camRight + uv.y * camUp + camDir);\n\n    // Background color with gradient sky\n    vec3 bgColor = mix(vec3(0.8, 0.9, 1.0), vec3(0.4, 0.7, 1.0), rayDir.y * 0.5 + 0.5);\n\n    // Add sun glow\n    float sunGlow = sun(rayDir);\n    bgColor += vec3(1.0, 0.9, 0.8) * sunGlow;\n\n    // Initialize color\n    vec3 col = bgColor;\n\n    // Raymarching parameters\n    float t = 0.0;\n\n    // Volumetric rendering\n    const float dt = 0.1;\n    float transmittance = 1.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n        if(t > MAX_DISTANCE || transmittance < 0.01) break;\n\n        vec3 pos = camPos + t * rayDir;\n\n        // Sample cloud density\n        float dens = cloudDensity(pos);\n\n        if(dens > 0.0) {\n            // Simple lighting\n            float light = clamp(dot(normalize(sunDirection), vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n            vec3 cloudColor = mix(vec3(1.0), vec3(1.0, 0.9, 0.8), light);\n\n            // Accumulate color with transmittance\n            float alpha = dens * 0.1;\n            alpha *= transmittance;\n            col = mix(col, cloudColor, alpha);\n            transmittance *= (1.0 - alpha);\n        }\n\n        t += dt;\n    }\n\n    // Tone mapping\n    col = pow(col, vec3(0.4545)); // Gamma correction\n\n    // Output color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}