{"ver":"0.1","info":{"id":"MscBzs","date":"1526341450","viewed":488,"name":"Outline #2: Scenes in a cube","username":"lsdlive","description":"This was my shader for the shader showdown at Outline demoparty 2018 for the final.\nShader showdown is a live-coding competition where two participants are facing each other during 25 minutes.\n\nI'm now qualified for the shader showdown revision 2019 :-)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","cube","livecoding","demoparty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @lsdlive\n\n// This was my second shader for the shader showdown at Outline demoparty 2018 in Nederland.\n// Shader showdown is a live-coding competition where two participants are\n// facing each other during 25 minutes.\n\n// I don't have access to the code I typed at the event,\n// so the code is NOT exactly the same. See below to get more information.\n\n// The idea was a simple cube on which I texture mapped other sphere-traced scenes.\n// There is only two scenes, but as I was updating the scenes at the same time\n// & changing the rotation during the 25 minutes, it gives the illusion\n// there was more than 2 scenes.\n// I kept everything black & white, because I didn't have time to add colours.\n// I wish I would have worked harder on this & deliver a more polished version,\n// but it was prepared the same day before the event, and I wanted to do this for the event.\n\n// Thanks to the organizers of the Outline demoparty!\n// Thanks to the shadertoy community & greets to the shader showdown paris gang!\n\n// This is under CC-BY-NC-SA (shadertoy default licence).\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\n// mercury's hglib\nvoid amod(inout vec2 p, float m) {\n\tfloat a = re(atan(p.x, p.y), m);\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\n// mercury's hglib\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x)p = p.yx;\n}\n\n// signed cross\n// https://iquilezles.org/articles/menger\nfloat sc(vec3 p, float d) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - d;\n}\n\n// signed box\n// https://iquilezles.org/articles/distfunctions\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nvoid transf(inout vec3 p) {\n\tfloat t = iTime * 7.;\n\tfloat s = t * .1 + sin(t)*.1;\n\tp.xz *= r2d(.77 + s * 2.5);\n\tp.xy *= r2d(.77 + s * 2.5);\n}\n\n// Main scene\n// The rotating cube\nfloat de(vec3 p) {\n\ttransf(p);\n\treturn box(p, vec3(1));\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0005, 0);\n\treturn normalize(vec3(\n\t\tde(p + e.xyy) - de(p - e.xyy),\n\t\tde(p + e.yxy) - de(p - e.yxy),\n\t\tde(p + e.yyx) - de(p - e.yyx)\n\t));\n}\n\n// First sphere-traced scene mapped on the cube.\n// This is not what it was on stage, it was improvisation,\n// so, it's impossible to me to remember the parameters.\n// This was a signed cross with amod/mo layers.\nfloat de2(vec3 p) {\n\t//p.xz*=r2d(iTime);\n\tp.xy*=r2d(iTime);\n\tp.z = re(p.z, 2.);\n\n\t//mo(p.xy, vec2(1, 2));\n\tamod(p.xy, .785);\n\tmo(p.xy, vec2(2.5, 1));\n\tp.x = abs(p.x) - 2.;\n\tp.xy *= r2d(3.14*.25);\n\n\treturn sc(p, .2);\n}\n\n// At some point during the live-coding session,\n// the 2nd scene was something like this:\n/*\nfloat de3(vec3 p){\np.xz*=r2d(iTime);\namod(p.xy,.785);\nmo(p.xz, vec2(.4, .2));\nreturn dot(p,normalize(sign(p)))-1.;\n}\n\nvec3 tex3(vec2 uv){\nvec3 ro=vec3(0,0,-4);\nvec3 rd=normalize(vec3(uv,1));\n\nfloat t=0.,i=0.;\nvec3 p;\nfor(;i<1.;i+=.01){\np=ro+rd*t;\nfloat d=de3(p);\nif(d<.001)break;\nt+=d;\n}\n\nvec3 c=vec3(i)*(1.-length(pow(uv, vec2(3.) )));\nreturn c;\n}\n*/\n\n\n\n// Second sphere-traced scene mapped on the cube.\n// This is not what it was on stage, it was kind of an improvisation,\n// I tried to do something similar to one of my previous shader:\n// https://www.shadertoy.com/view/4ddfDr\n// but I struggled hard on stage with the stress & time limit,\n// so I did a less intersting stuff at the event.\nfloat g3 = 0.;\nfloat de3(vec3 p) {\n\n\tp.xy *= r2d(iTime*.3);\n\n\tfloat pl = p.y + .2;\n\n\tp.z = re(p.z, 2.);\n\n\tvec3 q = p;\n\tq.xz *= r2d(3.14*.25);\n\tq.y = abs(q.y) - .3;\n\tfloat sc1 = sc(q, .2);;\n\n\tp.x = abs(p.x) - 1.;\n\tp.xy *= r2d(3.14*.25);\n\n\tfloat d = max(-sc1, min(pl, sc(p, .25)));\n\tg3 += .01 / (.015 + d * d);\n\treturn d;\n}\n\n// One face is barely visible due to my cube rotation function\n// So I decide to just put a very fast coded moving texture\n// It also helped me to focus only on two scene in parallel.\nvec3 tex1(vec2 uv) {\n\tvec2 uv2 = uv;\n\tuv *= sin(iTime);\n\tuv *= r2d(iTime);\n\tvec3 c = texture(iChannel0, uv).rrr;\n\n\t// small trick to avoid seeing texture from other faces on edges.\n\tc *= (1. - length(pow(uv2, vec2(3))));\n\n\treturn c;\n}\n\n// Sphere tracer of the first mapped scene.\n// It was faster & more flexible to duplicate code in this livecoding context,\n// sorry if it triggers your developer's sense :p\nvec3 tex2(vec2 uv) {\n\tvec3 ro = vec3(0, 0, -4. + iTime * 4.);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\tfloat t = 0., ri;\n\tvec3 p;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de2(p);\n\t\tif (d < .001) break;\n\t\tt += d;\n\t}\n\n\tvec3 c = vec3(ri);\n\n\t// small trick to avoid seeing texture from other faces on edges.\n\tc *= (1. - length(pow(uv, vec2(3))));\n\n\treturn c;\n}\n\n// Sphere tracer of the second mapped scene.\nvec3 tex3(vec2 uv) {\n\tvec3 ro = vec3(0, 0, -4. + iTime * 1.);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\tfloat t = 0., ri;\n\tvec3 p;\n\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de3(p);\n\t\t// if(d<.001) break;\n\t\td = max(abs(d), .002);\n\t\tt += d * .3;\n\t}\n\n\tvec3 c = vec3(ri*.1);//mix(vec3(.2, .3, .7), vec3(.1, .1, .4), i);\n\tc += g3 * .008;\n\n\t// small trick to avoid seeing texture from other faces on edges.\n\tc *= (1. - length(pow(uv, vec2(3))));\n\n\treturn c;\n}\n\n// boxmap from iq https://www.shadertoy.com/view/MtsGWH\nvec3 boxmap(vec3 p, vec3 n) {\n\tn = pow(abs(n), vec3(32));\n\tvec3 tx = tex1(p.yz);\n\tvec3 ty = tex2(p.zx);\n\tvec3 tz = tex3(p.xy);\n\treturn (tx*n.x + ty * n.y + tz * n.z) / (n.x + n.y + n.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0, 0, -4);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\tfloat t = 0., ri;\n\tvec3 p;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\tif (d < .001) break;\n\t\tt += d;\n\t}\n\n\tvec3 n = normal(p);\n\ttransf(p);\n\ttransf(n);\n\tvec3 c = boxmap(p, n);\n\tfragColor = vec4(c, 1);\n}\n","name":"Image","description":"","type":"image"}]}