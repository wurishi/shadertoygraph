{"ver":"0.1","info":{"id":"cdKczd","date":"1696476746","viewed":60,"name":"tiles - azavier","username":"azavier","description":"this is kinda fun","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ddVyRm","parentname":"sqrt attenuation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 scene_info(in vec3 p) {\n vec2 ci = vec2(FAR, -1.0);\n #define rectify(obj, matID) ci = mix(ci, vec2(obj, matID), step(obj, ci.x));\n \n // tiles\n vec3 boxp = p;\n vec2 id = floor(boxp.xz);\n float g_cd = length(id);\n boxp.xz = fract(boxp.xz);\n boxp.y -= 0.1+0.1*sin(id.x*id.y+4.0*iTime)\n         + 0.2+0.2*sin(0.5*id.x*id.y+2.0*iTime)\n         - 0.3+0.3*sin(2.0*id.x*id.y+iTime)\n         + 2.0*sin(0.35*g_cd + iTime);\n vec3 q = abs(boxp) - vec3(0.9, 0.02, 0.9);\n rectify(0.25*(min(max(q.x, max(q.y,q.z)), 0.0) + length(max(q, 0.0)))-0.01, 0.0);\n \n return ci;\n}\n\n// i stole this from IQ without reading up on it, is it faster?\nvec3 surface_normal(in vec3 p) { // klems's trick to prevent the compiler from inlining map() 4 times\n vec3 n = vec3(0.0);\n for(int i = min(iFrame, 0); i < 4; i++) {\n  vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n  n += e*scene_info(p+HIT*e).x;\n }\n return normalize(n);\n}\n\nvec2 march_scene(in vec3 ro, in vec3 rd) { // fancy innit\n vec2 mi = vec2(0.0);\n for(vec3 msi = vec3(scene_info(ro), 0.0); step(FAR, mi.x)+step(msi.x, HIT)+step(TRACESTEPS, msi.z++) == 0.0; msi.xy = scene_info(ro + rd*mi.x))\n  mi = vec2(mi.x + msi.x, msi.y);\n return mi;\n}\n\nvec3 parse_material(in float m, in vec3[2] data) {\n switch(int(m)) {\n  case 0:\n   vec2 id = floor(data[0].xz);\n   float g_cd = length(id);\n   return mix(vec3(0.11, 0.32, 0.22), vec3(0.22, 0.1, 0.5), vec3(0.25+0.25*sin(id.x*id.y) + 0.25+0.25*sin(0.01*g_cd + 1.5*iTime)));\n }\n}\n\nvoid lighting(inout vec3 col, in vec3 hitp, in vec3 hitn, in vec3 lightp) {\n // lighting calculations\n vec4 pointL = vec4(lightp, 32.0);\n vec3 to = pointL.xyz - hitp;\n col *= smoothstep(-1.0, 1.0, dot(normalize(to), hitn)); // diffuse\n col *= sqrt(pointL.w/length(to)); // squirt attenuation\n col = sqrt(col); // gamma correction\n}\n\nvec3 PixelColor(in vec2 uv) {\n vec3 ro = vec3(25.0, 5.0, 25.0);\n float t = iTime*0.33;\n ro.xz *= rot(t);\n vec3 focus = ro + vec3(0.0, -1.0, 0.0);\n focus.xz += vec2(sin(t), cos(t));\n vec3 rd = lookTo(uv, ro, focus);\n\n vec2 traceout = march_scene(ro, rd);\n vec3 hitp = ro+rd*traceout.x, hitn = surface_normal(hitp);\n float fcheck = step(traceout.x, FAR); // fcheck is 1.0 if we did not reach the far plane\n \n vec3 col = vec3(fcheck);\n col *= parse_material(traceout.y, vec3[](hitp, hitn));\n \n lighting(col, hitp, hitn, focus);\n \n vec3 bgc = vec3(0.6,0.2,0.3)*(0.65+0.35*rd.y); // far plane color\n return mix(col, bgc, smoothstep(0.0, FAR*FAR, traceout.x*traceout.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n vec3 col = vec3(0.0);\n \n#if AA > 1\n const float AA_INCREMENT = 1.0/float(AA);\n  \n for(vec2 AAO = vec2(-0.5); AAO.x < 0.5; AAO.x += AA_INCREMENT)\n  for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT)\n   col += PixelColor(uv + AAO/iResolution.y);\n  \n col /= float(AA*AA);\n#else\n col += PixelColor(uv);\n#endif\n \n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AA 2\n\n#define HIT 0.001\n#define FAR 50.0\n#define TRACESTEPS 300.0\n\nmat2x2 rot(in float th) {\n return mat2x2(cos(th), -sin(th), sin(th), cos(th));\n}\n\nvec3 lookTo(in vec2 uv, in vec3 o, in vec3 f) {\n vec3 fwd = normalize(f-o);\n vec3 rgt = normalize(cross(fwd, vec3(0.0,1.0,0.0)));\n vec3 up = cross(rgt, fwd);\n \n return normalize(1.0*(uv.x*rgt + uv.y*up) + fwd);\n}\n\nfloat sdf_box (vec3 p, vec3 c, vec3 s) {\n    float x = max( p.x - c.x - (s.x/2.0)\n                 , c.x - p.x - (s.x/2.0) );\n    float y = max( p.y - c.y - (s.y/2.0)\n                 , c.y - p.y - (s.y/2.0) );\n    float z = max( p.z - c.z - (s.z/2.0)\n                 , c.z - p.z - (s.z/2.0) );\n                 \n    float d = x;\n    d = max(d,y);\n    d = max(d,z);\n    return d;\n}","name":"Common","description":"","type":"common"}]}