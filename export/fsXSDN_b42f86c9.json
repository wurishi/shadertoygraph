{"ver":"0.1","info":{"id":"fsXSDN","date":"1618618760","viewed":64,"name":"Formanchuk Anton","username":"antonf2000","description":"вода + октаэдр","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"NdsXWH","parentname":"Fork Specular q antonf2000 676"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float SPHERE_R = 0.4;\nconst vec3 CAMERA_POS = vec3(1.4, 1, -6);\nconst vec3 LIGHT1_POS = vec3(-2.5,1.0, 5.0);\nconst float LIGHT1_RADIUS = 0.4;\nconst vec3 LIGHT1_COLOR = vec3(0.3, 0.6, 0.9);\n\nconst vec3 LIGHT2_POS = vec3(2.5, 0.5, 2.0);\nconst float LIGHT2_RADIUS = 0.4;\nconst vec3 LIGHT2_COLOR = vec3(1, 1, 1);\nvec3 randDir;\n\nstruct Quad {\n    vec3 pos[4];\n    vec3 color;\n};\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir1, vec3 a, vec3 b, vec3 c, out vec3 normal) {\n    float eps = 0.001;\n    vec3 ba = b - a;\n    vec3 ac = c - a;\n    vec3 dir = normalize(dir1);\n    vec3 die = dir1;\n    normal = normalize(cross(ba,ac));\n    if (dot(normal, dir) > 0.0){\n        normal = -normal;\n    }\n    float D = -dot(normal, a);\n    float n = dot(normal, dir);\n    if (n < eps && n > (-eps)) {\n        return INF;\n    }\n    float t = -(dot(normal, pos)+D)/n;\n    if (t < 0.0) {\n        return INF;\n    }\n    vec3 x;\n    x.x = pos.x+dir.x*t; \n    x.y = pos.y+dir.y*t; \n    x.z = pos.z+dir.z*t;\n    float dab = sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n    float dac = sqrt((a.x-c.x)*(a.x-c.x)+(a.y-c.y)*(a.y-c.y)+(a.z-c.z)*(a.z-c.z));\n    float dax = sqrt((a.x-x.x)*(a.x-x.x)+(a.y-x.y)*(a.y-x.y)+(a.z-x.z)*(a.z-x.z));\n    float dbc = sqrt((b.x-c.x)*(b.x-c.x)+(b.y-c.y)*(b.y-c.y)+(b.z-c.z)*(b.z-c.z));\n    float dbx = sqrt((b.x-x.x)*(b.x-x.x)+(b.y-x.y)*(b.y-x.y)+(b.z-x.z)*(b.z-x.z));\n    float dcx = sqrt((c.x-x.x)*(c.x-x.x)+(c.y-x.y)*(c.y-x.y)+(c.z-x.z)*(c.z-x.z));\n    float ppabc = (dab + dbc + dac)/2.0;\n    float ppabx = (dab + dbx + dax)/2.0;\n    float ppacx = (dac + dcx + dax)/2.0;\n    float ppbcx = (dbc + dcx + dbx)/2.0;\n    float pabc = sqrt(ppabc*(ppabc-dab)*(ppabc-dbc)*(ppabc-dac));\n    float pabx = sqrt(ppabx*(ppabx-dab)*(ppabx-dbx)*(ppabx-dax));\n    float pacx = sqrt(ppacx*(ppacx-dac)*(ppacx-dcx)*(ppacx-dax));\n    float pbcx = sqrt(ppbcx*(ppbcx-dbc)*(ppbcx-dcx)*(ppbcx-dbx));\n    if (pabc + eps > pabx + pacx + pbcx){\n        return t;\n    }\n    return INF; \n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos - vec3(-1.5, -1.0, 0.0), dir, 0.2, sphNorm);\n    if (sphT < dist)\n        return true;\n    \n    vec3 tri1Norm;\n    float triT1 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri1Norm);\n    if (triT1 < dist)\n        return true;\n    vec3 tri2Norm;\n    float triT2 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri2Norm);\n    if (triT2 < dist)\n        return true;\n    vec3 tri3Norm;\n    float triT3 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri3Norm);\n    if (triT3 < dist)\n        return true;\n    vec3 tri4Norm;\n    float triT4 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri4Norm);\n    if (triT4 < dist)\n        return true;\n    vec3 tri5Norm;\n    float triT5 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri5Norm);\n    if (triT5 < dist)\n        return true;\n    vec3 tri6Norm;\n    float triT6 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri6Norm);\n    if (triT6 < dist)\n        return true;\n    vec3 tri7Norm;\n    float triT7 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri7Norm);\n    if (triT7 < dist)\n        return true;\n    vec3 tri8Norm;\n    float triT8 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri8Norm);\n    if (triT8 < dist)\n        return true;\n    vec3 tri21Norm;\n    float triT21 = traceTriangle(pos, dir, vec3(-2.0,-1.2, 0.9), vec3(-2.6,-1.2, 0.9), vec3(-2.3, 0.0, 1.2), tri21Norm);\n    if (triT21 < dist)\n        return true;\n    vec3 tri22Norm;\n    float triT22 = traceTriangle(pos, dir, vec3(-2.0,-1.2, 1.5), vec3(-2.6,-1.2, 1.5), vec3(-2.3, 0.0, 1.2), tri22Norm);\n    if (triT22 < dist)\n        return true;\n    vec3 tri23Norm;\n    float triT23 = traceTriangle(pos, dir, vec3(-2.6,-1.2, 0.9), vec3(-2.6,-1.2, 1.5), vec3(-2.3, 0.0, 1.2), tri23Norm);\n    if (triT23 < dist)\n        return true;\n    vec3 tri24Norm;\n    float triT24 = traceTriangle(pos, dir, vec3(-2.0,-1.2, 0.9), vec3(-2.0,-1.2, 1.5), vec3(-2.3, 0.0, 1.2), tri24Norm);\n    if (triT24 < dist)\n        return true;\n    vec3 tri31Norm;\n    float triT31 = traceTriangle(pos, dir, vec3(2.0,-1.2, 3.0), vec3(2.0,-0.6, 3.0), vec3(2.8,-1.2, 3.8), tri31Norm);\n    if (triT31 < dist)\n        return true;\n    vec3 tri32Norm;\n    float triT32 = traceTriangle(pos, dir, vec3(2.8,-0.6, 3.8), vec3(2.0,-0.6, 3.0), vec3(2.8,-1.2, 3.8), tri32Norm);\n    if (triT32 < dist)\n        return true;\n    vec3 tri33Norm;\n    float triT33 = traceTriangle(pos, dir, vec3(2.8,-0.6, 3.8), vec3(2.0,-0.6, 4.6), vec3(2.8,-1.2, 3.8), tri33Norm);\n    if (triT33 < dist)\n        return true;\n    vec3 tri34Norm;\n    float triT34 = traceTriangle(pos, dir, vec3(2.0,-1.2, 4.6), vec3(2.0,-0.6, 4.6), vec3(2.8,-1.2, 3.8), tri34Norm);\n    if (triT34 < dist)\n        return true;\n    vec3 tri35Norm;\n    float triT35 = traceTriangle(pos, dir, vec3(2.0,-1.2, 4.6), vec3(2.0,-0.6, 4.6), vec3(1.2,-1.2, 3.8), tri35Norm);\n    if (triT35 < dist)\n        return true;\n    vec3 tri36Norm;\n    float triT36 = traceTriangle(pos, dir, vec3(1.2,-0.6, 3.8), vec3(2.0,-0.6, 4.6), vec3(1.2,-1.2, 3.8), tri36Norm);\n    if (triT36 < dist)\n        return true;\n    vec3 tri37Norm;\n    float triT37 = traceTriangle(pos, dir, vec3(1.2,-0.6, 3.8), vec3(2.0,-0.6, 3.0), vec3(1.2,-1.2, 3.8), tri37Norm);\n    if (triT37 < dist)\n        return true;\n    vec3 tri38Norm;\n    float triT38 = traceTriangle(pos, dir, vec3(2.0,-1.2, 3.0), vec3(2.0,-0.6, 3.0), vec3(1.2,-1.2, 3.8), tri38Norm);\n    if (triT38 < dist)\n        return true;\n    vec3 tri39Norm;\n    float triT39 = traceTriangle(pos, dir, vec3(2.0,-0.6,3.0), vec3(2.8,-0.6,3.8), vec3(2.0,-0.6,4.6), tri39Norm);\n    if (triT39 < dist)\n        return true;\n    vec3 tri40Norm;\n    float triT40 = traceTriangle(pos, dir, vec3(2.0,-0.6,3.0), vec3(1.2,-0.6,3.8), vec3(2.0,-0.6,4.6), tri40Norm);\n    if (triT40 < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 15.0f / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 10.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nconst float PI = 3.14159265359;\n\n\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (abs(sinB) > 1.0){return reflect(v, normal);}\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat modFloat(float x){\n    while (x > 10.0){\n        x /= 10.0;\n    }\n    return x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    float specFactor = 32.0 * 2.0 + 1.0;\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    const float WATER_N = 1.33;\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    Quad light;\n    light.pos = vec3[4](\n        vec3(3.0, 1.5, -0.3),\n        vec3(3.0, 0.5, -0.3),\n        vec3(2.0, 0.5, -0.7),\n        vec3(2.0, 1.5, -0.7)\n    );\n    light.color = vec3(1, 1, 1);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.3).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 tri1Norm;\n        float triT1 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri1Norm);\n        if (triT1 < t) {\n            t = triT1;\n            normal = tri1Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION; \n            } else {\n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n        }\n        vec3 tri2Norm;\n        float triT2 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri2Norm);\n        if (triT2 < t) {\n            t = triT2;\n            normal = tri2Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri3Norm;\n        float triT3 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri3Norm);\n        if (triT3 < t) {\n            t = triT3;\n            normal = tri3Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri4Norm;\n        float triT4 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri4Norm);\n        if (triT4 < t) {\n            t = triT4;\n            normal = tri4Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri5Norm;\n        float triT5 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri5Norm);\n        if (triT5 < t) {\n            t = triT5;\n            normal = tri5Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri6Norm;\n        float triT6 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri6Norm);\n        if (triT6 < t) {\n            t = triT6;\n            normal = tri6Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri7Norm;\n        float triT7 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri7Norm);\n        if (triT7 < t) {\n            t = triT7;\n            normal = tri7Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n               \n                \n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                \n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri8Norm;\n        float triT8 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri8Norm);\n        if (triT8 < t) {\n            t = triT8;\n            normal = tri8Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1,1,1);\n                /*\n                vec3 worldPos = t * curDir + curPos;\n                vec3 density = texture(iChannel2, fragCoord/iResolution.xy * 2.05).rgb;\n                colorMult += 0.8*density;\n                */\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri31Norm;\n        float triT31 = traceTriangle(curPos, curDir, vec3(2.0,-1.2, 3.0), vec3(2.0,-0.6, 3.0), vec3(2.8,-1.2, 3.8), tri31Norm);\n        if (triT31 < t) {\n            t = triT31;\n            normal = tri31Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri32Norm;\n        float triT32 = traceTriangle(curPos, curDir, vec3(2.8,-0.6, 3.8), vec3(2.0,-0.6, 3.0), vec3(2.8,-1.2, 3.8), tri32Norm);\n        if (triT32 < t) {\n            t = triT32;\n            normal = tri32Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri33Norm;\n        float triT33 = traceTriangle(curPos, curDir, vec3(2.8,-0.6, 3.8), vec3(2.0,-0.6, 4.6), vec3(2.8,-1.2, 3.8), tri33Norm);\n        if (triT33 < t) {\n            t = triT33;\n            normal = tri33Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri34Norm;\n        float triT34 = traceTriangle(curPos, curDir, vec3(2.0,-1.2, 4.6), vec3(2.0,-0.6, 4.6), vec3(2.8,-1.2, 3.8), tri34Norm);\n        if (triT34 < t) {\n            t = triT34;\n            normal = tri34Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri35Norm;\n        float triT35 = traceTriangle(curPos, curDir, vec3(2.0,-1.2, 4.6), vec3(2.0,-0.6, 4.6), vec3(1.2,-1.2, 3.8), tri35Norm);\n        if (triT35 < t) {\n            t = triT35;\n            normal = tri35Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri36Norm;\n        float triT36 = traceTriangle(curPos, curDir, vec3(1.2,-0.6, 3.8), vec3(2.0,-0.6, 4.6), vec3(1.2,-1.2, 3.8), tri36Norm);\n        if (triT36 < t) {\n            t = triT36;\n            normal = tri36Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri37Norm;\n        float triT37 = traceTriangle(curPos, curDir, vec3(1.2,-0.6, 3.8), vec3(2.0,-0.6, 3.0), vec3(1.2,-1.2, 3.8), tri37Norm);\n        if (triT37 < t) {\n            t = triT37;\n            normal = tri37Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri38Norm;\n        float triT38 = traceTriangle(curPos, curDir, vec3(2.0,-1.2, 3.0), vec3(2.0,-0.6, 3.0), vec3(1.2,-1.2, 3.8), tri38Norm);\n        if (triT38 < t) {\n            t = triT38;\n            normal = tri38Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri39Norm;\n        float triT39 = traceTriangle(curPos, curDir, vec3(2.0,-0.6,3.0), vec3(2.8,-0.6,3.8), vec3(2.0,-0.6,4.6), tri39Norm);\n        if (triT39 < t) {\n            t = triT39;\n            normal = tri39Norm;\n            materialType = REFLECTION;\n        }\n        vec3 tri40Norm;\n        float triT40 = traceTriangle(curPos, curDir, vec3(2.0,-0.6,3.0), vec3(1.2,-0.6,3.8), vec3(2.0,-0.6,4.6), tri40Norm);\n        if (triT40 < t) {\n            t = triT40;\n            normal = tri40Norm;\n            materialType = REFLECTION;\n           \n        }\n        vec3 tri21Norm;\n        float triT21 = traceTriangle(curPos, curDir, vec3(-2.0,-1.2, 0.9), vec3(-2.6,-1.2, 0.9), vec3(-2.3, 0.0, 1.2), tri21Norm);\n        if (triT21 < t) {\n            t = triT21;\n            normal = tri21Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.1,1,0.1);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri22Norm;\n        float triT22 = traceTriangle(curPos, curDir, vec3(-2.0,-1.2, 1.5), vec3(-2.6,-1.2, 1.5), vec3(-2.3, 0.0, 1.2), tri22Norm);\n        if (triT22 < t) {\n            t = triT22;\n            normal = tri22Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.1,1,0.1);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri23Norm;\n        float triT23 = traceTriangle(curPos, curDir, vec3(-2.6,-1.2, 0.9), vec3(-2.6,-1.2, 1.5), vec3(-2.3, 0.0, 1.2), tri23Norm);\n        if (triT23 < t) {\n            t = triT23;\n            normal = tri23Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.1,1,0.1);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri24Norm;\n        float triT24 = traceTriangle(curPos, curDir, vec3(-2.0,-1.2, 0.9), vec3(-2.0,-1.2, 1.5), vec3(-2.3, 0.0, 1.2), tri24Norm);\n        if (triT24 < t) {\n            t = triT24;\n            normal = tri24Norm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.1,1,0.1);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        \n      \n        vec3 tri9Norm;\n        float triT9 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(0.3,-0.3,-0.3), vec3(-0.3,-0.3,-0.3), vec3(-0.3,0.3,-0.3), tri9Norm);\n        if (triT9 < t) {\n                t = triT9;\n                materialType = REFRACTION;\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                normal = tri9Norm;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n                \n        }\n        vec3 tri10Norm;\n        float triT10 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(0.3,-0.3,-0.3), vec3(0.3,0.3,-0.3), vec3(-0.3,0.3,-0.3), tri10Norm);\n        if (triT10 < t) {\n            t = triT10;\n            normal = tri10Norm;\n             {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n            colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri11Norm;\n        float triT11 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(0.3,-0.3,-0.3), vec3(0.3,0.3,-0.3), vec3(0.3,0.3,0.3), tri11Norm);\n        if (triT11 < t) {\n            t = triT11;\n            normal = tri11Norm;\n           {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri12Norm;\n        float triT12 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(0.3,-0.3,-0.3), vec3(0.3,-0.3,0.3), vec3(0.3,0.3,0.3), tri12Norm);\n        if (triT12 < t) {\n            t = triT12;\n            normal = tri12Norm;\n           {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri13Norm;\n        float triT13 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(0.3,-0.3,0.3), vec3(-0.3,-0.3,0.3), vec3(-0.3,0.3,0.3), tri13Norm);\n        if (triT13 < t) {\n            t = triT13;\n            normal = tri13Norm;\n            {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri14Norm;\n        float triT14 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(0.3,-0.3,0.3), vec3(0.3,0.3,0.3), vec3(-0.3,0.3,0.3), tri14Norm);\n        if (triT14 < t) {\n            t = triT14;\n            normal = tri14Norm;\n            {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n         vec3 tri15Norm;\n        float triT15 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(-0.3,-0.3,-0.3), vec3(-0.3,0.3,-0.3), vec3(-0.3,0.3,0.3), tri15Norm);\n        if (triT15 < t) {\n            t = triT15;\n            normal = tri15Norm;\n            {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri16Norm;\n        float triT16 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(-0.3,-0.3,-0.3), vec3(-0.3,-0.3,0.3), vec3(-0.3,0.3,0.3), tri16Norm);\n        if (triT16 < t) {\n            t = triT16;\n            normal = tri16Norm;\n           {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri17Norm;\n        float triT17 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(-0.3,0.3,-0.3), vec3(-0.3,0.3,0.3), vec3(0.3,0.3,0.3), tri17Norm);\n        if (triT17 < t) {\n            t = triT17;\n            normal = tri17Norm;\n             {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri18Norm;\n        float triT18 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(-0.3,0.3,-0.3), vec3(0.3,0.3,-0.3), vec3(0.3,0.3,0.3), tri18Norm);\n        if (triT18 < t) {\n            t = triT18;\n            normal = tri18Norm;\n            {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri19Norm;\n        float triT19 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(-0.3,-0.3,-0.3), vec3(-0.3,-0.3,0.3), vec3(0.3,-0.3,0.3), tri19Norm);\n        if (triT19 < t) {\n            t = triT19;\n            normal = tri19Norm;\n            {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        vec3 tri20Norm;\n        float triT20 = traceTriangle(curPos+ 0.03*randVals, curDir+ 0.03*randVals, vec3(-0.3,-0.3,-0.3), vec3(0.3,-0.3,-0.3), vec3(0.3,-0.3,0.3), tri20Norm);\n        if (triT20 < t) {\n            t = triT20;\n            normal = tri20Norm;\n            {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n        }\n        \n        vec3 Sphere1Norm;\n        float Sphere1T = traceSphere(curPos - vec3(-1.5, -1.05, 0.0), curDir, 0.2, Sphere1Norm);\n        if (Sphere1T < t) {\n            t = Sphere1T;\n            normal = Sphere1Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1, 1, 1);\n                materialType = REFRACTION;\n                n1 == AIR_N; \n                nEnter = AIR_N;\n            }\n            if (n1 == AIR_N) nEnter = GLASS_N;\n            if (n1 == GLASS_N) nEnter = AIR_N;\n        }\n        \n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel3, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            } \n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult + vec3(0.08, 0.08, 0.08);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}