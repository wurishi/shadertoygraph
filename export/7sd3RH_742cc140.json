{"ver":"0.1","info":{"id":"7sd3RH","date":"1629184105","viewed":230,"name":"old film effect","username":"zyc","description":"old film effect, sepia, noise, scratching, vignetting.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["film"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* port from https://www.nutty.ca\n*\n**/\n// sepia in [0.0, 1.0]\nconst float SepiaValue = 0.1;\n// noise in [0.0, 1.0]\nconst float NoiseValue = 0.08;\n// Scratch in [0.0, 1.0]\nconst float ScratchValue = 0.9;\nconst float InnerVignetting = 1.0;\nconst float OuterVignetting = 1.2;\n\nvec3 Overlay (vec3 src, vec3 dst)\n{\n\t// if (dst <= �) then: 2 * src * dst\n\t// if (dst > �) then: 1 - 2 * (1 - dst) * (1 - src)\n\treturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n\t\t\t(dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n\t\t\t(dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat nrand( vec2 n ) { return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);}\nfloat snoise (vec2 v)\n{\n\tconst vec4 C = vec4(0.211324865405187,\t// (3.0-sqrt(3.0))/6.0\n\t\t\t\t0.366025403784439,\t// 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t-0.577350269189626,\t// -1.0 + 2.0 * C.x\n\t\t\t\t0.024390243902439);\t// 1.0 / 41.0\n\n\t// First corner\n\tvec2 i  = floor(v + dot(v, C.yy) );\n\tvec2 x0 = v -   i + dot(i, C.xx);\n\n\t// Other corners\n\tvec2 i1;\n\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\tm = m*m ;\n\tm = m*m ;\n\n\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\n\t// Normalise gradients implicitly by scaling m\n\t// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\t// Compute final noise value at P\n\tvec3 g;\n\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\treturn 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 vUv = fragCoord.xy/iResolution.xy;\n    float TimeLapse = 10.*iTime;\n    \n    // Sepia RGB value\n\tvec3 sepia = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\n\t// Step 1: Convert to grayscale\n\tvec3 colour = texture(iChannel0, vUv).xyz;\n\tfloat gray = (colour.x + colour.y + colour.z) / 3.0;\n    vec3 grayscale = vec3(gray);\n    //vec3 grayscale = colour;\n    \n    float RandomValue = nrand(vUv*iTime*dot(colour,colour));\n\t\n\t// Step 2: Appy sepia overlay\n\tvec3 finalColour = Overlay(sepia, grayscale);\n\t\n\t// Step 3: Lerp final sepia colour\n\tfinalColour = grayscale + SepiaValue * (finalColour - grayscale);\n\t\n\t// Step 4: Add noise\n\tfloat noise = snoise(vUv * vec2(1024.0 + RandomValue * 512.0, 1024.0 + RandomValue * 512.0)) * 0.5;\n\tfinalColour += noise * NoiseValue;\n\t\n\t// Optionally add noise as an overlay, simulating ISO on the camera\n\t//vec3 noiseOverlay = Overlay(finalColour, vec3(noise));\n\t//finalColour = finalColour + NoiseValue * (finalColour - noiseOverlay);\n\t\n\t// Step 5: Apply scratches\n\tif ( RandomValue < ScratchValue )\n\t{\n\t\t// Pick a random spot to show scratches\n\t\tfloat dist = 1.0 / ScratchValue;\n\t\tfloat d = distance(vUv, vec2(RandomValue * dist, RandomValue * dist));\n\t\tif ( d < 0.2 )\n\t\t{\n\t\t\t// Generate the scratch\n\t\t\tfloat xPeriod = 8.0;\n\t\t\tfloat yPeriod = 1.0;\n\t\t\tfloat pi = 3.141592;\n\t\t\tfloat phase = TimeLapse;\n\t\t\tfloat turbulence = snoise(vUv * 2.5);\n\t\t\tfloat vScratch = 0.5 + (sin(((vUv.x * xPeriod + vUv.y * yPeriod + turbulence)) * pi + phase) * 0.5);\n\t\t\tvScratch = clamp((vScratch * 10000.0) + 0.35, 0.0, 1.0);\n\n\t\t\tfinalColour.xyz /= vScratch;\n\t\t}\n\t}\n\t\n\t// Step 6: Apply vignetting\n\t// Max distance from centre to corner is ~0.7. Scale that to 1.0.\n\tfloat d = distance(vec2(0.5, 0.5), vUv) * 1.414213;\n\tfloat vignetting = clamp((OuterVignetting - d) / (OuterVignetting - InnerVignetting), 0.0, 1.0);\n\tfinalColour.xyz /= vignetting;\n\t\n\t// Apply colour\n\tfragColor.xyz = finalColour;\n\tfragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}]}