{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\n: rand ( x:float -> float )\n\tx 123 * 17 + sin x 69 * 49 + sin *\n;\n\niResolution frag->position 3 * =p\n\n[\n\t[ [ 1 0 0 ] 1 3 / [ .2 time * 1.2 .7 ] [ .3 .12 .1 ] { } ] ( Linear )\n\t[ [ 0 1 0 ] 1 3 / [ .3 1.7 .4 ] [ .6 .5 time * .34 ] { sin } ] ( Sinusoidal )\n\t[ [ 0 0 1 ] 1 3 / [ .7 .4 .8 ] [ .17 time * .2 .2 ] { !length / } ] ( Spherical )\n] =>funcs\n\n10 =>runs\n\n[ 0 0 0 0 ] =hist\n\n{ ( i )\n\t[ time p .x + i float * rand time 17 * p .y + p .x + i float * rand ] =P\n\t[ 0 0 0 ] =C\n\n\t50 =>iters\n\t{\n\t\tP .x P length * rand abs funcs size * floor =ci\n\t\t\t[ funcs enumerate /{ ( [ i [ color weight xvars yvars block ] ] ) [ ci i ==\n\t\t\t\t{\n\t\t\t\t\t[\n\t\t\t\t\t\tP .x xvars .x * P .y xvars .y * + xvars .z +\n\t\t\t\t\t\tP .x yvars .x * P .y yvars .y * + yvars .z +\n\t\t\t\t\t] *block =P\n\t\t\t\t\tC color + 2 / =C\n\t\t\t\t}\n\t\t\t] } /flatten flatten ]\n\t\tcond\n\t\t{\n\t\t\t[ hist .x 1 + hist .yzw C + 2 / ] =hist\n\t\t} P p - length 1 hist .x 10 * / .001 + < when\n\t} iters times\n} runs times\n\nhist .yzw ->fragcolor\n*/\n\nfloat rand(float x) {\n\treturn sin(x * 123. + 17.) * sin(x * 69. + 49.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 P;\n\tvec3 C;\n\tvec4 hist;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) * 3.;\n\thist = vec4(0., 0., 0., 0.);\n\tfor(int temp_5 = 0; temp_5 < 10; ++temp_5) {\n\t\tP = vec2(rand((iTime + p.x) * float(temp_5)), rand((iTime * 17. + p.y + p.x) * float(temp_5)));\n\t\tC = vec3(0., 0., 0.);\n\t\tfor(int temp_6 = 0; temp_6 < 50; ++temp_6) {\n\t\t\tfloat ci = floor(abs(rand(P.x * length(P))) * 3.);\n\t\t\tif(ci == 0.) {\n\t\t\t\tP = vec2(P.x * vec3(.2 * iTime, 1.2, .7).x + P.y * vec3(.2 * iTime, 1.2, .7).y + vec3(.2 * iTime, 1.2, .7).z, P.x * .3 + P.y * .12 + .1);\n\t\t\t\tC = (C + vec3(1., 0., 0.)) / 2.;\n\t\t\t} else if(ci == 1.) {\n\t\t\t\tP = sin(vec2(P.x * .3 + P.y * 1.7 + .4, P.x * vec3(.6, .5 * iTime, .34).x + P.y * vec3(.6, .5 * iTime, .34).y + vec3(.6, .5 * iTime, .34).z));\n\t\t\t\tC = (C + vec3(0., 1., 0.)) / 2.;\n\t\t\t} else if(ci == 2.) {\n\t\t\t\tP = vec2(P.x * .7 + P.y * .4 + .8, P.x * vec3(.17 * iTime, .2, .2).x + P.y * vec3(.17 * iTime, .2, .2).y + vec3(.17 * iTime, .2, .2).z) / length(vec2(P.x * .7 + P.y * .4 + .8, P.x * vec3(.17 * iTime, .2, .2).x + P.y * vec3(.17 * iTime, .2, .2).y + vec3(.17 * iTime, .2, .2).z));\n\t\t\t\tC = (C + vec3(0., 0., 1.)) / 2.;\n\t\t\t}\n\t\t\tif(length(P - p) < (1. / (hist.x * 10.) + .001)) {\n\t\t\t\thist = vec4(hist.x + 1., (hist.yzw + C) / 2.);\n\t\t\t}\n\t\t}\n\t}\n\tfragColor = vec4(hist.yzw, 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4llGz7","date":"1420239605","viewed":275,"name":"Fractal Flame","username":"daeken","description":"Realtime fractal flame experiment.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["flame","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}