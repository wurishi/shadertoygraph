{"ver":"0.1","info":{"id":"MXf3DS","date":"1707871488","viewed":57,"name":"Shape Entity","username":"Shin0155","description":"Shape Entity","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shapeentity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy uniforms\nuniform vec3 iGlobalResolution;\nuniform float iGlobalTime;\n\n\n\n// Constants\nconst float PI = 3.14159265359;\nconst float TWO_PI = PI * 2.0;\n\n// Rotation matrix\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Signed distance function for a sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Signed distance function for a box\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Signed distance function for a woman's body\nfloat sdWoman(vec3 p) {\n    // Head\n    float head = sdSphere(p - vec3(0.0, 1.0, 0.0), 0.5);\n    \n    // Torso\n    float torso = sdBox(p - vec3(0.0, 0.0, 0.0), vec3(0.5, 1.0, 0.5));\n    \n    // Arms\n    float arm = sdBox(p - vec3(0.5, -0.5, 0.0), vec3(0.2, 0.5, 0.2));\n    arm = min(arm, sdBox(p - vec3(-0.5, -0.5, 0.0), vec3(0.2, 0.5, 0.2)));\n    \n    // Legs\n    float leg = sdBox(p - vec3(0.0, -1.5, 0.0), vec3(0.2, 1.0, 0.2));\n    \n    return min(min(min(head, torso), arm), leg);\n}\n\n// Raymarching function\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    float dS = 0.0; // Initialize dS\n    for (int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * dO;\n        dS = sdWoman(p); // Update dS with the current distance to the surface\n        dO += dS;\n        if (dO > 100.0 || dS < 0.01) break;\n    }\n    return vec2(dO, dS);\n}\n\n// Main image function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n\n    // Camera\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // Rotate camera\n    ro.xz *= rotate(iTime * 0.1);\n    rd.xz *= rotate(iTime * 0.1);\n\n    // Raymarching\n    vec2 d = raymarch(ro, rd);\n    if (d.x < 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = normalize(vec3(\n            sdWoman(p + vec3(0.01, 0.0, 0.0)) - d.y,\n            sdWoman(p + vec3(0.0, 0.01, 0.0)) - d.y,\n            sdWoman(p + vec3(0.0, 0.0, 0.01)) - d.y\n        ));\n\n        // Simple lighting\n        float diffuse = max(dot(n, normalize(vec3(1.0))), 0.0);\n        col = vec3(diffuse);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}