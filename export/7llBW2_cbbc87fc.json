{"ver":"0.1","info":{"id":"7llBW2","date":"1651743771","viewed":239,"name":"Electric generator","username":"sinvec","description":"I really don't know what it is :)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sdf","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\nmat2 rot(float a) {float s=sin(a), c=cos(a); return mat2(c,s,-s,c);}\nfloat gl1 = 0., gl2 = 0., gl3 = 0., gl4 = 0., gl5 = 0., gl6 = 0., gls1 = 0.;\nvec3 map(vec3 p) {\n    vec3 r = vec3(999.);\n    vec3 b = vec3(999.);\n\n    vec3 q = p;\n\n    p.xz *= rot(-iTime * .5);\n    p.xy *= rot(-iTime * 2.);\n \n    r.x = fTorus(p, .2, 1.);\n    vec3 w = p;\n    w.xz = abs(w.xz);\n    w.xz -= .7;\n    r.x = max(r.x,-length(w)+.3);\n    r.x = max(r.x,-fTorus(p, .16, 1.));\n    \n    vec2 u = normalize(p.xz);\n    u.x = atan(p.z / p.x);\n    u.y = length(p.xz);\n    if (sin(u.x * 150.) > 0.) r.z = 6.;\n    else {r.z = 3.;gl6 += (.0003/(.0001+pow(r.x+.01, 2.)));}\n    \n    float rot_speed = iTime * 8.;\n    p.xz *= rot(rot_speed);\n    q = p;\n    p.xz = abs(p.xz);\n    p.xz *= rot(-3.14/4.);\n    p.z -= 1.;\n    b.x = length(p) - .15;\n    if (q.x >= 0. && q.z >= 0.) {b.z = 2.; gl1 += (.01/(.0001+pow(b.x+.008, 2.)));}\n    else if (q.x <= 0. && q.z >= 0.) {b.z = 3.; gl2 += (.01/(.0001+pow(b.x+.008, 2.)));}\n    else if (q.x <= 0. && q.z <= 0.) {b.z = 4.; gl3 += (.01/(.0001+pow(b.x+.008, 2.)));}\n    else {b.z = 5.; gl4 += (.01/(.0001+pow(b.x+.008, 2.)));}\n    if (r.x > b.x) r = b; \n\n    p = q;\n    b.x = length(p) - .4;\n    gl6 += (.003/(.001+pow(b.x+.008, 2.)));\n    b.z = 1.;\n    if (r.x > b.x) r = b; \n    \n    vec3 m = p;\n    p.xz *= rot(3.14/4.);\n    q = p; \n    float cur_speed = iTime * 15.;\n    p.xz *= rot(sin(p.z * 15. + cur_speed)*.1);\n    p.xz = abs(p.xz);\n    \n    q.xz *= rot(sin(q.x * 15. + cur_speed)*.1);\n    q.xz = abs(q.xz);\n    \n    b.x = length(q.zy) - .015;\n    b.x = min(b.x,length(p.xy) - .015);\n    b.x = max(b.x,fBox(p,vec3(1.)));\n    gl6 += (.0005/(.0001+pow(b.x+.01, 2.)));\n    b.z = 1.;\n    if (r.x > b.x) r = b; \n    \n    p = m;\n    p.y = abs(p.y);\n    b.x = length(p) - .75;\n    b.x = max(b.x,-length(p)+.65);\n    b.x = max(b.x,-fBox(p,vec3(1.,.1,1.)));\n    gls1 += (.00001/(.0001+pow(b.x+.01, 2.)));\n    b.z = 1.;\n    b.y = 1.;\n    if (r.x > b.x) r = b; \n    b.y = 0.;\n    p = m;\n    p.xz *= rot(-rot_speed);\n    p = abs(p);\n    \n    p.xy *= rot(3.14/2.);\n    p.zy *= rot(-3.14/3.);\n\n    b.x = fTorus(p, .01, 1.);\n    p.zy *= rot(3.14/6.);\n\n    b.x = min(b.x,fTorus(p, .01, 1.));\n    b.z = 7.;\n    u = normalize(p.xz);\n    u.x = atan(p.z / p.x);\n    u.y = length(p.xz);\n    gl6 += (.001/(.001+pow(b.x+.01, 2.))) * (sin((u.x * 20.+iTime*50.))*.5+.5);\n    \n    p = m;\n    b.x = max(b.x,-fTorus(p, .16, 1.));\n    \n    if (r.x > b.x) r = b; \n    \n    b.x = length(w) - .3;\n    b.x = max(b.x, -length(w) + .25);\n    b.x = max(b.x,-fTorus(m, .16, 1.));\n    gls1 += (.00001/(.0001+pow(b.x+.01, 2.)));\n    b.y = 1.;\n    if (r.x > b.x) r = b; \n    \n    p = m;\n    p.y = abs(p.y);\n    p.y -= 1.;\n    b.x = length(p) - .15;\n    gl6 += (.001/(.001+pow(b.x+.01, 2.))) * (sin((iTime*50.))*.5+.5);\n    b.y = 0.;\n    if (r.x > b.x) r = b;     \n    \n    return r;\n}\n\nconst vec2 e = vec2(.00035, -.00035);\nvec3 norm(vec3 po) {\n        return normalize(e.yyx*map(po+e.yyx).x + e.yxy*map(po+e.yxy).x +\n                         e.xyy*map(po+e.xyy).x + e.xxx*map(po+e.xxx).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y;\n    const float Y = 2.;\n    vec3 ro = vec3(0.,Y,-Y),\n         rd = normalize(vec3(uv,1.)),\n         p, h;\n    rd.yz *= rot(-.8);\n    float t = 1.;\n    for (int i = 0; i < 120; i++) {\n        p = ro + rd * t;\n        h = map(p);\n        if(h.x<.001)\n            if(h.y==1.) { h.x = abs(h.x) + .001; }\n            else break;\n        if(t>40.) break;\n        t += h.x;\n    }\n\n    vec3 col = vec3(.1);\n    \n    vec3 ld = vec3(2.);\n    ld.xz *= rot(iTime);\n    \n    if (h.x < .001) {\n        p = ro + rd * t;\n        vec3 n = norm(p);\n        ld = normalize(ld - p);\n    \n        if (h.z == 1.) col = vec3(.6, .4, .9);\n        \n        if (h.z == 2.) col = vec3(.9, .1, .1);\n        if (h.z == 3.) col = vec3(.1, .9, .1);\n        if (h.z == 4.) col = vec3(.1, .0, .9);\n        if (h.z == 5.) col = vec3(.9, .9, .0);\n        \n        if (h.z == 6.) col = vec3(.72,.45,.2); // copper\n        if (h.z == 7.) col = vec3(.7); // steel\n    }\n    \n    col += gl1 * vec3(1.,0.,0.) * .1;\n    col += gl2 * vec3(0.,1.,0.) * .1;\n    col += gl3 * vec3(0.,0.,1.) * .1;\n    col += gl4 * vec3(1.,1.,0.) * .1;\n    col += gl5 * vec3(.7,1.,.7) * .1;\n    col += gl6 * vec3(.8,.5,1.) * .1;\n    \n    col += gls1 * vec3(.8,.5,1.) * .1;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}