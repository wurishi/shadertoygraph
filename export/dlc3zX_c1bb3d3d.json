{"ver":"0.1","info":{"id":"dlc3zX","date":"1688492587","viewed":64,"name":"reflective balls 2","username":"consindine","description":"this isn't ray marching, but also i don't quite know what it is!\n\nyou can think of this as a reflective ball in a mirror box, with a RGB gaming lamp","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ray","balls","mirrors","jank"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EP (1.0/512.0)\n\nfloat toLen(float l){\n    return 2.0*abs(l/(sign(l)+1.0));\n}\n\nfloat sphere(vec3 p, vec3 d, float r){\n    float a = dot(d,d), b = dot(p,d), c = b*b - a*(dot(p,p) - r*r);\n\n    if(c < 0.0)\n        return 1.0/0.0;\n\n    a = 1.0/a;\n    b *= -a;\n    c = sqrt(c);\n\n    \n    return toLen(min(b+c,b-c));\n}\n\nfloat plane(vec3 p, vec3 d){\n    return toLen(p.x / d.x);\n}\n\nfloat sphereSDF(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat planeSDF(vec3 p){\n    return p.x;\n}\n\nfloat dist(vec3 p){\n    float sd = 0.2;\n    \n    float d1 = sphereSDF(p, 0.1); \n    float d2 = planeSDF(vec3(sd, 0.0, 0.0) + p);\n    float d3 = planeSDF(vec3(sd, 0.0, 0.0) - p);\n    float d4 = planeSDF(vec3(sd, 0.0, 0.0) + p.yxz);\n    float d5 = planeSDF(vec3(sd, 0.0, 0.0) - p.yxz);\n    float d6 = planeSDF(vec3(sd, 0.0, 0.0) + p.zyx);\n    float d7 = planeSDF(vec3(sd, 0.0, 0.0) - p.zyx);\n    \n    return min(min(min(d2, d5), min(d3, d6)), min(min(d1, d7), d4));\n}\n\n\n\nfloat dist(vec3 p, vec3 d){\n    float sd = 0.2;\n    \n    float d1 = sphere(p, d, 0.1);    \n    float d2 = plane(vec3(-sd, 0.0, 0.0) - p, d);\n    float d3 = plane(vec3(sd, 0.0, 0.0) - p, d);\n    float d4 = plane(vec3(-sd, 0.0, 0.0) - p.yxz, d.yxz);\n    float d5 = plane(vec3(sd, 0.0, 0.0) - p.yxz, d.yxz);\n    float d6 = plane(vec3(-sd, 0.0, 0.0) - p.zyx, d.zyx);\n    float d7 = plane(vec3(sd, 0.0, 0.0) - p.zyx, d.zyx);\n    \n    return min(min(min(d2, d5), min(d3, d6)), min(min(d1, d7), d4));\n}\n\nvec3 dnorm(vec3 p)\n{\n\n    const vec2 h = vec2(EP,0);\n    return normalize(vec3(dist(p+h.xyy) - dist(p-h.xyy),\n                          dist(p+h.yxy) - dist(p-h.yxy),\n                          dist(p+h.yyx) - dist(p-h.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    fragCoord = 2.0*(fragCoord - iResolution.xy*0.5) / max(iResolution.x, iResolution.y);\n\n    vec3 camera = vec3(0.1*cos(iTime/1.0), 0.0, 0.15);\n    vec3 lightpos = vec3(0.1, 0.1, 0.1);\n    \n    vec4 light = vec4(sin(iTime/2.0)+1.1, cos(3.14*iTime/3.0)+1.1, sin(1.41*iTime)+1.1,1.0);\n      \n    float od = 0.0;\n    \n    vec3 ray = camera;\n    vec3 stp = vec3(fragCoord.xy, 0.75) - camera;\n    for(int i = 0; i < 10; i++){\n        stp = normalize(stp);\n        float d = dist(ray, stp);\n        \n        od += d;\n        if(isnan(od) || isinf(od))\n            break;\n        \n        ray = ray + stp*d;\n        vec3 dn = dnorm(ray);\n\n        d = dist(lightpos, ray - lightpos);\n        vec3 lr = lightpos + d*(ray - lightpos);\n        if(!isnan(d) && length(lr - ray) < EP){\n            vec3 ldn = normalize(lightpos - ray);\n            vec3 refl = reflect(ldn, dn);\n            \n            float l  = max(dot(ldn, dn), 0.0);\n            float l2 = max(dot(refl, stp), 0.0);\n            float ld = length(lightpos - ray);\n\n            fragColor += 2.5*(0.002*l + 0.01*pow(l2,64.0))*light / (ld*od);\n        }\n        \n        stp = reflect(stp, dn);\n        ray += EP * dn;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}