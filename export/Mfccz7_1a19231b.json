{"ver":"0.1","info":{"id":"Mfccz7","date":"1730399406","viewed":85,"name":"stare into the void","username":"jakekinchen","description":"big lightning blob","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["cool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash function and constants\nconst float TAU = 6.28318530718;\nconst int MAX_STEPS = 150;\nconst float FRACTAL_ITERATIONS = 8.0;\n\n// Improved hash function\nfloat hash21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Complex number operations\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(dot(a, b), a.y*b.x - a.x*b.y) / denom;\n}\n\n// Enhanced rotation with recursive elements\nmat2 hyperRot(float angle, float recursion) {\n    float s = sin(angle + recursion * 0.1);\n    float c = cos(angle - recursion * 0.15);\n    return mat2(c, s, -s, c);\n}\n\n// Fractal distortion field\nvec3 fractalDistort(vec3 p, float time) {\n    float amp = 1.0;\n    vec3 result = p;\n    vec3 pp = p;\n    \n    for(int i = 0; i < 5; i++) {\n        pp.xz *= hyperRot(time * 0.1 + float(i), length(pp));\n        pp.xy *= hyperRot(time * 0.15 + float(i) * 0.5, length(pp.yz));\n        \n        vec3 q = abs(fract(pp) - 0.5);\n        float qq = dot(q, q);\n        q = abs(q) / (qq + 0.001);\n        \n        result += q * amp;\n        amp *= 0.7;\n        pp *= 1.5;\n        pp += sin(time * 0.2 + float(i));\n    }\n    \n    return result;\n}\n\n// Hyperbolic space transformation\nvec3 hyperTransform(vec3 p, float time) {\n    vec2 z = p.xy;\n    float iter = 0.0;\n    \n    for(int i = 0; i < 7; i++) {\n        z = cmul(z, z) + 0.7*vec2(cos(time*0.2), sin(time*0.3));\n        vec2 z2 = cdiv(z, vec2(length(z) + 0.0001));\n        z = mix(z, z2, 0.5 + 0.5*sin(time * 0.1));\n        iter += length(z);\n    }\n    \n    return vec3(z, iter);\n}\n\n// Modified triangle tiling with dimensional folding\nvec4 dimensionalTiling(vec2 uv, float time) {\n    vec2 gv = fract(uv * 2.0) - 0.5;\n    vec2 id = floor(uv * 2.0);\n    \n    float minDist = 1e10;\n    vec2 cellId = vec2(0);\n    \n    for(float y = -1.; y <= 1.; y++) {\n        for(float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            float h = hash21(id + offset);\n            vec2 v = offset + sin(time + h * TAU) * 0.5;\n            float d = length(gv - v);\n            \n            if(d < minDist) {\n                minDist = d;\n                cellId = id + offset;\n            }\n        }\n    }\n    \n    float cells = minDist;\n    float pattern = 1.0 - smoothstep(0.05, 0.1, cells);\n    \n    return vec4(cellId, cells, pattern);\n}\n\n// Enhanced SDF operations\nfloat sdHyperbox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sceneSDF(vec3 p, float time) {\n    vec3 p1 = fractalDistort(p, time);\n    vec3 hyperP = hyperTransform(p, time);\n    \n    float scale = 1.0 + 0.5 * sin(time * 0.3);\n    float box = sdHyperbox(p1, vec3(scale));\n    \n    // Create recursive geometry\n    float d = box;\n    float s = 1.0;\n    for(int i = 0; i < 5; i++) {\n        vec3 q = mod(p1 * s, 2.0) - 1.0;\n        float bd = sdHyperbox(q, vec3(0.7)) / s;\n        d = min(d, bd);\n        s *= 1.8;\n    }\n    \n    return d * 0.5;\n}\n\nvec3 colorPalette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    t += iTime * 0.1;\n    return a + b * cos(TAU * (c * t + d + sin(t * 0.2)));\n}\n\n// Recursive detail generation\nfloat recursivePattern(vec2 uv, float scale) {\n    float pattern = 0.0;\n    float amp = 0.5;\n    vec2 p = uv;\n    \n    for(int i = 0; i < 6; i++) {\n        float l = dot(p, p) + 0.001;\n        p = abs(p * 1.5) / l;\n        p *= hyperRot(iTime * 0.1 + float(i), l);\n        pattern += sin(p.x * scale) * cos(p.y * scale) * amp;\n        scale *= 1.2;\n        amp *= 0.7;\n    }\n    \n    return pattern;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Initialize dimensional blending\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    // Camera movement\n    ro.xz *= hyperRot(iTime * 0.2, 1.0);\n    rd.xz *= hyperRot(iTime * 0.1, 2.0);\n    \n    // Ray marching\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float acc = 0.0;\n    \n    // Dimensional folding pattern\n    vec4 tilingPattern = dimensionalTiling(uv * 2.0, iTime);\n    float pattern2D = recursivePattern(uv, 3.0);\n    \n    // Ray marching loop with dimensional blending\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p, iTime);\n        \n        // Accumulate color and glow\n        vec3 hyperColor = colorPalette(length(p) * 0.1 + float(i) * 0.01);\n        float glow = exp(-d * 4.0);\n        acc += glow;\n        \n        // Blend 2D and 3D patterns\n        float blend = sin(iTime * 0.2 + pattern2D) * 0.5 + 0.5;\n        col += hyperColor * glow * (1.0 - blend) + \n               colorPalette(tilingPattern.z) * glow * blend;\n        \n        if(d < 0.001 || t > 20.0) break;\n        t += d * 0.5;\n    }\n    \n    // Final color composition\n    col = col * 0.02 + acc * 0.01 * colorPalette(pattern2D);\n    \n    // Add hyperbolic patterns\n    vec3 hyperEffect = hyperTransform(vec3(uv * 2.0, pattern2D), iTime);\n    col += colorPalette(hyperEffect.z * 0.1) * 0.2;\n    \n    // Dynamic color enhancement\n    col *= 1.0 + sin(iTime * vec3(0.2, 0.3, 0.4));\n    \n    // Pulse effect\n    float pulse = sin(iTime * 0.5) * 0.5 + 0.5;\n    col *= 1.0 + pulse * 0.3;\n    \n    // HDR and tone mapping\n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.8));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}