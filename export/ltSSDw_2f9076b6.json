{"ver":"0.1","info":{"id":"ltSSDw","date":"1444071863","viewed":535,"name":"Wu's Line Algorithm","username":"Hamneggs","description":"I grew bored in class today and wrote a rough and dirty recreation of the Wu anti-aliased line algorithm. It's done in a fragment shader and hence on a per pixel basis though, which kind of takes away from the cool factor a bit.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["line","aliasing","distance","algorithm","wu","anti","xiaolin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n\tAuthor: Gerard Geer\n\tLicense: MIT\n\n\tWu's anti-aliased lines implemented in a fragment shader. Things are\n\ta bit different since we aren't iterating over individual pixels.\n\t\t\n\tA good reference for the original algorithm can be found here:\n\thttp://archive.gamedev.net/archive/reference/articles/article382.html\n*/\n\n\n// Just some mediocre-ly chosen sample line endpoints.\nconst vec2 a = vec2(1.0, 5.0);\nconst vec2 b = vec2(5.0, 9.0);\nconst vec2 c = vec2(4.0, 1.0);\nconst vec2 d = vec2(20.0, 5.0);\n\n/*\n\tPer-pixel Wu anti-aliased lines.\n\tIt's not really the same since we aren't iterating over\n\ta tiny subset of pixels, but hey it still embraces the\n\tspirit of the distance-to-actual-line==brightness idea of\n\tthe original algorithm. (with shortcut'd edge-cases to boot!)\n\t\n\tParameters:\n\ta: The first line endpoint.\n\tb: The second line endpoint.\n\tuv: The current pixel coordinate.\n\n\treturns: \n\tAn inverted brightness coefficient. (Okay actually just\n\tthe distance to the line capped at 1.0)\n\n*/\nfloat ppWu(in vec2 a, in vec2 b, in vec2 uv)\n{\n    // Zero length line test.\n    if(length(a-b)<1.0) return 1.0;\n    // Length 1 line test.\n    if(length(a-b)<2.0) return length(uv-(a+b)*.5);\n    // Vertical line test.\n    if(b.x == a.x)\n    {\n        if(uv.y > max(a.y,b.y) || uv.y < min(a.y,b.y)) return 1.0;\n        return min(1.0, abs(uv.x-a.x));\n    }\n\t// Horizontal line test.\n    if ( a.y == b.y )\n    {\n        if(uv.x > max(a.x,b.x) || uv.x < min(a.x,b.x)) return 1.0;\n        return min(1.0, abs(uv.y-a.y));\n    }\n    \n    // We'll need the slope for all other cases.\n    float s = (b.y-a.y) / (b.x-a.x);\n    \n    // If the line's major axis is the X axis...\n\tif(abs(s) < 1.0)\n    {\n        // Not on the line? welp.\n        if(uv.x > max(a.x,b.x) || uv.x < min(a.x,b.x)) return 1.0;\n        // The point at the current pixel along the line.\n        vec2 q = vec2(uv.x, a.y+(uv.x-a.y)*s);\n\t\t// Return the distance from the line.\n\t\treturn min(1.0,abs(uv.y-q.y));\n\t}\n    // If we're dealing with those pesky perfectly diagonal lines.\n    if(s == 1.0)\n    {\n        if(uv.x > max(a.x,b.x) || uv.x < min(a.x,b.x)) return 1.0;\n        return (uv.x-a.x == uv.y - a.y) ? 0.0 : 1.0;\n    }\n    // If the line's major axis is the y axis...\n\telse\n    {\n        // If we aren't next to the line, well...\n        if(uv.y > max(a.y,b.y) || uv.y < min(a.y,b.y)) return 1.0;\n        \n        // Since we are working in x(y), we invert the slope.\n        s = pow(s,-1.0);\n        // The point at the current pixel along the line.\n        vec2 q = vec2(a.x+(uv.y-a.y)*s, uv.y);\n        // Return the distance to the line.\n        return min(1.0,abs(uv.x-q.x));\n\t}\n}\n\n// \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized screen coordinates.\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    // Square-ish pixels.\n    uv.x *= iResolution.x/iResolution.y;\n    // Expand the coordinate space and floor it so we have\n    // blocky macro pixels.\n    uv = floor(uv*20.);\n    \n    // Draw some lines.\n    float pw = 0.0;\n    if(fract(iTime*.5)<.25)\n        pw = ppWu(a,b,uv);\n    else if(fract(iTime*.5)<.50)\n        pw = ppWu(b,c,uv);\n    else if(fract(iTime*.5)<.75)\n        pw = ppWu(c,d,uv);\n    else\n        pw = ppWu(d,a,uv);\n        \n\tfragColor = vec4(pw);\n}","name":"","description":"","type":"image"}]}