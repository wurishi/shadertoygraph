{"ver":"0.1","info":{"id":"ctsXDH","date":"1674694723","viewed":161,"name":"CLAUSTROPHOBIA","username":"ianertson","description":"Control the camera with the mouse,\nwalking is done automatically.","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["3d","raytracing","raymarching","rays","music","marching","raymarcher","cave","dark","claustrophobia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llBSDK","filepath":"https://soundcloud.com/the-glaive/cave_ambient?si=186c40b720744b8da2ae707581c3572f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/the-glaive/cave_ambient?si=186c40b720744b8da2ae707581c3572f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    ******** CLAUSTROPHOBIA ********\n    \n    Control the camera with the mouse,\n    walking is done automatically.\n    \n    --------------------------------\n\n\n\n    ////////// Credits /////////////\n    \n    Credit to https://soundcloud.com/the-glaive/cave_ambient\n    for the ambient cave sound.\n    \n    Credit to iq for the non-repeating textures:\n    https://www.shadertoy.com/view/lt2GDd\n    \n    ////////////////////////////////\n*/\n\n/* ------------------------------------------------------------- */\n\n//  ////////// Parameters /////////////\n\n\n// You can adjust the seed blow to change the\n// cave layout. (Needs to be a floating point value)\n#define SEED SEED_DEFAULT\n\n// make things a bit crazier\n#define CHAOS 0.09\n\n// how bumpy the walls are (default=M_PI)\n#define DIST_AMPLITUDE M_PI\n\n\n#define R iResolution.xy\n#define T (iTime*0.8)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n\n#define STEPS 48\n#define NEAR 0.003\n#define FAR 100.0\n#define SEED_DEFAULT (iDate.z + 0.5291)\n\n/* ------------------------------------------------------------- */\n\n\n\n// Thanks to iq for this: https://www.shadertoy.com/view/lt2GDd\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\n// Thanks to iq for this: https://www.shadertoy.com/view/lt2GDd\nvec4 textureNoTile( sampler2D samp, in vec2 uv )\n{\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n\n#ifdef USEHASH    \n    // generate per-tile transform (needs GL_NEAREST_MIPMAP_LINEARto work right)\n    vec4 ofa = texture( iChannel3, (iuv + vec2(0.5,0.5))/256.0 );\n    vec4 ofb = texture( iChannel3, (iuv + vec2(1.5,0.5))/256.0 );\n    vec4 ofc = texture( iChannel3, (iuv + vec2(0.5,1.5))/256.0 );\n    vec4 ofd = texture( iChannel3, (iuv + vec2(1.5,1.5))/256.0 );\n#else\n    // generate per-tile transform\n    vec4 ofa = hash4( iuv + vec2(0.0,0.0) );\n    vec4 ofb = hash4( iuv + vec2(1.0,0.0) );\n    vec4 ofc = hash4( iuv + vec2(0.0,1.0) );\n    vec4 ofd = hash4( iuv + vec2(1.0,1.0) );\n#endif\n    \n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n\n    // transform per-tile uvs\n    ofa.zw = sign(ofa.zw-0.5);\n    ofb.zw = sign(ofb.zw-0.5);\n    ofc.zw = sign(ofc.zw-0.5);\n    ofd.zw = sign(ofd.zw-0.5);\n    \n    // uv's, and derivarives (for correct mipmapping)\n    vec2 uva = uv*ofa.zw + ofa.xy; vec2 ddxa = ddx*ofa.zw; vec2 ddya = ddy*ofa.zw;\n    vec2 uvb = uv*ofb.zw + ofb.xy; vec2 ddxb = ddx*ofb.zw; vec2 ddyb = ddy*ofb.zw;\n    vec2 uvc = uv*ofc.zw + ofc.xy; vec2 ddxc = ddx*ofc.zw; vec2 ddyc = ddy*ofc.zw;\n    vec2 uvd = uv*ofd.zw + ofd.xy; vec2 ddxd = ddx*ofd.zw; vec2 ddyd = ddy*ofd.zw;\n        \n    // fetch and blend\n    vec2 b = smoothstep(0.25,0.75,fuv);\n    \n    return mix( mix( textureGrad( samp, uva, ddxa, ddya ), \n                     textureGrad( samp, uvb, ddxb, ddyb ), b.x ), \n                mix( textureGrad( samp, uvc, ddxc, ddyc ),\n                     textureGrad( samp, uvd, ddxd, ddyd ), b.x), b.y );\n}\n\nfloat noise(vec2 uv, float ld) {\n    vec3 v = texture(iChannel2, vec3(uv, 1.)).xyz;\n    return v.r;\n}\n\nvec3 noiseSigned(vec3 uv, float ld) {\n    vec3 v = texture(iChannel2, uv).xyz;\n    vec3 s = texture(iChannel2, uv+vec3(-0.3291, 0.2291, 0.92815)).xyz;   \n    return v * mix(vec3(-1.), vec3(1.), s); // trick to get some random sign value\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n};\n\n// shape of cave\nvec3 getRamp(vec3 p) {\n    p = mix(p, p+p, CHAOS*2.0);\n    float fseed = fract(SEED / 1.6);\n    p += (min(1.0, SEED) * vec3(cos(SEED) + fseed, tan(SEED) + fseed, sin(SEED) + fseed));\n    vec3 n = noiseSigned(p*0.01, 0.);\n    vec3 n2 = noiseSigned(((p+n)/2.0)*0.06, 0.);\n    n = mix(n, n2, CHAOS);\n    n *= DIST_AMPLITUDE;\n    return n;\n}\n\nfloat getDist(vec3 p) {\n    vec3 offset = getRamp(p);\n    vec3 mag = abs(offset);\n    p += offset;\n    float magX = max(mag.x, 1.0);\n    float magY = max(mag.y, 1.0);\n    float magZ = max(mag.z, 1.0);\n    float r = 2.0-p.x;\n    float l = 2.0+p.x;\n    float t = 1.0-p.y;\n    float b = p.y+1.0;\n    return (min(min(l/magX, r/magX), min(t/magY, b/magY)));\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.2, 0.0);\n    return normalize(getDist(p) - vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)\n    ));\n}\n\nvec2 getUv(in Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    \n    float up = abs(dot(n, vec3(0.0, 1.0, 0.0)));\n    float left = abs(dot(n, vec3(1.0, 0.0, 0.0)));\n    float front = abs(dot(n, vec3(0.0, 0.0, 1.0)));\n    \n    // unrolled \"sort\"\n    int idx = 0;\n    float maxDist = -100.;\n    if (up > maxDist) { maxDist = up; idx = 0; }\n    if (left > maxDist) { maxDist = left; idx = 1; }\n    if (front > maxDist) { maxDist = front; idx = 2; }\n    \n    switch (idx) {\n        case 0: return p.xz; break;\n        case 1: return p.zy; break;\n        case 2: return p.xy; break;\n    }\n    \n    return p.xz;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    data.dist = FAR;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    vec3 normal = getNormal(p);\n    \n    data.point = p;\n    data.normal = normal;\n    data.dist = dist;\n    data.uv = getUv(data);\n    \n    return true;\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 dir;\n    vec3 color;\n    float strength;\n};\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -4.0 + T);\n    \n    vec3 ramp = getRamp(ro);\n    \n    ro.y = 0.0 - (ramp.y*0.89);\n    ro.x = 0.0 - ramp.x;\n    \n    ro.y += (0.5+(0.5*cos(T*16.)))*0.09;\n    ro.x += sin(T*2.)*0.25;\n    \n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    float yaw = 0.0;\n    float pitch = 0.0;\n    \n    if (iMouse.z > 0.01) {\n        pitch  = m.y*TAU;\n        yaw = m.x*TAU;\n    } else {\n        pitch = sin(T)*0.25;\n        yaw = cos(T)*0.33;\n\n    }\n    \n    rd.yz *= rot(pitch);\n    rd.xz *= rot(yaw);\n    \n    // used to orient the flashlight.\n    vec3 camdir = normalize(vec3(\n        sin(yaw),\n        tan(pitch),\n        cos(yaw)\n    ));\n    \n    if (iMouse.z <= 0.01) camdir.xz *= rot((ramp.x+sin(T*0.87))*0.25);\n    \n    Light light = Light(ro, camdir, vec3(0.96, 0.89, 0.79), 8.);\n    float ambient = 0.06;\n    \n    Data data;\n    data.point = vec3(0.0);\n    data.normal = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    if (march(ro, rd, data)) {\n        float tile = 1.0;\n        data.uv *= 0.25;\n        float id = floor((data.point.z)*tile);\n        float NdotL = max(0.0, dot(data.normal, normalize(light.dir)));\n        float distLight = distance(data.point, light.pos);\n        vec3 ld = normalize(light.dir);\n        vec3 sd = normalize(data.point - light.pos);\n        float cone = max(0.0, dot(sd, ld));\n        float att = NdotL*light.strength*smoothstep(0.8, 1.0, cone);\n        float z = id;\n        vec3 albedo0 = textureNoTile(iChannel0, data.uv).rgb;\n        vec3 albedo1 = textureNoTile(iChannel1, data.uv).rgb;\n        float n0 = noise(data.uv, 4.);\n        vec3 albedo = mix(albedo0, albedo1, n0*n0);\n        vec3 diffuse = albedo / M_PI;\n        col += diffuse * light.color*att;\n        col /= max(NEAR, data.dist);\n        col += diffuse * ambient;\n    }\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(0.53715));\n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}