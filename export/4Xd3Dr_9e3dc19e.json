{"ver":"0.1","info":{"id":"4Xd3Dr","date":"1716546294","viewed":37,"name":"Floating Boxes a la H. Bartnig","username":"hissanova","description":"The moving version of the following shader.\nhttps://www.shadertoy.com/view/wltyz7","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["horstbartnig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.1415926\nconst float M = 16.0;\n\nvec3 WHITE = vec3(1.0,1.0,1.0) - 0.05;\nvec3 BLACK = vec3(0.0,0.0,0.0) + 0.25;\nvec3 GREEN = vec3(0.0,0.5,0.5) - 0.05;\nvec3 ORANGE = vec3(0.75,0.5,0.0) + 0.05;\n\nconst vec2 BASE1 =  vec2(6.0, 1.0),\n           DIR1 = vec2(1.0, 1.0/BASE1.x)/M,\n           DIR2 = vec2(-1.0, 1.0/BASE1.x)/M,\n           BOX_SIZE = vec2(1.0, 2.2)/(2.0*M),\n           OFFSET1 =  vec2(0.0, 0.0),\n           OFFSET2 = 2.0*BOX_SIZE + vec2(0.0, 0.4),\n           OFFSET3 = vec2(0.0, -0.2),\n           OFFSET4 = 2.0*BOX_SIZE + vec2(0.0, 0.2);\n\nvec3 paint(vec2 uv, vec3 col_original, vec3 col_new, vec2 offset, vec2 dir){\n    vec2 inf, sup;\n    float hash1 = hash21(dir);\n    bool in_x_interval, in_y_interval;\n    for (int i=0; i<3*int(M);i++){\n        float freq = hash1 + 10.*hash11(float(i));\n        vec2 perturb = vec2(0.0, 0.03*sin(freq*iTime + 10.*hash11(float(i))));\n        inf = mod(offset + float(2*i)*dir - perturb, BASE1);\n        sup = mod(offset + float(2*i)*dir + 2.0*BOX_SIZE + perturb, BASE1);\n        //inf = mod(offset + float(2*i)*dir, BASE1);\n        //sup = mod(offset + float(2*i)*dir + 2.0*BOX_SIZE + vec2(0.0, 0.05*sin(t)), BASE1);        \n        in_x_interval = inf.x < sup.x ?\n                        inf.x < uv.x && uv.x < sup.x :\n                        inf.x < uv.x || uv.x < sup.x;\n        in_y_interval = inf.y < sup.y ?\n                        inf.y < uv.y && uv.y < sup.y :\n                        inf.y < uv.y || uv.y < sup.y;\n        if (in_x_interval && in_y_interval){\n            float min_dist = min(abs(uv.y-sup.y), abs(uv.y-inf.y));\n            float mixture = smoothstep(0.0, 0.01, min_dist);        \n            return mix(col_original, col_new, mixture);\n        }\n    }\n    return col_original;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 5.0 * fragCoord/iResolution.x;\n\n    vec3 col;\n    float theta = PI/4.0;\n    //float theta = .0;\n    uv =  mod(uv + vec2(cos(theta), sin(theta)) * .3 * iTime, BASE1);\n    float x = uv.x * M;\n    int column = int(x);\n    col = column % 2 == 0 ? BLACK : WHITE;\n    \n    vec2 offset, dir;\n    vec3 col_new;\n    switch (column % 4) {\n    case 0:\n        dir = DIR1;\n        offset =  OFFSET1;\n        col_new = ORANGE;\n        break;\n    case 1:\n        dir = DIR1;\n        offset = OFFSET2;\n        col_new = GREEN;\n        break;\n    case 2:\n        dir = DIR2;\n        offset = OFFSET3;\n        col_new = ORANGE;\n        break;\n    case 3:\n        dir = DIR2;\n        offset = OFFSET4;\n        col_new = GREEN;\n        break;\n    }    \n    col = paint(uv, col, col_new, offset, dir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hsv2rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nuvec4 k = uvec4(0x456789abu, 0x6789ab45u, 0x89ab4567u, 0xab456789u);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << 1);\n    n ^= (n >> 1);\n    n *= k.x;\n    n ^= (n << 1);\n    return n * k.x;\n} \nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\n\nuvec4 u = uvec4(1, 2, 3, 4);\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u.xyz);\n    n ^= (n.yzx >> u.xyz);\n    n *= k.xyz;\n    n ^= (n.yzx << u.xyz);\n    return n * k.xyz;\n}\nuvec4 uhash44(uvec4 n){\n    n ^= (n.yzwx << u);\n    n ^= (n.yzwx >> u);\n    n *= k;\n    n ^= (n.yzwx << u);\n    return n * k;\n}\n\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nfloat hash41(vec4 p){\n    uvec4 n = floatBitsToUint(p);\n    return float(uhash44(n).x) / float(UINT_MAX);\n}\n\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\nfloat vnoise31(vec3 p){\n    vec3 n = floor(p);\n    float[8] v;\n    for (int k = 0; k< 2; k++){\n        for (int j = 0; j < 2; j++){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = hash31(n + vec3(i, j, k));\n            }\n        }\n    }\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float[2] w;\n    for (int i = 0; i <2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return mix(w[0], w[1], f[2]);\n}\nvec3 vnoise33(vec3 p){\n    vec3 n = floor(p);\n    vec3[8] v;\n    for (int k = 0; k< 2; k++){\n        for (int j = 0; j < 2; j++){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = hash33(n + vec3(i, j, k));\n            }\n        }\n    }\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec3[2] w;\n    for (int i = 0; i <2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return mix(w[0], w[1], f[2]);\n}\n\nfloat gnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j<2; j++){\n        for (int i = 0; i<2; i++){\n            vec2 g = normalize(hash22(n + vec2(i,j)) - vec2(0.5));\n            v[i+2*j] = dot(g, f - vec2(i,j));\n        }\n    }\n    f = f*f*f*(10.0 - 15.0*f + 6.0*f*f);\n    return 0.5 + 0.5*mix(mix(v[0], v[1], f[0]), mix(v[2], v[3],f[0]), f[1]);\n}\nfloat gnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k<2; k++){\n        for (int j = 0; j<2; j++){\n            for (int i = 0; i<2; i++){\n                vec3 g = normalize(hash33(n + vec3(i,j,k)) - vec3(0.5));\n                v[i+2*j+4*k] = dot(g, f - vec3(i,j,k));\n            }\n        }\n    }\n    f = f*f*f*(10.0 - 15.0*f + 6.0*f*f);\n    float plane1 = mix(mix(v[0], v[1], f[0]), mix(v[2], v[3],f[0]), f[1]);\n    float plane2 = mix(mix(v[4], v[5], f[0]), mix(v[6], v[7],f[0]), f[1]);\n    return 0.5 + 0.5*mix(plane1, plane2, f[2]);\n}\n\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);\n    return ((ind & 1u) == 0u ? u: -u) + ((ind & 2u) == 0u ? v: -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j<2; j++){\n        for (int i = 0; i<2; i++){\n            v[i+2*j] = gtable2(n + vec2(i,j), f - vec2(i,j));\n        }\n    }\n    f = f*f*f*(10.0 - 15.0*f + 6.0*f*f);\n    return 0.5 + 0.5*mix(mix(v[0], v[1], f[0]), mix(v[2], v[3],f[0]), f[1]);\n}\nfloat gtable3(vec3 lattice, vec3 p){\n    uvec3 n = floatBitsToUint(lattice);\n    uint ind = uhash33(n).x >> 28;\n    float u = ind < 8u ? p.x : p.y;\n    float v = ind < 4u ? p.y : ind == 12u || ind == 14u ? p.x : p.z;\n    return ((ind & 1u) == 0u ? u: -u) + ((ind & 2u) == 0u ? v: -v);\n}\nfloat pnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k<2; k++){\n        for (int j = 0; j<2; j++){\n            for (int i = 0; i<2; i++){\n                v[i+2*j+4*k] = gtable3(n + vec3(i,j,k), f - vec3(i,j,k)) * 0.70710678;\n            }\n        }\n    }\n    f = f*f*f*(10.0 - 15.0*f + 6.0*f*f);\n    float plane1 = mix(mix(v[0], v[1], f[0]), mix(v[2], v[3],f[0]), f[1]);\n    float plane2 = mix(mix(v[4], v[5], f[0]), mix(v[6], v[7],f[0]), f[1]);\n    return 0.5 + 0.5*mix(plane1, plane2, f[2]);\n}\nfloat gtable4(vec4 lattice, vec4 p){\n    uvec4 n = floatBitsToUint(lattice);\n    uint ind = uhash44(n).x >> 27;\n    float u = ind < 24u ? p.x : ind < 30u ? p.y : p.z;\n    float v = ind < 6u ? p.y : ind < 12u ? p.z : ind < 18u ? p.z : ind < 24u ? p.w : ind < 27u ? p.z : p.w;\n    return ((ind & 1u) == 0u ? u: -u) + ((ind & 2u) == 0u ? v: -v);\n}\nfloat pnoise41(vec4 p){\n    vec4 n = floor(p);\n    vec4 f = fract(p);\n    float[16] v;\n    for (int l = 0; l<2; l++){\n        for (int k = 0; k<2; k++){\n            for (int j = 0; j<2; j++){\n                for (int i = 0; i<2; i++){\n                    v[i+2*j+4*k+8*l] = gtable4(n + vec4(i,j,k,l), f - vec4(i,j,k,l)) * 0.70710678;\n                }\n            }\n        }\n    }\n    f = f*f*f*(10.0 - 15.0*f + 6.0*f*f);\n    vec4 mixtures;\n    for (int j = 0; j<2; j++){\n        for (int i = 0; i<2; i++){\n            mixtures[i+2*j] = mix(mix(v[0+4*i+8*j], v[1+4*i+8*j], f[0]), mix(v[2+4*i+8*j], v[3+4*i+8*j],f[0]), f[1]);\n        }\n    }\n    return 0.5 + 0.5*mix(mix(mixtures[0], mixtures[1], f[2]), mix(mixtures[2], mixtures[3], f[2]), f[3]);\n}","name":"Common","description":"","type":"common"}]}