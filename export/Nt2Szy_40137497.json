{"ver":"0.1","info":{"id":"Nt2Szy","date":"1627955195","viewed":178,"name":"not a local laplacian filter","username":"ear7h","description":"An attempt at approximating local Laplacian filter (requires Gaussian blur) with the hardware MIPmap (uses box blur). LLFs are commonly used in image processing for various effects like shadow, highlight, and clarity.\n\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["mipmap","laplacian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n// To change the parameters see the common file.\n\n// resources:\n// * https://www.youtube.com/watch?v=t4mbrKYRmvs\n// * https://people.csail.mit.edu/sparis/publi/2011/siggraph/\n// * https://www.darktable.org/2017/11/local-laplacian-pyramids\n\nfloat linstep(float x, float lo, float hi) {\n    return clamp((x - lo) / (hi - lo), 0., 1.);\n}\n\nfloat gp_interp(float lum, vec2 uv, int level) { \n    float p;\n    float lo;\n    float hi;\n    \n    if (lum < L1) {\n        p = linstep(lum, L0, L1);\n        vec4 ch = gp(iChannel1, uv, level);\n        lo = ch.x;\n        hi = ch.y;\n    } else if (lum < L2) {\n        p = linstep(lum, L1, L2);\n        vec4 ch = gp(iChannel1, uv, level);\n        lo = ch.y;\n        hi = ch.z;\n    } else if (lum < L3) {\n        p = linstep(lum, L2, L3);\n        vec4 ch = gp(iChannel1, uv, level);\n        lo = ch.z;\n        hi = ch.w;\n    } else if (lum < L4) {\n        p = linstep(lum, L3, L4);\n        lo = gp(iChannel1, uv, level).w;\n        hi = gp(iChannel2, uv, level).x;\n    } else if (lum < L5) {\n        p = linstep(lum, L4, L5);\n        vec4 ch = gp(iChannel2, uv, level);\n        lo = ch.x;\n        hi = ch.y;\n    } else if (lum < L6) {\n        p = linstep(lum, L5, L6);\n        vec4 ch = gp(iChannel2, uv, level);\n        lo = ch.y;\n        hi = ch.z;\n    } else if (lum < L7) {\n        p = linstep(lum, L6, L7);\n        vec4 ch = gp(iChannel2, uv, level);\n        lo = ch.z;\n        hi = ch.w;\n    } else {\n        p = linstep(lum, L7, L8);\n        lo = gp(iChannel2, uv, level).w;\n        hi = REMAP(L8, lum);\n    }\n    \n    return (1. - p) * lo + p * hi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 g4 = gp(iChannel0, uv, 4);\n    float lum = luminance(g4);\n    float f4 = gp_interp(lum, uv, 4);\n    \n    vec4 g3 = gp(iChannel0, uv, 3);\n    lum = luminance(g3);\n    float f3 = gp_interp(lum, uv, 3);\n    \n    vec4 g2 = gp(iChannel0, uv, 2);\n    lum = luminance(g2);\n    float f2 = gp_interp(lum, uv, 2);\n    \n    vec4 g1 = gp(iChannel0, uv, 1);\n    lum = luminance(g1);\n    float f1 = gp_interp(lum, uv, 1);\n    \n    vec4 g0 = gp(iChannel0, uv, 0);\n    lum = luminance(g0);\n    float f0 = gp_interp(lum, uv, 0);\n    \n    vec4 g00 = gp(iChannel0, uv, -1);\n    lum = luminance(g0);\n    float f00 = gp_interp(lum, uv, -1);\n    \n    float f = texture(iChannel1, uv).x;\n    fragColor = g0;//vec4(vec3(f), 1.);\n    //return;\n\n    // laplace assemble\n    vec4 orig = texture(iChannel0, uv);\n    lum = f4 - (f2 - f3) - (f1 - f2) - (f0 - f1) - (f00 - f0);\n    float lum0 = luminance(orig);\n\n    // add color\n    fragColor = orig;//vec4(vec3(lum0), 1.);\n    if (uv.y > uv.x) {\n        // TODO: modify luminance of the color? ie. modify the value to a target luminance while preserving hue and saturation\n        // the expression of saturation has an absolute value so it'd be pain to try to use it a constraint\n        fragColor += lum - lum0;\n    }\n    \n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = pow(texture(iChannel0, uv), vec4(2.2));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float lum = luminance(texture(iChannel0, uv));\n     \n    fragColor.x = REMAP(L0, lum);\n    fragColor.y = REMAP(L1, lum);\n    fragColor.z = REMAP(L2, lum);\n    fragColor.w = REMAP(L3, lum);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float lum = luminance(texture(iChannel0, uv));\n\n    fragColor.x = REMAP(L4, lum);\n    fragColor.y = REMAP(L5, lum);\n    fragColor.z = REMAP(L6, lum);\n    fragColor.w = REMAP(L7, lum);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\n// The knobs to tweak the effects to understand what they do, see:\n// https://www.darktable.org/2017/11/local-laplacian-pyramids\n\n\n#define A  0.5\n// #define A  (iMouse.x/iResolution.x)\n#define BH (iMouse.x == 0. ? .8 : iMouse.x/iResolution.x)\n#define BL (iMouse.y == 0. ? .8 : iMouse.y/iResolution.y)\n#define S  0.2\n// #define S  (iMouse.y/iResolution.y)\n\n\n#define L0 .0\n#define L1 .125\n#define L2 .25\n#define L3 .375\n#define L4 .5\n#define L5 .625\n#define L6 .75\n#define L7 .875\n#define L8 1.\n\n#define REMAP(L, I) remap_curve(L,I,A,BH,BL,S)\n\nfloat rd(float x, float a) {\n    return pow(x, a);\n}\n\nfloat re(float x) {\n    return x;\n}\n\nfloat remap_curve(\n    float g,  // center\n    float i,  // current px\n    float a,  // detail parameter\n    float bh, // edge parameter hi\n    float bl, // edge parameter lo\n    float s   // threshold\n) {\n    a = tan(a * PI / 2.);\n    bh = tan(bh * PI / 2.);\n    bl = tan(bl * PI / 2.);\n\n    float delta = i - g;\n\n    \n    float v;\n    if (abs(delta) < s) {\n        v = s * rd(abs(delta)/s, a);\n    } else if (delta < 0.) {\n        v = bl * re(abs(delta) - s) + s;\n    } else {\n        v = bh * re(abs(delta) - s) + s;\n    }\n    \n    return g + sign(delta) * v;\n}\n\nfloat luminance(vec4 color) {\n    // return (color.r + color.b + color.g) / 3.;\n    return 0.2126 * color.r + 0.7162 * color.g + 0.0722 * color.b;\n}\n\n// get a pixel from a level of the (non actually) gaussian\n// pyramid. According to shadertoy-unoficial it's a box blur\nvec4 gp(sampler2D tex, vec2 uv, int layer) {\n    return textureLod(tex, uv, float(1 << layer));\n}","name":"Common","description":"","type":"common"}]}