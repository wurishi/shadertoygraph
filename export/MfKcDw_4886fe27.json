{"ver":"0.1","info":{"id":"MfKcDw","date":"1731966719","viewed":67,"name":"Rotating  squares","username":"Elsio","description":"seria essa a demonstração de que, se não precisaria uma função hexgrid() pra fazer isso, também não precisaria para fazer a própria grade de hexagonos?","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["square","box","animate","geometria"],"hasliked":0,"parentid":"lfVcz1","parentname":" Rotating hexagons"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 1, 3, 0) * pi/2.))\n#define H(p) fract(29.* sin(p + p) * sin(p).yx)\n#define pi acos(-1.)\n#define hex vec2(1, sqrt(3.))\n#define S(v) smoothstep(6./r.y, .0, v)\n\nfloat box(vec2 p, float b) {\n    p = abs(p) - b + .02;\n    return length(max(p, 0.)) - .02;\n}\n\nvoid hexgrid(vec2 u, out vec2 p, out vec2 id){\n    vec2\n      a = mod(u           , hex) - hex / 2.,\n      b = mod(u - hex / 2., hex) - hex / 2.;\n      \n    p = b;\n    dot(a, a) < dot(b, b)\n      ? id = floor(u / hex), p = a\n      : id = floor(u / hex - .5) + .1;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t = iTime * .1;\n    vec2 r = iResolution.xy, q, id;\n         u = 3. * (u - r / 2.) / r.y\n             + tanh(vec2(cos(t * 1.5), sin(t)) * 3.) \n             + tanh(vec2(cos(t * 3.), sin(t + t)) * 4. + 2.) \n             + 2.3 * tanh(vec2(sin(t + t), cos(t) * 3.) * 5. - 3.);\n             \n    hexgrid(u, q, id);\n    \n    q *= rot(\n             tanh(\n                 cos(\n                     iTime * .5 \n                     + 2. * pi * H(id).x \n                 ) * 5. + 3.\n             )\n         );\n         \n    o = vec4(H(id), H(id + .5)) * S(box(q, sqrt(2.) / 4.));\n    \n    if(iMouse.z > 0.) \n        o += S(abs(length(q) - .5));\n    o += S(length(q) - .03);\n}","name":"Image","description":"","type":"image"}]}