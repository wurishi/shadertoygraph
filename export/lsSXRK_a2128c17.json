{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct Ray\n{\n\tvec3 origin;\n    vec3 dir;\n};\n    \nstruct Plane\n{\n\tvec3 p;\n    vec3 n;\n};\n    \n    \nstruct Light\n{\n\n    float specular;\n    vec3 position;\n    float diffuse;\n};\n    \nstruct LightDir\n{\n\n    vec3 dir;\n    float diffuse;\n};\n    \n    \n    \nfloat noise(vec2 uv)\n{\n \treturn texture(iChannel0, uv).r;   \n}\n\nfloat fbm(vec2 p)\n{\n \tfloat f = 0.0;   \n    f += 0.5    * noise(p); p *= 2.07;\n    f += 0.250  * noise(p);\tp *= 2.03;\n    f += 0.125  * noise(p);\tp *= 2.05;\n    f += 0.0625 * noise(p);\tp *= 2.08;\n    f /= 0.9375;\n    return f;\n}\n\nmat4 rotateY(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( cosa, 0.0, -sena, 0.0,\n               0.0  , 1.0, 0.0, 0.0,\n               sena , 0.0, cosa , 0.0\t,\n               0.0  , 0.0, 0.0 , 1.0\t);\n}\n\nmat4 rotateX(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( 1.0, 0.0, 0.0, 0.0,\n             0.0,\tcosa , sena, 0.0,\n             0.0, -sena , cosa , 0.0,\n             0.0  , 0.0, 0.0 , 1.0\t);\n}\n\nmat4 rotateZ(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( cosa ,sena , 0.0,  0.0,\n                -sena, cosa, 0.0,   0.0,\n             \t0.0\t ,0.0  , 1.0,  0.0,\n             \t0.0  ,0.0  , 0.0,  1.0\t);\n}\n\n\n    \nbool intersectPlane(in Ray r, in Plane p, out vec3 c)\n{\n\tfloat dotP=dot(r.dir, p.n);\n\tif(abs(dotP)<0.001)\n\t\treturn false;\n\tfloat t=-(dot(r.origin,p.n)-dot(p.p,p.n))/dotP;\n\tc=r.origin+t*r.dir;\n\tif(t>0.0)\n        return true;\n\treturn false;\n}\n    \n\n\nvec3 camera(in vec3 dir)\n{\n    vec3 cam =  dir;\n   \n        \n    vec2 m = iMouse.xy;\n    m /= iResolution.xy;\n    float cosa = cos(m.x * 2.0 - 1.0);\n    float sena = sin(m.x * 2.0 - 1.0);\n    float cosb = cos(m.y * 2.0 - 1.0);\n    float senb = sin(m.y * 2.0 - 1.0);\n    mat4 rotY = rotateY(-(m.x * 2.0 - 1.0));\n    mat4 rotX = rotateX(m.y * 2.0 - 1.0);\n\n\n    cam = normalize(vec3(rotY *rotX *  vec4(cam, 0.0))); \n    \n   return cam;\n}\n\n#define FREQ 0.00725\n#define HIGH_MODIF 2.5\n#define NORMAL_OFFSET 0.1\n//#define QUAD_DEPTH\nconst vec4 fogColor = vec4(1.0, 0.8, 0.4, 1.0);\n#define MAX_DIST 17.0\n#define MIN_DIST 0.01\n#define DELTA_T\t0.01\n#define SUN_EXP 20.0\n#define IT 1024\nvec3 vSun = normalize(vec3(0.3, 0.4, -0.9));\nconst vec4 sunColor = vec4(0.9, 0.6, 0.1, 1.0);\n#define PHONG_SHADING\nfloat f(in vec2 v)\n{\n return (2.0 * fbm(v * FREQ) - 1.0) * HIGH_MODIF;   \n}\n\nvec3 getNormal( in vec3 p )\n{\n    vec3 n = vec3( f(vec2(p.x-NORMAL_OFFSET,p.z)) - f(vec2(p.x+NORMAL_OFFSET,p.z)),\n                         2.0 * NORMAL_OFFSET,\n                         f(vec2(p.x,p.z-NORMAL_OFFSET)) - f(vec2(p.x,p.z+NORMAL_OFFSET)) );\n    return normalize( n );\n}\n\nbool castRay( in vec3 ro, in vec3 rd, out float T , out vec3 N)\n{\n    const float delt = DELTA_T;\n    const float mint = MIN_DIST;\n    const float maxt = MAX_DIST;\n    \n   \tbool res = false;\n    vec3 p;\n    for(int i = 0; i < IT; ++i)\n   // for( float t = mint; t < maxt; t += delt )\n    {\n        //precission seems less important as we move far away\n        #ifdef QUAD_DEPTH\n      \tfloat dt = smoothstep(DELTA_T, 0.8, (float(i * i) / float(IT * IT)));\n        #else \n       \tfloat dt = DELTA_T;\n        #endif\n        float t =  dt * float(i)+ MIN_DIST;\n        p = ro + rd*t;\n        if( p.y < (f(p.xz)  ))\n        {\n            T = t - 0.5*delt;\n            \n           \tres = true;\n            break;\n        }\n    }\n    if(res) N = getNormal(p);\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = fogColor;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec2 ss = uv * 2.0 - vec2(1.0);//from 1.0 to -1.0\n\tss.y*= iResolution.y / iResolution.x;//aspect ratio\n\tRay cam;\n    cam.origin = vec3(0.0, sin(iTime * 1.1) * 1.0 + 2.0 ,-iTime * 2.0);\n    cam.dir = normalize(vec3(ss.x, ss.y, -1.0));\n    cam.dir = camera(cam.dir);\n    vec3 d = cam.dir;\n    vec3 o = cam.origin;\n    LightDir l;\n    l.dir= vSun;\n    l.diffuse = 1.7;\n\tPlane wp;\n    wp.n = vec3(0.0, 1.0, 0.0);\n    wp.p = vec3(0.0,0.0, 0.0);\n    vec3 n;\n    \n\tfloat t;\n    if(castRay(o, d, t, n))\n    {\n        //moar phong\n        //lets phong shading model\n        vec3 ip = o + d * t;\n        vec3 lv = l.dir;\n\n        float dif = max(0.3, dot(lv, n));\n        \n        float h = ((ip.y/ HIGH_MODIF) );\n        \n       \tvec4 mColor = mix(texture(iChannel1, 2.0 * ip.xy / HIGH_MODIF + vec2(1.0)) \n                          * mix(vec4(1.0), vec4(0.1,0.954, 0.3, 1.0), \n                      smoothstep(0.0, 1.0, h * 0.125)), vec4(1.0, 0.89, 0.97, 1.0), smoothstep(0.0, 1.0, h));\n        color\t= mix(fogColor, mColor, smoothstep(1.0, 0.0, (t ) / (DELTA_T * float(IT) + MIN_DIST)));\n        #ifdef PHONG_SHADING\n        color = l.diffuse * dif* color;\n        #endif\n        if(ip.y < 0.0)\n        {\n            //compute intersection point\n            //interscetion with the water\n            //o.y + m.y = 0.0\n            //m.y = -o.y\n            //m.x = \n            Ray r;\n            r.dir = d;\n            r.origin = o;\n            \n            vec3 m;\n            intersectPlane(r, wp, m);\n           \n            //reflect\n            vec3 d = reflect(d,wp.n);\n            if(castRay(m, d, t, n))\n            {\n                vec3 newip = m + d * t;\n                h = newip.y / MAX_DIST;\n                vec4 mColor = mix(texture(iChannel1, 2.0 * newip.xy / HIGH_MODIF + vec2(1.0)) \n                          * mix(vec4(1.0), vec4(0.1,0.954, 0.3, 1.0), \n                      smoothstep(0.0, 1.0, h * 0.125)), vec4(1.0, 0.89, 0.97, 1.0), smoothstep(0.0, 1.0, h));\n                color = mix(mColor, color, 0.8);\n            }\n            else\n            {\n                color\t= mix(fogColor, color, smoothstep(1.0, 0.0, (t ) / (DELTA_T * float(IT) + MIN_DIST)));\n                \n            }\n            color = mix(color, vec4(0.0,0.1, 0.9, 1.0), 0.2);\n            \n            \n        }\n        \n        //color = vec4(n,1.0);//l.diffuse * d  ;  \n        \n       t = t / (MAX_DIST);\n        float tInv = 1.0/t;\n        //height fog color\n        color = mix(color, vec4(0.0, 0.1, 0.4, 1.0), smoothstep(0.3, -0.6, h * tInv));\n        //color = vec4(t / 50.0, t  / 50.0 , t  / 50.0, 1.0);\n    }\n    \n    //get the angle from the view to the sun\n    float s = pow(max(0.0, dot(cam.dir, l.dir)), SUN_EXP);\n   \tcolor = mix(color, sunColor, smoothstep(0.0, 1.0, s));\n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsSXRK","date":"1413671216","viewed":297,"name":"Terrain with Water","username":"bolt304","description":"Terrain with water reflection modifcated from the prev one I did","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["terrainreflection"],"hasliked":0,"parentid":"","parentname":""}}