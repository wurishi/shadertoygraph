{"ver":"0.1","info":{"id":"l3sBRl","date":"1728787824","viewed":59,"name":"basic truchet 02","username":"jorge2017a2","description":"basic truchet 02","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["basictruchet02"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por Jorge2017a2\n///---12-oct-2024\n//basic truchet 02\n//referencia color jt  //https://www.shadertoy.com/view/M3lBRl\n\n\nconst float esc = 3.0;\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n//#define S3(d,b) smoothstep(1.0/antialiasing(0.5),0. , d - (b) )\n\n\n#define S3(d,b) smoothstep( 1.5*esc/iResolution.y, -1.5*esc/iResolution.y , d - (b) ) \n\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DFS(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut;\n  return colOut;\n}\n\n\n\n\nfloat Sdf_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Sdf_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Sdf_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\n// Function to rotate a 2D point by an angle\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\n\n// Function to generate a random number based on tile position\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\nfloat sop1(vec2 p)\n{\n\nvec2 A,B, med,pr;\nfloat dfin;\nfloat  r1,ang, he ;\n\nA=vec2(0.00675676,0.01351351);\nr1=0.5574324;\nfloat d1=sdCircle(p-A,r1);\n\nA=vec2(0.00675676,0.01351351);\nr1=0.4324324;\nfloat d2=sdCircle(p-A,r1);\n\nd2=Sdf_D(d1,d2);\n\n\nA=vec2(0.9932432,1.0);\nr1=0.5540541;\nfloat d3=sdCircle(p-A,r1);\n\nA=vec2(0.9932432,1.0);\nr1=0.4358108;\nfloat d4=sdCircle(p-A,r1);\nd4=Sdf_D(d3,d4);\n\n\nfloat dout=min(d2, d4);\n    return dout;\n}\n\n\nfloat sop2(vec2 p)\n{\nvec2 A,B, med,pr;\nfloat dfin;\nfloat  r1,ang, he ;\n\nA=vec2(0.0,1.0);\nr1=0.4358108;\nfloat d1=sdCircle(p-A,r1);\n\nA=vec2(0.0,1.0);\nr1=0.5574324;\nfloat d2=sdCircle(p-A,r1);\nd2=Sdf_D(d2,d1);\n\n\nA=vec2(0.9932432,0.00675676);\nr1=0.5574324;\nfloat d3=sdCircle(p-A,r1);\n\nA=vec2(0.9932432,0.00675676);\nr1=0.4324324;\nfloat d4=sdCircle(p-A,r1);\nd4=Sdf_D(d3,d4);\n\nfloat dout=min(d2, d4);\n\nreturn dout;\n\n}\n\n\nfloat sop3(vec2 p)\n{\nvec2 A,B, med,pr;\nfloat dfin;\nfloat  r1,ang, he ;\n\nA=vec2(0.5,0.5);\nmed=vec2(0.06756756,0.52950676);\n\nfloat d1=sdBox(p-A,med);\n\nA=vec2(0.5,0.5);\nmed=vec2(0.567568,0.06587838);\n\nfloat d2=sdBox(p-A,med);\n\n    float  dout=min(d1,d2);\n    return dout;\n}\n\n\n\nfloat sop4(vec2 p)\n{\nvec2 A,B, med,pr;\nfloat dfin;\nfloat  r1,ang, he ;\n\nA=vec2(0.5,0.5);\nmed=vec2(0.567568,0.06587838);\nfloat d1=sdBox(p-A,med);\n\nA=vec2(0.5,0.5);\nmed=vec2(0.06756756,0.5560676);\nfloat d2=sdBox(p-A,med);\n\n\nfloat dt=Sdf_U(d2,d1);\n\nA=vec2(0.4966216,0.5);\nr1=0.3141892;\nfloat d3=sdCircle(p-A,r1);\n\nA=vec2(0.4966216,0.5);\nr1=0.1824324;\nfloat d4=sdCircle(p-A,r1);\n\nd4=Sdf_D(d3,d4);\n    float dout=min(dt,d4);\n    \n\n    return dout;\n}\n\n\n\nvec3 hash32(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    uv -= vec2(0.0,-0.5);\n    \n    uv *= esc;\n    uv += iTime * 0.5;\n    vec2 pos = uv;\n    vec3 col = vec3(0.0);\n    \n    vec2 tile = floor(uv);\n    pos = fract(uv) - 0.5;\n    \n    // Use random function to get a random rotation for each tile (0, 90, 180, 270 degrees)\n    float rotation = floor(random(tile) * 4.0) * PI / 2.0;\n    \n    // Rotate position to create the random tile orientation\n    pos = rotate(pos, rotation);\n    \n    // Generate a random number to choose between sop1, sop2, sop3, sop4\n    float choice = random(tile);\n    float dist = 0.0;\n\n    if (choice < 0.25) {\n        dist = sop1(pos + vec2(0.5, 0.5));\n      \n    } else if (choice < 0.5) {\n        dist = sop2(pos + vec2(0.5, 0.5));\n      \n    } else if (choice < 0.75) {\n        dist = sop3(pos + vec2(0.5, 0.5));\n      \n    } else {\n        dist = sop4(pos + vec2(0.5, 0.5));\n      \n    }\n    \n    \n    dist=abs(dist)-0.01;\n//col = DFS(vec3(1.0, 0.0, 1.0), col, dist);  \n   \n     //referencia color jt  //https://www.shadertoy.com/view/M3lBRl\n     vec3 color = hash32(tile);\n//col = DFS(vec3(1.0, 0.0, 1.0), col, dist);  \ncol = DFS(color+vec3(0.0,0.0,0.3), col, dist);  \n\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}