{"ver":"0.1","info":{"id":"fdtczs","date":"1653974165","viewed":411,"name":"Progressive PathTracer 1 by Omni","username":"Omniscience","description":"Progressive raytracer featuring random gaussian based specular sampling, accumulation and supersampling, incomplete/simplified BDRF radiance model, and simple PBR materials. Also features FlyCam from my other projects: WASD/RF/QE/mouselook controls.","likes":27,"published":1,"flags":48,"usePreview":0,"tags":["gi","raytrace","pathtrace","bdrf","flycam"],"hasliked":0,"parentid":"fstczl","parentname":"Statefulness - FlyCam by Omni"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec4 samples = texture(iChannel0, fragCoord * kres);\n    \n    fragColor = vec4(samples.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793238462643327950;\nconst float PI_BY_90 = PI / 90.0;\nconst float DEG_TO_RAD = PI / 180.0;\nconst vec3 FWD = vec3(0.0, 0.0, 1.0);\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst vec3 RIGHT = vec3(1.0, 0.0, 0.0);\nconst vec3 ZERO3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ONE3 = vec3(1.0, 1.0, 1.0);\n\nfloat lerp(float a, float b, float x) { return a + (b-a) * x; }\nvec3 lerp(vec3 a, vec3 b, float x) { return a + (b-a) * x; }\n\nmat4 identity() {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 translate(vec3 pos) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        pos.x, pos.y, pos.z, 1.0\n    );\n}\nmat4 rotateX(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateY(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateZ(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixFromQuat(vec4 q) {\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    \n    float xy = x*y, xz = x*z, yz = y*z,\n          xw = x*w, yw = y*w, zw = z*w;\n    \n    return identity() + 2.0 * mat4(\n        -(y2 + z2),  (xy + zw),  (xz - yw), 0.0,\n         (xy - zw), -(x2 + z2),  (yz + xw), 0.0,\n         (xz + yw),  (yz - xw), -(x2 + y2), 0.0,\n               0.0,        0.0,        0.0, 0.0\n    );\n}\n\nvec4 quatConjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    float ax = a.x, ay = a.y, az = a.z, aw = a.w;\n    float bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    return vec4(\n        aw*bx + ax*bw + ay*bz - az*by,\n        aw*by + ay*bw + az*bx - ax*bz,\n        aw*bz + az*bw + ax*by - ay*bx,\n        aw*bw - ax*bx - ay*by - az*bz\n    );\n}\n\nvec3 qmulv(vec4 q, vec3 v) {\n    vec4 vq = vec4(v, 0.0);\n    vec4 c = quatConjugate(q);\n    q = qmul(q, vq);\n    q = qmul(q, c);\n    return q.xyz;\n}\nvec4 qmulv(vec4 q, vec4 v) {\n    return vec4(qmulv(q, v.xyz), v.w);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    angle *= 0.5;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec4(\n        axis.x * sa,\n        axis.y * sa,\n        axis.z * sa,\n        ca\n    );\n}\n\nvec4 quatFromEulerDeg(vec3 euler) {\n    float ex = euler.x, ey = euler.y, ez = euler.z;\n    float ep = ex * PI_BY_90,\n          eq = ey * PI_BY_90,\n          er = ez * PI_BY_90,\n        sinp = sin(ep),\n        siny = sin(eq),\n        sinr = sin(er),\n        cosp = cos(ep),\n        cosy = cos(eq),\n        cosr = cos(er);\n    vec4 q = vec4(\n        sinr * cosp * cosy - cosr * sinp * siny,\n        cosr * sinp * cosy + sinr * cosp * siny,\n        cosr * cosp * siny - sinr * sinp * cosy,\n        cosr * cosp * cosy + sinr * sinp * siny\n    );\n    return normalize(q);\n}\n\nstruct Transform {\n    vec3 pos;\n    vec4 rot;\n};\n\nTransform t_identity() {\n    return Transform(ZERO3, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 matrixFromTransform(Transform xform) {\n    mat4 m = identity();\n    m *= translate(xform.pos);\n    m *= matrixFromQuat(xform.rot);\n    return m;\n}\n\nconst vec4 gSeed = vec4(12.9898, 77.233, 143.66337, 23.53277);\n\nfloat hash(float p) { return fract(sin(p * gSeed.x)*43758.5453123); }\nfloat hash(vec2 p) { return fract(sin(dot(p, gSeed.xy))*43758.5453123); }\n\nvec2 rand2(float p) {\n    vec2 s = vec2(p+7.123, p+11.521) * gSeed.xy;\n    return vec2(hash(s.x), hash(s.y));\n}\nvec3 rand3(float p) {\n    vec3 s = vec3(p+7.123, p+11.521, p+13.67) * gSeed.xyz;\n    return vec3(hash(s.x), hash(s.y), hash(s.z));\n}\n\nvec2 randBoxMuller(vec2 U) {\n    float R = sqrt(-2.0 * log(max(U.x, EPSILON)));\n    float t = 2.0 * PI * max(U.y, EPSILON);\n    return vec2(\n        R*cos(t),\n        R*sin(t)\n    );\n}\n\nvec3 gauss3(vec3 v, float std, float p) {\n    vec2 seed = rand2(p);\n    vec2 r = std * randBoxMuller(seed);\n    vec4 q = qmul(\n        quatFromAxisAngle(RIGHT,  r.x),\n        quatFromAxisAngle(UP,     r.y)\n    );\n    return qmulv(q, v);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define STATE_LENGTH   5.0\n#define STATE_LENGTH_I 5\n\n#define STATE_FLAGS 0.5\n#define STATE_POS   1.5\n#define STATE_ROT   2.5\n#define STATE_VEL   3.5\n#define STATE_MOUSE 4.5\n\n#define STATE_FLAGS_I 0\n#define STATE_POS_I   1\n#define STATE_ROT_I   2\n#define STATE_VEL_I   3\n#define STATE_MOUSE_I 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec2 uvi = fragCoord;\n    vec2 uv = uvi * kres;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (uvi.y < 1.0 && uvi.x < STATE_LENGTH) {\n        vec4 state[] = vec4[] (\n            texture(iChannel0, vec2(0.5, 0.5) * kres),\n            texture(iChannel0, vec2(1.5, 0.5) * kres),\n            texture(iChannel0, vec2(2.5, 0.5) * kres),\n            texture(iChannel0, vec2(3.5, 0.5) * kres),\n            texture(iChannel0, vec2(4.5, 0.5) * kres)\n        );\n        \n        vec4 flags = state[STATE_FLAGS_I];\n        \n        // Catch initial load and set default values\n        if (flags.x != 1.0) {\n            flags.x = 1.0;\n            state[STATE_FLAGS_I] = flags;\n            \n            state[STATE_POS_I] = vec4(0.0, 1.0, -5.0, 0.0);\n            state[STATE_ROT_I] = quatFromAxisAngle(RIGHT, 5.0 * DEG_TO_RAD);\n        }\n        \n        // Controls\n        vec4 kbW = texture(iChannel1, vec2(87.0/256.0, 0.0));\n        vec4 kbA = texture(iChannel1, vec2(65.0/256.0, 0.0));\n        vec4 kbS = texture(iChannel1, vec2(83.0/256.0, 0.0));\n        vec4 kbD = texture(iChannel1, vec2(68.0/256.0, 0.0));\n        vec4 kbR = texture(iChannel1, vec2(82.0/256.0, 0.0));\n        vec4 kbF = texture(iChannel1, vec2(70.0/256.0, 0.0));\n        vec4 kbQ = texture(iChannel1, vec2(81.0/256.0, 0.0));\n        vec4 kbE = texture(iChannel1, vec2(69.0/256.0, 0.0));\n        \n        vec4 prevMouse = state[STATE_MOUSE_I];\n        state[STATE_MOUSE_I] = iMouse;\n        if (prevMouse.z != iMouse.z)\n            prevMouse = iMouse;\n        vec4 dMouse = iMouse - prevMouse;\n        \n        vec2 sensitivity = vec2(1.5, 2.0);\n        \n        // Rotation\n        float roll = (kbQ.x - kbE.x) * 0.02;\n        vec2 mouse_norm = dMouse.xy * kres * sensitivity;\n        vec3 angles = vec3(-mouse_norm.y, mouse_norm.x, roll);\n        \n        vec4 rot = state[STATE_ROT_I];\n        rot = qmul(rot, quatFromAxisAngle(FWD, angles.z));\n        rot = qmul(rot, quatFromAxisAngle(UP, angles.y));\n        rot = qmul(rot, quatFromAxisAngle(RIGHT, angles.x));\n        \n        state[STATE_ROT_I] = rot;\n        \n        // Translation\n        vec4 velocity = state[STATE_VEL_I];\n        \n        vec4 accel = vec4(kbD.x - kbA.x, kbR.x - kbF.x, kbW.x - kbS.x, 0.0);\n        accel *= 0.0125;\n        accel = qmulv(rot, accel);\n        \n        velocity += accel;\n        velocity *= 0.875;\n        \n        state[STATE_VEL_I] = velocity;\n        state[STATE_POS_I] += velocity;\n        \n        // Write\n        color = state[int(uvi.x - 0.5)];\n    }\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    float ior;\n};\nconst Material BLACK      = Material(vec3(0.125).xxx       , 0.125, 0.625, 1.5);\nconst Material WHITE      = Material(vec3(0.875).xxx       , 0.375, 0.625, 1.5);\nconst Material BACKGROUND = Material(vec3(0.5, 0.75, 1.0), 1.0, 0.0, 1.0);\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Contact {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\nconst Contact NO_CONTACT = Contact(false, ZERO3, ZERO3, BACKGROUND);\n\nstruct Sample {\n    vec3 light;\n    Contact contact;\n};\n\nContact raySphereContact(Ray ray, Sphere sphere) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    float r2 = r*r;\n    vec3 L = C - O;\n    \n    float tca = dot(L, ray.dir);\n    //if (tca < 0.0) return NO_CONTACT;\n    \n    float d2 = dot(L, L) - tca*tca;\n    if (d2 > r2) return NO_CONTACT;\n    \n    float thc = sqrt(r2 - d2);\n    float t0 = min(tca - thc, tca + thc);\n    if (t0 < 0.0) return NO_CONTACT;\n    \n    vec3 P = O + t0 * D;\n    \n    return Contact(true, P, normalize(P - C), sphere.material);\n}\n\nfloat seed(float x, vec3 c) { return x + dot(c,c) + fract(iTime/100.0); }\n\nconst float _m = 0.05;\nconst float _M = 0.95;\nconst float _r = 0.125;\nconst vec3 _c = vec3(0.5, 0.25, 0.0);\nconst float _kR = 0.1;\nconst float _kM = 0.5;\nconst float _ior = 1.5;\n\nconst int NUM_OBJECTS = 9;\nconst Sphere objects[] = Sphere[](\n    Sphere(vec3(-2.5, 1.0, -2.5), 1.0, Material(_c, _m, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, -2.5), 1.0, Material(_c, _m, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, -2.5), 1.0, Material(_c, _m, _M, _ior)),\n    Sphere(vec3(-2.5, 1.0, 0.0), 1.0, Material(_c, 0.5, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, 0.0), 1.0, Material(_c, 0.5, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, 0.0), 1.0, Material(_c, 0.5, _M, _ior)),\n    Sphere(vec3(-2.5, 1.0, 2.5), 1.0, Material(_c, _M, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, 2.5), 1.0, Material(_c, _M, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, 2.5), 1.0, Material(_c, _M, _M, _ior))\n);/*\nconst Sphere objects[] = Sphere[](\n    Sphere(vec3(-2.5, 1.0, -2.5), 1.0, Material(vec3(0.0, 0.0, 0.0), 0.0)),\n    Sphere(vec3(0.0,  1.0, -2.5), 1.0, Material(vec3(_m, _m, _m), 0.125)),\n    Sphere(vec3(2.5,  1.0, -2.5), 1.0, Material(vec3(_M, _M, _M), 0.5)),\n    Sphere(vec3(-2.5, 1.0, 0.0), 1.0, Material(vec3(_M, _m, _m), _r)),\n    Sphere(vec3(0.0,  1.0, 0.0), 1.0, Material(vec3(_m, _M, _m), _r)),\n    Sphere(vec3(2.5,  1.0, 0.0), 1.0, Material(vec3(_m, _m, _M), _r)),\n    Sphere(vec3(-2.5, 1.0, 2.5), 1.0, Material(vec3(_M, _M, _m), _R)),\n    Sphere(vec3(0.0,  1.0, 2.5), 1.0, Material(vec3(_m, _M, _M), _R)),\n    Sphere(vec3(2.5,  1.0, 2.5), 1.0, Material(vec3(_M, _m, _M), _R))\n);*/\n\nconst int MAX_DEPTH = 4;\n\nContact sampleRayOnce(Ray ray) {\n    Contact best = NO_CONTACT;\n    float bestDist = 0.0;\n    \n    for (int i=0; i<NUM_OBJECTS; ++i) {\n        Contact contact = raySphereContact(ray, objects[i]);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n\n    if (ray.dir.y < 0.0 && ray.pos.y > 0.0) {\n        float y = ray.pos.y;\n        float aspect = y / ray.dir.y;\n        float h = -1.0 * aspect;\n        vec3 pos = ray.pos + ray.dir * h;\n\n        Material mat = BLACK;\n        bool bx = fract(pos.x * 0.5) < 0.5;\n        bool bz = fract(pos.z * 0.5) < 0.5;\n        if (bx ^^ bz) mat = WHITE;\n        \n        Contact contact = Contact(true, pos, UP, mat);\n        \n        float d = distance(ray.pos, contact.position);\n        if (!best.hit || d < bestDist) {\n            best = contact;\n            bestDist = d;\n        }\n    }\n    \n    if (!best.hit) {\n        best.material.albedo = texture(iChannel1, ray.dir).xyz;\n        //best.material.albedo = BACKGROUND.albedo * lerp(0.5, 1.25, pow(1.0 - ray.dir.y, 1.5));\n        best.material.albedo *= best.material.albedo;\n    }\n    \n    return best;\n}\n\nSample sampleRay(Ray ray) {\n    Contact firstContact = NO_CONTACT;\n    vec3 light = ZERO3;\n    vec3 absorbtion = vec3(1.0).xxx;\n    \n    for (int depth=0; depth<MAX_DEPTH; ++depth) {\n        Contact contact = sampleRayOnce(ray);\n        Material mtl = contact.material;\n        \n        if (depth == 0) firstContact = contact;\n        \n        if (contact.hit) {\n            float ior = mtl.ior;\n            float F0 = abs((1.0 - ior) / (1.0 + ior));\n            F0 *= F0;\n            //F0 = lerp(F0, mtl.albedo, mtl.metallic);\n            \n            float dp = clamp(-dot(ray.dir, contact.normal), 0.0, 1.0);\n            float kfresnel = pow(1.0 - dp, 5.0);\n            float fresnel = F0 + (1.0 - F0) * kfresnel;\n            \n            float roughness = mtl.roughness;\n            roughness *= roughness;\n            \n            vec3 idealRef = reflect(ray.dir, contact.normal);\n            vec3 ref = gauss3(idealRef, roughness, seed(1.0 + float(depth), ray.pos + ray.dir));\n            ray = Ray(contact.position, ref);\n            \n            float ks = fresnel;\n            float kd = (1.0 - ks) * (1.0 - mtl.metallic);\n            \n            light += kd * mtl.albedo * absorbtion;\n            absorbtion *= 1.0-fresnel;\n\n        }\n        else {\n            light += mtl.albedo * absorbtion;\n            break;\n        }\n    }\n    \n    return Sample(light, firstContact);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 kres = 1.0 / iResolution.xy;\n\n    vec4 state[] = vec4[] (\n        texture(iChannel0, vec2(0.5, 0.5) * kres),\n        texture(iChannel0, vec2(1.5, 0.5) * kres),\n        texture(iChannel0, vec2(2.5, 0.5) * kres),\n        texture(iChannel0, vec2(3.5, 0.5) * kres)\n    );\n    Transform xform = Transform(state[1].xyz, state[2]);\n    mat4 view = matrixFromTransform(xform);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 screenPos = vec4(-1.0 + 2.0 * fragCoord * kres, 0.0, 1.0);\n    screenPos.x *= aspectRatio;\n    \n    const float SUPERSAMPLE_STD = 0.0005;\n    \n    vec4 rayPos = view * vec4(ZERO3, 1.0);\n    vec3 rayDir = normalize(vec3(screenPos.xy, 2.0));\n    rayDir = mat3(view) * gauss3(rayDir, SUPERSAMPLE_STD, seed(0.0, screenPos.xyz));\n    Ray ray = Ray(rayPos.xyz, rayDir);\n    \n    Sample raySample = sampleRay(ray);\n    Contact contact = raySample.contact;\n    \n    vec4 prevColor = texture(iChannel3, fragCoord * kres);\n    vec3 nextColor = raySample.light;\n    \n    const float exposure = 600000.0;\n    const float kShutter = 1.0 / exposure;\n    \n    const float MIN_W = kShutter;\n    float w = 1.0;\n    \n    if (iMouse.z > 0.0) prevColor.w = 1.0;\n    \n    if (prevColor.w > 0.0) {\n        w = 1.0 / (1.0 / prevColor.w + 1.0);\n        \n        //vec3 err = clamp(nextColor - prevColor.xyz, 0.0, 1.0);\n        \n        /*vec3 err = abs(nextColor - prevColor.xyz);\n        err = err*err;\n        err = err*err;\n        float mse = (err.x + err.y + err.z) / 3.0;\n        //float mse = max(max(err.x, err.y), err.z);\n        w += pow(mse, 1.5) * 0.125;*/\n        w = clamp(w, MIN_W, 1.0);\n    }\n    \n    nextColor *= w;\n    nextColor += (1.0 - w) * prevColor.xyz;\n    \n    fragColor = vec4(nextColor, w);\n}","name":"Buffer B","description":"","type":"buffer"}]}