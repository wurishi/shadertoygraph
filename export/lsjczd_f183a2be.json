{"ver":"0.1","info":{"id":"lsjczd","date":"1494514614","viewed":267,"name":"Basic RT","username":"TinyTexel","description":"basic ray tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Basic RT\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nbasic ray tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\n/*\nvec3 CIERGB_to_sRGB(vec3 rgb)\n{\n    float sr = dot(rgb, vec3( 7.435473334463469   , -1.4082685200881504,  0.7807287336836757));\n    float sg = dot(rgb, vec3(-0.8069202350680907  ,  6.91617743120303  , -0.7501567836356445));\n    float sb = dot(rgb, vec3(-0.049776120246369425, -0.7791863027631802,  5.963731027857829 ));\n    \n    return vec3(sr, sg, sb);\n}\n//*/\n    \nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    \n    //if(false)\n    {\n    \tcol = 1.0 - exp2(-col * 3.0);\n        col = mix(col, col*col, 0.9);\n    }\n    \n    //col = vec3(col.r);\n    //col = CIERGB_to_sRGB(col) * 0.1;\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Basic RT\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nbasic ray tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n#define REF\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\n// shoulder of the ground truth s-curve\nfloat SCurveU_Sh(float x)\n{\n    float a = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 1.0 / 60.0 :\n              x < 0.75 ?  47.0 / 60.0 :\n                         -49.0 / 15.0 ;\n    \n    float b = x < 0.25 ?   2.0        :\n              x < 0.5  ?   7.0 /  3.0 :\n              x < 0.75 ? -17.0 /  3.0 :\n                          64.0 /  3.0 ; \n\n    float c = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 8.0 /  3.0 :\n              x < 0.75 ?  88.0 /  3.0 :\n                         -128.0/  3.0 ; \n\n    float d = x < 0.25 ?   0.0        :\n              x < 0.5  ?  32.0 /  3.0 :\n              x < 0.75 ? -160.0/  3.0 :\n                          128.0/  3.0 ; \n    \n    float e = x < 0.25 ?   0.0        :\n              x < 0.5  ? -64.0 /  3.0 :\n              x < 0.75 ?  128.0/  3.0 :\n                         -64.0 /  3.0 ;    \n    \n    float f = x < 0.25 ? -64.0 / 15.0 :\n              x < 0.5  ?  64.0 /  5.0 :\n              x < 0.75 ? -64.0 /  5.0 :\n                          64.0 / 15.0 ;  \n    \n    float r = a + x*(b + x*(c + x*(d + x*(e + x*f))));   \n    \n    return r;\n}\n\n// ground truth s-curve [-1..1]\nfloat SCurveU(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU_Sh(abs(x)) * s;\n}\n\n// ground truth s-curve [0..1]\nfloat SCurveU01(float x)\n{\n    return SCurveU(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n// bluish noise [-1..1]\n// high-pass filtered white noise\nfloat BNoise(vec2 uv, float fId, uvec3 id)\n{\n    float v = Hash(vec3(uv, fId), id);\n    \n    float v0 = Hash(vec3(uv + vec2(-1.0, 0.0), fId), id);\n    float v1 = Hash(vec3(uv + vec2( 1.0, 0.0), fId), id);\n    float v2 = Hash(vec3(uv + vec2( 0.0,-1.0), fId), id);\n    float v3 = Hash(vec3(uv + vec2( 0.0, 1.0), fId), id);\n    \n    float vf = v * 0.5 - (v0+v1+v2+v3) * 0.125;      \n    \n    vf = SCurveU(vf);\n    \n    return vf;  \n}\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n\n// primitive normals\n// see: http://people.tamu.edu/~ergun/research/implicitmodeling/papers/sm99.pdf\n\n#define Phi 1.618033988749895\n     // Phi sqrt(5)*0.5 + 0.5\n\nconst vec3 PrimN0 = vec3(1.0, 0.0, 0.0);\nconst vec3 PrimN1 = vec3(0.0, 1.0, 0.0);\nconst vec3 PrimN2 = vec3(0.0, 0.0, 1.0);\n\n#define a 0.5773502691896258\nconst vec3 PrimN3 = vec3( a, a, a);\nconst vec3 PrimN4 = vec3(-a, a, a);\nconst vec3 PrimN5 = vec3( a,-a, a);\nconst vec3 PrimN6 = vec3( a, a,-a);\n#undef a\n\n\n#define a 0.3568220897730899\n       //      1  / length(vec3(0, 1, phi+1))\n#define b 0.9341723589627156\n       // (phi+1) / length(vec3(0, 1, phi+1))\nconst vec3 PrimN7  = vec3(0.0,  a, b);\nconst vec3 PrimN8  = vec3(0.0, -a, b);\nconst vec3 PrimN9  = vec3( b, 0.0, a);\nconst vec3 PrimN10 = vec3(-b, 0.0, a);\nconst vec3 PrimN11 = vec3( a, b, 0.0);\nconst vec3 PrimN12 = vec3(-a, b, 0.0);\n#undef a\n#undef b\n\n\n#define a 0.5257311121191336\n       //  1  / length(vec3(0, 1, phi))\n#define b 0.85065080835204\n       // phi / length(vec3(0, 1, phi))\nconst vec3 PrimN13 = vec3(0.0,  b, a);\nconst vec3 PrimN14 = vec3(0.0, -b, a);\nconst vec3 PrimN15 = vec3( a, 0.0, b);\nconst vec3 PrimN16 = vec3(-a, 0.0, b);\nconst vec3 PrimN17 = vec3( b, a, 0.0);\nconst vec3 PrimN18 = vec3(-b, a, 0.0);\n#undef a\n#undef b\n\n\n//float Sgn(float v) { return v < 0.0 ? -1.0 : 1.0; }\n//vec2  Sgn(vec2  v) { return If(lessThan(v, vec2(0.0)), vec2(-1.0), vec2(1.0)); }\n//vec3  Sgn(vec3  v) { return If(lessThan(v, vec3(0.0)), vec3(-1.0), vec3(1.0)); }\n//vec4  Sgn(vec4  v) { return If(lessThan(v, vec4(0.0)), vec4(-1.0), vec4(1.0)); }\n//\n//float InvSgn(float v) { return v < 0.0 ? 1.0 : -1.0; }\n//vec2  InvSgn(vec2  v) { return If(lessThan(v, vec2(0.0)), vec2(1.0), vec2(-1.0)); }\n//vec3  InvSgn(vec3  v) { return If(lessThan(v, vec3(0.0)), vec3(1.0), vec3(-1.0)); }\n//vec4  InvSgn(vec4  v) { return If(lessThan(v, vec4(0.0)), vec4(1.0), vec4(-1.0)); }\n\nvoid Intersect_Ray_DSlab(\nvec3 rp, vec3 rd, \nvec3 sn,\nout vec2 t, out vec3 N)\n{\n    float PdN = dot(rp, sn);\n    float DdN = dot(rd, sn);\n    \n    N = DdN < 0.0 ? sn : -sn;\n    \n    float m = -1.0 / DdN;\n    \n    t.x = PdN * m - abs(m);\n\tt.y = PdN * m + abs(m);\n}\n\n\nvoid Intersect_Ray_DSlabBackside(\nvec3 rp, vec3 rd, \nvec3 sn,\nout float t, out vec3 N)\n{\n    float PdN = dot(rp, sn);\n    float DdN = dot(rd, sn);\n\n    N = DdN < 0.0 ? sn : -sn;\n    \n    float m = -1.0 / DdN;\n    \n    t = PdN * m + abs(m);\n}\n\nvoid Intersect_Ray_DSlab(\nvec3 rp, vec3 rd, \nvec3 sn,\nout vec3 t, out vec3 N)\n{\n    float PdN = dot(rp, sn);\n    float DdN = dot(rd, sn);\n\n    float sgn = DdN < 0.0 ? 1.0 : -1.0;\n    \n    N = sn * sgn;\n    \n    float sPdN = PdN * sgn;\n    \n    t = vec3(sPdN - 1.0, sPdN + 1.0, abs(DdN));\n}\n\nvoid Intersect_Ray_DSlabBackside(\nvec3 rp, vec3 rd, \nvec3 sn,\nout vec2 t, out vec3 N)\n{\n    float PdN = dot(rp, sn);\n    float DdN = dot(rd, sn);\n\n    float sgn = DdN < 0.0 ? 1.0 : -1.0;\n    \n    N = sn * sgn;\n    \n    t = vec2(PdN * sgn + 1.0, abs(DdN));\n}\n\n\nfloat Intersect_Ray_Cube2(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\trp /= cth;\n    rd /= cth;\n    \n\tIntersect_Ray_DSlab(rp, rd, PrimN0, OUT t, n0);\n    n1 = n0;\n    \n    vec2 tt; vec3 Nt;\n    \n    Intersect_Ray_DSlab(rp, rd, PrimN1, OUT tt, Nt);\n    if(tt.x > t.x) { t.x = tt.x; n0 = Nt; }\n    if(tt.y < t.y) { t.y = tt.y; n1 = Nt; }\n    \n    Intersect_Ray_DSlab(rp, rd, PrimN2, OUT tt, Nt);\n    if(tt.x > t.x) { t.x = tt.x; n0 = Nt; }\n    if(tt.y < t.y) { t.y = tt.y; n1 = Nt; }\n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside2(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\trp /= cth;\n    rd /= cth;\n    \n\tIntersect_Ray_DSlabBackside(rp, rd, PrimN0, OUT t, N);\n    \n    float tt; vec3 Nt;\n    \n    Intersect_Ray_DSlabBackside(rp, rd, PrimN1, OUT tt, Nt);\n    if(tt < t) { t = tt; N = Nt; }\n    \n    Intersect_Ray_DSlabBackside(rp, rd, PrimN2, OUT tt, Nt);\n    if(tt < t) { t = tt; N = Nt; }\t\n}\n\n\nvoid AddSlab(vec3 slabN, vec3 rp, vec3 rd, inout vec4 t, inout vec3 N0, inout vec3 N1)\n{\n    vec3 tt; vec3 Nt;\n    Intersect_Ray_DSlab(rp, rd, slabN, OUT tt, Nt); \n    \n    if(tt.x * t.z > t.x * tt.z) { t.xz = tt.xz; N0 = Nt; }\n    if(tt.y * t.w < t.y * tt.z) { t.yw = tt.yz; N1 = Nt; }\n}\n\nfloat Intersect_Ray_Ico(\nvec3 rp, vec3 rd, \nvec3 cp, float cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\trp /= cth;\n    rd /= cth;\n    \n    vec3 t1;\n    \n\tIntersect_Ray_DSlab(rp, rd, PrimN3, OUT t1, n0);\n\t//Intersect_Ray_DSlab(rp, rd, PrimN13, OUT t1, n0);\n    vec4 t2 = t1.xyzz;\n    \n    n1 = n0;\n    \n    #define AddS(slabN) AddSlab(slabN, rp, rd, REF t2, n0, n1);\n    AddS(PrimN4)\n    AddS(PrimN5)\n    AddS(PrimN6)\n    AddS(PrimN7)\n    AddS(PrimN8)\n    AddS(PrimN9)\n    AddS(PrimN10)\n    AddS(PrimN11)\n    AddS(PrimN12)\n    #undef AddS\n    //#define AddS(slabN) AddSlab(slabN, rp, rd, REF t2, n0, n1);\n    //AddS(PrimN14)\n    //AddS(PrimN15)\n    //AddS(PrimN16)\n    //AddS(PrimN17)\n    //AddS(PrimN18)\n    //#undef AddS\n        \n    t = t2.xy / t2.zw;    \n    \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n\nvoid AddSlabBackside(vec3 slabN, vec3 rp, vec3 rd, inout vec2 t, inout vec3 N)\n{\n    vec2 tt; vec3 Nt;\n    Intersect_Ray_DSlabBackside(rp, rd, slabN, OUT tt, Nt); \n    \n    if(tt.x * t.y < t.x * tt.y) { t = tt; N = Nt; }\n}\n\nvoid Intersect_Ray_IcoBackside(\nvec3 rp, vec3 rd, \nvec3 cp, float cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\trp /= cth;\n    rd /= cth;\n    \n    vec2 t2;\n    \n\tIntersect_Ray_DSlabBackside(rp, rd, PrimN3, OUT t2, N);\n    \n    #define AddS(slabN) AddSlabBackside(slabN, rp, rd, REF t2, N);\n    AddS(PrimN4 )\n    AddS(PrimN5 )\n    AddS(PrimN6 )\n    AddS(PrimN7 )\n    AddS(PrimN8 )\n    AddS(PrimN9 )\n    AddS(PrimN10)\n    AddS(PrimN11)\n    AddS(PrimN12)\n    #undef AddSlab\n    \n\t//Intersect_Ray_DSlabBackside(rp, rd, PrimN13, OUT t2, N);\n    //\n    //#define AddS(slabN) AddSlabBackside(slabN, rp, rd, REF t2, N);\n    //AddS(PrimN14)\n    //AddS(PrimN15)\n    //AddS(PrimN16)\n    //AddS(PrimN17)\n    //AddS(PrimN18)\n    //#undef AddS\n           \n    t = t2.x / t2.y;\n}\n\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n    \n\tvec3 m = -1.0 / rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -os * cth;\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n    \n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -os * cth;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    if(ub.x < ub.y) {t = ub.x; N = vec3(os.x, 0.0, 0.0);} else \n                    {t = ub.y; N = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t   ) {t = ub.z; N = vec3(0.0, 0.0, os.z);}\t\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvoid Intersect_Ray_SphereBackside(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout float t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = min(dot(rp, rp) - sr2, 0.0);\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\t//if(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(max(0.0, D));\n\n\tt = (-b + sqrtD) / a * 0.5;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(clamp01(1.0 - s1*s1));\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n\n// s [0..1]\nfloat Sample_HenyeyGreensteinPhF(float s, float g)\n{\t\n    if(abs(g) < 0.0001) return s * 2.0 - 1.0;\n\n    float g2 = g * g;\n\n    float t0 = (1.0 - g2) / (1.0 - g + 2.0 * g * s);\n\n    float cosAng = (1.0 + g2 - t0*t0) / (2.0 * g);\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_HenyeyGreensteinPDF(float s0, float s1, float g, vec3 forward)\n{\t\n    float cosTheta = Sample_HenyeyGreensteinPhF(s1, g);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n// s [0..1]\nfloat Sample_SchlickPhF(float s, float k)\n{\t\n    float t0 = 1.0 + k - 2.0 * s;\n    float t1 = 1.0 + k - 2.0 * s * k;\n\n    float cosAng = t0 / t1;\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_SchlickPDF(float s0, float s1, float k, vec3 forward)\n{\t\n    float cosTheta = Sample_SchlickPhF(s1, k);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nfloat HenyeyGreensteinPhF(float cosTheta, float g)\n{\n\tfloat g2 = g * g;\n\t\n\tfloat t0 = 1.0 - g2;\n\tfloat t1 = 1.0 + g2 - 2.0 * g * cosTheta;\n\t\n\t return t0 * rsqrt(max(0.0, t1*t1*t1));\n\t//return t0 * rsqrt(max(1.0e-32, t1*t1*t1));\n}\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhF(cosTheta, g) * RcpPi4;\n}\n\n\nfloat FresnelDielectricsP(float ci, float ct, float ni, float nt)\n{\n\tfloat t0 = nt * ci;\n\tfloat t1 = ni * ct;\n\t\n\treturn (t0 - t1) / (t0 + t1);\n}\n\nfloat FresnelDielectricsS(float ci, float ct, float ni, float nt)\n{\n\tfloat t0 = ni * ci;\n\tfloat t1 = nt * ct;\n\t\n\treturn (t0 - t1) / (t0 + t1);\n}\n\nfloat FresnelDielectrics(float ci, float ct, float ni, float nt)\n{\n\tfloat p = FresnelDielectricsP(ci, ct, ni, nt);\n\tfloat s = FresnelDielectricsS(ci, ct, ni, nt);\n\t\n\treturn (p*p + s*s) * 0.5;\n}\n\nvec3 ReflectRay(vec3 ray, vec3 N)\n{\n\tfloat ct = dot(-ray, N);\n\t\n\treturn ray + N * (2.0 * ct);\n}\n\n\n//cos2t (discriminant) < 0 -> total internal reflection\nvec3 RefractRay(vec3 ray, vec3 N, float n1, float n2, out float cos2t)\n{\n\tfloat n = n1 / n2;\n\tfloat NdL = dot(-ray, N);\n\n\tfloat sin2t = n*n * (1.0 - NdL*NdL);\n\tcos2t = 1.0 - sin2t;\n\t\n\tif(cos2t > 0.0)\n\tray = n * ray + (n * NdL - sqrt(cos2t)) * N;\n\t// else\n\t// ray = float3(1.0, 0.0, 0.0);\n\t\n\treturn ray;\n}\n\nvoid ReflRefrDielectrics(vec3 ray, vec3 N, float n1, float n2, \nout vec3 refl, out vec3 refr, out float re)\n{\n\tfloat cos2t;\n\n\trefl = ReflectRay(ray, N);\n\trefr = RefractRay(ray, N, n1, n2, cos2t);\n\t\n\tif(cos2t > 0.0)\n\tre = FresnelDielectrics(dot(-ray, N), sqrt(cos2t), n1, n2);\n\telse\n\tre = 1.0;\n}\n\n//s [0..1]\n// return(passed through boundary)\nbool ReflRefrDielectrics(vec3 ray, vec3 N, float n1, float n2, float s, \nout vec3 rayO)\n{\n\tvec3 refl, refr;\n\tfloat re;\n\tReflRefrDielectrics(ray, N, n1, n2, refl, refr, re);\n\t\n\tif(s < re)\n\t{\n\t\trayO = refl;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trayO = refr;\n\t\treturn true;\n\t}\n}\n\n\nconst vec3 PseudoSpectralRGBWeights_Box_W = 1.0 / vec3(0.25, 0.5, 0.25);\nvec3 Sample_PseudoSpectralRGBWeights_Box(float s)\n{\n\tvec3 fw = vec3(0.0);\n\t\n\tif(s < 0.25) fw.x = 1.0;\n\telse \n\tif(s < 0.75) fw.y = 1.0;\n\telse\t\t fw.z = 1.0;\n\t\n\treturn fw;\n}\n\nconst vec3 PseudoSpectralRGBWeights_Tri_W = 1.0 / vec3(0.25, 0.5, 0.25);\nvec3 Sample_PseudoSpectralRGBWeights_Tri(float s)\n{\n\tvec3 fw;\n\t\n\tif(s < 0.5)\n\t{\n\t\tfw.z = 0.0;\n\t\tfw.y = s * 2.0;\n\t\tfw.x = 1.0 - fw.y;\n\t}\n\telse\n\t{\n\t\tfw.x = 0.0;\n\t\tfw.z = s * 2.0 - 1.0;\n\t\tfw.y = 1.0 - fw.z;\n\t}\n\t\n\treturn fw;\n}\n\n\nconst vec3 PseudoSpectralRGBWeights_Tri2_W = vec3(3.0);\nvec3 Sample_PseudoSpectralRGBWeights_Tri2(float s)\n{\n\tvec3 fw;\n\t\n    s = s * 3.0;\n    \n    if(s < 1.0)\n    {\n        s *= 2.0;\n\n        float u = sqrt(s < 1.0 ? s : 2.0 - s);\n\n        if(s < 1.0) \n        {\n            fw.x = 2.0 - u;\n            fw.y = 1.0 - fw.x;\n            fw.z = 0.0;\n        }\n        else\n        {\n            fw.z = 2.0 - u;\n            fw.y = 1.0 - fw.z;\n            fw.x = 0.0;\n        }\n    }\n    else\n    {\n        s -= 1.0;\n        s *= 0.5;\n        \n        if(s < 0.5)\n        {\n            fw.z = 0.0;\n            fw.y = s * 2.0;\n            fw.x = 1.0 - fw.y;\n        }\n        else\n        {\n            fw.x = 0.0;\n            fw.z = s * 2.0 - 1.0;\n            fw.y = 1.0 - fw.z;\n        }\n    }\n    \n\treturn fw;\n}\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.35, Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    \n    float cdist = exp2(1.3 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n   // cpos.y -= 1.0;\n\n    float fId = frameAccu * 1.64683 + 0.84377;\n    \n    //vec3 pxId  = vec3(frameAccu != 0.0 ? frameAccu : Time, uv); \n    vec3 pxId  = vec3(frameAccu, uv);     \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    {\n        vec2 off;\n        {\n        \tfloat h0 = Hash(fId, 0xAF609A13u);\n        \tfloat h1 = Hash(fId, 0xE0ABC868u);\n        \n        \t//off = vec2(h0, h1) * 0.5;\n        \toff = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        }\n                      \n        tex21 = (uv0.xy + off) / PixelCount * 2.0 - vec2(1.0);\n    }\n    \n    vec2 llp = vec2(0.0);// local sample pos on lens\n    if(false)\n    {\n        float h0 = HashFlt(hh, 0x27BB116Bu);\n        float h1 = HashFlt(hh, 0x11A95B42u);\n\t\th1 = clamp01(h1 * 0.5 + 0.5);\n\n        llp = Sample_Disk(h0, h1);\n        llp *= 0.02;\n    }\n    \n    vec3 glp;// global sample pos on lens\n    float S1 = cdist - 0.0;// set cube ~sharp\n    vec3 rdir = NewRay(cam, tex21, llp, S1, OUT glp);\n \n    \n    vec2 lightAng = vec2(Pi * 0.3, 0.2 * Pi);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    vec3 lightp;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(0.999, 1.0, h1);\n        \n        lightp = Sample_Sphere(h0, h1, light);\n    }\n    \n    vec3 colW0, colW;\n    {\n        //float h0 = Hash(fId, 0x7F1489B8u);\n        float h0 = HashFlt(hh, 0x7F1489B8u);\n        h0 = BNoise(uv, fId, uvec3(0x281DFC85u, 0xB6A3C02Bu, 0x59F98C6Du));\n              h0 = clamp01(h0 * 0.5 + 0.5);\n        \n        //float ivals = 4.0;\n        //h0 = (mod(frameAccu, ivals) + h0) / ivals;\n        \n        colW0 = Sample_PseudoSpectralRGBWeights_Tri2(h0);\n        colW  = clamp01(colW0);\n    }\n    \n    //light = vec3(0.0, 1.0, 0.0);\n    float pot = 1.0;\n    //vec3 col = vec3(0.0);\n    float val = 0.0;\n    \n    float t = -1.0; vec2 tt;\n    vec3 pos = cpos + glp;\n    vec3 dir = rdir;\n\n\tfloat n2 = 1.5;\n\n    n2 = max(1.0, dot(vec3(1.2, 1.3, 1.4), colW0));\n    //n2 = max(1.0, dot(vec3(1.3083, 1.3111, 1.3163), colW0));// ice\n    //n2 = max(1.0, dot(vec3(1.4, 1.3, 1.2), colW0));\n    //n2 = max(1.0, dot(vec3(1.2) + 3.0 * (vec3(1.3163) - vec3(1.3083, 1.3111, 1.3163)), colW0));\n    //n2 = max(1.0, exp2(dot(log2(vec3(1.2) + 3.0 * (vec3(1.3163) - vec3(1.3083, 1.3111, 1.3163))), colW0)));\n    \n\n    bool exit = false;\n    \n    vec3 cs = vec3(1.0, 0.5, 0.25);\n    vec3 cp = vec3(0.5, -0.25, 0.125);\n    cp = vec3(0.0);\n    \n    //*\n    vec3 N0, N1;\n    //bool hit = Intersect_Ray_Cube2(pos, dir, cp, cs, OUT tt, N0, N1) > 0.0;\n    bool hit = Intersect_Ray_Ico(pos, dir, cp, 1.0, OUT tt, N0, N1) > 0.0;    \n    /*/\n    vec3 N0, N1;\n    bool hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), Pow2(1.0), OUT tt) > 0.0;\n    N0 = normalize(pos + dir * tt.x);\n\t//*/\n    \n    //if(hit)\n    //{\n    //    pos += dir * tt.x;\n    //    \n    //    float h0 = HashFlt(hh, 0x939D0B34u);\n    //          h0 = clamp01(h0 * 0.5 + 0.5);\n    //    \n    //    bool passed = ReflRefrDielectrics(dir, N0, 1.0, n2, h0, OUT dir);\n    //    \n    //    hit = passed;   \n    //}\n    \n\tif(hit)\n    {\n        pos += dir * tt.x;\n        \n        vec3 refl, refr;\n        float re;\n        ReflRefrDielectrics(dir, N0, 1.0, n2, refl, refr, re);\n\n        \n\t\tval += dot(textureLod(iChannel2, refl, 0.0).rgb, colW) * re;     \n        if(dot(refl, light) > 0.999) val += dot(vec3(3.0 * Pi), colW) * re;\n        \n        pot *= 1.0 - re;\n        dir = refr;\n        \n        //if(false)\n        for(float i = 0.0; i < 32.0; ++i)\n        {\n            hh = Hash(hh);\n            \n            //*\n            //Intersect_Ray_CubeBackside2(pos, dir, cp, cs, OUT t, N0);\n            Intersect_Ray_IcoBackside(pos, dir, cp, 1.0, OUT t, N0);            \n\t\t\t/*/\n            Intersect_Ray_SphereBackside(pos, dir, vec3(0.0), Pow2(1.0), OUT t);\n    \t\tN0 = -normalize(pos + dir * t);\n   \t\t\t//*/   \n            \n            pos += dir * t;\n\n            float h0 = HashFlt(hh, 0x2C2E74DAu);\n            h0 = clamp01(h0 * 0.5 + 0.5);\n\n            if(ReflRefrDielectrics(dir, N0, n2, 1.0, h0, OUT dir))\n            {\n                exit = true;\n\n                break;\n            }\n        }\n    }\n\n    \n   // if(false)\n    if(!hit || exit)\n    {\n        val += pot * dot(textureLod(iChannel2, dir, 0.0).rgb, colW);\n        \n        if(dot(dir, light) > 0.999) val += pot * dot(vec3(3.0 * Pi), colW);  \n        //col += 1.0;\n    }\n    \n    //if(false)\n    //if(hit && !exit)\n    //{\n    //    col = vec3(1.0, 0.0, 0.0);\n    //}\n    \n    vec3 col = colW * val * PseudoSpectralRGBWeights_Tri2_W;\n     \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}