{"ver":"0.1","info":{"id":"Ns2SWD","date":"1620262854","viewed":82,"name":"weird space gimbal thing","username":"livvy","description":"weird space gimbal thing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEP 500\n#define EPSILON 0.00001\n#define fGlobalTime iTime\n\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\nuniform float fFrameTime; // duration of the last frame, in seconds\n\nmat2 rot(float q) {\n  return mat2(\n    -sin(q), cos(q),\n     cos(q), sin(q)\n  );\n}\n\nfloat pln(vec3 p, vec3 n, float d)\n{\n  return dot(p, n) - d;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n  //p*=vec3(1.0,sin(fGlobalTime)+0.2,0.6);\n  \n  p.xy*=rot(fGlobalTime/0.5);\n  \n  p*=mat3(\n    1.0,              0.0,              0.0,\n    cos(fGlobalTime*.2), 1.0,              0.0,\n    0.0,              sin(fGlobalTime*.2), 1.0\n  );\n  return length(p) - r;  \n}\n\nfloat scene(vec3 p) {\n  vec3 c = vec3(0.0, 0.0, 8.0);\n  vec3 l = vec3(0.0, 0.0 , 0.0);\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n\t\n  q.xz *= rot(fGlobalTime/3.);\n  q.yz *= rot(fGlobalTime/3.);\n  vec3 r = q;\n  r.xz *= rot(fGlobalTime);\n  \n  \n\n  float objkt = min(min(\n     sdBoxFrame(q, vec3(0.,1.,1.), 0.054)-.1*0.2,\n     sdSphere(p, clamp(sin(fGlobalTime),0.2,0.25))\n  ), sdBoxFrame(r, vec3(0.,1.3,1.3), 0.04)-0.1*.2);\n  return objkt;\n  return min(objkt, pln(p, vec3(0., 1., 0.), -2.0));\n}\n\nvec3 normal(vec3 p)\n{\n    const float eps = EPSILON;\n    return normalize(\n      vec3(\n        scene(p + vec3(eps, 0, 0)) - scene(p - vec3(eps, 0, 0)),\n        scene(p + vec3(0, eps, 0)) - scene(p - vec3(0, eps, 0)),\n        scene(p + vec3(0, 0, eps)) - scene(p - vec3(0, 0, eps))\n      )\n    );\n}\n\n/*\nvec3 normal(vec3 p) {\n  return normalize(vec3(\n    scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)), \n    scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n    scene(vec3(p.x, p.y, p.z + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n  )); \n}\n*/\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fov) / 2.0);\n  return normalize(vec3(xy, -z));  \n}\n\nvec4 march(vec3 eye, vec3 dir, float start, float end)\n{\n  float depth = start;\n  for (int i=0; i<MAX_STEP; i++) {\n    vec3 p = eye + depth * dir;\n    float dist = scene(eye + depth * dir);\n    if (dist < EPSILON) {\n      return vec4(p, depth);\n    }\n    depth+=dist;\n    if(depth >= end) {\n      return vec4(p, end);  \n    }\n  }  \n}\n\nconst vec3 colors[5] = vec3[5](\n  vec3(0.99, 0.45, 0.20),\n  vec3(0.85, 0.26, 0.17),\n  vec3(0.94, 0.24, 0.36),\n  vec3(0.86, 0.31, 0.75),\n  vec3(0.80, 0.18, 0.98)\n);\n\n// PHONG SHADING\nvec3 phongLightContrib(vec3 kd, vec3 ks, float alpha,\n                       vec3 p, vec3 ro, vec3 lightpos,\n                       vec3 lightint)\n{\n  vec3 N = normal(p);\n  vec3 L = normalize(lightpos - p);\n  vec3 V = normalize(ro - p);\n  vec3 R = normalize(reflect(-L, N));\n  float dotLN = dot(L,N);\n  float dotRV = dot(R,V);\n  \n  if (dotLN < 0.0) return vec3(0.0);\n  if (dotRV < 0.0) return lightint * kd * dotLN;\n  return lightint * (kd * dotLN + ks * pow(dotRV, alpha));  \n}\n\n\nvec3 phong(vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 ro)\n{\n  const vec3 ambientLux = vec3(1.);\n  vec3 color = ambientLux * ka;\n  // LIGHT 1\n  color += phongLightContrib(kd, ks, alpha, p, ro, vec3(7.0, 5.0, 3.0), vec3(10.0));\n  return color;\n}\n\n\nvec3 getSceneColor(vec3 p, vec3 ro) {\n\n  vec3 c = colors[int(round(mod(fGlobalTime*1.,4.)))];\n  vec3 Kd = vec3(20.);     // AMBIENT  LIGHT\n  vec3 Ka = c;     // DIFFUSE  LIGHT\n  vec3 Ks = vec3(2.); // SPECTRAL LIGHT \n  float shine = 300.0;\n  \n  // APPLY PHONG\n  vec3 col = phong(Ka, Kd, Ks, shine, p, ro);\n  \n  return col;\n}\n\nvec3 getSceneColorBasic(vec3 p, vec3 ro) {\n  return colors[int(round(mod(fGlobalTime*1.,4.)))];  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  const float MIN_DIST = 0.;\n  const float MAX_DIST = 20.;\n  vec3 cam = vec3(0,0,9);\n  vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord.xy); \n  vec4 m = march(cam, dir, MIN_DIST, MAX_DIST);\n  vec3 p = m.xyz;  \n  vec3 col = vec3(.001,.0,.001);\n  // SHADE THE SCENE\n  if (m.a < MAX_DIST) {\n    col = getSceneColor(p, cam);\n    // ANTIALIASING\n    float AA_size = 16.0;\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < AA_size; aaY++)\n    {\n        for (float aaX = 0.0; aaX < AA_size; aaX++)\n        {\n            col += getSceneColorBasic(p - vec3(aaX, aaY, p.z) / AA_size, cam);\n            count += 1.0;\n        }\n    }\n    col /= count;\n   \n  }\n  // GAMMA CORRECTION\n  col = smoothstep(0.0,1.0,col);\n  col = pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}