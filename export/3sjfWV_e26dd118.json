{"ver":"0.1","info":{"id":"3sjfWV","date":"1590869907","viewed":613,"name":"Castle in the Sky","username":"fma","description":"A study at modeling complex shapes and environments. Nothing really fancy, just lots of tweaking.\nBased on the movie by Studio Ghibli.","likes":42,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","clouds","sky","castle","fxaa","reprojection","laputa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n-----------------\nCastle in the Sky\n-----------------\n\nA study at modeling complex shapes and environments. Nothing really fancy, just lots of tweaking.\nI started this shader years ago and decided to finish it.\nBased on the movie by Studio Ghibli\n\nThings to consider:\n- There's a lot of balancing between lookdev, performance and compilation times, so performance is not really 100%.\n- Sometimes the sound doesn't play automatically :( Go to Buffer B to enable it by pause/playing it\n- Slapped some FXAA without a lot of tweaking because I got lazy at the end\n- Code is ugly\n\nThanks to:\n- iq for all his raymarching/sdf articles and functions\n- mercury for sg_sdf\n- Dave_Hoskins for random hashes\n- reinder for their FXAA shadertoy port\n- Hamoudi Moneimne for feedback and anisotropic voronoi inspiration\n\nBuffers\n- A: Walls\n- B: Core, music\n- C: Top\n- D: Clouds\n- Image: Composition, glider\n\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n#define ENABLE_SCATTERING\n#define MAX_ITERATIONS 20\n#define MAX_ITERATIONS_FOREGROUND 75\n#define EPSILON 0.001\n\n#define ENABLE_FXAA\n#define ENABLE_COMPOSE\n#define BUFFER_DEBUG 3\n//#define ENABLE_RAW_DEBUG\n\n//#define DREAMY\n\n// Well known tonemapper, http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 FilmicTonemapping(vec3 x)\n{\n\treturn ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;\n}\n\nfloat sdf(vec3 p)\n{\n    return fCylinder(p, 2., .19);\n}\n\n//iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 d )\n{\n    return a + b * cos(6.28318 * (t + d));\n}\n\n// Color palette approach\nvec3 hsv2rgb_p(vec3 c) \n{\n    c = abs(c); //\n    float h = c.x;\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n     //\n    // Can remove some parameters, but I'll leave them as reference\t\n    return palette(h, vec3(s_n), vec3(s), vec3(1.0, 0.667, .3334));\n}\n \n// iq/aaltonen\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20; //\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdf(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.5*ph); //\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.001,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 ParticipatingMedia(vec2 uv, float hitDistance, float time)\n{\n    Ray ray = GetCameraRay(iFrame, uv, iMouse.xy/iResolution.xy);       \n    float stepSize = hitDistance / float(MAX_ITERATIONS);    \n    vec3 L = GetLightDirection();\n    \n    // Some small noise to hide marching artifacts\n    stepSize *= mix(.95, 1.0, hash12(uv * 1378.084567 + iTime));    \n    float unoccludedDistance = 0.0;\n    \n    for(float t = 0.0; t < hitDistance; t += stepSize)\n\t{\n        vec3 p = ray.origin + ray.direction * t;\n        float shadows = softshadow(p, L, .47, 5.0, 4.0);\n        unoccludedDistance += stepSize * smoothstep(-.2, 1.0, shadows);        \n\t}\n    \n    #ifdef DREAMY\n    vec3 extinction = (hsv2rgb_p(vec3(cos(iTime * .1))) + .1) * 50.0;\n    #else\n    vec3 extinction = vec3(1.05, .45, .25);\n    #endif\n    \n    extinction *= mix(0.0, 40.0, smoothstep(2.0, 45.0, time));\n    \n    return exp(-extinction / unoccludedDistance);\n}\n\nfloat OpeningFrame(vec2 screenPos, vec2 resolution, float s)\n{\n    float y = resolution.x / ASPECT_RATIO;\n    float offset = resolution.y / 2.0;\n    return smoothstep(s, 0.0, abs(offset - screenPos.y) - y * 0.5);\n}\n\n\nvec4 SampleScene(vec2 uv)\n{\n    vec4 buffers[4];\n    buffers[0] = texture(iChannel0, uv);\n    buffers[1] = texture(iChannel1, uv);\n    buffers[2] = texture(iChannel2, uv);\n    buffers[3] = texture(iChannel3, uv);\n    \n    vec4 result = buffers[0];\n    \n#ifdef ENABLE_COMPOSE\n    for(int b = 1; b < 4; ++b)\n        result = mix(result, buffers[b], smoothstep(.0, .1, result.w - buffers[b].w));\n#else\n    result = buffers[BUFFER_DEBUG];\n#endif\n    \n    result.rgb *= smoothstep(MAX_DISTANCE, MAX_DISTANCE - 1.5, result.w);\n    \n    return result;\n}\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\n// Shadertoy version from reinder: https://www.shadertoy.com/view/ls3GWS\n// Code from geeks3d, original from Timothy Lottes/NVIDIA:\n// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\nvec4 FxaaPixelShader( vec4 uv, vec2 rcpFrame) {\n    \n    vec4 rgbNW = SampleScene(uv.zw);\n    vec4 rgbNE = SampleScene(uv.zw + vec2(1,0)*rcpFrame.xy);\n    vec4 rgbSW = SampleScene(uv.zw + vec2(0,1)*rcpFrame.xy);\n    vec4 rgbSE = SampleScene(uv.zw + vec2(1,1)*rcpFrame.xy);\n    vec4 rgbM  = SampleScene(uv.xy);\n\n    vec4 luma = vec4(0.299, 0.587, 0.114, 0.0);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec4 rgbA = (1.0/2.0) * (\n        SampleScene(uv.xy + dir * (1.0/3.0 - 0.5)) +\n        SampleScene(uv.xy + dir * (2.0/3.0 - 0.5)));\n    vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        SampleScene(uv.xy + dir * (0.0/3.0 - 0.5)) +\n        SampleScene(uv.xy + dir * (3.0/3.0 - 0.5)));\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// iq\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// This could be done a bit better, but last minute tweaks :)\nvec3 GetGliderTransform(vec3 p, Ray camera)\n{\n    vec3 steadyPos = p;\n    vec3 introPos = p;\n    \n    introPos -= (camera.origin + camera.forward * .85);\n    introPos -= vec3(.5, 0.0, .2) * smoothstep(20.0, .0, iTime);\n    introPos.y += cos(iTime * .2) * .2 + .3 - smoothstep(1.5, 4.5, iTime) * .4;\n    introPos.y += smoothstep(10.0, 30.0, iTime) * 1.5;\n    \n    pR(introPos.xy, sin(iTime*.3));\n    \n    float t = iTime * .3;\n    vec2 offset = vec2(cos(t), sin(t));\n    \n    float circleTime = cos(t * 1.3) * 0.5 + 0.5;\n    steadyPos.xz += offset * mix(2.35, 3.5, sin(t*.75) * 0.5 + 0.5);\n    pR(steadyPos.xz, t);    \n    steadyPos.y -= .1 + mix(-.9, 1.6, circleTime);\n    pR(steadyPos.yx, cos(t * .2));\n    \n    p = introPos;\n    p = mix(introPos, steadyPos, smoothstep(15.0, 35.0, iTime));\n    \n    return p * mix(2.0, 1.75, smoothstep(15.0, 35.0, iTime));\n}\n\nfloat sdfMaterial(vec3 p, Ray camera)\n{\n    p = GetGliderTransform(p, camera);\n    return p.y > -.0 ? 1.0 : 0.0;\n}\n\nfloat sdf(vec3 p, Ray camera)\n{\n    p = GetGliderTransform(p, camera);\n    p.xyz = p.xzy;\n    \n    vec3 backP = p;\n    vec3 frontP = p;\n    vec3 bottomP = p;\n    \n    float wind =  mix(.9,1.0, sin((p.x+iTime)*40.0));\n    \n    p.y *= 1.3;\n    p.y += smoothstep(-.1, .75, p.y) * abs(sin(p.x * 90.0)) * .2;\n    p.z += abs(p.x) * wind * -.4;\n    \n    float d = sdTriPrism(p, vec2(.1, .0));\n    \n    backP.y -= .12;\n    backP.y *= -1.0;\n    backP.z -= abs(backP.x) * .2 + wind * .01 - .01;\n    d = min(d, sdTriPrism(backP, vec2(.02, .0)));\n    \n    bottomP.xyz = bottomP.xzy;\n    bottomP.zy += vec2(-.025, .015);\n    float r = smoothstep(.025, -.07, bottomP.z);\n    d = min(d, sdRoundedCylinder(bottomP, .03 * r, .005, .01));\n    \n\treturn d * .5;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon, Ray ray)\n{\n    vec3 normal = vec3(0.0);\n\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        vec3 offset = vec3(0.0);\n        offset[axis] = epsilon;\n        normal[axis] = sdf(p + offset, ray) - sdf(p - offset, ray);\n    }\n    \n    return normalize(normal);\n}\nvec3 Raymarch(Ray r)\n{\n    float t = 0.0;\n    float d = 0.0;\n    \n\tfor(int j = 0; j < MAX_ITERATIONS_FOREGROUND; j++)\n\t{\n\t\td = sdf(r.origin + r.direction * t, r);\n\n\t\tif(d < EPSILON)\n            break;\n        \n\t\tt += d;\n        \n        if(t > MAX_DISTANCE)\n            break;\n\t}\n    \n    t = min(t, MAX_DISTANCE);\n    \n    return vec3(t, 0.0, d);\n}\n\nvec3 Render(Ray ray, float t, float d)\n{\n    if(d > .1)\n\t\treturn vec3(0.0);\n    \n    vec3 p = SampleRay(ray, t);\n    float material = sdfMaterial(p, ray);\n    vec3 albedo = mix(vec3(.1, .05, .025), vec3(.65,.075, .075), material);\n    vec3 normal = sdfNormal(SampleRay(ray,t), .001, ray);\n    \n    float diffuse = smoothstep(-.3,1.0, dot(normal, GetLightDirection()));\n    return diffuse * albedo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool frame = Frame(fragCoord, iResolution.xy);\n    \n    float time = float(iFrame) / 60.0;\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    vec2 screenUV = fragCoord / iResolution.xy;  \n    \n#ifdef ENABLE_FXAA\n    vec2 rcpFrame = 1./iResolution.xy;\n    vec4 fxaaUV = vec4(screenUV, screenUV - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));    \n    vec4 result = FxaaPixelShader(fxaaUV, rcpFrame);\n#else\n    vec4 result = SampleScene(screenUV);\n#endif\n    \n    Ray ray = GetCameraRay(iFrame, uv, iMouse.xy/iResolution.xy);\n    vec3 fgTrace = Raymarch(ray);\n    vec3 foreground = Render(ray, fgTrace.x, fgTrace.z);\n    result = mix(result, vec4(foreground, fgTrace.x * 2.0), smoothstep(.0, .35, result.w - fgTrace.x));\n    \n    if(!frame)\n    \tresult = vec4(foreground, fgTrace.x);\n    \n    vec3 bg = vec3(0.29, .619, 1.5) * 0.9;\n    float vignette = 1.0 - pow(length(uv) / 2.5, 3.0);\n    \n    result.rgb *= smoothstep(MAX_DISTANCE, MAX_DISTANCE - 2.0, result.w);\n    \n#ifdef ENABLE_SCATTERING\n    result.rgb += ParticipatingMedia(uv, result.w, time);\n#endif\n\n    // Vignette\n    result.rgb = mix(result.rgb * result.rgb, result.rgb * 1.1, vignette * vignette);\n    \n    float whitePoint = mix(1.0, 15.0, smoothstep(0.0, 30.0, time));\n    \n    vec3 pixel = FilmicTonemapping(max(vec3(0.0), result.rgb) * 20.0);\n    vec3 whiteScale = 1.0 / FilmicTonemapping(vec3(whitePoint));\n    result.rgb = clamp(pixel*whiteScale, 0.0, 1.0);\n    \n#ifdef ENABLE_RAW_DEBUG\n    result = buffers[BUFFER_DEBUG];\n#endif\n    \n    float introTime = mix(.0, 1.0, smoothstep(0.0, 35.0, time));\n    vec2 frameRes = iResolution.xy * vec2(introTime *.99, 1.0); // .99 to hide edge artifacts\n    \n    // Make the glider actual foreground :)\n    if(time > 15.0 || fgTrace.x > MAX_DISTANCE - .2)\n    {\n        result *= OpeningFrame(fragCoord, frameRes, 2.0 + 6.0 * smoothstep(35.0, 0.0, time));\n        result *= smoothstep(0.0, 2.5, time);\n    }\n  \n    // No gamma helps the saturated look\n\tfragColor = result;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_DISTANCE 10.0\n#define PI 3.14159265\n#define TAU 6.28318530718\n\n//#define VIEW_ITERATIONS\n#define TEMPORAL_REPROJECTIION\n#define ANIMATE_SCENE\n//#define ENABLE_CONTROLS\n\n// Some functions are taken from hg_sdf, some from iq\n\n// hg\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = TAU/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Hashes by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nvec2 R2seq(const int n)\n{\n\treturn fract(vec2(n) * vec2(0.754877666246692760049508896358532874940835564978799543103, 0.569840290998053265911399958119574964216147658520394151385));\n}\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height); //\n\treturn d;\n}\n\n// A modification of the cylinder sdf to handle multiple at the same time\nvec3 fCylinder4(vec3 p, vec3 yOffset, vec3 r, vec3 height) {\n\tvec3 d = length(p.xz) - r;\n\td = max(d, abs(p.y-yOffset) - height);\n\treturn d;\n}\n\n// hg\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Majercik et al., A Ray-Box Intersection Algorithm and Efficient Dynamic Voxel Rendering \nbool slabs(vec3 p0, vec3 p1, vec3 rayOrigin, vec3 invRaydir) {\n    vec3 t0 = (p0 - rayOrigin) * invRaydir;\n    vec3 t1 = (p1 - rayOrigin) * invRaydir;\n    vec3 tmin = min(t0,t1), tmax = max(t0,t1);\n    return vmax(tmin) <= vmin(tmax);\n}\n\n#define ASPECT_RATIO 2.5\n\nbool Frame(vec2 screenPos, vec2 resolution)\n{\n    float y = resolution.x / ASPECT_RATIO;\n    float offset = resolution.y / 2.0;\n    return abs(offset - screenPos.y) < y * 0.5;\n}\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 forward;\n};\n    \nvec3 SampleRay(Ray ray, float t)\n{\n    return ray.origin + ray.direction * t;\n}\n\nRay GetCameraRay(int frame, vec2 uv, vec2 mouse)\n{   \n    // Problem of doing it this way is that it will be slow on fullscreen, but I want easy reproj stability\n    float time = float(frame) / 60.0;\n    vec3 target = vec3(0.0, .55, 0.0);\n    vec3 p = vec3(-3.56402609672, -1.25, 1.81596199896);\n    \n    // Simple animation\n    float introMask = smoothstep(45.0, 0.0, time);    \n    p += vec3(-1.0, -.7, 1.0) * introMask;\n    p += vec3(9.0, -1.5, 15.0) * smoothstep(25.0, -10.0, time);\n    target.y -= 10.0 * smoothstep(35.0, 0.0, time);\n    \n#ifdef ENABLE_CONTROLS\n    target.y += mouse.y * 3.5 - 1.25;\n#endif\n    \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(forward, left);\n    \n    float zoom = .635;\n#ifdef ENABLE_CONTROLS\n    zoom = clamp(.5 - mouse.x * .9, 0.01, 1.0);\n#endif\n    \n    float castleTime = time * .03;\n#ifndef ANIMATE_SCENE\n    castleTime = 0.0;\n#endif\n    \n    p += vec3(cos(castleTime*4.0), sin(castleTime*2.0), cos(castleTime * 7.0)) * .1;\n    pR(p.xy, cos(castleTime * 15.0) * .01);\n    pR(p.yz, sin((castleTime + PI) * 7.0) * .01);\n \n    Ray ray;\n    ray.origin = p + vec3(0.0, 0.5, 0.0);\n    ray.direction = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);\n    ray.forward = forward;\n    \n    return ray;\n}\n\nvec3 GetLightDirection()\n{\n    return normalize(vec3(-.1, 1.0, 1.0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITERATIONS 100\n#define EPSILON 0.005\n#define SEARCH_SAMPLES 8\n\nfloat Line(const float y, const float repeat, const float thickness, const float smoothness)\n{\n    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(repeat * 0.5 - mod(y, repeat)));\n}\n\nvec4 Line4(const vec4 y, const vec4 repeat, const vec4 thickness, const vec4 smoothness)\n{\n    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(repeat * 0.5 - mod(y, repeat)));\n}\n\nvec4 Line4NoRepeat(const vec4 y, const vec4 offset, const vec4 thickness, const vec4 smoothness)\n{\n    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(offset - y));\n}\n\nfloat Tower(vec3 p, float h, float index, bool detail, bool midtower)\n{\n    float rand = hash11(index);\n    const float sublevelSize = 0.12;\n    float sublevel = floor((p.y + sublevelSize * 0.5) / sublevelSize);\n    \n    float angle = atan(p.z, p.x);\n    float windowProfile = -2.25;\n    \n    if(detail)\n    {\n        // Two windows side by side, and construction lines\n        float windowAngle = angle + sublevel * + rand * 2.0;\n        vec4 ly = vec4(p.y + 0.05 - rand*sublevelSize, windowAngle, windowAngle + 0.15, p.y);\n        vec4 lr = vec4(sublevelSize, 1.2, 1.2, sublevelSize);\n        vec4 lt = vec4(.0165, .05, .05, .007);\n        vec4 ls = vec4(.5, .5, .5, 1.0);\n\n        vec4 lines = Line4(ly, lr, lt, ls);\n        windowProfile = -max(lines.y, lines.x) - max(lines.z, lines.x) - lines.w * .75;\n    }\n  \n    \n    float upperCap = smoothstep(0.17, .222, p.y) * .03;\n    \n    vec3 vOffset = vec3(0.0, h*.06, -.02);\n    vec3 radius = vec3(.077 - windowProfile * .0035 - upperCap, .085, .065);    \n    vec3 height = vec3(h, .4, h);\n    \n    float domeRadius = .065;\n    float domeOffset = h * 0.9;\n    \n    if(midtower)\n    {\n        if(int(sublevel) >= 1)\n        {\n            float sl = 1.0 - fract((p.y + sublevelSize*.5) / (sublevelSize));\n            radius = vec3(.077, .025, .015);\n        \tradius *= mix(.8, 1.0, sl * sl * sl);\n            height *= .79;\n        }\n        \n        radius *= .8;\n        domeRadius *= 0.7;\n        domeOffset *= .9;\n    }\n    \n    float dome = length(p - vec3(0.0, domeOffset, 0.0)) - domeRadius;\n    \n    vec3 d4 = fCylinder4(p, vOffset, radius, height); //\n    float d = min(max(d4.x, -d4.y), d4.z);\n    \n    return min(d * .7, dome);\n}\n\nfloat voronoi(vec3 p)\n{\n\tvec3 flP = floor(p);\n    vec3 frP = fract(p);\n    float f1 = 15.0;\n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    for(int z = -1; z <= 1; ++z)\n    {   \n        vec3 offset = vec3(x,y,z);\n        vec3 cellSample = hash33(flP + offset) + offset;\n        f1 = min(f1, length(cellSample - frP));\n    }\n\n    return f1;\n}\n\n// TODO: Refactor a bit more\nfloat WallHorizontalProfile(float angle, float repeat, float y, int level, bool detail)\n{\n    float baseAngle = angle;\n\tfloat repeatAngle = TAU/repeat;\n\tfloat maskAngle = Line(baseAngle, repeatAngle * 3.0, repeatAngle * 1.05, 0.05);\n    \n\tangle = (mod(angle, repeatAngle) - repeatAngle * .5) * 2.0 / repeatAngle;\n    \n    float bigArchAngle = angle;\n    \n    y = y * 4.0 + 0.5;\n    float catenary = mix(pow(y, 4.0) + 0.15, .5, maskAngle);\n    \n    // Main arches and big details\n    float r = catenary - clamp(abs(angle), -catenary, catenary);    \n    r = smoothstep(-.2, .2, r) * .5;\n        \n    float archMask = smoothstep(.25, .4, r+maskAngle);\n    \n    // Horizontal lines\n    r += archMask * Line(y + .28, .4, .015, 1.0) * .04;  \n\n    if(level == 2)\n        return r * 0.045;\n    \n    int section = int(baseAngle * 2.0 / repeatAngle);\n    float separation = 0.09 - hash11(float(section) * 2874.0) * .08;\n    float centerOffset = section % 2 == 0 ? -separation : separation;\n    \n    // Secondary arches\n    angle = baseAngle + repeatAngle * (0.25 + centerOffset);\n    repeatAngle *= .5;\n    angle = (mod(angle, repeatAngle) - repeatAngle * .5) * 2.0 / repeatAngle;\n    catenary = (pow(y, 6.0) * 10.0 + .6);\n    \n   \tfloat cat = (catenary - clamp(abs(angle), -catenary, catenary)) * .15;   \n    r -= smoothstep(.04, -.05, cat) * 0.5;\n    \n    // Upper curvature\n    r -= smoothstep(1.15, 1.35, y);\n    \n    if(detail)\n    {\n        float windowOffset = hash11(float(section) * 287423.0) * .2;\n        \n        vec4 ly = vec4(angle, y + windowOffset, y, mod(baseAngle + repeatAngle, repeatAngle * 2.0));\n        vec4 lo = vec4(1.0, .35, 0.75, repeatAngle);\n        vec4 lt = vec4(.2, .065, 0.08, 0.005);\n        vec4 ls = vec4(.6, 0.45, 0.35, 0.5);        \n        vec4 windows = Line4NoRepeat(ly, lo, lt, ls);\n        \n        // Small windows\n        float offset = max(windows.x, windows.y);\n        \n        // Big window\n        offset += max(windows.z, windows.w);\n    \n        // Lower bump\n        offset += smoothstep(-0.145, -.18, y);\n        \n        r += offset * 0.1;\n    }\n    \n    return r * 0.05;\n}\n\nfloat Wall(vec3 p, float r, float level, bool detail)\n{\n    pR(p.xz, level * 1.2 - .7);\n    p.y *= 1.0 - level * .2;\n    float h = 0.19;\n    float angle = atan(-p.z, p.x);\n    float inner = fCylinder(p, r * .965, h * 1.1);\n    \n    float sectionRepeat = 20.0 - level * 6.0;\n    \n    float profileRadius = r + WallHorizontalProfile(angle, sectionRepeat * 3.0, p.y, int(level), detail);\n    float outer = fCylinder(p, profileRadius, h);\n    float d = max(outer, -inner);\n    \n    if(level > 0.5)\n    {\n    \tvec3 outerTowerP = p;\n        pR(outerTowerP.xz, 1.0*PI/sectionRepeat);\n        outerTowerP.y *= 0.8;\n        outerTowerP -= vec3(0.0, -.05, r * 1.155);\n        \n        // TODO: try to reuse tower function instead of duplicating cost\n        d = min(d, Tower(outerTowerP , h, level, detail, true));\n        \n        outerTowerP.z += r * .1;\n        outerTowerP.y += 0.05;\n        outerTowerP.y -= pow(min(1.0, abs(outerTowerP.z - 0.1) / 0.16), 2.0) * .035;\n        \n        float wallDetail = Line(outerTowerP.y - 0.03, .083, .005, 1.0) * .1;\n        d = min(d, fBoxCheap(outerTowerP, vec3(.02 * wallDetail, .065, .15)) - .02);\n    }\n    \n    vec3 innerTowerP = p;\n    float index = pModPolar(innerTowerP.xz, sectionRepeat);\n    innerTowerP.x -= r;    \n    d = min(d, Tower(innerTowerP, h * 1.15, index, detail, false));\n    \n    return d;\n}\n\nfloat sdf(vec3 p, bool detail)\n{\n\tfloat d = 2.0;\n    \n    for(float i = 0.0; i < 3.0; i+=1.0)\n    \td = min(d, Wall(p + vec3(0.0, i * -0.55, 0.0), 2.0 - (i * .35), i, detail));\n    \n    if(detail)\n    {\n    \td += -voronoi(p * 18.0) * .012 * smoothstep(1.0, -0.5, p.y);\n    }\n    \n    return d;\n}\n\n// iq/aaltonen\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdf(ro + rd*t, false);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.5*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.001,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon, bool detail)\n{\n    vec3 normal = vec3(0.0);\n    float s = sdf(p, detail);\n    \n    for(int axis = 0; axis < 3; ++axis)\n    {\n        vec3 offset = vec3(0.0);\n        offset[axis] = epsilon;\n        normal[axis] = sdf(p + offset, detail) - s;\n    }\n    \n    return normalize(normal);\n}\n\nvec3 Raymarch(Ray r, float startT)\n{\n    float t = startT;\n    float d = 0.0;\n    float iterations = 0.0;\n    \n\tfor(int j = 0; j < MAX_ITERATIONS; j++)\n\t{\n\t\td = sdf(r.origin + r.direction * t, false);\n\n\t\tif(d < EPSILON)\n            break;\n        \n\t\tt += d;\n        \n        if(t > MAX_DISTANCE)\n            break;\n        \n        iterations += 1.0;\n\t}\n    \n    t = min(t, MAX_DISTANCE);\n    \n    return vec3(t, iterations / float(MAX_ITERATIONS), d);\n}\n\nvec3 Render(Ray ray, float t, float d)\n{\n    if(d > .1)\n\t\treturn vec3(0.0);\n    \n    vec3 p = SampleRay(ray, t);\n    \n    vec3 L = GetLightDirection();\n    vec3 detailNormal = sdfNormal(p, .002, true);\n    vec3 normal = detailNormal;\n   \tfloat diffuse = dot(L, detailNormal) * 0.5 + 0.5;\n    \n    vec3 albedo = pow(vec3(.9, 0.66, .4), vec3(1.3)) * 1.25;\n    \n    float y = (p.y + .053) / .111;\n    float yH = hash11(floor(y));\n    float angle = atan(p.z, p.x) + 1.2;\n    float dirt = texture(iChannel0, vec2(angle * 8.0 + yH * .5, angle + yH + p.y * .5)).r;\n    dirt = mix(dirt, 0.0, step(.8, p.y));\n    float dirtMask = 1.0 - fract(y);\n    \n    albedo *= mix(vec3(.8, 0.8, .5) * .75, vec3(1.0), smoothstep(.6, .0, dirt - dirtMask * .7));\n    \n    // Per level mask\n    dirtMask = smoothstep(1.0, .35, fract((pow(p.y + .295, .85)) / .55));\n    dirt = texture(iChannel0, vec2(angle, p.y * .25) * .7).r + texture(iChannel0, vec2(angle, p.y * .25) * 7.7).r * .45;\n    albedo *= mix(vec3(.3, 0.4, .1) * .65, vec3(1.0), smoothstep(.8, .15, dirt - dirtMask));\n    \n    vec3 color = albedo * diffuse;\n    float ao = smoothstep(.0, .1, sdf(p + normal * .065, true));\n    \n    // Shadows\n    float shadows = max(0.0, softshadow(p, L, .01, 4.0, 2.5));\n    color *= mix(.1, 1.0, shadows);\n    \n    float cloudShadows = smoothstep(1.5, -4.0, p.y - texture(iChannel0, p.zy * .15 + iTime * .01).r * 5.);    \n    cloudShadows *= smoothstep(-.15, 2.0, p.y + .2 + texture(iChannel0, p.zy * .05 + iTime * .02).r);    \n    cloudShadows = smoothstep(0.05, .5, cloudShadows);\n    color *= mix(1.0, 0.05, cloudShadows);\n    \n    vec3 backL = normalize(vec3(-.25, .0, -1.0));\n   \tfloat backLight = smoothstep(-.35, 1.2, dot(backL, detailNormal));\n    color += ao * backLight * vec3(0.32, 0.365, 0.45) * .8;\n    \n    // Weathering/AO\n    color *= mix(color * .5, vec3(1.), ao);\n    \n    // Some slight translucency\n    color += vec3(.85, 0.63, .4) * vec3(.85, 0.63, .4) * max(0.0, sdf(p + L * .2, false));\n    \n    // Inner scaffolding mask\n    color *= 1.0 - (smoothstep(.25, .15, abs(p.y)) * smoothstep(1.975, 1.93, length(p.xz)));\n   \n    return color;\n}\n\nfloat SampleSearchMinimum(vec2 uv, float radius, Ray ray, Ray prevRay)\n{\n\tfloat minT = texture(iChannel3, uv).w;\n    float projD = dot(ray.direction, prevRay.direction);\n    int seed = ((int(uv.x * 434523.0) * int(uv.y * 23434.0)) % 1476) + int(iTime * 1837.0);\n    \n    for(int i = 0; i < SEARCH_SAMPLES; ++i)\n    {\n        vec2 offset = R2seq(i + seed) * 2.0 - 1.0;\n        offset *= radius * mix(.01, 1.0, 1.0 / float(i+1));\n        \n        float t = projD * texture(iChannel3, uv + offset).w;\n        \n        float sampleDist = sdf(SampleRay(ray, t), false);\n    \tfloat sampleDistPrev = sdf(SampleRay(prevRay, t), false);\n        \n        float dS = sampleDist / sampleDistPrev;\n    \tbool sampleIsApproaching = dS < 0.95;\n        \n        if(sampleIsApproaching)\n            minT = min(minT, t - EPSILON * 2.0);\n        \n        // This sample is close to the surface\n        if(sampleDist < EPSILON)\n            minT = min(minT, t);\n    }\n    \n    return minT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(!Frame(fragCoord, iResolution.xy))\n    {\n        fragColor = vec4(iMouse.xy/iResolution.xy, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    vec2 prevMouse = texture(iChannel3, vec2(0.0)).rg;\n\n    Ray ray = GetCameraRay(iFrame, uv, iMouse.xy/iResolution.xy);    \n    Ray prevRay = GetCameraRay(iFrame - 1, uv, prevMouse);\n   \t\n    // We don't really need the distance, as the reprojection makes sure we're always close\n    bool bounds = slabs(vec3(-1.75, -.5, -2.1), vec3(2.0, 1.35, 2.05), ray.origin, vec3(1.0) / ray.direction);\n    \n    if(!bounds)\n    {\n\t\tfragColor = vec4(MAX_DISTANCE);\n        return;\n    }\n    \n    float startDistance = 1.5;\n    \n#ifdef TEMPORAL_REPROJECTIION\n    float bias = EPSILON * .05;\n    startDistance = max(startDistance, SampleSearchMinimum(fragCoord.xy / iResolution.xy, .1, ray, prevRay) - bias);\n    \n    float aspect = iResolution.y / iResolution.x;\n    float edgeEntryBias = smoothstep(1.0, .99, abs(uv.x * aspect)) * smoothstep(0.75, .74, abs(uv.y));    \n    startDistance *= mix(.95,1.0, edgeEntryBias);\n#endif\n    \n    vec3 traceData = Raymarch(ray, startDistance);    \n    vec3 color = Render(ray, traceData.x, traceData.z);\n    \n#ifdef VIEW_ITERATIONS\n    if(uv.x > 0.0)\n    \tcolor = vec3(1.0) * traceData.y;\n#endif\n    \n    color = mix(color, texture(iChannel3, fragCoord.xy/iResolution.xy).rgb, .65);\n    \n\tfragColor = vec4(max(vec3(0.0), color), traceData.x);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ml23RK","filepath":"https://soundcloud.com/joe-hisaishi/castle-in-the-sky-by-joe-hisaishi","previewfilepath":"https://soundcloud.com/joe-hisaishi/castle-in-the-sky-by-joe-hisaishi","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_ITERATIONS 100\n#define EPSILON 0.01\n#define SEARCH_SAMPLES 8\n\nstruct CellData\n{\n    vec2 p1;\n    vec2 p2;\n};\n\nCellData Sample(vec2 cellPosition, vec2 offset, vec2 anisoOffset)\n{\n\tCellData cell;\n    cell.p1 = hash22(cellPosition + offset) + anisoOffset + offset;\n    cell.p2 = hash22((cellPosition + offset) * 54.53343) - anisoOffset + offset;\n    return cell;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y+.5),0.0); \n}\n\nvec4 Voronoi(vec2 p, float anisotropy)\n{\n\tvec2 flP = floor(p);\n    vec2 frP = fract(p);\n    \n    // f.x: min, f.y: second mininum, etc\n    vec4 f = vec4(15.0);\n    \n    float anisoAngle = 1.4;\n    vec2 anisoOffset = vec2(cos(anisoAngle), sin(anisoAngle)) * anisotropy;\n    \n    // Smallest possible bounds that captures the look\n    for(int x = -4; x <= 4; ++x)\n    for(int y = -4; y <= 4; ++y)\n    {   \n        vec2 offset = vec2(x,y);\n\t\tCellData cell = Sample(flP, offset, anisoOffset);\n        float dist = sdBox(frP - cell.p1, abs(cell.p1 - cell.p2));\n\n        if(dist < f.x)\n        {\n            f.w = f.z;\n            f.z = f.y;\n            f.y = f.x;\n            f.x = dist;\n        }\n\t}\n\n    return f;\n}\n\nvec3 pattern(vec3 pos)\n{\n    pR(pos.xz, .7); // Move the seam out\n    float u = acos(pos.y + 0.15);\n    float v = atan(pos.z, pos.x);\n    \n    vec2 p = vec2(v, u);\n    p *= 4.0;\n    vec4 cells = Voronoi(p * 1.4, .2);\n    float base = smoothstep(.25, .0, cells.y - cells.x) * .25;\n    base += cells.x;\n    \n    cells = Voronoi(p * 1.2 + vec2(36.5, .0), .8);\n    float vines = smoothstep(0.01, .17, cells.y - cells.x);\n    return vec3(base, vines, mix(vines * .75, base * .35, vines));\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; //\n}\n\nfloat scaffold(vec3 originalP)\n{\n    vec3 p = originalP;\n    \n    float brokenLeftSide = fBoxCheap(p - vec3(-1.4, .0, -.8), vec3(0.7));\n    \n    p.y += 0.2;\n    float index = pModPolar(p.xz, 10.0);\n    float baseCylinder = fCylinder(p, 1.9, .1);\n    vec2 c = pMod2(p.xz, vec2(.23));\n    c = hash22(c*28473.2387345) * .135;\n    \n    float scaffold = max(baseCylinder, sdRoundBox(p, vec3(c.y , .2, c.x), .02));\n    float d = max(scaffold, -brokenLeftSide);\n    \n    return d;\n}\n\nvec2 patternTx(vec3 p)\n{\n    return pattern(p).xy;\n}\n\nfloat sdf(vec3 p, bool detail)\n{\n    p.y -= 0.15;\n    \n    float radius = 1.3;\n    \n    // Early out\n    if(p.y > 0.0)\n\t    return 10.0;\n    \n    if(detail)\n    {\n        radius -= pattern(p + vec3(0.0, 0.15, 0.0)).z * .02;\n    }\n    \n    // A bit squashed\n    float core = length(p*vec3(1.0, 1.05, 1.0)) - radius;\n    \n    return min(core, scaffold(p));\n}\n\nvec3 sdfNormal(vec3 p, float epsilon, float d, bool detail)\n{\n    vec3 normal = vec3(0.0);\n\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        vec3 offset = vec3(0.0);\n        offset[axis] = epsilon;\n        normal[axis] = sdf(p + offset, detail) - d;\n    }\n    \n    return normalize(normal);\n}\n\nvec3 Raymarch(Ray r, float startT)\n{\n    float t = startT;\n    float d = 0.0;\n    float iterations = 0.0;\n    \n\tfor(int j = 0; j < MAX_ITERATIONS; j++)\n\t{\n\t\td = sdf(r.origin + r.direction * t, false);\n\n\t\tif(d < EPSILON)\n            break;\n        \n\t\tt += d;\n        \n        if(t > MAX_DISTANCE)\n            break;\n        \n        iterations += 1.0;\n\t}\n    \n    t = min(t, MAX_DISTANCE);\n    \n    return vec3(t, iterations / float(MAX_ITERATIONS), d);\n}\n\nvec3 Render(Ray ray, float t, float d)\n{\n    if(d > .05)\n\t\treturn vec3(0.0);\n    \n    vec3 pos = SampleRay(ray, t);\n    \n    vec3 normal = sdfNormal(pos, .025, d, true);\n    vec3 L = GetLightDirection();\n    float heightMask = smoothstep(0.0, -.7, pos.y);\n    \n    vec2 coreTexture = patternTx(pos);\n    \n    float scaffoldMask = smoothstep(.2, .0, abs(-.15 - pos.y));\n    float coreMask = 1.0 - scaffoldMask;\n    \n    float specular = mix(1.0, 0.0, scaffoldMask) * coreTexture.y * heightMask;\n    \n    float shadows = 1.0;\n   \tfloat diffuse = max(0.0, dot(L, normal)* 0.55 + 0.5);\n    \n    vec3 albedo = vec3(0.06, 0.08, .12) * 1.5;\n    vec3 vineColor = vec3(0.3, 0.2, .1) * .095;\n    \n    albedo = mix(vineColor, albedo, min(1.0, scaffoldMask + coreTexture.y));\n    albedo *= smoothstep(.9, .7, coreTexture.x);\n    \n    vec3 color = albedo * diffuse * heightMask;\n    \n    vec3 bounceSpec = normalize(vec3(.5, -1.0, 1.0));\n    vec3 bg = vec3(0.5, .619, .7);\n    vec3 refl = reflect(bounceSpec, normal);\n    float NdotR = max(0.0, dot(ray.direction, refl));\n    color += specular * bg * pow(NdotR, 8.0) * .25;\n    \n    color *= smoothstep(1.25, -.1, coreTexture.x);\n    \n    // Lower bounce on the scaffolding to add contrast\n    float coreOuterMask = smoothstep(1.4, 1.5, length(pos));\n    color += bg * coreOuterMask * scaffoldMask * max(0.0, -normal.y) * .03;\n    \n    return color;\n}\n\n\nfloat SampleSearchMinimum(vec2 uv, float radius, Ray ray, Ray prevRay)\n{\n\tfloat minT = texture(iChannel3, uv).w;\n    float projD = dot(ray.direction, prevRay.direction);\n    \n    int seed = ((int(uv.x * 434523.0) * int(uv.y * 23434.0)) % 1476) + int(iTime * 1837.0);\n    \n    for(int i = 0; i < SEARCH_SAMPLES; ++i)\n    {\n        vec2 offset = R2seq(i + seed) * 2.0 - 1.0;\n        offset *= radius * mix(.01, 1.0, 1.0 / float(i+1));\n        \n        float t = projD * texture(iChannel3, uv + offset).w;\n        \n        float sampleDist = sdf(SampleRay(ray, t), false);\n    \tfloat sampleDistPrev = sdf(SampleRay(prevRay, t), false);\n        \n        float dS = sampleDist / sampleDistPrev;\n    \tbool sampleIsApproaching = dS < 0.9;\n        \n        if(sampleIsApproaching)\n            minT = min(minT, t - EPSILON * 2.0);\n        \n        // This sample is close to the surface\n        if(sampleDist < EPSILON)\n            minT = min(minT, t);\n    }\n    \n    return minT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(!Frame(fragCoord, iResolution.xy))\n    {\n        fragColor = vec4(iMouse.xy/iResolution.xy, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    vec2 prevMouse = texture(iChannel3, vec2(0.0)).rg;\n\n    Ray ray = GetCameraRay(iFrame, uv, iMouse.xy/iResolution.xy);    \n    Ray prevRay = GetCameraRay(iFrame - 1, uv, prevMouse);\n   \t\n    // We don't really need the distance, as the reprojection makes sure we're always close\n    bool bounds = slabs(vec3(-1.75, -1.5, -1.5), vec3(2.0, .1, 2.0), ray.origin, vec3(1.0) / ray.direction);\n    \n    if(!bounds)\n    {\n\t\tfragColor = vec4(MAX_DISTANCE);\n        return;\n    }\n    \n    float startDistance = 2.35;\n    \n#ifdef TEMPORAL_REPROJECTIION\n    float bias = EPSILON * .05;\n    startDistance = max(startDistance, SampleSearchMinimum(fragCoord.xy / iResolution.xy, .1, ray, prevRay) - bias);\n    \n    float aspect = iResolution.y / iResolution.x;\n    float edgeEntryBias = smoothstep(1.0, .99, abs(uv.x * aspect)) * smoothstep(0.75, .74, abs(uv.y));    \n    startDistance *= mix(.95,1.0, edgeEntryBias);\n#endif\n    \n    vec3 traceData = Raymarch(ray, startDistance);    \n    vec3 color = Render(ray, traceData.x, traceData.z);\n    \n#ifdef VIEW_ITERATIONS\n    if(uv.x > 0.0)\n    \tcolor = vec3(1.0) * traceData.y;\n#endif\n    \n    color = mix(color, texture(iChannel3, fragCoord.xy/iResolution.xy).rgb, .65);\n    \n\tfragColor = vec4(max(vec3(0.0), color), traceData.x);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define MAX_ITERATIONS 75\n#define EPSILON 0.02\n#define SEARCH_SAMPLES 8\n\nvec4 Line4(const vec4 y, const vec4 repeat, const vec4 thickness, const vec4 smoothness)\n{\n    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(repeat * 0.5 - mod(y, repeat)));\n}\n\nfloat Voronoi(vec3 p)\n{\n\tvec3 flP = floor(p);\n    vec3 frP = fract(p);\n    \n    float f1 = 15.0;\n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    for(int z = -1; z <= 1; ++z)\n    {   \n        vec3 offset = vec3(x,y,z);\n        vec3 s = hash33(flP + offset) + offset;\n        f1 = min(distance(s, frP), f1);\n\t}\n\n    return f1;\n}\n\nfloat WorleyFractal(vec3 p, float freqRatio, const int octaves)\n{\n    const float G = exp2(-.58);\n    float noise = 0.0;\n    float freq = 1.0;\n    float amp = 1.;\n    \n    for (int i = 0; i < octaves; ++i)\n    {\n        float v = amp * Voronoi(p * freq + vec3(i));\n        noise += v;\n        freq *= freqRatio;\n        amp *= G;\n    }\n    \n    return noise;\n}\nfloat Tower(vec3 p, float radius, float height, bool detail)\n{\n    if(detail && p.y < .6)\n    {\n        float sublevelSize = 0.35;\n    \tfloat angle = atan(p.z, p.x);\n        \n        vec4 ly = vec4(p.y + sublevelSize*.5, angle, angle + 0.15, p.y);\n        vec4 lr = vec4(sublevelSize*.355, .1, 1.2, sublevelSize);\n        const vec4 lt = vec4(.03, .035, .05, .007);\n        const vec4 ls = vec4(1.0, .6, .5, 1.0);\n        \n        vec4 lines = Line4(ly, lr, lt, ls) * .0175;\n        radius -= -max(lines.y, lines.x) - max(lines.z, lines.x) - lines.w;        \n    }\n\n    float d = fCylinder(p, radius, height);\n    d = min(d, length(p - vec3(0.0, height, 0.0)) - radius);\n    \n    return d;\n}\n //\nint sdfMaterial(vec3 p)\n{   \n    int material = 0;\n    float d = 10.0;\n    p.y -= 1.7;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        pR(p.xz, .65);\n        vec3 towerP = p;\n        \n        float index = pModPolar(towerP.xz, 12.0);\n        float h1 = hash11(index * 487.01);\n\t\t\n        towerP.xy += vec2(-mix(.75, .9, h1), h1*h1);\n        float t = Tower(towerP, .2 + h1*h1 * .2, 0.5, false);\n        \n        if(t < d)\n        {\n            if(towerP.y > .55)\n                material = 1;\n            \n\t\t\td = t;\n        }\n    }\n    \n    p.y = 2.1 * (p.y - .8);\n    \n    // Face it towards us\n    pR(p.yz, .5);\n    \n    float tree = length(p) - 1.35 + smoothstep(.35, -.2, p.y) * .5;\n    \n    if(tree < d)\n        material = 2;\n    \n    return material;\n}\n\n\nfloat sdf(vec3 p, bool detail)\n{   \n    float d = 10.0;\n    p.y -= 1.7;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        pR(p.xz, .65);\n        vec3 towerP = p;\n        \n        float index = pModPolar(towerP.xz, 12.0);\n        float h1 = hash11(index * 487.01);\n\t\t\n        towerP.xy += vec2(-mix(.75, .9, h1), h1*h1);\n        d = min(d, Tower(towerP, .2 + h1*h1 * .2, 0.5, detail));\n    }\n    \n    d = max(d, -p.y - .35);\n    p.y = 2.1 * (p.y - .9);\n    \n    float w = 0.0;\n    \n    // Bound the noise a bit\n    if(length(p) < 2.0)\n    \tw = WorleyFractal(p * vec3(1.0, 4.0, 1.0), 1.85, detail ? 4 : 3);\n    \n    // Face it towards us \n    pR(p.xz, -.8);\n    pR(p.yz, .5);\n    \n    float tree = length(p) - 1.4 + smoothstep(.35, -.2, p.y) * .5; \n    tree += w * .25;\n    \n    d = min(d, tree);\n    \n    return d;\n}\n\n// iq/aaltonen\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, bool detail)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdf(ro + rd*t, detail);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.5*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.001,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon, bool detail)\n{\n    vec3 normal = vec3(0.0);\n    float s = sdf(p, detail);\n    \n    for(int axis = 0; axis < 3; ++axis)\n    {\n        vec3 offset = vec3(0.0);\n        offset[axis] = epsilon;\n        normal[axis] = sdf(p + offset, detail) - s;\n    }\n    \n    return normalize(normal);\n}\n\nvec3 Raymarch(Ray r, float startT)\n{\n    float t = startT;\n    float d = 0.0;\n    float iterations = 0.0;\n    \n\tfor(int j = 0; j < MAX_ITERATIONS; j++)\n\t{\n\t\td = sdf(r.origin + r.direction * t, false);\n\n\t\tif(d < EPSILON)\n            break;\n        \n\t\tt += d * .4;\n        \n        if(t > MAX_DISTANCE)\n            break;\n        \n        iterations += 1.0;\n\t}\n    \n    t = min(t, MAX_DISTANCE);\n    \n    return vec3(t, iterations / float(MAX_ITERATIONS), d);\n}\n\nvec3 Render(Ray ray, float t, float d)\n{\n    if(d > .2)\n\t\treturn vec3(0.0);\n    \n    vec3 p = SampleRay(ray, t);\n    \n    int material = sdfMaterial(p);\n    \n    vec3 L = GetLightDirection();\n    vec3 detailNormal = sdfNormal(p, .015, true);\n    vec3 normal = detailNormal;\n    float diffuse = smoothstep(-.95, 1.0, dot(L, detailNormal));\n    float shadows = max(0.0, softshadow(p, L, .01, 4.0, 2.5, false));\n    \n    vec3 color = vec3(1.) * diffuse;\n\n    float cloudShadows = smoothstep(1.5, -4.0, p.y - .35 - texture(iChannel0, p.zy * .15 + iTime * .01).r * 5.);    \n    cloudShadows *= smoothstep(-.15, 2.0, p.y - .35 + texture(iChannel0, p.zy * .05 + iTime * .02).r);    \n    cloudShadows = smoothstep(0.1, .5, cloudShadows);\n    \n    if(material != 2)\n    {\n        vec3 albedo = material == 0 ? vec3(1.0,.95, .8) : vec3(.25, .1, .025);\n        color *= albedo;\n        float ao = smoothstep(.0, .3, sdf(p - ray.direction * .1 + normal * .0165, false));\n        ao *= smoothstep(1.0, 1.35, length(p.xz));\n\n        // Shadows\n        color *= mix(.1, 1.0, shadows);\n        color *= mix(1.0, 0.05, cloudShadows);\n\n        vec3 backL = normalize(vec3(-.25, .0, -1.0));\n        float backLight = smoothstep(-.35, 1.2, dot(backL, detailNormal));\n        color += ao * backLight * vec3(0.32, 0.365, 0.45);\n\n        // Some slight translucency\n        color += vec3(.85, 0.63, .4) * vec3(.85, 0.63, .4) * abs(sdf(p + L * .2, false));\n    }\n    else\n    {\n        float ao = smoothstep(.8, 1.35, length(p.xz));\n        vec3 albedo = vec3(.15, .3, .05);\n        color *= albedo * ao;\n        color *= mix(1.0, 0.05, cloudShadows);\n        color *= mix(.1, 1.0, shadows);\n\n        vec3 backL = normalize(vec3(-.25, .0, -1.0));\n        float backLight = smoothstep(-.05, 3.0, dot(backL, detailNormal));\n        color += ao * backLight * vec3(0.32, 0.365, 0.45);\n\n        // Some slight translucency\n        color += albedo * .45 * max(0.0, sdf(p + L * .5, false));\n    }\n    \n    return color;\n}\n\nfloat SampleSearchMinimum(vec2 uv, float radius, Ray ray, Ray prevRay)\n{\n\tfloat minT = texture(iChannel3, uv).w;\n    float projD = dot(ray.direction, prevRay.direction);\n    \n    int seed = ((int(uv.x * 434523.0) * int(uv.y * 23434.0)) % 1476) + int(iTime * 1837.0);\n    \n    for(int i = 0; i < SEARCH_SAMPLES; ++i)\n    {\n        vec2 offset = R2seq(i + seed) * 2.0 - 1.0;\n        offset *= radius * mix(.01, 1.0, 1.0 / float(i+1));\n        \n        float t = projD * texture(iChannel3, uv + offset).w;\n        \n        float sampleDist = sdf(SampleRay(ray, t), false);\n    \tfloat sampleDistPrev = sdf(SampleRay(prevRay, t), false);\n        \n        float dS = sampleDist / sampleDistPrev;\n    \tbool sampleIsApproaching = dS < 0.95;\n        \n        if(sampleIsApproaching)\n            minT = min(minT, t);\n        \n        // This sample is close to the surface\n        if(sampleDist < EPSILON)\n            minT = min(minT, t);\n    }\n    \n    return minT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(!Frame(fragCoord, iResolution.xy))\n    {\n        fragColor = vec4(iMouse.xy/iResolution.xy, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    vec2 prevMouse = texture(iChannel3, vec2(0.0)).rg;\n\n    Ray ray = GetCameraRay(iFrame, uv, iMouse.xy/iResolution.xy);    \n    Ray prevRay = GetCameraRay(iFrame - 1, uv, prevMouse);\n   \t\n    // We don't really need the distance, as the reprojection makes sure we're always close\n    bool bounds = slabs(vec3(-1.0, 1.7, -1.0), vec3(1.0, 5.0, 1.3), ray.origin, vec3(1.0) / ray.direction);\n    \n    if(!bounds)\n    {\n\t\tfragColor = vec4(MAX_DISTANCE);\n        return;\n    }\n   \t\n    float startDistance = 3.5;\n    \n#ifdef TEMPORAL_REPROJECTIION\n    float bias = EPSILON;\n    startDistance = max(startDistance, SampleSearchMinimum(fragCoord.xy / iResolution.xy, .15, ray, prevRay) - bias);\n    \n    float aspect = iResolution.y / iResolution.x;\n    float edgeEntryBias = smoothstep(1.0, .99, abs(uv.x * aspect)) * smoothstep(0.75, .74, abs(uv.y));    \n    startDistance *= mix(.95,1.0, edgeEntryBias);\n#endif\n    \n    vec3 traceData = Raymarch(ray, startDistance);    \n    vec3 color = Render(ray, traceData.x, traceData.z);\n    \n#ifdef VIEW_ITERATIONS\n    if(uv.x > 0.0)\n    \tcolor = vec3(1.0) * traceData.y;\n#endif\n    \n    color = mix(color, texture(iChannel3, fragCoord.xy/iResolution.xy).rgb, .65);\n    \n\tfragColor = vec4(max(vec3(0.0), color), traceData.x);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define MAX_ITERATIONS 130\n#define EPSILON 0.05\n#define SEARCH_SAMPLES 6\n\n#define CLOUD_FREQ_RATIO 1.95\n#define CLOUD_BASE_FREQ 1.35\n#define CLOUD_ITERATIONS 5\n\nfloat Voronoi(vec3 p)\n{\n\tvec3 flP = floor(p);\n    vec3 frP = fract(p);\n    \n    float f1 = 15.0;\n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    for(int z = -1; z <= 1; ++z)\n    {   \n        vec3 offset = vec3(x,y,z);\n        vec3 s = hash33(flP + offset) + offset;\n        float dist = distance(s, frP);\n        \n        f1 = min(dist, f1);\n\t}\n\n    return f1;\n}\n\nvec4 WorleyFractal(vec3 p, float freqRatio, const int octaves)\n{\n    float G = exp2(-.58);\n    vec4 noise = vec4(0.);\n    float freq = 1.0;\n    float amp = 1.;\n    \n    for (int i = 0; i < octaves; ++i)\n    {\n        float v = amp * Voronoi(p * freq + vec3(i));\n        noise.x += v;\n        \n        int m = max(1, i % 4);\n        noise[m] += v;\n        \n        freq *= freqRatio;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\nfloat sdf(vec3 p, bool detail)\n{\n    vec3 oP = p;\n    vec3 wP = p;\n    \n    pR(wP.xy, .714);\n    p -= vec3(.0, -.2, .4);\n    \n    vec3 rightP = p;\n    pR(rightP.xy, .6);\n    float rightCloud = length(rightP - vec3(-.5, -1.1, 2.3)) - 1.15;\n    rightCloud = min(rightCloud, length(rightP * vec3(1.0, 1.0, .45) - vec3(-.5, -1.5, 1.3)) - 1.45);\n    \n    \n    float farClouds = length(p - vec3(6.5, 1., 0.5)) - 3.5;    \n    farClouds = min(farClouds, length(p - vec3(4.0, 3.5, 0.5)) - 1.5); //\n    \n    // Left far\n    farClouds = min(farClouds, length(p - vec3(3., 1.7, -5.5)) - 3.25);    \n    farClouds = min(farClouds, length(p - vec3(.5, -.1, -5.5)) - 1.45);\n    \n    pR(p.yz, .1);\n    float lowerClouds = p.y + 3.8 - smoothstep(-1.0, -5.0, p.z) * 3.5;\n    \n    vec2 index = pMod2(oP.xz, vec2(1.65));\n    lowerClouds = min(lowerClouds, p.y + 1.5);\n    \n    float clouds = min(min(rightCloud, lowerClouds), farClouds);\n    \n    vec3 noiseScale = vec3(.65, 1.0, .85) * CLOUD_BASE_FREQ;\n    vec4 noise = vec4(0.0);\n    \n    // Bound the noise\n    if(detail && clouds < .06)\n    {\n        noise = WorleyFractal(wP * noiseScale, CLOUD_FREQ_RATIO, CLOUD_ITERATIONS);    \n        noise = pow(noise, vec4(1.3));\n    }\n    \n    return clouds + dot(noise, noise) * .06;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon, float d, bool detail)\n{\n    vec3 normal = vec3(0.0);\n\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        vec3 offset = vec3(0.0);\n        offset[axis] = epsilon;\n        normal[axis] = sdf(p + offset, detail) - d;\n    }\n    \n    return normalize(normal);\n}\n\nvec3 Raymarch(Ray r, float startT)\n{\n    float t = startT;\n    float d = 0.0;\n    float iterations = 0.0;\n    \n\tfor(int j = 0; j < MAX_ITERATIONS; j++)\n\t{\n\t\td = sdf(r.origin + r.direction * t, true);\n\n\t\tif(d < EPSILON)\n            break;\n        \n\t\tt += d;\n        \n        if(t > MAX_DISTANCE)\n            break;\n        \n        iterations += 1.0;\n\t}\n    \n    t = min(t, MAX_DISTANCE);\n    \n    return vec3(t, iterations / float(MAX_ITERATIONS), d);\n}\n\nfloat sdfCore(vec3 p)\n{\n\treturn length(p-vec3(0.0,.1,0.0)) - 1.395;\n}\n\nvec3 Render(Ray ray, float t, float d)\n{\n    if(d > .05)\n\t\treturn vec3(0.0);\n    \n    vec3 p = SampleRay(ray, t);\n    \n    vec3 L = normalize(vec3(-.85, 1., 1.));\n    \n    float nT = (t - 1.0) / MAX_DISTANCE;\n    \n    vec3 normalHF = sdfNormal(p, .1 * nT + .001, d, true);\n    float ratio = max(0.0, dot(normalHF, -ray.direction));\n    float limb = mix(.85 - nT * .3, 1.01, pow(ratio, 2.0));\n    \n    // This helps with low freq shadowing\n    float sssLF = sdf(p + L * .65, false);\n    sssLF = smoothstep(-.75, 1.3, sssLF);\n    \n    vec3 sssSample = p + ray.direction * -1.2 + L * (2.65);\n    float sss = sdf(sssSample, false);\n    \n    float coreShadow = smoothstep(-1.0, 1.5, sdfCore(p - ray.direction * 3.2 + GetLightDirection() * 1.85));    \n    sss *= mix(.25, 1.0, coreShadow);\n    \n    vec3 cloudExtinction = pow(vec3(1.05, .75, .4), vec3(1.5)) * 1.5;\n    vec3 scattering = exp(-cloudExtinction / sss);\n    \n    float closeClouds = step(t, 2.5);\n    scattering *= mix(mix(.2, 1.5, sssLF), 1.0, closeClouds);\n    \n    return clamp(scattering * limb * 1.25, 0.0, 1.0);\n}\n\nfloat SampleSearchMinimum(vec2 uv, float radius, Ray ray, Ray prevRay)\n{\n\tfloat minT = texture(iChannel3, uv).w;\n    float projD = dot(ray.direction, prevRay.direction);\n    \n    int seed = ((int(uv.x * 434523.0) * int(uv.y * 23434.0)) % 1476) + int(iTime * 1837.0);\n    \n    for(int i = 0; i < SEARCH_SAMPLES; ++i)\n    {\n        vec2 offset = R2seq(i + seed) * 2.0 - 1.0;\n        offset *= radius * mix(.01, 1.0, 1.0 / float(i+1));\n        \n        float t = projD * texture(iChannel3, uv + offset).w;\n        \n        // Note that here we need detail=true to reduce noise\n        float sampleDist = sdf(SampleRay(ray, t), true);\n    \tfloat sampleDistPrev = sdf(SampleRay(prevRay, t), true);\n        \n        float dS = sampleDist / sampleDistPrev;\n    \tbool sampleIsApproaching = dS < 0.95;\n        \n        if(sampleIsApproaching)\n            minT = min(minT, t - EPSILON);\n        \n        // This sample is close to the surface\n        if(sampleDist < EPSILON)\n            minT = min(minT, t);\n    }\n    \n    return minT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(!Frame(fragCoord, iResolution.xy))\n    {\n        fragColor = vec4(iMouse.xy/iResolution.xy, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    vec2 prevMouse = texture(iChannel3, vec2(0.0)).rg;\n   \n    Ray ray = GetCameraRay(iFrame, uv, iMouse.xy/iResolution.xy);    \n    Ray prevRay = GetCameraRay(iFrame - 1, uv, prevMouse);\n   \t\n    float startDistance = 1.0;\n    \n#ifdef TEMPORAL_REPROJECTIION\n    float bias = EPSILON * .05;\n    startDistance = max(startDistance, SampleSearchMinimum(fragCoord.xy / iResolution.xy, .15, ray, prevRay) - bias);\n    \n    float aspect = iResolution.y / iResolution.x;\n    float edgeEntryBias = smoothstep(1.0, .99, abs(uv.x * aspect)) * smoothstep(0.75, .74, abs(uv.y));    \n    startDistance *= mix(.95,1.0, edgeEntryBias);\n#endif\n    \n    vec3 traceData = Raymarch(ray, startDistance);    \n    vec3 color = Render(ray, traceData.x, traceData.z);\n    \n#ifdef VIEW_ITERATIONS\n    if(uv.x > 0.0)\n    \tcolor = vec3(1.0) * traceData.y;\n#endif\n    \n    color = mix(color, texture(iChannel3, fragCoord.xy/iResolution.xy).rgb, .65);\n    \n\tfragColor = vec4(max(vec3(0.0), color), traceData.x);\n}","name":"Buffer D","description":"","type":"buffer"}]}