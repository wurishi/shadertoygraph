{"ver":"0.1","info":{"id":"MdyXWt","date":"1467326770","viewed":139,"name":"Lighted Sphere Field","username":"VoidChicken","description":"A simple raymarching test so try out a new way of rendering.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","light","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Light;\nfloat Map(vec3 P, out bool WHITE) {\n    float outt;\n    WHITE = (outt=min(length(mod(P,20.)-10.)-2.,length(P-Light)-1.))==length(P-Light)-1.;\n    return outt;\n}\nvec3 Normal( vec3 x )\n{\n    bool b;\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( vec3( Map(x+e.xyy,b) - Map(x-e.xyy,b),\n                            Map(x+e.yxy,b) - Map(x-e.yxy,b),\n                            Map(x+e.yyx,b) - Map(x-e.yyx,b) ) );\n}\nstruct Ray {\n    vec3 Origin, Direction;\n};\nstruct Intersection {\n    float Distance;\n    bool Collision;\n    bool Light;\n};\nvec3 RayDirection(vec2 D) {\n    return vec3((D*2.-1.)*vec2(1., iResolution.y/iResolution.x), 1);\n}\nRay CreateRay(vec3 O, vec3 D) {\n    Ray r;\n    r.Origin = O;\n    r.Direction = D;\n    return r;\n}\nvec3 RayPoint(Ray R,float T) {\n    return R.Origin+R.Direction*T;\n}\nIntersection ComputeRayIntersection(Ray r) {\n    Intersection it;\n    for (int i = 0; i < 64; i++) {\n        float df = Map(RayPoint(r,it.Distance),it.Light);\n        if (df<.01) {\n            it.Collision = true;\n        }\n        it.Distance+=df;\n    }\n    return it; \n}\nvec3 Shade(float T, Ray ray){\n    vec3 p = RayPoint(ray,T);\n    return vec3(1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 COLOR;\n    vec3 Camera = vec3(0,0,iTime*10.);\n    Light = Camera + vec3(mod(iTime*5.,100.)-50.,sin(iTime)*10.,50);\n    Ray ray = CreateRay(Camera, RayDirection(uv));\n    Intersection T = ComputeRayIntersection(ray);\n    float d = .1;\n    float e = 2.71828;\n  \tfloat fog = 1./(e*(0.125*T.Distance)*d);\n    vec3 p = RayPoint(ray,T.Distance);\n    float light = max(0.,dot(Normal(p),Light-p))/max(distance(Light,p),1.);\n    if (T.Collision)  \n        if (T.Light) COLOR = vec3(1);\n        else COLOR = vec3(1)*light;\n\tfragColor = vec4(COLOR,1.0);\n}","name":"Image","description":"","type":"image"}]}