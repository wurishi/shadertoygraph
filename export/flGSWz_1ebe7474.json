{"ver":"0.1","info":{"id":"flGSWz","date":"1640481856","viewed":54,"name":"20211226 ray marching sphere","username":"kamonumber","description":"reference\nhttps://logicalbeat.jp/blog/6237/\nhttps://wgld.org/d/glsl/g012.html","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nfloat spherSize = 0.8;\nvec3 lightDir = normalize(vec3(-0.5, 0.5, 0.0));//ディレクショナルライト\n\nvec3 rep(vec3 p){\n// 2Dでuvを反復するようなイメージ\n// 球が現れる(-1,-1,-1)~(1,1,1)の範囲を反復させる\n    float size = 1.6;\n    return mod(p,size*2.0)-size;\n}\n\nfloat df(vec3 p){\n    return length(rep(p))-spherSize;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.001;\n    vec3 v =normalize(vec3(\n        df(p+vec3(    d,0.0,0.0))-df(p+vec3(  -d,0.0,0.0)),\n        df(p+vec3(0.0,    d,0.0))-df(p+vec3(0.0,  -d,0.0)),\n        df(p+vec3(0.0,0.0,    d))-df(p+vec3(0.0,0.0,  -d))\n        ));\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // 正規化\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cPos = vec3(vec2(0.0),-3.0);\n    \n    // z=0のx,y（横,縦）平面上にシェーダーが付加された板ポリがある\n    // そのそれぞれのピクセルの板ポリ上での座標-カメラの座標\n    // を計算することでrayの方向ベクトルが計算できる\n    vec3 rDir = normalize(vec3(p,(0.0))-cPos);\n    \n    vec3 rPos = cPos;\n    float d = 0.0;\n    for(int i = 0;i<64;i++){\n        d = df(rPos);\n        rPos += + rDir * d;\n    }\n\n\n    //色つけ\n    if (d<0.01){\n        vec3 n = getNormal(rPos);\n        float diff = clamp(dot(lightDir, n), 0.1, 1.0);//ディレクショナルライト\n        float rim = 1.0-length(dot(rDir,n)*0.1);//リムライト\n        \n        fragColor = vec4(vec3(diff*rim+0.1),1.0);\n    }else{\n        fragColor = vec4(vec3(0.0),1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}