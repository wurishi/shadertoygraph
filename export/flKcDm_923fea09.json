{"ver":"0.1","info":{"id":"flKcDm","date":"1661608844","viewed":159,"name":"Joukowski 2","username":"cmarot","description":"Click above the airfoil to change its shape","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fluid","complex","joukowski","wing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\nIRROTATIONAL INCOMPRESSIBLE FLOW AROUND A JOUKOWSKI PROFILE\n===========================================================\n\nThe irrotational and incompressible flow around a Joukowski profile\nis largely documented using the Joukowsky transform\n   -> see https://en.wikipedia.org/wiki/Joukowsky_transform\nHowever, the inverse Joukowski transformation was mostly undocumented back in 2015\nwhen this shader was created.\nI decided to move this shader (from https://www.shadertoy.com/view/Xts3R2) to my new account\n\ncreated by CÃ©lestin Marot\nLicense Creative Commons Attribution-ShareAlike 4.0 International\n*/\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution.xy\n#define pi 3.14159265359\n\n\n/* PARAMETERS\n ******************/\n\nvec2 pos = vec2(0.0,0.0);\n\n// the lines\nfloat interval = 0.1;    // interval between isolines (the window height is 2)\nfloat linewidth = 0.33;  // the unit is the interval\n#define ISOX 0.03   // draw isox, the number is the thickness of the line (comment=disable)\n#define ISOY 1.0    // draw isoy, the number is the thickness of the line (comment=disable)\n\n// some color parameters (comment to disable)\n#define COLOR    // color corresponding to argument\n#define SHADE       // shade corresponding to modulus\n\n\n\n/* Useful complex functions \n ***************************/\nvec2 cartToPol(vec2 z){\n\treturn vec2(length(z),atan(z.y,z.x));\n}\n\nvec2 polToCart(vec2 p){\n\treturn vec2(p.r*cos(p.g),p.r*sin(p.g));\n}\n\nvec2 fracz(vec2 z1, vec2 z2){\n    return vec2(dot(z1,z2),z1.y*z2.x-z1.x*z2.y)/dot(z2,z2);\n}\n\nvec2 mulz(vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x-z1.y*z2.y,z1.x*z2.y+z1.y*z2.x);\n}\n\nvec2 powz(vec2 z , float power){\n    vec2 p = cartToPol(z);\n    return polToCart(vec2(pow(p.r,power),power*p.g));\n}\n\nvec2 logz(vec2 z, float angle){\n    vec2 p = cartToPol(z);\n    return vec2(log(p.r),mod(p.g+angle,2.0*pi)-angle);\n}\n\nvec2 expz(vec2 z){\n    return polToCart(vec2(exp(z.x),z.y));\n}\n\nvec2 I(float n){\n    return vec2(0.0,n);\n}\n\nvec2 R(float n){\n    return vec2(n,0.0);\n}\n\n\n/* put color given z\n ****************************/\nvec3 colorize(vec2 z,float r){\n    vec2 p = cartToPol(z);\n\n    #ifdef COLOR\n    float A = p.g/pi; // angle from -1 to 1\n    float AA = abs(A + 1.0/3.0) - 1.0;\n    float AAA = 1.0 - abs(A - 1.0/3.0);\n    vec3 color = vec3(1.0 - abs(A), 1.0 - abs(AA),1.0 - abs(AAA));\n    #elif 0\n    float w = length(z) * 0.25;\n    float w1 = 3.5*(w-0.7);\n\tfloat w2 = 1.25*w;\n\tfloat w3 = min(0.5,w)*2.0;\n    vec3 color = sqrt(r)*0.8*vec3(-w1*w1+1.,6.*w2*w2*(1.-w2),5.5*w3*(1.-w3)*(1.-w3));\n    #else\n    vec3 color=vec3(.5);\n    #endif\n\n    #ifdef SHADE\n    color *= exp(-0.5*p.r)*1.5;\n    #endif\n\t\n    #ifdef ISOX\n    color+=smoothstep(linewidth,0.,abs(mod(z.x,interval)*2./interval-1.))*ISOX;\n    #endif\n    #ifdef ISOY\n    color+=smoothstep(linewidth,0.,abs(mod(z.y+interval*.5,interval)*2./interval-1.))*ISOY;\n    #endif\n\n    color*=smoothstep(0.99,1.05,r);\n\n    return color;\n}\n\n\n/*   MAIN\n *************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 Z = ( (2.0*fragCoord.xy-resolution) / resolution.y)-pos ;\n    \n    // parameters for the Joukowski transform\n\t#define JOUKO       // Joukowski transform (comment for flow around a sphere )\n    // the radius of the circle (from which the Joukowski profile originate)\n    float a = 4.0*interval; // radius (chord)\n    float e = clamp(2.0*mouse.y/resolution.y-1.0-pos.y,0.0,a); // thickness (0<e<a)\n\tfloat d = mouse.x/resolution.x*pi/2.0;               // camber (-pi/2<=d<=pi/2)\n\tfloat alpha = cos(0.2*time)*pi/6.0;                  // angle of attack\n\n    //Circulation  ( K=-circulation/(4*pi*a*sin(alpha+beta)) )\n    float K = 1.0; // = 1.0 for Kutta condition\n\t\n    // rotating the airfoil + the flow\n    Z=mulz(Z,expz(I(alpha)));\n    \n    #ifdef JOUKO\n    /******************************\n     *  Inverse Joukowki transform\n     ******************************/\n        float b = -e*cos(d)+sqrt(e*e*cos(d)*cos(d)-e*e+a*a);\n        vec2 Z0 = e*expz(I(-d));\n        float beta = -atan(Z0.y,Z0.x+b);\n\n        vec2 Z1 = powz(mulz(Z-Z0,Z-Z0)-R(4.*b*b),0.5);\n    \t\n    \t/*\n    \tvec2 z1 = 0.5*(Z0+Z+Z1);\n    \tvec2 z2 = 0.5*(Z0+Z-Z1);\n    \tif(length(z1)>=a)\n            Z=z1;\n    \telse\n            Z=z2;\n\t\t*/\n    \t\n    \t// same as commented above but faster and better\n        Z = Z+Z0;\n    \tZ = 0.5*(Z+sign(dot(Z,Z1))*Z1);\n\n    /*******************************/\n    #else\n        float beta=0.0;\n    #endif\n\t\n    // rotating the flow in the opposite dir\n    Z=mulz(Z,expz(I(-alpha)));\n    \n    // modulus compare to radius\n    float r = length(Z)/a;\n\n    // flow around a circle of radius a\n    vec2 z = Z+fracz(R(a*a),Z);\n    \n    // adding circulation\n    float T = -2.0*K*a*sin(alpha+beta);\n    z-=mulz(I(T),logz(Z/a,(alpha+beta)*step(z.y/T,log(r))));\n\n    fragColor = vec4(colorize(z,r), 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}