{"ver":"0.1","info":{"id":"WtfcRr","date":"1591218053","viewed":115,"name":"Coulomb's Equipotential Lines","username":"cancred","description":"Customizable shader for drawing Coulomb's equipotential lines.\n\nSee COMMON for controls and available arguments description.\n\nThis is my first expirience with shaders, so code is probably just a huge mess. ","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["magnetic","potential","coulomb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tThis is result image.\n\tFeel free to set iChannel0 to buffer A (to see random noise) or to buffer B (to see potential map)\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 normalizedCoord = fragCoord / iResolution.xy;\n    fragColor=texture(iChannel0, normalizedCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\tCONTROLS:\n\n\tSPACE: GENERATE NEW LAYOUT\n\tMOUSE CLICK: MOVE CHARGE AT CURSOR\n\n\tFEEL FREE TO ADJUST ARGUMENTS BELOW \n\n*/\n\n/*\n\tCHARGE LAYOUT GENERATION ARGUMENTS SECTION\n*/ \n\n//ASCII keycode of restart button. 32 is SPACE\n#define RESTART_KEYCODE 32\n\n//How many charges to generate. It should be fine even with big numbers, we calculate potential map only once for each layout\n#define CHARGE_COUNT 5\n\n//Generated charges will be in range [MIN_CHARGE;MAX_CHARGE]\n#define MIN_CHARGE -1.0\n#define MAX_CHARGE +1.0\n\n/*\n\tPOTENTIAL CALCULATION ARGUMENTS SECTION\n*/ \n\n//Potential areas colors (only buffer B)\n#define POSITIVE_POTENTIAL_COLOR vec3(1.0, 0.0, 0.0)\n#define NEGATIVE_POTENTIAL_COLOR vec3(0.0, 0.0, 1.0)\n\n//Charge value at mouse position. Just set it to 0.0 if you don't need it\n#define MOUSE_CHARGE 0.5\n\n/*\n\tISOLINES DRAWING ARGUMENTS SECTION\n*/ \n\n//Absolute values of potential range for isoline drawing\n#define MIN_POTENTIAL 0.00\n#define MAX_POTENTIAL 0.02\n\n//Time in seconds between isolines appearance/disappearance\n#define TIME_PERIOD 2.0\n\n//Potential \"distance\" between isolines\n#define POTENTIAL_WINDOW 0.001\n\n//Isoline color\n#define POSITIVE_ISOLINE_COLOR vec3(1.0,1.0,0.0)\n#define NEGATIVE_ISOLINE_COLOR vec3(0.0,1.0,1.0)\n\nbool isKeyDown(sampler2D channel, int keycode){\n    if(texelFetch(channel, ivec2(keycode, 0),0).x != 0.0){\n    \treturn true;\n    }else{\n        return false;\n    }\n}\n\nbool isKeyPressed(sampler2D channel, int keycode){\n    if(texelFetch(channel, ivec2(keycode, 1),0).x != 0.0){\n    \treturn true;\n    }else{\n        return false;\n    }\n}\n\nbool isKeyToggled(sampler2D channel, int keycode){\n    if(texelFetch(channel, ivec2(keycode, 2),0).x != 0.0){\n    \treturn true;\n    }else{\n        return false;\n    }\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n\tThis buffer provides random noise to be used later for random generation of charges values and positions\n\n*/\n\n\n//This is not my code, and I lost its source.\nvec3 hash3(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(uint n){\n    \n    //We need to make sure it isn't 0, or else we will receive same result for any n\n    float milliseconds = iDate.w * 1000.0 + 1.0;\n    //We need to make sure it isn't 0, or else we will receive same result at zero index for any time\n    n++;\n    //I'm not sure about multiplication. But results look fine.\n    n *= uint(milliseconds);\n    \n    return hash3(n);\n}\n\nint positionToIndex(vec2 pos){\n    //Shouldn't forget that fragCoord lies at center of pixel (X.5, Y.5).\n\treturn int(floor(pos.y)*iResolution.x+pos.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 normalizedCoord = fragCoord / iResolution.xy;\n    \n    if(iFrame == 0 || isKeyPressed(iChannel3, RESTART_KEYCODE)){\n    \tfragColor = vec4(rand3(uint(positionToIndex(fragCoord))), 1.0);\n    }else{\n    \tfragColor = texture(iChannel0, normalizedCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\n\tThis buffer calculates potential map \n\n*/\n\nconst vec3 POSITIVE_COLOR = POSITIVE_POTENTIAL_COLOR;\nconst vec3 NEGATIVE_COLOR = NEGATIVE_POTENTIAL_COLOR;\n\nconst float POTENTIAL_RANGE = MAX_POTENTIAL - MIN_POTENTIAL;\n\nivec2 indexToPosition(int index){\n \n    int x = index % int(iResolution.x);\n    int y = index / int(iResolution.x);\n    \n    return ivec2(x,y);\n}\n\nvec3 getCharge(int index){\n    //Maybe should declare it as const\n\tvec3 minimalCharge = vec3(0.0, 0.0, MIN_CHARGE);\n    vec3 maximalCharge = vec3(iResolution.xy, MAX_CHARGE);\n    vec3 rawCharge = texelFetch(iChannel0, indexToPosition(index), 0).xyz;\n    \n    return mix(minimalCharge, maximalCharge, rawCharge);\n}\n\nfloat coulombPotentialMouse(vec2 pos){\n\treturn MOUSE_CHARGE / distance(pos, iMouse.xy);\n}\n\nfloat coulombPotential(vec2 pos){\n    float potential = 0.0;\n    \n    for(int i=0;i<CHARGE_COUNT;i++){\n        vec3 charge = getCharge(i);\n        \n    \tfloat dist = distance(pos, charge.xy);\n        potential += charge.z / dist;\n    }\n\n    return potential;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 normalizedCoord = fragCoord / iResolution.xy;\n    \n    float potential = 0.0;\n    float mousePotential =  coulombPotentialMouse(fragCoord);\n    \n    //We should perform potential map calculation only once\n    if(iFrame == 0 || isKeyPressed(iChannel3, RESTART_KEYCODE)){\n    \tpotential = coulombPotential(fragCoord);\n    }else{\n    \tpotential = texelFetch(iChannel1, ivec2(fragCoord), 0).w;\n    }\n    \n    mousePotential += potential;\n    vec3 color = (0.5 + 0.5 * sign(mousePotential)) * POSITIVE_COLOR + (0.5 - 0.5 * sign(mousePotential)) * NEGATIVE_COLOR;  \n    float intensity = smoothstep(MIN_POTENTIAL, MAX_POTENTIAL, abs(mousePotential));\n    \n    fragColor = vec4(intensity * color, potential);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\n\tThis buffer draws isolines\n\n*/\n\n\n\nconst float FREQUENCY = 1.0 / TIME_PERIOD;\nconst float POTENTIAL_WINDOW_INVERSE = 1.0 / POTENTIAL_WINDOW;\n\nconst vec3 POSITIVE_COLOR = POSITIVE_ISOLINE_COLOR;\nconst vec3 NEGATIVE_COLOR = NEGATIVE_ISOLINE_COLOR;\n\nfloat coulombPotentialMouse(vec2 pos){\n\treturn MOUSE_CHARGE / distance(pos, iMouse.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float potential = texelFetch(iChannel0, ivec2(fragCoord), 0).w + coulombPotentialMouse(fragCoord);\n    \n \tfloat potentialSign = sign(potential);\n    potential = abs(potential);\n    \n    float shift = fract(iTime * FREQUENCY);\n    float windowIndex = potential * POTENTIAL_WINDOW_INVERSE +  shift;\n    float delta = fwidth(windowIndex);\n\n    float intensity = step(MIN_POTENTIAL, potential) - step(MAX_POTENTIAL, potential);\n    intensity *= 1.0 - smoothstep(0.0, delta, abs(fract(windowIndex)-0.5));\n    //this should be equivalent \n    //intensity *= smoothstep(0.5-delta, 0.5, fract(windowIndex))-smoothstep(0.5, 0.5+delta, fract(windowIndex));\n\tvec3 color = (0.5 + 0.5 * potentialSign) * POSITIVE_COLOR + (0.5 - 0.5 * potentialSign) * NEGATIVE_COLOR; \n    fragColor = vec4(color * intensity, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}