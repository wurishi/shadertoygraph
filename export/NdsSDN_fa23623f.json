{"ver":"0.1","info":{"id":"NdsSDN","date":"1618669329","viewed":63,"name":"My changes impul gusandr 045","username":"gusandr","description":"Messing around with refractions. I am quite new to shader programming\n  and raymarching so while I think the code might not be very good I also think that\n  what makes ShaderToy.com so good is that programmers are sharing what they do, \n  big and small.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["glass"],"hasliked":0,"parentid":"NdsSW4","parentname":"Fork impulse_gl gusandr 029"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TOLERANCE       0.000001\n#define MAX_RAY_LENGTH  16.0\n#define MAX_BOUNCES     8\n#define MAX_RAY_MARCHES 90\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define DEG2RAD         (PI/180.0)\n\n\n\n\nvec2 uv;\n#define AA              0\n\nfloat sgn(float x)\n{\n  return (x<0.0)?-1.0:1.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n  float t = dot(p, planeNormal)+offset;\n  if (t < 0.0)\n  {\n    p = p - (2.0*t)*planeNormal;\n  }\n  return sgn(t);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\n\n\nfloat sdRoundCube(in vec3 p, float r1)\n{\n    float s = 1.8;\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    \n\tvec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k));   \n}\n\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\n\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\n\nfloat bubbles(in vec3 p)\n{\n  vec3 pp = p - vec3(0.1) - vec3(0.0, 10.4935, -1.0);\n  pReflect(pp, normalize(vec3(1.0, 0.5, 0.2)), 0.3);\n  pReflect(pp, normalize(vec3(0.2, 0.5, 1.0)), 0.2);\n  pMod3(pp, vec3(0.5, 0.3, 0.4));\n\n\n  float ss = sdSphere(pp, 0.05);\n  float sss = 1.;\n\n  return smin(ss, sss, 20.0);\n}\n\nfloat impulse4(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float sb = sdRoundCube(p, 1.0);\n  float s = 4.5;\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\n\n\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n\n  float i = 10000000.0;\n  \n  i = impulse4(p, col, ref, trans, absorb);\n  float rc = sdRoundCube(p - vec3(0.0, -5.05, 0.0), 4.0);\n\n  float d = min(rc, i);\n  if (d == rc)\n  {\n    col    = vec3(1.0);\n    ref    = 0.2;\n    trans  = 0.0;\n  }\n  return d;\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nconst vec3 lightPos1 = 100.0*vec3(-0.3, 0.0, 1.0);\nconst vec3 lightPos2 = 100.0*vec3(-0.5, -0.1, -1.2);\n\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return MAX_RAY_LENGTH;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return MAX_RAY_LENGTH;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\n\n\nvec3 getSkyColor(vec3 rayDir, vec3 pos) {\n\n    vec3 col = vec3(0);\n    float g = uv.x - 0.  + 0.5*rayDir.x;\n    if (uv.y - 0.3 + g*g< 0.) {\n\n        float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n\n        col = texture(iChannel2, pos.xz).xyz;\n        return col;\n    }\n    \n    vec3 lightDir1 = normalize(lightPos1);\n    vec3 lightDir2 = normalize(lightPos2);\n\n    float ld1      = max(dot(lightDir1, rayDir), 0.0);\n    float ld2      = max(dot(lightDir2, rayDir), 0.0);\n    vec3 final     = vec3(0.125);\n\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n    final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n    final += lightCol1 * pow(ld1, 200.0);\n    final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n    final += lightCol2 * pow(ld2, 200.0);\n    \n    return final;\n\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  float t = mint;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);\n    float distance = dmod*distance_;\n    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n  return t;\n}\n\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  //col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 lightPos = 1.5*vec3(1.5, 3.0, 1.0);\n  vec3 lightPos2 = 1.5*vec3(-1.5, 1.0, -1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  float refraction = 0.9;\n\n  refraction = 0.9;\n  \n  bool inside = false;\n\n  float mint    = 0.01;\n  float minstep = 0.001;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      final += ragg*getSkyColor(rd, pos);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside)\n    {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3 lv   = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n\n\n    vec3 lv1   = lightPos1 - pos;\n    vec3  ld1  = normalize(lv1);\n    float ll1  = length(lv1);\n\n\n    float dif = max(dot(nor,mix(ld, ld1, 1.5)),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*occ;\n\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl, pos);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n\n    vec3 beer = vec3(1.0);\n\n    if (inside)\n    {\n      beer = exp(-absorb*t);\n    }\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0))\n    {\n        rd = refl;\n    }\n    else\n    {\n      rd = refr;\n      inside = !inside;\n    }\n\n  }\n\n\n  return final;\n}\n\nvec3 getSample(in vec2 p)\n{\n  vec3 ro  = vec3(4.0, 0.1, 0.0);\n\n  vec3 la  = vec3(0.0);\n\n  pR(ro.xz, 0.2);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 q=fragCoord.xy/iResolution.xy;\n  uv = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n\n  vec3 col = getSample(p);\n  \n  fragColor = vec4(postProcess(col, q), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}