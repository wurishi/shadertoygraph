{"ver":"0.1","info":{"id":"XtVfWy","date":"1543922323","viewed":290,"name":"a Stranger - imported","username":"Machia","description":"TokyoDemoFest 4kb intro - import\n","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["intro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//uniform float t = iTime;\nuniform vec2 resolution;\n\n//uniform int beat;\n\n//uniform float step;\n\nprecision mediump float;\n\n#define z3\tvec3(0.)\n#define z4\tvec4(0.)\n#define V vec3(0.,1.,-1.)\n\n#define BPM\t130.\n#define OFFSET 50.\n\nconst float PI = 3.14159265;\nint bt =2;\n\nconst float sphereSize = 1.;\nvec3 light = vec3(-1,-2,-1);\n\nvec3 particle[500];\nint beat = 1;\nint stop_flag=0;\n\nfloat BPMSync( float t ){\n\t//bt = (beat != 0)?beat:bt;\n\t//フラグを建てて管理する\n\tfloat fx = t+OFFSET;\n\treturn (stop_flag!=1)?fract(fx*.001/240.*BPM*float(beat)):0.;\n}\n\n\n\nbool inCircle(vec2 position, float size) {\n    float len = length(position);\n    if (len < size) {\n        return true;\n    }\n    return false;\n}\n\nfloat calculateRampCoefficient( float t, int sC )\n{\n\tfloat fSC = float(sC);\n\tfloat mT = mod( floor( t * fSC ), fSC );\n\tfloat rC = mix( .1, 1., mT / (fSC-1.) );\n\t\n\treturn rC;\n}\n\nvec4 random2H(vec2 _v) {\n\treturn vec4(fract(sin(dot(_v, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nvec4 random(float _v) {\n\treturn random2H(_v * V.yy);\n}\n\nfloat perlin(vec3 p) {\n\tvec3 i = floor(p);\n\tvec4 a = dot(i,vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*PI)*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere_d(vec3 pos,float r){return length(pos)-r;}\n\n//vec3 trans(vec3 p){return mod(p, 4.) - 2.;}\n\n//float plane_d(vec3 pos){return length(max(abs(pos)-vec3(1.,0.,1.),pos.y));}\n\nmat3 x_axis_rot(float a){\n\tfloat c=cos(a),s=sin(a);\n\treturn mat3(1.,0.,0.,\n\t\t\t0.,c,s,\n\t\t\t0.,-s,c);\n}\nmat3 y_axis_rot(float a){\n\tfloat c = cos(a),s = sin(a);\n\treturn mat3(c,0.,s,\n\t\t\t0.,1.,0.,\n\t\t\t-s,0.,c);\n}\n/*\nmat3 z_axis_rot(float a){\n\tfloat c=cos(a),s=sin(a);\n\treturn mat3(c,s,0,\n\t\t\ts,-c,0.,\n\t\t\t0.,0.,1.);\n}\n*/\n\n//立方体\nfloat box_d(vec3 pos,float sz){\n\treturn length(max(abs(pos) - vec3(sz),0.));\n}\n\nfloat b_o(vec3 pos, vec3 offset,float sz){\n\treturn length(max(abs(pos-offset) -vec3(sz), 0.)); \n}\n\n//球体出力\nfloat sp_o(vec3 pos,float r){return length(pos)-r;}\n\nfloat sdCps( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h ) -r;\n}\n\n//前の方にあるオブジェクトの値を取得。\n//float opU( float d1, float d2 ){return (d1<d2)?d1:d2;}\n\n//同じベクトルの内積？\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nmat3 setC( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec2 monster( vec3 p, vec3 w, float _t){\n\t//t初期値\n\tfloat r = 100.;\n\tfloat c = 0.;\n\t\n\t//perlinノイズ。ボディ等に使用\n\tfloat noiz = abs(perlin(p * 7.)*BPMSync(_t) * .025)*2.4;\n\n\tvec3 breath = z3;\n\n\t//ボディ\n\tr = min(r, length(p-vec3(-.4, .1+sin(_t*.01)*.01, 0.)-w )- .2 + noiz );\n\t\n\tfloat ey = length(p-vec3(-0.56,0.17+sin(_t*.01)*.01,0)-w)-0.08;\n\tr = min(r, ey);\n\t\n\t\n\t//ボディ２（大きい方）\n\tr = min( r, length(p-vec3(.0, .1+sin(_t*.008+3.1)*.01, 0.)-w )- .36+ noiz);\n\t\n\tvec3 arm= vec3(.35,.2,.35);\n\tfloat rt= sin(_t*.007)*.01;\n\n\t//前足\n\tr = min(r,sdCps(p,w,vec3(-.35,.2+rt,-.35)+w,.09 )+noiz );\n\tr = min(r,sdCps(p,vec3(-.35,.2+rt,-.35)+w,vec3(-.3,-.2,-.4)+w,.09 )+noiz );\n\n\t//前足\n\tr = min(r,sdCps(p,+w,vec3(-.35,0.2+rt,0.35)+w,0.09 )+noiz );\n\tr = min(r,sdCps(p,vec3(-.35,.2+rt,0.35)+w,vec3(-.3,-.2,.4)+w,.09 )+noiz );\n\t\n\t//後足\n\tr = min(r,sdCps(p,w,vec3(.35,.2+rt,-.5)+w,.09 )+noiz );\n\tr = min(r,sdCps(p,vec3(.35,.2+rt,-.5)+w,vec3(.4,-.2,-.55)+w,.09 )+noiz );\n\t\n\t//後足\n\tr = min(r,sdCps(p,+w,vec3(.35,.2+rt,.5)+w,.09 )+noiz );\n\tr = min(r,sdCps(p,vec3(.35,.2+rt,.5)+w,vec3(.4,-.2,.55)+w,.09 )+noiz );\n\t\n\tc = (r ==ey)?3.:1.;\n\treturn vec2(r,c);\n}\n\n\nvec2 opScale( in vec3 p, vec3 w, float _t,in float s  ){return monster(p/s,w,_t)*s;}\n\n//float dot2( in vec3 v ) { return dot(v,v); }\n\n//ベジェ曲線\n//vec3 be(vec3 p0,vec3 p1,vec3 p2,float t){return (1.-t)*(1.-t)*p0+2*(1-t)*t*p1+t*t*p2;}\n\n\nfloat map(vec3 p){return 1.0 - dot(p, vec3(0., 1., 0.) );}\n\nvec2 dF(vec3 p){\n\t\n\tfloat data = 1.;\n\n\t//vec3 moving = vec3( be(z3,light,vec3(1.0),step) );\n\tvec3 m2 = vec3(-0.15,0.1,0);\n\t\n\t//穴あけ部分モンスター\n\tvec2 q = monster(p,m2,iTime*1000.);\n\t\n\t//立方体\n\tfloat r2=100.;\n\tfloat range=2.;\n\t\n\tr2 = min(r2, b_o( p, vec3(-0.1,-0.8,0), 0.7) );\n\t\n\t//球\n\tfloat r = max(-q.x ,\n\t//矩形\n\t r2\n\t );\n\t \n\t //描画するモンスター\n\t vec2 u = opScale(p,m2,iTime*1000.,0.95);\n\t r =min(r, u.x );\n\t r = max(r,-map(p) );\n\n\t//球体が前にある場合、球体の色を塗るものとする\n\tdata = (r!=u.x)?2.:1.;\n\tdata = (q.y == 3.)?3.:data;\n\treturn vec2(r,data);\n}\n\nfloat genShadow(vec3 ro, vec3 rd){\n\tfloat h = .0;\n\tfloat c = .001;\n\tfloat r = 1.;\n\tfloat shadowCoef = .5;\n\tfor(float t = 0.; t < 50.; t++){\n\t\th = dF(ro + rd * c).x;\n\t\tif(h < .001){\n\t\t\treturn shadowCoef;\n\t\t}\n\t\tr = min(r, h * 1.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec3 getNormal(vec3 p){\n\tfloat d = .006;\n\tvec3 n1= normalize(vec3(\n\t\tdF(p + vec3(  d, 0., 0.)).x - dF(p + vec3( -d, 0., 0.)).x,\n\t\tdF(p + vec3(0.,   d, 0.)).x - dF(p + vec3(0.,  -d, 0.)).x,\n\t\tdF(p + vec3(0., 0.,   d)).x - dF(p + vec3(0., 0.,  -d)).x\n\t));\n\treturn n1;\n}\n\n\nvec4 sequence( float time, float tick ){\n\t\n\t/*=========|=========|=========|=========*/\n\tfloat fx_t = time + OFFSET;\n\tvec4 s_t;\n\t\n\t//拍子数を返す（四分音符のカウント、作曲に使用）\n\tfloat s = mod(floor(time/240.*BPM*float(2)),4.);\n\n\t//ティックごとの数値を返す\n\tfloat t = fract(time/240.*BPM*float(tick));\n\t\n\t//指定された拍子数を返す\n\tfloat u = mod( floor( time/240.*BPM*float(tick)),tick );\n\t\n\t//小節数を返す\n\tfloat v = floor(time*0.001/240.*BPM);\n\t\n\ts_t.x = s;\n\ts_t.y = t;\n\ts_t.z = u;\n\ts_t.w = v;\n\t\n\treturn s_t;\n}\n\n\nfloat fade_r=0.;\nfloat mono_rate[3];\nfloat rotate_plus=0.0;\nfloat r_rate=1.0;\n\nvoid sch(){\n\t//フェードインアウト\n    \n\n\tif( iTime*1000.>2000.){\n\t\n\t\tif( iTime*1000.>135000.){\n\t\t\tfade_r = 1.-(iTime*1000.-135000.)*0.00015;\n\t\t\tfade_r = (fade_r<0.)?0.:fade_r;\n\t\t}else{\n\t\t\tfade_r = (iTime*1000.-2000.)*0.0001;\n\t\t\tfade_r = (fade_r>1.)?1.:fade_r;\n\t\t}\n\t}else\n\t\tfade_r = 0.;\n\n\n\t//fade_r = 1.;\n\t\n\tvec4 bts = sequence(iTime*1000., float(beat));\n\t\n\t//時間によってビートを変更する\n\t\n\tbeat = (bts.w >11.)?4:beat;\n\tbeat = (bts.w>59.)?1:beat;\n\t\n\tif(beat>=4){\n\t\t//時間によって回転を追加する\n\t\tif( mod(bts.w,8.) >=7. ){\n\t\t\tbeat = 8;\n\t\t\tr_rate = 1.5;\n\t\t}\n\t\t\n\t\tif( mod(bts.w,16.) >=15.){\n\t\t\tbeat = 16;\n\t\t\tr_rate = 2.4;\n\t\t}\n\t}\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// fragment position\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t// camera\n\t//初期値1.84___ _far\n\tfloat far = 1.44;\n\tfloat cam_x = 0.781,cam_y = 0.,cam_z=0.;\n\t\n\t//camera_pos.x = 0.781  \n\t\n\tsch();\n\t\n\t//展開によってカメラの位置を変更する\n\tcam_x += (float(iTime*1000.))*0.0001;\n\tcam_y += BPMSync(iTime*1000.) *0.2;\n\t\n\tvec3 cPos = vec3( cam_z+far*cos(cam_x*PI), 0.5*far+cam_y*r_rate , far*sin(cam_x*PI) );\n\tvec3 ta = z3;\n\t// camera-to-world transformation\n\tmat3 ca = setC(cPos, ta, 0.);\n\tvec3 lightDir =vec3(-0.177*sin(iTime*1000.*r_rate*0.005), .477, .577*cos(iTime*1000.*r_rate*0.006));\n\t\n\t// ray direction\n\tvec3 ray = ca * normalize( vec3(p.xy,2.2) );\n\n\t// marching loop\n\tvec2 distance = vec2(0.);\n\tfloat rLen = 0.;\n\t\n\t//カメラの位置を変更する\n\t\n\tvec3  rPos =cPos;\n\tvec3 result = rPos;\n\tmat3 rotx = y_axis_rot( iTime*1000.*.001);\n\tmat3 roty = x_axis_rot(.5);\n\t\n\t//マーチングループ\n\tfor(int i = 0; i < 32; i++){\n\t\t//distance function実行\n\t\tdistance = dF(rPos);\n\t\trLen += distance.x;\n\t\trPos = cPos + ray * rLen;\n\t\t\n\t\t//if分岐\n\t\tif( distance.x>4.)\n\t\t\tbreak;\n\t}\n\t\n\t//ベース色・・・ここでは黒。\n\t//z4=vec4(0.0)のこと。#defineにて定義\n\tvec4 c = z4;\n\tfloat shadow = 5.0;\n\t\n\t// ライティングを含めた色の定義\n\tif(abs(distance.x) < .0001){\n\t\t\n\t\t//ノーマルマップの取得\n\t\tvec3 normal=getNormal(rPos);\n\t\t\n\t\tvec3 halfLE = normalize(lightDir - ray);\n\t\tfloat diff=clamp(dot(lightDir, normal), .1, 1.);\n\t\tfloat spec = pow(clamp(dot(halfLE, normal), 0.0, 1.0), 25.0);\n\t\t\n\t\t//トゥーンシェード用の定義。（ノーマルマップの推移を大雑把にする）\n\t\tdiff=calculateRampCoefficient(diff,int(8));\n\t\t\n\t\t//影生成\n\t\tshadow = genShadow(rPos + normal * 0.001, light);\n\t\t\n\t\t//マテリアル1番（モンスター）の色定義\n\t\tif( distance.y==1.){\n\t\t\tc+=(diff==0.)?vec4(1.):vec4(vec3(diff)+vec3(0.15,0.4,0.1)+vec3(spec)*0.4,1.);\n\t\t}\n\t\t//マテリアル2番（地面）の色定義\n\t\telse if(distance.y==2.){\n\t\t\tc=(dot(rPos,normal)<.25) ? vec4(vec3(.1),1.):z4;\t\n\t\t\tc+=(diff==0.)?vec4(1):vec4(vec3(diff)*0.5+vec3(0.15)+vec3(spec),1.);\n\t\t}\n\t\t//目部分\n\t\telse if(distance.y ==3.){\n\t\t\tc+=(diff==0.)?vec4(1.):vec4(vec3(diff)+vec3(0.1,.1,1.)+vec3(spec),1.);\n\t\t}else{\n\t\t\tc+=vec4(vec3(diff),1.);\n\t\t}\n\t}else{\n\t\t//背景色(r,g,b)\n\t\tfloat ganma=1.5;\n\t\tc = vec4(vec3((p.y)*0.25,(p.y-0.65),0)*ganma, 1.0);\n\t\tdistance.y =10.;\n\t}\n\t//\n\n\t//ポイントライト\n\t\n\tfor( int i=0; i<6; i++){\n\t\tif(inCircle(p-vec2(1.6*sin(iTime*1000.*0.001+float(i)),0.25+0.5*cos(iTime*1000.*0.0015+float(i))),0.15) ){\n\t\t\tc.xyz += (distance.y != mod(float(i),3.)+1.)?vec3(0.35,0.1,.1):z3;\n\t\t}\n\t\tif(inCircle(p-vec2(1.6*sin((iTime*1000.-100.)*0.001+float(i)),0.25+0.5*cos((iTime*1000.-100.)*0.0015+float(i))),0.15) ){\n\t\t\tc.xyz += (distance.y != mod(float(i),3.)+1.)?vec3(0.15,0.1,.2):z3;\n\t\t}\n\n\t}\n\t\n\t\n\t\n/*\t\n\t  float grayColor = dot(color.rgb, monochromeScale);\n  color = vec4(vec3(grayColor), 1.0);\n  gl_FragColor = vec4(color);\n*/\t\n\n/*\n\t//gr;\n\tif(distance.y != 3){\n\tfloat gr = dot(c.xyz, vec3(0.298912,0.586611,0.114478));\n\t//c = vec4((c.xyz+vec3(gr))/1.5,1.);\n\t\n\t//暗転\n\tc = vec4(vec3(gr)/2,1.);\n\t}\n\t\n\n\t\n\t*/\n\t\tc.xyz = fade_r*c.xyz;\n\tfragColor = c;\n\t//gl_FragColor = vec4(pow( c.xyz*max(0.2,shadow), vec3(ganma) ),1.0);\n\t\n}\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.1415926535\n#define BPM 130.0\n#define V vec3(0.,1.,-1.)\n\n//out vec2 gain;\n\nfloat pitch(float p) {\nreturn pow(1.059460646483, p) * 440.0;\n}\n\n// wave genelators ----------\nfloat noiz(float s){\n  return fract(sin(s*78.233)*43758.5453)*1.;\n}\n\nfloat tone( float note ){\n\treturn 2.0*PI*pitch(note);\n}\n\nfloat saw(float phase) {\n float s = 0.0;\n for (int k = 1; k <= 8; k++) {\n s += (sin(2.0*PI*float(k)*phase) / float(k));\n }\n return (1.0/2.0) - (1.0/PI)*s - 0.5;\n}\n\nvec4 random2H(vec2 _v) {\n\treturn vec4(fract(sin(dot(_v, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nvec4 random(float _v) {\n\treturn random2H(_v * V.yy);\n}\n\n\nvec4 sqc( float time, float tick ){\n\t\n\t/*=========|=========|=========|=========*/\n\tvec4 s_t;\n\t\n\t//拍子数を返す（四分音符のカウント、作曲に使用）\n\tfloat s = mod(floor(time/240.*BPM*float(2)),4.);\n\n\t//ティックごとの数値を返す\n\tfloat t = fract(time/240.*BPM*float(tick));\n\t\n\t//指定された拍子数を返す\n\tfloat u = mod( floor( time/240.*BPM*float(tick)),tick );\n\t\n\t//小節数を返す\n\tfloat v = floor(time/240.*BPM);\n\t\n\ts_t.x = s;\n\ts_t.y = t;\n\ts_t.z = u;\n\ts_t.w = v;\n\t\n\treturn s_t;\n}\n\n\nfloat pad( float time,float semi){\n\tfloat s = 0.0; float semitones[4];\n\tsemitones[0] = 0.0; semitones[1] = 4.0;\n\tsemitones[2] = 7.0; semitones[3] =9.0;\n\n\tconst int VOICES = 4;\n\t\n\t//譜面カウンタ\n\t//（t：1小節内の二分音符のカウント、t2：譜面いっこの経過時間）\n\tfloat t1 = mod(floor(time/240.*BPM*float(2)),4.);\n\tfloat t2 = fract(time/240.*BPM*float(2));\n\tfloat t3 = (t1>= 2.)?1.:0.;\n\t\n\tfloat main_seq[4];\n\tmain_seq[0]=0.,main_seq[1]=0.,main_seq[2]=3.,main_seq[3]=3.;\n\t\n\n\tvec4 sq = sqc(time, .5);\n\n\t//音色部分\n\tfor (int i = 0 ; i < 4; i++) {\n\t \n\t float q = mod(sq.w,4.);\n\t \n\t \t//ピッチの変更\n\t\t float f = pitch(-2.+semi+main_seq[int(q)]+(semitones[i]));\n\t\t \n\t\t const int UNISON = 8;\n\t\t for (int u = 0; u < UNISON-1; u++) {\n\t\t \n\t\t\t float fu = float(u);\n\t\t\t float new_f = f + fu * sin(fu);\n\t\t\n\t\t\t//データ\n\t\t\t s += saw(time * new_f) * (1.0/float(UNISON))\n\t\t\t * (1./float(VOICES))\n\t\t\t *min(1., sq.y*6.)\t//アタック\n\t\t\t *max(0., 1.5-sq.y) //ディケイ\n\t\t\t ;\t//音量\n\t\t }\n\t }\n\n\t return s;\n}\n\nfloat kick(float time){\n\tfloat s = 0.;\n\t\n\tvec4 sq1 = sqc(time,4.);\n\tvec4 sq2 = sqc(time,8.);\n\t\n\t//拍子を返す\n\tfloat t1 = sq1.x;\n\tfloat t3 = sq2.x;\n\t\n\t//ティックごとの大きさを返す\n\tfloat t2 = sq1.y;\n\tfloat t4 = sq2.y;\n\t\n\tfloat t_r = t2;\n\tt_r = ( sq2.z>=7. && mod(sq1.x,4.) == 3. )?t4:t2;\n\t\n\tfloat f = pitch(9.-t2*35.);\n\t\n\n\t//t_r = ()?t4:t2;\n\t\n\t//最終的なピッチを決定\n\ts += sin(t_r*f)\n\t*min(1., t_r*6.)\t//アタック\n\t*exp(-t_r*8.7)//*max(0, 1-t2*5.5)\n\t//*max(0,1-t_r)\n\t;\n\t\n\treturn s;\n}\n\nfloat hihat(float time ) {\n\tvec4 sq = sqc( time, 16.);\n\t\n\tfloat _seed = sq.y,_dec = _seed*18.;\n\treturn (random(_seed).x + random(_seed + _dec).x) * .5 * exp(-_dec/1.5) ;\n}\n\nfloat snare(float time,float flag) {\n\tvec4 sq = sqc( time, 16.);\n\tvec4 sq2 = sqc( time,4.);\n\t\n\tfloat _seed = sq.y,_dec = _seed*7.5;\n\tflag = (mod(sq.w,16.) == 15.)?1.0:flag;\n\tflag = (mod(sq.w,8.) == 7. && mod(sq.z, 16.) > 7.)?1.0:flag;\n\tflag = (mod(sq.w,4.) ==3. && mod(sq.z, 16.) > 13.)?1.0:flag;\n\t\n\tfloat s = 0.;\n\ts = (mod(sq.z,8.) != 4. )?0.:(random(_seed).x*1.5 ) * 1.3 * exp(-_dec/3.);\n\t//s += (sq2.x > 4. )?(random(_seed).x*1.5 ) * 1.5 * exp(-_dec/4.5) : 0;\n\t\n\ts = (flag ==1.0) ? (random(_seed).x*1.5 ) * 1.5 * exp(-_dec/4.5): s;\n\t\n\t\n\treturn s*0.7;\n}\n\nfloat bassline(float time,float semi ){\n\n\tfloat ptn[16];\n\tptn[0]=0.,ptn[1]=0.,ptn[2]=12.,ptn[3]=0.,\n\tptn[4]=0.,ptn[5]=0.,ptn[6]=0.,ptn[7]=12.,\n\tptn[8]=0.,ptn[9]=0.,ptn[10]=0.,ptn[11]=0.,\n\tptn[12]=12.,ptn[13]=0.,ptn[14]=0.,ptn[15]=0.;\n\t\n\tvec4 sq = sqc( time, 16.);\n\t\n\t//semi = (mod(sq.w,4)>2)?semi:semi;\n\t\n\tfloat bs_note = -21.+semi;\n\tbs_note =(mod(sq.x,4.) ==2.)?bs_note-7.:bs_note;\n\tbs_note =(mod(sq.x,4.) ==3.)?bs_note-5.:bs_note;\n\t\n\tint tick = int(sq.z);\n\tfloat note = (ptn[tick] != 44.)?bs_note + ptn[tick]:0.;\n\t\n\tfloat t1 = (ptn[tick]==44.)? 0. :(sin(tone(note)*time) );\n\tfloat a = 2.5*sq.y;\n\tt1 = t1*min(1., sq.y*1.)\t//アタック\n\t//*(exp(-sq.y*2.));\t//フェードアウト\n\t*max(0., 1.-sq.y) //ディケイ\n\t;\n\t\n\treturn t1;\n}\n\nfloat sq2( float time){\n\tfloat ptn[16];\n\t\n\tptn[0]=0.,ptn[1]=0.,ptn[2]=7.,ptn[3]=0.,\n\tptn[4]=0.,ptn[5]=7.,ptn[6]=0.,ptn[7]=0.,\n\tptn[8]=7.,ptn[9]=0.,ptn[10]=0.,ptn[11]=7.,\n\tptn[12]=0.,ptn[13]=0.,ptn[14]=7.,ptn[15]=0.;\n\t\n\tvec4 sq = sqc( time, 16.);\n\tfloat bs_note = -3.;\n/*\t\n\tbs_note =(mod(sq.x,4) ==2.)?bs_note-5.:bs_note;\n\tbs_note =(mod(sq.x,4) ==3.)?bs_note-4.:bs_note;\n\t//bs_note = (mod(sq.x,2)==1)?bs_note-3:bs_note;\n\t*/\n\t\n\tint tick = int(sq.z);\n\tfloat note = (ptn[tick] != 44.)?bs_note + ptn[tick]:0.;\n\t\n\tfloat t1 = (ptn[tick]==44.)? 0. :(saw(pitch(note)*(time+sin(time*pitch(note/2.))) ) );\n\t//float a = 1.*sq.y;\n\tt1 = t1//*((a>1.0)?1.0:a)\n\t*(exp(-sq.y*8.));\t//フェードアウト\n\n\treturn t1;\n}\n\nfloat sq3( float time,float semi){\n\tvec4 sq = sqc( time, 1.);\n\t\n\tfloat bs_note = -3.+semi;\n\t\tfloat note =100.;\n\t\n\tfloat t1 =(saw(pitch(note)*(sin(pitch(note/2.)*sq.y)) ) );\n\tt1 = ( mod(sq.w,4.)==0.)?t1:0.;\n\t/*float a = 16.*sq.y;\n\tt1 = t1*((a>1.0)?1.0:a)\n\t*(exp(-sq.y*9.));\t//フェードアウト\n\t*/\n\t\t\tt1 *= max(0., 1.-sq.y*2.); //ディケイ\n\treturn t1;\n}\n\nvec2 mainSound( in int samp, float time ) {\n\tvec2 s=vec2(0.);\n\t\n\tfloat semi = 0.;\n\tfloat count = floor(time/240.*BPM);\n\tvec4 sq =sqc(time,2.);\n\t\n\tfloat tr[10];\n\tfor( int i=0;i<9;i++){\n\t\ttr[i] = 0.0;\n\t}\n\t//通常シーケンス===================================================\n\t\n\tfloat cr = 1.;\n\tfloat s_roll = 0.;\n\tfloat smt=0.;\n\tsemi = (count>1.)?semi-3.:semi;\n\ttr[0]=(count>1.)?1.:0.;\n\ttr[1] = (count>1.)?1.:0.;\n\ttr[6] = (count>11.)?1.:0.;\n\ttr[7] = (count>15.)?1.:0.;\n\ttr[8] = (count>18.)?1.:0.;\n\ttr[2] = (count>19.)?1.:0.;\n\t//tr[3] = (count>23)?1.:0.;\n\t\n\t//転調パート\n\tsemi = (count>31.)?semi-2.:semi;//\n\tsemi = (count>39.)?semi+1.:semi;//1:13\n\tsemi = (count>47.)?semi+2.:semi;//1:29\n\n\ttr[6] =(count>59.)?0.:tr[6];\n\ttr[7] =(count>59.)?0.:tr[7];\n\ttr[8] =(count>59.)?0.:tr[8];\n\ttr[2] =(count>60.)?0.:tr[2];\n\t\n\ttr[0]=(count>67.)?0.:tr[0];\n\ttr[1] = (count>67.)?0.:tr[1];\n\t\n\n\t//通常シーケンス===================================================\n\t\n\ts += tr[0]*pad(time, semi)*vec2(.9,.4);\n\ts += tr[0]*pad(time+.24, semi)*vec2(.3,.8);\n\ts += tr[0]*pad(time+.48, semi)*vec2(.5,.5);\n\n\ts += tr[1]*bassline(time, semi)*vec2(.55);\n\ts += tr[1]*bassline(time+.008, semi)*vec2(.28);\n\t\n\ts += tr[7]*sq2(time)*vec2(.5);\n\ts += tr[2]*sq3(time, semi)*vec2(.0,.4);\n\t\n\t//s += sq4(t,smt)*vec2(0.4);\n\t\n\ts += tr[6]*kick(time)*vec2(1.)*.85;\n\t//s += tr[7]*hihat(t)*vec2(.82,.2)*.35;\n\ts += tr[8]*snare(time,s_roll)*vec2(.2,.8)*.5;\n\t\n\t//フェードイン。\n\tfloat fade_in = time*.05;\n\tfade_in = (fade_in>.8)?.8:fade_in;\n\n\tfloat f_o =1.;\n\tif(count==67.){\n\t\t\n\t\tf_o = (sq.x==3.)?(1.-sq.y):f_o;\n\t}\n\tf_o = (count>67.)?0.:f_o;\n\n\treturn vec2(s)* fade_in*f_o*1.5;\n}\n","name":"Sound","description":"","type":"sound"}]}