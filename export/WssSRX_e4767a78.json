{"ver":"0.1","info":{"id":"WssSRX","date":"1551785157","viewed":120,"name":"shadow study 3","username":"mindtree","description":"more shadowy bizz","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define WALL_LIGHT_AMP 2.0\n#define LIGHTA_AMP 3.0\n\n#define WALL_X 7.0\n\nconst int MODE_WALL_LIGHT_FLICKER = 0;\nconst int MODE_WALL_LIGHT_PHASE = 1;\nconst int MODE_OVERHEAD_LIGHT_PHASE = 2;\n\nconst float PI = 3.1457;\n\nfloat bpm() { return 128.5; }\nfloat beats_per_bar() { return 4.; }\nfloat bar() { return iTime * bpm() / 60.0 / beats_per_bar(); }\nfloat bar_phase() { return mod(bar(), 1.0); }\nfloat bar2_phase() { return mod(bar(), 2.0) / 2.0; }\nfloat bar4_phase() { return mod(bar(), 4.0) / 4.0; }\nfloat bar8_phase() { return mod(bar(), 8.0) / 8.0; }\nfloat bar16_phase() { return mod(bar(), 16.0) / 16.0; }\nfloat beat() { return iTime * bpm() / 60.0; }\nfloat beat_phase() { return mod(beat(), 1.0); }\nfloat minim_phase() { return mod(beat()*0.5, 1.0); }\nfloat quaver_phase() { return mod(beat()*2.0, 1.0); }\nfloat semiquaver_phase() { return mod(beat()*4.0, 1.0); }\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sqr(float phase) {\n    return float(int(phase * 2.0))*0.5;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat flicker() {\n    return 1.0 - 0.35*noise(beat()*16.);\n}\n\nfloat light_mode_phase() {\n    return bar8_phase();\n}\n\nint light_mode() {\n    int i = int(light_mode_phase() * 4.0);\n    if (i == 0) {\n        return MODE_WALL_LIGHT_FLICKER;\n    } else if (i == 1) {\n        return MODE_WALL_LIGHT_PHASE;\n    } else if (i == 2) {\n        return MODE_WALL_LIGHT_FLICKER;\n    } else if (i == 3) {\n        return MODE_OVERHEAD_LIGHT_PHASE;\n    } else {\n        return MODE_WALL_LIGHT_FLICKER;\n    }\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t*ab;\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat tunnel_dist(vec3 p) {\n    float wall_x = WALL_X;\n    vec3 box_pos = vec3(wall_x, 3.0, 15.0);\n    vec3 box_dim = vec3(1.0, 1000.0, 1000.0);\n    float right_dist = dBox(p-box_pos, box_dim);\n    box_pos.x = -wall_x;\n    float left_dist = dBox(p-box_pos, box_dim);\n    return min(right_dist, left_dist);\n}\n\nfloat seat_dist(vec3 p) {\n    vec3 box_dim = vec3(1.0, 1.0, 2.0);\n    vec3 box_pos = vec3(WALL_X-box_dim.x, 0.0, 10.0);\n    return dBox(p-box_pos, box_dim);\n}\n\nfloat wall_barrel_dist(vec3 p, float bz) {\n    vec3 a = vec3(-WALL_X+2.0, 0.0, bz);\n    vec3 b = vec3(a.x, a.y+2.0, a.z);\n    float r = 0.5;\n    return sdCylinder(p, a, b, r);\n}\n\nfloat bin_dist(vec3 p) {\n    vec3 a = vec3(WALL_X-1., 0.0, 14.0);\n    vec3 b = vec3(a.x, a.y+1.0, a.z);\n    float r = 0.65;\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sphere_dist(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat metablob_dist(vec3 p) {\n    float spread = 1.3;\n    float y = 3.0;\n    float z = 8.0;\n    float smth = 3.0;\n    float br = bar();\n    float s1 = sphere_dist(p-vec3(cos(br*0.8)*spread, y + sin(br*1.0)*spread, z + cos(br*1.3)*spread), 0.2);\n    float s2 = sphere_dist(p-vec3(sin(br*1.3)*spread, y + cos(br*1.1)*spread, z + sin(br*1.4)*spread), 0.25);\n    float s3 = sphere_dist(p-vec3(sin(br*0.9)*spread, y + sin(br*0.8)*spread, z + sin(br*1.7)*spread), 0.3);\n    float d = s1;\n    d = smin(d, s2, smth);\n    d = smin(d, s3, smth);\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    float plane_d = p.y;\n    float tunnel_d = tunnel_dist(p);\n    float seat_d = seat_dist(p);\n    float barrel1_z = 10.0;\n    float barrel_sep = 1.5;\n    float barrel1_d = wall_barrel_dist(p, barrel1_z);\n    float barrel2_d = wall_barrel_dist(p, barrel1_z+barrel_sep);\n    float barrel3_d = wall_barrel_dist(p, barrel1_z+barrel_sep*2.);\n    float barrel4_d = wall_barrel_dist(p, barrel1_z+barrel_sep*16.);\n    float barrel5_d = wall_barrel_dist(p, barrel1_z+barrel_sep*17.);\n    float barrel6_d = wall_barrel_dist(p, barrel1_z+barrel_sep*18.);\n\tfloat bin_d = bin_dist(p);\n\tfloat metablob_d = metablob_dist(p);\n\n    float d = plane_d;\n    d = min(d, tunnel_d);\n    d = min(d, seat_d);\n    d = min(d, barrel1_d);\n    d = min(d, barrel2_d);\n    d = min(d, barrel3_d);\n    d = min(d, barrel4_d);\n    d = min(d, barrel5_d);\n    d = min(d, barrel6_d);\n    d = min(d, bin_d);\n    d = min(d, metablob_d);\n\n\n    return d;\n}\n\nfloat shadow_march(vec3 ro, vec3 rd, float min_light, float light_dist, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float maxt = min(MAX_DIST, light_dist);\n    for (float t=min_light; t < maxt;) {\n        vec3 p = ro + rd*t;\n        float h = GetDist(p);\n        if (h<SURF_DIST) {\n            return 0.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 wall_light_pos() {\n    return vec3(WALL_X-2.5, 5, 8);\n}\n\nvec3 lighta_pos() {\n    return vec3(0.0, 20, beat_phase()*MAX_DIST*2.0);\n}\n\nfloat GetLight(vec3 p, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lp-p)) dif *= .1;\n    float min_light = 0.2;\n    float light_dist = 1.0;\n    float k = 0.5;\n    float s = shadow_march(p+n*SURF_DIST*2., l, min_light, light_dist, k);\n\n    \n    return dif*s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float light = 1.0;\n\n    \n    if (light_mode() == MODE_WALL_LIGHT_FLICKER) {\n    \tlight = pow(GetLight(p, wall_light_pos()), 2.0) * flicker() * WALL_LIGHT_AMP;\n    } else if (light_mode() == MODE_WALL_LIGHT_PHASE) {\n        light = pow(GetLight(p, wall_light_pos()), 2.0) * (1.0 - quaver_phase()) * WALL_LIGHT_AMP;\n    } else if (light_mode() == MODE_OVERHEAD_LIGHT_PHASE) {\n        light = pow(GetLight(p, lighta_pos()), 1.0) * LIGHTA_AMP;\n    }\n    \n    float fade_dist = 1.0 - pow(d / MAX_DIST, 2.);\n    float dif = light * fade_dist;\n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}