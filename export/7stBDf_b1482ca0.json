{"ver":"0.1","info":{"id":"7stBDf","date":"1657388250","viewed":151,"name":"Translucent Ray Marching","username":"mattdeeds","description":"I'm using ray marching to find the surface and thickness of the object described by the SDF.  There are a lot of undesirable artifacts.  Any suggestions?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 1.0\n#define kOutsideSteps 64\n#define kInsideSteps 16\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\n\nmat3 rotation3dZ(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, s, 0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nfloat sdfSphere(in vec3 pos, in vec3 center) {\n  vec3 relPos = (pos - center);\n  mat3 tx = rotation3dY(iTime * 0.2);\n  relPos = tx * relPos;\n  float displacement = dot(vec3(1.0), sin(5.0 * relPos)) * 0.2; \n  return length(relPos) - 2.0 + displacement * (1.0 + cos(iTime * 0.4));\n}\n\n\nfloat sdf(in vec3 pos) {\n  const vec3 sp1 = vec3(0.0, 0.0, -4.0);\n  vec3 sp2 = vec3(2.0 * sin(iTime), 0.0, -5.0);\n  return min(sdfSphere(pos, sp1), sdfSphere(pos, sp2));\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 calculate_normal(in vec3 pos)\n{\n    const vec2 del = vec2(0.05, 0.0);\n\n    float gradient_x = sdf(pos + del.xyy) - sdf(pos - del.xyy);\n    float gradient_y = sdf(pos + del.yxy) - sdf(pos - del.yxy);\n    float gradient_z = sdf(pos + del.yyx) - sdf(pos - del.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n\n    vec2 mouseUV = 8.0 * (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.yy;\n    if (length(iMouse) == 0.0) {\n      mouseUV = vec2(0.0);\n    }\n\n    mat3 tx = rotation3dY(mouseUV.x) * rotation3dX(-mouseUV.y);\n\n    vec3 view = normalize(vec3(uv.x, uv.y, -kDistanceToScreen));\n    view = normalize(tx * view);\n\n    vec3 ray_origin = vec3(0.0, 0.0, 0.0); \n    float travel = 0.0;\n    float travel_outside = 0.0;\n    float travel_inside = 0.0;\n    vec3 col = vec3(1.0, 0.5, 0.1);\n    \n    float previous_distance = sdf(ray_origin);\n    for (int i = 0; i < kOutsideSteps; ++i) {\n      vec3 ray_pos = ray_origin + travel * view;\n      float distance = sdf(ray_pos);\n      if (length(ray_pos) > 5.0) {\n        break;\n      }\n      float step_size = max(abs(distance), 0.05);\n      if (distance > 0.0 && previous_distance > 0.0) {\n        travel_outside += step_size;\n      } else if (distance < 0.0 && previous_distance < 0.0) {\n        travel_inside += step_size;\n      } else if (distance < 0.0 && previous_distance > 0.0) {\n        float p = previous_distance / (previous_distance - distance);\n        travel_outside += p * step_size;\n        travel_inside += (1.0 - p) * step_size;\n      } else if (distance > 0.0 && previous_distance < 0.0) {\n        float p = distance / (distance - previous_distance);\n        travel_outside += p * step_size;\n        travel_inside += (1.0 - p) * step_size;\n      }\n      travel += step_size;\n      previous_distance = distance;\n    }\n    \n    vec3 normal = calculate_normal(ray_origin + travel * view);\n    float thickness = 0.2 * travel_inside;\n\n\n    fragColor = 2.0 * vec4(col,1.0) * thickness;\n}","name":"Image","description":"","type":"image"}]}