{"ver":"0.1","info":{"id":"MtBcWd","date":"1510877955","viewed":164,"name":"RayTracing_test","username":"annistone","description":"My first ray tracing","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DIST = 100.0;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n  float refrKoef;\n  vec3 color;   \n};\n    \nstruct Sphere\n{\n  float radius;\n  vec3 center;\n  Material material;   \n};\n    \nstruct Light\n{\n  float intensity;\n  vec3 direction;\n};\n    \nstruct Intersect {\n    float dist;\n    vec3 normal;\n    Material material; \n};\n\nstruct Plane\n{\n    vec3 normal;\n    float y;\n    Material material;\n};\n\nIntersect miss = Intersect(MAX_DIST, vec3(0.), Material(0.,vec3(1.)));\n\n\nIntersect intersect(Ray ray, Plane plane){\n    \n    if(ray.direction.y < 0.){\n        Intersect intersect;\n        float t = abs(plane.y/ray.direction.y);\n        vec3 OP = t*ray.direction;\n        intersect.dist = length(OP);\n        intersect.normal = plane.normal;\n        intersect.material = plane.material;\n        \n        intersect.material.color = vec3(0.,1.,1.);\n    \tfloat cellSize = 5.;\n        vec3 OP_proj = OP - vec3(.0, -plane.y, 0.);\n        bool is_z_eval = mod(floor(OP_proj.z/cellSize),2.) == .0;\n        bool is_x_eval = mod(floor(OP_proj.x/cellSize),2.) == .0;\n        if((is_z_eval && is_x_eval) || (!is_z_eval && !is_x_eval)){\n        \tintersect.material.color = vec3(1.,0.,1.);\n        }\n        return intersect;\n    }\n\treturn miss;\n}\n    \nIntersect intersect(Ray ray, Sphere sphere){\n\t\n    vec3 oc = sphere.center - ray.origin;\n    \n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    \n    if (det < 0.0) \n        return miss;\n\n    float len = l - sqrt(det);\n    if (len < 0.0) \n        len = l + sqrt(det);\n    if (len < 0.0) \n        return miss;\n    return Intersect(len, normalize(ray.origin + len*ray.direction - sphere.center), sphere.material);\n} \n\nIntersect trace(Ray ray, Plane plane, Sphere spheres[3]){\n\t\n    Intersect hit = intersect(ray, plane);\n    \n    for(int i = 0; i < spheres.length(); i++)\n  \t{\t\n        Intersect sphereIntersect = intersect(ray,spheres[i]);\n\t\t\n        if ( sphereIntersect.dist < hit.dist){\n            hit = sphereIntersect;\n       \t\t\n        }\n    }\n    return hit;\n}\n\nfloat fresnel(vec3 rayDir, vec3 normal, float refrKoef)\n{\n    float cosi = clamp(-1., 1.,dot(rayDir, normal));\n    float etai = 1., etat = refrKoef;\n    if (cosi > 0.) { etai = etat; etat = 1.; }\n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0., 1. - cosi * cosi));\n    // Total internal reflection\n    if (sint >= 1.) {\n    \treturn 1.;\n    }\n    else {\n        float cost = sqrt(max(0., 1. - sint * sint));\n        cosi = abs(cosi);\n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n        return (Rs * Rs + Rp * Rp) / 2.;\n    }\n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\nvec3 my_refract(Ray ray, vec3 normal, float ior)\n{\n    float cosi = clamp(-1., 1.,dot(ray.direction, normal));\n    float etai = 1., etat = ior;\n    if (cosi < 0.) { cosi = -cosi; } \n    else { etai = etat; etat = 1.; normal = -normal; }\n    float eta = etai / etat;\n    float k = 1. - eta * eta * (1. - cosi * cosi);\n    if(k < 0.)\n        return vec3(0.); \n    else \n        return eta * ray.direction + (eta * cosi - sqrt(k)) * normal;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float rRadius = 17.;\n    float rk = 0.4;\n    vec3 ro = vec3( (1.+ rRadius)*sin(rk*iTime), 0., (1.+rRadius)*cos(rk*iTime));\n    vec3 rd = normalize( vec3(uv.x*cos(rk*iTime) + rRadius*sin(rk*iTime), uv.y, -uv.x*sin(rk*iTime) + rRadius*cos(rk*iTime)) - ro);\n    \n    Ray ray = Ray(ro,rd);\n    Light sun = Light(1., normalize(vec3(2., -2., 2.)));\n    Plane plane = Plane(vec3(0.,1.,0.),-5., Material(0.6, vec3(0.)));\n   \tSphere sphere1 = Sphere(2., vec3(-7.,-2. - cos(iTime),0.), Material(20.7,vec3(1.,0.,0.)));\n    Sphere sphere2 = Sphere(3., vec3(1.,-1.+ cos(iTime),0.), Material(22.4,vec3(0.,1.,0.)));\n    Sphere sphere3 = Sphere(2., vec3(8.,-2.- cos(iTime),0.), Material(25.9,vec3(0.,0.,1.)));\n    Sphere spheres[3] = Sphere[3](sphere1, sphere2, sphere3);\n    \n   \t\n    Intersect hit = trace(ray, plane, spheres);\n    vec3 color = vec3(0.05);\n    if(hit != miss)\n    \tcolor = hit.material.color * dot(hit.normal,-sun.direction)*(1.-pow(hit.dist/MAX_DIST,2.));\n    vec3 hitPoint = hit.dist*0.9999 *ray.direction + ray.origin;   \n    \n    float kr = fresnel(ray.direction, hit.normal, hit.material.refrKoef);\n    \n    //reflections\n   \tint numOfIters = 1;\n    vec3 reflectionColor = vec3(0.);\n    \n    vec3 reflectedDir = 2.*length(dot(- ray.direction, hit.normal))*hit.normal + ray.direction;\n    Ray reflectedRay = Ray(hitPoint, reflectedDir);\n    vec3 reflectedHitPoint = hitPoint;\n    \n    for(int i = 0; i < numOfIters; i++){\n        Intersect reflectedHit = trace(reflectedRay, plane, spheres);  \t\n        \n        if (reflectedHit != miss)\n        reflectionColor = 0.8 * reflectedHit.material.color* dot(reflectedHit.normal, -sun.direction)*(1.-pow(reflectedHit.dist/MAX_DIST,2.));\n    \t\n        reflectedHitPoint = reflectedHit.dist*0.9999 *reflectedRay.direction + ray.origin; \n        reflectedDir = 2.*length(dot(- reflectedRay.direction, reflectedHit.normal))*reflectedHit.normal + reflectedRay.direction;\n   \t\treflectedRay = Ray(reflectedHitPoint, reflectedDir);\n    }\n  \t\n    \n    //refraction\n    \n    vec3 refractionColor = vec3(0.);\n    if (kr < 1.){\n        numOfIters = 2;\n\n        Intersect refrHit = hit;\n        Ray refrRay = ray;\n        vec3 refrDir;\n        vec3 refrPoint;\n\n        for(int i = 0; i < numOfIters; i++){\n\n            float biasDir;\n            if(mod(float(i),2.) == 0.)\n                biasDir = -1.;\n            else\n                biasDir = 1.;\n\n            refrPoint = refrHit.dist*refrRay.direction + refrRay.origin + 0.01*biasDir*refrHit.normal; \n            refrDir = my_refract(refrRay, refrHit.normal, refrHit.material.refrKoef);\n\n            Ray rayToRefract = Ray(refrPoint, refrDir); \n\n            refrHit = trace(rayToRefract, plane, spheres);  \t\n            if (refrHit == miss)\n                break;\n            refrRay = Ray(refrPoint,rayToRefract.direction);\n        }\n\n       if (refrHit != miss)\n            refractionColor += 0.8 * refrHit.material.color* dot(refrHit.normal, -sun.direction);\n    }\n    //fresnel\n    \n   \tcolor += 0.8*(reflectionColor * kr + refractionColor * (1. - kr)); \n    \n    // color += 0.8*reflectionColor; \n    //shadows   \n    Ray rayToSun = Ray(hitPoint,-sun.direction);\n    \n    Intersect hitToSun = trace(rayToSun, plane, spheres);\n    \n    if (hitToSun.dist < MAX_DIST)\n    \tcolor *= 0.25;\n    \n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}