{"ver":"0.1","info":{"id":"lcdXz4","date":"1713686175","viewed":165,"name":"Testing Tone Mapping Operators","username":"bizzarrus","description":"Comparison of various different tone mapping operators.\nOn the left is the base color, next to it is a color scale that first ramps from 0 to 1 brightness (first half) and then up to 40 brightness (second half).\n\nUse the mouse to control the color.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["tonemapping","reinhard","tonemap","aces"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float HSV_RGB_Helper(float n, float h, float s, float v)\n{\n    float k = mod(n + (h * 6.0), 6.0);\n    return v - (v * s * clamp(min(k, 4.0 - k), 0.0, 1.0));\n}\n\nvec3 HSV_To_RGB(vec3 hsv)\n{\n    vec3 t = clamp(hsv, 0.0, 1.0);\n    return vec3(HSV_RGB_Helper(5.0, t.x, t.y, t.z), HSV_RGB_Helper(3.0, t.x, t.y, t.z), HSV_RGB_Helper(1.0, t.x, t.y, t.z));\n}\n\nvec3 OETF_REC709(vec3 linearColor)\n{\n    float a = 0.0031308;\n\tfloat b = 0.055;\n\tfloat c = 12.92;\n\tfloat m = 1.0 / 2.4;\n\t\n\tvec3 color = clamp(linearColor, 0.0, 1.0);\n\tcolor.x = color.x > a ? ((1.0 + b) * pow(color.x, m) - b) : (c * color.x);\n\tcolor.y = color.y > a ? ((1.0 + b) * pow(color.y, m) - b) : (c * color.y);\n\tcolor.z = color.z > a ? ((1.0 + b) * pow(color.z, m) - b) : (c * color.z);\n\t\n\treturn color;\n}\n\nfloat GetExposure(float x, float minE, float midE, float maxE)\n{\n    if(x < 0.5)\n        return minE + (2.0 * x * (midE - minE));\n\n    float b = 4.0 * (midE + 1.5 * (midE - minE) - maxE);\n    float c = maxE - 2.0 * (midE - minE);\n    float a = 2.0 * (midE - minE) - b;\n    \n    return c + (x * (b + (x * a)));\n}\n\nvec3 GetBaseColor(vec2 edge)\n{\n    vec3 hsv = vec3(fract(iTime / 10.0), 0.9, 1.0);\n    if(iMouse.z > 0.0)\n        hsv = clamp(vec3(((iMouse.xy / iResolution.xy) - edge) / (1.0 - (2.0 * edge)), 1.0), 0.0, 1.0);\n\n    return HSV_To_RGB(hsv);\n}\n\nmakeStr(Label_Saturate) _S _a _t _u _r _a _t _e _end\nvec3 ToneMap_Saturate(vec3 linCol)\n{\n    return clamp(linCol, 0.0, 1.0);\n}\n\nmakeStr(Label_Reinhard1) _R _e _i _n _h _a _r _d __ _1 _end\nvec3 ToneMap_Reinhard1(vec3 linCol)\n{\n    return linCol / (1.0 + linCol);\n}\n\nmakeStr(Label_Reinhard2) _R _e _i _n _h _a _r _d __ _2 _end\nvec3 ToneMap_Reinhard2(vec3 linCol)\n{\n    float white = 0.8;\n    vec3 a = linCol * (1.0 + (linCol / (white * white)));\n    vec3 b = 1.0 + linCol;\n    return a / b;\n}\n\nmakeStr(Label_ReinhardLuma) _R _e _i _n _h _a _r _d __ _L _u _m _a _end\nvec3 ToneMap_ReinhardLuma(vec3 linCol)\n{\n    float luma = dot(linCol, vec3(0.2126, 0.7152, 0.0722));\n    return linCol * (luma / (1.0 + luma));\n}\n\nmakeStr(Label_ACES_Simple) _A _C _E _S __ _S _i _m _p _l _e _end\nvec3 ToneMap_ACES_Simple(vec3 linCol)\n{\n    vec3 x = linCol;\n\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    \n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nmakeStr(Label_ACES) _A _C _E _S _end\nvec3 ToneMap_ACES(vec3 linCol)\n{\n    // This code is based on an implementation by Stephen Hill (@self_shadow),\n    // who deserves all credit for coming up with this fit. \n\n    mat3 ACESInputMat = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    \n    mat3 ACESOutputMat = mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    \n    // ACES has some weird artefacts around blue colors\n    // This matrix was proposed by Scott Dyer as a fix\n    mat3 ACESFixMat = mat3(\n        0.9404372683, -0.0183068787, 0.0778696104,\n        0.0083786969, 0.8286599939, 0.1629613092,\n        0.0005471261, -0.0008833746, 1.0003362486\n    );\n    \n    vec3 x = linCol * ACESFixMat;\n    vec3 v = x * ACESInputMat;\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    vec3 c = (a / b) * ACESOutputMat;\n    return c;\n}\n\nmakeStr(Label_Uncharted) _U _n _c _h _a _r _t _e _d _end\nvec3 ToneMap_Uncharted(vec3 linCol)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n    \n    vec3 R = linCol * 2.0;\n    vec3 cA =  ((R*(A*R+C*B)+D*E)/(R*(A*R+B)+D*F))-E/F;\n    float cB = ((W*(A*W+C*B)+D*E)/(W*(A*W+B)+D*F))-E/F;\n    return cA / cB;\n}\n\nmakeStr(Label_AgX0) _A _g _X __ _D _e _f _a _u _l _t _end\nmakeStr(Label_AgX1) _A _g _X __ _G _o _l _d _e _n _end\nmakeStr(Label_AgX2) _A _g _X __ _P _u _n _c _h _y _end\nvec3 ToneMap_AgX(vec3 linCol, int lookMode)\n{\n    // Minimal AgX, see by https://iolite-engine.com/blog_posts/minimal_agx_implementation\n\n    mat3 agx_mat = mat3(\n        0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n        0.0784335999999992,  0.878468636469772,  0.0784336,\n        0.0792237451477643, 0.0791661274605434, 0.879142973793104\n    );\n    \n    mat3 agx_mat_inv = mat3(\n        1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n        -0.0990297440797205, -0.0989611768448433, 1.15107367264116\n    );\n    \n    float min_ev = -12.47393;\n    float max_ev = 4.026069;\n    float bias = 1.0;\n    \n    // Input transform\n    vec3 val = agx_mat * (linCol * bias);\n  \n    // Log2 space encoding\n    val = clamp(log2(val), min_ev, max_ev);\n    val = (val - min_ev) / (max_ev - min_ev);\n    \n    // Apply sigmoid function approximation\n    val = ((((((((((15.5 * val) - 40.14) * val) + 31.96) * val) - 6.868) * val) + 0.4298) * val) + 0.1191) * val - 0.00232;\n    \n    // Apply Look Transform\n    float luma = dot(val, vec3(0.2126, 0.7152, 0.0722));\n    vec3 offset = vec3(0.0);\n    vec3 slope = vec3(1.0);\n    vec3 power = vec3(1.0);\n    float sat = 1.0;\n    \n    if(lookMode == 1) // \"Golden\"\n    {\n        slope = vec3(1.0, 0.9, 0.5);\n        power = vec3(0.8);\n        sat = 0.8;\n    }\n    else if(lookMode == 2) // \"Punchy\"\n    {\n        slope = vec3(1.0);\n        power = vec3(1.35);\n        sat = 1.4;\n    }\n    \n    val = pow(val * slope + offset, power);\n    val = luma + sat * (val - luma);\n    \n    // Inverse Input transform\n    return agx_mat_inv * val;\n}\n\nmakeStr(Label_Lottes) _L _o _t _t _e _s _end\nvec3 ToneMap_Lottes(vec3 linCol)\n{\n    // Timothy Lottes Generic Filmic with fixes from Bart Wronski\n    \n    float hdr_max = 2.0;\n    float contrast = 1.2;\n    float shoulder = 0.97;\n    float mid_in = 0.3;\n    float mid_out = 0.18;\n    \n    float a = contrast;\n    float d = shoulder;\n    float ad = a * d;\n    \n    float midi_pow_a = pow(mid_in, a);\n    float midi_pow_ad = pow(mid_in, ad);\n    float hdrm_pow_a = pow(hdr_max, a);\n    float hdrm_pow_ad = pow(hdr_max, ad);\n    float u = hdrm_pow_ad * mid_out - midi_pow_ad * mid_out;\n    float v = midi_pow_ad * mid_out;\n    \n    float b = -((-midi_pow_a + (mid_out * (hdrm_pow_ad * midi_pow_a - hdrm_pow_a * v)) / u) / v);\n    float c = (hdrm_pow_ad * midi_pow_a - hdrm_pow_a * v) / u;\n       \n    vec3 x = min(linCol, hdr_max);\n    vec3 z = pow(x, vec3(a));\n    vec3 y = z / (pow(z, vec3(d)) * b + c);\n    \n    return y;\n}\n\nmakeStr(Label_Uchimura) _U _c _h _i _m _u _r _a _end\nvec3 ToneMap_Uchimura(vec3 linCol)\n{\n    // GT Tonemap\n    // Copyright(c) 2017 by Hajime Uchimura @ Polyphony Digital Inc.\n    \n    float P_in = 1.0; // Maximum brightness, 1 .. 100\n    float a_in = 1.0; // Contrast 1 .. 5\n    float m_in = 0.4; // Linear section start 0 .. 1\n    float l_in = 0.24; // Linear section length 0 .. 1\n    float c_in = 1.33; // Black tightness 1 .. 3, 0 .. 1\n    float b_in = 0.0;\n    \n    vec3 P = vec3(P_in);\n    vec3 a = vec3(a_in);\n    vec3 m = vec3(m_in);\n    vec3 l = vec3(l_in);\n    vec3 c = vec3(c_in);\n    vec3 b = vec3(b_in);\n    \n    // Linear Region Computation\n    // l0 is the linear length after scale\n    vec3 l0 = ((P - m) / l) / a;\n    vec3 L0 = m - (m / a);\n    vec3 L1 = m + (l - m) / a;\n    vec3 Lx = m + a * (linCol - m);\n    \n    // Toe\n    vec3 Tx = m * pow(linCol / m, c) + b;\n    \n    // Shoulder\n    vec3 S0 = m + l0;\n    vec3 S1 = m + a * l0;\n    vec3 C2 = (a * P) / (P - S1);\n    vec3 Sx = P - (P - S1) * exp(-(C2 * (linCol - S0) / P));\n    \n    // Toe weight\n    vec3 wm = clamp(linCol / m, 0.0, 1.0);\n    vec3 w0 = 1.0 - ((wm * wm * 3.0) - (2.0 * wm));\n    \n    // Shoulder weight\n    vec3 w2 = smoothstep(m + l0, m + l0, linCol);\n    \n    // Linear weight\n    vec3 w1 = vec3(1.0) - (w0 + w2);\n    \n    return Tx * w0 + Lx * w1 + Sx * w2;\n}\n\nmakeStr(Label_Drago) _D _r _a _g _o _end\nvec3 ToneMap_Drago(vec3 linCol)\n{\n    // https://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n    float Ls_max = 1.0;\n    float Ld_max = 1.0;\n    float exposure = 1.0;\n    float adaption = 1.0;\n    float bias = 0.6;\n    \n    float L0 = dot(linCol, vec3(0.2126, 0.7152, 0.0722));\n    \n    float Lwa = adaption / pow(1.0 + bias - 0.85, 5.0);\n    float Lw = L0 * exposure / Lwa;\n    float Lw_max = Ls_max * exposure / Lwa;\n    \n    float a = Ld_max * log(10.0) / log(Lw_max + 1.0);\n    float b = log(Lw + 1.0);\n    float c = 1.0 / log(2.0 + 8.0 * pow(Lw / Lw_max, log(b) / log(0.5)));\n    \n    float Ld = a * b * c;\n    \n    return linCol * Ld / L0;\n}\n\nmakeStr(Label_RomBinDaHouse) _R _o _m _B _i _n _D _a _H _o _u _s _e _end\nvec3 ToneMap_RomBinDaHouse(vec3 linCol)\n{\n    return exp(-1.0 / (2.72 * linCol + 0.15));\n}\n\nmakeStr(Label_Ottosson) _O _t _t _o _s _s _o _n _end\nvec2 ToneMap_Ottosson_MP(vec3 x)\n{\n    mat3 MPT = mat3(\n         2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107\n    );\n    \n    x = x * MPT;\n    float x_min = min(x.r, min(x.g, x.b));\n    float x_max = max(x.r, max(x.g, x.b));\n    \n    float c = 0.5 * (x_max + x_min);\n    float s = x_max - x_min;\n    \n    vec3 y = (x - c) / max(1e-7, s);\n    float c_smooth = c + dot(y * y * y, vec3(1.0 / 3.0)) * s;\n    float s_smooth = sqrt(dot(x - c_smooth, x - c_smooth) / 2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\nvec3 ToneMap_Ottosson(vec3 linCol)\n{\n    // From https://www.shadertoy.com/view/fsXcz4\n    // Copyright(c) 2022 BjÃ¶rn Ottosson\n    \n    float chroma_scale = 1.2; // overall scale of chroma\n    float offset = 0.25; // controls how colors desaturate as they brighten. 0 results in that colors never fluoresce, 1 in very saturated colors \n    \n    // Parameters from ACES Simple curve\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    \n    mat3 LMSInput = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005\n    );\n    \n    mat3 LMSOutput = mat3(\n         4.0767416621, -3.3077115913,  0.2309699292,\n        -1.2684380046,  2.6097574011, -0.3413193965,\n        -0.0041960863, -0.7034186147,  1.7076147010\n    );\n    \n    vec3 lms = linCol * LMSInput;\n    lms = sign(lms) * pow(abs(lms), vec3(1.0 / 3.0));\n    vec2 mp = ToneMap_Ottosson_MP(lms);\n    \n    float I = mp.x + (1.0 - offset) * mp.y;\n    lms = lms * I * I;\n    I = I * I * I;\n    vec3 dLms = lms - I;\n    \n    float Ip = max(I, 0.0);\n    float Ir = (Ip * (c * Ip + d) + e);\n    float Icurve = clamp((Ip * (a * Ip + b)) / (Ip * (c * Ip + d) + e), 0.0, 1.0);\n    float Dcurve = (a * Ip * (d * Ip + 2.0 * e) + b * (e - c * Ip * Ip)) / (Ir * Ir);\n    lms = 1.0 + chroma_scale * dLms * Dcurve / Icurve;\n    I = pow(Icurve, 1.0 / 3.0);\n    \n    lms = lms * I;\n    \n    // Precomputed ST gamut shape\n    vec2 ST = vec2(0.46801, 0.06212);\n    float m = ToneMap_Ottosson_MP(lms).x;\n    float c_smooth_gamut = 1.0 / ((ST.x / m) + (ST.y / (1.0 - m)));\n\n    // Precomputed UV matrix\n    mat3 ToUV = mat3(\n        1.0683026, -0.7993305,  0.7310280,\n        6.0502715, -7.5786538,  1.5283825,\n        0.6739459,  1.3066778, -1.9806237\n    );\n    \n    vec3 uv = lms * ToUV;\n    \n    float c_lms = sqrt(uv.y * uv.y + uv.z * uv.z);\n    lms = (lms - m) / sqrt(c_lms * c_lms / c_smooth_gamut / c_smooth_gamut + 1.0) + m;\n    return lms * lms * lms * LMSOutput;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cutOff = 0.07;\n    float n = 14.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 baseCol = GetBaseColor(vec2(cutOff, 1.0 / n));\n    vec3 res = vec3(0.0);\n    float text = 0.0;\n    float font_size = 2.5;\n    float font_x_scale = 3.0 / 4.0 * iResolution.x / iResolution.y;\n    vec2 text_uv = ((uv - vec2(cutOff, 0.005)) * n * font_size * vec2(font_x_scale, 1.0)) - vec2(0.0, (n - 1.0) * font_size);\n    vec3 text_col = vec3(1.0, 1.0, 1.0);\n    \n    if(uv.x > cutOff)\n    {\n        float exposure = GetExposure((uv.x - cutOff) / (1.0 - cutOff), 0.0, 1.0, 40.0);\n        vec3 linCol = baseCol * exposure;\n\n        int row = int((1.0 - uv.y) * n);\n        text_uv += vec2(0.0, float(row) * font_size);\n        \n             if(row ==  0) { res = ToneMap_Saturate(linCol);      text = Label_Saturate(text_uv); }\n        else if(row ==  1) { res = ToneMap_Reinhard1(linCol);     text = Label_Reinhard1(text_uv); }\n        else if(row ==  2) { res = ToneMap_Reinhard2(linCol);     text = Label_Reinhard2(text_uv); }\n        else if(row ==  3) { res = ToneMap_ReinhardLuma(linCol);  text = Label_ReinhardLuma(text_uv); }\n        else if(row ==  4) { res = ToneMap_ACES_Simple(linCol);   text = Label_ACES_Simple(text_uv); }\n        else if(row ==  5) { res = ToneMap_ACES(linCol);          text = Label_ACES(text_uv); }\n        else if(row ==  6) { res = ToneMap_Uncharted(linCol);     text = Label_Uncharted(text_uv); }\n        else if(row ==  7) { res = ToneMap_AgX(linCol, 0);        text = Label_AgX0(text_uv); }\n    //  else if(row ==  8) { res = ToneMap_AgX(linCol, 1);        text = Label_AgX1(text_uv); } \n        else if(row ==  8) { res = ToneMap_AgX(linCol, 2);        text = Label_AgX2(text_uv); }\n        else if(row ==  9) { res = ToneMap_Lottes(linCol);        text = Label_Lottes(text_uv); }\n        else if(row == 10) { res = ToneMap_Uchimura(linCol);      text = Label_Uchimura(text_uv); }\n        else if(row == 11) { res = ToneMap_Drago(linCol);         text = Label_Drago(text_uv); }\n        else if(row == 12) { res = ToneMap_RomBinDaHouse(linCol); text = Label_RomBinDaHouse(text_uv); }\n        else if(row == 13) { res = ToneMap_Ottosson(linCol);      text = Label_Ottosson(text_uv); }\n\n        if (abs(fract(n * uv.y + 0.5) - 0.5) < 0.02)\n            res = vec3(0.0);\n    }\n    else\n    {\n        if(uv.x < cutOff - 0.001)\n            res = baseCol;\n    }\n    \n    res = OETF_REC709(mix(res, text_col, text));\n    fragColor = vec4(res, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*   ### How to use this shader ? ###\n   \n   = Setup =\n   0. Copy the content of the Common Tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n   \n   = Declare String =\n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printAnother) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n   \n   = Print String =\n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printAnother(uv);\n   \n   Note that by default a character has a height of 1 (which is full height if \n   the coordinates are normalized). You are responsible for scaling/offsetting \n   the uvs to control the text placement before calling the function.\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _EXC _QUOT ... (see Common)\n   \n   \n   ### Javascript string generator helper ###\n   \n   To make things even easier, I've made a tiny javascript helper function that you\n   can use to convert strings to the right _F _o _r _m _a _t !\n   (I've written it in the comments of this shader)\n   \n   \n   ### Special functions ###\n   \n   _dig(i)       : write a specific digit [i ranges between 0-9]\n   _dec(i, prec) : write a floating point number [prec: number of decimals to print]\n   _ch(i)        : Write an uppercase character [i ranges between 0-25]\n   \n   To use these special functions, you need to pass additional parameters into makeStr:\n   \n   \"makeStr1i\" allows you to pass 1 int parameter named \"i\" :\n   \n   makeStr1i(test) _dig(i) _end\n   test(uv, 5);\n   \n   \"makeStr1f\" allows you to pass 1 float parameter named \"i\":\n   \n   makeStr1f(test) _dec(i, 3) _end\n   test(uv, 5.);\n   \n   You can also create your own makeStr with any parameter type! (see below)\n   \n   \n   ### Help me optimize it! ###\n   \n   The _dec() function is only for debug purposes, I've never used it in a published shader.\n   It's *very* intensive and can have rounding issues (ie 21.999 when the float is 22.), \n   however it's done with a pretty naive approach so if you can come up with a better one\n   I'd be glad! The function is defined at the very end of this tab.\n*/\n\n/// SETTINGS ///\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel0\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n\n/// SPECIAL FUNCTIONS ///\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n\n/// SPECIAL CHARACTERS ///\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n\n/// CHARACTER DEFINITIONS ///\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p, -1.0).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}","name":"Common","description":"","type":"common"}]}