{"ver":"0.1","info":{"id":"cdcBz7","date":"1696965810","viewed":41,"name":"10. Fortune","username":"Ladus","description":"Inktober 2023 Day 10. A wheel of fortune","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["inktober","fortune"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define AmountOfOptions 16.\n#define ClickerScale 16.\n\n//  Function from Iñigo Quiles - https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// Function from Iñigo Quiles - https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return distance(vec2(0), p)-r;\n}\n\nvec2 normalizeScreenSpace(vec2 fragCoord, out float aa) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 1.-(iResolution.y/iResolution.x);\n    uv = (uv - vec2(0.5))*2.;\n    aa = min(iResolution.x, iResolution.y)*0.000005; // I should probably calculate the anti aliasing res with the iResolution...\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aa = 0.;\n    vec2 p = normalizeScreenSpace(fragCoord, aa);\n\n    float distanceFromCenter = distance(vec2(0,0), p);\n\n    // Create circular masks\n    float circleSdf = sdCircle(p, .75);\n    float fullCircleMask = 1.-smoothstep(0.-aa, 0.+aa, circleSdf);\n    float innerCircleMask = 1.-smoothstep(-0.55-aa, -0.55+aa, circleSdf);\n    \n    // Create whole circular gradient\n    float angle = 1. - max((clamp(0.,1.,atan(p.x,p.y) / PI) / 2.), ((clamp(0.,1.,atan(-p.x,-p.y) / PI) / 2.) + 0.5 ));\n    \n    //// Options\n    // rotate options\n    float rotationSpeed = iTime*0.5 + sin(iTime*0.5);\n    float wheelRotation = angle + rotationSpeed;\n    float optionsMask = floor(wheelRotation * AmountOfOptions)/AmountOfOptions;\n\n    //// Clicker / ticker\n    vec2 clickerSpace = p*ClickerScale + vec2(0.,-13.);\n    float rotation = sin(1.-rotationSpeed*20.);\n    clickerSpace *= mat2(cos(rotation),-sin(rotation),sin(rotation), cos(rotation));\n    vec2 triangleSpace = clickerSpace + vec2(0.,2.);\n    float triangleSdf = sdTriangleIsosceles(triangleSpace, vec2(0.4,2.) );\n    float clickerSdf = sdCircle(clickerSpace, .5);\n    clickerSdf = min(clickerSdf, triangleSdf);\n    float clickerMask = smoothstep(0.1+aa*ClickerScale, 0.1-aa*ClickerScale, clickerSdf);\n    \n    //// Color scene\n    // Add color to inner wheel\n    vec3 optionColors = hsb2rgb(vec3(optionsMask*AmountOfOptions * 1.75,0.6,1.)) * fullCircleMask * (1.-innerCircleMask);\n    // Add color to inner circle\n    vec3 col = mix(optionColors, hsb2rgb(vec3(0.3,0.4,0.9)), innerCircleMask);\n    // Add color to background\n    col = mix(col, hsb2rgb(vec3(0.3,0.4,0.9)) * clamp(0.,1.,distanceFromCenter*0.5)+0.1, 1.-fullCircleMask);\n    // Add color to clicker\n    col = mix(col, hsb2rgb(vec3(1,0,1)) * smoothstep(0.3,-0.2,clickerSdf), clickerMask);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}