{"ver":"0.1","info":{"id":"43KXRd","date":"1720373935","viewed":75,"name":"bad ascii shader","username":"int_45h","description":"a bad ascii shader I made as an experiment, I was inspired by acerola's video on ASCII rendering (https://www.youtube.com/watch?v=gg40RWiaHRY).\n\nThis shader does NOT feature edge flow or any additional post fx, but it's something i'll do when I fork this","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","ascii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, in vec2 U)\n{\n    vec2 size = vec2(8,8);\n    vec2 ires = iResolution.xy;\n    vec2 uv = U/ires;\n    vec2 uvg = floor(U/size);\n    vec2 uvc = fract(U/size);\n    \n    vec3 c = texture(iChannel1, uvg*size/ires.xy).rgb;\n    float l = luma(c);\n    \n    int idx = clamp(int(floor(l*8.)),0,7);\n    vec2 U2 = (uvc+vec2(idx,0))/vec2(size.x,1);//vec2(idx)/8.;\n    float g = texture(iChannel0, U2).r;\n    vec2 iq = RGB_to_YIQ(floor(c*16.)/16.).gb;\n    //vec3 c_prime = dither(YIQ_to_RGB(vec3(g,iq)), uvg)*g;\n    vec3 c_prime = YIQ_to_RGB(vec3(g,iq))*g;\n    \n    //fragColor = vec4(vec3(c_prime),1);\n    //fragColor = vec4(vec3(g),1);\n    O = vec4(c_prime,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Code Page 437 font definitions, from https://www.zap.org.au/projects/console-fonts-distributed/psftx-freebsd-11.1/cp437-8x8.fnt.huge.pdf\n*/\n\nint _space[8] = int[8](\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n);\n\nint _period[8] = int[8](\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x30,\n    0x30,\n    0x00\n);\n\nint _comma[8] = int[8](\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x30,\n    0x30,\n    0x60\n);\n\nint _colon[8] = int[8](\n    0x00,\n    0x30,\n    0x30,\n    0x00,\n    0x00,\n    0x30,\n    0x30,\n    0x00\n);\n\nint _semicolon[8] = int[8](\n    0x00,\n    0x30,\n    0x30,\n    0x00,\n    0x00,\n    0x30,\n    0x30,\n    0x60\n);\n\nint _C[8] = int[8](\n    0x3C,\n    0x66,\n    0xC0,\n    0xC0,\n    0xC0,\n    0x66,\n    0x3C,\n    0x00\n);\n\nint _E[8] = int[8](\n    0xFE,\n    0x62,\n    0x68,\n    0x78,\n    0x68,\n    0x62,\n    0xFE,\n    0x00\n);\n\nint _pound[8] = int[8](\n    0x6C,\n    0x6C,\n    0xFE,\n    0x6C,\n    0xFE,\n    0x6C,\n    0x6C,\n    0x00\n);\n\n/* Common functions */\nfloat luma(vec3 c){return dot(c, vec3(.299,.587,.114));}\n\nvec3 RGB_to_YIQ(vec3 c)\n{\n    return mat3(\n        .299, .587, .114,\n        .596, -.275, -.321,\n        .212, -.523, .311\n    )*c;\n}\n\nvec3 YIQ_to_RGB(vec3 c)\n{\n    return mat3(\n        1., .956, .619,\n        1., -.272, -.647,\n        1., -1.106, 1.703\n    )*c;\n}\n\nint dither_matrix[64] = int[](\n    0,32,8,40,2,34,10,42,\n    48,16,56,24,50,18,58,26,\n    12,44,4,36,14,46,6,38,\n    60,28,52,20,62,30,54,22,\n    3,35,11,43,1,33,9,41,\n    51,19,59,27,49,17,57,25,\n    15,47,7,39,13,45,5,37,\n    63,31,55,23,61,29,53,21\n);\n\nconst vec3 CGA_palette[16] = vec3[16](\n    vec3(0x00, 0x00, 0x00),\n    vec3(0x55, 0x55, 0x55),\n    vec3(0xAA, 0xAA, 0xAA),\n    vec3(0xFF, 0xFF, 0xFF),\n    vec3(0x00, 0x00, 0xAA),\n    vec3(0x55, 0x55, 0xFF),\n    vec3(0x00, 0xAA, 0x00),\n    vec3(0x55, 0xFF, 0x55),\n    vec3(0x00, 0xAA, 0xAA),\n    vec3(0x55, 0xFF, 0xFF),\n    vec3(0xAA, 0x00, 0x00),\n    vec3(0xFF, 0x55, 0x55),\n    vec3(0xAA, 0x00, 0xAA),\n    vec3(0xFF, 0x55, 0xFF),\n    vec3(0xAA, 0x55, 0x00),\n    vec3(0xFF, 0xFF, 0x55)\n);\n\nvec3 palettize(vec3 c)\n{\n    int index = 0;\n    float dist = 10000.0f;\n    \n    for (int i=0; i<16; i++)\n    {\n        vec3 cga_c = CGA_palette[i] / 255.99f;\n        float d = length(cga_c - c);\n        if (d > dist)\n            continue;\n        \n        dist = d;\n        index = i;\n    }\n    \n    return CGA_palette[index] / 255.99f;\n}\n\nvec3 dither(vec3 col, vec2 U)\n{\n    int x_m = int(U.x) % 8;\n    int y_m = int(U.y) % 8;\n    float M = float(dither_matrix[y_m*8+x_m])/64.;\n    \n    return palettize(col+(M-.5f));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float render_glyph(vec2 U, vec2 size, int[8] glyph)\n{\n    vec2 px = floor(mod(U, size));\n    int row = glyph[int(size.y - px.y)-1];\n    int mask = 1 << int(size.x - px.x);\n    return ((row & mask) == 0) ? 0. : 1.;\n}\n\nfloat render_row(vec2 U, vec2 size)\n{\n    int cols = 8;\n    int idx = int(mod(U.x, float(cols)));\n    switch(idx)\n    {\n        case 0: return render_glyph(U*float(cols), size, _space);\n        case 1: return render_glyph(U*float(cols), size, _period);\n        case 2: return render_glyph(U*float(cols), size, _comma);\n        case 3: return render_glyph(U*float(cols), size, _colon);\n        case 4: return render_glyph(U*float(cols), size, _semicolon);\n        case 5: return render_glyph(U*float(cols), size, _C);\n        case 6: return render_glyph(U*float(cols), size, _E);\n        case 7: return render_glyph(U*float(cols), size, _pound);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(8,8);\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 c = vec3(render_row(uv*vec2(8,1), size));\n    fragColor = vec4(c,1);\n}","name":"Buffer A","description":"","type":"buffer"}]}