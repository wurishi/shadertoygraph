{"ver":"0.1","info":{"id":"l32XRD","date":"1710513542","viewed":68,"name":"project_moon_graves2","username":"BlackBow","description":"projecttp","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tppolytechsacl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// tree settings\n#define TREE_COLOR vec3(0.6, 0.45, 0.3)\n#define BRANCH_LAYERS 6.\n#define BRANCH_ROT 0.75\n#define BRANCH_DEPTH 6.\n\n// forest settings\n#define FOREST_SPACING 9.\n#define FOREST_LAYERS 7.\n#define WIND_STRENGTH 0.1\n#define TREE_OFFSET 0.8\n#define FOREST_SEED 30.\n\n// ground/terrain settings\n#define GROUND_COLOR vec3(0.165,0.173,0.169)\n#define TERRAIN_BRIGHTNESS 4.\n\n#define TERRAIN_HEIGHT 3.\n#define TERRAIN_SEED 10.\n\n// how common gravestones are (more gravestones means less trees)\n#define ITEM_AMOUNT -0.1\n\n// the matrix for the hash function (weights from the origonal Hash function)\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with some modifactions)\nvec3 Hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 Hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n        return length(p-vec2(a,b));\n    }\n\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat Perlin( in vec3 p )\n{\n\tvec3 i = floor( p );\n\tvec3 f = fract( p );\n\n\t// cubic interpolant\n\tvec3 u = f*f*(3.0-2.0*f);\n\n\treturn mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                      \tdot( Hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                 \tmix( dot( Hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                      \tdot( Hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n            \tmix( mix( dot( Hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                      \tdot( Hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                 \tmix( dot( Hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                      \tdot( Hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n// renders grave stones\nfloat GraveStone(vec2 np)\n{\n\t// getting the relative position\n\tfloat bright = 1.;\n    \n\t// drawing the grave stone\n\tif (abs(np.x) < 0.1 && abs(np.y) < 0.15 || length(np-vec2(0., 0.15)) < 0.1) bright = 0.05;\n\telse if (abs(np.x-0.03) < 0.1 && abs(np.y-max(np.x - 0.1, 0.)) < 0.15 || length(np-vec2(0.031, 0.16)) < 0.1) return 0.5;\n\telse return bright;\n    \n\t// drawing the letters\n\tif (abs(np.x+0.06) < 0.004 && abs(np.y-0.1  )<0.03 ) return 0.99;\n\tif (abs(np.x+0.03) < 0.004 && abs(np.y-0.116)<0.015) return 0.99;\n\tif (abs(np.x + 0.045) < 0.015 && abs(np.y - 0.1) < 0.004) return 0.99;\n\tif (abs(np.x + 0.045) < 0.015 && abs(np.y - 0.129) < 0.004) return 0.99;\n\tif (abs(-np.x-(np.y-0.045)) < 0.006 && abs(np.x+0.045) < 0.0155) return 0.99;\n\n\tif (abs(np.x-0.007) < 0.004 && abs(np.y - 0.1  )< 0.03  ) return 0.99;\n\tif (abs(np.x-0.007) < 0.015 && abs(np.y - 0.07 ) < 0.004) return 0.99;\n\tif (abs(np.x-0.007) < 0.015 && abs(np.y - 0.129) < 0.004) return 0.99;\n\n\tif (abs(np.x-0.05) < 0.004 && abs(np.y-0.1  )<0.03 ) return 0.99;\n\tif (abs(np.x-0.08) < 0.004 && abs(np.y-0.116)<0.015) return 0.99;\n\tif (abs(np.x - 0.065) < 0.015 && abs(np.y - 0.1) < 0.004) return 0.99;\n\tif (abs(np.x - 0.065) < 0.015 && abs(np.y - 0.129) < 0.004) return 0.99;\n    \n\t// returning the final brightness\n\treturn bright;\n}\n\n\n// renders a bunch of layers of trees\nvoid RenderForest(inout vec3 col, vec2 uv, float pixelWidth, vec2 offset, float scrollX)\n{\n\t// the depth (use for ground fog)\n\tfloat depth = FOREST_LAYERS;\n\n\t// looping through the layers of the forest\n\tfor (float layer = FOREST_LAYERS; layer > 0.; layer--)\n\t{\n    \t// getting the position\n    \tfloat spacing = FOREST_SPACING / (layer * 0.5);\n    \tvec2 nuv = uv + offset/layer + vec2(scrollX/layer, 0.);\n    \tfloat xOffset = layer*spacing*0.25;\n    \tfloat x = nuv.x + xOffset;\n    \tfloat cell = floor(x / spacing);\n    \tvec3 hash = Hash(vec3(layer, cell+3., FOREST_SEED));\n   \t \n    \t// getting the height of the terrain and more position information\n    \tfloat l = max((FOREST_LAYERS - layer + 1.) * 0.75, 1.85);\n    \tfloat terrainOffset = layer*0.195-1.;\n    \tfloat height = terrainOffset + Perlin(vec3(nuv.x*0.1, TERRAIN_SEED, layer)) * min(TERRAIN_HEIGHT / ((l+3.25)*0.15), TERRAIN_HEIGHT * 0.6);\n    \tfloat y = nuv.y - height;\n   \t \n    \t// the final position of the tree\n    \tfloat treeOff = TREE_OFFSET*hash.x/(layer*0.1+0.2) - spacing*0.5;\n    \tvec2 pos = vec2(mod(x, spacing) + treeOff, y);\n   \t \n    \t// rendering the ground\n    \tfloat terrainDst = smoothstep(-pixelWidth, pixelWidth, height-nuv.y);\n    \tcol = mix(col, GROUND_COLOR, terrainDst);\n   \t \n    \t// checking if a secondary item should be rendered\n    \tif (hash.z < ITEM_AMOUNT && layer > 1.)\n    \t{\n        \t// rendering a gravestone\n        \tfloat grave = GraveStone(pos*(layer*0.2)*0.75);\n        \tif (grave < 1.)\n        \t{\n            \tcol = vec3(grave);\n            \tdepth = layer;\n        \t}\n    \t}\n   \t \n    \t// finding the depth\n    \tdepth = mix(depth, layer, terrainDst);\n\t}\n    \n\t// rendering ground fog\n\tfloat fog = exp((depth-FOREST_LAYERS) * 0.5) * smoothstep(3., -4., uv.y);\n\tcol += fog;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p_moon = (1.25*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p_moon *= 5.0;\n    m *= 1.3;\n    \n    float ra = 1.0;\n    float rb = 0.8;\n    float di = 1.2*cos(iTime+3.9);\n    vec2 cameraOffset = vec2(0., 1.);\n    float zoom = 6.;\n    \n    float d = sdMoon( p_moon, di, ra, rb );\n    float pixelWidth = zoom / iResolution.y * 1.5;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * zoom + cameraOffset;\n    vec2 mouseOffset = smoothstep(0., 1., iMouse.xy/iResolution.xy) * vec2(10., 5.);\n    \n    vec3 col =vec3(0.984,0.957,0.176) - sign(d)*vec3(1.000,0.969,0.000);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\t//col *= 0.8 + 0.2*cos(100.0*d);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // rendering the ground and forest\n\tRenderForest(col, uv, pixelWidth, mouseOffset, iTime*2.);\n\n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}