{"ver":"0.1","info":{"id":"NtB3Dm","date":"1623984448","viewed":44,"name":"Twirl compare 2","username":"Envy24","description":"Twirl compare","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["twirlcompare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2831853071795862 // 2*PI\n\nfloat transformParameter(float t)\n{\n    t = clamp(t, 0.0, 1.0);\n\n    return 0.5 * (1.0 + sin(4.71239 * (t * 2.0 - 1.0) * (t * 2.0 - 1.0)));\n}\n\nvec2 twirlLeft(\n    float u,\n    float v,\n    float uCenter,\n    float vCenter,\n    float maxDistance,\n    float theta)\n{\n    u -= uCenter;\n    v -= vCenter;\n    \n    float distance_ = sqrt(u * u + v * v);\n\n    float alpha = atan(v, u) + theta * ((maxDistance - distance_) / maxDistance);\n\n    return vec2(\n        distance_ <= maxDistance ?\n            uCenter + distance_  * cos(alpha) :\n            uCenter + u,\n        distance_ <= maxDistance ?\n            vCenter + distance_  * sin(alpha) :\n            vCenter + v);\n}\n\n/* Without using atan https://www.shadertoy.com/view/slfGzN \n   \n   Uses smoothstep interpolation\n*/\nvec2 twirlRight(\n    float u,\n    float v,\n    float uCenter,\n    float vCenter,\n    float maxDistance,\n    float theta)\n{\n    u -= uCenter;\n    v -= vCenter;\n    \n    /**/\n    float alpha = \n        smoothstep(\n            0.0, maxDistance,\n            maxDistance - sqrt(u * u + v * v)) * theta;\n            \n    /* some interesting pattern *\n    float alpha = transformParameter(maxDistance - sqrt(u * u + v * v)) * theta;\n    /**/\n    \n    float c = cos(alpha);\n    float s = sin(alpha);\n\n    return vec2(\n        uCenter + u * c - v * s,\n        vCenter + u * s + v * c);\n}\n\nfloat pixelColor(vec2 uv, vec2 tranformed_uv, float smoothness)\n{\n    return smoothstep(0.0, 1.0, smoothness * abs(length(uv) - length(tranformed_uv)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= 2.0;\n    \n    uv.y *= aspectRatio;\n    uv.y -= 0.40;\n\n    float smoothness = 1.0 + 400.0 - (iMouse.x / iResolution.x) * 400.0;\n    float maxDistance = 0.25 + (1.0 + sin(iTime * 0.2)) * 0.5;\n    float theta = 0.2 +  (1.0 + sin(iTime * 0.5)) * TAU;\n    float scale = 1.0;\n    float col = 0.5;\n\n    if (uv.x < 1.0 * aspectRatio)\n    {  \n        col = \n            pixelColor(\n                uv, \n                twirlLeft(uv.x, uv.y, 0.5 * aspectRatio, 0.5, maxDistance, theta),\n                smoothness);\n    }\n    else if ((uv.x >= 1.0 * aspectRatio) && (uv.x < 2.0 * aspectRatio))\n    {\n        col = \n            pixelColor(\n                uv, \n                twirlRight(uv.x, uv.y, 1.5 * aspectRatio, 0.5, maxDistance, theta),\n                smoothness);\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"}]}