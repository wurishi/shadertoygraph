{"ver":"0.1","info":{"id":"Wsj3RD","date":"1559971069","viewed":466,"name":"Visualizer 1","username":"josplode","description":"Music visualizer experiment 1","likes":3,"published":3,"flags":96,"usePreview":0,"tags":["music","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4ls3Dn","filepath":"https://soundcloud.com/joey-bzdek/aftermath","previewfilepath":"https://soundcloud.com/joey-bzdek/aftermath","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 sampleChannel0Pixel(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    \n    const float SAMPLES = 4.;\n    for (float i = 0.; i < SAMPLES; ++i)\n    {\n        color += sampleChannel0Pixel(fragCoord + vec2(0., i - SAMPLES / 2.));\n    }\n    color /= SAMPLES;\n    \n    color.x += abs(dFdx(color.x) * 2.);\n    color.y += abs(dFdx(color.y) * 2.);\n    color.z += abs(dFdx(color.z) * 2.);\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PERLIN_OCTAVES = 7.;\n\nfloat perlin(vec2 uv)\n{\n    float val = texture(iChannel0, uv).r / 8.;\n    \n    float valDivisor = pow(2., PERLIN_OCTAVES);\n    float uvDivisor = 0.25;\n    for (float i = 0.; i < PERLIN_OCTAVES; ++i)\n    {\n        uvDivisor *= 2.;\n        valDivisor /= 2.;\n        val += texture(iChannel0, uv / uvDivisor).r / valDivisor;\n    }\n    \n    return val / 4.;\n}\n\nconst float GRAD_STEP = 0.001;\n\nvec2 perlinGradient(vec2 uv)\n{\n    float A = perlin(uv);\n    float B = perlin(uv+vec2(GRAD_STEP,0.));\n    float C = perlin(uv+vec2(0.,GRAD_STEP));\n    \n    return vec2((B - A) / GRAD_STEP, (C - A) / GRAD_STEP);\n}\n\nvec3 perlinNormal(vec2 uv)\n{\n    vec3 A = vec3(uv, perlin(uv));\n    vec2 bUV = uv+vec2(GRAD_STEP, 0.);\n    vec3 B = vec3(bUV, perlin(bUV));\n    vec2 cUV = uv+vec2(0., GRAD_STEP);\n    vec3 C = vec3(cUV, perlin(cUV));\n    \n    vec3 T = B - A;\n    vec3 T2 = C - A;\n    \n    return normalize(cross(T, T2));\n}\n\nfloat bullshitSDF(vec3 pos)\n{\n    vec2 uv = pos.xy;\n    vec2 grad = perlinGradient(uv);\n    int maxIterations = 10;\n    while (maxIterations > 0 && (grad.x + grad.y) >= 1.)\n    {\n        uv += GRAD_STEP * grad;\n        maxIterations--;\n        grad = perlinGradient(uv);\n    }\n    \n    return pos.z - perlin(uv);\n}\n\nvec3 lightPos = vec3(1., 1., 1.);\n\nconst float INTERSECT_DISTANCE = 0.01;\n\nconst vec3 BLUE = vec3(0.2, .5, .2);\nconst vec3 VIOLET = vec3(4., 0., 0.);\n\nbool rayMarch(inout vec3 p, vec3 d, out vec3 color)\n{\n    float dist = bullshitSDF(p);\n\n    if (dist <= INTERSECT_DISTANCE)\n    {\n        vec3 L = lightPos - p;\n        vec3 N = perlinNormal(p.xy);\n        float cosTheta = dot(N, L);\n        float lightDist = length(L) * 0.5;\n        L = normalize(L);\n        \n        \n        float alpha = perlin(p.xy) - 0.35;\n        color = mix(BLUE, VIOLET, alpha) * 4.;\n        \n        color *= cosTheta / (lightDist * lightDist);\n        return false;\n    }\n    \n    p += d * dist;\n    \n    return true;\n}\n\nvec3 pixelColor(vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float volume = texture(iChannel3, vec2(0.02, 0.)).r;\n    \n    vec2 offset = vec2(0. + (iTime * 0.1 * (1. + volume * 0.01)), cos(iTime * -0.025) + sin(iTime * 0.044));\n    \n    lightPos.x += sin(iTime) * 4.;\n    lightPos.y += cos(iTime * 2.7) * 4.;\n    lightPos.z += sin(iTime * 0.3) * 2. + 2.;\n   \n    vec3 p = vec3(offset, 1.);\n    vec3 d = vec3(1., 0. + uv.x * 0.8, -1. + uv.y * 0.8);\n    \n    if (d.y > 0.4)\n    {\n        d.y = 0.8-d.y;\n    }\n    if (d.z < -0.6)\n    {\n        d.z = -1.2 - d.z;\n    }\n    \n    d = normalize(d);\n    \n    lightPos.xy += offset;\n    \n    vec3 color;\n    \n    int maxIterations = 7;\n    while (maxIterations-- > 0 && rayMarch(p, d, color));\n    \n    return clamp(color, vec3(0.), vec3(1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(pixelColor(fragCoord), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Horizontal gaussian blur\n\nvec3 sampleChannel0Pixel(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    \n    const float SAMPLES = 4.;\n    for (float i = 0.; i < SAMPLES; ++i)\n    {\n        color += sampleChannel0Pixel(fragCoord + vec2(i - SAMPLES / 2., 0.));\n    }\n    color /= SAMPLES;\n    \n    fragColor = vec4(color, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}