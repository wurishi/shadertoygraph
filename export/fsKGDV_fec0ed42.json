{"ver":"0.1","info":{"id":"fsKGDV","date":"1632223942","viewed":64,"name":"loka：【故障3-1】错位线条故障","username":"LokaHer","description":" 1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _LinesWidth (0.8) //越小越宽\n#define _Amount (0.3) //控制线条数量，1就无了\n#define _Offset (0.9) //控制线条的强度\n#define _Alpha (0.9) //混合比例\n\nfloat randomNoise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(1.9898, 7.233))) * 43758.5453123);\n}\n\nfloat trunc(float x, float num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nvec2 trunc(vec2 x, vec2 num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nvec3 rgb2yuv(vec3 rgb)\n{\n    vec3 yuv;\n    yuv.x = dot(rgb, vec3(0.299, 0.587, 0.114));\n    yuv.y = dot(rgb, vec3(-0.14713, -0.28886, 0.436));\n    yuv.z = dot(rgb, vec3(0.615, -0.51499, -0.10001));\n    return yuv;\n}\n\t\nvec3 yuv2rgb(vec3 yuv)\n{\n    vec3 rgb;\n    rgb.r = yuv.x + yuv.z * 1.13983;\n    rgb.g = yuv.x + dot(vec2(-0.39465, -0.58060), yuv.yz);\n    rgb.b = yuv.x + yuv.y * 2.03211;\n    return rgb;\n}\n\nvec3 LineBlockGlitch(vec2 uv)\n{\n    float truncTime = trunc(iTime, 4.0);\n    float uv_trunc = randomNoise(trunc(uv.yy, vec2(8., 8.)) + vec2(100.0 * truncTime));\n    //return vec3(uv_trunc); ------------------------------1\n    \n    float uv_randomTrunc = 6. * trunc(iTime, 24. * uv_trunc);\n    //return vec3(uv_randomTrunc); ------------------------2\n    \n    float blockLine_random = 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(8. * _LinesWidth, 8. * _LinesWidth)));\n    blockLine_random += 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(7., 7.)));\n    blockLine_random = blockLine_random * 2.0 - 1.0;\t\n    blockLine_random = sign(blockLine_random) * clamp((abs(blockLine_random) - _Amount) / (0.4), 0., 1.);\n    blockLine_random = mix(0., blockLine_random, _Offset);\n    //return vec3(blockLine_random);-----------------------3\n    \n    vec2 uv_blockLine = uv;\n    uv_blockLine = clamp(uv_blockLine + vec2(0.1 * blockLine_random, 0.), 0., 1.);\n    \n    vec3 col = texture(iChannel0, abs(uv_blockLine)).xyz;\n    //return col; -----------------------------------------4\n    \n    col = rgb2yuv(col);\n    col.y /= 2. - 3. * abs(blockLine_random) * clamp(0.5 -  blockLine_random, 0., 1.); //Chrominance\n    col.z += 3.25 *  blockLine_random * clamp( blockLine_random - .5, 0., 1.);  //Chroma\n    col = yuv2rgb(col);\n    \n    vec3 ori_col = texture(iChannel0, uv).xyz;\n    return mix(ori_col, col, vec3(_Alpha));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = LineBlockGlitch(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}