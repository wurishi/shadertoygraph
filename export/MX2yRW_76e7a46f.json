{"ver":"0.1","info":{"id":"MX2yRW","date":"1727059381","viewed":35,"name":"Golden Pendulum Animation","username":"savorsauce","description":"A physics pendulum simulation with offsets based on the golden ratio. Enjoy :)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["shader","physics","pendulum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_TRAILS 30.0  // Maximum number of frames for trails\n\n// Function to calculate the golden angle\nfloat goldenAngle(int index) {\n    return float(index) * (PI * (3.0 - sqrt(5.0))); // Golden angle in radians\n}\n\n// Function to calculate the angle and color for each pendulum at a given time\nvec3 pendulum(float time, float index, out vec2 tipPosition, float fixedLength) {\n    // Pendulum parameters\n    float amplitude = 2.0;   // Swing amplitude\n    \n    // Calculate the swing angle with time based on the index\n    float angle = amplitude * sin(time * (1.0 + 0.5 * index));\n\n    // Compute pendulum tip position with fixed length\n    tipPosition = vec2(sin(angle), -cos(angle)) * fixedLength;\n    \n    // Color for the pendulum line\n    vec3 lineColor = vec3(0.3 + 0.3 * sin(index + time), 0.3 + 0.3 * cos(index + time * 1.5), 0.3 + 0.3 * sin(index * 2.0 - time));\n    \n    return lineColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize the pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;  // Center the coordinates (-1 to 1 range)\n    uv.x *= iResolution.x / iResolution.y; // Maintain aspect ratio\n\n    // Pendulum parameters\n    float numPendulums = 7.0;\n    float fixedLength = 0.7; // Fixed length for each pendulum\n    float circleRadius = 0.005; // Circle radius at connection points\n    \n    // Time control for the current frame\n    float trailTime = mod(iTime, MAX_TRAILS);  // Time for generating trails\n\n    // Initial pendulum origin\n    vec2 origin = vec2(0.0, 0.0); // Starting point of the pendulum\n    vec3 col = vec3(0.0);         // Initialize color\n\n    // Array to hold the tip positions of each pendulum for trail rendering\n    vec2 pendulumTips[10]; // Store pendulum tip positions for trails\n\n    // First, render the current pendulums (always visible)\n    for (float i = 0.0; i < numPendulums; i++) {\n        // Calculate position using the golden angle\n        float angleOffset = goldenAngle(int(i));\n        vec2 offset = vec2(cos(angleOffset), sin(angleOffset)) * 0.2; // Radius for positioning\n\n        // Calculate the current pendulum tip position and color\n        vec2 pendulumTip;\n        vec3 lineColor = pendulum(iTime, i, pendulumTip, fixedLength);\n\n        // Update the tip position with the offset\n        pendulumTip += origin + offset;\n\n        // Store the tip position for trail rendering\n        pendulumTips[int(i)] = pendulumTip;\n\n        // Draw current pendulum lines between the origin and pendulumTip\n        float segment = clamp(dot(uv - origin, pendulumTip - origin) / dot(pendulumTip - origin, pendulumTip - origin), 0.0, 1.0);\n        vec2 linePoint = mix(origin, pendulumTip, segment);\n        float distToLine = distance(uv, linePoint);\n        col += smoothstep(0.01, 0.005, distToLine) * lineColor;\n\n        // Draw circles at the connection points for each pendulum\n        float distToCircle = distance(uv, pendulumTip);\n        col += smoothstep(circleRadius + 0.005, circleRadius - 0.005, distToCircle) * vec3(1.0, 1.0, 1.0);\n\n        // Move to the next pendulum tip as the new origin for the next pendulum\n        origin = pendulumTip;\n    }\n\n    // Now, render the trailing effect for the past frames\n    for (float t = 0.0; t < MAX_TRAILS; t++) {\n        vec2 trailOrigin = vec2(0.0); // Reset trail origin for each frame\n        float fadeFactor = (MAX_TRAILS - t) / MAX_TRAILS;  // Fade over time\n\n        for (float i = 0.0; i < numPendulums; i++) {\n            // Calculate position using the golden angle\n            float angleOffset = goldenAngle(int(i));\n            vec2 offset = vec2(cos(angleOffset), sin(angleOffset)) * 0.2; // Radius for positioning\n\n            // Calculate the pendulum tip position and color at the given trail time\n            vec2 pendulumTip;\n            vec3 lineColor = pendulum(iTime - t / 60.0, i, pendulumTip, fixedLength);\n\n            // Update the tip position with the offset\n            pendulumTip += trailOrigin + offset;\n\n            // Draw lines between the origin and pendulumTip for previous positions\n            float segment = clamp(dot(uv - trailOrigin, pendulumTip - trailOrigin) / dot(pendulumTip - trailOrigin, pendulumTip - trailOrigin), 0.0, 1.0);\n            vec2 linePoint = mix(trailOrigin, pendulumTip, segment);\n            float distToLine = distance(uv, linePoint);\n            col += smoothstep(0.01, 0.005, distToLine) * lineColor * fadeFactor;  // Fade opacity over time\n\n            // Draw circles at the connection points for previous positions\n            float distToCircle = distance(uv, pendulumTip);\n            col += smoothstep(circleRadius + 0.005, circleRadius - 0.005, distToCircle) * vec3(1.0) * fadeFactor;  // Fade opacity over time\n\n            // Update the trail origin for the next pendulum in the trail\n            trailOrigin = pendulumTip;\n        }\n    }\n\n    // Output the final color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}