{"ver":"0.1","info":{"id":"3d3BRS","date":"1605347194","viewed":122,"name":"Unrolling cardioid.","username":"Logos","description":"Unrolling main Mandelbrot cardioid - we can see emerging fractal elephants.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","2d","fractal","mandelbrot","cardioid","main","bending","unrolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 14.11.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\nvec3 fractal(vec2 p)\n{   \n    \n    //--- basic constants ---//\n    \n    const vec2     O = vec2(1, 0);\n    const vec2     I = vec2(0, -1);\n    const float s3d2 = 0.5*sqrt(3.0);\n\n    \n    //--- moebius transform coefficients ---//\n    \n    const vec2 a = vec2(-0.5, -s3d2);\n\tconst vec2 b = vec2(1.5, -s3d2);\n\tconst vec2 c = vec2(0.5, s3d2);\n\tconst vec2 d = vec2(1.5, -s3d2);\n\n    \n    //--- horizontal movement ---//\n    \n    vec2 z = p;\n    \n    if (iMouse.z > 0.5)\n    {\n        z.x += 40.0*(iMouse.x / iResolution.x - 0.5);\n    }\n    else\n    {\n        z.x += 0.2*iTime;\n    }\n\n    \n    //--- unrolling cardioid (two stages) ---//\n    \n    z = cMob(z, a, b, c, d);\t\t\t\t// stage 1: unrolling disc\n    z = 0.25 * (O - cMul(z + O, z + O));\t// stage 2: transform cardioid into disc\n    \n\n    //--- generating \"before unrolling\" chessboard ---//\n    \n    vec2 q = floor(25.3*z);\t\t\t\t\t// checkboard size\n    bool ch = mod(q.x + q.y, 2.0) == 0.0;\n\n    \n    //--- calculate fractal ---//\n    \n    float an = 0.0;\n    \n    p = z;\n      \n\tfor (float i = 0.0; i < 512.0; i++)\n    {\n        z = cMul(z, z) + p;\t\t\t\t\t// Mandelbrot formulae\n\n\t\tif (dot(z, z) > 4.0)\n        {\n            float f = 1.0 - i/512.0;\n            f *= f;\n\n            return vec3(f, 0.6*f*(ch?0.0:1.0), 0);\t// outside color\n\t\t}\n        \n        an += z.x;\n\t}\n\n    \n    //--- inside color ---//\n    \n    an += iTime;\n    return vec3(0.5 + 0.5 * sin(4.0*an));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- calculate point coordinates ---//\n\n    float ZOOM = 0.6;\n    vec2\tp  = ZOOM * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    p.y += 0.26;\n    p.x -= 1.0;\n\n    \n    //--- set final antialiased pixel color by accumulating samples ---//\n    \n    float a  = 2.0;\t\t\t\t\t// improves quality, use carefully (3-4 max), only ints!\n    float o  = 1.0 / (4.0*a*a);\n    float e  = 0.5 / min(iResolution.x, iResolution.y);    \n    float ea =   e / a * ZOOM;\n    \n    vec3 fc = vec3(0.0);\t\t\t// final color\n    \n    \n    //--- that is why \"a\" variable must be choosen carefully :D ---//\n    \n    for (float j = -a; j < a; j++)\n        for (float i = -a; i < a; i++)\n\n            fc += o*fractal(p + ea*vec2(i, j));\n        \n    fragColor = vec4(fc, 1.0); \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 cMul(vec2 z, vec2 w)\n{\n    return vec2 (z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\n\nvec2 cDiv(vec2 z, vec2 w)\n{\n\treturn vec2 (z.x*w.x + z.y*w.y, -z.x*w.y + z.y*w.x)/(w.x*w.x + w.y*w.y);\n}\n\n\nvec2 cMob(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return cDiv(cMul(a, z) + b, cMul(c, z) + d);\n}\n\n\nvec2 cMobI(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return cDiv(cMul(d, z) - b, -cMul(c, z) + a);\n}\n\n\nfloat cMod(vec2 z)\n{\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\n\nvec2 cSqrt (vec2 z)\n{\n  float t = sqrt(2.0 * (cMod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n\nvec2 rot(vec2 v, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    \n\treturn vec2(ca*v.x + sa*v.y, -sa*v.x + ca*v.y);\n}\n","name":"Common","description":"","type":"common"}]}