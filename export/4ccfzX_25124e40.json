{"ver":"0.1","info":{"id":"4ccfzX","date":"1733324666","viewed":202,"name":"Bouncy Bounce Beach 3D üèñÔ∏èüåûüèê","username":"chronos","description":"Bouncy! Use mouse to play!","likes":35,"published":1,"flags":32,"usePreview":0,"tags":["game","collision","sea","clouds","music","audio","ocean","ball","bounce","physics","bouncy","summer","beach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    -----------------------------------------------------\n    Bouncy Bounce Beach 3D üèñÔ∏èüåûüèê by chronos\n    -----------------------------------------------------\n    \n    Rules:\n     ~~~~~~~~~~~~~~   Be the seal!   ~~~~~~~~~~~~~~\n     ~~~~~~~~~~~~~~ Bounce the ball  ~~~~~~~~~~~~~~\n     ~~~~~~~~~~~~~~    Good vibes    ~~~~~~~~~~~~~~\n    \n    You get a point for each bounce! üåû\n    \n    If the cloud rendering is a bit heavy for your GPU, try turning them off with\n    either setting \n        CLOUDS to 0\n    or\n        HIGH_QUALITY to 0\n    in Common tab\n    \n    Based on my previous shader: \n     \"Bouncy Bounce Beach üèñÔ∏èüåûüèê\"\n     https://www.shadertoy.com/view/XfVczK\n        \n    Sea rendering is based on a modified version of Seascape by TDM (https://www.shadertoy.com/view/Ms2SD1)\n    \n    \n    Thanks to Nguyen2007 aka random guy for perf optimization suggestions! :)\n        https://www.shadertoy.com/user/Nguyen2007\n\n    -----------------------------------------------------\n    self link: https://www.shadertoy.com/view/4ccfzX\n*/\n\n\n/*\n//   MOVED QUALITY FLAGS TO COMMON TAB! \n//   Have a look there if fps is too low :)\n*/\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(a*k) + exp(b*k))/k; \n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p, b)/dot(b,b), 0. , 1.) * b - p);\n}\n\nfloat halfdisc(vec2 c, vec2 dir, float r, vec2 p)\n{\n    float sdf = length(c-p)-r;\n    dir = normalize(dir);\n    float proj = dot(p-c, dir);\n    if(length(p - (c + proj*dir)) <= r+0.1) sdf = max(sdf, proj);\n    return sdf;\n}\n\nvec3 beach_ball(vec3 color, vec2 uv, vec3 pos, float rot)\n{\n\n    float focal = 2.;\n    \n    \n    #if 0\n    // Perspective\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3(0, 0, focal*2.);\n    /*\n    rd = axisangle(vec3(0,0,1), iTime, rd);\n    rd = axisangle(vec3(1,0,0), iTime, rd);\n    ro = axisangle(vec3(1,0,0), iTime, ro);\n  */  \n    #else\n    // Orthographic\n    vec3 rd = vec3(0, 0, -1);\n    vec3 ro = vec3(uv, focal*2.);\n    rd = axisangle(vec3(1,0,0), rot, rd);\n    ro = axisangle(vec3(0,0,1), rot, ro);\n    ro = axisangle(vec3(1,0,0), rot, ro);\n    #endif\n    \n    float radius = .5;\n    \n    vec2 T = ray_sphere(ro, rd, pos, radius);\n    vec3 p1 = rd * T.x + ro;\n    vec3 p2 = rd * T.y + ro;\n    //float t = (T.x > 0. && p1.y > 0.) ? T.x : (T.y > 0.  && p2.y > 0. ? T.y : -1.);\n    float t = T.x;\n    if(t > 0.) {\n        vec3 p = rd * t + ro;\n        float stripes = 1.-(smoothstep(0.1, 0.2, cos(10. * atan(p.z-pos.z, p.x-pos.x)))*.75+.25);\n        stripes = mix(stripes, 0.75, step(0.995*radius, abs(p.y-pos.y)));\n        vec3 ball_color = mix(vec3(1), vec3(0,0,1), stripes);\n        \n        vec3 N = normalize(p-pos);\n        vec3 L = normalize(vec3(1, 1, 1));\n        vec3 R = reflect(rd, N);\n\n        // Move light dir with camera\n        #if 1\n        L = axisangle(vec3(0,0,1), rot, L);\n        L = axisangle(vec3(1,0,0), rot, L);\n        #endif\n\n        float NdotL = max(dot(N, L), 0.);\n        float RdotL = max(dot(R, L), 0.);\n        color = ball_color * (.25+.75*NdotL) + pow(RdotL, 5.);\n        \n        if(t == T.y) color *= 0.75;\n        \n        \n    }\n    return color;\n}\n\n// Obviously completely different from the beach ball function :)\nvec3 parasol(vec3 color, vec2 uv, vec3 pos, float rot)\n{\n\n    float focal = 2.;\n    \n    \n    #if 0\n    // Perspective\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3(0, 0, focal*2.);\n    /*\n    rd = axisangle(vec3(0,0,1), iTime, rd);\n    rd = axisangle(vec3(1,0,0), iTime, rd);\n    ro = axisangle(vec3(1,0,0), iTime, ro);\n      */  \n    #else\n    // Orthographic\n    vec3 rd = vec3(0, 0, -1);\n    vec3 ro = vec3(uv, focal*2.);\n    rd = axisangle(vec3(1,0,0), rot, rd);\n    ro = axisangle(vec3(0,0,1), rot, ro);\n    ro = axisangle(vec3(1,0,0), rot, ro);\n    #endif\n    \n    float radius = .6;\n    \n    vec2 T = ray_sphere(ro, rd, pos, radius);\n    vec3 p1 = rd * T.x + ro;\n    vec3 p2 = rd * T.y + ro;\n    float t = (T.x > 0. && p1.y > 0.) ? T.x : (T.y > 0.  && p2.y > 0. ? T.y : -1.);\n    if(t > 0.) {\n        vec3 p = rd * t + ro;\n        float stripes = 1.-(smoothstep(0.1, 0.2, cos(10. * atan(p.z-pos.z, p.x-pos.x)))*.75+.25);\n        stripes = mix(stripes, 0.75, step(0.995*radius, abs(p.y-pos.y)));\n        vec3 ball_color = mix(vec3(1), vec3(1,0,0), stripes);\n        \n        vec3 N = normalize(p-pos);\n        vec3 L = normalize(vec3(1, 1, 1));\n        vec3 R = reflect(rd, N);\n\n        // Move light dir with camera\n        #if 1\n        L = axisangle(vec3(0,0,1), rot, L);\n        L = axisangle(vec3(1,0,0), rot, L);\n        #endif\n\n        float NdotL = max(dot(N, L), 0.);\n        float RdotL = max(dot(R, L), 0.);\n        color = ball_color * (.25+.75*NdotL) + pow(RdotL, 5.);\n        \n        if(t == T.y) color *= 0.75;\n    }\n    return color;\n}\n\n\n// Just seal stuff!\nfloat disc(vec2 c, float r, vec2 p)\n{\n    return length(p - c) - r;\n}\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(-a/k)+exp(-b/k))*k;\n}\nfloat cap(vec2 a, vec2 b, float r1, float r2, vec2 p)\n{\n    p-= a; b-=a;\n    float scalar_proj = clamp(dot(p,b)/dot(b,b), 0., 1.);\n    float r = mix(r1, r2, scalar_proj);\n    return length(scalar_proj * b - p) - r;\n}\nvec3 seal(vec3 color, vec2 uv, vec2 mouse, float ps)\n{\n    vec2 a, b, c, snoot;\n    a = vec2(-0.5,-.5)*.25; b =  mouse; // vec2(1, 1)*.25 +\n    c = vec2(-3., -1.1)*.25 + (vec2(0,1) * (sin(iTime*10.)*.025));\n    \n    snoot = normalize(normalize(b-a) + normalize(b-a).yx*vec2(1,-1))*0.25;\n    vec2 eye = b + snoot*0.45 + 0.06*normalize(b-a);\n    float r = 0.125;\n    \n    \n    // neck\n    float d = cap(a, b, 0.18, 0.11, uv);\n    \n    // body\n    d = smin(d, cap(c, a, 0.15 - length(b-a)*0.025, 0.25 - length(b-a)*0.05, uv), 0.15);\n        \n    // snoot\n    d = smin(d, \n        cap(b, b+snoot, 0.035, 0.03, uv), \n    0.1);\n    \n    // flippers\n    d = smin(d, cap(a, a-vec2(0., .35), 0.03, 0.0125, uv), 0.1);\n    \n    \n    // Tail\n    d = smin(d, \n        cap(c, \n        c + normalize(vec2(-2,.5))*0.3\n        + vec2(0,1) * (sin(iTime*10.)*.025)\n        , 0.02 +0.005-length(b-a)*0.005\n        , 0.01, uv),\n    0.02);\n    \n    d = smin(d, \n        cap(c, \n        c + normalize(vec2(-2,-.5))*0.3\n        + vec2(0,1) * (sin(iTime*10.)*.025)\n        , 0.02 +0.005-length(b-a)*0.005, 0.01, uv), \n    0.065);\n    \n    color = mix(color, vec3(.5), smoothstep(1.5*ps, 0.+.5*ps, d));\n    color *= 0.66+0.33*smoothstep(0.0, -0.2, d);\n    \n    // eye\n    color *= 0.05+.95*smoothstep(-ps, ps, disc(eye, 0.03, uv));\n    \n    color *= 0.5+.5*smoothstep(-ps, ps, disc(b+snoot + normalize(b-a)*0.03+ normalize(b-a).yx*vec2(1,-1)*0.025, 0.01, uv));\n    \n    color *= 0.5+.5*smoothstep(ps*.5, 1.5*ps, seg(b+snoot - normalize(b-a)*0.01,\n    b+snoot + normalize(b-a).yx*vec2(1,-1)*0.05, uv));\n    \n    return color;\n}\n// No more seal stuff :(\n\n\n// Score discplay stuff\n/*\n    a\tb\tc\td\te\tf\tg\n0\t√ó\t√ó\t√ó\t√ó\t√ó\t√ó\t \n1\t \t√ó\t√ó\t \t \t \t \n2\t√ó\t√ó\t \t√ó\t√ó\t \t√ó\n3\t√ó\t√ó\t√ó\t√ó\t \t \t√ó\n4\t \t√ó\t√ó\t \t \t√ó\t√ó\n5\t√ó\t \t√ó\t√ó\t \t√ó\t√ó\n6\t√ó\t \t√ó\t√ó\t√ó\t√ó\t√ó\n7\t√ó\t√ó\t√ó\t \t \t \t \n8\t√ó\t√ó\t√ó\t√ó\t√ó\t√ó\t√ó\n9\t√ó\t√ó\t√ó\t \t \t√ó\t√ó\n*/\nbool sevseg_a(int num) { return num != 1 && num != 4; }\nbool sevseg_b(int num) { return num != 5 && num != 6; }\nbool sevseg_c(int num) { return num != 2            ; }\n\nbool sevseg_d(int num) { return num != 1 && num != 4 && num != 7 && num != 9 ; }\nbool sevseg_e(int num) { return num == 0 || num == 2 || num == 6 || num == 8 ; }\nbool sevseg_f(int num) { return num != 1 && num != 2 && num != 3 && num != 7 ; }\nbool sevseg_g(int num) { return num != 0 && num != 1 && num != 7             ; }\n\nfloat sevenseg_sdf(int num, vec2 uv)\n{\n    float w = 0.05;\n    float h = 0.1;\n    float d = 9e9;\n    // Horizontal bars\n    if(sevseg_a(num)) d = min(d, seg(vec2(-w, h), vec2(w, h), uv));\n    if(sevseg_g(num)) d = min(d, seg(vec2(-w, 0), vec2(w, 0), uv));\n    if(sevseg_d(num)) d = min(d, seg(vec2(-w,-h), vec2(w,-h), uv));\n    \n    // Left vertical bars\n    if(sevseg_f(num)) d = min(d, seg(vec2(-w, 0), vec2(-w, h), uv));\n    if(sevseg_e(num)) d = min(d, seg(vec2(-w, 0), vec2(-w,-h), uv));\n    \n    // Right vertical bars\n    if(sevseg_b(num)) d = min(d, seg(vec2( w, 0), vec2( w, h), uv));\n    if(sevseg_c(num)) d = min(d, seg(vec2( w, 0), vec2( w,-h), uv));\n    \n    return d;\n}\n\nfloat score_sdf(float points, vec2 uv)\n{\n    float sdf = 9e9;\n    int digit0 = int(points)%10;\n    int digit1 = (int(points)/10)%10;\n    int digit2 = (int(points)/100)%10;\n    int digit3 = (int(points)/1000)%10;\n    sdf = min(sdf, sevenseg_sdf(digit0, uv-vec2(0.2,0)));\n    sdf = min(sdf, sevenseg_sdf(digit1, uv-vec2(0.0,0)));\n    sdf = min(sdf, sevenseg_sdf(digit2, uv-vec2(-.2,0)));\n    sdf = min(sdf, sevenseg_sdf(digit3, uv-vec2(-.4,0)));\n\n    return sdf;\n}\n\nvec3 draw_sun_icon(vec3 color, vec2 uv, float ps)\n{\n    float time_since_prev_point = iTime-texelFetch(iChannel2, ivec2(0), 0).a;\n\n    float size_offset = 0.08*max(min(3.*time_since_prev_point, 1.-3.*time_since_prev_point)*2., 0.);\n\n    float size = 0.11;\n    float sdf = length(uv)-size;\n    float angle = cos(iTime)*0.2;\n    \n    const float num_spikes = 14.;\n    sdf += 0.2 * (size * cos((atan(uv.y, uv.x)/PI + angle) * PI * num_spikes ) - size_offset);\n    float alpha = smoothstep(ps, -ps-0.025, sdf);\n    color = mix(color, vec3(1,1,smoothstep(0.05, -0.25, sdf)), alpha);\n    \n    float s = sin(angle*PI), c = cos(angle*PI);\n    mat2 R = mat2(c, -s, s, c);\n    vec2 eye_uv0 = uv- R * vec2(0.025, 0.025);\n    vec2 eye_uv1 = uv- R * vec2(-0.025, 0.025);\n    vec2 mouth_uv = uv- R * vec2(0., -0.0125);\n    \n    alpha = smoothstep(ps, -ps, length(eye_uv0)-size*0.1);\n    alpha = max(alpha, smoothstep(ps, -ps, length(eye_uv1)-size*0.1));\n    alpha = max(alpha, smoothstep(ps, -ps, max(length(mouth_uv)-size*0.2, (transpose(R)*mouth_uv).y)));\n    color = mix(color, vec3(0), 0.95*alpha);\n    \n    return color;\n}\n\nvec3 draw_score(vec3 color, float points, vec2 uv, float ps)\n{\n    { // Bounding box early out.\n        vec2 bbox = abs(uv) - vec2(.55, .15);\n        if(max(bbox.x, bbox.y) > 0.) return color;\n    }\n    uv -= vec2(.25, 0);\n    float thickness = 0.0025;\n    {\n        // Shadow\n        float sdf = score_sdf(points, uv-vec2(-0.01));\n        float alpha = smoothstep(7.*ps, -2.*ps, sdf-thickness);\n        color = mix(color, vec3(0), .2*alpha);\n    }\n\n    float sdf = score_sdf(points, uv);\n    float alpha = smoothstep(1.5*ps, .5*ps, sdf-thickness);\n    color = mix(color, vec3(1), alpha);\n    \n    color = draw_sun_icon(color, uv-vec2(-.62, 0), ps);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float ps = 2. / iResolution.y;\n    \n    \n    vec2 refl_offset = mat2(1,1,-1,1)*sqrt(1./2.)*(uv-vec2(0.85,-.25))*vec2(1.8,.8);\n    float wave_offset = texture(iChannel2, fragCoord.xy/512.).r;\n    float waves = (sin(3.14159265*(wave_offset + uv.y*20.) + 0.8*cos(iTime+(uv.x-1.)*20. * .33 / (+.25-uv.y)))*.125+.5);\n    vec3 color = clamp(texture(iChannel3, fragCoord.xy/iResolution.xy).rgb, 0., 1.);\n        \n    // Sky sun-scattering\n    color += 0.5*exp(-3. * dot(uv-vec2(1), uv-vec2(1)));\n\n    #if CLOUDS\n    \n    color =  draw_clouds(color, uv, iTime).rgb; // Actual clouds, yey!\n    \n    #else\n    \n    // Clouds, lol\n    {\n        vec3 rd = normalize(vec3(uv, -focal));\n        float h = max(1.-rd.y, 0.);\n        color = mix(color, vec3( pow(h, 4.) * .65, pow(h, 2.5), pow(h, 1.) ), smoothstep(-0.02, .01, uv.y));\n        vec2 cloud_uv = vec2(-.5, -.25)+.4*uv*vec2(1.2,3) + .025*vec2(0, sin(iTime*.4+uv.x*5.) + .25*cos(.1+iTime+uv.x*20.));\n        color = mix(color, vec3(1.), 0.13*smoothstep(0.1, -0.1, halfdisc(vec2(-1,.3), vec2(0,-1), 0.35, cloud_uv)));\n        color = mix(color, vec3(1.), 0.17*smoothstep(0.1, -0.1, halfdisc(vec2(-1.2,.5), vec2(0.2,-1), 0.35, cloud_uv)));\n        color = mix(color, vec3(1.), 0.15*smoothstep(0.1, -0.1, halfdisc(vec2(-.8,.4), vec2(0.3,-1), 0.35, cloud_uv)));\n    }\n    #endif\n    \n    // parasol\n    {\n        vec2 parasol_pos = vec2(-1.5, -.25);\n        vec2 parasol_dir = vec2(1,-2);\n        float parasol_pattern = smoothstep(0.15, 0.15, sin(20. * dot(uv-parasol_pos, parasol_dir)));\n\n        color = mix(color, vec3(0.5)*max(pow(dot(uv-parasol_pos, parasol_dir.yx*vec2(-1,1))+1.05, 8.), 0.), smoothstep(ps, -ps, seg(parasol_pos, parasol_pos+parasol_dir*.375, uv)-0.03));\n\n        /* // Old parasol code\n        color = mix(color,\n            mix(vec3(0.85), vec3(0.95,0.25,0.35), parasol_pattern)\n            *max(dot(uv-parasol_pos, parasol_dir.yx*vec2(-1,1))+.85, 0.)\n        , smoothstep(ps, -ps, halfdisc(parasol_pos, vec2(1,-2), 0.6, uv)));\n        */\n\n        color = parasol(color, uv-parasol_pos, vec3(0), -.45);\n    }\n    vec4 pos_vel = texelFetch(iChannel0, ivec2(0), 0);\n\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n\n    float rot = texelFetch(iChannel0, ivec2(0), 0).r;\n\n    vec2 peg_pos = get_peg_pos(mouse, iMouse.xy, iTime);\n\n    vec3 ball_color = vec3(1);\n    vec2 ball_offset = uv-pos;\n\n    float peg_sdf = length(uv-peg_pos)-peg_radius;\n        \n    #if 0\n    { // Old ball code. RIP. :(\n        float C = cos(rot), S = sin(rot);\n        mat2 R = mat2(C, S, -S, C);\n\n        vec2 spoke_dir = R * ball_offset;\n\n        float spokes = 1.-(smoothstep(0.1, 0.2, cos(10. * atan(spoke_dir.y, spoke_dir.x)))*.75+.25);\n        ball_color = mix(ball_color, vec3(0,0,1), spokes);\n\n        float ball_sdf = length(uv-pos)-radius;\n\n        float pre_dent_sdf = ball_sdf;\n\n        ball_sdf = smax(ball_sdf, -peg_sdf, 10.);\n\n        float r_scaling = max(1.+ pre_dent_sdf - ball_sdf, 0.000001);\n        float scaled_radius = radius * r_scaling;\n\n        float ball_offset_len = length(ball_offset);\n\n        vec3 ball_normal = normalize(vec3(ball_offset/r_scaling, sqrt(max(scaled_radius*scaled_radius - dot(ball_offset, ball_offset), 0.))));\n\n        vec3 L = normalize(vec3((vec2(1,1)-pos),0));\n        float NdotL = max(dot(ball_normal, vec3(0,1,1)+L), 0.);\n        float rim_light = smoothstep(0.3, 1., length(uv - pos - 0.2*normalize(pos-vec2(1)))/(.95+radius));\n        //color = mix(color, mix(NdotL*.25+.35, 1., 0.1)*ball_color+rim_light, smoothstep(ps, -ps, ball_sdf));\n    }\n    #endif \n    color = beach_ball(color, uv-pos, vec3(0), rot);\n    \n    // SEAL!\n    vec2 seal_pos = vec2(0,-.5);\n    color = color * (smoothstep(0.125, 3., length((sin(iTime*10.)*.1+vec2(2.5,10))*(uv-vec2(-.5,-0.9))))*.6 + .4); // shadow\n    color = seal(color, uv-seal_pos, peg_pos-seal_pos, ps);\n    \n    // Sun stuff\n    \n    float sun_block = smoothstep(0., .35, length(pos-vec2(1))-radius);\n    \n    #if HIGH_QUALITY && CLOUDS\n        #if 0\n            sun_block *= draw_clouds(color, vec2(1), iTime).a;\n        #else\n            sun_block *= texelFetch(iChannel3, ivec2(0), 0).a;\n        #endif\n    #endif \n    \n    color += 1.5*exp(-3. * dot(uv-vec2(1), uv-vec2(1)) / (.125+sun_block))*sun_block;\n    \n    // vignette\n    color *= 1.-length(uv)*.1;\n    \n    // UI\n    {\n        vec4 gamestate = texelFetch(iChannel2, ivec2(0), 0);\n        float points = gamestate.r;\n        \n        float time_since_fail = iTime-gamestate.b;\n        float score_offset = max(1.- time_since_fail, 0.)+(-0.5+.5*pos.y)*step(pos.y,-1.)\n        - float(length(iMouse.xy) < 10.)*10.;\n        vec2 score_pos = vec2(-1.25, 0.8 + score_offset );\n        color = mix(color, draw_score(color, points, uv-score_pos, ps), max(1.+score_offset, 0.));\n        \n        float time_since_prev_point = iTime-gamestate.a;\n        \n        // Peg\n        float peg_animation = .5*time_since_prev_point*step(time_since_prev_point, 0.5);\n        color = mix(color, vec3(2.)*(1.-.5*smoothstep(-.1, 0.04, peg_sdf-0.075)), \n            max(1.-peg_animation*4., 0.) * .05*smoothstep(ps, -ps, abs(peg_sdf-0.065-peg_animation\n                )-0.01));\n        if(length(iMouse.xy) < 10.)\n        {\n            float alpha = 0.185 * (2. + cos(4.*iTime)) * smoothstep(2., 4., iTime) * smoothstep(11., 10., iTime);\n            color = mix(color, vec3(0), alpha*smoothstep(ps, -ps, peg_sdf+0.04));\n            color = mix(color, vec3(1), alpha*smoothstep(ps, -ps, peg_sdf+0.05));\n        }\n    }\n\n    #if 1\n    //float contrast = 1.3;\n    float contrast = 1.4;\n    color = tanh(contrast * pow(color,vec3(contrast)));\n    #else\n    color = tanh(color);\n    #endif\n    \n    \n    fragColor = vec4(pow(color, vec3(1./2.2))\n    \n    #if HIGH_QUALITY\n    + texture(iChannel1, fragCoord.xy/1024.).rgb*(1./256.)\n    #endif\n    \n    , 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define HIGH_QUALITY 1\n\n#define CLOUDS 1 && HIGH_QUALITY\n\n#define USE_MANUAL_DELTATIME 0\n\nconst float TARGET_FPS = 60.;\n\n\n/*\n\n// TODOS:\n    \n    X - Sand\n    X - Translucent water (with refraction)\n    X - Water wave adjustment (waves towards shore + reduced size of random waves)\n    X - Score counter\n    - Collectibles / Power up / modifiers\n    X - Parasol canopy\n    X - Parasol rod/pole\n    - Beach ball deformation\n    - Beach ball varied rotation\n    - Beach ball lighting\n    - easter eggs\n    - anti-aliasing\n    - refactor / clean up \n    X - Volumetric clouds\n    x - Distance fog/haze\n    - Particle effects ( sand, etc )\n\n*/\n\nfloat PI = 3.14159265;\n\nfloat radius = 0.5;\nfloat peg_radius = 0.1;\n\nvec2 default_peg_pos = vec2(0, -0.5);\nvec2 ball_init_pos = vec2(0.045, 1.5);\n\nconst float focal = 1.75;\n\n\nconst float num_fbm_levels = 4.; // 8 for full quality!\nconst float num_cloud_integration_steps = 15.; // 25 for full quality!\n\n/*\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}*/\n\nvec2 get_peg_pos(vec2 mouse_uv, vec2 mouse_xy, float time)\n{\n    vec2 peg_pos = default_peg_pos;\n    peg_pos.x += cos(time*.5)*.4+.2;\n    peg_pos.y += sin(time*2.)*.2+.33;\n    peg_pos = length(mouse_xy) > 10. ? mouse_uv : peg_pos;\n    return peg_pos;\n}\n\nvec2 ray_sphere(vec3 ro, vec3 rd, vec3 pos, float r)\n{\n    pos -= ro;\n    \n    float scalar_proj = dot(pos, rd);\n    vec3 rej = scalar_proj * rd - pos;\n    float y2 = dot(rej, rej);\n    float x2 = r*r - y2;\n    if(x2 < 0.) return vec2(-1);\n    return scalar_proj + sqrt(x2) * vec2(-1, 1);\n}\n\nvec3 axisangle(vec3 ax, float angle, vec3 p)\n{\n    ax = normalize(ax); // just in case :)\n    float sproj = dot(ax, p);\n    vec3 proj = sproj * ax;\n    vec3 rej = p - proj;\n    return proj + rej * cos(angle) + cross(ax, p) * sin(angle);\n}\n\n\nconst float cloud_density_scaling_factor = 0.165;\n\n\n#if 0\n// I think this hash function, while high quality, is too slow.\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n#else\n// Hash without sine by  Dave_Hoskins\n// hash13(vec3 p3)\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\nfloat noise_sample(vec3 coord)\n{\n    return hash(coord);\n}\n\nfloat interpolation_function(float x)\n{\n    return smoothstep(0., 1., x);\n}\n\nvec3 interpolation_function(vec3 x)\n{\n    return smoothstep(0., 1., x);\n}\n\nfloat noise(vec3 coord)\n{\n    vec3 fi = floor(coord);\n    vec3 fr = interpolation_function(fract(coord));\n    vec3 coord_000 = fi+vec3(0,0,0);\n    vec3 coord_001 = fi+vec3(0,0,1);\n    vec3 coord_010 = fi+vec3(0,1,0);\n    vec3 coord_011 = fi+vec3(0,1,1);\n    \n    vec3 coord_100 = fi+vec3(1,0,0);\n    vec3 coord_101 = fi+vec3(1,0,1);\n    vec3 coord_110 = fi+vec3(1,1,0);\n    vec3 coord_111 = fi+vec3(1,1,1);\n    \n    float f000 = noise_sample(coord_000);\n    float f001 = noise_sample(coord_001);\n    float f010 = noise_sample(coord_010);\n    float f011 = noise_sample(coord_011);\n    \n    float f100 = noise_sample(coord_100);\n    float f101 = noise_sample(coord_101);\n    float f110 = noise_sample(coord_110);\n    float f111 = noise_sample(coord_111);\n    \n    float f00z = mix(f000, f001, fr.z);\n    float f01z = mix(f010, f011, fr.z);\n    \n    float f0yz = mix(f00z, f01z, fr.y);\n    \n    float f10z = mix(f100, f101, fr.z);\n    float f11z = mix(f110, f111, fr.z);\n    \n    float f1yz = mix(f10z, f11z, fr.y);\n    \n    float fxyz = mix(f0yz, f1yz, fr.x);\n        \n    return fxyz;\n}\n\nfloat fbm(vec3 pos, float levels)\n{\n    pos *= 0.33;\n    float result = 0.;\n    for(float i = 1.; i <= levels; i++)\n    {\n        float scale = pow(.5, i);\n        result += scale * noise(pos/scale);\n    }\n    return result;\n}\n\nfloat sample_density(vec3 p)\n{\n    float density = fbm(p* 4.12242, num_fbm_levels);\n    density *= smoothstep(.5, .55, density) * cloud_density_scaling_factor;\n    return clamp(density, 0. ,1.);\n}\n\nvec4 draw_clouds(vec3 color, vec2 uv, float time)\n{    \n    vec3 ro = vec3(0,3.5,0);\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    // sky\n    float h = max(1.-rd.y, 0.);\n    color = mix(color, vec3( pow(h, 4.) * .65, pow(h, 2.5), pow(h, 1.) ), smoothstep(-0.02, .01, uv.y));\n        \n    float lower_height = 50.;\n    float upper_height = 65.;\n    \n    // Sky: y > 100.\n    // solve (rd * t + ro).y = 100.\n    float t0 = (lower_height-ro.y)/rd.y;\n    float t1 = (upper_height-ro.y)/rd.y;\n    \n    float total_transmission = 1.;\n    \n    if(t0 > 0.)\n    {\n        float current_transmission = 1.;\n        \n        vec3 start_pos = t0 * rd + ro;\n        vec3 end_pos = t1 * rd + ro;\n        float total_length = t1-t0;\n        float step_length = total_length / num_cloud_integration_steps;\n        \n        float march_step = (upper_height - lower_height) / num_cloud_integration_steps;\n                \n        vec3 total_emission = vec3(0);\n        \n        float absorption_coefficient = 1.01;\n        \n        for(float i = 0.; i < num_cloud_integration_steps; i++)\n        {\n            float height_percentage = i / (num_cloud_integration_steps-1.);\n            float step_height = (upper_height - lower_height) / num_cloud_integration_steps;\n            \n            vec3 sample_position = (t0 + total_length * height_percentage) * rd + ro;\n            \n            float density = sample_density( sample_position / 200. + time * vec3(0.1,0.02, 0.2)*-.15);\n            current_transmission *= exp(-absorption_coefficient * density * march_step);\n            \n            total_emission += \n                // incoming light * scatter function\n                current_transmission * density * exp(height_percentage) / (exp(1.)-1.)  * march_step;\n            \n            if(current_transmission < 0.01) break;\n            if (length(sample_position) > 5e3) break;\n        }\n        total_transmission = current_transmission;\n        \n        color = color * total_transmission + total_emission;        \n    }\n    return vec4(color, total_transmission);\n}\n   \nfloat get_cloud_transmission(vec2 uv, float time)\n{\n    vec3 ro = vec3(0,3.5,0);\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    // sky\n    float h = max(1.-rd.y, 0.);\n        \n    float lower_height = 50.;\n    float upper_height = 65.;\n    \n    // Sky: y > 100.\n    // solve (rd * t + ro).y = 100.\n    float t0 = (lower_height-ro.y)/rd.y;\n    float t1 = (upper_height-ro.y)/rd.y;\n    \n    float total_transmission = 1.;\n    \n    if(t0 > 0.)\n    {\n        //float cloud_alpha = pow(texture(iChannel1, .0125*p.xz).rgb, vec3(.125*.125)).r;\n        //cloud_alpha = mix(cloud_alpha, 1., fbm( .25*p.xz, 8. )*(exp(-t*.0006)));\n        \n        float h = max(1.-rd.y, 0.);\n        \n        #if 0\n        color = vec3( pow(h, 4.) * .65, pow(h, 2.5), pow(h, 1.) );\n        #endif\n          \n        float current_transmission = 1.;\n        \n        vec3 start_pos = t0 * rd + ro;\n        vec3 end_pos = t1 * rd + ro;\n        float total_length = t1-t0;\n        float step_length = total_length / num_cloud_integration_steps;\n        \n        float march_step = (upper_height - lower_height) / num_cloud_integration_steps;\n                        \n        float absorption_coefficient = 1.01;\n        \n        for(float i = 0.; i < num_cloud_integration_steps; i++)\n        {\n            float height_percentage = i / (num_cloud_integration_steps-1.);\n            float step_height = (upper_height - lower_height) / num_cloud_integration_steps;\n            \n            vec3 sample_position = (t0 + total_length * height_percentage) * rd + ro;\n            \n            float density = sample_density( sample_position / 200. + time * vec3(0.1,0.02, 0.2)*-.15);\n            current_transmission *= exp(-absorption_coefficient * density * march_step);\n                        \n            if(current_transmission < 0.01) break;\n            if (length(sample_position) > 5e3) break;\n        }\n        total_transmission = current_transmission;\n    }\n    return total_transmission;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Physics and whatnot\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ivec2(fragCoord).y != 0 || ivec2(fragCoord).x > 1) return;\n\n    vec2 pos = ball_init_pos;\n    vec2 vel = vec2(0);\n    \n    float rotation = 0.;\n\n    if(iFrame == 0)\n    {\n        fragColor = vec4(pos, vel);\n        return;\n    }\n\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy)/iResolution.y;\n\n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    pos = bufA.xy;\n    vel = bufA.zw;\n\n    vec2 peg_pos = get_peg_pos(mouse, iMouse.xy, iTime);\n\n    vec2 normal = normalize(pos-peg_pos);\n\n    float proj_vel = dot(vel, normal);\n    vec2 rej_vel  = vel - dot(vel, normal) * normal;\n\n    float penetration = length(pos-peg_pos) - radius - peg_radius;\n    if(penetration < 0.)\n    {\n        pos += (pos-peg_pos) / length(pos - peg_pos) * (-penetration);\n        vel = max(proj_vel, 0.) * normal + rej_vel;\n    }\n    \n    vec2 force = 0.075 * smoothstep(radius+peg_radius + 0.0001, radius+peg_radius, length(pos-peg_pos)) * ((pos-peg_pos) / length(pos-peg_pos));\n    \n    float gravity = 0.0025;\n    \n    force.y -= gravity;\n    \n    vec2 accel = force;\n    \n    #if USE_MANUAL_DELTATIME\n    vel += accel * (60./TARGET_FPS);\n    pos += 0.5*vel * (60./TARGET_FPS);\n    #else\n    vel += accel * 60. * iTimeDelta;\n    pos += 0.5*vel * 60. * iTimeDelta;\n    #endif\n    \n    penetration = length(pos-peg_pos) - radius - peg_radius;\n    if(penetration <= 0.)\n    {\n        pos += (pos-peg_pos) / length(pos - peg_pos) * (-penetration);\n        vel = max(proj_vel, 0.) * normal + rej_vel;\n    }\n    \n    if(pos.y < -10.) { pos = ball_init_pos; vel = vec2(0); }\n    \n    if(ivec2(fragCoord).x == 0)\n        fragColor = vec4(pos, vel);\n    else\n        fragColor = vec4(rotation, 0, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Render ocean and stuff and things and whatnot\n\n// hash\n\n// (value-) noise\n\n// generate heightmap\n// - single wave octaves: distort uvs with noise, create waves with 1.-abs(cos()) \n// - layer octaves\n\n// Ray trace:\n// interval search\n// find normal\n\n// Optical depth has to be approximately inversely proportional to height,\n// since the thin peaks are at the top\n// and adjusted for viewing direction by reducing depth at glancing angles,\n// and increasing towards a more vertical viewing direction.\n\nfloat noise(vec2 uv)\n{\n    return 2.*texture(iChannel0, uv/256.).r-1.;\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat value_noise(vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = smoothstep(0., 1., f);\n    return 2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y) - 1.;\n}\n\nfloat field_octave(vec2 uv, float sharpness)\n{\n    vec2 wave_ax = pow(abs(cos(uv+value_noise(uv))), vec2(1.625)); // 1.625 =  2.5*0.65\n    return pow(1.0-wave_ax.x*wave_ax.y, sharpness);\n}\n\n#if 0\nfloat map(vec3 p)\n{\n    float height = cos(p.x+iTime)*.6;\n    \n    height *= cos(p.z+iTime)*.4-0.5;\n    \n    height = field_octave(p.xz, 4.)-0.5;\n\n    return p.y - height;\n}\n#else\n#define SEA_TIME (1.0 + iTime * 0.8)\nfloat map(vec3 p) {\n    float freq = 0.16;\n    float amp = 0.6;\n    float choppy = 6.;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float time = 1. + iTime * 0.8;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < 5; i++) {        \n        \n    \td = field_octave((uv+time)*freq,choppy)*.5;\n    \td += field_octave((uv-time)*freq,choppy)*.5;\n        d += cos(p.z - iTime)*.4;\n        h += d * amp * tanh(abs(p.z)*0.5);        \n    \tuv *= mat2(1.6,1.2,-1.2,1.6);\n        freq *= 1.9; \n        amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n#endif\n\n\nvec3 get_normal(vec3 p)\n{\n    float eps = 1e-3;\n    vec3 dx = vec3(1,0,0) * eps;\n    vec3 dz = vec3(0,0,1) * eps;\n    float h  = map(p);\n    float dhdx = h-map(p+dx);\n    float dhdz = h-map(p+dz);\n    return normalize(cross(vec3(0,dhdz,eps), vec3(eps,dhdx,0)));\n}\n\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.14159265 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    const vec3 SEA_BASE = vec3(0.0,0.09,0.18);\n    const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n    float fresnel = smoothstep(0., 1., 1.0 - dot(n, -eye));\n    fresnel = tanh(3./1.*fresnel * fresnel* fresnel)*.5;\n    \n    vec3 reflected = getSkyColor(reflect(eye, n));    \n    vec3 refracted = SEA_BASE + pow(dot(n,l) * 0.4 + 0.6,80.) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - 0.6) * 0.18 * atten;\n    \n    color += specular(n, l, eye, 60.0);\n    \n    return color;\n}\n\nvec3 get_shading(vec3 p, vec3 rd, vec3 n, vec3 l, float t)\n{\n    return getSeaColor(p, n, l, rd, vec3(t,0,0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec4 bufD = texture(iChannel1, fragCoord.xy/iResolution.xy);\n\n    vec3 color = bufD.rgb;\n        \n    vec3 ro = vec3(0,3.5,0);\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    float t_min = ( 2.-ro.y)/rd.y;\n    float t_max = (-1.-ro.y)/rd.y;\n    float t = t_min;\n    float t2 = bufD.a;\n    \n    bool sand = false;\n    \n    if(t > 0.)\n    {   \n        float h_min = map(rd * t_min + ro);\n        float h_max = map(rd * t_max + ro);\n        \n        for(int i = 0; i < 32; i++)\n        {\n            t = mix(t_min, t_max, (0.-h_min)/(h_max - h_min));\n\n            vec3 p = rd * t + ro;\n            float h_p = map(p);   // height of p over surface ( in y-direction )\n            \n            float fwd = step(h_p, 0.);\n            t_max = mix(t_max, t, fwd);\n            t_min = mix(t, t_min, fwd);\n            \n            h_max = mix(h_max, h_p, fwd);\n            h_min = mix(h_p, h_min, fwd);\n\n            if(abs(h_p) < 1e-3 \n            || abs(h_max-h_min) < 1e-3 || abs(t_max-t_min) < 1e-3\n            )\n            {\n                t = mix(t_min, t_max, (0.-h_min) / (h_max - h_min));\n                break;\n            }\n        }\n    }\n    \n    if(t_min > 0.)\n    {\n        float water_depth = max(t2 - t, 0.);\n        t = t2 > 0.? min(t2, t) : t;\n        vec3 p = rd * t + ro;\n        vec3 N = get_normal(p);\n        vec3 L = normalize(vec3(.525,1,-1));\n        \n        color = \n            mix(\n                color,\n                get_shading(p, rd, N, L, t),\n                (1.-exp(-.2*water_depth))\n                );\n    }\n    \n    #if CLOUDS\n    if(ivec2(fragCoord) == ivec2(0,0))\n        fragColor = vec4(color, get_cloud_transmission(vec2(1), iTime));\n    else\n    #endif\n        fragColor = vec4(color, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Some game logic and score and whatnot\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > 2. || fragCoord.y > 1.) return;\n    \n    vec4 bufC = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    if(ivec2(fragCoord) == ivec2(1,0)) // Detect resolution change\n    {\n        float current_resolution = iResolution.x;\n        float previous_resolution = bufC.g;\n        float resolution_changed = float(current_resolution != previous_resolution);\n        fragColor = vec4(resolution_changed, current_resolution, 0., 0.);\n        return;\n    }\n    \n    vec4 ballstate = texelFetch(iChannel0, ivec2(0), 0);\n    \n    vec4 gamestate = bufC;\n    \n    if(ivec2(fragCoord) == ivec2(0))\n    {\n        float points = bufC.r;\n        float prev_ball_dir = bufC.g;\n        float time_of_fail = bufC.b;\n        float time_of_prev_point = bufC.a;\n\n        vec2 ball_pos = ballstate.xy;\n        vec2 ball_vel = ballstate.zw;\n\n        if(prev_ball_dir <= 0. && ball_vel.y > 0.)\n        {\n            if(time_of_prev_point != iTime) points++;\n            time_of_prev_point = iTime;\n        }\n\n        prev_ball_dir = ball_vel.y;\n\n        if(ball_pos.y < -1.) \n        {\n            points *= 0.; // hey, don't change this, you cheater! I SEE you!\n            time_of_fail = iTime;\n        }\n\n        gamestate = vec4(points, prev_ball_dir, time_of_fail, time_of_prev_point);\n    }\n\n    fragColor = gamestate;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Render sand and stuff and things and whatnot\n\nfloat noise(vec2 uv)\n{\n    return 2.*texture(iChannel0, uv/256.).r-1.;\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat value_noise(vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = smoothstep(0., 1., f);\n    return 2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y) - 1.;\n}\n\nfloat field_octave(vec2 uv, float sharpness)\n{\n    vec2 wave_ax = pow(abs(cos(uv+value_noise(uv))), vec2(1.625)); // 1.625 =  2.5*0.65\n    return pow(1.0-wave_ax.x*wave_ax.y, sharpness);\n}\n\nfloat map_beach(vec3 p) {\n    float freq = 0.16;\n    float amp = 0.6;\n    float choppy = 6.;\n    vec2 uv = p.xz; uv.x *= 0.75;\n        \n    float d, h = 0.0;    \n    for(int i = 0; i < 5; i++) {        \n        \n    \td = field_octave((uv)*freq,choppy);\n    \td += field_octave((uv)*freq,choppy);\n        h += d * amp;        \n    \tuv *= mat2(1.6,1.2,-1.2,1.6);\n        freq *= 1.9; \n        amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);    \n    }\n    \n    #if 0\n    float surface_height = p.y - 2.*h/abs(p.z) - p.z*.2-2.;\n    #else\n    float surface_height = p.y - 2.*h/max(abs(p.z),2.) - max(p.z*.2 + 2., -2.);\n    #endif\n    return surface_height;\n}\n\nvec3 get_sand_normal(vec3 p)\n{\n    float eps = 1e-3;\n    vec3 dx = vec3(1,0,0) * eps;\n    vec3 dz = vec3(0,0,1) * eps;\n    float h  = map_beach(p);\n    float dhdx = h-map_beach(p+dx);\n    float dhdz = h-map_beach(p+dz);\n    return normalize(cross(vec3(0,dhdz,eps), vec3(eps,dhdx,0)));\n}\n\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.14159265 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    const vec3 SEA_BASE = vec3(0.0,0.09,0.18);\n    const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n    float fresnel = smoothstep(0., 1., 1.0 - dot(n, -eye));\n    fresnel = tanh(3./1.*fresnel * fresnel* fresnel)*.5;\n    \n    vec3 reflected = getSkyColor(reflect(eye, n));    \n    vec3 refracted = SEA_BASE + pow(dot(n,l) * 0.4 + 0.6,80.) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - 0.6) * 0.18 * atten;\n    \n    color += specular(n, l, eye, 60.0);\n    \n    return color;\n}\n\n// This has no right to work as 'well' as it does, heh.\nvec3 getSandColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) \n{\n    return \n        (smoothstep(-1., 1.25, p.y)*.4+.6) * \n        max(1. -(getSeaColor(p, normalize(n + texture(iChannel0, p.xz).rgb*vec3(1,0,1)*.07) , l*-1. , eye, dist)), 0.);\n}\n\nvec3 get_shading(vec3 p, vec3 rd, vec3 n, vec3 l, float t)\n{\n    return getSandColor(p, n, l, rd, vec3(t,0,0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Check if first frame or resolution changed.\n    // if so, then we must recompute the buffer, \n    // otherwise just use previous result\n    if(iFrame > 0 && texelFetch(iChannel1, ivec2(1,0), 0).r < .5) \n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    vec3 ro = vec3(0,3.5,0);\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    //rd = axisangle(vec3(1,0,0), mouse.y-PI/8., rd);\n    //rd = axisangle(vec3(0,1,0), mouse.x-PI/8., rd);\n    \n    fragColor = vec4(0,0,0, 1e6);\n    \n    float t_min = ( 3.-ro.y)/rd.y;\n    float t_max = ( -2.-ro.y)/rd.y;\n    float h_min = map_beach(rd * t_min + ro);\n    float h_max = map_beach(rd * t_max + ro);\n\n    float t2 = t_min;\n    \n    if(t2 > 0.)\n    {   \n        for(int i = 0; i < 32; i++)\n        {\n            t2 = mix(t_min, t_max, (0.-h_min)/(h_max - h_min));\n\n            vec3 p = rd * t2 + ro;\n            float h_p = map_beach(p);   // height of p over surface ( in y-direction )\n            \n            float fwd = step(h_p, 0.);\n            t_max = mix(t_max, t2, fwd);\n            t_min = mix(t2, t_min, fwd);\n            \n            h_max = mix(h_max, h_p, fwd);\n            h_min = mix(h_p, h_min, fwd);\n\n            if(abs(h_p) < 1e-3 \n            || abs(h_max-h_min) < 1e-3 || abs(t_max-t_min) < 1e-3\n            )\n            {\n                t2 = mix(t_min, t_max, (0.-h_min) / (h_max - h_min));\n                break;\n            }\n        }\n    }\n    \n    if(t_min > 0.)\n    {\n        vec3 p = rd * t2 + ro;\n        vec3 N = get_sand_normal(p);\n        vec3 L = normalize(vec3(.525,1,-1));\n        vec3 SandColor = get_shading(p, rd, N, L, t2);\n        color = SandColor;\n    }\n    else\n    {\n        color = getSkyColor(rd);\n    }\n    \n    fragColor = vec4(color, t2);\n}","name":"Buffer D","description":"","type":"buffer"}]}