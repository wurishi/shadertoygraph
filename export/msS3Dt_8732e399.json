{"ver":"0.1","info":{"id":"msS3Dt","date":"1668491278","viewed":495,"name":"Recursive Raytracer (no diffuse)","username":"Poisson","description":"Real time! Rendered with raymarching, fake ground reflections. For the glass, I used an elongated torus.","likes":43,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","reflection","raytracer","ray","refraction","dof","raymarcher","glass","path","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//█▀█ █▀▀ ▄▀█ █░░   ▀█▀ █ █▀▄▀█ █▀▀ █\n//█▀▄ ██▄ █▀█ █▄▄   ░█░ █ █░▀░█ ██▄ ▄\n\n\n// depth of field function, thanks to iq\nvec4 dof(sampler2D sam, vec2 p) {\n    const float focus = 3.5;\n    vec4 col = vec4(0);\n    \n    for(int i=-5; i<=5; i++) {\n    for(int j=-5; j<=5; j++) {\n        vec2 of = vec2(i,j);\n        vec4 tmp = texture(iChannel0, p+of*.002); \n        float depth = tmp.w;\n        vec3 color = tmp.xyz;\n        float coc = 8.*abs(depth-focus)/depth;\n        if(dot(of,of) < coc*coc) {\n            float w = 1./(coc*coc); \n            col += vec4(color*w,w);\n        }\n    }\n    }\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec3 col = dof(iChannel0, p).rgb;\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    col = vec3(1)*dot(col,vec3(1))/3.; // rgb to greyscale\n    col = col*2.-.5; // contrast\n    col = clamp(col, 0., 1.);\n    col = pow(col,vec3(.95,1.,.9)); // color curve\n    \n    col = clamp(col,0.,1.);\n    // vignette\n    col *= clamp(pow(64. * p.x*p.y*(1.-p.x)*(1.-p.y), .1), 0., 1.);    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_RECURSION 8 // max ray bounces\n#define REFRACTION_IDX 1.5 // index of refraction\n\n// 0 - wine glass\n// 1 - cocktail glass\n\nconst int GLASS_LOOK = 0;\n\n// materials idx\n#define MAT_WOOD 0.\n#define MAT_GLASS 1.\n#define MAT_METAL 2.\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// box sdf\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z)));\n}\n\n// torus sdf\nfloat sdTorus(vec3 p, float ra, float rb) {\n    return length(vec2(length(p.xz)-ra,p.y))-rb;\n}\n\n// smoothstep but not smooth\nfloat mstep(float a, float b, float x) {\n    return clamp((x-a)/(b-a),0.,1.);\n}\n\n// glass curve\n// https://www.desmos.com/calculator/jfyacmb6pr\nfloat func(float x) {\n    if (GLASS_LOOK==0)\n        return .3*smoothstep(.95,1.,x)+.35*smoothstep(.56,.4,x)*smoothstep(-1.3,.4,x);\n    else\n        return .25*smoothstep(.95,1.,x)+.45*mstep(.45,.0,x);\n}\n\n// glass sdf\nfloat sdGlass(vec3 p) {\n    p.y -= 1.;\n    float h = clamp(-p.y*.6779661017, 0., 1.);\n    return sdTorus(p + vec3(0,1.475,0)*h, func(h), .025);\n}\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// scene\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10);\n    \n    d = opU(d, vec2(p.y+.5+.001*sin(6.*p.x)*sin(6.*p.z), MAT_WOOD)); // plane\n\n    // glass\n    vec3 q = p;\n    q.x = fract(q.x+.5)-.5; // repetition on the x axis\n    float glass = sdGlass(q)*.5;\n    d = opU(d, vec2(glass, MAT_GLASS));\n\n    // metal cubes\n    p.xz = abs(p.xz);\n    d = opU(d, vec2(sdBox(p-vec3(.6,-.3,.6), vec3(.16))-.04, MAT_METAL));\n            \n    return d;\n}\n\n// raymarching loop\n// returns the distance and the material idx\nvec2 intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float s = sign(map(ro).x); // inside and outside the surface\n    \n    for (int i=0; i<256 && t<16.; i++) {\n        vec3 p = ro + rd*t;\n        vec2 h = map(p);\n        h.x *= s;\n        if (abs(h.x)<.0001*t) return vec2(t,h.y);\n        t += h.x;\n    }\n    return vec2(t,-1);\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// ambient occlusion\nfloat calcAO(vec3 p, vec3 n, float k) {\n    float res = clamp(.5+.5*map(p+n*k).x/k,0.,1.);\n    return res;\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=.01; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p).x*2.;\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res);\n}\n\n// sky texture\nvec3 skyTex(vec3 rd) {\n    vec3 col = pow(texture(iChannel1, rd).rgb,vec3(2.));\n    return col+2.*pow(col,vec3(3.));\n}\n\n// ground texture\nvec3 groundTex(vec3 p) {\n    return pow(texture(iChannel0, p.xz*.5).rgb,vec3(2.2));\n}\n\n// wood lighting and color function\nvec3 woodLighting(vec3 p, vec3 n, vec3 rd) {\n    vec3 r = reflect(rd, n); // reflected vector\n    \n    float occ = .5+.5*calcAO(p, n, .1); // occulsion\n    occ = occ*occ*(3.-2.*occ);\n    float ref = shadow(p, r, 8., 24.); // reflection (specular)\n    \n    vec3 col = groundTex(p);\n    col += (.3+.7*skyTex(r))*.1*ref; // skybox reflection\n    col *= occ;\n        \n    return col;\n}\n\n// pathtracing function\nvec3 pathtrace(vec3 ro, vec3 rd, bool ref) {\n    vec3 col = vec3(1);\n    \n    for (int i=0; i<MAX_RECURSION; i++) { // ray bounces\n        vec2 tmat = intersect(ro, rd);\n        float t = tmat.x; // distance\n        float mat = tmat.y; // material\n        if (t<16.) {\n            vec3 p = ro + rd*t;\n            vec3 n = calcNormal(p);\n\n            if (mat==MAT_GLASS) {\n                if (ref) {\n                    ro = p+n*.005;\n                    rd = reflect(rd, n);\n                } else {\n                    // refraction\n                    float fre = dot(rd, n);\n                    float s = sign(fre);\n                    vec3 m = -n*s;\n                    float ior = REFRACTION_IDX;\n                    float v = (.5-.5*s)/ior+ior*(.5+.5*s);\n\n                    ro = p-m*.005;\n                    rd = refract(rd, m, v);\n                }\n            } else if (mat==MAT_WOOD) {\n                col *= woodLighting(p, n, rd);\n                return col;\n            } else if (mat==MAT_METAL){\n                // reflection\n                ro = p+n*.005;\n                rd = reflect(rd, n);\n            }\n        } else {\n            break;\n        }\n    }\n    \n    return col*skyTex(rd);\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = skyTex(rd);\n    \n    vec2 tmat = intersect(ro, rd);\n    float t = tmat.x; // distance\n    float mat = tmat.y; // material\n    if (t<16.) {\n        vec3 p = ro + rd*t;\n        vec3 n = calcNormal(p);\n        vec3 r = reflect(rd, n); // reflected ray\n        \n        // lighting and coloring\n        \n        vec3 refl = pathtrace(ro, rd, true); // reflected color\n        vec3 refr = pathtrace(ro, rd, false); // refracted color\n        \n        // ambient occlusion\n        float occ = .4+.6*calcAO(p, n, .1);\n        occ = occ*occ*(3.-2.*occ);\n        \n        if (mat==MAT_WOOD) {\n            col = woodLighting(p, n, rd);\n        } else if (mat==MAT_GLASS) {\n            // schlick aproximation\n            float fre = 1.+dot(rd, n);\n            float r0 = (1.-REFRACTION_IDX)/(1.+REFRACTION_IDX);\n            r0 = r0*r0;\n            float schlick = r0 + (1.-r0)*pow(fre, 5.);\n            col = mix(refr, refl, schlick); // blending the reflected ray with the refracted ray\n        } else if (mat==MAT_METAL){\n            col = refr;\n            col *= occ;\n        }\n    }\n    \n    return col;\n}\n\n// camera matrix\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0,.2,-3.5); // ray origin\n    ro.xz *= rot(-.2*iTime+3.141592*m.x-.7); // ray origin rotation\n    vec3 ta = vec3(0,.3,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.6)); // ray direction\n\n    vec3 col = render(ro, rd);\n    float t = intersect(ro, rd).x; // distance to the scene (for the dof)\n\n    // output\n    fragColor = vec4(col,t);\n}","name":"Buffer A","description":"","type":"buffer"}]}