{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Output visualizes 16xSGSSAA with a Lanzcos-like linear adaptive filter\n// Pattern and motion is to simulate worst case content\n\n// Amount of nearest zoom on output\n//  0 ... none\n//  1 ... 1:2x2\n//  2 ... 1:4x4\n#define ZOOM 1\n\n\n\n\n// This renders an image in Buffer A\n// With special layout {RGBA} are 4 monochrome samples\n// Groups of 2x2 pixels provides the 16xMSAA pattern (super-sampled)\n\n\n// CALLBACKS\nH4 ResF(I2 p){return texelFetch(iChannel0,ivec2(p),0);}\n\n\n\n//|||||||||||||||||||||||||||||||||||||..|||||||||||||||||||||||||||||||||||||||\n//=====================================||=======================================\n//                            [RES] CUSTOM RESOLVE\n//-------------------------------------::---------------------------------------\n// SOURCE IMAGE LAYOUT\n// ===================\n// Source image is {2xWidth,2xHeight} as final output (4x area)\n// Source image is FP16x4 (likely not a bottleneck) and linear\n// Output is monochome, each 'RGBA' provides 4 monochrome samples\n// Groups of 2x2 pixels provide 16 total samples in the 16xMSAA pattern\n// Generally in this pattern spatially \n//  RG\n//  BA \n// ===================\n//     - - - - - - - -\n//     8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7\n// -8  . R . . . . . . , , , , , , , ,\n// -7  . . . . . . . . R , , , , , , ,\n// -6  . . . . G . . . , , , , , , , ,\n// -5  . . . . . . . . , , , G , , , ,\n// -4  . . . . . . . . , , , , , , , A\n// -3  . . . . . . . A , , , , , , , ,\n// -2  . . . B . . . . , , , , , , , ,\n// -1  . . . . . . . . , , , , B , , ,\n//  0  R , , , , , , , . . . . . . . .\n//  1  , , , , , , , , . R . . . . . .\n//  2  , , , , , G , , . . . . . . . .\n//  3  , , , , , , , , . . . . . G . .\n//  4  , , B , , , , , . . . . . . . . \n//  5  , , , , , , , , . . B . . . . .\n//  6  , , , , , , A , . . . . . . . . \n//  7  , , , , , , , , . . . . . . A .\n//-------------------------------------::---------------------------------------\n// ONE MASSIVE KERNEL\n// ==================\n// A 2D jinc scaling for lanczos requires 2.0*1.2196699 radius (quite large)\n// ------------------\n// Each 'x' is a group of 4 samples (takes 2x2 to make an output pixel)\n// Total fetch count is 100-12 = 88 fetches * 4 samples = 352 samples!\n// ==================\n// A B C D E F G H I J <--- working in 10x1 groups to keep this simple\n// - - - - - - - - - -\n// . . x x x x x x . .\n// . x x x x x x x x .\n// x x x x x x x x x x\n// x x x x x x x x x x\n// x x x x x x x x x x\n// x x x x x x x x x x\n// x x x x x x x x x x\n// x x x x x x x x x x\n// . x x x x x x x x .\n// . . x x x x x x . .\n// ==================\n// . . 0 1 0 1 0 1 . .\n// . 3 2 3 2 3 2 3 2 .\n// 0 1 0 1 0 1 0 1 0 1\n// 2 3 2 3 2 3 2 3 2 3\n// 0 1 0 1 0 1 0 1 0 1 <--- sample permutations\n// 2 3 2 3 2 3 2 3 2 3\n// 0 1 0 1 0 1 0 1 0 1\n// 2 3 2 3 2 3 2 3 2 3\n// . 1 0 1 0 1 0 1 0 .\n// . . 2 3 2 3 2 3 . .\n//-------------------------------------::---------------------------------------\n// PRECISION ISSUES\n// ================\n// Designed for samples to get loaded at FP16 to save on register file\n// This is also done in batches\n// Too many samples to use FP16 for accumulation\n// So this is designed for V_DOT2_F32_F16 ops with a V_FMA_MIX_F32 fallback\n//-------------------------------------::---------------------------------------\n// SAMPLING\n// ========\n// TexelFetchLod (without offset)\n// NSA is faster since offsets on AMD are not in the opcode\n// For platforms which this doesn't hold, a compiler could optimize to offsets\n//=====================================||=======================================\n // Work with a group of 4 samples [10ops] if V_DOT2_F32_F16, else [20ops] \n // The {pX,pY} coords are compile time immediates\n // All filter coef are computed from compile time immediates (factored out)\n void ResG(inout F4 f,inout H2 xny,H4 s,F4 pX,F4 pY){\n  // Update {max,-min} [4ops]\n  // A good compiler should be able to move these around to avoid ALU latency\n  xny=VMaxH2(xny,H2(s.r,-s.r));\n  xny=VMaxH2(xny,H2(s.g,-s.g));\n  xny=VMaxH2(xny,H2(s.b,-s.b));\n  xny=VMaxH2(xny,H2(s.a,-s.a));\n//-------------------------------------::---------------------------------------\n  // Using the fast approximate lanzcos2\n  // These are all compile time immediates (no shader math) [0ops]\n  // Set to almost have no negative lobe (perceptually none)\n  // Could go to 16 to be safer (and 10 didn't work)\n  F1 p0=F1(12.0);\n  // Set to the maximum amount of sharpening\n  // This is set a little less than the real lanzcos2\n  // Don't need as much because this is linear\n  F1 p1=F1( 5.0);\n  F1 k1=1.0/(pow(4.0/3.0,p1)-1.0);\n  F1 k0=1.0/(pow(4.0/3.0,p0)-1.0);\n  F4 r=F4(1.0)-VSatF1(pX*pX+pY*pY);\n  H4 w1=F4(((1.0+k1)*pow(r,H4(p1))-k1)*r*r);\n  H4 w0=F4(((1.0+k0)*pow(r,H4(p0))-k0)*r*r);\n//-------------------------------------::---------------------------------------\n  // Accumulate the crap [6ops] assuming V_DOT2_F32_F16 ops else [16ops]\n  // Letting the compile move around to avoid ALU latency\n  f.x=VDot2F1H2(s.rg,w0.rg,f.x);\n  f.x=VDot2F1H2(s.ba,w0.ba,f.x);\n  f.y=VAddF1(f.y,F1(w0.r+w0.g+w0.b+w0.a));\n  f.z=VDot2F1H2(s.rg,w1.rg,f.z);\n  f.z=VDot2F1H2(s.ba,w1.ba,f.z);\n  f.w=VAddF1(f.w,F1(w1.r+w1.g+w1.b+w1.a));}\n//=====================================||=======================================\n // SCALE MAPPING\n // =============\n // jinc = 1.2196699\n // 2 pixel * jinc : 1\n // Pixel is 16 units in coordinates, so conversion is a scale by\n #define RES_SCALE (1.0/(32.0*1.2196699))\n//-------------------------------------::---------------------------------------\n // Source pixel permutations\n //  01\n //  23\n // The 'p' is the base coordinate in units of 16 per one 16xMSAA pattern\n void ResG0(inout F4 f,inout H2 xny,H4 s,F2 p){\n  F4 pX=F4(-7,-4,-5,-1);\n  F4 pY=F4(-8,-6,-2,-3);\n  pX=(pX+F4(p.x))*F4(RES_SCALE);\n  pY=(pY+F4(p.y))*F4(RES_SCALE);\n  ResG(f,xny,s,pX,pY);}\n//-------------------------------------::---------------------------------------\n void ResG1(inout F4 f,inout H2 xny,H4 s,F2 p){\n  F4 pX=F4(0,3,4,7);\n  F4 pY=F4(-7,-5,-1,-4);\n  pX=(pX+F4(p.x))*F4(RES_SCALE);\n  pY=(pY+F4(p.y))*F4(RES_SCALE);\n  ResG(f,xny,s,pX,pY);}\n//-------------------------------------::---------------------------------------\n void ResG2(inout F4 f,inout H2 xny,H4 s,F2 p){\n  F4 pX=F4(-8,-3,-6,-2);\n  F4 pY=F4(0,2,4,6);\n  pX=(pX+F4(p.x))*F4(RES_SCALE);\n  pY=(pY+F4(p.y))*F4(RES_SCALE);\n  ResG(f,xny,s,pX,pY);}\n//-------------------------------------::---------------------------------------\n void ResG3(inout F4 f,inout H2 xny,H4 s,F2 p){\n  F4 pX=F4(1,5,2,6);\n  F4 pY=F4(1,3,5,7);\n  pX=(pX+F4(p.x))*F4(RES_SCALE);\n  pY=(pY+F4(p.y))*F4(RES_SCALE);\n  ResG(f,xny,s,pX,pY);}\n//=====================================||=======================================\n // Filter entry\n F1 Res(I2 p){\n//-------------------------------------::---------------------------------------\n  // VGPR STATE\n  // ==========\n  //  1 ... pY\n  // 10 ... pX*\n  //  4 ... f\n  //  1 ... xny\n  // 20 ... 10x1 loads into packed FP16\n//-------------------------------------::---------------------------------------\n  // Generate all coords for NSA\n  // Keeping the X coords around, the Y's get generated before use only\n  I1 pXA,pXB,pXC,pXD,pXE,pXF,pXG,pXH,pXI,pXJ;\n  // The 'E' is the {top,left} of the middle 2x2\n  // The 2*x is folded into a 3 operand add instruction [10ops]\n  pXA=VAdd3I1(p.x,p.x,I1_SI1(-4));\n  pXB=VAdd3I1(p.x,p.x,I1_SI1(-3));\n  pXC=VAdd3I1(p.x,p.x,I1_SI1(-2));\n  pXD=VAdd3I1(p.x,p.x,I1_SI1(-1));\n  pXF=VAdd3I1(p.x,p.x,I1_SI1( 1));\n  pXG=VAdd3I1(p.x,p.x,I1_SI1( 2));\n  pXH=VAdd3I1(p.x,p.x,I1_SI1( 3));\n  pXI=VAdd3I1(p.x,p.x,I1_SI1( 4));\n  pXJ=VAdd3I1(p.x,p.x,I1_SI1( 5));\n  pXE=VAddI1(p.x,p.x);\n//-------------------------------------::---------------------------------------\n  // Init filtering data [5ops] but maybe less of the shader optimizes\n  F4 f=F4(0); // Acc {filter 0 x=luma y=weight, filter 1 z=luma w=weight}\n  H2 xny=H2(0.0,-1.0); // {max,-min}\n//-------------------------------------::---------------------------------------\n  // Batches of 10x1\n  // [10ops] for Y generation\n  // [880ops] for filtering if V_DOT2 else [1760ops]\n  H4 iA,iB,iC,iD,iE,iF,iG,iH,iI,iJ;\n  I1 pY;\n  F1 yy;\n  // A B C D E F G H I J\n  // = = = = = = = = = =\n  // . . 0 1 0 1 0 1 . .\n  // . 3 2 3 2 3 2 3 2 .\n  // 0 1 0 1 0 1 0 1 0 1\n  // 2 3 2 3 2 3 2 3 2 3\n  // 0 1 0 1 0 1 0 1 0 1 <--- sample permutations\n  // 2 3 2 3 2 3 2 3 2 3\n  // 0 1 0 1 0 1 0 1 0 1\n  // 2 3 2 3 2 3 2 3 2 3\n  // . 1 0 1 0 1 0 1 0 .\n  // . . 2 3 2 3 2 3 . .\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAdd3I1(p.y,p.y,I1_SI1(-4));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  yy=-32.0;\n  ResG0(f,xny,iC,F2(-16,yy));\n  ResG1(f,xny,iD,F2(-16,yy));\n  ResG0(f,xny,iE,F2(  0,yy));\n  ResG0(f,xny,iF,F2(  0,yy));\n  ResG1(f,xny,iG,F2( 16,yy));\n  ResG0(f,xny,iH,F2( 16,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  yy=-32.0;\n  ResG3(f,xny,iB,F2(-32,yy));\n  ResG2(f,xny,iC,F2(-16,yy));\n  ResG3(f,xny,iD,F2(-16,yy));\n  ResG2(f,xny,iE,F2(  0,yy));\n  ResG3(f,xny,iF,F2(  0,yy));\n  ResG2(f,xny,iG,F2( 16,yy));\n  ResG3(f,xny,iH,F2( 16,yy));\n  ResG2(f,xny,iI,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iA=ResF(I2(pXA,pY));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  iJ=ResF(I2(pXJ,pY));\n  yy=-16.0;\n  ResG0(f,xny,iA,F2(-32,yy));\n  ResG1(f,xny,iB,F2(-32,yy));\n  ResG0(f,xny,iC,F2(-16,yy));\n  ResG1(f,xny,iD,F2(-16,yy));\n  ResG0(f,xny,iE,F2(  0,yy));\n  ResG1(f,xny,iF,F2(  0,yy));\n  ResG0(f,xny,iG,F2( 16,yy));\n  ResG1(f,xny,iH,F2( 16,yy));\n  ResG0(f,xny,iI,F2( 32,yy));\n  ResG1(f,xny,iJ,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iA=ResF(I2(pXA,pY));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  iJ=ResF(I2(pXJ,pY));\n  yy=-16.0;\n  ResG2(f,xny,iA,F2(-32,yy));\n  ResG3(f,xny,iB,F2(-32,yy));\n  ResG2(f,xny,iC,F2(-16,yy));\n  ResG3(f,xny,iD,F2(-16,yy));\n  ResG2(f,xny,iE,F2(  0,yy));\n  ResG3(f,xny,iF,F2(  0,yy));\n  ResG2(f,xny,iG,F2( 16,yy));\n  ResG3(f,xny,iH,F2( 16,yy));\n  ResG2(f,xny,iI,F2( 32,yy));\n  ResG3(f,xny,iJ,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iA=ResF(I2(pXA,pY));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  iJ=ResF(I2(pXJ,pY));\n  yy=0.0;\n  ResG0(f,xny,iA,F2(-32,yy));\n  ResG1(f,xny,iB,F2(-32,yy));\n  ResG0(f,xny,iC,F2(-16,yy));\n  ResG1(f,xny,iD,F2(-16,yy));\n  ResG0(f,xny,iE,F2(  0,yy));\n  ResG1(f,xny,iF,F2(  0,yy));\n  ResG0(f,xny,iG,F2( 16,yy));\n  ResG1(f,xny,iH,F2( 16,yy));\n  ResG0(f,xny,iI,F2( 32,yy));\n  ResG1(f,xny,iJ,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iA=ResF(I2(pXA,pY));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  iJ=ResF(I2(pXJ,pY));\n  yy=0.0;\n  ResG2(f,xny,iA,F2(-32,yy));\n  ResG3(f,xny,iB,F2(-32,yy));\n  ResG2(f,xny,iC,F2(-16,yy));\n  ResG3(f,xny,iD,F2(-16,yy));\n  ResG2(f,xny,iE,F2(  0,yy));\n  ResG3(f,xny,iF,F2(  0,yy));\n  ResG2(f,xny,iG,F2( 16,yy));\n  ResG3(f,xny,iH,F2( 16,yy));\n  ResG2(f,xny,iI,F2( 32,yy));\n  ResG3(f,xny,iJ,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iA=ResF(I2(pXA,pY));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  iJ=ResF(I2(pXJ,pY));\n  yy=16.0;\n  ResG0(f,xny,iA,F2(-32,yy));\n  ResG1(f,xny,iB,F2(-32,yy));\n  ResG0(f,xny,iC,F2(-16,yy));\n  ResG1(f,xny,iD,F2(-16,yy));\n  ResG0(f,xny,iE,F2(  0,yy));\n  ResG1(f,xny,iF,F2(  0,yy));\n  ResG0(f,xny,iG,F2( 16,yy));\n  ResG1(f,xny,iH,F2( 16,yy));\n  ResG0(f,xny,iI,F2( 32,yy));\n  ResG1(f,xny,iJ,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iA=ResF(I2(pXA,pY));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  iJ=ResF(I2(pXJ,pY));\n  yy=16.0;\n  ResG2(f,xny,iA,F2(-32,yy));\n  ResG3(f,xny,iB,F2(-32,yy));\n  ResG2(f,xny,iC,F2(-16,yy));\n  ResG3(f,xny,iD,F2(-16,yy));\n  ResG2(f,xny,iE,F2(  0,yy));\n  ResG3(f,xny,iF,F2(  0,yy));\n  ResG2(f,xny,iG,F2( 16,yy));\n  ResG3(f,xny,iH,F2( 16,yy));\n  ResG2(f,xny,iI,F2( 32,yy));\n  ResG3(f,xny,iJ,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iB=ResF(I2(pXB,pY));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  iI=ResF(I2(pXI,pY));\n  yy=32.0;\n  ResG1(f,xny,iB,F2(-32,yy));\n  ResG0(f,xny,iC,F2(-16,yy));\n  ResG1(f,xny,iD,F2(-16,yy));\n  ResG0(f,xny,iE,F2(  0,yy));\n  ResG1(f,xny,iF,F2(  0,yy));\n  ResG0(f,xny,iG,F2( 16,yy));\n  ResG1(f,xny,iH,F2( 16,yy));\n  ResG0(f,xny,iI,F2( 32,yy));\n//- - - - - - - - - - - - - - - - - - -::- - - - - - - - - - - - - - - - - - - -\n  pY=VAddI1(pY,I1(1));\n  iC=ResF(I2(pXC,pY));\n  iD=ResF(I2(pXD,pY));\n  iE=ResF(I2(pXE,pY));\n  iF=ResF(I2(pXF,pY));\n  iG=ResF(I2(pXG,pY));\n  iH=ResF(I2(pXH,pY));\n  yy=32.0;\n  ResG2(f,xny,iC,F2(-16,yy));\n  ResG3(f,xny,iD,F2(-16,yy));\n  ResG2(f,xny,iE,F2(  0,yy));\n  ResG3(f,xny,iF,F2(  0,yy));\n  ResG2(f,xny,iG,F2( 16,yy));\n  ResG3(f,xny,iH,F2( 16,yy));\n//-------------------------------------::---------------------------------------\n  // Normalize the two kernels [10ops]\n  // The 'c0' is the safe one without visible negative lobes\n  // Don't saturate the 'c1' it can clip\n  F1 c0=VSatF1(VMulF1(f.x,VRcpF1(f.y)));\n  F1 c1=       VMulF1(f.z,VRcpF1(f.w));\n//-------------------------------------::---------------------------------------\n  #if 0\n   // [DEBUG] See the filter without much negative lobe\n   return c0;\n  #endif\n//-------------------------------------::---------------------------------------\n  #if 0\n   // [DEBUG] See the filter with full negative lobe\n   return c1;\n  #endif\n//-------------------------------------::---------------------------------------\n  // Adaptively blend between the 2 filters [10ops]\n  //  c0=almost no negative lobe\n  //  c1=maximum negative lobe\n  // Minimum distance to signal end of local neighborhood\n  // Note the dark side has a multiplier 1/N which limits ringing\n  // This is because for linear it's the dark ring which is primary visible\n  F1 n=VMinF1(VMulF1(F1(1.0/16.0),-xny.y),VAddF1(1.0,-xny.x));\n  // Difference between two filters\n  F1 d=VAddF1(c1,-c0);\n  // Amount of safe blend {0:all c0, 1:all c1}\n  F1 a=VSatF1(VMulF1(n,VRcpF1(abs(d))));\n  // Blend\n  return VFmaF1(d,a,c0);}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Junky convert from linear to sRGB\nF1 Srgb(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n F2 fc=fragCoord;\n #if ZOOM==0\n  // Because it needs 2x2:1\n  if(fc.x>iResolution.x*0.5)fc.x-=iResolution.x*0.5;\n  if(fc.y>iResolution.y*0.5)fc.y-=iResolution.y*0.5;\n #endif\n #if 0\n  // [DEBUG] View input image\n  fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n #else\n  // Show filter\n  fragColor.x=Res(I2(fc)>>I2(ZOOM));\n  fragColor.x=Srgb(fragColor.x);\n  fragColor.yz=fragColor.xx;\n #endif\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"// JUNK to just create an image in the associated layout\n// Each RGBA is 4 luma values\n// There is separate offsets for each group of 2x2 pixels\n// A group of 2x2 pixels represents 16x AA for one real pixel\n\n// Return coodinates based on even/odd pixels\nvoid JunkCoord(out F2 p0,out F2 p1,out F2 p2,out F2 p3,P1 x,P1 y){\n // false,false\n  p0=F2(-7,-8)+F2( 4, 4);\n  p1=F2(-4,-6)+F2( 4, 4);\n  p2=F2(-5,-2)+F2( 4, 4);\n  p3=F2(-1,-3)+F2( 4, 4); \n if((x==true)&&(y==false)){\n  p0=F2( 0,-7)+F2(-4, 4);\n  p1=F2( 3,-5)+F2(-4, 4);\n  p2=F2( 4,-1)+F2(-4, 4);\n  p3=F2( 7,-4)+F2(-4, 4);}\n if((x==false)&&(y==true)){\n  p0=F2(-8, 0)+F2( 4,-4);\n  p1=F2(-3, 2)+F2( 4,-4);\n  p2=F2(-6, 4)+F2( 4,-4);\n  p3=F2(-2, 6)+F2(-4,-4);}\n if((x==false)&&(y==true)){\n  p0=F2( 1, 1)+F2(-4,-4);\n  p1=F2( 5, 3)+F2(-4,-4);\n  p2=F2( 2, 5)+F2(-4,-4);\n  p3=F2( 6, 7)+F2(-4,-4);}\n // Scale to be inside the 'pixel'\n p0*=F2(0.5/4.0);\n p1*=F2(0.5/4.0);\n p2*=F2(0.5/4.0);\n p3*=F2(0.5/4.0);}\n\n// Silly function to graph\nF1 JunkShade(F2 p){\n #if 1\n  // Scale...\n  p*=0.5;\n #endif\n p.xy+=sin(iTime)*2.0;\n F2 pp=F2(p.x+p.y/16.0,p.y+p.x/16.0);\n pp*=pp;\n F1 x=sin(pp.x/800.0)>0.0?0.5:0.0;\n F1 y=sin(pp.y/1000.0)>0.0?0.5:0.0;\n x+=y;\n #if 1\n  #if 0\n   // Make it 50% contrast and centered.\n   x=x*0.5+(1.0-0.5)*0.5;\n  #else\n   // Close to black.\n   x=x*0.75+(1.0/32.0);\n  #endif\n #endif\n return x;}\n \n// Entry\nvoid mainImage(out F4 fragColor,in F2 fragCoord){\n I2 p=I2(fragCoord);\n P1 pX=(p.x&1u)==1u;\n P1 pY=(p.y&1u)==1u;\n F2 p0,p1,p2,p3;\n JunkCoord(p0,p1,p2,p3,pX,pY);\n fragColor.r=JunkShade(fragCoord+p0);\n fragColor.g=JunkShade(fragCoord+p1);\n fragColor.b=JunkShade(fragCoord+p2);\n fragColor.a=JunkShade(fragCoord+p3);}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"// Types and crap needed to port to personal engine\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n#define SI1 int\n\n#define I1 uint\n#define I2 uvec2\n#define I3 uvec4\n#define I4 uvec4\n\n// No halfs\n#define H1 float\n#define H2 vec2\n#define H3 vec3\n#define H4 vec4\n\n#define P1 bool\n#define P2 bvec2\n\n// Ops\n#define VAddI1(a,b) ((a)+(b))\n#define VAdd3I1(a,b,c) ((a)+(b)+(c))\n#define VSubRevI1(a,b) ((b)-(a))\n#define VDot2F1H2(a,b,c) (F1(a.x)*F1(b.x)+F1(a.y)*F1(b.y)+c)\n#define VMulF1(a,b) ((a)*(b))\n#define VAddF1(a,b) ((a)+(b))\n#define VMaxH2(a,b) max(a,b)\n#define VMinF1(a,b) min(a,b)\n#define I1_SI1(a) I1(SI1(a))\n#define VFmaF1(a,b,c) ((a)*(b)+(c))\n#define VSatF1(a) clamp(a,F1(0.0),F1(1.0))\n#define VRcpF1(a) (F1(1.0)/(a))\n#define VClpF1(a,b,c) clamp(a,b,c)","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfVBWR","date":"1734053618","viewed":136,"name":"Lottes16x","username":"TimothyLottes","description":"Lottes16x","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["lottes16x"],"hasliked":0,"parentid":"","parentname":""}}