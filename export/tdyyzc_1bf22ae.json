{"ver":"0.1","info":{"id":"tdyyzc","date":"1603373096","viewed":434,"name":"uniform/Poisson distrib in grid","username":"FabriceNeyret2","description":"Generating large distrib of random points is costly at rendering, and problematic for infinite worlds.\nPer-cell generation with 1 (or N) point per cell doesn't give a Uniform distrib (i.e. Poissonian, in screen space).\nHere:Worley \"voronoÃ¯ guy\" solution.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","voronoi","worley","stars","tuto","pointdistribution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float DENS = 10.;                         // target average density per cell\n\n#define hash2(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define lcg(p)        toFloat( p = p * 1664525u + 1013904223u )\n#define toFloat(p)  ( float(p)  / float(0xffffffffu) )\n#define toUint(p)     uint( (p) * float(0xffffffffu) )\n\n// Poisson generator via Inverse transform sampling ( for small d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat Poisson(vec2 U, float d) {          // d = target average density\n    float x = 0., p = exp(-d), s = p;\n    uint r = toUint( hash2(U+.5).x );     // seed\n    \n    for( ; lcg(r) > s && x<50. ; ) \n        s += p *= d/++x; \n        \n    return x;\n}\n    \nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         M = length(iMouse.xy) < 10. ? vec2(0) : 2.*iMouse.xy/R-1.,\n         S = 4.*exp2(2.*M.x) / R.yy,\n         U = S * ( 2.*u - R ) - iTime,\n         I = floor(U), F = fract(U), P;\n    \n // O = vec4( 2.-R.y/8.*length(hash2(I)-F) ); return; // test: one single value per cell\n\n    float d = 1e5, i = 0.,\n           n = Poisson(I, DENS );         // number of dot per cell = Poisson law\n    for( ; i < n; i++ )                   // then, generates n Uniform dots in the cell\n        P = F - hash2(I+i/100.),\n        d = min(d, dot(P,P) );\n                         // dot size proportional if big or 1 pixel if small \n    O = vec4( max(0., 1. - min(R.y/8.,.5/S.x)* sqrt(d) ) );   // draw points \n    O.b += .2*mod(I.x+I.y,2.);            // show cells\n    O = sqrt(O);                          // to sRGB\n}","name":"Image","description":"","type":"image"}]}