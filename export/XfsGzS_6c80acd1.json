{"ver":"0.1","info":{"id":"XfsGzS","date":"1705267083","viewed":68,"name":"Colorful Star - Shwow","username":"Shwow","description":"Little Star background shader i developed for a Graphics programming class.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DRAW_BG\n\n#define TRAIL_LEN 8\n#define TRAIL_OFFSET .4\n\n#define STAR_COUNT 10\n#define STAR_SPEED 1.\n#define STAR_GLOW 1.\n\n#define HALOS\n#define HALO_GLOW 5.\n\n//optimization that, for each pixel, disregards stars farther away than CULLING_DISTANCE\n#define CULLING\n#define CULLING_DISTANCE 1.6\n\n//Precomputes the sdf variables. Has no noticeable effect.\n#define PRECOMPUTE\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    #ifdef PRECOMPUTE\n    float an = 0.62831853071;\n    float en = 1.16355283466;\n    vec2 acs = vec2( 0.80901699438 , 0.58778525228);\n    vec2 ecs = vec2( 0.39607976604, 0.91821610687);\n    #else\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n    #endif\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nmat2 rotMat(float anglei){\n    return mat2( cos(anglei), -sin(anglei),\n                 sin(anglei), cos(anglei));\n}\n\n//Similar to smoothstep, but linear\nfloat linearStep(float edge0, float edge1, float x)\n{\n    return  clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\n//smoothly transitions only from drop to zero\nfloat falloff(float d, float zero, float drop){\n    if (d < drop) d = smoothstep(zero, drop, d) * drop;\n    return d;\n}\n\n//horizontal scrolling and vertical bobbing calculation for stars\nvec2 moveStar(vec2 uv, float t){\n    \n    vec2 p = uv + vec2(-t * .6,cos(t*2.)*.15);\n    return vec2(mod(p.x, 3.7)-1.85,mod(p.y+1., 2.)-1.);\n}\n\n//Star code\nvec3 drawStar(vec2 uv, float t, float size, float tx, float to, vec3 starColor){\n    \n    //time offset calculation\n    t = (t + to) * tx;\n    \n    #ifdef CULLING\n    //Culling by distance to star center\n    vec2 pos0 = moveStar(uv, t);\n    float tn = t - (TRAIL_OFFSET * size * float(TRAIL_LEN - 1));\n    vec2 posn = moveStar(uv, tn);\n    if( min(length(pos0),length(posn)) > CULLING_DISTANCE * size) return vec3(0.);\n    #endif\n\n    float totalD;\n    float opacity = 1.;\n\n    for( int i = 0; i < TRAIL_LEN; ++i){\n        //calculates position & rotation of star\n        vec2 pos = moveStar(uv, t);\n        vec2 uvs = (pos) * rotMat( sin(-t*2.) * .23);\n\n        //Main star sdf calculation\n        float d = sdStar( uvs, .4 * size, int(5), 2.7 );\n        d -= .07 * size;\n        d = pow(.06 * size/abs(d),0.17 / pow(size, 2.));\n\n        //tonemapping trailing stars\n        if(i != 0){\n        d = 1.0 - exp( -d );\n        }\n        #ifdef HALOS\n        else{\n            //origin for light and halo\n            float d2 = length(uvs);\n            d2 = pow(.3 * size/d2,2.3);\n\n            //point light\n            float d21 = clamp(d2, 0., .5);\n\n            //halos\n            float d22 = clamp(d2, 0., .08);\n            float d23 = clamp(d2, 0., .07);\n            float h = d21 - d22 + d23;\n\n            //tonemapping light & halos\n            h = 1.0 - exp( -h );\n            \n            //applying glow multipliers\n            d = d * STAR_GLOW + h * HALO_GLOW; \n\n        }\n        #endif\n        //correcting falloff to limit reach\n        d = falloff(d, 0.028 * max(HALO_GLOW, STAR_GLOW), 0.096 * max(HALO_GLOW, STAR_GLOW));\n        \n        //opacity calculation\n        if(i != 0) {\n            opacity = pow(linearStep(float(TRAIL_LEN), 0., float(i)) * .4, 1.75);\n            d *= opacity;\n        }\n\n        //adding d to total d\n        totalD += d;\n        \n        //iterative changes\n        size *=1.02;\n        t -= TRAIL_OFFSET * size;\n\n    }\n    \n    //applies the color selected for the star\n    return starColor * totalD;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n                        \n    vec3 starLayer;\n    \n    #ifdef DRAW_BG\n    //background\n    vec3 backgroundColor;\n    backgroundColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1,2,4));\n    fragColor += vec4(backgroundColor * 1., 0);\n    #endif\n    \n    float globalTimeOffset = 500.;\n    //drawing each star\n    for (int i = 0; i < STAR_COUNT; ++i){\n        float e = float(i) * sin(float(i));\n        float speed = STAR_SPEED * .3 + e * .004;\n        vec2 pos = vec2(e * .3);\n        float size = clamp(.4 * cos(e), 0.2, 1.);\n        float timeOffset = e * sin(e) * 3. + globalTimeOffset;\n        vec3 starColor = vec3(sin(e) * .5 + .5, sin(-e) * .5 + .5, cos(e) * .5 + .5);\n        starLayer += drawStar(uv - pos, iTime, size, speed, timeOffset , starColor);\n    }\n    \n    //combining star layer with background\n    fragColor += vec4(starLayer, 0);\n    \n    //tonemapping final result\n    fragColor = 1.0 - exp( -fragColor );\n}","name":"Image","description":"","type":"image"}]}