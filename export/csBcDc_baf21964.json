{"ver":"0.1","info":{"id":"csBcDc","date":"1688284036","viewed":93,"name":"Atmosphere scattering model test","username":"AdamFull","description":"Test of math model based on https://habr.com/ru/articles/459948/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sky","scattering","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float planetRadius = 6371e3;\nconst float atmosphereRadius = 6471e3;\nconst float maxScatterDistance = (atmosphereRadius - planetRadius) * 3.0;\n\nconst int integralStepCount = 32;\nconst int lightIntegralStepCount = 8;\n\nconst vec3 DefaultColor = vec3(0.01);\nconst float BaseIntencity = 5.0;\n\nconst float RayleighScaleHeight = 8e3;\nconst vec3 BetaRayleigh = vec3(5.8e-6, 13.5e-6, 33.1e-6);\n\nconst float MieScaleHeight = 1.2e3;\nconst vec3 BetaMie = vec3(21e-6);\n\nconst float AbsorptionScaleHeight = 30e3;\nconst vec3 BetaAbsorption = vec3(2.04e-5, 4.97e-5, 1.95e-6);\nconst float FalloffAbsorbtion = 4e3;\nconst vec3 BetaAmbient = vec3(0.01);\n\nfloat phaseRayleight(float cosAngle)\n{\n    float cosAngleSquare = cosAngle * cosAngle;\n    return ((3.0 * PI) / 16.0) * (1.0 + cosAngleSquare);\n}\n\nfloat phaseMie(float cosAngle, float g)\n{\n    float cosAngleSquare = cosAngle * cosAngle;\n    float gSquare = g * g;\n    return ((3.0 * PI) / 8.0) * (1.0 - gSquare) * (1.0 + cosAngleSquare) / ((2.0 + gSquare) * pow(1.0 + gSquare - 2.*g*cosAngle, 1.5));\n}\n\n// Calculate Rayleight, Mie and Absorbtion density \nvec3 calculateDensity(float height, float deltaHeight)\n{\n    const vec2 scaleHeight = vec2(RayleighScaleHeight, MieScaleHeight);\n\n    // Calculate density for Rayleight and Mie both\n    vec3 density = vec3(exp(-height / scaleHeight), 0.0);\n\n    // Calculate adsorption (Ozone)\n    float denom = (AbsorptionScaleHeight - height) / FalloffAbsorbtion;\n    density.z = (1.0 / (denom * denom + 1.0)) * density.x;\n\n    density *= deltaHeight;\n\n    return density;\n}\n\nvec3 atmosphere(vec3 origin, vec3 direction, vec3 sunDirection, float sunIntensity)\n{\n    // Trace ray from viewer position to atmosphere\n    vec2 intersection = raySphereIntersect(origin, direction, vec3(0.0), atmosphereRadius);\n    \n    if (intersection.x > intersection.y)\n        return DefaultColor;\n    \n    float hitDistance = max(intersection.x, intersection.y);\n    \n    if (hitDistance < 0.0)\n        return DefaultColor;\n        \n    hitDistance = min(hitDistance, maxScatterDistance);\n\n    // Calculate point where ray hit a sphere\n    \n    vec3 hitPosition = direction * hitDistance;\n    vec3 rayStep = hitPosition / float(integralStepCount);\n    float stepHeight = length(rayStep);\n\n    vec3 opticalDepth = vec3(0.0);\n    vec3 totalRayleight = vec3(0.0);\n    vec3 totalMie = vec3(0.0);\n\n    // Solve first integral\n    for (int i = 0; i < integralStepCount; ++i)\n    {\n        // Calculate current ray step from VIEWER to SKY\n        vec3 integralPos = origin + rayStep * float(i);\n        float integralHeight = length(integralPos) - planetRadius;\n\n        // Accumulate air density\n        vec3 density = calculateDensity(integralHeight, stepHeight);\n        opticalDepth += density;\n\n        // Trace ray from current integral position to sun direction\n        vec2 sunIntersection = raySphereIntersect(integralPos, -sunDirection, vec3(0.0), atmosphereRadius);\n        float sunHitDistance = max(sunIntersection.x, sunIntersection.y);\n\n        // Calculate point where ray hit a sphere\n        vec3 sunHitPosition = -sunDirection * sunHitDistance;\n        vec3 sunRayStep = sunHitPosition / float(lightIntegralStepCount);\n        float sunStepHeight = length(sunRayStep);\n\n        vec3 sunOpticalDepth = vec3(0.0);\n\n        // Solve second integral\n        for (int j = 0; j < lightIntegralStepCount; ++j)\n        {\n            // Calculate position from INTEGRAL POSITION to SUN\n            vec3 sunIntegralPos = integralPos + sunRayStep * float(j);\n            float sunIntegralHeight = length(sunIntegralPos) - planetRadius;\n\n            // Accumulate sun density\n            vec3 sunDensity = calculateDensity(sunIntegralHeight, sunStepHeight);\n            sunOpticalDepth += sunDensity;\n        }\n\n        // Calculate light attenuation\n        vec3 attenuation = exp(-(BetaRayleigh * (opticalDepth.x + sunOpticalDepth.x) + BetaMie * (opticalDepth.y + sunOpticalDepth.y) + BetaAbsorption * (opticalDepth.z + sunOpticalDepth.z)));\n\n        // Accumulate Rayleight and Mie color\n        totalRayleight += density.x * attenuation;\n        totalMie += density.y * attenuation;\n    }\n\n    // Angle between viewer direction and sun direction\n    float angle = dot(normalize(direction), -sunDirection);\n\n    // Calculate total scattered color\n    vec3 rayleightColor = BaseIntencity * phaseRayleight(angle) * BetaRayleigh * totalRayleight;\n    vec3 mieColor = sunIntensity * phaseMie(angle, 0.45) * BetaMie * totalMie;\n    vec3 sunColor = sunIntensity * phaseMie(angle, 0.999) * BetaMie * totalMie;\n\n    return rayleightColor + mieColor + sunColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 origin = vec3(0.0, planetRadius, 0.0) + vec3(0.0, 0.0, 0.0);\n    vec3 direction = normalize(vec3(uv.xy, -1.0));\n    \n    vec3 light_dir = normalize(vec3(0.0, (sin(iTime * 0.5) - 1.0) * 0.5, sin(iTime * 0.5)));\n    \n    vec3 col = atmosphere(origin, direction, light_dir, 1.0f);\n    \n    col = 1.0 - exp(-col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Here is implementation of math functions/constanst that repeating in code\n#define PI 3.1415926535897932384626433832795\n\nvec2 raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b * b - 4.0 * a * c < 0.0) {\n        return vec2(-1.0, -1.0);\n    }\n\n    float t1 = (-b - sqrt((b * b) - 4.0 * a * c)) / (2.0 * a);\n    float t2 = (-b + sqrt((b * b) - 4.0 * a * c)) / (2.0 * a);\n    return vec2(t1, t2);\n}","name":"Common","description":"","type":"common"}]}