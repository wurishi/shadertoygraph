{"ver":"0.1","info":{"id":"ctjSRD","date":"1675770878","viewed":90,"name":"Testing Shader on Randomness?","username":"hcchou4","description":"I thought shaders could be made random? sounds like it\nSo my goal is to have \"randomized\" value set that looks independent to each other in visual.\nExperiment kind of success\nPlease tell me if you think anything could be done to improve it?\nReply slow tho","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["random","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n#define T_OFFSET 5900.0\n#define T iTime\n#define VELOCITY 750.0\n//#define ANGLE_COFF 100.0\n\n#define NUMBEBER_OF_POINT 500.0\n#define RADIUS 15.0\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//randomizeFunctions\nfloat MatrixRandomize(float index){\n    mat2 not_too_unique_matrix = mat2(31.0+index,113.0-index,-13.0+index,-97.0-index);\n    not_too_unique_matrix = mat2(mod(index,2.0),mod(index,3.0),mod(index,5.0),mod(index,7.0))*not_too_unique_matrix;\n    not_too_unique_matrix = mat2(mod(index,11.0),mod(index,13.0),mod(index,17.0),mod(index,19.0))*not_too_unique_matrix;\n    return length(vec2(1,1)*not_too_unique_matrix);\n}\n\n//Provide randomness\nfloat randomizeFunction(float index){\n    return MatrixRandomize(index); \n}\n\nfloat convertTimeToSeed(float index){\n    return fract(randomizeFunction(index)) * (T+T_OFFSET);\n}\n\nfloat getDistanceBySeed(float index){\n    return VELOCITY*convertTimeToSeed(index);\n}\n\n//Use the \"SuperDist\" so the consistency can be remained by some modular\nfloat getAngleBySeed(float Seed){\n    return randomizeFunction(floor(Seed/length(iResolution.xy)));\n    //return ANGLE_COFF*floor(Seed/length(iResolution.xy));\n}\n\nfloat trimDist(float DIST){\n    return mod(DIST,length(iResolution.xy));\n}\n\n//Objects are simple circle in this case\nvec2 computeObjects(vec2 uv,float size){\n    vec2 result=vec2(0,0);\n    for(float i=1.0;i<=size;i++){\n        float superDist = getDistanceBySeed(i);\n        float Dist = trimDist(superDist) ;\n        vec2 Vector = vec2(Dist,0)*rot(getAngleBySeed(superDist));\n        if(length(uv-Vector)<RADIUS){\n            float new_score = min(1.,2.-2.*length(uv-Vector)/RADIUS);\n            result.y += result.y==0.? new_score\n            :0.5*result.y+0.5*new_score+2.*result.y*new_score;\n            if(result.y>=1.){\n                return result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Just so i can look better on the edge\n    vec3 t_colour = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    // pixel coordinates\n    vec2 uv = fragCoord;\n\n    // normalized\n    uv = uv - 0.5 * iResolution.xy;\n    \n    vec2 score = computeObjects(uv,NUMBEBER_OF_POINT);\n    \n    // Time varying pos system\n    vec3 col = score.y>0.0\n    ?vec3(1,0,1)*(score.y)+t_colour*(1.-score.y)\n    :t_colour;\n\n    // Output to screen\n    fragColor.rgb = col;\n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"}]}