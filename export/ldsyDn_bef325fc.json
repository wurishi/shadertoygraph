{"ver":"0.1","info":{"id":"ldsyDn","date":"1487802887","viewed":126,"name":"graprogMidterms","username":"Severin0","description":"eurgh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["misc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PATTERNS 1\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define WHITE vec3(1.0, 1.0, 1.0)\n\n#if PATTERNS == 0\n//simplicity, \nmat2 rotate2d(float angle)\n{\n \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));   \n}\n\nmat2 scale2d(vec2 value)\n{\n \treturn mat2(value.x, 0, 0, value.y);   \n}\n\nvec3 createPolygon(vec2 pos, float ratio, int sides, vec2 uv, vec3 color)\n{\n    \n    //Centering the shape\n    vec2 shapePos = vec2(pos.x*ratio, pos.y);\n    uv -= shapePos;\n    uv *= scale2d(vec2(0.6));\n    uv *= rotate2d(iTime);\n    \n    float derA = atan(uv.x,uv.y)+PI;\n\tfloat derR = TWO_PI/float(sides);\n    \n    float dist = cos(floor(0.5+derA/derR)*derR-derA)*length(uv);\n    \n    float shape = 1.0 - step(0.1, dist);\n    return vec3(shape) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    //scale the space\n    uv *= 1.;\n    \n    //get index from scale\n    vec2 index = floor(uv);\n    \n    //offset every other row\n    float offset1 = step(1.0, mod(uv.y, 2.0));\n    //uv.x += offset1*iTime;\n    \n    float offset2 = step(1.0, mod(uv.x, 2.0));\n    //uv.y += offset2*iTime;\n    \n    float offset3 = step(1.0, mod(uv.x, 3.0));\n    //uv.y -= offset3*iTime;\n   \n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    \n    //uv *= rotate2d(iTime);\n\n    vec3 image;\n    image += createPolygon(vec2(0.5, 0.7), ratio, 40, uv, WHITE);\n    //image += createPolygon(vec2(0.5, 0.5), ratio, 40, uv, vec3(abs(sin((iTime)))));\n    //image += createPolygon(vec2(0.5), ratio, 3, uv, vec3(abs(tan((iTime)))));        \n    image -= createPolygon(vec2(0.5), ratio, 1, uv, RED);\n    image -= createPolygon(vec2(0.5), ratio, 2, uv, GREEN);\n    image -= createPolygon(vec2(0.5), ratio, 1, uv, BLUE);\n    image += createPolygon(vec2(0.7, 0.5), ratio, 40, uv, RED);\n    image += createPolygon(vec2(0.3, 0.5), ratio, 40, uv, BLUE);\n    image += createPolygon(vec2(0.5, 0.3), ratio, 40, uv, vec3(1.0, 1.0, 1.0));\n\n    //image *= createPolygon(vec2(0.5), ratio, 3, uv);\n    \n    /*if(index.x == 1. && index.y == 0. ||\n       index.x == 1. && index.y == 1. ||\n       index.x == 1. && index.y == 2.)\n    {\n       image = createPolygon(vec2(0.5), ratio, 5, uv);\n    }\n    \n    if (index.x == 0. && index.y == 1. ||\n        index.x == 2. && index.y == 1.)\n    {\n        image = createPolygon(vec2(0.5), ratio, 8, uv);\n    }\n    */\n    fragColor = vec4(image, 1.0);\n}\n\n#elif PATTERNS == 1\n// harmony, unity\nmat2 rotate2d(float angle)\n{\n \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));   \n}\n\nmat2 scale2d(vec2 value)\n{\n \treturn mat2(value.x, 0, 0, value.y);   \n}\n\nvec3 createPolygon(vec2 pos, float ratio, int sides, vec2 uv, vec3 color, vec2 scale)\n{\n    \n    //Centering the shape\n    vec2 shapePos = vec2(pos.x*ratio, pos.y);\n    uv -= shapePos;\n    uv *= scale2d(scale);\n    uv *= rotate2d(iTime);\n    \n    float derA = atan(uv.x,uv.y)+PI;\n\tfloat derR = TWO_PI/float(sides);\n    \n    float dist = cos(floor(0.5+derA/derR)*derR-derA)*length(uv);\n    \n    float shape = 1.0 - step(0.1, dist);\n    return vec3(shape) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    //scale the space\n    uv *= 4.;\n    \n    //get index from scale\n    vec2 index = floor(uv);\n    \n    //offset every other row\n    float offset1 = step(1.0, mod(uv.y, 2.0));\n    //uv.x += offset1*iTime;\n    \n    float offset2 = step(1.0, mod(uv.x, 2.0));\n    //uv.y += offset2*iTime;\n    \n    float offset3 = step(1.0, mod(uv.x, 3.0));\n    //uv.y -= offset3*iTime;\n   \n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    \n    //uv *= rotate2d(iTime);\n\n    vec3 image;\n    //image -= createPolygon(vec2(0.5, 0.5), ratio, 1, uv, WHITE, vec2(abs(sin(iTime)), abs(cos(iTime))));\n    image += createPolygon(vec2(0.9, 0.8), ratio, 4, uv, RED, vec2(abs(cos(iTime)), abs(sin(iTime))));\n    image += createPolygon(vec2(0.1, 0.1), ratio, 4, uv, RED, vec2(abs(cos(iTime)), abs(sin(iTime))));\n    image += createPolygon(vec2(0.1, 0.8), ratio, 4, uv, BLUE, vec2(abs(sin(iTime)), abs(cos(iTime))));\n    image += createPolygon(vec2(0.9, 0.1), ratio, 4, uv, BLUE, vec2(abs(sin(iTime)), abs(cos(iTime))));\n    image -= createPolygon(vec2(0.9, 0.1), ratio, 4, uv, vec3(1.0, 0., 1.0), vec2(0.8));\n    image -= createPolygon(vec2(0.1, 0.8), ratio, 4, uv, vec3(1.0, 0., 1.0), vec2(0.8));    \n    image -= createPolygon(vec2(0.9, 0.8), ratio, 4, uv, vec3(1.0, 0., 1.0), vec2(0.8));    \n    image -= createPolygon(vec2(0.1, 0.1), ratio, 4, uv, vec3(1.0, 0., 1.0), vec2(0.8));\n    \n    //image *= createPolygon(vec2(0.5), ratio, 3, uv);\n    \n    /*if(index.x == 1. && index.y == 0. ||\n       index.x == 1. && index.y == 1. ||\n       index.x == 1. && index.y == 2.)\n    {\n       image = createPolygon(vec2(0.5), ratio, 5, uv);\n    }\n    \n    if (index.x == 0. && index.y == 1. ||\n        index.x == 2. && index.y == 1.)\n    {\n        image = createPolygon(vec2(0.5), ratio, 8, uv);\n    }\n    */\n    fragColor = vec4(image, 1.0);\n}\n\n#elif PATTERNS == 2\nmat2 rotate2d(float angle)\n{\n \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));   \n}\n\nmat2 scale2d(vec2 value)\n{\n \treturn mat2(value.x, 0, 0, value.y);   \n}\n\nvec3 createPolygon(vec2 pos, float ratio, int sides, vec2 uv, vec3 color, vec2 scale)\n{\n    \n    //Centering the shape\n    vec2 shapePos = vec2(pos.x*ratio, pos.y);\n    uv -= shapePos;\n    uv *= scale2d(scale);\n    uv *= rotate2d(iTime);\n    \n    float derA = atan(uv.x,uv.y)+PI;\n\tfloat derR = TWO_PI/float(sides);\n    \n    float dist = cos(floor(0.5+derA/derR)*derR-derA)*length(uv);\n    \n    float shape = 1.0 - step(0.1, dist);\n    return vec3(shape) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    //scale the space\n    //uv *= 3.;\n    \n    //get index from scale\n    vec2 index = floor(uv);\n    \n    //offset every other row\n    float offset1 = step(1.0, mod(uv.y, 2.0));\n    //uv.x += offset1*iTime;\n    \n    float offset2 = step(1.0, mod(uv.x, 2.0));\n    //uv.y += offset2*iTime;\n    \n    float offset3 = step(1.0, mod(uv.x, 3.0));\n    //uv.y -= offset3*iTime;\n   \n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    \n    //uv *= rotate2d(iTime);\n\n    vec3 image;\n    image += createPolygon(vec2(0.5), ratio, 1, uv, WHITE, vec2(1.0));\n    \n\n    //image *= createPolygon(vec2(0.5), ratio, 3, uv);\n    \n    /*if(index.x == 1. && index.y == 0. ||\n       index.x == 1. && index.y == 1. ||\n       index.x == 1. && index.y == 2.)\n    {\n       image = createPolygon(vec2(0.5), ratio, 5, uv);\n    }\n    \n    if (index.x == 0. && index.y == 1. ||\n        index.x == 2. && index.y == 1.)\n    {\n        image = createPolygon(vec2(0.5), ratio, 8, uv);\n    }\n    */\n    fragColor = vec4(image, 1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}