{"ver":"0.1","info":{"id":"DsGXDm","date":"1681160392","viewed":77,"name":"Simple Colorless Pawn","username":"xor_swap","description":"Ray marching of a simple chess pawn.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Cristian A. aka @swap_xor on twitter\n// I make cool stuff, follow me and checkout\n// https://github.com/cristian-5\n\nfloat sphere(vec3 p, vec3 o, float r) {\n\treturn length(p - o) - r;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - r;\n}\nfloat cylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0)); // exterior distance\n\tfloat i = min(max(x, y), 0.0); // interior distance\n\treturn e + i;\n}\n\nfloat scene(vec3 p) {\n\tp.y -= 0.2; // move the scene up a bit\n\tfloat z = 2.5;\n\tint n = 6;\n\tfloat objects[6];\n\t// chess pawn:\n\tobjects[n - 1] = sphere(p, vec3(0, 1, z), 0.22);\n\tobjects[n - 2] = cylinder(p, vec3(0, 0.77, z), vec3(0, 0.74, z), 0.21);\n\tfloat y = 1.5 - p.y;\n\tobjects[n - 3] = capsule(\n\t\tp, vec3(0, 1, z), vec3(0, 0.3, z),\n\t\t0.25 * pow(y * 0.8, 2.0)\n\t);\n\tobjects[n - 4] = cylinder(p, vec3(0, 0.32, z), vec3(0, 0.27, z), 0.275);\n\tobjects[n - 5] = capsule(p, vec3(0, 0.12, z), vec3(0, 0.12, z),\n\t\t0.35 * pow(sin(y), 2.0)\n\t);\n\tobjects[n - 6] = cylinder(p, vec3(0, 0.06, z), vec3(0, 0, z), 0.39);\n\t// ground plane rendering:\n\tfloat m = p.y;\n\twhile (n-- > 0) m = min(m, objects[n]);\n\treturn m;\n}\n\n#define MAX_STEPS 100\n#define MAX_DIST  100.0\n#define SURF_DIST 0.01\n// ray marching with camera origin and direction:\nfloat march(in vec3 ro, in vec3 rd) {\n\tfloat d0 = 0.0;\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * d0;\n\t\tfloat ds = scene(p);\n\t\td0 += ds;\n\t\tif (d0 >= MAX_DIST || ds <= SURF_DIST) break;\n\t}\n\treturn d0;\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = scene(p);\n\tvec2 e = vec2(0.01, 0.0);\n\tvec3 n = d - vec3(\n\t\tscene(p - e.xyy),\n\t\tscene(p - e.yxy),\n\t\tscene(p - e.yyx)\n\t); // n is a point close to p;\n\treturn normalize(n);\n}\n\nfloat light(vec3 p) {\n\tvec3 source = vec3(2, 4, -1); // source light\n\tsource.xz *= vec2(sin(iTime), cos(iTime)) * 2.0;\n\tvec3 l = normalize(source - p);\n\tvec3 n = normal(p);\n\t// the dot product between normal and \n\t// light is the diffuse lighting model\n\tfloat diffuse = clamp(dot(n, l), 0.0, 1.0);\n\tfloat d = march(p + n * SURF_DIST * 2.0, l); // shadows:\n\tif (d < length(source - p)) diffuse *= 0.1;\n\treturn diffuse;\n}\n\nvec3 fragment(in vec2 uv) {\n\t// camera:\n\tvec3 ro = vec3(0, 1, 0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\tfloat d = march(ro, rd);\n\t// add lighting of intersection point:\n\tfloat diffuse = light(ro + rd * d);\n\treturn vec3(diffuse);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\tvec2 uv = coord / iResolution.xy;\n\tuv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\tcolor = vec4(fragment(uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}