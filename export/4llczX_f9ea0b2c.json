{"ver":"0.1","info":{"id":"4llczX","date":"1505770592","viewed":222,"name":"Sobel filter (contour detection)","username":"xtrium","description":"Sobel filter as from https://fr.wikipedia.org/wiki/Filtre_de_Sobel\n\n\nBottom left : original image (grayscale)\nTop left : Binarized image\nTop right : Contour detection\nBottom right : Inner inflated contour (aka. inflate(contour) * binaryImage)\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sobel","contour","imageanalysis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float textureLuma(vec2 uv)\n{\n    vec4 textap = texture(iChannel0, uv);\n    return dot(textap.xyz, vec3(0.3, 0.6, 0.1));\n}\n\nfloat textureThreshold(vec2 uv)\n{\n    float textap = textureLuma(uv);\n    return step(0.5, textap);\n}\n\n// Half the inflation size\n#define INFLATE_SIZE 15\n#define CIRCLE_FILTER\n#define INFLATE_SMOOTH\n\nfloat inflate(vec2 uv)\n{\n    float vMax = 0.0;\n    \n    for(int y = -INFLATE_SIZE; y <= INFLATE_SIZE; ++y)\n    {\n        for(int x = -INFLATE_SIZE; x <= INFLATE_SIZE; ++x)\n        {\n            \n#ifdef CIRCLE_FILTER\n            float fx = float(x);\n            float fy = float(y);\n            float d  = sqrt(fx*fx+fy*fy);\n            \n            if(d > float(INFLATE_SIZE))\n                continue;\n#endif\n            \n            float v = texture(iChannel1, uv + vec2(x,y) / vec2(textureSize(iChannel1, 0))).x;\n            \n#ifdef CIRCLE_FILTER\n#ifdef INFLATE_SMOOTH\n            v *= 1.0 - smoothstep(float(INFLATE_SIZE) - 2.0, float(INFLATE_SIZE), d);\n#endif\n#endif\n            \n            vMax = max(vMax, v);\n        }\n    }\n\n    return vMax * texture(iChannel1, uv).y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(1.0);\n    \n    if(uv.x < 0.15)\n    {\n        if(uv.y < 0.5)\n        \tfragColor = texture(iChannel1, uv).zzzz;\n    \telse\n        \tfragColor = texture(iChannel1, uv).yyyy;\n    }\n    else\n    {\n        if(uv.y < 0.5)\n        \tfragColor = texture(iChannel1, uv).xxxx;\n    \telse\n        \tfragColor = vec4(inflate(uv));\n    }\n    \n    //if(abs(uv.x - (sin(iTime) * 0.5 + 0.5)) < 0.002)\n    //    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Sobel filter as from https://fr.wikipedia.org/wiki/Filtre_de_Sobel\n\nfloat textureThreshold(vec2 uv)\n{\n    vec4 textap = texture(iChannel0, uv);\n    float luma = dot(textap.xyz, vec3(0.3, 0.6, 0.1));\n    return step(0.5, luma);\n}\n\nfloat textureLuma(vec2 uv)\n{\n    vec4 textap = texture(iChannel0, uv);\n    return dot(textap.xyz, vec3(0.3, 0.6, 0.1));\n}\n\nfloat Gx(vec2 uv)\n{\n    vec2 texelSize = vec2(1.0) / vec2(textureSize(iChannel0, 0));\n    \n    float result = 0.0f;\n    \n    result += -1.0 * textureThreshold(uv + vec2(-1.0, -1.0) * texelSize);\n    result += -2.0 * textureThreshold(uv + vec2(-1.0,  0.0) * texelSize);\n    result += -1.0 * textureThreshold(uv + vec2(-1.0,  1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0, -1.0) * texelSize);\n    result +=  2.0 * textureThreshold(uv + vec2( 1.0,  0.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0,  1.0) * texelSize);\n    \n    return result;\n}\n\nfloat Gy(vec2 uv)\n{\n    vec2 texelSize = vec2(1.0) / vec2(textureSize(iChannel0, 0));\n    \n    float result = 0.0f;\n    \n    result += -1.0 * textureThreshold(uv + vec2(-1.0, -1.0) * texelSize);\n    result += -2.0 * textureThreshold(uv + vec2( 0.0, -1.0) * texelSize);\n    result += -1.0 * textureThreshold(uv + vec2( 1.0, -1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2(-1.0,  1.0) * texelSize);\n    result +=  2.0 * textureThreshold(uv + vec2( 0.0,  1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0,  1.0) * texelSize);\n    \n    return result;\n}\n\nvec3 contour(vec2 uv)\n{\n    float gx = Gx(uv);\n    float gy = Gy(uv);\n    \n    return vec3(\n        sqrt(gx * gx + gy * gy), // contour\n        textureThreshold(uv), // base image\n        textureLuma(uv)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(contour(uv), 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}