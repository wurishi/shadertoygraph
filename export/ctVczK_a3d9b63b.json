{"ver":"0.1","info":{"id":"ctVczK","date":"1700525477","viewed":20,"name":"Simple UV mapping and texturing","username":"serioux666","description":"I haz UV coordinates, I haz texture. Needz better camera control :D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","texture","uv"],"hasliked":0,"parentid":"dtVcWm","parentname":"Yet another sphere tracer"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst vec3 c = vec3(1., 0., -1.);\nconst float pi = 3.14159265359;\nconst float EPSILON = 0.00001;\nconst float MAX_DEPTH = 100.0;\nconst int MAX_ITERATIONS = 256 ;\n\nvec3 textureSample(vec2 uv)\n{\n    const float tile_size = 0.5;\n    const float tile_border = 0.01;\n    const vec3 color_a = vec3(0.8, 0.5, 0.0);\n    const vec3 color_b = vec3(0.45, 0.8, 0.1);\n    const vec3 color_border = vec3(0.05, 0.05, 0.05);\n    vec2 index = floor(uv / tile_size);\n    vec2 tc = mod(uv, tile_size) / tile_size;\n    vec3 color = mix(color_a, color_b, mod(index.x + index.y, 2.));\n    color = mix(color_border, color, step(tile_border, min(tc.x, tc.y)) * step(max(tc.x, tc.y), 1.0 - tile_border));\n    return color;\n}\n\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y, 0., -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 lightPos()\n{\n    return vec3(3.0 * cos(iTime), 1. * sin(iTime / 3.), -3. * (sin(iTime * 0.7) - 1.));\n}\n\nvec3 sdPlane( vec3 p, vec3 n, float h )\n{\n  vec3 t = mat3(c.yxy, c.zyy, c.yyy) * n;\n  vec3 b = cross(t, n);\n  // n must be normalized\n  return vec3(dot(p,n) - h, dot(t, p), dot(t, n));\n}\n\nvec3 sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  vec2 d = abs(p.xz);\n  vec2 uv = p.xz + vec2(step(d.y, d.x), step(d.x, d.y)) * p.y;\n  return vec3(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), uv);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec3 sdSphere( vec3 p, float s )\n{\n  return vec3(length(p)-s, 0.5 + atan(p.z, p.x) / (2. * pi), 0.5 + asin(p.y) / pi);\n}\n\nvec3 scene(vec3 p)\n{\n    //return min(\n    //   sdPlane(p, c.yxy, -2.0),\n    //    sdSphere(p - vec3(0.0, -1.5, 5.0), 0.5));\n    vec3 hit = c.zxx * sdBox(p - vec3(0.0, 1.5, 0.0), vec3(20., 4., 20.));\n    vec3 sphere = sdSphere(p - vec3(0.0, -1.5, .0), 1.0) * vec3(1., 5., 5.);\n    if(sphere.x < hit.x) {\n        hit = sphere;\n    }\n    return hit;\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    return normalize(vec3(\n        scene(p + EPSILON * c.xyy).x - scene(p - EPSILON * c.xyy).x,\n        scene(p + EPSILON * c.yxy).x - scene(p - EPSILON * c.yxy).x,\n        scene(p + EPSILON * c.yyx).x - scene(p - EPSILON * c.yyx).x));\n}\n\n\nvec3 spheretrace(vec3 p0, vec3 dir)\n{\n    float depth = EPSILON;\n    for(int i = 0; i < MAX_ITERATIONS; ++i) {\n        vec3 dist = scene(p0 + depth * dir);\n        if(dist.x < EPSILON) {\n            return vec3(depth, dist.yz);\n        }\n        depth += dist.x;\n        if(depth > MAX_DEPTH) {\n            break;\n        }\n    }\n    return vec3(MAX_DEPTH, 0., 0.);\n}\n\nfloat shadowing(vec3 p, vec3 n, vec3 light, float k)\n{\n    // iq's algorithm\n    float depth = EPSILON;\n    vec3 dir = normalize(light - p);\n    if(dot(dir, n) < 0.) {\n        return 0.;\n    }\n    float lightness = 1.0;\n    float max_depth = length(p - light) - EPSILON;\n    for(int i = 0; i < MAX_ITERATIONS && depth < max_depth; ++i) {\n        float dist = scene(p + depth * dir).x;\n        lightness = min(lightness, k * dist / depth);\n        depth += dist;\n    }\n    return lightness;\n}\n\n\nconst float I_specular = 1.0;\nconst float shininess = 10.;\nconst float decay_specular = -0.8;\nconst float decay_gouraud = -1.;\nconst float I_gouraud = 3.;\nconst float I_ambient = 0.3;\n\nvec3 render(vec3 eye, vec3 dir)\n{\n    vec3 col;\n    vec3 light = lightPos();\n    vec3 hit = spheretrace(eye, dir);\n    float depth = hit.x;\n    vec2 hit_uv = hit.yz;\n    if(depth < MAX_DEPTH) {\n        vec3 p = eye + depth * dir;\n        vec3 normal = sceneNormal(p);\n        vec3 light_vec = light - p;\n        vec3 L = normalize(light_vec);\n        float light_dist = length(light_vec);\n        float blinn = max(0., pow(dot(-dir + L, normal) / length(-dir + L), shininess) * I_specular);\n        float lit = 1.0;\n        float shadow = shadowing(p, normal, light, 5.);\n        vec3 color = textureSample(hit_uv);\n        col.xyz = shadow * (color * dot(L, normal) * I_gouraud * pow(light_dist, decay_gouraud) + c.xxx * pow(light_dist, decay_specular) * blinn) + color * I_ambient;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2. ;\n    float z = iResolution.y * tan((90. - 45./2.)/180.* pi) * 0.5;\n    float n = 0.;\n    vec3 col = c.yyy;\n    // super duper super sampling\n    float dss = 1. / 2.;\n    for(float xss = 0.; xss < 1.0; xss += dss) {\n        for(float yss = 0.; yss < 1.0; yss += dss) {\n            vec3 dir = normalize(vec3(xy, z) + vec3(xss, yss, 0.));\n            vec3 eye = vec3(0.0, 0.0, -7.);\n\n\n            mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n            dir = rot * dir;\n            eye = rot * eye;\n            eye.y = clamp(eye.y, -1.0, 3.0);\n\n            col += render(eye, dir);\n            n += 1.0;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col / n,1.0);\n}","name":"Image","description":"","type":"image"}]}