{"ver":"0.1","info":{"id":"dscSWn","date":"1680122178","viewed":108,"name":"tris/trs.wire","username":"alesteba","description":"shader fork, ice and fire, by mattz, changing triangle renderization with simple lines.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ice and fire, by mattz\n\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Demonstrate triangulation of jittered triangular lattice.\n\n*/\n\n// FORK OF THE ICE AND FIRE SHADER, by mattz\n// changing the triangles renderization with lines.\n// (and some other effects)\n\n// transformation functions:\n\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n// from https://www.shadertoy.com/view/4djSRW\n\n#define pi 3.14159265\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// draw line segment from A to B\n// https://www.shadertoy.com/view/4ljfRD\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(5./iResolution.y, 0., d) ;\n}\n\n// other draw line:\n\nfloat dseg(vec2 xa, vec2 ba) {\n    return length(xa - ba*clamp(dot(xa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    \n    float theta = 9.28318 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // catmull-rom spline\n    \n    float t1 = floor(t);\n    t -= t1;\n    \n    // points\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.7;\n    \n}\n\nvec2 triPoint(vec2 p) {\n\n    float t0 = hash12(p);\n    \n    return tri2cart*p + 0.45*randCircleSpline(p, 0.15*iTime + t0);\n}\n\n// fucntion, redefinition to use line_segments.\n\nvoid tri_lines(in vec2 p, \n               in vec4 t0, in vec4 t1, in vec4 t2, \n               in float scl, \n               inout float cw) {\n               \n    cw = max(cw,segment(p, t0.xy, t1.xy, scl));\n    cw = max(cw,segment(p, t1.xy, t2.xy, scl));\n    cw = max(cw, segment(p, t2.xy, t1.xy, scl));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // float lines = cube_wire(uv);\n    \n    // blending funct -> for scl:\n    \n    float scl = 3.0/ iResolution.y;\n    \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5 - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighbors\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    // color accumulator\n    float cw = 0.0;\n\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // triangle in this quad\n            vec4 t00 = vec4(pts[3*i+j  ], tfloor + vec2(i-1, j-1));\n            vec4 t10 = vec4(pts[3*i+j+3], tfloor + vec2(i,   j-1));\n            vec4 t01 = vec4(pts[3*i+j+1], tfloor + vec2(i-1, j));\n            vec4 t11 = vec4(pts[3*i+j+4], tfloor + vec2(i,   j));\n          \n            // lower\n            tri_lines(p, t00, t10, t11, scl, cw);\n\n            // upper\n            tri_lines(p, t00, t11, t01, scl, cw);  \n        }\n    }    \n                     \n\tfragColor = vec4(cw, 0.0, 0.0, 1.);\n}","name":"Image","description":"","type":"image"}]}