{"ver":"0.1","info":{"id":"WdVyzh","date":"1602253306","viewed":1264,"name":"Cuvoid / S1C004","username":"phi16","description":"first attempt","likes":38,"published":1,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(x) step(x*32., bt) \n#define I(x) step(bt, x*32.) \n#define C(x) max(step(bt, x*32.-4.), R(x))\n\n// #define AA\n\nstruct C {\n    float d;\n    int m, n, o;\n};\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCappedCylinder( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smax(float d1, float d2, float k){\n    float h = exp(k * d1) + exp(k * d2);\n    return log(h) / k;\n}\nfloat smin(float d1, float d2, float k) {\n    return -smax(-d1,-d2,k);\n}\n\nvec2 pmod(vec2 p, int m) {\n    float a = atan(p.y, p.x);\n    float s = 3.1415926535 / float(m);\n    a = mod(a + s, 2. * s) - s;\n    return length(p) * vec2(cos(a), sin(a));\n}\nC cc(float d, int m, int n) {\n\tC c;\n    c.d = d;\n    c.m = m;\n    c.n = n;\n    return c;\n}\nC cmin(C a, C b) {\n\tif(a.d < b.d) return a;\n    return b;   \n}\nC scene(vec3 p) {\n    vec3 lp;\n    \n    C shaft = cc(length(p.xz) - 0.04, 0, 0);\n    \n    float t = iTime;\n    float bpm = 140.;\n    float spb = 60./bpm;\n    float bt = t/spb;\n    p.y += t*0.23;\n    \n    float yh = 0.23/140.*60.;\n    float ly = mod(p.y, yh) - yh/2.;\n    float yi = floor(p.y/yh);\n    lp = vec3(p.x, ly, p.z);\n    C cyl = cc(sdCappedCylinder(lp, mod(yi,2.) < 1. ? 0.05 : 0.06, yh*0.1), 1, int(yi+8.)%2);\n    shaft = cmin(shaft, cyl);\n    \n    vec2 seed = vec2(yi,0.);\n    float abt = bt < 40. ? smax(32., bt, 2.) : bt < 344. ? bt : bt < 360. ? 352.+smin(0., bt-352., 2.) : 352.;\n    \n    float le = 0.1 * ev(100., 3., fract(bt)) * min(R(2.), max(I(4.), min(R(8.), I(10.)))) * C(4.);\n    \n    float ld = (mod(yi,2.) < 0.5 ? 0.35 : 0.25) + mix(0., 0.6, pow(rand(seed+1.), 4.));\n    float lh = 0.;\n    float rspd = rand(seed+0.)-.5;\n    if(mod(yi,3.) < 0.5) {\n        float u = pow(smoothstep(-2.2, 0.2, bt-224.), 6.);\n        ld += 0.8 * u;\n        lh += 0.02 * u;\n        rspd += sign(rspd) * .3;\n    }\n    float a = rspd * abt * .5 - 0.1 * t;\n    \n    float u = fract(bt/4.-0.25);\n    float ce = ev(100., 8., u);\n    if(bt < 256.) {\n        u = fract(bt/8.-0.875+0.0625)*2.;\n        ce += ev(100., 4., u);\n    }\n    ce *= ld * .2 * min(R(6.), I(12.)) * C(8.);\n    \n    bool beatPos = (int(floor(bt)-yi)%4+4)%4 == 3;\n    bool clapPos = (int(yi)%4+4)%4 == 0;\n    if(!beatPos) le = 0.;\n    if(!clapPos) ce = 0.;\n    ld += le;\n    int sep = 24;\n    lp = vec3(pmod(vec2(p.x,p.z)*mat2(cos(a),-sin(a),sin(a),cos(a)),sep) - vec2(ld,0), ly);\n    C cubes = cc(min(yh/2., sdBox(lp, vec3(0.02+le,0.02+ce,0.02+lh)) - 0.003), 2, int(yi+8.)%4);\n    bool clapPhase = 192. <= bt && bt < 256.;\n    if(beatPos && !clapPos && clapPhase || !clapPhase && beatPos) cubes.n += 4;\n    else if(clapPos) cubes.n += 8;\n    \n    return cmin(shaft, cubes);\n}\nvec3 normal(vec3 p) {\n\tC c = scene(p);\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(\n    \tscene(p+e.xyy).d,\n    \tscene(p+e.yxy).d,\n    \tscene(p+e.yyx).d\n    )-c.d);\n}\nvec3 color(vec2 uv) {\n    float t = iTime;\n    float bpm = 140.;\n    float spb = 60./bpm;\n    float bt = t/spb;\n    float u;\n    \n    float a = 0.8;\n    uv *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\n    vec3 dir = normalize(vec3(uv,1.));\n    a = -0.5;\n    dir.yz *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec3 cam = vec3(0.1,-0.693,-1.1);\n    float dist = 0.;\n    C ld;\n    ld.d = 10000.;\n    ld.m = -1;\n    float eps = 0.001;\n    for(int i=0;i<80;i++) {\n        vec3 p = cam + dir * dist;\n        ld = scene(p);\n        dist += ld.d;\n    \tif(abs(ld.d) < eps) break;    \n    }\n\t\n    vec3 bg = vec3(0.);\n    a = t*0.1;\n    vec2 bgdir = mat2(cos(a),-sin(a),sin(a),cos(a)) * dir.xz;\n    vec2 bguv = vec2(atan(bgdir.y, bgdir.x), dir.y*.8/length(dir.xz) + t*0.05) * 8. / 3.1415926535;\n    bguv = (fract(bguv*2.)-0.5) * 2.;\n    float bd = pow(pow(abs(bguv.x),3.) + pow(abs(bguv.y), 3.), 1.);\n    bg += (1.-exp(-bd)) * vec3(0.2,0,0.8) * 0.3;\n    vec3 col = vec3(0.);\n    \n    if(ld.d < eps) {\n\t    vec3 p = cam + dir * dist;\n        vec3 n = normal(p);\n        vec3 v = normalize(cam - p);\n        float dif = dot(n,normalize(vec3(1,0.5,1))) * 0.5 + 0.5;\n        float rim = 1. - dot(n,v);\n        float ref = cos(dot(reflect(v,n), normalize(vec3(1,-1,1))) * 2.) * 0.5 + 0.5;\n        col = vec3(0.);\n        col += dif * vec3(0,0.2,0.5);\n        col += pow(rim,2.) * vec3(0.1,0.2,1);\n        col += pow(ref, 5.) * vec3(0.2,0.,0.3);\n        \n        // p\n        float pa = 0.;\n        u = fract(bt/4.-0.0)*4.;\n        pa += ev(100., 1., u);\n        u = fract(bt/4.-0.375)*4.;\n        pa += ev(100., 4., u);\n        u = fract(bt/4.-0.75)*4.;\n        pa += ev(100., 3., u);\n        \n        vec3 emi = vec3(0.);\n        if(ld.m == 0) {\n            // a\n            emi += vec3(0.5,0.5,2.) * smoothstep(417., 415., bt);\n            emi *= rim * R(1.);\n            emi += pa * vec3(1.5,1,0) * (rim + dif) * min(R(3.), I(10.));\n        } else if(ld.m == 1) {\n            // h\n            if(ld.n == 1) {\n\t\t\t\t/*u = fract(bt/4.-0.5)*4.;\n            \temi += 1. * R(5.) * C(6.);\n                */\n            \tu = fract(bt+0.5)*2.;\n            \temi += 1. * C(6.);\n            } else if(ld.n == 0) {\n                u = fract(bt*4.);\n                int i = int(floor(bt*4.))%32;\n                if(bt < 320. && i%3 == 0) {\n                \temi += 1. * C(4.) * max(I(4.), R(8.));\n                }\n            }\n            emi *= rim * ev(100., 2., u) * 4. * min(R(.5), I(11.)) * C(2.) * C(8.);\n            emi += pa * vec3(1.5,1,0) * (rim + dif) * min(R(3.), I(10.));\n        } else if(ld.m == 2) {\n            // m & b\n            float ut = fract(bt/64.+0.125)*64. < 62. ? bt : bt+0.5;\n            int n = ld.n % 4;\n            if(n == 0) {\n                u = fract(bt/4.) * 2.;\n            \temi += vec3(0.,0.5,2.) * (1. + exp(-u));\n            } else if(n == 2) {\n                u = fract(bt/4.-0.375) * 2.;\n            \temi += vec3(0.7,0.,2.) * (1. + exp(-u));\n            } else if(bt > 8.) {\n                if(n == 1) {\n                    u = fract(ut/16.-15./16.)*16.;\n                    emi += vec3(2.,0.8,0.);\n                } else if(n == 3) {\n                    u = fract(ut/32.-31.5/32.)*32.;\n                    emi += vec3(2.,0.2,0.);\n                }\n            }\n            emi *= rim * ev(100., 2., u) * 4. * I(12.);\n            if(bt > 384.) {\n                u = bt-384.;\n                emi += rim * ev(100., 1., u) * 4.;\n            }\n            if(4 <= ld.n && ld.n < 8) {\n            \tu = fract(bt);\n                emi += vec3(1,1,1) * ev(100., 2., u) * 4. * dif * min(R(2.), max(I(4.), min(R(8.), I(10.)))) * C(4.);\n            } else if(ld.n >= 8) {\n                float u = fract(bt/4.-0.25);\n                float ce = ev(100., 8., u);\n                if(bt < 256.) {\n                    u = fract(bt/8.-0.875+0.0625);\n                    ce += ev(100., 4., u);\n                }\n                ce *= min(R(6.), I(12.)) * C(8.);\n                emi += ce * vec3(3,1.5,0) * ev(100., 0.5, u) * 4. *dif;\n            }\n        }\n        col += emi;\n        float beatOffset = bt - 129.6;\n        float shd = max(0.,p.y+beatOffset*0.5);\n        col += (ev(100., 16., shd) * 2. + ev(10., 1.5, shd)) * 4. * (rim + dif) * vec3(1.,0.7,0.5);\n        \n        col = mix(bg, col, 1. - pow(rim, 5.));\n    } else {\n        col = bg;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 col = vec3(0.);\n    #ifdef AA\n    int x = 2;\n    for(int i=0;i<x;i++) {\n        for(int j=0;j<x;j++) {\n    \t\tcol += color(uv + vec2(i,j)/float(x)/iResolution.xy);\n        }\n    }\n    col /= float(x*x);\n    #else\n    col += color(uv);\n    #endif\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R(x) smoothstep(x*32.-0.01, x*32.+0.01, bt) \n#define I(x) smoothstep(x*32.+0.01, x*32.-0.01, bt) \n#define C(x) max(smoothstep(x*32.-3.8, x*32.-4.02, bt), R(x))\n#define C2(x) max(smoothstep(x*32.-2.0, x*32.-4.02, bt), R(x))\n#define N(x) smoothstep(x*32., x*32.-0.01, bt)\n#define E(x) smoothstep(x*32., x*32.-4., bt)\n\n// Instruments\n\nfloat a(float f, float t) {\n  return inst0(f*4., t/4., 1000., 100., 0.);\n}\nfloat b(float t) {\n  return chirp(10., 500., 100., t);\n}\nfloat b2(float t) {\n  return chirp(10., 100., 20., t);\n}\nfloat h(float t) {\n  return noise2(t*18000., 0.);\n}\nfloat c1(float t) {\n  return inst2(20., t, 4000., 50., 1.);\n}\nfloat c2(float t) {\n  return inst2(10., t, 2000., 50., 0.5);\n}\nvec2 m(float f, float t) {\n  return ov(f/1.5, t, 1.3, exp(-t*1.5)) + cos(f*1.5*t*tau) * exp(-t*10.);\n}\nvec2 p(float f, float t) {\n  f *= 253.;\n  return vec2(cos(f*1.5*t*tau+.1), cos(f*1.5*t*tau-.1)) * 2.;\n}\nvec2 y(float f, float t) {\n  return vec2(\n    inst0(f*40.3, t/2., 1000., 40., 0.),\n    inst0(f*40.3, t/2., 1000., 50., 0.)\n  ) * 0.5;\n}\nvec2 k(float t) {\n  return vec2(\n    noiseR1(t*4000.-.5, 1.) * 0.5 + noiseR2(t*7000.+.5, 1.) * 1.,\n    noiseR1(t*4000.+.5, 1.) * 0.5 + noiseR2(t*7000.-.5, 1.) * 1.\n  ) * 0.5;\n}\nvec2 o(float t) {\n  float f1 = 8000. + exp(-t*1.) * 5000.;\n  float f2 = 15000. + exp(-t*2.) * 10000.;\n  return vec2(\n    noiseR2(t*f1+.5, 0.5) + noiseR2(t*f2+.5, 0.5),\n    noiseR2(t*f1+.5, 0.5) + noiseR2(t*f2-.5, 0.5)\n  ) * 0.5;\n}\n\n// Main\n\nvec2 mainSound( in int samp,float time){\n  vec2 v = vec2(0.);\n  float t = time;\n  float bpm = 140.;\n  float spb = 60./bpm;\n  float bt = t/spb;\n  int i = 0;\n  \n  vec2 aa = vec2(0.), aa2 = vec2(0.);\n  float u = fract(bt+0.05);\n  float bbu = ev(1000., 0., u) * ev(10., 4.8, 1.-u) * 4.;\n  if(bt > 352.) bbu = 1.;\n  u = fract(bt);\n  aa.x += a(50., t) * 0.4;\n  aa.y += a(50., t+1.) * 0.4;\n  aa2 += mix(y(4., t), y(5., t), sin(bt/16.*tau)*0.5+0.5) * 1.;\n  aa2 += y(6., t) * 0.6 * bbu;\n  \n  vec2 ba = vec2(0.);\n  ba += b(u*spb) * ev(100., 4., u) * 0.4;\n  ba += chirp(10., 100., 10., u*spb) * noiseR0(u*spb, 0.) * ev(100., 2., u) * 0.8;\n  u = fract(bt/4.-0.375);\n  ba += b(u*spb*4.) * ev(100., 4., u) * 0.6 * R(3.);\n  \n  vec2 ha = vec2(0.);\n  u = fract(bt+0.5);\n  ha += h(u*spb) * ev(100., 16., u) * 0.1 * R(5.) * C(6.);\n  ha += o(u*spb) * (ev(100., 32., u) * 4. + ev(100., 4., u)) * 0.06 * C(6.);\n  u = fract(bt/4.-0.5);\n  ha += h(u*spb*4.) * ev(50., 120., u) * 0.15 * R(5.) * C(6.);\n  u = fract(bt*4.-0.25);\n  i = int(floor(bt*4.))%4;\n  if(192.-4. < bt && bt < 192.) {\n    int j = 192*4-1 - int(bt*4.);\n    if((56031 >> j) % 2 == 1) { // **.**.*.**.*****\n      ha += h(u*spb/3.5) * ev(20., 12., u) * 0.5 * R(5.);\n    }\n  } else {\n    if(i != 1) ha += h(u*spb/3.5) * ev(20., 12., u) * 0.4 * R(5.);\n  }\n  u = fract(bt*4.);\n  i = int(floor(bt*4.))%32;\n  if(320.-8. < bt && bt < 320.) {\n    int j = 320*4-1 - int(bt*4.);\n    if((1861156831 >> j) % 2 == 1) {\n      ha += k(u/4.) * ev(100., 8., u) * 0.25 * C(4.) * max(I(4.), R(8.));\n    }\n  } else if(320. < bt && bt < 321. || bt < 320. && i%3 == 0) {\n    ha += k(u/4.) * ev(100., 8., u) * 0.25 * C(4.) * max(I(4.), R(8.));\n  }\n  ha *= 0.5;\n  \n  vec2 ma = vec2(0.);\n  u = fract(bt/4.);\n  ma += m(250., u*spb*4.) * ev(100., 2., u) * ev(1000., 0., 1.-u) * 0.1;\n  u = fract(bt/4.-0.375);\n  ma += m(300., u*spb*4.) * ev(100., 1., u) * ev(1000., 0., 1.-u) * 0.1;\n  float ut = fract(bt/64.+0.125)*64. < 62. ? bt : bt+0.5;\n  u = fract(ut/16.-15./16.);\n  ma += m(333., u*spb*16.) * ev(100., 24., u) * ev(1000., 0., 1.-u) * 0.1;\n  u = fract(ut/32.-31.5/32.);\n  ma += m(300., u*spb*32.) * ev(200., 32., u) * ev(1000., 0., 1.-u) * 0.1;\n  ma *= 1.2;\n  \n  vec2 ca = vec2(0.);\n  u = fract(bt/4.-0.25);\n  ca += c1(u*spb*4.) * ev(100., 32., u) * 0.1;\n  vec2 cl2 = vec2(c2(u*spb*4.), c2(u*spb*4.+5.));\n  ca += mat2(0.8,0.5,-0.5,0.8) * cl2 * ev(100., 6., u) * 0.05;\n  if(bt < 256.) {\n    u = fract(bt/8.-0.875+0.0625);\n    ca += c1(u*spb*8.) * ev(200., 32., u) * 0.05;\n    cl2 = vec2(c2(u*spb*8.), c2(u*spb*8.+5.));\n    ca += mat2(0.8,0.5,-0.5,0.8) * cl2 * ev(200., 6., u) * 0.04;\n  }\n  ca *= 1.2;\n  \n  vec2 pa = vec2(0.);\n  u = fract(bt/4.-0.0);\n  pa += p(1., u*spb*4.) * (ev(100., 32., u) + ev(20., 1., u)*0.1) * 0.12;\n  u = fract(bt/4.-0.375);\n  pa += p(1., u*spb*4.) * (ev(150., 48., u) + ev(20., 4., u)*0.08) * 0.15;\n  u = fract(bt/4.-0.75);\n  float mu = int(floor(bt/4.-0.75))%4 == 3 ? 1. : 8./9.;\n  if(int(floor(bt/4.-0.75))%16 == 15) mu = 4./3.;\n  pa += p(mu, u*spb*4.) * (ev(100., 32., u) + ev(20., 3., u)*0.2) * 0.1;\n  pa *= 0.8;\n  \n  v += ma * N(12.);\n  v += aa * min(R(1.), max(I(4.), min(R(7.), E(13.)))) * C2(4.) * C2(8.);\n  v += aa2 * min(R(2.), max(I(4.), min(R(8.), E(13.))));\n  v += ha * min(R(.5), I(11.)) * C(2.) * C(8.);\n  v += ca * min(R(6.), I(12.)) * C(8.);\n  v += ba * min(R(2.), max(I(4.), min(R(8.), I(10.)))) * C(4.);\n  v += pa * min(R(3.), I(10.));\n  \n  u = bt-127.;\n  if(u > 0.) v += o(u*spb) * (ev(100., 32., u) * 4. + ev(100., 1.5, u)) * 0.03;\n  u = bt-127.95;\n  if(u > 0.) v += psh(1000., 10000., 1.6, u*spb) * 0.12 * (ev(0.5, 2., u*2.) + ev(40., 0.2, u*1.2));\n  u = bt-352.0;\n  if(u > 0.) v += o(u*spb) * (ev(100., 32., u) * 4. + ev(100., 4., u) + ev(100., 1., u) * 0.5) * 0.06;\n  u = bt-384.0;\n  if(u > 0.) v += m(250.*(1.02-1./9.*exp(-u*2.5)), u*spb) * ev(100., 0.1, u) * 0.1;\n  \n  return v * 0.68 * smoothstep(0.,0.1,bt);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// Libraries\n\n#define tau (3.1415926535*2.)\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise0(float t, float s) {\n  float r = floor(t);\n  float f = fract(t);\n  f = smoothstep(0., 1., f);\n  float u0 = rand(vec2(r+0.,s)) - 0.5;\n  float u1 = rand(vec2(r+1.,s)) - 0.5;\n  return mix(u0, u1, f);\n}\nfloat noise1(float t, float s) {\n  float r = floor(t);\n  float f = fract(t);\n  f = smoothstep(0., 1., f);\n  float v0 = rand(vec2(r+0.,s));\n  float v1 = rand(vec2(r+1.,s));\n  float v2 = rand(vec2(r+2.,s));\n  float u0 = v1 - v0;\n  float u1 = v2 - v1;\n  return mix(u0, u1, f);\n}\nfloat noise2(float t, float s) {\n  float r = floor(t);\n  float f = fract(t);\n  f = smoothstep(0., 1., f);\n  float w0 = rand(vec2(r+0.,s));\n  float w1 = rand(vec2(r+1.,s));\n  float w2 = rand(vec2(r+2.,s));\n  float w3 = rand(vec2(r+3.,s));\n  float v0 = w1 - w0;\n  float v1 = w2 - w1;\n  float v2 = w3 - w2;\n  float u0 = v1 - v0;\n  float u1 = v2 - v1;\n  return mix(u0, u1, f);\n}\nfloat noiseR0(float t, float p) {\n  t += noise0(t, 0.) * p;\n  return noise0(t, 1.);\n}\nfloat inst0(float f, float t, float m, float o, float p) {\n  float rep = 1./f;\n  float fac = mod(t,rep);\n  float mult = m;\n  float offset = t*o;\n  return mix(\n    noiseR0(fac*mult + offset, p),\n    noiseR0((fac+rep)*mult + offset, p),\n    smoothstep(0.,1.,1.-fac/rep));\n}\nfloat noiseR1(float t, float p) {\n  t += noise0(t, 0.) * p;\n  return noise1(t, 1.);\n}\nfloat inst1(float f, float t, float m, float o, float p) {\n  float rep = 1./f;\n  float fac = mod(t,rep);\n  float mult = m;\n  float offset = t*o;\n  return mix(\n    noiseR1(fac*mult + offset, p),\n    noiseR1((fac+rep)*mult + offset, p),\n    smoothstep(0.,1.,1.-fac/rep));\n}\nfloat noiseR2(float t, float p) {\n  t += noise0(t, 0.) * p;\n  return noise2(t, 1.);\n}\nfloat inst2(float f, float t, float m, float o, float p) {\n  float rep = 1./f;\n  float fac = mod(t,rep);\n  float mult = m;\n  float offset = t*o;\n  return mix(\n    noiseR2(fac*mult + offset, p),\n    noiseR2((fac+rep)*mult + offset, p),\n    smoothstep(0.,1.,1.-fac/rep));\n}\nfloat chirp(float sf, float df, float rate, float t) {\n  // integrate sf+df*exp(-rate*t) = sf*t-df*exp(-rate*t)/rate\n  float v = sf*t - df*exp(-rate*t)/rate;\n  return sin(v*tau) + sin(v*1.5*tau)*0.5;\n}\nvec2 psh(float sf, float df, float rate, float t) {\n  // integrate sf+df*exp(-rate*t) = sf*t-df*exp(-rate*t)/rate\n  float v = sf*t - df*exp(-rate*t)/rate;\n  return vec2(noise2(v*tau, 0.), noise2(v*tau+.2, 0.))*.7 + noise1(v*tau, 0.) * .3;\n}\nvec2 ov(float f, float t, float m, float e) {\n  vec2 v = vec2(0.);\n  float ff = f;\n  float ee = (1.+e)/2.;\n  for(int i=0;i<4;i++) {\n    v += sin(ff*t*tau+float(i)+vec2(-0.25,0.25)) * ee;\n    ff *= m;\n    ee *= e;\n  }\n  return v;\n}\nfloat ev(float s, float e, float t) {\n  return (1.-exp(-s*t)) * exp(-e*t);\n}\nfloat ev2(float s, float e, float t) {\n  return ev(s, e, t) + ev(s*4., e*8., t) * 2.;\n}","name":"Common","description":"","type":"common"}]}