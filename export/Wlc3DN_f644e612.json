{"ver":"0.1","info":{"id":"Wlc3DN","date":"1576365654","viewed":94,"name":"SNOWMAN!!!","username":"onlinerocker","description":"Here's a snowman.\nTis the season!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting","snowman","chirstmas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nstruct object\n{\n \tfloat dist;\n    vec3 color;\n    bool isSnow;\n};\n    \nstruct ray\n{\n \tvec3 curRay;   \n    object obj;\n    float totalDist;\n};\n    \nfloat fmod(float x, float y)\n{\n \treturn x - y * floor(x/y); \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat4 getTransXYZ(float alpha, float beta, float gamma, float x, float y, float z)\n{\n \tvec4 col =  vec4(cos(beta)*cos(gamma),\n                     cos(alpha)*sin(gamma) + sin(alpha)*sin(beta)*cos(gamma),\n                     sin(alpha)*sin(gamma) - cos(alpha)*sin(beta)*cos(gamma),\n                     0);\n    \n    vec4 col1 = vec4(-cos(beta)*sin(gamma),\n                      cos(alpha)*cos(gamma) - sin(alpha)*sin(beta)*sin(gamma),\n                      sin(alpha)*cos(gamma) + cos(alpha)*sin(beta)*sin(gamma),\n                      0);\n                     \n    vec4 col2 = vec4(sin(beta),\n                    -sin(alpha)*cos(beta),\n                     cos(alpha)*cos(beta),\n                     0);\n                     \n    vec4 col3 = vec4(x, y, z, 1);\n                    \n    return mat4(col,\n                col1,\n                col2,\n                col3);\n    \n}\n\n//START IQ FUNCTIONS\n\nfloat sdSphere(vec3 pos, vec3 center, float rad)\n{\n \treturn length(pos - center) - rad;   \n}\n\nfloat sdPlane(vec3 pos, float y)\n{\n    return pos.y - y;   \n}\n\nfloat sdCone(vec3 p, float radAng)\n{\n    /*if(p.x < 0.)\n        return 24.;\n    p -= vec3(1.0, 0.8, 0);\n    p = vec3(getTransXYZ(.0, -PI/2.0, .0, .0, .0, .0) * vec4(p,1));\n    \n    vec2 c = vec2(sin(2.), sin(.2));\n\tfloat q = length(p.xy);\n  \treturn dot(c,vec2(q,p.z));*/\n    if(p.x < -1.0)\n        return 24.0;\n    vec2 c = vec2(sin(2.), sin(.2));\n\tfloat q = length(p.yz);\n  \treturn dot(normalize(c),vec2(q,p.x));\n    \n    /*vec2 vals = vec2(sin(2.95), sin(2.));\n    vec3 tipPos = vec3(-3, 0.8, 0);\n    \n    float len = length(pos.zy - tipPos.zy);\n    return dot(vals, vec2(pos.x - 1., len));\n\t*/\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(0.2+(sin(iTime)*0.04)) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat sdRoundCone( vec3 p, vec3 loc, float r1, float r2, float h, mat4 transform)\n{\n  p = p - loc;\n  p = vec3(transform * vec4(p,1));\n    \n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n//END IQ FUNCIONS\n\nvec3 getMapColor(float d, float dNew, vec3 col, vec3 colNew)\n{\n    return step(dNew, d)*colNew + step(d, dNew)*col;\n}\n\n//maps body and ground plane\nobject map(vec3 pos)\n{\n    object obj;\n    obj.dist = 1000.0;\n    obj.color = vec3(1);\n\n    //combing top, mid, and btm of snowman here\n    //change x < 5 and z > -5 to fix nose... why? idfk\n \n    float dGr = sdPlane(pos, -2.0); //ground\n    if(dGr < obj.dist) obj.color = vec3(1);\n    obj.dist = min(dGr, obj.dist);\n    \n    float lightX = pos.x;\n    float lightZ = pos.z;\n    if(lightX < 0.95 && lightX > -0.5)\n    {\n        lightZ = abs(pos.z);\n        lightX = fmod(pos.x, 0.5);   \n    }\n\n    vec3 lightPos = vec3(lightX, pos.y, lightZ);\n    float dL = sdSphere(lightPos , vec3(0., -1.97, 1.5), 0.05); //light\n    if(dL < obj.dist) obj.color = vec3(2,0,0);\n    //col = getMapColor(d, dL, col, vec3(2,0,0));\n    obj.dist = min(obj.dist, dL);\n    \n    float dl1 = sdSphere(lightPos, vec3(0.3, -1.97, 1.3), 0.05);//light\n    if(dl1 < obj.dist) obj.color = vec3(0,1,0);\n    //col = getMapColor(d, dl1, col, vec3(0,1,0));\n    obj.dist = min(dl1, obj.dist);\n    \n    float dRop = sdCapsule(lightPos, vec3(0, -1.97, 1.5), vec3(0.3, -1.97, 1.3), 0.03); //rope\n    float dRop1 = sdCapsule(lightPos, vec3(0.3, -1.97, 1.3), vec3(0.6, -1.97, 1.6), 0.03); //rope 1\n    dRop1 += 1000.0*step(0.6, pos.x); //clip last rope off\n    \n    dRop = min(dRop, dRop1);\n    if(dRop < obj.dist) obj.color = vec3(0);\n    //col = getMapColor(d, dRop, col, vec3(0));  \n    obj.dist = min(dRop, obj.dist);\n    \n    float boundingCap = sdSphere(pos, vec3(0, -1, 0), 1.3);\n\t//obj.dist = boundingCap;\n    \n    if(boundingCap < obj.dist)\n    {\n        float top = sdSphere(pos, vec3(0,-1.5,0), 1.0);\n        float mid = sdSphere(pos, vec3(0,-.3,0), 0.8);\n        float bottom = sdSphere(pos, vec3(0,0.7,0), 0.6);\n        float bodyDist = min(mid, bottom);\n        bodyDist = min(top, bodyDist);\n        obj.dist = min(bodyDist, obj.dist);\n        obj.color = vec3(1);\n        \n        //btns\n        float btnY = pos.y;\n    \tfloat btnX = pos.x;\n    \n    \tbtnX += step(0.0, btnY)*0.07;\n    \tif(btnY < 0.4 && btnY > -0.6)\n    \t{\n        \tbtnY = fmod(pos.y, -0.4);\n    \t}\n        \n        float dBtn = sdSphere(vec3(btnX, btnY, pos.z), vec3(0.8,-0.3,0.0), .07); //buttons\n        if(dBtn < obj.dist) obj.color = vec3(0);\n        //col = getMapColor(d, dBtn, col, vec3(0));\n        obj.dist = min(dBtn, obj.dist);\n        \n        float eyeZ = abs(pos.z);\n        float dEye = sdSphere(vec3(pos.xy, eyeZ), vec3(0.5,0.9,0.2), .1); //eyes\n        if(dEye < obj.dist) obj.color = vec3(0);\n        //col = getMapColor(d, dEye, col, vec3(0));\n        obj.dist = min(dEye, obj.dist);\n        \n        float dNose = sdCone(pos - vec3(1.0, 0.8, 0), 0.05); //nose\n        if(dNose < obj.dist) obj.color = vec3(235./255., 137./255., 33./255.);\n        //col = getMapColor(d, dNose, col, vec3(235./255., 137./255., 33./255.));\n        obj.dist = min(dNose, obj.dist);\n        \n        vec3 pipePos1 = vec3(getTransXYZ(-PI/4.0, .0, .0,.0, .0, .0) * vec4(pos,1)); //pipe\n        vec3 pipePos = pipePos1 - vec3(.92, 0.8, -0.3);\n        pipePos = vec3(getTransXYZ(.0, -PI/4.0, .0, .0, .0, .0) * vec4(pipePos, 1.0));\n\n        float dPipe = sdCappedCylinder(pipePos, vec3(.0, -0.1, .0), vec3(.0, .1, .0), 0.05);\n        float dPipe1 = sdCapsule(pipePos1, vec3(.92, 0.8, -0.3), 0.5*normalize(vec3(-1,-0.1,-0.4)), 0.03);    \n        dPipe = min(dPipe, dPipe1);\n        if(dPipe < obj.dist) obj.color = vec3(0.35, 0.1, 0.1);\n        //col = getMapColor(d, dPipe, col, vec3(0.35, 0.1, 0.1));\n        obj.dist = min(dPipe, obj.dist);\n        \n        vec3 rotPos = vec3(getTransXYZ(.0, .0, -PI/10.0, .0, .0, .0) * vec4(pos,1)); //hat\n        \n        float dHat = sdRoundedCylinder(rotPos - vec3(0.2, 1.4, .0), 0.2, 0.1, 0.25); \n        float dHatBtm = sdRoundedCylinder(rotPos - vec3(0.2, 1.15, .0), 0.3, 0.05, 0.015);\n        dHat = min(dHat, dHatBtm);\n        if(dHat < obj.dist) obj.color = vec3(0);\n        obj.dist = min(dHat, obj.dist);\n        \n        float dHatRib = sdCappedCylinder(rotPos - vec3(0.2, 1.2, .0), vec3(0), vec3(.0, 0.13, .0), 0.43);\n        if(dHatRib < obj.dist) obj.color = vec3(0.7,0,0);\n        obj.dist = min(dHatRib, obj.dist);\n        \n\n    }\n\n    obj.isSnow = false;\n \treturn obj;   \n}\n\nvec3 calcNorm(vec3 pos)\n{\n    float ep = 0.001;\n \tfloat x = map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist;  \n    float y = map(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist;  \n    float z = map(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist;  \n    \n    return normalize(vec3(x, y, z));\n}\n\nray marchRay(vec3 pos, vec3 dir)\n{\n    vec3 curRay;\n    float dist = 0.001;\n    object obj;\n    ray r;\n    \n    for(int x=0; x<100; x++)\n    {\n        curRay = pos + dist*dir;\n        \n        obj = map(curRay);\n        float d = obj.dist;\n        dist += d;\n        \n        if(d < 0.001)\n            break;\n        if(dist > 25.0)\n            break;\n        \n             \n    }\n    \n    r.curRay = curRay;\n    r.obj = obj;\n    r.totalDist = dist;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.x)/iResolution.y;\n\tvec3 camPos = vec3(0, 0, 0);\n\tvec3 dir = normalize(vec3(uv, -1));\n       \n    float rotMod = PI/2.0 + sin(iTime/4.0) * PI/3.0;\n\n    //(2.2+rotMod*iTime/4.0)\n    mat4 camTransform = getTransXYZ(0.0, rotMod, 0., \n                                    4.*sin(rotMod), 2., 4. * cos(rotMod));\n\n    dir = normalize(vec3(camTransform * vec4(dir,0))); //transform direction\n    camPos = vec3(camTransform * vec4(camPos,1)); //rotate camera around sphere\n    \n    //lights\n    vec3 sunLightPos = vec3(10, 10, 1);\n    vec3 skyLightPos = vec3(0, 12, 0);\n    vec3 bouLightPos = vec3(0, -1.9, -1);\n    \n    vec3 xmasLightPos = vec3(0, -1.8, 1.5);\n    vec3 xmasLightPos1 = vec3(0.3, -1.8, 1.3);\n    vec3 xmasLightPos2 = vec3(0.6, -1.8, 1.5);\n    vec3 xmasLightPos3 = vec3(0.9, -1.8, 1.3);\n    vec3 xmasLightPos4 = vec3(-0.5, -1.9, 1.5);\n    vec3 xmasLightPos5 = vec3(-0.2, -1.9, 1.3);\n    \n    float sunLightInt = 5.0;\n    float skyLightInt = 1.0;\n    float bouLightInt = 1.0;\n    float xmasLightInt = 0.3;\n    \n    ray ret = marchRay(camPos, dir);\n    vec3 curRay = ret.curRay;\n    float dist = ret.totalDist;\n    \n    vec3 rayNorm = calcNorm(curRay);\n    \n    ray shaRet = marchRay(curRay + rayNorm*0.01, normalize(sunLightPos - curRay));\n    float shaDist = shaRet.totalDist;\n    \n    //ray shaRetBou = marchRay(curRay + rayNorm*0.01, normalize(bouLightPos - curRay));\n    //float shaDistBou = shaRetBou.totalDist;\n    \n    bool objIsSnow = shaRet.obj.isSnow;\n    if(objIsSnow)\n        shaDist = 26.0;\n    \n    vec3 col;\n    \n    vec3 xmasRay = curRay;\n    vec3 xmasNorm = rayNorm;\n    xmasRay.z = abs(xmasRay.z);\n    xmasNorm.z = abs(xmasNorm.z);\n    \n    float slIntensity = sunLightInt * clamp(dot(rayNorm, normalize(sunLightPos - curRay)), 0.0, 1.0);\n    float skLIntensity = skyLightInt * clamp(dot(rayNorm, normalize(skyLightPos - curRay)), 0.0, 1.0);\n    float bouIntensity = bouLightInt * clamp(dot(rayNorm, normalize(bouLightPos - curRay)), 0.0, 1.0);\n    \n    float xmInt = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos - xmasRay)), 0.0, 1.0);\n    float xmInt1 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos1 - xmasRay)), 0.0, 1.0);\n    float xmInt2 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos2 - xmasRay)), 0.0, 1.0);\n    float xmInt3 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos3 - xmasRay)), 0.0, 1.0);\n    float xmInt4 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos4 - xmasRay)), 0.0, 1.0);\n    float xmInt5 = xmasLightInt * clamp(dot(xmasNorm, normalize(xmasLightPos5 - xmasRay)), 0.0, 1.0);\n\n    vec3 slCol = vec3(0.2, 0.2, 0.2) * slIntensity;\n    vec3 skCol = vec3(0.0, 0.0, 0.2) * skLIntensity;\n    vec3 bouCol = vec3(0.2, 0.2, 0.2) * bouIntensity;\n    vec3 xmCol = vec3(1, 0, 0) * xmInt;\n    vec3 xmCol1 = vec3(0, 1, 0) * xmInt1;\n    vec3 xmCol2 = vec3(1, 0, 0) * xmInt2;\n    vec3 xmCol3 = vec3(0, 1, 0) * xmInt3;\n    vec3 xmCol4 = vec3(1, 0, 0) * xmInt4;\n    vec3 xmCol5 = vec3(0, 1, 0) * xmInt5;\n    \n    vec3 allLightMod = slCol*step(25., shaDist) + skCol + bouCol + xmCol + xmCol1 + xmCol2 + xmCol3 + xmCol4 + xmCol5;\n    \n    if(dist > 25.0)\n    {\n        col = (0.6+uv.y)*vec3(0.0, 0.2, 0.4) + (1.0-uv.y)*vec3(0.1);\n        col = applyFog(col, dist, curRay, sunLightPos);\n    }\n    else\n    {        \n        col = ret.obj.color * (allLightMod);\n        col = applyFog(col, dist, curRay, sunLightPos);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}