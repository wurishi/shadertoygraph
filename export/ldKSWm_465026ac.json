{"ver":"0.1","info":{"id":"ldKSWm","date":"1464856642","viewed":1093,"name":"Waveform Generator","username":"SoftEgg","description":"Testing waveform table calculation for NanoEgg Synthesizer development\nhttps://hackaday.io/project/11574-nanoegg-music-synthesizer\nAttempting to implement my waveform generator from\nhttps://www.desmos.com/calculator/odxjpny3g1","likes":26,"published":1,"flags":8,"usePreview":0,"tags":["sound","triangle","square","sine","waveform","sawtooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Draw multiple lines of functions on gradient background\n// A sample for the book of shaders.\n// http://thebookofshaders.com/05/\n\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.003, pct, st.y) - \n          smoothstep( pct, pct+0.003, st.y);\n}\n\nfloat audiowave_pulse_to_saw(float time, float c)\n{\n    float pi = 3.1415626;\n    float t = time*10000.0;//scale time here\n    float mx = 32768.0;\n    float mn = -32768.0;\n    float range = mx - mn;\n    float seg = floor(t/256.0);\n    float segstart = seg*256.0;\n    float p = 1.0;\n\n    float ic = 1.0-c;\n    //float p = 0.0;//sin(seg/100000.0);\n    float ip = 1.0-p;\n    t=mod(t,256.0);\n    float y=0.0;   \n    float s=1.0;\n\ty = mn;\n\n    if ( ( t < (126.0 * p ) ) || ( t > ( 128.0 ) ) )\n    {\n        s = -1.0;\n        y = mn;\n        float width = (254.0 * ic )+2.0; \n        float start = 128.0 -width;\n        float startlow = mod(start,256.0);\n        float end = start + width;\n        if ((( t > start ) && ( t < end )) || (( t > (start + 256.0) && ( t < end + 256.0))))\n        {\n\t        float tmod = (t +256.0 - startlow );\n    \t    tmod = mod( tmod, 256.0);\n        \ttmod = (tmod) * 256.0/width;\n\t\t\ty=(tmod*range/256.0)+mn;            \n        }\n    }\n    return ( y/100000.0 );\n}\n\nfloat audiowave( float time,float a, float b, float c, float p )\n{\n    float pi = 3.1415626;\n    float t = time*10000.0;//scale time here\n    float mx = 32768.0;\n    float mn = -32768.0;\n    float range = mx - mn;\n    float seg = floor(t/256.0);\n    float segstart = seg*256.0;\n\n    //float a = 128.0*(1.0+sin(seg/100.0));\n    float ia = 1.0-a;\n    //float b = 1.0;//sin(time/10000000.0)+1.0;\n    float ib = 1.0-b;\n    //float c = 0.0;//sin(seg/10000.0);\n    float ic = 1.0-c;\n    //float p = 0.0;//sin(seg/100000.0);\n    float ip = 1.0-p;\n    t=mod(t,256.0);\n    float y=0.0;   \n    float s=1.0;\n    if ( ( t < (126.0 * p ) ) || ( t > ( 128.0 ) ) )\n    {\n        s = -1.0;\n    }\n    if ( t<(128.0-((256.0-a)/2.0)) )\n    {\n    \ty=\tic*\n            (\n                b*\n                mx*\n                sin(\n                    2.0*\n                    pi*\n                    (\n                        t/\n                        (2.0*a)\n                    )\n\t\t\t\t)+\n                ib*\n                range*\n                (\n                    t/\n                    a\n                )                \n            )+\n            (\n                c*\n                mx*\n                s\n            );\n    }\n    else if (t<(128.0+((256.0-a)/2.0)))\n    {\n        y= \tic * \n           \t(\n           \t\tb*\n                mx*\n                sin(\n                   \t2.0*\n                   \tpi*\n                   \t(\t\n                     \t0.25+\n                      \t(\n                           \t( \n                                t - \n                           \t\t(a/2.0)\n                        \t)\n                        \t/\n                        \t(\n                            \t512.0-\n                            \t(2.0*a)\n                        \t)\n                      \t)\n                 \t)\n\t\t\t\t)+\n                (\n                   \tib*\n                   \trange*\n                   \t(\n                       \t(128.0-t)/\n                       \t(256.0-a)\n                   \t)\n                )\n\t\t\t)+\n            (mx*c*s);\n    }\n    else\n    {\n        y=\tic*\n            (\n                b*\n                mx*\n                sin(\n                    2.0*\n                    pi*\n                    (\n                        0.5+\n                        (\n                            (\n                                t-\n                                a-\n                                256.0\n                            )\n                            /\n                            (\n                                2.0*\n                                a\n                            )\n                        )\n                    )\n                )\n\t            +\n    \t        ib*\n        \t    range*\n            \t(\n                \t(\n                    \tt-\n                    \t256.0\n                \t)\n                \t/\n                \ta\n            \t)\n            )+\n            (\n                mx*\n                c*\n                s\n            );\n    }\n    float o = y/100000.0;///max;\n    \n    return o;\n}\n\n#define DOWN_SCALE 3.0\n\n#define MAX_INT_DIGITS 8\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-â–ˆâ–ˆâ–ˆ----\nâ–ˆâ–ˆ-â–ˆâ–ˆ---\nâ–ˆâ–ˆ-â–ˆâ–ˆ---\n-â–ˆâ–ˆâ–ˆ----\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ-â–ˆ-\nâ–ˆâ–ˆ-â–ˆâ–ˆâ–ˆâ–ˆ-\nâ–ˆâ–ˆ--â–ˆâ–ˆ--\nâ–ˆâ–ˆ-â–ˆâ–ˆâ–ˆ--\n-â–ˆâ–ˆâ–ˆ-â–ˆâ–ˆ-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\n//vec2 res = iResolution.xy / DOWN_SCALE;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    if ( number < 0.0 )\n    {\n        number *=-1.0;\n        result += char(ch_dsh,uv);\n    }\n    \n\tfor(int i = 8;i >= -4;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat text(vec2 uv, float t, float seg, float a, float b, float c, float p)\n{\n    float col = 0.0;\n    \n    vec2 center = iResolution.xy / (2.0*DOWN_SCALE);//res/2.0;\n    \n    //Time Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(5.0));\n    \n    TEXT_MODE = INVERT;\n    col += char(ch_T,uv);\n    col += char(ch_i,uv);\n    col += char(ch_m,uv);\n    col += char(ch_e,uv);\n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_number(t,uv);\n    \n    //Seg Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(4.0));\n    \n    TEXT_MODE = INVERT;\n    col += char(ch_S, uv);\n    col += char(ch_e, uv);\n    col += char(ch_g, uv);\n    TEXT_MODE = NORMAL;\n    col += char(ch_col, uv);\n    \n    TEXT_MODE = UNDERLINE;\n\n    col += print_integer(seg,6, uv);\n    \n    //A Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(3.0));\n    \n    TEXT_MODE = INVERT;  \n    col += char(ch_A,uv);\n    \n    TEXT_MODE = NORMAL;  \n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_integer(a,3,uv); \n\n    //B Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(2.0));\n    \n    TEXT_MODE = INVERT;  \n    col += char(ch_B,uv);\n    \n    TEXT_MODE = NORMAL;  \n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_number(b,uv); \n\n    //C Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(1.0));\n    \n    TEXT_MODE = INVERT;  \n    col += char(ch_C,uv);\n    \n    TEXT_MODE = NORMAL;  \n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_number(c,uv); \n    \n    //P Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(0.0));\n    \n    TEXT_MODE = INVERT;  \n    col += char(ch_P,uv);\n    \n    TEXT_MODE = NORMAL;  \n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_number(p,uv); \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    \n    //backgoud gradient\n    vec3 bkcolor = vec3(st.x/6.0,st.x/3.5, st.x/5.0);\n    if (( st.y < 0.5001 )&& (st.y > 0.499))\n    {\n        bkcolor+=vec3(0.0,0.5,0.2);\n    }\n    if (( st.y < 0.827 )&& (st.y > 0.825))\n    {\n        bkcolor+=vec3(0.2,0.2,0.2);\n    }\n    if (( st.y < 0.172 )&& (st.y > 0.170))\n    {\n        bkcolor+=vec3(0.2,0.2,0.2);\n    }\n    float pi = 3.1415626;\n    float t = iTime*10000.0;//scale time here\n    float mx = 32768.0;\n    float mn = -32768.0;\n    float seg = floor(t/256.0);\n    float segstart = seg*256.0;\n    float section = floor(seg/(100.0*pi));\n    float sectionstart = seg*100.0*pi*256.0;\n    \n\n    float a = 128.0*(1.0+sin(seg/100.0));\n    float b = sin(seg/200.0);\n    float c = (1.0-cos(seg/400.0))/2.0;\n    float p = 0.0;//sin(seg/100000.0);\n\n    float select = mod(section,8.0);\n    float y=0.0;\n    if ( select < 1.0 ){\n       \ta = 0.0;\n       \tb = -1.8*cos(seg/200.0);\n       \tc = 0.0;\n       \tp = 0.0;\n        y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    else if (select < 2.0 ){\n       \ta = 128.0*(-cos(seg/200.0));\n       \tb = 0.0;\n       \tc = 0.0;\n       \tp = 0.0;\n        y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    else if (select < 3.0 )\n    {\n\t\ta = 128.0;\n       \tb = -sin(seg/200.0);\n       \tc = 0.0;\n       \tp = 0.0;\n        y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    else if (select < 4.0 )\n    {\n\t\ta = 128.0;\n       \tb = 1.0;\n       \tc = cos(seg/200.0);\n       \tp = 0.0;\n        y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    else if ( select < 5.0 )\n    {\n\t\ta = 128.0;\n       \tb = 1.0;\n       \tc = 1.0;\n       \tp = sin(seg/200.0);\n        y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    else if (select < 6.0 )\n    {\n       a = 255.0;\n       b = 1.0;\n       c = sin(seg/200.0);\n       p = 1.0;     \n       y= audiowave_pulse_to_saw((st.x)/20.0,c);\n    }\n    else if (select < 7.0 )\n    {\n       a = 255.0*(-cos(seg/200.0));\n       b = 0.0;\n       c = 0.0;\n       p = 0.0;     \n       y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    else if (select < 8.0 )\n    {\n       a = 0.0;\n       b = -1.8*cos(seg/200.0);\n       c = 0.0;\n       p = 0.0;     \n       y = audiowave((st.x)/20.0,a,b,c,p);\n    }\n    \n    float ia = 1.0-a;\n    float ib = 1.0-b;\n    float ic = 1.0-c;\n    float ip = 1.0-p;\n        \n    // Plot a lines\n    float pct1 = plot(st,1.0);\n    float pct2 = plot(st,0.5+y);\n    float pct3 = plot(st, 0.0);\n\n    //text start\n    vec2 uv = fragCoord.xy / DOWN_SCALE;\n\tvec2 duv = floor(fragCoord.xy / DOWN_SCALE);\n    \n\tfloat pixel = text(duv,t,section,a,b,c,p);\n    \n    //Shading stuff\n    vec3 col = vec3(1);\n    col *= (1.-distance(mod(uv,vec2(1.0)),vec2(0.65)))*1.2;\n    col *= mix(vec3(0.2),vec3(0,1,0),pixel);\n\t//text end\n    \n    \n    vec3 color = (1.0-col)*(1.0-pct2)*bkcolor+pct2*vec3(0.0,1.0,0.0)+vec3(col);\n    \n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"float audiowave_pulse_to_saw(float time, float c)\n{\n    float pi = 3.1415626;\n    float t = time*10000.0;//scale time here\n    float mx = 32768.0;\n    float mn = -32768.0;\n    float range = mx - mn;\n    float seg = floor(t/256.0);\n    float segstart = seg*256.0;\n    float p = 1.0;\n\n    float ic = 1.0-c;\n    //float p = 0.0;//sin(seg/100000.0);\n    float ip = 1.0-p;\n    t=mod(t,256.0);\n    float y=0.0;   \n    float s=1.0;\n\ty = mn;\n\n    if ( ( t < (126.0 * p ) ) || ( t > ( 128.0 ) ) )\n    {\n        s = -1.0;\n        y = mn;\n        float width = (254.0 * ic )+2.0; \n        float start = 128.0 -width;\n        float startlow = mod(start,256.0);\n        float end = start + width;\n        if ((( t > start ) && ( t < end )) || (( t > (start + 256.0) && ( t < end + 256.0))))\n        {\n\t        float tmod = (t +256.0 - startlow );\n    \t    tmod = mod( tmod, 256.0);\n        \ttmod = (tmod) * 256.0/width;\n\t\t\ty=(tmod*range/256.0)+mn;            \n        }\n    }\n    return ( y / range );\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float pi = 3.1415626;\n    float t = time*10000.0;//scale time here\n    float mx = 32768.0;\n    float mn = -32768.0;\n    float range = mx - mn;\n    float seg = floor(t/256.0);\n    float segstart = seg*256.0;\n    float section = floor(seg/(100.0*pi));\n    float sectionstart = seg*100.0*pi*256.0;\n\n    float a = 128.0*(1.0+sin(seg/100.0));\n    float b = sin(seg/200.0);\n    float c = (1.0-cos(seg/400.0))/2.0;\n    float p = 0.0;//sin(seg/100000.0);\n    float y=0.0;   \n    t=mod(t,256.0);\n    float s=1.0;\n\n    float select = mod(section,8.0);\n    if ( select < 1.0 ){\n       \ta = 0.0;\n       \tb = -1.8*cos(seg/200.0);\n       \tc = 0.0;\n       \tp = 0.0;\n    }\n    else if (select < 2.0 ){\n       \ta = 128.0*(-cos(seg/200.0));\n       \tb = 0.0;\n       \tc = 0.0;\n       \tp = 0.0;\n    }\n    else if (select < 3.0 )\n    {\n\t\ta = 128.0;\n       \tb = -sin(seg/200.0);\n       \tc = 0.0;\n       \tp = 0.0;\n    }\n    else if (select < 4.0 )\n    {\n\t\ta = 128.0;\n       \tb = 1.0;\n       \tc = cos(seg/200.0);\n       \tp = 0.0;\n    }\n    else if ( select < 5.0 )\n    {\n\t\ta = 128.0;\n       \tb = 1.0;\n       \tc = 1.0;\n       \tp = sin(seg/200.0);\n    }\n    else if (select < 6.0 )\n    {\n       a = 255.0;\n       b = 1.0;\n       c = sin(seg/200.0);\n       p = 1.0;     \n       y= audiowave_pulse_to_saw(time,c);\n        return( vec2(y));\n    }\n    else if (select < 7.0 )\n    {\n       a = 255.0*(-cos(seg/200.0));\n       b = 0.0;\n       c = 0.0;\n       p = 0.0;     \n    }\n    else if (select < 8.0 )\n    {\n       a = 0.0;\n       b = -1.8*sin(seg/200.0);\n       c = 0.0;\n       p = 0.0;     \n    }    \n        \n    //float ia = 1.0-a;\n    float ib = 1.0-b;\n    float ic = 1.0-c;\n    float ip = 1.0-p;\n\n    if ( ( t < (126.0 * p ) ) || ( t > ( 128.0 ) ) )\n    {\n        s = -1.0;\n    }\n    \n\n    if ( t<(128.0-((256.0-a)/2.0)) )\n    {\n    \ty=\tic*\n            (\n                b*\n                mx*\n                sin(\n                    2.0*\n                    pi*\n                    (\n                        t/\n                        (2.0*a)\n                    )\n\t\t\t\t)+\n                ib*\n                range*\n                (\n                    t/\n                    a\n                )                \n            )+\n            (\n                c*\n                mx*\n                s\n            );\n    }\n    else if (t<(128.0+((256.0-a)/2.0)))\n    {\n        y= \tic * \n           \t(\n           \t\tb*\n                mx*\n                sin(\n                   \t2.0*\n                   \tpi*\n                   \t(\t\n                     \t0.25+\n                      \t(\n                           \t( \n                                t - \n                           \t\t(a/2.0)\n                        \t)\n                        \t/\n                        \t(\n                            \t512.0-\n                            \t(2.0*a)\n                        \t)\n                      \t)\n                 \t)\n\t\t\t\t)+\n                (\n                   \tib*\n                   \trange*\n                   \t(\n                       \t(128.0-t)/\n                       \t(256.0-a)\n                   \t)\n                )\n\t\t\t)+\n            (mx*c*s);\n    }\n    else\n    {\n        y=\tic*\n            (\n                b*\n                mx*\n                sin(\n                    2.0*\n                    pi*\n                    (\n                        0.5+\n                        (\n                            (\n                                t-\n                                a-\n                                256.0\n                            )\n                            /\n                            (\n                                2.0*\n                                a\n                            )\n                        )\n                    )\n                )\n\t            +\n    \t        ib*\n        \t    range*\n            \t(\n                \t(\n                    \tt-\n                    \t256.0\n                \t)\n                \t/\n                \ta\n            \t)\n            )+\n            (\n                mx*\n                c*\n                s\n            );\n    }\n    float o = y/range;///max;\n    \n    return vec2(o);// ,sin(time*10000.0));\n}","name":"Sound","description":"","type":"sound"}]}