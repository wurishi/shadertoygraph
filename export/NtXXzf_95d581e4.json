{"ver":"0.1","info":{"id":"NtXXzf","date":"1626159073","viewed":180,"name":"RayCaster Experiment 7.5","username":"Yusef28","description":"Features: Cheap look up and down Texure, Cheap Sky Texture, Optional Mouse Movement\nI would only read my comments in conjuction with the lodev tutorial:\nhttps://lodev.org/cgtutor/raycasting.html\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raycaster"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\n//KORONAL - A Gift Of Consciousness (FULL ALBUM) 2021 Progressive Deathcore | Math Metal | Djent\n//Main learning resource https://lodev.org/cgtutor/raycasting.html\n\n\n\n#define MAP_WIDTH 5\n#define MAP_HEIGHT 7\n#define MAP_LENGTH MAP_WIDTH*MAP_HEIGHT\n\nprecision highp float;\n\n//The map is from MonkeyIsBack: https://www.shadertoy.com/view/4dG3RD\nbool map2(int x,int y){\n\n    if (y >= 0 && y <= 9) {\n        if (x == 0 || x == 9)\n            return true;\n    }\n    if (x >= 0 && x <= 9) {\n        if (y == 0 || y == 9)\n            return true;\n    }\n\n    if (x == 2 && y == 2)\n        return (true);\n    if (x == 2 && y == 4)\n        return (true);\n    if (x == 2 && y == 6)\n        return (true);\n    if (x == 2 && y == 7)\n        return (true);\n    \n    if (x == 4 && y == 2)\n        return (true);\n    if (x == 4 && y == 4)\n        return (true);\n    if (x == 4 && y == 6)\n        return (true);\n    if (x == 4 && y == 7)\n        return (true);\n    \n    if (x == 6 && y == 2)\n        return (true);\n    if (x == 6 && y == 4)\n        return (true);\n    if (x == 6 && y == 6)\n        return (true);\n    if (x == 6 && y == 7)\n        return (true);\n\n\treturn false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Step 0: set up a color\n    vec3 col = vec3(0.);\n     \n    //Step 1: Initialize the vectors that give this whole simulation it's structure:\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)*2./iResolution.xy;\n    //having the uv moving here affects things later and creates\n    //a moving texture problem\n    uv.y += sin(iTime)*0.5;\n    //let's start with ground and sky already there\n    //col = mix(vec3(0.4,0.7,0.5),texture(iChannel1,vec2(uv.x,1./uv.y)).rgb,step(0.0,uv.y));\n    \n    //camera origin. Where the person is.\n    vec2 co =vec2(2.,6.);\n    \n    \n    //set to 1 for interesting mouse movement\n    #if 0\n    co = vec2(float(MAP_WIDTH)  * (iMouse.x / iResolution.x),\n          float(MAP_HEIGHT) * (iMouse.y / iResolution.y));\n    #endif\n    float rt= iTime/5.;\n    float si = sin(rt);\n    float cs = cos(rt);\n    //camera direction. Where the person is looking.\n    vec2 cd = vec2(0.,1.)*mat2(cs,-si,si,cs);\n    \n    //project plane is a perpendicular plane(line)\n    vec2 po = co + cd;\n    //the direction of the project plane is perpendicular to the camera direction\n\n    vec2 pd = cd*mat2(0.,-1.,1.,0.);// rotate 90degs\n    //ray origin \n    //the camera...\n    vec2 ro = co ;\n    //and directed by\n    //a percentage of the plane direction (perpendicular to camera direction)\n\n    vec2 rd = cd + pd*uv.x; //* pd*uv.x - ro\n    \n    //That's step 1 so if you don't know. Now you know.\n\n    //Step 2:\n    //Initialize the essecial distances of the Digital Differential Analysis Algorithm.\n\n    \n    //these are more like ancors for the other calculations\n    //the two components of the starting position vector.\n    //It's easier to just keep them separate.\n    float currentX,currentY; \n    float firstX,firstY;\n    //we obsever that for any given line on a grid between two\n    //neighboring grid lines on an axis, (like x = 1. and x = 2.)\n    //we'll have a corresponding y distance that wont change, and a hypotenuse\n    //(Which is the actuall ray distance traveled from x1 to x2) which \n    //also wont change.\n    \n    //Whenever we move 1 unit from x to x, we move \"dx\" along the ray\n    //Whenever we move 1 unit from y to y, we move \"dy\" along the ray\n    float dx,dy;\n    \n    //These are the 1 unit portions x,y which will be positive if\n    //that component of the ray is positive, otherwise negative.\n    float stepX,stepY;\n\n    \n    //*rd.x > 0.0 ? floor(ro.x) : ceil(ro.x)\n    firstX = floor(ro.x);\n    //and same for y\n    firstY = floor(ro.y);\n    //rd.y > 0.0 ? floor(ro.y) : ceil(ro.y);\n    //this isn't on the ray, but it's the square we are in.\n    \n    //Missing from lodev tutorial is this simple substitution\n    \n    //y = mx where m = slope = rd.y/rd.x.\n    //and c^2 = a^2 + b^2 where c is hypotenuse (H) or distance travlled on ray,\n    //and a is x and b is y.\n    //what we want to get is the ratio of either of these, with hypotenuse.\n    //like, H/x or H/y becuase then we can multiply h/x by the distance\n    //travelled from x1 to x2 (which is 1) and come out with the distance travlled\n    //along the ray from x1 to x2 since that's what H is. 1 * H/1 = H\n    \n    //y = mx -> h^2 = x^2 + y^2 -> h^2 = x^2 + (mx)^2 \n    // h^2 = x^2(1 + m^2)\n    // h^2/x^2 = 1 + m^2 \n    // h/x = sqrt(1+m^2)\n    //That's for x! for y, we just use m = x/y (we flip them) \n    //to get our h/y ratio. \n    \n    //x = rd.x and y = rd.y and m = rd.y/rd.x\n\n    \n    //if rd.x is 0 we got a problem so in that CASE we'll add a small number\n    dx = rd.x != 0.0 ? abs(1./rd.x) : abs(1./(rd.x + 0.00001));\n    dy = rd.y != 0.0 ? abs(1./rd.y) : abs(1./(rd.y + 0.00001));\n    //so we have our ratios/distances and we are going to abuse the sh*t out of them.\n\n    //*\n    currentX = rd.x < 0.0 ? (ro.x - firstX)*dx : (firstX + 1. - ro.x)*dx;\n    currentY = rd.y < 0.0 ? (ro.y - firstY)*dy : (firstY + 1. - ro.y)*dy;\n    \n\n    //from ray direction:\n    stepX = rd.x > 0.0 ? 1. : -1.; \n    stepY = rd.y > 0.0 ? 1. : -1.; \n    \n\n    //if we hit a wall, it could be either n/s or e/w and we can color slightly\n    //differently depending to get a shading effect.\n    float side = 0.;\n    float endDist;\n    //if we don't hit anything we'll color the sky and ground\n    float hit = 0.;\n\n    for(int i = 1; i < 10; i++){\n    \n        //we can check first. To do that we find the current closest\n        //distance to us along the ray. And there are only two possibilities.\n        //the distane to touch or closest x or closest y grid line.\n        //\n        if(hit == 1.){break;}\n        \n        if(currentX < currentY){\n        \n            currentX += dx;\n            firstX += stepX;\n           // xDist += stepX;\n            side = 0.;\n        }\n        else\n        {\n            currentY += dy;\n            firstY += stepY;\n           // yDist += stepY;\n            side = 1.;\n        }\n       \n       if(map2(int(firstX),int(firstY))){\n            hit = 1.;\n        }\n        \n\n\n    }\n    //after the loop\n    \n    //there are a bunch of rations from triangles formed by\n    //the euclidean distance to the hit point, the perpendicular path\n    //from projection plane to hit point, etc. Using these we get a bunch of fractions\n    //and we can use basic algebra to solve for the perpendicular distance.\n    //there is an effective diagram of this in the lodev tutorial\n        \n        \n        if(side == 1.){\n        \n        //Perpendicular Distnace = endDist here.\n        //rd component takes care of the sign?\n            endDist = abs((firstY - ro.y + (1. - stepY)/2.)/rd.y);\n        }\n        else{\n            endDist = abs((firstX - ro.x + (1. - stepX)/2.)/rd.x);\n        }\n        \n        //endDist 1 = full height, 1000. = zero height\n        float height = 1./endDist;\n\n        float texX,texY;\n        \n        float wallP = side == 1. ? ro.x + endDist*rd.x : ro.y + endDist*rd.y;\n        wallP = fract(wallP);\n        texX = wallP;//*1024 *text_width from lodev not nessesary\n        \n        //this from lodev was not nessesary\n        //if(side == 0. && rd.x > 0.){texX = 1024. - texX - 1.;}\n        //if(side == 1. && rd.y < 0.){texX = 1024. - texX - 1.;}\n        \n        col = mix(vec3(0.4,0.7,0.5),texture(iChannel1,vec2(uv.x,1./uv.y)).rgb,step(0.0,uv.y));\n    \n        //I break away from the lodev tutorial and get texturing like this for now\n        vec3 tex = texture(iChannel0, vec2(texX, (uv.y/height))).xyz;\n        \n        col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}