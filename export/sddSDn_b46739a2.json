{"ver":"0.1","info":{"id":"sddSDn","date":"1632971483","viewed":47,"name":"Mandelbrot Set (SovietSalman)","username":"SovietSalman","description":"Renders the Mandelbrot Set, the function f(z)=z^2+c. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["julia","mandelbrot","numbers","complex","set"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 complexMult(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nfloat complexAbs(vec2 a)\n{\n    return sqrt(a.x * a.x + a.y * a.y);\n}\n\nvec2 linInterp(vec4 a, vec2 n)\n{\n  return vec2(a.x + n.x * (a.y - a.x), a.z + n.y * (a.w - a.z));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nrgb hsv2rgb(hsv in)\n{\n    double      hh, p, q, t, ff;\n    long        i;\n    rgb         out;\n\n    if(in.s <= 0.0) {       // < is bogus, just shuts up warnings\n        out.r = in.v;\n        out.g = in.v;\n        out.b = in.v;\n        return out;\n    }\n    hh = in.h;\n    if(hh >= 360.0) hh = 0.0;\n    hh /= 60.0;\n    i = (long)hh;\n    ff = hh - i;\n    p = in.v * (1.0 - in.s);\n    q = in.v * (1.0 - (in.s * ff));\n    t = in.v * (1.0 - (in.s * (1.0 - ff)));\n\n    switch(i) {\n    case 0:\n        out.r = in.v;\n        out.g = t;\n        out.b = p;\n        break;\n    case 1:\n        out.r = q;\n        out.g = in.v;\n        out.b = p;\n        break;\n    case 2:\n        out.r = p;\n        out.g = in.v;\n        out.b = t;\n        break;\n\n    case 3:\n        out.r = p;\n        out.g = q;\n        out.b = in.v;\n        break;\n    case 4:\n        out.r = t;\n        out.g = p;\n        out.b = in.v;\n        break;\n    case 5:\n    default:\n        out.r = in.v;\n        out.g = p;\n        out.b = q;\n        break;\n    }\n    return out;     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (vec2(2.0*fragCoord.x,iResolution.y)-fragCoord)/iResolution.xy;\n\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float s = 0.1;\n    vec2 xRange = vec2(0.27-2.0*s,0.27+ 2.0*s);\n    vec2 yRange = vec2(-s, s);\n    \n    vec2 z = linInterp(vec4(xRange,yRange),uv);\n    vec2 c = z;\n    \n    for(int i = 0; i < 500; i++)\n    {\n        z = complexMult(z,z);\n        z += c;\n        if(complexAbs(z)>2.0) \n        {\n            col = hsv2rgb(vec3(float(i%15)/15.0, 1.0, 1.0));\n            break;\n        }\n        col = vec3(0.0,0.0,0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}