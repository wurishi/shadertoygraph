{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define TMIN     0.1\n#define TMAX     5000.0\n\n#define ID_NONE           -1.0\n#define ID_FLOOR           0.10\n#define ID_CEILING         0.11\n#define ID_WALL_BACK       0.12\n#define ID_WALL_RIGHT      0.13\n#define ID_WALL_LEFT       0.14\n#define ID_LIGHT           0.15\n#define ID_SPHERE_REFRACT  0.16\n#define ID_SPHERE_REFLECT  0.17\n#define ID_VOID            1.0\n\n#define GLASS_REFRACTION_INDEX    1.5\n\n// http://www.graphics.cornell.edu/online/box/data.html\nconst vec4 FLOOR          = vec4(278.0, 0.0, 279.6, ID_FLOOR);\nconst vec4 CEILING        = vec4(278.0, 0.0, 279.6, ID_CEILING);\nconst vec4 WALL_BACK      = vec4(278.0, 274.4, 0.0, ID_WALL_BACK);\nconst vec4 WALL_RIGHT     = vec4(0.0, 274.4, 279.6, ID_WALL_RIGHT);\nconst vec4 WALL_LEFT      = vec4(0.0, 274.4, 279.6, ID_WALL_LEFT);\nconst vec4 LIGHT          = vec4(65.0, 0.0, 52.5, ID_LIGHT);\nconst vec4 SPHERE_REFRACT = vec4(80.0, 0.0, 0.0, ID_SPHERE_REFRACT);\nconst vec4 SPHERE_REFLECT = vec4(100.0, 0.0, 0.0, ID_SPHERE_REFLECT);\n\nconst vec3 lightPos = vec3(278.0, 0.0, 279.6);\n\nfloat sdBox(in vec3 p, in vec3 box) {\n   vec3 d = abs(p) - box;\n   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n   return length(p) - s;\n}\n\nvec2 intersectSpheres(in vec3 p, bool refrSph) {\n    // hit object ID is stored in res.x, distance to object is in res.y\n\n    vec2 res = vec2(ID_VOID, 2000.0);\n\n    if (refrSph) res = vec2(ID_SPHERE_REFRACT, sdSphere(p + vec3(380.0, 468.8, 166.0), SPHERE_REFRACT.x));\n    vec2 obj = vec2(ID_SPHERE_REFLECT, sdSphere(p + vec3(190.0, 448.8, 365.0), SPHERE_REFLECT.x));\n    if (obj.y < res.y) res = obj;\n\n    return res;\n}\n\nvec2 intersect(in vec3 p, bool refrSph) {\n    // hit object ID is stored in res.x, distance to object is in res.y\n\n    vec2 res = vec2(ID_VOID, 2000.0);\n\n    vec2 obj = vec2(ID_LIGHT, sdBox(p + lightPos, LIGHT.xyz));\n    if (obj.y < res.y) res = obj;\n\n    obj = vec2(ID_FLOOR, sdBox(p + vec3(278.0, 548.8, 279.6), FLOOR.xyz));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_CEILING, sdBox(p + vec3(278.0, 0.0, 279.6), CEILING.xyz));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_WALL_BACK, sdBox(p + vec3(278.0, 274.4, 559.2), WALL_BACK.xyz));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_WALL_RIGHT, sdBox(p + vec3(556.0, 274.4, 279.6), WALL_RIGHT.xyz));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_WALL_LEFT, sdBox(p + vec3(0.0, 274.4, 279.6), WALL_LEFT.xyz));\n    if (obj.y < res.y) res = obj;\n\n    obj = intersectSpheres(p, refrSph);\n    if (obj.y < res.y) res = obj;\n\n    return res;\n}\n\nvec2 intersect(in vec3 p) {\n    return intersect(p, true);\n}\n\nvec2 raymarchScene(in vec3 ro, in vec3 rd, in float tmin, in float tmax, bool refrSph) {\n    vec3 res = vec3(ID_NONE);\n    float t = tmin;\n    for (int i = 0; i < 250; i++) {\n        vec3 p = ro + rd * t;\n        res = vec3(intersect(p, refrSph), t);\n        float d = res.y;\n        if (d < (0.001 * t) || t > tmax)\n            break;\n        t += 0.5 * d;\n    }\n    return res.xz;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 eps = vec2(0.005, 0.0);\n    return normalize(vec3(intersect(p + eps.xyy).y - intersect(p - eps.xyy).y,\n                          intersect(p + eps.yxy).y - intersect(p - eps.yxy).y,\n                          intersect(p + eps.yyx).y - intersect(p - eps.yyx).y));\n}\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = intersect(p).y;\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.00125 * ao;\n}\n\nfloat raymarchShadows(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 50; i++) {\n        vec3 p = ro + rd * t;\n        float d = intersectSpheres(p, true).y;\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            break;\n    }\n    return sh;\n}\n\nvec3 getLightColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {\n    vec3 difColor = vec3(18.4, 15.6, 8.0);\n\n    // main light\n    vec3 lightDir = normalize(vec3(-lightPos.x, -125.0, -lightPos.z) - pos);\n    float lightDist = length(vec3(-lightPos.x, -125.0, -lightPos.z) - pos);\n    float dif = max(0.0, dot(nor, lightDir));\n    vec3 h = normalize(-rd + lightDir);\n    float spe = pow(clamp(dot(h, nor), 0.0, 1.0), 4.0);\n    vec3 lightColor = dif * difColor * (1.0 / lightDist);\n    lightColor += 0.25 * dif * spe * difColor;\n\n    lightDir = normalize(vec3(-lightPos.x, 350.0, -lightPos.z) - pos);\n    float sha = clamp(raymarchShadows(pos, lightDir, 0.5, 500.0), 0.0, 1.0);\n    float id = obj.x;\n    if (id != ID_LIGHT && id != ID_CEILING) lightColor *= sha;\n\n    // light bounce on back wall\n    lightDir = normalize(vec3(-278.0, -274.4, -55.0) + pos);\n    lightDist = length(vec3(-278.0, -274.4, -55.0) + pos);\n    dif = max(0.0, dot(nor, lightDir));\n    h = normalize(-rd + lightDir);\n    spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);\n    lightColor += dif * vec3(0.25, 0.175, 0.1) * (1.0 / lightDist);\n    lightColor += 0.5 * dif * spe * vec3(0.25, 0.175, 0.1);\n\n    // light bounce on right wall\n    lightDir = normalize(vec3(-556.0, -274.4, -279.6) - pos);\n    lightDist = length(vec3(-556.0, -274.4, -279.6) - pos);\n    dif = max(0.0, dot(nor, lightDir));\n    h = normalize(-rd + lightDir);\n    spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);\n    lightColor += dif * vec3(0.0, 0.5, 0.0) * (1.0 / lightDist);\n    lightColor += 0.5 * dif * spe * vec3(0.0, 0.5, 0.0);\n\n    // light bounce on left wall\n    lightDir = normalize(vec3(0.0, -274.4, -279.6) - pos);\n    lightDist = length(vec3(0.0, -274.4, -279.6) - pos);\n    dif = max(0.0, dot(nor, lightDir));\n    h = normalize(-rd + lightDir);\n    spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);\n    lightColor += dif * vec3(1.5, 0.0, 0.0) * (1.0 / lightDist);\n    lightColor += 0.5 * dif * spe * vec3(1.5, 0.0, 0.0);\n\n    float amb = clamp(0.75 + 0.25 * nor.y, 0.0, 1.0);\n    lightColor += 0.015 * amb * difColor;\n\n    return lightColor;\n}\n\nvec3 getWallColor(in vec2 obj) {\n    vec3 color = vec3(0.0);\n    float id = obj.x;\n    if (id == ID_FLOOR) color = vec3(0.25, 0.175, 0.1);\n    if (id == ID_CEILING) color = vec3(0.25, 0.175, 0.1);\n    if (id == ID_WALL_BACK) color = vec3(0.25, 0.175, 0.1);\n    if (id == ID_WALL_RIGHT) color = vec3(0.0, 0.05, 0.0);\n    if (id == ID_WALL_LEFT) color = vec3(0.25, 0.0, 0.0);\n    if (id == ID_LIGHT) color = vec3(10.0);\n    return color;\n}\n\nvec3 getBoxColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {\n    vec3 color = getWallColor(obj);\n    float occ = clamp(raymarchAO(pos, nor, 80.0), 0.0, 1.0);\n    color *= getLightColor(obj, pos, rd, nor) * occ;\n    return color;\n}\n\nvec3 getMirrorBallColor(in vec3 pos, in vec3 rd, in vec3 nor) {\n    vec3 refl = reflect(rd, nor);\n    vec2 robj = raymarchScene(pos, refl, TMIN, TMAX, true);\n    vec3 rpos = pos + refl * robj.y;\n    vec3 rnor = getNormal(rpos);\n    vec3 color = getWallColor(robj);\n    float occ = clamp(raymarchAO(rpos, rnor, 80.0), 0.0, 1.0);\n    if (robj.x == ID_SPHERE_REFRACT) {\n        vec3 rrefl = reflect(refl, rnor);\n        vec2 reflObj = raymarchScene(rpos, rrefl, TMIN, TMAX, true);\n        vec3 reflPos = rpos + rrefl * reflObj.y;\n        vec3 reflNor = getNormal(reflPos);\n        float reflOcc = clamp(raymarchAO(reflPos, reflNor, 80.0), 0.0, 1.0);\n        vec3 refr = refract(refl, rnor, 1.0 / (GLASS_REFRACTION_INDEX * 2.0));\n        robj = raymarchScene(rpos, refr, TMIN, TMAX, false);\n        rpos = rpos + refr * robj.y;\n        rnor = getNormal(rpos);\n        color = getWallColor(robj);\n        float occ = clamp(raymarchAO(rpos, rnor, 80.0), 0.0, 1.0);\n        color *= occ;\n        color = mix(color, getWallColor(reflObj) * reflOcc, 0.02);\n    }\n    color *= getLightColor(robj, rpos, refl, rnor) * occ;\n\n    return color;\n}\n\nvec3 getGlassBallColor(in vec3 pos, in vec3 rd, in vec3 nor) {\n    vec3 refl = reflect(rd, nor);\n    vec2 reflObj = raymarchScene(pos, refl, TMIN, TMAX, true);\n    vec3 reflPos = pos + refl * reflObj.y;\n    vec3 reflNor = getNormal(reflPos);\n    float reflOcc = clamp(raymarchAO(reflPos, reflNor, 80.0), 0.0, 1.0);\n    vec3 refr = refract(rd, nor, 1.0 / GLASS_REFRACTION_INDEX);\n    vec2 robj = raymarchScene(pos, refr, TMIN, TMAX, false);\n    vec3 rpos = pos + refr * robj.y;\n    vec3 rnor = getNormal(rpos);\n    vec3 color = getWallColor(robj);\n    float occ = clamp(raymarchAO(rpos, rnor, 80.0), 0.0, 1.0);\n    if (robj.x == ID_SPHERE_REFLECT) {\n        vec3 rrefl = reflect(refr, rnor);\n        robj = raymarchScene(rpos, rrefl, TMIN, TMAX, true);\n        rpos = rpos + rrefl * robj.y;\n        rnor = getNormal(rpos);\n        color = getWallColor(robj);\n        if (robj.x == ID_SPHERE_REFRACT) {\n            vec3 rrefr = refract(rrefl, rnor, 1.0 / (GLASS_REFRACTION_INDEX * 2.0));\n            vec2 rrobj = raymarchScene(rpos, rrefr, TMIN, TMAX, false);\n            vec3 rrpos = rpos + rrefr * rrobj.y;\n            vec3 rrnor = getNormal(rrpos);\n            color = getWallColor(rrobj);\n            float occ = clamp(raymarchAO(rrpos, rrnor, 80.0), 0.0, 1.0);\n            color *= occ;\n        }\n        float occ = clamp(raymarchAO(rpos, rnor, 80.0), 0.0, 1.0);\n        color *= occ;\n    }\n    vec3 reflColor = getWallColor(reflObj);\n    reflColor *= reflOcc;\n    if (reflObj.x == ID_SPHERE_REFLECT) {\n        vec3 rrefl = reflect(refl, reflNor);\n        reflObj = raymarchScene(reflPos, rrefl, TMIN, TMAX, true);\n        reflPos = reflPos + rrefl * reflObj.y;\n        reflNor = getNormal(reflPos);\n        reflColor = getWallColor(reflObj);\n        float occ = clamp(raymarchAO(reflPos, reflNor, 80.0), 0.0, 1.0);\n        reflColor *= occ;\n    }\n    color *= getLightColor(robj, rpos, refr, rnor) * occ;\n    color = mix(color, reflColor, 0.02);\n\n    return color;\n}\n\nvec3 getFloorColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {\n    vec3 color = getBoxColor(obj, pos, rd, nor);\n    vec3 lightDir = normalize(vec3(-lightPos.x, 500.0, -lightPos.z) - pos);\n    vec2 robj = raymarchScene(pos, lightDir, TMIN, TMAX, true);\n    if (robj.x == ID_SPHERE_REFRACT) {\n        vec3 rpos = pos + lightDir * robj.y;\n        vec3 rnor = getNormal(rpos);\n        vec3 refr = refract(lightDir, rnor, 1.0 / GLASS_REFRACTION_INDEX);\n        robj = raymarchScene(rpos, refr, TMIN, TMAX, false);\n        rpos = rpos + refr * robj.y;\n        rnor = getNormal(rpos);\n        if (robj.x == ID_LIGHT) {\n            vec3 difColor = vec3(18.4, 15.6, 8.0);\n            float occ = clamp(raymarchAO(pos, nor, 80.0), 0.0, 1.0);\n            color = mix(color, difColor * occ, 0.05);\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 eye = vec3(278.0, 273.0, -800.0);\n    vec2 rot = 6.2831 * (vec2(0.085, 0.01) + vec2(1.0, 0.5) * (iMouse.xy - iResolution.xy * 0.5) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(-278.0, -274.4, -279.6);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 2.75));\n\n    // background\n    vec3 color = vec3(0.0);\n\n    vec2 obj = raymarchScene(ro, rd, TMIN, TMAX, true);\n    float id = obj.x;\n    if (id != ID_VOID) {\n        float t = obj.y;\n        vec3 pos = ro + rd * t;\n        vec3 nor = getNormal(pos);\n\n        if (id == ID_SPHERE_REFRACT) {\n            color = getGlassBallColor(pos, rd, nor);\n        }\n        else if (id == ID_SPHERE_REFLECT) {\n            color = getMirrorBallColor(pos, rd, nor);\n        }\n        else if (id == ID_FLOOR) {\n            color = getFloorColor(obj, pos, rd, nor);\n        }\n        else {\n            color = getBoxColor(obj, pos, rd, nor);\n        }\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlB3RR","date":"1426425603","viewed":4281,"name":"Cornell Box variant","username":"jimmikaelkael","description":"Just a Cornell box variant with 2 spheres, one is perfectly reflective and the other primarily refractive.\nYou can rotate the box with mouse.","likes":36,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","reflection","refraction","sphere","glass","cornell"],"hasliked":0,"parentid":"","parentname":""}}