{"ver":"0.1","info":{"id":"3ljBDz","date":"1598731333","viewed":224,"name":"First Volumetric Rendering - AT","username":"athibaul","description":"Monte-Carlo pathtracing to render volumetric material, based on the paper Production Volumetric Rendering by Fong et al. (2017).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","pathtracing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FIRST VOLUMETRIC RENDERING\n\n// The scene is a cube with six emitting faces, containing \n// a volumetric material that absorbs/scatters all colors, \n// and emits blue light.\n\n// Use Closed-Form tracking of one ray\n// Algorithm from: Fong 2017, Production Volume Rendering\n// https://drive.google.com/file/d/1eFr_4IKzt796Ns4Iv3OjR3ni0Y7QigP5/view\n\n// CHANGELOG\n// --------------\n// Non-uniform density fields - DONE 30/08/2020\n\n\n// TODO-LIST\n// --------------\n// TODO Modify the algorithm to avoid absorption events.\n// Instead, let us gather the emitted contribution \n// and the total transmittance along the path,\n// so that one given ray always ends up exiting the volume.\n\n// TODO Multi-component RGB density fields\n// TODO Use diffuse faces in the scene?\n\nconst int BAILOUT = 100; // Maximum volumetric steps\nconst int SAMPLES = 50;\n\n\nfloat boxExitDistance( in vec3 ro, in vec3 rd )\n{\n    // How far is the exit of the unit box [-1,1]^3 ?\n    vec3 n = ro/rd;\n    vec3 k = 1.0/abs(rd);\n    //vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    return min(t2.x, min(t2.y, t2.z));\n}\n\nvec3 worldSurfaceColor( in vec3 pos )\n{\n    if(pos.x <= -0.999) return vec3(0.95, 0.0, 0.0);\n    if(pos.x >=  0.999) return vec3(0.0, 0.95, 0.0);\n    if(pos.z >=  0.999) return vec3(1.0);\n    if(pos.z <= -0.999) return vec3(0.2);\n    return vec3(0.8);\n}\n\nvec3 worldGetVolumetricEmission( in vec3 pos )\n{\n    // Color of the emission\n    return vec3(1.0, 2.0, 3.0);\n}\n\nvec3 samplePhaseFunction( in vec3 pos, in vec3 rd )\n{\n    // In case of scattering, where does the new ray go?\n    return randomInSphere();\n}\n\n// Volume density functions\n// ------------------------\n// Scattering coefficient\n//float sigma_s( in vec3 pos ){ return (length(pos)<1.0)? 5.0*0.5*(1.0+cos(iTime)) : 0.0; }\nfloat sigma_s( in vec3 pos ){\n    float v = smoothstep(0.0, 0.5, 1.0-length(pos));\n    v = max(v, 0.5*smoothstep(0.0,0.2, 0.5-length(pos-vec3(0.5,-0.2,-0.4))));\n    v = max(v, 0.8*smoothstep(0.0,0.2, 0.6-length(pos-vec3(-0.6,-0.4,0.0))));\n    return 10.0*0.5*(1.0+cos(iTime)) * v; \n}\n// Absorption coefficient\nfloat sigma_a( in vec3 pos ){ return 0.03 * sigma_s(pos); }\n// Majorant of sigma_a + sigma_s\n// MUST BE A MAJORANT EVERYWHERE ALWAYS\nfloat sigma_tilde(){ return 12.0; }\n// ------------------------\n\n\n\nvec3 ClosedFormTracking( in vec3 ro, in vec3 rd )\n{\n    float d = boxExitDistance(ro, rd);\n    float sigma_t = sigma_tilde();\n    for(int i=0; i<BAILOUT; i++)\n    {\n        // Sample the free-path length\n        float t = -log(1.0-random1f())/sigma_t;\n        \n        if(t > d) // A boundary has been hit\n        {\n            return worldSurfaceColor(ro + d * rd);\n        }\n        ro += t * rd;\n        float xi = random1f();\n        if(xi < sigma_a(ro)/sigma_t)\n        {\n            // An absorption + emission event has occurred\n            return worldGetVolumetricEmission(ro);\n        }\n        else if(xi < sigma_s(ro)/sigma_t)\n        {\n            // A scattering event has occurred\n            rd = samplePhaseFunction(ro, rd);\n            d = boxExitDistance(ro, rd);\n        }\n        else\n        {\n            // A null event has occured, just update the distance\n            d -= t;\n        }\n    }\n    // If looping for too long, absorb.\n    return vec3(0.0);\n}\n\nvec3 rendererCalculateColor( vec3 ro, vec3 rd )\n{\n    return ClosedFormTracking(ro, rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    if(abs(uv.x)>1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    \n    //sigma_s = 3.0 * (1.0+sin(iTime));\n    //sigma_t = sigma_a + sigma_s;\n    float fov = 0.5;\n    vec3 ro = vec3(uv.x, -1.0, uv.y);\n    vec3 rd = normalize(vec3(fov*uv.x, 1.0, fov*uv.y));\n    \n    float d = boxExitDistance(ro, rd);\n    vec3 pos = ro + d*rd;\n    //vec3 col = worldSurfaceColor(pos);\n    \n    seed = sqrt(2.0)*fragCoord.xy;\n    \n    \n    vec3 col = vec3(0.0);\n    for(int i=0; i<SAMPLES; i++)\n    {\n        col += rendererCalculateColor(ro, rd) / float(SAMPLES);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nvec2 seed = vec2(0.0);\nfloat random1f()\n{\n    seed.x += 1.0;\n    return hash12(seed);\n}\n\nvec2 random2f()\n{\n    seed.x += 1.0;\n    return hash22(seed);\n}\n\nvec3 randomInSphere()\n{\n    vec2 rnd = random2f();\n    float phi = 2.0*3.14159 * rnd.x;\n    float ct = 1.0 - 2.0*rnd.y;\n    float st = 2.0 * sqrt(rnd.y * (1.0 - rnd.y));\n    return vec3(cos(phi) * st, sin(phi) * st, ct);\n}","name":"Common","description":"","type":"common"}]}