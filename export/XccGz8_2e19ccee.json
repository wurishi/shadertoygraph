{"ver":"0.1","info":{"id":"XccGz8","date":"1711356752","viewed":109,"name":"Gold hypertexture spheres","username":"akr51","description":"First attempt at hypertexture using a noise function","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hypertexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nmat2 rot2(float t)\n{\n\n\n    float s = sin(t);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);\n    return rot;\n    \n}\n\n\n\nvec3 rot3(vec3 axis, vec3 p, float theta)\n{\n\n\n    return mix(dot(axis, p) * axis, p, cos(theta)) + cross(axis, p) * sin(theta);\n\n}\n\n\n\n\nfloat noise2(vec3 p)\n{\n\n\n    float xs = 11.0;\n    float ys = 11.0;\n    float zs = 11.0;\n    \n    return cos(p.x * xs) * sin(p.y * ys) * sin(p.z * zs) * 0.1;\n\n}\n\n\nfloat sphere(vec3 p, float radius)\n{\n\n    vec3 f = p;\n    \n    f.x = mod(f.x + iTime * 2.0, 9.0) - 0.5 * 9.0;\n    f.y = mod(f.y + iTime * 5.0, 9.0) - 0.5 * 9.0;\n    f.z = mod(f.z + iTime * 11.0, 9.0) - 0.5 * 9.0;\n   \n    \n    f = rot3(vec3(0.0, 1.0, 0.0), f, iTime);\n    return (length(f) - radius + noise2(f));\n\n}\n\n\n\nfloat map(vec3 p)\n{\n\n    \n    \n    return sphere(p, 1.0);\n\n}\n\n\nfloat march(vec3 ro, vec3 rd)\n{\n\n\n    float d0 = 0.0;\n    \n    for (int i = 0; i < 255; ++i)\n    {\n        \n        vec3 p = ro + rd * d0;\n        float ds = map(p);\n        d0 += ds * 0.8889;\n        \n        if (d0 > 255.0 || abs(ds) < 0.1)\n        {\n        \n            break;\n        \n        }\n        \n    \n    }\n   \n    return d0;\n}\n\n\n\nvec3 normal(vec3 p)\n{\n\n\n    vec2 d = vec2(0.1, 0.0);\n    return normalize(map(p) - vec3(map(p - d.xyy), map(p - d.yxy), map(p - d.yyx)));\n\n}\n\n\n\nvec3 rayDirection(vec2 uv, vec3 p, vec3 l, float z)\n{\n\n\n    vec3 f, r, u, c, i;\n    \n    f = normalize(l - p);\n    r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    u = cross(f, r);\n    c = f * z;\n    \n    return normalize(c + uv.x * r + uv.y * u);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n        \n    uv *= rot2(iTime * 0.2);     \n   \n    uv *= 0.20;\n\n    vec3 color = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 3.0, -3.0);\n    vec3 rd = rayDirection(uv, ro, vec3(0.0, 0.0, 0.0), 1.0);\n    \n    float d = march(ro, rd);\n    \n    if (d < 255.0)\n    {\n    \n        \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p);\n        \n        float dif = dot(n, normalize(vec3(1.0, 2.0, 3.0))) * 0.5 + 0.5;\n        color = vec3(pow(0.1 / dif, 8.0)) * vec3(1.0, 0.5, 0.1);\n    \n    }\n    \n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}