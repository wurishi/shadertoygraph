{"ver":"0.1","info":{"id":"XsBXDy","date":"1430462039","viewed":176,"name":"BRDF Lab Pathtraced","username":"Orihaus","description":":3","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(i) ( clamp( i, 0.0, 1.0 ) )\n\nconst float pi = 3.14159265;\nconst float tau = pi * 2.0;\nconst float halfpi = pi * 0.5;\nconst float oneoverpi  = 1.0 / pi;\nconst float oneovertau = 1.0 / tau;\n\nconst float ZMAX = 99999.0;\nconst float EPSILON = 0.001;\n\nstruct Intersection\n{\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n    bool hit;\n    vec3 color;\n    float emission;\n    float roughness;\n    vec2 uv;\n};\n\t\nstruct Light\n{\n    vec4 lightOrientation;\n    vec3 planarDirection;\n    vec3 planarRight;\n    vec3 planarUp;\n    vec3 lightExtents;\n    vec3 lightPosition;\n};\n    \nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\nstruct Plane\n{\n    vec2 extent;\n\tvec3 center;\n    \n    vec4 orient;\n    \n    vec3 color;\n    float emission;\n    float roughness;\n};\n     \nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n    float emission;\n    vec3 color;\n    float roughness;\n};\n    \n//\n    \nIntersection MinIntersection( Intersection a, Intersection b )\n{\n\tif( a.distance < b.distance )\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nIntersection RaySphere(Ray ray, Sphere sphere)\n{\n\tIntersection i;\n\ti.distance = ZMAX;\n\tvec3 c = sphere.c;\n\tfloat r = sphere.r;\n\tvec3 e = c-ray.origin;\n\tfloat a = dot(e, ray.direction);\n\tfloat b = r*r - dot(e,e) + a*a;\n\tif( b>0.0 )\n\t{\n\t\tfloat f = sqrt(b);\n\t\tfloat t = a - f;\n\t\tif(t > EPSILON)\n\t\t{\n\t\t\ti.position = ray.origin + ray.direction*t;\n\t\t\ti.normal = normalize(i.position-c);\n\t\t\ti.distance = t;\n            i.roughness = sphere.roughness;\n            i.emission = sphere.emission;\n            i.color = sphere.color;\n            i.hit = true;\n            i.uv = i.normal.xy;\n\t\t}\n\t}\n\treturn i;\n}\n\n//\n\nstruct Spatial\n{\n\tvec4 pos, rot;\n};\n\n// Construct Quaternion from Euler Angles\nvec4 constructQuaternion( vec3 angles )\n{\t\n    vec3 halfAngles = 0.5 * angles;\n    \n    float cos_z_2 = cos( halfAngles.z );\n    float cos_y_2 = cos( halfAngles.y );\n    float cos_x_2 = cos( halfAngles.x );\n\n    float sin_z_2 = sin( halfAngles.z );\n    float sin_y_2 = sin( halfAngles.y );\n    float sin_x_2 = sin( halfAngles.x );\n\n    // and now compute quaternion\n    vec4 quat;\n    quat.w = cos_z_2*cos_y_2*cos_x_2 + sin_z_2*sin_y_2*sin_x_2;\n    quat.x = cos_z_2*cos_y_2*sin_x_2 - sin_z_2*sin_y_2*cos_x_2;\n    quat.y = cos_z_2*sin_y_2*cos_x_2 + sin_z_2*cos_y_2*sin_x_2;\n    quat.z = sin_z_2*cos_y_2*cos_x_2 - cos_z_2*sin_y_2*sin_x_2;\n    return quat;\n}\n\nvec3 quaternionMultiply( vec4 quat, vec3 vector )\n{\n\tvec3 uv, uuv;\n    vec3 qvec = quat.xyz;\n    \n    uv = cross( qvec, vector );\n    uuv = cross( qvec, uv );\n    \n\tuv  *= ( 2.0 * quat.w );\n\tuuv *= 2.0;\n\n\treturn normalize( vector + uv + uuv );\n}\n\nvec3 rotateVector( vec4 quat, vec3 vec )\n{\n\treturn vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );\n}\n\nconst vec3 left = vec3( 1, 0, 0 );\nconst vec3 up = vec3( 0, 1, 0 );\nconst vec3 forward = vec3( 0, 0, 1 );\nconst vec4 quaternionIdentity = vec4( 0, 0, 0, 1 );\n\nvec3 linePlaneIntersect(in vec3 rayOrigin, in vec3 rayDirection, in vec3 planeCenter, in vec3 planeNormal )\n{\n\tfloat distanceToPlane = dot( planeNormal, planeCenter - rayOrigin ) / dot( planeNormal, rayDirection );\n\treturn rayOrigin + rayDirection * distanceToPlane;\n}\n\nIntersection RayPlane( Ray ray, Plane p )\n{\n\tIntersection i;\n    i.hit = false;\n\ti.distance = ZMAX;\n   \n    vec3 axisX = quaternionMultiply( p.orient, left );\n    vec3 axisY = quaternionMultiply( p.orient, forward );\n    vec3 axisZ = quaternionMultiply( p.orient, up );\n    \n\t// Intersect ray with plane\n    float distanceToPlane = dot( axisZ, p.center - ray.origin ) / dot( axisZ, ray.direction );\n    \n    if( distanceToPlane > EPSILON )\n    {\n        vec3 pointOnPlane = ray.origin + ray.direction * distanceToPlane;\n        vec3 toCenter = pointOnPlane - p.center;\n\n        float x_dot_c = dot( axisX, toCenter );\n        float y_dot_c = dot( axisY, toCenter );\n        float inExtentX = abs( x_dot_c );\n        float inExtentY = abs( y_dot_c );\n\n        vec2 extents = vec2( p.extent.x, p.extent.y );\n        if( inExtentY < extents.y && inExtentX < extents.x )\n        {\n            i.position = pointOnPlane;\n            i.normal = axisZ;//dot( axisZ, ray.direction ) < 0.0 ? axisZ : -axisZ;\n            i.distance = distanceToPlane;\n            i.hit = true;\n\n            vec2 scaledPosition = vec2( 0.5 + x_dot_c * 0.5, 0.5 + y_dot_c * 0.5 ) / extents;\n            i.uv = scaledPosition.xy;\t\n\n            i.emission  = p.emission;\n            i.roughness = p.roughness;\n            i.color = p.color;\n        }\n    }\n    \n\treturn i;\n}\n\nint sideOfPlane(in vec3 p, in vec3 pc, in vec3 pn)\n{\n   if (dot(p-pc,pn)>=0.0) return 1; else return 0;\n}\n\nvec3 projectOnPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) \n{\n    return point - dot( point - planeCenter, planeNorm ) * planeNorm;\n}\n\nvec3 closestPointOnRect( vec3 rect, vec3 extents, vec3 position, vec3 axisX, vec3 axisY, vec3 axisZ )\n{\n\tvec3 proj = projectOnPlane( position, rect, axisZ );\n\tvec3 dir = proj - rect;\n\n\tvec2 diagonal = vec2( dot( dir, axisX ), dot( dir, axisY ) );\n\tvec2 nearest2D = vec2( clamp( diagonal.x, -extents.x, extents.x ), clamp( diagonal.y, -extents.y, extents.y ) );\n    \n\tvec3 nearestPointInside = rect + ( axisX * nearest2D.x + axisY * nearest2D.y );\n\treturn nearestPointInside;\n}\n\n//\n\nPlane pone;\nPlane ptwo;\nPlane pthree;\nPlane pfour;\nPlane pfive;\nPlane psix;\nSphere sphere;\nSphere spheretwo;\n\n//\n\nIntersection projectRay( Ray ray )\n{\n    Intersection intersection;\n    \n\tintersection = RayPlane( ray, pone );\n\tintersection = MinIntersection( RayPlane( ray, ptwo ), intersection );\n\t//intersection = MinIntersection( RayPlane( ray, pthree ), intersection );\n\tintersection = MinIntersection( RayPlane( ray, pfour ), intersection );\n\tintersection = MinIntersection( RayPlane( ray, pfive ), intersection );\n\tintersection = MinIntersection( RayPlane( ray, psix ), intersection );\n    intersection = MinIntersection( RaySphere( ray, sphere ), intersection );\n    intersection = MinIntersection( RaySphere( ray, spheretwo ), intersection );\n    \n    return intersection;\n}\n\n//\n\nvec2 Hash22(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n\n// code from : http://www.rorydriscoll.com/2009/01/07/better-sampling/\n\nvec3 cosineWeightedDirection( vec2 uv, vec3 normal, float roughness ) \n{\n    float u = uv.x; float v = uv.y;\n    float r = sqrt(u);\n    float angle = 6.283185307179586 * v;\n    // compute basis from normal\n    vec3 sdir, tdir;\n    if (abs(normal.x)<.5) \n    {\n        sdir = cross(normal, vec3(1,0,0));\n    } \n    else \n    {\n        sdir = cross(normal, vec3(0,1,0));\n    }\n    tdir = cross(normal, sdir);\n    \n    return ( r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal ) * roughness;\n}\n\nvec3 TangentToWorld( vec3 Vec, vec3 TangentZ )\n{\n\tvec3 UpVector = abs( TangentZ.z ) < 0.999 ? vec3( 0.0, 0.0, 1.0 ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 TangentX = normalize( cross( UpVector, TangentZ ) );\n\tvec3 TangentY = cross( TangentZ, TangentX );\n\treturn TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n}\n\nvec3 ImportanceSampleGGX( vec2 E, float Roughness )\n{\n\tfloat m = Roughness * Roughness;\n\tfloat m2 = m * m;\n\n\tfloat Phi = 2.0 * pi * E.x;\n\tfloat CosTheta = sqrt( (1.0 - E.y) / ( 1.0 + (m2 - 1.0) * E.y ) );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\t\n\t//float d = ( CosTheta * m2 - CosTheta ) * CosTheta + 1.0;\n\t//float D = m2 / ( pi*d*d );\n\t//float PDF = D * CosTheta;\n\n\treturn H;\n}\n\nvec3 UniformSampleCone( vec2 E, float CosThetaMax )\n{\n\tfloat Phi = 2.0 * pi * E.x;\n\tfloat CosTheta = mix( CosThetaMax, 1.0, E.y );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 L;\n\tL.x = SinTheta * cos( Phi );\n\tL.y = SinTheta * sin( Phi );\n\tL.z = CosTheta;\n\n\t//float PDF = 1.0 / ( 2 * PI * (1 - CosThetaMax) );\n\n\treturn L;\n}\n\nvec3 UniformSampleHemisphere( vec2 E )\n{\n\tfloat Phi = 2.0 * pi * E.x;\n\tfloat CosTheta = E.y;\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\n\t//float PDF = 1.0 / (2 * PI);\n\n\treturn H;\n}\n\nvec3 getWeightedDirection( float seed, vec3 normal, vec3 incident, float roughness, vec3 view, vec2 ouv )\n{\n    vec2 uv = Hash22( vec2( iTime, seed ) * ouv.xy );\n    return cosineWeightedDirection( uv, normal, seed > 0.8 ? roughness : 1.0 );\n    \n    //if( seed < 0.0 )\n    \t//return TangentToWorld( UniformSampleHemisphere( uv, roughness ), incident );\n    //else\n    //    return TangentToWorld( UniformSampleCone( uv, 0.9 ), incident );\n    //return UniformSampleHemisphere( uv );\n}\n\n//\n\nfloat distributionBeckmann( float roughness, float n_dot_h )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NoH2 = n_dot_h * n_dot_h;\n\treturn exp( (NoH2 - 1.0) / (m2 * NoH2) ) / ( pi * m2 * NoH2 * NoH2 );\n}\n\nfloat distributionGGX( float roughness, float n_dot_h )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat d = ( n_dot_h * m2 - n_dot_h ) * n_dot_h + 1.0;\n\treturn m2 / ( pi*d*d );\n}\n\n// From : https://www.unrealengine.com/blog/physically-based-shading-on-mobile\n\nfloat EnvBRDFApproxNonmetal( float Roughness, float NoV )\n{\n    const vec2 c0 = vec2( -1.0, -0.0275 );\n    const vec2 c1 = vec2(  1.0,  0.0425 );\n    vec2 r = Roughness * c0 + c1;\n    return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n}\n\n//\n\nfloat Square( float s )\n{\n    return s*s;\n}\n\nfloat F_Fresnel( float SpecularColor, float VoH )\n{\n\tfloat SpecularColorSqrt = sqrt( clamp( 0.0, 0.99, SpecularColor ) );\n\tfloat n = ( 1.0 + SpecularColorSqrt ) / ( 1.0 - SpecularColorSqrt );\n\tfloat g = sqrt( n*n + VoH*VoH - 1.0 );\n\treturn 0.5 * Square( (g - VoH) / (g + VoH) ) * ( 1.0 + Square( ((g+VoH)*VoH - 1.0) / ((g-VoH)*VoH + 1.0) ) );\n}\n\nfloat F_Schlick( in float f90, in float u )\n{\n    float f = pow( 1.0 - u, 5.0 );\n\treturn f + ( 1.0 - f ) * f90;\n}\n\nfloat disneyDiffuse( float NdotV, float NdotL, float LdotH, float linearRoughness )\n{\n\tfloat energyBias = mix( 0.0, 0.5, linearRoughness );\n   \tfloat energyFactor = mix( 1.0, 1.0 / 1.51, linearRoughness );\n    \n\tfloat fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness;\n\n\tfloat lightScatter = F_Schlick( fd90, NdotL );\n\tfloat viewScatter  = F_Schlick( fd90, NdotV );\n\treturn lightScatter * viewScatter * energyFactor;\n}\n\nfloat V_SmithGGXCorrelatedOriginal( float NdotL, float NdotV, float alphaG )\n{\n\t// This is the optimize version\n\tfloat alphaG2 = alphaG * alphaG;\n    float NdotL2 = NdotL * NdotL;\n    float NdotV2 = NdotV * NdotV;\n    \n\tfloat lambda_v = (-1.0 + sqrt( alphaG2 * ( 1.0 - NdotL2 ) / NdotL2 + 1.0 ) ) * 0.5;\n\tfloat lambda_l = (-1.0 + sqrt( alphaG2 * ( 1.0 - NdotV2 ) / NdotV2 + 1.0 ) ) * 0.5;\n\tfloat G_SmithGGXCorrelated = 1.0 / ( 1.0 + lambda_v + lambda_l );\n\tfloat V_SmithGGXCorrelated = G_SmithGGXCorrelated / ( 4.0 * NdotL * NdotV );\n    return V_SmithGGXCorrelated;\n}\n\nfloat V_SmithGGXCorrelated( float NdotL, float NdotV, float alphaG )\n{\n\t// This is the optimize version\n\tfloat alphaG2 = alphaG * alphaG;\n\t// Caution : the \" NdotL *\" and \" NdotV *\" are explicitely inversed , this is not a mistake .\n\tfloat Lambda_GGXV = NdotL * sqrt((-NdotV * alphaG2 + NdotV ) * NdotV + alphaG2 );\n\tfloat Lambda_GGXL = NdotV * sqrt((-NdotL * alphaG2 + NdotL ) * NdotL + alphaG2 );\n\n\treturn 0.5 / ( Lambda_GGXV + Lambda_GGXL );\n}\n\nconst float PI = 3.14159265359;\nconst float oneoverPI = 1.0 / PI;\nfloat D_Beckmann( float NoH, float m )\n{\n\tfloat m2 = m * m;\n\tfloat NoH2 = NoH * NoH;\n\treturn exp( (NoH2 - 1.0) / (m2 * NoH2) ) / ( PI * m2 * NoH2 * NoH2 );\n}\n\nfloat D_GGX( float NdotH, float m )\n{\n\tfloat m2 = m * m;\n\tfloat f = ( NdotH * m2 - NdotH ) * NdotH + 1.0;\n\treturn m2 / (f * f);\n}\n\nfloat cot ( float x) { return cos (x) / sin (x); }\nfloat acot ( float x) { return atan (1.0 / x); }\n\nfloat illuminanceSphereOrDisk( float cosTheta , float sinSigmaSqr )\n{\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n\tfloat illuminance = 0.0;\n\tif ( cosTheta * cosTheta > sinSigmaSqr )\n\t{\n\t\tilluminance = PI * sinSigmaSqr * saturate( cosTheta );\n\t}\n\telse\n\t{\n        float x = sqrt( 1.0 / sinSigmaSqr - 1.0 ); // For a disk this simplify to x = d / r\n        float y = -x * ( cosTheta / sinTheta );\n        float sinThetaSqrtY = sinTheta * sqrt( 1.0 - y * y );\n        illuminance = ( cosTheta * acos( y ) - x * sinThetaSqrtY ) \n            * sinSigmaSqr + atan( sinThetaSqrtY / x );\n\t}\n\treturn max( illuminance , 0.0 );\n}\n\nfloat getSphereIlluminance( vec3 lightDirection, vec3 worldNormal, \n                            float lightRadius, float sqrDist )\n{\n\t/*float Beta = acos( dot( worldNormal, lightDirection ) );\n\tfloat H = sqrt( sqrDist );\n\tfloat h = H / lightRadius;\n\tfloat x = sqrt( h * h - 1.0 );\n\tfloat y = -x * ( 1.0 / tan( Beta ) );\n\n\tfloat illuminance = 0.0;\n\tif( h * cos ( Beta ) > 1.0 )\n\t\tilluminance = cos ( Beta ) / ( h * h );\n\telse\n    {\n\t\tilluminance = ( 1.0 / ( PI * h * h ) ) *\n\t\t\t( cos( Beta ) * acos ( y ) - x * sin( Beta ) * sqrt( 1.0 - y * y ) ) +\n\t\t\t( 1.0 / PI ) * atan( sin ( Beta ) * sqrt( 1.0 - y * y ) / x );\n\t}\n\n\tilluminance *= PI;*/\n    \n\tfloat cosTheta = clamp( dot( worldNormal , lightDirection ), -0.999, 0.999 );\n\tfloat sqrLightRadius = lightRadius * lightRadius;\n\tfloat sinSigmaSqr = min( sqrLightRadius / sqrDist, 0.9999 );\n    float illuminance = illuminanceSphereOrDisk( cosTheta, sinSigmaSqr );\n    return illuminance;\n}\n\nfloat smoothDistanceAtt( float squaredDistance , float invSqrAttRadius )\n{\n\tfloat factor = squaredDistance * invSqrAttRadius;\n\tfloat smoothFactor = saturate( 1.0 - factor * factor );\n\treturn smoothFactor * smoothFactor;\n}\n\nfloat getDistanceAtt( vec3 unormalizedLightVector, float invSqrAttRadius )\n{\n\tfloat sqrDist = dot ( unormalizedLightVector, unormalizedLightVector );\n\tfloat attenuation = 1.0 / ( max( sqrDist, 0.01 * 0.01 ) );\n    attenuation *= smoothDistanceAtt( sqrDist, invSqrAttRadius );\n    return attenuation;\n}\n\nvec3 DoLight( vec3 origin, vec3 lightPosition, vec3 normal, vec3 viewDirection )\n{\n    float lightRadius = 0.125;\n    \n    vec3 lightVector = ( lightPosition - origin );\n    \n    //\n    \n    vec3 R = reflect( -viewDirection, normal );\n    vec3 ClosestPointOnRay = dot( lightVector, R ) * R;\n    vec3 CenterToRay = ClosestPointOnRay - lightVector;\n    vec3 ClosestPointOnSphere = lightVector + CenterToRay \n       * saturate( lightRadius * inversesqrt( dot( CenterToRay, CenterToRay ) ) );\n    lightVector = ClosestPointOnSphere;\n    \n    //\n    \n\tvec3 light = normalize( lightVector );\n    \n    vec3 halfVector = normalize( viewDirection + light );\n    float n_dot_v = abs( dot( viewDirection, normal ) + 1e-5 );\n    float n_dot_l = saturate( dot( light, normal ) );\n    float l_dot_h = saturate( dot( light, halfVector ) );\n    float n_dot_h = saturate( dot( normal, halfVector ) );\n    \n    float roughness = 0.4;//saturate( sin( iTime ) );\n    float roughnessSquared = roughness * roughness;\n    \n    float fresnel = F_Schlick( 0.04, n_dot_v );\n    float visibility = V_SmithGGXCorrelated( n_dot_l, n_dot_v, roughnessSquared );\n    float distribution = D_GGX( n_dot_h, roughnessSquared );\n    float specular = distribution * fresnel * saturate( visibility * oneoverPI );\n    \n    float attenuation = getDistanceAtt( lightVector, 0.00007 );\n    float diffuse = oneoverPI;// * disneyDiffuse( n_dot_v, n_dot_l, l_dot_h, roughness );\n    \n    float illuminance = getSphereIlluminance( light, normal, \n                                              lightRadius, dot( lightVector, lightVector ) );\n    \n    //\n    \n    Ray shadowray;\n    shadowray.origin = origin;\n    shadowray.direction = light;\n    Intersection shadowintersect = projectRay( shadowray );\n    float shadow = shadowintersect.distance < length( lightVector ) ? 0.0 : 1.0; \n    \n    float final = illuminance * ( diffuse + specular );\n    return vec3( final );\n}\n\nvec3 getBRDF( Light light, Intersection intersect, vec3 incidentReflection, vec3 viewDirection, vec3 enviroment )\n{\n    return DoLight( intersect.position, light.lightPosition, intersect.normal, viewDirection );\n}\n\n// filmic without sRGB conversion\n\n// shoulder strength\nconst float A = 0.22;\n// linear strength\nconst float B = 0.3;\n// linear angle\nconst float C = 0.1;\n// toe strength\nconst float D = 0.20;\n// toe numerator\nconst float E = 0.01;\n// toe denominator\nconst float F = 0.30;\n// linear white point\nconst float W = 11.2;\nfloat filmic_curve(float x) {\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nfloat inverse_filmic_curve(float x) {\n    float q = B*(F*(C-x) - E);\n    float d = A*(F*(x - 1.0) + E);\n    return (q -sqrt(q*q - 4.0*D*F*F*x*d)) / (2.0*d);\n}\nvec3 filmic(vec3 x) {\n    float w = filmic_curve(W);\n    return vec3(\n        filmic_curve(x.r),\n        filmic_curve(x.g),\n        filmic_curve(x.b)) / w;\n}\nvec3 inverse_filmic(vec3 x) {\n    x *= filmic_curve(W);\n    return vec3(\n        inverse_filmic_curve(x.r),\n        inverse_filmic_curve(x.g),\n        inverse_filmic_curve(x.b));\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    float sintime = sin( iTime );\n    \n    pone.orient = quaternionIdentity;\n    pone.extent = vec2( 3, 1 );\n    pone.center = vec3( 0,-1, 0 );\n    pone.color = vec3( 1.0, 1.0, 1.0 );\n    pone.emission = 0.75;\n    pone.roughness = 0.9;\n\n    ptwo.orient = constructQuaternion( ( vec3( -1.0, 0.0, 0.0 ) ) * halfpi );\n    ptwo.extent = vec2( 3.0, 1.0 );\n    ptwo.center = vec3( 0, 0, 1 );\n    ptwo.color = vec3( 0.25, 0.75, 0.25 );\n    ptwo.emission = 0.875;\n    ptwo.roughness = 0.1;\n\n    pthree.orient = constructQuaternion( ( vec3( 1.0, 0.0, 1.0 ) ) * halfpi );\n    pthree.extent = vec2( 0.125, 1.0 );\n    pthree.center = vec3( 0.0, sintime, 0.9975 );\n    //pthree.emission = 0.975;\n    pthree.color = vec3( 1.0, 1.0, 1.0 );\n    pthree.roughness = 0.1;\n\n    pfour.orient = constructQuaternion( ( vec3( 0.0, 0.0, -1.0 ) ) * halfpi );\n    pfour.extent = vec2( 1.0, 3.0 );\n    pfour.center = vec3( -1.0, 0.0, 0.0 );\n    pfour.emission = 0.0;\n    pfour.color = vec3( 1.0, 1.0, 1.0 );\n    pfour.roughness = 0.9;\n\n    pfive.orient = constructQuaternion( ( vec3( 1.0, 1.0, -1.0 ) ) * halfpi );\n    pfive.extent = vec2( 1.0, 3.0 );\n    pfive.center = vec3( 0.0, 1.0, 0.0 );\n    //pfive.emission = 0.875;\n    pfive.color = vec3( 1.0, 1.0, 1.0 );\n    pfive.roughness = 0.9;\n\n    psix.orient = constructQuaternion( ( vec3( 1.0, 0.0, 1.0 ) ) * halfpi );\n    psix.extent = vec2( 1.0, 3.0 );\n    psix.center = vec3( 0.0, 0.0, -1.0 );\n    //psix.emission = 0.0;\n    psix.color = vec3( 0.75, 0.25, 0.25 );\n    psix.roughness = 0.1;\n\n    sphere.r = 0.5;\n    sphere.c = vec3( 0.0, 0.0, 0.0 );\n    sphere.roughness = 0.25;\n    sphere.color = vec3( 1.0 );\n\n    spheretwo.r = 0.125;\n    spheretwo.c = vec3( cos( iTime ) * 0.7, 0.5 * sintime, sintime * 0.7 );\n    spheretwo.emission = 4.75;\n    spheretwo.roughness = 0.25;\n    spheretwo.color = vec3( 1.0 );\n    //\n    \n\tfloat finalval = 0.0;\n    vec3 finalColor = vec3( finalval );\n    \n    vec2 mouse = 1.125 - ( iMouse.xy / iResolution.xy ) * 5.0;\n    \n\tvec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n\tpos.y *= aspect;\n    \n  \tvec3 view = vec3( pos.x, pos.y, 1.0 );\n    vec4 viewOrientation = constructQuaternion( vec3( 0.0, -( mouse.x ), 0.0 ) * halfpi );\n    \n    vec3 viewVector = quaternionMultiply( viewOrientation, view );\n\tvec3 rayDir = normalize( viewVector );\n    \n\tRay ray;\n\tray.origin = vec3( 3.0, 0.0, 0.0 );\n\tray.direction = rayDir;\n    \n    //\n    \n    vec3 enviroment = vec3( 0.0 );\n    float occlusion = 1.0;\n    \n    Intersection intersect, aaintersect;\n    vec3 viewDirection    = -rayDir;\n    \n    //\n    \n    Light light;\n    //light.lightOrientation = constructQuaternion( vec3( sin( time ), 0.0, 1.0 ) * halfpi );\n    //light.planarDirection  = quaternionMultiply( light.lightOrientation, up );\n    //light.planarRight      = quaternionMultiply( light.lightOrientation, -left );\n    //light.planarUp         = normalize( cross( light.planarRight, light.planarDirection ) );\n    light.lightExtents     = vec3( 0.125, 0.5, 1.0 );\n    light.lightPosition    = spheretwo.c;\n    \n    const int aasamples = 2;\n    const float faaSamples = float( aasamples * aasamples * 2 * 2 );\n    const float aaraycountoverone = 1.0 / float( faaSamples );\n    \n    bool everhit = false; float hitcount = 0.0;\n   \tvec3 aaoffset = vec3( fwidth( pos ) * 0.5, 1.0 );\n    for( int x = -aasamples; x < aasamples; x++ )\n    {\n    \tfor( int y = -aasamples; y < aasamples; y++ )\n        {\n            ray.direction = normalize( viewVector + vec3( x, y, 0.0 ) * aaoffset );\n            \n            aaintersect = projectRay( ray );\n            \n            vec3 incident = normalize( intersect.position - ray.origin );\n        \tvec3 incidentReflection = reflect( incident, intersect.normal );\n            \n            vec3 colorin = getBRDF( light, aaintersect, incidentReflection, \n                                   viewDirection, enviroment );\n            colorin *= 2.0;  // Hardcoded Exposure Adjustment\n\n\t\t\tfloat ExposureBias = 2.0;\n            vec3 curr = filmic( ExposureBias * colorin );\n\n            vec3 whiteScale = 1.0 / filmic( vec3( W ) );\n            vec3 color = curr * whiteScale;\n\n        \tfinalColor += aaraycountoverone * color;\n        }\n    }\n\n    //\n\n    finalColor = linear_srgb( finalColor );\n\tfragColor = vec4( finalColor, 1.0 );\n}","name":"Image","description":"","type":"image"}]}