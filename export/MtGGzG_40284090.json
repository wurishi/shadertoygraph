{"ver":"0.1","info":{"id":"MtGGzG","date":"1475124521","viewed":556,"name":"ShipWrecked","username":"Passion","description":"Underwater scene... background color reference: https://www.shadertoy.com/view/MlcGD7 tex3D and doBumpMap functions by user 'Shane'","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["noise","raymarch","postprocess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 35\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 buffer = texture(iChannel0,uv);\n    float decay=0.96815;\n    float exposure=0.21;\n    float density=0.926;\n    float weight=0.58767;\n    \n    vec2 tc = uv;\n    vec2 lightPos = iMouse.xy;\n    vec2 deltaTexCoord = tc;\n    \n    //float lm = sin(iTime*.3)*.25;\n    \n    deltaTexCoord =  uv-vec2(.5,.75);   //uv+vec2(sin(iTime*.7)*.3,-cos(iTime*.2)*.3)-.5;\n    deltaTexCoord *= 1.0 / float(NUM_SAMPLES)  * density;\n    \n    float illuminationDecay = 1.0;\n    vec4 color =texture(iChannel0, tc.xy)*0.305104;\n    \n    tc += deltaTexCoord * fract( sin(dot(uv.xy+fract(iTime), \n                                         vec2(12.9898, 78.233)))* 43758.5453 );\n    \n    for(int i=0; i < NUM_SAMPLES; i++)\n    {\n        tc -= deltaTexCoord;\n        vec4 sampleTex = texture(iChannel0, tc)*0.305104;\n        sampleTex *= illuminationDecay * weight;\n        color += sampleTex;\n        illuminationDecay *= decay;\n    }\n    fragColor = pow(color*exposure+(buffer*.75), vec4(vec3(1.0/0.75), 1.0));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_SAMPLES 32\n#define EPS 0.001\n#define MAX_DIST 30.0\n\n// 2D rotation\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// ground distance function\nfloat ground(vec3 p){\n    float n = noise(.1*p.xz)*2.;\n    float pl = (p.y*-1.) + 3.5;\n    return pl+(n+n);\n}\n\n// the whole scene\nfloat map(vec3 p){\n    //p = mod(p, 6.) - 3.;\n    //return length(p) - 1.0;\n    //p = normalize(p);\n    float n1 = noise(4.*p.xz+iTime*1.825)*.125;\n    float n2 = noise(2.*p.zx+iTime*2.75)*.12;\n    float n3 = noise(.25*p.xz+iTime*2.)*.5;\n    float n4 = noise(.15*p.zx+iTime*1.)*1.4;\n    \n    float n5 = noise(.1 *p.xz)*2.;\n    float pl = ground(p);//(p.y*-1.) +2.5;\n    return min(p.y+ n1+ n2+ n3+ n4, pl);\n}\n\n// raymarch/trace funtion\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_SAMPLES; i++){\n        vec3 p = o+t * r;\n        float d = map(p);\n        if(abs(d) < EPS || t > MAX_DIST) break; \n        t += d * 0.75;\n    }\n    return t;\n}\n\n// normal or gradient function\nvec3 grad(vec3 p) {\n\tvec2 e = vec2(EPS, 0.0);\n\treturn normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    // adjust uv coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    // create directional light ray and origin...\n    vec3 l = normalize(vec3(0.3, -0.8, 0.2));\n    vec3 ray = vec3(uv, 1.0 - dot(uv,uv) * .15);\n    vec3 origin = vec3(0.0, 2.0, -16.0);\n    // translate cam position by rotating on y\n    origin.xz *= r2(t/6.);\n    //origin.zy *= r2(t*1.3);\n    \n    // rotate cam view a bit\n    ray.yz *= r2(.75*sin(t/1.5)+1.5);\n    ray.xy *= r2(.25*sin(t*.5)-1.5);\n    ray.xz *= r2(-t/6.);\n    float hit = trace(origin, ray);\n    vec3 sp = origin+hit * ray;\n    float d = map(sp);\n    float d2 = ground(sp);\n    // normal\n    vec3 n = grad(sp);\n    \n    vec3 incident = normalize(sp - origin);  \n    vec3 reflected = normalize(reflect(incident,n)); //, 1.31\n    vec3 refracted = normalize(refract(incident,n,1.333));\n    // cubemaps mm and m1...\n    vec4 mm = texture(iChannel0, reflected);\n    vec4 m1 = texture(iChannel2, refracted);\n    // background color\n    vec4 bg = pow(vec4(.1, .75, .8, 1), vec4(4.*(ray.y+1.0)));\n    \n    // initialize to avoid issuses/artifacts\n    fragColor = vec4(0.0);\n    \n    if(d < 0.5){\n        // blinn-phong specular\n        vec3 halfDir = normalize(l - ray);\n        float specAngle = max(dot(halfDir, n), 0.0);\n        float spec = pow(specAngle, 80.);\n        // fog\n        float fog = smoothstep(.15, .75, hit*.05);\n        // diffuse\n        float dif = clamp(dot(n,l), 0.15, 1.0);//*dif\n        fragColor = mix(vec4((m1*.5)+mm*vec4(.1,.75,.8,1.)*dif+spec), bg, fog);\n        // check if ground is hit\n        if(d2 < 0.5){\n            // reset set the norm using the bump map function\n            n = doBumpMap(iChannel1, (sp)*(1.0/3.0), n, 0.05);\n            vec3 l2 = normalize(vec3(.2,-.8,.3));\n            float dif2 = clamp(dot(n,l2),0.15,1.0);\n            vec4 tex = vec4(tex3D(iChannel1,(sp)*(1.0/8.0), n), 1.0);\n            fragColor = mix(tex*dif2, bg, fog);\n        }\n    }\n    else\n        fragColor = bg;\n}","name":"Buf A","description":"","type":"buffer"}]}