{"ver":"0.1","info":{"id":"WdXXRr","date":"1550454753","viewed":306,"name":"rayleigh, mie","username":"kuma720","description":"rayleigh, mie","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["rayleigh","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//referenced \n//http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/index_en.html\n//https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\n//https://github.com/wwwtyro/glsl-atmosphere\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\nfloat sdf( vec3 p ) {\n    return length( p ) - 1.2 ;\n}\n\nvec3 createnormal(vec3 p) {\n  float e = 0.001;\n  return normalize( vec3(\n    sdf( vec3(p.x+e,p.y,p.z) ) - sdf( vec3(p.x-e,p.y,p.z) ) ,\n    sdf( vec3(p.x,p.y+e,p.z) ) - sdf( vec3(p.x,p.y-e,p.z) ) ,\n    sdf( vec3(p.x,p.y,p.z+e) ) - sdf( vec3(p.x,p.y,p.z-e) )\n  ));\n}\n\n\n\nvec2 rsi(vec3 r0, vec3 rd, float sr) {\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, r0);\n    float c = dot(r0, r0) - (sr * sr);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 dir ) {\n  float len = 0.;\n\n  //////////////////////////////////////////\n  int iSteps = 30;\n  int jSteps = 8;\n  float PI = 3.14159265;\n\n  //////////////////////////////////////////\n  float intensity = 15.;\n  float g = -.995;\n  float rAtmos = 6420e3;\n  float rPlanet = 6360e3;\n  float atmosThickness = rAtmos - rPlanet; \n  float shRlh = 0.25 * atmosThickness; //scale height rayliegh\n  float shMie = 0.01 * atmosThickness; //scale height mie\n  float kMie = 21e-6;\n  vec3 kRlh = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n  vec3 r0 = vec3(0,rPlanet,0);\n\n  //////////////////////////////////////////\n  float T = iTime;\n  vec3 pSun = normalize( vec3( cos(T) , sin(T*3.5) * .1 + .2 , sin(T) ) );\n  vec3 rayDirection = normalize(dir);\n\n  ////////////////\n  float iOdRlh = 0.0;\n  float iOdMie = 0.0;\n  vec3 totalRlh = vec3(0,0,0);\n  vec3 totalMie = vec3(0,0,0);\n\n  float iStepSize = 0.;\n  {////////////////\n    vec2 p = rsi(r0, rayDirection, rAtmos);\n    p.y = min(p.y, rsi(r0, rayDirection, rPlanet).x);\n    iStepSize = (p.y - p.x) / float(iSteps);\n  }\n\n  ////////////////\n  float len2 = 0.;\n  vec3 objcol = vec3(0.);\n  for ( int I=0 ; I<iSteps ; ++I ) {\n\n    ////////////////\n    vec3 iPos = (eye + r0) + rayDirection * ( float(I) * iStepSize + iStepSize * 0.5 );\n      \n    // The Out-Scattering Equation\n    float iHeight = length(iPos) - rPlanet;\n    float odStepRlh = exp(-iHeight / shRlh) * iStepSize;\n    float odStepMie = exp(-iHeight / shMie) * iStepSize;\n    iOdRlh += odStepRlh;\n    iOdMie += odStepMie;\n    \n    ////////////////\n    float jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);\n    float jTime = 0.0;\n    float jOdRlh = 0.0;\n    float jOdMie = 0.0;\n    for (int j = 0; j < jSteps; j++) {\n        vec3 jPos = iPos + pSun * ( float(j) * jStepSize + jStepSize * 0.5 );\n        float jHeight = length(jPos) - rPlanet;\n        jOdRlh += exp(-jHeight / shRlh) * jStepSize;\n        jOdMie += exp(-jHeight / shMie) * jStepSize;\n    }\n\n    ////////////////\n    totalRlh += odStepRlh * exp( -( kRlh * (iOdRlh + jOdRlh) ) );\n    totalMie += odStepMie * exp( -( vec3(kMie) * (iOdMie + jOdMie) ) );\n\n    ////////////////\n    vec3 p = eye + dir * len2;\n    float l = sdf( p );\n    len2 += min( l , 3. );\n    if ( l < 0.01 ) {\n      objcol = dot ( createnormal(p) , pSun ) * vec3(.5,.4,.3);\n      break;\n    }\n\n  }\n\n\n\n  ////////////////\n  float mu = dot( -rayDirection , pSun);\n  float mumu = mu * mu;\n  float gg = g * g;\n    \n  //fix\n  //float pRlh = 1. / (4. * PI) * ( 1.0 + mumu );\n  float pRlh = 3. / (16. * PI) * ( 1.0 + mumu );\n    \n  //fix\n  //float pMie = 1. / (4. * PI) * ( ( 3. * (1.0 - gg) ) / (2. * (2.0 + gg) ) )  * ( (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) )\n  float pMie = 3. / (8. * PI) * ( ( (1. - gg) * (mumu + 1.) ) / ( ( 2. + gg ) * pow(1. + gg - 2. * mu * g, 1.5) ) );\n\n  ////////////////\n  vec3 col = intensity * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie) + objcol;\n  return vec4( col , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    vec3 eye = vec3( -25. , -2. ,  -25. );\n    vec3 center = vec3( 0. , 3., 0. );\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n   fragColor = render( uv , eye , worldDir );\n}","name":"Image","description":"","type":"image"}]}