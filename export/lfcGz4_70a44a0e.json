{"ver":"0.1","info":{"id":"lfcGz4","date":"1711452346","viewed":73,"name":"Black Hole Accretion DiskTexture","username":"ShaderGott420","description":"I was searching for something like this, couldnt find it so I made it. *its not great though* so here ya go :) Free to use\n\nStill has to use a more realistic blue/redshift pattern\nI need to find out how to make it tiling","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["accretion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n\n// this is from https://www.shadertoy.com/view/4lB3zz\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\n\nfloat tileableNoise(float x, float y) {\n    // Wrap x and y coordinates for tiling\n    float tiledX = mod(x,iResolution.x);\n\n\n    return InterpolationNoise(tiledX, y);\n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.2;\n    float frequency =0.2;\n    float amplitude = 0.3;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.3,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + tileableNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 brightness = vec3(exp(-(1.0 - uv.y)*4.0));\n    float timeFactor = smoothstep(0.0,1.0,1.0-uv.y);// Adjust the values 1.0 and 2.0 as needed\n    // Time varying pixel color\n    float multipleNoise = PerlinNoise2D(uv.x + iTime *0.2, uv.y)*uv.y*8.0 + PerlinNoise2D(uv.x + iTime *0.4, uv.y)*uv.y*4.0 + PerlinNoise2D(uv.x + iTime *0.6, uv.y)*uv.y*2.0;\n    vec3 col = vec3(multipleNoise)*uv.y*2.0;\n    col = mix(col,vec3(0.878,0.427,0.180) ,uv.y*0.99);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}