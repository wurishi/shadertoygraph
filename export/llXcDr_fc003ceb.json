{"ver":"0.1","info":{"id":"llXcDr","date":"1504333652","viewed":631,"name":"4D Raytracer","username":"AustinSpafford","description":"An experiment in casting a 3D-raster of rays (across x/y/w), and sacrificing hue information in exchange for displaying hits across the w-dimension.\n\nI recommend playing with raytrace_scene(); such as changing constants and enabling the hyperspheres. :)","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","4d","tesseract","hypercube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Austin Spafford\n// Title: Hyper-Chroma\n// <dummy-comment to keep the title-scraper from reading into code>\n\n//#define ENABLE_HYPERSPHERES\n    \nprecision highp float;\nprecision highp int;\n\nconst float k_pi = radians(180.0);\nconst float k_tau = radians(360.0);\n\nconst int k_bloblet_count = 3;\n\nconst bool k_blob_enabled = true;\nconst bool k_ground_enabled = true;\n\nconst int k_hyperslice_count = 30;\n\nvec4 s_bloblet_positions[k_bloblet_count];\nfloat s_bloblet_radii[k_bloblet_count];\n\nvec3 s_hyperslice_colors[k_hyperslice_count];\nfloat s_hyperslice_depths[k_hyperslice_count];\n\nvec3 s_light_ambient_color = vec3(0.1);\nvec4 s_light_direction; // surface-to-light\n\nvec2 s_mouse_fractions; // (iMouse / iResolution)\n\nmat4 s_tesseract_world_to_local_rotation;\n\nfloat saturate(\n\tfloat value)\n{\n\treturn clamp(value, 0.0, 1.0);\n}\n\nfloat length_sq(\n\tvec2 vector)\n{\n\treturn dot(vector, vector);\n}\n\nfloat sq(\n    float value)\n{\n    return (value * value);\n}\n\nvec3 sq(\n    vec3 value)\n{\n    return vec3(\n        (value.x * value.x),\n        (value.y * value.y),\n        (value.z * value.z));\n}\n\nfloat distance_sq(\n\tvec2 point_one,\n\tvec2 point_two)\n{\n    vec2 delta = (point_two - point_one);\n    \n\treturn dot(delta, delta);\n}\n\nfloat wrap_angle(\n\tfloat original_radians)\n{\n    return mod(original_radians, k_tau);\n}\n    \nfloat linear_fraction(\n\tfloat min,\n\tfloat max,\n\tfloat value)\n{\n\treturn (min != max) ?\n        ((value - min) / (max - min)) :\n    \tstep(value, max);\n}\n\nfloat clamped_linear_fraction(\n\tfloat min,\n\tfloat max,\n\tfloat value)\n{\n\treturn clamp(linear_fraction(min, max, value), 0.0, 1.0);\n}\n\nfloat trig_cycle_fraction(\n\tfloat domain_fraction)\n{\n    // Smoothly moves through: (0.0, 0.0), (0.5, 1.0), (1.0, 0.0)\n    return linear_fraction(1.0, -1.0, cos(mix(0.0, radians(360.0), domain_fraction)));\n}\n\nint int_mod(\n    int numerator,\n    int divisor)\n{\n    return (numerator - ((numerator / divisor) * divisor));\n}\n\nfloat soft_add_fractions(\n\tfloat first,\n\tfloat second)\n{\n    // Derived from \"compliment(compliment(first) * compliment(second))\", which has the\n    // effect of almost naively adding two fractions when their small, but avoiding going above 1.0 when either one is large.\n    return (first + second - (first * second));\n}\n\nvec3 soft_add_colors(\n\tvec3 first,\n\tvec3 second)\n{\n    return vec3(\n        soft_add_fractions(first.r, second.r),\n        soft_add_fractions(first.g, second.g),\n        soft_add_fractions(first.b, second.b));\n}\n\nfloat random(\n    vec2 st)\n{\n    // From: https://thebookofshaders.com/10/\n\treturn fract(\n\t\tsin(dot(st.xy, vec2(12.9898, 78.233))) * \n\t\t43758.5453123);\n}\n\nvec3 hsb_to_rgb(\n    vec3 hsb_color)\n{\n    //  From: IÃ±igo Quiles \n    //  https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod((hsb_color.x * 6.0) + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = (rgb * rgb * (3.0 - (2.0 * rgb)));\n    return (hsb_color.z * mix(vec3(1.0), rgb, hsb_color.y));\n}\n\nmat2 rotation_mat2(\n\tfloat theta)\n{    \n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat2(\n    \tcos_theta, sin_theta, // x-basis\n        (-1.0 * sin_theta), cos_theta); // y-basis\n}\n\nmat4 rotation_mat4_xy_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat4(\n    \tcos_theta, sin_theta, 0.0, 0.0, // x-basis\n        (-1.0 * sin_theta), cos_theta, 0.0, 0.0, // y-basis\n        0.0, 0.0, 1.0, 0.0, // z-basis\n    \t0.0, 0.0, 0.0, 1.0); // w-basis\n}\n\nmat4 rotation_mat4_xz_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat4(\n    \tcos_theta, 0.0, (-1.0 * sin_theta), 0.0, // x-basis\n        0.0, 1.0, 0.0, 0.0, // y-basis\n        sin_theta, 0.0, cos_theta, 0.0, // z-basis\n    \t0.0, 0.0, 0.0, 1.0); // w-basis\n}\n\nmat4 rotation_mat4_xw_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n \n    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.\n    return mat4(\n    \tcos_theta, 0.0, 0.0, sin_theta, // x-basis\n        0.0, 1.0, 0.0, 0.0, // y-basis\n    \t0.0, 0.0, 1.0, 0.0, // z-basis\n        (-1.0 * sin_theta), 0.0, 0.0, cos_theta); // w-basis\n}\n\nmat4 rotation_mat4_yz_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0, // x-basis\n        0.0, cos_theta, sin_theta, 0.0, // y-basis\n        0.0, (-1.0 * sin_theta), cos_theta, 0.0, // z-basis\n    \t0.0, 0.0, 0.0, 1.0); // w-basis\n}\n\nmat4 rotation_mat4_yw_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.\n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0, // x-basis\n        0.0, cos_theta, 0.0, sin_theta, // y-basis\n    \t0.0, 0.0, 1.0, 0.0, // z-basis\n        0.0, (-1.0 * sin_theta), 0.0, cos_theta); // w-basis\n}\n\nmat4 rotation_mat4_zw_plane(\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.\n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0, // x-basis\n        0.0, 1.0, 0.0, 0.0, // y-basis\n    \t0.0, 0.0, cos_theta, sin_theta, // z-basis\n        0.0, 0.0, (-1.0 * sin_theta), cos_theta); // w-basis\n}\n\nfloat smooth_min(\n    float first_value,\n    float second_value,\n    float smoothing_distance)\n{\n    // Credit: https://iquilezles.org/articles/smin\n    float blend_fraction = saturate(0.5 + (0.5 * ((first_value - second_value) / smoothing_distance)));\n    return (\n        mix(first_value, second_value, blend_fraction) - \n        (smoothing_distance * (blend_fraction * (1.0 - blend_fraction))));\n}\n\nvoid raytrace_sphere(\n    vec4 sphere_center,\n    float sphere_radius,\n\tvec4 ray_origin,\n\tvec4 ray_direction,\n\tinout vec3 inout_ray_color,\n\tinout float inout_ray_depth)\n{\n    vec4 local_ray_origin = (ray_origin - sphere_center);\n    \n    // Solving for the intersections via the quadratic equation, as seen in: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n    float quadratic_a = 1.0; // dot(ray_direction, ray_direction)\n    float quadratic_b = (2.0 * dot(local_ray_origin, ray_direction));\n    float quadratic_c = (dot(local_ray_origin, local_ray_origin) - sq(sphere_radius));\n    float quadratic_discriminant = (sq(quadratic_b) - (4.0 * quadratic_a * quadratic_c));\n    \n    if (quadratic_discriminant >= 0.0)\n    {\n        float sqrt_quadratic_discriminant = sqrt(quadratic_discriminant);\n        float quadratic_divisor = (1.0 / (2.0 * quadratic_a));\n        \n        float depth_near = (((-1.0 * quadratic_b) - sqrt_quadratic_discriminant) * quadratic_divisor);\n        float depth_far = (((-1.0 * quadratic_b) + sqrt_quadratic_discriminant) * quadratic_divisor);\n        \n        float depth = ((depth_near >= 0.0) ? depth_near : depth_far);\n        \n        if ((depth >= 0.0) &&\n            (depth < inout_ray_depth))\n        {\n            vec4 intersection = (ray_origin + (ray_direction * depth));\n            \n            vec4 normal = normalize(intersection - sphere_center);\n            float diffuse_fraction = (1.0 * max(0.0, dot(normal, s_light_direction)));\n            float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));\n            \n            inout_ray_color = mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction)));\n            inout_ray_depth = depth;\n        }\n    }\n}\n\nvoid raytrace_plane(\n\tvec4 plane_center,\n\tvec4 plane_normal,\n\tvec4 ray_origin,\n\tvec4 ray_direction,\n\tinout vec3 inout_ray_color,\n\tinout float inout_ray_depth)\n{    \n    // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n    float depth = dot((plane_center - ray_origin), plane_normal) / dot(ray_direction, plane_normal);\n    \n    if ((depth >= 0.0) &&\n        (depth < inout_ray_depth))\n    {\n        vec4 intersection = (ray_origin + (ray_direction * depth));\n\n        float diffuse_fraction = (1.0 * max(0.0, dot(plane_normal, s_light_direction)));\n        float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));\n        \n        vec3 surface_color = vec3(1.0);\n        \n        // Checkerboard\n        if (true)\n        {\n            float fuzziness = (0.025 * depth);\n            \n            surface_color = \n                mix(\n                \tvec3(0.1),\n                \tvec3(0.9),\n                \tabs((smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.x)) + smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.z))) - 1.0));            \n        }\n\n        inout_ray_color = (surface_color * mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction))));\n        inout_ray_depth = depth;\n    }\n}\n\nvoid raytrace_tesseract(\n\tvec4 tesseract_center,\n    vec4 tesseract_scale,\n\tvec4 world_ray_origin,\n\tvec4 world_ray_direction,\n\tinout vec3 inout_ray_color,\n\tinout float inout_ray_depth)\n{\n    // Using this method: https://tavianator.com/fast-branchless-raybounding-box-intersections/\n        \n    vec4 local_ray_origin = (s_tesseract_world_to_local_rotation * (world_ray_origin - tesseract_center));\n    vec4 local_ray_direction = (s_tesseract_world_to_local_rotation * world_ray_direction);\n    \n    vec4 local_ray_direction_inverse = (1.0 / local_ray_direction);\n    \n    float result_near_depth = 0.0;\n    float result_far_depth = 1000000.0;\n    \n    // X-slab\n    {\n        float pos_x_depth = ((tesseract_scale.x - local_ray_origin.x) * local_ray_direction_inverse.x);\n        float neg_x_depth = (((-1.0 * tesseract_scale.x) - local_ray_origin.x) * local_ray_direction_inverse.x);\n        \n        float x_near_depth = min(pos_x_depth, neg_x_depth);\n        float x_far_depth = max(pos_x_depth, neg_x_depth);\n        \n        result_near_depth = max(result_near_depth, x_near_depth);\n        result_far_depth = min(result_far_depth, x_far_depth);\n    }\n    \n    // Y-slab\n    {\n        float pos_y_depth = ((tesseract_scale.y - local_ray_origin.y) * local_ray_direction_inverse.y);\n        float neg_y_depth = (((-1.0 * tesseract_scale.y) - local_ray_origin.y) * local_ray_direction_inverse.y);\n        \n        float y_near_depth = min(pos_y_depth, neg_y_depth);\n        float y_far_depth = max(pos_y_depth, neg_y_depth);\n        \n        result_near_depth = max(result_near_depth, y_near_depth);\n        result_far_depth = min(result_far_depth, y_far_depth);\n    }\n    \n    // Z-slab\n    {\n        float pos_z_depth = ((tesseract_scale.z - local_ray_origin.z) * local_ray_direction_inverse.z);\n        float neg_z_depth = (((-1.0 * tesseract_scale.z) - local_ray_origin.z) * local_ray_direction_inverse.z);\n        \n        float z_near_depth = min(pos_z_depth, neg_z_depth);\n        float z_far_depth = max(pos_z_depth, neg_z_depth);\n        \n        result_near_depth = max(result_near_depth, z_near_depth);\n        result_far_depth = min(result_far_depth, z_far_depth);\n    }    \n    \n    // W-slab\n    {\n        float pos_w_depth = ((tesseract_scale.w - local_ray_origin.w) * local_ray_direction_inverse.w);\n        float neg_w_depth = (((-1.0 * tesseract_scale.w) - local_ray_origin.w) * local_ray_direction_inverse.w);\n        \n        float w_near_depth = min(pos_w_depth, neg_w_depth);\n        float w_far_depth = max(pos_w_depth, neg_w_depth);\n        \n        result_near_depth = max(result_near_depth, w_near_depth);\n        result_far_depth = min(result_far_depth, w_far_depth);\n    }\n    \n    if ((result_near_depth <= result_far_depth) &&\n        (result_near_depth < inout_ray_depth))\n    {\n        vec4 normalized_local_surface = ((local_ray_origin + (local_ray_direction * result_near_depth)) / tesseract_scale);\n        \n        float cube_hole_fraction = smoothstep(0.1, 1.0, s_mouse_fractions.x);\n        cube_hole_fraction = 0.8;\n        \n        if ((step(cube_hole_fraction, abs(normalized_local_surface)) * step(abs(normalized_local_surface), vec4(0.999999))) != vec4(0.0))\n        {\n            inout_ray_color = vec3(1.0);\n            inout_ray_depth = result_near_depth;\n\n            // Lighting\n            if (true)\n            {\n                vec4 surface_normal = (normalize(step(0.999, abs(normalized_local_surface))) * sign(normalized_local_surface));\n                float diffuse_fraction = (1.0 * max(0.0, dot(surface_normal, (s_tesseract_world_to_local_rotation * s_light_direction))));\n\n                inout_ray_color *= mix(s_light_ambient_color, vec3(1.0), diffuse_fraction);\n            }\n        }\n        else if (result_far_depth < inout_ray_depth)\n        {\n            normalized_local_surface = ((local_ray_origin + (local_ray_direction * result_far_depth)) / tesseract_scale);\n\n            if ((step(cube_hole_fraction, abs(normalized_local_surface)) * step(abs(normalized_local_surface), vec4(0.999999))) != vec4(0.0))\n            {\n                inout_ray_color = vec3(1.0);\n                inout_ray_depth = result_far_depth;\n\n                // Lighting\n                if (true)\n                {\n                    vec4 surface_normal = (normalize(step(0.999, abs(normalized_local_surface))) * (-1.0 * sign(normalized_local_surface)));\n                    float diffuse_fraction = (1.0 * max(0.0, dot(surface_normal, (s_tesseract_world_to_local_rotation * s_light_direction))));\n\n                    inout_ray_color *= mix(s_light_ambient_color, vec3(1.0), diffuse_fraction);\n                }\n            }\n        }\n    }\n}\n\nvoid raytrace_scene(\n\tvec4 ray_origin,\n\tvec4 ray_direction,\n\tout vec3 out_ray_color,\n\tout float out_ray_depth)\n{\n    out_ray_color = vec3(0.0, 0.0, 0.0);\n    out_ray_depth = 10.0;\n    \n#ifdef ENABLE_HYPERSPHERES\n    for (int bloblet_index = 0; bloblet_index < k_bloblet_count; bloblet_index++)\n    {\n        raytrace_sphere(\n            s_bloblet_positions[bloblet_index],\n            s_bloblet_radii[bloblet_index],\n            ray_origin,\n            ray_direction,\n        \tout_ray_color,\n        \tout_ray_depth);\n    }\n#endif\n    \n    vec4 tesseract_scale = vec4(0.6);\n    //tesseract_scale = vec4(0.8, 0.2, 0.2, 0.7);\n    tesseract_scale = vec4(0.6, 0.6, 0.6, 0.2);\n      \n    raytrace_tesseract(\n\t\tvec4(0.0, 0.3, 0.0, 0.0), // tesseract_center\n        tesseract_scale,\n    \tray_origin,\n        ray_direction,\n        out_ray_color,\n        out_ray_depth);\n        \n    raytrace_plane(\n    \tvec4(0.0, -0.8, 0.0, 0.0),\n    \tnormalize(vec4(0.0, 1.0, 0.0, 0.0)),\n        ray_origin,\n        ray_direction,\n        out_ray_color,\n        out_ray_depth);\n}\n\nvoid mainImage(\n\tout vec4 fragColor,\n    in vec2 fragCoord)\n{\n    vec2 test_point = (fragCoord.xy / iResolution.xy);\n    \n    s_mouse_fractions = (iMouse.xy / iResolution.xy);\n    \n    test_point -= 0.5;\n    test_point *= 2.0;\n    \n    float texture_aspect_ratio = (iResolution.x / iResolution.y);\n    \n    // Perform aspect-ratio correction.\n\ttest_point.x *= max(1.0, texture_aspect_ratio);\n    test_point.y *= max(1.0, (1.0 / texture_aspect_ratio));\n    \n    // Crop down until the artwork is touching at least one pair of edges.\n    {\n        float artwork_aspect_ratio = 1.0;\n        \n        //artwork_aspect_ratio = texture_aspect_ratio; // Zoom in until the artwork fills the frame.\n        \n        if ((artwork_aspect_ratio > 1.0) && (texture_aspect_ratio > 1.0))\n        {\n            test_point /= min(artwork_aspect_ratio, texture_aspect_ratio);\n        }\n        else if ((artwork_aspect_ratio < 1.0) && (texture_aspect_ratio < 1.0))\n        {\n            test_point *= max(artwork_aspect_ratio, texture_aspect_ratio);\n        }\n    }\n    \n    s_light_direction = normalize(vec4(1.0, 2.0, 1.5, 0.0));\n    \n    // Build a transform for the tesseract.\n    {\n        float animation_fraction = fract(iTime * 0.02);\n        \n    \ts_tesseract_world_to_local_rotation = (\n            rotation_mat4_xy_plane(k_tau * smoothstep(0.0, 0.1, animation_fraction)) * \n\n            //rotation_mat4_xy_plane(k_tau * smoothstep(0.1, 0.2, animation_fraction)) * \n            //rotation_mat4_xz_plane(k_tau * smoothstep(0.1, 0.2, animation_fraction)) *\n\n            //rotation_mat4_xz_plane(k_tau * 0.125) *\n            rotation_mat4_xw_plane(k_tau * smoothstep(0.1, 0.3, animation_fraction)) * \n            //rotation_mat4_xz_plane(k_tau * -0.125) * \n\n            rotation_mat4_xy_plane(k_tau * smoothstep(0.3, 0.4, animation_fraction)) *  \n            rotation_mat4_xw_plane(k_tau * smoothstep(0.3, 0.4, animation_fraction)) *  \n\n            //rotation_mat4_xy_plane(k_tau * smoothstep(0.4, 1.0, animation_fraction)) *  \n            //rotation_mat4_yz_plane(k_tau * 2.0 * smoothstep(0.4, 1.0, animation_fraction)) *  \n            //rotation_mat4_xz_plane(k_tau * smoothstep(0.4, 1.0, animation_fraction)) *  \n            rotation_mat4_xw_plane(k_tau * 2.0 * smoothstep(0.4, 1.0, animation_fraction)) *  \n            rotation_mat4_yw_plane(k_tau * smoothstep(0.4, 1.0, animation_fraction)) *  \n            rotation_mat4_zw_plane(k_tau * 3.0 * smoothstep(0.4, 1.0, animation_fraction)));\n    }\n    \n    // Compute the blob parameters.\n    for (int bloblet_index = 0; bloblet_index < k_bloblet_count; bloblet_index++)\n    {\n        float bloblet_fraction = (float(bloblet_index) / float(k_bloblet_count));\n        \n        vec4 bloblet_movement_rates =\n            vec4(\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.0))),\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.1))),\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.2))),\n                mix(0.02, 0.1, random(vec2(float(bloblet_index), 0.3))));\n        \n        bloblet_movement_rates *= 0.5;\n        \n        s_bloblet_positions[bloblet_index] = (1.0 * vec4(1.0, 1.0, 1.0, 1.0) * sin(k_tau * bloblet_movement_rates * iTime));\n        \n        if (false)\n        {\n            s_bloblet_positions[bloblet_index] = vec4(\n                cos(k_tau * ((0.0 * iTime) + bloblet_fraction)),\n                sin(k_tau * ((0.0 * iTime) + bloblet_fraction)),\n                0.0,\n                (1.0 * cos(k_tau * ((-0.1 * iTime) + (0.5 * bloblet_fraction)))));\n        }\n        \n        s_bloblet_radii[bloblet_index] = (0.5 * mix(1.0, 1.0, random(vec2(float(bloblet_index), 0.3))));\n    }\n    \n    vec3 scene_color;\n    {\n        // Render all of the hyperslices.\n        for (int hyperslice_index = 0; hyperslice_index < k_hyperslice_count; hyperslice_index++)\n        {\n            float dithering_fraction = random(test_point);\n            \n            float hyperslice_fraction = ((float(hyperslice_index) + mix(-0.5, 0.5, dithering_fraction)) / max(1.0, float(k_hyperslice_count - 1)));\n            \n            float w_fov = 0.5;//s_mouse_fractions.y;\n            \n            // Akin to how test_point varies from -1 to 1 on each axis, we're adding an additional axis of iteration/sampling.\n            float hyperslice_w = mix((-1.0 * w_fov), w_fov, hyperslice_fraction);\n            hyperslice_w = sign(hyperslice_w) * pow(abs(hyperslice_w), 2.0);\n            \n            vec4 ray_origin = vec4(0.0, 0.0, 1.75, 0.0);\n            vec4 ray_direction = normalize(vec4(test_point, -1.0, hyperslice_w));\n\n            // Orthographic.\n            if (false)\n            {\n                ray_origin = vec4((2.0 * test_point), 10.0, hyperslice_w);\n                ray_direction = vec4(0.0, 0.0, -1.0, 0.0);\n            }\n\n            // Camera-Pitch control.\n            if (false)\n            {\n                mat4 transform = rotation_mat4_yz_plane(k_tau * mix(-0.08, 0.25, (1.0 - s_mouse_fractions.y)));\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n            else\n            {\n                mat4 transform = rotation_mat4_yz_plane(k_tau * 0.1);\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n\n            // Camera-Yaw control.\n            if (false)\n            {\n                mat4 transform = rotation_mat4_xz_plane(k_tau * s_mouse_fractions.x);\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n            else\n            {\n                float yaw_fraction = fract(iTime * 0.012);\n                yaw_fraction = mix(0.1, -0.35, smoothstep(-1.0, 1.0, cos(iTime * 0.11)));\n                \n                mat4 transform = rotation_mat4_xz_plane(k_tau * yaw_fraction);\n                ray_origin *= transform;\n                ray_direction *= transform;\n            }\n\n            raytrace_scene(\n                ray_origin,\n                ray_direction,\n            \ts_hyperslice_colors[hyperslice_index],\n            \ts_hyperslice_depths[hyperslice_index]);\n    \n            if (s_hyperslice_depths[hyperslice_index] < 10.0)\n            {\n                vec4 shadow_ray_origin = (ray_origin + (ray_direction * s_hyperslice_depths[hyperslice_index]));\n                vec4 shadow_ray_direction = s_light_direction;\n                \n                shadow_ray_origin += (0.001 * shadow_ray_direction);\n\n                vec3 shadow_ray_color = vec3(0.0);\n                float shadow_ray_depth = 10.0;\n                raytrace_scene(\n                    shadow_ray_origin,\n                    shadow_ray_direction,\n                    shadow_ray_color,\n                    shadow_ray_depth);\n\n                if (shadow_ray_depth < 10.0)\n                {\n                    s_hyperslice_colors[hyperslice_index] = min(s_hyperslice_colors[hyperslice_index], s_light_ambient_color);\n                }\n            }\n        }\n        \n        // Composite the hyperslices.\n        if (true)\n        {\n            vec3 color_summation = vec3(0.0);\n            \n            for (int hyperslice_index = 0; hyperslice_index < k_hyperslice_count; hyperslice_index++)\n            {\n            \tfloat hyperslice_fraction = (float(hyperslice_index) / max(1.0, float(k_hyperslice_count - 1)));\n                \n                float brightness = dot(s_hyperslice_colors[hyperslice_index], s_hyperslice_colors[hyperslice_index]); // Squaring into linear-space color.                \n                vec3 hyperslice_color = hsb_to_rgb(vec3((0.7 * hyperslice_fraction), 1.0, brightness));\n                    \n                color_summation += hyperslice_color;\n            }\n        \n        \tscene_color = sqrt(color_summation / float(k_hyperslice_count)); // Converting back into sqrt-space color.\n        }\n        else\n        {\n            vec3 color_summation = vec3(0.0);\n            \n            for (int hyperslice_index = 0; hyperslice_index < k_hyperslice_count; hyperslice_index++)\n            {\n                color_summation += sq(s_hyperslice_colors[hyperslice_index]); // Squaring into linear-space color.\n            }\n        \n        \tscene_color = sqrt(color_summation / float(k_hyperslice_count)); // Converting back into sqrt-space color.\n        }\n    }\n\n    vec3 background_color = vec3(0.0);\n    //background_color += (vec3(0.4) * max(smoothstep(0.04, 0.0, abs(fract(test_point.x))), smoothstep(0.04, 0.0, abs(fract(test_point.y))))); // Generate a coordinates-grid.\n    \n    vec3 color = scene_color;         \t\n    //color = mix(background_color, scene_color.rgb, scene_color.a);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}