{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// https://www.shadertoy.com/view/Xdf3zB\n\n// Implementation of equi-angular sampling for raymarching through homogenous media\n// 2013 @sjb3d\n\n#define PI\t\t\t\t3.1415926535\n#define SIGMA\t\t\t0.3\n#define STEP_COUNT\t\t16\n#define DIST_MAX\t\t10.0\n#define LIGHT_POWER\t\t12.0\n#define SURFACE_ALBEDO\t0.7\nconst float rad = 0.9;\nconst float dots = 64.0;\nconst float duration = 180.0;\nconst vec3 colorsep = vec3(0,2.09,4.18);\n\nconst float PI2 = 2.0*3.1415926535897932384626433832795;\n// shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvoid sampleCamera(vec2 u, out vec3 rayOrigin, out vec3 rayDir, in vec2 fragCoord)\n{\n\tvec2 filmUv = (fragCoord.xy + u)/iResolution.xy;\n\t\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\t\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = normalize(vec3(tx, ty, tz) - rayOrigin);\n}\n\nvoid intersectSphere(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 sphereCentre,\n\tfloat sphereRadius,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n\t// ray: x = o + dt, sphere: (x - c).(x - c) == r^2\n\t// let p = o - c, solve: (dt + p).(dt + p) == r^2\n\t//\n\t// => (d.d)t^2 + 2(p.d)t + (p.p - r^2) == 0\n\t//vec3 p = vec3(0.,0.,0.);\n //   rayOrigin =  vec3(0.,0.,0.);\n\n    \n    \n    //sphereCentre = vec3(star_pos.x,star_pos.y,0.);    /// this is pisotion \n   vec3 p = rayOrigin - sphereCentre;\n\tvec3 d = rayDir;\n\tfloat a = dot(d, d);\n\tfloat b = 2.0*dot(p, d);\n\tfloat c = dot(p, p) - sphereRadius*sphereRadius;\n\tfloat q = b*b - 4.0*a*c;\n\tif (q > 0.0) {\n\t\tfloat denom = 0.5/a;\n\t\tfloat z1 = -b*denom;\n\t\tfloat z2 = abs(sqrt(q)*denom);\n\t\tfloat t1 = z1 - z2;\n\t\tfloat t2 = z1 + z2;\n\t\tbool intersected = false;\n\t\tif (0.0 < t1 && t1 < rayT) {\n\t\t\tintersected = true;\n\t\t\trayT = t1;\n\t\t} else if (0.0 < t2 && t2 < rayT) {\n\t\t\tintersected = true;\n\t\t\trayT = t2;\n\t\t}\n\t\tif (intersected) {\n\t\t\tgeomNormal = normalize(p + d*rayT);\n\t\t}\n\t}\n}\n\nvoid intersectScene(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n    vec2 fragCoord,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n    \n        \n      vec2 pq = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  float tm = mod(iTime,duration)/duration;\n  pq.y *= iResolution.y/iResolution.x;\n\n      vec3 gradient = vec3(0.0);\nvec2 star_pos;\n  for (float i=1.0; i<=dots; i++)\n  {\n    float i2pi = i*PI2;\n    float ang = mod(tm*i2pi, PI2);\n    float amp = rad*(1.0-(i-1.0)/dots);\n    float cang = i2pi/dots;\n    float fade = 0.7 - pow(smoothstep(0.0,1.0,ang),2.0)*0.5;\n     star_pos = vec2(cos(ang) * amp, -sin(ang) * amp);\n    gradient += (cos(cang+colorsep) + 1.0/2.0) * ((fade / 384.0) / pow(length(star_pos - pq), 1.5)) * fade;\n  \n  \tintersectSphere(rayOrigin, rayDir, vec3(star_pos.x,  star_pos.y, 0.3), 0.03, rayT, geomNormal);\n\n  \n  }\n    \n\n}\n\nvoid sampleUniform(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\tdist = u*maxDistance;\n\tpdf = 1.0/maxDistance;\n}\n\nvoid sampleScattering(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\t// remap u to account for finite max distance\n\tfloat minU = exp(-SIGMA*maxDistance);\n\tfloat a = u*(1.0 - minU) + minU;\n\n\t// sample with pdf proportional to exp(-sig*d)\n\tdist = -log(a)/SIGMA;\n\tpdf = SIGMA*a/(1.0 - minU);\n}\n\nvoid sampleEquiAngular(\n\tfloat u,\n\tfloat maxDistance,\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 lightPos,\n\tout float dist,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - rayOrigin, rayDir);\n\t\n\t// get distance this point is from light\n\tfloat D = length(rayOrigin + delta*rayDir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n\tdist = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\tvec3 lightPos = vec3(0.8*sin(iTime*7.0/4.0), 0.8*sin(iTime*5.0/4.0), 0.0);\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightIntensity = vec3(LIGHT_POWER)*200.0;\n\tvec3 surfIntensity = vec3(SURFACE_ALBEDO/PI);\n\tvec3 particleIntensity = vec3(1.0/(900.0*PI));\n\t\n\tvec3 rayOrigin, rayDir;\n\tsampleCamera(vec2(0.5, 0.5), rayOrigin, rayDir, fragCoord);\n\t\n\n\t\n\tvec3 col = vec3(0.0);\n\tfloat t = DIST_MAX;\n\t{\n\t\tvec3 n;\n\t\tintersectScene(rayOrigin, rayDir, fragCoord, t, n);\n\t\t\n\t\tif (t < DIST_MAX) {\n\t\t\t// connect surface to light\n\t\t\tvec3 surfPos = rayOrigin + t*rayDir;\n\t\t\tvec3 lightVec = lightPos - surfPos;\n\t\t\tvec3 lightDir = normalize(lightVec);\n\t\t\tvec3 cameraDir = -rayDir;\n\t\t\tfloat nDotL = dot(n, lightDir);\n\t\t\tfloat nDotC = dot(n, cameraDir);\n\t\t\t\n\t\t\t// only handle BRDF if entry and exit are same hemisphere\n\t\t\tif (nDotL*nDotC > 0.0) {\n\t\t\t\tfloat d = length(lightVec);\n\t\t\t\tfloat trans = exp(-SIGMA*(d + t));\n\t\t\t\tfloat geomTerm = abs(nDotL)/dot(lightVec, lightVec);\n\t\t\t\tcol = surfIntensity*lightIntensity*geomTerm*trans;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfloat offset = hash(fragCoord.y*iResolution.x + fragCoord.x + iTime);\n\tfor (int stepIndex = 0; stepIndex < STEP_COUNT; ++stepIndex) {\n\t\tfloat u = (float(stepIndex)+offset)/float(STEP_COUNT);\n\t\t\n\t\t// sample along ray from camera to surface\n\t\tfloat x;\n\t\tfloat pdf;\n\n\t\t\tsampleEquiAngular(u, t, rayOrigin, rayDir, lightPos, x, pdf);\n\t\n\t\t\n\t\t// adjust for number of ray samples\n\t\tpdf *= float(STEP_COUNT); /// looks amazing!!!!\n\t\t\n\t\t// connect to light and check shadow ray\n\t\tvec3 particlePos = rayOrigin + x*rayDir;\n        //vec3 particlePos = vec3(1.0,0.0,0.0);\n\t\tvec3 lightVec = lightPos - particlePos;\n\t\tfloat d = length(lightVec);\n\t\tfloat t2 = d;\n\t\tvec3 n2;\n\t\tintersectScene(particlePos, normalize(lightVec), fragCoord, t2, n2);\n\t\t\n\t\t// accumulate particle response\n\t\tif (t2 == d) {\n\t\t\tfloat trans = exp(-SIGMA*(d + x));\n\t\t\tfloat geomTerm = 1.0/dot(lightVec, lightVec);\n\t\t\tcol += SIGMA*particleIntensity*lightIntensity*geomTerm*trans/pdf;\n\t\t}\n\t}\n\n\n\n\t\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xls3zX","date":"1423867359","viewed":327,"name":" Volumetric whitney rose","username":"strimbob","description":"from https://www.shadertoy.com/view/4dsSRM, and https://www.shadertoy.com/view/Xdf3zB","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spiral","media","homogenous","whitney"],"hasliked":0,"parentid":"","parentname":""}}