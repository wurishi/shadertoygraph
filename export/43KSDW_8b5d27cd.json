{"ver":"0.1","info":{"id":"43KSDW","date":"1719952369","viewed":26,"name":"not my not first raytracer","username":"NoahSchrr","description":"f*cks","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    float material; \n};\n\n\nfloat randVec3(vec3 coords) {\n    return fract(sin(dot(coords, vec3(12.9898, 78.233, 45.543))) * 43758.5453);\n}\n\nfloat randVec2(vec2 coords) {\n    return fract(sin(dot(coords, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\nvec3 random_unit_sphere(vec3 smCords){\n    vec3 hitPoint;\n    float test = randVec2(smCords.xz*smCords.xz);\n    do {\n        hitPoint = 2.0*vec3(randVec3(smCords.xyz), randVec3(vec3(smCords.xy, test*smCords.x)), randVec3(vec3(smCords.zy, test*test))) - vec3(1.0,1.0,1.0); // filled with bogus, maybe adjust in the future\n       } while ( dot(hitPoint, hitPoint) >= 1.0); \n    return hitPoint;\n}\n\n    \nvec3 lambertian(vec3 hitPoint, vec3 normal) {\n    vec3 target = hitPoint + normal + random_unit_sphere(hitPoint);\n    return normalize(target - hitPoint);\n}\n\nvec3 metal(vec3 rayDir, vec3 normal, float fuzz) {\n    vec3 reflected = reflect(rayDir, normal);\n    reflected += fuzz * random_unit_sphere(rayDir);\n    return normalize(reflected);\n}\n\n\n\n\nfloat hit_sphere(vec3 rayOrigin, vec3 rayDir, out Sphere hitSphere, const Sphere spheres[4], const int NUM_SPHERES) {\n    float closestHit = -1.0;\n    for (int i = 0; i < NUM_SPHERES; ++i) {\n        Sphere sphere = spheres[i];\n        vec3 oc = rayOrigin - sphere.center;\n        float a = dot(rayDir, rayDir);\n        float b = 2.0 * dot(oc, rayDir);\n        float c = dot(oc, oc) - sphere.radius * sphere.radius;\n        float discriminant = b * b - 4.0 * a * c;\n        \n        if (discriminant >= 0.0) \n        {\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            if (t > 0.0 && (closestHit < 0.0 || t < closestHit)) \n            {\n                closestHit = t;\n                hitSphere = sphere;\n            }\n        }\n    }\n    return closestHit;\n}\n\nvec3 color(vec3 rayDir, vec3 rayOrigin, const Sphere spheres[4], const int NUM_SPHERES) {\n    const int MAX_RECURSION_DEPTH = 50;\n    vec3 col = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n\n    for (int depth = 0; depth < MAX_RECURSION_DEPTH; ++depth) {\n        Sphere hitSphere;\n        float t = hit_sphere(rayOrigin, rayDir, hitSphere, spheres, NUM_SPHERES);\n\n        if (t > 0.0001) {\n            vec3 hitPoint = rayOrigin + t * rayDir;\n            vec3 normal = normalize(hitPoint - hitSphere.center);\n\n            if (int(hitSphere.material) == 1) {\n                float fuzz = fract(hitSphere.material); // Fuzzyness stored as decimal\n                rayDir = metal(rayDir, normal, fuzz);\n            } else {\n                rayDir = lambertian(hitPoint, normal);     \n            }\n\n            rayOrigin = hitPoint;\n            attenuation *= hitSphere.color;\n        } else {\n            // Background color (sky color) when no sphere is hit\n            vec3 unitDirection = normalize(rayDir);\n            t = 0.5 * (unitDirection.y + 1.0);\n            col = attenuation * mix(vec3(0.11, 0.22, 0.75), vec3(1.00, 0.91, 0.86), t);\n            break; // Exit the loop since no intersection\n        }\n    }\n\n    return sqrt(col); // Apply square root for gamma correction (if needed)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0; \n     \n    \n    // Camera setup\n    vec3 sphereCenter = vec3(0.0, sin(iTime)/21.2, 0.0);\n    vec3 cameraPos = vec3(sin(iTime)/1.5, 0.20, cos(iTime)/1.5);   \n    vec3 cameraDir = normalize(sphereCenter - cameraPos); \n    vec3 cameraRight = normalize(cross(vec3(0.0, 1.0, 0.0), cameraDir));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    float fov = 90.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n \n    \n    \n    const int NUM_SPHERES = 4;\n\n    Sphere spheres[NUM_SPHERES];\n    spheres[0] = Sphere(vec3(0.0, -200.2, -0.0), 200.0, vec3(0.31, 0.41, 0.59), 0.0); \n    spheres[1] = Sphere(vec3(0.0, 0.0, -0.45), 0.2, vec3(0.89, 0.28, 0.37), 0.0);\n    spheres[2] = Sphere(vec3(0.0, 0.0,  0.45), 0.2, vec3(0.09, 0.95, 0.95), 0.0);\n    spheres[3] = Sphere(vec3(0.0, 0.0,  0.0), 0.2, vec3(1.0), 1.2);\n    \n    const int ANTI_ALIAS = 50;\n    vec3 outPutColor = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 1; i < ANTI_ALIAS; ++i) {\n        float randA = randVec2(uv.xy * vec2(float(i) + 1.0)) / 200.0; \n        float randB = randVec2(uv.yx * vec2(float(i) + 1.0)) / 200.0;\n        vec3 rayDir = normalize(cameraDir + (randA + uv.x) * cameraRight * aspectRatio * tan(radians(fov) / 2.0) + (randB + uv.y) * cameraUp * tan(radians(fov) / 2.0));\n        outPutColor += color(rayDir, cameraPos, spheres, NUM_SPHERES);\n    }\n    \n    outPutColor /= float(ANTI_ALIAS);\n    \n    \n    fragColor = vec4(outPutColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}