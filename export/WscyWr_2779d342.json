{"ver":"0.1","info":{"id":"WscyWr","date":"1620258926","viewed":117,"name":"Path Tracing - clopezgarces","username":"clopezgarces","description":"Path tracing.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    color *= c_exposure;\n    \n    color = ACESFilm(color);\n    \n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct SRayHitInfo {\n\tfloat dist;\n    vec3 normal;\n\tSMaterialInfo material;\n};\n    \nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere) {\n\tvec3 m = rayPos - sphere.xyz;\n    \n    float b = dot(m, rayDir);\n    \n    float c = dot(m, m) - sphere.w*sphere.w;\n    \n    if (c > 0.0 && b > 0.0) {\n    \treturn false;\n    }\n    \n    float discriminant = b*b - c;\n    \n    if (discriminant < 0.0f) {\n    \treturn false;\n    }\n    \n    bool fromInside = false;\n    float dist = -b -sqrt(discriminant);\n    if (dist < 0.0f) {\n    \tfromInside = true;\n        dist = -b + sqrt(discriminant);\n    }\n    \n    if (dist > c_minimumRayHitTime && dist < info.dist) {\n    \tinfo.dist = dist;\n        info.normal = normalize((rayPos+rayDir * dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n    \treturn true;\n    }\n    \n    return false;\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nvoid TestSceneCornellBox(\n    in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, bool off\n) {\n    if (off) return;\n    \n    const float floorLevel = -9.9f;\n    const float ceilingLevel = 9.9f;\n    const float backWallLevel = 30.0f;\n    const float boxWidth = 20.0f;\n    \n\t// Cornell box.\n\n    {\n        vec3 A = vec3(-10.0f, floorLevel, backWallLevel);\n        vec3 B = vec3(-10.0f,  10.0f, backWallLevel);\n        vec3 C = vec3( 10.0f,  10.0f, backWallLevel);\n        vec3 D = vec3( 10.0f, floorLevel, backWallLevel);\n\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = backWallMaterial;\n        }\n\t}\n    \n    {\n        vec3 A = vec3(-10.0f, floorLevel, backWallLevel);\n        vec3 B = vec3(10.0f, floorLevel, backWallLevel);\n        vec3 C = vec3(10.0f, floorLevel, 20.0f);\n        vec3 D = vec3(-10.0f, floorLevel, 20.0f);\n\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = floorMaterial;\n        }\n\t}\n    \n    {\n        vec3 A = vec3(-10.0f, ceilingLevel, backWallLevel);\n        vec3 B = vec3(-10.0f, ceilingLevel, 20.0f);\n        vec3 C = vec3(10.0f, ceilingLevel, 20.0f);\n        vec3 D = vec3(10.0f, ceilingLevel, backWallLevel);\n        \n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = ceilingMaterial;\n        }\n\t}\n    \n    {\n        vec3 A = vec3(-9.9f, floorLevel-0.1f, backWallLevel);\n        vec3 B = vec3(-9.9f, floorLevel-0.1f, 20.0f);\n        vec3 C = vec3(-9.9f, ceilingLevel+0.1f, 20.0f);\n        vec3 D = vec3(-9.9f, ceilingLevel+0.1f, backWallLevel);\n\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = leftWallMaterial;\n        }\n\t}\n    \n    {\n        vec3 A = vec3(9.9f, floorLevel-0.1f, backWallLevel);\n        vec3 B = vec3(9.9f, ceilingLevel+0.1f, backWallLevel);\n        vec3 C = vec3(9.9f, ceilingLevel+0.1f, 20.0f);\n        vec3 D = vec3(9.9f, floorLevel-0.1f, 20.0f);\n\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = rightWallMaterial;\n        }\n\t}\n    \n    // Rectangular area light.\n    \n    {\n        vec3 A = vec3(-4.0f, ceilingLevel-0.1f, 27.5f);\n        vec3 B = vec3(-4.0f, ceilingLevel-0.1f, 22.5f);\n        vec3 C = vec3(4.0f, ceilingLevel-0.1f, 22.5f);\n        vec3 D = vec3(4.0f, ceilingLevel-0.1f, 27.5f);\n        \n\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = lightMaterial;\n        }\n\t}\n    \n    // Spheres.\n    \n    float radius = 2.5f;\n    \n    if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.8f+radius, floorLevel+0.1f+radius, 25.0f, radius))) {\n        hitInfo.material = leftSphereMaterial;\n    } \n     \n    if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, floorLevel+0.1f+radius, 25.0f, radius))) {\n        hitInfo.material = middleSphereMaterial;  \n    }    \n     \n    if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.8f-radius, floorLevel+0.1f+radius, 25.0f, radius))) {\n        hitInfo.material = rightSphereMaterial;\n    }\n    \n    // Small spheres.\n    \n    float smallRadius = 1.3f;\n    int smallCount = 5;\n    float smallTotalSpan = boxWidth - 2.0f*0.2f;\n    float centerDistance = (smallTotalSpan-2.0f*smallRadius)/4.0f;\n    float center = -smallTotalSpan/2.0f+smallRadius;\n    \n    for (\n        int i=0; \n        i<smallCount; \n        ++i, center+=centerDistance\n    ) {\n    \tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(center, 0.0f, backWallLevel-smallRadius, smallRadius))) {\n        \thitInfo.material = createMaterial(\n            \t// Albedo.\n                vec3(0.0f, 1.0f, 0.0f),\n                // Emissive.\n                vec3(0.0f, 0.0f, 0.0f),\n                // SpecularChance.\n                0.5f,\n                // SpecularRoughness.\n                0.2f*float(i),\n                // SpecularColor.\n                vec3(1.0f, 1.0f, 1.0f),\n                // IOR.\n    \t\t\t1.0f,\n                // RefractionChance.\n                0.0f,\n                // RefractionRoughness.\n                0.0f,\n                // RefractionColor.\n                vec3(0.0f, 0.0f, 0.0f)\n            );\n    \t}\n    }\n}\n\nvoid TestSceneFresnel(\n    in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, bool off\n) {\n    if (off) {\n    \treturn;\n    }\n    \n    const float ceilingLevel = 10.0f;\n    const float ceilingFarEnd = 35.0f;\n\tconst float ceilingWidth = 10.0f;\n\tconst float ceilingDepth = 10.0f;\n\n    const float lightRectWidth = ceilingWidth*0.7f;\n    const float lightRectDepth = ceilingDepth*0.8f;\n    \n    // Ceiling.\n    \n    {\n        vec3 A = vec3(-ceilingWidth/2.0f, ceilingLevel, ceilingFarEnd);\n        vec3 B = vec3(-ceilingWidth/2.0f, ceilingLevel, ceilingFarEnd-ceilingDepth);\n        vec3 C = vec3(ceilingWidth/2.0f, ceilingLevel, ceilingFarEnd-ceilingDepth);\n        vec3 D = vec3(ceilingWidth/2.0f, ceilingLevel, ceilingFarEnd);\n        \n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = ceilingMaterial;\n        }\n\t}\n    \n    // Rectangular area light.\n    \n    {\n        vec3 A = vec3(-lightRectWidth/2.0f, ceilingLevel-0.1f, ceilingFarEnd-2.5f);\n        vec3 B = vec3(-lightRectWidth/2.0f, ceilingLevel-0.1f, ceilingFarEnd-lightRectDepth);\n        vec3 C = vec3(lightRectWidth/2.0f, ceilingLevel-0.1f, ceilingFarEnd-lightRectDepth);\n        vec3 D = vec3(lightRectWidth/2.0f, ceilingLevel-0.1f, ceilingFarEnd-2.5f);\n        \n\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D)) {\n        \thitInfo.material = lightMaterial;\n        }\n\t}\n \n    // Spheres.\n    \n    float radius = 5.0f;\n    float separation = 7.0f;\n    \n    SMaterialInfo leftSphereMaterial = createMaterial(\n\t\t// Albedo.\n        vec3(0.9f, 0.25f, 0.25f),\n        // Emissive.\n    \tvec3(0.0f, 0.0f, 0.0f),\n    \t// SpecularChance.\n        0.02f,\n    \t// SpecularRoughness.\n        0.0f,\n    \tvec3(1.0f, 1.0f, 1.0f),\n        // IOR.\n    \t1.0f,\n        // RefractionChance.\n        0.0f,\n        // RefractionRoughness.\n        0.0f,\n        // RefractionColor.\n        vec3(0.0f, 0.0f, 0.0f)\n    );\n    \n    SMaterialInfo rightSphereMaterial = createMaterial(\n\t\t// Albedo.\n        vec3(0.9f, 0.25f, 0.25f),\n        // Emissive.\n    \tvec3(0.0f, 0.0f, 0.0f),\n    \t// SpecularChance.\n        0.02f,\n    \t// SpecularRoughness.\n        0.0f,\n    \tvec3(1.0f, 1.0f, 1.0f),\n        // IOR.\n    \t2.0f,\n        // RefractionChance.\n        0.0f,\n        // RefractionRoughness.\n        0.0f,\n        // RefractionColor.\n        vec3(0.0f, 0.0f, 0.0f)\n    );\n    \n    if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-radius-separation/2.0f, -2.0f, 20.0f, radius))) {\n        hitInfo.material = leftSphereMaterial;\n    } \n     \n    if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(radius+separation/2.0f, -2.0f, 20.0f, radius))) {\n        hitInfo.material = rightSphereMaterial;  \n    }\n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState) {\n    // A single hitInfo is shared across Test*Trace() calls:\n    // the info from the previous calls is used to make a decision:\n    // if the ray hits the object but it has already hit an object that\n    // is closer to the ray's origin, that hit is discarded.\n\tSRayHitInfo hitInfo;\n    hitInfo.dist = c_superFar;\n    \n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    \n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex) {\n    \tSRayHitInfo hitInfo;\n        hitInfo.dist = c_superFar;\n        \n        TestSceneCornellBox(rayPos, rayDir, hitInfo, false);\n        \n        if (hitInfo.dist == c_superFar) {\n            // TestSceneTrace didn't update dist: no intersections.\n\n\t\t\t// Sample the environment cubemap.\n            color += SRGBToLinear(texture(iChannel1, rayDir).rgb) * 1.0f/c_exposure * throughput;\n\n            break;\n        }\n        \n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        \n        SMaterialInfo material = hitInfo.material;\n                \n        // Fresnel.\n        float specularChance = material.specularChance;\n        if (specularChance > 0.0f) {\n        \tspecularChance = FresnelReflectAmount(\n            \t1.0f,\n                material.IOR,\n                hitInfo.normal,\n                rayDir,\n                material.specularChance, \n                1.0f\n            );\n        }\n        \n\t\tfloat doSpecular = (RandomFloat01(rngState) < specularChance) ? 1.0f : 0.0f;\n        \n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        \n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        \n        // Square the rougness interpolator to make reflections less glossy and more specular.\n        // (A fraction squared becomes smaller, tilting the scale in favor of specularity.)\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, material.specularRoughness*material.specularRoughness));\n        \n        // No need to normalize: doSpecular is either 0.0 or 1.0.\n        // Interpolation returns diffuseRayDir or specularRayDir intact. \n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        \n        color += hitInfo.material.emissive * throughput;\n        \n        // Cumulative absorption.\n        throughput *= mix(material.albedo, material.specularColor, doSpecular);\n        \n        throughput /= (doSpecular == 1.0f) ? specularChance : max(1.0f - specularChance, 0.001f);\n    \n    \t// Russian roulette: stop short some rays.\n        {\n        \tfloat p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p) {\n\t\t\t\tbreak;\n            }\n            \n            throughput *= 1.0f / p;\n        }\n    }\n    \n    return color;\n}\n\nvoid GetCameraVectors(\n    out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight\n) {\n\tvec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f) {\n    \tcameraPos = vec3(0.0f, 0.0f, -c_cameraDistance);\n        cameraFwd = vec3(0.0f, 0.0f, 1.0f);\n        cameraUp = vec3(0.0f, 1.0f, 0.0f);\n        cameraRight = vec3(1.0f, 0.0f, 0.0f);\n        return;\n    }\n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n\t\n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(vec3(0.0f, 1.0f, 0.0f), cameraFwd));\n\tcameraUp = normalize(cross(cameraFwd, cameraRight));\n}\n\n\n// Image corners to coordinates: LL:(0,0), LR:(1,0), UL:(0,1), UR:(1,1).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState \n    \t= uint(\n            uint(fragCoord.x) * uint(1973) \n            + uint(fragCoord.y) * uint(9277) \n            + uint(iFrame) * uint(26699))\n          | uint(1);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    // Shift coordinates by half the resolution, to get a range of [-1,1] on both axes.\n    // vec2 pixelTarget2D = uv * 2.0f - 1.0f;\n    // 4 quadrants (R=+,G=+), (R=-,G=+), (R=-,G=-), (R=+,G=-). Red and green components that are <1 are clamped to 0.\n    // That's why quadrant II is mostly green (R=0,G=->1) and quadrant III is all black (R=0,G=0).\n    // fragColor = vec4(pixelTarget2D, 0.0f, 1.0f);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 antialiasJitter = vec2(\n        RandomFloat01(rngState) - 0.5f,\n        RandomFloat01(rngState) - 0.5f\n    );\n    \n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n    \n            \n    // Maps fragment coordinates from ([0, iResolution.x],[0, iResolution.y]) to ([-1, 1], [-1, 1]).\n    // But iResolution has an aspect ratio that is not 1:1.\n    // So we mapped the viewport of some non-1:1 aspect ratio (maybe 16:9) to\n    // an image with 1:1 aspect ratio. We shrank the image horizontally to make it a square.\n    vec2 rayTarget = vec2(((fragCoord+antialiasJitter)/iResolution.xy) * 2.0 - 1.0f);\n    // Now give the image the aspect ratio of the viewport.\n    rayTarget.y *= 1.0f / aspectRatio;\n    \n    float cameraDistance = tan(c_FOVDegrees * 0.5 * c_pi / 180.0f);\n    \n    vec3 rayDir = vec3(rayTarget, cameraDistance);\n    rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    \n    vec3 rayColor = vec3(0.0f, 0.0f, 0.0f);\n    for (int i=0; i<c_numRendersPerFrame; ++i) {\n    \trayColor += GetColorForRay(cameraPos, rayDir, rngState) / float(c_numRendersPerFrame);\n    }\n\t\n    // Reset render with spacebar.\n    bool spacePressed = (texture(iChannel2, vec2(32.5f/256.0f, 0.25)).x > 0.1);\n\t\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (iFrame < 2 || iMouse.z > 0.0f || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n\trayColor = mix(lastFrameColor.rgb, rayColor, blend);\n    \n    fragColor = vec4(rayColor, blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float c_minimumRayHitTime = 0.1f;\n\nconst float c_superFar = 10000.0f;\n\nconst float c_largestUInt = 4294967296.0;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nconst int c_numBounces = 8;\n\n// Camera parameters.\nconst float c_minCameraAngle = 0.01f;\nconst float c_maxCameraAngle = c_pi - 0.01f;\nconst vec3 c_cameraAt = vec3(0.0f, 0.0f, 20.0f);\nconst float c_cameraDistance = 20.0f;\n\n// A bouncing ray is nudged a little along the hit's normal so that it doesn't\n// intersect the same surface next.\nconst float c_rayPosNormalNudge = 0.01f;\n\nconst float c_exposure = 0.5;\n\nconst float c_FOVDegrees = 90.0f;\n\nconst int c_numRendersPerFrame = 8;\n\nvec3 LessThan(vec3 f, float value) {\n\treturn vec3(\n    \t(f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f\n    );\n}\n\nvec3 LinearToSRGB(vec3 rgb) {\n\trgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n    \tpow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 srgb) {\n\tsrgb = clamp(srgb, 0.0f, 1.0f);\n    \n    return mix(\n    \tpow(((srgb + 0.055f) / 1.055f), vec3(2.4f)),\n        srgb / 12.92f,\n        LessThan(srgb, 0.04045f)\n    );\n}\n\n// x is a linear color.\n// Returns a linear color.\nvec3 ACESFilm(vec3 x) {\n\tfloat a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nuint wang_hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {\n    // Random float between 0 and 1.\n\treturn float(wang_hash(state)) / c_largestUInt;\n}\n\nvec3 RandomUnitVector(inout uint state) {\n    // Between -1 and 1.\n\tfloat z = RandomFloat01(state) * 2.0f - 1.0f;\n    \n    // Random angle in unit circle on xy plane.\n    float a = RandomFloat01(state) * c_twopi;\n    \n    // See http://www.math.union.edu/research/student/1998/tolin/dome.htm.\n    // 1 is the radius of the unit circle.\n    // z is a random distance away from the xy plane in either direction,\n    // capped at the sphere's radius.\n    // The radicand 1 - z^2 is one side of the sphere's implicit equation:\n    //\t\tx^2 + y^2 = R^2 - z^2.\n    float r = sqrt(1.0f - z*z);\n    \n    // Parametric equation of the hemisphere.\n    float x = r * cos(a);\n    float y = r * sin(a);\n    \n    return vec3(x, y, z);\n}\n\nstruct SMaterialInfo {\n\tvec3 albedo;\n    vec3 emissive;\n    float specularChance;\n    float specularRoughness;\n    vec3 specularColor;\n    float IOR;\n    float refractionChance;\n    float refractionRoughness;\n    vec3 refractionColor;\n};\n    \nSMaterialInfo createMaterial(\n\tvec3 albedo,\n    vec3 emissive,\n    float specularChance,\n    float specularRoughness,\n    vec3 specularColor,\n    float IOR,\n    float refractionChance,\n    float refractionRoughness,\n    vec3 refractionColor\n) {\n\treturn SMaterialInfo(\n    \talbedo, emissive, \n        specularChance, specularRoughness, specularColor, \n        IOR,\n        refractionChance, refractionRoughness, refractionColor\n    );\n}\n    \nconst SMaterialInfo backWallMaterial = SMaterialInfo(\n\t// Albedo.\n    vec3(0.7f, 0.7f, 0.7f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.0f,\n    // SpecularRoughness.\n    0.0f,\n    // SpecularColor.\n    vec3(0.0f, 0.0f, 0.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo leftWallMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(1.0f, 0.1f, 0.1f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.0f,\n    // SpecularRoughness.\n    0.0f,\n    // SpecularColor.\n\tvec3(0.0f, 0.0f, 0.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo rightWallMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.1f, 1.0f, 0.1f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.0f,\n    // SpecularRoughness.\n    0.0f,\n    // SpecularColor.\n    vec3(0.0f, 0.0f, 0.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo floorMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.7f, 0.7f, 0.7f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.0f,\n    // SpecularRoughness.\n    0.0f,\n    // SpecularColor.\n    vec3(0.0f, 0.0f, 0.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo ceilingMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.7f, 0.7f, 0.7f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.0f,\n    // SpecularRoughness.\n    0.0f,\n    // SpecularColor.\n    vec3(0.0f, 0.0f, 0.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo lightMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.0f, 0.0f, 0.0f),\n    // Emissive.\n    vec3(1.0f, 0.9f, 0.7f) * 10.0f,\n    // SpecularChance.\n    0.0f,\n    // SpecularRoughness.\n    1.0f,\n    // SpecularColor.\n    vec3(0.0f, 0.0f, 0.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo leftSphereMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.9f, 0.9f, 0.5f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.1f,\n    // SpecularRoughness.\n    0.2f,\n    // SpecularColor.\n    vec3(0.9f, 0.9f, 0.9f),\n    // IOR.\n    1.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nconst SMaterialInfo middleSphereMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.9f, 0.5f, 0.9f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.3f,\n    // SpecularRoughness.\n    0.2f,\n    // SpecularColor.\n    vec3(0.9f, 0.9f, 0.9f),\n    // IOR.\n    1.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nSMaterialInfo rightSphereMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(0.0f, 0.0f, 1.0f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.5f,\n    // SpecularRoughness.\n    0.4f,\n    // SpecularColor.\n    vec3(1.0f, 0.0f, 0.0f),\n    // IOR.\n    1.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nSMaterialInfo mirrorMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(1.0f, 1.0f, 1.0f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.5f,\n    // SpecularRoughness.\n    0.0f,\n    // SpecularColor.\n    vec3(1.0f, 1.0f, 1.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nSMaterialInfo semiMirrorMaterial = SMaterialInfo(\n    // Albedo.\n    vec3(1.0f, 1.0f, 1.0f),\n    // Emissive.\n    vec3(0.0f, 0.0f, 0.0f),\n    // SpecularChance.\n    0.5f,\n    // SpecularRoughness.\n    0.01f,\n    // SpecularColor.\n    vec3(1.0f, 1.0f, 1.0f),\n    // IOR.\n    0.0f,\n    // RefractionChance.\n    0.0f,\n    // RefractionRoughness.\n    0.0f,\n    // RefractionColor.\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\n// Schlick returns an approximation of the specular reflection coefficient.\n// n1 is the refractive index of the 1st medium.\n// n2 is the refractive index of the 2nd medium.\n// cosTheta is the cosine of the angle between the additive inverse of the\n// incident vector and the normal.\nfloat Schlick(float n1, float n2, float cosTheta) {\n    // r0 is the specular reflection coefficient when the incident\n    // vector is parallel to the normal.\n    float r0 = pow((n1-n2) / (n1+n2), 2.0f);\n        \n    // r is the specular reflection coefficient, which is what the\n    // Schlick polynomial approximates.\n    float r = r0 + (1.0f-r0)*pow(1.0f-cosTheta, 5.0f);\n    \n    return r;\n}\n\n// f0 and f90 are properties of the material.\n// f0 is the reflectance of the material when the angle of incidence is 0.\n// f90 is the reflectance when the angle of incidence is 90.\nfloat FresnelReflectAmount(\n    float n1, float n2, vec3 normal, vec3 incident, float f0, float f90\n) {\n\tfloat cosTheta = dot(-incident, normal);\n\n    if (n1 > n2) {\n    \tfloat sinThetaP = n1/n2 * sqrt(1.0f - pow(cosTheta, 2.0f));\n        \n        if (sinThetaP > 1.0f) {\n        \t// Total internal reflection.\n            return f90;\n        }\n        \n        float cosThetaP = sqrt(1.0f - pow(sinThetaP, 2.0f));\n        return mix(f0, f90, Schlick(n1, n2, cosThetaP));\n    }\n    \n    // Schlick returns the reflectance coefficient for the given angle of\n    // incidence. This coefficient ranges from r0, the coefficient for a\n    // 0-degree angle of incidence, to r90, the coefficient for a 90-degree\n    // angle of incidence. The coefficient is used to interpolate across the\n    // 2 extremes of reflectance of the material. \n\treturn mix(f0, f90, Schlick(n1, n2, cosTheta));\n}\n","name":"Common","description":"","type":"common"}]}