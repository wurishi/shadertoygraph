{"ver":"0.1","info":{"id":"3dBBRw","date":"1677014851","viewed":54,"name":"van Damme got the star powerup","username":"toteload","description":"messing around with HSV","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["distortion","hsv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ugly ass code that i mindlessly ported from a stackoverflow post\nvec3 hsv_to_rgb(vec3 hsv) {\n    vec3 rgb;\n    \n    if (hsv.y < 0.0) {\n        rgb.r = hsv.z;\n        rgb.g = hsv.z;\n        rgb.b = hsv.z;\n        return rgb;\n    }\n    \n    float hh = hsv.x;\n    if (hh >= 360.0) { hh = 0.0; }\n    hh /= 60.0;\n    int i = int(hh);\n    float ff = hh - float(i);\n    float p = hsv.z * (1.0 - hsv.y);\n    float q = hsv.z * (1.0 - (hsv.y * ff));\n    float t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));\n    \n    switch (i) {\n        case 0: { rgb.r = hsv.z; rgb.g = t; rgb.b = p; } break;\n        case 1: { rgb.r = q; rgb.g = hsv.z; rgb.b = p; } break;\n        case 2: { rgb.r = p; rgb.g = hsv.z; rgb.b = t; } break;\n        case 3: { rgb.r = p; rgb.g = q; rgb.b = hsv.z; } break;\n        case 4: { rgb.r = t; rgb.g = p; rgb.b = hsv.z; } break;\n        case 5: default: { rgb.r = hsv.z; rgb.g = p; rgb.b = q; } break;\n    }\n    \n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 f = hsv_to_rgb(vec3(texture(iChannel0, uv + vec2(80.0, 0.0) / iResolution.xy).r,\n    //                         texture(iChannel0, uv + vec2(-80.0, 0.0) / iResolution.xy).g,\n    //                         texture(iChannel0, uv + vec2(00.0, 0.0) / iResolution.xy).b));\n    \n    //vec3 f = hsv_to_rgb(vec3((0.5 * (1.0 + sin(iTime))) * 360.0, 1.0, 1.0));\n    \n    float t = fract(iTime);\n    vec3 f = hsv_to_rgb(vec3(t * 360.0,\n                             1.0,\n                             texture(iChannel0, uv + vec2(0.0, 0.0) / iResolution.xy).b));\n    \n    vec3 v;\n    if (texture(iChannel0, uv).w == 0.0) {\n        v = f;\n    } else {\n    \tv = vec3(0.0); //hsv_to_rgb(texture(iChannel0, uv).rgb);\n    }\n    \n    // Output to screen\n    fragColor = vec4(v, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// .x = h\n// .y = s\n// .z = v\nvec3 rgb_to_hsv(vec3 rgb) {\n\tvec3 hsv;\n    \n    float minrgb = min(rgb.r, min(rgb.g, rgb.b));\n    float maxrgb = max(rgb.r, max(rgb.g, rgb.b));\n    \n    hsv.z = maxrgb;\n    float delta = maxrgb - minrgb;\n    if (delta < 0.0001) {\n        hsv.x = 0.0;\n        hsv.y = 0.0;\n        return hsv;\n    }\n    \n    if (maxrgb > 0.0) {\n        hsv.y = (delta / maxrgb);\n    } else {\n        hsv.y = 0.0;\n        hsv.x = 0.0; // should be NaN but FUCK IT\n        return hsv;\n    }\n    \n    if (rgb.r >= maxrgb) {\n    \thsv.x = (rgb.g - rgb.b) / delta;\n    } else {\n        if (rgb.g >= maxrgb) {\n            hsv.x = 2.0 + (rgb.b - rgb.r) / delta;\n        } else {\n            hsv.x = 4.0 + (rgb.r - rgb.g) / delta;\n        }\n    }\n    \n    hsv.x *= 60.0;\n    \n    if (hsv.x < 0.0) {\n    \thsv.x += 360.0;\n    }\n    \n    return hsv;\n}\n\nbool float_equals(float x, float y) {\n    float epsilon = 0.17;\n    return (y >= x - epsilon && y <= x + epsilon);\n}\n\n// very shitty simple method.\nbool is_background(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 f = texture(iChannel0, uv).rgb;\n    \n    return (float_equals(f.r, 34.0 / 255.0) && float_equals(f.g, 166.0 / 255.0) && float_equals(f.b, 38.0 / 255.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(rgb_to_hsv(texture(iChannel0, uv).rgb), is_background(fragCoord) ? 1.0 : 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}