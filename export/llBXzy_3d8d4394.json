{"ver":"0.1","info":{"id":"llBXzy","date":"1444831261","viewed":307,"name":"sphere_eat_textured","username":"snolot","description":"More than inspired by eddietree \nhttps://www.shadertoy.com/view/lt2SDD\n\nClick to see full sphere","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// More than inspired by eddietree \n// https://www.shadertoy.com/view/lt2SDD\n\n#define SIZE 2.0\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 64;\nconst float eps = .01;\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse ){\n    float radius \t= 6. ;//+ sin(time*.25)*1.6;\n    float theta \t= 0.3 + 5.0*mouse.x - iTime*0.15;\n    float phi \t\t= .01 + 1.58 ;//* mouse.y ;//.5 + sin(iTime*.05) *2.14159 ;//mouse.y - iTime*0.5;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat smin( float a, float b, float k ){\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q, .25 );\n}\n\nfloat opScale( vec3 p, float s )\n{\n    return sdSphere(p/s, s)*s;\n}\n\nfloat opS( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 ){\n    return min(d1,d2);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2; \n}\n\nfloat opI( float d1, float d2 ){\n    return max(d1,d2);\n}\n\n// noise func\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec2 doModel( vec3 pos ){  \n  \t\n    vec3 cp = vec3( 2.0 );\n    //vec3 f = worley( pos - vec3(  0.0, 1.0,  0.0  ), cp );\n    \n    \n//    float sphere = sdDisplacementSphere( pos, noise(pos), cp, 0 );\n    float sphere = sdSphere(pos, 3.95  );\n    float t1 = sphere;\n\n    \n    \n    vec3 q;\n\tvec3 c = vec3(1.2, .05, 1.2);\n    \n    if(iMouse.w>.5){\n\t\tt1 =   opS(sdTorus( pos, vec2(3.8, cos(iTime*.75)* 3.14) )+noise(pos+pos * .02 + iTime*0.5), t1);\n    }else{\n        t1 =   opS(sdTorus( pos, vec2(3.8, cos(cos(iTime*.75))* 3.14) )+noise(pos+pos * .02 + iTime*0.5), t1);\n    }\n       \n   \treturn vec2( t1, 1.0 );\n}\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float k = 2.0;\n    \n    const int maxSteps = 10;\n    float t = 0.0;\n    float res = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = doModel(ro + rd*t).x;\n            \n        if(d < INTERSECTION_PRECISION) {\n            \n            return 0.0;\n        }\n        \n        res = min( res, k*d/t );\n        t += d;\n    }\n    \n    return res;\n}\n\n\nfloat ambientOcclusion( in vec3 ro, in vec3 rd ){\n    \n    const int maxSteps = 7;\n    const float stepSize = 0.05;\n    \n    float t = 0.0;\n    float res = 0.0;\n    \n    // starting d\n    float d0 = doModel(ro).x;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        \n        float d = doModel(ro + rd*t).x;\n\t\tfloat diff = max(d-d0, 0.0);\n        \n        res += diff;\n        \n        t += stepSize;\n    }\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    doModel(pos+eps.xyy).x - doModel(pos-eps.xyy).x,\n\t    doModel(pos+eps.yxy).x - doModel(pos-eps.yxy).x,\n\t    doModel(pos+eps.yyx).x - doModel(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid doShading( vec3 ro , vec3 rd, inout vec3 color, vec3 currPos ){\n\t\n    vec3 lightDir \t= normalize(vec3(.0,0.,0.0));\n\tvec3 normal \t= calcNormal( currPos );\n    vec3 normal_distorted = calcNormal( currPos +  noise(currPos*1.5 + vec3(0.0,0.0,sin(iTime*0.75))) );\n\tfloat shadowVal = shadow( currPos - rd* 0.1, lightDir  );\n    float ao = ambientOcclusion( currPos - normal*0.01, normal );\n\n    float ndotl = abs(dot( -rd, normal ));\n    float ndotl_distorted = abs(dot( -rd, normal_distorted ));\n    float rim = pow(1.0-ndotl, 6.0);\n    float rim_distorted = pow(1.0-ndotl_distorted, 6.0);\n\n\tcolor = texture (iChannel0, reflect( rd, normal ) ).xyz;\n\t//\n\n    float distToCenter = length(currPos);\n    if ( abs(distToCenter - 4.0) < 0.08  )\n    {\n\n        vec4 pos = vec4( currPos*15.0, 1.0 );\n        color *= vec3(.7, .7, .7);\n        color = mix( color, vec3(0., 0., 0.), rim_distorted+0.05 ) * .75;\n        color += texture (iChannel0, refract( rd, normal_distorted, .75 ) ).xyz * rim*.5 + vec3(rim*.2);\n        vec3 bm = doBumpMap(iChannel1, currPos*.75, normal, .05);\n        vec3 objCol = tex3D( iChannel2, currPos*.25, bm );\n        color += objCol*.35;\n    }else{\n        color = mix( color, vec3(5., .4, .4), rim_distorted*0.5 );\n        //color += texture (iChannel0, refract( rd, normal_distorted, .75 ) ).xyz * rim + vec3(rim*.6);\n        color = mix( color, vec3(1., .7, .4), rim_distorted+0.025 );\n\t\tcolor += vec3((tex3D(iChannel1, currPos, normal)*.5).x*.8, 0., 0.);\n        color += rim;\n    }\n    \n\n\n    color *= vec3(mix(0.9,1.0,shadowVal));\n\t//\tcolor *= vec3(mix(0.4,1.0,ao)); \n    \n}\n\nvec3 rayPlaneIntersection( vec3 ro, vec3 rd, vec4 plane ){\n\tfloat t = -( dot(ro, plane.xyz) + plane.w) / dot( rd, plane.xyz );\n\treturn ro + t * rd;\n}\n\nbool renderRayMarch(vec3 ro, vec3 rd, inout vec3 color ) {\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        vec3 currPos = ro + rd * t;\n        d = doModel(currPos).x;\n        if(d < INTERSECTION_PRECISION) {\n            break;\n        }        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) {\n        vec3 currPos = ro + rd * t;\n        doShading( ro, rd, color, currPos );\n        \n        return true;\n    }\n    \n    //vec3 planePoint = rayPlaneIntersection(ro, rd, vec4(0.0, -1.0, 0.0, 1.0));\n\t//float shadowFloor = shadow( planePoint, vec3(0.0,1.0,0.0));\n\t//color = color * mix( .9, 1.0, shadowFloor );// - length(ro)\n\t//color *= vec3(.3, .6, .4);\n    \n    return false;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.0) ); // 2.0 is the lens length\n    \n    // calc color\n    vec3 col = vec3(.75, .75, .75);\n    renderRayMarch( ro, rd, col );\n    \n    // vignette, OF COURSE\n    float vignette = 1.0-smoothstep(1.0,2.5, length(p));\n    col.xyz *= mix( 0.7, 1.0, vignette);\n        \n    fragColor = vec4( col , 1. );\n}","name":"Image","description":"","type":"image"}]}