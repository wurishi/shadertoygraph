{"ver":"0.1","info":{"id":"4tSSDD","date":"1443563612","viewed":462,"name":"Enigma raytracing part","username":"Optimus","description":"Raytracing part from the Amiga demo Enigma by Phenomena.\nAdded defines for Amiga resolution, palette (not sure I am doing this correctly) and bouncing animation.\nMaybe a tune next?","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","mandelbrot","amiga","enigma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define AMIGA_RES\n#define AMIGA_PAL\n#define BOUNCING\n\nfloat time;\nvec2 resolution;\n\nconst int numBalls = 24;\nconst float radius = 0.25;\n\nconst vec3 lightPos = vec3(4.0, 4.0, 0.0);\nvec3 sphereCenter;\n\nbool hasHitSphere = false;\nvec3 floorHitPoint;\n\nconst float bounceOutTimeStart = 24.0;\nconst float bounceDuration = 4.0;\n\nvec2 amigaRes = vec2(320.0, 256.0);\n\nvec4 getColor(vec3 normal)\n{\n\tvec3 lightBack = normalize(lightPos - sphereCenter);\n\tfloat diffuse = dot(normal, lightBack);\n\tif (diffuse < 0.0) diffuse = 0.0;\n\tfloat specular = pow(diffuse, 64.0);\n\tvec4 color = vec4(vec3(0.25 + 1.0*diffuse + 4.0*specular) * vec3(0.25,1.0,0.25), 1.0);\n\treturn color;\n}\n\n\nfloat z_fractal = 1.0;\n\nconst float xpos = -0.99424;\nconst float ypos = 0.2975;\n\nconst float iter = 16.0;\nconst float iter2 = iter / 4.0;\n\nvec4 getFractalColor(vec2 tc)\n{\n\tfloat x0 = mod(0.1*tc.x + 0.9, 2.0);\n\tfloat y0 = mod(0.025*(1.0 - tc.y) + 0.7, 1.0);\n\n\tfloat z0_r = 0.0;\n\tfloat z0_i = 0.0;\n\tfloat z1_r = 0.0;\n\tfloat z1_i = 0.0;\n\tfloat p_r = (x0 + xpos * z_fractal) / z_fractal;\n\tfloat p_i = (y0 + ypos * z_fractal) / z_fractal;\n\tfloat d = 0.0;\n\n\tfloat nn = 0.0;\n\tfor (float n=0.0; n<iter; n++)\n\t{\n\t\tz1_r = z0_r * z0_r - z0_i * z0_i + p_r;\n\t\tz1_i = 2.0 * z0_r * z0_i + p_i;\n\t\td = sqrt(z1_i * z1_i + z1_r * z1_r);\n\t\tz0_r = z1_r;\n\t\tz0_i = z1_i;\n\t\tif (d > iter2) break;\n\t\tnn++;\n\t}\n\n\tfloat c = (1.0*nn) / iter;\n\tif (c==1.0) c = 0.0;\n\tc *= 4.0;\n\tvec4 color = vec4(1.0*c, 1.0*c, 4.0*c, 0.0);\n\treturn color;\n}\n\nvec4 getSphereColor(vec3 pos, vec3 dir, float index)\n{\n\tvec4 color = vec4(0.0);\n\t\n\tfloat yy = -0.4 + sin(index * 0.5);\n\t\n\tvec3 startCenter = vec3(-2.0, yy, 4.0);\n\tvec3 endCenter = vec3(4.0, yy, 32.0);\n\tsphereCenter = startCenter + (endCenter - startCenter) * (index / float(numBalls));\n\t\n\thasHitSphere = false;\n\n\tpos -= sphereCenter;\n\n\tfloat b = 2.0 * dot(pos,dir);\n\tfloat c = dot(pos,pos) - radius;\n\n\tfloat discr = b*b - 4.0*c;\n\tif (discr >= 0.0)\n\t{\n\t\tvec2 t = vec2(-b+discr, -b-discr) / 2.0;\n\t\tvec3 p = pos + min(t.x,t.y) * dir;\n\t\tfloorHitPoint = p;\n\t\thasHitSphere = (p.y > -0.7-yy);\n\t\tif (hasHitSphere)\n\t\t{\n\t\t\tcolor = getColor(normalize(p));\n\t\t\thasHitSphere = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloorHitPoint = p;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec4 getBackgroundColor(vec2 pix)\n{\n\tif (pix.y < 0.0)\n\t{\n\t\tpix.y = -pix.y;\n\t\tfloat v = 1.0 / pix.y;\n\t\tfloat u = pix.x * v;\n\t\tvec4 fractalColor = getFractalColor(vec2(u,v));\n\t\tvec3 aview = vec3(0.0, -1.0, 0.0);\n\t\tvec3 apos = vec3(u, 0.4, v);\n\t\tvec3 adir = normalize(aview - apos);\n\n\t\tvec4 reflectionColor = vec4(0.0);\n\t\tfor (int i=0; i<numBalls; i++)\n\t\t{\n\t\t\treflectionColor += getSphereColor(apos, adir, float(i) - mod(4.0*time, 1.0));\n\t\t\tif (hasHitSphere) break;\n\t\t}\n\n\t\treturn (fractalColor + 2.0 * reflectionColor) * (pix.y + 0.025);\n\t}\n\telse\n\t{\n\t\treturn vec4(0.3 - pix.y, 0.0, 1.0 * pix.y, 0.0) * 2.0;\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n\tresolution = iResolution.xy;\n    \n    float aspect = resolution.y / resolution.x;\n\n    float bouncing = 0.0;\n\t#ifdef BOUNCING\n        float t = mod(time, 32.0);\n        if (t >= bounceOutTimeStart && t < bounceOutTimeStart + bounceDuration) t = bounceOutTimeStart + bounceDuration - t;\n        float height = (2.0 - 0.5*t) * aspect;\n\n        if (height < 0.0) height = 0.0;\n        bouncing = -abs(cos(3.5*t) * 0.5 * height);\n\n        if (t >= bounceOutTimeStart + bounceDuration) bouncing = -1.0;\n\t#endif\n\n\tvec2 pix = (fragCoord.xy / resolution - vec2(0.5)) * vec2(1.0, aspect) + vec2(0.0, bouncing);\n\n    #ifdef AMIGA_RES\n    \tpix = floor(pix * amigaRes) / amigaRes;\n    #endif\n\n    vec4 col = vec4(0.0);\n    if (pix.y >= -0.5 * aspect)\n    {\n\t\tvec3 pos = vec3(pix,-1.0);\n\t\tvec3 dir = normalize(vec3(pix.x, pix.y, 1.0));\n\n        for (int i=0; i<numBalls; i++)\n        {\n            col += getSphereColor(pos, dir, float(i) - mod(4.0*time, 2.0));\n            if (hasHitSphere) break;\n        }\n        if (!hasHitSphere)\n        {\n            col = getBackgroundColor(pix);\n        }\n    }\n\n\tconst vec3 rgbBands = vec3(32.0, 24.0, 32.0);\n    #ifdef AMIGA_PAL\n    \tcol.rgb = floor(col.rgb * rgbBands) / rgbBands;\n    #endif\n\n\tfragColor = col;\n}\n","name":"","description":"","type":"image"}]}