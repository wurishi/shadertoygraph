{"ver":"0.1","info":{"id":"7stfDr","date":"1656367442","viewed":155,"name":"Dust in a Pointlight","username":"weasel","description":"This is a very simple shader for a pointlight with some dust around it. I wonder if there is a simpler way to create this type of effect efficiently (without for loops over all particles).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["scrollingtextures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotateZ(vec3 pos, float angle) {\n    return vec3(cmul(pos.xy, cexp(vec2(0.,-angle))), pos.z);\n}\n\nfloat ray_point_dist(vec3 point, vec3 rpos, vec3 rdir) {\n    vec3 rel_pos = point - rpos;\n    float d = dot(rel_pos, rdir);\n    if (d < 0.0)\n        return abs(d);\n    return length(cross(rel_pos, rdir));\n}\n\nfloat light_halo(float dist) {\n    const float radius = 1.2;\n    return radius * radius / ((dist + radius) * (dist + radius));\n}\n\nvec2 warp(vec2 pos, float strength) {\n    float t = 2.*iTime;\n    float sx = sin(pos.x + t);\n    float sy = sin(pos.y + t);\n    return pos + strength * vec2(sy, sx + iTime*5.);\n}\n\n// from https://www.shadertoy.com/view/fscSWH\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvec2 steps(vec2 x) {\n    return floor(x + 0.5*sin(x.yx));\n}\n\nfloat point_texture(vec2 pos) {\n    float rnd = hash(steps((pos + 1.2*vec2(pos.y, -pos.x)) * 17.0));\n    rnd *= hash(steps((pos - 2.41*pos.yx) * 13.0));\n    return max(0.0, (rnd - 0.8) * 10.0);\n}\n\n\nvec3 raytrace_plane(vec3 p, vec3 n, vec3 t, vec3 rpos, vec3 rdir) {\n    float d = dot(rdir, n);\n    float mul = dot(p - rpos, n) / d;\n    if (mul < 0.0)\n        return vec3(0.0);\n    vec3 hit = rpos + rdir * mul;\n    return vec3(dot(hit + p, t), dot(cross(n, t), hit + p), light_halo(length(hit)) * d * d);\n}\n\nfloat simple_env(vec3 dir) {\n    return point_texture(dir.xy) + point_texture(dir.xz) + point_texture(dir.yz);\n}\n\nvec4 see(vec3 rpos, vec3 rdir) {\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    // add a light in the fog\n    float light = ray_point_dist(vec3(0.0), rpos, rdir);\n    col.rgb = vec3(light_halo(light));\n    // Now add dust rising turbulent particles\n    // this is supposed to be efficient, so no drawing of every particle individually!\n    // instead use warped and layered scrolling textures\n    vec3 rtp1 = raytrace_plane(vec3(10.,0.,0.), vec3(0.,1.,0.), vec3(1.,0.,0.), rpos, rdir);\n    vec3 rtp2 = raytrace_plane(vec3(5.,-8.66,0.), vec3(0.866,0.5,0.), vec3(0.,-1.,0.), rpos, rdir);\n    vec3 rtp3 = raytrace_plane(vec3(0.,0.,0.), vec3(-0.866,0.5,0.), vec3(0.,1.,0.), rpos, rdir);\n    float pt1 = point_texture(warp(rtp1.xy, 0.1)) * rtp1.z;\n    float pt2 = point_texture(warp(rtp2.xy, 0.1)) * rtp2.z;\n    float pt3 = point_texture(warp(rtp3.xy, 0.1)) * rtp3.z;\n    col.rgb *= (pt1 + pt2 + pt3) * 1.0 + 1.0;\n    //col.rgb *= vec3(pt1, pt2, pt3) * 1.0 + 1.0;\n    \n    // add some background color\n    col.rgb += mix(vec3(.2, .2, .4), vec3(.18, .18, .4), simple_env(rdir * 10.0)) * (1.0 + rdir.z * 0.5);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n     // camera movement\n\tvec3 cam_pos = 6.0 * rotateZ(rotateX(vec3(0,1,0), (m.y - 0.5) * PI/2.1), m.x * PI);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 shaded_color = see(rpos, rdir);\n    shaded_color.rgb *= shaded_color.a;\n    shaded_color.rgb = pow(shaded_color.rgb, vec3(0.7));\n\n    fragColor = vec4(shaded_color);\n}","name":"Image","description":"","type":"image"}]}