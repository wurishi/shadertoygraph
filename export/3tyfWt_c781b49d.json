{"ver":"0.1","info":{"id":"3tyfWt","date":"1615250254","viewed":424,"name":"Iterative Function Guide","username":"Mrpalland","description":"This is a loose template/guide to explore iterative functions!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","tutorial","template","graph","function","iterative","lorenz","guide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Evan Nave 2021\n// Iterative Functions in GLSL: https://www.shadertoy.com/view/MtBGDW\n//\n// 'Mythic Bird' Graph: http://www.atomosyd.net/spip.php?article98\n// 'Tinkerbell map': https://en.wikipedia.org/wiki/Tinkerbell_map\n// 'Ikeda map': https://en.wikipedia.org/wiki/Ikeda_map\n// 'Bogdanov map': https://en.wikipedia.org/wiki/Bogdanov_map\n// 'Mandelbrot Set': https://en.wikipedia.org/wiki/Mandelbrot_set\n// 'Lorenz Strange Attractor': https://en.wikipedia.org/wiki/Lorenz_system\n// \n///////////////////////////\n// \n// This a compilation of examples of iterative functions.\n// The basic premise of iterative functions is that the current\n// value of x, y, or both, affect the next values.\n// \n// Some of these examples are attractors. Attractors are functions\n// or fields where values drift toward a point or set of points. This\n// can lead to pleasing or interesting visuals. Enjoy!\n// \n///////////////////////////\n// General Structure of an Iterative Function:\n// \n// ITERATIONS : Number of steps a function will take\n// BREAK : The value at which the length/distance of a function escapes\n// \n// float w : increments if function is within BREAK value\n// \n// Other Parameters: These examples come with a set of parameter values\n//                   that come with the curve. Please see the references\n//                   at the top if you are curious about what they do!\n// \n// funct(position, time){\n//     \n//     for(int i = 0; i < ITERATIONS; i++){\n//         x[n+1] = ...;\n//         y[n+1] = ...;\n//         if(length(xy) > BREAK)break;\n//         x[n] = x[n+1];\n//         y[n] = y[n+1];\n//     }\n//     return w/ITERATIONS;\n// }\n// \n\n#define SCALE 3.\n#define ITERATION 80\n#define PI 3.14159265359\n\n////////////////////////////////////\n// Mythic Bird Example (THE QUASI-CONSERVATIVE GUMOWSKI-MIRA MAP)\n// \n// g(x,u) = ux + (2(1 - u)x^2/(1 + x^2))\n// \n// x[n+1] = y[n] + g(x[n],u) + a(1 - by[n]^2)y[n]\n// y[n+1] = -x[n] + g(x, u)\n//\nfloat g(float x, float u){\n    return u*x + ((2.*(1. - u)*pow(x, 2.)) / (1. + pow(x, 2.)));\n}\n\nvec2 mythic(vec2 c,float t){\n\tvec4 z = vec4(c.x*1.6, -c.y, 0.0, 0.0);\n\tvec3 zi = vec3(0.0);\n    \n    float a = 0.0009;\n    float b = 0.005 - 0.5;\n    float u = -0.801;\n    \n    //Animation\n    u += cos(t*0.1 + 15.7)*0.25 + 0.25;\n    \n    float m = -3.5;\n    \n    float BREAK = 30.0;\n    \n\tfor(int i=0; i<ITERATION; i++){\n\t\tzi.x = z.y + g(z.x, u) + a*z.y*(1. - b*pow(z.y, 2.) + m);\n\t\tzi.y = -z.x + g(zi.x, u);\n        if(length(zi.xy) > BREAK)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n        z.z = float(i);\n\t}\n\tz.w/=float(ITERATION);\n\treturn 1.0-z.wx;\n}\n\n////////////////////////////////////\n// Bogdanov Map Example\n//\n// x[n+1] = x[n] + y[n+1]\n// y[n+1] = y[n] + ey[n] + kx[n](x[n] - 1) + ux[n]y[n]\n//\nvec2 bogdanov(vec2 c,float t){\n\tvec4 z = vec4(c.x, c.y, 0.0, 0.0);\n\tvec3 zi = vec3(0.0);\n    \n    float e = 0.02;\n    float k = 1.2;\n    float u = 0.0;\n    \n    //Animation\n    k +=  + cos(t);\n    \n    float BREAK = 1.0;\n    \n\tfor(int i=0; i<ITERATION; i++){\n\t\tzi.y = z.y + e*z.y + k*z.x*(z.x - 1.) + u*z.x*z.y;\n        zi.x = z.x + zi.y;\n        if(length(zi.xy) > BREAK)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n        z.z = float(i);\n\t}\n\tz.w/=float(ITERATION);\n\treturn 1.0-z.wx;\n}\n\n\n////////////////////////////////////\n// Tinker Bell Example\n//\n// x[n+1] = x[n]^2 - y[n]^2 + ax[n] + by[n]\n// y[n+1] = 2x[n]y[n] + cx[n] + dy[n]\n//\nvec2 tinker(vec2 p,float t){\n\tvec4 z = vec4(p.x, p.y, 0.0, 0.0);\n\tvec3 zi = vec3(0.0);\n    \n    float a = 0.1;\n    float b = -.6013;\n    float c = 2.0;\n    float d = 0.5;\n    \n    //Animation\n    b += cos(t) + 1.;\n    d += cos(t);\n    \n    float BREAK = 5.0;\n    \n\tfor(int i=0; i<ITERATION; i++){\n\t\tzi.x = pow(z.x, 2.0) - pow(z.y, 2.0) + a*z.x + b*z.y;\n\t\tzi.y = 2.*z.x*z.y + c*z.x + d*z.y;\n        if(length(zi.xy) > BREAK)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n        z.z = float(i);\n\t}\n\tz.w/=float(ITERATION)*0.5;\n\treturn 1.0-z.wx;\n}\n\n////////////////////////////////////\n// Ikeda Map Example\n//\n// t[n] = 0.4 - (6 / (1 + x[n]^2 + y[n]^2))\n//\n// x[n+1] = 1 + u(x[n]cos(t[n]) - y[n]sin(t[n]))\n// y[n+1] = u(x[n]sin(t[n]1) + y[n]cos(t[n]))\n//\nvec2 ikeda(vec2 c,float t){\n\tvec4 z = vec4(c.x, c.y, 0.0, 0.0);\n\tvec3 zi = vec3(0.0);\n    \n    float u = 0.918;\n    float tn = 0.0;\n    \n    //Animation\n    u +=  + cos(t)*0.25 + 0.45;\n    \n    float BREAK = 1.9;\n    \n\tfor(int i=0; i<ITERATION; i++){\n\t\ttn = 0.4 - (6. / (1. + pow(z.x, 2.0) + pow(z.y, 2.0)));\n        \n        zi.x = 1. + u*(z.x*cos(tn) - z.y*sin(tn));\n\t\tzi.y = u*(z.x*cos(tn) + z.y*sin(tn));\n        \n        if(length(zi.xy) > BREAK)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n        z.z = float(i);\n\t}\n\tz.w/=float(ITERATION);\n\treturn 1.0-z.wx*10.;\n}\n\n////////////////////////////////////\n// Mandelbrot Set Example (From: https://www.shadertoy.com/view/MtBGDW)\n//\n// x[n+1] = x[n]^2 - y[n]^2\n// y[n+1] = 2(x[n]y[n])\n//\nvec2 mandelbrot(vec2 c,float t){\n\tvec4 z = vec4(c, 0., 0.);\n\tvec3 zi = vec3(0.0);\n\tfor(int i=0; i<ITERATION; ++i){\n\t\tzi.x = (z.x*z.x-z.y*z.y);\n\t\tzi.y = 2.*(z.x*z.y);\n\t\tzi.xy += c;\n\t\tif(dot(z.xy,z.xy)>4.0)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n\t}\n\tz.w/=float(ITERATION);\n\treturn 1.0-z.wx;\n}\n\n////////////////////////////////////\n// Lorenz Strange Attractor (2D Projection)\n//\n// dx = s(y - x)\n// dy = x(r - z) - y\n// dz = xy - bz\n//\nfloat drawdot(vec2 uv, float r){\n    return smoothstep(0.0, 0.01, length(uv) - r);\n}\n\nfloat lorenz(vec2 c,float t){\n\tvec4 p = vec4(0.1, 0., 0., 0.);\n\tvec3 d = vec3(0.);\n    \n    float s = 10.;\n    float r = 28.;\n    float b = 8./3.;\n    \n    float dt = 0.02;\n    \n    //Animation\n    dt *= (cos(t*0.1)*0.0015 + 0.5);\n    \n\tfor(int i=0; i<ITERATION*10; i++){\n        d.x = (s * (p.y - p.x))*dt;\n        d.y = (p.x * (r - p.z) - p.y)*dt;\n        d.z = (p.x * p.y - b * p.z)*dt;\n        p.xyz += d;\n        p.w += drawdot(c + 0.02*p.xy, 0.004);\n    }\n\tp.w/=float(ITERATION*10);\n    \n    p.w = smoothstep(0.995, 1.0, p.w);\n    \n    return p.w;\n}\n\n////////////////////////////////////\n// MAIN IMAGE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= SCALE;\n\tvec3 col = vec3(0.);\n    \n    //Mythic Bird\n    float mb = max(mythic((uv + vec2(3.5, -1.5))*13.0,iTime).x, 0.);\n    \n    //Bodganov Map\n    mb *= max(bogdanov((uv + vec2(3.5, 1.2))*0.8,iTime).x, 0.);\n    \n    //Tinker Bell Attractor\n    mb *= max(tinker((uv + vec2(0.0, -1.6))*1.5,iTime).x, 0.);\n    \n    //Ikeda Attractor\n    mb *= ikeda((uv + vec2(0.0, 1.8))*3.0,iTime).x;\n    \n    //Mandelbrot Set\n    mb *= mandelbrot((uv + vec2(-3.9, -1.4))*0.9,iTime).x;\n    \n    //Lorenz Strange Attractor\n    mb *= max(lorenz((uv + vec2(-3.5, 1.3))*0.4,iTime), 0.);\n    \n    mb = 1.0 - mb;\n    col = vec3(mb);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}