{"ver":"0.1","info":{"id":"ddlXR4","date":"1668697248","viewed":50,"name":"SDF Triangulation Splits","username":"NicoEl","description":"Toggle select Vertices or Circles:\n - Vertices with Key 1,2,3\n - Circles with Key Q,W,E\n\nMove selected Vertices/Circles using Arrow Keys\nScale selected Circles up/down using X/Y Keys\n\nReset using Space\n","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["sdf","split"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float calcHighlightMixFactor(in SContext ctx, in vec2 p)\n{\n\tfloat mixFactor = 0.f;\n\n\tbool bToggleVertexA = readKey(iChannel3, kToggleVertexA, true) || iFrame == 0;\n\tbool bToggleVertexB = readKey(iChannel3, kToggleVertexB, true) || iFrame == 0;\n\tbool bToggleVertexC = readKey(iChannel3, kToggleVertexC, true) || iFrame == 0;\n\n\tbool bToggleCircleA = readKey(iChannel3, kToggleCircleA, true) || iFrame == 0;\n\tbool bToggleCircleB = readKey(iChannel3, kToggleCircleB, true) || iFrame == 0;\n\tbool bToggleCircleC = readKey(iChannel3, kToggleCircleC, true) || iFrame == 0;\n\n\tif (bToggleVertexA)\n\t{\n\t\tvec2 x = readVertex(iChannel0, ctx, gIdxVertexA);\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, length(p - x) - 0.03));\n\t}\n\tif (bToggleVertexB)\n\t{\n\t\tvec2 x = readVertex(iChannel0, ctx, gIdxVertexB);\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, length(p - x) - 0.03));\n\t}\n\tif (bToggleVertexC)\n\t{\n\t\tvec2 x = readVertex(iChannel0, ctx, gIdxVertexC);\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, length(p - x) - 0.03));\n\t}\n\tif (bToggleCircleA)\n\t{\n\t\tvec3 c = readCircle(iChannel0, ctx, gIdxCircleA);\n\t\tfloat d = sdCircle(p, c.xy, c.z);\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, length(p - c.xy) - 0.03));\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, abs(d) - 0.015));\n\t}\n\tif (bToggleCircleB)\n\t{\n\t\tvec3 c = readCircle(iChannel0, ctx, gIdxCircleB);\n\t\tfloat d = sdCircle(p, c.xy, c.z);\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, length(p - c.xy) - 0.03));\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, abs(d) - 0.015));\n\t}\n\tif (bToggleCircleC)\n\t{\n\t\tvec3 c = readCircle(iChannel0, ctx, gIdxCircleC);\n\t\tfloat d = sdCircle(p, c.xy, c.z);\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, length(p - c.xy) - 0.03));\n\t\tmixFactor = max(mixFactor, 1.0 - smoothstep(0.0, 0.005, abs(d) - 0.015));\n\t}\n\n\treturn mixFactor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tp *= 1.5;\n\n\tSContext ctx;\n\tctx.iResolution = iResolution;\n\n\tvec2 vertices[] = vec2[3](\n\t\treadVertex(iChannel0, ctx, gIdxVertexA),\n\t\treadVertex(iChannel0, ctx, gIdxVertexB),\n\t\treadVertex(iChannel0, ctx, gIdxVertexC));\n\n\tvec3 circles[] = vec3[3](\n\t\treadCircle(iChannel0, ctx, gIdxCircleA),\n\t\treadCircle(iChannel0, ctx, gIdxCircleB),\n\t\treadCircle(iChannel0, ctx, gIdxCircleC));\n\n\t// ----------------------------------------------------------\n\n\t// i := vertex index in triangle\n\t// n := offset for index to prev or next vertex\n\t// $_n := $ from prev or next vertex\n\n\tfloat we[] = float[12](-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.);\n\n#define gEdgeInactive 0\n#define gEdgeConnected 1\n\tint es[] = int[3](0, 0, 0);\n\tint ec[] = int[3](0, 0, 0);\n\tint va[] = int[3](0, 0, 0);\n\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tint si_n = i + 1;\n\t\tint i_n = smod(si_n, 3);\n\n\t\tint edgeId = ((i + i_n) - 1); // 0-1 = 0; 1-2 = 2; 2-0 = 1\n\t\tint wId = 4 * edgeId;\n\n\t\t// Iter both edge diretions\n\t\tfor (int s = 0; s < 2; ++s)\n\t\t{\n\t\t\tint i_a = s == 0 ? i : i_n;\n\t\t\tint i_b = s == 1 ? i : i_n;\n\n\t\t\tbool forwards = s == 0;\n\n\t\t\tvec2 v_a = vertices[i_a];\n\t\t\tvec3 c_a = circles[i_a];\n\t\t\tfloat d_a = sdCircle(v_a, c_a);\n\n\t\t\tvec2 v_b = vertices[i_b];\n\t\t\tvec3 c_b = circles[i_b];\n\t\t\tfloat d_b = sdCircle(v_b, c_b);\n\n\t\t\tif (d_a > 0. && d_b > 0.) { break; } // Inactive Edge\n\t\t\tif (d_a > 0. /* && d_b > 0.*/) { continue; } // Inactive Edge\n\n\t\t\tint wVertId = s * 3;\n\t\t\tif (d_a <= 0.)\n\t\t\t{\n\t\t\t\twe[wId + wVertId] = forwards ? 0. : 1.;\n\t\t\t}\n\n\t\t\tva[i_a] = 1;\n\n\t\t\tint wSpltId = s + 1;\n\n\t\t\tfloat w = -1.;\n\n\t\t\tif (!colCircle(c_a, c_b))\n\t\t\t{\n\t\t\t\tfloat d_vbca = -abs(sdCircle(v_b, c_a));\n\n\t\t\t\tw = clamp(d_a / (d_a + d_vbca), 0., 1.);\n\t\t\t\tw = forwards ? w : 1. - w;\n\t\t\t}\n\t\t\telse if (d_b > 0.) // already given d_a <= 0.\n\t\t\t{\n\t\t\t\tw = clamp(d_a / (d_a - d_b), 0., 1.);\n\t\t\t\tw = forwards ? w : 1. - w;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tec[edgeId] = 1;\n\t\t\t}\n\t\t\twe[wId + wSpltId] = w;\n\t\t}\n\n\t}\n\n\tint numConnectedEdges = 0;\n\tfor (int i = 0; i < 3; ++i) { numConnectedEdges += ec[i] == 1 ? 1 : 0; }\n\tint vFaces[3] = int[3](0, 1, 2);\n\n\tif (numConnectedEdges >= 2)\n\t{\n\t\tvFaces = int[3](1, 1, 1);\n\t\t// Single triangle or cannot split a single edge\n\t}\n\telse\n\t{\n\t\tvFaces = int[3](0, 1, 2);\n\t\tfor (int iIdx = 0; iIdx < 3; ++iIdx)\n\t\t{\n\t\t    int kIdx = (iIdx + 1) % 3; // next vertex\n\t\t    int edgeId = ((iIdx + kIdx) - 1); // 0-1 = 0; 1-2 = 2; 2-0 = 1\n\n            if (va[iIdx] == 0)\n            {\n                vFaces[iIdx] = -1;\n                continue;\n            }\n\n            if (ec[edgeId] == 1)\n            {\n                vFaces[kIdx] = vFaces[iIdx];\n            }\n            \n            vFaces[kIdx] = (ec[edgeId] == 1) ? iIdx : kIdx;\n\t\t}\n\t}\n\n\t// ----------------------------------------------------------\n\t//\n\n\tint numFaceGroupVertices[] = int[3](0, 0, 0);\n\tvec2 splitVertices[] = vec2[12](vec2(0), vec2(1), vec2(2), vec2(3), vec2(0), vec2(1), vec2(2), vec2(3), vec2(0), vec2(1), vec2(2), vec2(3));\n\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tvec2 vi = vertices[i];\n\t\tint i_n = smod(i + 1, 3);\n\t\tvec2 vi_n = vertices[i_n];\n\t\t\n\t\tint edgeId = ((i + i_n) - 1);\n\t\tint wId = 4 * edgeId;\n\t\t\n\t\t{ // s = 0\n\t\t    int ei0 = i;\n\t\t\tint ei = wId + 0;\n\t\t\t\n\t\t\tif (we[ei] >= 0.)\n\t\t\t{\n\t\t\t    int faceId = vFaces[ei0];\n\t\t\t\tint faceVertIdx = numFaceGroupVertices[faceId]++;\n\t\t\t\tsplitVertices[faceId * 4 + faceVertIdx] = vi;\n\t\t\t}\n\t\t}\n\n\t\tfor (int s = 1; s < 3; s++)\n\t\t{\n\t\t\tbool forwards = s == 1;\n\t\t\tint ei0 = forwards ? i : i_n;\n\t\t\tint ei = wId + s;\n\t\t\tif (we[ei] >= 0.)\n\t\t\t{\n\t\t\t\tint faceId = vFaces[ei0];\n\t\t\t\tint faceVertIdx = numFaceGroupVertices[faceId]++;\n\t\t\t\tsplitVertices[faceId * 4 + faceVertIdx] = mix(vi, vi_n, we[ei]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat dSplits = 99999999999.f; //@@TODO_Nico:\n\tfor (int fid = 0; fid < 3; ++fid)\n\t{\n\t\tint vb = fid * 4;\n\t\tif (numFaceGroupVertices[fid] < 3) { continue; }\n\t\tif (numFaceGroupVertices[fid] >= 3)\n\t\t{\n\t\t\tdSplits = min(dSplits, sdTriangle(p, splitVertices[vb + 0], splitVertices[vb + 1], splitVertices[vb + 2]));\n\t\t}\n\t\tif (numFaceGroupVertices[fid] >= 4)\n\t\t{\n\t\t\tdSplits = min(dSplits, sdTriangle(p, splitVertices[vb + 0], splitVertices[vb + 2], splitVertices[vb + 3]));\n\t\t}\n\t}\n\n\t// ----------------------------------------------------------\n\t//float d = sdTriangle(p, vertices[0], vertices[1], vertices[2]);\n\tfloat d = dSplits;\n\n\t// color\n\tvec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-2.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n\n\t// ----------------------------------------------------------\n\t// Debug Draw weight based vertices\n\n#if 0\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tvec2 vi = vertices[i];\n\t\tint i_n = smod(i + 1, 3);\n\t\tvec2 vi_n = vertices[i_n];\n\t\t\n\t\tint edgeId = ((i + i_n) - 1);\n\t\tint edgeIdx = 4 * ((i + i_n) - 1);\n\n\t\tfor (int s = 0; s < 4; s++)\n\t\t{\n\t\t\tint edgeVertId0 = edgeIdx + s;\n\t\t\t\n\t\t\tint vFacesIdx;\n\t\t\n\t\t\tint ei0 = s < 2 ? i : i_n;\n\t\t\tint faceId = vFaces[ei0];\n\n\t\t\tif (we[edgeVertId0] >= 0.)\n\t\t\t{\n\t\t\t\tvec2 vlerp = mix(vi, vi_n, we[edgeVertId0]);\n\t\t\t\tfloat w = 1.0 - smoothstep(0.0, 0.005, length(p - vlerp) - 0.045 * float(3-i));\n\t\t\t\tcol = mix(col, gColor[vFaces[faceId]], w);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tcol = mix(col, vec3(1., 1., 0.), calcHighlightMixFactor(ctx, p));\n\t\n#if 1\n\tfor (int wi = 0; wi < 12; ++wi)\n\t{\n\t\tvec2 pos = vec2(20., iResolution.y - 20.) - vec2(0, 20) * float(wi);\n\t\tcol = mix(col, vec3(1.), PrintValue(fragCoord, pos - vec2(10, 0), vec2(8.0, 15.0), float(wi), 1., 0.));\n\t\tcol = mix(col, vec3(0.), PrintValue(fragCoord, pos, vec2(8.0, 15.0), we[wi], 2., 3.));\n\t}\n\t\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tvec2 pos = vec2(100., iResolution.y - 20.) - vec2(0, 20) * float(i);\n\t\tcol = mix(col, vec3(1.), PrintValue(fragCoord, pos - vec2(10, 0), vec2(8.0, 15.0), float(i), 1., 0.));\n\t\tcol = mix(col, vec3(0.), PrintValue(fragCoord, pos, vec2(8.0, 15.0), float(ec[i]), 1., 0.));\n\t}\n\t\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tvec2 pos = vec2(200., iResolution.y - 20.) - vec2(0, 20) * float(i);\n\t\tcol = mix(col, vec3(1.), PrintValue(fragCoord, pos - vec2(10, 0), vec2(8.0, 15.0), float(i), 1., 0.));\n\t\tcol = mix(col, vec3(0.), PrintValue(fragCoord, pos, vec2(8.0, 15.0), float(numFaceGroupVertices[i]), 1., 0.));\n\t}\n#endif\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ----------------------------------------------------------\n// DEV CONTROLS\n// ----------------------------------------------------------\n#define ENABLE_FORCEINJECTION 1\n#define ENABLE_FEEDBACK 1\n#define ENABLE_FEEDBACK_COMPOSITION 0\n#define DEBUGDRAW_FFT1 0\n#define DEBUGDRAW_FFTKEYS DEBUGDRAW_FFT1\n#define DEBUGDRAW_FFT2 0\n#define DEBUGDRAW_FFTMEAN 0\n#define DEBUGDRAW_CTRL_IDX 0\n#define DEBUGDRAW_UVCOORDS 1\n#define DEBUGDRAW_OUTPUT_VELOCITY 0\n#define DEBUGDRAW_OUTPUT_FORCE_INJECTION 0\n\n// ----------------------------------------------------------\n// Constants\n// ----------------------------------------------------------\n#define PI 3.141\n\n// ----------------------------------------------------------\n// Common Functions\n// ----------------------------------------------------------\nstruct SContext\n{\n\tvec3 iResolution;\n};\n\nint toLinearIndex(in SContext ctx, ivec2 id)\n{\n\treturn int(ctx.iResolution.x) * id.y + id.x;\n}\n\n\nivec2 fromLinearIndex(in SContext ctx, int i)\n{\n\treturn ivec2(i % int(ctx.iResolution.x), i / int(ctx.iResolution.x));\n}\n\n// ----------------------------------------------------------\n// 2D SDF by Inigo Quilez\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat sdCircle(vec2 p, vec3 c)\n{\n    return sdCircle(p, c.xy, c.z);\n}\n\nbool colCircle(vec3 c0, vec3 c1)\n{\n\treturn length(c0.xy - c1.xy) < (c0.z + c1.z);\n}\n\n\n// ----------------------------------------------------------\nfloat DigitBin(const in int x)\n{\n\treturn x == 0 ? 480599.0 : x == 1 ? 139810.0\n\t\t: x == 2\t\t\t\t\t  ? 476951.0\n\t\t: x == 3\t\t\t\t\t  ? 476999.0\n\t\t: x == 4\t\t\t\t\t  ? 350020.0\n\t\t: x == 5\t\t\t\t\t  ? 464711.0\n\t\t: x == 6\t\t\t\t\t  ? 464727.0\n\t\t: x == 7\t\t\t\t\t  ? 476228.0\n\t\t: x == 8\t\t\t\t\t  ? 481111.0\n\t\t: x == 9\t\t\t\t\t  ? 481095.0\n\t\t\t\t\t\t\t\t\t  : 0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tvec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n\tif ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif (fDigitIndex > (-fDecimalPlaces - 1.01))\n\t{\n\t\tif (fDigitIndex > fBiggestIndex)\n\t\t{\n\t\t\tif ((fValue < 0.0) && (fDigitIndex < (fBiggestIndex + 1.5))) fCharBin = 1792.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif (fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n\t\t\t\tfloat kFix = 0.0001;\n\t\t\t\tfCharBin = DigitBin(int(floor(mod(kFix + fDigitValue, 10.0))));\n\t\t\t}\n\t\t}\n\t}\n\treturn floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ----------------------------------------------------------\n// Mouse & Keyboard\n// ----------------------------------------------------------\nconst int kA = 65, kB = 66, kC = 67, kD = 68, kE = 69, kF = 70, kG = 71, kH = 72, kI = 73, kJ = 74, kK = 75, kL = 76, kM = 77, kN = 78, kO = 79, kP = 80, kQ = 81, kR = 82, kS = 83, kT = 84, kU = 85, kV = 86, kW = 87, kX = 88, kY = 89, kZ = 90;\nconst int k0 = 48, k1 = 49, k2 = 50, k3 = 51, k4 = 52, k5 = 53, k6 = 54, k7 = 55, k8 = 56, k9 = 57;\nconst int kSpace = 32, kLeft = 37, kUp = 38, kRight = 39, kDown = 40;\n\nbool readKey(sampler2D textureChannel, int key, bool toggle)\n{\n\tfloat keyVal = texture(textureChannel, vec2((float(key) + .5) / 256.0, toggle ? .75 : .25)).x;\n\treturn (keyVal > .5) ? true : false;\n}\n\nconst int kToggleVertexA = k1;\nconst int kToggleVertexB = k2;\nconst int kToggleVertexC = k3;\n\nconst int kToggleCircleA = kQ;\nconst int kToggleCircleB = kW;\nconst int kToggleCircleC = kE;\n\nconst int kElementReset = kSpace;\nconst int kElementMoveLeft = kLeft;\nconst int kElementMoveUp = kUp;\nconst int kElementMoveRight = kRight;\nconst int kElementMoveDown = kDown;\nconst int kElementDecrease = kY;\nconst int kElementIncrease = kX;\n\n// ----------------------------------------------------------\n\nconst int gIdxVertexA = 0; \nconst int gIdxVertexB = 1; \nconst int gIdxVertexC = 2; \nconst int gIdxCircleA = 3; \nconst int gIdxCircleB = 4; \nconst int gIdxCircleC = 5;\n\nvec3 gColor[] = vec3[3](\n\tvec3(1., 0., 0.),\n\tvec3(0., 1., 0.),\n\tvec3(0., 0., 1.));\n\t\nvec3 gColorB[] = vec3[3](\n\tvec3(1., 1., 0.),\n\tvec3(0., 1., 1.),\n\tvec3(1., 0., 1.));\n\nvec2 readVertex(sampler2D textureChannel, in SContext ctx, int idx)\n{\n\treturn texelFetch(textureChannel, fromLinearIndex(ctx, idx), 0).xy;\n}\n\nvec3 readCircle(sampler2D textureChannel, in SContext ctx, int idx)\n{\n\tvec3 fetch = texelFetch(textureChannel, fromLinearIndex(ctx, idx), 0).xyz;\n\treturn vec3(fetch.xy, abs(fetch.z));\n}\n\nint smod(int x, int m) { int r = x%m; return r < 0 ? r+m : r; } ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 UpdateSpeed = vec3(-0.015, 0.015, 0.);\n\nvoid updateElement(inout vec3 p, in vec3 reset)\n{\n\n\tbool bTriggerElementReset = readKey(iChannel3, kElementReset, false) || iFrame == 0;\n\t\n\tbool bTriggerElementMoveLeft = readKey(iChannel3, kElementMoveLeft, false);\n\tbool bTriggerElementMoveUp = readKey(iChannel3, kElementMoveUp, false);\n\tbool bTriggerElementMoveRight = readKey(iChannel3, kElementMoveRight, false);\n\tbool bTriggerElementMoveDown = readKey(iChannel3, kElementMoveDown, false);\n\t\n\tbool bTriggerElementIncrease = readKey(iChannel3, kElementDecrease, false);\n\tbool bTriggerElementDecrease = readKey(iChannel3, kElementIncrease, false);\n\t\n\tvec2 x = bTriggerElementReset ? reset.xy : p.xy;\n\tfloat r = bTriggerElementReset ? reset.z : p.z;\n\t\n\tif (bTriggerElementMoveLeft) { x += UpdateSpeed.xz; }\n\tif (bTriggerElementMoveUp) { x += UpdateSpeed.zy; }\n\tif (bTriggerElementMoveRight) { x += UpdateSpeed.yz; }\n\tif (bTriggerElementMoveDown) { x += UpdateSpeed.zx; }\n\tif (bTriggerElementIncrease) { r += UpdateSpeed.y; }\n\tif (bTriggerElementDecrease) { r += UpdateSpeed.x; }\n    \n    p = vec3(x, r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tSContext ctx;\n\tctx.iResolution = iResolution;\n\tint linearIndex = toLinearIndex(ctx, ivec2(fragCoord));\n\t\n\tbool bToggleVertexA = readKey(iChannel3, kToggleVertexA, true) || iFrame == 0;\n\tbool bToggleVertexB = readKey(iChannel3, kToggleVertexB, true) || iFrame == 0;\n\tbool bToggleVertexC = readKey(iChannel3, kToggleVertexC, true) || iFrame == 0;\n\t\n\tbool bToggleCircleA = readKey(iChannel3, kToggleCircleA, true) || iFrame == 0;\n\tbool bToggleCircleB = readKey(iChannel3, kToggleCircleB, true) || iFrame == 0;\n\tbool bToggleCircleC = readKey(iChannel3, kToggleCircleC, true) || iFrame == 0;\n\t\n\tvec3 col = texelFetch(iChannel0, fromLinearIndex(ctx, linearIndex), 0).xyz;\n\t\n\tif (linearIndex == gIdxVertexA && bToggleVertexA)\n\t{\n\t\tupdateElement(col, vec3(-0.5, 0., 0.));\n\t}\n\telse if (linearIndex == gIdxVertexB && bToggleVertexB)\n\t{\n\t\tupdateElement(col, vec3(0.5, 0.5, 0.));\n\t}\n\telse if (linearIndex == gIdxVertexC && bToggleVertexC)\n\t{\n\t\tupdateElement(col, vec3(0.5, -0.5, 0.));\n\t}\n\telse if (linearIndex == gIdxCircleA && bToggleCircleA)\n\t{\n\t\tupdateElement(col, vec3(-1., 0., 1.0));\n\t}\n\telse if (linearIndex == gIdxCircleB && bToggleCircleB)\n\t{\n\t\tupdateElement(col, vec3(1., 1., 1.0));\n\t}\n\telse if (linearIndex == gIdxCircleC && bToggleCircleC)\n\t{\n\t\tupdateElement(col, vec3(1., -1., 1.0));\n\t}\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}