{"ver":"0.1","info":{"id":"Xl3Szr","date":"1477609525","viewed":794,"name":"Triangulation","username":"gigatron","description":"Trianglulation attempt .. goal broken glass using triangulation ... for now it's not ok  ! \nAll from alien IQ ;\nso i have glasses triangles now ; deformation is now much realistic..\nbtw when it's done i will 99 year old ! be patient !","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// triangulation .. attempt to simulate broken glass! \n\n#define t iTime\n\nfloat fx=fract(1.+0.5);  // broke factor !\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Vertex\n{\n    vec3  pos; \n\tvec2  uv; \n\tfloat occ;\n};\n\n\t\nstruct Triangle\n{\n    Vertex a;\n    Vertex b;\n    Vertex c;\n    vec3 n;\n};\n\n\nvec4 func( in vec2 s )\n{\n\t \n  \n  \t\n    float r = 1.0 + fx*cos(16.0*s.x + 6.28318*s.y + fx );\n    \n    return vec4( r*vec3(s.y,s.x,0.0 ), 1.0 );\n     \n    // broken now !!\n}\n\n\nTriangle calcTriangle( float u, float v, float du, float dv, int k )\n{\n\t\n    \n    vec2 aUV = vec2( u,    v    );\n\tvec2 bUV = vec2( u+du, v+dv );\n\tvec2 cUV = vec2( u+du, v    );\n\tvec2 dUV = vec2( u,    v+dv );\n\t\n\tif( k==1 )\n\t{\n\t\tcUV = bUV; \n\t\tbUV = dUV;\n\t}\n\n    \n    \n\tvec4 a = func( aUV );\n\tvec4 b = func( bUV );\n\tvec4 c = func( cUV );\n\tvec3 n = normalize( -cross(c.xyz-a.xyz, b.xyz-a.xyz));\n\t\n\treturn Triangle( Vertex(a.xyz, 1.0*aUV, a.w), \n\t\t\t\t\t Vertex(b.xyz, 1.0*bUV, b.w), \n\t\t\t\t\t Vertex(c.xyz, 1.0*cUV, c.w), n);\n}\n\nvec3 lig = normalize( vec3( 0.0,0.0,0.0) );\n\nvec3 pixelShader( in vec3 nor, in float oc, in vec2 uv, vec3 di )\n{\n \n   float wire = 1.0 - smoothstep( 0.0, 0.02, di.x ) *\n                       smoothstep( 0.0, 0.02, di.y ) *\n                       smoothstep( 0.0, 0.02, di.z );\n\t\n    vec3 material = texture( iChannel0, uv ).xyz;\n\t\n     material += 2.*wire * vec3(0.2,0.2,0.2);\n      \n\n    return   material ;\n}\n\nfloat crosss( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tmat4 mdv = setTranslation( 0.0, 1.0, -2.0 ) * \n\t\t       setRotation( 0.0, 0., -1.57 )  ;\n\t\n    vec2 px = fragCoord / iResolution.xy;\n    \n    px.y =1.-px.y;\n    \n  //  px.x *= iResolution.x/iResolution.y;\n\t// vertex points ; \ta ,b,c\n\tfloat aa = fx/10.;\n    float bb = 0.00;\n    float cc = 0.00;\n    \n    vec3 color = vec3( 0.0 );\n\n\t// clear zbuffer\n    float mindist = -1000000.0;\n\n\t// for every triangle\n\tfloat du = 1.0/8.0;\n\tfloat dv = 1.0/8.0;\n    for( int k=0; k< 2; k++ )\n    for( int j=0; j<8; j++ )\n    for( int i=0; i<8; i++ )\n\t//for( int i=0; i<100; i++ )\n    {\n\t\t// get the triangle\n\t\tfloat pu = float(i)*du;\n\t\tfloat pv = float(j)*dv;\n\t\n        \n\t\t\n\t\tTriangle tri = calcTriangle( pu, pv, du, dv, k );\n\n\t\t// transform to eye space\n        vec3 ep0 = (mdv * vec4(tri.a.pos-aa,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(tri.b.pos+bb,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(tri.c.pos-cc,1.0)).xyz;\n        vec3 nor = (mdv * vec4(tri.n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n\t\t{\n\t\t\n        // fetch vertex attributes, and divide by z\n        vec2  u0 = tri.a.uv  * w0;\n        vec2  u1 = tri.b.uv  * w1;\n        vec2  u2 = tri.c.uv  * w2;\n        float a0 = tri.a.occ * w0;\n        float a1 = tri.b.occ * w1;\n        float a2 = tri.c.occ * w2;\n\n        \n        // calculate areas for subtriangles\n        vec3 di = vec3( crosss( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    crosss( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    crosss( cp0 - cp2, px - cp2 ));\n\t\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(0.0,0.0,0.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n           \n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n            float oc = ba.x*a0 + ba.y*a1 + ba.z*a2;\n\n            // recover interpolated attributes (this could be done after 1/depth test)\n\t\t\tfloat z = 1.0/iz;\n            uv *= z;\n\t\t\toc *= z;\n\n\t\t\t// depth buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n\n                // run pixel shader\n                color = pixelShader( nor, oc, uv, ba );\n\t\t\t}\n        }\n\t\t}\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}