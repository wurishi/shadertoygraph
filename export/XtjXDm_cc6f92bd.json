{"ver":"0.1","info":{"id":"XtjXDm","date":"1444478895","viewed":403,"name":"LightBox","username":"dila","description":"After watching some shaders by Shane, I noticed that I lacked bump mapping, so I tried to implement it here. Also uses iq's soft shadows and I raymarch an additive blended box with low step-size for \"bloom\".","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"mat2 rot(float t)\n{\n \treturn mat2(cos(t), sin(t), -sin(t), cos(t));   \n}\n\nfloat sdBoxXY(vec3 p, vec3 b)\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nbool alpha = true;\n\nvec2 lightbox(vec3 p)\n{\n    float anim = (0.5 + 0.5 * sin(iTime * 0.25)) * 5.0;\n    float d = sdBox(p - vec3(0.0, 0.0, 5.0), vec3(1.0 + anim, 1.0, 2.0));\n    return vec2(d, anim);\n}\n\nfloat heightmap(vec3 p)\n{\n    float h = 0.05;\n    float gt = iTime * 1.0;\n    float wave = sin(p.x + p.z + gt) * h;\n    wave += sin(p.z * 2.0 - gt * 2.0) * h * 0.5;\n    wave += sin(p.x * 4.0 + gt * 3.0) * h * 0.25;\n    float w = p.y + 1.5 + wave;\n    return w;\n}\n\nvec2 map(vec3 p)\n{\n    float mat = 0.0;\n\tfloat d = - sdBox(p - vec3(0.0, 0.4, 0.0), vec3(5.0, 2.0, 5.0));\n    \n    float window = lightbox(p).x;\n    d = max(d, -window);\n    \n    float cut = -p.z + 10.0;\n    d = max(d, -cut);\n    \n    if (alpha) {\n\t\tfloat w = heightmap(p);\n        if (w < d)\n        {\n            d = w;\n            mat = 1.0;\n        }\n    }\n    \n\treturn vec2(d, mat);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d;\n        if (abs(d) < 0.01) {\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nvec2 tracelight(vec3 o, vec3 r, float ld)\n{\n\tfloat t = 0.0;\n    float ss = 1000.0;\n    for (int i = 0; i < 128; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        float md = min(d, 0.1);\n        t += md * (1.0-t/ld);\n        ss = min(ss, md/t);\n        if (abs(d) < 0.001) {\n            break;\n        }\n    }\n    return vec2(t, ss);\n}\n\nfloat gray(sampler2D channel, vec2 p)\n{\n\tvec3 s = texture(channel, p).xyz;\n    return (s.x*s.x + s.y*s.y + s.z*s.z) / 3.0;\n}\n\nvec3 bump(sampler2D channel, vec2 p, float k)\n{\n    float d = 0.01;\n    float sx = gray(channel, p + vec2(d,0.0)) - gray(channel, p + vec2(-d,0.0));\n    float sy = gray(channel, p + vec2(0.0,d)) - gray(channel, p + vec2(0.0,-d));\n    return normalize(vec3(sx, sy, k));\n}\n\nmat3 basis(vec3 v)\n{\n\tmat3 r;\n    r[2] = v;\n    r[1] = vec3(0.0, 1.0, 0.0);\n    r[0] = cross(r[2], r[1]);\n    if (dot(r[0],r[0]) < 0.5) {\n        r[1] = vec3(1.0, 0.0, 0.0);\n        r[0] = cross(r[2], r[1]);\n    }\n    r[1] = normalize(cross(r[0], r[2]));\n    r[0] = normalize(r[0]);\n    return r;\n}\n\nvec3 dolight(vec3 o, vec3 r, vec3 w, vec3 sn, vec3 lp)\n{\n    vec3 lv = w - lp;\n    float ld = length(lv);\n    lv /= ld;\n    vec2 lt = tracelight(lp + sn * 0.01, lv, ld);\n    float lm = 1.0;\n    if (lt.x < ld) {\n        lm = lt.y;\n    }\n    float atn = 1.0 / (1.0 + ld * ld * 0.01);\n    float lam = max(dot(sn, -lv), 0.0);\n    vec3 sc = atn * lam * lm * vec3(1.0, 1.0, 1.0);\n    return sc * 50.0 + 0.1;\n}\n\nfloat flare(vec3 o, vec3 r, vec3 f)\n{\n \tfloat t = 0.0;\n    vec2 d = vec2(0.0);\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        d = lightbox(p);\n        t += d.x * 0.1;\n    }\n    return 1.0 / (1.0 + t * t * 0.1);\n}\n\nvec3 lightpos()\n{\n\treturn vec3(0.0, 0.0, 6.0);\n}\n\nvec3 shade(vec3 o, vec3 r, vec3 w, inout vec3 sn, vec2 fd, float t)\n{  \n    mat3 texb = basis(sn);\n    vec2 tuv = vec3(w * texb).xy * 0.125;\n    vec3 tex = texture(iChannel0, tuv).xxx;\n    tex *= tex;\n    sn = texb * bump(iChannel0, tuv, 2.5);\n\n    vec3 sunpos = lightpos();\n    vec3 light = dolight(o, r, w, sn, sunpos);\n    \n    return tex * light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.0));\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    \n    if (iMouse.w < 1.0) {\n    \t//r.xz *= rot(iTime);\n    } else {\n        vec2 ms = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        r.yz *= rot(ms.y * 3.14 * 0.25);\n        r.xz *= rot(ms.x * 3.14);\n    }\n        \n    alpha = true;\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 fd = map(w);\n    vec3 sn = normal(w);\n    \n    vec3 fc;\n    alpha = false;\n    if (fd.y == 1.0) {       \n        mat3 texb = basis(sn);\n        vec2 tuv = vec3(w * texb).xy * 0.25;\n        sn = texb * bump(iChannel1, tuv, 2.5);\n        \n        vec3 rfrr = refract(r, sn, 0.5);\n        float rfrt = trace(w, rfrr);\n        vec3 rfrw = w + rfrr * rfrt;\n        vec2 rfrfd = map(rfrw);\n        vec3 rfrsn = normal(rfrw);\n       \tvec3 rfrc = shade(w, rfrr, rfrw, rfrsn, rfrfd, rfrt);\n        rfrc *= vec3(1.0, 1.0, 0.7);// / (1.0 + rfrt * rfrt * 0.01);\n        \n        vec3 rflr = reflect(r, -sn);\n        float rflt = trace(w, rflr);\n        vec3 rflw = w + rflr * rflt;\n        vec2 rflfd = map(rflw);\n        vec3 rflsn = normal(rflw);\n        vec3 rflc = shade(w, rflr, rflw, rflsn, rflfd, rflt);\n\n       \tvec3 sunpos = lightpos();\n    \tvec3 light = dolight(o, r, w, sn, sunpos);\n        \n        float fres = max(dot(r, -sn), 0.0);\n        fc = mix(rflc, rfrc * light, fres);\n    } else {\n\t\tvec3 rfrc = shade(o, r, w, sn, fd, t);\n        \n        vec3 rflr = reflect(r, -sn);\n        float rflt = trace(w + rflr * 0.1, rflr);\n        vec3 rflw = w + rflr * rflt;\n        vec2 rflfd = map(rflw);\n        vec3 rflsn = normal(rflw);\n        vec3 rflc = shade(w, rflr, rflw, rflsn, rflfd, rflt);\n        \n\t\tfloat fres = max(dot(r, -sn), 0.0);\n        fc = mix(rflc, rfrc, fres);\n    }\n    \n    fc += flare(o, r, lightpos());\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}