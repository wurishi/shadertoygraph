{"ver":"0.1","info":{"id":"4XsfDr","date":"1728291377","viewed":82,"name":"Far Pointer","username":"nr4","description":"This is a Shadertoy port of the 4k executable graphics I released together with Darya at Deadline 2024, which won a 2nd place.\n\nhttps://www.pouet.net/prod.php?which=98107","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["procedural","waves","sunset","4k","demoscene","gfx","team210","executable","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Far Pointer\n * Copyright (C) 2024 Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Far Pointer\n * Copyright (C) 2024 Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nconst int sliceCount = 400;\n\nconst float pi = 3.14159;\nconst float fsaa = 256.;\nconst float PHI = 1.618;\nconst float gold = 2.4;\nconst vec3 c = vec3(1,0,-1);\nconst bvec2 cb = bvec2(true, false);\n\nconst int SPHERE_TRACER_STEP_COUNT = 1450;\nconst float SPHERE_TRACER_PRECISION = 1.e-4;\nconst float PATH_TRACER_NORMAL_PRECISION = 5.e-5;\nconst int PATH_TRACER_REFLECTION_COUNT = 5;\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// vec2->float hash function\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Rotation in R3\nmat3 rot3(in vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// vec3->vec3 hash function\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\n// Low-Frequency noise (value-type)\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    float n = mix(v1.x, v1.y, t.x);\n    float p = pi;\n    n = sin(p * asin(n));\n    return n;\n}\n\n// Multi-frequency fractal noise stack\nfloat mfnoise(vec2 x, float d, float b, float e)\n{\n    float n = 0.;\n    float a = 1., nf = 0., buf;\n    for(float f = d; f<b; f *= 2.)\n    {\n        n += a*lfnoise(f*x);\n        a *= e;\n        nf += 1.;\n    }\n    return n * (1.-e)/(1.-pow(e, nf));\n}\n\n// 3D Cheap Simplex\n// taken from Shane's shader \"Smooth Noise Contours\" -\n// https://www.shadertoy.com/view/ldscWH\n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat simplex3D(in vec3 p) {\n    vec3 i = floor(p + dot(p, vec3(1./3.)) );\n    p -= i - dot(i, vec3(1./6.));\n    vec3 i1 = step(p.yzx, p),\n        i2 = max(i1, 1. - i1.zxy);\n    i1 = min(i1, 1. - i1.zxy);    \n    vec3 p1 = p - i1 + 1./6.,\n        p2 = p - i2 + 1./3.,\n        p3 = p - .5;\n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    return -1. + 2.* clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.);\n}\n\n/* FBM stack */\nfloat fbm(vec3 x) {\n    float pscale = 1.1,\n        nscale = .53,\n        drift = .75;\n    float result = 0.;\n    float nsc = .8;\n    float dr = 0.;\n    for(int i=0; i<32; ++i) {\n        result += nsc * simplex3D(x);\n        x*= pscale + float(i) * dr;\n        nsc *= nscale;\n        dr += drift;\n        x = vec3(\n\t\t\t-1.6 * x.y - 1.2 * x.z,\n\t\t\t1.6 * x.x + .8 * x.y - x.z,\n\t\t\t1.2 * x.x - x.y + 1.2 * x.z\n\t\t);\n    }\n    return result;\n}\n\nvec3 cmap_UnweightedOklab_example0(float t) {\n    return vec3(0.15,0.19,0.25)\n        +t*(vec3(0.07,-0.67,-0.94)\n        +t*(vec3(6.45,8.05,10.15)\n        +t*(vec3(-33.05,-33.67,-39.94)\n        +t*(vec3(69.54,63.73,68.86)\n        +t*(vec3(-64.67,-51.94,-49.67)\n        +t*(vec3(21.64,14.44,11.47)\n    ))))));\n}\n\nvec3 cmap_UnweightedOklab_example1(float t) {\n    return vec3(0.25,0.26,0.36)\n        +t*(vec3(1.24,-0.24,-0.98)\n        +t*(vec3(3.64,2.29,9.63)\n        +t*(vec3(-17.29,-3.18,-37.13)\n        +t*(vec3(26.91,1.45,63.84)\n        +t*(vec3(-19.83,3.78,-44.59)\n        +t*(vec3(5.32,-4.17,9.13)\n    ))))));\n}\n\nvec3 cmap_UnweightedOklab_example2(float t) {\n    return vec3(0.29,0.27,0.36)\n        +t*(vec3(1.63,-0.13,-0.78)\n        +t*(vec3(6.47,1.18,9.36)\n        +t*(vec3(-35.84,3.88,-43.36)\n        +t*(vec3(66.21,-11.55,86.26)\n        +t*(vec3(-54.72,13.04,-70.90)\n        +t*(vec3(16.22,-6.48,19.35)\n    ))))));\n}\n\nvec3 cmap_OklabOklab_sea_l(float t) {\n    return vec3(0.21,0.24,0.34)\n        +t*(vec3(0.89,0.29,-0.02)\n        +t*(vec3(-9.01,-0.56,3.63)\n        +t*(vec3(39.94,6.56,-13.74)\n        +t*(vec3(-73.36,-20.57,18.00)\n        +t*(vec3(58.79,22.80,-8.88)\n        +t*(vec3(-17.24,-8.52,0.99)\n    ))))));\n}\n\nvec3 cmap_OklabOklab_sea_d(float t) {\n    return vec3(0.04,0.08,0.12)\n        +t*(vec3(1.19,0.92,0.51)\n        +t*(vec3(-10.79,-8.48,-2.76)\n        +t*(vec3(51.01,43.22,20.24)\n        +t*(vec3(-103.47,-91.69,-52.03)\n        +t*(vec3(91.92,83.96,52.63)\n        +t*(vec3(-29.86,-27.94,-18.60)\n    ))))));\n}\n\nvec3 cmap_OklabOklab_sea(float t) {\n    return vec3(0.15,0.18,0.24)\n        +t*(vec3(0.67,0.51,0.57)\n        +t*(vec3(-7.33,-3.49,-2.54)\n        +t*(vec3(36.20,17.13,9.07)\n        +t*(vec3(-74.10,-36.49,-17.59)\n        +t*(vec3(66.26,33.43,15.56)\n        +t*(vec3(-21.70,-11.10,-5.06)\n    ))))));\n}\n\nvec3 cmap2(vec2 uv) {\n    uv.y *= 0.85;\n    uv.y = pow(\n        smoothstep(0., 1.2, uv.y),\n        .33\n    );\n    if(uv.x < .5)\n        return mix(\n            cmap_UnweightedOklab_example0(uv.y),\n            cmap_UnweightedOklab_example1(uv.y),\n            uv.x * 2.\n        );\n    return mix(\n        cmap_UnweightedOklab_example1(uv.y),\n        cmap_UnweightedOklab_example2(uv.y),\n        uv.x * 2. - 1.\n    );\n}\n\nvec3 sky(vec2 uv) {\n    if(uv.y < .5) {\n        return vec3(0.18, 0.20, 0.26);\n    }\n    // Sky gradient\n    vec2 uvs = uv;\n    uvs = fract(vec2(1,2.)*(uvs - vec2(0,.5)));\n\n    vec3 col = cmap2(uvs + .1 * smoothstep(.5,.51,uv.y)*mfnoise(vec2(1.,12.)*uv, 1., 1.e3, .65));\n    \n    // Clouds.\n    vec3 o = c.yyx,\n        t = c.yyy,\n        dir = normalize(vec3(vec2(.9,4.)*(uv - vec2(0,.5)),0.) + t - o);\n    float d = 0.,\n        dx = 2.e-3;\n    for(int i=0; i<45; ++i) {\n        vec3 x = o + d * dir;\n        float density = smoothstep(.1, 1., mix(fbm(22.*x), 0., smoothstep(.9, .3, uv.y)));\n        col = mix(\n            col, \n            mix(\n                cmap_UnweightedOklab_example0(fract(0.63 +smoothstep(.1, .5, pow(12.*density+.1, .95)))), \n                col,\n                1.-density\n            ),\n            .5*pow(density,.63)\n        );\n        d += dx;\n    }\n    \n    return col;\n}\n\nvec4 unite(vec4 sda, vec4 sdb) {\n    return sda.x < sdb.x ? sda : sdb;\n}\n\n/* Materials. */\nconst float MATERIAL_FLOOR = 0.;\n\n// Scene distance function\n// Mode:\n// mode.x - distance, material\n// mode.y - (glow amount) * (glow color)\n// mode.z - texture color, roughness\n// mode.w - reserved\nvec4 map(vec3 x, bvec4 mode) {\n    vec4 dm = vec4(1.e5, MATERIAL_FLOOR, 0, 0);\n    \n    float s = .3-.3*mfnoise(vec2(1., 15.)*x.xy, 1., 1.e2, .4);\n    \n    dm = unite(\n        dm,\n        vec4(x.z + .1 * s, MATERIAL_FLOOR, 0, 0)\n    );\n\n    if(mode.x)\n        return dm;\n\n    if(mode.y)\n        return c.yyyy;\n\n    if(mode.z) {\n        if(dm.y == MATERIAL_FLOOR) {\n            return mix(\n                vec4(cmap_OklabOklab_sea(fract(s)), .05), // Ordinary sea\n                vec4(sky((gl_FragCoord.xy/iResolution.xy*.9*c.xz + c.yx)), .05), // reflection\n                s\n            );\n        }\n    }\n    \n    return vec4(sky((gl_FragCoord.xy/iResolution.xy*.9*c.xz + c.yx)), .05);\n}\n\n// Surface normal\n// Usually, a map value at the intersection point is\n// already available; so we take this one here.\nvec3 normal(vec3 x, vec4 m) {\n    return normalize(vec3(\n        map(x + c.xyy * PATH_TRACER_NORMAL_PRECISION, cb.xyyy).x,\n        map(x + c.yxy * PATH_TRACER_NORMAL_PRECISION, cb.xyyy).x,\n        map(x + c.yyx * PATH_TRACER_NORMAL_PRECISION, cb.xyyy).x\n    ) - m.x);\n}\n\n// Sphere tracing algorithm\n// Output parameters:\n// x: Intersection coordinate\n// m: Intersection value\n// t: Ray parameter at intersection\nvoid march(\n    vec3 origin,\n    vec3 direction,\n    inout float t,\n    out vec3 x,\n    out vec4 m,\n    out vec3 glow\n) {\n    for(int i=0; i<SPHERE_TRACER_STEP_COUNT; ++i) {\n        x = origin + t * direction;\n        m = map(x, cb.xyyy);\n\n        float d = abs(m.x);\n\n        if(d < SPHERE_TRACER_PRECISION)\n            break;\n\n        t += min(.1*d, .01);\n    }\n}\n\nvec3 ca;\n\n// Taken from gltracy https://www.shadertoy.com/view/lsXSz7\n// and modified with a more realistic microfacet approximation\nvec3 radiance(\n    vec3 n, // macro surface normal\n    vec3 l, // direction from vertex to light\n    vec3 v, // direction from vertex to view\n    float m\t// roughness\n) {\n    vec3 cdiff = vec3(0.85, 0.42, 0.33);\n    vec3 cspec = .5*vec3(0.85, 0.42, 0.33);\n    vec3 clight = .5*vec3(0.85, 0.42, 0.33);\n\n    // half vector\n    vec3 h = normalize( l + v );\n\n    // dot\n    float dot_n_h = max( dot( n, h ), .01 );\n    float dot_n_v = max( dot( n, v ), .01 );\n    float dot_n_l = max( dot( n, l ), .1 );\n    float dot_h_v = max( dot( h, v ), .01 ); // dot_h_v == dot_h_l\n\n    // Geometric Term\n    // Cook-Torrance\n    //          2 * ( N dot H )( N dot L )    2 * ( N dot H )( N dot V )\n    // min( 1, ----------------------------, ---------------------------- )\n    //                 ( H dot V )                   ( H dot V )\n    float g = 2. * dot_n_h / dot_h_v;\n    float G = min( min( dot_n_v, dot_n_l ) * g, 1. );\n\n    // Normal Distribution Function ( cancel 1 / pi )\n     // Beckmann distribution\n    //         ( N dot H )^2 - 1\n    //  exp( ----------------------- )\n    //         ( N dot H )^2 * m^2\n    // --------------------------------\n    //         ( N dot H )^4 * m^2\n    float sq_nh   = dot_n_h * dot_n_h;\n    float sq_nh_m = sq_nh * ( m * m );\n    float D = exp( ( sq_nh - 1. ) / sq_nh_m ) / ( sq_nh * sq_nh_m );\n\n    // Specular Fresnel Term : Schlick approximation\n    // F0 + ( 1 - F0 ) * ( 1 - ( H dot V ) )^5\n    vec3 Fspec = cspec + ( 1.  - cspec ) * pow( 1. - dot_h_v, 5. );\n\n    // Diffuse Fresnel Term : violates reciprocity...\n    // F0 + ( 1 - F0 ) * ( 1 - ( N dot L ) )^5\n    vec3 Fdiff = cspec + ( 1.  - cspec ) * pow( 1. - dot_n_l, 5. );\n\n    // Cook-Torrance BRDF\n    //          D * F * G\n    // ---------------------------\n    //  4 * ( N dot V )( N dot L )\n    vec3 brdf_spec = Fspec * D * G / ( dot_n_v * dot_n_l * 4. );\n\n    // Lambertian BRDF ( cancel 1 / pi )\n    vec3 brdf_diff = cdiff * ( 1. - Fdiff );\n    \n    // Microfacet BRDF\n    // https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n    float msq = m * m;\n    float mqu = msq * msq;\n    float d = (dot_n_h * mqu - dot_n_h) * dot_n_h + 1.0;\n    float brdf_ggx = mqu / (pi * d * d);\n\n    // Punctual Light Source ( cancel pi )\n    return ( brdf_spec + brdf_diff ) * clight * dot_n_l * brdf_ggx;\n}\n\nvoid pixel( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(sky(fragCoord.xy / iResolution.xy), 1);\n    ca = fragColor.rgb;\n\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 origin = vec3(0, -1, 1);\n    vec3 target = vec3(0, 0, 1);\n    vec3 right = c.xyy;\n    vec3 direction = normalize(target + uv.x * right + uv.y * cross(right, normalize(target - origin)) - origin);\n    vec3 light = vec3(1.e4, -1.e4, -1.e4);\n\n    // Material ray\n    vec3 x;\n    vec4 m;\n    float t = -origin.z/direction.z;\n    vec3 g = c.yyy;\n    march(origin, direction, t, x, m, g);\n    if(m.x >= SPHERE_TRACER_PRECISION) return;\n    vec3 n = normal(x, m);\n    vec4 cr = map(x, cb.yyxy);\n    vec3 lx = normalize(light - x);\n    fragColor.rgb = (1.8 + 1.8 * radiance(n, lx, normalize(origin - x), cr.w)) * cr.xyz + .1 * g;\n    \n    // Reflected Ray\n    if(.66-cr.w >= 0.) {\n        vec3 xr = x;\n        vec3 nr = n;\n        for(int i=0; i<1; ++i) {\n            vec4 mr;\n            vec3 gr = c.yyy;\n            vec3 or = reflect(direction, nr);\n            float tr = 5. * SPHERE_TRACER_PRECISION;\n            march(xr, or, tr, xr, mr, gr);\n            if(m.x >= SPHERE_TRACER_PRECISION) return;\n            nr = normal(xr, mr);\n            vec4 crr = map(xr, cb.yyxy);\n            vec3 colr = (.6+ .7 * radiance(nr, normalize(light - xr), normalize(or - xr), crr.w)) * crr.xyz / float(i + 1);\n            fragColor.rgb += clamp(.66-cr.w, 0., 1.) * clamp(colr, 0., 1.);\n        }\n    }\n    \n    // Ambient Occlusion\n    float d = 1.e-2,\n        am = 150.;\n    for(float i=0.; i<=am; i+=1.) {\n        d += .001;\n        vec4 mm = map(x+d*n, cb.xyyy);\n        fragColor.rgb *= 1.-max(0.,(d-.5*abs(map(x + d*n, cb.xyyy).x))/d/am);\n    }\n    \n    // Hard Shadow\n    vec3 xs;\n    vec4 ms;\n    float ts = 1.e-2;\n    vec3 gs = c.yyy;\n    march(x, lx, ts, xs, ms, gs);\n    fragColor.rgb *= mix(.7, 1., step(length(light - xs), ts));\n    fragColor.a = t;\n    \n    // Set the color.\n    fragColor = clamp(fragColor, 0., 1.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int sliceIndex = iFrame % sliceCount;\n    float sliceSize = iResolution.y / float(sliceCount);\n    if(fragCoord.y >= float(sliceIndex) * sliceSize && fragCoord.y < float(sliceIndex + 1) * sliceSize) {\n        float ssaa = 1.;\n        vec4 col = vec4(0.);\n        float bound = sqrt(ssaa)-1.;\n            for(float i = -.5*bound; i<=.5*bound; i+=1.)\n                for(float j=-.5*bound; j<=.5*bound; j+=1.)\n                {\n                    vec4 c1;\n                    float r = pi/4.;\n                    mat2 R = mat2(cos(r),sin(r),-sin(r),cos(r));\n                    pixel(c1, fragCoord.xy+R*(vec2(i,j)*.25/max(bound, 1.)));\n                    col += c1;\n                }\n        col /= ssaa;\n        fragColor = col;\n    }\n    else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}