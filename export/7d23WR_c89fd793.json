{"ver":"0.1","info":{"id":"7d23WR","date":"1617452071","viewed":102,"name":"Waves TP5","username":"JohannaTrost","description":"Ocean waves","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["proceduralanimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Eric Galin\n\nconst float View = 2800.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\nconst int Steps = 400;      // Number of steps\n\nconst float PI = 3.14159265359;\n\n// Lipschitz constant\nconst float K=1.2;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Boolean operations -----------------------------------------------------------------------------------\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nV Sphere(vec3 p, vec3 c,float r, int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n// Sphere \n// p : point\n// n : Normal of Plan\n// o : Point on Plan\nV Plan(vec3 p, vec3 n, vec3 o, int index)\n{\n    return V(dot((p-o),n), index);\n}\n\n// Disc\n// p : point\n// c : center point \n// n : normal\n// r : radius \n// t : thickness of disc\nV Disc(vec3 p, vec3 c, vec3 n, float r, float t, int index)\n{\n  vec3 pc = p-c;\n  float h = dot(pc,n);\n  float m = sqrt(dot(pc, pc)-h*h) - r;\n\n  if(m < 0.0)\n  {\n      return V(abs(h) - t,index); \n  }\n  else\n  {\n      return V(sqrt(m*m + h*h) - t, index);\n  }\n}\n\n// Terrain -----------------------------------------------------------------------------------------------\n\nfloat replace(float ha, float hb, float mask)\n{\n    return mix(ha,hb,mask);\n}\n\nfloat Plateau(float h, float starth, float endh ,bool limit)\n{\n  if(h > starth && h < endh)\n  {      \n      return starth + smoothstep(0., 1., (h - starth) / (endh - starth))* (endh - starth);\n  }\n  else if (limit && h >= endh) \n  {\n      return endh;\n  }\n  else \n  {\n      return h;\n  }\n}\n\nfloat PlateauInMountain(float h, float starth, float endh)\n{ \n  float mid1 = starth + (endh - starth)*.3;\n  float mid2 = endh - (endh - starth)*.3;\n  if(h > starth && h < mid2)\n  {\n      return Plateau(h, starth, mid1, true);\n  }\n  else \n  {\n      return Plateau(h, mid2, endh, false);\n  }\n} \n\n// Terrain heightfield\n// x : Position in the plane\nfloat Canyon(in vec2 p)\n{\n    float l0 = 110.;\n    float z1 = 30.;\n    float z2 = 200.;\n    return z1 + 0.25*(z2-z1) + HeteroFbmRidge(p,.25*(z2-z1),l0,4);\n} \n\n\n// Implicit surface defining the terrain\n// p : Point\nV ImplicitTerrain(in vec3 p, in float terrain, in int index)\n{\n    float h = (p.z - terrain) / K; \n    return V(h, index);\n}\n\n// Masque à support compact dans cercle (c, ra) avec decroissance jusqu'à rb\nfloat AlphaDisk(in vec2 p, in vec2 c, float ra, float rb)\n{\n    float d=length(p-c);\n    return 1.-smoothstep(ra,rb,d);\n}\n\n// SommeSinusoides\n// a0 : amplitude \n// l0 : wavelength\n// wavedir : direction in which the waves are rolling\n// o : octaves for sum\n// ph : phase \n// f : wave frequency\n// noiselevel : amount of noise\n// changerate : speed of change between wave frequencies\n// maxWaveFreq : min frequency of waves\n// minWaveFreq : max frequency of waves\nfloat SommeSinusoides(in vec2 p, in float a0, in float l0, \n                      in vec2 wavedir, in int o, in float ph, \n                      in float f, in float noiselevel, in float changeRate, \n                      in float maxWaveFreq, in float minWaveFreq, \n                      bool changeori)\n{\n  float a = a0;\n  float l = l0;\n  \n  /*\n   *  To ensure organic behavior, the number of waves generated changes periodically as well. \n   *  The changeRate indicates how long one cycle between the maximum number of waves generated\n   *  and the minimum number of waves generated lasts (in seconds). Maximum and minimum number of\n   *  waves refers to the number of wave peaks that are simultaneously rendered at the disc surface.\n   *  In order to enure positive values only, the absolute values of the cosine function was used.\n   */\n   \n  vec2 k;\n  \n  float sum = 0.;\n  float noise = FbmRidge(p,6.,150.,3);\n  \n\n  float changeWaveFreq = abs(cos(iTime/changeRate*2.*PI)); // abs to ensure unidirectionality of waves  \n  changeWaveFreq *= (maxWaveFreq - minWaveFreq);\n  changeWaveFreq += minWaveFreq;\n\n  float waveFreqScaling = 1.;\n  \n  for(int i=0;i<o;i++)\n  {\n    if(changeori)\n    {\n        waveFreqScaling = changeWaveFreq/l;\n    }\n        \n    k = vec2(wavedir.x,wavedir.y)*waveFreqScaling;\n    \n    sum+=a*cos(dot(vec2(p.x,p.y-noise*noiselevel),k)-(f*2.*PI*iTime+ph));\n    a*=pow(2.,float(-i));\n    l*=pow(2.,float(-i));\n  }\n  return sum;\n}\n\n\n// Scene --------------------------------------------------------------------------\n\n// Potential field of the object\n// p : point\nV Object(vec3 p)\n{\n  float ocean;\n  float l0 = 200.; // wavelength\n  vec2 k1 = vec2(0.75,0.5); // wavedirection\n  vec2 k2 = vec2(0.4,0.75); // wavedirection\n\n  // params : p, a0, l0, wavedir, octaves, phase, freq, noiselevel, changeRate, maxWaveFreq, minWaveFreq, bool changeori\n  ocean = SommeSinusoides( p.xy, 10., l0, k1, 3 , PI/2., .2, 5., 100., 3.5, 0.5, true); // big slow waves\n  \n  ocean += SommeSinusoides(p.xy, 1.5, l0/6., k2, 3,2., .5, 7., 40., 1., 1.5, true); // smaller noisier waves with different direction\n\n  V u = Intersection(\n      ImplicitTerrain(p,ocean,0),\n      Disc(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,1.0), 350.0, 200., 0));\n      \n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = Object(p).v;\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/K);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nvec3 TextureWater(in vec3 p)\n{\n  return vec3(0.114, 0.392, 0.439);   \n}\n\n// Compute color \n// p : Point\n// n : Normal\nvec3 Color(in vec3 p,in vec3 n)\n{\n  V vp= Object(p);\n  float h = ImplicitTerrain(p, vp.v,0).v;\n  return TextureWater(p)/(1.-h/50.); \n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    int it;\n    bool b;\n    float t = SphereTrace( ro, rd, View,b , it);\n\tvec3 p = ro + t*rd;\n    float vp= Object(p).v;\n    vec3 n = ObjectNormal( p );\n\n\n    col = Color(p,n);\n    // Sky\n    if( b==false )\n    {\n        col = vec3(0.35,0.65,0.95) - rd.z*rd.z*2.5;\n    }\n\telse \n\t{\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n                   \n\n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col = 0.45*col+0.55*dif*vec3(0.35,0.35,0.35);\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \tfloat s=float(it)/float(Steps);\n\t\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    \t// Gamma with square root\n    \treturn vec4( sqrt(col), t );\n    }\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    pip=false;\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 3.14*2.0*1.5*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,5.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \n//float Noise(in vec2 p)\n//{\n//    vec2 i = floor(p);\n//    vec2 f = fract(p);\n//  \n//    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n//    return mix(mix( Hash(i+vec2(0,0)), \n//                        Hash(i+vec2(1,0)),f.x),\n//                   mix( Hash(i+vec2(0,1)), \n//                        Hash(i+vec2(1,1)),f.x),f.y);\n//}\n\nfloat Random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat Noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = Random(i);\n    float b = Random(i + vec2(1.0, 0.0));\n    float c = Random(i + vec2(0.0, 1.0));\n    float d = Random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// FBM ---------------------------------------------------------------------------\n\n// Fractal brownian motion with 4 frequencies\n// p : Point\nfloat Fbm(in vec3 p)\n{\n    return Noise(p)/2.0+Noise(p*2.0)/4.0+Noise(p*4.0)/8.0+Noise(p*8.0)/16.0;\n}\n\n// Ridge\nfloat Ridge(in float x)\n{\n  return 1.-2.*abs(x);\n}\n\n// Fractial Brownien Motion on Noise\nfloat Fbm(in vec2 p, in float a0, in float l0, in int o)\n{\n  float a = a0;\n  float l = l0;\n  float noiseSum = 0.;\n  for(int i=0;i<o;i++)\n  {\n    noiseSum+=a*Noise(p/l);\n    a*=pow(2.,float(-i));\n    l*=pow(2.,float(-i));\n  }\n  return noiseSum;\n}\n\n// Fractional Brownian Motion on Ridge Noise\nfloat FbmRidge(in vec2 p, in float a0, in float l0, in int o)\n{\n  float a = a0;\n  float l = l0;\n  float noiseSum = 0.;\n  for(int i=0;i<o;i++)\n  {\n    noiseSum+=a*Ridge(Noise(p/l));\n    a*=pow(2.,float(-i));\n    l*=pow(2.,float(-i));\n  }\n  return noiseSum;\n}\n\n// Fbm on ridge noise\n// output +/- a0 + a0/2 + a0/4 + a0/8 + ... ~ +/- 2a0 = [-2 a0, 2 a0]\nfloat HeteroFbmRidge(in vec2 p, in float a0, in float l0, in int o)\n{\n  float noiseSum = a0*Ridge(Noise(p/l0)); // starting with a signal: level 0\n  float a = a0;\n  float l = l0; \n  for(int i=1;i<o;i++)\n  {\n    noiseSum+=a*Ridge(Noise(p/l))*smoothstep(-a,a,noiseSum); // attenuation depends on current altitude\n    a*=.5;\n    l*=.5;\n  }\n  return noiseSum;\n}\n\n// Camera\n// a: Rotation angle around z axis\n// ro : Ray origin\nmat3 Camera(float a, out vec3 ro)\n{\n\tfloat range=1600.0;\n    // Origin\n    ro = vec3(range*cos(a),range*sin(a),range/4.0);\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,-50.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}","name":"Common","description":"","type":"common"}]}