{"ver":"0.1","info":{"id":"wdVyzm","date":"1602889222","viewed":141,"name":"Waving USSR flag","username":"dmitrytsgn","description":"Our shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","basics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nvec2 rotate(vec2 vec, float angle) {\n    vec2 res;\n\tres.x = vec.x * cos(angle) - vec.y * sin(angle);\n    res.y = vec.x * sin(angle) + vec.y * cos(angle);\n\n\treturn res;\n}\n\nfloat Band(float val, float a, float b, float blur) {\n\treturn smoothstep(a - blur, a + blur, val) * smoothstep(b + blur, b - blur, val);\n}\n\nfloat Rect(vec2 uv, float bottom, float top, float left, float right, float blur) {\n\tfloat bandV = Band(uv.y, bottom, top, blur);\n    float bandH = Band(uv.x, left, right, blur);\n\n    return bandV * bandH;\n}\n\nfloat Circle(vec2 uv, vec2 center, float radius, float blur) {\n    float dist = distance(uv, center);\n    \n    return smoothstep(radius+blur, radius-blur, dist);\n}\n\nfloat Ellipse(vec2 uv, vec2 center, float a, float b, float blur) {\n    uv-= center;\n    float leftSide = uv.x * uv.x / (a * a);\n    float rightSide = 1.f - uv.y * uv.y / (b * b);\n    float blur2 = sqrt(blur * 2.f) / 2.f;\n    return smoothstep(leftSide - blur2, leftSide + blur2, rightSide);\n}\n\nfloat IsoscelesTriangle(vec2 uv, vec2 center, float height, float baseHalf, float blur) {\n    uv -= center;\n    float left = Rect(uv, 0.f, height, -(baseHalf - uv.y / height * baseHalf), 0.f, blur);\n    float right = Rect(uv, 0.f, height, 0.f, baseHalf - uv.y / height * baseHalf, blur);\n    \n\treturn left + right;\n}\n\nfloat StarPoligon(vec2 uv, vec2 center, float radius, int n, int d, float blur) {\n    uv -= center;\n    uv /= radius;\n    float beta = 2.f * M_PI * (float(d) - 1.f) / float(n);\n\tfloat pointAngleHalf = (M_PI - 2.f * beta) * 0.5f;\n    \n    float baseHalf = tan(pointAngleHalf);\n    \n    float star = 0.f;\n    for (int i = 0; i < n; i += 1) {\n        float angle = M_PI * 2.f / float(n) * float(i);\n    \tstar = max(IsoscelesTriangle(rotate(uv, angle), vec2(0.f), 1.f, baseHalf, blur), star);\n    }\n    \n    return star;\n}\n\nfloat Sickle(vec2 uv, vec2 center, float side, float blur) {\n    uv -= center;\n    \n    float circleScale = 0.8f;\n    float circleOffset = 1.f - circleScale;\n    float radius = side * circleScale;\n    vec2 circleCenter = vec2(0.f, side * circleOffset);\n    \n    // Blade\n    float circle = Circle(uv, circleCenter, radius, blur);\n    \n    vec2 ellipseCenter = vec2(circleCenter.x - 0.19f * radius, circleCenter.y + 0.05f * radius);\n    float ellipse = Ellipse(uv, ellipseCenter, radius * 0.9f, radius * 0.8f, blur);\n    float rect = Rect(uv, -(radius + blur), 0.f, -(radius + blur), 0.f, blur);\n    \n    float blade = circle - ellipse - rect;\n\n    // Handle\n    float handleThickness = radius * 0.18f; // at the bottom\n    float bottom = -side + handleThickness;\n    float top = -radius * 0.47f;\n    float height = bottom - top;\n    float x = (uv.y - bottom) / height * 0.08f * radius;\n    float left = -handleThickness - x;\n    float right = handleThickness + x;\n    rect = Rect(uv, bottom, top, left, right, blur);\n   \tcircle = Circle(uv, vec2(0.f, bottom), handleThickness, blur);\n    \n    float handle = max(rect, circle);\n    \n    float frame = Rect(uv, -side, side, -side, side, blur);\n    return max(handle, blade);\n}\n\nfloat Hammer(vec2 uv, vec2 center, float side, float blur) {\n\tuv -= center;\n    float frame = Rect(uv, - side, side, -side, side, blur);\n    \n    // Handle \n    float handleThickness = 0.13f * side; // at the bottom\n    \n    float height = side * 2.f - handleThickness;\n    float bottom = -side + handleThickness;\n    float top = side;\n    float x = (uv.y - bottom) / height * side * 0.05f;\n    float left = -handleThickness + x;\n    float right = handleThickness - x;\n    float rect = Rect(uv, bottom, top, left, right, blur);\n    float circle = Circle(uv, vec2(0.f, -side + handleThickness), handleThickness, blur);\n    float handle = max(rect, circle);\n\n    // Head\n    float headHeight = side * 0.45f;\n    float headWidth = side * 0.5f; // at the bottom\n    \n   \tbottom = side - headHeight;\n    top = side;\n    x = (uv.y - bottom) / headHeight * side * 0.2f;\n    left =  -headWidth;\n    right = headWidth - x;\n    rect = Rect(uv, bottom, top, left, right, blur);\n\n    return max(rect, handle);\n}\n\nfloat CoatOfArms(vec2 uv, vec2 center, float scale, float blur) {\n    uv -= center;\n    uv /= scale;\n    float side = 0.5f;\n    \n\tfloat sickle = Sickle(rotate(uv, 0.25f * M_PI), vec2(-0.1f * side, -0.15f * side), side, blur);\n    float hammer = Hammer(rotate(uv, -0.25f * M_PI), vec2(0.02f, -0.1f), side * 0.9f, blur);\n    \n    float frame = Rect(uv, -0.5f, 0.5f, -0.5f, 0.5f, blur);\n    return max(sickle, hammer);\n}\n\nvec4 Flag(vec2 uv, vec2 center, float scale, float blur) {\n    uv -= center;\n    uv /= scale;\n    \n    vec4 flagRed = vec4(0.78f, 0.f, 0.f, 1.f);\n    vec4 flagYellow = vec4(1.f, 0.79f, 0.055f, 1.f);\n\t\n    float flagLength = 0.8f;\n    // The flag aspect ratio was 1/2\n    float heightHalf = flagLength / 2.f;\n    \n    // construct sine wave\n    float sinScaleX = 8.f;\n    float tilt = uv.y * 2.f; // tilt the wave, so that it's not parallel to height\n    float offset = -mod(iTime + tilt, 2.f * M_PI); // dynamic offset to make wave move\n    float sinVal = sin(uv.x * sinScaleX + offset);\n    // subtract sine value at flag base, so that base does not move\n    float flagBaseSin = sin(-flagLength * sinScaleX + offset);\n    \n    float waveStrength = 0.033f;\n    float wave = (sinVal - flagBaseSin) * waveStrength;\n    \n    uv.y -= wave; // apply wave\n    \n    // flag symbols\n    float symbolsX = -flagLength + heightHalf * 2.f / 3.f;\n    vec2 coatPosition = vec2(symbolsX, heightHalf * 0.37f);\n    float coatOfArms = CoatOfArms(uv, coatPosition, heightHalf / 2.f, blur);\n    \n    vec2 starPosition = vec2(symbolsX, heightHalf *3.f / 4.f);\n    float starOuter = StarPoligon(uv, starPosition, heightHalf / 8.f, 5, 2, blur * 3.f);\n    float starInner = StarPoligon(uv, starPosition, heightHalf / 15.f, 5, 2, blur * 2.f);\n\t\n    float symbols = coatOfArms + starOuter - starInner;\n    \n    // make right side of the flag wave\n    float right = flagLength * (1.f + 0.05f * sinVal);\n    float flag = Rect(uv, -heightHalf, heightHalf, -flagLength, right, blur);\n    \n    vec4 flagCol = flagRed * flag;\n    vec4 symbolsCol = flagYellow * symbols;\n    vec4 col = mix(flagCol, symbolsCol, symbolsCol.a);\n    \n    // add shadows and highlights based on sinusoid\n    col.xyz -= (-sinVal * 0.11f) * flagCol.a;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y; \n\n    vec4 skyBlue = vec4(0.53f, 0.81f, 0.92f, 1.f);\n\tvec4 flag = Flag(uv, vec2(0.f), 1.f, 0.01f);\n    vec4 col = mix(skyBlue, flag, flag.a);\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}