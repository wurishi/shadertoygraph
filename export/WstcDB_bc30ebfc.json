{"ver":"0.1","info":{"id":"WstcDB","date":"1601656233","viewed":126,"name":"22 - Raymarched Texture","username":"Krabcode","description":"I'm really glad I finally learned how to do this","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"18 - Sea of Sinewaves\" by Krabcode. https://shadertoy.com/view/3ddcz2\n// 2020-10-02 16:01:39\n\n// Made with love by Krabcode\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n\nconst int MAX_STEPS = 1;\nconst float MAX_DIST = 1.;\nconst float SURF_DIST = 0.0001;\nconst float NORMAL_DIST = 0.001;\nconst float SHININESS = 10.;\nconst float DOWNSTEP = 0.1;\nconst float PI = 3.14159;\n\nfloat time; \nvec2 uv;\nvec2 lightOffset; \nvec3 lightPos;\n\nfloat rayLength;\nfloat closestDist;\nfloat hitDist;\nvec3 hit;\nvec3 intersect;\nvec2 m;\n\nmat2 rotate(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\nfloat sdf(vec3 p){ \n    return p.z-0.01+.002*length(texture(iChannel0, p.xy+vec2(0.7, time)));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        closestDist = min(dS, closestDist);\n        dO += dS*DOWNSTEP;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) \n{\n    float d = sdf(p);\n    vec2 e = vec2(NORMAL_DIST, 0);\n    vec3 n = d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx));\n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p, vec3 normal) \n{\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    float d = rayMarch(p+normal*SURF_DIST*2., l);\n    if(d<length(lightPos-p)){ dif *= .1; }\n    return dif;\n}\n\n\nfloat specularLight(vec3 p, vec3 rayDir, vec3 normal) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDir), 0.);\n    return pow(specularAngle, SHININESS);\n}\n\nfloat render(vec2 uv)\n{\n    vec3 rayOrigin = vec3(uv+vec2(0., 0.25), 0.);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.)); \n    hitDist = rayMarch(rayOrigin, rayDir);\n    hit = rayOrigin + rayDir * hitDist;\n    vec3 normal = normal(hit);\n    float diff = diffuseLight(hit, normal);   \n    float spec = specularLight(hit, rayDir, normal);\n    return .5*diff + .5*spec;\n}\n\nfloat aaRender(vec2 uv){\n    vec2 third = vec2(1./iResolution.x, 1./iResolution.y) / 3.0;\n    vec2 mult = vec2(1, -1);\n    float c1 = render(uv+third*mult.xx);\n    float c2 = render(uv+third*mult.xy);\n    float c3 = render(uv+third*mult.yx);\n    float c4 = render(uv+third*mult.yy);\n    return (c1+c2+c3+c4) / 4.;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy / iResolution.xy;\n    time = 100.+float(iFrame)*.0005;\n    lightPos = vec3(0.,5.0,-16.0);\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float lit = render(uv); \n    lit *= smoothstep(MAX_DIST*.15, MAX_DIST*.05, hitDist);\n    fragColor = vec4(gammaCorrection(vec3(lit)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}