{"ver":"0.1","info":{"id":"3dKSWG","date":"1711361109","viewed":77,"name":"towrers with z-system","username":"voland","description":"word of  cylinders, spheres and flat objects(front projection)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["texturing","simplestshapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nconst float N_INFINITY = -1000.0;\nconst float R = .7;// main column's radius\n\n// TODO: сделать 2D булевские операции: \n// объединение - это просто сложение по модулю 1: res = (a + b) % 1\n// вычитание(скорее маска) - умножение на инверс: res = a * (1 - b)\n\nfloat remap01(float a, float b, float t) {return (t-a)/(b-a);}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    // это обратная матрица к настоящей матрице поворота.\n    // Мы должны так делать потому что как бы возвращаем точку в начало  и там рисутем\n    // и вот это \"возвращение\" и есть обратная операция к прямому сдвигу\n    // - действительному положению объекта на экране.\n    return mat2(c,-s,s,c);\n}\n\nfloat circ(vec2 _p, vec2 c, in float r){\n    vec2 p = _p - c;\n    return step(dot(p,p),r * r);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat rect(vec2 p, vec2 c, vec2 size){\n\tvec2 s = step(abs(p - c), 0.5 * size);\n\treturn s.x * s.y;\n}\n\n\n\nfloat rectOutline(vec2 p, vec2 c, vec2 size, float thickness){\n\tfloat ht = 0.5 * thickness;// half thickness\n\tfloat outer = rect(p, c, size + vec2(ht));\n\tfloat inner = rect(p, c, size - vec2(ht));\n\treturn outer - inner;\n}\n\nvec2 brickTile(vec2 p, float _zoom){\n    p *= _zoom;\n    p.x += step(1., mod(p.y,2.0)) * 0.5;\n    return fract(p);\n}\n\nfloat column(vec2 p, float x, float r){\n    return step(abs(p.x - x), r);\n}\n\nvec4 columnWithST(vec2 p, float x, float r, float a){\n  \tfloat c = column(p,x,r);\n    float X = p.x - x;\n    float alpha = acos(X/r) + a;\n    vec2 st = vec2(fract(alpha/PI), p.y);\n    //float z =  N_INFINITY * (1. - c);// плоский объект: где есть, z=0, иначе -Infinity..\n    float z = sqrt(r * r - X * X);// + pf.wcoord.z;// не плоский а цилиндрический\n    //z = (c > .0) ? z : N_INFINITY;// TODO: how to do this without conditional?\n    //z = (1. - c) * N_INFINITY + c * z;// same as above, but without conditional...\n    z = N_INFINITY - c * (N_INFINITY - z);\n    return vec4(st,z, c);\n}\n\nstruct Platform {\n    vec3 ccoord;// alpha, y, d. Cylindrical coords of the platform's axe(pivot point).\n    vec3 wcoord;// word coord of pivot point;\n    float r;// platform's radius\n    float h;// it's height\n      \n    vec2 st;// texture coords\n    float z;// world z coord of the point on surface. Do we need full 3D worldcoords?\n    float c;\n};\n\n// constructs Platform using coord = vec2(alpha, y) of base point. \nPlatform createPlatform(vec2 p, vec2 ccoord, float r, float h, float R, float A){\n    Platform pf;pf.r = r;pf.h = h;\n    pf.ccoord = vec3(ccoord, R + r);\n    float a = A + pf.ccoord.x;// current alpha\n    pf.wcoord =  vec3(cos(a) * pf.ccoord.z, // we can use cylindric->world matrix here\n                      pf.ccoord.y,\n                      sin(a) * pf.ccoord.z);\n    //pf.c = column(p,pf.wcoord.x,r);\n    float X = p.x - pf.wcoord.x;\n    pf.c = step(abs(X), r) * step(abs(p.y - pf.wcoord.y + 0.5 * h), h * 0.5);\n    float beta = acos(X/r) - a;\n    pf.st = vec2(fract(beta/PI), p.y);\n    //pf.z = (X*tan(beta) + pf.wcoord.z) * pf.c ;\n    //pf.z = (sqrt(r * r - X * X) + pf.wcoord.z) * pf.c;\n    pf.z = sqrt(r * r - X * X) + pf.wcoord.z;\n    pf.z = N_INFINITY - pf.c * (N_INFINITY - pf.z); // keep -INFINITY if c=0, set z if c=1.\n    return pf;\n}\n\n\n// our custom mix\nvec4 mix(vec4 col1, vec3 col2, vec4 object){\n    vec3 col = mix (col1.rgb, col2, object.a * step(col1.w, object.z));\n    return vec4(col,  max(col1.w, object.z));\n}\n\nvec4 drawPlatformType1 (vec2 p, vec4 col, vec2 coord, float A){\n    Platform ptf2 = createPlatform(p, coord, 0.15, 0.1, R, A);\n    vec3 ptf2Col = mix(vec3(.5,1.,1), vec3(1,0,1), circ(brickTile(ptf2.st, 10.), vec2(0.5), 0.5));\n    return mix(col, ptf2Col, vec4(ptf2.st, ptf2.z, ptf2.c));\n}\n\nconst vec4 green = vec4(0,1,0,1);\n\n// Двузвенная цепь. Примитивнейшая IK.\nvec4 drawHeroLeg1(vec2 p, vec4 col, float A){\n\n    //col = mix(col, vec4(0,0,1,1), rect(q, vec2(0), vec2(.13, .4))  );\n    //col = mix(col, vec4(0,0,1,1), step( sdBox(q, vec2(.017, .20)), .05 ));\n    const float timing = 20.;\n    \n    p -= vec2(-.15, -.1);// база не по центру.(это же животное..)\n    \n    //--- links --------------------------------------------\n    \n    // Начинаем со второго звена   \n    float l1 = 0.3;\n    vec2 shift = vec2(-.1, -.35);\n    shift.x += .1 * sin(timing * A);\n    shift.y +=  max(0.0, .07 * cos(timing * A));\n    vec2 p1 = p - shift;\n    \n    \n    \n    // Первое звено\n    mat2 T0 = mat2(shift, vec2(1,0));// Новый x - это как раз shift, новый y - как и старый - горизонталь(шиириться...).  \n    //mat2 T0 = mat2(shift, vec2(-shift.y,shift.x));// Прямоугольная, не нормализованная(скейлится)\n    \n    // Прямоугольная, нормализованная(единичная).\n    // Длину звена надо выставлять явно при отрисовке...\n    //mat2 T0 = mat2(shift, vec2(-shift.y,shift.x)) / length(shift);// Запоминаем: быстрая нормаль(перпендикуляр к вектору)\n    \n    vec2 p0 = inverse(T0) * p;\n    \n    // рисуем\n      \n    col = mix(col, vec4(0), step( sdLine(p0, vec2(0), vec2(1.03, 0)), .1));\n    col = mix(col, vec4(0), step( sdLine(p1, vec2(0), vec2(l1, 0)), .05)); \n    \n    col = mix(col, green, step( sdLine(p0, vec2(-0.1, 0), vec2(1.01, 0)), .065));\n    col = mix(col, green, step( sdLine(p1, vec2(0), vec2(l1, 0)), .025)); \n    \n    \n    \n    // Debug stick-like chain\n    //col = mix(col, vec4(1), step( sdLine(p1, vec2(0), vec2(l1, 0)), .01));  \n    //col = mix(col, vec4(1), step( sdLine(p0, vec2(0), vec2(1.0, 0)), .01));\n    \n    \n    \n    \n    return col;\n}\n\nvec4 drawHero(vec2 p, vec4 col, float A){\n    \n    //p *= 3.5;\n    \n    col = drawHeroLeg1(p, col, A + .25 * PI);\n    \n    //col = mix(col, vec4(1.,1., 0,0), circ(p, vec2(0), 1.));\n    col = mix(col, vec4(0), circ(p / vec2(1., 0.66), vec2(0), .5));\n    col = mix(col, vec4(0,1,0, 0), circ(p * vec2(1., 1.5), vec2(0), .45));// always on top\n    \n    col = mix(col, vec4(0), circ(p * vec2(1.5, 1.), vec2(.25, 0.25), 0.35));\n    col = mix(col, vec4(1), circ(p * vec2(1.5, 1.), vec2(.25, 0.25), 0.3));\n    col = mix(col, vec4(0), circ(p, vec2(.225, 0.2), 0.125));\n    col = mix(col, vec4(1), circ(p, vec2(.2, 0.25), 0.025));\n    \n    //col = mix(col, vec4(vec3(1),0), rectOutline (p,vec2 (0), vec2(1.), 0.03));\n    \n    col = drawHeroLeg1(p, col, A);\n    \n    return col;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    \n    vec4 col = vec4(.0,.0,.0, N_INFINITY);\n    \n    //col = mix(col, vec4(0,0,1, N_INFINITY), circ(p, vec2(0.1, 0.), 1.));\n    //col = mix(col, vec4(0,1,0, N_INFINITY + 1.), circ(p, vec2(0), 1.));// place flat drawing on -INFINITY...\n    \n    \n    \n        //float A = iTime;\n    float A =  texelFetch(iChannel1, ivec2(0),0).x;// between 0 and 1\n    A = A * TWO_PI;\n    \n    \n    \n    vec4 myColumn = columnWithST(p, 0., R, -A);// TODO: why I should pass neganive value?\n    //col = mix(col, vec3(1,0,0), circ(brickTile(myColumn.st, 10.), vec2(0.5), 0.5));// Крутой эффект прозрачности без альфаканала(альфа на базе миксера)\n    // Теперь я могу наложить сколько угодно текстур на колонну:\n    //vec3 colCol = mix(vec3(0,0,1), vec3(1,0,0), circ(brickTile(myColumn.st, 10.), vec2(0.5), 0.5));\n    vec3 colCol = mix(vec3(0.3), vec3(1,0,0), rect(brickTile(myColumn.st, 10.), vec2(0.5), vec2(.8)));\n    colCol = mix(colCol, vec3(1,1,0), circ(myColumn.st, vec2(0.5), 0.5));\n    col = mix(col, colCol, myColumn);// custom mix\n      \n\n    \n\t\n    Platform myPlatform = createPlatform(p, vec2(0), 0.2, 0.2, R, A);\n\n    vec3 platformCol = mix(vec3(.5,0.5,1), vec3(1,1,1), circ(brickTile(myPlatform.st, 10.), vec2(0.5), 0.5));\n    //vec3 platformCol = mix(vec3(0,0.5,1), vec3(1,0,0), circ(myPlatform.st, vec2(0.5), 0.5));\n    col = mix(col, platformCol, vec4(myPlatform.st, myPlatform.z, myPlatform.c));\n    \n    \n        \n    \n    Platform ptf2 = createPlatform(p, vec2(0.15, 0.05), 0.15, 0.2, R, A);\n    vec3 ptf2Col = mix(vec3(.5,1.,1), vec3(1,0,1), circ(brickTile(ptf2.st, 10.), vec2(0.5), 0.5));\n    col = mix(col, ptf2Col, vec4(ptf2.st, ptf2.z, ptf2.c));\n   \n    col = drawPlatformType1(p, col, vec2(0., -0.3), A);//ec2 p, vec4 col, vec2 coord, float A\n    \n\n    // hero\n    col = drawHero(p, col, A);\n    \n    \n\n    // Output to screen\n    fragColor = col;//vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const ivec2 r0 = ivec2(0);// 0th register for alpha\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\n\nfloat readKey( int key )\n{\n    return texelFetch(iChannel0, ivec2(key,0),0).x;\n}\n\n\nfloat readDir(){\n    return readKey(37) - readKey(39);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > 1.0 || fragCoord.y > 1.0 ) discard;\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    fragColor = vec4(0.0);\n    \n    const float w = 0.25;// velocity (turn/sec)\n    float oldAlpha = texelFetch(iChannel1, r0,0).x;\n    float deltaAlpha = w * iTimeDelta * readDir();\n    float newAlpha = fract (oldAlpha + deltaAlpha);\n \n    storeValue(r0, vec4(newAlpha, 0.0, 0.0, 0.0), fragColor, ipx);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}