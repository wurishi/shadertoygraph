{"ver":"0.1","info":{"id":"lX2XR1","date":"1710757184","viewed":167,"name":"BumpSphere","username":"dema","description":"Simple implementation of an environment map for mirror-like surfaces for a spherical object which radius dynamically changes over time. Click to show only the base color and the Fresnel effect.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","environmentmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define MAX_ITER 70\n#define MIN_DIST 0.001\n\n#define F0 vec3(0.955,0.638,0.538)\n\nvec3 schlick(vec3 n , vec3 v){\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - clamp(dot(n,v),0.0,1.0),5.0);\n}\n\n\n// helper function for 2D rotations\nmat2 rot2D(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\n// the signed distance field of a sphere\nfloat sdSphereBump(vec3 p, vec3 center, float radius){\n    radius = radius + 0.05 * sin(p.x * 10.0 + iTime) * sin(p.y * 10.0 + iTime) * sin(p.z * 10.0 + iTime);\n    return length(p-center) - radius; \n}\n\n// map is the signed distance field of the scene\n// we are going to render\nfloat map(vec3 p){\n    return sdSphereBump(p,vec3(0.,0.,0.),1.0);\n}\n\n// an helper function that analytically computes \n// the normal of the scene at a given point p\nvec3 calcNormal(vec3 p){\n    vec3 dx = vec3(.001,0.,0.);\n    vec3 dy = vec3(0.,.001,0.);\n    vec3 dz = vec3(0.,0.,.001);\n    float fp = map(p);\n    return normalize(\n        dx * (map(p+dx) - fp) + \n        dy * (map(p+dy) - fp) +\n        dz * (map(p+dz) - fp)\n    );\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    // compute distance with raymarching\n    float t = 0.;\n    float currentDist = map(ro + t*rd);\n    \n    for(int i = 0; i < MAX_ITER; i++){\n        if (currentDist < MIN_DIST)\n            return t;\n        if (currentDist > MAX_DIST)\n            return -1.0;\n        t += currentDist;\n        currentDist = map(ro + t*rd);\n    }\n    return -1.0;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 z = normalize(ta-ro);\n\tvec3 up = vec3(0.0,1.0,0.0);\n\tvec3 x = -normalize( cross(z,up) );\n\tvec3 y =          ( cross(z,x) );\n    return mat3( x, y, z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y from -1 to 1, x from -ar to ar)\n    vec2 uv = (2.* fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.* iMouse.xy - iResolution.xy)/iResolution.y;\n\n    vec3 ta = vec3( 0.,0.,0.);\n    vec3 ro = ta + vec3(0.,.5,3.);\n    mat3 ca = setCamera( ro, ta);\n    const float fl = 1.5;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    \n    // rotate camera\n    mat2 rot = rot2D(0.1 * iTime);\n    ro.xz *= rot;\n    rd.xz *= rot;\n    rot = rot2D(0.0);\n    ro.yz *= rot;\n    rd.yz *= rot;\n    \n    // compute distance with raymarching\n    float t = rayMarch(ro,rd);\n    if(t>0.){\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 r = reflect(rd,n);\n        vec3 color;\n        if(iMouse.z > 0.0)\n            color = schlick(n,reflect(rd,n));\n        else\n            color = schlick(n,reflect(rd,n)) * texture(iChannel0,r).rgb;\n        fragColor = vec4(color,1.0);\n    }\n    else{\n        fragColor = texture(iChannel0,rd);\n    }\n\n\n}","name":"Image","description":"","type":"image"}]}