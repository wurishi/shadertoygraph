{"ver":"0.1","info":{"id":"lsVczG","date":"1522698612","viewed":414,"name":"Weird Animated Pathtracer","username":"slerpy","description":"This one is animated, but takes forever to converge\n\nSpace to reset","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","dof","shadows","animated","reflections","pathtracer","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define DEBUG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    col = col / col.w;\n\n#ifdef DEBUG\n    col *= 2.0;\n#else\n    vec3 s1 = sin(.7 * (iTime + 10.) * vec3(1, 1.1, 1.3));\n    vec3 s2 = sin(.8 * (iTime + 10.) * vec3(1.2, 0.9, 1.1));\n    vec3 mask = 1. - pow(max(s1*s1, s2*s2), vec3(120.));\n    col = vec4(dot(col.rgb, mask));\n#endif\n    \n    col = 2.5 * col / (box(col.xyz) + 1.);\n    col = pow(col, vec4(1) / 2.2) - 0.16;\n\n#ifndef DEBUG\n    col.rg = vec2(smoothstep(.0, 1., col.r));\n#endif\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 1.\n#define DOF 0.\n\n#define FAR 50.\n#define ITER 80\n#define STEP 1.\n#define NORK 1e-3\n\n#define RITER 4\n#define RRFB .001\n\nconst float pi = acos(-1.);\nconst float tau = pi + pi;\n\nstruct obj {\n    vec3 emit;\n    float metallic;\n} objHit;\n\nconst vec3 ps[] = vec3[](\n    vec3(-1.5,1,1.5), vec3(1.1,.3,-2), vec3(-1.4,-.8,-1), vec3(1.6,-.9,1.5)\n    //vec3(-3,1,3), vec3(1,1,-1), vec3(1,-1,-1), vec3(-3,-1,3)\n    //vec3(-1,0,-1), vec3(0,1,-1), vec3(1,0,-1), vec3(0,-1,-1), vec3(-1,0,-1)\n);\n\nfloat map(vec3 p)\n{\n    objHit.emit = vec3(0);\n    objHit.metallic = .0;\n    \n    float d = 1e+31;\n    \n    dmin(d, min( max(1.8-box(p*rz(.6)), 1.-p.z), min(3.2-box(p.xy), p.z+4.5)));\n    if(dmin(d, length(p)-.5))objHit.metallic = .9;\n    \n    /*for(int i=0; i < ps.length()-1; i++)\n    {\n        vec3 glow = vec3(0); glow[i%3] = 1.;\n        //vec3 dlt = .2 * normalize(ps[i+1] - ps[i]);\n        vec3 p1 = ps[i], p2 = ps[i+1];\n        if(dmin(d, line(p, p1, p2)-.06 ))objHit.emit = 16. * glow;\n    }*/\n    \n    vec3 pipes = vec3(0);\n    for(int i=0; i < ps.length()-1; i++)\n    {\n        vec3 p1 = ps[i], p2 = ps[i+1];\n        pipes[i%3] = line(p, p1, p2)-.06;\n    }\n    float mp = -sbox(-pipes);\n    if(dmin(d, mp))objHit.emit = vec3(lessThan(pipes, vec3(mp+.001)));\n    \n    \n\treturn d;\n}\n\n\n/////////////////////////////////\n\n\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p);\n\tvec2 e = vec2(0,k);\n\treturn normalize(m-vec3(\n\t\tmap(p - e.yxx),\n\t\tmap(p - e.xyx),\n\t\tmap(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd, int iter)\n{\n    float t=RRFB, m;\n    for(int i=0; i < iter; i++)\n    {\n        t += STEP * map(ro + rd*t);\n        if(t > FAR)break;\n    }\n    return t;\n}\n\n\n/////////////////////////////////\n\n\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n    p.xy += AA * (hash23(vec3(p.xy, iFrame)) - .5);\n\tvec2 uv = (2.*p.xy-iResolution.xy)/iResolution.x;\n    \n    vec2 blur = DOF * (hash23(vec3(iFrame, p.xy))-.5) / iResolution.x;\n    mat3 rm = rx(blur.x) * ry(blur.y);\n    \n\tro = rm * vec2(0, -4).xxy;\n    rd = rm * normalize(vec3(uv, 1.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    if(iFrame > 0 && texelFetch(iChannel1, ivec2(0x20, 0), 0).r < .5)\n\t\tfragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    uvec2 temp = uvec2(fragCoord + iResolution.yx * iTime);\n    uint seed = temp.x * temp.y;\n    \n    vec3 emit = vec3(0), ro, rd, sp, sn;\n    camera(ro, rd, fragCoord);\n    \n    for(int i=0; i<RITER; i++)\n    {\n        float t = tracer(ro, rd, ITER-14*i);\n        if(t > FAR)break;\n        \n        obj objSave = objHit;\n        \n\t\tsp = ro + rd*t;\n\t\tsn = normal(sp,NORK);\n        \n        emit += objSave.emit;\n        \n        seed ^= uint(iFrame) / uint(i+1);\n        rd = mix(hashHs(sn, seed), reflect(rd, sn), objSave.metallic);\n        ro = sp;\n    }\n    \n    fragColor += vec4(emit, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashHs( vec3 n, uint seed )\n{\n    float a=(float((seed*0x73493U)&0xfffffU)/float(0x100000))*2.-1.;\n    float b=6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float c=sqrt(1.-a*a);\n    vec3 r=vec3(c*cos(b),a,c*sin(b));\n    return dot(r,n)>0.?r:-r;\n}\n\n\n/////////////////////////////////\n\n\nmat3 rx(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat3(1,0,0,0,c,s,0,-s,c);\n}\n\nmat3 ry(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat3(c,0,s,0,1,0,-s,0,c);\n}\n\nmat3 rz(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat3(c,s,0,-s,c,0,0,0,1);\n}\n\n\n/////////////////////////////////\n\n\nfloat box(vec3 p)\n{\n    p=abs(p);\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat box(vec2 p)\n{\n    p=abs(p);\n    return max(p.x, p.y);\n}\n\nfloat sbox(vec3 p)\n{\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sbox(vec2 p)\n{\n    return max(p.x, p.y);\n}\n\n/////////////////////////////////\n\n\nbool dmin(inout float d, in float x)\n{\n    bool b=x<d;\n    if(b)d=x;\n    return b;\n}\n\nfloat line(vec3 pos, vec3 point1, vec3 point2) {\n    vec3 dir0 = point2 - point1;\n    vec3 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    return length(dir1 - dir0 * h);\n}","name":"Common","description":"","type":"common"}]}