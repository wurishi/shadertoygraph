{"ver":"0.1","info":{"id":"XX3Sz8","date":"1718561455","viewed":74,"name":"Čech Complex","username":"chronos","description":"The 2D Čech complex of a set of points for a given radius as a function of time. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["graph","complex","complex","alpha","topology","persistent","computational","homology"],"hasliked":0,"parentid":"M3tXRr","parentname":"Alpha Complex"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Čech Complex by chronos\n    --------------------------------------\n\n    For completeness, here is the Čech complex as well :)\n    \n    The Čech complex resembles the Vietoris-Rips Complex, \n    but has fewer simplices due to a stricter criterion:\n    In order to build a triangle, all the discs around the vertices\n    have to have a non-empty intersection, instead of just the pairwise edges.\n    \n    The Čech complex is therefore a sub-complex of the Vietoris-Rips complex.\n    \n    The first point where the non-empty intersection occurs happens to be the circumenter,\n    so when the threshold radius reaches the circumradius, we include the simplex.\n    \n    This is similar to the α-complex, with the difference being that we do not\n    require the simplices to be part of the Delaunay complex as well.\n    The α-complex is therefore a sub-complex of the Čech complex (which in turn\n    is a sub-complex of the Vietoris-Rips, as previously mentioned).\n    \n    The α-complex can therefore be seen as the intersection of the set of\n    simplices in the Delaunay complex and the Čech complex.\n    \n    --------------------------------------\n    Forked shader description:\n    --------------------------------------\n        Alpha Complex by chronos\n        --------------------------------------\n\n        An α-complex is generalization and a subcomplex of the Delaunay complex\n        which only includes simplicies that have a circumcircle smaller than\n        the given radius. α is the reciprocal of the generalized disc radius, 1/α. \n\n        Note that I use the radius 'r' as the threshold here, instead of using α = 1/r.\n        It seems some authors use α = r. It doesn't really matter though :)\n        In the code, the word alpha only refers to opacity.\n\n        Note also that the rule for drawing edges used here is:\n            Edge circumsphere radius < r AND circumsphere does not contain other vertices.\n            OR\n            The edge is part of another simplex (triangle) already in the complex.\n\n        \n\n            Vietoris–Rips Complex by chronos\n            --------------------------------------\n\n            Simple (and inefficient) rendering and demonstration of the\n            Vietoris–Rips complex of a set of points in 2D \n\n            The Vietoris–Rips complex contains all simplices constructed from points in the set whose \n            diameter is less than a specified value. The diameter of a set of points is the maximum of\n            all pairwise distances between points in the set.\n\n            As I understand, the Vietoris–Rips complex can contain subsets of\n            size greater than the (ambient-) dimension. E.g containing tetrahedrons even in 2D.\n            This is in contrast to Delaunay Complexes and Alpha Complexes.\n            Here I only include simplices of size up to 3 (aka triangles).\n    \n    Related concepts:\n    \n    Vietoris–Rips Complex\n        - See description in forked shader! :)\n    Delaunay complex ( and Voronoi diagram)\n        - Contains all simplices whose circumsphere do not contain other vertices.\n    Convex hull\n        - Intuitively the outline/surface of the Delaunay complex.\n    Čech complex\n        - Simplices are included based on the intersection of all balls centered at the vertices.\n          In contrast to Vietoris-Rips, where we only require *pairwise* intersections of the participating vertices.\n          There is also a 2x difference in scale due to one definition using radius and and the other using the diameter.\n          \n    Alpha Complex\n        - A generalization and a subcomplex of the Delaunay complex which only includes simplicies that have a circumcircle smaller than\n          the given radius. α is the reciprocal of the generalized disc radius, 1/α. \n          \n    Alpha Shape\n        - Intuitively the outline/surface of the alpha complex, so it only includes simplices with circumsphere radius *exactly* equal to 1/α,\n          which do not contain other vertices. Exact definition varies a bit it seems.\n    \n    \n    Links:\n    ----------------------------------------------------\n    https://en.wikipedia.org/wiki/Vietoris–Rips_complex\n    https://en.wikipedia.org/wiki/Čech_complex\n    https://en.wikipedia.org/wiki/Alpha_shape\n    https://en.wikipedia.org/wiki/Diameter#Generalizations\n    https://en.wikipedia.org/wiki/Delaunay_triangulation#d-dimensional_Delaunay\n    \n    self link: https://www.shadertoy.com/view/XX3Sz8\n\n*/\n\n\nvec2 get_pos(int index)\n{\n    return  .8 * (-1. + 2. * texelFetch(iChannel0, ivec2(index, 9), 0).rg);\n}\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat tri(vec2 a, vec2 b, vec2 c, vec2 p, float ps)\n{\n    c-= a; b-=a; p-=a;\n    float ABC = determinant(mat2(b,c));\n    float C = determinant(mat2(b,p));\n    float B = determinant(mat2(p,c));\n    float A = ABC - B - C;\n    ps *= ABC * 4.;\n    return smoothstep(-ps, ps, A) * smoothstep(-ps, ps, B) * smoothstep(-ps, ps, C);\n}\n\n\nvec2 circumcircle_center(vec2 a, vec2 b, vec2 c)\n{\n    float bdotb = dot(b,b);\n    vec2 rhs = vec2((bdotb - dot(a,a)), (dot(c,c) - bdotb)) / 2.;\n    return transpose(inverse(mat2x2(b-a, c-b))) * rhs;\n}\n\nfloat circumcircle_radius(vec2 q, vec2 a)\n{\n    return distance(q,a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ps = 2. / iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float dotsize = 0.01;\n    float seg_thickness = 0.005;\n    \n    float t = fract(iTime*0.01);\n    float r = 2. * min(t,(1.-t));\n    \n    if(length(iMouse.xy) > 10.)\n        r = length(mouse)*.8;\n    \n    const int num_points = 20;\n    \n    // Loop over all points\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos = get_pos(i);\n        float d = length(uv-pos);\n\n        col += smoothstep(dotsize+ps,dotsize-ps, d); // Draw dot\n        \n        col += smoothstep(r+ps,r-ps, d) * 0.00125 * vec3(1, 2, 3); // Draw disc\n        col += smoothstep(1.5*ps,ps*.5, abs(d-r)) * 0.0125 * vec3(0.25, 1, 4); // Draw circle\n    }\n    \n    // Loop over all pairs\n    \n    float seg_alpha = 0.;\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos_i = get_pos(i);\n        for(int j = i; j < num_points; j++)\n        {\n            vec2 pos_j = get_pos(j);\n\n            vec2 center = (pos_i+pos_j)*.5;\n            float radius = length(pos_i-pos_j)*.5;\n            float connected = smoothstep(radius-0.001, radius+0.001, r); // 1 if  radius < r\n            seg_alpha = max(seg_alpha, connected * 0.125 * smoothstep(seg_thickness+ps,seg_thickness-ps, seg(pos_i, pos_j, uv)));\n            \n            \n        }\n    }\n    \n    // Loop over all triples\n    float tri_alpha = 0.;\n    for(int i = 0; i < num_points; i++)\n    {\n        vec2 pos_i = get_pos(i);\n        for(int j = i; j < num_points; j++)\n        {\n            vec2 pos_j = get_pos(j);\n            \n            for(int k = j; k < num_points; k++)\n            {\n                vec2 pos_k = get_pos(k);\n                \n                vec2 center = circumcircle_center(pos_i, pos_j, pos_k);\n                float radius = circumcircle_radius(center, pos_i);\n                \n                float connected = smoothstep(r+0.001, r-0.001, radius);\n                tri_alpha = max(tri_alpha, 0.1 * connected * tri(pos_i, pos_j, pos_k, uv, ps));\n            }\n        }\n    }\n    \n    col = mix(col,  vec3(1, 3, 2), tri_alpha * (1.-8.*seg_alpha));\n    col = mix(col, vec3(3, 1, 3), seg_alpha);\n\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}