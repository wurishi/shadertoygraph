{"ver":"0.1","info":{"id":"NlBfWz","date":"1652015994","viewed":188,"name":"Beat of Love","username":"Rrrrichard","description":"A lovely toon-style beating heart For Anniversary of Love at 2022/05/08","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","heart","toonsytle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ==========================================================\n// \"Beat of Love\"\n// -- A lovely toon-style beating heart for anniversary of love at 2022/05/08\n// \n// Written by Rrrrichard(Zhehao Li) \n// in a \"2-hour shader challenge\" on 2022/05/08 \n// (Actually used about 4 hours)\n//\n// Copyright Zhehao Li, 2022 \n// You cannot use this work in any commercial product, \n// website or project. You cannot sell this Work \n// and you cannot mint NFTs of it.\n// \n// ==========================================================\n\n#define MAX_STEPS 300\n//#define MAX_DIST 10. --> amazing effect with the shape of SDF\n#define MAX_DIST 1e10\n#define EPS .01\n\n\nfloat smoothAbs(float x, float alpha)\n{\n    // softmax for soften sharp features \n    float t1 = exp(alpha *x);\n    float t2 = exp(-alpha *x);\n    return x*(t1 - t2) / (t1+t2);\n}\n\nfloat spike(float x, float center, float sigma)\n{\n    // a Guass normal function, not used \n    return 1. / sigma * exp(- pow((x-center)/sigma, 2.));\n}\n\nfloat GetSceneDistance(vec3 point, out int obj)\n{\n    vec4 sphere = vec4(0, 1.5, 6, 1.3); // (xyz, radius)\n    float bounce_freq = 9.;\n    sphere.w += 0.1*sin(bounce_freq * iTime);\n    \n    point = vec3(\n        0.95 * point.x, \n        //1.1*point.y - abs(point.x) *(25. - point.x) / 50.,\n        1.1 *point.y - smoothAbs(point.x, 6.) *(25. - point.x) / 50.,\n        0.8 * point.z);  \n        \n    float sphere_dist = length(point - sphere.xyz)-sphere.w;\n   \n    float ground_dist =  10. - point.z; // distance to background wall \n    \n    float d =min(sphere_dist, ground_dist);\n    \n    // distance to center \n    float c= (point.x*point.x + point.y*point.y);\n    \n    float eps = 0.01;\n    if( abs(sphere_dist - d) < eps)\n        obj = 1; // heart \n    else\n        obj = 0; // wall\n        \n    if(obj == 0)\n    {\n        //point.z += 0.01* sin(dist_to_center);\n        //d+= 0.1*pow(0.99, c) *sin(0.3*c- bounce_freq * iTime);\n        \n        d+= 0.3*pow(0.95, c) *\n                sin(0.3*c- bounce_freq * iTime);\n        \n        //d+= 10. * spike(c, 1., 0.4);\n     }\n        \n    \n    return d; \n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir, out int obj)\n{\n    float d = 0.; \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * d;\n        float ds = GetSceneDistance(p, obj); \n        d += ds; \n        if(d > MAX_DIST || ds < EPS)\n            break;  // hit object or out of scene\n    }\n    return d; \n}\n\nvec3 GetNormal(vec3 point)\n{\n    int obj_nouse;\n    float d = GetSceneDistance(point, obj_nouse); \n    vec2 e = vec2(0.01, 0); \n    vec3 n = d - vec3(\n        GetSceneDistance(point - e.xyy, obj_nouse),\n        GetSceneDistance(point - e.yxy,  obj_nouse),\n        GetSceneDistance(point - e.yyx, obj_nouse)\n    );\n    \n    return normalize(n); \n}\n\nfloat smoothStep(float edge0, float edge1, float x)\n{\n    \n    if (x < edge0)\n        return 0.;\n    if (x > edge1)\n        return 1.;\n    if(edge1 == edge0)\n        return 0.; \n    x = (x - edge0) / (edge1 - edge0);\n    return x*x * (3.-2.*x);\n}\n\nvec3 GetLight(bool is_ground, vec3 point, vec3 light_pos, vec3 light_col, vec3 camera_pos)\n{    \n    vec3 to_light = normalize(light_pos - point); \n    vec3 normal = GetNormal(point); \n        \n    //======== 1. diffuse ==========\n    bool in_shadow = false; \n    float NdotL = dot(to_light, normal);\n    float diffuse = NdotL > 0. ? 1. : 0.;\n    if(is_ground)\n    {\n        float NdotL_smooth = smoothStep(0.4, 1.0, NdotL);\n        diffuse = NdotL > 0.4 ? 1.0 : 0.5;\n    }\n        \n    // Shoot a ray towards light \n    int obj_nouse;\n    float d = RayMarch(point+normal*2.*EPS, to_light, obj_nouse);\n    \n    if(is_ground)\n        diffuse *= 0.4;\n    // Shadow \n    if (d < length(light_pos - point))\n    {\n        in_shadow = true;\n        diffuse *= 0.3;\n    }        \n    \n    // ======== 2. ambient ===========\n    float ambient = 0.3; \n    if (is_ground)\n         ambient = 0.1;\n    \n    // ======== 3. specular ===========\n    vec3 to_camera = normalize(camera_pos - point);\n    vec3 half_vector = normalize(to_camera + to_light);\n    float NdotH = dot(normal, half_vector);\n    \n    float glossiness = 20.; \n    if (is_ground)\n        glossiness = 2.;\n    float specular = pow(NdotH, glossiness * glossiness);\n    float specular_smooth = smoothStep(0.005, 0.01, specular);\n    \n    // ======== 4. rim light ===========\n    float scale = 0.2;\n    float rimDot = pow(NdotL, scale)* (1. - clamp(dot(to_camera, normal), 0., 1.));\n    float rimAmount = 0.616; \n    if (is_ground)\n        rimAmount = 0.1;\n    float rim = 0.5 *  smoothStep(rimAmount - 0.01, rimAmount+0.01, rimDot);\n    \n    // ======== Final light ==========\n    float intensity = 0.8; \n    \n    float sum = 0.;\n    \n    if(in_shadow)\n        if(is_ground)\n            sum = (diffuse + ambient + 0.5 *(specular_smooth ));\n            // not add rim here\n        else\n            sum = (diffuse + ambient);\n    else\n        sum = (diffuse + ambient + specular_smooth + rim);\n    \n    vec3 light = intensity * sum * light_col ;\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.x;\n\n    // Time varying pixel color\n    vec3 ray_origin = vec3(0., 1.5, -1);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // light\n    vec3 light_pos = vec3(0.8, 5., -2); \n    \n    vec3 light_col = vec3(255.,25.,53.) / 255.;\n    //vec3 light_col = vec3(240.,139.,113.) / 255.; lovely pink-yellow\n    //vec3 light_col = vec3(240.,179.,113.) / 255.; lovely white-yellow\n    //vec3 ground_col = vec3(120.,19.,27.) / 255.;\n    vec3 ground_col = vec3(250,59.,103.) / 255.;\n    //vec3 ground_col = vec3(150,59.,203.) / 255.; a little purple\n    \n    float spin = 1.;\n    float range = 10.;\n    vec3 light_pos2 = light_pos + range* vec3(sin(spin *iTime), cos(spin *iTime), 0.);\n    \n    // \n    int obj = 0; \n    float d = RayMarch(ray_origin, ray_dir, obj);\n    \n    vec3 point = ray_origin + d * ray_dir; \n   \n    vec3 col; \n    if(obj == 1)\n        col = GetLight(false, point, light_pos, light_col, ray_origin);\n    else\n        col = GetLight(true, point, light_pos, ground_col, ray_origin);\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}