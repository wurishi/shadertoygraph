{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float SIZE = 0.6;\n#define TR (5./iResolution.x)\n#define PI 3.141592\n\nvec4 c = vec4(0.0, 0.0, 0.0, 1.0);\nvec2 uv; \n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fnoise(vec2 uv) {\n\tuv*=vec2(.5,1.);\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.85*noise( uv*vec2(.5,1.)); uv = m*uv+.17562;\n\t\t  f += 0.30*noise( uv ); uv = m*uv+.54621;\n\t\t  f += 0.15*noise( uv ); uv = m*uv+.23585;\n\t\t  f += 0.08*noise( uv ); uv = m*uv+.12598;\n\t\t  f += 0.04*noise( uv ); uv = m*uv+.64581;\n\treturn f*f;\n}\n\nfloat _smooth(float start, float end, float t) {\n\tif (t > end) {\n\t\treturn 1.;\n\t} else if (t < start) {\n\t\treturn 0.;\n\t} else {\n\t\treturn (t-start)/(end-start);\n\t}\n}\n\nvoid planet(void)\n{\n\tfloat d = sqrt(uv.x*uv.x + uv.y*uv.y);\n\tif (d >= SIZE) {\n\t\treturn;\n\t}\n\tfloat m = (1.0 - _smooth(SIZE - TR, SIZE, d));\n\t\n\t\n\tfloat cng = asin(d/SIZE);\n\tfloat lambda = atan(uv.x*sin(cng) , d*cos(cng));\n\t//float phi = 0.;\n\tfloat phi = asin(uv.y*sin(cng) / d);\n\t\t\n\tvec2 duv = vec2(lambda * 2. / PI , phi * 2.0 / PI);\n\tduv.x = duv.x*(1.0 - 0.5*abs(duv.y)*(abs(duv.y))) + iTime*0.25;\n\t\n\t\n\tfloat n = noise(3.0*(duv + vec2(50.0,-100.0)));\n\tfloat n2 = noise(6.0*(duv + vec2(-50.0,100.0)));\n\tfloat n3 = noise(40.0*(duv + vec2(-20.0,0.0)));\n\t\n\tc = vec4((n+1.)/2.,(n2+1.)/2.,(n3+1.)/2.,1.);\n\t//return;\n\t\n\tif (n > -0.1)\n\t\tc = m * vec4(0.06,0.04,0.50,1.0);\n\telse \n\t\tc = m * vec4(0.05,0.45,0.1,1.0);\n\t\n\tif (n < 0.05 && n2 < 0.)\n\t\tc = m * vec4(0.05,0.45,0.1,1.0);\n\tif (n < 0.06 && n3 > 0.36)\n\t\tc = m * vec4(0.05,0.45,0.1,1.0);\n\t\n\t\t\n\t// c = m * mix(vec4(0.0,0.1,0.7,1.0),vec4(0.1,0.7,0.7,1.0),(n-0.01)/(0.06));\t\n\n\t\n\t\t\n\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = (fragCoord.xy / iResolution.y) * 2.0 - (iResolution.xy / iResolution.y);\n\tplanet();\n\tfragColor = c;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslXD4","date":"1401701983","viewed":222,"name":"Planets","username":"Smitty","description":"Just experimenting with noise + generation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""}}