{"ver":"0.1","info":{"id":"lsVSWW","date":"1464515216","viewed":1497,"name":"perspective transform 2","username":"PeterVivo","description":"fork: https://www.shadertoy.com/view/Xd3SR8#\n\nmy target is Ngon masked editable inversebilinear texture ( video on texture isn't important )\n+collect some experience with shader interaction.","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["video","interactive","inversebilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//adapted from this opengl method:\n//http://stackoverflow.com/questions/16989181/whats-the-correct-way-to-draw-a-distorted-plane-in-opengl\n\n//store the buffer drags values\nvec2 PP[4];\n\n\n//drags from buffer\n//buffer variables\nconst int maxCount = 4;\nconst float radius = 5.0;\nconst float border = .5;\n\nconst float statePos = float(maxCount);\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n// From: Iq\n// https://www.shadertoy.com/view/lsBSDm\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nfloat xross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = xross( g, f );\n    float k1 = xross( e, f ) + xross( h, g );\n    float k0 = xross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\n\nfloat line(vec2 uv, vec2 origin, vec2 destiny, float radius){\n    destiny -= origin;\n\tfloat color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );\n    return smoothstep(color-0.0005,color+0.0005, radius);    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //read drag buffer\n    vec4 state = BufA(statePos);\n    float curr = 0.0;\n    float dist = radius + 1.0;\n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        if (d < dist) {\n            dist = d;\n            curr = f;\n        }\n    }\n    for (int i = 0; i < maxCount; i++) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        \n        //store drag values\n        PP[i] = center/iResolution.xy;\n    }\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //background\n    vec3 color = mix( texture(iChannel2, uv).rgb , vec3(.7) , vec3(1.2) ) ; //background\n   \n    //distort\n\n    vec2 texUv = invBilinear( uv, PP[0], PP[1], PP[2], PP[3] );\n    if( texUv.x>-0.5 )\n    {\n        //color = texture( iChannel1, texUv ).xyz;\n        color = texture( iChannel1, texUv ).xyz + mix( texture(iChannel2, texUv ).rgb , vec3(.1) , vec3(1.2) ) ;\n    }\n    \n    //line border\n   \t\n    vec3 dotCol = vec3( .7,.7,.7 );\n    color = mix(color, dotCol , line(uv, PP[0], PP[1], .002));\n    color = mix(color, dotCol , line(uv, PP[1], PP[2], .002));\n    color = mix(color, dotCol , line(uv, PP[2], PP[3], .002));\n    color = mix(color, dotCol , line(uv, PP[3], PP[0], .002));\n\t\n    \n    //drags\n\n    if (dist < radius) {\n        if (dist > radius - border) {\n            //border\n            color = vec3( .0,.0,.0 );\n        } else {\n            if (curr == state.x)\n                if (state.z > 0.0)\n                    //mouse pressed\n                    color = vec3( .0,.7,.9 );\n                else\n                    //last pressed\n                    color = vec3(.5,.5,.5 );\n            else\n                //standby\n                color = vec3(.5,.5,.5 );\n        }\n    }\n\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 4;\nconst float radius = 50.0;\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    vec3 IR = iResolution;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        // Initial conditions\n        \n        //comment this\n        addObject(0.2 * IR.x+0.01, 0.1 * IR.y);\n        addObject(0.8 * IR.x, 0.2 * IR.y);\n        addObject(0.7 * IR.x, 0.7 * IR.y);\n        addObject(0.2 * IR.x, 0.87 * IR.y);\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / IR.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / IR.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / IR.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n                state.x = 2.0 * statePos;\n            } else {\n                state.x = state.y;\n                state.y += 1.0;\n            }\n        }\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / IR.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}