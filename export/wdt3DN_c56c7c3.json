{"ver":"0.1","info":{"id":"wdt3DN","date":"1569161739","viewed":118,"name":"Floppydisk","username":"Minus256","description":"Thx iq <3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","floppydisk","diskette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--2019/22/9--\n//written by juwon \"Minus256\" ko(verification for school writing)\nconst float eps = 0.001;\nconst int mxmarch = 255;\nconst float maxlength = 1023.0;\nconst float beattime = 0.5;\nconst float halfpi = 1.57079632679;\nconst int bcnt = 7;\nfloat beat(float time)\n{\n    return mod(iTime,beattime)/beattime;\n}\nvec4 RotationToQuaternion(vec3 axis, float angle)\n{\n    float half_angle = angle * halfpi / 180.0;\n    vec2 s = sin(vec2(half_angle, half_angle + halfpi));\n    return vec4(axis * s.x, s.y);\n}\nvec3 rotate(vec3 pos, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n\tvec4 q = RotationToQuaternion(axis, angle);\n    return pos + 2.0 * cross(q.xyz, cross(q.xyz, pos) + q.w * pos);\n}\nfloat rand(float seed)\n{\n    float a = dot(vec2(seed*57.18273649,seed*32.190263728),vec2(18.123512,23.126423));\n    return sin(a);\n}\nfloat smoothrandom(float time)\n{\n    float timeseed = floor(time);\n    float smth = smoothstep(.0,1.,fract(time));\n    float smoothtime = mix(rand(timeseed),rand(timeseed+1.),smth);\n    return smoothtime;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b/2.0;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCol( vec3 p, vec3 info )\n{\n    vec2 nor = p.xy - info.xy;\n    return length(nor)-info.z;\n}\n\nfloat merge(float p1,float p2)\n{\n    return min(p1,p2);\n}\n\nfloat sub(float p1,float p2)\n{\n    return max(-p1,p2);\n}\n\nfloat sphere(vec3 pos,float rad)\n{\n    return length(pos)-rad;\n}\nfloat fsphere(vec3 pos,vec3 origin,float s)\n{\n    float c =0.4;\n    float en = 1.5;\n    float bt = beat(iTime);\n    float a = 0.;\n    float dsp = 0.2;\n    if(bt<0.4)\n    {\n        a=sin(bt*2.);\n        dsp = (c-bt);\n        s *= 1.+pow(dsp*0.3,1.2);\n    }\n    s *= en;\n    float p = ((sin(pos.x*c)+sin(pos.y*c)+sin(pos.z*c)))*0.01;\n    pos -= origin;\n    pos.yx  -= sin(length(pos.xyz*100.)*a)*dsp*0.5;\n    float diskbody = sdBox(pos,vec3(5.25,5.25,.06)*s);\n    float diskhole = sdCol(pos,vec3(.0,.0,.75)*s);\n    float diskhole2 = sdCol(pos,vec3(1.,-.27,.12)*s);\n    float diskrechole = sdBox(pos-vec3(.0,-1.8,.0)*s,vec3(.5,1.,3.)*s);\n    float disktab = sdBox(pos-vec3(2.7,1.3,.0)*s,vec3(.4,.25,3.)*s);\n    float diskrndhole =  sdCol(pos,vec3(.0,-1.3,.25)*s);\n    float diskrndhole2 = sdCol(pos,vec3(.0,-2.3,.25)*s);\n    float disknotchhole = sdCol(pos,vec3(.6,-2.625,.07)*s);\n    float disknotchhole2 = sdCol(pos,vec3(-.6,-2.625,.07)*s);\n    float subt = merge(diskhole,\n                 merge(diskhole2,\n                 merge(diskrechole,\n                 merge(disktab,\n                 merge(diskrndhole,\n                 merge(diskrndhole2,\n                 merge(disknotchhole,disknotchhole2)))))));\n    return sub(subt,diskbody)+p*max(sin(0.72),.0)-p;\n}\nfloat foprnd(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat sdf2(vec3 pos)\n{\n    vec3 bpos,rotater = vec3(.0);\n    float modtime = iTime*0.1;\n    float stk = 0.41;\n    float rts = 2.;\n    float s1,s2 = .0;\n    for(int i = 0;i < bcnt;i++)\n    {\n        float I = float(i);\n        bpos = vec3(smoothrandom(modtime+I*0.4234)\n                   ,smoothrandom(modtime*0.324+I*0.5342)\n                   ,smoothrandom(modtime*0.643+I*2.4321))*0.5;\n        rotater = vec3(smoothrandom(modtime*0.14322*rts+I*2.58245)\n                      ,smoothrandom(modtime*0.12132*rts+I*9.824356)\n                      ,smoothrandom(modtime*0.14532*rts+I*3.72434)\n                      )*0.2;\n        pos = rotate(pos,rotater,modtime*299.);\n        s1 = fsphere(pos,bpos*5.,(length(bpos[i])*0.5));\n        if(i == 0)\n        {\n            s2=s1;\n        }\n        else\n        {\n        \ts2 = foprnd(s1,s2,1.12);\n        }\n    }\n    float s3 = sphere(pos,.6);\n    return merge(s2,s3);\n}\nvec3 norm(vec3 pos)\n{\n    \n    float p = sdf2(pos);\n    vec2 h = vec2(.0,eps);\n    return normalize(vec3(\n        sdf2(pos+h.yxx)-p,\n        sdf2(pos+h.xyx)-p,\n        sdf2(pos+h.xxy)-p));\n}\nvec3 Luminance(vec3 N,vec3 W,vec3 cons1,vec3 cons2,vec3 cons3,vec3 cons4)\n{\n    return pow(vec3(abs(dot(N,W)))+cons4,cons1)*cons2+cons3;\n}\nvec3 render(vec3 Oi,vec3 OR,vec3 N,vec3 col)\n{\n    return Luminance(N,OR,vec3(123.3214,42.421,41.3412),vec3(1.5),vec3(0.19,0.01372,0.11123),vec3(.01))/\n           (Luminance(N,Oi,vec3(0.3452,0.2345,0.334523),vec3(1.),vec3(1.),vec3(.0))*abs(dot(N,Oi)));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 lookat = vec3(.0,.0,.0);\n    vec3 pos = vec3(3.*cos(iTime*0.2),3.*sin(iTime*0.2),3.0*sin(iTime*0.2));\n    vec3 post = pos;\n    vec3 vv = normalize(lookat-pos);\n    vec3 sv = cross(vv,vec3(.0,1.,.0));\n    vec3 up = cross(sv,vv);\n    vec2 uv = vec2((2.*fragCoord.xy-iResolution.xy)/iResolution.xx)*1.0;\n    vec3 ray = normalize(vv+up*uv.y+sv*uv.x);\n    vec3 ray2,normal2,pos2 = vec3(.0);\n    float L2,A2 = .0;\n    float A =.0;\n    float L=.0;\n    float shade = .0;\n    bool hit,hit2 = false;\n    for(int i=0;i<mxmarch;i++)\n    {\n        A = sdf2(pos);\n        L += A;     \n        shade++;\n        pos += ray*A;\n        if(A < eps)\n        {\n            hit = true;\n            break;\n        }\n        if(L>maxlength)\n        {\n            break;\n        }\n    } \n    vec3 normal = vec3(.0);\n    if(hit)\n    {\n        normal = norm(pos);\n    }\n    vec3 color = vec3(.0);\n    vec3 lightpos = vec3(sin(iTime*2.458672)*5.2345,-7.,sin(iTime*4.273289)*4.234);\n    vec3 OR = normalize(post);\n    vec3 Oi = -ray;\n    vec3 N = normal;\n    color = render(Oi,OR,N,pow(mod(pos,0.1)*44.44,vec3(55.0)));\n    if(sphere(pos,.6)<= eps)\n    {\n        ray2 = reflect(ray,normal);\n        pos2 = pos + 2.*eps*ray2;\n        for(int i=0;i<mxmarch;i++)\n    \t{\n        \tA2 = sdf2(pos2);\n       \t\tL2 += A2;     \n        \tpos2 += ray2*A2;\n        \tif(A2 < eps)\n        \t{\n            \thit2 = true;\n            \tbreak;\n        \t}\n        \tif(L2>maxlength)\n        \t{\n            break;\n        \t}\n    \t} \n        if(hit2)\n    \t{\n    \t    normal2 = norm(pos2);\n            color = render(-ray2,normalize(pos2),normal2,pow(mod(pos,0.1)*44.44,vec3(55.0)));\n    \t}\n        else\n        {\n            color = vec3(1.,1.,1.);\n        }\n    }\n    if(!hit)\n    {\n        color = vec3(1.,.24,.64);\n    }\n    color = pow(color,vec3(shade/280.));\n    color += shade/320.;\n    fragColor = vec4(vec3(color),1.);\n}","name":"Image","description":"","type":"image"}]}