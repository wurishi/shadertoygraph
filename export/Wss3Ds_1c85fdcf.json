{"ver":"0.1","info":{"id":"Wss3Ds","date":"1548095973","viewed":1693,"name":"Cubemap Pathtracing","username":"fizzer","description":"This is an example of how the new cubemap feature of Shadertoy can be used to cache and accumulate non-view-dependent illumination. Click and drag with the mouse to move the camera around.","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cubemap","cache"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is an example of how the new cubemap feature of Shadertoy can be used to cache\n// and accumulate non-view-dependent illumination.\n//\n// Surface textures for two cubes are both stored in one cubemap, by using a 2-channel\n// colour system. So two colours can be stored in an RGBA pixel.\n//\n// Click and drag with the mouse to move the camera around.\n//\n// This cached-cube-illumation idea was partially inspired by the 4-kilobyte demo\n// \"Think Outside the Box\" by slerpy: https://www.pouet.net/prod.php?which=79661\n\n#define AA 3\n\n// Sample the illumunation at a given position, in a given direction.\n// This version of the function (compared to the one in Cube A) uses the cubemap\n// for shading the diffuse boxes, and only traces mirror reflection rays.\nvec2 sampleRay(vec3 ro, vec3 rd)\n{\n    vec2 energy = vec2(0);\n    vec2 spectrum = vec2(1.);\n    vec2 mats = vec2(.9, .5) * .99;\n    vec3 lo = vec3(.7, .8, .1), ls = vec3(1, 0, 0) * .2, lt = vec3(0, 0, 1) * .2;\n    vec3 ln = normalize(cross(ls, lt));\n    float lightArea = length(ls) * length(lt);\n    float lightRadiance = 50.0;\n\n    for(int i = 0; i < 3; ++i)\n    {\n        vec3 n, p0, p1, uvw;\n        vec2 res = traceScene(ro, rd, n, uvw);\n        vec3 rp = ro + rd * res.x;\n        if(res.x < 0. || res.x > 1e3)\n            break;\n\n        float t = dot(lo - ro, ln) / dot(rd, ln);\n        if(t > 0. && t < res.x && dot(rd, ln) < 0.)\n        {\n            vec3 rp = ro + rd * t;\n            vec2 uv = vec2(dot(rp - lo, ls) / dot(ls, ls), dot(rp - lo, lt) / dot(lt, lt));\n            if(abs(uv.x) < 1. && abs(uv.y) < 1.)\n            {\n                energy += spectrum * lightRadiance;\n            }\n        }\n\n        float fr = mix(0.001, 1.0, pow(1. - clamp(dot(-rd, n), 0., 1.), 3.));\n\n        vec3 absuvw = abs(uvw);\n        vec2 uv = absuvw.x > absuvw.y ? (absuvw.x > absuvw.z ? uvw.yz : uvw.xy) : (absuvw.y > absuvw.z ? uvw.xz : uvw.xy);\n\n            if(res.y < .5)\n            {\n                // No intersection.\n                break;\n            }\n        else if(res.y < 1.5)\n        {\n            // Diffuse box 1.\n            if(rp.y > .99)\n                spectrum *= .5;\n            else\n                spectrum *= mats;\n            vec2 dc = texture(iChannel0,uvw).rg/float(iFrame)*12.;\n            dc *= mix(.3, 1., textureLod(iChannel2, uv / 2., 1.).r);\n            if(rp.y > .999 && abs(rp.x - -.3) < .6 && abs(rp.z - .1) < .8)\n            {\n                energy += spectrum * vec2(1.3, 1.).yx * mix(.7, 1., textureLod(iChannel1, rd, 2.).r);\n                fr = 1.;\n            }\n            else\n            {\n                energy += spectrum * dc * (1. - fr);\n            }\n        }\n        else if(res.y < 2.5)\n        {\n            // Diffuse box 2.\n            spectrum *= mats.yx;\n            vec2 dc = texture(iChannel0,uvw).ba / float(iFrame) * 12.;\n            dc *= mix(.3, 1., textureLod(iChannel3, uv / 2., 1.).b);\n            energy += spectrum * dc * (1. - fr);\n        }\n        else if(res.y < 3.5)\n        {\n            // Mirror box.\n            fr = 1.;\n        \tfr *= mix(1., .25, pow(textureLod(iChannel2, rp.zx, 1.).r, 3.));\n        }\n        spectrum *= .9 * fr;\n        ro = rp + n * 5e-3;\n        rd = reflect(rd, n);\n        \n        if(max(spectrum.x, spectrum.y) < 1e-4)\n            break;\n    }\n    return energy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = vec3(0);\n\n    // Set up primary ray direction and differentials.\n    vec3 ord = vec3(uv, -2.);\n    vec3 rdx = dFdx(ord) / 1.;\n    vec3 rdy = dFdy(ord) / 1.;\n\n    // Camera positioning.\n    float ax, ay;\n    mat2 mx, my;\n\n    ax = iMouse.z > 0. ? (iMouse.y / iResolution.y * 2. - 1.) * .7 : 0.;\n    mx = mat2(cos(ax), sin(ax), -sin(ax), cos(ax));   \n\n    ay = iMouse.z > 0. ? (iMouse.x / iResolution.x * 2. - 1.) * 1.5 : iTime / 4.;\n    my = mat2(cos(ay), sin(ay), -sin(ay), cos(ay));   \n\n    // AA loops.\n    for(int iy = 0; iy < AA; ++iy)\n        for(int ix = 0; ix < AA; ++ix)\n        {\n            vec3 ro = vec3(0, 0, 3.5);\n            vec3 rd = ord + float(ix) / float(AA) * rdx + float(iy) / float(AA) * rdy;\n\n            float a;\n            mat2 m;\n\n            ro.yz *= mx;\n            rd.yz *= mx;\n\n            ro.xz *= my;\n            rd.xz *= my;\n\n            vec3 n, uvw;\n            vec2 res = traceScene(ro, rd, n, uvw);\n\n            // Accumulate.\n            if(res.y > .5)\n            {\n                vec2 energy = sampleRay(ro,rd);\n                vec3 c2 = min(energy.x * vec3(.8, .6, .1) + energy.y * vec3(.1, .1, 1), 1.);\n                c += c2;\n            }\n            else\n            {\n                c += vec3(.03);\n            }\n        }\n\n    fragColor.rgb = c / float(AA * AA);\n\n\t// Gamma correction.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mats = vec2(.9, .5) * .99;\n\n// Lambert BRDF sampling-function.\nvec3 lambertNoTangent(in vec3 normal, in vec2 uv)\n{\n    float theta = 6.283185 * uv.x;\n    uv.y = 2.0 * uv.y - 1.0;\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n    return normalize(normal + spherePoint);\n}\n\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\n// Box surface normal.\nvec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)\n{\n    rp = rp - (p0 + p1) / 2.;\n    vec3 arp = abs(rp) / (p1 - p0);\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp);\n}\n\n// Ray intersection test with scene. Returns surface ID, hit distance,\n// surface normal, and local space texture coordinates.\nvec2 traceScene(vec3 ro, vec3 rd, inout vec3 outn, inout vec3 uvw)\n{\n    vec3 p = vec3(-1),q = vec3(1);\n    vec2 b = box(ro, rd, p, q);\n\n    float mint = 1e4;\n    float id = 0.;\n\n    // First box test\n    if(b.y > 0. && b.x < b.y && b.y < mint)\n    {\n        mint = b.y;\n        id = 1.;\n        uvw = ro + rd * mint;\n        outn = -boxNormal(uvw, p, q);\n        uvw = (uvw - p) / (q - p) * 2. - 1.;\n    }\n    else\n        return vec2(mint, id);\n\n    p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);\n    b = box(ro, rd, p, q);\n\n    // Second box test\n    if(b.x > 0. && b.x < b.y && b.x < mint)\n    {\n        mint = b.x;\n        id = 2.;\n        uvw = ro + rd * mint;\n        outn = boxNormal(uvw, p, q);\n        uvw = (uvw - p) / (q - p) * 2. - 1.;\n    }\n\n    float a = 3.9;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));   \n\n    ro.xz *= m;\n    rd.xz *= m;\n\n    ro.xy *= m;\n    rd.xy *= m;\n\n    ro.yz *= m;\n    rd.yz *= m;\n\n    p = vec3(-.26), q = vec3(.26);\n    b = box(ro, rd, p, q);\n\n    // Third box test\n    if(b.x > 0. && b.x < b.y && b.x < mint)\n    {\n        mint = b.x;\n        id = 3.;\n        vec3 rp = ro + rd * mint;\n        outn = (rp - (p + q) / 2.) / (q - p);\n        outn = normalize(pow(abs(outn), vec3(32)) * sign(outn));      \n\n        m = transpose(m);\n        outn.yz *= m;\n        outn.xy *= m;\n        outn.xz *= m;\n    }\n\n    return vec2(mint, id);\n}\n\n// Ray intersection test with scene. Tests for any intersection.\n// Doesn't test against first box, because it's inverted and encloses the whole scene.\nbool traceSceneShadow(vec3 ro, vec3 rd)\n{\n    vec3 p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);\n    vec2 b = box(ro, rd, p,q);\n\n    if(b.x > 0. && b.x < b.y)\n    {\n        return false;\n    }\n\n    float a = 3.9;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));   \n\n    ro.xz *= m;\n    rd.xz *= m;\n\n    ro.xy *= m;\n    rd.xy *= m;\n\n    ro.yz *= m;\n    rd.yz *= m;\n\n    p = vec3(-.26), q = vec3(.26);\n    b = box(ro, rd, p, q);\n\n    if(b.x > 0. && b.x < b.y)\n    {\n        return false;\n    }\n\n    return true;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// Light properties\nvec3 lo = vec3(.7, .8, .1), ls = vec3(1, 0, 0) * .2, lt = vec3(0, 0, 1) * .2;\nfloat lightRadiance = 18.0;\n\nuvec2 rstate;\n\n// Tiny Encryption Algorithm for random numbers: \nuvec2 encrypt(uvec2 v)\n{\n    uint k[4], sum = 0U, delta = 0x9e3779b9U;\n    k[0] = 0xA341316CU;\n    k[1] = 0xC8013EA4U;\n    k[2] = 0xAD90777DU;\n    k[3] = 0x7E95761EU;\n    for(uint i = 0U; i < 4U; ++i)\n    {\n        sum += delta;\n        v.x += ((v.y << 4) + k[0]) ^ (v.y + sum) ^ ((v.y >> 5) + k[1]);\n        v.y += ((v.x << 4) + k[2]) ^ (v.x + sum) ^ ((v.x >> 5) + k[3]);\n    }\n\n    return v;\n}\n\nfloat rand()\n{\n    rstate = encrypt(rstate);\n    return float(rstate.x & 0xfffffU) / float(1U << 20U);\n}\n\n// Sample the lightsources directly, including shadowing.\nvec2 sampleLight(vec3 rp, vec3 n)\n{\n    vec2 energy = vec2(0);\n    vec3 lightdir = normalize(normalize(vec3(.2, 4., 1.)) +\n                              (vec3(rand(), rand(), rand()) * 2. - 1.) * .015);\n    vec3 n2, uvw;\n    float t = traceScene(rp, lightdir, n2, uvw).x;\n\n    vec3 lrp = rp + lightdir * t;\n\n    // Directional 'sky' lighting.\n    if((lrp.y > .999 && abs(lrp.x- -.3) < .6 && abs(lrp.z - .1) < .8))\n        energy += vec2(1.5, .8).yx * max(0., dot(n, lightdir)) * 2.;\n\n    vec3 lo = vec3(.7, .8, .1), ls = vec3(1, 0, 0) * .2, lt = vec3(0, 0, 1) * .2;\n    vec3 ln = normalize(cross(ls, lt));\n    \n    int light_sample_count = 2;\n    \n    // Parallelogram local lightsource.\n    for(int j = 0; j < light_sample_count; ++j)\n    {\n        float lu = rand() * 2. - 1., lv = rand() * 2. - 1.;\n        vec3 lp = lo + ls * lu + lt * lv, n2;\n        float ld = dot(normalize(lp - rp), n), ld2 = dot(normalize(rp - lp), ln);\n        if(ld > 0. && ld2 > 0. && traceSceneShadow(rp + n * 1e-4, lp - rp))\n            energy += vec2(1.5, .5) *\n            \t(1. / dot(rp - lp, rp - lp) * ld * ld2) / float(light_sample_count);\n    }\n\n    return energy;\n}\n\n// Sample the illumunation at a given position, in a given direction.\nvec2 sampleRay(vec3 ro, vec3 rd)\n{\n    vec2 energy = vec2(0);\n    vec2 spectrum = vec2(1.);\n\n    vec3 ln = normalize(cross(ls, lt));\n    float lightArea = length(ls) * length(lt);\n\n    for(int i = 0; i < 3; ++i)\n    {\n        vec3 n, p0, p1, uvw;\n        vec2 res = traceScene(ro, rd, n, uvw);\n        vec3 rp = ro + rd * res.x;\n        \n        if(res.x < 0. || res.x > 1e3)\n            break;\n        \n        vec3 lrd = lambertNoTangent(n, vec2(rand(), rand()));\n        \n        if(res.y < .5)\n        {\n            // No intersection.\n            break;\n        }\n        else if(res.y < 1.5)\n        {\n            // Diffuse box 1.\n            if(rp.y > .999)\n                spectrum *= .5;\n            else\n                spectrum *= mats;\n            ro = rp + n * 1e-4;\n            rd = lrd;\n        }\n        else if(res.y < 2.5)\n        {\n            // Diffuse box 2.\n            spectrum *= mats.yx;\n            ro = rp + n * 1e-4;\n            rd = lrd;\n        }\n        else if(res.y < 3.5)\n        {\n            // Mirror box.\n            spectrum *= .9;\n            ro = rp + n * 1e-4;\n            rd = reflect(rd, n);\n        }\n        \n        \n        if(res.y < 2.5)\n        {\n            // For diffuse materials, sample lights directly.\n            energy += spectrum * sampleLight(rp, n) * lightRadiance * lightArea;\n        }\n        else\n        {\n            // Test for intersection with the parallelogram lightsource.\n            float t = dot(lo - ro, ln) / dot(rd, ln);\n            if(t > 0.)\n            {\n                vec3 rp = ro + rd * t;\n                vec2 uv = vec2(dot(rp - lo, ls) / dot(ls, ls), dot(rp - lo, lt) / dot(lt, lt));\n                if(abs(uv.x) < 1. && abs(uv.y) < 1.)\n                {\n                    energy += spectrum * lightRadiance;\n                }\n            }\n        }\n    }\n    return energy;\n}\n\nvec2 sampleScene(vec3 p, vec3 n)\n{\n    vec2 energy = vec2(0);\n\n    vec3 ln = normalize(cross(ls, lt));\n    float lightArea = length(ls) * length(lt);\n    int count = 1;\n    for(int i = 0; i < count; ++i)\n    {\n        vec3 ro = p + n * 1e-4;\n        vec3 rd = lambertNoTangent(n, vec2(rand(), rand()));\n\n        energy += sampleRay(ro, rd);\n        energy += sampleLight(ro, n) * lightRadiance * lightArea;\n    }\n\n    energy /= float(count);\n    return energy;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    rstate = uvec2(fragCoord.xy) + uint(iFrame) / 6U * 4096U;\n\n    // Project ray direction on to the unit cube.\n    vec3 absRayDir = abs(rayDir);\n    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));\n\n    // Get the index of the current face being rendered.\n    int faceIndex = 0;\n\n    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)\n    {\n        faceIndex = 2;\n    }\n    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)\n    {\n        faceIndex = 4;\n    }\n\n    if(rayDir[faceIndex / 2] > 0.)\n        faceIndex |= 1;\n\n    // Sample previous result.\n    fragColor = textureLod(iChannel0, rayDir,0.);\n\n    // Skip this face if it's not the one chosen for this frame.\n    if(faceIndex != (iFrame % 6))\n        return;\n\n    // Render for only one of the boxes per frame, as an extra speedup.\n    if((iFrame / 12 & 1) == 0)\n    {\n        vec3 p = vec3(-1), q = vec3(1);\n        vec3 samplePoint = (p + q) / 2. + (q - p) * rayDir / 2.;\n        vec3 sampleNormal = boxNormal(samplePoint, p, q);\n        fragColor.rg += sampleScene(samplePoint, -sampleNormal);\n    }\n    else\n    {\n        vec3 p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);\n        vec3 samplePoint = (p + q) / 2. + (q - p) * rayDir / 2.;\n        vec3 sampleNormal = boxNormal(samplePoint, p, q);\n        fragColor.ba += sampleScene(samplePoint, sampleNormal);\n    }\n\n}","name":"Cube A","description":"","type":"cubemap"}]}