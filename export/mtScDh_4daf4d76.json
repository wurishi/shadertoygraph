{"ver":"0.1","info":{"id":"mtScDh","date":"1691744602","viewed":77,"name":"RenderingLTree","username":"Lemlog","description":"Almost L-system, but F replaced by rule only during rendering. In future planning to improve it, so it will be exactly L-system.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["lsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define cF 0\n#define cPlus 1\n#define cMinus 2\n#define cOpen 3\n#define cClose 4\n#define cG 5\n#define cEND -1\n\n#define PI 3.14159\n#define vec_forward vec2(1.0, 0.0)\n\n#define REC_DEPTH 4\n#define RULE_LIMIT 32\n#define BRACKETS_DEPTH 8\n#define BUFF_SIZE 512\n\nfloat BUG = 1.0;\n\n// Math\n\nmat3 Rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return  mat3(vec3(c, s, 0),\n                 vec3(-s, c, 0),\n                 vec3(0, 0, 1)); \n}\n\nmat3 Move(vec2 move)\n{\n    return  mat3(vec3(1, 0, 0),\n                 vec3(0, 1, 0),\n                 vec3(move, 1));\n}\n\nmat3 RotAround(float angle, vec2 point)\n{\n    mat3 m = Move(-point);\n    m = Rot(angle) * m;\n    m = Move(point) * m;\n    return m;\n}\n\n// Basic draw\n\n// for horizontal line\nfloat line_dist(vec2 p, float left, float right)\n{\n    if (p.x < left) return length(p - vec2(left, 0.0));\n    else if (p.x > right) return length(p - vec2(right, 0.0));\n    return abs(p.y);\n}\n\n// for horizontal line\nfloat line_draw(vec2 uv, float left, float right, float width)\n{\n    float d = line_dist(uv, left, right);\n    return smoothstep(0.0, width, d);\n}\n\nfloat line_dist(vec2 p, vec2 a, vec2 b)\n{\n    if (dot(p-a, b-a) < 0.0) return length(p - a);\n    if (dot(p-b, a-b) < 0.0) return length(p - b);\n    vec2 co = dot(p-a, b-a)/(length(b-a) * length(b-a)) * (b-a);\n    return length(a - p + co);\n}\n\nfloat line_draw(vec2 uv, vec2 from, vec2 to, float width)\n{\n    float d = line_dist(uv, from, to);\n    return smoothstep(0.0, width, d);\n}\n\nvec2 rotate(vec2 v, float angle)\n{\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * v;\n}\n\nvec2 rotate_around(vec2 v, float angle, vec2 point)\n{\n    return (RotAround(angle, point) * vec3(v,1.0)).xy;\n}\n\n// Basic structs\n\nstruct Transform\n{\n    float rotation;\n    vec2 position;\n};\n\nstruct LTree\n{\n    Transform root;\n    \n    float branch_len;\n    float branch_width;\n    float angle;\n    float scale;\n    \n    int[RULE_LIMIT] rule;\n};\n\n// uv transforms\n\nvec2 uv_real(vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvec2 uv_texture(vec2 uv)\n{\n    uv.x *= iResolution.y / iResolution.x;\n    uv = (uv + 1.0) / 2.0;\n    return uv;\n}\n\n// Tree drawing\n\nvec2 forward_step(vec2 position, float rotation, float step_len)\n{\n    vec2 forward = vec_forward;\n    forward = rotate(forward, rotation) * step_len;\n    return position + forward;\n}\n\nfloat from_prev_tree(vec2 uv, vec2 position, float rotation, LTree tree)\n{\n    vec3 v = vec3(uv, 1.0);\n    v = Move(-position) * v;\n    v = Rot(-rotation) * v;\n    \n    v.xy *= tree.scale;\n    \n    v = Rot(tree.root.rotation) * v;\n    v = Move(tree.root.position) * v;\n    \n    // adding is for self-clear\n    return texture(iChannel0, uv_texture(v.xy)).y + 0.01;\n}\n\nfloat[BRACKETS_DEPTH] rot_buffer;\nvec2[BRACKETS_DEPTH] pos_buffer;\nfloat subtree_draw(vec2 uv, LTree tree)\n{\n    vec2 position = tree.root.position;\n    float rotation = tree.root.rotation;\n    int rec_bracket = 0;\n        \n    float d = 10.0;\n    for (int i = 0; i < RULE_LIMIT; ++i)\n    {   \n        int symbol = tree.rule[i];\n        \n        if (symbol == cEND)\n        {\n            break;\n        }\n        \n        // recurrent\n        \n        if (symbol == cF)\n        {\n            d = min(d, from_prev_tree(uv, position, rotation, tree));\n        }\n        \n        // brackets\n        \n        if (symbol == cOpen)\n        {\n            rot_buffer[rec_bracket] = rotation;\n            pos_buffer[rec_bracket] = position;\n            rec_bracket += 1;\n            continue;\n        }\n        else if (symbol == cClose)\n        {\n            rec_bracket -= 1;\n            rotation = rot_buffer[rec_bracket];\n            position = pos_buffer[rec_bracket];\n            continue;\n        }\n        \n        // next move\n\n        if ((symbol == cF) || (symbol == cG))\n        {\n            vec3 v = vec3(uv, 1.0);\n            v = Move(-position) * v;\n            v = Rot(-rotation) * v;\n        \n            vec2 next_pos = forward_step(position, rotation, \n                                    tree.branch_len);\n            if (symbol != cF)\n                d = min(d, line_draw(v.xy, 0.0, tree.branch_len, \n                    tree.branch_width));\n            position = next_pos;\n        }\n        else if (symbol == cPlus)\n        {\n            rotation += tree.angle;\n        }\n        else if (symbol == cMinus)\n        {\n            rotation -= tree.angle;\n        }\n    }\n    \n    return d;\n}\n\nfloat tree_draw(vec2 uv, LTree tree, int[RULE_LIMIT] rule)\n{\n    tree.rule = rule;\n    float d = subtree_draw(uv, tree);\n    \n    return d;\n}\n\n// rules for trees\n\nvoid init_trio_rule(out int[RULE_LIMIT] f_rule)\n{    \n    f_rule[0] = cG;\n    f_rule[1] = cOpen;\n    f_rule[2] = cMinus;\n    f_rule[3] = cF;\n    f_rule[4] = cClose;\n    f_rule[5] = cOpen;\n    f_rule[6] = cPlus;\n    f_rule[7] = cF;\n    f_rule[8] = cClose;\n    f_rule[9] = cF;\n    f_rule[10] = cEND;\n}\n\nvoid init_rule(out int[RULE_LIMIT] f_rule)\n{\n    const int SIZE = 15;\n    int temp[SIZE] = int[SIZE](\n                cG, cOpen, cMinus, cF, cClose, cOpen, cPlus,\n                cG, cOpen, cPlus, cF, cClose, cF, cClose, cEND);           \n    for (int i = 0; i < SIZE; ++i)\n    {\n        f_rule[i] = temp[i];\n    }\n}\n\nvoid init_fir(out int[RULE_LIMIT] f_rule)\n{\n    const int SIZE = 13;\n    int temp[SIZE] = int[SIZE](\n                cG, cOpen, cMinus, cF, cClose, cG, cOpen, cPlus,\n                cF, cClose, cG, cF, cEND);           \n    for (int i = 0; i < SIZE; ++i)\n    {\n        f_rule[i] = temp[i];\n    }\n}\n\n\nvoid init_other(out int[RULE_LIMIT] f_rule)\n{\n    const int SIZE = 17;\n    int temp[SIZE] = int[SIZE](\n                cG, cOpen, cPlus, cPlus, cF, cClose, cMinus, cG, cMinus, \n                cOpen, cPlus, cF, cClose, cG, cMinus, cF, cEND);           \n    for (int i = 0; i < SIZE; ++i)\n    {\n        f_rule[i] = temp[i];\n    }\n}\n\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv_real(uv);\n    \n    Transform root;\n    root.position = vec2(-0.4, -0.9);\n    root.rotation = PI /2.2;\n    \n    float branch_len = 0.4;\n    float branch_width = 0.005;\n    float angle = PI /10.0 + (iMouse.x / iResolution.x * 0.15);;\n    float scale = 1.6 + (iMouse.y / iResolution.y * 0.5);\n    \n    int[RULE_LIMIT] rule;\n    init_other(rule);\n    \n    LTree tree = LTree(root, \n        branch_len, branch_width, angle, scale,\n        rule);\n    \n    float d = tree_draw(uv, tree, rule);\n    vec3 col = vec3(d);\n    \n    if (iTime <= 0.03)\n        fragColor = vec4(1.0);\n    else\n        fragColor = vec4(col*BUG,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}