{"ver":"0.1","info":{"id":"wtXczf","date":"1592608404","viewed":158,"name":"fractional part patterns","username":"wj","description":"the answer is probably 42","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","moirepatterns"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fractional part patterns\n// by wj\n//\n// Just the result of a quick experiment that I did out of curiosity.. \n// and indeed there are pretty patterns.\n//\n// The shader multiplies the screen coordinates (since used \n// number range is -1 to 1 I'd rather call it a division)\n// and then shows what the fractional parts of the resulting \n// numbers look like, 1, 2, 3, 4, 5 (etc) positions after the \n// decimal point (discarding the more significant parts of the\n// number and \"shifting\" those smaller parts \"up to the \n// decimal point\").\n//\n// what might be the meaning of this?\n// \n//\n// PS: I meanwhile fixed the flawed oversampling impl (thx to\n// FabriceNeyret2 who spotted the bug with a keen eye). The below\n// \"defines\" allow to switch between my originally intended \n// experiment (default) and what I had first released \n// (disable DECIMAL_DIGITS_ONLY). \n// Ramping up the OVERSAMPLE rate will eliminate most of the\n// Moir√© patterns and sadly blur them into a dull grey.\n// The ZOOM mode reduces the shown area while less significant\n// parts of the number are used - to show what the blurred areas\n// look like under a microscope. The WIGGLE mode shows the effect\n// that a minimal shift of the sampled location affects the \n// result (use without OVERSAMPLE).\n\n#define DECIMAL_DIGITS_ONLY\n#define OVERSAMPLE 1 \t\t\t// e.g. try 32\n//#define ZOOM\n//#define WIGGLE\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 r= iResolution.xy;\n    vec2 uv= (fragCoord/r - .5)*2.;\t// use -1 to 1 range\n\n#ifdef  WIGGLE\n    float magnify= 1000.;\n    uv+= vec2(.00005)*sin(iTime*10.);\n#else\n#ifdef DECIMAL_DIGITS_ONLY\n    // this is what I had originally set out to investigate\n    // (at some point the available precision of \"float\"\n    // numbers is reached and the image turns black)\n    \n    float magnify = pow(10., round( (sin(iTime*.6)+1.) *4.5) );\t// 9 places max\n#else\n    // turns out the above effect stays the same even when \n    // fractional powers of 10 are used (same as removing \"round\"\n    // above and reducing the used range to compensate for \n    // slower animation)\n    \n    float magnify = 1.+(sin(iTime*.1)+1.)*5000.;\n#endif\n#endif\n    \n#ifdef ZOOM\n    // patterns repeat on progressively smaller scales.. \n    // zoom in to keep up with the smaller structures\n    \n    float zoom= log2(magnify)/log2(10.);\n    r*= zoom;\n    \n    // translate someplace more interesting than the center\n    vec2 o= vec2(0.33, 0.66);\t\n    uv+= o;\n    uv/= zoom;\t\n    uv-=o;\n#endif\n    \n    int os= max(1, OVERSAMPLE);\n    float s = float(os);\n    \n    float sum= 0.;\n    for (int i=0; i< os*os ; i++) {\n        vec2 coord = uv + (( vec2(i%os, i/os)+(.5-.5*s) )/s)/r;\n        \n        // must apply \"fract\" here since more significant digits \n        // might otherwise be pulled back in when dividing the sum\n        sum += fract(coord.x*coord.y*magnify);\n        \n        // as FabriceNeyret2 pointed out, the effect does not\n        // depend on the discontinuity of \"fract\" but can similarily \n        // be created by something like the below \n\t\t// (however the progressively smaller \"crosses\" that seem to \n        // divide the surface - e.g. in 2, 3, 4, 5, etc) actually \n        // seem to the effect of my use of \"fract\")\n//        sum += .5+.5*sin(6.28*coord.x*coord.y*magnify);\n        \n    }\n    \n\tfragColor=  vec4(sum/(s*s));\n}\n","name":"Image","description":"","type":"image"}]}