{"ver":"0.1","info":{"id":"Mt3BWM","date":"1539852888","viewed":134,"name":"Short RGB Perlin","username":"dust","description":"A short, quick 2D perlin noise implementation. Some funky UV transformations to coax out a pattern instead of blurry randomness.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","noise","perlinnoise","perlin","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Adjustable palette tones\n#define PALETTE_TONE_A vec3(0.25f, 0.5f, 1.0f)\n#define PALETTE_TONE_B vec3(1.0f)\n\n// Vector implementation of the ease-in ease-out function from [robjohn]'s \n// answer here:\n// https://math.stackexchange.com/questions/121720/ease-in-out-function\nvec2 soften(vec2 nn,\n            vec2 alpha)\n{\n    vec2 nnExp = pow(nn, alpha);\n    return nnExp / (nnExp + pow(vec2(1.0f) - nn, alpha));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Four-way mirroring\n    uv = abs(uv - vec2(0.5f));\n    \n    // Find cell offset\n    const float cellSize = 0.2f;\n    vec2 skewTex = texture(iChannel0, uv).xy;\n    if (iTime > 3.12f) { skewTex *= texture(iChannel1, uv).xy; }\n    vec2 uvSkew = skewTex * (abs(sin(iTime)) + 0.4f * (sin(iTime) + 0.5f));\n    vec2 offs = mod(uv * uvSkew * 0.2f, cellSize);\n    \n    // Cache cell origin\n    vec2 ori = uv - offs;\n    \n    // Cache upper-right cell\n    vec2 upr = ori + (vec2(1.0f) / iResolution.xy);\n    \n    // Cache adjacent cells\n    vec4 adj = vec4(ori.x, upr.y,\n                    ori.y, upr.x);\n    \n    // Sample nearby directions\n    mat4x2 dirs = mat4x2(texture(iChannel0, ori).rg,\n                         texture(iChannel0, adj.xy).rg,\n                         texture(iChannel0, adj.zw).rg,\n                         texture(iChannel0, upr).rg);\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Evaluate nearby values\n    vec4 values = vec4(dot(dirs[0], offs),\n                       dot(dirs[2], offs - vec2(0.0f, 1.0f)),\n                       dot(dirs[1], offs - vec2(1.0f, 0.0f)),\n                       dot(dirs[3], offs - vec2(1.0f)));\n    \n    // Smoothly interpolate values, then cache\n    vec2 softXY = soften(offs, offs);\n    float sel = mix(mix(values[0], \n                        values[1], softXY.x), \n                    mix(values[2], \n                        values[3], softXY.x),\n                    softXY.y);\n    \n    // Use interpolated values to blend between palette colors\n    vec3 rgb = mix(PALETTE_TONE_A,\n                   PALETTE_TONE_B,\n                   sel);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}