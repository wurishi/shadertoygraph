{"ver":"0.1","info":{"id":"dtGBWt","date":"1702622246","viewed":47,"name":"Menger Sponge, 3D Carpet","username":"noahsk","description":"By Pedro Schneider. This shader targets to achieve a mathematical render of Menger's Sponge, a generalization to higher dimensions of Sierpinski's Carpet.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","cube","glsl","menger","sponge","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n*\n*\n*\n*     Uploaded by Noah Kahn on December 15th 2023\n*     All credits to the author below.\n*     Hosted here as the author left the ShaderToy link blank\n*     and it should to be seen by more.\n*\n*\n* /\n\n/**\n * Direct Link: https://github.com/pedrotrschneider/shader-fractals/tree/main/3D\n *\n * @file MengerSponge.glsl\n *\n * @brief This shader targets to achieve a mathematical render of Menger's Sponge, a generalization to higher\n * dimensions of Sierpinski's Carpet.\n *\n * @author Pedro Schneider <pedrotrschneider@gmail.com>\n *\n * @date 06/2020\n *\n * Direct link to ShaderToy: [self]\n*/\n\n#define MaximumRaySteps 100\n#define MaximumDistance 1000.\n#define MinimumDistance .01\n#define PI 3.141592653589793238\n\n// --------------------------------------------------------------------------------------------//\n// SDF FUNCTIONS //\n\n// Sphere\n// s: radius\nfloat SignedDistSphere (vec3 p, float s) {\n  return length (p) - s;\n}\n\n// Box\n// b: size of box in x/y/z\nfloat SignedDistBox (vec3 p, vec3 b) {\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0));\n}\n\n// (Infinite) Plane\n// n.xyz: normal of the plane (normalized)\n// n.w: offset from origin\nfloat SignedDistPlane (vec3 p, vec4 n) {\n  return dot (p, n.xyz) + n.w;\n}\n\n// Rounded box\n// r: radius of the rounded edges\nfloat SignedDistRoundBox (in vec3 p, in vec3 b, in float r) {\n  vec3 q = abs (p) - b;\n  return min (max (q.x, max (q.y, q.z)), 0.0) + length (max (q, 0.0)) - r;\n}\n\n// BOOLEAN OPERATORS //\n\n// Union\n// d1: signed distance to shape 1\n// d2: signed distance to shape 2\nfloat opU (float d1, float d2) {\n  return (d1 < d2) ? d1 : d2;\n}\n\n// Subtraction\n// d1: signed distance to shape 1\n// d2: signed distance to shape 2\nvec4 opS (vec4 d1, vec4 d2) {\n  return (-d1.w > d2.w) ? -d1 : d2;\n}\n\n// Intersection\n// d1: signed distance to shape 1\n// d2: signed distance to shape 2\nvec4 opI (vec4 d1, vec4 d2) {\n  return (d1.w > d2.w) ? d1 : d2;\n}\n\n// Mod Position Axis\nfloat pMod1 (inout float p, float size) {\n  float halfsize = size * 0.5;\n  float c = floor ((p + halfsize) / size);\n  p = mod (p + halfsize, size) - halfsize;\n  p = mod (-p + halfsize, size) - halfsize;\n  return c;\n}\n\n// SMOOTH BOOLEAN OPERATORS //\n\n// Smooth Union\n// d1: signed distance to shape 1\n// d2: signed distance to shape 2\n// k: smoothness value for the trasition\nfloat opUS (float d1, float d2, float k) {\n  float h = clamp (0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  float dist = mix (d2, d1, h) - k * h * (1.0 - h);\n\n  return dist;\n}\n\n// Smooth Subtraction\n// d1: signed distance to shape 1\n// d2: signed distance to shape 2\n// k: smoothness value for the trasition\nvec4 opSS (vec4 d1, vec4 d2, float k) {\n  float h = clamp (0.5 - 0.5 * (d2.w + d1.w) / k, 0.0, 1.0);\n  float dist = mix (d2.w, -d1.w, h) + k * h * (1.0 - h);\n  vec3 color = mix (d2.rgb, d1.rgb, h);\n\n  return vec4 (color.rgb, dist);\n}\n\n// Smooth Intersection\n// d1: signed distance to shape 1\n// d2: signed distance to shape 2\n// k: smoothness value for the trasition\nvec4 opIS (vec4 d1, vec4 d2, float k) {\n  float h = clamp (0.5 - 0.5 * (d2.w - d1.w) / k, 0.0, 1.0);\n  float dist = mix (d2.w, d1.w, h) + k * h * (1.0 - h);\n  vec3 color = mix (d2.rgb, d1.rgb, h);\n\n  return vec4 (color.rgb, dist);\n}\n\n// TRANSFORM FUNCTIONS //\n\nmat2 Rotate (float angle) {\n  float s = sin (angle);\n  float c = cos (angle);\n\n  return mat2 (c, -s, s, c);\n}\n\nvec3 R (vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize (l - p),\n    r = normalize (cross (vec3 (0, 1, 0), f)),\n    u = cross (f, r),\n    c = p + f * z,\n    i = c + uv.x * r + uv.y * u,\n    d = normalize (i - p);\n  return d;\n}\n\n// --------------------------------------------------------------------------------------------//\nvec3 hsv2rgb (vec3 c) {\n  vec4 K = vec4 (1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs (fract (c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix (K.xxx, clamp (p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map (float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sierpinski3 (vec3 z) {\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  float iterations = 25.0;\n  float Scale = 2.0 + (sin (iTime / 2.0) + 1.0);\n  vec3 Offset = 3.0 * vec3 (1.0, 1.0, 1.0);\n  float bailout = 1000.0;\n\n  float r = length (z);\n  int n = 0;\n  while (n < int (iterations) && r < bailout) {\n\n    z.x = abs (z.x);\n    z.y = abs (z.y);\n    z.z = abs (z.z);\n\n    if (z.x - z.y < 0.0) z.xy = z.yx; // fold 1\n    if (z.x - z.z < 0.0) z.xz = z.zx; // fold 2\n    if (z.y - z.z < 0.0) z.zy = z.yz; // fold 3\n\n    z.x = z.x * Scale - Offset.x * (Scale - 1.0);\n    z.y = z.y * Scale - Offset.y * (Scale - 1.0);\n    z.z = z.z * Scale;\n\n    if (z.z > 0.5 * Offset.z * (Scale - 1.0)) {\n      z.z -= Offset.z * (Scale - 1.0);\n    }\n\n    r = length (z);\n\n    n++;\n  }\n\n  return (length (z) - 2.0) * pow (Scale, -float (n));\n}\n\n// Calculates de distance from a position p to the scene\nfloat DistanceEstimator (vec3 p) {\n  p.yz *= Rotate (0.2 * PI);\n  p.yx *= Rotate (0.3 * PI);\n  p.xz *= Rotate (0.29 * PI);\n  float sierpinski = sierpinski3 (p);\n  return sierpinski;\n}\n\n// Marches the ray in the scene\nvec4 RayMarcher (vec3 ro, vec3 rd) {\n  float steps = 0.0;\n  float totalDistance = 0.0;\n  float minDistToScene = 100.0;\n  vec3 minDistToScenePos = ro;\n  float minDistToOrigin = 100.0;\n  vec3 minDistToOriginPos = ro;\n  vec4 col = vec4 (0.0, 0.0, 0.0, 1.0);\n  vec3 curPos = ro;\n  bool hit = false;\n  vec3 p = vec3 (0.0);\n\n  for (steps = 0.0; steps < float (MaximumRaySteps); steps++) {\n    p = ro + totalDistance * rd; // Current position of the ray\n    float distance = DistanceEstimator (p); // Distance from the current position to the scene\n    curPos = ro + rd * totalDistance;\n    if (minDistToScene > distance) {\n      minDistToScene = distance;\n      minDistToScenePos = curPos;\n    }\n    if (minDistToOrigin > length (curPos)) {\n      minDistToOrigin = length (curPos);\n      minDistToOriginPos = curPos;\n    }\n    totalDistance += distance; // Increases the total distance armched\n    if (distance < MinimumDistance) {\n      hit = true;\n      break; // If the ray marched more than the max steps or the max distance, breake out\n    }\n    else if (distance > MaximumDistance) {\n      break;\n    }\n  }\n\n  float iterations = float (steps) + log (log (MaximumDistance)) / log (2.0) - log (log (dot (curPos, curPos))) / log (2.0);\n\n  if (minDistToScene > MinimumDistance) {\n\n  }\n\n  if (hit) {\n    col.rgb = vec3 (0.8 + (length (curPos) / 8.0), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n\n  }\n  else {\n    col.rgb = vec3 (0.8 + (length (minDistToScenePos) / 8.0), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n    col.rgb *= 1.0 / pow (minDistToScene, 1.0);\n    col.rgb /= 15.0 * map (sin (iTime * 3.0), -1.0, 1.0, 1.0, 3.0);\n  }\n  col.rgb /= iterations / 10.0; // Ambeint occlusion\n  col.rgb /= pow (distance (ro, minDistToScenePos), 2.0);\n  col.rgb *= 2000.0;\n\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  uv *= 0.2;\n  uv.y -= 0.015;\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  vec3 ro = vec3 (-40, 30.1, -10); // Ray origin\n  //ro.yz *= Rotate (-m.y * 2.0 * PI + PI - 1.1); // Rotate thew ray with the mouse rotation\n  ro.xz *= Rotate (-iTime * 2.0 * PI / 20.0);\n  vec3 rd = R (uv, ro, vec3 (0, 1, 0), 1.); // Ray direction (based on mouse rotation)\n\n  vec4 col = RayMarcher (ro, rd);\n\n  // Output to screen\n  fragColor = vec4 (col);\n}","name":"Image","description":"","type":"image"}]}