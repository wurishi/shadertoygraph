{"ver":"0.1","info":{"id":"wllXRl","date":"1568689293","viewed":168,"name":"RayTracing Demo","username":"lost1996","description":"begin with a easy raytracing demo","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct Plane\n{\n    vec3 normal;\n    float height;\n    vec3 color;\n};\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n\n// 光线和球体计算交点\nfloat Intersect(Ray ray,Sphere sphere)\n{\n    vec3 v = ray.origin - sphere.position;\n    //b^2-4ac\n    float a = dot(ray.direction,ray.direction);\n    float b = dot(ray.direction,v);\n    float c = dot(v,v) - sphere.radius * sphere.radius;\n    float value = b*b-a*c;\n    if(value < 0.)\n        return -1.;\n    if(value == 0.)\n        return - b/a;\n    float sqrtValue = sqrt(value);\n    float result = -b - sqrtValue;\n    if(result > 0.)\n        return result/a;\n    return -1.;\n}\n\n// 光线和地面计算交点\nfloat Intersect(Ray ray,Plane plane)\n{\n    float LDotN = dot(ray.direction,plane.normal);\n    if(LDotN > 0.)\n        return -1.;\n    return (plane.height - ray.origin.y)/ray.direction.y;\n}\n\nvec3 rotate(vec3 origin,vec3 target)\n{\n\tfloat degree = iTime-1.;\n\n    vec3 relate = origin - target;\n\tfloat x = relate.x * cos(degree) + relate.z * sin(degree) + target.x;\n\tfloat z = -relate.x * sin(degree) + relate.z * cos(degree) + target.z;\n\n\treturn vec3(x,origin.y,z);\n}\n\nvec3 radiance(Ray ray)\n{\n    Sphere spheres[3];\n    spheres[0] = Sphere(vec3(0.0,3.0+(sin(iTime)+1.)*3.,10.0),3.0,vec3(1.0,0.0,0.0));\n    spheres[1] = Sphere(vec3(-2.0-sin(iTime)*3.,3.0,0.0),3.0,vec3(0.0,1.0,0.0));\n    spheres[2] = Sphere(rotate(vec3(0.0,3.0,7.0),vec3(-2.0,3.0,0.0)),3.0,vec3(0.0,0.0,1.0));\n    \n\n    Plane plane = Plane(vec3(0.0,1.0,0.0),0.0,vec3(0.8,0.5,0.));\n    vec3 skyColor = vec3(0.,0.,0.8);\n    vec3 cameraPos = ray.origin;\n\n    vec3 result = vec3(0.,0.,0.);\n    float intensity = 1.0;\n    for(int ti = 0;ti<1000;++ti)\n    {\n        vec3 L = ray.direction;\n        int sIndex = -1;\n        float t = -1.;\n        for(int i=0;i<3;++i)\n        {\n            float tt = Intersect(ray,spheres[i]);\n            if(tt > 0. && (tt < t || t < 0.))\n            {\n                sIndex = i;\n                t = tt;\n            }\n        }\n\n        float tt = Intersect(ray,plane);\n\n        if(t<=0.)\n        {\n            if(tt > 0.)\n            {\n                vec3 pos = ray.origin + tt * ray.direction;\n                vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = plane.normal;\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V, plane.color)*intensity; //地板色\n            }\n            else\n            {\n                result += skyColor*intensity;//天空色\n                break;\n            }\n        }\n        else\n        {\n            if(t < tt || tt <= 0.)\n            {\n                vec3 pos = ray.origin + t * ray.direction;\n                 vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = normalize(pos - spheres[sIndex].position);\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V,spheres[sIndex].color)*intensity;\n            }\n            else\n            {\n                vec3 pos = ray.origin + tt * ray.direction;\n                vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = plane.normal;\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V,plane.color)*intensity; //地板色\n            }\n        }\n\n        intensity /= 2.;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5));\n    uv.x *= (iResolution.x/iResolution.y);\n    vec3 cameraPos = vec3(20.,5.,0.);\n    Ray ray = Ray(cameraPos,normalize(vec3(-1.,uv.y,uv.x)));\n\n    fragColor = vec4(radiance(ray),1.0);\n}","name":"Image","description":"","type":"image"}]}