{"ver":"0.1","info":{"id":"lsyyRV","date":"1524113043","viewed":255,"name":"Diffusion Paint-3 GLITCH","username":"cubby208","description":"Click the screen","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["diffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Diffusion Paint-3 Thicker\" by cubby208. https://shadertoy.com/view/XdVyzy\n// 2018-04-01 15:18:48\n\n// Fork of \"Diffusion Paint-2\" by cubby208. https://shadertoy.com/view/lsGyWw\n// 2018-03-31 07:21:07\n\n// Fork of \"Diffusion Paint\" by cubby208. https://shadertoy.com/view/XdGyWR\n// 2018-03-27 21:50:57\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    //fragColor = vec4(vec3(color.a), 1.0);\n    fragColor = color;\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n//Really a crappy function we only pay attention to the alpha (a/w) value. \n//This is how much is overflowing from the cell\nfloat lerp(float v1, float v2, float value) {\n \t//return a + f * (b - a);\n    //t = t*t*t * (t * (6f*t - 15f) + 10f)\n    //float value2 = smoothstep(0.0, 1.0, value);\n    float value2 = value;\n    return v1 + value2 * (v2 - v1);\n}\nvec3 lerp(vec3 v1, vec3 v2, float value) {\n \treturn vec3(lerp(v1.x, v2.x, value),lerp(v1.y, v2.y, value),lerp(v1.z, v2.z, value));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Some basic coordinate math\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.y;\n    \n    //Last stores if the last mouse state was down so we only pain blobs once\n    float last = texture(iChannel0, vec2(1.0) / iResolution.xy).y; \n    float resc = texture(iChannel0, vec2(1.0) / iResolution.xy).x; \n    \n    \n    //Mouse is down (and we can draw) so do so\n    if ( iMouse.z > 0.01 && last > 0.1) {\n        //Drawing code vvvvvvv\n        \n        //Draw on the simulation if it is within distance\n        fragColor = texture(iChannel0, uv);\n        vec2 uv2 = fragCoord.xy / iResolution.y;\n        //uv2.x -= 0.5;\n        float dist = length(iMouse.xy - fragCoord.xy);\n        if (dist < 40.0) {\n            \n            //We use the formula from the default shader emitting the 'uv' portion\n            vec3 target = 0.5 + 0.5*cos(iTime*2.0+vec3(0,2,4));\n            vec3 targetCol = target;\n            \n            \n            fragColor.xyz = sqrt(mix(fragColor.xyz * fragColor.xyz, targetCol * targetCol, 0.8));\n            \n            //The pixel is 0now fully wet with the pain\n        \tfragColor.w = 10.0;\n        }\n    } else {\n  \t\t//Simulation step\n\n        //Scalar is used to \n        vec2 scalar = 3.0 * vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\n        //Get the color of the cells in all directions\n        vec4 col = texture(iChannel0, uv);\n        vec4 l = texture(iChannel0, uv + vec2(-1.0, 0.0) * scalar);\n        vec4 r = texture(iChannel0, uv + vec2(1.0, 0.0) * scalar);\n        vec4 u = texture(iChannel0, uv + vec2(0.0, 1.0) * scalar);\n        vec4 d = texture(iChannel0, uv + vec2(0.0, -1.0) * scalar);\n\n        \n        //Clamp the wetness as it spreads\n        float wetnessClamp = 20.0;\n        float il = clamp(l.a - col.a,0.0,wetnessClamp);\n        float ir = clamp(r.a - col.a,0.0,wetnessClamp);\n        float iu = clamp(u.a - col.a,0.0,0.5);\n        float id = clamp(d.a - col.a,0.0,wetnessClamp);\n\n        //Calculate the contribution of all the colors based on their wetness\n        float myContrib = (1.0-(il+id+ir+iu));\n        col.xyz = (il*l.xyz)+(ir*r.xyz)+(iu*u.xyz)+(id*d.xyz)+myContrib*col.rgb;\n\n        //Average all the surronding pigments\n        //vec4 avg = sqrt((l*l + d*d+r*r+u*u)*0.25);\n        vec4 avg = (l + d + r + u) * 0.25;\n\n        //Decide how much of our color mixes with the outside colors\n        float porous = min(1.0, min(0.5,(col.a+avg.a)*0.9)*3.0);\n        col.xyz = lerp(col.xyz,avg.xyz,porous*0.5);\n        col.w = lerp(col.w,avg.w,porous);\n\n        col.w /= 1.003;\n        \n        //Set the color on the texture\n        fragColor = col;\n    }\n    \n    //Clear the texture to white at the beginning\n    if (iFrame < 10) {\n     \tfragColor = vec4(vec3(1.0), 0.0);   \n    }\n    //Handle resize (in a very naiive way)\n    if ( abs((iResolution.x / 1000.0) - resc) > 0.0001) {\n        vec4 temp = texture(iChannel0, uv);\n        if (length(temp) < 0.1) {\n\t\t\tfragColor = vec4(vec3(1.0), 0.0);   \n        }\n    }\n    \n    \n    //this helps us keep track of the mouses last state\n    float set = 0.0;\n    if (iMouse.z > 0.01) {\n\t\tset = 0.0;\n    } else {\n     \tset = 1.0;\n    }\n    if (length(uv) < 0.01) {\n\t\tfragColor.y = set;\n        fragColor.x = iResolution.x / 1000.0;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}