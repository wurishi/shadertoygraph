{"ver":"0.1","info":{"id":"wdtSD7","date":"1572197768","viewed":77,"name":"Raymarched shadows","username":"JentGent","description":"Testing out shadows.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set float precision\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Output color\nvec3 c = vec3(1.0, 1.0, 1.0);\n\n// Distance estimators\nfloat deSphere(vec3 from, vec3 center, float radius) {\n\treturn length(center - from) - radius;\n} // Sphere\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n} // Torus\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n\treturn length(clamp(abs(center - from) - dimensions / 2.0, 0.0, 100000.0));\n} // Cuboid\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n} // Uncapped cylinder\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capped cylinder\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capsule\n\n// Find normal of a sphere\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\n// Rounded objects (WARNING: also increases object size!)\nfloat deRound(float pd, float radius) {\n\tfloat de = pd;\n\treturn de - radius;\n}\n\n// Booleans (union, subtraction, intersection)\nfloat boolUnion(float pd, float pd2) {\n\treturn min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n\treturn max(-pd, pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n\treturn max(pd, pd2);\n}\n\n// Smooth Booleans\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n\tfloat level = clamp(0.5 + (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n\treturn mix(pd, pd2, level) - smoothness * level * (1.0 - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2.0, 0.0, 1.0 );\n    return mix(pd2, -pd, level) + smoothness * level * (1.0 - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n    return mix(pd, pd2, level) + smoothness * level * (1.0 - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rotate(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot; // X rotation\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot; // Y rotation\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot; // Z rotation\n    inp += anchor;\n    return inp;\n}\n\n// Lights\nvec3 sun = vec3(-2.0, 1.0, -1.0);\n\n// Camera\nvec3 cam = vec3(0.0, 0.0, -100.0);\nfloat FOV = 0.25;\n\n// Glow settings\nvec3 glow_color = vec3(1.0, 1.0, 1.0);\nfloat glow_strength = 0.0;\n\nuniform vec2 cursor;\n\nfloat PI = 3.14159265358979323;\n\n// Scene (creating the scene)\nfloat scene(vec3 from) {\n    float speed = 1.0;\n    float rotation = iTime;\n    mat2 rot = mat2(\n        cos(rotation * speed), -sin(rotation * speed),\n        sin(rotation * speed), cos(rotation * speed)\n    );\n    from.xz *= rot; // Y rotation\n    \n    float de = deRound(deCuboid(rotate(from, 0.5, -1.0, 0.25, vec3(0.0)), vec3(0.0, 0.0, -10.0), vec3(130.0, 130.0, 20.0)), 10.0);\n    de = smoothBoolSubtraction(deSphere(rotate(from, 0.5, -1.0, 0.25, vec3(0.0)), vec3(cos(iTime * 2.0) * 45.0, 0.0, -10.0), 50.0), de, 5.0);\n    de = smoothBoolUnion(de, from.y + 25.0 - floor(cos(from.x / 12.0) + sin(from.z / 12.0) + 0.5) * 2.0, 20.0);\n    de = boolUnion(de, deCuboid(from, vec3(0.0, -5.0, 30.0), vec3(45.0)));\n    return de;\n    \n}\n\n// March the rays!\nvec3 render(vec3 from, vec3 dir) {\n    vec3 at = from;\n    float closest = 10000.0;\n    for(float totalDE = 0.0; totalDE < 100.0; totalDE += 1.0) {\n        float de = scene(at);\n        at += dir * de;\n        if(de < closest) {\n            closest = de;\n        }\n        if(de < 0.00001) {\n            float closestShadow = 10000.0;\n            float shade = 1.0;\n            float bias = 1.0;\n            vec3 atShadow = at + bias * sun;\n            float totalShadowDE = bias;\n            for(float shadowDE = 0.0; shadowDE < 100.0; shadowDE += 1.0) {\n                float deShadow = clamp(scene(atShadow), 0.0, 1.0);\n                atShadow += sun * deShadow;\n                if(deShadow < closestShadow) {\n                    closestShadow = deShadow;\n                    shade = min(shade, deShadow / totalShadowDE);\n                }\n                totalShadowDE += deShadow;\n            }\n            return vec3(0.75) * clamp(shade, 0.2, 1.0) - totalDE / 500.0;\n        }\n    }\n    return glow_color * glow_strength - closest / 10.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    c = render(cam, normalize(vec3(gl_FragCoord.x / iResolution.x - 0.5, gl_FragCoord.y / iResolution.y - 0.5, FOV)));\n    fragColor = vec4(c, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}