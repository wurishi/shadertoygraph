{"ver":"0.1","info":{"id":"Ws2fD1","date":"1589971137","viewed":73,"name":"Me Learning Marching 6","username":"ShadingAlpaca","description":"Let's rotate the camera","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 10.\n#define MIN_SURF .001\n#define PI 3.14159\n\n//Rotates the given Vector around the X-Axis\nvec3 rotateX(vec3 put,float angle)\n{\n    return vec3(\n        put.x,\n        put.y*cos(angle) - put.z*sin(angle),\n        put.y*sin(angle) + put.z*cos(angle)\n    );\n}\n\n//Rotates the given Vector around the Y-Axis\nvec3 rotateY(vec3 put,float angle)\n{\n    return vec3(\n        put.x*cos(angle) + put.z*sin(angle),\n        put.y,\n       -put.x*sin(angle) + put.z*cos(angle)\n    );\n}\n\n//Rotates the given Vector around the Z-Axis\nvec3 rotateZ(vec3 put,float angle)\n{\n    return vec3(\n        put.x*cos(angle) - put.y*sin(angle),\n        put.x*sin(angle) + put.y*cos(angle),\n        put.z\n    );\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereDist(vec3 point, vec4 sphere)\n{\n    return length(point-sphere.xyz)-sphere.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sceneDist(vec3 point)\n{\n    float box1 = sdBox(mod(point,2.)-vec3(1.,1.,1.),vec3(0.3));\n    float scene = box1;\n        \n    return scene;\n}\n\nfloat rayMarch(vec3 position, vec3 direction)\n{\n    float cD = 0.;\n    \n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = position+direction*cD;\n        float dS = sceneDist(p);\n        cD += dS;\n        if(cD>MAX_DISTANCE||dS<MIN_SURF)\n            break;\n    }\n    \n    return cD;\n}\n\nvec3 getNormal(vec3 point)\n{\n    float d = sceneDist(point);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d-vec3(\n        sceneDist(point-e.xyy),\n        sceneDist(point-e.yxy),\n        sceneDist(point-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat getLight(vec3 point, vec3 light)\n{\n    vec3 l = normalize(light-point);\n    vec3 n = getNormal(point);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = rayMarch(point+MIN_SURF*n*2.,l);\n    \n    if(d<length(light.xyz-point))\n        dif *= 0.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5*iResolution.xy) /iResolution.y;\n\n    vec3 camera = vec3(0.,0.,iTime*0.5);\n    vec3 direction = normalize(rotateX(rotateY(vec3(uv.x*zoom,uv.y*zoom,1.),sin(iTime)*0.1),cos(iTime*0.2)*0.3));\n    \n    float d = rayMarch(camera,direction);\n    \n    \n    vec3 p = camera+direction*d;\n    \n    vec3 light1 = camera;\n    float brightness1 = getLight(p,light1);\n    // Time varying pixel color\n    vec3 col1 = vec3(0.2,0.18,0.1);\n\n    // Output to screen\n    fragColor = vec4(col1*brightness1+1./d,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}