{"ver":"0.1","info":{"id":"ltVyD1","date":"1536194705","viewed":182,"name":"Terrain first test","username":"saidwho12","description":"saf","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["terraub"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float RAY_T_MAX = 50.0;\nconst float RAY_T_MIN = 1e-1;\nconst float EPSILON = 1e-2;\nconst int   MARCH_STEPS_MAX = 200;\n/*\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n*/\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 fade(in vec2 p) {\n\treturn 6.0*pow(p,vec2(5.0)) - 15.0*pow(p,vec2(4.0)) + 10.0*pow(p,vec2(3.0));\n}\n\nfloat perlin(in vec2 p) {\n\tvec2 a = floor(p), b = a + 1.0;\n    vec2 s = fade(p-a);\n    \n    float a1 = hash12(a)  * radians(360.0);\n    vec2 v1 = vec2(cos(a1), sin(a1));\n    \n    vec2 p2 = vec2(b.x, a.y);\n    float a2 = hash12(p2) * radians(360.0);\n    vec2 v2 = vec2(cos(a2), sin(a2));\n    \n    vec2 p3 = vec2(a.x, b.y);\n    float a3 = hash12(p3) * radians(360.0);\n    vec2 v3 = vec2(cos(a3), sin(a3));\n    \n    float a4 = hash12(b) * radians(360.0);\n    vec2 v4 = vec2(cos(a4), sin(a4));\n    \n    vec2 d1 = normalize(v1-p);\n    vec2 d2 = normalize(v2-p);\n    vec2 d3 = normalize(v3-p);\n    vec2 d4 = normalize(v4-p);\n    \n    float g1 = dot(d1, v1);\n    float g2 = dot(d2, v2);\n    float g3 = dot(d3, v3);\n    float g4 = dot(d4, v4);\n    \n    return mix(mix(g1, g2, s.x), mix(g3, g4, s.x), s.y);\n}\n\nfloat sdSphere(in vec3 p, in float r) { return length(p)-r; }\nfloat udBox(in vec3 p, in vec3 b) { return length(max(abs(p)-b, 0.0)); }\n\nmat2 rotate(in float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat f(in vec3 p) {\n    p.xz *= 0.5;\n    //p.xz = rotate(0.1 * iTime * radians(360.0)) * p.xz;\n    \n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n    float q = 0.5;\n    \n    //p.xz = abs(p.xz);\n    \n    float h = 0.0;\n    for(int i = 0; i < 6; ++i) {\n    \th += q * perlin(p.xz);\n    \tp.xz = m * p.xz;\n        q *= 0.4;\n    }\n    \n    float w = p.y + 0.25;\n    \n    return 0.5 * (p.y - h);\n    \n    //return p.y - 0.1*sin((length(p.xz) - iTime) * radians(360.0));\n    /*\n    p.xz = rotate(iTime) * p.xz;\n    vec2 uv = vec2((atan(p.y, p.x) + radians(180.0)) / radians(360.0),\n                   acos(p.z / length(p)) / radians(180.0));\n    \n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n    float q = 0.5;\n    \n    uv = uv * 2.0 - 1.0;\n    float h = 0.0;\n    for(int i = 0; i < 1; ++i) {\n    \th += q * perlin(uv);\n    \tuv = m * uv;\n        q *= 0.5;\n    }\n    \n    return sdSphere(p, 1.0) - 0.05*h;*/\n}\n\nvec3 n(in vec3 p) {\n\treturn normalize(vec3(\n    \tf(vec3(p.x + EPSILON, p.yz)) - f(vec3(p.x - EPSILON, p.yz)),\n        f(vec3(p.x, p.y + EPSILON, p.z)) - f(vec3(p.x, p.y - EPSILON, p.z)),\n        f(vec3(p.xy, p.z + EPSILON)) - f(vec3(p.xy, p.z - EPSILON))\n    ));\n}\n\nstruct Camera {\n\tvec3 pos;\n\tvec3 forward;\n    vec3 up;\n    vec3 right;\n};\n\nfloat trace(in vec3 ro, in vec3 rd) {\n\tfloat t = RAY_T_MIN;\n    int j = 0;\n    for(int i = 0; i < MARCH_STEPS_MAX; i++) {\n        vec3 p = ro + rd * t;\n    \tfloat r = f(p);\n        if(r < EPSILON || t > RAY_T_MAX) {\n            j = i;\n        \tbreak;\n        }\n        \n        t += r;\n    }\n    \n    if(j == MARCH_STEPS_MAX || t > RAY_T_MAX) {\n    \treturn RAY_T_MAX;\n    }\n    \n    return t;\n    \n}\n\nstruct PhongMaterial {\n    vec3 diffuse;\n    vec3 specular;\n    float a;\n};\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    Camera cam;\n    cam.pos = vec3(0.0, 4.0, -mod(iTime, 100.0));\n    cam.forward = vec3(0,0,-1);\n    cam.up = vec3(0,1,0);\n    cam.right = normalize(cross(cam.forward, cam.up));\n    vec3 rd = normalize(cam.forward + p.x * cam.right + p.y * cam.up);\n    \n    vec3 color = vec3(0);\n   \n    const vec3 skyblue = vec3(235.0, 255.0, 255.0) / 255.0;\n    const vec3 white = vec3(255.0, 255.0, 255.0) / 255.0;\n    float t = trace(cam.pos, rd);\n    if(t != RAY_T_MAX) {\n        vec3 p = cam.pos + rd * t;\n        vec3 normal = n(p);\n        \n    \t//color = vec3(t / RAY_T_MAX);\n    \t\n        float fogDist = 25.0;\n        float elevation = clamp(2.0*p.y * 0.5 + 0.5, 0.0, 1.0);\n        vec3 lightPos = vec3(1250.0, 2000.0, 500.0);\n        vec3 L = normalize(lightPos - p);\n        vec3 V = normalize(p - cam.pos);\n        vec3 R = reflect(L, normal);\n        float dotNL = max(dot(normal, L),0.0);\n        float dotNU = max(dot(normal, vec3(0,1,0)),0.0);\n        \n        vec3 snow = vec3(1.0) * clamp(pow(dotNU, 2.0),0.0,1.0);\n        \n        vec3 brown = vec3(237.0, 201.0, 175.0) / 255.0;\n        vec3 dirt = mix(brown, vec3(0.25),\n                        0.25 *\n                        (cos(radians(360.0) * (elevation*2.0 - 1.0)*0.5) * 0.5 + 0.5) *\n                        (sin(radians(360.0) * elevation * 20.0) * 0.5 + 0.5) *\n                       \t(perlin(p.xz) * 0.5 + 0.5)\n                       );\n        \n        color = dotNL * mix(dirt, mix(vec3(0.4,0.6,0.3), snow, elevation), pow(dotNU,4.0));\n        //color = dirt;\n        \n        float fog = /*(1.0 - 0.25*elevation) * */ min(exp(-3.0 * (1.0 - t/fogDist)),1.0);\n        color = mix(color, skyblue, fog);\n        \n        //color = normal * 0.5 + 0.5;\n    \n    \t//color += 0.25*dotNL;\n    } else {\n    \tcolor = mix(skyblue, white, p.y);\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}