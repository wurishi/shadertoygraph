{"ver":"0.1","info":{"id":"Dd2BzK","date":"1696619636","viewed":132,"name":"Lake Water Recreation","username":"TextBox","description":"My own recreation of lake water as a raymarching shader, it uses waves instead of a noise map.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 dim = vec3(5, 0, 5);\n\nstruct Wave\n{\n    float y;\n    float wtx; // wave tangent\n    float wtz;\n};\n\nstruct WaveSum\n{\n    float y;\n    vec3 n;\n};\n\nfloat CubeSDF(vec3 o) \n{\n    vec3 d = abs(o) - dim;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nWave CreateWave(vec3 eye, float a, float w, float k, float x, float z)\n{\n    float w1 = a * sin(w * iTime - k * (pow(eye.x + x, 2.0) + pow(eye.z + z, 2.0)));\n    float wtx = -2.0 * a * k * (x + eye.x) * cos(w * iTime - k * (pow(eye.x + x, 2.0) + pow(eye.z + z, 2.0)));\n    float wtz = -2.0 * a * k * (z + eye.z) * cos(w * iTime - k * (pow(eye.x + x, 2.0) + pow(eye.z + z, 2.0)));\n    Wave wav = Wave(w1, wtx, wtz);\n    return wav;\n}\n\nWaveSum Waves(vec3 eye)\n{\n    Wave w1 = CreateWave(eye, 0.015, 10.0, 0.2, 5.0, 15.0);\n    Wave w2 = CreateWave(eye, 0.01, 8.0, 0.2, 2.0, 15.0);\n    Wave w3 = CreateWave(eye, 0.005, 10.0, 0.3, 10.0, 15.0);\n    Wave w4 = CreateWave(eye, 0.008, 13.0, 0.5, 0.0, 15.0);\n    \n    float wys = w1.y + w2.y + w3.y + w4.y;\n    float wtxs = w1.wtx + w2.wtx + w3.wtx + w4.wtx;\n    float wtzs = w1.wtz + w2.wtz + w3.wtz + w4.wtz;\n    vec3 n = normalize(vec3(wtxs, 1.0, wtzs));\n    return WaveSum(wys, n);\n}\n\nvec4 LightScene(WaveSum w, vec3 eye, vec3 dir)\n{\n    vec3 p = vec3(0, 5, 3);\n    vec3 oeye = vec3(cos(iTime * 0.5) * 7.0, abs(sin(iTime * 0.3)) * 4.0 + 1.0, sin(iTime * 0.5) * 7.0); // lil hack\n    \n    float d = max(dot(normalize(p), w.n), 0.0);\n    vec4 rfl = texture(iChannel0, reflect(dir, w.n)); // Reflection\n    vec3 rfr = refract(dir, w.n, 0.02); // Refraction\n    \n    float fog = min(pow(distance(oeye, eye), 3.0) / 500.0, 1.0);\n    vec4 t = texture(iChannel1, ((eye.xz + rfr.xz + dir.xz * 3.0) / dim.xz));\n    vec4 c = mix(t, vec4(0.0, 0.3, 0.3, 1.0), fog);\n    \n    return c * vec4(0.0, 0.8, 0.7, 1.0) * d + rfl * 0.5;\n}\n         \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(cos(iTime * 0.5) * 7.0, abs(sin(iTime * 0.3)) * 4.0 + 1.0, sin(iTime * 0.5) * 7.0);\n    vec3 ta = vec3(0);\n\tvec3 cf = normalize( ta - eye );\n\tvec3 wu = vec3( 0.0, 1.0, 0.0 ); // world up reference\n\tvec3 cr = normalize( cross(cf,wu) );\n\tvec3 cu = normalize( cross(cr,cf) );\n\tvec3 dir = normalize( uv.x * cr + uv.y * cu + cf );\n    \n    for (int i = 0; i < 256; i++) \n    {\n        WaveSum w = Waves(eye);\n        float dist = CubeSDF(vec3(0, w.y, 0) + eye);\n        if (dist <= 0.001) \n        {\n            fragColor = LightScene(w, eye, dir);\n            return;\n        }\n        \n        if (dist >= 100.0)\n        {\n            fragColor = texture(iChannel0, dir);\n            return;\n        }\n        eye += dir * dist * 0.9;\n    }\n}\n\n\n","name":"Image","description":"","type":"image"}]}