{"ver":"0.1","info":{"id":"msdSDn","date":"1679658490","viewed":63,"name":"Fixed newton","username":"zenzicubic","description":"Fixed version of newton","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITER 100\n#define SCALE 4.\n#define EPSILON 1e-5\n\n#define PI 3.141592653979\n#define TAU 2. * PI\n\n// Complex number utilities\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\nvec2 cinv(vec2 z) { return vec2(z.x, -z.y) / dot(z, z); }\n#define cdiv(a, b) cmul(a, cinv(b))\n\nvec2 newton_iteration(vec2 z)\n{\n    vec2 t = cmul(z, cmul(z, z));\n    // Calculate the function and derivative and divide them\n    return cdiv(\n        cmul(t, z) - vec2(1., 0.),\n        t * 4.);\n}\n\nvec3 color(vec2 z)\n{\n    vec2 lastZ, tempZ;\n    int j = 0;\n    \n    // Apply the iteration\n    while (j < MAXITER) {\n        tempZ = z;\n        z -= newton_iteration(z);\n        lastZ = tempZ;\n        \n        if (length(z - lastZ) <= EPSILON) {\n            break;\n        } \n        j ++;\n    }\n    \n    // Calculate color\n    float t = PI + atan(z.y, z.x);\n    float brt = 1. - (float(j) / float(MAXITER));\n    \n    vec3 col = 0.5 + 0.5 * cos(t + vec3(.0, 2.09, 4.19));\n    return col * brt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 c)\n{\n    vec2 z = SCALE * (2. * c - iResolution.xy) / iResolution.y;\n    fragColor = vec4(color(z),1.0);\n}","name":"Image","description":"","type":"image"}]}