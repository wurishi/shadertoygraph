{"ver":"0.1","info":{"id":"Md3Bz8","date":"1524276371","viewed":402,"name":"Garden of Spheres","username":"konidia","description":"A combination of my experience with voxel traversal (dda) and ray tracing :)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","sphere","dda","infinity","3dtraversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATION 300\n\n// top half: 25 unites high\nconst float height1 = 25.0;\n\n\n// bottom half: 2 units high\nconst float height2 = 2.0;\n\n// look around horizontally with mouse\nconst float radius = 0.4;\n\n// structs\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float fovScalar;\n};\n    \n// functions for casting rays\n    \nvoid setCamera(vec3 pos, vec3 forward, vec3 upGuide, float fov, out Camera cam)\n{\n    cam.pos = pos;\n    cam.forward = normalize(forward);\n    cam.right = cross(-cam.forward, normalize(upGuide));\n    cam.up = cross(cam.right, -cam.forward);\n    cam.fovScalar = tan(radians(fov/2.0));\n}\n\nRay castRay(vec2 uv, in Camera cam)\n{\n    uv *= cam.fovScalar;\n    return Ray(\n        cam.pos,\n        normalize(cam.forward + uv.x * cam.right + uv.y * cam.up)\n    );\n}\n\n// noise function\n\nvec3 noise(in vec2 uv){return texture(iChannel0, uv).rgb;}\n\n// shape intersection functions\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 p = ro - sph.xyz;\n\tfloat b = dot( p, rd );\n\tfloat c = dot( p, p ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 nSphere(in vec3 p, in vec4 sph)\n{\n    return (p-sph.xyz)/sph.w;\n}\n\nfloat iFloor(in vec3 ro, in vec3 rd, float h)\n{\n    if(ro.y <= h)\n        return -1.;\n    if(rd.y >= 0.)\n        return -1.;\n    \n    h = h - ro.y;\n    return h/rd.y;\n}\n\n// produce color based on ro and rd\n\nvec3 rayCast(vec3 ro, vec3 rd)\n{\n    float t = iFloor(ro, rd, radius*2.75);\n    if(t < 0.)\n        return vec3(0, 0.8, 1);\n    \n    ro = ro + t * rd;\n    \n    vec3 mapPos = floor(ro);\n    vec3 rayStep = sign(rd);\n    vec3 deltaDist = abs(1./rd);\n    vec3 sideDist = sign(rd)*(mapPos - ro + sign(rd)*0.5+0.5)*deltaDist;\n    \n    bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yxx, sideDist.zzy));\n    \n    for(int i = 0; i < MAX_ITERATION; ++i)\n    {   \n        mapPos += vec3(mask) * rayStep;\n        \n        vec4 sph = vec4(vec3(mapPos.x+0.5, radius, mapPos.z+0.5), radius);\n        \n        t = iSphere(ro, rd, sph);\n        \n        if(t >= 0.)\n        {\n            vec3 p = ro + rd * t;\n            float diff = max(dot(nSphere(p, sph), vec3(0,1,0)),0.)+0.2;\n            mapPos = mod(mapPos, vec3(50.));\n            return diff*noise(mapPos.xz/128.);\n        }\n        if(mapPos.y < 0.) \n            return vec3(0.2, 0.1, 0);\n        \n        sideDist += vec3(mask) * deltaDist;\n        \n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yxx, sideDist.zzy));\n    }\n    \n    return vec3(0, 0.8, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y/iResolution.x;\n\t\n    Camera cam;\n    vec3 pos = vec3(0, height1+radius*2., 0.5+iTime*5.);\n    float mouseX = (iMouse.x/iResolution.x-0.5)*6.28;\n    vec3 dir = vec3(sin(mouseX), -0.3, cos(-mouseX));\n    if(uv.y < 0.005 && uv.y > -0.005)\n    {\n        fragColor = vec4(vec3(0), 1);\n        return;\n    }\n    if(uv.y <= -0.005)\n    {\n        pos = vec3(0, height2+radius*2., 0.5+iTime*5.);\n    \tdir = vec3(sin(mouseX), -0.01, cos(-mouseX));\n    }\n    \n    setCamera(pos, dir, vec3(0,1,0), 60., cam);\n    Ray ray = castRay(uv, cam);\n\n    fragColor = vec4(rayCast(ray.pos, ray.dir),1.0);\n}","name":"Image","description":"","type":"image"}]}