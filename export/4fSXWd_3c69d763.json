{"ver":"0.1","info":{"id":"4fSXWd","date":"1706945594","viewed":91,"name":"Fork Magic Door psycho_cho 304","username":"psycho_chou","description":"This is another shader for Sableraph's weekly creative coding challenge, the theme was \"textile\". \n\nAt first I felt a bit disappointed a different prompt wasn't picked but in the end I really like how this one turned out. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"stjSWh","parentname":"Magic Doormat Dispenser"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STEPS 128.0\n#define MDIST 40.0\n#define pi 3.1415926535\n#define pmod(p, x) (mod(p, x) - 0.5 * (x))\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a));\n// box sdf\nfloat box(vec3 p, vec3 s) {\n    vec3 d = abs(p) - s;\n    return max(d.x, max(d.y, d.z));\n}\n// iq's color palette function\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n// An interpolated sinwave with variable sample rate to give the carpets a low\n// poly look\nfloat psin(float x, float b) {\n    return sin(floor(b * x) / b) +\n           (sin(floor(b * x + 1.0) / b) - sin(floor(b * x) / b)) *\n               mod(b * x, 1.0);\n               \n}\n\n#define RED vec3(1.0, 0.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\nvec3 blanket(vec3 d, vec3 p, vec3 rd, vec3 col) {\n    // float g0 = getRug(vec2(p.x - d.z, p.z), d.y);\n    //     col = light(p, rd, color(d, g0));\n    // vec3 v = vec3(g0);\n    // col = v;\n    // vec2 p = uv;\n    // p.x -= d.z;\n    p.z /= 4.;\n    p.z = p.z + .5;\n    p.z = 1. - p.z;\n    p.x -= d.z;\n    p.x /= 4.;\n    p.x += .5;\n    float t = mod(floor(iTime / 1.), 4.);\n    if (p.y > 0. && p.y < 1.0) {\n        if (t == 0.) {\n            col = RED;\n        } else if (t == 1.) {\n            col =BLUE ;\n        } else if (t == 2.) {\n            col = GREEN;\n        } else if (t == 3.) {\n            col =YELLOW ;\n        }\n    }\n    if (p.y > -1. && p.y < 0.0) {\n        if (t == 0.) {\n            col = BLUE;\n        } else if (t == 1.) {\n            col = GREEN;\n        } else if (t == 2.) {\n            col = YELLOW;\n        } else if (t == 3.) {\n            col = RED;\n        }\n    }\n    if (p.y > -2. && p.y < -1.0) {\n        if (t == 0.) {\n            col = GREEN;\n        } else if (t == 1.) {\n            col = YELLOW;\n        } else if (t == 2.) {\n            col = RED;\n        } else if (t == 3.) {\n            col = BLUE;\n        }\n    }\n    if (p.y > -3. && p.y < -2.) {\n        if (t == 0.) {\n            col = YELLOW;\n        } else if (t == 1.) {\n            col = RED;\n        } else if (t == 2.) {\n            col = BLUE;\n        } else if (t == 3.) {\n            col = GREEN;\n        }\n    }\n    if (p.y > -4. && p.y < -3.) {\n        /*if (t == 0.) {\n                    col = texture(iChannel0, p.xz).xyz;\n                } else if (t == 1.) {\n                    col = texture(iChannel1, p.xz).xyz;\n                } else if (t == 2.) {\n                    col = texture(iChannel2, p.xz).xyz;\n                } else if (t == 3.) {\n                    col = texture(iChannel3, p.xz).xyz;\n                }*/\n        if (t == 0.) {\n            col = RED;\n        } else if (t == 1.) {\n            col = BLUE;\n        } else if (t == 2.) {\n            col = GREEN;\n        } else if (t == 3.) {\n            col = YELLOW;\n        }\n        /*else if (t == 2.) {\n                    col = vec3(0.0, 0.0, 1.0);\n                } else if (t == 3.) {\n                    col = vec3(1.0, 1.0, 0.0);\n                }*/\n    }\n  \n    return col;\n}\nvec3 map(vec3 p) {\n    vec3 a = vec3(0);\n    float t = iTime;\n    // scroll the y axis up all the time\n    p.y -= t - .5;\n    // id of y axis domain repition\n    float id = floor(p.y / 1.0) + .5;\n    // x value to offset carpets so they fly left and right\n    float xoff = max(0.0, (id + t) * 2.0);\n    xoff = xoff * xoff * sign(sin(id * pi));\n    ;\n    // domain repition in the y axis\n    p.y = pmod(p.y, 1.0);\n    // Add some low poly waves to the carpets\n    // float sb = .7;\n    // float wscl = 0.06;\n    // p.y += psin(p.x * 4.0 + id, sb) * wscl;\n    // p.y -= psin(p.z * 4.0 + id, sb) * wscl;\n    // calculate box sdf\n    a.x = box(p - vec3(xoff, 0, 0), vec3(2, 0.025, 2));\n    // pass some info to coloring code\n    a.y = id;\n    a.z = xoff;\n    return a;\n}\nvec3 norm(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    return normalize(\n        map(p).x - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x));\n}\n// mirror function\n// radial mod (stole a flopine shader)\nvec2 moda(vec2 p, float per) {\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a - per / 2., per) - per / 2.;\n    return vec2(cos(a), sin(a)) * l;\n}\nvoid rayTracing(out vec3 d, out vec3 p, vec3 ro, vec3 rd, out bool hit) {\n    float dO;\n    // raymarch loop\n    for (float i = 0.0; i < STEPS; i++) {\n        d = map(p);\n        dO += min(0.75, d.x * 0.8);\n        p = ro + rd * dO;\n        if (abs(d.x) < 0.001) {\n            hit = true;\n            break;\n        }\n        if (dO > MDIST) {\n            break;\n        }\n    }\n}\nfloat shadow(vec3 p, vec3 n, vec3 ld) {\n    // some hacky soft shadows\n    float shadow = 1.0;\n    float md = 1.0;\n    vec3 sp = p + n * 0.5;\n    for (int i = 0; i < 10; ++i) {\n        float d = map(sp).x;\n        if (d > 3.0) break;\n        sp += min(d, 0.4) * ld;\n        md = min(md, d);\n        if (md < 0.5) shadow = md + 0.5;\n    }\n    // I still have no idea what I am doing with these lighting mixes\n    shadow = pow(shadow, 1.75);\n    return shadow;\n}\nvec3 lightShadow(vec3 n, vec3 h, vec3 rd, vec3 ld, vec3 col, float shadow) {\n    float spec = pow(max(dot(n, h), 0.0), 20.0);\n    float fres = pow(1. - max(dot(n, -rd), 0.), 5.);\n    float diff = max(dot(n, ld), 0.);\n    col += spec * 0.3 * shadow * vec3(1.000, 0.831, 0.439);\n    col += fres * 0.175 * shadow * vec3(1.000, 0.957, 0.824);\n    col *= clamp(diff * vec3(1.000, 0.957, 0.824), 0.2, 1.0);\n    col *= clamp(shadow, 0.0, 1.0);\n    return col;\n}\nvec3 light(vec3 p, vec3 rd, vec3 col) {\n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(0.2, 1, 1));\n    vec3 h = normalize(ld - rd);\n    float shadow = shadow(p, n, ld);\n    col = lightShadow(n, h, rd, ld, col, shadow);\n    return col;\n}\nvec3 color(vec3 d, float g0) {\n    vec3 palc = 0.9 * pal(d.y / 3.0, vec3(0.3), vec3(0.5), vec3(1.7),\n                          vec3(0, 0.33, 0.66));\n    float bright = mix(1., 1., sin(d.y * pi) * 0.5 + 0.5);\n    vec3 al = mix(palc, vec3(bright), g0);\n    return al;\n}\nvec3 sunStars(vec2 uv, float aa, float t, vec3 col) {\n    // orange/purple gradient\n    col = mix(vec3(0.976, 0.502, 0.243), vec3(0.420, 0.259, 1.000),\n              min(length(uv) - 0.4, 1.2));\n    // big sun circle\n    float sun = smoothstep(length(uv) - aa, length(uv) + aa, 0.3);\n    uv *= rot((floor(length(uv) / 0.1) + 0.5) - t * 0.025);\n    // lots of little tiny rings\n    uv = moda(uv, 0.3);\n    uv.x = pmod(uv.x, 0.1);\n    float rs = 0.035 / 2.0;\n    sun += (smoothstep(length(uv) - aa, length(uv) + aa, rs) -\n            smoothstep(length(uv) - aa, length(uv) + aa, rs * 0.5));\n    col += min(sun, 1.0);\n    return col;\n}\n\nvec3 mountain(vec2 uv, vec2 uvo, float t, vec3 col, float aa) {\n    // Some sand dune thingys\n    uv = uvo;\n    uv.y += sin(uv.x * 12.0 - t * 0.4 + 5.0) * 0.015;\n    col = mix(col, vec3(1.000, 0.655, 0.275),\n              smoothstep(uv.y - aa, uv.y + aa, -0.25));\n    uv = uvo;\n    uv.y += sin(uv.x * 12.0 - t + 2.5) * 0.015;\n    col = mix(col, vec3(0.957, 0.584, 0.357),\n              smoothstep(uv.y - aa, uv.y + aa, -0.325));\n    uv = uvo;\n    uv.y += sin(uv.x * 12.0 - t * 1.8) * 0.015;\n    col = mix(col, vec3(0.894, 0.871, 0.353),\n              smoothstep(uv.y - aa, uv.y + aa, -0.4));\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    float aa = 1.0 / iResolution.y;\n    vec3 ro = vec3(0, 3, -7);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.yz *= rot(-0.4);\n    vec3 p = ro;\n    vec3 d;\n    bool hit = false;\n    rayTracing(d, p, ro, rd, hit);\n    // if ray marcher hits something color it\n    if (hit) {\n        col = blanket(d, p, rd, col);\n    }\n    // if ray marcher didn't hit then render the background\n    else {\n        vec2 uvo = uv;\n        uv.y -= 0.5;\n        uv.x -= 0.7;\n        col = sunStars(uv, aa, t, col);\n        col = mountain(uv, uvo, t, col, aa);\n    }\n    // Gamma\n col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}