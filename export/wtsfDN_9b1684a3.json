{"ver":"0.1","info":{"id":"wtsfDN","date":"1596822567","viewed":124,"name":"Split Quaternion Transform","username":"skye_adaire","description":"Click to move the origin (shown as a white dot).\nSplit Quaternions can be used to transform 2D hyperbolic space.\nHere we are oscillating with constant velocity along a line passing through the origin.\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["space","quaternion","transform","hyperbolic","split"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by Skye Adaire\nApache License 2.0\n\nHyperbolic space is the surface of a hyperboloid of two sheets.\nIf we wish to translate in hyperbolic space we must rotate the surface.\nWe can rotate the surface by multiplying by a versor.\n\nThe hyperbolic versor for distance ~ rapidity \"a\" in direction \"n\"\ncosh(a) + n * sinh(a)\nSimilar to quaternion versor / Euler's formula\n\nUnlike complex quaternions, we are not performing a double rotation,\nand do not need to use conjugation to transform a point in R3.\n\nWhen n is a unit direction in the XY plane, a versor can be used\nto generate all points on the model.\n\nA point on the model can be decomposed to a distance and direction.\n\nWe are coloring based on direction, and shading based on hyperbolic distance.\nThis is why the black lines pass the center at a constant rate.\n\nhttps://en.m.wikipedia.org/wiki/Cayley%E2%80%93Dickson_construction\nhttps://en.wikipedia.org/wiki/Hyperboloid_model\nhttps://en.wikipedia.org/wiki/Split-quaternion\n*/\n\n#define USE_POINCARE_DISK false\n\n#define S vec2\n#define SS vec4\n\nS S_conj(S a)\n{\n \treturn S(a[0], -a[1]);   \n}\n\nS S_mul(S a, S b)\n{\n \treturn S(a[0]*b[0] + a[1]*b[1], a[1]*b[0] + a[0]*b[1]);\n}\n\nS SS_L(SS a)\n{\n \treturn S(a[0], a[1]);   \n}\n\nS SS_R(SS a)\n{\n    return S(a[2], a[3]);   \n}\n\nfloat SS_bilinearNorm(SS a, SS b)\n{\n \treturn a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3];   \n}\n\nfloat SS_distance(SS a, SS b)\n{\n \treturn acosh(SS_bilinearNorm(a, b));   \n}\n\nfloat SS_distance(vec3 a, vec3 b)\n{\n \treturn SS_distance(SS(0, a), SS(0, b));   \n}\n\nSS SS_mul(SS a, SS b)\n{\n    S a0 = SS_L(a); S a1 = SS_R(a);\n    S b0 = SS_L(b); S b1 = SS_R(b);\n    S r0 = S_mul(a0, b0) + S_mul(S_conj(b1), a1);\n    S r1 = S_mul(b1, a0) + S_mul(a1, S_conj(b0));\n    return SS(r0, r1);\n}\n\nvec2 rotateCW(vec2 n)\n{\n    return vec2(n.y, -n.x);\n}\n\nvec2 rotateCCW(vec2 n)\n{\n    return vec2(-n.y, n.x);\n}\n\n//generates points on the hyperbolid, where b is unit and orthogonal \n//to the hyperboloid's axis (0, 0, 1)\nSS SS_versor(float a, vec2 n)\n{\n \treturn SS(cosh(a), vec3(rotateCCW(n), 0) * sinh(a));\n}\n\nvoid SS_decompose(SS v, out float a, out vec2 n)\n{\n    a = SS_distance(v, SS(0, 0, 0, 1));\n    n = rotateCW(normalize(vec2(v[1], v[2])));\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < 0.00001)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < 0.00001)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\nfloat hdot(vec3 a, vec3 b)\n{\n    return a[0] * b[0] + a[1] * b[1] - a[2] * b[2];\n}\n\nbool intersectHypercone(vec3 rayPosition, vec3 rayDirection, float type, out float t)\n{\n    float a = hdot(rayDirection, rayDirection);\n    float b = 2.0 * hdot(rayDirection, rayPosition);\n    float c = hdot(rayPosition, rayPosition) + type;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nbool intersectEllipticHyperboloid(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    return intersectHypercone(rayPosition, rayDirection, +1.0, t);\n}\n\nvec3 projectPlaneToHyperboloid(vec2 p)\n{\n    vec3 rayPosition, rayDirection;\n    \n    if(USE_POINCARE_DISK)\n    {\n        rayPosition = vec3(0, 0, 0.9995);//1 would intersect with the other sheet\n    \trayDirection = normalize(vec3(p, 0) - rayPosition);\n    }\n\telse\n    {\n        rayPosition = vec3(p, 0);\n        rayDirection = vec3(0, 0, -1);\n    }\n    \n    float t;\n    intersectEllipticHyperboloid(rayPosition, rayDirection, t);\n    \n    return rayPosition + t * rayDirection;\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat triangleWave(float x)\n{\n \treturn abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat modelScale = USE_POINCARE_DISK ? 2.0 : 40.0;\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseUnit = mouseUV - 0.5;\n    vec2 mouseRatio = mouseUnit * vec2(iResolution.x / float(iResolution.y), 1.0);\n    vec2 mouseModel = modelScale * mouseRatio;\n    \n   \tif(iMouse.xy == vec2(0, 0))\n    {\n     \tmouseModel = normalize(vec2(1, -1));   \n    }\n    \n    if(USE_POINCARE_DISK && length(mouseModel) >= 0.999)//keep mouse in the disk\n    {\n     \tmouseModel = normalize(mouseModel) * 0.999;   \n    }\n    \n    //The screen lies in the XY plane, looking down -Z\n    vec2 uvPosition = fragCoord/iResolution.xy;\n    vec2 unitPosition = uvPosition - 0.5;\n    vec2 ratioPosition = unitPosition * vec2(iResolution.x / float(iResolution.y), 1.0);\n    vec2 planePosition = modelScale * ratioPosition;\n    vec3 surfacePosition = projectPlaneToHyperboloid(planePosition);\n    vec3 mouseHyperboloid = projectPlaneToHyperboloid(mouseModel);    \n\n    float rapidity = iMouse.z > 0.0 ? SS_distance(mouseHyperboloid, vec3(0, 0, 1)) : -triangleWave(iTime*0.01)*40.0;;\n    vec2 direction = normalize(mouseHyperboloid.xy);\n    SS transformInv = SS_versor(-rapidity, direction);\n\n    SS transformedPosition = SS_mul(transformInv, SS(0, surfacePosition));                              \n\n    float pDistance;\n    vec2 pDirection;\n    SS_decompose(transformedPosition, pDistance, pDirection);\n    \t\n    float levels = fract(pDistance) * 0.5 + 0.5;\n    vec3 color = hsv2rgb(vec3(atan(pDirection.y, pDirection.x) / (3.14159*2.0), 1, levels));\n\n    if(SS_distance(transformedPosition, SS(0, 0, 0, 1)) < 0.2)\n    {\n     \tcolor = vec3(1, 1, 1);   \n    }\n    \n    if(USE_POINCARE_DISK && length(planePosition) >= 1.0)\n    {\n        color = vec3(0);\n    }\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}