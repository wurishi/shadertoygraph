{"ver":"0.1","info":{"id":"XttcRH","date":"1531555600","viewed":123,"name":"Rapid Cross title screen","username":"kuyuri_iroha","description":"This fragment shader is used Rapid Cross for title screen.\nGitHub: https://github.com/Kuyuri-Iroha/RapidCross","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265f;\nconst vec3 X_AXIS = vec3(1.0f, 0.0f, 0.0f);\nconst vec3 Y_AXIS = vec3(0.0f, 1.0f, 0.0f);\nconst vec3 Z_AXIS = vec3(0.0f, 0.0f, 1.0f);\nconst float angle = 30.0f;\nconst float fov = angle * 0.5f * PI / 180.0f;\nconst vec3 initCam = vec3(-0.5f, 0.0f, 3.0f);\nconst vec3 lightDir = normalize(vec3(0.3f, -2.0f, 1.0f));\n\nvec3 rotate(vec3 pos, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0f - c;\n    \n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * pos;\n}\n\nvec3 trans(vec3 pos)\n{\n    return vec3(\n        mod(pos.x, 6.0f) - 2.5f,\n        mod(pos.y, 5.0f) - 2.5f, \n        mod(pos.z, 8.0f) - 2.5f\n    );\n}\n\nfloat distanceFunc(vec3 ray)\n{\n    vec3 transRay = trans(ray);\n    vec3 q = abs( abs( rotate( rotate( transRay, -iTime, -Y_AXIS ), -iTime, -X_AXIS ) ) );\n    return length( max( q - vec3(0.5f, 0.5f, 0.5f), 0.0f ) );\n}\n\nvec3 normal(vec3 ray)\n{\n    float delta = 0.0001;\n    vec3 deltaX = X_AXIS * delta;\n    vec3 deltaY = Y_AXIS * delta;\n    vec3 deltaZ = Z_AXIS * delta;\n    \n    return normalize( vec3(\n        distanceFunc( ray + deltaX) - distanceFunc( ray - deltaX),\n        distanceFunc( ray + deltaY) - distanceFunc( ray - deltaY),\n        distanceFunc( ray + deltaZ) - distanceFunc( ray - deltaZ)\n    ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    \n    vec2 pos = vec2( (uv.x * 2.0f - 1.0f) * (16.0f / 9.0f), (uv.y * 2.0f - 1.0f) * 9.0f / 9.0f);\n    \n    vec3 cam = initCam;\n    cam.z = mod( -iTime, 20.0f ) * 10.0f;\n    \n    vec3 rayDir = normalize( vec3( sin(fov) * pos.x, sin(fov) * pos.y, -cos(fov) ) );\n\n    float dist = 0.0f;\n    float len = 0.0f;\n    vec3 ray = cam;\n    //Raymarching\n    for(int i=0; i<126; i++)\n    {\n        dist = distanceFunc(ray);\n        len += dist;\n        ray = cam + rayDir * len;\n    }\n    \n    //Hit\n    if( abs( dist ) < 0.001f)\n    {\n        vec3 n = normal(ray);\n        float diff = clamp( dot( lightDir , n ), 0.015f, 0.5f);\n        color = vec3( diff, diff, diff );\n    }\n    //No hit\n    else\n    {\n        color = vec3( 0.0f, 0.0f, 0.0f);\n    }\n    \n    color = color + 0.4f;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}