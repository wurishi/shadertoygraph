{"ver":"0.1","info":{"id":"WtSGDD","date":"1559511839","viewed":201,"name":"Beneath Water Light Rays","username":"charon","description":"Using noise it creates the lower surface of water and rays of light.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","water","columes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nfloat lightIntensity = 20.0;\nfloat density = 0.2;\nfloat surface = 8.0;\n\n\n// noise function taken from https://www.shadertoy.com/view/4sdGD8\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // moving light\n\t//vec3 lightSource = vec3(0.5+5.0*(cos(time)), 5.0, 10.0 + 2.0*(sin(time)));\n   \n    // startionary light\n    vec3 lightSource = vec3(0.5, 5.0, 10.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n\n    \n    // generatying rays to cast from camera based on coordinates\n    \t\t// z serves to modify field of view\n    \t\t// y moves to look up and to horizon\n    vec3 rayDir = normalize( vec3(uv.x, uv.y + sin(time/4.0)+1.0, 5));\n    \n    \n    \n    vec3 color = vec3(0, 0.3, 0.5);\n    bool brokeSurface = false;\n    for (float i = 1.0; i < 100.0; i+=1.0){\n        float d = distance(i * rayDir, lightSource);\n        \t\n\t\t\tcolor += lightIntensity \n                * pow(2.7, -1.0 * pow(d,1.3) * density) //diffuse based on distance to light\n                * pow(2.7, -1.0 * i * density) //diffuse based on distance to camera (0,0,0)\n                //stationary noise\n                //* pow(snoise(rayDir.xz*50.0), 3.0);\n        \t\t// shifting noise\n\t\t\t\t* pow(snoise(rayDir.xz*i + time/4.0), 3.0);\n        \n        if (!brokeSurface && (i * rayDir).y > surface){\n            brokeSurface = true;\n        \tcolor.y += snoise(rayDir.xz*i + time/4.0)* lightIntensity*10.0* pow(2.7, -1.0 * i * density) ;\n        \ti = 40.0;\n        }\n           \n    }\n   \n\tcolor *= pow(dot(rayDir, normalize(lightSource))-0.2, 6.0);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}