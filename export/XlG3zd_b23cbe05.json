{"ver":"0.1","info":{"id":"XlG3zd","date":"1476108070","viewed":140,"name":"Mandelbrot like sets","username":"EEVV","description":"It just draws the Mandelbrot set, nothing much else. Turn down iteration count, if you have bad performance!\n\nControls: Left click to magnify\n\nEdit: Adding some other weird sets\n","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["2d","fractal","maths"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://stackoverflow.com/questions/369438/smooth-spectrum-for-mandelbrot-set-rendering\n\n#define ZOOMINSCALE 64.0 // change this based on your liking\n#define ITERATIONS 250 // decrease if you are lagging\n#define INCREMENTAMOUNT 12.0 // those c0lors!\n\n// (a + bi)^2 = a^2 + 2abi - b^2\nvec2 complexSquare(vec2 complex) {\n    return vec2(complex.x*complex.x - complex.y*complex.y, 2.0*complex.x*complex.y);\n}\n\n// (a + bi)^3 = a^3 + 3a^2bi - 3ab^2 - b^3\nvec2 complexCube(vec2 complex) {\n    float a2 = complex.x*complex.x;\n    float b2 = complex.y*complex.y;\n    \n    return vec2(a2*complex.x - 3.0*complex.x*b2, 3.0*a2*complex.y - b2*complex.y);\n}\n\n// (a + bi)(c + di) = ac + adi + bci - bd\nvec2 complexMultiply(vec2 complex0, vec2 complex1) {\n\treturn vec2(complex0.x*complex1.x - complex0.y*complex1.y, complex0.x*complex1.y + complex0.y*complex1.x);\n}\n\n// Make a tiny, custom, iterative function!\nvec2 function(vec2 current, vec2 origin) {\n    return complexSquare(current) + origin;\n}\n\nfloat scale = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate the difference between the mouse coordinates and the current fragment coordinates\n    vec2 displacementToMouse = (iMouse.xy - fragCoord.xy);\n    // Normalise it\n    vec2 mouseOrigin = (iMouse.xy / iResolution.xy - 0.5) * 4.0;\n    // Replace with your aspect ratio\n    mouseOrigin.y /= 1.75;\n    \n    // Normalise the origin\n    vec2 origin = ((fragCoord / iResolution.xy - 0.5) * 4.0);\n    // Replace this too with your aspect ratio\n    origin.y /= 1.75;\n    \n    // If scaled (left/right/middle click)\n    bool scaled = length(displacementToMouse) <= 250.0 && iMouse.w > 0.0;\n    \n   \t// If scaled, fix the origin\n    if (scaled) {\n    \tscale = ZOOMINSCALE;\n   \t\torigin /= scale;\n        mouseOrigin /= scale;\n        \n        origin = origin + mouseOrigin * (ZOOMINSCALE - 1.0);\n    }\n    \n    // Current function output\n    vec2 current = origin.xy;\n    \n    // Default to the color black\n    //fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float color = 0.0;\n    \n    int iteration = 0;\n    for (int i = 0; i<ITERATIONS; i++) {\n        iteration = i;\n        \n        current = function(current, origin);\n        \n        // If the number grows beyond our escape number\n        if (current.x*current.x + current.y*current.y > 4.0)\n            break;\n       \t\n    }\n    \n    float interpolated = float(iteration) + 1.0 - log2(log(length(current)));\n    \n   \tcolor = interpolated / float(ITERATIONS);\n    \n    if (iteration == ITERATIONS - 1)\n        color = 1.0;\n    \n    if (scaled) {\n    \tfragColor = vec4(color, color, color, 1.0);//colors.b, log(colors.b), colors.b / 2.0, 1.0);\n\t} else {\n    \tfragColor = vec4(color, color, color, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}