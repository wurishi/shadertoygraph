{"ver":"0.1","info":{"id":"Ndyyzm","date":"1654594407","viewed":99,"name":"RayMarchingTest338","username":"xhl388","description":"now learing Ray Marching with this shader.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SURFACE_DIST .01\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n\n#define PI 3.1415926535\n\n#define LIGHT_NUM 2\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nstruct Light{\n    vec3 pos;\n    vec3 color;\n};\n\nLight mainLight[2] = Light[2](Light(vec3(0, 3, -3), vec3(80,60,70)),\n    Light(vec3(0,5,0), vec3(30,100,40)));\n\n\nvec3 sphereColor = vec3(0.5f, 0.6f, 1.0f);\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 o, float r) {\n    return distance(p, o) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat cubeSDF( vec3 p)\n{\n    vec3 q = abs(p) - 1.;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    float inOutRadius = length(p.xy) - r;\n    float inOutHeight = abs(p.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n\nfloat GetDist(vec3 p)\n{\n    float S = sphereSDF(p, vec3(0,0,0), abs(sin(iTime)));\n    float S2 = sphereSDF(p, vec3(0,0.5f,0), abs(cos(iTime))*0.8f);\n    return intersectSDF(S,S2);\n}\n\nfloat RayMarching(vec3 ro, vec3 rd) {\n\tfloat depth = 0.0f;\n    for(int i = 0 ;i < MAX_STEPS; i ++) {\n\t\tvec3 pos = ro + depth * rd;\n        float dist = GetDist(pos);\n        depth += dist;\n        if(dist < SURFACE_DIST || depth > MAX_DIST)\n            break;\n    }\n    return depth;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(0.01f, 0.0f);   \n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td - GetDist(p - e.xyy),\n    \td - GetDist(p - e.yxy),\n    \td - GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, int idx)\n{\n    vec3 l = normalize(mainLight[idx].pos - p);\n    vec3 n = GetNormal(p);\n    float diff = clamp(dot(n ,l), 0., 1.);\n    float d = RayMarching(p + n * SURFACE_DIST, l);\n    if(d < length(mainLight[idx].pos - p))\n        diff *= .1;\n    return diff;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0f - F0) * pow(1.0f -cosTheta, 5.0f);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(0.0f, dot(N, H));\n    float NdotH2 = NdotH * NdotH;\n    \n    float nom = a2;\n    float denom = NdotH2 * (a2 - 1.0f) + 1.0f;\n    denom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = roughness + 1.0f;\n    float k = (r * r)/8.0f;\n    \n    float nom = NdotV;\n    float denom = NdotV * (1.0f - k) + k;\n    \n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N,V), 0.0f);\n    float NdotL = max(dot(N,L), 0.0f);\n    \n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n    \n    return ggx2 * ggx1;\n}\n\n\nvec3 pbrrender(vec3 ro, vec3 p)\n{\n    vec3 albedo = sphereColor;\n    float metallic = 0.4f;\n    float roughness = 0.8f;\n    float ao = 10.0f;\n    \n    vec3 Lo = vec3(0);\n    \n    vec3 n = GetNormal(p);\n    vec3 v = normalize(ro - p);\n    \n    vec3 ambient = vec3(0.03f) * albedo * ao;\n    \n    for(int i =0; i < LIGHT_NUM;i++){\n        vec3 l = normalize(mainLight[i].pos - p);\n        vec3 h = normalize(v+l);\n        float dis = distance(mainLight[i].pos, p);\n        float atte = 1.0f/(dis*dis);\n        vec3 radiance = mainLight[i].color * atte;\n    \n        vec3 F0 = vec3(0.04f);\n        F0 = mix(F0, albedo, metallic);\n        vec3 F = fresnelSchlick(max(0.0f, dot(n, h)), F0);\n        float NDF = DistributionGGX(n, h, roughness);\n        float G = GeometrySmith(n, v, l, roughness);\n    \n        vec3 nominator = NDF * G * F;\n        float denominator = 4.0f * max(dot(n,v),0.0f) * max(dot(n,l),0.0f) + 0.001f;\n        vec3 specular = nominator / denominator;\n    \n        vec3 kS = F;\n        vec3 kD = vec3(1) - kS;\n        kD *= (1.0f - metallic);\n        vec3 diffuse = kD * albedo / PI;\n    \n        float NdotL = max(dot(n,l),0.0f);\n        Lo += (diffuse + specular) * radiance * NdotL;\n    }\n    vec3 color = Lo + ambient;\n    color = color / (color + vec3(1.0f));\n    color = pow(color, vec3(1.0f/2.2f)); \n    return Lo + ambient;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mainLight[0].pos = rotateY(iTime*1.0f)*mainLight[0].pos;\n    mainLight[1].pos = rotateX(iTime*2.5f)*mainLight[1].pos;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv,1));\n    float d = RayMarching(ro, rd);\n    vec3 p = ro + rd * d;\n    //if(d >= SURFACE_DIST && d <= MAX_DIST)\n        fragColor = vec4(pbrrender(ro ,p), 1);\n}\n","name":"Image","description":"","type":"image"}]}