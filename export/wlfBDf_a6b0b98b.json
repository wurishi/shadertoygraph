{"ver":"0.1","info":{"id":"wlfBDf","date":"1597907201","viewed":156,"name":"bool cutaways","username":"pixlpa","description":"Trying out booleans and setting material based on outside/inside.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["volume","raymarch","bool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//global variables\n#define volume_iterations 7\n#define volume_step 0.004\n#define density 0.85\n#define max_distance 5.\n#define grad_step 0.0001\n#define stop_threshold 0.002\n#define maxiterations 100\n\nconst vec3 nn1 = normalize(vec3(-0.2,.5,1.));\n\nmat3 objRot = mat3(1.);\nmat3 obj2Rot = mat3(1.);\nmat3 frcRot = mat3(1.);\n\n\n//iq distance functions\n\nfloat sdfSphere(vec3 z, vec3 pos, float s){\n\tvec3 p = z-pos;\n\treturn length(p)-s;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdfNoise( vec3 p, float s)\n{\n  float v = triNoise3d(p*0.35)*0.5+snoise(p*1.3)*0.8;\n  return v*s;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}       \n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 opU( vec2 d1, vec2 d2 ){    \n\treturn (d1.x<d2.x) ? d1 : d2;    \n}\n\nvec2 opS( vec2 d1, vec2 d2 ){    \n\treturn (-d1.x>d2.x) ? d1*vec2(-1.,1.) : d2;    \n}\n\n\nvec2 map(vec3 z){\n    vec3 blip = vec3(iTime*1.25,iTime*0.74,iTime*3.);\n    vec3 blap = mix(random3(floor(blip)),random3(floor(blip+1.)),fract(blip));\n\tvec3 rotated = z*objRot;\n    vec3 inz = z*frcRot;\n    float b1 = sdfBox(inz-vec3(-0.25,0.,0.),vec3(0.1,1.5,1.5));\n    b1 = opUnion(sdfBox(inz-vec3(0.5,0.18,0.),vec3(1.,0.05,5.)),b1);\n    b1 = opUnion(sdfBox(inz-vec3(-0.5,-0.4+blap.z*0.3,0.25),vec3(0.5,0.5,0.5)),b1);\n    float b2 = opUnion(sdfBox(rotated-vec3(0.,0.,1.),vec3(0.5,0.5,0.35)),b1);\n    b2 = opUnion(sdfBox(rotated-vec3(blap.x*1.5,0.,0.25),vec3(0.1*blap.y+0.11,0.7,0.95)),b1);\n    float d1 = sdfOctahedron(z*obj2Rot,1.);\n\td1 = opSmoothUnion(sdfOctahedron(rotated-vec3(0.,0.,0.),1.),d1,0.25);\n    vec2 res = opS(vec2(b1,1.),vec2(d1,0.));\n    res = opS(vec2(b2,2.),res);\n\treturn res;\n}\n\nvec3 calcNormal(vec3 pos ){   \n\tvec3 eps = vec3( grad_step, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){    \n\tfloat result = -1.0;\n    float id = -1.;\n    float dist = stop_threshold*2.0;\n\n    for (int i = 0; i < maxiterations; i++) {\n        vec3 p = ro+rd*dist;\n        vec2 res = map(p);\n        if (res.x <= stop_threshold) break;\n        dist += res.x;\n        id = res.y; \n        if (dist >= max_distance) break;\n    }\n\n    result = dist;\n\tid = mix(id,-1.0,float(dist>max_distance));\n    \n    return vec2(result,id);   \n}\n\n//diffuse lighting calc\nvec3 calcLight(vec3 p, vec3 eye2, vec3 N, \n\t\t\t\t\t\t\tvec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos);\n    vec3 V = normalize(eye2 - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (dotLN);\n    }\n    return lightIntensity * (dotLN);\n}\n\n// procedural volume\n// maps position to color\n// based on https://www.shadertoy.com/view/ttSczc\nvec4 volumeFunc(vec3 p)\n{\n\treturn colornoise(p*objRot,8.5, 0.8);\n    //return vec4(smoothstep(0.,0.5,1.-length(mod(p*6.*objRot,2.)-1.)*0.8));\n}\n\nvec4 volumeMarch(vec3 rayOrigin, vec3 rayDir, vec3 lightDir)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tvec3 pos = rayOrigin;\n\tvec3 ref = rayDir;\n\tfloat dist = 0.005;\n\tfor(int i=0; i<volume_iterations; i++) {\n\t\tvec3 p = pos + ref * dist;\n\t\tdist += volume_step;\n\t\tvec4 vol = volumeFunc(p);\n        //using volume sample diff to get lighting\n        //based on https://www.shadertoy.com/view/XslGRr\n        float dif = clamp((vol.a + volumeFunc(p-0.01*lightDir).a)/.7, 0.0, 1.0 );\n\t\tsum.rgb += vol.rgb*vol.a*density*(dif*0.85);\n\t\tsum.a += vol.a*density;\n\t\tref = refract(rayDir, vol.xyz, 1./1.2);\n\t}\n\treturn abs(sum);\n}\n\n#define light_dir vec3(1.,-1.,0.95)\nvec3 render(vec2 res, vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.65,0.85,0.95)*0.25;\n\tif( res.y > -1. ) {\n\t\tvec3 p = ro +rd * res.x;\n\t\tvec3 norm = calcNormal(p);\n        vec3 pick = mix(vec3(0.8,.5,0.2)*0.85,vec3(0.,1.,1.3),clamp(res.y,0.,1.));\n        color += calcLight(p, ro, norm, \n\t\t\t\t\t\t\tlight_dir, pick); \n\t\t\n\t\tvec4 vol = volumeMarch(p, refract(rd,norm,1./1.95), light_dir);\n        vol.rgb = mix(vec3(dot(vol.rgb,vec3(0.333))),vol.rgb,0.15);\n\t\tvol.a = pow(vol.a,1.1);\n\t\tvol = clamp(vol,0.,1.);\n        vec3 stripes = mix(vec3(1.,0.7,0.),vec3(0.),step(0.8,mod(p.y*20.,1.)));\n\t\tcolor = mix(mix(color,mix(color,vol.rgb,vol.a),clamp(res.y,0.,1.)),stripes,clamp(res.y-1.,0.,1.));\n\t}\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\tvec3 ro = vec3(0.,0.,2.);\n\tvec3 ta = vec3(0.);\n\t\n\t//initialize globals\n\tobjRot = rot3Dmat(vec3(0.25,sin(sin(iTime*0.15)*2.+iTime*0.27),0.));\n    obj2Rot = rot3Dmat(vec3(sin(sin(iTime*0.15)*2.+iTime*0.27),0.5,0.5));\n\tfrcRot = rot3Dmat(vec3(sin(iTime*0.23)*2.5,0.,iTime*0.3));\n\n\tmat3 camMat = calcLookAtMatrix(ro, ta, 0.);\n\tvec3 rd = normalize(camMat * vec3(p.xy,2.0) );\n    vec2 res = calcIntersection(ro, rd);\n\tvec3 color = render(res,ro,rd);\n\n    // Output to screen\n    fragColor = mix(vec4(0.96,0.82,0.83,1.),vec4(color, 1.0),float(res.y>-0.5));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec4 colornoise(vec3 p, float rgboff, float simple){\n\tvec4 color = vec4(0.);\n\tvec3 pos = p+vec3(0.,0.,rgboff);\n\tcolor.r = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(0.,0.,-rgboff);\n\tcolor.g = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(0.,rgboff,0.);\n\tcolor.b = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(2.,0.,-rgboff);\n\tcolor.a = triNoise3d(pos*0.25)*simple+snoise(pos);\n\treturn color;\n}\n\n//Rotation matrix from euler (X/Y/Z) angles. http://glslsandbox.com/e#48064.5\nmat3 rot3Dmat(vec3 angles)\n{\n\tvec3 c = cos(angles);\n\tvec3 s = sin(angles);\n\t\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n\tmat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n\tmat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t\n\treturn rotX * rotY * rotZ;\n}\n\n//-----------------------------------------------------------------------------\n//Vectors\n//-----------------------------------------------------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}","name":"Common","description":"","type":"common"}]}