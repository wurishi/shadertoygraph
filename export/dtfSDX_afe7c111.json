{"ver":"0.1","info":{"id":"dtfSDX","date":"1675427671","viewed":87,"name":"3D Partiel GLSL","username":"Decnox","description":"Triforce de The Legend Of Zelda personnalis√©","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["triforce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c) - 0.5 * c;\n}\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 opU2(vec2 d1, vec2 d2)\n{\n    return (d1.x< d2.x) ? d1 : d2;\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  p.xz = rot(p.xz, iTime*2.0);\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 map(vec3 pos) {\n    float v = 0.0;\n    \n    vec2 prismForce = vec2(sdTriPrism(vec3(pos.x - 1.945, pos.y, pos.z), vec2(1.0,0.2)),0.0);\n    //vec3 prismForceX = prismForce.x;\n    //prismForceX.xz = rot(prismForceX.xz, iTime);\n    vec2 prismCourage = vec2(sdTriPrism(vec3(pos.x + -0.2, pos.y, pos.z), vec2(1.0,0.2)),1.0);\n    vec2 prismSagesse = vec2(sdTriPrism(vec3(pos.x - 1.075 , pos.y - 1.5, pos.z), vec2(1.0,0.2)),2.0);\n    \n    vec2 prism_with_materials = opU2(prismForce,prismCourage);\n    prism_with_materials = opU2(prism_with_materials,prismSagesse);\n    //v = opSmoothUnion(v, prismCourage, 0.1);\n    //v = opSmoothUnion(v, prismSagesse, 0.1);\n    \n    return prism_with_materials;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    float c = map(p).x;\n    vec2 eps = vec2(0.001,0.);\n    return normalize(vec3(\n    map(p+eps.xyy).x,\n    map(p+eps.yxy).x,\n    map(p+eps.yyx).x) - c);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd)  \n{\n    float contact = 0.0;\n    \n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = vec2(map(ro + rd * contact)); // TODO\n        \n        if(ray.x < (0.0001*contact))\n        {\n            return vec2(contact, ray.y);\n            //return float(i)/32.;\n        }\n        \n        contact += ray.x;\n    }\n    \n    return vec2(-1.0,0.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    vec2 contact = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(contact.x == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else // s'il y a contact\n    {\n        vec3 lightPos = vec3(sin(iTime) * 10.0, cos(iTime) * -10.0 + -7.0, -10.0);\n        vec3 lightTar = vec3(0.0, 0.0, 0.0);\n        vec3 lightDir = normalize(lightTar - lightPos);\n        \n        vec3 nor = getNormal(ro + rd * contact.x);\n        \n        float lambert = clamp(dot(nor, lightDir),0.6,1.0);\n        float toon = step(lambert, 0.5);\n        float stoon = smoothstep(lambert, 0.4, 0.6);\n        float fresnel = pow(dot(nor, rd)+0.8,3.0);\n        \n        if(contact.y == 0.0){\n        \n            col = vec3(0.0,0.5,0.0) * (lambert) + pow(lambert,64.) + (fresnel); //Blinn (normalement)\n        }\n        \n        else if(contact.y == 1.0){\n          col = vec3(0.0,0.0,0.5) * (lambert) + pow(lambert,64.) + (fresnel); //Blinn (normalement)  \n        }\n        \n        else{\n           col = vec3(0.5,0.0,0.0) * (lambert) + pow(lambert,64.) + (fresnel); //Blinn (normalement)\n          col += fresnel;\n        }\n        vec3 ref = reflect(rd,nor);\n        vec3 cub = texture( iChannel0, ref).xyz;\n        col += fresnel;\n        col += cub/2.0;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x +=0.5;\n    \n    uv.y += 0.4;\n    \n    vec3 cameraPos = vec3(sin(iTime)*5.0, cos(iTime), 4.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    //cameraPos.xz = rot(cameraPos.xz, iTime);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n\n    vec3 col = render(cameraPos, viewDir);\n    \n    //col = palette(col.x, vec3(0.5), vec3(0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.2, 0.25));//LA COULEUR\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}