{"ver":"0.1","info":{"id":"wsXGDf","date":"1547647899","viewed":209,"name":"Triangle Interpolation Algos","username":"antl","description":"This is a shader that implements different triangle interpolation variants.\nThe list is not exhaustive.\n\nThese algorithms are intentionally not optimized in order to remain close to their underlying reasonings.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["triangle","intersection","interpolation","algorithm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 1 :\n// 1) For each segment, check if the point is on the right or left side.\n// 2) If the point is on the same side for all the segments, the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 edgeSide(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    vec3 N_AB = cross(B-A, N); // Normal to AB vector\n    vec3 N_BC = cross(C-B, N); // Normal to BC vector\n    vec3 N_CA = cross(A-C, N); // Normal to CA vector\n    \n    float dir_N_AB = dot(I-A, N_AB);\n    float dir_N_BC = dot(I-B, N_BC);\n    float dir_N_CA = dot(I-C, N_CA);\n    \n    bool all_positive = (dir_N_AB >= 0.0) && (dir_N_BC >= 0.0) && (dir_N_CA >= 0.0);\n    bool all_negative = (dir_N_AB <= 0.0) && (dir_N_BC <= 0.0) && (dir_N_CA <= 0.0);\n    isIn = all_positive || all_negative;\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float a = dot(I-B, N_BC); // Orthogonal distance from I to BC\n        float b = dot(I-C, N_CA); // Orthogonal distance from I to CA\n        float c = dot(I-A, N_AB); // Orthogonal distance from I to AB\n        \n        float sum = a+b+c;\n        a /= sum;\n        b /= sum;\n        c /= sum;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 2 :\n// 1) Form 4 triangles from your point I : AIB, BIC, CIA and ABC.\n// 2) Compute the areas. [formula: area(XYZ)=0.5*length(cross(Y-X,Z-X))]\n// 2) If area(AIB)+area(BIC)+area(CIA)=area(ABC), the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 areas(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    float areaAIB = 0.5*length(cross(I-A, B-A));\n    float areaBIC = 0.5*length(cross(I-B, C-B));\n    float areaCIA = 0.5*length(cross(I-C, A-C));\n    float areaABC = 0.5*length(cross(B-A, C-A));\n    \n    isIn = abs((areaAIB+areaBIC+areaCIA)-areaABC) < 0.001;\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float a = areaBIC/areaABC;\n        float b = areaCIA/areaABC;\n        float c = areaAIB/areaABC;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 3 :\n// 1) Form 3 triangles from your point I : AIB, BIC and CIA.\n// 2) Compute the signed areas. [formula: signedArea(XYZ)=dot(0.5*(cross(Y-X,Z-X)),N), with N the triangle's normal]\n// 2) If the signs are all the same, the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 areasSigned(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    float signedAreaAIB = dot(0.5*(cross(I-A, B-A)),N);\n    float signedAreaBIC = dot(0.5*(cross(I-B, C-B)),N);\n    float signedAreaCIA = dot(0.5*(cross(I-C, A-C)),N);\n    \n    bool all_positive = (signedAreaAIB >= 0.0) && (signedAreaBIC >= 0.0) && (signedAreaCIA >= 0.0);\n    bool all_negative = (signedAreaAIB <= 0.0) && (signedAreaBIC <= 0.0) && (signedAreaCIA <= 0.0);\n    isIn = all_positive || all_negative;\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float areaABC = 0.5*length(cross(B-A, C-A));\n        \n        float a = abs(signedAreaBIC)/areaABC;\n        float b = abs(signedAreaCIA)/areaABC;\n        float c = abs(signedAreaAIB)/areaABC;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 4 :\n// 1) Rewrite the point, I, as (I-A)=u*(B-A)+v*(C-A). [which is also I=(1-u-v)*A+u*B+v*C, barycentric coordinates]\n// 2) Compute u and v. [to get u, first cross product the equation with (C-A), then project along the face normal N; then similarly to get v]\n// 2) If u and v are in [0,1] and u+v<=1, the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 uvCoord(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    float u = dot(cross(I-A,C-A),N)/dot(cross(B-A,C-A),N);\n    float v = dot(cross(I-A,B-A),N)/dot(cross(C-A,B-A),N);\n    \n    isIn = (u >= 0.0) && (v >= 0.0) && (u+v <= 1.0);\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float a = 1.0-u-v;\n        float b = u;\n        float c = v;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n\n\n\n\n\n\n\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Help functions, for text and drawing /////////////////////////////////////////////////////////////////\n#define C(c) U.x-=0.5; T += (U.x<0.0||U.x>1.0||U.y<0.0||U.y>1.0) ? vec4(0) : textureGrad(iChannel3, U/16.0 + fract(vec2(c, 15-c/16)/16.0), dFdx(U/16.0), dFdy(U/16.0))\n#define initMsg vec4 T = vec4(0); U.x+=0.5;\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\n// Write \"Edge Side\"\nfloat string_Method1(vec2 U) {\n    initMsg;\n    C(69);C(100);C(103);C(101);\n    C(32);\n    C(83);C(105);C(100);C(101);\n    endMsg;\n}\n\n// Write \"Areas\"\nfloat string_Method2(vec2 U) {\n    initMsg;\n    C(65);C(114);C(101);C(97);C(115);\n    endMsg;\n}\n\n// Write \"Signed Areas\"\nfloat string_Method3(vec2 U) {\n    initMsg;\n    C(83);C(105);C(103);C(110);C(101);C(100);\n    C(32);\n    C(65);C(114);C(101);C(97);C(115);\n    endMsg;\n}\n\n// Write \"Barycentric UV Coordinates\"\nfloat string_Method4(vec2 U) {\n    initMsg;\n    C(66);C(97);C(114);C(121);C(99);C(101);C(110);C(116);C(114);C(105);C(99);\n    C(32);\n    C(85);C(86);\n    C(32);\n    C(67);C(111);C(111);C(114);C(100);C(105);C(110);C(97);C(116);C(101);C(115);\n    endMsg;\n}\n\n// Write \"A\"\nfloat string_A(vec2 U) {\n    initMsg;\n    C(65);\n    endMsg;\n}\n\n// Write \"B\"\nfloat string_B(vec2 U) {\n    initMsg;\n    C(66);\n    endMsg;\n}\n\n// Write \"C\"\nfloat string_C(vec2 U) {\n    initMsg;\n    C(67);\n    endMsg;\n}\n\n// Draw a point\nvec3 drawPoint(in vec3 X, in vec3 I, in float radius, in vec3 color)\n{\n    if (length(I-X) <= radius)\n    {\n        if (int(floor(length(I-X)/radius*3.0))%2 == 0)\n        {\n        \treturn color;\n        }\n    }\n\treturn vec3(0.0);\n}\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 I = vec3((2.0*fragCoord.xy-iResolution.xy)/iResolution.y*1.5, 1.0);\n    \n    // Triangle definition\n    float m = 0.5;\n\tvec3 A = vec3(cos(iTime*m + vec2(0.0,2.00) + 0.0), 1.0);\n    vec3 B = vec3(cos(iTime*m + vec2(0.0,1.50) + 1.5), 1.0);\n\tvec3 C = vec3(cos(iTime*m + vec2(0.0,3.00) + 4.0), 1.0);\n    \n    // Mouse manipulation\n    if (iMouse.z>=1.0)\n    {\n        vec3 Click = vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y*1.5, 1.0);\n        A = Click;\n    }\n    \n    // Interpolation in the triangle, according to a given method\n    float method = mod(floor(iTime/5.0), 4.0)+1.0;\n    bool isIn;\n    vec3 col;\n    if (method==1.0)\n    {\n    \tcol = edgeSide(A,B,C,I,isIn);\n        col = max(col,string_Method1(fragCoord.xy*0.02));\n    }\n    else if (method==2.0)\n    {\n    \tcol = areas(A,B,C,I,isIn);\n        col = max(col,string_Method2(fragCoord.xy*0.02));\n    }\n    else if (method==3.0)\n    {\n    \tcol = areasSigned(A,B,C,I,isIn);\n        col = max(col,string_Method3(fragCoord.xy*0.02));\n    }\n    else if (method==4.0)\n    {\n    \tcol = uvCoord(A,B,C,I,isIn);\n        col = max(col,string_Method4(fragCoord.xy*0.02));\n    }\n\n    // Draw the vertices\n    if (!isIn)\n    {\n        col = max(col,drawPoint(A,I,0.07,vec3(1.0,0.0,0.0)));\n    \tcol = max(col,drawPoint(B,I,0.07,vec3(0.0,1.0,0.0)));\n    \tcol = max(col,drawPoint(C,I,0.07,vec3(0.0,0.0,1.0)));\n    }\n    \n    // Draw the labels\n    vec3 pA = A+0.2*normalize(normalize(A-B)+normalize(A-C));\n    vec3 pB = B+0.2*normalize(normalize(B-C)+normalize(B-A));\n    vec3 pC = C+0.2*normalize(normalize(C-A)+normalize(C-B));\n    \n    col = max(col,vec3(string_A((I.xy-pA.xy)*5.0+0.5),0.0,0.0));\n    col = max(col,vec3(0.0,string_B((I.xy-pB.xy)*5.0+0.5),0.0));\n    col = max(col,vec3(0.0,0.0,string_C((I.xy-pC.xy)*5.0+0.5)));\n\n    \n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}