{"ver":"0.1","info":{"id":"3tjcRK","date":"1699413495","viewed":51,"name":"Volume Rendering Cloud","username":"Johnblu","description":"体积渲染的云，希望加入阴影使之更加立体。","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fov 60.0\n#define cloudHeight 9.0\n#define cloudOffset -18.0\n\n#define skyCol vec4(0.5,0.7,0.8,1.0)\n//#define slightCloudCol vec4(0.8,0.8,0.7,1)\n//#define heavyCloudCol vec4(0.9,0.9,0.8,1)\n#define slightCloudCol vec4(0.95,0.95,0.9,1)\n#define heavyCloudCol vec4(0.9,0.9,0.8,1)\n\nfloat hash31(vec3 p)\n{\n    p = vec3( dot(p,vec3(612.1,946.7,108.4)),\n              dot(p,vec3(735.5,354.3,304.9)),\n              dot(p,vec3(435.2,861.6,232.6)));\n    \n    float vertexValue = -1.0 + 2.0 * fract(sin(p.z + p.x + p.y)*(455835.53));\n    vertexValue = sin(vertexValue * 3.1415926 + iTime * 0.2);\n    return vertexValue;\n}\nfloat value_noise_cloud(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n\t\n    //以下两个是前人提出的缓和曲线\n    //vec3 w = pf * pf * (3.0 - 2.0 * pf);\t//一阶导数连续\n    vec3 w = pf * pf * pf * (pf * pf * 6.0 - pf * 15.0 + 10.0);\t//二阶导数连续\n\t\n    float point000 = hash31(pi + vec3(0.0, 0.0, 0.0));\n    float point100 = hash31(pi + vec3(1.0, 0.0, 0.0));\n    float point010 = hash31(pi + vec3(0.0, 1.0, 0.0));\n    float point110 = hash31(pi + vec3(1.0, 1.0, 0.0));\n    float point001 = hash31(pi + vec3(0.0, 0.0, 1.0));\n    float point101 = hash31(pi + vec3(1.0, 0.0, 1.0));\n    float point011 = hash31(pi + vec3(0.0, 1.0, 1.0));\n    float point111 = hash31(pi + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(point000, point100, w.x), \n               \tmix(point010, point110, w.x),\n               \tw.y),\n           \tmix(mix(point001, point101, w.x), \n               \tmix(point011, point111, w.x),\n               \tw.y),\n           \t\tw.z);\n}\n\nfloat hash21(vec2 p)\n{\n    p = vec2( dot(p,vec2(612.1,946.7)),\n              dot(p,vec2(735.5,354.3)));\n    \n    float vertexValue = -1.0 + 2.0 * fract(sin(p.x + p.y)*(4558.5353));\n    vertexValue = sin(vertexValue * 3.1415926 + iTime * 0.2);\n    return vertexValue;\n}\nfloat value_noise_height(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\t\n    //以下两个是前人提出的缓和曲线\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\t//一阶导数连续\n    vec2 w = pf * pf * pf * (pf * pf * 6.0 - pf * 15.0 + 10.0);\t//二阶导数连续\n\n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x), \n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat noiseValue(vec3 worldPos)\n{\n    vec3 cloudPos = worldPos * 0.01;\n    float cloudResult = 0.0;\n    cloudResult += 4.0 / 7.0 * abs(value_noise_cloud(cloudPos));\t\tcloudPos *= 2.0;\n    cloudResult += 2.0 / 7.0 * abs(value_noise_cloud(cloudPos));\t\tcloudPos *= 2.0;\n    cloudResult += 1.0 / 7.0 * abs(value_noise_cloud(cloudPos));\t\tcloudPos *= 2.0;\n    \n    vec2 heightPos = worldPos.xz * 0.04;\n    float heightResult = 0.0;\n    heightResult += 2.0 / 3.0 * abs(value_noise_height(heightPos));\t\theightPos *= 2.0;\n    heightResult += 1.0 / 3.0 * abs(value_noise_height(heightPos));\t\theightPos *= 2.0;\n    heightResult = 1.0 - heightResult;\t//噪音图形状决定\n    \n    float heightFade = clamp((cloudHeight + cloudOffset * heightResult) - worldPos.y,0.0,1.0);\n    cloudResult *= heightFade;\n    \n    return cloudResult;\n}\n\nfloat intersects(vec3 camPos, vec3 viewDir)\n{\n    float magnitude = 10.0;\n    vec3 beginPos = camPos + viewDir * magnitude;\n    vec3 endPos = camPos + viewDir * (magnitude + 150.0);\n    \n    float sum = 0.0;\n    for (float i = 0.0; i <= 1.0; i += 0.01)\n    {\n        vec3 pos = mix(beginPos, endPos, i);\n        float v = noiseValue(pos);\n        sum += v;\n    }\n    sum = clamp(sum * 0.015,0.0,1.0);\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //摄像机旋转,拖动屏幕可以旋转摄像机\n    float radianY = mix(-3.1415926,3.1415926,-iMouse.x / iResolution.x);\n    vec3 tmpCamY0 = vec3(cos(radianY),0,sin(radianY));\n    vec3 tmpCamY1 = vec3(0,1,0);\n    vec3 tmpCamY2 = vec3(-sin(radianY),0,cos(radianY));\n    mat3 rotCamY = mat3(tmpCamY0,tmpCamY1,tmpCamY2);\n    \n    float radianX = mix(-3.1415926 * 0.2,3.1415926 * 0.2,iMouse.y / iResolution.y);\n    vec3 tmpCamX0 = vec3(1,0,0);\n    vec3 tmpCamX1 = vec3(0,cos(radianX),-sin(radianX));\n    vec3 tmpCamX2 = vec3(0,sin(radianX),cos(radianX));\n    mat3 rotCamX = mat3(tmpCamX0,tmpCamX1,tmpCamX2);\n    \n    //摄像机旋转结束\n    \n    vec2 uv = (vec2(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0) / max(iResolution.x, iResolution.y)) * 2.0;\n    float tanValue = tan(radians(fov * 0.5));\n    float cameraDis = (iResolution.y / iResolution.x) / tanValue;\n    vec3 viewDir = normalize(vec3(uv, cameraDis));\t//这里通过fov确定每个像素的观察方向\n    viewDir = rotCamY * rotCamX * viewDir;\n    vec3 camPosition = vec3(0,0,iTime * 10.0);\n    \n    float cloudValue = intersects(camPosition, viewDir);\n    cloudValue = smoothstep(0.0,1.0,cloudValue);\n    //cloudValue = smoothstep(0.0,1.0,cloudValue);\n    //cloudValue = smoothstep(0.0,1.0,cloudValue);\n    fragColor = mix(skyCol, mix(slightCloudCol, heavyCloudCol, cloudValue), cloudValue);\n    return;\n}","name":"Image","description":"","type":"image"}]}