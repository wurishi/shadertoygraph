{"ver":"0.1","info":{"id":"3s3XzB","date":"1572238219","viewed":373,"name":"UnitDiskToSphere","username":"TinyTexel","description":"A mapping from the unit disk to the sphere that can be used with low-discrepancy sequences.\nAt the moment, the distribution quality degenerates towards the bottom pole. Any ideas for a potential fix?\ncamera controls via mouse (hold shift to zoom)","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["sphere","mapping","sequence","disk","lowdiscrepancy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2019 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nA mapping from the unit disk to the sphere that can be used with low-discrepancy sequences.\nAt the moment, the distribution quality degenerates towards the bottom pole.\ncamera controls via mouse (hold shift to zoom)\n*/\n\n// use this to show how the distribution quality degenerates towards the bottom pole\n//#define USE_EVENLY_SPACED_POINTS\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\nconst float Pi025 = Pi * 0.25;\nconst float Phi    = 1.61803399;\nconst float PhiRcp = 0.61803399;\n\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\nfloat Erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n\nfloat Erf1(float xx)\n{\n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return y;\n}\n\nfloat ErfI(float x)\n{\n    //x = Erf(x);\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(max(0.0000001, 1.0 - x*x));\n    float c = u * 0.5 + b;\n    \n    //float y = sqrt(sqrt(c*c - u*a) - c);    \n    float y = sqrt(max(0.0, sqrt(max(0.0, c*c - u*a)) - c));\n\n    //float o = rsqrt(c*c - u*a);\n    //float y = rsqrt(o / (1.0 - c*o));\n    \n    return neg ? -y : y;\n}\n\nfloat ErfI1(float x)\n{\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(max(0.0000001, 1.0 - x*x));\n    float c = u * 0.5 + b;\n    \n    return sqrt(max(0.0, c*c - u*a)) - c;\n}\n\nfloat cdf(float x)\n{\n    return 0.5*(1.0-Erf(-x/sqrt(2.0)));\n}\n\nfloat icdf(float x)\n{\n    return -sqrt(2.0)*ErfI(-2.0*x+1.0);\n}\n\nfloat Erf2(float x)\n{\n    bool neg = x < 0.0;\n    x = abs(x);\n    \n    const float p = 0.3275911;\n    const float a1 = 0.254829592;\n    const float a2 =-0.284496736;\n    const float a3 = 1.421413741;\n    const float a4 =-1.453152027;\n    const float a5 = 1.061405429;\n    \n   // a1 = 0.254829592, a2 = −0.284496736, a3 = 1.421413741, a4 = −1.453152027, a5 = 1.061405429\n    float t = 1.0/(1.0 + p*x);\n    \n    float y = 1.0 - (a1*t + a2*t*t + a3*t*t*t + a4*t*t*t*t + a5*t*t*t*t*t) * exp(-x*x);\n\n    return neg ? -y : y;\n}\n//#define Erf Erf2\n\n// p: [-1,1]² | return u: [-1,1]²\nvec2 DiskFromSquare(vec2 p)\n{\n    vec2 sgn = vec2(p.x < 0.0 ? -1.0 : 1.0, \n                    p.y < 0.0 ? -1.0 : 1.0);    \n    \n    vec2 vv = vec2(ErfI1(p.x), ErfI1(p.y));\n    \n    float w = vv.x+vv.y;\n    \n    vec2 uu = vv * ((1.0-exp(-w)) / w);\n    \n    vec2 u = sqrt(uu) * sgn;\n    \n    return u;\n}\n\n// u: [-1,1]² | return p: [-1,1]²\nvec2 SquareFromDisk(vec2 u)\n{\n    vec2 sgn = vec2(u.x < 0.0 ? -1.0 : 1.0, \n                    u.y < 0.0 ? -1.0 : 1.0);\n\n    vec2 uu = u*u;\n    \n    float m = uu.x+uu.y;\n    \n    vec2 vv = uu * (-log(1.0-m) / m);\n    \n    vec2 p = vec2(Erf1(vv.x), \n                  Erf1(vv.y)) * sgn;\n                \n    return p;                \n}\n\nvec2 ToUnitDiskX(vec2 p) \n{\nreturn DiskFromSquare(p*2.0-1.0);\n//return p*2.0-1.0;\n    float a = p.x;// * 2.0 - 1.0;\n    float b = p.y;// * 2.0 - 1.0;\n    \n    vec2 v = vec2(ErfI(a*2.0-1.0), ErfI(b*2.0-1.0));\n    \n   #if 0\n    v = vec2(cos(a*Pi*2.0), sin(a*Pi*2.0))*sqrt(-log(1.0-b));\n   #endif\n    \n    vec2 dir = normalize(v);\n    \n    float l = sqrt(1.0-exp(-dot(v,v)));\n    \n    vec2 u = v*sqrt((1.0-exp(-dot(v,v)))/dot(v,v));\n    \n    //u = normalize(u) * sqrt(-log(1.0-dot(u,u)));\n    \n    //u = u * sqrt(-log(1.0-dot(u,u))/dot(u,u));\n    //u = vec2(Erf(u.x), Erf(u.y));\n    \n    vec2 sgn = vec2(u.x < 0.0 ? -1.0 : 1.0, \n                    u.y < 0.0 ? -1.0 : 1.0);\n\n    vec2 uu = u*u;\n    \n    float m = uu.x+uu.y;\n    \n    vec2 n = uu * (-log(1.0-m) / m);\n    \n    return vec2(Erf1(n.x), \n                Erf1(n.y))*sgn;\n    \n    return u;\n    \n    return v/sqrt(dot(v,v) /(1.0-exp(-dot(v,v))));\n    return normalize(v) * l;\n    return vec2(Erf(v.x), 0.0);\n\treturn v;    \n    \n     l = cdf((length(v)*2.0-1.0)*0.7);\n    \n    return vec2(cdf(icdf(a)), 0.0);\n    \n    return dir * l;    \n}\n\n// http://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\nvec2 ToUnitDisk(vec2 p) \n{\n    float phi, r;\n    float a = p.x * 2.0 - 1.0;\n    float b = p.y * 2.0 - 1.0;\n\n    if (abs(a) > abs(b))\n    { \n        r = a;\n        phi = Pi025 * (b / a);\n    } \n    else \n    {\n        r = b;\n        phi = Pi05 - Pi025 * (a / b);\n    }\n    \n    return r * vec2(cos(phi), sin(phi));\n}\n\n#define ToUnitDisk ToUnitDiskX\n\nvec3 UnitDiskToHemisphere(vec2 p)\n{\n    float s = dot(p, p);\n    float l = sqrt(2.0 - s);\n    \n    return vec3(p.x * l, 1.0 - s, p.y * l);\n}\n\nvec3 UnitDiskToSphericalCap(vec2 p, float cosA)\n{\n    p *= sqrt(1.0 - cosA);// pre-comp this factor in practice\n    float s = dot(p, p);\n    float l = sqrt(2.0 - s);\n    \n    return vec3(p.x * l, 1.0 - s, p.y * l);\n}\n\n/*\nvec2 UnitSphere_to_UnitDisk(vec3 p)\n{\n    return p.xy * inversesqrt(p.z * 2.0 + 2.0);\n}\n\nvec3 UnitDisk_to_UnitSphere(vec2 p)\n{\n    float s = dot(p, p);\n    float l = sqrt(4.0 - 4.0 * s);\n    \n    return vec3(p.xy * l, 1.0 - 2.0 * s);\n}\n*/\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere0(float s0, float s1)\n{\n    float phi = s0 * Pi;\n    \n    float cosPhi = cos(phi);\n    float sinPhi = sin(phi);\n    \n    float cosTheta = s1;\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    \n    return vec3(cosPhi * sinTheta, \n                         cosTheta, \n                sinPhi * sinTheta);\n}\n\nvec2 SphereToUnitDisk(vec3 p)\n{\n    return p.xz * inversesqrt(p.y * 2.0 + 2.0);\n}\n\n// multiple approaches with equivalent results:\n#if 1\nvec3 UnitDiskToSphere(vec2 u)\n{\n    float cosTheta = 1.0 - 2.0 * dot(u, u);\n\n#if 0\n\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    \n    vec2 dir = normalize(u);\n    \n    float cosPhi = dir.x;\n    float sinPhi = dir.y;\n\n    return vec3(cosPhi * sinTheta, \n                         cosTheta, \n                sinPhi * sinTheta);\n#elif 1\n\n   #if 0\n    float l = (1.0/sqrt(dot(u, u))) * sinTheta;\n   #elif 0\n    float l = sqrt((sinTheta * sinTheta) / dot(u, u));\n   #elif 0\n    float l = sqrt((1.0 - (1.0 - 4.0*dot(u,u) + 4.0*dot(u,u)*dot(u,u))) / dot(u, u));\n   #elif 1\n    float l = sqrt(4.0 - 4.0 * dot(u,u));\n   #endif\n   \n    return vec3(u.x * l, cosTheta, u.y * l);\n    \n#endif\n}\n\n#elif 1\nvec3 UnitDiskToSphere(vec2 p)\n{\n    float s = dot(p, p);\n    float l = sqrt(4.0 - 4.0 * s);\n    \n    return vec3(p.x * l, \n                1.0 - 2.0 * s, \n                p.y * l);\n}\n#elif 1\n// my second attempt: applies the inverse of smpl_cos = normalize(smpl_sph + vec3(0, 1, 0)) after vertical projection\nvec3 UnitDiskToSphere(vec2 p)\n{\n    float hsqr = 1.0 - dot(p, p);\n    float h = sqrt(hsqr);\n    \n    vec3 r = vec3(p.x * h, hsqr, p.y * h);\n\n    return r * 2.0 - vec3(0.0, 1.0, 0.0);\n}\n#else\n// my first attempt; also based on UnitDiskToHemisphere\nvec3 UnitDiskToSphere(vec2 p)\n{\n    float s = dot(p, p);\n\n    if(s == 0.0) return vec3(0.0, 1.0, 0.0);\n    \n    vec2 dir = p * inversesqrt(s);\n    \n    float hs = s < 0.5 ? 1.0 : -1.0;\n    s = s < 0.5 ? s * 2.0 : s * -2.0 + 2.0;\n    \n    float l = sqrt((2.0 - s) * s);\n    \n    return vec3(dir.x * l, (1.0 - s) * hs, dir.y * l);\n}\n\n// unoptimized function for reference\n//vec3 UnitDiskToSphere(vec2 p)\n//{\n//    float len = length(p);\n//    vec2 dir = p / len;\n//    float len2 = len * len;\n//    \n//    float hs;\n//    if(len2 < 0.5)\n//    {\n//        hs = 1.0;\n//        p = dir * sqrt(len2 * 2.0);\n//    }\n//    else\n//    {\n//        hs = -1.0;\n//        p = dir * sqrt(1.0 - (len2 * 2.0 - 1.0));\n//    }\n//    \n//    float s = dot(p, p);\n//    float l = sqrt(2.0 - s);\n//    \n//    return vec3(p.x * l, (1.0 - s) * hs, p.y * l);\n//}\n#endif\n\n#define Frame float(iFrame)\n#define Time iTime\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(s1);\n    \n    return vec2(cos(ang), sin(ang)) * s1p;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\nvec2 Roberts(uint i)\n{\n    //\n    //return vec2(i * uvec2(2882110344, 3518319154)) * (1.0 / 4294967296.0);\n    return vec2(i * uvec2(2447445413u, 3242174889u)) * (1.0 / 4294967296.0);\n    //return vec2(i * uvec2(3242174889u, 2447445413u)) * (1.0 / 4294967296.0);\n    //return fract(vec2(i * uvec2(12664745u, 9560333u)) / 16777216.0);\n}\n\n//  Owen Scrambled Sobol Sequence: https://www.shadertoy.com/view/3ldXzM\nuvec2 Sobol(uint n) \n{\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; n != 0u; n >>= 1u) {\n        if((n & 1u) != 0u)\n            p ^= d;\n        \n        d.x >>= 1u; // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\nuint LCG1(uint n) {\n    return (n * 1664525u) + 1013904223u; // from Numerical Recipes\n}\n\nuint LCG2(uint n) {\n    return (n * 1103515245u) + 12345u; // from glibc\n}\n\nuint OwenScramble(uint p, uint s) \n{\n    s = LCG2(s);\n    \n    for(uint i = 1u << 31u; i > 0u; i >>= 1u) {\n        if(s > 0x80000000u)\n            p ^= i;\n        \n        if((p & i) == 0u)\n            s = LCG1(s);\n        else\n            s = LCG2(s);\n    }\n    \n    return p;\n}\n\nuint PhiHash(uvec2 uv)\n{\n    const uint r0 = 3242174893u;// prime[(2^32-1) / phi_2  ]\n    const uint r1 = 2447445397u;// prime[(2^32-1) / phi_2^2]\n    \n    uint h = ((uv.x * r0) ^ (uv.y * r1)) * r0;\n    \n    return h;\n}\n\nfloat Float01(uint x) { return float(x)      * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nfloat Hash01(inout uint h)\n{\n    h = h * 2654435761u + 1u;\n    return Float01(h * 2447445413u);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = h * 2654435761u + 1u;\n    return Float11(h * 2447445413u);\n}\n\nfloat CircDistrInvCDF(float x)\n{\n    x = x * 2.0 - 1.0;\n    \n    //1 - 1/4 (-3 Sqrt[3] + ((8 + 3 Sqrt[3])^(2/3) - (-3 + (8 + 3 Sqrt[3])^(2/3)) x)^(3/2))^(2/3)\n        \n    const float a = pow(8.0 + 3.0 * sqrt(3.0), 2.0/3.0);\n    const float o = - (-3.0 + a);\n    const float b = -3.0 * sqrt(3.0);\n    \n    float t0 = a + o * abs(x);\n    \n    float t1 = 1.0 - 0.25 * pow(b + t0 * sqrt(t0), 2.0/3.0);\n    \n    return x > 0.0 ? t1 : -t1;\n}\n\nvec2 ToUnitDiskC(vec2 p)\n{    \n    vec2 p0 = p * 2.0 -1.0;\n    float x = CircDistrInvCDF(p.x);\n    \n    return vec2(x, sqrt(1.0 - x*x) * (p.y * 2.0 - 1.0));\n}\n\n// Box-Muller Transform: \n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n// u (0..1] | v [-1..1]\nvec2 Sample_Gauss2D(float u, float v)\n{\n    float l = sqrt(-2.0 * log(u));\n    \n    return vec2(cos(v * Pi), sin(v * Pi)) * l;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n\nfloat EvalSceneCol(\n    vec3 rp, Cam cam, vec2 uv0, bool right)\n{\n    float col = 0.0;\n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n        \n    if(right)\n    {      \n        vec3 rd = NewRay(cam, tex21);\n    \n        vec2 t; vec3 n; vec3 a;\n        float hit = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 1.0, OUT t);\n    \n        \n        if(hit > 0.0)// RIGHT ----------------------------------------------------------------------\n        {\n\t\t\tvec3 p = rp + rd * t.x;           \n            \n            col = 0.0;\n            \n            //if(p.y < 0.0) col = 0.05; else\n            //for(uint i = 0u; i < 4096u; ++i)            \n            for(uint i = 0u; i < 1024u*1u; ++i)\n            //for(uint i = 0u; i < (uint(iFrame) % 1024u) * 4u; ++i)                \n            {\n                #ifndef USE_EVENLY_SPACED_POINTS\n                vec2 u = Roberts(i);\n                #else\n                vec2 u = vec2(i % 32u, i / 32u) / 31.0;\n                #endif\n                \n                u = ToUnitDiskX(u);\n            \t//u = vec2(cos(u.x * Pi * 2.0), sin(u.x * Pi * 2.0)) * sqrt(abs(u.y*2.0-1.0)) * (u.y < 0.5 ? -1.0 : 1.0);\n           \t\t//u = ToUnitDisk(abs(u*2.0-1.0));\n                \n                //vec3 v = vec3(u.x, sqrt(1.0 - dot(u, u)), u.y);// vertical proj -> cosine distr\n                //vec3 v = UnitDiskToSphericalCap(u, cos(Pi * 0.25));\n                //u = Sample_Disk(float(i) * PhiRcp * 2.0, (float(i) + 0.5) / 1024.0);\n                \n                vec3 v = UnitDiskToSphere(u);\n                //v = Sample_Sphere(u.x * 2.0 - 1.0, u.y * 2.0 - 1.0);\n                //v = Sample_Sphere(float(i) * PhiRcp * 2.0, (float(i) + 0.5) / 1024.0 * 2.0 - 1.0);\n                //v = Sample_Sphere(float(i) * PhiRcp * 2.0, (float(i) + 6.0) / (1024.0 + 11.0) * 2.0 - 1.0);\n                //if(i ==    0u) v = vec3(0.0, -1.0, 0.0);\n                //if(i == 1023u) v = vec3(0.0,  1.0, 0.0);\n                if(false)\n                {\n                    vec3 N = vec3(0.0, 1.0, 0.0);\n                    \n                    if(dot(N, v) < 0.0) v = -v;\n                    \n                    float c = dot(N, v);\n                    \n                    v = (v - c * N) * c + c*c * N;\n                    //v = vec3(v.x * c, c*c, v.z * c); \n                    \n                    //v.xz *= c;\n                    \n                    v -= N * 0.5;\n                    v *= 2.0;\n                    //v = v * 2.0 - N;\n                }\n                \n                if(false)\n                {\n                    // sphere to hemi-sphere\n                    vec3 N = normalize(vec3(0.0, 1.0, 1.0));\n                    \n                    v = normalize(v + N);\n                    \n                    vec3 p = v - dot(N, v) * N;\n                    \n                    float s = dot(p, p);\n    \t\t\t\tfloat l = sqrt(2.0 - s);\n    \n                    v = p * l + N * (1.0 - s);\n    \t\t\t\t//v = vec3(p.x * l, 1.0 - s, p.y * l);\n                }\n                \n                \n                float m = length(v - p);\n                \n                col += clamp(clamp(mix(1.0, 0.0, m * 128.0), 0.0, 1.0) * 4.0, 0.0, 1.0) * 0.75;\n                //col = max(col, clamp(clamp(mix(1.0, 0.0, m * 128.0), 0.0, 1.0) * 4.0, 0.0, 1.0));\n            }\n            \n            //if(sqrt(1.0 - p.y*p.y) < sin(Pi * 0.25)) col = mix(col, 1.0, 0.2);// highlight spherical cap\n            if(p.y < 0.0) col = mix(col, 1.0, 0.08);// make lower hemisphere brighter\n            if(abs(p.y) > 0.995 && abs(p.y) < 0.999) col = mix(col, 1.0, 0.1);// rings around poles\n            \n        }\n        else\n        {\n           col = 0.11;           \n        }\n    }\n    else// LEFT ------------------------------------------------------------------------------------\n    { \n        tex = (uv0.xy - vec2(0.0, (PixelCount.y - PixelCount.x) * 0.5)) / PixelCount.x;\n        \n        col = 0.0;\n\n        if(tex.y > 0.0 && tex.y < 1.0)\n        //for(uint i = 0u; i < (uint(iFrame) % 1024u) * 4u; ++i)\n        for(uint i = 0u; i < 1024u; ++i)            \n        //for(uint i = 0u; i < 4069u*4u; ++i)            \n        //for(uint i = 0u; i < 1024u*2u; ++i)\n        {\n           // #ifndef USE_EVENLY_SPACED_POINTS\n           #if 1\n            vec2 u = Roberts(i);\n            u = vec2(i * uvec2(2447445413u, 3242174889u)) * (1.0 / 4294967296.0);\n            \n            //u = vec2(i * uvec2(2700274805u, 3679390609u)) * (1.0 / 4294967296.0);//4D A\n            //u = vec2(i * uvec2(3152041523u, 2313257605u).yx) * (1.0 / 4294967296.0);//4D B\n            \n            //u = vec2(i * uvec2(2313257605u, 3679390609u)) * (1.0 / 4294967296.0);//4D A\n            //u = vec2(i * uvec2(2700274805u, 3152041523u).xy) * (1.0 / 4294967296.0);//4D B\n            vec2 u0 = u;\n            #if 0\n            uint h0 = PhiHash(i * uvec2(2447445413u, 3242174889u));\n            u.x = Hash01(h0);             \n            u.y = Hash01(h0);\n            #endif\n            \n            float ang = Float01(PhiHash(uint(i) * uvec2(2447445413u, 3242174889u)))*Pi*2.0;\n            \n            float s = 0.02;\n            u = u*2.0-1.0;\n            u += vec2(cos(ang), sin(ang)) * s;\n            u = u*0.5+0.5;\n            u = fract(u);\n            \n           #else\n            vec2 u = vec2(i % 32u, i / 32u) / 31.0;\n           #endif\n            \n            //u = fract(u + 0.125);\n            \n            #if 1\n            #if 0\n            u = ToUnitDisk(u)*0.5+0.5;\n            #else\n            //u = ToUnitDisk(abs(u*2.0-1.0));\n            u = ToUnitDisk(u);\n            //u = vec2(cos(u.x*Pi*2.0),sin(u.x*Pi*2.0))*sqrt(u.y);\n            \n            //            //u = normalize(u) * pow(1.0 - dot(u, u), 0.45);    \n\t\t\t//u = normalize(u);// * pow(dot(u, u), 0.5);    \n            u = u * 0.5 + 0.5;\n            #endif\n            #elif 0\n            float u2 = u.y * 2.0;// 2 30 ...\n            float uf = fract(u2);\n            float ui = floor(u2);\n            bool flip = fract(ui*0.5)<0.5; \n            if(flip)uf = 1.0-uf;\n            u = vec2(cos(u.x * Pi * 2.0), sin(u.x * Pi * 2.0)) * sqrt(uf) * (flip ? -1.0 : 1.0) * 0.5 + 0.5;\n            #elif 1\n            u = vec2(cos(u.x * Pi * 2.0), sin(u.x * Pi * 2.0)) * sqrt(abs(u.y*2.0-1.0)) * (u.y < 0.5 ? -1.0 : 1.0) * 0.5 + 0.5;\n            #else\n            u = vec2(cos(u.x * Pi * 2.0), sin(u.x * Pi * 2.0)) * sqrt(u.y) * 0.5 + 0.5;\n            #endif\n            \n            //u = SphereToUnitDisk(UnitDiskToSphere(u*2.0-1.0))*0.5+0.5;\n            //u = SphereToUnitDisk(Sample_Sphere(u0.x*2.0-1.0, u0.y*2.0-1.0))*0.5+0.5;\n            \n            //u = Sample_Disk(float(i) * PhiRcp * 2.0, (float(i) + 0.5) / 1024.0) * 0.5 + 0.5;\n            \n            #if 0\n            {\n                uvec2 ip = Sobol(i);\n        \t\t//ip = (i * uvec2(2447445413u, 3242174889u));\n                //ip = (i * uvec2(2700274805u, 3679390609u));//4D A\n            \t//ip = (i * uvec2(3152041523u, 2313257605u).yx);//4D B\n                \n                //ip = (i * uvec2(2313257605u, 3679390609u));//4D A\n            \t//ip = (i * uvec2(2700274805u, 3152041523u));//4D B\n                \n            \tip.x = OwenScramble(ip.x, 42u);\n            \tip.y = OwenScramble(ip.y, 666u);\n                \n                u = vec2(ip) * (1.0 / 4294967296.0);\n            \tu = ToUnitDisk(u) * 0.5 + 0.5;\n            }\n            #endif\n            \n            float m = length(u - tex);\n            \n            col += clamp(clamp(mix(1.0, 0.0, m * 128.0*1.), 0.0, 1.0) * 4.0, 0.0, 1.0)*0.75;\n            //col = max(col, clamp(clamp(mix(1.0, 0.0, m * 128.0*4.), 0.0, 1.0) * 4.0, 0.0, 1.0));\n        }\n        else col = 0.11;\n    }\n\n    col = pow(clamp01(col), 2.2);\n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    bool right = uv.x > PixelCount.x;\n    if(right) uv.x -= PixelCount.x;\n    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    \n    vec2 ang = vec2(0.0, 0.0);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(0.6 + mouseAccu.w * 0.02));\n    \n\n\t#if 0\n    float flip = step(0.5, fract(uv.y * 0.5));\n    \n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 0.5  ), 1./6.), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 5./6.), 0.5  ), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 1./6.), 5./6.), right);    \n    \n    col /= 3.0;   \n    #else\n    col = vec3(EvalSceneCol(cpos, cam, uv, right));    \n    #endif\n    \n\n    \n    //if(col.x > 1.0) col = vec3(1.0, 0.0, 1.0);\n    //if(col.x >\n    \n\toutCol = vec4(pow(clamp01(col), vec3(1.0/2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}","name":"Buffer A","description":"","type":"buffer"}]}