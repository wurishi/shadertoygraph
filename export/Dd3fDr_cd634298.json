{"ver":"0.1","info":{"id":"Dd3fDr","date":"1697024436","viewed":76,"name":"Battered unlimited","username":"_pwd_","description":"Tiny repeated battered boxes.","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","reflection","cubes","mirrors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x/iResolution.x;\n    float f = clamp( 4.0*abs(x-0.5)-1.0, 0.0, 1.0 );\n    \n    //blur edges -> from https://www.shadertoy.com/view/XtycD1\n    vec3 col = vec3(0.0);\n    for( int m=-4; m<=4; m++ )\n    for( int n=-4; n<=4; n++ )\n    {\n        vec2 uv = (fragCoord + f*2.0*vec2(float(m),float(n)) )/iResolution.xy;\n        col += textureLod(iChannel0, uv, 0.0 ).xyz;\n    }\n    col /= 81.0;\n    \n    // vignette\n    col *= 1.0-0.1*f;\n    \n    //tone mapping\n    col.rgb = vec3(1.7, 1.8, 1.6 + sin(iTime) * 0.5) * col.rgb / ( 0.8 + cos(iTime) * 0.2 + col.rgb);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dc3zB","filepath":"https://soundcloud.com/hipdozer/vanilla-summer","previewfilepath":"https://soundcloud.com/hipdozer/vanilla-summer","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//\n//\n// Battered Unlimited\n//\n//\n//\n// Tiny repeated battered boxes ftw\n// here -> https://gyabo.sakura.ne.jp/progdx9.html\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor canÂ´t be minted (ecofriendly or not) as NFT.   \n//\n//\n//\n\n\n#define move\n#define reflections\n#define plasma\n#define lensDistort\n#define matte\n#define texFFTSmoothed iChannel0\n\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nfloat getMatte(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n\n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        if (t0>t) break; \n        \n        float sDi = length(lp-ro)/120.; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = n3D(ro2)*.65 + n3D(ro2*3.)*.25 + n3D(ro2*9.)*.1;\n\n        float n = c;\n        mist += n*sAtt;\n        \n        t0 += clamp(c*.25, .1, 1.);\n        \n    }\n    \n    return max(mist/48., 0.);\n\n}\n\nvec2 rot(vec2 p, float r) {\n    return vec2(-cos(r) * p.x + sin(r) * p.y, sin(r) * p.x + cos(r) * p.y);\n}\n\nfloat sinusoidalPlasma(in vec3 p){\n    return sin(p.x+iTime*2.)*cos(p.y+iTime*2.1)*sin(p.z+iTime*2.3) + 0.25*sin(p.x*2.)*cos(p.y*2.)*sin(p.z*2.);\n}\n\nfloat scene(vec3 p) {\n\n    vec3 d = p;\n    float rtrn;\n\n  \tp = mod(p, 2.1) - 1.0;\n  \td = p;\n    \n    d.xz = rot(d.xz,  0.5 + iTime );\n    float k1 = length(max(abs(d) - 0.5, 0.0)) - 0.01;\n  \n    rtrn = k1;\n  \n    #ifdef plasma\n    rtrn = k1 - .09-0.05*sinusoidalPlasma(p*4.0);\n    #endif\n\n    return rtrn;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 eps1=vec3(0.1,0,0);\n    return normalize(vec3(scene(p+eps1.xyy),scene(p+eps1.yxy),scene(p+eps1.yyx)));\n}\n\nvec3 getf(vec2 uv) {\n  uv = abs(uv * 0.15);\n  //float m0 = texture(texFFTSmoothed, uv.x).x * 5.0; //Bonzomatic\n  //float m1 = texture(texFFTSmoothed, uv.y).x * 5.0;  //Bonzomatic\n  float m0 = texture(texFFTSmoothed, uv.xy).x * 5.5;\n  float m1 = texture(texFFTSmoothed, uv.yx).x * 5.5;\n  return vec3(\n  m0 * m1,\n  m0 - m1,\n  m0 + m1) * 0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float count = iTime * 0.15;\n\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0); \n    vec2 uv = (2.0*gl_FragCoord.xy/iResolution.xy - 1.0)*aspect;\n    \n    vec4 dir = vec4(normalize(vec3(uv * vec2(1.25, 1.0), 1.0)), 1.0);\n    vec3 cam = normalize(vec3(-1.0, 1.0, -1.0));\n    vec3 eye = vec3(0.0 , 2.0, 2.5 );\n\n    #ifdef move\n    eye.z += iTime;\n    #endif\n\n    vec3 ro = eye;\n    \n    #ifdef lensDistort\n    dir.z -= length(dir) * 0.36; //lens distort\n    dir = normalize(dir);\n    #endif\n\n    dir.yz = rot(dir.yz, -2.4);\n\n    dir.yz   = rot(dir.yz, -12.4);\n    dir.yx   = rot(dir.yx,  iTime * 0.125);\n    dir.xz   = rot(dir.xz,  iTime * 0.125);\n    \n    float total = 0.5;\n\n    for(int i = 0 ; i < 100; i++) {\n        ro += dir.xyz * scene(ro) * 0.95;\n        total+=max(0.001,abs(ro.z));\n    }\n\n    #ifdef reflections\n    dir.xyz = reflect(dir.xyz,getNormal(ro));\n    ro += dir.xyz;\n\n    for(int i = 0 ; i < 100; i++) {\n       ro += dir.xyz * scene(ro) * 0.95;\n    }  \n    #endif\n    \n    float polish = 1.0;\n    #ifdef matte\n    polish = getMatte(ro, dir.xyz, vec3(-0.5,  1.5, -0.5), total)*(-dir.y + 1.);\n    #endif\n\n    float t = length(ro - eye) ;\n    \n    fragColor = vec4(vec3(0.3 * dir + scene(ro + 0.3 * cam) * polish + t * 0.03 ), 1.0);\n    vec3 fog = vec3(2,2,3) * t * 0.002;\n    fragColor.xyz += fog;\n\n}","name":"Buffer A","description":"","type":"buffer"}]}