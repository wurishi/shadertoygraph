{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//float closest;\nstruct point{\n\tvec3 position;\n\tvec3 normal;\n\tvec3 color;\n\tfloat distanceFromCamera;\n};\nstruct polygon{\n\tvec3 A;\n\tvec3 B;\n\tvec3 C;\t\n\tvec3 color;\n};\nstruct sphere{\n\tvec3 pos;\n\tfloat size;\n};\nvec3 color;\nvec3 camera;\nvec3 ray;\npoint closestPoint;\nvoid resolveRayPolygonIntersection(polygon poly){\n\t\n\tvec3 e1=poly.B-poly.A;\n\tvec3 e2=poly.C-poly.A;\n\tvec3 pvec=cross(ray, e2);\n\tfloat det=dot(e1, pvec);\n\t\n\tfloat invDet=1.0/det;\n\tvec3 tvec=camera-poly.A;\n\tfloat u=dot(tvec,pvec)*invDet;\n\tif(u<0.0||u>1.0) return;\n\tvec3 qvec=cross(tvec,e1);\n\tfloat v=dot(ray,qvec)*invDet;\n\tif(v<0.0||v>1.0||(u+v)>1.0) return;\n\tfloat t=dot(e2,qvec)*invDet;\n\tif(t>0.0)\n\tif(t<closestPoint.distanceFromCamera){\n\t\tclosestPoint.distanceFromCamera=t;\n\t\tclosestPoint.normal=normalize(cross(e1, e2));\n\t\tclosestPoint.color=poly.color;\n\t}\n}\nbool resolveRaySphereIntersection(sphere ball){\n\tvec3 OC=ball.pos-camera;\n\tfloat P=dot(OC,ray);\n\tif(P<0.) return false;\n\tfloat d=sqrt(pow(length(OC),2.0)-pow(P,2.0));\n\tif(d>ball.size) return false;\n\treturn true;\n}\nfloat resolveRayLightIntersection(sphere sun){\n\tvec3 OC=sun.pos-camera;\n\tfloat P=dot(OC,ray);\n\tfloat d=sqrt(pow(length(OC),2.0)+pow(P,2.0));\n\treturn 1./d;\n\t\n}\nmat3 rotate_x( float angle)\n{\n\treturn mat3(\t\t1\t,\t\t0,\t\t\t0\t,\n\t\t\t\t\t\t0\t,cos(angle),-sin(angle) ,\n\t\t\t\t\t\t0\t,sin(angle),cos(angle)\t); \n}\nmat3 rotate_y( float angle)\n{\n\treturn mat3(cos(angle)\t,\t\t0,\tsin(angle)\t,\n\t\t\t\t\t\t0\t,\t\t1,\t\t\t0\t,\n\t\t\t\t-sin(angle)\t,\t\t0,\tcos(angle)\t); \n}\nsphere sun;\nvoid resolveRay(float howManiethReflection){\n\tif(closestPoint.distanceFromCamera<100000.){\n\t\tcamera+=ray*(closestPoint.distanceFromCamera)-normalize(closestPoint.normal);\n\t\tray=normalize(reflect(ray,closestPoint.normal));\n\t\tfloat sunlight=length(sun.pos-camera)/min(max(0.4/resolveRayLightIntersection(sun),0.01),1.0);\n\t\tcolor+=vec3(closestPoint.color/(0.11*sunlight*(howManiethReflection*1.1+1.)));\n\t\t//ray=normalize(ray)*vec3(0.77);\n\n\t}\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid scene(){\n\tsphere ball;\n\tball.pos=vec3(0.,-3.,10.);\n\tball.size=17.;\n\tif(resolveRaySphereIntersection(ball))\n\tfor(float reflection=0.; reflection<=6.; reflection++){\n\t\t\n\tpolygon test2;\n\ttest2.A=vec3(9., -10., 10.);\n\ttest2.B=vec3(4., -10., -10.);\n\ttest2.C=vec3(9., 10., 10.);\n\ttest2.color=vec3(.61,.8,.51);\n\tresolveRayPolygonIntersection(test2);\n\tpolygon test3;\n\ttest3.C=vec3(-12., -10., 10.);\n\ttest3.B=vec3(-7., -10., -10.);\n\ttest3.A=vec3(-1., 30., 0.);\n\ttest3.color=vec3(.8,.5,.5);\n\tresolveRayPolygonIntersection(test3);\n\t\t\n\tfor(float i=3.14*2000.0; i<3.14*4000.0; i+=3.14*400.0){\n\t\t\tpolygon ympyraPala;\n\t\t\tympyraPala.A=vec3(4.0*cos(i), -1.0, 4.0*sin(i));\n\t\t\tympyraPala.B=vec3(4.0*cos(i+3.14*400.), -1.0, 4.0*sin(i+3.14*400.));\n\t\t\tympyraPala.C=vec3(0.0, 4.+1.*sin(iTime*3.782562261), 0.0);\n\t\t\tympyraPala.color=vec3(.31,.0,.0);\n\t\t\tresolveRayPolygonIntersection(ympyraPala);\n\t}\n\tfor(float i=3.14*2000.0; i<3.14*4000.0; i+=3.14*400.0){\n\t\t\tpolygon ympyraPala;\n\t\t\tympyraPala.A=vec3(5.0*cos(i+3.14*400.), -3.0+1.*sin(iTime*3.782562261-1.), 5.0*sin(i+3.14*400.));\n\t\t\tympyraPala.B=vec3(4.0*cos(i+3.14*400.), -1.0, 4.0*sin(i+3.14*400.));\n\t\t\tympyraPala.C=vec3(4.0*cos(i), -1.0, 4.0*sin(i));\n\t\t\tympyraPala.color=vec3(.31,.0,.0);\n\t\t\tresolveRayPolygonIntersection(ympyraPala);\n\t\t\tympyraPala.C=vec3(5.0*cos(i+3.14*400.), -3.0+1.*sin(iTime*3.782562261-1.), 5.0*sin(i+3.14*400.));\n\t\t\tympyraPala.B=vec3(5.0*cos(i), -3.0+1.*sin(iTime*3.782562261-1.0), 5.0*sin(i));\n\t\t\tympyraPala.A=vec3(4.0*cos(i), -1.0, 4.0*sin(i));\n\t\t\tympyraPala.color=vec3(.31,.0,.0);\n\t\t\tresolveRayPolygonIntersection(ympyraPala);\n\t}\n\tpolygon RR;\n\tRR.A=vec3(-10., -6., -10.);\n\tRR.B=vec3(10., -6., -10.);\n\tRR.C=vec3(-10., -6., 10.);\n\tRR.color=vec3(.104,.1,.31);\n\tresolveRayPolygonIntersection(RR);\n\tRR.A=vec3(10., -6., -10.);\n\tRR.B=vec3(10., -6., 10.);\n\tRR.C=vec3(-10., -6., 10.);\n\tRR.color=vec3(.104,.1,.31);\n\tresolveRayPolygonIntersection(RR);\n\t\t\n\tfor(float j=-1.0; j<4.0; j++)\n\t\tfor(float i=-2.0; i<2.0; i++){\n\t\t\tpolygon tasoPalaA;\n\t\t\ttasoPalaA.C=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);\n\t\t\ttasoPalaA.B=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);\n\t\t\ttasoPalaA.A=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);\n\t\t\ttasoPalaA.color=vec3(.41,.41,.41);\n\t\t\tresolveRayPolygonIntersection(tasoPalaA);\n\t\t\tpolygon tasoPalaB;\n\t\t\ttasoPalaB.C=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);\n\t\t\ttasoPalaB.B=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);\n\t\t\ttasoPalaB.A=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);\n\t\t\ttasoPalaB.color=vec3(.41,.41,.41);\n\t\t\tresolveRayPolygonIntersection(tasoPalaB);\n\t\t}\n\t\tresolveRay(reflection);\n\t\tcolor+=vec3(min(resolveRayLightIntersection(sun),0.0));\n\tclosestPoint.distanceFromCamera=100000.;\n\t}\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//float aspectratio = iResolution.x / iResolution.y;\n\tvec3 noise=texture(iChannel0, uv+vec2(iTime)).xyz*rand(uv+vec2(iTime))*vec3(0.052);\n\t\n\t\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n\t\n\tcamera = vec3(-4.0*sin(iTime),3.0,22.0);\n\tray = normalize(vec3(coord, -1.5));\n\tclosestPoint.distanceFromCamera=100000.;\n\tcolor=vec3(0.);\n\tscene();\n\n\tfragColor = vec4(color+noise+vec3(-0.5),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldsSzr","date":"1396223421","viewed":759,"name":"Polygon Raytracing","username":"Branch","description":"Polygon Raytracing.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","tracing","polygon"],"hasliked":0,"parentid":"","parentname":""}}