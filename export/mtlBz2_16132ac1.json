{"ver":"0.1","info":{"id":"mtlBz2","date":"1693227195","viewed":64,"name":"Ray Tracing Spheres by Anton","username":"Anto_Crasher555","description":"ray trace spheres with colors, shadows, and reflections","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","render","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n#define PI 3.141592\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    float reflectivity;\n};\n\nstruct PointLight {\n    vec3 center;\n    float intensity;\n    vec3 color;\n};\n\nstruct ShootRayRet {\n    float dist;\n    vec3 normal;\n    vec3 hitPoint;\n    vec3 color;\n    float reflectivity;\n};\n\nstruct AddSphereRet {\n    float dist;\n    vec3 normal;\n    vec3 color;\n    float reflectivity;\n};\n\nstruct RayCastRet {\n    vec3 final;\n};\n\nstruct ReflectionBounceRet {\n    vec3 shaded;\n    vec3 reflected;\n    vec3 normal;\n    vec3 hitPoint;\n    float reflectivity;\n};\n\nstruct GetAngleBetVecRet {\n    float theta;\n    vec3 axis;\n};\n\n// SCENE SETTINGS\nconst int sphereCount = 4;\nconst int pointLightCount = 3;\n\nconst Sphere spheres[sphereCount] = Sphere[](\n    Sphere(vec3(-0.58, -0.28, -0.94), 0.31, vec3(0.961, 0.184, 0.388), 0.3),\n    Sphere(vec3(0.8, -0.35, -0.35), 0.59, vec3(0.506, 0.184, 0.961), 0.1),\n    Sphere(vec3(-0.29, 0.83, 0.53), 1.04, vec3(1.0, 1.0, 1.0), 1.0),\n    Sphere(vec3(0.41, -3000.4, 0.03), 3000.0, vec3(1.0, 1.0, 1.0), 0.4)\n);\n\nconst PointLight pointLights[pointLightCount] = PointLight[](\n    PointLight(vec3(-2.6, 2.0, -2.8), 9.2, vec3(0.279755, 0.523567, 1.0)),\n    PointLight(vec3(1.2, 2.4, -2.6), 5.1, vec3(1.0, 0.360682, 0.060892)),\n    PointLight(vec3(-0.1, 3.8, -3.5), 5.2, vec3(1.0, 1.0, 1.0))\n);\n\n// INTERSECT SPHERE\nAddSphereRet addSphere(float dist, vec3 normal, vec3 color, float reflectivity, vec3 rayOrigin, vec3 rayDir, float radius, vec3 pos, vec3 currentColor, float currentReflectivity) {\n    vec3 newSpherePos = pos - rayOrigin;\n    float l = max(dot(newSpherePos, rayDir), 0.0);\n    vec3 bPoint = rayOrigin + rayDir * l;\n    float b = length(bPoint - pos);\n\n    float retDist = dist;\n    vec3 retNormal = normal;\n    vec3 retColor = color;\n    float retReflectivity = reflectivity;\n\n    float mult = (length(pos - rayOrigin) > radius) ? 1.0 : 0.0;\n    if (b < radius) {\n        float a = sqrt(radius * radius - b * b);\n        float d = l - a;\n        retDist = 1000.0 + mult * (d - 1000.0);\n\n        vec3 hitPoint = rayOrigin + rayDir * retDist;\n        vec3 newNormal = normalize(hitPoint - pos);\n\n        float mult2 = retDist < dist ? 1.0 : 0.0;\n\n        retDist = min(dist, retDist);\n        retNormal = normal + (newNormal - normal) * mult2;\n        retColor = color + (currentColor - color) * mult2;\n        retReflectivity = reflectivity + (currentReflectivity - reflectivity) * mult2;\n    }\n    return AddSphereRet(retDist, retNormal, retColor, retReflectivity);\n}\n\n// SHOOT RAY TO SCENE\nShootRayRet shootRay(vec3 rayOrigin, vec3 rayDir) {\n    AddSphereRet lastRet = AddSphereRet(1000.0, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n    for (int i = 0; i < sphereCount; i++) {\n        Sphere sphere = spheres[i];\n        lastRet = addSphere(lastRet.dist, lastRet.normal, lastRet.color, lastRet.reflectivity, rayOrigin, rayDir, sphere.radius, sphere.center, sphere.color, sphere.reflectivity);\n    }\n    float frenel = pow((dot(lastRet.normal, rayDir) + 1.0), 1.3);\n    return ShootRayRet(\n        lastRet.dist,\n        lastRet.normal,\n        rayOrigin + rayDir * lastRet.dist,\n        lastRet.color,\n        frenel\n    );\n}\n\n// ADD POINT LIGHT\nvec3 pointLight(vec3 normal, vec3 rayOrigin, vec3 lightPos, float intensity, vec3 color) {\n    vec3 dir = lightPos - rayOrigin;\n    float dirLen = length(dir);\n    vec3 lightVector = normalize(lightPos - rayOrigin);\n    float dotted = max(dot(normal, lightVector), 0.0);\n    float shadedHitPoint = dotted / (dirLen * dirLen);\n    ShootRayRet retShadowRay = shootRay(rayOrigin, lightVector);\n    float mult = retShadowRay.dist > dirLen ? 1.0 : 0.0;\n    vec3 retShading = color * (shadedHitPoint * mult * intensity);\n    return retShading;\n}\n\n// SHADER HIT POINT WITH COLORS / SHADOWS\nvec3 shadeHitPoint(vec3 normal, vec3 hitPoint, vec3 color) {\n    vec3 shading = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < pointLightCount; i++) {\n        PointLight light = pointLights[i];\n        shading = shading + pointLight(normal, hitPoint, light.center, light.intensity, light.color);\n    }\n    return shading * color;\n}\n\n// GET REFLECTION BOUNCE ITERATION\nReflectionBounceRet getReflectionBounce(vec3 rayOrigin, vec3 rayDirection, vec3 rayNormal) {\n    vec3 reflected = reflect(rayDirection, rayNormal);\n    ShootRayRet rayRet = shootRay(rayOrigin, reflected);\n    vec3 shadedRet = shadeHitPoint(rayRet.normal, rayRet.hitPoint, rayRet.color);\n    return ReflectionBounceRet(\n        shadedRet,\n        reflected,\n        rayRet.normal,\n        rayRet.hitPoint,\n        rayRet.reflectivity\n    );\n}\n\n// MIX COLOR WITH FACTOR\nvec3 mixColor(float factor, vec3 A, vec3 B) {\n    return A + (B - A) * factor;\n}\n\n// RAYCAST SCENE\nRayCastRet rayCast(vec3 cameraPos, vec3 rayDir) {\n    ShootRayRet rayRet = shootRay(cameraPos, rayDir);\n    \n    vec3 shaded = shadeHitPoint(rayRet.normal, rayRet.hitPoint, rayRet.color);\n    \n    ReflectionBounceRet reflectedPoint1 = getReflectionBounce(rayRet.hitPoint, rayDir, rayRet.normal);\n    ReflectionBounceRet reflectedPoint2 = getReflectionBounce(reflectedPoint1.hitPoint, reflectedPoint1.reflected, reflectedPoint1.normal);\n    \n    vec3 mixed1 = mixColor(reflectedPoint1.reflectivity, reflectedPoint1.shaded, reflectedPoint2.shaded);\n    vec3 final = mixColor(rayRet.reflectivity, shaded, mixed1);\n    \n    return RayCastRet(final);\n}\n\n// GET SCREEN RAY DIRECTION\nvec3 getRayDir(vec2 screenUV, vec3 cameraPosition, vec3 lookAt, float focalLength) {\n    vec3 forward = normalize(lookAt - cameraPosition);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 cameraCenter = cameraPosition + forward * focalLength;\n    vec3 intersectionPoint = cameraCenter + screenUV.x * right + screenUV.y * up;\n    return normalize(intersectionPoint - cameraPosition);\n}\n\n// ROTATE VECTOR\nmat2 rotVector(float angleRadians) {\n    float sineValue = sin(angleRadians);\n    float cosineValue = cos(angleRadians);\n    mat2 rotationMatrix = mat2(cosineValue, -sineValue, sineValue, cosineValue);\n    return rotationMatrix;\n}\n\n// MAIN IMAGE FUNCTION\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // CAMERA SETTINGS \n    vec3 cameraPos = vec3(0, 0.0, 3.0);\n    \n    cameraPos.yz *= rotVector(mouse.y*PI-1.);\n    cameraPos.xz *= rotVector(-mouse.x*TAU);\n    \n    const vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    const float fov = 70.0;\n\n    // UV COORDS\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // GET FOV PIXEL COORDS\n    float fovRad = fov * (3.141 / 180.0);\n    float tanHalfFov = tan(fovRad * 0.5);\n    float ny = tanHalfFov * uv.y;\n    float nx = tanHalfFov * uv.x;\n\n    // GET DIRECTION\n    vec3 cameraDirection = getRayDir(vec2(nx, ny), cameraPos, cameraTarget, 1.);\n    \n    RayCastRet retColor = rayCast(cameraPos, cameraDirection);\n    \n    fragColor = vec4(retColor.final, 1.0);\n}","name":"Image","description":"","type":"image"}]}