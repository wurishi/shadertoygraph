{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// 2D vector field visualization by Matthias Reitinger, @mreitinger\n// Based on : \n// - \"2D vector field visualization by Morgan McGuire, http://casual-effects.com\", \n// - https://www.shadertoy.com/view/4s23DG\n// - https://www.shadertoy.com/view/ls2GWG\n\nconst float ARROW_TILE_SIZE = 10.;\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.3);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst float detailScale = 10.;\n\nvec2 fragToUV( vec2 coord )\n{\n\tvec2 p = coord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*= detailScale;\n\n\treturn p;\t\n}\n\nvec2 curl(vec2 fragCoord)\n{\n\tfloat pN = noise( fragToUV( fragCoord + vec2(0,1) ) );\n\tfloat pS = noise( fragToUV( fragCoord - vec2(0,1) ) );\n\tfloat pE = noise( fragToUV( fragCoord + vec2(1,0) ) );\n\tfloat pW = noise( fragToUV( fragCoord - vec2(1,0) ) );\n\n\treturn vec2((pN - pS), -(pE - pW));\n\n}\n\nfloat normalizedDistanceToCone( vec2 conePos, vec2 coneDir, float coneLength, float coneRadius, vec2 testPos )\n{\n\tvec2 displacement = testPos - conePos;\n\tfloat displacementDotDir = dot( displacement, coneDir );\n\t\n\tif( displacementDotDir < 0.0 || displacementDotDir > coneLength )\n\t{\n\t\treturn 1.0;\n\t}\n\t\n\tvec2 pointOnAxis = conePos + displacementDotDir * coneDir;\n\tvec2 testPosToAxis = pointOnAxis - testPos;\n\n\treturn clamp( \n\t\tlength(testPosToAxis) / ( coneRadius * displacementDotDir / coneLength )\n\t\t, 0.0\n\t\t, 1.0 );\n}\n\nconst vec2 scrollVelocity = vec2(0.,0.);\n\n/////////////////////////////////////////////////////////////////////\n\n// The vector field; use your own function or texture\nvec3 field(vec2 pos) \n{\n\treturn vec3( curl( pos + scrollVelocity * iTime ), 0.3) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec3 arrowField = field(arrowTileCenterCoord(fragCoord.xy));\n\tvec3 fieldValue = field(fragCoord.xy);\n\tfloat arrow_dist = arrow(fragCoord.xy,\n\t                         arrowField.xy * ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, (0.4 + fieldValue.z ) * clamp(arrow_dist, 0.0, 1.0));\n\tfloat fieldIntensity = 0.5 + pow(length(fieldValue.xy), 0.2);\n\tvec4 field_col = vec4(fieldIntensity, fieldIntensity, fieldIntensity,1.0);\n\t\t\n\tfragColor = mix(arrow_col, field_col, arrow_col.a);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfXRj","date":"1403795365","viewed":1091,"name":"Curl-Noise","username":"fibre","description":"A simple visualization of a partial implementation of \"Curl-Noise for Procedural Fluid Flow\", by Bridson et al.\n\nThat kind of noise respects the incompressible condition of fluids.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["noise","curl","curlnoise"],"hasliked":0,"parentid":"","parentname":""}}