{"ver":"0.1","info":{"id":"4slBDl","date":"1498831679","viewed":1039,"name":"R11G11B10F quantization & dither","username":"Khayzo","description":"Apply dithering on R11G11B10F  floating point format to reduce quantization effect.\n(Mouse click to apply dithering)","likes":14,"published":1,"flags":16,"usePreview":0,"tags":["quantization","dithering","r11g11b10f"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FLOAT32 0\n#define FLOAT16\t1\n#define FLOAT11\t2\n#define FLOAT10\t3\n#define FLOAT8\t4\n\n#define FLOAT_TYPE_COUNT 5\n\n#define EFloatType int\n\n//#define SHOW_RELATIVE_ERROR\n//#define SHOW_DITHER\n\n#define RANGE_LOW 0.2\n#define RANGE_HIGH 0.7\n\n#ifndef SHOW_RELATIVE_ERROR\n//#define REMAP_RANGE_TO_01\n#endif\n\nstruct FloatDesc\n{\n\tbool signBit;\n\tint nbitsExponent;\n\tint nbitsMantissa;\n};\n\nconst FloatDesc gFloatDescs[FLOAT_TYPE_COUNT] = FloatDesc[FLOAT_TYPE_COUNT](\n\tFloatDesc(true,  8, 23 ), // FLOAT32\n\tFloatDesc(true,  5, 10 ), // FLOAT16\n\tFloatDesc(false, 5, 6  ), // FLOAT11\n\tFloatDesc(false, 5, 5  ), // FLOAT10\n    FloatDesc(false, 5, 3  )  // FLOAT8\n);\n// Quantize a 32-bit float to a float with 'nbitsMantissa' bits of mantissa\nfloat F32ToFn(float f, const int nbitsMantissa)\n{\n\tint bits = floatBitsToInt(f);\n\n    int s = bits >> 31;\t// sign\n    int expo = (bits & 0x7f800000) >> 23; // exponent\n    int m = bits & 0x007fffff; // mantissa\n\n  \tconst float exponentBias32 = 127.0;\n    float decodedExponent = float(expo) - float(exponentBias32);\n\n    float decodedSignificand = 1.0;\n\n    for(int i = 0; i < nbitsMantissa; ++i)\n    {\n        int bit = (1 << (23 - i - 1));\n        if((m & bit) != 0)\n        {\n            decodedSignificand += exp2(-(float(i)+1.0));\n        }\n    }\n\n    return decodedSignificand * exp2(decodedExponent);\n}\n\n// Quantize a 32-bit float to a float of the given type\nfloat F32To(EFloatType ftype, float f)\n{\n\treturn F32ToFn(f, gFloatDescs[ftype].nbitsMantissa);\n}\n\n\n// Quantum for the float f with 'nbitsMantissa' bits of mantissa\nfloat FnQuantum(float f, const int nbitsMantissa)\n{\n    float e = floor(log2(f));   \n    return exp2(e - float(nbitsMantissa));\n}\n\n// Quantum for the float f of the given type\nfloat FQuantum(EFloatType ftype, float f)\n{\n    return FnQuantum(f, gFloatDescs[ftype].nbitsMantissa);\n}\n\n\nfloat interleavedGradientNoise(vec2 n)\n{\n    float f = 0.06711056 * n.x + 0.00583715 * n.y;\n    return fract(52.9829189 * fract(f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float f = uv.y > 0.5 ? uv.x : uv.x *  (RANGE_HIGH - RANGE_LOW) + RANGE_LOW; // [0.0, 1.0] : [RANGE_LOW, RANGE_HIGH]\n  \n    float r = f;\n    float g = f;\n    float b = f;\n    \n    float noise = interleavedGradientNoise(fragCoord.xy);\n    noise = noise * 2.0 - 1.0;\n    \n    float dither11 = FQuantum(FLOAT11, f) * noise;\n    float dither10 = FQuantum(FLOAT10, f) * noise;\n   \n    // Apply per-component float dithering\n    bool mouseBtnPressed = (iMouse.z >= 1.0);\n    if(mouseBtnPressed)\n    {\n   \t\tr += dither11;\n        g += dither11;\n        b += dither10;\n    }\n    \n    // Quantize 32-bit floats to R11G11B10F\n    r = F32To(FLOAT11, r);\n    g = F32To(FLOAT11, g);\n    b = F32To(FLOAT10, b);\n    \n    vec3 rgb = vec3(r, g, b);\n    \n    #ifdef REMAP_RANGE_TO_01\n    if(uv.y < 0.5)\n    \trgb = (rgb - RANGE_LOW) / (RANGE_HIGH - RANGE_LOW);\n    #endif\n       \n   \t#ifdef SHOW_RELATIVE_ERROR\n    vec3 relativeError = abs((vec3(f) - rgb) / vec3(f));\n    rgb = relativeError * 10.0;\n    #elif defined(SHOW_DITHER)\n    rgb = vec3(dither11, dither11, dither10) * 100.0;\n    #endif\n    \n    // Separator\n    vec2 texelSize = vec2(1.0 / iResolution.xy);\n    float lineWidth = 4.0;\n    if(abs(uv.y - 0.5) < (0.25 * lineWidth * texelSize.y)) rgb = vec3(0);\n    \n\tfragColor = vec4(rgb, 1);\n}","name":"Image","description":"","type":"image"}]}