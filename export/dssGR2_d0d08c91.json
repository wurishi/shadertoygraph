{"ver":"0.1","info":{"id":"dssGR2","date":"1666477566","viewed":102,"name":"Interactive Newton's fractal","username":"Krafpy","description":"Interactive newton's fractal.\nInspired from : https://www.youtube.com/watch?v=-RdOwhmqP5s\n\nUse the mouse to drag the polynomial root points in the complex plane.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["fractal","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CHECK COMMON TO CHANGE PARAMETERS\n// Use the mouse to drag the points (polynomial's roots in the complex plane)\n\n#define HALF_PI 1.5707963\n\n\nvec2 roots[N_ROOTS]; // [x1, ..., xn] roots of the considered polynomial\n\n// Computes 1/z, z a complex number\nvec2 invc(vec2 z){\n    return vec2(z.x, -z.y) / dot(z, z);\n}\n\n\n// Time dependant coefficient in front of P(z)/P'(z),\n// gives interesting results.\nfloat tc(){\n    return 1.3*(sin(0.3*iTime - HALF_PI)*0.5 + 0.5) + 0.4;\n}\n\n\nvec2 next(vec2 z){\n    // Compute P(z)/P'(z)\n    // using the fact that P(z)/P'(z) = 1/(1/(z-x1) + ... + 1/(z-xn))\n    vec2 p = vec2(0.);\n    for(int i = 0; i < N_ROOTS; ++i){\n        p += invc(z - roots[i]);\n    }\n    p = invc(p);\n    #ifdef ANIMATE\n    return z - tc() * p;\n    #else\n    return z -  p;\n    #endif\n}\n\n// Magic function used for smooth coloring.\n// http://www.hiddendimension.com/FractalMath/Divergent_Fractals_Main.html\n// http://www.hiddendimension.com/FractalMath/Convergent_Fractals_Main.html\nfloat magic(float d){ // d = |z_{n} - z_{n+1}|\n    return exp(-0.6/d);\n}\n\nvec3 newton(vec2 z0){\n    // Newton's iteration\n    const float eps = .01;\n    vec2 z1 = z0;\n    vec2 z2 = next(z1);\n    float d = length(z1 - z2);\n    float s = magic(d);\n    for(int i = 0; i < N_ITERS && d > eps; ++i){\n        z1 = z2;\n        z2 = next(z1);\n        d = length(z1 - z2);\n        s += magic(d);\n    }\n    \n    return vec3(z2, s);\n}\n\n\nfloat hmap(float x){\n    return abs(-6.*fract(x)+3.)-1.;\n}\n\nvec3 hue2rgb(float h){\n    float r = hmap(h);\n    float g = hmap(h-2./6.);\n    float b = hmap(h+2./6.);\n    return clamp(vec3(r, g, b), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = touv(fragCoord, iResolution.xy);\n    \n    // Get root points' coordinates from the buffer\n    for(int i = 0; i < N_ROOTS; i++){\n        ivec2 ruv = ivec2(i, 0);\n        roots[i] = texelFetch(iChannel0, ruv, 0).xy;\n    }\n    \n    \n    // Iterate the newton's sequence for the complex\n    // number corresponding to the pixel\n    vec2 z0 = uv;\n    vec3 res = newton(z0);\n    // Find the closest root to the iterated point\n    int argmin = closest(res.xy, roots);\n    // Color the fractal\n    vec3 col = vec3(1);\n    float f = float(argmin+1)/float(N_ROOTS);\n    col = hue2rgb(f);\n    float avg = (col.r+col.g+col.b)/3.;\n    col = mix(col, vec3(avg), 0.3);\n    col *= pow(res.z, .3);\n    \n    // Show the root points\n    float d = distance(uv, roots[0]);\n    for(int i = 1; i < N_ROOTS; ++i){\n        d = min(d, distance(z0, roots[i]));\n    }\n    // Rings around the roots\n    float pr = POINT_RADIUS;\n    float re = 0.3;\n    float s = smoothstep(pr*(1.-re), pr, d)*smoothstep(pr*(1.+re), pr, d);\n    col = mix(col, vec3(1.), s);\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TWO_PI 6.2831853\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 r;\n    if(iFrame <= 1) {\n        // Create initial roots\n        float i = fragCoord.x;\n        float a = TWO_PI * fragCoord.x/float(N_ROOTS);\n        r = 0.25 * vec2(cos(a), sin(a));\n    } else {\n        ivec2 ruv = ivec2(fragCoord.x, 0);\n        r = texelFetch(iChannel0, ruv, 0).xy;\n    }\n    \n    // User interacction\n    if(iMouse.z > 0.){\n        // Find if this shader instance manages\n        // the root closest to the mouse\n        vec2 roots[N_ROOTS];\n        for(int i = 0; i < N_ROOTS; ++i){\n            ivec2 ruv = ivec2(i, 0);\n            roots[i] = texelFetch(iChannel0, ruv, 0).xy;\n        }\n        vec2 m = touv(iMouse.xy, iResolution.xy);\n        int argmin = closest(m, roots);\n        if(argmin == int(fragCoord.x)) r = m;\n    }\n    \n    fragColor = vec4(r, 0., 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Number of roots of the polynomial (movable points on screen)\n#define N_ROOTS 5\n// Maximum number of iterations\n#define N_ITERS 100\n// Wether animate the coefficient, comment to ignore\n#define ANIMATE\n// Draggable points radius\n#define POINT_RADIUS 0.0075\n\n// Converts pixel coordinates into normalized, centered coordinates\nvec2 touv(vec2 fragc, vec2 resol){\n    vec2 uv = fragc/resol;\n    uv -= 0.5;\n    uv.x *= resol.x/resol.y;\n    return uv;\n}\n\n// Returns the index of the closest root to x\nint closest(vec2 x, vec2 roots[N_ROOTS]) {\n    vec2 d = x - roots[0];\n    float dstmin = dot(d, d);\n    int argmin = 0;\n    for(int i = 1; i < N_ROOTS; ++i){\n        d = x - roots[i];\n        float dst = dot(d, d);\n        if(dst < dstmin){\n            dstmin = dst;\n            argmin = i;\n        }\n    }\n    return argmin;\n}","name":"Common","description":"","type":"common"}]}