{"ver":"0.1","info":{"id":"ltjfWD","date":"1515910729","viewed":1317,"name":"Simple SDF","username":"chrisnolet","description":"Experiments with ray marching","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst int kMaxSteps = 1000;\nconst float kMaxDepth = 1000.0;\nconst float kTolerance = 0.01;\nconst float kPi = 3.1415926535897932384626433832795;\nconst float kFov = 90.0;\nconst float kTanFov = tan(kFov / 360.0 * kPi);\n\nconst vec3 kCameraOrigin = vec3(0.0, 0.0, 10.0);\nconst vec3 kDirectionalLight = normalize(vec3(-0.6, -0.4, -0.6));\nconst vec3 kSkyboxColor = vec3(0.0);\nconst vec3 kDiffuseColor = vec3(0.4, 0.05, 0.05);\nconst vec3 kSpecularColor = vec3(0.6, 0.5, 0.5);\nconst float kSpecularExponent = 8.0;\nconst float kAmbientCoefficient = 0.2;\n\n////////////////////////////////////////////////////////////////////////////////\n// Forward declarations\n\nfloat sceneSDF(vec3 point);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\nfloat march(vec3 origin, vec3 direction);\nvec3 normal(vec3 point);\nvec4 color(vec3 point, vec3 direction);\n\nfloat sdSphere(vec3 p, float s);\nfloat udBox(vec3 p, vec3 b);\nfloat udRoundBox(vec3 p, vec3 b, float r);\n\nvec3 opRotation(vec3 point, float angle);\n\n////////////////////////////////////////////////////////////////////////////////\n// Scene\n\nfloat sceneSDF(vec3 point) {\n    \n    // Define object parameters\n    vec3 sphereOffset = vec3(4.0, 2.0, 0.0);\n    float sphereRadius = 1.0;\n    \n    vec3 boxOffset = vec3(-4.0, -2.0, 0.0);\n    vec3 boxSize = vec3(1.2, 1.0, 2.0);\n    float boxRadius = 0.2;\n    \n    // Calculate distance to each object\n    float sphere = sdSphere(\n        opRotation(point, iTime) - sphereOffset,\n        sphereRadius\n    );\n    \n    float box = udRoundBox(\n        opRotation(point - boxOffset, -iTime),\n        boxSize,\n        boxRadius\n    );\n    \n    // Join sphere and box\n    return min(sphere, box);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Functions\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Calculate ray direction from fragment coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    vec3 direction = normalize(vec3(uv, -0.5 / kTanFov));\n    \n    // Set camera origin\n    vec3 origin = kCameraOrigin;\n    \n    // Calculate scene depth\n    float depth = march(origin, direction);\n    \n    // Render color\n    if (depth < kMaxDepth) {\n        vec3 normal = normal(origin + depth * direction);\n        \n        fragColor = color(normal, direction);\n    }\n    else {\n        fragColor = vec4(kSkyboxColor, 1.0);\n    }\n}\n\nfloat march(vec3 origin, vec3 direction) {\n    float depth = 0.0;\n    \n    for (int n = 0; n < kMaxSteps; n++) {\n        \n        // Get distance to nearest object\n        float distance = sceneSDF(origin + depth * direction);\n        \n        // Return when distance is within tolerance\n        if (distance <= kTolerance) {\n            return depth;\n        }\n        \n        // Increment ray\n        depth += distance;\n        \n        // Return if depth exceeds max depth\n        if (depth > kMaxDepth) {\n            return kMaxDepth;\n        }\n    }\n    \n    // Return max depth after too many steps\n    return kMaxDepth;\n}\n\nvec3 normal(vec3 point) {\n    \n    // Measure the change-in-distance along each axis\n    vec3 deltaX = vec3(kTolerance, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, kTolerance, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, kTolerance);\n    \n    float x = sceneSDF(point + deltaX) - sceneSDF(point - deltaX);\n    float y = sceneSDF(point + deltaY) - sceneSDF(point - deltaY);\n    float z = sceneSDF(point + deltaZ) - sceneSDF(point - deltaZ);\n    \n    // Return vector where SDF gradient is maximized\n    return normalize(vec3(x, y, z));\n}\n\nvec4 color(vec3 normal, vec3 direction) {\n    \n    // Calculate lighting\n    vec3 halfway = -normalize(direction + kDirectionalLight);\n    float specularBase = max(0.0, dot(normal, halfway));\n    \n    vec3 diffuse = kDiffuseColor * max(0.0, dot(normal, -kDirectionalLight));\n    vec3 specular = kSpecularColor * pow(specularBase, kSpecularExponent);\n    vec3 ambient = kAmbientCoefficient * kDiffuseColor;\n    \n    // Combine components\n    return vec4(diffuse + specular + ambient, 1.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distances: https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat udBox(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Operations\n\nvec3 opRotation(vec3 point, float angle) {\n    \n    // Invert angle\n    float cosineAngle = cos(-angle);\n    float sineAngle = sin(-angle);\n    \n    // Generate rotation matrix\n    mat3 rotation = mat3(\n        vec3(cosineAngle, 0.0, -sineAngle),\n        vec3(0.0,         1.0, 0.0),\n        vec3(sineAngle,   0.0, cosineAngle)\n    );\n    \n    // Apply rotation\n    return (rotation * point);\n}\n","name":"Image","description":"","type":"image"}]}