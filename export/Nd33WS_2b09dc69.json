{"ver":"0.1","info":{"id":"Nd33WS","date":"1644350004","viewed":137,"name":"Cone tracing","username":"floatingcomma","description":"Cone tracing example as seen on: https://www.shadertoy.com/view/wtBSzc","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["conetracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Cone tracing\n    ---------------------\n    // Move mouse to control \"aperture\" on the x axis and \"focus\" on the y axis\n    \n    // Based on:\n    edapx -- Intro to cone tracing pt.2\n    https://www.shadertoy.com/view/wtBSzc\n    \n*/\n\nconst int MAX_MARCHING_STEPS = 128;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.00;\nconst float PI = 3.14159265359;\nconst float FOV = 15.0;\n\n#define CONETRACING\n\nvec2 rotate(vec2 pos, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n} \n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 pos){\n    float box = sdBox(pos - vec3(-0.2, 0, 0), vec3(1));\n    float box2 = sdBox(pos - vec3(0.9, 0, 0), vec3(0.5));\n    return min(box, box2);\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0, 1, 0)) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getColor(vec3 eye, vec3 dir,float dist){\n    float ambient = 0.2;\n    vec3 albedo = vec3(0.8, 0.1, 0.05);\n    vec3 collision = (eye += (dist*0.995) * dir );\n    vec3 normal = computeNormal(collision);\n    // Diffuse\n    vec3 lightDirection = vec3(1.0, 1.0, 1.0);\n    float diffuse = max(0.,dot(normal, lightDirection));\n\n    // Specular\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    float specular =  pow(max(0.,dot(h, normal)), specularityCoef);\n\n    return albedo * ((diffuse * ambient + ambient) + specular);\n}\n\nvec4 coneTrace(vec3 eye, vec3 dir, float aspectRatio) {\n    // t is the position of the center of the sphere along the ray.\n    float t = NEAR_CLIP;\n    float dist = EPSILON;\n\n    // https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer\n    float vFOV = 2.0 * atan( tan(radians(FOV) / 2.0) * aspectRatio );\n    float coneRadius = (2.0*tan(vFOV/2.0)) /(iResolution.y);\n    \n    \n    //Depth of Field\n    float aperture = .03 * iMouse.x/iResolution.x;\n\tfloat focus = 5.1 * iMouse.y/iResolution.y;\n\n    // Accumulate cone-scene intersections colors (rgb) and coverage (a)\n    vec4 acc = vec4(0, 0, 0, 1);\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float rad = t*coneRadius + t * aperture*(focus);\n\n        dist = map(eye + t * dir);\n        if (dist < rad) {\n            // how much of the surface of the projected pixel is covering the scene?\n            // https://www.shadertoy.com/view/4scBW8\n            float alpha = smoothstep(rad, -rad, dist);\n            vec3 sampleCol = getColor(eye, dir, t);\n            // the new color is calculated multiplying the previous alpha for the new color times the new alpha\n            acc.rgb += acc.a * (alpha*sampleCol.rgb);\n            acc.a *= (1.0 - alpha);\n            \n            if (acc.a < EPSILON ) return acc;\n        }\n        // move the center of the sphere forward along the ray\n        t += max(abs(dist*0.85), 0.001); //https://www.shadertoy.com/view/4dlyWB\n        if (t > FAR_CLIP) return acc;\n    }\n}\n\nvec3 raymarch(vec3 eye, vec3 rayDir) {\n    float t = NEAR_CLIP;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + t * rayDir);\n        if (dist < EPSILON) {\n\t\t\treturn getColor(eye, rayDir, t);\n        }\n        t += dist;\n        if (t >= FAR_CLIP) {\n            return vec3(-1);\n        }\n    }\n    return vec3(-1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec3 eye = vec3(cos(iTime * 0.2) * 10., 10, sin(iTime * 0.2) * 10.);\n    vec3 ta = vec3( 0 );\n    mat3 camera = setCamera( eye, ta );\n    //\n    float cameraDistance = 1.0 / tan(radians(FOV) / 2.0);\n    vec3 dir = camera * normalize(vec3(uv, cameraDistance));\n\n    // bg color\n    vec3 bgColor = vec3(0.086, 0.19, 0.8);\n    \n#ifdef CONETRACING\n    vec4 sceneColor = coneTrace(eye, dir, aspectRatio);\n    vec4 color = vec4(mix(sceneColor.rgb, bgColor, sceneColor.a), 1);\n#else\n    vec3 sceneColor = raymarch(eye, dir);\n    vec4 color = vec4(sceneColor.r != -1. ? sceneColor : bgColor, 1);\n#endif\n\nfragColor = color;\n}","name":"Image","description":"","type":"image"}]}