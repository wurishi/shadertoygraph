{"ver":"0.1","info":{"id":"DstSzf","date":"1680188463","viewed":111,"name":"Disturbed Lines","username":"LoganOracio","description":"disturbed lines","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["lines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = C.xy/iResolution.xy;\n    O = texture(iChannel0,uv);\n    O.x = pow(O.x*1.2,2.0);\n    O = O.x*mix(vec4(1.0,0.0,0.0,1.0),vec4(1.0),O.x*0.7-0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/4ljfRD\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1.0 / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\nfloat fbm(vec2 uv)\n{\n    return pnoise(uv)*0.5+pnoise(uv*2.0)*0.25+pnoise(uv*4.0)*0.125;\n}\n#define POINTS 16\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = (C.xy*2.0-iResolution.xy)/iResolution.x;\n    float rl = 0.0;\n    \n    for(int j = 0; j <8; j++)\n    {\n\n        vec3 pts[POINTS];\n        for(int i = 0; i < POINTS; i++)\n        {\n            pts[i] = vec3(float(i*2-POINTS)/float(POINTS),1.5*fbm(vec2(float(i)/float(POINTS)*0.6,float(j)*0.05+iTime*.3))-3.0,3.8+0.4*float(j));\n            pts[i] = vec3(pts[i].x,pts[i].y*cos(0.6)+pts[i].z*sin(0.6),pts[i].y*sin(0.6)+pts[i].z*cos(0.6));\n            pts[i] /= pts[i].z*0.65;\n        }\n        for(int i = 1; i < POINTS; i++)\n        {\n            rl = max(rl,drawLine(pts[i-1].xy,pts[i].xy,uv,1.3));\n        }\n    }\n    rl = max(rl,0.97*texture(iChannel0,C.xy/iResolution.xy+1.0/iResolution.xy*vec2(0.0,-1.0)).x);\n    rl = max(rl,0.97*texture(iChannel0,C.xy/iResolution.xy+1.0/iResolution.xy*vec2(1.0,-2.0)).x);\n    rl = max(rl,0.97*texture(iChannel0,C.xy/iResolution.xy+1.0/iResolution.xy*vec2(-1.0,-2.0)).x);\n    O = vec4(rl);\n}","name":"Buffer A","description":"","type":"buffer"}]}