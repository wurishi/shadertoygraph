{"ver":"0.1","info":{"id":"XtcSDs","date":"1482069241","viewed":180,"name":"The Hungry Cave","username":"Hadyn","description":"My first raymarched shader! It was actually a bit easier to learn than I expected - especially with so many excellent references provided across this site. The articles on iq's blog were a big help, too :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXDEPTH 200.\n#define FOGSTART 4.\n#if 1\n\t#define FOGCOLOR vec3(0.2,0.1,0.2)\n#else\n\t#define FOGCOLOR vec3(1.0,1.0,1.0)\n#endif\n#define FOV 120.\n#define TIMESCALE 0.5\n#define NEARPLANE 0.0001\n#define UP vec3(0.0, 1.0, 0.0)\n\n#define GRIDLINEWIDTH 0.05\n#define SCALE 0.1\n#define PI 3.14159265359\n\nfloat terrainHeight(vec2 p)\n{\n    float res;\n    p *= SCALE;\n    res = 4.0*4.0*abs(0.5-fract(p.x))*abs(0.5-fract(p.y));        \n    res += 6.0*4.0*abs(0.5-fract(p.x))*abs(0.5-fract(p.y)) * step(0.0, (0.5-fract((p.x-0.5)*0.5))) * step(0.0, (0.5-fract((p.y-0.5)*0.5))) ;\n\tres *= mix(1.5*(0.5+0.5*sin(TIMESCALE*PI*(iTime-0.25*(abs(p.x)+p.y)))), 1.0, step(0.0, (0.5-fract((p.x-0.5)*0.5))) * step(0.0, (0.5-fract((p.y-0.5)*0.5)))) ;\n    return res;    \n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat castRay( vec3 ro, vec3 rd, float tmin, float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        float rh = terrainHeight( pos.xz );\n\t\tfloat h = pos.y - rh;\n        h = smin(h, -(pos.y - (12.0 - rh)), 6.0);\n        //h = -(pos.y - (12.0 - rh));\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n// I borrowed this useful function from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = MAXDEPTH;\n    float t = castRay(ro,rd, tmin, tmax);\n \tif(t>tmax)\n    {\n        return vec4(1.0, 1.0, 1.0, 1.0/0.0);\n    }\n    vec2 res = (ro+rd*t).xz;\n    //return vec4(0,.5,.5, t);\n    return vec4(mix(vec3(0,.45,.5), vec3(0,.65,.65), (ro+rd*t).y/12.0), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= 0.5*vec2(iResolution.x/iResolution.y, 1); \n    \n    float camDist = 1.0/tan(radians(FOV*0.5));\n    \n    vec2 mouse = vec2(0.0);    \n\tif( iMouse.z>0.0 )\n        mouse = 2.0*iMouse.xy/iResolution.y-vec2(iResolution.x/iResolution.y,1);\n    \n    float zPos = TIMESCALE*4.0*iTime;\n    float camPhase = sin(PI*SCALE*0.5*(zPos+5.0));\n    float latePhase = sin(PI*SCALE*0.5*(zPos+6.0));\n    float doublePhase = sin(PI*SCALE*(zPos+0.0));\n    float lateDoublePhase = sin(PI*SCALE*(zPos+2.5));\n    \n    vec3 camForward = vec3(0, 0, 1);\n    camForward = mat3(rotationMatrix(UP, radians(15.0)*latePhase + mouse.x*-radians(90.0))) * camForward;\n\tvec3 camRight = cross(UP, camForward);\n    camRight = mat3(rotationMatrix(camForward, radians(-10.0)*camPhase)) * camRight;\n    camForward = mat3(rotationMatrix(camRight, radians(5.0)*lateDoublePhase + mouse.y*radians(90.0))) * camForward;\n\tvec3 camUp = cross(camForward, camRight);\n    vec3 vectorToPixel = vec3(uv.xy,camDist)*NEARPLANE;\n   \tvectorToPixel = (uv.x*camRight + uv.y*camUp + camDist*camForward)*NEARPLANE;\n    vec3 camPosition = vec3(5.0*camPhase,6.0+1.0*doublePhase,zPos);\n    \n    vec4 pixel = render(camPosition, normalize(vectorToPixel));\n    \n\tfloat fogStrength = 1.0-pow(clamp(1.0-max(pixel.w-FOGSTART,0.0)/(MAXDEPTH-FOGSTART), 0.0, 1.0), 1.8);\n    fragColor = vec4(pixel.rgb*(1.0-fogStrength) + FOGCOLOR*fogStrength, 1.0);\n}","name":"Image","description":"","type":"image"}]}