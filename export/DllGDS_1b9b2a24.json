{"ver":"0.1","info":{"id":"DllGDS","date":"1672332192","viewed":152,"name":"Fractal: Sierpinski triangle ","username":"explicite_shader","description":"Intelligible and simple implementation of Sierpinski triangle fractal.\nBased on https://www.youtube.com/watch?v=svLzmFuSBhk","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","triangle","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Intelligible and simple implementation of Sierpinski triangle fractal.\n    29/01/22 | @explicite_shader\n    \n    Based on https://www.youtube.com/watch?v=svLzmFuSBhk\n*/\n\n# define REC_DEPTH 6\n# define SQRT_3_OVER_2 0.866\n# define TRIPY_FACTOR 0.1\n\nvec2 mirror(vec2 normed_uv, vec2 a, vec2 b){\n\n    // Apply a mirror tranform along the line AB to the uv coordinates\n    \n    vec2 centered_uv = normed_uv - a;\n    \n    vec2 along = b - a;\n    along /= length(along);\n    \n    vec2 normal;\n    normal.x = b.y - a.y;\n    normal.y = a.x - b.x;\n    normal /= length(normal);\n    \n    mat2 mirror_mat = mat2(along.x, along.y, normal.x, normal.y)\n                    * mat2(1, 0, 0, -1)\n                    * mat2(along.x, normal.x, along.y, normal.y);\n    \n    float mirror_side = step(0.0, dot(normal, centered_uv));\n    \n    return (1.0-mirror_side)*centered_uv + (mirror_side)*mirror_mat*centered_uv+a;\n}\n\nfloat triangleDistance(vec2 normed_uv, vec2 a, vec2 b, vec2 c){\n\n    //Compute the signed distance function to a triangle ABC\n    \n    vec2 normal;\n    \n    normal.x = b.y - a.y;\n    normal.y = a.x - b.x;\n    normal /= length(normal);\n    float dist_ab = dot(normed_uv-a, normal);\n    \n    normal.x = c.y - b.y;\n    normal.y = b.x - c.x;\n    normal /= length(normal);\n    float dist_bc = dot(normed_uv-b, normal);\n    \n    normal.x = a.y - c.y;\n    normal.y = c.x - a.x;\n    normal /= length(normal);\n    float dist_ca = dot(normed_uv-c, normal);\n    \n    return max(max(dist_ab, dist_bc), dist_ca);\n}\n\nfloat sierpinski(vec2 normed_uv, vec2 a, vec2 b, vec2 c, int rec_depth){\n\n    //Compute the signed distance function to the Sierpinski fractal\n    \n    vec2 mirrored_uv = normed_uv;\n    \n    for(int i=0; i<rec_depth; i++){\n        mirrored_uv = mirror(mirrored_uv, a, 0.5*(c+b));\n        mirrored_uv = mirror(mirrored_uv, 0.5*(a+c),b);\n        mirrored_uv = (mirrored_uv-c)*2.0+c;\n    }\n    \n    return triangleDistance(mirrored_uv, a, b, c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 normed_uv = uv - 0.5;\n    normed_uv.x *= iResolution.x/iResolution.y;\n    \n    // Coordinates of the triangles edges\n    vec2 a = vec2(-0.5, -0.4 + 0.4*TRIPY_FACTOR*sin(0.3*iTime));\n    vec2 b = vec2(+0.5 + 0.2*TRIPY_FACTOR*cos(0.4*iTime), -0.4);\n    vec2 c = vec2(0, +SQRT_3_OVER_2-0.4 + 0.15*TRIPY_FACTOR*cos(0.65*iTime));\n    \n    // Compute the signed distance to the sierpinski fractal\n    float dist = sierpinski(normed_uv, a, b, c, REC_DEPTH);\n    float inside = step(0.0, dist);\n    \n    // Time varying pixel color\n    vec3 col_1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+dist);\n    vec3 col_2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+inside);\n\n    // Output to screen\n    fragColor = vec4(inside*(0.15*col_1+0.85*col_2), 1.0);\n}","name":"Image","description":"","type":"image"}]}