{"ver":"0.1","info":{"id":"M3G3Wz","date":"1717503606","viewed":137,"name":"Noah's Tower","username":"swafim","description":"In a dream, people built a high Tower named after Noah to escape flood, but were still submerged by the raging water.\nï»¿","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["underwater","tower","godray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// iChannel0 : Buffer A\n\nconst float water_depth = 140.;\nconst float AA = 1.;\n\nconst int MAX_STEP = 256;\nconst float MAX_DIST = 1000.;\n\nmat2 rot2D(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nmat3 get_camera_matrix(vec3 la) {\n    vec3 cw = normalize(la);\n    vec3 cu = -normalize(cross(cw, vec3(0, 1., 0)));\n    vec3 cv = cross(cw, cu);\n    return mat3(cu, cv, cw);\n}\n\nvec3 cyl_coord(vec3 cart_coord) {\n    float r = length(cart_coord.xz);\n    float theta = atan(cart_coord.z, cart_coord.x);\n    return vec3(r, cart_coord.y, r*theta);\n}\n\nvec3 voronoi(vec2 x) {\n    vec2 ip = floor(x), fp = fract(x);\n    vec2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = rand23( ip + g ).xy;\n            vec2 r = g + o - fp;\n            float d = dot(r,r);\n            if(d < md) {\n                md = d; mr = r; mg = g;\n            }\n        }\n    }\n    return vec3( md, mr );\n}\n\nfloat sd_box3d(vec3 p, vec3 s) {\n    p=abs(p)-s;\n    return length(max(p,vec3(0))) + min(0.,max(p.x,max(p.y,p.z)));\n}\n\nfloat sd_box2d(vec2 p, vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sd_cylring(vec3 p, vec3 a, vec3 b, float R, float r) {\n    vec3 ab = normalize(b - a), ap = p - a;\n    float height = length(b - a);\n    float py = dot(ap, ab), px = length(ap - ab * py);\n    vec2 box = vec2((R-r) / 2., height / 2.);\n    vec2 pp = vec2(px - (R+r) / 2., py - height / 2.);\n    return sd_box2d(pp, box);\n}\n\n// different details to control computation cost\nbool tower_detail, water_detail, wave_detail, tyndall_detail;\n\nfloat dist_tower, dist_ground, dist_water_surface;\nfloat dist_window;\nvec2 window_idx;\nfloat sdf(vec3 p) {\n    float d = 10000.0;\n    vec3 p_cyl = cyl_coord(p);\n    p_cyl.z -= 100.;\n\n    dist_tower = sd_cylring(p, vec3(0., -200., 0.), vec3(0., 100., 0.), 48., 40.);\n    if (tower_detail && dist_tower < 0.1) {\n        dist_tower -= 0.5 * voronoi(p_cyl.yz * 0.2).x;\n        dist_tower -= 0.05 * voronoi(p_cyl.yz * 0.6).x;\n    }\n    d = min(d, dist_tower);\n\n    dist_water_surface = water_depth - p.y;\n    if (water_detail) {\n        if (wave_detail && dist_water_surface < 0.1) {\n            dist_water_surface -= 2.5 * wave_height(0.15*p.xz, iTime, 15);\n        }\n        d = min(d, dist_water_surface);\n    }\n\n    dist_ground = p.y + 200.;\n    d = min(d, dist_ground);\n\n    window_idx = floor(p_cyl.yz / vec2(3., 1.5*PI));\n    dist_window = 100.;\n    if (p_cyl.y < 98. && rand21(window_idx) < 0.08) {\n        vec3 p_cyl_grid = p_cyl;\n        p_cyl_grid.yz = mod(p_cyl_grid.yz, vec2(3., 1.5*PI)) - vec2(1.5,0.75*PI);\n        dist_window = sd_box3d(p_cyl_grid - vec3(40.,0.,0.), vec3(0.05,1.0,1.5));\n        d = max(-dist_window, dist_tower);\n        if (dist_tower > 0.) {dist_window = length(p_cyl_grid - vec3(40.,0.,0.)) + 1.;}\n    }\n\n    return d;\n}\n\nvec3 get_normal(vec3 pos) {\n    vec3 eps = vec3(.001, 0, 0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < 6; i++) {\n        nor += sdf(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvec3 sun_drc = normalize(vec3(3., 3., 1.));\nvec3 refr_sun_drc; // = refract(sun_drc, vec3(0.,-1.,0.), 0.75);\n\nfloat get_tyndall(vec3 p) {\n    float hd = 100. - p.y;\n    vec2 wave_p = p.xz + hd / refr_sun_drc.y * refr_sun_drc.xz;\n    float light = texture(iChannel0, wave_p/80. + 0.5).x;\n    light *= smoothstep(40.1 + abs(hd) * 0.1, 39.9 - abs(hd) * 0.05, length(wave_p));\n    return light * smoothstep(200., 0., hd);\n}\n\nfloat tyndall;\nvec4 trace(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float d, travel_dist = 0.;\n    int i = 0;\n    tyndall = 0.0;\n    for(i = 0; i < MAX_STEP; i++) {\n        d = sdf(p);\n        if (d < 0.001 || d > MAX_DIST) { break; }\n        if (tyndall_detail) {\n            d = min(3., d);    // smaller step to eliminate artifacts\n            // d = min(1., d); // with more computation cost though\n        }\n        p += rd * d; travel_dist += d;\n        if (tyndall_detail) {\n            tyndall += d * get_tyndall(p);\n        }\n    }\n    return vec4(p, travel_dist);\n}\n\nvec3 skycol(vec3 rd) {\n    vec3 sky = mix(vec3(0.3, 0.5, 0.9), vec3(0.22, 0.44, 0.88), rd.y);\n    sky = mix(sky, vec3(0.99, 0.99, 0.99), smoothstep(0.9985, 0.999, dot(rd,sun_drc)));\n    sky = mix(sky, vec3(0.99, 0.9, 0.7), smoothstep(0.8, 1.3, dot(rd, sun_drc)));\n    return sky;\n}\n\nfloat schlick(vec3 rd, vec3 normal) {\n    float f = 0.15; // Not real, should be 0.02\n    float c = - dot(rd, normal);\n    if (c < 0.) {return 1.;}\n    return f + (1.-f) * pow(1.-c, 5.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.), cam_pos = ro;\n    \n    const int bounce_time = 2;\n    float blend = 1.;\n    for (int k = 0; k < bounce_time; k++) {\n        tower_detail = false; water_detail = true; wave_detail = false;\n        tyndall_detail = (k == 0);\n        vec4 pt = trace(ro, rd);\n        vec3 hit_point = pt.xyz;\n        float travel_dist = pt.w;\n\n        float dist_tower2 = dist_tower;\n        float dist_ground2 = dist_ground;\n        float dist_water_surface2 = dist_water_surface;\n        float dist_window2 = dist_window;\n        vec2 window_idx2 = window_idx;\n\n        tower_detail = (k == 0); water_detail = true; wave_detail = (k == 0);\n        vec3 normal = get_normal(hit_point);\n        \n        vec3 cur_color = vec3(0.);\n        float alpha = 1.; // diffusion ratio\n        bool keep_bounce = (k < bounce_time - 1);\n        \n        float absorb_dist = travel_dist + 0.7 * (water_depth - hit_point.y);\n        vec3 absorb_factor = exp(\n            -vec3( .006,.004,.003 ) * absorb_dist\n        ); // light absorbance by water. thanks @FabriceNeyret2\n        \n        if (k == 0 && dist_window2 < 0.001) {\n            float window_brightness = rand21(window_idx + 0.33);\n            float shad = mix(0.7, 1., get_tyndall(hit_point));\n            window_brightness = shad * c01(smoothstep(0.3, 0.7, window_brightness)+0.1);\n            cur_color = vec3(window_brightness);\n            cur_color *= mix(vec3(1.), absorb_factor, 0.7); // thanks @msm01\n        }\n        else if (dist_tower2 < 0.001) {\n            alpha = 0.9;\n            vec3 diffusion = vec3(0.7);\n            float shad = pow(get_tyndall(hit_point), 1.2);\n            cur_color = 2.5 * mix(vec3(0.), max(0., dot(refr_sun_drc, normal)) * diffusion, shad);\n            if (hit_point.y > 100.) {cur_color = 1. *  max(0., dot(refr_sun_drc, normal)) * diffusion;}\n            cur_color += 0.2 * max(0., dot(normalize(cam_pos - hit_point), normal)) * diffusion;\n            cur_color = mix(cur_color, vec3(0.99, 0.9, 0.7), smoothstep(50., 200., hit_point.y));\n            cur_color *= absorb_factor;\n        }\n        else if (dist_ground2 < 0.001) {\n            cur_color = absorb_factor * max(0., dot(refr_sun_drc, normal));\n            keep_bounce = false;\n        }\n        else if (dist_water_surface2 < 0.001) {\n            vec3 rd_out = refract(rd, normal, 1.33);\n            float air = schlick(rd_out, normal), water = schlick(rd, normal);\n            alpha = (1.-air) / (1.-air + water);\n            cur_color = skycol(rd_out);\n            cur_color *= absorb_factor;\n            if (alpha < 0.1) {\n                cur_color = vec3(0.2, 0.4, .8);\n                alpha = 0.5;\n            }\n        }\n\n        cur_color += float(k == 0) * vec3(0.99, 0.9, 0.7) * tyndall * 0.018;\n        cur_color *= mix(1., 0., smoothstep(50., 250., 100.-hit_point.y));\n\n        float coef = blend;\n        if (keep_bounce) { coef *= alpha; }\n        color += coef * cur_color;\n\n        if (!keep_bounce) { break; }\n        blend *= 1. - alpha;\n        rd = normalize(reflect(rd, normal));\n        if (dot(rd, normal) < 0.) {\n            color += blend * cur_color;\n            break;\n        }\n        ro = hit_point + 0.05 * rd;\n    }\n\n    return c01(color);\n}\n\nvec3 random_disturbance(float time, float iter, float seed) {\n    vec3 bias = vec3(0.,0.,0.);\n    float a = 1., sa = 0., freq = 1.0;\n    for (float i = 0.; i < iter; i++) {\n        vec3 drc = rand23(vec2(i + seed, rand11(i + seed)));\n        bias += drc * a * sin(freq * time);\n        sa += a; a *= 0.8;\n        freq *= 1.2;\n    }\n    return bias / sa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    sun_drc = normalize(sun_drc + 0.2*random_disturbance(0.1*iTime, 2., 0.13267)); // sun motion\n    refr_sun_drc = refract(sun_drc, vec3(0.,-1.,0.), 0.75);\n\n    vec3 bias = random_disturbance(iTime, 5., 1.231441);\n    vec3 dbias = random_disturbance(0.2*iTime, 5., 0.8714);\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uvbias = vec2(wave_height(uv*8., iTime*3., 4), wave_height(uv*8.+0.23, iTime*3.+0.71, 4));\n    uv = uv + uvbias * 0.007;\n\n    vec3 ro = vec3(0., 15., -35.) + 2.*bias;\n    vec3 la = normalize(vec3(-0.75, 1.5, 1.)) + 0.1 * dbias;\n    if (iMouse.z > .5) {\n        vec2 mouse_uv = iMouse.xy / iResolution.xy;\n        la = vec3(0., 0., 1.);\n        la.zy = rot2D(mouse_uv.y * PI - PI * 0.5) * la.zy;\n        la.zx = rot2D(mouse_uv.x * 2. * PI - PI) * la.zx;\n    }\n    mat3 cmat = get_camera_matrix(la);\n    \n    vec3 rd = cmat * normalize(vec3(uv.x, uv.y, 1.45) + vec3(uv.x, uv.y, -1.45) * dot(uv, uv) * 0.05);  \n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(1.25));\n\n    fragColor = vec4(col, 1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define c01(x) clamp(x, 0., 1.)\n#define s01(x) smoothstep(0., 1., x)\nconst float PI = 3.14159265358;\n\nfloat rand11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rand23(vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rand31(vec3 p3) {\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rand33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat rand21(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat wave_height(vec2 position, float time, int iter) {\n    float seed = 0.0, frequency = 1.0, timeMultiplier = 1.5;\n    float weight = 1.0, sum_weights = 0.0, sum_height = 0.0;\n    for(int i = 0; i < iter; i++) {\n        vec2 direction = vec2(sin(seed), cos(seed));\n        float x = dot(direction, position) * frequency + time * timeMultiplier;\n        float wave = 0.5 * (1.0 + sin(x));\n        float wavedx =  0.5* cos(x);\n        position -= direction * wavedx * weight * 0.4;\n        sum_height += wave * weight; sum_weights += weight;\n        weight *= 0.87; frequency *= 1.18; timeMultiplier *= 1.07; seed += 1232.399963;\n    }\n    return sum_height / sum_weights;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float h = wave_height(uv * 20., iTime, 15);\n    fragColor = vec4(h, h, h, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}