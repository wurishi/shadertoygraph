{"ver":"0.1","info":{"id":"ltVBRm","date":"1542142293","viewed":64,"name":"Intro to Graphics mjv42","username":"mjv42","description":"Graphics Supervision 1 - mjv42","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["supervision1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\n//TODO: TASK1\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    // IMPLEMENT PHONG MODEL HERE\n    \n    d = 0.0;\n    s = 0.0;\n    \n    float L_dot_N = L.x*N.x + L.y*N.y + L.z*N.z;\n   \tvec3 R = vec3(N.x*L_dot_N*2.0 - L.x, N.y*L_dot_N*2.0, N.z*L_dot_N*2.0);\n    R = normalize(R);\n    \n    \n    float R_dot_V = R.x*V.x + R.y*V.y + R.z*V.z;\n    \n    if (R_dot_V < 0.0) {\n        s = 0.0;\n    } else {\n        s = R_dot_V;\n        for(; sh > 0.0; sh = sh - 1.0) {\n        \ts = s*R_dot_V;\n    \t}\n    }\n    \n    if(L_dot_N < 0.0) {\n        d = 0.0;\n    } else {\n        d = L_dot_N;\n    }\n\t\n    \n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    Ray r;\n    r.Direction = normalize(vec3(uv,1.0));\n    r.Orgin = vec3(0,0,-4.0);\n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        col = texture(iChannel0, planeUV).xyz; \n        //TODO: TASK3\n        // ADD FLOOR PATTERNS\n\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    //TODO: TASK3\n    //SCREEN SPACE EFFECTS\n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}