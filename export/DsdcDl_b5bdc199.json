{"ver":"0.1","info":{"id":"DsdcDl","date":"1699650557","viewed":19,"name":"TP image ","username":"Jares","description":"Fin du TP d'image","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n////////////////////             Data Structures            ////////////////////\n////////////////////////////////////////////////////////////////////////////////\nstruct Sphere\n{\n    vec3 c;  // Center\n    float r; // Radius\n    int i;   // Texture Id\n};\n\nstruct Plane\n{\n    vec3 n; // Normal\n    vec3 p; // Point\n    int i;  // Texture Id\n};\n\nstruct Ellipsoide\n{\n    vec3 c; // Center\n    vec3 e; // Rayon\n    int i;  // Texture Id\n};\n\nstruct Cylinder\n{\n    vec3 a, b; // Center\n    float r;   // Rayon\n    int i;     // Texture Id\n};\n\nstruct Box\n{\n    vec3 a, b;\n    int i; // Texture Id\n};\n\n\n/*************************************/\nstruct Hit\n{\n    float t; // Intersection depth\n    vec3 n;  // Normal\n    int i;   // Texture Id\n};\n\nstruct Ray\n{\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Material\n{\n    vec3 ka; // Ambiant\n    vec3 kd; // Diffuse\n    vec3 ks; // Speculaire\n    float alpha; // shininess\n    float mirror; // mirroreness\n    float transparency; \n};\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////                Constants               ////////////////////\n////////////////////////////////////////////////////////////////////////////////\nconst vec3 LIGHT_POSITION = vec3(0., 0., 6);\nconst int NB_REBOUND = 3;\nconst int NB_SAMPLES_OCCLUSION = 0;\nconst float DISTANCE_OCCULSION = 2.;\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////             Utils Functions            ////////////////////\n////////////////////////////////////////////////////////////////////////////////\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w = fwidth(p) + .001;\n    // Box box filter\n    vec2 i = 2. * (abs(fract((p - .5 * w) * .5) - .5) - abs(fract((p + .5 * w) * .5) - .5)) / w;\n    // xor pattern\n    return .5 - .5 * i.x * i.y;\n}\n\n// Compute point on ray\nvec3 Point(in Ray ray, in float t)\n{\n    return ray.o + t * ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 10) { // Bleue\n        return Material(vec3(0.), vec3(0., 0., 1.), vec3(.5), 100., 0., 0.);\n    }\n    else if (i == 9) { // Vert\n        return Material(vec3(0.), vec3(0., 1., 0.), vec3(0.), 100., 0.1, 0.);\n    }\n    else if (i == 8) { // Rouge\n        return Material(vec3(0.), vec3(1., 0., 0.), vec3(0.), 100., 0., 0.5);\n    }\n    else if (i == 1)\n    {\n        return Material(vec3(0., 0., .3), vec3(0., 0., 1.), vec3(1.), 10., 1., 0.);\n    }\n    else if (i == 0) // \n    {\n        // compute checkboard\n        float f = Checkers(.5 * p.xy);\n        vec3 col = vec3(.5, 0., .5) + f * vec3(.2);\n        return Material(vec3(0.1), col, vec3(0.2), 1., 0., 0.);\n    }\n    else if (i == -1) {\n        vec3 col = vec3(0., 0., 1.); // value if f==0\n\n        int f =  int(.5 * sqrt(pow(p.x, 2.) + pow(p.y, 2.))) % 3;\n        if (f == 1) {\n            col = vec3(.5, 0., .8);\n        }\n        else if (f == 2) {\n            col = vec3(1., 0., .6);\n        }\n        return Material(vec3(0.1), col, vec3(0.2), 1., 0., 0.);\n    }\n    return Material(vec3(0.), vec3(0.), vec3(0.), 1., 0., 0.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////          Rotation Functions            ////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 rotateX(in vec3 p){\n    float sinTime = sin(iTime);\n    float cosTime = cos(iTime);\n\n    mat3 transformation = mat3(1., 1., 0.,\n                                0., cosTime, sinTime,\n                                0., -sinTime, cosTime);\n    \n    return p * transformation;\n}\n\nvec3 rotateY(in vec3 p){\n    float sinTime = sin(iTime);\n    float cosTime = cos(iTime);\n\n    mat3 transformation = mat3(cosTime, 0., -sinTime,\n                                0., 1., 0.,\n                                sinTime, 0., cosTime);\n    \n    return p * transformation;\n}\n\nvec3 rotateZ(in vec3 p){\n    float sinTime = sin(iTime);\n    float cosTime = cos(iTime);\n\n    mat3 transformation = mat3(cosTime, sinTime, 0.,\n                                -sinTime, cosTime, 0.,\n                                0., 1., 0.);\n    \n    return p * transformation;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////           Intersect Functions          ////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n// Sphere intersection\n// ray : The ray\n// sph : The sphere to intersect\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x)\n{\n    vec3 oc = ray.o - sph.c;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float d = b * b - c;\n    if (d > 0.)\n    {\n        float t = -b - sqrt(d);\n        if (t >= 0.)\n        {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - sph.c), sph.i);\n\n            return true;\n        }\n    }\n    return false;\n}\n\n// Ellipsoide intersection\n// ray : The ray\n// ell : The ellipsoide to intersect\n//   x : Returned intersection information\nbool IntersectEllipsoide(Ray ray, Ellipsoide ell, out Hit x)\n{\n    float a = dot(ray.d / ell.e, ray.d / ell.e);\n    float b = dot(2. * ((ray.o - ell.c) / ell.e), ray.d / ell.e);\n    float c = dot((ray.o - ell.c) / ell.e, (ray.o - ell.c) / ell.e) - 1.;\n    float delta = b * b - 4. * a * c;\n\n    if (delta > 0.0)\n    {\n        float t = (-b - sqrt(delta)) / (2. * a);\n        if (t < 0.) // Point derrière la caméra\n        {\n            float t = (-b + sqrt(delta)) / (2. * a);\n            if (t < 0.) // Point derrière la caméra\n            {\n                return false;\n            }\n        }\n        vec3 p = Point(ray, t);\n        x = Hit(t, normalize(p - ell.c), ell.i);\n        return true;\n    }\n    return false;\n}\n\n// Infinite cylinder intersection\n// ray : The ray\n// cyl : The cylinder to intersect\n//   x : Returned intersection information\nbool IntersectInfiniteCylinder(Ray ray, Cylinder cyl, out Hit x)\n{\n    vec3 u = normalize(cyl.b - cyl.a);\n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, u), 2.);\n    vec3 oa = ray.o - cyl.a;\n    float b = 2. * (dot(oa, ray.d) - (dot(oa, u) * dot(ray.d, u)));\n    float c = dot(oa, oa) - pow(dot(oa, u), 2.) - pow(cyl.r, 2.);\n\n    float delta = b * b - 4. * a * c;\n\n    if (delta > 0.)\n    {\n        float t = (-b - sqrt(delta)) / (2. * a);\n        if (t < 0.) // Point derrière la caméra\n        {\n            float t = (-b + sqrt(delta)) / (2. * a);\n            if (t < 0.) // Point derrière la caméra\n            {\n                return false;\n            }\n        }\n        vec3 p = Point(ray, t);\n        vec3 p_ab = cyl.a + u * dot((p - cyl.a), u); // Projection de p sur la droite ab\n        vec3 normale = p - p_ab;\n        x = Hit(t, normalize(normale), cyl.i);\n        return true;\n    }\n    return false;\n}\n\n// Cylinder intersection\n// ray : The ray\n// cyl : The cylinder to intersect\n//   x : Returned intersection information\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x)\n{\n    vec3 u = normalize(cyl.b - cyl.a);\n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, u), 2.);\n    vec3 oa = ray.o - cyl.a;\n    float b = 2. * (dot(oa, ray.d) - (dot(oa, u) * dot(ray.d, u)));\n    float c = dot(oa, oa) - pow(dot(oa, u), 2.) - sqrt(cyl.r);\n\n    float delta = b * b - 4. * a * c;\n\n    if (delta > 0.0)\n    {\n        float t = (-b - sqrt(delta)) / (2. * a);\n        if (t < 0.) // Point derrière la caméra\n        {\n            t = (-b + sqrt(delta)) / (2. * a);\n            if (t < 0.) // Point derrière la caméra\n            {\n                return false;\n            }\n        }\n\n        vec3 p = Point(ray, t);\n        vec3 p_ab = cyl.a + u * dot(u, (p - cyl.a)); // Projection de p sur la droite ab\n        vec3 normale = p - p_ab;\n\n        // Calcul length of AP and AB\n        float length_AP = length(p_ab - cyl.a);\n        float length_AB = length(cyl.b - cyl.a);\n\n        // Calcule du cos(theta) avec theta : angle entre AP et AB\n        float cos_AP_AB = dot(p_ab - cyl.a, u) / (length_AP * length_AB);\n\n        // Si scalaire_AP > scalaire_AB -> pas d'affichage\n        if ((length_AP > length_AB) || (cos_AP_AB < 0.))\n        {\n            float t_plan_a = -dot(ray.o - cyl.a, -u) / dot(ray.d, -u);\n            float t_plan_b = -dot(ray.o - cyl.b, u) / dot(ray.d, u);\n\n            if (t_plan_a < t_plan_b)\n            {\n                t = t_plan_a;\n                p = Point(ray, t);\n                if (length(p - cyl.a) > cyl.r)\n                {\n                    return false;\n                }\n                normale = -u;\n            }\n            else\n            {\n                t = t_plan_b;\n                p = Point(ray, t);\n                if (length(p - cyl.b) > cyl.r)\n                {\n                    return false;\n                }\n                normale = u;\n            }\n        }\n        x = Hit(t, normalize(normale), cyl.i);\n        return true;\n    }\n    return false;\n}\n\n// Capsule intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectCapsule(Ray ray, Cylinder cyl, out Hit x)\n{\n    vec3 u = normalize(cyl.b - cyl.a);\n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, u), 2.);\n    vec3 oa = ray.o - cyl.a;\n    float b = 2. * (dot(oa, ray.d) - (dot(oa, u) * dot(ray.d, u)));\n    float c = dot(oa, oa) - pow(dot(oa, u), 2.) - sqrt(cyl.r);\n\n    float delta = b * b - 4. * a * c;\n\n    if (delta > 0.0)\n    {\n        float t = (-b - sqrt(delta)) / (2. * a);\n        if (t < 0.) // Point derrière la caméra\n        {\n            t = (-b + sqrt(delta)) / (2. * a);\n            if (t < 0.) // Point derrière la caméra\n            {\n                return false;\n            }\n        }\n\n        vec3 p = Point(ray, t);\n        vec3 p_ab = cyl.a + u * dot(u, (p - cyl.a)); // Projection de p sur la droite ab\n        vec3 normale = p - p_ab;\n\n        // Calcule longueur AP et AB\n        float length_AP = length(p_ab - cyl.a);\n        float length_AB = length(cyl.b - cyl.a);\n        // Calcule du cos(theta) avec theta : angle entre AP et AB\n        float cos_AP_AB = dot(p_ab - cyl.a, u) / (length_AP * length_AB);\n\n        // Si scalaire_AP > scalaire_AB -> pas d'affichage\n        if (cos_AP_AB < 0.)\n        {\n            vec3 oc = ray.o - cyl.a;\n            float b = dot(oc, ray.d);\n            float c = dot(oc, oc) - pow(cyl.r, 2.);\n            float d = b * b - c;\n            if (d > 0.)\n            {\n                float t = -b - sqrt(d);\n                if (t > 0.)\n                {\n                    p = Point(ray, t);\n                    x = Hit(t, normalize(p - cyl.a), cyl.i);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if ((length_AP > length_AB))\n        {\n\n            vec3 oc = ray.o - cyl.b;\n            float b = dot(oc, ray.d);\n            float c = dot(oc, oc) - pow(cyl.r, 2.);\n            float d = b * b - c;\n            if (d > 0.)\n            {\n                float t = -b - sqrt(d);\n                if (t > 0.)\n                {\n                    p = Point(ray, t);\n                    x = Hit(t, normalize(p - cyl.b), cyl.i);\n                    return true;\n                }\n            }\n            return false;\n        }\n        x = Hit(t, normalize(normale), cyl.i);\n        return true;\n    }\n    return false;\n}\n\n// Plane intersection\n// ray : The ray\n//  pl : The plane to intersect\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x)\n{\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.)\n    {\n\n        x = Hit(t, vec3(0, 0, 1), pl.i);\n        return true;\n    }\n    return false;\n}\n\n// Box intersection\n// ray : The ray\n// box : The box to intersect\n//   x : Returned intersection information\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n    vec3 X = vec3(1., 0., 0.);\n    vec3 Y = vec3(0., 1., 0.);\n    vec3 Z = vec3(0., 0., 1.);\n\n    float t_x_a = -dot(ray.o - box.a, X) / dot(ray.d, X);\n    float t_x_b = -dot(ray.o - box.b, X) / dot(ray.d, X);\n\n    float t_y_a = -dot(ray.o - box.a, Y) / dot(ray.d, Y);\n    float t_y_b = -dot(ray.o - box.b, Y) / dot(ray.d, Y);\n\n    float t_z_a = -dot(ray.o - box.a, Z) / dot(ray.d, Z);\n    float t_z_b = -dot(ray.o - box.b, Z) / dot(ray.d, Z);\n\n    float t_x_min = min(t_x_a, t_x_b);\n    float t_x_max = max(t_x_a, t_x_b);\n\n    float t_y_min = min(t_y_a, t_y_b);\n    float t_y_max = max(t_y_a, t_y_b);\n\n    float t_z_min = min(t_z_a, t_z_b);\n    float t_z_max = max(t_z_a, t_z_b);\n\n    float t_min = max(max(t_x_min, t_y_min), t_z_min);\n    float t_max = min(min(t_x_max, t_y_max), t_z_max);\n\n    if (t_min < t_max)\n    {\n        vec3 normale = vec3(0.);\n\n        if (t_min == t_x_a)\n        {\n            normale = normalize(vec3(box.a.x - box.b.x, 0., 0.));\n        }\n        if (t_min == t_x_b)\n        {\n            normale = normalize(vec3(box.b.x - box.a.x, 0., 0.));\n        }\n        if (t_min == t_y_a)\n        {\n            normale = normalize(vec3(0., box.a.y - box.b.y, 0.));\n        }\n        if (t_min == t_y_b)\n        {\n            normale = normalize(vec3(0., box.b.y - box.a.y, 0.));\n        }\n        if (t_min == t_z_a)\n        {\n            normale = normalize(vec3(0., 0., box.a.z - box.b.z));\n        }\n        if (t_min == t_z_b)\n        {\n            normale = normalize(vec3(0., 0., box.b.z - box.a.z));\n        }\n\n        vec3 p = Point(ray, t_min);\n        x = Hit(t_min, normale, box.i);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x)\n{\n    // Spheres\n    Sphere sph1 = Sphere(rotateY(vec3(0., -2., 2.)) + vec3(0., 0., 4.), 1., 10);\n    Sphere sph2 = Sphere(rotateX(vec3(0., 2., 2.)) + vec3(0., 0., 4.), 1., 9);\n    Sphere sph3 = Sphere(rotateZ(vec3(2., 0., 2.)) + vec3(0., 0., 2.), 1., 8);\n    const Sphere sph4 = Sphere(vec3(-4., 0., 2.), 1., 1);\n\n    // Ellipsoide\n    const Ellipsoide ell1 = Ellipsoide(vec3(0., 3., 2.), vec3(1.5, 0.7, 0.7), 10);\n\n    // Cylinder \n    const Cylinder cyl1 = Cylinder(vec3(-1., -3., 2.), vec3(1., -3., 2.), 1., 9);\n\n    // Box\n    const Box box1 = Box(vec3(-1., -5., 1.), vec3(1., -6., 3.), 8);\n\n    const Plane pl = Plane(vec3(0., 0., 1.), vec3(0., 0., 0.), -1);\n\n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n\n\n    if (IntersectSphere(ray, sph1, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    if (IntersectSphere(ray, sph2, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    if (IntersectSphere(ray, sph3, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    if (IntersectSphere(ray, sph4, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    // if (IntersectEllipsoide(ray, ell1, current) && current.t < x.t)\n    // {\n    //     x = current;\n    //     ret = true;\n    // }\n\n    // if (IntersectCylinder(ray, cyl1, current) && current.t < x.t)\n    // {\n    //     x = current;\n    //     ret = true;\n    // }\n\n    // if (IntersectBox(ray, box1, current) && current.t < x.t)\n    // {\n    //     x = current;\n    //     ret = true;\n    // }\n\n    if (IntersectPlane(ray, pl, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n\n\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////             Others Functions           ////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8, .8, .9), vec3(.7, .7, .8), rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(0,0,1);\n    vec3 cu =-normalize(cross(cw,cp));\n    vec3 cv =-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Hemisphere direction\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n   \n    return d;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int N)\n{\n    if(N==0){return 1.;}\n    float ao=1.;\n\n    Hit x;\n\n    for(int i=0;i<N;i++)\n    {\n        vec3 d = Hemisphere (i,n); // d dans la demi-sphere \n        Ray random_ray = Ray(p, d);\n        if (Intersect(random_ray, x)) {\n            if (x.t < DISTANCE_OCCULSION) {\n                ao -= 1. / float(N);\n            }\n        }\n    }\n    return ao;\n}\n\n// Returne the direction vector as the reflection of the light \n// light : the light \n//     n : normal\nvec3 getReflection(in vec3 light, in vec3 n) \n{\n    return 2. * dot(-light, n) * n + light;\n}\n\n// Return true if a point is in a shadow\nbool Shadow(in vec3 p, in vec3 n, in vec3 light)\n{\n    Hit x; \n    // return false;\n    return   Intersect(Ray(p + n * 0.0001, light), x);\n}\n\n\n// Return the color of the phong reflection model\nvec3 getPhongColor (in Material m, in vec3 p, in vec3 n, in vec3 light, in vec3 view) {\n    // Shadow\n    if (Shadow(p + n * 0.001, n, light))\n    {\n        return vec3(0.);\n    }\n    else\n    {   \n        float diffuse = clamp(dot(n, light), 0., 1.);\n\n        vec3 lightReflection = getReflection(light, n);\n        float specular = pow(clamp(dot(lightReflection, view), 0., 1.), m.alpha);        \n\n        return (1. - m.mirror) * (m.ka + m.kd * diffuse + m.ks * specular);\n    }\n}\n\n// Return the color of the reflected light\n// p : point de reflexion\n// n : normal\n// v : direction de notre demie-droite d'observation \nvec3 getReflectedColor (in vec3 p, in vec3 n, in vec3 v) {\n    vec3 returnedColor = vec3(0.);\n\n    vec3 viewDirectionReflected = getReflection(v, n);\n    \n    Ray reflectedView = Ray(p + n * 0.0001, viewDirectionReflected);\n    Hit x;\n\n    for (int i = 0; i < NB_REBOUND; i++) {\n\n        bool idx = Intersect(reflectedView, x);\n\n        // Intersect an object\n        if (idx)\n        {\n            vec3 pointOnObjectReflected = Point(reflectedView, x.t);\n            Material mat = Texture(pointOnObjectReflected, x.i);\n\n            vec3 lightOnObjectReflected = normalize(LIGHT_POSITION - pointOnObjectReflected);\n            \n            returnedColor += (1. - mat.mirror) *  getPhongColor(mat, pointOnObjectReflected, x.n, lightOnObjectReflected, viewDirectionReflected);\n\n            // If the new intersected object is also reflective\n            if (mat.mirror > 0.) {\n                viewDirectionReflected = getReflection(viewDirectionReflected, x.n);\n                reflectedView = Ray(pointOnObjectReflected - x.n * 0.0001 , viewDirectionReflected);\n            }\n            else \n            {\n                break;\n            }\n        }\n        // Intersect Nothing\n        else\n        {\n            returnedColor =  Background(reflectedView.d);\n            break;\n        }\n    }\n\n    return returnedColor;\n}\n\n// Return the color of the refracted light\n// p : point de reflexion\n// n : normal\n// v : direction de notre demie-droite d'observation \nvec3 getRefractedColor (in vec3 p, in vec3 n, in vec3 v) {\n    vec3 returnedColor = vec3(0.);\n\n    Ray rayContinuity = Ray(p - n * 0.0001, v);\n    Hit x; \n\n    for (int i = 0; i < NB_REBOUND; i++) {\n        bool idx = Intersect(rayContinuity, x);\n        if (idx) {\n            vec3 pointBehindOject = Point(rayContinuity, x.t);\n            Material mat = Texture(pointBehindOject, x.i);\n\n            vec3 lightBeginOject = normalize(LIGHT_POSITION - pointBehindOject);\n\n            returnedColor += (1. - mat.transparency) * getPhongColor(mat, pointBehindOject, x.n, lightBeginOject, v);\n\n            // If the new intersected object is also transparent\n            if (mat.transparency > 0.) {\n                rayContinuity = Ray(pointBehindOject - x.n * 0.0001 , v);\n            }\n            else \n            {\n                break;\n            }\n        }\n        else \n        {\n            returnedColor = Background(rayContinuity.d);\n            break;\n        }\n    } \n    return returnedColor;\n}\n\n// Apply color model\n// m : Material\n// n : normal\n// p : point d'affichage\n// v : direction de notre demie-droite d'observation \nvec3 Color(Material m, vec3 n, vec3 p, vec3 v)\n{\n    // pour avoir une lumière ponctuelle : soustraire p \n    vec3 light = normalize(LIGHT_POSITION - p);\n    vec3 lightColor = vec3(1., 1., 1.);\n\n    vec3 reflectedColorComponent = vec3(0.);\n    vec3 phongColor = vec3(0.);\n    vec3 refractedColorComponent = vec3(0.);\n\n    // If the texture is transparent\n    if (m.transparency > 0.) \n    {   \n        refractedColorComponent = m.transparency *  getRefractedColor(p, n, v);\n    }\n\n    // If the texture is not totaly transparent\n    if (m.transparency < 1.)\n    {   \n        // If the texture reflect the light\n        if (m.mirror > 0.) {\n            reflectedColorComponent = m.mirror * getReflectedColor(p, n, v);            \n        }\n\n        // If the texture not reflect totaly the light\n        if (m.mirror < 1. ) {            \n            phongColor = getPhongColor(m, p, n, light, v);\n        }\n    }\n \n    float occlusion = AmbientOcclusion(p + n * 0.0001, n, NB_SAMPLES_OCCLUSION);\n    return occlusion * (((1. - m.mirror) * phongColor + reflectedColorComponent) * lightColor * (1. - m.transparency) + refractedColorComponent);\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx = Intersect(ray, x);\n\n    // Intersect an object\n    if (idx)\n    {\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n\n        return Color(mat, x.n, p, ray.d);\n    }\n    // Intersect Nothing\n    else\n    {\n        return Background(ray.d);\n    }\n\n    return vec3(0.);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////                  Main                  ////////////////////\n////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // Ray origin\n    vec3 ro = 18. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n    vec3 ta = vec3(0., 0., 1.5);\n    mat3 ca = setCamera(ro, ta);\n\n    // Ray\n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n\n    // Render\n    vec3 col = Shade(Ray(ro, rd));\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}