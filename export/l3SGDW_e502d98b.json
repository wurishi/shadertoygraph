{"ver":"0.1","info":{"id":"l3SGDW","date":"1708455732","viewed":34,"name":"Colored Mandelbrot set","username":"Mate12345","description":"This is a very simple, colored mandelbrot set.\n(To be exact, the mandelbrot set is black, but its perimiter is colored)\n\nI added a slow time-based zooming and you can control the exact spot using your mouse in a small range.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/**\nThe usage of the break inside the for cycle increases the performance in this case\nPotential for Optimization: If the condition causing the break is likely to be true for most threads in a SIMD group early in the loop, using break can significantly reduce runtime by avoiding unnecessary iterations. This can lead to performance improvements, especially in cases where the avoided computations are costly.\nRisk of Divergence: If the likelihood and timing of the break condition vary widely across the threads, this can introduce divergence, potentially reducing the efficiency of SIMD execution. The performance impact of divergence can vary based on the hardware and the specifics of the shader program.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    vec2 uv = (fragCoord/iResolution.xy)*(1.0/(128.0+iTime*64.0));\n\n    vec2 offset = vec2(-0.3005, 0.492) + (mouseUv-vec2(0.5, 0.5))/1000.0;\n\n    vec2 z = uv - offset;\n    vec2 z0 = z;\n    float res = -1.0;\n    bool exceeded = false;\n    const int iteration = 1000;\n    const float divergenceLimit = 100.0;\n\n    for( int i=0; i<iteration; i++ )\n    {\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n        z = z + z0;\n        float len = length(z);\n        bool firstToExceedTheLimit = len>divergenceLimit;\n        exceeded = firstToExceedTheLimit;\n        res = float(i);\n        if (firstToExceedTheLimit) break;\n    }\n    \n    res += 1.0;\n    float h = res / float(iteration);\n    \n\n    vec3 col = hsv2rgb(vec3(h, 1.0, 1.0)) * float(exceeded) + vec3(0.0) * (1.0 - float(exceeded));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}