{"ver":"0.1","info":{"id":"Xs3cDS","date":"1519932933","viewed":148,"name":"Raymarched Sound Visualizer","username":"DeadMan","description":"This is a basic visualizer that converts sound into a terrain and then raymarches it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float fov = 100.0;\nconst float maxDist = 5000.0;\nconst float terrainHeight = 200.0;\nconst float terrainSize = 1.0;\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit{\n    vec3 color;\n\tvec3 worldPosition;\n    vec3 normal;\n    float depth;\n    bool hit;\n};\n    \nvec2 getTerrainUV(vec2 v){\n    vec2 res = iChannelResolution[0].xy;\n    //return mod(v, res) / res / vec2(2);\n    return v / res;\n}\n    \nbool IsVectorInTerrain(vec3 v){\n    vec2 uv = getTerrainUV(v.xz / terrainSize);\n    float height = texture(iChannel0, uv).x * terrainHeight;\n    if (uv.x < 0.0 || uv.x > 1.0){\n        return false;\n    }\n    return v.y <= height;\n}\n\nvec3 GetTerrainNormal(vec3 v){\n    vec2 uv = getTerrainUV(v.xz / terrainSize);\n    float height1 = texture(iChannel0, uv).x * terrainHeight;\n    float height2 = texture(iChannel0, uv + vec2(1.0 / iChannelResolution[0].x, 0.0)).x * terrainHeight;\n    float height3 = texture(iChannel0, uv + vec2(0.0, 1.0 / iChannelResolution[0].y)).x * terrainHeight;\n    float height4 = texture(iChannel0, uv + vec2(-1.0 / iChannelResolution[0].x, 0.0)).x * terrainHeight;\n    float height5 = texture(iChannel0, uv + vec2(0.0, -1.0 / iChannelResolution[0].y)).x * terrainHeight;\n    \n    return normalize(vec3(height2 - height1 + height4, 1.0, height3 - height1 + height5));\n}\n    \nRayHit RayMarchTerrain(Ray ray){\n    float dist = 0.0;\n    bool hit = false;\n    RayHit rayHit;\n    while(!hit && dist < maxDist){\n        dist += 1.0;\n        hit = IsVectorInTerrain(ray.origin + ray.direction * dist);\n    }\n    rayHit.depth = dist;\n    rayHit.worldPosition = ray.origin + ray.direction * dist;\n    rayHit.hit = hit;\n    rayHit.normal = GetTerrainNormal(ray.origin + ray.direction * dist);\n    return rayHit;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Ray ray;\n    ray.origin = vec3(iChannelResolution[0].x / 2.0, 210.0, 0.0);\n    ray.direction = normalize(vec3((uv.x - 0.5) * (fov / 360.0), (uv.y - 0.5) * (fov / 360.0) - 0.1, 1.0));\n    \n    RayHit rayHit = RayMarchTerrain(ray);\n\tvec3 col;\n    vec3 sunNormal = normalize(vec3(0, 0, 0.5));\n    if(rayHit.hit){\n        col = mix(vec3(0.1, 1.0, 0.1), vec3(1.0, 0.1, 0.1), rayHit.worldPosition.y / terrainHeight) * (1.0 - clamp(rayHit.depth / maxDist, 0.1, 1.0));\n    } else{\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n    // Output to screen\n}","name":"Image","description":"","type":"image"}]}