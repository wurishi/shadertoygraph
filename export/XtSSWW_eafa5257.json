{"ver":"0.1","info":{"id":"XtSSWW","date":"1443482263","viewed":411,"name":"Bitwise stuff","username":"qwert33","description":"Implementing per-bit integer operations as they are not implemented by default.\nAnd then applying a nonlinear transformation on top of it","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["bit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nbool XOR(bool a, bool b) {\n    return (a && !b) || (b && !a);\n}\n\nbool AND(bool a, bool b) {\n    return a && b;\n}\n\nint bitwiseOperation(int x, int y) {\n    int outval = 0;\n    ivec2 xy = ivec2(x,y);\n    for (int i=0; i<30; ++i) {\n        ivec2 shift = xy / 2;\n        \n        ivec2 lowestBit = xy - shift * 2;\n        \n        //outval *= 2;  // if this is disabled, we count the bits rather than interpret the number\n        if (XOR(lowestBit.x != 0, lowestBit.y != 0)) {\n           outval += 1;\n        }\n        \n        xy = shift;\n    }\n    return outval;\n}\n\n// makes a rotation matrix\nmat2 rotate(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(\n        c, -s,\n        s,  c\n    );\n}\nconst float pi = 3.14159265359;\n\nvec2 swirl(vec2 toSwirl, vec2 center, float amonut) {\n    float rotateRadius = 1.04;\n    vec2 p = toSwirl; // out\n    p -= center;\n    p *= rotate((rotateRadius / -length(p)) * amonut);\n    p += center;\n\treturn p;\n}\n\n// makes a function looking like a staircase\nfloat stairs(float x, float stepSize) {\n    float y = (floor(x / stepSize) + 0.5);\n    y *= 2.0 * stepSize;\n    y += stepSize * y/abs(y);\n    y *= 0.5;\n    return y;\n}\n\nvec2 doubleSwirl(vec2 toSwirl, float theta) {\n    vec2 p = toSwirl; // out\n    float y = 0.5 * p.x*p.x / p.y  +  0.5 * p.y;\n    y = stairs(y, 30.0);\n    \n    // why this is necessary?\n    \n    \n    vec2 center = vec2(0.0, y);\n    p -= center;\n    //if (abs(p.y) < 2.1) return vec2(0.0);\n    p *= rotate(theta / (2.0 * pi * center.y));\n    p += center;\n    return p;\n\n}\n\nvec4 main2(in vec2 fragCoord) {\n    \n    const float timeScale = 5.0;\n    const float repeatPeriod = 10.0;\n    float time = iTime * timeScale;\n    time = mod(time, repeatPeriod * timeScale);\n    fragCoord -= iResolution.xy / 2.0;\n    vec2 p = fragCoord;\n    \n    // do some non-linear transformations\n    p = doubleSwirl(p, time*100.0);\n    /*\n    vec2 translate = vec2(0.0, -100.0);\n    p = swirl(p, translate, time * 5.0);\n    p = swirl(\n        p, \n        swirl(-translate, translate, time * 5.0),\n        time * -5.0\n    );\n    */\n    \n    /*\n\n    p -= translate;\n    p *= rotate((rotateRadius / -length(p)) * -time*10.0);\n    p += translate;\n*/\n\n    /*\n\tfragCoord *= mat2(\n        0.5 * sin(time * 0.5),\n        0.5 * sin(time * 0.78),\n        0.5 * sin(time * 0.85),\n        0.5 * sin(time * 0.7)\n    );\n\t*/\n    int x = int(p.x);\n    int y = int(p.y);\n\tvec2 uv = p.xy / iResolution.xy;\n    int bit = bitwiseOperation(x, y);\n    float val = float(bit);\n    float exposure = 0.1;//iMouse.x / 3000.0;\n    val = 1.0 - exp(-val * exposure);\n    \n    return vec4(val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = main2(fragCoord);\n    \n    if (true) {  // antialiasing\n        float AAradius = 0.5;\n        fragColor += main2(fragCoord + AAradius * vec2( 1.0,  0.0));\n        fragColor += main2(fragCoord + AAradius * vec2(-1.0,  0.0));\n        fragColor += main2(fragCoord + AAradius * vec2( 0.0,  1.0));\n        fragColor += main2(fragCoord + AAradius * vec2( 0.0, -1.0));\n        fragColor /= 5.0;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}