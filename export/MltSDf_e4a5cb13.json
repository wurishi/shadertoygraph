{"ver":"0.1","info":{"id":"MltSDf","date":"1481982691","viewed":259,"name":"Ghost Cells","username":"ptrgags","description":"This is my first time trying to randomly generate a Voronoi shader based on techniques from https://thebookofshaders.com/12/. My hash isn't random enough, but I managed to work around it.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","pulse","waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//hash a point onto a color from the texture\nvec2 hash2(vec2 point) {\n    return texture(iChannel0, point).rg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Convert to UV space\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= 0.5;\n    \n    //Fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //Tile space\n    vec2 scaled = 7.0 * uv;\n    \n    \n    //Coordinates (x, y) of the box\n    vec2 box = floor(scaled);\n    \n    //UV coordinate within current box\n    vec2 box_uv = fract(scaled);\n    \n    //Minimum distance between box_uv and a nearby feature point\n    float min_dist = 1.0;\n    \n    //Iterate over current box + surrounding 8 neighbors\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            //Coodrinates (x, y) of neighbor box\n            vec2 neighbor = vec2(float(i), float(j));\n            \n            //Find the feature point in the neighbor cell.\n            //this is a fractional coordinate like box_uv\n            vec2 feature = hash2((box + neighbor) / 100.0);\n            \n            //Animate the feature points a little bit\n            feature = 0.5 * sin(iTime + 6.0 * feature) + 0.5;\n            \n            //Get the distance between current pixel (box_uv)\n            //and the feature point (neighbor + feature)\n            float dist = distance(box_uv, neighbor + feature);\n            \n            //Update the minimum\n            min_dist = min(dist, min_dist);\n        }\n    }\n\n    vec4 spring_green = vec4(0.0, 1.0, 0.5, 1.0);\n    \n    //Pulse outwards from the center of each feature point over time\n    float pulse_val = 10.0 * min_dist;\n    float animation = -iTime;\n    //shift the frequency as we move away from the center of the screen\n    float variation = 5.0 * length(uv);\n    //This was a happy\n    float distortion = length(hash2(uv));\n    float pulse = cos(pulse_val + animation + variation + distortion);\n    \n    fragColor = pulse * spring_green;\n    \n    \n}","name":"Image","description":"","type":"image"}]}