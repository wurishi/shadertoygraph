{"ver":"0.1","info":{"id":"ddcBzj","date":"1697992102","viewed":64,"name":"rotate rotate rotate","username":"Acre","description":"I want to rotate only the box without moving the pos","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 50\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.;\nvec3 pale_aqua=vec3(0.76,0.89,0.89);\nvec3 wedgwood_blue=vec3(0.08,0.51,0.67);\nvec3 turquoise_blue=vec3(0.0,0.68,0.8);\nvec3 darkblue_green=vec3(0.0,0.435,0.482);\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nmat2 rotate2d(float angle)\n{\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\nmat3 RotateY(float a)\n{\n  return mat3(cos(a),    0.0, sin(a),\n              0.0,  1.0, 0.0,\n              -sin(a),   0.0, cos(a));\n}\nvec2 PolarMod(vec2 p, float r)\n{\n    float a =  atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rotate2d(-a);\n}\n\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\nvec2 opUnion(vec2 d1,vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\nvec2 map(vec3 p) \n{\n    p.xy=PolarMod(PolarMod(PolarMod(p.xy,8.), 4.),2.);\n    vec2 d=vec2(sdCylinder(p, 1.0,0.1), 0.0);\n    for(float i=0.0;i<12.0;i++)\n    {\n        for(float j=1.0;j<4.0;j++)\n        {\n            float angle=radians(i*360.0/6.+360./j);\n            d=opUnion(d,vec2(sdBox(p+vec3(cos(angle),-5.+i,sin(angle))*0.2*RotateY(iTime), vec3(0.05)), j));\n        }\n    }\n\treturn d;\n}\n\n\nvec3 materialize(vec3 p, float depth,vec2 mat,vec2 uv)\n{\n    vec3 col;\n    if (depth > 10.0)\n    {\n\n    }\n    else\n    {\n        if(mat.y== 0.0)\n        {        \n            col=mix(pale_aqua, wedgwood_blue,uv.y+0.7);\n        }\n        if(mat.y== 1.0)\n        {        \n            col=turquoise_blue;\n        }\n        if(mat.y== 2.0)\n        {        \n            col=darkblue_green;\n        }\n        if(mat.y== 3.0)\n        {        \n            col=pale_aqua;\n        }\n    }\n    return col;\n}\nvec3 raymarch(vec3 ro, vec3 rd,vec2 uv) \n{\n\tvec3 p;\n    vec2 d;\n\tfloat depth;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        p=ro+rd*depth;\n\t\td = map(p);\n\t\tif(d.x<0.00001)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tdepth += d.x;\n\t}\n\treturn  materialize(p,depth,d,uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy ) / min(iResolution.x,iResolution.y);\n    vec3 origin = vec3(cos(iTime)*5.0, 0.0,sin(iTime)*5.);\n    vec3 target = vec3(0.0);\n    mat3 camera = SetCamera(origin, target, 0.0);\n    vec3 rd = camera * normalize(vec3(p,3.5));\n    vec3 col=raymarch(origin , rd,p);    \n\tfragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}