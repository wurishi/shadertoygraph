{"ver":"0.1","info":{"id":"llGyzh","date":"1535022594","viewed":623,"name":"GPU hacks #01 - CUDA & OpenGL","username":"PrzemyslawZaworski","description":"Welcome. ShaderToy is a great place to learn WebGL shaders. Now it's time to extend our skills with GPU programming. Every episode will provide full source code with tiny framework in different language. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","opengl","nvidia","cuda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWritten by Przemyslaw Zaworski, MIT licence\nRequirements and tools:\n - A CUDA-capable GPU\n - A supported version of Microsoft Windows\n - A supported version of Microsoft Visual Studio (2015)\n - the NVIDIA CUDA Toolkit (available at http://developer.nvidia.com/cuda-downloads)\nSave code as uv.cu and compile from command line (toolkit installed in E:\\CUDA):\n\tnvcc -o uv.exe uv.cu -IE:\\CUDA\\Samples\\common\\inc -lopengl32 -arch=sm_30  user32.lib gdi32.lib\nYou can make your own functions, and add __device__ qualifier, for example:\n    __device__  float plane(float3 p, float3 c, float3 n)\n    {\n        return dot(p - c, n);\n    }\n*/\n\n/*\n#include <windows.h>\n#include <GL/gl.h>\n#include <helper_math.h> \n#include <cuda_runtime.h>\n#include <cuda_gl_interop.h>\n\n#define width 1920\n#define height 1080\nstatic float timer = 0.0f;\nfloat3* device;\nunsigned int buffer;\ntypedef void (APIENTRY* PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *b);\ntypedef void (APIENTRY* PFNGLBINDBUFFERPROC) (GLenum t, GLuint b);\ntypedef void (APIENTRY* PFNGLBUFFERDATAPROC) (GLenum t, ptrdiff_t s, const GLvoid *d, GLenum u);\ntypedef int (APIENTRY* PFNWGLSWAPINTERVALEXTPROC) (int i);\n\n__global__ void mainImage(float3 *output, float iTime)\n{\n\tunsigned int x = blockIdx.x*blockDim.x + threadIdx.x;\n\tunsigned int y = blockIdx.y*blockDim.y + threadIdx.y;\n\tunsigned int i = (height - y - 1)*width + x;\n\tfloat2 iResolution = make_float2((float)width, (float)height);\n\tfloat2 fragCoord = make_float2((float)x, (float)y);\n\tfloat2 uv = fragCoord / iResolution;\n\tfloat r = cos(iTime+uv.x+0), g = cos(iTime+uv.y+2), b = cos(iTime+uv.x+4);\n\tfloat3 fragColor = clamp(0.5 + 0.5 * make_float3(r,g,b),0.0,1.0);\n\tfloat colour;\n\tGLubyte bytes[] = {(GLubyte)(fragColor.x*255+0.5),(GLubyte)(fragColor.y*255+0.5),(GLubyte)(fragColor.z*255+0.5)};\n\tmemcpy(&colour, &bytes, sizeof(colour));\n\toutput[i] = make_float3(x, y, colour);\n}\n\nint main()\n{\n\tShowCursor(0);\n\tunsigned int size = width * height * sizeof(float3);\n\tcudaMalloc(&device, size);\n\tdim3 block(8, 8, 1);\n\tdim3 grid(width / block.x, height / block.y, 1);\n\tPIXELFORMATDESCRIPTOR pfd = { 0, 0, PFD_DOUBLEBUFFER };\n\tHDC hdc = GetDC(CreateWindow(\"static\", 0, WS_POPUP | WS_VISIBLE | WS_MAXIMIZE, 0, 0, 0, 0, 0, 0, 0, 0));\n\tSetPixelFormat(hdc, ChoosePixelFormat(hdc, &pfd), &pfd);\n\twglMakeCurrent(hdc, wglCreateContext(hdc));\n\tglOrtho(0.0, width, 0.0, height, -1.0, 1.0);\n\t((PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress(\"wglSwapIntervalEXT\")) (0);\n\t((PFNGLGENBUFFERSPROC)wglGetProcAddress(\"glGenBuffers\"))(1, &buffer);\n\t((PFNGLBINDBUFFERPROC)wglGetProcAddress(\"glBindBuffer\"))(0x8892, buffer);\n\t((PFNGLBUFFERDATAPROC)wglGetProcAddress(\"glBufferData\"))(0x8892, size, 0, 0x88EA);\n\tcudaGLRegisterBufferObject(buffer);\n\tglVertexPointer(2, GL_FLOAT, 12, 0);\n\tglColorPointer(3, GL_UNSIGNED_BYTE, 12, (GLvoid*)8);\n\tglEnableClientState(GL_VERTEX_ARRAY);\n\tglEnableClientState(GL_COLOR_ARRAY);\n\tfloat s = GetTickCount();\n\tdo\n\t{\n\t\ttimer = (GetTickCount()-s)*0.001f;\n\t\tcudaGLMapBufferObject((void**)&device, buffer);\n\t\tmainImage <<< grid, block >>>(device, timer); \n\t\tcudaGLUnmapBufferObject(buffer);\n\t\tglDrawArrays(GL_POINTS, 0, width * height);\n\t\twglSwapLayerBuffers(hdc, WGL_SWAP_MAIN_PLANE);\n\t} while (!GetAsyncKeyState(VK_ESCAPE));\n\tcudaFree(device);\n\treturn 0;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}