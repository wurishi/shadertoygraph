{"ver":"0.1","info":{"id":"cljyDh","date":"1691791643","viewed":106,"name":"Sky of Balloons","username":"andrew741","description":"Watch as hundreds of balloons drift in the wind, slowly floating upwards.\n\nUse the mouse to look around.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["color","parallax","sky","background","string","string","rotation","birthday","gravity","party","wind","flying","rope","ballon","celebration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BalloonCol vec3(1., 0.2, 0.2)\n#define OffsetStrength vec2(3.5, 2.)\n#define SkyCol vec3(0.8, 0.8, 0.95)\n#define CellSize vec2(9.5, 9.5)\n#define Itterations 50.\n\n// the matrix for the hash function (weights from the origonal Hash function)\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with some modifactions)\nvec3 Hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 Hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat Perlin( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( Hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n/*\nApparently this version causes a weird glitch on some peoples devices\n// from another persons shader\nfloat Perlin(vec3 x)\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = Hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = Hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = Hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = Hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = Hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = Hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = Hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = Hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}*/\n\n// squares a value (more preformant apprently then using pow(x, 2.))\nfloat Sqr(float v) {  return v*v;  }\n\n// rotates a 2d point based on an angle\nvec2 rot2D(vec2 v, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return v * mat2(ca, -sa, sa, ca);\n}\n\n// renders a balloon\nvec4 Balloon(vec2 uv, float blur, float time, float seed)\n{\n    // getting info on the cell\n    vec2 cell = floor(uv /  CellSize);\n    vec3 offset = Hash(vec3(cell, seed));\n    float rot = Perlin(vec3(cell, time+seed)) * 1.5;\n    \n    // getting the translated coords\n    vec2 nUv = mod(uv, CellSize) - CellSize*0.5 + offset.xy * OffsetStrength;\n    vec2 np = rot2D(nUv, rot);\n    vec2 sp = mix(np, nUv, smoothstep(2., 8., length(nUv)));\n    \n    // getting the distance to the balloon\n    float dst = Sqr(np.x/Sqr(cos(min(np.y*0.5, 0.)))) + Sqr(np.y*0.6666);\n    float dst2 = np.y < -0.5 ? np.y + 2.6 - max(abs(5.*np.x*pow(np.y+2.7, 8.)) - 0.8, 0.) : -99999.;\n    float dst3 = sp.y < -1. ? abs(sp.x - sin(15. * sp.y)*0.025) : 999.;\n    float ballonMin = min(dst, -dst2*4.+4.55);\n    float balloonDst = min(ballonMin, dst3*35.);\n    \n    // getting the color of the ballon\n    vec2 hp = rot2D(nUv, -0.8+rot) - vec2(0.95, 0.45);\n    float highlight = smoothstep(0.1, 0., Sqr(hp.x) + Sqr(Sqr(hp.y) + hp.x));\n    vec3 col = offset + highlight;\n    if (balloonDst == dst3*35. && ballonMin > 1.) col = vec3(1.);\n    return vec4(smoothstep(blur, -blur, balloonDst-1.), col);\n}\n\n// the main program code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 12.;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * zoom;\n    vec2 offset = smoothstep(0., 1., iMouse.xy/iResolution.xy) * vec2(40., 20.);\n    float pixelWidth = zoom / iResolution.y * 1.5;\n    \n    float blur = 0.;\n    vec3 col = SkyCol;\n    \n    // getting info on the cell\n    vec2 cell = vec2(-1000.);\n    vec2 sway = vec2(Perlin(vec3(cell, -iTime*0.3+20.)), Perlin(vec3(-cell, iTime*0.3+20.)));\n    float rot = Perlin(vec3(cell, iTime*0.3+20.)) * 1.5 + smoothstep(0., 1., iMouse.x/iResolution.x)*0.25;\n    \n    // rendering the mountains\n    float stepSize = 1./Itterations;\n    for (float i = 1.; i >= stepSize; i-=stepSize)\n    {\n        // getting different itteration numbers\n        float itteration = i*Itterations;\n        float invI = 1. - i;\n        \n        // getting the height of the mountain\n        vec2 pos = rot2D(uv, rot*0.5) + (sway + offset)*invI - vec2(iTime*0.5, iTime) + itteration * CellSize * 0.5;\n        vec4 balloon = Balloon(pos*(i+1.), blur+pixelWidth, iTime*0.3, itteration);\n        col = mix(col, mix(SkyCol, balloon.yzw*0.5+0.5, invI*0.25+0.75), balloon.x);\n    }\n    \n    // getting the translated coords for the main balloon\n    vec2 np = uv*0.75;\n    vec2 sp = mix(np, rot2D(np, rot*0.5), smoothstep(2., 8., length(uv)));\n    \n    // getting the distance to the main balloon\n    float dst = Sqr(np.x/Sqr(cos(min(np.y*0.5, 0.)))) + Sqr(np.y*0.6666);\n    float dst2 = np.y < -0.5 ? np.y + 2.6 - max(abs(5.*np.x*pow(np.y+2.7, 8.)) - 0.8, 0.) : -99999.;\n    float dst3 = sp.y < -1. ? abs(sp.x - sin(15. * sp.y)*0.025) : 999.;\n    float ballonMin = min(dst, -dst2*4.+4.55);\n    float balloonDst = min(ballonMin, dst3*35.);\n    float balloon = smoothstep(pixelWidth, -pixelWidth, balloonDst-1.);\n    \n    // getting the main balloons color\n    vec2 hp = rot2D(np, -0.8) - vec2(0.95, 0.45);\n    float highlight = smoothstep(0.1, 0., Sqr(hp.x) + Sqr(Sqr(hp.y) + hp.x));\n    vec3 ballonCol = vec3(1., 0.2, 0.2) + highlight*0.8;\n    if (balloonDst == dst3*35. && ballonMin > 1.) ballonCol = vec3(1.);\n    \n    // rendering the main balloon\n    col = mix(col, ballonCol, balloon);\n    \n    // the final color\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}