{"ver":"0.1","info":{"id":"Wt3BWr","date":"1612476845","viewed":234,"name":"Basic raymarch lava lamp","username":"tupto","description":"The result of my first day learning how to create raymarching shaders","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The result of my first day learning how to create raymarching shaders\n//Massive shoutout to Inigo Quiles and Jamie Wong for their tutorials\n\nconst int MAX_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst int NUM_BUBBLES = 20;\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sunion(float obj1, float obj2, float k) { return smin(obj1, obj2, k); }\n\nfloat sdfSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat hash(float x)\n{\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\nvec2 hash2(in vec2 p)\n{\n\treturn fract(1965.5786 * vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat map(vec3 p)\n{\n\tfloat final = MAX_DIST;\n\tfor (int i = 0; i < NUM_BUBBLES; i++)\n\t{\n\t\tvec3 pos = p;\n\t\tpos.xy += (hash2(vec2(float(i)))) * 2.0 - 1.0;\n\t\tpos.y += sin(iTime * hash(float(i)) + hash(float(i)));\n\t\tfloat r = hash(float(i) * 0.6) * 0.6;\n\t\tfloat bubble = sdfSphere(pos, r);\n\t\t\n\t\tfinal = sunion(final, bubble, 0.2);\n\t}\n\t\n\treturn final;\n}\n\nvec3 rayDirection(float fov, vec2 res, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - res / 2.0;\n\tfloat z = res.y / tan(radians(fov) / 2.0);\n\t\n\treturn normalize(vec3(xy, -z));\n}\n\nfloat rayMarch(vec3 cam, vec3 dir, float start, float end)\n{\n\tfloat depth = start;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tfloat dist = map(cam + depth * dir);\n\t\tif (dist < EPSILON)\n\t\t{\n\t\t\treturn depth;\n\t\t}\n\t\t\n\t\tdepth += dist;\n\t\tif (depth >= end)\n\t\t{\n\t\t\treturn end;\n\t\t}\n\t}\n\t\n\treturn end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 gouraud(vec3 pos, vec3 normal, vec3 lightPos, vec3 lightCol, vec3 cam)\n{\n\tvec3 camVec = normalize(pos - cam);\n\tvec3 reflection = reflect(camVec, normal);\n\t\n\tfloat dist = length(lightPos - pos);\n\tvec3 toLight = normalize(lightPos - pos);\n\t\n\tfloat diffuse = clamp(max(dot(normal, toLight), 0.0), 0.0, 1.0);\n\treturn diffuse * lightCol;\n}\n\nvoid fragment()\n{\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n\t\n\tvec3 cam = vec3(0.0, 0.0, 5.0);\n\tfloat dist = rayMarch(cam, dir, MIN_DIST, MAX_DIST);\n\t\n\tvec3 lightpos = vec3(0.0, 0.0, 10.0);\n\t//vec3 lightpos = vec3(5.0 * cos(TIME * 0.25), 5.0 * sin(TIME * 0.5), sin(TIME) * 2.0);\n\t\n\tif (dist > MAX_DIST - EPSILON)\n\t{\n\t\t//MISS\n\t\tfragColor = vec4(vec3(0.0), 1.0);\n\t}\n\telse\n\t{\n\t\t//HIT\n\t\tvec3 pos = cam + dir * dist;\n\t\tfragColor.xyz = gouraud(pos, estimateNormal(pos), lightpos, vec3(1.0, 0.0, 0.0), cam);\n\t}\n}","name":"Image","description":"","type":"image"}]}