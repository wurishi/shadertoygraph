{"ver":"0.1","info":{"id":"lfVSDh","date":"1715128869","viewed":25,"name":"AK FYP22: Alien Orb","username":"AKHC","description":"A scene with a glowing orb created with raymarching and a spherical cut-out of a gyroid.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n#define TAU 6.283185\n\n#define SHELLTHICK 0.03\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat ballGyroid(vec3 p, float scale)\n{\n    p.yz *= Rot(T / 2.);\n\n\n    p *= scale;\n    float gyr = abs(0.7 * dot(sin(p), cos(p.yzx)) / scale) - 0.02;\n    return gyr;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix (b, a, h) - k*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n  k = -k;\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix (b, a, h) - k*h*(1.-h);\n}\n\nvec3 twistPoint(vec3 p)\n{\n    float k = sin(iTime); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nfloat dispPrim(float primitive, vec3 p, float freq)\n{\n    float f = freq;\n    float s = 1.;\n    return (primitive + sin(p.x*f)*sin(p.y * f)*sin(p.z * f) * s)/2.;\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 234.53));\n    p += dot(p, p+23.4);\n    return fract(p.x*p.y);\n}\nfloat Glitter(vec2 p, float a) //a = phase of the sparkle\n{\n    p *= 10.;\n    vec2 id = floor(p);\n    p = fract(p) - 0.5;    \n    float n = Hash21(id);\n    float disc = length(p);\n    float m = S(.3 * n,.0,disc);\n    \n    m *= pow((sin(a + fract(n*10.) * TAU) * 0.5) + .5, 100.);\n    return m;\n}\n\n\n#define GROUNDMOVE -T*3.\n\nfloat GetDist(vec3 p) {\n    float sphere = sdSphere(p, 1.);\n    sphere = abs(sphere) - SHELLTHICK;\n    float gyr = ballGyroid(p, 10.);\n    \n    sphere = smax(sphere, gyr, abs(sin(iTime)*0.025) + 0.025);\n    \n    float ground = p.y + 1.;\n    vec3 q = p*5.;\n    q.y += sin(.7) * 1.4;  \n    q.z -= T * 2.;\n    float y = abs(dot(sin(q), cos(q.yzx))) * .1;\n    ground += y;\n\n    float onion = min(sphere, ground);\n    \n\n    return onion;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nvec3 RayPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float t = max(0., dot(p-ro, n) / dot(rd, n)); //distance from plane\n    return ro + rd * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float centerDist = dot(uv, uv); // center distance squared\n\n    vec3 ro = vec3(0, 3, -1);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.y = max(-0.9,ro.y);\n    ro.xz *= Rot(-m.x*TAU + T*0.2);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n\n    //material rendering\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        vec3 lightDir = normalize(-p);\n\n        float dif = dot(n, lightDir)*.5+.5;\n        float cd = length(p); //distance from origin\n        col = vec3(dif);\n        \n        if(cd > 1. + SHELLTHICK + 0.005) //if distance is larger than radius of ball\n        {\n            //col *= vec3(0,1,0);\n            float s = ballGyroid(twistPoint(-lightDir), 10.);\n            float soft = 0.01 * cd;\n            float shadow = smoothstep(-soft, soft, s);\n            col *= shadow * .9 + .1;\n            p.z -= T / 2.;\n            float glitterPhase = dot(ro, vec3(2)) -T*3.; //ro.x + ro.y + ro.z\n            col += Glitter(p.xz * 3., glitterPhase) * 3. * shadow;\n            col /= cd*cd;\n        }\n        else //didn't hit floor\n        {\n            float sss = .05/centerDist;\n            sss*=sss;\n            \n            float s = ballGyroid((p+sin(p*10. + T)) * 0.6, 10.);\n            \n            sss *= S(-0.03, 0., s);\n            \n            //sss = min(sss, 2.);\n            col += sss * vec3(.3,.4,.1);\n        }\n    }\n    \n    //2d lght\n    //center light\n    \n    float light = .003 / centerDist * (sin(T * 5.) + 2.) / 2.;\n    col += light * S(.0, .5, d - 3.);\n    \n    //center glare\n    float s = ballGyroid(normalize(ro), 10.);\n    col += light * S(0., .04, s) * vec3(0.2, 0.3, 1.);\n    float glow = 0.003 / centerDist * (sin(T * 5.) + 2.) / 2.;;\n    col.r += S(0., 0.6,glow * S(.5, .0, d - 3.));\n    \n    \n    //volumetrics\n    \n    //old god rays\n    float a = atan(uv.x, uv.y); //-pi to pi, loops correctly in a trig function\n    float sb = sin(a * 11. - T) * cos(a*7.+T) * sin(a*5.+T*.2); //prime numbers don't easly fall on top of each other\n    sb *= S(0.0, 0.4, centerDist);\n\n    \n    vec3 pp = RayPlane(ro, rd, vec3(0), normalize(ro));\n    float sbb = ballGyroid(normalize(pp), 10.);\n\n    col += max(0., sb); //mask center\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    //vignette\n    col *= 1. - centerDist * 1.2;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}