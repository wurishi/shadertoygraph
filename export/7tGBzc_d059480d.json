{"ver":"0.1","info":{"id":"7tGBzc","date":"1664930611","viewed":71,"name":"Raymarching 2D (L1 Metric)","username":"Envy24","description":"Try switch lines 47, 48.\nControl ray direction with mouse.\n\nFor 3d: https://www.youtube.com/watch?v=PGtv-dBi2wE&t","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","norm","metric","l1"],"hasliked":0,"parentid":"slyBRc","parentname":"Raymarching 2D (L2 Metric)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n//#define TO_CENTERED_NDC(SC)       ( ((SC)-.5*R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define UNIT                      (  3. / R.y )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat find_closest_scene_object(vec2 marching_point)\n{   \n    float min_dist = 99.;\n\n    min_dist = min(min_dist, rhombusSDF_L1(marching_point, rotateAroundZ(vec2(0.8, 0.4), iTime*0.4), 8.*UNIT));\n    min_dist = min(min_dist, rhombusSDF_L1(marching_point, rotateAroundZ(vec2(0., -0.3), iTime), 16.*UNIT));\n    \n    min_dist = min(min_dist, segmentSDF_L1(marching_point, vec2(1.5, -0.7), vec2(1.0, 0.7), 3.*UNIT));\n\n    return min_dist;\n}\n\nfloat ray_march(\n    in vec2 ray_origin,\n    in vec2 ray_direction,\n    in float max_num_steps,\n    in float max_distance,\n    in float hit_distance,\n    /* Only for visualization */\n    in vec2 NDC,\n    inout vec3 color)\n{\n    float marched_distance = 0.;    \n    bool quit = false;\n\n    for (float s = 0.; (s < max_num_steps) && (!quit); s += 1.)\n    {\n        vec2 marching_point = ray_origin + marched_distance * ray_direction;      \n        float distance_to_closest_object = find_closest_scene_object(marching_point);\n             \n        /*Visualization.*/      \n        vec2 hit_point = ray_origin + marched_distance * ray_direction;\n        color.rg -= SMAA(outlineSDF_L1(NDC, hit_point, distance_to_closest_object)) * 0.4;\n        color.gb -= SMAA(rhombusSDF_L1(NDC, hit_point, 2.*UNIT));\n        /**/\n\n        // March (update).\n        marched_distance += 0.7*distance_to_closest_object;\n        //marched_distance += distance_to_closest_object;\n        /* Without multiplier 0.7 point can overstep object. Point can't make full step,\n           because local hit point (red) can occur out of rhombus bounds.\n           0.7*distance_to_closest_object is approximate radius of inner circle (in rhombus). */\n        \n        quit = \n            (marched_distance > max_distance) ||         // Marched to far?\n            (distance_to_closest_object < hit_distance); // Hit something?    \n    }\n\n    return marched_distance;\n}\n\nvec2 approximate_normal(\n    in vec2 hit_point,\n    /* Only for visualization */\n    in vec2 NDC,\n    inout vec3 color)\n{\n    float minimal_distance = find_closest_scene_object(hit_point);\n    \n    vec2 normal = minimal_distance - vec2(\n        find_closest_scene_object(hit_point - vec2(0.01, 0.0)),\n        find_closest_scene_object(hit_point - vec2(0.0, 0.01))\n        );\n        \n    /* Visualize offseted points */\n    color = mix(color, vec3(.8, .5, .1), SMAA(segmentSDF_L1(NDC, hit_point, hit_point - vec2(0.08, 0.0), 0.)) );\n    color = mix(color, vec3(.8, .5, .1), SMAA(segmentSDF_L1(NDC, hit_point, hit_point - vec2(0.0, 0.08), 0.)) );\n    color = mix(color, vec3(.4, .5, .1), SMAA(rhombusSDF_L1(NDC, hit_point - vec2(0.08, 0.0), UNIT)) );\n    color = mix(color, vec3(.4, .5, .1), SMAA(rhombusSDF_L1(NDC, hit_point - vec2(0.0, 0.08), UNIT)) );\n    /**/\n        \n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n    vec3 color = vec3(1.);\n    \n    /* Visualize scene */\n    color = mix( color, vec3(.1, .5, .8), SMAA(find_closest_scene_object(NDC)) );\n    \n    /* Define camera*/\n    vec2 ray_origin = vec2(-AR, 0.), \n         mouse =\n             LMB_IS_HOLD == true ?\n                 TO_CENTERED_NDC(iMouse.xy) :\n                 vec2(AR, sinOSC(-1., 1., iTime*.5)),\n         ray_direction = normalize(mouse - ray_origin);\n    \n    \n    /* Vizuialize ray. */\n    vec2 ray_end = ray_origin + 10. * ray_direction;\n    color -= SMAA(segmentSDF_L1(NDC, ray_origin, ray_end, 0.));\n    \n    /* Raymarch. */\n    float marched_distance = ray_march(ray_origin, ray_direction, 12., 1000., 0.01, NDC, color);\n    \n    /* Vizualize hit point */\n    vec2 hit_point = ray_origin + marched_distance * ray_direction;\n    color = mix(color, vec3(1,0,1), SMAA(rhombusSDF_L1(NDC, hit_point, 3.*UNIT)));\n    \n    /* Vizuialize normal. */\n    vec2 normal = approximate_normal(hit_point, NDC, color);       \n    vec2 end = hit_point + 0.2*normal;\n    color.rb -= SMAA(segmentSDF_L1(NDC, hit_point, end, .8*UNIT));\n    /**/\n\n    O = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat rhombusSDF_L1(vec2 NDC, vec2 C, float R)\n{\n    return L1(C, NDC)-R;\n}\n\nfloat outlineSDF_L1(vec2 NDC, vec2 C, float R)\n{\n    return abs(L1(C, NDC)-R);\n}\n\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x) / (E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC))) - R;\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}