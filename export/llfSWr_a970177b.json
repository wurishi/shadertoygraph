{"ver":"0.1","info":{"id":"llfSWr","date":"1435774587","viewed":190,"name":"Spirals (kind of)","username":"ducsuus","description":"An implementation of the Archimedean Spiral.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","spirals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926535897932384626433832795\n\n// Uses the equation from the Archimedean Spiral (https://en.wikipedia.org/wiki/Archimedean_spiral)\nfloat r_spiral(vec2 fragCoord){\n    \n    vec2 center = vec2(-10,0);\n   \n    vec2 dist = fragCoord - center;\n\n    float a = 1.0;\n    float b = 50.0;\n    \n    float theta = atan(dist.x / dist.y);\n    \n    return a + (b * theta);\n}\n\n// a changes the rotation of the spiral, whereas b changes the distance between two lines of the spiral (the radius inbetween two spirals on any plane)\nbool isSpiral(vec2 fragCoord, vec2 center, float a, float b){\n    \n    // Make sure that the coords we are using are relative to the center of the spiral specified\n    vec2 relative_fragCoord = fragCoord - center;\n    \n    // Work out the radius of the spiral the current fragment (pixel) lays on, using the Archimedean Spiral equation, and trigonomtery to work out theta\n    float radius = a + (b * (atan(relative_fragCoord.y, relative_fragCoord.x)));\n    \n    // Work out the radius of the circle the current fragment (pixel) lays on the circumference of.\n    float circle_radius = length(relative_fragCoord); // Length is a less-intensive way of performing sqrt(x^2 + y^2)\n    \n    // If the radius of the spiral the current fragment is on and the radius of the circle the fragment is currently on are within 2.0 of each other\n   \t// The absolute value of the difference between the two is compared; absolute means it will always be positive\n    if(abs(radius - circle_radius) < 2.0)\n        return true;\n    \n    return false;    \n}\n\n// a changes the rotation of the spiral, whereas b changes the distance between two lines of the spiral (the radius inbetween two spirals on any plane)\nbool _isSpiral(vec2 fragCoord, vec2 center, float a, float b, float offset){\n    \n    // Make sure that the coords we are using are relative to the center of the spiral specified\n    vec2 relative_fragCoord = fragCoord - center;\n    \n    // Work out the radius of the spiral the current fragment (pixel) lays on, using the Archimedean Spiral equation, and trigonomtery to work out theta\n    float radius = a + (b * (offset + atan(relative_fragCoord.y, relative_fragCoord.x)));\n    \n    // Work out the radius of the circle the current fragment (pixel) lays on the circumference of.\n    float circle_radius = length(relative_fragCoord); // Length is a less-intensive way of performing sqrt(x^2 + y^2)\n    \n    // If the radius of the spiral the current fragment is on and the radius of the circle the fragment is currently on are within 2.0 of each other\n   \t// The absolute value of the difference between the two is compared; absolute means it will always be positive\n    if(abs(radius - circle_radius) < 2.0)\n        return true;\n    \n    return false;    \n}\n\n\n\nfloat theta(vec2 fragCoord){\n\n    float theta = atan(abs(fragCoord.y) / abs(fragCoord.x));\n\n    float offset = 0.0;\n\n    if (fragCoord.x > 0.0){\n    \tif (fragCoord.y < 0.0){\n    \t\toffset += 270.0;\n    \t}\n    }\n    else {\n    \tif (fragCoord.y > 0.0){\n    \t\toffset += 90.0;\n    \t}\n    \telse {\n    \t\toffset += 180.0;\n    \t}\n    }\n    \n\n    return theta + offset;\n}\n\nfloat crazyTheta(vec2 fragCoord){\n\n    float theta = atan(abs(fragCoord.y) / abs(fragCoord.x));\n\n    float offset = 0.0;\n\n    \n    if (fragCoord.x > 0.0){\n    \tif (fragCoord.y < 0.0){\n    \t\toffset += (M_PI/2.0) * 3.0 ;\n    \t}\n    }\n    else {\n    \tif (fragCoord.y > 0.0){\n    \t\toffset += (M_PI/2.0);\n    \t}\n    \telse {\n    \t\toffset += (M_PI/2.0) * 2.0;\n    \t}\n    }\n    \n\n    return theta + offset;\n}\n\nbool isSpiralTesting(vec2 fragCoord, vec2 center, float a, float b){\n    \n    // Make sure that the coords we are using are relative to the center of the spiral specified\n    vec2 relative_fragCoord = fragCoord - center; \t   \n    \n    // Use a different method of \"rearranging\" the Archimedean Spiral equation\n    float r = length(relative_fragCoord) / (b * atan(relative_fragCoord.y, relative_fragCoord.x));\n    \n    // If r is within a decent range of a\n    if (abs(r - a) < 1.0)\n        return true;\n     \n    return false;\n}\n\nbool crazyIsSpiralTesting(vec2 fragCoord, vec2 center, float a, float b){\n    \n    // Make sure that the coords we are using are relative to the center of the spiral specified\n    vec2 relative_fragCoord = fragCoord - center; \t   \n    \n    // Use a different method of \"rearranging\" the Archimedean Spiral equation\n    float r = length(relative_fragCoord) / (b * theta(relative_fragCoord));\n    //float r = length(relative_fragCoord) / (b * crazyTheta(relative_fragCoord));\n    \n    // If r is within a decent range of a\n    if (abs(r - a) < 1.0)\n        return true;\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Default to a black color\n    fragColor = vec4(0.0);\n    \n    for(float i = 0.0; i < 5.0; i++){\n        if(_isSpiral(fragCoord, vec2(iResolution.x / 4.0, iResolution.y - (iResolution.y / 4.0)), 70.0, 10.0, i * M_PI * 2.0))\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    \n    /* The spiral functions's second argument tends to be the center of the spiral, a resolution calculation\n\t   is used to make sure that the spiral is always in the position relative to the screen size intended */\n    \n    // The red spiral; in the top left\n    if(isSpiral(fragCoord, vec2(iResolution.x / 4.0, iResolution.y - (iResolution.y / 4.0)), 70.0, 10.0))\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    // The yellow spiral\n    else if(isSpiralTesting(fragCoord, vec2(iResolution.x - (iResolution.x / 4.0), iResolution.y - (iResolution.y / 4.0)), 15.0, 4.0))\n        fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n        \n    // Bottom left\n    else if(crazyIsSpiralTesting(fragCoord, vec2(iResolution.x - (3.0 * (iResolution.x / 4.0)), iResolution.y - (3.0 * (iResolution.y / 4.0))), 15.0, 4.0))\n        fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n        \n    /* Let's draw a divider to make things look pretty */\n    else if(abs(fragCoord.x - (iResolution.x / 2.0)) < 2.0)\n        fragColor = vec4(1.0, 0.5, 1.0, 1.0);\n    else if(abs(fragCoord.y - (iResolution.y / 2.0)) < 2.0)\n        fragColor = vec4(1.0, 0.5, 1.0, 1.0);\n    \n}","name":"","description":"","type":"image"}]}