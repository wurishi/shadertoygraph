{"ver":"0.1","info":{"id":"dtVyRW","date":"1700000324","viewed":141,"name":"Batom","username":"Elsio","description":"Que feio! trocando dois par√¢metros e mostrando como um shader novo... ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","pistons"],"hasliked":0,"parentid":"mlccWn","parentname":"Formas"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define spring(x) (smoothstep(-.4, .4, x) + smoothstep(-.3, .3, x) - smoothstep(-.7, .7, x))\n#define raymarch(a) 1., i; while(i++ < 140. && d * d > 1e-6 ) d = map(p), p += d * D\n#define norm(p) normalize(vec3(map(p + e), map(p + e.yxy), map(p + e.yyx)) - map(p))\n#define cor(a) (cos(a * 6.3 + vec3(0, 23., 21.) * a) * .5 + .5)\n#define smpl(p, dir, dist) smoothstep(-dist, dist, map(p + dir * dist))\n#define t (iTime + 25.)\n\nfloat hash(float a, float b) {\n\tvec3 p3  = fract(vec3(a,b,a) * .1031);\n    p3 += dot(p3, p3.yzx + 7.);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 face(vec3 p) {\n    vec3 s = sign(p);\n         p = abs(p);\n    float m = max(p.x, max(p.y, p.z));\n    if(m == p.x) s.yz *= 0.;\n    if(m == p.y) s.xz *= 0.;\n    if(m == p.z) s.xy *= 0.;\n    return s;\n}\n\n\nvec3 id;\nfloat gnd;\n\n// https://www.shadertoy.com/view/dlccRH\n// https://www.shadertoy.com/view/DttcDH\n\nfloat map(vec3 p) {\n    float s, cur, adj, pz = p.z;\n    vec3 m, a, b, k;\n    \n    p.z = \n      dot(\n          cos(p.xy * 5.) * 2.5, \n          sin(p.xy * 2.)\n      ) * .1;\n    \n    id = floor(p) + .5;\n    m = sign(mod(p, 2.) - 1.);\n    if(m.x * m.y * m.z < 0.) \n            id += face(p - id);\n    p -= id;\n    \n    b = 1. - abs(face(p));\n    a = sign(p) * b.zxy; \n    b = sign(p) * b.yzx;\n    k = length(p - a) < length(p - b) ? a : b;\n    \n    \n    float z = spring(\n                sin(hash(id.x, id.y) * t * 2.)) * 2. - .5;\n    \n    adj = length(\n                 max(\n                    vec2(length(p - k) - .6, pz - 1.7),\n                    .0));\n                    \n    cur = length(\n                 max(\n                    vec2(length(p) - .6, pz - z),\n                    0.));\n    \n\n    adj = min(adj, length(\n                     max(vec2(length(p) - .5, pz - 1.7), 0.)\n                   )\n                );\n    \n    cur = min(cur, length(\n                     max(vec2(length(p) - .5, pz - z), 0.)\n                   )\n                );\n    \n    \n    \n              \n    gnd = length(\n                 max(\n                    vec2(-length(p) + .68, pz),\n                    .0)) - .04;\n    \n    return min(gnd, min(cur, adj) - .02);\n}\n\n\n\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    vec2 R = iResolution.xy;\n    u = (u - R / 2.) / R.y;\n    \n    //camera\n    vec3 D = normalize(vec3(1.5, u)), \n         p = vec3(-7, 0, 0); \n         \n    float yrot = sin(t * .1) * .3 + .7, \n          zrot = t * .05 +  sin(t * 1.2) * .05;\n    \n    D.xz *= rot(yrot);\n    D.yx *= rot(zrot);\n    p.xz *= rot(yrot);\n    p.yx *= rot(zrot);\n    p += vec3(t * vec2(.5, 2), cos(t)) * .5;\n    \n    float d = raymarch();\n    \n    // material\n    float ao, spec,\n          s = hash(id.y, id.x);\n          \n    vec3 mcol = d == gnd ? vec3(.3) : cor(s),\n         e = vec3(.01, 0, 0),           \n         n = norm(p), \n         r = reflect(D, n),\n         col;\n\n    ao = smpl(p, n, .01)\n            * sqrt(\n                  smpl(p, r, .9) \n                * smpl(p, r, .4) \n                * smpl(p, r, .5));\n    \n    spec = length(sin(r * 3.) * .4 + .5) / 1.6;\n            \n    o.rgb = sqrt((mcol * spec + pow(spec, 6.)) * ao);\n}","name":"Image","description":"","type":"image"}]}