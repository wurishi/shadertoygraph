{"ver":"0.1","info":{"id":"43jXRy","date":"1725162608","viewed":18,"name":"rainbow flows 64685516586565145","username":"HaleyHalcyon","description":"e","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"l3BSDD","parentname":"Fork lch 595433 haleyhalcy 428"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHERED 0\n\nconst float TURN = 2. * acos(-1.);\n\n// overexposure filter\n/*vec3 overexpose(vec3 rgb) {\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}*/\n\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n\n#if DITHERED\nfloat dither(float z, float steps, float thres) {\n    return floor(z * steps) + step(thres, fract(z * steps));\n}\n#endif\n\nvec3 cmap(float h, float l, float thres) {\nconst vec3[] CMAP = vec3[](\n    vec3(149, 0, 54) / 255.,\n    vec3(126, 0, 0) / 255.,\n    vec3(67, 61, 0) / 255.,\n    vec3(0, 76, 0) / 255.,\n    vec3(0, 79, 68) / 255.,\n    vec3(0, 78, 148) / 255.,\n    vec3(0, 62, 177) / 255.,\n    vec3(109, 0, 135) / 255.,\n    vec3(210, 0, 100) / 255.,\n    vec3(185, 64, 0) / 255.,\n    vec3(115, 109, 0) / 255.,\n    vec3(0, 127, 0) / 255.,\n    vec3(0, 133, 115) / 255.,\n    vec3(0, 129, 203) / 255.,\n    vec3(0, 108, 234) / 255.,\n    vec3(165, 58, 189) / 255.,\n    vec3(255, 83, 150) / 255.,\n    vec3(248, 118, 54) / 255.,\n    vec3(171, 160, 0) / 255.,\n    vec3(26, 182, 61) / 255.,\n    vec3(0, 189, 167) / 255.,\n    vec3(0, 183, 255) / 255.,\n    vec3(55, 159, 255) / 255.,\n    vec3(223, 114, 246) / 255.,\n    vec3(255, 144, 204) / 255.,\n    vec3(255, 173, 105) / 255.,\n    vec3(230, 214, 53) / 255.,\n    vec3(103, 239, 114) / 255.,\n    vec3(0, 247, 222) / 255.,\n    vec3(0, 240, 255) / 255.,\n    vec3(134, 213, 255) / 255.,\n    vec3(255, 169, 255) / 255.\n);\n\n#if DITHERED\n    h = dither(h, 8., thres);\n    l = dither(.5 * cos(l * TURN) + .5, 3., thres);\n    return CMAP[int(h) % 8 + int(l) * 8];\n#else\n    h = h * 8.;\n    l = 3. * (.5 * cos(l * TURN) + .5);\n    return mix(\n        mix(\n            CMAP[int(h) % 8 + int(l) * 8],\n            CMAP[int(h + 1.0) % 8 + int(l) * 8],\n            fract(h)\n        ), mix(\n            CMAP[int(h) % 8 + int(l + 1.0) * 8],\n            CMAP[int(h + 1.0) % 8 + int(l + 1.0) * 8],\n            fract(h)\n        ), fract(l)\n    );\n#endif\n}\n\nfloat stepped(float v, float steps) {\n    return round(v * steps) / steps;\n}\n\nfloat timeStep(float t) {\n    const float w = 0.1;\n    t = 1. - abs(1. - fract(t) * 2.);\n    return mix(\n        step(0.5, t),\n        1.5 * (t - 0.5) + 0.5,\n        smoothstep(0.25 - w, 0.25 + w, t)\n        - smoothstep(0.75 - w, 0.75 + w, t)\n    );\n}\n\nfloat component(float x, float y, float t) {\n    float yStep = stepped(y, 7.);\n    float tStep = t + yStep;\n    return fract(\n        //8. * (x + y)\n        10. * x\n        + 4. * timeStep(tStep)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 4.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float thres = crosshatch(fragCoord);\n    const float scale = 0.4;\n    float comp0 = component(scale * uv.x, scale * uv.y, t);\n    float comp1 = component(scale * uv.y, scale *-uv.x, t + 0.25);\n\n    //vec3 col = cmap(comp0, comp1, thres);\n    vec3 col = cmap(comp0, comp1,\n#if DITHERED\n        crosshatch(fragCoord)\n#else\n        0.5\n#endif\n    );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}