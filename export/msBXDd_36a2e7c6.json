{"ver":"0.1","info":{"id":"msBXDd","date":"1671086773","viewed":472,"name":"Little Man Computer Simulator","username":"oneshade","description":"See comment in the Image tab.","likes":19,"published":3,"flags":32,"usePreview":1,"tags":["computer","simulator","assembly","interpreter","programming","lmc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a simulation of a \"little man computer\", an educational model of a computer.\nI recommend reading the details on wikipedia (https://en.wikipedia.org/wiki/Little_man_computer).\nYou can slow down the simulation by increasing INSTRUCTION_DELAY in the\nCommon tab.\n\nInstructions for this implementation:\n+-----------+---------+-------------------------------------------------------------+\n| Assembled | Syntax  | Operation                                                   |\n+-----------+---------+-------------------------------------------------------------+\n| 000       | HLT     | \"halt\", stop the program                                    |\n+-----------+---------+-------------------------------------------------------------+\n| 1xx       | ADD xx  | add the value at RAM address x to the accumulator           |\n+-----------+---------+-------------------------------------------------------------+\n| 2xx       | SUB xx  | subtract the value at RAM address x from the accumulator    |\n+-----------+---------+-------------------------------------------------------------+\n| 3xx       | STA xx  | store the accumulator's value in RAM at address x           |\n+-----------+---------+-------------------------------------------------------------+\n| 4xx       | LDA xx  | load the value at RAM address x into the accumulator        |\n+-----------+---------+-------------------------------------------------------------+\n| 5xx       | BRA xx  | \"branch\", jump to RAM address x and start executing the     |\n|           |         | program from there on                                       |\n+-----------+---------+-------------------------------------------------------------+\n| 6xx       | BRZ xx  | same as BRA, but only if the accumulator equals 0           |\n+-----------+---------+-------------------------------------------------------------+\n| 7xx       | BRP xx  | same as BRA, but only if the accumulator is positive (>= 0) |\n+-----------+---------+-------------------------------------------------------------+\n| 8xx       | INP     | load the value in the inbox into the accumulator            |\n+-----------+---------+-------------------------------------------------------------+\n| 9xx       | OUT     | store the accumulator's value in the outbox                 |\n+-----------+---------+-------------------------------------------------------------+\n| xxx       | DAT xxx | store x at this instruction's address in RAM (should be     |\n|           |         | at the end of your program and is only executed by the      |\n|           |         | assembler)                                                  |\n+-----------+---------+-------------------------------------------------------------+\n\nNote that the program reads from and writes to RAM but is also stored in RAM\nitself and as a result, can modify itself. Believe it or not, this is a pretty\nuseful feature.\n\nChallenges:\n - Count from 0 to 10\n - Compute the fibonacci sequence\n - Compute prime numbers (I suggest brute force first, its easier and also\n   probably more efficient for the amount of RAM you have available)\n - Write a \"functional\" program (emulate functions with branching)\n   Hint: your program will have to modify itself\n - Implement a recursive algorithm, this is not well charted territory for me\n   but I am certain that indefinite (THEORETICALLY indefinite, you do have\n   limited RAM) recursion can be implemented\n*/\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid drawInt(inout vec3 color, in vec3 fontColor, in vec2 uv, in vec2 pos, in vec2 digitSize, in int num, in int precis) {\n    float digitWidth = 0.5 * digitSize.x;\n    if (num < 0) drawChar(color, fontColor, uv, pos, digitSize, 45);\n    pos.x += digitWidth * float(precis);\n    num = abs(num);\n    for (int i=0; i < precis; i++) {\n        int digit = num % 10;\n        drawChar(color, fontColor, uv, pos, digitSize, 48 + digit);\n        num = (num - digit) / 10;\n        pos.x -= digitWidth;\n    }\n}\n\nconst int MAX_STR = 7;\nvoid drawString(in int[MAX_STR] str, in int len, inout vec3 color, in vec3 fontColor, in vec2 uv, in vec2 pos, in vec2 size, in float space) {\n    for (int i=0; i < len; i++) {\n        drawChar(color, fontColor, uv, pos, size, str[i]);\n        pos.x += space;\n    }\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Load registers\n    ivec4 registers = ivec4(texelFetch(iChannel0, ivec2(100, 0), 0));\n    int counter = registers.x;\n    int accum = registers.y;\n    int inbox = registers.z;\n    int outbox = registers.w;\n\n    // Display RAM\n    vec2 padding = vec2(0.015 * aspect, 0.05);\n    vec2 cellSize = vec2(0.084375 * aspect, 0.1);\n    vec2 halfCellSize = cellSize / 2.0;\n\n    // Grid\n    vec2 cellUv = uv + halfCellSize;\n    vec2 cellId = clamp(floor(cellUv / cellSize), 0.0, 10.0);\n    cellUv -= cellId * cellSize + halfCellSize;\n    drawSDF(abs(cellUv.x), vec3(1.0));\n    if (uv.x < 10.0 * cellSize.x) drawSDF(abs(cellUv.y), vec3(1.0));\n\n    // Draw memory cells\n    cellId = floor(uv / cellSize);\n    if (cellId.x >= 0.0 && cellId.x < 10.0 && cellId.y >= 0.0 && cellId.y < 10.0) {\n        // Load mailbox\n        int mailAddr = 10 * (9 - int(cellId.y)) + int(cellId.x);\n        int mailbox = int(texelFetch(iChannel0, ivec2(mailAddr, 0), 0).x);\n\n        // Display RAM address\n        vec2 drawPos = cellId * cellSize + padding;\n        drawPos.y += 0.02;\n        drawInt(color, vec3(1.0), uv, drawPos, vec2(0.05), mailAddr, 2);\n\n        // Display value\n        drawPos.y -= 0.04;\n        drawInt(color, vec3(0.0, 1.0, 0.0), uv, drawPos, vec2(0.05), mailbox, 3);\n        if (mailAddr == counter) color.r += 0.5;\n    }\n\n    // Display registers\n    vec2 drawPos = vec2(0.87890625 * aspect, 0.875);\n\n    // Counter\n    drawString(int[7](C, o, u, n, t, e, r), 7, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    drawInt(color, vec3(1.0), uv, drawPos, vec2(0.1), counter, 3);\n    drawPos.y -= 0.15;\n\n    // Accumulator\n    drawString(int[7](A, c, c, u, m, PERIOD, -1), 6, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    drawInt(color, vec3(1.0), uv, drawPos, vec2(0.1), accum, 3);\n    drawPos.y -= 0.15;\n\n    // Inbox (unused)\n    drawString(int[7](I, n, b, o, x, -1, -1), 5, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    drawInt(color, vec3(1.0), uv, drawPos, vec2(0.1), inbox, 3);\n    drawPos.y -= 0.15;\n\n    // Outbox\n    drawString(int[7](O, u, t, b, o, x, -1), 6, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    vec2 outboxUv = uv - drawPos;\n    float outboxIdx = round(-outboxUv.y / 0.15);\n    if (uv.x > 10.0 * cellSize.x && outboxIdx >= 0.0 && outboxIdx < 3.0) {\n        outboxUv.y += outboxIdx * 0.15;\n        int outboxHist = int(texelFetch(iChannel0, ivec2(outbox - int(outboxIdx) - 1, 1), 0).x);\n        drawInt(color, vec3(exp2(-outboxIdx)), outboxUv, vec2(0.0), vec2(0.1), outboxHist, 3);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 mailbox, in vec2 fragCoord) {\n    mailbox = vec4(0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int mailAddr = iFragCoord.x;\n    if (iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            // Assemble program\n            if (iFragCoord.y == 0 && iFragCoord.x < program.length()) {\n                ivec2 instr = program[mailAddr];\n                if (instr.x == DAT) { // Store variable\n                    mailbox.x = float(instr.y);\n                } else { // Encode and store instruction\n                    mailbox.x = float(instr.x * 100 + instr.y);\n                }\n            }\n\n            // Initialize registers\n            // program counter, accumulator, inbox, outbox\n            if (iFragCoord.y == 0 && iFragCoord.x == 100) {\n                mailbox = vec4(0, 0, 0, 0);\n            }\n        }\n\n        if (iFrame > 0) {\n            mailbox = texelFetch(iChannel0, iFragCoord, 0);\n            if (iFrame % INSTRUCTION_DELAY == 0 && iFragCoord.x <= 100) {\n                // Load registers\n                ivec4 registers = ivec4(texelFetch(iChannel0, ivec2(100, 0), 0));\n                int counter = registers.x;\n                int accum = registers.y;\n                int inbox = registers.z;\n                int outbox = registers.w;\n\n                if (inbox != -1) {\n                    // Load RAM\n                    int[100] mailboxes;\n                    for (int i=0; i < 100; i++) {\n                        mailboxes[i] = int(texelFetch(iChannel0, ivec2(i, 0), 0).x);\n                    }\n\n                    // Load current instruction\n                    int instr = mailboxes[counter];\n                    counter++;\n\n                    // Decode current instruction\n                    int addr = instr % 100;\n                    int opcode = (instr - addr) / 100;\n\n                    // Execute current instruction\n                    switch(opcode) {\n                        case HLT:\n                            inbox = -1;\n                            counter--;\n                            break;\n\n                        case ADD:\n                            accum += mailboxes[addr];\n                            break;\n\n                        case SUB:\n                            accum -= mailboxes[addr];\n                            break;\n\n                        case STA:\n                            mailboxes[addr] = accum;\n                            break;\n\n                        case LDA:\n                            accum = mailboxes[addr];\n                            break;\n\n                        case BRA:\n                            counter = addr;\n                            break;\n\n                        case BRZ:\n                            if (accum == 0) {\n                                counter = addr;\n                            } break;\n\n                        case BRP:\n                            if (accum >= 0) {\n                                counter = addr;\n                            } break;\n\n                        case INP:\n                            accum = inbox;\n                            break;\n\n                        case OUT:\n                            if (iFragCoord.y == 1 && iFragCoord.x == outbox) mailbox.x = float(accum);\n                            outbox++;\n                            break;\n                    }\n\n                    // Store updated state\n                    if (iFragCoord.y == 0 && iFragCoord.x < 100) mailbox.x = float(mailboxes[mailAddr]);\n                    if (iFragCoord.y == 0 && iFragCoord.x == 100) mailbox = vec4(counter, accum, inbox, outbox);\n                }\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define INSTRUCTION_DELAY 1\n\n// Opcodes\nconst int HLT = 0;\nconst int ADD = 1;\nconst int SUB = 2;\nconst int STA = 3;\nconst int LDA = 4;\nconst int BRA = 5;\nconst int BRZ = 6;\nconst int BRP = 7;\nconst int INP = 8;\nconst int OUT = 9;\nconst int DAT = 10;\n\n// Program to output the Recaman sequence\n// See https://en.wikipedia.org/wiki/Recam%C3%A1n's_sequence\n#define NUM 35 // Number of values to print out\nconst ivec2[] program = ivec2[](\n    ivec2(LDA,  55),\n    ivec2(SUB,  54),\n    ivec2(BRP,  52),\n    ivec2(LDA,  59),\n    ivec2(ADD,  60),\n    ivec2(STA,  10),\n    ivec2(LDA,  59),\n    ivec2(ADD,  64),\n    ivec2(STA,  59),\n    ivec2(LDA,  53),\n    ivec2(STA,  53),\n    ivec2(OUT,   0),\n    ivec2(LDA,  55),\n    ivec2(ADD,  64),\n    ivec2(STA,  55),\n    ivec2(LDA,  53),\n    ivec2(SUB,  55),\n    ivec2(STA,  56),\n    ivec2(LDA,  58),\n    ivec2(STA,  62),\n    ivec2(LDA,  63),\n    ivec2(STA,  57),\n    ivec2(LDA,  62),\n    ivec2(SUB,  59),\n    ivec2(BRP,  39),\n    ivec2(LDA,  62),\n    ivec2(ADD,  61),\n    ivec2(STA,  28),\n    ivec2(LDA,  53),\n    ivec2(SUB,  56),\n    ivec2(BRZ,  32),\n    ivec2(BRA,  35),\n    ivec2(LDA,  64),\n    ivec2(STA,  57),\n    ivec2(BRA,  39),\n    ivec2(LDA,  62),\n    ivec2(ADD,  64),\n    ivec2(STA,  62),\n    ivec2(BRA,  22),\n    ivec2(LDA,  63),\n    ivec2(SUB,  56),\n    ivec2(BRP,  48),\n    ivec2(LDA,  57),\n    ivec2(SUB,  64),\n    ivec2(BRZ,  48),\n    ivec2(LDA,  56),\n    ivec2(STA,  53),\n    ivec2(BRA,  51),\n    ivec2(LDA,  53),\n    ivec2(ADD,  55),\n    ivec2(STA,  53),\n    ivec2(BRA,   0),\n    ivec2(HLT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT, NUM),\n    ivec2(DAT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,  65),\n    ivec2(DAT,  65),\n    ivec2(STA,   0),\n    ivec2(LDA,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,   1)\n);\n\n/*\n// For those interested, here's my original pseudocode\n// from before I wrote the final program (if you can understand it :))\n// I have converted the original program to store all variables after\n// the rest of the program\n00 dat 0     cur_val = 0\n01 dat 20    max_val = 20\n02 dat 0     index = 0\n03 dat 0     tent_val = 0\n04 dat 0     in_hist = 0\n05 dat 65    hist_start = 65\n06 dat 65    hist_end = 65\n07 dat 300   mod_1 = 300 \"18 sta ? :MODIFY_1:\"\n08 dat 400   mod_2 = 400 \"32 lda ? :MODIFY_2:\"\n09 dat 0     hist_index = 0\n10 dat 0     const_0 = 0\n11 dat 1     const_1 = 1\nmainloop:\n12 lda cur_val\n13 sub max_val\n14 brp end(mainloop)\n15 lda hist_end\n16 add mod_1\n17 sta MODIFY_1\n18 lda hist_end\n19 add const_1\n20 sta hist_end\n21 lda cur_val\n22 sta ? :MODIFY_1:\n23 out\n24 lda index\n25 add const_1\n26 sta index\n27 lda cur_val\n28 sub index\n29 sta tent_val\n30 lda hist_start\n31 sta hist_index\n32 lda const_0\n33 sta in_hist\ncheck_loop:\n34 lda hist_index\n35 sub hist_end\n36 brp end(check_loop)\n37 lda hist_index\n38 add mod_2\n39 sta MODIFY_2\n40 lda ? :MODIFY_2:\n41 sub tent_val\n42 brz jmp_pt_1\n43 bra jmp_pt2\n:jmp_pt_1:\n44 lda const_1\n45 sta in_hist\n46 bra end(check_loop)\n:jmp_pt_2:\n47 lda hist_index\n48 add const_1\n49 sta hist_index\n50 bra check_loop\n:end(check_loop)\n51 lda const_0\n52 sub tent_val\n53 brp other_case\n54 lda in_hist\n55 sub const_1\n56 brz other_case\n57 lda tent_val\n58 sta cur_val\n59 bra skip_point\nother_case:\n60 lda cur_val\n61 add index\n62 sta cur_val\n:skip_point:\n63 bra mainloop\n:end(mainloop)\n64 hlt\n65 HIST_START\n*/\n\n// Character codes for convenience\n// Generated with a python script I wrote to save me the trouble ;)\n// I had to change some of the names manually though.\nconst int SPACE = 32;\nconst int EXCLAMATION = 33;\nconst int DOUBLE_QUOTE = 34;\nconst int HASHTAG = 35;\nconst int DOLLAR = 36;\nconst int PERCENT = 37;\nconst int AMPERSAND = 38;\nconst int SINGLE_QUOTE = 39;\nconst int OPEN_PARENTHESIS = 40;\nconst int CLOSE_PARENTHESIS = 41;\nconst int ASTERISK = 42;\nconst int PLUS = 43;\nconst int COMMA = 44;\nconst int HYPHEN = 45;\nconst int PERIOD = 46;\nconst int SLASH = 47;\nconst int ZERO = 48;\nconst int ONE = 49;\nconst int TWO = 50;\nconst int THREE = 51;\nconst int FOUR = 52;\nconst int FIVE = 53;\nconst int SIX = 54;\nconst int SEVEN = 55;\nconst int EIGHT = 56;\nconst int NINE = 57;\nconst int COLON = 58;\nconst int SEMICOLON = 59;\nconst int LESS_THAN = 60;\nconst int EQUAL = 61;\nconst int GREATER_THAN = 62;\nconst int QUESTION = 63;\nconst int AT = 64;\nconst int A = 65;\nconst int B = 66;\nconst int C = 67;\nconst int D = 68;\nconst int E = 69;\nconst int F = 70;\nconst int G = 71;\nconst int H = 72;\nconst int I = 73;\nconst int J = 74;\nconst int K = 75;\nconst int L = 76;\nconst int M = 77;\nconst int N = 78;\nconst int O = 79;\nconst int P = 80;\nconst int Q = 81;\nconst int R = 82;\nconst int S = 83;\nconst int T = 84;\nconst int U = 85;\nconst int V = 86;\nconst int W = 87;\nconst int X = 88;\nconst int Y = 89;\nconst int Z = 90;\nconst int OPEN_BRACKET = 91;\nconst int BACKSLASH = 92;\nconst int CLOSE_BRACKET = 93;\nconst int CIRCUMFLEX = 94;\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\nconst int OPEN_BRACE = 123;\nconst int PIPE = 124;\nconst int CLOSE_BRACE = 125;\nconst int TILDE = 126;","name":"Common","description":"","type":"common"}]}