{"ver":"0.1","info":{"id":"ss2GDm","date":"1618406645","viewed":83,"name":"CG-Course_Task_2","username":"Gr_Gusev","description":"CMC CG course. Task 2","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // A hack for getting full screen image:\n    // uncomment this, reset time, go fullscreen and Alt + <Up Arrow>\n    \n    //if (iFrame < 2)\n    //    return;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float EPS = 1e-5;\n\nvec3 randDir; // Global vec\n\n// Change this to move camera:\nconst vec3 CAMERA_POS = vec3(3.0, 2.5, -6.0);\n//const vec3 CAMERA_POS = vec3(3.2, 2.5, 5.5);\n//const vec3 CAMERA_POS = vec3(-5.5, -1.05, 2.9);\n//const vec3 CAMERA_POS = vec3(-3.2, 3.7, 2.4);\n//const vec3 CAMERA_POS = vec3(-1.9, -1.1, -6.2);\n\n\nconst vec3  LIGHT1_POS = vec3(2.3, 0.6, -0.8);\nconst vec3  LIGHT1_COLOR = vec3(1.0, 0.95, 0.6);\nconst float LIGHT1_RADIUS = 0.5;\n\nconst vec3  LIGHT2_POS = vec3(-2.0, 1.0, 0.5);\nconst vec3  LIGHT2_COLOR = vec3(0.5, 1.0, 0.8);\nconst float LIGHT2_RADIUS = 0.4;\n\nconst vec3  PEDESTAL_POS = vec3(0.0, -1.6, 0.0);\nconst float PEDESTAL_RA = 0.4;\nconst float PEDESTAL_RB = 0.1;\nconst float PEDESTAL_H = 0.01;\nconst float PEDESTAL_R = 0.2;\n\n// objects :\nconst int CAPSULE = 1;\nconst int ROUND_CONE = 2;\nconst int TORUS = 3;\nconst int LINK = 4;\n\nconst vec3  CAPSULE_POS = vec3(-0.7, -0.5, -0.5);\nconst vec3  CAPSULE_A = vec3(0.0, 0.5, 0.0);\nconst vec3  CAPSULE_B = vec3(0.6, -0.2, 0.4);\nconst float CAPSULE_R = 0.15;\nconst float CAPSULE_N = 1.0;\nconst vec3  CAPSULE_COLOR_MULT = vec3(1.0, 0.9, 0.9);\n\nconst vec3  ROUND_CONE_A = vec3(0.8, -0.2, 0.0);\nconst vec3  ROUND_CONE_B = vec3(0.0, 0.4, 0.8);\nconst float ROUND_CONE_R1 = 0.2;\nconst float ROUND_CONE_R2 = 0.08;\nconst float ROUND_CONE_N = 2.5;\nconst vec3  ROUND_CONE_COLOR_MULT = vec3(1.0, 1.0, 0.8);\n\nconst vec3  TORUS_POS = vec3(0.0, 0.5, 0.0);\nconst vec2  TORUS_T = vec2(0.5, 0.1);\nconst float TORUS_N = 1.3;\nconst vec3  TORUS_COLOR_MULT = vec3(0.9, 0.8, 1.0);\n\nconst vec3  LINK_POS = vec3(0.0, 0.0, 0.0);\nconst float LINK_LE = 0.3;\nconst float LINK_R1 = 0.25;\nconst float LINK_R2 = 0.1;\nconst float LINK_N = 2.3;\nconst vec3  LINK_COLOR_MULT = vec3(0.9, 1.0, 0.9);\n\nconst float AIR_N = 1.0;\n\nconst float OCT_N = 1.2;\n\nconst float TABLE_R = 0.2;\nconst float TABLE_H = -1.7;\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nstruct TRGL\n{\n    vec3 V0, V1, V2;\n};\n\nconst TRGL Octahedron[8] = \n    TRGL[8](TRGL(vec3(0.0, 0.0, -1.5), // 0\n                 vec3(0.0, -1.5, 0.0),\n                 vec3(-1.5, 0.0, 0.0)),\n            \n            TRGL(vec3(0.0, 0.0, -1.5), // 1\n                 vec3(1.5, 0.0, 0.0),\n                 vec3(0.0, -1.5, 0.0)),\n                 \n            TRGL(vec3(0.0, 0.0, -1.5), // 2\n                 vec3(1.5, 0.0, 0.0),\n                 vec3(0.0, 1.5, 0.0)),\n                 \n            TRGL(vec3(0.0, 0.0, -1.5), // 3\n                 vec3(-1.5, 0.0, 0.0),\n                 vec3(0.0, 1.5, 0.0)),\n                 \n            TRGL(vec3(0.0, 0.0, 1.5), // 4\n                 vec3(0.0, -1.5, 0.0),\n                 vec3(-1.5, 0.0, 0.0)),\n                 \n            TRGL(vec3(0.0, 0.0, 1.5), // 5\n                 vec3(1.5, 0.0, 0.0),\n                 vec3(0.0, -1.5, 0.0)),\n                 \n            TRGL(vec3(0.0, 0.0, 1.5), // 6\n                 vec3(0.0, 1.5, 0.0),\n                 vec3(1.5, 0.0, 0.0)),\n                 \n            TRGL(vec3(0.0, 0.0, 1.5), // 7\n                 vec3(0.0, 1.5, 0.0),\n                 vec3(-1.5, 0.0, 0.0))\n            );\n\nfloat intersectSphere(in vec3 rayPos, in vec3 rayDir, \n                      in vec3 spherePos, in float radius, \n                      out vec3 normal)\n{\n    vec3 pos = rayPos - spherePos;\n    \n    float dp = dot(rayDir, pos);\n    float pp = dot(pos, pos);\n    \n    float D = dp * dp - pp + radius * radius;\n    if (D < 0.0) {\n        return INF;\n    }\n    \n    float t = - dp - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(t * rayDir + pos);\n        return t;\n    }\n\n    t = -dp + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(t * rayDir + pos);\n    return t;\n}\n\nfloat intersectTable(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (TABLE_H - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 10.0) {\n        return INF;\n    }\n    \n    normal = normalize(vec3(0, 1, 0) + (texture(iChannel0, worldPos.xz).rgb * 3.0 - 1.0) * 0.4);\n    return t;\n}\n\nfloat intersectTrgl(in vec3 ro, in vec3 rd, \n                    in vec3 v0, in vec3 v1, in vec3 v2,\n                    out vec3 normal)\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross(v1v0, v2v0);\n    vec3  q = cross(rov0, rd);\n    \n    float d = 1.0 / dot(rd, n);\n    \n    if (d < EPS && d > -EPS) {\n        return INF;\n    }\n    \n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n\n    if (u < 0.0 || v < 0.0 || (u + v) > 1.0) {\n        return INF;\n    }\n    \n    normal = normalize(cross(v1v0, v2v0));\n    if (dot(normal, rd) > 0.0) {\n        normal = normalize(cross(v2v0, v1v0));\n    }\n    \n    if (t < 0.0) {\n        return INF;\n    }\n    \n    return t;\n}\n\nfloat intersectOctahedron(in vec3 pos, in vec3 dir, out vec3 normal)\n{\n    float t = INF;\n    vec3 t_normal;\n    float t_trgl0 = intersectTrgl(pos, dir,\n                                  Octahedron[0].V0, Octahedron[0].V1, Octahedron[0].V2,\n                                  t_normal);\n    if (t_trgl0 < t) {\n        t = t_trgl0;\n        normal = t_normal;\n    }\n        \n    float t_trgl1 = intersectTrgl(pos, dir,\n                                  Octahedron[1].V0, Octahedron[1].V1, Octahedron[1].V2,\n                                  t_normal);\n    if (t_trgl1 < t) {\n        t = t_trgl1;\n        normal = t_normal;\n    }\n    \n    float t_trgl2 = intersectTrgl(pos, dir,\n                                  Octahedron[2].V0, Octahedron[2].V1, Octahedron[2].V2,\n                                  t_normal);\n    if (t_trgl2 < t) {\n        t = t_trgl2;\n        normal = t_normal;\n    }\n       \n    float t_trgl3 = intersectTrgl(pos, dir,\n                                  Octahedron[3].V0, Octahedron[3].V1, Octahedron[3].V2,\n                                  t_normal);\n    if (t_trgl3 < t) {\n        t = t_trgl3;\n        normal = t_normal;\n    }\n        \n    float t_trgl4 = intersectTrgl(pos, dir,\n                                  Octahedron[4].V0, Octahedron[4].V1, Octahedron[4].V2,\n                                  t_normal);\n    if (t_trgl4 < t) {\n        t = t_trgl4;\n        normal = t_normal;\n    }\n        \n    float t_trgl5 = intersectTrgl(pos, dir,\n                                  Octahedron[5].V0, Octahedron[5].V1, Octahedron[5].V2,\n                                  t_normal);\n    if (t_trgl5 < t) {\n        t = t_trgl5;\n        normal = t_normal;\n    }\n        \n    float t_trgl6 = intersectTrgl(pos, dir,\n                                  Octahedron[6].V0, Octahedron[6].V1, Octahedron[6].V2,\n                                  t_normal);\n    if (t_trgl6 < t) {\n        t = t_trgl6;\n        normal = t_normal;\n    }\n        \n    float t_trgl7 = intersectTrgl(pos, dir,\n                                  Octahedron[7].V0, Octahedron[7].V1, Octahedron[7].V2,\n                                  t_normal);\n    if (t_trgl7 < t) {\n        t = t_trgl7;\n        normal = t_normal;\n    }\n    \n    return t;\n}\n\nfloat distancePedestal(in vec3 p)\n{\n    p = p - PEDESTAL_POS;\n    float ra = PEDESTAL_RA;\n    float rb = PEDESTAL_RB;\n    float h = PEDESTAL_H;\n    \n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    float ret = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n    return ret;\n}\n\nvec3 normalPedestal(in vec3 p)\n{\n    const vec2 h = vec2(EPS * 10.0, 0.0);\n\n    float t1 = distancePedestal(p + h.xyy);\n    float t2 = distancePedestal(p - h.xyy);\n    \n    float t3 = distancePedestal(p + h.yxy);\n    float t4 = distancePedestal(p - h.yxy);\n    \n    float t5 = distancePedestal(p + h.yyx);\n    float t6 = distancePedestal(p - h.yyx);\n    \n    return normalize(vec3(t1 - t2, t3 - t4, t5 - t6));\n}\n\nfloat intersectPedestal(in vec3 pos, in vec3 dir, out vec3 color, out vec3 normal)\n{\n    float t = INF, t_prev = INF;\n    float dist = 0.0;\n    while (true) {\n        t = distancePedestal(pos);\n        if (t < EPS / 10.0) {\n            break;\n        }\n        dist += t;\n        pos += t * dir;\n        if (t_prev < t) {\n            return INF;\n        } else {\n            t_prev = t;\n        }\n    }\n    normal = normalPedestal(pos + t * dir);\n    vec3 world_pos = pos + t * dir;\n    color = texture(iChannel2, world_pos.xz * world_pos.y).rgb;\n    return dist;\n}\n\nfloat distanceCapsule(in vec3 p)\n{\n    p = p - CAPSULE_POS;\n    float r = CAPSULE_R;\n    vec3 a = CAPSULE_A;\n    vec3 b = CAPSULE_B;\n    \n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nvec3 normalCapsule(in vec3 p)\n{\n    const vec2 h = vec2(EPS * 10.0, 0.0);\n\n    float t1 = distanceCapsule(p + h.xyy);\n    float t2 = distanceCapsule(p - h.xyy);\n    \n    float t3 = distanceCapsule(p + h.yxy);\n    float t4 = distanceCapsule(p - h.yxy);\n    \n    float t5 = distanceCapsule(p + h.yyx);\n    float t6 = distanceCapsule(p - h.yyx);\n    \n    return normalize(vec3(t1 - t2, t3 - t4, t5 - t6));\n}\n\nfloat distanceRoundCone(in vec3 p)\n{\n    vec3 a = ROUND_CONE_A;\n    vec3 b = ROUND_CONE_B;\n    float r1 = ROUND_CONE_R1;\n    float r2 = ROUND_CONE_R2;\n    \n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr * rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot(pa * l2 - ba * y, pa * l2 - ba * y);\n    float y2 = y * y * l2;\n    float z2 = z * z * l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if (sign(z) * a2 * z2 > k ) {\n        return  sqrt(x2 + z2) * il2 - r2;\n    }\n    if (sign(y) * a2 * y2 < k ) {\n        return  sqrt(x2 + y2) * il2 - r1;\n    }\n    \n    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n}\n\nvec3 normalRoundCone(in vec3 p)\n{\n    const vec2 h = vec2(EPS * 10.0, 0.0);\n\n    float t1 = distanceRoundCone(p + h.xyy);\n    float t2 = distanceRoundCone(p - h.xyy);\n    \n    float t3 = distanceRoundCone(p + h.yxy);\n    float t4 = distanceRoundCone(p - h.yxy);\n    \n    float t5 = distanceRoundCone(p + h.yyx);\n    float t6 = distanceRoundCone(p - h.yyx);\n    \n    return normalize(vec3(t1 - t2, t3 - t4, t5 - t6));\n}\n\nfloat distanceTorus(in vec3 p)\n{\n    p = p - TORUS_POS;\n    vec2 t = TORUS_T;\n    \n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nvec3 normalTorus(in vec3 p)\n{\n    const vec2 h = vec2(EPS * 10.0, 0.0);\n\n    float t1 = distanceTorus(p + h.xyy);\n    float t2 = distanceTorus(p - h.xyy);\n    \n    float t3 = distanceTorus(p + h.yxy);\n    float t4 = distanceTorus(p - h.yxy);\n    \n    float t5 = distanceTorus(p + h.yyx);\n    float t6 = distanceTorus(p - h.yyx);\n    \n    return normalize(vec3(t1 - t2, t3 - t4, t5 - t6));\n}\n\nfloat distanceLink(in vec3 p)\n{\n    p = p - LINK_POS;\n    float le = LINK_LE;\n    float r1 = LINK_R1;\n    float r2 = LINK_R2;\n    \n    vec3 q = vec3(p.x, p.y, max(abs(p.z) - le, 0.0));\n    return length(vec2(length(q.yz) - r1, q.x)) - r2;\n}\n\nvec3 normalLink(in vec3 p)\n{\n    const vec2 h = vec2(EPS * 10.0, 0.0);\n\n    float t1 = distanceLink(p + h.xyy);\n    float t2 = distanceLink(p - h.xyy);\n    \n    float t3 = distanceLink(p + h.yxy);\n    float t4 = distanceLink(p - h.yxy);\n    \n    float t5 = distanceLink(p + h.yyx);\n    float t6 = distanceLink(p - h.yyx);\n    \n    return normalize(vec3(t1 - t2, t3 - t4, t5 - t6));\n}\n\nfloat intersectObjects(in vec3 pos, in vec3 dir, \n                       out vec3 color, out vec3 normal, out float n)\n{\n    bool init = false;\n    bool init_inside = false;\n    bool is_inside = false;\n    float t_start = 0.0, t_step;\n    float t = INF, t_prev = INF;\n    int object = -1;\n    float dist = 0.0;\n    \n    while (t != -INF) {\n        t = INF;\n        float t_capsule = distanceCapsule(pos);\n        float t_roundCone = distanceRoundCone(pos);\n        float t_torus = distanceTorus(pos);\n        float t_link = distanceLink(pos);\n        \n        if (t_capsule < t) {\n            t = t_capsule;\n            object = CAPSULE;\n        }\n        if (t_roundCone < t) {\n            t = t_roundCone;\n            object = ROUND_CONE;\n        }\n        if (t_torus < t) {\n            t = t_torus;\n            object = TORUS;\n        }\n        if (t_link < t) {\n            t = t_link;\n            object = LINK;\n        }\n        \n        if (init == false) {\n            if (t <= 0.0) {\n                is_inside = true;\n            } else {\n                is_inside = false;\n            }\n            init = true;\n        }\n        \n        if (is_inside) {\n            if (init_inside == false) {\n                if (t_prev > t) {\n                    t_prev = t;\n                } else {\n                    init_inside = true;\n                }\n            } else {\n                if (abs(t) < EPS / 10.0) {\n                    break;\n                }\n            }\n        } else {\n            if (t < EPS / 10.0) {\n                break;\n            }\n        }\n        if (is_inside) {\n            t_step = min(EPS * 1000.0, abs(t));\n        } else {\n            t_step = t;\n        }\n        dist += t_step;\n        pos += t_step * dir;\n\n        if (is_inside == false) {\n            if (t_prev < t) {\n                if (t > 1.3) {\n                    return INF;\n                }\n            } else {\n                t_prev = t;\n            }\n        }\n    }\n    \n    if (object == CAPSULE) {\n        color = CAPSULE_COLOR_MULT;\n        normal = normalCapsule(pos);\n        if (is_inside) {\n            n = OCT_N;\n        } else {\n            n = CAPSULE_N;\n        }\n        return dist;\n    }\n    if (object == ROUND_CONE) {\n        color = ROUND_CONE_COLOR_MULT;\n        normal = normalRoundCone(pos);\n        if (is_inside) {\n            n = OCT_N;\n        } else {\n            n = ROUND_CONE_N;\n        }\n        return dist;\n    }\n    if (object == TORUS) {\n        color = TORUS_COLOR_MULT;\n        normal = normalTorus(pos);\n        if (is_inside) {\n            n = OCT_N;\n        } else {\n            n = TORUS_N;\n        }\n        return dist;\n    }\n    if (object == LINK) {\n        color = LINK_COLOR_MULT;\n        normal = normalLink(pos);\n        if (is_inside) {\n            n = OCT_N;\n        } else {\n            n = LINK_N;\n        }\n        return dist;\n    }\n    return INF;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nbool isOccluded(in vec3 pos, in vec3 target) {\n    vec3 rvec = target - pos;\n    float dist = length(rvec);\n    vec3 dir = rvec / dist;\n    vec3 normal;\n    float t;\n    \n    t = intersectOctahedron(pos, dir, normal);\n    if (dist >= t) {\n        return true;\n    }\n    vec3 color;\n    t = intersectPedestal(pos, dir, color, normal);\n    return (t <= dist && t > EPS);\n}\n\nvec3 computeLight(in vec3 pos, in vec3 color, in vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 20.0 / distSq1;\n    \n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 15.0 / distSq2;\n    \n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.8\n    );\n}\n\nvec3 refraction(in vec3 v, in vec3 normal, inout float n1, inout float n2)\n{\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    \n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    if (sinA > n2 / n1) {\n        return normalize(reflect(v, normal));\n    }\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA * (n1 / n2);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    float tmp = n1;\n    n1 = n2;\n    n2 = tmp;\n    return normalize(sinB * tang + cosB * normal);\n}\n\nfloat getR(in float n1, in float n2)\n{\n    float s1 = n1 - n2;\n    float s2 = n1 + n2;\n    \n    return (s1 / s2) * (s1 / s2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    \n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    float cur_n = AIR_N;\n    float n;\n    vec3 cur_dir, cur_pos;\n    vec3 colorMult = vec3(1.0, 1.0, 1.0);\n    cur_dir = viewVec;\n    cur_pos = CAMERA_POS;\n\n    for (int i = 0; i < 50; i++) {\n        float t = INF;\n        vec3 color;\n        vec3 t_normal, normal;\n        int t_material;\n        \n        fragColor.rgb = colorMult;\n        \n        float t_table = intersectTable(cur_pos, cur_dir, t_normal);\n        if (t_table <= t) {\n            t = t_table;\n            vec3 worldPos = cur_pos + t * cur_dir;\n            color = texture(iChannel0, worldPos.xz / 10.0).rgb;\n            if (randVals.x < TABLE_R) {\n                t_material = REFLECTION;\n            } else {\n                t_material = DIFFUSE;\n            }\n            normal = t_normal;\n        }\n        \n        float t_light1 = intersectSphere(cur_pos, cur_dir, \n                                         LIGHT1_POS, LIGHT1_RADIUS, \n                                         t_normal);\n        if (t_light1 < t) {\n            t = t_light1;\n            normal = t_normal;\n            float noise = texture(iChannel3, normal * 1.1).r;\n            vec3 noise_vec = vec3(0.0, noise * 0.2, noise * 0.4);\n            color = LIGHT1_COLOR - noise_vec;\n            t_material = EMISSION;\n        }\n        \n        float t_light2 = intersectSphere(cur_pos, cur_dir, \n                                         LIGHT2_POS, LIGHT2_RADIUS, \n                                         t_normal);\n        if (t_light2 < t) {\n            t = t_light2;\n            vec3 world_pos = cur_pos + cur_dir * t;\n            normal = t_normal;\n            float noise = texture(iChannel3, normal * 0.4).r;\n            vec3 noise_vec = vec3(noise * 0.1, noise * 0.2, noise * 0.5);\n            color = LIGHT2_COLOR - noise_vec;\n            t_material = EMISSION;\n        }\n        \n        float t_oct = intersectOctahedron(cur_pos, cur_dir, t_normal);\n        if (t_oct < t) {\n            t = t_oct;\n            if (randVals.x < getR(OCT_N, AIR_N)) {\n                t_material = REFLECTION;\n            } else {\n                t_material = REFRACTION;\n                colorMult *= vec3(0.98, 1.0, 0.98);\n                if (cur_n == AIR_N) {\n                    n = OCT_N;\n                } else {\n                    n = AIR_N;\n                }\n            }\n            normal = t_normal;\n        }\n        \n        vec3 t_color;\n        if (cur_n == AIR_N) {\n            float t_pedestal = intersectPedestal(cur_pos, cur_dir, t_color, t_normal);\n            if (t_pedestal < t) {\n                t = t_pedestal;\n                color = t_color;\n                if (randVals.x < PEDESTAL_R) {\n                    t_material = REFLECTION;\n                } else {\n                    t_material = DIFFUSE;\n                }\n                normal = t_normal;\n            }\n        }\n        float t_n = AIR_N;\n        vec3 t_colorMult;\n        float t_obj = intersectObjects(cur_pos, cur_dir, t_colorMult, t_normal, t_n);\n        if (t_obj < t) {\n            t = t_obj;\n            fragColor.rgb = t_colorMult;\n            normal = t_normal;\n            n = t_n;\n            if (randVals.x < getR(OCT_N, n)) {\n                t_material = REFLECTION;\n            } else {\n                t_material = REFRACTION;\n                colorMult *= t_colorMult;\n            }\n        }\n        \n        if (t != INF) {\n            vec3 world_pos = t * cur_dir + cur_pos;\n\n            if (t_material == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (t_material == DIFFUSE) {\n                fragColor.rgb = computeLight(world_pos, color, normal) * colorMult;\n                break;\n            } else if (t_material == REFLECTION) {\n                cur_dir = normalize(reflect(cur_dir, normal));\n                cur_pos = world_pos + cur_dir * EPS * 100.0;\n            } else if (t_material == REFRACTION) {\n                cur_dir = normalize(refraction(cur_dir, normal, cur_n, n));\n                cur_pos = world_pos + cur_dir * EPS * 100.0;\n                fragColor.rgb = colorMult;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, cur_dir).rgb * colorMult;\n            break;\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}