{"ver":"0.1","info":{"id":"lXlSRs","date":"1709866176","viewed":73,"name":"Hyperboloid as a ruled surface","username":"zenzicubic","description":"The hyperboloid of revolution colored by one of its two families of rulings","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["surface","hyperboloid","ruled"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Hit {\n    bool hit;\n    float t;\n    vec3 pt, normal;\n};\n\nstruct Material {\n    float diffuse, specular, glossiness, reflectivity;\n};\n\n// Camera stuff\nvec3 eye;\nmat3 viewMat;\n#define FOCAL_LEN 2.5\n#define MAX_DIST 25.\n#define RAD_SQ 9.\n\n// Lighting/material\n#define AMBIENT .4\n#define INTENSITY .7\n#define LIGHT_POS vec3(10.)\n#define DELTA vec3(1e-3, 0., 0.)\n\nMaterial mat = Material(.5, .7, 30., .3);\n\n/*\nRay-scene intersector.\n*/\n\nHit intersectScene(vec3 ro, vec3 rd) {\n    Hit hit;\n    hit.hit = false;\n    \n    // Coefficients and discriminant\n    float a = dot(rd.xz, rd.xz) - rd.y * rd.y;\n    float b = dot(rd.xz, ro.xz) - rd.y * ro.y;\n    float c = dot(ro.xz, ro.xz) - ro.y * ro.y - 1.;\n    \n    float disc = b * b - a * c;\n    if (disc < 0.) return hit;\n    \n    // Solve\n    disc = sqrt(disc);\n    a = 1. / a;\n    \n    float t = (-b - disc) * a;\n    vec3 pt = ro + rd * t;\n    if (t < 0. || t > MAX_DIST || abs(pt.y) > 3.) {\n        t = (disc - b) * a;\n        pt = ro + rd * t;\n        if (t < 0. || t > MAX_DIST || abs(pt.y) > 3.) return hit;\n    }\n    \n    // Get normal and point\n    vec3 nrm = normalize(pt * vec3(1., -1., 1.));\n    nrm *= -sign(dot(rd, nrm));\n    \n    hit.hit = true;\n    hit.t = t;\n    hit.pt = pt;\n    hit.normal = nrm;\n    return hit;\n}\n\n/*\nCamera stuff.\n*/\n\nvoid setViewMat(vec3 lookAt) {\n    // OpenGL-style view matrix\n    vec3 w = normalize(lookAt - eye);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    viewMat = mat3(u, v, -w);\n}\n\nvec3 getRayDir(vec2 p) {\n    // Get the ray direction\n    p = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 d = normalize(vec3(p, -FOCAL_LEN));\n    return viewMat * d;\n}\n\n/*\nMain intersection, lighting, and coloring.\n*/\n\nfloat getLighting(Hit hit) {\n    // Simple Phong lighting\n    vec3 N = hit.normal, P = hit.pt;\n    vec3 L = normalize(LIGHT_POS - P);\n    vec3 V = normalize(eye - P);\n    vec3 R = reflect(-L, N);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.) return 0.;\n    float contrib = mat.diffuse * dotLN;\n    \n    if (dotRV > 0.) {\n        contrib += mat.specular * pow(dotRV, mat.glossiness);\n    }\n    return contrib;\n}\n\nvec3 getColor(vec2 p) {\n    vec3 rd = getRayDir(p);\n    Hit hit = intersectScene(eye, rd);\n    if (hit.hit) {\n        // Simple lighting model\n        float brt = AMBIENT + INTENSITY * getLighting(hit);\n        vec3 pt = hit.pt;\n        \n        float v = pt.y;\n        float d = asin(-pt.y / sqrt(v * v + 1.));\n        d -= atan(pt.z, pt.x);\n        \n        vec3 col = vec3(1., .8, 0.) * smoothstep(0., .5, abs(sin(20. * d)));\n        return col * brt;\n    }\n    return vec3(.1);\n}\n\nvoid mainImage(out vec4 col, vec2 pt) {\n    float t = .1 * iTime;\n    eye = 3. * vec3(3. * cos(t), 2., 3. * sin(t));\n    setViewMat(vec3(0.));\n    col = vec4(getColor(pt), 1.);\n}","name":"Image","description":"","type":"image"}]}