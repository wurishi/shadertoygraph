{"ver":"0.1","info":{"id":"lsKSDt","date":"1467481112","viewed":398,"name":"Trying to simplify a sine shader","username":"cubby208","description":"NOTE: This shader is not mine\n\nRight now I am considering creating a LUT.\n\nOrigional by  ETD: https://www.shadertoy.com/view/XdyXW3","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Shiny Waves by etd\n\n   License Creative Commons Zero\n\n   https://www.shadertoy.com/view/XdyXW3\n\n   Wave idea from http://glslsandbox.com/e#33565.1\n*/\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define global_speed 0.5\n#define convert (180.0 / 3.141592)\n#define twopi 3.141592 * 2.0\n\nfloat range(float num) {\n\tfloat temp = num;\n\tif (temp > twopi) {\n\t\ttemp -= twopi;\n\t}\n\treturn temp;\n}\n\nfloat round(float num) {\n\tfloat scale = iMouse.x / iResolution.x;\n    if (scale == 0.0) { scale = 0.0001;}\n\treturn float(int(range(num) * (convert * scale))) / (convert * scale);\n}\nfloat sine(float num) {\n\treturn sin(round(num));\n}\n\nvec4 wave(vec4 w_base, vec2 res, float time, float x_offset, float y_offset,\n\tfloat x_amp, float y_amp, float speed) {\n\tvec2 p = (gl_FragCoord.xy / (res.xy * 4.)) - vec2(0.25, 0.02) + y_offset;\n\tfloat sx = y_amp * 0.1 * (p.x * 2.0 + 2.15) * sin(round(x_offset + x_amp * 60. * p.x - time * speed)); \n\tfloat dy = 1. / (10. * abs(p.y - sx));\n\tvec4 col = vec4(w_base.xyz * dy, w_base.w);\n\treturn col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat time = iTime * global_speed;\n\tvec2 res = iResolution.xy;\n\tvec2 p = (gl_FragCoord.xy / res.xy) - 0.5; \n\tvec4 w_base = vec4(p.x + 0.5, (p.y + 0.5) * 0.8, 0.3, 1.0);\n    \n\tvec4 w1 = wave(w_base, res, time, 0.0, -0.1, 1.0, 0.9, 3.0);\n\tvec4 w2 = wave(w_base, res, time, 5., -0.2, 0.5, 0.5 + sine(time / 3.0) * 0.4, 1.0);\n\tvec4 w3 = wave(w_base, res, time, -5., -0.05, 0.5, 0.5 + sine(time + 5.0) * 0.3, 3.0);\n    \n\tvec4 bg = vec4(0., 0., .2, 1.0);\n    \n\tfloat y = (sine((fragCoord.x / res.x) * twopi) / 2.0) + 0.5;\n\tif (abs(y - (fragCoord.y / res.y)) < 0.05) {\n\t\tfragColor = vec4(1.0);\n\t} else {\n\t\tfragColor = bg + w1 * w2 * w3;\n\t}\n}","name":"Image","description":"","type":"image"}]}