{"ver":"0.1","info":{"id":"ll3SDr","date":"1478970144","viewed":2290,"name":"Small Pathtracer","username":"fizzer","description":"A simple picture made using 998 chars in total, with multiple bounces, depth-of-field with a circular aperture, vignet, and an importance-sampled Lambert BRDF.\nClick to restart.\nShould be like this:https://twitter.com/eddbiddulph/status/799201904563781632","likes":50,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, vec2 c)\n{\n    o = texture(iChannel0, c / iResolution.xy);   \n    o = vec4(o.rgb / o.a * 4., 1.);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float s, b, R, is, e, f, E = 0.;\nfloat r() { return fract(sin(s++) * 43758.545); }\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    // RNG seed\n    s = mod(C.x * C.y + float(iFrame) * 91., 9121.);\n\n    // Camera set-up\n    vec3 a = vec3(r(), r(), .5) - .5,\n        d = vec3(10.5, 5.3 ,-60),\n        D = normalize(vec3(C / iResolution.y * 2. - 1.6, 2) * 9. - a), O = d + a + D * 15.,\n        c;\n\n    // Ray contribution factor (includes a vignet-like effect)\n    f = dot(a, a) < .25 ? D.z * D.z * 1.5 - .5 : 0.;\n\n    // Uniform grid ray traversal loop\n    for (int i = 0; i < 90; ++i)\n    {\n        c = floor(O);\n        a = c + .5;\n\n        // Ray-sphere intersection set-up\n        b = dot(D, a - O);\n        e = b * b - dot(a - O, a - O) + .25;\n\n        if (e > 0.)\n        {\t\t\t\n            d = vec3(1e-6);\n            // Ray-sphere intersection\n            is = b - sqrt(e) + 1e-4;\n\n            \n            // Mandelbulb iteration for sphere placement\n            for (int j = 0; j < 11; ++j)\n                b = length(d),\n                e = 4. * atan(d.y, d.x),\n                R = 4. * acos(d.z / b),\n                d = b * b * b * b * vec3(sin(R) * cos(e), sin(R) * sin(e), cos(R)) + c.yzx / 50.;\n\n            \n            if (b < 200. && is > 0.)\n            {\n                if (b > 100.)\n                    E += f;\n                // Ray offset to sphere intersection point\n                O += D * is;\n                D = normalize(O - a);\n                // Mostly-importance-sampled Lambert reflection\n                d = vec3(r(), r(), r()) * 2. - 1.;\n                b = length(d);\n                R = pow(b / log(length(exp(abs(d) * 32.))) * 32., 3.);\n                d /= b;\n                D = (D + d) / sqrt(dot(D, d) * 2. + 2.001); // 0.001 is added here to avoid numerical problems.\n                // Reflection albedo\n                f *= .9 / R;\n                continue;\n            }\n        }\n\n        // Step to the next cell in the uniform grid\n        d = (c + max(sign(D), 0.) - O) / D;\n        O += (dot(d, step(d, d.yzx) * step(d, d.zxy)) + 1e-4) * D;\n    }\n\n    // Accumulate energy\n    o = texture(iChannel0, C / iResolution.xy) * step(iMouse.z, 0.) + vec4(E * vec3(1, 3, 2) + (.5 + .5 * D.y) * f, 1);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}