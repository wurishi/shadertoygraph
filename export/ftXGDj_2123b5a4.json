{"ver":"0.1","info":{"id":"ftXGDj","date":"1622897193","viewed":632,"name":"Marching Cubes II","username":"kastorp","description":"another marching cubes experiment, now with buffering\n\n","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["voxel","marchingcubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Marching Cubes II by Kastorp\n//----------------------------------------------------------------\n// \n// with CACHE undefined: caching only surface intersection; only 1 bit needed per cube\n// with CACHE defined: caching all data in one pixel, with quantized weights; better performance, less accuracy\n//\n// update:  after some optimizations on tritable lookup, also uncached version if fast and usable in realtime\n//----------------------------------------------------------------\n\n//#define CACHE\n\nvec3    g_n;\nvec2    g_uv;\n\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5*csz - csz*0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\nvec3 rayDirection(vec3 cameraDir, vec2 uv){\n    \n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\n\nvec4 trace(vec3 ro,vec3 rd)\n{\n    //RAYTRACING BOUNDING BOX\n    vec2 tb= boxIntersection(  ro,  rd, vec3(csz*N*.50+.00001) ) ;\n    if(tb.y<0.) return vec4(0.);\n    \n    \n    //VOXEL TRAVERSAL\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp=ro +  max(tb.x,0.)*rd;  \n    vec3 mp=floor(rp/csz)*csz;\n    vec3 sd = (mp-rp + 0.5*csz + sign(rd)*0.5*csz) *ri;\n    vec3 mask=vec3(0.);     \n    for (int i = 0; i < 200; i++) {\n         \n        mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\t\tsd += mask *  rs *ri*csz;\n        mp += mask *  rs*csz;\n        \n        rp = VoxelHitPos(mp,rp,rd).xyz+rd*.0001; \n        if(length(rp-ro)>tb.y) break; //outside bounding box\n        \n\n       uvec4 tridata = floatBitsToUint(getVoxel( mp/csz,iChannel2,iChannelResolution[2])); \n    \n       int ntriangles=int(tridata.x);\n        if(ntriangles>0 ){\n                     \n            TRIANGLE[5] triangles;\n            \n#ifndef CACHE\n                //calculate vertexes & triangles (requires buffer A and B)\n                GRIDCELL g;\n                for(int id=0;id<8;id++)\n                {\n                    g.p[id]=mp+  VertexOffset[id]*csz;\n                    g.val[id]=getVoxel(g.p[id]/csz,iChannel1,iChannelResolution[1]).x;                \n                }\n\n                Polygonise(g,0.,triangles,iChannel0);\n#else\n                //rebuild from cache (requires only buffer C)\n                Polygonise(tridata,triangles,mp);\n#endif\n                      \n            float t = 1000.0; \n            for(int i=0;i<ntriangles;i++) {\n                vec3 tri =triIntersect( ro,rd,triangles[i].p[0],triangles[i].p[1],triangles[i].p[2]);\n                if(tri.x>0.  && tri.x <t) {\n                    t=tri.x;\n                     g_n=-normalize(cross(triangles[i].p[1]-triangles[i].p[0],triangles[i].p[2]-triangles[i].p[0]));\n                     g_uv= tri.yz;\n                 }\n            }\n            if(t< 1000.) return  vec4(ro+rd*t,t);\n        }\n\t} \n    return vec4(tb.x,tb.y,0.,0.);\n}\n\n//--------------------SHANE---------------------\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n//--------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    gFrame=min(iFrame,0);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2  m =  iMouse.x<=0. ? vec2(-0.3): (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y*3.14;\n        \n    vec3 ro = vec3(sin(m.y+.76) * cos(-m.x), sin(m.y+.76) * sin(-m.x), cos(m.y +.76))*15.;\n    vec3 cd = -normalize(ro); \n    vec3 rd = rayDirection(cd ,uv);   \n    vec4 r= trace(ro,rd);\n    \n    \n    if(r.a>0. ){\n            vec3 p =r.xyz, \n                 n = g_n;       \n              vec3 l=normalize(vec3(.6,-.4,1));  //light\n           \n             fragColor.rgb= mix(tex3D(iChannel3, (p)*.25/csz, n).grb,vec3(0.110,0.204,0.055),.4); //grass\n             fragColor.rgb = mix( fragColor.rgb ,vec3(0.188,0.137,0.051),smoothstep(.7,.5,dot(n, normalize(p)))) ;  //dirt            \n             fragColor.rgb*= .9+ .1*smoothstep(0.01,.15,min(min(g_uv.x,g_uv.y),1.-g_uv.x-g_uv.y)); //edges\n              \n             float ambience = 0.25;\n             float diff = max( dot(n, l), 0.0);\n             float spec = 0.;//pow(max( dot( reflect(-l, n), -rd ), 0.0 ), 32.);                               \n             vec4 s= trace(p+n*.005*csz ,l); \n             float shading = step(0., -s.a)*.8 + .2; \n                          \n             fragColor.rgb = fragColor.rgb*(diff + ambience) + vec3(.7, .9, 1.)*spec;            \n             fragColor.rgb *= shading;   \n                            \n             fragColor = vec4(sqrt(clamp(fragColor, 0., 1.)));                   \n    }   \n    else fragColor =mix(vec4(0.4,0.4,0.7,1.0),vec4(.2), (r.y-r.x)/L*1.2); //background  \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// LOOKUP TABLES: 256x2 pixels required\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    if(iFrame>3) discard;\n    else if(U.y<1.&& U.x<256.)\n    {\n       int _edgeTable[256]= int[256](\n        -1   , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, \n        0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, \n        0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, \n        0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, \n        0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, \n        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, \n        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, \n        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, \n        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, \n        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, \n        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, \n        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, \n        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, \n        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, \n        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, \n        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0\n       );\n        Q=vec4(_edgeTable[int(U.x)]);\n   }\n   else if(U.y<2.&& U.x<128.){\n   \n    int  _triTableCompact1[512] = int[512](\n        65535,65535,65535,65535, 62336,65535,65535,65535, 63760,65535,65535,65535, 37761,65304,65535,65535, 64033,65535,65535,65535, \n        4992,65442,65535,65535, 2601,65426,65535,65535, 9090,39562,65528,65535, 62131,65535,65535,65535, 33456,65291,65535,65535, \n        8337,65459,65535,65535, 4785,35257,65531,65535, 45475,65338,65535,65535, 416 ,47272,65530,65535, 12435,43931,65529,65535, \n        43657,65464,65535,65535, 63604,65535,65535,65535, 28724,65347,65535,65535, 35088,65396,65535,65535, 18708,14103,65521,65535,\n        35361,65396,65535,65535, 14147,8512,65530,65535, 39465,18464,65527,65535, 10658,29305,18803,65535, 14152,65323,65535,65535,\n        46923,578 ,65524,65535, 33033,12916,65531,65535, 39796,47540,4754,65535, 12707,34731,65524,65535, 6833,436 ,19316,65535, 39028,\n        47536,12474,65535, 19316,47515,65530,65535, 62553,65535,65535,65535, 1113,65336,65535,65535, 5200,65285,65535,65535, 33880,4947,\n        65525,65535, 39457,65349,65535,65535, 6147,38050,65525,65535, 23077,1060,65522,65535, 13730,21330,33844,65535, 9305,65459,65535,\n        65535, 688 ,38072,65525,65535, 1104,12881,65531,65535, 9490,33413,22603,65535, 43834,22833,65524,65535, 1428,43032,43905,65535,\n        20549,46512,12474,65535, 22597,35496,65531,65535, 22649,65431,65535,65535, 36921,30005,65523,65535, 2160,20849,65527,65535, 13137,\n        65397,65535,65535, 39033,6773,65522,65535, 37402,13573,14160,65535, 33288,22610,9639,65535, 9634,21301,65527,65535, 30103,45976,\n        65522,65535, 38745,10535,46880,65535, 2866,29057,29976,65535, 45355,6001,65525,65535, 34905,6773,45987,65535, 20597,46992,40976,\n        61611, 45227,23088,28800,61557, 30123,65371,65535,65535, 62826,65535,65535,65535, 21376,65386,65535,65535, 20745,65386,65535,65535,\n        4993,42377,65526,65535, 9569,65302,65535,65535, 5473,866  ,65528,65535, 38249,8288,65526,65535, 22677,9512,33334,65535, 43826,65366,\n        65535,65535, 47115,27138,65525,65535, 10512,42419,65526,65535, 5797,47401,47250,65535, 27446,5429,65523,65535, 2944,20571,27473,65535,\n        1715,24675,38149,65535, 26966,39865,65528,65535, 18085,65415,65535,65535, 16436,22071,65530,65535, 20625,18538,65527,65535, 5482,\n        29049,18803,65535, 25110,29717,65528,65535, 21793,866 ,29748,65535, 38728,24656,25093,65535, 31031,9033,26969,63842, 29363,27208,\n        65525,65535, 18085,9255,46880,65535, 18704,12935,27227,65535, 37161,18731,19323,63141, 14152,21339,27473,65535, 23317,363 ,19323,\n        64320, 2384,12374,14006,63304, 26966,29881,39801,65535, 26954,65444,65535,65535, 18084,32937,65523,65535, 41226,17926,65520,65535,\n        33080,26721,41316,65535, 6465,25154,65524,65535, 6147,17042,17961,65535, 17440,65378,65535,65535, 33336,9282,65526,65535, 43338,\n        11078,65523,65535, 8832,38072,27210,65535, 691 ,24673,41316,65535, 24902,33953,45345,61880, 37993,6499,14003,65535, 33208,27393,\n        16785,61766, 14003,24582,65524,65535, 47174,65414,65535,65535, 30375,39080,65530,65535, 880,36986,42858,65535, 5994,29050,2072,\n        65535, 42858,28951,65523,65535, 5665,33158,30345,65535, 10594,30233,14601,63799, 28807,1632,65522,65535, 25143,65319,65535,65535,\n        43826,35462,30345,65535, 9986,37047,42855,63401, 4225,41351,42855,64306, 45355,27249,5985,65535, 34456,6518,14006,63025, 45456,\n        65398,65535,65535, 28807,45920,1712,65535,63159,65535,65535,65535); \n            int id= int(U.x)*4;\n     Q= vec4(_triTableCompact1[id],_triTableCompact1[id+1],_triTableCompact1[id+2],_triTableCompact1[id+3] );\n\n    }\n  else  if(U.y<2.&& U.x<256.){\n  int  _triTableCompact2[512] = int[512](       \n       64359,65535, 65535,65535, 47107,65383,65535,65535, 47376,65383,\n        65535,65535, 35096,31507,65526,65535, 25114,65403,65535,65535, 14881,46720,65527,65535, 8338,46746,65527,65535, 10166,35386,35235,\n        65535, 25383,65394,65535,65535, 30727,9734,65520,65535, 9842,4211,65529,65535, 4705,37224,26504,65535, 42618,12657,65527,65535, \n        5754,33191,32791,65535, 1840,41127,31337,65535, 31335,43146,65529,65535, 46214,65384,65535,65535, 15203,16480,65526,65535, 35688,\n        2404,65521,65535, 38473,14646,25521,65535, 25734,41611,65521,65535, 14881,24752,25611,65535, 18612,8374,39465,65535, 41882,18723,\n        25523,62308, 33576,25636,65522,65535, 16960,65318,65535,65535, 8337,16963,33606,65535, 5265,16932,65526,65535, 33560,18454,6758,\n        65535, 40986,1632,65524,65535, 17252,42627,37635,62362, 25754,65354,65535,65535, 30100,65462,65535,65535, 17280,31577,65526,65535,\n        20741,26372,65531,65535, 34427,21315,20788,65535, 42073,26401,65531,65535, 6070,32930,22851,65535, 23399,9380,8266,65535, 14403,\n        9029,9637,63099, 29479,17702,65529,65535, 1113,24680,30818,65535, 12899,20839,1104,65535, 26662,4728,22600,63569, 42073,29025,29462,\n        65535, 6753,359 ,1927,62553, 18948,12378,31338,64115, 31335,17802,43082,65535, 26006,35739,65529,65535, 2915,20534,22790,65535, \n        2224,4277,46677,65535, 25526,13651,65521,65535, 39457,47541,26040,65535, 944 ,37046,38486,64033, 46475,2149,9637,62752, 25526,\n        41555,13731,65535, 22917,25986,10290,65535, 38489,24582,65522,65535, 6225,25864,10296,63526, 9809,65377,65535,65535, 5681,33702,\n        38486,63128, 40986,22880,1616,65535, 22576,65446,65535,65535, 63066,65535,65535,65535, 31323,65461,65535,65535, 47707,14423,65520,\n        65535, 22453,37306,65520,65535, 42362,35195,4993,65535, 45595,22295,65521,65535, 4992,29042,45685,65535, 38265,2418,31522,65535, \n        29271,38322,33330,62089, 10834,29523,65525,65535, 32808,30757,21157,65535, 20745,13626,10807,65535, 37513,30738,21154,62039,\n        13617,65367,65535,65535, 1920,28951,65525,65535, 37641,13651,65527,65535, 22409,65401,65535,65535, 21637,47754,65528,65535, 21509,\n        42251,955 ,65535, 35088,43172,21675,65535, 42170,15188,5268,62483, 8530,45656,34120,65535, 2880,21563,6955,64277, 1312,45717,34117,\n        62859, 9545,65339,65535,65535, 14930,17189,18485,65535, 21157,9282,65520,65535, 12963,33701,34117,63760, 21157,37186,9362,65535, \n        34120,21301,65521,65535, 5440,65360,65535,65535, 34120,2357,21253,65535, 62793,65535,65535,65535, 18356,43449,65531,65535, 17280,\n        47481,47767,65535, 7073,16715,46192,65535, 13331,41348,46196,62650, 38836,10571,8603,65535, 38009,6523,6955,62336, 46203,16932,\n        65520,65535, 46203,14372,16948,65535, 10898,12951,38007,65535, 38825,10823,1927,63234, 14963,18218,2586,64004, 33441,65351,65535,\n        65535, 16788,6001,65523,65535, 16788,32881,6017,65535, 29444,65332,65535,65535, 63364,65535,65535,65535, 43177,65419,65535,65535,\n        14595,39865,65530,65535, 2576,43146,65531,65535, 47635,65443,65535,65535, 6945,47515,65528,65535, 14595,8633,39721,65535, 35616,\n        65456,65535,65535, 64291,65535,65535,65535, 10290,35496,65529,65535, 681 ,65321,65535,65535, 10290,4264,35352,65535, 62113,65535,\n        65535,65535, 38961,65409,65535,65535, 61840,65535,65535,65535, 63536,65535,65535,65535, 65535,65535,65535,65535\n    );\n       \n     int id= int(U.x)*4;\n     Q= vec4(_triTableCompact2[id-512],_triTableCompact2[id-511],_triTableCompact2[id-510],_triTableCompact2[id-509] );\n\n }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\nconst float L= 30., //cube size\n            N= 60., //number of voxel x side (TOT=N^3)\n            csz=.5*L/N ; \n\nvec3 offset = floor(vec3(0.,0.,-L/2.));\nconst vec2 packedChunkSize= ceil(sqrt(N) * vec2(1.25 ,0.8)); // iResolution.xy/iResolution.yx \nconst float heightLimit = packedChunkSize.x * packedChunkSize.y; //must be > N\n\n//-----------------------------------------\n// VOXEL CACHE FUNCTIONS from fb39ca4\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float o = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - o);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float o = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + o;\n}\n\nfloat calcLoadDist(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\n    vec2 packedChunkSize= packedChunkSize;\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec2 packedChunkSize= packedChunkSize;\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nvec4  getVoxel(vec3 p,sampler2D iChannel,vec3 resolution) {\n    p.z-= offset.z;\n    if(p.z>heightLimit || p.z<0.){return vec4(0.);}  \n    return texelFetch(iChannel, ivec2(voxToTexCoord(p))  , 0); \n    //return texture(iChannel, (floor(voxToTexCoord(p)) + 0.5) /  (floor (resolution.xy)), 0.0);\n\n}\n\n\n//--------------------\n\n//porting of \"Marching Cubes\" algorithm by Paul Bourke (1994)\n//http://paulbourke.net/geometry/polygonise/\n \n//Note on porting: I made code more compact. Also used the usual trick to prevent unrolling in Angle\nint gFrame=0; \n \n struct TRIANGLE {\n   vec3 p[3];\n} ;\n\n\n struct GRIDCELL{\n   vec3 p[8];\n   float val[8];\n} ;\n\n\n//   4-------5\n//  /|      /|\n// 7-------6 |\n// | |     | |\n// | 0-----|-1\n// |/      |/\n// 3-------2\n//\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n\n//lookup tables retrieved from BufferA\n#define edgeTable(i) int(texelFetch(confChannel, ivec2(i,0),0).x)\n#define triTableRow(i) ivec4(texelFetch(confChannel, ivec2(i,1),0))\n#define triTableVal(tt,j) int((tt[j>>2]&(15*(1<<((j&3)*4))))>>((j&3)*4))\n\nconst int  vertexTable[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n   \n/*\n   Linearly interpolate the position where an isosurface cuts\n   an edge between two vertices, each with their own scalar value\n*/\n#define SNAP .0\nfloat  VertexWeight(float isolevel,float valp1, float valp2)\n{\n   \n   float mu = (isolevel - valp1) / (valp2 - valp1);\n   if(mu<SNAP) mu=0.;\n   if(mu>1.-SNAP) mu=1.;\n\n   return mu;\n\n}\n\n//input: isolevel value at 8 cube vertexs and isolevel threshold\n//output: number of triangles (-1= outside) and list of triangles (up to 5 in worst case)\nuvec4  Polygonise(inout GRIDCELL grid,float isolevel,inout TRIANGLE[5] triangles,sampler2D confChannel)\n{\n \n   /*\n      Determine the index into the edge table which\n      tells us which vertices are inside of the surface\n   */\n   int cubeindex = 0;\n   for(int i=gFrame;i<8;i++) if (grid.val[i] < isolevel) cubeindex |= 1<<i;\n\n   /* Cube is entirely in/out of the surface -1=IN, 0=OUT */\n   int e=edgeTable(cubeindex);\n   if ( e<= 0) return uvec4(e);\n\n   /* Find the vertices where the surface intersects the cube */\n   vec3 vertlist[12];\n   float vertW[12];\n\n\n   for(int i=0;i<12;i++)\n   if ((e & (1<<i))>0)  {\n       vertW[i]= VertexWeight(isolevel,grid.val[vertexTable[i*2]], grid.val[vertexTable[i*2+1]]);\n          \n       vertlist[i]= mix( grid.p[vertexTable[i*2]], grid.p[vertexTable[i*2+1]],vertW[i]);\n   }\n   /* Create the triangle */\n   uvec4 tridata=uvec4(0u); //x=number of triangles, yzw= tritable\n   \n   ivec4 ttr=triTableRow(cubeindex); \n   for (int i=gFrame;triTableVal(ttr,i)!=15 && i<15;i+=3) {\n       \n       for(int j=gFrame;j<3;j++)   {\n           uint k =uint(triTableVal(ttr,(i+j)));\n           int idx =(i+j);\n           if(idx<8) tridata.y +=  k*( 1u<<(idx*4));\n           else tridata.z += k*( 1u<<(idx*4-32));\n        \n           tridata.w+=  uint( floor(vertW[k]*4. )  ) \n                        *( 1u<<(idx*2));\n           triangles[tridata.x].p[j] = vertlist[k];\n       }\n      \n      tridata.x++;\n   }\n\n   return uvec4(tridata);\n}\n\n// the following functions are used if CACHE is defined\nuint getTri(uvec4 tridata,int n){\n\n        if(n<8) return (tridata.y & (15u * (1u<<(4*n))))  >>(4*n);\n        else return  ( tridata.z & (15u* (1u<<(4*n-32)))) >>(4*n-32);\n}\n\n// 3 quantized values: .25, .5, .75, \nfloat getMu(uvec4 tridata,int n){\n       uint m= (tridata.w & (3u * (1u<<(2*n))))  >>(2*n);\n       return  float(m)*.25+.125;\n}\n\nvoid  Polygonise(uvec4 tridata,inout TRIANGLE[5] triangles, vec3 mp)\n{\n     for (int i=0;i<5;i++)     {\n         if(getTri(tridata,i*3) ==15u) break;\n         for(int j=0;j<3;j++)   {\n           int idx=i*3+j;\n           uint k =  getTri(tridata,idx) ;\n           vec3 v1= mp+  VertexOffset[vertexTable[k*2u]]*csz;\n           vec3 v2= mp+  VertexOffset[vertexTable[k*2u+1u]]*csz;\n           float mu=  getMu(tridata,idx);\n\n           triangles[i].p[j] = mix( v1 , v2,mu);\n\n       }\n    }\n}\n\n//-----------------------------\n\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// triangle degined by vertices v0, v1 and  v2\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//ISOSURFACE FUNCTION \n#define GYROID\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nfloat map(vec3 p)\n{\n#ifdef GYROID\n    p*=.7*L/N;\n    float time=sin(iTime/ 2.0)*2.5+7.5;  \n    //https://www.shadertoy.com/view/4tVSzR\n    float d0=dot(sin(p),cos(p.yzx));     \n    float d2=length(p)-min(10.,time);\n    float d=smax(-d0,d2,1.);\n    return d;\n#else\n\n    //HyperDodecahedron\n    p = p/15. -vec3(0,0,.5);    \n    float phi=1.618,phi2=phi*phi, phi4=phi2*phi2;\n    float x=p.x,y=p.y,z=p.z;\n    float fn=\n        exp((phi2+1.) *(x*x+y*y+z*z))\n        -exp(pow(phi*x+y,2.))\n        -exp(pow(-phi*x+y,2.))\n        -exp(pow(phi*y+z,2.))\n        -exp(pow(-phi*y+z,2.))\n        -exp(pow(phi*z+x,2.))\n        -exp(pow(-phi*z+x,2.));\n        \n    return fn ;\n    \n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 voxelCoord = texToVoxCoord(floor(fragCoord), offset);    \n    float data =map(voxelCoord);\n    //TODO: make editable\n    fragColor = vec4(data);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// MARCHING CUBES BUFFER (used if CACHE enabled)\n\nGRIDCELL g;\nTRIANGLE[5] triangles;\nuvec4 tridata=uvec4(0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 v = texToVoxCoord(floor(fragCoord), offset); \n       \n    int nv=0;\n    for(int id=0;id<8;id++)\n    {\n\n        g.p[id]=v+  VertexOffset[id];\n        g.val[id]=getVoxel(v+  VertexOffset[id],iChannel1,iChannelResolution[1]).x;\n        if(g.val[id]>0.) nv++;\n    }\n    \n     if(nv==0  || nv==8) tridata= uvec4(0u);\n     else {\n         tridata =Polygonise(g,0.,triangles,iChannel0);\n        \n     }\n             \n    fragColor = uintBitsToFloat(tridata);\n\n}","name":"Buffer C","description":"","type":"buffer"}]}