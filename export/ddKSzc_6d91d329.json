{"ver":"0.1","info":{"id":"ddKSzc","date":"1681410627","viewed":101,"name":"Help Needed Life Simulation","username":"incription","description":"Each buffer pixel has 32x4 = 128 bits, you can store at most 11^2 pixels within each one. In a 1200x675 frame thats 98 million bits being simulated","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["life","buffer","bitwise"],"hasliked":0,"parentid":"cdVXRw","parentname":"Superdense Life"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.y = uv.y;\n    \n    if(iMouse.z > 0.) {\n        //uv /= 32.;\n        uv += ((iMouse.xy) / iResolution.xy - .5);\n    }\n    \n    float zoom = 11. + 10. * tanh(5.*iTime-5.);\n    \n    uv /= zoom;\n    \n    ivec2 duv = ivec2((uv + .5) * iResolution.xy);\n    ivec2 subduv = ivec2((uv + .5) * iResolution.xy * 10.) % subPixelSize;\n    //subduv = ivec2(3, 1);\n    \n    vec4 data = texelFetch(iChannel0, duv, 0);\n    buffer[4] = Load(data);\n    \n    int pix = GetPixel(subduv);\n    \n    int total = 0;\n    for(int y = 0; y < subPixelSize; y++)\n        for(int x = 0; x < subPixelSize; x++) {\n            total += GetPixel(ivec2(x, y));\n    }\n    \n    float filled = float(total) / float(subPixelSize * subPixelSize);\n\n    vec3 c = vec3(float(pix>0));\n    c += .25 * hsv2rgb(vec3(float(GetCoord(subduv).y)/3.,1,1));\n    \n    //Debug\n    //c += vec3(float(GetCoord(subduv+ivec2(1,1)).x == 2),0,0);\n    //c += vec3(0,0,float(GetCoord(subduv).z == 0));\n    \n    c = mix(vec3(filled), c, min(1., max(0., zoom / 4. - 1.)) );\n    \n    fragColor = vec4(vec3(c), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//multiple of 2 only or i kill you (or the compiler does)\n#define subPixelSize 10\n#define ips 1\n\nivec4 buffer[9];\n\n//credit um idk owo\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nivec4 Load(vec4 data) {\n    return floatBitsToInt(data);\n}\n\nvec4 Save(ivec4 data) {\n    return intBitsToFloat(data);\n}\n\nivec3 GetCoord(ivec2 p) {\n\n    //p.x=subPixelSize-p.x;\n    int bufferCoord = 4 + p.x / subPixelSize - (p.y / subPixelSize) * 3;\n    p %= subPixelSize;\n    int subBufferCoord = 2 + int(p.x >= subPixelSize / 2) - 2 * int(p.y >= subPixelSize / 2);\n    //p %= subPixelSize / 2;\n    int subPixelCoord = p.x % (subPixelSize / 2) + (p.y % (subPixelSize / 2)) * subPixelSize / 2;\n    //subPixelCoord = 0;\n    //if(p.y == 1) subPixelCoord = 5;\n    return ivec3(bufferCoord, subBufferCoord, subPixelCoord);\n}\n\nint Shift(int n) {\n    return 1 << (n);\n}\n\nint GetPixel(ivec2 p) {\n    ivec3 loc = GetCoord(p);\n    return (buffer[loc.x][loc.y] >> loc.z) & 1;\n}\n\nbool Simulate(ivec2 p) {\n    int cur = GetPixel(p);\n    int sum = -cur; //offset center cell\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++) {\n            ivec2 pos = p + ivec2(x, y);\n            //ivec3 loc = GetCoord(pos);\n            sum += GetPixel(pos);\n            //sum += 1;\n    }\n    \n    bool result = false;\n    \n    if(cur > 0)\n        result = (sum == 3 || sum == 2);\n    else\n        result = (sum == 3);\n\n    return result;\n}\n\nfloat PatternMask(vec2 Pos) {\n    return mod(Pos.x + mod(Pos.y, 2.0), 2.0);\n}\n\nint PatternMask(ivec2 Pos) {\n    return (Pos.x + (Pos.y % 2)) % 2;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool GetInitPixel(ivec2 pos) {\n    return true;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    \n    ivec4 clear[9];\n    buffer = clear;\n    \n    int ind = 0;\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++) {\n            buffer[ind] = Load(texelFetch(iChannel0, uv + ivec2(x, y), 0));\n    ind++;} ind = 0;\n    \n    ivec4 data = buffer[4]; \n    ivec4 new = ivec4(data);\n    \n    for(int y = 0; y < subPixelSize; y++)\n        for(int x = 0; x < subPixelSize; x++) {\n            ivec2 pos = ivec2(x, y);\n            ivec3 coord = GetCoord(pos);\n            \n            if(Simulate(pos)) {\n                new[coord.y] |= 1 << coord.z; //enable bit\n            } else {\n                new[coord.y] &= ~Shift(coord.z); //disable bit\n            }\n            \n            if(iFrame < 1) {\n                new[coord.y] |= int(rand(vec2(pos + uv * subPixelSize) / iResolution.xy) > .5) << coord.z;\n                //new[coord.y] |= int(GetInitPixel(pos + uv * subPixelSize)) << coord.z;\n            }\n    ind++;}\n        \n    fragColor = Save(new);\n    //if(iFrame < 1) fragColor = Save(ivec4(1));\n}","name":"Buffer A","description":"","type":"buffer"}]}