{"ver":"0.1","info":{"id":"MXd3Wr","date":"1716447461","viewed":87,"name":"Trippy Hyperspace Tunnel","username":"Rahn","description":"bruh","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rainbow","trippy","hyperspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define TAU (2.0 * PI)\n#define SPEED 15.0  // Increased by 50%\n#define RESOLUTION iResolution\n#define TIME iTime  // Use the normal time\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = i.x + i.y * 57.0 + 113.0 * i.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                   mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    return f;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(vec3 pos) {\n    pos.z += TIME * SPEED; // Travel forward\n    pos.xy += vec2(sin(pos.z * 0.1), cos(pos.z * 0.1)) * fbm(pos * 0.1) * 2.0; // Add curves to the tunnel\n    float radius = 3.0 + sin(pos.z * 0.1) * 0.5 + fbm(pos * 0.5) * 0.5;\n    return length(pos.xy) - radius;\n}\n\nvec3 getColor(vec3 p) {\n    float d = fbm(p * 0.5 + TIME * 0.5); // Slow down the pulsating effect\n    float hue = 0.1 + 0.5 * sin(d * 5.0 + TIME * 0.5); // Adjust hue range to avoid yellow and green\n    if (hue > 0.3 && hue < 0.5) hue += 0.2; // Avoid yellow range\n    float sat = 0.8; // Slightly reduce saturation\n    float val = 1.0 - d * 0.6; // Increase range of value to include darker colors\n    return hsv2rgb(vec3(hue, sat, val));\n}\n\nvec3 getElectricColor(vec3 p) {\n    float d = fbm(p * 5.0 + TIME * 5.0); // Slow down the pulsating effect\n    float hue = fract(d + TIME * 0.5); // Slow down the hue shift\n    hue = mod(hue + 0.1, 1.0); // Adjust hue range to avoid yellow and green\n    if (hue > 0.3 && hue < 0.5) hue += 0.2; // Avoid yellow range\n    float sat = 0.8; // Slightly reduce saturation\n    float val = smoothstep(0.4, 0.6, sin(TIME * 5.0 + d * 10.0)) * 0.4; // Adjust value range to include more black\n    return hsv2rgb(vec3(hue, sat, val));\n}\n\nvec3 getLightningColor(vec3 p) {\n    float d = noise(p * 10.0 + TIME * 20.0); // High frequency noise for lightning\n    float hue = fract(d + TIME * 0.5); // Color of the lightning\n    hue = mod(hue + 0.1, 1.0); // Adjust hue range to avoid yellow and green\n    if (hue > 0.3 && hue < 0.5) hue += 0.2; // Avoid yellow range\n    float sat = 0.9; // High saturation for lightning\n    float val = smoothstep(0.7, 0.9, d) * 1.0; // Make the lightning very bright but include some black\n    return hsv2rgb(vec3(hue, sat, val));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / RESOLUTION.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= RESOLUTION.x / RESOLUTION.y;\n\n    float time = TIME * SPEED;\n    vec3 col = vec3(0.0);\n\n    vec3 ro = vec3(0.0, 0.0, -time); // Set ray origin to simulate forward movement\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    float t = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < 100; i++) {\n        float dist = map(p);\n        t += dist;\n        p += dist * rd;\n        if (abs(dist) < 0.001) break;\n    }\n\n    vec3 normal = normalize(vec3(map(p + vec3(0.001, 0.0, 0.0)) - map(p - vec3(0.001, 0.0, 0.0)),\n                                 map(p + vec3(0.0, 0.001, 0.0)) - map(p - vec3(0.0, 0.001, 0.0)),\n                                 map(p + vec3(0.0, 0.0, 0.001)) - map(p - vec3(0.0, 0.0, 0.001))));\n\n    vec3 color = getColor(p);\n    color *= 0.5 + 0.5 * dot(normal, normalize(-rd));\n\n    // Add twisting and morphing effects\n    vec3 posMod = p + vec3(sin(p.z * 0.5), cos(p.z * 0.5), 0.0) * 0.5;\n    vec3 twistColor = getColor(posMod);\n    color = mix(color, twistColor, 0.5);\n\n    // Add electric crackles\n    for (int i = 0; i < 5; i++) {\n        vec3 offset = vec3(hash(float(i)), hash(float(i) + 1.0), hash(float(i) + 2.0));\n        vec3 electricPos = p + offset * 10.0;\n        vec3 electricColor = getElectricColor(electricPos);\n        color += electricColor * 0.025; // Tone down electric effect by 75%\n    }\n\n    // Add lightning crackles\n    for (int i = 0; i < 3; i++) {\n        vec3 offset = vec3(hash(float(i) + 3.0), hash(float(i) + 4.0), hash(float(i) + 5.0));\n        vec3 lightningPos = p + offset * 20.0;\n        vec3 lightningColor = getLightningColor(lightningPos);\n        color += lightningColor * 0.05; // Tone down lightning effect by 75%\n    }\n\n    // Add plasma-like effect\n    vec3 plasmaPos = p + vec3(sin(p.z * 0.1), cos(p.z * 0.1), 0.0) * 2.0;\n    vec3 plasmaColor = getColor(plasmaPos);\n    color = mix(color, plasmaColor, 0.2);\n\n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}