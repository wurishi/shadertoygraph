{"ver":"0.1","info":{"id":"MtBcRG","date":"1509382746","viewed":199,"name":"Martin Birth Compo Recreation","username":"lamogui","description":"Attempting to recreate martin pedro compo for his show birth of la treve collectif, during the paris shader showdown \n#2 (https://www.facebook.com/events/172824569940299/) Unfortunatly I ran out of time during the compo, so this version is not live coded\n","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["compo","recreation","martin","birth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MslSDs","filepath":"https://soundcloud.com/nils_frahm/down-down-1","previewfilepath":"https://soundcloud.com/nils_frahm/down-down-1","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define mmin(v, d, i) (v.x > d ? vec2(d,i) : v)\n#define ID_SPHERE 1.0\n#define ID_LIGHT 2.0\n#define ID_BLACK 3.0\n#define PI 3.14159265\n\nfloat lc;\n\nfloat sphere(vec3 p, vec3 pos, float id)\n{\n  vec3 q = normalize(p - pos);\n  vec2 uv = vec2(atan(q.z, q.x) / (2.0 * PI), acos(q.y) / PI);\n  float d = 0.15 * textureLod(iChannel0, uv + sin(2.0 * PI * id) * iTime * 0.1 + vec2(id * 0.4), 0.0).x;\n  return length(p - pos) - (0.35)* (1.0 + d * 0.15);\n}\n\nfloat cylinder(vec3 p)\n{\n  return length(p.xz) - 0.2 - 0.1 * lc;\n}\n\nmat3 rotateY(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(c, 0.0, -s, \n            0.0, 1.0, 0.0, \n              s, 0.0, c);\n}\n\nmat3 rotateZ(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(c, -s , 0.0, s, c, 0.0 , 0.0 ,0.0 ,1.0);\n}\n\nmat3 rotateX(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(1.0, 0.0 ,0.0,\n              0.0 , c, -s,\n              0.0, s, c);\n}\n\nfloat modA(inout vec2 v, float n, float len)\n{\n  float l = length(v);\n  float an = PI * 2.0 / n; \n  \n  float a = atan(v.y, v.x);\n  float id = floor(a / an);\n  a = mod(a, an) - an * 0.5;\n  //l = mod(l, len) - len * 0.5;\n  v = vec2(cos(a), sin(a)) * l;\n  return id;\n}\n\nvec2 map(vec3 p)\n{\n  float d = 100000.0;\n  for (int i = 0; i < 8; ++i)\n  {\n    int j = i + int(iTime * .1);\n    vec3 q = rotateY(iTime * (0.1 + 0.3 * fract(0.3 + 0.1451 * float(i)))) * p;\n    float id = modA(q.xz, 10.0 + 4.0 * float(i), 4.0);\n    float x = 1.0 + (float(j) - iTime * .1) * .5 + 0.3 * fract(id * 0.534);\n    d = min(sphere(q, vec3(x, sqrt((x - 1.0) * 0.9) - 0.3 + 0.2 * textureLod(iChannel1, vec2(0.75, fract(id * 0.1554)), 0.0).x, 0.0), fract(id * 0.15614 * float(i))), d);\n  }\n  vec2 v = vec2(d, ID_SPHERE);\n  v = mmin(v, cylinder(p), ID_LIGHT);\n  return v;\n}\n\nvec4 rm(vec3 ro, vec3 rd)\n{\n  vec3 p = ro;\n  vec2 d;\n  float id = ID_BLACK;\n  for (int i = 0; i< 64; ++i)\n  {\n    d = map(p);\n    if (abs(d.x) < 0.001)\n    {\n      id = d.y;\n      break;\n    }\n    else if (d.x > 1000.0)\n      break;\n    p += rd * d.x * 0.9;\n  }\n  return vec4(p, id);\n}\n\nvec3 grad(vec3 p)\n{\n  vec2 e = vec2(0.01, 0.0);\n  return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x, map(p + e.yxy).x - map(p - e.yxy).x, map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nfloat f(float a)\n{\n  a *= PI;\n  return pow(abs(cos(a)) + abs(sin(a)), -1.0 / 0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float a = -PI / 2.0;\n  vec3 ro = vec3(3.5 * cos(a), 3.0, -2.0 + 3.5 *sin(a));\n  vec3 rd = vec3(uv, 1.0);\n  //rd = rotateY(-PI / 2.0 + a) * rd;\n  rd = rotateX(-0.2) * rd;\n  rd = rotateZ(0.2) * rd;\n  \n  lc = clamp(1.0-f(.05*iTime) - f(iTime + sin(iTime * 3.0)), 0.0, 1.0);\n  vec4 q = rm(ro, rd);\n  vec3 p = q.xyz;\n  float id = q.w;\n  float d = distance(ro, p);\n  \n  vec3 n = grad(p);\n  \n\n  \n  vec3 color;\n  if (id == ID_LIGHT)\n    color = vec3(0.8 + 0.2 * lc);\n  else if (id == ID_SPHERE)\n  {\n    color = vec3(0.1);\n    color *= n * 0.5 + 0.5;\n    vec3 pp = p;\n    q = rm(p + 0.1 * n, reflect(rd, n));\n    p = q.xyz;\n    id = q.w;\n    n = grad(p);\n    if (id == ID_LIGHT)\n      color =  mix(color, vec3(lc) * exp(-0.2*distance(vec2(0.0), pp.xz)), 0.7);\n    else if (id == ID_SPHERE)\n      color = mix(color, 0.15 * (n * 0.5 + 0.5), 0.3);\n  }\n    \n  if (id != ID_LIGHT)\n    color *= exp(-d * 0.1);\n  color = pow(color, vec3(1.0 / 1.1));\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}