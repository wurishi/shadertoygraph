{"ver":"0.1","info":{"id":"3tXfR8","date":"1597808969","viewed":61,"name":"CharacterRobot Little test","username":"antoinefortin","description":"ddd","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ddd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYMARCH_STEPS = 100\n#define PI 3.14159265359\n\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nfloat sdSphere(vec3 pos, float radius)\n{\n\treturn length(pos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x <d2.x) ? d1 : d2;\n}\n\nfloat sdRobot(\n\tvec3 pos\n)\n{\n    pos.y -= .5;\n    pos.xz = rotate(pos.xz, sin(iTime));\n    vec3 q = pos;\n    \n   \tq.xy = rotate(q.xy, PI / 2.);\n    float wheel = sdTorus(q, vec2(.25, 0.12)); \n    q = pos;\n    float body =  sdBox(q + vec3(0., -.75, .0), vec3(.55, .65,.5));\n    \n   \tq = pos;\n    /*Socket*/\n    float armsL = sdSphere(q + vec3(.5, -1., 0.), .25);\n    float armsR = sdSphere(q + vec3(-.5, -1., 0.), .25);\n   \t/* Arms*/\n    q.xy -= vec2(.75,1.);\n    float fs = iTime * 2.;\n\tq.xy = rotate(q.xy, sin(fs));\n    float armsLineL = sdBox(q, vec3(.35,.015,.05));\n    q = pos;\n    q.xy -= vec2(-0.75,1.);\n    q.xy = rotate(q.xy, cos(fs));\n    float armsLineR = sdBox(q, vec3(.35,.015,.05));\n    \n    // Head\n    q = pos;\n    q.y -= 1.95;\n    float head = sdBox(q, vec3(.35,.45,.35));\n    q.x += .1;\n    q.y -= .10;\n    q.z += .40;\n    float eyesL = sdSphere(q, .075);\n    \n    q.x -= .25;\n    float eyesR = sdSphere(q, .075);\n    \n    \n    q.y += .25;\n    q.x += .1;\n    float mouth = sdBox(q, vec3(.09, .01, .05));\n    q.xy = rotate(q.xy, .5);\n    float mouthL = sdBox(q + vec3(.175,.05,-0.01), vec3(.09, .01, .05));\n     \n    \n    \n    mouth = min(mouth, mouthL );\n    //mouth = min(mouth, min(mouthL, mouthR));\n    head = min(eyesL, min(eyesR, min(mouth,head)));\n\treturn min(wheel, min(armsL,min(armsR,min(body, min(armsLineL, min(armsLineR, head))))));\n}\n\nfloat sdRobot2(\n\tvec3 pos\n)\n{\n    pos.y -= .5;\n    pos.xz = rotate(pos.xz, sin(iTime));\n    vec3 q = pos;\n    \n   \tq.xy = rotate(q.xy, PI / 2.);\n    float wheel = sdTorus(q, vec2(.25, 0.12)); \n    q = pos;\n    float body =  sdBox(q + vec3(0., -.75, .0), vec3(.55, .65,.5));\n    \n   \tq = pos;\n    /*Socket*/\n    float armsL = sdSphere(q + vec3(.5, -1., 0.), .25);\n    float armsR = sdSphere(q + vec3(-.5, -1., 0.), .25);\n   \t/* Arms*/\n    q.xy -= vec2(.75,1.);\n    float fs = iTime * 2.;\n\tq.xy = rotate(q.xy, sin(fs));\n    float armsLineL = sdBox(q, vec3(.35,.015,.05));\n    q = pos;\n    q.xy -= vec2(-0.75,1.);\n    q.xy = rotate(q.xy, cos(fs));\n    float armsLineR = sdBox(q, vec3(.35,.015,.05));\n    \n    // Head\n    q = pos;\n    q.y -= 1.95;\n    float head = sdBox(q, vec3(.35,.45,.35));\n    q.x += .1;\n    q.y -= .10;\n    q.z += .40;\n    float eyesL = sdSphere(q, .075);\n    \n    q.x -= .25;\n    float eyesR = sdSphere(q, .075);\n    \n    \n    q.y += .25;\n    q.x += .1;\n    float mouth = sdBox(q, vec3(.09, .01, .05));\n    q.xy = rotate(q.xy, .5);\n    float mouthL = sdBox(q + vec3(.175,.05,-0.01), vec3(.09, .01, .05));\n     \n    \n    \n    mouth = min(mouth, mouthL );\n    //mouth = min(mouth, min(mouthL, mouthR));\n    head = min(eyesL, min(eyesR, min(mouth,head)));\n\treturn min(wheel, min(armsL,min(armsR,min(body, min(armsLineL, min(armsLineR, head))))));\n}\n\n\nfloat plane(vec3 pos)\n{\t\n    \n    vec3 q = pos;\n    \n\treturn q.y;\n}\n\nvec2 df(vec3 pos)\n{\n    \n    float shape1 = sdRobot(pos);\n\n    float shape4 = sdRobot(pos + vec3(2.5,0., 0.));\n    \n   \tfloat shape5 = sdRobot2(pos + vec3(-2.5,0., 0.));\n    \n\t\n    \n    float shape2 = sdBox(pos + vec3(3.0, 0.0, 0.0), vec3(0.0));\n\tfloat shape3 = \tplane(pos);    \t\t\t\t\n    \n    \n    vec2 res =     vec2(shape1,       1.0 /*Object ID*/);\n    \n    res = opu(res, vec2(shape2,       2.0/*Object ID*/));\n    res = opu(res, vec2(shape3,       3.0/*Object ID*/));  \n    res = opu(res, vec2(shape4,       4.0/*Object ID*/));  \n    res = opu(res, vec2(shape5,       6.0/*Object ID*/));  \n    return res;\n}\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        df(pos + eps.xyy).x - df(pos - eps.xyy).x,\n        df(pos + eps.yxy).x - df(pos - eps.yxy).x,\n        df(pos + eps.yyx).x - df(pos - eps.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n\t\t\n   // the ray origin\n   vec3 pos = vec3(0.0, 2.0, -5.0);\n\t    \n   // the ray direction\n   vec3 dir = normalize(vec3(uv.x, uv.y, 1));    \n   // The default color, if there is no hitpoint\n\n\t    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * (sin(dir.x) *  dir.x + dir.y);\n   for(int i = 0; i < 120; i++)\n   {\t\n       // Get the distance of the ray\n       float d = df(pos).x;\n       float id = df(pos).y;\n\t   // we hit something\n\t   if(d < 0.01)\n\t   {\t\n           \n           vec3 normalWS = computeNormal(pos);\n           // Raw material for now\n\t       col = fract(pos * 12.5);\n           // robot\n           \n           \tvec3 lightPos = vec3(1.0, 1.0, -12.);\n\t\t\tvec3 L = normalize(lightPos - pos);\n           \tvec3 N = computeNormal(pos);\n           \tvec3 C = vec3(0.1 + abs(cos(iTime)), .52, abs(sin(iTime)));\n           \tfloat scalarI = 1.; \n           \tvec3 I = vec3(scalarI);\n           \tcol = vec3(dot(N, L)) * C * I;\n           \n           if(id == 1.0)\n           {\n             \tvec3 col2 = vec3(dot(L, N)) * C * I * 1.;\n\t\t\t\tcol *= col2 * vec3(1., 2.,1.);\n               \n             \n           }\n           // Cube\n           if(id == 2.0)\n           {\n\n           }\n           // Floor\n\t\t   if(id == 3.0)\n           {\n           \t  vec3 ref = reflect(pos, N);\n               col = ref;\n           }\n           \n           if(id == 4.0)\n           {\n\t\t\t\tvec3 col2 = vec3(dot(L, N)) * C * I * 1.;\n\t\t\t\tcol *= sin(col2.y) * vec3(sin(iTime), 2.,1.);\n               \n           }\n           \n\t\t\tif(id == 6.0)\n           {\n\t\t\tcol = sin();\n               \n           }\n           \n           \n\t       break;\n\t   }\n\t   pos += d * dir;\n\t}\n\t    \n\t// Output pixel to screen    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}