{"ver":"0.1","info":{"id":"cdsGzB","date":"1696627559","viewed":35,"name":"Clouds for background","username":"BadBadDog","description":"Just a test","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define heightMap iChannel0\n#define heightMapResolution iChannelResolution[0]\n#define normalStrength 10.0\n#define textureOffset 1.0\n#define pixelToTexelRatio (iResolution.xy/heightMapResolution.xy)\n\n\nvec3 stdNormalMap(in float height) \n{\n    //float height = texture(heightMap, uv).r;\n   vec2 wc = -vec2(dFdx(height), dFdy(height)) * pixelToTexelRatio;\n   return normalize(vec3( wc.x, height, wc.y ));\n   \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.y;\n    st.x *= 5.; // 5 columns for different noises\n    //uv -= .02 * iTime;\n    \n    uv -= 0.5;\n    \n    uv *= 4.0;\n\n    //vec3 col = vec3(0.);\n    \n    float pw = textureLod(iChannel0, -uv * 0.3, 0.).w;\n    \n    float pwmap = textureLod(iChannel1, uv * 0.4 + 0.2*vec2(-iTime*0.01,iTime*0.01), 0.).x;\n\n    vec3 worley1 = textureLod(iChannel0, uv, 0.).yzw;\n    float wfbm = worley1.x * .1 +\n        \t\t  worley1.y * .1 +\n        \t\t  worley1.z * .6; \n\n\n\n\n    \n    \n    \n    vec3 normal = stdNormalMap( wfbm*0.001 + 0.9*(pow(pwmap,5.0)*pwmap*pow(pw,5.0))    );\n    \n    //normal *= normalStrength;\n    //normal += 0.5;\n\n\n    vec3 material = vec3(1.0);\n\n\n    vec3 light = vec3(0.2, 1.0, -0.2);\n    vec3 toEye = normalize(vec3(0.0,11.0,0.0) - vec3(uv.x, 0.0, uv.y));    \n    vec3 lightRef = normalize(reflect(-light, normal)); \n    float spec = pow(dot(lightRef, toEye), 8.0f);  \n    vec3 fcol = 0.6 * material * max(spec, 0.0); \n\n    float a = 0.5;\n    vec3 col = vec3( pow(fcol.x,1.0/a), pow(fcol.x,1.0/a), pow(fcol.x,1.0/a) );\n    \n    \n    \n    col -= (1.0-col) * pow(1.0-pwmap,2.0)*0.2;    \n\n    col += (1.0-col) * pow(pwmap,0.4)*0.5;    \n\n    col += (1.0-col) * pow(1.0-col.x,0.6) * 0.8 * pow(1.0-pwmap,0.5);    \n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**\nThis tab contains all the necessary noise functions required to model a cloud shape.\n*/\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Fbm for Perlin noise based on iq's blog\nfloat perlinfbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * gradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\nThis buffer writes the tileable 3D noise to a texture. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy ;\n    \n    m = vec2(0.0,iTime*0.005);\n\n    vec4 col = vec4(0.);\n    \n    float slices = 12800.; // number of layers of the 3d texture\n    float freq = 4.;\n    \n    float pfbm= mix(1., perlinfbm(vec3(uv, floor(m.y*slices)/slices), 4., 7), .5);\n    pfbm = abs(pfbm * 2. - 1.); // billowy perlin noise\n    \n    col.g += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq);\n    col.b += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq*2.);\n    col.a += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq*4.);\n    col.r += remap(pfbm, 0., 1., col.g, 1.); // perlin-worley\n    \n    \n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"}]}