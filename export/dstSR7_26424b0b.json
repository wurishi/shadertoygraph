{"ver":"0.1","info":{"id":"dstSR7","date":"1680945785","viewed":29,"name":"Demo Idea: metaballs","username":"seven_dc","description":"metaballs and grid plane. this was originally be part of the Demo that never was and the metaballs were taken from this template and impmented into Wake up / Rise Up demo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"WdcBRN","parentname":"red square in a torus"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 40.\n#define SURF_DIST .001\n\n\nmat2 Rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ballDist(vec3 point, vec4 sphere, float preBallDist) {\n    float l1 = length(point-sphere.xyz)-sphere.w;\n    return smin(l1, preBallDist, .6);\n}\n\nfloat GetDistance(vec3 point) {\n\tvec4 sphere = vec4(0, 1., 5., 1);\n    float planeDist = point.y+ mod(iTime*3., 1.)*.05; // 3 times a second       \n    planeDist += smoothstep(.5, 0.01, abs(mod(point.x, 3.)-1.))*.2;\n    planeDist += smoothstep(.5, 0.01, abs(mod(point.z, 3.)-1.))*.2;\n    \n    \n    float rot1 = sin(iTime);\n    float rot2 = cos(iTime);\n    float rot3 = sin(iTime*2.);\n    float rot4 = cos(iTime*3.);\n    \n    float rot5 = sin(iTime*6.);\n    float rot6 = cos(iTime*6.);\n    \n\n    vec3 spoint = vec3(mod(point.x, 7.)-3., point.y, mod(point.z, 7.)-0.);\n    \n\n    vec4 ball1 = vec4(0, 1., 5.+rot1*.5, 1);\n\n    float spd1 = ballDist(spoint, ball1, 9.);\n    float spd2 = ballDist(spoint, vec4(0. + rot1, 2., 5., .4), spd1);  \n    float spd3 = ballDist(spoint, vec4(0. + rot1 * 1.5, 1., 4.5-rot2* 1.5, .2), spd2);\n    float spd4 = ballDist(spoint, vec4(0. + rot3 * 1.5, .5, 4.5-rot2* 1.5, .2), spd3);\n    \n    vec4 ball2 = vec4(.5 + rot4 * .5, 1.+rot1*.5, 4.5-rot4* 2., .5);\n    \n    float spd5 = ballDist(spoint, ball2, spd4);\n    float spd6 = ballDist(spoint, ball2+vec4(rot5, rot6*.5, rot6, -.2), spd5);\n   \n    float spd7 = ballDist(spoint, ball1+vec4(-rot5*2., rot6*.5, -rot2, -.5), spd6);\n    \n    \n    float d = min(spd7, planeDist);\n    \n    for (int i=0; i < 8; i++) {\n        vec4 ball = vec4(0., 2., 5., .1);\n        float bf = length(point-ball.xyz)-ball.w;\n        d = smin(d, bf, .6); \n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int i, steps = MAX_STEPS; \n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  vec2 d = RayMarch(point+normal*.1, direction);\n  if ( d.x < length(lightPos-point)) {\n      dif *= 0.5;      \n  } else {\n      dif -= d.y*.006;\n  }\n  \n  return dif;\n}\n\nvec4 getMetaBalls(vec2 uv, float time) {\n    vec4 col = vec4(0.);\n    vec3 rayOrgin = vec3(0., 2., 4.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    float i,d = 0.;\n    \n    for(i=0.; i<200.; i++) {\n    \tvec3 point = rayOrgin + rayDirection * d;\n        float surfaceDistance = GetDistance(point);\n        d += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(d>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0., 2, 4.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    rayDirection.yz *= Rotate(.3);\n    rayDirection.xz *= Rotate(sin(iTime));\n    \n\n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1, 4, 3);\n    \n    if (d.x < MAX_DIST) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        col = vec3(light);\n        col.r += n.r*.3;\n        col.g += n.r*.1;\n    } else {\n        col.b += d.y*.01;\n        \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}