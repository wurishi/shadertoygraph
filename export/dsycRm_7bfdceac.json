{"ver":"0.1","info":{"id":"dsycRm","date":"1695900761","viewed":50,"name":"Interactable Julia set","username":"carlosroxo1","description":"Use the mouse to drag the fractal around or move with WASD\nZoom in n out using 'E' and 'Q'\nSpacebar resets the zoom\nUse the keyboard arrows to change the coordinates of the point C (it starts at (-1,0))","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","julia","mouse","mandelbrot","complex","keyboard","set","interactable"],"hasliked":0,"parentid":"DsyyRh","parentname":"Interactable Mandelbrot set"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by me :)\n//\n// Figured that a good follow up to the interactable mandelbrot set, would be an interactable julia set\n//\n// I sourced the loadValue and storeValue functions from the Pac-Man game: https://www.shadertoy.com/view/Ms3XWN\n// Full credit to the original creator for these functions.\n//\n// As always, feel free to use any part of the code as needed.\n// If you have suggestions for improving efficiency, readability, or any other aspect, I welcome feedback.\n// Enjoy!\n\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the coordinates for the current pixel\n    vec2 resolution = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);\n    \n    \n    // Load saved values\n    // Load saved values\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec2 offset      = loadValue( txOffset ).xy;\n    vec2 mouseLast   = loadValue( txMouseLast ).xy;\n    float zoom       = loadValue( txZoom ).x;\n    vec2 vecC        = loadValue( txC ).xy;\n    Complex c;\n    c.real = vecC.x;\n    c.imag = vecC.y;\n    \n    \n    // Map pixel coordinates to the Mandelbrot set's complex plane\n    int MAX_ITER = 1024;\n    Complex z;\n    z.real = p.x/zoom - offset.x;\n    z.imag = p.y/zoom - offset.y;\n\n\n    // Check if the current complex number is inside the Mandelbrot set\n    int count = isInsideJulia(z, c, MAX_ITER);\n\n\n    // Map the number of iterations to a color gradient with a log scale\n    vec3 color;\n    if (count == MAX_ITER) {\n        color = vec3(0.0); // Inside the set (black)\n    } else {\n        // Apply a logarithm to the count for a log scale\n        float logCount = log(float(count) + 1.0) / log(float(MAX_ITER) + 1.0);\n        color = vec3(logCount, logCount * logCount, 1.0 - logCount); // Color gradient (change this for different colors)\n    }\n    if (absC(subC(z,c)) < 0.01/zoom){\n        color = vec3(1.0);\n    }\n\n\n    // Output the color\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 txOffset    = ivec2(31, 1);\nconst ivec2 txMouseLast = ivec2(31, 3);\nconst ivec2 txZoom      = ivec2(31, 5);\nconst ivec2 txC         = ivec2(31, 7);\n\n\nstruct Complex {\n    float real;\n    float imag;\n};\n\nComplex vec2Complex(vec2 v){\n    Complex c;\n    c.real = v.x;\n    c.imag = v.y;\n    return c;\n}\n\nComplex addC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\nComplex subC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real - b.real;\n    result.imag = a.imag - b.imag;\n    return result;\n}\n\nComplex multiplyC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\n\nfloat absC(Complex c) {\n    return length(vec2(c.real, c.imag));\n}\n\nint isInsideJulia(Complex z, Complex c, int MAX_ITER) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        z = addC(multiplyC(z, z), c);\n        if (absC(z) > 2.0) {\n            return i; // If |z_copy| > 2, it's not in the Julia set\n        }\n    }\n    return MAX_ITER;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the coordinates for the current pixel\n    vec2 resolution = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);\n    vec4 m = iMouse / iResolution.x;\n        \n    // Load saved values\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec2 offset      = loadValue( txOffset ).xy;\n    vec2 mouseLast   = loadValue( txMouseLast ).xy;\n    float zoom       = loadValue( txZoom ).x;\n    Complex c        = vec2Complex(loadValue( txC ).xy);\n    \n    // Initialize zoom and c values\n    if (zoom==0.0){\n        zoom = 1.0;\n        c.real = -1.0;\n        c.imag = 0.0;\n    }\n    \n    \n    // Capture mouse events\n    if( m.w>0.0 ) // button click\n\t{\n        mouseLast.x = m.x;\n        mouseLast.y = m.y;\n    }\n    else if( m.z>0.0 ) // button is down\n\t{\n        offset.x += (m.x - mouseLast.x) * 2.0*resolution.x/resolution.y / zoom;\n        offset.y += (m.y - mouseLast.y) * 2.0*resolution.x/resolution.y / zoom;\n        // c.real = (m.x - 0.5) * 2.0*resolution.x/resolution.y / zoom - offset.x;\n        // c.imag = (m.y * 2.0*resolution.x/resolution.y - 1.0) / zoom - offset.y;\n        mouseLast.x = m.x;\n        mouseLast.y = m.y;\n\t}\n    \n    // move with keyboard\n    float zoomSpeed = 2.0;\n    float moveSpeed = 3.0;\n    float cSpeed    = 0.1;\n    if( texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x>0.5 )     zoom = zoom*(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_Q, 0), 0 ).x>0.5 )    zoom = zoom/(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x>0.5 ) zoom = 1.0;\n    if( texelFetch( iChannel1, ivec2(KEY_W, 0), 0 ).x>0.5 ) offset.y -= moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_A, 0), 0 ).x>0.5 ) offset.x += moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_S, 0), 0 ).x>0.5 ) offset.y += moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_D, 0), 0 ).x>0.5 ) offset.x -= moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_UP, 0), 0 ).x>0.5 )    c.imag += cSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0 ).x>0.5 )  c.imag -= cSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_LEFT, 0), 0 ).x>0.5 )  c.real -= cSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_RIGHT, 0), 0 ).x>0.5 ) c.real += cSpeed*iTimeDelta/zoom;\n    \n    // Save loaded values\n    fragColor = vec4(0.0);\n    storeValue( txOffset,    vec4(offset, 0.0, 0.0),         fragColor, ifragCoord );\n    storeValue( txMouseLast, vec4(mouseLast, 0.0, 0.0),      fragColor, ifragCoord );\n    storeValue( txZoom,      vec4(zoom, 0.0, 0.0, 0.0),      fragColor, ifragCoord );\n    storeValue( txC,         vec4(c.real, c.imag, 0.0, 0.0), fragColor, ifragCoord );\n}","name":"Buffer A","description":"","type":"buffer"}]}