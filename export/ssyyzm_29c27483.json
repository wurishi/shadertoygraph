{"ver":"0.1","info":{"id":"ssyyzm","date":"1654681477","viewed":118,"name":"ray marching my_practice","username":"tk87","description":"raymarching practice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//GLSL ray marching practice\n\n#define MAX_STEPS 127\n\n#define BACKGROUND 99.0\n#define GROUND_MAT 1.0\n#define SPHERE_MAT 2.0\n#define SPHERE_MAT2 3.0\n#define TORUS_MAT 4.0\n\n#define METAL_ID 2.5\n\n#define MAX_RAY_BOUNCES 3.0\n#define REFLECTIVITY 0.9\n\n//#define LIGHT_DIR normalize(vec3(-1.2, 0.7, 0.5))\n#define LIGHT_DIR normalize(vec3(sin(iTime), 0.7, cos(iTime)))\n#define LIGHT_COLOR vec3(0.9, 0.9, 0.9)\n#define AMBIENT_COLOR vec3(0.03, 0.03, 0.03)\n\n#define SPEC_POWER 16.0\n#define SPEC_COLOR vec3(0.8, 0.80, 0.60)\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat sdPlane(vec3 p, vec3 n, float offset) {\n    //n: must normalized\n    return dot(p, n) + offset;\n}\nfloat sdShere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n    return length(vec2(length(p.xy) - t.x, p.z)) - t.y;\n}\n\nvec2 upU(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1: d2;\n}\n\nvec2 distFunc(vec3 p) {\n    vec2 ret = vec2(1e10, 100.0);\n    ret = upU(ret, vec2(sdPlane(p, vec3(0.0, 1.0, 0.0), -0.1), GROUND_MAT));\n    ret = upU(ret, vec2(sdShere(p - vec3(-0.4, 0.5, 0.0), 0.4), SPHERE_MAT2));\n    ret = upU(ret, vec2(sdShere(p - vec3(0.4, 0.5, 0.0), 0.4), SPHERE_MAT));\n    ret = upU(ret, vec2(sdTorus(p - vec3(1.2, 0.5, 0.0), vec2(0.3, 0.1)), TORUS_MAT));\n    return ret;\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd){\n    vec2 ret = vec2(-1.0, BACKGROUND);\n    \n    float tmin = 0.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for(int i = 0;i < MAX_STEPS && t < tmax;i++){\n        vec2 h = distFunc(ro + rd * t);\n        if(abs(h.x) < (0.001 * t)){ \n            ret = vec2(t, h.y); \n            break;\n        }\n        t += h.x;\n    }\n    return ret;\n\n    // bounding box\n    // insert ground plane\n    // box\n    // insert primitives   \n}\n\nvec3 calcNormal(in vec3 pos){\n    \n    // float eps = 0.0001;\n    // vec2 h = vec2(eps, 0.0);\n    // return normalize(vec3(distFunc(pos + h.xyy).x - distFunc(pos - h.xyy).x,\n    //                        distFunc(pos + h.yxy).x - distFunc(pos - h.yxy).x,\n    //                        distFunc(pos + h.yyx).x - distFunc(pos - h.yyx).x));\n    \n\n    const float eps = 0.0001;\n    const vec2 h = vec2(1, -1);\n    return normalize(\n        h.xyy * distFunc(pos + h.xyy * eps).x\n        + h.yyx * distFunc(pos + h.yyx * eps).x\n        + h.yxy * distFunc(pos + h.yxy * eps).x\n        + h.xxx * distFunc(pos + h.xxx * eps).x\n    );\n\n    // return normalize(vec3(\n    //     distFunc(pos + vec3(eps, 0.0, 0.0)) - distFunc(pos + vec3(-eps, 0.0, 0.0)),\n    //     distFunc(pos + vec3(0.0, eps, 0.0)) - distFunc(pos + vec3(0.0, -eps, 0.0)),\n    //     distFunc(pos + vec3(0.0, 0.0, eps)) - distFunc(pos + vec3(0.0, 0.0, -eps))\n    // ));\n}\n\nvec3 getMaterialColor(float mid) {\n    vec3 col = vec3(0.3, 0.5, 0.8);\n    if(mid <= GROUND_MAT) col = vec3(0.1, 0.1, 0.1);\n    else if(mid <= SPHERE_MAT) col = vec3(0.8, 0.2, 0.0);\n    else if(mid <= SPHERE_MAT2) col = vec3(0.1, 0.4, 0.1);\n    else if(mid <= TORUS_MAT) col = vec3(0.1, 0.1, 0.4);\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy) {\n    vec3 totCol = vec3(0.0);\n\n    float alpha = 1.0;\n\n    for(float i = 0.0;i <= MAX_RAY_BOUNCES;i += 1.0) {\n        vec2 res = rayMarch(ro, rd);\n        float t = res.x;//dist\n        float mid = res.y;//material id\n\n        vec3 col = getMaterialColor(mid);\n\n        if(mid >= BACKGROUND) {\n            totCol += (col - max(rd.y, 0.0) * 0.3) * alpha;\n            break;\n        }\n        \n        vec3 pos = ro + t * rd;\n        vec3 norm = calcNormal(pos);\n        vec3 ref = reflect(rd, norm);\n\n        if(mid <= GROUND_MAT) {\n            vec3 p = floor(pos * 5.0) * 0.5;\n            if(fract(p.x + p.z) >= 0.5) {\n                col = 1.0 - col;\n            }\n        }\n\n        float diffuse = clamp(dot(LIGHT_DIR, norm), 0.0, 1.0);\n        float specular = pow(clamp(dot(ref, LIGHT_DIR), 0.0, 1.0), SPEC_POWER);\n        col *= AMBIENT_COLOR + LIGHT_COLOR * (diffuse + specular * SPEC_COLOR);\n\n        totCol += col * alpha;\n\n        if(mid <= METAL_ID){ \n            break;\n        }\n        \n        ro = pos + ref * 0.001;\n        rd = ref;\n        alpha *= REFLECTIVITY;\n    }\n\n    return  vec3(clamp(totCol, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr){\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    vec3 ta = vec3(0.0, 0.5, -0.6);\n    vec3 ro = ta + vec3(4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 totalColor = vec3(0.0);\n\n    int sample_count = 1;\n    for(int i = 0; i < sample_count; ++i){\n        for(int j = 0; j < sample_count; ++j){\n            vec2 offset = vec2(float(i),float(j)) / float(sample_count) - 0.5;\n            vec2 uv = (2.0 * (fragCoord + offset) - iResolution.xy) / iResolution.y;\n\n            const float fl = 4.5;\n        \n            vec3 rd = ca * normalize(vec3(uv, fl));\n\n            vec2 px = (2.0 * (fragCoord + vec2(1.0,0.0)) - iResolution.xy) / iResolution.y;\n            vec2 py = (2.0 * (fragCoord + vec2(0.0,1.0)) - iResolution.xy) / iResolution.y;\n            vec3 rdx = ca * normalize(vec3(px, fl));\n            vec3 rdy = ca * normalize(vec3(py, fl));\n            \n            vec3 col = render(ro, rd, rdx, rdy);\n\n            //Gamma Correction\n            col = pow(col, vec3(0.4545));\n\n            totalColor += col;\n        }\n    }\n\n    totalColor /= float(sample_count * sample_count);\n\n    fragColor = vec4(totalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}