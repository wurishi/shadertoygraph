{"ver":"0.1","info":{"id":"cdyfWV","date":"1698650947","viewed":46,"name":"Julia Sets e^ia v1.0.0","username":"FishDrowned","description":"See https://en.wikipedia.org/wiki/Julia_set for more info if curious.\nz^2 + c, c = x*e^ia = xcos(a) + xisin(a), x belonging to the set of real numbers, and 0 < a < 2pi.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made via ShaderToy\n// Do what you want with the code\n\n// Special c positions (as listed from wiki):\n    // (1 - sqrt(5))/2 or 1 - φ (golden ratio)\n    // (sqrt(5) - 3)/2 + (sqrt(5) - 1)/2 * i or (φ - 2) + (φ - 1)i\n    // 0.285 + 0i\n    // 0.285 + 0.01i\n    // 0.45 + 0.1428i\n    // −0.70176 − 0.3842i\n    // −0.835 − 0.2321i\n    // −0.8 + 0.156i\n    // −0.7269 + 0.1889i\n    // 0.8i\n\n#define PI 3.1415926538\n#define phi (1.0 + sqrt(5.0))/2.0\n\n// Constants\n\nbool COLORBAND = false;\nfloat BRANCH_DISTANCE = PI / 4.0;\nfloat SPEED = .5;\nfloat RADIUS = 15.0;\nfloat ITERATIONS = 1000.0;\nint RESX = 1280;\nint RESY = 720;\n\n// COLOR\nvec3 basic = vec3(.0, .1, .2);\nvec3 white = vec3(.0);\n\nvec3 color = vec3(.0, .1, .2);\n\nfloat COLORFULL = 10.0;\nvec3 COLORFOCUS = vec3(0.5);\nvec3 BRIGHTNESS = vec3(.5);\nvec3 HUE = vec3(1.0);\n\nvec2 zoomPosition = vec2(.65, .45);\n\n\n// Functions\n\nfloat frac(float f){\n    return f - floor(f);\n}\n\n// COLOR FUNCTIONS\nvec3 mandelColor(float iteration){float t = frac(iteration/float(ITERATIONS) * float(COLORFULL) + .5);return (iteration != float(ITERATIONS))? (BRIGHTNESS+COLORFOCUS*cos(2.0*PI*(HUE*t+color)))*1.3 : vec3(0.0);}\n\n\n// TODO: Add more color options\n\n// Julia\n// z_n = z^2 + x * e^ia\n// Using Eulers, e^ix = cos(x) + i * sin(x)\n    // x * e^ia = x * (cosa + isina)\nfloat euJuliaSet(vec2 z_0, float i_m, float a) {\n    z_0 = 2.5 * z_0 - vec2(0.2, 0.0);\n    vec2 eu = BRANCH_DISTANCE * vec2(cos(a), -sin(a));\n    // ADD A C POSITION HERE BY JUST REDEFINING eu\n    \n    vec2 z_n = z_0;\n    float i_z = 0.0;\n    float m_z = dot(z_n, z_n);\n    \n    while(i_z < ITERATIONS && m_z < RADIUS){\n        z_n = vec2(pow(z_n.x, 2.0) - pow(z_n.y, 2.0)\n                    , 2.0 * z_n.x * z_n.y) + eu;\n        i_z += 1.0;\n        m_z = dot(z_n, z_n);\n    }\n    \n    // Ending ifs\n    if(i_z == float(ITERATIONS)){\n        return float(ITERATIONS);\n    }\n    \n    if(COLORBAND){\n        return i_z;\n    }\n    \n    return float(i_z + 1.0 - (log(log(m_z))/log(2.0)));\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float a = SPEED * iTime;\n    float iterations = euJuliaSet(uv, float(ITERATIONS), a);\n    \n    vec3 color = mandelColor(iterations); // DEFAULT\n    //vec3 color = blackWhite(iterations, true, false);  // BLACK AND WHITE (WHITE/BLACK CENTER, REVERSE OR NORMAL)\n    //vec3 color = redScale(iterations);      // RED\n    //vec3 color = greenScale(iterations);    // GREEN\n    //vec3 color = blueScale(iterations);     // BLUE (DARK)\n    //vec3 color = blueScale(iterations) + greenScale(iterations); // CYAN\n    //vec3 color = redScale(iterations) + blueScale(iterations); // MAGENTA\n\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}