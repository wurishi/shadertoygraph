{"ver":"0.1","info":{"id":"l3dXRX","date":"1719365880","viewed":21,"name":"ball+plane+ellipse","username":"sophytoeat","description":"None","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ball","plane","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0; }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(0.0, 4.0, 3.0); }\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 2.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\nvec3 sphereCenter = vec3(2.0, 0.0, 0.0);\nfloat sphereRadius = 1.0;\n\nvec3 planeNormal = vec3(0.0, 1.0, 0.0);\nfloat planeDistance = -1.0; // 平面はy = -1.0\n\nvec3 ellipsoidCenter = vec3(-2.0, 1.0, 1.0);\nvec3 ellipsoidRadii = vec3(1.0, 1.0, 1.0); // 楕円の各軸の半径\n\n// 正規直交基底を計算する関数の例\nvoid creatnormalize(vec3 from, vec3 to, vec3 up, out vec3 u, out vec3 v, out vec3 w, out vec3 e)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\n// ピクセル座標をカメラ座標系の座標で表現\nvec3 convertCamera(vec2 pixelCoordinate)\n{\n    float filmWidth = FilmWidth();\n    float filmHeight = FilmHeight();\n    float filmDistance = FilmDistance();\n\n    float x = filmWidth - 2.0 * ((pixelCoordinate.x + 0.5) / iResolution.x) * filmWidth;\n    float y = filmHeight - 2.0 * ((pixelCoordinate.y + 0.5) / iResolution.y) * filmHeight;\n    float z = filmDistance;\n\n    return vec3(x, y, z);\n}\n\n// カメラレイを生成する\nRay generateCameraRay(vec2 pixelCoordinate)\n{\n    vec3 cameraPos = CameraFrom();\n    vec3 targetPos = CameraTo();\n    vec3 upDir = CameraUp();\n\n    vec3 u, v, w, e;\n    creatnormalize(cameraPos, targetPos, upDir, u, v, w, e);\n\n    vec3 camera_pixel = convertCamera(pixelCoordinate);\n    vec3 world_pixel = camera_pixel.x * u + camera_pixel.y * v + camera_pixel.z * w;\n\n    Ray ray;\n    ray.org = e;\n    ray.dir = normalize(e - world_pixel);\n    return ray;\n}\n\n// レイと球の交差判定を行うプログラム\nbool intersectToSphere(vec3 center, float radius, Ray ray, out Hit hit)\n{\n    vec3 oc = ray.org - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(oc, ray.dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discri = b * b - 4.0 * a * c;\n\n    if (discri < 0.0) return false;\n\n    float t1 = (-b - sqrt(discri)) / (2.0 * a);\n    float t2 = (-b + sqrt(discri)) / (2.0 * a);\n\n    if (t1 > 0.0 && t1 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t1;\n        hit.normal = normalize((ray.org + t1 * ray.dir) - center);\n        return true;\n    }\n\n    if (t2 > 0.0 && t2 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t2;\n        hit.normal = normalize((ray.org + t2 * ray.dir) - center);\n        return true;\n    }\n\n    return false;\n}\n\n// レイと平面の交差判定を行うプログラム\nbool intersectToPlane(vec3 planeNormal, float planeDistance, Ray ray, out Hit hit)\n{\n    float denom = dot(planeNormal, ray.dir);\n    if (-1.0 < denom && denom < 1.0)\n    {\n        float t = (planeDistance - dot(planeNormal, ray.org)) / denom;\n        if (t >= 0.0 && t < hit.distanceToHitpoint)\n        {\n            hit.distanceToHitpoint = t;\n            hit.normal = planeNormal;\n            return true;\n        }\n    }\n    return false;\n}\n\n// レイと楕円の交差判定を行うプログラム\nbool intersectToEllipsoid(vec3 center, vec3 radii, Ray ray, out Hit hit)\n{\n    vec3 oc = ray.org - center;\n    vec3 dir = ray.dir / radii;\n    vec3 ocScaled = oc / radii;\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(ocScaled, dir);\n    float c = dot(ocScaled, ocScaled) - 1.0;\n    float discri = b * b - 4.0 * a * c;\n\n    if (discri < 0.0) return false;\n\n    float t1 = (-b - sqrt(discri)) / (2.0 * a);\n    float t2 = (-b + sqrt(discri)) / (2.0 * a);\n\n    if (t1 > 0.0 && t1 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t1;\n        hit.normal = normalize((ray.org + t1 * ray.dir - center) / radii);\n        return true;\n    }\n\n    if (t2 > 0.0 && t2 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t2;\n        hit.normal = normalize((ray.org + t2 * ray.dir - center) / radii);\n        return true;\n    }\n\n    return false;\n}\n\n// レイの交点から光源への影のレイを生成し、そのレイが球や楕円と交差するかをチェック\nbool shadowRay(vec3 hitPoint, vec3 lightPos)\n{\n    Ray shadowRay;\n    shadowRay.org = hitPoint;\n    shadowRay.dir = normalize(lightPos - hitPoint);\n\n    Hit shadowHit;\n    shadowHit.distanceToHitpoint = length(lightPos - hitPoint);\n\n    // 球との交差判定\n    if (intersectToSphere(sphereCenter, sphereRadius, shadowRay, shadowHit))\n    {\n        return true;\n    }\n\n    // 楕円との交差判定\n    if (intersectToEllipsoid(ellipsoidCenter, ellipsoidRadii, shadowRay, shadowHit))\n    {\n        return true;\n    }\n\n    return false;\n}\n\n// 球と平面と楕円の交差判定を行う\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    // 球との交差判定\n    bool hitSphere = intersectToSphere(sphereCenter, sphereRadius, ray, hit);\n\n    // 平面との交差判定\n    bool hitPlane = intersectToPlane(planeNormal, planeDistance, ray, hit);\n\n    // 楕円との交差判定\n    bool hitEllipsoid = intersectToEllipsoid(ellipsoidCenter, ellipsoidRadii, ray, hit);\n\n    return hitSphere || hitPlane || hitEllipsoid;\n}\n\n// 光源位置からの光の方向を計算し、影の有無をチェックします\nvec3 shade(Ray ray, Hit hit)\n{\n    vec3 lightPos = vec3(1.0, 8.0, -1.0);\n    vec3 lightDir = normalize(lightPos - (ray.org + hit.distanceToHitpoint * ray.dir));\n\n    // 影の有無をチェック\n    vec3 hitPoint = ray.org + hit.distanceToHitpoint * ray.dir;\n    vec3 offsetPoint = hitPoint + hit.normal * 1e-4; // 表面の模様発生防止のために影のレイの始点をオブジェクトの表面から少しだけ離す\n    bool inShadow = shadowRay(offsetPoint, lightPos);\n\n    float diffuse = max(dot(hit.normal, lightDir), 0.0);\n    if (inShadow)\n    {\n        diffuse *= 0.2; // 影の度合いを計算\n    }\n\n    return vec3(diffuse);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n\n    Hit hit;\n    if (intersect(ray, hit))\n    {\n        fragColor = vec4(shade(ray, hit), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}