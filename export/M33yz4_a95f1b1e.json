{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float pi = 3.1415927;\n\nfloat plane(vec3 position, vec3 planeNormal, float planeDistance) {\n    float d = dot(position, planeNormal) + planeDistance;\n    return d / dot(planeNormal, sign(planeNormal));\n}\n\nfloat box(vec3 position, vec3 halfSize) {\n    position = abs(position) - halfSize;\n    return max(max(position.x, position.y), position.z);\n}\n\nfloat sphere(vec3 position, float radius) {\n    position = abs(position);\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nfloat ellipsoid(vec3 position, vec3 radius) {\n    position = abs(position);\n    float d = max(max(abs(position.x - radius.x), position.y), position.z);\n    d = min(d, max(max(position.x, abs(position.y - radius.y)), position.z));\n    d = min(d, max(max(position.x, position.y), abs(position.z - radius.z)));\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.yz * radius.yz));\n        float b = dot(vec2(1.0), position.yz / (radius.yz * radius.yz));\n        float c = dot(vec2(1.0), (position.yz * position.yz) / (radius.yz * radius.yz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xz * radius.xz));\n        float b = dot(vec2(1.0), position.xz / (radius.xz * radius.xz));\n        float c = dot(vec2(1.0), (position.xz * position.xz) / (radius.xz * radius.xz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xy * radius.xy));\n        float b = dot(vec2(1.0), position.xy / (radius.xy * radius.xy));\n        float c = dot(vec2(1.0), (position.xy * position.xy) / (radius.xy * radius.xy)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float a = dot(vec3(1.0), 1.0 / (radius * radius));\n    float b = dot(vec3(1.0), position / (radius * radius));\n    float c = dot(vec3(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(d, t);\n    }\n    return d;\n}\n\nfloat cylinder(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    float d = max(position.x - radius, position.z);\n    d = min(d, max(position.x, position.z - radius));\n    float b = dot(vec2(1.0), position.xz);\n    float c = dot(position.xz, position.xz) - (radius * radius);\n    float discriminant = b * b - 2.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 2.0;\n        d = min(d, t);\n    }\n    d = max(d, position.y - halfHeight);\n    return d;\n}\n\nfloat capsule(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    return d;\n}\n\nmat3 rotationAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nvec4 sdf(vec3 position) {\n    float material = 0.0;\n    float d = plane(position, vec3(0.0, 1.0, 0.0), 0.0);\n    float d1 = box(position - vec3(-4.0, 0.5, 0.0), vec3(0.5, 0.5, 0.5));\n    if (d1 < d) {\n        material = 1.0;\n        d = d1;\n    }\n    float d2 = cylinder(position - vec3(-2.0, 0.5, 0.0), 0.5, 0.5);\n    if (d2 < d) {\n        material = 2.0;\n        d = d2;\n    }\n    float d3 = capsule(position - vec3(0.0, 0.6, 0.0), 0.3, 0.6);\n    if (d3 < d) {\n        material = 3.0;\n        d = d3;\n    }\n    float d4 = sphere(position - vec3(2.0, 0.5,  0.0), 0.5);\n    if (d4 < d) {\n        material = 4.0;\n        d = d4;\n    }\n    float d5 = ellipsoid(position - vec3(4.0, 0.5, 0.0), vec3(0.75, 0.5, 0.5));\n    if (d5 < d) {\n        material = 5.0;\n        d = d5;\n    }\n    return vec4(d, material, 0.0, 0.0);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)).x - sdf(position + vec3(-epsilon, 0, 0)).x,\n        sdf(position + vec3(0, epsilon, 0)).x - sdf(position + vec3(0, -epsilon, 0)).x,\n        sdf(position + vec3(0, 0, epsilon)).x - sdf(position + vec3(0, 0, -epsilon).x)\n    );\n    return normalize(gradient);\n}\n\nfloat testVisibility(vec3 rayOrigin, vec3 rayDirection, float threshold) {\n    int stepCount = 64;\n    float t = 0.0;\n    float maximumDistance = 10.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition).x;\n        if (d < threshold) {\n            return 0.0;\n        }\n        t += d + threshold;\n    }\n    return 1.0;\n}\n\nvec4 raycast(vec3 rayOrigin, vec3 rayDirection) {\n    vec4 hitResult = vec4(0.0, 0.0, 0.0, 0.0);\n    int stepCount = 256;\n    float maximumDistance = 100.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        vec4 result = sdf(currentPosition);\n        if (result.x < 0.001 * max(t, 1.0)) {\n            hitResult = vec4(t, result.y, 0.0, 0.0);\n            break;\n        }\n        t += result.x;\n    }\n   \n    return hitResult;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float yaw = sin((iTime - 10.0) * 0.2);\n    float pitch = 0.05;\n    if (iMouse.z > 0.0) {\n        float mouseSensitivity = 0.01;\n        vec2 delta = iMouse.xy - abs(iMouse.zw);\n        pitch = clamp(pitch + -delta.y * mouseSensitivity, 0.5 * pi, 0.0);\n        yaw = yaw + delta.x * mouseSensitivity;\n    }\n    mat3 orbitRotation = rotationAxisAngle(vec3(0.0, 1.0, 0.0), yaw);\n    orbitRotation *= rotationAxisAngle(vec3(1.0, 0.0, 0.0), pitch);\n\tvec3 cameraPosition = vec3(0.0, 0.5, 0.0) + orbitRotation * vec3(0.0, 0.0, -9.5);\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = orbitRotation * normalize(vec3(uv, 2.5));\n    vec3 color = mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, 2.0 * rayDirection.y + 0.6);\n    vec4 hitResult = raycast(cameraPosition, rayDirection);\n    float t = hitResult.x;\n    float material = hitResult.y;\n    if (t > 0.0) {\n        vec3 position = cameraPosition + rayDirection * t;\n        vec3 n = normal(position);\n        vec3 lightDirection = normalize(vec3(-0.5, 0.8, -0.2));\n        float visibility = testVisibility(position + n * 0.005, lightDirection, 0.001);\n        vec3 baseColor;\n        if (material == 0.0) {\n            float checkerboard = mod(floor(2.0 * position.z) + floor(2.0 * position.x), 2.0);\n            baseColor = vec3(0.2 + 0.1 * checkerboard);\n        } else {\n            baseColor = 0.2 + 0.2 * cos(2.0 * pi * (vec3(1.0, 1.0, 1.0) * (material / 6.0) + vec3(0.0, 1.0 / 3.0, 2.0 / 3.0)));\n        }\n        float lightAngle = max(dot(lightDirection, n), 0.0);\n        vec3 halfwayDirection = normalize(lightDirection + -rayDirection);\n        float halfwayAngle = max(dot(halfwayDirection, n), 0.0);        \n        // diffuse\n        color = 2.0 * vec3(1.0, 0.85, 0.55) * lightAngle * visibility * baseColor;\n        // specular\n\t\tcolor += 1.0 * vec3(1.0, 0.85, 0.55) * pow(halfwayAngle, 16.0) * lightAngle * visibility * baseColor;\n        // ambient\n        color += 0.5 * vec3(0.25, 0.5, 1.0) * ((n.y + 1.0) * 0.5) * baseColor; // sky\n        color += 0.5 * vec3(0.25, 0.25, 0.25) * clamp(dot(n, normalize(vec3(-lightDirection.x, 0.0, -lightDirection.z))), 0.0, 1.0) * clamp(1.0 - position.y, 0.0, 1.0) * baseColor; // back\n        // fog\n        color = mix(color, mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, 0.55), 1.0 - exp(-0.00005 * t * t * t));\n    }\n    // gamma\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"M33yz4","date":"1734784375","viewed":35,"name":"Lab5 3d geometric shapes","username":"j200410","description":"geometric","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["task"],"hasliked":0,"parentid":"","parentname":""}}