{"ver":"0.1","info":{"id":"tsfSzN","date":"1550718598","viewed":122,"name":"Light Bot","username":"cbrpnk","description":"Everyday","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_0 0.\n#define MAT_1 1.\n\nvec2 add(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat box(vec3 p, vec3 d)\n{\n    p = abs(p) - d;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat cap(vec3 p, float r, float l)\n{\n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdfHead(vec3 p)\n{\n    p = mod(p+vec3(3.), 6.)-vec3(3.);\n    float speed = iTime * .1 * sin(iTime*.1);\n    p.y += sin(iTime*3.)*.1-.5;\n    vec2 head = vec2(box(p, vec3(.8, .5, .5)), MAT_0);\n    float mouthHole = cap(p.yxz-vec3(-.5, 0., .5), .2, .05);\n    \n    return max(head.x, -mouthHole);\n}\n\nfloat sdfEyes(vec3 p)\n{\n    p = mod(p+vec3(3.), 6.)-vec3(3.);\n    p.y += sin(iTime*3.)*.1-.5;\n    p.x = abs(p.x);\n    return cap(p-vec3(.4, 0., .4), .2, .1);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 head = vec2(sdfHead(p), MAT_0);\n    vec2 eyes = vec2(sdfEyes(p), MAT_1);\n    \n    return add(head, eyes);\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    vec2 t = vec2(0);\n    for(int i=0; i<128; ++i) {\n    \tvec2 d = map(ro+rd*t.x);\n        if(d.x < .0001) break;\n        t = vec2(t.x+d.x, d.y);\n    }\n    return t;\n}\n\nfloat glow(vec3 ro, vec3 rd)\n{\n    float t = 1000.;\n    for(float s=0.; s<3.; s+=.1) {\n    \tfloat d = sdfEyes(ro+rd*s);\n        t = min(t, d);\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy).x - map(p-eps.xyy).x,\n        map(p+eps.yxy).x - map(p-eps.yxy).x,\n        map(p+eps.yyx).x - map(p-eps.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n\n    vec3 cam = vec3(0, 0.5, 2.);\n    vec3 dir = normalize(vec3(uv, -1.));\n    cam.xz *= rot(sin(iTime)*.5);\n    cam.yz *= rot(sin(iTime)*.5);\n    dir.xz *= rot(sin(iTime)*.5);\n    dir.yz *= rot(sin(iTime)*.5);\n    \n    vec2 res = march(cam, dir);\n    vec3 p = cam+dir*res.x;\n\tvec3 col = vec3(.01);\n    \n    if(res.x < 100.) {\n        vec3 normal = getNormal(p);\n        float light1 = max(0., dot(normal, vec3(1.)));\n        float light2 = max(0., dot(normal, vec3(-1., -1., 1.)));\n        if(res.y == MAT_0) {\n    \t\tcol = vec3(.1, .1, .2) * light1;\n            col += vec3(.2, .1, .1) * light2;\n        } else if(res.y == MAT_1) {\n        \tcol = vec3(.8, .6, .6);\n            col = (res.x>5.) ? col.bgr*.1 : col.rgb;\n        }\n    }\n    col *= vec3(2./pow(res.x, 1.5));\n    float g = 1.-clamp(glow(cam, dir), 0., 1.);\n    col += clamp(.001*vec3(.8, .1, .1)+pow(g, 3.), 0., 1.) * vec3(1., .6, .6);\n    // Output to screen\n    col *= 1.-length(uv)*.3;\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}