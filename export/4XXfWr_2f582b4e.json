{"ver":"0.1","info":{"id":"4XXfWr","date":"1728319704","viewed":12,"name":"retro loading screen","username":"secondthumb","description":"retro loading screen","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define the cloud texture noise function (simple gradient noise)\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// Smooth cloud-like noise function\nfloat cloudNoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0 - 2.0*f);\n    \n    float n = mix(mix(mix(noise(i + vec3(0.0, 0.0, 0.0)),\n                          noise(i + vec3(1.0, 0.0, 0.0)), f.x),\n                      mix(noise(i + vec3(0.0, 1.0, 0.0)),\n                          noise(i + vec3(1.0, 1.0, 0.0)), f.x), f.y),\n                  mix(mix(noise(i + vec3(0.0, 0.0, 1.0)),\n                          noise(i + vec3(1.0, 0.0, 1.0)), f.x),\n                      mix(noise(i + vec3(0.0, 1.0, 1.0)),\n                          noise(i + vec3(1.0, 1.0, 1.0)), f.x), f.y), f.z);\n    \n    return n;\n}\n\n// Main cloud partitioning and float-off function\nvec3 cloudCube(vec3 p, float time) {\n    // Define the cube's dimensions\n    float cubeSize = 1.5;\n    vec3 cubeCenter = vec3(0.0, 0.5, 0.0); // Adjust cube center\n    \n    // Adjust cube boundaries based on position and time\n    vec3 cubePos = mod(p + time, cubeSize) - 0.5 * cubeSize;\n    \n    // Determine which parts of the cloud \"break off\"\n    float breakOff = smoothstep(0.1, 0.5, sin(time + length(cubePos.xy)) + cos(time + length(cubePos.zx)));\n    \n    // Cloud density based on noise and cube structure\n    float cloudDensity = cloudNoise(cubePos * 2.0);\n    float alpha = smoothstep(0.4, 0.6, cloudDensity);\n    \n    // Use breakOff to create the float-off effect\n    vec3 floatDir = vec3(sin(time * 1.2), cos(time * 1.3), sin(time * 1.1));\n    vec3 offset = breakOff * floatDir * 0.5;\n    \n    return vec3(alpha) + offset;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0; // Normalize coordinates\n    \n    // Camera setup\n    vec3 rayOrigin = vec3(0.0, 0.0, 3.0); // Camera position\n    vec3 rayDir = normalize(vec3(uv, -1.5)); // Ray direction\n    \n    float time = iTime * 0.5;\n    \n    // Position in 3D space\n    vec3 p = rayOrigin + rayDir * 2.0;\n    \n    // Cloud cube calculation\n    vec3 cloud = cloudCube(p, time);\n    \n    // Background (blue sky)\n    vec3 sky = vec3(0.5, 0.7, 1.0);\n    \n    // Composite cloud and sky\n    fragColor = vec4(mix(sky, vec3(1.0), cloud.x), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}