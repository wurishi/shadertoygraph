{"ver":"0.1","info":{"id":"ss23DR","date":"1617450469","viewed":314,"name":"Noise generation","username":"grevel","description":"my attempt on noise generation\n\npixel noise, smooth noise and two variations of rough noise (try playing with depth and roughness)\n\nclick and grab dividing cross","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","pixel","smooth","rough"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nuint seed1 = uint(0);\nfloat r()  // random float\n{\n    return float(Hash(seed1)) / 4294967295.0;\n    seed1 += uint(1);\n}\n\nuint seed2 = uint(0);\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r();\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\n\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\n\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\n\nfloat roughNoise1(vec2 uv, int depth, float roughness)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(), 5.754*r()); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness)\n{\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(), 5.754*r()); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed1 = uint(iTime);\n    seed2 = uint(iTime);\n\n    vec2 uv = fragCoord/iResolution.xy-vec2(.5);\n    uv.x /= iResolution.y/iResolution.x;\n\n    vec2 mUV = iMouse.xy/iResolution.xy-vec2(.5);\n    mUV.x /= iResolution.y/iResolution.x;\n    if(iMouse.xy == vec2(0.)) mUV = vec2(0.);\n\n    vec3 col = vec3(.5);\n    \n    float scale = 10.;\n    int depth = 5;\n    float roughness = .6;\n    \n    vec2 uv1 = uv;\n    vec2 uv2 = uv+vec2(-1., 2.);\n    vec2 uv3 = uv+vec2(3., -4.);\n    \n         if(uv.x<=mUV.x && uv.y>=mUV.y) col = vec3(pixelNoise(uv1*scale),                    pixelNoise(uv2*scale),                    pixelNoise(uv3*scale));\n    else if(uv.x>=mUV.x && uv.y>=mUV.y) col = vec3(smoothNoise(uv1*scale),                   smoothNoise(uv2*scale),                   smoothNoise(uv3*scale));\n    else if(uv.x<=mUV.x && uv.y<=mUV.y) col = vec3(roughNoise1(uv1*scale, depth, roughness), roughNoise1(uv2*scale, depth, roughness), roughNoise1(uv3*scale, depth, roughness));\n    else if(uv.x>=mUV.x && uv.y<=mUV.y) col = vec3(roughNoise2(uv1*scale, depth, roughness), roughNoise2(uv2*scale, depth, roughness), roughNoise2(uv3*scale, depth, roughness));\nfragColor = vec4(col.xxx, 1.0);\n    if(fract(iTime/6.) < .5) fragColor = vec4(col,1.0);\n    else fragColor = vec4(col.xxx, 1.0);\n}","name":"Image","description":"","type":"image"}]}