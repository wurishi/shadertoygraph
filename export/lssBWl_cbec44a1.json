{"ver":"0.1","info":{"id":"lssBWl","date":"1499262378","viewed":185,"name":"Checkerboard texture test","username":"yumcyawiz","description":"checkerboard texture test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nstruct Obj {\n    int objType;\n    float d;\n};\nObj opU(Obj obj1, Obj obj2) {\n    if(obj1.d < obj2.d) {\n        return obj1;\n    }\n    else {\n        return obj2;\n    }\n}\n\n\nObj df(vec3 p) {\n    Obj obj1 = Obj(1, sdSphere(p, 1.0));\n    Obj obj2 = Obj(2, sdBox(p + vec3(0, -1, 0), vec3(5.0, 0.01, 5.0)));\n    Obj obj3 = Obj(1, sdSphere(p + vec3(2, -0.5, 0), 0.5));\n    Obj obj4 = Obj(1, sdSphere(p + vec3(-2, -0.5, 0), 0.5));\n    Obj obj = opU(obj1, obj2);\n    obj = opU(obj, obj3);\n    obj = opU(obj, obj4);\n    return obj;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        df(p + vec3(eps, 0, 0)).d - df(p - vec3(eps, 0, 0)).d,\n        df(p + vec3(0, eps, 0)).d - df(p - vec3(0, eps, 0)).d,\n        df(p + vec3(0, 0, eps)).d - df(p - vec3(0, 0, eps)).d\n        ));\n}\n\n\nstruct Ray {\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n    bool hit;\n    float minDist;\n    Obj hitObj;\n    vec3 rayDir;\n};\nconst int maxStep = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    float t = 0.0;\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float minDist = 10000.0;\n    Obj hitObj = Obj(0, 0.0);\n    \n    for(int i = 0; i < maxStep; i++) {\n        vec3 p = from + t*rayDir;\n        Obj obj = df(p);\n        if(obj.d < minDist) {\n            minDist = obj.d;\n        }\n        if(obj.d < 0.01) {\n            p -= 0.01*rayDir;\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            hitObj = obj;\n            break;\n        }\n        t += obj.d*0.9;\n    }\n    \n    return Ray(hitPos, hitNormal, steps, t, hit, minDist, hitObj, rayDir);\n}\n\n\n//checkerboard texture (u, v) -> color\nvec3 checkerboard(float u, float v, float interval) {\n    /*\n    float um = mod(u, interval);\n    float vm = mod(v, interval);\n    if(um < interval/2.0 && vm < interval/2.0) {\n        return vec3(0.1);\n    }\n    else if(um >= interval/2.0 && vm < interval/2.0) {\n        return vec3(1.0);\n    }\n    else if(um < interval/2.0 && vm >= interval/2.0) {\n        return vec3(1.0);\n    }\n    else {\n        return vec3(0.1);\n    }\n\t*/\n    u = floor(u/interval*2.0);\n    v = floor(v/interval*2.0);\n    float p = mod(u + v, 2.0);\n    return vec3(0.1 + 0.9*p);\n}\n\n\n//is light visible from point p\nbool isVisible(vec3 p, vec3 lightPos) {\n    Ray tr = trace(p, normalize(lightPos - p));\n    if(!tr.hit) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\nvec3 lightPos = vec3(0, -10, 0);\nvec3 shading(vec3 from, vec3 rayDir) {\n    //raymarch\n    Ray tr = trace(from, rayDir);\n    \n    //if nothing hit return black\n    if(!tr.hit) {\n        return vec3(0.5, 0.7, 0.8);\n    }\n    \n    //texture\n    vec3 tex = vec3(1);\n    Obj hitObj = tr.hitObj;\n    //sphere\n    if(hitObj.objType == 1) {\n        vec3 normal = tr.hitNormal;\n        float u = atan(normal.y, length(normal.xz)) + 3.14;\n        float v = atan(normal.z, normal.x) + 3.14;\n        tex = checkerboard(u, v, 1.0);\n    }\n    //plane\n    else {\n        vec3 hitPos = tr.hitPos;\n        float u = hitPos.x;\n        float v = hitPos.z;\n        tex = checkerboard(u, v, 1.0);\n    }\n    \n    vec3 color = vec3(0.0);\n    //stepsAO\n    vec3 stepsAO = (1.0 - pow(float(tr.steps)/float(maxStep), 1.0)) * vec3(0.5, 0.7, 0.8);\n    \n    //direct illumination\n    bool visible = isVisible(tr.hitPos, lightPos);\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    if(visible) {\n        vec3 lightDir = normalize(lightPos - tr.hitPos);\n        diffuse = max(dot(tr.hitNormal, lightDir), 0.0) * vec3(1.0);\n        specular = pow(max(dot(reflect(-lightDir, tr.hitNormal), -tr.rayDir), 0.0), 8.0) * vec3(1.0);\n    }\n    \n    color = 0.7*diffuse + 0.3*specular + 0.1*stepsAO;\n    \n    color = clamp(color*tex, vec3(0), vec3(1));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    float t = 0.2*iTime;\n    vec3 camPos = vec3(3.0*sin(t), 0, -3.0*cos(t));\n    vec3 camFront = normalize(-camPos);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = -cross(camFront, camUp);\n    float focus = 0.1;\n    vec3 focusPos = camPos + focus*camFront;\n    vec3 sensorPos = 0.1*uv.x*camRight + 0.1*uv.y*camUp + camPos;\n    vec3 rayDir = normalize(focusPos - sensorPos);\n    \n    lightPos = vec3(3.0*cos(2.0*t), -5, 2.0*sin(3.0*t));\n    \n    vec3 color = shading(sensorPos, rayDir);\n    color.x = pow(color.x, 1.0/2.2);\n    color.y = pow(color.y, 1.0/2.2);\n    color.z = pow(color.z, 1.0/2.2);\n    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}