{"ver":"0.1","info":{"id":"cslBW4","date":"1688898329","viewed":100,"name":"SDF Teapot + PBR","username":"KZubatov","description":"Homework 2.5","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"msfBW8","parentname":"SDF Teapot + Textures + Bump"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 300\n#define LIGHT 1\n#define AA 2\nconst float PI = 3.14159265359;    \n\nconst vec3 baseLightPos1   = vec3(-4, 4, 2);\nconst vec3 lightColor1 = vec3(1.3, 0.6, 0.7);\n\nconst vec3 baseLightPos2   = vec3(3, 1.1, -3);\nconst vec3 lightColor2 = vec3(0.4, 0.4, 1); \n\nconst float MAX_DIST = 5.0;\nconst float EPS = 0.0001;\n\nmat3 rotationX(float a) {\n    return mat3(1, 0, 0,\n                0, cos(a), -sin(a),\n                0, sin(a), cos(a));\n}\n\nmat3 rotationY(float a) {\n    return mat3(cos(a), 0, sin(a),\n                0, 1, 0,\n                -sin(a), 0, cos(a));\n}\n\nmat3 rotationZ(float a) {\n    return mat3(cos(a), -sin(a), 0,\n                sin(a), cos(a), 0,\n                0, 0, 1);\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h); \n}\n\nfloat smoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h); \n}\n\nfloat smoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h); \n}\n\nfloat sdf_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdf_capped_cone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, q.y < 0.0 ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdf_torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdf_cut_sphere(vec3 p, float r, float h) {\n    float w = sqrt(r * r - h * h);\n    vec2 q = vec2(length(p.xz), p.y);\n    float s = max((h - r) * q.x * q.x + w * w * (h + r - 2.0 * q.y), h * q.x - w * q.y);\n    return s < 0.0 ? length(q) - r : q.x < w ? h - q.y : length(q - vec2(w, h));\n}\n\nfloat sdf_cylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r,h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat length_n(vec2 t, float n) {\n    return pow(pow(abs(t.x), n) + pow(abs(t.y), n), 1.0 / n);\n}\n\nfloat sdf_torus(vec3 p, vec2 t, float n, float m) {\n    vec2 q = vec2(length_n(p.xz, n) - t.x, p.y);\n    return length_n(q, m) - t.y;\n}\n\nfloat sdf_round_cone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0) \n        return length(q) - r1;\n    if (k > a * h) \n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a,b)) - r1;\n}\n\nfloat sdf_plane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdf(vec3 p) {\n    // teapot\n    float dTorus = sdf_torus(p - vec3(0, 0.2, 0), vec2(0.31, 0.02));\n    float dCappedCone = sdf_capped_cone(p, 0.2, 0.5, 0.35);\n    float dCutSphereUp = sdf_cut_sphere(p + vec3(0, 0.55, 0), 0.8, 0.75);\n    float subtraction1 = smoothSubtraction(dTorus, dCappedCone, 0.02);\n    float union1 = smoothUnion(subtraction1, dCutSphereUp, 0.03);\n    float dCutSphereDown = sdf_cut_sphere(p * vec3(1, -1, 1), sqrt(0.29), 0.2);\n    float union2 = min(union1, dCutSphereDown);\n    float dInvisibleCylinder = sdf_cylinder(p + vec3(0, sqrt(0.29) - 0.05, 0), 0.19, 0.45);\n    float subtraction2 = max(union2, -dInvisibleCylinder);\n    float dVisibleCylinder = sdf_cylinder(p + vec3(0, sqrt(0.29) - 0.22, 0), 0.01, 0.45);\n    float union3 = smoothUnion(subtraction2, dVisibleCylinder, 0.03);\n    float dTorus42 = sdf_torus((p - vec3(0, 0.22, 0)) * rotationX(PI / 2.0), vec2(0.1, 0.02), 4.0, 2.0);\n    float union4 = smoothUnion(union3, dTorus42, 0.03);\n    float dTorus24 = sdf_torus((p + vec3(0.5, 0, 0)) * rotationX(PI / 2.0), vec2(0.14, 0.035), 2.0, 2.0);  \n    float union5 = smoothUnion(union4, dTorus24, 0.05);\n    float dRoundCone = sdf_round_cone(rotationZ(-PI / 4.0) * (p - vec3(0.46, -0.1, 0)), 0.1, 0.04, 0.35);\n    float union6 = smoothUnion(union5, dRoundCone, 0.05);\n    float dInvisibleSphere = sdf_sphere(p, vec3(0.73, 0.17, 0), 0.025);\n    float subtraction3 = smoothSubtraction(dInvisibleSphere, union6, 0.03);\n    \n    float dPlane = sdf_plane(p, vec3(0, 1, 0), 0.34);\n    return min(subtraction3, dPlane);\n}\n\nvoid generateTNB(vec3 p, out vec3 t, out vec3 n, out vec3 b) {\n    float dx1 = sdf(p + vec3(EPS, 0, 0));\n    float dx2 = sdf(p - vec3(EPS, 0, 0));\n    float dy1 = sdf(p + vec3(0, EPS, 0));\n    float dy2 = sdf(p - vec3(0, EPS, 0));\n    float dz1 = sdf(p + vec3(0, 0, EPS));\n    float dz2 = sdf(p - vec3(0, 0, EPS));\n    \n    n = normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n    vec3 e1 = abs(n.x) < EPS && abs(n.y) < EPS ? vec3(0, 1, 0) : vec3(0, 0, 1);\n    vec3 e2 = abs(n.x) < EPS && abs(n.z) < EPS ? vec3(1, 0, 0) : vec3(0, 1, 0);\n    \n    t = normalize(e1 - dot(e1, n) * n);\n    b = normalize(e2 - dot(e2, n) * n - dot(e2, t) * t);\n    \n    if (length(cross(n, t) - b) > 0.001) {\n        b *= -1.0;\n    }\n}\n\nvec3 getTriplanarWeights(vec3 n) {\n    vec3 w = n * n;\n    return w / (w.x + w.y + w.z);\n}\n\nvec3 getTexel(vec3 p, vec3 w, sampler2D iChannel) {\n    vec3 tx = texture(iChannel, p.yz).rgb;\n    vec3 ty = texture(iChannel, p.xz).rgb;\n    vec3 tz = texture(iChannel, p.xy).rgb;\n    return tx * w.x + ty * w.y + tz * w.z;\n}\n\nvec3 fresnel(vec3 F0, float nv) {\n    return mix(F0, vec3(1), pow(1.0 - nv, 5.0));\n}\n\nfloat G_Neumann(float nl, float nv) {\n    return nl * nv / max(0.01, max(nl, nv));\n}\n\nfloat G_CookTorrance(float nl, float nv, float nh, float vh) {\n    return min(1.0, min(2.0 * nh * nv / vh, 2.0 * nh * nl / vh));\n}\n\nfloat G_Implicit(float nl, float nv) {\n    return nl * nv;\n}\n\nfloat D_Beckmann(float roughness, float nh) {\n    float nh2 = max(0.01, nh * nh);\n    float tmp = nh2 * roughness * roughness;\n    return 1.0 / tmp / nh2 * exp((nh2 - 1.0) / tmp);\n}\n\nfloat CookTorrance(float nl, float nv, float nh, float vh, float roughness) {\n    return D_Beckmann(roughness, nh) * G_CookTorrance(nl, nv, nh, vh);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 offset = vec3(0, cos(3.0 * iTime), sin(4.0 * iTime));\n    vec3 lightPos1 = baseLightPos1 + offset;\n    vec3 lightPos2 = baseLightPos2 - offset;\n    \n    vec3 CAMERA_POS = vec3(3.0 * cos(iTime), 1, 3.0 * sin(iTime));\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    \n    #if AA > 1\n    fragColor = vec4(0);\n    vec4 col = vec4(0);\n    float order = float(AA);\n    vec2 coord = fragCoord;\n    \n    for (float y = 0.0; y < order; y += 1.0) {\n        for (float x = 0.0; x < order; x += 1.0) {\n            fragCoord = coord + vec2(x, y) / order;\n    #endif\n            vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x; \n            vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);\n            vec3 p = CAMERA_POS;\n\n            float totalDist = 0.0;\n            for (int i = 0; i < MAX_STEPS; ++i) {\n                float dist = sdf(p);\n\n                if (abs(dist) < EPS) {\n                    vec3 normal, tangent, bitangent;\n                    generateTNB(p, tangent, normal, bitangent);\n\n                    vec3 towardLight1 = normalize(lightPos1 - p);\n                    vec3 towardLight2 = normalize(lightPos2 - p);\n                    vec3 v = normalize(CAMERA_POS - p);\n                    vec3 h1 = normalize(towardLight1 + v);\n                    vec3 h2 = normalize(towardLight2 + v);\n\n                    vec3 w = getTriplanarWeights(normal);\n\n                    vec3 color;\n                    float roughness;\n                    float metalness;\n                    vec3 texNormal;\n                    if (abs(dist - sdf_plane(p, vec3(0, 1, 0), 0.34)) < EPS) {\n                        color = vec3(0.357, 0.631, 0.6);\n                        texNormal = getTexel(p, w, iChannel2) * 2.0 - vec3(1);\n                        roughness = 0.4;\n                        metalness = 0.1;\n                    } else {\n                        color = getTexel(p, w, iChannel1);\n                        texNormal = getTexel(p, w, iChannel3) * 2.0 - vec3(1);\n                        roughness = color.b;\n                        metalness = color.r;\n                    }\n\n                    normal = normalize(tangent * texNormal.x + normal * texNormal.y + bitangent * texNormal.z);\n\n                    color = pow(color, vec3(2.2));\n                    float nv = max(0.0, dot(normal, v));\n                    float nl1 = max(0.0, dot(normal, towardLight1));\n                    float nl2 = max(0.0, dot(normal, towardLight2));\n                    float nh1 = max(0.0, dot(normal, h1));\n                    float nh2 = max(0.0, dot(normal, h2));\n                    float vh1 = max(0.0, dot(v, h1));\n                    float vh2 = max(0.0, dot(v, h2));\n\n                    vec3 F0 = mix(vec3(0.04), color, metalness);\n                    vec3 specFresnel = max(vec3(0.0), fresnel(F0, nv));\n\n                    vec3 spec1 = specFresnel * CookTorrance(nl1, nv, nh1, vh1, roughness) / max(0.001, 4.0 * nv);\n                    vec3 diff1 = max(vec3(0), (vec3(1) - specFresnel) * nl1 / PI);\n\n                    vec3 spec2 = specFresnel * CookTorrance(nl2, nv, nh2, vh2, roughness) / max(0.001, 4.0 * nv);\n                    vec3 diff2 = max(vec3(0), (vec3(1) - specFresnel) * nl2 / PI);            \n\n                    #if LIGHT == 2\n                        fragColor.rgb = pow((diff1 * mix(color, vec3(0), metalness) + spec1) * lightColor1 + (diff2 * mix(color, vec3(0), metalness) + spec2) * lightColor2, vec3(1.0 / 2.2));\n                    #else\n                        fragColor.rgb = pow((diff1 * mix(color, vec3(0), metalness) + spec1) * lightColor1, vec3(1.0 / 2.2));\n                    #endif\n                    break;\n                }\n\n                totalDist += dist;\n                if (totalDist > MAX_DIST) {\n                    fragColor.rgb = texture(iChannel0, rotationZ(3.0 * PI / 2.0) * (rayDir + vec3(0, .1, 0))).rgb;\n                    break;\n                }\n\n                p += rayDir * dist;\n            }\n    #if AA > 1\n            col += fragColor;\n        }\n    }\n    fragColor = col / (order*order);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FLOATING_SCALE 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #if FLOATING_SCALE\n        float scale = mix(0.0, 10.0, cos(iTime / 4.0) * cos(iTime / 4.0));\n    #else\n        float scale = 10.0;\n    #endif\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 offsetX = vec2(1.0 / iResolution.x, 0.0);\n    vec2 offsetY = vec2(0.0, 1.0 / iResolution.y); \n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 color_dx = texture(iChannel0, uv + offsetX).rgb;\n    vec3 color_dy = texture(iChannel0, uv + offsetY).rgb;\n    \n    float h = (color.x + color.y + color.z) / 3.0;\n    float hx = (color_dx.x + color_dx.y + color_dx.z) / 3.0;\n    float hy = (color_dy.x + color_dy.y + color_dy.z) / 3.0;\n    \n    float dx = (h - hx) * scale;\n    float dy = (h - hy) * scale;\n    \n    float len = length(vec3(dx, dy, 1.0));\n    \n    vec3 normal = vec3(dy, 1.0, dx) / len;\n    normal += vec3(1.0);\n    normal /= 2.0;\n    fragColor.rgb = normal;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 3.0;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 offsetX = vec2(1.0 / iResolution.x, 0.0);\n    vec2 offsetY = vec2(0.0, 1.0 / iResolution.y); \n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 color_dx = texture(iChannel0, uv + offsetX).rgb;\n    vec3 color_dy = texture(iChannel0, uv + offsetY).rgb;\n    \n    float h = (color.x + color.y + color.z) / 3.0;\n    float hx = (color_dx.x + color_dx.y + color_dx.z) / 3.0;\n    float hy = (color_dy.x + color_dy.y + color_dy.z) / 3.0;\n    \n    float dx = (h - hx) * scale;\n    float dy = (h - hy) * scale;\n    \n    float len = length(vec3(dx, dy, 1.0));\n    \n    vec3 normal = vec3(dy, 1.0, dx) / len;\n    normal += vec3(1.0);\n    normal /= 2.0;\n    fragColor.rgb = normal;\n}","name":"Buffer B","description":"","type":"buffer"}]}