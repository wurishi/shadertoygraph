{"ver":"0.1","info":{"id":"wt2cDK","date":"1595453638","viewed":68,"name":"002 - Ray Tracer","username":"Mr_Admirals","description":"Experimenting with raytracing.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n\tvec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n \tvec3 color;\n    vec3 dir;\n};\n    \nstruct Material\n{\n  \tvec3 color;\n    float diffuse;\n    float specular;\n};\n    \nstruct Sphere\n{\n  \tvec3 pos;\n    float r;\n    Material mat;\n};\n    \nstruct Plane \n{\n    vec3 normal;\n    Material mat;\n};\n    \nstruct Hit\n{\n\tvec3 point;\n    vec3 normal;\n    Material mat;\n};\n    \nLight light;\nLight ambientLight;\nPlane plane;\nvec3 camera;\nconst int numSpheres = 2;\nSphere spheres[numSpheres];\n\nconst float exposure = 0.5;\nconst float gamma = 1.0;\n\nconst int iterations = 4;\nconst float Epsilon = 1e-3;\nconst float\tambientConstant = 0.08;\nconst float smoothness = 0.5;\n\n// Computes scene object values\nvoid SetUpScene()\n{\n    light = Light(vec3(1.0), normalize(vec3(1.0, -0.75, 1.0)));\n    ambientLight = Light(vec3(1.0, 1.0, 1.0), normalize(vec3(1.0)));\n    plane = Plane(vec3(0.0, 1.0, 0.0), Material(vec3(0.8), 1.0, 0.0));\n    camera = vec3(0.0, 1.0, -10.0);\n    spheres[0] = Sphere(vec3(-4.0, 3.0 + sin(iTime), 0), 2.0, Material(vec3(1.0, 0.5, 0.2), 1.0, 1.0));\n    spheres[1] = Sphere(vec3( 4.0 + cos(iTime), 3.0, 0), 2.5, Material(vec3(0.5, 0.2, 1.0), 1.0, 1.0));\n}\n    \n// Tests for intersection between ray and sphere\nbool IntersectionTest(out Hit hit, Ray ray, Sphere sphere)\n{\n    // Check for a Negative Square Root\n    vec3 oc = sphere.pos - ray.origin;\n    float l = dot(ray.dir, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.r, 2.0);\n    if (det < 0.0) return false;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return false;\n    hit = Hit(ray.origin + len*ray.dir, (ray.origin + len*ray.dir - sphere.pos) / sphere.r, sphere.mat);\n    return true;\n}\n\n// Test for intersection between ray and plane\nbool IntersectionTest(out Hit hit, Ray ray, Plane plane) \n{\n    float len = -dot(ray.origin, plane.normal) / dot(ray.dir, plane.normal);\n    if (len < 0.0) return false;\n    hit = Hit(ray.origin + len * ray.dir, plane.normal, plane.mat);\n    \n    return true;\n}\n\n// Trace a ray throughout the scene, testing for intersections with all objects\nbool Trace(out Hit hit, Ray ray)\n{   \n    Hit intersection;\n    \n    for(int i = 0; i < numSpheres; i++)\n    {\n     \tif(IntersectionTest(intersection, ray, spheres[i]))\n        {\n            hit = intersection;\n    \t\treturn true;\n        }\n    }\n    \n    if(IntersectionTest(intersection, ray, plane))\n    {\n        hit = intersection;\n     \treturn true;   \n    }\n    \n    return false;\n}\n\n// Computes the color value from a ray and its bounces\nvec3 GetColor(Ray ray)\n{\n    vec3 color;\n    \n    vec3 ambient = ambientConstant * ambientLight.color;\n    \n    vec3 energyFalloff = vec3(1.0);\n    \n    for(int i = 0; i < iterations; i++)\n    {\n        Hit hit;\n    \tif(Trace(hit, ray))\n    \t{\n            // Schlick's Approximation\n            float refractionIndex = 3.0;\n         \tfloat f0 = pow(refractionIndex - 1.0, 2.0) / pow(refractionIndex + 1.0, 2.0);\n            float ndotv = clamp(dot(hit.normal, -ray.dir), 0.0, 1.0);\n            float fresnel = f0 + (1.0 - f0) * pow(1.0 - ndotv, 5.0);\n            energyFalloff *= fresnel;\n            \n            // Check for obstacles between surface and light\n            Hit shadowHit;\n            if(!Trace(shadowHit, Ray(hit.point + -light.dir * Epsilon, -light.dir)))\n            {\n                // Blinn-Phong\n                float shade = clamp(dot(hit.normal, -light.dir), 0.0, 1.0);\n                vec3 diffuse = hit.mat.color * light.color * hit.mat.diffuse * shade * energyFalloff;\n                \n                vec3 halfDir = normalize(-light.dir + -ray.dir);\n                vec3 specular = light.color * hit.mat.specular * pow(clamp(dot(halfDir, hit.normal), 0.0, 1.0), smoothness * 100.0);               \n                \n                color += diffuse + specular;\n            }\n            \n            // Calculate reflectance ray\n            ray = Ray(hit.point + hit.normal * Epsilon, reflect(ray.dir, hit.normal));\n    \t}\n        else\n        {\n           color += ambient;\n           break;\n        }\n    }\n    \n    return color;\n}\n\n\n// Fragment program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    SetUpScene();\n    \n    Ray ray = Ray(camera, normalize(vec3(uv, 1.0)));\n    vec3 col = GetColor(ray);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}