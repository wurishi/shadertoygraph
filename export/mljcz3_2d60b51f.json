{"ver":"0.1","info":{"id":"mljcz3","date":"1692349772","viewed":106,"name":"working jfa point lights","username":"Carandiru","description":"finally figured out proper interpolation for lighting between Voronoi cells (light emitter seeds inside) from the output of JFA\ntodo:\n  - eliminate the edges between Voronoi cells that unfortunately still show up\n  - jitter with blue noise\n\nany ideas?","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["2d","lighting","jfa"],"hasliked":0,"parentid":"ctfyRX","parentname":"JFA bugs"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// working jfa point lights (research)\n// http://bit.ly/supersinfulsilicon\n\n// working jfa point lights by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/mljcz3\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n//------------------------------------------------------------------------------------------------------------------\n\n// jumpflood lighting (w/ debug visualization)\n//\n// finally figured out proper interpolation for lighting between Voronoi cells \n// (light emitter seeds inside) from the output of JFA\n// pending:\n//  - eliminate the edges between Voronoi cells that unfortunately still show up\n//  - jitter with blue noise (optional) to remove banding artifacts\n\n// *updated - solved pending with bluenoise in part a & b, to enable see below.\n//\n//\n//------------------------------------------------------------------------------------------------------------------- \n\n//#define ENABLE_BLUENOISE   // uncomment to enable bluenoise jittering\n\n// jumpflood shader template taken from:\n// https://www.shadertoy.com/view/MstBWX\n\n#define SCALE 64.0\n\n#define R (iResolution.xy)\n\n#define phi 1.618034\n#define iphi 0.618034\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 bn = textureLod(iChannel1, (fragCoord)/1024.0f, 0.0).rg;\n    bn = bn * 0.5f + 0.5f; // minimum 0.5 to maximum of 1.0 required\n    \n    vec2 uv = fragCoord/R;\n    uv = uv * 0.5f; // zoomed in\n    \n    vec4 read = textureLod(iChannel0, uv, 0.0f);\n    vec2 seedCoord; vec3 seedColor;\n    DecodeData(read, seedCoord, seedColor);\n\n    float distSeed = distance(uv*R, seedCoord);\n    \n#ifdef ENABLE_BLUENOISE\n    distSeed = distSeed*bn.x;  // part a: can optionally add blue noise by scaling the seed distance\n                               // *banding is ~eliminated, shape conforms better to seed\n#endif\n\n    bool phi_time = fract(iTime*iphi) > iphi;\n    \n    vec3 color = vec3(0);\n    float samps = float(0.0f);\n    \n    vec2 dir;\n    for ( dir.y = -1.0f; dir.y <= 1.0f; dir.y += (1.0f/6.0f)) {\n        for ( dir.x = -1.0f; dir.x <= 1.0f; dir.x += (1.0f/6.0f)) {\n\n            vec2 nuv = (uv*R + dir*(1.0f + distSeed))/R;\n            \n            vec2 nCoord; vec3 nColor;\n            float d = 0.0f;\n            \n            read = textureLodOffset(iChannel0, nuv, 0.0f, ivec2(-1, 0));\n            DecodeData(read, nCoord, nColor);\n            d += distance(uv*R, nCoord);\n            \n            read = textureLodOffset(iChannel0, nuv, 0.0f, ivec2( 1, 0));\n            DecodeData(read, nCoord, nColor);\n            d += distance(uv*R, nCoord);\n            \n            read = textureLodOffset(iChannel0, nuv, 0.0f, ivec2( 0,-1));\n            DecodeData(read, nCoord, nColor);\n            d += distance(uv*R, nCoord);\n            \n            read = textureLodOffset(iChannel0, nuv, 0.0f, ivec2( 0, 1));\n            DecodeData(read, nCoord, nColor);\n            d += distance(uv*R, nCoord);\n            \n            d *= 1.0f / 4.0f;\n            \n            read = textureLod(iChannel0, nuv, 0.0f);\n            DecodeData(read, nCoord, nColor);            \n            float nd = distance(uv*R, nCoord);\n\n#ifdef ENABLE_BLUENOISE\n            nd = nd*bn.y;  // part b: can optionally add blue noise by scaling the neighbour distance\n                           // *eliminates voronoi edges and any other \"lines or patterns\"\n#endif                     // can use second channel of bluenoise as it is isolated from the first channels usage\n\n            bool debug = phi_time && (nd < 4.01f || (abs(nd - d) > 0.25f)); // b4\n                        \n           // nd = nd - abs(nd - d);\n           // nd = min(nd, d);\n           // nd = smin(nd, d, 0.5f * d);\n            \n            float a = att((nd/SCALE));\n            \n            if ( debug ) { // l8\n                nColor = vec3(0, 1, 0); a = 1.0f; \n            }\n            else {\n                nColor = mix(nColor, nColor * 0.15f, bvec3(phi_time));\n            }\n            \n            color += nColor * a;\n            samps += 1.0f;\n        }\n    }   \n    \n    color /= max(1.0f, samps);\n    ///color = color * att(distSeed/SCALE); // *note if this is enabled. then only a single channel of bluenoise can be used for part a & b above.\n    \n    // final color is linear output for lights, to be sampled.....\n    // however for proper display, must cancel out the monitor's srgb transfer function\n    // *important\n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)), 1.0f);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n\n//--------------------------------------------------\n\nvec4 JFAStep(vec2 fragCoord, int level)\n{\n    // current data in texture on fragCoord position\n    vec4 ret = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    bool emitter = ret != vec4(0.);\n    \n    // big number so any real distance will be smaller than that\n    vec3 color = vec3(0);\n    float invSqSeed = 0.;\n    \n    // that means the current data contains info of a nearby seed\n    if( emitter )\n    {\n        vec2 seedCoord;\n        \n        DecodeData(ret, seedCoord, color);\n        invSqSeed = att(distance(fragCoord, seedCoord));\n    }\n    \n    vec2 offset = vec2(exp2(max(0., float(JFA_MAX_STEPS - level) ) ) );\n    \n    for(int x = -1; x <= 1; x++)\n    {\n    \tfor(int y = -1; y <= 1; y++)\n        {\n\t\t\tvec4 read = texture(iChannel0, (fragCoord + vec2(x,y)*offset)/iChannelResolution[0].xy );\n            if( read != vec4(0.) )\n            {\n                vec2 coord;\n                vec3 ncolor;\n                \n                DecodeData(read, coord, ncolor);\n                \n                float invsqdist = att(distance(coord, fragCoord));\n                \n                if( invsqdist > invSqSeed )\n                {\n                    invSqSeed = invsqdist;\n                    ret = read;\n                }\n            }\n        }\n    }\n    \n    return ret;\n}\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 0.618034f\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// copied the random functions...\n//============================================================\n// returns 0..1\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342) * 1.618034f;\n    co.y += fract(iDate.w * 11.214) * 1.618034f;\n    return hash12(co);\n}\n\nvec3 blackbody(float t){\n    // http://en.wikipedia.org/wiki/Planckian_locus\n\n    vec4 vx = vec4( -0.2661239e9, -0.2343580e6, 0.8776956e3, 0.179910   );\n    vec4 vy = vec4( -1.1063814,   -1.34811020,  2.18555832, -0.20219683 );\n    //vec4 vy = vec4(-0.9549476,-1.37418593,2.09137015,-0.16748867); //>2222K\n    float it = 1. / t;\n    float it2= it * it;\n    float x = dot( vx, vec4( it*it2, it2, it, 1. ) );\n    float x2 = x * x;\n    float y = dot( vy, vec4( x*x2, x2, x, 1. ) );\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 xyzToSrgb = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n\n    vec3 srgb = vec3( x/y, 1., (1.-x-y)/y ) * xyzToSrgb;\n\n    return max( srgb, 0. );\n}\n\n//============================================================\n// Converts a color from sRGB to linear (branchless)\nvec3 toLinear(in vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045f));\n    return mix(pow((sRGB + vec3(0.055f)) / 1.055f, vec3(2.4f)), sRGB / 12.92f, cutoff);\n}\nvec3 RandColor (vec2 co)\n{\n    // light color is linear, convert srgb color returned from blackbody()\n    return(toLinear(blackbody(440.0f + 8660.0f * textureLod(iChannel1, (co * iResolution.xy)/1024.0f, 0.0f).r)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float frame = float(iFrame & (REPEAT-1));\n    \n    // Create seeds\n    if(frame == 0.)\n    {\n\t\tif(Rand(fragCoord) > (1.- SEED_CHANCE))\n        {\n            fragColor = EncodeData(fragCoord, RandColor((fragCoord) / iResolution.xy));\n        }\n        else\n        {\n            fragColor = vec4(0.);\n        }\n        \n    }\n    else\n    {\n        frame = frame - 1.0f;\n        \n        if( (float(JFA_MAX_STEPS*8) - frame) >= 0.0f /*&& mod( float(iFrame), FRAME_DELAY) == 0.*/ )\n        {\n        \tfragColor = JFAStep(fragCoord, int(frame / float(FRAME_DELAY)) );\n            \n        }\n        else\n        {\n            fragColor = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n        }\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// jumpflood shader template taken from:\n// https://www.shadertoy.com/view/MstBWX\n\n#define SEED_CHANCE .00015\n#define JFA_MAX_STEPS 10\n#define FRAME_DELAY 1.0\n#define REPEAT 256 // must be pow2\n\nfloat att(in float d)\n{\n    return 1.0f / (1.0f + d*d);\n}\n\nfloat smootherstep(in float edge0, in float edge1, in float x) \n{\n  x = (x - edge0)/(edge1 - edge0);\n  return( x * x * x * (x * (x * 6.0f - 15.0f) + 10.0f) ); // quintic equation\n}\n\nvec2 rndC(in vec2 pixel) // good function, works with any texture sampling that uses linear interpolation\n{\n    pixel = pixel + 0.5f;\n    vec2 ipixel = floor( pixel );\n    vec2 fpixel = fract( pixel );\n    \n\tpixel = ipixel + fpixel*fpixel*(3.0f-2.0f*fpixel); \n \n\treturn(pixel - 0.5f);  // returns in same unit as input, pixels\n}\n\nfloat smin( in float a, in float b, in float k )\n{\n    float h = max( k-abs(a-b), 0.0f )/k;\n    return min( a, b ) - h*h*h*k*(1.0f/6.0f);\n}\n\n// Putting coordinate encoded in the color\nvec4 EncodeData(vec2 coord, vec3 color)\n{\n\tvec4 ret = vec4(0.);\n\tret.xy = coord;\n    ret.z = floor(color.x * 255.)*256. + floor(color.y * 255.);\n    ret.w = floor(color.z * 255.);\n\treturn ret;\n}\n\n// Getting the coordinate out of the color\nvoid DecodeData(in vec4 data, out vec2 coord, out vec3 color )\n{\n\tcoord = data.xy;\n    color.x = floor(data.z/256.)/255.;\n    color.y = mod(data.z,256.)/255.;\n    color.z = mod(data.w,256.)/255.;\n}\n","name":"Common","description":"","type":"common"}]}