{"ver":"0.1","info":{"id":"XdfBD8","date":"1495804098","viewed":120,"name":"Grid non-AA using fract()","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/4tBGRz","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/4tBGRz\n\n// Why doesn't smoothstep induces AA in this case? Anyone know?\n\n#define N_TILES_Y 2.\n#define THICKNESS .04\n\nfloat draw_grid(vec2 st){\n  float tile_len = N_TILES_Y / iResolution.y;\n\n  // Why doesn't smoothstep induces AA in this case?\n  vec2 grid = smoothstep(.5 * tile_len, tile_len, fract(tile_len * st) - THICKNESS);\n  return min(grid.x, grid.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 st = 2. * fragCoord - iResolution.xy;  // Center (but don't normalize) pixel coordinates!\n\n  st *= 1. + sin(iTime);  // Zoom!\n  st = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * st;  // Rotate!\n\n  float grid = draw_grid(st);\n  fragColor.rgb = vec3(1. - grid);\n}\n","name":"Image","description":"","type":"image"}]}