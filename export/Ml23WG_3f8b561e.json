{"ver":"0.1","info":{"id":"Ml23WG","date":"1432241140","viewed":166,"name":"Shiny Balls","username":"dirkadirkadan","description":"Shiny balls floating around","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nfloat time;\n\n\n#define EPS .00001\n#define MAX_BOUNCES 4\n#define MAX_ITER 100\n#define STEP_FACTOR .8\n\nint mat_hit;\n\nvec3 right_ball_mat;\nvec3 left_ball_mat;\nvec3 floor_mat;\n\nfloat fbm(vec2 p)\n{\n    p /= 50.;\n    mat2 m = mat2(.8, -.6, .6, .8); \n    float amp = .5;\n \n    float f=0.;\n    for (int i = 0; i < 6; i++)\n    {\n        f += amp * texture(iChannel0, p).r;\n        p *= m * 2.;\n        amp *= .5;\n    }\n    \n    return f;\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  mat3 rot;\n\n  p = p - vec3(0,2.,0.);\n\n  float speed = 8.;\n  float st = sin(time*speed);\n  float ct = cos(time*speed);\n\n  rot[0] = vec3(st,ct,0.);\n  rot[2] = vec3(0.,0.,1.);\n  rot[1] = vec3(ct,-st,0.);\n  \n  p = rot*p;\n  \n  return length(max(abs(p)-b,0.0));\n}\n\nfloat opDisplace( vec3 p )\n{\n  /*\n    float d1 = primitive(p);\n    float d2 = displacement(p);\n    return d1+d2;\n    */\n    return 0.;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opBlend( vec3 p )\n{\n  /*\n    float d1 = primitiveA(p);\n    float d2 = primitiveB(p);\n    return smin( d1, d2 );\n    */\n    return 0.;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 z, vec3 loc, float radius)\n{\n    return length(z-loc)-radius;\n}\n\nfloat de(vec3 z)\n{\n  \n    z.x = mod(z.x,10.)-5.;\n    z.z = mod(z.z,10.)-5.;\n    \n    float sphere1 = sphere(z, vec3(0.,sin(time*20.),0.), .5);\n    float sphere2 = sphere(z, vec3(-1.,-1.+.5*cos(time*20.),-1.), .7);\n    float flr = z.y+2.;\n    \n    mat_hit = int(step(0.,sphere1-sphere2));\n\n    float dist = min(sphere1,sphere2);\n    mat_hit += int(step(0.,dist-flr));\n    dist = min(dist,udBox(z,vec3(1.45)));\n    dist = min(dist,flr);\n    \n    return dist;\n}\n\nvec3 norm(vec3 p)\n{\n    float d = de(p);\n    \n    float x = d - de(vec3(p.x+EPS,p.y,p.z));\n    float y = d - de(vec3(p.x,p.y+EPS,p.z));\n    float z = d - de(vec3(p.x,p.y,p.z+EPS));\n    \n    return normalize(vec3(x,y,z));\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    n*=-0.2;\n    float f = .8+de(p+n);\n    return clamp(f,0.,1.);\n}\n\nfloat march(vec3 ro, vec3 rd, out bool hit, out vec3 pt, inout float d)\n{\n    hit = false;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        pt = ro+rd*d;\n        float s = de(pt);\n        d += STEP_FACTOR*s;\n        \n        if (s < EPS)\n        {\n            hit = true;\n            return d;\n        }\n    }\n    \n    return 100.;\n}\n\nvec3 fogclr=vec3(.5,.6,.7);\n\nvec3 light(vec3 col, vec3 normal)\n{\n    vec3 lpos = vec3(2.);\n    vec3 ldir = normalize(vec3(-1.));\n    \n    return col*(clamp(dot(normal,ldir),0.,1.));\n    \n}\n\nvoid fog(inout vec3 col, float d, float f)\n{\n    col = mix(col,fogclr, clamp(1.-exp(-d*d*.0105*2.5*f),.0,1.));\n}\n\nbool trace(vec3 ro, vec3 rd, inout vec3 col)\n{\n    vec3 orig_ro = ro;\n    float d = 0.;\n    int max_bounces = MAX_BOUNCES;\n    \n    float factor = 1.;\n    factor = .95;\n    \n    bool any_hits = false;\n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)\n    {\n        factor *= factor;\n        bool hit = false;\n        vec3 pt;\n        \n        d = march(ro,rd,hit,pt,d);\n        \n        if (hit)\n        {\n            vec3 mat_color = normalize(vec3(float(mat_hit),float(mat_hit)+1.,float((mat_hit+1)*(mat_hit+1))));\n            vec3 n = norm(pt);\n            col += clamp(factor,0.,1.)*light(mat_color, n);\n//            col *= ao(pt,n);\n\n            col += clamp(1.-abs(dot(n,pt-orig_ro)),0.,1.);\n            \n            float f = fbm(orig_ro.xy);\n            fog(col,d, f);\n            //col = mix(col,fogclr,f);\n            \n            ro = pt;\n            d = 0.01;\n            rd = reflect(rd,n);\n            any_hits = true;\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    return any_hits;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n \n\n    time = iTime*.1;\n// vec2 uv = fragCoord;\n    \n    \n    vec3 col = vec3(0.);\n    /*\n    float x_noise = .3*noise(vec3(time,sin(time),2.));\n    float y_noise = .3*noise(vec3(cos(time),time,2.));\n    */\n\n  vec3 ro;\n  ro = vec3(5.,3.,8.);\n    ro = vec3(5.*sin(time*8.),+sin(time*8.)+cos(time*8.),8.*cos(time*9.));\n    ro.xy += uv;\n\n\n    vec3 rd = normalize(vec3(uv,-1.));\n    \n    \n    bool any_hits = trace(ro,rd,col);\n    \n    if (!any_hits) col= fogclr;\n   \n    col.xyz = vec3(col.x*col.x,col.y*col.y,col.z*col.z);\n    \n    \n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}