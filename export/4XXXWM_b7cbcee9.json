{"ver":"0.1","info":{"id":"4XXXWM","date":"1709566910","viewed":86,"name":"Trippy Flood Fill Over Image","username":"Bingle","description":"A fading octagonal flood fill. Each newly lit pixel takes the color of iChannel1 at that position. This flood fill process takes place separately for each color channel, producing weird effects given time as the 3 simulations fall out of sync.","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["trippy","floodfill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Go check out Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This code is sub-par, I didn't expect this project to actually go somewhere\n\nivec2[] neighbors = ivec2[] // Lookup neighbors. Some are ignored every other frame to produce the octagonal fill shape\n(\nivec2(-1, 1), ivec2(0, 1), ivec2(1, 1),\nivec2(-1, 0),              ivec2(1, 0),\nivec2(-1,-1), ivec2(0,-1), ivec2(1,-1)\n);\n\n// Takes a whole bunch of arguments and outputs the correct data for a specific channel\nvec3 process(float val, sampler2D tex, vec2 fragCoord, float texMult){\n    \n    ivec2 iCoord = ivec2(fragCoord);\n    if (iFrame==1){ // Initialize some bright pixels for funsies\n        if ((iCoord.x==int(iResolution.x/2.0)) && (fragCoord.y>iResolution.y/2.0)){\n            val=1.0;\n        }else{\n            if ((iCoord.x==int(iResolution.x/2.0)-1) && (fragCoord.y>iResolution.y/2.0)){\n                val=0.5;\n            }else{\n                val=0.0;\n            }\n        }\n    }else{\n        val*=0.95;\n\n        if (val<0.05){\n            for (int i=0;i<8;i++){\n                if (texelFetch(iChannel0,iCoord+neighbors[i],0).r>0.9 && (iFrame%2==0 || (i==1 || i==3 || i==4 || i==6))){\n                    return texture(iChannel1,fragCoord/iResolution.xy).rgb*texMult;\n                }\n            }\n        }\n    }\n    \n    return vec3(val);\n}\n\n// At least this part looks neat-ish...\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    \n    col.r = process(col.r,iChannel1,fragCoord,9.0).r;\n    col.g = process(col.g,iChannel1,fragCoord,8.0).g;\n    col.b = process(col.b,iChannel1,fragCoord,7.0).b;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}