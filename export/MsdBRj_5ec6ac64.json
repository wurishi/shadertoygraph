{"ver":"0.1","info":{"id":"MsdBRj","date":"1525985629","viewed":279,"name":"Raymarched Scene","username":"noxbuds","description":"A neat little scene - this is my first try at raymarching. Took a while to figure out that reflection, but it was definitely worth it. ","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Experimenting with using raymarching. This  //\n//  is my first shader which does this, so it   //\n//  is likely I got some things wrong ;)        //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n////////////////////////////\n//                        //\n//       CONSTANTS        //\n//                        //\n////////////////////////////\n\n////////////////////////////\n//                        //\n//   IMAGE PROCESSING     //\n//                        //\n////////////////////////////\n\n// Main image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup colour\n    vec3 colour = vec3(0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Calculate colour\n    colour = texture(iChannel0, uv).rgb;\n    \n    // Output to screen\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////\n//                        //\n//   QUALITY DEFINITION   //\n//                        //\n////////////////////////////\n\n\n// Comment/uncomment a QUALITY define to change the\n// quality of the scene.\n#define HIGHQUALITY\n//#define MEDQUALITY\n//#define LOWQUALITY\n\n// Whether or not to include a cubemap in the reflections\n//#define USECUBEMAP\n\n////////////////////////////\n//                        //\n//       CONSTANTS        //\n//                        //\n////////////////////////////\n\n#ifdef HIGHQUALITY\nfloat LOD = 1.0; // Raymarching LOD; lower = worse\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4)); // Light vector (directional light)\nfloat ambientLight = 1.0; // Amount of ambient light.\nfloat reflectionQuality = 64.0; // Quality of reflections. 48 is good, higher is more costly\n#endif\n\n#ifdef MEDQUALITY\nfloat LOD = 1.0;\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\nfloat ambientLight = 1.0;\nfloat reflectionQuality = 32.0;\n#endif\n\n#ifdef LOWQUALITY\nfloat LOD = 1.0;\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\nfloat ambientLight = 1.0;\nfloat reflectionQuality = 16.0;\n#endif\n\n////////////////////////////\n//                        //\n//    SIGNED DISTANCE     //\n//       FUNCTIONS        //\n//                        //\n////////////////////////////\n\n// Max function for 3d vectors\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n// Renders a sphere\n// p = position in 3d space\n// r = radius of sphere\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Renders a box\n// p = position, dim = dimensions\nfloat cube(vec3 p, vec3 dim)\n{\n    vec3 d = abs(p) - dim;\n    return length(max(d, 0.0)) + max3(min(d, 0.0));\n}\n\n// Renders a cylinder\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Combines two objects together, and gives you\n// the material ID\nvec4 combine(vec4 a, vec4 b, int am, int bm, out int mi)\n{\n    if (a.a < b.a)\n    {\n        mi = am;\n        return a;\n    }\n    else\n    {\n        mi = bm;\n        return b;\n    }\n}\n\n// Combines two objects together; this doesn't\n// use material IDs\nvec4 combine(vec4 a, vec4 b)\n{\n    if (a.a < b.a)\n        return a;\n    else\n        return b;\n}\n\n////////////////////////////\n//                        //\n//     SCENE ASSEMBLY     //\n//                        //\n////////////////////////////\n\n// Draws a chair\nfloat chair(vec3 p)\n{\n    // Setup v\n    float v = 0.0;\n    \n    // Draw the chair\n    v = cube(p, vec3(0.5, 0.05, 0.5));\n    \n    // Draw the legs\n    v = min(v, cube(p + vec3(-0.45, 0.5, 0.45), vec3(0.05, 0.5, 0.05)));\n    v = min(v, cube(p + vec3(0.45, 0.5, -0.45), vec3(0.05, 0.5, 0.05)));\n    v = min(v, cube(p + vec3(-0.45, 0.5, -0.45), vec3(0.05, 0.5, 0.05)));\n    v = min(v, cube(p + vec3(0.45, 0.5, 0.45), vec3(0.05, 0.5, 0.05)));\n    \n    // Return it\n    return v;\n}\n\n// Draws a table\nfloat table(vec3 p)\n{\n    // Setup v\n    float v = 0.0;\n    \n    // Draw the table\n    v = cube(p, vec3(0.8, 0.05, 0.8));\n    \n    // Draw the legs\n    v = min(v, cube(p + vec3(-0.65, 0.65, 0.65), vec3(0.05, 0.6, 0.05)));\n    v = min(v, cube(p + vec3(0.65, 0.65, -0.65), vec3(0.05, 0.6, 0.05)));\n    v = min(v, cube(p + vec3(-0.65, 0.65, -0.65), vec3(0.05, 0.6, 0.05)));\n    v = min(v, cube(p + vec3(0.65, 0.65, 0.65), vec3(0.05, 0.6, 0.05)));\n    \n    // Return it\n    return v;\n}\n\n// Draws a bowl\nfloat bowl(vec3 p, float s)\n{\n    float v = 0.0;\n    \n    // Draw a bowl\n    v = sphere(p, s);\n    v = max(v, -cube(p - vec3(0.0, 1.0, 0.0), vec3(1.5, 1.0, 1.5)));\n    v = max(v, -sphere(p, s * 0.9));\n    \n    return v;\n}\n\n// Draws a cup\nfloat cup(vec3 p, float s)\n{\n    float v = 0.0;\n    \n    // Draw the base\n    v = cylinder(p, vec2(s, s));\n    \n    // Cut out a gap\n    v = max(v, -cylinder(p + vec3(0.0, -s, 0.0), vec2(s * 0.9, s * 0.9)));\n    \n    return v;\n}\n\n// Map function. This calculates the\n// whole scene\nvec4 map(vec3 p, out int matId)\n{\n    // v is the scene\n    vec4 v = vec4(0.0);\n    float tv = 0.0;\n    \n    // Draw a reflective sphere\n    v = vec4(vec3(0.9, 0.9, 0.9), sphere(p, 0.5));\n    matId = 1;\n    \n    // Draw the table\n    v = combine(v, vec4(vec3(0.7, 0.7, 0.0), table(p + vec3(-1.2, 0.5, 1.5))), matId, 0, matId);\n    \n    // Draw a bowl on the table\n    v = combine(v, vec4(vec3(0.2, 0.6, 0.9), bowl(p + vec3(-0.8, 0.2, 1.5), 0.3)), matId, 1, matId);\n    \n    // Draw a cup on the table\n    tv = cup(p + vec3(-0.8, 0.35, 2.0), 0.1);\n    v = combine(v, vec4(vec3(0.8, 0.9, 0.8), tv), matId, 1, matId);\n    \n    // Draw a chair\n    tv = chair(p + vec3(0.2, 0.8, 1.5));\n    v = combine(v, vec4(vec3(0.7, 0.7, 0.0), tv), matId, 0, matId);\n    \n    // Draw a mirror for testing purposes\n    tv = cube(p + vec3(-2.0, 0.0, -2.0), vec3(4.0, 4.0, 0.5));\n    v = combine(v, vec4(vec3(0.9, 0.9, 0.9), tv), matId, 1, matId);\n    \n    // Max distance between edges\n    float pd = 1.0;\n    \n    // Wrap p around\n    vec2 pp = mod(p.xz, pd) - pd / 2.0;\n    p = vec3(pp.x, p.y, pp.y);\n    \n    // Make a cube\n    tv = cube(p + vec3(0.0, 2.2, 0.0), vec3(0.49, 0.48, 0.49));\n    v = combine(v, vec4(vec3(0.7, 0.7, 0.9), tv), matId, 1, matId);\n    \n    // Return a value\n    return v;\n}\n\n// Map override which doesn't do material stuff\nvec4 map(vec3 p)\n{\n    int m = 0;\n    return map(p, m);\n}\n\n////////////////////////////\n//                        //\n// LIGHTING AND MATERIALS //\n//                        //\n////////////////////////////\n\n// Calculates a normal\nvec3 calcNormal(vec3 p)\n{\n    // Epsilon; used to approximate dx when taking the derivative\n    vec2 eps = vec2(0.001, 0.0);\n    \n    // Approximate the derivative at the given point\n    vec3 nor = vec3(\n        map(p + eps.xyy).a - map(p - eps.xyy).a,\n        map(p + eps.yxy).a - map(p - eps.yxy).a,\n        map(p + eps.yyx).a - map(p - eps.yyx).a);\n    return normalize(nor);\n}\n\n// Credit to https://iquilezles.org/articles/rmshadows\n// for the shadow functions.\n\n// Calculates shadows\nfloat shadow(vec3 o, vec3 r, float mint, float maxt)\n{\n    for (float t = mint; t < maxt;)\n    {\n        float h = map(o + r * t).a;\n        \n        if (h < 0.0001)\n            return 0.0;\n        \n        t += h;\n    }\n    return 1.0;\n}\n\n// Softer shadows\nfloat sshadow(vec3 o, vec3 r, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt;)\n    {\n        float h = map(o + r * t).a;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// Maps a 3d point to a UV co-ordinate, based on\n// the normal vector\nvec2 uvMap(vec3 p, vec3 n)\n{\n    // Calculate vector perpendicular to n\n    vec3 u = normalize(vec3(n.y, -n.x, 0));\n    \n    // Get the cross-product of the vectors\n    vec3 v = cross(n, u);\n    \n    // Take the dot product\n    vec2 uv = vec2(dot(u, p), dot(v, p));\n    \n    // Return our UV co-ordinates\n    return uv;\n}\n\n// Diffuse lighting (matId = 0)\nvec3 diffuse(vec3 p, vec3 col, vec3 n)\n{\n    // Then set colour\n    vec3 colour = col.rgb;\n\n    // Then do lighting and shadows\n    colour *= vec3(max(dot(-lightDir.xyz, n), 0.0));\n    \n    // Return the colour\n    return colour;\n}\n\n// Specular lighting\nvec3 specular(vec3 p, vec3 col, vec3 n, vec3 v)\n{\n    // Set base colour\n    vec3 colour = ambientLight * diffuse(p, col, n);\n    \n    // Reflect the light ray\n    vec3 rr = reflect(-lightDir, n);\n    vec3 r = reflect(-v, n);\n    \n    // Specular constant\n    float ks = 1.0;\n    \n    // Calculate specular reflection\n    colour += ks * max(0.0, dot(rr, v));\n    \n    // Calculate cubemap reflection. Invert\n    // the y component because it's wrong. :)\n    colour += ks * texture(iChannel0, vec3(r.x, -r.y, r.z)).rgb;\n    \n    // Return colour\n    return colour;\n}\n\n// Reflection testing\nvec3 reflective(vec3 p, vec3 col, vec3 n, vec3 v)\n{\n    // Set base colour\n    vec3 colour = ambientLight * diffuse(p, col, n);\n    \n    // Reflect the light ray\n    vec3 r = reflect(v, n);\n    vec3 rr = reflect(-lightDir, n);\n    \n    // Specular constant\n    float ks = 0.6;\n    \n    // Calculate specular reflection\n    colour += ks * max(0.0, dot(rr, v));\n    \n    // Reflect the scene\n    float t = 0.0;\n    for (float i = 0.0; i < reflectionQuality; i++)\n    {\n        vec3 q = p + r * (0.2 + t);\n        vec4 m = map(q);\n        vec3 refCol = m.rgb;\n        \n        if (m.a < 0.001)\n        {\n            vec3 n = calcNormal(q);\n\n            // Diffuse - default\n            refCol = diffuse(p, col, n);\n            \n            // Add the reflected object's colour.\n            colour += (1.0 - ks) * refCol * (1.0 / (1.0 + t * t * 0.1));\n            break;\n        }\n        \n        t += m.a * 0.8;\n    }\n    \n    // Return colour\n    return colour;\n}\n\n// General material function\nvec3 material(int matId, vec3 p, vec3 col, vec3 n, vec3 r)\n{\n    // Shade differently based on material\n    if (matId == 1)\n    {\n        // If it's set to low quality, don't even\n        // bother with the scene-based reflections...\n        \n        #ifdef LOWQUALITY\n        // Specular\n        col = 0.5 * specular(p, col, n, r);\n        #else\n        #ifdef USECUBEMAP\n        // Reflective + cubemap\n        col = 0.5 * reflective(p, col, n, r);\n        col += 0.5 * specular(p, col, n, r);\n        #else\n        // Default reflective\n        col = reflective(p, col, n, r);\n        #endif\n        #endif\n    }\n    else\n    {\n        // Map p to a uv co-ordinate and sample\n        // a texture\n        //vec2 uv = uvMap(p, n);\n        //col = texture(iChannel0, uv).rgb;\n        \n        // Diffuse - default\n        col = diffuse(p, col, n);\n    }\n    \n    // Then do shadows\n    #ifndef LOWQUALITY\n    float shv = sshadow(p, -normalize(lightDir), 0.02, 10.0, 2.0);\n    #else\n    float shv = shadow(p, -normalize(lightDir), 0.02, 10.0);\n    #endif\n    \n    // Just stop the ugly, pure black shadows\n    //if (shv < 0.5)\n    //    shv = 0.5;\n    \n    //\n    col *= shv;\n    \n    // Then return colour\n    return col;\n}\n\n// Raytrace function\n// o = origin\n// r = ray direction (vector)\nfloat trace(vec3 o, vec3 r, out vec3 colour)\n{\n    // t is the distance from the origin\n    float t = 0.0;\n    \n    // Extend the ray out\n    for (int i = 0; i < 128; i ++)\n    {\n        // Create a point - this should be\n        // the origin plus a ray with the same\n        // direction as r, but with length t.\n        vec3 p = o + r * t;\n        \n        // Material ID\n        int matId = 0;\n        \n        // Evaluate distance functions\n        vec4 m = map(p, matId);\n        float d = m.a;\n        \n        // If we have hit something, calculate normal\n        if (d < 0.001)\n        {\n            // Calculate normal\n            vec3 n = calcNormal(p);\n            \n            // Material\n            colour = material(matId, p, m.rgb, n, r);\n            \n            // Exit out of the loop, since we hit something\n            return t;\n        }\n        \n        // Increment t\n        t += d * LOD;\n    }\n    \n    // Return t\n    return t;\n}\n\n// Does all the raymarching stuff. Moved here so that\n// we can more easily do some post-processing to make\n// it look prettier.\nvec3 raymarch(vec2 uv)\n{\n    // Colour\n    vec3 colour = vec3(0.0);\n    \n    // Create a ray using the current pixel position\n    // The z-position here is the FOV. 1/2pi is a\n    // 90-degree field of view which works pretty well\n    vec3 r = normalize(vec3(uv, 3.14159 * 0.5));\n    \n    // Mouse co-ordinates\n    vec2 mp = (iMouse.xy / iResolution.xy * 2.0 - 1.0) * iResolution.x / iResolution.y;\n    \n    // X rotation (pitch)\n    float xrot = -mp.y;\n    r.yz *= mat2(cos(xrot), -sin(xrot), sin(xrot), cos(xrot));\n    \n    // Y rotation (yaw)\n    float yrot = -mp.x;\n    r.xz *= mat2(cos(yrot), -sin(yrot), sin(yrot), cos(yrot));\n    \n    // Set origin - this is the camera position\n    float dist = 2.0;\n    vec3 o = vec3(1.0 + sin(iTime), 1.0, -4.0);\n    \n    // Trace a ray\n    vec3 tc = vec3(0.0);\n    float t = trace(o, r, tc);\n    \n    // Simple fog - darkens objects based on how far they are\n    // f(x) = 1 / (1 + 0.1x^2)\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    // Set colour accordingly\n    //colour = fog;\n    colour = tc * fog;\n    \n    // Return colour\n    return colour;\n}\n\n////////////////////////////\n//                        //\n//   IMAGE PROCESSING     //\n//                        //\n////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Correct UV co-ordinates\n    uv = uv * 2.0 - 1.0;\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Grab colour\n    vec3 col = raymarch(uv);\n    \n    // Tone-mapping and gamma correction, as\n    // suggested by @MacSlow\n    col = col / (1.0 + col);\n    col = 0.2 * col + 0.8 * sqrt(col);\n    \n    // Output to buffer\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}