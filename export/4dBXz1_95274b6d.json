{"ver":"0.1","info":{"id":"4dBXz1","date":"1480950109","viewed":269,"name":"SAPIN d'noel","username":"MBR","description":"A single (unit) impulse point noise ","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["noise","anisotropic","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LICENSE: http://unlicense.org/\n\n// SAPIN = Simplex Ansiotropic Point Impulse Noise\n// (sapin d'noel = christmas tree in French)\n// toy implementation - lots of optimization room\n// some buggy numbers as well\n\n// mouse click and drag to pan\n// keyboard +/- zoom in and out\n\n// This viz is one sample/frag: params = 2D coordinate and frequency\n// frequency is varying in time.  Two example window function (right/\n// left side).\n\n// break the plane into simplex cells\n// generate a single point in cell\n// pseudo freq domain xform: window * carrier\n// (contributions from cell + 3 neighbors)\n// NOTE: Currently the point is a unit impluse instead of random magnitude.\n\n#define SQUARE\n\nconst float W = 1.11;\n\nconst float NUMBER_OF_CELLS_VERTICAL = 15.0;\n\n// simplex constants\nconst float F2D     = 0.36602540378443864676372317075294;\nconst float R2D     = 0.21132486540518711774542560974902;\nconst float SQRT_2  = 1.4142135623730950488016887242097;\nconst float JITTER  = (0.10566243270259355887271280487451 * SQRT_2);\n\n#define W0 0.5545497\n#define W1 0.308517\n#define W3 0.618034\n\n// don't remember who did this one.\nvoid rand(vec2 c, out vec4 h0, out vec4 h1)\n{\n  const vec2  OFF = vec2(26.0, 161.0);\n  const float FS  = 71.0;\n  const float IS  = 1.0/FS;\n  const vec2  K   = vec2(1.0/951.135664, 1.0/642.949883);\n\n  vec4 P = vec4(c.xy, c.xy + 1.0);\n\n  P  = P - floor(P * IS) * FS;\n  P += OFF.xyxy;\n  P *= P;\n  P  = P.xzxz * P.yyww;\n\n  h0 = fract(P * K.x);\n  h1 = fract(P * K.y);\n}\n\n\nfloat window0(float x)\n{\n  return exp(-3.14159*x);\n  //return 0.971285 + x*(-2.60608 + (2.62535 - 0.948581*x)*x);\n}\n\nfloat window1(float x)\n{\n  float r = x*W; r = 1.0-(r*r); return r*r*r;\n}\n\nvec4 weight(vec4 x)\n{\n  x = x * 2.0 - 1.0;\n#if defined(SQUARE)\n  return (1.0 - x * x) * sign(x);\n#else\n  return (x * x * x) - sign(x);\n#endif\n}\n\nfloat reconstruct0(in vec4 d, in vec4 h, float f)\n{\n  float r = 0.0;\n\n  if (d.x < 1.0) {\n    float w = window0(d.x);\n    float c = cos(h.x*f);\n    r += w * c;\n  }\n\n  if (d.y < 1.0) {\n    float w = window0(d.y);\n    float c = cos(h.y*f);\n    r += w * c;\n  }\n\n  if (d.z < 1.0) {\n    float w = window0(d.z);\n    float c = cos(h.z*f);\n   r += w * c;\n  }\n\n  if (d.w < 1.0) {\n    float w = window0(d.w);\n    float c = cos(h.w*f);\n    r += w * c;\n  }\n\n  return r;\n}\n\nfloat reconstruct1(in vec4 d, in vec4 h, float f)\n{\n  float r = 0.0;\n\n  if (d.x < 1.0) {\n    float w = window1(d.x);\n    float c = cos(h.x*f);\n    r += w * c;\n  }\n\n  if (d.y < 1.0) {\n    float w = window1(d.y);\n    float c = cos(h.y*f);\n    r += w * c;\n  }\n\n  if (d.z < 1.0) {\n    float w = window1(d.z);\n    float c = cos(h.z*f);\n   r += w * c;\n  }\n\n  if (d.w < 1.0) {\n    float w = window1(d.w);\n    float c = cos(h.w*f);\n    r += w * c;\n  }\n\n  return r;\n}\n\nfloat eval0(vec2 p, float f)\n{\n  // simplex coord\n  const vec3 DP = vec3(1.0-R2D, -R2D, 1.0-2.0*R2D) * SQRT_2;\n  \n  vec2 c0 = floor(p + dot(p, vec2(F2D)));\n  vec2 p0 = ((c0 - dot(c0, vec2(R2D)))-p) * SQRT_2;\n  \n  // jittered coordinate\n  vec4 hx, hy;\n  rand(c0, hx, hy);\n\n  hx      = weight(hx) * JITTER;\n  hy      = weight(hy) * JITTER;\n  hx     += p0.xxxx;\n  hy     += p0.yyyy;\n  hx.yzw += DP.xyz;\n  hy.yzw += DP.yxz;\n    \n  vec4 d2 = hx*hx + hy*hy;\n    \n  return reconstruct0(d2, hx, f);\n}\n\nfloat eval1(vec2 p, float f)\n{\n  // simplex coord\n  const vec3 DP = vec3(1.0-R2D, -R2D, 1.0-2.0*R2D) * SQRT_2;\n  \n  vec2 c0 = floor(p + dot(p, vec2(F2D)));\n  vec2 p0 = ((c0 - dot(c0, vec2(R2D)))-p) * SQRT_2;\n  \n  // jittered coordinate\n  vec4 hx, hy;\n  rand(c0, hx, hy);\n\n  hx      = weight(hx) * JITTER;\n  hy      = weight(hy) * JITTER;\n  hx     += p0.xxxx;\n  hy     += p0.yyyy;\n  hx.yzw += DP.xyz;\n  hy.yzw += DP.yxz;\n    \n  vec4 d2 = hx*hx + hy*hy;\n    \n  return reconstruct1(d2, hx, f);\n}\n\n\n\n//---- VISUALIAZATION JUNK BELOW HERE\n\n\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) { \n  return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() { return pz_readState(1.).z;   }\nvec3  pz_position()   { return pz_readState(3.).xyz; }\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2  uv = pz_initializeState(fragCoord)/iResolution.xy;   \n  \n  // bad hack to animate frequency\n  float c  = abs(cos(0.25*iTime))+.01;\n  float f  = 20.0*abs(c);\n\n  if (fragCoord.x > iResolution.x*.5)\n    f = eval1(NUMBER_OF_CELLS_VERTICAL*uv, f);\n  else\n    f = eval0(NUMBER_OF_CELLS_VERTICAL*uv, f);\n    \n  f = (f+1.0)*0.5; \n  \n  fragColor.rgb = vec3(f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// copy of:  https://www.shadertoy.com/view/XdG3Dh\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n//======Defines for state behaviour\n#define pz_resetOnMove 1\n#define pz_kinetic 0.95\n\nbool pz_checkCell(float nr, vec2 coord) {\n    return distance(pz_nr2vec(nr),coord)<=0.5;\n}\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\nconst float KEY_ADD   = 107.5/256.0;\nconst float KEY_SUBS  = 109.5/256.0;\nconst float KEY_EQUAL = 187.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\n\nbool checkKey(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.25)).x > 0.5;\n}\n\nbool checkKey(float key1, float key2)\n{\n    return checkKey(key1) || checkKey(key2);\n}\n\nbool checkKey(float key1, float key2, float key3)\n{\n    return checkKey(key1) || checkKey(key2) || checkKey(key3);\n}\n\nvoid pz_mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pz_initializeState();\n    fragColor = pz_stateSample(fragCoord/pz_realBufferResolution);\n    if (fragCoord.x < 1. \n     && fragCoord.y < 1.) {\n        //Lets store the initial buffersize at pos0 and use that for addressing\n        if (pz_originalBufferResolution.x == 0.0)\n            fragColor = vec4(pz_realBufferResolution,1.0,1.0);\n        \n    } else if (pz_checkCell(1.,fragCoord)) {\n        \n        // Use postion 1 to trigger screen size changes so we can clear other buffers on going fullscreen\n        if (distance(fragColor.xy,pz_realBufferResolution)>1.0 \n#if pz_resetOnMove            \n            || pz_readState(3.).w > 0.0\n#endif            \n           ) {\n            fragColor.xy = pz_realBufferResolution;\n            fragColor.z = 60.0;\n        } else {\n            if (fragColor.z > 0.0)\n                fragColor.z -= 1.0;\n        }\n        \n    } else if (pz_checkCell(2.,fragCoord)) {\n        // Store mouse delta if keydown\n        if (iMouse.w>0.5) {\n            if (fragColor.x>0.0) {\n                fragColor.zw = fragColor.xy - iMouse.xy;\n            } else {\n                fragColor.zw = vec2(0.0);\n            }\n            fragColor.xy = iMouse.xy;\n        } else {\n            \n            fragColor.xy = vec2(-1.,-1.);\n#ifdef pz_kinetic\n            fragColor.zw = length(fragColor.zw)>0.1?fragColor.zw*pz_kinetic:vec2(0.0,0.0);\n#else                             \n            fragColor.zw = vec2(0.0,0.0);\n#endif                             \n        }\n        \n    } else if (pz_checkCell(3.,fragCoord)) { \n        // Handle keyboard moves\n        vec2 delta = vec2( checkKey(KEY_LEFT ,KEY_A,KEY_Q)?-0.02:\n                           checkKey(KEY_RIGHT,KEY_D      )? 0.02:0.0\n                         , checkKey(KEY_DOWN ,KEY_S      )?-0.02:\n                           checkKey(KEY_UP   ,KEY_W,KEY_Z)? 0.02:0.0);\n        float factor = checkKey(KEY_SUBS, KEY_MINUS)?1.01:\n                       checkKey(KEY_ADD , KEY_EQUAL)?0.99:1.0;\n        if (fragColor.z<0.0000001)\n            fragColor.z = 1.0;\n        \n        //Update transform state\n        vec2 mouseDelta = pz_readState(2.).zw;\n        fragColor.z *= factor;\n        fragColor.xy += delta *  fragColor.z; //Add keyboard move\n        fragColor.xy += mouseDelta / iResolution.xy *  fragColor.z; //Add mouse delta\n        \n        //Store movement in w\n        fragColor.w = abs(factor-1.0)*3. + length(delta) + length(mouseDelta);\n                \n    } else\n        fragColor = vec4(0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pz_mainImage( fragColor, fragCoord );\n    \n    // Add multiple state handlers here\n}\n","name":"Buf A","description":"","type":"buffer"}]}