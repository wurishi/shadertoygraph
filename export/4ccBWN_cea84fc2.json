{"ver":"0.1","info":{"id":"4ccBWN","date":"1733081550","viewed":82,"name":"final_project_lich","username":"gabby934","description":"finalproject","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis code creates shadows and subsurface scattering from a height map. This is the data: \niChannel0: HeightMap\niChannel1: Normal Map (for comparison: You can use arrow buttons) \niChannel2: Outline3.png\n*/\n\nconst float pi=3.1416;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat smooth_step( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0);\n    t = t * t * (3.0 - 2.0 * t); // smoothstep formula   \n    return t;\n}\n\nfloat step2( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0); \n    return t;\n}\n\nvec4 dots(vec2 fragCoord, float size, float period)\n{\n    float red,green,blue;\n    red=green=blue=size;\n    \n    float periodT = period;//num per screen\n    float numDis = 1.00;\n    float width = 8.0;\n\n    float theta=80.0;\n    \n    float func[20];\n    vec2 p[20], dir[20];\n    int N=3; //dont change\n    float psi=0.5*360.0/float(N);\n    \n    for (int i=0; i<N; i++) {\n    float j= float(i);\n    p[i] = vec2(0, 0);\n    dir[i] = vec2(cos(2.0*pi*(theta+j*psi)/360.0), sin(2.0*pi*(theta+j*psi)/360.));\n    func[i]  = dot((fragCoord-p[i]), dir[i]);\n    func[i] = func[i] / (periodT);  \n    func[i] = abs(func[i] - round(func[i]));\n    }\n    \n    \n    float funcL2,funcL1,funcLmax,funcL0,funcLmin,funcLH, FUNC;\n    \n    funcL2=funcL1=funcLmax=funcL0=funcLmin=funcLH=func[0];\n    for (int i=1; i<N; i++) {\n    funcL2=sqrt(funcL2*funcL2+func[i]*func[i]);\n    funcL1=funcL1+func[i];\n    funcLmax=max(funcLmax,func[i]);\n    funcL0=sqrt(funcL0*funcL0*func[i]);\n    funcLH=1.0/(1.0/funcLH + 1.0/func[i]);\n    funcLmin=min(funcLmin,func[i]);\n    }\n    funcL2=1.2*funcL2/sqrt(float(N));\n    funcL1=2.0*funcL1/float(N);\n    funcLmax*=2.0;\n    funcL0*=2.0;\n    funcLH*=2.0*float(N);\n    funcLmin*=2.0;\n    \n    FUNC=funcL2;\n\n    float r=0.00; //Amount of noise for antialising \n     \n    //Dither\n    red = ceil(red - 2.0*FUNC+ r*(random(fragCoord)-0.5));\n    green = ceil(green - 2.0*FUNC + r*(random(fragCoord)-0.5));\n    blue = ceil(blue - 2.0*FUNC + r*(random(fragCoord)-0.5));\n    vec4 dot_color = vec4(red,green,blue,1.0);\n    return dot_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy; //Normalized pixel coordinates\n    \n    vec4 color = texture(iChannel3, uv);\n    \n    vec4 col = vec4(0.0);\n    vec4 img0 = texture(iChannel0, uv);\n    vec4 img1 = texture(iChannel1, uv);\n    vec4 img2 = texture(iChannel2, uv);\n    //vec4 img3 = vec4(1.0,1.0,1.0,1.0);\n    \n    vec4 blueColor = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 redColor = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 white = vec4(0.8,0.8,0.8,1.0);\n    \n    vec3 normals= 2.0*img1.rgb - vec3(1.0); \n    normals = normals/length(normals); \n    \n    int num_of_Samples=100; \n    float d=0.5;\n    float R=d; \n    vec3 shader_point=vec3(fragCoord,(1.0+d)*img0.x-d);\n    float a=5.0;\n    \n    vec3 light_position = vec3(iMouse.x,iMouse.y,3.00); \n    vec3 light_vector = light_position - shader_point;\n    vec3 light_dir=light_vector/length(light_vector);\n    \n    \n    for (int i=0; i<num_of_Samples; i++) {\n    vec3 pos=shader_point+float(i)*d*a*light_dir+ 0.00125*vec3(random(shader_point.xy));\n    vec2 pos_uv= pos.xy/iResolution.xy; \n    vec4 H = texture(iChannel0,pos_uv);\n    if(H.x>pos.z) R=R+d; \n    }\n    \n    float t=d/R;\n    t=2.0*pow(t,0.4);\n    t=clamp(t,0.0,1.0);\n    \n    \n    float dif= 0.5*dot(light_dir,normals)+0.5;\n    float W=pow(dif,10.0);\n    \n    /*\n    if(texelFetch( iChannel2, ivec2(KEY_UP,0),0).x == 1.0) t=dif;\n    if(texelFetch( iChannel2, ivec2(KEY_DOWN,0),0).x == 1.0)\n    {float W=0.10; t=W*dif+(1.0-W)*t;}\n    if(texelFetch( iChannel2, ivec2(KEY_LEFT,0),0).x == 1.0)\n    {W=W/2.0; t=W*dif+(1.0-W)*t;}\n    if(texelFetch( iChannel2, ivec2(KEY_RIGHT,0),0).x == 1.0)\n    {W=W/3.0; t=W*dif+(1.0-W)*t;}\n    */\n    \n    float size =0.5;\n    vec4 dot_color = dots(fragCoord, size, 10.0);\n    \n    col = white + (dots(fragCoord, 0.4,8.0)); \n    \n    if(t<0.8){\n        col = (blueColor + ((dots(fragCoord, 0.6,10.0))/2.0));\n    }\n    if(t<0.5){\n        col = redColor + (dots(fragCoord, 0.7,14.0)/2.5);\n    }\n    \n    col =  (col + color) - (img2);\n\n \n    fragColor = vec4(col);    // Output to screen\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThis code creates refraction and refraction from a normal map. This is the data: \niChannel0: Normal Map \n\n*/\n\nconst float pi=3.1416;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat smooth_step( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0);\n    t = t * t * (3.0 - 2.0 * t); // smoothstep formula   \n    return t;\n}\n\nfloat step2( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0); \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy; //Normalized pixel coordinates\n    \n    vec3 col = vec3(0.0);\n    vec3 border= vec3(0.0,0.0,0.0);\n    vec3 spec= vec3(1.0,1.0,0.9);\n    vec3 ambi= vec3(0.10,0.10,0.60);\n    vec3 diff= vec3(1.00,0.80,0.50);\n    vec4 img0 = texture(iChannel0, uv);\n    vec4 img1=  texture(iChannel1, uv);\n    vec4 img2=  texture(iChannel2, uv);\n    vec4 img3=  texture(iChannel3, uv);\n    float Kt=img1.a;\n    float a=img0.a;\n    ambi = (0.1*ambi+img1.xyz)/1.1;\n    diff = (0.1*diff+img1.xyz)/1.1;\n    float F;\n    float ior=2.0*iMouse.x/iResolution.x-1.0;\n    ior=pow(2.0,ior);\n    float fc[3]= float[3](0.1,0.00,2.50);\n\n \n    vec3 eye=vec3(0.0,0.0,10.0);\n    // eye = eye-vec3(fragCoord,0.0); //Eye is a Position \n    eye = eye/length(eye); \n    \n\n    vec3 normals; \n    vec3 reflect, refract;\n    float d=100.0;\n    vec3 lightpos = vec3(iMouse.x,iMouse.y,d/2.0);\n    //vec3 dir=lightpos/length(lightpos); // directional light\n    vec3 dir = lightpos-vec3(fragCoord,0.0);\n    dir=dir/length(dir); //Eye is a direction\n  \n    \n    normals= 2.0*img0.rgb - vec3(1.0); \n    normals = normals/length(normals); \n    float C=dot(eye,normals);\n    reflect = 2.0*C*normals-eye;\n    refract = -eye;\n    if(C*C-1.0+ior*ior>0.0) refract = 1.0/ior*(-eye+(C-sqrt(C*C-1.0+ior*ior))*normals) ;\n    float t= 0.5*dot(dir,normals)+0.5;\n    float s= 0.5*dot(reflect,dir)+0.5;\n    float b=1.0;\n    //Fake Fresnel\n    F=fc[2]*(1.0-C)*(1.0-C)+fc[1]*2.0*C*(1.0-C)+fc[0]*C*C;\n    F-clamp(F,0.0,1.0);\n    /* //Real Fresnel\n    float Ct=dot(refract,-normals);\n    F=abs((Ct-ior*C)/(Ct+ior*C));\n    F=pow(F,2.0);\n    if(C*C-1.0+ior*ior<0.0) F=1.0;\n    */\n   \n   \n    vec2 reflected_uv= (reflect.xy*d/(reflect.z+0.01) +fragCoord+lightpos.xy)/iResolution.xy;\n    vec4 reflected_env= vec4(0.0,0.0,0.0,0.0);\n    vec2 refracted_uv= (refract.xy*d/(reflect.z+0.01) +fragCoord)/iResolution.xy;\n    vec4 refracted_bg= vec4(1.0,1.0,1.0,1.0);\n    vec3 Fresnel_mix=F*reflected_env.xyz+(1.0-F)*refracted_bg.xyz;\n    \n   \n    \n    t=step2(0.1,0.99,t);\n    //t=t/0.99;\n    //s=pow(s,4.0);\n    s=step2(0.9,1.0,s);\n    //t=smooth_step(0.1,0.9,t);\n    //t=0.5*sin(2.0*pi*t/0.50)+0.5;\n    \n    \n    col = ambi*(1.0-t)+diff*t; \n    col= col*Kt+(1.0-Kt)*max(Fresnel_mix,spec*s) ; \n    col = col*a+(1.0-a)*img2.xyz; \n \n    fragColor = vec4(col,1.0);    // Output to screen\n}","name":"Buffer A","description":"","type":"buffer"}]}