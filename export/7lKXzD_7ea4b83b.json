{"ver":"0.1","info":{"id":"7lKXzD","date":"1641244499","viewed":245,"name":"LBM fluid","username":"elamolo","description":"fluid simulation.\nThis simulation uses the lattice boltzmann method which is very efficiant when running on the gpu.\nIf anyone knows how to skip frames (for example show every tenth frame) for a faster simulation, please let me know.\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pressure(in ivec2 p){\n    float rho = texelFetch( iChannel0, p, 0 ).z;\n    return(fract(rho/10.));\n    }\n    \nvec4 val4(in ivec2 p){\n    return texelFetch(iChannel0,p,0);\n    }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    ivec2 p = ivec2(fragCoord);\n    ivec2 o = (ivec2(fragCoord)/3)*3+1;\n    vec2 u =texelFetch( iChannel0, p, 0 ).xy;\n    float density = val4(p).z;\n    \n    float vorticity = val4(o+ivec2(0,3)).x- val4(o+ivec2(3,0)).y-val4(o+ivec2(0,-3)).x+val4(o+ivec2(-3,0)).y;\n    \n    float norm = 40.;\n    fragColor = vec4(norm*vorticity,-norm*vorticity,(.9/rho0)*(density-rho0),0);\n    //fragColor =(.6/rho0) * vec4(0,density-rho0,0,0);\n\n    \n    \n    //if(p-o == ivec2(0,0)){fragColor = fragColor + vec4(0.2,0,0,0);}\n    \n    if(!visdomain(p)){fragColor = vec4(0.2,0.2,0.2,0);}\n    if(visboundary(p)){fragColor = (p-o==ivec2(0,0)||p-o==ivec2(-1,1)||p-o==ivec2(1,-1))?\n    vec4(0.3,0.3,0.1,0):vec4(0.1,0.1,0.3,0);}\n\n    \n\n\n    \n    \n    \n    \n    \n    /*\n    for(int i = 0;i<100;i+=10){\n    for(int j = 0;j<450;j+=10){\n        if(p == ivec2(texelFetch(iChannel1,ivec2(i,j),0)).xy){fragColor = vec4(1,1,1,1);}}}*/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//STREAMING\n\n\nfloat val(in ivec2 p){\n    return texelFetch(iChannel0,p,0).w;\n    }\n\n\nvoid mainImage( out vec4 uRhoF, in vec2 fragCoord )\n{\n    \n    \n    //coordinate of pixel and coordinate of its center point.\n    ivec2 p = ivec2(fragCoord);\n    ivec2 o = (ivec2(fragCoord)/3)*3+1;\n    \n\n    if(domain(p)){\n\n\n        \n        //put streaming steps in here\n        float Fnew = 0.;\n        \n\n\n\n        \n        \n                     \n        if(domain(p-3*(p-o))){\n            Fnew = val(p-3*(p-o));\n            \n        }\n        else{\n            ivec2 bot_corner = ivec2(xcen,ycen) - ivec2(xres/2,yres/2)*3-ivec2(1,1);\n            ivec2 look = p-3*(p-o);\n            ivec2 diag = ivec2((xres+1)*3,(yres+1)*3);\n            Fnew = val( (((look-bot_corner) % diag) +diag) %diag + bot_corner );\n            \n        }\n        \n\n            \n\n        //write values to buffer A\n        uRhoF = vec4(0,0,0,Fnew);\n        \n        \n         //initial conditions\n\n        \n       \n        if(iFrame==0){\n            mat3 weights = mat3(1.0/36.0,1.0/9.0,1.0/36.0,\n                            1.0/9.0,4.0/9.0,1.0/9.0,\n                            1.0/36.0,1.0/9.0,1.0/36.0);\n            ivec2 intVi = p-o;\n            float wi = weights[intVi[1]+1][intVi[0]+1];\n            if(p-o==ivec2(1,0)){ uRhoF = vec4(0,0,0,(4.0/9.0)*rho0);\n                }\n            else{uRhoF = vec4(0,0,0,wi*rho0);\n                } \n            uRhoF += 0.02*rho0*hash(p);\n            }\n        \n        \n        \n        \n       \n       \n       \n        //mouse interaction\n        float d = (float(p.x)-iMouse.x)*(float(p.x)-iMouse.x)\n        +(float(p.y)-iMouse.y)*(float(p.y)-iMouse.y);\n        \n        float sDist = dot(vec2(p)-iMouse.xy,vec2(p)-iMouse.xy);\n\n        if( iMouse.z > 0. && sDist <= pow(mouse_r,2.)){\n                uRhoF = uRhoF + 0.1*vec4(0,0,0,rho0/9.);\n            }\n        \n            \n    }\n    else{uRhoF = vec4(0,0,0,0);}\n    \n    \n      \n}\n     ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//STREAMING BOUNDARY\n\n\nfloat val(in ivec2 p){\n    return texelFetch(iChannel0,p,0).w;\n    }\n\n\nvoid mainImage( out vec4 uRhoF, in vec2 fragCoord )\n{\n    \n    \n    //coordinate of pixel and coordinate of its center point.\n    ivec2 p = ivec2(fragCoord);\n    ivec2 o = (ivec2(fragCoord)/3)*3+1;\n    \n\n    if(boundary(p)){\n        float Fnew = val(p-2*(p-o));\n        uRhoF = vec4(0,0,0,Fnew);\n        }\n    else{uRhoF = vec4(0,0,0,val(p));}\n    \n      \n}\n     ","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//DETERMINE DENSITY AND FLOW VELOCITY\n\n//read values from buffer a\nfloat val(in ivec2 p){\n    return texelFetch(iChannel0,p,0).w;\n    }\n\n\nvoid mainImage( out vec4 uRhoF, in vec2 fragCoord )\n{\n    //coordinate of pixel and coordinate of its center point.\n    ivec2 p = ivec2(fragCoord);\n    ivec2 o = (ivec2(fragCoord)/3)*3+1;\n    \n    \n    if(domain(p)){\n        \n        \n        \n        mat3 f = mat3(val(o+ivec2(-1,-1)),val(o+ivec2(0,-1)),val(o+ivec2(1,-1)),\n                       val(o+ivec2(-1,0)),val(o+ivec2(0,0)),val(o+ivec2(1,0)),\n                       val(o+ivec2(-1,1)),val(o+ivec2(0,1)),val(o+ivec2(1,1)));      \n        \n\n\n        //determine density\n        float rho = 0.0;\n        \n        for(int i=0;i<=2;i++){\n            for(int j=0;j<=2;j++){\n                rho = rho+f[i][j];\n                }\n            }\n        \n\n        //determine u\n        vec2 u = vec2(0,0);\n        for(int i=0;i<=2;i++){\n            for(int j=0;j<=2;j++){\n                vec2 Vij = vec2(i-1,j-1);\n                u = u + Vij*f[j][i];\n                }\n            }\n        u = u/rho;\n        uRhoF = vec4(u,rho,texelFetch(iChannel0,p,0).w);\n        }\n    else{\n        uRhoF = vec4(0,0,0,0);\n        }\n    \n \n        \n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float tau = float(0.6);\nfloat rho0 = float(200);\n\n//(leave in this form eg:change 400's to half ur display length)\n\n\n#define xcen  320-320%3+1\n#define ycen  180-180%3+1\n//ensure center of display lies on 'o' type point\n\n\nint xres = 2*  100;//these gotta be even\nint yres = 2*  50;\n\nfloat hash(in ivec2 p){\n    return fract(fract(1000.*sin(float(p.x)))+fract(100.*sin(float(p.y))));\n    }\n\n//######|######}15\n//######|######}\n//------o------\n//######|######\n//######|######   we actually get yres' = yres+1\n\n\nfloat circ_r = float(10);\nfloat mouse_r = float(10);\nvec2 circ_xy = vec2(xcen,ycen)+ 3.*vec2(-70,0); //apromimate due to mod_3 rounding\n\n\nbool domain(in ivec2 p ){\n    return(p.x>=xcen-3*(xres/2)-1 && p.x<=xcen+3*xres/2+1\n            && p.y>=ycen-3*yres/2-1 && p.y<=ycen+3*yres/2+1);\n}\n\n\nbool boundary(in ivec2 p){\n    vec2 o = vec2((ivec2(p)/3)*3+1);\n    return(dot(o-circ_xy,o-circ_xy) < pow(3.*circ_r, 2.));\n}\n\n/*\nbool boundary(in ivec2 p){\n    ivec2 o = ivec2((ivec2(p)/3)*3+1);\n    return(o.x>200 && o.x<300 && o.y>200 && o.y<250);\n}*/\n\nbool visdomain(in ivec2 p){\n    return(p.x>=xcen-3*(xres/2-1)-1 && p.x<=xcen+3*(xres/2-1)+1\n            && p.y>=ycen-3*(yres/2-1)-1 && p.y<=ycen+3*(yres/2-1)+1);\n}\n\n\nbool visboundary(in ivec2 p){\n    vec2 o = vec2((ivec2(p)/3)*3+1);\n    return(dot(o-circ_xy,o-circ_xy) < pow(3.*(circ_r+1.), 2.));\n}   \n    \n\n    \n\n    \n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//COLLISIONS\n\nvec4 val4(in ivec2 p){\n    return texelFetch(iChannel0,p,0);\n    }\n\n\n\nvoid mainImage( out vec4 uRhoF, in vec2 fragCoord )\n{\n    //coordinate of pixel and coordinate of its center point.\n    ivec2 p = ivec2(fragCoord);\n    ivec2 o = (ivec2(fragCoord)/3)*3+1;\n    \n    \n    if(domain(p)){\n    \n        \n        mat3 fs = mat3(val4(o+ivec2(-1,1)).w,val4(o+ivec2(0,1)).w,val4(o+ivec2(1,1)).w,\n                       val4(o+ivec2(-1,0)).w,val4(o+ivec2(0,0)).w,val4(o+ivec2(1,0)).w,\n                       val4(o+ivec2(-1,-1)).w,val4(o+ivec2(0,-1)).w,val4(o+ivec2(1,-1)).w);\n\n\n        //read speed and density from prev buffer.\n        \n        uRhoF = val4(p);\n        \n        vec2 u = uRhoF.xy;\n        float rho = uRhoF.z;\n        float f = uRhoF.w;\n        \n        \n        if(boundary(p)){\n            uRhoF = val4(p);\n            }\n        else{\n            mat3 weights = mat3(1.0/36.0,1.0/9.0,1.0/36.0,\n                            1.0/9.0,4.0/9.0,1.0/9.0,\n                            1.0/36.0,1.0/9.0,1.0/36.0);\n\n\n\n\n            ivec2 intVi = p-o;\n            float wi = weights[intVi[1]+1][intVi[0]+1];\n            vec2 vi = vec2(p-o);\n            float fieq = wi*rho*( 1.+3.*dot(vi,u)+(9./2.)*dot(vi,u)*dot(vi,u)-(3./2.)*dot(u,u) );\n            //float fieq = (90./9.)*pow(0.25,dot(vi-u,vi-u));\n            float fNew = f + (fieq-f)/tau;\n\n            uRhoF = vec4(u,rho,fNew);\n\n\n\n            //initial conditions\n            if(iFrame==0 && boundary(p)){\n                uRhoF = vec4(0,0,0,0);\n\n                }\n            }\n        \n        }\n    else{uRhoF = vec4(0,0,0,0);}\n\n        \n}","name":"Buffer D","description":"","type":"buffer"}]}