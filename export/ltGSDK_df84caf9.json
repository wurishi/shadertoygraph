{"ver":"0.1","info":{"id":"ltGSDK","date":"1485901526","viewed":89,"name":"Testing raymarching","username":"perzon","description":"Some simple forms using raymarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["somesimpleformsusingraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float epsilon = 0.001;\nfloat udBox(vec3 p, vec3 b);\nfloat sdTorus(vec3 p, vec2 t);\nmat4 rotateY(float theta);\nmat4 rotateX(float theta);\nvec3 calc_gradient(vec3 p);\nfloat scene(vec3 p);\nbool march (out vec3, in vec3, in vec3);\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 cameraPosition = vec3(0.0, 1., -7.0);\n    vec3 cameraFocalPoint = vec3(-0.0, 1.2, -8.4);\n    cameraPosition.xy += (fragCoord.xy - iResolution.xy/2.0) / iResolution.xx;\n\n    vec3 hitPosition;\n    \n    bool hit = march(hitPosition, cameraPosition, normalize(cameraPosition - cameraFocalPoint));\n    \n    //fragColor += 0.2;\n    \n    \n    if(!hit) return;\n    \n    vec3 normal = normalize(calc_gradient(hitPosition));\n    vec3 light = vec3(-1.0, 2.0, -1.0);\n    vec3 lm = normalize(light - hitPosition);\n    vec3 rm = normalize(2.0 * dot(lm, normal) * normal - lm);\n    vec3 v = normalize(cameraPosition - hitPosition);\n    \n    \n    \n    fragColor.xyz += vec3(0.0, 0.0, 0.1) +\n        0.3 * dot(lm, normal) +\n        0.4 * pow(clamp(dot(rm, v),0.0,1.0), 4.0);\n    \n    \n    \n}\n\n\n\nbool march(out vec3 endPosition, in vec3 startPosition, in vec3 direction) {\n    \n    vec3 mdir = normalize(direction);\n    endPosition = startPosition;\n    \n    for(int i = 0; i < 400; i++) {\n        float distance = scene(endPosition);\n        \n        if(distance < epsilon)\n            return true;\n        \n        if(distance > 1000.0)\n            return false;\n        \n        endPosition += distance * mdir;\n    }\n    \n    \n    return false;\n    \n}\n\n\n\nfloat scene (vec3 p) {\n    \n    float smallcircle = length(p-vec3(0.0))-0.1;\n    float smallcircle2 = length(p-vec3(0.0))-0.14;\n    vec3 p3 = (rotateX(iTime)*vec4(p,1.0)).xyz;\n    vec3 p4 = (rotateY(iTime)*vec4(p3, 1.0)).xyz;\n    float square = udBox(p4-vec3(0.0,0.0,0.0), vec3(0.9,0.3,0.5)) ;\n    \n    vec3 p2 = (rotateY(-iTime) * vec4(p, 1.0)).xyz;\n    float rotatingcircle = length(p2-vec3(0.5, sin(iTime/2.0), 0.0))-abs(sin(iTime)/3.0);\n    float rotatingcircle2 = length(p2-vec3(-0.5, sin(-iTime), 0.0))-abs(sin(iTime)/3.0);\n    float rotatingcircle3 = length(p2-vec3(0.5, sin(iTime/2.0), 0.0))-abs(sin(iTime)/3.0)-0.1;\n    float rotatingcircle4 = length(p2-vec3(-0.5, sin(-iTime), 0.0))-abs(sin(iTime)/3.0)-0.1;\n    float circlehole = sdTorus(p2 - vec3(0.5,0.0, 0.0), vec2(0.4, 0.095));\n    float circlehole2 = sdTorus(p2 - vec3(0.5,0.0, 0.0), vec2(0.4, 0.18));\n    float circlehole3 = sdTorus(p2 - vec3(-0.5,0.0, 0.0), vec2(0.4, 0.095));\n    float circlehole4 = sdTorus(p2 - vec3(-0.5,0.0, 0.0), vec2(0.4, 0.18));\n    \n    \n    \n    \n    \n    \n \treturn\n        min(\n        \tmin(\n        \t\tmin(\n        \t\t\tmin(circlehole,smallcircle),\n           \t\t\tcirclehole3\n        \t\t),\n        \t\tmin(rotatingcircle, rotatingcircle2)\n        \t),\n        \tmax(\n        \t\t-min(\n        \t\t\tmin(rotatingcircle3, rotatingcircle4),\n        \t\t\tmin(smallcircle2, min(circlehole2,circlehole4))\n        \t\t),\n           \t\tsquare\n        \t)\n        );\n        \n        \n        \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udBox(vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        vec4(1, 0, 0 ,0),\n        vec4(0, c, -s,0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1));\n}\n\nvec3 calc_gradient(vec3 p) {\n    vec3 delta = vec3(epsilon, 0.0, 0.0);\n \treturn normalize(vec3 (\n        (scene(p + delta.xyz) - scene(p))/ epsilon, \n        (scene(p + delta.yxz) - scene(p))/ epsilon, \n        (scene(p + delta.zyx) - scene(p))/ epsilon\n   \t));\n    \n}\n\n\n\n","name":"Image","description":"","type":"image"}]}