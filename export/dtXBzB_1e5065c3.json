{"ver":"0.1","info":{"id":"dtXBzB","date":"1693138930","viewed":115,"name":"Simple Kuwahara filter","username":"hasenpfote","description":"[Kuwahara filter](https://en.wikipedia.org/wiki/Kuwahara_filter)\nLeft side: Original image, Right side: Filtered image\n- Dragging the mouse allows you to modify the applied range.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["filter","kuwahara","postprocess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**\n * This value specifies a natural number. Be cautious when choosing a value that is too large,\n * as it can significantly decrease performance.\n */\nconst int KUWAHARA_FILTER_RADIUS = 10;\n\nvec4 fetch(in vec2 pos){\n    return texture(iChannel0, pos / iResolution.xy).rgba;\n}\n\n/**\n * Applies the Kuwahara filter at the specified position.\n * https://en.wikipedia.org/wiki/Kuwahara_filter\n *\n * Given the potential increase in computational load with a high number of samples,\n * it might be beneficial to create a brightness map in advance if deemed necessary.\n */\n\n//\n// This is the original version at the time of release.\n//\nvec3 kuwahara_filter(in vec2 pos, in int a){\n    int side_length = a + 1;\n    int num_samples = side_length * side_length;\n    vec2[4] origins = vec2[](\n        pos + vec2(0., 0.), // 1st quadrant\n        pos + vec2(-a, 0.), // 2nd quadrant\n        pos + vec2(-a, -a), // 3rd quadrant\n        pos + vec2(0., -a)  // 4th quadrant\n    );\n\n    vec4 v_sum = vec4(0.);\n    vec4 v_sum_sq = vec4(0.);\n    for(int i = 0; i < side_length; i++){\n        for(int j = 0; j < side_length; j++){\n            vec2 xy = vec2(j, i);\n            vec4 _brightness = vec4(\n#ifdef ENABLE_PRECOMPUTED_BRIGHTNESS\n                fetch(origins[0] + xy).a,\n                fetch(origins[1] + xy).a,\n                fetch(origins[2] + xy).a,\n                fetch(origins[3] + xy).a\n#else\n                brightness(fetch(origins[0] + xy).rgb),\n                brightness(fetch(origins[1] + xy).rgb),\n                brightness(fetch(origins[2] + xy).rgb),\n                brightness(fetch(origins[3] + xy).rgb)\n#endif\n            );\n            v_sum += _brightness;\n            v_sum_sq += _brightness * _brightness;\n        }\n    }\n\n    vec4 v_variance = v_sum_sq / float(num_samples) - (v_sum * v_sum) / float(num_samples * num_samples);\n\n    int index = v_variance[0] < v_variance[1] ? 0 : 1;\n    index = v_variance[index] < v_variance[2] ? index : 2;\n    index = v_variance[index] < v_variance[3] ? index : 3;\n\n    vec3 color = vec3(0.);\n    for(int i = 0; i < side_length; i++){\n        for(int j = 0; j < side_length; j++){\n            color += fetch(origins[index] + vec2(j, i)).rgb;\n        }\n    }\n\n    return color / float(num_samples);\n}\n\n//\n// [2023-09-30] This is a version that reduces the number of texture fetches.\n//\nvec3 kuwahara_filter_2(in vec2 pos, in int a){\n    int side_length = a + 1;\n    int num_samples = side_length * side_length;\n    vec2[4] origins = vec2[](\n        pos + vec2(0., 0.), // 1st quadrant\n        pos + vec2(-a, 0.), // 2nd quadrant\n        pos + vec2(-a, -a), // 3rd quadrant\n        pos + vec2(0., -a)  // 4th quadrant\n    );\n\n    mat4 colors;\n    mat4 sums = mat4(0.);\n    vec4 v_sum_sq = vec4(0.);\n    for(int i = 0; i < side_length; i++){\n        for(int j = 0; j < side_length; j++){\n            vec2 xy = vec2(j, i);\n#ifdef ENABLE_PRECOMPUTED_BRIGHTNESS\n            colors[0] = fetch(origins[0] + xy);\n            colors[1] = fetch(origins[1] + xy);\n            colors[2] = fetch(origins[2] + xy);\n            colors[3] = fetch(origins[3] + xy);\n#else\n            colors[0].rgb = fetch(origins[0] + xy).rgb;\n            colors[0].a = brightness(colors[0].rgb);\n            colors[1].rgb = fetch(origins[1] + xy).rgb;\n            colors[1].a = brightness(colors[1].rgb);\n            colors[2].rgb = fetch(origins[2] + xy).rgb;\n            colors[2].a = brightness(colors[2].rgb);\n            colors[3].rgb = fetch(origins[3] + xy).rgb;\n            colors[3].a = brightness(colors[3].rgb);\n#endif\n            sums += colors;\n\n            vec4 _brightness = vec4(colors[0].a, colors[1].a, colors[2].a, colors[3].a);\n            v_sum_sq += _brightness * _brightness;\n        }\n    }\n\n    vec4 v_sum = vec4(sums[0].a, sums[1].a, sums[2].a, sums[3].a);\n    vec4 v_variance = v_sum_sq / float(num_samples) - (v_sum * v_sum) / float(num_samples * num_samples);\n\n    int index = v_variance[0] < v_variance[1] ? 0 : 1;\n    index = v_variance[index] < v_variance[2] ? index : 2;\n    index = v_variance[index] < v_variance[3] ? index : 3;\n\n    return sums[index].rgb / float(num_samples);\n}\n\n/**\n * Returns the weight of a separator at the specified position.\n */\nfloat vert_separator(in float pos, in float sep){\n    pos -= sep;\n    return pos * pos < 4. ? 0. : 1.;\n}\n\nfloat get_vert_separator_pos(){\n    return all(lessThan(iMouse.xy, vec2(0.5))) ? 0.5 * iResolution.x : iMouse.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = vec3(0.);\n    float vsep_pos = get_vert_separator_pos();\n\n    if(fragCoord.x < vsep_pos){\n        color = fetch(fragCoord).rgb;\n    }else{\n#if 0\n        color = kuwahara_filter(fragCoord, KUWAHARA_FILTER_RADIUS);\n#else\n        color = kuwahara_filter_2(fragCoord, KUWAHARA_FILTER_RADIUS);\n#endif\n    }\n    color *= vert_separator(fragCoord.x, vsep_pos);\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/**\n * Enable precomputed brightness map.\n * This is an option for cases where the KUWAHARA_FILTER_RADIUS is large.\n */\n#define ENABLE_PRECOMPUTED_BRIGHTNESS\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n\n/**\n * Returns the V (value/brightness) component of the HSV color representation\n * obtained from the specified RGB color.\n */\nfloat brightness(in vec3 color){\n    return max(color.r, max(color.g, color.b));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * Here, brightness precomputation is performed as needed.\n * If precomputation is not done, this pass becomes unnecessary.\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 color;\n#ifdef ENABLE_PRECOMPUTED_BRIGHTNESS\n    color.rgb = srgb_to_linear(texture(iChannel0, fragCoord / iResolution.xy).rgb);\n    color.a = brightness(color.rgb);\n#else\n    color = vec4(srgb_to_linear(texture(iChannel0, fragCoord / iResolution.xy).rgb), 1.);\n#endif\n    fragColor = color;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}