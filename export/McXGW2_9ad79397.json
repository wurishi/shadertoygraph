{"ver":"0.1","info":{"id":"McXGW2","date":"1703594404","viewed":68,"name":"fall into black hole","username":"Mik0","description":"light bending simulation. (spacey colors function is from chatgpt)","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["space","galaxy","blackhole","bending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float halfPi = acos(0.0);\nconst float convert = halfPi/90.0;\nconst float gravitationalConst = 6.674*pow(10.0, -11.0);\n\nstruct ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nray cam(vec3 pos, vec2 turn, float zoom, vec2 uv)\n{\n    vec3 forward = vec3(sin((turn.x)*convert)*cos((turn.y)*convert), cos((turn.x)*convert)*cos((turn.y)*convert), sin((turn.y)*convert));\n    vec3 right = vec3(sin((turn.x+90.0)*convert), cos((turn.x+90.0)*convert), 0);\n    vec3 up = vec3(sin((turn.x)*convert)*cos((turn.y+90.0)*convert), cos((turn.x)*convert)*cos((turn.y+90.0)*convert), sin((turn.y+90.0)*convert));\n    vec3 p = (forward*zoom)+(right*uv.x)+(up*uv.y);\n    return ray(pos, normalize(p));\n}\n\n#define HASHSCALE3 0.1031\n\nfloat hash(vec3 p) {\n    vec3 p3 = fract(p * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 cellNoise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    \n    float d = 1e30;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int k = -1; k <= 1; k++) {\n                vec3 offset = vec3(float(i), float(j), float(k));\n                vec3 neighbor = vec3(hash(pi + offset));\n                vec3 diff = offset + neighbor - pf;\n                float dist = dot(diff, diff);\n                d = min(d, dist);\n            }\n        }\n    }\n    return vec3(sqrt(d));\n}\n\nfloat worley(vec3 p) {\n    vec3 cell = floor(p);\n    vec3 fc = fract(p);\n    \n    float d = 1.0;\n    for (int xo = -1; xo <= 1; xo++) {\n        for (int yo = -1; yo <= 1; yo++) {\n            for (int zo = -1; zo <= 1; zo++) {\n                vec3 offset = vec3(float(xo), float(yo), float(zo));\n                vec3 neighbor = cellNoise(cell + offset);\n                vec3 diff = offset - fc + neighbor;\n                float dist = dot(diff, diff);\n                d = min(d, dist);\n            }\n        }\n    }\n    return sqrt(d);\n}\n\nfloat fractalWorley(vec3 p, int octaves, float lacunarity, float persistence) {\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float maxValue = 0.0; // Used for normalizing result to 0.0 - 1.0\n\n    for (int i = 0; i < octaves; i++) {\n        total += worley(p * frequency + float(i)) * amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n        maxValue += amplitude;\n    }\n\n    return total / maxValue; // Normalize to 0.0 - 1.0\n}\n\nfloat ring(vec3 vec, vec2 turn, float thickness)\n{\n    vec3 p = vec3(sin((turn.x)*convert)*cos((turn.y)*convert), cos((turn.x)*convert)*cos((turn.y)*convert), sin((turn.y)*convert));\n    return pow(1.0-abs(dot(vec, p)), thickness);\n}\n\n\nvec3 spaceyColors(float t) {\n\n    // Define spacey colors\n    vec3 color1 = vec3(12.0/255.0, 23.0/255.0, 44.0/255.0);    // Deep Space Blue\n    vec3 color2 = vec3(63.0/255.0, 27.0/255.0, 71.0/255.0);    // Galactic Purple\n    vec3 color3 = vec3(146.0/255.0, 45.0/255.0, 141.0/255.0);  // Nebula Pink\n    vec3 color4 = vec3(47.0/255.0, 184.0/255.0, 118.0/255.0);  // Aurora Green\n    vec3 color5 = vec3(29.0/255.0, 133.0/255.0, 142.0/255.0);  // Stardust Teal\n    vec3 color6 = vec3(52.0/255.0, 32.0/255.0, 92.0/255.0);    // Cosmic Indigo\n    vec3 color7 = vec3(87.0/255.0, 95.0/255.0, 103.0/255.0);   // Meteorite Gray\n    vec3 color8 = vec3(78.0/255.0, 122.0/255.0, 153.0/255.0);  // Comet Blue\n    vec3 color9 = vec3(255.0/255.0, 149.0/255.0, 45.0/255.0);  // Solar Flare Orange\n    vec3 color10 = vec3(5.0/255.0, 5.0/255.0, 5.0/255.0);      // Dark Matter Black\n\n    // Blend between colors using smoothstep\n    vec3 blendedColor = mix(color1, color2, smoothstep(0.0, 1.0, t));\n    blendedColor = mix(blendedColor, color3, smoothstep(0.1, 1.0, t));\n    blendedColor = mix(blendedColor, color4, smoothstep(0.2, 1.0, t));\n    blendedColor = mix(blendedColor, color5, smoothstep(0.3, 1.0, t));\n    blendedColor = mix(blendedColor, color6, smoothstep(0.4, 1.0, t));\n    blendedColor = mix(blendedColor, color7, smoothstep(0.5, 1.0, t));\n    blendedColor = mix(blendedColor, color8, smoothstep(0.6, 1.0, t));\n    blendedColor = mix(blendedColor, color9, smoothstep(0.7, 1.0, t));\n    blendedColor = mix(blendedColor, color10, smoothstep(0.8, 1.0, t));\n\n    return blendedColor;\n}\n\n\nvec3 sky(vec3 p)\n{\n    vec3 col;\n    col += vec3(ring(p, vec2(45, 60), 2.0))*abs(1.0-fractalWorley(p+100.0, 8, 2.0, 0.75));\n    col += pow(worley(p*2.0), 10.0)*0.3;\n    col *= (spaceyColors(col.x*2.0-0.5)*vec3(3.09, 2.0, 1.2)*2.0) + (sqrt(sqrt(spaceyColors(col.x*0.5))*vec3(1.0, 1.2, 1.5)));\n    col += pow(1.0-worley(p*20.0), 50.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 blackHolePos = vec3(0, 1000, 0); // meters away\n    float gravity = 1.5*pow(10.0, 20.0); // mass in kg\n    float speedOfLight = 299792458.0; // speed of light in m/s\n    float simulationStep;\n    float dist = 0.0;\n    bool hit = false;\n    float power = 99999.0;\n    \n    ray ray = cam(vec3(0, clamp(iTime*20.0, -999999.0, blackHolePos.y), 0), vec2(iMouse.x/iResolution.x*720.0-360.0, iMouse.y/iResolution.y*180.0-90.0), 0.5, uv);\n    \n    while(power>100.0 && !hit)\n    {\n        vec3 gravityDir = blackHolePos-ray.pos;\n        dist = length(gravityDir);\n        gravityDir/=dist;\n        simulationStep = dist*0.01/speedOfLight;\n        power = (gravity*gravitationalConst)/(dist*dist);\n        ray.dir = normalize(ray.dir+(gravityDir*power*simulationStep));\n        ray.pos+=ray.dir*speedOfLight*simulationStep;\n        hit = speedOfLight<power;\n    }\n    \n    \n\n    \n    vec3 col;\n    \n    if(hit)\n    {\n        col = vec3(0);\n    }\n    else\n    {\n        //col = vec3(pow(1.0-worley(ray.dir*20.0), 40.0));\n        col = sky(ray.dir);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}