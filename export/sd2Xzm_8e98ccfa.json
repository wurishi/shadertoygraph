{"ver":"0.1","info":{"id":"sd2Xzm","date":"1619966027","viewed":595,"name":"Improved Owen Scrambled Sobol","username":"Chrism","description":"Left: vanilla Sobol. Right: Owen scrambled Sobol.\n\nThe new method used by this improved shader is similar to the one in 'Practical Hash-Based Owen Scrambling' (http://www.jcgt.org/published/0009/04/01/) but using a much better hash made by Nathan Vegdahl.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["noise","random","sequence","hash","rand","lowdiscrepancy","scramble","owen","sobol"],"hasliked":0,"parentid":"3ldXzM","parentname":"Owen Scrambled Sobol Sequence"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ^ important stuff is in Buffer A\n\n// drawing code adapted from https://www.shadertoy.com/view/4dtBWH\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float m = smoothstep(0.0015, 0.003, abs(0.5 - fragCoord.x / iResolution.x));\n    \n    fragColor = clamp(texelFetch(iChannel0, ivec2(fragCoord), 0), 0., 1.) * 0.9 * m;\n    fragColor.rgb += (1. - m) * vec3(0.1, 0.2, 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// a great explanation of Owen scrambling and the method presented here:\n// https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\n\n#define SAMPS_PER_FRAME 4u\n\nuvec2 Sobol(uint n) {\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; n != 0u; n >>= 1u) {\n        if((n & 1u) != 0u)\n            p ^= d;\n        \n        d.x >>= 1u; // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\n// adapted from: https://www.shadertoy.com/view/3lcczS\nuint ReverseBits(uint x) {\n    x = ((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1);\n    x = ((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2);\n    x = ((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4);\n    x = ((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8);\n    return (x >> 16) | (x << 16);\n}\n\n// EDIT: updated with a new hash that fixes an issue with the old one.\n// details in the post linked at the top.\nuint OwenHash(uint x, uint seed) { // works best with random seeds\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\nuint OwenScramble(uint p, uint seed) {\n    p = ReverseBits(p);\n    p = OwenHash(p, seed);\n    return ReverseBits(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame == 0 ? vec4(0) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = fragCoord / iResolution.x;\n    float a = max(iResolution.y, iResolution.x / 2.) / iResolution.x;\n    \n    for (uint i = 0u; i < SAMPS_PER_FRAME; i++) {\n        uint iter = uint(iFrame) * SAMPS_PER_FRAME + i;\n        vec2 offset = vec2(0);\n        uvec2 ip = Sobol(iter);\n        \n        if(uv.x > 0.5) {\n            ip.x = OwenScramble(ip.x, 0xe7843fbfu);\n            ip.y = OwenScramble(ip.y, 0x8d8fb1e0u);\n            offset.x = 0.5;\n        }\n\n        vec2 p = vec2(ip) / float(0xffffffffu);        \n        vec2 screenPos = (p * a) + offset - uv;\n        \n        fragColor.rgb += 1. - smoothstep(0.0000015, 0.000006, dot(screenPos, screenPos));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}