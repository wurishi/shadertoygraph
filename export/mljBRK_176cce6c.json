{"ver":"0.1","info":{"id":"mljBRK","date":"1694263515","viewed":69,"name":"spinny cube field","username":"DeltaT","description":"not sure what's up with the small artefacts","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","mod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 128.\n\n// rotor funcs:\n\n// unoptimised version (mine):\n//vec3 rotTransform(vec3 v, vec4 R) {\n//    vec4 S = vec4(\n//        R.w*v.x - R.x*v.y + R.z*v.z,\n//        R.w*v.y + R.x*v.x - R.y*v.z,\n//        R.w*v.z + R.y*v.y - R.z*v.x,\n//        -R.x*v.z - R.y*v.x - R.z*v.y\n//    );\n//    return vec3(\n//        S.x*R.w - S.y*R.x - S.w*R.y + S.z*R.z,\n//        S.y*R.w + S.x*R.x - S.z*R.y - S.w*R.z,\n//        S.z*R.w - S.w*R.x + S.y*R.y - S.x*R.z\n//    );\n//}\n\n// more compact and optimised version:\n// (I have absolutely no clue why this works, but thanks to ENDESGA for giving it to me)\nvec3 rotTransform(vec3 v, vec4 R) {\n    vec3 uv = cross(R.yzx, v);\n    return v + 2.0f * (R.w * uv + cross(R.yzx, uv));\n}\n\n// rendering + other stuff:\n\nfloat distBox(vec3 p, float r) {\n    vec3 p1 = abs(p);\n    float d = length(max(p1-r, 0.));\n    float dsigned = min(max(max(p1.x-r, p1.y-r), p1.z-r), 0.);\n    return d + dsigned;\n}\n\nfloat distSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat distScene(vec3 p) {\n    float t = cos(iTime)+5.;\n    vec3 p1 = mod(p+t/2., t) - t/2.;\n    vec3 p2 = rotTransform(p1, vec4(sin(iTime/2.)*normalize(vec3(0.5, -0.5, 1)), cos(iTime/2.)));\n    return max(distBox(p2, 1.), -distSphere(p2, 1.3));\n}\n\nfloat rayMarch(vec3 pos, vec3 rd) {\n    float d = 0.;\n    while (d <= MAX_DIST) {\n        vec3 p = pos + rd*d;\n        float ds = distScene(p);\n        if (ds <= 0.001) { break; }\n        d += ds;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    float d = distScene(p);\n    vec3 n = d-vec3(distScene(p-e.xyy), distScene(p-e.yxy), distScene(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 render(vec3 campos, vec4 camrot, float fov, vec2 coord) {\n    vec3 raydir = rotTransform(normalize(vec3(coord.x, fov, coord.y)), camrot);\n    float d = rayMarch(campos, raydir);\n    if (d >= MAX_DIST) { return vec3(0); }\n    vec3 p = campos + raydir * d;\n    \n    vec3 n = getNormal(p);\n    return vec3(n.x/2. + 0.5, n.y/2. + 0.5, n.z/2. + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)*2./iResolution.yy;\n    \n    vec3 campos = vec3(0);\n    vec4 camrot = vec4(sin(iTime/2.)*normalize(vec3(1, 1, 1)), cos(iTime/2.));\n    \n    vec3 col = render(campos, camrot, 1.5, uv);\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}