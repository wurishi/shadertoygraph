{"ver":"0.1","info":{"id":"msyyzw","date":"1696179399","viewed":59,"name":"fractal croissant","username":"helenhsn","description":"inspired by inigo quilez's article on distance to fractals & some papers on julia set & mandelbrot sets.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 300.0\n#define SURF_DIST .01\n#define PI 3.14159265359\n#define OCTAVES 5\n\n// UTILS\n\n\nmat2 rotate(float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)); \n}\n\n// FRACTALS COMPUTATIONS\nvec4 z_n_Julia(vec4 q, float n, float r) {\n    /*\n    Computes the q (quaternion) to the power of n using polar coordinates\n    */\n    float phi = acos(q.x/r);\n     \n    vec3 n_hat = q.yzw/(r*sin(phi));\n    float n_phi = n*phi;\n    return pow(r, n) * vec4(cos(n_phi), n_hat*sin(n_phi));\n}\n\nvec3 z_n_Mandelbulb(vec3 z, float n, float r) {\n    /*\n    Computes the z to the power of n in spherical space\n    */\n    float th = acos(z.y/r);\n    float phi = asin(z.z/length(z.xz));\n     \n    float n_th = n*th;\n    float n_phi = n*phi;\n    float sin_nth = sin(n_th);\n    return pow(r, n) * vec3(sin_nth*sin(n_phi), cos(n_th), sin_nth*cos(n_phi));\n}\n\n\n\n// Hubbard-Douady potential SDF\nfloat distToJuliaSet(vec3 p) \n{\n    // transformations (rot, scale...)\n    p.xz*=rotate(cos(iTime*0.5)*0.8);\n    p.yx *= rotate(sin(iTime*0.9)*0.2);\n    \n    //vec4 c = normalize(vec4(.19, -.01, 0.9* sin(iTime*.9), 0.5));\n    vec4 c = vec4(clamp(-2.0*smoothstep(1.0, 0.0, iTime*0.06), -3.0, -0.6), 0.3*cos(iTime*0.5), 0.6*sin(iTime*0.4), 0.01);\n    \n    float n = 2.0;\n    float n_minus = n-1.0;\n    float size_bulb = 64.0;\n    vec4 z = vec4(p, 0.0);\n    float lz_2 = dot(z,z); // length squared of vector z\n    float r = sqrt(lz_2);\n    float dz = 1.0; // derivative\n\n    for (int i = 0; i<10; i++) \n    {\n        \n        dz = n * dz * pow(r, n_minus); //dz_k+1 = n * dz_k * length(z)**(n-1) + 1\n        z = c + z_n_Julia(z, n, r);\n        lz_2 = dot(z, z);\n        r = sqrt(lz_2);\n        if (r > size_bulb) break;\n    }\n    return abs(0.5*r*log(r)/dz);\n}\n\n\n// RAYMARCHING \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float d = 0.0;\n    for (int i = 0; i<MAX_STEPS; i++) \n    {\n        vec3 p = ro + rd*d;\n        float dist = distToJuliaSet(p);\n        d += dist;\n        \n        if (d > MAX_DIST || dist < SURF_DIST) \n        {\n            break;\n        }\n    }\n    return d;\n}\n\nvec3 initCamera(vec2 uv, vec3 eye, vec3 look_at, float zoom)\n{\n    vec3 fwd = normalize(look_at - eye);\n    vec3 rgt = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));\n    vec3 local_up = cross(rgt, fwd);\n    \n    return zoom*fwd + uv.x*rgt + uv.y * local_up;\n}\n\n\nvec3 getNormal(vec3 p) \n{\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 n = vec3(\n    distToJuliaSet(p+eps.xyy) - distToJuliaSet(p-eps.xyy), \n    distToJuliaSet(p+eps.yxy) - distToJuliaSet(p-eps.yxy),\n    distToJuliaSet(p+eps.yyx) - distToJuliaSet(p-eps.yyx));\n    return normalize(n);\n}\n\nvec3 getColor(vec3 eye, vec3 p, float sdf) \n{\n    vec3 l = normalize(vec3(0.0,-5.0, 3.0) - p);\n    vec3 l_2 = normalize(vec3(0.3,5.,-5.5)- p);\n    vec3 n = getNormal(p);\n    vec3 v = normalize(eye - p);\n    float intensity = clamp(dot(n, l), 0.0, 1.0);\n    float intensity_2 = clamp(dot(n, l_2), 0.0, 1.0);\n    \n    \n    vec3 color = vec3(0., 0., 0.);\n    if (p.y>-8.0)\n    {\n        vec3 h = normalize(l + v);\n        vec3 h_2 = normalize(l_2 + v);\n\n        //blinn phong spec\n        float spec = max(pow(dot(n, h), 32.0), 0.0);\n        float spec_2 = max(pow(dot(n, h_2), 64.0), 0.0);\n\n        color = vec3(0.0) * intensity;\n        color += vec3(250.0, 191.0, 186.0)/255. * intensity_2;\n\n        color += spec;\n        color += spec_2;\n    }\n    \n    float dist = rayMarch(p+n*SURF_DIST*2.0, l);\n    if (dist < length(l - p)) \n        intensity *=.6;\n        \n       \n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    \n    vec3 ro = vec3(0.0, 2.5, 3.0);\n    ro.xz = 3.0* vec2(cos(iTime*0.5), sin(iTime*3.0*0.5));\n    ro.yz =5.0* vec2(cos(-iTime*0.1), sin(iTime*3.0*0.1));\n    // mouse input\n    vec2 t = iMouse.xy/iResolution.xy ;\n    ro.yz *= rotate(-t.y*PI*2.0);\n    ro.xz *= rotate(-t.x*PI);\n    vec3 look_at = vec3(0.0, 0.0, 0.0); //look at\n    \n    float zoom = 0.9;\n    vec3 rd = initCamera(uv, ro, look_at, zoom);\n    \n    \n    float sdf = rayMarch(ro, rd);\n\n    vec3 intersection = ro + sdf * rd;\n    \n    \n    vec3 color = getColor(ro, intersection, sdf);\n\n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}