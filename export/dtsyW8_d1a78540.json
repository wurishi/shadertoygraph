{"ver":"0.1","info":{"id":"dtsyW8","date":"1690702247","viewed":28,"name":"Fork 20230722_3 O次郎 152","username":"drinkva","description":"O次郎 20230730","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["o"],"hasliked":0,"parentid":"mdBBRd","parentname":"20230722_3 O次郎"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sabs(float x,float a){\n    return sqrt(x*x+a);\n}\n\n//使う　smooth in\nfloat smin(float a,float b,float t){\n    return (a+b-sabs(a-b,t))*0.5;\n}\n\n//使わない Smooth Max\nfloat smax(float a,float b,float t){\n    return (a+b+sabs(b-a,t))*0.5;\n}\n\n\n//関数sminを定義\n//minよりもスムーズに区分けできる\n\nfloat circle(vec2 uv,float r){\n    return length(uv)-r;\n}\n\n\n//sd(sighed distance 距離関数)Box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvec2 prolong(vec2 p,float e){\n    p.x/=e;\n    return p;\n}\n\nvec2 rot(vec2 p,float a){\n    p*=mat2(cos(a),-sin(a),sin(a),cos(a));\n    return p;\n}\n\nfloat Ojiro(vec2 uv){\n\n    //胴体\n    float Ocircle = circle(uv,0.6);//\n    //O次郎右脚\n    float OlegRight = sdEllipse(uv-vec2(0.3,-0.55),vec2(0.26,0.1));\n    //O次郎左脚\n    float OlegLeft = sdEllipse(uv-vec2(-0.3,-0.55),vec2(0.26,0.1));\n    //O次郎右腕-卵\n    vec2 uv2 = uv;\n    uv2.x=abs(uv2.x);\n    uv2 -= vec2(0.55,-0.25);//4.並行移動\n    uv2 = rot(uv2,1.0);//3.回転\n    uv2 = prolong(uv2,0.4);//2.引き伸ばし\n    float Oarm = sdEgg(uv2,0.16,0.05);//1.Egg生成\n    \n    //脚と胴体結合　(smpoothmin)\n    float Obody = smin(Ocircle,OlegRight,0.009);\n    Obody = smin(Obody,OlegLeft,0.009);\n    //さらに両腕結合 (min)\n    Obody = min(Obody,Oarm);\n    return Obody;\n    \n}\n\nfloat Osmile(vec2 uv){\n    \n    //O次郎　目（左右）\n\n    vec2 uv4 = uv;\n    uv4.x = abs(uv4.x);//x軸方向に鏡移し\n    uv4 -= vec2(0.15,0.25);//4.並行移動\n    uv4 = rot(uv4,0.25);//3.回転\n    uv4 *= 10.; //2.縮小 \n    float Oeye = sdArc(uv4,vec2(sin(1.0),cos(1.0)),0.7,0.05);\n    Oeye = step(Oeye,0.);\n    \n    //O次郎-口\n    vec2 uv5= uv;\n    uv5 -= vec2(0.,0.13);//4.並行移動\n    float OMouth = sdBezier(uv5,vec2(-0.4,0.003),vec2(0.,-0.7),vec2(0.4,-0.01));\n    OMouth = step(OMouth,0.01);\n\n   //O次郎-髪\n    vec2 uv6= uv;\n    uv6 -= vec2(0.,0.);//並行移動\n    float OHair1 = sdBezier(uv6,vec2(0,0.6),vec2(0.1,0.8),vec2(-0.09,0.75));\n    float OHair2 = sdBezier(uv6,vec2(-0.09,0.75),vec2(0.1,0.7),vec2(0,0.9));\n    float OHair = min(OHair1,OHair2);\n    OHair = step(OHair,0.005);\n    float Osmile = Oeye+OMouth+OHair;\n    return Osmile;\n}\n\nfloat Osmile2(vec2 uv){\n    \n    //O次郎　目（左右）\n\n    vec2 uv4 = uv;\n    uv4.x=abs(uv4.x);\n    float Oeye = circle(uv4-vec2(0.2,0.25),0.02);\n    Oeye = step(Oeye,0.);\n    \n    //O次郎-口\n    vec2 uv5= uv;\n    uv5 -= vec2(0.,0.13);//4.並行移動\n    float OMouth = sdBezier(uv5,vec2(-0.3,-0.3),vec2(0.,0.2),vec2(0.3,-0.3));\n    OMouth = step(OMouth,0.01);\n\n   //O次郎-髪\n    vec2 uv6= uv;\n    uv6.x=-uv6.x;\n    uv6 -= vec2(0.,0.);//並行移動\n    float OHair1 = sdBezier(uv6,vec2(0,0.6),vec2(0.1,0.8),vec2(-0.09,0.75));\n    float OHair2 = sdBezier(uv6,vec2(-0.09,0.75),vec2(0.1,0.7),vec2(0,0.9));\n    float OHair = min(OHair1,OHair2);\n    OHair = step(OHair,0.005);\n    float Osmile = Oeye+OMouth+OHair;\n    return Osmile;\n}\n\n    \n    \n    \n    \n\nvoid mainImage(out vec4 fragColor ,in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.; //正規化・0-1の範囲にしてる\n    uv.x*=iResolution.x/iResolution.y;//アスペクト比調整\n    \n    uv*=sin(iTime*5.)+1.;//拡大縮小\n    uv= rot(uv, iTime);//回転\n    uv -= vec2(sin(iTime*1.),sin(iTime*1.));\n    uv=mod(uv*2.,4.)-2.;\n    //uv= rot(uv, iTime);//回転\n    \n    vec3 col;//定義\n    vec3 BGcolor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); //背景定義\n    vec3 Ocolor = vec3(1.,1.,0.6);\n    //Ocolor*=dot(uv-vec2(0.,-0.5),vec2(0.,1.));//内積・グラデーション\n    vec3 Osmilecolor = vec3(0.,0.,0.);//髪の色\n\n\n    //色塗り\n    /*if(Ojiro < 0.){\n        col=Ocolor;\n    }\n    else{\n        col= BGcolor;\n    }\n    */\n    float Ojiro = Ojiro(uv);\n    col=mix(BGcolor,Ocolor,step(Ojiro,0.));\n    \n    \n    \n    /*\n    if(Ojiro > 0.5 ){\n        col=vec3(1.,1.,1.);\n    }*/\n    \n    col = mix(col, vec3(1.,1.,1.),step(0.,Ojiro)*smoothstep(0.5,0.,Ojiro));\n    \n        \n    float Osmile = mix(Osmile(uv),Osmile2(uv),step(sin(iTime*3.),0.));//表情アニメーション\n    col = mix(col,Osmilecolor,Osmile);  \n\n    //出力\n    fragColor = vec4(col,1.);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n///////////////////////////////////////////////////\n\n　　　　　　　　　　　　楕円\n\n///////////////////////////////////////////////////\n\n*/\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if ( d < 0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n/*\n///////////////////////////////////////////////////\n\n　　　　　　　　　　　　卵\n\n///////////////////////////////////////////////////\n\n*/\n\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\n\n/*\n///////////////////////////////////////////////////\n\n　　　　　　　　　　　　目\n\n///////////////////////////////////////////////////\n\n*/\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n\n\n\n/*\n///////////////////////////////////////////////////\n\n　　　　　　　　　　　　口\n\n///////////////////////////////////////////////////\n\n*/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n","name":"Common","description":"","type":"common"}]}