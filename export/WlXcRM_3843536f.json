{"ver":"0.1","info":{"id":"WlXcRM","date":"1614348370","viewed":353,"name":"Raytracing kaoD","username":"kaoD","description":"Ray. Tracing.\n\nRaytracing.","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color *= .5;\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* CONSTANTS */\nconst float PI = 3.14159;\n\nconst float TWO_PI = 2. * PI;\n\nconst float TO_RAD = PI / 180.;\n\n/* TYPES */\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n};\n\nstruct RayHit {\n    float d;\n    vec3 n;\n    Material m;\n};\n    \nstruct Sphere {\n    vec3 p;\n    float r;\n};\n    \nstruct Quad {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n\n/* CONFIG */\n\n// Coordinate system -- Right handed\nconst vec3 UP = vec3(0, 1, 0);\n\n// Camera\nconst vec3 RO = vec3(0, 0, 0);\nconst vec3 RT = vec3(0, 0, 10);\nconst float FOVX = 120. * TO_RAD;\n\n// Ray tracing\nconst float MIN_RAY_HIT_DIST = .01;\nconst float FAR_DIST = 10000.;\nconst uint NUM_BOUNCES = 8u;\nconst float NORMAL_NUDGE = .01;\nconst uint SAMPLES = 10u;\n\n\n/* FUNCTIONS */\n\nvec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 SRGBToLinear(vec3 rgb)\n{\n    return rgb;\n     \n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 rd, float fovx) {\n    vec3 f = rd;\n    vec3 r = cross(UP, f);\n    vec3 u = cross(f, r);\n    \n    float zoom = 1. / tan(fovx / 2.);\n    vec3 c = ro + rd*zoom;\n    vec3 i = c + r*uv.x + u*uv.y;\n    \n    return normalize(i - ro);\n}\n\n\n// ¿?¿?\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w) {\n    return dot(cross(u, v), w);\n}\n\n//\n \nbool testQuadTrace(vec3 ro, vec3 rd, inout RayHit hit, Quad quad) {\n    vec3 a = quad.a, b = quad.b, c = quad.c, d = quad.d;\n    \n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(quad.c-quad.a, quad.c-quad.b));\n    \n    if (dot(normal, rd) > 0.) {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f) {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    } else {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rd.x) > .1) {\n        dist = (intersectPos.x - ro.x) / rd.x;\n    } else if (abs(rd.y) > .1) {\n        dist = (intersectPos.y - ro.y) / rd.y;\n    } else {\n        dist = (intersectPos.z - ro.z) / rd.z;\n    }\n    \n\tif (dist > MIN_RAY_HIT_DIST && dist < hit.d) {\n        hit.d = dist;        \n        hit.n = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n \nbool testSphereTrace(vec3 ro, vec3 rd, inout RayHit hit, Sphere sphere) {\n    vec3 m = ro - sphere.p;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - sphere.r * sphere.r;\n\n    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0) return false;\n\n\tfloat discr = b * b - c;\n\n    //a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.) return false;\n    \n    //ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat d = -b - sqrt(discr);\n    \n    if (d < 0.) {\n        fromInside = true;\n        d = -b + sqrt(discr);\n    }\n    \n\tif (d > MIN_RAY_HIT_DIST && d < hit.d) {\n        hit.d = d;        \n        hit.n = normalize((ro + rd*d) - sphere.p) * (fromInside ? -1. : 1.);\n        return true;\n    }\n    \n    return false;\n}\n\nconst Quad BOX_BACK = Quad(\n    vec3(-12.6, -12.6, 25),\n    vec3( 12.6, -12.6, 25),\n    vec3( 12.6,  12.6, 25),\n    vec3(-12.6,  12.6, 25)\n);\nconst Quad BOX_FLOOR = Quad(\n    vec3(-12.6, -12.45, 25),\n    vec3( 12.6, -12.45, 25),\n    vec3( 12.6, -12.45, 5),\n    vec3(-12.6, -12.45, 5)\n);\nconst Quad BOX_CEILING = Quad(\n    vec3(-12.6, 12.5, 25),\n    vec3( 12.6, 12.5, 25),\n    vec3( 12.6, 12.5, 15),\n    vec3(-12.6, 12.5, 15)\n);\nconst Quad BOX_LEFT = Quad(\n    vec3(-12.5, -12.6, 25),\n    vec3(-12.5, -12.6, 15),\n    vec3(-12.5,  12.6, 15),\n    vec3(-12.5,  12.6, 25)\n);\nconst Quad BOX_RIGHT = Quad(\n    vec3( 12.5, -12.6, 25),\n    vec3( 12.5, -12.6, 15),\n    vec3( 12.5,  12.6, 15),\n    vec3( 12.5,  12.6, 25)\n);\nconst Quad QUAD_LIGHT = Quad(\n    vec3(-5, 12.4, 22.5),\n    vec3( 5, 12.4, 22.5),\n    vec3( 5, 12.4, 17.5),\n    vec3(-5, 12.4, 17.5)\n);\nconst Sphere SPHERE_LEFT = Sphere(vec3(-9, -9.5, 20), 3.);\nconst Sphere SPHERE_CENTER = Sphere(vec3( 0, -9.5, 20), 3.);\nconst Sphere SPHERE_RIGHT = Sphere(vec3( 9, -9.5, 20), 3.);\n\nconst Material MATERIAL_METAL = Material(vec3(.7), vec3(0), .7);\nconst Material MATERIAL_WHITE = Material(vec3(.7), vec3(0), 1.);\nconst Material MATERIAL_RED = Material(vec3(.7, .1, .1), vec3(0), 0.);\nconst Material MATERIAL_GREEN = Material(vec3(.1, .7, .1), vec3(0), 1.);\nconst Material MATERIAL_LIGHT = Material(vec3(0), vec3(1., .9, .7) * 20., 1.);\nconst Material MATERIAL_YELLOW = Material(vec3(.9, .9, .5), vec3(0), 0.);\nconst Material MATERIAL_PINK = Material(vec3(.9, .5, .9), vec3(0), 1.);\nconst Material MATERIAL_CYAN = Material(vec3(.5, .9, .9), vec3(0), 1.);\n\nvoid testSceneTrace(vec3 ro, vec3 rd, inout RayHit hit) {\n    if (testQuadTrace(ro, rd, hit, BOX_BACK)) {\n        hit.m = MATERIAL_METAL;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_FLOOR)) {\n        hit.m = MATERIAL_WHITE;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_CEILING)) {\n        hit.m = MATERIAL_WHITE;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_LEFT)) {\n        hit.m = MATERIAL_RED;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_RIGHT)) {\n        hit.m = MATERIAL_GREEN;\n    }\n    if (testQuadTrace(ro, rd, hit, QUAD_LIGHT)) {\n        hit.m = MATERIAL_LIGHT;\n    }\n\tif (testSphereTrace(ro, rd, hit, SPHERE_LEFT)) {\n        hit.m = MATERIAL_YELLOW;\n    } \n    if (testSphereTrace(ro, rd, hit, SPHERE_CENTER)) {\n        hit.m = MATERIAL_PINK;\n    }\n\tif (testSphereTrace(ro, rd, hit, SPHERE_RIGHT)) {\n        hit.m = MATERIAL_CYAN;\n    }\n}\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * TWO_PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n \nvec3 getRayColor(vec3 ro, vec3 rd, inout uint rngState) {\n    vec3 ret = vec3(0);\n    vec3 throughput = vec3(1);\n     \n    for (uint i = 0u; i <= NUM_BOUNCES; i++) {\n        // shoot a ray out into the world\n        RayHit hit;\n        hit.d = FAR_DIST;\n        testSceneTrace(ro, rd, hit);\n         \n        // if the ray missed, we are done\n        if (hit.d == FAR_DIST) {\n            ret += SRGBToLinear(texture(iChannel1, rd).rgb) * throughput * .5;\n            break;\n        }\n            \n        // update the ray position\n        ro = (ro + rd * hit.d) + hit.n * NORMAL_NUDGE;\n\n        // Calculate a new ray direction.\n        // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n        // Perfectly smooth specular uses the reflection ray.\n        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n        vec3 diffuseRayDir = normalize(hit.n + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rd, hit.n);\n        rd = normalize(mix(specularRayDir, diffuseRayDir, hit.m.roughness * hit.m.roughness));\n\n        // add in emissive lighting\n        ret += hit.m.emissive * throughput;\n\n        // update the colorMultiplier\n        throughput *= hit.m.albedo;\n        \n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            // Add the energy we 'lose' by randomly terminating paths\n            throughput *= 1.0f / p;\n        }\n    }\n  \n    // return pixel color\n    return ret;\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    float AR = iResolution.x/iResolution.y;\n    \n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n    vec2 uv = (fragCoord + jitter)/iResolution.xy;\n    uv *= 2.;\n    uv -= 1.;\n    uv.y /= AR;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    m *= 2.;\n    m -= 1.;\n    m.y /= AR;\n    \n    vec3 ro = RO - vec3(m * 10., 0);\n    vec3 rd = normalize(RT - ro);\n    vec3 rdd = getRayDir(uv, ro, rd, FOVX);\n\n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    //bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    bool spacePressed = iMouse.xy != vec2(0,0) && iMouse.z >= 0. && iMouse.w >= 0.;\n\n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    lastFrameColor.a = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : lastFrameColor.a;\n    \n    for (uint i = 0u; i < SAMPLES; i++) {\n        vec3 color = getRayColor(ro, rdd, rngState);\n        color = mix(lastFrameColor.rgb, color, lastFrameColor.a);\n        lastFrameColor = vec4(color, 1.0f / (1.0f + (1.0f / lastFrameColor.a)));\n    }\n\n    // show the result\n    fragColor = lastFrameColor;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}