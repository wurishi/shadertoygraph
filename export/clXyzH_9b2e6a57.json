{"ver":"0.1","info":{"id":"clXyzH","date":"1690378145","viewed":87,"name":"GPU/VIP 6.4.15_release_20230726","username":"titolini72","description":"GPU/VIP 6.4.15_release_20230726","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["text","structures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsc3WH","filepath":"https://soundcloud.com/daliente/loreen-tattoo-sped-up-reverb","previewfilepath":"https://soundcloud.com/daliente/loreen-tattoo-sped-up-reverb","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Source \n// https://www.shadertoy.com/view/lsySzd\n// https://www.shadertoy.com/view/MdKXzc\n// https://www.shadertoy.com/view/ld2SzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 cA = texture(iChannel0, uv).xyz;\n    vec3 cB = texture(iChannel1, uv).xyz;\n\n    fragColor = vec4(cA,.1) + vec4(cB,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI=3.14159265358979323846;\nconst float value=0.0;\n\nfloat rand(in vec2 p,in float t)\n\t{\n\treturn fract(sin(dot(p+mod(t,1.0),vec2(12.9898,78.2333)))*43758.5453);\n\t}\n\nvec2 rotate(vec2 k,float t)\n\t{\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n\t}\n\nfloat scene1(vec3 p)\n\t{\n\tfloat speed=iTime*0.5;\n\tfloat ground=dot(p,vec3(0.0,1.0,0.0))+0.75;\n\tfloat t1=length(abs(mod(p.xyz,2.0)-1.0))-1.35+0.05*cos(PI*p.x*4.0)+0.05*sin(PI*p.z*4.0);\t// structure\n\tfloat t3=length(max(abs(mod(p.xyz,2.0)-1.0).xz-1.0,0.5))-0.075+0.1*cos(p.y*36.0);\t\t\t// structure slices\n\tfloat t5=length(abs(mod(p.xyz,0.5))-0.25)-0.975;\n\tfloat bubble_w=0.8+0.2*cos(PI*p.z)+0.2*cos(PI*p.x);\n\tfloat bubble=length(mod(p.xyz,0.125)-0.0625)-bubble_w;\n\tfloat hole_w=0.05;\n\tfloat hole=length(abs(mod(p.xz,1.0)-0.5))-hole_w;\n\tfloat tube_p=2.0-0.25*sin(PI*p.z*0.5);\n\tfloat tube_v=PI*8.0;\n    float tube_b=tube_p*0.02;\n\tfloat tube_w=tube_b+tube_b*cos(p.x*tube_v)*sin(p.y*tube_v)*cos(p.z*tube_v)+tube_b*sin(PI*p.z+speed*4.0);\n\tfloat tube=length(abs(mod(p.xy,tube_p)-tube_p*0.5))-tube_w;\n\treturn min(max(min(-t1,max(-hole-t5*0.375,ground+bubble)),t3+t5),tube);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\tfloat speed=iTime*0.5;\n    float ground_x=1.5*cos(PI*speed*0.125);\n    float ground_y=4.0-3.0*sin(PI*speed*0.125)+0.125*value;\n    float ground_z=-1.0-speed;\n\tvec2 position=fragCoord.xy/iResolution.xy;        \n\tvec2 p=-1.0+2.0*position;\n\tvec3 dir=normalize(vec3(p*vec2(1.625,1.0),0.75));\t// screen ratio (x,y) fov (z)\n\tdir.yz=rotate(dir.yz,PI*0.25*sin(PI*speed*0.125)-value*0.25);\t// rotation x\n\tdir.zx=rotate(dir.zx,PI*cos(-PI*speed*0.05));\t\t// rotation y\n\tdir.xy=rotate(dir.xy,PI*0.125*cos(PI*speed*0.125));\t// rotation z\n\tvec3 ray=vec3(ground_x,ground_y,ground_z);\n\tfloat t=0.0;\n\tconst int ray_n=96;\n\tfor(int i=0;i<ray_n;i++)\n\t\t{\n\t\tfloat k=scene1(ray+dir*t);\n        if(abs(k)<0.005) break;\n\t\tt+=k*0.5;\n\t\t}\n\tvec3 hit=ray+dir*t;\n\tvec2 h=vec2(-0.02,0.01); // light\n\tvec3 n=normalize(vec3(scene1(hit+h.xyy),scene1(hit+h.yxx),scene1(hit+h.yyx)));\n\tfloat c=(n.x+n.y+n.z)*0.1;\n\tvec3 color=vec3(c,c,c)-t*0.0625;\n    //color*=0.6+0.4*rand(vec2(t,t),iTime); // noise!\n\tfragColor=vec4(vec3(c+t*0.08,c+t*0.02,c*1.5-t*0.01)+color*color,1.0);\n\t}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 25. \n#define font_spacing .04\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Gu(p) t(C_,A_,p) + t(A_,M_,p) + t(M_,O_,p) + t(O_,I_,p) + t(I_,H_,p) + t(H_,K_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define Iu(p) t(A_,C_,p) + t(M_,O_,p) + t(B_,N_,p)\n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Pu(p) t(M_,A_,p) + t(A_,C_,p) + t(C_,I_,p) + t(I_,G_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define Uu(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,C_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define Vu(p) t(A_,N_,p) + t(N_,C_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n#define one(p) t(D_,C_,p) + t(C_,O_,p)\n#define two(p) t(D_,A_, p) + t(A_,C_,p) + t(C_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) + t(O_,L_,p)\n#define three(p) t(A_,C_,p) + t(G_,I_,p) + t(M_,O_,p) + t(C_,O_,p)\n#define four(p) t(N_,B_,p) + t(B_,G_,p) + t(G_,I_,p)\n\n#define five(p) t(A_,C_,p) + t(A_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(M_,O_,p)\n#define six(p)  t(C_,A_,p) + t(A_,M_,p) + t(M_,O_,p) + t(O_,I_,p) + t(I_,G_,p)\n#define seven(p) t(D_,A_,p) + t(A_,C_,p) + t(C_,O_,p) + t(H_,I_,p)\n#define eight(p) t(A_,C_,p) + t(C_,O_,p) + t(O_,M_,p) + t(M_,A_,p) + t(G_,I_,p)\n#define nine(p)  t(M_,O_,p) + t(O_,C_,p) + t(A_,C_,p) + t(A_,G_,p) + t(G_,I_,p)\n#define zero(p) t(A_,C_,p) + t(C_,O_,p) + t(O_,M_,p) + t(M_,A_,p)\n#define under(p) t(M_,O_,p)\n#define slash(p) t(M_,C_,p)\n\n\t\nvec2 caret_origin = vec2(1.2, .75);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += .9;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 11.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\t//vec3 col = vec3(0.8, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.0);\n        vec3 col;\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n\t/*d += T(r()); add(); d += H(r()); add(); d += E(r()); space();\n\td += Q(r()); add(); d += U(r()); add(); d += I(r()); add(); d += C(r()); add(); d += K(r()); space();\n\td += B(r()); add(); d += R(r()); add(); d += O(r()); add(); d += W(r()); add(); d += N(r()); space();\n\tnewline();\n\td += F(r()); add(); d += O(r()); add(); d += X(r()); space();\n\td += J(r()); add(); d += U(r()); add(); d += M(r()); add(); d += P(r()); add(); d += S(r()); space();\n\td += O(r()); add(); d += V(r()); add(); d += E(r()); add(); d += R(r()); space();\n\tnewline();\n\td += T(r()); add(); d += H(r()); add(); d += E(r()); space();\n\td += L(r()); add(); d += A(r()); add(); d += Z(r()); add(); d += Y(r()); space();\n\td += D(r()); add(); d += O(r()); add(); d += G(r()); add(); d += STOP(r()); add(); d += STOP(r()); add(); d += STOP(r());\n    */\n    space();space();space();\n    d += Gu(r());    add(); space(); d += Pu(r()); add(); space(); d += Uu(r()); space(); add(); d+= slash(r()); add(); space();\n    d += Vu(r());    add(); space(); d += Iu(r()); add(); space(); d += Pu(r()); \n\n    newline();    newline();    newline(); space();\n    d += six(r());   add(); d += STOP(r());  add(); d += four(r());  add(); d += STOP(r());  add();\n    d += one(r());   add(); d += five(r());  add(); d += under(r()); add(); d += R(r());     add();\n    d += E(r());     add(); d += L(r());     add(); d += E(r());     add(); d += A(r());     add();\n    d += S(r());     add(); d += E(r());     add(); d += under(r()); add(); d += two(r());   add();\n    d += zero(r());  add(); d += two(r());   add(); d += three(r()); add(); d += zero(r());  add();\n    d += seven(r()); add(); d += two(r());   add(); d += six(r());   add();\n    \n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.1, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    fragColor = vec4( col, 0.0 );\n}","name":"Buffer B","description":"","type":"buffer"}]}