{"ver":"0.1","info":{"id":"3t2BW3","date":"1600010060","viewed":91,"name":"Jan Albers plane","username":"HalbFettKaese","description":"A scene intended to be a recreation of Jan Albers's art concept.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586476925286766559\n\n#define MAX_ITERATION_LIMIT 1000\n\nconst vec3 light_direction = normalize(vec3(.3, 1, .5));\n\nconst float SunSize = .1;\n\nvec2 NormalizeUV(vec2 fragCoord) {\n    // Normalize pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    \n    if (iResolution.y < iResolution.x) {\n        uv.y *= iResolution.y / iResolution.x;\n    } else {\n    \tuv.x *= iResolution.x / iResolution.y;\n    }\n    return uv;\n}\n\nfloat Cuboid(vec3 p, vec3 r) {\n    // Signed Distance Function from p to cuboid going from 0 to r.\n\treturn max(\n        max(\n        \tmax(-p.x, p.x - r.x),\n        \tmax(-p.y, p.y - r.y)),\n        max(-p.z, p.z - r.z));\n}\n\nfloat Prism(vec3 p, int rot) {\n    // Signed Distance Function from p to triangular prism going from 0 to 1.\n    // The last 2 bits of rot determine the rotation of the prism.\n    float s = p.y;\n    if ((rot & 1) == 0) {\n    \ts = p.x;\n    }\n    if ((rot & 2) == 0) {\n    \ts = 1. - s;\n    }\n\treturn Cuboid(p, vec3(1., 1., mix(1., 0., max(0., min(s, 1.)))));\n}\n\nfloat time() {\n\treturn iTime;\n}\n\nint iMod(int x, int y) {\n\treturn x - y * (x/y);\n}\n\nint lcg(int x) {\n    int m = 13,\n    \tc = 28411,\n    \ta = 8121;\n\treturn iMod(x * a + c, m);\n}\n\nint h21(vec2 p) {\n    ivec2 id = ivec2(floor(p)) + int(floor(time()));\n    return (\n        (id.x + id.y) & 3) + ((lcg(id.x) + lcg(lcg(id.y))) & 2);\n}\n\nfloat Dist(vec3 p) {\n    vec2 id = p.xy;\n    p.xy = fract(p.xy);\n    vec3 u = vec3(1, 0, -1);\n    \n    // Union between the prisms in the 9 touching tiles\n    float d = 10.;\n    for (float x = -1.; x <= 1.; x += 1.) {\n        for (float y = -1.; y <= 1.; y += 1.) {\n        \td = min(d, Prism(p - vec3(x, y, 0), h21(id + vec2(x, y))));\n        }\n    }\n\treturn d / sqrt(2.1);\n}\n\nvec3 Normal(vec3 p, float sm) {\n\tvec2 u = vec2(sm, 0);\n    return normalize(vec3(\n    \tDist(p + u.xyy),\n    \tDist(p + u.yxy),\n    \tDist(p + u.yyx)\n    ) - vec3(Dist(p)));\n}\n\nvec2 rotate(vec2 uv, float t) {\n    uv -= .5;\n    uv *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    uv += .5;\n    return uv;\n}\n\nstruct RayReturnValue {\n\tvec3 p;\n    vec3 col;\n    float shadow;\n};\n\nconst float ZEnd = 3.51;\n    \nRayReturnValue Ray(vec3 ro, vec3 rd, float eps) {\n    float s = 0.;\n    \n    vec3 col = vec3(smoothstep(.999, .9995, dot(light_direction, rd)));\n    \n    int i;\n    vec3 p;\n    float shadow = 1.;\n    for (i = 0; i < MAX_ITERATION_LIMIT && s < 100. && p.z < ZEnd; i++) {\n        p = ro + s * rd;\n    \tfloat d = Dist(p);\n        \n        shadow = min(shadow, d/(s*SunSize));\n        s += d;\n        \n        if (d <= eps) {\n            vec3 n = Normal(p, .0001);\n            vec2 texUV;\n            if (abs(n.z) <= 0.01) {\n            \ttexUV = fract(vec2(p.x + p.y, p.z));\n            } else {\n            \ttexUV = fract(vec2(p.x, p.y));\n            \ttexUV = rotate(texUV, float((h21(p.xy) + 2) & 3) * PI / 2.);\n            }\n            col = texture(iChannel0, texUV).rgb * pow(.96, s) * (dot(n, light_direction) + 1.75) / 2.75;\n            break;\n        }\n    }\n    \n    if (i == MAX_ITERATION_LIMIT || s >= 100. || p.z <= ZEnd) shadow = 0.;\n\treturn RayReturnValue(p, col, shadow);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = NormalizeUV(fragCoord);\n    \n    // View Origin\n    vec3 vo = vec3(0.5, 0.5, 3.5);\n    \n    vo.xy += fract(time());\n    \n    vec2 M = (iMouse.xy / iResolution.xy - .5);\n    \n    M *= TWOPI;\n    \n    M.y = (iMouse.y / iResolution.y - .5) * PI;\n    if (!(iMouse.x > 0.0))\n        M = vec2(0);\n    M.x += PI;\n    \n    // View Direction\n    vec3 vd = vec3(sin(M.x) * cos(M.y), sin(M.y), cos(M.x) * cos(M.y));\n    \n    // Local forward, right and up axes\n    vec3 f = normalize(vd), \n         r = normalize(cross(vec3(0, 1, 0), f)), \n         u = cross(f, r);\n    float l = length(r);\n    \n    float focal_length = 0.5;\n    \n    // Ray Direction\n    vec3 rd = normalize(focal_length * f + uv.x * r + uv.y * u);\n    RayReturnValue ray = Ray(vo, rd, 0.001);\n    \n    vec3 col = ray.col;\n    \n\tfloat shadow = Ray(ray.p, light_direction, 0.00001).shadow;\n    col *= mix(.4, 1., shadow);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}