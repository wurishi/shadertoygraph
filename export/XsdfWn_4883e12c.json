{"ver":"0.1","info":{"id":"XsdfWn","date":"1524697249","viewed":353,"name":"Squarewave fourier series visual","username":"akhgary","description":"visualization of square wave Fourier series using plots i learned recently. with help of yours of course.\n\nspecial thanks to FabriceNeyret2 and iq\n\nit messes up after the timer grows up. probably because of loss of precision. reset timer to fix the issue.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["wave","sin","cos","plot","visualisation","fourier","squarewave","series","fourierseries"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fourier series:\n// http://mathworld.wolfram.com/FourierSeriesSquareWave.html\n// https://en.wikipedia.org/wiki/Fourier_series#Convergence\n// ========================================\n// distance formula used to plot squarewave smoothly\n// d = |fx-y|/sqrt(1+(dfx/dx)^2)\n// https://iquilezles.org/articles/distance\n// ========================================\n\nconst float pi = 3.14159265359;\nconst float scale = 2.0;\nconst float thickness = 3.0*scale;\n\nvec2 uvmap(vec2 uv)\n{\n    return (2.0*uv - iResolution.xy)/iResolution.y;\n}\n\n// color picker:\n// https://www.shadertoy.com/view/ll2cDc\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat squarewave(float n, float x, float l, float phase){\n    return 4.0/(n*pi)*sin(n*pi*x/l+phase);\n}\n\n// derivative of series terms.\nfloat dsquarewave(float n, float x, float l, float phase){\n    return 4.0/l*cos(n*pi*x/l+phase);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    float time = iTime/3.0;\n    vec3 col = vec3(0);\n    int terms = 10; // number of terms to produce\n    \n    float l = 1.0; // squarewave length divided by two.\n    vec2 c = vec2(0); // center of the circles\n    float sum = 0.0; // fourier series sum\n    float dsum = 0.0; // derivative of the sum\n    float tsum = 0.0; // sum for red line\n    \n    for(int i=0; i<terms; i++) {\n        float n = float(i)*2.0+1.0;\n        vec3 color = pickColor(n/float(terms*2));\n        \n        // calculate fourier series terms for circles\n        float term = squarewave(n, time, l, 0.0);\n        float cterm = squarewave(n, time, l, pi/2.0);\n        vec2 r = vec2(cterm,term);\n        \n        // plot circles\n        col += circle(uv,c,length(r),false)*color;\n        col += line(uv,c, c += r)*color;\n        \n        // calculate fourier series terms for wave plot\n        sum += squarewave(n, uv.x-time, l, 0.0);\n        dsum += dsquarewave(n, uv.x-time, l, 0.0);\n        tsum += term;\n    }\n    \n    // squarewave plot\n    float dist = abs(uv.y-sum)/sqrt(1.0+dsum*dsum);\n    col+=smoothstep(thickness/iResolution.y,0.0,dist);\n    \n    // red line\n    col+=(line(uv,c,vec2(+l,c.y))\n        + line(uv,c,vec2(-l,c.y))\n        + circle(uv,vec2(+l,tsum),0.01,true)\n        + circle(uv,vec2(-l,tsum),0.01,true))*vec3(1,0,0);\n    \n    // fill main circle\n    float term = squarewave(1., time, l, 0.0);\n    float cterm = squarewave(1., time, l, pi/2.0);\n    col+= circle(uv,vec2(0), sqrt(term*term+cterm*cterm), true)*.2*c.y*\n           vec3(sin(time), sin(time+2.*pi/3.), sin(time-2.*pi/3.));\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}