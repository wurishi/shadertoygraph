{"ver":"0.1","info":{"id":"mdK3RK","date":"1678843431","viewed":95,"name":"Hot Air Balloon","username":"ianertson","description":"Look around with the mouse :)\nNo idea why the smoke is so buggy... Seems to be working fine while rotating around with the mouse,\nbut not so good with the automatic camera thing.","likes":12,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarch","sdf","fire","smoke","hotairballoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 boxBlur(vec2 uv, in float f) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = clamp(1.0+f, 1.0, 2.5) / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\nvec3 shade(in vec2 uv) {\n    vec4 rgba = texture(iChannel0, uv).rgba;\n    vec3 col = rgba.rgb;\n    float depth = rgba.a;\n    \n    vec3 blurred = boxBlur(uv, depth*2.);\n    \n    return mix(col, blurred, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T ((iFrame <= 1 || iTime <= 0.00003) ? 30.109 : iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n\n#define AMBIENT 0.05\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) : \n        light.type == LIGHT_POINT ? normalize(light.p - p) : \n            normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xz, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xy, round(adot(n, vec3(0, 0, 1))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    \n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0001) return wn;\n    cp = normalize(cp);   \n    return normalize(mix(wn, normalize(wn+cp), mx));\n}\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\nfloat voronoi(in vec2 p, in float seed){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n\n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            \n            if(dist<dmin){\n                dmin = dist;\n                res = lattice + offset;\n            }\n        }\n    }\n    \n    return sqrt(dmin);\n}\n\nbool ibox(\n    vec3 org,\n    vec3 rd,\n    vec3 boxPos,\n    vec3 boxSize,\n    float tnear,\n    float tfar\n ) {\n    vec3 inv_dir = 1.0 / rd;\n    vec3 box_min = boxPos-boxSize*0.5;\n    vec3 box_max = boxPos+boxSize*0.5;\n    vec3 tmin = (box_min - org) * inv_dir;\n    vec3 tmax = (box_max - org) * inv_dir;\n    vec3 t0 = min(tmin, tmax);\n    vec3 t1 = max(tmin, tmax);\n    vec2 v = vec2(\n        max(t0.x, max(t0.y, max(t0.z, tnear))),\n        min(t1.x, min(t1.y, min(t1.z, tfar))));\n        \n    return v.x < v.y;\n}\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return max(0.0, 1.0-length(pa - ba * h)/t);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_AIR_BALLOON 3\n#define ID_AIR_BALLOON_BASKET 4\n#define ID_AIR_BALLOON_PILLAR 5\n#define ID_AIR_BALLOON_CONTRAP 6\n#define ID_AIR_BALLOON_GAS 7\n#define ID_FIRE 8\n#define ID_ROPE 9\n\n#define NOISE(P, seed, lod) (textureLod(iChannel3, (p + (seed*1.938387154))/256., lod).xyz)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    vec3 n = vec3(0.0);\n    float div = 0.0;\n    float amp = 1.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    \n    return n/div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    vec3 n = vec3(0.0);\n    float div = 0.0;\n    float amp = 1.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy+n.z) * warp;\n    }\n    \n    return n/div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    };\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nvec3 noise3D(in vec3 p, in float seed) { return textureLod(iChannel1, (p+(seed*1.928271731))/10., 0.0).xyz;}\n\nvec3 snoise3D(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n    mix(\n        mix(noise3D(id + vec3(0, 0, 0), seed), noise3D(id + vec3(1, 0, 0), seed), lv.x),\n        mix(noise3D(id + vec3(0, 1, 0), seed), noise3D(id + vec3(1, 1, 0), seed), lv.x),\n        lv.y\n    ),\n    mix(\n        mix(noise3D(id + vec3(0, 0, 1), seed), noise3D(id + vec3(1, 0, 1), seed), lv.x),\n        mix(noise3D(id + vec3(0, 1, 1), seed), noise3D(id + vec3(1, 1, 1), seed), lv.x),\n        lv.y\n    ), lv.z);\n}\n\nvec3 snoise3D(in vec3 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*snoise3D(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n / div;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h)-r;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nvec4 fireNoise(in vec3 p, const in int octaves) {\n    vec4 n = vec4(0.0);\n    \n    float time = T*0.8;\n    vec3 shift = vec3(cos(time*0.5)*0.8, sin(time)*1.5, sin((time*0.5)+2.292981823)*0.8);\n    \n    float div = 0.0;\n    float amp = 1.0;\n    float freq = 1.5;\n    \n    p += shift;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n.x += amp * (cos(p.x*6.*freq));\n        n.z += amp * (sin(p.z*6.*freq));\n        n.y += amp * (sin(p.y*4.*freq));\n        n.w += amp * (cos(p.y*4.*freq));\n        \n        p += ((n.x+n.z+n.y+n.w)*(freq))/64.;\n        freq *= 2.0;\n        div += amp;\n        amp /= 2.0;\n        \n    }\n    \n    return n / div;\n}\n\nfloat fireSDF(in vec3 p, in float r) {\n    vec4 n = fireNoise(p, 5);\n    vec4 n2 = fireNoise(p.zxy, 5);\n    \n    p.y += (n2.x*n2.z)*0.5;\n    r -= smoothstep(0.0, 0.09, length(p.xz)*pow(max(0.0, dot(p, vec3(0, -1., 0))), 2.));\n    return distance(p, vec3(n.y*0.1, (p.y/4.)+((n.x*n.z)*0.1), n.w*0.1)) - r;\n}\n\n#define AIR_BALLOON_POS vec3(0, 1.0 + (0.5+(0.5*sin(T))), 0)\n\nfloat airBalloonSDF(in vec3 p, in int skip, inout int id) {\n    p -= AIR_BALLOON_POS;\n    id = ID_AIR_BALLOON;\n    float dist = FAR;\n    \n    vec3 basketSize = vec3(0.8, 0.6, 0.8);\n    \n    float basket = boxSDF(p - vec3(0, basketSize.y, 0), basketSize)-0.015;\n    float basketInside = boxSDF(p - vec3(0, basketSize.y+0.19, 0), basketSize*0.83);\n    basket = smax(basket, -basketInside, 0.1)-0.01;\n    \n    float pillarHeight = 2.5;\n    float pillarR = 0.06;\n    float pillar = lineSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(basketSize.x/2., basketSize.y*2., basketSize.z/2.), vec3(0, 0, 0), vec3(0, pillarHeight, 0), pillarR);\n    \n    float holder1 = lineSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(-basketSize.x, basketSize.y*2., basketSize.z), vec3(0, 0, 0), vec3(basketSize.x*2., 0, 0), pillarR);\n    float holder2 = lineSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(basketSize.x, basketSize.y*2., -basketSize.z), vec3(0, 0, 0), vec3(0., 0, basketSize.z*2.), pillarR);\n    float holder = min(holder1, holder2);\n    \n    holder = smin(holder, pillar, clamp(length(abs(p.xz)), 0.0, 1.0));\n    \n    float contrapY = pillarHeight/3.;\n    float contrapR = pillarR*0.6;\n    vec3 contrapSize = basketSize*0.5;\n    float contrap1 = lineSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(-basketSize.x, (basketSize.y*2.)+contrapY, basketSize.z/2.), vec3(0, 0, 0), vec3(basketSize.x*1.5, 0, 0), contrapR);\n    float contrap2 = lineSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(basketSize.x/2., (basketSize.y*2.)+contrapY, -basketSize.z), vec3(0, 0, 0), vec3(0, 0, basketSize.z*1.5), contrapR);\n    float contrap3 = lineSDF(vec3(p.x, p.y, p.z) -\n        vec3(-basketSize.x/2., (basketSize.y*2.)+contrapY, -basketSize.z/2.),\n        vec3(0, 0, 0), vec3(basketSize.x, 0, basketSize.z), contrapR);\n    float contrap4 = lineSDF(vec3(p.x, p.y, p.z) -\n        vec3(basketSize.x/2., (basketSize.y*2.)+contrapY, -basketSize.z/2.),\n        vec3(0, 0, 0), vec3(-basketSize.x, 0, basketSize.z), contrapR);\n\n    float contrap = min(contrap1, contrap2);\n    contrap = min(contrap4, min(contrap, contrap3));\n    \n    float gasHeight = 0.22;\n    float gasR = 0.2;\n    float gas = cylSDF(p - vec3(0, (basketSize.y*2.)+contrapY, 0), vec3(0, 0, 0), vec3(0, gasHeight, 0), gasR);\n    float gasInside = cylSDF(p - vec3(0, (basketSize.y*2.)+contrapY+0.1, 0), vec3(0, 0, 0), vec3(0, gasHeight*0.9, 0), gasR*0.87);\n    gas = smax(gas, -gasInside, 0.01);\n    float fireR = gasR*1.5;\n    float fire = fireSDF(p -  vec3(0, (basketSize.y*2.)+contrapY+(fireR*2.), 0), fireR);\n    \n    \n    float balloonR = 2.5;\n    float gg = smoothstep(0., 16.0, length(p.xz)*max(0.0, -p.y+7.));\n    float balloon = distance(p - vec3(0, (balloonR)+(basketSize.y*2.)+((pillarHeight/2.)-0.2), 0), vec3(0, p.y/4., 0)) - (balloonR / (1.0 + gg));\n    float balloonInside = distance(p - vec3(0, (balloonR)+(basketSize.y*2.)+((pillarHeight/2.)-0.8), 0), vec3(0, p.y/4., 0)) - 0.7*(balloonR / (1.0 + gg));\n\n    balloon = mix(balloon, smax(balloon, -balloonInside, 0.1), smoothstep(0.0, 0.2, max(0.0, -p.y+((basketSize.y*2.0)+contrapY+9.))));\n    \n    balloon += smoothstep(0.0, 4.5, max(0.0, dot(p, vec3(0, 1, 0)))*max(0.0, -p.y+((basketSize.y*2.0)+contrapY+1.5)));\n    balloon = balloon / 2.2;\n    \n    balloon = smin(balloon, pillar, 0.3);\n    SAMPLE(balloon, ID_AIR_BALLOON);\n    \n    SAMPLE(holder, ID_AIR_BALLOON_PILLAR);\n    SAMPLE(pillar, ID_AIR_BALLOON_PILLAR);\n    SAMPLE(basket, ID_AIR_BALLOON_BASKET);\n    SAMPLE(contrap, ID_AIR_BALLOON_CONTRAP);\n    SAMPLE(gas, ID_AIR_BALLOON_GAS);\n    SAMPLE(fire, ID_FIRE);\n    \n    return dist;\n}\n\nfloat ropeSDF(in vec3 p, vec3 attach) {\n    vec3 start = vec3(-4., 0, 0);\n    vec3 center = (start + attach)*0.5;\n    \n    attach.y += smoothstep(0.0, 4., pow(distance(p, center), 2.));\n    \n    float d = lineSDF(p, start, attach, 0.05);\n    return d;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n    int airBalloonId = 0;\n    float airBalloon = airBalloonSDF(p, skip, airBalloonId);\n    \n    float rope = ropeSDF(p, AIR_BALLOON_POS+vec3(-0.5, -0.5, 0));\n    SAMPLE(rope, ID_ROPE);\n    \n    SAMPLE(airBalloon, airBalloonId);\n    //float box = boxSDF(p - vec3(0, 1, 0), vec3(1.0));\n   // SAMPLE(box, ID_BOX);\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(data.id == ID_FIRE ? 0.02 : 0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= 0.00003) return 1.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    float d = 0.0;\n    float r = 1.0;\n    \n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    return clamp((r + (d / (1.0+d)))/2., 0.0, 1.0);\n}\n\nfloat smokeSDF(in vec3 p, in vec3 pos) {\n    \n    float time = T*0.5;\n    vec3 shift = vec3(0, -time*0.8, 0);\n    vec3 n1 = snoise3D(p+shift, 0.02813156, 3.09);\n    shift += (n1*0.05) + vec3(cos(time+(n1.x*0.1)), sin(time+9.9872711223+(n1.y*0.1)), sin(time+(n1.z*0.1)));\n    vec3 n2 = snoise3D(p+(shift*0.5), 4.8372156933, 4.0) * 2.0- 1.0;\n    vec3 n = reflect(n1, n2);\n    \n    float dd = 1.0/max(0.0001, distance(p, pos));\n    \n    return (clamp((length(n+((dot(n1, n2))/2.)) - (length(p/(2.2+dd)))), 0.0, 1.0));\n}\n\n\nvec3 marchSmoke(in vec3 smokePos, in vec3 ro, in vec3 rd, in float minD, in Light light1, in Light light2) {\n    float d = 0.0;\n    vec3 col = vec3(0.0);\n    float sum = 0.0;\n    vec3 pp = smokePos;\n    smokePos = ro;\n    for (float d = 10.0; d > 0.002;  d -= 0.5) {\n        vec3 p = ro+(rd*d);\n        \n        vec3 dir = normalize(pp -p);\n    \n        p += dir * 0.01*max(0.0, 10.0 - (d*d));\n        p.y -= 0.01;\n        \n        float next = smokeSDF(p, smokePos);\n        sum += next;\n        \n       \n        \n        if (sum > 0.02) {\n            vec3 L = getLightDir(light1, p);\n            vec3 nextCol = vec3(0.0);\n            nextCol += max(0.001, next - (smokeSDF(p + (L), smokePos))) * light1.s * mix(light1.c, vec3(1.0), 0.61);\n        \n            L = getLightDir(light2, p);\n            nextCol += max(0.001, next - (smokeSDF(p + (L), smokePos))) * light2.s * mix(light2.c, vec3(1.0), 0.61);\n            \n            nextCol *= smoothstep(0.0, 1.0, max(0.00001, max(2., minD) - (sum*16.)));\n            //nextCol *= smoothstep(0.0, 1., max(0.0001, minD)/(sum*20.));\n            col += max(nextCol, 0.);// / 1.5;\n        }\n        \n        \n    }\n    \n\n    \n    return max(col, 0.);\n}\n\n\n//#define DEBUG_TEXTURE fireTexture\n\nvec3 getFireColor(in float time) {\n    float transTime = 0.9;\n    float cycle = mod(time, 5.0 + transTime);\n    vec3 c1 = rgb(255, 134, 5);\n    vec3 c2 = rgb(206, 95, 12);\n    vec3 c3 = rgb(247, 209, 90);\n    vec3 c4 = rgb(244, 152, 58);\n    vec3 c5 = rgb(113, 17, 1);\n    \n    \n    vec3 col = c1;\n    float frame = 1.0;\n    col = mix(col, c2, smoothstep(frame - transTime, frame + transTime, cycle));\n    frame += 1.0;\n    \n    col = mix(col, c3, smoothstep(frame - transTime, frame + transTime, cycle));\n    frame += 1.0;\n    \n    col = mix(col, c4, smoothstep(frame - transTime, frame + transTime, cycle));\n    frame += 1.0;\n    \n    col = mix(col, c5, smoothstep(frame - transTime, frame + transTime, cycle));\n    frame += 1.0;\n    \n    col = mix(col, c1, smoothstep(frame - transTime, frame + transTime, cycle));\n    \n    return mix(col, col*vec3(1, 0.5, 0.5), 0.5) + vec3(0.3, 0., 0.);\n}\n\n//#define DEBUG_TEXTURE ropeTexture\n\n\nvec3 ropeTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(223, 182, 136);\n    vec3 c2 = rgb(143, 100, 58);\n    vec3 c3 = rgb(125, 102, 75);\n    vec3 c4 = rgb(191, 170, 149);\n    \n    vec3 hf1 = snoise(uv, 0.038828871, 0.3, 120.0, 6);\n    vec3 hf2 = snoise(uv, 4.49482919, 0.2, 100.0, 6);\n    vec3 lf1 = snoise(uv, 6.69988345, 0.3, 16.0, 6);\n    \n    float pat = max(0.0, 1.0-smoothstep(0.02, 0.2, abs(lf1.x*2.0-1.0)));\n    pat *= fract(dot(hf1, hf2)*1.1);\n    \n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    col += col1;\n    \n    uv.xy *= rot(0.4);\n    float tile = 16.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    \n    \n    vec2 start = vec2(1., -0.5);\n    vec2 end = vec2(0.02, 1.2);\n    \n    float thick = 3.5;\n    float line1 = line2D(alv, start, end, 0.1*thick) * smoothstep(0.1, 0.3, max(0.0, thick-dot(lv, vec2(2., 0.))));\n    float line2 = line2D(alv, start + vec2(-0.1, -0.1), end + vec2(0.1, -0.1), 0.19*thick) * smoothstep(0.0, 0.4, max(0.0, 1.1-dot(lv, vec2(2., 0.))));\n    col = mix(col, mix(c2, c3, lf1.y*hf1.x), pat);\n    col = mix(col, c1, line1);\n    col = mix(col, col*col, line2);\n    col = mix(col, col*col, hf2.x);\n    tile = 4.0;\n     id = floor(uv*tile);\n     lv = fract(uv*tile);\n     alv = abs(lv*2.0-1.0);\n     slv = lv*lv*(3.0-2.0*lv);\n   float line3 = line2D(alv, start + vec2(-0.1, -0.1), end + vec2(0.1, -0.1), 0.19*thick) * smoothstep(0.0, 0.4, max(0.0, 1.1-dot(lv, vec2(2., 0.))));\n    col = mix(col, col*col, line3);\n    \n    m.z = (line1+line2+line3)/3.;\n    m.spec = 0.0;\n    return col;\n}\n\nvec3 fireTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(255, 134, 5);\n    vec3 c2 = rgb(206, 95, 12);\n    vec3 c3 = rgb(247, 209, 90);\n    vec3 c4 = rgb(244, 152, 58);\n    vec3 c5 = rgb(113, 17, 1);\n    \n    vec3 warp = snoiseWarp(uv, 0.032828, 0.4, 16.0, 6, 0.5);\n    vec3 warp2 = snoiseWarp(uv, 3.39444, 0.4, 8.0, 6, 0.4);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, warp);\n    col1 = mix(col1, c5, warp2.x*0.8);\n    col += col1;\n    \n    col = mix(col, col*col, warp2.y*warp2.z);\n    \n    m.spec = 0.0;\n    m.lum = 1.0;\n    \n    return col;\n}\n\nvec3 fabricTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(73, 20, 25);\n    vec3 c2 = rgb(80, 12, 20);\n    vec3 c3 = rgb(138, 6, 8);\n    vec3 c4 = rgb(161, 31, 41);\n    vec3 c5 = rgb(59, 45, 29);\n    \n    vec3 hf1 = snoise(uv, 0.3828152, 0.01, 120.0, 6);\n    vec3 hf2 = snoise(uv, 5.5583355, 0.4, 64.0, 6);\n    vec3 lf1 = snoise(uv, 7.7998389, 0.4, 8.0, 6);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    col += col1;\n    \n    vec3 col2 = mix4(c2, c3, c4, c5, hf2);\n    \n    float lines1 = 0.0;\n    float lines2 = 0.0;\n    \n    float tile = 24.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    \n    lines1 = smoothstep(0.3, 0.5, alv.x-0.5) +\n           smoothstep(0.3, 0.5, alv.y-0.5);\n           \n    float rid = hash21(id, 0.3212535);\n           \n    tile *= ceil(rid*5.5);       \n    vec2 id2 = floor(uv*tile);\n    vec2 lv2 = fract(uv*tile);\n    vec2 alv2 = abs(lv2*2.0-1.0);\n    vec2 slv2 = lv2*lv2*(3.0-2.0*lv);\n    \n    lines2 = smoothstep(0.15, 0.5, alv2.x-0.5) +\n           smoothstep(0.15, 0.5, alv2.y-0.5);\n    \n    float lines = clamp(lines1+lines2, 0.0, 1.0);\n    lines *= smoothstep(0.4, 0.7, lf1.x)*hf1.x;\n    \n    col += lines*col2;\n    \n    m.z = lines;\n    m.spec = hf1.x*hf2.y*lf1.z*0.2;\n    \n    return col;\n    \n}\n//#define DEBUG_TEXTURE balloonTexture\nvec3 balloonTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 8.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float w = voronoi(uv*8., 0.32125123);\n    \n    vec3 idColor = hash23(id.xx*3.2998123, 0.2312312);\n    vec3 hf1 = snoise(uv, 0.3828152, 0.01, 120.0, 6);\n    vec3 hf2 = snoise(uv, 5.5583355, 0.4, 64.0, 6);\n    vec3 lf1 = snoise(uv, 7.7998389, 0.4, 8.0, 6);\n    \n    col += max(0.0, smoothstep(-0.7, 0.7, 1.0-alv.x)) * idColor;\n    \n  /*  float seed = 5.5938193;\n    vec3 idColor2 = \n        mix(\n            mix(hash23(id, seed), hash23(id + vec2(1,0), seed), slv.x),\n            mix(hash23(id+vec2(0, 1), seed), hash23(id + vec2(1,1), seed), slv.x),\n            slv.y\n        );*/\n\n    col = mix(col, col*col, w*0.7);\n    \n     float lines1 = 0.0;\n    float lines2 = 0.0;\n    \n    tile = 64.0;\n     id = floor(uv*tile);\n     lv = fract(uv*tile);\n     alv = abs(lv*2.0-1.0);\n     slv = lv*lv*(3.0-2.0*lv);\n    \n    lines1 = smoothstep(0.3, 0.5, alv.x-0.5) +\n           smoothstep(0.3, 0.5, alv.y-0.5);\n           \n    float rid = hash21(id, 0.3212535);\n           \n    tile *= ceil(rid*5.5);       \n    vec2 id2 = floor(uv*tile);\n    vec2 lv2 = fract(uv*tile);\n    vec2 alv2 = abs(lv2*2.0-1.0);\n    vec2 slv2 = lv2*lv2*(3.0-2.0*lv);\n    \n    lines2 = smoothstep(0.15, 0.5, alv2.x-0.5) +\n           smoothstep(0.15, 0.5, alv2.y-0.5);\n    \n    float lines = clamp(lines1+lines2, 0.0, 1.0);\n    lines *= smoothstep(0.4, 0.7, lf1.x)*hf1.x*lf1.y;\n    \n    col = mix(col, vec3(1.0), lines);\n    \n    m.z = luma(col);\n    m.spec = clamp(lines, 0.02, 1.0);\n    m.rough = clamp(lines*2., 0.7, 1.0);\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 g1 = rgb(147, 153, 108);\n    vec3 g2 = rgb(119, 121, 58);\n    vec3 g3 = rgb(69, 92, 7);\n    vec3 g4 = rgb(98, 103, 70);\n    \n    vec3 d1 = rgb(155, 137, 123);\n    vec3 d2 = rgb(122, 116, 89);\n    vec3 d3 = rgb(137, 113, 47);\n    vec3 d4 = rgb(102, 88, 55);\n    vec3 d5 = rgb(94, 75, 48);\n    \n    vec3 hf1 = snoise(uv, 0.92818124, 0.5, 120.0, 6);\n    vec3 warp = snoiseWarp(uv, 2.2938215, 0.5, 100.0, 6, 0.5);\n    vec3 lf1 = snoise(uv, 4.490482981, 0.3, 8.0, 6);\n    vec3 lf2 = snoise(uv, 12.1288599924, 0.3, 2.5, 6);\n    vec3 lf3 = snoise(uv, 44.9892878333, 0.3, 0.2, 6);\n    float w = voronoi((uv)*10.+warp.x, 0.2312532);\n    vec3 grain = abs(normalize(refract(hf1, warp, (w*w))));\n   \n    \n    vec3 grassCol = mix4(g1, g2, g3, g4, hf1);\n    col += grassCol;\n    \n    vec3 dirtCol = mix4(d1, d2, d3, d4, warp);\n    dirtCol = mix(dirtCol, d5, w);\n    \n    float dirtReg = clamp(smoothstep(0.4, 0.6, lf2.x)*smoothstep(0.4, 0.6, lf1.x)*1.5, 0.0, 1.0);\n    float dirtReg2 = smoothstep(0.4, 0.6, lf3.x);\n    dirtReg = mix(dirtReg, dirtReg2, smoothstep(0.4, 0.6, lf3.y));\n    \n    float detail = smoothstep(0.4, 0.6, lf1.y)*w*smoothstep(0.4, 0.6, lf2.y)*0.6;\n    float detail2 = grain.x * smoothstep(0.4, 0.6, warp.y)*smoothstep(0.2, 0.6, lf2.z);\n    detail2 = detail2*detail2;\n    \n    \n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, detail);\n    col = mix(col, col+col, detail2);\n    \n    m.spec = clamp(dirtReg*detail*smoothstep(0.4, 0.6, lf1.z)*w, 0.0, 1.0);\n    \n    m.z = 1.0-((w*dirtReg)*0.09);\n    \n    return col;\n}\n\nvec3 dirtyMetalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(131, 131, 131);\n    vec3 c2 = rgb(172, 173, 176);\n    vec3 c3 = rgb(103, 113, 125);\n    vec3 c4 = rgb(192, 192, 192);\n    \n    vec3 d1 = rgb(87, 78, 76);\n    vec3 d2 = rgb(59, 53, 44);\n    vec3 d3 = rgb(178, 118, 83);\n    vec3 d4 = rgb(176, 80, 70);\n    \n    vec3 warp = snoiseWarp(uv, 0.0288231, 1., 32.0, 6, 0.2);\n    vec3 hf1 = snoise(uv, 2.8981819, 1.0, 100.0, 6);\n    float w = wnoise(uv*12., 6, 1.);\n    vec3 hf2 = abs(normalize(cross(vec3(warp.z*2.0-1.0, hf1.x*2.0-1.0, w*2.0-1.0), hf1-warp)));\n    vec3 lf1 = snoise(uv, 5.54828155, 0.5, 8.0, 6);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n \n    float dirtReg = smoothstep(0.3 + (hf2.x*0.09), 1.0, lf1.y);\n    float wear = smoothstep(0.0+hf2.z, 1.-(lf1.y*0.2), abs(hf2.x*2.0-1.0));\n    wear = wear*lf1.z*warp.y;\n    float bulge = w*warp.x*hf2.y;\n    float scratch = max(0.0, 1.0-smoothstep(0.02, 0.04, abs(lf1.x*2.0-1.0)));\n    scratch = scratch*bulge*lf1.z;\n    \n    col += col1;\n    \n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, wear);\n    col = mix(col, col*col, bulge);\n    col = mix(col, dirtCol, scratch);\n    \n    m.rough = clamp((wear+scratch+bulge)*1.9, 0.0, 1.0);\n    m.metallic = clamp(1.0-((wear+bulge)*3.), 0.0, 1.0);\n    m.spec = clamp(1.0-((wear+scratch)*3.), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = grassTexture(uv, p, data.m);\n    \n    data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = snoiseWarp(uv, 0.3922812, 0.5, 16.0, 6, 1.);\n    return col;\n}\n\nvec3 getAlbedoAirBalloon(inout Data data) {\n    vec3 p = data.p - AIR_BALLOON_POS;\n    vec3 n = data.n;\n    vec2 uv = sphereUv(n);\n    vec3 col = balloonTexture(uv.yx, p, data.m);\n    \n    \n  //  data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\nvec3 getAlbedoAirBalloonBasket(inout Data data) {\n    vec3 p = data.p - AIR_BALLOON_POS;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = texture(iChannel2, uv*0.5).rgb;\n    \n    data.m.z = luma(col);\n    data.m.spec = data.m.z;\n    data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\nvec3 getAlbedoAirBalloonPillar(inout Data data) {\n    vec3 p = data.p - AIR_BALLOON_POS;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = fabricTexture(uv.yx, p, data.m);\n    \n    data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\n\n\nvec3 getAlbedoFire(inout Data data) {\n    vec3 p = data.p - AIR_BALLOON_POS;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = fireTexture(uv.yx, p, data.m);\n    \n    \n    return col;\n}\n\nvec3 getAlbedoAirBalloonContrap(inout Data data) {\n    vec3 p = data.p - AIR_BALLOON_POS;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = dirtyMetalTexture(uv.yx, p, data.m);\n    \n    //data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\nvec3 getAlbedoAirBalloonGas(inout Data data) {\n    vec3 p = data.p - AIR_BALLOON_POS;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = dirtyMetalTexture(uv.yx, p, data.m);\n    \n    //data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\nvec3 getAlbedoRope(inout Data data) {\n    vec3 p = data.p - (AIR_BALLOON_POS / max(0.0001, distance(data.p, AIR_BALLOON_POS)));\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = ropeTexture(uv.yx, p, data.m);\n    \n    data.n =  makeNormal(data.n, data.m.z, 0.39, 0.4);\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_AIR_BALLOON: return getAlbedoAirBalloon(data); break;\n        case ID_AIR_BALLOON_BASKET: return getAlbedoAirBalloonBasket(data); break;\n        case ID_AIR_BALLOON_PILLAR: return getAlbedoAirBalloonPillar(data); break;\n        case ID_FIRE: return getAlbedoFire(data); break;\n        case ID_AIR_BALLOON_CONTRAP: return getAlbedoAirBalloonContrap(data); break;\n        case ID_AIR_BALLOON_GAS: return getAlbedoAirBalloonGas(data); break;\n        case ID_ROPE: return getAlbedoRope(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getClouds(in vec3 rd) {\n    if (rd.y < -0.00001) return vec3(0.);\n    vec2 uv = rd.xz / rd.y;\n    float time = T*0.1;\n    vec2 shift = vec2(cos(time), sin(time));\n    vec3 lf1 = snoise(uv + shift, 0.028811, 0.2, 2.0, 6);\n    vec3 lf2 = snoise(uv - shift, 1.987766, 0.1, 3.0, 6);\n    vec3 hf1 = snoise(uv + shift, 3.333398, 0.0, 10.0, 6);\n    vec3 hf2 = snoise(uv - shift, 7.776261, 0.1, 24.0, 6);\n    vec3 mixer1 = snoise(uv + shift, 23.987271, 0.3, 2.5, 4);\n    vec3 mixer2 = snoise(uv - shift, 34.676622, 0.3, 2.5, 4);\n    vec3 mixer3 = snoise(uv + shift, 73.777324, 0.3, 2.5, 4);\n    float low1 = mix(mix(lf1.x, lf1.y, mixer1.x), lf1.z, mixer1.y);\n    float low2 = mix(mix(lf2.x, lf2.y, mixer2.x), lf2.z, mixer2.y);\n    float high1 = mix(mix(hf1.x, hf1.y, mixer1.x), hf1.z, mixer1.y);\n    float high2 = mix(mix(hf2.x, hf2.y, mixer2.x), hf2.z, mixer2.y);\n    float low = mix(low1, low2, mixer1.z);\n    float high = mix(high1, high2, mixer2.z);\n    float clouds = mix(low, high, mixer3.x);\n    clouds = pow(clouds, 2.0);\n    return vec3(clouds);\n}\n\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(vec3(0.29, 0.61, 0.9), vec3(1.0 + dotup));\n    \n    float cloudFactor = smoothstep(0.0, 0.09, dotup);\n    if (cloudFactor > 0.00000001) {\n        vec3 clouds = getClouds(rd);\n        col += clouds * cloudFactor;\n    }\n    \n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    \n    att += data.m.lum;\n    \n    float shadow = data.m.lum >= 0.99 ? 1.0 : getShadow(p + (n*NEAR*2.), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 2\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, in vec2 uv, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    float fireTime = T;\n    \n    vec3 firePos = AIR_BALLOON_POS + vec3(0, 2.5, 0);\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.86, 0.79), 0.5, LIGHT_AMBIENT);\n    lights[1] = Light(firePos, vec3(0.0), getFireColor(fireTime), 3.0, LIGHT_POINT);\n    \n    vec3 mixf = vec3(1.0);\n    Data primData = data;\n    vec3 oRo = ro;\n    vec3 oRd = rd;\n    float dist =  FAR;\n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                primData = data;\n                dist = data.d;\n            }\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += forEachLight(data, light, ro, rd, diffuse) * mixf;\n            }\n            \n            float rough = data.m.rough;\n            if (rough >= 0.999) break;\n            \n            vec3 p = data.p;\n            vec3 n = data.n;\n            float NdotV = dot(n,-rd);\n            float metallic = data.m.metallic;\n            \n            vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n            \n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n            mixf = F * max(0.0, 1.0-(rough*rough));\n            \n            rd = reflect(rd, n);\n            ro = p + (n*NEAR*2.);\n            data.skip = data.id;\n            \n        } else {\n            col += getSky(rd) * mixf;\n            break;\n        }\n    }\n    \n    data = primData;\n    ro = oRo;\n    rd = oRd;\n    depth = abs(data.d) / FAR;\n    \n    \n    firePos.y += 0.44;\n    vec3 dirFire = normalize(firePos - (ro));\n    float dp = adot(normalize(rd), dirFire);\n    float smokeMag = pow(dp, 656.) * (max(0.0, 1.0-smoothstep(0.3, 0.02, depth))*2.);\n    smokeMag += clamp(1.0/max(0.0001, pow(distance(ro, firePos), 2.)), 0.0, 1.0)*smokeMag;\n\n/*if (\n    ibox(\n    oRo,\n    oRd,\n    firePos + vec3(0, 1., 0),\n    vec3(4., 5, 4),\n    NEAR,\n    FAR\n   ) ) { col += vec3(1, 0, 0); }*/\n  \n  \n    if (\n    ibox(\n    oRo,\n    oRd,\n    firePos + vec3(0, 1., 0),\n    vec3(4, 5, 4),\n    NEAR,\n    FAR\n    ) && smokeMag > 0.001) {\n        vec3 fireRo = (ro)-(firePos);\n        vec3 smoke = marchSmoke(firePos, fireRo, rd, dist, lights[0], lights[1]) * clamp(smokeMag, 0.0, 1.0);\n        col += smoke;\n    }\n    \n    \n    col += smoothstep(0.09, 1., depth) * max(0.0, 1.0 - smoothstep(-0.02, 0.15, dotup))*depth*lights[0].c;\n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -12.);\n    rd = normalize(vec3(uv.xy, 1.0));\n    vec3 firePos = AIR_BALLOON_POS + vec3(0, 2.5, 0);\n    vec3 ropePos = vec3(-4, 0, 0);\n    \n    if (length(m.xy) > 0.001 && iFrame > 1 && iTime > 0.0003 && m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        float y = 4.;\n        ro.y += y;\n        ro.y = max(y, ro.y);\n    } else {\n        float time = T*0.5;\n        ro = vec3(0, 6., -16.);\n        vec3 oro = ro;\n        vec3 lookp = firePos;\n        vec3 olook = lookp;\n        \n        float nrSteps = 17.0;\n        float transTime = 0.9;\n        float frame = 1.0;\n        \n        ro = onCycle(ro, firePos+vec3(0, 0, -4), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, firePos, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, firePos+vec3(0, 0, -3), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, firePos, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, ropePos+vec3(0, 0.5, -1.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, ropePos+vec3(2., 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, ropePos+vec3(0, 1., 2.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, ropePos+vec3(2., 0.5, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, ropePos+vec3(0, 2., 5.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, AIR_BALLOON_POS, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, ropePos+vec3(5, 2., 9.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, AIR_BALLOON_POS, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(0, 5., 3.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, AIR_BALLOON_POS + vec3(0, 2, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(0, 9., 3.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, AIR_BALLOON_POS + vec3(0, 4, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(6., 9., 6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, AIR_BALLOON_POS + vec3(0, 4, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(cos(T)*6., 5., sin(T)*6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(cos(T)*6., 5., sin(T)*6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(cos(T)*6., 5., sin(T)*6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(cos(T)*6., 5., sin(T)*6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(cos(T)*6., 5., sin(T)*6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(cos(T)*6., 5., sin(T)*6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(6., 9., -6.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, oro, time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, olook, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        rd = look(uv, lookp, ro);\n\n    }\n    \n    \n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    float depth = 1.0;\n    Data data = NEW_DATA;\n    getRay(uv, m, ro, rd);\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, uv, depth);\n    col += (col*col*luma(col));\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}