{"ver":"0.1","info":{"id":"cldGWj","date":"1683132739","viewed":83,"name":"Schwarz Gold Flakes","username":"dansh0","description":"More fun with TPMS structures. Exploring channels for the first time. \nI should have gone to bed when I started making this, let alone now...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["music","volumetric","schwarz","tpms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS_FILL 100\n#define MIN_DIST 0.01\n#define DOTS_PER_MM 10.\n#define NORM_EPS 0.001\n#define PI 3.141592\n\n// PARAMS\nfloat tpmsDiv = 2.0; // # of periods within the volume\nfloat cDist = 200.; // Camera distance from center\nvec3 lCol = vec3(1.0, 1.0, 0.7); // Light color\nvec3 objCol = vec3(1.0);\nvec3 lPos = vec3(1000.); // Light source position\nfloat slStr = 0.4; // Specular light strength\nfloat slPow = 4.0; // Specular light power (spread)\n\n// Globals\nfloat scl; // Part Size\nfloat tpmsSc; // Fill Periodicity\nfloat tpmsFac; // Fill Density (width only in this case)\nfloat alStr; // Ambient light strength\nfloat dlStr; // Diffuse light strength\n\n// GEOMETRY\n    \n\n// Schwarz SDF\nfloat dSchwarz(vec3 p) {\n    p *= tpmsSc;\n    float fac = 0.3 + texture( iChannel2, vec2( 0.1, 0.25 ) ).x*0.2;\n    return abs(dot(cos(p), vec3(1.0))) - fac;\n}\n    \n\n// Color data volume filtering\nbool filterColor(vec3 p) {\n    float noiseDiv = 75.0 + sin(iTime/10.0)*25.0;\n    vec3 color = texture(iChannel0, p/noiseDiv).rgb;\n    float baseThresh = 0.95;\n    float modThresh = 0.1;\n    float timeDiv = 2.0;\n    float threshold = (baseThresh + sin(iTime/timeDiv)*modThresh);\n    float threshold2 = (baseThresh + sin(iTime/timeDiv + (2.0/3.0)*PI)*modThresh);\n    float threshold3 = (baseThresh + sin(iTime/timeDiv + (4.0/3.0)*PI)*modThresh);\n    \n    return (color.r < threshold && color.b < threshold2 && color.g < threshold3);\n}\n    \n\n// Volumetric raymarch\nfloat mrchFixSt(vec3 p, vec3 d, float bDist, float step) {\n\n    vec3 bPos = p + bDist * d;\n    float dist = bDist; \n    float maxDist = dist + scl*2.0;\n    p = bPos;\n\n    for (int iStep=0; iStep<MAX_STEPS_FILL; iStep++) {\n        float sdfDist = dSchwarz(p);\n        if (sdfDist>MIN_DIST && dist<maxDist || filterColor(p)) {\n            p += step * d;\n            dist += step;\n        } else {\n            return dist;\n        }\n    }\n    return maxDist;\n}\n  \n// tpmsGradient instead of normal\nvec3 tpmsGrad(vec3 p) {\n    vec3 change;\n    change.x = dSchwarz(p + vec3(NORM_EPS, 0, 0)) - dSchwarz(p - vec3(NORM_EPS, 0, 0));\n    change.y = dSchwarz(p + vec3(0, NORM_EPS, 0)) - dSchwarz(p - vec3(0, NORM_EPS, 0)); \n    change.z = dSchwarz(p + vec3(0, 0, NORM_EPS)) - dSchwarz(p - vec3(0, 0, NORM_EPS)); \n    return normalize( change );\n}\n\n\n// CAMERA TOOLS\n\n// Orbit Controls\nvec3 orbitCtrl(float cDist, vec2 sphAngles) {\n    // spherical angles is x = theta -PI to PI and y = phi -PI/2 to PI/2\n    vec3 cPos;\n    cPos.x = cDist * cos(sphAngles.x) * sin(sphAngles.y);\n    cPos.z = cDist * sin(sphAngles.x) * sin(sphAngles.y);\n    cPos.y = cDist * cos(sphAngles.y);\n    return cPos;  \n}    \n\n\n// Camera Fragment Position (Orthographic)\nvec3 orthoFragP(vec3 cPos, vec3 cDir, vec2 cSize, vec2 fCoord) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    if (cDir.x == 0.0 && cDir.z == 0.0 && cDir.y != 0.0) {\n        up = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 off = ((fCoord / iResolution.xy) * cSize) - (cSize * 0.5);\n    vec3 rCh = normalize(cross(cDir, up));\n    vec3 upCh = normalize(cross(rCh, cDir));\n    vec3 wrldOff = off.x * rCh + off.y * upCh;\n    return cPos + wrldOff;\n}\n\n    \n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Background color default\n    vec3 col = vec3(0.0);\n    \n    // Music\n    dlStr = 0.7 + texture( iChannel2, vec2( 0.1, 0.25 ) ).x*2.0;\n    alStr = 0.4 + texture( iChannel2, vec2( 0.5, 0.25 ) ).x*0.1;\n    \n    // Set Geometry Size\n    float marg = -iResolution.y; \n    float sphRPx = min(iResolution.y, iResolution.x)/2.0 - marg;\n    scl = sphRPx / DOTS_PER_MM;\n    tpmsSc = (2.0*PI)/((2.0*scl)/tpmsDiv);\n    \n    // Init camera\n    vec2 cSize = iResolution.xy / DOTS_PER_MM;\n    vec2 cAngles = vec2(sin(iTime/20.0)*PI, (PI/2.0)+(sin(iTime/25.0-PI/2.0))*0.999*(PI/2.0));\n    vec3 cPos = orbitCtrl(cDist, cAngles);\n    vec3 cDir = normalize(-cPos);\n    vec3 fragPos = orthoFragP(cPos, cDir, cSize, fragCoord);\n    \n    // UV and noise\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Ray March Fixed Step Lattice\n    float mrchStepSize = 2.0*scl / float(MAX_STEPS_FILL);\n    float boundDist = length(fragPos) - scl;\n    float tpmsDist = mrchFixSt(fragPos.xyz, cDir, boundDist, mrchStepSize);\n    vec3 tpmsPos = fragPos + cDir * tpmsDist;\n    float maxDist = boundDist+2.0*scl;\n    \n    if (tpmsDist < maxDist) {\n        // Find gradient\n        vec3 grad = tpmsGrad(tpmsPos);\n        \n        // Ambient Lighting\n        vec3 ambiLight = lCol * alStr;\n        \n        // Diffuse Lighting\n        vec3 diffDir = normalize(lPos - tpmsPos);\n        vec3 diffLight = lCol * dlStr * max(dot(grad, diffDir), 0.0);\n        \n        // Specular Lighting\n        vec3 reflDir = reflect(-diffDir, grad);\n        float specFact = pow(max(dot(-cDir, reflDir), 0.0), slPow);\n        vec3 specLight = lCol * slStr * specFact;\n        \n        \n        \n        // Phong Combined Lighting\n        vec3 combLight = ambiLight + diffLight + specLight;\n        col = combLight * objCol;\n\n    } else {\n        // Background\n        col = vec3(texture(iChannel1,vec3(uv, 1.0)));     \n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col, maxDist-tpmsDist );\n    \n}","name":"Image","description":"","type":"image"}]}