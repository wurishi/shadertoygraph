{"ver":"0.1","info":{"id":"4f3fR4","date":"1732740479","viewed":39,"name":"Gaussian shader black and white","username":"dvrbs","description":"gaussian black and white shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blackandwhitegaussian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 swirl(vec2 uv, vec2 center, float strength) {\n    vec2 offset = uv - center;\n    float angle = strength * length(offset);\n    float s = sin(angle);\n    float c = cos(angle);\n    offset = mat2(c, -s, s, c) * offset;\n    return offset + center;\n}\n\n// ShaderToy code for a Gaussian Blur\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv2 = swirl(uv,vec2(.5,.5),sin(iTime)*.5);\n \n    // Gaussian weights for a 5-tap kernel\n    const float weights[5] = float[](\n    0.227027,\n    0.1945946,\n    0.1216216,\n    0.054054,\n    0.016216);\n\n    vec3 color = texture(iChannel0, uv2).rgb * weights[0];\n    vec3 color2 = texture(iChannel0,uv2).rgb;\n    \n    for (int i = 1; i < 5; ++i) {\n        float offset = float(i) / iResolution.x; // Adjust for resolution (horizontal blur)\n        \n        offset*=sin(iTime);\n        \n        // Horizontal and vertical blur\n        color += texture(iChannel0, uv + vec2(offset, 0.0)).rgb * weights[i];\n        color += texture(iChannel0, uv - vec2(offset, 0.0)).rgb * weights[i];\n        \n        offset = float(i) / iResolution.y; // Vertical pass\n        color += texture(iChannel0, uv + vec2(0.0, offset)).rgb * weights[i];\n        color += texture(iChannel0, uv - vec2(0.0, offset)).rgb * weights[i];\n    }\n    \n    float avg1 = (color.r + color.g + color.b)/3.0;\n    float avg2 = (color2.r + color2.g + color2.b)/3.0;\n    \n    if(avg1 > .7 + abs(sin(iTime)*0.05)){color = vec3(1.0);}\n    else{color = vec3(0.0);}\n    \n    if(avg2 > .7 + abs(sin(iTime)*0.05)){color2 = vec3(1.0);}\n    else{color2 = vec3(0.0);}\n    \n    color = color - color2;\n    \n    vec3 mask = texture(iChannel2,uv).rgb;\n    mask = mask * color;\n    \n    fragColor = vec4(mask, 1.0);\n}","name":"Image","description":"","type":"image"}]}