{"ver":"0.1","info":{"id":"4XBczW","date":"1727016345","viewed":42,"name":"You should buy pringles","username":"w2w3","description":"*You should buy pringles\n*You should buy pringles\n*You should buy pringles\n*You should buy pringles\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pringles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 2000\n#define MAX_DIST 300.0\n#define EPS 0.00001\n#define TRUST 0.1\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat dFace(vec3 p, vec3 center, float size) {\n    float dist = 0.0;\n    dist += pow(abs(p.x - center.x), 6.0);\n    dist += pow(abs(p.y - center.y), 2.5);\n    dist += pow(abs(p.z - center.z), 2.0);\n    dist = pow(dist, 0.5);\n    return dist - size;\n}\n\nfloat dTor(vec3 p, vec3 center, vec2 size, mat3 rotation) {\n    vec3 shift = (p - center) * rotation;\n    vec2 q = vec2(length(shift.xz) - size.x, shift.y);\n    return length(q) - size.y;\n}\n\nfloat dEye(vec3 p, vec3 center, float size, float spikes, float sharpness) {\n    float pi = acos(-1.0);\n    float x = (p - center).x;\n    float y = (p - center).y;\n    float z = (p - center).z;\n    float alpha = asin(x / sqrt(x * x + z * z));\n    float beta = asin(y / sqrt(x * x + y * y));\n    float gamma = asin(z / sqrt(y * y + z * z));\n    float spikeA = pow(sin(alpha * spikes), sharpness);\n    float spikeB = pow(sin(beta * spikes), sharpness);\n    float spikeC = pow(sin(gamma * spikes), sharpness);\n    return length(p - center) - size - min(spikeA, min(spikeB, spikeC));\n}\n\nfloat sdf(vec3 p, mat3 rotate) {\n    p *= rotate;\n    mat3 spin = rotateX(iTime);\n    vec3 dEye1pos = vec3(0, 0, -2);\n    vec3 dEye2pos = vec3(0, 0, 2);\n    \n    float outSdf = dEye((p - dEye1pos) * spin + dEye1pos, dEye1pos, 1.0, 1.0 + pow(iTime, 2.0) * 0.01, 5.0);\n    outSdf = min(outSdf, dEye((p - dEye2pos) * spin + dEye2pos, dEye2pos, 1.0, 1.0 + pow(iTime, 2.0) * 0.01, 5.0));\n    outSdf = min(outSdf, dFace(p, vec3(1.5, -1, 0), 5.0));\n    outSdf = min(outSdf, dTor(p, vec3(0.5, -1.5, -1.5), vec2(1.5, 0.5), rotateX(0.5) * rotateZ(-1.0)));\n    outSdf = min(outSdf, dTor(p, vec3(0.5, -1.5, 1.5), vec2(1.5, 0.5), rotateX(-0.5) * rotateZ(-1.0)));\n    return outSdf;\n}\n\nvec3 trace (in vec3 from, in vec3 dir, out bool hit, in mat3 rotate) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    hit = false;\n    for (int steps = 0; steps < MAX_STEPS; ++steps) {\n        float dist = sdf(p, rotate);\n        if (dist < EPS) {\n            hit = true;\n            break;\n        }\n        totalDist += dist;\n        if (totalDist > MAX_DIST)\n            break;\n        p += dist * dir * TRUST;\n    }\n    return p;\n}\n\nvec3 normal(vec3 z, float d, mat3 rotate) {\n    float step = max(d * 0.5, EPS);\n    float dx1 = sdf(z + vec3(step, 0, 0), rotate);\n    float dx2 = sdf(z - vec3(step, 0, 0), rotate);\n    float dy1 = sdf(z + vec3(0, step, 0), rotate);\n    float dy2 = sdf(z - vec3(0, step, 0), rotate);\n    float dz1 = sdf(z + vec3(0, 0, step), rotate);\n    float dz2 = sdf(z - vec3(0, 0, step), rotate);\n    return normalize(vec3 (dx1 - dx2, dy1 - dy2, dz1 - dz2));\n\n}\n\nconst vec3 eye = vec3(0, 0, 10);\nconst vec3 light = vec3(0.0, 1.0, 15.0);\nconst float brightness = 3.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 rotate = rotateX(-mouse.y * 6.0) * rotateY(-mouse.x * 6.0);\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5)) * 20.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec3 wDir = normalize(vec3(uv, 0) - eye);\n    vec3 wP = trace(eye, wDir, hit, rotate);\n    vec3 cP = wP * rotate;\n    vec3 color = texture(iChannel1, wDir * rotate).rgb;\n    if (hit) {\n        vec3 l = normalize(light - wP);\n        vec3 v = normalize(eye - wP);\n        vec3 n = normal(wP, EPS, rotate);\n        float nl = max(0.0, dot(n, l));\n        vec3 h = normalize(l + v);\n        float nh = max(0.0, dot(n, h));\n        float blick = pow(nh, 100.0);\n        \n        vec3 texNorm = abs(n);\n        texNorm /= (texNorm.x + texNorm.y + texNorm.z);\n        vec3 tex = texture(iChannel0, cP.xy).rgb * texNorm.z;\n        tex += texture(iChannel0, cP.xz).rgb * texNorm.y;\n        tex += texture(iChannel0, cP.yz).rgb * texNorm.x;\n        tex *= brightness;\n        \n        color = tex * (nl + blick) / 2.0;\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor.rgb = vec3(0.5, asin(cos(uv * acos(-1.0) * 6.0))) * 2.0;\n    fragColor.rgb *= rotateX(iTime);\n}","name":"Cube A","description":"","type":"cubemap"}]}