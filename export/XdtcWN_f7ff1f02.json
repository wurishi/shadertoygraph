{"ver":"0.1","info":{"id":"XdtcWN","date":"1518939134","viewed":304,"name":"speedy cube","username":"laserdog","description":"recreating a GIF, linked below. i simulate 3d rendering by using orthographic projection.  no raymarching.\n\ngif:\nhttps://camo.githubusercontent.com/027b2fc8715d8ab93f571c59b0444d6c89b5f824/68747470733a2f2f692e696d6775722e636f6d2f4c746d35786a442e676966","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["motionblur","gif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define left -2.2\n#define right 2.2\n#define bottom -2.2\n#define top 2.2\n#define pi 3.14159265359\n#define blurIterations 24\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, -dot(r, eye)),\n        vec4(u, -dot(u, eye)),\n        vec4(-f, -dot(f, eye)),\n        vec4(0., 0., 0., 1.));\n}\n\nconst mat4 proj = mat4(\n\tvec4(2. / (right - left), 0., 0., -(right + left) / (right - left)),\n    vec4(0., 2. / ( top - bottom), 0., -(top + bottom) / (top - bottom)),\n    vec4(0., 0., 0., 0.),\n    vec4(0., 0., 0., 1.)\n);\n\nmat4 rotateY(float rads)\n{\n    return mat4(\n        vec4(cos(rads), 0., sin(rads), 0.),\n        vec4(0., 1., 0., 0.),\n        vec4(-sin(rads), 0., cos(rads), 0.),\n        vec4(0.)\n    );\n}\n\nconst vec4[] horizontalPoints = vec4[](vec4(-1., 1., 0., 1.), vec4(0., 1., 1., 0.), \n                                vec4(-1., -1., 0., 1.), vec4(0., 1., -1., 0.),\n                                vec4(1., -1., 0., 1.), vec4(0., -1., 1., 0.), \n                                vec4(1., 1., 0., 1.), vec4(0., -1., -1., 0.));\n\nconst vec4[] verticalPoints = vec4[](vec4(-1., 0., 1., 0.), vec4(1., 0., 1., 0.),\n                             \t\t vec4(-1., 0., -1., 0.), vec4(1., 0., -1., 0.));\n\nfloat ease(float t)\n{\n    return t < .5 ? 4. * pow(t, 3.) : (t - 1.) * (2. * t - 2.) * (2. * t - 2.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float duration = 4.5;\n    const float oscillationStart = 2.;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0., 3., 5.);\n    vec3 target = vec3(0.);\n    \n    float minDist = 100.;\n    \n    int horizontalCount = horizontalPoints.length();\n    int verticalCount = verticalPoints.length();\n    \n    mat4 view = lookAt(eye, target, vec3(0., 1., 0.));\n    mat4 mvp = proj * view * rotateY(iTime * 1.25);\n    vec3 blurCol = vec3(0.);\n    \n    // motion blur technique inspired by https://www.shadertoy.com/view/XdXXz4 by @HLorenzi\n    for (int x = 0; x < blurIterations; x++)\n    {\n        float t = mod(iTime - float(x) * (1. / 15. / 32.), duration);\n        float num = ease(max(0., t - oscillationStart) / (duration - oscillationStart)) * 2. * pi;\n    \tfloat distOffset = sin(num * 7.);\n\n        for (int i = 0; i < horizontalCount; i++)\n    \t{\n        \tvec4 offsetVec = i % 2 == 0 ? vec4(0., 0., distOffset, 0.) : vec4(distOffset, 0., 0., 0.);\n        \tminDist = min(distance(uv, (mvp * (horizontalPoints[i] - offsetVec)).xy), minDist);\n        \tminDist = min(distance(uv, (mvp * (horizontalPoints[i] + offsetVec)).xy), minDist);\n    \t}\n    \n    \tfor (int i = 0; i < verticalCount; i++)\n    \t{\n        \tvec4 offsetVec = vec4(0., distOffset, 0., 0.);\n        \tminDist = min(distance(uv, (mvp * (verticalPoints[i] - offsetVec)).xy), minDist);\n        \tminDist = min(distance(uv, (mvp * (verticalPoints[i] + offsetVec)).xy), minDist);\n    \t}\n    \n    \tblurCol += mix(vec3(1.), vec3(.27, .19, .237), step(.02, minDist));\n    }\n\n    fragColor.rgb = blurCol / float(blurIterations);\n}","name":"Image","description":"","type":"image"}]}