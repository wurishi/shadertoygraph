{"ver":"0.1","info":{"id":"MlKcWV","date":"1537874371","viewed":138,"name":"Nelder-Mead method on Rosenbrock","username":"Ultraviolet","description":"Optimization using the Nelder-Mead method ([url]https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method[/url]).\nYou can switch to Himmelblau function in the Common Tab.\nClick to change point location.\nHold SPACE for speed.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n\n\n// cf https://www.shadertoy.com/view/XtjBzG\nvec3 colorMap(float t)\n{    \n    t *= 4.;\n    return mix(vec3(.9),\n               clamp(vec3(min(t-1.5, 4.5-t), \n                      min(t-0.5, 3.5-t), \n                      min(t+0.5, 2.5-t)), \n                 0., 1.),\n               0.4);\n}\n\n\n\n\n// The following 2 functions come from https://www.shadertoy.com/view/lt3GRj\n// Thank you TimoKinnunen !\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 X = (fragCoord -iResolution.xy*.5)/iResolution.y*3.;\n    float Y = functionToOptimize(X);\n    \n    vec3 col;\n    col = colorMap(Y);\n    \n    \n    DRAW(Grid(1.), X, vec3(.1), .5, col);\n    DRAW(Ray(vec2(0.), vec2(1.,0.)), X, vec3(.0), 1., col);\n    DRAW(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n    \n    vec2 x0 = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 x1 = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 x2 = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n    \n    DRAW(Triangle(x0, x1, x2), X, vec3(1., 0., 0.), 2.0, col);\n    if(alg_dist(Triangle(x0, x1, x2), X) <0.)\n        col = mix(col, vec3(1.0, 0.0, 0.0), 0.2);\n\n    \n    vec2 xx = (x0+x1+x2)/3.;\n    \n\tvec2 fontSize = vec2(4,5) * vec2(5,3);\n    vec2 vPixelCoord = vec2(-5.0, 5.0);\n\tfloat fDigits = 2.0;\n\tfloat fDecimalPlaces = 5.0;\n\tfloat fIsDigit = PrintValue(fragCoord, vPixelCoord + vec2(0., 20.), fontSize, xx.x, fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n\tfIsDigit = PrintValue(fragCoord, vPixelCoord, fontSize, xx.y, fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n\tfIsDigit = PrintValue(fragCoord, vPixelCoord+vec2(iResolution.x-200., 10.), fontSize, functionToOptimize(xx), fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This tab implements the Nelder-Mead method.\n// See https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method.\n\n\nconst float alpha = 1.;\t// reflection coeff\nconst float gamma = 2.;\t// expansion coeff\nconst float rho   = .5;\t// contraction coeff\nconst float sigma = .5;\t// shrink coeff\n\nconst int frames = 20;\t// frame skipping coeff (for a slower animation)\n\n\n/// swaps x0 with x1 and y0 with y1\nvoid swap(inout vec2 x0, inout vec2 x1, inout float y0, inout float y1)\n{\n    float y_;\n    vec2 x_;\n    y_ = y1;\n    y1 = y0;\n    y0 = y_;\n    x_ = x1;\n    x1 = x0;\n    x0 = x_;\n}\n\n/// ensures that y0 < y1 < y2, and orders x[0,1,2] accordingly\nvoid sort(inout vec2 x0, inout vec2 x1, inout vec2 x2, inout float y0, inout float y1, inout float y2)\n{\n    if(y0 > y1)\n    {\n        swap(x0, x1, y0, y1);\n    }\n    \n    if(y0 > y2)\n    {\n        swap(x0, x2, y0, y2);\n    }\n    \n    if(y1 > y2)\n    {\n        swap(x1, x2, y1, y2);\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // represents the working triangle in the first 3 pixels of the buffer, the rest is discarded\n    \n    ivec2 coord = ivec2(floor(fragCoord));\n    if(coord.x > 2 || coord.y > 0)\n        discard;\n    \n    vec4 v0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 v1 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 v2 = texelFetch(iChannel0, ivec2(2, 0), 0);\n    \n    vec2 x0 = v0.xy;\n    vec2 x1 = v1.xy;\n    vec2 x2 = v2.xy;\n    \n    float y0 = v0.z;\n    float y1 = v1.z;\n    float y2 = v2.z;\n    \n    int k = 0;\t// debug utility\n    \n    if(iMouse.z > .5)\n    {\n        x0 = (iMouse.xy -iResolution.xy*.5)/iResolution.y*3.;\n        y0 = functionToOptimize(x0);\n    }\n    \n    if(iFrame  == 0)\n    {\n        //x0 = vec2(-1.);\n        x0 = vec2(-1., 1.)*.8;\n        y0 = functionToOptimize(x0);\n        \n        //x1 = vec2(-1., 1.);\n        x1 = vec2(1., -1.)*.8;\n        y1 = functionToOptimize(x1);\n        \n        x2 = vec2(-1.)*.8;\n        y2 = functionToOptimize(x2);\n    }\n    else if(iFrame%frames == 0 || texelFetch(iChannel1, ivec2(32, 2), 0).x > .5) // frame skipping\n    {\n\n        sort(x0, x1, x2, y0, y1, y2);\n\n        vec2 xo = (x0+x1)*.5;\n\n        vec2 xr = xo + alpha*(xo-x2);\n\n        float yr = functionToOptimize(xr);\n\n        // Reflection\n        if(y0 <= yr && yr < y1)\n        {\n            x2 = xr;\n            y2 = yr;\n            k = 1;\n        }\n        // Expansion\n        else if(yr < y0)\n        {\n            vec2 xe = xo + gamma*(xr-xo);\n            float ye = functionToOptimize(xe);\n\n            if(ye<yr)\n            {\n                x2 = xe;\n        \t\ty2 = ye;\n                k = 2;\n            }\n            else\n            {\n                x2 = xr;\n        \t\ty2 = yr;\n                k = 3;\n            }\n        }\n        // Contraction\n        else\n        {\n            vec2 xc = xo + rho*(x2-xo);\n            float yc = functionToOptimize(xc);\n\n            if(yc < y2)\n            {\n                x2 = xc;\n        \t\ty2 = yc;\n                k = 4;\n            }\n        \t// Shrink\n            else\n            {\n                x1 = x0 + sigma*(x1-x0);\n        \t\ty1 = functionToOptimize(x1);\n                x2 = x0 + sigma*(x2-x0);\n        \t\ty2 = functionToOptimize(x2);\n                k = 5;\n            }\n        }\n    }\n    \n    if(coord.x == 0)\n        fragColor = vec4(x0,y0,float(k)/6.);\n    else if(coord.x == 1)\n        fragColor = vec4(x1,y1,float(k)/6.);\n    else\n        fragColor = vec4(x2,y2,float(k)/6.);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n\nconst vec2 dx = vec2(1e-5, 0.);\nconst vec2 dy = dx.yx;\n#define DIFF(FUNC, X) (vec2(FUNC(X+dx)-FUNC(X-dx), FUNC(X+dy)-FUNC(X-dy))/dx.x*.5)\n\n\nconst float a = 1.0;\nconst float b = 100.0;\n\nfloat rosenbrock(in vec2 X)\n{\n    return (a-X.x)*(a-X.x) + b*(X.y-X.x*X.x)*(X.y-X.x*X.x);\n}\n\n\nfloat rosenbrock_(in vec2 X)\n{\n    return log(rosenbrock(X)+1.)*.1;\n}\n\nfloat himmelblau(in vec2 X)\n{\n    X *= 5.;\n    return (X.x*X.x+X.y-11.0)*(X.x*X.x+X.y-11.0) + (X.x+X.y*X.y-7.)*(X.x+X.y*X.y-7.);\n}\n\n\nfloat himmelblau_(in vec2 X)\n{\n    return log(himmelblau(X)+1.)*.1;\n}\n\n\nfloat functionToOptimize(in vec2 X)\n{\n    //*\n    //return rosenbrock(X);\n    return rosenbrock_(X);\n\t/*/\n    return himmelblau_(X);\n    //*/\n}\n\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n    \nstruct Grid\n{\n    float inter;\n};\n    \nstruct Triangle\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = mod(p,g.inter);\n    d = min(d, g.inter-d);\n    return min(d.x, d.y);\n}\n\n\nfloat dist(Triangle t, in vec2 p )\n{\n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\t//return -sqrt(d.x)*sign(d.y);\n\treturn sqrt(d.x);\n}\n\nfloat alg_dist(Triangle t, in vec2 p)\n{\n    \n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n\n#define DRAW(O,P,C,W, CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2. -  W, -1., 1.)*.5+.5))\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This tab implements the Gradient descent method.\n\nconst int frames = 20;\t// frame skipping coeff (for a slower animation)\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // represents the working triangle in the first 3 pixels of the buffer, the rest is discarded\n    \n    ivec2 coord = ivec2(floor(fragCoord));\n    if(coord.x > 2 || coord.y > 0)\n        discard;\n    \n    vec4 v0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    vec2 x0 = v0.xy;\n    \n    if(iMouse.z > .5)\n    {\n        x0 = (iMouse.xy -iResolution.xy*.5)/iResolution.y*3.;\n    \tfragColor = vec4(x0,0.0, 0.0);\n        return;\n    }\n    \n    if(iFrame  == 0)\n    {\n        x0 = vec2(0.0);\n    \tfragColor = vec4(x0,0.0, 0.0);\n        return;\n    }\n    else if(iFrame%frames == 0 || texelFetch(iChannel1, ivec2(32, 2), 0).x > .5) // frame skipping\n    {\n        vec2 grad = DIFF(functionToOptimize, x0);\n        vec2 dir = -grad;\n        dir = normalize(dir);\n        \n        float dt = 0.01;\n        float t = 0.;\n        \n        vec2 curPos = x0;\n        float curVal = functionToOptimize(curPos);\n        \n        \n        for(int i=0; i<100; ++i)\n        {\n            vec2 nextPos = x0 + dir*(t+dt);\n        \tfloat nextVal = functionToOptimize(nextPos);\n            if(nextVal>=curVal)\n            {\n                dt /= 2.;\n                //break;\n            }\n            else\n            {\n                curPos = nextPos;\n                curVal = nextVal;\n                t += dt;\n                //dt *= 1.5;\n            }\n        }\n        \n        \n        x0 += dir*t;\n    }\n    \n    fragColor = vec4(x0,0.0, 0.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This tab implements the Gradient descent method.\n\nconst int frames = 20;\t// frame skipping coeff (for a slower animation)\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // represents the working triangle in the first 3 pixels of the buffer, the rest is discarded\n    \n    ivec2 coord = ivec2(floor(fragCoord));\n    if(coord.x > 2 || coord.y > 0)\n        discard;\n    \n    vec4 v0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    vec2 x0 = v0.xy;\n    vec2 dir;\n    \n    if(iMouse.z > .5)\n    {\n        x0 = (iMouse.xy -iResolution.xy*.5)/iResolution.y*3.;\n    }\n    \n    if(iFrame  == 0)\n    {\n        x0 = vec2(0.0);\n    }\n    \n    \n    \n    dir = vec2(1., 0.);\n    if(dot(dir, DIFF(functionToOptimize, x0))>0.)\n        dir *= -1.;\n    \n    \n    if(iFrame%frames != 0 && texelFetch(iChannel1, ivec2(32, 2), 0).x < .5 || iMouse.z > 0.) // frame skipping\n    {\n    \tfragColor = vec4(x0, dir);\n        return;\n    }\n    \n\n    float dt = 0.01;\n    float t = 0.;\n\n    vec2 curPos = x0;\n    float curVal = functionToOptimize(curPos);\n\n\n    for(int i=0; i<100; ++i)\n    {\n        vec2 nextPos = x0 + dir*(t+dt);\n        float nextVal = functionToOptimize(nextPos);\n        if(nextVal>=curVal)\n        {\n            dt /= 2.;\n            //break;\n        }\n        else\n        {\n            curPos = nextPos;\n            curVal = nextVal;\n            t += dt;\n            //dt *= 1.5;\n        }\n    }\n\n\n    x0 += dir*t;\n    \n    \n    \n    \n    \n    dir = vec2(0., 1.);\n    if(dot(dir, DIFF(functionToOptimize, x0))>0.)\n        dir *= -1.;\n    dt = 0.01;\n    t = 0.;\n\n    curPos = x0;\n    curVal = functionToOptimize(curPos);\n\n\n    for(int i=0; i<100; ++i)\n    {\n        vec2 nextPos = x0 + dir*(t+dt);\n        float nextVal = functionToOptimize(nextPos);\n        if(nextVal>=curVal)\n        {\n            dt /= 2.;\n            //break;\n        }\n        else\n        {\n            curPos = nextPos;\n            curVal = nextVal;\n            t += dt;\n            //dt *= 1.5;\n        }\n    }\n\n\n    x0 += dir*t;\n    \n    \n    \n    \n    fragColor = vec4(x0,dir);\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}