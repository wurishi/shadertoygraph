{"ver":"0.1","info":{"id":"dd3BzB","date":"1714830426","viewed":99,"name":"A multiple balls falling","username":"bowari","description":"You can change all the parameters of this simulation in the common file.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------------\n// --------------------------------------- SKY DOME -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\n//cheap skydome from : https://www.shadertoy.com/view/tsXSRs\nvec3 skydome(vec3 p_rayD){\n    vec2 uv = vec2(atan(p_rayD.x,p_rayD.y),acos(-p_rayD.z));\n\n    const vec3 ground   = pow(vec3(0.416, 0.396, 0.382), vec3(GAMMA));\n    const vec3 horizon  = pow(vec3(0.915, 0.97, 0.99),   vec3(GAMMA));\n    const vec3 sky_low  = pow(vec3(0.827, 0.94, 0.96),   vec3(GAMMA));\n    const vec3 sky_mid  = pow(vec3(0.541, 0.637, 0.78),  vec3(GAMMA));\n    const vec3 sky_high = pow(vec3(0.403, 0.5, 0.655),   vec3(GAMMA));\n    const vec3 sky_top  = pow(vec3(0.271, 0.345, 0.482), vec3(GAMMA));\n    \n    vec3 h = vec3(0); \n    h = mix(ground, horizon, smoothstep(PI*0.5-0.02, PI*0.51, uv.y));\n    h = mix(h, sky_low,  smoothstep(PI*0.5-0.02, PI*0.53, uv.y));\n    h = mix(h, sky_mid,  smoothstep(PI*0.5, PI*0.6, uv.y));\n    h = mix(h, sky_high, smoothstep(PI*0.52, PI*0.8, uv.y));\n    h = mix(h, sky_top,  smoothstep(PI*0.54, PI, uv.y));\n    \n    vec3 val = 0.25+mix(h+sky_low*0.01, h, smoothstep(PI*0.2, PI*0.6, uv.y));\n    return 2.*val*val*val;\n}\n\n// ------------------------------------------------------------------------------------------\n// ---------------------------------------- RENDER ------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nvec3 trace( in vec3 p_rayD, in vec3 p_rayO){ \n    // --- primary ray ---\n    float t=TMAX;\n    vec3 normal, albedo;\n    \n    if(intersectPlane(p_rayD,p_rayO,vec3(0.),vec3(0.,0.,1.),TMIN,1e10,t)){\n        normal = vec3(0.,0.,-1.);\n        albedo = vec3(0.4);\n    }\n    \n    for(int i=0; i<NB_BALL ;i++){\n        vec4 sphereData = vec4(\n            texelFetch(iChannel1, ivec2((i*5+2)%int(iResolution.x),(i*5+2)/int(iResolution.x)), 0).xyz,\n            texelFetch(iChannel1, ivec2((i*5+1)%int(iResolution.x),(i*5+1)/int(iResolution.x)), 0).y);\n        if(intersectSphere(p_rayD, p_rayO, sphereData, TMIN, min(t,TMAX), t)){\n            normal = normalize((p_rayD*t+p_rayO)-sphereData.xyz);\n            albedo = texelFetch(iChannel1, ivec2((i*5)%int(iResolution.x),(i*5)/int(iResolution.x)), 0).xyz;\n        }\n    }\n    \n    if(t==TMAX) return skydome(p_rayD); \n    \n    // --- shadow ray ---\n    vec3 P = p_rayD*t+p_rayO+normal*0.01;\n    vec3 L = normalize(vec3(0.,0.5,0.5));\n    float shadow = 1.;\n    for(int i=0; i<NB_BALL ;i++){\n        vec4 sphereData = vec4(\n            texelFetch(iChannel1, ivec2((i*5+2)%int(iResolution.x),(i*5+2)/int(iResolution.x)), 0).xyz,\n            texelFetch(iChannel1, ivec2((i*5+1)%int(iResolution.x),(i*5+1)/int(iResolution.x)), 0).y);\n        if(intersectSphere(L, P, sphereData, TMIN, min(t,TMAX), t)) {shadow=0.; break;}\n    }\n    \n    // --- shading ---\n    if(dot(normal,-p_rayD)<0.) normal = -normal;\n    float cosNV = max(1e-5,dot(normal,-p_rayD));\n    float cosNL = max(0.,dot(normal,L));\n    float cosHL = max(0.,dot(normalize(L-p_rayD),L));\n    \n    float r = 1.;\n    float Rr = r*2.*cosHL*cosHL+0.5;\n    float Fl = pow5(1.-cosNL);\n    float Fv = pow5(1.-cosNV);\n    vec3 brdf = albedo*((1.-0.5*Fl)*(1.-0.5*Fv)+Rr*(Fl+Fv+Fl*Fv*(Rr-1.)))/PI;\n    \n    return max(albedo*0.04,brdf*1.*shadow*cosNL);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // --- setup --- \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //--- camera ---    \n    vec3 posCam = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz;\n    vec4 dataCam = texelFetch(iChannel0, ivec2(5%int(iResolution.x),5/int(iResolution.y)), 0);\n    \n    vec3 w = texelFetch(iChannel0, ivec2(2%int(iResolution.x),2/int(iResolution.y)), 0).xyz;\n    vec3 u = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec3 v = texelFetch(iChannel0, ivec2(1%int(iResolution.x),1/int(iResolution.y)), 0).xyz;\n    \n    vec3 vpV = v * dataCam.z;\n    vec3 vpU = u * dataCam.z * (iResolution.x/iResolution.y);\n    \n    // --- trace --- \n    vec3 color = vec3(0.);\n    for(int a=0; a<AA ;a++)\n        for(int b=0; b<AA ;b++)\n            color += trace(normalize((uv.x+(float(a)+0.5)/(iResolution.x*float(AA))-0.5)*vpU + (uv.y+(float(b)+0.5)/(iResolution.y*float(AA))-0.5)*vpV +w*dataCam.x),posCam);\n    color /= float(AA*AA);\n    \n    // tone map (aces)\n    color = clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59 ) + 0.14), 0., 1.);\n    //cheap gamma correction\n    color = pow(color,vec3(1./GAMMA));\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// --- constants ---\n#define INV_PI          0.318309\n#define PI              3.141592\n#define PI_TWO          1.570796\n#define PI_THREE        1.047197\n#define PI_SIX          0.523598\n#define TWO_PI          6.283185\n\n// --- ball ---\n#define NB_BALL         500\n#define DENSITY         25.\n#define RADIUS_MIN      10.\n#define RADIUS_MAX      20.\n#define VELOCITY_BOUND  20.\n#define RESTITUTION     0.99\n#define GRAVITY         vec3(0.,0.,-981.)\n#define DT              0.016\n\n// --- camera ---\n#define POS_CAM         vec3(0.,300.,100.)\n#define LOOKAT          vec3(0.,0.,0.)\n#define FOCAL_DISTANCE  2.5\n#define FOVY            PI_THREE\n\n// --- render ---\n#define AA              2\n#define TMIN            0.\n#define TMAX            1000.\n#define GAMMA           2.2\n\n// --- function ---\n#define pow5(a) (a)*(a)*(a)*(a)*(a) \n\nuint seed;\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- RANDOM -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nuint pcg(){\n    uint state = seed*747796405U+2891336453U;\n    uint tmp  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    return (seed = (tmp >> 22U) ^ tmp);\n}\n\nfloat rand(){return float(pcg())/float(0xffffffffU);}\n\n// ------------------------------------------------------------------------------------------\n// ---------------------------------------- SHADING -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nfloat schlick(in float f0, in float f90, in float cosT){\n    return f0 + (f90-f0) * pow5(1.-cosT);\n} \n\n// ------------------------------------------------------------------------------------------\n// -------------------------------------- EVALUATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\nbool intersectSphere(in vec3 p_rayD, in vec3 p_rayO, in vec4 p_sphereData, in float p_tmin, in float p_tmax, inout float p_t) {\n    vec3 centerToRayO  = p_rayO - p_sphereData.xyz;\n\n\tfloat b = 2.*dot(p_rayD,centerToRayO);\n\tfloat c = dot(centerToRayO,centerToRayO) - (p_sphereData.a*p_sphereData.a);\n\tfloat delta = b*b - 4.*c;\n\n\tif(delta<0.) {}\n\telse if(delta==0.f) { \n        float t = -0.5*b; \n        if(t>p_tmin && t<p_tmax) { p_t=t; return true; }\n    }\n\telse {\n\t\tfloat tmp = sqrt(delta);\n\t\tfloat t1 = -0.5*(b+tmp);\n        float t2 = 0.5*(tmp-b);\n        if(t1>p_tmin && t1<p_tmax && t2>p_tmin && t2<p_tmax) { p_t=(t1<t2) ? t1 : t2; return true; }\n        if(t1>p_tmin && t1<p_tmax) { p_t=t1; return true; }\n        if(t2>p_tmin && t2<p_tmax) { p_t=t2; return true; }\n\t}\n\n    return false;\n}\n\nbool intersectPlane(in vec3 p_rayD, in vec3 p_rayO, in vec3 p_planeO, in vec3 p_planeN, in float p_tmin, in float p_tmax, inout float p_t) {\n    float d = dot(p_rayD, p_planeN);\n\tif (abs(d) > 0.f) {\n        float t = dot(p_planeO-p_rayO, p_planeN) / d;\n\t\tif(t>p_tmin && t<p_tmax) { p_t=t; return true; }\n\t}\n\treturn false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer store the camera data\n// inspired by : https://www.shadertoy.com/view/wsVSDd\n\nmat3 rotationMatrix(in vec3 p_rot){\n    vec3 c = vec3(cos(p_rot.x),cos(p_rot.y),cos(p_rot.z));\n    vec3 s = vec3(sin(p_rot.x),sin(p_rot.y),sin(p_rot.z));\n    \n    mat3 rx = mat3(1., 0., 0., 0., c.x, -s.x, 0., s.x, c.x);\n    mat3 ry = mat3(c.y, 0., s.y, 0., 1., 0., -s.y, 0., c.y);\n    mat3 rz = mat3(c.z, -s.z, 0., s.z, c.z, 0., 0., 0., 1.);\n    \n    return rz*ry*rx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, iFragCoord, 0);\n    int index = iFragCoord.x+iFragCoord.y*int(iResolution.x);\n    \n    if(iFrame==0){\n        vec3 w = normalize(LOOKAT - POS_CAM);\n        vec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n        vec3 v = normalize(cross(w, u));\n    \n        if(index==0) fragColor = vec4(u,0.);       // u\n        if(index==1) fragColor = vec4(v,0.);       // v\n        if(index==2) fragColor = vec4(w,0.);       // w\n        \n        if(index==3) fragColor = vec4(POS_CAM,0.); // camPos\n        if(index==4) fragColor = vec4(LOOKAT,0.);  // lookAt\n        if(index==5) fragColor = vec4(FOCAL_DISTANCE,FOVY,2.*tan(0.5*FOVY)*FOCAL_DISTANCE,1.); // camData : focalDistance,fovy,vpSize,isMoving\n        \n        if(index==6) fragColor = vec4(iMouse);                 // mouse data\n        if(index==7) fragColor = vec4(iResolution.xy,0.,0.);   // resolution\n    }else{\n        vec4 mouseData = texelFetch(iChannel0, ivec2(6%int(iResolution.x),6/int(iResolution.y)), 0);\n        vec2 oldResolution = texelFetch(iChannel0, ivec2(7%int(iResolution.x),7/int(iResolution.y)), 0).xy;\n        \n        float isMoving = 0.;\n        \n        if(iResolution.x != oldResolution.x || iResolution.y != oldResolution.y) isMoving = 1.;\n        \n        if(iMouse.z>=0. && mouseData.z>=0. && (iMouse.x != mouseData.x || iMouse.y != mouseData.y)){\n            vec3 cameraPosition = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz * \n                                  rotationMatrix(vec3(0.,0.,(mouseData.x-iMouse.x)*(iResolution.x/iResolution.y) * 0.005));\n            \n            vec3 w = normalize(texelFetch(iChannel0, ivec2(4%int(iResolution.x),4/int(iResolution.y)), 0).xyz - cameraPosition);\n            vec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n            vec3 v = normalize(cross(w, u));\n            \n            if(index==0) fragColor = vec4(u,0.);\n            if(index==1) fragColor = vec4(v,0.);\n            if(index==2) fragColor = vec4(w,0.);\n            \n            if(index==3) fragColor = vec4(cameraPosition,0.);\n            \n            isMoving = 1.;\n        }\n        \n        if(index==5) fragColor = vec4(fragColor.xyz,isMoving); \n        if(index==6) fragColor = vec4(iMouse);\n        if(index==7) fragColor = vec4(iResolution.xy,0.,0.);    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    seed = uint(iFrame*(int(iResolution.x*iResolution.y)))+uint(fragCoord.x+fragCoord.y*iResolution.x);\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0,iFragCoord,0);\n    \n    int index = iFragCoord.x+iFragCoord.y*int(iResolution.x);\n    int numBall = index/5;\n    \n    if(numBall<NB_BALL){\n        if(iFrame==0) {\n            float radius = 5.+10.*rand();            \n            float density = 0.5+rand();\n            float mass = density*4.*PI_THREE*radius*radius*radius;\n            \n            vec3 pos = 2.*(90.-radius)*vec3(rand(),rand(),rand())-90.+radius;\n            \n            if(index%5==0) fragColor = vec4(rand(),rand(),rand(),0.); // albedo\n            if(index%5==1) fragColor = vec4(mass,radius,density,0.);  // mass + radius + density \n            if(index%5==2) fragColor = vec4(pos,0.);                  // actual position\n            if(index%5==3) fragColor = vec4((vec3(rand(),rand(),rand())-0.5)*2.*VELOCITY_BOUND,0.);                      // velocity\n            if(index%5==4) fragColor = vec4(0.);                      // somme des forces \n        }else{\n            vec3 ballData  = texelFetch(iChannel0, ivec2((5*numBall+1)%int(iResolution.x),(5*numBall+1)/int(iResolution.x)), 0).xyz;\n            vec3 pos       = texelFetch(iChannel0, ivec2((5*numBall+2)%int(iResolution.x),(5*numBall+2)/int(iResolution.x)), 0).xyz;\n            vec3 vel       = texelFetch(iChannel0, ivec2((5*numBall+3)%int(iResolution.x),(5*numBall+3)/int(iResolution.x)), 0).xyz;\n            vec3 sumForces = texelFetch(iChannel0, ivec2((5*numBall+4)%int(iResolution.x),(5*numBall+4)/int(iResolution.x)), 0).xyz;\n        \n            vec3 a = GRAVITY - vel*(length(vel)*0.9195*0.25/ballData.y) + sumForces/ballData.x;\n            vel += a*DT;\n            pos += vel*DT;\n            \n            sumForces = vec3(0.);\n            \n            if(pos.z-ballData.y<0.){\n                vel.z *= -RESTITUTION;\n                pos.z = max(pos.z,0.+ballData.y);\n            }\n        \n            if(index%5==2) fragColor = vec4(pos,0.);\n            if(index%5==3) fragColor = vec4(vel,0.);\n            if(index%5==4) fragColor = vec4(0.);\n            \n            // colision ball-ball\n            if(index%5==4){            \n                for(int i=0; i<NB_BALL ;i++){\n                    if(numBall==i) continue;\n                    float R = ballData.y + texelFetch(iChannel0, ivec2((5*i+1)%int(iResolution.x),(5*i+1)/int(iResolution.x)), 0).y;\n                    vec3 vec = pos-texelFetch(iChannel0, ivec2((5*i+2)%int(iResolution.x),(5*i+2)/int(iResolution.x)), 0).xyz;\n                    float d2 = dot(vec,vec);\n\n                    if(d2<(R*R)){\n                        float d = sqrt(d2);\n                        fragColor += vec4(vec*1000000.*(R-d)/d,0.);\n                    }\n                }\n            }\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}