{"ver":"0.1","info":{"id":"43KGRm","date":"1717437072","viewed":146,"name":"REAC Wave","username":"Chosko","description":"Reac logo","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of cells\n#define TILES  20.0\n// Time frequency of waves\n#define W_FREQ 1.\n#define PI2 6.2831\n#define TR_EXC 50.0\n#define TR_SPEED 0.05\n\nuint[] logo20x5 = uint[5]( 376103u,336168u,473576u,303400u,474311u );\n\nvec2 cellTransform (vec2 xy) {\n    return xy + TR_EXC * vec2(\n        sin(iTime * TR_SPEED),\n        cos(iTime * TR_SPEED)\n    );\n}\n\nfloat getLogo(vec2 xy){\n xy = cellTransform(xy);\n xy -= 10.0;\n // should be faster than modulo\n xy.x = xy.x - (floor(xy.x/20.f)*20.f);\n xy.y = xy.y - (floor(xy.y/6.f)*6.f);\n ivec2 ixy = ivec2(xy);\n if(ixy.y==5) return 0.f;\n return ((logo20x5[ixy.y] << ixy.x) & (1u<<19u)) != 0u ? 1.0f : 0.0f;\n}\n\nfloat sinRand (float x, float seed) {\n    return fract(sin(x + 123.0) * 10000.0 * seed);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    o -= o;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.y, iResolution.x);\n    float t = iTime * .3 + 8.0;\n    \n    // --- Smooth effect input vars - Part 1 ---\n    vec2  sCellID = (uv * TILES);     // Cell ID\n    float isLogo = getLogo(sCellID);  // Logo mask\n    t += (isLogo * .75);\n    \n    // --- Spatial and temporal parameters\n    float tLenPow = -sin(t * .3) * .5 + .5;\n    float wLen = mix(20.0, 70.0, tLenPow); // Wave length in number of cells. Varies with time\n    float wPow = mix(2.5, 7.5, mix(max(tLenPow, 2.0), 0.0, isLogo));  // Wave power (affects thickness)\n    \n    //float rot = sin(t * 0.01) * length(uv) * clamp(pow(t*0.01,2.0),0.0,1.0);\n    //float sa = sin(rot);\n    //float ca = cos(rot);\n    //uv.xy = mat2x2(ca, -sa, sa, ca) * uv.xy;\n    \n    // --- Smooth effect input vars - Part 2 ---\n    vec2  sCellUV = fract(cellTransform(sCellID)) - .5;  // Cell's local UV (centered)\n    float sProg   = length(sCellID - 1. * sign(sCellID)) / wLen - t * W_FREQ; // Linear space-time progression\n    float sWaveID = floor(sProg);                        // Wave ID (progressive integer)\n    float sWave   = fract(sProg);                        // Wave progression\n          \n    // --- Pixelated effect input vars ---\n    vec2  pCellID = floor(cellTransform(sCellID));  // Cell ID\n    \n    // --- How much the effect must be pixelated ---\n    float cellSmoothness = sinRand(sWaveID, 1.0); // How much pixelated the effect is\n    \n    // --- Final effect input vars ---\n    vec2  cellUV = sCellUV;                               // UV are computed from the smooth effect\n    vec2  cellID = mix(sCellID, pCellID, cellSmoothness); // Lerp between smooth and pixelated\n    float prog   = length(cellID) / wLen - t * W_FREQ;    // Linear space-time progression\n    float waveID = floor(prog);                           // Wave ID (progressive integer)\n    float wave   = fract(prog);                           // Wave progression\n    \n    // --- How much the effect must be colored ---\n    float colorness = sinRand(waveID, 1.4214);\n    \n    // --- Shape ---\n    float shape = sinRand(waveID + isLogo * 8.0, .89928);\n    \n    // --- Effect ---\n    float r = pow(wave, wPow); // Cell shape radius based on wave progression\n\n    vec4 col = 1.5 * abs(vec4(cellID.x + cellUV.y,0.5,cellID.y + cellUV.x,1.0) / TILES + sin(1.21 * (t + isLogo)));\n    \n    float p = mix(0.1, 3.5, shape);\n    float len = pow(pow(abs(cellUV.x), p) + pow(abs(cellUV.y), p), 1.0 / p);\n    vec4 smoot = .4 / len * r * col;\n    vec4 bw = vec4(smoothstep(r * 0.5, r * 0.4, len));\n    \n    \n    //o.rgb = vec3(sin(sWaveID * 53331.094) * .5 + .5);\n    o += mix(smoot, bw, colorness);\n    //o *= abs(fract(t*0.5) - 0.5) * 2.0 + 0.1;\n    \n    //o.r = isLogo;\n}","name":"Image","description":"","type":"image"}]}