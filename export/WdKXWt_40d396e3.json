{"ver":"0.1","info":{"id":"WdKXWt","date":"1575326665","viewed":449,"name":"[twitch] Drop of Distortion","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/DropOfDistortion.glsl","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","distortion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/DropOfDistortion.glsl\n*/\n\n#define ALL_COLORS 1\n\nfloat time;\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat tick(float t, float d) {\n  t/=d;\n  float g=fract(t);\n  g=smoothstep(0.0,1.0,g);\n  g=pow(g,10.0);\n  return (floor(t) + g)*d;\n}\n\n// Kaleidoscopic iterated function system\nvec3 kifs(vec3 p, float t) {\n  \n  for(int i=0; i<3; ++i) {\n    \n    float t1 = tick(t + float(i), 0.4 + float(i)*0.1) + t*0.3;\n    p.xz *= rot(t1);\n    p.yz *= rot(t1*0.7);\n    \n    //p = abs(p);\n    // symmetry on all axis with a smooth transition\n    p = smin(p, -p, -1.0);\n    p -= vec3(1.2,0.5,1.6);\n    \n  }\n  \n  return p;\n}\n\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  float t0 = time*0.7;\n  float t1 = tick(t0,1.3)*0.3 + t0*0.1;\n  p.xy *= rot(t1);\n  p.yz *= rot(t1*1.3);\n  \n  vec3 p2 = kifs(p, t0*0.3);\n  vec3 p3 = kifs(p+vec3(1,0,0.3), t0*0.2);\n  \n  float d = sph(p2, 1.0);\n  float d2 = cyl(p3.xz, 1.1);\n  \n  // substract d2 to d1 with a smooth transition\n  d = smin(d, -d2, -1.0);\n  \n  // remove whats above and below a depth plane to keep only a slice\n  d = smin(d, -bp.z-4.0, -0.3);\n  d = smin(d, bp.z-4.0, -0.3);\n  \n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime+0.6;\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec2 buv = uv;\n  \n  uv *= rot(time*0.1);\n\n  vec3 s=vec3(0,0,-17);\n  float fov = 1.0;//1.3+sin(tick(time,2.3) + time*0.4)*0.4;\n  vec3 r=normalize(vec3(-uv, fov));\n  \n  vec3 p=s;\n  float at=0.0;\n  bool inside = false;\n  // main raymarching loop\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.01) {\n      inside=true;\n      break;\n    }\n    if(d>100.0) {\n      break;\n    }\n    p+=r*d;\n    at+=0.9/(3.0+abs(d));\n  }\n  \n  // if we hit a surface\n  if(inside) {\n    vec2 off=vec2(0.01,0);\n    vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n    // refract the ray direction\n    r = refract(r, n, 0.7);\n  }\n  \n  float depth = length(p-s);\n  \n  // project the surface position on the screen to get new UVs but with the refraction applyed\n  float backscale = 0.9+sin(tick(time,2.3)*0.3 + time*0.1)*0.4;\n  vec2 uv2 = p.xy * backscale * fov / (depth * r.z);\n  \n  \n  vec2 grid = step(0.5,fract(uv2*7.0));\n  vec2 grid2 = abs(fract(uv2*12.0)-0.5)*2.0;\n  vec2 grid3 = abs(fract(uv2*12.0*rot(0.77))-0.5)*2.0;\n    \n  float val = min(grid.x, grid.y) + 1.0 - max(grid.x,grid.y);\n  \n  float prog = time * 0.3;\n  float preanim = floor(mod(prog-0.5, 6.0));\n  // transitions types\n  if(preanim == 0.0) {\n    prog += at*0.02;\n  } else if(preanim==1.0) {\n    prog -= length(uv)*0.2;\n  } else if(preanim==2.0) {\n    prog -= sin(atan(uv.y,uv.x)*5.0)*0.1;\n  } else if(preanim==3.0) {\n    prog -= min(abs(uv.x),abs(uv.y))*0.2;\n  } else if(preanim==4.0) {\n    prog -= length(uv)*0.1+sin(atan(uv.y,uv.x)*7.0)*0.05;\n  } else {\n    prog -= atan(buv.x,-buv.y)*0.05;\n  }\n  float anim = mod(prog, 6.0);\n  float scene = floor(anim);\n  \n  float wantinverse = floor(mod(prog/6.0,2.0));\n    \n  // background types\n  \n  if(scene == 1.0 ) {\n    val = step(min(grid2.x, grid2.y), 0.04);\n  }\n  \n  if(scene == 2.0) {\n    float di = fract(uv2.x*10.0-time*0.8)-0.5;\n    val = step(fract(uv2.y*10.0 + abs(di)*2.0),0.2);\n  }\n  \n  if(scene == 3.0) {\n    val = step(sin(min(grid3.x, grid3.y)*16.0), -0.3);\n  }\n  \n  vec2 gridSize = vec2(7,10)*1.3;\n  float ds = length((fract(uv2*gridSize)-0.5)*gridSize.y/gridSize);\n  float ds2 = length((fract(uv2*gridSize+0.5)-0.5)*gridSize.y/gridSize);\n  \n  if(scene == 4.0) {\n    val = step(abs(min(ds,ds2)-0.25), 0.025);\n  }\n  \n  if(scene == 5.0) {\n    val = step(abs(ds-ds2)-0.13,0.0);\n  }\n    \n  if(inside && wantinverse<0.5) {\n    val = 1.0-val;\n  }\n  \n  vec3 col=vec3(0);\n  \n  col += (val + 0.1);\n  \n  col *= at*0.08;\n  \n  // if on the second part, invert everything to get a white background\n  if(wantinverse>0.5) {\n    col = pow((1.0-col),vec3(12));\n  }\n  \n#if ALL_COLORS\n  // rotate all the colors\n  float t3 = scene*1.3 + time*0.05;\n  vec3 col2 = vec3(1,0.5,0.3);\n  col2.xz *= rot(t3);\n  col2.zy *= rot(t3*1.4);\n  col2=abs(col2);\n  col2=mix(col2, vec3(1), 0.4 + wantinverse*0.2);\n  \n  col *= col2;\n#endif\n  \n  col *= pow(max(0.0,1.3-length(uv)),0.8);\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}