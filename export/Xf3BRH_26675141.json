{"ver":"0.1","info":{"id":"Xf3BRH","date":"1732666236","viewed":44,"name":"multiverze","username":"pb","description":"more log(z) rings of rings","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"MctBRn","parentname":"pentagonal spirals"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime/3.\n#define too_small 1e-7\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n\nvoid mainImage0( out vec4 O, vec2 u )\n{\n\n    float jr = -.8, ja=0.;\n    \n    float zoom = 1. + 50.*mod(iTime,8.);\n    zoom*=zoom;\n    \n    vec2  R =  iResolution.xy, z,\n          U = ( u+u - R )/ R.y / zoom ,\n          M = jr*vec2(cos(ja),sin(ja));\n          \n    float i = 0.;\n    \n    //U *= rot( -iTime/4.);\n    \n    z=U + vec2(.03501,0);  //Julia set: input is each pixel coordinate\n    \n    vec2 maxz = vec2(0);\n    \n    float w1 = .92;\n    for ( O *= 0. ; i++ < 40. && dot(z,z) < 100. ; ) {\n         \n        float r = max(sqrt(z.x*z.x + z.y*z.y),too_small);\n        //we want the \"wrong\" atan which does not look at quadrant\n        float theta = abs(z.x)>too_small ? atan(z.y/z.x) : 0.0;\n\n        vec2 f1 = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y);\n        vec2 f2 = vec2(log(r), theta);\n        \n        z = w1*f2 + (1.-w1)*f1 + M;\n        \n        maxz.x = abs(z.x)>maxz.x ? abs(z.x) : maxz.x;\n        maxz.y = abs(z.y)>maxz.y ? abs(z.y) : maxz.y;\n        \n               \n    }\n    \n    vec2 cc = sin( log( maxz) * vec2(.5,3.) ) ;\n    cc *= cc  ; \n            \n    vec2 cc2 = sin( log(1.+z) * vec2(.5,2.) ) ;\n    cc2 *= cc2;\n    \n    O = vec4( cc.y,0,cc2.y,0 ) ;    \n    \n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > iResolution.x/1e4 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}