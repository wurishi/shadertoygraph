{"ver":"0.1","info":{"id":"clyfWW","date":"1702049480","viewed":74,"name":"triangle in space","username":"nayk","description":"space,cosmos,universe","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["space","cosmos","universe","trip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* /*original https://www.shadertoy.com/view/lslyRn, /* original https://www.shadertoy.com/view/lsyXDK https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DlycWR and other*/\n#define iterations 17\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n#define NUM_LAYERS 8.\n#define TAU 6.28318\n#define PI 3.141592\n#define Velocity .025 //modified value to increse or decrease speed, negative value travel backwards\n#define StarGlow 0.025\n#define StarSize 02.\n#define CanvasView 20.\n\nconst float MATH_PI\t= float( 3.14159265359 );\n\nvoid Rotate( inout vec2 p, float a ) \n{\n\tp = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1.0 ) * r;\n}\n\nfloat Rand( vec2 c )\n{\n\treturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat saturate( float x )\n{\n\treturn clamp( x, 0.0, 1.0 );\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c )   \n{\n    float wrap = 450.0;    \n    if ( mod( floor( p.y / wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n    }    \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    vec2 cell = floor( p / wrap + 0.5 );\n    float cellR = Rand( cell );\n        \n    c *= fract( cellR * 3.33 + 3.33 );    \n    float radius = mix( 30.0, 70.0, fract( cellR * 7.77 + 7.77 ) );\n    p2.x *= mix( 0.9, 1.1, fract( cellR * 11.13 + 11.13 ) );\n    p2.y *= mix( 0.9, 1.1, fract( cellR * 17.17 + 17.17 ) );\n    \n    float sdf = Circle( p2, radius );\n    float circle = 1.0 - smoothstep( 0.0, 1.0, sdf * 0.04 );\n    float glow\t = exp( -sdf * 0.025 ) * 0.3 * ( 1.0 - circle );\n    color += c * ( circle + glow );\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);\n  \tfloat m = sin(StarGlow*1.2)/d;  \n    float rays = max(0., .5-abs(uv.x*uv.y*1000.)); \n    m += (rays*flare)*2.;\n    m *= smoothstep(1., .1, d);\n    return m;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nvec3 StarLayer(vec2 uv){\n    vec3 col = vec3(0);\n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    for(int y=-1;y<=1;y++){\n        for(int x=-1; x<=1; x++){\n            vec2 offs = vec2(x,y);\n            float n = Hash21(id+offs);\n            float size = fract(n);\n            float star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.1,.9,size)*.46);\n            vec3 color = sin(vec3(.2,.3,.9)*fract(n*2345.2)*TAU)*.25+.75;\n            color = color*vec3(.9,.59,.9+size);\n            star *= sin(iTime*.6+n*TAU)*.5+.5;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\n\n\nconst float nbCircle = 13.; \n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nfloat udTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n  vec2 ab = b - a; vec2 pa = a - p;\n  vec2 bc = c - b; vec2 pb = b - p;\n  vec2 ca = a - c; vec2 pc = c - p;\n    \n  float d0 = dot(perp(ab), pa);\n  float d1 = dot(perp(bc), pb);\n  float d2 = dot(perp(ca), pc);\n    \n  return min(min(d0, d1), d2);\n}\n\nfloat sdfTriangle(vec2 p)\n{\n    float radius = 1.2;\n    float angle = iTime * 0.8;\n    vec2 a = rotate( angle, radius);\n    vec2 b = rotate( TAU / 3. + angle, radius);\n    vec2 c = rotate( 2. * TAU / 3. + angle, radius);\n    \n    return udTriangle(p, a, b, c);\n}\n\nfloat radFilter(float v)\n{\n    return smoothstep(100. / iResolution.y, 0., abs(v-1.));\n}\n\nfloat distFilter(float v)\n{\n    return smoothstep(0., 0.5, v);\n}\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1)); \n    \n    \n    \n    vec2 p2 = (2. *  C - iResolution.xy) / iResolution.y;\n    float\tangle = atan(p2.y, p2.x);\n    float \tl = length(p2) * nbCircle;\n    float\tcircleId = floor(l);\n \n\n    float\ts = 0.6;    \n  \n    float\tmodCircleId = mod(circleId, 2.);\n    float d2 = sdfTriangle(p2);\n    d2 = distFilter(d2);\n    float speed = mix(0.1, -0.1, modCircleId);\n    l+= sin((angle - iTime * speed) * circleId * 5.) * 0.5 * d2 * s;\n    l = fract(l) * 2.;\n    float\tt2 = min(l, 2. - l);\n    t2 = radFilter(t2); \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    \t\n    {\n        p=g*d;\n        p.z+=iTime*5.5;\n          p.y+=cos(iTime)*5.5;\n             p.x+=sin(iTime)*5.5;\n        a=50.;\n        p=mod(p-a,a*2.)-a;\n        s=7.;\n         p.xz*=mat2(cos(iTime*1.1),sin(iTime*1.1),-sin(iTime*1.1),cos(iTime*1.1));\n           p.zy*=mat2(cos(iTime*1.1),sin(iTime*1.1),-sin(iTime*1.1),cos(iTime*1.1));\n            p.xy*=mat2(cos(iTime*1.1),sin(iTime*1.1),-sin(iTime*1.1),cos(iTime*1.1));\n            p.yz*=mat2(cos(iTime*1.1),sin(iTime*1.1),-sin(iTime*1.1),cos(iTime*1.1));\n        for(int i=0;i++<8;){\n            p=0.3-abs(p);\n         \n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*1.3+.5*cos(iTime*1.3))*3.,\n                    25,\n                    8.+cos(iTime*1.2)*5.\n                 )*d2 ;\n         }\n         g+=e=length(p.yz)/s;\n          g+=e=length(p.yx)/s;\n    }\n}","name":"Image","description":"","type":"image"}]}