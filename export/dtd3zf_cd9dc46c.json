{"ver":"0.1","info":{"id":"dtd3zf","date":"1682885241","viewed":117,"name":"sessions party - shader jam ","username":"anticore","description":"coded live at sessions demoparty","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["shader","jam","demoparty","sessions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ffti =11.3;\nfloat ffts = 0.02;\n  float fftr = 2.;\n\n float blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) { \n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 vv = abs(p)-b;\n    return max(vv.x, vv.y);\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    float d = length(p.xz)-r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\n\nfloat plane(vec3 p, vec3 n, float d) {\n    return dot(p,n)+d;\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat modpolar(inout vec2 p, float n) {\n    float ng = 2. * 3.14159 / n;\n    float a = atan(p.y, p.x) + ng / 2.;\n    float r = length(p);\n    float c = floor(a / ng);\n    a = mod(a, ng) - ng / 2.;\n    p = vec2(cos(a), sin(a)) * r;\n    if (abs(c) >= (n / 2.))\n        c = abs(c);\n    return c;\n}\n\n\nvec2 map(vec3 p) {\n    float dist = 999.;\n   float id = 0.;\n  \n  \n    vec3 sphP = p + vec3(\n    sin(iTime * 1.) * 1.,\n  \n    sin(iTime * 2.) * 0.3,\n  \n    sin(ffti * 2.) * 1.\n  );\n  float sph = sphere(sphP, .3);\n  \n  vec3 cylP = sphP;\n  pR(cylP.xz, iTime);\n  pR(cylP.xy, cos(length(cylP.xy) * 0.5) + iTime);\n  pR(cylP.xz, sin(length(cylP.xz) * 0.5) + ffti);\n  modpolar(cylP.yz, 6.);\n  modpolar(cylP.yx, 6.);\n  float cyl = cylinder(cylP, 0.03 * ffts, 10.);\n  \n  if (cyl < dist) {\n      dist = cyl;\n    id = 0.;\n  }\n  \n  if (sph < dist){\n      dist = sph;\n     id = 1.;\n   }\n   \n   \n   float walls = -box(p.xy, vec2(3., 1.));\n   if (walls < dist){\n      dist = walls;\n     id = 1.;\n   }\n   \n   float wall = plane(p, vec3(0., 0., 1.), 2.);\n   if (wall < dist) {\n     dist = wall;\n      id = 2.;     \n    }\n   \n   return vec2(dist, id);\n}\n\n\nvec3 norm(vec3 p) {\n    float E = 0.0001;\n    vec2 k = vec2(1., -1.);\n   return normalize(\n      k.xyy * map(p + k.xyy * E).x +\n      k.yyx * map(p + k.yyx * E).x +\n      k.yxy * map(p + k.yxy * E).x +\n      k.xxx * map(p + k.xxx * E).x\n  );\n}\n\nfloat ao(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d).x / d, 0., 1.);\n}\n\n\nvec4 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = .1;\n    vec2 h;\n  \n  vec3 c = vec3(0.);\n  vec3 g = vec3(0.);\n  vec3 gcol = vec3(1.);\n  \n  int bnc = 0;\n  float en = 1.;\n  \n  for (int i = 0; i < 256; i++) {\n      vec3 ip = ro + rd * td;\n      h = map(ip);\n     td += h.x * 0.5;\n    \n      if (h.y == 0.) {\n          g += gcol * exp(-h.x * 10.) * (0.04);\n      }\n    \n      if (h.x < 0.001) {\n          vec3 inorm = norm(ip);\n        \n         if (h.y  == 0.) {\n            c = gcol;\n            break;\n         } else if (h.y == 1.) {\n            float nz = texture(iChannel0, ip.xz).r / 2. + texture(iChannel0, ip.zy).r / 2.;\n           \n            c += vec3(nz * .15) * en * ao(ip, inorm, .1);\n            ro = ip;\n            rd = reflect(rd, inorm + (nz * .2 - .1));\n            td = .1;\n            bnc += 1;\n            en -= .7;\n         } else {\n           vec3 tp = ip;\n           \n      pR(tp.xy, ffts * 2. + 0.5);\n            //c += vec3(1.,0.,0.) - texture(_tex1, tp.xy * vec2(-.5, -1.) + vec2(_t*0.2, ffti)).r * vec3(1., ffts * 10., 0.).r * en; \n           c += vec3(mod(floor(tp.x * 2.), 2.) * vec3(1., ffts * 10., 0.)) * en;\n           break;\n         }\n      }\n      \n      if (h.x > 100. || bnc > 3 || en < 0.) {\n          break;\n      }\n  }\n  \n  return vec4(c + g, 1.);\n}\n\n\nvec3 cam(vec3 pos, vec3 dir, vec2 uv) {\n    vec3 f = normalize(dir - pos);\n    vec3 l = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = normalize(cross(f, l));\n    return normalize(f + l * uv.x + u * uv.y);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  vec3 ro = vec3(smoothstep(0.,1.,sin(iTime)) * 2., 0., 5.);\n  vec3 rd = cam(ro, vec3(0.), uv);\n \n  \n  vec3 rc = tr(ro, rd, uv).rgb;\n  vec3 fc = blendColorBurn(tr(ro, rd, uv).rgb, texture(iChannel1, uv * vec2(1., -1.) * 1. + iTime * 0.1  + (ffts * 4. *  texture(iChannel0, uv).r)).rgb * vec3(1.,abs(sin(ffti * 0.2)), 0.));\n  \n  fragColor = vec4(mix(rc, fc, ffts * 3.), 1.);\n}","name":"Image","description":"","type":"image"}]}