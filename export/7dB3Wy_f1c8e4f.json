{"ver":"0.1","info":{"id":"7dB3Wy","date":"1617981480","viewed":131,"name":"Flying Vectorama logoish thing","username":"eimink","description":"Vectorama is a lanparty held in Oulu, Finland. Their logo is a penrose triangle. Virtuaalirama is online version of that.\nGrid coloring and inspiration from Flyguy's awesome work at https://www.shadertoy.com/view/4dt3RX","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define line1 V_ I_ R_ T_ U_ A_ A_ L_ I_ R_ A_ M_ A_\n#define M_PI 3.14159\n#define GRID_SIZE 2.0\n#define GRID_LINE_SIZE 1.25\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(1.00, 0.20, 0.60)\n#define SPEED 20.0\n\n#define GROUND 1.0\n#define FLYER 2.0\n#define BACKDROP 3.0\n#define TEXT 4.0\n\n#define RENDER_TEXT true\n\nvec3 glow = vec3(0.);\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\n\n#define ch(l,w) x = min(x,l(clc(pp,cp+=w,w)));\n\n#define A_ ch(AA,0.7);\n#define I_ ch(II,0.5);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define R_ ch(RR,0.7);\n#define V_ ch(VV,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n\nvec2 clc(vec2 uv, float cp, float w) {\n    return uv-vec2(cp-(w*.5),0.);\n}\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat text(vec3 p){\n   p = vec3(p.x-4.5,p.y-5.,p.z+2.+iTime*SPEED);\n   rot(p.xz,M_PI);\n   rot(p.yz,-.3);\n   vec2 pp = p.xy;\n   float cp = 0.;\n   float x = 1.;\n   line1;\n   vec3 bd = vec3(9.,1.,0.2);\n   float res = max(x,sdBox(p,bd));\n   return res;\n}\n\nfloat backdrop(vec3 p){\n    vec3 pp = vec3(p.xy,p.z+51.+iTime*SPEED);\n    rot(pp.xz,M_PI*.5);\n    float a = sdPlane(pp,vec3(1.,0.,0.),10.);\n    return a;\n}\n\nfloat ground(vec3 p){\n   float a = sdPlane(p,vec3(0.,1.,-0),15.);\n   float b = sdPlane(p,vec3(.5,1,0.),20.);\n   float c = sdPlane(p,vec3(-.5,1,0.),20.);\n   float d = cos(p.x*.04)*8.+(sin(p.z*.5)+cos(p.x*.3)+sin(p.y*.5))*1.2;\n   return min(a,min(b,c));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 scene2(vec3 p) {\n   vec3 pp = vec3(p.x-sin(iTime)*5.-sin(2.*iTime),(p.y-sin(iTime*.5)*2.)+2.,p.z+3.0+iTime * SPEED);\n   rot(pp.xy,M_PI);\n   rot(pp.yz,-M_PI*.5);\n   rot(pp.xz,sin(iTime)+cos(iTime*.5));\n   float prism = sdTriPrism(pp,vec2(3.,.6));\n   float prism2 = sdTriPrism(pp,vec2(4.,.5));\n   vec2 gnd = vec2(ground(p),GROUND);\n   vec2 flyer = vec2(max(-prism,prism2),FLYER);\n   glow += vec3(0.6,0.1,0.1)*0.025/(0.5+abs(prism));\n   vec2 backdr = vec2(backdrop(p),BACKDROP);\n   vec2 res = opU(opU(gnd,flyer),backdr);\n   if (RENDER_TEXT == true) {\n       vec2 txt = vec2(text(p),TEXT);\n       res = opU(res,txt);\n   }\n   return res;\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(scene2(pos+e.xyy).x-scene2(pos-e.xyy).x,\n                           scene2(pos+e.yxy).x-scene2(pos-e.yxy).x,\n                           scene2(pos+e.yyx).x-scene2(pos-e.yyx).x ) );\n}\n\nMarchResult raymarch(in vec3 ro, in vec3 rd) {\n    vec3 p = ro+rd;\n    float s = 0.;\n    float id = GROUND;\n    float t = 0.;\n    for (int i = 0; i < 40; ++i){\n        vec2 d = scene2(p);\n        t += d.x;\n        p += rd*d.x;\n        s = float(i);\n        id = d.y;\n        if(d.x < 0.01 || t > 100.){\n            break;\n        }\n    }\n    MarchResult res;\n    res.position = p;\n    res.normal = calcNormal(p);\n    res.dist = t;\n    res.steps = s;\n    res.id = id;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(0.,4.,10.-iTime * SPEED);\n    vec3 ct = vec3(0,0,0.-iTime * SPEED);\n    vec3 ld = vec3(0.,15.,100. + iTime * SPEED);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    MarchResult m = raymarch(cp,rd);\n    \n    t = m.dist;\n    p = m.position;\n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        if (m.id == FLYER) {\n            col = vec3(abs(cos(p.z*.1)),.4,abs(sin(p.z*.1))) + (clamp(dot(m.normal, ld), 0.0, 1.0)*0.1);\n        }\n        if (m.id == GROUND) {\n            vec2 uv2 = abs(mod(p.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n            uv2 /= fwidth(p.xz);\n            float gln = min(uv2.x, uv2.y) / GRID_SIZE;       \n            col = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n        }\n        else if (m.id == BACKDROP) {\n            float th = 1.5+p.y*0.09;\n            col =  mix(mix(mix(vec3(1.0,.3,0.),vec3(.9,0.,0.),th),vec3(1.,0.,.4),th-1.3),vec3(0.,0.,0.4),th-1.8);\n        }\n        else if (m.id == TEXT) {\n            col = vec3(1.0,.8,0.);\n        }\n        \n        \n    }\n    col += glow;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}