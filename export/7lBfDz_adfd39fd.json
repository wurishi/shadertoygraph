{"ver":"0.1","info":{"id":"7lBfDz","date":"1652026757","viewed":156,"name":"Terrain and river generation","username":"movax20h","description":"Just some fun.\n\nEdit, 2023-11-18 - Added some debug options. Check source before main.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["terrain","perlin"],"hasliked":0,"parentid":"MdScDc","parentname":"Understanding Perlin Noise 2D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//http://flafla2.github.io/2014/08/09/perlinnoise.html\n//https://web.archive.org/web/20160530124230\n//http://freespace.virgin.net/hugo.elias/models/m_perlin.htm\n//http://eastfarthing.com/blog/2015-04-21-noise/\n//https://www.youtube.com/watch?v=Or19ilef4wE\n//https://www.youtube.com/watch?v=MJ3bvCkHJtE\n//https://www.shadertoy.com/view/MdScDc - Understaning Perlin Noise 2D by fscur\n//https://www.youtube.com/watch?v=CSa5O6knuwI - Minecraft terrain generation in a nutshell\n\n\n// hash from iq\n// https://www.shadertoy.com/view/Xs23D3\nvec2 hash(vec2 p) {  \t\t\t\t\t\t\n\tp = vec2(dot(p, vec2(127.1, 311.7)),\n\t\t\t dot(p, vec2(269.5, 183.3)));\n    \n\treturn -1.0 + 2.0 * fract(sin(p + 20.0) * 53758.5453123);\n}\n\nfloat lerp(float a, float b, float t) {\n  return a + t * (b - a);\n}\n\nfloat perlin_noise_2(in vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  // grid points\n  vec2 p0 = vec2(0.0, 0.0);\n  vec2 p1 = vec2(1.0, 0.0);\n  vec2 p2 = vec2(0.0, 1.0);\n  vec2 p3 = vec2(1.0, 1.0);\n\n  // distance vectors to each grid point\n  vec2 s0 = f - p0;\n  vec2 s1 = f - p1;\n  vec2 s2 = f - p2;\n  vec2 s3 = f - p3;\n\n  // random gradient vectors on each grid point\n  vec2 g0 = hash(i + p0);\n  vec2 g1 = hash(i + p1);\n  vec2 g2 = hash(i + p2);\n  vec2 g3 = hash(i + p3);\n\n  // gradient values\n  float q0 = dot(s0, g0);\n  float q1 = dot(s1, g1);\n  float q2 = dot(s2, g2);\n  float q3 = dot(s3, g3);\n\n  // interpolant weights\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  // bilinear interpolation\n  float l0 = lerp(q0, q1, u.x);\n  float l1 = lerp(q2, q3, u.x);\n  float l2 = lerp(l0, l1, u.y);\n    \n  return l2;\n}\n\nfloat perlin_fbm(vec2 uv, float persistence, int octaves)  {\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        total += perlin_noise_2(uv * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return total / maxValue;\n}\n\n// Optimally we would make each of the noises be independent (i.e. by varying a seed),\n// but we use same perlin_fbm, and just make it look sufficiently independent,\n// by adding some offsets here and there.\n//\n// We offset output of perlin_fbm by +0.5, so results are positive (I think).\n\n\nfloat main_height(vec2 uv) {\n    return 0.5 + perlin_fbm(0.1 * uv, 0.3, 8);\n}\n\nfloat continentalness(vec2 uv) {\n    return 0.5 + perlin_fbm(0.1 * uv + vec2(314.123, 1231.0), 0.6, 8);\n}\n\nfloat erossion(vec2 uv) {\n    return 0.5 + perlin_fbm(0.1 * uv + vec2(100.0, 100.0), 0.6, 9);\n}\n\nfloat riverness(vec2 uv) {\n    return 0.5 + perlin_fbm(0.1 * uv + vec2(-100.0, 200.0), 0.4, 3);\n}\n\nfloat river(vec2 uv) {\n    return 0.5 + perlin_fbm(0.5 * uv + vec2(-300.0, 200.0), 0.6, 4);\n}\n\nfloat humidity(vec2 uv) {\n    return 0.5 + perlin_fbm(0.02 * uv + vec2(420.0, 200.0), 0.6, 7);\n}\n\nfloat sea_base = 0.18;\n\nfloat sea_color = 0.4;  // shade of blue\n\n\nvec3 render(vec2 uv) {\n  float h0 = main_height(uv);\n  float c = continentalness(uv);\n  float e = erossion(uv);\n  float r = riverness(uv);\n  // river (when close to middle)\n  float r2 = river(uv);\n\n  // temperature\n  // humidity, verying very slowly\n  float hum = humidity(uv);\n\n  // weirdness\n\n  float h = e * c;\n  // float h = h0;\n\n\n  if (h < sea_base) {\n    if (h < sea_base - 0.02) {\n      // deep water\n      return vec3(0.0, 0.0, sea_color);\n    } else {\n      // sea close to shore\n      return vec3(0.0, 0.08, sea_color);\n    }\n  } else {\n    // 0 - fully connected rivers\n    // 0.45 some dead ends (more open land area with no rivers)\n    // 1.0 - no rivers\n    float close_to_sea = (h - sea_base)/(1.0 - sea_base);  // 0 at sea, 1 at max\n    float close_to_sea2 = 1.0 - pow(1.0 - close_to_sea, 32.0);\n    // When close to sea, makes river more likely, thus likely to be wider.\n    if (r >= 0.48) {\n      // close_to_sea2 can get very close to 1.0, which will make super thin rivers\n      // mutliply by 0.99 to set minimum river width\n      if (0.5 * 0.99 * close_to_sea2 <= r2 && r2 <= 1.0 - 0.99 * close_to_sea2 * 0.5) {\n      // if (0.49 <= r2 && r2 <= 0.51) {\n        // Vary color of rivers a bit related to height / closness to sea\n        return vec3(0.0, close_to_sea * 0.8, sea_color + (1.0 - sea_color) * close_to_sea);\n      }\n    } else {\n      // land\n    }\n  }\n\n  // Color land more grean in humid areas\n  return vec3(h * (1.0 - hum), h * hum, h * (1.0 - hum));\n}\n\n// Perform gamma correction (poor-mans sRGB).\nvec4 degamma(vec3 col) {\n    if (col.x < 0.0 || col.y < 0.0 || col.z < 0.0) {\n      // Debug pink for negative channel values\n      return vec4(255.0 / 255.0, 192.0 / 255.0, 203.0 / 255.0, 0.0);\n    }\n    return vec4(pow(col, vec3(0.424242)), 0.0);\n}\n\n// Without gamma correction\nvec4 degamma0(vec3 col) {\n    if (col.x < 0.0 || col.y < 0.0 || col.z < 0.0) {\n      // Debug pink for negative channel values\n      return vec4(255.0 / 255.0, 192.0 / 255.0, 203.0 / 255.0, 0.0);\n    }\n    return vec4(col.xyz, 0.0);\n}\n\nvec4 degamma2(vec3 col) {\n    if (col.x < 0.0 || col.y < 0.0 || col.z < 0.0) {\n      // Debug pink for negative channel values\n      return vec4(255.0 / 255.0, 192.0 / 255.0, 203.0 / 255.0, 0.0);\n    }\n    return vec4(pow(col, vec3(2)), 0.0);\n}\n\n#define NOISE_DEBUG false\n// #define NOISE_DEBUG true\n\n// Transform from screen to out space\nvec2 transformView1(vec2 uv) {\n  float width = 1.0;\n  return ((uv.xy * 2.0 - iResolution.xy) / iResolution.y) * width * 0.5;\n}\n\n#define SCALE_FACTOR 15.0\n// #define SCALE_FACTOR 30.0\n\n// #define MOVE_SPEED 0.0\n#define MOVE_SPEED 2.0\n\n// Scale and animate (side scroll)\nvec2 transformView2(vec2 uv) {\n  return SCALE_FACTOR * uv  + vec2(iTime * MOVE_SPEED, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (NOISE_DEBUG) {\n    // Debug output with all noise channels separated\n    // Super horrible code\n\n    if (3.0 * fragCoord.x < iResolution.x) {\n      if (3.0 * fragCoord.y < iResolution.y) {\n        // bottom-left - main height\n        // fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(3.0/3.0, 1.0/3.0));\n        uv = transformView2(uv);\n        float c = main_height(uv);\n        fragColor = degamma2(vec3(c, 0.0, 0.0));\n        // Main height is not super interesting on itself, it varies slowly,\n        // it is more interesting when combined with erossion probably.\n\n        if (false) {\n          float c = continentalness(uv);\n          float e = erossion(uv);\n\n          float h = e * c;\n\n          fragColor = degamma0(vec3(h, 0.0, 0.0));\n        }\n      } else if (3.0 * fragCoord.y < 2.0*iResolution.y) {\n        // center-left - continentalness\n        // fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(3.0/3.0, 2.0/3.0));\n        uv = transformView2(uv);\n        float c = continentalness(uv);\n        fragColor = degamma0(vec3(0.0, c, 0.0));\n      } else {\n        // top-left - erossion\n        // fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(3.0/3.0, 3.0/3.0));\n        uv = transformView2(uv);\n        float c = erossion(uv);\n        fragColor = degamma(vec3(0.0, 0.0, c));\n      }\n      return;\n    } else if (3.0 * fragCoord.x < 2.0 * iResolution.x) {\n      if (3.0 * fragCoord.y < iResolution.y) {\n        // bottom-center - riverness\n        // fragColor = vec4(1.0, 1.0, 0.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(2.0/3.0, 1.0/3.0));\n        uv = transformView2(uv);\n        float c = riverness(uv);\n        fragColor = degamma0(vec3(c, c, 0.0));\n      } else if (3.0 * fragCoord.y < 2.0*iResolution.y) {\n        // center-center - river\n        // fragColor = vec4(0.0, 1.0, 1.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(2.0/3.0, 2.0/3.0));\n        uv = transformView2(uv);\n        float c = river(uv);\n        fragColor = degamma0(vec3(0.0, c, c));\n      } else {\n        // top-center - humidity\n        // fragColor = vec4(1.0, 0.0, 1.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(2.0/3.0, 3.0/3.0));\n        uv = transformView2(uv);\n        float c = humidity(uv);\n        fragColor = degamma0(vec3(c, 0.0, c));\n      }\n      return;\n    } else {\n      if (3.0 * fragCoord.y < iResolution.y) {\n        // bottom-center - sea (deep water and sea close to shore)\n        // fragColor = vec4(1.0, 1.0, 1.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(3.0/3.0, 1.0/3.0));\n        uv = transformView2(uv);\n\n        // This a bit messy, but show various sub-branches truness\n        float c = continentalness(uv);\n        float e = erossion(uv);\n\n        float h = e * c;\n        if (h < sea_base) {\n          if (h < sea_base - 0.02) {\n            // deep water\n            fragColor = degamma(vec3(0.0, 0.0, sea_color));\n          } else {\n            // sea close to shore\n            fragColor = degamma(vec3(0.0, 0.08, sea_color));\n          }\n         } else {\n           fragColor = vec4(0.0, 0.0, 0.0, 0.0);  // black\n         }\n      } else if (3.0 * fragCoord.y < 2.0*iResolution.y) {\n        // center-center - rivers vs land\n        // fragColor = vec4(0.0, 0.5, 1.0, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(3.0/3.0, 2.0/3.0));\n        uv = transformView2(uv);\n\n        // This a bit messy, but show various sub-branches truness\n        float c = continentalness(uv);\n        float e = erossion(uv);\n\n        float r = riverness(uv);\n        float r2 = river(uv);\n\n        float h = e * c;\n        if (h < sea_base) {  // sea\n           fragColor = vec4(0.0, 0.0, 0.0, 0.0);  // black\n        } else {\n          // 0 - fully connected rivers\n          // 0.45 some dead ends (more open land area with no rivers)\n          // 1.0 - no rivers\n          float close_to_sea = (h - sea_base)/(1.0 - sea_base);  // 0 at sea, 1 at max\n          float close_to_sea2 = 1.0 - pow(1.0 - close_to_sea, 32.0);\n\n          if (r >= 0.48) {\n            fragColor = vec4(1.0, 1.0, 1.0, 0.0);\n            // close_to_sea2 can get very close to 1.0, which will make super thin rivers\n            // mutliply by 0.99 to set minimum river width\n            if (0.5 * 0.99 * close_to_sea2 <= r2 && r2 <= 1.0 - 0.99 * close_to_sea2 * 0.5) {\n            // if (0.49 <= r2 && r2 <= 0.51) {\n              // Vary color of rivers a bit related to height / closness to sea\n              // fragColor = degamma(vec3(0.0, close_to_sea * 0.8, sea_color + (1.0 - sea_color) * close_to_sea));\n              fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n            } else {\n              fragColor = vec4(0.0, 0.65, 0.0, 0.0);  // maybe land\n            }\n          } else {\n            fragColor = vec4(0.0, 0.9, 0.0, 0.0);  // definitively land\n          }\n        }\n      } else {\n        // top-center - final composite\n        fragColor = vec4(1.0, 1.0, 0.5, 0.0);\n        vec2 uv = transformView1(fragCoord - iResolution.xy * vec2(3.0/3.0, 3.0/3.0));\n        uv = transformView2(uv);\n\n        fragColor = degamma0(render(uv));\n        // fragColor = degamma(render(uv));\n      }\n      return;\n    }\n  } else {\n    vec2 uv = transformView1(fragCoord);\n    uv = transformView2(uv);\n\n    fragColor = degamma0(render(uv));\n  }\n}\n\n\n","name":"Image","description":"","type":"image"}]}