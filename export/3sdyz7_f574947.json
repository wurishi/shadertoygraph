{"ver":"0.1","info":{"id":"3sdyz7","date":"1600764506","viewed":391,"name":"cumulus cloud","username":"bluebean","description":"cumulus cloud","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tmax = 20.0;\n#define SHQ\n//#define MEDQ\n//#define YUCKQ\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//iq's LUT 3D noise\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\n    f = f*f*(3.0-2.0*f);\n     \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\nfloat Turbulence(vec3 p)\n{\t\n\tfloat t = 0.;\n\tfloat oof = 1.;\n\tfor (int i=0; i<7; i++)\n\t{\n\t\tt += abs(noise(p))*oof;\n\t\toof *= 0.5;\n\t\tp *= 2.7;\t//bigger number, more detail\n\t}\n\t\n\treturn t-1.;\n}\n\nvec2 cloudShape2(vec3 p)\n{\n    float anim = .0;// 0.033*iTime + 0.5*3.1415926;\n    float scale1 = 1.0 - pow(abs(sin(anim)),8.0);\n    float scale = scale1*1.75;\n    vec2 res = vec2(999.0,0.0);\n    res = opU(res, vec2(sdEllipsoid(p-vec3(0.0,0.4,0.0), vec3(3.0,1.5,1.0)*scale), 2.0*scale));\n    res = opU(res, vec2(sdEllipsoid(p-vec3(5.0,-0.4,1.0), vec3(3.0,1.5,1.0)*scale), 2.0*scale));\n    res = opU(res, vec2(sdEllipsoid(p-vec3(2.0,-0.99,2.0), vec3(2.0,1.5,1.0)*scale), 2.0*scale));\n    res = opU(res, vec2(sdEllipsoid(p-vec3(-5.0,-1.99,1.2), vec3(2.0,1.2,1.0)*scale), 2.0*scale));\n    return res;\n}\n\nvec2 cloudShape(vec3 p)\n{\n     float anim = .0;// 0.033*iTime + 0.5*3.1415926;\n    float scale1 = 1.0 - pow(abs(sin(anim)),8.0);\n    float scale = scale1*0.9;\n    vec2 res = vec2(999.0,0.0);\n    res = opU(res, vec2(sdEllipsoid(p-vec3(0.0,0.4,0.0), vec3(3.0,1.5,1.0)*scale), 2.0*scale));\n    res = opU(res, vec2(sdEllipsoid(p-vec3(5.0,-0.4,1.0), vec3(3.0,1.5,1.0)*scale), 2.0*scale));\n    res = opU(res, vec2(sdEllipsoid(p-vec3(2.0,-0.99,2.0), vec3(2.0,1.5,1.0)*scale), 2.0*scale));\n    res = opU(res, vec2(sdEllipsoid(p-vec3(-5.0,-1.99,1.2), vec3(2.0,1.2,1.0)*scale), 2.0*scale));\n    return res;\n}\n\nfloat cloudShapeDensity(in vec3 p)\n{\n    vec2 res = cloudShape(p);\n    float d = res.x;\n    float size = res.y;\n    float mdens = 1. - smoothstep(-size*0.01, size*0.01, d);\n    mdens = clamp(mdens,0.0,1.0);\n    return mdens;\n}\n    \n\n// maps 3d position to colour and density\nvec4 map( in vec3 p)\n{\n    //start of params\n    float denStrength = 7.3;\n    float anim = 0.067;\n    float riseS = 0.5;\n    //end of params\n    float move = anim*iTime;\n    float noi = noise(p);\n    float c = cos(move*0.0001);\n    float s = sin(move*0.0001);\n    float pathX = s*0.005*iTime;\n    float pathZ = s*0.0035*iTime;\n    float rise = move*riseS;\n    vec3 p1 = p;\n    p1.x += move + noi*0.01 + pathX;\n    p1.z += move + noi*0.01 + pathZ;\n    p1.y -= rise + noi*0.1;\n    float turb1 = Turbulence(p1);\n    float den = 0.0;\n    float turbAmount1 = turb1*1.75;\n    vec3 p2 = p;\n    p2.x += turbAmount1; p2.y += turbAmount1; p2.z += turbAmount1;\n    vec2 d = cloudShape(p2);\n    float shape = cloudShapeDensity(p2);\n    \n    float r = -d.x;\n    float R = d.y;\n    float r2 = r*r;float R2 = R*R;\n    float r4 = r2*r2;float R4 = R2*R2;\n    float r6 = r4*r2;float R6 = R4*R2; \n    float bden = -4.0/9.0*r6/R6 + 17.0/9.0*r4/R4 -22.0/9.0*r2/R2 + 1.0;\n   \n    den = shape*bden*denStrength;\t\n    \n    den = clamp(den,0.0,1.0);\n    den = pow(den,0.5);\n    //make color\n    vec3 color = mix(vec3(.99,0.99,0.99), vec3(0.72,0.72,0.72), den);\n\treturn vec4(color,den);\n}\n\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\n{\n    vec3 pos = rayo;\n    float t = 0.0;\n\t\n\tfor(int i = 0; i < 15 && t < tmax; i++)\n    {\n        vec2 h = cloudShape2(pos);\n        if( h.x < 0.0001*t)\n        { \n            //float noi = noise(pos);\n            //pos += rayd*t*0.0001;\n            break;\n        }\n        t += h.x;\n        pos = rayo + rayd * t;\n    }\n   \n    vec4 sum = vec4( 0.0 );\n    \n    #ifdef SHQ\n\t#define STEPS  128\n    float dt = 0.062;\n    #endif\t\n    #ifdef MEDQ\n\t#define STEPS\t64\n    float dt = 0.124;\n    #endif\t\n    #ifdef YUCKQ\t\n\t#define STEPS\t32\n    float dt = 0.248;\n    #endif\n\t\n    float last_t = t;\n    for( int i = 0; i < STEPS && t < tmax; i++ )\n    {\n        if( sum.a > 0.99 ) continue;\n\t\t\t\t\n\t\tfloat dens;\n\t\t\n        vec4 col = map(pos);\n        \n\t\tcol.a *= (t-last_t)*1.5;\n\t\t// colour by alpha\n\t\tcol.rgb *= col.a;\n\t\t\n\t\t// alpha blend in contribution\n\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t\n\t\t// step along ray\n        last_t = t;\n\t\tt += dt;\n\t\tpos = rayo + rayd * t;\n    }\n\tvec4 sky = vec4(vec3(141.0/255.0,200.0/255.0,242.0/255.0),1.0); \n    sky.a *= 0.6;\n    sky.rgb *= sky.a;\t\n\tsum = sum + sky*(1.0 - sum.a);  \n        \n    return clamp( sum, 0.0, 1.0 );\n}\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\t\n    float camRadius = 7.8;\n\tfloat rota = 0.0;\n    float dist = 1.0;\n    if( iMouse.z > 0. )\n    {\n\t\trota = iMouse.x/iResolution.x;\n        dist = iMouse.y/iResolution.y;\n    }\n\tfloat theta = rota*3.1415726*2.0 - 3.1415726*0.5;\n    camRadius *= dist;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,.0,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.0,0.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    \n\tvec3 rayDir, cameraPos;\n    rayDir = computePixelRay( p, cameraPos );\n\t\n\tvec4 col = vec4(0.);\n\tcol = raymarch( cameraPos, rayDir);\n    // smoothstep final color to add contrast\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\n}\n","name":"Image","description":"","type":"image"}]}