{"ver":"0.1","info":{"id":"DttGDM","date":"1682873396","viewed":94,"name":"Basic Snake","username":"benito_luna","description":"Quick and dirty snake implementation. All the code can be cleaned and optimized (no need to use 2 buffers for gameplay). Use arrows for control. ","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\n///////////////////////\nvec4 loadDebug(in vec2 fragCoordRead)\n{\n    return texture(iChannel1, (0.5 + fragCoordRead) / iChannelResolution[0].xy, 0.0 );\n}\n//////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)    \n    vec4 raw  =  load(fragCoord);        \n        \n    fragColor = vec4(BackgroundColor, 1.0);           \n    if (raw.x > 0.0) //snake\n    {        \n        if (raw.x < 0.3)\n        {\n            fragColor = mix(vec4(BodyColor, 1.0), vec4(BodyColor2, 1.0), 0.5 + 0.5 * sin(0.1 * ( fragCoord.x + fragCoord.y)));\n        }\n        else\n        {\n            fragColor = mix(vec4(BorderColor, 1.0), vec4(BorderColor2, 1.0), 0.5 + 0.5 * sin(0.1 * ( fragCoord.x + fragCoord.y)));\n        }\n        \n    }   \n    else if (raw.y > 0.0) //food\n    {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);        \n    }          \n    \n    vec4 UI = texture(iChannel2, fragCoord / iResolution.xy, 0.0);\n    fragColor.rgb = mix(fragColor.rgb, UI.rgb, UI.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 load0(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, 0.0 );\n}\n\nvec4 load2(in vec2 fragCoordRead)\n{\n    return texture(iChannel2, (0.5 + fragCoordRead) / iChannelResolution[2].xy, 0.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); \n}\n\nvoid store( in vec2 fragCoordWrite, in vec4 value, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (isInside(fragCoord, fragCoordWrite) > 0.0) ? value : fragColor;\n}\n\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.5) ).x;\n}\n\nvec2 GenerateFood()\n{\n    return texture(iChannel3, vec2(0.5 + 0.5 * cos(iTime), 0.5 + 0.5 * sin(iTime)), 0.0).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 HeadData = vec4(0.5,0.5, 0.0, 0.0);    \n    vec4 TailData = vec4(0.5, 0.5, 0.5, 0.0);\n    vec4 EraseData = vec4(0.0, 0.0, 0.0, 0.0); //fix me always erasing 0,0, needs to add a border\n    vec4 FoodData = vec4(0.4,0.6,1.0,1.0); //food data, and food data to erase\n    vec4 ScoreData = vec4(0.5/ScoreScale, 0.5/ScoreScale, 0.0, 0.0);\n    \n    #if 0\n    //update reset state\n    if (isKeyPressed(KEY_R) > 0.0)\n    {\n        TailData.w = 1.0;\n    }\n    #endif\n    \n    vec4 ScoreDataTmp;\n    if (iFrame > 0)\n    {\n        ScoreDataTmp = load0(ScoreAddress); \n    }\n    ScoreData.y = ScoreDataTmp.y;\n    \n    if (TailData.w == 0.0 && iFrame > 0)\n    {   \n        //persistent data\n        TailData = load0(TailAddress);                \n        HeadData = load0(HeadAddress);                  \n        FoodData = load0(FoodAddress); \n        ScoreData = ScoreDataTmp;\n        \n        FoodData.zw = vec2(1.0,1.0); //non persistent\n        //update tail\n        TailData.w = 0.f; //reset the reset :)\n        #if 0\n        if (isKeyPressed(KEY_E) > 0.0)\n        {\n            TailData.z = 1.0;//mix(1.0, 0.0, TailData.z);\n        }    \n        #endif\n        vec2 offset = vec2(0.f, 0.f);\n        \n        //check for invalid data\n        if (FoodData.x == 0.0 && FoodData.y == 0.0)\n        {        \n            FoodData.xy = GenerateFood();\n            vec4 newCollision = load2(iResolution.xy * FoodData.xy); //check new collision\n            if (newCollision.x > 0.0f)\n            {\n               FoodData.xy = vec2(0.0, 0.0);\n            }\n        }\n        \n        //update head                \n        HeadData.zw = HeadData.zw * 2.0 - 1.0;\n        if (isKeyPressed(KEY_LEFT) > 0.0 && HeadData.z <= 0.0)\n        {\n            HeadData.zw = vec2(-1.0,0.0);\n        }\n        else if (isKeyPressed(KEY_RIGHT)> 0.0 && HeadData.z >= 0.0)\n        {\n            HeadData.zw = vec2(1.0,0.0);\n        }\n        else if (isKeyPressed(KEY_UP)> 0.0 && HeadData.w >= 0.0)\n        {\n            HeadData.zw = vec2(0.0,1.0);\n        }\n        else if (isKeyPressed(KEY_DOWN)> 0.0 && HeadData.w <= 0.0)\n        {\n            HeadData.zw = vec2(0.0,-1.0);\n        }             \n        else //don't trigger an offset when changing direction cause bugs\n        {\n            offset = HeadData.zw;                      \n            offset = offset / iResolution.xy;          \n        }\n        ivec2 PrevGridPosition = ivec2(iResolution.xy * HeadData.xy / GridSize);\n        \n        HeadData.xy += SnakeSpeed * offset;                \n        \n        ivec2 tmp = ivec2(iResolution.xy * HeadData.xy / GridSize) - PrevGridPosition;             \n        //we moved to another case, update tail and check collision\n        if (tmp.x != 0 || tmp.y != 0)\n        {\n            if (TailData.z == 0.0)\n            {            \n                // erase previous tail position and update tail\n                EraseData.xy = TailData.xy;\n                //now get the moving direction of the tail\n                vec2 tailDirection = 2.0 * load2(iResolution.xy * TailData.xy).zw - 1.0;                                       \n                TailData.xy += tailDirection / iResolution.xy * GridSize;                                \n            }\n            else //consume one growth token\n            {\n                TailData.z = TailData.z - 1.0 / GrowthSize;\n            }\n            \n            //check for collision\n            vec4 collision = load2( GridSize * (vec2(PrevGridPosition) + HeadData.zw) );\n            if (collision.x > 0.0 || HeadData.x < 0.0 || HeadData.x >= 1.0 || HeadData.y < 0.0 || HeadData.y >= 1.0)\n            {   \n                ScoreData.y = max(ScoreData.y, ScoreData.x);\n                TailData.w = 1.0;\n            }\n            else if (collision.y > 0.0) //food!\n            {\n                TailData.z = 1.0;\n                FoodData.zw = FoodData.xy;\n                //psuedo randomness\n                //todo don't generate on collision\n                FoodData.xy = GenerateFood();\n                ScoreData.x += 1.0 / ScoreScale;\n                vec4 newCollision = load2(iResolution.xy * FoodData.xy); //check new collision\n                if (newCollision.x > 0.f)\n                {\n                    FoodData.xy = vec2(0.0, 0.0);\n                }\n            }\n        }\n     }\n     \n     if (TailData.w > 0.0) //clean that\n     {\n        //Collision, reset the game \n        HeadData = vec4(0.5,0.5, 0.0, 0.0);    \n        TailData = vec4(0.5, 0.5, 0.0, 1.0); //tail is initially static   \n        EraseData = vec4(0.0, 0.0, 0.0, 0.0); //fix me always erasing 0,0, needs to add a border\n        FoodData = vec4(0.4,0.6,1.0,1.0);\n        ScoreData.x = 0.0;\n     }\n     \n     TailData.xy = floor(TailData.xy * iResolution.xy / GridSize) + 0.5;\n     TailData.xy = TailData.xy / iResolution.xy * GridSize;\n     TailData.z =  clamp(0.0, 1.0, TailData.z);\n     HeadData.zw = 0.5 * HeadData.zw + vec2(0.5);\n           \n     store(HeadAddress, vec4(HeadData), fragColor, fragCoord);     \n     store(TailAddress, vec4(TailData), fragColor, fragCoord);     \n     store(EraseAddress, vec4(EraseData), fragColor, fragCoord);\n     store(FoodAddress, vec4(FoodData), fragColor, fragCoord);\n     store(ScoreAddress, vec4(ScoreData), fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec3 BodyColor = vec3(0.0, 0.5, 1.0);\nconst vec3 BodyColor2 = vec3(0.0, 0.7, 1.0);\nconst vec3 BorderColor = vec3(1.0, 0.4, 0.0);\nconst vec3 BorderColor2 = vec3(1.0, 0.5, 0.0);\nconst vec3 FoodColor = vec3(0.0, 1.0, 0.0);\nconst vec3 BackgroundColor = vec3(0.3, 0.3, 0.3);\n\n//data address\nconst vec2 HeadAddress = vec2(0.0,0.0); //Head + direction\nconst vec2 TailAddress = vec2(1.0,0.0); //tail + moving + reset\nconst vec2 EraseAddress = vec2(2.0,0.0); //tail moving \nconst vec2 FoodAddress = vec2(3.0,0.0); \nconst vec2 ScoreAddress = vec2(4.0, 0.0);\n\nconst float GridSize = 8.0;\nconst float GrowthSize = 32.0;\nconst float SnakeSpeed = 2.0;\nconst float Border = 0.9;\nconst float Body = 0.1;\nconst float ScoreScale = 256.0; //8 bit per buffer channel?\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Render the snake\n\nvec4 loadSnakeState(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, 0.0 );\n}\n\nvec4 loadSnakePreviousFrame(in vec2 fragCoordRead)\n{\n    return texture(iChannel1, (0.5 + fragCoordRead) / iChannelResolution[0].xy, 0.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)    \n    vec4 HeadData = loadSnakeState(HeadAddress);\n    vec4 TailData = loadSnakeState(TailAddress);\n    vec4 FoodData = loadSnakeState(FoodAddress);\n    \n    vec2 HeadPosition = HeadData.xy * iResolution.xy;    \n    vec3 res = vec3(0.0, 0.0, 0.0);               \n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (TailData.w == 0.0)\n    {    \n        // reuse last frame\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }                  \n                     \n    ivec2 tmp = ivec2(fragCoord/GridSize) - ivec2(HeadPosition/GridSize);         \n    // renderhead\n    if (tmp.x == 0 && tmp.y == 0)    \n    {\n        // Output to screen        \n        fragColor = vec4(Body, 0.0, HeadData.zw);                                            \n    }   \n    \n    vec4 toErase = loadSnakeState(EraseAddress);\n    tmp = ivec2(fragCoord/GridSize) - ivec2(toErase.xy * iResolution.xy / GridSize);         \n    if (tmp.x == 0 && tmp.y == 0)    \n    {\n        fragColor.xy = vec2(0.0, 0.0);\n    }    \n    \n    //render food\n    vec2 FoodPosition = FoodData.xy * iResolution.xy;\n    tmp = ivec2(fragCoord/GridSize) - ivec2(FoodPosition/GridSize);       \n    if (tmp.x == 0 && tmp.y == 0)    \n    {\n        // Output to screen        \n        fragColor = vec4(0.0, 1.0, 0.5, 0.5);                                            \n    }   \n           \n    tmp = ivec2(fragCoord/GridSize) - ivec2(FoodData.zw * iResolution.xy / GridSize);         \n    if (tmp.x == 0 && tmp.y == 0)    \n    {\n        fragColor.xy = vec2(1.0, 0.0); //food to snake\n    }\n    \n    //borders\n    vec2 toBorder = iResolution.xy -fragCoord;\n    float border = min(min(toBorder.x, toBorder.y), min(fragCoord.x, fragCoord.y));\n    if (border < GridSize)\n    {\n        fragColor.xy = vec2(Border, 0.0); //border =collision\n    }\n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n\n// NO MINIFIED VERSION : https://www.shadertoy.com/view/XsySzG\n#define MAX_DIGIT 3\n#define FLOAT_PRECISION 0\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.3,1.,.3)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\nvec4 load0(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, 0.0 );\n}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //_box(vec2(10,10),vec2(148,iResolution.y-20.),vec4(0.,0.,0.,.25))\n      \n    vec2 ScoreData = load0(ScoreAddress).xy; \n    float t = mod(iTime,10.);   \n    _cursor(15,30) _S _C _O _R _E \n    _cursor(60,30) _float(floor(ScoreScale * ScoreData.x))\n    _cursor(15,45) _B _E _S _T \n    _cursor(60,45) _float(floor(ScoreScale * ScoreData.y))\n    \n      \n      \n    //_slider(20,50, 0, .75) _R _o _u _g _h _n _e _s _s\n    //_slider(20,80, 1, 0.) _M _e _t _a _l _l _i _c\n    //_color (20,110, 0, vec3(1.,.7,.0)) _M _a _t _e _r _i _a _l _spc  _c _o _l _o _r\n    \n    fragColor =  min(col.rgba,1.);\n}\n\n\n\n\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}