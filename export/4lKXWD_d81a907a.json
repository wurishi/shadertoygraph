{"ver":"0.1","info":{"id":"4lKXWD","date":"1484422341","viewed":1663,"name":"Animated selection rectangle","username":"nsf","description":"Just a simple way to display a selection rectangle (animated dashed outline). It uses fwidth and hence will also work in 3d.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["2d","effect","animation","rectangle","outline","selection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // rect boundaries\n    vec2 rectMin = vec2(0.4, 0.2);\n    vec2 rectMax = vec2(0.8, 0.8);\n    \n    // some people prefer \"min + (max - min) / 2\", but for floating point UV space it\n    // doesn't matter\n    vec2 center = (rectMin + rectMax) / 2.0;\n    vec2 halfSize = center - rectMin;\n    vec2 fw = fwidth(uv);\n    \n    vec2 dist = abs(uv - center);\n    \n    float col = 0.0;\n    if (all(lessThan(dist, halfSize)) && any(greaterThan(dist, halfSize - fw))) {\n        // for pixel here I could use fragCoord.xy, but on textures you don't have it\n        // using fwidth is a tricky way to operate in screenspace sizes on all surfaces\n        // of course it's an approximation, but it's a pretty good one, here, uncomment this \n        // line to try fragCoord, it gives almost the same result:\n        //vec2 pixel = fragCoord.xy;\n        vec2 pixel = uv / fw;\n        float aspect = halfSize.y / halfSize.x;\n        float dir = (dist.x * aspect > dist.y) ?\n              -sign(uv.x - center.x) : sign(uv.y - center.y);\n        float dash = step(0.5, fract((pixel.x + pixel.y) * dir / 10.0 + iTime));\n        col = mix(1.0, 0.0, dash);\n    }\n    \n\tfragColor = vec4(col, col, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}