{"ver":"0.1","info":{"id":"MlVcDh","date":"1536109931","viewed":226,"name":"Curved Space Raytracing","username":"RolandRock","description":"[WIP]\nLighting seems to work\nRaytracing within a 3-sphere (i.e. surface of a 4D sphere)\nMove camera w/ mouse. Tan background is actually you - the rays loop around.\n\nCurrent scene: 7 balls, 1 reflective, + large sphere. Camera moving along geodesic.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////// IMPORTANT CONSTANTS ///////////////////////////\n\n//Note: the containing 3-sphere always has a radius of 1\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = 2. * PI;\nbool debug_overrideColor = false;\n\nconst float MIN_RAY_HIT_THRESHOLD = 0.001;\n\n\n//////////////////////////// RAYTRACER PARAMS ////////////////////////////\n\nfloat zoom = 500.0;\nconst int AA_AMOUNT = 2;\nconst int REFLECTION_COUNT = 4;\nconst float REFLECTANCE = 0.6;\n\nconst vec3 BACKGROUND_COLOR = vec3(0);\nconst bool USER_SPHERE_VISIBLE = true;\n\n\n///////////////////////////// UTILITY METHODS ////////////////////////////\n\n//will rotate the positive x-axis towards the positive y-axis\nmat4 RotXYPlane(float angle)\n{\n    return mat4(cos(angle), -sin(angle), 0, 0,\n                sin(angle),  cos(angle), 0, 0,\n                         0,           0, 1, 0,\n                         0,           0, 0, 1);\n}\n//will rotate the positive x-axis towards the positive z-axis\nmat4 RotXZPlane(float angle)\n{\n     return mat4(cos(angle), 0, -sin(angle), 0,\n                          0, 1,           0, 0,\n                 sin(angle), 0,  cos(angle), 0,\n                 0,          0,           0, 1);\n}\n//will rotate the positive y-axis towards the positive z-axis\nmat4 RotYZPlane(float angle)\n{\n     return mat4(1, 0,          0,           0,\n                 0, cos(angle), -sin(angle), 0,\n                 0, sin(angle),  cos(angle), 0,\n                 0, 0,          0,           1);\n}\n//will rotate the positive x-axis towards the positive w-axis\nmat4 RotXWPlane(float angle)\n{\n     return mat4(cos(angle), 0, 0, -sin(angle),\n                          0, 1, 0,           0,\n                          0, 0, 1,           0,\n                 sin(angle), 0, 0,  cos(angle));\n}\n//will rotate the positive y-axis towards the positive w-axis\nmat4 RotYWPlane(float angle)\n{\n     return mat4(1,          0,           0,           0,\n                 0, cos(angle),           0, -sin(angle),\n                 0,          0,           1,           0,\n                 0, sin(angle),           0,  cos(angle));\n}\n//will rotate the positive z-axis towards the positive w-axis\nmat4 RotZWPlane(float angle)\n{\n     return mat4(1, 0,           0,          0,\n                 0, 1,           0,          0,\n                 0, 0,  cos(angle),  -sin(angle),\n                 0, 0,  sin(angle),  cos(angle));\n}\n\nfloat GeodesicDistance(vec4 p1, vec4 p2)\n{\n    float dotProd = dot(normalize(p1), normalize(p2));\n    \n    //clamp in case of float imprecision\n    return acos(clamp(dotProd, -1.0, 1.0));\n}\n\nfloat AngleFromGeodesicDistance(float dist)\n{\n    return dist;\n}\n\nvec4 Reflect(vec4 normal, vec4 dir)\n{\n    vec4 n = normalize(normal);\n    return dir - (2.*dot(dir, n))*n;\n}\n\nvec4 Project(vec4 toBeProjected, vec4 onto)\n{\n    vec4 normOnto = normalize(onto);\n    return dot(toBeProjected, normOnto) * normOnto;\n}\n\nbool PointsAreEqualOrOpposite(vec4 pt1, vec4 pt2)\n{\n    return abs(dot(pt1, pt2)) == 1.0;\n}\n\n\n/////////////////////////////////// RAY ///////////////////////////////////\n\nstruct Ray\n{\n    vec4 origin;\n    \n    //For the purpose of this raytracer, the \"direction\" vector is the point in space that this\n    //ray will reach at t=pi/2.\n    \n    //So the equation of this ray would be cos(t) * origin + sin(t) * direction\n    vec4 direction;\n};\n\nvec4 PointAlongRay(Ray ray, float t)\n{\n    return normalize((cos(t) * ray.origin) + (sin(t) * ray.direction));\n}\n\nvec4 DirectionAtPointAlongRay(Ray ray, float t)\n{\n    return normalize((cos(t) * ray.direction) + (sin(t) * -ray.origin));\n}\n\nRay RayFromAToB(vec4 from, vec4 to)\n{    \n    return Ray(from, normalize(to - Project(to, from)));\n}\n\n/////////////////////////////////// HIT ///////////////////////////////////\n\nstruct Hit\n{\n    bool isHit;\n    float dist;\n    vec4 normal;\n    vec3 color;\n    \n    bool hasReflection;\n    Ray reflectedRay;\n};\nHit NO_HIT = Hit(false, -1., vec4(0.0), vec3(1.0, 0., 1.0), false, Ray(vec4(0), vec4(0)));\nHit HitWithoutReflection(bool isHit, float dist, vec4 normal, vec3 color)\n{\n    return Hit(isHit, dist, normal, color, false, Ray(vec4(0), vec4(0)));\n}\n    \n\n////////////////////////////////// SPHERE /////////////////////////////////\n\nstruct Sphere\n{\n    vec4 center;\n    float radius;\n    vec3 color;\n    \n    bool hasCheckerboardPattern;\n    bool isReflective;\n    bool visibleFromInside;\n};\n   \nHit SphereHit(Sphere sphere, Ray ray)\n{\n    //A circle on the surface of a 3D sphere can be defined as the intersection\n    //of a plane and a sphere (and conversely, the intersection of a plane and a\n    //sphere will always generate a circle on the surface of the sphere)\n    //\n    //Similarly, intersecting a 3-dimensional \"hyperplane\" with a 4D sphere gets you\n    //a sphere within the surface of the 4D sphere. We can use this to determine intersection.\n    //Instead of trying to calculate the intersection of the ray and the sphere, we calculate\n    //the intersection of the ray and the hyperplane that would generate the sphere if it \n    //intersected the 4D sphere.\n    \n    float angle = AngleFromGeodesicDistance(sphere.radius);\n    vec4 volumeNormal = sphere.center;\n    vec4 volumeNormalCenter = sphere.center * cos(angle);\n    \n    float A = dot(volumeNormal, ray.direction);\n    float B = dot(volumeNormal, ray.origin);\n    float C = dot(volumeNormal, volumeNormalCenter);\n\n    float phaseShift = atan(B, A);\n    float amplitude = sqrt((A*A)+(B*B));\n\n    float asinInput = C / amplitude;\n    if(abs(asinInput) > 1.)\n    {\n        return NO_HIT;\n    }\n\n    float asinVal = asin(asinInput);\n    float asinAltVal = sign(asinVal) * (PI - abs(asinVal));\n    \n    float t1 = asinVal - phaseShift;\n    float t2 = asinAltVal - phaseShift;\n    \n    while(t1 < 0.)      { t1 += TWO_PI; }\n    while(t1 >= TWO_PI) { t1 -= TWO_PI; }\n    while(t2 < 0.)      { t2 += TWO_PI; }\n    while(t2 >= TWO_PI) { t2 -= TWO_PI; }\n    \n    //When we're inside a sphere, we can see through it.\n    //(this is mainly to allow the user to have a sphere representing them.)\n    bool rayIsComingFromWithinSphere = GeodesicDistance(ray.origin, sphere.center) <= sphere.radius;\n    \n    float t;\n    float nearT = min(t1, t2);\n    float farT = max(t1, t2);\n    if(nearT < MIN_RAY_HIT_THRESHOLD && farT < MIN_RAY_HIT_THRESHOLD)\n    {\n        return NO_HIT;\n    }\n    else if(nearT < MIN_RAY_HIT_THRESHOLD)\n    {\n        t = farT;\n    }\n    else if(farT < MIN_RAY_HIT_THRESHOLD)\n    {\n        if(!sphere.visibleFromInside && rayIsComingFromWithinSphere)\n        {\n            //debug_overrideColor = true;\n            return NO_HIT;\n        }\n        else\n        {\n        \tt = nearT;\n        }\n    }\n    else\n    {\n        if(!sphere.visibleFromInside && rayIsComingFromWithinSphere)\n        {\n            //debug_overrideColor = true;\n            t = farT;\n        }\n        else\n        {       \n        \tt = nearT;\n        }\n    }\n    \n    vec3 returnColor = sphere.color;\n    \n    vec4 hitPoint = PointAlongRay(ray, t); \n    \n    //Draw a grid-like texture on the spheres to let you see how you rotate around them\n    if(sphere.hasCheckerboardPattern)\n    {  \n        ivec4 alternating = ivec4(round(mod(vec4(floor(hitPoint / .06)), 2.)));\n        if((alternating.x == 1) ^^ (alternating.y == 1) ^^ (alternating.z == 1) ^^ (alternating.w == 1))\n        {\n            returnColor = vec3(0);\n        }\n    }\n    \n    vec4 rayDirAtHitPoint = DirectionAtPointAlongRay(ray, t);\n    vec4 vecToHitPoint = hitPoint - sphere.center;\n    vec4 normal = normalize(vecToHitPoint - Project(vecToHitPoint, hitPoint));\n    \n    Ray reflectedRay = Ray(vec4(0), vec4(0));\n    if(sphere.isReflective)\n    {\n        //Calculate reflection\n        vec4 reflection = normalize(Reflect(normal, rayDirAtHitPoint));\n        reflectedRay = Ray(hitPoint, reflection);\n    }\n    \n    return Hit(true, t, normal, returnColor, sphere.isReflective, reflectedRay);  \n}\n\n\n////////////////////////////// SCENE OBJECTS //////////////////////////////\n\nconst vec4 lightPos = normalize(vec4(1.,0.,0., 0.25));\nfloat lightIntensity = 0.5;\nfloat ambientLight = 0.1;\n\nconst Sphere lightObject = Sphere(lightPos, 0.05, vec3(1.0, 1.0, 1.0), false, false, false);\n\nSphere[] spheres = Sphere[](\n    //bools are in this order: checkerboard, reflective, visible from inside.\n    \n    Sphere(vec4(0), 0.1, vec3(0.8, 0.5, 0.5), false, false, false) //This spot reserved for the player sphere\n    \n    ,Sphere(normalize(vec4(1., 0., 0., 0.)),  0.1, vec3(1.0, 1.0, 1.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0.5, 0., 0.)), 0.1, vec3(0.0, 0.0, 0.0), false, true, true)\n    ,Sphere(normalize(vec4(1., -0.5, 0., 0.)),  0.1, vec3(1.0, 0.0, 0.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., 0.5, 0.)), 0.1, vec3(1.0, 0.0, 1.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., -0.5, 0.)),  0.1, vec3(0.0, 1.0, 0.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., 0., 0.5)), 0.1, vec3(1.0, 1.0, 0.0), true, false, true)\n    ,Sphere(normalize(vec4(1., 0., 0., -0.5)),  0.1, vec3(0.0, 0.0, 1.0), true, false, true)\n    \n    // The light (at the moment it looks funny because things cast shadows on it)\n    ,lightObject\n    \n    //almost-plane at the bottom\n    ,Sphere(normalize(vec4(0.0, 0.0, 0.0, -1.)),  (PI/2.0) - 0.15, vec3(0.4, 0.2, 0.9), true, false, true)\n);\n\n\n////////////////////////// CORE RENDERING LOGIC ///////////////////////////\n\nHit FindClosestHit(Ray ray, out int hitObjectIndex)\n{\n    Hit nearest = HitWithoutReflection(false, 99999999999999., vec4(0), BACKGROUND_COLOR);\n    hitObjectIndex = -1;\n\n    //Iterate over spheres\n    int startingPoint = USER_SPHERE_VISIBLE ? 0 : 1;\n    for(int i = startingPoint; i < spheres.length(); i++)\n    {            \n        Hit sphereHit = SphereHit(spheres[i], ray);\n        if(sphereHit.isHit && sphereHit.dist < nearest.dist)\n        {\n            nearest = sphereHit;\n            hitObjectIndex = i;\n        }\n    }\n    \n    return nearest;\n}\n\nvec3 RayColor(Ray ray)\n{\n    vec3[REFLECTION_COUNT+1] colors;\n    \n    for(int i = 0; i < colors.length(); i++)\n    {\n        //So we can detect non-reflective surfaces.\n        colors[i] = vec3(-1);\n    }\n    \n    for(int reflections = 0; reflections <= REFLECTION_COUNT; reflections++)\n    {\n        int hitObjectIndex;\n        Hit nearest = FindClosestHit(ray, hitObjectIndex);\n        \n        if(!nearest.isHit)\n        {\n            colors[reflections] = BACKGROUND_COLOR;\n            break;\n        }\n        \n        vec4 hitPos = PointAlongRay(ray, nearest.dist);\n\n        float lightAmnt;\n        if(spheres[hitObjectIndex] == lightObject)\n        {\n            lightAmnt = 1.0;\n        }     \n        else if(PointsAreEqualOrOpposite(hitPos, lightPos))\n        {\n            if(dot(hitPos, lightPos) == 1.0)\n            {\n                lightAmnt = 1.0;\n            }\n            else\n            {\n                //TODO\n            }\n        }\n        else\n        {\n            vec4 lightRayDirAtHitPoint = -normalize(lightPos - Project(lightPos, hitPos));\n            float nearPathDotProduct = dot(-lightRayDirAtHitPoint, nearest.normal);\n\n            Ray lightRayWithPossibilityOfHitting;\n            float hitDotProduct;\n            if(nearPathDotProduct > 0.0)\n            {\n                lightRayWithPossibilityOfHitting = RayFromAToB(lightPos, hitPos);\n                hitDotProduct = nearPathDotProduct;\n            }\n            else if(nearPathDotProduct < 0.0)\n            {\n                Ray closeRay = RayFromAToB(lightPos, hitPos);\n                closeRay.direction = -closeRay.direction;\n                lightRayWithPossibilityOfHitting = closeRay;\n\n                hitDotProduct = -nearPathDotProduct;\n            }\n            else\n            {\n                // angle is exactly 90deg so it's not lit at all\n                lightAmnt = 0.0;\n            }\n\n            int lightHitObjectIndex;\n            Hit firstHit = FindClosestHit(lightRayWithPossibilityOfHitting, lightHitObjectIndex);\n\n            //TODO: this only works for convex objects - if concave objects are added this code will need to be updated \n            if(lightHitObjectIndex == hitObjectIndex)\n            {\n                //Nothing in between!\n\n                //TODO: may want to have sanity check here, compare adjusted geodesic distance to firsthit dist\n                //float dist = GeodesicDistance(lightPos, hitPos);\n                float dist = firstHit.dist;\n                lightAmnt = min(1.0, lightIntensity / (sin(dist) * sin(dist)));\n                lightAmnt *= clamp(hitDotProduct, 0.0, 1.0);\n            }\n            else\n            {\n                lightAmnt = 0.0;\n            }          \n        }\n        \n        //TODO: gamma correction\n\n        lightAmnt = min(1.0, lightAmnt + ambientLight);\n             \n        colors[reflections] = nearest.color * lightAmnt;\n\n        if(nearest.hasReflection)\n        {\n            ray = nearest.reflectedRay;           \n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    \n    vec3 curColor = colors[REFLECTION_COUNT];\n    for(int j = REFLECTION_COUNT - 1; j >= 0; j--)\n    {\n        //TODO: gamma correction & better lighting alg\n        if(curColor == vec3(-1))\n        {\n            curColor = colors[j];\n        }\n        else\n        {\n        \tcurColor = mix(colors[j], curColor, REFLECTANCE);\n        }\n    }\n    \n    return curColor;\n}\n\nvec4 ColorAt(vec2 pixelCoord)\n{\n    //full loop is 8 seconds\n    //(+0.56 is for thumbnail)\n    float a = 0.56 + (iTime / 8.) * TWO_PI;\n    vec2 mousePos = (iMouse.xy - (iResolution.xy/2.))/(iResolution.y/2.);\n    \n    //for thumbnail\n    if(iMouse.xy == vec2(0))\n    {\n        mousePos = vec2(-0.5, 0);\n    }\n    \n    //Generate ray\n    vec2 adjPixel = pixelCoord - iResolution.xy/2.;\n    vec4 baseRayDir = normalize(vec4(adjPixel.x/zoom, 0., 1., adjPixel.y/zoom));\n    \n    mat4 matrixTransform = RotYZPlane(a) * RotXYPlane(-PI / 4.);\n    mat4 mouseTransform = RotZWPlane(mousePos.y * PI / 2.) * RotXZPlane(-mousePos.x * PI / 2.);\n    \n    Ray ray = Ray(\n        normalize(vec4(0.,1.,0.,0.) * matrixTransform), \n        normalize(baseRayDir * mouseTransform * matrixTransform)\n    );\n    \n    if(USER_SPHERE_VISIBLE)\n    {\n    \tspheres[0].center = ray.origin;\n    }\n\n    return vec4(RayColor(ray), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    zoom *= iResolution.x / 1000.;\n    \n    fragColor = vec4(0.0);\n    \n    //antialiasing\n    for(float x = 0.; x < 1.; x += 1. / float(AA_AMOUNT))\n    {\n    \tfor(float y = 0.; y < 1.; y += 1. / float(AA_AMOUNT))\n        {    \n    \t\tfragColor += ColorAt(fragCoord + vec2(x, y));    \n    \t}\n    }\n    fragColor /= float(AA_AMOUNT * AA_AMOUNT);\n    \n    if(debug_overrideColor)\n    {\n        fragColor = vec4(1., 0., 1., 1.);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}