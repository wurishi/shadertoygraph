{"ver":"0.1","info":{"id":"fsyyWt","date":"1655774654","viewed":105,"name":"More Perlin Noisery","username":"daeken","description":"Just playing around with perlin noise.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["playing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ntrue =>shadertoy\n\n{\n    @vec2 uniform =iResolution\n    @float uniform =iTime\n    @vec2 varying =fragCoord\n    \n    :m resolution iResolution ;\n    :m time iTime ;\n    fragCoord resolution .xy / 2 * 1 - [ resolution .xy \\/ 1 ] * =real-position\n    \n    :m ->fragColor =fragColor ;\n} {\n    @vec2 uniform =resolution\n    @float uniform =time\n    @vec2 varying =position\n    position 2 / 1 - [ resolution .xy \\/ 1 ] * =real-position\n\n    :m ->fragColor =$gl_FragColor ;\n} shadertoy cif\n\n{ + - * / } //{ (| operator |)\n    { = => } //{ (| assignment |)\n            `{ (| value variable |)\n                        *variable\n                        value\n                    ,operator\n                        &,assignment\n                        variable\n                    concat\n                call\n            }\n            operator assignment concat\n        def-prefix\n    }\n}\n:p min= (| variable |) *variable min &= variable concat call ;\n:p max= (| variable |) *variable max &= variable concat call ;\n\n:m when (| block cond |) block { } cond if ;\n:m cwhen (| block cond |) cond ~*block ;\n\n: smin (| a b k |)\n    k a b - abs - 0 max k / =h\n    a b min [ h h k 1 4 / ] \\* -\n;\n\n: sdif (| d1 d2 k |)\n    0.5 !d2 d1 + * k / - 0 1 clamp =h\n    d2 d1 neg h mix [ k h 1 h - ] \\* +\n;\n\n: sint (| d1 d2 k |)\n    0.5 !d2 d1 - * k / - 0 1 clamp =h\n    d2 d1 h mix [ k h 1 h - ] \\* +\n;\n\n:m union \\min ;\n:m mat-union \\{ (| $a $b |) a b a .x b .x < select } ;\n:m smooth-union (| list k |) list \\{ k smin } list union k 0 != select ;\n\n:m difference \\{ (| d1 d2 |) d2 neg d1 max } ;\n:m smooth-difference (| list k |) list \\{ swap k sdif } list difference k 0 != select ;\n\n:m intersection \\max ;\n:m smooth-intersection (| list k |) list \\{ k sint } list intersection k 0 != select ;\n\n:m scale (| block factor p |) p factor / *block factor * ;\n\n:m repeat (| block c p |) p .5 c * + c mod .5 c * - *block ;\n\n:m onion (| sdf thickness |) sdf abs thickness - ;\n\n:m store !drop ;\n\n:m apply (| funcs value |) funcs /{ value *_ } ;\n\n:m rotate (| $p angle |)\n        { cos sin }\n            &*angle\n            { angle store }\n            angle is-block?\n        cif\n    apply =[ c s ]\n    [\n        p .x c * p .y s * -\n        p .x s * p .y c * +\n    ]\n;\n\n:m scoped (| block p |) p *block ;\n\n:m round .5 + floor ;\n\n:m noise-permute (| x |)\n\tx 34 * 1 + x * 289 mod\n;\n\n:m pnoise-fade (| t |)\n\tt 6 * 15 - t * 10 + t * t * t *\n;\n\n: pnoise-2d (| v |)\n\tv .xyxy floor [ 0 0 1 1 ] + 289 mod =Pi\n\tv .xyxy fract [ 0 0 1 1 ] - =Pf\n\n\tPi .xzxz noise-permute Pi .yyww + noise-permute =>i\n\ti 41 / fract 2 * 1 - =gx\n\tgx abs .5 - =gy\n\tgx !round - =gx\n\n\t[ gx .x gy .x ] =>g00\n\t[ gx .y gy .y ] =>g10\n\t[ gx .z gy .z ] =>g01\n\t[ gx .w gy .w ] =>g11\n\n\tgx gx * gy gy * + sqrt inversesqrt =norm\n\tg00 norm .x * Pf .xy dot =>n00\n\tg10 norm .z * Pf .zy dot =>n10\n\tg01 norm .y * Pf .xw dot =>n01\n\tg11 norm .w * Pf .zw dot =>n11\n\n\tPf .xy pnoise-fade =fade_xy\n\t[ n00 n01 ] [ n10 n11 ] fade_xy .x mix =n_x\n\tn_x .x.y fade_xy .y mix 2.3 *\n;\n\n:m apply-contrast (| color value |)\n    color .5 - value 0 max * .5 + 0 1 clamp\n;\n\n:m apply-brightness (| color value |)\n    color value + 0 1 clamp\n;\n\n:m apply-vignette (| color distance intensity |)\n    real-position length distance - =>v\n    v intensity * 0 1 clamp =>v\n    1 v - =>v\n    color v *\n;\n\ntime 1 * =>time\n\n:m inv 1 _ - ;\n\n[ { .1 + =>i\n    [ i sin time * .05 * i 1.5 / sin time 10 / * !sign i * + ] =>$offset\n        real-position 2 *\n        offset + i *\n    =>$tpos\n    tpos pnoise-2d abs =>$t\n    [\n        t 0.5 0.8 smoothstep inv\n        t 0.6 0.7 smoothstep inv\n        t 0.3 0.6 smoothstep inv\n    ]\n} #6 mtimes ] \\+ 7 / =color\n\n\n        color\n        .1\n    apply-brightness\n    2\napply-contrast\n1.6 * =color\n\ncolor .9 10 apply-vignette =color\n\n[ color 1 ] ->fragColor\n*/\n\nfloat pnoise_2d_float_vec2(vec2 arg_0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 real_position;\n\tfloat tmp_0;\n\tvec2 tmp_1;\n\tvec2 tmp_2;\n\tfloat tmp_3;\n\tfloat tmp_4;\n\tvec2 tmp_5;\n\tvec2 tmp_6;\n\tfloat tmp_7;\n\tfloat tmp_8;\n\tvec2 tmp_9;\n\tvec2 tmp_10;\n\tfloat tmp_11;\n\tfloat tmp_12;\n\tvec2 tmp_13;\n\tvec2 tmp_14;\n\tfloat tmp_15;\n\tfloat tmp_16;\n\tvec2 tmp_17;\n\tvec2 tmp_18;\n\tfloat tmp_19;\n\tfloat tmp_20;\n\tvec2 tmp_21;\n\tvec2 tmp_22;\n\tfloat tmp_23;\n\tvec3 color;\n\treal_position = (fragCoord / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.0) * 1.05;\n\ttmp_0 = (sin(0.06666667)) * ((iTime) / (10.));\n\ttmp_1 = vec2(((sin(0.1)) * (iTime)) * (0.05), (tmp_0) + ((sign(tmp_0)) * (0.1)));\n\ttmp_2 = (((real_position) * (2.)) + (tmp_1)) * (0.1);\n\ttmp_3 = abs(pnoise_2d_float_vec2(tmp_2));\n\ttmp_4 = (sin(0.73333335)) * ((iTime) / (10.));\n\ttmp_5 = vec2(((sin(1.1)) * (iTime)) * (0.05), (tmp_4) + ((sign(tmp_4)) * (1.1)));\n\ttmp_6 = (((real_position) * (2.)) + (tmp_5)) * (1.1);\n\ttmp_7 = abs(pnoise_2d_float_vec2(tmp_6));\n\ttmp_8 = (sin(1.4)) * ((iTime) / (10.));\n\ttmp_9 = vec2(((sin(2.1)) * (iTime)) * (0.05), (tmp_8) + ((sign(tmp_8)) * (2.1)));\n\ttmp_10 = (((real_position) * (2.)) + (tmp_9)) * (2.1);\n\ttmp_11 = abs(pnoise_2d_float_vec2(tmp_10));\n\ttmp_12 = (sin(2.0666666)) * ((iTime) / (10.));\n\ttmp_13 = vec2(((sin(3.1)) * (iTime)) * (0.05), (tmp_12) + ((sign(tmp_12)) * (3.1)));\n\ttmp_14 = (((real_position) * (2.)) + (tmp_13)) * (3.1);\n\ttmp_15 = abs(pnoise_2d_float_vec2(tmp_14));\n\ttmp_16 = (sin(2.7333333)) * ((iTime) / (10.));\n\ttmp_17 = vec2(((sin(4.1)) * (iTime)) * (0.05), (tmp_16) + ((sign(tmp_16)) * (4.1)));\n\ttmp_18 = (((real_position) * (2.)) + (tmp_17)) * (4.1);\n\ttmp_19 = abs(pnoise_2d_float_vec2(tmp_18));\n\ttmp_20 = (sin(3.3999999)) * ((iTime) / (10.));\n\ttmp_21 = vec2(((sin(5.1)) * (iTime)) * (0.05), (tmp_20) + ((sign(tmp_20)) * (5.1)));\n\ttmp_22 = (((real_position) * (2.)) + (tmp_21)) * (5.1);\n\ttmp_23 = abs(pnoise_2d_float_vec2(tmp_22));\n\tcolor = ((((((vec3((1.) - (smoothstep(tmp_3, 0.5, 0.8)), (1.) - (smoothstep(tmp_3, 0.6, 0.7)), (1.) - (smoothstep(tmp_3, 0.3, 0.6)))) + (vec3((1.) - (smoothstep(tmp_7, 0.5, 0.8)), (1.) - (smoothstep(tmp_7, 0.6, 0.7)), (1.) - (smoothstep(tmp_7, 0.3, 0.6))))) + (vec3((1.) - (smoothstep(tmp_11, 0.5, 0.8)), (1.) - (smoothstep(tmp_11, 0.6, 0.7)), (1.) - (smoothstep(tmp_11, 0.3, 0.6))))) + (vec3((1.) - (smoothstep(tmp_15, 0.5, 0.8)), (1.) - (smoothstep(tmp_15, 0.6, 0.7)), (1.) - (smoothstep(tmp_15, 0.3, 0.6))))) + (vec3((1.) - (smoothstep(tmp_19, 0.5, 0.8)), (1.) - (smoothstep(tmp_19, 0.6, 0.7)), (1.) - (smoothstep(tmp_19, 0.3, 0.6))))) + (vec3((1.) - (smoothstep(tmp_23, 0.5, 0.8)), (1.) - (smoothstep(tmp_23, 0.6, 0.7)), (1.) - (smoothstep(tmp_23, 0.3, 0.6))))) / (7.);\n\tcolor = (clamp((((clamp((color) + (0.1), 0., 1.)) - (0.5)) * (max(2., 0.))) + (0.5), 0., 1.)) * (1.6);\n\tcolor = (color) * ((1.) - (clamp(((length(real_position)) - (0.9)) * (10.), 0., 1.)));\n\tfragColor = vec4(color, 1.);\n}\n\nfloat pnoise_2d_float_vec2(vec2 arg_0) {\n\tvec4 Pi;\n\tvec4 Pf;\n\tvec4 gx;\n\tvec4 gy;\n\tvec4 norm;\n\tvec2 fade_xy;\n\tvec2 n_x;\n\tPi = mod((floor((arg_0).xyxy)) + (vec4(0., 0., 1., 1.)), 289.);\n\tPf = (fract((arg_0).xyxy)) - (vec4(0., 0., 1., 1.));\n\tgx = ((fract((mod(((((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)) * (34.)) + (1.)) * ((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)), 289.)) / (41.))) * (2.)) - (1.);\n\tgy = (abs(gx)) - (0.5);\n\tgx = (gx) - (floor((gx) + (0.5)));\n\tnorm = inversesqrt(sqrt(((gx) * (gx)) + ((gy) * (gy))));\n\tfade_xy = ((((((((Pf).xy) * (6.)) - (15.)) * ((Pf).xy)) + (10.)) * ((Pf).xy)) * ((Pf).xy)) * ((Pf).xy);\n\tn_x = mix(vec2(dot((vec2((gx).x, (gy).x)) * ((norm).x), (Pf).xy), dot((vec2((gx).z, (gy).z)) * ((norm).y), (Pf).xw)), vec2(dot((vec2((gx).y, (gy).y)) * ((norm).z), (Pf).zy), dot((vec2((gx).w, (gy).w)) * ((norm).w), (Pf).zw)), (fade_xy).x);\n\treturn (mix((n_x).x, (n_x).y, (fade_xy).y)) * (2.3);\n}\n","name":"Image","description":"","type":"image"}]}