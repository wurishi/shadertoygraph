{"ver":"0.1","info":{"id":"wl2czt","date":"1595162208","viewed":281,"name":"Helix Distance Estimator","username":"fizzer","description":"Approximate distance to a helix-like shape (actually a swept disc, hence the fact that the inner radius only applies in the XY plane at each point of the helix coil). ","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sdf","helix","approximate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Approximate distance to a helix-like shape (actually a swept disc, hence the fact\n// that the inner radius only applies in the XY plane at each point of the helix coil).\n// I arrived at this function by starting with the f/|Δf| method, re-arranged the terms, then\n// picked out the recognizable vector operations.\n\nconst float pi = 3.14159265358979323;\nconst float r0 = 1.9;\nconst float r1 = .5;\nconst float twist = .8;\n    \n// Helix distance estimation. (Actually it's a swept disc along a helix coil).\n// Discovered via the f/|Δf| method of distance estimation.\nfloat helix(vec3 p, float r0, float r1, float twist)\n{\n    vec2 zv = vec2(cos(p.z * twist), sin(p.z * twist)) * r0;\n    float dsq = dot(p.xy - zv, p.xy - zv) - r1 * r1;\n    float gsq = 4. * (dot(p.xy, p.xy) - 2. * dot(p.xy, zv) + r0 * r0 +\n        (dot(p.xy * p.xy, zv.yx * zv.yx) - 2. * p.x * zv.x * p.y * zv.y) * twist * twist);\n    \n    return dsq / sqrt(gsq);\n}\n\nfloat map(vec3 p)\n{\n    return min(p.y + 2.4, helix(p, r0, r1, twist));\n}\n\n// Forward-difference SDF gradients.\nvec3 distG(vec3 p)\n{\n    vec2 e = vec2(1e-3, 0);\n    return vec3(map(p + e.xyy), map(p + e.yxy), map(p + e.yyx)) -\n        vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n}\n\n// Soft shadow for SDF, from IQ and Sebastian Aaltonen:\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique, float s )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<70; i++ )\n    {\n        float h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n            res = min( res, s*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, s*d/max(0.0,t-y) );\n            ph = h;\n        }\n\n        t += h;\n\n        if( res<0.0001 || t>tmax ) break;\n\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    // Camera position and target.\n    float move = -iTime;\n    vec3 campos = vec3(-9., 6., 5. + move);\n    vec3 camtarget = vec3(0, -.5, move);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 2.7));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n    \n    // SDF raymarching.\n    float t = 4.;\n    for(int i = 0; i < 100; ++i)\n    {\n        float d = map(ro + rd * t);\n        if(d < 1e-3)\n            break;\n        if(t > 100.)\n            break;\n        t += d;\n    }\n    \n    vec3 rp = ro + rd * t;\n    \n    vec3 n = normalize(distG(ro + rd * t));\n\n    // Shadows.\n    vec3 r = reflect(rd, n);\n    vec3 ld = normalize(vec3(1, 2, 1));\n    float sh = calcSoftshadow(ro + rd * t, ld, 1e-4, 1e3, 0, 6.);\n    float sh2 = calcSoftshadow(ro + rd * t, r, 1e-2, 1e3, 0, 4.);\n    \n    // Surface colour.\n    vec3 diff;\n    \n    if(rp.y < -2.39)\n    {\n        diff = mix(vec3(.95), vec3(.95,.32,.1), .7);\n    }\n    else\n    {\n        vec2 hp = vec2(cos(rp.z * twist), sin(rp.z * twist)) * r0 - rp.xy;\n        float a = atan(hp.y, hp.x) / pi * 1.5;\n        \n        diff = mix(vec3(.95),vec3(1,.02,.02), clamp((min(fract(a) * 2., 2. - fract(a) * 2.) - .5) * 20., 0., 1.));\n    }\n    \n    fragColor.rgb = diff;\n\n    float fr = pow(clamp(1. - dot(n, -rd), 0., 1.), 1.5);\n\n    // Lighting and BRDF.\n    fragColor.rgb *= mix(vec3(.8,.8,1.) / 1.5, vec3(1.), sh) * max(0., .6 + .4 * dot(n, ld));\n    fragColor.rgb += textureLod(iChannel0, r, (rp.y < -2.39) ? 5. : 4.).rrr * fr * sh2;\n    \n    // Colour remapping etc.\n    fragColor.rgb *= .85;\n    fragColor.rgb /= (fragColor.rgb + 1.1)*.5;\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2)) +\n        \t\t\t\ttexelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rgb / 200.;\n}","name":"Image","description":"","type":"image"}]}