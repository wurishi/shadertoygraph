{"ver":"0.1","info":{"id":"dtjBWy","date":"1694470627","viewed":217,"name":"Highlands Castle","username":"athibaul","description":"A 2D shader depicting a fictitious castle in the Scottish highlands.\nTotally not inspired by a famous series of books/films.\nMake sure you enable sound.","likes":31,"published":1,"flags":8,"usePreview":0,"tags":["2d","castle","highlands"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Highlands Castle\n// by athibaul, 2023-09-11\n\n#define W (1.5*max(fwidth(pW.x), fwidth(pW.y)))\n//#define W 0.\n#define BOX(p,r,fg) {vec2 pW = p; float d = sdBox(p, r); c = mix(c, fg, smoothstep(0., -W, d)); }\n#define TOW(p,r,fg,slope) q = (p) / (r); {vec2 pW = p; float d = sdTower(p, r, slope); float fg2 = mix(fg,bgc,0.1*abs(q.x)*smoothstep(-0.5,0.5,q.y)); c = mix(c, fg2, smoothstep(0., -W, d)); }\n#define TRI(p,q,fg) {float d = sdTriangleIsosceles(p, q); c = mix(c, fg, smoothstep(0., -W, d)); }\n#define WINDOWS(s,r,w) {vec2 q0 = q; q.x = abs(q.x) < 1. ? asin(q.x) : 1000.; q = abs(q * (s)) - (r)*(s); q -= min(vec2(0),round(q)); BOX(q, w, fg);}\n\n\n// cosine based palette adapted from Inigo Quilez:\n// https://iquilezles.org/articles/palettes/\nvec3 pal(in float t)\n{\n    vec3 a = vec3(.5), b = vec3(.5), c = vec3(1), d = vec3(0,.1,.2);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// 2D sdfs from iquilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n//---\n\n#define T(p) textureLod(iChannel0,(p)/256.,0.).r\n\nfloat fbm(vec2 p)\n{\n    p += T(p.yx*5. + iTime*0.1)*0.1;\n    return T(p)/2. + T(p*2.)/4. + T(p*4.)/8. + T(p*8.)/16. + T(p*16.)/32. + T(p*32.)/64.;\n}\n\n\nfloat sinn(in float x)\n{\n    return sin(x) + 0.62*cos(1.62*x);\n}\n\nfloat sdTower(in vec2 p, in vec2 r, in float slope) {\n    float d = sdBox(p, r);\n    // Also add a small ring before the end of the tower\n    p.y -= r.y - r.x;\n    d = min(d, sdBox(p, vec2(r.x * (1.1 + 0.1 * p.y / (r.x*0.3)), r.x*0.3)));\n    // And the roof\n    float h = slope * r.x;\n    p.y -= r.x*0.9 + h;\n    d = min(d, sdTriangleIsosceles(p, vec2(r.x*1.2, -h)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    //float W = fwidth(uv.y);\n    \n    // I want to use palette values ranging from 0.0 to 0.5\n    // 0.5 night sky\n    // 0.4 pitch black\n    // 0.2-0.1 windows\n    // 0.0 bright highlights\n    \n    float blk = 0.4; // pitch black\n    float bgc = 0.5 + 0.05*uv.y; // background gradient for the sky\n    float c = bgc;\n    // Hills in the background\n    float voff = 0.8, phi = 1.2, vscale = 0.3;\n    for(float i=20.; i>2.; i/=1.8) {\n        float d = uv.y - (0.4*sinn(uv.x*i + 10.2*i +1.) - 0.6)/i - 0.3;\n        vec2 pW = uv;\n        c = mix(c, mix(bgc, blk, exp(-0.5*i)), smoothstep(0., -W, d));\n        // Passing clouds\n        vec2 uv_clouds = uv * 2. * i;\n        uv_clouds += 1.*fbm(uv_clouds - iTime * vec2(-0.4,0.05));\n        uv_clouds += vec2(1,-1)*fbm(-uv_clouds - iTime * vec2(0.2,0.5));\n        float clouds = fbm(uv_clouds + vec2(1.,1.62) * 100.*i + iTime * vec2(-0.5,-0.1));\n        c = mix(c, bgc + clouds, 0.13*smoothstep(2./i,-0.5,d));\n    }\n    \n    // Front hill\n    {\n        float d = uv.y - 0.2*sinn(uv.x*1.5 + 1.) + 0.5;\n        vec2 pW = uv;\n        c = mix(c, blk, smoothstep(0., -W, d));\n    }\n    // Castle towers and windows\n    vec2 p = 2.2*(uv - vec2(-0.35,-0.25));\n    {\n        vec2 q = vec2(0);\n        float fg = 0.;\n        //W *= 2.;\n        BOX(p, vec2(0.75,0.5), blk); // main block\n        BOX(p - vec2(-1.,-0.5) - 0.1*p.y, vec2(0.8,0.5), blk); // left block\n        BOX(p - vec2(0.5,-0.2) + 0.2*p.y, vec2(0.8,0.5), blk); // right block\n        BOX(p - vec2(-0.2,0.5) - 0.1*p.y, vec2(0.3,0.2), blk); // chapel beneath left tower\n        BOX(p - vec2(0.2,0.4), vec2(0.2, 0.5), blk); // left reinforcement of high tower\n        BOX(p - vec2(0.5, 0.6) - vec2(0.,1.)*p.x, vec2(0.1, 0.1), blk); // right flank of high tower\n        TOW(p - vec2(-0.12, 0.6), vec2(0.13, 0.6), blk, 2.5); // left tower beside high tower\n        fg = 0.1 + abs(q.x)*0.2; q.y -= 0.7; WINDOWS(vec2(1.5,3.), vec2(1.,0.2), vec2(0.2))\n        TOW(p - vec2(0.2, 0.9), vec2(0.25,0.8), blk, 3.5); // high tower\n        fg = abs(q.x)*0.3 - 0.2*q.y; WINDOWS(3., vec2(1.,0.83), vec2(0.2))\n        TOW(p - vec2(-0.35, 0.7), vec2(0.05, 0.2), blk, 6.); // chapel tower\n        fg = bgc; q.y -= 0.9; WINDOWS(vec2(1.5,5.), vec2(1.,0.), vec2(0.4))\n        fg = 0.2; TOW(p - vec2(0.5, 1.3), vec2(0.1, 0.15), blk, 4.); // right tower beside high tower\n        q -= vec2(0.5,-0.2); WINDOWS(vec2(1.,1.), vec2(0.2,0.2), vec2(0.1))\n        TOW(p - vec2(-1., 0.3), vec2(0.16, 0.45), blk, 2.1); // middle left tower flank\n        fg = 0.3; q.y -= 0.85; WINDOWS(1.5, vec2(1.,0.), vec2(0.1,0.15))\n        TOW(p - vec2(-0.7, 0.4), vec2(0.2, 0.5), blk, 2.); // middle left tower\n        fg = 0.1; q.y -= 0.8; WINDOWS(2., vec2(1.,0.), vec2(0.1,0.2))\n        TOW(p - vec2(0.65, 0.2), vec2(0.1, 0.55), blk, 5.); // middle right tower\n        fg = 0.1; q.y -= 0.9; WINDOWS(2., vec2(1.,0.), vec2(0.1,0.1))\n        TOW(p - vec2(-1.5, 0.), vec2(0.3, 0.5), blk, 1.5); // left tower\n        fg = 0.3; q.y -= 0.8; WINDOWS(2., vec2(1.,0.), vec2(0.2))\n        TOW(p - vec2(1.05, 0.3), vec2(0.25, 0.4), blk, 1.2); // right tower\n        fg = 0.3; q.y -= 0.8; WINDOWS(2., vec2(1.,0.), vec2(0.2))\n        //float d = sdBox(p, vec2(0.5,0.5));\n        //c = mix(c, blk, smoothstep(0., -W, d));\n    }\n    \n    // Chapel windows\n    {\n        vec2 q = p - vec2(-0.2,0.6);\n        float fg = 0.15 - q.x + q.y;\n        float qy = max(q.y,0.);\n        q = abs(q/0.05) - (vec2(7,1)*0.5-0.5);\n        q -= min(vec2(0), round(q));\n        float width = 0.2 - 100.*qy*qy;\n        BOX(q, vec2(width, 2.0), fg);\n    }\n    \n    \n    // Hall windows\n    {\n        vec2 q = p - vec2(-0.2,0.6);\n        float fg = 0.15 - q.x + q.y;\n        float qy = max(q.y,0.);\n        q = abs(q/0.05) - (vec2(7,1)*0.5-0.5);\n        q -= min(vec2(0), round(q));\n        float width = 0.2 - 100.*qy*qy;\n        BOX(q, vec2(width, 2.0), fg);\n    }\n    \n    // Flying flag\n    {\n        vec2 q = p - vec2(0.2, 0.9) - vec2(0.,0.8 + 3.5*.25);\n        float h = 0.2;\n        q.x = h-q.x;\n        q.y += 0.2*h*sin(16.*q.x+3.*iTime) * smoothstep(h,0.,q.x);\n        vec2 pW = q;\n        TRI(q.yx, vec2(0.03,h), blk)\n    }\n    vec3 col = pal(c);\n    //col = mix(col, pal(bgc), 0.1);\n    // Slight vignette\n    col = pow(col, vec3(0.8 + 0.1*dot(uv,uv)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318\n#define F(nn) 440.*pow(2., ((nn)-9.)/12.)\n#define bdur (60./160.)\n\nfloat varsaw(float t, float f, float fc) {\n    float p = mod(f*t, 1.);\n    return (p - 0.5) * clamp(2.*p*(1.-p)*fc/f, 0., 1.);\n}\n\nvec2 pan(float x) {\n    return vec2(1. - x, 1. + x);\n}\n\nvec2 stringPad(float t, float df) {\n    vec4 nn = vec4(-8.,-1.,7.,16.);\n    vec2 sig = vec2(0);\n    float swell = 0.5 - 0.2*cos(TAU/2.*t);\n    sig += pan(-0.5) * varsaw(t, F(nn.x)+df, 500. + 500.*swell) * swell;\n    sig += pan(-0.2) * varsaw(t, F(nn.y)+df, 600. + 1000.*swell) * swell;\n    sig += pan( 0.2) * varsaw(t, F(nn.z)+df, 800. + 800.*swell) * swell;\n    sig += pan( 0.5) * varsaw(t, F(nn.w)+df, 1000. + 500.*swell) * swell;\n    return sig * 0.2;\n}\n\nvec2 stringPhrase(float t) {\n    float t0 = t;\n    t -= 32.*bdur;\n    t = max(t,-0.249*bdur);\n    float hasBegun = step(0.,t);\n    \n    float fc = 1500. + 500.*sin(0.125*TAU*t/bdur) * (0.5+.1*cos(t));\n    t = mod(t, 8.*bdur);\n    float u = 4.*t/bdur;\n    //float a[8] = float[8](7.,6.,7.,9.,11.,9.,7.,6.);\n    float a[32] = float[32](4.,3.,4.,6.,7.,9.,11.,13.,15.,16.,18.,19.,21.,23.,24.,23.,\n                           21.,19.,18.,16.,14.,12.,11.,10.,11.,9.,7.,6.,7.,6.,4.,3.);\n    int i = int(floor(u));\n    int j = int(floor(mod(u+1., 32.)));\n    float nn = a[i], nn2 = a[j];\n    //float env = smoothstep(0.,0.5,fract(u)) * smoothstep(1.,0.5,fract(u));\n    //env *= 1. + 0.2*sin(TAU/2.*u);\n    //return vec2(varsaw(t, F(nn), fc)) * 0.15 * env;\n    vec2 sig = vec2(0);\n    sig += varsaw(t0, F(nn), fc) * smoothstep(1.,0., fract(u)) * hasBegun;\n    sig += varsaw(t0, F(nn2), fc) * smoothstep(0.,1., fract(u));\n    return sig * 0.15;\n}\n\nvec2 stringPhraseVerb(float t) {\n    vec2 sig = pan(-0.2) * stringPhrase(t);\n    sig += pan(0.5) * stringPhrase(t - 0.08) * 0.5;\n    sig += pan(-0.5) * stringPhrase(t - 0.15) * 0.3;\n    sig += pan(0.) * stringPhrase(t - 0.3) * 0.1;\n    return sig;\n}\n\nfloat pluck(float t, float f) {\n    t = max(t,0.);\n    float fc = f * (2. + 1. * exp(-20.*t));\n    return varsaw(t, f, fc) * exp(-10.*t) * smoothstep(0.,0.005,t);\n}\n\nvec2 pluckPhrase(float t) {\n    t -= (32.+16.)*bdur;\n    t = max(t,0.);\n    t = mod(t, 8.*bdur);\n    float f = t > 7.*bdur ? 0. : \n              t > 3.5*bdur && t < 4.*bdur ? F(-1.-24.) :\n              F(4.-24.);\n    t = mod(t, 4.*bdur);\n    float env = smoothstep(4.*bdur, 3.9*bdur, t); // fade out short note\n    t = mod(t, 3.5*bdur);\n    vec2 sig = vec2(0);\n    sig += pluck(t, f);\n    sig += pluck(t - 0.03, 2.*f - 2.) * pan(0.2) * 0.3;\n    sig += pluck(t - 0.02, 2.*f + 2.) * pan(-0.2) * 0.2;\n    return sig * 0.8 * env;\n}\n\nvec2 glock(float t, float f) {\n    t = max(t,0.);\n    vec2 fs = vec2(f-1., f+1.);\n    return sin(TAU*fs*t + 0.2*exp(-15.*t)*sin(7.*TAU*fs*t)) * exp(-3.*t);\n}\n\n#define G(nn,d) sig+=glock(t,F(nn+24.)); t-=(d)*bdur;\nvec2 glockPhrase(float t) {\n    t -= 1.;\n    t = max(t, 0.);\n    vec2 sig = vec2(0);\n    G(-1.,1.) G(-8.,0.) G(4.,1.5) G(7.,.5) G(6.,1.) G(-8.,0.) G(4.,2.) G(11.,1.)\n    G(-8.,0.) G(9.,3.) G(-8.,0.) G(6.,3.)\n    G(-8.,0.) G(4.,1.5) G(7.,.5) G(6.,1.) G(-5.,0.) G(3.,2.) G(-13.,0.) G(5.,1.)\n    G(-8.,0.) G(-1.,2.) G(-5.,1.) G(-8.,0.) G(-1.,2.)\n    return sig * 0.05;\n}\n\nvec2 glockPhraseVerb(float t) {\n    vec2 sig = glockPhrase(t);\n    sig += glockPhrase(t-0.03).yx * 0.5;\n    return sig;\n}\n\nvec2 mainSound(int samp, float t)\n{\n    vec2 sig = vec2(0);\n    \n    sig += stringPad(t, 0.) * 0.2;\n    sig += stringPad(t, 1.62).yx * 0.15;\n    \n    sig += stringPhraseVerb(t) * 0.8;\n    \n    sig += pluckPhrase(t);\n    \n    sig += glockPhraseVerb(t) * 0.5;\n    \n    return sig * smoothstep(0.,1.,t);\n}","name":"Sound","description":"","type":"sound"}]}