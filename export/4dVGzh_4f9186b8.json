{"ver":"0.1","info":{"id":"4dVGzh","date":"1453281243","viewed":162,"name":"Fancier Patterns - MoirÃ©","username":"algrant","description":"Making some fancy patterns","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["moire","fancy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"bool topHalf( in vec2 v)\n{\n    return v.y > iResolution.y/2.0;\n}\n\nvec2 rotateTranslate( in vec2 v, in vec2 offset, in float rot ){\n\tfloat c = cos(rot);\n    float s = sin(rot);\n    return mat2(c,-s,s,c)*(v-offset);\n    //return vec2 ((v.x - offset.x)*c - (v.y - offset.y)*s, (v.x - offset.x)*s + (v.y - offset.y)*c);\n}\n\nbool checkerBoard( in vec2 v, in float gridW, in float gridH){\n    v = mod(floor(v/gridW),2.);\n    return v.x==v.y;\n    \n    //if ( mod(floor(v.x/gridW),2.0) == \n    //  mod(floor(v.y/gridH), 2.0)) {\n    //   return true;\n    //}\n    //return false;\n}\n\nbool circleSquareGrid( in vec2 v, in float gridW, in float gridH ){\n\t\n    if (checkerBoard(v, gridW, gridH)){\n        float x = mod(v.x, gridW) - gridW/2.0;\n        float y = mod(v.y, gridH) - gridH/2.0;\n        if(x*x + y*y < gridW*gridH/4.0){\n\t\t\treturn true;\n        }\n    }\n    \n    return false;\n}\n\n\nvec2 cube_to_hex( in vec3 h){\n    float q = h.x;\n    float r = h.z;\n    return vec2(q, r);\n}\n\nvec3 hex_to_cube( in vec2 h){\n    float x = h.x;\n    float z = h.y;\n    float y = -x-z;\n    return vec3(x, y, z);\n}\n\nvec3 cube_round ( in vec3 h ) {\n    float rx = floor(h.x+0.5);\n    float ry = floor(h.y+0.5);\n    float rz = floor(h.z+0.5);\n    \n    float x_diff = abs(rx - h.x);\n    float y_diff = abs(ry - h.y);\n    float z_diff = abs(rz - h.z);\n    \n    if (x_diff > y_diff && x_diff > z_diff){\n        rx = -ry-rz;\n    } else {\n        if (y_diff > z_diff){\n        \try = -rx-rz;\n       \t} else {\n        \trz = -rx-ry;\n       \t}\n    }\n        \n    return vec3 (rx, ry, rz);\n}\n\nvec2 hex_round(in vec2 h) {\n    return cube_to_hex(cube_round(hex_to_cube(h)));\n}\n\nvec2 pixel_to_hex(in vec2 v, in float size){\n    float q = (v.x * sqrt(3.0)/3.0 - v.y / 3.0) / size;\n    float r = v.y * 2.0/3.0 / size;\n    \n    return hex_round(vec2(q, r));\n}\n\nvec2 hex_to_pixel(in vec2 v, in float size){\n    float x = size * sqrt(3.0) * (v.x + v.y/2.0);\n    float y = size * 3.0/2.0 * v.y;\n    return vec2(x, y);\n}\n\nbool hexGrid( in vec2 v, in float size, in float offset ){\n\tvec2 hexagon = pixel_to_hex(v, size);\n    \n    if (mod(hexagon.x+offset,3.0) == mod(hexagon.y, 3.0)){\n        return true;\n    }\n    \n    return false;\n}\n\nbool circleHexGrid( in vec2 v, in float size, in float circleRatio ){\n\tvec2 hexagon = pixel_to_hex(v, size);\n    vec2 hexPoint = hex_to_pixel(hexagon, size);\n    //if (mod(hexagon.x+offset,3.0) == mod(hexagon.y, 3.0)){\n        float xDiff = hexPoint.x - v.x;\n        float yDiff = hexPoint.y - v.y;\n        return xDiff*xDiff+yDiff*yDiff < size*size*3.0/8.0*circleRatio;\n    //}\n    \n    return false;\n}\n\nbool letterASquareGrid( in vec2 v, in float size ){\n\tfloat x = floor(mod(v.x, size)/(size/4.0));\n    float y = floor(mod(v.y, size)/(size/5.0));\n    if ( (x == 1.0 || x == 3.0) &&\n    \t( y == 1.0 ||\n          y == 2.0 ||\n         y == 3.0 ||\n         y == 4.0 )){\n            return true;\n    }\n   \tif ( x == 2.0 && (\n        y == 1.0 || y == 3.0 )) {\n       \treturn true;\n    }\n    \n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v1 = fragCoord.xy;\n    vec2 v2 = rotateTranslate(fragCoord.xy, vec2(iResolution.x/2.0,iResolution.y/2.0), iTime*0.12);\n    \n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    //if (letterASquareGrid(v1, 10.0) || letterASquareGrid(v2, 10.0)){\n    //    fragColor = vec4(0,0,0,0);\n    //}\n    \n    if(!circleHexGrid(v1, 5. , 1.5) || !circleHexGrid(v2, 6., 1.5)){\n    \tfragColor = vec4((vec2(1.0,1.0)-uv)/2.0,(1.0-0.5*sin(iTime))/2.0,0.5);\n    }\n    \n    //if (circleHexGrid(v2, 15.0, 0.0, 0.9)){\n        \n\t//\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        \n    //} else {\n    //    if (circleHexGrid(v2, 15.0, 1.0, 0.5)){\n    //    \tfragColor = vec4(vec2(1.0,1.0)-uv,1.0-0.5*sin(iTime),0.5);\n    //    } else {\n    //        fragColor = vec4(0,0,0,0);\n    //    }\n    //}\n}","name":"","description":"","type":"image"}]}