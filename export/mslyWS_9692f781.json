{"ver":"0.1","info":{"id":"mslyWS","date":"1687182138","viewed":64,"name":"rainbow rings kaborkian","username":"kaborkian","description":"based on this tutorial https://www.youtube.com/watch?v=f4s1h2YETNY&t=1018s&ab_channel=kishimisu","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["todo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 pallete(float t, vec3 exposure, vec3 intensity, vec3 cycles, vec3 phase) {//t&cycles 0<>1\n    //not clamped and phase pushes to the right, unlike http://dev.thi.ng/gradients/\n    return exposure + intensity * cos(2.0*PI * (cycles * t - phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //declaring settings variables\n    vec2 uv = makeClipSpace(fragCoord, iResolution); //800x450 -> 1.777x1\n    vec3 col = vec3(0.0); //background color\n    float rep; // scaling\n    const float PI = 3.141592; // Ï€\n    float anim_speed = 2.0; // animation speed, playback speed\n    float freq = 1.0; // frequency of trig funcs\n    float intensity = 10.0; // emission strength of 'glowing stuff'\n    \n    for (float i=1.0; i < 3.0; i++) {\n        rep = 4.0 / i;\n        uv = mod(uv, rep) - rep / 2.0;\n        anim_speed *= -1.0; //reversing ring growth direction with each iteration\n        float d = length(uv); // distance from origin\n        float mask = sin(d * freq*2.0*PI - 0.5*PI - iTime*anim_speed); // multiply so 1 freq = half trig cycle = 1 peak\n        mask = mapRange(-1.0, 1.0, 0.0, 1.0, mask); // remap values to 0 <> 1\n\n        float radius = 0.02 / (i * 10.0); // size of glow\n        float glow = radius / mask; // range is 0 <> infinity\n        glow -= (radius/1.0); // substracting min value for black background\n        glow += 0.003; // adding some exposure for cheap bloom\n        glow *= intensity;\n\n        // each component of the vector corresponds to a subpixel, xyz -> rgb\n        vec3 exposure = vec3(0.5); // these inputs for a and b are for remapping our trig functions\n        vec3 brightness = vec3(0.5); // to 0 <> 1 exacatly like doing \"cos(x) / 2.0 + 0.5\"\n        float spread = 0.5;\n        vec3 cycles = vec3( min(d / abs(uv.y), d / abs(uv.x)) * sin(iTime * 0.03 * i) * 2.0 ); // frequency,\n        vec3 phase = vec3(0.667,0.333,0.0); // offsetting each subcolor wave for varying colors\n        vec3 gradient = pallete(d, exposure, brightness, cycles, phase);\n        col += glow * gradient;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// library of custom made functions that i find usefull, feel free to use - made by kaborkian\n// an exclamation mark '[!]' means the input is necessary\n// and a question mark '[?]' means its optional and if unprovided will be given default values\n\nconst float PI = 3.141592;\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\nconst vec3 GREY = vec3(0.5, 0.5, 0.5);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\nconst vec3 MAGENTA = vec3(1.0, 0.0,1.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\n\n//_____________________________________________________________________________________________\n// input: current fragment coordiantes in absolute values\n// output: remapped fragment coordinates where the origin (0,0) is centered on the canvas.\n// short axis coordiantes will get remapped to -1 <> 1 and long axis values will exceed.\n\nvec2 makeClipSpace(vec2 fragCoord, vec3 iResolution){\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 uv = vec2(fragCoord.xy / iResolution.xy); // range 0 <-> 1\n    uv = uv * 2.0 - 1.0; // center origin and remap to range -1 <-> 1\n    uv.x *= aspect_ratio; // fix stretching of the long axis making its values exceed -1 <-> 1\n    return uv;\n}\n//_____________________________________________________________________________________________\n// input1: the circle's position as a 2d coordinate of its center,\n// added as an offset after calcualtions are done from the origin (0,0)\n// input2: circle radius, if radius is 0 then its a filled circle and not a ring,\n// because all distances will be measured from the same point 'p'\n// input3: point from which wew are measuring the distance\n// output: distance from point 'p' to a circle with radius 'r' that its center is located at 'pos'\n\nfloat sdfCircle(vec2 pos, float r, vec2 p) {\n        return length(vec2(p.x - pos.x, p.y - pos.y)) - r;\n}\n//_____________________________________________________________________________________________\nvec3 drawPin(vec2 pos, float r, vec3 bg, vec3 col, vec2 uv) {\n    return mix(bg, col, step(sdfCircle(pos, r, uv), r));\n}\n//_____________________________________________________________________________________________\nvec3 invertColor(vec3 col) {\n    return vec3(1.0 - col.x, 1.0 - col.y, 1.0 - col.z);\n}\n//_____________________________________________________________________________________________\n// input1[!] [uv]: 2d vector of uv\n// input2[?] [pois]: array of length 5 containing specific points of interest, to be highlited with an opposite color\n// output: easily readable uv fragment color values for debugging\nvec4 viewUV(vec2 uv, vec2[5] pois) {\n    vec3 col = vec3(uv, 0.0);\n    // adding blue value to indicate being out of clip space bounds\n    if (uv.x < -1.0 || uv.x > 1.0) {\n        col.z += 0.5;\n    }\n    if (uv.y < -1.0 || uv.y > 1.0) {\n        col.z += 0.5;\n    }\n    vec2 poi;\n    vec3 stamp_color = invertColor(col); // highlighting with inverted colors of uv\n    float mask; // used for combining the layer of uv and the layer of poi\n    float radius = 0.05;\n    float d;\n    for (int i = 0; i < 5; i++) { // looping points of interest\n        poi = pois[i];\n        d = sdfCircle(poi, 0.0, uv); // radius 0.0 for a filled circle\n        mask = step(d, radius); // making the mask boolean ie interpolation = constant\n        col = mix(col, stamp_color, mask);\n    }\n    return vec4(col, 1.0);\n}\nvec4 viewUV(vec2 uv) {\n    return viewUV(uv, vec2[5](\n        vec2(0.0, 0.0),\n        vec2(-1.0, -1.0),\n        vec2(-1.0, 1.0),\n        vec2(1.0, -1.0),\n        vec2(1.0, 1.0)));\n}   \n//_____________________________________________________________________________________________\n// input1[!] [uv]: uv\n// input2[!] [radius]: size of glowing area\n// input3[!] [intensity]: strength of the glow\n// output: glowing amount of fragment, values in the center of glowing parts approach infinite value\n// because of the ifinite value, which will appear first, if there is any amount of glow,\n// some of is assured to be completly white\n\nfloat infiniteGlow(float uv, float radius, float intensity) {\n    return intensity * (radius / uv - radius); // substract radius so the min value is 0 and not radius\n}\n//_____________________________________________________________________________________________\n// input1[!] [uv]: uv\n// input2[!] [radius]: size of glowing area\n// input3[!] [glow]:  strength of the glow\n\nfloat glow(float uv, float radius, float glow) {\n    return pow(uv, radius) * glow;\n}\n//_____________________________________________________________________________________________\n// input1[!] [a]: first value\n// input2[!] [b]: second value\n// input3[!] [t]: mixing factor between the two values, in range 0 <> 1 \n// output: mixing result, linearly interpolated. if t=0.5 then identical to doing an average.\n// identical to using the built-in function mix(a, b, t)\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n//_____________________________________________________________________________________________\nfloat mapRange(float oldMin, float oldMax, float newMin, float newMax, float value) {\n    float relative_position = (value - oldMin) / (oldMax - oldMin); // deducted from the lerp function\n    return mix(newMin, newMax, relative_position);\n}\n//_____________________________________________________________________________________________\n// input1[!] [uv]: uv coordinate space to draw xy axes in\n// input2[?] [thickness]: thickness of the lines drawn for axes.\n// input3[?] [r]: radius of the filled circle that will be drawn at the origin (0,0)\n// output: black or white boolean value representing if current fragment is a part of axes drawing\nfloat drawAxis(vec2 uv, float thickness, float r) {\n    float v = 0.0;\n    if (uv.x >= 0.0 - thickness && uv.x <= 0.0 + thickness || uv.y >= 0.0 - thickness && uv.y <= 0.0 + thickness) {\n        v = 1.0;\n    }\n    v = mix(v, 1.0, step(sdfCircle(vec2(0.0, 0.0), r, uv), r)); // (0,0) white\n    return v;\n}\n// function overload with default values for optional parameters\nfloat drawAxis(vec2 uv) {\n    return drawAxis(uv, 0.005, 0.0);\n}\n//____________________________________________________________________________________________\n// returns distance and relative location between points\nvec2 sdfInfLine(vec2 p1, vec2 p2, vec2 uv) {\n    vec2 p3 = uv;\n    vec2 p12 = p2 - p1; // displacement vector from p1 to p2\n    vec2 p13 = p3 - p1; // displacement vector from p1 to p3\n    p12 = normalize(p12);\n    float projection = dot(p13, p12);\n    float l = distance(p1, p2);\n    float rl = projection / l; // relative length\n    vec2 p4 = mix(p1, p2, rl); // lerping to get the vector to the intersection point\n    return vec2(distance(p3, p4), rl); // distance from line\n}\n//____________________________________________________________________________________________\n//input1[!] [p1]: first point to draw line from\n//input2[!] [p2]: second point to draw line to\n//input3[!] [thickness]: thickness of the line\n//input1[?] [sm1]: brightness of the first segment of the line\n//input1[?] [sm2]: brightness of the second segment of the line\n//input1[?] [sm3]: brightness of the third segment of the line\n//input1[?] [cap]: cap shape, only has effect if a line segment is disabled\n//input1[!] [uv]: uv space to draw the line in\nfloat drawLine(vec2 p1, vec2 p2, float thickness, float sm1, float sm2, float sm3, vec2 uv) {\n    vec2 info = sdfInfLine(p1, p2, uv);\n    float d = info.x;\n    float rl = info.y;\n    float seg1 = step(rl, 0.0) * sm1; // brightness of segment connected only to p1, segments are unaffected by distance\n    float seg2 = step(rl, 1.0) * step(0.0, rl) * sm2; // brightness of segment connecting both points\n    float seg3 = step(1.0, rl) * sm3; // brightness of segment connected only to p2\n    float mask = seg1 + seg2 + seg3; // boolean hard edged mask b/w\n    return mask * step(d, thickness);\n}\nfloat drawLine(vec2 p1, vec2 p2, float thickness, vec2 uv) {\n    return drawLine(p1, p2, thickness, 0.0, 1.0, 0.0, uv);\n}\nfloat drawRoundLine(vec2 p1, vec2 p2, float thickness, vec2 uv) {\n    thickness /= 2.0;\n    vec2 info = sdfInfLine(p1, p2, uv);\n    float d = info.x;\n    float rl = info.y;\n    float seg1 = step(rl, 0.0) * 0.0; // brightness of segment connected only to p1, segments are unaffected by distance\n    float seg2 = step(rl, 1.0) * step(0.0, rl); // brightness of segment connecting both points\n    float seg3 = step(1.0, rl) * 0.0; // brightness of segment connected only to p2\n    float mask = seg1 + seg2 + seg3; // boolean hard edged mask b/w\n    mask *= step(d, thickness);\n    mask = max(mask, step(sdfCircle(p1, thickness, uv), 0.0));\n    mask = max(mask, step(sdfCircle(p2, thickness, uv), 0.0));\n    return mask;\n}","name":"Common","description":"","type":"common"}]}