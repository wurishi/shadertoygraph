{"ver":"0.1","info":{"id":"3tfGzl","date":"1557259379","viewed":116,"name":"Plane separation","username":"madware","description":"Examining the dot product as a tool to destinguish a side on which point is placed in relation to a \"plane\"","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","plane","dot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h(n) fract(sin(n)*753.5453)\n\n#define TINT_INSIDE_THE_LOOP \n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3. - 2. * f);\n\t\n    float n = p.x + p.y*157. + 113.;\n    return mix(mix( h(n+ 0.), h(n+ 1.),f.x),\n               mix( h(n+63.), h(n+64.),f.x),f.y);\n}\n\n// simple dot plotter\nfloat circle(in vec2 uv, in vec2 p, in float rad)\n{\n    vec2 puv = uv - p;;\n    return smoothstep( rad + .000001, rad - 0.000001, dot(puv, puv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get coords scaled to be in range of [0..1]\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    // This is our \"origin\" for the plane:\n    vec2 pPlane = iMouse.xy / iResolution.xy;\n    pPlane.y *= iResolution.y / iResolution.x;\n    \n    // Step 1: Fill background with neutral gray\n    vec3 col = vec3(.5, .5, .5);\n\n    // Step 2: Make a normal for the plane \n    //        (this time named \"dir\" by some reason)    \n    float a = iTime;\n    vec2 dir = vec2(cos(a), sin(a));\n\n    // Step 3: Project a vector from the plane origin \n    //         to uv coord on our normal\n    float uvPlaneProj = dot(dir, uv - pPlane);    \n    \n    // Step 3.1: Get distance to the plane and use its \n    //           threshold as a helper to draw a line \n    //           for the plane (cyan one). Distance is \n    //           just an abs from a projection (in case\n    //           of normal is normalized)    \n    float planeDist = abs(uvPlaneProj);\n    col = mix(col, \n              vec3(0.0, 1.0, 1.0), \n              smoothstep(.0025, 0.0015, planeDist) * .5);\n    \n    // Step 3.2: Determine a side for the space, be it\n    //           negative or positive. This is trivial \n    //           step, because sideness is equal to the\n    //           sign of a projection. Positive side\n    //           will be tinted in white and negative\n    //           are about to be tinted in black\n    #ifndef TINT_INSIDE_THE_LOOP\n        float side = step(uvPlaneProj, 0.0); \n        vec3 tintc = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), side);             \n    #endif  \n    \n    // Step 4: Finally, we are drawing some scattered \n    //         points and tint it to show their sideness\n    for(float i = -0.8; i < 0.8; i += 0.1)\n    {\n        for(float j = -0.8; j < 0.8; j += 0.1)\n        {\n            vec2 p = vec2(i, j);\n            vec2 p2 = (p + vec2(noise(p), noise(p.yx))) / 2.0 + vec2(.25, .125);\n                        \n            // In case of define is set we are determining if an\n            // actual point is on the specific side from a plane.\n            // In this mode points are never tinted in two colors \n            // at the same time.\n            #ifdef TINT_INSIDE_THE_LOOP\n                float proj = dot(dir, p2 - pPlane);  \n                float side = step(proj, 0.0); \n                vec3 tintc = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), side); \n            #endif\n            float plot = circle(uv, p2, 0.00002);\n            \n            col = mix(col, tintc, plot);\n        }\n    }\n    \n    // Step 5: We should not forget to draw our stuff\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}