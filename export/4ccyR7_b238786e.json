{"ver":"0.1","info":{"id":"4ccyR7","date":"1730376171","viewed":46,"name":"Computer Graphics Project 2","username":"rafakatri","description":"Moving blobs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["educational","firstshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 randomColor(vec2 st) {\n    // Generate random color components\n    vec3 color = vec3(\n        random(st + vec2(1.0, 0.0)),\n        random(st + vec2(0.0, 1.0)),\n        random(st + vec2(1.0, 1.0))\n    );\n\n    // Add a small bias to ensure the color is not close to black\n    return color * 0.65 + 0.1; // Scale to keep it above 0.3\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;    \n    \n    float ratio = iResolution.y / iResolution.x;\n    uv.x /= ratio;\n    uv *= 5.0;\n    \n    vec2 before_uv = floor(uv);\n    uv = fract(uv) - 0.5;\n    \n    // Assign a random color for each quadrant based on the before_uv\n    vec3 color = randomColor(before_uv);\n    \n    // Use step to determine clockwise or counterclockwise movement\n    float directionFactor = mix(-1.0, 1.0, step(0.5, random(before_uv)));\n    \n    // Parameters for circles\n    const int maxCircles = 3; // Maximum number of circles per quadrant\n    float k = 0.1; // Smoothing factor\n    float circle = 0.0; // Accumulated circle effect\n\n    // Loop to create multiple circles\n    for (int i = 0; i < maxCircles; i++) {\n        // Generate random radii for each circle\n        float r = 0.05 + 0.1 * random(before_uv + vec2(float(i) * 0.5, 0.5));\n        \n        // Compute the centers for circles using the original calculation and add float(i)\n        vec2 center = vec2(\n            sin(iTime * 2.0 * directionFactor * random(before_uv + float(i))) * 0.14,\n            cos(iTime * 5.6 * directionFactor * random(before_uv + float(i))) * 0.17\n        );\n\n        // Calculate the smooth circles with random radii\n        circle += smoothstep(r + k, r, length(uv - center));\n    }\n    \n    circle = smoothstep(0.2, 0.35, circle);\n    \n    // Apply the color to the circles\n    fragColor = vec4(color * circle, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}