{"ver":"0.1","info":{"id":"Nsc3Wj","date":"1630625373","viewed":252,"name":"Ray-2D-Bounces","username":"Yusef28","description":"An architecture\nShowing the normals helped a lot with the debugging.\nAs did recalling how the technique of nudging the ray out from the new ro by the normal. Learned that from shane.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["ad","autodiff","autodiff","automaticdifferentiation","dualnumbers","autodifferentiation","dn"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 02-09-2021                                  //\n// Status: On Going                                        //\n// Topic: Ray-Segment Architecture                         //\n// Sources:                                                //\n// https://rootllama.wordpress.com/2014/06/20/ray-         //\n//                  line-segment-intersection-test-in-2d/  //\n// Listening to: UFO361 - so wie wir                       //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\n\nI don't follow the proper ray-segment intersection actually\nthe goal of this is to become more familiar with ray tracing\narchitecture so I've just taken an intersection model\nI had laying around and added a proper(and basic) ray-trace \narchitecture to it. \n\nWhat I really want eventually is:\nhttps://www.shadertoy.com/view/WsBGRz\nor\nhttps://www.shadertoy.com/view/ltXBz7\n\nThe main hiccups here ended up being such small things\nlike the normal being flipped the wrong way\nand well I was drawing some things I didn't need to be \nit's when it came to adding more bounces that things\nfell apart and I was forced to question my assumptions\nabout what I had written.\n\n\nArchitecturial features/functions:\n\n- time and animation \n- draw ray\n- draw intersection point\n- scene intersections\n- bounces\n- ray trace\n- segment structure\n\nAdjustables in Common Tab:\n\n- number of rays\n- number of bounces (good with more objects)\n- number of segments (if you wan to add more segments you need\nto increase this before adding them to segmentList)\n\nPossible expansions:\n\n- materials(refractions/diffuse/lambert/roughness)\n- more objects (triangle, AABB, circle, ellipse)\n- movement (I'd love to make the segments rotate for starters)\n\n\n*/\n//objects //global hit list, just two points for one line\n\nstruct Segment{\n    vec2 A;\n    vec2 B;\n    int id;\n};\nSegment segmentList[] = Segment[Seg_N](\n    Segment(vec2(3., -3.),vec2(4., 3.), 0),\n    Segment(vec2(-5., -3.),vec2(-3., 3.), 1)\n);\n\nvec3 background_grid(vec2 st, vec2 uv){\n    vec3 col = vec3(0.1);;\n     col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    return col;\n\n}\nvec2 time_and_animation(){\n\n    float speed = 1.;\n    float time = 12.;//clamp(abs(fract(iTime*speed-0.5)-0.5)*2.,0.1,1.)*12.;\n     /*\n    float rotation_animation;\n    float rotation_animation_time = iTime*speed;\n    rotation_animation_time = mod(rotation_animation_time,12.);\n    rotation_animation_time = floor(rotation_animation_time);\n    rotation_animation_time = rotation_animation_time/12.;\n    rotation_animation_time = rotation_animation_time*pi*1.;*/\n    return vec2(time,0.);\n    }\nvec3 draw_ray(vec2 A1, vec2 B1, vec3 col, vec2 uv){\n\n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    return col;\n}\nvec3 draw_iPoint(vec3 col, vec2 pointOnLine, vec2 uv){\n\n\n    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    return col;\n}\nvec4 scene_intersections(vec2 A1, vec2 B1, inout int id){\n\n    float A,B,C,D,E,F,s,t,temp_s,temp_t;\n    vec2 pointOnLine, temp_pointOnLine;\n    \n    s = -1.;\n    t = -1.;\n    pointOnLine = vec2(0.);\n    \n    //assuming more than one line we would get \n    //a new A2 B2 each round\n    for(int i = 0; i < Seg_N; i++){\n    \n        vec2 A2 = segmentList[i].A;\n        vec2 B2 = segmentList[i].B;\n        \n        B = B2.x-A2.x;\n        A = B1.x-A1.x;\n\n        E = B2.y-A2.y;\n        D = B1.y-A1.y;\n\n        C = A1.x-A2.x;\n        F = A1.y-A2.y;\n\n        temp_s = (B*F-C*E)/(A*E-D*B);\n        temp_t = (A*F-D*C)/(A*E-D*B);\n        \n        if((temp_s >= 0. && temp_s <= 1.) && (temp_t >= 0. && temp_t <= 1.)){\n            \n            s = temp_s;\n            t = temp_t;\n            pointOnLine = vec2(A2.x + t*(B2.x-A2.x), A2.y + t*(B2.y-A2.y));   \n            id = segmentList[i].id;\n            \n        }\n        \n      }\n       \n   return vec4(s, t, pointOnLine);\n}\nvec3 bounces(vec2 bounce_ro, vec2 rd, float time, vec2 uv, vec3 col){\n\n    vec3 ray_color = line1Col;\n    for(float j = 0.; j < float(BOUNCE_N); j++){\n        \n            //time instead of t_and_a.y!\n            \n            vec2 A1 = bounce_ro;\n            vec2 B1 = bounce_ro + rd*time;\n            \n            //check all objects (just one line here)\n            int id = -1;\n            vec4 s_t_iPoint = scene_intersections(A1,B1,id);\n            \n            //get the s and t from the line calc\n            float s = s_t_iPoint.x;\n            float t = s_t_iPoint.y;\n            \n            // draw an intersection point if we hit\n            // if s and t are both between 0. and 1. they are\n            // valid for both the linear interpolations we need.\n            // so show the intersection point.\n            // if((s >= 0. && s <= 1.) && (t >= 0. && t <= 1.)){\n            // intersection\n            \n            if((s >= 0. && s <= 1.) && (t >= 0. && t <= 1.)){\n            \n                vec2 segA = segmentList[id].A;\n                vec2 segB = segmentList[id].B;\n                \n                //new ro is hit point\n                bounce_ro = s_t_iPoint.zw;\n                \n                //normal is orthogonal to the line facing left\n                vec2 n = normalize(vec2( -(segB.y-segA.y), segB.x-segA.x ));\n                \n                \n                //a good couple of hours spent here\n                //until I decided to just show the normals \n                //which I should have done from the start\n                if(dot(n,rd) <= 0.){ n = -n;}\n                n = -n;\n                \n                \n                //reflected rd is...\n                rd = reflect(rd,n);\n                \n                //use the same \"time\" variable to go back along the reflected ray\n                vec2 reflected_a = bounce_ro;\n                vec2 reflected_b = bounce_ro + rd*time;\n                \n                //draw the ray to the hit point\n                //col = draw_ray(A1, bounce_ro, col, uv);\n                float f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(A1, bounce_ro, uv)));\n                \n                col = mix(col, ray_color, f);\n                \n                //draw normal\n                f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(bounce_ro,bounce_ro + n*0.5, uv)));\n                \n                col = mix(col, vec3(0.,1.,0.5), f);\n                \n                col = draw_iPoint(col, s_t_iPoint.zw, uv);\n                \n                \n                //draw reflected way, why?\n                /*f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(reflected_a, reflected_b, uv)));\n                \n                col = mix(col, ray_color, f);\n                col = draw_iPoint(col, s_t_iPoint.zw, uv);\n                */\n                //this is so important!!!\n                bounce_ro += n*0.01;\n                ray_color = 0.5+0.5*cos(vec3(1.,2.,4.)/1. + j*300.);\n            }\n            \n            else{\n            //draw the ray \n            //col = draw_ray(A1, B1, col, uv);\n            \n            float f = 1.0-smoothstep(0.02,0.06,\n            abs(distToLine(A1, B1, uv)));\n            col = mix(col, ray_color, f);\n            \n            break;\n            }\n            \n    }\n    \n    return col;\n}\nvec3 ray_trace(vec2 uv, vec2 ro, vec3 col){\n    \n    vec2 t_and_a = time_and_animation();\n    \n    //rays\n    for(float i = 0.; i<pi; i += pi/float(RAY_N)){\n    \n        vec2 rd = vec2(1.,0.)*rot(i-pi/2.*sin(iTime/6.));\n        vec2 bounce_ro = ro;\n        //bounces\n        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);\n        }\n        \n    \n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = background_grid(st, uv);\n    //center highlights\n    \n   //the line in the scene\n   \n   for(int i = 0; i < Seg_N; i++){\n       vec2 A2 = segmentList[i].A;\n       vec2 B2 = segmentList[i].B;\n       float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A2, B2, uv)));\n       col = mix(col, vec3(1.,.3,.3), f);\n   }\n\n   vec2 ro = vec2(-1.,0.);\n    \n   col = ray_trace(uv, ro, col);\n\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    //Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159265\n#define RAY_N 24\n#define BOUNCE_N  3\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n#define Seg_N 2\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\nmat2 rot(float a){\n\n    \n    float si = sin(a);\n    float cs = cos(a);\n    return mat2(cs,-si,si,cs);\n   }   \n    \nmat2 trigless_rot(vec2 v, vec2 vr){\n    float si = length(cross(vec3(v,0.),vec3(vr,0.)));\n    float cs = dot(v,vr);\n    return mat2(cs,-si,si,cs);\n}","name":"Common","description":"","type":"common"}]}