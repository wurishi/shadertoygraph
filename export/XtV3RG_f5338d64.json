{"ver":"0.1","info":{"id":"XtV3RG","date":"1475196295","viewed":2246,"name":"Bayer Matrix Generator","username":"MartyMcFly","description":"When looking for an algorithm to compute the bayer matrix for arbitrary sizes, all I found was recursive definitions. So... here's a concise, iterative one.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["dither","algorithm","bayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Created by Pascal Gilcher 2016 \n * This creates the more or less famous bayer dither pattern, \"bayer matrix\".\n *\n * Shadertoy has an 8x8 texture version of this as standard asset, flipped vertically,\n * which corresponds to MAX_LEVEL 3.\n * The algorithm can be made shorter probably, at least it's readable.\n * \n * The resulting matrix is square with sides = 2^MAX_LEVEL\n *\n * Note that for MAX_LEVEL = 4, i.e. 16x16 matrix entries, all values from 0-255 are\n * covered, anything higher can't be represented with 8bit.\n */\n\n\n#define MAX_LEVEL 4\n/*\n//some optimizations by FabriceNeyret2, \n//I decided to keep some things expanded for imho better readability\nfloat GetBayerFromCoordLevel2(vec2 pixelpos)\n{\n\tfloat finalBayer   = 0.0;\n\tfloat finalDivisor = 0.0;\n    float layerMult\t   = 1.0;\n    \n  \tfor(float bayerLevel = float(MAX_LEVEL); bayerLevel >= 1.0; bayerLevel--)\n\t{\n\t\tfloat bayerSize \t= exp2(bayerLevel)*0.5;\n\t\tvec2 bayercoord \t= mod(floor(pixelpos.xy / bayerSize),2.0);\n\t\tlayerMult \t\t   *= 4.0;\n\t\t\n\t\tfloat line0202 = bayercoord.x*2.0;\n\n\t\tfinalBayer += mix(line0202,3.0 - line0202,bayercoord.y) / 3.0 * layerMult;\n\t\tfinalDivisor += layerMult;\n\t}\n\n\treturn finalBayer / finalDivisor;\n}\n\n*/\n#define bayer2x2(a) (4-(a).x-((a).y<<1))%4\n\n//some more optimizations, using bitwise ops\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{\n    ivec2 ppos = ivec2(pixelpos);\n    int sum = 0;\n    for(int i=0; i<MAX_LEVEL; i++)\n        sum += bayer2x2(ppos>>(MAX_LEVEL-1-i)&1)<<(2*i); \n    return float(sum) / float(2<<(MAX_LEVEL*2-1));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //align matrix with window\n    uv =floor(uv*exp2(float(MAX_LEVEL)));\n    \n    float bayerPattern = GetBayerFromCoordLevel(uv.xy);\n    \n\tfragColor = vec4(bayerPattern);\n}","name":"Image","description":"","type":"image"}]}