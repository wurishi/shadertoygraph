{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nmat2 rot2D(float theta)\n{\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// convert from pixel space to homogenous coordinate (-1 to 1 on each axis)\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\n    mat2 mRot = rot2D(iTime);\n    \n\t// define ray (we cast outward from the center, perspective)\n\t// ** fiddle with this to alter your view (or camera, if you will) **\n\tvec3 origin = vec3(0.0, 0.0, 0.0);\n\tvec3 direction = vec3(p.x, p.y, 1.0);\n    direction.xy *= mRot; // rotate around Z\n\tnormalize(direction);\n\n\t// define plane (by a normal and a distance to from center)\n\t// this one faces us directly (on Z-axis) and is almost right in front\n\tvec3 normal = vec3(0.0, 0.0, -1.0);\n\tfloat dist = 2. + sin(iTime);\n\n\t// what we want to know is the intersection point:\n\t// - a plane equation looks like this: ax+bx+cz + d = 0\n\t// - we can substitute a, b and c for the plane's normal and d for the distance (dist)\n\t// - that leaves us with unknown x, y and z which is the intersection point\n   \n\t// we need to solve this:\n\t// the point can be expressed as: intersection = origin + t*direction\n\t// since we already know 2 of those, that leaves us with finding t\n\t\n\t// to find t (skipping the process of solving, Google and do it manually or use Matlab):\n\tfloat denominator = dot(direction, normal);\n\tif (abs(denominator) > 0.001) // if it's practically zero, we did not hit it! (*)\n\t{\n\t\tfloat t = (dot(origin, normal) + dist) / denominator;\n\t\n\t\t// and now we can calculate the intersection point like described above:\n\t\tvec3 hit = origin + t*direction;\n\t\n\t\t// mapping this to meaningful 2D UVs depends on the plane\n\t\t// we use X and Y as we intersect with Z, if the plane normal were 0,1,0 we'd use X and Z\n\t\tvec2 uv = hit.xy;\n\t\tfragColor = texture(iChannel0, uv);\n\t}\n\telse\n\t{\n\t\t// no intersection\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t}\n\t\n\t// now, how to run this on older hardware?\n\t// - the intersection check (*) is usually not necessary, so don't bother\n\t// - a lot of values are fixed to 0, 1 and -1 so they cancel out a *lot* of operations\n\t//   (note that fiddling with for ex. your plane or origin may change things)\n\t// - all the \"obvious\" optimizations for those platforms, I did this in assembly on a 486DX PC with\n\t//   a rotating camera, depth (t) shading et cetera\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtX3zS","date":"1422889439","viewed":1225,"name":"Plane intersect","username":"superplek","description":"Wrote this small explanation a long while back. Needed it again, so what place better to touch it up than here?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing3d2d"],"hasliked":0,"parentid":"","parentname":""}}