{"ver":"0.1","info":{"id":"7dfyDl","date":"1642889674","viewed":198,"name":"Scene w/ AA, MB, Bloom","username":"Hatchling","description":"Template for creating a scene with spatial and temporal super sampling, plus bloom for HDR and Bayer pattern filtering","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["motionblur","template","aa"],"hasliked":0,"parentid":"sdfcWl","parentname":"[Template] Scene w/ AA and MB"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Taken from https://www.shadertoy.com/view/tdjyzz\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 pixelSize = 1.5/iResolution.xy;\n    \n    vec2 right = vec2(pixelSize.x, 0);\n    vec2 up = vec2(0, pixelSize.y);\n\n    // Input linear image + bloom.\n    vec3 colorC = texture(iChannel0, uv).rgb;\n    \n    vec3 colorT = textureLod(iChannel0, uv + up, 0.5).rgb;\n    vec3 colorB = textureLod(iChannel0, uv - up, 0.5).rgb;\n    vec3 colorL = textureLod(iChannel0, uv - right, 0.5).rgb;\n    vec3 colorR = textureLod(iChannel0, uv + right, 0.5).rgb;\n    \n    right *= 2.0;\n    up *= 2.0;\n    \n    vec3 colorTR = textureLod(iChannel0, uv + up + right, 1.5).rgb;\n    vec3 colorTL = textureLod(iChannel0, uv + up - right, 1.5).rgb;\n    vec3 colorBR = textureLod(iChannel0, uv - up + right, 1.5).rgb;\n    vec3 colorBL = textureLod(iChannel0, uv - up - right, 1.5).rgb;\n        \n        \n    vec3 color = colorC + (colorT + colorB + colorL + colorR) * 0.125 + (colorTR + colorTL + colorBR + colorBL) * 0.0625;    \n    //color = (colorT + colorB + colorL + colorR) * 0.03;   \n    //color = (colorTR + colorTL + colorBR + colorBL) * 0.01;    \n\n    // Tonemap \n    float lum = rbgToluminance(color);\n    color += vec3(lum * 0.01); // Allow colors to whiten when saturated.\n    color = color / (0.5 + mix(vec3(lum), color, 0.95));\n    \n    // Convert to gamma.\n\tcolor = pow(color, vec3(1.0/2.2));\n    \n\tfragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 scene(float time, vec2 uv)\n{\n    time *= 5.;\n    float blend = time - floor(time);\n    uint hash1 = uint(floor((time+1.)));\n    uint hash2 = uint(floor((time)));\n    \n    \n    vec2 offset1 = vec2(RandomFloat01(hash1), RandomFloat01(hash1));\n    vec2 offset2 = vec2(RandomFloat01(hash2), RandomFloat01(hash2));\n\n    float scale1 = 2.0 * pow(5., blend-1.);\n    float scale2 = 2.0 * pow(5., blend);\n\n   // uv = uv * 2.0 - 1.0;\n    \n   // uv = atanh(uv);\n\n    vec2 olduv = uv;\n    uv.x += sin(olduv.y * 2. + time* 0.200) * 0.5;\n    uv.y -= sin(olduv.x * 2. + time* 0.161) * 0.2;\n    olduv = uv;\n    uv.x += sin(olduv.y * 2. + time* 0.161) * 0.2;\n    uv.y -= sin(olduv.x * 2. + time* 0.200) * 0.5;\n    \n   // uv = tanh(uv);\n    \n  // uv = uv * 0.5 + 0.5;\n     \n    vec2 uv1 = uv / scale1;\n    vec2 uv2 = uv / scale2;\n    \n    uv1 += offset1;\n    uv2 += offset2;\n    \n  /*  olduv = uv1;\n    uv1.x += sin(olduv.y * 2. + time* 0.200) * 0.5;\n    uv1.y -= sin(olduv.x * 2. + time* 0.161) * 0.2;\n    olduv = uv1;\n    uv1.x += sin(olduv.y * 2. + time* 0.161) * 0.2;\n    uv1.y -= sin(olduv.x * 2. + time* 0.200) * 0.5;\n    \n    olduv = uv2;\n    uv2.x += sin(olduv.y * 2. + time* 0.200) * 0.5;\n    uv2.y -= sin(olduv.x * 2. + time* 0.161) * 0.2;\n    olduv = uv2;\n    uv2.x += sin(olduv.y * 2. + time* 0.161) * 0.5;\n    uv2.y -= sin(olduv.x * 2. + time* 0.200) * 0.1;*/\n    \n    vec3 c1 = pow(texture(iChannel0, uv1).rgb, vec3(10.2));\n    vec3 c2 = pow(texture(iChannel0, uv2).rgb, vec3(10.2));\n    \n    // Fake an HDR texture.\n    c1 = atanh(c1 * 0.99999) * 8.;//c1 * 0.5 + pow(c1, vec3(4)) * 5.;\n    c2 = atanh(c2 * 0.99999) * 8.;//c2 * 0.5 + pow(c2, vec3(4)) * 5.;\n    \n    vec3 c = mix(c2, c1, blend);\n    \n   \n    \n    return c;//pow(max(vec3(0),c), vec3(2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \nuint rngState = uint\n    (\n        uint(iFrame) * uint(1973)\n    ) | uint(1);\n    // For aspect corrected UV's use the following calculation: \n    \n    float s = min(iResolution.x, iResolution.y);\n   \tvec2 uv = (2.*fragCoord.xy - vec2(iResolution.xy)) / s;\n    \n    \n    // For UVs sampling from textures use the following calculation:\n    // vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    mat2 jitter;\n    jitter[0] = dFdx(uv);\n    jitter[1] = dFdy(uv);\n    \n    vec4 blueNoise0 = sampleBlueNoise(iChannel1, fragCoord, rngState);\n    blueNoise0.xy = uniform01ToGauss(blueNoise0.xy);\n    blueNoise0.zw = uniform01ToGauss(blueNoise0.zw);\n    vec4 blueNoise1 = sampleBlueNoise(iChannel1, fragCoord, rngState);\n    blueNoise1.xy = uniform01ToGauss(blueNoise1.xy);\n    blueNoise1.zw = uniform01ToGauss(blueNoise1.zw);\n    vec4 blueNoise2 = sampleBlueNoise(iChannel1, fragCoord, rngState);\n    blueNoise2.xy = uniform01ToGauss(blueNoise2.xy);\n    blueNoise2.zw = uniform01ToGauss(blueNoise2.zw);\n    \n    blueNoise0 *= iTimeDelta * 1.0;\n    blueNoise1 *= iTimeDelta * 1.0;\n    blueNoise2 *= iTimeDelta * 1.0;\n\n    //aa and motion blur\n    //float dt = iTimeDelta;//1./60.;\n    float t = iTime;\n    vec3 c \n        = scene(t+blueNoise0.x,                    uv)\n        + scene(t+blueNoise0.y, uv+jitter*vec2( 0.707,  0.00  ))\n        + scene(t+blueNoise0.z, uv+jitter*vec2(-0.707,  0.00  ))\n        + scene(t+blueNoise0.w, uv+jitter*vec2( 0.00,  0.707))\n        + scene(t+blueNoise1.x, uv+jitter*vec2( 0.00, -0.707))\n        + scene(t+blueNoise1.y, uv+jitter*vec2( 0.50,  0.50))\n        + scene(t+blueNoise1.z, uv+jitter*vec2(-0.50,  0.50))\n        + scene(t+blueNoise1.w, uv+jitter*vec2(-0.50, -0.50))\n        + scene(t+blueNoise2.x, uv+jitter*vec2( 0.50, -0.50));\n        \n    c /= 9.;\n    \n    fragColor = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}","name":"Common","description":"","type":"common"}]}