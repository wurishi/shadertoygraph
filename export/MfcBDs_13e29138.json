{"ver":"0.1","info":{"id":"MfcBDs","date":"1733621137","viewed":17,"name":"Growing phyllotactic spiral","username":"stegu","description":"Minimal code with no frills, showcasing my \"inversePF\" function and its use for smooth animated \"growth\".\nThe shader runs in constant time, and up to 1e6 points are handled without glitches. The algorithm is limited only by numerical precision.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spiral","animation","fibonacci","growth","phyllotactic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Find nearest neighbor in an N-point Fibonacci spiral,\n// not scaled to fit in the unit circle but growing\n// with N to a radius of ~sqrt(N) around the origin.\n// Modified version of the algorithm from the article\n// \"Spherical Fibonacci Mapping\" by Keinert et al,\n// ACM Trans. on Graphics 34 (2015), 6, 193.\n// Ported from HLSL to GLSL by Stefan Gustavson 2021,\n// edited for planar mapping and modified for animation\n// by Stefan Gustavson 2022. I'm not sure if this has been\n// done before as an inverse mapping. I couldn't find a\n// reference for it, so I did it myself.\n//\n// This version is Copyright 2022 Stefan Gustavson, released\n// under the terms of the MIT license (\"use freely with\n// credit\"): https://opensource.org/licenses/MIT\n// \n// The vec3 return value has the absolute position of the\n// nearest feature point in .xy, and its integer index (k)\n// in .z.\n// A gradual blend between configurations with N and N+1\n// points can be achieved by calling the function with\n// intN = floor(t), fracN = fract(t), N <= t < N+1.\n// Indices are numbered from 0 up outwards from the origin.\n// If you want the index to \"follow\" a point as it \"moves\n// outwards\" with an animated N \"growth\", the index needs\n// to be recomputed as (intN - k).\n//\n// The searched point set is not actually limited to N\n// points -- the point returned is the nearest neighbor\n// on the infinite plane, with k as large as it takes.\n// Mask on k if you want to limit the number of cells\n// that are displayed.\n//\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n#define Phi 0.618033988749895\n\n#if 0\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * Phi - floor(k * Phi);\n}\n#else\n// For some reason, this version of fracmodphi bugged out on some\n// platforms that claim to have integer support, apparently because\n// the % operator doesn't work according to spec for negative dividends.\n// My ugly fix was to add a large multiple of q after the conversion:\n// int n = int(k) + (q<<6);  // (Note the parentheses, they are required!)\n// This pushes the bug to after 64*q = 2967552 sheep have appeared, while\n// maintaining enough accuracy for positioning the dots at the center.\n// This is a hack. Negative k should not be a problem - it's an annoying\n// bug with some GLSL implementations.\nfloat fracmodphi(float k) {\n    // Thanks to @mla for this more predictable version,\n    // invoking the angelic powers of integer arithmetic.\n    // 1) Realize that fract(n*p/q) = ((n*p)%q)/q = (((n%q)*p)%q)/q\n    // 2) Use F23/F24 as a rational approximation of (sqrt(5)-1)/2\n    int p = 28657, q = 46368;\n    int n = int(k) + (q<<6); // The % operator can be bugged for n<0\n    return float(n%q*p%q)/float(q);\n}\n#endif\n\nvec3 inversePF(vec2 p, float intN, float fractN) {\n\tvec3 nn;\n\tfloat theta = min(atan(p.y, p.x), PI); // min() to dodge NaN\n\tfloat r2 = dot(p,p);\n    float i = max(0.0, r2-0.5+fractN);\n    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*PI*(i+0.5))/2.0/log(PHI)));\n\t// F0, F1 are actually faster to compute with pow()\n\t// than by using an array of precomputed values\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n    float B0 = fracmodphi(F0);\n    B0 = (B0 > 0.62) ? B0-1.0 : B0;\n    float B1 = fracmodphi(F1);\n    B1 = (B1 > 0.62) ? B1-1.0 : B1;\n\tmat2 B = mat2(2.0*PI*B0, F0,  // Note how simple this B is, compared to\n                  2.0*PI*B1, F1); // the spherical mapping in the reference\n\tmat2 invB = inverse(B);\n    float ctheta = theta + 2.0*PI*fracmodphi(intN);\n    float ci = i + 0.5 + fractN;\n    vec2 c = floor(invB * vec2(ctheta, ci));\n\tfloat dsqmin = 4.0; // Actual min dsq is always less than this\n    float r, dsq;\n    vec2 q;\n\tfor (float i1 = 0.0; i1 < 2.0; i1++) { // Explicit nested loops instead\n        for(float i0 = 0.0; i0 < 2.0; i0++) { // of Keinert's single loop\n            i = dot(vec2(F0, F1), vec2(i0, i1) + c); // (0,0),(1,0),(0,1),(1,1)\n            i = abs(i); // abs() eliminates some misses near the origin\n            theta = 2.0*PI*fracmodphi(i-intN); // Set theta=0 at index intN\n            r = sqrt(i+0.5+fractN);\n            q = vec2(cos(theta)*r, sin(theta)*r);\n            dsq = dot(p-q, p-q); // Most numerically sound measure\n            if (dsq < dsqmin) {\n                dsqmin = dsq;\n                nn.xy = q;\n                nn.z = i;\n            }\n        }\n    }\n    // The algorithm finds the closest point in the set for fracN=0,\n    // but it has a few glitches close to some Voronoi boundaries\n    // near the origin, where points move around a lot with fracN.\n    // The most blatant error is that we sometimes miss cell 0\n    // near the origin. Let's fix that, because it encroaches on\n    // the useful circular portion of cell 0, but leave the rest.\n    // (Straightening out the loop above and just adding this at\n    // the end would make it less of a \"repeated code\" boo-boo,\n    // but GLSL compilers inline almost everything anyway.)\n    if(r2 < 3.0) {\n        theta = 2.0*PI*fracmodphi(0.0-intN);\n\t\tr = sqrt(0.0+0.5+fractN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q);\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = 0.0;\n\t\t}\n    }\n    return nn;\n}\n\n// Anti-aliased step function\nfloat aastep(float a, float x) {\n    float fw = 0.5*fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\n// Make a kind-of-random RGB color from a modulo-520 integer ID.\n// (520 = 5*8*13, three Fibonacci numbers, which emphasizes some spirals)\nvec3 rgbh(float h) {\n    h = mod(h, 520.0);\n    return vec3(1.0-mod(h,5.0)/8.0, 0.9-mod(h,40.0)/64.0, 1.0-h/520.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Number of points. Fractional values allowed. Up to 1e6 points are fine.\n    // Above that, numerical precision issues start messing with the results.\n    float N = iTime*20.0;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.x * max(16.0, sqrt(N));\n    \n    vec3 nn = inversePF(uv, floor(N), fract(N));\n    \n    float dots = aastep(0.5, length(uv-nn.xy)); // Dots around each point\n    float mask = step(floor(N), nn.z-1.0); // Mask out cells where i>N\n\n    // Because of how N and the point index k are handled, an index that\n    // \"stays with a point\" during the animation is N-k rather than k.\n    // Index k=0 from the function is always the point closest to the center.\n    vec3 col = (1.0-dots)*(1.0-mask) * rgbh(floor(N)-nn.z);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}