{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// ÑÐ´ÐµÐ»Ð°Ð½Ð¾ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ https://www.shadertoy.com/view/4sfGzj\nconst int MAX_ITER = 55;\n//-------------------------------------------\n#define time iTime\n\n//--------------------------------------------------\n// Ð’Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ - Ð¿ÐµÑ€ÐµÑÑ‡ÐµÑ‚ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹\n//--------------------------------------------------\nvec3 rotationCoord(vec3 n, float paramRotate)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   if(paramRotate <= 0.1)\n   {\n\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0,  1.0,  0.0,\n                      0.0,  0.0,  1.0);   \n   }\n   else if(paramRotate <= 1.0)\n   {\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0, sc.y,-sc.x,\n                      0.0, sc.x, sc.y);\n   }\n   else if(paramRotate <= 2.0)\n   {\n       rotate = mat3(  1.0,  0.0,  0.0,\n                       0.0, sc.y,sc.x,\n                       0.0, -sc.x, sc.y);  \n   }\n   else if (paramRotate <= 3.0)\n   {\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n   }\n   else if (paramRotate <= 4.0)\n   {\n      rotate = mat3( sc.y,  0.0, sc.x,\n                     0.0,   1.0,  0.0,\n                    -sc.x,  0.0, sc.y);   \n   }   \n   else if (paramRotate <= 5.0)\n   {\n       rotate = mat3( sc.y,sc.x,  0.0,\n                     -sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }   \n   else if (paramRotate <= 6.0)\n   {\n       rotate = mat3( sc.y,-sc.x, 0.0,\n                      sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }     \n   else\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   //sc = vec2(sin(t), cos(t));\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n  // sc = vec2(sin(t), cos(t));\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//-------------------------------------------------- ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ñ†Ð²ÐµÑ‚Ð° Ñ‡Ð°ÑÑ‚ÐµÐ¹ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nvec3 getmaterial(vec3 p, float mat)\n{\n   vec3 p1 = rotationCoord(p, 7.);\n    \n    if (mat < 0.5)\n      return vec3(0.4662, 0.4565, 0.4488);\n   else if (mat < 1.5)\n      return vec3(0, 0, 0);   \n   else if (mat < 2.5)\n      return vec3(floor(length(floor(mod(p1, 2.0)+0.5))-0.5));\n   else if (mat < 3.5)\n      return vec3(0.8392, 0.0629,1.0);\n   else if (mat < 4.5)\n      return vec3(0.6289, 0.7216, 1.0);  \n   return vec3(0.3, 0.9,0.5);\n}\n//--------------------------------------------------Ð¡ÐºÑ€ÑƒÐ³Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ñ†ÐµÐ»Ð¸Ð½Ð´Ñ€\n// capsule in Y axis\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n//--------------------------------------------------ÐšÐ¾Ð½ÑƒÑ\nfloat dist_cone( vec3 p, float r, float h )\n{\n   vec2 c = normalize( vec2( h, r ) );\n    float q = length(p.xy);\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\n}\n//--------------------------------------------------\nfloat disttube(vec2 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------Ð¨Ð°Ñ€\nfloat distsphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------Ð¢Ð¾Ñ€\nfloat disttorus(vec3 p, vec2 t)\n{\n   vec2 q = vec2(length(p.xz) - t.x, p.y);\n   return length(q) - t.y;\n}\n//----------------------------------------------------ÐšÑƒÐ±\nfloat distbox(vec3 p, vec3 b)\n{\n   return length(max(abs(p) - b, 0.0));\n}\n//----------------------------------------------------Ð’Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ Ð´ÐµÑ‚Ð°Ð»Ð¸\nvec2 rotate(vec2 v, float a) {\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n//----------------------------------------------------\n\nvec2 astronaut(vec3 p)\n{\n   float material = 0.;\n //  p.y -= tmpY;    // Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð²ÑÐµÐ³Ð¾ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð¿Ð¾ Y   \n   vec3 r1 = vec3(rotate(p.xz, 0.1), p.y); // Ð¢ÑƒÑ‚ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¾Ñ‚Ñ€ÐµÐ³ÑƒÐ»Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð½Ð°ÐºÐ»Ð¾Ð½\n   vec3 pAbs = p;\n   // Ð·ÐµÑ€ÐºÐ°Ð»Ð¾\n   pAbs.x = abs(pAbs.x);\n   float d = 1.;\n\n   // head Ð³Ð¾Ð»Ð¾Ð²Ð°\n //  d = min(d, distsphere(p * tmpSize + tmpOffset, tmpRadius));\n   d = min(d, distsphere(p * vec3(1.0) + vec3(0.0, 2.5, 0.0), 1.));\n   float maska =   min(d, distsphere(p * vec3(1.2, 2.0, 1.8) + vec3(0, 4.7, -1.), 1.));\n   // body Ñ‚ÐµÐ»Ð¾\n   d = min(d, distsphere(p * vec3(1.1, 0.5, 1.1) + vec3(0, 0.2, 0), 1.0));   \n   // arms Ñ€ÑƒÐºÐ¸\n   d = min(d, distsphere(pAbs * vec3(1.8, 1.2, 1.8) + vec3(-1.3, 0.7, 0), 1.0));\n   float arms = min(d, distsphere(pAbs * vec3(1.9, -3.2, 1.9) + vec3(-1.0, 0.5, -0.4), 1.0)/1.6);   \n   // feet Ð½Ð¾Ð³Ð¸\n   d = min(d, distsphere(pAbs * vec3(1.8, -0.6, 1.8) + vec3(-0.8, 0.9, 0), 1.0));\n   float feet = min(d, distsphere(pAbs * vec3(3.0, -3., 1.6) + vec3(-1.4, 9.0, -0.5), 1.0)/1.6);\n   //Ð ÑŽÐºÐ·Ð°Ðº\n   float baul = min(d, max(distbox(p + vec3(0, 0.8, 0.9), vec3(0.6)), \n                  disttorus(p.yzx + vec3(1.0, 1.4, 0), vec2(0.4, 0.8))));\n    // Ð¢Ñ€ÑƒÐ±ÐºÐ¸\n    float trubka =  min(d, max(distbox(p + vec3(0, 2.0, 0.9), vec3(0.7)), \n                  disttorus(pAbs.yzx + vec3(1.0, 1.4, 0.5), vec2(1.0, 0.1)))); \n   trubka = min(trubka, max(distsphere(r1 + vec3(0.9, 0.4, 1.6), 1.3), \n                  disttube(r1.xz + vec2(0.1, 1.85), 0.1)));    \n   \n\n   if (maska < d) material = 4.0; \n   else if (baul < d) material = 4.0;\n   else if(trubka < d) material = 4.0; \n   else if(arms < d) material = 0.0;\n   else if (feet < d)material = 0.0;\n   else material = 3.0;\n   \n   d = min(d, maska); \n   d = min(d, baul); \n   d = min(d, trubka);        \n   d = min(d, arms);  \n   d = min(d, feet);     \n   return vec2(d, material);\n}\n//--------------------------------------------------\n//----------------------------------------------------\nvec2 rocket(vec3 p)      \n{\n   p.y = 1.- p.y + 0.5;\n   float material = 3.0;\n   float korpus = 1., sopla = 1.;\n   vec3 r1 = vec3(rotate(p.xz, 0.), p.y);    float d = 1.;\n   d =   min(d, capsuleY( p -  vec3(0, 1., 0.0), 0.9, 2.3));     \n   korpus = min(d, distbox(p -  vec3(0, 1.7, 0.0), vec3(0.75, 2.0, 0.75))); \n   korpus =   min(korpus, dist_cone(   r1 + vec3(0.0, 0., -5.5) , 0.9, 1.9 ));   \n\n vec3 pos = r1;\n pos.y = abs(pos.y); \n korpus =  min(korpus, dist_cone( pos + vec3(0.50, -0.55, 0.0) , 0.5, 1.4 ));   \n korpus =  min(korpus, dist_cone( pos + vec3(-0.50, -0.55, 0.0) , 0.5, 1.4 ));   \n \n  p.z = abs(p.z);\n  korpus =   min(korpus, distsphere(p + vec3(0.00, -2.7, -0.5), 0.55));   \n  korpus =   min(korpus, distsphere(p + vec3(0.00, -1.5, -0.5), 0.55));  \n  //--------------------------------\n  if(korpus < d)material = 4.0; \n  if(sopla < d)material = 3.0; \n  d = min(d, korpus); \n   return vec2(d, material);\n\n}\n//--------------------------------------------------\nvec2 station(vec3 p)     \n{\n\n   vec3 r1 = vec3(rotate(p.xz, 1.55), p.y); \n   float material = 2.;\n   float korpus = 1.;\n   float d = 1.;\n   korpus = disttorus(p.zxy  * vec3(1.06, -0.42, 1.), vec2(2.5, 0.2));\n   korpus = min(korpus, disttorus(p.yzx * vec3(1.06, -0.42, 1.) , vec2(2.5, 0.2))); \n   korpus = min(korpus, disttorus(p  * vec3(1.06, -0.42, 1.), vec2(2.5, 0.2))); \n  d = min(d, distsphere(p  , 2.0));     \n  d = min(d, distsphere(p - vec3(0.0, -2.5, 0.0) , 0.5));\n\n  vec3 pAbs = p;\n  pAbs.x = abs(pAbs.x); \n  d = min(d, distsphere(pAbs - vec3(2.5, 0.0, 0.0) , 0.4));\n\n  pAbs = r1;\n  pAbs.x = abs(pAbs.x);\n  d = min(d, distsphere(pAbs - vec3(2.5, 0.0, 0.0) , 0.4)); \n  //--------------------------------\n  if(korpus < d)material = 4.0; \n  d = min(d, korpus); \n  return vec2(d, material);\n\n}\n\n//-------------------------------------------------\n// Ð¡ÐºÑ€ÑƒÐ³Ð»ÐµÐ½Ð½Ñ‹Ð¹ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚\nfloat lengthN(vec3 v, float n)\n{\n  vec3 tmp = pow(abs(v), vec3(n));\n  return pow(tmp.x+tmp.y+tmp.z, 1.0/n);\n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nvec2 renderFunction(vec3 pos)\n{\n  vec3 pos1 = pos; \n pos1 = rotationCoord(pos, 3.0);      // ÐŸÐµÑ€ÐµÑÑ‡ÐµÑ‚ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚ Ð´Ð»Ñ Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ñ\n vec2 result;\n vec2 astr =  astronaut(pos1);\n\n pos1 = rotationCoord(pos, 2.0); \n pos1.x -= 8.5;\n vec2 roket = rocket(pos1);\n \n pos1 = rotationCoord(pos, 7.0);  \n pos1.x += 4.0;  \n vec2 stat = station(pos1);\n\n  result = (astr.x < roket.x) ? astr : roket;\n  result = (result.x < stat.x) ? result : stat;\n  return result;\n\n\n}\n//-------------------------------------------------\nvec3 getNormal(vec3 p)\n{\n  const float d = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        renderFunction(p+vec3(d,0.0,0.0)).x - renderFunction(p+vec3(-d,0.0,0.0)).x,\n        renderFunction(p+vec3(0.0,d,0.0)).x - renderFunction(p+vec3(0.0,-d,0.0)).x,\n        renderFunction(p+vec3(0.0,0.0,d)).x - renderFunction(p+vec3(0.0,0.0,-d)).x\n      )\n    );\n}\n//-------------------------------------------------\nvec3 getlighting(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   float b = max(0.0, dot(normal, lightDir));\n   return b * color;\n}\n//-------------------------------------------------\nvec3 getlightingPhong(in vec3 pos,in vec3 camPos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   vec3  specColor = vec3(0.2126, 0.9023, 0.2128);\n   float specPower = 12.0;\n    \n    vec3   l = normalize (lightDir-pos);                  \n    vec3   v = normalize(camPos-pos);\n    vec3   n = normalize (normal); \n    vec3   r = reflect ( -l, n ); \n    vec3 diff = color * max ( dot ( n, l ), 0.0 );\n    vec3 spec = specColor * pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    \n    return diff + spec;\n}\n//-------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos =   ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n  pos.y = 1.0 - pos.y - 1.0;\n  \n  vec3 camPos =  vec3(0.0, 0.0, 9.0);\n  vec3 camDir = vec3(0.0, 0.0, -1.0);\n  vec3 camUp = vec3(0.0, 1.0, 0.0);  \n  vec3 camSide = cross(camDir, camUp);\n  float focus = 1.8;//1.8\n \n  vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir/* *focus*/);\n \n  float t = 0.0;\n  vec2 object = vec2(1., 1.);\n//------------------------------\n\n  vec3 posOnRay = camPos;\n//------------------------------ \n  for(int i=0; i<MAX_ITER; ++i)\n  {\n\n    object = renderFunction(posOnRay);\n    t += object.x;\n    posOnRay = camPos + t*rayDir;    \n  }\n//------------------------------ \n\n  if(abs(object.x) < 0.01)\n  {\n    vec3 materialColor = getmaterial(posOnRay.xyz, object.y); \n    vec3 normal = getNormal(posOnRay);                        \n  //  vec3 lightDir = -rayDir;\n  //  vec3 color = getlighting(posOnRay.xyz, normal, lightDir, materialColor);  \n\n  vec3 lightDir =  vec3(5.0, 0.0, 4.0);\n  vec3 color = getlightingPhong(posOnRay, camPos, normal, lightDir, materialColor); // ÐŸÐ¾ Ð¤Ð¾Ð½Ð³Ñƒ   \n  \n  fragColor = vec4(color, 1.0);\n  }else\n  {\n   fragColor = vec4(0.5);// \n  }\n}\n  \n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Ms2SWc","date":"1416797598","viewed":208,"name":"My astronaut","username":"Lio","description":"my first attempt to create an object","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tagsprocedural"],"hasliked":0,"parentid":"","parentname":""}}