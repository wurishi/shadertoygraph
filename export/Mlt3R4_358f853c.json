{"ver":"0.1","info":{"id":"Mlt3R4","date":"1468222592","viewed":376,"name":"Neighbors","username":"AmazingThew","description":"Lots of ways this could be made more efficient but whatever dude computers are fast","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["2d","generative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspired by a diagram in this article on Build Engine's software rendering: http://fabiensanglard.net/duke3d/build_engine_internals.php\n//Initial circle grid adapted from here: http://webstaff.itn.liu.se/~stegu/webglshadertutorial/shadertutorial.html\n//Uses Brian Sharpe's Wombat code for simplex noise: https://github.com/BrianSharpe/Wombat\n\nconst float samples = 4.0; //Square this number to get supersample level\nconst float cells = 50.0;\nconst float noiseScale = 15.0;\nconst float angle = -1.0;\nconst mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\nconst float hRange = 0.5;\nconst float vRange = 1.0 - hRange;\nconst float radius = 0.6;\nconst float shift = 0.47;\nconst float speed = 0.2;\n\nconst vec4 bgColor = vec4(0.04, 0.07, 0.12, 1.0);\nconst vec4 hColor = vec4(0.43, 0.15, 0.24, 1.0);\nconst vec4 vColor = vec4(0.18, 0.29, 0.37, 1.0);\n\nfloat SimplexPerlin3D( vec3 P );\n\nfloat getNoise(vec2 pos) {\n    float noiseZ = iTime * speed;\n    float noise = SimplexPerlin3D(vec3(pos, noiseZ)) * 0.5 + 0.5;\n    float gradient = (pos * rot).y / noiseScale + shift; //set to 0 to visualize noise\n    \n    return clamp(noise+gradient, 0.0, 1.0);\n}\n\nvec4 samplePixel(vec2 uv) {\n    vec2 nearest = 2.0*fract(cells * uv) - 1.0;\n    float dist = length(nearest);\n    \n    float circle = 1.0 - step(radius, dist);\n    float left   = mix(step(0.0, -nearest.x), 0.0, step(radius, abs(nearest.y)));\n    float right  = mix(step(0.0,  nearest.x), 0.0, step(radius, abs(nearest.y)));\n    float top    = mix(step(0.0,  nearest.y), 0.0, step(radius, abs(nearest.x)));\n    float bottom = mix(step(0.0, -nearest.y), 0.0, step(radius, abs(nearest.x)));\n    \n    \n    vec2 point = floor(uv * cells) / cells;\n    vec2 lPoint = point - vec2(1.0/cells, 0.0);\n    vec2 rPoint = point + vec2(1.0/cells, 0.0);\n    vec2 tPoint = point + vec2(0.0, 1.0/cells);\n    vec2 bPoint = point - vec2(0.0, 1.0/cells);\n    point  *= noiseScale;\n    lPoint *= noiseScale;\n    rPoint *= noiseScale;\n    tPoint *= noiseScale;\n    bPoint *= noiseScale;\n    \n    float noise  = getNoise(point);\n    float lNoise = getNoise(lPoint);\n    float rNoise = getNoise(rPoint);\n    float tNoise = getNoise(tPoint);\n    float bNoise = getNoise(bPoint);\n    \n    float hShape = clamp(\n        circle +\n        mix(left,  0.0, step(hRange, 1.0 - lNoise)) +\n        mix(right, 0.0, step(hRange, 1.0 - rNoise)),\n        0.0, 1.0);\n    \n    float vShape = clamp(\n        circle +\n        mix(top,    0.0, step(vRange, tNoise)) +\n        mix(bottom, 0.0, step(vRange, bNoise)),\n        0.0, 1.0);\n    \n    float vMap = mix(vShape, 0.0, step(vRange, noise));\n    float hMap = mix(hShape, 0.0, step(hRange, 1.0 - noise));\n    \n    return mix(mix(bgColor, hColor, hMap), vColor, vMap);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    float off = 1.0 / samples / iResolution.x;\n    vec4 sum = vec4(0.0);\n    for (float x=0.0; x<samples-0.01; x+=1.0) {\n        for (float y=0.0; y<samples-0.01; y+=1.0) {\n            sum += samplePixel(pos + vec2(off*x, off*y));\n        }\n    }\n    return sum / (samples * samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    uv *= rot;\n    fragColor = vec4(vec3(superSamplePixel(uv)), 1.0);\n}\n\n\n\n\n\n\n\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson's and Ian McEwan's work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat SimplexPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}\n","name":"Image","description":"","type":"image"}]}