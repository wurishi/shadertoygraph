{"ver":"0.1","info":{"id":"WdycR1","date":"1602729010","viewed":112,"name":"Michael Bowen Lab 6","username":"mbowen","description":"Lab 6","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["lab6"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n//  -> IMAGE TAB (final)\n\n//------------------------------------------------------------\n// SHADERTOY MAIN\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    // setup\n    // test UV for input image\n    sCoord uv = fragCoord / iChannelResolution[0].xy;\n    \n    // TESTING\n    // set iChannel0 to 'Misc/Buffer A' and fetch sample\n    vec4 t1 = texture(iChannel0, uv);\n    vec4 t2 = texture(iChannel1, uv);\n    vec4 t3 = texture(iChannel2, uv);\n    vec4 mixedColor = t1 + t2; //add\n    //mixedColor = mix(t1, t2, .5); //mix\n    //mixedColor = screen(t1, t2); //screen\n    mixedColor = softLight(t1, t2); //Pegtop's formula soft light compositing\n\n    fragColor = mixedColor; //Mixed Colors\n    //fragColor = t3; //bright pass\n    //fragColor = t2; //cubemap\n    //fragColor = t1; //blur\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common by Michael Bowen\n//  -> Common\n//\n//Desc: Common functions shared across tabs\n\nfloat globalIntensity = .1;\nvec4 globalColor = vec4(1.0);\nconst int MAX_LIGHTS = 5;\nconst bool RUN_WORMHOLE = true; //set to true to run wormhole\n#define PI 3.1415926538\nvec4 LUMINANCE = vec4(.2125,.07154,.0721, 1.0);\nfloat weight[3] = float[](0.375, 0.25, 0.625); //alternate implementation divides by the sum removing a division calculation from the code(weight at n)/(2^n) = weight at kernal\n\n//------------------------------------------------------------\n// TYPE ALIASES & UTILITY FUNCTIONS\n\n// sScalar: alias for a 1D scalar (non-vector)\n#define sScalar float\n\n// sCoord: alias for a 2D coordinate\n#define sCoord vec2\n\n// sDCoord: alias for a 2D displacement or measurement\n#define sDCoord vec2\n\n// sBasis: alias for a 3D basis vector\n#define sBasis vec3\n\n// sPoint: alias for a point/coordinate/location in space\n#define sPoint vec4\n\n// sVector: alias for a vector/displacement/change in space\n#define sVector vec4\n\n\n// color3: alias for a 3D vector representing RGB color\n// \t(this is non-spatial so neither a point nor vector)\n#define color3 vec3\n\n// color4: alias for RGBA color, which is non-spatial\n// \t(this is non-spatial so neither a point nor vector)\n#define color4 vec4\n\n\n// asPoint: promote a 3D vector into a 4D vector \n//\trepresenting a point in space (w=1)\n//    v: input 3D vector to be converted\nsPoint asPoint(in sBasis v)\n{\n    return sPoint(v, 1.0);\n}\n\n// asVector: promote a 3D vector into a 4D vector \n//\trepresenting a vector through space (w=0)\n//    v: input 3D vector to be converted\nsVector asVector(in sBasis v)\n{\n    return sVector(v, 0.0);\n}\n\n\n// lengthSq: calculate the squared length of a vector type\n//    x: input whose squared length to calculate\nsScalar lengthSq(sScalar x)\n{\n    return (x * x);\n    //return dot(x, x); // for consistency with others\n}\n\nsScalar lengthSq(sDCoord x)\n{\n    return dot(x, x);\n}\nsScalar lengthSq(sBasis x)\n{\n    return dot(x, x);\n}\nsScalar lengthSq(sVector x)\n{\n    return dot(x, x);\n}\n\nfloat squareValue(float v){\n\treturn v*v;\n}\n\nvec3 squareValue(vec3 v){\n\treturn vec3(squareValue(v.x), squareValue(v.y), squareValue(v.z));\n}\nvec4 squareValue(vec4 v){\n\treturn vec4(squareValue(v.x), squareValue(v.y), squareValue(v.z), squareValue(v.a));\n}\n\n//Rotation Functions\n//mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c); //Rotates around the X axis\n//mat3(c,0.0,-s,0.0\t\t  ,1.0,0.0,s,0.0,c); //rotates around the y axis\n//mat3(c  ,s  ,0.0,-s ,c  ,0.0,0.0,0.0,1.0); //rotates around the z axis\nmat3 rotXAxis3D(in float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c); //Rotates around the X axis\n}\n\nmat3 rotYAxis3D(in float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c); //rotates around the y axis\n}\n\nfloat calcLuminance(in vec4 color){\n\treturn dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec4 screen(vec4 color1, vec4 color2){\n    return 1.0 - (1.0 - color1) * (1.0 - color2); //screen\n}\n\nvec4 softLight(vec4 color1, vec4 color2){ //soft light compositing\n\treturn (1.0 - color1)*(color1*color2) + color1 * screen(color1,color2);\n}\n\n//------------------------------------------------------------\n// VIEWPORT INFO\n\n// sViewport: info about viewport\n//    viewportPoint: location on the viewing plane \n//\t\t\t\t\t\t\tx = horizontal position\n//\t\t\t\t\t\t\ty = vertical position\n//\t\t\t\t\t\t\tz = plane depth (negative focal length)\n//\t  pixelCoord:    position of pixel in image\n//\t\t\t\t\t\t\tx = [0, width)\t-> [left, right)\n//\t\t\t\t\t\t\ty = [0, height)\t-> [bottom, top)\n//\t  resolution:    resolution of viewport\n//\t\t\t\t\t\t\tx = image width in pixels\n//\t\t\t\t\t\t\ty = image height in pixels\n//    resolutionInv: resolution reciprocal\n//\t\t\t\t\t\t\tx = reciprocal of image width\n//\t\t\t\t\t\t\ty = reciprocal of image height\n//\t  size:       \t in-scene dimensions of viewport\n//\t\t\t\t\t\t\tx = viewport width in scene units\n//\t\t\t\t\t\t\ty = viewport height in scene units\n//\t  ndc: \t\t\t normalized device coordinate\n//\t\t\t\t\t\t\tx = [-1, +1) -> [left, right)\n//\t\t\t\t\t\t\ty = [-1, +1) -> [bottom, top)\n// \t  uv: \t\t\t screen-space (UV) coordinate\n//\t\t\t\t\t\t\tx = [0, 1) -> [left, right)\n//\t\t\t\t\t\t\ty = [0, 1) -> [bottom, top)\n//\t  aspectRatio:   aspect ratio of viewport\n//\t  focalLength:   distance to viewing plane\nstruct sViewport\n{\n    sPoint viewportPoint;\n\tsCoord pixelCoord;\n\tsDCoord resolution;\n\tsDCoord resolutionInv;\n\tsDCoord size;\n\tsCoord ndc;\n\tsCoord uv;\n\tsScalar aspectRatio;\n\tsScalar focalLength;\n};\n\n// initViewport: calculate the viewing plane (viewport) coordinate\n//    vp: \t\t      output viewport info structure\n//    viewportHeight: input height of viewing plane\n//    focalLength:    input distance between viewer and viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid initViewport(out sViewport vp,\n                  in sScalar viewportHeight, in sScalar focalLength,\n                  in sCoord fragCoord, in sDCoord resolution)\n{\n    vp.pixelCoord = fragCoord;\n    vp.resolution = resolution;\n    vp.resolutionInv = 1.0 / vp.resolution;\n    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;\n    vp.focalLength = focalLength;\n    vp.uv = vp.pixelCoord * vp.resolutionInv;\n    vp.ndc = vp.uv * 2.0 - 1.0;\n    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;\n    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * 0.5, -vp.focalLength));\n}\n\n\n//------------------------------------------------------------\n// RAY INFO\n\n// sRay: ray data structure\n//\t  origin: origin point in scene\n//    direction: direction vector in scene\nstruct sRay\n{\n    sPoint origin;\n    sVector direction;\n};\n\n// initRayPersp: initialize perspective ray\n//    ray: \t\t   output ray\n//    eyePosition: position of viewer in scene\n//    viewport:    input viewing plane offset\nvoid initRayPersp(out sRay ray,\n             \t  in sBasis eyePosition, in sBasis viewport)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    ray.origin = asPoint(eyePosition);\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    ray.direction = asVector(viewport - eyePosition);\n}\n\n// initRayOrtho: initialize orthographic ray\n//    ray: \t\t   output ray\n//    eyePosition: position of viewer in scene\n//    viewport:    input viewing plane offset\nvoid initRayOrtho(out sRay ray,\n             \t  in sBasis eyePosition, in sBasis viewport)\n{\n    // offset eye position to point on plane at the same depth\n    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);\n}\n\n\n//------------------------------------------------------------\n/*\n// GLSL FRAGMENT SHADER STRUCTURE WITH COMMON TAB\n//  -> This is (likely) how Shadertoy compiles buffer tabs:\n\n// latest version or whichever is used\n#version 300 es\n\n// **CONTENTS OF COMMON TAB PASTED HERE**\n\n// PROGRAM UNIFORMS (see 'Shader Inputs' dropdown)\n\n// **CONTENTS OF BUFFER TAB PASTED HERE**\n\n// FRAGMENT SHADER INPUTS (more on this later)\n\n// FRAGMENT SHADER OUTPUTS (framebuffer render target(s))\n//out vec4 rtFragColor; // no specific target\nlayout (location = 0) out vec4 rtFragColor; // default\n\nvoid main()\n{\n    // Call 'mainImage' in actual shader main, which is \n\t// \tour prototyping interface for ease of use.\n\t//\t\trtFragColor:  shader output passed by reference,\n\t//\t\t\tfull vec4 read in 'mainImage' as 'fragColor'\n\t//\t\tgl_FragCoord: GLSL's built-in pixel coordinate,\n\t//\t\t\tvec2 part read in 'mainImage' as 'fragCoord'\n    mainImage(rtFragColor, gl_FragCoord.xy);\n}\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A by Michael Bowen\n//  -> Buf A\n//\n//Desc: Calculation for revolving cube map\n\n//------------------------------------------------------------\n// RENDERING FUNCTIONS\n\n// calcColor: calculate the color of current pixel\n//\t  vp:  input viewport info\n//\t  ray: input ray info\ncolor4 calcColor(in sViewport vp, in sRay ray)\n{\n    //CubeMap (Code could be contensed for a easier viewing experiance)\n    vec3 rayVec = ray.direction.xyz;\n  \n    //rotation based on mouse position\n    vec2 mousePointInspace = (iMouse.xy * vp.resolutionInv)  * 2.0 - 1.0; \n    vec2 theta = mousePointInspace*2.0*PI; //Makes the mouse position more proportinal to the output screen \n    rayVec *= rotXAxis3D(-theta.y) * rotYAxis3D(theta.x); //rotates the scene to an angle based on the mouse position\n    \n\tvec4 cube = texture(iChannel0, rayVec);  //Render Cube color\n    \n    return cube;\n    // test inputs\n    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass\n    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass\n    //return color4(vp.uv, 0.0, 0.0);\n    //return color4(vp.ndc, 0.0, 0.0);\n    return asPoint(sBasis(vp.viewportPoint.xy, -vp.viewportPoint.z));\n}\n\n\n//------------------------------------------------------------\n// SHADERTOY MAIN\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    // viewing plane (viewport) inputs\n    const sBasis eyePosition = sBasis(0.0);\n    const sScalar viewportHeight = 2.0, focalLength = 1.5;\n    \n    // viewport info\n    sViewport vp;\n\n    // ray\n    sRay ray;\n    \n    // render\n    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);\n    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);\n    fragColor += calcColor(vp, ray);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B by Michael Bowen\n//  -> Buf B\n//\n//Desc: Bright pass with linear fall off\n\n//------------------------------------------------------------\n// SHADERTOY MAIN\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    // setup\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec4 tex = texture(iChannel0, uv);\n    \n    //Bright Pass\n    float brightness = calcLuminance(tex); //luminance calc\n    float fallOffBrightness = (brightness - .5)*.5; //linear fall off\n    fragColor = vec4(vec3(fallOffBrightness), 1.0); //Mapping the brightness of the image to a grayscale\n    \n    // TESTING\n    // set iChannel0 to 'Misc/Buffer A' and fetch sample\n    //fragColor = textureColor;\n    \n    //Alternate Fall off calculations\n    //float fallOffBrightness = brightness/(brightness+1.0)-2.0; //Calculates the value based on its prightness\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C by Michael Bowen\n//  -> Buf C\n//source for information regarding multi-pass/optimizations: http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n//\n//Desc: Calculates the x-axis gaussian blur with a convolution kernal using weighted sampling based on pascales triangle\n\n//------------------------------------------------------------\n// SHADERTOY Buffer C\n\n\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    //global variables\n\t//float weight[3] = float[](0.375, 0.25, 0.625); // divides by the sum removing a division calculation from the code(weight at n)/(2^n) = weight at kernal\n    //Convolution experimentation: float weight[3] = float[](6.0, 4.0, 1.0); //based on the pascels triangle. half of a given row\n    \n    //setup\n    vec2 pixelSize = 1.0 / iChannelResolution[0].xy; //invRes\n    vec2 uv = vec2(fragCoord) * pixelSize; //define uv plane\n\n    //Convolution Experimentation Declaration\n    //float weightSum;\n    //vec3 tex;\n    //vec2 offset = vec2(0.0, 0.0);\n    //vec4 textureColor;\n\n    //sampling\n\tint i;\n    vec4 textureColor = texture(iChannel0, uv) * weight[0]; //runs outside the loop because the weight index at zero only runs once\n    for(i= weight.length() - 1; i > 0; --i){\n        \n        //All the pixel samples to the right\n        uv = (vec2(fragCoord) + vec2(float(i), 0.0)) * pixelSize; //since pixel size is the measure of a single UV pixel can we get rid of the call to frag coord?\n        textureColor += texture(iChannel0, uv) * weight[i];\n        \n        //All the pixel samples to the left\n        uv = (vec2(fragCoord) - vec2(float(i), 0.0) ) * pixelSize;\n        textureColor += texture(iChannel0, uv) * weight[i];\n        \n        //Convolution experimentation\n        //float weight = length(textureColor);\n        //weightSum += weight[i];\n    \t//tex += weight * textureColor.rgb;\n    }\n\n    fragColor = textureColor;\n    \n    // TESTING\n    // set iChannel0 to 'Misc/Buffer A' and fetch sample\n    //fragColor = tex;\n    \n    //more Convolution experimentation\n    //float inverseWeightSum = 1.0/weightSum; //don't need because of the construction of the weight array\n    //vec4 finalColor = vec4(vec3(textureColor.rgb*inverseWeightSum), 1.0);\n    //vec4 finalColor = vec4(vec3(textureColor.rgb), 1.0);\n    //vec4 finalColor = textureColor;\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D by Michael Bowen\n//  -> Buf D\n//source for information regarding multi-pass/optimizations: http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n//Same as Buf C for y-axis\n\n//------------------------------------------------------------\n// SHADERTOY Buffer D\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n\t//float weight[3] = float[](6.0, 4.0, 1.0); //based on the pascels triangle. half of a given row\n\t//float weight[3] = float[](0.375, 0.25, 0.625); //alternate implementation divides by the sum removing a division calculation from the code(weight at n)/(2^n) = weight at kernal\n    // setup\n    // test UV for input image\n    \n    int i;\n    vec2 pixelSize = 1.0 / iChannelResolution[0].xy; //declared for optimization\n    vec2 uv = vec2(fragCoord) * pixelSize;\n    vec4 textureColor = texture(iChannel0, uv) * weight[0]; //runs outside the loop because the weight index at zero only runs once\n    for(i= weight.length() - 1; i > 0; --i){\n        \n        //All the pixel samples to the right\n        uv = (vec2(fragCoord) + vec2(0.0, float(i))) * pixelSize;\n        textureColor += texture(iChannel0, uv) * weight[i];\n        \n        //All the pixel samples to the left\n        uv = (vec2(fragCoord) - vec2(0.0, float(i))) * pixelSize;\n        textureColor += texture(iChannel0, uv) * weight[i];\n        \n\n    }\n  \n    fragColor =  textureColor; \n    \n    \n    // TESTING\n    // set iChannel0 to 'Misc/Buffer A' and fetch sample\n    //fragColor = tex;\n    \n    \n}","name":"Buf D","description":"","type":"buffer"}]}