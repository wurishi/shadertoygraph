{"ver":"0.1","info":{"id":"tlcSD4","date":"1580927714","viewed":139,"name":"Jellyfish form for 3dprint","username":"cabbibo","description":"form only","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["jellyfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 2000;\n\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               \t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX , in float mouseY )\n{\n    float an = 0.3 + 10.0*mouseY;\n    float anY =  mouseX * 6.;\n\tcamPos = vec3(3.5*sin(an),20. * sin(anY),3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\n\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat dot2(in vec2 v ) {return dot(v,v);}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec3 opTwist(  in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    pos.x += sin( pos.y) * .2;\n    pos.z += cos( pos.y * .8) * .3;\n    \n    float res = sdSphere( pos - vec3(0.,1.,0.) , .8);\n    res = opSmoothSubtraction(  sdBox( pos , vec3(10.,1.,10.)),res ,.3);\n    res = opSmoothSubtraction(  sdSphere( pos - vec3(0.,.8,0.) , .7),res ,.3);\n    \n    res = opSmoothUnion( sdTorus(pos-vec3(0.,1.2,0.),vec2(1. , .01)),res ,.5);\n    res = opSmoothUnion( sdTorus(pos-vec3(0.,1.,0.),vec2(1.2 , .07)),res ,.2);\n    res += .03 * noise( pos * 10. );\n    \n    res -= .01 * noise( pos * 3. );\n    \n    \n    // Top Tubes\n    vec3 p2 = pos;\n    float degree = atan( p2.x , p2.z );\n    \n    float ogD = degree;\n    \n    float l = length( p2.xz );\n    \n    float segments = 20.;\n    float which = floor((degree - 3.14159  / (segments*2.)) / ( 3.14159 / segments)- 3.14159  / (segments * 2.));\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    p2.x += sin( p2.y * 10. + which * 2. + iTime * which * .1) * .02;\n    res = opSmoothUnion( .1 * sdVerticalCapsule( p2 - vec3(0.,-(.1 + sin( 6.*which * 3.14159 / segments)),1.2),1.2 + sin(  6.*which* 3.14159 / segments), .05),res ,.1);\n   \t\n   \n    \n    // lil bumppies\n    \n    p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    l = length( p2.xz );\n    \n    segments = 10.;\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    res = opSmoothSubtraction( sdSphere( p2 - vec3(0.,1.2,.98),.03),res ,.2);\n   \t\n    \n    \n    // top dimples\n     p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    l = length( p2.xz );\n    \n    segments = 2.;\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    res = opSmoothSubtraction( sdSphere( p2 - vec3(0.,1.8,.4),.2),res ,.15);\n   \t\n       \n    // long tenkz\n    \n        p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    \n    l = length( p2.xz );\n     segments = 6.;\n    which = floor((degree - 3.14159  / (segments*2.)) / ( 3.14159 / segments)- 3.14159  / (segments * 2.));\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    p2.x += sin( p2.y * 3. + which * 2. + iTime * which * .1) * .02;\n    res = opSmoothUnion( .04 * noise( pos * 5. ) * p2.y + sdVerticalCapsule( p2 - vec3(0.,-(2.1 + sin( 6.*which * 3.14159 / segments)),.6 - .1*p2.y),3.2 + sin(  6.*which* 3.14159 / segments), .1 * max(-p2.y * .3,1.)),res ,.03);\n   \t\n    \n    float pluemVal =  .4 * noise( pos * 5. ) + sdVerticalCapsule( pos - vec3(0.,-7.,0.), 8., .4  * max(.5,.4*-pos.y) );\n   \tpluemVal = opSmoothUnion( .2 * noise( pos * 8. ) + sdVerticalCapsule( pos - vec3(0.,-7.,0.), 8., .4  * max(.5,.5*-pos.y) ),pluemVal ,.03);\n   \tpluemVal = opSmoothUnion( .1 * noise( pos * 9. ) + sdVerticalCapsule( pos - vec3(0.,-7.,0.), 8., .4  * max(.5,.6*-pos.y) ),pluemVal ,.03);\n   \t \n    // long tenkz\n    \n    p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    \n    l = length( p2.xz );\n     segments = 6.;\n    which = floor((degree - 3.14159  / (segments*2.)) / ( 3.14159 / segments)- 3.14159  / (segments * 2.));\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    p2.x += sin( p2.y * 3. + which * 2. + iTime * which * .1) * .02;\n    \n    float extras = sdVerticalCapsule( p2 - vec3(0.,-8.,-.2*p2.y),8.2,.05 * max(-p2.y * .5,1.));\n    pluemVal = opSmoothSubtraction(  extras, pluemVal ,.3);\n    pluemVal = opSmoothUnion(  extras, pluemVal ,.01);\n   \tpluemVal = opSmoothUnion( sdVerticalCapsule(pos- vec3(0.,-1.,0.), 2.,.2),pluemVal,.2);\n    pluemVal = opSmoothSubtraction( sdVerticalCapsule(pos- vec3(0.,-10.,0.), 2.,1.2),pluemVal,.6);\n    \n    res = opSmoothUnion( res , pluemVal , .1 );\n    \n    return vec2(res,1.);\n    \n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.yx + 2.0*fragCoord.yx)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x ,m.y);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n       col = norm * .5 + .5;\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}","name":"Image","description":"","type":"image"}]}