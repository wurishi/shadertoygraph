{"ver":"0.1","info":{"id":"fdGfR1","date":"1657626441","viewed":70,"name":"Red star","username":"jordies","description":"a weird star","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Function that takes a position p, a centre of the sphere c, and the radius of said sphere r\nfloat Distance(in vec3 p, in vec3 c, float r)\n{\n    return length(p-c)-r;\n}\n\nfloat MapTheWorld(in vec3 p)\n{\n    //Mapping all the spheres in the world\n    float displacement = sin(iTime * p.x) * sin(iTime * p.y) * sin(iTime * p.z) * 0.25;\n    float sphere_0 = Distance(p, vec3(0.0), 1.0);\n\n    return sphere_0 + displacement;\n}\n\n//Calculating normals\nvec3 CalculateNormal(in vec3 p)\n{\n    const vec3 smallStep = vec3(0.001f,0.0f, 0.0f);\n    \n    float gradientX = MapTheWorld(p + smallStep.xyy) - MapTheWorld(p - smallStep.xyy);\n    float gradientY = MapTheWorld(p + smallStep.yxy) - MapTheWorld(p - smallStep.yxy);\n    float gradientZ = MapTheWorld(p + smallStep.yyx) - MapTheWorld(p - smallStep.yyx);\n    \n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n    \n    return normalize(normal);\n}\n\n// ro: ray origin\n// rd: ray direction\nvec3 rayMarch(in vec3 ro, in vec3 rd)\n{\n    float totalDistanceTraveled = 0.0f;\n    const int NUMBEROFSTEPS = 32; //number of times we loop\n    const float MINIMUMHITDISTANCE = 0.001f; //minimum number to consider a hit\n    const float MAXIMUMTRACEDISTANCE = 1000.0f;\n    \n    for(int i = 0; i < NUMBEROFSTEPS; ++i)\n    {\n        vec3 currentPos =  ro + totalDistanceTraveled * rd;\n        \n        float distanceClosest = MapTheWorld(currentPos);\n        \n        if(distanceClosest < MINIMUMHITDISTANCE) //hit\n        {\n            vec3 normal = CalculateNormal(currentPos);\n            \n            vec3 lightPos = vec3(2.0f,-5.0f, 3.0f);\n            vec3 dir2Light = normalize(currentPos - lightPos);\n            float diffuseIntensity = max(0.0, dot(normal,dir2Light));\n            \n            return vec3(1.0f,0.0f,0.0f) * diffuseIntensity;\n        }\n        \n        if(totalDistanceTraveled > MAXIMUMTRACEDISTANCE) // ray out of scope\n        {\n            break;\n        }\n        \n        //update distance traveled\n        totalDistanceTraveled += distanceClosest;\n    }\n    \n    return vec3(0.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n  \n    // Create ray\n    \n    vec3 cameraPos = vec3(0.0f, 0.0f, -5.0f);\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(vec3(uv,1.0f));\n    \n    vec3 color = rayMarch(ro,rd);\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}