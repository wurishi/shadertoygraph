{"ver":"0.1","info":{"id":"mdKXWR","date":"1680966760","viewed":78,"name":"Physically Incorrect Ray Tracer","username":"FrederickAmpsUp","description":"My first **PUBLIC** Shadertoy. I'm starting this in 4/8/2023 with an end goal of spheres and meshes.\nUPDATE: so RIP this project but it looks kinda cool","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracer","triangles","spheres","mesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 light( RayHit hit ) {\n    return vec3(0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = vec3(0,0,-1);\n    vec3 cam_dir = vec3(0,0,1);\n    int fov = 70;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float ratio = float(iResolution.y) / float(iResolution.x);\n    \n    Ray camera = cameraRay(eye, cam_dir, fov, uv, ratio);\n    \n    Sphere scene = Sphere(vec3(0,0,1), .5);\n    // Output to screen\n    fragColor = vec4(intersectSphere(scene, camera).normal,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 lerp( vec2 pos1, vec2 pos2, vec2 val ) { // Used for finding screen coords for camera rays\n    return (pos2 - pos1) * val + pos1;\n}\n\n// Ray functions\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nRay newRay( vec3 origin, vec3 direction ) {\n    return Ray(origin, normalize(direction));\n}\n\n// Generate a camera ray (credit to ChatGPT)\nRay cameraRay( vec3 eye, vec3 camForward, int fov, vec2 fragScreenUV, float screenRatio ) {\n   // Calculate the tan of half the field of view in radians\n  float tan_fov = tan(radians(float(fov) / 2.0));\n  // Calculate the direction of the ray by adding the camera's forward direction to a vector that is proportional to the fragment's position on the screen and the screen ratio\n  vec3 rayDir = normalize(camForward + vec3(fragScreenUV.x * tan_fov, fragScreenUV.y * screenRatio * tan_fov, 0.0));\n  // Create a new Ray object with the eye position as the origin and the normalized ray direction as the direction\n  return newRay(eye,rayDir);\n}\n\nvec3 pointOnRay( Ray ray, float dist ) {\n    return ray.origin + (ray.direction * dist);\n}\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n\nstruct RayHit {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n};\n\nRayHit intersectSphere( Sphere obj, Ray r ) {\n    vec3 oc = r.origin - obj.position;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc,oc) - obj.radius*obj.radius;\n    float discriminant = half_b*half_b - a*c;\n    \n    float d = (-half_b - sqrt(abs(discriminant)) / a);\n    return RayHit (discriminant > 0.0 && d > 0.0, pointOnRay(r, d), normalize(pointOnRay(r, d) - obj.position));\n}\n\n","name":"Common","description":"","type":"common"}]}