{"ver":"0.1","info":{"id":"dljfRV","date":"1694274429","viewed":79,"name":"VJ-WIRETAP-2023-09-08","username":"FoRenard","description":"I love sh4derjockey\n\nThis is a part of the VJ I did\nhttps://youtu.be/P_dGCuVyJ6s?si=KGhitrpJsOpctNcJ","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["vj","sh4derjockey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// #pragma include \"common/func.glsl\" -----------------------------------------------\nconst float PI = acos(-1.0);\nconst float TAU = 2.0 * PI;\n#define remap(x,a,b,c,d) ((((x)-(a))/((b)-(a)))*((d)-(c))+(c))\n#define remapc(x,a,b,c,d) clamp(remap(x,a,b,c,d),min(c,d),max(c,d))\n#define saturate(x) clamp(x,0.0,1.0)\n#define linearstep(a, b, x) min(max(((x) - (a)) / ((b) - (a)), 0.0), 1.0)\nvec2 uvmap(vec2 uv, vec2 lb, vec2 rt)\n{\n    return (uv - lb) / (rt - lb);\n}\nvec2 uvmapc(vec2 uv, vec2 lb, vec2 rt)\n{\n    return clamp(uvmap(uv, lb, rt), 0., 1.);\n}\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n// hacky\nvec2 uvtrip(vec3 P, vec3 N,float power)\n{\n    N = sign(N) * pow(abs(N), vec3(power));\n    N = N / dot(vec3(1), N);\n    return N.x * P.zy + N.y * P.xz + N.z * P.xy;\n}\n// ortho basis\n// https://en.wikipedia.org/wiki/Osculating_plane\nmat3 getBNT(vec3 T)\n{\n    // camera rotation (may not be needed)\n    // float cr = 0.0;\n    // vec3 N = vec3(sin(cr), cos(cr), 0.0);\n    T = normalize(T);\n    vec3 N = vec3(0, 1, 0);\n    vec3 B = normalize(cross(N, T));\n    N = normalize(cross(T, B));\n    return mat3(B, N, T);\n}\nvec2 pmod(vec2 suv, float div)\n{\n    const float shift = 0.0;\n    float a = atan(suv.y, suv.x) + TAU - PI * 0.5 + PI / div;\n    a = mod(a, TAU / div) + PI * 0.5 - PI / div - shift;\n    return vec2(cos(a), sin(a)) * length(suv);\n}\nvec3 acesFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// #pragma include \"common/brdf.glsl\" -----------------------------------------------\n\n// type: 0:pbr, 1:unlit(emissive)\nconst int MAT_PBR = 0;\nconst int MAT_UNLIT = 1;\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float metallic;\n    float roughness;\n};\n#define Material() Material(0,vec3(1), 0.5, 0.5)\n\n/*\nhttps://google.github.io/filament/Filament.html#materialsystem\nSpecular Microfacet BRDF for Realtime Rendering\n*/\n\nfloat pow5(float x)\n{\n    return (x * x) * (x * x) * x;\n}\n\n/*\nNormal distribution function\n(Trowbridge-Reitz distribution)\n*/\nfloat D_GGX(float roughness, float NoH)\n{\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * (1.0 / PI);\n}\n/*\nVisibility function\n(height-correlated Smith function)\n*/\nfloat V_Smith(float roughness, float NoV, float NoL)\n{\n    float a2 = roughness * roughness;\n    float G_V = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float G_L = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (G_V + G_L);\n}\nfloat V_Smith_Fast(float roughness, float NoV, float NoL)\n{\n    float a = roughness;\n    float G_V = NoV / (NoV * (1.0 - a) + a);\n    float G_L = NoL / (NoL * (1.0 - a) + a);\n    return 0.5 / (G_V + G_L);\n}\n/*\nFresnel function\n(Schlick approximation)\nF : Fresnel reflectance\nF90 = 1.0\n*/\nvec3 F_Schlick(vec3 f0, float c)\n{\n    float k = pow5(1.0 - c);\n    return f0 + (1.0 - f0) * k;\n}\nfloat F_Schlick_Burley(float f90, float c)\n{\n    const float f0 = 1.0;\n    float k = pow5(1.0 - c);\n    return f0 + (f90 - f0) * k;\n}\n/*\nDisney diffuse BRDF\n*/\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH)\n{\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float ls = F_Schlick_Burley(NoL, f90);\n    float vs = F_Schlick_Burley(NoV, f90);\n    return ls * vs * (1.0 / PI);\n}\n/*\nCook-Torrance approximation\nSpecular-BRDF=D*G*F/(4*dot(L,N)*dot(V,N))\n=D*V*F\n\nD: Normal distribution function\nG: geometric shadowing function\nF: Fresnel function\nV: Visibility function\n*/\nvec3 Microfacet_BRDF(Material mat, vec3 L, vec3 V, vec3 N)\n{\n    // i think 0.5\n    const float reflectance = 0.5;\n    vec3 albedo = mat.albedo;\n    float metallic = mat.metallic;\n    float paramRoughness = mat.roughness;\n\n    float roughness = paramRoughness * paramRoughness;\n    // clamp roughness\n    roughness = max(roughness, 1e-3);\n    vec3 f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + albedo * metallic;\n\n    vec3 H = normalize(L + V);\n    float NoV = abs(dot(N, V)) + 1e-5;\n    float NoL = saturate(dot(N, L));\n    float NoH = saturate(dot(N, H));\n    float LoH = saturate(dot(L, H));\n\n    // Calc specular\n    float D_spec = D_GGX(roughness, NoH);\n    float V_spec = V_Smith(roughness, NoV, NoL);\n    // float V_spec = V_Smith_Fast(roughness, NoV, NoL);\n\n    vec3 F_spec = F_Schlick(f0, LoH);\n    vec3 Fr = (D_spec * V_spec) * F_spec;\n    // Calc diffuse\n    vec3 diffColor = albedo * (1.0 - metallic);\n    vec3 Fd = diffColor * Fd_Burley(roughness, NoV, NoL, LoH);\n\n    return (Fr + Fd) * NoL;\n}\n// Lighting-------------------\n// 1/(r^2+1) * saturate((1-(r/rmax)^2)^2)\nvoid pointLight(vec3 P, vec3 lpos, float lmin, float lmax, out vec3 L, out float lint)\n{\n    L = lpos - P;\n    float r = length(L);\n    L /= r;\n    r = max(0., r - lmin);\n    float c = 1.0 / (r * r + 1.0);\n    float w = r / lmax;\n    w = 1.0 - w * w;\n    w = saturate(w * w);\n    lint = c * w;\n}\nvoid tubeLight(vec3 P, vec3 spos, vec3 epos, float lmin, float lmax, out vec3 L, out float lint)\n{\n    vec3 dir = epos - spos;\n    float len = length(dir);\n    dir /= len;\n    float t = dot(P - spos, dir);\n    t = clamp(t, 0.0, len);\n    vec3 p = spos + dir * t;\n    pointLight(P, p, lmin, lmax, L, lint);\n}\n\n// #pragma include \"common/noise.glsl\" -----------------------------------------------\n// Hash without Sine by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n// Voronoi - distances by iq\n// https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi(vec2 x)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; j++) for(int i = -1; i <= 1; i++)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash22(n + g);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for(int j = -2; j <= 2; j++) for(int i = -2; i <= 2; i++)\n        {\n            vec2 g = mg + vec2(float(i), float(j));\n            vec2 o = hash22(n + g);\n            vec2 r = g + o - f;\n\n            if(dot(mr - r, mr - r) > 0.00001)\n                md = min(md, dot(0.5 * (mr + r), normalize(r - mr)));\n        }\n\n    return vec3(md, mr);\n}\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v)\n{\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n\n    return v;\n}\nvec3 pcg33(vec3 v)\n{\n    uvec3 u = pcg3d(floatBitsToUint(v));\n    return vec3(u) / float(0xffffffffu);\n}\n// Cyclic Noise by nimitz (explained by jeyko)\n// https://www.shadertoy.com/view/3tcyD7\n// And edited by 0b5vr\n// https://scrapbox.io/0b5vr/Cyclic_Noise\nvec3 cyclic(vec3 p)\n{\n    const float freq = 2.0;\n    const vec3 seed = vec3(1, 2, 3);\n    const int octaves = 8;\n    vec4 n = vec4(0);\n    mat3 bnt = getBNT(seed);\n\n    for(int i = 0; i < octaves; i++)\n    {\n        p += sin(p.yzx);\n        n += vec4(cross(cos(p), sin(p.zxy)), 1);\n        p *= bnt * freq;\n    }\n\n    return n.xyz / n.w;\n}\n// Vorocracks marble by FabriceNeyret2\n// https://www.shadertoy.com/view/Xs3fR4\n// -1~1\nfloat perlin12(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f); // smoothstep\n\n    float v = mix(mix(hash12(i + vec2(0, 0)), hash12(i + vec2(1, 0)), f.x), mix(hash12(i + vec2(0, 1)), hash12(i + vec2(1, 1)), f.x), f.y);\n    return 2. * v - 1.;\n}\n// -1~1\nvec2 fbm22(vec2 p)\n{\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for(int i = 0; i < 6; i++, p *= 2., a /= 2.) p *= R, v += a * vec2(perlin12(p), perlin12(p + 17.7));\n\n    return v;\n}\n// -1~1\nfloat fbm12(vec2 p)\n{\n    float v = 0., a = .5;\n    mat2 R = rot(.37);\n\n    for(int i = 0; i < 9; i++, p *= 2., a /= 2.) p *= R, v += a * perlin12(p);\n\n    return v;\n}\n// Wet Concrete by kaneta\n// https://www.shadertoy.com/view/tsjXDV\nfloat concrete(vec2 p)\n{\n    const int octaves = 3;\n    p *= 0.1;\n    float n = perlin12(p * 1000.0);// so rough noise\n    float f = remapc(fbm12(p * 12.0), -0.2, 0.4, 0.0, 1.0);// fbm for detail\n\n    float d = 999999.9;\n\n    float height = 1.0;\n    float alpha = 2.0;\n\n    mat2 R = rot(.37) * 1.5;\n\n    // fractal voronoi\n    for(int i = 0; i < octaves; i++)\n    {\n        vec3 c = voronoi(8.0 * p + fbm22(p * 8.0));\n        height -= smoothstep(0.05, 0.0, c.x) * alpha * remapc(fbm12(p * 12.0), 0.0, 0.4, 0.0, 1.0);\n        alpha *= 0.55;\n        d = min(d, c.x);\n        p *= R;\n    }\n\n    // heightだけなら saturate(height) でいいと思う\n    float v = height - f;\n    // normalize maybe -2. ~ -1. ?\n    v = remapc(v, -2., 1.0, 0.0, 1.0);\n    return v;\n\n    // original\n    // float v = height + n * 0.1 - f;\n    // v = (v - .5) * 0.05 + .5; // contrast\n}\n\n// #pragma include \"common/sdf.glsl\" -----------------------------------------------\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For ShaderToy----------------------------------------------------------------------------------\n#define time iTime\n#define resolution iResolution\n\n#define beatSpan 1.0\n#define beatCount int(floor(time / beatSpan) + 0.5)\n#define beatBT (fract(time / beatSpan))\n#define IsEye (beatCount%16==0)\n#define gain (0.0)\n\n// Global----------------------------------------------------------------------------------\n#define LoopMax 256\n#define DistMin 1e-3\n#define LenMax 100.0\n#define NormalEPS 1e-4\n\nfloat Time;\nint MatID;\n\nconst float RZ = 2.0;\n\n// Other----------------------------------------------------------------------------------\nstruct Info\n{\n    float pd;\n    float magaru;\n    float mawaru;\n    float tikaru;\n};\n\nInfo getInfo()\n{\n    Info info;\n    vec3 h3 = pcg33(vec3(beatCount / 2, -.11, 12.2));\n    info.pd = floor(h3.x * mix(2.0, 4.0, gain)) + 2.0;\n    info.magaru = float(h3.y < 0.5);\n    info.mawaru = mix(0.01, 0.1, float(h3.z < 0.5));\n    h3 = pcg33(vec3(beatCount / 2, 21.23, -1.4));\n    info.tikaru = float(h3.x < 0.5);\n    return info;\n}\n\n// SDF----------------------------------------------------------------------------------\n\nfloat sdPol(vec3 p)\n{\n    const vec2 syz = vec2(2, 0.9);\n    const float r = 4.0;\n    float rz = RZ;\n    Info info = getInfo();\n    float zi = floor(p.z / rz) * rz;\n    p.z = mod(p.z, rz) - rz * 0.5;\n    float a = TAU * zi * info.mawaru;\n    p.xy *= rot(-a);\n    p.xy = pmod(p.xy, info.pd);\n    p.y -= r;\n    p.y += -p.x * p.x * 0.05 * info.magaru;\n    return sdBox(p, vec3(1e5, syz * 0.5));\n}\n\nfloat sdPolLight(vec3 p)\n{\n    const float sr = 0.3;\n    const float r = 2.0;\n    float rz = RZ * 2.0;\n    Info info = getInfo();\n    float zi = floor(p.z / rz) * rz;\n    p.z = mod(p.z, rz) - rz * 0.5;\n    float a = TAU * zi * info.mawaru;\n    p.xy *= rot(-a);\n    p.xy = pmod(p.xy, info.pd);\n    p.y -= r;\n    p.y += -p.x * p.x * 0.05 * info.magaru;\n    // return sdBox(p, vec3(1e9, syz * 0.5));\n    return sdCapsule(p, vec3(-1e5, 0, 0), vec3(1e5, 0, 0), sr);\n}\n\nfloat sdf(vec3 p)\n{\n    #define opSDFMin(sdf) (MatID = ((dt = sdf) < d ? (d = dt, mid): MatID)), mid++\n    int mid = 0;\n    MatID = -1;\n    float dt, d = LenMax;\n\n    opSDFMin(sdPol(p));\n    opSDFMin(sdPolLight(p));\n\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float h = NormalEPS;\n    const vec2 k = vec2(1, -1);\n    // keep matid\n    int mid = MatID;\n    vec3 n = normalize(k.xyy * sdf(p + k.xyy * h) + k.yyx * sdf(p + k.yyx * h) + k.yxy * sdf(p + k.yxy * h) + k.xxx * sdf(p + k.xxx * h));\n    MatID = mid;\n    return n;\n}\n\nvec3 getPolLightDir(vec3 p)\n{\n    const float h = NormalEPS;\n    const vec2 k = vec2(1, -1);\n    vec3 l = -normalize(k.xyy * sdPolLight(p + k.xyy * h) + k.yyx * sdPolLight(p + k.yyx * h) + k.yxy * sdPolLight(p + k.yxy * h) + k.xxx * sdPolLight(p + k.xxx * h));\n    return l;\n}\n\nbool march(vec3 rd, vec3 ro, out vec3 rp)\n{\n    float dist, len = 0.0;\n    for(int i; i < LoopMax; i++)\n    {\n        rp = ro + rd * len;\n        dist = sdf(rp);\n        // traversal z\n        float nd = abs((ceil(rp.z / RZ) * RZ - rp.z));\n        nd = (rd.z < 0.0 ? nd - RZ : nd) / rd.z;\n        dist = min(dist, nd + DistMin);\n\n        len += dist;\n        if(len > LenMax)\n        {\n            break;\n        }\n        if(dist < DistMin)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Material----------------------------------------------------------------------------------\n#define Tika(P) float(fract(floor(P.z / RZ - Time * 10.0) / 6.0) < 0.1||getInfo().tikaru>0.5)\n\nMaterial getMaterial(vec3 P, inout vec3 N)\n{\n    Material mat = Material();\n    if(MatID == 0)\n    {\n        P.z = mod(P.z, RZ);\n        vec2 uv = uvtrip(P, N, 20.0);\n        float c = concrete(uv);\n        mat.albedo = vec3(c);\n        mat.roughness = 0.7;\n        mat.metallic = 0.2;\n    }\n    else if(MatID == 1)\n    {\n        mat.albedo = vec3(1) * Tika(P);\n        mat.type = MAT_UNLIT;\n    }\n    return mat;\n}\n\n// Shading----------------------------------------------------------------------------------\n\nvec3 calcDirectionalLight(Material mat, vec3 P, vec3 V, vec3 N)\n{\n    vec3 L = normalize(vec3(-P.xy, 1));\n    vec3 lcol = vec3(0.5);\n    return Microfacet_BRDF(mat, L, V, N) * lcol;\n}\n\nvec3 calcPolLight(Material mat, vec3 P, vec3 V, vec3 N)\n{\n    float d = sdPolLight(P);\n    vec3 L = getPolLightDir(P);\n    vec3 lcol = vec3(2);\n    vec3 lpos = P + L * d;\n    float lint;\n    pointLight(P, lpos, 1.5, 4.0, L, lint);\n    return Microfacet_BRDF(mat, L, V, N) * lcol * lint * Tika(lpos);\n}\n\nvec3 secondaryShading(vec3 SP, vec3 SV)\n{\n    vec3 scol = vec3(0);\n    vec3 SN = getNormal(SP);\n    Material smat = getMaterial(SP, SN);\n    return smat.albedo * float(smat.type == MAT_UNLIT);\n}\n\nvec3 shading(inout vec3 P, vec3 V, vec3 N)\n{\n    vec3 col = vec3(0);\n    N = getNormal(P);\n\n    Material mat = getMaterial(P, N);\n    if(mat.type == MAT_UNLIT)\n    {\n        return mat.albedo;\n    }\n    // primary lighting\n    col += calcDirectionalLight(mat, P, V, N);\n    col += calcPolLight(mat, P, V, N);\n\n    // secondary ray\n    P += N * DistMin;// avoid self-intersection\n    vec3 SP;\n    vec3 srd = reflect(-V, N);\n    if(!march(srd, P, SP))\n    {\n        return col;\n    }\n    vec3 SV = -srd;\n    vec3 scol = secondaryShading(SP, SV);\n\n    // primary lighting\n    // indirect like IBL\n    const float iblmax = 10.0;\n    float iblr = length(SP - P);\n    // saturate((1-(r/rmax)^2)^2)\n    float iblwin = saturate(pow(saturate(1.0 - pow(iblr / iblmax, 2.0)), 2.0));\n    // this is so bad i think\n    col += scol * Microfacet_BRDF(mat, normalize(srd + N * 0.1), V, N) / PI;\n\n    return col;\n}\n\n// Trace----------------------------------------------------------------------------------\n\n// primary ray\nvec3 tracer(vec3 rd, vec3 ro)\n{\n    vec3 rp;\n    if(!march(rd, ro, rp))\n    {\n        return vec3(0);// sky color\n    }\n    float len = length(rp - ro);\n    vec3 N;\n    vec3 col = shading(rp, -rd, N);\n\n    // fog\n    float fog = exp(-max(0.0, len * 0.03));\n\n    col *= fog;\n    return col;\n}\n\n// Root----------------------------------------------------------------------------------\n\nfloat sEyeCustom(vec2 uv, float t)\n{\n    const float sc = 0.8;\n    // float lt = t * 5.0;\n    // float h1 = pcg11(floor(lt));\n    // float ease = fract(lt);\n    // float mabataki = pow(abs(ease - 0.5) * 2.0, 7.0);\n    // float w = 0.4 * (h1 < 0.05 ? mabataki : 1.0);\n    float w = 0.4 * saturate(t);\n    uv = (uv - .5) / sc + .5;\n    vec2 suv = uv * 2.0 - 1.0;\n    suv.y = abs(suv.y);\n    float x = suv.x, y = suv.y;\n    float right = w * (1.0 - x * x);\n    right *= pow(1.0 - saturate(abs(x)), 0.2);\n\n    float c = 0.0;\n    c += float(y < right);\n    // c -= sCircle(uv, w * 0.45);\n\n    return saturate(c);\n}\n\nvoid getUV(out vec2 uv, out vec2 suv)\n{\n    vec2 fc = gl_FragCoord.xy, res = resolution.xy;\n    fc += (pcg33(vec3(iTime,.1,.2)).xy-0.5)*0.25;\n    uv = fc / res;\n    suv = (fc * 2.0 - res) / min(res.x, res.y);\n\n    vec2 euv = uvmap(suv * rot(-PI * 0.25), vec2(-1.5), vec2(1.5));\n    float c = sEyeCustom(euv, 1.0 - pow(1.0 / (1.0 + beatBT), 10.0));\n    if(IsEye)\n    {\n        suv += cyclic(vec3(suv * 0.1, Time * 0.005)).xy * c * 0.2;\n    }\n}\n\nvoid getRORD(out vec3 ro, out vec3 rd, out vec3 dir, vec2 suv)\n{\n    // Parameter\n    float fov = 60.0;\n    float fisheye = 0.0;\n    // 0.0: ortho, 1.0: persp\n    float pars = 1.0;\n    // ortho size\n    float osize = 2.5;\n    // ortho near\n    float onear = -5.0;\n\n    ro = vec3(0, 0, Time);\n    dir = vec3(0, 0, 1);\n\n    mat3 bnt = getBNT(dir);\n    float zf = 1.0 / tan(fov * PI / 360.0);\n    zf -= zf * length(suv) * fisheye;\n\n    vec3 rdp, rop, rdo, roo;\n    {\n        rdp = normalize(bnt * vec3(suv, zf));\n        rop = ro;\n    }\n    {\n        rdo = dir;\n        roo += bnt * vec3(suv * osize, onear);\n    }\n\n    rd = normalize(mix(rdo, rdp, pars));\n    ro = mix(roo, rop, pars);\n}\n\nvec3 overlay(vec3 ro, vec2 uv, vec2 suv, vec3 bcol)\n{\n    vec3 col = vec3(0);\n\n    float c = 0.0;\n    Info info = getInfo();\n\n    vec2 puv = suv;\n    puv *= rot(-(ro.z + 2.0) * TAU * 0.01);\n\n    puv = pmod(puv, info.pd);\n    puv.y += -puv.x * puv.x * info.magaru;\n    float fq = 7.0;\n    float l = abs(fract(puv.y * fq) - 0.5) * 2.0;\n    c += smoothstep(0.5, 0.35, l) * float(floor(puv.y * fq) < 5.0);\n\n    col += c;\n    return col;\n}\n\nvec3 postProcess(vec3 col, vec2 uv, vec2 suv)\n{\n    // Vignette\n    float l = length(uv * 2.0 - 1.0);\n    l = remapc(l, 0.5, 1.0, 1.0, 0.0);\n    col *= (mix(0.7, 1.0, smoothstep(0.0, 1.0, l)));\n    // 嘘 Gamma Correction\n    col = pow(col, vec3(0.8));\n    col = acesFilm(col);\n    return col;\n}\n\n// Main----------------------------------------------------------------------------------\n\nvec3 render(float t)\n{\n    // Parameter\n    Time = t;\n\n    // Get UV\n    vec2 uv, suv;\n    getUV(uv, suv);\n\n    // Camera\n    vec3 ro, rd, dir;\n    getRORD(ro, rd, dir, suv);\n\n    // Tracer\n    vec3 col = tracer(rd, ro);\n\n    // Overlay\n    if(beatCount % 2 == 0)\n    {\n        col = overlay(ro, uv, suv, col);\n    }\n    \n    // Eye\n    vec2 euv = uvmap(suv * rot(-PI * 0.25), vec2(-1.5), vec2(1.5));\n    float c = sEyeCustom(euv, 1.0 - pow(1.0 / (1.0 + beatBT), 10.0));\n    if(IsEye && c < 0.5)\n    {\n        col *= vec3(1, 0.1, 0.1);\n    }\n\n    // Post Process\n    col = postProcess(col, uv, suv);\n    \n    // ema\n    col = mix(col,texture(iChannel0,uv).rgb,0.5);\n    \n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Render\n    vec3 col = render(time);\n    // Output to screen\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}