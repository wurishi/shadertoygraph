{"ver":"0.1","info":{"id":"MllBzr","date":"1510858859","viewed":774,"name":"Karman Vortex Street FINAL","username":"riouxld","description":"Add perturbation with left click. You can change the number of obstacle in the buffers.\n\n(the shock at the start is due to large time-step and incompatbility between inlet and initial condition)","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","advection","multipass","navierstokes","jacobi","multistep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Variation of a precedent project\n// https://www.shadertoy.com/view/XtSczK\n\n// added substance advection/diffusion along the flow (like die coloring in fluid experiment)\n// you can modify the parameter (but do it in all buffer)\n\n// added multiple obstacles\n\n//corrected an error during advection\n\n// choose what field to look at by commenting the others\n//#define VELOCITY\n//#define PRESSURE\n//#define DIVERGENCE\n//#define VORTICITY\n#define DENSITY //density of smoke/die\n\n// THE FELOWWING MUST BE MODFIED IN ALL BUFFER AND IMAGE (until macro)\n\n//Select number of obstacles\n//#define ONEOBS\n#define MANYOBS\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(0.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 200.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\nconst float flowSpeed = 4.0;\n//const float epsilon = 10000000.0;\nconst float source = 1.0;\nconst float kappa = 0.0; //substance diffusion constant\nconst float alpha = 0.4; //substance dissipation rate\n\n\nconst int bandNb = 11; //number of die line\nconst int bandDens = 6; //density of die line (high mean less dense)\n\nconst float radiusPert = 0.05; // radius of perturbations\n                        \nconst int numberOfObstacles = 9;\nconst int sizeOfObstacles = 15;\n struct Obstacle {\n     int radius;\n     vec2 position;\n };\n     \nObstacle obstacles[numberOfObstacles]; \n\n//macro\n#define GetDensity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).z\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n#define GetDivergence(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).y\n#define GetVorticity(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).z\n// COLORMAP\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\n\nvec3 gray(float t)\n{\n    return vec3(t);\n}\n\nvec3 jet(float t)\n{\n    return smoothstep(0.5,0.75,t) * vec3(1,0,0)\n         + (smoothstep(0.0,0.25,t)-(smoothstep(0.75,1.0,t))) * vec3(0,1,0)\n        + (1.0-smoothstep(0.25,0.5,t)) * vec3(0,0,1);\n}\n\nvec3 wheel(float t)\n{\n    return clamp(abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n}\n\nvec3 cool(float t)\n{\n    return mix( vec3(0.0,1.0,1.0), vec3(1.0,0.0,1.0), t);\n}\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    // set obstacle\n    ivec2 obsCenter[numberOfObstacles];\n    ivec4 obsCoord[numberOfObstacles];\n    #ifdef ONEOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    #endif \n    #ifdef MANYOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.1));\n    obstacles[1] = Obstacle(sizeOfObstacles, vec2(0.15,0.3));\n    obstacles[2] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    obstacles[3] = Obstacle(sizeOfObstacles, vec2(0.15,0.7));\n    obstacles[4] = Obstacle(sizeOfObstacles, vec2(0.15,0.9));\n    obstacles[5] = Obstacle(sizeOfObstacles, vec2(0.6,0.2));\n    obstacles[6] = Obstacle(sizeOfObstacles, vec2(0.6,0.4));\n    obstacles[7] = Obstacle(sizeOfObstacles, vec2(0.6,0.6));\n    obstacles[8] = Obstacle(sizeOfObstacles, vec2(0.6,0.8));\n    #endif \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        obsCenter[k] = ivec2(floor(iResolution.xy*obstacles[k].position));\n        obsCoord[k] = ivec4(obsCenter[k]-obstacles[k].radius, obsCenter[k]+obstacles[k].radius);\n    }\n    \n    // no-flow inside obstacle\n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        if (abs(ijCoord.x - obsCenter[k].x) <= obstacles[k].radius  &&  abs(ijCoord.y - obsCenter[k].y) <= obstacles[k].radius) \n        {\n            fragColor = vec4(0.5);\n            return;\n        } \n    }\n    \n    //to compute finite difference approximaton\n\n    vec2 uv = GetVelocity(0,0); \n    float p = GetPressure(0,0); \n    float density = GetDensity(0,0); \n    float divergence = GetDivergence(0,0);\n    float vortiticy = GetVorticity(0,0);\n    \n\n    #ifdef VELOCITY\n    fragColor =vec4(1.0-hot(0.5*(uv.x+1.0)),1);\n    #endif\n    #ifdef PRESSURE\n    fragColor =vec4(1.0-hot(0.01*(p+60.0)),1);\n    #endif\n    #ifdef DIVERGENCE\n    fragColor =vec4(1.0-hot(0.1*(divergence+5.0)),1);\n    #endif\n    #ifdef VORTICITY\n    fragColor =vec4(1.0-hot(0.1*(vortiticy+5.0)),1);\n    #endif\n    #ifdef DENSITY\n    //fragColor = vec4(1.0-blackbody(1.0-density),1);\n    fragColor = vec4(blackbody(density),1);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / perturbation / advection / force\n\n\n\n// THE FELOWWING MUST BE MODFIED IN ALL BUFFER AND IMAGE (until macro)\n\n//Select number of obstacles\n//#define ONEOBS\n#define MANYOBS\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(0.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 200.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\nconst float flowSpeed = 4.0;\n//const float epsilon = 10000000.0;\nconst float source = 1.0;\nconst float kappa = 0.0; //substance diffusion constant\nconst float alpha = 0.4; //substance dissipation rate\n\n\nconst int bandNb = 11; //number of die line\nconst int bandDens = 6; //density of die line (high mean less dense)\n\nconst float radiusPert = 0.05; // radius of perturbations\n                        \nconst int numberOfObstacles = 9;\nconst int sizeOfObstacles = 15;\n struct Obstacle {\n     int radius;\n     vec2 position;\n };\n     \nObstacle obstacles[numberOfObstacles]; \n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n#define GetDensity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).z\n#define GetVorticity(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).z\n\n\n\n#define GetVelocityUV(XY) texture( iChannel3, vec2(XY)).xy\n#define GetDensityUV(XY) texture( iChannel1, vec2(XY)).z\n\nvec2 Euler(vec2 posUV){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    return dt*GetVelocityUV(posUV)/AspectRatio;\n}\n\nvec2 Runge(vec2 posUV){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    vec2 k1 = GetVelocityUV(posUV)/AspectRatio;\n    vec2 k2 = GetVelocityUV(posUV-0.5*k1*dt)/AspectRatio;\n    vec2 k3 = GetVelocityUV(posUV-0.5*k2*dt)/AspectRatio;\n    vec2 k4 = GetVelocityUV(posUV-k3*dt)/AspectRatio;\n    return dt/6.*(k1+2.0*k2+2.0*k3+k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //set die parameters\n    float bandWidth = 1.0/float(bandDens*bandNb);\n    float gapWidth = (1.0-float(bandNb)*bandWidth)/float(bandNb+1);\n    \n    // set obstacle\n    ivec2 obsCenter[numberOfObstacles];\n    ivec4 obsCoord[numberOfObstacles];\n    #ifdef ONEOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    #endif \n    #ifdef MANYOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.1));\n    obstacles[1] = Obstacle(sizeOfObstacles, vec2(0.15,0.3));\n    obstacles[2] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    obstacles[3] = Obstacle(sizeOfObstacles, vec2(0.15,0.7));\n    obstacles[4] = Obstacle(sizeOfObstacles, vec2(0.15,0.9));\n    obstacles[5] = Obstacle(sizeOfObstacles, vec2(0.6,0.2));\n    obstacles[6] = Obstacle(sizeOfObstacles, vec2(0.6,0.4));\n    obstacles[7] = Obstacle(sizeOfObstacles, vec2(0.6,0.6));\n    obstacles[8] = Obstacle(sizeOfObstacles, vec2(0.6,0.8));\n    #endif \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        obsCenter[k] = ivec2(floor(iResolution.xy*obstacles[k].position));\n        obsCoord[k] = ivec4(obsCenter[k]-obstacles[k].radius, obsCenter[k]+obstacles[k].radius);\n    }\n    \n    // no-flow inside obstacle\n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        if (abs(ijCoord.x - obsCenter[k].x) <= obstacles[k].radius  &&  abs(ijCoord.y - obsCenter[k].y) <= obstacles[k].radius) \n        {\n            fragColor = vec4(0,0,0,0);\n            return;\n        } \n    }\n    \n    // initial condition\n    if (iFrame==0) {\n        fragColor = vec4(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0,0,0);\n        return;\n    }\n    \n    // advect via semi-lagrangian method\n    vec2 posUV =fragCoord/iResolution.xy;\n    #ifdef EULER\n    vec2 posAdvUV = posUV-Euler(posUV);\n    #endif\n    #ifdef RUNGE\n    vec2 posAdvUV = posUV-Runge(posUV);\n    #endif\n    vec2 uvAdv = GetVelocityUV(posAdvUV);\n    float densityAdv = GetDensityUV(posAdvUV)/(1.0+dt*alpha);\n\n    \n    \n    // vorticity confinement\n    //to compute density finite difference approximaton\n    /*\n    float vortij = GetVorticity(0,0); \n    float vortip1j = GetVorticity(1,0); \n    float vortim1j = GetVorticity(-1,0); \n    float vortijp1 = GetVorticity(0,1); \n    float vortijm1 = GetVorticity(0,-1);\n    \n    vec3 gradVort = vec3(vortip1j-vortim1j,vortijp1-vortijm1,0.0)/dx;\n    vec3 psi = normalize(gradVort);\n    vec2 fv = cross(psi,gradVort).xy;\n    \n    uvAdv += epsilon*fv.xy;\n\t*/\n    // add driving force\n    // may be problematic with obstacle. can be removed. The simulation will have less energy,\n    // but the inlet boundary condition should be enough.\n    uvAdv += dt*force/reynold;\n    \n    if(ijCoord.x == 0)\n    {\n        \n        for (int k = 1;k<=bandNb;k++)\n        {\n            if (uvCoord.y >= gapWidth*float(k)+bandWidth*float(k-1) && \n                uvCoord.y <=  gapWidth*float(k)+bandWidth*float(k))\n            {\n                densityAdv += dt*source*4.0*uvCoord.y*(1.0-uvCoord.y);\n                break;\n            }\n        }\n    }\n    \n    // add perturbation with mouse\n    float pert = length((fragCoord.xy - iMouse.xy) / iResolution.y);   \n    if(iMouse.z > 0.0 && pert < radiusPert) {\n        vec2 temp = (vec2(fragCoord.y - iMouse.y,-fragCoord.x + iMouse.x)/ iResolution.y)/radiusPert;\n        fragColor = vec4(0.5*temp,densityAdv,0);\n        return;\n    }\n    \n    \n    \n    fragColor = vec4(uvAdv, densityAdv, 0); \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n// THE FELOWWING MUST BE MODFIED IN ALL BUFFER AND IMAGE (until macro)\n\n//Select number of obstacles\n//#define ONEOBS\n#define MANYOBS\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(0.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 200.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\nconst float flowSpeed = 4.0;\n//const float epsilon = 10000000.0;\nconst float source = 1.0;\nconst float kappa = 0.0; //substance diffusion constant\nconst float alpha = 0.4; //substance dissipation rate\n\n\nconst int bandNb = 11; //number of die line\nconst int bandDens = 6; //density of die line (high mean less dense)\n\nconst float radiusPert = 0.05; // radius of perturbations\n                        \nconst int numberOfObstacles = 9;\nconst int sizeOfObstacles = 15;\n struct Obstacle {\n     int radius;\n     vec2 position;\n };\n     \nObstacle obstacles[numberOfObstacles]; \n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n#define GetDensity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).z\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //set die parameters\n    float bandWidth = 1.0/float(bandDens*bandNb);\n    float gapWidth = (1.0-float(bandNb)*bandWidth)/float(bandNb+1);\n    \n    // set obstacle\n    ivec2 obsCenter[numberOfObstacles];\n    ivec4 obsCoord[numberOfObstacles];\n    #ifdef ONEOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    #endif \n    #ifdef MANYOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.1));\n    obstacles[1] = Obstacle(sizeOfObstacles, vec2(0.15,0.3));\n    obstacles[2] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    obstacles[3] = Obstacle(sizeOfObstacles, vec2(0.15,0.7));\n    obstacles[4] = Obstacle(sizeOfObstacles, vec2(0.15,0.9));\n    obstacles[5] = Obstacle(sizeOfObstacles, vec2(0.6,0.2));\n    obstacles[6] = Obstacle(sizeOfObstacles, vec2(0.6,0.4));\n    obstacles[7] = Obstacle(sizeOfObstacles, vec2(0.6,0.6));\n    obstacles[8] = Obstacle(sizeOfObstacles, vec2(0.6,0.8));\n    #endif \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        obsCenter[k] = ivec2(floor(iResolution.xy*obstacles[k].position));\n        obsCoord[k] = ivec4(obsCenter[k]-obstacles[k].radius, obsCenter[k]+obstacles[k].radius);\n    }\n    \n    // no-flow inside obstacle\n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        if (abs(ijCoord.x - obsCenter[k].x) <= obstacles[k].radius  &&  abs(ijCoord.y - obsCenter[k].y) <= obstacles[k].radius) \n        {\n            fragColor = vec4(0,0,0,0);\n            return;\n        } \n    }\n    \n    //to compute velocity finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    \n    \n    //to compute density finite difference approximaton\n    float densij = GetDensity(0,0); \n    float densip1j = GetDensity(1,0); \n    float densim1j = GetDensity(-1,0); \n    float densijp1 = GetDensity(0,1); \n    float densijm1 = GetDensity(0,-1); \n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv;\n        densip1j = densij;\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = 2.0*vec2(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0.0)-uv;\n        densim1j =-densij;\n        /*\n        for (int k = 1;k<=bandNb;k++)\n        {\n            if (uvCoord.y >= gapWidth*float(k)+bandWidth*float(k-1) && \n                uvCoord.y <=  gapWidth*float(k)+bandWidth*float(k))\n            {\n                densim1j = 2.0*source-densij;\n                break;\n            }\n        }\n*/\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv;\n        densijp1 = -densij;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; \n        densijm1 = -densij; \n    }\n    \n    // set obstable boundary conditions\n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n    if(ijCoord.x == obsCoord[k].x-1 && ijCoord.y >= obsCoord[k].y && ijCoord.y <= obsCoord[k].w )\n    {\n        uvip1j = -uv; \n        densip1j = -densij; \n    }\n    if(ijCoord.x == obsCoord[k].z+1 && ijCoord.y >= obsCoord[k].y && ijCoord.y <= obsCoord[k].w )\n    {\n        uvim1j = -uv; \n        densim1j = -densij;\n    }\n    if(ijCoord.y == obsCoord[k].w+1 && ijCoord.x >= obsCoord[k].x && ijCoord.x <= obsCoord[k].z )\n    {\n        uvijm1 = -uv;\n        densijm1 = -densij;\n    }\n    if(ijCoord.y == obsCoord[k].y-1 && ijCoord.x >= obsCoord[k].x && ijCoord.x <= obsCoord[k].z )\n    {\n        uvijp1 = -uv; \n        densijp1 = -densij;\n    }\n    }\n    \n    \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt/(dxPow*reynold);\n    vec2 uvDiff = (uv+coef*(uvip1j+uvim1j+uvijp1+uvijm1))/(1.0+4.0*coef);\n \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    coef = kappa*dt/(dxPow);\n    densij = (densij+coef*(densip1j+densim1j+densijp1+densijm1))/(1.0+4.0*coef);\n \n    fragColor = vec4(uvDiff,densij,0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for pressure\n\n// THE FELOWWING MUST BE MODFIED IN ALL BUFFER AND IMAGE (until macro)\n\n//Select number of obstacles\n//#define ONEOBS\n#define MANYOBS\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(0.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 200.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\nconst float flowSpeed = 4.0;\n//const float epsilon = 10000000.0;\nconst float source = 1.0;\nconst float kappa = 0.0; //substance diffusion constant\nconst float alpha = 0.4; //substance dissipation rate\n\n\nconst int bandNb = 11; //number of die line\nconst int bandDens = 6; //density of die line (high mean less dense)\n\nconst float radiusPert = 0.05; // radius of perturbations\n                        \nconst int numberOfObstacles = 9;\nconst int sizeOfObstacles = 15;\n struct Obstacle {\n     int radius;\n     vec2 position;\n };\n     \nObstacle obstacles[numberOfObstacles]; \n\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n    ivec2 obsCenter[numberOfObstacles];\n    ivec4 obsCoord[numberOfObstacles];\n    #ifdef ONEOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    #endif \n    #ifdef MANYOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.1));\n    obstacles[1] = Obstacle(sizeOfObstacles, vec2(0.15,0.3));\n    obstacles[2] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    obstacles[3] = Obstacle(sizeOfObstacles, vec2(0.15,0.7));\n    obstacles[4] = Obstacle(sizeOfObstacles, vec2(0.15,0.9));\n    obstacles[5] = Obstacle(sizeOfObstacles, vec2(0.6,0.2));\n    obstacles[6] = Obstacle(sizeOfObstacles, vec2(0.6,0.4));\n    obstacles[7] = Obstacle(sizeOfObstacles, vec2(0.6,0.6));\n    obstacles[8] = Obstacle(sizeOfObstacles, vec2(0.6,0.8));\n    #endif \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        obsCenter[k] = ivec2(floor(iResolution.xy*obstacles[k].position));\n        obsCoord[k] = ivec4(obsCenter[k]-obstacles[k].radius, obsCenter[k]+obstacles[k].radius);\n    }\n    \n    // no-flow inside obstacle\n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        if (abs(ijCoord.x - obsCenter[k].x) <= obstacles[k].radius  &&  abs(ijCoord.y - obsCenter[k].y) <= obstacles[k].radius) \n        {\n            fragColor = vec4(0,0,0,0);\n            return;\n        } \n    }\n    //to compute diveergence finite difference approximaton\n    vec2 uv = GetVelocity(0,0); // texture.x value of u this step\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    \n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    //to compute pressure finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n    float pijentry =  GetPressure(-ijCoord.x,0);\n    float pijexit =  GetPressure(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv;\n        pip1j = p;\n    }\n    if(ijCoord.x == 0)\n    {\n        uvim1j =  2.0*vec2(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0.0)-uv;\n        pim1j = -p;\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv;\n        pijp1 = p;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 =  -uv;\n        pijm1 = p;\n    }\n    \n    // set obstable boundary conditions\n    \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n    if(ijCoord.x == obsCoord[k].x-1 && ijCoord.y >= obsCoord[k].y && ijCoord.y <= obsCoord[k].w )\n    {\n        uvip1j = -uv;\n        pip1j = p;\n    }\n    if(ijCoord.x == obsCoord[k].z+1 && ijCoord.y >= obsCoord[k].y && ijCoord.y <= obsCoord[k].w )\n    {\n        uvim1j = -uv;\n        pim1j = p;\n    }\n    if(ijCoord.y == obsCoord[k].w+1 && ijCoord.x >= obsCoord[k].x && ijCoord.x <= obsCoord[k].z )\n    {\n        uvijm1 = -uv;\n        pijm1 = p;\n    }\n    if(ijCoord.y == obsCoord[k].y-1 && ijCoord.x >= obsCoord[k].x && ijCoord.x <= obsCoord[k].z )\n    {\n        uvijp1 = -uv;\n        pijp1 = p;\n    }\n    }\n    // compute velocity divergence\n    float divergence = 0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    float vortiticy = 0.5*(uvijp1.y-uvim1j.y + uvijp1.x-uvijm1.x)/dx;\n    // should use more than 1 iteration...\n    // compute pressure (auxiliary) via jacobi iteration... \n    float phi = 0.25*((pip1j+pim1j)+(pijp1+pijm1)-dxPow*reynold*divergence/dt);\n        \n    fragColor = vec4(phi,divergence,vortiticy,0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// project for incompressibility\n\n// THE FELOWWING MUST BE MODFIED IN ALL BUFFER AND IMAGE (until macro)\n\n//Select number of obstacles\n//#define ONEOBS\n#define MANYOBS\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// simulation parameters\nconst float dt = 1.0/400.0; //time-stepping\nconst vec2 force = vec2(0.0, 0.0); //constant pressure gradiant flow\nconst float reynold = 200.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //for karman, higher the better.\n\t\t\t\t\t\t\t //reynold an dt are \"coupled\" so modify both for accuracy.\nconst float flowSpeed = 4.0;\n//const float epsilon = 10000000.0;\nconst float source = 1.0;\nconst float kappa = 0.0; //substance diffusion constant\nconst float alpha = 0.4; //substance dissipation rate\n\n\nconst int bandNb = 11; //number of die line\nconst int bandDens = 6; //density of die line (high mean less dense)\n\nconst float radiusPert = 0.05; // radius of perturbations\n                        \nconst int numberOfObstacles = 9;\nconst int sizeOfObstacles = 15;\n struct Obstacle {\n     int radius;\n     vec2 position;\n };\n     \nObstacle obstacles[numberOfObstacles]; \n\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n    ivec2 obsCenter[numberOfObstacles];\n    ivec4 obsCoord[numberOfObstacles];\n    #ifdef ONEOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    #endif \n    #ifdef MANYOBS\n    obstacles[0] = Obstacle(sizeOfObstacles, vec2(0.15,0.1));\n    obstacles[1] = Obstacle(sizeOfObstacles, vec2(0.15,0.3));\n    obstacles[2] = Obstacle(sizeOfObstacles, vec2(0.15,0.5));\n    obstacles[3] = Obstacle(sizeOfObstacles, vec2(0.15,0.7));\n    obstacles[4] = Obstacle(sizeOfObstacles, vec2(0.15,0.9));\n    obstacles[5] = Obstacle(sizeOfObstacles, vec2(0.6,0.2));\n    obstacles[6] = Obstacle(sizeOfObstacles, vec2(0.6,0.4));\n    obstacles[7] = Obstacle(sizeOfObstacles, vec2(0.6,0.6));\n    obstacles[8] = Obstacle(sizeOfObstacles, vec2(0.6,0.8));\n    #endif \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        obsCenter[k] = ivec2(floor(iResolution.xy*obstacles[k].position));\n        obsCoord[k] = ivec4(obsCenter[k]-obstacles[k].radius, obsCenter[k]+obstacles[k].radius);\n    }\n    \n    // no-flow inside obstacle\n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n        if (abs(ijCoord.x - obsCenter[k].x) <= obstacles[k].radius  &&  abs(ijCoord.y - obsCenter[k].y) <= obstacles[k].radius) \n        {\n            fragColor = vec4(0,0,0,0);\n            return;\n        } \n    }\n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    \n    //to compute finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n     // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        pip1j = p;\n    }\n    if(ijCoord.x == 0)\n    {\n        pim1j = -p;\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        pijp1 = p;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        pijm1 = p;\n    }\n    \n    // set obstable boundary conditions\n    \n    for (int k = 0;k<numberOfObstacles;k++)\n    {\n    if(ijCoord.x == obsCoord[k].x-1 && ijCoord.y >= obsCoord[k].y && ijCoord.y <= obsCoord[k].w )\n    {\n        pip1j = p;\n    }\n    if(ijCoord.x == obsCoord[k].z+1 && ijCoord.y >= obsCoord[k].y && ijCoord.y <= obsCoord[k].w )\n    {\n        pim1j = p;\n    }\n    if(ijCoord.y == obsCoord[k].w+1 && ijCoord.x >= obsCoord[k].x && ijCoord.x <= obsCoord[k].z )\n    {\n        pijm1 = p;\n    }\n    if(ijCoord.y == obsCoord[k].y-1 && ijCoord.x >= obsCoord[k].x && ijCoord.x <= obsCoord[k].z )\n    {\n        pijp1 = p;\n    }\n    }\n    \n    //compute gradiant of pressure\n    vec2 pGrad = 0.5*vec2(pip1j-pim1j, pijp1-pijm1)/dx;\n    \n    //projection (helmholtz-hodge) to obtain divergence free\n    vec2 uvProj = uv-dt/reynold*pGrad;\n    \n    fragColor = vec4(uvProj,  0,0);\n}","name":"Buf D","description":"","type":"buffer"}]}