{"ver":"0.1","info":{"id":"Nt3BWf","date":"1663696075","viewed":103,"name":"4k of CAFe'2022 invitation","username":"jin_x","description":"CAFe PARTY 2022 invitation by Jin X (idea, shader graphics) & Quiet (music)\nPresented at: Deadline 2022\nWeb links:\n - https://www.pouet.net/prod.php?which=92425\n - https://youtu.be/ewWjvbIequw\n - https://soundcloud.com/dimaquiet/4k-of-cafe22","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","cafeparty","invitation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Ml2SDR","filepath":"https://soundcloud.com/dimaquiet/4k-of-cafe22","previewfilepath":"https://soundcloud.com/dimaquiet/4k-of-cafe22","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// If you don't hear music please place cursor into editor\n// and sequentially press Alt+Up then Alt+Down then Alt+Up\n// or buttons under the shader screen: pause || back |< resume >\n\n\n#define SPEED (135./120.)\n#define TIME_SHIFT 0.\n#define TEXT_COUNT 12\n#define OBJ_COUNT 8\n\nbool effects;\n\n// Bitmap of text messages\nint msg[7*TEXT_COUNT] = int[](\n    1860855986,-1572164183,-1572164183,1716153001,-1572197719,-1572198231,-1371133797,\n    63942,8777,8777,8655,8777,8777,8777,\n    776304143,692330753,692396401,791224919,690562161,688989201,-384752783,\n    64495,2593,494113,310241,494113,35361,494127,\n    36683247,35792169,35792169,29507055,8523041,8525089,8529185,\n    236743,270632,270632,203046,34081,34081,507087,\n    26240547,39356468,38832164,38814882,38830625,38830625,28995191,\n    9649353,11837737,11833637,16226787,13928741,13927721,9747753,\n    26687783,38831401,38831401,64166183,39067945,39067945,39034057,\n    -1907845944,-2125941464,-2125941464,-2042039000,-2008492760,138990889,-2026859322,\n    0,-1360237133,-1532320599,-462492231,1152001193,1152003243,0,\n    0,5709276,5571924,5444820,5576020,3497309,0);\nint text_widths[] = int[](32, 16, 32, 19, 26, 19, 26, 24, 26, 32, 32, 23);\n\n// Man polyline coords\nvec2 outline[9] = vec2[](\n    vec2(0), vec2(1.1039, 0.0711), vec2(1.5050, -1.1101),\n    vec2(1.3115, -1.1463), vec2(1.6974, -2.1151), vec2(1.3365, -2.1733),\n    vec2(1.4838, -2.5433), vec2(0.1195, -2.5433), vec2(0));\nvec2 face[17] = vec2[](\n    vec2(0.0826, -0.0739), vec2(0.1930, -2.4257), vec2(1.3515, -2.4250),\n    vec2(1.2565, -2.1862), vec2(0.8567, -2.2504), vec2(0.7462, -2.1774),\n    vec2(0.8748, -2.1678), vec2(1.5875, -2.0528), vec2(1.4522, -1.7131),\n    vec2(1.1491, -1.7437), vec2(1.2278, -1.6562), vec2(1.4218, -1.6367),\n    vec2(1.2328, -1.1622), vec2(1.1709, -1.1731), vec2(1.1178, -1.1021),\n    vec2(1.4008, -1.0492), vec2(1.0485, -0.0117));\nvec2 brow[9] = vec2[](\n    vec2(1.0847, -0.4180), vec2(0.6789, -0.3390), vec2(0.7572, -0.4601),\n    vec2(0.8763, -0.4832), vec2(0.8761, -0.5627), vec2(0.9622, -0.4999),\n    vec2(0.9907, -0.5054), vec2(0.9997, -0.5799), vec2(1.0972, -0.5213));\n\n// Logo colors\nvec3 colors[] = vec3[](\n    vec3(0,.2,1), vec3(0,.2,1), vec3(1), vec3(.1), vec3(1,1,0), vec3(1,.1,0),\n    vec3(.5), vec3(.75), vec3(.3,.5,.7), vec3(.5,.7,1), vec3(.7,.3,.3), vec3(1,.5,.5),\n    vec3(.8,.5,.15), vec3(1,.7,.3), vec3(.15,.5,.15), vec3(.3,.7,.3));\nint colidx[OBJ_COUNT+TEXT_COUNT-2] = int[](0, 1, 2, 3, 4, 5, 6, 8, 10, 6, 6, 8, 8, 10, 10, 12, 14, 14);\n\n////////////////////////////////////////////////////////////////////////////////\n// MAIN SDF                                                                   //\n////////////////////////////////////////////////////////////////////////////////\n\n// Signed Distance Function of object(s) with output of point near object and object index\nfloat sdf(vec3 pl, vec3 pt, out vec3 po, out int index)\n{\n    // Logo\n    float obj[OBJ_COUNT];\n    vec3 p1 = pl + vec3(-.25, -.75, 0);\n    obj[0] = max(  // blue\n        sdBox(p1 - vec3(0, .1, 0), vec3(.85, .85, .15)),  // screen\n        -sdStar5(rot2(p1.xy, -.2) + vec2(-.25, -.08), .55, .38)  // -star\n    );\n    obj[1] =  // blue\n        sdBox(p1 + vec3(-.75, .95, 0), vec3(.15, .05, .125));  // button\n    obj[2] = max(  // white\n        sdBox(p1, vec3(1, 1.1, .05)),  // monitor\n        -sdBox(p1 - vec3(0, .1, 0), vec3(.85, .85, 1))  // -screen\n    );\n    obj[3] = min(min(  // black\n        max(\n            sdBox(p1 - vec3(0, .1, 0), vec3(.9, .9, .1)),  // screen frame\n            -sdBox(p1 - vec3(0, .1, 0), vec3(.85, .85, 1))),  // -screen\n        max(\n            sdBox(p1, vec3(1.05, 1.15, .1)),  // logo frame\n            -sdBox(p1, vec3(1, 1.1, 1)))),  // -monitor\n        min(\n            sdPolygon(p1 - vec3(-1.5, 1.2, -.4), outline, .1),\n            sdPolygon(p1 - vec3(-1.5, 1.2, -.55), brow, .1))\n    );\n    obj[4] = sdPolygon(p1 - vec3(-1.5, 1.2, -.5), face, .1);  // yellow face\n    obj[5] = effects ? sdSphere(p1 - vec3(-.56, .60, -.6), .04) : 100.;  // red brow\n\n    // Text\n    obj[6] = obj[7] = 100.;\n    vec3 p2 = pt + vec3(0, 1.25, 1);\n    int text_index = int(time / 2. ) % TEXT_COUNT;\n    obj[6] = sdBox(p2, vec3(float(text_widths[text_index])*.05+.05, .4, .1));\n    if (obj[6] < dmin) {\n        glass = vec3(.1, .1, .1);\n        obj[6] = 100.;\n        for (int j = 0; j < 7; ++j) {\n            for (int i = 0; i < text_widths[text_index]; ++i) {\n                if ((msg[j + text_index * 7] >> i & 1) != 0) {\n                    vec3 ptt = p2 - vec3(float(i*2-text_widths[text_index])*.05+.05, (3.5-float(j))*.1-.05, 0);\n                    obj[6] = min(obj[6], sdBox(ptt, vec3(.05)));\n                    obj[7] = min(obj[7], sdSphere(ptt, .07));\n                }\n            }\n        }\n    }\n\n    // Store point near object and object index    \n    int idx = 0;\n    for (int i = 1; i < OBJ_COUNT; ++i) {\n        if (obj[i] < obj[idx]) {\n            idx = i;\n        }\n    }\n    po = idx < 6 ? p1 : p2;\n    index = idx < 6 ? colidx[idx] : colidx[6+text_index] + idx-6;\n    // Return combined SDF\n    return obj[idx];\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// MAIN CODE                                                                  //\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust time and normalize pixel coordinates (x = -xres/yres*0.5..xres/yres*0.5, y = -0.5..0.5)\n    time = (iTime + TIME_SHIFT) * SPEED;\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv *= vec2(max(iResolution.x/iResolution.y, 1.), max(iResolution.y/iResolution.x, 1.));\n\n    // Glitches\n    if (mod(time, 52.) >= 50. && mod(time, .125) < .0625) {\n        uv.x += rand(uv) * sin(time * 3.14159265) * .25;\n    }\n    float glitch_pos = mod(time*.5, 8.) - 4.5;\n    float glitch_shift = glitch_pos - uv.y;\n    uv.x += .00025 / glitch_shift;\n    \n\n    // Background and rays\n    float twist = length(uv)*sin(time/200.)*(1.-rand(uv)*.03);\n    float intensity = sinr(atan(uv.y, uv.x)*20. + time*10. + sin(length(uv)*30.)*twist*sint(1.57079633), .25, .75);\n    vec3 col = vec3(intensity*.1, intensity*.4, intensity*.2);\n\n    vec3 rp = vec3(0, 0, -5.);  // ray origin point coordinate\n    vec3 rd = normalize(vec3(uv, 1));  // ray direction\n\n    // Position of objects relative to center (applied before rotation)\n    vec3 pos = vec3(sint(speed.x)*1.5, sint(speed.y), sint(speed.z)*1.2) * .2;\n\n    // Open man's mouth\n    effects = mod(time, 16.) >= 8.;\n    if (effects) {\n        face[8] -= vec2(-.04, .1);\n        face[9].y -= .1;\n        face[10].y += .1;\n        face[11] += vec2(-.04, .1);\n    }\n\n    // Ray Marching\n    for (int i = 0; i < iters; ++i) {\n        int index;  // object index\n        vec3 po; // point near object (almost on object)\n        vec3 pl = sin_rotate(rp - pos, vec3(1., .7, 0), vec3(.5), twist);  // rotate ray point for logo objects\n        vec3 pt = sin_rotate(rp - pos, vec3(0,  3.14159265, 1.7), vec3(0, .3, 0), 0.);  // rotate ray point for texts\n        float dist = sdf(pl, pt, po, index);  // get nearest distance to objects, point near object and object index\n        if (dist > dmax) { break; }  // too far (ray goes out of objects)\n        if (dist < dmin) {  // close enough (hit to object)\n            intensity = 1. - pow(float(i)*.05, 2.2);\n            col = intensity * colors[index];\n            if (effects) {\n                if (index == 0 && po.z <= -.15) {\n                    vec2 p = (po.xy - vec2(0, .1)) / .85;\n                    int eff_no = int(mod(time / 16., 5.));\n                    if (eff_no == 0) col = julia(p);\n                    else if (eff_no == 1) col = plasma(p);\n                    else if (eff_no == 2) col = cube(p);\n                    else if (eff_no == 3) col = tube(p);\n                    else if (eff_no == 4) col = colbars(p);\n                    col = intensity * col * (rand(p)*.4 + .8);\n                } else if (index == 1) {\n                    col = intensity * vec3(.7, .1, 0.);\n                }\n            }\n            break;\n        }\n        rp += rd * dist;  // move ray point in direction 'rd' by distance 'dist'\n    }\n\n    // Output to screen\n    fragColor = vec4(col + glass, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float time;\n\nfloat dmin = .001;\nint iters = 64;  // maximal number of iterations\nfloat dmax = 7.;  // maximal distance from ray origin point\nvec3 speed = vec3(2, 1.5, 2.5);  // position/rotation change speeds\nvec3 glass = vec3(0);\n\n////////////////////////////////////////////////////////////////////////////////\n// SIGNED DISTANCE FUNCTIONS                                                  //\n////////////////////////////////////////////////////////////////////////////////\n\n// SDFs are taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPolygon(vec3 p, vec2 v[9], float t)\n{\n    float d = dot(p.xy-v[0],p.xy-v[0]);\n    float s = 1.;\n    for (int i=0, j=8; i<9; j=i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w = p.xy - v[i];\n        vec2 b = w - e*clamp(dot(w,e)/dot(e,e), 0., 1.);\n        d = min(d, dot(b,b));\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if (all(c) || all(not(c))) s*=-1.0;  \n    }\n    return max(s*sqrt(d), abs(p.z) - t);\n}\n\nfloat sdPolygon(vec3 p, vec2 v[17], float t)\n{\n    float d = dot(p.xy-v[0],p.xy-v[0]);\n    float s = 1.;\n    for (int i=0, j=16; i<17; j=i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w = p.xy - v[i];\n        vec2 b = w - e*clamp(dot(w,e)/dot(e,e), 0., 1.);\n        d = min(d, dot(b,b));\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if (all(c) || all(not(c))) s*=-1.0;  \n    }\n    return max(s*sqrt(d), abs(p.z) - t);\n}\n\nfloat sdStar5(vec2 p, float r, float rf)\n{\n    vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// EXTRA FUNCTIONS                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\n// Random number\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p + time, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Sine in range from vmin to vmax\nfloat sinr(float x, float vmin, float vmax)\n{\n    return (sin(x)*.5+.5) * (vmax-vmin) + vmin;\n}\n\n// Sine of time with specified speed in range from vmin to vmax\nfloat sint(float speed, float vmin, float vmax)\n{\n    return sinr(time*speed, vmin, vmax);\n}\n\n// Sine of time with specified speed\nfloat sint(float speed)\n{\n    return sin(time*speed);\n}\n\n// Rotate 2D point p by angle a\nvec2 rot2(vec2 p, float a)\n{\n    float sin_a = sin(a);\n    float cos_a = cos(a);\n    return p*mat2(cos_a, -sin_a, sin_a, cos_a);\n}\n\n// Rotate 3D point p by angles time*a\nvec3 rotate(vec3 p, vec3 a)\n{\n    p.xz = rot2(p.xz, time*a.y);  // around axis Y\n    p.yz = rot2(p.yz, time*a.x);  // around axis X\n    p.xy = rot2(p.xy, time*a.z);  // around axis Z\n    return p;\n}\n\n// Rotate 3D point p by angles time*a + ca by sine\nvec3 sin_rotate(vec3 p, vec3 a, vec3 v, float c)\n{\n    p.xz = rot2(p.xz, sin(time*a.y)*v.y + c);  // around axis Y\n    p.yz = rot2(p.yz, sin(time*a.x)*v.x + c);  // around axis X\n    p.xy = rot2(p.xy, sin(time*a.z)*v.z + c);  // around axis Z\n    return p;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// EFFECT FUNCTIONS                                                           //\n////////////////////////////////////////////////////////////////////////////////\n\n// Julia set\nvec3 julia(vec2 p)\n{\n    float zoom = pow(1.5, sin(time*2.)+.5);\n    vec2 xy = rot2(p, time) * zoom;\n\n    int iter;\n    float xp = cos(time) * 0.5;\n    float yp = sin(time) * 0.5;\n    for (iter = 0; iter < 64; ++iter) {\n        vec2 xy2 = xy * xy;\n        if (xy2.x + xy2.y > 4.0) { break; }\n        xy = vec2(xy2.x - xy2.y + xp, 2.0 * xy.x * xy.y + yp);\n    }\n\n    vec3 col;\n    if (iter < 64) {\n        float c = 1. - pow(float(iter) / 64., .333);\n        col = vec3(1.-c, (1.-c)*.25, c);\n    } else {\n        col = vec3(1, .25, 0);\n    }\n    return col;\n}\n\nvec3 plasma(vec2 p)\n{\n    float s=sin(time*1.2+p.x)*5.;\n    float c=cos(time*2.+p.y)*5.;\n    p *= 7.;\n    float col;\n    col = (sin(s+p.x) + cos(c+p.y)) * .25 + .5;\n    return vec3(.3+.3*cos(6.2832 * (col + vec3(0,.33,.67))));  // rainbow colors\n}\n\nvec3 cube(vec2 p)\n{\n    // Ray Marching preparations\n    vec3 rp = vec3(0, 0, -2);  // ray origin point coordinate\n    vec3 rd = normalize(vec3(p, 1));  // ray direction\n\n    // Ray Marching\n    float intensity = 0.;\n    for (int i = 0; i < 64; ++i) {\n        int index;  // object index\n        vec3 po; // point near object (almost on object)\n        vec3 p = rotate(rp + vec3(0, 0, sin(time*2.)), speed);  // rotate ray point for object 1 (rotate object 1 if fact)\n        float dist = max(  // get nearest distance to objects, point near object and object index\n            sdBox(p, vec3(.5)),\n            -sdSphere(p, .6)\n        );\n        if (dist > 3.) { break; }  // too far (ray goes out of objects)\n        if (dist < dmin) {  // close enough (hit to object)\n            intensity = 1. - pow(float(i)*.05, 2.2);\n            break;\n        }\n        rp += rd * dist;  // move ray point in direction 'rd' by distance 'dist'\n    }\n    return vec3(0, max(intensity, .2), .5);\n}\n\nvec3 tube(vec2 p)\n{\n    float angle = (atan(p.y, p.x) + time)*12.;\n    float len = length(p);\n    return vec3(sinr(20./len + time*10., 0., .75), sinr(angle, 0., .5), sinr(-angle, 0., .75));\n}\n\nvec3 colbars(vec2 p)\n{\n    vec3 pos = vec3(sin(time), sin(time*1.2), sin(time*1.5));\n    return (.25 - abs(pos - p.y)) * 4.;\n}\n","name":"Common","description":"","type":"common"}]}