{"ver":"0.1","info":{"id":"sdcSRH","date":"1632595576","viewed":479,"name":"Ocean waves ride","username":"sergei_am","description":"POM for waves + some simple foam shading, refraction + reflection","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["waves","parallax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PARALLAX_DEPTH = 2.8;\nconst int   PARALLAX_STEPS = 32;\nconst float\tPI_OVER_180 = 3.14159265359 / 180.0;\nconst float CAMERA_VERTICAL_FOV = 60.0;\nconst vec3  SUN_DIRECTION = normalize(vec3(1.0,1.0,1.0));\nconst float SEABED_DEPTH = -1.0;\nconst vec3  WATER_COLOR = vec3(0.4,0.7,1.0)*0.5;\n\nvec3 camera_ray(in vec3 pos, in float y_angle_deg, in float x_angle_deg, in float z_angle_deg, in float fov_y_deg, in vec2 coord, in vec3 iResolution)\n{\n    coord = coord / iResolution.xy * 2.0 - vec2(1.0,1.0);\n    \n    float aspect = iResolution.x / iResolution.y;\n    float tan_fov = sin(fov_y_deg*PI_OVER_180*0.5) / cos(fov_y_deg*PI_OVER_180*0.5);\n    \n    float y = coord.y * tan_fov;\n    float x = coord.x * tan_fov * aspect;\n    float z = 1.0;\n    \n    float xa = x_angle_deg * PI_OVER_180, ya = y_angle_deg * PI_OVER_180, za = z_angle_deg * PI_OVER_180;\n    \n    float xs = sin(xa), xc = cos(xa);\n    float ys = sin(za), yc = cos(za);\n    float zs = sin(ya), zc = cos(ya);\n    \n    mat3 xr = mat3(\n    \t1.0, 0.0, 0.0,\n\t\t0.0,  xc,  xs,\n\t\t0.0, -xs,  xc);\n    \n    mat3 yr = mat3(\n\t\t yc, 0.0,  ys,\n\t\t0.0, 1.0, 0.0,\n\t\t-ys, 0.0,  yc);\n    \n    mat3 zr = mat3(\n\t\t zc,  zs, 0.0,\n\t\t-zs,  zc, 0.0,\n\t\t0.0, 0.0, 1.0);\n   \n    return normalize(vec3(x,y,z) * xr * yr * zr );\n}\n\nfloat noise(float x)\n{\n    return sin(x*0.4) * sin(x*0.05 + 0.45);\n}\n\nfloat get_foam_for_position(in vec2 pos)\n{\n    // foam perturbed coordinates\n    vec2 foam_uv = pos;\n    \n    float pos_noise = abs(sin(pos.x*1.0)*sin(pos.y*1.0));\n    \n    float fx = pos.y;\n    float fy = pos.x;\n    \n    foam_uv.x += cos(fx*2.0 + iTime*1.0)*0.17;\n    foam_uv.y += sin(fy*2.0 + iTime*1.0)*0.17;\n    \n    // process blob texture to produce foam-like pattern\n    float foam = texture(iChannel0, foam_uv).x;\n    foam = 1.0 - foam;\n    foam = min( foam*1.2, 1.0 );\n    foam = pow( foam, 4.0 );\n    foam = min( foam*1.5, 1.0 );\n    \n    return foam;\n}\n\nvec4 get_water_surface(in vec2 pos, in float sdf)\n{\n    // coastal pulse wave\n    float wave_pulse = sdf + iTime * 0.2;\n    wave_pulse = fract(wave_pulse);\n    \n    // construct wave shape\n    float wave_front = pow(wave_pulse, 4.0);\n    float wave_back = pow(1.0 - wave_pulse, 1.0);\n    \n    float wave_height = max(wave_front, wave_back);\n    wave_height = wave_front + wave_back;\n\n\tfloat foam = get_foam_for_position(pos);\n    \n    //foam *= abs(sin(pos.x/2.0));\n    \n    float wave = max( 0.0, pow(wave_height,8.0)*foam );\n    \n    float noise1 = abs(sin(pos.x*4.0));\n    float noise2 = abs(sin(pos.x*0.017));\n    float noise3 = pow(abs(sin(pos.x*2.25)), 0.25);\n    \n    float front_mask = wave_front - 0.5;\n    front_mask -= 0.1*noise1;\n    front_mask -= 0.1*noise2;\n    front_mask -= 0.2*noise3;\n    \n    front_mask = max(0.0, front_mask);\n    \n    foam *= front_mask*8.0 + pow(wave_back, 8.0);\n    \n    foam  = mix(foam, 0.7, pow(wave_height,16.0));\n    \n    foam *= abs(sin(pos.x/2.0));\n    \n    vec3 color = vec3(foam, foam, foam);\n    return vec4(color, wave_height);\n}\n\nfloat sdf(in vec3 pos)\n{\n    float v = abs(sin(pos.x*17.0));\n    v = pow(v, 128.0);\n\n    return pos.z * 0.125 - 100.0 + sin(pos.x/5.0)*0.2 + sin(pos.x/1.0)*0.03 + sin(pos.x*32.0)*v*0.01;\n}\n\nvec3 compute_parallax_waves(in vec3 eye, in vec3 ray, in float time, out vec3 intersect_pos)\n{\n    //eye.xz *= 0.125;\n    //ray.xz *= 0.125;\n\n    vec3 pos_bottom = eye + ray * eye.y / -ray.y;\n    \n    float depth_fade = length(eye.xz - pos_bottom.xz)/50.0;\n    float parallax_depth = PARALLAX_DEPTH;// * (1.0 - min( 1.0, depth_fade ) );\n    \n    //parallax_depth *= 1.0 + sin(pos_bottom.x/5.0)*sin(pos_bottom.z/5.0)*0.5;\n    \n    vec3 pos_top = pos_bottom - ray * parallax_depth / -ray.y;\n    \n    //pos.y += noise(pos.x);\n    //pos2.y += noise(pos2.x);\n    \n    vec3 pos = pos_top;\n    vec3 pstep = (pos_bottom - pos_top) * (1.0/float(PARALLAX_STEPS));\n    \n    vec4 wave;\n    \n    wave = get_water_surface(pos_bottom.xz, sdf(pos_bottom));\n    wave = get_water_surface(pos_top.xz, sdf(pos_top));\n    \n    //wave.x = wave.y = wave.z = fract(pos_bottom.z*0.25);\n    //return wave.xyz;\n    \n    vec4 prev_wave = wave;\n    float prev_delta = 0.0;\n    \n    for(int i=0; i<PARALLAX_STEPS; ++i)\n    {\n        wave = get_water_surface(pos.xz, sdf(pos));\n        wave.w *= parallax_depth;\n        \n        float delta = wave.w - pos.y;\n        \n        if(delta > 0.0)\n        {\n            pos += pstep * delta / (prev_delta - delta);\n            \n            intersect_pos = pos;\n            \n            wave = get_water_surface(pos.xz, sdf(pos));\n            return wave.xyz;\n        }\n        pos += pstep;\n        prev_wave = wave;\n        prev_delta = delta;\n    }\n    intersect_pos = pos_bottom;\n    return wave.xyz;\n}\n\nfloat detail_surface(in vec3 pos)\n{\n    pos.x += sin(pos.z*20.5 + iTime)*0.043;\n    pos.z += cos(pos.x*20.5 + iTime)*0.043;\n\n    return 1.0 - abs(sin(pos.x*6.0)*sin(pos.z*6.0));\n}\n\nvec3 get_surface_normal(in vec3 pos, in vec3 eye)\n{\n    float h00 = get_water_surface(pos.xz, sdf(pos)).w;\n    vec3  pos10 = pos + vec3(0.1,0.0,0.0);\n    float h10 = get_water_surface(pos10.xz, sdf(pos10)).w;\n    vec3  pos01 = pos + vec3(0.0,0.0,0.1);\n    float h01 = get_water_surface(pos01.xz, sdf(pos01)).w;\n    \n    float ds00 = detail_surface(pos);\n    float ds10 = detail_surface(pos + vec3(0.1, 0.0, 0.0));\n    float ds01 = detail_surface(pos + vec3(0.0, 0.0, 0.1));\n    \n    float dist = length(pos - eye);\n    \n    float detail_weight = mix(0.008, 0.0, min( 1.0, dist/20.0));\n    \n    h10 += (ds10 - ds00)*detail_weight;\n    h01 += (ds01 - ds00)*detail_weight;\n    \n    return normalize(vec3(h10 - h00, 0.1, h01-h00));\n}\n\nvec3 get_sea_bottom(in vec3 eye, in vec3 ray)\n{\n    vec3 pos = eye + ray * (eye.y - SEABED_DEPTH) / -ray.y;\n   \n    vec3 color = texture(iChannel1, pos.xz * 0.2).xyz;\n    color *= vec3(0.6, 0.25, 0.05);\n    color = mix(WATER_COLOR, color, exp(-length(pos - eye)*0.2));\n    \n    return color;\n}\n\nvec3 refract_water(in vec3 ray, in vec3 N)\n{\n    return normalize(ray - N*0.3);  // quite fake, but cheap\n}\n\nvec3 get_skybox(in vec3 ray)\n{\n    vec3 cbm = texture(iChannel2, ray.xyz).xyz;\n    cbm = mix(WATER_COLOR, cbm, clamp((ray.y - 0.05)*15.0, 0.0, 1.0));\n    return cbm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = iTime * 1.5;\n    float R = 0.0;\n    vec3 eye = vec3(iTime * 5.0, 5.0, 0.0);\n    vec3 angles = vec3(-35.0, 0.0, 65.0);\n    \n    vec3 ray = camera_ray(eye, angles.y, angles.x, angles.z, CAMERA_VERTICAL_FOV, fragCoord, iResolution);\n    \n    vec3 color;\n    if( ray.y < 0.0 )\n    {\n        vec3 intersect_pos;\n        color = compute_parallax_waves(eye, ray, iTime, intersect_pos);\n        vec3 N = get_surface_normal(intersect_pos, eye);\n        \n        vec3 wray = refract_water(ray, N);\n        vec3 sea_bottom = get_sea_bottom(intersect_pos, wray);\n        \n        vec3 reflection = get_skybox(reflect(ray, N));\n        float reflectivity = 1.0 - abs(dot(N, -ray));\n        \n        reflectivity = pow(reflectivity, 3.0);\n        \n        sea_bottom = mix(sea_bottom, reflection, reflectivity);\n       \n        color += sea_bottom;\n    }\n    else\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}