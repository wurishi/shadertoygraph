{"ver":"0.1","info":{"id":"ldcSRS","date":"1460405591","viewed":293,"name":"Temporal Tricks","username":"akohdr","description":"Tiling a voxel model in space and time.\nMouse acts as temporal scrubber. (mouse.x time +/-center screen, mouse.y speed)\nB - toggles bounds, Cursor/WASD - model offset and world spin\nSPC - resets","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// flag for bounds support 'B' toggles \n#define SHOW_BOUNDS\n\n// Keyboard\n#define KEY_B 66.\n#define isToggle(k) texture(iChannel3,vec2(k/256.,1.)).x>.0\n\n// Storage \n#define ADDR_OFFSET vec2(10.,10.)\n#define ADDR_BEARING vec2(20.,10.)\n#define ADDR_TIME vec2(40.,10.)\n#define LOAD(a) texture(iChannel0,(a+0.5)/iChannelResolution[0].xy,-100.0)\n\n#define BOB_H 3.5\n#define EYE_D 40.\n#define MAX_RAY 150    \n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nvoid cVoxel(out vec4 c, const in vec4 P );\n\nvec4 offset,   // spacetime\n     bearing,  // orientation\n     timebase; // timebase\n\nvoid VxViewer(out vec4 fc,             // fragColor\n         const in vec2 P,              // fragCoord\n         const in vec3 R,              // iResolution\n        const in float T ) {           // timebase\n    \n    const vec3 B0 = vec3(0),\n               B1 = vec3(.6),\n               B2 = vec3(.3);\n    vec2 b = vec2(sin(T+bearing.x), cos(T+bearing.x)),\n         //t = vec2(sin(T), cos(T)),\n         t = b,\n         //t = vec2(.9),\n         l = P.xx / R.xx - .5;\n    vec3 r = vec3(l.y*t.y - .8*t.x, (P.y/R.y - .5)*R.y/R.x, .8*t.y + l.x*t.x),\n         //r = vec3(l.y*b.y-.8*b.x, (P.y/R.y - .5)*R.y/R.x, .8*b.y + l.x*b.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n\n    for(int i=MAX_RAY; i>0; i--) {\n        vec4 spacetime = vec4(f + offset.xyz, T);\n\n\t\tcVoxel(fc, spacetime);\n        if(fc.w>0.){\n            fc.xyz += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return; // early exit\n        }\n        \n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n                \n        f += m*q;\n        s += m*d;\n    }\n    fc.w = -1.;  // use alpha channel sign for hit flag\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\toffset = LOAD(ADDR_OFFSET);    \n    bearing = LOAD(ADDR_BEARING);\n    timebase = LOAD(ADDR_TIME);\n    \n    vec3 ir2 = iResolution/vec3(3,2,1);\n    vec2 mf = mod(fragCoord,ir2.x),\n         df = floor(fragCoord / ir2.xy);\n    \n    // we tile the viewer with different timebases\n    VxViewer(fragColor, \n             mf,\n             ir2,\n             (df.x-3.*(2.*df.y-1.))*timebase.x\n            );\n    \n//    bool hit = fragColor.w>0.;\n}\n\n#define TEMPORAL_MODEL(p,c,r) length(p.xyz-c)<(mod(T/5.,20.)<7.?r:r*sin((tan(.1*T))*(.3*length(p.xxy))))\n#define SPHERE(p,c,r) length(p.xyz-c)<r\n#define PULSATING_SPHERE(p,c,r) SPHERE(p,c,r+3.*sin(2.*p.w))\n\n#define MODEL TEMPORAL_MODEL\n//#define MODEL PULSATING_SPHERE\n\n// User supplied temporal voxel model\nvoid cVoxelModel(inout vec4 c, const in vec4 P) \n{\n    float T = P.w,\t\t    // timebase (T is used by RES macro)\n          res = 1.,\n          rPlanet = 8.,\t\t// planet radius\n          rMoon = 3.;\t\t// moon radius\n\n    vec3 orbit = vec3(sin(T), 1, cos(T)),\n         pPlanet = vec3(0),\n         pMoon = orbit*vec3(22.,5.,16.);\n    \n    // adjust size/positions for voxel resolution\n    rPlanet *= res;\n    rMoon *= res;\n    pMoon *= res;\n        \n\t// hit test on planet\n    if (MODEL(P, pPlanet, rPlanet)) {\n        // local space based colouring\n        c = vec4(normalize(orbit.zyx*P.xyz),1.);\n        return;\n    }\n\n    // hit test on moon\n    if (PULSATING_SPHERE(P, pMoon, rMoon)) {\n        // time based colouring\n        c = vec4(.2+sin(T)*vec3(.7),1.);\n        return;\n    }\n}\n\n#define ineq(a,v,b) ((a)<(v)&&(v)<(b))\n\n// Simple Voxel model of clock\nvoid cVoxelClock(inout vec4 c, const in vec4 P)\n{\n    vec4 c1;\n    float t = P.w/2.,\n          x1 = P.x*sin(t), \n          y1 = P.y*cos(t),\n          x2 = P.x*sin(12.*t), \n          y2 = P.y*cos(12.*t),\n          l = length(P.xy);\n    if(abs(P.z)<2.)\n        if (l<11.5)\n            if(l<7. && ineq(.0,x1+y1,1.)) c = vec4(1.,.0,.0,1.);\n            else if(ineq(.0,x2+y2,1.)) c = vec4(0.,.1,.0,1.);\n        else\n\t\tif(l>11.4) c = vec4(.4);\n            \n    c -= .01*vec4(c1.xyz,.05);            \n}\n\n// VxViewer consults cVoxel for existence/colour(c) of voxel at point in spacetime(P)\nvoid cVoxel(out vec4 c, const in vec4 P ){\n\n    c = vec4(0);\n    cVoxelModel(c,P);\n    cVoxelClock(c,P-offset);\n\n#ifdef SHOW_BOUNDS \n    if(isToggle(KEY_B)){\n    // bounding markers (white positive direction  .rgb <=> .xyz)\n    const vec4 L = vec4(8.),\n               H = vec4(.5);\n    vec4 ap = abs(P); \n\tbvec4 b = lessThan(ap,L);\n    if(length(ap.xyz-8.)<3. && (b.x&&b.y&&b.z)) c = H+.3*sign(P); //local corners\n    \n    //if(length(abs(P.xyz)-L.xyz)<.5) c = H+.3*sign(P); //local\n    \n    if(length(abs(P.xyz-offset.xyz)-L.xyz)<.5) c = H+.3*sign(P); //global\n\n    // world origin\n    if(length(P.xyz-offset.xyz)<.5) c = vec4(0.,1.,0.,1.);\n    }\n#endif\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This buffer provides persistence, mouse and keyboard support\n\n// Mouse variable support\n#define SCALE(p,m) ((p-iResolution.xy/2.) *(m/iResolution.xy))\n#define SCALEM(m) SCALE(iMouse.xy, m)\n\n// Keyboard support ---------------------------------------\n#define KEYB_CH iChannel3\n// Keyboard constants definition\n#define KC(k) float(k)/256.\nconst float KEY_BSP   = KC(8),   KEY_SP   = KC(32),\n            KEY_LEFT  = KC(37),  KEY_UP   = KC(38),\n            KEY_RIGHT = KC(39),  KEY_DOWN = KC(40),\n            KEY_COMMA = KC(188), KEY_PER  = KC(190),\n    \t\tKEY_1 = KC(49), KEY_2 = KC(50), KEY_3 = KC(51), \n            KEY_4 = KC(52), KEY_5 = KC(53), KEY_6 = KC(54), \n            KEY_7 = KC(55), KEY_8 = KC(56), KEY_9 = KC(57), \n            KEY_0 = KC(48), \n    \t\tKEY_N1 = KC(97),  KEY_N2 = KC(98),  KEY_N3 = KC(99), \n            KEY_N4 = KC(100), KEY_N5 = KC(101), KEY_N6 = KC(102), \n            KEY_N7 = KC(103), KEY_N8 = KC(104), KEY_N9 = KC(105), \n            KEY_N0 = KC(96), \n            KEY_A = KC(65), KEY_B = KC(66), KEY_C = KC(67),\n            KEY_D = KC(68), KEY_E = KC(69), KEY_F = KC(70),\n            KEY_G = KC(71), KEY_H = KC(72), KEY_I = KC(73),\n            KEY_J = KC(74), KEY_K = KC(75), KEY_L = KC(76),\n            KEY_M = KC(77), KEY_N = KC(78), KEY_O = KC(79),\n            KEY_P = KC(80), KEY_Q = KC(81), KEY_R = KC(82),\n            KEY_S = KC(83), KEY_T = KC(84), KEY_U = KC(85),\n            KEY_V = KC(86), KEY_W = KC(87), KEY_X = KC(88),\n            KEY_Y = KC(89), KEY_Z = KC(90);\n#define isKey(k) (texture(KEYB_CH,vec2(k)).x>.0)\n#define isToggle(k) texture(KEYB_CH,vec2(k,1.)).x>.0\n// Following macros expand to minimal key test -------------\n#define QK(a,b) if(isKey(a)||isKey(b))return\n// Storage -------------------------------------------------\n#define NEAR(p,a) if(length(p-a)<1.)\n#define LOADP(p,a,v) NEAR(p,a){v=texture(iChannel0,(a+0.5)/iChannelResolution[0].xy,-100.0);return;}\n#define STOREPC(a,v,p,c) NEAR(p,a){c=v;return;}\n// Mem Layout ----------------------------------------------\n#define ADDR_OFFSET  vec2(10.,10.)\n#define ADDR_BEARING vec2(20.,10.)\n#define ADDR_ACC     vec2(30.,10.)\n#define ADDR_TIME    vec2(40.,10.)\n// ---------------------------------------------------------\n\n// IMPORTANT!\n// currently single action mapping (KISS)\n// for multi-key actions need to use something like bitfields\n\n// state vectors\nvec4 acc,\n     offset,\n     bearing,\n     timebase;\n\n// action enum\n#define ACT_NONE -1\n#define ACT_RST 1\n#define ACT_MOUSE 10\n#define ACT_UP 12\n#define ACT_DN 13\n#define ACT_LT 14\n#define ACT_RT 15\n#define ACT_OFF 20\n\n// maps key code to action\nint inputScan() {\n\tQK(KEY_W, KEY_UP)\t\tACT_UP;\n\tQK(KEY_A, KEY_LEFT)\t\tACT_LT;\n\tQK(KEY_S, KEY_DOWN)\t\tACT_DN;\n\tQK(KEY_D, KEY_RIGHT)\tACT_RT;\n\tQK(KEY_SP,KEY_SP)\t\tACT_RST;\n    \n    // world offsets\n    vec3 d = -vec3(1);\n    #define OK(a,b,c) if(isKey(a)||isKey(b)) {c;return ACT_OFF;}\n    OK(KEY_J,KEY_N4, offset.x -= d.x);\n    OK(KEY_U,KEY_N7, offset.x += d.x);\n    OK(KEY_K,KEY_N5, offset.y -= d.y);\n    OK(KEY_I,KEY_N8, offset.y += d.y);\n    OK(KEY_O,KEY_N9, offset.z -= d.z);\n    OK(KEY_L,KEY_N6, offset.z += d.z);\n\n    if(iMouse.z>0.) return ACT_MOUSE;\n\n    return ACT_NONE;\n}\n\nbool react(const in int action) {\n    const float dTurn = .1,\n                dAcc = 1.;\n    #define CASE(e) if(action==e)\n    \n    CASE(ACT_LT) bearing.x += dTurn;\n    CASE(ACT_RT) bearing.x -= dTurn;\n    \n    CASE(ACT_UP) acc -= dAcc;\n    CASE(ACT_DN) acc += dAcc;\n\n    CASE(ACT_RST) {\n        offset = vec4(0.);\n        bearing = vec4(0.);\n        acc = vec4(0.);\n    }\n        \n    return true;\n}\n\nvoid updateState() {\n    offset.z += acc.z*sin(bearing.x);\n    offset.x += acc.z*cos(bearing.x);\n}\n\nvoid load(const in vec2 p){\n    #define LOAD(a,v) LOADP(p,a,v)\n\tLOAD(ADDR_OFFSET, offset);\n    LOAD(ADDR_BEARING, bearing);\n    LOAD(ADDR_ACC, acc);\n    LOAD(ADDR_TIME, timebase);\n}\n\nvoid store(out vec4 c, const in vec2 p){\n    #define STORE(a,v) STOREPC(a,v,p,c)\n    STORE(ADDR_OFFSET, offset);\n    STORE(ADDR_BEARING, bearing);\n    STORE(ADDR_ACC, acc);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    load(fragCoord);\n\n    if(iMouse.z>0.) {\n        // variable temporal scrubber\n        vec2 sm = SCALEM(vec2(4));\n        timebase.x = sm.x * (.5+sm.y);\n    } else \n    \ttimebase.x = iTime/3.;\n    STOREPC(ADDR_TIME, timebase,fragCoord,fragColor);\n        \n    // try to minimize work \n    int action = inputScan();\n    if(action>0) {\n\n        if(react(action)) {\n            updateState();\n\t        store(fragColor, fragCoord);\n            return;\n        }\n    }\n\n    // maintain state if no action\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}