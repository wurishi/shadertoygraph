{"ver":"0.1","info":{"id":"XfKcDK","date":"1732419373","viewed":133,"name":"Anti-aliasing test","username":"sh1boot","description":"Left side uses naive mix(floor(x), floor(x)+1, fract(x)) interpolation.\nRight side uses mix(even(x), odd(x), abs(fract(x/2)*2-1)) interpolation to avoid discontinuities which cause fwidth() to glitch.\n\nLeft side should look bad.","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["example","antialiasing","demonstration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Code is in Buffer A; this just upscales for visibility. */\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    ivec2 uv = ivec2(floor(fragCoord)) / scale;\n    fragColour = texelFetch(iChannel0, uv, 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 lookup(ivec2 uv) {\n    ivec3 h = ivec3(3*uv.x ^ (uv.y + 13), 1 + (uv.x ^ uv.y), 7*uv.x ^ 5 * uv.y);\n    return vec4((cos(vec3(h)) + 1.0) * 0.5, 1.0);\n}\n\nfloat aa_lessThan(float x, float y) {\n    /* fwidth(x) tells us (very approximately) how much x changes across\n     * the width of a pixel.  if we normalise x to cross zero at the desired \n     * crossover point, then x==0 means the threshold was crossed halfway\n     * across the pixel (half each side), values less than -fw are fully one\n     * side, and values greater than fw are fully the other side.  So we\n     * consider -fw < x < fw to be partial coverage needing a mixture of\n     * values.\n     */\n     float fw = fwidth(y - x);\n    return smoothstep(-fw, fw, y - x);\n}\nvec4 example(vec2 uv, bool left) {\n    ivec2 c[4];\n    vec2 w_a, w_b;\n    if (left) {\n        /* calculate coordinates of floor(uv)+vec2([0..1],[0..1]),\n         * and calculate weights accordingly\n         */\n        ivec2 i = ivec2(floor(uv));\n        c[0] = i + ivec2(0, 0);\n        c[1] = i + ivec2(1, 0);\n        c[2] = i + ivec2(0, 1);\n        c[3] = i + ivec2(1, 1);\n        w_a = fract(uv - vec2(i));\n        w_b = 1.0 - w_a;\n    } else {\n        /* calculate even coordinates in one table entry and\n         * odd coordinates in another, in two dimensions, so\n         * that the corresponding weigths see-saw rather than\n         * step\n         */\n        ivec4 i = ivec4(floor((uv.xyxy + vec4(1,1,0,0)) * 0.5) * 2.0\n                        + vec4(0,0,1,1));\n        c[0] = i.xy;\n        c[1] = i.zy;\n        c[2] = i.xw;\n        c[3] = i.zw;\n        w_a = abs(uv - vec2(i.xy));\n        w_b = abs(uv - vec2(i.zw));\n    }\n    float w[4];\n    w[0] = aa_lessThan(w_a.x, 0.5) * aa_lessThan(w_a.y, 0.5);\n    w[1] = aa_lessThan(w_b.x, 0.5) * aa_lessThan(w_a.y, 0.5);\n    w[2] = aa_lessThan(w_a.x, 0.5) * aa_lessThan(w_b.y, 0.5);\n    w[3] = aa_lessThan(w_b.x, 0.5) * aa_lessThan(w_b.y, 0.5);\n    vec4 r = vec4(0);\n    for (int i = 0; i < 4; ++i) r += lookup(c[i]) * w[i];\n    return r;\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    vec2 r = iResolution.xy / float(scale);\n    if (any(greaterThan(fragCoord, vec2(r)))) discard;\n    vec2 uv = (fragCoord - r * 0.5) / r.xx;\n    bool left = uv.x < 0.0;\n    vec2 cs = sintau(iTime * 0.1 + vec2(0.25,0));\n    uv *= mat2x2(cs.x, cs.y, -cs.y, cs.x) * 5.0;\n\n    fragColour = example(uv, left);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"int scale = 8;\n\nfloat sintau(float x) { return sin(x * 6.28318530718); }\nvec2 sintau(vec2 x) { return sin(x * 6.28318530718); }\nvec3 sintau(vec3 x) { return sin(x * 6.28318530718); }\nvec4 sintau(vec4 x) { return sin(x * 6.28318530718); }\n","name":"Common","description":"","type":"common"}]}