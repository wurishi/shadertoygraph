{"ver":"0.1","info":{"id":"MlcXRs","date":"1481143603","viewed":90,"name":"#Devember 2016 - day 06","username":"theGiallo","description":"At the beginning of the file there is a preprocessor define that controls if the materials are indexed or entirely passed by the map function. You can test yourself that indexed are faster.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define INDEXED_MATERIALS 1\n\n#if INDEXED_MATERIALS\n#define MPt vec2\n#define distance x\n#else\n#define MPt Material_Point\n#endif\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_COUNT    7\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nmin( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmax( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( max( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate( -a, p );\n}\n\n#if INDEXED_MATERIALS\nvec2\nunion_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nunion_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance < p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\nvec3 sky_color;\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nmap( in vec3 pos )\n{\n    #if 0\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n    #else\n    vec3 color = ORANGE_RGB;\n    #endif\n    \n    MPt res;\n    #if INDEXED_MATERIALS\n    res.x = 1e38;\n    #else\n    res.distance = 1e38;\n    #endif\n    \n    #if !INDEXED_MATERIALS\n    Material plastic_m;\n    plastic_m.color = vec3(1.0);\n    plastic_m.diffuse_reflection  = 1.0;\n    plastic_m.specular_reflection = 1.0;\n    plastic_m.ambient_reflection  = 1.0;\n    plastic_m.shininess           = 15.0;\n\n    Material floor_m;\n    plastic_m.color = vec3(1.0);\n    floor_m.diffuse_reflection  = 1.0;\n    floor_m.specular_reflection = 0.2;\n    floor_m.ambient_reflection  = 0.5;\n    floor_m.shininess           = 1.0;\n\n    Material orange_m = plastic_m;\n    orange_m.color = ORANGE_RGB;\n    \n    Material red_m = plastic_m;\n    red_m.color = vec3(1.0,0.0,0.0);\n    Material green_m = plastic_m;\n    green_m.color = vec3(0.0,1.0,0.0);\n    Material blue_m = plastic_m;\n    blue_m.color = vec3(0.0,0.0,1.0);\n    #endif\n\n    float sr = 0.5;\n    float sd = 0.5;\n    #if 0\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),\n                          orange_mat ),\n\t      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),\n                          orange_mat ) );\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),\n               orange_mat ),\n          res );\n    #endif\n    \n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_RED\n                        #else\n                        red_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_GREEN\n                        #else\n                        green_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_BLUE\n                        #else\n                        blue_m\n                        #endif\n                       ),res );\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                        #if INDEXED_MATERIALS\n                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m\n                        #else\n                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )\n                        #endif\n                       ),\n                    res );\n\n\n    res =\n       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )\n                        #endif\n                       ),\n                    res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,iTime), at_pos(vec3(2.0,6.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = rgb_from_hsv(vec4(0.57,0.5,0.7,1.0));\n    sky_color = col.rgb;\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, -1.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n    vec2 d = vec2(3.0,5.0);\n    vec3 camera_pos;\n    #if 1\n    camera_pos.y = 3.0 + cos(time) * d.y;\n    camera_pos.x = 4.0;\n    camera_pos.z = 1.5;\n    vec3 look = normalize( vec3(-0.5,0.0,-0.1) );\n    #else\n    camera_pos = vec3(1.0,8.0,1.0);\n    vec3 look = normalize( vec3(0.5,0.0,-0.25) );\n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    \n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb;\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n    \n    MPt mp;\n    float t = 0.0, t_max = 1e2;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    Material mat;\n    #if INDEXED_MATERIALS\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == int(mp.y) )\n        {\n            mat = materials_table[i];\n        }\n\t}\n    #else\n    mat = mp.material;\n    #endif\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        // col.rgb = 0.5 + normal * 0.5;\n        float diffuse = max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        float ambient = 0.3;\n        col.rgb = ( diffuse * mat.diffuse_reflection +\n                    ambient * mat.ambient_reflection ) * mat.color +\n                    spec    * mat.specular_reflection * sun_specular_color;\n    } else\n    if ( t == 0.0 )\n    {\n        col.rgb = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}