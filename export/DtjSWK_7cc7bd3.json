{"ver":"0.1","info":{"id":"DtjSWK","date":"1676603329","viewed":85,"name":"handmade textures test","username":"ianertson","description":"Just wanted to try to make some custom textures, just from using one noise texture.\nUse the mouse to look around :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","raymarch","textures","albedo","handmadetextures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(T)))\n#define adot(a, b) abs(dot(a,b))\n#define rgb(a, b, c) (vec3(a, b, c)/255.0)\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 rand3(vec2 p, float seed) {\n    p += seed*0.2915921838;\n    return textureLod(iChannel3, p/256.0, 0.0).rgb;\n}\n\nvec3 noise23(vec2 p, float seed) {\n   vec2 id = floor(p);\n   vec2 lv = fract(p);\n   lv = lv*lv*(3.0-2.0*lv);\n   return mix(mix(rand3(id, seed), rand3(id+vec2(1, 0), seed), lv.x),\n          mix(rand3(id+vec2(0, 1), seed), rand3(id+vec2(1, 1), seed), lv.x),lv.y);\n    \n}\n\nvec3 noise23(vec2 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise23(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    ADV; ADV;\n    ADV; ADV;\n    \n    #undef ADV\n    \n    return n / div;\n}\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0)\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n\nvec3 getLightDir(in Light light, vec3 p) {\n    if (light.type == LIGHT_AMBIENT) return normalize(light.p);\n    return normalize(light.p - p);\n}\n\nvec3 getLightAtt(in Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n,L));\n    if (light.type == LIGHT_AMBIENT) return light.c * light.s * NdotL;\n    float d = distance(light.p, p);\n    float att = pow(light.s, 2.0) / max(0.0001, pow(d, 2.0));\n    return light.c * att * NdotL;\n}\n\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    \n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0); \n}\n\nfloat groundSDF(vec3 p) {\n    return p.y;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    float box = boxSDF(p - vec3(0, 0.5, 0), vec3(0.5));\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(box, ID_BOX);\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data, vec3 p) {\n    vec3 n = data.n;\n    vec2 uv = vec2(0.0);\n    \n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    \n    return uv;\n}\n\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    dist = abs(dist);\n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    data.n = getNormal(data, p);\n    data.uv = getUv(data, p);\n    \n    return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= min(NEAR, near)) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    \n    dist = abs(dist);\n\n    \n    return dist/abs(near);\n}\n\nvec3 woodTexture(vec2 uv) {\n    vec3 col = vec3(0.0);\n    vec2 lv = fract(uv);\n    \n    vec3 n = noise23(uv*32., 3.291895, 4.0);\n    vec3 n2 = noise23(uv*32., 9.938154, 3.0);\n    \n    vec3 c1 = rgb(176, 122, 78);\n    vec3 c2 = rgb(68, 32, 10);\n    vec3 c3 = rgb(118, 62, 35);\n    \n    col = mix(col, c1, n.x);\n    col = mix(col, c2, n.y);\n    col = mix(col, c3, n.z);\n    \n    float thick = 0.1 -  n2.x*0.04;\n     \n    float f = thick*0.3;\n    float vert = max(0.0, 1.0 - smoothstep(0.0, thick, lv.x-f));\n    vert += max(0.0, 1.0 - smoothstep(1.0, 1.0-thick, lv.x+f));\n    \n    float hor = max(0.0, 1.0 - smoothstep(0.0, thick, lv.y-f));\n    hor += max(0.0, 1.0 - smoothstep(1.0, 1.0-thick, lv.y+f));\n    \n    float mh = max(0.0, float(lv.y >= 0.5-thick && lv.y <= 0.5+thick) - vert);\n    float mv = max(0.0, float(lv.x >= 0.5-thick && lv.x <= 0.5+thick) - vert);\n  \n    float mhs1 = max(0.0, 1.0 - smoothstep(0.5-thick, 0.5+thick, lv.y-thick*0.5));\n    float mhs2 = max(0.0, 1.0 - smoothstep(0.5+thick, 0.5-thick, lv.y+thick*0.5));\n    float mhs = min(mhs1, mhs2);\n     \n    float mvs1 = max(0.0, 1.0 - smoothstep(0.5-thick, 0.5+thick, lv.x-thick*0.5));\n    float mvs2 = max(0.0, 1.0 - smoothstep(0.5+thick, 0.5-thick, lv.x+thick*0.5));\n    float mvs = min(mvs1, mvs2);\n    \n    float lineY = fract((lv.x+(0.07*cos((lv.y*2.0-1.0)*TAU)))*90.);\n    \n    float jag = fract((lv.x-lv.y)*40.);\n    \n    float sg = hor+vert;\n    \n    float g = float(\n        lv.x <= thick || lv.x >= 1.0-thick ||\n        lv.y <= thick || lv.y >= 1.0-thick\n    );\n    \n    g = mix(g, sg, 0.4);\n    float bars =  max(g, max(max(mh, mhs), max(mv, mvs)));\n    \n    float outerEdges = 1.0 - smoothstep(max(g, max(mhs, mvs)), 0.01, 0.09);\n    \n    col = mix(col, c2, 0.5*lineY*bars);\n    \n    \n    col = mix(col, c2*n.x*n.y*n.z,bars*n.y);\n    \n    col = mix(col, jag*c2, 0.5*n2.x*max(0.0, 1.0 - bars));\n    \n    col *= n2.y;\n    col *= max(0.0, 1.0 - outerEdges*0.6);\n    \n    col += ((fract(n.x+n.y+n.z+n2.x+n2.y+n2.z)*c3) * (col+0.2))/3.;\n    \n    vec2 lvm = fract(uv*2.0);\n    \n    float gvm = max(0.0, 1.0 - ceil(min(lvm.x, lvm.y)-0.01));\n    vec2 cvm = lvm*2.0-1.0;\n    \n    float ra = 0.05;\n    float fr = ra*0.2;\n    cvm = abs(cvm);\n    float screws = 1.0 - smoothstep(ra-fr, ra+fr, length(cvm - vec2(0.8, 0.8)));\n    \n    col += (screws*n2.x*n.x*n2.y*n2.z)*2.;\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = woodTexture(uv);\n    \n    float e = 0.001;\n    \n    vec3 n = normalize(luma(col) - vec3(\n        luma(woodTexture(uv + vec2(e, 0))),\n        luma(woodTexture(uv + vec2(0, e))),\n        0.04+luma(woodTexture(uv + vec2(e, e)))\n    ));\n    \n\n    \n    float d = dot(n, data.n);\n    vec3 t = cross(data.n, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(data.n, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(data.n, t));\n    mat3 tbn = mat3(t, b, -data.n);\n    n = normalize((tbn)*n);\n    data.n = n;//mix(data.n, n, max(0.0, dot(data.n, n)));\n    \n    return col;\n}\n\nvec3 stoneTexture(vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    vec3 n = noise23(uv, 5.5495, 10.5);\n    \n    float bumps = pow(n.x, 2.0);\n    \n    col += bumps;\n    \n    float scratches = fract((n.y+n.z)*1000.2815);\n    \n    col += scratches*max(0.2, 1.0-(bumps*6.));\n    \n    vec3 c1 = rgb(86, 85, 86);\n    vec3 c2 = rgb(158, 168, 179);\n    vec3 c4 = rgb(168, 151, 128);\n    \n    vec3 n2 = noise23(uv, 6.12495992, mix(20.542, 20.542 * (n.x*2.0-1.0), 0.25));\n    \n    col = mix(col, col*c1, n2.x*1.6);\n    col = mix(col, col*c2, n2.y*1.6);\n    col = mix(col, col*c4, n2.z*1.6);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = stoneTexture(uv);\n    \n    float e = 0.05;\n    \n    vec3 n = normalize(luma(col) - vec3(\n        luma(stoneTexture(uv + vec2(e, 0))),\n        luma(stoneTexture(uv + vec2(0, e))),\n        0.05+luma(stoneTexture(uv + vec2(e, e)))\n    ));\n    \n\n    \n    float d = dot(n, data.n);\n    vec3 t = cross(data.n, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(data.n, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(data.n, t));\n    mat3 tbn = mat3(t, b, -data.n);\n    n = normalize((tbn)*n);\n    data.n = mix(data.n, n, max(0.0, dot(data.n, n)));\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n    }\n    \n    return vec3(0.48);\n}\n\nvec3 forEachLight(inout Data data, in Light light, vec3 ro, vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 n = data.n;\n    vec3 p = data.p;\n    vec3 att = getLightAtt(light, p, n);\n    vec3 L = getLightDir(light, p);\n    float distLight = distance(p, light.p);\n    float shadow = getShadow(p + (n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : distLight);\n    \n    \n    vec3 ref = reflect(L, n);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 32.0);\n    \n    return (diffuse+spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.97, 0.83, 0.79), 2.6, LIGHT_AMBIENT);\n    float d = FAR;\n    if (march(data, ro, rd)) {\n        d = data.d;\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd);\n        }\n    }\n    \n    float depth = d / FAR;\n    \n    col += depth*depth;\n    \n    return col;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n  vec3 lookAt = point;\n  float zoom = 1.;\n  vec3 camForward = normalize(lookAt - ro);\n  vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n  vec3 camUp = -cross(camRight, camForward);\n  vec3 screenCenter = ro + camForward * zoom;\n  vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n  return normalize(screenIntersection - ro);\n}\n\nvoid getRay(in vec2 uv, in vec2 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0.5, -2.6);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float t = T*0.5;\n       // ro.yz *= rot(t);\n        //ro.xz *= rot(t);\n        \n        float zoom = M_PI;\n        \n        zoom /= (1.0 + (0.5+(0.5*cos(t*2.+(0.5+(0.5*sin((t+0.28715)*3.)))))));\n        \n        ro.x = cos(t+0.25*sin((t-1.)*3.))*zoom;\n        ro.z = sin(t+0.25*cos((t+1.0293981)*3.))*zoom;\n        ro.y += (0.5+(0.5*sin(t+0.25*(ro.x+ro.z+cos((t-10.02913)*0.5)))))*2.5;\n        \n        float lx = sin(t+cos(sin((t+1.298814)*3.)+((t-1.00281)*3.)))*0.4;\n        float lz = cos(t+sin((lx*3.)+((t+4.92914)*3.)))*0.4;\n        float ly = cos((3.0*(lx*1.1+lz*1.1))+((t-3.9912)*3.3))*0.3;\n        rd = look(uv, vec3(lx*0.5, 0.5 + (ly*0.5), lz*0.5), ro);\n        \n       // rd.yz *= rot(t);\n       // rd.xz *= rot(t);\n    }\n    \n    ro.y = max(0.2, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    \n    Data data = NEW_DATA;\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    \n    col += render(data, ro, rd);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}