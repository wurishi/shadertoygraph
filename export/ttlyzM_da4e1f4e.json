{"ver":"0.1","info":{"id":"ttlyzM","date":"1591727438","viewed":114,"name":"\"antagata dokosa\"(japanese song)","username":"darkfox","description":"antagata_dokosa!\nAlso, very long.... not smart....\n","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// palette.\n#define GREEN vec3(0.13, 0.69, 0.29)\n#define RED vec3(1.0, 0.4, 0.3)\n#define BLUE vec3(0.4, 0.6, 1.0)\n\n// space.\n#define Ch_sp 127\n// double quotation.\n#define Ch_dq 168\n// period, comma, apostrophe.\n#define Ch_prd 46\n#define Ch_com 44\n#define Ch_apt 39\n\n// notes.\n#define Ch_n8 10\n\n// small alphabets.\n#define Ch_a 97\n#define Ch_b 98\n#define Ch_c 99\n#define Ch_d 100\n#define Ch_e 101\n#define Ch_f 102\n#define Ch_g 103\n#define Ch_h 104\n#define Ch_i 105\n#define Ch_j 106\n#define Ch_k 107\n#define Ch_l 108\n#define Ch_m 109\n#define Ch_n 110\n#define Ch_o 111\n#define Ch_p 112\n#define Ch_q 113\n#define Ch_r 114\n#define Ch_s 115\n#define Ch_t 116\n#define Ch_u 117\n#define Ch_v 118\n#define Ch_w 119\n#define Ch_x 120\n#define Ch_y 121\n#define Ch_z 122\n\n// draw character\nvec2 getCodePos(float code){\n    return vec2(mod(code, 16.0), 15.0 - floor(code / 16.0));\n}\n\nvec4 getCharLU(int charCode, vec2 p, vec2 lu, vec2 size, vec4 col){\n    // size: right, down.\n    float code = float(charCode);\n    if(p.x < lu.x || p.x > lu.x + size.x || p.y > lu.y || p.y < lu.y - size.y){\n        return vec4(0.0);\n    }\n\n    vec2 co = vec2(p.x - lu.x, lu.y - p.y) / size;\n    co.y = 1.0 - co.y;\n\n    vec4 tex = texture(iChannel0, (co + getCodePos(code)) / 16.0);\n    if(tex.r < 0.5 * (tex.g + tex.b)){ return vec4(0.0); }\n    return col;\n}\n\nvec4 Ch(vec2 p, int CharCode, float x, float y){\n    return getCharLU(CharCode, p, vec2(x, y), vec2(0.08, 0.1), vec4(GREEN, 1.0));\n}\n\n// white keys(24)\n// y:0.0～0.4\nvoid drawWhiteKey(in vec2 p, inout vec3 col, float n, bool isPressed){\n    vec2 pos = vec2((n * 2.0 + 1.0) / 48.0, 0.2);\n    vec2 size = vec2(0.9 / 48.0, 0.2);\n    if(abs(p.x - pos.x) > size.x || abs(p.y - pos.y) > size.y){ return; }\n    if(isPressed){ col = RED; return; }\n    col = vec3(0.9);\n}\n\n// black keys(25)\n// y:0.18～0.4\nvoid drawBlackKey(in vec2 p, inout vec3 col, float n, bool isPressed){\n    vec2 pos = vec2(n / 24.0, 0.29);\n    vec2 size = vec2(0.8 / 48.0, 0.11);\n    if(abs(p.x - pos.x) > size.x || abs(p.y - pos.y) > size.y){ return; }\n    if(isPressed){ col = BLUE; return; }\n    col = vec3(0.1);\n}\n\nfloat getCurrentNote(){\n    float prevTerm = 0.0;\n    for(int i = 0; i < note_count; i++){\n        // a bit shorten.\n        if(prevTerm < iTime && iTime < prevTerm + sus[i] * unit * 0.85){\n            return float(notes[i]);\n        }\n        prevTerm = term[i] * unit;\n    }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 st = fragCoord.xy / min(iResolution.x, iResolution.y);\n\n    vec3 col = mix(GREEN, vec3(1.0), p.y); // background.\n\n    float cur = getCurrentNote(); // current note.\n\n    for(float n = 0.0; n < 24.0; n += 1.0){\n        drawWhiteKey(p, col, n, n == cur);\n    }\n    for(float n = 0.0; n < 25.0; n += 1.0){\n        if(mod(n, 7.0) == 1.0 || mod(n, 7.0) == 5.0){ continue; }\n        drawBlackKey(p, col, n, n - 0.5 == cur);\n    }\n    \n    int title[18] = int[18](Ch_n8, Ch_dq,\n                            Ch_a, Ch_n, Ch_t, Ch_a, Ch_g, Ch_a, Ch_t, Ch_a,\n                            Ch_sp, Ch_d, Ch_o, Ch_k, Ch_o, Ch_s, Ch_a, Ch_dq);\n    \n    vec4 words = vec4(0.0);\n    for(int i = 0; i < 18; i++){\n        words += Ch(st, title[i], 0.1 + 0.04 * float(i), 0.9);\n    }\n    \n    fragColor = mix(vec4(col, 1.0), words, words.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.2831\n\n/*\n(lyrics)\n\"antagatadokosa higosa higodokosa kumamotosa kumamotodokosa senbasa\"\n\"senbayamaniha tanuki(raccoon dog)ga ottesa sorewo ryousiga teppou(gun)de\"\n\"uttesa(bakyuuuuuuuuunnn!!!!!!) nitesa yaitesa kuttesa(kill and eat)\"\n\"sorewo konohade tyoito kabuse~~~\"\n*/\n\n// pianolike sound.\nfloat piano(float x){\n    float wv = 0.5 * sin(TAU * x);\n    wv += 0.25 * sin(TAU * 2.0 * x);\n    wv += 0.125 * sin(TAU * 3.0 * x);\n    wv += 0.0625 * sin(TAU * 4.0 * x);\n    wv += 0.03125 * sin(TAU * 5.0 * x);\n    return wv;\n}\n\nvec2 pianoWave(float time, float freq, float m){\n  return vec2(piano(freq * time)) * exp(-m * time);\n}\n\nvec2 sound(float t, float freq, float span){\n    return pianoWave(t, freq, 1.6 / span);\n}\n\nvec2 mainSound( in int samp,float time){\n    vec2 wv = vec2(0.0);\n    float prevTerm = 0.0;\n    float frequency;\n    \n    for(int i = 0; i < note_count; i++){\n        if(time < term[i] * unit){\n            frequency = 440.0 * pow(2.0, getExponent(notes[i]) / 12.0);\n            wv += sound(time - prevTerm, frequency, sus[i] * unit);\n            break;\n        }\n        prevTerm = term[i] * unit;\n    }\n    return wv;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// common constants, functions, etc...\n\n// keyboard code. (sharp key is fractional.)\nconst float _RA = 10.0;\nconst float _RASP = 10.5;\nconst float _SI = 11.0;\nconst float DO = 12.0;\nconst float DOSP = 12.5;\nconst float RE = 13.0;\nconst float RESP = 13.5;\nconst float MI = 14.0;\nconst float FA = 15.0;\nconst float FASP = 15.5;\nconst float SO = 16.0;\nconst float SOSP = 16.5;\nconst float RA = 17.0;\nconst float RASP = 17.5;\nconst float SI = 18.0;\nconst float DO_ = 19.0;\n\n// song data\n\nconst int note_count = 79;\nconst float BPM = 150.0;\nconst float unit = 60.0 / BPM;\n\n// terminal time of each segment.\nconst float term[note_count] =\n        float[note_count](1.0, 1.5, 2.5, 3.0, 4.0, 4.5, 6.0,\n                          7.0, 7.5, 9.0, 10.0, 10.5, 11.5, 12.0, 13.5,\n                          14.5, 15.0, 16.0, 16.5, 18.0,\n                          19.0, 19.5, 20.5, 21.0, 22.0, 22.5, 24.0,\n                          25.0, 25.5, 28.0,\n                          28.5, 29.5, 30.0, 31.0, 31.5, 32.5, 33.0,\n                          34.0, 34.5, 35.5, 36.0, 37.0, 37.5, 40.0,\n                          40.5, 41.5, 42.0, 43.0, 43.5, 44.5, 45.0,\n                          46.0, 46.5, 47.5, 48.0, 49.0, 49.5, 51.0,\n                          52.0, 52.5, 54.0, 55.0, 55.5, 57.0, 58.0, 58.5, 61.0,\n                          61.5, 62.5, 63.0, 64.0, 64.5, 65.5, 67.5,\n                          68.5, 69.0, 70.5, 72.0, 75.0);\n\n// sustain time.\nconst float sus[note_count] =\n        float[note_count](1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0,\n                          1.0, 0.5, 1.0, 1.0, 0.5, 1.0, 0.5, 1.0,\n                          1.0, 0.5, 1.0, 0.5, 1.0,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0,\n                          1.0, 0.5, 1.0,\n                          0.5, 1.0, 0.5, 1.0, 0.5, 1.0, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0,\n                          0.5, 1.0, 0.5, 1.0, 0.5, 1.0, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0,\n                          1.0, 0.5, 1.0, 1.0, 0.5, 1.0, 1.0, 0.5, 1.0,\n                          0.5, 1.0, 0.5, 1.0, 0.5, 1.0, 0.5,\n                          1.0, 0.5, 1.0, 1.0, 1.5);\n\nconst float notes[note_count] =\n        float[note_count](_RA, _RA, _RA, DO, RE, DO, RE,\n                          MI, DO, RE, MI, MI, RE, DO, _RA,\n                          _RA, DO, DO, DO, RE,\n                          DO, RE, MI, MI, RE, DO, _RA,\n                          RE, DO, _RA,\n                          _RA, MI, MI, MI, MI, DO, DO,\n                          RE, RE, MI, MI, RE, DO, _RA,\n                          _RA, MI, MI, MI, MI, DO, DO,\n                          RE, RE, MI, MI, RE, DO, _RA,\n                          _RA, DO, RE, _RA, DO, RE, MI, DO, RE,\n                          _RA, MI, MI, MI, MI, DO, DO,\n                          RE, DO, _RA, DO, RE);\n\n// 鍵盤の番号からオクターブの指数を出すための若干美しくない処理\nconst float array_w[7] = float[7](-5.0, -4.0, -2.0, 0.0, 2.0, 3.0, 5.0);\nconst float array_b[7] = float[7](-6.0, 0.0, -3.0, -1.0, 1.0, 0.0, 4.0); //0:dummy.\n\n// get exponent. 0:white key, 1:black key.\n// これを440.0に掛ける\nfloat getExponent(float index){\n    float r, q;\n    int diffType = 0;\n    if(fract(index) > 0.25){ index += 0.5; diffType = 1; }\n    for(int i = 0; i < 7; i++){\n        r = mod(index, 7.0);\n        q = floor(index / 7.0);\n        if(float(i) == r){\n            return 12.0 * q - 24.0 + (diffType == 0 ? array_w[i] : array_b[i]);\n        }\n    }\n    return 0.0;\n}","name":"Common","description":"","type":"common"}]}