{"ver":"0.1","info":{"id":"3s2XWh","date":"1553617905","viewed":346,"name":"I LIKE SHINY THINGS, NO APOLOGY","username":"kevs3d","description":"There really isn't such a thing as too much SHINY.\n\nTwo reflection bounces used to create even MOAR SHINY.\n\nUses code by other authors - as credited in method comments.\nThis and others on my shader page: http://www.kevs3d.co.uk/dev/shaders","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","raymarch","shiny","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Distance field ray-marching demo - by Kevin Roast\n   Uses code by other authors - as credited in method comments.\n   http://www.kevs3d.co.uk/dev/shaders\n*/\n\n\n#define AO_SAMPLES 4\n#define RAY_DEPTH 512\n#define MAX_DEPTH 512.0\n#define DISTANCE_MIN 0.002\n#define PI 3.14159265\n\n#define ANTIALIAS_SAMPLES 1\n#define REFLECT 1\n\n#define FLOOR_YPOS 0.0\n\nconst bool rotateWorld = true;\nconst vec2 delta = vec2(DISTANCE_MIN, 0.0);\n\n\n#define HASHSCALE1 .1031\nfloat Hash(float p)\n{\n   vec3 p3  = fract(vec3(p) * HASHSCALE1);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.x + p3.y) * p3.z);\n}\n\n// unsmoothed psuedo random number noise - fine for this purpose (a single random per domain cell)\nfloat vnoise(in vec2 x)\n{\n   vec2 p = floor(x);\n   float n = p.x + p.y*57.0;\n   float res = Hash(n);\n   return res;\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n   float c,s;\n   vec3 q=p;\n   c = cos(a);\n   s = sin(a);\n   p.x = c * q.x + s * q.z;\n   p.z = -s * q.x + c * q.z;\n   return p;\n}\n\nfloat fOpUnion(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8(vec2 p)\n{\n   p = p*p; p = p*p; p = p*p;\n   return pow(p.x + p.y, 1.0/8.0);\n}\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nconst float DOMAIN = 5.0;\nfloat Map(vec3 p)\n{\n   vec3 q = vec3(mod(p.x, DOMAIN) - 0.5 * DOMAIN, p.y, mod(p.z, DOMAIN) - 0.5 * DOMAIN);\n\n   float f = vnoise( vec2( floor(p.x/DOMAIN)*DOMAIN, floor(p.z/DOMAIN)*DOMAIN ) );\n   float d;\n   if (f > 0.75) {\n      d = udRoundBox(vec3(q.x-(0.25*f), q.y-max(f, 0.1)+sin(iTime*f)*0.75+0.25, q.z+(f-0.75)), vec3(1.0-(f*0.5), max(f, 0.1), f), 0.025);\n   }\n   else if (f > 0.5) {\n      d = length(q-vec3(-0.15+f*0.25,0.75+sin(iTime+100.0*f), 0.0)) - (0.4+f);\n   }\n   else if (f > 0.25) {\n      d = sdTorus(vec3(q.x, q.y-sin(iTime*f*2.0)-0.75, q.z), vec2(f+0.33,f+0.05));\n   }\n   else {\n      d = sdTorus88(RotateY(vec3(q.x, q.y-sin(iTime*f*3.0)-1.0, q.z), cos(iTime*f*2.0)), vec2(f+0.4,f+0.05));\n   }\n   return d;\n}\n\nfloat Dist(vec3 pos)\n{\n   if (rotateWorld) pos = RotateY(pos, sin(iTime*0.15)*PI);\n   \n   return fOpUnion(\n      Plane(pos-vec3(0.,FLOOR_YPOS,0.), vec3(0.,1.,0.)),\n      Map(pos),\n      0.5\n   );\n}\n\nconst vec3 lightColour = vec3(2.5, 1.8, 1.9);\nconst float specular = 1.5;\nconst float specularHardness = 20.0;\nconst float diffuse = 0.05;\nconst float ambientFactor = 0.3;\n\n// Based on original by IQ\nfloat CalcAO(vec3 p, vec3 n)\n{\n   float r = 0.0;\n   float w = 1.0;\n   for (int i=1; i<=AO_SAMPLES; i++)\n   {\n      float d0 = float(i) * ambientFactor;   // NOTE: factor controls the 'spread' of the AO test and therefore overlap into domain cells\n      r += w * (d0 - abs(Dist(p + n * d0)));\n      normalize(n + vec3(0.0,0.5,0.0));\n      w *= 0.5;\n   }\n   return 1.0 - r;\n}\n\n// see https://iquilezles.org/articles/rmshadows\nfloat SoftShadow(vec3 ro, vec3 rd)\n{\n   float k = 20.0;            // softness\n   float res = 1.0;\n   float t = 0.01;            // min-t\n   for (int i=0; i<48; i++)\n   {\n      float h = Dist(ro + rd * t);\n      res = min(res, k*h/t);\n      t += h;\n      if (res < DISTANCE_MIN || t > 64.0) break; // max-t\n   }\n   return clamp(res, 0.0, 1.0);\n}\n\nvec3 GetNormal(vec3 pos, float s)\n{\n   if (pos.y < FLOOR_YPOS + DISTANCE_MIN)\n   {\n      return vec3(0.0,1.0,0.0);\n   }\n   else\n   {\n      vec3 n;\n      n.x = s - Dist(pos - delta.xyy);\n      n.y = s - Dist(pos - delta.yxy);\n      n.z = s - Dist(pos - delta.yyx);\n      return normalize(n);\n   }\n}\n\nconst vec3 lightDir = vec3(0.1313, 0.1209, 0.0518);\n\nvec3 Sky(vec3 rd)\n{\n   vec3 sky = mix( vec3(.7,.7,.8), vec3(0), exp2(-(1.0/max(rd.y,.01))*vec3(.4,.6,1.0)) );\n   float sunAmount = max(dot(rd, lightDir), 0.0);\n   sky += vec3(1.0,0.6,0.3) * sunAmount * sunAmount * .5 + vec3(1.0,0.6,0.3) * min(pow(sunAmount, 800.0), .3);\n   return sky;\n}\n\n// Fog routine - original by IQ\nvec3 Fog(vec3 rgb, vec3 rd, float distance)   // camera to point distance\n{\n   const float start = 20.0;  // start offset\n   const float b = 0.2;       // fog amount\n   float fogAmount = clamp(1.0 - exp((-distance+start)*b*b), 0.0, 1.0);\n   vec3 fogColor = Sky(rd);\n   return mix(rgb, fogColor, fogAmount);\n}\n\nvec4 Shading(vec3 pos, vec3 rd, vec3 norm, float d)\n{\n   vec3 light;\n   float ref;\n   \n   if (d != 0.0)\n   {\n      float fresnel = pow(1.0 - dot(normalize(-rd), norm), 5.0);\n\n      light = lightColour * max(0.0, dot(norm, lightDir));\n      vec3 heading = normalize(-rd + lightDir);\n      float spec = pow(max(0.0, dot(heading, norm)), specularHardness);\n      light = (diffuse * light * (1.0-fresnel)) + (spec * specular);\n\n      // object reflection\n      fresnel = mix(0.5, 1.0, fresnel);\n      ref = fresnel;\n\n      light *= SoftShadow(pos, lightDir);\n\n      float occ = CalcAO(pos, norm);\n      light *= occ;\n\n      // sky light with AO\n      float sky = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n      light += sky * vec3(0.24, 0.20, 0.24) * 0.5 * occ * occ;\n      \n      // indirect light bounce with AO\n      float ind = clamp(dot(norm, normalize(lightDir * vec3(-1.0,0.0,-1.0))), 0.0, 1.0);\n      light += ind * lightColour * 0.25 * occ * occ;\n   }\n   else\n   {\n      // Sky hit - distance test went to max\n      light = Sky(rd);\n   }\n   \n   return vec4(light, ref);\n}\n\n// Original method by David Hoskins\n#define GAMMA 0.8\n#define CONTRAST 1.1\n#define SATURATION 1.2\n#define BRIGHTNESS 1.2\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(GAMMA));\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\n// Ray March\nfloat March(vec3 ro, vec3 rd, inout vec3 p)\n{\n   float t = 0.0;\n   float d = 0.0;\n   for (int i=0; i<RAY_DEPTH; i++)\n   {\n      p = ro + rd * t;\n      float d = Dist(p);\n      if (abs(d) < DISTANCE_MIN)\n      {\n         return d;\n      }\n      t += d * 0.75;\n      if (t >= MAX_DEPTH) break;\n   }\n   return 0.0;\n}\n\n// Boing\nfloat MarchReflect(vec3 ro, vec3 rd, inout vec3 p)\n{\n   float t = 0.0;\n   float d = 0.0;\n   for (int i=0; i<RAY_DEPTH/2; i++)\n   {\n      p = ro + rd * t;\n      float d = Dist(p);\n      if (abs(d) < DISTANCE_MIN)\n      {\n         return d;\n      }\n      t += d * 0.75;\n      if (t >= MAX_DEPTH) break;\n   }\n   return 0.0;\n}\n\nconst vec3 cameraPos = vec3(0.0, 5.0, -12.0);\nconst vec3 cameraLookAt = vec3(16.0, -5.0, -1.2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 cpos = vec3(cameraPos);\n   vec3 lookAt = cameraLookAt;\n   if (rotateWorld) {\n      //cpos.y = sin(iTime)*0.5 + 5.0;\n      cpos.y = sin(iTime*0.5)*4.0 + 8.0;\n      cpos.x = cos(iTime*.25)*8.0 + 4.0;\n      lookAt.y = -sin(iTime*0.75)*4.0 - 2.0;\n   }\n   \n   vec4 res = vec4(0.0);\n   vec2 p;\n   float d_ang = 2.*PI / float(ANTIALIAS_SAMPLES);\n   float ang = d_ang * 0.333;\n   float r = 0.333;\n   for (int i = 0; i < ANTIALIAS_SAMPLES; i++)\n   {\n      p = vec2((gl_FragCoord.x + cos(ang)*r) / iResolution.x, (gl_FragCoord.y + sin(ang)*r) / iResolution.y);\n      vec3 ro = cpos;\n      vec3 rd = normalize(GetRay(lookAt-cpos, p));\n      vec3 hit;\n\n      float d = March(ro, rd, hit);\n      float fogDistance = length(ro - hit);\n      vec3 fogRd = rd;\n      vec3 norm = GetNormal(hit,d);\n      vec4 shade = Shading(hit, rd, norm, d);\n#if REFLECT\n      shade.rgb *= 1.0 - shade.a;\n      if (shade.a != 0.0)     // reflection sample needed\n      {\n         // ray reflection - shift out again so not immediately hit same point\n         rd = reflect(rd, norm);\n         ro = hit + rd;\n         d = MarchReflect(ro, rd, hit);\n\n         norm = GetNormal(hit, d);\n         vec4 shade1 = Shading(hit, rd, norm, d);\n         if (shade1.a != 0.0)\n         {\n            // add in colour from another reflection march step\n            shade.rgb += shade1.rgb * shade.a * 0.5;\n\n            // ray reflection - shift out again so not immediately hit same point\n            rd = reflect(rd, norm);\n            ro = hit + rd;\n            d = MarchReflect(ro, rd, hit);\n\n            // add in colour from another reflection march step\n            norm = GetNormal(hit, d);\n            vec4 shade2 = Shading(hit, rd, norm, d);\n            shade.rgb += shade2.rgb * shade.a * 0.5;\n         }\n         else shade.rgb += shade1.rgb * shade.a;\n      }\n#endif\n      res.rgb += Fog(shade.rgb, fogRd, fogDistance);\n      ang += d_ang;\n   }\n   res.rgb /= float(ANTIALIAS_SAMPLES);\n   \n   fragColor = vec4(PostEffects(res.rgb, p), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}