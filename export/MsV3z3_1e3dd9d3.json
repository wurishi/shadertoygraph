{"ver":"0.1","info":{"id":"MsV3z3","date":"1455703190","viewed":1370,"name":"2D Weyl hash #1 (integer)","username":"MBR","description":"a 2D equidistributed sequence based on Weyl generators, integer version","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LICENSE: http://unlicense.org/\n\n// NOTE: Not interesting if you can use XOR.\n// SEE: https://www.shadertoy.com/view/4dlcR4\n\n// ****** THIS REQUIRES FULL 32-BIT INTEGER OPERATIONS ******\n//   other bit-width versions are possible, see post.  Also\n//   for non-WebGL limitations cheaper versions are possible\n//   also see post.\n\n// Math background: http://marc-b-reynolds.github.io/math/2016/02/24/weyl.html\n// Hash function:   http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\n\n// The integer constants are simply the same as the float verion\n// of the above scaled to bit-width and rounded to odd.  In this\n// example: roundToOdd(k * 2^32).  The modulo 1 becomes the \n// automatic modulo 2^32 in standard 32-bit integers.  The final\n// scale and addition map the (signed) integer to float. Any\n// deviation from these will result in broken results.  The same\n// can be followed for other bit-widths but it requires that the\n// width be known to form the consants and final scale and the\n// product be modulo bit-width.\n//\n// If you can use bit-ops, notably xor, shifts and ands in a\n// shader it becomes easy to improve speed and/or quality. I'm\n// working on a series of post that explain better.\n//\n// Also SEE: \n//   https://gist.github.com/Marc-B-Reynolds/5a939f71fc7237c7af63\n//   https://gist.github.com/Marc-B-Reynolds/60ff744ad07ca791b02a\n\n\nfloat hash(in ivec2 c)\n{\n  int x = 0x3504f333*c.x*c.x + c.y;\n  int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n  return float(x*y)*(2.0/8589934592.0)+0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2  p = fragCoord.xy ;\n  float r = hash(ivec2(p)+2*iFrame);\n  vec4  c = vec4(vec3(r),1.0);\n    \n  fragColor = c;\n}","name":"Image","description":"","type":"image"}]}