{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"volume","id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Big thanks to mla for helping me with my project\n// Based on mla's shader: https://www.shadertoy.com/view/dlXGRN\n\nfloat PI  = 3.141593,\n      TAU = 6.283185;\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nmat2 powMat(mat2 A, int n)\n{\n    if(n == 0) return mat2(1);\n    \n    if(n < 0) A = inverse(A), n = -n;\n    \n    mat2 res = mat2(1);\n    \n    while(n > 0)\n    {\n        if(n % 2 > 0) res *= A;\n        A *= A;\n        n /= 2;\n    }\n    \n    return res;\n}\n\nvec2 reduce(vec2 p, float tr, mat2 A, mat2 P, out int n)\n{\n    vec2 v = vec2(p.y, -p.x) * P;\n    \n    n = int(floor(.5 * log(abs(v.y / v.x)) / acosh(tr * .5)));\n    \n    vec2 r0 = powMat(A, n) * p, r1 = A * r0;\n    \n    if(length(r1) < length(r0))\n    {\n        n++;\n        return r1;\n    }\n    \n    return r0;\n}\n\nfloat sdStar(vec2 p, float r, float n, float w)\n{\n    float an = PI / n, en = PI / (n + w * (2. - n));\n    \n    vec2  racs = r * vec2(cos(an), sin(an)),\n          ecs  =     vec2(cos(en), sin(en));\n    \n    float bn = abs(mod(atan(p.x, p.y), 2. * an) - an);\n    p = length(p) * vec2(cos(bn), sin(bn));\n\n    p -= racs;\n    p += ecs * clamp(-dot(p, ecs), 0., racs.y / ecs.y);\n    \n    return length(p) * sign(p.x);\n}\n\n#define noise(p) texture(iChannel1, fract(((p) - sin(TAU * (p)) / TAU + .5) / 32.)).x\n\nfloat getStar(vec2 p, vec2 i, float t)\n{\n    float type, size, pulse;\n    \n    if(i == vec2(0))\n    {\n        type = 5.; size = .2;\n        pulse = .5 + .5 * sin(t * TAU);\n        p *= rot(t * TAU * .4);\n    }\n    else\n    {\n        vec4 rand = texelFetch(iChannel0, ivec2(mod(i, 1024.)), 0);\n        type = 3. + round(rand.x * 3.);\n        size = .2 + .2 * rand.y;\n        vec3 q = i.xyx + t + rand.yzw;\n        pulse = noise(2. * q);\n        p *= rot(10. * noise(q));\n    }\n    \n    return min(abs(sdStar(p,         size, type, type > 3. ? .7 : 1.)) - .02,\n                   sdStar(p, pulse * size, type, type > 3. ? .7 : 1.));\n}\n\n#define R iResolution\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O = vec4(0);\n    \n    vec2 p = (2. * I - R.xy) / R.y;\n    \n    if(abs(p.x) > 1.) return;\n    \n    p = p * 10. + vec2(-3.3, 2.7);\n    \n    mat2 A = mat2(2, -1, -1, 1);\n    \n    float a = A[0][0], b = A[1][0], c = A[0][1], d = A[1][1];\n    \n    float tr = a + d;\n    \n    float l = .5 * (tr - sqrt(tr * tr - 4.));\n          \n    float t = fract(iTime / 3.), k = pow(l, t - .5);\n    \n    mat2 P = mat2(normalize(vec2(-b, a - l)),\n                  normalize(vec2(-b, a - 1. / l)));\n    \n    P *= mat2(k, 0, 0, 1. / k);\n    \n    p = P * p;\n    vec2 i = round(p);\n    p = inverse(P) * (p - i);\n    \n    int n;\n    \n    i = reduce(i, tr, A, P, n);\n    \n    t += float(n);\n\n    O = vec4(smoothstep(20., -20., getStar(p, i, t) * R.y));\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcGfzc","date":"1734341649","viewed":247,"name":"they're getting closer together","username":"Nguyen2007","description":"Inspired by: https://x.com/etiennejcb/status/1604946331411292166","likes":24,"published":3,"flags":0,"usePreview":1,"tags":["math","optical","art","illusions"],"hasliked":0,"parentid":"","parentname":""}}