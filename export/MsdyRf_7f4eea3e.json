{"ver":"0.1","info":{"id":"MsdyRf","date":"1519806790","viewed":207,"name":"Spline based particle Movement","username":"ircss","description":"Trying out splines. Is there a way to draw a shape which has multiply y for a given x, using uv.x as input in a ploting function?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","particles","splines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define colorToDraw vec4(Points[0].y,Points[3].y,Points[1].y,1.0)\n#define toDraw cubic_bspline(Points, fract(iTime*0.3))\n\nvoid plotAPixel( inout vec4 buffer, in vec4 pixelColor,\n                in vec2 toDrawPos, in vec2 currentFragCord, float smoothness, float thickness)\n{\n    float distanceToPixel = distance( toDrawPos, currentFragCord);\n    float lerpFactor = smoothstep(thickness, thickness + smoothness, distanceToPixel);\n    buffer = mix( pixelColor, buffer, lerpFactor );\n}\n\nvec2 quadratic_bezier(vec2 A, vec2 B, vec2 C, float t)\n{\n\tvec2 D = mix(A, B, t);\n\tvec2 E = mix(B, C, t); \n\treturn mix(D, E, t);\n}\n\nvec2 cubic_bezier(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n\tvec2 E = mix(A, B, t);\n\tvec2 F = mix(B, C, t); \n\tvec2 G = mix(C, D, t); \n\treturn quadratic_bezier(E, F, G, t);\n}\n\nvec2 cubic_bspline(vec2 CP[10], float t)\n{\n\tfloat f = t * 3.0;\n\tint i = int(floor(f));\n\tif (t <= 0.0)\n\treturn CP[0];\n\tif (t >= 1.0)\n\treturn CP[9];\n\tvec2 A = CP[i * 3];\n\tvec2 B = CP[i * 3 + 1];\n\tvec2 C = CP[i * 3 + 2];\n\tvec2 D = CP[i * 3 + 3];\n\treturn cubic_bezier(A, B, C, D, fract(f));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randomInRange(in float lower, in float higher, in float period, in float seedDifference){\n     float ranVal = rand (vec2(seedDifference + floor(iTime/period)));\n     return lower + ranVal * (higher-lower);\n}\nvoid determineCurve(inout vec2 CP[10], float period, float particleDiff){\n    float RandSeed1=randomInRange(0.0, 1.0, period, particleDiff+241.);\n    float RandSeed2=randomInRange(0.0, 1.0, period, particleDiff+2431.);\n    float RandSeed3=randomInRange(0.0, 1.0, period, particleDiff+31.);\n    float RandSeed4=randomInRange(0.0, 1.0, period, particleDiff+2211.);          \n    \n    float u=iResolution.x/(iResolution.y);\n    \n    CP[0] = vec2(-0.1, RandSeed1);\n    CP[3] = vec2(4.0*u/10., RandSeed2);\n    CP[6] = vec2(RandSeed3*u, RandSeed3);\n    CP[9] = vec2(10.0*u/10. + 0.1, RandSeed4);\n    \n    vec2 v1=vec2(RandSeed1, (RandSeed1*2.-1.));\n    vec2 v2=vec2(RandSeed2, (RandSeed1*2.-1.));\n    vec2 v3=vec2(RandSeed3, (RandSeed1*2.-1.));\n    vec2 v4=vec2(RandSeed4, (RandSeed1*2.-1.));\n    \n    CP[1] = CP[0] + v1;\n    CP[2] = CP[3] - v2;\n    CP[4] = CP[3] + v2;\n    CP[5] = CP[6] - v3;\n    CP[7] = CP[6] + v3;\n    CP[8] = CP[9] - v4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    vec4 buff = vec4(0.0);\n    const float Period = 10./3.;\n    vec2 Points[10];\n    \n    determineCurve(Points, Period,32.);\n    plotAPixel(buff,colorToDraw + vec4(0.5) ,toDraw, uv, 0.02, 0.01);\n    \n    determineCurve(Points, Period,4124.);\n    plotAPixel(buff,colorToDraw + vec4(0.5) ,toDraw, uv, 0.02, 0.01);\n    \n    determineCurve(Points, Period,4.);\n    plotAPixel(buff,colorToDraw + vec4(0.5) ,toDraw, uv, 0.02, 0.01);\n    \n    fragColor =buff;\n}","name":"Image","description":"","type":"image"}]}