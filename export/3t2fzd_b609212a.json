{"ver":"0.1","info":{"id":"3t2fzd","date":"1599640219","viewed":108,"name":"Complex mapping","username":"copperbotte","description":"simple complex mapping visualizer. Work in progress\nThe functions fluid_sample_wall, fluid_cylinder, and electric_dipole all produce interesting plots. Uncomment the lines underneath fluid_cylinder to see the cylinder as well.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mathwip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct complex\n{\n    float real;\n    float imag;\n};\n\ncomplex c_neg(in complex This)\n{\n    complex res; // this is MUCH faster with vec2s.\n    res.real = -This.real;\n    res.imag = -This.imag;\n    return res;\n}\n    \ncomplex c_add(in complex This, in complex other)\n{\n    complex res; // this is easier, and probably faster with vec2s.\n    res.real = This.real + other.real;\n    res.imag = This.imag + other.imag;\n    return res;\n}\n    \ncomplex c_mul(in complex This, in complex other)\n{\n    complex res;\n    res.real = This.real*other.real - This.imag*other.imag;\n    res.imag = This.imag*other.real + other.imag*This.real;\n    return res;\n}\n\ncomplex c_inv(in complex This)\n{\n    float z = This.real*This.real + This.imag*This.imag; // geometric dot\n    complex res;\n    res.real = This.real / z;\n    res.imag = -This.imag / z;\n    return res;\n}\n\ncomplex c_pow(in complex This, float power)\n{\n    complex res;\n    \n    //complex numbers are either in a + ib form or re^(it) form\n    //complex powers are easier in polar form\n    //(re^(it))^p = r^p * e^(ipt)\n    //e^(ipt) is equal to cos(pt) + i*sin(pt)\n    \n    float rad = length(vec2(This.real, This.imag));\n    float t = atan(This.imag, This.real);\n    \n    rad = pow(rad, power);\n    t *= power;\n    \n    res.real = rad * cos(t);\n    res.imag = rad * sin(t);\n    \n    return res;\n}\n\ncomplex c_exp(in complex This)\n{\n\tcomplex res;\n   \t\n    //complex exponent, base e + 0i. equal to e * e^(i0)\n    //e^(a + ib)\n    //e^a * e^ib\n    //R * e^(iT)\n    \n    float res_rad = exp(This.real);\n    res.real = res_rad * cos(This.imag);\n    res.imag = res_rad * sin(This.imag);\n    \n    return res;\n}\n\ncomplex c_log(in complex This)\n{\n    complex res;\n    \n    //complex log, base e + 0i.\n    //ln(a + ib)\n    //ln(re^it)\n    //ln r + ln e^i(t + 2pi*n)\n    //ln r + i*(t + 2pi * n)\n    //A + iB\n    //imaginary is periodic every 2 pi n\n    \n    float rad = length(vec2(This.real, This.imag));\n    float t = atan(This.imag, This.real);\n    \n    res.real = log(rad);\n    res.imag = t;\n    \n    return res;\n}\n\n///////////////////////////////////////\n//Sample programs\n\ncomplex fluid_simple_wall(in complex c0)\n{\n    //z = w^2\n    //w = sqrt(z)\n    complex c = c0;\n    \n    //c = 1/c^2\n    //c = c_mul(c,c);\n    //c = c_inv(c);\n    \n    //c = c_mul(c,c);\n    \n    //without this rotation it looks weird\n    complex d;\n    d.real = 0.0;\n    d.imag = 1.0;\n    \n    c = c_pow(c, 0.5);\n    c = c_mul(c,d);\n    \n    return c;\n}\n\ncomplex fluid_cylinder(in complex c0)\n{\n    //w = z + 1/z\n    \n    complex c = c0;\n    \n    complex d = c0;\n    d.real *= 10.0;\n    d.imag *= 10.0;\n    \n    d = c_inv(d);\n    \n    return c_add(c, d);\n}\n\ncomplex electric_dipole(in complex c0)\n{\n    //z = (1+e^w) / (1-e^w)\n    //z = (1+u) / (1-u)\n    //z - zu = 1+u\n    //z - 1 = u + zu\n    //z - 1 = u(z+1)\n    //u = (z-1)/(z+1)\n    //w = ln((z-1) / (z+1))\n    //w = ln(z-1) - ln(z+1)\n    \n    complex left = c0;\n    left.real -= 1.0;\n    left = c_log(left);\n    \n    complex right = c0;\n    right.real += 1.0;\n    right = c_log(right);\n    \n    return c_add(left, c_neg(right));\n    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    if(iResolution.x > iResolution.y)\n    \tuv.x *= iResolution.x / iResolution.y;\n    else\n        uv.y *= iResolution.y / iResolution.x;\n    \n    complex c0;\n    c0.real = uv.x;\n    c0.imag = uv.y;\n    \n    complex c = c0;\n    \n    //c = fluid_simple_wall(c0);\n    \n    //c = fluid_cylinder(c0);\n    //if(length(uv) < 1.0 / sqrt(10.0))\n    //{\n    // \tfragColor = vec4(0.75,0.75,0.75,1.0);\n    //    return;\n    //}\n    \n    c = electric_dipole(c0);\n    \n    vec3 col = texture(iChannel0, vec2(c.real - iTime, c.imag)).xyz;\n    \n    //col = vec3(uv, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}