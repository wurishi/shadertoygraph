{"ver":"0.1","info":{"id":"ldGGzV","date":"1455583203","viewed":353,"name":"First Person Control","username":"jackdavenport","description":"First person camera control in a raymarcher. If the shader is too slow, comment out ENABLE_VOLUMETIRC_LIGHT<br/><br/>Use WASD to walk around.<br/>Use mouse to look around.<br/>Use Shift to sprint","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarcher","fp","control","perspective","look"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 512\n#define MIN_DISTANCE .001\n\n//#define ENABLE_VOLUMETRIC_LIGHT\n#ifdef ENABLE_VOLUMETRIC_LIGHT\n\t#define VOLUME_SAMPLES 5\n#endif\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dst { float dst; int id;  };\nstruct Hit { vec3 p; int id;     };\n\nstruct Light { vec3 v; vec3 c; float a; float l; };\n    \n// Source: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co) {\n    \n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n}\n    \nDst dstSphere(vec3 p, vec3 pos, float r, int id) {\n\n    return Dst(length(pos - p) - r, id);\n    \n}\n\nDst dstFloor(vec3 p, float y, int id) {\n \n    return Dst(p.y - y, id);\n    \n}\n\nDst minDst(Dst a, Dst b) {\n    \n    if(a.dst < b.dst) return a;\n    return b;\n    \n}\n\nDst dstScene(vec3 p) {\n \n    Dst dst = dstSphere(p, vec3(0.,0.,0.), 1., 0);\n    dst = minDst(dst, dstFloor(p, -1., 1));\n    \n    return dst;\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dst scn = dstScene(p);\n        p += ray.dir * scn.dst * .5;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n\nLight getLight(vec3 p) {\n \n    float t = iTime * 4.;\n    \n    vec3 pos = vec3(sin(t / 2.) * 2., abs(cos(t / 5.) * 2.) + .5, -1. + cos(t / 50.) * 3.);\n    float atten = 1. - smoothstep(0., 25., distance(pos, p));\n    \n    vec3 lv = pos - p;\n    return Light(normalize(lv), vec3(1.,.3,.3), atten, length(lv));\n    \n}\n\nbool inShadow(Hit scn, Light l) {\n \n    Ray sr = Ray(scn.p + l.v * .4, l.v);\n    Hit sh = raymarch(sr);\n    \n    if(sh.id != -1) return true;\n    return false;\n    \n}\n\nvec3 calcLighting(Hit scn, Light l, bool inShadow, vec3 n) {\n\n    float d = max(dot(l.v, n), 0.);\n\tif(inShadow) d = 0.;\n    \n    return l.c * d * l.a;\n    \n}\n\nvec3 calcSpecular(Ray ray, Light l, float shininess, bool inShadow, vec3 n) {\n \n    vec3 r  = normalize(reflect(ray.dir, n));\n    float s = max(pow(dot(r,l.v), shininess), 0.);\n    \n    if(inShadow) s = 0.;\n    return l.c * s * l.a;\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001, 0.);\n    vec3   n = vec3(dstScene(p + eps.xyy).dst - dstScene(p - eps.xyy).dst,\n                    dstScene(p + eps.yxy).dst - dstScene(p - eps.yxy).dst,\n                    dstScene(p + eps.yyx).dst - dstScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\n#ifdef ENABLE_VOLUMETRIC_LIGHT\nvec3 calcVolumetric(Ray ray, float maxDist) {\n \n    vec3 col = vec3(0.);\n    \n    float is  = maxDist / 50.;\n    float vrs = maxDist / float(VOLUME_SAMPLES - 1);\n    float rs  = rand(gl_FragCoord.xy) + vrs;\n    \n    Ray volRay = Ray(ray.ori + ray.dir * rs, vec3(0.));\n    \n    for(int v = 0; v < VOLUME_SAMPLES; v++) {\n     \n        Light l = getLight(volRay.ori);\n        vec3 lv    = l.v;\n        volRay.dir = lv / l.l;\n        Hit i      = raymarch(volRay);\n        \n        if(distance(i.p,ray.ori) > l.l) {\n         \n            col += (l.c * l.a) * is;\n            \n        }\n        \n        volRay.ori += ray.dir * vrs;\n        \n    }\n    \n    return col;\n    \n}\n#endif\n\nvec3 shade(Ray ray) {\n \n    Hit  scn = raymarch(ray);\n    Light l = getLight(scn.p);\n    \n    vec3 col = vec3(.3,.3,.8);\n    \n    if(scn.id == 0) {\n     \n        bool t = inShadow(scn, l);\n        vec3 n = calcNormal(scn.p);\n        \n        vec3 d = calcLighting(scn, l, t, n);\n        vec3 s = calcSpecular(ray, l, 45., t, n) * d;\n        \n        col = vec3(0.,1.,0.) * d + s;\n        \n    } else if(scn.id == 1) {\n    \n        bool s = inShadow(scn, l);\n        vec3 n = calcNormal(scn.p);\n        \n        vec3 d = calcLighting(scn, l, s, n);\n        col = texture(iChannel1, mod(scn.p.xz / 3., 1.)).xyz * d;\n        \n    }\n    \n    #ifdef ENABLE_VOLUMETRIC_LIGHT\n    vec3 vl = calcVolumetric(ray, min(distance(scn.p,ray.ori),10.));\n    col -= vl * .5;\n    col += vl;\n    #endif\n    \n    return col;\n    \n}\n    \nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = texture(iChannel0, vec2(0.)).xyz;\n    vec3 dir = vec3(uv, 1.);\n    \n    vec2 m = ((iMouse.xy == vec2(0.) ? vec2(.5) : (iMouse.xy / iResolution.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    \n    vec3 col = shade(Ray(ori,dir));\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MOVE_SPEED 3.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,-3.);\n    \n    float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}