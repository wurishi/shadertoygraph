{"ver":"0.1","info":{"id":"mddcD7","date":"1695633111","viewed":75,"name":"spheres latitude wireframe","username":"386dx25","description":"Reproduction of the cover image from \"Computers and People\", May-June 1987:\nhttps://archive.org/details/bitsavers_ComputersArsandPeopleV36N0506198705_13230288\n\nAn exercise in parameterizing a (hemi-)sphere over a disc and rotating the coordinate system.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","wireframe","sphere","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A re-creation of the cover image from \"Computers and People\", May-June 1987\n// by 386dx25 in 2023\nconst float pi = 3.14159;\n\n// Rodriguez rotation macro proposed by FabriceNeyret2, thanks!\n#define rot(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\nvec3 get_normalized_disc_coordinate(vec2 point, vec2 center, float radius)\n{\n    return vec3(vec2((point - center) / radius), 0.0);\n}\n\n// Return (u,v) params of hemisphere above disc at normalized 2D coordinate n\n// with latitude/longitude params in (0,1) each, rotated by gamma radians around x and y axis.\n// Assumes length(n) <= 1.0.\nvec2 get_normalized_disc_sphere_latlon(vec3 n, float gamma)\n{\n    // project disc to hemisphere\n    n.z = sqrt(1.0 - n.y*n.y - n.x*n.x);\n\n    // rotate\n    n = rot(rot(n,vec3(1,0,0),gamma), vec3(0,1,0),gamma);\n\n    // polar parameterization\n    vec2 polar = vec2(acos(n.z)/pi, (atan(n.y,n.x)+pi)/(2.0*pi));\n\n    return polar;\n}\n\nvec4 draw_disc_as_sphere_with_latlon(vec2 uv, float numLines, float linewidth) \n{\n    vec2 offset = vec2(0.1,0.0); // slight offset in latitude to exclude pole\n    \n    vec2 latlon = abs(mod(numLines*uv+offset, 1.0) - vec2(0.5));\n    \n    float hlw = linewidth / 2.0;\n    vec2 b = 1.0 - 2.0*smoothstep(0.5-hlw, 0.5+hlw, latlon);\n    float o = b.x; // or a) lat/lon.grid: b.x*b.y; b) discs: n/20.0;\n    return vec4(o,o,o,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates with 0 in center (one-liner taken from https://www.shadertoy.com/view/mdjXRR)\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Spheres as (x,y, radius, numLines) where (x,y) is normalized in [-1,1]\n    vec4 s[8] = vec4[](\n        vec4( 0.04,  0.3,  0.11, 10.0),\n        vec4(-0.2,  -0.2,  0.1,   5.0),\n        vec4(-0.2,   0.2,  0.2,   8.0),\n        vec4( 0.2,  -0.3,  0.2,  10.0),\n        vec4( 0.0,   0.0,  0.25, 16.0),\n        vec4( 0.3,   0.3,  0.3,   9.0),\n        vec4(-0.5,   0.1,  0.15,  3.0),\n        vec4(-0.25, -0.25, 0.35,  7.0)\n    );\n\n    // Evaluate which sphere to draw\n    for(int i=0; i<8; ++i)\n    {\n        // Absolute radius (in normalized screen system)\n        float r = s[i].z;\n        \n        // Normalized disc coordinate\n        vec3 n = get_normalized_disc_coordinate(p, s[i].xy, r);\n\n        float global_linewidth = 1.5 + 6.0*(1.0 - smoothstep(0.0,800.0,max(iResolution.x,iResolution.y)));\n\n        if(length(n) > 1.0 + global_linewidth*0.01) // TODO: Consider border width correctly\n        {\n            continue;\n        }\n\n        // Rotation angle\n        float individualize = + min(100.0,1.1/s[i].x) + 1.1/r;\n        float gamma = pi*iTime*0.1 + individualize; //  warp by adding length(n)\n\n        // Relative radius in (0,1) inside the disc\n        float dr = length(n);\n\n        // Spherical parameterization in (0,1), with z-coordinate 0/1 inside/outside of disc\n        vec2 sphere_uv = get_normalized_disc_sphere_latlon(n, gamma);\n\n        // Disc border\n        float dist_border = abs((dr-1.0)*r)*(1000.0/global_linewidth);\n        float border = smoothstep(0.0,1.0,dist_border);\n        vec4 border_color = vec4(border,border,border,1.0);\n        \n        // Sphere\n        float linewidth = global_linewidth*0.004/s[i].z; // TODO: Consider du/dv for constant linewidth across sphere\n        float dist = 0.3*s[i].w;\n        vec4 sphere_color = draw_disc_as_sphere_with_latlon(sphere_uv, s[i].w, dist*linewidth);\n        \n        fragColor = min(border_color, sphere_color);\n        break;\n    }\n}","name":"Image","description":"","type":"image"}]}