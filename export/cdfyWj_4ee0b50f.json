{"ver":"0.1","info":{"id":"cdfyWj","date":"1687189071","viewed":69,"name":"no ray marching light 2D","username":"poipoi34","description":"Click to move the light source.\nVery basic thing to make light in 2D with circles and segments in the scene.\nNo ray marching, just checking if direct path get to pixel to color it.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//pour chaque pixel p, chaque lum l, verifier la colision entre le segement pl et chaque objet de la scène\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat dist_seg_circle(vec2 A, vec2 B, vec2 c, float r)\n{\n    return distanceToSegment(A,B,c) - r;\n}\n\nbool collide_seg_seg(vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    if (A.x == B.x && C.x == D.x)\n    {\n        // on return true si A,B,C,D ont la même coordoné x et soit C, soit D est entre A et B:\n        return ((B.x == C.x) && ((A.x-C.x)*(B.x-C.x) < 0. || (A.x-D.x)*(B.x-D.x) < 0.));\n    }\n    if (A.x == B.x)\n    {\n        return false;\n    }\n    if (C.x == D.x)\n    {\n        return false;\n    }\n    \n    float m1 = (B.y-A.y)/(B.x-A.x);\n    float m2 = (D.y-C.y)/(D.x-C.x);\n    float p1 = A.y - m1 * A.x;\n    float p2 = C.y - m2 * C.x;\n    \n    float x0 = (p2-p1)/(m1-m2);\n    \n    if ((A.x - x0)*(B.x - x0) < 0. && (C.x - x0)*(D.x - x0) < 0.)\n        return true;\n    else\n        return false;\n    \n}\n\nfloat dist_point_circle(vec2 p, vec2 c,float r)\n{\n    return length(p-c)-r;\n}\n\nstruct lum\n{\n    vec3 col;\n    float decay;\n    float shine_factor;\n};\n\nstruct circle\n{\n    vec2 c;\n    float r;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1 in the y axis)\n    vec2 uv = fragCoord / iResolution.y;\n    vec4 m = iMouse / iResolution.y;\n    \n    vec3 lum_col = vec3(0.7,0.7,0.3);\n    \n    vec3 lum2_col = vec3(0.9,0.6,0.4);\n    vec2 lum2_pos = vec2(1.5,0.5);\n    \n    vec3 bg_col = vec3(0.2,0.1,0.3);\n    \n    float lum_decay = 0.92; // per 0.1 distance\n    float shine_factor = 0.2;\n    \n    \n    vec2 c1 = vec2(0.8,0.5);\n    float r1 = 0.05;\n    \n    vec2 c2 = vec2(0.2,0.3);\n    float r2 = 0.1;\n\n    vec2 A = vec2 (0.4,0.1);\n    vec2 B = vec2 (1.5,0.2);\n\n    vec3 col = lum_col;\n    float d = length(uv-m.xy);\n    col *= pow(lum_decay,10.*(d-shine_factor));\n    \n    \n    if (dist_seg_circle(uv,m.xy,c1,r1) < 0.)\n        col = bg_col;\n    if (dist_seg_circle(uv,m.xy,c2,r2) < 0.)\n        col = bg_col;\n    if (collide_seg_seg(uv,m.xy,A,B))\n        col = bg_col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}