{"ver":"0.1","info":{"id":"DdcyWn","date":"1694895701","viewed":59,"name":"procedural mc dynamic texture","username":"snekjar","description":"playing with a minecraft cube","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","texture","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Global variables\nfloat fov = 5.0;\nfloat camDistance = 100.0;\nfloat pitch = 0.5;\nfloat yaw = 0.5;\nfloat roll = 1.0;\nfloat lerpFactor = 0.5; \nfloat moveX = 0.0;  \nfloat moveY = 0.0;  \nfloat gridSize = 8.0; // For example, 8x8 grid\nvec3 green = vec3(0.0, 1.0, 0.0);\nvec3 brown = vec3(0.6, 0.3, 0.0);\n\n\nvec4 quatMul(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nvec3 rotateByQuat(vec3 p, vec4 q) {\n    vec4 pQuat = vec4(p, 0.0);\n    vec4 conjQuat = vec4(-q.xyz, q.w);\n    vec4 rotated = quatMul(quatMul(q, pQuat), conjQuat);\n    return rotated.xyz;\n}\n\nvec3 randomColorFromUV(vec2 uv, float time) {\n    float t = fract(sin(dot(uv + vec2(time), vec2(12.9898, 78.233))) * 43758.5453);\n    return mix(green, brown, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    uv *= tan(radians(fov * 0.5));\n\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec4 pitchQuat = vec4(sin(pitch / 2.0) * up, cos(pitch / 2.0));\n    vec4 yawQuat = vec4(sin(yaw / 2.0) * vec3(0.0, 1.0, 0.0), cos(yaw / 2.0));\n    vec4 rollQuat = vec4(sin(roll / 2.0) * vec3(0.0, 0.0, 1.0), cos(roll / 2.0));\n    vec4 orientation = quatMul(rollQuat, quatMul(pitchQuat, yawQuat));\n\n    vec3 originalDir = vec3(0.0, 0.0, -1.0);\n    vec3 camDir = rotateByQuat(originalDir, orientation);\n\n    vec3 camPos = camTarget - camDir * camDistance;\n    camPos.xy += vec2(moveX, moveY);\n\n    vec3 right = cross(up, camDir);\n    vec3 rayDir = normalize(camDir + uv.x * right + uv.y * up);\n\n    // Cube bounds\n    vec3 boxMin = vec3(-1.0);\n    vec3 boxMax = vec3(1.0);\n    vec3 tMin = (boxMin - camPos) / rayDir;\n    vec3 tMax = (boxMax - camPos) / rayDir;\n    vec3 t0 = min(tMin, tMax);\n    vec3 t1 = max(tMin, tMax);\n    float tNear = max(max(t0.x, t0.y), t0.z);\n    float tFar = min(min(t1.x, t1.y), t1.z);\n\n    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));\n    vec3 hitPoint = camPos + tNear * rayDir;\n    vec3 normal = vec3(0.0);\n\n    vec2 faceUV = vec2(0.0);\n    if(abs(hitPoint.x) > 0.999) {\n        faceUV = hitPoint.yz;\n        normal = vec3(sign(hitPoint.x), 0.0, 0.0);\n    } else if(abs(hitPoint.y) > 0.999) {\n        faceUV = hitPoint.xz;\n        normal = vec3(0.0, sign(hitPoint.y), 0.0);\n    } else if(abs(hitPoint.z) > 0.999) {\n        faceUV = hitPoint.xy;\n        normal = vec3(0.0, 0.0, sign(hitPoint.z));\n    }\n    faceUV = (faceUV + 1.0) * 0.5; // normalize UV to [0,1] range\n\n      \n    // Adjust to grid\n    faceUV = floor(faceUV * gridSize) / gridSize + (0.5 / gridSize);\n\n\n    float diffuse = max(0.0, dot(normal, lightDir));\n     vec3 faceColor = randomColorFromUV(faceUV, iTime);\n    \n    if (tNear < tFar) {\n        fragColor = vec4(vec3(diffuse) * faceColor, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}