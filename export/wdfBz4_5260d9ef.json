{"ver":"0.1","info":{"id":"wdfBz4","date":"1587759231","viewed":176,"name":"Alone","username":"livvy","description":"Song: Leafar Legov - Alone [Giegling]\n\nJust trying my hand at some raymarched geometry using distance functions and some phong shading. I thought I'd add some music to tie it all into some kind of theme. =)\n\nThanks to:\n@mla for the tips\n@iq for resources","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["phong","raymarched","music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MljGDW","filepath":"https://soundcloud.com/billybelgium/leafar-legov-alone-unreleased","previewfilepath":"https://soundcloud.com/billybelgium/leafar-legov-alone-unreleased","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n*/\n\n#define MAX_STEPS 300\n#define MAX_DEPTH 50.0\n#define EPSILON 0.001\n\nmat2 rot(float a)\n{\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// iq's anti-aliased checker pattern\nfloat checkers(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 0.9*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 1.2 - 0.5*i.x*i.y;\n}\n\nfloat opSU(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n  return mix( d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat line( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat pln(vec3 p, vec3 n, float d)\n{\n  return dot(p, n) - d;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sph(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat pyramid(vec3 p) {\n   float s = 1.2;\n   p.xz = abs(p.xz);\n   float l1 = line(p,vec3(s, -s, s),vec3(0, -s, s));\n   float l2 = line(p,vec3(s, -s, s), vec3(s, -s, 0));\n   float l3 = line(p,vec3(0, s, 0), vec3(s, -s, s));\n   return min(min(l1,l2),l3)-0.025;\n}\n\n\nfloat sdf(vec3 p)\n{\n  p.xz *= rot(iTime/2.0)*rot(0.3);\n\n  float t = iTime/2.0;\n  float c = cos(t)/3.;\n  float s = sin(t)/3.;\n \n  float p1 = pln(p, vec3(0.0, 1.0, 0.0), -2.0);\n  float py1 = abs(pyramid(p));\n  \n  vec3 ps = p-vec3(0,-0.43,0);\n  float r = 0.5;\n  float us = 0.4;\n  float s1 = sph(ps-vec3(c,  0., s ), r);\n  float s2 = sph(ps-vec3(c,  s , 0.), r);\n  float s3 = sph(ps+vec3(0., c , s ), r);\n  float fft = texture(iChannel0, vec2(0.35, 0.)).r*.1;\n\n  float ss = opSU(opSU(s1, s2, us), s3, us)-fft;\n  return min(min(ss, py1), p1);\n}\n\nvec3 getNormal(vec3 p) {\n   const float h = 0.00001;\n   const vec2 k = vec2(1,-1);\n   return normalize( k.xyy*sdf( p + k.xyy*h ) +\n                     k.yyx*sdf( p + k.yyx*h ) +\n                     k.yxy*sdf( p + k.yxy*h ) +\n                     k.xxx*sdf( p + k.xxx*h) );\n}\n\nvec3 phongLightContrib(vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightInt)\n{\n  vec3 N = getNormal(p);\n  vec3 L = normalize(lightPos - p);\n  vec3 V = normalize(eye - p);\n  vec3 R = normalize(reflect(-L, N));\n\n  float dotLN = dot(L, N);\n  float dotRV = dot(R, V);\n\n  if (dotLN < 0.0) {return vec3(0.0);}\n  if (dotRV < 0.0) {return lightInt * (kd * dotLN);}\n  return lightInt * (kd * dotLN + ks * pow(dotRV, alpha));\n}\n\nvec3 phong(vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye)\n{\n  const vec3 ambientLux = vec3(0.3);\n  vec3 colour = ambientLux * ka;\n  \n  vec3 light1Pos = vec3(0.0, 0.4, -2.0);\n  vec3 light1Int = vec3(0.7);\n  \n  vec3 light2Pos = vec3(0.0, 0.5, -1.0);\n  vec3 light2Int = vec3(0.3);\n  \n  colour += phongLightContrib(kd, ks, alpha, p, eye, light1Pos, light1Int);\n  //colour += phongLightContrib(kd, ks, alpha, p, eye, light2Pos, light2Int);\n  return colour;\n}\n\nvec3 calcSceneColour(vec3 p, float t1, vec3 ro)\n{\n  vec3 lum = phong(\n    vec3(  0.7,  0.0, 0.0), // ambient\n    vec3(  1.0,  0.0, 0.0), // diffuse\n    vec3(  1.0, 1.0, 1.0), // spectral\n    3000.0,                 // shininess\n    p,\n    ro\n  );\n  return lum;\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n  vec3  col   = vec3(0);\n  float depth = 10.0/float(MAX_STEPS);\n  float dist;\n  vec3 pf;\n  vec3 rf;\n  vec3 pp;\n  float tf;\n  for (int i=0; i<MAX_STEPS; i++)\n  {\n      vec3 p = ro + rd * depth;\n      p.y -= 1.3;\n      p.z -= 0.5;\n      dist = sdf(p.xyz);\n      if (depth > MAX_DEPTH) {\n          break;\n      } else if (dist < EPSILON)\n      {\n        pf = p;\n        tf = depth;\n        rf = ro;\n        if (pf.y > -1.4) {\n           col = calcSceneColour(p, tf, rf);\n        }\n        break;\n      }\n      depth += dist*0.85;\n  }\n  if (pf.y < -1.4) {\n          pf.xz *= rot(iTime/2.0) * rot(0.3);\n\n    float r = texture(iChannel0, vec2(0.35, 0.)).r*.7;\n    col = vec3(checkers(pf.xz)*mix(vec3(0.24,0.03,0.15), vec3(0.3,0.03,0.4), r));\n    col*=30.0/(tf*tf*tf);\n  } else {\n   \n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = vec3(0.0,1.0,-4.0);\n  vec3 rd = vec3(uv, 1.0);\n  vec3 c = march(ro, rd);\n  fragColor = vec4(c, 1.0);\n  fragColor = vec4(pow(c,vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"}]}