{"ver":"0.1","info":{"id":"7sKGRK","date":"1642786127","viewed":87,"name":"Trypophobia Sphere","username":"Catarina","description":"Messing around with raymarch for the first time","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .01\n\n#define PI 3.14159265358\n#define INFINITY 1./0.\n\nprecision highp float;\n\nstruct Light{\n vec3 pos;\n vec3 color;\n float intensity;\n};\n\nstruct LambertMaterial{\n vec3 albedo;\n};\n\nstruct Sphere{\n vec3 pos;\n float radius;\n LambertMaterial material;\n};\n\nstruct Ray{\n vec3 origin;\n vec3 direction;\n};\n\nstruct Hit{\n vec3 pos;\n float dist;\n LambertMaterial material;\n};\n\nstruct Scene{\n Light light1;\n Light light2;\n Sphere sphere;\n};\n\nScene createScene(){\n Light light1 = Light(\n     //vec3(cos(iTime)*3.8,\n    vec3(\n    0.,\n    3.2,\n    -10.),\n    //sin(iTime)*3.8-8.),\n    vec3(0.8, 0.9, 0.8),\n    4.);\n Light light2 = Light(\n  vec3(0., 1.5, 8.),\n  vec3(0.7, 0.3, 0.5),\n  2.\n );\n\n Sphere sphere = Sphere(\n  vec3(0., 1.5, 8.),\n  1.,\n  LambertMaterial(vec3(0.99, 0.6, 0.6)));\n\n Scene scene = Scene(\n  light1,\n  light2,\n  sphere\n );\n return scene;\n}\n\nfloat GetDist(vec3 p, inout Scene scene, bool getl){\n    Sphere s = scene.sphere;\n    //Light l = scene.light1;\n\n  vec3 ps = p-s.pos;\n  //float sphereDist = length(ps) - s.radius;\n\n\n  float sphereDist = length(ps)\n   -s.radius\n   * mix(\n    length(cos(ps*iTime/2.)),\n    length(sin(ps*iTime/2.)),\n    0.5\n    );\n\n\n\n  //float lightDist = length(p-l.pos)-0.1;\n  /*vec3 ps = p-s.pos;\n    float sphereDist = length(ps)\n     -s.radius *\n      length(cos((ps)*iTime));*/\n    //float planeDist = p.y;\n    float d = sphereDist;\n    //float d = min(sphereDist, planeDist);\n    //if (getl) d = min(d, lightDist);\n    return d;\n}\n\nHit RayMarch(Ray ray, inout Scene scene, bool getl) {\n  vec3 rd = ray.direction;\n  vec3 ro = ray.origin;\n    float dO=0.;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO; // current march location\n        float dS = GetDist(p, scene, getl); // next march step\n        dO += dS; //\n        if(dS  < SURF_DIST){\n         //dO = INFINITY;\n         break;\n       }\n       if (dO > MAX_DIST){\n        dO = INFINITY;\n        break;\n       }\n    }\n\n  float dist = dO;\n    vec3 hitPoint = ro + rd * dist;\n    Hit hit = Hit(hitPoint, dist, scene.sphere.material);\n  return hit;\n}\n\nvec3 GetNormal(vec3 p, inout Scene scene) {\n    float d = GetDist(p, scene, false);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d-vec3(\n        GetDist(p-e.xyy, scene, false),\n        GetDist(p-e.yxy, scene, false),\n        GetDist(p-e.yyx, scene, false));\n\n    return normalize(n);\n}\n\nvec3 GetLight(Hit hit, inout Scene scene) {\n  vec3 dif = vec3(0.);\n  vec3 p = hit.pos;\n  vec3 albedo = hit.material.albedo;\n\n  //if(length(p-light.pos) < 0.11) return light.color;\n  Light light = scene.light1;\n    vec3 l = normalize(light.pos-p);\n    vec3 n = GetNormal(p, scene);\n  float lightValue = clamp(dot(n, l), 0., 1.);\n    dif += albedo / PI * lightValue * light.color * light.intensity;\n\n   light = scene.light2;\n    l = normalize(light.pos-p);\n    n = GetNormal(p, scene);\n  lightValue = clamp(dot(n, l), 0., 1.);\n    dif += albedo / PI * lightValue * light.color * light.intensity;\n\n    // making shadow\n    /*Ray lightRay = Ray(\n     p+n*SURF_DIST*1.5,\n     l);\n      float d = RayMarch(lightRay, scene, false);\n      if(d<length(light.pos-p)) dif *= .1;\n      */\n  vec3 col = vec3(0.2, 0.05, 0.05);\n    return col+dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n  Scene scene = createScene();\n\n  // from -0.5 to 0.5\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    // output color\n    vec3 color = vec3(0.1, 0.1, 0.1);\n\n  // Ray\n    /*vec3 ro = vec3(\n     cos(iTime),\n     1.5+cos(iTime)*sin(iTime),\n     sin(iTime)); */\n    vec3 ro = vec3(0., 1.5, cos(iTime));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    Ray ray = Ray(ro, rd);\n\n    Hit hit = RayMarch(ray, scene, true);\n    if(hit.dist < MAX_DIST){\n     vec3 diffuse = GetLight(hit, scene);\n     color = diffuse;\n   }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}