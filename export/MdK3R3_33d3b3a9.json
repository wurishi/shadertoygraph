{"ver":"0.1","info":{"id":"MdK3R3","date":"1455678337","viewed":665,"name":"Classical Water Fountain","username":"Hamneggs","description":"Here's a fountain that's strewn apart every buffer so it will compile. Procedural texturing with multiple ray bounces makes NVidia's Cg compiler angry. Try out HIGH_QUALITY mode in buffers A and Image!","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["procedural","reflection","ray","refraction","water","marching","fountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tA raymarched fountain, by Gerard Geer.\n\n\tThis shader takes more than advantage of multipass, mainly so that\n\tit doesn't crash the browser when compiling. Also because it's cool.\n\n\tThis buffer and buffer B have a HIGH_QUALITY option that takes this shader\n\tfrom snazzy all the way to jazzy! (It bumps the underwater tiles, and adds\n\thigh frequency noise to the basin, basin trim, and ground.)\n\n\tIf you want to trade framerate for reduced warpiness, increase V_STEPS in buffer A and B.\n\t\n\tBuffer A: Calculates first bounce position, and if a ray hits nothing, stores its direction.\n\tBuffer B: Marches everything again to store surface normals.\n\tBuffer C: Uses A and B to march to and store reflected ray intersections if the starting position\n\t\t\t  was water. Otherwise it calculates the sky color and stores it.\n\tBuffer D: Does the same thing but for refractions. This doesn't give a crap about the sky color though.\n\tImage Buffer: Texturing and lighting.\n\tSound: Chopin's Nocturne in Eb Major, Op 2, until the shutter falls. Then it's a foreign movie. In 3D!\n*/\n\t\t\n//#define HIGH_QUALITY\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 3.5\n// Occlusion probe length.\n#define OCC_DIST .125\n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 25.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Shadow marching steps.\n#define S_STEPS 20\n// Maximum successful marching distance.\n#define EPSILON .0005\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// Entity IDs.\n#define ID_NONE  0.0\n#define ID_WATER 1.0\n#define ID_BASIN 2.0\n#define ID_BTRIM 3.0\n#define ID_TOWER 4.0\n#define ID_BOWL  5.0\n#define ID_GRND  6.0\n\n// Buffer definitions.\n#define PRI_TEX iChannel0\n#define NRM_TEX iChannel1\n#define RFL_TEX iChannel2\n#define RFR_TEX iChannel3\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.408248, 0.816497, -0.408248); \t// Sun direction.\nconst vec3 SKY_COLOR_AVG = vec3(0.407, 0.709, 0.918);\t\t// Sky color.\nconst vec3 SUN_COLOR = vec3(4.0);\t\t\t\t\t\t\t// Sun color.\nconst vec3 GROUND_COLOR = vec3(0.73,0.60,0.47);\t\t\t\t// Average color of the ground for fake GI.\nconst vec3 STN_COLOR_A = vec3(0.5808, 0.528, 0.462);        // One shade of the stone.\nconst vec3 STN_COLOR_B = vec3(0.33, 0.297, 0.2442);         // The other one.\nconst vec3 TILE_COLOR_A = vec3(.3,.45,.5);\t\t\t\t\t// The lighter tile color.\nconst vec3 TILE_COLOR_B = vec3(.1,.2,.4);\t\t\t\t\t// The darker one.\n\n// Camera parameters.\nconst vec3 CAM_LOOK_AT = vec3(0.0, 1.0, 0.0);\nconst float CAM_DIST_AWAY = 8.0; // How far away the camera is from CAM_LOOK_AT.\nconst float CAM_ZOOM = 1.0;\n\n#define WN_TEX iChannel0\n#define GEOM_TEX iChannel1\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera( in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd )\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tIQ's procedural Perlin noise implementation. \n*/\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n/*\n\tHis procedural Voronoi as well, but simplified to only \n\treturn the nearest distance.\n*/\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n/*\n\tA simple unrolled FBM.\n*/\nfloat fbm( in vec3 p )\n{\n    float r = noise(p)*.500;\n    r += noise(p*2.0)*.250;\n    r += noise(p*4.0)*.125;\n    return r *1.1429;\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tI think we all know where this came from.\n*/\nfloat cyl( vec3 p, vec2 h ) // h = <r,h>\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tAnother IQ distance function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tIt's nice to have a catalog of primitives, isn't it guys?\n*/\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\n/*\n\tHere we take a short and wide cylinder, subtract a narrower\n\tbut taller cylinder to hollow it out, then subract a shorter\n\tbut wider one to leave only the top and bottom.\n*/\nfloat basinTrim( vec3 p )\n{\n    // Since we already have the surface normal stored in buffer B, \n    // we can use that for primary bounce lighting. This means that\n    // the distance fields here are only used in shadow marching and\n    // occlusion sampling. We don't need the fully bumped \n    // fields for that. Sure, fidelity of those effects suffer,\n    // but compileability goes up. :)\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.05,.35));\n    float hollowing = cyl(p,vec2(2.70,.8));\n    float cutout = cyl(p,vec2(4.0,.3));\n    float r = max( exterior,\n               -hollowing);\n    return max(r,-cutout);\n    \n}\n\n\n#ifdef HIGH_QUALITY\n/*\n\tTake one cylinder, and min() it out with another cylinder just\n\tlike a bread bowl. Oh, we also modulate the radius of the outer\n\t\n*/\nfloat basinSmooth( in vec3 p )\n{\n    p.y -= .35;\n    float d = length(p.xz)-3.5, ripples = 0.0;\n    // We would miss these a whole lot when doing shadow marching.\n    // The inverse trig call stays.\n    if( d < .02 )\n    {\n        ripples = (sin(atan(p.z/p.x)*60.0));\n        ripples *= ripples;\n        ripples *= .02;\n    }\n    \n    float exterior = cyl(p,vec2(3.0-ripples,.35));\n    p.y -= .1;\n    float cutout = cyl(p,vec2(2.75,.35));\n    float r = max( exterior,\n                  -cutout);\n    \n    return r;\n    \n}\nvec3 basinNorm( in vec3 p )\n{\n\treturn normalize(vec3(basinSmooth(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  basinSmooth(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  basinSmooth(vec3(p.x,p.y,p.z+EPSILON)))-basinSmooth(p));\n}\nfloat tileBump( in vec2 p )\n{\n    p *= 10.0;\n    vec2 f = fract(p)-.5;\n    f*=2.0;\n    f = abs(f);\n    return smoothstep(.8,1.0,clamp(max(f.x,f.y),.8,1.0));\n}\nfloat basin( in vec3 p )\n{\n    float d = basinSmooth(p), pol = 0.0, bump = 0.0;\n    vec3 n = vec3(0);\n    if( d < .01 )\n    {\n        n = basinNorm(p);\n        pol = mod(atan(p.z/p.x)*3.14, 3.14)-1.57;\n        bump = tileBump(p.xz)*abs(n.y)+\n                     tileBump(vec2(pol,p.y))*(1.0-abs(n.y));\n        bump *= step(length(p.xz),2.75);\n    }\n    return d + bump*.005;\n    \n}\n#else\n\n/*\n\tTake one cylinder, and min() it out with another cylinder just\n\tlike a bread bowl. Oh, we also modulate the radius of the outer\n\t\n*/\nfloat basin( in vec3 p )\n{\n    p.y -= .35;\n    float d = length(p.xz)-3.5, ripples = 0.0;\n    // We would miss these a whole lot when doing shadow marching.\n    // The inverse trig call stays.\n    if( d < .02 )\n    {\n        ripples = (sin(atan(p.z/p.x)*60.0));\n        ripples *= ripples;\n        ripples *= .02;\n    }\n    \n    float exterior = cyl(p,vec2(3.0-ripples,.35));\n    p.y -= .1;\n    float cutout = cyl(p,vec2(2.75,.35));\n    float r = max( exterior,\n                  -cutout);\n    \n    return r;\n    \n}\n#endif\n\n\n/*\n\tSmush two spheres, and subtract one from the other.\n*/\nfloat bowl( in vec3 p )\n{\n    vec3 q = p;\n    p.y -= 2.90;\n    p.y *= 1.75;\n    q.y -= 3.00;\n    q.y *= 1.75;\n    return max(length(p)-.50,-length(q)+.50);\n}\n\n/*\n\tThis takes the cylinder distance field and modulates its radius\n\tbased on height and xz theta.\n*/\nfloat tower( vec3 p )\n{\n    p.y -= .65; // Translate.\n    \n    // Test to see if we are within a distance that need worry\n    // about surface displacement.\n    float d = length(p.xz)-.150, n = 0.0, r = .125;\n    \n\tif( d < .2 )\n    {\n        // Modulate the radius based on height.\n        n = sin(p.y*8.0+sin(p.y*10.0));\n        r += (n*n*.0625);\n    \n        // Give it some ripples.\n        r -= abs(sin(atan(p.z/p.x)*10.0))*.005;\n    }\n    \n    // Combine the bowl and the tower.\n \treturn capsule(p,vec3(0,-1,0),vec3(0,3,0),r);\n}\n\n/*\n\tWe don't care about the bumpmapping of the ground here. It only complicates\n\tshadowing and since the \"nearest distance\" tennant of distance field functions\n\tis struck down by modulating this function, AO doesn't work at all.\n*/\nfloat ground( in vec3 p )\n{\n    return p.y;\n}\n\n/*\n\tThe core distance function. This is only used for the shadows and ambient\n    occlusion.\n*/\nfloat dist( in vec3 p )\n{\n    float r = min(basin(p),basinTrim(p));\n    r = min(r,tower(p));\n    return min(r,bowl(p));\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir)\n{    \n\tfloat t = EPSILON;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float d = dist( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, PENUMBRA_FACTOR * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    float unit = OCC_DIST/OCC_SAMPLES;\n    // They see me unrollin', they hatin'...\n    result += pow(2.0,s*unit*1.0)*(unit*1.0-dist(pos+norm*unit*1.0));\n    result += pow(2.0,s*unit*2.0)*(unit*2.0-dist(pos+norm*unit*2.0));\n    result += pow(2.0,s*unit*3.0)*(unit*3.0-dist(pos+norm*unit*3.0));\n    \n\treturn clamp(1.0-result*OCC_FACTOR,0.0,1.0);\n}\n\n/*\n\tThis snake oil salesman sells you a colorized fbm as stone.\n\tGo chase him off your lawn!\n*/\nvec3 texStone( in vec3 p )\n{\n    p *= 15.0;\n    return clamp( mix(STN_COLOR_A, STN_COLOR_B,fbm(p)), 0.0, 1.0 );\n}\n\n/*\n\tThis is the tile texture on the inside of the basin.\n*/\nvec3 tileTex( in vec2 p )\n{\n    p *= 10.0;\n    p = floor(p);\n    p = mod(p,8.0);\n    return mix(TILE_COLOR_A,TILE_COLOR_B,floor(max(p.x,p.y)/7.0));\n}\n\n/*\n\t\"Hmm, how can we make fake pool-bottom lighting?\"\n\t*Screws with FBM for an hour.*\n\t\"I'm never going to get there warping fbm.\"\n\t*Remembers cellular noise*\n\t*Domain-warps Voronoi*\n\t*One compile later*\n\t\"EFF ME THAT WAS EASY\"\n*/\nfloat fakeCaustics( in vec3 p )\n{\n    p *= 10.0; // Scaling.\n    return pow(voronoi(p+iTime*2.0+fbm(p+iTime*2.0)).x,5.)*1.5;\n}\n\n/*\n\tYou see, the basin's a bit of a chore. The walls need to be textured\n\tin the polar domain, and the bottom in cartesian, and since this\n\twill be called super deep we don't want to chance it with conditionality.\n\tAnd so we do the mix and step dance to get things moving.\n*/\nvec3 texBasin( in vec3 p )\n{\n    return mix( tileTex(p.xz), // Bottom\n                tileTex(vec2( mod(atan(p.z/p.x)*3.14, 3.14)-1.57, p.y)), // Sides\n                step(.125,p.y) ); // Are we at the bottom or not? -> 0,1\n}\n\n/*\n\tThe ground's just tile too, but this time we do the ol' floored hash\n\tto get random shades. (but not a messy Waffle House)\n*/\nvec3 texGround( in vec3 p, in vec3 stone )\n{\n    p *= 2.5;\n    p.y += .5; // Now floor won't return a different vale in the grooves.\n    return mix(hash(p) * vec3(.125,.15,.1) + .1, // The grout. It's a little green for the appearance of moss.\n               stone * .6 * (.5+length(hash(floor(p)))), // The random tile colors mentioned before.\n               smoothstep(.47,.472,p.y)); // The \"is it grout?\" test.\n}\n\n/*\n\tThis function shades all surfaces that are \"dry\". In the world of this\n\tfountain, everything is dry except the inside tiles. We pre-compute and\n\tpass in the shadowing and AO because for some reason moving them up\n\tto the prior function call eases compilation constipation. (The browser\n\tstopped crashing on compilation when I made such a change. \n\tGTX 660, Chrome x64, Win10.)\n*/\nvec3 shadeDry( in vec3 p, in vec3 d, in vec3 n, in vec3 t, in float sdw, in float amb )\n{\n    \n    // Get light colors and irradiance for the three lights.\n    vec3 skc = orenNayar(n,-d,UP)*SKY_COLOR_AVG;\t\t\t// Ambient sky lighting.\n    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;\t\t// Direct lighting from the sun.\n    vec3 gnd = orenNayar(n,-d,-SUN_DIR)*GROUND_COLOR;\t// Faux secondary illumination.\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= sdw;\n    \n    // Return the sum.\n    return t * (skc+gnd+sun+vec3(.05));\n}\n\n/*\n\tShades the wet surfaces. This is just Phong lighting, with AO.\n*/\nvec3 shadeWet( in vec3 p, in vec3 d, in vec3 n, in vec3 t, in float sdw, in float amb )\n{\n    vec3 r = reflect(-d,n);\n    vec3 spec = SUN_COLOR * pow(clamp(dot(r,SUN_DIR),0.0,1.0),400.0);\n    vec3 diff = t * clamp(dot(n,SUN_DIR),0.0,1.0);\n    vec3 ambi = t * .15*amb;\n    return spec*sdw + diff*sdw + ambi;\n}\n\n/*\n    Shades reflection and refraction images. We can reuse the stone tex\n    from the first pass beacuse the stone is just an FBM, and it's very,\n    very distorted. One can't tell the difference. The tiles on the other\n    hand have too many details.\n*/\nvec3 shadeRflRfr( in vec3 p, in vec3 d, in vec3 n, in vec3 stoneTex, in float cst, in float i )\n{\n    float sdw = shadow(p,SUN_DIR);\n    if( i == ID_NONE ) return SKY_COLOR_AVG;\n    else if( i == ID_BTRIM ) return shadeDry(p,d,n,stoneTex,sdw,1.0);\n    else if( i == ID_BASIN )\n    {\n        if( length(p.xz) < 2.8 ) return shadeWet(p,d,n,texBasin(p)*(1.+cst),sdw,1.0);\n        else return shadeDry(p,d,n,stoneTex,sdw,1.0);\n    }\n    else if( i == ID_TOWER ) return shadeDry(p,d,n,stoneTex,sdw,1.0);\n\telse if( i == ID_BOWL ) return shadeDry(p,d,n,stoneTex*(1.+cst),sdw,1.0);\n    // WHY DOESN'T THIS WORK?\n\t//else if( i == ID_BOWL ) return shadeDry(p,d,n,texGround(p,stoneTex),sdw,1.0);\n    else if( i == ID_GRND ) return clamp(texGround(p,stoneTex),0.0,1.0);\n    else return SKY_COLOR_AVG;\n}\n\n/*\n\tShades the pixel, based on what entity it belongs to.\n\tLet's talk about why it's so gnarly.\n\tGLSL compilation seems to flow more freely when not using local vars to store the\n\tcomponents of vectors, so I reference the parameter vectors everywhere.\n    Also, calling functions here rather than down below the decks of these if statements\n\tseems to help out compilation as well. Hence calls to fakeCaustics(), shadow(),\n\tocclusion(), and the texture functions all happen here. Their results are either\n\tpassed down as parameters, or are interjected into the affairs of other variables.\n\t(such as cst).\n\n*/\nvec3 shade( in vec4 pri, in vec4 nrm, in vec4 rfl, in vec4 rfr, in vec3 e )\n{\n    float a = 0.0;\n    float sdw = shadow(pri.xyz,SUN_DIR);\n    float amb = occlusion(pri.xyz,nrm.xyz);\n    float cst = fakeCaustics(pri.xyz);\n    vec3 d = normalize(pri.xyz-e);\n    vec3 stoneTex = texStone(pri.xyz);\n    vec3 shade_rfl = vec3(0), shade_rfr = vec3(0);\n    if( pri.w == ID_WATER )\n    {\n        // Do we present the refraction, or reflection? The angle of incidence holds the key.\n        // (except actually the cosine between the normal and incident vector.)\n        shade_rfl = shadeRflRfr( rfl.xyz, normalize(rfl.xyz-pri.xyz), norm(rfl.xyz), stoneTex, cst, rfl.w );\n        shade_rfr = shadeRflRfr( rfr.xyz, normalize(rfr.xyz-pri.xyz), norm(rfr.xyz), stoneTex, cst, rfr.w );\n        a = dot(-d,nrm.xyz);\n        return mix(shade_rfl,shade_rfr,clamp(a,0.0,1.0));\n    }\n    else if( pri.w == ID_BASIN )\n    {\n        if( length(pri.xz) < 2.8 ) return shadeWet(pri.xyz,d,nrm.xyz,texBasin(pri.xyz)*(1.+cst),sdw,amb);\n        else return shadeDry(pri.xyz,d,nrm.xyz,stoneTex,sdw,amb);\n    }\n    else if( pri.w == ID_BTRIM ) return shadeDry(pri.xyz,d,nrm.xyz,stoneTex,sdw,amb);\n    else if( pri.w == ID_TOWER ) return shadeDry(pri.xyz,d,nrm.xyz,stoneTex,sdw,amb);\n    else if( pri.w == ID_BOWL ) return shadeDry(pri.xyz,d,nrm.xyz,stoneTex*(1.+cst),sdw,amb);\n    else if( pri.w == ID_GRND ) return shadeDry(pri.xyz,d,nrm.xyz,texGround(pri.xyz,stoneTex),sdw,amb);\n    else return shadeDry(pri.xyz,d,nrm.xyz,stoneTex,sdw,amb);\n    \n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( vec2 uv, vec3 c )\n{\n    \n    float vig = 1.0-dot(uv,uv)*.333;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized texture coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    // Load the results of all the other buffers.\n    vec4 pri = texture(PRI_TEX,uv);\n    vec4 nrm = texture(NRM_TEX,uv);\n    vec4 rfl = texture(RFL_TEX,uv);\n    vec4 rfr = texture(RFR_TEX,uv);\n    //fragColor = nrm;return;\n    \n    // If there's no geometry, we get the sky color from where we left it,\n    // in the reflection position buffer. (Buffer C).\n    if( pri.w == ID_NONE )\n    {\n        fragColor = rfl;\n        return;\n    }\n    \n    float m = mix(.5, iMouse.y/iResolution.y, step(.5,iMouse.y)); // The ol' thumbnail hack.\n    \n    // The eye position is the camera position from the marchin' buffers. (A and B).\n    vec3 e = vec3(7.0*cos(iTime*.5), 1.0 + 8.0*m, 7.0*sin(iTime*.5));\n    \n    // Eh, I don't feel like typecasting to a vec4. It's late; I'm tired.\n    fragColor = shade(pri,nrm,rfl,rfr,e).rgbb;\n    fragColor = postProcess( uv,fragColor.rgb ).rgbb;\n    fragColor = mix(fragColor,rfl,smoothstep(.9,.95,length(e-pri.xyz)/MAX_DEPTH));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tIn this buffer we march to find the position of the model, storing it.\n\tIn cases where we don't hit anything, we store the ray's direction.\n\tWhy? Because without a point to compare with the eye position, we cannot\n\tdetermine ray direction. So if we save the ray direction in that case,\n\twe've covered our rear.\n*/\n\n// Main marching steps. This needs to be high, as this buffer's results are felt\n// far and wide.\n#define V_STEPS 150\n// Maximum successful marching distance.\n#define EPSILON .007\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// Entity IDs.\n#define ID_NONE  0.0\n#define ID_WATER 1.0\n#define ID_BASIN 2.0\n#define ID_BTRIM 3.0\n#define ID_TOWER 4.0\n#define ID_BOWL  5.0\n#define ID_GRND  6.0\n\n// Channel definitions.\n#define WN_TEX iChannel0\n#define GEOM_TEX iChannel1\n#define SN_TEX iChannel2\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t// An up vector.\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera( in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd )\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tGenerates the bumpmap for the water.\n*/\nfloat waterNoise( in vec2 p )\n{\n        float r = sin((length(p)*40.0)-iTime*20.0)*.0003;\n        r += cos((length(p)*25.0)+iTime*20.0)*.0003;\n        r += texture(WN_TEX,p+iTime*.25).r*.00125;\n        return r + texture(WN_TEX,(p*2.0)-iTime*.125).r*.0025;\n}\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tI think we all know where this came from.\n*/\nfloat cyl( vec3 p, vec2 h ) // h = <r,h>\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tYeah! The rounding was my doing! That r parameter details\n\thow rounded the bases of the cylinder is. Note though, that\n\tit also increases radius.\n*/\nfloat roundCyl( vec3 p, vec2 h, in float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ( min(max(d.x,d.y),0.0) + length(max(d,0.0)) ) - r;\n}\n\n/*\n\tAnother IQ distance function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tIt's nice to have a catalog of primitives, isn't it guys?\n*/\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\n/*\n\tThe non-ridged basin trim. The ridges are added elsewhere.\n*/\nfloat basinTrimSmooth( vec3 p )\n{\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.05,.35));\n    float hollowing = cyl(p,vec2(2.70,.8));\n    float cutout = cyl(p,vec2(4.0,.3));\n    float r = max( exterior,\n               -hollowing);\n    return max(r,-cutout);\n    \n}\n\nvec3 basinTrimNorm( in vec3 p )\n{\n\treturn normalize(vec3(basinTrimSmooth(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  basinTrimSmooth(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  basinTrimSmooth(vec3(p.x,p.y,p.z+EPSILON)))-basinTrimSmooth(p));\n}\n\nfloat basinTrim( vec3 p )\n{\n    float d = basinTrimSmooth(p), bump = 0.0;\n    if( d < .02)\n    {\n        bump = sin(mod(atan(p.z/p.x)*10.0,3.14));\n        bump = 1.0 - smoothstep(.9995,1.00, clamp(bump,.9995,1.00));\n    }\n    return d - bump*.02;\n    \n}\n\nfloat basinSmooth( vec3 p )\n{\n    p.y -= .35;\n    float d = length(p.xz)-3.5, ripples = 0.0;\n    \n    if( d < .02 )\n    {\n        ripples = (sin(atan(p.z/p.x)*60.0));\n        ripples *= ripples;\n        ripples *= .02;\n    }\n    \n    float exterior = cyl(p,vec2(3.0-ripples,.35));\n    p.y -= .1;\n    float cutout = cyl(p,vec2(2.75,.35));\n    float r = max( exterior,\n                  -cutout);\n    \n    return r;\n}\n\nvec3 basinNorm( in vec3 p )\n{\n\treturn normalize(vec3(basinSmooth(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  basinSmooth(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  basinSmooth(vec3(p.x,p.y,p.z+EPSILON)))-basinSmooth(p));\n}\n\n/*\n\tGenerates the bump map for the tiles.\n\tThe second parameter determines how sharp and narrow the gaps between\n\ttiles are.\n*/\nfloat tileBump( in vec2 p, in float s )\n{\n    p *= 10.0;\n    vec2 f = fract(p)-.5;\n    f*=2.0;\n    f = abs(f);\n    return smoothstep(s,1.0,clamp(max(f.x,f.y),s,1.0));\n}\n\nfloat basin( in vec3 p )\n{\n    float d = basinSmooth(p), pol = 0.0, bump = 0.0;\n    vec3 n = vec3(0);\n    if( d < .01 )\n    {\n        n = basinNorm(p);\n        pol = mod(atan(p.z/p.x)*3.14, 3.14)-1.57;\n        bump = tileBump(p.xz,.8)*abs(n.y)+\n                     tileBump(vec2(pol,p.y),.8)*(1.0-abs(n.y));\n        bump *= step(length(p.xz),2.75);\n    }\n    return d + bump*.005;\n    \n}\n\nfloat bowl( in vec3 p )\n{\n    vec3 q = p;\n    p.y -= 2.90;\n    p.y *= 1.75;\n    q.y -= 3.00;\n    q.y *= 1.75;\n    return max(length(p)-.50,-length(q)+.50);\n}\n\nfloat tower( vec3 p )\n{\n    p.y -= .65; // Translate.\n    \n    // Test to see if we are within a distance that need worry\n    // about surface displacement.\n    float d = length(p.xz)-.150, n = 0.0, r = .125;\n    \n\tif( d < .2 )\n    {\n        // Modulate the radius based on height.\n        n = sin(p.y*8.0+sin(p.y*10.0));\n        r += (n*n*.0625);\n    \n        // Give it some ripples.\n        r -= abs(sin(atan(p.z/p.x)*10.0))*.005;\n    }\n    \n    // Combine the bowl and the tower.\n \treturn capsule(p,vec3(0,-1,0),vec3(0,3,0),r);\n}\n\nfloat ground( in vec3 p )\n{\n    float b = 0.0;\n    if( p.y < .02 )\n    {\n        b = tileBump(p.xz*.25,.975);\n        b *= b*b;\n        #ifdef HIGH_QUALITY\n        b += fbm(p*20.0)*.5;\n        #endif\n        return p.y + b*.02;\n    }\n    else return p.y;\n}\n\n/*\n\tThis sub-field represents some polar-coordinated blocks\n    that swing around the tower through the cylinder that\n\tmakes up the water, cutting chunks out. This gives the water\n\tthe appearance of cohesive behavior.\n*/\nfloat waterCohesor( in vec3 p )\n{\n    // Convert to polar coordinates.\n    p = vec3(length(p.xz),p.y,atan(p.x/p.z));\n    // Move the cutting blocks out to the radius of the falling water.\n    p.x -= .7;\n    // Create a coordinate for a second pair of cutters.\n    vec3 q = p;\n    // MAKE SOME NOIIISSSEEE!\n    #define t iTime\n    q.z = mod(q.z, 3.14)-1.57;\n    float n1 = sin(t+cos(t*2.0+sin(t*3.0)));\n    float n2 = sin(t+cos(t*2.5+cos(t*4.1)));\n    #undef t\n    // USE THE NOISE\n    p.z += n1;\n    q.z -= n2;\n    // Create a factor by which to modify the width of the block\n    // based on height.\n    float cohesion = pow(p.y*.33333,2.0);\n\t\n    // Gotta make sure we're within the eh, range.\n    p.z = mod(p.z, 3.14)-1.57;\n    q.z = mod(q.z, 3.14)-1.57;\n    // Finally we return the union of the two blocks.\n    return min( box(p,vec3(.2,2.95,.25-cohesion*.5+n2*.25)),\n                box(q,vec3(.2,2.95,.25-cohesion*.5+n1*.25)));\n}\n\nfloat fallingWater( in vec3 p )\n{\n    float y = p.y; // Store the actual Y position for the speed.\n    p.y -= 1.400;\n    float water = max( roundCyl(p,vec2(.475, 1.475),0.1),\n                      -roundCyl(p,vec2(.475, 1.475),0.05));\n    if( water < .005 )\n    {\n        float wSpeed = 2.875-p.y;\n        water += waterNoise(p.xz)+\n                 waterNoise(vec2(atan(p.z/p.x),p.y+iTime*2.0))*3.0;\n    }\n    return max(water,-waterCohesor(p));\n}\n\nfloat basinWater( in vec3 p )\n{\n    p.y -= .3;\n    float d = cyl(p,vec2(2.75,.05));\n    if( d < .01 )\n    {\n        return d + waterNoise(p.xz)*8.0;\n    }\n    else return d;\n}\n\nfloat dist( in vec3 p )\n{\n    float w = smin(basinWater(p),fallingWater(p),.125);\n    float r = min(basin(p),basinTrim(p));\n    r = min(r,tower(p));\n    r = min(r,bowl(p));\n    r = min(r,ground(p));\n    return min(r,w);\n}\n\nfloat id( in vec3 p )\n{\n    if(dist(p) > EPSILON*5.0) return ID_NONE;\n\tvec2 closest = u(vec2(tower(p), ID_TOWER), \n\t\t\t\t\t vec2(basin(p),ID_BASIN));\n\t\t closest = u(closest, vec2(basinTrim(p), ID_BTRIM));\n\t\t closest = u(closest, vec2(bowl(p), ID_BOWL));\n\t\t closest = u(closest, vec2(basinWater(p), ID_WATER));\n    \t closest = u(closest, vec2(ground(p), ID_GRND));\n    \t return u(closest, vec2(fallingWater(p), ID_WATER)).t;\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tPrimary march function.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r*.5;\n        r = dist(p);\n\t}\n\treturn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Camera position and direction.\n    float m = mix(.5, iMouse.y/iResolution.y, step(.5,iMouse.y)); // The ol' thumbnail hack.\n    \n    vec3 cp = vec3(7.0*cos(iTime*.5), 1.0 + 8.0*m, 7.0*sin(iTime*.5));\n    vec3 cd = normalize(vec3(0,1,0)-cp);\n    vec3 up = -cross(cd,cross(cd,UP)); // Nesting cross calls makes me feel kinda cool.\n    \n    // Set up the camera.\n    camera(uv, cp, cd, up, 1.0, p, d);\n    \n\t// Store the eye position.\n    e = vec3(p);\n    \n    // Do the actual ray marching.\n    march(p,d,e);\n    \n    // Store the final pixel color.\n    // If the id is less than 1, that means it's\n    // ID_NONE, and there is no positional data there to have.\n    // Instead we store the sky color to offload the operation\n    // from the other shaders.\n    float i = id(p);\n    fragColor = vec4(mix(d,p,step(.1,i)),i);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\tThis shader has to re-march everything to determine the surface normals of the scene.\n\tI tried extracting them from the position buffer, but slight imprecision (I guess in the\n\ttexture format?) gave me some narsty discontinuities. MRT would be incredible right now.\n\n\tThis buffer, and buffer A as well, use the full scene's distance functions, however, here\n\twe often march slightly more detailed versions (an fbm here and there). This allows\n\tfor variations in normals and subtle bumpmapping effects, without unpleasant 1 pixel shadows.\n\t(It also speeds things up in buffer A.)\n\n\tDon't forget to try out HIGH_QUALITY mode!\n*/\n\n//#define HIGH_QUALITY\n\n// Main marching steps.\n#define V_STEPS 150\n// Maximum successful marching distance.\n#define EPSILON .005\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// Entity IDs.\n#define ID_NONE  0.0\n#define ID_WATER 1.0\n#define ID_BASIN 2.0\n#define ID_BTRIM 3.0\n#define ID_TOWER 4.0\n#define ID_BOWL  5.0\n#define ID_GRND  6.0\n\n// Channel definitions\n#define PRI_TEX iChannel0\n#define WN_TEX iChannel1\n#define GEOM_TEX iChannel2\n#define SN_TEX iChannel3\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t// An up vector. For the camera.\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera( in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd )\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tProvides a coefficient by which to modulate the height of the water.\n*/\nfloat waterNoise( in vec2 p )\n{\n        float r = sin((length(p)*40.0)-iTime*20.0)*.0003;\n        r += cos((length(p)*25.0)+iTime*20.0)*.0003;\n        r += texture(WN_TEX,p+iTime*.25).r*.00125;\n        return r + texture(WN_TEX,(p*2.0)-iTime*.125).r*.0025;\n}\n\n/*\n\tWe have an extra channel available here, so we can use the\n\ttexture-lookup version of IQ's noise!\n*/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( SN_TEX, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tAn FBM of such noise.\n*/\nfloat fbm( in vec3 p )\n{\n    float r = noise(p)*.500;\n    r += noise(p*2.0)*.250;\n    r += noise(p*4.0)*.125;\n    return r *1.1429;\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/*\n\tI think we all know where this came from.\n*/\nfloat cyl( vec3 p, vec2 h ) // h = <r,h>\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tAnother IQ distance function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tIt's nice to have a catalog of primitives, isn't it guys?\n*/\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\n/*\n\tYeah! The rounding was my doing! That r parameter details\n\thow rounded the bases of the cylinder is. Note though, that\n\tit also increases radius.\n*/\nfloat roundCyl( vec3 p, vec2 h, in float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ( min(max(d.x,d.y),0.0) + length(max(d,0.0)) ) - r;\n}\n\n/*\n\tHere's the standard basin trim depth function. We take this,\n\tand decorate it into a bumped map version below.\n*/\nfloat basinTrimSmooth( vec3 p )\n{\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.05,.35));\n    float hollowing = cyl(p,vec2(2.70,.8));\n    float cutout = cyl(p,vec2(4.0,.3));\n    float r = max( exterior,\n               -hollowing);\n    return max(r,-cutout);\n    \n}\n\n/*\n\tThe bumpmapped basin trim.\n*/\nfloat basinTrim( vec3 p )\n{\n    // If we're far enough away, we don't have to worry about\n    // going into so much detail as to consider the bump map.\n    float d = basinTrimSmooth(p), bump = 0.0;\n    if( d < .1)\n    {\n        bump = sin(mod(atan(p.z/p.x)*10.0,3.14));\n        bump = 1.0 - smoothstep(.9995,1.00, clamp(bump,.9995,1.00));\n        #ifdef HIGH_QUALITY\n        bump += fbm(p*50.0)*.25;\n        #endif\n        bump *= .02;\n    }\n    return d-bump;\n    \n}\n\n/*\n\tLike with the basin trim, we start with a \"smooth\" distance function\n\tthat we wrap up in bumpmap gift wrap later.\n*/\nfloat basinSmooth( vec3 p )\n{\n    p.y -= .35;\n    float d = length(p.xz)-3.5, ripples = 0.0;\n    \n    if( d < .02 )\n    {\n        ripples = (sin(atan(p.z/p.x)*60.0));\n        ripples *= ripples;\n        #ifdef HIGH_QUALITY\n        ripples += fbm(p*50.0)*.125;\n        #endif\n        ripples *= .02;\n    }\n    \n    float exterior = cyl(p,vec2(3.0-ripples,.35));\n    p.y -= .1;\n    float cutout = cyl(p,vec2(2.75,.35));\n    float r = max( exterior,\n                  -cutout);\n    \n    return r;\n}\n\n/*\n\tGenerates the bump map for the tiles.\n\tThe second parameter determines how sharp and narrow the gaps between\n\ttiles are.\n*/\nfloat tileBump( in vec2 p, in float s )\n{\n    p *= 10.0;\n    vec2 f = fract(p)-.5;\n    f*=2.0;\n    f = abs(f);\n    return smoothstep(s,1.0,clamp(max(f.x,f.y),s,1.0));\n}\n\n/*\n\tThe distance function for the basin.\n*/\nfloat basin( in vec3 p )\n{\n    float d = basinSmooth(p), pol = 0.0, bump = 0.0;\n    vec3 n = vec3(0);\n    if( d < .01 )\n    {\n        pol = mod(atan(p.z/p.x)*3.14, 3.14)-1.57;\n        // Since we will always hit water before we hit the bottom of\n       \t// the basin, we can just assume that we will always find the\n        // inner wall of the basin.\n        bump = tileBump(vec2(pol,p.y),.8);\n        bump *= step(length(p.xz),2.75);\n    }\n    return d + bump*.005;\n    \n}\n\n/*\n\tThe bowl. Two balls. Cutting each other up.\n*/\nfloat bowl( in vec3 p )\n{\n    vec3 q = p;\n    p.y -= 2.90;\n    p.y *= 1.75;\n    q.y -= 3.00;\n    q.y *= 1.75;\n    return max(length(p)-.50,-length(q)+.50);\n}\n\n/*\n\tThe tower is a cylinder, who has his radius mingled with.\n*/\nfloat tower( vec3 p )\n{\n    p.y -= .65; // Translate so the bottom sits on y=0.\n    \n    // Test to see if we are within a distance that need worry\n    // about surface displacement.\n    float d = length(p.xz)-.150, n = 0.0, r = .125;\n    \n    // Do some complexity cullin'. We don't need to worry about\n    // those fancy scallops if we aren't near then yet.\n\tif( d < .2 )\n    {\n        // Modulate the radius based on height.\n        n = sin(p.y*8.0+sin(p.y*10.0));\n        r += (n*n*.0625);\n    \n        // Give it some ripples.\n        r -= abs(sin(atan(p.z/p.x)*10.0))*.005;\n    }\n    \n    // Combine the bowl and the tower.\n \treturn capsule(p,vec3(0,-1,0),vec3(0,3,0),r);\n}\n\n/*\n\tThe ground sub-field in this buffer is special. Depending on if HIGH_QUALITY\n\tis defined, we add in some deviations to the distance function used,\n\tso the ground has a bit more meat on its bones.\n\tOtherwise it's pretty much a scaled version of the inside of the basin.\n*/\nfloat ground( in vec3 p )\n{\n    float b = 0.0;\n    #ifdef HIGH_QUALITY\n    if( p.y < .08 )\n    {\n        b = tileBump(p.xz*.25,.975);\n        b *= b*b;\n        // This floor() coincides with the one in tileBump(), and gives\n       \t// each tile a distinct bump map that's not continuous between\n        // tiles. That discontinuity makes it look so much better.\n        b += fbm( p*20.0 + floor(p*2.5)*10.0 )*.5;\n        return p.y + b*.02;\n    }\n    #else\n    if( p.y < .02 )\n    {\n        b = tileBump(p.xz*.25,.975);\n        b *= b*b;\n        return p.y + b*.02;\n    }\n    #endif\n    else return p.y;\n}\n\n/*\n\tThis sub-field represents some polar-coordinated blocks\n    that swing around the tower through the cylinder that\n\tmakes up the water, cutting chunks out. This gives the water\n\tthe appearance of cohesive behavior.\n*/\nfloat waterCohesor( in vec3 p )\n{\n    // Convert to polar coordinates.\n    p = vec3(length(p.xz),p.y,atan(p.x/p.z));\n    // Move the cutting blocks out to the radius of the falling water.\n    p.x -= .7;\n    // Create a coordinate for a second pair of cutters.\n    vec3 q = p;\n    // MAKE SOME NOIIISSSEEE!\n    #define t iTime\n    q.z = mod(q.z, 3.14)-1.57;\n    float n1 = sin(t+cos(t*2.0+sin(t*3.0)));\n    float n2 = sin(t+cos(t*2.5+cos(t*4.1)));\n    #undef t\n    // USE THE NOISE\n    p.z += n1;\n    q.z -= n2;\n    // Create a factor by which to modify the width of the block\n    // based on height.\n    float cohesion = pow(p.y*.33333,2.0);\n\t\n    // Gotta make sure we're within the eh, range.\n    p.z = mod(p.z, 3.14)-1.57;\n    q.z = mod(q.z, 3.14)-1.57;\n    // Finally we return the union of the two blocks.\n    return min( box(p,vec3(.2,2.95,.25-cohesion*.5+n2*.25)),\n                box(q,vec3(.2,2.95,.25-cohesion*.5+n1*.25)));\n}\n\n/*\n\tCreates the afore mentioned column of water, and then as prophecised\n\tchomps out bits using waterCohesor(). It also does some bumpmapping.\n*/\nfloat fallingWater( in vec3 p )\n{\n    float y = p.y; // Store the actual Y position for the speed.\n    p.y -= 1.400;\n    float water = max( roundCyl(p,vec2(.475, 1.475),0.1),\n                      -roundCyl(p,vec2(.475, 1.475),0.08));\n    if( water < .005 )\n    {\n        float wSpeed = 2.875-p.y;\n        water += waterNoise(p.xz)+\n                 waterNoise(vec2(atan(p.z/p.x),p.y+iTime*2.0))*3.0;\n    }\n    return max(water,-waterCohesor(p));\n}\n\nfloat basinWater( in vec3 p )\n{\n    p.y -= .3;\n    float d = cyl(p,vec2(2.75,.05));\n    if( d < .01 )\n    {\n        return d + waterNoise(p.xz)*8.0;\n    }\n    else return d;\n}\n\nfloat dist( in vec3 p )\n{\n    float w = smin(basinWater(p),fallingWater(p),.125);\n    float r = min(basin(p),basinTrim(p));\n    r = min(r,tower(p));\n    r = min(r,bowl(p));\n    r = min(r,ground(p));\n    return min(r,w);\n}\n\nfloat id( in vec3 p )\n{\n    if(dist(p) > EPSILON*5.0) return ID_NONE;\n\tvec2 closest = u(vec2(tower(p), ID_TOWER), \n\t\t\t\t\t vec2(basin(p),ID_BASIN));\n\t\t closest = u(closest, vec2(basinTrim(p), ID_BTRIM));\n\t\t closest = u(closest, vec2(bowl(p), ID_BOWL));\n\t\t closest = u(closest, vec2(basinWater(p), ID_WATER));\n    \t closest = u(closest, vec2(ground(p), ID_GRND));\n    \t return u(closest, vec2(fallingWater(p), ID_WATER)).t;\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tPrimary march function.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif( r < EPSILON || length(p-e) > MAX_DEPTH )\n\t\t\treturn;\n\t\tp += d*r*.5;\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tThe ol' entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if( texture(PRI_TEX,uv).w == ID_NONE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Camera position and direction.\n    float m = mix(.5, iMouse.y/iResolution.y, step(.5,iMouse.y)); // The ol' thumbnail hack.\n    \n    vec3 cp = vec3(7.0*cos(iTime*.5), 1.0 + 8.0*m, 7.0*sin(iTime*.5));\n    vec3 cd = normalize(vec3(0,1,0)-cp);\n    vec3 up = -cross(cd,cross(cd,UP)); // Nesting cross calls makes me feel kinda cool.\n    \n    // Set up the camera.\n    camera(uv, cp, cd, up, 1.0, p, d);\n    \n\t// Store the eye position.\n    e = vec3(p);\n    \n    // Do the actual ray marching.\n    march(p,d,e);\n    \n    // Store the final pixel color.\n    fragColor = vec4(norm(p),id(p));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\tThis buffer has two responsibilities. The first is marching reflected rays\n\tfrom the points stored in buffer A and the normals in buffer B.\n\tBut that's only if the surface is reflective (more specifically, water),\n\totherwise it stores the sky color, so that later on we may have a sky\n\tbox without burdening the Image shader any more than it has to be.\n*/\n\n// Main marching steps.\n#define V_STEPS 60\n// Maximum successful marching distance.\n#define EPSILON .0005\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// Entity IDs.\n#define ID_NONE  0.0\n#define ID_WATER 1.0\n#define ID_BASIN 2.0\n#define ID_BTRIM 3.0\n#define ID_TOWER 4.0\n#define ID_BOWL  5.0\n#define ID_GRND  6.0\n\n// Channel definitions.\n#define SCENE_TEX iChannel0\n#define NORM_TEX iChannel1\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t// Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t// High angle sky.\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera( in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd )\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tI think we all know where this came from.\n*/\nfloat cyl( vec3 p, vec2 h ) // h = <r,h>\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tAnother IQ distance function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tIt's nice to have a catalog of primitives, isn't it guys?\n*/\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\n/*\n\tThe trim around the basin. It's simplified from\n\tthe primary two and final passes.\n*/\nfloat basinTrim( vec3 p )\n{\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.05,.35));\n    float hollowing = cyl(p,vec2(2.70,.4));\n    float cutout = cyl(p,vec2(4.0,.3));\n    float r = max( exterior,\n               -hollowing);\n    return max(r,-cutout);\n    \n}\n\n/*\n\tA refracted ray will also never see the ripples on the outside of\n\tthe basin. We don't need to worry about crap in this pass!\n*/\nfloat basin( vec3 p )\n{\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.0,.35));\n    p.y -= .1;\n    float cutout = cyl(p,vec2(2.75,.35));\n    float r = max( exterior,\n                  -cutout);\n    \n    return r;\n}\n\n/*\n\tThe bowl is the usual bowl.\n*/\nfloat bowl( in vec3 p )\n{\n    vec3 q = p;\n    p.y -= 2.90;\n    p.y *= 1.75;\n    q.y -= 3.00;\n    q.y *= 1.75;\n    return max(length(p)-.50,-length(q)+.50);\n}\n\n/*\n\tOh wait, we do need to maintain the surface features of the\n\tcolumn/tower/thing that holds the bowl up.\n*/\nfloat tower( vec3 p )\n{\n    p.y -= .65; // Translate.\n    \n    // Test to see if we are within a distance that need worry\n    // about surface displacement.\n    float d = length(p.xz)-.150, n = 0.0, r = .125;\n    \n\tif( d < .2 )\n    {\n        // Modulate the radius based on height.\n        n = sin(p.y*8.0+sin(p.y*10.0));\n        r += (n*n*.0625);\n    \n        // Give it some ripples.\n        r -= abs(sin(atan(p.z/p.x)*10.0))*.005;\n    }\n    \n    // Combine the bowl and the tower.\n \treturn capsule(p,vec3(0,-1,0),vec3(0,3,0),r);\n}\n\n/*\n\tThis is the simplest distance function.\n*/\nfloat ground( in vec3 p )\n{\n    return p.y;\n}\n\n/*\n\tThis distance function only cares about what can be reflected.\n*/\nfloat dist( in vec3 p )\n{\n    float r = min(basin(p),basinTrim(p));\n    r = min(r,tower(p));\n    r = min(r,ground(p));\n    return min(r,bowl(p));\n}\n\n/*\n\tThis also only takes into account things refraction can see.\n*/\nfloat id( in vec3 p )\n{\n    vec2 closest = u(vec2(EPSILON*5.0, ID_NONE),\n        \t\t\t vec2(tower(p), ID_TOWER));\n\tclosest = u(closest,vec2(basin(p),ID_BASIN));\n    closest = u(closest,vec2(ground(p),ID_GRND));\n    return u(closest, vec2(bowl(p), ID_BOWL)).t;\n}\n\n/*\n\tReflection and post-water march function.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif( r < EPSILON || length(p-e) > MAX_DEPTH )\n\t\t\treturn;\n        // Since we are using noise that doesn't preserve the nearest distance\n        // property, we have attenuate our step size.\n\t\tp += d*r*.75;\n        r = dist(p);\n\t}\n\treturn;\n}\n\nvec3 sky( vec3 d )\n{\n    vec3 flatD = normalize(vec3(d.x,0.0,d.z));\n    return mix(SKY_COLOR_B, SKY_COLOR_A, clamp(dot(flatD,d),0.0,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get normalized UV coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    // Load the base scene data.\n    vec4 scene = texture(SCENE_TEX,uv);\n    \n    // Use the camera position from the principle pass\n    // as the eye position in other passes.\n    float m = mix(.5, iMouse.y/iResolution.y, step(.5,iMouse.y)); // The ol' thumbnail hack.\n    \n    vec3 e = vec3(7.0*cos(iTime*.5), 1.0 + 8.0*m, 7.0*sin(iTime*.5));\n    \n    // Extract the position.\n    vec3 p = scene.xyz;\n    \n    // Get the ray direction.\n    vec3 d = normalize(p-e);\n    \n    // The ID allows us to shortcut if we aren't reflective.\n    // Since this buffer only cares about water, we store the sky color\n    // through any pixel that doesn't represent water.\n    // This will allow us to gently fade from geometry to sky at distance\n    // in the final shader.\n    float i = scene.w;\n    if( i != ID_WATER )\n    {\n        // So in the position buffer, if we had an ID_NONE,\n        // we stored the direction since it would be impossible\n        // to extract otherwise. We have to make use of that\n        // foresight here.\n        fragColor = vec3(mix(sky(p),sky(d),step(.1,i))).rgbb;\n        return;\n    }\n    \n    // Extract the surface normal from the scene data.\n    vec3 n = texture(NORM_TEX,uv).xyz;\n    \n    // This is the reflection pass, so we need to march the reflection.\n    march(p,reflect(d,n),e);\n    \n    // Store the final pixel color.\n    fragColor = vec4(p,id(p));\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\n\tThis buffer only cares about the water fields. In such a case it takes the\n\tposition from buffer A and surface normal from buffer B and marches a refracted\n\tray past the water to see what's up.\n\n\tSince this is seperated out, we don't need the subfields that represent the water,\n\twhich simplifies things a teensy wee bit. Also, since we're storing a refraction\n\timage, the geometry can be simplified even further. \n*/\n\n// Main marching steps.\n#define V_STEPS 100\n// Maximum successful marching distance.\n#define EPSILON .0005\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// Entity IDs.\n#define ID_NONE  0.0\n#define ID_WATER 1.0\n#define ID_BASIN 2.0\n#define ID_BTRIM 3.0\n#define ID_TOWER 4.0\n#define ID_BOWL  5.0\n#define ID_GRND  6.0\n\n// Channel definitions.\n#define SCENE_TEX iChannel0\n#define NORM_TEX iChannel1\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera( in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd )\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tI think we all know where this came from.\n*/\nfloat cyl( vec3 p, vec2 h ) // h = <r,h>\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tAnother IQ distance function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tIt's nice to have a catalog of primitives, isn't it guys?\n*/\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\n/*\n\tThe trim around the basin. It's simplified from\n\tthe primary two and final passes.\n*/\nfloat basinTrim( vec3 p )\n{\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.05,.35));\n    float hollowing = cyl(p,vec2(2.70,.4));\n    float cutout = cyl(p,vec2(4.0,.3));\n    float r = max( exterior,\n               -hollowing);\n    return max(r,-cutout);\n    \n}\n\n/*\n\tA refracted ray will also never see the ripples on the outside of\n\tthe basin. We don't need to worry about crap in this pass!\n*/\nfloat basin( vec3 p )\n{\n    p.y -= .35;\n    float exterior = cyl(p,vec2(3.0,.35));\n    p.y -= .1;\n    float cutout = cyl(p,vec2(2.75,.35));\n    float r = max( exterior,\n                  -cutout);\n    \n    return r;\n}\n\n/*\n\tThe bowl is the usual bowl.\n*/\nfloat bowl( in vec3 p )\n{\n    vec3 q = p;\n    p.y -= 2.90;\n    p.y *= 1.75;\n    q.y -= 3.00;\n    q.y *= 1.75;\n    return max(length(p)-.50,-length(q)+.50);\n}\n\n/*\n\tOh wait, we do need to maintain the surface features of the\n\tcolumn/tower/thing that holds the bowl up.\n*/\nfloat tower( vec3 p )\n{\n    p.y -= .65; // Translate.\n    \n    // Test to see if we are within a distance that need worry\n    // about surface displacement.\n    float d = length(p.xz)-.150, n = 0.0, r = .125;\n    \n\tif( d < .2 )\n    {\n        // Modulate the radius based on height.\n        n = sin(p.y*8.0+sin(p.y*10.0));\n        r += (n*n*.0625);\n    \n        // Give it some ripples.\n        r -= abs(sin(atan(p.z/p.x)*10.0))*.005;\n    }\n    \n    // Combine the bowl and the tower.\n \treturn capsule(p,vec3(0,-1,0),vec3(0,3,0),r);\n}\n\n/*\n\tThis is still the simplest distance function.\n*/\nfloat ground( in vec3 p )\n{\n    return p.y;\n}\n\n/*\n\tThis distance function only takes into account the things\n\ta refracted ray can possibly run into.\n*/\nfloat dist( in vec3 p )\n{\n    float r = min(basin(p),basinTrim(p));\n    r = min(r,tower(p));\n    r = min(r,ground(p));\n    return min(r,bowl(p));\n}\n\n/*\n\tThis also only takes into account things refraction can see.\n*/\nfloat id( in vec3 p )\n{\n    vec2 closest = u(vec2(EPSILON*5.0, ID_NONE),\n        \t\t\t vec2(tower(p), ID_TOWER));\n\tclosest = u(closest,vec2(basin(p),ID_BASIN));\n    closest = u(closest,vec2(ground(p),ID_GRND));\n    return u(closest, vec2(bowl(p), ID_BOWL)).t;\n}\n\n/*\n\tReflection and post-water march function.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n        // Since we are using noise that doesn't preserve the nearest distance\n        // property, we have attenuate our step size.\n\t\tp += d*r*.75;\n        r = dist(p);\n\t}\n\treturn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get normalized UV coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    // Load the base scene data.\n    vec4 scene = texture(SCENE_TEX,uv);\n    \n    // The ID allows us to shortcut if we aren't reflective.\n    float i = scene.w;\n    if( i != ID_WATER )\n    {\n        fragColor = vec4(0,0,0,ID_NONE);\n        return;\n    }\n    \n    // Use the camera position from the principle pass\n    // as the eye position in other passes.\n    float m = mix(.5, iMouse.y/iResolution.y, step(.5,iMouse.y)); // The ol' thumbnail hack.\n    \n    vec3 e = vec3(7.0*cos(iTime*.5), 1.0 + 8.0*m, 7.0*sin(iTime*.5));\n    \n    // Extract the position.\n    vec3 p = scene.xyz;\n    \n    // Get the ray direction.\n    vec3 d = normalize(p-e);\n    \n    // Extract the surface normal from the scene data.\n    vec3 n = texture(NORM_TEX,uv).xyz;\n    \n    // This is the reflection pass, so we need to do the reflection.\n    vec3 refl = refract(d,n,.85);\n    // Do the actual ray marching.\n    march(p,refl,e);\n    \n    // Store the final pixel color.\n    i = id(p);\n    fragColor = vec4(mix(d,p,step(ID_NONE,i)),i);\n}","name":"Buf D","description":"","type":"buffer"}]}