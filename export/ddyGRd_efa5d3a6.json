{"ver":"0.1","info":{"id":"ddyGRd","date":"1679087794","viewed":104,"name":"Soddy circles - infinite zoom","username":"DjinnKahn","description":"Soddy circles\n\nIf your initial 3 circles have radii with a ratio of phi + sqrt(phi) (2.89...) the resulting gasket is a scaled & rotated copy of itself, allowing a \"simple\" infinite zoom.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fractal","zoom","gasket","appollonian","soddy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Circle\n{\n    vec2 p;\n    float r;\n};\n\n// inversions use the unit circle\nCircle invert( Circle c )\n{\n    return Circle( c.p/(dot(c.p,c.p) - c.r*c.r), c.r/(dot(c.p,c.p) - c.r*c.r) );\n}\nvec2 invert( vec2 p )\n{\n    return p/dot(p,p);\n}\n\nvec3 color( float i )\n{\n    return sin( i + vec3(0,2,4) )*.4 + .6;\n}\n\n//aa,bb,cc counterclockwise\nint soddy( vec2 p, inout Circle aa, inout Circle bb, inout Circle cc )\n{\n    // rotate so that a.y == b.y\n    vec2 dif = bb.p - aa.p;\n    mat2 m = mat2( dif.x, -dif.y, dif.y, dif.x ) / length( dif );\n    Circle a = Circle( m * aa.p, aa.r );\n    vec2 d = a.p + vec2( a.r, 0. ); // d = point of inversion (where a, b meet)\n    a.p -= d;\n    Circle b = Circle( m * bb.p - d, bb.r );\n    Circle c = Circle( m * cc.p - d, cc.r );\n    p = m * p - d;\n    \n    Circle invC = invert( Circle( c.p, c.r ) );\n    Circle invE = Circle( invC.p + vec2(0., invC.r*2.), invC.r );\n    Circle e = invert( invE );    \n    Circle ee = Circle( inverse( m ) * ( e.p + d ), e.r );\n    \n    if ( invert(p).y < invC.p.y )\n        return -1; // p is not between aa,bb,cc\n    if ( distance( invert(p), invE.p ) < invE.r )\n        return 0;\n    if ( invert(p).y >= invE.p.y ) cc = ee;\n    else if ( invert(p).x > invC.p.x ) aa = ee;\n    else bb = ee;\n    return 1;\n}\n\nint go( vec2 p, Circle a, Circle b, Circle c )\n{    \n    int ct = 4;\n    \n    while ( ct <= 30 )\n    {\n        int sod = soddy( p, a, b, c );\n        if ( sod == -1 )\n            return -1;\n        if ( sod == 0 )\n            return ct;            \n        ct += sod;\n    }\n    \n    return -1;\n}\n\nvec2 cos_sin( float angle )\n{\n    return vec2( cos( angle ), sin( angle ) );\n}\n\nconst float PHI = .5 + sqrt( 1.25 );\nconst float ITERATION_SCALE = PHI + sqrt( PHI ); // 2.89005...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    float zoom_factor = iTime * 3.;\n    float algo_zoom = floor( zoom_factor );\n    zoom_factor = fract( zoom_factor );\n    \n    p *= pow( 1./ITERATION_SCALE, zoom_factor ) * .4;\n    \n    float start = -algo_zoom;\n    \n    vec2 a = cos_sin( (-algo_zoom + 0.) * 2.2370357592874117 ) * pow( ITERATION_SCALE, 0. );\n    vec2 b = cos_sin( (-algo_zoom + 1.) * 2.2370357592874117 ) * pow( ITERATION_SCALE, 1. );\n    vec2 c = cos_sin( (-algo_zoom + 2.) * 2.2370357592874117 ) * pow( ITERATION_SCALE, 2. );\n    \n    float ra = (distance(b, a) + distance(a, c) - distance(c, b)) / 2.;\n    float rb = (distance(c, b) + distance(b, a) - distance(a, c)) / 2.;\n    float rc = (distance(a, c) + distance(c, b) - distance(b, a)) / 2.;\n    \n    \n    int hit = -4;\n    if ( distance( p, a ) < ra )      hit = 3;\n    else if ( distance( p, b ) < rb ) hit = 2;\n    else if ( distance( p, c ) < rc ) hit = 1;\n    else hit = go( p, Circle( a, ra ), Circle( b, rb ), Circle( c, rc ) );\n    \n    \n    fragColor = vec4(0,0,0,1);\n    if ( hit < 0 )\n        return;\n    fragColor = vec4( color( (float(hit) - start)*0.5 ), 1. );\n}","name":"Image","description":"","type":"image"}]}