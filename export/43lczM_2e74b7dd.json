{"ver":"0.1","info":{"id":"43lczM","date":"1725983899","viewed":40,"name":"My first shader:)","username":"NekoShades","description":"bright,movementy,morphy,disco","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float Time, vec2 Uv)\n{\n    // Dynamic color components influenced by time and UV coordinates\n    vec3 a = vec3(0.5, 0.4, 0.7);     // Base color\n    vec3 b = vec3(0.2, 0.3, 0.8);     // Variation for color shift\n    vec3 c = vec3(1.198, 1.308, 1.000);     // Contrast and depth in the color spectrum\n    vec3 d = vec3(0.4, 0.2, 0.6);     // Introduces motion-based changes\n\n    // Blend the palette colors over time and UV movement\n    return a + b * cos(6.28318 * (c * Time + d * Uv.x * Uv.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 Uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 OriginalUv = Uv;\n    vec3 FinalColor = vec3(0.0);\n    // Introduce movement in the UV coordinates based on time\n    Uv.x += sin(iTime * 1.25) * 0.5;   // Horizontal movement\n    Uv.y += cos(iTime * 0.25) * 3.;  // Vertical movement\n\n    // Iterate to create layering and zoom effect\n    for (float i = 0.0; i < 1.5; i++)\n    {\n        float ZoomFactor = mix(1.0, 5.0, smoothstep(0.0, 1.0, 0.5 * (1.0 + cos(iTime))));\n        float RotationAngle = iTime * radians(360.0) / 8.0;\n        mat2 RotationMatrix = mat2(cos(RotationAngle), -sin(RotationAngle), sin(RotationAngle), cos(RotationAngle));\n        Uv = fract((Uv * ZoomFactor) * RotationMatrix) - 0.5;\n        float Distance = asin(cos(pow(length(Uv),2.))) * exp(-length(OriginalUv));\n        \n        // Updated palette function with movement and UV influence\n        vec3 Color = palette(length(cos(OriginalUv)) + cos(iTime * 0.743), Uv);\n        Distance = sin(Distance * 8.0 + iTime) / 8.0;\n        Distance = abs(Distance);\n        Distance = pow(clamp(asin(cos(iTime)), 0.005, 0.02) / Distance, 1.2);\n        FinalColor += Color * Distance;\n    }\n    \n    fragColor = vec4(FinalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}