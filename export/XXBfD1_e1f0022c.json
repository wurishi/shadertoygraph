{"ver":"0.1","info":{"id":"XXBfD1","date":"1729563936","viewed":93,"name":"VideoTest4","username":"kosalos","description":"video effects development\n\n Cross-eyed 3D\n Slightly cross your eyes so there is a third image in the middle.\n Concentrate only on middle image which is in 3D.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["video"],"hasliked":0,"parentid":"X3SfDh","parentname":"VideoTest3"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI2 = acos(-1.) * 2.;\n\nvoid scaleCell(int index,vec2 uv,float scale, inout vec4 O, vec2 U, bool centered) {\n    float scaledSize = gsize * scale;\n    float dstXsize = 0.9 * scale * iResolution.x/float(gcount); // .9 = fudge to remove image overlap\n    float dstYsize = scale * iResolution.y/float(gcount);\n\n    uv *= iResolution.xy;\n    vec2 dest = vec2(U.x - uv.x,U.y - uv.y);\n    if(centered) dest += vec2(iResolution.xy * scaledSize * 0.5);\n    \n    if(dest.x >= 0. && dest.x < dstXsize && dest.y >= 0. && dest.y < dstYsize) {\n        vec2 src = gcoord(index) * iResolution.xy + dest / scale;\n        vec3 pix = texelFetch(iChannel1,ivec2(src),0).xyz;\n        if(pix.x > 0.) O.xyz = pix;\n    }\n}\n\n// ------------------------------------------------\n#ifdef DISPLAY_CELL_CAPTURE \n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = texelFetch(iChannel1,ivec2(U),0);\n}\n\n#endif\n\n// ------------------------------------------------\n#ifdef STACK_CELLS \n\nvoid mainImage(out vec4 O, vec2 U) {\n\n     O = vec4(0.);\n \n    float dstXhop = iResolution.x/float(gtotal);\n    float dstXsize = iResolution.x/float(gcount);\n    float dstYsize = iResolution.y/float(gcount);\n    float dstYbase = dstYsize;\n    \n    for(int i=0;i<gtotal;++i) {\n        float dstXbase = float(i) * dstXhop;\n        float dx = U.x - dstXbase;\n        float dy = U.y - dstYbase;\n        \n        if(dx >= 0. && dx < dstXsize && dy >= 0. && dy < dstYbase) {\n            vec2 src = gcoord(i) * iResolution.xy + vec2(dx,dy);\n            vec3 pix = texelFetch(iChannel1,ivec2(src),0).xyz;\n            if(pix.x > 0.) O.xyz = pix;\n        }\n     }\n}\n\n#endif\n\n// ------------------------------------------------\n#ifdef SCALE_CELLS \n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = vec4(0.);\n    float scale = 3.5;    \n    int index = (iFrame/skipFrame) % gtotal; // most recently saved cell index\n\n    float as = 0.3;\n    for(int i=0;i<gtotal;++i) {\n        float angle = PI2 * float(i)/float(gtotal);\n        vec2 center = vec2(0.5) + vec2(cos(angle)*as,sin(angle) * as);\n        if(++index >= gtotal) index = 0;\n\n        scaleCell(index,center,scale,O,U,true);\n        \n        scale *= 0.95;\n    }     \n}\n#endif\n\n// ------------------------------------------------\n#ifdef FRACTAL_LANDSCAPE\n\nfloat foam = 0.064;\nfloat foam2 = 1.07;\nfloat mult = 0.499;\nvec3 camera = vec3( -3.46559999, -7.33265000, -7.73873000);\nvec3 aim = vec3(0.76312483, -0.08013050, -0.64126405);\nfloat ostrength = 0.36;\nfloat ocycle = 0.;\nvec4 orbit2 = vec4( 0.38347405, 1.86336986, -0.01788503, -2.71105793);\nvec4 orbit3 = vec4(0.87534959, 1.04847687, 0.03234359, 0.00505466);\nvec3 orbit4 = vec3(-2.19183836, 1.41098694, 1.56200985);\nvec3 phongColor =  vec3(0.21999000, 0.30000000, 0.31999000);\nvec3 phongPosition = vec3(7.00000000, -20.00000000, 20.000);\nvec3 phongParam = vec3(0.,10.,5.99);\nvec4 spotLightParam = vec4(0.62,2.26,-2.05,1.32);\nvec3 spotLightColor = vec3(1.,0.44,0.);\n\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos) {\n    float t = foam2 + 0.25 * cos(mult * (pos.z - pos.x));\n    float k,scale = 1.0;\n    orbitTrap = vec4(10000.0);\n\n    for(int s=0; s < 3; ++s) {\n        pos = -1.0 + 2.0 * fract(0.5 * pos + 0.5);\n        pos -= sign(pos) * foam;\n\n        k = t / dot(pos,pos);     \n        pos *= k;\n        scale *= k;\n\n        vec3 ot = pos - orbit4;\n        orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n\n    float d1 = sqrt(min(min(dot(pos.xy,pos.xy), dot(pos.yz,pos.yz)), dot(pos.zx,pos.zx))) - 0.02;\n    return 0.5 * min(d1,abs(pos.y)) / scale;\n}\n\n// --------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\nvoid calcNormal() {\n    float d0 = DE(position);\n    const vec2 epsilon = vec2(.00001,0);\n    vec3 d1 = vec3(\n        DE(position-epsilon.xyy),\n        DE(position-epsilon.yxy),\n        DE(position-epsilon.yyx));\n    normal = normalize(d0 - d1);\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 U) {\n    vec3 viewVector = normalize(aim);//-qcamera);\n    vec3 sideVector = vec3(0.,1.,0.);\n    sideVector = cross(sideVector,viewVector);\n    sideVector = normalize(sideVector);\n    vec3 topVector = viewVector;\n    topVector = cross(topVector,sideVector);\n    \n    vec2 vPos = (U - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(ocycle,generateColor(orbit2.x,orbit2.y), orbitTrap.x) * orbit2.x * orbitTrap.x +\n        orbitTrapCycle(ocycle,generateColor(orbit2.z,orbit2.w), orbitTrap.y) * orbit2.z * orbitTrap.y +\n        orbitTrapCycle(ocycle,generateColor(orbit3.x,orbit3.y), orbitTrap.z) * orbit3.x * orbitTrap.z +\n        orbitTrapCycle(ocycle,generateColor(orbit3.z,orbit3.w), orbitTrap.w) * orbit3.z * orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(orbit2.x,orbit2.y) * orbit2.x * orbitTrap.x +\n        \tgenerateColor(orbit2.z,orbit2.w) * orbit2.z * orbitTrap.y +\n        \tgenerateColor(orbit3.x,orbit3.y) * orbit3.x * orbitTrap.z +\n        \tgenerateColor(orbit3.z,orbit3.w) * orbit3.z * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\n// --------------------------------------------------------\n\nvoid phongLight() {\n\tvec3 L = normalize(phongPosition - position);\n\tfloat dotLN = dot(L, normal);\n\tif (dotLN < 0.) return;\n\t\t\n\tfloat t1 = phongParam.x * dotLN;\n\tvec3 V = normalize(camera - position);\n\tvec3 R = normalize(reflect(-L, normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0)\n\t\tcolor += vec3(phongColor * t1);\n\n\tfloat t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n\tcolor += phongColor * (t1 + t2);\n}\n\n// --------------------------------------------------------\n\nconst float PI = acos(-1.);\n\nvoid spotLight() { \n\tfloat a1 = spotLightParam.y * PI;\n\tfloat a2 = spotLightParam.z * PI * 0.5;\n\tfloat s1 = sin(a1);\n\tvec3 spotDir = vec3(a1*s1,a2*s1, cos(a1));\n\tspotDir = normalize(spotDir);\n\tvec3 halfVector = normalize(spotDir - direction);\n\n\tfloat nDotL = max(0., dot(normal, spotDir));\n\tfloat hDotN = max(0., dot(normal, halfVector));\n\n    vec3 c = spotLightColor * spotLightParam.x;\n    float sexp = spotLightParam.w;\n\n\tcolor += c * ((sexp + 2.) / 2.) * pow(hDotN, sexp) \n\t\t* (sexp + (1. - sexp) * pow(1. - hDotN, 5.)) * nDotL * spotLightParam.x;\n}\n\n// --------------------------------------------------------\n\nvoid ambient() { \n    const float amb = 0.369;\n    float dim = 0.025; \n    const float contrast = 0.8;\n    color = texelFetch(iChannel2,ivec2(normal.xy * depth * 6.),0).xyz; \n    color += vec3(amb) + vec3(1. - float(iter) * dim);\n        \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }\n\n    phongLight();\n    spotLight();\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast; \n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.02;\nconst float MAX_DIST = 12.0;\nconst float EP = 0.00001;\n\nvoid rayMarch() {\n\tfloat distance;\n\tposition = camera;\n\titer = 0;\n\tdepth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n\t\n\tfor(int i = 0;i < 100;++i) {\n\t\tdistance = DE(position);\n        if(abs(distance) < EP || depth > MAX_DIST) break;\n        iter += 1;\n\t\t\n        depth += distance;\n        position += direction * distance;\n    }\n}\n\n// --------------------------------------------------------\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n    \nvoid fractalMainImage(inout vec4 O, vec2 U) {\n\n    animate2(foam,0.06, 0.05, 0.1);\n    animate2(foam2,1.0,0.5,  0.15);\n    animate2(mult,0.5,0.05,   0.3);\n\n    animate2(camera.x,-4.5,.5,   0.35);\n    animate2(camera.y,2.7,.05,   0.4);\n    animate2(camera.z,-7.7,0.1,   0.45);\n    const float as = 0.003;\n    animate(aim.x,-1.-as,as,0.035);\n    animate(aim.y,-as,as,   0.04);\n    animate(aim.z,1.-as,as, 0.05);\n \n    animate2(spotLightParam.y,2.26,0.5,0.3);\n    animate2(spotLightParam.z,-2.,0.5,0.35);\n    animate2(spotLightParam.w,1.3,0.5,0.4);\n    animate2(phongParam.x,1.44,0.5,0.3);\n    animate2(phongParam.y,3.,1.,0.35);\n    animate2(phongParam.z,7.,3.,0.4);\n    \n    animate2(spotLightColor.x,0.5,0.5,0.3);\n    animate2(spotLightColor.y,0.5,0.5,0.35);\n    animate2(spotLightColor.z,0.5,0.5,0.4);\n\n\n    animate(ostrength,0.,0.28,0.1);\n    animate(ocycle,0.,4.,0.18);\n    animate(orbit2.x,-1.,1.,0.011);  // X wt,color\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-1.,1.,0.015);  // Y wt,color\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-1.,1.,0.019);  // Z wt,color\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.23);  // center\n    animate(orbit4.y,-3.,3.,0.25);\n    animate(orbit4.z,-3.,3.,0.27);\n\n    setDirection(U);\n\trayMarch();\n    \n    O = vec4(0.,0.,0.,1000.);\n\tif(depth > MAX_DIST) return;  \n    calcNormal();\n    ambient();\n\n  \n    O.xyzw = vec4(color,depth);\n}\n\n// ------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    fractalMainImage(O,U);\n    float fractalDepth = O.w;\n\n    float scale = 0.2;    \n    int index = (iFrame/skipFrame) % gtotal; // most recently saved cell index\n\n    float as = 0.4;\n    float depth = 32.;\n    for(int i=0;i<gtotal;i += 1) {\n        float angle = PI2 * 0.25 + PI2 * float(i)/float(gtotal);\n        vec2 center = vec2(0.5,-0.15) + vec2(cos(angle)*as,-sin(angle) * as * 0.5 + float(i) * 0.03);\n\n        index += 1;\n        if(index >= gtotal) index -= gtotal;\n\n        if(depth < fractalDepth)\n            scaleCell(index,center,scale,O,U,true);\n        \n        scale *= 1.13;\n        depth -= 1.3; \n    }     \n}\n#endif\n\n// ------------------------------------------------\n#ifdef RADIAL_SYMMETRY \n\nvoid radialSymmetry(inout vec2 U, float radialAngle) {\n    if(radialAngle == 0.) return;\n    vec2 R = U/iResolution.xy;  // normalize coordinate\n    vec2 d = R - 0.5;        // distance from center\n    float angle = abs(atan(d.y,d.x)); // angle from center\n    float dist = length(d);\n    float dRatio = 0.01 + radialAngle;\n    \n    for(int test=0;test<100;++test) {\n        if(angle <= dRatio) break;\n        angle -= dRatio;\n    }\n    if(angle > dRatio * 0.5) angle = dRatio - angle;\n\n    U.x = (0.5 + cos(angle) * dist) * iResolution.x;\n    U.y = (0.5 + sin(angle) * dist) * iResolution.y;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float scale = (0.5 + sin(iTime * 0.1) * 0.5) * 3.;    \n    float ra = 1. + (0.5 + sin(iTime * 0.1) * 0.5) * 1.3;\n\n    radialSymmetry(U,ra);\n    \n    O = texelFetch(iChannel1,ivec2(U),0);\n}\n#endif\n\n// ------------------------------------------------\n#ifdef STEREO\n\nconst float parallax = 0.01;\n\nvoid stereoRender(int index,vec2 uv,float scale,float depth,inout vec4 O, vec2 U) {\n    float xCenter = iResolution.x * 0.5;\n    if(abs(U.x - xCenter) <= 1.) { O = vec4(0.5); return; }\n\n    uv.x *= 0.5;  \n    float depthOffset = depth * parallax;    \n    \n    vec2 p = uv + vec2(depthOffset,0.); // left side\n    if(U.x >= 0. && U.x < iResolution.x * 0.5) scaleCell(index,p,scale,O,U,true);\n    \n    p = uv + vec2(0.5 - depthOffset,0.); // right side\n    if(U.x >= iResolution.x * 0.5 && U.x < iResolution.x) scaleCell(index,p,scale,O,U,true);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = vec4(0.);\n\n    int index = (iFrame/skipFrame) % gtotal; // most recently saved cell index\n    float scale = 2.5;    \n    float as = 0.3;   // scale position from center\n    \n    for(int i=0;i<gtotal;++i) {\n        float angle = PI2 * float(i)/float(gtotal);\n        float depth = 1. - float(i) * 0.2;\n        vec2 center = vec2(0.5) + vec2(cos(angle)*as,sin(angle) * as);\n        if(++index >= gtotal) index = 0;\n\n        stereoRender(index,center,scale,depth,O,U);\n        \n        scale *= 0.95;\n    }     \n}\n#endif\n\n// ------------------------------------------------\n#ifdef STEREO_FRACTAL\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n    \nvec2 center;\n\nvoid drawNormalizedCircle(vec3 pt3, float radius, vec3 color,inout vec4 O,vec2 U) {\n    vec2 pt = vec2(iResolution.x * pt3.x,iResolution.y * pt3.y);\n    radius *= iResolution.x;\n    float d = length(U-pt);\n    if(d < radius) {\n        float d2 = length(U - vec2(-radius * 0.3,radius * 0.3) - pt);\n        O.xyz = color - vec3(d2 / (radius * 3.5));\n        O.w = pt3.z;\n    }\n    if(abs(d - radius)< 1.) O = vec4(0.,0.,0.,pt3.z);\n}\n\nconst float parallax = 0.001;\n\nvoid stereoSphere(vec3 position,float radius,vec3 color,inout vec4 O, vec2 U) {\n    float xCenter = iResolution.x * 0.5;\n    if(abs(U.x - xCenter) <= 1.) { O = vec4(0.5); return; }\n    vec2 uv = position.xy;\n    \n    uv.x *= 0.5;  \n    radius *= (0.5 - position.z * 0.015); // / pow(position.z,3.);\n    float depthOffset = position.z * parallax;    \n    \n    vec2 p = uv + vec2(depthOffset,0.); // left side\n    if(U.x >= 0. && U.x < iResolution.x * 0.5) drawNormalizedCircle(vec3(p,position.z),radius,color,O,U);\n    \n    p = uv + vec2(0.5 - depthOffset,0.); // right side\n    if(U.x >= iResolution.x * 0.5 && U.x < iResolution.x) drawNormalizedCircle(vec3(p,position.z),radius,color,O,U);\n}\n\n// ------------------------------------------------------------\n\nvoid stereoRender(int index,vec2 uv,float scale,float depth,inout vec4 O, vec2 U) {\n    float xCenter = iResolution.x * 0.5;\n    if(abs(U.x - xCenter) <= 1.) { O = vec4(0.5); return; }\n\n    uv.x *= 0.5;  \n    float depthOffset = depth * parallax;    \n    \n    vec2 p = uv + vec2(depthOffset,0.); // left side\n    if(U.x >= 0. && U.x < iResolution.x * 0.5) scaleCell(index,p,scale,O,U,true);\n    \n    p = uv + vec2(0.5 - depthOffset,0.); // right side\n    if(U.x >= iResolution.x * 0.5 && U.x < iResolution.x) scaleCell(index,p,scale,O,U,true);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    if(abs(U.x - iResolution.x * 0.5) <= 1.) { O = vec4(1.); return; }\n    O = vec4(0.,0.,0.,1000.);\n\n    // waves ---------------------------------\n    for(float i=0.;i<float(gtotal*2);i += 1.) {   \n        float x = 0.5 + sin(iTime * 0.2 + i) * (0.2 + i * 0.01);\n        float y = 0.75 - i * 0.025 + sin(iTime * 0.2) * 0.01;\n        float depth = 10. - i * 0.9;\n        float radius = 0.03 + i * 0.002;\n        \n        float r = radius;\n        for(float j=-0.4;j<0.4;j += 0.08) {\n            vec3 color = vec3(sin(j*20.) * 0.9,0.5,1. - sin(j*25.) * 0.5);\n            stereoSphere(vec3(x+j,y,depth),r + sin(j*12.) * 0.02,color,O,U);\n            r *= 0.9;\n        }\n    }\n\n    // video ----------------------------------\n    float fractalDepth = O.w;\n    float scale = 0.3;    \n    int index = (iFrame/skipFrame) % gtotal; // most recently saved cell index\n    float as = 0.5;\n    float depth = 20.;\n    \n    for(int i=0;i<gtotal;i += 1) {\n        float fi = float(i);\n        float angle = PI2 * 0.25 + PI2 * 4. * fi/float(gtotal);\n        float x = 0.22 + sin(iTime * 0.1 + fi) * (0.1 + fi * 0.01);\n        float y = 0.3 - fi * 0.04;\n        vec2 center = vec2(0.5, 0.5) + vec2(x,y);\n\n        if(++index >= gtotal) index -= gtotal;\n\n        if(depth < fractalDepth)\n            stereoRender(index,center,scale,depth,O,U);\n            \n        scale *= 1.15;\n        depth -= 2.5; \n    }  \n    \n}\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// define only one of these\n//#define DISPLAY_CELL_CAPTURE \n//#define STACK_CELLS\n//#define SCALE_CELLS\n//#define FRACTAL_LANDSCAPE  // works well with Claude video\n//#define RADIAL_SYMMETRY    // works well with Britney video\n//#define STEREO               // Claude video\n#define STEREO_FRACTAL       // Claude video\n\n#ifdef DISPLAY_CELL_CAPTURE\nconst int gcount = 5;        // # cells per axis\nconst int skipFrame = 3;     // #video frames overwritten per cell\n#endif\n\n#ifdef STACK_CELLS\nconst int gcount = 4;\nconst int skipFrame = 6;\n#endif\n\n#ifdef SCALE_CELLS\nconst int gcount = 5;\nconst int skipFrame = 3;\n#endif\n\n#ifdef FRACTAL_LANDSCAPE\n#define FRACTAL_ROUTINES\nconst int gcount = 5;\nconst int skipFrame = 5;\n#endif\n\n#ifdef RADIAL_SYMMETRY  // works well with Britney video\nconst int gcount = 2;\nconst int skipFrame = 1;\n#endif\n\n#ifdef STEREO\nconst int gcount = 5; // # cells per axis\nconst int skipFrame = 2;\n#endif\n\n#ifdef STEREO_FRACTAL\n#define FRACTAL_ROUTINES\nconst int gcount = 4;\nconst int skipFrame = 4;\n#endif\n\nconst int gtotal = gcount * gcount; // total #cells on screen\nconst float gsize = 1./float(gcount); // normalized size of cell\n// ---------------------------------------------------------------------\n\nivec2 gindex(int b) { return ivec2(b % gcount, b / gcount); } // map cell index to logical coordinate\n\nvec2 gcoord(int b) { // map cell index to normalized uv coordinate \n    ivec2 g = gindex(b);\n    return vec2(float(g.x) * gsize,float(g.y) * gsize);\n}\n\nvec3 pixel(sampler2D channel,vec2 uv) { // green screen removal\n    vec3 p = texture(channel,uv).xyz;\n/*   \n    // sharpen-------------\n    const float scl = 0.01;\n    vec3 total = vec3(0.);\n    for(int x=-1;x<=1;++x)\n        for(int y=-1;y<=1;++y) \n            if(x!=0 || y!=0) \n                total += texture(channel,uv + vec2(float(x) * scl,float(y) * scl)).xyz;\n        \n    p =  p*2. - total/8.0;    \n*/            \n    if(p.y > 0.35 && p.y > p.x * 1.25 && p.y > p.z * 1.25) return vec3(0.);\n    return p;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage(out vec4 O, vec2 U) {\n\n    O = texelFetch(iChannel1,ivec2(U),0);\n    int frame = iFrame/skipFrame;  // only save occasional images\n\n    vec2 uv = U/iResolution.xy;  // normalized pixel coordinate\n    vec2 base = gcoord(frame % gtotal); // normalized coordinate of current cell \n    \n    // uv not within current cell?\n    if(uv.x < base.x || uv.x >= base.x+gsize || uv.y < base.y || uv.y >= base.y+gsize) return;\n    \n    O.xyz = pixel(iChannel0,(uv - base) / gsize); // whole video image mapped to current cell\n}","name":"Buffer A","description":"","type":"buffer"}]}