{"ver":"0.1","info":{"id":"sltSWS","date":"1639721148","viewed":331,"name":"Fluffy Clouds","username":"tsaari42","description":"Back to shaders after a long break, and.. fluffy clouds :D Now with a weird disco ball star! Inspiration from multiple sources, especially iq continues to amaze me - wanted something minimalistic, Clouds was nice source of that. Missing custom textures.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) Timo Saarinen 2021\n// You can use this Work in a Good and Cool Spirit.\n// Just don't copy-paste the whole thing, that's lame!\n// Greetings go to IQ and other Shadertoy inspirators.\n\n// Turbo loader, volumetric clouds, weird star, demoish effects.\n// One goal was to not use textures at all for 3D, but to do everything\n// procedurally. Tested with custom logo 2D textures, but works without \n// them. And the usual disclaimer: this was done in a hurry. \n// Lots of room for optimization et al.\n\nconst float PI = 3.141592; // close enough\n\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat iRaySphere(in vec3 ro, in vec3 rd, in vec3 sph, in float rad) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float t = b*b - c;\n    return (t > 0.0) ? -b - sqrt(t) : t;\n}\n\nmat4 lookat(in vec3 o, in vec3 dir, in vec3 worldup)\n{\n    vec3 right = normalize(cross(dir, worldup));\n    vec3 up = normalize(cross(right, dir));    \n    mat4 m = mat4(vec4(right, 0.0), vec4(up, 0.0), vec4(dir, 0.0), vec4(o, 1.0));\n    return m;\n}\n\n// by trisomie21\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\n// Star background\n// https://www.shadertoy.com/view/XsyGWV\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\n// 3D noise function (IQ)\nfloat noise3(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n//------------------------------------------------------------------------\n//  Raymarching clouds+ (based on: https://www.shadertoy.com/view/XslGRr)\n//------------------------------------------------------------------------\nconst vec3 sundir = normalize( vec3(-1.0,0.0,-1.9) );\nconst vec3 sunpos2 = sundir;\nconst float sunr = 0.3;\nconst int kDiv = 1; // make bigger for more steps, higher quality\n\nfloat cloudnoise(in vec3 x)\n{\n    return snoise(x * 0.1, 10.0);\n}\nfloat cloudDensity(in vec3 p, int oct) {\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n    float g = 0.5 + 0.5*cloudnoise( q*0.3 );\n    \n\tfloat f;\n    f  = 0.50000*cloudnoise( q ); q = q*2.02;\n    f += 0.25000*cloudnoise( q ); q = q*2.23;\n    f += 0.12500*cloudnoise( q ); q = q*2.41;\n    f += 0.06250*cloudnoise( q ); q = q*2.62;\n    f += 0.03125*cloudnoise( q ); \n    \n    f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    return 1.5*f - 0.5 - p.y;\n}\n\nvec3 background(in vec3 ro, in vec3 rd, in ivec2 px, in vec3 suncol, in float sundot, in float beat) {\n    vec3 add = vec3(0.0);\n    vec3 sunpos = ro + sunpos2;\n    float sunt = iRaySphere(ro, rd, sunpos, sunr + 0.005*beat);\n\n    vec3 halocol = suncol;\n    float halo = pow(sundot, 32.0*5.0*sunr + 4.0*5.0*sunr*-beat);\n\n    if( sunt > 0.0 ) {\n        // add \"sun\"\n        vec3 p2 = (ro + sunt*rd) - sunpos;\n        vec3 hitn = normalize(p2);\n        add.xyz += saturate(dot(vec3(0.0, 0.0, 1.0),hitn)) * vec3(0.2, 0.0, 0.5);\n\n        vec3 n = normalize( vec3( hitn.x, 0.0, hitn.z ) );\n        float u = acos( dot( vec3(1.0, 0.0, 0.0), n ) )/PI;\n        float v = acos( dot( vec3(0.0, 1.0, 0.0), hitn ) )/PI;\n\n        float sunnoise = abs( noise3(vec3(u*777.0,v*997.0, 0.1*iTime)) );\n\n        vec3 sun0 = suncol * 0.5;\n        vec3 sun1 = suncol * 1.5;\n        add.xyz += mix(sun0, sun1, saturate(sin(50.0*u*v + iTime) + cos(0.07*v + 0.7*iTime)));\n        add.xyz += 1.0*halo*halocol; // keep some \"halo\" inside\n    } else {\n        // sun halo + stars\n        add.xyz += 10.0*stars(rd);\n        add.xyz += 10.0*halo*halocol;\n    }\n    return add;\n}\n\n// TODO: the idea was to get some mountaintops peaking from clouds..\nvec4 hitTerrain(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    return vec4(0.0, 1.0, 0.0, 99999999.0); \n}\n\nvec3 raymarch(in vec3 ro, in vec3 rd, in ivec2 px, float beat)\n{\n    float tmin = 0.1; // just fixed bounds for now\n    float tmax = 10.0;\n    \n    float sundot = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 suncol = vec3(1.0, 0.95, 0.840) * (1.0+saturate(0.5*-beat));\n    vec3 horizcol = vec3(0.32, 0.0, 1.0);\n    vec3 glarecol = vec3(1.0, 1.0, 1.0);\n    vec3 dircol = 0.6 * vec3(1.0, 0.8, 1.0);\n   \n    // terrain\n    vec4 terra = hitTerrain(ro, rd, tmin, 100.0*tmax);\n\n    // background (sun, stars)\n    vec3 bgcol = background(ro, rd, px, suncol, sundot, beat);\n    \n    // raymarch loop\n\tvec4 sum = vec4(0.0);\n    vec3 add = vec3(0.0);\n    int numsteps = 64*kDiv;\n    float dt = tmax / float(numsteps);\n    float t = tmin + noise3(vec3(px, iTime)) * dt; // jitter the raymarch start position\n    for(int i=0; i < numsteps; ++i) {\n        vec3 pos = ro + t*rd;\n\n        int oct = 5 - int(log2(1.0 + 0.5*t));\n        float density = cloudDensity(pos, oct);\n        if( density > 0.01 ) {\n            vec3 clouddencol = vec3(5.0, 0.3, 0.3);\n            float shadowFeeler = cloudDensity(pos + 0.3*sundir, oct);\n            float diffuse = clamp((density - shadowFeeler)/0.3, 0.0, 1.0);\n            vec3 cloudcol = 0.5*suncol + vec3(0.0, 0.0, 1.25*abs(rd.y));\n            vec3 lin = suncol*diffuse + cloudcol;\n            \n            vec4 col = vec4(lin * mix(suncol, clouddencol, density), density);\n            col.w = min(col.w*8.0*dt, 1.0);\n            col.rgb *= col.a;\n            sum += col*(1.0-sum.a);\n        }\n        \n        t += dt;\n        if( t > tmax || sum.a > 0.99 ) break; // far clip or full opacity? \n        //if( t > terra.w ) { // TODO: hit the ground? }\n    }\n\n    // FIX: shows as overlay.. well, kinda works\n    vec3 horiz = (pow(1.0-abs(rd.y + 0.00), 8.0)) * horizcol;\n    horiz += (pow(1.0-abs(rd.y + 0.00), 32.0)) * vec3(5.0, 5.0, 0.0) * beat;\n\n    return clamp( sum.xyz, 0.0, 1.0 ) + add + (1.0-sum.w)*bgcol + horiz*t/tmax;\n}\n\n//-------------------------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in ivec2 px, float beat)\n{\n    vec3 col = raymarch(ro, rd, px, beat);\n    return col.xyz; // TODO: tone mapping\n}\n\n//-------------------------------------------------------------------------\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) // by IQ\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) ); \n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float beat = pow(0.75*(cos(iTime) * cos(iTime*0.97)) + 0.25*cos(iTime*7.77), 2.0);\n\n    //vec2 m = iMouse.xy / iResolution.xy; // if want to look around..\n    vec2 m = vec2(0.0, -0.15);\n\n    // camera by IQ (was nice)\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.8*m.y, cos(3.0*m.x))) - vec3(0.0,0.1,0.0);\n\tvec3 ta = vec3(0.0, -1.5, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.07*cos(0.25*iTime) );\n    \n    // render the 3D scene\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    vec3 c = render( ro, rd, ivec2(fragCoord-0.5), beat );\n\n    // logos\n    vec3 dude = texture(iChannel2, vec2(2.0*p.xy) + 2.0*vec2(1.25, 1.2)\n        + beat*0.65*vec2(sin(p.x*iTime), cos(5.0*p.y*iTime)) + 2.0*vec2(-1.0, -0.5)).xyz;\n    c += beat * dude.g * vec3(0.0, 0.25, 0.0) * clamp(0.05*iTime, 0.0, 1.0);\n\n    // vignetting + \"film grain\"\n    float vigdist = length(p);\n    float vignette = mix(1.5, 0.0, pow(0.25*vigdist, 0.5));  \n    float grain = 1.0; //0.0 + 1.0*pow(0.5+0.5*noise3(vec3(p.xy*1397.0, fract(iTime*97.0))), 0.51);\n    c *= vignette * grain;\n    \n    // fade in everything except the logo\n    float logofade = clamp(0.05*iTime, 0.0, 1.0);\n    float fade = clamp(0.5*(iTime-2.0), 0.0, 1.0); \n    c *= fade;\n    \n    // top logo\n    vec4 logotexel = texture(iChannel0, vec2(1.0*p.xy) + 1.0*vec2(0.5, 0.5));\n    float a = logofade * logotexel.g;\n    c = (1.0-a)*c + a*logotexel.rgb; // TODO: premul alpha?\n    \n    // Kraku's Tetris-remix logo flash at start.. \n    float krakudur = 1.0;\n    if( iTime < krakudur ) { \n        float krakufade = (iTime < 0.25*krakudur) ? \n            mix(0.0, 1.0, saturate(iTime/0.25)) :\n            (iTime > 0.75*krakudur ? mix(1.0, 0.0, saturate((iTime - 0.75*krakudur)/(0.25*krakudur)))\n                : 1.0);\n        c += krakufade * texture(iChannel1, vec2(0.0, 1.0-krakufade) + fragCoord/iResolution.xy).xyz; // TODO: aspect\n    }\n    // ..and a turbo-loader!\n    float turboloaderdur = krakudur;\n    if( iTime < krakudur ) {\n        float border = iTime < 0.75*turboloaderdur ? 64.0 : mix(64.0, 0.0, (iTime-0.75*turboloaderdur) / 0.25*turboloaderdur);\n        if( fragCoord.x < border || fragCoord.x > iResolution.x-border || \n            fragCoord.y < border || fragCoord.y > iResolution.y-border) {\n            c = nmzHash33(vec3(fragCoord.y, iTime, 997.0*iTime)); \n        }\n    }\n\n    c = 1. - exp(-c*3.0); // @Plento too dark w/o multiplier, and I think it's the noise, TODO: check noise\n    \n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}