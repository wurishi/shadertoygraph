{"ver":"0.1","info":{"id":"Wl3BD8","date":"1612572285","viewed":114,"name":"formographik__001","username":"formographik","description":"A grid of black and white circles and black and white squares.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid","opart","formographik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A shader by Nicole Vella. (2021)\n// @nicole.vella.art\n// www.nicolevella.com\n//\n// Attribution 4.0 International (CC BY 4.0)\n// This work is licensed under a Creative Commons Attribution 4.0 International License. \n// http://creativecommons.org/licenses/by/4.0/\n\nfloat map(float value,float min1,float max1,float min2,float max2){\n    return min2+(value-min1)*(max2-min2)/(max1-min1);\n}\n\nvec2 createGrid(in vec2 st,in vec2 grid,out vec2 indices){\n    \n    st*=grid;\n    indices=floor(st);\n    st=fract(st);\n    \n    return st;\n}\n\nfloat drawRectangle(vec2 st,vec2 pos,vec2 size){\n    \n    float result=1.;\n    vec2 border=(1.-size)/2.200;\n    st=st-pos+vec2(.5);\n    result=step(border.x,st.x);\n    result*=step(border.x,1.-st.x);\n    result*=step(border.y,st.y);\n    result*=step(border.y,1.-st.y);\n    \n    return result;\n}\n\n#define drawCircle(st,pos,size) smoothstep(0.,15./iResolution.y,size - length(pos-st) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st=fragCoord.xy/iResolution.xy;\n    st.x*=iResolution.x/iResolution.y;\n    \n    vec2 st0=st;\n    vec2 indices;\n    st=createGrid(st,vec2(10.,10.),indices);\n    \n    float delay=.45;\n    float circSize=map(cos(iTime*delay*2.),-1.,1.,0.71,0.5);\n    vec2 size=vec2(.25,.25);\n    vec2 pos=vec2(.5,.5);\n    \n    vec3 white=vec3(1.);\n    vec3 black=vec3(0.);\n    vec3 canvas=vec3(0.);\n    \n    float animation0to1=map(cos(iTime*delay),-1.,1.,0.01,0.99);\n    float animation1to0=map(cos(iTime*delay),-1.,1.,.99,0.01);\n    float rect=drawRectangle(st,vec2(.5),vec2(1.));\n    \n    float circleTLTR=drawCircle(st,vec2(animation0to1,1.),circSize);\n    float circleBRTL=drawCircle(st,vec2(animation1to0,0.),circSize);\n    float circleLTTB=drawCircle(st,vec2(0.,animation1to0),circSize);\n    float circleRBTT=drawCircle(st,vec2(1.,animation0to1),circSize);\n    \n    if((mod(indices.x,2.)==0.&&mod(indices.y,2.)==1.)||(mod(indices.x,2.)==1.&&mod(indices.y,2.)==0.)){\n        \n        canvas=mix(canvas,white,rect);\n        canvas=mix(canvas,black,circleTLTR);\n        canvas=mix(canvas,black,circleBRTL);\n        \n    }else{\n        \n        canvas=mix(canvas,black,rect);\n        canvas=mix(canvas,white,circleRBTT);\n        canvas=mix(canvas,white,circleLTTB);\n        \n    }\n    \n    fragColor=vec4(canvas,1.);\n\n}","name":"Image","description":"","type":"image"}]}