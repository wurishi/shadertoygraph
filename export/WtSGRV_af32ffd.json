{"ver":"0.1","info":{"id":"WtSGRV","date":"1560164256","viewed":1163,"name":"Plasma Beat","username":"adelciotto","description":"A shader written with love.\n\nSet the RETRO_MODE variable to 1 to enable pixelated effect.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["plasma","heart","rotation","love"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RETRO_MODE 0\n\nconst float RETRO_PIXEL_SIZE = 4.0;\nconst float PULSE_DURATION = 1.5;\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI * 2.0;\n\n//  function from IÃ±igo Quiles (no cubic smoothing)\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsvToRgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 p, float angle) {\n    return vec2(\n        cos(angle)*p.x + sin(angle)*p.y,\n        -sin(angle)*p.x + cos(angle)*p.y\n    );\n}\n\nfloat heart(vec2 p, vec2 center, float size, float angle) {\n    vec2 o = (p - center) / (1.6 * size);\n    vec2 ro = rotate(o, angle);\n    float a = ro.x*ro.x + ro.y*ro.y - 0.3;\n\n    return step(a*a*a * 2.0, ro.x*ro.x * ro.y*ro.y*ro.y);\n}\n\n// modified plasma effect from https://www.bidouille.org/prog/plasma\nvec3 plasma(vec2 p, float scale) {\n    float angle = iTime*0.3;\n    vec2 rp = rotate(p, angle);\n    rp *= scale;\n\n    float v1 = sin(rp.x+iTime);\n    float v2 = sin(rp.y+iTime);\n    float v3 = sin(rp.x+rp.y+iTime);\n    float v4 = sin(length(rp) + 1.7*iTime);\n    float v = v1+v2+v3+v4;\n\n    v *= 2.0;\n    vec3 col = vec3(1.0, 0.3-sin(v+PI*.5)*0.2, 0.8 - sin(v+PI*.5)*0.2);\n    return col*0.5 + 0.5;\n}\n\nvec3 render(vec2 uv, float t) {\n    float pulseTime = mod(t, PULSE_DURATION) / PULSE_DURATION;\n    float pulseBeat = pow(pulseTime, 0.2) * 0.5 + 0.5;\n\n    float pulse = 1.0 + pulseBeat * 0.5 * sin(pulseTime*TWO_PI*3.0 + uv.y*0.5) * exp(-pulseTime * 4.0);\n    vec3 col = plasma(uv, pulse * 8.0);\n\n    // Centre heart.\n    float radius = pulse * .4;\n    float d = heart(uv, vec2(0, -0.07), radius, 0.0);\n    vec3 heartCol = mix(vec3(1.0), vec3(0.95, 0.37, 0.47), pulse);\n    col = mix(col, heartCol, d);\n\n    // Rotating heart ring.\n    const float piOver6 = PI / 6.0;\n    pulse = 0.4 + pulseBeat * 0.3 * sin(pulseTime*TWO_PI*3.0 + uv.x*0.6) * exp(-pulseTime*3.33);\n    float ringRadius = 0.25 + pulse;\n    for (float angle = piOver6; angle <= TWO_PI; angle += piOver6) {\n        float currentAngle = iTime*.8+angle;\n        vec2 center = vec2(ringRadius*cos(currentAngle), ringRadius*sin(currentAngle));\n        float d = heart(uv, center, 0.08, currentAngle);\n        vec3 heartCol = hsvToRgb(vec3((currentAngle / TWO_PI) + 0.5, ringRadius, 1.0));\n        col = mix(col, heartCol, d);\n    }\n\n    return col;\n}\n\nvec2 normalizeScreenCoords(vec2 fragCoord) {\n    // Get coordinate in the range -1, 1.\n\tvec2 result = 2.0 * (fragCoord / iResolution.xy - 0.5);\n    \n    // Correct for the aspect ratio.\n    result.x *= iResolution.x / iResolution.y;\n\t\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = normalizeScreenCoords(fragCoord);\n#if RETRO_MODE\n    uv = ceil(uv / retroPixelSize) * retroPixelSize;\n#endif\n    float t = iTime;\n    \n    vec3 col = render(uv, iTime);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}