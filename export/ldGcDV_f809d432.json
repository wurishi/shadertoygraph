{"ver":"0.1","info":{"id":"ldGcDV","date":"1523372013","viewed":508,"name":"Enter the void","username":"Flopine","description":"Kaleidoscopic stuff, please watch it from the beginning (time 0) :)","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","colors","experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, XT95 and lamogui for teaching me :) <3\n\n\n#define STEPS 60.\n#define PI 3.141592\n\nvec2 moda (vec2 p, float per)\n{\n   float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mo(inout vec2 p, vec2 d) \n{\n\tp.y = abs(p.y) - d.x;\n\tp.x = abs(p.x) - d.y;\n\tif (p.y > p.x) p.xy = p.yx;\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos(2.*PI*(c*t+d));\n}\n\nfloat cyl (vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sphe (vec3 p, float r)\n{\n\treturn length(p)-r;    \n}\n\nfloat petal(vec3 p)\n{\n    p.xy *= rot(PI);\n    p.x += sin(p.y/1.7)*1.8;\n  \tp.y += 2.;\n    return cyl(p.xz,p.y*0.1+0.5);\n}\n\nfloat flower(vec3 p)\n{\n    p.xz *= rot(PI*2.);\n    p.xz = moda(p.xz, (2.*PI)/8.);\n    p.x -= 3.;\n    return petal(p);\n}\n\nfloat pistil(vec3 p)\n{\n    float r = 1.3;\n    float per = r+5.;\n    float c = cyl(p.xz,r/4.+p.y*0.04);\n    p.y -= tan(iTime);\n    p.y = mod(p.y - per/2.,per)-per/2.;\n    return smin(sphe(p,r*0.8),c, 0.8);\n}\n\nfloat gate (vec3 p, float mdl)\n{\n    mo(p.xy,vec2(mdl));\n    mo(p.xz, vec2(mdl/2.));\n    return min(flower(p),pistil(p));\n}\n\nfloat fractal (vec3 p, int IM)\n{\n    float g = gate(p,10.);\n    for (int i=0; i<IM; i++)\n    {        \n        p = abs(p);\n        p -= 25.;\n        p.xy *= rot(PI/4.);      \n        p.xz *= rot(PI/8.);       \n        g = min(g,gate(p,10.));\n    }\n    return g;\n}\n\n\nfloat sdf (vec3 p, int i)\n{\n    return fractal(p, i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float sin_per = 15.;\n    vec3 p = vec3 (0.001,0.001,-cos((iTime)/9.)*sin_per+sin_per);\n    vec3 dir = normalize(vec3(uv,1.));\n    float shad = 0.;\n    float d = 0.;\n    \n    for (float i=0.;i<STEPS;i++)\n    {\n\t\td = sdf(p, int(i));\n        if (d<0.01)\n        {\n            shad = i/STEPS;\n            break;\n        }\n        p+=d*dir;\n    }\n    vec3 pal = palette(length(uv),\n                      vec3(0.5),\n                      vec3(0.5),\n                      vec3(0.5,0.5,1.),\n                      vec3(0.3,0.9,0.8)\n                      );\n    \n    // Time varying pixel color\n    vec3 col = vec3(shad*2.5)*pal;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}