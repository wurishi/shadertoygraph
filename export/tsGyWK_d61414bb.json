{"ver":"0.1","info":{"id":"tsGyWK","date":"1603741197","viewed":243,"name":"fdog second attempt","username":"mrmola","description":"fdog?? fdog.","likes":2,"published":1,"flags":34,"usePreview":0,"tags":["fdog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float hopDistance = 1.;\nconst int steps = 20;\n#define LC\nvoid lineKernel( inout vec3 n[5], in vec2 coords, in vec2 normal ){ \n    vec2 humerous = vec2(-normal.y, normal.x)*lineDistance/iResolution.xy;\n    n[0] = texture( iChannel0, coords+humerous*2.).xyz;\n    n[1] = texture( iChannel0, coords+humerous).xyz;\n    n[2] = texture( iChannel0, coords).xyz;\n    n[3] = texture( iChannel0, coords-humerous).xyz;\n    n[4] = texture( iChannel0, coords-humerous*2.).xyz;\n}\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n  float w = sobelStep / iResolution.x;\n  float h = sobelStep / iResolution.y;\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\nvoid make_mini_kernel(inout vec4 n[9], sampler2D tex, vec2 coord, float scale)\n{\n  float w = scale / iResolution.x;\n  float h = scale / iResolution.y;\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\nvec4 getAverage(in vec2 coord, in  float scale) {\n        vec2 multi = 1./iResolution.xy;\n    float tlength = float(size)*float(size);\n     vec4 tempColor, average;\n    for(float i = -float(size)*scale; i < float(size)*hacky; i+=scale) {\n        for(float j = -float(size)*scale; j < float(size)*hacky; j+=scale) {\n            tempColor = texture(iChannel0, multi*(coord+vec2(float(i), float(j))));\n            float theLength =  tempColor.x*tempColor.x + tempColor.y*tempColor.y+ tempColor.z*tempColor.z;\n            average += length(vec2(i,j)/scale)/float(size*size);\n        }\n    }\n    return average/average.w;\n}\nfloat getTheta( in vec2 coord, inout vec4 n[9] ) {\n\n    make_kernel( n, iChannel0, coord/iResolution.xy );\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n    vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n    sobel_edge_h.w = 0.;\n    sobel_edge_v.w = 0.;\n    //vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    float theta = atan(length(sobel_edge_h)/length(sobel_edge_v));\n    return theta;\n}\n\nfloat getMag( in vec2 coord, inout vec4 n[9] ) {\n    make_kernel( n, iChannel0, coord/iResolution.xy );\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n    vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n    sobel_edge_h.w = 0.;\n    sobel_edge_v.w = 0.;\n    vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    sobel.w = 0.;\n\treturn length(sobel);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 average;\n    vec3 s[5];\n    vec4 n[9];\n    vec2 currentCoord = fragCoord;\n    vec4 linearity;\n    float nm = 1.;\n    for(int i =0; i < steps && getMag(currentCoord, n) > 0.5 ;i++)\n    {\n        float theta = getTheta(currentCoord, n);\n        vec2 normal = vec2(cos(theta), sin(theta));\n        lineKernel(s, currentCoord/iResolution.xy, normal);\n        vec4 tAverage;\n        for(int j = 0; j < 5; j++) {\n\t\t\ttAverage += vec4(s[j], 1.0);\n        }\n        average += tAverage/5.;\n        vec3 coolColor;\n        coolColor = s[0]+s[1]*2.-s[3]*2.-s[4];\n        linearity += vec4(coolColor,1.);\n        currentCoord += normal*hopDistance; \n    }\n    \n#ifdef debug\n    fragColor = vec4(texture(iChannel1, currentCoord/iResolution.xy).xyz, 1.0);\n#endif\n#ifdef outline\n    if(length(linearity.xyz) > 1. || average.w >(float(steps)-10.)) {\n\t\tfragColor = vec4(0,0,0,1);\n    } else if(average.w > 0.) {\n    \tfragColor =average/average.w;\n    } else {\n\t\tfragColor =texture(iChannel0, fragCoord/iResolution.xy);\n    }\n#endif\n#ifdef LC\n    //make_mini_kernel(n, iChannel2, fragCoord/squareSize/iResolution.xy,1./squareSize);\n    //average = n[0]+n[1]+n[2]+n[3]+n[4]*8.+n[5]+n[6]+n[7]+n[8];\n    //average = getAverage(fragCoord/squareSize/iResolution.xy,1.5);\n    vec2 move = texture(iChannel2, fragCoord/squareSize/iResolution.xy).xy;\n    fragColor=texture(iChannel1, (fragCoord+move*50.)/iResolution.xy);\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void lineKernel( inout vec3 n[5], in vec2 coords, in vec2 normal ){ \n    vec2 humerous = vec2(-normal.y, normal.x)*lineDistance/iResolution.xy;\n    n[0] = texture( iChannel0, coords+humerous*2.).xyz;\n    n[1] = texture( iChannel0, coords+humerous).xyz;\n    n[2] = texture( iChannel0, coords).xyz;\n    n[3] = texture( iChannel0, coords-humerous).xyz;\n    n[4] = texture( iChannel0, coords-humerous*2.).xyz;\n}\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n  float w = sobelStep / iResolution.x;\n  float h = sobelStep / iResolution.y;\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\nfloat getTheta( in vec2 coord, inout vec4 n[9] ) {\n\n    make_kernel( n, iChannel0, coord/iResolution.xy );\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n    vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n    sobel_edge_h.w = 0.;\n    sobel_edge_v.w = 0.;\n    //vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    float theta = atan(length(sobel_edge_h)/length(sobel_edge_v));\n    return theta;\n}\n\nfloat getMag( in vec2 coord, inout vec4 n[9] ) {\n    make_kernel( n, iChannel0, coord/iResolution.xy );\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n    vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n    sobel_edge_h.w = 0.;\n    sobel_edge_v.w = 0.;\n    vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    sobel.w = 0.;\n\treturn length(sobel);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec4 n[9];\n    vec2 uv = fragCoord*squareSize;\n    float theta = getTheta(uv, n);\n    vec2 normal = vec2(cos(theta), sin(theta));\n    fragColor = vec4(normal*getMag(uv,n), 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float hopDistance = 1.;\nconst int steps = 20;\nvoid lineKernel( inout vec3 n[5], in vec2 coords, in vec2 normal ){ \n    vec2 humerous = vec2(-normal.y, normal.x)*lineDistance/iResolution.xy;\n    n[0] = texture( iChannel0, coords+humerous*2.).xyz;\n    n[1] = texture( iChannel0, coords+humerous).xyz;\n    n[2] = texture( iChannel0, coords).xyz;\n    n[3] = texture( iChannel0, coords-humerous).xyz;\n    n[4] = texture( iChannel0, coords-humerous*2.).xyz;\n}\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n  float w = sobelStep / iResolution.x;\n  float h = sobelStep / iResolution.y;\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\nfloat getTheta( in vec2 coord, inout vec4 n[9] ) {\n\n    make_kernel( n, iChannel0, coord/iResolution.xy );\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n    vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n    sobel_edge_h.w = 0.;\n    sobel_edge_v.w = 0.;\n    //vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    float theta = atan(length(sobel_edge_h)/length(sobel_edge_v));\n    return theta;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 average;\n    vec3 s[5];\n    vec4 n[9];\n    vec2 currentCoord = fragCoord;\n    vec4 linearity;\n    float nm = 1.;\n    for(int i =0; i < steps;i++)\n    {\n        float theta = getTheta(currentCoord, n);\n        vec2 normal = vec2(cos(theta), sin(theta));\n        lineKernel(s, currentCoord/iResolution.xy, normal);\n        vec4 tAverage;\n        for(int j = 0; j < 5; j++) {\n\t\t\ttAverage += vec4(s[j], 1.0);\n        }\n        average += tAverage/5.;\n        vec3 coolColor;\n        coolColor = s[0]+s[1]*2.-s[3]*2.-s[4];\n        linearity += vec4(coolColor,1.);\n        currentCoord += normal*hopDistance; \n    }\n    fragColor = vec4(texture(iChannel1, currentCoord/iResolution.xy).xyz, 1.0);\n    //if(length(linearity.xyz) > 4.) {\n\t//\tfragColor = vec4(0,0,0,1);\n    //} else {\n    //\tfragColor = linearity;\n    //}\n    fragColor=texture(iChannel2, fragCoord/iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float squareSize =10.;\n\nconst float lineDistance = 1.;\nconst float sobelStep = 1.;\nconst int size = 5;\nconst float sizeSquared = 64.;\nconst float hacky = 2.;\n","name":"Common","description":"","type":"common"}]}