{"ver":"0.1","info":{"id":"NdyBzz","date":"1657538508","viewed":127,"name":"Magic fractal box","username":"E_mc2","description":"Magic fractal box","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://iquilezles.org/articles/intersectors/\n\n\nvec3 lig = normalize(vec3(0.7,0.6,0.3));  // 光照方向\n\nconst vec3  ra = vec3(0.25);  // size of boxes\n\nint intMaxN = 10; //最大分形迭代次数\nbool solid[8];  // 8个单元格是否为一个正方体\n\nvec4 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxOrigin, vec3 boxSize)  // box\n{\n    ro -= boxOrigin;\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec4(-1.0); // no intersection\n    vec3 outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec4( tN, outNormal );\n}\n\nvec4 combine(in vec4 tnor1, in vec4 tnor2)  // 合并两次相交计算的结果\n{\n    if(tnor1.x<0.0)\n        return tnor2;\n    else\n    {\n        if(tnor2.x<0.0)\n        return tnor1;\n        else\n        {\n            if(tnor1.x<tnor2.x)\n                return tnor1;\n            else\n                return tnor2;\n        }\n    }\n}\n\nvec4 combine(in vec4 tnor1, in vec4 tnor2, in int id1, in int id2, out int id)  // 合并两次相交计算的结果\n{\n    if(tnor1.x<0.0)\n    {\n        id = id2;\n        return tnor2;\n    }\n    else\n    {\n        if(tnor2.x<0.0)\n        {\n            id = id1;\n            return tnor1;\n        }\n        else\n        {\n            if(tnor1.x<tnor2.x)\n            {\n                id = id1;\n                return tnor1;\n            }\n            else\n            {\n                id = id2;\n                return tnor2;\n            }\n        }\n    }\n}\n\nvec3 pattern(in vec3 p)\n{\n    vec3 col = vec3(1);\n    //col += 0.4*mod(round(mod(p.x, 1.0))+round(mod(p.y, 1.0))+round(mod(p.z, 1.0)), 2.0);\n    //col *= smoothstep(-1.0,-0.98,cos(p.x))*smoothstep(-1.0,-0.98,cos(p.y))*smoothstep(-1.0,-0.98,cos(p.z));\n    return col;\n}\n\nvec3 raytrace(in vec3 ro, in vec3 rd, vec3 background, vec3 lig)  // raytrace\n{\n    // shading/lighting\t\n    vec3 col = background;  // color\n    \n    \n    float f1 = sin(iTime*1.0);\n    float f2 = cos(iTime*1.0);\n    f1=f1*f1;\n    f2=f2*f2;\n    mat3 m = mat3(f2, 1, f1, f1, f2, 1, 1, f1, f2);\n    \n    // raytrace\n    vec4 tnor = vec4(-1);\n    vec4 tnor2;\n    int id = -1;\n    int i0, i1, i2, i3;\n    for(i0=0;i0<intMaxN;i0++)\n    {\n        for(i1=0;i1<2;i1++)\n            for(i2=0;i2<2;i2++)\n                for(i3=0;i3<2;i3++)\n                {\n                    tnor = combine(tnor, boxIntersection(ro, rd, vec3(i1, i2, i3)*0.5-0.25, ra), id, (i1<<2)+(i2<<1)+i3, id);\n                }\n        \n        if(tnor.x<0.)\n            break;\n        else\n        {\n            if(i0>0&&solid[id])\n            {\n                col = vec3(1);\n                break;\n            }\n            else\n            {\n                i1 = id>>2;\n                i2 = (id>>1)&1;\n                i3 = id&1;\n                vec3 boxP = vec3(i1, i2, i3)*0.5-0.25;\n                ro += tnor.x*rd*1.0;\n                ro -= boxP;\n                ro *= 2.0;\n                ro = m*ro;\n                rd = m*rd;\n                lig = m*lig;\n            }\n        }\n    }\n    if(i0==intMaxN)\n        col = vec3(0);\n    col *= pow(0.7, float(i0));\n\n    float t = tnor.x;\n    \n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = tnor.yzw;\n\n        // material\n        // col = pattern(pos*2.99);\n        // col = vec3(1);\n        col *= nor;\n\n        // lighting\n        vec3 hal = normalize(-rd+lig);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n\n        col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n        col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n    }\n\n    // gamma        \n    col = sqrt(col);\n    \n    return col;\n}\n\n#define AA 2\n\n//在55.03 s的时候，上端有一行像素有异常行为\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 初始化（这是非常重复的，但似乎没有别的解决方法）\n    solid[0] = true;\n    solid[3] = true;\n    solid[5] = true;\n    solid[6] = true;\n    \n    \n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.6, 1.0*sin(an) )*1.3;\n    vec3 ta = vec3( 0.0, -0.1, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n        for( int n=0; n<AA; n++ )\n        {\n            // pixel coordinates\n            vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n            vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n            #else    \n            vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n            #endif\n\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n            // raytrace\n            //vec3 background = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y; // background\n            vec3 background = vec3(0.01); // background\n            tot += raytrace(ro, rd, background, lig);\n            \n        #if AA>1\n        }\n        tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}