{"ver":"0.1","info":{"id":"ctG3Rz","date":"1683405400","viewed":181,"name":"sRGB gamut","username":"Nazlbit","description":"CIE xy chromaticity diagram showing the gamut of the sRGB color space. The actual colors you see depend on your display.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["srgb","gamut"],"hasliked":0,"parentid":"Dl3GWl","parentname":"Wavelength to Wide-gamut RGB"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://en.wikipedia.org/wiki/CIE_1931_color_space\n// https://en.wikipedia.org/wiki/SRGB\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html\n// https://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_E\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// https://bottosson.github.io/posts/gamutclipping/\n\nfloat g(const float x, const float a, const float b, const float c)\n{\n    float d = x - a;\n    return exp(-0.5 * d * d / ((x < a) ? (b * b) : (c * c)));\n}\n\nvec3 wl2xyz_CIE1931(const float w){\n    float x = 1.056 * g(w, 599.8, 37.9, 31.0) + 0.362 * g(w, 442.0, 16.0, 26.7) - 0.065 * g(w, 501.1, 20.4, 26.2);\n    float y = 0.821 * g(w, 568.8, 46.9, 40.5) + 0.286 * g(w, 530.9, 16.3, 31.1);\n    float z = 1.217 * g(w, 437.0, 11.8, 36.0) + 0.681 * g(w, 459.0, 26.0, 13.8);\n    return vec3(x,y,z);\n}\n\nconst mat3 E2D65_XYZ = mat3( 0.9531874, -0.0265906,  0.0238731,\n                            -0.0382467,  1.0288406,  0.0094060,\n                             0.0026068, -0.0030332,  1.0892565);\n\nconst mat3 XYZ2SRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                           -0.9692660, 1.8760108, 0.0415560,\n                           0.0556434, -0.2040259, 1.0572252);\n\nfloat linear2gamma(const float x)\n{\n    return x > 0.0031308 ? 1.055 * pow(x, 1.0/2.4) - 0.055 : 12.92 * x;\n}\n\nvec3 linear2gamma(const vec3 x)\n{\n    return vec3(linear2gamma(x.r), linear2gamma(x.g), linear2gamma(x.b));\n}\n\nbool grid(vec2 uv)\n{\n    const vec2 range = vec2(0.8, 0.9);\n    const float grid_step = 0.05;\n    const ivec2 num_steps = ivec2(range / grid_step) + 1;\n    if(uv.y >= 0.0 && uv.y <= range.y)\n    {\n        for(int i = 0; i < num_steps.x; ++i)\n        {\n            float line_pos = grid_step * float(i);\n            float d = (uv.x - line_pos) * iResolution.y;\n            if(d >= 0.0 && d < 1.0)\n            {\n                return true;\n            }\n        }\n    }\n    if(uv.x >= 0.0 && uv.x <= range.x)\n    {\n        for(int i = 0; i < num_steps.y; ++i)\n        {\n            float line_pos = grid_step * float(i);\n            float d = (uv.y - line_pos) * iResolution.y;\n            if(d >= 0.0 && d < 1.0)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvec2 xyz_xy(vec3 xyz)\n{\n    float sum = xyz.x + xyz.y + xyz.z;\n    return vec2(xyz.x / sum, xyz.y / sum);\n}\n\nbool inside_cie1931_color_space(vec2 uv)\n{\n    const int num_samples = 100;\n    const float visible_range_min = 440.0;\n    const float visible_range_max = 646.0;\n\n    vec2 prev_xy = xyz_xy(wl2xyz_CIE1931(visible_range_min));\n    int num = 0;\n    for(int i = 1; i < num_samples + 2; ++i)\n    {\n        float w = mix(visible_range_min, visible_range_max, float(i % (num_samples + 1)) / float(num_samples));\n        vec2 xy = xyz_xy(wl2xyz_CIE1931(w));\n        vec2 a = xy - prev_xy;\n        vec2 intersection = inverse(mat2(a.x, a.y, -1.0, 0.0)) * (uv - prev_xy);\n        if(intersection.x > 0.0 && intersection.x <= 1.0 && intersection.y > 0.0)\n        {\n            ++num;\n        }\n        \n        prev_xy = xy;\n    }\n\n    return num % 2 == 1 && num > 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0), 1.0);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv += vec2(0.4, 0.45);\n\n    vec3 xyz = vec3(uv.x / uv.y, 1.0, (1.0 - uv.x - uv.y) / uv.y);\n    xyz *= E2D65_XYZ;\n    vec3 srgb = xyz * XYZ2SRGB;\n\n    xyz.y /= (srgb.r + srgb.g + srgb.b);\n    xyz.x = xyz.y * uv.x / uv.y;\n    xyz.z = xyz.y * (1.0 - uv.x - uv.y) / uv.y;\n    \n    srgb = xyz * XYZ2SRGB;\n\n    if(srgb.x < 0.0 || srgb.y < 0.0 || srgb.z < 0.0)\n    {\n        if(grid(uv))\n        {\n            srgb = vec3(1.0);\n        }\n        else if(!inside_cie1931_color_space(uv))\n        {\n            srgb = vec3(0);\n        }\n        else\n        {\n            srgb = clamp(srgb, 0.0, 1.0) * 0.5;\n        }\n    }\n\n    srgb = linear2gamma(srgb);\n    fragColor = vec4(srgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}