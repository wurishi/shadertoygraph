{"ver":"0.1","info":{"id":"cddGzs","date":"1677704999","viewed":372,"name":"Flyby [462 Chars]","username":"Xor","description":"Based on [url=https://www.shadertoy.com/view/Ddt3z2]Cubic[/url].","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","ao","city","golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Flyby\" by @XorDev\n\n    Based on \"Cubic\": https://www.shadertoy.com/view/Ddt3z2\n    \n    -11 by FabriceNeyret2\n    \n    <512 Chars playlist: shadertoy.com/playlist/N3SyzR\n*/\n\n//Rotation matrix\n#define R mat2(cos(vec4(0,33,11,0)\n\n//Cube fractal distance function\nfloat D(vec3 p)\n{\n    float i = 2., d = p.y;\n    for(;i>.01; i*=.38)\n        p.xz = mod(p.xz,i*4.)-i-i,\n        d = min(d, length(clamp(p,-i,i)-p));\n    return d;\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Difference vector for normal computation \n    vec3 n = vec3(2,-2,2)/1e4,\n    //Resolution for scaling\n    r = iResolution,\n    //Camera position\n    p = vec3(iTime,2,1);\n    //Compute ray direction\n    r = vec3(I+I,r)-r;\n    //Rotate pitch\n    r.yz *= R+.9));\n    \n    //Variables for loops\n    float d = 1e-3, i=d;\n    \n    //Rotate yaw and raymarch\n    for(r.xz *= R+iTime*.1)); i++<1e2; p += r/length(r)*D(p));\n    \n    //Compute normals\n    for(n = D(p+n.xxy)*n.xxy+D(p+n)*n+D(p+n.yxx)*n.yxx+D(p+n.y)*n.y;\n    //AO loop\n        d<9.; d+=d)\n        //Compute AO at each scale\n        i *= D(p+n/length(n)*d)/d+1.;\n    \n    //Multiplicative average \n    O = pow(i/2e6,.2)+O*0.;\n}","name":"Image","description":"","type":"image"}]}