{"ver":"0.1","info":{"id":"tlyBDD","date":"1614332611","viewed":63,"name":"Raymarching - Infinite Space","username":"Victor000_1","description":"First raymarching test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ati"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    return mod(p+0.5 * c, c)-.5*c;  \n}\n\nfloat map(vec3 pos) \n{\n    \n    //pos = vec3(2*rot(time));\n    pos = opRep(pos,vec3(6));\n    \n    float world = sdOctahedron(pos, sin(iTime));\n\n    world = opSmoothUnion(world, sdSphere(pos, 0.5), 0.5);\n    \n    return world;\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float c = 0.; //si y'a contact, on aura la distance\n    int multiplier = 128;\n    \n    for(int i = 0; i<multiplier; i++)\n    {\n        float ray = map(ro + rd*c);\n        \n        if(ray < (0.0001*c))\n        {\n            return float (i)/(float(multiplier)/2.);\n        }\n        c+=ray;\n    } \n    return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    \n    float contact = castRay(ro ,rd); \n    \n    vec3 col = vec3(0.);\n    \n    if(contact == -1.){\n        col = vec3(0.);\n    }else{\n        col = vec3(1.-contact);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Première initialisation\n    float fov = 2.5; //fieldOfView\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Centrer la caméra\n    vec3 camPos = vec3(10.*rot(iTime/2.));\n    vec3 camTar = vec3(0);\n    \n    // Direction de la vue / du rayon\n    vec3 forward = normalize(camTar - camPos);\n    vec3 right = normalize(cross(vec3(0, -1, 0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up+ forward*fov);\n    \n    vec3 col = vec3(uv.x,uv.y,0.0);\n    col = render(camPos,viewDir);\n    fragColor = vec4(col, 1);\n    \n}","name":"Image","description":"","type":"image"}]}