{"ver":"0.1","info":{"id":"Mcs3WH","date":"1703100658","viewed":29,"name":"Corn","username":"BearKirb","description":"fasafs","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["a","f","f","f","s","s","asf","fsa","af","af","af","af","af","fs","fs","fa","fa","fas","saf","afaf","afa","afa","afs","afs","afs","fdfad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n  \n    // Output to screen\n    \n    fragColor = texture( iChannel0, uv);\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/0.8) );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SAMPLES 1\nfloat random (float s) {\nvec2 st=vec2(s,0.0);\n    return (fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123));\n}\nint Iterations=10;\nfloat DE(vec3 z)\n{\n\nfloat Scale=2.0;\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n    a1/=3.0;\n    a2/=3.0;\n    a3/=3.0;\n    a4/=3.0;\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < Iterations) {\n\t\t c = a1; dist = length(z-a1);\n\t        d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n\t\tz = Scale*z-c*(Scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(z) * pow(Scale, float(-n));\n}\nfloat Mand(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float Bailout=2.0;\n    float Power=8.0;\n    int Iterations = 3;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr-0.01;\n}\n\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\nfloat sdBox( vec3 p, vec3 b, vec3 l ,float r)\n{\np-=l;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdf(vec3 p){\n\nfloat f=sdBox(p,vec3(0.1,1.1,1.1),vec3(1.0,0.0,0.0),0.0);\nf=min(f,sdBox(p,vec3(0.1,1.1,1.1),vec3(-1.0,0.0,0.0),0.0));\nf=min(f,sdBox(p,vec3(1.1,0.1,1.1),vec3(0.0,1.0,0.0),0.0));\nf=min(f,sdBox(p,vec3(1.1,0.1,1.1),vec3(0.0,-1.0,0.0),0.0));\nf=min(f,sdBox(p,vec3(1.1,1.1,0.1),vec3(0.0,0.0,-1.0),0.0));\nf=min(f,sdBox(p,vec3(1.1,1.1,0.1),vec3(0.0,0.0,1.0),0.0));\nf=min(f,DE(p)-0.0008);\n\nreturn f;\n}\nvec3 sdfColor(vec3 p){\n\nfloat f=sdBox(p,vec3(0.1,1.1,1.1),vec3(1.0,0.0,0.0),0.0);\nvec3 color=vec3(0.0,0.5,0.0);\nif(sdBox(p,vec3(0.1,1.1,1.1),vec3(-1.0,0.0,0.0),0.0)<f){\ncolor=vec3(0.5,0.0,0.0);\nf=min(f,sdBox(p,vec3(0.1,1.1,1.1),vec3(-1.0,0.0,0.0),0.0));\n}\nif(sdBox(p,vec3(1.1,0.1,1.1),vec3(0.0,1.0,0.0),0.0)<f){\ncolor=vec3(0.3,0.3,0.3);\nf=min(f,sdBox(p,vec3(1.1,0.1,1.1),vec3(0.0,1.0,0.0),0.0));\n}\nif(sdBox(p,vec3(1.1,0.1,1.1),vec3(0.0,-1.0,0.0),0.0)<f){\ncolor=vec3(0.3,0.3,0.3);\nf=min(f,sdBox(p,vec3(1.1,0.1,1.1),vec3(0.0,-1.0,0.0),0.0));\n}\nif(sdBox(p,vec3(1.1,1.1,0.1),vec3(0.0,0.0,-1.0),0.0)<f){\ncolor=vec3(0.3,0.3,0.3);\nf=min(f,sdBox(p,vec3(1.1,1.1,0.1),vec3(0.0,0.0,-1.0),0.0));\n}\nif(sdBox(p,vec3(1.1,1.1,0.1),vec3(0.0,0.0,1.0),0.0)<f){\ncolor=vec3(0.3,0.3,0.3);\nf=min(f,sdBox(p,vec3(1.1,1.1,0.1),vec3(0.0,0.0,1.0),0.0));\n}\nif(DE(p)-0.0008<f){\ncolor=vec3(0.0,0.0,0.5);\nf=min(f,DE(p)-0.0008);\n}\n\nreturn color;\n}\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvoid Rotate( inout vec2 vect, vec2 angle )\n{\nvec3 vector = vec3(vect.x,0.0,vect.y);\n\tvect.yx = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvect.xy = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 calcNormal(vec3 p) {\nfloat EPSILON = 0.0001;\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n    for( int i=0; i<84; i++ )\n    {\n  \n        po -= (normalize(rd-ro) * sdf(po))/1.5;\n        minDist=min(minDist,sdf(po));\n  \n      \n      \n    }\n          if( sdf(po)-minDist<0.004){\n        if(distance(po,ro)<0.004){\n            return 1.0;\n            }else{\n            return 0.0;\n            }\n            }\n    return 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord)/iResolution.xy-iMouse.xy;\nvec4 startColor = texture( iChannel0, uv );\nuv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t((fragCoord+vec2(random(iTime),random(iTime+1.0)))-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t0.3 ) ); \n             \n    vec3 pos = vec3(0.0,0.0,-0.9); \n    \n  \n vec4 color = vec4(0.0,0.0,0.0,1.0);\n    \nvec2 angle = vec2(3.14+0.3,0.5);\n\tRotate(pos,angle);\n \n\tRotate(ray,angle);\n vec3 cameraPos = pos; \n vec3 normal;\n \n    \n  \nfor(int c=0;c<3;c++){\n    for(int x=0;x<80+c*2;x++){\n    float h=sdf(pos);\n    if(h<0.0001&&x>2){\n    break;\n    }else{\n\n    pos+=ray*h/1.5;\n    }\n    }\n       normal = calcNormal(pos);\n    \n   if(sdf(pos-normal/1000.0)>0.0001){\n   normal=-normal;\n   }\n   ray=normalize(reflect(ray,normal)+0.51*vec3(random(ray.x+iTime),random(ray.y+iTime),random(ray.z+iTime)));\n   \n     \n    vec3 light=vec3(cameraPos.x+random(normal.x+iTime)/100.0,cameraPos.y+random(normal.y+iTime+2.0)/100.0,cameraPos.z+random(normal.z+iTime+4.0)/100.0);\n   \n   vec3 ambient = sdfColor(pos)*0.2;\n    float d = dot(normal,normalize(light-pos));\n    vec3 lambert=ambient*d*18.0;\n   \n    color.rgb += (ambient/2.0+(lambert*shadow(pos,light)))/2.0/float(c+1);\n \n    }\n    vec4 accum = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    float samples = accum.a + float(SAMPLES);\n\tfragColor = vec4((accum.rgb * accum.a + color.rgb)/samples, samples);\n}","name":"Buffer A","description":"","type":"buffer"}]}