{"ver":"0.1","info":{"id":"dt3yD4","date":"1699201387","viewed":164,"name":"tunnel in menger","username":"nayk","description":"tunnel, menger, space, universe","likes":6,"published":1,"flags":1,"usePreview":0,"tags":["tunnel","space","menger","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Star Nest by Pablo RomÃ¡n Andrioli\n// copied from https://www.shadertoy.com/view/XlfGRj\n//\n// This content is under the MIT License.\n// (copied for API availability + VR)\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n\nconst float FAR = 50.0; // Far plane.\n\n// Used to identify individual scene objects. In this case, there are only three: The metal framework, the gold\n// and the timber.\nfloat objID = 0.; // Wood = 1., Metal = 2., Gold = 3..\n\n// Simple hash function.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n// Common formula for rounded squares, for all intended purposes.\nfloat lengthN(in vec2 p, in float n){ p = pow(abs(p), vec2(n)); return pow(p.x + p.y, 1.0/n); }\n\n\n// The camera path: There are a few spline setups on Shadertoy, but this one is a slight variation of\n// Otavio Good's spline setup in his \"Alien Beacon\" shader: https://www.shadertoy.com/view/ld2SzK\n//\n// Spline point markers (\"cp\" for camera point). The camera visits each point in succession, then loops\n// back to the first point, when complete, in order to repeat the process. In case it isn't obvious, each \n// point represents an open space juncture in the object that links to the previous and next point.\n// Of course, running a camera in a straight line between points wouldn't produce a smooth camera effect, \n// so we apply the Catmull-Rom equation to the line segment.\nvec3 cp[16];\n\nvoid setCamPath(){\n    \n    // The larger fractal object has nodes in a 4x4x4 grid.\n    // The smaller one in a 2x2x2 grid. The following points\n    // map a path to various open areas throughout the object.\n    const float sl = 2.*.96;\n    const float bl = 4.*.96;\n    \n    cp[0] = vec3(0, 0, 0);\n    cp[1] = vec3(0, 0, bl);\n    cp[2] = vec3(sl, 0, bl);\n    cp[3] = vec3(sl, 0, sl);\n    cp[4] = vec3(sl, sl, sl);\t\n    cp[5] = vec3(-sl, sl, sl);\t\n    cp[6] = vec3(-sl, 0, sl);\n    cp[7] = vec3(-sl, 0, 0);\n    \n    cp[8] = vec3(0, 0, 0);\t\n    cp[9] = vec3(0, 0, -bl);\n    cp[10] = vec3(0, bl, -bl);\t\n    cp[11] = vec3(-sl, bl, -bl);\n    cp[12] = vec3(-sl, 0, -bl);\n    cp[13] = vec3(-sl, 0, 0);\n    cp[14] = vec3(-sl, -sl, 0);\n    cp[15] = vec3(0, -sl, 0); \n    \n    // Tighening the radius a little, so that the camera doesn't hit the walls.\n    // I should probably hardcode this into the above... Done.\n    //for(int i=0; i<16; i++) cp[i] *= .96;\n    \n}\n\n// Standard Catmull-Rom equation. The equation takes in the line segment end points (p1 and p2), the\n// points on either side (p0 and p3), the current fractional distance (t) along the segment, then\n// returns the the smooth (cubic interpolated) position. The end result is a smooth transition \n// between points... Look up a diagram on the internet. That should make it clearer.\nvec3 Catmull(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    return (((-p0 + p1*3. - p2*3. + p3)*t*t*t + (p0*2. - p1*5. + p2*4. - p3)*t*t + (-p0 + p2)*t + p1*2.)*.5);\n   \n}\n \n// Camera path. Determine the segment number (segNum), and how far - timewise - we are along it (segTime).\n// Feed the segment, the appropriate adjoining segments, and the segment time into the Catmull-Rom\n// equation to produce a camera position. The process is pretty simple, once you get the hang of it.\nvec3 camPath(float t){\n    \n    const int aNum = 16;\n    \n    t = fract(t/float(aNum))*float(aNum);\t// Repeat every 16 time units.\n    \n    // Segment number. Range: [0, 15], in this case.\n    float segNum = floor(t);\n    // Segment portion. Analogous to how far we are alone the individual line segment. Range: [0, 1].\n    float segTime = t - segNum; \n    \n    \n    if (segNum == 0.) return Catmull(cp[aNum-1], cp[0], cp[1], cp[2], segTime); \n    \n    for(int i=1; i<aNum-2; i++){\n        if (segNum == float(i)) return Catmull(cp[i-1], cp[i], cp[i+1], cp[i+2], segTime); \n    }\n    \n    if (segNum == float(aNum-2)) return Catmull(cp[aNum-3], cp[aNum-2], cp[aNum-1], cp[0], segTime); \n    if (segNum == float(aNum-1)) return Catmull(cp[aNum-2], cp[aNum-1], cp[0], cp[1], segTime);\n\n    return vec3(0);\n    \n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// https://iquilezles.org/articles/smin\nfloat sminP( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\n\n// Creating the scene geometry.\n//\n// There are two intertwined fractal objects. One is a gold and timber lattice, spread out in a 4x4x4\n// grid. The second is some metallic tubing spread out over a 2x2x2 grid. Each are created by combining\n// repeat objects with various operations. All of it is pretty standard.\n//\n// The code is a little fused together, in order to save some cycles, but if you're interested in the \n// process, I have a \"Menger Tunnel\" example that's a little easier to decipher.\nfloat map(in vec3 q){\n\n    \n///////////\n\n    // The grey section. I have another Menger example, if you'd like to look into that more closely.\n    // Layer one.\n \tvec3 p = abs(fract(q/4.)*4. - 2.);\n \tfloat tube = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 4./3. - .015;// + .05;\n    \n\n    // Layer two.\n    p = abs(fract(q/2.)*2. - 1.);\n \t//d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);// + .025\n \ttube = max(tube, sminP(max(p.x, p.y), sminP(max(p.y, p.z), max(p.x, p.z), .05), .05) - 2./3.);// + .025\n   \n///////\n    // The gold and timber paneling.\n    //\n    // A bit of paneling, using a combination of repeat objects. We're doing it here in layer two, just\n    // to save an extra \"fract\" call. Very messy, but saves a few cycles... maybe.\n    \n    //float panel = sminP(length(p.xy),sminP(length(p.yz),length(p.xz), 0.25), 0.125)-0.45; // EQN 1\n    //float panel = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-0.5; // EQN 2\n    //float panel = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.5; // EQN 3\n    float panel = sminP(max(p.x, p.y),sminP(max(p.y, p.z),max(p.x, p.z), .125), .125)-0.5; // EQN 3\n    \n\n    // Gold strip. Probably not the best way to do this, but it gets the job done.\n    // Identifying the gold strip region, then edging it out a little... for whatever reason. :)\n    float strip = step(p.x, .75)*step(p.y, .75)*step(p.z, .75);\n    panel -= (strip)*.025;     \n    \n    // Timber bulge. Just another weird variation.\n    //float bulge = (max(max(p.x, p.y), p.z) - .55);//length(p)-1.;//\n    //panel -= bulge*(1.-step(p.x, .75)*step(p.y, .75)*step(p.z, .75))*bulge*.25;    \n    \n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(fract(q*2.)*.5 - .25);\n    float pan2 = min(p.x, min(p.y,p.z))-.05;    \n    \n    // Combining the two entities above.\n    panel = max(abs(panel), abs(pan2)) - .0425;    \n/////////\n    \n    // Layer three. 3D space is divided by three.\n    p = abs(fract(q*1.5)/1.5 - 1./3.);\n \ttube = max(tube, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 2./9. + .025); // + .025 \n\n\n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p = abs(fract(q*3.)/3. - 1./6.);\n \ttube = max(tube, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .035); //- .025 \n    \n\n    \n    \n    // Object ID: Equivalent to: if(tube<panel)objID=2; else objID = 1.; //etc.\n    //\n    // By the way, if you need to identify multiple objects, you're better off doing it in a seperate pass, \n    // after the raymarching function. Having multiple \"if\" statements in a distance field equation can \n    // slow things down considerably.\n        \n    //objID = 2. - step(tube, panel) + step(panel, tube)*(strip);\n    objID = 1.+ step(tube, panel) + step(panel, tube)*(strip)*2.;\n    //objID = 1. + step(panel, tube)*(strip) + step(tube, panel)*2.;\n    \n\n    return min(panel, tube);\n    \n    \n}\n\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    for(int i = 0; i < 92; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return t;\n}\n\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only 16 iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0.;\n    for(int i=0; i<16; i++){\n        float d = map(ro + rd*t);\n        if (d < .0025*(t*.25 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define PI 3.14159265359\n/*original  https://www.shadertoy.com/view/msKBzD  https://www.shadertoy.com/view/cltczN */\nmat2 rotate2d(float _angle){\n\treturn mat2(cos(_angle),-sin(_angle),\n\t\t\t\t\t\t\tsin(_angle),cos(_angle));\n}\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.000,1.000,0.000);\n    vec3 d = vec3(0.5,0.2,0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat SDF_Triangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)/sign(p.y);\n}\n\nfloat spiral(in vec2 p)\n{\n    float x = p.x*3.;\n    float m = min (fract (x), fract (3. -x)) ;\n    return smoothstep (-0.2, .5, m*.5+.2-p.y) ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    float speed2 = iTime*0.35 + 8.;\n    \n    // Initiate the camera path spline points. Kind of wasteful not making this global, but I wanted\n    // it self contained... for better or worse. I'm not really sure what the GPU would prefer.\n    setCamPath();\n\n    \n\t// Camera Setup.\n    vec3 ro = camPath(speed2); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(speed2 + .5);  // \"Look At\" position.\n    vec3 lp = camPath(speed2 + .5) + vec3(0, .25, 0); // Light position, somewhere near the moving camera.\n   \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n        // Unit direction ray.\n    vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    \n    // Raymarch the scene.\n    float t = trace(ro, rd);\n    \n    // Initialize the scene color.\n    vec3 col = vec3(0);\n    \n    // Scene hit, so color the pixel. Technically, the object should always be hit, so it's tempting to\n    // remove this entire branch... but I'll leave it, for now.\n    if(t<FAR){\n        \n        // This looks a little messy and haphazard, but it's really just some basic lighting, and application\n        // of the following material properties: Wood = 1., Metal = 2., Gold = 3..\n    \n        float ts = 1.;  // Texture scale.\n        \n        // Global object ID. It needs to be saved just after the raymarching equation, since other \"map\" calls,\n        // like normal calculations will give incorrect results. Found that out the hard way. :)\n        float saveObjID = objID; \n        \n        \n        vec3 pos = ro + rd*t; // Scene postion.\n        vec3 nor = calcNormal(pos); // Normal.\n        vec3 sNor = nor;\n        \n        \n        // Apply some subtle texture bump mapping to the panels and the metal tubing.\n        nor = texBump(iChannel0, pos*ts, nor, 0.002); // + step(saveObjID, 1.5)*0.002\n    \n        // Reflected ray. Note that the normal is only half bumped. It's fake, but it helps\n        // taking some of the warping effect off of the reflections.\n        vec3 ref = reflect(rd, normalize(sNor*.5 + nor*.5)); \n         \n        \n\t\tcol = tex3D(iChannel0, pos*ts, nor); // Texture pixel at the scene postion.\n        \n        \n        vec3  li = lp - pos; // Point light.\n        float lDist = max(length(li), .001); // Surface to light distance.\n        float atten = 1./(1.0 + lDist*0.125 + lDist*lDist*.05); // Light attenuation.\n        li /= lDist; // Normalizing the point light vector.\n        \n        float occ = calcAO( pos, nor ); // Occlusion.\n\t\t\n        float dif = clamp(dot(nor, li), 0.0, 1.0); // Diffuse.\n        dif = pow(dif, 4.)*2.;\n        float spe = pow(max(dot(reflect(-li, nor), -rd), 0.), 8.); // Object specular.\n        float spe2 = spe*spe; // Global specular.\n        \n        float refl = .35; // Reflection coefficient. Different for different materials.\n\n            \n\n        // Reflection color. Mostly fake.\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        float rt = refTrace(pos + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        float rSaveObjID = objID; // IDs change with reflection. Learned that the hard way. :)\n        vec3 rsp = pos + ref*rt; // Reflected surface hit point.\n        vec3 rsn = calcNormal(rsp); // Normal at the reflected surface. Too costly to bump reflections.\n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        vec3 rLi = lp-rsp;\n        float rlDist = max(length(rLi), 0.001);\n        rLi /= rlDist;\n        float rDiff = max(dot(rsn, rLi), 0.); // Diffuse light at \"rsp.\"\n        rDiff = pow(rDiff, 4.)*2.;\n        float rAtten = 1./(1. + rlDist*0.125 + rlDist*rlDist*.05);\n        \n        if(rSaveObjID>1.5 && rSaveObjID<2.5){\n            rCol = vec3(1)*dot(rCol, vec3(.299, .587, .114))*.7 + rCol*.15;//*.7+.2\n            //rDiff *= 1.35;\n        }\n        if(rSaveObjID>2.5){\n             //float rc = dot(rCol, vec3(.299, .587, .114));\n             vec3 rFire = pow(vec3(1.5, 1, 1)*rCol, vec3(8, 2, 1.5));//*.5+rc*.5;\n             rCol = min(mix(vec3(1.5, .9, .375), vec3(.75, .375, .3), rFire), 2.)*.5 + rCol;         \n        }\n        \n        rCol *= (rDiff + .35)*rAtten; // Reflected color. Not accurate, but close enough.         \n        \n        \n        \n        // Grey metal inner tubing.\n        if(saveObjID>1.5 && saveObjID<2.5){ \n\t\t\t\n            // Grey out the limestone wall color.\n            col = vec3(1)*dot(col, vec3(.299, .587, .114))*.7 + col*.15;\n            \n            refl = .5;\n            //dif *= 1.35;\n            //spe2 *= 1.35;\n            \n        }         \n        \n        // Gold trimming properties. More effort should probably be put in here.\n        // I could just write \"saveObjID == 3.,\" but I get a little paranoid where floats are concerned. :)\n        if(saveObjID>2.5){\n\n            // For the screen image, we're interested in the offset height and depth positions. Ie: pOffs.zy.\n            \n            // Pixelized dot pattern shade.\n            //float c = dot(col, vec3(.299, .587, .114));\n            \n            vec3 fire = pow(vec3(1.5, 1, 1)*col, vec3(8, 2, 1.5));//*.5+c*.5;\n            col = min(mix(vec3(1, .9, .375), vec3(.75, .375, .3), fire), 2.)*.5 + col;//\n            \n            refl = .65;\n            //dif *= 1.5;\n            //spe2 *= 1.5;\n            \n        }\n        \n     \n        // Combining everything together to produce the scene color.\n        col = col*(dif + .35  + vec3(.35, .45, .5)*spe) + vec3(.7, .9, 1)*spe2 + rCol*refl;\n        col *= occ*atten; // Applying occlusion.\n       \n        \n    }\n  vec2 st = vec2 (atan(uv.x, uv.y), length (uv)) ;\n    uv = vec2 (st.x / 6.2831+.5 - (-iTime + st.y), st.y);\n    float c = 0.0;\n    \n    float triangle = SDF_Triangle((fragCoord.xy-.5*iResolution.xy) / iResolution.y, .3);\n    \n    c = spiral(uv) * 0.5 * spiral(vec2(spiral(uv / 0.6), triangle));\n    \n    \n    c += triangle * 1.6;\n\n    \n    vec3 color = palette(length(st.y) + 1.4 + iTime*.4);\n    color *= c;\n    \n    \n    uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    c *= smoothstep(0.0, 0.05, length(uv));\n\n    color *= c;\n  float\n        t2=iTime*2.*((st.x+.5)/2.), \n        b=pow(1.-fract(st.y+st.x+t2),4.);\n\n    b=(b*.5)+step(1.-b,.05);\n    color += st.y * b*vec3(0.,.5,1.);\n\n  \n    \n    st.x=fract(2.*sin(8.*(ceil(st.x*384.)/128.)));\n    \n    // Applying some very slight fog in the distance. This is technically an inside scene...\n    // Or is it underground... Who cares, it's just a shader. :)\n    col = mix(min(col, 1.), vec3(0), 1.-exp(-t*t/FAR/FAR*20.));//smoothstep(0., FAR-20., t)\n    //col = mix(min(col, 1.), vec3(0), smoothstep(0., FAR-35., t));//smoothstep(0., FAR-20., t)\n    \n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n    \n\tvec3 from=vec3(1.,.5,0.5)+col+color;\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n}","name":"Image","description":"","type":"image"}]}