{"ver":"0.1","info":{"id":"dsGGWR","date":"1678377182","viewed":221,"name":"edge tangent flow(etf) cubemap","username":"lalaoopybee","description":"drag mouse around to view different angles!\n\nthis is my [url=https://www.shadertoy.com/view/dsd3zs]etf shader[/url] in action.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["mouse","cubemap","npr","lic","etf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//line integral convolution\n#define K 5//[3, 10]\n\n#define GETDIR(a) normalize(texture(iChannel0, a).xy)\n#define GETNOISE(a) texture(iChannel1, a).rgb\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //base color\n    vec2 uv=fragCoord/iResolution.xy;\n    fragColor=texture(iChannel0, uv);\n    \n    //lic\n    vec2 pt0=fragCoord+.5, pt=pt0;\n    vec2 dir0=GETDIR(uv), dir=dir0;\n    vec3 sum=vec3(0.);\n    for(int i=-K;i<=K;i++){\n        //which way are we going?\n        switch(sign(i)){\n            case -1://behind: step back\n                pt-=dir;\n                break;\n            case 0://middle: init for ahead\n                pt=pt0;\n                dir=dir0;\n                break;\n            case 1://ahead: step forward\n                pt+=dir;\n                break;\n        }\n        //sampling\n        vec2 ptUV=pt/iResolution.xy;\n        sum+=texture(iChannel2, ptUV).rgb;//noise\n        dir=normalize(texture(iChannel1, ptUV).xy);\n    }\n    \n    fragColor.rgb*=sum/float(K);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/XsjfDD\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //init image\n    vec2 mousePt=iMouse.xy;\n    if(iMouse.xy==vec2(0)) mousePt=.5*iResolution.xy;\n    \n    float rotX = (mousePt.x / iResolution.x) * 2. * PI;\n    float rotY = (mousePt.y / iResolution.y) * PI;\n    vec2 uv = 2.5 * (fragCoord.xy - .5 * iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uv.x * camR + uv.y * camU + camD);\n    //random noise prevents artifacting? (although etf wont be technically accurate)\n    //there should be a gaussian, but there arent enough passes.\n    float noise=hash12(fragCoord)*.5-.5;\n    fragColor = texture(iChannel0, dir)+noise*.1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//make structure tensor from partial derivative using sobel\nmat3 sobelX=mat3(\n    -1., 0., 1.,\n    -2., 0., 2.,\n    -1., 0., 1.\n);\n\nmat3 sobelY=mat3(\n    1., 2., 1.,\n    0., 0., 0.,\n    -1., -2., -1.\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec3 gradX=vec3(0.);\n    vec3 gradY=vec3(0.);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            vec2 offsetUV=vec2(i-1, j-1)/iResolution.xy;\n            vec3 col=texture(iChannel0, uv+offsetUV).rgb;\n            gradX+=sobelX[i][j]*col;\n            gradY+=sobelY[i][j]*col;\n        }\n    }\n    gradX*=.25;\n    gradY*=.25;\n    \n    float e=dot(gradX, gradX);\n    float f=dot(gradX, gradY);\n    float g=dot(gradY, gradY);\n    fragColor=vec4(e, f, g, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//blur structure tensor, calc eigenvectors. this is the etf.\n#define PI 3.1415927\n\n#define K 3\n\n#define SIGMA 1.4\n\nfloat gaussian(vec2 pos){\n    float left=1./(2.*PI*SIGMA*SIGMA);\n    float right=exp(-dot(pos, pos)/(2.*SIGMA*SIGMA));\n    return left*right;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 sum=vec4(0.);\n    for(int i=0;i<2*K+1;i++){\n        for(int j=0;j<2*K+1;j++){\n            vec2 offset=vec2(i-K, j-K);\n            float weight=gaussian(offset);\n            \n            vec2 offsetUV=offset/iResolution.xy;\n            vec3 efg=texture(iChannel0, uv+offsetUV).rgb;\n            sum+=vec4(efg, 1.)*weight;\n        }\n    }\n    vec3 efg=sum.rgb/sum.a;\n    \n    //calc eigenvalues\n    float e=efg.x, f=efg.y, g=efg.z;\n    float sqeg24f2=sqrt(pow(e-g, 2.)+4.*f*f);\n    float l1=(e+g+sqeg24f2)*.5;\n    float l2=(e+g-sqeg24f2)*.5;\n    \n    //calc eigenvectors\n    vec2 v1=vec2(f, l1-e);//maximal, gradient\n    vec2 v2=vec2(l2-g, f);//minimal, tangent\n    fragColor=vec4(v1, v2);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//why not\n#define PI 3.1415927\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//make sufficiently sized noise texture\n\n//if you want grayscale, make amt 0.\n#define AMT 100.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor=vec4(\n        hash12(fragCoord-AMT),\n        hash12(fragCoord),\n        hash12(fragCoord+AMT), \n        1.\n    );\n}","name":"Buffer D","description":"","type":"buffer"}]}