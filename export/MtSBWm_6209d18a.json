{"ver":"0.1","info":{"id":"MtSBWm","date":"1515976494","viewed":190,"name":"RaymarcherBounce02","username":"ramagosula","description":"Third iteration of raymarcher.\nXY coordinate moves camera. Also has other context-dependent effects for debugging.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 100;\nconst float EPSILON = 0.001;\nconst float MARCH_DIST = 5000.0;\nconst float PI = 3.1415926535897932;\n\n//colors\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 BGCOLOR = WHITE;\n\nvec3 debugColor;\n\n//utility\nfloat noiseSeed = 0.0;\n\n//noiseFromTex\nfloat noiseFromTex(float seed)\n{\n \treturn texture(iChannel0,vec2(mod(seed,256.0),seed/256.0)).x;  \n}\n\nfloat noiseFromTexSeeded()\n{\n    noiseSeed = noiseFromTex(noiseSeed);\n    return noiseSeed;\n}\n\n//CREDIT Dave_Hoskins-----------------------------------\n#define HASHSCALE1 .1031\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//------------------------------------------------------\n\nmat4 xRotate(float a)\n{\n\treturn mat4(\n        vec4(1,0,0,0),\n        vec4(0,cos(a),-sin(a),0),\n        vec4(0,sin(a),cos(a),0),\n        vec4(0,0,0,1)\n        );\n}\nmat4 yRotate(float a)\n{\n\treturn mat4(\n        vec4(cos(a),0,-sin(a),0),\n        vec4(0,1,0,0),\n        vec4(sin(a),0,cos(a),0),\n        vec4(0,0,0,1)\n        );\n}\nmat4 zRotate(float a)\n{\n\treturn mat4(\n        vec4(cos(a),-sin(a),0,0),\n        vec4(sin(a),cos(a),0,0),\n        vec4(0,0,1,0),\n        vec4(0,0,0,1)\n        );\n}\n\n//lights\nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n    \nconst int NUM_LIGHTS = 2;\nPointLight sceneLights[NUM_LIGHTS];\n    \n//CAMERA:\nfloat CAMFOV = 90.0;\n\n//signed distance fields\n\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA,distB);\n}\n\nfloat unionSDF(float distA, float distB)\n{\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA,-distB);\n}\n\nfloat sphereSDF( vec3 p )\n{\n    return length(p) - 1.0;\n}\n\nfloat swirlSDF( vec3 p );\n\nfloat halfWorldSDF( vec3 p, vec3 normal, float d)\n{\n\treturn dot(p,normal) - d;\n}\n\nfloat cubeSDF(vec3 p )\n{\n\tfloat x = max(\n        p.x - 1.0\n        ,\n        -p.x - 1.0\n        );\n    \n    float y = max(\n        p.y - 1.0\n        ,\n        -p.y - 1.0\n        );\n    \n    float z = max(\n        p.z - 1.0\n        ,\n        -p.z - 1.0\n        );\n    \n    \n    return max(max(x,y),z);\n}\n\nfloat iterativeFractal( vec3 p, int iterations )\n{\n    float dist = MARCH_DIST;\n    vec3 translate = vec3(0,1,0);\n    vec3 translateX = vec3(0.5,0,0);\n    vec3 translateXN = vec3(-0.5,0,0);\n    float scale = 0.80;\n    float scaleFactor = 0.7;\n    \n\tfor(int i = 0; i < iterations; i++)\n    {\n        dist = unionSDF(dist,sphereSDF( (p - float(i)*translateX)/scale )*scale );\t   \n        dist = unionSDF(dist,cubeSDF( (p - float(i)*translateXN)/scale )*scale );\t   \n        dist = unionSDF(dist,cubeSDF( (p - float(i)*translate)/scale )*scale );\t\n           \n        scale *= scaleFactor;\n        translateX = vec3(yRotate(0.1)*vec4(translateX,1));\n        translateXN = vec3(yRotate(0.1)*vec4(translateXN,1));\n    }\n    \n    return dist;\n}\n\nfloat randomShapesSDF( vec3 p)\n{\n    float dist = MARCH_DIST;\n    for(int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            dist = unionSDF(sphereSDF(p + 2.1*vec3(i,j,(hash11(float(i + 10*j))+-0.5)*10.0) + vec3(-5.0,-5.0,0)),dist);\n        }\n    }\n    \n    return dist;\n}\n\nfloat icosaBallSDF( vec3 p)\n{\n float dist = MARCH_DIST;\n    \n    float r = 1.0;\n    \n    float edgeLength = 1.0/sin(2.0*PI/5.0);\n    float sphereScale = edgeLength* 1.0/sqrt(3.0);\n    //float sphereScale = 1.0;\n    \n\tvec4 offset = vec4(1,0,0,0);\n    for(int i = 0; i < 10; i++)\n    {\n\t\toffset = vec4(1,0,0,0);\n        float upOrDown = mod(float(i),2.0)*2.0 - 1.0;\n\t\toffset = zRotate(upOrDown*atan(0.5))*offset;\n        offset = yRotate(float(i)* 36.0 * PI /180.0)*offset;\n        dist = unionSDF(dist,sphereSDF((p - offset.xyz)/sphereScale )*sphereScale );\n    }\n    \n    dist = unionSDF(dist,sphereSDF((p - vec3(0,1,0))/sphereScale )*sphereScale );\n    dist = unionSDF(dist,sphereSDF((p - vec3(0,-1,0))/sphereScale )*sphereScale );\n    \n    return dist;   \n}\n\nfloat funBallSDF( vec3 p)\n{\n    float dist = MARCH_DIST;\n    \n    float sphereScale = 2.0*iMouse.x/iResolution.x;\n    dist = unionSDF(dist,sphereSDF(p/sphereScale)*sphereScale);\n    \n    dist = differenceSDF(dist,icosaBallSDF(p));\n    \n    return dist; \n}\n\nfloat wolframSDF( vec3 p)\n{\n    float dist = MARCH_DIST;\n    \n    float sphereScale = cos(PI/5.0);\n    \n    dist = unionSDF(dist,sphereSDF(p/sphereScale)*sphereScale);\n    \n    dist = differenceSDF(dist,icosaBallSDF(p));\n    \n    return dist;\n}\n\nfloat sceneSDF( vec3 p )\n{\n    float dist = MARCH_DIST;\n    \n    //dist = unionSDF(randomShapesSDF(p),dist);\n    //dist = unionSDF(dist,intersectSDF(sphereSDF(p),cubeSDF(p/0.8)*0.8));\n    //dist = unionSDF(dist,differenceSDF(cubeSDF(p/(0.8))*0.8,sphereSDF(p + vec3(2,0,0)*sin(iTime))));\n    //dist = unionSDF(dist,iterativeFractal(p,9));\n    //dist = unionSDF(dist, wolframSDF(p));\n    dist = unionSDF(dist, funBallSDF(p));\n    \n    //add a floor\n    //dist = unionSDF(dist,halfWorldSDF(p,vec3(0,1,0),-15.0));\n    \n    return dist;\n}\n\nfloat traceDist( vec3 eye, vec3 viewRayDir, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n\t\tfloat dist = sceneSDF(eye + depth*viewRayDir);\n        if(dist < EPSILON)\n        {\n            //we're inside the scene surface\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if(depth >= end)\n        {\n         \t//gone too far; give up;\n            return end;\n        }\n    }\n}\n\nvec3 estimateNormal(vec3 p) {\n    //EPSILON\n    const float epsilon = 0.01;\n    \n    //vec3 offset = p;\n    //vec3 normal;\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + epsilon, p.y, p.z)) - sceneSDF(vec3(p.x - epsilon, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + epsilon, p.z)) - sceneSDF(vec3(p.x, p.y - epsilon, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + epsilon)) - sceneSDF(vec3(p.x, p.y, p.z - epsilon))\n    ));\n    \n    //attempt to optimize: didn't work\n    \n    //offset.x += epsilon;\n    //normal.x += sceneSDF(offset);\n    //offset.x -= epsilon*2.0;\n    //normal.x -= sceneSDF(offset);\n    \n    //offset.x = p.x;\n    \n    //offset.y += epsilon;\n    //normal.y += sceneSDF(offset);\n    //offset.y -= epsilon*2.0;\n    //normal.y -= sceneSDF(offset);\n    \n    //offset.y = p.y;\n    \n    //offset.z += epsilon;\n    //normal.z += sceneSDF(offset);\n    //offset.z -= epsilon*2.0;\n    //normal.z -= sceneSDF(offset);\n       \n    \n    //return normalize(normal);\n}\n\nvec3 phongColor( vec3 eye, vec3 pos, PointLight lights[NUM_LIGHTS], int bounces )\n{ \n    vec3 color;\n    \n    //ambient \n    vec3 ambientColor = vec3(1,1,0.3);\n    float ambientIntensity = 0.00101;\n    \n    //ambient\n    color += ambientColor*ambientIntensity;\n    \n\tvec3 normal = estimateNormal(pos);\n    \n    vec3 toCamera = normalize(eye - pos);\n    \n    //bounce attenuation should be material-based\n    float bouncePercent = 0.2;\n    float attenuation = 1.0;\n    \n\tfor(int b = bounces; b > 0; b--)\n    {\n        vec3 nextColor;\n        for(int i = 0; i < NUM_LIGHTS; i++)\n        {               \n            float shadow = 1.0;\n            \n            //hard shadow\n            vec3 toLight = lights[i].pos- pos;\n            float lightLength = length(toLight);\n            if((traceDist(pos,normalize(toLight),0.1,lightLength) < lightLength ))\n            {\n                shadow = 0.0;\n            }\n\n            //diffuse\n            nextColor += clamp(dot(normal,normalize(lights[i].pos- pos))*lights[i].color*lights[i].intensity*shadow,0.0,1.0);\n\n            //specular \n            float ks = 0.9;\n            float a = 9.0;\n            //note specular properties should be material based\n\n            nextColor += shadow*lights[i].intensity*ks*pow(clamp(dot(reflect(-normalize(lights[i].pos- pos),normal),toCamera),0.0,1.0),a);            \n        }\n                \t\n            color += nextColor*attenuation;\n            \n            //now perform bounce\n            attenuation *= bouncePercent;\n\n\t\t\tvec3 bounceRay = reflect(normalize(pos-eye),normal);\n            eye = pos;\n            float dist = traceDist(eye,bounceRay,0.1,MARCH_DIST);\n    \n            if((abs(MARCH_DIST-dist) < EPSILON) )\n            {\n                b = 0;//early out if nothing found\n            }\n            pos = eye + dist*bounceRay;\n            normal = estimateNormal(pos);\n    \t\ttoCamera = normalize(eye - pos);\n    }\n    \n\n    \n    return clamp(color,0.0,1.0);\n}\n\nvec3 getViewRayFromCamera( vec2 uv )\n{\n    vec2 camdimensions = normalize(iResolution.xy);\n\n\tvec3 dir;\n    dir.z = 0.5/(tan((CAMFOV*0.5)*PI/180.0));\n    dir.xy = uv * camdimensions;\n    \n    return normalize(dir);\n}\n\nmat4 viewMatrix( vec3 eye, vec3 focus, vec3 up)\n{\n \tvec3 f = -normalize(focus - eye);\n    vec3 s = normalize(cross(f,up));\n    vec3 u = cross(s,f);\n    return mat4(\n        vec4(s,0.0),\n        vec4(u,0.0),\n        vec4(-f,0.0),\n        vec4(0.0,0.0,0.0,1)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenPercent = (vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y) - vec2(0.5,0.5));\n    debugColor = vec3(screenPercent,0);\n    //Perform raymarching\n    \n    //Camera    \n    float distanceFromCenter = 4.0;\n    vec3 eyePos = vec3(0,0,-1)*distanceFromCenter;\n    vec3 eye = vec3((yRotate(-2.0*PI*screenPercent.x)*xRotate(-PI*screenPercent.y)*vec4(eyePos,1.0)).xyz);\n    \n    mat4 viewMat = viewMatrix(eye,vec3(0,0,0),vec3(0,1,0));//camera transform\n    vec3 viewRayDir = getViewRayFromCamera( uv - vec2(0.5,0.5) );\n    viewRayDir = vec3((viewMat*(vec4(viewRayDir,0.0))).xyz);\n\n    float rayStart = 0.000;\n    float rayEnd = MARCH_DIST;\n    \n    //Lights\n    \n    //Light1\n    sceneLights[0].pos = vec3(11.2,11.2,-1.6 - 15.0) + (screenPercent.y - 0.9);\n    sceneLights[0].color = vec3(0.1,0.7,0.8);\n    sceneLights[0].intensity = 0.8;\n    \n    //Light2\n    sceneLights[1].pos = vec3(-13.2,0.5,-1.6) + (screenPercent.y - 1.9);\n    sceneLights[1].color = vec3(0.8,0.2,0.2);\n    sceneLights[1].intensity = 0.2;\n    \n    vec3 color = BGCOLOR;  \n    \n    float dist = traceDist(eye,viewRayDir,rayStart,rayEnd);\n    \n    if(!((rayEnd-dist) < EPSILON) )\n    {\n     \tcolor = phongColor( eye, eye + dist*viewRayDir, sceneLights, 2);\n    }\n\n    //debugColor.x = clamp(traceDist(eye,viewRayDir,rayStart,rayEnd)/30.0,0.0,1.0);\n\n\tfragColor = vec4(color,1.0);\n    //fragColor = vec4(debugColor,1.0);\n}\n","name":"Image","description":"","type":"image"}]}