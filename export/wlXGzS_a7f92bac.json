{"ver":"0.1","info":{"id":"wlXGzS","date":"1556660523","viewed":229,"name":"Edge Detection Experiments TRN","username":"toridango","description":"Experiments with edge detection using the Sobel operator","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["sobel","edgedetection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI = 3.14159265358979;\nuniform sampler2D sampler;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.0 * iResolution.xy) / iResolution.xy;\n\n    // increasing the nominator makes the image blurry\n    vec2 inv = 1.0 / iResolution.xy;\n    vec2 sampleOffsets[8];\n\n\t// | 0 | 1 | 2 |\n\t// | 3 | X | 4 |\n\t// | 5 | 6 | 7 |\n    sampleOffsets[0] = uv + vec2(-inv.x, -inv.y);\n    sampleOffsets[1] = uv + vec2(   0.0, -inv.y);\n    sampleOffsets[2] = uv + vec2( inv.x, -inv.y);\n    \n    sampleOffsets[3] = uv + vec2(-inv.x,    0.0);\n    sampleOffsets[4] = uv + vec2( inv.x,\t0.0);\n    \n    sampleOffsets[5] = uv + vec2(-inv.x,  inv.y);\n    sampleOffsets[6] = uv + vec2(   0.0,  inv.y);\n    sampleOffsets[7] = uv + vec2( inv.x,  inv.y);\n    \n    vec4 colour = vec4(0.0);\n    vec4 cMatrix[9];\n    cMatrix[0] = texture(iChannel0, sampleOffsets[0]);\n\tcMatrix[1] = texture(iChannel0, sampleOffsets[1]);\n\tcMatrix[2] = texture(iChannel0, sampleOffsets[2]);\n            \n    cMatrix[3] = texture(iChannel0, sampleOffsets[3]);\n    cMatrix[4] = texture(iChannel0, uv);\n    cMatrix[5] = texture(iChannel0, sampleOffsets[4]);\n            \n    cMatrix[6] = texture(iChannel0, sampleOffsets[5]);\n    cMatrix[7] = texture(iChannel0, sampleOffsets[6]);\n    cMatrix[8] = texture(iChannel0, sampleOffsets[7]);\n\n    float greyS[9];\n    float bnw[9];\n    float threshold = 0.5;\n\t\n    for (int i = 0; i < 9; ++i)\n    {\n        greyS[i] = (cMatrix[i].x + cMatrix[i].y + cMatrix[i].z) / 3.0;\n        if (greyS[i] > threshold)\n            bnw[i] = 1.0;\n        else\n            bnw[i] = 0.0;\n    }\n\t\n    mat3 vKernel;\n    vKernel[0] = vec3(-1.0,  0.0,  1.0);\n\tvKernel[1] = vec3(-2.0,  0.0,  2.0);\n\tvKernel[2] = vec3(-1.0,  0.0,  1.0);\n    \n\t\n\n    mat3 hKernel;\n    hKernel[0] = vec3(-1.0, -2.0, -1.0);\n\thKernel[1] = vec3( 0.0,  0.0,  0.0);\n\thKernel[2] = vec3( 1.0,  2.0,  1.0);\n\n\t\n\n    bool greyscale = true;\n    if (greyscale)\n    {\n        \n        float d = 0.0;\n        float q = 0.0;\n        \n\t\tfor (int i = 0; i < 9; ++i)\n\t\t{\n\t\t\td += greyS[i] * hKernel[int(floor(float(i)/3.0))][int(mod(float(i),3.0))];\n\t\t\tq += greyS[i] * vKernel[int(floor(float(i)/3.0))][int(mod(float(i),3.0))];\n\t\t}\n\t\tfloat g = pow(pow(d, 2.0) + pow(q, 2.0), 0.5);\n        \n\n\t\t//g = smoothstep(0.4, 0.6, g);\n\t\tg = smoothstep(0.1, 0.9, g);\n        \n        colour = vec4(vec3(g), 1.0);;\n    }\n    else\n    {\n        \n        vec4 h = vec4(0.0);\n        vec4 v = vec4(0.0);\n        \n        for (int i = 0; i < 9; ++i)\n        {\n            h += cMatrix[i] * hKernel[int(floor(float(i)/3.0))][int(mod(float(i),3.0))];\n            v += cMatrix[i] * vKernel[int(floor(float(i)/3.0))][int(mod(float(i),3.0))];\n        }\n        colour = pow(pow(h, vec4(2.0)) + pow(v, vec4(2.0)), vec4(0.5));\n        colour = smoothstep(0.4, 0.6, colour);\n\n    }\n\n    fragColor = colour;\n}\n","name":"Image","description":"","type":"image"}]}