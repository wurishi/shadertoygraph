{"ver":"0.1","info":{"id":"7sycWD","date":"1654866081","viewed":122,"name":"Snake Nest","username":"sayo","description":"inspired by truchet tiles","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n#define PI 3.14159265\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n  float s=sin(a), c=cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n  p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  float a = atan(p.x/p.z);\n  float r = (cos(a*40.0+T*10.) + 1.0) / 2.0 * t.y * 0.12;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y+r;\n}\n\nfloat Hash31(vec3 p) {\n  return fract(sin(dot(p,vec3(21.221,49.122,80.121))*29.2491));\n}\n\nfloat GetDist(vec3 p) {\n  // repetition\n  float c = 2.;\n  vec3 fp = mod(p+0.5*c,c)-0.5*c;\n  vec3 ip = floor((p+0.5*c)/c);\n  float rand = Hash31(ip);\n  float flip = fract(rand*219.21)<.5 ? 1. : -1.;\n\n  fp.xz *= Rot(PI*0.5*floor(rand*4.));\n  fp.x *= flip;\n  // fp.xz *= Rot(PI*0.5);\n  \n  float d1 = sdTorus(fp-vec3(c*0.5,0,c*0.5), vec2(c*0.5, c*0.1));\n\n  fp.xz *= Rot(PI);\n  fp.xy *= Rot(PI*0.5);\n  float d2 = sdTorus(fp-vec3(c*0.5,0,c*0.5), vec2(c*0.5, c*0.1));\n\n  fp.xz *= Rot(PI);\n  fp.zy *= Rot(PI*0.5);\n  float d3 = sdTorus(fp-vec3(c*0.5,0,-c*0.5), vec2(c*0.5, c*0.1));\n  \n  float d = min(d1,d2);\n  d = min(d,d3);\n\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n  for(int i=0; i<MAX_STEPS; i++) {\n    vec3 p = ro + rd*dO;\n    float dS = GetDist(p);\n    dO += dS;\n    if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n  }\n  \n  return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    GetDist(p-e.xyy),\n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n  \n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l-p),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i);\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  \n  vec3 ro = vec3(0, 0, -3);\n  ro.yz *= Rot(sin(T*0.5)*1.0);\n  ro.zx *= Rot(T*0.4);\\\n  vec3 lookAt = vec3(-10.*sin(T*.2), 0, -10.*cos(T*.1));\n  \n  vec3 rd = GetRayDir(uv, ro, lookAt, 1.);\n  vec3 col = vec3(0);\n  \n  float d = RayMarch(ro, rd);\n\n  if(d<MAX_DIST) {\n    vec3 p = ro + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n        \n    float spec = pow(max(0., r.y), 100.);\n    float dif1 = max(0.,dot(n, normalize(vec3(1,2,3))));\n    float dif2 = max(0.,dot(n, normalize(vec3(-1,5,-1))));\n    vec3 difCol1 = dif1 * vec3(.1, 0., .8);\n    vec3 difCol2 = dif2 * vec3(0., 2., 0.);\n    vec3 lightCol = vec3(0.0, 0.03, 0.07) + (difCol1 + difCol2) * exp(-d*d/100.);\n    col = lightCol * vec3(1.) + spec * exp(-d*d/100.);\n  }\n  \n  col = pow(col, vec3(.4545));\t// gamma correction\n  // col *= exp(-d*d/300.);\n  \n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}