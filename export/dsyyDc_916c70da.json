{"ver":"0.1","info":{"id":"dsyyDc","date":"1696710178","viewed":46,"name":"shp_0ts-lerp","username":"alesteba","description":"interpolating stuff","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    \n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x) - r;\n    \n    p.y = p.y + r/k;\n    \n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    \n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    \n    return -length(p)*sign(p.y);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat shape(vec2 st, float radius) {\n\n    float r = length(st);\n    float a = atan(st.y,st.x);\n\n    float f = radius;\n    \n    //m += noise(st+iTime*0.1)*.1;\n    f += noise(st+iTime*.2)*.1;\n    f += (sin(a*50.)*.01);\n    // done\n    \n    // returnin the shape: \n    //return 1.-smoothstep(f,f+0.007,r);\n    return length(st) - f;\n}\n\nint binarySearch(float[4] nums,float searchnum ){\n\n    int low = 0;\n    int high = 4 - 1;\n    int mid = (low + high) / 2;\n    \n    while(low < high){\n        if(nums[mid] < searchnum){\n            if(nums[mid + 1] > searchnum){\n                return mid;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        else{\n            high = mid - 1;\n        }\n        mid = (low + high) / 2;\n    }\n    \n    return mid;\n}\n\n\nfloat lerp (float x0, float x1, float y0, float y1, float x)\n{\n    float d = x1 - x0;\n    \n    if (d == 0.0)\n        return (y0 + y1) / 2.0;\n        \n    return y0 + ( (x - x0) * (y1 - y0) ) / d;\n}\n\nfloat piecewise_lerp (float[4] Xs, float[4] Ys, float x)\n{\n    int index = int(binarySearch(Xs, x));\n\n    return lerp\n    (\n        Xs[index ], Xs[index+1],\n        Ys[index ], Ys[index+1],\n        x\n    );\n}\n\nfloat pulse(float time) {\n\n    float pi = 3.14;\n    float frequency = 0.1;\n    return 0.5*(1.0+sin(2.0 * pi * frequency * time));\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n// noise to shapes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.14159265359;\n    \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float amount = (sin(iTime));\n    \n    float circle = sdCircle(uv,0.5);\n    float square = sdBox(uv,vec2(0.5));\n    float noise = shape(uv, 0.5);\n       \n    uv = scale( vec2(sin(iTime)+2.) ) * uv;\n    uv = rotate2d( amount ) * uv;\n    float triangle = sdEquilateralTriangle(uv, 0.5);\n    \n    //float pulse = abs(sin(iTime));\n    float pulse = pulse(iTime);\n    \n    float x[4]=float[](0.0,0.25,0.75, 1.0); \n    float y[4]=float[](circle,triangle,square,noise); \n    \n    float combination = piecewise_lerp(x,y,pulse);\n\n    vec3 col = mix(vec3(0.0), vec3(1.0), 1.0-smoothstep(0.0,4./iResolution.y,abs(combination)) );\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}