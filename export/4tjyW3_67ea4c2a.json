{"ver":"0.1","info":{"id":"4tjyW3","date":"1510354078","viewed":694,"name":"Test : Bitwise Arithmetic","username":"newshorts","description":"To test arithmetic bitmask/shift left/right for webgl 1.0, since it doesn't support bitwise operations","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bitmask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO 0\n#define ONE 1\n\n// NOTE: this is pure confirmation bias, hasn't been tested, may cause late nights :)\n\n// Collection of functions designed to help packing/unpacking rgba values from/to textures\n// create a bitmask (bitwise &)\n// a is int to mask\n// b is the bitmask e.g. (0b00001111 = 15)\nint bitmask(int a, int b) {\n    int result = 0;\n    int byteVal = 1;\n    int zero = int(0);\n    int two = int(2);\n    \n    // NOTE: safari hated while loops for some reason\n    for(int i = ONE; i > ZERO; i++) {\n        if(a > ZERO || b > ZERO) {\n            // do nothing\n        } else {\n        \tbreak;\n        }\n        \n        // using mod() for safari\n        //if(a % two != zero && b % two != zero) {\n        if(int(mod(float(a), float(two))) != zero && int(mod(float(b),float(two))) != zero) {\n            result += byteVal;\n        }\n        a = int(floor(float(a) * 0.5));\n        b = int(floor(float(b) * 0.5));\n        byteVal *= two;\n    }\n    return result;\n}\n\n// create a join (bitwise |)\n// a is left join\n// b is right join\nint bitjoin(int a, int b) {\n    int byteVal = 1;\n    int result = 0;\n    int zero = int(0);\n    int two = int(2);\n    //while ((a > zero || b > zero) && true) {\n    for(int i = ONE; i > ZERO; i++) {\n        if(a > ZERO || b > ZERO) {\n            // do nothing\n        } else {\n        \tbreak;\n        }\n    \n       \tif (int(mod(float(a), float(two))) > zero || int(mod(float(b),float(two))) > zero) { \n            result += byteVal; \n        }\n        a = int(floor(float(a) * 0.5));\n        b = int(floor(float(b) * 0.5));\n        byteVal *= two;\n    }\n    return result;\n}\n\n// NOTE: the bitwise shift functions are incomplete \n// and don't account for sign. You've been warned :O\n\n// bitwise shift x to the left n spaces (bitwise <<)\n// x is int to shift\n// n is number of \"shifts\" or spaces to shift left\nint shiftleft(int x, int n) {\n\treturn int(float(x) * pow(2.0,float(n)));\n}\n\n// bitwise shift x to the right n spaces (bitwise >>)\n// x is int to shift\n// n is number of \"shifts\" or spaces to shift right\nint shiftright(int x, int n) {\n\treturn int(floor(float(x) / pow(2.0,float(n))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n\tint result = bitmask(95, 101); \n    int leftresult = shiftleft(101,4);\n    int rightresult = shiftright(101,4);\n    int joinresult = bitjoin(138,22);\n    \n    if(result == 69 && leftresult == 1616 && rightresult == 6 && joinresult == 158) {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n    \n\tfragColor = vec4(col,1.0); // green = right, red = wrong\n}","name":"Image","description":"","type":"image"}]}