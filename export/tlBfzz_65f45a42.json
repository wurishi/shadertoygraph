{"ver":"0.1","info":{"id":"tlBfzz","date":"1614075799","viewed":85,"name":"Fyrecean Ray Tracer","username":"Fyrecean","description":"A simple ray sphere ray tracer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define far 1000.\n#define bg vec3(.1,.1,.1)\n#define n 4\n\nstruct Hit {\n    float t;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 center;\n    float rad;\n    vec3 color;\n};\n\nstruct Light {\n    vec3 dir;\n};\n\n// Create direcitonal light\nLight light = Light(normalize(vec3(1.,-0.2,1.)));\n\n// Find the intersection between a ray and a sphere\nHit intersectSphere(Sphere sphere, Ray ray) {\n    vec3 origin = ray.origin - sphere.center;\n    float od = dot(origin, ray.dir);\n    float sqr = (od * od) - dot(origin, origin) + (sphere.rad * sphere.rad);\n    if (sqr < 0.) {\n        return Hit(far, vec3(0.), vec3(0.), vec3(0.));\n    }\n    float root = sqrt(sqr);\n    float t = min(-od - root, -od + root);\n    vec3 pos = ray.origin + (t * ray.dir);\n    return Hit(t, pos, normalize(pos - sphere.center), sphere.color);\n}\n\n// Find closest object intersected\nHit raytrace(Sphere[n] objects, Ray startRay) {\n    Hit closest = Hit(far, vec3(0.), vec3(0.), vec3(1.));\n    for (int i = 0; i < n; i++) {\n        Hit hit = intersectSphere(objects[i], startRay);\n        if (hit.t > .001 && hit.t < closest.t) {\n            closest = hit;\n        }\n    }\n    \n    return closest;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Place spheres in scene\n    Sphere[n] objects = Sphere[n](\n        Sphere(vec3(-4.,1. + sin(iTime + .5), -5.), 1., vec3(1., 0., 0.)),\n        Sphere(vec3(0.,1., -6. + sin(iTime * .95)), 2., vec3(1., 0., 1.)),\n        Sphere(vec3(4.,1. + cos(iTime * 1.05), -5.), 1., vec3(0., 1., 0.)),\n        Sphere(vec3(0.,-10, -5.), 10., vec3(0., 1., 1.))\n    );\n\n    // Convert pixel coordinates to screen space coordiantes\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    // Create ray from camera (at origin) through pixel\n    Ray v = Ray(vec3(0.), normalize(vec3(uv, -1.)));\n\n    // Initialize array to store color data for each reflection\n    vec3[3] colors = vec3[3](bg, bg, bg);\n    \n    for (int i = 0; i < 3; i++) {\n        // Get closest intersection\n        Hit hit = raytrace(objects, v);\n        if (hit.t == far) {\n            // If ray hit background, stop\n            break;\n        }\n        \n        // Check if ray is in shadow\n        Ray shadow = Ray(hit.pos, light.dir);\n        if (raytrace(objects, shadow).t < far) {\n            hit.color /= 4.;\n        }\n        \n        // Create shading using Lambertian model\n        colors[i] = hit.color * max(0., dot(light.dir, hit.normal));\n        \n        // Create a new ray that bounces off the surface of the intersection\n        v = Ray(hit.pos, reflect(v.dir, hit.normal));\n    }\n    // Combine all the colors\n    vec3 color = colors[0] * .5 + (colors[1] * .5 + colors[2] * .5) * .5;\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}