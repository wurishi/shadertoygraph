{"ver":"0.1","info":{"id":"XsscD7","date":"1488501696","viewed":93,"name":"BasicStuff","username":"Nihilus","description":"Basic testing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["basic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// Anti-aliasing\nfloat aa(float edge, float val)\n{\n    return 1.0 - smoothstep(val, val + 0.00999999, edge);\n}\n\nvec2 point_shr(vec2 p, float val)\n{\n    return p - vec2(val, 0.0);\n}\n\nvec2 point_shl(vec2 p, float val)\n{\n    return p + vec2(val, 0.0);\n}\n\nvec2 point_up(vec2 p, float val)\n{\n    return p - vec2(0.0, val);\n}\n\nvec2 point_down(vec2 p, float val)\n{\n    return p + vec2(0.0, val);\n}\n\nfloat square(vec2 c, float d)\n{\n    return aa(abs(c.x), d) * aa(abs(c.y), d);\n}\n\nfloat circle(vec2 c, float r)\n{\n    // Calculating the length\n    float l = length(c);\n    // Calculating the angle\n    float t = atan(c.y, c.x);\n    // Calculating point coordinates\n    vec2 p = vec2(r*cos(t), r*sin(t));\n    // Determining the circle\n    return aa(length(c), length(p));\n}\n\nfloat triangle(vec2 c, float d)\n{\n    return aa(c.y, d - abs(c.x)) * aa(abs(c.y), d);\n}\n\nfloat romboid(vec2 c, float d)\n{\n    return aa(abs(c.x) + abs(c.y), d);\n}\n\nfloat polygon(vec2 c, int n, float s)\n{\n    // if n = 3, scale down s\n    if(n == 3)\n        s = s/2.0;\n    // Calculating the length of the c vector (c.x, c.y) from the center (0,0)\n    //float l = sqrt(pow(c.x,2.0)+pow(c.y,2.0));\n    float l = length(c);\n    \n    // Calculating the angle at the base (0,0) of the c vector (c.x, c.y)\n    //float a = acos(-c.y/l); //using negative c.y to get the first triangle facing down\n    float a = atan(c.x, c.y) - PI; //subtracting PI to get the first triangle facing down\n    \n    // Calculating the angle at the base (0,0) of each triangle making the polygon\n  \tfloat r = (2.0 * PI) / float(n);\n   \n    /*\n    \tCalculating the index (integer) of the nearest multiple angle of r\n    \te.g. if N = 6 and a = 135 -> r = 360/6 = 60 -> i = 2 -> i * r = 120\n\t*/\n    float i = floor(0.5 + a / r);\n    \n    // Calculating the difference between a and the nearest multiple angle\n    float t = i * r - a;\n    \n    // Calculating the length of the apothem for the current triangle (hint: index)\n    float d = cos(t) * l;\n    \n    return aa(d, s);\n}\n\nfloat add_shape(float color, float shape)\n{\n    return color + shape;\n}\n\nfloat sub_shape(float color, float shape)\n{\n    return color - shape;\n}\n\nfloat add_border(float size, float shape)\n{\n    return size + shape;\n}\n\nfloat sub_border(float size, float shape)\n{\n    return size - shape;\n}\n\nfloat sine(vec2 c, float s, float f, float h)\n{\n    float d = h*sin(f*c.x);\n    return aa(abs(c.y - d), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*(fragCoord.xy / iResolution.xy) - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    // Save original pixel coordinates\n    vec2 uv_s = uv;\n    vec3 color = vec3(0.0);\n   \n    // Repetition of the field\n    //uv_s.x = mod(uv_s.x, 1.0);\n    //uv_s.y = mod(-pow(uv_s.x, 1.1) + uv_s.y, 1.0);\n    \n    // Field deformation, power\n    //uv_s.y = uv_s.y - pow(uv_s.x, 1.1);\n    \n    // Reflect field\n    //uv_s.x = abs(uv_s.x);\n    //uv_s.y = abs(uv_s.y);\n    \n    // Draw a square\n    uv = point_shr(uv_s, 1.2);\n    uv.y = uv.y - 0.05*sin(iTime);\n    \n    // Add a border to the square\n    float l = atan(uv.x, uv.y);\n   \tfloat border = 0.02*sin(50.0 * l + 10.0*iTime) + 0.02*sin(20.0 * l);\n    float size = 0.2;\n    size = add_border(size, border);\n    color.g = add_shape(color.g, square(uv, size));\n    \n    // Draw a square\n    uv = point_shl(uv_s, 1.2);\n    uv.y = uv.y + 0.15*sin(2.5*iTime);\n    uv.x = uv.x - 0.15*cos(2.5*iTime);\n    \n    l = atan(uv.x, uv.y);\n    border = 0.01*sin(5.0*l + 10.0*iTime);\n    size = 0.2;\n    size = sub_border(size, border);\n    color.g = add_shape(color.g, square(uv, size));\n    \n    // Draw a circle\n    uv = point_up(uv_s, 0.7);\n    uv = point_shl(uv, 1.2);\n    l = atan(uv.x, uv.y);\n    border = 0.02*sin(50.0 * l + 10.0*iTime) + 0.02*cos(20.0 * l);\n    size = 0.2;\n    size = add_border(size, border);\n    color.g = add_shape(color.g, circle(uv, size));\n    \n    // Draw a circle\n    uv = point_up(uv_s, 0.7);\n    uv = point_shr(uv, 1.2);\n    color.g = add_shape(color.g, circle(uv, 0.2));\n    \n    // Subtract a square to the circle\n    uv = point_up(uv_s, 0.7);\n    uv = point_shr(uv, 1.2);\n    color.g = sub_shape(color.g, square(uv, 0.14));\n    \n    // Add a triangle inside the square\n    uv = point_up(uv_s, 0.635);\n    uv = point_shr(uv, 1.2);\n    color.g = add_shape(color.g, polygon(uv, 3, 0.075));\n    \n    // Draw a triangle\n    uv = uv_s;\n    uv = point_down(uv_s, 0.7);\n    uv = point_shl(uv , 1.2);\n    l = atan(uv.x, uv.y);\n    border = 0.02*sin(50.0 * l + 10.0*iTime) + 0.02*cos(20.0 * l);\n    size = 0.16;\n    size = add_border(size, border);\n    color.g = add_shape(color.g, triangle(uv, size));\n    \n    // Draw a romboid\n    uv = point_down(uv_s, 0.7);\n    uv = point_shr(uv , 1.2);\n    color.g = add_shape(color.g, romboid(uv, 0.25));\n    \n    // Subtract a circle to the romboid\n    uv = point_down(uv_s, 0.7);\n    uv = point_shr(uv, 1.2);\n    color.g = sub_shape(color.g, circle(uv, 0.175));\n    \n    // Draw some polygons\n    uv = uv_s;\n    uv = point_down(uv, 1.13);\n    float shift = 0.25;\n    for(int i = 3; i < 11; i++)\n    {\n        uv = point_up(uv, shift);\n    \tcolor.g = add_shape(color.g, polygon(uv, i, 0.1));\n    }\n    \n    // Draw a sine\n    uv = uv_s;\n    uv.x = uv.x + 0.5*iTime;\n    color.r = add_shape(color.r, sine(uv, 0.01, 5.0, 0.3));\n    color.g = add_shape(color.g, sine(uv, 0.01, 5.0, 0.6));\n    color.b = add_shape(color.b, sine(uv, 0.01, 5.0, 0.9));\n        \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}