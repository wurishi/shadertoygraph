{"ver":"0.1","info":{"id":"DdcfRn","date":"1696770187","viewed":52,"name":"Cristal fractal","username":"FFFFFFear1","description":"Thanks for @kishimisu for that way to make a graphics!\nThat's new for me, i tryed to do my version","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I find a fantastic tutorial and made it with help of that! https://www.youtube.com/watch?v=f4s1h2YETNY\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat _tileCount = 1.5;\nfloat _cicles = 4.;\nfloat _speedColor = .6;\nvec2 _rhombusVector = vec2(1.5, 1.5);\n\nvec3 colorPalette( float t)\n{\n    vec3 a = vec3(0.468, 0.248, 0.608);\n    vec3 b = vec3(-0.312, 0.500, 0.448);\n    vec3 c = vec3(-1.732, 1.328, 1.328);\n    vec3 d = vec3(-0.542, 0.318, 0.48);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat rhomb( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord *  2.0  - iResolution.xy) / iResolution.y;\n    vec2 uvColor = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < _cicles; i++) \n    { \n        uv = fract(uv * _tileCount) -.5;\n\n        float newRhombus = rhomb(uv, _rhombusVector) / exp(rhomb(uvColor, _rhombusVector));\n\n        vec3 color = colorPalette(rhomb(uvColor, _rhombusVector) + i* _speedColor + iTime * _speedColor);\n\n        newRhombus = sin(newRhombus * 10.0 + iTime) / 2.0;\n \n        newRhombus = pow(0.1 / newRhombus, 1.8);\n        finalColor += color * newRhombus;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}