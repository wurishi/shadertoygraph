{"ver":"0.1","info":{"id":"wtdyDn","date":"1608994861","viewed":116,"name":"Synced Pendulum","username":"darkeclipz","description":"Pendulum","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1.\n#define R iResolution.xy\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdFloor(vec3 pos) {\n    float floor = sdBox(pos + vec3(0.5), vec3(20., 0.1, 20.));\n    float hole = sdBox(pos + vec3(-0.0, 0.4 , 0.1), vec3(.05, .5, .4));\n    return max(floor, -hole);\n}\n\n\nconst float g = 1.;\nconst float l = 3.;\nconst float th0 = pi/3.;\nbool wire = false; // pretty hacky *shrugs*\nfloat sdPendulum(vec3 pos, float t) {\n\n    vec3 c = vec3(0,0.2,0.0);\n    pos -= c;\n    pos.xy *= rot(th0*cos(sqrt(g/l) * t));\n    pos += c;\n    \n    //cone\n    //pos -= vec3(0.1,-0.5,-0.1);\n    pos -= vec3(0.,-0.5,-0.1);\n    float cone = sdCone(pos + vec3(0,-0.33,-0), vec2(0.25, 0.5), 0.18 );\n    \n    // rod\n    float rod = sdVerticalCapsule(pos - vec3(0,0.2,0), 0.5, 0.0025);\n    wire = rod < cone;\n    return min(rod, cone);\n}\n\nfloat sdSpinningDisk(vec3 pos, float t) {\n    // spinning cyl\n    //pos -= vec3(0.1,-0.5,-0.1);\n    pos -= vec3(0.0,-0.5,-0.1);\n    pos.yz *= rot(-t*sqrt(g/l)+pi/2.);\n    vec3 rpos = pos;\n    rpos.xy *= rot(pi/2.);\n    float cyl = sdCappedCylinder(rpos, 0.39, 0.01);\n    \n    // cone cut\n    vec3 cpos = pos;\n    cpos.y = abs(cpos.y);\n    float cone = sdCone(cpos + vec3(0,-0.375,-0), vec2(0.25, 0.5), 0.25);\n    cyl = max(cyl, -cone);\n    \n    // slit cut\n    float slit = sdBox(cpos - vec3(0,0.7,0), vec3(0.02, 0.5, 0.015));\n    return max(cyl, -slit);\n}\n\n//float id = 0.;\nvec2 map( in vec3 pos, float time )  \n{    \n    float id = 0.;\n    float t = 3.*iTime;\n    //t=2.*psqrt(g/l);\n    \n    // Floor\n    float d = sdFloor(pos);\n    \n    // Spinning disk\n    float disk = sdSpinningDisk(pos, t) - 0.004;\n    if(disk < d) {\n        id = 1.;\n    }\n    d = min(d, disk);\n    \n    // Pendulum\n    float pendulum = sdPendulum(pos, t);\n    if(pendulum < d) {\n        id = 2.;\n    }\n    d = min(d, pendulum);\n    \n    return vec2(d, id);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.0001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec3 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.01;\n    int i=0;\n    for( i=0; i<60; i++ )\n    {\n        float precis = 0.0001 * t;\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x< precis )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec3(t, m, 1. - float(i)/60.);\n}\n\n// https://iquilezles.org/articles/biplanar\n// \"p\" point being textured\n// \"n\" surface normal at \"p\"\n// \"k\" controls the sharpness of the blending in the transitions areas\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy );\n    \n    // blend factors\n    vec3 w = pow( abs(n), vec3(k) );\n    // blend and return\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\n\nvec3 calcRayDirection(in vec2 p, in vec3 ta, in vec3 ro) {\n    vec3 ww = normalize( ta-ro );\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    return normalize( p.x*uu + p.y*vv + 1.8*ww );\n}\n\nvec3 matFloor(in vec3 pos, in vec3 nor, in vec3 rd, float time) {\n    vec3 mate = vec3(10, 80, 255) / 255.;   \n    vec3 refl = reflect(rd, nor);\n    vec3 hit = castRay(pos + refl*0.01, refl, time);\n    float t = hit.x, id = hit.y;\n    if(t < 20.0) {\n        mate *= vec3(191, 222, 245)/255.;\n    }\n    float s = 8.;\n    float w = 0.025;\n    if(fract(pos.x*s) < w) {\n        mate *= 0.9;\n    }\n    if(fract(pos.z*s) < w) {\n        mate *= 0.9;    \n    }\n    return mate;\n}\n\nvec3 matSpinningDisk(in vec3 pos, in vec3 nor, float time) {\n    vec3 bpos = pos - vec3(0.,-0.49,-0.1);\n    bpos.yz *= rot(-time*sqrt(g/l) + pi/2.);\n    vec3 text = vec3(0);\n    if(bpos.y > 0.) text = boxmap(iChannel0, bpos, nor, 2.0).rgb;   \n    else            text = boxmap(iChannel1, bpos, nor, 2.0).rgb;   \n    return mix(vec3(1), text, 0.85);\n}\n\nvec3 calcMaterial(in vec3 pos, in vec3 nor, in vec3 rd, float id, float time) {\n    vec3 mate = vec3(0.6); \n    \n    if(id < 0.5) { // floor\n        mate = matFloor(pos, nor, rd, time);\n    }\n    else if(id < 1.5) { // spinning disk\n        mate = matSpinningDisk(pos, nor, time);\n    }\n    else if(id < 2.5) { // pendulum\n        mate = wire ? vec3(0) : nor;\n    }\n    \n    return mate;\n}\n\nvec3 calcBRDF(in vec3 pos, in vec3 nor, float occl) {\n    vec3  light1 = vec3(0.3, 0.1, -1 );\n    vec3  light2 = vec3(0.2, 3, -1 );\n    float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n    float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n    float amb = (0.7+0.3*nor.y);\n    //float shadow = clamp(castShadow(pos + nor*0.05, light1 - pos, time), 0., 1.);\n    vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb;\n    brdf += 1.0*vec3(255, 248, 230)/255.*key*occl;\n    brdf += 1.0*vec3(230, 248, 255)/255.*bac*occl;\n    return brdf;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = 3.*iTime;\n\n    vec3 col = vec3(0);\n    vec3 result = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0.1,-0.4,0);\n        vec3 ro = vec3(0, 0.1, -0.8);\n        ro.xz *= rot(3.1415/4.+0.1);\n        \n        vec3 rd = calcRayDirection(p, ta, ro);\n        vec3 col = vec3(0.0);\n\n        vec3 hit = castRay(ro, rd, time); \n        float t = hit.x;\n        float id = hit.y;\n        float occl = hit.z;\n\n        if(t < 20.)\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n            vec3 mate = calcMaterial(pos, nor, rd, id, time);\n            vec3 brdf = calcBRDF(pos, nor, occl);\n            col = mate * brdf * exp(-0.6*t);\n        }\n\n        result += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow(result/(AA*AA), vec3(0.4545));\n    O = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}