{"ver":"0.1","info":{"id":"mlXyW8","date":"1690714978","viewed":39,"name":"Carpet colony","username":"arkhan99","description":"Just messing around","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","circle","trippy","cells","carpet","mandala","colony"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nvec4 sdfCircle( in vec2 p, in vec2 c, in float r, in float n)\n{\n    p = (p + 1.0)/2.0;\n    p = mod(p, 1.0);\n    p = (p - 0.5)*2.0;\n    // very cool constructive and destructive interference\n    p = length(p)*vec2(sin(0.3*iTime), cos(0.2*iTime));\n    float len = max(length(p - c) - r, 0.);\n    // todo later\n    return vec4(0.1, 0.3, 0.7, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float r_ = 10.*iTime;\n    float th_= 0.01*iTime;\n    //scaling - move it to after t and r to get hammered\n    float scale_f = abs(max(sin(0.02*iTime), 0.3));\n    fragCoord = fragCoord * scale_f;\n    //rotation\n    fragCoord = vec2(fragCoord.x*cos(th_) - fragCoord.y*sin(th_), fragCoord.x*sin(th_) + fragCoord.y*cos(th_));\n    //translation\n    fragCoord = fragCoord + vec2(r_, 0);\n    \n    //rescaling\n    fragCoord.x = mod(fragCoord.x, iResolution.x);\n    fragCoord.y = mod(fragCoord.y, iResolution.y);\n    \n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*2.0;\n    \n    //correcting circles (there has to be a better way lol)\n    float aspect_r = iResolution.y/iResolution.x;\n    if (iResolution.x > iResolution.y)\n    {\n        uv.x = uv.x/aspect_r;\n    }\n    else\n    {\n        uv.y = uv.y/aspect_r;\n    }\n    uv = abs(uv);\n    \n    vec2 uv2;\n    float col = 10.;\n    float col2;\n    float n = 7.;// + ((1.-scale_f) * 5.);\n    float radius;\n    vec3 color_acc = vec3(0, 0, 0);\n    vec4 sdf;\n    for(float i = 1.0; i<n; i+=0.9)\n    {\n        radius = 0.01 * sin(iTime);\n        uv2 = (uv - (sin(0.01*i*iTime) - cos(0.01*i*iTime)))*i;\n        // correction in theta - farther circles now rotate slower\n        sdf = sdfCircle(uv2, vec2(0.2*sin(3.*(1./i) * iTime + i), 0.2*cos(3.*(1./i) * iTime + i)), radius, i);\n        // do it later\n        color_acc += sdf.xyz;\n        col2 = sdf.w;\n        col = smin(col, col2, 0.01);\n        \n    }\n    fragColor = vec4(col*abs(sin(0.01 * iTime + 1.2)), 0, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}