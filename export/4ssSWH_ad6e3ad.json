{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI \t\t\t\t\t3.14159265359\n#define EPSILON \t\t\t0.02\n#define BUMP_FACTOR     \t0.01\n#define K\t\t\t\t\t(2.0 + 0.5*sin (iTime*PI*0.7))\n\n#define MIN_STEP\t\t\t0.001\n#define MAX_STEP\t\t\t100.0\n\n#define MAX_STEPS \t\t\t100\n#define MAX_SHADOW_STEPS\t64\n\n#define MAX_OCCLUSION_STEPS 8\n#define MIN_DIST\t\t\tEPSILON\n#define MAX_DIST\t\t\t50.0\n#define BUMP_SCALE_FACTOR\t0.2\n#define TEX_SCALE_FACTOR\t0.1\n#define FOV\t\t\t\t\t60.0\n\n#define SHADOW_HARDNESS \t64.0\n#define ATTENUATION\t\t\t0.025\n#define AMBIENT\t\t\t\t0.5\n#define SHINYNESS\t\t\t50.0\n#define SPECULAR\t\t\t3.0\n#define DIFFUSE\t\t\t\t3.0\n#define OCCLUSION   \t\t5.0\n\n#define FLICKER_SPEED\t\t3.0\n#define FLICKER_THRESHOLD\t0.7\n\n#define LIGHT_AMBIENT\t\tvec4(1.0,1.0,1.0,1.0)\n#define LIGHT_DYNAMIC\t\tvec4(1.0,1.0,1.0,1.0)\n//\n//#define MSAA4X\n\nmat3 rotate_x (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (1.0, 0.0, 0.0),\n\t\tvec3 (0.0, cfi, -sfi),\n\t\tvec3 (0.0, sfi, cfi)\n\t);\n}\n\nmat3 rotate_y (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (cfi, 0.0, sfi),\n\t\tvec3 (0.0, 1.0, 0.0),\n\t\tvec3 (-sfi, 0.0, cfi)\n\t);\n}\n\nmat3 rotate_z (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (cfi, -sfi, 0.0),\n\t\tvec3 (sfi, cfi, 0.0),\n\t\tvec3 (0.0, 0.0, 1.0)\n\t);\n}\n\nmat3 rotate (vec3 vPitchYawRoll, float fi) {\n\treturn\n\t\trotate_z (fi * vPitchYawRoll.z) *\n\t\trotate_y (fi * vPitchYawRoll.y) *\n\t\trotate_x (fi * vPitchYawRoll.x);\n}\n\n\nfloat smin (float a, float b, float k) {\n    return -log (exp (-k*a) + exp (-k*b)) / k;\n}\n\nfloat smax (float x, float y, float k) {\n\treturn log (exp (k*x) + exp (k*y)) / k;\n}\n\nstruct Plane {\n\tvec3 n;\n\tfloat d;\t\n};\n\nstruct Sphere {\n\tvec3 o;\n\tfloat r;\t\n};\n\nstruct Box {\n\tvec3 o;\n\tvec3 b;\t\n};\n\t\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.xz * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\nfloat get_distance_plane (vec3 p, Plane plane) {\n\treturn dot (plane.n,p) + plane.d;\n}\n\nfloat get_distance_sphere (vec3 p, Sphere sphere) {\n\tvec3 p0 = p - sphere.o;\t\n\tfloat l0 = length (p0);\n\tfloat bump = 0.0;\n\tif (l0 < sphere.r + BUMP_FACTOR) {\n\t\tbump = BUMP_FACTOR * texture3d(iChannel0, p, normalize (p0), BUMP_SCALE_FACTOR).r ;\t\n\t}\t\t\t\n\treturn length (p0) - sphere.r + bump;\n}\n\nfloat get_distance_box (vec3 p, Box box) {\n\tfloat bump = 0.0;\n\tvec3 p0 = p - box.o;\n\t\n\tif (length (p0) < length (box.b)) {\n\t\tbump = texture3d(iChannel0, p, p0, BUMP_SCALE_FACTOR).r * BUMP_FACTOR;\n\t}\t\n\t\n \tvec3 d = abs(p0) - box.b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) + bump;\t\n}\n\nfloat dadd (float a, float b) {\n\treturn smin (a, b, K);\n}\nfloat dsub (float a, float b) {\n\treturn smax (a, -b, K);\n}\n\nfloat get_distance (vec3 p) {\n\t\n\tfloat s0 = get_distance_sphere (p, Sphere (vec3 (0.0, 2.5, 0.0), 1.0));\n\tfloat s1 = get_distance_sphere (p, Sphere (vec3 (1.5, 1.0, 0.0), 1.0));\n\tfloat b0 = get_distance_box (p, Box (vec3 (0.0, 1.0, 0.0), vec3 (1.0, 1.0, 1.0)));\n\tfloat b1 = get_distance_box (p, Box (vec3 (0.0, -0.5, 0.0), vec3 (3.0, 1.0, 3.0)));\n\tfloat p0 = get_distance_plane (p, Plane (normalize (vec3 (0.0, 1.0, 0.0)),0.0));\n\treturn dadd (dadd (dadd (dadd (b0, b1), s0), s1), p0);\n}\nvec3 get_normal (vec3 p) {\n\tfloat d = get_distance (p);\n\treturn normalize (vec3 (\n\t\tget_distance (p - vec3 (EPSILON, 0.0, 0.0)) - d,\n\t\tget_distance (p - vec3 (0.0, EPSILON, 0.0)) - d,\n\t\tget_distance (p - vec3 (0.0, 0.0, EPSILON)) - d\n\t));\n}\n\nvec2 screen_uv () {\n\t//vec2 mouse = iMouse.xy / iResolution.xy - vec2 (0.5, 0.5);\n\treturn vec2 (2.0*gl_FragCoord.xy - iResolution.xy)/ \n\t\tvec2 (min (iResolution.x, iResolution.y));\n}\n\nfloat ray_march (vec3 org, vec3 dir, out float md) {\t\n\tfloat h = EPSILON;\n\tmd = MAX_DIST;\t\n\tfor (int i = 0;i < MAX_STEPS;++i) {\n\t\tfloat d = get_distance  (dir * h + org);\n\t\tmd = min (md, d);\n\t\tif (d <= EPSILON) \n\t\t\treturn h;\n\t\th += clamp (d, MIN_STEP, MAX_STEP);\n\t\tif (h >= MAX_DIST)\n\t\t\treturn h;\t\t\n\t}\n\treturn MAX_DIST;\n}\n\nfloat light_march (vec3 org, vec3 dir, float k){\n    float res = 1.0;\n\tfloat t = MIN_DIST;\n    for (int i =0; i < MAX_SHADOW_STEPS; ++i){\n        float h = get_distance (org + dir*t);\n        if (h < 0.001)\n            return 0.0;\n        res = min (res,k*h/t);\n        t += h;\n\t\tif (t >=MAX_DIST)\n\t\t\treturn res;\n    }\n    return res;\n}\n\nfloat sample_occlusion (vec3 pnt, vec3 nml) {\n\tfloat ao = 0.0;\n\tfloat di = 1.0 / float (MAX_OCCLUSION_STEPS);\n\tfor (float i = 0.0; i < float(MAX_OCCLUSION_STEPS); i += 1.0) {\n\t\tfloat d = i * di;\n\t\tao += (1.0/exp2 (i))*(d - get_distance (pnt - nml*d));\n\t}\n\treturn 1.0 - OCCLUSION * ao;\n}\n\nfloat flicker (float o) {\n\treturn step (FLICKER_THRESHOLD, texture (iChannel2, vec2 (o, iTime/(50.0/FLICKER_SPEED))).r);\n}\n\nvec4 calc_ray (vec2 uv) {\t\n\tuv *= tan (radians (FOV)/2.0);\n\t\n\tmat3 rotcam = rotate_y (PI * sin (iTime*PI/10.0) / 4.0);\n\tmat3 rotlit = rotate_y ((PI / 2.0) * sin (iTime*PI/5.0));\n\t\n\tvec3 lo = vec3 (0.0, 5.0, -10.0) * rotlit;\n\tvec3 org = vec3 (0.0, 3.0, -7.0) * rotcam;\n\tvec3 up = vec3 (0.0, 1.0, 0.0) ;\n\tvec3 fw = vec3 (0.0, 0.0, 1.0) * rotcam;\n\tvec3 rt = -cross (fw, up) ;\n\t\n\t\n\tvec3 dir = normalize (up * uv.y + rt * uv.x + fw);\t\n\tfloat md = 0.0;\n\tfloat hd = ray_march (org, dir, md);\n\n\t\n\tvec3 pnt = org + dir * hd;\n\tvec3 nml = get_normal (pnt);\n\tvec3 lds = pnt - lo;\n\tvec3 ldr = normalize (lds);\n\tvec3 lrf = reflect (-ldr, nml);\n\t\n\tfloat shadow = light_march (pnt, -ldr, SHADOW_HARDNESS);\n\tfloat occlusion = sample_occlusion (pnt, nml)*AMBIENT*flicker(0.2) ;\t\n\tfloat diffuse = max (0.0, dot (nml, ldr)) ;\t\n\tfloat attenuation = (1.0/(1.0+ATTENUATION*pow(length (lds),2.0)));\n\tfloat specular = diffuse > 0.0 ? pow(max(0.0, dot(dir, lrf)), SHINYNESS) : 0.0;\t\t\t\t\n\tfloat lighting = clamp ((DIFFUSE*diffuse + SPECULAR*specular)*shadow*attenuation, 0.0, 1.0);\n\t\n\treturn mix (\n\t\ttexture3d (iChannel1, pnt, nml, TEX_SCALE_FACTOR)*\n\t\t\t(LIGHT_DYNAMIC*lighting + LIGHT_AMBIENT*occlusion), \n\t\tmix (vec4 (1.0, 0.0, 0.0, 1.0), \n\t\t\t vec4 (0.1, 0.0, 0.1, 1.0), \n\t\t\t smoothstep (-1.0, 0.1, dot (up, dir))),\n\t\tsmoothstep (10.0, 20.0, hd));\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat dp = 1.0 / min (iResolution.y, iResolution.x);\n\tvec2 uv = screen_uv ();\n\t#ifdef MSAA4X\n\tfragColor = (\n\t\tcalc_ray (uv+vec2(-dp/2.0, -dp/2.0))+\n\t\tcalc_ray (uv+vec2(+dp/2.0, +dp/2.0))+\n\t\tcalc_ray (uv+vec2(+dp/2.0, -dp/2.0))+\n\t\tcalc_ray (uv+vec2(-dp/2.0, +dp/2.0))) * 0.25;\n\t#else\n\tfragColor = calc_ray (uv);\n\t#endif\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssSWH","date":"1400185781","viewed":250,"name":"Living breathing thing","username":"Coldberg","description":"ray marching test nr 3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","smoothmin"],"hasliked":0,"parentid":"","parentname":""}}