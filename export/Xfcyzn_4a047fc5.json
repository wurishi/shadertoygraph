{"ver":"0.1","info":{"id":"Xfcyzn","date":"1730398267","viewed":159,"name":"Truchet Labyrinth","username":"Bingle","description":"An infinite labyrinth of corridors and massive stone walls, seemingly empty besides occasional moss or tunnels...","likes":14,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","truchet","maze"],"hasliked":0,"parentid":"X3SBDy","parentname":"Simple Raymarching Boilerplate"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching Boilerplate by Bingle\n/* Axis orientation (from default camera view):\n\n             ^ +Y\n             |\n             |\n     +X      |\n     <-------+\n              \\\n               \\| +Z\n              ‾‾\n*/\n\n// Use mouse to slide the side-by-side comparison boundary\n//#define DEBUG\n\n// Definitions\n#define WALL_THICKNESS 0.07\n#define WALL_HEIGHT 1.25\n#define BEVEL 0.025\n#define LIGHT_DIR normalize(vec3(-0.5,1.0,0.1))\n#define CLOUD_LOW 4.0\n#define CLOUD_MIDDLE 5.0\n#define CLOUD_HIGH 6.0\n#define SQRT2 1.41421356237\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Returns distance and the seed for the cell\nvec2 truchet(vec2 p){\n    float r = hash12(floor(p));\n    p = mod(p,1.0);\n    if (mod(r,0.5)<0.25){\n        p.y = 1.0-p.y;\n    }\n    if (r<0.5){\n        return vec2(SQRT2*abs(mod(p.x - p.y - 0.5, 1.0) - 0.5)*0.5 - WALL_THICKNESS, r);\n    }else{\n        return vec2(-SQRT2*(0.5*(abs(p.x - 0.5) + abs(p.y - 0.5)) - 0.5) - WALL_THICKNESS, r);\n    }\n}\n\nfloat SDF(vec3 p){\n    vec2 UV = p.xz;\n    vec2 t = truchet(UV);\n    \n    if (p.y>WALL_HEIGHT){\n        if (t.x <= 0.0){\n            return p.y-WALL_HEIGHT-BEVEL;\n        }else{\n            return sqrt((p.y-WALL_HEIGHT)*(p.y-WALL_HEIGHT) + t.x*t.x)-BEVEL;\n        }\n    }else{\n        if (t.y<0.5 && mod(t.y,0.25)<0.125){\n            return min(max(t.x-BEVEL,0.02-length(vec2((mod(p.x,1.0)+mod(mod(t.y,0.5)>0.25?p.z:-p.z,1.0)-0.5)/SQRT2,max(p.y-0.1,0.0) )) ),p.y);\n        }else{\n            return min(t.x-BEVEL,p.y);\n        }\n    }\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax, float w){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = SDF( ro + rd*t );\n        \n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)));\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// taken from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SDF( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 normal(vec3 P){\n    vec2 h = .0001*vec2(1,-1);\n    return normalize( vec3(h.xxy*SDF(P+h.xxy) + h.xyx*SDF(P+h.xyx) + h.yxx*SDF(P+h.yxx) + h.yyy*SDF(P+h.yyy) ));\n}\n\nvec2 randDir(vec2 p){\n    for (int i=1;i<50;i++){ // Do NOT make this a while true loop. Precision limits at far distances make it loop forever. Ask how I found that out...\n        vec2 rnd = hash22(p)*2.0-1.0;\n        float l = length(rnd);\n        if (l>0.0001 && l<1.0){\n            return normalize(rnd);\n        }\n        p+=vec2(0.3,0.1);\n    }\n    return vec2(0.0);\n}\n\nfloat noise(vec2 p){\n    vec4 corners = vec4(floor(p),ceil(p));\n    \n    vec2 ll = randDir(corners.xy);\n    vec2 lh = randDir(corners.xw);\n    vec2 hl = randDir(corners.zy);\n    vec2 hh = randDir(corners.zw);\n    \n    vec2 loc = mod(p,vec2(1.0)); // local coords\n    \n    float llDot = dot(ll,(p-corners.xy));\n    float lhDot = dot(lh,(p-corners.xw));\n    float hlDot = dot(hl,(p-corners.zy));\n    float hhDot = dot(hh,(p-corners.zw));\n    \n    vec2 easeFac = ((6.0*loc - 15.0)*loc+10.0)*loc*loc*loc;\n    \n    return mix(\n        mix(llDot,hlDot,easeFac.x),\n        mix(lhDot,hhDot,easeFac.x),\n        easeFac.y\n    );\n}\n\nvec2 noiseDerivs(vec2 p){\n    vec4 corners = vec4(floor(p),ceil(p));\n    \n    vec2 ll = randDir(corners.xy);\n    vec2 lh = randDir(corners.xw);\n    vec2 hl = randDir(corners.zy);\n    vec2 hh = randDir(corners.zw);\n    \n    vec2 loc = mod(p,vec2(1.0)); // local coords\n    \n    float llDot = dot(ll,(p-corners.xy));\n    float lhDot = dot(lh,(p-corners.xw));\n    float hlDot = dot(hl,(p-corners.zy));\n    float hhDot = dot(hh,(p-corners.zw));\n    \n    vec2 easeFac = ((6.0*loc - 15.0)*loc+10.0)*loc*loc*loc; // eased factor\n    vec2 easeDif = 30.0*loc*loc*(loc*(loc-2.0)+1.0); // differential of eased factor\n    \n    return ll + easeFac.x*(hl-ll) + easeFac.y*(lh-ll) + easeFac.x*easeFac.y*(ll-hl-lh+hh) +\n           easeDif*(easeFac.yx*(llDot-hlDot-lhDot+hhDot) + vec2(hlDot,lhDot) - llDot);\n}\n\nvec2 fractal(vec2 p,int iters){\n    vec2 val = vec2(0.0);\n    vec2 coords = p;\n    float total = 0.0;\n    for (int i=0;i<iters;i++){\n        float magnitude = 1.0/(0.15*float(i)+1.0);\n        val+=noiseDerivs(coords)*magnitude;\n        total+=magnitude;\n        coords*=2.0;\n    }\n    return val/total;\n}\n\nfloat cloudDensity(vec3 p){\n    float val = 0.0;\n    vec2 coords = p.xz*0.1;\n    float total = 0.0;\n    for (int i=0;i<5;i++){\n        float magnitude = 1.0/(2.0*float(i)+1.0);\n        val+=noise(coords)*magnitude;\n        total+=magnitude;\n        coords*=2.0;\n    }\n    return -min(0.0,abs(p.y-CLOUD_MIDDLE)-3.0*(val/total));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    cam camera = cam(vec3(sin(iTime*0.17),1.9+sin(iTime*0.2)*0.4,-5.0-iTime),normalize(vec3(0,-0.25,-1)),normalize(vec3(0,1,-1)),0.5);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    ray r = getCamRay(camera,uv);\n    bool hit = false;\n    int iters = 250;\n    float dist = 0.0;\n    float totalDist = 0.0;\n    \n    while (iters>0){\n        dist = SDF(r.pos);\n        if (dist<0.0025){\n            break;\n        }\n        if (dist>3.0){\n            iters = 0;\n            break;\n        }\n        r.pos += r.dir*dist;\n        totalDist += dist;\n        iters--;\n    }\n    \n    vec3 norm;\n    \n    if (iters==0 && dist<0.1){ // Are we close, but not there yet?\n        norm = normal(r.pos);\n        r.pos += r.dir/dot(r.dir,norm); // Helps if near parallel to a flat surface (like the walls)\n        dist = SDF(r.pos);\n        if (dist>0.01){ // Are we still not there yet?\n            r.pos = r.pos-norm*dist; // Just give up and snap to the surface. Not great, but looks better than holes\n            dist = 0.0;\n        }\n    }\n    \n    if (iters>0 || dist<0.01){ // Hit\n        if (iters>0){\n            norm = normal(r.pos);\n        }\n        vec3 lightNorm = norm;\n        if (norm.y>0.5){\n            vec3 tan1 = cross(norm,vec3(1.0,0.0,0.0));\n            vec3 tan2 = cross(norm,tan1);\n            vec2 nmap = fractal(r.pos.xz*10.0,7)*0.3;\n            lightNorm = normalize(norm*sqrt(1.0-dot(nmap,nmap)) + tan1*nmap.x + tan2*nmap.y);\n        }else{\n            vec3 tan1 = cross(norm,vec3(0.0,1.0,0.0));\n            vec3 tan2 = cross(norm,tan1);\n            vec2 nmap = fractal(r.pos.xy*vec2(SQRT2,1.0)*10.0,3)*0.45;\n            lightNorm = normalize(norm*sqrt(1.0-dot(nmap,nmap)) + tan1*nmap.x + tan2*nmap.y);\n        }\n        st_assert(dot(norm,lightNorm)>0.0); // Doesn't appear to highlight anything. (That's good!)\n        float light = 1.4*calcSoftshadow(r.pos,LIGHT_DIR,0.01,3.0,0.1)*calcAO(r.pos,norm)*max(dot(lightNorm,LIGHT_DIR),0.0)*0.85+0.15;\n        \n        if (light>0.0){\n            float cover = 1.5*cloudDensity(r.pos+LIGHT_DIR*(CLOUD_MIDDLE-r.pos.y)/LIGHT_DIR.y);\n            light = min(light,max(1.0-cover,0.1));\n        }\n        \n        vec2 wallUV = vec2(r.pos.x*SQRT2,r.pos.y)*1.5;\n        vec2 floorUV = vec2(r.pos.x - r.pos.z,r.pos.x + r.pos.z)*2.0;\n        float vegetation = clamp(fractal(r.pos.xz*0.15,7).r*2.0-0.5,0.0,1.0);\n        vec3 wall = mix(texture(iChannel0,wallUV).rrr,texture(iChannel0,wallUV*3.0).rrr,0.25)*0.95+vec3(0.05); // Walls\n        wall = mix(wall,texture(iChannel2,wallUV*4.0).grb,clamp(vegetation*(1.0-r.pos.y),0.0,1.0));\n        vec3 top;\n        if (r.pos.y>0.5*WALL_HEIGHT){ // Top of walls\n            top = mix(texture(iChannel0,floorUV).rrr,texture(iChannel0,floorUV*2.0).rrr,0.25)*0.8+vec3(0.2);\n        }else{ // Floor\n            top = (texture(iChannel1,floorUV).rrr*texture(iChannel1,floorUV*2.0).rrr);\n            vec2 t = truchet(r.pos.xz); // This is calculated elsewhere already for the SDF but it's cheap enough that I can just calculate it again.\n            top *= cos(t.x*3.14159*SQRT2*10.0) > 0.0 ? 1.0 : 0.8; // Floor pattern\n            top = mix(top,texture(iChannel2,floorUV*2.0).grb,clamp(vegetation,0.0,1.0)); // \n        }\n        \n        col = light*mix(wall,top,max(norm.y,0.0));\n        //col = vec3(vegetation);\n    }else{ // Miss\n        if (r.dir.y<0.0){ // Are we below the horizon?\n            vec3 p = r.pos+r.dir*(r.pos.y-WALL_HEIGHT)/-r.dir.y;\n            vec2 t = truchet(p.xz);\n            \n            col = texture(iChannel0,p.xz).rrr*vec3(t.x<=0.0 ? 1.0 : 0.4); // Fake far distances\n        }else{ // Draw the sky\n            r.pos = camera.pos;\n            col = mix(vec3(0.5,0.8,0.9),vec3(0.3,0.5,1.0),r.dir.y);\n            float near = abs(r.pos.y-CLOUD_LOW)/r.dir.y;\n            float far = abs(r.pos.y-CLOUD_HIGH)/r.dir.y;\n            totalDist = near; // For the fog calculations. Not super precise but it looks fine\n            \n            for (int i=0;i<25;i++){\n                float t = 1.0-(float(i)/25.0);\n                vec3 p = r.pos + r.dir*mix(near,far,t);\n                float d1 = cloudDensity(p);\n                float d2 = cloudDensity(p+LIGHT_DIR/100.0);\n                col = mix(col,mix(vec3(0.55),vec3(1.0,1.0,0.8),(d1-d2)*100.0),d1);\n            }\n        }\n    }\n    \n    col = mix(vec3(0.5,0.8,0.9),col,1.0/(totalDist*totalDist*0.0015+1.0)); // Fog\n    \n    #ifdef DEBUG\n    if (mod(iTime,5.0)>2.5){\n        // Debug raymarching iterations (black near, white far)\n        col = mix(col,vec3(1.0-float(iters)/250.0),min(max(fragCoord.x-iMouse.x-0.2*(fragCoord.y-iMouse.y),0.0),1.0));\n    }else{\n        // Debug inverse of distance map (white near, black far)\n        col = mix(col,vec3(1.0/totalDist),min(max(fragCoord.x-iMouse.x-0.2*(fragCoord.y-iMouse.y),0.0),1.0));\n    }\n    #endif\n    \n    float sunFac = dot(r.dir,LIGHT_DIR);\n    if (sunFac>0.0){\n        col += vec3(pow(sunFac*0.925,10.0)); // Sun halo (not great but it's offscreen so I don't care)\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct cam{\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    float viewDist;\n};\n\nstruct ray{\n    vec3 pos;\n    vec3 dir;\n};\n\n// Takes UV coords -0.5 to 0.5 (or in whatever centered range really) and returns a ray\nray getCamRay(cam c,vec2 uv){\n    vec3 side = cross(c.dir,c.up);\n    vec3 up = cross(side,c.dir);\n    \n    return ray(c.pos,normalize(c.dir*c.viewDist + side*uv.x + up*uv.y));\n}\n\n// Returns the point at distance t along ray r\nvec3 at(ray r,float t){\n    return r.pos + r.dir*t;\n}","name":"Common","description":"","type":"common"}]}