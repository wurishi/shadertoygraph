{"ver":"0.1","info":{"id":"cdyGD3","date":"1679084472","viewed":112,"name":"Spinning 3D Cube GPT4","username":"milesd","description":"spinning cube generated by GPT4 This one is a bit better than gpt3. I didn't need to make any changes to the code it gave me\n\nprompt: \"generate shadertoy code for a shader that makes a spinning 3d cube with realistic lighting\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube","spinning","gpt4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Camera settings\n    vec3 cameraPosition = vec3(0.0, 0.0, 5.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraForward = normalize(cameraTarget - cameraPosition);\n    vec3 cameraRight = normalize(cross(cameraUp, cameraForward));\n    vec3 cameraDir = normalize(cameraForward + uv.x * cameraRight + uv.y * cameraUp);\n    \n    // Spinning cube\n    float t = iTime * 0.5;\n    vec3 cubePosition = vec3(0.0, 0.0, 0.0);\n    vec3 cubeSize = vec3(1.0, 1.0, 1.0);\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = cameraDir;\n    mat3 rotationMatrix = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    rayOrigin -= cubePosition;\n    rayOrigin = rotationMatrix * rayOrigin;\n    rayDirection = rotationMatrix * rayDirection;\n    \n    // Ray-box intersection\n    vec3 tMin = (cubeSize * -0.5 - rayOrigin) / rayDirection;\n    vec3 tMax = (cubeSize * 0.5 - rayOrigin) / rayDirection;\n    vec3 tNear = min(tMin, tMax);\n    vec3 tFar = max(tMin, tMax);\n    float t0 = max(max(tNear.x, tNear.y), tNear.z);\n    float t1 = min(min(tFar.x, tFar.y), tFar.z);\n    if (t0 < t1 && t1 > 0.0)\n    {\n        vec3 hitPosition = rayOrigin + t0 * rayDirection;\n        vec3 normal = vec3(0.0);\n        vec3 epsilon = vec3(0.001);\n        if (abs(hitPosition.x - cubeSize.x * 0.5) < epsilon.x) normal = vec3(1.0, 0.0, 0.0);\n        else if (abs(hitPosition.x + cubeSize.x * 0.5) < epsilon.x) normal = vec3(-1.0, 0.0, 0.0);\n        else if (abs(hitPosition.y - cubeSize.y * 0.5) < epsilon.y) normal = vec3(0.0, 1.0, 0.0);\n        else if (abs(hitPosition.y + cubeSize.y * 0.5) < epsilon.y) normal = vec3(0.0, -1.0, 0.0);\n        else if (abs(hitPosition.z - cubeSize.z * 0.5) < epsilon.z) normal = vec3(0.0, 0.0, 1.0);\n        else normal = vec3(0.0, 0.0, -1.0);\n            // Transform normal back to world space\n        normal = rotationMatrix * normal;\n\n        // Lighting\n        vec3 lightPosition = vec3(2.0, 2.0, 2.0);\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n        vec3 ambientColor = vec3(0.1, 0.1, 0.1);\n\n        // Ambient\n        vec3 ambient = ambientColor;\n\n        // Diffuse\n        vec3 lightDirection = normalize(lightPosition - hitPosition);\n        float diffuseIntensity = max(dot(normal, lightDirection), 0.0);\n        vec3 diffuse = lightColor * diffuseIntensity;\n\n        // Specular\n        float shininess = 32.0;\n        vec3 viewDirection = normalize(cameraPosition - hitPosition);\n        vec3 halfwayDirection = normalize(lightDirection + viewDirection);\n        float specularIntensity = pow(max(dot(normal, halfwayDirection), 0.0), shininess);\n        vec3 specular = lightColor * specularIntensity;\n\n        // Combine lighting components\n        vec3 lighting = ambient + diffuse + specular;\n        fragColor = vec4(lighting, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}