{"ver":"0.1","info":{"id":"tdG3Rz","date":"1569622041","viewed":364,"name":"High Voltage","username":"shau","description":"triangular noise experiment","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","electricity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Nimitz\nfloat tri(\n    float x) \n{\n    return abs(x - floor(x) - 0.5);\n} \n\nfloat clampHash11(\n    float seed) \n{\n    return clamp(hash11(seed), 0.5, 0.9);\n}\n\nfloat noise(\n    vec2 uv, \n    float s1, \n    float s2, \n    float t1, \n    float t2, \n    float c1) \n{\n\treturn clamp(hash33(vec3(uv.xy * s1, t1)).x +\n\t\thash33(vec3(uv.xy * s2, t2)).y, c1, 1.);\n}\n\n//https://iquilezles.org/www/index.htm\nfloat sphIntersect(\n    vec3 ro, \n    vec3 rd, \n    vec4 sph) \n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return -1.0;\n\treturn -b - sqrt(h);\n}\n\nfloat sdCapsule(\n    in vec3 p, \n    in vec3 a, \n    in vec3 b, \n    in float r) \n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nvec3 pointOnLine(\n    in vec3 a, \n    in vec3 b, \n    in float t) \n{\n    return a + normalize(b-a)*length(b-a)*t;    \n}\n\nvec3 loadSP(\n    in float idx, \n    in float dir) \n{\n    float row = (dir > 0.0) ? 0.5 : 100.5;\n    return texture(iChannel0, vec2(idx+0.5, row)/R).xyz;\n}\n\nvec2 near(\n    vec2 a, \n    vec2 b) \n{\n    float s = step(a.x, b.x);\n    return a*s + (1.0 - s)*b;\n}\n\nfloat bolt(\n    in vec3 p, \n    in vec3 op, \n    in float i1, \n    in float i2,\n    in float dir,\n    in float width,\n    in float offset) \n{\n    vec3 sp1 = loadSP(i1, dir),\n         sp2 = loadSP(i2, dir),\n         op2 = pointOnLine(sp1, op, clampHash11(T+offset));\n    \n    float lig = sdCapsule(p, op, sp1, width);    \n    return min(lig, sdCapsule(p, op2, sp2, width));\n}\n\nvec2 lightning(\n    in vec3 p, \n    in vec3 op) \n{\n    vec3 q = p;\n    //hide noise to see basic structure\n    //*\n    q.xz *= rot(q.y*0.7);\n\tq.xy += tri(p.y*2.7 + T*2.6)*0.2;\n    q.xz *= rot(q.y*2.1);\n\tq.xy += tri(p.y*7.9 - T*11.6)*0.1;\n    //*/\n    \n    float dir = 1.0 * sign(op.y);\n    float width = W * n3D(q*22.0 + T*12.7)*3.3;\n    //primary\n    vec3 sp = loadSP(0.0, dir);\n    float prim = sdCapsule(q, \n                           op, \n                           sp,\n                           width);\n\n    \n    //secondary & tertiary\n    float seed = (dir>0.0) ? T*3.3 : T*-2.72;\n    float sec = bolt(q, \n                     pointOnLine(sp, op, clampHash11(seed)),\n                     3.0, \n                     9.0,\n                     dir,\n                     width,\n                     seed);\n    \n    seed = (dir>0.0) ? T*2.1 : T*3.78;\n    sec = min(sec, bolt(q, \n                        pointOnLine(sp, op, clampHash11(seed)),\n                        11.0, \n                        33.0,\n                        dir,\n                        width,\n                        23.2+seed));\n\n    seed = (dir>0.0) ? T*1.7 : T*5.71;\n    sec = min(sec, bolt(q, \n                        pointOnLine(sp, op, clampHash11(seed)),\n                        41.0, \n                        53.0,\n                        dir,\n                        width,\n                        73.2+seed));\n    \n    return vec2(min(prim, sec), width);    \n}\n\nvec2 map(\n    in vec3 p) \n{   \n    vec2 ha = (hash23(p + T*0.7) - 0.5) * 0.3,\n         hb = (hash23(p.zyx - T*0.3) - 0.5) * 0.3;\n    return near(lightning(p, vec3(ha.x, 3, ha.y)),\n                lightning(p, vec3(hb.y,-3, hb.x)));\n}\n\nvec3 march(\n    in vec3 ro, \n    in vec3 rd,\n    in float maxt) \n{\n    vec3 pc = vec3(0);\n    float t = 0.0;\n    for (int i=0; i<100; i++) {\n        vec3 p = ro + rd*t;\n        vec2 s = map(p);\n        if (t>maxt) break;\n        pc += vec3(0.0, s.y*2.0, 0.5) * 0.01 / (1.0 + s.x*s.x*0.1);\n        pc += vec3(s.y*3.0, s.y*7.0, 1.0) * 0.05 / (1.0 + s.x*s.x * 200.0);\n        t += s.x * 0.8;\n    }\n    return pc;\n}\n\n//Knarkowicz\n//https://www.shadertoy.com/view/4sSfzK\nfloat visibilityTerm(\n    float rL,\n    float ndotv, \n    float ndotl) \n{\n\tfloat r2 = rL*rL,\n\t      gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2),\n\t      gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn .5 / max(gv + gl, 0.00001);\n}\n\nfloat distributionTerm(\n    float rL, \n    float ndoth) \n{\n\tfloat r2 = rL*rL,\n\t      d = (ndoth * r2 - ndoth) * ndoth + 1.;\n\treturn r2 / (d*d*PI);\n}\n\nvec3 fresnelTerm(\n    vec3 sc, \n    float vdoth) \n{\n\treturn sc + (1. - sc) * pow((1. - vdoth), 5.);\n}\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nvec3 envBRDFApprox(\n    vec3 sc, \n    float rE, \n    float ndotv) \n{\n    const vec4 c0 = vec4(-1, -.0275, -.572, .022),\n               c1 = vec4(1, .0425, 1.04, -.04);\n    vec4 r = rE * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n    return sc * AB.x + AB.y;  \n}\n\nvoid mainImage(\n    out vec4 C, \n    in vec2 U) \n{\n    \n    vec3 ro,\n         la,\n         lp;\n    \n    vec3 rd = camera(U, R, ro, la, lp, 1.4, T);\n\n    vec2 uv = U/R;\n    float cy = 1.0 - abs(uv.y - 0.5) * 2.0,\n          n = noise(uv, 64., 16., float(iFrame), float(iFrame), 0.96);\n    vec3 pc = vec3(0,0,0.1) * pow(cy, 2.0);\n    pc += vec3(0.2,0.2,0.6) * pow(cy, 16.0);    \n    pc *= n;\n    \n    vec4 sphere = vec4(0,0,0, SPHERE_RAD);\n    float si = sphIntersect(ro, rd, sphere),\n          mint = (si>0.0) ? si : FAR;\n    \n    if (si > 0.0) {\n        \n        vec3 p = ro + rd*si, //surface position\n             n = normalize(p), //surface normal \n             ld = normalize(lp - p), //light direction\n             dfc = vec3(0.0), //diffuse base colour\n             spc = vec3(0.1, 0.1, 0.4), //specular base colour\n             lc = vec3(0.6, 0.4, 0.1), //light colour\n             diff = vec3(0.), //diffuse accumaltor\n             spec = vec3(0.), //specular accumalator\n             h = normalize(-rd + ld);\n        \n        float rG = mod(p.y, 0.4) > 0.2 ? 0.5 : 0.2, //roughness\n              rL = max(.01, rG*rG), //linear roughness\n              vdoth = clamp(dot(-rd, h), 0., 1.),\n              ndoth\t= clamp(dot(n, h), 0., 1.),\n              ndotv = clamp(dot(n, -rd), 0., 1.),\n              ndotl = clamp(dot(n, ld), 0., 1.);\n        \n        //reflections\n\t\tvec3 rc = march(p + n*EPS, reflect(rd, n), FAR);\n        vec3 esc = envBRDFApprox(spc, rG, ndotv);    \n        diff += esc * dfc * rc;\n        spec += esc * rc;\n\n        diff += dfc * lc * max(.05, dot(n, ld));\n\n        //specular term\n        vec3 lightF = fresnelTerm(spc, vdoth);\n\t    float lightD = distributionTerm(rL, ndoth);\n\t    float lightV = visibilityTerm(rL, ndotv, ndotl);\n        spec += lc * lightF * (lightD * lightV * PI * ndotl);\n\n        pc = diff + spec;      \n        pc = pow(pc * .6, vec3(1. / 2.2)); //gamma correction\n    }\n    \n    pc += march(ro, rd, mint);\n    \n    C = vec4(pc*3.0,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 30.0\n#define PI 3.14159\n#define T iTime\n\n#define SPHERE_RAD 1.0\n#define W 0.01\n\n//Shane IQ\nfloat n3D(\n    vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 hash33(\n    vec3 p) \n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec2 hash23(\n    vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash22(\n    vec2 p) \n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash11(\n    float p) \n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash12(\n    vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash21(\n    float p) \n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//fabrice\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nvec3 camera(\n    vec2 U, \n    vec2 r, \n    inout vec3 ro, \n    inout vec3 la, \n    inout vec3 lp, \n    float fl,\n    float t) \n{\n\n    la = vec3(0.0, 0.0, 0.0);\n    ro = vec3(0.0, sin(t*0.3)*0.6, -2.8 + sin((t+113.2) * 0.2)*0.6);\n    lp = vec3(6,5,-2);\n    \n    ro.xz *= rot(t*0.3);\n    \n    vec2 uv = (U - r*.5)/r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(\n    out vec4 C, \n    in vec2 U) \n{\n    float h1 = hash12(U + 20.0) - 0.5,\n          y = (U.y == 0.5) ? SPHERE_RAD : SPHERE_RAD * -1.0;\n    vec2 h2 = (hash22(U+111.3+T*0.9)-0.5) * 2.0;    \n    C = vec4(h2.x, y, h2.y, 1.0);\n    C.xz *= rot(T*h1*4.0);\n    C.xyz = normalize(C.xyz) * SPHERE_RAD;\n}","name":"Buffer A","description":"","type":"buffer"}]}