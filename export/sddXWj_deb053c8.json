{"ver":"0.1","info":{"id":"sddXWj","date":"1633995209","viewed":489,"name":"Cook-Torrance IS Attempt","username":"harry7557558","description":"Attempt to implement importance sampling for Cook-Torrance BRDF, somehow cannot get it right.\nLeft/Right: without/with importance sampling, look slightly different.\nIf someone could point out the problem or give a fix I'd appreciate :)","likes":20,"published":1,"flags":32,"usePreview":1,"tags":["sampling","sample","pbr","cooktorrance","importance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see Buffer A\nvoid mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Left: without importance sampling\n// Right: with importance sampling for GGX normal\n// The two versions look slightly different. Should be the same.\n\n// if there is no bug with GGX importance sampling,\n// left and right should be the same when this is set to 1\n#define DEBUG_GGX 0\n\n// References:\n// http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n// https://pbr-book.org/3ed-2018/Reflection_Models/Microfacet_Models\n// https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/\n// https://www.shadertoy.com/view/3slSzn\n// https://computergraphics.stackexchange.com/questions/4394/path-tracing-the-cook-torrance-brdf\n\n// A Desmos implementation of the BRDF:\n// https://www.desmos.com/calculator/zccocbuygk\n\n\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\n// random number generator\nuint seed = 0u;\nuint randu() { return seed = seed * 1664525u + 1013904223u; }\nfloat rand01() { return float(randu()) * (1./4294967296.); }\n\n\n// cubemap lighting\nvec3 light(vec3 rd) {\n    vec3 col = texture(iChannel1, rd.yzx).xyz;\n    vec3 bri = vec3(1.0) + vec3(2.0) * pow(max(dot(rd, normalize(vec3(-0.2, -0.5, 0.5))), 0.), 4.);\n    return col * bri;\n}\n\n\n// sphere intersection function\nbool intersectSphere(vec3 o, float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    ro -= o;\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.0) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\n\n// sample hemisphere distributions\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\nvec3 sampleUniformHemisphere(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rz = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(1.0-rz*rz) * vec2(cos(an), sin(an));\n    return rh.x * u + rh.y * v + rz * n;\n}\n\n\n// sample GGX, return weight (Fr divided by PDF)\n// At least one of the two functions have a bug\nfloat sampleGgxSimple(in vec3 wi, in float alpha, out vec3 wo) {\n    wo = sampleUniformHemisphere(vec3(0, 0, 1));\n    vec3 m = normalize(wi+wo);\n    float denom = (alpha*alpha-1.)*m.z*m.z+1.;\n    float Fr = alpha*alpha / (PI * denom*denom);\n    return Fr / (1.0/(2.0*PI));\n}\nfloat sampleGgxImportance(in vec3 wi, in float alpha, out vec3 wo) {\n    float su = 2.0*PI*rand01();\n    float sv = rand01();\n    //sv = acos(sqrt((1.0-sv)/((alpha*alpha-1.)*sv+1.)));\n    sv = atan(alpha*sqrt(sv/(1.0-sv)));\n    vec3 h = vec3(sin(sv)*vec2(cos(su),sin(su)), cos(sv));\n    wo = -(wi-2.0*dot(wi,h)*h);\n    return wo.z<0. ? 0. : 4.0*dot(wi, h);\n}\n\n\n// as global variable\nbool ImportanceSampling;\n\n\n// return random output ray direction, multiply m_col by weight\nvec3 sampleCookTorrance(\n    vec3 wi, vec3 n,\n    float alpha,  // roughness\n    float f0,  // ratio of reflection along the normal\n    float lambertian,  // ratio of lambertian coefficient\n    vec3 lambert_col,  // lambertian color\n    vec3 microfacet_col,  // microfacet color\n    inout vec3 m_col\n    ) {\n\n#if !DEBUG_GGX\n    if (ImportanceSampling) {\n        if (rand01() < lambertian) {\n            vec3 wo = sampleCosWeighted(n);\n            m_col *= lambert_col;\n            return wo;\n        }\n    }\n#endif\n\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    wi = vec3(dot(wi, u), dot(wi, v), dot(wi, n));\n    vec3 wo, m;  // out and half vector\n\n    // GGX divided by PDF\n    float D;\n    if (ImportanceSampling) D = sampleGgxImportance(wi, alpha, wo);\n    else D = sampleGgxSimple(wi, alpha, wo);\n    // uncomment to see if lambert sampling is ok\n    //D = sampleGgxSimple(wi, alpha, wo);\n\n    // debug GGX importance sampling\n#if DEBUG_GGX\n    m_col *= 0.25*D*wo.z; return wo.x*u+wo.y*v+wo.z*n;\n#endif\n    m = normalize(wi+wo);\n\n    // Geometry\n    float tan2_theta_i = (1.0-wi.z*wi.z)/(wi.z*wi.z);\n    float tan2_theta_o = (1.0-wo.z*wo.z)/(wo.z*wo.z);\n    float lambda_i = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_i)-1.0);\n    float lambda_o = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_o)-1.0);\n    float G = 1.0/(1.0+lambda_i+lambda_o);\n\n    // Fresnel\n    float F = f0 + (1.0-f0)*pow(1.0-dot(wi, m), 5.0);\n\n    // Put all together\n    float Fr = D*G*F / (4.0*wi.z*wo.z+1e-4);\n    float Fr_cos = Fr * wo.z;  // wo is the direction of light in path tracing\n    if (ImportanceSampling) {\n        m_col *= Fr_cos * microfacet_col;\n    }\n    else {\n        vec3 col = lambertian * lambert_col / (1.0/2.0) + (1.0-lambertian) * microfacet_col * Fr;\n        m_col *= col * wo.z;\n    }\n    return wo.x * u + wo.y * v + wo.z * n;\n}\n\n\n// path tracing\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    const int background = -1;\n    const int lambertian = 0;\n    const int mat_floor = 1;\n\n    vec3 m_col = vec3(1.0), col;\n    bool is_inside = false;\n\n    for (int step = int(ZERO); step < 64; step++) {\n        ro += 1e-4f*rd;\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        int material = background;\n\n        // plane\n        t = -ro.z / rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            col = vec3(0.9, 0.95, 0.98);\n            //material = lambertian;\n            material = mat_floor;\n        }\n\n        // objects\n        for (float i = 0.; i < 6.; i++) {\n            t = min_t;\n            vec3 pos = vec3(2.2*vec2(cos(2.*PI*i/6.), sin(2.*PI*i/6.)), 1.0+1e-4);\n            if (intersectSphere(pos, 1.0, ro, rd, t, n)) {\n                min_t = t, min_n = n;\n                col = vec3(1.0);\n                material = int(i)+2;\n            }\n        }\n\n        // update ray\n        if (material == background) {\n            col = light(rd);\n            return m_col * col;\n        }\n        ro = ro + rd * min_t;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;\n        if (material == lambertian) rd = sampleCosWeighted(min_n), m_col *= col;\n        if (material == mat_floor) rd = sampleCookTorrance(-rd, min_n, 0.3, 0.4, 0.2, col, col, m_col);\n        if (material == 2) rd = sampleCookTorrance(-rd, min_n, 0.8, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 3) rd = sampleCookTorrance(-rd, min_n, 0.4, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 4) rd = sampleCookTorrance(-rd, min_n, 0.1, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 5) rd = sampleCookTorrance(-rd, min_n, .02, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 6) rd = sampleCookTorrance(-rd, min_n, 0.1, 0.4, 0.5, vec3(0.8,0.4,0.1), vec3(1.0), m_col);\n        if (material == 7) rd = sampleCookTorrance(-rd, min_n, .01, 0.4, 0.2, vec3(0.8,1.0,0.8), vec3(0.6,0.6,1.0), m_col);\n        if (m_col == vec3(0.0)) break;\n        if (dot(rd, min_n) < 0.0) is_inside = !is_inside;\n        if (is_inside) return vec3(1, 0, 0);  // should not happen\n    }\n    return m_col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ImportanceSampling = fragCoord.x > 0.5*iResolution.x;\n\n    // https://www.shadertoy.com/view/4djSRW by David Hoskins, MIT licence\n    vec3 p3 = fract(vec3(fragCoord/iResolution.xy, sin(0.001*float(iFrame))) * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    seed = uint(16777216.*h);\n\n    // camera\n    vec2 mouse_uv = iMouse.z==0. ? vec2(0.6,0.4) : iMouse.xy/iResolution.xy;\n    float rx = 1.8*mouse_uv.y-0.3;\n    float rz = -mouse_uv.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(rand01(),rand01())-0.5)/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 1.8*length(iResolution.xy));\n    rd = normalize(rd);\n\n    // calculate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}