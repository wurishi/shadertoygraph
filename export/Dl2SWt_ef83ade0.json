{"ver":"0.1","info":{"id":"Dl2SWt","date":"1677129947","viewed":75,"name":"ifs onion","username":"pb","description":"enjoy","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// using lighting techniques from: https://www.shadertoy.com/view/4tGGRV by zackpudil\n// philip.bertani@gmail.com\n\nint max_iter = 5;  //play with this\nfloat ifs_scale, myTime;\nvec3 ro;\n\n\n//hard coding the vertices for a dodecahedron\nconst float gmh=(sqrt(5.)+1.)/2.;\nconst float gmi=1./gmh;\n\nvec3[] d12 = vec3[]  (\nvec3(1.,1.,1.),\nvec3(1.,1.,-1.),\nvec3(1.,-1,1.),\nvec3(1.,-1,-1.),\nvec3(-1,1.,1.),\nvec3(-1.,1.,-1),\nvec3(-1.,-1.,1.),\nvec3(-1.,-1.,-1.),\nvec3(0.,gmh,gmi),\nvec3(0.,gmh,-gmi),\nvec3(0.,-gmh,gmi),\nvec3(0.,-gmh,-gmi),\nvec3(gmi,0.,gmh),\nvec3(gmi,0.,-gmh),\nvec3(-gmi,0.,gmh),\nvec3(-gmi,0.,-gmh),\nvec3(gmh,gmi,0.),\nvec3(gmh,-gmi,0.),\nvec3(-gmh,gmi,0.),\nvec3(-gmh,-gmi,0.)\n);\n\n\nfloat hash(float n) {\n    return fract(sin(n)*50000.);\n}\n\n\nmat3 rotx(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(1,0.,0.,0.,cc,-ss,0.,ss,cc);\n\n}\n\nmat3 rot(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(cc,0.,-ss,0.,1.,0.,ss,0.,cc);\n\n}\n\n\n//dodecahedral ifs here\nfloat de(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    float n=0.;\n    float min_dist,dist_to_vtx;\n\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        float sc = 4.;\n        float w = myTime/2.;\n        vec3 dd_0 = rot(w)*d12[0]*sc;\n        min_vtx = dd_0;\n        min_dist=length(z-dd_0);\n        for (int j=1; j<20; j++) {\n            vec3 ddj = rot(w)*d12[j]*sc;\n            dist_to_vtx=length(z-ddj); \n            if (dist_to_vtx<min_dist) {min_vtx=ddj; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n                \n        n++;\n        \n    }\n\n    \n    float dz = pow(ifs_scale, float(n) );\n    \n    float f = (length(z)-(.07+myTime/20.))/dz;\n    \n    f = max( f, -(length(orig_z-ro)-4.1) );\n    \n    return f;\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    for(int i = 0; i < 80; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.001 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n1 = vec3(\n        de(p + h.xyy),\n        de(p + h.yxy),\n        de(p + h.yyx)\n\t);\n    \n    vec3 n2 = vec3(\n        de(p - h.xyy),\n        de(p - h.yxy),\n        de(p - h.yyx)\n\t);\n    \n    return normalize(n1 - n2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    myTime = mod(iTime,20.);\n    ifs_scale = 1.1 + myTime/60. ;\n    \n    ro = vec3(0.,0.,7.5);\n    vec3 rd = normalize( vec3(uv, -2.));\n    \n    vec3 col = vec3(.1,.2,.4);\n    \n    float t = trace(ro, rd, 30.0);\n    if(t > 0.0) {\n        float edg;\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n               \n     \n        vec3 lig = normalize(-pos);\n        float dis = length(pos);\n        \n        // direct lighting with hard shadows.\n        col += .7*clamp(dot(lig, nor), 0.0, 1.0)\n            *step(0.0, -trace(pos + nor*0.001, lig, dis));\n        \n        // indirect lighting\n        col += .5*clamp(dot(-lig, nor), 0.0, 1.0);\n        \n        // decay with distance\n        col *= exp(-t/10.);\n  \n\n    }\n    \n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}