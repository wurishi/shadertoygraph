{"ver":"0.1","info":{"id":"MtScRd","date":"1509727941","viewed":665,"name":"Opacity/Ordered Dithering","username":"Lunatunny","description":"This shader makes a 4x4 pattern using an opacity parameter that works between 0.0 and 1.0 then repeats it across the screen.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","game","video","halftone","videogame","dithering","games","ordereddithering","halftoning","opacitydithering","videogames"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This function calculates a 4x4 pattern based on the opacity parameter.\n//The opacity parameter works on a 0.0 - 1.0 range.\nmat4 patCalc(float opacity)\n{\n    //Initialize the return value matrix\n    //This matrix will store our 4x4 pattern.\n    mat4 retval = mat4(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0)\n        );\n    \n    //We multiply our opacity by 16 and store it in a variable.\n    int dPatlvl = int(abs(opacity*16.0));\n    \n    //We calculate the pattern with a loop\n    for(int i = 1; i <= dPatlvl; i++)\n    {\n        int xPat; int yPat; //Initiate xPat and yPat\n        float iFl = float(i); //I made a variable for i as a float to save myself from messy code\n        \n        //xPat gets offset by how divisible it is by 2, 4, and 8.\n        xPat = int(floor(iFl/2.0)*2.0 + floor((iFl-1.0)/4.0) - floor((iFl-1.0)/8.0));\n        xPat -= int(floor(float(xPat)/4.0)*4.0);//We sorta \"screen wrap\" the xPat value so that it loops itself back into the matrix's range\n        \n        //yPat gets offset by how divisible it is by 2 and 4.\n        yPat = int(abs(sign(mod(iFl, 2.0))-1.0)*2.0 + floor((iFl-1.0)/4.0));\n        yPat -= int(floor(float(yPat)/4.0)*4.0);//We also \"screen wrap\" the yPat value so that it loops itself back into the matrix's range\n        \n        //We write retval[xPat][yPat] to equal 1.0\n        //shadertoy wouldn't let me say retval[xPat][yPat] = 1.0;\n        //so I had to work around it using a vec4 and offset numbers.\n        retval[xPat] += vec4(\n            abs(sign(abs(yPat))-1),\n            abs(sign(abs(yPat-1))-1),\n            abs(sign(abs(yPat-2))-1),\n            abs(sign(abs(yPat-3))-1));\n    }\n    \n    return retval;\n}\n\nmat4 dPattern; //We use this variable to store our actual 4x4 pattern\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //I used the time as the opacity parameter and made it loop.\n    //If your program allows it then you should call this calculation\n    //outside of the void so that it only runs once rather than on every single pixel\n    dPattern = patCalc(iTime/5.0 - floor(iTime/5.0));\n    //In your own game you would probably say:\n    //dPattern = patCalc(opacity);\n    \n    //We find the corresponding pattern position to our screens x and y\n    //So we essentially \"screen wrap\" the screen coordinates between 0 and 3.\n    int xPos = int(floor(fragCoord.x - floor(fragCoord.x/4.0)*4.0));\n    int yPos = int(floor(fragCoord.y - floor(fragCoord.y/4.0)*4.0));\n    \n    //float a contains either 1.0 or 0.0 to coorispond with the pixel opacity.\n    float a = dPattern[xPos][yPos];\n    \n    //We set our fragColor!\n    fragColor = vec4(0.0+a*0.3,0.0+a*0.7,0.0+a*0.5,1.0);\n    //in your actual game you would probably use:\n    //fragColor.a = a;\n}","name":"Image","description":"","type":"image"}]}