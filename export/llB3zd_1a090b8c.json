{"ver":"0.1","info":{"id":"llB3zd","date":"1431418983","viewed":172,"name":"sand sponge ","username":"joeedh","description":"Erosion with noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sandspongeerosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//ray march steps\n#define STEPS 100\n\nfloat noise(vec2 xy) {\n    //xy = mod(xy, 1.0);\n    \n    //xy *= 0.2;\n    //xy *= 200.0;\n    if (xy[0] == 0.0) xy[0] += 0.00001;\n    if (xy[1] == 0.0) xy[1] += 0.00001;\n    \n    float t = fract(1.0 / (0.0001 + abs(0.001*sin(xy[0]-123.0*xy[0]*xy[1]))));\n    t = fract(1.0/(0.00001+fract(t + 200.0*xy[0] / (0.000001+abs(20.0*xy[1])))));\n    return abs(t);\n}\n\nvec2 noise2(vec2 xy) {\n    float a = noise(xy), b = noise(vec2(a+xy[1], a-xy[0]));\n    \n\treturn normalize(vec2(a, b))*0.35;\n}\n\nfloat smoothstep2(float a, float b, float t) {\n    float t3=t*t*t, t4=t3*t, t5=t4*t;\n    \n    t = 6.0*t5 - 15.0*t4 + 10.0*t3;\n    return a + (b - a)*t;\n}\nfloat pnoise2(vec2 uv, float sz) {\n    float u = uv[0]/sz, v = uv[1]/sz, fu = floor(u), fv = floor(v);\n    \n    float c1 = noise(vec2(fu, fv)*sz); \n    float c2 = noise(vec2(fu, fv+1.0)*sz); \n    float c3 = noise(vec2(fu+1.0, fv+1.0)*sz); \n    float c4 = noise(vec2(fu+1.0, fv)*sz); \n    \n    u -= fu; v -= fv;\n    \n    u = smoothstep(0.0, 1.0, u);\n    v = smoothstep(0.0, 1.0, v);\n    \n    float r1 = c1 + (c2 - c1)*v;\n    float r2 = c4 + (c3 - c4)*v;\n    \n    float r = r1 + (r2 - r1)*u;\n    \n    return r;\n}\n\nfloat pnoise(vec3 uvz, float sz) {\n    float zu = floor(uvz[2]/sz)*sz;\n    float a = pnoise2(uvz.xy+zu*4.0, sz);\n    float b = pnoise2(uvz.xy+(zu+sz)*4.0, sz);\n    \n    float z = 1.0-fract(abs(uvz[2]/sz));\n    z = smoothstep(0.0, 1.0, z);\n    \n    return a + (b - a)*z;\n}\n\nfloat atan2(float x, float y) {\n    if (x > 0.0) {\n        return atan(y / x);\n    } else if (y >= 0.0 && x < 0.0) {\n        return atan(y/x) + 3.14159;\n    } else if (y < 0.0 && x < 0.0) {\n        return atan(y/x) - 3.14159;\n    } else if (y > 0.0 && x == 0.0) {\n        return 3.14159*0.5;\n    } else if (y < 0.0 && x == 0.0) {\n        return -3.14159*0.5;\n    } else {\n    \treturn 0.0;\n    }\n}\n\nfloat atan2(vec2 xy) {\n    return atan2(xy[1], xy[0]);\n}\n\nfloat manlen(vec2 vec) {\n    vec = abs(vec);\n    return vec[1]+vec[0];\n}\n\n//float noise(vec3 pos) {\n//    return fract(1.0/sin(length(pos)*3.5+pos[0]*pos[1]*1.0)*0.5+0.5)*0.5+0.5;\n//}\n\nfloat func1(float p, float s, float m) {\n    //m = 9.0;\n    m = floor(m);\n    \n    float r1 = float(mod(floor(p*s*m - m*0.5), m) != 0.0); \n    \n    return r1;\n}\nfloat funca(float p, float s, float m) {\n    float r1 = func1(p, s, 4.0);\n\n    return r1;\n}\nfloat funcb(float p, float s, float m) {\n    float r2 = func1(p+0.5, s, 3.0);\n\n    return r2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n/*\non factor;\noff period;\n\nprocedure length(px, py, pz);\n\tsqrt(px*px + py*py + pz*pz);\n\nprocedure sdBox(px, py, pz, bx, by, bz);\n\tmin(max(abs(px)-bx, max(abs(py)-by, abs(pz)-bz)), 0)\n    + length(max(abs(px)-bx, 0), max(abs(py)-by, 0),\n             max(abs(pz)-bz, 0));\nsdbox(px + rx*s, py + ry*s, pz + rz*s, w, w, w);\n\n*/\n\n\nfloat box(vec3 pos, float w) {\n   return -sdBox(pos, vec3(w,w,w));\n}\n\nfloat crossb(vec3 pos, float w) {\n    float b1 = box(vec3(pos[0], pos[1], 0.0), w);\n    float b2 = box(vec3(pos[0], 0.0, pos[2]), w);\n    float b3 = box(vec3(0.0, pos[1], pos[2]), w);\n    \n    return max(max(b1, b2), b3);\n}\n\nfloat sponge(vec3 pos, float w) {\n    float c1 = crossb(pos, w);\n    float c2 = box(pos, w*3.0);\n    \n    return min(-c1, c2);\n}\n\nfloat density(vec3 pos, float sz) {\n    \n    float w = 0.15;\n    \n    //pos += pnoise(pos, 0.3)*0.1-0.1;\n    vec3 opos = pos;\n    float x = pos[0], y = pos[1], z = pos[2];\n    float t1 = abs(fract(0.8+iTime*0.1)-0.5)*2.0*1.15 + 0.15;\n    \n    float c = sponge(pos, w);\n    float sz1 = (t1)*1.5; //(t1*0.5+0.5)*2.0;\n    float p = (1.0-pnoise(pos*sz1, 0.3))-0.4*t1*2.0;\n    \n    c = min(c, p);\n    for (int i=0; i<3; i++) {\n\t    pos *= 3.0;\n    \tfloat c2 = sponge(mod(pos + w*0.5, w*3.0), w);\n        c = min(c, c2);\n    }\n    return c;\n    \n}\n\nvec3 sample1(vec3 p, vec3 d) {\n    float t=0.0, ret=0.0, dt, dt1=1.0/float(STEPS), dt2=dt1*1.0;\n    float sum = 0.0, r=0.0;\n    float first = 1.0, df=0.0;\n    float fac, lastdf, lastr=density(p - d*dt1, 1.0);\n    \n    dt = dt1;\n    \n    for (int i=0; i<STEPS; i++) {\n        r = density(p + d*t, 1.0);\n\t\t     \n        if (abs(r) < 0.00001) {\n           \tsum = 1.0;\n            break;\n        }\n        \n        //df = (r-lastr)/dt;\n        \n        float r2 = density(p + d*(t+0.001), 1.0);\n        lastdf = df;\n        df = (abs(r2)-abs(r))/0.001 + 0.000;\n      \n        ///*\n        fac = (-abs(r)/df);\n        \n        dt = -r*23.0*dt1; //(r+lastr)*0.5;\n        \n            \n        lastr = r;\n        t += dt;\n        if (t < 0.0) t = 0.0;\n    }\n    \n    float t2 = t - 0.1;\n    vec3 pos = p + d*t;\n    \n#define DF1 0.0001\n    \n    float r2 = density(vec3(pos[0]+DF1, pos[1], pos[2]), 1.0);\n    float r3 = density(vec3(pos[0], pos[1]+DF1, pos[2]), 1.0);\n    float r4 = density(vec3(pos[0], pos[1], pos[2]+DF1), 1.0);\n   // float r6 = density(p + d*(t+0.005), 1.0);\n    \n    vec3 norm = vec3(r2, r3, r4)/DF1;\n    \n    //df = (abs(r2)-abs(r))/0.001 + 0.000;\n    norm = normalize(norm);\n    norm *= -0.1;\n    float r5 = density(pos+norm, 1.0);\n    \n    //abs(abs(df-df)\n    //float ao = (abs(r6)*0.5 + abs(r)*0.5)/0.005;\n    //ao = (0.5*abs(df)+(1.0-ao*0.9))*0.9;\n    float ao2 = 1.0-t;\n    ao2 = 1.0-r5*1.0;\n    ao2 = pow(min(ao2*0.96, 1.0), 50.0);\n    ao2 = ao2*(1.0-t*t*t*0.4)*1.4;\n    return vec3(ao2, t, dt);\n}\n\nvec3 getray(vec2 uv) {\n    return normalize(vec3(uv, -1.0));\n}\n\nvec2 rot2d(vec2 v, float th) {\n    return vec2(sin(th)*v[1] + cos(th)*v[0], sin(th)*v[0] - cos(th)*v[1]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 uv = vec3((fragCoord.xy-iResolution.xy*0.5) / iResolution.x, 0.0);\n    float th1 = iTime*0.9;\n    float rr = 1.0;\n    vec3 origin = vec3(cos(th1)*rr, sin(th1)*rr, 0.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    //uv *= 2.0;\n\tvec3 up = normalize(cross(origin-target, vec3(0.0, 0.0, 1.0)));\n    vec3 cr = normalize(cross(up, origin-target));\n    vec3 zc = normalize(origin-target);\n    \n    vec3 ray = origin + up*uv[0] + cr*uv[1];\n    ray = normalize(ray - (origin+zc*0.5)) ;// - origin);\n    float c1=0.0;\n    //vec3 ray = -normalize((origin + uv) - target);\n    float c = 0.0, totw = 0.0, ts=0.0, mint=100.0, maxt=-100.0, thet;\n    \n    #define DF 0.000001\n\n    vec3 isect = sample1(origin, ray);\n    float ft = isect[1];\n    vec3 pos = origin + ray*isect[1];\n    float r0 = density(pos, 1.0);\n    float r1 = (density(pos+vec3(DF, 0.0, 0.0), 1.0)-r0)/DF;\n    float r2 = (density(pos+vec3(0.0, DF, 0.0), 1.0)-r0)/DF;\n    float r3 = (density(pos+vec3(0.0, 0.0, DF), 1.0)-r0)/DF;\n\n    vec3 norm = normalize(vec3(r1, r2, r3));\n\n    float spec = dot(normalize((norm+ray)), normalize(vec3(0, -1, 0)));\n    spec = max(spec, 0.0);\n    spec = pow(spec*1.0, 60.0);\n    float diffa = max(dot(norm, normalize(vec3(10.0, 0.5, 2.0))), 0.0);\n    float diffb = max(dot(norm, normalize(vec3(-20.0, 0.5, 2.0))), 0.0)*0.2;\n\n    //abs((0.2+0.6*spec+diffa*0.5+diffb))\n    float light = abs((spec*0.0+diffa*0.5+diffb))*1.0;\n    light = min(max(light, 0.0), 1.0);\n\n    c = isect[0] != 0.0 ? isect[0]*0.2 + 3.0*isect[0]*0.5*min(max(light, 0.0), 1.0) : 0.0;\n\n\tfragColor = vec4(c*1.5, c*1.32, c*0.9, 1.0);\n    fragColor = fragColor*0.6+0.2;\n}","name":"Image","description":"","type":"image"}]}