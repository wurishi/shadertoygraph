{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Voronoi noises\n// by Pietro De Nicola\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define SCALE\t\t   10.0\t\t// 3.0\n#define BIAS   \t\t   +0.0\n#define POWER\t\t\t1.0\t\t\n#define OCTAVES   \t\t2\t\t// 7\n#define SWITCH_TIME \t5.0\t\t// seconds\n#define WARP_INTENSITY\t0.00\t// 0.06\n#define WARP_FREQUENCY\t16.0\n\n\n//------------------------------------------------------------\n// print helper\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n//------------------------------------------------------------\n\n\n\n\n//\n// Noise functions\n//\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat voronoi( in vec2 x )\n{\n    float t = iTime/SWITCH_TIME;\n\tfloat function \t\t\t= mod(t,4.0);\n    bool  multiply_by_F1\t= mod(t,8.0)  >= 4.0;\n\tbool  inverse\t\t\t= mod(t,16.0) >= 8.0;\n\tfloat distance_type\t\t= mod(t/16.0,4.0);\n    \n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tfloat F1 = 8.0;\n\tfloat F2 = 8.0;\n\t\n\t\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(i,j);\n        vec2 o = hash( n + g );\n\n        o = 0.5 + 0.41*sin( iTime + 6.2831*o ); // animate\n\n\t\tvec2 r = g - f + o;\n\n\t\tfloat d = \tdistance_type < 1.0 ? dot(r,r)  :\t\t\t\t// euclidean^2\n\t\t\t\t  \tdistance_type < 2.0 ? sqrt(dot(r,r)) :\t\t\t// euclidean\n\t\t\t\t\tdistance_type < 3.0 ? abs(r.x) + abs(r.y) :\t\t// manhattan\n\t\t\t\t\tdistance_type < 4.0 ? max(abs(r.x), abs(r.y)) :\t// chebyshev\n\t\t\t\t\t0.0;\n\n\t\tif( d<F1 ) \n\t\t{ \n\t\t\tF2 = F1; \n\t\t\tF1 = d; \n\t\t}\n\t\telse if( d<F2 ) \n\t\t{\n\t\t\tF2 = d;\n\t\t}\n    }\n    \n\t\n\tfloat c = function < 1.0 ? F1 : \n\t\t\t  function < 2.0 ? F2 : \n\t\t\t  function < 3.0 ? F2-F1 :\n\t\t\t  function < 4.0 ? (F1+F2)/2.0 : \n\t\t\t  0.0;\n\t\t\n\tif( multiply_by_F1 )\tc *= F1;\n\tif( inverse )\t\t\tc = 1.0 - c;\n\t\n    return c;\n}\n\nfloat fbm( in vec2 p )\n{\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat a = 0.5;\n\t\n\tfor( int i=0; i<OCTAVES; i++ )\n\t{\n\t\ts += a * voronoi(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn s/m;\n}\n\n//\n// Main\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n\tfloat w = noise( p * WARP_FREQUENCY );\n\tp += WARP_INTENSITY * vec2(w,-w);\n    float c = POWER*fbm( SCALE*p ) + BIAS;\n    vec3 color = c * vec3( 0.7, 1.0, 0.9 );\n    \n    // print t\n    vec2 fontsize = vec2(8.0, 15.0);\n    vec2 position = vec2(0.0, 0.0);\n    float t = iTime/SWITCH_TIME;\n    float prn = PrintValue(fragCoord, position + vec2(0.0, 6.0), fontsize, t, 1.0, 0.0);\n    color = mix( color, vec3(0.7, 0.0, 0.0), prn);\n\t\n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsjGWD","date":"1388530844","viewed":3930,"name":"Voronoi noises","username":"piero","description":"This is a sequence of 64 voronoi noise variations, some of which may hopefully inspire your new works.","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi"],"hasliked":0,"parentid":"","parentname":""}}