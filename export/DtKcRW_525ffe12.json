{"ver":"0.1","info":{"id":"DtKcRW","date":"1701346291","viewed":123,"name":"Countach (4k intro)","username":"derangedlines","description":"This is the shader code responsible for creating the visuals for my 4k intro \"Countach\" released at Experience 2023 demoparty.\n\nMore information and orignal release (with music) here:\nhttps://www.pouet.net/prod.php?which=95507","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["retro","outrun","car"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is the shader code responsible for creating the visuals\n// for my 4k intro \"Countach\", released at Experience 2023 demoparty\n\n// For more info, video and download link, check out the released intro here:\n// https://www.pouet.net/prod.php?which=95507\n\n\n// Huge thanks to iq for the many articles, tutorials, examples,\n// and templates that have guided me throughout this journey.\n\n// Additionally, thank YOU for sharing your code and sketches\n// here, you were a great inspiration and learning guide for me.\n\n// In order to compress the file size of the final executable,\n// I used shader minifier by Ctrl-Alt-Test and Crinkler by Mentor + Blueberry.\n// Because of this, some parts of the code may not be the cleanest,\n// but I was able to achieve sufficient compression with this version.\n\n// The release version was using a global \"uniform\" float variable for time,\n// to synch with the music, I replaced these with \"iTime\" so the code still\n// works as intended.\n\n// Similarly for shadertoy compatibility:\n//  - \"gl_FragCoord\" was replaced by \"fragCoord\"\n//  - \"gl_FragColor\" was replaced by \"fragColor\"\n//  - \"void main(void)\" was replaced by \"void mainImage(out vec4 fragColor, vec2 fragCoord)\"\n//  - hardcoded resolution was replaced by \"iResolution\"\n\n// Also I rearranged function definitions for easier understanding (hopefully)\n\n// I will try to make the whole project available on github soon, but\n// it'll take some extra time, as I'd like to do some cleaning up before.\n\n// Now, a brief overview of how the intro is constructed:\n// There's a single scene with visual alterations to add variety.\n// The scene consists of a raytraced car model inside a hollow hemisphere.\n// Moving textures are then projected onto the sphere surface and the bottom\n// plane separately to fake the illusion of movement.\n\n// Based on this, the following subscenes are created:\n//  0-16s  - empty road   - Car model is not drawn\n// 16-32s  - dark intro   - Color palette is completely black, ground is solid color, light source is orbiting around car, ambient light is negative, so only reflections appear\n// 32-48s  - dark intro 2 - Same as previous, but with flickering ambient light added back in\n// 48-64s  - normal       - I consider this the base scene with no alterations\n// 64-80s  - racing       - Camera position is fixed third person, sky colors are scrolling faster\n// 80-96s  - outrun       - Grid for ground, line pattern for background\n// 96-112s - normal 2     - Same as normal, but different color palettes and camera positions\n\n\n// Constants\nfloat PI = 3.14159;\n\n// Road parameters\nfloat ROADWIDTH = 5.0;\nfloat LANEWIDTH = 4.0;\nfloat STRIPEWIDTH = 0.1;\n\n// Visual style\nfloat DOWNSCALE = 4.0;\nfloat QUANTIZE = 0.2;\n\n// Bayer matrices for dithering\nfloat bayer2(vec2 a) { a = floor(a);return fract(dot(a, vec2(.5, a.y * .75))); }\nfloat bayer4(vec2 a) { return bayer2(.5 * a) * .25 + bayer2(a); }\nfloat bayer8(vec2 a) { return bayer4(.5 * a) * .25 + bayer2(a); }\n// Higher level matrices were not used\n//float bayer16(vec2 a) { return bayer4(.25 * a) * .0625 + bayer4(a); }\n//float bayer32(vec2 a) { return bayer8(.25 * a) * .0625 + bayer4(a); }\n//float bayer64(vec2 a) { return bayer8(.125 * a) * .015625 + bayer8(a); }\n//float bayer128(vec2 a) { return bayer16(.125 * a) * .015625 + bayer8(a); }\n\n// Materials\n// x, y, z are for color,\n// w is for shininess\nvec4 MAT_BODY  = vec4(  1, 0.8, 0.1, 1); //Shiny yellow\nvec4 MAT_GLASS = vec4(  0,   0,   0, 1); //Shiny black\nvec4 MAT_TYRE  = vec4(0.1, 0.1, 0.1, 0); //Matte dark grey\nvec4 MAT_RIM   = vec4(1); //Shiny white\nvec4 MAT_LIGHT = vec4(5); //Glowing white (or at least an approximation)\n\n// This could probably be improved, but I couldn't figure out a solution:\n// map function expects a material variable as an argument, which is used\n// to tell the material of objects when drawing the image. For things like\n// shadows, map function is also needed, but material is not important.\n// Because of this I decided to create a global dummy material that can be\n// provided as an argument, but is never used.\nvec4 dummy;\n\n// Simple noise with two cosines.\n// This is used for every random looking element,\n// like heights of mountains and curvature of the road.\nfloat noise(in vec2 p) {\n    return 0.5 * (cos(p.x * 3.0) + cos(p.y * 4.0));\n}\n\n// Returns an angle using the current noise values.\n// In order to achieve coherent movement and scenery with a single noise,\n// a scaling and time delay parameter are used.\nfloat angle(float delay, float scale) {\n    return scale * noise(vec2(0.2 * (float(iTime > 48.) * iTime - delay)));\n}\n\n// Continuous color palette generation.\n// Thank you iq!\n// https://iquilezles.org/articles/palettes/\n//\n// Color palettes are sampled multiple times, for sky, sun color,\n// scenery color, lighting...basically defining a scene visually.\n\nvec3 sky (float x) {\n   // Change palettes based on music (time)\n   // Visualization: https://graphtoy.com/?f1(x,t)=floor(4*fract(x/16)+clamp((x-64)/4,0,4))\n   int i_scene = int(4.0 * fract(iTime/16.0) + clamp((iTime-64.0)/4.0, 0.0, 4.0));\n\n    // Dark intro\n    if(iTime > 16. && iTime < 48.)\n        return vec3(0);\n\n    // Day - default\n    vec3 a = vec3(1.0, 0.8, 0.2);\n    vec3 b = vec3(0.8, 0.6, 0.4);\n    vec3 c = vec3(0.7, 0.7, 0.5);\n    vec3 d = vec3(0.0, 0.0, 0.9);\n    // Ice\n    if(i_scene==1) {\n        a = vec3(0.5, 0.6, 1.0);\n        b = vec3(0.2, 0.2, 0.5);\n        //c = vec3(0.7, 0.7, 0.5); // Same as default, so commented to save a few bytes\n        //d = vec3(0.0, 0.0, 0.9); // Same as default, so commented to save a few bytes\n    }\n    // Desert\n    if(i_scene==2) {\n        a = vec3(0.5);\n        b = vec3(0.5);\n        c = vec3(0.5);\n        d = vec3(0.0, 0.1, 0.2);\n    }\n    // Tricolor\n    if(i_scene==3) {\n        a = vec3(0.7, 0.3, 0.2);\n        b = vec3(0.8, 0.5, 0.1);\n        c = vec3(0.5, 0.5, 0.7);\n        d = vec3(0.1, 0.1, 0.5);\n    }\n    // Outrun\n    if(i_scene==4) {\n        a = vec3(0.4, 0.0, 0.4);\n        b = vec3(0.5, 0.1, 0.4);\n        c = vec3(0.5, 0.7, 0.7);\n        d = vec3(0.1, 0.7, 0.7);\n    }\n    // Green\n    if(i_scene==7) {\n        a = vec3(0.3, 0.4, 0.3);\n        b = vec3(0.4, 0.4, 0.3);\n        c = vec3(0.5, 0.5, 0.7);\n        d = vec3(0.0, 0.0, 0.6);\n    }\n    // Mars\n    if(i_scene==6) {\n        a = vec3(0.0, 0.3, 0.0);\n        b = vec3(0.5, 0.8, 0.2);\n        c = vec3(0.5, 0.2, 0.5);\n        d = vec3(0.9, 0.2, 0.0);\n    }\n    // Sin City\n    if(i_scene==5) {\n        a = vec3(0.9);\n        b = vec3(1.0);\n        c = vec3(0.2);\n        d = vec3(0.3);\n    }\n    return a + b * cos(2.0 * PI * (c*x + d));\n}\n\n/* SDF primitives */\n\n//Box\nfloat SDFBox(vec3 position, vec3 center, vec3 size) {\n    vec3 q = abs(position - center) - 0.5 * size;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Horizontal cylinder pair\n// 2.4 apart, since it's only used for wheel related parts\nfloat SDFCylinder(vec3 p, float h, float r)\n{\n    p.x = abs(p.x) - 0.5 * 2.4;\n    vec2 d = abs(vec2(length(p.yx), p.z)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/* SDF transformations */\n\n// 3D rotations\n// Probably could be optimized further by having a single\n// function for rotation around arbitrary axis.\nvec3 rotateX(float theta, vec3 v) {\n    return vec3(v.x, v.y * cos(theta) - v.z * sin(theta), v.y * sin(theta) + v.z * cos(theta));\n}\n\nvec3 rotateY(float theta, vec3 v) {\n    return vec3(v.x * cos(theta) + v.z * sin(theta), v.y, -v.x * sin(theta) + v.z * cos(theta));\n}\n\nvec3 rotateZ(float theta, vec3 v) {\n    return vec3(v.x * cos(theta) - v.y * sin(theta), v.x * sin(theta) + v.y * cos(theta), v.z);\n}\n\n// Symmetry (only Z axis is used)\nvec3 mirrorZ(vec3 v) {\n    return vec3(v.xy, abs(v.z));\n}\n\n// Smooth union and substraction\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// Countach\n// This function defines the scene by returning the distance of the nearest point from given\n// position. Also returns the material for that point, via the \"out\" argument.\n// There's a car model aways at the origin, and a ground plane underneath\nfloat map(in vec3 position, out vec4 material) {\n    // Maximum distance\n    float d = 96.0;\n    float d_mat = 96.0;\n\n    // This is something that could be improved:\n    // When I started working on the intro, I modelled the car and created the rest of the\n    // scene separately, and the car ended up in a different orientation than the rest.\n    // Rotating the whole model is a quick fix, a better approach would be to remodel the\n    // car in the right orientation.\n    position = rotateY(PI/2.0, position);\n\n    // Car model only shown after 16s (empty road scene)\n    if(iTime > 16.) {\n        // Windshield\n        d = min(d, SDFBox(position, vec3(0.5, 0.85, 0), vec3(1.5,0.35,1.84))); //roof\n        // These few lines are used over and over to set material for different objecks.\n        // by keeping track of the distance for previous materials, and checking the\n        // difference.\n        if (abs(d-d_mat) > .001)\n           material = MAT_BODY;\n        d_mat = d;\n    \n        d = opSmoothSubtraction(SDFBox(rotateX(0.9,mirrorZ(position)), vec3(0, 0, 1.6), vec3(3,1,1)), d, 0.03); //side window angle\n        d = opSmoothSubtraction(SDFBox(rotateZ(0.4,rotateY(0.3,mirrorZ(position))), vec3(0.7, 1.9, 0.0), vec3(1.5)), d, 0.05); //windshield front curve\n        if (abs(d - d_mat)>.001)\n           material = MAT_GLASS;\n        d_mat = d;\n    \n        // Windshield Beams\n        d = opSmoothUnion(SDFBox(rotateY(0.5,rotateZ(0.4,mirrorZ(position))), vec3(0.6, 0.57, 0.4), vec3(1,1,0.01)), d, 0.04); //windshield beam\n    \n        // Main Body\n        d = min(d, SDFBox(position, vec3(-0.34, 0.39, 0.0), vec3(3.17, 0.65, 1.84))); //main box\n        d = min(d, SDFBox(rotateZ(0.4,position), vec3(1.34, 0.89, 0.0),vec3(0.95, 0.5, 1.84))); //hood\n        d = opSmoothSubtraction(SDFBox(rotateY(-0.3,mirrorZ(position)), vec3(1.45, 0.5, 1.8),vec3(1)), d, 0.1); //make hood wedge shaped\n        d = min(d, SDFBox(rotateZ(-0.18, position), vec3(-0.91, 0.9, 0), vec3(1.7, 0.32, 1.84))); //hatch\n    \n        // Hatch cuts\n        d = opSmoothSubtraction(SDFBox(rotateY(-0.15,rotateZ(-0.12,mirrorZ(position))), vec3(-1.1, 0.94, 0), vec3(1.7, 0.15, 0.6)), d, 0.05); //hatch cut\n        d = opSmoothSubtraction(SDFBox(rotateX(0.9,mirrorZ(position)), vec3(0, 0, 1.63), vec3(3,1,1)), d, 0.03); //shaping hatch to side windows\n        d = opSmoothSubtraction(SDFBox(rotateY(0.15, rotateX(1.3,mirrorZ(position))), vec3(-1, -0.4, 1.65), vec3(2,1,1)), d, 0.03); //hatch side cut\n        d = opSmoothUnion(SDFBox(rotateY(0.1, rotateX(1.2,mirrorZ(position))), vec3(-0.5, -0.35, 1), vec3(0.38))-0.02, d, 0.00); //air inlet bumps\n        d = opSmoothSubtraction(SDFBox(rotateX(0.2, rotateZ(0.5,mirrorZ(position))), vec3(-1.6, -1.2, 0.35), vec3(1)), d, 0.05); //back skirt corner cut\n    \n        // Spoiler alert\n        d = min(d, SDFBox(rotateY(0.1,mirrorZ(position)), vec3(-1.6, 0.95, 0.0), vec3(0.35, 0.03,2.2))); //spoiler\n        d = opSmoothUnion(SDFBox(mirrorZ(position), vec3(-1.6, 0.8, 0.55), vec3(0.2,0.22,0.01)), d, 0.05); //spoiler bar\n    \n        // Wheel flares\n        d = opSmoothUnion(d, SDFCylinder(mirrorZ(position)-vec3(-0.1, 0.3, 0.9), 0.1, 0.35), 0.1);\n        // Ground clearence\n        d = max(d, -SDFBox(position, vec3(0), vec3(5,0.3,2))); \n    \n        if (abs(d - d_mat)>.001)\n           material = MAT_BODY;\n        d_mat = d;\n        // Wheels\n        d = max(d, -SDFCylinder(mirrorZ(position)-vec3(-0.1, 0.3, (1.9-0.35)/2.0), 0.6, 0.35)); //wheel hole\n        d = min(d, SDFCylinder(mirrorZ(position)-vec3(-0.1, 0.3, (1.9-0.35)/2.0), 0.35, 0.3)); //wheels\n        if (abs(d - d_mat)>.001)\n           material = MAT_TYRE;\n        d_mat = d;\n    \n        // Rims\n        d = max(d, -SDFCylinder(mirrorZ(position)-vec3(-0.1, 0.3, 1), 0.2, 0.22)); //rim inset hole\n        if (abs(d - d_mat)>.001)\n           material = MAT_RIM;\n        d_mat = d;\n    \n        // Front lights\n        d = min(d, SDFBox(rotateZ(0.4, mirrorZ(position)), vec3(1.7, 1.1, 0.5),vec3(0.1, 0.1, 0.3)));\n        if (abs(d - d_mat)>.001)\n           material = MAT_LIGHT;\n        d_mat = d;\n    }\n\n    // Ground - plane\n    return min(d, dot(position, vec3(0, 1, 0)));\n}\n\n// Calculate surface normal\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calculateNormal(vec3 p) {\n    float EPS = 0.001;\n    vec3 v1 = vec3(\n        map(p + vec3(EPS, 0.0, 0.0), dummy),\n        map(p + vec3(0.0, EPS, 0.0), dummy),\n        map(p + vec3(0.0, 0.0, EPS), dummy));\n    vec3 v2 = vec3(\n        map(p - vec3(EPS, 0.0, 0.0), dummy),\n        map(p - vec3(0.0, EPS, 0.0), dummy),\n        map(p - vec3(0.0, 0.0, EPS), dummy));\n\n    return normalize(v1 - v2);\n}\n\n// Draw ground textures for bottom plane\nvec4 getRoadColor(vec3 rayPosition) {\n    // Determine the centerline for the roard.\n    // By introducing time dependent noise is added and scaled by distance\n    // in order to fake moving along a winding road.\n    // In reality the road is just bending left and right, with a static car.\n    float center = 1.5 - angle(0.0, 0.006 * rayPosition.z * rayPosition.z - 2.0);\n    \n    // Variable that is later used to alternate between \"light\" and \"dark\"\n    // stripes in order to simulate movement.\n    // No movement before 48s (during the first few scenes)\n    float lane = cos(rayPosition.z + 32.0 * max(0., iTime-48.));\n\n    // Light and dark base color for ground, by sampling sky color.\n    vec3 groundColor = sky(0.3);\n    if(lane>0.)\n        groundColor -= 0.1;\n\n    // Drawing road surface\n    if (abs(rayPosition.x - center) < ROADWIDTH) {\n       // Light and dark color alternating\n       groundColor = vec3(0.1);\n       if(lane>0.) {\n            //Road is only dark during intro (no movement)\n            if(iTime > 32.)\n                groundColor += 0.1; \n            // Lane stripes\n            if(abs(rayPosition.x - center) < STRIPEWIDTH)\n                groundColor += 1.0;\n       }\n        // Edge stripes\n        if(abs(abs(rayPosition.x - center) - LANEWIDTH) < STRIPEWIDTH)\n            groundColor += 1.0;\n   }\n    // At the distance try to blend road color into the sky color\n    // Not quite correct, because road receives raytraced lighting\n    // (for shadows) while background is not affected by lights.\n    groundColor = mix(groundColor, sky(0.6), length(rayPosition) / 70.0);\n\n    // Replace ground with solid grey for dark intros.\n    // Slight radial gradiant to black applied because I think it looks better\n    if (iTime > 16. && iTime < 48.)\n        groundColor = vec3(0.05 * abs(atan(1.0/length(rayPosition))));\n   \n    // During the outrun segment replace ground texture with grid pattern\n    if (iTime > 80. && iTime < 96.)\n        groundColor = 9.0/length(rayPosition)*sky(0.3) * float(cos((rayPosition.z) + 32.0 * iTime)>0.99 || cos(rayPosition.x-center)>0.99);\n    \n    // Convert color to material. Road is always matte.\n    return vec4(groundColor, 0);\n}\n\n// Draw skybox on sphere surface (centered around the car)\nvec4 getBackgroundColor(vec3 position) {\n    // Something like cylindrical coordates for drawing skybox\n    // from 0 to 1: from horizont to top of sky\n    float theta = position.y/length(position);\n\n    // from -pi to pi around the perimeter\n    float fi = sign(position.z) * acos(position.x/length(position.xz))\n        // Background moving with turns\n        + angle(3.0, 0.5);\n    \n    // Note here: After finalizing everything I realized that the above is incorrect. Well,\n    // maybe not incorrect, but could be improved:\n    // I assumed that the ray origin is near the center of the origin (car model)\n    // There's one camera movement, where the camera origin is moved \"along the road\" to\n    // make it seem like the car is passing by.\n    // In this scene I think my assumption causes distortions in the background. Oh well...\n\n    // Sky\n    // Having the square root looked better for me\n    vec3 color = sky(sqrt(theta));\n\n    // Sun\n    if(length(vec2(fi-1.3, theta-0.1)) < 0.1)\n        color += sky(0.0);\n\n    // Parallax to make scene look \"more 3D\"\n    // Mountains should move more with turns than sun, as it is closer.\n    fi += angle(3.0, 0.1);\n\n    // Skyline\n    // Always draw 3 layers, from furthest to closest.\n    // \"dist\" parameter range was selected arbitrarily.\n    for (float dist = 4.0; dist > 0.9; dist /= 2.0) {\n\n        // Buildings\n        float skyline = 0.1 * (noise(vec2(floor(20.0*fi*dist + dist)))\n                               -0.2 * dist    // Closer buildings are taller\n                               +sin(2.0*fi)); // Cluster buildings to \"cities\"\n\n        // Mountains\n        // Alternate between having buildings or mountains\n        if (fract(iTime/8.)<0.5)\n            // Multiple frequencies of undersampled noise (to look more square) laid on top of eachoter\n            skyline = 0.4*abs(fract(3.0*fi+dist+0.5)-0.5)*noise(vec2(floor(3.0*fi+dist)))\n                   + 0.2*abs(fract(10.0*fi+dist-0.5)-0.5)*noise(vec2(floor(10.0*fi+dist)))\n                   + 0.1;\n\n        // Normal coloring\n        if (theta < skyline)\n            // Add some color variance with distance and height\n            color = sky(0.3+0.4/dist-0.7*theta);\n\n        // Outrun coloring       \n        if (iTime > 80. && iTime < 96.)\n            if(theta < skyline-0.01)\n                // Experimented with different grids, this looked best to me\n                color *= float(fract(99.0*theta*(skyline-0.5))<0.1);\n    }\n    \n    // Convert color to material. Shininess doesn't matter, because\n    // sky is not affected by lighting.\n    return vec4(color, 0);\n}\n\n\n// Ray marching: Follow a ray of light from camera origin until collision to find distance\n// and material. Material is passed along using the \"out\" argument.\nfloat castRay(in vec3 rayOrigin, vec3 rayDirection, out vec4 material) {\n    // Start from origin\n    float distance = 0.0;\n    while(true) {\n        // Find stepsize for marching (distance of closest point from current position)\n        float step = map(rayOrigin + distance * rayDirection, material);\n\n        // An object is hit\n        if(step < 0.001) {\n            // If the ground plane is hit, then set material according to specific function\n            // for drawing ground surface\n            // Now that I think about it, It likely would have made more sense to move\n            // this inside the map function, similarly to other materials.\n            if ((rayOrigin + distance * rayDirection).y < 0.01)\n                material = getRoadColor(rayOrigin + distance * rayDirection);\n            return distance;\n        }\n            \n        // March!\n        distance += step;\n\n        // If maximum render distance is reached, draw the background\n        // This results in the background being projected to a ~sphere around the camera\n        if(length(rayOrigin + distance * rayDirection) > 96.0) {\n            material = getBackgroundColor(rayOrigin + distance * rayDirection);\n            // Return a negative distance, so background is not affected by lighting.\n            return -1.0;\n        }\n    } \n}\n\n// Calculate soft shadows\n// Thanks iq!\n// https://iquilezles.org/articles/rmshadows/\nfloat softShadow(in vec3 rayOrigin, vec3 rayDirection)\n{\n    float res = 1.0;\n    float distance = 0.0; // Min distance = 0\n    while (distance < 16.0) // Max distance = 16\n    {\n        float step = map(rayOrigin + distance * rayDirection, dummy);\n        if(step < 0.001)\n            return 0.0;\n        res = min(res, 4.0 * step/distance ); // hardness = 4\n        distance += step;\n    }\n    return res;\n}\n\n// Calculate ambient occlusions\n// Stole it from here:\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        occ += (h-map(opos, dummy))*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 2.0*occ, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // Pixel coordinates (from -1 to 1)\n    // Also downscales image to get that retro look\n    vec2 p = (2.0 * floor(fragCoord / DOWNSCALE) * DOWNSCALE - iResolution.xy) / iResolution.y;\n\n    // Change camera based on music (time)\n    // Visualization: https://graphtoy.com/?f1(x,t)=floor(4*fract(x/16))+2*(x%3E64)\n    int i_camera = int(4.*fract(iTime/16.))+2*int(iTime>64.);\n\n    // Camera position\n    // Helicopter - default\n    vec3 rayOrigin = vec3(-4.0 * sin(0.1 * iTime), 8.0, -4.0 * cos(0.1 * iTime));\n    vec3 cameraDirection = vec3(0.0, 0.5, 0.0);\n\n    // Wheel view\n    if(i_camera==0) {\n       rayOrigin = vec3(-2.0 + sin(0.1 * iTime), 0.4, -1.25);\n       cameraDirection = vec3(0.0, 0.4, 1.25);\n    }\n    // Rotating car view\n    if(i_camera==2) {\n       rayOrigin.y = 1.5;\n       //cameraDirection = vec3(0.0, 0.5, 0.0); // Same as default, so commented to save a few bytes\n    }\n    // Staring back down the road / mirror view\n    if(i_camera==3) {\n       rayOrigin = vec3(sin(0.5 * iTime)-1.0, 0.5, 5.0);\n       cameraDirection.z = -16.0;\n    }\n    // Driveby view\n    if(i_camera==5) {\n       rayOrigin = vec3(-3.0, 1.5, -96.0 * (fract(iTime/4.)-0.5));\n       //cameraDirection = vec3(0.0, 0.5, 0.0); // Same as default, so commented to save a few bytes\n    }\n    // Racing view\n    if(i_camera==4 || iTime>64. && iTime<80.) {\n       float i_fi = angle(0.5, -0.3);\n       rayOrigin = vec3(-5.0 * sin(i_fi), 1.5, -5.0 * cos(i_fi));\n       cameraDirection.z = 16.0;\n    }\n    \n    // Find ray direction for ray marching, based on position and direction\n    vec3 i_ww = normalize(cameraDirection - rayOrigin);\n    vec3 i_uu = normalize(cross(i_ww, vec3(0.0, 1.0, 0.0)));\n    vec3 i_vv = normalize(cross(i_uu, i_ww));\n    vec3 rayDirection = normalize(p.x * i_uu + p.y * i_vv + 2.0 * i_ww);\n    \n    // Perform ray marhcing:\n    // This finds the material and distance for the current pixel.\n    vec4 material;\n    float distance = castRay(rayOrigin, rayDirection, material);\n    \n    // Calculate lighting for valid collisions:\n    // This excludes lighting the background\n    if (distance > 0.0) {\n        // The scene is lit by a single global directional light source (mimicking the sun).\n        // Small amount of omnidirectional ambient light is added, so shadows are not completely black.\n        // Light parameters\n        float lightAmbientStrength = 0.1;\n        float light1Strength = 0.9;\n        vec3 light1Direction = normalize(vec3(sin(angle(3.0, 0.7) + 0.2), 1, cos(angle(3.0, 0.7) + 0.2)));\n        vec3 light1Color = sky(0.3);\n        vec3 lightAmbientColor = sky(0.4);\n        \n        // Finding surface normal for directional lighting\n        vec3 position = rayOrigin + distance * rayDirection;\n        vec3 normal = calculateNormal(position);\n\n        // During the dark intro the light source is white, flickering, and orbiting around the car.\n        if(iTime>16. && iTime<48.) {\n            light1Strength = float(iTime>32.)-sin(iTime)*sin(iTime);\n            light1Color = vec3(1);\n            light1Direction = normalize(vec3(sin(1.1 * (iTime-0.2)), 0.6, cos(1.1 * (iTime-0.2))));\n        }  \n        float i_diffusedLight1 = clamp(dot(normal, light1Strength * light1Direction), 0.0, 1.0);\n\n        // Specular using Blinn-Phong\n        vec3 i_half1 = normalize(light1Direction - rayDirection);\n        float i_specularLight1 = pow(clamp(dot(i_half1, normal), 0.0, 1.0), 128.0) //32.0 sets radius\n            // Fresnel effect\n            * mix(pow(1.0 - clamp(dot(i_half1, light1Direction), 0.0, 1.0), 5.0), 1.0, material.w); //5.0 is magic number\n\n        // Soft shadows\n        float i_shadow1 = softShadow(position + 0.001 * normal, light1Direction);\n\n        // Ambient occlusion\n        float i_occlusion = calcOcclusion(position, normal);\n\n        //Mixing lights and shadows\n        material.xyz *= (lightAmbientColor * lightAmbientStrength + light1Color * i_diffusedLight1 * i_shadow1) * i_occlusion\n            + 4.0 * light1Color * i_specularLight1 * i_shadow1;\n    }\n\n    // Gamma correction\n    material = pow(material, vec4(0.4545));\n\n    // Dithering with Bayer\n    float i_bayer = bayer8(fragCoord / DOWNSCALE) - 0.5;\n    material += i_bayer * 0.2;\n\n    // Quantizing palette\n    material = floor((material + QUANTIZE / 2.)/QUANTIZE)*QUANTIZE;\n    \n    // Metallica - Fade to Black\n    material *= clamp((112.0-iTime)/4.0,0.0,1.0);\n\n    // Output to screen\n    fragColor = vec4(material.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}