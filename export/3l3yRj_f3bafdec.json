{"ver":"0.1","info":{"id":"3l3yRj","date":"1609708524","viewed":108,"name":"peck of hexes (vlllll)","username":"valalalalala","description":"messing with hex tiles and truchet tiling. lotta issue to resolve still. the uv coordinates for the curves in particular are kooky.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["truchet","tiling","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"peck of hexes\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Trying to combine ideas from BigWings's videos on hex and truchet tiling\n// - https://www.youtube.com/watch?v=VmrIDyYiJBA\n// - https://www.youtube.com/watch?v=2R7h76GoIJM\n//\n// There are tiles with rounded and straight edges which are mixed. The edges\n// are pretty janky, and the flow has issues, uv's are wack\n//\n// taking a break from it for a bit...\n//\n/////////////////////////////////////////////////////////////////////////////\n\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define PI2             6.283185307179586\n\n#define RAND2(v)        fract( 333433.444469 * sin( dot( v + 13123.2421433, vec2( 449.457, 359.367 ) ) ) )\n#define EQUALS(a,b)     step( a, b ) * step( b, a )\n\n/////////////////////////////////////////////////////////////////////////////\n// demo controls\n\n#define FLIP\n#define SHOW_UV_\n#define COLOR_TILES\n#define SCALE 3.3\n#define PAN\n#define LINE_THRESHOLD .33\n\nconst vec2 HEX_MOD = vec2( 1., sqrt( 3.) );\n\n/////////////////////////////////////////////////////////////////////////////\n// helper functions\n\nmat2 rotate2d( in float angle ) {\n    angle *= PI2;\n    return mat2(\n        cos( angle ), -sin( angle ),\n        sin( angle ),  cos( angle )\n    );\n}\n\nvec2 which( in vec2 current, in vec2 test ) {\n    return test.y < current.y ? test : current;\n}\n\nfloat can_atan( vec2 v ) {\n    return atan( v.x, v.y );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// distance function \n\nfloat sdHex( vec2 uv ) {    \n    uv = abs( uv );\n    float angled = dot( uv, normalize( HEX_MOD ) );\n    float sides = uv.x;\n    \n    float d = max( angled, sides );\n    return d;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the tile connections (values are fiddled and twiddled)\n\nvec2 connectLines( vec2 uv ) {\n    vec2 d = vec2( 1., 1e33 );\n\n    d = which( d, vec2( 1., abs( uv.y - .00 ) / 1.0 ) );\n    d = which( d, vec2( 2., abs( uv.x - .25 ) / 0.8 ) );\n    d = which( d, vec2( 3., abs( uv.x + .25 ) / 0.8 ) );\n    \n    float a = .0;\n    a += EQUALS( 1., d.x ) * ( uv.x + .5 );\n    a += EQUALS( 2., d.x ) * ( uv.y + .2 ) / .8;\n    a += EQUALS( 3., d.x ) * ( uv.y + .2 ) / .8;\n    d.x = a;\n    \n    return d;\n}\n\nvec2 connectCircles( vec2 uv ) {\n    vec2 d = vec2( 1., 1e33 );\n\n    float lil = .29;\n    float big = .578;\n    float side = .5;\n\n    vec2 center1 = vec2( +side, lil );\n    vec2 center2 = vec2( -side, lil );\n    vec2 center3 = vec2( +.0, -big );\n    float r = .28;\n    d = which( d, vec2( 1., length( uv - center1 ) -r) );\n    d = which( d, vec2( 2., length( uv - center2 ) -r) );\n    d = which( d, vec2( 3., length( uv - center3 ) -r) );\n   \n    float a = .0;\n    a += EQUALS( 1., d.x ) * can_atan( center1 - uv ) / ( PI2 * .5);\n    a += EQUALS( 2., d.x ) * abs( can_atan( uv  - center2 ) -1. ) / 2.6;  \n    a += EQUALS( 3., d.x ) * ( 1. - ( can_atan( uv - center3 ) + .8 ) );\n    d.x = a;\n   \n    return d;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// make a hex tile with a random rotation and edge types\n\nvec4 hexTile( vec2 uv ) {\n    vec2 hexMod = vec2( 1., sqrt( 3.) );\n    vec2 halb = .5 * HEX_MOD;\n    \n    vec2 a = mod( uv ,       HEX_MOD ) -halb;\n    vec2 b = mod( uv + halb, HEX_MOD ) -halb;\n    \n    vec2 nu = dot( a,a ) < dot( b,b ) ? a : b;\n    vec2 id = ( uv - nu );\n\n    float angle = atan( nu.x, nu.y );\n    float d = .5 - sdHex( nu );\n\n#ifdef FLIP    \n    float n = floor( mod( 6. * RAND2( id * 7.89 + 43.34 ), 6. ) );\n    nu *= rotate2d( 1. / 6. * n );\n#endif\n\n    vec2 da = RAND2( id ) < LINE_THRESHOLD ? connectLines( nu ) : connectCircles( nu );\n    angle = da.x;\n    d = da.y;\n\n    return vec4( angle, d, id.x, id.y );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n\nvec3 old1( in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    vec3 color = vec3( .0 );\n    \n    color += sin( ( sdHex( uv ) * 9. - iTime * 3. ) * 4. );\n    //color.rg += .2 * hexTile( uv * 7. ).xy;\n    //color.gb += .2 * hexTile( uv * 7. ).zw *.2;\n    return color;\n}\n\nvec3 old2( in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    vec3 color = vec3( .0 );\n    float scale = 9.;\n    \n    vec4 hexo = hexTile( scale * uv + cos( iTime * .0239 ) * 99. );\n    color.r += smoothstep( .03, .09, hexo.y * cos( hexo.z * hexo.w + iTime ) );\n    color.g += smoothstep( .03, .09, hexo.y * sin( hexo.z * hexo.w + iTime ) );\n    color.b += .5 + .5 * cos( hexo.x + iTime );\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    vec2 mx = ( iMouse.xy / iResolution.xy ) * 2. -1.;\n\n    vec3 color = vec3( .0 );\n\n    float width = .22 * pow( .6 - abs( uv.y  ), .8 );\n    \n\n    uv += mx * 2.; // mouse pan\n#ifdef PAN\nuv += cos( iTime * .005 ) * 99.;\n#endif\n\n    vec4 hexo = hexTile( SCALE * uv );\n    float mask = smoothstep( .01, -.01, abs( hexo.y ) - width );\n/*  \n    never did get this quite right...\n    float eo = floor( mod( ( hexo.z + 99.) * 2.,  2. ) );\n    eo = floor( mod( (hexo.w+hexo.z+101.), 2. ) );\n    eo = eo * 2. - 1.;\n    \n    float every_other_column = floor( mod( abs(hexo.w + hexo.z), 2. ) );\n    float every_other_row    = floor( mod( hexo.z *2., 2. ) );\n    eo = mod( every_other_column - every_other_row, 2. );\n\n    //eo = every_other_column;\n    //eo = every_other_row;\n    eo = eo * 2. - 1.;\n*/\n    float eo = floor( mod( hexo.w + hexo.z, 2. ) ) * 2. - 1.; // idk...\n    \n\n#ifdef SHOW_UV\n    color.rg += mask * hexo.xy;\n#else\n    vec2 textureCoordinates = hexo.xy;\n    textureCoordinates.x += cos( eo * hexo.y * .1 + iTime * .4 );\n    \n    //color += mask * texture( iChannel0, textureCoordinates ).rgb;\n    \n    color += mask * hexTile( textureCoordinates * 4.4 ).xyy;\n#endif\n\n#ifdef COLOR_TILES\n    color.gb += (1.-mask) * fract( ( hexo.wz + 3.) * .2 ) * .3;\n#endif\n\n    fragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"}]}