{"ver":"0.1","info":{"id":"ls2yDc","date":"1494225718","viewed":214,"name":" Britney's Small Planet","username":"tholzer","description":"Reduced 'Britney Planet' of https://www.shadertoy.com/view/4tlGWs.\nEliminated 2nd texture, using reduced height field and activated skyColor. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","heightfield","planet","3dsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// <3 Shadertoy\n// thank to @uint9 -> http://9bitscience.blogspot.fr/2013/07/raymarching-distance-fields_14.html\n\n#define PI 3.141592653589\n\n// Raymarching\nconst float rayEpsilon = 0.001;\nconst float rayMin = 0.1;\nconst float rayMax = 10.0;\nconst int rayCount = 24;\n\n// Camera\nvec3 eye = vec3(0, 0, -1.5);\nconst vec3 front = vec3(0, 0, 1);\nconst vec3 right = vec3(1, 0, 0);\nconst vec3 up    = vec3(0, 1, 0);\n\n// Animation\nvec2 uvScale1 = vec2(2.0);\nvec2 uvScale2 = vec2(2.0);\nfloat terrainHeight = 0.2;\nfloat sphereRadius = 0.85;\nfloat translationSpeed = 10.4;\n\n// Colors\nvec3 skyColor    = vec3(0, 0, 0.41);\n\nvec3 rotateY(vec3 v, float t)\n{\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\nvec3 rotateX(vec3 v, float t)\n{\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\nfloat sphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat reflectance(vec3 a, vec3 b) { return dot(normalize(a), normalize(b)) * 0.5 + 0.5; }\n\nvec2 kaelidoGrid(vec2 p) { return vec2(step(mod(p, 2.0), vec2(1.0))); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(front + right * uv.x + up * uv.y);\n    \n    // Color\n    vec3 color = vec3(0);\n    \n    // Animation\n    float translationTime = iTime * translationSpeed;\n    \n    eye.y += 0.25 - 0.5*iMouse.y / iResolution.y;\n    \n    // Raymarching\n    float t = 0.0;\n    for (int r = 0; r < rayCount; ++r)\n    {\n        // Ray Position\n        vec3 p = eye + ray * t;\n        vec3 originP = p;\n        \n        // Transformations\n        p = rotateY(p, PI / 2.0);\n       \tp = rotateX(p, PI / 2.0);\n        vec2 translate = vec2(0.0, translationTime);\n        \n        // Sphere UV\n        float angleXY = atan(p.y, p.x);\n        float angleXZ = atan(p.z, p.x);\n        vec2 sphereP1 = vec2(angleXY / PI, 1.0 - reflectance(p, eye)) * uvScale1;\n        sphereP1 += 0.5;\n        vec2 uv1 = mod(mix(sphereP1, 1.0 - sphereP1, kaelidoGrid(sphereP1)), 1.0);\n        \n        // Texture\n        color = texture(iChannel0, uv1).rgb;\n        \n        // Height from luminance\n        float luminance = (color.r + color.g + color.b) / 4.0;\n        \n        // Displacement\n        p -= normalize(p) * terrainHeight * luminance * reflectance(originP, eye);\n        \n        // Distance to Sphere\n        float d = sphere(p, sphereRadius);\n        \n        // Distance min or max reached\n        if (t > rayMax)\n        {\n            // Sky color from distance\n            color = mix(color, skyColor, 0.6);\n            break;\n        }\n        \n        // Distance field step\n        t += d;\n    }   \n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}