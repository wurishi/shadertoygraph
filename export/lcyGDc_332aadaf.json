{"ver":"0.1","info":{"id":"lcyGDc","date":"1713354875","viewed":28,"name":"Sun cycle on a toric world","username":"esther_fpqc","description":"The world is a torus and the sun is orbiting at infinity on a plane orthogonal to the plane of the torus. In orange, the points where the sun is at the horizon. A natural satellite is orbiting the planet and casting a shadow.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Major and minor radii of the torus\nconst float R = 5.1;\nconst float r = 1.1;\n//Radius of the central sattelite\n//Make sure that m < R - r, otherwise everything breaks apart.\nconst float m = 0.5;\n\nconst float R2 = R * R;\nconst float r2 = r * r;\nconst float pi = 3.1415926;\nconst float stp = 2. * (R + r) / 100.;\n\nvec3 day(vec2 uv, float t){\n    //Coordinates (x0, y0, z0) of the corresponding point on the torus\n    float x0 = (R + r * cos(uv.y)) * cos(uv.x);\n    float y0 = (R + r * cos(uv.y)) * sin(uv.x);\n    float z0 = r * sin(uv.y);\n    //Direction (xs, ys, zs) of the sun\n    float xs = cos(t);\n    float ys = 0.;\n    float zs = sin(t);\n    //Coordinates (xm, ym, zm) of the moon\n    float xm = 0.;\n    float ym = R - R * cos(t/73.);\n    float zm = R * sin(t/73.);\n    \n    //Useful numbers to compute the polynomial\n    float a = x0 * x0 + y0 * y0 + z0 * z0 + R2 - r2;\n    float b = 2. * x0 * xs + 2. * y0 * ys + 2. * z0 * zs;\n    float c = xs * xs + ys * ys + zs * zs;\n\n    float a2 = a * a;\n    float b2 = b * b;\n    float c2 = c * c;\n    float d = m * m - (x0 - xm) * (x0 - xm) - (y0 - ym) * (y0 - ym) - (z0 - zm) * (z0 - zm);\n    float e = (x0 - xm) * xs + (y0 - ym) * ys + (z0 - zm) * zs;\n    float f = x0 * xs + y0 * ys;\n    float g = x0 * x0 + y0 * y0;\n    float h = xs * xs + ys * ys;\n    float hfR2 = 8. * f * R2;\n    float qgR2 = 4. * g * R2;\n    float qhR2 = 4. * h * R2;\n    float dab = 2. * a * b;\n    float dac = 2. * a * c;\n    float bc = b * c;\n    \n    //Coefficients of the polynomial\n    float p0 = (hfR2 - dab) * d - 2. * (qgR2 - a2) * e;\n    float p1 = (qhR2 - b2 - dac) * d - 2. * (hfR2 - dab) * e - (qgR2 - a2) * c;\n    float p2 = -2. * d * bc - 2. * (qhR2 - b2 - dac) * e - (hfR2 - dab) * c;\n    float p3 = 4. * e * bc - d * c2 - (qhR2 - b2 - dac) * c;\n    float p4 = 2. * c2 * (e + b);\n    float p5 = c * c2;\n    \n    //p0 is approximately 0 when the sun is at the horizon.\n    if(p0 * p0 < 3000.){\n        return vec3(0., 0.5, 1.);\n    }\n    //(The sun is near the other horizon (start/end of eclipse) when there is a positive double root.)\n    \n    //The polynomial takes a negative value at a positive input exactly during the night.\n    float px;\n    for(float x = 0.1 ; x < 2. * (R + r) ; x += stp){\n        px = ((((p5 * x + p4) * x + p3) * x + p2) * x + p1) * x + p0;\n        if(px < 0.){\n            return vec3(0.8);\n        }\n    }\n    //The polynomial only takes positive values at positive inputs exactly during the day.\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    uv += vec2(0.134, 0.155);\n    fragColor -= vec4(day(2. * pi * uv, iTime)/2.,1.);\n    \n    //Equator\n    /*\n    if(0.5 - 0.005 <= uv.y && uv.y <= 0.5 + 0.005){\n        fragColor = vec4(1., 0., 0., 1.);\n    }\n    if(1. - 0.005 <= uv.y && uv.y <= 1. + 0.005){\n        fragColor = vec4(0., 1., 0., 1.);\n    }\n    */\n}","name":"Image","description":"","type":"image"}]}