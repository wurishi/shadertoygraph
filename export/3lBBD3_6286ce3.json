{"ver":"0.1","info":{"id":"3lBBD3","date":"1599943304","viewed":166,"name":"raymarching test 001","username":"Koji","description":"learning raymarching","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n#define MAX_STEP 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat smoothMin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0. , 1.);\n  return mix(b,a,h)-k*k*(1.0-h);\n}\n\nfloat smoothMax(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0. , 1.);\n  return max(b,a)-k*k*(1.0-h);\n}\n\nmat2 Rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdCapsuel(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b-a;\n  vec3 ap = p-a;\n\n  float t = dot(ap, ab)/dot(ab, ab);\n  t = clamp(t, 0.0, 1.0);\n\n  vec3 c = a + t*ab;\n  float d = length(p-c)-r;\n\n  return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n  float x = length(p.xz)-r.x;\n  float y = p.y;\n  return length(vec2(x,y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 size) {\n  float d = length(max(abs(p)-size, 0.0));\n  return d;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  float gyroid = abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n  return gyroid;\n}\nvec3 Transform(vec3 p) {\n  p.xy *= Rotate(p.z*.1);\n  p.z -= iTime * .1;\n  p.y -= .3;\n  return p;\n}\n\nfloat GetDist(vec3 p) {\n  p = Transform(p);\n  float dP = p.y; // plane distance\n  float bd = dBox(p, vec3(1));\n\n  float gyroid = sdGyroid(p, 5.23, 0.03, 1.4);\n  float gyroid2 = sdGyroid(p, 10.76, 0.03, .3);\n  float torus = sdTorus(p, vec2(p.x, p.z));\n  \n\n  \n  gyroid -= gyroid2 * 1.5;\n  \n  float d = gyroid * .95;\n  \n  return abs(d);\n\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.0; // start origin\n  for(int i=0; i<MAX_STEP; i++) {\n    vec3 p = ro+dO*rd; // current march position\n    float dS = GetDist(p);\n    dO += dS;\n    if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n  }\n  return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n  float d = GetDist(p);\n  vec2 e = vec2(0.02, 0);\n  vec3 n = d -vec3(\n    GetDist(p-e.xyy),\n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx)\n  );\n  return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n  vec3 lightPos = vec3(3, 5, 4);\n  // lightPos.xz += vec2(sin(iTime), cos(iTime));\n  vec3 l = normalize(lightPos -p);\n  vec3 n = GetNormal(p);\n\n  float diff = clamp(dot(n, l)*.5+.5, 0., 1.);\n  float d = RayMarch(p+n*SURFACE_DIST*2., l);\n  return diff;\n\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Background(vec3 rd) {\n  vec3 col = vec3(0.);\n  float y = rd.y*.5+.5;\n  float t  = iTime;\n  col += (1.-y) * vec3(1., 1., 1.)*2.;\n  float a = atan(rd.x, rd.z);\n  float flames = sin(a*10.+t)*sin(a*7.-t)*sin(a*6.-t);\n  flames *= S(.8, .5, y);\n  col += flames;\n  col = max(col, 0.);\n  col += S(.5, .0, y);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalize\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0.0);\n    float t  = iTime;\n    \n    vec3 ro = vec3(0, 0, -.03);\n    ro.yz *= Rotate(-iMouse.y*3.14+1.);\n    ro.xz *= Rotate(-iMouse.x*6.2831);\n    \n    vec3 lookat = vec3(0,0,0);\n\n    vec3 rd = R(uv, ro, lookat, .8); // last zoom\n\n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n      vec3 p = ro + rd * d;\n      vec3 n = GetNormal(p);\n\n      float height = p.y;\n\n      p = Transform(p);\n\n      float diff = n.y*.5+.5;\n      col += diff * diff;\n\n      float g2 = sdGyroid(p, 10.76, 0.03, .3);\n      col *=S(-0.1, .1, g2); // blackening\n\n      float crackWidth = -0.02+S(0., -.5, n.y) * 0.04;\n      float cracks = S(crackWidth, -.03, g2); // first crack's width\n\n      float g3 = sdGyroid(p+t * .1, 5.76, 0.03, .0);\n      float g4 = sdGyroid(p-t * .05, 4.76, 0.03, .0);\n      cracks *= g3 * g4 *20.+.2 * S(.2, .0, n.y);\n\n      col += cracks * vec3(.1, .4, 1.) * 3. * sin(iTime);\n\n      float g5 = sdGyroid(p-vec3(0., t, 0.), 3.76, 0.03, .0);\n\n      col += g5*vec3(.1, .4, 1.);\n\n      col += S(0., -2., height)*vec3(.1, .4*sin(iTime), 1.*cos(iTime));\n\n\n    }\n\n    col = mix(col, Background(rd), S(0., 7. , d));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}