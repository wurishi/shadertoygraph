{"ver":"0.1","info":{"id":"3sscW4","date":"1584812352","viewed":154,"name":"Ice Cream in the Eighties","username":"iaian7","description":"In honour of a friend, in memory of a mother.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["light","gradient","abstract","motion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 xy, float angle){\n\treturn vec2(xy.x*cos(angle) - xy.y*sin(angle), xy.x*sin(angle) + xy.y*cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Global Settings\n\tfloat speed = 0.4;\n    float rotation = speed * 0.2; // speed of the global rotation\n\tfloat variance = 0.2; // shifts the angles so they're not exactly 120Â°, and animates the shift\n\tfloat range = 0.1; // distance travelled by the pieces (from negative to positive, measured from the centre)\n    float opacity = 0.8; // maximum strength of the individual layers\n\tfloat grain = 0.8; // strength of the grain applied to the non-100% opacity areas\n\t\n\t// Edge Settings\n\tfloat curve = 3.0; // size of the circle that creates the edge mask (only one side is visible)\n\tfloat softness = 6.0; // antialiasing looks good at 2.5, anything larger starts to blur\n    \n\t// Glow Settings\n\tfloat size = 0.8; // size of the glow\n\tfloat offset = size * 0.3; // shifts the glow side to side within the edge mask\n    \n\t// Colours\n\tvec4 bg = vec4(0.043137255, 0.152941176, 0.235294118, 1.0); // Dark Navy\n\tvec4 c0 = vec4(0.062745098, 0.188235294, 0.294117647, 1.0); // Soft Navy\n\tvec4 c1 = vec4(0.227450980, 0.525490196, 0.584313725, 1.0); // Turquoise\n\tvec4 c2 = vec4(0.482352941, 0.729411765, 0.584313725, 1.0); // Seafoam\n\tvec4 c3 = vec4(0.698039216, 0.839215686, 0.639215686, 1.0); // Mint\n\tvec4 c4 = vec4(0.980392157, 0.937254902, 0.643137255, 1.0); // Chifon Yellow\n\tvec4 c5 = vec4(0.952941176, 0.709803922, 0.505882353, 1.0); // Pale Orange\n\tvec4 c6 = vec4(0.925490196, 0.458823529, 0.396078431, 1.0); // Salmon\n\tvec4 c7 = vec4(0.917647059, 0.301960784, 0.301960784, 1.0); // Soft Red\n\t\n\t// Normalized pixel coordinates (from -1 to 1, square)\n\tvec2 uv = (fragCoord-iResolution.xy*0.5)/(iResolution.xx*0.5);\n\tvec2 uv0 = rotate(uv, iTime*rotation);\n\tvec2 uv1 = rotate(uv0, 2.094395 + sin(iTime*speed*0.3333)*variance);\n\tvec2 uv2 = rotate(uv0, 4.18879 + cos(iTime*speed*0.3333)*variance);\n\t\n\t// Pixel antialiasing size in UV space\n\tfloat px = softness/iResolution.x;\n\t\n\t// Noise texture\n\tvec4 noise = texture(iChannel0, uv*1.5+vec2(sin(iTime*6.0), cos(iTime*6.0)));\n\t\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t// Animation timelines (the sin/cos waves animate at different speeds to break up repetition)\n\tfloat sin0 = sin(iTime*speed);\n\tfloat sin1 = sin((iTime+1.047198)*speed*1.05);\n\tfloat sin2 = sin((iTime+2.094395)*speed*1.1);\n\tfloat sin3 = sin((iTime+3.141593)*speed*1.15);\n\tfloat sin4 = sin((iTime+4.18879)*speed*1.2);\n\tfloat sin5 = sin((iTime+5.235988)*speed*1.25);\n\tfloat cos0 = cos(iTime*speed);\n\tfloat cos1 = cos((iTime+1.047198)*speed*1.05);\n\tfloat cos2 = cos((iTime+2.094395)*speed*1.1);\n\tfloat cos3 = cos((iTime+3.141593)*speed*1.15);\n\tfloat cos4 = cos((iTime+4.18879)*speed*1.2);\n\tfloat cos5 = cos((iTime+5.235988)*speed*1.25);\n\t\n\t// Glow layers part 1\n\tfloat curvePos = range*sin1;\n\tfloat glowPos = cos0*size*0.25+size*0.5;\n\tfloat g0 = smoothstep(curve+px, curve, length(uv0-vec2(0.0, curve+curvePos)));\n\tg0 *= smoothstep(size, 0.0, length(uv0+vec2(sin2*offset, glowPos-curvePos)));\n\t\tglowPos = cos1*size*0.25+size*0.5;\n\tfloat g1 = smoothstep(curve+px, curve, length(uv1-vec2(0.0, curve+curvePos)));\n\tg1 *= smoothstep(size, 0.0, length(uv1+vec2(sin3*offset, glowPos-curvePos)));\n\t\tglowPos = cos2*size*0.25+size*0.5;\n\tfloat g2 = smoothstep(curve+px, curve, length(uv2-vec2(0.0, curve+curvePos)));\n\tg2 *= smoothstep(size, 0.0, length(uv2+vec2(sin4*offset, glowPos-curvePos)));\n\t\n\t// Invert UV for second set of glow layers\n\tuv0 *= vec2(1.0, -1.0);\n\tuv1 *= vec2(1.0, -1.0);\n\tuv2 *= vec2(1.0, -1.0);\n\t\n\t// Glow layers part 2\n\t\tcurvePos = range*sin0;\n\t\tglowPos = cos3*size*0.25+size*0.5;\n\tfloat g3 = smoothstep(curve+px, curve, length(uv0-vec2(0.0, curve+curvePos)));\n\tg3 *= smoothstep(size, 0.0, length(uv0+vec2(sin3*offset, glowPos-curvePos)));\n\t\tglowPos = cos4*size*0.25+size*0.5;\n\tfloat g4 = smoothstep(curve+px, curve, length(uv1-vec2(0.0, curve+curvePos)));\n\tg4 *= smoothstep(size, 0.0, length(uv1+vec2(sin4*offset, glowPos-curvePos)));\n\t\tglowPos = cos5*size*0.25+size*0.5;\n\tfloat g5 = smoothstep(curve+px, curve, length(uv2-vec2(0.0, curve+curvePos)));\n\tg5 *= smoothstep(size, 0.0, length(uv2+vec2(sin5*offset, glowPos-curvePos)));\n\t\n    // Mix the colours\n    bg = mix(bg, c0, pow(smoothstep(1.5, 0.0, length(uv)), 1.0+noise.b*grain));\n\tbg = mix(bg, c1, pow(g0*opacity, 1.0+noise.r*grain));\n\tbg = mix(bg, c2, pow(g1*opacity, 1.0+noise.g*grain));\n\tbg = mix(bg, c3, pow(g2*opacity, 1.0+noise.b*grain));\n\tbg = mix(bg, c5, pow(g3*opacity, 1.0+noise.r*grain));\n\tbg = mix(bg, c6, pow(g4*opacity, 1.0+noise.g*grain));\n\tbg = mix(bg, c7, pow(g5*opacity, 1.0+noise.b*grain));\n    \n\t// Output to screen\n\tfragColor = bg;\n}","name":"Image","description":"","type":"image"}]}