{"ver":"0.1","info":{"id":"ttcfR4","date":"1612394824","viewed":115,"name":"Carpet pattern #0","username":"TWal","description":"A kind of hexagonal tiling I found on a carpet","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","tiling","carpet","wallpapergroup","shining","pmg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COLORS 1\n\n\n/////////////////////\n//Version using sdf//\n/////////////////////\n\n#if 1\n//Thanks iq for the 2d sdf!\nfloat sdHexagon( in vec2 p, in float r ) {\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdThreeHexagon(vec2 p, float r) {\n    return min(sdHexagon(p-vec2(0.5*sqrt(3.), 0.0), r),\n           min(sdHexagon(p-vec2(0.0, 0.5), r),\n               sdHexagon(p-vec2((2.+5./9.)/sqrt(3.), 0.5), r)));\n}\n\nvec3 carpet0(vec2 uv, float blur) {\n    float modulus = (2.+5./9.)/sqrt(3.);\n    int id = int(floor(uv.x/modulus));\n    uv.x = mod(uv.x, modulus);\n    uv.y = abs(fract(uv.y+0.5)-0.5);\n    float sdSmallHex = sdThreeHexagon(uv, 1./9.);\n    float sd = max(sdThreeHexagon(uv, 2./9.), -sdSmallHex);\n    sd = max(-sd, sdThreeHexagon(uv, 3./9.));\n    sd = max(-sd, sdThreeHexagon(uv, 4./9.));\n    sd = max(-sd, sdThreeHexagon(uv, 5./9.));\n    sd = min(sd, sdBox(uv-vec2(1.3, 0.0), vec2(0.15, 0.5/9.)));\n    sd = min(sd, sdBox(uv-vec2(1.0, 0.5), vec2(0.15, 0.5/9.)));\n    float sdc = max(sdThreeHexagon(uv, 4.5/9.),\n                    -min(sdHexagon(uv-vec2(0.0, 0.5), 3.5/9.),\n                     min(sdHexagon(uv-vec2(0.5*sqrt(3.), 0.0), 3.5/9.),\n                     sdBox(uv-vec2(1.4, 0.), vec2(0.15, 1./9.))\n                     ))\n    );\n    bool i = bool(id%2) == (sdc < 0.);\n    bool ii = sdSmallHex < 0.1;\n    return vec3(smoothstep(blur, -blur, sd), i, ii);\n}\n\n\n//////////////////////////////////\n//Version using hexagonal tiling//\n//////////////////////////////////\n#else\n\n#define ANTIALIAS 1\n\nvec3 carpet0(vec2 uv, float blur) {\n    vec2 off = vec2(sqrt(3.), 1.);\n    float modulus = (2.+5./9.)/sqrt(3.);\n    int id = int(floor(uv.x/modulus));\n    uv.x = mod(uv.x, modulus);\n    uv.x += 2./sqrt(3.);\n    uv.y = abs(fract(uv.y+0.5)-0.5);\n    if(dot(vec2(uv.x, -abs(uv.y)), normalize(off)) < 1.) {\n        uv.x += modulus;\n        id += 1;\n    }\n    vec2 uv1 = mod(uv, off)-off/2.;\n    vec2 uv2 = mod(uv+off/2., off)-off/2.;\n    vec2 nuv = (length(uv1) < length(uv2)) ? uv1 : uv2;\n    float d = max(abs(nuv.y), dot(abs(nuv), normalize(off)));\n    float N = 4.5;\n#if ANTIALIAS == 1\n    // There is still a little glitch on the connexion with the adjacent tiling :(\n    // (Hopefully we have to zoom in to see it!)\n    float b = smoothstep(0.5/N+blur, 0.5/N     , mod(d, 1./N))\n            * smoothstep(0.5/N     , 0.5/N-blur, mod(d, 1./N))\n            * smoothstep(0., blur, mod(d, 1./N))\n            * smoothstep(1./N, 1./N-blur, mod(d, 1./N));\n    if(uv.x < (2.+4./9.)/sqrt(3.) && uv.y < 0.5/9.) {\n        b = 1.;\n    }\n    if(uv.x < (2.+3.5/9.)/sqrt(3.)) {\n        b *= smoothstep(0.5/9.+blur, 0.5/9.     , uv.y)\n           * smoothstep(0.5/9.     , 0.5/9.-blur, uv.y)\n           + smoothstep(1.5/9.-blur, 1.5/9.     , uv.y)\n           * smoothstep(1.5/9.     , 1.5/9.+blur, uv.y);\n    }\n    if(d < 0.25/9.) b = 1.;\n#else\n    bool b = mod(d, 1./N) < 0.5/N;\n    b = b || (uv.x < (2.+4./9.)/sqrt(3.) && uv.y < 0.5/9.);\n    b = b && !(uv.x < (2.+3.5/9.)/sqrt(3.) && 0.5/9. < uv.y && uv.y < 1.5/9.);\n#endif\n    bool i = bool(id%2) == (d > 3.5/9. && !(uv.y < 1./9. && uv.x < sqrt(3.)));\n    bool ii = d < 1.5/9.;\n    \n    return vec3(b, i, ii);\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 5.;\n    uv += 10.*vec2(cos(iTime/20.), sin(iTime/20.));\n    float pixelSize = 5./iResolution.y;\n    \n    vec3 res = carpet0(uv, 1.5*pixelSize/2.);\n    float b = res.x;\n    float i = res.y;\n    float ii = res.z;\n#if COLORS == 1\n    vec3 col = b*vec3(1., float(i*(1.-ii)), float(ii));\n#else\n    vec3 col = vec3(b);\n#endif\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}