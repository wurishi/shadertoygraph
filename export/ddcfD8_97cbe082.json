{"ver":"0.1","info":{"id":"ddcfD8","date":"1697100542","viewed":95,"name":"Wet Look Shader","username":"doriasschaerer","description":"wet shader with lighting & refraction","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","lighting","wet","realistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n\n// All noise functions are designed for values on integer scale.\n// They are tuned to avoid visible periodicity for both positive and\n// negative coordinates within a few orders of magnitude.\n\n// For a single octave\n//#define NOISE noise\n\n// For multiple octaves\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 5\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec2 RotateVec2(vec2 v, float angle)\n{\n    vec2 r;\n\n    r.x = cos(angle * v.x) - sin(angle * v.y);\n    r.y = sin(angle * v.x) + cos(angle * v.y);\n    \n    return r;\n}\n\nfloat CheckerBoard(int divisions, vec2 uv)\n{\n    float fac = 0.;\n    \n    for (int i = 0; i < divisions; i++)\n    {\n        uv = fract(uv*2.0);\n    }\n\n    fac = float((uv.x > 0.5) ^^ (uv.y > 0.5));\n\n    fac += 0.7;\n\n    return fac;\n}\n\nfloat CheckerBoardBlurred(int blursteps, float blurdistance, vec2 uv)\n{\n    float val = 0.;\n    \n    for (int i = -blursteps; i < blursteps; i++)\n    {\n       for (int j = -blursteps; j < blursteps; j++)\n        {\n            val += CheckerBoard(4, uv + vec2(float(i) * blurdistance, float(j) * blurdistance));\n        }\n    }\n\n    return val;\n}\n\nfloat Raindrops(vec2 uv, float scale, float limit) {\n    float height;\n\n    float offset = 3.;\n\n    float height1;\n    float height2;\n    float height3;\n\n    uv *= scale;\n\n    height1 = noise(uv * 3. + iMouse.xy * 0.01 * 3. + offset);\n\n    height1 = min(height1, limit);\n\n    height2 = noise(uv * 1.+ iMouse.xy * 0.01 * 1.+ offset);\n\n    height2 = min(height2, limit);\n\n    height3 = noise(uv * 2. + iMouse.xy * 0.01 * 2. + offset);\n\n    height3 = min(height3, limit);\n\n    height1 = height2 * float(height2 < 0.1) + height1 * float(height1 < 0.1) * float(!(height2 < 0.1));\n\n    height = height3 * float(height3 < 0.1) + height1 * float(height1 < 0.1) * float(!(height3 < 0.1));\n\n    height += float(height >= limit);\n\n    height *= 2.;\n    \n    return height;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    float lightlength = length(vec2(-2.));\n    vec2 light = vec2(-2.);\n    int blursteps = 4;\n    float blurdistance = 0.001;\n\n    vec2 mouseVec2 = iMouse.xy / iResolution.xy + vec2(0.5);\n    mouseVec2 *= 1.;\n\n    \n    \n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * vec2(1.6,0.9);\n\n    light = uv + vec2(0.5) - mouseVec2;\n\n    light *= 1.;\n\n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    float raindrops = Raindrops(uv, 10., 0.1);\n\n    uv += iMouse.xy * 0.0005 * vec2(1.6, 0.9);\n\n    col = vec3(CheckerBoardBlurred(blursteps, blurdistance, uv));\n\n    col = col / (float(blursteps * blursteps * 10));\n    col += 0.2;\n\n\n\n\n\n\n    //col += vec3(CheckerBoard(4, uv));\n\n    vec2 normal = vec2(dFdx(raindrops), dFdy(raindrops));// cheap normals (3x cheaper, but 2 times shittier ;))\n    //normal = normal * float(length(normal) < 0.1);\n    \n\n    // refraction\n\n    col2 += vec3(CheckerBoardBlurred(blursteps, blurdistance, uv - normal * 0.5)) * 0.011;\n    col2 += 0.;\n    col2 -= raindrops;\n\n    float diffuse = distance(normal*100., light * 1.);\n\n    //col2 += diffuse * 0.2;\n    \n    //float specular = (distance(normal * -100., light * 5.)) * dot(normal, -light);\n    float specular = (1. - dot(normal * 100., -light * 0.1)) * (1. - distance(normal * -100., light * 1.));\n\n    //float specular = (dot(normalize(normal), normalize(light)));\n\n    //specular = specular * float(specular > 0.);\n\n    specular *= specular;\n    specular *= specular;\n    specular *= specular;\n\n    specular = specular * float(specular < 1.);\n\n    col2 += specular;\n    \n    bool mask = (col2.x < 0.);\n\n    col = col * float(mask) + (col2 + 0. * 2.) * float(!mask);\n\n    col += (1. / (distance(uv,mouseVec2) * 1000.));\n\n    \n\n    //col = vec3(specular);\n    //col = vec3(distance(normal*100., light) * 0.3 - 1.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}