{"ver":"0.1","info":{"id":"dlc3zn","date":"1681856056","viewed":279,"name":"Better ASCII Shader","username":"arkelley77","description":"Unlike most ASCII shaders, this one can make use of all of the printable ASCII characters, in addition to choosing characters based on shape, not just brightness.\nLook in Buffer C for the configuration options.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["retro","ascii","lofi","quantize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision lowp float;\nprecision lowp int;\nprecision lowp sampler2D;\n\nconst int bpc = 4;             // output is quantized to this many bits per channel\n\n\nconst int gap_width = 1;\nconst int gap_height = 1;\n\n\nconst int char_width = 5;\nconst int char_height = 7;\n\n\n\nconst vec2 char_size = vec2(char_width, char_height);\nconst vec2 tile_size = char_size + vec2(gap_width, gap_height);\n\n// standard ascii 5x7 font\n// defines ascii characters 0x20-0x7F (32-127)\n// source: https://github.com/adafruit/monochron/blob/master/firmware/font5x7.h\nconst int Font5x7[95 * char_width] = int[95 * char_width](\n\t0x00, 0x00, 0x00, 0x00, 0x00,// (space)\n\t0x00, 0x00, 0x5F, 0x00, 0x00,// !\n\t0x00, 0x07, 0x00, 0x07, 0x00,// \"\n\t0x14, 0x7F, 0x14, 0x7F, 0x14,// #\n\t0x24, 0x2A, 0x7F, 0x2A, 0x12,// $\n\t0x23, 0x13, 0x08, 0x64, 0x62,// %\n\t0x36, 0x49, 0x55, 0x22, 0x50,// &\n\t0x00, 0x05, 0x03, 0x00, 0x00,// '\n\t0x00, 0x1C, 0x22, 0x41, 0x00,// (\n\t0x00, 0x41, 0x22, 0x1C, 0x00,// )\n\t0x08, 0x2A, 0x1C, 0x2A, 0x08,// *\n\t0x08, 0x08, 0x3E, 0x08, 0x08,// +\n\t0x00, 0x50, 0x30, 0x00, 0x00,// ,\n\t0x08, 0x08, 0x08, 0x08, 0x08,// -\n\t0x00, 0x60, 0x60, 0x00, 0x00,// .\n\t0x20, 0x10, 0x08, 0x04, 0x02,// /\n\t0x3E, 0x51, 0x49, 0x45, 0x3E,// 0\n\t0x00, 0x42, 0x7F, 0x40, 0x00,// 1\n\t0x42, 0x61, 0x51, 0x49, 0x46,// 2\n\t0x21, 0x41, 0x45, 0x4B, 0x31,// 3\n\t0x18, 0x14, 0x12, 0x7F, 0x10,// 4\n\t0x27, 0x45, 0x45, 0x45, 0x39,// 5\n\t0x3C, 0x4A, 0x49, 0x49, 0x30,// 6\n\t0x01, 0x71, 0x09, 0x05, 0x03,// 7\n\t0x36, 0x49, 0x49, 0x49, 0x36,// 8\n\t0x06, 0x49, 0x49, 0x29, 0x1E,// 9\n\t0x00, 0x36, 0x36, 0x00, 0x00,// :\n\t0x00, 0x56, 0x36, 0x00, 0x00,// ;\n\t0x00, 0x08, 0x14, 0x22, 0x41,// <\n\t0x14, 0x14, 0x14, 0x14, 0x14,// =\n\t0x41, 0x22, 0x14, 0x08, 0x00,// >\n\t0x02, 0x01, 0x51, 0x09, 0x06,// ?\n\t0x32, 0x49, 0x79, 0x41, 0x3E,// @\n\t0x7E, 0x11, 0x11, 0x11, 0x7E,// A\n\t0x7F, 0x49, 0x49, 0x49, 0x36,// B\n\t0x3E, 0x41, 0x41, 0x41, 0x22,// C\n\t0x7F, 0x41, 0x41, 0x22, 0x1C,// D\n\t0x7F, 0x49, 0x49, 0x49, 0x41,// E\n\t0x7F, 0x09, 0x09, 0x01, 0x01,// F\n\t0x7F, 0x08, 0x08, 0x08, 0x7F,// H\n\t0x3E, 0x41, 0x41, 0x51, 0x32,// G\n\t0x00, 0x41, 0x7F, 0x41, 0x00,// I\n\t0x20, 0x40, 0x41, 0x3F, 0x01,// J\n\t0x7F, 0x08, 0x14, 0x22, 0x41,// K\n\t0x7F, 0x40, 0x40, 0x40, 0x40,// L\n\t0x7F, 0x02, 0x04, 0x02, 0x7F,// M\n\t0x7F, 0x04, 0x08, 0x10, 0x7F,// N\n\t0x3E, 0x41, 0x41, 0x41, 0x3E,// O\n\t0x3E, 0x41, 0x51, 0x21, 0x5E,// Q\n\t0x7F, 0x09, 0x09, 0x09, 0x06,// P\n\t0x7F, 0x09, 0x19, 0x29, 0x46,// R\n\t0x46, 0x49, 0x49, 0x49, 0x31,// S\n\t0x01, 0x01, 0x7F, 0x01, 0x01,// T\n\t0x3F, 0x40, 0x40, 0x40, 0x3F,// U\n\t0x1F, 0x20, 0x40, 0x20, 0x1F,// V\n\t0x7F, 0x20, 0x18, 0x20, 0x7F,// W\n\t0x63, 0x14, 0x08, 0x14, 0x63,// X\n\t0x03, 0x04, 0x78, 0x04, 0x03,// Y\n\t0x61, 0x51, 0x49, 0x45, 0x43,// Z\n\t0x00, 0x00, 0x7F, 0x41, 0x41,// [\n\t0x02, 0x04, 0x08, 0x10, 0x20,// \\ \n\t0x41, 0x41, 0x7F, 0x00, 0x00,// ]\n\t0x04, 0x02, 0x01, 0x02, 0x04,// ^\n\t0x40, 0x40, 0x40, 0x40, 0x40,// _\n\t0x00, 0x01, 0x02, 0x04, 0x00,// `\n\t0x20, 0x54, 0x54, 0x54, 0x78,// a\n\t0x7F, 0x48, 0x44, 0x44, 0x38,// b\n\t0x38, 0x44, 0x44, 0x44, 0x20,// c\n\t0x38, 0x44, 0x44, 0x48, 0x7F,// d\n\t0x38, 0x54, 0x54, 0x54, 0x18,// e\n\t0x08, 0x7E, 0x09, 0x01, 0x02,// f\n\t0x08, 0x14, 0x54, 0x54, 0x3C,// g\n\t0x7F, 0x08, 0x04, 0x04, 0x78,// h\n\t0x00, 0x44, 0x7D, 0x40, 0x00,// i\n\t0x20, 0x40, 0x44, 0x3D, 0x00,// j\n\t0x00, 0x7F, 0x10, 0x28, 0x44,// k\n\t0x00, 0x41, 0x7F, 0x40, 0x00,// l\n\t0x7C, 0x04, 0x18, 0x04, 0x78,// m\n\t0x7C, 0x08, 0x04, 0x04, 0x78,// n\n\t0x38, 0x44, 0x44, 0x44, 0x38,// o\n\t0x7C, 0x14, 0x14, 0x14, 0x08,// p\n\t0x08, 0x14, 0x14, 0x18, 0x7C,// q\n\t0x7C, 0x08, 0x04, 0x04, 0x08,// r\n\t0x48, 0x54, 0x54, 0x54, 0x20,// s\n\t0x04, 0x3F, 0x44, 0x40, 0x20,// t\n\t0x3C, 0x40, 0x40, 0x20, 0x7C,// u\n\t0x1C, 0x20, 0x40, 0x20, 0x1C,// v\n\t0x3C, 0x40, 0x30, 0x40, 0x3C,// w\n\t0x44, 0x28, 0x10, 0x28, 0x44,// x\n\t0x0C, 0x50, 0x50, 0x50, 0x3C,// y\n\t0x44, 0x64, 0x54, 0x4C, 0x44,// z\n\t0x00, 0x08, 0x36, 0x41, 0x00,// {\n\t0x00, 0x00, 0x7F, 0x00, 0x00,// |\n\t0x00, 0x41, 0x36, 0x08, 0x00,// }\n\t0x08, 0x10, 0x08, 0x04, 0x08// ~\n);\n\n\nfloat char_px(int charid, int x, int y) {\n\tint col = Font5x7[(charid * char_width) + x];\n\tbool px = (col & (1 << (6 - y))) != 0;\n\n\treturn px ? 1.0 : 0.0;\n}\n\n// All components are in the range [0…1], including hue.\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// All components are in the range [0…1], including hue.\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 resolution = tile_size * floor(iResolution.xy / tile_size);\n\tvec2 px = mod(fragCoord.xy, resolution);\n\tvec2 tile_px = mod(px, tile_size);\n\n\tif (tile_px.x >= char_size.x || tile_px.y >= char_size.y) {\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\tvec4 rgb_id = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    int best = int(round(rgb_id.a * 255.0));\n    \n    int char_x = int(floor(float(tile_px.x) * 5.0 / char_size.x));\n    int char_y = int(floor(float(tile_px.y) * 7.0 / char_size.y));\n    \n    // output the correct character\n    float char_val = char_px(best, char_x, char_y);\n    vec3 hsv_out = vec3(rgb2hsv(rgb_id.rgb).xy, char_val);\n    vec3 out_color = hsv2rgb(hsv_out);\n    \n    // quantize the output color\n\tfragColor = vec4(floor(out_color * float(1 << bpc)) / float(1 << bpc), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sigmoid(float a, float f) {\n\treturn 1.0 / (1.0 + exp(-f * a));\n}\n\n// I can't remember where I found this edge detection method,\n// but since it uses fwidth I had to put it in its own shader.\n// Copy-pastes the RGB channels to avoid extra channels on the final pass.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 in_color = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = vec4(in_color.rgb, sigmoid(length(fwidth(in_color)) - 0.2, 15.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/* This is where the magic happens!\n * \n * This shader calculates the error for each character for each tile,\n * and chooses the character with the lowest total error. Additionally,\n * the color of the character is calculated, and both the color and the\n * character's ID are rendered to the shader.\n *\n * For an order of magnitude performance improvement, even while using more chars,\n * output the results of this shader to a downscaled buffer (downscaled by tile_size).\n * On my Core m7-6y75 laptop, running these shaders locally, I went from 10fps to 200fps,\n * and of course locally I was able to use 72 chars before bottlenecking.\n * \n */\n\nprecision lowp sampler2D;\nprecision lowp float;\nprecision lowp int;\n\n\n/* Relative strengths of different shading methods        *\n * These are automatically normalized against each other */\nconst float edge_strength = 0.25;              // Makes line art via edge detection.\n                                              // Quality varies based on edge quality.\nconst float normal_shading_strength = 1.0;    // Standard least absolute values regression,\n                                              // finds solid surfaces but loses contrast.\nconst float dithered_shading_strength = 1.0;  // Equivalent to brightness-based ASCII filter.\n                                              // Minimizes total error for the whole tile,\n                                              // adds details & shading in the dark, but\n                                              // loses detail in the light.\n\n// Quality\n\nconst int num_chars = 24;       // how many of the characters will be used.\n                                // performance is very sensitive to this setting.\n\nconst int gap_width = 1;\nconst int gap_height = 1;\n\nconst int char_width = 5;\nconst int char_height = 7;\n\n\n\nconst vec2 char_size = vec2(char_width, char_height);\nconst vec2 tile_size = char_size + vec2(gap_width, gap_height);\n\nconst float total_mul = edge_strength + normal_shading_strength + dithered_shading_strength;\nconst float edge_mul = edge_strength / total_mul;\nconst float highlights_mul = normal_shading_strength / total_mul;\nconst float shadows_mul = dithered_shading_strength / total_mul;\n\n// standard ascii 5x7 font\n// defines ascii characters 0x20-0x7F (32-127)\nconst int Font5x7[95 * 5] = int[95 * 5](\n\t0x00, 0x00, 0x00, 0x00, 0x00,// (space)\n\t0x00, 0x00, 0x5F, 0x00, 0x00,// !\n\t0x00, 0x07, 0x00, 0x07, 0x00,// \"\n\t0x14, 0x7F, 0x14, 0x7F, 0x14,// #\n\t0x24, 0x2A, 0x7F, 0x2A, 0x12,// $\n\t0x23, 0x13, 0x08, 0x64, 0x62,// %\n\t0x36, 0x49, 0x55, 0x22, 0x50,// &\n\t0x00, 0x05, 0x03, 0x00, 0x00,// '\n\t0x00, 0x1C, 0x22, 0x41, 0x00,// (\n\t0x00, 0x41, 0x22, 0x1C, 0x00,// )\n\t0x08, 0x2A, 0x1C, 0x2A, 0x08,// *\n\t0x08, 0x08, 0x3E, 0x08, 0x08,// +\n\t0x00, 0x50, 0x30, 0x00, 0x00,// ,\n\t0x08, 0x08, 0x08, 0x08, 0x08,// -\n\t0x00, 0x60, 0x60, 0x00, 0x00,// .\n\t0x20, 0x10, 0x08, 0x04, 0x02,// /\n\t0x3E, 0x51, 0x49, 0x45, 0x3E,// 0\n\t0x00, 0x42, 0x7F, 0x40, 0x00,// 1\n\t0x42, 0x61, 0x51, 0x49, 0x46,// 2\n\t0x21, 0x41, 0x45, 0x4B, 0x31,// 3\n\t0x18, 0x14, 0x12, 0x7F, 0x10,// 4\n\t0x27, 0x45, 0x45, 0x45, 0x39,// 5\n\t0x3C, 0x4A, 0x49, 0x49, 0x30,// 6\n\t0x01, 0x71, 0x09, 0x05, 0x03,// 7\n\t0x36, 0x49, 0x49, 0x49, 0x36,// 8\n\t0x06, 0x49, 0x49, 0x29, 0x1E,// 9\n\t0x00, 0x36, 0x36, 0x00, 0x00,// :\n\t0x00, 0x56, 0x36, 0x00, 0x00,// ;\n\t0x00, 0x08, 0x14, 0x22, 0x41,// <\n\t0x14, 0x14, 0x14, 0x14, 0x14,// =\n\t0x41, 0x22, 0x14, 0x08, 0x00,// >\n\t0x02, 0x01, 0x51, 0x09, 0x06,// ?\n\t0x32, 0x49, 0x79, 0x41, 0x3E,// @\n\t0x7E, 0x11, 0x11, 0x11, 0x7E,// A\n\t0x7F, 0x49, 0x49, 0x49, 0x36,// B\n\t0x3E, 0x41, 0x41, 0x41, 0x22,// C\n\t0x7F, 0x41, 0x41, 0x22, 0x1C,// D\n\t0x7F, 0x49, 0x49, 0x49, 0x41,// E\n\t0x7F, 0x09, 0x09, 0x01, 0x01,// F\n\t0x7F, 0x08, 0x08, 0x08, 0x7F,// H\n\t0x3E, 0x41, 0x41, 0x51, 0x32,// G\n\t0x00, 0x41, 0x7F, 0x41, 0x00,// I\n\t0x20, 0x40, 0x41, 0x3F, 0x01,// J\n\t0x7F, 0x08, 0x14, 0x22, 0x41,// K\n\t0x7F, 0x40, 0x40, 0x40, 0x40,// L\n\t0x7F, 0x02, 0x04, 0x02, 0x7F,// M\n\t0x7F, 0x04, 0x08, 0x10, 0x7F,// N\n\t0x3E, 0x41, 0x41, 0x41, 0x3E,// O\n\t0x3E, 0x41, 0x51, 0x21, 0x5E,// Q\n\t0x7F, 0x09, 0x09, 0x09, 0x06,// P\n\t0x7F, 0x09, 0x19, 0x29, 0x46,// R\n\t0x46, 0x49, 0x49, 0x49, 0x31,// S\n\t0x01, 0x01, 0x7F, 0x01, 0x01,// T\n\t0x3F, 0x40, 0x40, 0x40, 0x3F,// U\n\t0x1F, 0x20, 0x40, 0x20, 0x1F,// V\n\t0x7F, 0x20, 0x18, 0x20, 0x7F,// W\n\t0x63, 0x14, 0x08, 0x14, 0x63,// X\n\t0x03, 0x04, 0x78, 0x04, 0x03,// Y\n\t0x61, 0x51, 0x49, 0x45, 0x43,// Z\n\t0x00, 0x00, 0x7F, 0x41, 0x41,// [\n\t0x02, 0x04, 0x08, 0x10, 0x20,// \\ \n\t0x41, 0x41, 0x7F, 0x00, 0x00,// ]\n\t0x04, 0x02, 0x01, 0x02, 0x04,// ^\n\t0x40, 0x40, 0x40, 0x40, 0x40,// _\n\t0x00, 0x01, 0x02, 0x04, 0x00,// `\n\t0x20, 0x54, 0x54, 0x54, 0x78,// a\n\t0x7F, 0x48, 0x44, 0x44, 0x38,// b\n\t0x38, 0x44, 0x44, 0x44, 0x20,// c\n\t0x38, 0x44, 0x44, 0x48, 0x7F,// d\n\t0x38, 0x54, 0x54, 0x54, 0x18,// e\n\t0x08, 0x7E, 0x09, 0x01, 0x02,// f\n\t0x08, 0x14, 0x54, 0x54, 0x3C,// g\n\t0x7F, 0x08, 0x04, 0x04, 0x78,// h\n\t0x00, 0x44, 0x7D, 0x40, 0x00,// i\n\t0x20, 0x40, 0x44, 0x3D, 0x00,// j\n\t0x00, 0x7F, 0x10, 0x28, 0x44,// k\n\t0x00, 0x41, 0x7F, 0x40, 0x00,// l\n\t0x7C, 0x04, 0x18, 0x04, 0x78,// m\n\t0x7C, 0x08, 0x04, 0x04, 0x78,// n\n\t0x38, 0x44, 0x44, 0x44, 0x38,// o\n\t0x7C, 0x14, 0x14, 0x14, 0x08,// p\n\t0x08, 0x14, 0x14, 0x18, 0x7C,// q\n\t0x7C, 0x08, 0x04, 0x04, 0x08,// r\n\t0x48, 0x54, 0x54, 0x54, 0x20,// s\n\t0x04, 0x3F, 0x44, 0x40, 0x20,// t\n\t0x3C, 0x40, 0x40, 0x20, 0x7C,// u\n\t0x1C, 0x20, 0x40, 0x20, 0x1C,// v\n\t0x3C, 0x40, 0x30, 0x40, 0x3C,// w\n\t0x44, 0x28, 0x10, 0x28, 0x44,// x\n\t0x0C, 0x50, 0x50, 0x50, 0x3C,// y\n\t0x44, 0x64, 0x54, 0x4C, 0x44,// z\n\t0x00, 0x08, 0x36, 0x41, 0x00,// {\n\t0x00, 0x00, 0x7F, 0x00, 0x00,// |\n\t0x00, 0x41, 0x36, 0x08, 0x00,// }\n\t0x08, 0x10, 0x08, 0x04, 0x08// ~\n);\n\n// extract a brightness value from a char\nfloat char_px(int charid, int x, int y) {\n\tint col = Font5x7[(charid * char_width) + x];\n\tbool px = (col & (1 << (6 - y))) != 0;\n\n\treturn px ? 1.0 : 0.0;\n}\n\n// All components are in the range [0…1], including hue.\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// All components are in the range [0…1], including hue.\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // correct resolution & fit tiles to grid\n    vec2 resolution = tile_size * floor(iResolution.xy / tile_size);\n\tvec2 px = mod(fragCoord.xy, resolution);\n\tvec2 tile = floor(px / tile_size) * tile_size;\n\tvec2 tile_px = mod(px, tile_size);\n    \n\tvec3 color;                       // used to calculate weighted average color\n    float div_by = 0.0;               // used to calculate weighted average color\n    \n\tfloat errors[num_chars];          // cumulative error magnitude\n    float dithered_error[num_chars];  // cumulative error, used for dithering\n    \n    // for each pixel in the tile,\n    for (int samp_y = 0; float(samp_y) < char_size.y; ++samp_y) {\n        for (int samp_x = 0; float(samp_x) < char_size.x; ++samp_x) {\n            vec2 samp_uv = (tile + vec2(samp_x, samp_y)) / iResolution.xy;\n            vec4 rgb_es = texture(iChannel0, samp_uv);\n            \n            // perform color space conversion\n            vec3 hsv = rgb2hsv(rgb_es.rgb);\n            \n            // extract edge detection data\n            float edge_detect = rgb_es.a;\n            \n            // contribute to the weighted average color\n            color += rgb_es.rgb * hsv.z * edge_detect;\n            div_by += hsv.z * edge_detect;\n            \n            // for each char,\n            int char_x = int(floor(float(samp_x) * 5.0 / char_size.x));\n            int char_y = int(floor(float(samp_y) * 7.0 / char_size.y));\n            for (int id = 0; id < num_chars; ++id) {\n                float char_pixel = char_px(id, char_x, char_y);\n                // calculate the pixel brightness error\n                float px_err = hsv.z - char_pixel;\n                // and the relative importance of the pixel (as an edge)\n                float edge_err = edge_detect - char_pixel;\n                \n                float px_err_mag = abs(px_err);\n                float edge_err_mag = edge_err * edge_err;\n                \n                // accumulate the errors appropriately\n                // these functions determine the characters making up the output image\n                // and are in no way perfect or final. I'm sure there are better methods\n                // which result in cleaner images.\n                errors[id] += px_err_mag * highlights_mul\n                            + edge_err_mag * edge_mul;\n                dithered_error[id] += px_err * px_err_mag * shadows_mul + edge_err * edge_mul;\n\t\t\t}\n\t\t}\n\t}\n\t\n    // iterate over the accumulated errors & choose the best character\n\tint best = 0;\n\tfloat min_error = errors[0] + abs(dithered_error[0]);\n\tfor (int id = 1; id < num_chars; ++id) {\n        float e = errors[id] + abs(dithered_error[id]);\n\t\tif (e < min_error) {\n\t\t\tbest = id;\n\t\t\tmin_error = e;\n\t\t}\n\t}\n    \n    // give the output color & character ID to the final stage\n    fragColor = vec4(color / div_by, float(best) / 255.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}