{"ver":"0.1","info":{"id":"3d3cWN","date":"1600948185","viewed":312,"name":"Blinn Phong Model","username":"GCScholar","description":"A simple shading model based on Blinn Phong with specular reflections from the cube map. \nLEFT to RIGHT:    ROUGH to SHINE\nBOTTOM to UP:   NON METAL to METAL","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["phong","light","blinn","shaing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14 \n#define FOCAL_LENGTH 1.5\n#define MAX_MARCHING_DISTANCE 20.\n\n// Union of two SDF results\nvec2 SD_Union(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Signed Distance Function for a sphere\nfloat SD_Sphere(vec3 P, float r) \n{\n\treturn length(P) - r;\n}\n\n// Render spheres with different material properties\nvec2 SD_Scene(vec3 P) \n{\n    vec2 d = vec2(MAX_MARCHING_DISTANCE, -1.0);\n    for(int i=0; i<5; i++)\n    {\n        for(int j=0; j<5; j++)\n    \t{\n            vec2 d1 = vec2(SD_Sphere(P+vec3(-float(j)+2.0,-float(i)+2.0,0.0), 0.35), float(i*5+j));\n            d = SD_Union(d, d1);\n        }\n    }\n    \n    for(int i=0; i<5; i++)\n    {\n        for(int j=0; j<5; j++)\n    \t{\n            vec2 d1 = vec2(SD_Sphere(P+vec3(-float(j)+2.0,-float(i)+2.0,2.0), 0.35), float(i*5+j)+25.0);\n            d = SD_Union(d, d1);\n        }\n    }\n    \n    for(int i=0; i<5; i++)\n    {\n        for(int j=0; j<5; j++)\n    \t{\n            vec2 d1 = vec2(SD_Sphere(P+vec3(-float(j)+2.0,-float(i)+2.0,4.0), 0.35), float(i*5+j)+50.0);\n            d = SD_Union(d, d1);\n        }\n    }\n    \n    return d;\n}\n\n// Compute the normals at P\nvec3 normal(vec3 P)\n{\n\tvec2 eps = vec2(0.,0.001);\n    return normalize(vec3(\n        SD_Scene(P+eps.yxx).x - SD_Scene(P-eps.yxx).x, \n\t\tSD_Scene(P+eps.xyx).x - SD_Scene(P-eps.xyx).x, \n        SD_Scene(P+eps.xxy).x - SD_Scene(P-eps.xxy).x));\n}\n\n// A hit from the ray marcher / tracer\nstruct Hit \n{\n    vec3 point;\n    vec3 normal;\n    int objId;\n};\n\n// A material specification\nstruct Material \n{\n\tfloat shininess;\t// How much a surface is shine (roughness = 1-shininess)\n    vec3 fresnelR0;\t\t// The fresnel constant at the 0 angle between incident light and surface normal\n    vec3 diffuseAlbedo;\t// The material albedo\n};\n    \n// Define materials in the scene\nMaterial material(int id) \n{\n    Material mat;\n    if(id>=25 && id<50) \n    {\n        id-=25;\n        mat.diffuseAlbedo = vec3(0.01,0.01,0.2);\n    } \n    else if(id>=50) \n    {\n    \tid-=50;\n        mat.diffuseAlbedo = vec3(0.2,0.01,0.01);\n    }\n    else mat.diffuseAlbedo = vec3(0.15,0.15,0.2);\n    float row = float(id)/5.0;\n    float col = mod(float(id),5.0);\n    \n    mat.shininess = col*0.2;\n    mat.fresnelR0 =\tvec3(row*0.2);\n    return mat;\n}\n\n\n// ILLUMINATION MODEL\n\n// Schlick approximation of the Fresnel reflectance\n// R0 \tthe\n// N \tthe normal to the surface\n// L \tthe light direction from the point on the surface\nvec3 SchlickFresnel(vec3 R0, vec3 N, vec3 L){\n\t\n\tfloat f0 = 1.0f - max(dot(N, L), 0.0);\n    return R0 + (1.0f - R0)*(f0*f0*f0*f0*f0);\n}\n\n// Blinn-Phong model\n// lightStrength\tthe RGB light intensity\n// L \t\t\t\tthe light direction from the point on the surface\n// N \t\t\tthe normal to the surface at the point\n// V\t\t\tthe viewer direction from the point on the surface\n// albedo\t\tthe material albedo\n// shininess\thow much the material is shine or rough\n// R0\t\t\t\nvec3 BlinnPhong(vec3 lightStrength, vec3 L, vec3 N, vec3 V, Material mat)\n{\n    vec3 H = normalize(L+V);\t// Half vector between View and Light vector\n\t\n    float m = mat.shininess * 256.0;\n    float roughnessFactor = ((m + 8.0)*pow(max(dot(H,N),0.0), m))/8.0;\t// Controls how much smooth is the material, taking into account normalization for energy conservation    \n\tvec3 fresnelFactor = SchlickFresnel(mat.fresnelR0, H, L);\n    vec3 specAlbedo = fresnelFactor*roughnessFactor;\n    specAlbedo = specAlbedo / (specAlbedo + 1.0f);\t// the formula goes outside [0,1]\n    return (mat.diffuseAlbedo.rgb + specAlbedo) * lightStrength;\n}\n\n// N \t\tis the surface normal, \n// P \t\tis the point to shade\n// R_F0 i \tthe amount of reflected (specular) light at the 0 angle \n//\t\t\t that is the lowest value for specular reflection that is maximum at PI angles.\n// \t\t\t More the material is metallic, higher is the reflection at 0\n// roughness        controls the roughness (low values) - smoothness (high values) of the surface\nvec4 render(Hit hit, vec3 P_eye)\n{\n    // Material properties\n    Material mat = material(hit.objId);\n    vec3 ambientLight = vec3(0.1,0.1,0.1);\n   \t\n    vec3 V = normalize(P_eye - hit.point);\t// Vector from surface point to the camera\n\tvec3 N = hit.normal; \n    vec3 R = reflect(-V,N);\t\t// Refleted light vector respect to N\n    \n    vec4 cubeMapSampleDiff = texture(iChannel0, N);\n    vec4 cubeMapSampleSpec = texture(iChannel1, R);\n    \n    // Light 1\n    vec3 toLight1Dir = normalize(vec3(-0.5, 0.5, 1.0));\n    vec3 light1Color = vec3(0.9, 0.9, 0.9);\n    \n    // Lambert-law attenuation\n    vec3 light1Strength = max(dot(toLight1Dir,N),0.0)*light1Color;\n    vec3 C_light1 = BlinnPhong(light1Strength, toLight1Dir, N, V, mat);\n\n    // Light 2 floor reflex\n    vec3 toLight2Dir = normalize(vec3(0.0, -1.0, 0.0));\n    vec3 light2Color = vec3(0.1, 0.2, 0.6);\n    \n    // Lambert-law attenuation\n    vec3 light2Strength = max(dot(toLight2Dir,N),0.0)*light2Color;\n    vec3 C_light2 = BlinnPhong(light2Strength, toLight2Dir,  N, V, mat);\n   \n\tvec4 reflectionColor = cubeMapSampleSpec;\n\tvec3 fresnelFactor = SchlickFresnel(mat.fresnelR0, hit.normal, R);\n\tvec3 specLigth = mat.shininess * fresnelFactor * reflectionColor.rgb;\n    \n    return vec4(C_light1 + specLigth ,1.0);\n}\n\n\n// Cast a ray into the scene\nHit castRay(vec3 ro, vec3 dir) \n{\n    Hit hit; hit.objId = -1;\n    float t=0.0;\n    while(t < MAX_MARCHING_DISTANCE) \n    {\n        vec3 P = ro+t*dir;\n        vec2 d = SD_Scene(P);\n        if(d.x < 0.001) \n        {\n            // We have an hit\n            hit.point = P;\n            hit.normal = normal(P);\n            hit.objId = int(d.y);\n            return hit;\n        }\n        t+=d.x;    \n    }\n    return hit; // No hit\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 R = iResolution;  \n    vec2 U = (2.*fragCoord-R.xy)/(R.x);\t// Centered normalized coordinates\n    \n    // Camera\n   \tvec3 P_eye;\n   \tvec2 camAngle = iMouse.xy/iResolution.xy;\n    P_eye = vec3(8.*-(sin(iTime/5.+3.0*camAngle.x)),0.5+4.0*camAngle.y,-8.*-abs(cos(iTime/5.+3.0*camAngle.x)));\n    //P_eye = vec3(0.0,0.0,8.0);\n    vec3 P_target = vec3(0.,0.,0.);\n    \n    // Right handed camera frame reference\n    vec3 ww = normalize(P_eye - P_target);\n    vec3 vv = normalize(cross(vec3(0.,1.,0.), ww));\n    vec3 uu = normalize(cross(ww, vv));\n    \n    // Ray through this pixel\n    vec3 ray = normalize(U.x*vv + U.y*uu - FOCAL_LENGTH*ww);\n    \n    // Ray trace/march scene\n    Hit hit = castRay(P_eye, ray);\n            \n    // Background\n    if(hit.objId == -1) fragColor = texture(iChannel1, ray);\n\t// Shading\n    else fragColor = render(hit, P_eye);\n       \n    // Apply gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(0.4545)),1.0);    \n}","name":"Image","description":"","type":"image"}]}