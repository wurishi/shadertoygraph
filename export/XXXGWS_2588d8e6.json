{"ver":"0.1","info":{"id":"XXXGWS","date":"1707899126","viewed":52,"name":"ray rtxing","username":"Tatovka","description":"rtxtrt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["trx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14\n#define objects 5\nstruct Ray{\nvec3 origin;\nvec3 direction;\nvec3 color;\nint end;\nvec3 at; \n};\nRandom rng; \nfloat shift=0.0;\nfloat ratio=1.0;\nvec3 at(Ray r,float t){\n    return r.origin+r.direction*t;\n}\nfloat SqrLength(vec3 vec){\n    return vec.x*vec.x+vec.y*vec.y+vec.z*vec.z;\n}\nvec3 RandomVector(){\n    while(true){\n        vec3 vec = range(rng, vec3(0.0), vec3(1.0));\n        //if (SqrLength(vec) <= 1.0)\n        return vec/SqrLength(vec);\n    }\n}\n//mandelbrot\n#define n 8.\n\nbool sqr(vec3 g1) {\nreturn(length(g1)>4.);\n}\nvec3 sqrf(vec3 g1,vec3 g2) {\nfloat r=(g1.x*g1.x+g1.y*g1.y+g1.z*g1.z);\nfloat O=atan(g1.y/g1.x);\nr=pow(r,n/2.);\nfloat o=atan(sqrt(g1.x*g1.x+g1.y*g1.y)/g1.z);\nreturn(r*vec3(cos(n*O)*cos(n*o),cos(n*o)*sin(n*O),-sin(n*o))+g2);\n}\n\nbool graph(vec3 z){\nvec3 z1;\nz1=z;\nfor (float its = 0.0; its <5.0; its+=1.0) {\nif (sqr(z1))\nreturn false;\nz1 = sqrf(z1,z);\n}\nreturn true;\n}\n\nfloat GetTFrac(Ray ray){\n    Ray r1=ray;\n    r1.origin+=vec3(0,2,-0.4);\n    for (float t=0.0005;t<3.5;t+=.02){\n        if(graph(at(r1,t))){\n            //sphArr[3].center=at(r1,t)-sphArr[3].r;\n            return t;\n        }\n    }\n    return -1.;\n}\n\nvec3 RayColor(){\n   return vec3(0.5, 0.7, 1.0);\n}\nfloat GetT(Sphere sph,Ray ray){\n    vec3 v =sph.center-ray.origin;\n    float b = dot(ray.direction,v);\n    float c = SqrLength(v)-sph.r*sph.r;\n    float disc = b*b-c;\n    if (disc>=0.0)\n        return (b-sqrt(disc));\n    return -1.0;\n}\nfloat GetDistance(Ray r, vec3 point){\nvec3 a=point-r.origin;\nfloat cos_=abs(dot(r.direction,a))/length(r.direction)*length(a);\nfloat h = length(a)*sqrt(1.0-cos_*cos_);\nreturn h;\n}\nRay HitSphere(Ray ray){\n    float minT=-1.0;\n    int minI=-1;\n    for (int i=0;i<objects;i++){\n        float t;\n        if(i==4)\n            t=GetTFrac(ray);\n        else\n            t = GetT(sphArr[i],ray);\n            if (((t)<(minT) || minI==-1) && t>0.0001){\n                vec3 normal = (at(ray,t)-sphArr[i].center);               \n                minT=t;\n                minI=i;\n            }\n        }\n    if (minI!=-1){        \n        vec3 normal = normalize(at(ray,minT)-sphArr[minI].center);\n        \n        if(dot(normal,ray.direction)>0.0){\n            normal=normal;\n            }\n        Material mat=sphArr[minI].mat;\n        ray.color = max(vec3(0.0),mat.albedo*ray.color);\n        vec3 newDir=RandomVector();\n        if(dot(normal,newDir)<0.0)\n            newDir=-newDir;\n        newDir+=normal;\n        \n        newDir/=2.0;\n        if(minI==3){ \n            ray.end=1;\n            ray.color*=mat.albedo;\n        //ray.end=1;\n        }\n        ray.origin=at(ray,minT);\n        vec3 a=ray.direction;\n        vec3 b; //результат\n        b=reflect(a,normal);\n\n        ray.direction=(newDir*(1.0-mat.metallic))+b*mat.metallic;\n        \n        return ray;\n    }\n   //ray.color*=min(1.0,max(0.1,1.0/GetDistance(ray,light)));\n   //if(GetT(sphArr[3],ray)==-1.0)\n   ray.color*=0.5;\n   ray.end=1;\n   return ray;\n}\n\nvec3 TraceRay(Ray ray){\n    int count=0;\n    vec3 color=vec3(0,0,0);\n    int steps=0;\n    int maxStep=4;\n    while(steps<maxStep){\n        count=0;\n        Ray r1=ray;\n        r1.origin+=vec3(1.0/800.0*float(steps/2),1.0/450.0*float(steps%2),r1.origin.z);\n        while(count<100){\n            r1=HitSphere(r1);\n            if (r1.end == 1){\n                color += r1.color;\n                count=1000;\n            }\n            count+=1;\n        }\n        if (r1.end!=1)\n            color += r1.color;\n        steps+=1;\n    }\n    return (sqrt(color/float(maxStep)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\nInitObjects();\nivec2 fc = ivec2(fragCoord);\nrng = seed(seed(iFrame), fc.x*1024+fc.y);\nvec2 uv = fragCoord/iResolution.xy;\nfloat aspectRatio=iResolution.x/iResolution.y;\nfloat viewSize=1.0;\nfloat viewY=0.5;\nvec3 cameraPos=vec3(0,0.0,0.0);\nvec3 pixelPos=vec3(aspectRatio-uv.x*aspectRatio*viewSize,viewY,1.-uv.y*viewSize)-vec3(aspectRatio/2.0,0,0.5);\n//light=vec3(1,-2,0);\n//sphArr[3].center.z=cos(iTime)*5.0;\n//sphArr[3].center.x=(cos(iTime))*10.0;\n//sphArr[3].center.y=(sin(iTime))*10.0;\nRay ray;\nray.origin=cameraPos;\nray.direction=normalize(cameraPos-pixelPos);\nray.color=vec3(1);\nray.end=0;\n\nvec3 color = TraceRay(ray);\n    fragColor=vec4(color,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// random number generator library (https://www.shadertoy.com/view/ssGXDd)\n// by Leonard Ritter (@leonard_ritter)\n\n// based on https://www.shadertoy.com/view/MdcfDj\n// license: https://unlicense.org/\n\n// 2022/11/27: added support for hexagon sampling\n\n// comment out for faster but lower quality hashing\n#define RNGL_HIGH_QUALITY\n\nstruct Random { uint s0; uint s1; };\n\n// constructors; note that constructors are wilfully unique,\n// i.e. calling a different constructor with the same arguments will not\n// necessarily produce the same state.\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\n\n// fundamental functions to fetch a new random number\n// the last static call to the rng will be optimized out\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\n\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\n\n// ranged random value < maximum value\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n// marshalling functions for storage in image buffer and rng replay\nvec2 marshal(Random a) { return uintBitsToFloat(uvec2(a.s0,a.s1)); }\nRandom unmarshal(vec2 a) { uvec2 u = floatBitsToUint(a); return Random(u.x, u.y); }\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }\nstruct Material{\nvec3 albedo;\nfloat metallic;\n};\nstruct Sphere{\nvec3 center;\nfloat r;\nMaterial mat;\n};\n\nvec3 halfAbsorb=vec3(0.5);\nSphere sphArr[5];\nSphere sun;\nvoid InitObjects(){\n    \n    Material dif1;\n    dif1.albedo=vec3(0.8);\n    dif1.metallic=1.0;\n    \n    Material dif2;\n    dif2.albedo=vec3(0.9,0.9,0.5);\n    dif2.metallic=0.1;\n    \n    Material dif3;\n    dif3.albedo=vec3(0.9,0.5,0.5);\n    dif3.metallic=0.0;\n    \n    sphArr[1].center=vec3(-1.5,-1.5,0.0);\n    sphArr[1].r=0.5;\n    sphArr[1].mat=dif1;\n    sphArr[2].center=vec3(1.5,-1.5,0);\n    sphArr[2].r=0.5;\n    sphArr[2].mat=dif2;\n    sphArr[0].center=vec3(0,-1.0,-100.5);\n    sphArr[0].r=100.0;\n    sphArr[0].mat=dif3;\n    \n    sun.center=vec3(-2,6.,7.5);\n    sun.r=7.5;\n    Material sunMat;\n    sunMat.albedo=vec3(0.98,0.98,0.8);\n    sunMat.metallic=0.0;\n    sun.mat=sunMat;\n    sphArr[3]=sun;\n    sphArr[4]=sphArr[2];\n    }","name":"Common","description":"","type":"common"}]}