{"ver":"0.1","info":{"id":"llVBD3","date":"1545065922","viewed":410,"name":"try atmosphere scattering","username":"cailuming","description":"My first try about atmosphere scattering, still, there are some problem to be solved  ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["mieandrayleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define U_PI 3141592657U\n\n#define MAXIT 32.0\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n \nmat2 rot2D(float a){\n   float c =cos(a);\n   float s =sin(a);\n   return mat2(c,s,-s,c); \n}\n \n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8pi * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\nfloat density(float h,float s){\n   return exp(-h/s);\n}\n \n// get the optical depth\nfloat optic(float h,float b,float s){\n    \n    float ret = 0.0;\n    float smc = 4.0;\n    float t   = b;\n    float len = h/smc;\n    for(float i=0.0;i<smc;i++){\n        ret+= density(t,s);\n        t+= len;\n    }\n    ret*=len;\n    return clamp(ret,0.,1.0);\n}\n\n\nvec2 hash2(vec2 uv){\n   float drive = 1.0+iTime*0.2*PI; \n   float r = fract(sin(dot(uv,vec2(3.7345236,PI))*PI*128493.0)); \n   float r1 = fract(sin(dot(uv,vec2(r,PI))*PI*14327.0)); \n   \n   return vec2(r,r1)*rot2D(drive);\n}\n\nfloat noise2D(vec2 uv){\n   vec2 p = floor(uv);\n   vec2 f = fract(uv);\n   vec2 e = vec2(1,0);\n   vec2 p00 = p;\n   vec2 p10 = p+e;\n   vec2 p11 = p+e.xx;\n   vec2 p01 = p+e.yx;\n   float v00 = dot(f-e.yy,hash2(p00));\n   float v10 = dot(f-e.xy,hash2(p10));\n   float v11 = dot(f-e.xx,hash2(p11));\n   float v01 = dot(f-e.yx,hash2(p01));\n    \n   f = f*f*f*(f*(f*6.-15.)+10.); \n   \n   return mix(mix(v00,v10,f.x),mix(v01,v11,f.x),f.y);\n}\n\nfloat fbm(vec2 uv){\n    float freq = .2;\n    float ampli = 4.0;\n    float ret   = 0.5;\n    for (int i=0;i<8;i++){\n       ret+= noise2D(uv*freq)*ampli;\n       uv +=vec2(ret,ret);\n       freq*=2.0;\n       ampli*=0.5;\n    }\n    return smoothstep(-1.0,1.0,ret);\n}\n \nvec2 sphere(vec3 o,vec3 dir,vec4 sp){\n   vec3 a = sp.xyz - o;\n   float b = dot(dir,a);\n   float d = sqrt(dot(a,a)-b*b);\n   float t = sqrt(sp.w*sp.w-d*d);\n   if(d>sp.w) return vec2(-1); \n   return vec2(b-t,b+t);\n}\n\nvec2 intersect(vec4 p){\n    if(p.z<=-1.0){\n       return p.xy;\n    }\n    return vec2(p.x,p.z);\n}\n\nvec3 getColor(float c){\n   float r= cos((c-0.85)*PI);\n   float g= cos((c-0.55)*PI);\n   float b= cos((c-0.15)*PI);\n    \n   return vec3(r,g,b); \n}  \n \nvoid planet(inout Ray r,inout vec3 col,vec3 lp,vec3 sc){\n    float t  = 0.0;\n    float er = 2.0;\n    float ar = er*1.5;\n    float h  = 0.0;\n    float lh  = 0.0;\n    float c  = 0.0;\n    float td = 0.0;\n    float h_mie = 0.01;\n    float h_ray = 0.04;\n    float d_mie = 0.0;\n    float d_ray = 0.0;\n    float t_mie0 = 0.0;\n    float t_ray0 = 0.0;\n    float t_mie1 = 0.0;\n    float t_ray1 = 0.0;\n    float nl     = 0.0;\n    vec3 c_ray = vec3(0.);\n    vec3 c_mie = vec3(0.);\n    vec3 c_mul = vec3(0.);\n   \n    vec3 kray = vec3(15, 40, 85.0);\n    \n    vec3 kmie = vec3(80.);\n   \n    vec2  et = sphere(r.o,r.d,vec4(sc,er));\n    vec2  at = sphere(r.o,r.d,vec4(sc,ar));\n    vec2  lt = sphere(lp,-lp,vec4(sc,ar));\n    \n    vec2  pt = intersect(vec4(at,et));\n    vec3  ps = pt.x*r.d+r.o;\n    vec3  pe = pt.y*r.d+r.o;\n    vec3  pl = lt.x*normalize(-lp)+lp;\n    vec3  n  = vec3(0);\n    vec3  ep = pt.x*r.d+r.o;\n    \n    vec3  p  = ps;\n    float stp = length(pt.y-pt.x)*1.1/MAXIT;\n    \n    if(at.x<=0.) return;\n    \n    for(int i=0;i<int(MAXIT);i++){\n        p = p+r.d*stp;\n        h = length(p)-er;\n        lh = length(pl-p)*0.6;\n         \n        d_mie=density(h,h_mie);\n        d_ray=density(h,h_ray);\n        \n        t_mie0+=d_mie*stp;\n        t_ray0+=d_ray*stp;\n        \n        t_mie1=optic(lh,h,h_mie);\n        t_ray1=optic(lh,h,h_ray);\n        \n        c_mul= exp(-(t_ray0+t_ray1)*kray*0.02-(t_mie0+t_mie1)*kmie*0.007);\n        c_ray+= d_ray*c_mul*stp;\n        c_mie+= d_mie*c_mul*stp;\n        \n    }\n    \n    n = normalize(p);\n    c =  dot(normalize(lp),-r.d);\n    nl = dot(n,normalize(lp));\n   \n    \n    col += c_ray*kray*phase_ray(c*c)+c_mie*kmie*phase_mie(-0.77,c,c*c);\n\n    if(length(p)<=er+0.001){\n        nl = smoothstep(-0.3,1.0,nl);\n        col +=fbm(3.*vec2(atan(p.z,p.x),p.y))*getColor(0.4)*0.6*nl;\n        col *=nl;\n        \n    }\n       \n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n    vec3 look = normalize(tar-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up    = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right+uv.y*up+look);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv -vec2(0.5);\n    cuv.x*= iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 eye = vec3(0,0,-5.);\n    vec3 tar = vec3(0,0,1);\n    vec3 lp  = vec3(5.0*cos(iTime*0.2),0.0,5.0*sin(iTime*0.2));\n    Ray r;\n    setCamera(r,eye,tar,cuv);\n    planet (r,col,lp,vec3(0));\n   \n    \n    col = pow(col,vec3(.45));\n    col = smoothstep(0.,1.,col);\n\n    //Atmosphere(r,col,lp);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}