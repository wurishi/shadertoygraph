{"ver":"0.1","info":{"id":"wsj3RV","date":"1549414344","viewed":242,"name":"Purple Ripple","username":"oalpha","description":"Trying to raytrace liquid.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raytracer","liquid","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct distanceestimation {\n    vec3 p;\n    vec3 s;\n    vec3 d;\n    float l;\n    vec3 n;\n};\n\n#define NUMPOINTS 20\nfloat np = float(NUMPOINTS);\nfloat S = 1.;\nfloat DistanceEstimator(inout distanceestimation d) {\n    vec2 uv = fract(d.p.xy * 0.25/S)*S;\n    float displacement = 0.0;\n    #define SIMPLE\n    #ifdef SIMPLE\n    vec2 res0 = iChannelResolution[0].xy;\n    uv *= res0;\n    vec2 luv = floor(uv);\n    vec2 fuv = fract(uv);\n    #ifdef CURVE\n    #undef CURVE\n    #endif\n    #define CURVE(h) curve3(h)\n    vec4 X = CURVE(vec4(\n        1.0 - fuv.x,\n        fuv.x,\n        1.0 - fuv.x,\n        fuv.x\n    ));\n    vec4 Y = CURVE(vec4(\n        1.0 - fuv.y,\n        1.0 - fuv.y,\n        fuv.y,\n        fuv.y\n    ));\n    vec4 F = X * Y;\n    displacement += texture(iChannel0, Mod(luv / res0, 1.0)).x * F.x;\n    displacement += texture(iChannel0, Mod((luv + i2) / res0, 1.0)).x * F.y;\n    displacement += texture(iChannel0, Mod((luv + j2) / res0, 1.0)).x * F.z;\n    displacement += texture(iChannel0, Mod((luv + 1.0) / res0, 1.0)).x * F.w;\n    #else\n    float t = iTime * 2.;\n    int s = int(floor(t));\n    for(int i = 0; i < NUMPOINTS; i++) {\n        int n = s - i;\n        vec3 point = vec3(\n            randab(sqrt(2.)*float(n))*S,\n            t - float(n)\n        );\n        float d = distance(uv, point.xy);\n        for(float ix = -1.; ix < 1.5; ix++)\n            for(float iy = -1.; iy < 1.5; iy++) {\n                d = min(d, distance(uv + vec2(ix,iy)*S, point.xy));\n            }\n        float l = point.z - 20. * d;\n        float amplitude = clamp(\n            (2. - l) * l * exp(1. - l),\n            0., 1.\n        ) * clamp(1. - d / .5, 0., 1.);\n        displacement += cos(10. * l) * amplitude;\n    }\n    displacement = displacement * .5 + .5;\n    #endif\n    displacement *= .05;\n    d.s = vec3(d.p.xy, displacement);\n    d.l = d.p.z - displacement;\n    return d.l;\n}\nvec3 normal(vec3 p) {\n    float diff = 0.00001;\n    distanceestimation d = distanceestimation(\n        vec3(0.0), //p\n        vec3(0.0), //s\n        vec3(0.0), //d\n        0.0, //l\n        vec3(0.0) //n\n    );\n    d.p = p - diff * i3;\n    float nx = DistanceEstimator(d);\n    d.p = p + diff * i3;\n    float px = DistanceEstimator(d);\n    d.p = p - diff * j3;\n    float ny = DistanceEstimator(d);\n    d.p = p + diff * j3;\n    float py = DistanceEstimator(d);\n    d.p = p - diff * k3;\n    float nz = DistanceEstimator(d);\n    d.p = p + diff * k3;\n    float pz = DistanceEstimator(d);\n    return normalize(vec3(\n        px - nx,\n        py - ny,\n        pz - nz\n    ));\n}\nstruct point {\n    vec3 source;\n    vec3 direction;\n    vec3 position;\n    vec3 normal;\n    float marchlength;\n    int iterations;\n    float closestlength;\n    float closestdistance;\n    float penumbra;\n};\nvoid trace(inout point tracePoint, float k) {\n    float pdis = 1e20, dis;\n    tracePoint.direction = normalize(tracePoint.direction);\n    tracePoint.iterations = 0;\n    distanceestimation d = distanceestimation(\n        vec3(0.0),\n        vec3(0.0),\n        tracePoint.direction,\n        0.0,\n        vec3(0.0)\n    );\n\tfor (int steps = 0; steps < MaximumRaySteps; steps++) {\n        if(\n            tracePoint.iterations == 0\n            || abs(dis) > MinimumDistance\n            && tracePoint.marchlength < MaximumDistance\n            && length(Center - tracePoint.position) < MaximumRadius\n        ) {\n            tracePoint.position = tracePoint.source + tracePoint.marchlength * tracePoint.direction;\n            d.p = tracePoint.position;\n            dis = DistanceEstimator(d);\n            tracePoint.normal = d.n;\n            tracePoint.marchlength += dis;\n            float y = dis*dis/(2.0*pdis);\n\t\t\tfloat d = sqrt(dis*dis-y*y);\n            pdis = dis;\n            if(steps == 0) {\n                tracePoint.closestdistance = d;\n                tracePoint.closestlength = max(0.0,tracePoint.marchlength-y);\n                tracePoint.penumbra = k * d/max(0.0,tracePoint.marchlength-y);\n            }\n            else {\n                if(d < tracePoint.closestdistance) {\n                    tracePoint.closestdistance = d;\n                    tracePoint.closestlength = max(0.0,tracePoint.marchlength-y);\n                }\n                tracePoint.penumbra = min(tracePoint.penumbra, k * d/max(0.0,tracePoint.marchlength-y));\n            }\n            tracePoint.iterations++;\n        }\n\t}\n    if(length(Center - tracePoint.position) > MaximumRadius || tracePoint.marchlength > MaximumDistance) {\n        tracePoint.position = vec3(0.0);\n        tracePoint.iterations = MaximumRaySteps;\n    }\n}\n#define AMBIENT_LIGHT   0\n#define POINT_LIGHT     1\n#define CONE_LIGHT      2\n#define DIRECTION_LIGHT 3\nstruct light {\n    int type;\n    vec3 position;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    float falloff;\n    float spread;\n    float taper;\n};\nlight ambientLight(vec3 color, float intensity) {\n    return  light(\n        AMBIENT_LIGHT, // type\n        vec3(0.0), // position (N/A)\n        color, // color\n        intensity, // intensity\n        vec3(0.0), //direction (N/A)\n        0.0, // falloff (N/A)\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\nlight ambientLight(float color, float intensity) {\n    return ambientLight(vec3(color), intensity);\n}\nlight pointLight(vec3 position, vec3 color, float intensity, float falloff) {\n    return light(\n        POINT_LIGHT, // type\n        position, // position\n        color, // color\n        intensity, // intensity\n        vec3(0.0), //direction (N/A)\n        falloff, // falloff\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\nlight pointLight(vec3 position, float color, float intensity, float falloff) {\n    return pointLight(position, vec3(color), intensity, falloff);\n}\nlight directionLight(vec3 direction, vec3 color, float intensity) {\n    return light(\n        DIRECTION_LIGHT, // type\n        vec3(0.0), // position (N/A)\n        color, // color\n        intensity, // intensity\n        direction, //direction\n        0.0, // falloff (N/A)\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\n#define LAMBERT_DIFFUSE   0\n#define ORENNAYAR_DIFFUSE 1\n#define PHONG_SPECULAR 0\nstruct material {\n    float roughness;\n    vec3 ambientalbedo;\n    int diffusetype;\n    vec3 diffusealbedo;\n    int speculartype;\n    vec3 specularalbedo;\n};\nstruct lightpath {\n    point p;\n    light l;\n    vec3 normal;\n    float ilength;\n    vec3 iray;\n    vec3 vray;\n    vec3 rray;\n    vec2 incident;\n    vec2 view;\n    vec2 reflected;\n    float energy;\n};\nlightpath Lightpath(point p, light l, vec3 n) {\n    vec3 i = vec3(0.0);\n    float il = 0.0;\n    if(l.type == DIRECTION_LIGHT) {\n        i = -l.direction;\n        il = 0.0;\n    }\n    else {\n        i = l.position - p.position;\n        il = length(i);\n        i = normalize(i);\n    }\n    vec3 v = -p.direction;\n    vec3 r = 2.0 * dot(i, n) * n - i;\n    vec3 t = normalize(cross(cross(n, i), n));\n    vec3 tv = normalize(cross(cross(n, v), n));\n    vec3 tr = normalize(cross(cross(n, r), n));\n    float energy;\n    if(l.type != DIRECTION_LIGHT) {\n        energy = l.intensity / pow(il, l.falloff);\n        if(l.type == CONE_LIGHT)\n            energy *= pow((l.spread - acos(dot(-i, l.direction))) / l.spread, l.taper);\n    }\n    else\n        energy = l.intensity;\n    return lightpath(\n        p,\n        l,\n        n,\n        il,\n        i,\n        v,\n        r,\n        vec2(dot(n, i), 0.0), // incident\n        vec2(dot(n, v), dot(t, tv)), // view\n        vec2(dot(n, r), dot(t, tr)), // reflected\n        energy\n    );\n}\nmat3 lookAt(vec3 camera, vec3 target, vec3 up, float film, vec2 fov) {\n    vec3 z = normalize(camera - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return film * mat3(\n        fov.x,0.0,0.0,\n        0.0,fov.y,0.0,\n        0.0,0.0,1.0\n    ) * mat3(x, y, -z);\n}\nvec3 lambert(material m, lightpath lp) {\n    return m.diffusealbedo / PI * lp.l.color * lp.energy * lp.incident.x;\n}\nvec3 orennayar(material m, lightpath lp) {\n    float roughness = tan(0.999 * m.roughness * PI / 2.0);\n    float A = 1.0 - 0.5 * m.roughness / (m.roughness + 0.33);\n    float B = 0.45 * m.roughness / (m.roughness + 0.09);\n    float ca = max(lp.incident.x, lp.view.x);\n    float cb = min(lp.incident.x, lp.view.x);\n    float sa = sqrt(1.0 - ca * ca);\n    float tb = sqrt(1.0 / (cb * cb) - 1.0);\n    return m.diffusealbedo / PI * lp.l.color * lp.energy * lp.incident.x * (A + (B * max(0.0, lp.view.y) * sa * tb));\n}\nvec3 phong(material m, lightpath lp) {\n    float shininess = tan(0.999 * (1.0 - m.roughness) * PI / 2.0);\n    return m.specularalbedo / PI * lp.l.color * lp.energy * lp.incident.x * pow(dot(lp.rray, lp.vray), shininess);\n}\nvoid lighting(inout vec3 r, inout vec3 a, material m, light l, point p, vec3 n) {\n    if(l.type == AMBIENT_LIGHT)\n        a = clamp(a + m.ambientalbedo / PI * l.color * l.intensity, 0.0, 1.0);\n    else {\n        lightpath lp =  Lightpath(p, l, n);\n        vec3 L = vec3(0.0);\n        if(m.diffusetype == LAMBERT_DIFFUSE)\n            L = lambert(m, lp);\n        else if(m.diffusetype == ORENNAYAR_DIFFUSE)\n            L = orennayar(m, lp);\n        vec3 S;\n        if(m.speculartype == PHONG_SPECULAR)\n            L += phong(m, lp);\n        if(false && length(L) > 0.0001) {\n            point sp = point(\n                p.position + lp.iray * 0.01, // source\n                lp.iray, // direction\n                vec3(0.0), // position\n                vec3(0.0), // normal\n                0.0, // marchlength\n                0, // iterations\n                0.0, // closestlength\n                0.0, // closestdistance\n                0.0 // penumbra\n            );\n            trace(sp, 1.0);\n            float sf = exm1_ex(sp.penumbra);\n            sf = 1.0;\n            if(sp.iterations < MaximumRaySteps && sp.marchlength < lp.ilength)\n                sf = 0.0;\n            L *= sf;\n        }\n        r = clamp(r + L, 0.0, 1.0);\n        r = r + L;\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    float h = 2.0 / iResolution.x;\n    //uv.x *= iResolution.x / uResolution.y;\n    float t = 1.0 * iTime * 0.25;\n    //t = 0.;\n    \n    vec3 camera = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t),  cos(t), 0.0,\n           0.0,     0.0, 0.75\n    ) * vec3(3.0, -5.0, 5.0) * 0.5;\n    mat3 raycaster = lookAt(\n        camera,\n        vec3(0.0, 0.0, -0.2), // target\n        vec3(0.0, 0.0, 1.0), // up\n        0.5, // film\n        vec2(1.0) // fov\n    );\n    \n    light la = ambientLight(1.0, 0.0);\n    light lp1 = pointLight(\n        vec3(-32.0, 16.0, 20.0), // position\n        vec3(0.86, 0.91,\t0.96), // color\n        2560.0, // intensity\n        2.0 // falloff\n    );\n    light lp2 = pointLight(\n        vec3(64.0, 96.0, 8.0), // position\n        vec3(1.0,0.97,\t0.86), // color\n        128000.0, // intensity\n        2.0 // falloff\n    );\n    light lp3 = pointLight(\n        vec3(0.5, 0.7, 1.0), // position\n        //vec3(1.0, 0.8, 0.85), // color\n        vec3(1.0, 0.89, 0.85), // color\n        7.5, // intensity\n        1.125 // falloff\n    );\n    material m = material(\n        0.05, // roughness\n        vec3(1.0), // ambientalbedo\n        //LAMBERT_DIFFUSE, // diffusetype\n        ORENNAYAR_DIFFUSE, // diffusetype\n        vec3(.01), // diffusealbedo\n        PHONG_SPECULAR, // speculartype\n        vec3(.5,.5,.75) // specularalbedo\n    );\n    vec3 bg = vec3(0.53, 0.81, 0.98);\n    \n    #define SAMPLES 1\n    vec3 pixel = vec3(0.0);\n    \n    float fsn = float(SAMPLES);\n    float factor = 1.0 / (fsn * fsn);\n    for(int i = 0; i < SAMPLES; i++)\n        for(int j = 0; j < SAMPLES; j++) {\n            vec2 cuv = uv + h * (factor * vec2(float(i), float(j)) - 0.5 + 0.5 / fsn);\n            point p = point(\n                camera, // source\n                raycaster * vec3(cuv, 1.0), // direction\n                vec3(0.0), // position\n                vec3(0.0), // normal\n                0.0, // marchlength\n                0, // iterations\n                0.0, // closestlength\n                0.0, // closestdistance\n                0.0 // penumbra\n            );\n            trace(p, 1.0);\n\n            vec3 v;\n            if(p.iterations < MaximumRaySteps) {\n                vec3 n = p.normal;\n                if(length(n) < 0.001)\n                    n = normal(p.position);\n                vec3 reflection = vec3(0.0), ambient = vec3(0.0);\n                lighting(reflection, ambient, m, lp1, p, n);\n                lighting(reflection, ambient, m, lp2, p, n);\n                lighting(reflection, ambient, m, lp3, p, n);\n                lighting(reflection, ambient, m, la, p, n);\n                float occlusion = 1.0 - float(p.iterations) / float(MaximumRaySteps);\n                \n                // Output to screen\n                v = clamp((reflection + ambient), 0.0, 1.0);\n                //v = vec3(occlusion);\n                //v = n * 0.5 + 0.5;\n                //v = normalize(p) * 0.5 + 0.5;\n                //v = normalize(p) / length(p) * 0.5 + 0.5;\n                //v = mix(v, bg, log(clamp(p.marchlength - 100.0, 0.0, 1.0) + 1.0));\n            }\n            else {\n                v = vec3(0.0);\n                v = bg;\n            }\n            pixel += v * factor;\n        }\n    fragColor = vec4(pixel, 1.0);\n    //fragColor = texture(iChannel0, fragCoord.xy);\n    //fragColor = texture(iChannel0, Mod(uv, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592653589793238462643383279\n#define PI2 6.283185307179586476925286766559\n\n#define i2 vec2(1.0, 0.0)\n#define j2 vec2(0.0, 1.0)\n#define i3 vec3(1.0, 0.0, 0.0)\n#define j3 vec3(0.0, 1.0, 0.0)\n#define k3 vec3(0.0, 0.0, 1.0)\n#define i4 vec4(1.0, 0.0, 0.0, 0.0)\n#define j4 vec4(0.0, 1.0, 0.0, 0.0)\n#define k4 vec4(0.0, 0.0, 1.0, 0.0)\n#define l4 vec4(0.0, 0.0, 0.0, 1.0)\n\n#define duo(a, b) a##b\n#define Iterations 1\n#define fIterations float(Iterations)\n#define Power 8.0\n#define Bailout 2.0\n\n#define MaximumRaySteps 200\n#define MaximumDistance 100.0\n#define MinimumDistance 0.001\n#define MaximumRadius 100.0\n\n#define Center vec3(0.0)\n\n#define CURVE(h) curve5(h)\n#undef CURVE\n#define CURVE(h) curve3(h)\n//#undef CURVE\n//#define CURVE(h) h\n\nfloat Dot(vec2 v) {\n    return dot(v, v);\n}\nfloat Dot2(vec2 a, vec2 b) {\n    float d = dot(a, b);\n    return d * d;\n}\nfloat triple(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\nfloat red_e(vec2 v, float f) {return dot(v, vec2(f));}\nfloat red_e(vec3 v, float f) {return dot(v, vec3(f));}\nfloat red_e(vec4 v, float f) {return dot(v, vec4(f));}\nfloat sum_e(vec2 v) {return red_e(v, 1.0);}\nfloat sum_e(vec3 v) {return red_e(v, 1.0);}\nfloat sum_e(vec4 v) {return red_e(v, 1.0);}\nfloat prod_e(vec2 v) {return v.x * v.y;}\nfloat prod_e(vec3 v) {return v.x * v.y * v.z;}\nfloat prod_e(vec4 v) {return v.x * v.y * v.z * v.w;}\nfloat exm1_ex(float x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec2 exm1_ex(vec2 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec3 exm1_ex(vec3 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec4 exm1_ex(vec4 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nfloat Mod(float a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, vec2  b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, float b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, vec3  b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, float b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, vec4  b) {return a - floor(a / b) * b;}\n\nfloat curve3(float a) {return a * a * (3.0 - 2.0 * a);}\nvec2  curve3(vec2  a) {return a * a * (3.0 - 2.0 * a);}\nvec3  curve3(vec3  a) {return a * a * (3.0 - 2.0 * a);}\nvec4  curve3(vec4  a) {return a * a * (3.0 - 2.0 * a);}\nfloat curve5(float a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec2  curve5(vec2  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec3  curve5(vec3  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec4  curve5(vec4  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\n\nfloat randa(float v) {\n    return fract(sin(v * 120.) * 1000. + PI);\n}\nfloat randb(float v) {\n    return fract(sin(v * 90.) * 987. + 2. * PI);\n}\nvec2 randab(float v) {\n    return vec2(randa(v),randb(v));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    #define NUMPOINTS 50\n    /*\n    float t = iTime * .2;\n    int s = int(floor(t));\n    float np = float(NUMPOINTS);\n    vec3 col = vec3(0);\n    for(int i = 0; i < NUMPOINTS; i++) {\n        int n = s - i;\n        vec3 point = vec3(\n            randab(sqrt(2.)*float(n)),\n            t - float(n)\n        );\n        float d = distance(uv, point.xy);\n        for(float ix = -1.; ix < 1.5; ix++)\n            for(float iy = -1.; iy < 1.5; iy++) {\n                d = min(d, distance(uv + vec2(ix,iy), point.xy));\n            }\n        float l = point.z - 2. * d;\n        float amplitude = clamp(\n            (np / 2. - l) * l * exp(1. - l) / (np - 1.),\n            0., 1.\n        ) * clamp(1. - d / .5, 0., 1.);\n        col += cos(50. * l) * amplitude;\n    }\n    */\n    float t = iTime * 2.;\n    int s = int(floor(t));\n    vec3 col = vec3(0);\n    for(int i = 0; i < NUMPOINTS; i++) {\n        int n = s - i;\n        vec3 point = vec3(\n            randab(sqrt(2.)*float(n)),\n            t - float(n)\n        );\n        float d = distance(uv, point.xy);\n        for(float ix = -1.; ix < 1.5; ix++)\n            for(float iy = -1.; iy < 1.5; iy++) {\n                d = min(d, distance(uv + vec2(ix,iy), point.xy));\n            }\n        float l = point.z - 20. * d;\n        float amplitude = clamp(\n            (2. - l) * l * exp(1. - l),\n            0., 1.\n        ) * clamp(1. - d / .5, 0., 1.);\n        col += cos(10. * l) * amplitude;\n    }\n\n    col = col * .5 + .5;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}