{"ver":"0.1","info":{"id":"wtjXWz","date":"1565648514","viewed":245,"name":"Sliced Fractal","username":"notargs","description":"1 dimension repeat & slice based fractal","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//====================================\n// Quaternion\n//====================================\nvec4 qmul(vec4 q1, vec4 q2) {\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t);\n}\n\nvec3 rotVec(vec3 v, vec4 r) {\n\tvec4 r_c = r * vec4(-1, -1, -1, 1);\n\treturn qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\n\nvec4 qaxis(float angle, vec3 axis) {\n\tfloat sn = sin(angle * 0.5);\n\tfloat cs = cos(angle * 0.5);\n\treturn vec4(axis * sn, cs);\n}\n\n//====================================\n// Distance functions\n//====================================\nfloat dist(vec3 pos)\n{\n    float d = 2.0 - length(pos.xy);\n    float scale = 1.0;\n    \n    for (int i = 0; i < 10; ++i)\n    {\n        vec3 p = mod(pos, 8.0) - 4.0;\n    \td = max(d, ((sin(iTime + float(i) * 0.3) * 1.5 + 1.0) - length(p.x)) / scale);\n        vec4 rot = qaxis(0.8, normalize(vec3(1, 1, 1)));\n        rot = qmul(rot, qaxis(iTime * 0.003 + float(i), vec3(0, 0, 1)));\n    \tpos = rotVec(pos, rot);\n        pos *= 1.2;\n        scale *= 1.2;\n    }\n    return d;\n}\n\n//====================================\n// Normal\n//====================================\nvec3 calcNormal(vec3 pos)\n{\n    vec2 ep = vec2(0.01, 0);\n    float d0 = dist(pos);\n    return normalize(vec3(\n        d0 - dist(pos - ep.xyy),\n        d0 - dist(pos - ep.yxy),\n        d0 - dist(pos - ep.yyx)\n    ));\n}\n\n//====================================\n// Color\n//====================================\nvec3 calcColor(vec2 uv)\n{\n    vec4 rot = qaxis(sin(iTime) * 0.1, vec3(1, 0, 0));\n    rot = qmul(rot, qaxis(sin(iTime * 0.8) * 0.1, vec3(0, 1, 0)));\n    rot = qmul(rot, qaxis(iTime * 0.5, vec3(0, 0, 1)));\n    vec3 lightDir = rotVec(normalize(vec3(1, 1, -1)), rot);\n    vec3 pos = vec3(0, 0, mod(iTime, 100.0) * 10.0);\n    vec3 dir = rotVec(normalize(vec3(uv, 1)), rot);\n    \n    for (int i = 0; i < 128; ++i)\n    {\n        float d = dist(pos);\n        if (d < 0.001)\n        {\n            vec3 albedo = vec3(1, 1, 0.5);\n            vec3 norm = calcNormal(pos);\n            float atten = max(0.0, dot(norm, lightDir));\n            float fog = float(i) / 128.0;\n            return mix(atten * albedo, vec3(1.0, 1.0, 1.0), fog);\n        }\n        pos += d * dir;\n    }\n    \n    return vec3(1, 1, 1);\n}\n\n//====================================\n// Entry point\n//====================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    fragColor = vec4(calcColor(uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}