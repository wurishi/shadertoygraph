{"ver":"0.1","info":{"id":"Nl23z1","date":"1706780825","viewed":79,"name":"hmap_raymarch","username":"moshe","description":"Raymarched shadows for heightmap","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float angle = 1.;\nconst mat2 m1 = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n\nvec3 transform(vec3 p) {\n    float rot = iTime * 0.2;\n    mat2 m2 = mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n    p.yz *= m1;\n    p.xy *= m2;\n    return p;\n}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat PerlinNoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nconst float slopeUB= 1.;\nconst float g = sin(atan(1.,slopeUB));\nconst vec2 small_off = vec2(1e-5,0);\nfloat sde(vec3 p) {\n    float h = PerlinNoise(p.xy / 5.0);\n    return (p.z-h)*g;\n    \n}\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.001;\n    for(int i=0; i<100; i++) {\n        float d = sde(p);\n        if (d < 0.0001) return p;\n        p += rd*d;\n        if (length(p-ro) > 200.) return p;\n    }\n    return p;\n}\nfloat light(vec3 l, vec3 p) {\n    float d = sde(p);\n    vec3 norm = normalize(vec3(\n        sde(p + small_off.xyy) - d,\n        sde(p + small_off.yxy) - d,\n        sde(p + small_off.yyx) - d\n        ));\n    vec3 ld = normalize(l-p);\n    float s = max(0.,dot(ld, norm));\n    if (s > 0.0 && length(rayMarch(p,ld)-p) < length(l-p)) return 0.1;\n    return s;\n}\nconst vec3 l = vec3(0,0,5);\nconst vec3 ro = vec3(0,0,10);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 c = vec3(15.0*uv,3);\n    vec3 ro_ = ro;\n    c = transform(c);\n    ro_ = transform(ro_);\n    \n    vec3 p = rayMarch(ro_, normalize(c - ro_));\n\n    vec3 col = vec3(light(l, p));\n    \n    float d = length(p-ro_);\n    col -= vec3(smoothstep(0.,200.,d));\n    col = min(vec3(1),col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}