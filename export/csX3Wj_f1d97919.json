{"ver":"0.1","info":{"id":"csX3Wj","date":"1666780106","viewed":100,"name":"Cloudy Night with reflections","username":"jin_x","description":"Rotating rounding curving mirror boxes / drops are added :)\np.s. Learning shaders :-P","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","landscape"],"hasliked":0,"parentid":"dssGRs","parentname":"Cloudy Night / CAFePARTY 2022"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define FASTDRAW  // uncomment this line if playback is not smoothly ;)\n#define DROPS  // show drops (curving spheres)\n#define BOXES  // show rotating rounding curving boxes\n#define ROUGHNESS  // use evenen shapes of boxes/drops\n#define FINE_ROUGH  // use fine roughness instead of large one (only if UNEVEN_SHAPE is defined)\n\n\n#define EPS .0001\n\n#ifdef FASTDRAW\n  #define draw_coef .5\n#else\n  #define draw_coef 1.\n#endif\n\nfloat time, glow = 1., rpy;\nint idx;\n\nmat2 rot(float a)\n{\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sdf(vec3 p)\n{\n    float s[5];\n    s[0] = p.y + texture(iChannel0, p.xz*.05*draw_coef).x * 2.5;  // land\n    s[1] = 10. - p.y + texture(iChannel0, (p.xz+time*5.)*.005).x * 3.;  // sky\n    s[2] = length(p - vec3(6.,rpy+1.,time+12.));  // moon\n    s[3] = p.y + 1.75 - draw_coef*.5;  // water\n    float t = (time+(p.x+p.z)*.5)*.5;\n    vec3 q = vec3(mod(p.x,10.)-5.+sin(t*.7)*2., p.y-2.+sin(t), mod(p.z,20.)-10.);\n    s[4] = 1000.;\n#ifdef DROPS\n    s[4] = length(q) - 1.;  // drop\n#endif\n#ifdef BOXES\n    vec3 f = p/vec3(10., 15., 20.);\n    q.zx *= rot((f.y*3.+time)*.7);\n    q.yz *= rot((f.x*3.+time)*.6);\n    q.xy *= rot((f.z*3.+time)*.5);\n    vec3 b = abs(q) - .5;\n    s[4] = min(s[4], length(max(b, 0.)) + min(max(max(b.x, b.y), b.z), 0.) - .3);  // box\n#endif\n#ifdef ROUGHNESS\n #ifdef FINE_ROUGH\n    s[4] -= texture(iChannel1, vec2(q.x+q.y, q.z-q.y)*10.).x * .001;\n #else\n    s[4] -= texture(iChannel1, vec2(q.x+q.y, q.z-q.y)*.1).x * .1;\n #endif\n#endif\n    idx = 0;\n    for (int i = 1; i < 5; ++i)\n      if (s[i] < s[idx]) idx = i;\n    if (idx == 2) glow += .075/(.1+s[2]*s[2]);\n    return s[idx];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv *= vec2(iResolution.x / iResolution.y, 1);\n\n    time = iTime;\n\n    // Ray marching\n    rpy = sin(time)/2.+.5;\n    vec3 rp = vec3(0, rpy, time), rd = normalize(vec3(uv, 1));\n    float t = time*.075;\n    rd.xz *= rot(cos(t+sin(2.*t))*3.);\n    rd.xy *= rot(sin(time*.2)/4.);\n\n    int i = 0, rc = 0;\n    float sdf_coef = .1/draw_coef;\n    int rc_limit = int(20.*draw_coef), i_limit = int(1000.*draw_coef);\n    while (++rc < rc_limit) {\n        float d, td = 0.;\n        while (++i < i_limit) {\n            d = sdf(rp)*sdf_coef;\n            if (d < EPS) break;\n            td += d;\n            if (td > 100.) { idx = 2; break; }\n            rp += d*rd;\n        }\n        if (idx < 3 || rc == rc_limit-1) break;\n        // Reflection\n        vec2 e = vec2(.01, 0);\n        vec3 n = normalize(d - vec3(sdf(rp-e.xyy), sdf(rp-e.yxy), sdf(rp-e.yyx)) * sdf_coef);\n        rd = reflect(rd, n);\n        rp += n*EPS*40.;  // ???\n        glow *= 1.5;\n    }\n    if (i >= i_limit || rc >= rc_limit) idx = 3;\n\n    // Pixel color\n    float br = clamp(pow(50.*draw_coef/float(i), 1.5), 0., 1.);\n    float l = 5.;\n    if (texture(iChannel1, vec2(time*.7, 0)).x < .1) l = 50.;\n    float sky = texture(iChannel1, (rp.xz+time*5.)*.005).x * l * .8;\n    vec3 c[] = vec3[](vec3(1,.4,0)*sqrt(l)*.5, vec3(.3,.6,1)*sky, vec3(glow*.5), vec3(0));\n    vec3 col = br * glow * c[idx];\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}