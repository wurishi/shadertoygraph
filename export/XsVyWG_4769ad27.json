{"ver":"0.1","info":{"id":"XsVyWG","date":"1523195958","viewed":135,"name":"raymarching bitfonts","username":"crundle","description":"5x6 font as texture and as heightmap, and pixelating the whole thing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","text","pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI \t\t\t\t\t3.14159265359\n\nvec2 V;\n#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n\n#define TEXTSIZE 16.0\n\n//ints, because i had precision problems with floats\n//5x6 - top left corner is LSB\n//generated from http://asset-d.soupcdn.com/asset/14134/8421_d52e.png\nint[99] ichars = int[99]( 0, 422402636, 277094732, 1008824846, 487092750, 277117250, 487077982, 422131804, 138551838, 422130252, 487092812, 489636288, 489245122, 941689728, 959007632, 942098816, 69667404, 1024347008, 623462850, 138547204, 211034120, 623331906, 421595202, 727373280, 623462848, 422136192, 69683648, 554584448, 69290432, 486935424, 943854532, 959007296, 145312320, 358274592, 581052960, 1024346688, 1009140672, 623856204, 1025985102, 941688924, 489245262, 1009191006, 69666910, 959252572, 623856210, 474091662, 422068764, 623331922, 1008797762, 727373499, 623471314, 422136396, 69683790, 959269452, 623331918, 486934620, 138547359, 422136402, 212421202, 358274737, 581052977, 1024346706, 1008869918, 134353028, 134357580, 368409920, 134217728, 142999552, 142999808, 134348800, 35791360, 545392672, 136382592, 142876800, 203491520, 411312512, 491197888, 1040187392, 458752, 422135828, 422129684, 959332372, 4224, 14694400, 4657152, 9078784, 355019340, 330, 572662304, 455431816, 134348800, 138547332, 272699648, 71569472, 324, 10627072, 492519982, 809570456, 210247942  );\n\n//Extracts bit b from the given number.\nfloat extract_bit_int(int n, float b)\n{\n\treturn float( (n / int(exp2(b)) ) %2 );   \n}\n\nfloat drawchar(vec2 o, vec2 p, int ich) {\n    p-=o;    \n    if((p.x<0.||p.x>=5.) || (p.y<0.||p.y>=6.)) return 0.;\n    float cpx = trunc(mod(p.x,5.)); //pixel in cell, x\n    float cpy = 5.-trunc(mod(p.y, 6.)); // pixel in cell, y\n    \n    float cpno = mod(cpy*5.+cpx,32.); //pixel/bit in char\n    ich=ich%99;\n    return (extract_bit_int(ichars[ich],(cpno))); //is bit set?\n}\n\nfloat osc(float t, float mi, float ma) {\n    return mi+(ma-mi)*(sin(t)*0.5+.5);\n}\n\nfloat sphere(vec3 p) {\n    return length(p)-1.;\n}\nfloat scene(vec3 p, out vec3 colo) {\n    float s = sphere(p)-4.;\n    p.y += sin(p.z*0.2);\n    p.y += cos(p.x*0.2);\n    float ylimit = p.y+4.;\n    float fl = 0.;\n    float td = -15.0;\n        for(int i = 0; i<6; i++) {\n            int ch = int(mod(float(i)+trunc(iTime*4.),99.));\n            fl-= ( drawchar(vec2(td,-4.),p.zx*0.8*vec2(-1.,1.),ch) )*0.5;  \n            td+=5.;\n        }\n    colo = mix(vec3(1,1,0),vec3(1,1,1),step(0.,fl));\n    colo = mix(colo,vec3(1,0,0),step(0.1,ylimit-1.));\n    return min(fl+ylimit,s);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.4; // superlarge!\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n    vec3 scol;\n\treturn normalize( v1*scene( pos + v1*eps,scol) + \n\t\t\t\t\t  v2*scene( pos + v2*eps,scol) + \n\t\t\t\t\t  v3*scene( pos + v3*eps,scol) + \n\t\t\t\t\t  v4*scene( pos + v4*eps,scol) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 uv2 = uv*2.-1.;\n\tuv2.y = uv2.y*(iResolution.y/iResolution.x);\n    \n    \n    float pixelizer = osc(iTime*.2,32.,iResolution.x);\n    uv2.x = trunc(uv2.x*pixelizer)/pixelizer;\n    uv2.y = trunc(uv2.y*pixelizer)/pixelizer;\n   \t\n    vec3 col = vec3(uv2.y);\n    \n    \n    vec3 o = vec3(-15.,0.,0.);\n    vec3 dir = normalize(vec3(uv2*1.1,1.));\n    dir.xz *= rot(PI*.5);\n    \n    vec2 rotv = vec2(0);\n    if (iMouse.z > 0.0) {\n        rotv = vec2((iMouse.xy - iResolution.xy*0.5)*0.01);\n    } else {\n        rotv = vec2((-iTime*0.1), sin(iTime*0.3)*0.45-.5);\n    }\n    \n    mat2 rot1 = rot(rotv.x);\n    mat2 rot2 = rot(-rotv.y);\n    dir.xy *= rot2;\n    o.xy *= rot2;\n    dir.xz *= rot1;\n    o.xz *= rot1;\n    \n    \n    //trace\n    float totaldistance = .0;\n    float maxdistance = 100.;\n    float steps = 0.;\n    bool set = false;\n    vec3 p; vec3 scol;\n    for(int i = 0; i< 100; i++) {\n        steps += 1.;\n        p = o+dir*totaldistance;\n        float dist = scene(p,scol);\n        totaldistance += max(.05,min(dist,.7));\n        if(dist < .05) {\n         \tset = true;\n           \tbreak;\n        }\n    }\n    if(set) \n    {\t\n        vec3 lightdir = (vec3(1.,1.,1));\n        vec3 lightcol = vec3(0.7,1.,1.);\n        lightdir.xz*=rot(iTime);\n        float r = length(p.zx);\n        float angle = atan((p.x),(p.z))*PI-PI*PI;\n        \n        vec2 proj = (vec2(-1.*angle,1.*p.y)+vec2(0.,0.5))*2.;\n        vec3 norm = calcNormal(p);\n        col=(mix(scol,col,(steps*.01)));\n        float td = 0.0;\n        float t= 0.;\n        for(int i = 0; i<36; i++) {\n            int ch = int(mod(float(i)+trunc(iTime*4.),99.));\n            t+= drawchar(vec2(td,0.),proj,ch);\n            td+=5.;\n        }\n        col=mix(col,vec3(0,0,1),t);\n        float li  =dot(norm,lightdir);\n        col=li*lightcol*col+col*(1.-li)*0.5;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}