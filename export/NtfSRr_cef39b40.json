{"ver":"0.1","info":{"id":"NtfSRr","date":"1625047489","viewed":122,"name":"Non-Euclidean Shock Wave","username":"spr","description":"Rational points on a horocyle following a geodesic on the modular surface equidistributing for a while before escaping to infinity.\nThe grey region is a hyperbolic triangle with sides glued as described in https://en.wikipedia.org/wiki/Modular_group.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["dynamicalsystem","hyperbolicgeometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  \n\thttp://math.ucsd.edu/%7Eaterras/bigbang.htm\n\tFrom Audrey Terras' Harmonic Analysis on Symmetric Spaces and Applications, 2nd edition, p. 316.\n\tExercise 3.6.19 (Harold Stark): Computer-Generated Movie of a Non-Euclidean Shock Wave. \n\tStark created this movie on his Atari ST which is still operating.\n*/\n\nconst int N = 51;\nconst float y_start = 5.;\nconst float y_end = 10.;\n\nconst float N_inv = 1. / float(N);\nconst float line_thickness = 1.e-02;\nconst float point_size = 2.5e-02;\nconst float eps = 1.e-02;\nconst float width_screen = 7.;\n\nconst vec3 atari_green = vec3(105, 226, 68)/255.;\nconst vec3 atari_grey = vec3(222./255.);\nconst vec3 atari_red = vec3(209,45,31 )/255.;\n\n\nfloat time_reset = 2. * log2(float(N)) + log2(y_start) + log2(y_end);\n\n\n\n\nvoid circle_inversion(inout vec2 z) // z -> -1/z  ( = - conj(z) / |z|^2 )\n{\n\t//float length_squared = z.x * z.x + z.y * z.y;\n\tz.x = -z.x;\n\tz /= dot(z,z);\n}\n\nvoid horizontal_translation(inout vec2 z) // z -> z+-1\n{\n\tz.x = mod(z.x+0.5, 1.)-0.5;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = exp2(mod( iTime, time_reset)); // time flows exponentially in hyperbolic space\n    float time_inv = 1. / time;\n\n    vec2 st = width_screen * fragCoord.xy/iResolution.x - vec2(0.5*width_screen,0.);\n    \n    vec3 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = atari_green;\n    if(abs(abs(st.x)-0.5)< line_thickness && length(st.xy) >= 1.) \t\tcolor = vec3(0); \t// Left and Right border of fundamental domain\n    else if(abs(length(st.xy)-1.) < line_thickness) \t\t\t\t\tcolor = vec3(0); \t// lower circle of fundamental domain\n\telse if(abs(st.x) <= 0.5 && length(st.xy) >= 1.) \t\t\t\t\tcolor = atari_grey;\n\n\t\n\tvec2 horocycle;\n\n\tfor(int j = 0; j<N; ++j){\n\t\thorocycle = vec2(float(j)*N_inv-0.5, y_start); // Initialize\n\t\tvec3 point_color = vec3(sin(float(j)*N_inv*2.),float(j)*N_inv,1.-float(j)*N_inv);\n\t\n\t\thorocycle.y *= time_inv; // Flow down\n\n\t\t\n\t\t//if(length(st.xy-horocycle[j]) < point_size*0.5) color = atari_red; // Location without applying gamma\n\n\t\t\n\t\tif(dot(st.xy,st.xy) >= 1. && abs(st.x) >0.5){\n\t\t\tif(length(st.xy-horocycle) < 0.9* point_size) color = point_color;\n\t\t}\n\n\n\t\tif(dot(st.xy,st.xy) >= 1. && abs(st.x) <=0.5){\n            int limit = 100;\n\t\t\twhile(dot(horocycle,horocycle) < 1. || abs(horocycle.x) >0.5) // Applying gamma, i.e. put into fundamental domain\n\t\t\t{\n                if(--limit < 0 ) break;\n\t\t\t\tif(dot(horocycle,horocycle) < 1.) \tcircle_inversion(horocycle);\n\t\t\t\tif(abs(horocycle.x) >0.5)\t\t  horizontal_translation(horocycle);\n\t\t\t}\n\t\t\tif(length(st.xy-horocycle) < point_size) color = point_color; \n\t\t}\n\t\t\n\t}\n\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}