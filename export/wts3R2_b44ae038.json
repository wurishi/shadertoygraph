{"ver":"0.1","info":{"id":"wts3R2","date":"1556987128","viewed":115,"name":"ooze","username":"sayachang_bot","description":"ooze","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ooze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define smin(a,b,k) -log2(exp2(-k*a)+exp2(-k*b))/k;\nconst float PI = 3.1415926;\nconst float PHI = 1.618033988749894848;\nconst float EPS = .001;\nconst float TWEAK_STRONG = .02;\nconst float TWEAK_WEAK = .005;\nconst int IT = 32;\nstruct rays {\n    vec3 p;\n    vec3 ro;\n};\n\nvec2 rot(vec2 p, float a){\n    return vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)*p.y*cos(a));\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0) + 1.0)*x); }\nfloat snoise(vec2 v) {\n\tconst vec4 C = vec4(0.211324865405187,\n\t\t0.366025403784439,\n\t\t-0.577350269189626,\n\t\t0.024390243902439);\n\n\tvec2 i = floor(v + dot(v, C.yy));\n\tvec2 x0 = v - i + dot(i, C.xx);\n\n\t// Other two corners (x1, x2)\n\tvec2 i1 = vec2(0.0,0.0);\n\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec2 x1 = x0.xy + C.xx - i1;\n\tvec2 x2 = x0.xy + C.zz;\n\n\ti = mod289(i);\n\tvec3 p = permute(\n\t\tpermute(i.y + vec3(0.0, i1.y, 1.0))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0));\n\n\tvec3 m = max(0.5 - vec3(\n\t\tdot(x0, x0),\n\t\tdot(x1, x1),\n\t\tdot(x2, x2)\n\t\t), 0.0);\n\n\tm = m * m;\n\tm = m * m;\n\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\n\tm *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h * h);\n\n\tvec3 g = vec3(.0);\n\tg.x = a0.x  * x0.x + h.x  * x0.y;\n\tg.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);\n\treturn 130.0 * dot(m, g);\n}\n\nfloat dBox(vec3 p, vec3 q){\n    vec3 d = abs(p) - q;\n    return length(max(d,0.));\n}\n\nvec3 terrain(vec3 p){\n    vec3 q = p;\n    float tr = snoise(p.yz);\n    q.x+=EPS*EPS*PHI*tr;\n    q.y-=tr;\n    return q;\n\n}\n\nfloat map(rays ray, inout vec3 col){\n    float time = iTime;\n    vec3 p = ray.p;\n    vec3 q = p;\n    q.y-=.75;\n    float s1 = length(q.xy-.3*abs(sin(time)))-.2;\n    q.x+=1.;\n    float s2 = length(q.xy)-.3;\n    \n    float d = min(s1, s2);\n    s1<s2?col.g+=TWEAK_STRONG:col.b+=TWEAK_WEAK;\n    \n    q=p;\n    q.x+=1.5+.5*sin(time);q.y-=.5*abs(sin(time));q.z-=6.;\n    float sp1 = distance(ray.ro,q)-.2;\n    sp1<d?col.r+=TWEAK_STRONG:col.b+=TWEAK_WEAK;\n    sp1<d?col.g+=TWEAK_STRONG:col.b+=TWEAK_WEAK;\n    d = smin(d, sp1, PI);\n    \n    q=p;\n    q.x=.5+cos(time);q.y-=2.*abs(cos(time));q.z-=6.+.2*PHI*sin(time);\n    float sp2 = distance(ray.ro,q)-.4;\n    sp2<d?col.g+=TWEAK_STRONG:col.r+=TWEAK_WEAK;\n    d = smin(d, sp2, PI);\n\n    float flr = p.y + 1.6;\n    flr<d?col.r+=TWEAK_STRONG:col.r+=TWEAK_WEAK;\n    d = smin(d, flr, PI);\n\n    q=p;\n    q.y+=0.8;\n    float cel = -length(q.xy)+3.;\n    d = smin(d, cel, PI);\n\n    q=p;\n    q=terrain(q);\n    float tunnel = PI - 1.6*length(q.xy) +.6*sin(time);\n    tunnel<d?col.b+=TWEAK_STRONG:col.g+=TWEAK_WEAK;\n    d = smin(d, tunnel,PI);\n\n    return d;\n}\nvec3 normal(rays ray){\n    vec3 dummy;\n    rays q = ray;\n    vec2 xy = vec2(.1,.0);\n    rays subrayx = q;subrayx.p-=xy.xyy;\n    rays subrayy = q;subrayy.p-=xy.yxy;\n    rays subrayz = q;subrayz.p-=xy.yyx;\n    rays q1 = q;q1.p+=xy.xyy;\n    rays q2 = q;q2.p+=xy.yxy;\n    rays q3 = q;q3.p+=xy.yyx;\n\n    return normalize(vec3(\n        map(q,dummy)-map(subrayx,dummy),\n        map(q,dummy)-map(subrayy,dummy),\n        map(q,dummy)-map(subrayz,dummy)\n    ));\n}\n\nvec3 pow3(vec3 v, float p){\n    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));\n}\n\nvoid tweakCol(inout vec3 col){\n    for(int j=0;j<3;++j){\n        col+=.1;\n        col*=1.1;\n    }\n    col=pow3(col,4.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n    float t = iTime;\n    float FOV = .4;\n    FOV-=.1*smoothstep(mod(t,24.),12.,mod(t,24.)/12.);\n    vec3 q = vec3(FOV*p, 1.);\n    vec3 rd = normalize(q),N;\n    vec3 col = vec3(.6,.9,1.4);\n\n    vec3 ro = vec3(0.01,0.01,4.*PHI*t-PI);\n    ro.x+=1.2;ro.y*=PHI;ro.y-=1.;\n    rays ray;\n    ray.ro = ro;\n    ray.p = ro;\n    ray.p.xy=-abs(rot(ray.p.xy,t));\n    ray.p.xy+=.5;\n\n    int j=0;\n    float d = EPS,dd=EPS;\n    for(int i=0;i<IT;++i){\n        j=i;\n        d = map(ray,col);\n        if(d<EPS){\n            N = normal(ray);\n            break;\n        }\n        ray.p+=d*rd;\n        dd+=d;\n    }\n\n    float l=.5+.5*dot(N,vec3(-1.,-1.,-1.));\n    col+=l;\n    float spec = pow(max(dot(rd, N), 0.),4.);\n    \n    vec3 col2;\n    rays ray2;\n    ray2.ro = ray.p;\n    ray2.p = ray.p;\n    \n    vec3 rd2 = reflect(rd, N);\n    int k=0;\n    float dd2=EPS;\n    for(int i=0;i<IT;++i){\n        k=i;\n        d = map(ray2,col2);\n        if(d<EPS){\n            N = normal(ray);\n            break;\n        }\n        ray2.p+=d*rd2;\n        dd2+=d;\n    }\n\n \tcol+=spec;\n    col+=col2;\n    col*=.3;\n    col+=1.2/distance(ro,ray.p);\n    \n    tweakCol(col);\n    col=.5+.05*col;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}