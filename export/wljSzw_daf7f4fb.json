{"ver":"0.1","info":{"id":"wljSzw","date":"1565464468","viewed":258,"name":"Tunnel-o-love","username":"mewo2","description":"Clouds!","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat rand(float x) {\n        return fract(sin(x) * 43138.5453123);\n                 }\nfloat rand3(vec3 v) {\n\treturn rand(v.x + rand(v.y + rand(v.z)));\n}\nvec3 randgrad(vec3 v) {\n    float g1 = rand3(v);\n    float g2 = rand(g1);\n    float g3 = rand(g2);\n    return normalize(vec3(g1, g2, g3) * 2. - 1.);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat noise(vec3 p) {\n    return texture(iChannel0, p.xyz/32.).r - .5;\n    vec3 q = floor(p);\n    vec3 f = smoothstep(vec3(0.0), vec3(1.0), p - q);\n    float n = 0.;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                vec3 idx = vec3(float(i), float(j), float(k));\n                vec3 d = q + idx;\n                vec3 w = f * idx + (1. - f) * (1. - idx);\n                n += dot(p - d, randgrad(d)) * w.x * w.y * w.z;\n            }\n        }\n    }\n    return n;  \n}\n\nfloat ballangle() {\n    return sin(iTime / 3.9 + 2.*sin(iTime / 4.7) + sin(iTime/7.3));\n}\nfloat density(vec3 p) {\n    float d = 0.0;\n    vec3 q = p;\n    q.z -= iTime * 3.;\n    p.x += .5*sin(q.z/20.);\n    p.y += .7*sin(q.z/17.);\n    float s = 1.;\n    vec3 w = vec3(0., -2., -6.);\n    w.xy = rot(-ballangle()) * w.xy;\n    float wake = clamp((dot(normalize(p - w), vec3(0.,0.,1.)) - .93)/.07 * 1.3, 0., 1.);\n    //q *= 1.-wake;\n    //p *= 1. - wake * .5\n    for (int i = 0; i <4; i++) {\n        d += max(noise(q), 0.0)/s;\n        q *= 2.5;\n        s *= 2. - .8*wake;\n\t\t//q += iTime/13.;\n       // q *= pow(q, vec3(.1, .2, .3));\n        //q.yz = rot(iTime/4339.3) * q.yz;\n        q.xy = mix(rot(iTime/6.7) * q.xy, q.xy, wake);\n        //q.zx = rot(iTime/2224.7) * q.zx;\n    }\n    return clamp(2.*d*(1. - .7*wake) + length(p.xy) - 2.  -.1 *wake, 0.0, 1.0);\n}\n\nvec3 sky(vec3 dir) {\n    return vec3(2., 1.8,1.5);\n}\nvec3 suncolor() {\n    return vec3(1., .8, .5);\n}\nvec3 sundir() {\n    //return normalize(vec3(.5, 1., -1.));\n    return normalize(vec3(1. + cos(iTime/4.29), .5 + .3 * sin(iTime/5.8), -1.));\n}\n\nfloat sdf(vec3 p) {\n    p.xy = rot(ballangle()) * p.xy;\n    p -= vec3(0, -1.8, -3.);\n    p.yz = rot(iTime * 3.) * p.yz;\n    return length(p) - 1. + .05*noise(p*10.) + .03 * noise(p*20.);\n}\n\nvec3 normal(vec3 p) {\n\tvec3 a1 = vec3(1.,1.,1.);\n    vec3 a2 = vec3(1.,-1.,-1.);\n    vec3 a3 = vec3(-1.,1.,-1.);\n    vec3 a4 = vec3(-1.,-1.,1.);\n    float h = 0.01;\n    return normalize(a1 * sdf(p + h*a1) + a2 * sdf(p + h*a2) + a3 * sdf(p + h*a3) + a4 * sdf(p + h*a4));\n}\n\nvec4 march(vec3 start, vec3 dir) {\n    float t = 0.0;\n    vec3 sc = sky(dir);\n    for (int i = 0; i < 20; i++) {\n        vec3 p = start + t * dir;\n        float d = sdf(p);\n        if (d/t < 0.01) {\n            vec3 n = normal(p);\n            //float ao = sdf(p + .01*n)/.01;\n            sc = clamp(dot(n, sundir()), 0., 1.) * suncolor() + \n                 clamp(dot(n, vec3(.2, -.1, .2)), 0., 1.) * vec3(.4) +\n                (3. -(.5)*clamp(dot(p.xy, n.xy), 0., 1.)) * (1. - suncolor()) * .1;\n            break;\n        }\n     \tt += d;\n    }\n    return vec4(sc, t);\n}\n\nvec4 volmarch(vec3 start, vec3 dir, float tmax) {\n    float t = 0.0;\n    vec4 c = vec4(0.);\n    for (int i = 0; i < 499; i++) {\n        vec3 p = start + t * dir;\n        float d = density(p);\n        if (d > 0.1) {\n            vec4 col = mix(vec4(1., .9, .8, 0.), vec4((1.1 - suncolor()) * .2, 1.), d);\n            col *= 1.;\n            float ds = d - density(p + sundir()*.2) -exp(-sdf(p+sundir())/.5);\n            col.rgb *= mix((1.1 - suncolor()) * .2,suncolor(),  clamp(ds*2., 0., 1.)) + .5;\n            col.rgb *= col.a;\n        \tc += (1. - c.a) * col;\n        }\n        if (c.a > .99 || t > tmax) break;\n        t += max(0.05, t*.01);\n    }\n    c *= clamp(2. * exp(-t/20.), 0., 1.);\n    return c;\n    \n}\n\nvec3 render(vec3 start, vec3 dir) {\n    vec4 m = march(start, dir);\n    vec4 v = volmarch(start, dir, m.a);\n\treturn (1. - v.a) * m.rgb + v.rgb;\n}\nvec3 eyepos() {\n    return vec3(.8 * sin(iTime/1.6), .7 * cos(iTime), 3.);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    vec3 eye = eyepos();\n    vec3 look = vec3(0.);\n    vec3 fwd = normalize(look - eye);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = normalize(cross(fwd, up));\n    up = normalize(cross(right, fwd));\n    vec3 r = normalize(uv.x * right + uv.y * up + fwd);\n    float vignette = 1. - length(uv)/3.;\n    vec3 c = render(eye, r) * vignette;\n    float w = (c.r + c.g + c.b) / 3. + .2 * rand3(vec3(uv, iTime));\n    fragColor = vec4(c.rgb * w / (.3 + w), 1.0);// * vignette;\n    //fragColor = vec4(vec3(.5 + noise(vec3(uv * 5., 0.0))), 1.0);\n}","name":"Image","description":"","type":"image"}]}