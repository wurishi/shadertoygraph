{"ver":"0.1","info":{"id":"dtVyRD","date":"1700499993","viewed":79,"name":"nonuniform blending hexagons","username":"IlyaBelyy","description":"Based on https://www.shadertoy.com/view/cdjyRc but instead of blending uniformly from centre, the hexagons have a variable area of solid colour inside\n\nClick mouse to highlight the solid cores","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 id2colour(ivec2 id)\n{\n    return hash(uvec3(id.xy + 123, id.x + id.y + 200));\n}\n\nvec2 hex2pix(vec2 h)\n{\n    return vec2(\n        sqrt(3.) * h.x + sqrt(3.) * 0.5 * h.y,\n        1.5 * h.y\n    );\n}\n\n// https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#kenneth-shaw\nivec2 pix2id(vec2 p)\n{\n    float x = p.x / sqrt(3.);\n    float y = p.y + 1.;\n    float t2 = floor(x + y);\n    int r = int(floor((floor(y - x) + t2) / 3.));\n    int q = int(floor((floor(2. * x + 1.) + t2) / 3.)) - r;\n    return ivec2(q, r);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon(vec2 p, float r)\n{\n    p = abs(p.yx);      // flat-top to point-top\n    r *= sqrt(3.) / 2.; // inner radius to outer radius\n\n    const vec3 k = vec3(-sqrt(3.0)/2.0,0.5,sqrt(3.0)/3.0);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// perhaps, the barycentric coords could instead be somehow done by overlaying\n// the triangle grid from https://www.shadertoy.com/view/4dKXR3 ?\n\n// https://www.shadertoy.com/view/wdjfz1\nvec3 barycentric(vec2 v1, vec2 v2, vec2 v3, vec2 pos)\n{\n    vec2 posv1 = pos - vec2(v1);\n    \n    vec2 v21 = v2 - v1;\n    vec2 v31 = v3 - v1;\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;   \n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    return vec3 ( baryi, baryj, 1. - baryi - baryj );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - vec2(iResolution)*0.5) / iResolution.y;\n    uv *= 5. * sqrt(3.);\n    float t = iTime * 0.125;\n\n    // find the hex the point belongs to\n    ivec2 id = pix2id(uv);\n    vec2 centre = hex2pix(vec2(id));\n\n    // now we need to find the nearest two neighbours to perform interpolation\n    ivec2 hexd = ivec2(step(centre, uv));\n    \n    // one of these is always on an adjacent row\n    // X coorinate depends on Y because the coordinate system is not orthogonal\n    // and while top right neighbour is +1,+1 bottom right is 0,-1\n    ivec2 id2 = id + ivec2(hexd.x - hexd.y, hexd.y * 2 - 1);\n    vec2 centre2 = hex2pix(vec2(id2));\n    \n    // to find the other neighbour we need to check the nearest one between 2 candidates\n    // the first of these is on the same row as id2 but on the other side horizontally \n    ivec2 id3v = id + ivec2(1 - hexd.x - hexd.y, hexd.y * 2 - 1);\n    vec2 centre3v = hex2pix(vec2(id3v));\n    // the second is the one to the left/right on the same row\n    ivec2 id3h = id + ivec2(hexd.x * 2 - 1, 0);\n    vec2 centre3h = hex2pix(vec2(id3h));\n    ivec2 id3;\n    vec2 centre3;\n    if (dot(uv - centre3v, uv - centre3v) < dot(uv - centre3h, uv - centre3h)) {\n        id3 = id3v;\n        centre3 = centre3v;\n    } else {\n        id3 = id3h;\n        centre3 = centre3h;\n    }\n    \n    // I can't devise the formula to derive k from the solid area size :-(\n    // There are a few datapoints from experiments:\n    // size -> k\n    // 0 -> 0\n    // 0.5 -> 0.75 approximate\n    // 0.75 -> 2.5 approximate\n    // 0.9 -> 7.5 approximate, very inexact\n    // 1 -> inf\n\n    // k is just an animation, but because its effect on visible size\n    // is nonlinear, it has to be a bit overcomplicated\n    t = 0.16 * iTime + float(id.x + id.y) * 0.1;\n    float k = 2.0 * fract(t) - 1.0;\n    k = 0.5 * 3.1415 * k * k;\n    k = sin(k);\n    k = 20.0 * k * k;\n\n    // distance to the edge (max value = hex width = sqrt(3))\n    float d = -sdHexagon(uv - centre, 1.0);\n\n    vec3 bc = barycentric(centre3, centre, centre2, uv);\n    vec3 weight;\n    weight.x = bc.x + d * k;\n    weight.x = min(weight.x, 1.0);\n    // the other two weights are set to 1-w.x but we keep their mutual proportion\n    weight.yz = (1.0 - weight.x) * bc.yz / (bc.y + bc.z);\n\n    fragColor.rgb = id2colour(id ) * weight.x +\n                    id2colour(id2) * weight.y +\n                    id2colour(id3) * weight.z;\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n\n    if (iMouse.z > 0.001) {\n        if (weight.x >= 1.0)fragColor.rgb = vec3(0);\n    }\n\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}