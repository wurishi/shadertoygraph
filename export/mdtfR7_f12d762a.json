{"ver":"0.1","info":{"id":"mdtfR7","date":"1697444154","viewed":45,"name":"Raytracing test - Jupux","username":"Jupux","description":"First test of implementing Raytracing","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int OBJECTS_COUNT = 7;\nconst int LIGHTS_COUNT = 4;\nconst float epsilon = 0.0001;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    vec3 vertical = vec3(0.0,0.0,1.0);\n    C.View = (LookAt - Obs) / length(LookAt - Obs);\n    C.Horiz = normalize(cross(vertical, C.View));\n    C.Up = normalize(cross(C.View,C.Horiz));\n    C.Obs = Obs;\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H / (2.0*tan(aperture/2.0));\n    return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = -normalize(C.View * C.z + (XY.x - 0.5 * C.W) * C.Horiz + (XY.y - 0.5 * C.H) * C.Up);\n   return r;\n}\n\nstruct Object {\n   int type; // 0 for Sphere, 1 for Plan, 2 for Cylinder\n   vec3 Center; // Center for sphere, origin for cylinder / plan\n   float R; // Radius for sphere and cylinder\n   vec3 Color;\n   bool is_light;\n   bool is_finite;\n   \n   vec3 d1; // First vector of plan & Up vector for cylinder\n   vec3 d2; // Second vector of plan\n   vec3 normal; // Normal for the plan\n   float height; // height of plan / cylinder\n   float width; // Width for plan\n   \n   \n};\n\nstruct Light {\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n\n   \nLight lights[LIGHTS_COUNT];\nObject objects[OBJECTS_COUNT];\n\nvec3 compute_normal(in Camera C, in Object P) {\n    vec3 n = cross(P.d1,P.d2);\n    if(dot(n,C.Obs - P.Center) > 0.0) {\n        n = -n;\n    }\n    return n;\n}\n\nbool intersect_cylinder(in Ray R, in Object C, out float t) {\n\n    vec3 x = (R.Dir - dot(C.d1,R.Dir)*C.d1);\n    vec3 y = (R.Origin - C.Center - dot(C.d1,(R.Origin - C.Center))*C.d1);\n    float a = length(x) * length(x);\n    float b = 2.0*dot(x,y);\n    float c = length(y)*length(y) - C.R*C.R;\n    \n    float delta = b*b - 4.0*a*c;\n        \n    if (delta > 0.0) {\n        float t1 = (-b + sqrt(delta))/(2.0*a);\n        float t2 = (-b - sqrt(delta))/(2.0*a); \n        \n        float l1 = dot(C.d1,-(R.Origin + t1*R.Dir - C.Center));\n        float l2 = dot(C.d1,-(R.Origin + t2*R.Dir - C.Center));\n        \n        bool b1 = ( l1 > C.height || l1 < 0.0);\n        bool b2 = ( l2 > C.height || l2 < 0.0);\n        \n        if ( b1 && b2 ) {\n            t = -1.0;\n            return false;\n        } else if (b1) {\n             t = t2;\n             \n        } else if (b2) {\n            t = t1;\n        } else {\n            if (t1 < 0.0) {\n                t = t2;\n            }\n            if (t2 < 0.0) {\n                t = t1;\n            }\n            if (t1 > 0.0 && t2 > 0.0) {\n                t = min(t1,t2);\n            }\n        }\n\n    } else if (delta == 0.0) {\n        t = -b/(2.0*a);\n        float l = dot(C.d1,-(R.Origin + t*R.Dir - C.Center));\n        \n        if ( l > C.height && l < 0.0) {\n            t = -1.0;\n            return false;\n        }\n    }\n    \n    else {\n        t = -1.0;\n        return false;\n    }\n    \n    return true;\n}\n\n\n\nbool intersect_plan(in Ray R, in Object P, out float t) {\n\n    if (abs(dot(cross(P.d2,P.d1),R.Dir)) <= 0.00001) {\n        t = -1.0;\n        return false;\n    }\n\n    mat3 X = inverse(mat3(R.Dir,\n                    -P.d1,\n                     -P.d2));\n    vec3 v0 = P.Center - R.Origin;\n    vec3 C = X*v0;\n    t = C.x;\n    float u = C.y;\n    float v = C.z;\n    \n    if (P.is_finite && (P.width < abs(u) || P.height < abs(v))) {\n         t= -1.0;\n         return false;\n    }\n    \n    if ( t < 0.0) {\n        return true;\n    }\n    return true;\n}\n\n\nbool intersect_sphere(in Ray R, in Object S, out float t, out vec4 fragColor, out bool is_light) {\n    \n    float delta = 4.0*(pow(dot(R.Dir,R.Origin - S.Center),2.0) - pow(length(R.Dir),2.0)*(pow(length(R.Origin - S.Center),2.0) - pow(S.R,2.0)))                        ;\n    is_light = false;\n    if (delta > 0.0) {\n        float t1 = (-2.0*(dot(R.Dir,R.Origin - S.Center)) - sqrt(delta))/(2.0*pow(length(R.Dir),2.0));\n        float t2 =(-2.0*(dot(R.Dir,R.Origin - S.Center)) + sqrt(delta))/(2.0*pow(length(R.Dir),2.0));\n        t = t1;\n        \n        if (t1 < 0.0) {\n            t = t2;\n            if (t2 < 0.0) {return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = -(dot(R.Dir,R.Origin - S.Center))/(pow(length(R.Dir),2.0));\n        if (t < 0.0) {return false;}\n    } else {\n        t = -1.0;\n        return false;\n    }\n    is_light = S.is_light;\n    return true;\n}\n\nbool check_for_shadows(in Ray R, in Light L, in float t, in int i, in bool itself,out vec3 fragColor) {\n\n    float itself_dist = 0.01;\n    Ray Rl;\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    float t2 = -1.0;\n    bool intersect = false; \n    for(int j = 0; j < OBJECTS_COUNT; j++) {\n        Object O = objects[j];\n        if ((itself || j != i) && intersect == false  && (length(O.Center - L.Pos) > 0.1) || O.type != 0) {\n            bool a = false;\n            vec4 f = vec4(0,0,0,1);\n            t2 = -1.0;\n            if (O.type == 0) {\n                intersect_sphere(Rl, O, t2,f,a);\n            } else if (O.type == 1) {\n                intersect_plan(Rl,O,t2);\n            } else if (O.type == 2) {\n                 intersect_cylinder(Rl,O,t2);\n            }\n            if (j!=i && (t2 > epsilon && t2 < 1.00 - epsilon)) {\n                intersect = true;\n            } else if (j == i && (t2 > itself_dist && t2 < 1.00 - epsilon)) {\n                intersect = true;\n            }\n        }\n    }\n    return intersect;\n\n}\n\n\nvec3 apply_light(in Ray R, in Object S, in Light L, in float t, in int i, in bool itself) {\n    float costheta;\n    \n    if (S.type == 0) {\n        costheta = dot(normalize(S.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n        costheta = max(0.0,costheta);\n        float dist = length((R.Origin + t*R.Dir) - L.Pos);\n        // Definir un referentiel (lumière max)\n        if (dist >0.0){\n            costheta *= L.Intensity/(dist*dist);\n        } else {\n            costheta = 1.0;\n        }\n        costheta = min(1.0,costheta);\n    } else if (S.type == 1) {\n        vec3 n = S.normal;\n        costheta = dot(normalize(n),normalize((R.Origin + t*R.Dir) - L.Pos));\n        costheta = max(0.0,costheta);\n        float dist = length((R.Origin + t*R.Dir) - L.Pos);\n        if (dist >0.0){\n            costheta *= L.Intensity/(dist*dist);\n        } else {\n            costheta = 1.0;\n        }\n        costheta = min(1.0,costheta);\n    } else if (S.type == 2) {\n        \n        // Lumière dans le cylindre -> ombre avec lui même\n    \n    }\n    vec3 fragColor = vec3(0,0,0);\n    bool intersect = check_for_shadows(R, L, t, i,itself,fragColor);\n    if(fragColor != vec3(0,0,0)){\n        return fragColor;\n    }\n    if (intersect && S.is_light == false) {\n        return vec3(0,0,0);\n    }\n    return vec3(costheta*L.Color*S.Color);\n    }\n\n\nfloat rand(float co) { return fract(sin(co*iTime*(91.3458)) * 47453.5453); }\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n   float pi = 3.1415;\n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(2.0, 1.0, 1.5),\n       50.0*180.0/pi   \n   );\n   \n   \n   vec3 col = 0.5 + 0.5*cos(iTime+vec3(0,2,4));\n   col = vec3(1.0,1.0,1.0);\n   \n\n\n   \n   \n   \n   Object S;\n   S.type = 0;\n   S.Center = C.Obs + C.View * 15.0 + vec3(0.25,0.15,0.515);\n   S.R = 0.9;\n   S.Color = col;\n   S.is_light = false;\n   objects[0] = S;\n   \n    Object S2;\n    S2.type = 0;\n    float a = iTime; \n    vec3 offset = vec3(0.0, 2.2, 0.0);\n\n    mat3 rotZ = rotateZ(a);\n\n    vec3 rotatedOffset = rotZ*offset;\n\n    S2.Center = objects[0].Center + rotatedOffset + vec3(0.0,0.0,0.10);\n    S2.R = 0.4;\n    S2.Color = 0.5 + 0.5*cos(2.0*iTime+vec3(0,1,2));\n    S2.Color= vec3(1,0,1);\n    S2.is_light = true;\n    objects[1] = S2;\n    \n    \n    Object S3;\n    S3.type = 0;\n    rotZ = rotateZ(4.0*a);\n    offset = vec3(0.0, 1.0, 0.0);\n    rotatedOffset = rotZ*offset;\n    \n    S3.Center = objects[1].Center + rotatedOffset;\n    S3.R = 0.12;\n    S3.Color = 0.5 + 0.5*cos(2.0*iTime+vec3(0,1,2));\n    S3.is_light = false;\n    objects[2] = S3;\n   \n\n   Object S4;\n   S4.type = 0;\n    rotZ = rotateX(0.1*a);\n    offset = vec3(0.0, 0.0, 1000.0);\n    rotatedOffset = rotZ*offset;\n    \n    S4.Center = objects[0].Center + rotatedOffset;\n    S4.R = 50.12;\n    S4.Color = vec3(1.0,0.8,0.2);\n    S4.is_light = true;\n    objects[3] = S4;\n   \n   Object S5;\n   S5.type = 1;\n   S5.is_light = false;\n   S5.Center = vec3(0.0,0.0,4.5);\n   S5.d1 = vec3(0.0,1.0,0.0);\n   S5.d2 = vec3(1.0,0.0,0.0);\n   S5.Color = vec3(1.0,1.0,1.0);\n   S5.normal = compute_normal(C,S5);\n   S5.is_finite = false;\n   objects[4] = S5;\n   \n   Object S6;\n   S6.type = 1;\n    \n   S6.is_light = false;\n   \n    \n    rotZ = rotateZ(0.2*a);\n    offset = vec3(0.0, 3.0, 0.0);\n    rotatedOffset = rotZ*offset;\n    \n   \n   S6.Center = objects[0].Center + rotatedOffset + vec3(0.0,0.0,0.10);\n   mat3 rotX = rotateX(0.5*a);\n   rotZ = rotateZ(2.0*a);\n   S6.d1 = vec3(0.0,0.0,1.0)*rotZ*rotX;\n   S6.d2 = vec3(1.0,0.0,0.0)*rotZ*rotX;\n   S6.Color = vec3(1.0,1.0,1.0);\n   S6.normal = compute_normal(C,S6);\n   S6.is_finite = true;\n   S6.height = 0.5;\n   S6.width = 0.7;\n   objects[5] = S6;\n   \n   Object S7;\n   S7.type = 2;\n    \n   S7.is_light = false;\n   \n   \n   // Just garbages objects created for performances test\n   for(int i = 7; i< OBJECTS_COUNT; i++){\n       Object S;\n       S.type = 0;\n       \n       rotZ = rotateX(0.1*a);\n        offset = vec3(0.0, 0.0, 1000.0);\n        rotatedOffset = rotZ*offset;\n    \n    S.Center = objects[0].Center + rotatedOffset;\n    S.R = 50.12;\n    S.Color = vec3(1.0,0.8,0.2);\n    S.is_light = true;\n    objects[i] = S;\n   }\n   \n    \n    rotZ = rotateZ(0.2*a);\n    offset = vec3(0.0, 3.0, 0.0);\n    rotatedOffset = rotZ*offset;\n    \n   \n   S7.Center = objects[0].Center + rotatedOffset + vec3(0.0,0.0,0.10);\n   rotX = rotateX(0.5*(a+20.0));\n   rotZ = rotateZ(2.0*a);\n   S7.R = 0.125;\n   S7.Color = vec3(1.0,1.0,1.0);\n   S7.height = 1.0;\n   S7.d1 = normalize(vec3(0.0,0.0,1.0) * rotZ*rotX);\n   objects[6] = S7;\n   \n   \n   lights[0].Pos = S2.Center;\n   lights[0].Color = S2.Color;\n   lights[0].Intensity = 1.0;\n   \n    vec2 centralPixelUV = vec2(0.5, 0.5);\n\n    vec3 centralPixelColor = texture(iChannel0, centralPixelUV).rgb;\n   \n   lights[1].Pos = C.Obs + C.View * 5.0 + vec3(0.15,0.15,0.215);\n   lights[1].Color = centralPixelColor;\n   lights[1].Intensity = 2.0;\n   \n   lights[2].Pos = S4.Center;\n   lights[2].Color = S4.Color;\n   lights[2].Intensity = 500000.0;\n   \n   lights[3].Pos = vec3(-10,0,-10);\n   lights[3].Color = vec3(0.6,0.6,0.2);\n   lights[3].Intensity = 1500.0;\n   \n   float bg_color = 0.2;\n   fragColor = vec4(vec3(1,1,1)*bg_color,1);//vec4(centralPixelColor,1);\n   float best_dist = 999999.0;\n   Ray R = launch(C, fragCoord);\n   for(int i = 0; i < OBJECTS_COUNT; i++) {\n       float t = 0.0;\n       bool intersect = false;\n       bool itself = false;\n       bool is_light = objects[i].is_light;\n       if (objects[i].type == 0) {\n           intersect =  (intersect_sphere(R, objects[i], t,fragColor,is_light));\n       } else if (objects[i].type == 1) {\n             intersect = (intersect_plan(R,objects[i],t));\n       } else if (objects[i].type == 2) {\n            intersect =  (intersect_cylinder(R,objects[i],t));\n            itself = true;\n       }\n       if (intersect) {\n           if (t>0.0 && t< best_dist) {\n                       best_dist = t;\n                       fragColor = vec4(0,0,0,1);\n                       if (is_light) {\n                           fragColor = vec4(objects[i].Color,1);\n                       }\n                     \n                     for (int j = 0; j < LIGHTS_COUNT; j++){\n                           fragColor = vec4(fragColor.xyz + apply_light(R,objects[i], lights[j], t, i, itself) ,1);\n                       }\n\n             }\n       }\n   }\n   \n   \n}\n","name":"Image","description":"","type":"image"}]}