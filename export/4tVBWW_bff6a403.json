{"ver":"0.1","info":{"id":"4tVBWW","date":"1542565449","viewed":546,"name":"Blackbody","username":"TinyTexel","description":"Blackbody spectrum (1000K - 40000K) monte-carlo integrated and converted to sRGB.\n\nhttps://en.wikipedia.org/wiki/Planck%27s_law","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["color","blackbody"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2018 Tiny Texel\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 xyz = textureLod(iChannel0, tex, 0.0).rgb;\n    xyz /= dot(xyz, vec3(1.0));\n    \n    vec3 col = XYZ_to_sRGB(xyz);\n    \n    //col /= max(col.r, max(col.g, col.b));\n    //col = (col - min(col.r, min(col.g, col.b))) / (max(col.r, max(col.g, col.b)) - min(col.r, min(col.g, col.b)));\n    //col /= xyz.y;\n    //col *= 0.02;\n    \n    //float T = mix(2000.0, 10000.0, tex.x);\n    //float D65 = 6503.6;\n    //if(abs(T - D65) < 10.0 && abs(tex.y - 0.5) > 0.48) col = vec3(0.0);\n\n    fragColor = vec4(sRGB_NonlinearEncode(col), 0.0);\n    //fragColor = vec4(col.r > tex.y, col.g > tex.y, col.b > tex.y, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MIT License\n// Copyright © 2018 Tiny Texel\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{\n    col = vec4(0.0);\n      \n    vec2 uv = fragCoord.xy - 0.5;\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 pxId  = vec3(float(iFrame), uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n\n    float T = mix(1000.0, 40000.0, tex.x);\n    //T = 6503.6;// D65\n    //T = 5778.0;// sun\n    \n    vec3 c = vec3(0.0);\n    \n    const float n = 64.0;\n    for(float i = 0.0; i < n; ++i)\n    {\n\t\tfloat l = mix(380.0, 720.0, HashFlt(hh, 0x54A95E38u) * 0.5 + 0.5);\n        \n        float L = Blackbody(l, T);\n        \n        //if(tex.y > 0.5)\n        //c += L * XYZ2(l);\n        //else\n        c += L * XYZ10(l);\n        \n        hh = Hash(hh);\n    }\n    \n\n    vec3 o = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col.rgb = mix(o, c / n, 1.0 / float(iFrame + 1));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// The MIT License\n// Copyright © 2018 Tiny Texel\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n\n#define rsqrt inversesqrt\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\n\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nvec3 sRGB_NonlinearEncode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZ_to_sRGB(vec3 xyz)\n{\n    float r = dot(xyz, vec3( 3.2406, -1.5372, -0.4986));\n    float g = dot(xyz, vec3(-0.9689,  1.8758,  0.0415));\n    float b = dot(xyz, vec3( 0.0557, -0.2040,  1.0570));\n    \n    return vec3(r, g, b);\n}\n\n// https://en.wikipedia.org/wiki/Planck%27s_law\n// wavelength l in nm, temperature T in Kelvin, returns radiance\nfloat Blackbody(float l, float T)\n{\n    const float h = 6.626070040e-16;\n    const float k = 1.38064852e-5;\n    const float c = 299792458.0e9;\n    \n    const float o0 = 2e-3 * h * (c * c);\n    const float o1 = h * c / k * 1.442695;\n    \n    float l5 = ((l * l) * (l * l)) * l;\n    \n    return o0 / (l5 * (exp2(o1 / (l * T)) - 1.0));\n}\n\n// Simple Analytic Approximations to the CIE XYZ Color Matching Functions (https://www.shadertoy.com/view/4ttBRB)\n// https://research.nvidia.com/publication/simple-analytic-approximations-cie-xyz-color-matching-functions\nvec3 XYZ10(float l)\n{\n    vec3 xyz;\n\n    xyz.x = 0.4 * exp2(-866.433976 * Pow2(log2(l * 0.000986 + 0.56213)));\n\txyz.x += 1.13 * exp2(-162.19644 * Pow2(log2(l * -0.001345 + 1.799597)));\n    \n\txyz.y = 1.011 * exp2(-1.442695 * Pow2(l * 0.015325 - 8.522368));\n\n\txyz.z = 2.06 * exp2(-22.18071 * Pow2(log2(l * 0.005543 - 1.474501)));\n    \n    return xyz;\n}\n\nvec3 XYZ2(float l)\n{\n    vec3 xyz;\n\n    {\n        float dParam1 = (l-442.0)*((l < 442.0)?0.0624:0.0374);\n        float dParam2 = (l-599.8)*((l < 599.8)?0.0264:0.0323);\n        float dParam3 = (l-501.1)*((l < 501.1)?0.0490:0.0382);\n        xyz.x = 0.362*exp(-0.5*dParam1*dParam1) + 1.056*exp(-0.5*dParam2*dParam2) - 0.065*exp(-0.5*dParam3*dParam3);\n    }\n\n    {\n        float dParam1 = (l-568.8)*((l < 568.8)?0.0213:0.0247);\n        float dParam2 = (l-530.9)*((l < 530.9)?0.0613:0.0322);\n        xyz.y = 0.821*exp(-0.5*dParam1*dParam1) + 0.286*exp(-0.5*dParam2*dParam2);\n    }\n\n    {\n        float dParam1 = (l-437.0)*((l < 437.0)?0.0845:0.0278);\n        float dParam2 = (l-459.0)*((l < 459.0)?0.0385:0.0725);\n        xyz.z = 1.217*exp(-0.5*dParam1*dParam1) + 0.681*exp(-0.5*dParam2*dParam2);\n    }\n\n    return xyz;\n}","name":"Common","description":"","type":"common"}]}