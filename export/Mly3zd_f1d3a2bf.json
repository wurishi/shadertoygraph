{"ver":"0.1","info":{"id":"Mly3zd","date":"1476173982","viewed":1009,"name":"Mandelbrot 3D bifurcation","username":"rory618","description":"Attempt to render something similar to http://www.hevanet.com/bradc/ComplexLogisticBifurcationDiagram3D.png\nUse wasd + qe and mouse to move around the camera, R to reset. Arrow up and down to change speed and left and right to focus.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy);\n    fragColor = fragColor.xxyw/(fragColor.z+20.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926535\n#define m 10000.0\n#define up vec3(0,0,1)\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_S  = 83.5/256.0;\nconst float KEY_D  = 68.5/256.0;\n\nconst float KEY_Q  = 81.5/256.0;\nconst float KEY_E  = 69.5/256.0;\n\nconst float KEY_R  = 82.5/256.0;\n\nconst vec2 cPosLoc = vec2(1.5,1.5);\nconst vec2 cDirLoc = vec2(2.5,1.5);\nconst vec2 mouseLoc = vec2(3.5,1.5);\nconst vec2 moveLoc = vec2(3.5,2.5);\nconst vec2 speedLoc = vec2(3.5,3.5);\nconst vec2 distanceLoc = vec2(2.5,2.5);\n\nfloat speed = .01;\nfloat sens = .01;\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\n\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float move = 0.;\n    vec3 cPos = load(cPosLoc).xyz;\n    vec3 cDir = normalize(load(cDirLoc).xyz);\n    vec2 mouse = load(mouseLoc).xy;\n    speed = load(cPosLoc).w;\n    float dist = load(cDirLoc).w;\n    vec2 dM = iMouse.xy-mouse;\n    \n    vec3 R = normalize(cross(cDir, up));\n    vec3 U = normalize(cross(R, cDir));\n    \n    if (keyIsDown(KEY_UP)) { speed *= 1.03; }\n    if (keyIsDown(KEY_DOWN)) { speed /= 1.03; }\n    if (keyIsDown(KEY_RIGHT)) { dist *= 1.03; }\n    if (keyIsDown(KEY_LEFT)) { dist /= 1.03; }\n    if (keyIsDown(KEY_D)) {cPos += speed*R;move=1.;}\n    if (keyIsDown(KEY_A))  {cPos -= speed*R;move=1.;}\n    if (keyIsDown(KEY_W))    {cPos += speed*cDir;move=1.;}\n    if (keyIsDown(KEY_S))  {cPos -= speed*cDir;move=1.;}\n    if (keyIsDown(KEY_Q))   {cPos += speed*U;move=1.;}\n    if (keyIsDown(KEY_E))  {cPos -= speed*U;move=1.;}\n\n    \n    if (keyIsDown(KEY_R)||iFrame == 0){\n        cPos = vec3(1.0, -2.3, 0.0);\n        //cPos = vec3(-.2, -1.0, -0.4);\n        cDir = normalize(vec3(0.0,0.6,0.));\n        move = 1.;\n        speed = .01;\n        dist =.01;\n    }\n    \n    if (iMouse.z > 0.0) {\n        if(mouse.x>0.0){\n        \tcDir += sens * (R * dM.x + U * dM.y);\n        }\n        mouse = iMouse.xy;\n    } else {\n        mouse = vec2(0);\n    }\n    \n    fragColor = vec4(0);\n    fragColor += save(vec4(cPos,speed),cPosLoc,fragCoord);\n    fragColor += save(vec4(cDir,dist),cDirLoc,fragCoord);\n    fragColor += save(vec4(mouse,0,0),mouseLoc,fragCoord);\n    fragColor += save(vec4(move),moveLoc,fragCoord);\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 cPosLoc = vec2(1.5,1.5);\nconst vec2 cDirLoc = vec2(2.5,1.5);\nconst vec2 moveLoc = vec2(3.5,2.5);\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 cprod(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 iter(vec2 z, vec2 c){\n    //return cprod(c,z-cprod(z,z));//logistic map   x[n]+1 = cx[n](1 - xn)\n    return cprod(z,z)+c;//           mandelbrot   x[n]+1 = x[n]^2+c\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ofc = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    float dist = load(cDirLoc).w;\n    vec3 co = load(cPosLoc).xyz;\n    float move = load(moveLoc).x;\n    vec3 cd = normalize(load(cDirLoc).xyz);\n    if(iMouse.z<=0.&&move<.5){\n    \tfragColor = ofc;\n    } else {\n        fragColor = vec4(0,0,0,100);\n    }\n    for(int zz = 0; zz <3; zz++){\n        \n    vec3 r = hash33(vec3(fragCoord*float(zz+1),iFrame+83*zz));\n    vec2 os = (r.xy-.5) / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = 2.*(uv-.5)*iResolution.xy/iResolution.yy + os;\n    vec3 k = vec3(0,0,1);\n    vec3 right = normalize(cross(cd,k));\n    vec3 up = normalize(cross(right,cd));\n    vec3 rd = normalize(up*xy.y+right*xy.x+cd);\n    \n    float d = dist*100.*pow(tan((r.z-.5)*7.),2.);\n    vec2 c = co.xy+rd.xy*d;\n    \n    //vec4 ofc = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    for(int i = 0; i < 20; i++) {\n    \tvec4 dpt = texture(iChannel1, (fragCoord.xy+floor((hash33(vec3(r.xy,i)).xy-.5)*15.)) / iResolution.xy);\n\t\t//fragColor = vec4(0);\n    \tif(dpt.w<5.){\n        \td = dpt.w + dist*tan((r.z-.5)*7.);\n    \t}\n    }\n    vec2 z = vec2(0,0);\n    bool b = false;\n    for (int i=0; i < 100; i++){\n        z = iter(z,c);\n        if(dot(z,z)>16.){\n            b=true;\n            break;\n        }\n    }\n    vec2 pz = z;\n    int period = -1;\n    for (int i=0; i < 100; i++){\n        z = iter(z,c);\n        if(dot(z,z)>16.){\n            b=true;\n            break;\n        }\n        if(length(z-pz)<.01 && period == -1){\n            period = i;\n        }\n    }\n    if(b)\n   \t z = vec2(0,0);\n   // if(b==false && period != -2){\n\t\tfor (int i=0; i < 50; i++){\n        \tz = iter(z,c);\n        \tif(dot(z,z)>4.){\n            \tbreak;\n        \t}\n\t\t\tvec3 pr = vec3(c,z.x);\n\t\t\tvec3 pi = vec3(c,z.y);\n\t\t\tvec3 pm = vec3(c,length(z));\n            float ctr = dot(rd,normalize(pr-co));\n            //float cti = dot(rd,normalize(pi-co)); crt = max(ctr,cti); //imaginary part\n            if(ctr>.999995 && fragColor.w-d >-1.1 || fragColor.w > 10.){\n                fragColor.w = min(fragColor.w,d);\n                fragColor.xy += vec2(.5+.5*sin(vec2(2.2,2.3)*float(3+period)));\n                fragColor.z += 1.;\n            }\n    \t}\n   // }\n        \n    }\n\t//fragColor = mix(5.*fragColor,ofc,.99);\n}","name":"Buf B","description":"","type":"buffer"}]}