{"ver":"0.1","info":{"id":"4lGGWy","date":"1476359568","viewed":2354,"name":"Volumetric cloud rendering","username":"toninoni","description":"GLSL implementation of the volumetric cloud rendering described in http://www.blog.sirenix.net/blog/realtime-volumetric-clouds-in-unity\nMouse.x - rotate\nMouse.y - forward/backward","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["test","cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n GLSL implementation of volumetric cloud rendering as\n described in http://www.blog.sirenix.net/blog/realtime-volumetric-clouds-in-unity\n**/\n#define PI 3.14159265359\n#define iterations 50.0\n#define octaves 3\n#define cloudintensity 2.0\n\nfloat cloudDensity = 0.5;\nfloat viewDistance = 6.0;\nvec3 cloudColor = vec3(1.0, .8, .6);\nvec3 skyColor = vec3(0.4, 0.4, 0.7);\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv+0.5)/256.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}     \n\n\nfloat fbm(vec3 pos) {\n    float f = 0.;\n    for (int i = 0; i < octaves; i++) { \n        f += noise(pos) / pow(2.0, float(i + 1)); \n        pos *= 2.01; \n    } \n    f = f / (1.0 - 1.0 / pow(2.0, float(octaves + 1))); \n    return f; \n}\n\nvec4 frag(vec2 uv)\n{\n    // Rotation period\n    float T = 5.0;\n    float t = iTime;\n    \n    bool mouseDown = iMouse.z > 0.0;\n    if(mouseDown)\n        t = 0.0;\n    \n    // Radius of camera rotation movement\n    float tr = (t / 2.0 + iMouse.y / 200.0);\n    float r = (1.0 + cos(tr)) * 15.0;\n    \n    float tx = t * 0.1 - iMouse.x / 1000.0;\n    float camx = r * cos(tx / T * (2.0 * PI));\n    float camy = 0.0;\n    float camz = r * sin(tx / T * (2.0 * PI));\n        \n    vec3 camPos = vec3(camx, camy, camz);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camDir = normalize(camPos);\n    vec3 camRight = cross(camUp, camDir);\n    \n    vec3 ray = camUp * uv.y + camRight * uv.x + camDir;\n    vec3 pos = camPos;\n\n    // So now we have a position, and a ray defined for our current fragment, and we know from earlier in this article that it matches the field of view and aspect ratio of the camera. And we can now start iterating and creating our clouds. \n    // We will not be ray-marching twoards any distance field in this example. So the following code should be much easier to understand.\n    // pos is our original position, and p is our current position which we are going to be using later on.\n    vec3 p = pos;\n    // For each iteration, we read from our noise function the density of our current position, and adds it to this density variable.\n    float density = 0.0;\n\n    for (float i = 0.0; i < iterations; i++)\n    {\n        // f gives a number between 0 and 1.\n        // We use that to fade our clouds in and out depending on how far and close from our camera we are.\n        float f = i / iterations;\n        // And here we do just that:\n        float alpha = smoothstep(0.0, iterations * 0.2, i) * (1.0 - f) * (1.0 - f);\n        // Note that smoothstep here doesn't do the same as Mathf.SmoothStep() in Unity C# - which is frustrating btw. Get a grip Unity!\n        // Smoothstep in shader languages interpolates between two values, given t, and returns a value between 0 and 1. \n        // To get a bit of variety in our clouds we collect two different samples for each iteration.\n        float denseClouds = smoothstep(cloudDensity, 0.75, fbm(p));\n        float lightClouds = (smoothstep(-0.2, 1.2, fbm(p * 2.0)) - 0.5) * 0.5;\n        // Note that I smoothstep again to tell which range of the noise we should consider clouds.\n        // Here we add our result to our density variable\n        density += (lightClouds + denseClouds) * alpha;\n        // And then we move one step further away from the camera.\n        p = pos + ray * f * viewDistance;\n    }\n    // And here I just melted all our variables together with random numbers until I had something that looked good.\n    // You can try playing around with them too.\n    float l = (density / iterations) * cloudintensity;\n    vec3 color = skyColor + (cloudColor.rgb) * l;\n\n    return vec4(color, exp(-l));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= ar;\n\n    fragColor = frag(uv);\n}","name":"Image","description":"","type":"image"}]}