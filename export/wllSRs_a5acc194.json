{"ver":"0.1","info":{"id":"wllSRs","date":"1564007440","viewed":837,"name":"üëæüëæ Space Invaders üïπÔ∏è ","username":"coyote","description":"My reconstruction of the legendary game !\nDedicated to Tomohiro Nishikado.\n Left/Right/Space,\n 1 - new game (at any moment)\n C - toggle CRT filter, nice for fullscreen (def OFF)","likes":35,"published":1,"flags":48,"usePreview":1,"tags":["2d","game","retro","pixel","space","invaders","arcade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Space Invaders reconstruction by coyote\n//     dedicated to Tomohiro Nishikado\n//\n// my other reconstruction:\n//    Frogger : https://www.shadertoy.com/view/wtBSzW\n//\n// CRT filter by Timothy Lottes  (press C to toggle CRT)\n// hash11 taken from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n//\n// Engine updates are exactly one per frame so the game:\n//  - slows down if 60fps is not met\n//  - probably would be too fast if both monitor and browser support working\n//    in higher refresh rate, and of course if gfx card is fast enough\n//    (haven't had a chance to try it on such a system, though)\n//\n// Anyway, for too fast game there is a preprocessor variable defined at the\n// top of the Common source.\n// The variable is called FD. (as in frame divisor)\n//\n//  - for monitor/browser with support for 120Hz set FD to 2 (updates every other frame)\n//  - for 144Hz with FD 2 the game will be faster, and with FD 3 slower, sorry\n//\n// ********* Keys **********\n//\n// Left arrow           - move left\n// Right arrow          - move right\n// Space or left CTRL   - fire\n//\n// 1 - start a new game at any moment\n// C - toggle CRT simulation, nice for fullscreen (default OFF   )\n// I - toggle max integer multiplier / max height (default height)\n// L - toggle linear interpolation during zoom    (default ON    )\n// F - toggle FPS counter\n// P - pause, but shader runs at full power, so use wisely !!\n//\n\n\n//Image - CRT filter (press C to toggle, default is off)\n//A nearest,C linear,texture mipmap,Keyboard\n\n\n//============================================================\n\n//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//   by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n// Emulated input resolution.\n\n//#define res (640.0*vec2(1.0,iResolution.y/iResolution.x))\n//#define res (iResolution.xy/floor(1.0+iResolution.xy/512.0))\n\n#define res (iResolution.xy/2.)\n\n// Hardness of scanline.\n//  -8.0 = soft\n// -16.0 = medium\nconst float hardScan=-8.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nconst float hardPix=-3.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0/8.0 = extreme\nconst vec2 warp=vec2(1./32.0,1./24.0); \n\n// Amount of shadow mask.\nconst float maskDark=.6;\nconst float maskLight=2.0;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off){\n  pos=floor(pos*res+off)/res;\n  if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);\n//    return ToLinear(texelFetch(iChannel1,ivec2(pos.xy*iResolution.xy),0).rgb);\n  return ToLinear(texture(iChannel1,pos.xy,-16.0).rgb);}\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}\n    \n// 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n// 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off){\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  // Return filtered sample.\n  return (b*wb+c*wc+d*wd)/(wb+wc+wd);}\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off){\n  vec3 a=Fetch(pos,vec2(-2.0,off));\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  vec3 e=Fetch(pos,vec2( 2.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wa=Gaus(dst-2.0,scale);\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  float we=Gaus(dst+2.0,scale);\n  // Return filtered sample.\n  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);}\n\n// Return scanline weight.\nfloat Scan(vec2 pos,float off){\n  float dst=Dist(pos).y;\n  return Gaus(dst+off,hardScan);}\n\n// Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos){\n  vec3 a=Horz3(pos,-1.0);\n  vec3 b=Horz5(pos, 0.0);\n  vec3 c=Horz3(pos, 1.0);\n  float wa=Scan(pos,-1.0);\n  float wb=Scan(pos, 0.0);\n  float wc=Scan(pos, 1.0);\n  return a*wa+b*wb+c*wc;}\n\n\n// Shadow mask.\nvec3 Mask(vec2 pos)\n{\n  pos.x+=pos.y*3.0;\n  vec3 mask=vec3(maskDark,maskDark,maskDark);\n  pos.x=fract(pos.x/6.0);\n  if(pos.x<0.333)mask.r=maskLight;\n  else if(pos.x<0.666)mask.g=maskLight;\n  else mask.b=maskLight;\n  return mask;}    \n\n\nvec4 background( vec2 u ) {\n\n    float pi = 3.14159265 ;\n    float T = 38. ;\n    u += u - iResolution.xy ;\n    u /= iResolution.y ;\n    u.y += 3.65 ;\n    u /= 3.5 ;\n    \n    vec3 n = vec3(sqrt(max(1.-dot(u,u),0.)),u.y,-u.x) ;    \n    vec3 l = normalize(vec3(5,8,-9));\n    vec3 i = dot(n,l)*vec3(1.5,1.4,0);\n    vec3 sky = vec3( 0, .98, 1 ) - smoothstep( vec3(0), vec3(1), vec3(0,.55,.5)*length(u) );\n    vec3 planet = i*texture(iChannel2,vec2(T*.01+atan(n.y,n.x)/pi,asin(n.z)/pi)).rgb;\n    float R = 3.5*iResolution.y/2. ;\n    vec3 c = mix( planet, sky, smoothstep((R-4.)/R, (R-1.)/R, length(u)) ) ;\n    return( vec4(c,1) ) ;\n}\n\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n\n#if FD > 1\n    //skip frames\n    if( iFrame % FD != 0 ) {\n        discard ;\n    }\n#endif\n\n    ivec2 iu = ivec2( u ) ;\n\n    vec2 fscr_dim = vec2( scr_dim ) ;\n\n    float k = iResolution.y / fscr_dim.y ;\n    \n    if( texelFetch( iChannel3, ivec2( KEY_INT_SIZE, 2 ), 0 ).x > .5 ) {\n        k = floor( k ) ;\n    }\n    \n    ivec2 new_dim = ivec2( fscr_dim * k ) ;\n    ivec2 diff = ivec2( iResolution.xy ) - new_dim ;\n    \n    vec4 col ;\n\n    if( ! iINSIDE( iu, diff / 2, diff / 2 + new_dim ) ) {\n        col = vec4( .5, .0, 0, .0 ) ; //border\n    } else {\n        if( texelFetch( iChannel3, ivec2( KEY_CRT, 2 ), 0 ).x > .5 ) {\n            col = texelFetch( iChannel1, ivec2( u ), 0 ) ; //just to get alpha\n            col.rgb = ToSrgb( Tri(u.xy/iResolution.xy)*Mask(u.xy) ) ; //read Buffer C and apply crt filter\n        } else {\n            col = texelFetch( iChannel1, ivec2( u ), 0 ) ; //plain Buffer C copy\n        }\n    }\n\n    o = mix( .8*background( u ), col, col.a );\n    o.a = 1. ;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define FD  1  //update every n-th frame (1 for 60Hz, 2 for 120Hz monitor/browser combo)\n\n//ARROWS\n#define KEY_LEFT     37\n#define KEY_UP       38  //not used\n#define KEY_RIGHT    39\n#define KEY_DOWN     40  //not used\n\n#define KEY_FIRE     32  //SPACE - fire\n#define KEY_ALT_FIRE 17  //CTRL - also fire\n\n#define KEY_RESTART  49  //1 - start a new game at any moment\n#define KEY_CRT      67  //C - toggle CRT simulation, nice for fullscreen (default OFF   )\n#define KEY_INT_SIZE 73  //I - toggle max integer multiplier / max height (default height)\n#define KEY_LINEAR   76  //L - toggle linear interpolation during zoom    (default ON    )\n#define KEY_FPS      70  //F - toggle fps counter\n#define KEY_PAUSE    80  //P - pause, but shader runs at full power, so use wisely !!\n\n#define NUM_ENEMY_ROWS     5\n#define NUM_ENEMY_COLS     11\n#define ENEMY_MOVE_PERIOD  1\n\n#define SCR_WIDTH   224\n#define SCR_HEIGHT  256\n\n#define NUM_SHIELDS   4\n#define SHIELD_X     32\n#define SHIELD_Y     48\n#define SHIELD_DX    45\n#define SHIELD_W     22\n#define SHIELD_H     16\n\n#define BOTTOM_LINE  16\n\n#define BULLET_H        4  //our bullet is 1x4\n\n#define MAX_EN_BULLETS  3  //max number of simultaneous bullets on screen\n#define ENEMY_BULL_H    4  //for collision (enemy bullets are actually 3x7)\n\n#define ENEMY_BULL_SPEED     4  //pix/move period\n#define EN_BULL_MOVE_PERIOD  3  //move only every n-th frame\n\n#define STATE_PLAYING          1\n#define STATE_LEVEL_COMPLETE   2\n#define STATE_PAUSE            3\n#define STATE_GAME_OVER       99\n\n#define NEXT_LEVEL_T  (1*60)  //wait 1s before starting new level\n\n#define STATE_FLAG_PAUSED            1\n#define STATE_FLAG_EXTRA_LIFE        2\n#define STATE_FLAG_DONT_MOVE_EN      4\n#define STATE_FLAG_EN_LANDED         8\n#define STATE_FLAG_EN_APPEARING     16\n#define STATE_FLAG_GAME_OVER_ANIM   32\n\n#define STATE_FLAG_KEY_FIRE       1024\n#define STATE_FLAG_KEY_ALT_FIRE   2048\n#define STATE_FLAG_KEY_PAUSE      4096\n#define STATE_FLAG_KEY_RESTART    8192\n\n//used shadertoy's key toggle for the following\n/*\n#define STATE_FLAG_KEY_LINEAR     8192\n#define STATE_FLAG_KEY_INT_SIZE  16483\n#define STATE_FLAG_KEY_CRT       32768\n*/\n\n#define NUM_FONT_CHARS 44\nconst ivec2 ch_gfx_dim = ivec2( 5, 7 ) ;\n\n#define FONT_IN_TEXTURE 1\n\n\nconst ivec2\n    adr_state =       ivec2( 0, 0 ),\n    adr_gun =         ivec2( 1, 0 ),\n    adr_bullet =      ivec2( 2, 0 ),\n    adr_next_enemy =  ivec2( 3, 0 ),\n    adr_score =       ivec2( 4, 0 ),\n    adr_mothership =  ivec2( 5, 0 ),\n    adr_helper =      ivec2( 6, 0 ),\n\n    adr_bl_en_bull =  ivec2( 16, 0 ), //single row\n    adr_tr_en_bull =  adr_bl_en_bull + ivec2( MAX_EN_BULLETS, 1 ),\n    \n    adr_bl_enemies =  ivec2( 0, 1 ),\n    adr_tr_enemies =  adr_bl_enemies + ivec2( NUM_ENEMY_COLS, NUM_ENEMY_ROWS ),\n    \n    shields_area_bl = ivec2( SHIELD_X, SHIELD_Y ) - 8,\n    shields_area_tr = shields_area_bl + 16 + ivec2( NUM_SHIELDS * SHIELD_DX + SHIELD_W, SHIELD_H )\n\n#if FONT_IN_TEXTURE == 1\n    ,\n    font_gfx_bl =     ivec2( 0, 128 ),\n    font_gfx_tr =     font_gfx_bl + ivec2( ch_gfx_dim.x * NUM_FONT_CHARS, ch_gfx_dim.y )\n#endif\n;\n\nconst ivec2\n    data_dim            =   max( adr_tr_enemies, max( adr_helper, adr_tr_en_bull ) ),\n    //prev_data_off       =   ivec2( ( data_dim.x + 0xf ) & ~0xf, 0 ),\n\n    enemy_dim           =   ivec2( 12,   8 ),\n    en_exp_dim          =   ivec2( 13,   8 ),\n    en_en_bull_off      =   ivec2(  5, -13 ),\n    mothership_dim      =   ivec2( 16,   7 ),\n    mothership_exp_dim  =   ivec2( 21,   8 ),\n    gun_exp_dim         =   ivec2( 16,   8 ),\n    gun_bull_off        =   ivec2(  8,   8 ),\n    bull_exp_dim        =   ivec2(  8,   8 ),\n    bull_exp_off        = - ivec2(  4,   2 ),\n    en_bull_dim         =   ivec2(  3,   7 ),\n    en_bull_exp_off     = - ivec2(  3,   3 ) ;\n\n#define LOADI( ivec2_adr ) ivec4( texelFetch( iChannel0, (ivec2_adr), 0 ) )\n#define STOREI( ivec2_adr, value ) (o = iu == (ivec2_adr) ? vec4(value) : o)\n\n//integer collisions, top and right (trs) borders are excluded\n//input ivec2 point, ivec2 (left,bottom), ivec2 (right,top)\n#define iINSIDE( a, bl, tr ) ( (a) == clamp( (a), (bl), (tr)-1 ) )\n#define iCOLLIDE( bl, tr, bl2, tr2 ) iINSIDE( (bl), (bl2)-((tr)-1)+(bl), (tr2) )\n\n//rects are ivec4 as (x,y,w,h)\n#define iRECTS_COLLIDE( a, b ) iCOLLIDE( (a).xy, (a).xy+(a).zw, (b).xy, (b).xy+(b).zw )\n\n#define PREPARE_TEST_BIT float fx2 = exp2(-float(x+1))\n#define BR24(_y, A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,X,Y) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11)+(M<<12)+(N<<13)+(O<<14)+(P<<15)+(Q<<16)+(R<<17)+(S<<18)+(T<<19)+(U<<20)+(V<<21)+(X<<22)+(Y<<23))*fx2) >= .5)\n#define BR20(_y, A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11)+(M<<12)+(N<<13)+(O<<14)+(P<<15)+(Q<<16)+(R<<17)+(S<<18)+(T<<19))*fx2) >= .5)\n#define BR16(_y, A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11)+(M<<12)+(N<<13)+(O<<14)+(P<<15))*fx2) >= .5)\n#define BR15(_y, A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11)+(M<<12)+(N<<13)+(O<<14))*fx2) >= .5)\n#define BR12(_y, A,B,C,D,E,F,G,H,I,J,K,L) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11))*fx2) >= .5)\n#define BR8(_y, A,B,C,D,E,F,G,H) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7))*fx2) >= .5)\n#define BR6(_y, A,B,C,D,E,F) v = y!=_y ? v : vec3(fract( float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5))*fx2) >= .5)\n\n#define _ 0\n#define w 1\n\nvec4 draw_enemy( int t, int frame, ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), enemy_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        x += 12 * (frame & 1) ;\n        PREPARE_TEST_BIT ;\n        if( t == 2 ) {\n            BR24(7,   _,_,_,_,_,w,w,_,_,_,_,_  ,  _,_,_,_,_,w,w,_,_,_,_,_  ) ;\n            BR24(6,   _,_,_,_,w,w,w,w,_,_,_,_  ,  _,_,_,_,w,w,w,w,_,_,_,_  ) ;\n            BR24(5,   _,_,_,w,w,w,w,w,w,_,_,_  ,  _,_,_,w,w,w,w,w,w,_,_,_  ) ;\n            BR24(4,   _,_,w,w,_,w,w,_,w,w,_,_  ,  _,_,w,w,_,w,w,_,w,w,_,_  ) ;\n            BR24(3,   _,_,w,w,w,w,w,w,w,w,_,_  ,  _,_,w,w,w,w,w,w,w,w,_,_  ) ;\n            BR24(2,   _,_,_,w,_,w,w,_,w,_,_,_  ,  _,_,_,_,w,_,_,w,_,_,_,_  ) ;\n            BR24(1,   _,_,w,_,_,_,_,_,_,w,_,_  ,  _,_,_,w,_,w,w,_,w,_,_,_  ) ;\n            BR24(0,   _,_,_,w,_,_,_,_,w,_,_,_  ,  _,_,w,_,w,_,_,w,_,w,_,_  ) ;\n        } else if( t == 1 ) {\n            BR24(7,   _,_,_,w,_,_,_,_,_,w,_,_  ,  _,_,_,w,_,_,_,_,_,w,_,_  ) ;\n            BR24(6,   _,_,_,_,w,_,_,_,w,_,_,_  ,  _,w,_,_,w,_,_,_,w,_,_,w  ) ;\n            BR24(5,   _,_,_,w,w,w,w,w,w,w,_,_  ,  _,w,_,w,w,w,w,w,w,w,_,w  ) ;\n            BR24(4,   _,_,w,w,_,w,w,w,_,w,w,_  ,  _,w,w,w,_,w,w,w,_,w,w,w  ) ;\n            BR24(3,   _,w,w,w,w,w,w,w,w,w,w,w  ,  _,w,w,w,w,w,w,w,w,w,w,w  ) ;\n            BR24(2,   _,w,_,w,w,w,w,w,w,w,_,w  ,  _,_,w,w,w,w,w,w,w,w,w,_  ) ;\n            BR24(1,   _,w,_,w,_,_,_,_,_,w,_,w  ,  _,_,_,w,_,_,_,_,_,w,_,_  ) ;\n            BR24(0,   _,_,_,_,w,w,_,w,w,_,_,_  ,  _,_,w,_,_,_,_,_,_,_,w,_  ) ;\n        } else if( t == 0 ) {\n            BR24(7,   _,_,_,_,w,w,w,w,_,_,_,_  ,  _,_,_,_,w,w,w,w,_,_,_,_  ) ;\n            BR24(6,   _,w,w,w,w,w,w,w,w,w,w,_  ,  _,w,w,w,w,w,w,w,w,w,w,_  ) ;\n            BR24(5,   w,w,w,w,w,w,w,w,w,w,w,w  ,  w,w,w,w,w,w,w,w,w,w,w,w  ) ;\n            BR24(4,   w,w,w,_,_,w,w,_,_,w,w,w  ,  w,w,w,_,_,w,w,_,_,w,w,w  ) ;\n            BR24(3,   w,w,w,w,w,w,w,w,w,w,w,w  ,  w,w,w,w,w,w,w,w,w,w,w,w  ) ;\n            BR24(2,   _,_,w,w,w,_,_,w,w,w,_,_  ,  _,_,_,w,w,_,_,w,w,_,_,_  ) ;\n            BR24(1,   _,w,w,_,_,w,w,_,_,w,w,_  ,  _,_,w,w,_,w,w,_,w,w,_,_  ) ;\n            BR24(0,   _,_,w,w,_,_,_,_,w,w,_,_  ,  w,w,_,_,_,_,_,_,_,_,w,w  ) ;\n        }\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\nvec4 draw_enemy_bullet( int type, int frame, ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), en_bull_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        x += 3 * (frame & 3) ;\n        PREPARE_TEST_BIT ;\n        if( type == 0 ) {\n            BR12(6, _,w,_ , _,w,_ , w,w,w , _,w,_ ) ;\n            BR12(5, _,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;\n            BR12(4, _,w,_ , w,w,w , _,w,_ , _,w,_ ) ;\n            BR12(3, _,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;\n            BR12(2, w,w,w , _,w,_ , _,w,_ , _,w,_ ) ;\n            BR12(1, _,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;\n            BR12(0, _,w,_ , _,w,_ , _,w,_ , w,w,w ) ;\n        } else if( type == 1 ) {\n            BR12(6, _,w,_ , _,w,_ , _,w,w , _,w,_ ) ;\n            BR12(5, _,w,_ , _,w,_ , w,w,_ , _,w,_ ) ;\n            BR12(4, w,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;\n            BR12(3, _,w,w , _,w,_ , _,w,w , _,w,_ ) ;\n            BR12(2, _,w,_ , _,w,_ , w,w,_ , _,w,_ ) ;\n            BR12(1, w,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;\n            BR12(0, _,w,w , _,w,_ , _,w,_ , _,w,_ ) ;\n        } else if( type == 2 ) {\n            BR12(6, w,_,_ , _,w,_ , _,_,w , _,w,_ ) ;\n            BR12(5, _,w,_ , _,_,w , _,w,_ , w,_,_ ) ;\n            BR12(4, _,_,w , _,w,_ , w,_,_ , _,w,_ ) ;\n            BR12(3, _,w,_ , w,_,_ , _,w,_ , _,_,w ) ;\n            BR12(2, w,_,_ , _,w,_ , _,_,w , _,w,_ ) ;\n            BR12(1, _,w,_ , _,_,w , _,w,_ , w,_,_ ) ;\n            BR12(0, _,_,w , _,w,_ , w,_,_ , _,w,_ ) ;\n        }\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\nvec4 draw_bullet_explosion( int type, ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), bull_exp_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        x += type * 8 ;\n        PREPARE_TEST_BIT ;\n        BR16(7,  w,_,_,_,w,_,_,w  ,  _,_,_,w,_,_,_,_  ) ;\n        BR16(6,  _,_,w,_,_,_,w,_  ,  _,w,_,_,_,w,_,_  ) ;\n        BR16(5,  _,w,w,w,w,w,w,_  ,  _,_,_,w,w,_,w,_  ) ;\n        BR16(4,  w,w,w,w,w,w,w,w  ,  _,_,w,w,w,w,_,_  ) ;\n        BR16(3,  w,w,w,w,w,w,w,w  ,  _,w,_,w,w,w,_,_  ) ;\n        BR16(2,  _,w,w,w,w,w,w,_  ,  _,_,w,w,w,w,w,_  ) ;\n        BR16(1,  _,_,w,_,_,w,_,_  ,  _,w,_,w,w,w,_,_  ) ;\n        BR16(0,  w,_,_,w,_,_,_,w  ,  _,_,w,_,w,_,w,_  ) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\n#undef _\n#undef w\n\nvec4 draw_shield( ivec2 pos, ivec2 iu ) {\n    iu -= pos ;\n    int x = iu.x, y = iu.y ;\n    if( x < 0 || y < 0 || x >= 22 || y >= 16 ) return( vec4( 0,0,0,1 ) ) ;\n    if( y >= 4 && y < 12 ) return( vec4( 1 ) ) ;\n    if( y < 2 && x >= 5 && x < 16 ) return( vec4( 0,0,0,1 ) ) ;\n    if( y < 4 && x >= 7 && x < 14 ) return( vec4( 0,0,0,1 ) ) ;\n    if( y == 2 && ( x == 6 || x == 14 ) ) return( vec4( 0,0,0,1 ) ) ;\n    if( y == 13 && ( x == 2 || x == 19 ) ) return( vec4( 1 ) ) ;\n    if( y >= 13 && ( x < 3 || x >= 19 ) ) return( vec4( 0,0,0,1 ) ) ;\n    if( y == 12 && ( x == 0 || x == 21 ) ) return( vec4( 0,0,0,1 ) ) ;\n    if( y == 15 && ( x == 3 || x == 18 ) ) return( vec4( 0,0,0,1 ) ) ;\n    return( vec4( 1 ) ) ;\n}\n\nbool pix_coll_bullet_enemy_bullet( ivec2 b_pos, int type, int frame, ivec2 eb_pos ) {\n    for( int i = 0 ; i < 4 ; ++ i ) {\n        if( draw_enemy_bullet( type, frame, eb_pos, b_pos ).x > 0. ) {\n            return( true ) ;\n        }\n        b_pos.y ++ ;\n    }\n    return( false ) ;\n}\n\nbool pix_coll_bullet_enemy( ivec2 b_pos, int type, int frame, ivec2 e_pos ) {\n    for( int i = 0 ; i < 4 ; ++ i ) {\n        if( draw_enemy( type, frame, e_pos, b_pos ).x > 0. ) {\n            return( true ) ;\n        }\n        b_pos.y ++ ;\n    }\n    return( false ) ;\n}\n\n#if ! defined( SCR_WIDTH ) || ! defined( SCR_HEIGHT )\n    const ivec2 scr_dim = ivec2( 224 & ~0x3, 256 ) ;\n#else\n    const ivec2 scr_dim = ivec2( SCR_WIDTH & ~0x3, SCR_HEIGHT ) ;\n#endif\n\n#ifndef FD\n    #define FD 1\n#else\n    #if FD < 1 || FD > 5\n      #undef FD\n      #define FD 1\n    #endif\n#endif\n\n#define NUM_ENEMIES        ( NUM_ENEMY_ROWS * NUM_ENEMY_COLS )\n\n#define en_bull_start_row(b)  (((b).w>>16) & 0xff)\n#define en_bull_start_col(b)  (((b).w>>24) & 0xff)\n#define en_bull_move_phase(b) (((b).w>>4) )\n#define en_bull_anim_phase(b) (((b).w>>2) & 0x3)\n#define en_bull_type(b)       ( (b).w     & 0x3)\n#define en_bull_frame(b) (0x3 & ((iFrame/FD+en_bull_move_phase(b)) / EN_BULL_MOVE_PERIOD + en_bull_anim_phase(b)))\n\n//input: int flags, int bit (or multiple bits), float condition\n#define put_flag( flags, b, c ) ( flags = (c) > .5 ? flags |= (b) : flags &= ~(b) )\n\n#define set_flag( flags, b )    ( flags |= (b) )\n#define clear_flag( flags, b )  ( flags &= ~(b) )\n#define toggle_flag( flags, b ) ( flags ^= (b) )\n#define flag( flags, b )        bool( (flags) & (b) )\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//Buffer A - data buffer, gameplay logic\n//A nearest,_,_,Keyboard\n\n//hash11 taken from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n\n#define GOD_MODE    false\n#define NO_SHIELDS  false\n\n#define NUM_LIVES            3\n#define SCORE_EXTRA_LIFE  1500  //just once\n\n#if NUM_ENEMIES > 128\n#error please_dont_have_more_than_128_enemies__thank_you;\n#endif\n\n#if NUM_ENEMY_COLS > 16\n#error please_dont_have_more_than_16_columns_of_enemies__thank_you;\n#endif\n\n\n#define START_LEVEL   0  //levels cycle from 0..8\n\n#define NUM_LEVELS    9\n\nint get_level_start_row( int lev ) {\n    if( lev == 0 ) return( 7- 7 ) ;\n    if( lev == 1 ) return( 7- 4 ) ;\n    if( lev == 2 ) return( 7- 2 ) ;\n    if( lev == 3 ) return( 7- 1 ) ;\n    if( lev == 4 ) return( 7- 1 ) ;\n    if( lev == 5 ) return( 7- 1 ) ;\n    if( lev == 6 ) return( 7- 0 ) ;\n    if( lev == 7 ) return( 7- 0 ) ;\n    if( lev == 8 ) return( 7- 0 ) ;\n}\n\n#define GUN_SPEED           1   //pix/move period\n#define GUN_MOVE_PERIOD     1   //move every frame\n#define GUN_MIN_X          16\n#define GUN_MAX_X       ( - 4 + SHIELD_X + (NUM_SHIELDS - 1) * SHIELD_DX + SHIELD_W )\n#define GUN_Y              32\n\n#define BULLET_SPEED        4  //pix/move period\n#define BULLET_MOVE_PERIOD  1  //move every frame\n#define BULLET_MAX_Y        (scr_dim.y - 40)\n\n//wait (don't show gun) after lost life in frames\n#define GUN_NEXT_LIFE_T   60\n#define GUN_START_T      128\n\n//explosion lengths in frames\n#define GUN_EXP_T         48\n#define BULLET_EXP_T      16\n#define ENEMY_EXP_T       16\n#define ENEMY_BULL_EXP_T   8\n#define MOTHERSHIP_EXP_T  96\n\n#define FLEET_X    26\n#define FLEET_Y   120\n#define FLEET_DX   16\n#define FLEET_DY   16\n\n#define FLEET_SPEED        2\n#define FLEET_DESC         8\n#define FLEET_MOVE_PERIOD  1\n\n#define MOTHERSHIP_LX            0\n#define MOTHERSHIP_RX            (scr_dim.x - mothership_dim.x)\n#define MOTHERSHIP_Y             (scr_dim.y - 48)\n#define MOTHERSHIP_SPEED         2     //pix/move_period\n#define MOTHERSHIP_MOVE_PERIOD   3     //move only every n-th frame\n#define MOTHERSHIP_FIRST_PERIOD  35*60 //frames (=35s if stable 60fps)\n#define MOTHERSHIP_PERIOD        25*60\n#define MOTHERSHIP_MIN_EN_NUM    8     //will not show if less enemies are on screen\n\n#define GET_KEY(key)         texelFetch(iChannel3, ivec2((key),0), 0).x\n#define UPDATE_KEY(key,bit)  put_flag((state.z),(bit),GET_KEY(key))\n//#define KEY_PRESSED(key)    ( texelFetch(iChannel3, ivec2((key),1), 0).x > .5 )\n#define KEY_PRESSED(key,bit) (GET_KEY(key)>.5 && ! flag((state.z),(bit)))\n\nfloat rand_seed = 0. ;\n\n//integer rand [low,high>\nint rand( int low, int high ) {\n    float value = float( high - low ) * hash11( rand_seed ) ;\n    rand_seed = value + .5 ;\n    return( low + int( floor( value ) ) ) ;\n}\n\nint random_en_bull_type( ivec2 iu ) {\n\treturn(   ( rand( 0, EN_BULL_MOVE_PERIOD )<<4)    //movement phase\n            //+ ( rand( 0, 4 )<<2)    //animation phase, always 0\n            +   rand( 0, 3 ) ) ;    //type\n}\n\nivec4 random_en_bull_at_pos( ivec2 pos, ivec2 iu ) {\n    return( ivec4( pos, 0, random_en_bull_type( iu ) ) ) ;\n}\n\nvoid initialize_level( int level, inout vec4 o, ivec2 iu ) {\n\n    level = max( 0, level ) ;\n    level %= NUM_LEVELS ;\n\n    if( ! bool( NO_SHIELDS ) && level < 7 && iINSIDE( iu, shields_area_bl, shields_area_tr ) ) {\n\n        for( int i = 0 ; i < NUM_SHIELDS ; ++ i ) {\n            o += draw_shield( ivec2( SHIELD_X + i * SHIELD_DX, SHIELD_Y ), iu ) ;\n        }\n\n    } else if( iINSIDE( iu, adr_bl_enemies, adr_tr_enemies ) ) {\n\n        iu -= adr_bl_enemies ;\n        int r = iu.y,\n            c = iu.x % NUM_ENEMY_COLS ;\n        o = vec4( FLEET_X + c * FLEET_DX, FLEET_Y + r * FLEET_DY - get_level_start_row( level ) * FLEET_DESC, 0, 2 ) ;\n        //enemy.w == 2 -> fleet entering (ships appear one by one)\n\n    } else if( iINSIDE( iu, adr_bl_en_bull, adr_tr_en_bull ) ) {\n\n        iu -= adr_bl_en_bull ;\n        ivec4 enemy_bullet = random_en_bull_at_pos( ivec2( -100 ), iu ) ;\n        enemy_bullet.z = - rand( 60, 180 ) ; //wait for first bullets\n        o = vec4( enemy_bullet ) ;\n\n    }\n}\n\nvoid add_mothership_score( inout ivec4 iscore ) {\n    \n    #define FIRST_FOR_300   23\n    #define PERIOD_FOR_300  15\n    \n    int bullet_count = iscore.w - FIRST_FOR_300,\n        sc = bullet_count >= 0 && bullet_count % PERIOD_FOR_300 == 0 ?\n                 300\n               : 50 + 50 * rand( 0, 3 ) ;\n    iscore.x += sc ;\n    iscore.z = sc | (iscore.z & ~0x1ff) ; //keep it in bottom 9 bits for renderer\n}\n\nbool kissing_shields( ivec4 enemy_bullet ) {\n\n    int slx = SHIELD_X ;\n    for( int i = 0 ; i < NUM_SHIELDS ; ++ i ) {\n        if( enemy_bullet.x == slx - 2\n           || enemy_bullet.x == slx + SHIELD_W - 1 ) {\n            return( true ) ;\n        }\n        slx += SHIELD_DX ;\n    }\n    return( false ) ;\n}\n\n//forward declaration\nvec4 prepare_character( int n, ivec2 pos, ivec2 iu ) ;\n\nvoid mainImage( out vec4 o, vec2 u ) {\n\n    ivec2 iu = ivec2( u ) ;\n\n    //discard if we are outside of data, shields and gfx\n    if(   ! iINSIDE( iu, shields_area_bl, shields_area_tr )\n       && ! iINSIDE( iu, ivec2( 0 ), data_dim )\n#if FONT_IN_TEXTURE == 1\n       && ! ( iFrame < 2 && iINSIDE( iu, font_gfx_bl, font_gfx_tr ) )\n#endif\n      ) {\n        discard ;\n    } else\n    {\n\n#if FD > 1\n    //skip frames\n    if( iFrame % FD != 0 ) {\n        //copy data from front buffer of Buffer A\n        o = texelFetch( iChannel0, iu, 0 ) ;\n        return ;\n    }\n#endif\n\n    rand_seed = fract( sin( u.x ) + iTime + iTimeDelta + iDate.w ) ;\n\n    ivec4 state,\n          gun,\n          bullet,\n          next_enemy,\n          mothership,\n          score,\n          helper ;\n\n    state = LOADI( adr_state ) ;\n\n    if( iFrame < 2 || KEY_PRESSED( KEY_RESTART, STATE_FLAG_KEY_RESTART ) ) {\n\n        o = vec4( 0 ) ;\n        \n        if( iFrame < 2 ) {\n            //first start\n            score = ivec4( 0 ) ; //xy = (score,hiscore), z = enemies killed | mothership points, w = bullets fired\n        } else {\n            //restart (new game)\n            //keep the hiscore (score.y), reset other things\n            score = LOADI( adr_score ) ;\n            score.y = max( score.x, score.y ) ; //set hiscore (if 1 was pressed during play)\n            score.xzw = ivec3( 0 ) ; //reset\n        }\n        \n        state =       ivec4( STATE_PLAYING, START_LEVEL, STATE_FLAG_EN_APPEARING, 0 ) ; //x = state, y = level, z = flags, w = wait time\n        gun =         ivec4( GUN_MIN_X, GUN_Y, NUM_LIVES, - GUN_START_T ) ; //xy, lives, explosion, wait\n        bullet =      ivec4( -999 ) ;\n        next_enemy =  ivec4( 2, 0, 0, 0 ) ; //xy = delta, z = ind of next to move\n        mothership =  ivec4( -100, MOTHERSHIP_Y, 0, MOTHERSHIP_FIRST_PERIOD ) ;\n        helper =      ivec4( 77 ) ;\n\n        initialize_level( state.y, o, iu ) ;\n        \n#if FONT_IN_TEXTURE == 1\n\n        if( iINSIDE( iu, ivec2( 0, 128 ), ivec2( 5 * NUM_FONT_CHARS, 128 + 7 ) ) ) {\n            int ch = iu.x / 5 ;\n            o = prepare_character( ch + 1, ivec2( 0, 128 ) + ivec2( ch * 5, 0 ), iu ) ;\n        }\n#endif\n\n    } /*else if( iINSIDE( iu, prev_data_off, prev_data_off + data_dim ) ) {\n        \n        //keep data from previous frame\n        o = texelFetch( iChannel0, iu - prev_data_off, 0 ) ;\n\n    }*/ else {\n\n        //preload vars\n        //state =      LOADI( adr_state ) ; already loaded !\n        gun =        LOADI( adr_gun ) ;\n        bullet =     LOADI( adr_bullet ) ;\n        next_enemy = LOADI( adr_next_enemy ) ;\n        mothership = LOADI( adr_mothership ) ;\n        score =      LOADI( adr_score ) ;\n        helper =     LOADI( adr_helper ) ;\n\n        if( ( state.x == STATE_PLAYING ) && KEY_PRESSED( KEY_PAUSE, STATE_FLAG_KEY_PAUSE ) ) {\n            toggle_flag( state.z, STATE_FLAG_PAUSED ) ;\n        }\n\n        if( flag( state.z, STATE_FLAG_PAUSED ) ) {\n\n            o = vec4( texelFetch( iChannel0, iu, 0 ) ) ;\n\n        } else if( state.x == STATE_GAME_OVER ) {\n            \n            o = vec4( texelFetch( iChannel0, iu, 0 ) ) ;\n\n            if( flag( state.z, STATE_FLAG_GAME_OVER_ANIM ) ) {\n                if( ((iFrame/FD) & 0x7) == 0 ) {\n                    state.w ++ ;\n                    if( state.w >= 9 ) { //number of \"game over\" letters\n                        state.w = 20 ;\n                        clear_flag( state.z, STATE_FLAG_GAME_OVER_ANIM ) ;\n                    }\n                }\n            } else {\n                if( ((iFrame/FD) & 0xf) == 0 ) {\n                    state.w = - state.w ;\n                }\n            }\n\n            score.y = max( score.x, score.y ) ; //set hiscore\n\n        } else if( state.x == STATE_LEVEL_COMPLETE ) {\n\n            if( iINSIDE( iu, shields_area_bl, shields_area_tr ) ) {\n                o = vec4( 0, 0, 0, 1 ) ;\n            } else {\n                o = vec4( texelFetch( iChannel0, iu, 0 ) ) ;\n            }\n            \n            gun.w = - GUN_START_T ; //hack to hide gun during wait\n\n            if( state.w > 0 ) { //wait\n                state.w -- ;\n                if( state.w <= 0 ) {\n                    //next level\n                    state.xy = ivec2( STATE_PLAYING, (1 + state.y) % NUM_LEVELS ) ; //x = state, y = level, z = flags, w = wait time\n                    state.z &= STATE_FLAG_EXTRA_LIFE ;   //keep flag for already given extra life\n                    state.z |= STATE_FLAG_EN_APPEARING ; //new level, new appearance\n                    state.w = 0 ;\n\n                    gun =         ivec4( GUN_MIN_X, GUN_Y, gun.z, - GUN_START_T ) ; //xy, lives, explosion, wait\n                    bullet =      ivec4( -999 ) ;\n                    next_enemy =  ivec4( 2, 0, 0, 0 ) ; //xy = delta, z = ind of next to move\n                    mothership =  ivec4( -100, MOTHERSHIP_Y, 0, MOTHERSHIP_FIRST_PERIOD ) ;\n\n                    score.zw = ivec2( 0 ) ; //reset enemies killed, mothership points, bullets fired\n\n                    initialize_level( state.y, o, iu ) ;\n                }\n            }\n\n        } else if( state.x == STATE_PLAYING ) {\n\n            //let's first deal with most numerous fragments\n            if( iINSIDE( iu, shields_area_bl, shields_area_tr ) ) {\n\n                o = texelFetch( iChannel0, iu, 0 ) ;\n\n                if( bullet.z > 1 ) { //TODO\n                    //o += draw_bullet_explosion( 0, bullet.xy + bull_exp_off, iu ) ;\n                } else if( bullet.z > 0 ) {\n                    o -= draw_bullet_explosion( 0, bullet.xy + bull_exp_off, iu ) ;\n                }\n\n                for( int i = 0 ; i < MAX_EN_BULLETS ; ++ i ) {\n                    ivec4 enemy_bullet = LOADI( adr_bl_en_bull + ivec2( i, 0 ) ) ;\n                    if( enemy_bullet.z > 1 ) {\n                        //o += draw_bullet_explosion( 1, enemy_bullet.xy + en_bull_exp_off, iu ) ;\n                    } else if( enemy_bullet.z > 0 ) {\n                        o -= draw_bullet_explosion( 1, enemy_bullet.xy + en_bull_exp_off, iu ) ;\n                    } else if( enemy_bullet.z == 0 ) {\n                        int t = en_bull_type( enemy_bullet ),\n                            f = en_bull_frame( enemy_bullet ) ;\n                        /*if( enemy_bullet.x > 0 )*/ {\n                            if( ! kissing_shields( enemy_bullet ) ) {\n                                o -= draw_enemy_bullet( t, (f+3)&0x3, enemy_bullet.xy + ivec2( 0, ENEMY_BULL_SPEED-1 ), iu ) ;\n                            }\n                        }\n                    }\n                }\n\n                //TODO better fit clear rectangle\n                //clear (16,8) rectangle at each enemy pos (2 pixels from both sides)\n                for( int r = 0 ; r < NUM_ENEMY_ROWS ; ++ r ) {\n                    for( int c = 0 ; c < NUM_ENEMY_COLS ; ++ c ) {\n                        ivec4 ie =  LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                        if( ie.w > 0\n                           && iINSIDE( iu, ie.xy - ivec2( 2, 0 ), ie.xy + ivec2( 12 + 2, 8 ) ) ) {\n                            o = vec4( 0, 0, 0, 1 ) ;\n                        }\n                    }\n                }\n\n                o = clamp( o, 0., 1. ) ; //store shields area\n\n            } else if( iu == adr_gun || iu == adr_state ) {\n\n                if( gun.w < 0 ) { //wait and don't show\n                    gun.w ++ ;\n                    if( gun.w >= 0 ) {\n                        gun.w = 0 ;\n                        gun.x = GUN_MIN_X ;\n                        if( gun.z == 0 ) {\n                            state.w = 1 ; //letter of GAME OVER to show\n                            set_flag( state.z, STATE_FLAG_GAME_OVER_ANIM ) ;\n                            state.x = STATE_GAME_OVER ;\n                        }\n                        clear_flag( state.z, STATE_FLAG_EN_APPEARING ) ;\n                    }\n                } else if( gun.w > 0 ) { //gun in explosion\n                    gun.w -- ;\n                    if( gun.w <= 0 ) {\n                        if( flag( state.z, STATE_FLAG_EN_LANDED ) ) {\n                            gun.z = 0 ; //clear lives\n                        } else {\n                            gun.z -- ; //lives\n                        }\n                        gun.w = - GUN_NEXT_LIFE_T ; //wait after explosion\n                    }\n                } else {\n                    //collide\n                    for( int i = 0 ; i < MAX_EN_BULLETS ; ++ i ) {\n                        ivec4 enemy_bullet = LOADI( adr_bl_en_bull + ivec2( i, 0 ) ) ;\n                        if( enemy_bullet.z == 0 ) {\n                            if( ! bool( GOD_MODE )\n                               && iRECTS_COLLIDE( ivec4( enemy_bullet.xy, ivec2( en_bull_dim.x, ENEMY_BULL_H ) ),\n                                                  ivec4( gun.xy + ivec2(2,0), 13, 5 ) ) ) {\n                                gun.w = GUN_EXP_T ; //show explosion for n frames\n                                break ;\n                            }\n                        }\n                    }\n                    //move\n                    if( gun.w == 0 && (iFrame/FD) % GUN_MOVE_PERIOD == 0 ) {\n                        gun.x += GUN_SPEED * int( GET_KEY( KEY_RIGHT ) - GET_KEY( KEY_LEFT ) ) ;\n                        gun.x = clamp( gun.x, GUN_MIN_X, GUN_MAX_X ) ;\n                    }\n                }\n\n                if( ! flag( state.z, STATE_FLAG_EXTRA_LIFE ) && score.x >= SCORE_EXTRA_LIFE ) {\n                    gun.z ++ ;\n                    set_flag( state.z, STATE_FLAG_EXTRA_LIFE ) ;\n                }\n\n                if( gun.w != 0 && ! flag( state.z, STATE_FLAG_EN_APPEARING ) ) {\n                    set_flag( state.z, STATE_FLAG_DONT_MOVE_EN ) ;\n                } else {\n                    //find if any enemy is exploding\n                    clear_flag( state.z, STATE_FLAG_DONT_MOVE_EN ) ;\n                    for( int r = 0 ; r < NUM_ENEMY_ROWS ; ++ r ) {\n                        for( int c = 0 ; c < NUM_ENEMY_COLS ; ++ c ) {\n                            ivec4 enemy = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                            if( enemy.w > -999 && enemy.w < 0 ) {\n                                set_flag( state.z, STATE_FLAG_DONT_MOVE_EN ) ;\n                            }\n                            if( enemy.w > 0 && enemy.y <= gun.y ) {\n                                //some enemy descended to the bottom, end game after explosion\n                                gun.w = GUN_EXP_T ;\n                                set_flag( state.z, STATE_FLAG_EN_LANDED ) ;\n                                break ;\n                            }\n                        }\n                    }\n                    //did we kill all enemies?\n                    if( state.x == STATE_PLAYING && (score.z>>9) == NUM_ENEMIES ) {\n                        //are any enemy bullet still active?\n                        bool active_bullet = false ;\n                        for( int i = 0 ; i < MAX_EN_BULLETS ; ++ i ) {\n                            ivec4 eb = LOADI( adr_bl_en_bull + ivec2( i, 0 ) ) ;\n                            if( eb.z >= 0 ) { //enemy bullet is flying or exploding\n                                active_bullet = true ;\n                                break ;\n                            }\n                        }\n                        if( ! active_bullet && ! flag( state.z, STATE_FLAG_DONT_MOVE_EN ) ) {\n                            state.w = NEXT_LEVEL_T ;\n                            state.x = STATE_LEVEL_COMPLETE ;\n                        }\n                    }                    \n                }\n\n                //o = gun ;\n                //o = state\n\n            } else if( iu == adr_next_enemy ) {\n\n                int old_next_enemy = next_enemy.z, //z = ind of enemy to move\n                    new_next_enemy = - 1,\n                    descend        = next_enemy.y,\n                    direction      = next_enemy.x ;\n\n                ivec4 e ;\n                int i, r, c ;\n\n                if( flag( state.z, STATE_FLAG_DONT_MOVE_EN ) ) {\n                    //don't search for the next enemy if some is exploding\n                    new_next_enemy = old_next_enemy ;\n\n                } else {\n\n                    for( i = old_next_enemy + 1 ; i < NUM_ENEMIES ; ++ i ) {\n                        e = LOADI( adr_bl_enemies + ivec2( i % NUM_ENEMY_COLS, i / NUM_ENEMY_COLS ) ) ;\n                        if( e.w > 0 ) {\n                            new_next_enemy = i ;\n                            break ;\n                        }\n                    }\n\n                    if( new_next_enemy == -1 ) { //new cycle of movement, set the descend!\n                        bool work = true ;\n                        if( direction > 0 ) {\n                            if( descend == 0 ) {\n                                for( c = NUM_ENEMY_COLS - 1 ; work && c >= 0 ; -- c ) {\n                                    for( r = 0 ; r < NUM_ENEMY_ROWS ; ++ r ) {\n                                        e = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                                        if( e.w > 0 && ( e.x >= scr_dim.x - 22 ) ) {\n                                            descend = - FLEET_DESC ;\n                                            direction = - direction ;\n                                            work = false ;\n                                            break ;\n                                        }\n                                    }\n                                }\n                            } else {\n                                descend = 0 ;\n                            }\n                        } else {\n                            if( descend == 0 ) {\n                                for( c = 0 ; work && c < NUM_ENEMY_COLS ; ++ c ) {\n                                    for( r = 0 ; r < NUM_ENEMY_ROWS ; ++ r ) {\n                                        e = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                                        if( e.w > 0 && ( e.x <= 8 ) ) {\n                                            descend = - FLEET_DESC ;\n                                            direction = - direction ;\n                                            work = false ;\n                                            break ;\n                                        }\n                                    }\n                                }\n                            } else {\n                                descend = 0 ;\n                            }\n                        }\n\n                        for( i = 0 ; i <= old_next_enemy ; ++ i ) {\n                            e = LOADI( adr_bl_enemies + ivec2( i % NUM_ENEMY_COLS, i / NUM_ENEMY_COLS ) ) ;\n                            if( e.w > 0 ) {\n                                new_next_enemy = i ;\n                                break ;\n                            }\n                        }\n                    }\n                }\n                \n                next_enemy = ivec4( direction, descend, new_next_enemy, 0 ) ;\n\n                //o = next_enemy ;\n\n            } else if( iINSIDE( iu, adr_bl_enemies, adr_tr_enemies ) ) {\n\n                ivec4 enemy = LOADI( iu ) ;\n\n                int row = iu.y - adr_bl_enemies.y,\n                    ind = iu.x - adr_bl_enemies.x + row * NUM_ENEMY_COLS ;\n\n                if( enemy.w > 1 ) { //enemy appearing\n                \n                    if( ind == next_enemy.z ) {\n                        enemy.w = 1 ;\n                    }\n\n                } else if( enemy.w > 0 ) { //enemy active\n\n                    int type = row >> 1,\n                        frame = ( enemy.x & 2 ) >> 1 ;\n                    if( pix_coll_bullet_enemy( bullet.xy, type, frame, enemy.xy ) ) {\n                        //collision with our bullet\n                        enemy.w = - ENEMY_EXP_T ;\n                    }\n\n                    //don't move if any enemy is exploding, or if gun is lost etc.\n                    if( ! flag( state.z, STATE_FLAG_DONT_MOVE_EN ) && ind == next_enemy.z ) {\n                        if( (iFrame/FD) % ENEMY_MOVE_PERIOD == 0 ) {\n                            if( NUM_ENEMIES - (score.z>>9) == 1 ) {\n                                //move the last enemy faster to the right\n                                if( next_enemy.x > 0 ) next_enemy.x = 3 ;\n                            }\n                            enemy.xy += next_enemy.xy ;\n                        }\n                    }\n                } else {\n                    //enemy.w < 0\n                    if( enemy.w > -999 ) { //in explosion if w > -999 && w < 0\n                        enemy.w ++ ;\n                        if( enemy.w >= -2 ) { //not sure why I stop explosion at -2\n                            enemy = ivec4( -999 ) ;\n                        }\n                    }\n                }\n\n                o = vec4( enemy ) ; //store\n\n            } else if( iu == adr_mothership ) {\n\n                if( mothership.w > 0 ) { //waiting\n                    mothership.w -- ;\n                    if( mothership.w <= 0 ) {\n                        if( NUM_ENEMIES - (score.z>>9) >= MOTHERSHIP_MIN_EN_NUM ) {\n                            mothership = rand( 0, 2 ) < 1 ?\n                                ivec4( MOTHERSHIP_LX, MOTHERSHIP_Y, 1, 0 )\n                                : ivec4( MOTHERSHIP_RX, MOTHERSHIP_Y, -1, 0 ) ;\n                        } else {\n                            //too few enemies are left\n                            //hack to wait indefinitely (almost)\n                            mothership.w = 10000 * MOTHERSHIP_PERIOD ;\n                        }\n                    }\n                } else if( mothership.w < 0 ) { //exploding\n                    mothership.w ++ ;\n                    if( mothership.w >= 0 ) {\n                        mothership = ivec4( -100, MOTHERSHIP_Y, 0, MOTHERSHIP_PERIOD ) ;\n                    }   \n                } else {\n                    if( iRECTS_COLLIDE( ivec4( bullet.xy, 1, BULLET_H ), ivec4( mothership.xy, mothership_dim ) ) ) {\n                        //collision with our bullet\n                        mothership.w = - MOTHERSHIP_EXP_T ;\n                    } else {\n                        if( (iFrame/FD) % MOTHERSHIP_MOVE_PERIOD == 0 ) { //move only every n-th frame\n                            mothership.x += sign( mothership.z ) * MOTHERSHIP_SPEED ;\n                            if( mothership.x != clamp( mothership.x, MOTHERSHIP_LX, MOTHERSHIP_RX ) ) {\n                                mothership = ivec4( -999, MOTHERSHIP_Y, 0, MOTHERSHIP_PERIOD ) ;\n                            }\n                        }\n                    }\n                }\n\n                //o = mothership ;\n\n            } else if( iu == adr_score || iu == adr_bullet ) {\n\n                //TODO! CLEAN UP THIS SHIT!\n                if( bullet.z < 0 && bullet.z > -999 ) { //waiting without bullet explosion\n                    bullet.z ++ ;\n                    if( bullet.z >= 0 ) {\n                        bullet = ivec4( -999 ) ;\n                    }\n                } else if( bullet.z > 0 ) { //waiting showing explosion\n                    bullet.z -- ;\n                    if( bullet.z <= 0 ) {\n                        bullet = ivec4( -999 ) ;\n                    }\n                } else {\n                    if( bullet.y >= BULLET_MAX_Y ) { //top of the screen\n                        //collision with the top\n                        bullet.z = BULLET_EXP_T ; //wait and show bullet explosion\n\n                    } else if( iINSIDE( bullet.y, SHIELD_Y, SHIELD_Y + SHIELD_H ) ) { //bullet.y == clamp( bullet.y, SHIELD_Y, SHIELD_Y+SHIELD_H-1 ) ) {\n                        for( int i = 0 ; i < BULLET_H ; ++ i ) {\n                            vec4 c = texelFetch( iChannel0, bullet.xy + ivec2(0,i), 0 ) ;\n                            if( c.r >= 1. ) {\n                                //collision with a shield (or with an explosion on the shield)\n                                bullet.z = BULLET_EXP_T ; //wait and show bullet explosion\n                                break ;\n                            }\n                        }\n                    }\n                }\n\n                bool in_explosion = bullet.z != -999 ;\n\n                if( ! in_explosion ) {\n\n                    if( bullet.w >= 0 ) {\n                        bool work = true ;\n                        for( int r = 0 ; work && r < NUM_ENEMY_ROWS ; ++ r ) {\n                            for( int c = 0 ; c < NUM_ENEMY_COLS ; ++ c ) {\n                                ivec4 enemy = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                                if( enemy.w > -999 ) { //if enemy is still visible\n                                    if( pix_coll_bullet_enemy( bullet.xy, r>>1, (enemy.x&2)>>1, enemy.xy ) ) {\n                                        //collision with enemy\n                                        score.x += 10 * ( (r>>1) + 1 ) ;\n                                        score.z += 512 ; //count killed enemies (z above 9 bits)\n                                        bullet.z = - ENEMY_EXP_T ; //just wait together with enemy (don't show bullet explosion)\n                                        bullet.w = - 1 ; //block visibility\n                                        work = false ;\n                                        break ;\n                                    }\n                                }\n                            }\n                        }\n                        if( bullet.y + BULLET_H >= MOTHERSHIP_Y ) {\n                            if( iRECTS_COLLIDE( ivec4( bullet.xy, 1, BULLET_H ), ivec4( mothership.xy, mothership_dim ) ) ) {\n                                //collision with mothership\n                                add_mothership_score( score ) ;\n                                bullet.z = - BULLET_EXP_T ; //just wait (don't show bullet explosion)\n                                bullet.w = - 1 ; //block visibility\n                            }\n                        } else {\n                            for( int i = 0 ; i < MAX_EN_BULLETS ; ++ i ) {\n                                ivec4 eb = LOADI( adr_bl_en_bull + ivec2( i, 0 ) ) ;\n                                int t = en_bull_type( eb ),\n                                    f = en_bull_frame( eb ) ;\n                                if( iRECTS_COLLIDE( ivec4( bullet.xy, 1, BULLET_H ),\n                                                    ivec4( eb.xy, 3, ENEMY_BULL_H ) ) ) {\n                                    //collision with enemy bullet\n                                    bullet.z = BULLET_EXP_T ; //wait and show bullet explosion\n                                    bullet.w = - 1 ; //block visibility\n                                    break ;\n                                }\n                            }\n                        }\n                    } else {\n                        bullet = ivec4( -999 ) ;\n                    }\n\n                    if( bullet.w > 0 ) {\n                        if( (iFrame/FD) % BULLET_MOVE_PERIOD == 0 ) {\n                            bullet.y += BULLET_SPEED ;\n                        }\n                    } else if( bullet.z == -999\n                              && gun.w == 0\n                              && ( KEY_PRESSED( KEY_FIRE, STATE_FLAG_KEY_FIRE )\n                                  || KEY_PRESSED( KEY_ALT_FIRE, STATE_FLAG_KEY_ALT_FIRE ) ) ) {\n                        bullet = ivec4( gun.xy, 0, 0 ) + ivec4( gun_bull_off, -999, 1 ) ;\n                        score.w ++ ; //count bullets (for extra points for mothership ;)\n                    }\n                }\n\n                //o = bullet ;\n                //o = score ;\n\n            } else if( iINSIDE( iu, adr_bl_en_bull, adr_tr_en_bull ) ) {\n\n                ivec4 enemy_bullet = LOADI( iu ) ;\n                int eb_ind = iu.x - adr_bl_en_bull.x ;\n\n                if( enemy_bullet.z < 0 ) { //wait\n                    enemy_bullet.z ++ ;\n                    if( enemy_bullet.z >= 0 ) {\n                        if( (iFrame/FD) % MAX_EN_BULLETS != iu.x % MAX_EN_BULLETS ) {\n                             //hack for 1 bullet per frame (back to wait)\n                            enemy_bullet.z = -1 ;\n                        } else {\n                            if( gun.w == 0 ) { //gun active and not in explosion \n                                //create a new random bullet\n                                ivec4 lowest_enemies = ivec4( 0 ) ;\n                                int num_active = 0 ;\n                                //traverse enemies by columns from bottom to top and\n                                //pack indexes of all active lowest enemies\n                                for( int c = 0 ; c < NUM_ENEMY_COLS ; ++ c ) {\n                                    for( int r = 0 ; r < NUM_ENEMY_ROWS ; ++ r ) {\n                                        ivec4 e = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                                        if( e.w > 0 ) {\n                                            int component = num_active >> 2,\n                                                shift = ( num_active & 0x3 ) << 3 ;\n                                            lowest_enemies[component] |= ( r * NUM_ENEMY_COLS + c ) << shift ;\n                                            num_active ++ ;\n                                            break ;\n                                        }\n                                    }\n                                }\n                                //choose one of them randomly\n                                int rand_lowest_en = rand( 0,num_active ),\n                                    component = rand_lowest_en >> 2,\n                                    shift = ( rand_lowest_en & 0x3 ) << 3,\n                                    mask = 0x7f << shift,\n                                    enemy_ind = ( lowest_enemies[component] & mask ) >> shift,\n                                    r = enemy_ind / NUM_ENEMY_COLS,\n                                    c = enemy_ind % NUM_ENEMY_COLS ;\n                                //load it (again)\n                                ivec4 e = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n                                ivec2 new_eb_pos = e.xy + en_en_bull_off ;\n                                //check if any other bullet has the same x coord\n                                bool proceed_creating = true ;\n                                for( int i = 0 ; i < MAX_EN_BULLETS ; ++ i ) {\n                                    ivec4 eb2 = LOADI( adr_bl_en_bull + ivec2( i, 0 ) ) ;\n                                    if( enemy_bullet != eb2 && eb2.z == 0 && new_eb_pos.x == eb2.x ) {\n                                        //hack, wait more if any active bullet is in same hor pos\n                                        //this works because two bullets are never created in\n                                        //a single frame because of the hack before this\n                                        enemy_bullet.z = -1 ;\n                                        proceed_creating = false ;\n                                    }\n                                }\n                                if( proceed_creating ) {\n                                    //and create a bullet at enemy's position\n                                    enemy_bullet = random_en_bull_at_pos( new_eb_pos, iu ) ;\n                                    //keep the col and row to know which rows to collide\n                                    //for enemy explosions\n                                    enemy_bullet.w &= ~ 0xffff00 ; //clear\n                                    enemy_bullet.w |= ( (c<<8) | r ) << 8 ; //pack and store\n                                    //check if some is exploding right below\n                                    if( r > 0 ) {\n                                        e = LOADI( adr_bl_enemies + ivec2( c, r - 1 ) ) ;\n                                        if( e.w > -999 && e.w < -2 ) { //enemy in explosion\n                                            //destroy bullet immediately\n                                            enemy_bullet.z = ENEMY_BULL_EXP_T ;\n                                        }\n                                    }\n                                }\n                            } else {\n                                enemy_bullet.z = - rand( 100, 200 ) ; //wait after new gun is deployed\n                            }\n                        }\n                    }\n                } else if( enemy_bullet.z > 0 ) { //if in explosion\n                    enemy_bullet.z -- ;\n                    if( enemy_bullet.z <= 0 ) { //if explosion ended\n                        enemy_bullet.x = -999 ; //remove from screen\n                        enemy_bullet.z = - rand( 5, 100 ) ; //wait before new bullet\n                    }\n                } else if( enemy_bullet.z == 0 ) {\n\n                    if( iINSIDE( enemy_bullet.xy, shields_area_bl, shields_area_tr ) ) {\n                        if( kissing_shields( enemy_bullet )\n                           && enemy_bullet.y == clamp( enemy_bullet.y, SHIELD_Y - 1, SHIELD_Y + 4 ) ) {\n                            vec4 c1 = texelFetch( iChannel0, enemy_bullet.xy + ivec2( 2, 3 ), 0 ),\n                                 c2 = texelFetch( iChannel0, enemy_bullet.xy + ivec2( 0, 0 ), 0 ) ;\n                            if( c1.r > .5 || c2.r > .5 ) {\n                                //ongoing collision on the edge of the shields\n                                //destroy near the bottom\n                                enemy_bullet.z = ENEMY_BULL_EXP_T ;\n                            }\n                        } else {\n                            for( int i = 0 ; i < ENEMY_BULL_H ; ++ i ) {\n                                vec4 c = texelFetch( iChannel0, enemy_bullet.xy + ivec2(1,i), 0 ) ;\n                                if( c.r > .5 ) {\n                                    //collision with some shield (or with explosion on the shield)\n                                    enemy_bullet.z = ENEMY_BULL_EXP_T ; //show explosion\n                                    break ;\n                                }\n                            }\n                        }\n                    }\n\n                    //int t = en_bull_type( enemy_bullet ),\n                    //    f = en_bull_frame( enemy_bullet ) ;\n                    //if( pix_coll_bullet_enemy_bullet( bullet.xy, t, f, enemy_bullet.xy ) ) {\n                    if(   bullet.z <= 0 && bullet.w > 0\n                       && iRECTS_COLLIDE( ivec4( bullet.xy, 1, BULLET_H ),\n                                          ivec4( enemy_bullet.xy+ivec2(1,0), 1, ENEMY_BULL_H ) ) ) {\n                        //collision with our bullet\n                        enemy_bullet.z = ENEMY_BULL_EXP_T + 2 ;\n\n                    } else if( enemy_bullet.y <= BOTTOM_LINE + 3 ) { //hack\n                        //collision with bottom\n                        enemy_bullet.z = ENEMY_BULL_EXP_T ;\n\n                    } else if( iRECTS_COLLIDE( ivec4( enemy_bullet.xy, ivec2( en_bull_dim.x, ENEMY_BULL_H ) ),\n                                               ivec4( gun.xy + ivec2(2,0), 13, 5 ) ) ) {\n                        //collision with gun (hack with enemy_bull_h to not collide with gun in last row)\n                        enemy_bullet.z = ENEMY_BULL_EXP_T ;\n                    } else {\n                        //TODO better search for enemy collision (around its start_col)\n                        bool work = true ;\n                        for( int c = 0 ; work && c < NUM_ENEMY_COLS ; ++ c ) {\n                            for( int r = en_bull_start_row( enemy_bullet ) ; r >= 0 ; -- r ) {\n                                ivec4 e = LOADI( adr_bl_enemies + ivec2( c, r + 1 ) ) ;\n                                if( e.w > -999 && e.w < -2 ) { //enemy in explosion\n                                    if( iRECTS_COLLIDE( ivec4( enemy_bullet.xy, ivec2( en_bull_dim.x, ENEMY_BULL_H ) ),\n                                                        ivec4( e.xy, enemy_dim ) ) ) {\n                                        //collision with enemy's explosion\n                                        enemy_bullet.z = ENEMY_BULL_EXP_T ;\n                                        work = false ;\n                                        break ;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    \n                    //move on every move_period frame by speed pixels down\n                    if( enemy_bullet.z == 0 && ( (iFrame/FD) + en_bull_move_phase( enemy_bullet ) ) % EN_BULL_MOVE_PERIOD == 0 ) {\n                        enemy_bullet.y -= ENEMY_BULL_SPEED ;\n                    }\n                }\n\n                o = vec4( enemy_bullet ) ;\n\n            } else {\n\n                discard ;\n\n            }\n        }\n    }\n    \n    if( iu == adr_state ) {\n        UPDATE_KEY( KEY_FIRE,     STATE_FLAG_KEY_FIRE ) ;\n        UPDATE_KEY( KEY_ALT_FIRE, STATE_FLAG_KEY_ALT_FIRE ) ;\n        UPDATE_KEY( KEY_PAUSE,    STATE_FLAG_KEY_PAUSE ) ;\n        UPDATE_KEY( KEY_RESTART,  STATE_FLAG_KEY_RESTART ) ;\n    }\n\n    STOREI( adr_state,      state        ) ;\n    STOREI( adr_gun,        gun          ) ;\n    STOREI( adr_bullet,     bullet       ) ;\n    STOREI( adr_next_enemy, next_enemy   ) ;\n    STOREI( adr_mothership, mothership   ) ;\n    STOREI( adr_score,      score        ) ;\n    STOREI( adr_helper,     helper       ) ;\n    }\n}\n\n#if FONT_IN_TEXTURE == 1\n\n#undef BR20\n#define BR20(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T) float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11)+(M<<12)+(N<<13)+(O<<14)+(P<<15)+(Q<<16)+(R<<17)+(S<<18)+(T<<19))\n#define _ 0\n#define w 1\n\nconst vec4 font[] = vec4[32]( //((NUM_FONT_CHARS+3)/4)*2\n    vec4( 0, //0,1,2,3\n            BR20(  _,w,w,w,_  ,  _,_,w,_,_  ,  _,w,w,w,_  ,  w,w,w,w,w  ),\n            BR20(  w,_,_,_,w  ,  _,w,w,_,_  ,  w,_,_,_,w  ,  _,_,_,_,w  ),\n            BR20(  w,_,_,w,w  ,  _,_,w,_,_  ,  _,_,_,_,w  ,  _,_,_,w,_  ) ),\n    vec4(   BR20(  w,_,w,_,w  ,  _,_,w,_,_  ,  _,_,w,w,_  ,  _,_,w,w,_  ),\n            BR20(  w,w,_,_,w  ,  _,_,w,_,_  ,  _,w,_,_,_  ,  _,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  _,_,w,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ),\n            BR20(  _,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,w  ,  _,w,w,w,_  ) ),\n    vec4( 0, //4,5,6,7\n            BR20(  _,_,_,w,_  ,  w,w,w,w,w  ,  _,_,w,w,w  ,  w,w,w,w,w  ),\n            BR20(  _,_,w,w,_  ,  w,_,_,_,_  ,  _,w,_,_,_  ,  _,_,_,_,w  ),\n            BR20(  _,w,_,w,_  ,  w,w,w,w,_  ,  w,_,_,_,_  ,  _,_,_,_,w  ) ),\n    vec4(   BR20(  w,_,_,w,_  ,  _,_,_,_,w  ,  w,w,w,w,_  ,  _,_,_,w,_  ),\n            BR20(  w,w,w,w,w  ,  _,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  _,_,_,w,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  _,_,_,w,_  ,  _,w,w,w,_  ,  _,w,w,w,_  ,  _,_,w,_,_  ) ),\n    vec4( 0, //8,9,<,>\n            BR20(  _,w,w,w,_  ,  _,w,w,w,_  ,  _,_,_,w,_  ,  _,w,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,_,_,_  ,  _,_,_,w,_  ) ),\n    vec4(   BR20(  _,w,w,w,_  ,  _,w,w,w,w  ,  w,_,_,_,_  ,  _,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  _,_,_,_,w  ,  _,w,_,_,_  ,  _,_,_,w,_  ),\n            BR20(  w,_,_,_,w  ,  _,_,_,w,_  ,  _,_,w,_,_  ,  _,_,w,_,_  ),\n            BR20(  _,w,w,w,_  ,  w,w,w,_,_  ,  _,_,_,w,_  ,  _,w,_,_,_  ) ),\n    vec4( 0, //A,B,C,D\n            BR20(  _,_,w,_,_  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,_  ),\n            BR20(  _,w,_,w,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ,  w,_,_,_,w  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,w,w,w,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ),\n            BR20(  w,w,w,w,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,_  ) ),\n    vec4( 0, //E,F,G,H\n            BR20(  w,w,w,w,w  ,  w,w,w,w,w  ,  _,w,w,w,_  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ) ),\n    vec4(   BR20(  w,w,w,w,_  ,  w,w,w,w,_  ,  w,_,_,_,_  ,  w,w,w,w,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,w,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,w,w,w,w  ,  w,_,_,_,_  ,  _,w,w,w,w  ,  w,_,_,_,w  ) ),\n    vec4( 0, //I,J,K,L\n            BR20(  _,w,w,w,_  ,  _,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,_,_,w,_  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,_,w,_,_  ,  w,_,_,_,_  ) ),\n    vec4(   BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,w,_,_,_  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,_,w,_,_  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  w,_,_,_,w  ,  w,_,_,w,_  ,  w,_,_,_,_  ),\n            BR20(  _,w,w,w,_  ,  _,w,w,w,_  ,  w,_,_,_,w  ,  w,w,w,w,w  ) ),\n    vec4( 0, //M,N,O,P\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,w,w,_  ,  w,w,w,w,_  ),\n            BR20(  w,w,_,w,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,w,_,w  ,  w,w,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,_,w,_,w  ,  w,_,_,_,w  ,  w,w,w,w,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,w,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,w,w,_  ,  w,_,_,_,_  ) ),\n    vec4( 0, //Q,R,S,T\n            BR20(  _,w,w,w,_  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ,  _,_,w,_,_  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  _,_,w,_,_  ),\n            BR20(  w,_,w,_,w  ,  w,_,w,_,_  ,  _,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,w,_  ,  w,_,_,w,_  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  _,w,w,_,w  ,  w,_,_,_,w  ,  _,w,w,w,_  ,  _,_,w,_,_  ) ),\n    vec4( 0, //U,V,W,X\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,_,w,_  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,w,_,w  ,  _,w,_,w,_  ),\n            BR20(  w,_,_,_,w  ,  _,w,_,w,_  ,  w,w,_,w,w  ,  w,_,_,_,w  ),\n            BR20(  _,w,w,w,_  ,  _,_,w,_,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ) ),\n    vec4( 0, //Y,Z,?,-\n            BR20(  w,_,_,_,w  ,  w,w,w,w,w  ,  _,w,w,w,_  ,  _,_,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  _,_,_,_,w  ,  w,_,_,_,w  ,  _,_,_,_,_  ),\n            BR20(  _,w,_,w,_  ,  _,_,_,w,_  ,  _,_,_,_,w  ,  _,_,_,_,_  ) ),\n    vec4(   BR20(  _,_,w,_,_  ,  _,_,w,_,_  ,  _,_,_,w,_  ,  w,w,w,w,w  ),\n            BR20(  _,_,w,_,_  ,  _,w,_,_,_  ,  _,_,w,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  w,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  w,w,w,w,w  ,  _,_,w,_,_  ,  _,_,_,_,_  ) ),\n    vec4( 0, // /\n            BR20(  _,_,_,w,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,_,w,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ) ),\n    vec4(   BR20(  _,_,w,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,w,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,w,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ) ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 )\n) ;\n\n#undef _\n#undef w\n\n//workaround for variable indexing\n//binary search, 32 indexes\n\nfloat get_bit_row( int p, int y ) {\n    vec4 v ;\n    v =  p<16?p<8?p<4?p<2?p<1?     font[ 0] : font[ 1]\n        :p<3?                      font[ 2] : font[ 3]\n        :p<6?p<5?                  font[ 4] : font[ 5]\n        :p<7?                      font[ 6] : font[ 7]\n        :p<12?p<10?p<9?            font[ 8] : font[ 9]\n        :p<11?                     font[10] : font[11]\n        :p<14?p<13?                font[12] : font[13]\n        :p<15?                     font[14] : font[15]\n        :p<24?p<20?p<18?p<17?      font[16] : font[17]\n        :p<19?                     font[18] : font[19]\n        :p<22?p<21?                font[20] : font[21]\n        :p<23?                     font[22] : font[23]\n        :p<28?p<26?p<25?           font[24] : font[25]\n        :p<27?                     font[26] : font[27]\n        :p<30?p<29?                font[28] : font[29]\n        :p<31?                     font[30] : font[31] ;\n\n    //return( v[y] ) ;\n    return(\n        y<2?y<1? v[0] : v[1]\n       :y<3?     v[2] : v[3]\n    ) ;\n}\n\nvec4 prepare_character( int n, ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3( 0 ) ;\n    iu -= pos ;\n    if( n > 0 && n <= NUM_FONT_CHARS && iINSIDE( iu, ivec2(0), ch_gfx_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        n -- ;\n        x += 5 * ( n & 3 ) ;\n        float fx2 = exp2(-float(x+1)) ;\n\n        n >>= 2 ;\n        int part = y < 4 ? n * 2 + 1 : n * 2 ;\n        y = 3 - (y&3) ;\n        v = vec3( fract( get_bit_row( part, y ) * fx2 ) >= .5 ) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\n#endif","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//Buffer B - render buffer, just alpha with all white pixels\n//A nearest,_,_,_\n\nconst int\n    _0=1, _1=2, _2=3, _3=4, _4=5, _5=6, _6=7, _7=8,\n    _8=9, _9=10,_l=11,_g=12,_A=13,_B=14,_C=15,_D=16,\n    _E=17,_F=18,_G=19,_H=20,_I=21,_J=22,_K=23,_L=24,\n    _M=25,_N=26,_O=27,_P=28,_Q=29,_R=30,_S=31,_T=32,\n    _U=33,_V=34,_W=35,_X=36,_Y=37,_Z=38,_q=39,_d=40,\n    _s=41,_ =63 ;\n\n// _l = \"<\"\n// _r = \">\"\n// _q = \"?\"\n// _d = \"-\"\n// _s = \"/\"\n// _  = \" \"\n\n\n#define c(x) +(x\n#define _end *64))*64)*64)*64)\n#define STR20(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T)\\\n    ivec4( c(A)c(B)c(C)c(D)c(E) _end,  c(F)c(G)c(H)c(I)c(J) _end,\\\n           c(K)c(L)c(M)c(N)c(O) _end,  c(P)c(Q)c(R)c(S)c(T) _end )\n\nconst ivec4\n    txt_fps       = STR20( _F,_P,_S, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),\n    txt_score     = STR20( _S,_C,_O,_R,_E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),\n    txt_hiscore   = STR20( _H,_I,_d,_S,_C,_O,_R,_E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),\n    txt_game_over = STR20( _G,_A,_M,_E,_ ,_O,_V,_E,_R, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),\n    txt_for_a_new = STR20( _F,_O,_R,_ ,_A,_ ,_N,_E,_W,_ ,_G,_A,_M,_E, 0, 0, 0, 0, 0, 0 ),\n    txt_press_1   = STR20( _P,_R,_E,_S,_S,_ ,_1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),\n    txt_paused    = STR20( _P,_A,_U,_S,_E,_D, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 )\n;\n\n#undef c\n#undef _end\n#undef STR20\n\nconst ivec2\n    pos_txt_fps       = ivec2(  scr_dim.x - 5*8, scr_dim.y -  8 -  8 ),\n    pos_txt_score     = ivec2(  8, scr_dim.y -  8 -  8 ),\n    pos_score         = ivec2( 24, scr_dim.y - 24 -  8 ),\n    pos_txt_hiscore   = ivec2( 80, scr_dim.y -  8 -  8 ),\n    pos_hiscore       = ivec2( 88, scr_dim.y - 24 -  8 ),\n    pos_txt_game_over = ivec2( 72, scr_dim.y -  8 - 56 ),\n    pos_txt_for_a_new = ivec2( 24+8*8, 21 ),\n    pos_txt_press_1   = ivec2( 144-15*8, 21 ),\n    pos_txt_paused    = ivec2( 88, scr_dim.y -  8 - 56 ) ;\n\n\n\n\n//forward declarations\nvec4 draw_explosion( ivec2 pos, ivec2 iu ) ;\nvec4 draw_mothership( ivec2 pos, ivec2 iu ) ;\nvec4 draw_mothership_explosion( ivec2 pos, ivec2 iu ) ;\nvec4 draw_gun( ivec2 pos, ivec2 iu ) ;\nvec4 draw_gun_explosion( int frame, ivec2 pos, ivec2 iu ) ;\nvec4 draw_character( int n, ivec2 pos, ivec2 iu ) ;\nvec4 draw_string16_ivec4( int num_ch, ivec4 s, ivec2 pos, ivec2 iu ) ;\nvec4 draw_number_04( int n, ivec2 pos, ivec2 iu ) ;\n//vec4 draw_number_0k( int k, int n, ivec2 pos, ivec2 iu ) ;\nvec4 draw_number_6( int n, ivec2 pos, ivec2 iu ) ;\n\n//time in frames to show points during mothership explosion\n#define MOTHERSHIP_PTS_T   72\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n\n#if FD > 1\n    //skip frames\n    if( iFrame % FD != 0 ) {\n        discard ;\n    }\n#endif\n\n    ivec2 iu = ivec2( u ) ;\n    \n    if( ! iINSIDE( iu, ivec2( 0 ), scr_dim ) ) discard ; else\n    {\n    o = vec4( 0 ) ;\n    \n    /*if( iINSIDE( iu, ivec2( 0 ), scr_dim ) ) {\n        o = texelFetch( iChannel0, iu, 0 ) ;\n        return ;\n    }*/\n\n    ivec4\n        gun        =   LOADI( adr_gun ),\n        bullet     =   LOADI( adr_bullet ),\n        score      =   LOADI( adr_score ),\n        mothership =   LOADI( adr_mothership ),\n        state      =   LOADI( adr_state ),\n        helper     =   LOADI( adr_helper ) ;\n\n    //current fired bullet\n    //o += draw_number_6( score.w, ivec2( scr_dim.x - 32, scr_dim.y - 32 ), iu ) ;\n    \n    /*\n    o += draw_number_6( helper.x, ivec2( scr_dim.x - 64, scr_dim.y - 16 ), iu ) ;\n    o += draw_number_6( helper.y, ivec2( scr_dim.x - 64, scr_dim.y - 24 ), iu ) ;\n    o += draw_number_6( helper.z, ivec2( scr_dim.x - 64, scr_dim.y - 32 ), iu ) ;\n    o += draw_number_6( helper.w, ivec2( scr_dim.x - 64, scr_dim.y - 40 ), iu ) ;\n    */\n\n    if( texelFetch( iChannel3, ivec2( KEY_FPS, 2 ), 0 ).x > .5 ) {\n        //fps counter in top right corner\n        o += draw_string16_ivec4( 0, txt_fps, pos_txt_fps, iu ) ;\n        o += draw_number_6( int( iFrameRate ), ivec2( scr_dim.x - 32, scr_dim.y - 32 ), iu ) ;\n        #if( FD > 1 )\n            o += draw_character( _SLASH, ivec2( scr_dim.x - 16, scr_dim.y - 32 ), iu ) ;\n            o += draw_number_6( FD, ivec2( scr_dim.x - 8, scr_dim.y - 32 ),  iu ) ;\n        #endif\n    }\n\n    o += draw_string16_ivec4( 0, txt_score, pos_txt_score, iu ) ;\n    o += draw_number_04( score.x % 10000, pos_score, iu ) ;        //cycle score\n\n    o += draw_string16_ivec4( 0, txt_hiscore, pos_txt_hiscore, iu ) ;\n    o += draw_number_04( min( score.y, 9990 ), pos_hiscore, iu ) ; //fix at 9990 if larger\n\n    //mothership\n    if( mothership.w < - MOTHERSHIP_PTS_T ) {\n        o += draw_mothership_explosion( mothership.xy, iu ) ;\n    } else if( mothership.w < 0 ) {\n        o += draw_number_6( score.z & 0x1ff, mothership.xy, iu ) ;\n    } else {\n        o += draw_mothership( mothership.xy, iu ) ;\n    }\n\n    //shields from Buffer A\n    if( iINSIDE( iu, shields_area_bl, shields_area_tr ) ) {\n        o += texelFetch( iChannel0, iu , 0 ) ;\n    }\n\n    //gun\n    if( state.x == STATE_GAME_OVER ) {\n        o += draw_string16_ivec4( state.w, txt_game_over, pos_txt_game_over, iu ) ;\n        if( ! flag( state.z, STATE_FLAG_GAME_OVER_ANIM ) ) {\n            o += draw_string16_ivec4( 0, txt_for_a_new, pos_txt_for_a_new, iu ) ;\n            o += draw_string16_ivec4( 0, txt_press_1, pos_txt_press_1, iu ) ;\n        }\n    } else {\n        if( gun.w == 0 ) {\n            o += draw_gun( gun.xy, iu ) ;\n        } else if( gun.w > 0 ) {\n            o += draw_gun_explosion( int(((iFrame/FD)%10) < 5), gun.xy, iu ) ;\n        }\n            \n        if( flag( state.z, STATE_FLAG_PAUSED ) ) {\n            o += draw_string16_ivec4( - (((iFrame/FD)>>4)&0x1), txt_paused, pos_txt_paused, iu ) ;\n        }\n    }\n\n    //our bullet\n    //o += draw_number_6( bullet.x, ivec2( scr_dim.x - 32, scr_dim.y - 32 ), iu ) ;\n    if( bullet.z == -999 ) {\n        if( bullet.w > 0 && iINSIDE( iu, bullet.xy, bullet.xy + ivec2( 1, BULLET_H ) ) ) {\n            o += vec4( 1 ) ;\n        }\n    } else {\n        if( bullet.z > 1 ) {\n            o += draw_bullet_explosion( 0, bullet.xy + bull_exp_off, iu ) ;\n        }/*else if( bullet.z > 0 ) {\n            //the shield area is in Buffer A so it is cleared there\n        }*/\n    }\n\n    //enemies\n    for( int r = 0 ; r < NUM_ENEMY_ROWS ; ++ r ) {\n        int enemy_type = r >> 1 ;\n        for( int c = 0 ; c < NUM_ENEMY_COLS ; ++ c ) {\n            ivec4 e = LOADI( adr_bl_enemies + ivec2( c, r ) ) ;\n            if( e.w == 1 ) { //1 normal, 2 active but invisible (for fleet entering...)\n                if( e.y <= gun.y ) {\n                    o += draw_enemy( 2, (e.x&2)>>1, e.xy, iu ) ;\n                } else {\n                    o += draw_enemy( enemy_type, (e.x&2)>>1, e.xy, iu ) ;\n                }\n            } else if( e.w > -999 && e.w < -2 ) {\n                o += draw_explosion( e.xy, iu ) ;\n            }\n        }\n    }\n\n    //enemy bullets\n    for( int i = 0 ; i < MAX_EN_BULLETS ; ++ i ) {\n        ivec4 eb = LOADI( adr_bl_en_bull + ivec2( i, 0 ) ) ;\n        int t = en_bull_type( eb ),\n            f = en_bull_frame( eb ) ;\n        if( eb.z == 0 ) {\n            /*if( eb.x > 0 )*/ {\n                o += draw_enemy_bullet( t, f, eb.xy, iu ) ;\n            }\n        } else {\n            if( eb.z > 1 ) {\n                o += draw_bullet_explosion( 1, eb.xy + en_bull_exp_off, iu ) ;\n            }/*else if( eb.z > 0 ) {\n                //the shield area is in Buffer A so it is cleared there\n            }*/\n        }\n    }\n\n    //bottom line\n    if( iu.y == BOTTOM_LINE ) {\n        o += vec4( 1 ) ;\n    }\n\n    //number of lives\n    //o += draw_character( _0 + gun.z, ivec2( 8, 8 ), iu ) ;\n\n    //remaining guns\n    for( int i = 0 ; i < gun.z - 1 ; ++ i ) {\n        o += draw_gun( ivec2( 26 + i * 16, 8 ), iu ) ;\n    }\n\n    o = vec4( clamp( o.rgb, 0., 1. ), o.g > 0. ) ;\n \n    o = vec4( 1, 1, 1, o.g > 0. ) ;\n    }\n}\n\n\n#define _ 0\n#define w 1\n\nvec4 draw_explosion( ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), en_exp_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        PREPARE_TEST_BIT ;\n        BR16(7,   _,_,_,_,w,_,_,_,w,_,_,_,_   ,_,_,_) ;\n        BR16(6,   _,w,_,_,_,w,_,w,_,_,_,w,_   ,_,_,_) ;\n        BR16(5,   _,_,w,_,_,_,_,_,_,_,w,_,_   ,_,_,_) ;\n        BR16(4,   _,_,_,w,_,_,_,_,_,w,_,_,_   ,_,_,_) ;\n        BR16(3,   w,w,_,_,_,_,_,_,_,_,_,w,w   ,_,_,_) ;\n        BR16(2,   _,_,_,w,_,_,_,_,_,w,_,_,_   ,_,_,_) ;\n        BR16(1,   _,_,w,_,_,w,_,w,_,_,w,_,_   ,_,_,_) ;\n        BR16(0,   _,w,_,_,w,_,_,_,w,_,_,w,_   ,_,_,_) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\n\nvec4 draw_mothership( ivec2 pos, ivec2 iu ) {\n    vec3 v ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), mothership_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        PREPARE_TEST_BIT ;\n        BR16(6,   _,_,_,_,_,w,w,w,w,w,w,_,_,_,_,_  ) ;\n        BR16(5,   _,_,_,w,w,w,w,w,w,w,w,w,w,_,_,_  ) ;\n        BR16(4,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,_,_  ) ;\n        BR16(3,   _,w,w,_,w,w,_,w,w,_,w,w,_,w,w,_  ) ;\n        BR16(2,   w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w  ) ;\n        BR16(1,   _,_,w,w,w,_,_,w,w,_,_,w,w,w,_,_  ) ;\n        BR16(0,   _,_,_,w,_,_,_,_,_,_,_,_,w,_,_,_  ) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\nvec4 draw_mothership_explosion( ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), mothership_exp_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        PREPARE_TEST_BIT ;\n        BR24(7,   _,_,w,_,_,w,_,w,_,_,_,_,_,_,w,_,w,_,_,w,_   ,_,_,_  ) ;\n        BR24(6,   _,_,_,w,_,_,_,_,_,_,_,_,w,w,_,_,_,_,w,_,_   ,_,_,_  ) ;\n        BR24(5,   w,_,w,_,_,_,w,w,w,w,_,_,_,w,w,_,_,_,_,_,_   ,_,_,_  ) ;\n        BR24(4,   _,_,_,_,_,w,w,w,w,w,w,w,_,_,w,w,w,_,_,w,_   ,_,_,_  ) ;\n        BR24(3,   _,_,_,_,w,w,w,_,w,_,w,_,w,_,_,w,w,w,_,_,w   ,_,_,_  ) ;\n        BR24(2,   _,_,w,_,_,_,w,w,w,w,w,_,_,_,w,w,_,_,_,_,_   ,_,_,_  ) ;\n        BR24(1,   w,_,_,_,_,_,_,w,_,w,_,_,_,w,w,_,_,_,w,_,_   ,_,_,_  ) ;\n        BR24(0,   _,_,w,_,_,_,w,_,_,_,w,_,_,_,_,w,_,_,_,_,_   ,_,_,_  ) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\nvec4 draw_gun( ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(2,0), ivec2(15,8) ) ) {\n        int x = iu.x, y = iu.y ;\n        PREPARE_TEST_BIT ;\n        BR16(7,   _,_,_,_,_,_,_,_,w,_,_,_,_,_,_,_  ) ;\n        BR16(6,   _,_,_,_,_,_,_,w,w,w,_,_,_,_,_,_  ) ;\n        BR16(5,   _,_,_,_,_,_,_,w,w,w,_,_,_,_,_,_  ) ;\n        BR16(4,   _,_,_,w,w,w,w,w,w,w,w,w,w,w,_,_  ) ;\n        BR16(3,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;\n        BR16(2,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;\n        BR16(1,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;\n        BR16(0,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\nvec4 draw_gun_explosion( int frame, ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3(0) ;\n    iu -= pos ;\n    if( iINSIDE( iu, ivec2(0), gun_exp_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        frame &= 1 ;\n        PREPARE_TEST_BIT ;\n        if( frame == 0 ) {\n            BR16(7,   _,_,_,w,_,_,_,_,_,_,_,_,_,w,_,_  ) ;\n            BR16(6,   w,_,_,_,_,_,w,_,_,_,_,w,w,_,_,w  ) ;\n            BR16(5,   _,_,_,w,_,_,_,_,w,w,_,_,_,_,_,_  ) ;\n            BR16(4,   _,_,_,_,_,_,w,_,_,_,_,_,_,_,w,_  ) ;\n            BR16(3,   _,w,_,_,w,_,w,w,_,_,w,w,_,_,_,w  ) ;\n            BR16(2,   _,_,w,_,_,_,_,w,w,w,_,_,_,w,_,_  ) ;\n            BR16(1,   _,_,_,w,w,w,w,w,w,w,w,w,_,_,_,_  ) ;\n            BR16(0,   _,_,w,w,_,w,w,w,w,w,w,w,_,_,w,_  ) ;\n        } else if( frame == 1 ) {\n            BR16(7,   _,_,_,_,_,_,w,_,_,_,_,_,_,_,_,_  ) ;\n            BR16(6,   _,_,_,_,_,_,_,_,_,_,_,w,_,_,_,_  ) ;\n            BR16(5,   _,_,_,_,_,_,_,_,_,_,w,_,_,_,_,_  ) ;\n            BR16(4,   _,_,_,w,_,_,_,_,_,_,_,_,_,_,_,_  ) ;\n            BR16(3,   _,_,_,_,_,_,_,_,w,_,w,w,_,_,_,_  ) ;\n            BR16(2,   _,w,_,_,_,_,_,_,_,_,w,_,w,_,_,_  ) ;\n            BR16(1,   _,_,_,_,w,_,_,_,w,w,w,_,_,w,_,_  ) ;\n            BR16(0,   _,_,w,w,_,w,_,w,_,w,w,w,_,w,_,w  ) ;\n        }\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\n#undef _\n#undef w\n\n//TODO better/faster text/number mappers\n\n//5 letters (6 bit) packed per component, max 20 letters\nvec4 draw_string16_ivec4( int num_ch, ivec4 s, ivec2 pos, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    if( num_ch < 0 ) {\n        return( v ) ;\n    }\n    num_ch = num_ch == 0 ? 20 : min( num_ch, 20 ) ;\n\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(0), ivec2(16*8,8) ) ) {\n        bool work = true ;\n        for( int j = 0 ; work && j < 4 ; ++ j ) {\n            int s4 = s[j] ;\n            for( int i = 0 ; i < 5 ; ++ i ) { //5 letters per component (5*6 bits)\n                int c = s4 & 0x3f ;\n                if( -- num_ch >= 0 && c > 0 ) {\n                    v += draw_character( c, pos, iu ) ;\n                } else {\n                    work = false ;\n                    break ;\n                }\n                pos.x += 8 ;\n                s4 >>= 6 ;\n            }\n        }\n    }\n    return( v ) ;\n}\n\nvec4 draw_number_0k( int k, int n, ivec2 pos, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    int off = 0 ;\n    if( n < 0 ) {\n        v += draw_character( _d, pos, iu ) ;\n        n = 0 - n ; //freaking workaround for mac os bug!!!\n        off = 8 ;\n    }\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(off,0), ivec2(k*8,8) ) ) {\n        int p = ( ( k*8 - 1 ) - iu2.x ) / 8, c ;\n        //for( int i = 0 ; i < p ; ++ i ) n /= 10 ;\n        //c = n % 10 ;\n        int d = int( pow( 10., float(p) ) ) ;\n        c = ( n / d ) % 10 ;\n        v += draw_character( c + 1, pos + ivec2( (k-1-p) * 8, 0 ), iu ) ;\n    }\n    return( v ) ;\n}\n\n//leading zeros, 4 low significant digits, 3 digits if negative\n//in other words up to 9999, or -999 (modulo if larger/smaller)\nvec4 draw_number_04( int n, ivec2 pos, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(0), ivec2(5*8,8) ) ) {\n        int k ;\n        if( n < 0 ) {\n            n = - n ;\n            v += draw_character( _d, pos, iu ) ;\n            pos.x += 8 ;\n            k = 1000 ;\n        } else {\n            k = 10000 ;\n        }\n        while( k > 1 ) {\n            n %= k ;\n            k /= 10 ;\n            v += draw_character( n / k + 1, pos, iu ) ;\n            pos.x += 8 ;\n        }\n    }\n    return( v );\n}\n\n\n//no leading zeros, 6 low significant digits, 5 if negative\n//up to 999999, or -99999 (modulo if larger/smaller)\nvec4 draw_number_6( int n, ivec2 pos, ivec2 iu ) {\n    vec4 v = vec4( 0 ) ;\n    ivec2 iu2 = iu - pos ;\n    if( iINSIDE( iu2, ivec2(0), ivec2(8*8,8) ) ) {\n        int k, i, d ;\n        if( n < 0 ) {\n            n = - n ;\n            v += draw_character( _d, pos, iu ) ;\n            pos.x += 8 ;\n            k = 100000 ;\n        } else {\n            k = 1000000 ;\n        }\n        do {\n            n %= k ;\n            k /= 10 ;\n            d = n / k ;\n        } while( d == 0 && k > 1 ) ;\n\n        if( n == 0 ) {\n            v += draw_character( _0, pos, iu ) ;\n        } else {\n            v += draw_character( d + 1, pos, iu ) ;\n            pos.x += 8 ;\n        }\n        while( k > 1 ) {\n            n %= k ;\n            k /= 10 ;\n            v += draw_character( n / k + 1, pos, iu ) ;\n            pos.x += 8 ;\n        }\n    }\n    return( v );\n}\n\n#if FONT_IN_TEXTURE == 1\n\nvec4 draw_character( int n, ivec2 pos, ivec2 iu ) {\n    vec4 v = vec4( 0, 0, 0, 1 ) ;\n    iu -= pos + ivec2(1,0) ;\n    if( n > 0 && n <= NUM_FONT_CHARS && iINSIDE( iu, ivec2(0), ivec2(5,7) ) ) {\n        iu = ivec2( iu.x + ( n - 1 ) * 5, 128 + iu.y ) ;\n        v = vec4( texelFetch( iChannel0, iu, 0 ).xxx, 1 ) ;\n    }\n    return( v ) ;\n}\n\n#else\n\n#undef BR20\n#define BR20(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T) float(A+(B<<1)+(C<<2)+(D<<3)+(E<<4)+(F<<5)+(G<<6)+(H<<7)+(I<<8)+(J<<9)+(K<<10)+(L<<11)+(M<<12)+(N<<13)+(O<<14)+(P<<15)+(Q<<16)+(R<<17)+(S<<18)+(T<<19))\n#define _ 0\n#define w 1\n\nconst vec4 font[] = vec4[32]( //((NUM_FONT_CHARS+3)/4)*2\n    vec4( 0, //0,1,2,3\n            BR20(  _,w,w,w,_  ,  _,_,w,_,_  ,  _,w,w,w,_  ,  w,w,w,w,w  ),\n            BR20(  w,_,_,_,w  ,  _,w,w,_,_  ,  w,_,_,_,w  ,  _,_,_,_,w  ),\n            BR20(  w,_,_,w,w  ,  _,_,w,_,_  ,  _,_,_,_,w  ,  _,_,_,w,_  ) ),\n    vec4(   BR20(  w,_,w,_,w  ,  _,_,w,_,_  ,  _,_,w,w,_  ,  _,_,w,w,_  ),\n            BR20(  w,w,_,_,w  ,  _,_,w,_,_  ,  _,w,_,_,_  ,  _,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  _,_,w,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ),\n            BR20(  _,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,w  ,  _,w,w,w,_  ) ),\n    vec4( 0, //4,5,6,7\n            BR20(  _,_,_,w,_  ,  w,w,w,w,w  ,  _,_,w,w,w  ,  w,w,w,w,w  ),\n            BR20(  _,_,w,w,_  ,  w,_,_,_,_  ,  _,w,_,_,_  ,  _,_,_,_,w  ),\n            BR20(  _,w,_,w,_  ,  w,w,w,w,_  ,  w,_,_,_,_  ,  _,_,_,_,w  ) ),\n    vec4(   BR20(  w,_,_,w,_  ,  _,_,_,_,w  ,  w,w,w,w,_  ,  _,_,_,w,_  ),\n            BR20(  w,w,w,w,w  ,  _,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  _,_,_,w,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  _,_,_,w,_  ,  _,w,w,w,_  ,  _,w,w,w,_  ,  _,_,w,_,_  ) ),\n    vec4( 0, //8,9,<,>\n            BR20(  _,w,w,w,_  ,  _,w,w,w,_  ,  _,_,_,w,_  ,  _,w,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,_,_,_  ,  _,_,_,w,_  ) ),\n    vec4(   BR20(  _,w,w,w,_  ,  _,w,w,w,w  ,  w,_,_,_,_  ,  _,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  _,_,_,_,w  ,  _,w,_,_,_  ,  _,_,_,w,_  ),\n            BR20(  w,_,_,_,w  ,  _,_,_,w,_  ,  _,_,w,_,_  ,  _,_,w,_,_  ),\n            BR20(  _,w,w,w,_  ,  w,w,w,_,_  ,  _,_,_,w,_  ,  _,w,_,_,_  ) ),\n    vec4( 0, //A,B,C,D\n            BR20(  _,_,w,_,_  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,_  ),\n            BR20(  _,w,_,w,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ,  w,_,_,_,w  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,w,w,w,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ),\n            BR20(  w,w,w,w,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,_  ) ),\n    vec4( 0, //E,F,G,H\n            BR20(  w,w,w,w,w  ,  w,w,w,w,w  ,  _,w,w,w,_  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ) ),\n    vec4(   BR20(  w,w,w,w,_  ,  w,w,w,w,_  ,  w,_,_,_,_  ,  w,w,w,w,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,w,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,_  ,  w,_,_,_,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,w,w,w,w  ,  w,_,_,_,_  ,  _,w,w,w,w  ,  w,_,_,_,w  ) ),\n    vec4( 0, //I,J,K,L\n            BR20(  _,w,w,w,_  ,  _,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,_,_,w,_  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,_,w,_,_  ,  w,_,_,_,_  ) ),\n    vec4(   BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,w,_,_,_  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,w  ,  w,_,w,_,_  ,  w,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  w,_,_,_,w  ,  w,_,_,w,_  ,  w,_,_,_,_  ),\n            BR20(  _,w,w,w,_  ,  _,w,w,w,_  ,  w,_,_,_,w  ,  w,w,w,w,w  ) ),\n    vec4( 0, //M,N,O,P\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,w,w,_  ,  w,w,w,w,_  ),\n            BR20(  w,w,_,w,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,w,_,w  ,  w,w,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,_,w,_,w  ,  w,_,_,_,w  ,  w,w,w,w,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,w,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,w,w,_  ,  w,_,_,_,_  ) ),\n    vec4( 0, //Q,R,S,T\n            BR20(  _,w,w,w,_  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  w,w,w,w,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,_  ,  _,_,w,_,_  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,w,w,w,_  ,  _,w,w,w,_  ,  _,_,w,_,_  ),\n            BR20(  w,_,w,_,w  ,  w,_,w,_,_  ,  _,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,w,_  ,  w,_,_,w,_  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  _,w,w,_,w  ,  w,_,_,_,w  ,  _,w,w,w,_  ,  _,_,w,_,_  ) ),\n    vec4( 0, //U,V,W,X\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,w,_,w,_  ) ),\n    vec4(   BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,_,_,w  ,  _,_,w,_,_  ),\n            BR20(  w,_,_,_,w  ,  w,_,_,_,w  ,  w,_,w,_,w  ,  _,w,_,w,_  ),\n            BR20(  w,_,_,_,w  ,  _,w,_,w,_  ,  w,w,_,w,w  ,  w,_,_,_,w  ),\n            BR20(  _,w,w,w,_  ,  _,_,w,_,_  ,  w,_,_,_,w  ,  w,_,_,_,w  ) ),\n    vec4( 0, //Y,Z,?,-\n            BR20(  w,_,_,_,w  ,  w,w,w,w,w  ,  _,w,w,w,_  ,  _,_,_,_,_  ),\n            BR20(  w,_,_,_,w  ,  _,_,_,_,w  ,  w,_,_,_,w  ,  _,_,_,_,_  ),\n            BR20(  _,w,_,w,_  ,  _,_,_,w,_  ,  _,_,_,_,w  ,  _,_,_,_,_  ) ),\n    vec4(   BR20(  _,_,w,_,_  ,  _,_,w,_,_  ,  _,_,_,w,_  ,  w,w,w,w,w  ),\n            BR20(  _,_,w,_,_  ,  _,w,_,_,_  ,  _,_,w,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  w,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  w,w,w,w,w  ,  _,_,w,_,_  ,  _,_,_,_,_  ) ),\n    vec4( 0, // /\n            BR20(  _,_,_,w,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,_,w,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ) ),\n    vec4(   BR20(  _,_,w,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,_,w,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,w,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ),\n            BR20(  _,w,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ,  _,_,_,_,_  ) ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 ),\n    vec4( 0 )\n) ;\n\n#undef _\n#undef w\n\n//workaround for variable indexing\n//binary search, 32 indexes\n\nfloat get_bit_row( int p, int y ) {\n    vec4 v ;\n    v =  p<16?p<8?p<4?p<2?p<1?     font[ 0] : font[ 1]\n        :p<3?                      font[ 2] : font[ 3]\n        :p<6?p<5?                  font[ 4] : font[ 5]\n        :p<7?                      font[ 6] : font[ 7]\n        :p<12?p<10?p<9?            font[ 8] : font[ 9]\n        :p<11?                     font[10] : font[11]\n        :p<14?p<13?                font[12] : font[13]\n        :p<15?                     font[14] : font[15]\n        :p<24?p<20?p<18?p<17?      font[16] : font[17]\n        :p<19?                     font[18] : font[19]\n        :p<22?p<21?                font[20] : font[21]\n        :p<23?                     font[22] : font[23]\n        :p<28?p<26?p<25?           font[24] : font[25]\n        :p<27?                     font[26] : font[27]\n        :p<30?p<29?                font[28] : font[29]\n        :p<31?                     font[30] : font[31] ;\n\n    //return( v[y] ) ;\n    return(\n        y<2?y<1? v[0] : v[1]\n       :y<3?     v[2] : v[3]\n    ) ;\n}\n\nvec4 draw_character( int n, ivec2 pos, ivec2 iu ) {\n    vec3 v = vec3( 0 ) ;\n    iu -= pos + ivec2(1,0) ;\n    if( n > 0 && n <= NUM_FONT_CHARS && iINSIDE( iu, ivec2(0), ch_gfx_dim ) ) {\n        int x = iu.x, y = iu.y ;\n        n -- ;\n        x += 5 * ( n & 3 ) ;\n        float fx2 = exp2(-float(x+1)) ;\n\n        n >>= 2 ;\n        int part = y < 4 ? n * 2 + 1 : n * 2 ;\n        y = 3 - (y&3) ;\n        v = vec3( fract( get_bit_row( part, y ) * fx2 ) >= .5 ) ;\n    }\n    return( vec4( v, 1 ) ) ;\n}\n\n#endif\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//Buffer C - zoom buffer, color areas (press I to toggle max integer multiplier / max height)\n//A nearest,B linear,_,Keyboard\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n#if FD > 1\n    //skip frames\n    if( iFrame % FD != 0 ) {\n        discard ;\n    }\n#endif\n\n    ivec2 iu = ivec2( u ) ;\n\n    vec2 fscr_dim = vec2( scr_dim ) ;\n\n    float k = iResolution.y / fscr_dim.y ;\n    \n    //read toggle status of the key by fetching (key, 2) from keyboard\n\n    if( texelFetch( iChannel3, ivec2( KEY_INT_SIZE, 2 ), 0 ).x > .5 ) {\n        k = floor( k ) ;\n    }\n    \n    ivec2 new_dim = ivec2( fscr_dim * k ) ;\n    ivec2 diff = ivec2( iResolution.xy ) - new_dim ;\n    u -= vec2( diff / 2 ) ;\n    \n    o = vec4( 0 ) ;\n\n    //o += .5 * texture( iChannel1, u / ( k* iResolution.xy ), 4. ) ; //attempted mipmap glow\n\n    if( texelFetch( iChannel3, ivec2( KEY_LINEAR, 2 ), 0 ).x < .5 ) { //default linear\n        o += texture( iChannel1, u / ( k * iResolution.xy ) ) ;\n    } else {\n        o += texelFetch( iChannel1, ivec2( u / k ), 0 ) ;\n    }\n    \n    //green part of the screen\n    if( u.y < 72.*k && ! ( u.x < 16.*k && u.y < 16.*k ) )        o.rb *= 0. ;\n    //red part of the screen\n    if( u.y >= (fscr_dim.y-62.)*k && u.y < (fscr_dim.y-34.)*k )  o.gb *= 0. ;\n    \n    //border (but it is redrawn in filter stage to avoid filtering...)\n    /*if( ! iINSIDE( ivec2( u ), ivec2( 0 ), new_dim ) ) {\n        o = vec4( 0, 0, .5, 1 ) ;\n    }*/\n    \n}\n","name":"Buffer C","description":"","type":"buffer"}]}