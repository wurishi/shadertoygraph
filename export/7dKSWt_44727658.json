{"ver":"0.1","info":{"id":"7dKSWt","date":"1635543918","viewed":27,"name":"Mod Test 2","username":"Livie","description":"mod test 2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CLOSE_ENOUGH = 0.001;\nconst float RENDER_DISTANCE = 30.0;\n\nconst vec3 BG_COLOR = vec3(90., 10., 90.)/255.;\nconst vec3 SHADOW_COLOR = vec3(30., 10., 80.)/255.;\nconst vec3 COLOR = vec3(30., 150., 250.)/255.;\n\nstruct sphere {\n\tvec3 c;\n    float r;\n};\n\nfloat sphereDist(vec3 p, sphere s) {\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k )  {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p) {\n    float returnVal = .0;\n    \n    vec3 rep = vec3(1., 0., 2.);\n\tvec3 pr = mod(p, rep) - .5 * rep; \n        \n    sphere s1 = sphere(vec3(sin(iTime*4.)*.0, sin(iTime*3.)*0.25-0.5, 0.5), 0.1-0.3*sin(iTime));\n    sphere s2 = sphere(vec3(0., sin(iTime*2.)*.8-0.8, 0.5), 0.1);\n    sphere s3 = sphere(vec3(0., sin(iTime*1.)*1.-0.8, 0.5), 0.3*sin(iTime));\n    \n    vec3 b = vec3(1.5, 0.01, 3.);\n    vec3 q = abs(pr + vec3(.5,1.,-2.)) - b;\n    float b1 = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n    float smoothness = .2;\n    returnVal = opSmoothUnion(b1, sphereDist(pr,s1), smoothness); \n    returnVal = opSmoothUnion(returnVal, sphereDist(pr,s2), smoothness); \n    returnVal = opSmoothUnion(returnVal, sphereDist(pr,s3), smoothness);    \n\treturn returnVal; \n}\n\n// from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\tvec3 cameraPos = vec3(.0,0.0,-iTime*0.1);\n    \n    // Time varying pixel color\n    vec3 ro = vec3(cameraPos.x + uv.x, cameraPos.y + uv.y, cameraPos.z);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = BG_COLOR * (1. - uv.y);\n    float dist = .0;\n       \n    vec3 lightDir = normalize(vec3(sin(iTime*0.125), sin(iTime*0.25), -1.0));\n\n    while(dist < RENDER_DISTANCE)\n    {\n        float d = sdf(ro + rd * dist);\n        if(d < CLOSE_ENOUGH)\n        {\n            vec3 hit = ro + rd * dist;\n            col = COLOR; \n            col *= mix(SHADOW_COLOR, col, max(dot(calcNormal(hit), lightDir), .0));\n            col = col;\n            break;\n        }\n        dist += d;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}