{"ver":"0.1","info":{"id":"mdKfzz","date":"1697860137","viewed":62,"name":"Capped hyperboloid ray intersect","username":"dfwaffles","description":"Raycast a hyperboloid smoothly connecting two spheres. Works for rays starting inside or outside.\n\nThe hyperboloid solver is from here (https://www.shadertoy.com/view/fddBD2), I just added the computations required to get the quadric's coefficients!\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycast","quadric","smooth","intersect","hyperboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********\n\n Background functions: none of these are new, I got them all from iq. (Mistakes in my modifications are\n obviously due to me :) )\n \n See in particular generalized ellipsoid / quadric: https://www.shadertoy.com/view/fddBD2\n \n This probably won't make a lot of sense without Generalized Ellipsoid for context!\n\n***********/\n\n// this version of ray-sphere intersection returns both hits, to make it easier later to handle rays\n// starting inside the solid.\nvec4 ball(vec3 ro, vec3 rd, vec3 pb, float rb, out vec4 back) {                                                    \n back = vec4(123.);                                                                                                 \n vec3 ob = ro - pb;                                                                                                 \n float b = dot(ob, rd);                                                                                             \n float c = dot(ob, ob) - rb*rb;                                                                                     \n float h = b*b - c;                                                                                                 \n if(h < 0.0) return vec4(123.);                                                                                     \n h = sqrt(h);                                                                                                       \n vec4 hit = vec4(123.);                                                                                             \n float t = -b-h;                                                                                                    \n if (t > .0) hit = vec4(t, (ro+t*rd-pb)/rb);                                                                        \n t = -b+h;                                                                                                          \n if (t > .0) back = vec4(-t, (ro+t*rd-pb)/rb);                                                                      \n return hit.x == 123.? back : hit;                                                                                  \n}       \n\nbool clipy( in vec3 pos, float ymin, float ymax ){                                                                  \n return pos.y >= ymin && pos.y <= ymax;                                                                             \n}                                                                                                                    \n\n// this takes the quadric's abcd coefficients already squared; quad (below) takes them unsquared.\nvec4 quadraw(vec3 p, vec3 dp, vec3 r2, float w, float ymin, float ymax) {                                          \n float k2 = dot(dp,dp*r2);                                                                                          \n float k1 = dot(dp,p*r2);                                                                                           \n float k0 = dot(p,p*r2) - w;                                                                                        \n                                                                                                                    \n float h = k1*k1 - k2*k0;                                                                                           \n if( h<0.0 ) return vec4(123.);                                                                                     \n h = sqrt(h) * sign(k2);                                                                                            \n                                                                                                                                                                                                                        \n float t = (-k1-h)/k2;                                                                                              \n vec3 pos = p + t*dp;                                                                                               \n if(t>0.0 && clipy(pos,ymin,ymax))                                                                                  \n  return vec4(t*(k2>.0?1.:-1.), normalize(pos*r2));                                                                 \n                                                                                                                                                                                                                        \n t = (-k1+h)/k2;                                                                                                    \n pos = p + t*dp;                                                                                                    \n if( t>0.0 && clipy(pos,ymin,ymax))                                                                                 \n  return vec4(t*(k2<.0?1.:-1.), normalize(pos*r2));                                                                 \n                                                                                                                    \n return vec4(123.);                                                                                                 \n}\n\nvec4 quad(vec3 p, vec3 dp, vec4 abcd, float ymin, float ymax) {                                                    \n vec3 r2 = abcd.xyz*abs(abcd.xyz); // squared WITH sign                                                             \n return quadraw(p, dp, r2, abcd.w, ymin, ymax);                                                                    \n}                                                                                                                   \n                                                                                                                    \nconst mat3 im3 = mat3(1,0,0,0,1,0,0,0,1);                                                                           \n\n/***********\n\n The new stuff!\n \n Intersect a ray (p, dp) with a capped hyperboloid, with the first sphere at vec3(.0), the second at\n  pb, and radii r.x, r.y, r.z. Returns a vec4 whose x is distance along the ray to the intersection\n  (or 123. for no hit), and yzw is the normal.\n  \n This should also work for rays originating inside the capped hyperboloid.\n \n************/\n\nvec4 cappedHyperboloid(vec3 p, vec3 dp, vec3 pb, vec3 r) {                                                                       \n\n // The hyperboloid intersection (quad) is computed assuming it's aligned with the y axis;\n // so we rotate pb, p, and dp to align pb with the y axis.\n \n float lpb = length(pb);                                                                                            \n vec3 npb = pb/lpb;                                                                                                 \n vec3 v = cross(npb, vec3(.0,1.,.0));                                                                               \n mat3 vx = mat3(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);                                                          \n mat3 rm = im3 + vx + vx*vx/(1.+npb.y);                                                                             \n\n pb = vec3(.0, lpb, .0);                                                                                            \n p = rm*p;                                                                                                          \n dp = rm*dp; \n \n // h is the y coordinate of the narrowest point of the hyperbola. \n vec3 r2 = r*r;                                                                                                     \n float h = r.x == r.z? pb.y/2. : pb.y*(r2.x-r2.y-sqrt((r2.x-r2.y)*(r2.z-r2.y)))/(r2.x-r2.z);                        \n // I think this could also be +sqrt(...) in some cases, not sure which -- maybe capped ellipsoid?\n \n // ly is the low point of the hyperboloid, where it joins up with the bottom sphere; uy is the top where it joins\n // the top sphere.\n float ly = (r2.x-r2.y)/h;                                                                                          \n float uy = pb.y-(r2.z-r2.y)/(pb.y-h);                                                                              \n float or2y = 1./r2.y;\n \n // solve the quadric!\n // Note: this is using quadraw, so we're passing the squared versions of all coefficients.\n // Otherwise, we'd sqrt them here, then square them in the quadric solver, which would be a waste.\n vec4 hit = quadraw(p-vec3(.0,h,.0), dp, vec3(or2y, -or2y/(h*h/(r2.x-r2.y)-1.), or2y), 1., ly-h, uy-h);            \n \n // now draw the endcap spheres. \n vec4 bb1;                                                                                                          \n vec4 b1 = ball(p, dp, vec3(.0), r.x, bb1);                                                                        \n if (abs(b1.x) < abs(hit.x) && clipy(p+abs(b1.x)*dp, -r.x, ly)) hit = b1;                                           \n if (abs(bb1.x) < abs(hit.x) && clipy(p+abs(bb1.x)*dp, -r.x, ly)) hit = bb1;                                                                                                                                                         \n vec3 ppb = p-pb;                                                                                                   \n vec4 bb2;                                                                                                          \n vec4 b2 = ball(ppb, dp, vec3(.0), r.z, bb2);                                                                      \n if (abs(b2.x) < abs(hit.x) &&  clipy(ppb+abs(b2.x)*dp, uy-pb.y, r.z)) hit = b2;                                    \n if (abs(bb2.x) < abs(hit.x) && clipy(ppb+abs(bb2.x)*dp, uy-pb.y, r.z)) hit = bb2;                                  \n  \n  \n // don't forget to rotate the normal back to our original basis!\n return vec4(hit.x, transpose(rm)*hit.yzw);                                                                         \n}      \n\nvec2 rot(vec2 p, float t) {                                                                                         \n vec2 a = vec2(cos(t), sin(t));                                                                                     \n return mat2(a.x,-a.y,a.y,a.x)*p;                                                                                   \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 uv = fragCoord/iResolution.x;\n \n vec3 p = vec3(uv-vec2(.5, .5*iResolution.y/iResolution.x), 1.0);\n vec3 dp = normalize(vec3(p.xy,-1.));\n vec3 b = vec3(.5, .25, .0);\n b.xz = rot(b.xz, -.5*iTime);\n \n vec4 hit = cappedHyperboloid(p, dp, b, vec3(.3,mix(.01,.19,sin(.5+.33*iTime)), .2));\n vec4 c = hit.x != 123.? vec4(hit.yzw*.375+.375,1.0) : vec4(.0);\n if (hit.x != 123. && dot(reflect(vec3(.6), hit.yzw), dp) > .98) c += 1.;\n \n // to show off rays starting inside the hyperboloid, let's make it semi-transparent and continue our ray to the\n // back face:\n p += (hit.x+.001)*dp;\n hit = cappedHyperboloid(p, dp, b, vec3(.3,mix(.01,.19,sin(.5+.33*iTime)), .2));\n c += hit.x != 123.? vec4(hit.yzw*.125+.125,1.0) : vec4(.0);\n \n fragColor = c;\n}","name":"Image","description":"","type":"image"}]}