{"ver":"0.1","info":{"id":"clGGR1","date":"1683866968","viewed":99,"name":"Noise Reduction + Edge Detect","username":"Nardello1","description":"Trying to combine bilateral filtering and sobel edge detection. Need more sophisticated edge detection to use on anything with fine details.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid makeKernel(inout vec3 cell[9], vec2 uv)\n{\n    float w = 1.0 / iResolution.x;\n    float h = 1.0 / iResolution.y;\n    \n    cell[0] = texture(iChannel0, uv + vec2(-w, -h)).rgb;\n    cell[1] = texture(iChannel0, uv + vec2(0.0, -h)).rgb;\n    cell[2] = texture(iChannel0, uv + vec2(w, -h)).rgb;\n    cell[3] = texture(iChannel0, uv + vec2(-w, 0.0)).rgb;\n    cell[4] = texture(iChannel0, uv).rgb;\n    cell[5] = texture(iChannel0, uv + vec2(w, 0.0)).rgb;\n    cell[6] = texture(iChannel0, uv + vec2(-w, h)).rgb;\n    cell[7] = texture(iChannel0, uv + vec2(0.0, h)).rgb;\n    cell[8] = texture(iChannel0, uv + vec2(w, h)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n\n    \n    // Set up kernel data\n    vec3 cell[9];\n    makeKernel(cell, uv);\n    \n    // Perform sobel convolutions\n    vec3 sobelX = (1.0 * cell[0]) + (0.0 * cell[1]) + (-1.0 * cell[2]) +\n                    (2.0 * cell[3]) + (0.0 * cell[4]) + (-2.0 * cell[5]) +\n                    (1.0 * cell[6]) + (0.0 * cell[7]) + (-1.0 * cell[8]);\n    \n    vec3 sobelY = (1.0 * cell[0]) + (2.0 * cell[1]) + (1.0 * cell[2]) +\n                    (0.0 * cell[3]) + (0.0 * cell[4]) + (0.0 * cell[5]) +\n                    (-1.0 * cell[6]) + (-2.0 * cell[7]) + (-1.0 * cell[8]);\n    \n    // Add convolutions\n    vec3 sobelXY = sqrt((sobelX * sobelX) + (sobelY * sobelY));\n    \n\n    vec4 threshold = vec4(1.0 - (step(0.08, sobelXY)).rbg, 1.0);\n    float gray = dot(threshold.rgb, vec3(0.299, 0.587, 0.114));\n    vec4 mask = vec4(gray, gray, gray, threshold.a);\n    \n    col *= mask;\n    \n       \n    fragColor = col;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SIGMA_R 25.0\n#define SIGMA_D 10.0\n#define KERNEL_SIZE 10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 finalCol = vec3(0.0);\n    \n    vec4 col = texture(iChannel0, uv);\n    float kernel = KERNEL_SIZE;\n    float sigma_r = 2.0 * pow(SIGMA_R, 2.0);\n    float sigma_d = 2.0 * pow(SIGMA_D, 2.0);\n    \n    vec4 intensityWeightSum = vec4(0.0);\n    vec4 weightSum = vec4(0.0);\n    \n    for(float i = -kernel; i < kernel; i++)\n    {\n         for(float j = -kernel; j < kernel; j++)\n         {\n             vec2 newCoords = vec2(i, j);\n             vec2 newUV = uv + (newCoords / iResolution.xy);\n             vec4 sampleCol = texture(iChannel0, newUV);\n             \n             vec4 dI = vec4((sampleCol - col) * 255.0);\n             vec4 w = exp((-dot(newCoords, newCoords) / sigma_d) - (dI * dI / sigma_r));\n             \n             intensityWeightSum += w * sampleCol;\n             weightSum += w;\n         }\n    }\n\n    // Output to screen\n    fragColor = vec4((intensityWeightSum / weightSum).rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}