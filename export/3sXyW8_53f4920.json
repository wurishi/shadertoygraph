{"ver":"0.1","info":{"id":"3sXyW8","date":"1584630380","viewed":79,"name":"lucas barth√©lemy - TP4","username":"EpikWem","description":"infographie","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["infographie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Lucas BARTHELEMY\n\nconst float view = 8000.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Iterations\nconst int N = 500;\n\n// Lipschitz constant\nconst float K=7.0;\n\n// Calculate a color from 0-255 values\nvec3 color01 (vec3 c) {\n\treturn c / 255.0;\n}\n\n// Terrain -----------------------------------------------------------------------------------------------\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 x )\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1950.0;\n    const float a0=575.0;\n    \n\tvec2  p = x/l0;\n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i<12; i++ )\n    {\n        float n = Noise(p);\n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn -500.0+a0*a;\n} \n\n// Implicit surface defining the terrain\n// p : Point\nfloat ImplicitTerrain(in vec3 p)\n{\n\tfloat h = p.z - Terrain( p.xy );\n    return h;\n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool IntersectTerrain(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<N; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = ImplicitTerrain(p);\n        // 10 cm precision\n\t\tif( abs(h)<(Epsilon*t)  ) return true;\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n\treturn false;\n}\n\n// Calculate object normal\n// p : point\nvec3 NormalTerrain(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = ImplicitTerrain(p);\n  n.x = ImplicitTerrain( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = ImplicitTerrain( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = ImplicitTerrain( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Water ------------------------------------------------------------------------------------------------\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Water( in vec2 x )\n{\n\treturn 20.0*Noise(x/50.0+iTime)- 20.0;\n} \n\n// Implicit surface defining the terrain\n// p : Point\nfloat ImplicitWater(in vec3 p)\n{\n\tfloat h = p.z - Water( p.xy );\n    return h;\n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool IntersectWater(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<N; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = ImplicitWater(p);\n        // 10 cm precision\n\t\tif( abs(h)<(Epsilon*t)  ) return true;\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n\treturn false;\n}\n\n// Calculate object normal\n// p : point\nvec3 NormalWater(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = ImplicitWater(p);\n  n.x = ImplicitWater( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = ImplicitWater( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = ImplicitWater( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    float t;\n    float w;\n    int it;\n    bool bt = IntersectTerrain( ro, rd, t , it);\n    bool bw = IntersectWater( ro, rd, w , it);\n\n    // Sky\n    if( bt==false && bw == false)\n    {\n        vec3 p = ro + t*rd;\n        col = vec3(0.35, 0.65, 0.95) - rd.z*rd.z*2.5;\n    }\n\telse \n\t{\n        // Find first intersection by canceling intersection behind\n        if ((bt==true) && (bw==true))\n        {\n            if (t<w) { bw = false; }\n            else { bt = false; }\n        }\n        // Mountains\t\t\n        if (bt==true)\n        {\n\t\tvec3 p = ro + t*rd;\n        vec3 n = NormalTerrain( p );\n\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n\n        col = vec3(0.471, 0.361, 0.110);\n        // <----------------------------------\n            float forest = 0.0;\n            if ((p.z > 90.0))// && (p.z < 240.0))\n            \tforest = smoothstep( 100.0, 200.0, (p.z + 100.0*Noise(p/500.0)));\n            col = mix(col, vec3(0.05, 0.20, 0.00), forest);\n        // <----------------------------------\n            float snow = 0.0;\n            snow = smoothstep( 300.0, 500.0, (p.z + 100.0*Noise(p/100.0)) );\n            col = mix(col, vec3(0.7,0.9,0.9), snow);\n        // <----------------------------------\n            float sand = 1.0;\n            sand = smoothstep(100.0, 50.0, p.z + 10.0*Noise(p/5.0));\n            //if (p.z < 60.0)\n            //\tsand = smoothstep( 0.0, 250.0, (p.z + 100.0*Noise(p/100.0)) );\n            col = mix(col, vec3(1.0,0.9,0.6), sand);\n        // <----------------------------------\n\n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col += dif*vec3(0.35,0.35,0.35);\n\n\t\t// fog\n        float fo = 1.0-exp(-pow(0.00015*t,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo );    \n        \n        }\n        \n        // Water\n        if (bw==true)\n        {\n            vec3 p = ro + w*rd;\n            vec3 n = NormalWater( p );\n\n            vec3 ref = reflect( rd, n );\n            float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n            vec3 hal = normalize(light1-rd);\n\n            col = mix(\n                color01(vec3(100.0, 100.0, 120.0)),\n                color01(vec3(80.0, 80.0, 155.0)),\n                sin(p.x + 2.0*iTime)\n            ) + vec3(-0.3, -0.3, -0.2);\n        \n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col += dif*vec3(0.35,0.35,0.35);\n\n\t\t// fog\n        float fo = 1.0-exp(-pow(0.00015*w,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo );\n        }\n\n\t}\n\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    float s=float(it)/float(N);\n\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    // Gamma with square root\n    return vec4( sqrt(col), t );\n    }\n\n}\n\nmat3 Camera(float a, out vec3 ro)\n{\n\t// Origin\n    ro = vec3( 0.0,0.0,800.0 );\n\t\n    // Target\n    vec3 ta = ro+vec3(500.0*cos(a),500.0*sin(a),-50.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,5.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n","name":"Common","description":"","type":"common"}]}