{"ver":"0.1","info":{"id":"XdcfWX","date":"1526918134","viewed":543,"name":"Heightfield / Profile SDF","username":"fizzer","description":"Following on from https://www.shadertoy.com/view/MsdBDj, here's another way in which a 3D distance field can be composed of multiple 2D fields. Here, one map provides part of the sampling coordinate for the other map.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["heightfield","sdf","modelling","profile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A small shader to demonstrate SDF modelling with two 2D fields.\n// Check out https://www.shadertoy.com/view/MsdBDj for a similar way of modelling with 2D maps.\n//\n// Click mouse button to see the result full-screen.\n//\n\n#define SHAPE\t2\t// Can be 0, 1, or 2\n#define AA\t\t1\t// Anti-aliasing box size\n\nfloat box(vec2 p,vec2 s)\n{\n    p=abs(p)-s;\n    return max(p.x,p.y);\n}\n\n// The next sets of functions define two 2D distance field functions. Each set has a heightfield function\n// and a profile function. The parameters to the heightfield function are the X and Z coordinate of the point.\n// The parameters to the profile function are the Y coordinate, and the value returned from the heightfield function.\n// The heightfield is not really the height of a surface, but just the 'height' of the coordinate that the profile\n// shape is sampled by.\n#if SHAPE==0\n\nfloat heightfield(vec2 p)\n{\n    return box(p,vec2(0));\n}\n\nfloat profile(vec2 p)\n{\n    return box(p,vec2(0))-.1;\n    return length(p)-.1;\n}\n\n#elif SHAPE==1\n\nfloat heightfield(vec2 p)\n{\n    p=abs(p)-.15;\n    return box(p,vec2(0));\n}\n\nfloat profile(vec2 p)\n{\n   return max(box(p-vec2(0,.03),vec2(0,-.02))-.1+p.y/2.,-box(p-vec2(.15,0.0),vec2(.07,.02)));\n}\n\n#else\n\nfloat heightfield(vec2 p)\n{\n    p=abs(p)-.15;\n    return min(box(p,vec2(0)),box(p+.1,vec2(0,.2)));\n}\n\nfloat profile(vec2 p)\n{\n    p*=2.;\n    float s=1.5,ds=1.;\n    for(int i=0;i<3;++i)\n    {\n        p=abs(p)-.05;\n        float a=3.1415926535/4.;\n        p*=mat2(cos(a),sin(a),-sin(a),cos(a))*s;\n        ds*=s;\n    }\n    return box(p,vec2(.4,.03))/ds/2.;\n}\n\n#endif\n\n// The composed 3D signed distance field.\nfloat f(vec3 p)\n{\n    return min(p.y+.1,profile(vec2(heightfield(p.xz),p.y)));\n}\n\n// Orthonormal basis, based on code from PBRT.\nmat3 coordinateSystem(vec3 w)\n{\n    vec3 u = cross(w, vec3(1,0,0));\n    if (dot(u, u) < 1e-6)\n        u = cross(w, vec3(0,1,0));\n    return mat3(normalize(u), normalize(cross(u, w)), normalize(w));\n}\n\n// Signed distance field normal direction.\nvec3 getNormal(vec3 p)\n{\n    float d=f(p);\n    const vec2 e=vec2(1e-3,0);\n    vec3 n=vec3(f(p+e.xyy)-d,f(p+e.yxy)-d,f(p+e.yyx)-d);\n    return n;\n}\n\n// An approximate 'curvature' value (basically the amount of local change in the field normal).\n// It's not perfect, but I'm still working on it...\nfloat curvature(vec3 p)\n{\n    vec3 n=getNormal(p);\n\n    mat3 m=coordinateSystem(n);\n\n    const float e=1e-4;\n    vec3 n1=getNormal(p+m[0]*e);\n    vec3 n2=getNormal(p+m[1]*e);\n    vec3 n3=getNormal(p-m[0]*e);\n    vec3 n4=getNormal(p-m[1]*e);\n\n    return (length((n1-n3)/e)+length((n2-n4)/e))*5.;\n}\n\n// From IQ.\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 9;\n    const float delta = .18;\n\n    float a = 0.0;\n    float weight = .5;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - f(p + n*d));\n        weight *= 0.99;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec3 distanceColourMap(float d)\n{\n    float lines=mix(.5,1.,smoothstep(-.5,.5,(min(fract(d*64.),1.-fract(d*64.))-.5)*3.)*2.);\n    return clamp(mix(vec3(lines)*vec3(.1),vec3(.5,.5,1.),step(d,0.))+d/3.+(1.-smoothstep(.00,.002,abs(d)-.002)),0.,1.);\n}\n\n// Analytically triangle-filtered checkerboard, from IQ\n// https://iquilezles.org/articles/morecheckerfiltering\nvec3 pri( in vec3 x )\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an=.7;\n    vec2 t=fragCoord/iResolution.xy*2.-1.;\n\n    t.x*=iResolution.x/iResolution.y;\n\n    if(abs(t.x)>1.)\n    {\n        fragColor=vec4(0,0,0,1);\n        return;\n    }\n\n    float full = step(0.5,iMouse.z);\n\n    if(full>.5)\n    {\n        t.y=t.y+.5;\n    }\n\n    // Check which quadrant the pixel is in.\n    if(t.x<0.&&t.y<0.&&full<.5)\n    {\n        fragColor.rgb=distanceColourMap(heightfield((t.xy*.5+.25)*1.5));\n    }\n    else if(t.x>0.&&t.y<0.&&full<.5)\n    {\n        fragColor.rgb=distanceColourMap(profile((t.xy*.5+.25*vec2(-1.,1.))*1.5));\n    }\n    else\n    {\n        // Anti-aliasing loop.\n        vec3 c=vec3(0);\n        for(int y=-AA;y<=AA;++y)\n            for(int x=-AA;x<=AA;++x)\n            {\n                float u=float(x)*.25,v=float(y)*.25;\n\n                // Set up the primary ray.\n                vec3 ro=vec3(0.,0.,1.25);\n                vec3 rd=normalize(vec3((t.xy+dFdx(t.xy)*u+dFdy(t.xy)*v)*vec2(.5,.25)-.125*vec2(0,1),-1.));\n\n                rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n                ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n                // Get the ray directions of neighbouring pixels for this sample.\n                vec3 ddx_rd = rd + dFdx(rd);\n                vec3 ddy_rd = rd + dFdy(rd);\n\n                float s=20.;\n\n                // Trace primary ray.\n                float t=0.,d=0.;\n                for(int i=0;i<100;++i)\n                {\n                    d=f(ro+rd*t);\n                    if(d<1e-3||t>10.)break;\n                    t+=d;\n                }\n\n\n                vec3 rp=ro+rd*t;\n                vec3 n = normalize(getNormal(rp));\n\n                // Compute ray differentials (based on code from IQ)\n                vec3 ddx_pos = ro - ddx_rd*dot(ro-rp,n)/dot(ddx_rd,n);\n                vec3 ddy_pos = ro - ddy_rd*dot(ro-rp,n)/dot(ddy_rd,n);\n\n                // Calc texture sampling footprint (based on code from IQ)\n                vec3     uvw = rp*32.;\n                vec3 ddx_uvw = ddx_pos*32. - uvw;\n                vec3 ddy_uvw = ddy_pos*32. - uvw;\n\n                // Basic light value.\n                float l=.7+.3*dot(n,normalize(vec3(1)));\n\n                // Ambient occlusion.\n                l*=ambientOcclusion(rp,n);\n\n                // Depth cueing.\n                l*=exp(-t/1.5)*2.;\n\n                // Darken the geometric edges.\n                l*=clamp(1.-curvature(rp),0.,1.);\n\n                // Get a directional shadow.\n                t=0.;\n                d=0.;\n                ro=rp+n*2e-3;\n                rd=normalize(vec3(1,.3,1));\n                float mind=1e4;\n                for(int i=0;i<40;++i)\n                {\n                    d=f(ro+rd*t);\n                    mind=min(mind,d);\n                    if(d<1e-3||t>10.)break;\n                    t+=d;\n                }\n\n                l*=mix(.3,1.,smoothstep(0.001,0.0015,mind));\n\n                // Apply the filtered checkerboard texture.\n                c+=l*(.5+.5*checkersTextureGradTri( uvw, ddx_uvw, ddy_uvw ));\n            }\n        fragColor.rgb=c/((float(AA)*2.+1.)*(float(AA)*2.+1.));\n    }\n\n    if(full<.5)\n    {\n        // Add separation lines.\n        fragColor.rgb=mix(fragColor.rgb,vec3(.1),step(t.y,0.)*step(min(abs(t.x),abs(t.y)),.004));\n    }\n\n    fragColor.rgb=sqrt(max(fragColor.rgb,0.));\n}","name":"Image","description":"","type":"image"}]}