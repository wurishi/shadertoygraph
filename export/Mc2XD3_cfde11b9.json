{"ver":"0.1","info":{"id":"Mc2XD3","date":"1706984453","viewed":183,"name":"The Phased Array","username":"zeroDarkThirty","description":"given N emitters, solve for their phase so each wave peak meets the target. \n\nhttps://en.wikipedia.org/wiki/Phased_array\nReal world applications with wireless comm etc.\ninspired from the channel https://www.youtube.com/@DavesSpace/videos\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["waves","travelingwaves","phasedarrays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat antenna( float l ){return pow(0.01/l, 2.);}\n\nvec2 emitter( float l, float phi )\n// doesnt really need to be vec2, could return just f as a float\n// f.x and f.y just have values the vary a little from o1 and o2\n{\n    vec2 f;\n    float o1 = sin(t)/250.;\n    float o2 = sin(t + pi)/250.;\n    // assumes i <> 5 will cover the screen, dependent on float lambda(c,t)\n    for(float i = 0.; i<5.; i+=1.) {\n        float r = i*lambda + mod(phi + c*t,lambda);\n        f.x += intensity/(abs(l - r - o1));\n        f.y += intensity/(abs(l - r - o2));\n    }\n    return f;\n}\n\n\nfloat basicShape( vec2 pos, int sides, float size )\n{\n    //https://www.shadertoy.com/view/XlBBWt\n    float x = cos(pi*t)*pos.x  - sin(pi*t)*pos.y;\n    float y = sin(pi*t)*pos.x  + cos(pi*t)*pos.y;\n    float a = atan(x,y)+pi;\n    float r = tau/float(sides);\n    float d = cos(floor(.5+a/r)*r-a)*length(pos* 1./size);\n    return (1.0-smoothstep(.4,.41,d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec2 e;\n    float ar = iResolution.x/iResolution.y;\n    \n    // --- mouse stuff --- //\n    float mx = ar*(2.*iMouse.x/iResolution.x - 1.);\n    float my = (2.*iMouse.y/iResolution.y - 1.);\n    e += basicShape(uv - vec2(mx,my),3,.05);\n\n    for(float i = 0.; i<emitters; i+=1.)\n    {\n    \n        // --- line on x --- //\n        float ex = (stepX*i+startX);\n        vec2 pos = uv - vec2(ar*ex,0.);\n        float len = length(pos)+.001;\n        float phi = length(vec2(ar*ex,0.) - vec2(mx,my));\n        \n        // --- diag --- //\n        //float ex = (stepX*i+startX);\n        //vec2 pos = uv - vec2(ar*ex,ex);\n        //float len = length(pos)+.001;\n        //float phi = length(vec2(ar*ex,ex) - vec2(mx,my));\n        \n        \n        // --- circle --- //\n        //float ex = 0.2*cos(i*tau*1./(emitters));\n        //float ey = ar*0.2*sin(i*tau*1./(emitters)); \n        //vec2 pos = uv - vec2(ar*ex,ey);\n        //float len = length(pos)+.001;\n        //float phi = length(vec2(ar*ex,ey) - vec2(mx,my));\n\n        \n        // --- plot --- //\n        e += emitter(len,phi);\n        e += vec2(antenna(len));\n    }\n    \n    color += (e.x) * vec3(0.3, 0.2, sin(t) * 0.3) + (e.y) * vec3(sin(t+3.141) * 0.3, 0.2, 0.3);\n\tfragColor = vec4(color, e.x+e.y);;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// --- ex1 customize --- ///\n//# define emitters 10.\n//# define t .5*iTime\n//# define c 0.25        //speed of light\n//# define freq 0.5      //frequency of light\n//# define lambda c/freq\n//# define intensity 1.0/200.\n\n\n\n//// --- ex2 customize --- ///\n# define emitters 100.\n# define t .5*iTime\n# define c 0.25        //speed of light\n# define freq 0.1      //frequency of light\n# define lambda c/freq\n# define intensity 1.5/1000.\n\n\n\n\n\n// dont customize\n# define pi 3.141592654\n# define tau 2.*pi\n# define stepX (lambda/2.0)/(emitters-1.0)\n# define startX -lambda/4.0","name":"Common","description":"","type":"common"}]}