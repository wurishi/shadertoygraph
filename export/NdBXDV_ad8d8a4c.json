{"ver":"0.1","info":{"id":"NdBXDV","date":"1621153483","viewed":93,"name":"Cubemap metaballs","username":"seven_dc","description":"Raymarching rolling wave with cubemap metabalzz","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waves","raymarch"],"hasliked":0,"parentid":"fd2XDz","parentname":"Waves of ball sea"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 40\n#define MAX_DIST 50.\n#define SURF_DIST .01\n#define CLOSE_SURF_DIST .1\n\nfloat smin( float a, float b, float k ) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 GetDistance(vec3 point) {\n\t\n    float texture = sin((iTime + point.x)*.2)*2.4+\n        sin((iTime + point.x)*.25)*1.1+\n        sin(point.z*2.5+sin(iTime)*.1)*.15+\n        sin(point.x*5.+point.z*.015)*.41;\n    \n    float planeDist = point.y + texture*.5;\n    \n    vec4 sphere = vec4(1., 1.+cos(iTime+point.y)*.1, 1.5, 0.5-sin(point.x+point.z+iTime)*.1);\n    vec3 spoint = vec3(mod(point.x, 2.), point.y, mod(point.z, 3.));\n    float sphereDist =  length(spoint-sphere.xyz)-sphere.w;\n    \n    return vec2(smin(planeDist, sphereDist, .9), planeDist <= sphereDist ? 1 : 0);\n}\n\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point).x;\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy).x,\n      GetDistance(point-e.yxy).x,\n      GetDistance(point-e.yyx).x);\n  \n  return normalize(normal);\n}\n\nvec3 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    int c = 0; // close of surface\n    vec2 dist = vec2(0.);\n    \n    for(int i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        dist = GetDistance(point);\n        float surfaceDistance = dist.x;\n        distance += surfaceDistance;\n        \n        if (distance<CLOSE_SURF_DIST) c++;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec3(distance,c, dist.y);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  vec3 d = RayMarch(point+normal*.1, direction);\n  if ( d.x < length(lightPos-point)) {\n      dif *= .5;\n  } else {\n      dif -= d.y*.01;\n  }\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0.-sin(iTime*.1), 3.5, 0);\n    vec3 rayDirection = normalize(vec3(uv.x-sin(iTime*.1), uv.y-0.45, 1));\n\n    vec3 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = texture(iChannel0, rayDirection).rgb;\n    \n    vec3 lightPos = vec3(1.-sin(iTime*.1), 5.5, 1);\n    \n    if (d.x < 50.) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        float dist = d.x/36.;\n        col = vec3(\n            light*0.9-dist,\n            light*0.9-dist/1.5+(d.y*20.04),\n            light-dist/2.5+(d.y*20.8)\n        );\n        if (d.z == 0.) {\n            vec3 r = reflect(rayDirection, n);\n            vec3 refTex = texture(iChannel0, r).rgb;\n            \n            col = col*0.7 + refTex*0.7;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}