{"ver":"0.1","info":{"id":"tlScRd","date":"1595158974","viewed":69,"name":"Raymarch Tests","username":"Sassages","description":"Test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 100.0\n#define CLOSE_ENOUGH .01\n#define EPSILON .01\n#define SMOOTH_FACTOR 2.5\n\nvoid TRS (vec3 T, vec3 R, vec3 S)\n{\n    mat4 scale = mat4(S.x, 0, 0, 0,\n                       0, S.y, 0, 0,\n                       0, 0, S.z, 0,\n                       0, 0, 0, 1);\n    \n    float a = radians(R.x);\n    mat4 rotateX = mat4(1, 0, 0, 0,\n                        0, cos(a), -sin(a), 0,\n                        0, sin(a), cos(a), 0,\n                        0, 0, 0, 1);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat smoothMin(float dstA, float dstB, float k)\n{\n    float h = max(k - abs(dstA - dstB), .0) / k;\n    return min(dstA, dstB) - h * h * h * k * 1./6.;\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, .0, 1.);\n}\n\nvec3 saturate(vec3 v)\n{\n    return vec3(saturate(v.x), saturate(v.y), saturate(v.z));\n}\n\nfloat getNearestDistance(vec3 point)\n{\n    // sphere\n    float radius = 2.0;\n    vec3 pos = vec3(0, 2, 5);\n    float sphereDist = sdSphere(pos - point, radius);\n    \n    // box\n    pos = vec3(4. * sin(iTime), 2, 5);\n    vec3 dimensions = vec3(.9, .9, 1.8);\n    float boxDist = sdBox(pos - point, dimensions);\n    \n    // floor\n    float floorDist = point.y;\n    \n    float min1 = smoothMin(sphereDist, boxDist, SMOOTH_FACTOR);\n    //float min1 = min(sphereDist, boxDist);\n    \n    return min(min1, floorDist);\n}\n\nvec3 surfaceNormal( vec3 point )\n{\n    float leftDist = getNearestDistance(point - vec3(EPSILON, 0, 0));\n    float rightDist = getNearestDistance(point + vec3(EPSILON, 0, 0));\n    \n    float upDist = getNearestDistance(point + vec3(0, EPSILON, 0));\n    float downDist = getNearestDistance(point - vec3(0, EPSILON, 0));\n    \n    float forwardDist = getNearestDistance(point + vec3(0, 0, EPSILON));\n    float backwardDist = getNearestDistance(point - vec3(0, 0, EPSILON));\n    \n    return normalize(vec3(rightDist - leftDist, upDist - downDist, forwardDist - backwardDist));\n}\n\nfloat raymarch( vec3 origin, vec3 direction )\n{\n    float dist = 0.0;\n    \n    \n    while(dist < MAX_DISTANCE)\n    {\n        float step = getNearestDistance(origin);\n        dist += step;\n        \n        if(step < CLOSE_ENOUGH)\n            return dist;\n        \n        origin += step * direction;\n    }\n    \n    return MAX_DISTANCE;\n}\n\nfloat calcShadow( vec3 point, vec3 lightDir )\n{\n    vec3 normal = surfaceNormal(point);\n    vec3 origin = point + normal * CLOSE_ENOUGH * 2.;\n    \n    float distToLight = raymarch(origin, -lightDir);\n    \n    if(distToLight >= MAX_DISTANCE)\n        return 1.;\n    else\n        return 0.;\n}\n\nvec3 calcLightingForLight(vec3 normal, vec3 diffuseColor, vec3 lightDir, vec3 point, vec3 viewDir)\n{    \n    // Diffuse\n    float diffuseIntensity = 0.4;\n    vec3 diffuse = saturate(vec3(dot(-lightDir, normal))) * diffuseIntensity * diffuseColor;\n    \n    // Specular\n    vec3 halfVec = normalize(-viewDir - lightDir);\n    float power = 50.0;\n    vec3 specular = vec3(pow(saturate(dot(halfVec, normal)), power)) * 0.5;\n\n    return diffuse + specular;\n}\n\nvec3 calcLighting( vec3 point, vec3 viewDir )\n{\n    vec3 normal = surfaceNormal(point);\n    vec3 diffuseColor = vec3(0.3, 1.0, 0.3);\n    \n    // Light 1 - moving\n    vec3 lightDir = normalize(vec3(sin(iTime), -1, cos(iTime)));\n    vec3 light1 = calcLightingForLight(normal, diffuseColor, lightDir, point, viewDir);\n    float shadow = calcShadow(point, lightDir);\n    \n    // Light 2 - static\n    lightDir = normalize(vec3(-1., .8, 0.2));\n    vec3 light2 = calcLightingForLight(normal, diffuseColor, lightDir, point, viewDir) * 0.7;\n    \n    // Ambient\n    vec3 ambient = vec3(0.3) * diffuseColor;\n    \n    return shadow * (light1 + light2) + ambient;\n}\n\nvec3 calcDirection(vec2 fragCoord, float vertFOV)\n{\n    vec2 centeredCoords = fragCoord - iResolution.xy / 2.0;\n    float z = 0.5 * iResolution.y * tan(radians(0.5 * vertFOV));\n    \n    return normalize(vec3(centeredCoords, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayOrigin = vec3(0, 3, 0);\n    vec3 rayDirection = calcDirection(fragCoord, 90.0);\n    \n    float pixelDistance = raymarch(rayOrigin, rayDirection);\n    if(pixelDistance >= MAX_DISTANCE)\n    {\n        float grad = rayDirection.y * .7;\n        fragColor = vec4(.2,.6,1.,1) + grad;\n        return;\n    }\n\n    vec3 point = rayOrigin + rayDirection * pixelDistance;\n    vec3 col = calcLighting(point, rayDirection);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}