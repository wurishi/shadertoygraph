{"ver":"0.1","info":{"id":"4clcWB","date":"1721552676","viewed":78,"name":"Traversing Valhalla","username":"TamagoSan","description":"Based on original code from MobileForks01\nhttps://www.shadertoy.com/view/XtyXz1","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","psychedelic","tunnels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n//uniform vec2 resolution;\n//uniform float time;\n//uniform vec4 mouse;\n//uniform vec4 date;\n//uniform vec3 orientation;\n\nfloat sddistance = 0.1;\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.04, 0.036, 0.029);\n    vec3 b = vec3(0.1, 0.0873, 0.0942);\n    vec3 c = vec3(0.124, 0.167, 0.187);\n    vec3 d = vec3(0.2*sin(iTime*0.5));\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n\n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\n    vec3 pos = vec3\n        (\n            (position.x + 1.0 * sin(iTime)) - 2.0,\n            position.y + 1.0 * cos(iTime),\n            position.z - 1.5\n        );\n\n    vec3 pos2 = vec3\n        (\n            (position.x + 1.0 * sin(iTime)) - 2.0,\n            position.y + 1.0 * cos(iTime),\n            position.z - 1.5\n        );\n    vec3 pos3 = vec3\n        (\n            position.x + 45.,\n            position.y - 52. - iTime * 3.,\n            position.z + 55.0\n        );\n    //vec3 pos3 = vec3(position.x + 1.8 * sin(iTime - 3.3) + 0.2, position.y + 1.8 * cos(iTime - 3.3), position.z - 0.5);\n\n    vec3 floorPos = vec3\n        (\n            position.x,\n            position.y + 10.0,\n            position.z - 4.0 * iTime\n        );\n\n    vec3 wallPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z + 5.0 - 4.0 * iTime\n        );\n\n    vec3 roofPos = vec3\n        (\n            position.x,\n            position.y - 30.0 + 10.0 * sin(iTime),\n            position.z - 25.0 - 4.0 * iTime\n        );\n\n    pos3 = repeatPos(pos3, vec3(15,3.,9.));\n\n    //float dis1 = sdSphere(pos, 2.0);\n\n    //float dis2 = sdSphere(pos2, 1.33);\n    //float dis2 = sdBox(pos2, vec3(1.5, 1.5, 1.5));\n    float floorDis = sdBox(floorPos, vec3(600, 1, 600));\n    float wallDis = sdBox(wallPos, vec3(600, 600, 1));\n    float roofDis = sdBox(roofPos, vec3(600, 1, 600));\n\n\n   // float sphereDis = sdSphere(pos3, 1.);\n    float sphereDis = sdBox(pos3, vec3(1.0 - 0. *sin(iTime*0.4)));\n\n\n    // distance = smin(dis1, dis2, 1.0);\n    float distance = smin(floorDis, sphereDis, 1.0);\n\n    distance = smin(distance, floorDis, sddistance * 2.0);\n    distance = smin(distance, roofDis, sddistance * 3.0);\n    distance = min(distance, wallDis);\n\n\n\n    //return dis1;\n    return distance;\n    //return dis3;\n\n\n    //return sdSphere(pos, 2.0);\n    //Repeat shape\n\t//vec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n\n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\n    //Draw spheres\n\t//return sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.001;\n\tfloat f0 = getDistance(position);\n\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\n\n\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t0.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t10.0, //+ 12.0*sin(iTime*2.0),\n           // -55.0\n           -40.0 + iTime * 4.0 - 15.0 * sin(iTime*2.0)\n\n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n        \n\tvec3 lightPosition2 = vec3\n\t\t(\n\t\t\t-25.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t10.0, //+ 12.0*sin(iTime*2.0),\n           // -55.0\n           -40.0 + iTime * 4.0 - 15.0 * -sin(iTime*2.0)\n\n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightPosition3 = vec3\n\t\t(\n\t\t\t25.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t10.0, //+ 12.0*sin(iTime*2.0),\n           // -55.0\n           -40.0 + iTime * 4.0 - 15.0 * -sin(iTime*2.0)\n\n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position) + normalize(lightPosition2 - position) + normalize(lightPosition3 - position);\n    /*\n\tvec4 lightColor = vec4\n        (\n            (sin(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            (sin(iTime / 1.1) + 1.5)/ 25.0 + 0.1,\n            (cos(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n    */\n    vec4 lightColor = vec4\n        ( palette(lightDir.z),\n           //0.13,\n           //0.1,\n           //0.1,\n            //0.5 - tan,\n            //0.5 - 0.5 * sin(time),\n            //0.5 - 0.5 * cos(time),\n            0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir) * 0.4;\n\tfloat reflectance = 0.9;\n\n\tfloat lightDistance = length(position-lightPosition);\n\n    //Hacky but pretty good looking light intensity diminishing over distance\n\t//float distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1)));\n    float distanceIntensity = (10.0 / (pow(lightDistance / 10.0, 1.0001)));\n\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    vec3 eye = vec3(0, 3, iTime * 4.0 - 50.0);\n\n    //Still eye\n\t//vec3 eye = vec3(0, 10, -45);\n\t  //eye.z = -1.0*sin(time);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n\n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 10000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\n\n    //Variables needed for ray marching this pixel\n    float focalLength = 0.2;\n    vec3 forward = normalize(cross(right, up));\n\n    vec3 planePos = right * uv.x + up * uv.y;\n\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t);\n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n\n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}