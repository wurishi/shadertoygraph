{"ver":"0.1","info":{"id":"lsKXDW","date":"1464548541","viewed":236,"name":"Plasma Box","username":"sillsm","description":"Plasma Cube","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","plasmaeffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n// Plasma cube.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\naxis = normalize(axis);\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Derived from http://www.bidouille.org/prog/plasma\nfloat plasma2 (vec2 uv)\n{\n    uv *= 2.;\n    float v = sin((uv.x+iTime));\n    v += sin((uv.y+iTime)/2.0);\n    v += sin((uv.x+uv.y+iTime)/2.0);\n    vec2 c = uv/2.0 * vec2(sin(iTime/3.0), cos(iTime/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+iTime);\n    v = v/2.0;\n    return v;\n}\n\n// Rounded box with a plasma displacement.\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  float dist = max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p)));\n  return dist - plasma2(5.*p.xy)/6.;\n}\n\nvec4 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\t\t\t\t\n        float dist = udBox(p, vec3(1,1,1));\n        t += dist * .9;\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    // Rotate the viewer position (near clipping plane center).\n    vec3 position = qRotate(vec3(0,1.,0.),iTime/2. + 4.*mo.x,vec3(0.), vec3(0, 5.*mo.y, -5));\n    \n    mat4 mat = LookAtRH(position, vec3(0,0,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    vec4 tr     = trace(ray, pt);\n    float t     = tr.w;\n    float v = plasma2(5.*tr.xy);\n        \n    vec3 col = 5.*(1./t)*vec3(1, sin(3.14*v), cos(3.14*v));\n    col *= .8; // Gamma correction.\n    fragColor = vec4(col, 0);\n    if (length(col) < .05) {\n        float v2 = plasma2(uv*20.);\n        col = 5.*vec3(sin(v2), sin(v2 + iTime), sin(v2+7.));\n    }\n     fragColor = vec4(col, 0);\n}","name":"Image","description":"","type":"image"}]}