{"ver":"0.1","info":{"id":"NlcBDn","date":"1662878718","viewed":80,"name":"complex plot: exponential","username":"vivavolt","description":"based on \nhttps://hturan.com/writing/complex-numbers-glsl\nhttps://www.dynamicmath.xyz/domain-coloring/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"NtcBDn","parentname":"complex plot: arctan"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cx_arg(a) atan(a.y, a.x)\n\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n\n#define cx_mul(a, b) vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y)),((a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y)))\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n\nfloat sharp = 0.39; // delay\nfloat b = 0.655; // brightness 0 -> dark, 1 -> bright\nfloat nMod = 2.; // num of level curves mod\nfloat nPhase = 20.; // num. of level curves phase\nfloat base = 2.; // For the base of a logarithm\nfloat nContour = 16.;\n\nvec2 as_polar(vec2 z) {\n  return vec2(\n    length(z),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\nvec2 cx_log(vec2 a) {\n    vec2 polar = as_polar(a);\n    float rpart = polar.x;\n    float ipart = polar.y;\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\nvec2 cx_pow(vec2 v, float p) {\n  vec2 z = as_polar(v);\n  return pow(z.x, p) * vec2(cos(z.y * p), sin(z.y * p));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos(2. * PI *(c*t+d) );\n}\n\nfloat funPhase(vec2 p) {\n    return (PI - atan(p.y, -p.x)) / (2. * PI);\n}\n\nfloat funColor(vec2 p) {\n    return sharp * (nContour * (PI - atan(p.y, -p.x)) / (2. * PI) -  floor(nContour * (PI - atan(p.y, -p.x)) / (2. * PI))) + 0.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 z = uv;\n    float angle = sin(iTime/5.) * TAU;\n    float length = .2;\n  \n    // Spin our points in a circle of radius length\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 p = vec2( s*length, c*length);\n    vec2 q = vec2( s*-length, c*-length );\n    \n    vec2 res = c_exp(c_div(vec2(1., 0.),(z + vec2(0.01*sin(iTime),0.01*cos(iTime)))) + vec2(1., iTime));\n   \n\n    vec3 col = palette(5. + 0.15*funPhase(res) * (12. * cos(3.*cos(iTime / 10.) + PI/2.3)), vec3(0.50,.52,0.53), vec3(.46,.32,.35), vec3(.82,.84,.65), vec3(0.53,0.23,0.22));\n    vec3 hsv = rgb2hsv(col);\n    col = vec3(hsv.r, hsv.b, hsv.g);\n    //col = vec3(funPhase(res), 1., funColor(res));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://github.com/anvaka/pplay/blob/master/src/util/shaders/complex.glsl\n// based on https://github.com/rust-num/num-complex/blob/master/src/lib.rs\n// Copyright 2013 The Rust Project Developers. MIT license\n// Ported to GLSL by Andrei Kashcha (github.com/anvaka), available under MIT license as well.\n\n\n// Returns a complex number z = 1 + i * 0.\nvec2 c_one() { return vec2(1., 0.); }\n\n// Returns a complex number z = 0 + i * 1.\nvec2 c_i() { return vec2(0., 1.); }\n\nfloat arg(vec2 c) {\n  return atan(c.y, c.x);\n}\n\n// Returns conjugate of a complex number.\nvec2 c_conj(vec2 c) {\n  return vec2(c.x, -c.y);\n}\n\nvec2 c_from_polar(float r, float theta) {\n  return vec2(r * cos(theta), r * sin(theta));\n}\n\nvec2 c_to_polar(vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n// Computes `e^(c)`, where `e` is the base of the natural logarithm.\nvec2 c_exp(vec2 c) {\n  return c_from_polar(exp(c.x), c.y);\n}\n\n\n// Raises a floating point number to the complex power `c`.\nvec2 c_exp(float base, vec2 c) {\n  return c_from_polar(pow(base, c.x), c.y * log(base));\n}\n\n// Computes the principal value of natural logarithm of `c`.\nvec2 c_ln(vec2 c) {\n  vec2 polar = c_to_polar(c);\n  return vec2(log(polar.x), polar.y);\n}\n\n// Returns the logarithm of `c` with respect to an arbitrary base.\nvec2 c_log(vec2 c, float base) {\n  vec2 polar = c_to_polar(c);\n  return vec2(log(polar.r), polar.y) / log(base);\n}\n\n// Computes the square root of complex number `c`.\nvec2 c_sqrt(vec2 c) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(sqrt(p.x), p.y/2.);\n}\n\n// Raises `c` to a floating point power `e`.\nvec2 c_pow(vec2 c, float e) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(pow(p.x, e), p.y*e);\n}\n\n// Raises `c` to a complex power `e`.\nvec2 c_pow(vec2 c, vec2 e) {\n  vec2 polar = c_to_polar(c);\n  return c_from_polar(\n     pow(polar.x, e.x) * exp(-e.y * polar.y),\n     e.x * polar.y + e.y * log(polar.x)\n  );\n}\n\n// Computes the complex product of `self * other`.\nvec2 c_mul(vec2 self, vec2 other) {\n    return vec2(self.x * other.x - self.y * other.y, \n                self.x * other.y + self.y * other.x);\n}\n\nvec2 c_div(vec2 self, vec2 other) {\n    float norm = length(other);\n    return vec2(self.x * other.x + self.y * other.y,\n                self.y * other.x - self.x * other.y)/(norm * norm);\n}\n\nvec2 c_sin(vec2 c) {\n  return vec2(sin(c.x) * cosh(c.y), cos(c.x) * sinh(c.y));\n}\n\nvec2 c_cos(vec2 c) {\n  // formula: cos(a + bi) = cos(a)cosh(b) - i*sin(a)sinh(b)\n  return vec2(cos(c.x) * cosh(c.y), -sin(c.x) * sinh(c.y));\n}\n\nvec2 c_tan(vec2 c) {\n  vec2 c2 = 2. * c;\n  return vec2(sin(c2.x), sinh(c2.y))/(cos(c2.x) + cosh(c2.y));\n}\n\nvec2 c_atan(vec2 c) {\n  // formula: arctan(z) = (ln(1+iz) - ln(1-iz))/(2i)\n  vec2 i = c_i();\n  vec2 one = c_one();\n  vec2 two = one + one;\n  if (c == i) {\n    return vec2(0., 1./1e-10);\n  } else if (c == -i) {\n    return vec2(0., -1./1e-10);\n  }\n\n  return c_div(\n    c_ln(one + c_mul(i, c)) - c_ln(one - c_mul(i, c)),\n    c_mul(two, i)\n  );\n}\n\nvec2 c_asin(vec2 c) {\n // formula: arcsin(z) = -i ln(sqrt(1-z^2) + iz)\n  vec2 i = c_i(); vec2 one = c_one();\n  return c_mul(-i, c_ln(\n    c_sqrt(c_one() - c_mul(c, c)) + c_mul(i, c)\n  ));\n}\n\nvec2 c_acos(vec2 c) {\n  // formula: arccos(z) = -i ln(i sqrt(1-z^2) + z)\n  vec2 i = c_i();\n\n  return c_mul(-i, c_ln(\n    c_mul(i, c_sqrt(c_one() - c_mul(c, c))) + c\n  ));\n}\n\nvec2 c_sinh(vec2 c) {\n  return vec2(sinh(c.x) * cos(c.y), cosh(c.x) * sin(c.y));\n}\n\nvec2 c_cosh(vec2 c) {\n  return vec2(cosh(c.x) * cos(c.y), sinh(c.x) * sin(c.y));\n}\n\nvec2 c_tanh(vec2 c) {\n  vec2 c2 = 2. * c;\n  return vec2(sinh(c2.x), sin(c2.y))/(cosh(c2.x) + cos(c2.y));\n}\n\nvec2 c_asinh(vec2 c) {\n  // formula: arcsinh(z) = ln(z + sqrt(1+z^2))\n  vec2 one = c_one();\n  return c_ln(c + c_sqrt(one + c_mul(c, c)));\n}\n\nvec2 c_acosh(vec2 c) {\n  // formula: arccosh(z) = 2 ln(sqrt((z+1)/2) + sqrt((z-1)/2))\n  vec2 one = c_one();\n  vec2 two = one + one;\n  return c_mul(two,\n      c_ln(\n        c_sqrt(c_div((c + one), two)) + c_sqrt(c_div((c - one), two))\n      ));\n}\n\nvec2 c_atanh(vec2 c) {\n  // formula: arctanh(z) = (ln(1+z) - ln(1-z))/2\n  vec2 one = c_one();\n  vec2 two = one + one;\n  if (c == one) {\n      return vec2(1./1e-10, vec2(0.));\n  } else if (c == -one) {\n      return vec2(-1./1e-10, vec2(0.));\n  }\n  return c_div(c_ln(one + c) - c_ln(one - c), two);\n}\n\n// Attempts to identify the gaussian integer whose product with `modulus`\n// is closest to `c`\nvec2 c_rem(vec2 c, vec2 modulus) {\n  vec2 c0 = c_div(c, modulus);\n  // This is the gaussian integer corresponding to the true ratio\n  // rounded towards zero.\n  vec2 c1 = vec2(c0.x - mod(c0.x, 1.), c0.y - mod(c0.y, 1.));\n  return c - c_mul(modulus, c1);\n}\n\nvec2 c_inv(vec2 c) {\n  float norm = length(c);\n\treturn vec2(c.x, -c.y) / (norm * norm);\n}","name":"Common","description":"","type":"common"}]}