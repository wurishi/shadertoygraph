{"ver":"0.1","info":{"id":"XtsXzN","date":"1435134301","viewed":330,"name":"Implicit ray cast","username":"Ultraviolet","description":"Casting a ray toward an implicit surface is fun !","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","implicitsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n\n#define PI 3.1415972\n\nconst float dMin = 0.0;\nconst float dMax = 500.0;\nconst float stp = .05;\n\n\n#define evol iTime * 0.2\n#define centre1  vec3(sin(evol * PI))\n#define centre2  vec3(sin(evol * PI + PI))\nfloat radius1 = 1.0;\nfloat radius2 = 1.0;\nvec3 color1 = vec3(1,0,0);\nvec3 color2 = vec3(0,0,1);\n\n\nvec3 lightDir = normalize(vec3(0, -1, -0.3));\n\n\nfloat spherePotential(vec3 pos, vec3 centre, float radius)\n{\n    float dist = length(pos - centre);\n    \n    return radius / dist - 1.0;\n}\n\nvec3 sphereNormal(vec3 pos, vec3 centre)\n{\n    return normalize(pos - centre);\n}\n\n\nfloat objectPotential(vec3 pos)\n{\n    return \n          spherePotential(pos, centre1, radius1) \n        + spherePotential(pos, centre2, radius2);\n}\n\nvec3 objectNormal(vec3 pos)\n{\n    float w1 = spherePotential(pos, centre1, radius1) + 1.0;\n    float w2 = spherePotential(pos, centre2, radius2) + 1.0;\n    \n    return normalize(\n          sphereNormal(pos, centre1) * w1\n        + sphereNormal(pos, centre2) * w2);\n}\n\nbool isInsideObject(vec3 pos)\n{\n    if(objectPotential(pos) > 0.0)\n    \treturn true;\n    \n    return false;\n}\n\n\nvec3 objectColor(in vec3 pos)\n{\n    float t = abs(dot(objectNormal(pos), lightDir)) * 0.8 + 0.2;\n    \n    float w1 = spherePotential(pos, centre1, radius1) + 1.0;\n    float w2 = spherePotential(pos, centre2, radius2) + 1.0;\n    \n    vec3 color = (w1 * color1 + w2 * color2) / (w1 + w2);\n    \n    //return vec3(1.0) * t;\n    return color * t;\n}\n\nvec3 skyColor(in vec3 ro, in vec3 rd)\n{\n    return abs(rd);\n    \n    float latitude = acos(length(rd.xy)) / PI;\n    float longitude = acos(length(rd.x) / length(rd.xy)) / 2.0 / PI;\n    \n    return vec3(latitude, longitude, 0.5);\n}\n\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{    \n    for(float d = dMin; d < dMax; d += stp)\n    {\n        vec3 pos = ro + d * rd;\n        if(isInsideObject(pos))\n        {\n            return objectColor(pos);\n        }\n    }\n    \n    return skyColor(ro, rd);\n}\n\nmat3 idMatrix()\n{\n    return mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n}\n\nmat3 crossProdMatrix(in vec3 v)\n{\n    return mat3(\n         0.0, -v.z,  v.y,\n    \t v.z,  0.0, -v.x,\n    \t-v.y,  v.x,  0.0);\n}\n\nmat3 tensProdMatrix(in vec3 v)\n{\n    return mat3(\n        v.x * v.x, v.y * v.x, v.z * v.x,\n    \tv.x * v.y, v.y * v.y, v.z * v.y,\n    \tv.x * v.z, v.y * v.z, v.z * v.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    return idMatrix() * cos(angle) + crossProdMatrix(axis) * sin(angle) + tensProdMatrix(axis) * (1.0 - cos(angle));\n}\n\nmat3 polarTransformation(float longitude, float latitude)\n{\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n    vec3 Z = vec3(0,0,1);\n    \n    mat3 m = rotationMatrix(Z, longitude);\n    Y = m * Y;\n    \n    m = rotationMatrix(Y, latitude) * m;\n    X = m * X;\n    Z = m * Z;\n    \n    return mat3(X, Y, Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro = vec3(0, -5, 0); // ray origin\n    \n    float longitude = iMouse.x / iResolution.x * 2.0 * PI;//0.0;//\n    float latitude = iMouse.y / iResolution.y * PI - 0.5 * PI;\n    \n    mat3 m = polarTransformation(longitude, latitude);\n    \n    vec3 X = m * vec3(1,0,0);\n    vec3 Y = m * vec3(0,1,0);\n    vec3 Z = m * vec3(0,0,1);\n    \n    ro = -X * 5.0;\n    \n    float ratio = iResolution.x / iResolution.y;\n    float angle = PI * 0.5;\n    \n    float alpha_d = (fragCoord.x / iResolution.x - 0.5) * angle;\n    float beta_d  = (fragCoord.y / iResolution.y - 0.5) * angle / ratio;\n    \n    \n    mat3 m2 = polarTransformation(alpha_d, beta_d);\n    \n    vec3 rd = m * m2 * vec3(1,0,0);\n    \n    vec3 col = castRay(ro, rd);\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}