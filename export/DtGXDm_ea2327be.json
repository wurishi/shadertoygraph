{"ver":"0.1","info":{"id":"DtGXDm","date":"1694424532","viewed":44,"name":"Konod's dithering test","username":"Konod","description":"Just tryin' to apply dithering to falling spheres. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","periodic","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//You can try to change the default shape \n\n//#define BOX;\n//#define SHADOWBOX;\n#define SPHERE;\n\nconst mat4 ditheringMatrix = mat4(\n    0.f, 12.f, 3.f, 15.f,\n    8.f, 4.f, 11.f, 7.f,\n    2.f, 14.f, 1.f, 13.f,\n    10.f, 6.f, 9.f, 5.f\n)*0.0625;\n    \n    \nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nvec3 centered(vec3 pos, vec3 repeat) {\n    return mod(pos + repeat * 0.5, repeat) - repeat * 0.5;\n}\n\nvec3 rotation(vec3 pos, float theta, float omega) {\n    float cT = cos(theta);\n    float sT = sin(theta);\n    float cO = cos(omega);\n    float sO = sin(omega);\n    vec3 rotT = mat3(cT, 0.0, sT,\n                    0.0, 1.0, 0.0,\n                    -sT, 0.0, cT) * pos;\n    vec3 rotO = mat3(1.0, 0.0, 0.0,\n                    0.0, cO, sO,\n                    0.0, -sO, cO) * rotT;\n    return rotO;\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size) {\n    vec3 diff = abs(pos) - size;\n    return length(max(diff, 0.0)) + vmax(min(diff, 0.0));\n}\n\nfloat hollowBox(vec3 pos, vec3 sizeM, vec3 sizem) {\n    vec3 diffM = abs(pos) - sizeM;\n    vec3 diffm = abs(pos) - sizem;\n    return length(max(diffM, 0.0)) + vmax(min(diffm, 0.0));\n}\n\nfloat de ( vec3 p ) {\n    float s = 3.0f, e;\n    for ( int i = 0; i++ < 8; ) {\n      p = mod( p - 1.0f, 2.0f ) - 1.0f;\n      s *= e = 1.4f / dot( p, p );\n      p *= e;\n    }\n    return length( p.yz ) / s;\n  }\n\nfloat map(vec3 pos) {\n    vec3 centeredPos = centered(pos, vec3(10.0, 10.0, 10.0));\n    vec3 rotatedPos = rotation(centeredPos, iTime * 0.2, iTime * 0.3 + 1.);\n#ifdef BOX\n    return box(rotatedPos, vec3(1.0));\n#endif\n#ifdef HOLLOWBOX\n    return hollowBox(rotatedPos, vec3(1.0), vec3(0.5));\n#endif\n#ifdef SPHERE\n    return sphere(rotatedPos, 1.);\n#endif\n    return 0.f;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 delta = vec2(0.01, 0.0);\n    return normalize(vec3(\n        (map(pos + delta.xyy) - map(pos - delta.xyy)),\n        (map(pos + delta.yxy) - map(pos - delta.yxy)),\n        (map(pos + delta.yyx) - map(pos - delta.yyx))\n        ));\n}\n\nvec2 modI(vec2 a,float b) {\n    vec2 m=a-floor((a+0.5)/b)*b;\n    return floor(m+0.5);\n}\n\nbool dithering(float lightning, vec2 xy) {\n    float minLight = 0.1;\n    float maxLight = 0.9;\n    float lightStep = (maxLight - minLight);\n    \n    xy = modI(xy, 4.);\n\n    if (lightning > minLight + ditheringMatrix[int(xy.x)][int(xy.y)]*lightStep) {\n        return true;\n    }\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 camera = vec3(sin(iTime * 2.0) * 0.3 + 5.0, cos(iTime * 1.5) * 0.3 + 2.0, iTime * 2.0);\n    vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec3 pos = camera;\n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 color = vec3(0.9, 0.9, 0.9);\n    float lightning;\n    for (int i = 0; i < 100; i++) {\n        float d = map(pos);\n        if (d < 0.01) {\n            lightning = dot(normal(pos), -lightDirection);\n            \n            color = vec3(0.9, 0.9, 1.) * vec3(dithering(lightning, fragCoord));\n            break;\n        }\n        pos += d * dir;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}