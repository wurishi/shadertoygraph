{"ver":"0.1","info":{"id":"wds3zn","date":"1544816195","viewed":291,"name":"yet another terrain generation","username":"skaplun","description":"Decrease GRID_STEP to make terrain more smooth. Shadows need to be added.\nInspired by Shiffman's coding challenge","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","terrain","perlin","animation","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightPos = vec3(500., 300., 0.);\nconst vec3 lightColor = vec3(177., 23., 52.)/255.;\n\n//Humbly borrowed from iq\nfloat noise(in vec2 x){\n    vec2 p = floor(x),\n         f = fract(x);\n    f = f*f*(3.-2.*f);\n\treturn textureLod(iChannel0, (p+0.5+f)/256., 0.).x;\n}\n\n\nvec3 shadeSurphace(vec3 pos, vec3 normal){\n\tvec3 norm = normalize(normal);\n\tvec3 lightDir = normalize(lightPos - pos);\n    float diff = max(dot(norm, lightDir), 0.0);\n    return (diff + .2) * lightColor;\n}\n\nvec3 clrInside(in float lmin, in float lmax, const in Ray inray){\n    Ray2D projectedRay = Ray2D(inray.origin.xz, normalize(inray.dir.xz));\n    vec3 intersection = inray.origin + inray.dir * (lmin + .01);\n    vec2 cellOrigin = vec2(intersection.x, intersection.z);\n    cellOrigin -= mod(cellOrigin, vec2(GRID_STEP));\n    \n    for(int i=0; i<100; i++){\n        float min_dist = MAX_FLOAT;\n        bool hit_smthn = false;\n        float dist = MAX_FLOAT;\n        vec3 norm = vec3(0.);\n        \n        vec3 p0 = vec3(cellOrigin.x, noise(cellOrigin), cellOrigin.y);\n        vec3 p1 = vec3(cellOrigin.x, noise(cellOrigin + vec2(0., GRID_STEP)), cellOrigin.y + GRID_STEP);\n        vec3 p2 = vec3(cellOrigin.x + GRID_STEP, noise(cellOrigin + vec2(GRID_STEP)), cellOrigin.y + GRID_STEP);\n        vec3 p3 = vec3(cellOrigin.x + GRID_STEP, noise(cellOrigin + vec2(GRID_STEP, 0.)), cellOrigin.y);\n        \n        if(rayTriangleIntersect(inray, Triangle(vec3[TRIANG_V_COUNT](p0, p1, p2)), dist) && dist < min_dist){\n        \thit_smthn = true;\n            min_dist = dist;\n            norm = cross(p1 - p0, p2 - p0);\n        }\n        if(rayTriangleIntersect(inray, Triangle(vec3[TRIANG_V_COUNT](p2, p3, p0)), dist) && dist < min_dist){\n        \thit_smthn = true;\n            min_dist = dist;\n            norm = cross(p3 - p2, p0 - p2);\n        }\n\t\t\n        if(hit_smthn)\n            return shadeSurphace(inray.origin + inray.dir * min_dist, norm) * smoothstep(50., 25., min_dist);\n        \n        cellOrigin += getNextCellAlongVec(projectedRay, cellOrigin);\n    }\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime) * 5., 2., 15. + -iTime*10.);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0., 0., -iTime*10.), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float lmin, lmax;\n    \n    if (hit(Ray(eye, worldDir), Plane(vec3(0.), UP), Plane(vec3(0., 1., 0.), UP), lmin, lmax)) {\n        fragColor = vec4(clrInside(lmin, lmax, Ray(eye, worldDir)), 1.);\n    }else{\n    \tfragColor = vec4(vec3(0.), 1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n#define PI 3.1415\n#define EPS .00001\n#define MAX_FLOAT 1e5\n#define UP vec3(0., -1., 0.)\n#define TRIANG_V_COUNT 3\n#define GRID_STEP .2\n\nstruct Ray{vec3 origin, dir;};\nstruct Ray2D{vec2 origin, dir;};\nstruct HitRecord{float dist; vec3 point; vec3 normal;};\nstruct Line{vec2 p0, p1;};\nstruct Plane{vec3 origin, normal;};\nstruct Triangle{vec3 v[TRIANG_V_COUNT];};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nbool testLinesIntersect(const in Line ray, const in Line edge, out float dist){\n    float s1_x = ray.p1.x - ray.p0.x,\n          s1_y = ray.p1.y - ray.p0.y,\n    \t  s2_x = edge.p1.x - edge.p0.x,\n          s2_y = edge.p1.y - edge.p0.y,\n    \t  s = (-s1_y * (ray.p0.x - edge.p0.x) + s1_x * (ray.p0.y - edge.p0.y))\n        \t\t/ (-s2_x * s1_y + s1_x * s2_y);\n    \t  dist = ( s2_x * (ray.p0.y - edge.p0.y) - s2_y * (ray.p0.x - edge.p0.x))\n        \t\t/ (-s2_x * s1_y + s1_x * s2_y);\n\treturn (s >= 0. && s <= 1. && dist >= 0. && dist <= 1.);\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out float dist) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        if(t >= EPS){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit(in Ray inray, in Plane bottom, in Plane top, out float min_dist, out float max_dist){\n    bool hit = plane_hit(inray, top, min_dist);\n    if(hit)\n        plane_hit(inray, bottom, max_dist);\n    return hit;\n}\n\nbool rayTriangleIntersect(const in Ray ray,  const in Triangle triang, out float dist){ \n    vec3 e0 = triang.v[1] - triang.v[0];\n    vec3 e1 = triang.v[2] - triang.v[0];\n\n    vec3 n = cross(e0, e1);\n    float d2 = dot(n, n);\n    vec3 m = n * (1.0 / d2);\n    n = m * sqrt(d2);\n\n    float dot_nd = dot(n, ray.dir);\n    dist = dot(triang.v[0] - ray.origin, n) / dot_nd;\n    vec3 p = ray.origin + dist * ray.dir;\n\n    vec3 b;\n    b.y = dot(cross(p - triang.v[2], e1), m);\n    b.z = dot(cross(e0, p - triang.v[0]), m);\n    b.x = 1.0 - (b.y + b.z);\n\n    return (b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0);\n}\n\nvec2 getNextCellAlongVec(const in Ray2D xzVecProj, const in vec2 curCellOrigin){\n    float maxDist = -1., curDist = -1.;\n    vec2 result = vec2(0.);\n    Line sightLine = Line(xzVecProj.origin, xzVecProj.origin + xzVecProj.dir * 100.);\n    Line front = Line(vec2(curCellOrigin.x, curCellOrigin.y + GRID_STEP), vec2(curCellOrigin.x + GRID_STEP, curCellOrigin.y + GRID_STEP));\n    if(testLinesIntersect(sightLine, front, curDist) && curDist > maxDist){\n    \tmaxDist = curDist;\n        result = vec2(0., GRID_STEP);\n    }\n        \n    \n    Line back = Line(curCellOrigin, vec2(curCellOrigin.x + GRID_STEP, curCellOrigin.y));\n    if(testLinesIntersect(sightLine, back, curDist) && curDist > maxDist){\n        maxDist = curDist;\n        result = vec2(0., -GRID_STEP);\n    }\n    \n    Line left = Line(vec2(curCellOrigin.x, curCellOrigin.y + GRID_STEP), curCellOrigin);\n    if(testLinesIntersect(sightLine, left, curDist) && curDist > maxDist){\n        maxDist = curDist;\n        result = vec2(-GRID_STEP, 0.);\n    }\n    \n    Line right = Line(vec2(curCellOrigin.x + GRID_STEP, curCellOrigin.y + GRID_STEP), vec2(curCellOrigin.x + GRID_STEP, curCellOrigin.y));\n    if(testLinesIntersect(sightLine, right, curDist) && curDist > maxDist){\n        maxDist = curDist;\n        result = vec2(GRID_STEP, 0.);\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}