{"ver":"0.1","info":{"id":"tdX3z4","date":"1545133833","viewed":106,"name":"Sky Claudes","username":"khlorghaal","description":"Something else WIP but I had to publish this\nthe code is a mess i know","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray","sdf","cloud","greenscreen","claude"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 i){\n\treturn length(i)-1.;\n}\n#define SKY_H 1.\nfloat sdf(vec3 i){\n    //i= mods(-i,5.);\n    //i/= .6;\n\treturn SKY_H-i.y;\n}\nbool isbg(vec3 r){\n    //super hacky in a good way\n    float a= abs(r.z)/abs(r.y);\n    return a>1.55 || r.y<0.05;\n\n}\n\nvec3 iq_greenscreen(vec3 bg, vec3 fg){\n    // Created by inigo quilez - iq/2013 License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    return mix(fg, bg, k);\n}\n\nvoid mainImage( out vec4 col, in vec2 fragCoord ){\n    vec2 uv= fragCoord/res.xy;\n    ray r= look_persp(uv,mouse_ang+vec2(1.,.5));\n        \n    \n\t#define MAX_ITER 6\n    vec3 loc= vec3(0);\n    float t= 0.;\n    float d= 0.;\n    for(int step= 0;step<MAX_ITER; step++){\n        loc= r.a*t + r.c;\n        d= sdf(loc);\n        t+= d+.125*float(step)/float(MAX_ITER);\n        if(d<0.||d>BIG)\n            break;\n    }\n    float dist= length(loc);\n    float a= dist*1.001;\n    \n    vec4 bg= texture(iChannel0, r.a);\n    if(isbg(r.a)){\n        col= bg;\n        return;\n    }\n    \n    col= vec4(0.5);\n    vec2 st= loc.zx/SKY_H;\n    vec2 wind= rot2d(sin(time*.2)*TAU)[0];\n    st+= wind*.2;\n    st= mods(st,1.);\n    st= abs(st-.5)*2.;\n    col= texture(iChannel1, st);\n    \n    \n    vec3 fog= unsrgb(vec3(135.,206.,250.)/255.);\n    col.xyz= iq_greenscreen(fog, col.xyz);\n    col= lerp(col, vec4(fog,1.), dist/SKY_H*.1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Khlor's header\n//Copyright 2018 GNU GPLv3 https://www.gnu.org/licenses/gpl.txt\n//Cultivating this into a framework\n\nprecision highp float;\n\nvec3   srgb(vec3 c){ return pow(c,vec3(   2.2)); }\nvec3 unsrgb(vec3 c){ return pow(c,vec3(1./2.2)); }\n\n#define res (iResolution.xy)\n//vec3 img(vec2 uv){}\n\n\n\n\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n\n#define BIG 1e8\n#define ETA 1e-5\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n#define vec1 float\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/res*2.)\n#define mouse_ang (mouse*vec2(PI, PI/2.))\n\n\n/*\neliminate need to cast second arg to vector\nvec2 _fs(vec2 x, vec1 y){ return _f(x,vec2(y));}\nvec3 _fs(vec3 x, vec1 y){ return _f(x,vec3(y));}\nvec4 _fs(vec4 x, vec1 y){ return _f(x,vec4(y));}\n*/\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\nvec2 clamps(vec2 x, vec1 min, vec1 max){ return clamp(x, vec2(min),vec2(max));}\nvec3 clamps(vec3 x, vec1 min, vec1 max){ return clamp(x, vec3(min),vec3(max));}\nvec4 clamps(vec4 x, vec1 min, vec1 max){ return clamp(x, vec4(min),vec4(max));}\nvec2 mins(vec2 v, vec1 s){ return min(v, vec2(s));}\nvec3 mins(vec3 v, vec1 s){ return min(v, vec3(s));}\nvec4 mins(vec4 v, vec1 s){ return min(v, vec4(s));}\nvec2 maxs(vec2 v, vec1 s){ return max(v, vec2(s));}\nvec3 maxs(vec3 v, vec1 s){ return max(v, vec3(s));}\nvec4 maxs(vec4 v, vec1 s){ return max(v, vec4(s));}\nvec2 mins(vec1 s, vec2 v){ return min(v, vec2(s));}\nvec3 mins(vec1 s, vec3 v){ return min(v, vec3(s));}\nvec4 mins(vec1 s, vec4 v){ return min(v, vec4(s));}\nvec2 maxs(vec1 s, vec2 v){ return max(v, vec2(s));}\nvec3 maxs(vec1 s, vec3 v){ return max(v, vec3(s));}\nvec4 maxs(vec1 s, vec4 v){ return max(v, vec4(s));}\n\nfloat maxv(vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv(vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv(vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv(vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv(vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv(vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\nfloat sum (vec2 v){ return dot(v,vec2(1));}\nfloat sum (vec3 v){ return dot(v,vec3(1));}\nfloat sum (vec4 v){ return dot(v,vec4(1));}\nfloat prod(vec2 v){ return v.x*v.y;}\nfloat prod(vec3 v){ return v.x*v.y*v.z;}\nfloat prod(vec4 v){ return v.x*v.y*v.z*v.w;}\n\n\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nfloat pow2i(int x){ return float(1<<x); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return mod(t+PI,     TAU )-PI; }\nvec2 angn(vec2 t){ return mod(t+PI,vec2(TAU))-PI; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(sum(x)); }\nbool real(vec3 x){ return real(sum(x)); }\nbool real(vec4 x){ return real(sum(x)); }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\n//TODO this is srgb luminance, i dont think thats super important tho\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n\n#define R1A     (4445.231)\n#define R1B     ( 556.113)\n#define R2A vec2(4411.231, 4315.23)\n#define R2B vec2( 561.111,  531.45)\n#define R3A vec3(4411.231, 4315.23, 4424.34)\n#define R3B vec3( 561.111,  531.43,  543.13)\nvec1 rand (vec1 x){ return fract(sin(x*R1A)*R1B);   }\nvec2 rand (vec2 x){ return fract(sin(x*R2A+x.yx )); }\nvec3 rand (vec3 x){ return fract(sin(x*R3A+x.yzx)); }\nvec2 rand2(vec1 x){ return fract(sin(x*R2A)*R2B);   }\nvec3 rand3(vec1 x){ return fract(sin(x*R3A)*R1A);   }\nvec1 rand1(vec2 x){ return fract(sin(dot(x,R2A)));  }\nvec1 rand1(vec3 x){ return fract(sin(dot(x,R3A)));  }\n\n\n\n//f0 is a param because its almost always calculated for something else\n#define grad2(f,f0,x) \\\n\t((vec2( \\\n    \tf( x+vec2(ETA,0) ), \\\n\t\tf( x+vec2(0,ETA) ) \\\n\t)-f0)/ETA)\n#define grad3(f,f0,x) \\\n\t((vec3( \\\n    \tf( x+vec3(ETA,0,0) ), \\\n\t\tf( x+vec3(0,ETA,0) ), \\\n\t\tf( x+vec3(0,0,ETA) ) \\\n\t)-f0)/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n//azimuth, inclination\nvec3 azincl(vec2 a){\n    a.x+= PI/2.;\n    vec2 s= sin(a);//sin theta, sin phi\n    vec2 c= cos(a);//cos theta, cos phi\n    vec3 ret= vec3(c.x,s);\n    ret.xy*= c.y;\n    return ret;\n}\n\nstruct ray{\n\tvec3 a;\n    vec3 c;\n};\n\n#define FOV 110.\n#define FOV_S tan(deg2rad*.5*FOV)\n#define NEAR .1\n\nray look_persp(vec2 uv, vec2 a){\n\tray o;\n    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uv*FOV_S,1.));\n    o.c= o.a*NEAR;\n    return o;\n}\nray look_orbit(vec2 uv, vec2 a, float d){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= norm( mat * vec3(uv*FOV_S,1.));\n    o.c= mat[2]*-d + o.a*NEAR;\n\treturn o;\n}\n","name":"Common","description":"","type":"common"}]}