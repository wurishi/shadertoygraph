{"ver":"0.1","info":{"id":"sdlBD4","date":"1644902875","viewed":120,"name":"Animated Matchmaker Fractal","username":"c0rymcg","description":"\"Matchmaker\" fractal with Exponential Smoothing.\nIt is the result of iterating a Mobius transformations of complex number Z, which makes particularly interesting Julia sets.\n\nMouse overwrites the Julia constant.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","morph"],"hasliked":0,"parentid":"fdXBzr","parentname":"fractal code template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TAU 6.28318\n#define maxIterations 75\n#define AA 2\n#define time (iTime+12.5)/3.\n\n//turn off julia mode: good for debugging \n//#define juliaFalse\n\nvec2 cMult(vec2 c1, vec2 c2){\n   //complex mult\n    float newR = c1.x*c2.x - c1.y*c2.y;\n\tfloat newI = c1.y*c2.x + c1.x*c2.y;\n\treturn vec2(newR,newI);\n}\n\nvec2 cDivide(vec2 c1, vec2 c2){\n\t//conjugate = a - bi;\n\t//to divide, multiply both sides by complex conjugate of denom\n\n\tfloat divisor = dot(c2,c2);\n\t\n\treturn vec2((c1.x*c2.x + c1.y*c2.y)/divisor, (c1.y*c2.x - c1.x*c2.y)/divisor);\n}\n\n\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d){\n    \n    return cDivide(cMult(a,z)+b,cMult(c,z)+d);\n}\n\nvec2 f1(vec2 z, vec2 c) {\n//return cMobius(cSquare(z), userSettings.posP, c, a, b);\n    \n    \n    \n    vec2 p = vec2(sin(time/4.),cos(time/4.))*mix(0.9,1.2,(cos(time/10.)));\n    return mobius(cMult(z,z),p,c,vec2(0.3,0.6),vec2(-1.,0.));\n}\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\nfloat logPotential(float d,float i){\n  \n\tfloat base=log(2.);\n\treturn i-(log(log(d)/base)/base);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    \n        \n    vec2 mPos = iMouse.xy/iResolution.xx;\n    mPos -= 0.5; mPos *= 1.3; mPos += 0.5;\n    mPos=5.*(mPos-vec2(0.5,0.22));\n    \n    \n    //aa code here\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n        vec2 c = vec2(0.);\n        vec2 z = vec2(0.);\n    \n        vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xx;\n        uv -= 0.5;uv *= 1.3;uv += 0.5;\n        uv=5.*(uv-vec2(0.5,0.22));\n        z = uv;\n        \n        \n        \n        \n        \n        vec2 jPos = vec2(sin(-time/4.05),cos(-time/4.05))*1.1;\n        \n        \n        if (iMouse.z>0.)jPos=mPos;\n        \n                    \n        int i = 0;\n        float sum=0.; float fmin=10000.; float fmax=0.; float lenz=0.;\n        \n        //iterate\n        #ifdef juliaFalse\n            c=z;\n        #else\n            c=jPos;\n        #endif\n        for (i = 0; i < maxIterations; i++) {\n            z = f1(z,c);\n                    \t\n            lenz = exp(0.-length(z));\n            if (lenz<fmin) fmin=lenz;\n            if (lenz>fmax) fmax=lenz;\n            sum+=lenz;\n        }\n\n\n    \n    //exp smoothing color method\n    \n\n\tfloat colval = sqrt(sum)/(1.+fmax-fmin);\n    \n    \n    vec3 iterationCol = vec3(palette(colval/2., vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.0),vec3(0.3, 0.2, 0.2)));\n\t#ifdef juliaFalse\n    if (distance(c,jPos)<0.03)iterationCol=vec3(0.);\n    #endif\n    \n    aacol+= iterationCol;\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}