{"ver":"0.1","info":{"id":"4lyXWd","date":"1486368665","viewed":132,"name":"The Narrow Path of Eerie Boxes","username":"yumcyawiz","description":"I used simple \"steps AO\" to shade the box","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\n//primitives\n//lots of these functions are imported from here\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\nfloat opS(float d1, float d2) {\n\treturn max(-d1, d2);\n}\nfloat opI(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat primitive(vec3 p) {\n\treturn opS(sdSphere(p, 1.5), sdBox(p, vec3(1.2)));\n}\n\nfloat opRep(vec3 p, vec3 c) {\n\tvec3 q = mod(p, c) - 0.5*c;\n\treturn primitive(q);\n}\n\n\n\n//distance field\nfloat df(vec3 p) {\n\treturn opRep(p + vec3(cos(time), sin(time), 3.0*time), vec3(4));\n}\n\n\n//calculate normal vector\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\treturn normalize(vec3(\n\t\tdf(p + vec3(eps, 0, 0)) - df(p + vec3(-eps, 0, 0)),\n\t\tdf(p + vec3(0, eps, 0)) - df(p + vec3(0, -eps, 0)),\n\t\tdf(p + vec3(0, 0, eps)) - df(p + vec3(0, 0, -eps))\n\t\t));\n}\n\n\n//trace\nstruct Ray {\n    vec3 position; //hit position\n    vec3 rayDir; //ray direction\n    int steps; //the number of steps to reach the intersection point\n    float t; //traveled distance\n};\n\nconst int maxSteps = 100; //the number of maximum allowed steps\nRay trace(vec3 from, vec3 rayDir) {\n    vec3 p = vec3(0);\n\tfloat t = 0.0;\n\tint steps = 0;\n\tfor(int i = 0; i < maxSteps; i++) {\n\t\tp = from + t*rayDir;\n        steps = i;\n\t\tfloat d = df(p);\n\t\tif(d < 0.001) {\n\t\t\tbreak;\n\t\t}\n        t+= d/2.0;\n\t}\n\treturn Ray(p, rayDir, steps, t);\n}\n\n//shading\nvec3 shading(Ray tr) {\n    //simple steps AO\n    return vec3(1.0 - float(tr.steps)/float(maxSteps));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(-1, -1) ~ (1, 1)\n\tvec2 uv = (2.0*gl_FragCoord.xy - iResolution.xy)/iResolution.y;\n\t\n    //camera settings\n\tvec3 camPos = vec3(0, 0, -5);\n\tvec3 camFront = vec3(0.2*cos(time), 0, 1.0);\n\tvec3 camUp = vec3(0, 1.0, 0);\n\tvec3 camRight = cross(camFront, camUp);\n\t\n    //ray direction\n\tvec3 rayDir = uv.x*camRight + uv.y*camUp + 1.0*camFront;\n    \n    //trace\n    Ray tr = trace(camPos, rayDir);\n    \n    //shading\n    vec3 color = shading(tr);\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}