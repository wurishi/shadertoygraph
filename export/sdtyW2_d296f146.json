{"ver":"0.1","info":{"id":"sdtyW2","date":"1654122425","viewed":197,"name":"Lightning Simulation 2","username":"niels747","description":"Colors indicate charge\nWhite indicates temperature\n\nPlease play arround with the parameters to try and make it better, cause it's still far from actual lightning.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["simulation","lightning"],"hasliked":0,"parentid":"7stcDS","parentname":"Lightning Simulation 1"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 tempColorPalette[] = vec3[](vec3(1., 0.7, 1.), vec3(1., 0.5, 1.), vec3(1., 0.3, 1.), vec3(0.8, 0., 0.8), vec3(0.65, 0., 0.6), vec3(0.5, 0., 0.5), vec3(0.35, 0., 0.6), vec3(0., 0., 0.7), vec3(0., 0., 1.), vec3(0., 0.30, 1.), vec3(0., 0.44, 1.), vec3(0., 0.62, 1.0), vec3(0., 0.80, 1.0), vec3(0., 1., 1.), vec3(0., 0.50, 0.), vec3(0., 0.61, 0.0), vec3(0., 0.72, 0.), vec3(0., 0.85, 0.), vec3(0., 1., 0.), vec3(0.5, 1., 0.), vec3(0.80, 1., 0.), vec3(1., 1., 0.), vec3(1., 0.8, 0.), vec3(1., 0.6, 0.), vec3(1., 0.4, 0.), vec3(1., 0., 0.), vec3(0.85, 0., 0.), vec3(0.72, 0., 0.), vec3(0.61, 0., 0.), vec3(0.52, 0., 0.));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 t = texture(iChannel1,uv);\n    \n    vec4 image = texture(iChannel3,uv + t.xy/100.0);\n    \n    vec2 normMouse = iMouse.xy / iResolution.xy;\n    \n    float light = 0.0;\n    \n    vec2 lightAngle = vec2(-0.5+normMouse.x,-0.5+normMouse.y);\n    light += pow(max(length(lightAngle) - length(t.xy - lightAngle),0.0)/(length(lightAngle)+0.02),4.0); // light reflection\n    \n    float L = t.w*0.01; // temperature\n    \n    float B = length(t.xy);\n\n    vec3 chargeCol = vec3(0);\n    \n    chargeCol = tempColorPalette[int(t.z*2.)]; // show charge distribution\n\n    fragColor = vec4(chargeCol.r +L, chargeCol.g +L, chargeCol.b +L, 1.0); // charges and temperature\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nx = horizontal current\ny = vertical current\nz = charge\nw = temperature\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center =  fragCoord/iResolution.xy;\n    vec2 right  = (fragCoord + vec2(1,0))/iResolution.xy;\n    vec2 up     = (fragCoord + vec2(0,1))/iResolution.xy;\n    \n    vec4 t = texture(iChannel0,center);\n    \n    // current changes proportional to charge gradient across point\n    float Xvolt = texture(iChannel0,center).z - texture(iChannel0,right).z;\n    float Yvolt = texture(iChannel0,center).z - texture(iChannel0,up).z;\n    \n    t.x += Xvolt;\n    t.y += Yvolt;\n    \n    \n    t.w = t.w*(1. - tempSmooth*2.) + texture(iChannel0,right).w*tempSmooth + texture(iChannel0,up).w*tempSmooth; // smooth temperature\n   \n    t.w *= tempDecay;\n    \n   // t.z *= 1.0 - max(t.w - 10.0, 0.)*0.001; // drain charge when hot\n    \n    t.w += (t.x * t.x + t.y * t.y) * heatingMult; // heating proportional to square of current\n    \n    float resistance = clamp(1. - (t.w - conductThresh) * conductMult , minResistance, maxResistance);\n    \n    if(sqrt(Xvolt*Xvolt + Yvolt*Yvolt) > breakdownVolt){\n        resistance = minResistance*5.;\n        t.w += 0.5;\n        }\n   \n    t.xy *= 1. - resistance; // resistance reduces current\n    \n    \n    // mouse adds positive charge\n    if(length(iMouse.xy - fragCoord) < 20.1 && iMouse.z > 0.5){\n        t.z += 0.05;\n    }\n    \n    if(iFrame < chargingTime){ // create charge fields\n\n    //    if(length(vec2(450,220) - fragCoord) < 145.0){ //  left \n    //        t.z += chargingRate;\n      //  }\n      \n        t.z += max(0.20 - length(vec2(300,220) - fragCoord) * 0.0006, 0.0)* 1.5;\n        \n        if(length(vec2(400,200) - fragCoord) < 5.0){ //  starting spark \n            t.z += 0.18;\n        }\n    }\n\n    fragColor = t;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nx = horizontal current\ny = vertical current\nz = charge\nw = temperature\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center =  fragCoord/iResolution.xy;\n    vec2 left   =  (fragCoord + vec2(-1,0))/iResolution.xy;\n    vec2 down   = (fragCoord + vec2(0,-1))/iResolution.xy;\n\n    vec4 t = texture(iChannel0,center);\n   \n   // charge changes proportional to the net inflow - outflow of the cell\n   t.z += (texture(iChannel0,left).x - texture(iChannel0,center).x + texture(iChannel0,down).y - texture(iChannel0,center).y) *0.5; // multiplier has to be < 0.5\n   \n   fragColor = t;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define chargingTime 70\n#define chargingRate 0.190\n\n#define tempSmooth        0.0001 // 0.005 heat spreading out. makes the edges smoother and grows very hot paths\n#define tempDecay         0.998 // 0.970 temperature cooling down to 0\n\n#define maxResistance     0.950 // 0.970 resistance of cold air\n#define minResistance     0.010 // 0.005 min resistance of hot air\n\n#define conductThresh     0.30  // 0.20  temperature where conductivy starts to increase\n#define conductMult       0.20  // 0.30  temperature increase increases conductivity\n\n#define heatingMult       0.07  // 0.15  current heating air\n\n#define breakdownVolt     0.70\n\n\n// ***** Buffer C and D are copies of A and B to make it run twice as fast!","name":"Common","description":"","type":"common"}]}