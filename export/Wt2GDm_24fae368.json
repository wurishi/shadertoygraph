{"ver":"0.1","info":{"id":"Wt2GDm","date":"1559896069","viewed":185,"name":"Pikachu shader challenge","username":"markknol","description":"My attempt of a shader challenge https://github.com/leon196/SIGExam\nNo Pikachu here btw, but London..\n\nClick/drag left to right to see my output. Don't look at source/results, recreate it yourself :p\n\nred dot = incompleted\ngreen dot = completed","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["challenge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 calculatedUV = fragCoord/iResolution.xy;\n\n    // Example number\n    int totalExamples = 27;\n    int example = int(iMouse.x / iResolution.x * float(totalExamples));\n    \n    float complete = 1.0;\n    \n    vec2 uv = calculatedUV.xy;\n    \n    \n    /* \n    \tuv filters \n\t*/\n    if (example == 0)\n    {\n        // image\n        \n        // nothing to do here\n    }\n    else if (example == 1)\n    {\n        // mirror\n        uv.y = 1.0 - uv.y;\n    }\n    else if (example == 2)\n    {\n        // symmetry\n        if (uv.y > 0.5) {\n            uv.y = 1.0 - uv.y;\n        }\n    }\n    else if (example == 3)\n    {\n        // rotate 45deg\n        uv -= 0.5;\n        uv = rotate(uv, radians(-45.0));\n        uv += 0.5;\n    }\n    else if (example == 4)\n    {\n        // zoom\n        float zoom = 1.9 + sin(iTime) * 0.5;\n        uv -= 0.5;\n        uv /= zoom;\n        uv += 0.5;\n    }\n    else if (example == 5)\n    {\n        // zoom distortion\n        float distortion = 10.;\n        float damping = 0.05;\n        uv -= 0.5;\n        uv /= distortion / sqrt(uv.x * uv.x + uv.y * uv.y) * damping;\n        uv += 0.5;\n    }\n    else if (example == 6)\n    {\n        // repetition\n        float zoom = 0.2 + sin(iTime) / 5.5;\n        // uv = mod(uv / zoom), 1.0);\n        uv -= 0.5;\n        uv = fract(uv / zoom);\n        uv += 0.5;\n    }\n    else if (example == 7)\n    {\n        // spirale\n        float radians = -0.785398;\n        uv -= 0.5;\n        uv = rotate(uv, radians * length(uv) * (10.0 + sin(iTime) * 3.0));\n        uv += 0.5;\n    }\n    else if (example == 8)\n    {\n        // INCOMPLETE: rayon / kaleidoscope\n        complete = 0.5;\n        \n        float zoom = 1.0;\n\n        uv -= 0.5;\n        \n        float totalRays = 4.0;\n\n        float ang = atan(uv.y / uv.x);\n        vec2 rotated = rotate(uv, PI / totalRays);\n        uv.x = rotated.x;\n        uv.y = sin(ang * totalRays) ;\n\n        uv += 0.5;\n\n        //uv = fract(uv / zoom);\n    }\n    else if (example == 9)\n    {\n        // clamp\n        uv.y = max(uv.y, 0.5);\n    }\n    else if (example == 10)\n    {\n        // pli\n        complete = 0.0;\n    }\n    else if (example == 11)\n    {\n        // direction couleur\n        complete = 0.0;\n    }\n    else if (example == 12)\n    {\n        // pixelart\n        complete = 1.0;\n        vec2 pixelSize = iResolution.xy / 15.0;\n        uv = floor(uv * pixelSize) / pixelSize;\n    }\n    else if (example == 13)\n    {\n        // vague\n        float rings = 60.0;\n        float damp = 4.0;\n        uv -= 0.5;\n\n        float distance = sqrt(uv.x * uv.x + uv.y * uv.y);\n        float distanceNormalized = 1.0 - distance / iResolution.x;\n        float distortionY = sin(uv.y * rings + iTime) / distanceNormalized / damp;\n\n        uv.y += uv.y * distortionY;\n\n        uv += 0.5;\n    }\n    else if (example == 14)\n    {\n        // colonne\n        complete = 0.5;\n        \n        vec3 pixelSize = iResolution / 100.0;\n        uv -= 0.5;\n        \n        \n        float distortionX = 4.0;\n        float rings = 10.0;\n        float fractY = fract(uv.y * rings) / rings;\n        float distortionY = cos(uv.x + fractY) / rings * distortionX;\n        uv.x = uv.x * distortionY * rings;\n        \n        uv += 0.5;\n    }\n    else if (example == 15)\n    {\n        // crash\n        complete = 0.5;\n        \n        uv -= 0.5;\n        vec2 pixelSize = iResolution.xy / 10.0;\n        vec2 rndUv = floor(uv * pixelSize) / pixelSize;\n        float rnd1 = abs(mod(sin((cos(rndUv.y * 123.0123) + sin(rndUv.x * 2232.5410) * 45.234) * 22123.46235), 1.0));\n        float rnd2 = abs(mod(sin((cos(rndUv.x * 114.2570) + cos(rndUv.y * 2264.3430) * 56.345) * 12321.1235), 1.0));\n        vec2 rndPos = (-0.5 + vec2(rnd1, rnd2)) * (sin(iTime * 2.0) * 15.0);\n        \n        uv = floor((uv + rndPos / pixelSize) * pixelSize) / pixelSize;\n        uv += 0.5;\n    }\n    else if (example == 16)\n    {\n        // scanline\n        complete = 0.0;\n    }\n    else if (example == 17)\n    {\n        // double frequency\n        complete = 1.0;\n        \n        float displacement = 0.01;\n        float distance = 2.0;\n        float scanlines = 140.;\n        \n        uv.x += floor(mod(uv.y * scanlines, 1.0) * distance) < 1.0 ? displacement : -displacement;\n    } \n    \n\t\n    \n    vec4 channel0 = texture(iChannel0, uv.xy);\n    // image \n    fragColor = channel0;\n    \n    /* \n\t\tfragment color filters\n\t*/\n    if (example == 18)\n    {\n        // black/white\n        complete = 0.0;\n        fragColor = fragColor.rrra;\n    } \n    else if (example == 19)\n    {\n        // seuil\n        complete = 0.0;\n        fragColor.rgb = vec3(fragColor.r > 0.5 ? 1.0 : 0.0);\n    } \n    else if (example == 20)\n    {\n        // seuils\n        complete = 0.0;\n        float posterize = 4.0;\n        fragColor.rgb = round(fragColor.rgb * posterize) / posterize;\n    } \n    else if (example == 21)\n    {\n        // sonar\n        complete = 1.0;\n        \n        vec2 center= uv.xy;\n        center -= 0.5;\n        \n        vec2 gridSize = iResolution.xy / 3.;\n        float distance = sqrt(uv.x * uv.x + uv.y * uv.y);\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), sin(distance) > 0.9 ? 1.0 : 0.0);\n        \n    } \n    else if (example == 22)\n    {\n        // grille\n        complete = 1.0;\n        \n        vec2 gridSize = iResolution.xy / 25.;\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), (fract(uv.x * gridSize.x) > 0.9 || fract(uv.y * gridSize.y) > 0.9) ? 1.0 : 0.0);\n    }\n    else if (example == 23)\n    {\n        // tampon la poste\n        complete = 0.0;\n    }\n    else if (example == 24)\n    {\n        // negative locale\n        complete = 0.5;\n        \n        // TODO: only in circle\n        fragColor.rgb = 1.0 - fragColor.rgb;\n    }\n    else if (example == 25)\n    {\n        // aberriation chromatique\n        complete = 1.0;\n        float displacement = 0.02;\n        fragColor.r = texture(iChannel0, uv.xy + vec2(-displacement, 0.0)).r;\n        fragColor.b = texture(iChannel0, uv.xy + vec2( displacement, 0.0)).b;\n    }\n    else if (example == 26)\n    {\n        // chroma key\n        complete = 0.0;\n        /*\n        vec3 color = fragColor.rgb;\n        fragColor.r = (color.b + color.g) * 0.5;\n        fragColor.g = (color.r + color.b) * 0.5;\n        fragColor.b = (color.g + color.r) * 0.5;\n\t\t*/\n    }\n    \n    \n    // draw status bar, \n    //   percentage = example \n    //   color = completeness\n    vec4 statusColor = vec4(1.0 - pow(complete, 4.0), complete, 0., 1.0);\n    uv = calculatedUV;\n    if (uv.y < 0.01) {\n        fragColor.rgb = mix(statusColor.rgb, vec3(0.0), float(example)/(float(totalExamples)-1.0) < uv.x ? 1.0 : 0.0);\n   \t}\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 rotate(vec2 uv, float angle) {\n    float x = uv.x * cos(angle) - uv.y * sin(angle);\n    float y = uv.x * sin(angle) + uv.y * cos(angle);\n    return vec2(x, y);\n}","name":"Common","description":"","type":"common"}]}