{"ver":"0.1","info":{"id":"fs2XzV","date":"1620606834","viewed":18,"name":"CTKnoll - Metallic Text","username":"CTKnoll","description":"Simple text display shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["text"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// every letter has been converted into an int[8], where each int is an 8bit bitmask of each row\nconst int[] A = int[8] (60, 66, 66, 126, 66, 66, 66, 66);\nconst int[] B = int[8] (124, 66, 66, 124, 66, 66, 66, 124);\nconst int[] C = int[8] (62, 64, 64, 64, 64, 64, 64, 62);\nconst int[] D = int[8] (124, 66, 66, 66, 66, 66, 66, 124);\nconst int[] E = int[8] (126, 64, 64, 120, 64, 64, 64, 126);\nconst int[] F = int[8] (126, 64, 64, 120, 64, 64, 64, 64);\nconst int[] G = int[8] (60, 66, 66, 64, 78, 66, 66, 60);\nconst int[] H = int[8] (66, 66, 66, 126, 66, 66, 66, 66);\nconst int[] I = int[8] (124, 16, 16, 16, 16, 16, 16, 124);\nconst int[] J = int[8] (2, 2, 2, 2, 2, 2, 66, 60);\nconst int[] K = int[8] (68, 72, 80, 96, 80, 72, 68, 66);\nconst int[] L = int[8] (64, 64, 64, 64, 64, 64, 64, 126);\nconst int[] M = int[8] (66, 102, 90, 66, 66, 66, 66, 66);\nconst int[] N = int[8] (66, 98, 82, 74, 70, 66, 66, 66);\nconst int[] O = int[8] (60, 66, 66, 66, 66, 66, 66, 60);\nconst int[] P = int[8] (60, 66, 66, 124, 64, 64, 64, 64);\nconst int[] Q = int[8] (60, 66, 66, 66, 66, 74, 68, 59);\nconst int[] R = int[8] (60, 66, 66, 124, 80, 72, 68, 68);\nconst int[] S = int[8] (60, 66, 64, 60, 2, 2, 66, 60);\nconst int[] T = int[8] (124, 16, 16, 16, 16, 16, 16, 16);\nconst int[] U = int[8] (66, 66, 66, 66, 66, 66, 66, 60);\nconst int[] V = int[8] (66, 66, 66, 66, 66, 66, 36, 24);\nconst int[] W = int[8] (66, 66, 66, 66, 66, 90, 102, 66);\nconst int[] X = int[8] (66, 66, 36, 24, 24, 36, 66, 66);\nconst int[] Y = int[8] (68, 68, 40, 16, 16, 16, 16, 16);\nconst int[] Z = int[8] (126, 4, 8, 16, 32, 64, 64, 126);\nconst int[] EXC = int[8] (16, 16, 16, 16, 16, 16, 0, 16);\nconst int[] QUE = int[8] (126, 66, 2, 30, 16, 16, 0, 16);\nconst int[] PER = int[8] (0, 0, 0, 0, 0, 0, 0, 16);\n\n// colors... duh\nconst vec3 COLOR_RED = vec3(1, .1, .1);\nconst vec3 COLOR_BLUE = vec3(.1, .1, 1);\nconst vec3 COLOR_GREEN = vec3(.1, 1, .1);\n\n// the number of letters that can be fit on the screen\nconst ivec2 numLetters = ivec2(8, 8);\n// the number of \"pixels\" within a letter. This should always be 8x8 for now\nconst ivec2 letterSize = ivec2(8, 8);\n// these factors control how the text looks. I recommend playing with them!\n// If the fuzz dropoff is low, or fuzz amount is less than .5, fuzzAmt feels like a color slider\n// but if fuzzAmt > .5, interesting behavior happens on the edge of the letters\n// Fuzz dropoff is the extent to which the behavior is present\nconst float fuzzAmt = .75;\nconst float fuzzDropoff = .25;\n\n// coordinates of the pixel in texture space, letter space, and cell space\nvec2 uv, cellUv, letterUv;\n// the index of the \"cell within letter\" and \"letter within texture\" that the pixel belongs to\nivec2 cellIdx, letterIdx;\n\n// splits a space into x*y subspaces, and returns the space you're in and the uv in the new space\nvoid multiply(in int x, in int y, in vec2 uv, out vec2 pos, out ivec2 idx)\n{\n    pos = vec2(fract(uv.x * float(x)), fract(uv.y * float(y)));\n    idx = ivec2(floor(uv.x * float(x)), floor(uv.y * float(y)));\n}\n\n// reprojects a set of uvs by x on the x axis, and y on the y axis. This induces a \"shrinking\" effect around the center of the uv\nvoid reproject(in float x, in float y, inout vec2 uv)\n{\n    vec2 diff = uv - vec2(.5);\n    uv.x = .5 + diff.x * x;\n    uv.y = .5 + diff.y * y;\n}\n\nbool isLetter(in ivec2 idx, in int[8] letter)\n{\n    // anything outside the boundary is always \"not a letter\"\n    int check1 = int(idx.x >= 0);\n    int check2 = int(idx.y >= 0);\n    int check3 = int(idx.x < letterSize.x);\n    int check4 = int(idx.y < letterSize.y);   \n    int checkSum = check1 * check2 * check3 * check4;\n\n    // get the \"inside of letter\" cell row we're in\n    int row = checkSum != 0 ? letter[7 - clamp(idx.y, 0, letterSize.y)] : 0;\n    // bitmasking logic to check agianst the alphabet arrays we have above\n    int check = 1 << (7 - clamp(idx.x, 0, letterSize.x));\n    return (check & row) != 0;\n}\n\n// this is the less fun letter. Replace a fuzzy letter call with this to see the  most stripped down for of the code\nvec3 makeLetter(in int[8] letter, in int x, in int y)\n{   \n    bool posCheck = (letterIdx.x == x) && (letterIdx.y == y);\n    return vec3(int(posCheck) * int(isLetter(cellIdx, letter)));\n}\n\n// if a is 1, b is -1\n// if a is 0, b is 1\nfloat inverter(float a)\n{\n    return 1. - 2. * step(1., a);\n}\n\nvec3 makeFuzzyLetter(in int[8] letter, in int x, in int y)\n{\n    float multiplier = 0.;\n    bool center = isLetter(ivec2(cellIdx.x, cellIdx.y), letter);\n    \n    // for each true here, we need to do processing on ourselves, whitening for black, darkening for white\n    // this implies the cell in the given direction is the opposite color that we are\n    bool topLeft = isLetter(ivec2(cellIdx.x - 1, cellIdx.y + 1), letter) ^^ center;\n    bool topCenter = isLetter(ivec2(cellIdx.x, cellIdx.y + 1), letter)  ^^ center;\n    bool topRight = isLetter(ivec2(cellIdx.x + 1, cellIdx.y + 1), letter) ^^ center;\n    bool left = isLetter(ivec2(cellIdx.x - 1, cellIdx.y), letter)  ^^ center;\n    bool right = isLetter(ivec2(cellIdx.x + 1, cellIdx.y), letter)  ^^ center;\n    bool bottomLeft = isLetter(ivec2(cellIdx.x - 1, cellIdx.y - 1), letter)  ^^ center;\n    bool bottomCenter = isLetter(ivec2(cellIdx.x, cellIdx.y - 1), letter)  ^^ center;\n    bool bottomRight = isLetter(ivec2(cellIdx.x + 1, cellIdx.y - 1), letter)  ^^ center;\n    \n    // additive shading\n    multiplier += float(topLeft) * fuzzAmt * smoothstep(fuzzDropoff, 0., distance(vec2(0,1), cellUv));\n    multiplier += float(topCenter) * fuzzAmt * smoothstep(fuzzDropoff, 0., 1. - cellUv.y);\n    multiplier += float(topRight) * fuzzAmt * smoothstep(fuzzDropoff, 0., distance(vec2(1,1), cellUv));\n    multiplier += float(left) * fuzzAmt * smoothstep(fuzzDropoff, 0., cellUv.x);\n    multiplier += float(right) * fuzzAmt * smoothstep(fuzzDropoff, 0., 1. - cellUv.x);\n    multiplier += float(bottomLeft) * fuzzAmt * smoothstep(fuzzDropoff, 0., distance(vec2(0,0), cellUv));\n    multiplier += float(bottomCenter) * fuzzAmt * smoothstep(fuzzDropoff, 0., cellUv.y);\n    multiplier += float(bottomRight) * fuzzAmt * smoothstep(fuzzDropoff, 0., distance(vec2(1,0), cellUv));\n    \n    // we check here to make sure we're in the right cell; we'll return black otherwise\n    bool posCheck = (letterIdx.x == x) && (letterIdx.y == y);    \n    return vec3(float(posCheck) * (float(center) + inverter(float(center)) * clamp(0.0, fuzzAmt, multiplier)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Lets split out gridspace into letter cells, and store which cell we're in and where\n    uv = fragCoord/iResolution.xy;\n    multiply(numLetters.x, numLetters.y, uv, letterUv, letterIdx);\n    \n    // Reproject (make 1.2x smaller) to not cut off parts of the letter and prevent vertical melding\n    // then multiply again to get into \"inside of letter\" cell space\n    reproject(1.2, 1.2, letterUv);\n    multiply(letterSize.x, letterSize.y, letterUv, cellUv, cellIdx);\n    \n    // Create your text here! The first argument is just the capital letter, and then the next two are the place on the grid to align it. \n    // Letter size needs to be manually set, since GLSL doesnt let you get the size of an array dynamically :(\n    int lettersCount = 14;\n    vec3[] letters = vec3[] ( \n    makeFuzzyLetter(S, 1, 5), makeFuzzyLetter(C, 2, 5), makeFuzzyLetter(A, 3, 5), makeFuzzyLetter(R, 4, 5), makeFuzzyLetter(Y, 5, 5),\n    makeFuzzyLetter(T, 1, 4), makeFuzzyLetter(E, 2, 4), makeFuzzyLetter(X, 3, 4), makeFuzzyLetter(T, 4, 4),\n    makeFuzzyLetter(U, 1, 3), makeFuzzyLetter(W, 2, 3), makeFuzzyLetter(U, 3, 3), makeFuzzyLetter(EXC, 4, 3), makeFuzzyLetter(QUE, 5, 3));\n    \n    // We just add the value of every letter together, since it'll be 0 by definition for every letter except the one we're a part of\n    // so long as theres one letter per letter cell, of course ;)\n    vec3 color = vec3(0);\n    for(int i = 0; i < lettersCount; i++)\n    {\n        color += letters[i];\n    }\n    \n    color *= COLOR_RED;\n    \n    fragColor = vec4(clamp(color, 0.0, fuzzAmt), 1.0);\n}","name":"Image","description":"","type":"image"}]}