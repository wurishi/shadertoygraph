{"ver":"0.1","info":{"id":"Ndy3zG","date":"1631728174","viewed":247,"name":"brotrenderer","username":"samk9632","description":"brot","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rotate(vec3 pos, vec2 rotation) {\n    vec2 m4 = vec2(length(pos.xz), length(pos.xyz));\n\n    vec2 angle = vec2(acos(pos.x/m4.x), asin(pos.z/m4.y));\n    float l = length(pos);\n    vec3 poss = pos;\n    float xx = poss.x*cos(rotation.y)+poss.z*sin(rotation.y);\n    float yy = poss.y;\n    \n    float zz = -pos.x*sin(rotation.y)+poss.z*cos(rotation.y);\n    \n    return vec3(xx, yy, zz);\n}\n\nvec3 fractal(vec3 coords, int iterations, float degreee, float xRot) {\n    float pi = 3.1415926;\n    float degree = 7.0;\n    vec3 coordsMod = coords.xyz;\n    for (int i = 0; i < iterations; i++) {\n        vec3 UV = vec3(coordsMod.xyz);\n        UV = vec3(1.0*length(UV), abs(UV.y)/UV.y*acos(UV.x/length(UV.xy))+xRot, abs(UV.z)/UV.z*asin(abs(UV.z)/length(UV)));\n        coordsMod = coords.xyz+pow(UV.x, degree)*vec3(cos(degree*UV.y)*cos(degree*UV.z), sin(degree*UV.y)*cos(degree*UV.z), sin(degree*UV.z));\n        \n    }\n    if (length(coordsMod) < 2.0) {\n        return vec3(0.3, 0.5, 1.0);\n        //return vec3(1.0);\n    } else {\n        return vec3(0.0);\n    }\n    \n    \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayCast(vec3 dir, vec3 pos, float xRot, vec2 coord) {\n    float density = 500.0;\n    float anisotropy = 0.0;\n    float pi = 3.1415926;\n    vec3 o = vec3(0.0);\n    float stepSize = 0.02;\n    float lightingStepSize = 0.05;\n    vec3 p = pos+dir*stepSize*rand(coord.xy);\n    vec3 n = vec3(0.0);\n    vec3 lightingDir = vec3(cos(-xRot+iTime*0.5), sin(-xRot+iTime*0.5), -sin(iTime*2.718/4.0));\n    lightingDir = lightingDir/length(lightingDir);\n    \n    float a = dot(dir, dir);\n    float b = 2.0*dot(dir, pos);\n    float c = dot(pos, pos) - pow(2.0, 2.0);\n    float discriminant = b*b-4.0*a*c;\n    \n    if (discriminant > 0.0) {\n        vec3 inPos = (-b - sqrt(discriminant))/(2.0*a)*dir+pos;\n        vec3 outPos = (-b + sqrt(discriminant))/(2.0*a)*dir+pos;\n        p = inPos+dir*stepSize*rand(coord.xy);\n        for (float j = 0.0; j < length(inPos-outPos); j += stepSize) {\n            p += dir*stepSize;\n            vec3 pp = p+lightingStepSize*lightingDir*rand(coord.xy);\n            vec3 l = vec3(0.0);\n            vec3 m;\n            if (length(p) < 2.0) {\n                m = fractal(p, 4, 8.0, xRot+iTime*0.0)*stepSize;\n                o += m;\n                if (length(o) > 1.0) {\n                    j = 2.0 + length(pos);\n                }\n            } else {\n                m = vec3(0.0);\n            }\n            if (length(m) > 0.0) {\n                for (vec3 k = p; length(pp) < 2.0; pp -= lightingStepSize*lightingDir) {\n                    l += fractal(pp, 4, 8.0, xRot)*stepSize;\n                    if (length(l) > 1.0) {\n                        pp = vec3(2.0);\n                \n                    }\n                }\n            }\n            \n            vec3 q = vec3(0.0);\n            q.x = stepSize*m.x*density*pow(2.0, -density*stepSize*length(o.x))*pow(2.0, -density*stepSize*length(l.x));\n            q.y = stepSize*m.y*density*pow(2.0, -density*stepSize*length(o.y))*pow(2.0, -density*stepSize*length(l.y));\n            q.z = stepSize*m.z*density*pow(2.0, -density*stepSize*length(o.z))*pow(2.0, -density*stepSize*length(l.z));\n            float cloudValAdjust = 0.3;\n            float cloudVal = 0.0;\n            float minV = 0.0;\n            float maxV = 1.0;\n            anisotropy = clamp((length(o*cloudValAdjust)/(length(o*cloudValAdjust)+1.0)-minV)/(maxV-minV), 0.0, 1.0)*-cloudVal+clamp(1.0-(length(o*cloudValAdjust)/(length(o*cloudValAdjust)+1.0)-minV)/(maxV-minV), 0.0, 1.0)*cloudVal;\n            if (anisotropy >= 0.0) {\n                q*=(1.0-anisotropy+pow(2.7, -anisotropy/(1.0-anisotropy)*(1.0-dot(-dir, lightingDir))));\n            } else {\n                q*=(1.0+anisotropy+pow(2.7, anisotropy/(1.0+anisotropy)*(1.0-dot(dir, lightingDir))));\n            }\n            n.x+=q.x;\n            n.y+=q.y;\n            n.z+=q.z;\n        }\n    }\n    return n;\n    \n    //return vec3(dot(dir, lightingDir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.x-0.5);\n    float x = fragCoord.x/iResolution.x-0.5;\n    float y = (fragCoord.y-0.5*iResolution.y)/iResolution.x;\n    \n    //RayCasting\n    float dof = 1.0;\n    float r = 5.0;\n    float s = 10.0;\n    vec3 camPos = rotate(vec3(r, 0.0, 0.0), -vec2(-iTime*0.2, -s*(mouse.y+pi/2.0)));\n    \n    vec3 camDir = rotate(vec3(-1.0, dof*x, dof*y), vec2(iTime*0.2, s*(mouse.y+pi/2.0)));\n    \n    // Time varying pixel color\n    vec3 col = rayCast(camDir, camPos, -s*mouse.x, fragCoord);\n    \n    //col = (log(1.+col));\n    //col = clamp(col,0.,1.);\n    col *= 2.0;\n    col = col/(col+vec3(1.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}