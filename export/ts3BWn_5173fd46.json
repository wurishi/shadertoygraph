{"ver":"0.1","info":{"id":"ts3BWn","date":"1604833274","viewed":215,"name":"Filtered normal of cosinus 2","username":"SimonL","description":"This shader show how to extract normal from a sum of cosine functions of different phase and frequency, and how to filter analytic normals to remove aliasing in order to do better lighting effect.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["filter","shading","normal","derivation","cosinus","filtered"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader use \n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// More example here made by Inigo Quilez:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n//\n//________________________________________\n//\n// This shader show how to extract normal from a sum of cosine functions of different phase and frequence,\n// and how to filter analytic normals to remove aliasing in order to do better lighting effect.  \n//\n// You can use your mouse to select which part of the canvas you want to see.\n// You can also modify the filtering coefficient FILTERING_COEF, to modify the intensity of filtering.\n// DEFORM can be set to 0, 1 or 2 to change the visuals.\n//\n// Top left \t: Shaded surface with analytic normal from non filtered cosinus functions.\n// Top right \t: Shaded surface with analytic normal from filtered cosinus functions. \n// Bottom left \t: Aliased surface generated with cosinus functions.\n// Bottom right : Anti-aliased surface generated with filtered cosinus functions.\n//\n// Related Shader:\n//  https://www.shadertoy.com/view/Wd3fDn\n//  https://www.shadertoy.com/view/ts3BWn\n//\n\n// 0, 1 or 2\n#define DEFORM 1\n\n// Filtering coefficient.\n// Define the box filtering size. \n#define FILTERING_COEF 1.\n\n// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 deform( in vec2 p )\n{\n    // deform 1\n    #if DEFORM >= 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    p.x += iTime*0.1;\n    \n    \n    // deform 2\n    #if DEFORM >= 2\n    p += 0.1*cos( 1.5*p.yx + 0.003*1.0*iTime + vec2(0.1,1.1) );\n    p += 0.1*cos( 2.4*p.yx + 0.003*1.6*iTime + vec2(4.5,2.6) );\n    p += 0.1*cos( 3.3*p.yx + 0.003*1.2*iTime + vec2(3.2,3.4) );\n    p += 0.1*cos( 4.2*p.yx + 0.003*1.7*iTime + vec2(1.8,5.2) );\n    p += 0.1*cos( 9.1*p.yx + 0.003*1.1*iTime + vec2(6.3,3.9) );\n    #endif\n    #endif\n    return p;\n}\n\n////////////////////////////////////////////////////////////\n// derivative of cos(u)\n//\n// cos(u) = cos(f*t+o)\n// cos'(u) = -f*sin(f*t+o)\nfloat dcos( float u,float f)\n{\n\treturn -f*sin(u);\n}\n\n/////////////////////////////////////////////////////////////\n// box-filted cos(x)\nfloat fcos( float u )\n{\n    float w = fwidth(u);\n    return cos(u) * sin(FILTERING_COEF*w)/(FILTERING_COEF*w);\n}\n\n\n//////////////////////////////////////////////////////////////\n// derivative of fcos(x)\n//\n// cos(u)*sin(c*w(u))/(c*w(u)) = cos(f*t+o)*sin(c*w(f*t+o))/(c*w(f*t+o))\n//\n// (cos(u)*sin(c*w(u))/(c*w(u)))' =\n//\n//\t( -f * sin(u) * sin(c*w(u)) + cos(u) * c * w'(u) * cos(c*w(u)) ) * c * w(u) - cos(u) * sin(c * w(u)) * c * w'(u)\n//\t________________________________________________________________________________________________________________\n//\t\t\t\t\t\t\t\t\t\t\t\t\t(c * w(u))^2\n//\n//\n// w'(u) assumed to be fwidth(w(u)).\n// c is the filtering coefficient.\nfloat dfcos( float u, float f)\n{\n    float w = fwidth(u);\n    float dw = fwidth(w);\n    \n    return ( (-f * sin(u) * sin(FILTERING_COEF*w) + cos(u) * FILTERING_COEF * dw * cos(FILTERING_COEF * w) ) * (FILTERING_COEF*w) - cos(u) * sin(FILTERING_COEF * w) * (FILTERING_COEF*dw) )/ pow(FILTERING_COEF*w,2.);\n}\n\n\n\nfloat getIntensityFiltered( in float t )\n{\n    float col = 0.4;\n    col += 0.14*fcos(t*  1.0+0.6);\n    col += 0.13*fcos(t*  3.1+1.0);\n    col += 0.12*fcos(t*  5.1+1.1);\n    col += 0.11*fcos(t*  9.1+1.2);\n    col += 0.10*fcos(t* 17.1+0.9);\n    col += 0.09*fcos(t* 31. +11.3);\n    col += 0.08*fcos(t* 65. +11.3);\n    col += 0.07*fcos(t*131. +10.8);\n    return col;\n}\n\nfloat getIntensityFilteredGrad( in float t )\n{\n    float col = 0.;\n    col += 0.14*dfcos(t*  1.0+ 0.6, 1.0);\n    col += 0.13*dfcos(t*  3.1+ 1.0, 3.1);\n    col += 0.12*dfcos(t*  5.1+ 1.1, 5.1);\n    col += 0.11*dfcos(t*  9.1+ 1.2, 9.1);\n    col += 0.10*dfcos(t* 17.1+ 0.9, 17.1);\n    col += 0.09*dfcos(t* 31. +11.3, 31.);\n    col += 0.08*dfcos(t* 65. +11.3, 65.);\n    col += 0.07*dfcos(t*131. +10.8,131.);\n    return col;\n}\n\nfloat getIntensity( in float t )\n{\n    float col = 0.4;\n    col += 0.14*cos(t*  1.0+0.6);\n    col += 0.13*cos(t*  3.1+1.0);\n    col += 0.12*cos(t*  5.1+1.1);\n    col += 0.11*cos(t*  9.1+1.2);\n    col += 0.10*cos(t* 17.1+0.9);\n    col += 0.09*cos(t* 31. +11.3);\n    col += 0.08*cos(t* 65. +11.3);\n    col += 0.07*cos(t*131. +10.8);\n    return col;\n}\n\nfloat getIntensityGrad( in float t )\n{\n    float col = 0.;\n    col += 0.14*dcos(t*  1.0+0.6 , 1.0);\n    col += 0.13*dcos(t*  3.1+1.0 , 3.1);\n    col += 0.12*dcos(t*  5.1+1.1 , 5.1);\n    col += 0.11*dcos(t*  9.1+1.2 , 9.1);\n    col += 0.10*dcos(t* 17.1+0.9 , 17.);\n    col += 0.09*dcos(t* 31. +11.3, 31.);\n    col += 0.08*dcos(t* 65. +11.3, 65.);\n    col += 0.07*dcos(t*131. +10.8,131.);\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float thx = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.2*sin(iTime);\n    float thy = (iMouse.z>0.001) ? (2.0*iMouse.y-iResolution.y)/iResolution.y : 1.2*(iResolution.y / iResolution.x)*cos(iTime);\n    bool light = (q.y>thy);\n    bool filt = (q.x>thx);\n    \n    // deformation\n    vec2 p = deform(q);\n    p*=6.2832;\n    \n    // light position\n    vec3 lp = normalize(vec3(cos(iTime),sin(iTime),0.2));\n    \n    vec3 col;\n    if(!light){ // original version by Inigo Quilez \n        float i;\n        if(filt){ // With filtering\n    \t\ti = min(getIntensityFiltered(p.x),getIntensityFiltered(p.y));\n        } else { // Without filtering\n    \t\ti = min(getIntensity(p.x),getIntensity(p.y));\n        }\n        col = pal( i, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n        \n    } else { // shaded version\n        float i1,i2,i;\n        vec3 normal;\n        \n        if(filt){ // With filtering\n            i1 = getIntensityFiltered(p.x);\n            i2 = getIntensityFiltered(p.y);\n            i = min(i1,i2);\n            \n            if(i == i1){\n            \tnormal.x = -getIntensityFilteredGrad(p.x);\n                normal.z = 1.;\n                normal.y = 0.;\n            } else {\n                normal.z = 1.;\n                normal.y = -getIntensityFilteredGrad(p.y);\n                normal.x = 0.;\n            }\n            \n        } else { // Without filtering\n           \ti1 = getIntensity(p.x);\n           \ti2 = getIntensity(p.y);\n           \ti = min(i1,i2);\n            \n            if(i == i1){\n            \tnormal.x = -getIntensityGrad(p.x);\n                normal.z = 1.;\n                normal.y = 0.;\n            } else {\n                normal.z = 1. ;\n                normal.y = -getIntensityGrad(p.y);\n                normal.x = 0.;\n            }\n        }\n \n        normal = normalize(normal);\n        \n        col = pal( i, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n        col = col + max(dot(lp,normal),0.);\n        col *= 0.8;\n    }\n    \n\t\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-thx));\n    col *= smoothstep(0.005,0.010,abs(q.y-thy));\n    \n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}