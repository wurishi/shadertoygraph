{"ver":"0.1","info":{"id":"ftlyzl","date":"1648738192","viewed":83,"name":"Raytracing view dependent points","username":"51m0n397","description":"Rendering of points with consistent thickness regardless of the camera params\nUse the LEFT and RIGHT arrows to cycle between the samplers\nUse the UP and DOWN arrows to change projection\nUse the mouse + ALT or SHIFT to control the camera\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS    12\n#define MAX_RECURSION 10\n\nstruct ray3 {\n    vec3  o;\n    vec3  d;\n    float tmin;\n    float tmax;\n};\n\nstruct intersection {\n    int   id;\n    bool  hit;\n    vec2  uv;\n    float dist;\n    vec3  pos;\n    vec3  norm;\n};\n\nstruct dgram_point {\n    vec3  position;\n    float thickness;\n    vec4  stroke;\n    \n    float radius; \n};\n\nfloat scale = 80.;\nfloat size  = 720.;\n\ndgram_point points[NUM_POINTS] = dgram_point[](\n    dgram_point(vec3(-3., -2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3(-1., -2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3( 1., -2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3( 3., -2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    \n    dgram_point(vec3(-3.,  0., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3(-1.,  0., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3( 1.,  0., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3( 3.,  0., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    \n    dgram_point(vec3(-3.,  2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3(-1.,  2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3( 1.,  2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.),\n    dgram_point(vec3( 3.,  2., 0.), 2., vec4(1.0, 0.0, 0.0, 1.0), 0.)\n);\n\nray3 evalCamera(dgram_camera cam, vec2 uv, vec2 res) {\n    float aspect = res.x / res.y;\n    vec2  film   = aspect >= 1. ? vec2(cam.film, cam.film / aspect)\n                                : vec2(cam.film * aspect, cam.film);\n    frame3 frame = lookat_frame(cam.from, cam.to, vec3(0., 1., 0.), false);\n    float  lens  = cam.lens / size * scale;\n    \n    if (!cam.orthographic) {\n        vec3 q = vec3(film.x * (0.5f - uv.x), film.y * (uv.y - 0.5f), lens);\n        vec3 e = zero3;\n        vec3 d = normalize(-q - e);\n        return ray3(transform_point(frame, e), transform_direction(frame, d), ray_eps, flt_max);\n    } else {\n        float s = length(cam.from - cam.to) / lens;\n        vec3  q = vec3(film.x * (0.5f - uv.x) * s,\n          film.y * (uv.y - 0.5f) * s, lens);\n        vec3  e = vec3(-q.x, -q.y, 0);\n        vec3  d = normalize(-q - e);\n        return ray3(transform_point(frame, e), transform_direction(frame, d), ray_eps, flt_max);\n    }\n}\n\nint getSampler() {\n    return int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n}\n\ndgram_camera getCamera() {\n    bool orthographic = bool(texelFetch(iChannel1, ivec2(0, 1), 0).x);\n    vec3 from         = texelFetch(iChannel1, ivec2(0, 2), 0).xyz;\n    vec3 to           = texelFetch(iChannel1, ivec2(0, 3), 0).xyz;\n    float lens        = texelFetch(iChannel1, ivec2(0, 4), 0).x;\n    float film        = texelFetch(iChannel1, ivec2(0, 5), 0).x;\n\n    return dgram_camera(orthographic, from, to, lens, film);\n}\n\nintersection interstectPoint(ray3 ray, vec3 pc, float r) {\n    intersection isec = intersection(-1, false, zero2, flt_max, zero3, zero3);\n    \n    float a = dot(ray.d, ray.d);\n    float b = 2. * dot(ray.d, ray.o - pc);\n    float c = dot(ray.o - pc, ray.o - pc) - r * r;\n    \n    float t1 = 0.;\n    float t2 = 0.;\n    \n    float discr = b * b - 4. * a * c;\n    if (discr < 0.)\n        return isec; // no hit\n    else if (discr == 0.)\n        t1 = t2 = -0.5 * b / a;\n    else {\n        float q = (b > 0.) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t1      = q / a;\n        t2      = c / q;\n    }\n    \n    float t   = ray.tmax;\n    if (t1 >= ray.tmin && t1 <= t) {\n        t   = t1;\n        isec.hit = true;\n    }\n\n    if (t2 >= ray.tmin && t2 <= t) {\n        t   = t2;\n        isec.hit = true;\n    }\n    \n    if (isec.hit) {\n        isec.dist = t;\n        isec.pos  = ray.o + t * ray.d;\n        isec.norm = normalize(isec.pos - pc);\n        \n        float u = (pi - atan(isec.norm.z, isec.norm.x)) / (2. * pi);\n        float v = (pi - 2. * asin(isec.norm.y)) / (2. * pi);\n        isec.uv = vec2(u, v);\n    }\n    \n    return isec;\n}\n\nintersection intersect_points(dgram_point[NUM_POINTS] points, ray3 ray) {\n    intersection isec = intersection(-1, false, zero2, 0., zero3, zero3);\n    \n    for (int i = 0; i < NUM_POINTS; i++) {\n        intersection new_isec = interstectPoint(ray, points[i].position, points[i].radius);\n        if (new_isec.hit) {\n            ray.tmax = new_isec.dist;\n            isec = new_isec;\n            isec.id = i;\n        }\n    }\n    \n    return isec;\n}\n\nvec4 trace_color(dgram_point[NUM_POINTS] points, ray3 ray) {\n    intersection isec = intersect_points(points, ray);\n    \n    vec4 radiance = zero4;\n    \n    for (int i = 0; i < MAX_RECURSION; i++) {\n        if (isec.hit) {\n            vec4 color = points[isec.id].stroke;\n            radiance = composite(radiance, color);\n            \n            if (color.a < 1.)\n                isec = intersect_points(points, ray3(isec.pos, ray.d, ray_eps, flt_max));\n            else break;\n        } else break;\n    }\n    \n    return radiance;\n}\n\nvec4 trace_normal(dgram_point[NUM_POINTS] points, ray3 ray) {\n    intersection isec = intersect_points(points, ray);\n\n    if (isec.hit) \n        return vec4(isec.norm, 1.);\n    return zero4;\n}\n\nvec4 trace_uv(dgram_point[NUM_POINTS] points, ray3 ray) {\n    intersection isec = intersect_points(points, ray);\n\n    if (isec.hit) \n        return vec4(isec.uv.x, isec.uv.y, 0., 1.);\n    return zero4;\n}\n\nvec4 trace_eyelight(dgram_point[NUM_POINTS] points, ray3 ray) {    \n    intersection isec = intersect_points(points, ray);\n    \n    vec4 radiance = zero4;\n    \n    for (int i = 0; i < MAX_RECURSION; i++) {\n        if (isec.hit) {\n            vec4 stroke = points[isec.id].stroke;\n            vec4 color  = vec4(stroke.xyz * abs(dot(isec.norm, ray.d)), stroke.w);\n            radiance = composite(radiance, color);\n            \n            if (color.a < 1.)\n                isec = intersect_points(points, ray3(isec.pos, ray.d, ray_eps, flt_max));\n            else break;\n        } else break;\n    }\n    \n    return radiance;\n}\n\nvec4 sampler(int trace_sampler, dgram_point[NUM_POINTS] points, ray3 ray) {\n    switch (trace_sampler) {\n    case COLOR_SAMPLER:\n        return trace_color(points, ray);\n    case NORMAL_SAMPLER:\n        return trace_normal(points, ray);\n    case UV_SAMPLER:\n        return trace_uv(points, ray);\n    case EYELIGHT_SAMPLER:\n        return trace_eyelight(points, ray);\n    }\n}\n\ndgram_point[NUM_POINTS] compute_radii(dgram_point[NUM_POINTS] points, dgram_camera cam, vec2 res) {\n    frame3 frame = lookat_frame(cam.from, cam.to, vec3(0., 1., 0.), false);\n    \n    float aspect = res.x / res.y;\n    vec2  film   = aspect >= 1. ? vec2(cam.film, cam.film / aspect)\n                                : vec2(cam.film * aspect, cam.film);\n                                \n    float camera_distance = length(cam.from - cam.to);\n    \n    \n    float plane_distance = -cam.lens * scale / size;\n    \n    for (int i = 0; i < NUM_POINTS; i++) {\n        float radius = cam.orthographic ? points[i].thickness * film.x * camera_distance * 3. /\n                                     (2. * cam.lens * scale)\n                               : points[i].thickness * film.x  * 3. / (2. * size);\n                               \n        if(cam.orthographic) {\n            points[i].radius = radius;\n        } else {\n            vec3 camera_p = transform_point(inverse_frame(frame, false), points[i].position);\n            points[i].radius = radius * abs(camera_p.z / plane_distance);\n        }\n    }\n    \n    return points;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    dgram_camera cam           = getCamera(); \n    int          trace_sampler = getSampler();\n    \n    vec2 uv = vec2(fragCoord.x/iResolution.x, 1.-fragCoord.y/iResolution.y);\n        \n    ray3 ray = evalCamera(cam, uv, iResolution.xy);\n    \n    points = compute_radii(points, cam, iResolution.xy);\n        \n    vec4 color = sampler(trace_sampler, points, ray);\n\n    fragColor = composite(color, vec4(1.));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float ray_eps = 1e-4f;\nconst float flt_max = intBitsToFloat(2139095039);\nconst vec2  zero2   = vec2(0., 0.);\nconst vec3  zero3   = vec3(0., 0., 0.);\nconst vec4  zero4   = vec4(0., 0., 0., 0.);\nconst float pi      = 3.14159265358979323846;\n\nconst int KEY_SHIFT   = 16;\nconst int KEY_CONTROL = 17;\nconst int KEY_ALT     = 18;\nconst int KEY_LEFT    = 37;\nconst int KEY_UP      = 38;\nconst int KEY_RIGHT   = 39;\nconst int KEY_DOWN    = 40;\n\nconst int COLOR_SAMPLER    = 0;\nconst int NORMAL_SAMPLER   = 1;\nconst int UV_SAMPLER       = 2;\nconst int EYELIGHT_SAMPLER = 3;\n\nstruct frame3 {\n    vec3 x;\n    vec3 y;\n    vec3 z;\n    vec3 o;\n};\n\nstruct dgram_camera {\n    bool  orthographic;\n    vec3  from;\n    vec3  to;\n    float lens;\n    float film;\n};\n\nframe3 identity3x4 = frame3(vec3(1., 0., 0.), vec3(0., 1., 0.), vec3(0., 0., 1.), vec3(0., 0., 0.));\n\nmat3 rotation(frame3 a) { return mat3(a.x, a.y, a.z); }\nvec3 translation(frame3 a) { return a.o; }\n\nframe3 make_frame(mat3 m, vec3 t) {\n  return frame3(m[0], m[1], m[2], t);\n}\n\nframe3 lookat_frame(vec3 eye, vec3 center, vec3 up, bool inv_xz) {\n    vec3 w = normalize(eye - center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = normalize(cross(w, u));\n    if (inv_xz) {\n        w = -w;\n        u = -u;\n    }\n    return frame3(u, v, w, eye);\n}\n\nvec3 transform_point(frame3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z + a.o;\n}\n\nvec3 transform_vector(frame3 a, vec3 b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec3 transform_direction(frame3 a, vec3 b) {\n    return normalize(transform_vector(a, b));\n}\n\nframe3 inverse_frame(frame3 a, bool non_rigid) {\n    if (non_rigid) {\n        mat3 minv = inverse(rotation(a));\n        return make_frame(minv, -(minv * a.o));\n    } else {\n        mat3 minv = transpose(rotation(a));\n        return make_frame(minv, -(minv * a.o));\n    }\n}\n\nmat2x3 camera_turntable(vec3 from, vec3 to, vec3 up, vec2 rotate, float dolly, vec2 pan) {\n    if (rotate != zero2) {\n        vec3  z     = normalize(to - from);\n        float lz    = length(to - from);\n        float phi   = atan(z.z, z.x) + rotate.x;\n        float theta = acos(z.y) + rotate.y;\n        theta       = clamp(theta, 0.001f, pi - 0.001f);\n        vec3  nz    = vec3(sin(theta) * cos(phi) * lz, cos(theta) * lz, sin(theta) * sin(phi) * lz);\n        from        = to - nz;\n    }\n\n    if (dolly != 0.) {\n        vec3  z  = normalize(to - from);\n        float lz = max(0.001, length(to - from) * (1. + dolly));\n        z *= lz;\n        from = to - z;\n    }\n\n    if (pan != zero2) {\n        vec3 z = normalize(to - from);\n        vec3 x = normalize(cross(up, z));\n        vec3 y = normalize(cross(z, x));\n        vec3 t = vec3(pan.x * x.x + pan.y * y.x, pan.x * x.y + pan.y * y.y, pan.x * x.z + pan.y * y.z);\n        from += t;\n        to += t;\n    }\n\n    return mat2x3(from, to);\n}\n\nvec4 composite(vec4 a, vec4 b) {\n    if (a.w == 0. && b.w == 0.) return zero4;\n    vec3 cc = a.xyz * a.w + b.xyz * b.w * (1. - a.w);\n    float ca = a.w + b.w * (1. - a.w);\n    return vec4(cc.x / ca, cc.y / ca, cc.z / ca, ca);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool keypress(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.;\n}\n\nint getSampler() {\n    return int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n}\n\n\nint handleKeyboard(int sampler) {\n    if (keypress(KEY_RIGHT)) {\n        if(++sampler > EYELIGHT_SAMPLER)\n            sampler = COLOR_SAMPLER;\n    }\n    \n    if (keypress(KEY_LEFT)) {\n        if(--sampler < COLOR_SAMPLER)\n            sampler = EYELIGHT_SAMPLER;\n    }\n    \n    return sampler;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int sampler = getSampler();\n    \n    sampler = handleKeyboard(sampler);\n    \n    fragColor = vec4(sampler, 0., 0., 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool keystate(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.;\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.;\n}\n\nbool keytoggle(int key) {\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.;\n}\n\nvec4 getPrevMouse() {\n    return texelFetch(iChannel2, ivec2(0, 0), 0);\n}\n\n\ndgram_camera getCamera() {\n    dgram_camera cam = dgram_camera(true, vec3(0., 0., 5.), vec3(0., 0., 0.), 0.036f, 0.036f); \n    \n    bool changed = bool(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    \n    if (changed) {    \n        cam.orthographic = bool(texelFetch(iChannel0, ivec2(0, 1), 0).x);\n        cam.from         = texelFetch(iChannel0, ivec2(0, 2), 0).xyz;\n        cam.to           = texelFetch(iChannel0, ivec2(0, 3), 0).xyz;\n        cam.lens         = texelFetch(iChannel0, ivec2(0, 4), 0).x;\n        cam.film         = texelFetch(iChannel0, ivec2(0, 5), 0).x;\n    }\n\n    return cam;\n}\n\nvec4 setCamera(dgram_camera cam, vec2 coord) {\n    switch(int(coord.y)) {\n    case 0:\n        return vec4(1., 0., 0., 0.);\n    case 1:\n        return vec4(int(cam.orthographic), 0., 0., 0.);\n    case 2:\n        return vec4(cam.from, 0.);\n    case 3:\n        return vec4(cam.to, 0.);\n    case 4:\n        return vec4(cam.lens, 0., 0., 0.);\n    case 5:\n        return vec4(cam.film, 0., 0., 0.);\n    }\n}\n\n\ndgram_camera updateCamera(dgram_camera cam) {\n    if (keypress(KEY_UP)) {\n        cam.orthographic = true;\n    }\n    \n    if (keypress(KEY_DOWN)) {\n        cam.orthographic = false;\n    }\n    \n    vec4 pMouse = getPrevMouse();\n    \n    if (iMouse.z > 0. && pMouse.z > 0.) {\n        float dolly  = 0.;\n        vec2  pan    = zero2;\n        vec2  rotate = zero2;\n        \n        if (keystate(KEY_SHIFT)) {\n            pan = (iMouse.xy - pMouse.xy) * distance(cam.from, cam.to) / 200.0f;\n        } else if (keystate(KEY_ALT)) {\n            dolly = (iMouse.y - pMouse.y) / 100.0f;\n        } else {\n            rotate = (iMouse.xy - pMouse.xy) / 100.0f;\n        }\n        \n        mat2x3 from_to = camera_turntable(cam.from, cam.to, vec3(0., 1., 0), rotate, dolly, pan);\n        \n        cam.from = from_to[0];\n        cam.to   = from_to[1];\n    }\n    \n    return cam;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    dgram_camera cam = getCamera();\n    \n    cam = updateCamera(cam);\n        \n    fragColor = setCamera(cam, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    fragColor = iMouse;\n}","name":"Buffer C","description":"","type":"buffer"}]}