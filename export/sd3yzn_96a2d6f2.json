{"ver":"0.1","info":{"id":"sd3yzn","date":"1692585645","viewed":161,"name":"Voronoi based pixelation","username":"WhiteWalrus518","description":"Yay a thing\n\nI may have already posted this lol","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["voronoi","artsy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nvec2 randomSpin(vec2 p, float f){\n    return 1.0 * vec2(\n    cos( f * iTime * 3.14159 * sign(random2(p).y - 0.5) + random2(p).y * 3.14159), \n    sin( f * iTime * 3.14159 * sign(random2(p).x - 0.5) + random2(p).x * 3.14159));\n}\nvec4 VoronoiPixelation(vec2 uv, float pixH ){\n    vec2 pixInt = fract(uv * pixH);\n    vec2 pixExt = floor(uv * pixH);\n    float m_dist = 10.0;\n    vec2 relClos = vec2(0.0);\n    vec2 relRot = 0.5 * vec2(cos(iTime), sin(iTime));\n\n\n    for (int y= -3; y <= 3; y++) {\n        for (int x= -3; x <= 3; x++) {\n            vec2 neighbor = vec2(float(x),float(y));\n\n            vec2 point = random2(pixExt + neighbor);\n            vec2 relRot = randomSpin(pixExt + neighbor, 0.5);\n            vec2 diff = neighbor + relRot + point - pixInt;\n            float dist = length(diff);\n            if(dist < m_dist){\n                m_dist = dist;\n                relClos = neighbor;\n            }\n        }\n    }\n    vec2 nPoint = pixExt + relClos + randomSpin(pixExt + relClos, 0.5) + random2(pixExt + relClos);\n    nPoint = nPoint / pixH;\n    nPoint.x = nPoint.x * iResolution.y / iResolution.x ;\n    \n    return texture(iChannel0, nPoint);\n}\nvec4 VoronoiPixelation2(vec2 uv, float pixH ){\n    vec2 pixInt = fract(uv * pixH);\n    vec2 pixExt = floor(uv * pixH);\n    float m_dist = 10.0;\n    vec2 relClos = vec2(0.0);\n    vec2 relRot = 0.5 * vec2(cos(iTime), sin(iTime));\n\n\n    for (int y= -3; y <= 3; y++) {\n        for (int x= -3; x <= 3; x++) {\n            vec2 neighbor = vec2(float(x),float(y));\n\n            vec2 point = random2(pixExt + neighbor);\n            vec2 relRot = randomSpin(pixExt + neighbor, 0.5);\n            vec2 diff = neighbor + relRot + point - pixInt;\n            float dist = length(diff);\n            if(dist < m_dist){\n                m_dist = dist;\n                relClos = neighbor;\n            }\n        }\n    }\n    vec2 nPoint = pixExt + relClos + random2(pixExt + relClos);\n    nPoint = nPoint / pixH;\n    nPoint.x = nPoint.x * iResolution.y / iResolution.x ;\n    \n    return texture(iChannel0, nPoint);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x = iResolution.x/ iResolution.y - uv.x;\n    vec2 st = fragCoord / iResolution.xy;\n    st.x = 1.0 - st.x;\n    \n    float pixH =  100.0;\n    vec3 col;\n    col = texture(iChannel0, st).xyz;\n    col = VoronoiPixelation(uv,pixH).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0) ;\n}","name":"Image","description":"","type":"image"}]}