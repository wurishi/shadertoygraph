{"ver":"0.1","info":{"id":"mtdcR7","date":"1699033161","viewed":84,"name":"Bloodscape","username":"connectamey","description":"horror shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["horror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Bloodscape\" - A Blood Shader\n * Based on \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\n// Constants\nconst int NUM_STEPS = 8;             // Number of raymarching steps\nconst float PI = 3.141592;            // The mathematical constant pi\nconst float EPSILON = 1e-3;          // A small value for numerical stability\n#define EPSILON_NRM (0.1 / iResolution.x)  // Normal epsilon for raymarching\n#define AA  // Enable Anti-Aliasing\n\n// Blood parameters\nconst int ITER_GEOMETRY = 3;          // Iterations for geometry\nconst int ITER_FRAGMENT = 5;          // Iterations for fragments\nconst float BLOOD_HEIGHT = 0.6;      // Blood height\nconst float BLOOD_CHOPPY = 4.0;      // Blood choppy factor\nconst float BLOOD_SPEED = 0.8;       // Blood animation speed\nconst float BLOOD_FREQ = 0.16;       // Blood frequency\nconst vec3 BLOOD_BASE = vec3(0.5, 0.0, 0.0); // Base blood color\nconst vec3 BLOOD_COLOR = vec3(0.8, 0.1, 0.1);  // Blood color\n#define BLOOD_TIME (1.0 + iTime * BLOOD_SPEED)  // Blood animation time\nconst mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);  // Octave matrix for blood noise\n\n// Math functions\n\n// Function to create a rotation matrix from Euler angles\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x), cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y), cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z), cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y * a3.y + a1.x * a2.x * a3.x, a1.y * a2.x * a3.x + a3.y * a1.x, -a2.y * a3.x);\n    m[1] = vec3(-a2.y * a1.x, a1.y * a2.y, a2.x);\n    m[2] = vec3(a3.y * a1.x * a2.x + a1.y * a3.x, a1.x * a3.x - a1.y * a3.y * a2.x, a2.y * a3.y);\n    return m;\n}\n\n// Function to generate a pseudo-random value based on 2D input\nfloat hash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453123);\n}\n\n// Function to generate Perlin-like noise based on 2D input\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x), mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// Lighting functions\n\n// Function to calculate diffuse reflection\nfloat diffuse(vec3 n, vec3 l, float p) {\n    return pow(dot(n, l) * 0.4 + 0.6, p);\n}\n\n// Function to calculate specular reflection\nfloat specular(vec3 n, vec3 l, vec3 e, float s) {\n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n}\n\n// Sky function\n\n// Function to calculate sky color\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y, 0.0) * 0.8 + 0.2) * 0.8;\n    return vec3(pow(1.0 - e.y, 2.0), 1.0 - e.y, 0.6 + (1.0 - e.y) * 0.4) * 1.1;\n}\n\n// Blood functions\n\n// Function to generate blood noise using octaves\nfloat blood_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0 - abs(sin(uv));\n    vec2 swv = abs(cos(uv));\n    wv = mix(wv, swv, wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n}\n\n// Function to map a point in 3D space to the blood surface\nfloat map(vec3 p) {\n    float freq = BLOOD_FREQ;\n    float amp = BLOOD_HEIGHT;\n    float choppy = BLOOD_CHOPPY;\n    vec2 uv = p.xz;\n    uv.x *= 0.75;\n\n    float d, h = 0.0;\n    for (int i = 0; i < ITER_GEOMETRY; i++) {\n        d = blood_octave((uv + BLOOD_TIME) * freq, choppy);\n        d += blood_octave((uv - BLOOD_TIME) * freq, choppy);\n        h += d * amp;\n        uv *= octave_m;\n        freq *= 1.9;\n        amp *= 0.22;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n    return p.y - h;\n}\n\n// Function to map a point in 3D space with more detail\nfloat map_detailed(vec3 p) {\n    float freq = BLOOD_FREQ;\n    float amp = BLOOD_HEIGHT;\n    float choppy = BLOOD_CHOPPY;\n    vec2 uv = p.xz;\n    uv.x *= 0.75;\n\n    float d, h = 0.0;\n    for (int i = 0; i < ITER_FRAGMENT; i++) {\n        d = blood_octave((uv + BLOOD_TIME) * freq, choppy);\n        d += blood_octave((uv - BLOOD_TIME) * freq, choppy);\n        h += d * amp;\n        uv *= octave_m;\n        freq *= 1.9;\n        amp *= 0.22;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n    return p.y - h;\n}\n\n// Function to calculate the final color of a pixel on the blood surface\nvec3 getBloodColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {\n    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);\n    fresnel = min(pow(fresnel, 3.0), 0.5);\n\n    // Calculate the reflection and refraction colors\n    vec3 reflected = getSkyColor(reflect(eye, n));\n    vec3 refracted = BLOOD_BASE + diffuse(n, l, 80.0) * BLOOD_COLOR * 0.12;\n\n    // Apply random variations to the blood color\n    float randomFactor = noise(p.xz + iTime);\n    vec3 bloodColorWithVariation = BLOOD_COLOR + vec3(randomFactor, 0.0, 0.0); // You can adjust the variation here\n\n    // Apply the Fresnel effect to blend the reflection and refraction based on the Fresnel factor\n    vec3 color = mix(refracted, reflected, fresnel);\n\n    // Add attenuation based on distance\n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += bloodColorWithVariation * (p.y - BLOOD_HEIGHT) * 0.18 * atten;\n\n    // Add specular lighting\n    color += vec3(specular(n, l, eye, 60.0));\n\n    return color;\n}\n\n// Tracing functions\n\n// Function to calculate the surface normal at a point with a small offset\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);\n    n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x, p.y, p.z + eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\n// Function to perform heightmap-based ray tracing\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {\n    float tm = 0.0;\n    float tx = 1000.0;\n    float hx = map(ori + dir * tx);\n    if (hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;\n    }\n    float hm = map(ori + dir * tm);\n    float tmid = 0.0;\n    for (int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm, tx, hm / (hm - hx));\n        p = ori + dir * tmid;\n        float hmid = map(p);\n        if (hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// Main pixel rendering function\n\n// Function to calculate the color of a pixel\nvec3 getPixel(in vec2 coord, float time) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Ray direction and origin\n    vec3 ang = vec3(sin(time * 3.0) * 0.1, sin(time) * 0.2 + 0.3, time);\n    vec3 ori = vec3(0.0, 3.5, time * 5.0);\n    vec3 dir = normalize(vec3(uv.xy, -2.0));\n    dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n\n    // Tracing\n    vec3 p;\n    heightMapTracing(ori, dir, p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0, 1.0, 0.8));\n\n    // Calculate the final color with ambient lighting\n    vec3 finalColor = mix(\n        getSkyColor(dir),\n        getBloodColor(p, n, light, dir, dist),\n        pow(smoothstep(0.0, -0.02, dir.y), 0.2));\n\n    // Add ambient lighting\n    vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n    finalColor += ambientColor;\n\n    // Add specular reflection\n    finalColor += vec3(specular(n, light, dir, 60.0));\n\n    return finalColor;\n}\n\n// Main function to render the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Time-based animation for 'BLOOD_TIME'\n    #define ANIMATION_SPEED 0.2\n    float bloodTime = 1.0 + iTime * BLOOD_SPEED * ANIMATION_SPEED;\n\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 uv = fragCoord + vec2(i, j) / 3.0;\n            color += getPixel(uv, bloodTime);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, bloodTime);\n#endif\n\n    // Apply post-processing and set the final color\n    fragColor = vec4(pow(color, vec3(0.65)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}