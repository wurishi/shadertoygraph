{"ver":"0.1","info":{"id":"Xc2XDd","date":"1706999548","viewed":186,"name":"Easy adaptive sampling bugfix","username":"DigitalShadow","description":"This is an adaptaton of FabriceNeyret2's shader to isolate and bypass a bug on some graphics cards; \n\nIn the case where textureLod returns inconsistant or corrupted data, averaging a chunk of pixels in software is a cheap and dirty solution.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","antialiasing","sampling","optimization","adaptive","gpmipmap","spacefungus"],"hasliked":0,"parentid":"Wt2fzV","parentname":"easy adaptive sampling: raytrace"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Original method of sampling texture mipmap(line 10) is replaced\n    with a funciton call (line 11)\n*/\n\n#define N 3      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold\n\n\n//#define T(U,l)      textureLod(iChannel0, (U)/R, float(l-1) )\n#define T(U,l)        getTexture(U, l-1)\n\n#define M(U,l)        ( length( T(U,l).rgb )*.58 ) \n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\n\n//Manual mipmap emulation \nvec4 getTexture(vec2 uv, int lod)\n{\n    vec4 tex = vec4(0);\n    vec2 offset = vec2(0);\n    \n    //exit early if no averaging required\n    if(lod <= 0) return texture(iChannel0, uv / R);\n    \n    //get average of lod ^ 2 samples\n    for(int iY = 0; iY < lod; iY++)\n    for(int iX = 0; iX < lod; iX++)\n    {{\n        offset = vec2(iX, iY) - float(lod-1) / 2.;\n        tex += texture(iChannel0, (uv+offset) / R);\n    }}\n    tex /= float(lod*lod);\n    \n    \n    return tex;\n}\n\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    // normalized centered coords\n    vec2  U = ( 2.*u - R ) / R.y;      \n    \n    //background color\n    O *= 0.;                            \n    vec4 C = vec4(0);\n\n    float n = float(N),\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n    \n    //check if within AA reigon and if pixel neighbors exceed difference threshold\n    if ( u.x > s && length( T(u,5) - T(u,0) ) > eps ) \n    {\n        //if so, oversample pixel coordinate\n        for(int iY = 0; iY < N; iY++)\n        for(int iX = 0; iX < N; iX++)\n        {{\n            //get subpixel coordinate\n            vec2 D = (vec2(iX, iY) - float(N - 1) / 2.) / n;\n            //get sample at subpixel\n            C += f(  U +  2.*D/R.y , iTime);\n        }}\n        //average subpixels to pixel value\n        C /= n*n;\n    }\n    else\n        //when oversampling isn't required, use existing pixel value from buffer\n        C = T( u, 0 ), \n        //use space bar to toggle dimming of non-oversampled pixels\n        keyToggle(32) ? C.r *= .025, C.g *= 0.025, C.b *= 0.025: n;\n    \n    //apply color value to background using alpha channel\n    O = mix( O, C, C.a );\n    \n    //draw red seperator\n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1);\n    //convert to sRGB\n    O = pow( O, vec4(1./2.2) );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// --- custom function or image or render\n\n#define R  iResolution.xy\n\n\n// Space fungus https://www.shadertoy.com/view/lsSBWh\nvec4 f(vec2 U, float t) {\n    float a,b;                                             // materials id\n    mat2  rot = mat2( cos( .1*t + vec4(0,33,11,0)) );  \n    vec3  D = normalize( vec3(U,-1) ),                     // ray direction\n          p = vec3(0,0,13), q;                             // ray origine\n    \n    vec4  O = vec4(1);\n    for ( ; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= rot,\n        q.yz *= rot,\n        t = max( length(q) - 9.,                           // Sphere\n                 abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ),    // EggCarton\n        t = max( t, 8.5-length(q) ),                       // inner hole\n        q = mod(q,.5)-.25, t = max(t,.2-length(q) ),       // cheese holes \n        p += t*D;\n\n    if (O.x>0.) O.r -= b/30., O.g -= a, O*=O,              // coloring\n                O.a = 1.;                                  // hit -> opaque\n       else     O -= O;\n    return O;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n    O = f( U, iTime );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}