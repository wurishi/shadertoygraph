{"ver":"0.1","info":{"id":"dts3zM","date":"1671711303","viewed":132,"name":"Pixelating ðŸŽ¨","username":"blurryroots","description":"Naive approach to pixelising textures.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","texture","pixel","sampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n// Use to align grid to the left.\n#define MODE_FLOOR floor\n// Use to align grid to the center (e.g. with fractional pixel sizes).\n#define MODE_ROUND round\n\n// Method to discretise pixel grid.\n#define DISCRETISE MODE_FLOOR\n\nfloat psin (float t) { return (1. + sin (t)) / 2.; }\n\nvec2 pixelise (float pixel_size, inout vec2 coords, inout vec3 res) {\n    // Defines the amount of pixels to fill y.\n    float pixel_resolution_y = res.x / pixel_size;\n    // The factor to multiply incoming frag coordinates and screen resolution.\n    float pixel_factor = pixel_resolution_y / res.y;\n    \n    // Project fragment to pixel grid and discretise.\n    coords = DISCRETISE (coords * pixel_factor);\n    // Project display resolution to pixel grid and discretise.\n    res = DISCRETISE (res * pixel_factor);\n    \n    // Discretised uv space for texture sampling.\n    vec2 pixel_uv = coords.xy / res.xy;\n    return pixel_uv;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime/1.;\n    \n    // Define the size (width) of a pixel.\n    float pixel_size = 8. * floor (1. + mod (t, 8.));\n    // Setup pixel resolution and fragment coordinates.\n    vec3 pixel_res = iResolution;\n    vec2 pixel_coord = fragCoord;\n    // Discretised uv space for texture sampling.\n    vec2 pixel_uv = pixelise (pixel_size, fragCoord, pixel_res);\n    // Sample texture.\n    fragColor = texture (iChannel0, pixel_uv);\n}","name":"Image","description":"","type":"image"}]}