{"ver":"0.1","info":{"id":"WtKXWm","date":"1582864719","viewed":411,"name":"Coral growth","username":"TGlad","description":"This is a form of Laplacian growth that I made. It looks a bit like growing coral. Left click to add extra yellow chemical, or to reset the sim in full screen mode.\n\nboundary growth = (blue*yellow - smoothness)*(blue-yellow).","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["tree","laplacian","dla","viscousfingering","coral","dbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backgroundChemical = vec3(0.2, 0.5, 0.7);\n    vec3 treeChemical = vec3(0.5, 0.6, 0.0);\n    vec3 treeColour = vec3(0.6, 0.2, 0.1);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 val=texture(iChannel0, uv).xyz;\n    \n    vec3 combined = backgroundChemical*sqrt(val.x) + treeChemical*val.y + treeColour*val.z;\n    fragColor = vec4(combined,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fractal diffusion algorithm by Thomas Lowe\n// Use the left mouse button to add yellow chemical source, notice that the tree branches\n// attract towards it.\n\n// This algorithm is a form of Laplacian growth function\n// but rather than one diffused chemical (creating a thin tree) it uses two so generates\n// a thick tree with once chemical diffusing inside and one diffusing outside\n// The boundary of the tree (in blue) then grows in proportion to the gradient gX of \n// the chemical X (red) and the gradient gY of the chemical Y (green) such that:\n//\n//          growth rate = (gXgY-smoothness)(gX-gY)\n//\n// the first term is a signed version of Laplacian growth, so\n// when the first term is positive it makes the boundary more rough, and \n// when the first term is negative it makes the boundary more smooth.\n//\n// when the 'stochastic' parameter is set, the growth rate is applied as a probability of\n// adding or removing one pixel. Otherwise it is applied as a sub-pixel addition to the\n// boundary.\n\nconst float growth = 0.015;      // 0-inf controls how fast pixels are added to the shape. Too large and it saturates (use checkGrowthIsntTooLarge)\nconst float smoothness = 1.0;    // 0-inf \nconst float regeneration = 130.0;// 1-inf this regenerates the chemicals slowly \n\nconst bool stochastic = true; \nconst bool sayHi = false;\nconst bool checkGrowthIsntTooLarge = false; // if enabled the rendering will mess up (glow white) at some point if the growth value is too large\n\n// random functions courtesy of TomF.\nfloat nrand(vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat n1rand(vec2 n)\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\n\nconst float dt = 1.0;\n\nfloat distToBox(in vec2 pos, in vec2 boxMin, in vec2 boxMax)\n{\n    float expand = 0.1;\n    boxMin -= vec2(expand,expand);\n    boxMax += vec2(expand,expand);\n    float bMax = max(pos.x - boxMax.x, pos.y - boxMax.y);\n    float bMin = max(boxMin.x - pos.x, boxMin.y - pos.y);\n    return max(bMax, bMin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    fragColor = vec4(0.0,0.0,0.0,0.1);\n    if(iFrame == 0 || (iMouse.z > 0.0 && iResolution.x>1000.0))\n    {\n        if (sayHi)\n        {\n            vec2 pos = fragCoord * 9.0 / iResolution.y;\n            pos.y = 9.0 - pos.y;\n            float minDist = 1000.0;\n            float distH = min(distToBox(pos, vec2(2.0,2.0), vec2(3.0,7.0)),\n                          min(distToBox(pos, vec2(2.0,4.0), vec2(6.0,5.0)), \n                              distToBox(pos, vec2(5.0,2.0), vec2(6.0,7.0))));\n            minDist = min(minDist, distH);\n            float distI = min(distToBox(pos, vec2(8.0,2.0), vec2(11.0,3.0)),\n                          min(distToBox(pos, vec2(9.0,2.0), vec2(10.0,7.0)), \n                              distToBox(pos, vec2(8.0,6.0), vec2(11.0,7.0))));\n            minDist = min(minDist, distI);\n            float distEx = min(distToBox(pos, vec2(13.0,2.0), vec2(14.0,5.0)),\n                               distToBox(pos, vec2(13.0,6.0), vec2(14.0,7.0)));\n            minDist = min(minDist, distEx);\n            minDist /= 2.0;\n            if (minDist > 0.0)\n                fragColor.z = 0.0;\n            else\n                fragColor.z = 1.0;\n            if (minDist > 0.01)\n                fragColor.x = clamp(minDist-0.05, 0.0, 1.0);\n            else if (minDist < -0.01)\n                fragColor.y = clamp((-minDist)-0.05, 0.0, 1.0);\n        }\n        else\n        {\n            float dist = distance(fragCoord.xy, vec2(0.5,0.5)*iResolution.xy);\n            float mid = 0.28;\n            if (dist < iResolution.y*mid)\n            {\n                fragColor.z = 1.0;\n                fragColor.x = 0.0;\n                fragColor.y = cos(dist * 0.5*3.1415/(iResolution.y*(mid-0.01)));\n                fragColor.y = max(0.0, fragColor.y);\n            }\n            else\n            {\n                fragColor.z = 0.0;\n                fragColor.y = 0.0;\n                fragColor.x = (dist - iResolution.y*(mid+0.01))/(iResolution.y*(0.49-(mid+0.01)));\n                fragColor.x = clamp(fragColor.x, 0.0, 1.0);\n            }\n        }\n        return;\n    }\n   \n    vec2 position = uv;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\n    vec3 e0 = texture( iChannel0,  position - P.zy).xyz;\n    vec3 e1 = texture( iChannel0,  position - P.xz).xyz;\n    vec3 e2 = texture( iChannel0,  position + P.xz).xyz;\n    vec3 e3 = texture( iChannel0,  position + P.zy).xyz;\n\n    vec3 c0 = texture( iChannel0,  position - P.xy).xyz;\n    vec3 c1 = texture( iChannel0,  position - P.wy).xyz;\n    vec3 c2 = texture( iChannel0,  position + P.wy).xyz;\n    vec3 c3 = texture( iChannel0,  position + P.xy).xyz;\n\n    vec3 m = texture( iChannel0,  position).xyz;\n    vec2 delta;\n    \n    // Diffusion of chemical x and y\n    if (stochastic)\n    {\n        delta.x = e0.x + e1.x + e2.x + e3.x;\n        delta.x += 0.5*(c0.x + c1.x + c2.x + c3.x);\n        delta.x -= 6.0*m.x;\n\n        delta.y = e0.y + e1.y + e2.y + e3.y;\n        delta.y += 0.5*(c0.y + c1.y + c2.y + c3.y);\n        delta.y -= 6.0*m.y;\n\n        delta /= 6.0;  \n    }\n    else\n    {\n        float denomX = (1.0-e0.z) + (1.0-e1.z) + (1.0-e2.z) + (1.0-e3.z);\n        denomX += 0.5*((1.0-c0.z) + (1.0-c1.z) + (1.0-c2.z) + (1.0-c3.z));\n        float denomY = e0.z + e1.z + e2.z + e3.z;\n        denomY += 0.5*(c0.z + c1.z + c2.z + c3.z);\n\n        delta.x = e0.x*(1.0-e0.z) + e1.x*(1.0-e1.z) + e2.x*(1.0-e2.z) + e3.x*(1.0-e3.z);\n        delta.x += 0.5*(c0.x*(1.0-c0.z) + c1.x*(1.0-c1.z) + c2.x*(1.0-c2.z) + c3.x*(1.0-c3.z));\n\n        // Note: there dX and dY functions are a little heuristic, we can't just set the\n        // centre pixel to a darkened (by z) average of the Moore neighbourhood as this would be\n        // darker than it should be.\n        float dX = denomX + max(0.0, min(denomY, 2.0) + max(0.0, (denomY - 2.0)/2.0) - m.z);\n        delta.x /= dX;\n\n        delta.y = e0.y*e0.z + e1.y*e1.z + e2.y*e2.z + e3.y*e3.z;\n        delta.y += 0.5*(c0.y*c0.z + c1.y*c1.z + c2.y*c2.z + c3.y*c3.z);\n\n        float dY = denomY + max(0.0, min(denomX, 2.0) + max(0.0, (denomX - 2.0)/2.0) - (1.0-m.z));\n        delta.y /= dY;\n\n        delta -= vec2(m.x, m.y);\n    }\n    delta *= 1.4;\n    m.xy = clamp(vec2(m.x+delta.x*dt, m.y+delta.y*dt), 0.0, 1.0);\n    \n    // Grow or shrink the tree\n    if (stochastic)\n    {\n        float maxX = max(e0.x, max(e1.x, max(e2.x, e3.x)));\n        float maxX2 = max(c0.x, max(c1.x, max(c2.x, c3.x)));\n        if (maxX > 0.0)\n          maxX = max(maxX, maxX2*0.707);\n        float maxY = max(e0.y, max(e1.y, max(e2.y, e3.y)));\n        float maxY2 = max(c0.y, max(c1.y, max(c2.y, c3.y)));\n        if (maxY > 0.0)\n          maxY = max(maxY, maxY2*0.707);\n\n        maxX /= pixelSize.y;\n        maxY /= pixelSize.y;\n\n        fragColor.z = m.z;\n        float gX = m.x/pixelSize.y;\n        float gY = m.y/pixelSize.y;\n\n        float p = 0.0;\n        if (m.z < 0.5)\n        {\n            // if m.x or m.y are 0, it should gives p=0\n            p = growth*(gX*maxY - smoothness)*(gX-maxY);\n            if (n1rand(uv) < p)\n                fragColor.z = 1.0;\n        }\n        else\n        {\n            p = growth*(gY*maxX - smoothness)*(gY-maxX);\n            if (n1rand(uv) < p)\n                fragColor.z = 0.0;\n        }  \n        if (p > 1.0 && checkGrowthIsntTooLarge)\n        {\n            fragColor.xyz = vec3(1.0,1.0,1.0);\n            return;\n        }\n    }\n    else\n    {\n        fragColor.z = m.z;\n        fragColor.z = max(0.0, min(fragColor.z, 1.0));\n        // For this sub-pixel calculation the gradient is higher when the pixel intersects\n        // more with the boundary\n        float gX = m.x/((1.0-0.5*m.z)*pixelSize.y);\n        float gY = m.y/((1.0-0.5*(1.0-m.z))*pixelSize.y);\n\n        if (m.z>0.0 && m.z<1.0)\n        {\n            float p = growth*(gX*gY - smoothness)*(gX-gY);\n            if (p > 1.0 && checkGrowthIsntTooLarge)\n            {\n    \t      fragColor.xyz = vec3(1.0,1.0,1.0);\n    \t        return;\n            }\n            fragColor.z += p;\n        }\n\n        const float mx = 0.999;\n        const float mn = 0.001;\n        float extra = max(0.0, e0.z-mx) + max(0.0, e1.z-mx) + max(0.0, e2.z-mx) + max(0.0, e3.z-mx); \n        float extra2= max(0.0, c0.z-mx) + max(0.0, c1.z-mx) + max(0.0, c2.z-mx) + max(0.0, c3.z-mx); \n        float under = min(e0.z-mn, 0.0) + min(e1.z-mn, 0.0) + min(e2.z-mn, 0.0) + min(e3.z-mn, 0.0); \n        float under2= min(c0.z-mn, 0.0) + min(c1.z-mn, 0.0) + min(c2.z-mn, 0.0) + min(c3.z-mn, 0.0); \n\n        extra += extra2/2.0;\n        under += under2/2.0;\n        if (fragColor.z <= 0.0 && extra > 0.0)\n        {\n          fragColor.z += extra/3.0;\n        }\n        if (fragColor.z >= 1.0 && under < 0.0)\n        {\n          fragColor.z += under/3.0;\n        }\n        fragColor.z = max(-1.0, min(fragColor.z, 2.0));\n    }\n    float scale = 1.0 + regeneration*pixelSize.y*pixelSize.y;\n    fragColor.x = (1.0 - pow(1.0-m.x, scale));\n    fragColor.y = (1.0 - pow(1.0-m.y, scale));\n\n    if (fragColor.z <= 0.0)\n        fragColor.y = 0.0;\n    else if (fragColor.z >= 1.0)\n        fragColor.x = 0.0;\n    \n    if (iMouse.z > 0.0 && length(fragCoord.xy - iMouse.xy) < 20.0)\n        fragColor.y = 1.0;       \n}\n","name":"Buffer A","description":"","type":"buffer"}]}