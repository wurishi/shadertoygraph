{"ver":"0.1","info":{"id":"WtfSD7","date":"1563132494","viewed":264,"name":"Endless path","username":"bkpjjj","description":"just playing with ray marching","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 mod3D289( vec3 x ) { return x - floor( x / 289.0 ) * 289.0; }\nvec4 mod3D289( vec4 x ) { return x - floor( x / 289.0 ) * 289.0; }\nvec4 permute( vec4 x ) { return mod3D289( ( x * 34.0 + 1.0 ) * x ); }\nvec4 taylorInvSqrt( vec4 r ) { return 1.79284291400159 - r * 0.85373472095314; }\n//simplex noise3D\nfloat snoise( vec3 v )\n{\n\tconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n\tvec3 i = floor( v + dot( v, C.yyy ) );\n\tvec3 x0 = v - i + dot( i, C.xxx );\n\tvec3 g = step( x0.yzx, x0.xyz );\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - 0.5;\n\ti = mod3D289( i);\n\tvec4 p = permute( permute( permute( i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\tvec4 j = p - 49.0 * floor( p / 49.0 );  // mod(p,7*7)\n\tvec4 x_ = floor( j / 7.0 );\n\tvec4 y_ = floor( j - 7.0 * x_ );  // mod(j,N)\n\tvec4 x = ( x_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n\tvec4 y = ( y_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n\tvec4 h = 1.0 - abs( x ) - abs( y );\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\n\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\n\tvec4 sh = -step( h, vec4(0.0) );\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 g0 = vec3( a0.xy, h.x );\n\tvec3 g1 = vec3( a0.zw, h.y );\n\tvec3 g2 = vec3( a1.xy, h.z );\n\tvec3 g3 = vec3( a1.zw, h.w );\n  \tvec4 norm = taylorInvSqrt( vec4( dot( g0, g0 ), dot( g1, g1 ), dot( g2, g2 ), dot( g3, g3 ) ) );\n\tg0 *= norm.x;\n\tg1 *= norm.y;\n\tg2 *= norm.z;\n\tg3 *= norm.w;\n\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n\tm = m* m;\n\tm = m* m;\n\tvec4 px = vec4( dot( x0, g0 ), dot( x1, g1 ), dot( x2, g2 ), dot( x3, g3 ) );\n\treturn 42.0 * dot( m, px);\n}\n\nfloat sdf_Cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdf_plane(vec3 rp,vec4 p){\n    \n \treturn dot(rp,normalize(p.xyz))+p.w;  \n}\n\nfloat sdf(vec3 rp){\n \t\n    vec3 p = rp;\n    \n    p.y += snoise(rp*0.1)*0.5+0.5;\n    p.y += snoise(rp*0.01)*5.0+5.0;\n    p.y += snoise(rp*0.001)*10.0+5.0;\n    \n    vec3 cp = rp+vec3(6.0,0,0);\n    vec3 cp2 = rp+vec3(6.,3,0);\n \n   cp.xz = mod(cp.xz+6.,12.0)-6.;\n  cp.y = mod(cp.y+1.,2.0)-1.;\n    cp2.xz = mod(cp2.xz+6.,12.0)-6.;\n  cp2.y = mod(cp2.y+1.,2.0)-1.;\n\n    \n    float c = sdf_Cylinder(cp,1.0,0.8);\n    float c2 = sdf_Cylinder(cp2,1.1,0.2);\n    \n    return min(c,min(c2,sdf_plane(p,vec4(0,1,0,1))));\n}\n\n\nfloat RayMarch(vec3 ro , vec3 rd , int MAX_IT , out float steps){\n \tfloat z = 0.;\n    \n    for(int i = 0;i <= MAX_IT;i++){\n        steps = float(i);\n        if(z > 100.){steps=0.;break;}\n        \n        vec3 rp = ro + rd * z;\n        \n        float l = sdf(rp);\n        \n        \n        if(l < 0.001){break;}\n        \n        z += l;\n    }\n  \tsteps /= float(MAX_IT);\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.,5.,-5);\n    ro.z += iTime*10.0;\n    \n    vec3 mv = ro;\n    \n    ro.y -= snoise(mv*0.1)*0.5+0.5;\n    ro.y -= snoise(mv*0.01)*5.0+5.0;\n    ro.y -= snoise(mv*0.001)*10.0+5.0;\n    \n    vec3 rd = normalize(vec3(uv,1.));\n    \n    float a = sin(iTime*2.0)*0.04;\n    \n    rd.xy *= mat2x2(cos(a),sin(a),-sin(a),cos(a));\n    \n    float steps = 0.;\n    \n    float l = RayMarch(ro , rd ,100,steps);\n\n    vec3 rp = ro + rd * l;\n    \n    float fog = l/100.;\n    \n    vec3 col = vec3(0.8,0.2,0.)+vec3(1,1,0)*vec3(steps);\n    \n    col = mix(col , mix(vec3(0.8,0.5,0.2),vec3(0.2,0.2,1.),clamp(rp.y*0.01,0.,1.)), clamp(fog,0.,1.));\n\t\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}