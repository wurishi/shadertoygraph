{"ver":"0.1","info":{"id":"lfcSRf","date":"1717510563","viewed":157,"name":"Coin Spin","username":"spalmer","description":"spinning coin physics\n\nnot-so-fancy hack-graffix at least looks metallic\n\nEnjoy!  :D","likes":33,"published":1,"flags":32,"usePreview":0,"tags":["collision","dynamics","physics","cylinder","rigidbody","friction","coin","coulomb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO the rendering needs a lot of work\n// TODO environment map? scene's kinda boring\n// TODO more lights, way better lighting, specular, shadows, AO\n// TODO improve material BSDF\n// TODO more 'coins'; eventually I'd like stacks, piles!\n// TODO golf more?  :D\n\nfloat dFloor(vec3 q)\n{\n    return q.y + .25*z; // HACK small offset to prevent visual material mismatch bugs\n}\n// local bounding cylinder. FIXME sharp corner, need box sdf\n// given local q\nfloat dCoin(vec3 q)\n{\n    return max(length(q.xz) - Z, abs(q.y) - z); // outer cylinder\n}\n// TODO more texture, some face on the coin (nyancat? :D )\n// TODO more details, embossed words\nfloat dCoinDetail(vec3 q)\n{\n    float d = dCoin(q);\n    if (d > .5 * Z) return d;\n    float bmp = .9 * z * texture(iChannel2, q.xz * .2).x; // bumpmap\n    vec2 sym = .5 + vec2(4,5); // currency = 4,5; cent = 2,5; dollar = 4,13; pound = 3,5; yen = 5,5; is there a euro?\n    bmp += .9 * z * (clamp(texture(iChannel1, clamp(q.xz * .6/Z * vec2(1, sign(q.y)), -.5, .5) / 20. + sym/16.).r  - .5, -.2, .2) + .2); // bump symbol\n    float cut = max(length(q.xz) - Z + .7 * z, max(.4 * z, bmp) - abs(q.y));\n    d = max(d, -cut); // cylinder cutout\n    float a = atan(q.x, q.z), dup = radians(1440.); // angular domain repetition around rim - TODO should calculate notches from notch size or vice versa\n    a = round(a * dup) / dup * -.5;\n    q.xz = qrot(vec4(vec3(0,sin(a),0), cos(a)), q.xyz).xz;\n    float notch = .4 * z - length(q.xz - vec2(0, Z + .5 * z));\n    d = max(d, min(length(q.xz) - (Z - .4 * z), -.4 * z + length(q.xz - vec2(0, Z - .6 * z)))); // rim notches - subtracted in reverse == \"added\"\n    return d;\n}\n\nfloat scene(vec3 q, Body b)\n{\n    vec3 bq = qrot(qrev(b.r), q - b.p);\n\n    return min(50. - length(q - b.p - vec3(0,-25,0)),\n             min(dFloor(q), \n                dCoinDetail(bq)\n                )); // sky dome, plane and coin\n}\n\n// http://shadertoy.com/view/NscXR4\nvec3 gscene(vec3 q, float h, Body b)\n{\n\tvec3 n, e;\n\tfor (float i = min(0., iTime) + 4.; i-- > 0.; ) {\n\t\te = mod(floor(.5 * (i + vec3(3, 0, i))), 2.) * 2. - 1.;\n\t\tn += scene(h * e + q, b) * e;\n\t}\n\treturn n;\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    Body b = Load(iChannel0, 0);\n    vec3 R = iResolution,\n        p = b.p,\n        w = vec3(0,.25,-2)*B + p,\n        d = normalize(vec3(2. * q - R.xy, R.y));\n    vec4 r = b.r;\n    float t = 0., x = 5., ns = 128.;\n    // raymarch\n    for ( ; x > 2e-3 && ns-- > 0.; t += x)\n        w += (x = scene(w, b)) * d;\n    vec3 c = vec3(1.);\n    vec3 hit = w;\n    bool hitfloor = w.y <= t * 2e-2,\n        hitcoin = !hitfloor && dot(w - p, w - p) < B * B * 1.05;\n    if (hitcoin) c *= vec3(.2), w = qrot(qrev(r), w - p) * 8.; //qrot(r, w - p) * 4.; //\n    else if (hitfloor) c *= vec3(.2,.1,.3);\n    float fg = 1. / (1. + .16 * t);\n    if (hitcoin || hitfloor) c *= 1. - pow(1. - abs(sin(9.*w.x) * sin(9.*w.z)), 8.)\n         * (hitcoin ? .25 : .5) * fg;\n    hit -= 1e-3 * d;\n    vec3 n = normalize(gscene(hit, .2*z, b));\n    // FIXME this kind of lighting doesn't work with this sky dome.\n    vec3 L = normalize(vec3(0,.7,-.7)), //vec3(0,1,0), //\n        H = normalize(L - d);\n    x = scene(hit, b);\n    float fl = .8 * z, ad = 2. * z, //.1 * Z, //\n        ao = (scene(hit + ad * n, b) - x) / ad, // ambient // TODO fake ao, need a normal direction sample\n        nl = dot(n, L), //(scene(hit + fl * L, b) - x) / fl, // diffuse\n        nh = hitcoin ? (scene(hit + fl * H, b) - x) / fl : 0.,  // fakie specular\n        sp = 4.; //16.; // specular power\n    ao = clamp(ao, .04, 1.); //ao *= ao; // so far ambient occlusion is not working very well\n    nl = clamp(nl, .01, 1.);\n    nh *= nl;\n    nl = mix(nl, 1., ao);\n    //nl = mix(1., nl, ao); // backwards looks like a reflection almost\n    nh = clamp(nh, .0, 1.);\n    c *= nl;\n    c += 8./3.14 * (sp + 2.) * pow(nh, sp) * vec3(1,.8,.3);\n    c = mix(vec3(.7,.85,1), c, fg);\n    o = vec4(sqrt(c), 1);\n    //o += exp2(-8.) * (texelFetch(iChannel3, ivec2(q) & 7, 0).x - .5); // dither, bayer\n}\n\n\n// someone beat me to it, as usual!  in 2019!\n// heads or tails by flockaroo http://shadertoy.com/view/WtfSR2\n// doesn't exhibit quite the variety of behaviors.\n// and at 18110 total ch, mine's quite a bit shorter at 5317 or so..\n// perhaps will be easier for folks to understand.\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float\n    M = 10., // coin mass\n    kR = .25, // restitution/elasticity\n    kF = 2e1, // friction\n    lindamp = .1, // linear dampening\n    angdamp = .75; // angular dampening\n\n// see http://en.wikipedia.org/wiki/List_of_moments_of_inertia\n// cylinder solid = m ((3r² + 4h²) / 12, (3r² + 4h²) / 12, r² / 2) given half-height, z-aligned\nconst mat3\n    mom = M / 2. * mat3(\n            vec3((3. * Z*Z + 4. * z*z) / 6., 0, 0),\n            vec3(0, Z*Z, 0),\n            vec3(0, 0, (3. * Z*Z + 4. * z*z) / 6.)\n        ); // body-local inverse moment of inertia tensor (times radius?) of y-aligned cylinder\nconst mat3\n    imom = inverse(mom); // I had problems with constness of inverse intrinsic in Vulkan\n\nmat3 imomw(Body b)\n{\n\tmat3 m = quatToMatrix(b.r); \n    // aha.  thanks genus sole @glk7 !!! see http://shadertoy.com/view/wtfXD4\n    return m * imom * transpose(m);\n}\n\n\n// given local q\n/* // only gives just the rim, presently\nvec3 support(vec3 q)\n{\n\treturn vec3(Z,z,Z) * vec3(normalize(q.xz), sign(q.y)).xzy;\n}\n*/ // snap produces bit more stable collision contact points\nvec3 snap(vec3 q)\n{\n\tvec2 x = vec2(length(q.xz), abs(q.y)); // TODO squared\n    float zox = Z/x.x;\n\treturn max(x.x - Z, x.y - z) > 0. ? vec3(q.x * zox, sign(q.y) * z, q.z * zox) : \n        x.x - Z < x.y - z ? vec3(q.x, sign(q.y) * z, q.z) : vec3(q.x * zox, q.y, q.z * zox); \n}\n\nvec3 velAt(Body b, vec3 at)\n{\n\treturn b.v + cross(b.s, at);\n}\n\nvoid addImpulse(inout Body b, vec3 at, vec3 impulse)\n{\n\tb.v += 1./M * impulse;\n\tb.s += imomw(b) * cross(at, impulse);\n}\n\nvec3 computeNormalImpulse(Body b, float K, vec3 at, vec3 n, out float jr)\n{\n\tmat3 imw = imomw(b);\n\tvec3 v0 = velAt(b, at),\n\t\trv = v0;\n\tfloat nrv = dot(n, rv);\n\tif (nrv >= 0.)\n\t\treturn vec3(0);\n\tvec3\n\t\tw1 = cross(at, n),\n\t\tw3 = cross(imw * w1, at); //imw * cross(w1, at); //\n\tjr = -K * nrv / (1./M + dot(n, w3)); // scaled by mass\n\treturn jr * n;\n}\n\n// from iapafoto http://shadertoy.com/view/slXGRH; I've removed static friction just to simplify it\nvec3 getCoulombFriction(Body b, vec3 vr, vec3 n, float jr, float df) \n{\n\tvec3 t = vec3(0);\n\tfloat f = 0.;\n\tif (dot(vr, vr) > 1e-7) {\n\t\tvec3 pv = vr - dot(vr, n) * n; // reject\n\t\tf = dot(pv, pv);\n\t\tif (f > 1e-7) {\n\t\t\tt = pv / (f = sqrt(f)); // decompose into direction (t) and magnitude (f)\n            float //jf = -df * abs(jr), // their friction is proportional to the normal response somehow; I can almost see that if it were force, but even zero relative normal *velocity* should allow full friction, right?\n                jf = -(1. - exp2(-df)) * f; // HACKS\n            return jf * t;\n\t\t}\n\t}\n\treturn vec3(0);\n}\n\n// HACK dt has been factored into kF\nvec3 computeTangentialImpulse(Body b, float kF, float jr, vec3 at, vec3 n) // jr is the mass transfer for at and n\n{\n\tvec3 v0 = velAt(b, at),\n\t\trv = v0;\n\treturn getCoulombFriction(b, rv, n, jr, kF);\n}\n\nvec3 computeImpulses(inout Body b, float kE, float kF, vec3 at, vec3 n, float dt)\n{\n\tvec3 tot = vec3(0);\n\tfloat jr = 0.;\n\ttot += computeNormalImpulse(b, kE, at, n, jr);\n\tif (dot(tot, tot) > 1e-7)\n\t\ttot += computeTangentialImpulse(b, dt * kF, jr, at, n);\n\treturn tot;\n}\n\n// d = dot(n, pointonplane)\nvoid collidePlane(inout Body b0, vec3 n, float d, float dt)\n{\n\tvec4 oq = b0.r;\n\t// need gradient of shape to snap a point to its surface\n    vec3 lq = qrot(qrev(oq), -2. * B * n);\n    vec3 lsup = snap(lq); //support(lq); //\n\tvec3 sup = qrot(oq, lsup);\n\tfloat pen = -dot(sup, n) - d;\n\tif (pen < 0.) \n\t\treturn;\n\tvec3 r0 = sup;\n\tvec3 l = computeImpulses(b0, 1. + kR, kF, r0, n, dt);\n\tif (dot(l, l) > 1e-7)\n\t\taddImpulse(b0, r0, l);\n\tb0.p += pen * n;\n}\n\nvoid rotateOrientation(inout vec4 o, vec3 r) // o = orientation unit quaternion, r = dt * angularvelocity\n{\n\tvec4 qr = qexp(vec4(r, 0)); // convert spin to quaternion rotation\n\to = qmul(qr, o);\n\to = qrenormalize(o); // optional postconditioning brings closer to unit length; one rotation should never make much deviation anyway\n\t//o = normalize(o); // to absolutely ensure unit length, sanity check\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    ivec2 i = ivec2(q - .4);\n    if (i.y != 0 || i.x > 3) discard;\n    //i.x &= 3;\n    Body body = Load(iChannel0, 0);\n    vec3 \n        a = vec3(0,-5.,0), // gravity accel\n        d = fract(iDate.xzy + iDate.w * vec3(.1,.3,.5)) - .5;\n    float t = clamp(iTimeDelta, 1./144., 1./30.);\n    //t *= .5; // HACK slomo\n\tbody.v *= exp2(-lindamp * t); // linear damping\n\tbody.s *= exp2(-angdamp * t); // angular damping\n\n    // integrate physics\n    body.v += t * a;\n    body.p += t * body.v;\n    //body.s += t * w; // no torques yet\n    rotateOrientation(body.r, t * body.s);\n    \n    collidePlane(body, vec3(0,1,0), body.p.y, t);\n    bool stopped = dot(body.s.xyz, body.s.xyz) + 12. * dot(body.v, body.v) < .1; //(iMouse == vec4(0) ? 1. : .1);\n    if (iMouse == vec4(0) && (iFrame & 2047) == 0) stopped = true; // reset occasionally in previews since 'at rest' detection isn't working for some reason\n    if (iFrame == 0 || stopped) {\n        //float tilt = radians(.5*70.);\n        body.s = 60. * d + vec3(20,5,0), //vec3(10,0,0), //vec3(49,29,0), // *local*?!\n        body.p = vec3(0, Z + .2, 3), \n        body.r = sqrt(.5) * vec4(vec3(0,0,1),1), //vec4(vec3(0,0,cos(tilt)), sin(tilt)), //\n        body.v = 0. * d.yxz + 1. * vec3(0,1.5,0);\n    }\n    Save(o, i, 0, body);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define A(ch, i, j) texelFetch(ch, ivec2(i,j), 0)\n\nconst float \n    z = .04, // coin thickness\n    Z = .75, // coin radius\n    B = length(vec2(z,Z)); // bounding sphere radius\n\nvec4 qrev(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n// most quaternion stuff originates from http://shadertoy.com/view/fsGSDw\nvec4 qmul(vec4 a, vec4 b)\n{\n\tvec3 va = a.xyz, vb = b.xyz;\n\treturn vec4(a.w * vb + cross(va, vb) + b.w * va, a.w * b.w - dot(va, vb));\n}\n\n// one Newton-Raphson iteration approximating inversesqrt(), one place it's mentioned online is http://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton's_method\nvec4 qrenormalize(vec4 q)\n{\n\tfloat l = dot(q, q);\n\t//if (l == 1.) return q; // branch probably costs more than these few ops\n\tfloat f = .5 * (3. - l);\n\treturn f * q; //quat(f * q.xyz, f * q.w); //\n}\n\nvec3 qrot(vec4 q, vec3 r)\n{\n\tvec3 ax = q.xyz;\n    float w = q.w;\n    return r + 2. * cross(ax, cross(ax, r) + w * r); // thanks genis sole @glk7 http://shadertoy.com/view/wtfXD4\n}\n    //return r + 2. * cross(cross(r, -ax) + w * r, -axis);\n\t//return 2. * ((cross(ax, r) + r * w) * w + ax * dot(axis, r)) - r; // my (more awkward way, apparently)\n\nvec4 qlog(vec4 q)\n{\n\tvec3 v = q.xyz;\n\tfloat l = length(v), s = 2. * atan(l / q.w) / l;\n\treturn vec4(v * s, l);\n}\n\nvec4 qexp(vec4 v)\n{\n\tvec3 v3 = v.xyz;\n\tfloat a = dot(v3, v3);\n\tif (a < 1e-7) return vec4(vec3(0),1); // qidentity\n\ta = .5 * sqrt(a);\n\treturn vec4(v3 * (sin(a) * .5 / a), cos(a));\n}\n\nmat3 quatToMatrix(vec4 q)\n{\n\treturn mat3(\n\t\tqrot(q, vec3(1,0,0)),\n\t\tqrot(q, vec3(0,1,0)),\n\t\tqrot(q, vec3(0,0,1))\n\t\t);\n}\n\nstruct Body\n{\n\tvec4 r; // angular orientation unit quaternion \"rot\" such that qrot(r, x) represents a local-to-world transform of point x\n\tvec3 p, // linear position of CoM \"pos\"\n\t\t v, // linear velocity \"vel\"\n\t\t s; // angular velocity \"spin\"\n}; // all quantities in world space except imom\n\nBody Load(sampler2D ch, int i)\n{\n\tBody b;\n\tb.p = A(ch, 0, i).xyz;\n\tb.v = A(ch, 1, i).xyz;\n\tb.r = A(ch, 2, i).xyzw; //b.r = qexp(vec4(A(ch, 2, i).xyz,0)); // there's other ways one could pack this unit quaternion\n\tb.s = A(ch, 3, i).xyz;\n\treturn b;\n}\n// only used by Buffer A\nvoid Save(inout vec4 o, ivec2 x, int i, Body b)\n{\n    if (x.y != i) return;\n    switch (x.x) {\n        case 0: o = vec4(b.p, 0); break;\n        case 1: o = vec4(b.v, 0); break;\n        case 2: o = vec4(b.r   ); break; //o = vec4(qlog(b.r).xyz, 0); break;\n        case 3: o = vec4(b.s, 0); break;\n    }\n}\n","name":"Common","description":"","type":"common"}]}