{"ver":"0.1","info":{"id":"4dGfWc","date":"1588528022","viewed":139,"name":"random art - data stream","username":"Azorlogh","description":"tried recreating this image I made a while back : https://www.deviantart.com/spavec/art/Data-Stream-599482216\ndidn't work out very well\n\nwarning: this is an old botched up mess","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323846;\n\nvec3 rotateXY(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\tc, s, 0,\n\t\t-s, c, 0,\n\t\t0, 0, 1\n\t)*v;\n}\nvec3 rotateXZ(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\tc, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c\n\t)*v;\n}\nvec3 rotateYZ(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\t1, 0, 0,\n\t\t0, c, s,\n\t\t0, -s, c\n\t)*v;\n}\n\n// Operations\nfloat opU(float a, float b) { return min(a,b); }\nfloat opI(float a, float b) { return max(a,b); }\nfloat opD(float a, float b) { return max(a, -b); }\n\n// Transformations\nvec3 deform( vec3 p )\n{\n    p.xyz += .300*sin(  2.0*p.zxy );\n    p.xyz += 0.450*sin(  4.0*p.zxy );\n    p.xyz += 0.250*sin(  8.0*p.zxy );\n    return p;\n}\n\n// Distance functions\nfloat sphereSDF(vec3 p, float r) { return length(p)-r; }\nfloat boxSDF( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat planeSDF( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\nfloat torusSDF( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\n\n#define WALL_DIST 10.\n\nfloat wallsSDF(vec3 p) {\n    return opU(\n        planeSDF(p, normalize(vec4(1,0,0,WALL_DIST))),\n        planeSDF(p, normalize(vec4(-1,0,0,WALL_DIST)))\n\t);\n}\n\n#define SQR_SIDE 1.\n\nfloat squaresSDF(vec3 p) {\n    ivec2 ip = ivec2(mod(floor(p.yz/SQR_SIDE), vec2(256)));\n    p.yz = mod(p.yz, vec2(SQR_SIDE));\n    float h1 = texelFetch(iChannel0, ip, 0).r;\n    return opU(\n        boxSDF(p-SQR_SIDE*vec3(0,.5,.5)+vec3(WALL_DIST,0,0), vec3(h1,SQR_SIDE*.48,SQR_SIDE*.48)),\n        boxSDF(p-SQR_SIDE*vec3(0,.5,.5)+vec3(-WALL_DIST,0,0), vec3(h1,SQR_SIDE*.48,SQR_SIDE*.48))\n    );\n}\n\nfloat pillarsSDF(vec3 p) {\n    ivec2 ip = ivec2(mod(floor(p.yz/16.), vec2(256)));\n    p.yz = mod(p.yz, vec2(16));\n    vec2 shift = texelFetch(iChannel0, ip, 0).rg*8.;\n    return boxSDF(p-8.*vec3(0,.5,.5)+vec3(0,shift), vec3(WALL_DIST, SQR_SIDE*.5, SQR_SIDE*.5));\n}\n\n// Scene\nfloat sceneSDF(vec3 p) {\n    return opU(\n        opU(\n        \twallsSDF(p),\n        \tsquaresSDF(p)\n        ),\n        pillarsSDF(p)\n    );\n}\n\n\n\n/////////////////////////////////////////////////\n\n// Marching\n\n#define EPSILON 10e-5\n#define MAX_STEPS 512\n#define tmin 0.\n#define tmax 1e3\n\nvec3 getNormal( in vec3 pos ) {\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy) + \n        e.yyx * sceneSDF(pos + e.yyx) + \n        e.yxy * sceneSDF(pos + e.yxy) + \n        e.xxx * sceneSDF(pos + e.xxx));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float lightDist) {\n    float t = EPSILON;\n    float penumbra = 1e8;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = sceneSDF(ro+rd*t);\n        if (dist < EPSILON) {\n            return 0.;\n        }\n        penumbra = min(penumbra, 64.*dist/t);\n        t += dist;\n        if (t > lightDist) {\n            return smoothstep(penumbra, 0., .1);\n        }\n    }\n    return 0.;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t = tmin;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = sceneSDF(ro+rd*t);\n        if (dist < EPSILON*min(t,20.)) {\n            return t;\n        }\n        if (t > tmax) {\n            return -1.;\n        }\n        t += dist * ( .6 + (.01*t) );\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.3;\n    \n    vec3 lightPos = vec3(0, 0, -mod(iTime,4.)*400.+200.);\n    vec3 lightDir = normalize(vec3(0,.4,.5));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = (fragCoord - iResolution.xy/2.) / (iResolution.y/2.);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 ro = vec3(0,-.4,100.);\n    vec3 rd = normalize(vec3(pos*.6, -1));\n    rd = rotateXY(rd, .4);\n    \n    \n    vec3 col = vec3(0);\n    \n    float t = march(ro, rd);\n    if (t != -1.) {\n        vec3 p = ro+rd*t;\n        vec3 n = getNormal(p);\n        \n        vec3 sro = p+lightDir*10.;\n        vec3 srd = -normalize(lightDir);\n        float penumbra = shadow(sro, srd, 8.);\n        \n        vec3 toLight = lightPos-p;\n        toLight.y = 0.;\n        \n        float diff = max(dot(n, normalize(toLight)), 0.) / abs(toLight.z) * 10.;\n        col += vec3(diff) * 10.;\n        col += sqrt(t*.01) * vec3(.0,.4,.1)*.3;\n    } else {\n   \t\tcol = vec3(1,1,1);\n    }\n\n    fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define  HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    time = mod(time, 4.0);\n    \n    float outcoming = exp(-mod(time,4.));\n    \n    float incoming = exp(mod(time,4.)-4.);\n    \n    vec2 noise = hash22(vec2(time, time+500.));\n    \n    return vec2( (sin(time*501.)+step(.985, noise))*pow(max(outcoming, incoming), 2.) )*0.2;\n}","name":"Sound","description":"","type":"sound"}]}