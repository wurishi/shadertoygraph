{"ver":"0.1","info":{"id":"ltjczc","date":"1509983311","viewed":129,"name":"MCMC: naive uniform","username":"tale3d","description":"Image morphing with Markov Chain Monte Carlo. \nPart 1: \"naive\" solution with uniform sampling","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["stochastic","mcmc","teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//everything happens in Buffer A, here we just render a texture that is created in there\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define HASHSCALE1 443.8975\n\n//for testing purposes only: change that to something between 0 and 1 to control the speed of convergence\n//note that the quality decreases as we decrease the speed\n#define SPEED 1.0\n\n//pseudo-random number generator, taken from https://www.shadertoy.com/view/4djSRW \nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//target function/distribution that we are sampling from.\n//here we use a very simple one: difference between the colour in the target texture and the current colour\nfloat target(vec3 rgb, vec2 uv)\n{\n    //reading from the target texture\n    vec4 targetcolor = texture(iChannel2, uv);\n    \n    return 1.0/(dot(targetcolor.xyz-rgb,targetcolor.xyz-rgb) + 0.01); \n    //commenting the line above and de-commenting everything below in the function\n    //does comparison in black and white intensities instead \n    \n//    float x = rgb.x*0.3 + rgb.y*0.59 + rgb.z*0.11;\n//    float targetintensity = targetcolor.x*0.3 + targetcolor.y*0.59 + targetcolor.z*0.11;\n//    return 1.0/((x-targetintensity)*(x-targetintensity)+0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n \n    //reading current colour from the texture\n    float currentintensity = color.x*0.3 + color.y*0.59 + color.z*0.11;\n    \n    //create random point we walking to\n    float newR = hash11(fragCoord.x+iTime*fragCoord.y);\n    float newG = hash11(newR);\n    float newB = hash11(newG);\n    \n    //get function value for the existing colour\n    float sourceVal = target(color.xyz, uv);\n    //get function value for the proposed colour\n    float targetVal = target(vec3(newR, newG, newB), uv);\n    \n    float factor = 0.0;\n    \n    //if the function for the proposed is greater than for the current, move there\n    if (targetVal > sourceVal)\n        factor = SPEED;\n    \n    fragColor = mix(color,vec4(newR,newG,newB,1.),factor);\n\n    //for the first second, display (and store to channel0) texture from channel 1\n    if (iTime < 1.0) \n        fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"}]}