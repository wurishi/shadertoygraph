{"ver":"0.1","info":{"id":"fstGRX","date":"1630351825","viewed":182,"name":"Crystal Ritual","username":"Hyeve","description":"Originally made as a audio-responsive shader in Bonzomatic, this is a none-audio-responsive shadertoy port. Easily my best shader so far, I'm really happy with how this one turned out.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat t; //time\nvec3 glw = vec3(0); //glow\n\nfloat bx(vec3 p, vec3 s) //box sdf\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)), 0.) + length(max(q,0.));\n}\n\nfloat cy(vec3 p, float r) //cylinder sdf\n{\n  return length(p.xz)-r;\n}\n\n\nvec2 mp(vec3 p) //map/scene\n{\n  vec3 pp = p; //temp position\n\n  //audio based modifier - just replaced with a sine here\n  float fb = sin(t)*0.5+0.5;//texture(texFFTSmoothed,0.1).x * 300. + texture(texFFTSmoothed,0.99).x * 300.;\n  float tt = t + fb*0.6; //audio adjusted time\n  float g = length(pp) - fb*2.; //centre glow calculation\n  glw +=0.01/(0.01+g*g)*vec3(0.4,0.1,0.9); //add glow\n  \n  for(float i=0.;i<4.;i++) //kifs loop for centre\n  {\n     pp.xy=abs(pp.xy)-1.2 - fb*0.5;\n     pp.xy *= rot(tt + i);\n     pp.yz *= rot(i);\n     pp.z += fb;\n\n  }\n  vec2 b = vec2(bx(pp, vec3(1.)) - 0.1, 1.); //create centre crystal\n  pp=p; //reset temp position\n  \n  pp.xz *= rot(t/10.); //rotate around y\n  pp.xz=abs(pp.xz)-9.; //domain repeat to create 4 pillars\n \n  vec2 c = vec2(cy(pp,1.),2.); //outer cylinders\n  pp.y*=sin(t/3.); //hacky way to get the colours to shift by shifting the y\n  g = length(pp.xz) * 0.85; //slight glow on pillars\n  glw += 0.01/(0.01+g*g)*mix(vec3(0.1,0.0,0.9), vec3(0.9,0.0,0.1), (pp.y+10.)/20.); //add glow with y based colour\n  c.x = min(c.x, -abs(p.y) + 15.); //floor plane, domain repeated to create ceiling too\n  \n  return b.x < c.x ? b : c;\n} \n\n\nvec2 tr(vec3 ro,vec3 rd,float x) //raymarcher\n{\n  vec2 d = vec2(0);\n  for(int i = 0; i < 256; i++)\n  {\n    vec3 p=ro+rd*d.x;\n    vec2 s=mp(p);s.x*=x;\n    d.x+=s.x;d.y=s.y;\n    if(d.x>64.||s.x<0.001)break;\n  }\n  if(d.x>64.)d.y=0.;return d;\n}\n\nvec3 nm(vec3 p) //normal calc\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 n) //hit \"shader\" - calculates the colour from position + object + ray + normal data\n{\n  vec4 b=vec4(0,0,0,1); //background\n  if(h.a==0.)return vec4(b.rgb,1.); //return background for object id 0\n  vec4 a=h.a == 1. ? vec4(cos(t)*0.5+0.5,0.1,0.3, 0.2) : vec4(0.,0.,0.,0.8); //base colour\n  float d=dot(n,-rd); //unclamped diffuse\n  float dd=max(d,0.); //diffuse proper\n  float f=pow(1.-d,4.); //easy fres by using inverse of unclamped diffuse\n  float s=pow(abs(dot(reflect(rd,n),-rd)),40.); //specular\n  return vec4(a.rgb*(dd+f)+s,a.a); //mix together\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  t=iTime; //assign time global\n  vec2 uv = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y); //uv\n  uv-=0.5;uv/=vec2(iResolution.y/iResolution.x,1); //uv normalise\n  vec3 ro = vec3(0, 0, -30),rd=normalize(vec3(uv + vec2(0, 0),1.)), //ray origin and direction\n  oro=ro,ord=rd,cn,cp,cc;float ts=1.; //lots of variables to track transparency loop\n  for(int i=0;i<4;i++) //transparency loop\n  {\n    vec2 f=tr(oro,ord,1.); //march to front object\n    cp=oro+ord*f.x;cn=nm(cp); //update current position and normal\n    vec4 c=px(vec4(cp,f.y),ord,cn); //colour for front object\n    if(f.y==0.||c.a==1.){cc=mix(cc,c.rgb,ts);break;}; //mix colour and break if object is solid or there was no object\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./1.3); //refract and update ray\n    vec2 z=tr(ro,rd,-1.); //march through object\n    cp=ro+rd*z.x;cn=nm(cp); //update current position and normal\n    oro=cp+cn*0.01;ord=refract(rd,-cn,1.3); //refract and update the original ray variables\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn); //reflect if refraction failed\n    cc=mix(cc,c.rgb,ts);ts-=c.a; //mix colour\n    if(ts<=0.)break; //break if we reached 0 transmission\n  }\n  fragColor=vec4(cc + glw,1); //write output\n}","name":"Image","description":"","type":"image"}]}