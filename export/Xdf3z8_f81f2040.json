{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Tron light cycle - work in progress!\n// @simesgreen\n// \n// based on Carl Hoff's POVray model:\n// http://www.wwwmwww.com/Matt/cyclev4z.pov\n// http://www.tron-sector.com/forums/default.aspx?a=top&id=336281&pg=4\n\nconst float eps = 0.01;\n\n\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat _union(float a, float b, inout float m, float nm)\n{\n    m = (b < a) ? nm : m;\n    return min(a, b);\t\t\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat plane(vec3 p, vec3 n, vec3 pointOnPlane)\n{\t\n  return dot(p, n) - dot(pointOnPlane, n);\n}\n\n// plane in z defined by 2d edge\nfloat edge(vec3 p, vec2 a, vec2 b)\n{\n   vec2 e = b - a;\n   vec3 n = normalize(vec3(e.y, -e.x, 0.0));\n   return plane(p, n, vec3(a, 0.0));\n   //return intersect( plane(p, n, vec3(a, 0.0)), plane(p, -n, vec3(a, 0.0))-0.1);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = max(di.x, max(di.y, di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 bmin, vec3 bmax)\n{\n   vec3 c = (bmin + bmax)*0.5;\n   vec3 size = (bmax - bmin)*0.5;\n   return sdBox(p - c, size);\n}\n\n// http://www.povray.org/documentation/view/3.6.0/278/\nfloat cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    // project c onto ab, computing parameterized position d(t) = a + t(b-a)\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec3 c = a + t*ab;\n\t\t\n    float d = length(c - p) - r;\n    \n    vec3 n = normalize(ab);\n    d = intersect(d, plane(p, n, b));\n    d = intersect(d, plane(p, -n, a));\n    return d;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat torus(vec3 p, float r, float r2)\n{\n  return sdTorus(p, vec2(r, r2));\t\n}\n\n// http://www.povray.org/documentation/view/3.6.1/277/\nfloat cone(vec3 p, vec3 a, float baseR, vec3 b, float capR)\n{\n    vec3 ab = b - a;\n    // project c onto ab, computing parameterized position d(t) = a + t(b-a)\n    float t = dot(p - a, ab) / dot(ab, ab);\n    //t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\t// point on axis\n\n    float r = mix(baseR, capR, t);\n    float d = length(c - p) - r;\n    d *= 0.25;\n    vec3 n = normalize(ab);\n    d = intersect(d, plane(p, n, b));\n    d = intersect(d, plane(p, -n, a));\n    return d;\n}\n\n\n// Light cycle model\n\nfloat front_tire(vec3 p, float t)\n{\n\tfloat d;\n\td = sphere(p - vec3(355,85,0), 85.0);\n\tif (t > 1.0) {\n\t\td = difference(d, sphere(p - vec3(355,85,69.4092), 56.6367));\n\t\td = difference(d, sphere(p - vec3(355,85,-69.4092), 56.6367));\n\t}\n\treturn d;\t\n/*    return difference( difference(\n            sphere(p - vec3(355,85,0), 85.0),\n            sphere(p - vec3(355,85,69.4092), 56.6367) ),\n            sphere(p - vec3(355,85,-69.4092), 56.6367) );\n*/\n}\n\nfloat front_axle(vec3 p)\n{\n    return _union(\n        sphere(p - vec3(355,85,-26), 17.0),\n        sphere(p - vec3(355,85,26), 17.0));\n}\n\nfloat front_hub(vec3 p)\n{\n    return difference( \n        box(p, vec3(304.803,34.803,-43.1795), vec3(405.197,135.197,43.1795)),\n        _union( sphere(p - vec3(355,85,69.4092), 56.636),\n                sphere(p - vec3(355,85,-69.4092), 56.636)));\n}\n\nfloat rear_tire(vec3 p, float t)\n{\n\tfloat d = 1e10;\n\tif (t > 4.0) d = sphere((p - vec3(0,85,0)) * vec3(1,1,5), 85.0) * 0.2;\n\tif (t > 5.0) {\n\t\td = difference(d, sphere(p - vec3(0,85,20.8732), 58.7155));\n\t\td = difference(d, sphere(p - vec3(0,85,-20.8732), 58.7155));\n\t}\n\treturn d;\n\t/*\n    return difference( difference(\n        sphere((p - vec3(0,85,0)) * vec3(1,1,5), 85.0) * 0.2,\n        sphere(p - vec3(0,85,20.8732), 58.7155) ),\n        sphere(p - vec3(0,85,-20.8732), 58.7155) );\n\t*/\n}\n\nfloat rear_axle(vec3 p)\n{\n    return sphere(p - vec3(0,85,0), 17.0);\n}\n\nfloat rear_hub(vec3 p)\n{\n    //return box(p, vec3(-55.251,29.749,-1), vec3(55.251,140.251,1));\n    return cylinder(p, vec3(0,85,-1.0), vec3(0,85,1), 60.0);\n}\n\t       \nfloat upper_body(vec3 p, float t)\n{\n    float d = 1e10;\n    d = cylinder(p, vec3(192.447,-160,17.5), vec3(192.447,-160.0,-17.5), 389.721);\n    d = _union(d, cone(p, vec3(192.447,-160,-17.5), 389.721, vec3(192.447,-160,-22.5), 373.721) );\n    d = _union(d, cone(p, vec3(192.447,-160,17.5), 389.721, vec3(192.447,-160,22.5), 373.721) );\n\n\tif (t > 9.0) {\n    d = intersect(d, edge(p, vec2(434.548,145.401), vec2(434.548,229.721) ));\n    d = intersect(d, edge(p, vec2(35.372,145.401), vec2(434.548,145.401) ));\n    //d = intersect(d, edge(p, vec2(35.372,60), vec2(434.548,20) ));\n\t\n    //d = intersect(d, edge(p, vec2(6.02735,162.344), vec2(35.372,145.401) ));\n    d = intersect(d, edge(p, vec2(6.02735,229.721), vec2(6.02735,162.344) ));\t\n\t\n    //d = torus(p.xzy - vec3(192.447,-160, 26.5).xzy, 367.221, 11.5);\n    //d = torus(p.xzy - vec3(192.447,-160, -26.5).xzy, 367.221, 11.5);\n\t}\n    return d;\n}\n\nfloat lower_body(vec3 p)\n{\n    float d;\n    d = box(p, vec3(0,38.5,-22.5), vec3(278.689,145.401,22.5));\n    //d = difference(d, cylinder(p, vec3(192.447,-160,26.5), vec3(192.447,-160,-26.5), 373.721));\n    d = difference(d, cylinder(p, vec3(0,85,26.501), vec3(0,85,-26.501), 28.5));\t// axle hole\t\n    return d;\n}\n\nfloat window(vec3 p, float t)\n{\n    float d = 1e10;\n    d = sphere((p - vec3(238.0,145.4,0.0))/vec3(1.83,0.75,1.0), 77.5)*0.5;\n\t\t\n\tif (t > 13.0) {\n    d = _union(d, cylinder(p, vec3(192.447,-160,17.5), vec3(192.447,-160.0,-17.5), 389.721+0.01));\n    d = _union(d, cone(p, vec3(192.447,-160,-17.5), 389.721+0.01, vec3(192.447,-160,-22.5), 373.721+0.01) );\n    d = _union(d, cone(p, vec3(192.447,-160,17.5), 389.721+0.01, vec3(192.447,-160,22.5), 373.721+0.01) );\n\t\t\t\t\n    d = intersect(d, edge(p, vec2(192.447,229.721), vec2(238,145.4)));\n    d = intersect(d, edge(p, vec2(335.203,145.4), vec2(381.405,180.848)));\n    //d = intersect(d, edge(p, vec2(381.405,229.721), vec2(192.447,229.721)));\n    d = intersect(d, edge(p, vec2(192.447,145.4), vec2(381.405,145.4) ));\t\n//\td = edge(p, vec2(381.405,145.4), vec2(192.447,145.4));\n\t}\n    return d;\t\n}\n\nfloat jetwall(vec3 p)\n{\n\tfloat d;\n\td = box(p, vec3(-5000.0,0,-1), vec3(0.0,230.0,1));\n    d = intersect(d, cylinder(p, vec3(-200,-160,1), vec3(-200,-160.0,-1), 389.721));\n\td = _union(d, box(p, vec3(-5000.0,0,-1), vec3(-200.0,230.0,1)));\n\treturn d;\n}\n\n// distance to scene\nfloat scene(vec3 p, out float m, float t)\n{\n#if 0\n    // duplicate\n    p += vec3(-4.0, 0.0, -4.0);\n    p.xz = mod(p.xz, 8.0);\n    p -= vec3(4.0, 0.0, 4.0);\n#endif\t\n\t\t\n    float d;\n    m = 3.0;\t// material\n\n    p += vec3(2.0, 1.0, 0.0);\n    p = p * 100.0;\n\n    d = sdPlane(p, vec4(0, 1, 0, 0)); \n\n    d = _union(d, front_tire(p,t), m, 0.0);\n    if (t > 2.0) d = _union(d, front_axle(p), m, 2.0);\n    if (t > 3.0) d = _union(d, front_hub(p), m, 1.0);\n\t\n    d = _union(d, rear_tire(p,t),m, 0.0);\n    if (t > 6.0) d = _union(d, rear_axle(p), m, 2.0);\n    if (t > 7.0) d = _union(d, rear_hub(p), m, 1.0);\n\t\n    if (t > 8.0) d = _union(d, upper_body(p,t), m, 0.0);\n    if (t > 10.0) d = _union(d, lower_body(p), m, 0.0);\t\n\t\n    if (t > 11.0) d = _union(d, cone(p, vec3(293.0,85.0,0.0), 60.0, vec3(219.0,85.0,0.0), 26.5), m, 2.0);\n\t\n    if (t > 12.0) d = _union(d, window(p,t), m, 1.0);\n\n\tif (t > 14.0) d = _union(d, jetwall(p), m, 4.0);\n\t\n\t\n    d /= 100.0;\n\n    return d;\n}\n\n// calculate scene normal\nvec3 sceneNormal(in vec3 pos, in float t )\n{\n    float eps = 0.0001;\n    vec3 n;\n    float m;\n    float d = scene(pos, m, t);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z), m, t ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z), m, t ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps), m, t ) - d;\n    return normalize(n);\n}\n\n// edge detection from Kali's:\n// https://www.shadertoy.com/view/4djGz1\n\nvec3 sceneNormalEdge(vec3 p, out float edge, float t)\n{ \n\tconst float det = 0.02;\n\tvec3 e = vec3(0.0,det,0.0);\n\n\tfloat m;\n\tfloat d1=scene(p-e.yxx, m, t),d2=scene(p+e.yxx, m, t);\n\tfloat d3=scene(p-e.xyx, m, t),d4=scene(p+e.xyx, m, t);\n\tfloat d5=scene(p-e.xxy, m, t),d6=scene(p+e.xxy, m, t);\n\tfloat d=scene(p, m, t);\n\t\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\t//edge=min(1.0, pow(edge, 0.5)*20.0);\n\tedge *= 100.0;\n\tedge = clamp(0.0, 1.0, edge);\n\treturn -normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n, float t)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d, m, t));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit, out float m, float t)\n{\n    const int maxSteps = 64;\n    const float hitThreshold = 0.001;\n    hit = false;\n    vec3 pos = ro;\n    vec3 hitPos = ro;\n\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tif (!hit) {\n\t\t\tfloat d = scene(pos, m, t);\n\t\t\tif (d < hitThreshold) {\n\t\t\t\thit = true;\n\t\t\t\thitPos = pos;\n\t\t\t\t//return pos;\n\t\t\t}\n\t\t\tpos += d*rd;\n\t\t}\n    }\n    return hitPos;\n}\n\nfloat smoothpulse(float a, float b, float w, float t)\n{\n\treturn smoothstep(a, a + w, t) - smoothstep(b - w, b, t);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos, float m, float edge, float t)\n{\n    //const vec3 lightPos = vec3(5.0, 10.0, 5.0);\n    //vec3 color = vec3(0.1, 0.3, 1.0);\t// blue\n\tvec3 color = vec3(1.0, 0.7, 0.1);\t// yellow\n\tconst float ka = 0.2;\n\tvec3 specColor = vec3(0.75);\n    const float shininess = 20.0;\n\n    if (m==1.0) {\n\t\tcolor = vec3(0.05);\t\t\n    } else if (m==2.0) {\n\t\tcolor = vec3(1.0);\n\t} else if (m==3.0) {\n\t\t// floor\n\t    color = vec3(0.08, 0.12, 0.23);\n\t\tspecColor = vec3(0.0);\n\t\tvec2 uv = pos.xz * 0.3;\n\t\tif (t > 14.0) uv.x += (t - 14.0)*10.0;\n\t\tvec2 g = fract(uv);\n\t\t//vec2 width = fwidth(uv); float w = max(width.x, width.y);\n\t\tconst float w = 0.02;\n\t\t//color = ((g.x < 0.04) || (g.y < 0.04)) ? vec3(1.0): color;\n\t\tfloat l = smoothpulse(0.0, 0.05, w, g.x) + smoothpulse(0.0, 0.05, w, g.y);\n\t\tcolor = mix(color, vec3(1.0), min(l, 1.0));\n\t\t//color = vec3(w);\n\t} else if (m==4.0) {\n\t\t// jet wall\n\t\tfloat x = -(pos.x+2.0)*0.3;\n\t\tx = floor(x*15.0)/15.0;\n\t\tcolor = mix(vec3(1.2), color, clamp(x, 0.0, 1.0));\n\t}\n\t\n    //vec3 l = normalize(lightPos - pos);\n\tconst vec3 l = vec3(0.577, 0.577, -0.577);\n\t//const vec3 l = vec3(0, 1, 0);\n    vec3 v = normalize(eyePos - pos);\n    vec3 h = normalize(v + l);\n    float diff = dot(n, l);\n    float spec = pow(max(0.0, dot(n, h)), shininess) * float(diff > 0.0);\n    diff = max(0.0, diff);\n    //diff = 0.5+0.5*diff;\n\n\tbool shadowHit;\n\tpos += n*eps;\n\tvec3 shadowPos = trace(pos, l, shadowHit, m, t);\n\tdiff *= shadowHit ? 0.25 : 1.0;\n\tspec *= shadowHit ? 0.0 : 1.0;\n\n\t// add edges:\n\t//color = mix(color, vec3(1.0), edge);\n\t\n    //float fresnel = pow(1.0 - dot(n, v), 5.0);\n    //float ao = ambientOcclusion(pos, n);\n\n    return (ka + diff)*color + spec*specColor;\n//    return vec3(diff*ao) * color + vec3(spec);\n//    return vec3(diff*ao) * color + vec3(spec);\n//    return vec3(ao);\n//    return vec3(fresnel);\n//    return n*0.5+0.5;\n//\treturn vec3(edge);\n}\n\nvec3 background(vec3 rd)\n{\n     //return mix(vec3(1.0), vec3(0.0), rd.y);\n     //return mix(vec3(1.0), vec3(0.0, 0.25, 1.0), rd.y);\n     //return vec3(0.5);\n\treturn vec3(0.0);\n}\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 78.233)) + iTime*0.2)* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.8;\n    \n    vec2 pixel = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat roty;\n\tfloat rotx;\n\tif (iMouse.z <= 0.0) {\n\t\trotx = -0.6;\n\t\troty = iTime;\n\t} else {\n\t    rotx = -(1.0-mouse.y)*3.0;\n\t\troty = -(mouse.x-0.5)*6.0;\n\t}\n\n    rd = rotateX(rd, rotx);\n    ro = rotateX(ro, rotx);\n\t\t\n    rd = rotateY(rd, roty);\n    ro = rotateY(ro, roty);\n\t\t\n    // trace ray\n    bool hit;\n    float m = 0.0;\n    vec3 pos = trace(ro, rd, hit, m, t);\n\n    vec3 rgb;\n    if(hit)\n    {\n        // calc normal\n        //vec3 n = sceneNormal(pos);\n\t\tfloat edge;\n\t\tvec3 n = sceneNormalEdge(pos, edge, t);\n        // shade\n        rgb = shade(pos, n, ro, m, edge, t);\n\n#if 0\n        // reflection\n        vec3 v = normalize(ro - pos);\n        float fresnel = 0.1 + 0.4*pow(max(0.0, 1.0 - dot(n, v)), 5.0);\n\n        ro = pos + n*eps; // offset to avoid self-intersection\n        rd = reflect(-v, n);\n        pos = trace(ro, rd, hit, m);\n\n        if (hit) {\n            vec3 n = sceneNormal(pos);\n            rgb += shade(pos, n, ro, m) * vec3(fresnel);\n        } else {\n            rgb += background(rd) * vec3(fresnel);\n        }\n#endif \n\n     } else {\n        rgb = background(rd);\n     }\n\n    // vignetting\n    //rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\n\t// film grain\n\t//float noise = rand(pixel);\n\t//noise = exp(-noise*noise);\n\t//noise = noise*0.2 + 0.8;\n\t//rgb *= noise;\n\t\n    fragColor=vec4(rgb, 1.0);\n\t//fragColor = vec4(vec3(noise), 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdf3z8","date":"1366714373","viewed":3086,"name":"LightCycle","username":"simesgreen","description":"Tron light cycle. Original by MAGI, made of 57 CSG primitives. This is a simplified version of Carl Hoff's POVray model, feel free to improve!\n\nhttp://www.wwwmwww.com/Matt/cyclev4z.pov\nhttp://en.wikipedia.org/wiki/Mathematical_Applications_Group,_Inc.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","tron","lightcycle"],"hasliked":0,"parentid":"","parentname":""}}