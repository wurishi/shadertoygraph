{"ver":"0.1","info":{"id":"llBXWh","date":"1443338777","viewed":468,"name":"Magical varnished spheres.","username":"mjolnir","description":"My first raymarching shader, wherein I wonder when we'll have lambertian irradiance cubemaps or the ability to just add our own (or process the existing ones with a prepass!).","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Some bits blatantly stolen from https://www.shadertoy.com/view/Xds3zN (thanks iq!)\n// i.e. normal, camera, and a much better way to raymarch than I had thought up\n\n// See TARGET below to change spheres\n\n#define TI iTime\n#define PI 3.1415926535897932384626433832795\n#define TWOPI (2.0*PI)\n#define PI_2 (PI/2.0)\n#define CAM_DIST 25.0\n\n#define MH\t\t\tTWOPI*(iMouse.x/iResolution.x*2.0-1.0)+TI/5.0\n#define MV \t\t\tsin(TWOPI*iMouse.y/iResolution.y)\n#define MVN         (1.0-abs(MV))\n#define ROLL\t\t0.0\n#define FOV\t\t\t20.0\n\n#define MAX_BOUNCES 4\n#define RAY_MARCHES 65\n#define MAX_DIST \t50.0\n#define PRECISION\t0.01\n#define EPSILON\t\t0.001\n\n// 'objects' (pardon the macro mess)\n#define OBJ_ORBIT(P,S,R) P+vec3(sin(S),cos(S),0)*R\n\n#define NEXT_O(R) (R*2.0)\n#define NEXT_R(R) (R/2.5)\n#define NEXT_S(S) (S*PI)\n\n#define OBJ0_R 4.0\n#define OBJ0_P vec3(0)\n#define OBJ0_S TI/10.0\n#define OBJ0 vec2(0, sdSphere(P, OBJ0_P, OBJ0_R))\n\n#define OBJ1_O NEXT_O(OBJ0_R)\n#define OBJ1_S NEXT_S(OBJ0_S)\n#define OBJ1_R NEXT_R(OBJ0_R)\n#define OBJ1_P OBJ_ORBIT(OBJ0_P, OBJ1_S, OBJ1_O)\n#define OBJ1 vec2(1, sdSphere(P, OBJ1_P, OBJ1_R))\n\n#define OBJ2_O NEXT_O(OBJ1_R)\n#define OBJ2_S NEXT_S(OBJ1_S)\n#define OBJ2_R NEXT_R(OBJ1_R)\n#define OBJ2_P OBJ_ORBIT(OBJ1_P, OBJ2_S, OBJ2_O)\n#define OBJ2 vec2(2, sdSphere(P, OBJ2_P, OBJ2_R))\n\n// Change this to any of: OBJ0_P, OBJ1_P, OBJ2_P\n#define TARGET\t\tOBJ1_P\n#define ORIGIN\t\tvec3(sin(MH)*MVN, MV, cos(MH)*MVN)*CAM_DIST+TARGET*vec3(1,-1,1)\n\n// lights\n#define LIGHT0_P vec3(70, 100, 0)\n#define LIGHT0_C vec3(1.0, 0.9, 0.8)\n\n#define LIGHT1_P vec3(-70, 100, 0)\n#define LIGHT1_C vec3(1.0, 0.9, 0.8)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define GAMMA 2.2\nvec3 gamma_cmp(vec3 x) \n{\n    return pow(x, vec3(GAMMA));\n}\nvec3 gamma_exp(vec3 x)\n{\n \treturn pow(x,vec3(1.0/GAMMA));\n}\n\nvec2 polar(vec3 norm)\n{\n\tvec2 res;\n    res.y = (norm.y+1.0)/2.0;\n    res.x = atan(norm.z, norm.x) / TWOPI;\n    return res.xy;\n}\n\nvec2 polarWrap(vec3 norm)\n{\n\tvec2 res = polar(norm);\n    res.x = abs(res.x-0.5)*2.0;\n    return res; \n}\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c)-r;\n}\n\nvec2 opU(in vec2 o1, in vec2 o2)\n{\n    return o1.y < o2.y ? o1 : o2;\n}\n\nvec2 map(vec3 P)\n{\n    vec2 res = vec2(-1);\n    \n    res = OBJ0;\n    res = opU(res, OBJ1);\n    res = opU(res, OBJ2);\n    \n    return res;\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 t = vec2(EPSILON, 0);\n    return normalize(vec3(\n        map(p+t.xyy).y-map(p-t.xyy).y,\n        map(p+t.yxy).y-map(p-t.yxy).y,\n        map(p+t.yyx).y-map(p-t.yyx).y));\n}\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1);\n    \n   \tfloat t = 1.0;\n    \n    for (int i = 0; i < RAY_MARCHES; ++i)\n    {\n        res = map(ro+rd*t);\n        if (res.y < PRECISION || t > MAX_DIST) break;\n        t += res.y;\n    }\n    \n    if (t > MAX_DIST)\n        t = -1.0;\n    \n    return vec2(res.x, t);\n}\n// These could do a different thing per object... idd.x\nvec3 matAlbedo(const vec2 idd, vec3 N, vec3 RD, vec3 P)\n{\n\treturn gamma_cmp(texture(iChannel1, polarWrap(N)).xyz);\n}\n\nfloat matReflectance(const vec2 idd)\n{\n    return 0.075;\n}\n\nfloat matRoughness(const vec2 idd)\n{\n    return 0.2;\n}\n\nvec3 env(vec3 rd)\n{\n    return gamma_cmp(texture(iChannel0, rd).xyz);\n}    \n\nstruct RayMaterial\n{\n    float t;\n    vec3 albedo;\n    vec3 P;\n    vec3 N;\n    vec3 R;\n    vec3 H;\n    vec3 V;\n    float rough;\n    float f0;\n    vec3 C;\n};\n\n// GGX code borrowed from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}   \n\nvec3 ggxLight(RayMaterial rm, vec3 lightPos, vec3 lightCol)\n{\n    vec3 col = vec3(0);\n    vec3 lightV = lightPos-rm.P;\n    float lightD = length(lightV);\n    vec3 L = lightV/lightD; \n\n    vec2 ray = castRay(rm.P, L);\n    if (ray.y < 0.0 || ray.y > lightD)\n    {\n        col += GGX(rm.N, rm.V, L, rm.rough, rm.f0) * lightCol;\n        col += max(0.0, dot(rm.N, L)) * rm.albedo * lightCol;\n    }\n    return col;\n    \n}\n    \nvec3 draw(RayMaterial rm, vec3 incoming)\n{\n    vec3 col = vec3(0);\n    vec3 fresnel = vec3(pow(1.0-max(dot(rm.V,rm.H),0.0),5.0) * (1.0-rm.f0)+rm.f0);\n    \n    col += fresnel * incoming;\n    \n    col += ggxLight(rm, LIGHT0_P, LIGHT0_C);\n    col += ggxLight(rm, LIGHT1_P, LIGHT1_C);\n        \n    return col;\n}\n    \nfloat castMaterialRay(vec3 ro, vec3 rd, out RayMaterial rm)\n{\n    vec2 res = castRay(ro, rd);\n    float t = res.y;\n    if (t > 0.0)\n    {\n        vec3 V = -rd;\n        vec3 P = ro+rd*t;\n        vec3 N = norm(P);\n        vec3 R = reflect(rd,N);\n        vec3 H = normalize(V + R);\n        \n        vec3 albedo = matAlbedo(res, N, rd, P);\n        float rough = matRoughness(res);\n        float f0 = matReflectance(res);\n                \n        rm = RayMaterial(t, albedo, P, N, R, H, V, rough, f0, vec3(0));\n    }\n    return t;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = (uv-vec2(0.5))*2.0;\n    q.x *= iResolution.x/iResolution.y;\n    \n    fragColor.xyzw = vec4(0,0,0,1);\n    \n    float qZ = 1.0/tan(radians(FOV/2.0));\n    \n    vec3 ro = ORIGIN;\n    vec3 rd = setCamera(ORIGIN, TARGET, ROLL) * normalize(vec3(q.xy, qZ));\n    \n    RayMaterial rm[MAX_BOUNCES];\n    \n    for (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        float t = castMaterialRay(ro, rd, rm[i]);\n        if (t >= 0.0)\n        {\n            ro = rm[i].P;\n            rd = rm[i].R;\n        }\n        else\n        {\n            rm[i].C = env(rd);\n            rm[i].t = -1.0;\n            break;\n        }\n    }\n    for (int i = MAX_BOUNCES-1; i >= 0; --i)\n    {\n        if (rm[i].t > 0.0)\n        {\n        \trm[i].C = draw(rm[i], rm[i+1].C);\n        }\n    }\n    \n    fragColor.xyz = rm[0].C;\n    \n    fragColor.xyz = gamma_exp(fragColor.xyz);\n}","name":"","description":"","type":"image"}]}