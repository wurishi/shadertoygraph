{"ver":"0.1","info":{"id":"NssSDf","date":"1619374203","viewed":220,"name":"SIGGRAPH Frontiers 2021 demo ","username":"Flopine","description":"A simple and quick shader made as a learning material for my talk at SIGGRAPH Frontiers 2021","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","comments","siggraph","lean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy and wwrighter for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define rotation(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n// cosine palette from iq\n// https://iquilezles.org/articles/palettes\nvec3 palette (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.36,0.64)));}\n\n// 2D mask returning 0 or 1 based on a threshold\n// on repeated UVs\nfloat mask (vec2 uv)\n{\n    // animate the UVs\n    uv += iTime*.5;\n    // draw a diagonal\n    float m = uv.x+uv.y;\n    // repeat it by taking the fractional part (= modulo by 1)\n    // and shift the position by half a period\n    // to put the shape in the center of the cell\n    m = fract(m)-.5;\n    // symmetrize the shape with absolute value\n    m = abs(m);\n    \n    // return the mask by making a threshold of the value m\n    return step(0.1, m);\n}\n\n// declare global variables for id of repetition\n// and glow accumulation\nfloat id, g1=0.;\n\n// Signed Distance Function\n// also called map() by many shadercoders\n// this is our scene, our 3d shapes\nfloat SDF (vec3 p)\n{\n    // store the original space\n    vec3 pp = p;\n    \n    // symmetrize in the y axis\n    p.y = abs(p.y)-10.;\n    \n    // declare a period for the repetition\n    float period = 4.;\n    // calculate the id of the cells\n    id = floor(p.x/period);\n    // repeat the space\n    p.x = mod(p.x,period)-period*0.5;\n    \n    // \"push\" the shapes in the x axis based on a sine wave along z axis\n    p.x += sin(p.z*id*0.2+iTime*2.)*0.5;\n    // \"push\" the shapes in the y axis based on a sine wave along z axis\n    p.y += cos(p.z*id*0.1+iTime*3.);\n    \n    // declare the shape, an infinite cylinder\n    float c1 = length(p.xy)-0.5;\n    \n    // retrieve original position to clea all space transformations\n    // made previously\n    p = pp;\n    // rotate the space in the z axis\n    p.xy *= rotation(iTime);       \n    \n    // symmetrize the space on the x and y axis\n    p.xy = abs(p.xy)-.8; \n    \n    // declare the shape, a sphere\n    float s = length(p)-0.5;\n    // accumulation for making the sphere glowing\n    g1 += 0.01/(0.01+s*s);\n    \n    // return all the shapes that compose our field\n    // min = union, max = intersection, max(-shape,othershape) = subtraction\n    return min(s,c1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 centered_uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // kaleidoscopic effect on UVs\n    //centered_uv = abs(centered_uv)-0.5;\n    \n    // fake diffraction by moving slightly the UVs\n    // based on the 2D mask\n    centered_uv += mask(centered_uv)*0.1;\n    \n    // declaring the camera\n    vec3 ro = vec3(0.,0.,-3.), \n    rd = normalize(vec3(centered_uv,1.)),\n    p = ro,\n    // declaring the color background\n    col = vec3(0.);\n    \n    bool hit = false;\n    \n    // will help us store the iterations \n    // for a supe chap and fake AO\n    float shad;\n    \n    // raymarching loop\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);       \n        if(d<0.01)  // if we're really close to the shape\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        // moving along the ray \n        // with the technique of sphere-tracing\n        p += d*rd*0.6;\n    }\n    \n    if (hit)\n    {\n        col = palette(id,vec3(0.1));\n        col *= 1.-shad;\n    }\n    \n    // adding the glow on spheres\n    col += g1*0.5;\n    \n    // Output to screen\n    // sqrt() make a approx. gamma correction\n    // the correct one is pow(col, vec3(1./2.2))\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}