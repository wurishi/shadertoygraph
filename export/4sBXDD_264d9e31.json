{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define saturate(i) ( clamp( i, 0.0, 1.0 ) )\n\nconst float pi = 3.14159265;\nconst float tau = pi * 2.0;\nconst float halfpi = pi * 0.5;\nconst float oneoverpi  = 1.0 / pi;\nconst float oneovertau = 1.0 / tau;\n\nconst float ZMAX = 99999.0;\nconst float EPSILON = 0.001;\n\nstruct Intersection\n{\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n    bool hit;\n    float luminance;\n    float emission;\n    float roughness;\n    vec2 uv;\n};\n\t\nstruct Light\n{\n    vec4 lightOrientation;\n    vec3 planarDirection;\n    vec3 planarRight;\n    vec3 planarUp;\n    vec3 lightExtents;\n    vec3 lightPosition;\n};\n    \nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\nstruct Plane\n{\n    vec2 extent;\n\tvec3 center;\n    \n    vec4 orient;\n    \n    float luminance;\n    float emission;\n    float roughness;\n};\n     \nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n    float emission;\n    float roughness;\n};\n    \n//\n    \nIntersection MinIntersection( Intersection a, Intersection b )\n{\n\tif( a.distance < b.distance )\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nIntersection RaySphere(Ray ray, Sphere sphere)\n{\n\tIntersection i;\n\ti.distance = ZMAX;\n\tvec3 c = sphere.c;\n\tfloat r = sphere.r;\n\tvec3 e = c-ray.origin;\n\tfloat a = dot(e, ray.direction);\n\tfloat b = r*r - dot(e,e) + a*a;\n\tif( b>0.0 )\n\t{\n\t\tfloat f = sqrt(b);\n\t\tfloat t = a - f;\n\t\tif(t > EPSILON)\n\t\t{\n\t\t\ti.position = ray.origin + ray.direction*t;\n\t\t\ti.normal = normalize(i.position-c);\n\t\t\ti.distance = t;\n            i.luminance = 1.0;\n            i.roughness = sphere.roughness;\n            i.emission = sphere.emission;\n            i.hit = true;\n            i.uv = i.normal.xy;\n\t\t}\n\t}\n\treturn i;\n}\n\n//\n\nstruct Spatial\n{\n\tvec4 pos, rot;\n};\n\n// Construct Quaternion from Euler Angles\nvec4 constructQuaternion( vec3 angles )\n{\t\n    vec3 halfAngles = 0.5 * angles;\n    \n    float cos_z_2 = cos( halfAngles.z );\n    float cos_y_2 = cos( halfAngles.y );\n    float cos_x_2 = cos( halfAngles.x );\n\n    float sin_z_2 = sin( halfAngles.z );\n    float sin_y_2 = sin( halfAngles.y );\n    float sin_x_2 = sin( halfAngles.x );\n\n    // and now compute quaternion\n    vec4 quat;\n    quat.w = cos_z_2*cos_y_2*cos_x_2 + sin_z_2*sin_y_2*sin_x_2;\n    quat.x = cos_z_2*cos_y_2*sin_x_2 - sin_z_2*sin_y_2*cos_x_2;\n    quat.y = cos_z_2*sin_y_2*cos_x_2 + sin_z_2*cos_y_2*sin_x_2;\n    quat.z = sin_z_2*cos_y_2*cos_x_2 - cos_z_2*sin_y_2*sin_x_2;\n    return quat;\n}\n\nvec3 quaternionMultiply( vec4 quat, vec3 vector )\n{\n\tvec3 uv, uuv;\n    vec3 qvec = quat.xyz;\n    \n    uv = cross( qvec, vector );\n    uuv = cross( qvec, uv );\n    \n\tuv  *= ( 2.0 * quat.w );\n\tuuv *= 2.0;\n\n\treturn normalize( vector + uv + uuv );\n}\n\nvec3 rotateVector( vec4 quat, vec3 vec )\n{\n\treturn vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );\n}\n\nconst vec3 left = vec3( 1, 0, 0 );\nconst vec3 up = vec3( 0, 1, 0 );\nconst vec3 forward = vec3( 0, 0, 1 );\nconst vec4 quaternionIdentity = vec4( 0, 0, 0, 1 );\n\nvec4 linePlaneIntersect(in vec3 rayOrigin, in vec3 rayDirection, in vec3 planeCenter, in vec3 planeNormal )\n{\n\tfloat distanceToPlane = dot( planeNormal, planeCenter - rayOrigin ) / dot( planeNormal, rayDirection );\n\treturn vec4( rayOrigin + rayDirection * distanceToPlane, distanceToPlane);\n}\n\nIntersection RayPlane( Ray ray, Plane p )\n{\n\tIntersection i;\n    i.hit = false;\n\ti.distance = ZMAX;\n   \n    vec3 axisX = quaternionMultiply( p.orient, left );\n    vec3 axisY = quaternionMultiply( p.orient, forward );\n    vec3 axisZ = quaternionMultiply( p.orient, up );\n    \n\t// Intersect ray with plane\n    float distanceToPlane = dot( axisZ, p.center - ray.origin ) / dot( axisZ, ray.direction );\n    \n    if( distanceToPlane > EPSILON )\n    {\n        vec3 pointOnPlane = ray.origin + ray.direction * distanceToPlane;\n        vec3 toCenter = pointOnPlane - p.center;\n\n        float x_dot_c = dot( axisX, toCenter );\n        float y_dot_c = dot( axisY, toCenter );\n        float inExtentX = abs( x_dot_c );\n        float inExtentY = abs( y_dot_c );\n\n        vec2 extents = vec2( p.extent.x, p.extent.y );\n        if( inExtentY < extents.y && inExtentX < extents.x )\n        {\n            i.position = pointOnPlane;\n            i.normal = dot( axisZ, ray.direction ) <= 0.0 ? axisZ : -axisZ;\n            i.distance = distanceToPlane;\n            i.hit = true;\n\n            vec2 scaledPosition = vec2( 0.5 + x_dot_c * 0.5, 0.5 + y_dot_c * 0.5 ) / extents;\n            i.uv = scaledPosition.xy;\t\n\n            vec2 uv = i.uv;\n            i.luminance = p.luminance;\n            i.emission  = p.emission;\n            i.roughness = p.roughness;\n        }\n    }\n    \n\treturn i;\n}\n\nint sideOfPlane(in vec3 p, in vec3 pc, in vec3 pn)\n{\n   if (dot(p-pc,pn)>=0.0) return 1; else return 0;\n}\n\nvec3 projectOnPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) \n{\n    return point - dot( point - planeCenter, planeNorm ) * planeNorm;\n}\n\nvec3 closestPointOnRect( vec3 rect, vec3 extents, vec3 position, vec3 axisX, vec3 axisY, vec3 axisZ )\n{\n\tvec3 proj = projectOnPlane( position, rect, axisZ );\n\tvec3 dir = proj - rect;\n\n\tvec2 diagonal = vec2( dot( dir, axisX ), dot( dir, axisY ) );\n\tvec2 nearest2D = vec2( clamp( diagonal.x, -extents.x, extents.x ), clamp( diagonal.y, -extents.y, extents.y ) );\n    \n\tvec3 nearestPointInside = rect + ( axisX * nearest2D.x + axisY * nearest2D.y );\n\treturn nearestPointInside;\n}\n\nIntersection projectRay( Ray ray )\n{\n    float sintime = sin( iTime );\n    \n    Intersection intersection;\n    \n\tPlane pone;\n\tpone.orient = quaternionIdentity;\n\tpone.extent = vec2( 1, 1 );\n\tpone.center = vec3( 0,-1, 0 );\n    pone.luminance = 0.9;\n    pone.emission = 0.0;\n    pone.roughness = 0.5;\n\tintersection = RayPlane( ray, pone );\n    \n\tPlane ptwo;\n\tptwo.orient = constructQuaternion( ( vec3( 1.0, 0.0, sintime ) ) * halfpi );\n\tptwo.extent = vec2( 1.0, 1.0 );\n\tptwo.center = vec3( 0, -0.5, 2 );\n    ptwo.luminance = 0.9;\n    ptwo.emission = 0.0;\n    ptwo.roughness = 0.05;\n\tintersection = MinIntersection( RayPlane( ray, ptwo ), intersection );\n    \n\tPlane pthree;\n\tpthree.orient = constructQuaternion( ( vec3( 1.0, 0.0, 1.0 ) ) * halfpi );\n\tpthree.extent = vec2( 0.125, 1.0 );\n\tpthree.center = vec3( 0.0, 0.5 * ( sintime - 0.5 ), -0.5 );\n    pthree.emission = 5.0;\n    pthree.luminance = 0.9;\n    pthree.roughness = 0.5;\n\tintersection = MinIntersection( RayPlane( ray, pthree ), intersection );\n    \n    Sphere sphere;\n    sphere.r = 0.5;\n    sphere.c = vec3( 0.0, 0.25 * sintime - 0.25, 0.5 );\n    sphere.emission = 0.0;\n    sphere.roughness = 1.0;\n    intersection = MinIntersection( RaySphere( ray, sphere ), intersection );\n    \n    Sphere spheretwo;\n    spheretwo.r = 0.25;\n    spheretwo.c = vec3( cos( iTime ) * 0.7, 0.25 * sintime - 0.25, 0.5 - sintime * 0.7 );\n    spheretwo.emission = 5.5;\n    spheretwo.roughness = 0.75;\n    intersection = MinIntersection( RaySphere( ray, spheretwo ), intersection );\n    \n    return intersection;\n}\n\n//\n\nvec2 Hash22(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 395.4337, p.x * p.y * 397.597));\n}\n\nfloat random(vec3 scale, float seed, vec2 fragCoord) \n{\n\treturn fract(sin(dot(vec3(fragCoord,0.) + seed, scale)) * 43758.5453 + seed);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 + iTime);\n}\n\n// code from : http://www.rorydriscoll.com/2009/01/07/better-sampling/\n\nvec3 cosineWeightedDirection( float seed, vec3 normal, vec2 fragCoord ) \n{\n    vec2 uv = Hash22( vec2( iTime, seed ) + fragCoord.xy );\n\n    float u = uv.x; float v = uv.y;\n    float r = sqrt(u);\n    float angle = 6.283185307179586 * v;\n    // compute basis from normal\n    vec3 sdir, tdir;\n    if (abs(normal.x)<.5) \n    {\n        sdir = cross(normal, vec3(1,0,0));\n    } \n    else \n    {\n        sdir = cross(normal, vec3(0,1,0));\n    }\n    tdir = cross(normal, sdir);\n    \n    return r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal;\n}\n\nvec3 UniformSampleHemisphere( float x, float y )\n{\n\tfloat SinTheta = ( y );\n    SinTheta *= SinTheta;\n\n\tvec3 H;\n\tH.x = SinTheta * cos( x );\n\tH.y = 0.0;\n\tH.z = SinTheta * sin( x );\n\n\treturn H;\n}\n\nmat3 PBR_axisRotationMatrix( vec3 u, float ct, float st ) //u=axis, co=cos(t), st=sin(t)\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 PBR_importanceSampling(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    const float PI = 3.14159;\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n    float phi = 2.0*PI*e2;\n    vec3 notColinear   = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n    vec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n\tmat3 m1 = PBR_axisRotationMatrix(normalize(othogonalAxis), cos(range), sin(range));\n\tmat3 m2 = PBR_axisRotationMatrix(normalize(sampleDir),     cos(phi),   sin(phi));\n\treturn sampleDir*m1*m2;\n}\n\n//\n\nfloat distributionBeckmann( float roughness, float n_dot_h )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NoH2 = n_dot_h * n_dot_h;\n\treturn exp( (NoH2 - 1.0) / (m2 * NoH2) ) / ( pi * m2 * NoH2 * NoH2 );\n}\n\nfloat distributionGGX( float roughness, float n_dot_h )\n{\n\tfloat m = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat d = ( n_dot_h * m2 - n_dot_h ) * n_dot_h + 1.0;\n\treturn m2 / ( pi*d*d );\n}\n\n// From : https://www.unrealengine.com/blog/physically-based-shading-on-mobile\n\nfloat EnvBRDFApproxNonmetal( float Roughness, float NoV )\n{\n    const vec2 c0 = vec2( -1.0, -0.0275 );\n    const vec2 c1 = vec2(  1.0,  0.0425 );\n    vec2 r = Roughness * c0 + c1;\n    return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n}\n\n//\n\nfloat BurleyBRDF( float NdotL, float NdotV, float VdotH, float roughness )\n{\n\tNdotV = max( NdotV, 0.1 );  // Prevent overly dark edges\n\t\n\t// Burley BRDF with renormalization to conserve energy\n\tfloat energyBias = 0.5 * roughness;\n\tfloat energyFactor = mix(1.0, 1.0 / 1.51, roughness);\n\tfloat fd90 = energyBias + 2.0 * VdotH * VdotH * roughness;\n\tfloat scatterL = mix(1.0, fd90, pow(1.0 - NdotL, 5.0));\n\tfloat scatterV = mix(1.0, fd90, pow(1.0 - NdotV, 5.0));\n\t\n\treturn scatterL * scatterV * energyFactor * NdotL;\n}\n\nfloat SphereNormalization( float len, float lightSize, float m )\n{\n\t// Compute the normalization factors.\n\t// Note: just using sphere normalization (todo: come up with proper disk/plane normalization)\n\tfloat dist = clamp(lightSize / len, 0.0, 1.0);\n\tfloat normFactor = m / clamp( m + 0.5 * dist, 0.0, 1.0 );\n\treturn normFactor * normFactor;\n}\n\nfloat PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, float ior )\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution Term\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; //Distribution term is externalized from IBL version\n\n    //Fresnel Term\n\tfloat F;\n    float F0 = pow((1.0 - ior) / (1.0 + ior),2.0);\n  \tF = (F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    \n    //Geometric term (Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation p.3/59)\n    //k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = roughness*roughness/2.0; \n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    float softTr = 0.1; // Valid range : [0.001-0.25]. Transition softness factor, close from dot(L,N) ~= 0\n    float angleLim = 0.15; // Valid range : [0-0.75]. Compensates for IBL integration suface size.\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr));\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n\tfloat finalval = 0.0;\n    vec3 finalColor = vec3( finalval );\n    \n    vec2 mouse = 3.125 - ( iMouse.xy / iResolution.xy ) * 5.0;\n    \n\tvec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n\tpos.y *= aspect;\n    \n  \tvec3 view = vec3( pos.x, pos.y, 1.0 );\n    vec4 viewOrientation = constructQuaternion( vec3( 0.0, -sin( mouse.x ), 0.0 ) * halfpi );\n    \n    vec3 viewVector = quaternionMultiply( viewOrientation, view );\n\tvec3 rayDir = normalize( view );\n    \n\tRay ray;\n\tray.origin = vec3( sin( mouse.x ) * 2.0 , -0.5, cos( mouse.x ) * 2.0 );\n\tray.direction = rayDir;\n    \n    //\n    \n    float roughness = 0.0;\n    float enviroment = 0.0;\n    float occlusion = 1.0;\n    \n    vec3 lightPosition = vec3( 0.0, 0.0, 0.0 );\n    float nearestPoint = 1000.0;\n    float lightEmission = 0.0;\n    bool everhit = false;\n    \n    const int reflectraycount = 150;\n    const float reflectraycountoverone = 1.0 / float( reflectraycount );\n    \n    const int shadowraycount = 50;\n    const float shadowraycountoverone = 1.0 / float( shadowraycount );\n    \n    Intersection intersect;\n    vec3 normal = vec3( 0.0 );\n    vec3 position = vec3( 0.0 );\n    float hitcount = 0.0;\n    float luminance = 0.0;\n    vec3 viewDirection    = normalize(-viewVector);\n    \n    //\n       \n    Light light;\n    light.lightOrientation = constructQuaternion( vec3( 1.0, 0.0, 1.0 ) * halfpi );\n    light.planarDirection  = quaternionMultiply( light.lightOrientation, up );\n    light.planarRight      = quaternionMultiply( light.lightOrientation, -left );\n    light.planarUp         = normalize( cross( light.planarRight, light.planarDirection ) );\n    light.lightExtents     = vec3( 0.125, 1.0, 0.0 );\n    light.lightPosition    = vec3( 0.0, 0.5 * ( sin( iTime ) - 0.5 ), -0.5 );\n    \n    float emission = 0.0;\n    \n    const int aasamples = 1;\n    const float faaSamples = float( aasamples * aasamples * 2 * 2 );\n    const float aaraycountoverone = 1.0 / float( faaSamples );\n    \n   \tvec3 aaoffset = vec3( fwidth( pos ) * 0.25, 1.0 );\n    for( int x = -aasamples; x < aasamples; x++ )\n    {\n    \tfor( int y = -aasamples; y < aasamples; y++ )\n        {\n            ray.direction = normalize( viewVector + vec3( x, y, 0.0 ) * aaoffset );\n            intersect = projectRay( ray );\n\n            emission += intersect.emission;\n            luminance += intersect.luminance;\n            normal += intersect.normal;\n            position += intersect.position;\n            roughness += intersect.roughness;\n            hitcount += intersect.hit ? 1.0 : 0.0;\n\n            if( hitcount > 10.0 )\n                continue;\n        }\n    }\n    \n    float oneoverhitcount = 1.0 / hitcount;\n    normal    *= oneoverhitcount; position  *= oneoverhitcount;\n    emission  *= aaraycountoverone; luminance *= aaraycountoverone;\n    roughness *= aaraycountoverone;\n    \n    Intersection reflectIntersect;\n    \n    everhit = hitcount > 1.0;\n    if( everhit )\n    {\n        vec3 incident = normalize( position - ray.origin );\n        vec3 incidentReflection = reflect( incident, normal );\n    \tvec3 vCenter = reflect(-viewDirection, normal );\n        Ray reflectionRay;\n\n        // Reflections\n        \n        float sample2d = 0.0;\n        float randomness_range = 0.75;\n        float angularRange = 0.0;\n        float fIdx = 0.0;\n        for( int i = 0; i < reflectraycount; i++ )\n        {\n            float indexOverOne = float( i ) / float( reflectraycount );\n            \n            vec2 jitter;\n            \n            if( i < reflectraycount / reflectraycount )\n            {\n            \tjitter = vec2( clamp(0.1*fIdx,0.0,0.50), fract(0.1*fIdx*1.25)+3.14*fIdx); //Fixed sampling pattern.\n            }\n            else\n            {\n                vec3 p3 = fract(vec3( fIdx*10.0 + incidentReflection.xyx * 100.0 ) * vec3(.1031,.11369,.13787)); \n                p3 += dot(p3.zxy, p3.yzx+19.19+sin(iTime));\n                jitter = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n            }\n            \n            vec3 noiseOffset = PBR_importanceSampling( incidentReflection, roughness, \n                                                       jitter.x * randomness_range, \n                                                       jitter.y, angularRange );\n            \n            //vec3 noiseOffset = cosineWeightedDirection( indexOverOne, normal, fragCoord );\n                \n            reflectionRay.direction = noiseOffset;//normalize( incidentReflection + noiseOffset * roughness );\n            reflectionRay.origin    = position + reflectionRay.direction * EPSILON;\n            reflectIntersect = projectRay( reflectionRay );\n\n            sample2d = reflectIntersect.hit ? reflectIntersect.emission :\n            \tpow( texture( iChannel0, reflectionRay.direction ).r, 2.2 );\n            \n            float contribution = PBR_Equation(viewDirection, reflectionRay.direction, normal, roughness, 0.01 );\n            \n            enviroment += sample2d * contribution * reflectraycountoverone;\n            ++fIdx;\n            \n            if( enviroment > 0.99 )\n                continue;\n        }\n        \n        /*vec3 lightPoint = closestPointOnRect( light.lightPosition, light.lightExtents, \n        \tintersect.position, light.planarRight, light.planarUp, light.planarDirection );\n        \n        vec3 lightDirection = lightPoint - position;\n        \n        // From : http://www.gamedev.net/topic/552315-glsl-area-light-implementation/\n        \n        float roughness2 = roughness * roughness;\n        \n        float distanceToLight = length( lightDirection );\n        float distanceToLightRCP = 1.0 / distanceToLight;\n        float distanceSquared = distanceToLight * distanceToLight;\n        \n        float falloffExp = 0.5;\n        float falloff = 1.0 / ( distanceSquared + 1.0 );\n        float invfalloff = ( distanceSquared * falloffExp * falloffExp );\n        invfalloff = saturate( 1.0 - ( invfalloff * invfalloff ) );\n        invfalloff *= invfalloff;\n        falloff *= invfalloff;*/\n        \n        //\n        \n        /*vec3 vLightDir = dot( light.planarDirection.xyz,  light.lightPosition.xyz) * \n                              light.planarDirection.xyz - light.lightPosition.xyz;\n\n        // Calculate the nearest point.\n        vec2 vSurfArea = vec2( dot( vLightDir.xyz, light.planarRight.xyz ), \n                               dot( vLightDir.xyz, light.planarUp.xyz ) );\n        vec2 vSurfAreaClamp = clamp(vSurfArea.xy, -light.lightExtents.xy, light.lightExtents.xy); // 1 alu\n        vec3 vNearestPoint = light.planarRight.xyz * vSurfAreaClamp.x + (light.planarUp.xyz * vSurfAreaClamp.y);\n\n        vec3 reflectedLightDirection = light.lightPosition.xyz + vNearestPoint.xyz;*/\n        \n        //\n\n        vec3 lightDirection = normalize( light.lightPosition - position );\n       \tvec3 reflectionvector = reflect( viewDirection, normal );\n        float RdotN = ( dot( light.planarDirection.xyz, reflectionvector ) + 1e-6 );\n        float intersectLen = ( ( dot( light.planarDirection.xyz, lightDirection) ) / ( RdotN ) );\n        vec3 I = reflectionvector * intersectLen - lightDirection;\n        vec3 I2 = reflectionvector *  dot( light.planarDirection.xyz, lightDirection) - lightDirection;\n\n        // Project the intersection to 2D and clamp it to the light radius to get a point inside or on the edge of the light.\n        vec2 lightPos2D = vec2( dot(I.xyz, light.planarRight.xyz), dot(I.xyz, light.planarUp.xyz) );\n        vec2 lightPos2D2 = vec2( dot(I2.xyz, light.planarRight.xyz), dot(I2.xyz, light.planarUp.xyz) );\n        vec2 lightClamp2D = clamp(lightPos2D, -light.lightExtents.xy, light.lightExtents.xy);\n        vec2 lightClamp2D2 = clamp(lightPos2D2, -light.lightExtents.xy, light.lightExtents.xy);\n        \n        vec3 ld1 = lightDirection + ( light.planarRight.xyz * lightClamp2D.x ) + light.planarUp.xyz * lightClamp2D.y;\n        vec3 ld2 = lightDirection + ( light.planarRight.xyz * lightClamp2D2.x ) + light.planarUp.xyz * lightClamp2D2.y;\n        \n        lightDirection = ld2;\n        \n        float len = max( length( lightDirection.xyz ),  1e-6 );\n        lightDirection.xyz /= len;\n        //lightDirection = normalize( lightDirection );\n        \n        float lightNormalization = SphereNormalization( ( len ), ( length( light.lightExtents ) ), roughness );\n        \n        vec3 halfVector = normalize( viewDirection + lightDirection );\n        \n        // Lighting\n        \n        //falloff *= saturate( dot( light.planarDirection, -lightDirection ) );\n\n        float n_dot_l = saturate( dot( lightDirection, normal ) );\n        float n_dot_v = abs( dot( normal, lightDirection ) ) + 1e-5;\n        float h_dot_n = saturate( dot( halfVector, normal ) );\n        float v_dot_h = saturate( dot( viewDirection, halfVector ) );\n        \n        float diffuse = BurleyBRDF( n_dot_l, n_dot_v, v_dot_h, roughness );\n               \n        //\n\n        float fresneloffset = 0.05;\n        float normalizationFactor = 1.0;\n       \tfloat m2 = roughness * roughness;\n        float spec = (h_dot_n * m2 - h_dot_n) * h_dot_n + 1.0;\n        spec = m2 / (spec * spec) * normalizationFactor;\n\n        // Correlated Smith Visibility Term (including Cook-Torrance denominator)\n        float Gv = n_dot_l * sqrt(   (-n_dot_v * m2 + n_dot_v) * n_dot_v + m2 );\n        float Gl = n_dot_v * sqrt( (-n_dot_l * m2 + n_dot_l) * n_dot_l + m2 );\n        spec *= 0.5 / (Gv + Gl);\n\n        float f90 = saturate( dot( fresneloffset, 0.33333 ) / 0.02 );  // Assume micro-occlusion when reflectance is below 2%\n        float fresnel = mix( fresneloffset, f90, pow( 1.0 - h_dot_n, 5.0 ) );\n\n        //\n\n        float approxEnv = EnvBRDFApproxNonmetal( roughness, n_dot_v );\n        float distribution = saturate( distributionGGX( roughness, h_dot_n ) ) ;\n        float BRDF = ( fresnel * spec * n_dot_l ) + n_dot_l * 0.1;// * ( 0.2 + approxEnv * distribution );\n        \n        finalColor += emission + ( luminance * enviroment );// + BRDF;\n    }\n\n    finalColor = vec3( pow( finalColor, vec3( 1.0 / 2.2 ) ) );\n\tfragColor = vec4( finalColor, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sBXDD","date":"1411962022","viewed":521,"name":"Raytraced Reflection Experiments","username":"Orihaus","description":"Uses a few techniques I haven't seen on Shadertoy yet: stochastic (Glossy) secondary rays, anti-aliased primary ray, planar area lighting. Also, quaternion-aligned quads.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}