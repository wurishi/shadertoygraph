{"ver":"0.1","info":{"id":"tsSBRd","date":"1590600072","viewed":130,"name":"Bispirale Hedges","username":"spalmer","description":"someone dared someone to do it, so ...","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["hedge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://shadertoy.com/view/tlyGzG\n// and uses a FabriceNeyret2 snippet :)\n// TODO needs more work, some trees, and a lot of cleanup\n\n// simple bispirale by Fabrice :) https://shadertoy.com/view/tsBfRt\nfloat abispirale(vec2 u)\n{\n    u /= 32.; \n    u.x += sign(u.y)*.375;\n    return .5 - cos(58.6* length(u)) * .5;\n}\n// btw there's a busted derivative between the two halves of the bispirale!\n\n//#define Enviro   iChannel2\n \nconst float tau = 2. * acos(-1.);\n\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 25314.67283);\n}\n\nfloat hash(vec2 x)\n{\n\treturn rand(dot(x, vec2(7,5)));\n}\n\nfloat hash(vec3 x)\n{\n\treturn rand(dot(x, vec3(7,5,11)));\n}\n\nfloat hbispirale(vec2 p)\n{\n    float c = abispirale(p);\n    c = clamp(c*2.-1., 0., 1.);\n    return 1.-pow(max(0., 1.-c), 2.);\n}\n/* // just inlined\nfloat dbispirale(vec3 p)\n{\n    float h = hbispirale(p.xz);\n\t// converts height to fake conservative distance atm\n    return p.y - h;\n//\treturn sqrt(sqrt(c));\n//    if (c >= .99) return .5;\n//    c = c * .5; // HACK thin walls\n     // round the hedges\n//    float s = sqrt(1. - c*c);\n//    return 0.; //.5 - .5 * c;   \n}\n*/\nfloat dleaf(vec2 q)\n{\n    q.x = abs(q.x);\n    q.x = q.x + .5;\n    return length(q) - 1.02;\n}\n\n\nfloat gt(vec3 p, vec3 c, vec3 o, float h, inout float r)\n{\n//    return length(p) - .2; //.001; //1./tSpace;\n    vec3 q = p + o; // o is presently zero; q should be relative to cell origin, local coord, basically\n    if (q.y > h) //2.5) // 0.)  //\n        return r; // cull if center not inside hedge shape\n     // need random orientation\n    float n1 = hash(c) * tau;\n    float n2 = (hash(c+1.) * 2. - 1.) * .25 * tau; //sin(2.5*iTime) * 3.14 * .5; //\n    rot(q.xz, vec2(cos(n1),sin(n1)));\n    rot(q.yz, vec2(cos(n2),sin(n2))); // fine, we'll just do it this way!\n    float d = dleaf(q.xz / .5) * .5;\n    float dy = abs(q.y) - .02;\n    d = max(d, dy); //min(d, dy); //d += dy; // flat\n    return r = min(r, d); //d; //\n}\n\nfloat gd(vec3 p, float h)\n{\n    vec3 c = floor(p);\n    const float ldens = 1.; //.5; //.2; // affects leaf density, not scale\n\t/*c = floor(p / ldens); // tile address\n    p.xyz = (fract(p / ldens) - .5) * ldens; // local coord\n    //return length(p) - .2; //.001; //1./ldens; */\n\tfloat r = 3e38; //dist2frame(p, 4.25);\n    //gt(p, c, vec3(0), h, r); // had 2 fields interleaved before\n    // no, must re-tile again  - beware 0.5 scale factor! still causing problems\n    gt((fract((p + .25) / ldens) - .5) * ldens, c+.5, vec3(0), h, r);\n    // random offsets would be better but this is pretty dense and looks ok-ish for now\n    //r *= ldens;\n    return r;\n  #if 0\n //   return gt(p, c, vec3(0), 3e38); // actual leaf\n    // TODO checking neighbor cells will be necessary once I start perturbing their offsets near the cell boundaries\n\tvec2 z = vec2(0,1);\n\tgt(p, c, z.xxx, h, r);\n\tgt(p, c, z.yxx, h, r);\n\tgt(p, c, z.xyx, h, r);\n\tgt(p, c, z.yyx, h, r);\n\tgt(p, c, z.xxy, h, r);\n\tgt(p, c, z.yxy, h, r);\n\tgt(p, c, z.xyy, h, r);\n\tgt(p, c, z.yyy, h, r);\n//\tr = min(r, abs(p.y - 0.));\n\treturn r; \n  #endif\n}\n\nfloat max3(vec3 a) { return max(a.x,max(a.y,a.z)); }\n\nvec3 campos, camdir;\n\nfloat sdf(vec3 p)\n{\n\tfloat h = hbispirale(p.xz);\n    h = max(h, 0.);\n    // this part's really supposed to be only the low-lod\n   // h -= .01; // in fact, trim it down a bit so march won't stop on it before hitting leaves\n    float pd = p.y - h; // not a true sdf, just a heightfield\n    // tiled randomized leaf texture\n    // but only in areas *beneath* the maze hedge height and above the ground\n    if (true //false //\n        //distance(p,campos) < 5. && // just switch to lod lod with distance\n      &&  h > .03\n      &&  pd < .2 //p.y < h + .2\n     //   && max3(fwidth(p)) < 1e-7 // totally not working how I'd hoped\n       ) {\n        // scale of the hedge leaves\n        float lscale = 1. / 2.; //32.; //4.; //8.; //64.; //\n        float ld = gd(p/lscale, h / lscale)*lscale;\n        ld *= .9; // it's FUBAR HACK\n       // ld = min(ld, pd - h + .33); // fill body of hedge where leaves don't cover enough - borked\n        return min(pd, ld);\n    } else {\n        pd *= .91;\n    }\n    return pd;\n}\n\nvec3 nbispirale(vec3 p, float h)\n{\n    return normalize((vec3(sdf(p + vec3(h,0.,0.)), sdf(p + vec3(0.,h,0.)), sdf(p + vec3(0.,0.,h))) - sdf(p)) / h);\n}\n    \nfloat raymarch(vec3 ro, vec3 rd, int maxsteps)\n{\n    float ret = -1.;\n    float t = 0.0;\n    for (int i = 0; i < maxsteps; ++i) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if (d <= 1e-7) {\n          ret = t;\n          break;\n        }\n        t += max(d, .0005);\n    }\n    if (ret < 0. && rd.y < 0.)\n        ret = ro.y / -rd.y; // rescue to plane\n    return ret;\n}\n\nconst vec3 L = normalize(vec3(1.,1.,2.));\n\nfloat shadow(vec3 p)\n{\n    float r = raymarch(p, L, 24);\n    return r > 0.\n        ? .4 : 1.;\n}\n\nvec3 lighting(vec3 d, vec3 n, float r, vec3 p)\n{\n    vec3 cdiff = vec3(.3,.7,.1);\n    if (p.y < .01) cdiff = vec3(.9,.5,.2);\n    float h = p.y; // this color palette is bogus FIXME\n    float nl = dot(L, n);\n    float shadowatten = shadow(p + n * .005 + nl * .03 * L); //1.; //\n    nl = max(0., nl);\n    // TODO ambient occlusion\n    nl *= shadowatten;\n    float diff = mix(nl, 1., .05);  // wtf kind of hax is this\n    vec3 H = normalize(L+d); // blinn-phong hack\n    float spec = nl * pow(max(0., dot(H, n)), 64.); //0.; //\n    vec3 nr = reflect(n, d); //d, n); //\n//    vec3 env = textureLod(Enviro, nr, 0.).rgb;\n    return //env + \n        clamp(cdiff * diff + .6 * spec, 0., 1.); //mix(diff, 2.*spec, .5);\n}\n\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\nvec3 draw(vec2 q)\n{\n    campos = vec3(sin(vec2(0,.25*tau) + iTime * .01), -5).xzy; // slow fly cam\n    camdir = vec3(cos(vec2(0,.25*tau) + iTime * .01) * .5, -.866).xzy;\n    campos -= camdir * 63.;\n    mat3 m = cameraMatrix(camdir);\n    vec3 rp = campos;\n    vec3 rd = normalize(m * vec3(q, 2.));\n    float r = raymarch(rp, rd, 72);\n    float vl = max(dot(rd, L), 0.);\n    if (!(r >= 0.))\n        return vec3(mix(.5,1.,pow(vl, 4.))) //exp2(-8. * max(0.,1.-vl))))\n       * 1.2*vec3(.85,.9,.95);\n    vec3 phit = rp + rd * r;\n    float nw = .005 * r;\n    vec3 n = nbispirale(phit, nw);\n    return lighting(-rd, n, r, phit);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    c.rgb = draw((p+p-r)/r.y);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to approx srgb gamut\n\tc.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}