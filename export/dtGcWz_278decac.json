{"ver":"0.1","info":{"id":"dtGcWz","date":"1700091454","viewed":15,"name":"Fractal Lakes  - David","username":"davidmachadosf","description":"KEYS\n    ' : reset\n  (numpad numlock OFF):..\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom +/-  \n    + -      : inc/dec zoom\n    .        : stop/play\n    Home End : +/- cicle vel\n    PgUp PgDown: Cicle 19 diff f(x,y)\n   a q: change pal","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"mlGyWz","parentname":"Polar Coordinates - Iterative 4"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n\nfloat n = 5.;\nfloat pi = 3.141592;\nfloat thetax = 0.;\nfloat thetay = .5*3.141592;\n\n\nfloat uniform_to_widthNanometers (float u){\n    return 380. + 400.*(1.-u);\n}\n\n\n\nfloat uniform_to_freqTeraHertz (float u){\n    return (384. + 405.*u)*1.e3;\n}\n\nvec4 paletteReal( float w ) {\n    \n    float red, green, blue;\n\n    if (w >= 380. && w < 440.) {\n        red   = -(w - 440.) / (440. - 380.);\n        green = 0.;\n        blue  = 1.;\n    }\n    else \n    if (w >= 440. && w < 490.) {\n        red   = 0.;\n        green = (w - 440.) / (490. - 440.);\n        blue  = 1.;\n    }\n    else \n    if (w >= 490. && w < 510.) {\n        red   = 0.;\n        green = 1.;\n        blue  = -(w - 510.) / (510. - 490.);\n    }\n    else \n    if (w >= 510. && w < 580.) {\n        red   = (w - 510.) / (580. - 510.);\n        green = 1.;\n        blue  = 0.;\n    }\n    else \n    if (w >= 580. && w < 645.) {\n        red   = 1.;\n        green = -(w - 645.) / (645. - 580.);\n        blue  = 0.;\n    }\n    else \n    if (w >= 645. && w < 781.) {\n        red   = 1.;\n        green = 0.;\n        blue  = 0.;\n    }\n    else {\n        red   = 0.;\n        green = 0.;\n        blue  = 0.;\n    }\n\n\n    // Let the intensity fall off near the vision limits\n    float factor;\n    if (w >= 380. && w < 420.)\n        factor = .3 + .7*(w - 380.) / (420. - 380.);\n    else \n    if (w >= 420. && w < 701.)\n        factor = 1.;\n    else \n    if (w >= 701. && w < 781.)\n        factor = .3 + .7*(780. - w) / (780. - 700.);\n    else\n        factor = 0.;\n\n    float gamma = .8;\n    float R = (red   > 0. ? 255.*pow(red   * factor, gamma) : 0.);\n    float G = (green > 0. ? 255.*pow(green * factor, gamma) : 0.);\n    float B = (blue  > 0. ? 255.*pow(blue  * factor, gamma) : 0.); \n    \n    return vec4(R/255.,G/255.,B/255.,1.);\n    //return vec3(r,0.,b);\n}\n\n\n\n\nfloat processFunction(int func, float x, float y){\n\n    // x:radius y:angle\n    switch(func){\n        case  0: return log(abs(x)) + log(abs(y));\n        case  1: return log(abs(x)) +         y  ;\n        case  2: return         x   + log(abs(y));\n        case  3: return         x   +         y  ;\n        case  4: return         x   +       y*y  ;\n        case  5: return       x*x   +       y*y  ;\n        case  6: return       x*x   +     y*y*y  ;\n        case  7: return     x*x*x   +       y*y  ;\n        case  8: return     x*x*x   +     y*y*y  ;\n        case  9: return   x*x*x*x   +   y*y*y*y  ;\n        case 10: return x*x*x*x*x   + y*y*y*y*y  ;\n        case 11: return      1./x   +      1./y  ;\n        case 12: return  1./(x*x)   -  1./(y/x)  ;\n        case 13: return 1./(x*x*x)  + 1./(y*y*y) ;\n        case 14: return     sin(log(abs(x*y)))   + \n                            cos(log(abs(y/x)))   ;\n        case 15: return (y+x)/cos(x*y*x)  + sin(x-y)/(y*x*y) ;\n        case 16: return sin(abs(atan(y/x)))+y/x;\n        case 17: return sin(log(abs(atan(y/x))))+y/x;\n        \n        case 18: return sin(y/x)*cos(x/y);\n        case 19: return (y+x)/x*cos(x+y);\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    \n    float[5] colors;\n    \n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    \n    int func = int(get(paramFunc));\n    \n    bool      cicle = get(paramCicle)>0.;\n    float  velCicle = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);    \n    float cpow      = get(paramCpow);\n    \n    \n    float x = (xi+(xf-xi)*uv.x);\n    float y = (yi+(yf-yi)*uv.y);\n    \n    \n    // coordenadas polares\n    float r = pow(x*x+y*y,.5);\n    float a = atan(x,y);\n    \n    \n    \n    float d, newx, newy;\n    float t = timeCicle;\n\n    if(cicle){\n      float dt = (1.*iTime - timeBase)*velCicle;\n      t += dt;        \n    }\t\n\n     \n    d = 0.;\n    for(int i=0;i<5;i++){\n\n        d = processFunction(func,sin(r+t),a);\n        \n        \n        //float omegax = cos(2.*pi+sin((d+t)*y));\n        //float omegay = sin(2.*pi+cos((d-t)*x));\n\n        \n        //float omegax = y/d + x/sqrt(n) + thetax + 2.*t;\n        //float omegay = x/d + y/sqrt(n) + thetay + .5*t;\n\n        //newx = omegax;\n        //newy = omegay;\n\n        //x = newx;\n        //y = newy;\n        \n        \n        //colors[i]=pow(d,cpow);\n        colors[i]=pow((sin(d)+1.)/2.,cpow)*255.;//abs(pow(((x/t-y)/2.+1.)/2.,cpow))*255.;\n        \n        \n    }\n\t\t\t\n\n    // Output to screen\n    //vec3 col = vec3();\n    \n    \n    \n    //fragColor = vec4(colors[2]/256.,colors[4]/256.,colors[3]/256.,1.0);\n    float w1 = uniform_to_widthNanometers(colors[1]/256.);\n    float w2 = uniform_to_widthNanometers(colors[2]/256.);\n    float w3 = uniform_to_widthNanometers(colors[3]/256.);\n    fragColor = (paletteReal(w1)+paletteReal(w2)+paletteReal(w3))/3.*((colors[4]+colors[0])/512.);\n    \n    //fragColor = paletteReal(uniform_to_widthNanometers(d));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n// parameters (coordinates on texture buffer)\nconst ivec2 paramXi = ivec2(0,0);\nconst ivec2 paramXf = ivec2(0,1);\nconst ivec2 paramYi = ivec2(0,2);\nconst ivec2 paramYf = ivec2(0,3);\n\nconst ivec2 paramVel   = ivec2(1,0);\nconst ivec2 paramFunc  = ivec2(2,0);\n\n\nconst ivec2 paramCicle     = ivec2(3,0);\nconst ivec2 paramVelCicle  = ivec2(3,1);\nconst ivec2 paramTimeCicle = ivec2(3,2);\nconst ivec2 paramTimeBase  = ivec2(3,3);\n\nconst ivec2 paramCpow      = ivec2(4,0);\n\n// read and store values as x value on texture pixels\n#define get(var) texelFetch(iChannel0, var, 0).x\n#define set(var, value, fragColor, fragCoord) fragColor=(ivec2(fragCoord)==var?vec4(value,0.,0.,1.):fragColor)\n\n\n// reset to initial parameters\nconst int keyReset = 192; // Esc\n\n// change image functions\nconst int keyPrev = 33; // PgUp\nconst int keyNext = 34; // PgDown\n\n\n// change position (arrow keys)\nconst int keyNorth = 38;\nconst int keySouth = 40;\nconst int keyEast  = 37;\nconst int keyWest  = 39;\nconst int keyOrig  = 12;\n\n\n\n// keycodes below are from numeric keyboard\n\n// change scale\nconst int keyZoomOut = 111; // /\nconst int keyZoomIn  = 106; // *\n\n// change scale velocity\nconst int keySlow = 109; // -\nconst int keyFast = 107; // +\n//const int keySlow = 81; // -\n//const int keyFast = 65; // +\n\n// cicle palete over time\nconst int keyCicle = 110; // .\n\n// change cicle velocity\nconst int keyCicleSlow = 36; // Home\nconst int keyCicleFast = 35; // End\n\n\n// change palete pow\nconst int keyPowDec  = 81; // q\nconst int keyPowInc  = 65; // a\nconst int keyPowZero = 90; // z\n\n\n\n\n\n\n\n#define keyToggle(code)  ( texelFetch(iChannel1,ivec2(code,2),0).x > 0.)\n#define keyClick(code)   ( texelFetch(iChannel1,ivec2(code,1),0).x > 0.)\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n/* MANUAL\n\nKEYS\n    ' : reset\n  (numpad numlock OFF):..\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom in/out  \n    + -      : inc/dec zoom vel\n    .        : pause/play time\n    Home End : inc/dec cicle vel\n    PgUp PgDown: Cicle 19 diff f(x,y)\n    q a: change palete gamute\n    \n*/\n\n\n// initial parameter values\nfloat iniXi       =  -1. ;\nfloat iniXf       =   1. ;\nfloat iniYi       =  -1. ;\nfloat iniYf       =   1. ;\nfloat iniVel      =   .01;\nfloat iniFunc     =  3.  ;\n\nfloat iniCicle     =  1.  ; // -1.: FALSE 1.:TRUE\nfloat iniVelCicle  =  1.  ;\nfloat iniTimeCicle =  0.  ;\nfloat iniTimeBase  =  0.  ;\n\nfloat iniCpow = 2. ; \n\n\n\nvoid initParameters(inout vec4 fragColor, in vec2 fragCoord){\n    set(paramXi,       iniXi,       fragColor, fragCoord);   \n    set(paramXf,       iniXf,       fragColor, fragCoord);   \n    set(paramYi,       iniYi,       fragColor, fragCoord);   \n    set(paramYf,       iniYf,       fragColor, fragCoord);   \n    set(paramVel,      iniVel,      fragColor, fragCoord);   \n    set(paramFunc,     iniFunc,     fragColor, fragCoord);   \n    \n    set(paramCicle,     iniCicle,     fragColor, fragCoord);   \n    set(paramVelCicle,  iniVelCicle,  fragColor, fragCoord);   \n    set(paramTimeCicle, iniTimeCicle, fragColor, fragCoord);   \n    set(paramTimeBase,  iniTimeBase,  fragColor, fragCoord); \n    \n    set(paramCpow,  iniCpow,  fragColor, fragCoord); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // initialize values\n    if (iFrame==0) {\n        initParameters(fragColor, fragCoord);    \n    }\n\n    else { \n    \n        // get current values\n        float xi       = get(paramXi);   \n        float xf       = get(paramXf);   \n        float yi       = get(paramYi);   \n        float yf       = get(paramYf);   \n        float vel      = get(paramVel);   \n        float func     = get(paramFunc); \n        \n        float cicle     = get(paramCicle);  \n        float velCicle  = get(paramVelCicle);  \n        float timeCicle = get(paramTimeCicle);  \n        \n        float timeBase  = get(paramTimeBase);\n        \n        float cpow      = get(paramCpow);\n        \n        // current visible window size\n        float dx = xf-xi;\n        float dy = yf-yi;\n        \n        \n       \n        \n        // move image\n        if(keyDown(keyNorth)){\n            yi+=dy/100.;\n            yf+=dy/100.;\n        }\n        if(keyDown(keySouth)){\n            yi-=dy/100.;\n            yf-=dy/100.;\n        }\n        if(keyDown(keyEast)){\n            xi-=dx/100.;\n            xf-=dx/100.;\n        }\n        if(keyDown(keyWest)){\n            xi+=dx/100.;\n            xf+=dx/100.;\n        }\n        \n        // return to 0,0 (dont change scale)\n        if(keyDown(keyOrig)){\n            xi=-dx/2.;\n            xf=+dx/2.;\n            yi=-dy/2.;\n            yf=+dy/2.;\n        }\n        \n        // zoom controls\n        if(keyDown(keyZoomOut)){\n            xi-=dx*vel;\n            xf+=dx*vel;\n            yi-=dy*vel;\n            yf+=dy*vel;\n        }        \n        if(keyDown(keyZoomIn)){\n            xi+=dx*vel;\n            xf-=dx*vel;\n            yi+=dy*vel;\n            yf-=dy*vel;\n        }\n        \n        // zoom velocity change\n        if(keyClick(keySlow)){\n            vel/=2.;\n        }        \n        if(keyClick(keyFast)){\n            vel*=2.;\n        }\n                \n        \n        \n        // restart to initial status\n        if(keyClick(keyReset)){            \n            xi    = iniXi;\n            xf    = iniXf;\n            yi    = iniYi;\n            yf    = iniYf;\n            vel   = iniVel;\n            func  = iniFunc;\n            \n            cicle     = iniCicle;\n            velCicle  = iniVelCicle;  \n            timeCicle = 0.; \n            timeBase  = 1.*iTime;\n        }\n        \n        \n        // change f(x,y) function\n        if(keyClick(keyPrev)){\n            func = func-1.;\n            if(func<0.) func = 19.;\n        }        \n        if(keyClick(keyNext)){\n            func = func+1.;\n            if(func>19.) func = 0.;\n        }\n        \n        // cicle fase and colors by iTime\n        if(keyClick(keyCicle)){\n            // its a bool, but I must store as float... \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle < 0.){\n                // estava parado                \n                timeBase = fTime;\n            }\n            else{\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = timeCicle;        \n            }\n                        \n            cicle*=-1.;\n        }\n        \n        // cicle velocity change\n        if(keyDown(keyCicleSlow)){\n        \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n        \n            velCicle/=1.01;            \n        }        \n        if(keyDown(keyCicleFast)){\n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n            \n            velCicle*=1.01;            \n        }\n        \n        \n        // change palete power\n        if(keyDown(keyPowDec)){\n            cpow /=1.01;\n        }        \n        if(keyDown(keyPowInc)){\n            cpow *=1.01;\n        }\n        if(keyClick(keyPowZero)){\n            cpow = iniCpow;\n        }        \n        \n        \n        \n        \n        // update parameters\n        set(paramXi,       xi,       fragColor, fragCoord);   \n        set(paramXf,       xf,       fragColor, fragCoord);   \n        set(paramYi,       yi,       fragColor, fragCoord);   \n        set(paramYf,       yf,       fragColor, fragCoord);   \n        set(paramVel,      vel,      fragColor, fragCoord);   \n        set(paramFunc,     func,     fragColor, fragCoord);   \n        \n        set(paramCicle,     cicle,     fragColor, fragCoord); \n        set(paramVelCicle,  velCicle,  fragColor, fragCoord); \n        set(paramTimeCicle, timeCicle, fragColor, fragCoord); \n        set(paramTimeBase,  timeBase, fragColor, fragCoord); \n        \n        set(paramCpow,  cpow, fragColor, fragCoord); \n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}