{"ver":"0.1","info":{"id":"MlBfRW","date":"1632694613","viewed":420,"name":"yoshi_","username":"myrkott","description":"Yoshi!","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","yoshi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarched SDF rendering of a familiar green little dinosaur :) The materials\n// and lighting have been tweaked to make the model look soft and cartoonish,\n// with soft shadows, faked subsurface scattering (wrap shading), faked one\n// bounce diffuse GI, and rim lighting.\n//\n// The shader is currently quite slow and might crash on some mobile GPUs. Will\n// try to fix that...\n//\n// Controls: Press the left mouse button and move the mouse horizontally to\n// rotate the camera around the model.\n//\n// To enable anti-aliasing, increase the SPP (samples per pixel) setting to,\n// e.g., 2 or 4. This will make the rendering much slower, so make sure your\n// GPU can handle it :)\n//\n// Author: Johan NysjÃ¶\n\n#define SETTINGS_YOSHI_COLOR vec3(0.25, 0.875, 0.2)\n#define SETTINGS_KEY_LIGHT_INTENSITY 0.5\n#define SETTINGS_SKY_LIGHT_INTENSITY 1.2\n#define SETTINGS_RIM_LIGHT_INTENSITY 0.45\n#define SETTINGS_EXPOSURE 1.0\n#define SETTINGS_SPP 1\n\n#define PI 3.141592653\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct PerspectiveCamera {\n\tvec3 eye;\n    vec3 up;\n    vec3 center;\n    float fovy;\n    float aspect;\n};\n\nstruct DirectionalLight {\n\tvec3 direction;\n    vec3 color;\n    float intensity;\n};\n\nstruct HemisphereLight {\n    vec3 up;\n    vec3 sky_color;\n    vec3 ground_color;\n    float intensity;\n};\n\nstruct RimLight {\n    vec3 color;\n    float intensity;\n};\n\nstruct Material {\n\tvec3 base_color;\n    float metalness;\n    float gloss;\n    float wrap;\n    float rim;\n};\n\nvec3 srgb2lin(vec3 color)\n{\n\treturn pow(color, vec3(2.2));\n}\n\nvec3 lin2srgb(vec3 color)\n{\n\treturn pow(color, vec3(0.454));\n}\n\nvec3 normalize_safe(vec3 v)\n{\n    float v_length = length(v);\n    return v_length > 0.0 ? v / v_length : v;\n}\n\n// The R2 low-discrepancy sequence, generates evenly distributed points in [0,1)^2\n// Reference: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 ldseq_r2(int n)\n{\n\tfloat phi = 1.324717957;\n    return fract(float(n) / vec2(phi, phi * phi));\n}\n\nRay get_camera_ray(PerspectiveCamera camera, vec2 uv)\n{\n    vec3 f = normalize(camera.center - camera.eye);\n    vec3 s = normalize(cross(f, normalize(camera.up)));\n    vec3 u = normalize(cross(s, f));\n\n    float half_height = tan(0.5 * camera.fovy);\n    float half_width = camera.aspect * half_height;\n    float x = 2.0 * uv.x - 1.0;\n    float y = 2.0 * uv.y - 1.0;\n\n    Ray ray;\n    ray.origin = camera.eye;\n    ray.direction = normalize(f + x * half_width * s + y * half_height * u);\n    \n    return ray;\n}\n\nvec2 min_op(vec2 d0, vec2 d1)\n{\n    return (d0.x < d1.x) ? d0 : d1;\n}\n\nvec2 smin_op(vec2 d0, vec2 d1)\n{\n    float k = 0.05;\n    float h = clamp(0.5 + 0.5 * (d1.x - d0.x) / k, 0.0, 1.0);\n    float dist = mix(d1.x, d0.x, h) - k * h * (1.0 - h);\n    float material_id = (d0.x < d1.x) ? d0.y : d1.y;\n\n    return vec2(dist, material_id);\n}\n\nvec2 ssmin_op(vec2 d0, vec2 d1)\n{\n    float k = 0.01;\n    float h = clamp(0.5 + 0.5 * (d1.x - d0.x) / k, 0.0, 1.0);\n    float dist = mix(d1.x, d0.x, h) - k * h * (1.0 - h);\n    float material_id = (d0.x < d1.x) ? d0.y : d1.y;\n\n    return vec2(dist, material_id);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tmat3 R = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(angle), sin(angle),\n        0.0, -sin(angle), cos(angle)\n    );\n\n    return R * v;\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tmat3 R = mat3(\n        cos(angle), 0.0, -sin(angle),\n        0.0, 1.0, 0.0,\n        sin(angle), 0.0, cos(angle)\n    );\n\n    return R * v;\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tmat3 R = mat3(\n        cos(angle), sin(angle), 0.0,\n        -sin(angle), cos(angle), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    return R * v;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n\treturn length(pos) - radius;   \n}\n\nfloat ellipsoid(vec3 pos, vec3 radius)\n{\n\treturn (length(pos / radius) - 1.0) * min(radius.x, min(radius.y, radius.z));   \n}\n\nfloat torus(vec3 pos, vec3 radius)\n{\n    float d = (length(pos.xy / radius.xy) - 1.0) * min(radius.x, radius.y);\n    return length(vec2(d, pos.z)) - radius.z;\n}\n\nvec2 yoshi_head(vec3 pos)\n{\n    // Apply symmetry along the x-axis, to save some SDF computations.\n    pos.x = abs(pos.x);\n\n    // Head\n    float mat_id_head = 1.0;\n    vec2 dist = vec2(sphere(pos - vec3(0.0, -0.02, 0.03), 0.245), mat_id_head);    \n    dist = smin_op(dist, vec2(ellipsoid(pos - vec3(0.085, 0.07, 0.06), vec3(0.15, 0.28, 0.165)), mat_id_head));\n    dist = smin_op(dist, vec2(ellipsoid(pos - vec3(0.0, 0.07, 0.06), vec3(0.15, 0.28, 0.165)), mat_id_head));\n    dist = smin_op(dist, vec2(ellipsoid(pos - vec3(-0.085, 0.07, 0.06), vec3(0.15, 0.28, 0.165)), mat_id_head));\n\n    // Eyebrow ridge\n    float mat_id_eyebrow_ridge = 1.0;\n    dist = smin_op(dist, vec2(torus(rotate_x((pos - vec3(0.07, 0.175, 0.13)), radians(8.5)), vec3(0.09, 0.135, 0.025)), mat_id_eyebrow_ridge));\n\n    // Spines\n    float mat_id_spines = 6.0;    \n    dist = ssmin_op(dist, vec2(ellipsoid(pos - vec3(0.0, -0.09, -0.23), vec3(0.04, 0.074, 0.074)), mat_id_spines));\n    dist = ssmin_op(dist, vec2(ellipsoid(pos - vec3(0.0, 0.055, -0.235), vec3(0.04, 0.074, 0.074)), mat_id_spines));\n    dist = ssmin_op(dist, vec2(ellipsoid(pos - vec3(0.0, 0.175, -0.155), vec3(0.04, 0.074, 0.074)), mat_id_spines));\n\n    // Cheeks\n    float mat_id_cheeks = 4.0;    \n    dist = min_op(dist, vec2(sphere(pos - vec3(0.12, -0.03, 0.05), 0.2), mat_id_cheeks));\n    dist = ssmin_op(dist, vec2(sphere(pos - vec3(0.0, -0.0475, 0.0575), 0.22), mat_id_cheeks));    \n    \n    // Nose\n    float mat_id_nose = 1.0;\n    dist = min_op(dist, vec2(ellipsoid(pos - vec3(0.0, 0.0, 0.44), vec3(0.26, 0.235, 0.26)), mat_id_nose));\n\n    return dist;\n}\n\nvec2 yoshi_eye(vec3 pos)\n{\n    vec2 mat_ids = vec2(4.0, 5.0);\n\tvec2 dist = vec2(ellipsoid(pos - vec3(0.07, 0.0, 0.0), vec3(0.1, 0.15, 0.05)), mat_ids.x);\n\tdist = min_op(dist, vec2(ellipsoid(pos - vec3(0.065, 0.02, 0.043), vec3(0.04, 0.06, 0.025)), mat_ids.y));\n\n\treturn dist;    \n}\n\nvec2 yoshi_body(vec3 pos)\n{\n    // Back\n    float mat_id_back = 1.0;    \n    vec2 dist_back = vec2(ellipsoid(pos - vec3(0.0, 0.215, -0.075), vec3(0.3, 0.21, 0.3)), mat_id_back);\n\tdist_back = smin_op(dist_back, vec2(sphere(pos - vec3(0.0, 0.345, 0.0), 0.245), mat_id_back));\n    dist_back = smin_op(dist_back, vec2(sphere(pos - vec3(0.0, 0.265, 0.0), 0.26), mat_id_back));\n    dist_back = smin_op(dist_back, vec2(sphere(pos - vec3(0.0, 0.255, -0.075), 0.24), mat_id_back));\n    dist_back = smin_op(dist_back, vec2(sphere(pos - vec3(0.0, 0.215, -0.23), 0.155), mat_id_back));\n    dist_back = smin_op(dist_back, vec2(sphere(pos - vec3(0.0, 0.2, -0.35), 0.075), mat_id_back));\n\n    // Belly\n    float mat_id_belly = 4.0;\n    vec3 scaling = vec3(0.97, 1.012, 1.01);\n    vec3 offset = vec3(0.0, -0.001, -0.004);\n    vec2 dist_belly = vec2(ellipsoid(pos - vec3(0.0, 0.21, -0.075) + offset, scaling * vec3(0.3, 0.21, 0.3)), mat_id_belly);\n\tdist_belly = smin_op(dist_belly, vec2(ellipsoid(pos - vec3(0.0, 0.34, 0.0) + offset, scaling * 0.2475), mat_id_belly));\n    dist_belly = smin_op(dist_belly, vec2(ellipsoid(pos - vec3(0.0, 0.26, 0.0) + offset, scaling * 0.26), mat_id_belly));\n    dist_belly = smin_op(dist_belly, vec2(ellipsoid(pos - vec3(0.0, 0.21, -0.23) + offset, scaling * 0.155), mat_id_belly));\n    dist_belly = smin_op(dist_belly, vec2(ellipsoid(pos - vec3(0.0, 0.195, -0.35) + offset, scaling * 0.075), mat_id_belly));\n    \n    vec2 dist = min_op(dist_back, dist_belly);\n\n    return dist;\n}\n\nvec2 yoshi_shell(vec3 pos)\n{\n    vec2 mat_ids = vec2(4.0, 0.0);\n    vec2 dist = vec2(sphere(pos - vec3(0.0, 0.0, 0.0), 0.165), mat_ids.x);\n    dist = min_op(dist, vec2(sphere(pos - vec3(0.0, 0.0525, -0.055), 0.13), mat_ids.y));\n    \n    return dist;   \n}\n\nvec2 yoshi_foot(vec3 pos)\n{\n    vec2 mat_ids = vec2(6.0, 2.0);\n    vec2 dist = vec2(ellipsoid(pos - vec3(0.0, 0.02, 0.0), vec3(0.175, 0.12, 0.21)), mat_ids.x);\n    dist = min_op(dist, vec2(ellipsoid(pos - vec3(0.0, -0.015, 0.0), vec3(0.165, 0.09, 0.2)), mat_ids.y));\n\n\treturn dist;\n}\n\nvec2 yoshi_leg(vec3 pos)\n{\n    float mat_id = 1.0;\n    vec2 dist = vec2(ellipsoid(pos - vec3(0.0, -0.12, 0.0), vec3(0.08, 0.12, 0.1)), mat_id);    \n    \n    return dist;\n}\n\nvec2 yoshi_arm(vec3 pos)\n{\n    float mat_id = 1.0;    \n\tvec2 dist = vec2(ellipsoid(pos - vec3(0.0, -0.09, 0.0), vec3(0.0525, 0.09, 0.07)), mat_id);\n\tdist = smin_op(dist, vec2(ellipsoid(pos - vec3(0.0, -0.18, 0.0), vec3(0.06, 0.11, 0.09)), mat_id));\n\n\treturn dist;    \n}\n\nvec2 yoshi(vec3 pos)\n{\n    // Used for mirroring the eyes, feet, legs, and arms along the x-axis. Saves\n    // some SDF computations.\n    vec3 pos_sym_x = vec3(abs(pos.x), pos.y, pos.z);\n\n    vec2 dist = yoshi_head(pos - vec3(0.0, 0.71, 0.01));\n    dist = ssmin_op(dist, yoshi_eye(rotate_x(pos_sym_x - vec3(0.0, 0.9, 0.189), radians(12.0))));    \n    dist = ssmin_op(dist, yoshi_body(pos - vec3(0.0, 0.0, 0.0)));\n    dist = ssmin_op(dist, yoshi_shell(pos - vec3(0.0, 0.345, -0.23)));\n    dist = min_op(dist, yoshi_foot(rotate_x(pos_sym_x - vec3(0.2, 0.19, 0.36), radians(69.0))));\n    dist = ssmin_op(dist, yoshi_leg(rotate_x(rotate_y(pos_sym_x - vec3(0.25, 0.195, 0.07), 0.2), radians(69.0))));\n    dist = min_op(dist, yoshi_arm(rotate_x(rotate_z(pos_sym_x - vec3(0.15, 0.5, 0.05), -0.55), radians(21.0))));    \n    \n    return dist;\n}\n\nvec2 sdf(vec3 pos)\n{\n    // Yoshi\n    vec2 dist = yoshi(pos);\n\n    // Floor\n    float mat_id_floor = 3.0;\n    dist = min_op(dist, vec2(sphere(pos - vec3(0.0, -200.01, 0.0), 200.0), mat_id_floor));\n\n    return dist;\n}\n\nstruct FirstHitInfo {\n    vec3 pos;\n    int material_id;\n};\n\nbool raymarch(Ray ray, out FirstHitInfo hit_info)\n{\n    float tol = 0.0015; // surface intersection tolerance\n    const int max_num_steps = 130;\n    float max_depth = 25.0;\n    \n    // Raymarch through the signed distance field until a surface is hit\n    // or the ray is terminated    \n    vec3 pos = ray.origin;\n    float depth = 0.0;\n    bool hit = false;\n    for (int i = 0; i < max_num_steps; ++i) {\n        vec2 dist = sdf(pos);\n        if (dist.x < tol) {\n            hit_info.pos = pos;\n            hit_info.material_id = int(dist.y);\n         \thit = true;\n            break;\n        }\n\n     \tpos += ray.direction * dist.x;\n        depth += dist.x;\n\n        if (depth > max_depth) {\n         \tbreak;  \n        }\n    }\n\n    return hit;\n}\n\nvec3 get_gradient(vec3 pos)\n{\n    // Estimate SDF gradient with central differences \n    float delta = 0.005;\n    vec3 gradient = vec3(\n        sdf(pos + delta * vec3(1.0, 0.0, 0.0)).x -\n        sdf(pos + delta * vec3(-1.0, 0.0, 0.0)).x,\n        sdf(pos + delta * vec3(0.0, 1.0, 0.0)).x -\n        sdf(pos + delta * vec3(0.0, -1.0, 0.0)).x,\n        sdf(pos + delta * vec3(0.0, 0.0, 1.0)).x -\n        sdf(pos + delta * vec3(0.0, 0.0, -1.0)).x);\n\n    return gradient;\n}\n\nfloat cast_shadow_ray(vec3 pos, vec3 L)\n{\n    const float tol = 0.0015; // surface intersection tolerance\n    const int max_num_steps = 30;\n    float radius = 0.03;\n    float start_offset = 0.06;\n    \n    Ray ray;\n    ray.origin = pos;\n    ray.direction = L;\n\n    float t = start_offset;\n    float visibility = 1.0;\n    for (int i = 0; i < max_num_steps; ++i) {\n        float occluder_dist = max(0.0, sdf(ray.origin + t * ray.direction).x);\n        if (occluder_dist < radius) {\n        \tvisibility = min(visibility, clamp(occluder_dist / radius, 0.0, 1.0));\n        }\n\n        if (occluder_dist < tol) {\n           visibility = 0.0;\n           break;\n        }\n        \n\t\tt += occluder_dist;\n    }\n\n    return visibility;\n}\n\nfloat compute_ao(vec3 pos, vec3 N)\n{\n    const int max_num_steps = 6;\n    float base_step_size = 0.025;\n    \n    // Bias the AO ray direction slightly towards the sky\n    Ray ray;\n    ray.origin = pos;\n    ray.direction = normalize(mix(N, vec3(0.0, 1.0, 0.0), 0.2));\n\n    float t = base_step_size;\n    float occlusion = 1.0;\n    for (int i = 0; i < max_num_steps; ++i) {\n        float occluder_dist = max(0.0, sdf(ray.origin + t * ray.direction).x);\n        float occlusion_i = occluder_dist / t;\n\t    occlusion = mix(occlusion_i, occlusion, 0.8);\n        t *= 2.0;\n    }\n\n    return occlusion;\n}\n\n// Approximates one bounce of indirect diffuse illumination by assuming that the\n// occluded point is surrounded by surfaces that have similar base color and\n// reflect some of the incoming light, which will brighten and apply a color tint\n// on the monochrome AO value.\n//\n// Reference: A.J. Stewart, and M.S. Langer, \"Towards Accurate Recovery of Shape\n// from Shading under Diffuse Lighting\", TPAMI, 1997.\nvec3 ao_approx_one_bounce(float ao, vec3 base_color)\n{\n    return clamp(ao / (1.0 - 0.99 * base_color * (1.0 - ao)), 0.0, 1.0);\n}\n\nfloat diffuse_wrap(vec3 N, vec3 L, float wrap)\n{\n    return max(0.0, (dot(N, L) + wrap) / ((1.0 + wrap) * (1.0 + wrap)));\n}\n\nfloat specular_blinn_phong(vec3 N, vec3 H, float specular_power)\n{\n    return pow(max(0.0, dot(N, H)), specular_power) * (8.0 + specular_power) / 8.0;\n}\n\nfloat specular_power_from_gloss(float gloss)\n{\n    return pow(2.0, 10.0 * gloss + 1.0);\n}\n\nvec3 fresnel_schlick(vec3 R_F0, vec3 E, vec3 H)\n{\n    return R_F0 + (1.0 - R_F0) * pow(1.0 - max(0.0, dot(E, H)), 5.0);\n}\n\nvec3 fresnel_schlick_gloss(vec3 R_F0, vec3 E, vec3 N, float gloss)\n{\n    return R_F0 + (max(vec3(gloss), R_F0) - R_F0) * pow(1.0 - max(0.0, dot(E, N)), 5.0);\n}\n\nvec3 hemisphere_diffuse(HemisphereLight light, vec3 N)\n{\n    return mix(light.ground_color, light.sky_color,\n               0.5 * dot(N, light.up) + 0.5) * light.intensity;\n}\n\nvec3 hemisphere_specular(HemisphereLight light, vec3 R, float gloss)\n{\n    float g = min(0.975, gloss);\n    float alpha = clamp(dot(R, light.up) / (1.0 - g * g), 0.0, 1.0);\n    return mix(light.ground_color, light.sky_color, alpha) * light.intensity;\n}\n\nvec3 rim_lighting(RimLight light, vec3 N, vec3 V)\n{\n    return light.color * light.intensity * pow(1.0 - max(0.0, dot(N, V)), 3.0);\n}\n\nvec3 compute_shading(vec3 pos, vec3 N, vec3 V, Material material, DirectionalLight key_light,\n                     HemisphereLight sky_light, RimLight rim_light)\n{\n    vec3 L = -normalize(key_light.direction);\n    vec3 H = normalize_safe(L + V);\n    vec3 R = normalize(reflect(-V, N));\n\n    float visibility = cast_shadow_ray(pos, L);\n    float occlusion = compute_ao(pos, N);\n    vec3 diffuse_occlusion = ao_approx_one_bounce(occlusion, material.base_color);\n    float specular_occlusion = occlusion;\n\n    vec3 diffuse_color = mix(material.base_color, vec3(0.0), material.metalness);\n    vec3 specular_color = mix(vec3(0.04), material.base_color, material.metalness);\n    float specular_power = specular_power_from_gloss(material.gloss);    \n    vec3 F0 = specular_color;\n    vec3 F = fresnel_schlick_gloss(specular_color, N, V, material.gloss);\n\n    vec3 key_light_color = key_light.color * key_light.intensity;\n\n    // Diffuse lighting\n    vec3 output_color = vec3(0.0);    \n    output_color += visibility * (1.0 - F0) * diffuse_color * diffuse_wrap(N, L, material.wrap) *\n                    key_light_color;\n    output_color += diffuse_occlusion * (1.0 - F) * diffuse_color * hemisphere_diffuse(sky_light, N);\n\n    // Specular lighting\n    output_color += visibility * specular_color * specular_blinn_phong(N, H, specular_power) *\n                    key_light_color;        \n    output_color += specular_occlusion * F * hemisphere_specular(sky_light, R, material.gloss);\n    \n    // Rim lighting\n    output_color += occlusion * material.rim * rim_lighting(rim_light, N, V);\n    \n    return output_color;\n}\n\nvec3 dither(vec2 screen_pos)\n{\n    float white_noise = fract(sin(dot(vec2(screen_pos), vec2(12.989, 78.233))) * 43758.545);\n    return vec3((0.5 * white_noise - 0.5) / 255.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Set up the camera\n    PerspectiveCamera camera;\n    camera.eye = vec3(2.7, 0.6, 0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    camera.center = vec3(0.0, 0.5, 0.0);\n    camera.fovy = radians(30.0);\n    camera.aspect = iResolution.x / iResolution.y;\n\n    // Apply mouse rotation onto the camera\n    float angle_rad = iMouse.z > 0.0 ? -2.0 * PI * (iMouse.x - iMouse.z) / iResolution.x : 0.0;\n    camera.eye = rotate_y(camera.eye - camera.center, angle_rad) + camera.center;\n\n    // Define materials\n    // Parameters: base_color, metalness, gloss, wrap, rim\n\tMaterial materials[7];\n    materials[0] = Material(srgb2lin(vec3(0.9, 0.1, 0.1)), 0.0, 0.4, 0.2, 1.0);\n    materials[1] = Material(srgb2lin(SETTINGS_YOSHI_COLOR), 0.0, 0.4, 0.2, 1.0);    \n    materials[2] = Material(srgb2lin(vec3(0.9, 0.8, 0.25)), 0.0, 0.4, 0.2, 1.0);\n    materials[3] = Material(srgb2lin(vec3(0.7, 0.7, 0.7)), 0.0, 0.3, 0.0, 0.0);\n    materials[4] = Material(srgb2lin(vec3(0.9, 0.9, 0.9)), 0.0, 0.4, 0.2, 1.0);\n    materials[5] = Material(srgb2lin(vec3(0.2, 0.2, 0.2)), 0.0, 0.8, 0.2, 0.0);\n\tmaterials[6] = Material(srgb2lin(vec3(0.9, 0.4, 0.1)), 0.0, 0.4, 0.2, 1.0);\n    \n    // Set up light sources\n    DirectionalLight key_light;\n    key_light.direction = normalize(vec3(-1.0, -1.0, -1.0));\n    key_light.color = srgb2lin(vec3(1.0, 1.0, 1.0));\n    key_light.intensity = SETTINGS_KEY_LIGHT_INTENSITY;\n\n    HemisphereLight sky_light;\n    sky_light.up = vec3(0.0, 1.0, 0.0);\n    sky_light.sky_color = srgb2lin(vec3(0.9, 0.9, 0.9));\n    sky_light.ground_color = srgb2lin(vec3(0.2, 0.2, 0.2));\n    sky_light.intensity = SETTINGS_SKY_LIGHT_INTENSITY;\n    \n    RimLight rim_light;\n    rim_light.color = vec3(1.0, 1.0, 1.0);\n    rim_light.intensity = SETTINGS_RIM_LIGHT_INTENSITY;\n\n    vec3 output_color = vec3(0.0);\n    for (int i = 0; i < SETTINGS_SPP; ++i) {\n        // Calculate subpixel offset for anti-aliasing\n        vec2 aa_offset = (ldseq_r2(i + 1) - 0.5) / iResolution.xy;\n\n        // Generate camera ray\n        Ray ray = get_camera_ray(camera, uv + aa_offset);\n\n        // Find the closest surface intersection point by raymarching\n        FirstHitInfo hit_info;\n        bool hit = raymarch(ray, hit_info);\n    \n        // Apply shading\n        if (hit) {\n            Material material = materials[hit_info.material_id];        \n            vec3 V = -ray.direction;        \n            vec3 N = normalize_safe(get_gradient(hit_info.pos));\n            N = dot(N, V) < 0.0 ? -N : N;\n            output_color +=\n                compute_shading(hit_info.pos, N, V, material, key_light, sky_light, rim_light);\n        }\n        else {\n            output_color += hemisphere_diffuse(sky_light, ray.direction);\n        }\n    }\n    output_color /= float(SETTINGS_SPP);\n\n    // Apply gamma correction. The scene has fairly low dynamic range, so no\n    // tone mapping is required.\n    output_color *= SETTINGS_EXPOSURE;\n    output_color = lin2srgb(output_color);\n    \n    // Apply dithering, to reduce color banding\n    output_color += dither(fragCoord.xy);\n    output_color = clamp(output_color, 0.0, 1.0);\n\n\tfragColor = vec4(output_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}