{"ver":"0.1","info":{"id":"NltyD7","date":"1659951391","viewed":92,"name":"Equirectangular area of viewport","username":"mkael5k","description":"Shows which part of equirectangular texturemap is used when looking to certain direction.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["equirectangularprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Simulate part of needed equirectangular 360 image for given fov and viewport\n */\n\nfloat yaw = .0;\nfloat pitch = .0;\nfloat roll = .0;\nfloat fovWidth = .0;\nfloat fovHeight = .0;\n\n// inverse rotation trasformation from angles\nmat4x4 rotationMatrixFromEuler(vec3 vDegrees, bool inverse)\n{\n    vec3 v = radians(vDegrees);\n\n    float sx, cx;\n    float sy, cy;\n    float sz, cz;\n\n    sx = sin(v.x);\n    cx = cos(v.x);\n    \n    sy = sin(v.y);\n    cy = cos(v.y);\n    \n    sz = sin(v.z);\n    cz = cos(v.z);\n\n    vec3 row1 = vec3(sx * sy * sz + cy * cz, sx * sy * cz - cy * sz, cx * sy);\n    vec3 row3 = vec3(sx * cy * sz - sy * cz, sx * cy * cz + sy * sz, cx * cy);\n    vec3 row2 = vec3(cx * sz, cx * cz, -sx);\n\n    mat3x3 rotationMatrix = mat3x3(row1, row2, row3);\n\n    // special case for pure 3x3 rotation matrix transpose give inverted matrix\n    mat3x3 finalRotation = inverse ? transpose(rotationMatrix) : rotationMatrix;\n\n    return mat4x4(\n        vec4(finalRotation[0], 0),\n        vec4(finalRotation[1], 0),\n        vec4(finalRotation[2], 0),\n        vec4(0,0,0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // TODO: resolve if projected pixel is inside fov of the viewport\n    \n    // TODO: so basically calculate x,y degrees of each pixel and then inverse transform its position to view direction and then check\n    //       if degrees are inside +-fovWidth/2 and +-fovHeight/2 then output the color for pixel\n\n    if (uv.x > 0.5) {\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}