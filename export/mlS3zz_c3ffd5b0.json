{"ver":"0.1","info":{"id":"mlS3zz","date":"1672748226","viewed":138,"name":"Water drop function","username":"mmartosdev","description":"Mimic water drop effect.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","splot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define GAMMA 1\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n         p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nvec2 opI(vec2 d1, vec2 d2)\n{\n\treturn (d1.x > d2.x) ? d1 : d2;\n}\n\n// Ref: https://iquilezles.org/articles/distfunctions/\nvec2 opS(vec2 d1, vec2 d2)\n{\n\treturn (d1.x > -d2.x) ? d1 : vec2(-d2.x,d2.y);\n}\n\nfloat evalDT(in float d)\n{\n    return -4.0 * pow(d, 6.0) \n          +12.0 * pow(d, 5.0) \n           -9.0 * pow(d, 4.0)\n           -2.0 * pow(d, 3.0)\n           +3.0 * d*d;\n}\n\nfloat evalFunction(in vec3 p)\n{\n    float d = length(p.xz);\n    float dt = evalDT(clamp(4.0*d-mod(iTime,6.0)+1.0, 0.0, 1.0));\n    return 0.0125 * dt * exp(-d*d)*sin(256.0*d-12.0*iTime);\n}\n\nfloat sdFunction(in vec3 p, in float th)\n{\n    float f = evalFunction(p);\n    return min(abs(p.y - f)-th, 30.0);\n}\n\nvec2 sdFunction(in vec3 pos, in vec3 center, float thickness) \n{\n    vec2 res = vec2( 100.0, 0.0 );\n    vec3 ts = center;\n    vec3 bs = vec3(1.0,20.0,1.0);\n    res = opU(res, vec2(sdFunction(pos - ts,thickness), 2.0));\n    res = opI(res, vec2(sdBox     (pos - center, bs),   2.0));\n    return res;\n}\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 100.0, 0.0 );\n\n    res = opU(res, sdFunction(pos, vec3(0), 0.005));\n    res = opU(res, vec2(sdBoxFrame(pos-vec3(0.0,0.5,0.0), vec3(1.0, 0.5, 1.0), 0.001), 1.0));\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 50.0;\n\n    // raymarch primitives   \n    float t = tmin;\n    for (int i = 0; i < 250 && t < tmax; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        if (abs(h.x) < (0.0001*t))\n        { \n            res = vec2(t,h.y);\n            break;\n        }\n        t += 0.5*h.x;\n    }\n    \n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(1.0);\n    \n    vec2 res = rayCast(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m > -0.5)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(2.0);\n        if (m < 1.5) {\n            mate = vec3(0.0);\n        } else if (m < 2.5) {            \n            mate = vec3(112.0/255.0, 200.0/255.0, 228.0/255.0);\n            mate = mix(mate, vec3(192.0/255.0,  78.0/255.0, 255.0/255.0), abs(dot(vec3(1.0,0.0,0.0),nor)));\n            mate = mix(mate, vec3(255.0/255.0, 224.0/255.0, 178.0/255.0), abs(dot(vec3(0.0,0.0,1.0),nor)));\n            mate = mate * \n                (1.0 - step(-0.005,mod(pos.x+0.0025, 0.1)) * step(mod(pos.x+0.0025, 0.1),0.005)) * \n                (1.0 - step(-0.005,mod(pos.z+0.0025, 0.1)) * step(mod(pos.z+0.0025, 0.1),0.005));\n        }\n        col  = mate;\n    }\n\treturn col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = normalize(vec3(sin(cr), cos(cr), 0.0));\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup viewport coordinates: -0.5, -0.5 to 0.5, 0.5\n    float maxAxis = max(iResolution.x, iResolution.y);\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / maxAxis;\n    \n    // Define camera position\n    vec3 ta = vec3(0.0, 0.5, 0.0);\n    vec3 ro = ta + vec3(6.0*sin(-8.0*iMouse.x/maxAxis), 3.0, 6.0*cos(-8.0*iMouse.x/maxAxis));\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // Focal length\n    const float fl = 2.25;\n    \n    // Antialiasing rendering loop\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.5/(maxAxis*float(AA)), 0.5/(maxAxis*float(AA)));\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            vec3 rd = ca * normalize(vec3(vec2(p.x+float(m)*off.x,p.y+float(n)*off.y), fl));\n            col += render(ro, rd);\n        }\n    }\n    col /= float(AA * AA);\n    \n#if GAMMA == 1\n    // Gamma correction \n    col = pow(col, vec3(0.4545));\n#endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}