{"ver":"0.1","info":{"id":"NdKSRG","date":"1635236027","viewed":75,"name":"Accumulated Dithering","username":"szali","description":"Let's see how dithering based on different noise performs with accumulation","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["noise","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2)); // approximate SRGB conversion\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAGNIFICATION 3\n\n#define FIXED_CUTOFF 0.4\n#ifndef FIXED_CUTOFF\n    #define CUTOFF_ANIMATE_SPEED 0.2\n#endif\n\n#define ANIMATE_PATTERN\n\n#define TEMPORAL_ACCUMULATION\n#ifdef TEMPORAL_ACCUMULATION\n    #define HISTORY_WEIGHT 0.96\n    #define ACCUMULATE_OVER 1\n#else\n    #define ACCUMULATE_OVER 16\n#endif\n\n// For golden ratio animation, see \"Integration Over Time\" section of: https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\nconst float GOLDEN_RATIO_FRAC = 0.61803398875;\n\n//  55 * 0.61803398875 = 33.991869381250005 -> first multiple of the Golden Ratio closer to an integer than 0.01,  maybe a good place to wrap back to zero\n// 610 * 0.61803398875 = 377.00073313750005 -> first multiple of the Golden Ratio closer to an integer than 0.001, maybe a good place to wrap back to zero\nconst int GOLDEN_RATIO_FRAME_MOD = 610;\n\nfloat GetIGNoise(vec2 pos, int frame)\n{\n    frame %= GOLDEN_RATIO_FRAME_MOD;\n\n    //For PHI2 constant derivation, see dithering section of: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\tconst float PHI2 = 1.324717957;\n    float noise = dot(pos, 1.0 / vec2(PHI2, PHI2*PHI2));\n\n    return fract(GOLDEN_RATIO_FRAC * float(frame) + noise);\n}\n\n//https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat GetIGNoise2(vec2 pos, int frame)\n{\n    frame = frame % 64; // need to periodically reset frame to avoid numerical issues\n    pos += 5.588238f * float(frame);\n    return fract(52.9829189f * fract(0.06711056f * pos.x + 0.00583715f * pos.y));\n}\n\nfloat GetBlueNoise(vec2 pos, int frame)\n{\n    frame %= GOLDEN_RATIO_FRAME_MOD;\n\n    const float BLUE_NOISE_SCALE = 1.0;\n    vec2 uv = (pos + 0.5) / (iChannelResolution[1].xy * BLUE_NOISE_SCALE);\n    float noise = texture(iChannel1,  uv).r;\n    return fract(GOLDEN_RATIO_FRAC * float(frame) + noise);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef TEMPORAL_ACCUMULATION\n        vec2 historyUv = fragCoord / iResolution.xy;\n    #endif\n\n    fragCoord = floor(fragCoord); // By default ShaderToy aims at pixel center with these coords, let's floor them to get integer pixel coords\n    fragCoord.y = (iResolution.y - 1.0) - fragCoord.y; // To mimic DirectX UVs ((0,0) at the top left)\n    \n    #ifdef FIXED_CUTOFF\n        float cutoff = FIXED_CUTOFF;\n    #else\n        float cutoff = fract(iTime * CUTOFF_ANIMATE_SPEED);\n    #endif\n\n    float value;\n    if (fragCoord.x < iResolution.x * (3.0/4.0))\n    {\n        float sum = 0.0;\n        for (int i = 0; i < ACCUMULATE_OVER; i++)\n        {\n            vec2 coords = vec2(ivec2(fragCoord) / MAGNIFICATION);\n\n            #ifdef ANIMATE_PATTERN\n                int offset = iFrame;\n            #else\n                int offset = 0;\n            #endif\n            offset += i;\n\n            float dither;\n            if (fragCoord.x < iResolution.x * (1.0/4.0))\n                dither = GetIGNoise(coords, offset);\n            else if (fragCoord.x < iResolution.x * (2.0/4.0))\n                dither = GetIGNoise2(coords, offset);\n            else\n                dither = GetBlueNoise(coords, offset);\n\n            value += dither < cutoff ? 1.0 : 0.0;\n        }\n        value /= float(ACCUMULATE_OVER);\n        \n        #ifdef TEMPORAL_ACCUMULATION\n            float history = texture(iChannel0, historyUv).r;\n            value = mix(value, history, HISTORY_WEIGHT);\n        #endif\n    }\n    else\n    {\n        value = cutoff;        \n    }\n\n    fragColor = vec4(value, value, value, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}