{"ver":"0.1","info":{"id":"ddcXRN","date":"1679455826","viewed":408,"name":"post processing lens flare","username":"Swifter","description":"drag ur mouse around on the screen","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pretty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// USING https://www.shadertoy.com/view/4d2Xzw FOR BOKEH\n \n// Controls randomness\nconst int seed = 7;\n// Amount of circles in flare\nconst int circles = 20;\n// Max size of circles\nconst float circleSize = 1. / 10.;\n// Outside color\nconst vec3 col1 = vec3(0.2,0.1,0.0);\n// Inside color\nconst vec3 col2 = vec3(0.9,1.,1.);\n// Percentage of screen toward the center to start fading out circles\nconst float fadeRadius = 0.7;\n// Overall circle opacity multiplier\nconst float overallOpacity = 5.;\n// Iterations for bokeh blur\nconst int bokehIterations = 5;\n// Radius for bokeh blur\nconst float bokehRadius = 0.4;\n\nfloat easeOutQuad(float x) {\n    return x * x;\n}\n\nfloat random(float seed) {\n    return fract(sin(seed) * 100000.0);\n}\n\nfloat getPointDist(vec2 point1, vec2 point2) {\n    float x = point2.x - point1.x;\n    float y = point2.y - point1.y;\n    return length(vec2(x, y));\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + (b - a) * t;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t) {\n    return vec3(\n        lerp(a.x, b.x, t),\n        lerp(a.y, b.y, t),\n        lerp(a.z, b.z, t)\n    );\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 drawRainbowCircle(vec2 circlePos, vec2 pixelPos, float radius) {\n    float dist = getPointDist(circlePos, pixelPos) / radius;\n    if (dist > 1.) return vec3(0,0,0);\n    \n    float colorMul = (dist - 0.4) / (dist + 1.);\n    vec3 col = hsv2rgb(vec3(colorMul * 8., 0.5, 1));\n    col *= colorMul;\n    col = max(col, 0.);\n    if (dist > 0.5) col *= 1. - dist;\n    \n    return col;\n}\n\nvec3 drawCircle(vec2 circlePos, vec2 pixelPos, float radius, float falloff, vec3 startColor, vec3 endColor) {\n    float dist = getPointDist(circlePos, pixelPos) / radius;\n    if (dist > 1.) return vec3(0,0,0);\n    \n    float colorMul = (dist - falloff) / (dist + 1.);\n    vec3 col = lerp(startColor, endColor, colorMul);\n    col *= colorMul;\n    col = max(col, 0.);\n    \n    return col;\n}\n\nvec2 getFlarePoint(vec2 centerPos, vec2 centerVec, float position) {\n    vec2 delta = centerVec * position;\n    delta += centerPos;\n    return delta;\n}\n\nfloat angleBetween(vec2 v1, vec2 v2) {\n    return acos(dot(v1, v2) / (length(v1) * length(v2)));\n}\n\n#define GOLDEN_ANGLE 2.3999632\n#define BLUR 1.\n#define PI 3.14159265359 \n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.x;\n    vec3 col = vec3(0,0,0);\n    \n    vec2 mousePos = iResolution.xy / 2.;\n    vec2 centerPos = iMouse.xy;\n    vec2 centerVec = (mousePos - centerPos) * 2.;\n    float centerVecLength = length(centerVec);\n    vec2 flareEnd = mousePos + centerVec;\n    \n    float centerProximity = centerVecLength / 170.;\n    if (centerProximity < 1.) centerProximity = 1.;\n    \n    float opacityMul = centerVecLength / iResolution.x / fadeRadius;\n    if (opacityMul > 1.) opacityMul = 1.;\n    opacityMul = 1. - easeOutQuad(1. - opacityMul);\n    \n    float circleOpacityMul = centerVecLength / iResolution.x / 0.2;\n    if (circleOpacityMul > 1.) circleOpacityMul = 1.;\n    \n    vec3 acc = vec3(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,bokehRadius*.01 / sqrt(float(bokehIterations)));\n    \n\tfor (int j = 0; j < bokehIterations; j++)\n    {  \n\t    vangle = rot * vangle;\n        vec2 pixelPos = (uv + (BLUR) * vangle) * iResolution.x;\n        \n        float baseRadius = (1. - circleOpacityMul) / 4. + 3. / 4.;\n        float circleBoost = 1. + (1. - circleOpacityMul) * 0.1;\n        col = drawCircle(getFlarePoint(centerPos, centerVec, 0.), pixelPos, iResolution.x / 1.5 * baseRadius, circleBoost, vec3(0,0,0), vec3(1,1,1));\n    \n        for (int i = 0; i < circles; i++) {\n            float newSeed = float(seed) / (float(i) + 10.);\n            float pos = random(newSeed);\n            float dist = 1. - pos;\n            float radius = iResolution.x * circleSize * random(newSeed * 2.) * dist;\n            float falloff = 0.35 + random(newSeed * 3.) * 0.5;\n            float opacity = (0.8 + random(newSeed * 4.) * 0.2) * opacityMul * overallOpacity;\n            opacity *= dist;\n            \n            vec2 flarePoint = getFlarePoint(centerPos, centerVec, pos);\n            vec2 pointToFlare = flarePoint - pixelPos;\n            float angle = angleBetween(pointToFlare, centerVec) / PI;\n            angle = easeOutQuad(angle);\n            angle = clamp(angle, 0., 1.);\n            opacity *= angle;\n            opacity /= centerProximity;\n        \n            col += drawCircle(flarePoint, pixelPos, radius, falloff, col1, col2) * opacity;\n        }\n        \n        vec2 flarePoint = getFlarePoint(centerPos, centerVec, 0.25);\n        vec2 pointToFlare = flarePoint - pixelPos;\n        float angle = angleBetween(pointToFlare, centerVec) / PI;\n        angle = easeOutQuad(easeOutQuad(angle));\n        angle = clamp(angle, 0., 1.);\n        angle = lerp(1., angle, opacityMul);\n        float opacity = angle * 1.5;\n        opacity /= centerProximity / 1.5;\n        col += drawRainbowCircle(flarePoint, pixelPos, iResolution.x / 5.) * opacity;\n        \n        vec2 distToCenter = pixelPos - centerPos;\n        float res = iResolution.x / 80.;\n        opacity = (1. - opacityMul) * 0.9 + 0.1;\n        \n        float dist = 1. - (abs(distToCenter.x / 16.) + abs(distToCenter.y * 4.)) / res;\n        col += max(dist, 0.) * 0.3 * opacity;\n       \n        dist = 1. - (abs(distToCenter.x * 4.) + abs(distToCenter.y / 16.)) / res;\n        col += max(dist, 0.) * 0.3 * opacity;\n        \n        res = iResolution.x / 80.;\n        \n        dist = 1. - (abs(distToCenter.x / 9.) + abs(distToCenter.y)) / res;\n        col += max(dist, 0.) * 0.3 * opacity;\n       \n        dist = 1. - (abs(distToCenter.x) + abs(distToCenter.y / 9.)) / res;\n        col += max(dist, 0.) * 0.3 * opacity;\n        \n        \n\t\tvec3 bokeh = pow(col, vec3(4));\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\n    fragColor = vec4(acc / div, 1.0);\n}","name":"Image","description":"","type":"image"}]}