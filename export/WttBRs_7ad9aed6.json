{"ver":"0.1","info":{"id":"WttBRs","date":"1613274580","viewed":274,"name":"Simple Beating Heart SDF - exact","username":"lumic","description":"Simple Heart from circular arcs.\n\nImproved version of the following, but uses exact SDFs (since subtraction doesn't yield exact SDFs)\nhttps://www.shadertoy.com/profile?show=shaders","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","heart"],"hasliked":0,"parentid":"3l3BRl","parentname":"Simple Heart SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float TWOPI = 6.28318530718;\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nfloat sdCircle(vec2 p, vec2 center, float r)\n{\n    return length(p - center) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdBox(vec2 p, vec2 bottomLeft, vec2 topRight)\n{\n    vec2 center = 0.5 * (bottomLeft + topRight);\n    vec2 extents = 0.5 * (topRight - bottomLeft);\n    vec2 d = abs(p -  center) - extents;\n    return length(max(d, vec2(0, 0))) + min(max(d.x, d.y), 0.0);\n}\n\n\n// From: https://iquilezles.org/articles/distfunctions2d\n// https://www.shadertoy.com/view/wl23RK\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p, scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    float radians = angle + deg / 360.0 * (2.0 * PI);\n    return vec2(r * cos(radians), r * sin(radians));\n}\n\nfloat combine( float d1, float d2 ) { return min(d1,d2); }\nfloat difference( float d1, float d2 ) { return max(d1,-d2); }\nfloat intersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat timeFactor(float scale) {\n   // sinusoidal, with a short pause at start/end\n   float overshoot = 1.5;\n   float t = iTime * scale; // scale time here\n   float a = clamp((mod(t, 2.0) - 1.0) * overshoot, -1.0, 1.0);\n   return sin(a * PI);\n}\n\nfloat getUpperRadius() {\n    return 0.15 + timeFactor(1.5) * 0.05;\n}\n\nfloat getLowerRadius() {\n    return 0.5 + timeFactor(1.5) * 0.15;\n}\n\n\n// This SDF is only exact on the outside\n// This is used to classify interior/exterior, and the actual distance is computed from the outline SDF \"heartOutline\"\nfloat heart(vec2 p) {\n    float rUpper = getUpperRadius();\n    float rLower = getLowerRadius();\n\n    // Mirror -x half plane into +x\n    p.x =  -abs(p.x);\n    \n    float upperHalf =  sdCircle(p, vec2(-rUpper,0), rUpper);\n    \n    // Flip this lower half pie\n    vec2 flipped = vec2(p.x, -p.y);\n    float lowerHalf = sdPie(flipped + vec2(rUpper * 2.0 - rLower, 0), vec2(sin(PI/2.0), cos(PI/2.0)), rLower);\n    \n    float combined = combine(upperHalf, lowerHalf);\n    \n    return combined;\n}\n\n// This SDF is exact, and doesn't have inside or outside (since the thickness of arc is 0)\nfloat heartOutline(vec2 p) {\n    float rUpper = getUpperRadius();\n    float rLower = getLowerRadius();\n\n    \n    float upperAngle = PI / 2.0;\n    float upperHalf =  sdArc(p - vec2(-rUpper,0), vec2(sin(upperAngle), cos(upperAngle)), vec2(sin(upperAngle), cos(upperAngle)), rUpper, 0.0);\n    float upperHalf2 =  sdArc(p + vec2(-rUpper,0), vec2(sin(upperAngle), cos(upperAngle)), vec2(sin(upperAngle), cos(upperAngle)), rUpper, 0.0);\n    \n    // TODO determine if P is on the \"inner side\" of the arcs? Without relying on the second SDF hack\n    \n    //float lowerAngleOrientation = PI / 4.0;\n    float lowerAngleAperture = acos((rLower - 2.0 * rUpper) / rLower) * 0.5;\n    float lowerAngleOrientation = -PI / 2.0 + (PI / 2.0 - lowerAngleAperture);\n    \n    float lowerHalf = sdArc(\n        p - vec2(-rUpper * 2.0 + rLower, 0),\n        vec2(sin(lowerAngleOrientation), cos(lowerAngleOrientation)),\n        vec2(sin(lowerAngleAperture), cos(lowerAngleAperture)),\n        rLower,\n        0.0);\n    \n    float lowerHalf2 = sdArc(\n        p - vec2(rUpper * 2.0 - rLower, 0),\n        vec2(sin(lowerAngleOrientation), -cos(lowerAngleOrientation)),\n        vec2(sin(lowerAngleAperture), cos(lowerAngleAperture)),\n        rLower,\n        0.0);\n    \n    float combined = combine(upperHalf2, upperHalf);\n    combined = combine(combined, lowerHalf);\n    combined = combine(combined, lowerHalf2);\n    \n    return combined;\n}\n\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = 0.0f;\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n    vec2 rd = normalize(-ro);\n\n    vec2 p = (uv - vec2(0, 0.15)) * 1.25;\n\n    // correct but has no interior\n    float correctAbsD = heartOutline(p);\n    \n    // Only correct on the exterior\n    float d = heart(p);\n    \n    if (d < 0.0) {\n        // Comment this line to see incorrect interior distance\n        d = -correctAbsD;\n    }\n      \n    // coloring\n    float isocontours = smoothstep(0.8, 0.9, cos(150.0*abs(d))) * 3.0;\n    \n    vec3 col = (d<0.0) ? vec3(0.6,0.3,1.0) : vec3(0.2,0.4,0.8);\n    col *= 1.0 - exp(-9.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n    col *= 1.0 + 0.25 * isocontours;\n\n    fragColor.rgb = col;\n    fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}