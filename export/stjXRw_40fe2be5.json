{"ver":"0.1","info":{"id":"stjXRw","date":"1627356602","viewed":212,"name":"ray ellipse intersection","username":"Envy24","description":"ray ellipse intersection","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","intersection","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932\n#define TAU 6.2831853071795862 // 2*PI\n#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n#define R iResolution\n\nfloat shootRayInEllipse(\n    vec3 ray,\n    vec3 dir,\n    vec3 C,  // ellipse center\n    float r, // radius\n    float m, // vertical parameter\n    float n) // depth parameter\n{\n    vec3 tmp = ray - C; // ray coords relative to ellipse center\n    \n    float mm = m * m;\n    float nn = n * n;\n    \n    float a = dir.x * dir.x + mm * dir.y * dir.y + nn * dir.z * dir.z;\n    float b = 2.0 * (tmp.x * dir.x + mm * tmp.y * dir.y + nn * tmp.z * dir.z);\n    float c = tmp.x * tmp.x + mm * tmp.y * tmp.y + nn * tmp.z * tmp.z - r * r;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float root = (-b - e) / (2.0 * a);\n\n    if (root >= 0.0) { return root; }\n\n    root = (-b + e) / (2.0 * a);\n\n    if (root >= 0.0) { return root; }\n    \n    return -1.0;\n}\n\n\n/*\n    branchless\n*/\nfloat shootRayInEllipse2(\n    vec3 ray,\n    vec3 dir,\n    vec3 C,  // ellipse center\n    float r, // radius\n    float m, // vertical parameter\n    float n) // depth parameter\n{\n    vec3 tmp = ray - C; // ray coords relative to ellipse center\n    \n    float mm = m * m;\n    float nn = n * n;\n    \n    float a = dir.x * dir.x + mm * dir.y * dir.y + nn * dir.z * dir.z;\n    float half_b = (tmp.x * dir.x + mm * tmp.y * dir.y + nn * tmp.z * dir.z);\n    float c = tmp.x * tmp.x + mm * tmp.y * tmp.y + nn * tmp.z * tmp.z - r * r;\n    \n    float sqrtDiscriminant = sqrt(half_b * half_b - a * c);\n    \n    float root0 = (-half_b - sqrtDiscriminant) / a;\n    float root1 = (-half_b + sqrtDiscriminant) / a;\n    \n    return \n        sqrtDiscriminant < 0.0 ? // any real roots?\n            -1.0 : // no hit\n            root0 >= 0.0 ? // min root is pass?\n                root0 :\n                root1 >= 0.0 ? // max root is pass?\n                    root1 :\n                        -1.0; // no hit\n}\n\n/*\n    from wikipedia.\n*/\nvec2 sphericalUV(vec3 HPN  /* hit point normal */)\n{\n    return vec2(\n        0.5 + atan(HPN.x, HPN.z) / TAU,\n        //0.5 - asin(HPN.y) / PI);\n        0.5 - asin(-HPN.y) / PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    camera = rotateAroundY(camera, iTime);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n\n\n    /* Ellipse */\n    vec3 ellipse = vec3(0.0, 0.0, -1.0);\n    float radius = 0.8;\n    float m = 0.1 + (1.0 + sin(iTime));\n    float n = 0.1 + (1.0 + cos(iTime * 0.6));\n    //float m = 0.5;\n    //float n = 0.8;\n    /* Ellipse */\n\n\n    /* Rotation */\n    ellipse = rotateAroundX(ellipse, iTime);   \n    ellipse = rotateAroundY(ellipse, iTime * 0.6);\n    ellipse = rotateAroundZ(ellipse, iTime * 0.3);\n    /* Rotation */\n\n\n    /* Ray tracing */\n    float t = shootRayInEllipse2(ray, rayDir, ellipse, radius, m, n);\n    /* Ray tracing */\n    \n    \n    /* Shading */\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    if (t >= 0.0) // hit ?\n    {\n        vec3 HP = ray + rayDir * t;\n        vec3 HPN = normalize(HP - ellipse);\n        vec2 UV = sphericalUV(HPN);\n        \n        /* uv as color *\n        color.x = UV.x;\n        color.y = UV.x;\n        /* uv as color */\n        \n        color = texture(iChannel1, UV);\n    }\n    else { color = BACKGROUND; }\n    /* Shading */\n\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}","name":"Common","description":"","type":"common"}]}