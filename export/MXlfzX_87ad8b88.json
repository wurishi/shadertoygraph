{"ver":"0.1","info":{"id":"MXlfzX","date":"1728730235","viewed":65,"name":"sponge spherigal menger","username":"nayk","description":"originals ","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractal","menger","spherical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuniform vec2 resolution;\nuniform float time;\n#define time iTime\n#define resolution iResolution.xy\n#define MAX_DIST    80.\n\n#define PI          3.1415926\n#define PI2         6.2831853\n#define R           resolution\n#define T           time\n#define S           smoothstep\n#define M           vec4(0.0)\n#define hue(a) .45 + .42*cos(1.42*a + vec3(.25,.75,1.25));\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 get_mouse( vec3 ro ) {\n    float x = M.xy==vec2(0) ? -.6 : -(M.y / R.y * 1. - .5) * PI;\n    float y = M.xy==vec2(0) ? .9 : (M.x / R.x * 2. - 1.) * PI;\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    return ro;\n}\n// rotation speeds \nfloat ar = .3, br = .2, cr = .1;\n\n// offsets for fractal - \nfloat av = .14, bv = .45, cv = 4.5;\n\nfloat flods;\n#define n1Q(p) p *= 2.*ri(round(atan(p.x, p.y) * 4.) / 4.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\nvec3 fragtal(vec3 p, vec3 r, vec3 o) {\n  \tvec3 res =  vec3(1000.,0.,0.);\n\np.xy*=r2(iTime);\n    p = abs(p)-0.25;\n\n   p.xy*=r2(iTime);\n\n    float s=1.84;\n    float r2;\n        \nn1Q(p.xy);\n\n    for(int i=0;i<11;++i)\n    {\n    \n      p.xy-=.012;\n     \n      r2=2./clamp(dot(p,p),.1,1.);\n      p=abs(p)*abs(r2)-o;\n      s*=r2;\n    }\n\n    float d = length(p)/s;\n    \n    if(d<res.x) {\n    \tflods=log2(s*.00075);\n        res = vec3(d,1.,flods);\n    }\n\n    return res;\n}\n\n// make a map and repeat domain with slight\n// tweaks to the vec3 for the fractal\nvec3 map(vec3 p){\n    vec3 res =  vec3(1000.,0.,0.);\n\n    float k = 7.0/dot(p,p); \n    p *= k;\n     \n    vec3 q3 = p+vec3(0,1,0);\n\n    float fl =7.5, hf = fl*.5;\n    vec3 pi =  floor((p - hf)/fl);\n\n    // rotation and offset for fractals\n    // use ID of pi to change each rep\n    vec3 r = vec3(T+ar,T*br,T*cr);\n\tvec3 o = vec3(.45+.32*cos(T*.25),.25+.2*sin(T*.15),cv-1.35+1.3*sin(T*.25));\n    //vec3 o = vec3(av,bv,cv);\n    \n    vec3 d = fragtal(p,r,o);\n    if(d.x<res.x) {\n        res = d;\n    }\n\n    float mul = 1.0/k;\n    res.x *= mul / 1.35;\n    return res;\n}\n\nvec3 get_normal(in vec3 p, in float t) {\n    t *= .0005;\n    vec2 eps = vec2(t, 0.0);\n    vec3 n = vec3(\n        map(p+eps.xyy).x - map(p-eps.xyy).x,\n        map(p+eps.yxy).x - map(p-eps.yxy).x,\n        map(p+eps.yyx).x - map(p-eps.yyx).x);\n    return normalize(n);\n}\n\nvec3 ray_march( in vec3 ro, in vec3 rd, int maxstep ) {\n    float t = .0001;\n    vec2 m = vec2(0.);\n    float r = 0., w = 1., dt;\n    for( int i=0; i<128; i++ ) {\n        if (i >= maxstep) break;\n        vec3 p = ro + rd * t;\n        vec3 d = map(p);\n        if(d.x<.0005*t||t>MAX_DIST) break;\n        t += d.x;\n        m = d.yz;\n    }\n    return vec3(t,m);\n}\n\nfloat get_diff(vec3 p, vec3 lpos, vec3 n) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.),\n          shadow = ray_march(p + n * .001 * 2., l, 64).x;\n    if(shadow < length(p -  lpos)) dif *= .1;\n    return dif;\n}\n\nvec3 r( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 c = vec3(0.);\n    vec3 fadeColor =  hue(uv.y*3.);\n    vec3 ray = ray_march(ro, rd, 128);\n    float t = ray.x,\n          m = ray.y,\n          f = ray.z;\n    if(t<MAX_DIST) {\n        vec3 p = ro + t * rd,\n             n = get_normal(p, t);\n        vec3 color1 = hue(4.7);\n        vec3 color2 = hue(16.5);\n        // lighting and shade\n        vec3 lpos1 = vec3(-.2, 9.2, 8.5);\n        vec3 lpos2 = vec3(.0, 9.0, 9.0);\n        vec3 diff = color1 * get_diff(p,lpos1,n) +\n                    color2 * get_diff(p,lpos2,n);\n        //cheap fill light\n        vec3 sunlight = clamp(dot(n,vec3(1.,9.,9.)),.25 ,6.) *vec3(.35);\n       \n        //simple color\n        vec3 h = hue(f);\n\n        //mixdown\n        c += h * diff * sunlight; \n    } else {\n        c = fadeColor;\n    }\n    //fog @iq\n    c = mix( c, fadeColor, 1.-exp(-.0002*t*t*t));\n    return c;\n}\n\nfloat zoom = 5.25;\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    //uv coords\n    vec2 U = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    \n    //set origin and direction\n    vec3 ro = vec3(0.,0.,.1+zoom),\n         lp = vec3(0.,0.,0.);\n    \n\t//set camera view\n    vec3 cf = normalize(lp-ro),\n         cp = vec3(0.,1.,0.),\n         cr = normalize(cross(cp, cf)),\n         cu = normalize(cross(cf, cr)),\n         c = ro + cf * .85,\n         i = c + U.x * cr + U.y * cu,\n         rd = i-ro;\n\t//render\n    vec3 C = r(ro, rd, U);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}