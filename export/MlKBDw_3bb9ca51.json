{"ver":"0.1","info":{"id":"MlKBDw","date":"1542856376","viewed":381,"name":"Hilbert Tile Renderer","username":"oalpha","description":"Renders an image in tiles.  The image generated is a sphere with a voronoi bump map surrounded by other normal spheres.  The center sphere will remain in focus and the others are blurred based on the sensor and aperature sizes defined in common.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","voronoi","depth","hilbert","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ires = vec2(iResolution);\n    vec2 icoord = vec2(fragCoord);\n    \n    vec2 cellSize = ires / F_HILBERT_SIDE;\n    \n    ivec2 cell = ivec2(floor(icoord / cellSize));\n    vec2 cellCoord = icoord - vec2(cell) * cellSize;\n    \n    int F = iFrame + 1;\n    int rcell = iFrame / FRAMES_PER_CELL;\n    int rcellFrame = iFrame - rcell * FRAMES_PER_CELL;\n    int rcycle = rcell / HILBERT_CELLS;\n    rcell -= rcycle * HILBERT_CELLS;\n    \n    //rcell = 1;\n    ivec2 hcell = hilbert(rcell);\n    \n    if(length(vec2(hcell - cell)) < 0.5) {\n        vec2 a = abs(cellCoord - cellSize * .5);\n        vec3 inset = vec3(.1, .15, .2) * cellSize.x;\n        mat2 t = mat2(\n            cellSize * 0.5 - inset.y,\n            cellSize * 0.5 - inset.x\n        );\n        float edge = \n            max(step(t[0].x, a.x), step(t[0].y, a.y)) -\n            max(step(t[1].x, a.x), step(t[1].y, a.y));\n        edge = min(edge, min(\n            step(cellSize.x * 0.5 - inset.z, a.x),\n            step(cellSize.y * 0.5 - inset.z, a.y)\n        ));\n        //edge = 1.;\n\t    fragColor = mix(\n            texture(\n                iChannel2,\n                fragCoord / iResolution.xy\n            ),\n            vec4(1.),\n            edge\n        );\n    }\n    else\n\t    fragColor = texture(\n            iChannel2,\n            fragCoord / iResolution.xy\n        );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// sets the number of hilbert cells.\n// there will be HILBERT_LEVEL x HILBERT_LEVEL tiles\n#define HILBERT_LEVEL 3\n\n// defines how many frames will be drawn per cell per cycle\n#define FRAMES_PER_CELL 1\n\n// defines how many samples per tile\n// actual amount of samples per pixel is\n// SAMPLES * (4 ^ HILBERT_LEVEL)\n#define SAMPLES 1\n\n// sets the spacing between spheres\n#define CELL_WIDTH 10.\n\n// size of camera sensor\n// affects field of view: higher values -> greater field of view\n#define SENSOR_SIZE .1\n\n// distance from sensor to aperature\n// affects field of view: higher values -> smaller field of view\n#define SENSOR_DISTANCE .1\n\n// aperature size\n// affects blurring: higher values -> more blurring\n#define APERATURE_SIZE .1\n\n// uncomment for bicubin interpolation\n// Note: creates aliasing (albeit interesting looking aliasing)\n//#define BICUBIC\n\n// uncomment to view bump map\n//#define BUMPMAP_CHECK\n\n// uncomment to see each tile separately\n// Note: you should use this in combination with a hgigher\n//     FRAMES_PER_CELL to see each tile for longer\n//#define BUFFER_PASSTHROUGH\n\nconst float F_HILBERT_LEVEL = float(HILBERT_LEVEL);\nconst int HILBERT_SIDE = 1 << HILBERT_LEVEL;\nconst float F_HILBERT_SIDE = float(HILBERT_SIDE);\nconst int HILBERT_CELLS = 1 << (2 * HILBERT_LEVEL);\nconst float F_HILBERT_CELLS = float(HILBERT_CELLS);\nivec2 hilbert(int index) {\n    int i = 0;\n    vec2 p = vec2(0.5),\n        x = vec2(0.25, 0.0),\n        y = vec2(0.0, 0.25);\n    int f = int(pow(2.0, 2. * F_HILBERT_LEVEL));\n    while(i < HILBERT_LEVEL) {\n        f /= 4;\n        int q = index / f;\n        index -= q * f;\n        \n        p += q == 2 || q == 3 ? x : -x;\n        p += q == 1 || q == 2 ? y : -y;\n        if(q == 0) {\n            vec2 t = x;\n            x = y;\n            y = t;\n        }\n        if(q == 3) {\n            vec2 t = x;\n            x = -y;\n            y = -t;\n        }\n        x *= 0.5;\n        y *= 0.5;\n        \n        i++;\n    }\n    return ivec2(pow(2.0, F_HILBERT_LEVEL) * (p - pow(0.5, (F_HILBERT_LEVEL + 1.))));\n}\n\n#define PI  3.141592653589793238462643383279\n#define PI2 6.283185307179586476925286766559\n\n#define o1 0.0\n#define i1 1.0\n#define o2 o1, 0.0\n#define i2 i1, 0.0\n#define j2 o1, 1.0\n#define o3 o2, 0.0\n#define i3 i2, 0.0\n#define j3 j2, 0.0\n#define k3 o2, 1.0\n#define o4 o3, 0.0\n#define i4 i3, 0.0\n#define j4 j3, 0.0\n#define k4 k3, 0.0\n#define l4 o3, 1.0\n\n#define o1i 0\n#define i1i 1\n#define o2i o1, 0\n#define i2i i1, 0\n#define j2i o1, 1\n#define o3i o2, 0\n#define i3i i2, 0\n#define j3i j2, 0\n#define k3i o2, 1\n#define o4i o3, 0\n#define i4i i3, 0\n#define j4i j3, 0\n#define k4i k3, 0\n#define l4i o3, 1\n\n#define O2 vec2(o2)\n#define I2 vec2(i2)\n#define J2 vec2(j2)\n#define O3 vec3(o3)\n#define I3 vec3(i3)\n#define J3 vec3(j3)\n#define K3 vec3(k3)\n#define O4 vec4(o4)\n#define I4 vec4(i4)\n#define J4 vec4(j4)\n#define K4 vec4(k4)\n#define L4 vec4(l4)\n\n#define O2i ivec2(o2i)\n#define I2i ivec2(i2i)\n#define J2i ivec2(j2i)\n#define O3i ivec3(o3i)\n#define I3i ivec3(i3i)\n#define J3i ivec3(j3i)\n#define K3i ivec3(k3i)\n#define O4i ivec4(o4i)\n#define I4i ivec4(i4i)\n#define J4i ivec4(j4i)\n#define K4i ivec4(k4i)\n#define L4i ivec4(l4i)\n\n#define mat2s(v) mat2(vec2(v), vec2(v))\n#define mat3s(v) mat3(vec3(v), vec3(v), vec3(v))\n#define mat4s(v) mat4(vec4(v), vec4(v), vec4(v), vec4(v))\n\n#define mO2 mat2(o1)\n#define mO3 mat3(o1)\n#define mO4 mat4(o1)\n\nfloat exm1_ex(float x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec2 exm1_ex(vec2 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec3 exm1_ex(vec3 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec4 exm1_ex(vec4 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nfloat Mod(float a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, vec2  b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, float b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, vec3  b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, float b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, vec4  b) {return a - floor(a / b) * b;}\n\nfloat map(vec2 uv, mat2 q, vec2 l) {\n    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));\n}\nfloat map(vec3 uv, mat3 q, vec3 l) {\n    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));\n}\nfloat map(vec4 uv, mat4 q, vec4 l) {\n    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));\n}\n\nstruct RSet2 {\n    mat2 q;\n    vec2 l;\n    vec4 r;\n};\n    RSet2 rset2() {\n        return RSet2(\n            mat2(1.0),\n            vec2(0.0),\n            vec4(0.0)\n        );\n    }\nstruct RSet3 {\n    mat3 q;\n    vec3 l;\n    vec4 r;\n};\n    RSet3 rset3() {\n        return RSet3(\n            mat3(1.0),\n            vec3(0.0),\n            vec4(0.0)\n        );\n    }\nstruct RSet4 {\n    mat4 q;\n    vec4 l;\n    vec4 r;\n};\n    RSet4 rset4() {\n        return RSet4(\n            mat4(1.0),\n            vec4(0.0),\n            vec4(0.0)\n        );\n    }\nstruct RDoublet2 {\n    RSet2 a;\n    RSet2 b;\n};\n    RDoublet2 rdoublet2() {\n        return RDoublet2(rset2(), rset2());\n    }\nstruct RDoublet3 {\n    RSet3 a;\n    RSet3 b;\n};\n    RDoublet3 rdoublet3() {\n        return RDoublet3(rset3(), rset3());\n    }\nstruct RDoublet4 {\n    RSet4 a;\n    RSet4 b;\n};\n    RDoublet4 rdoublet4() {\n        return RDoublet4(rset4(), rset4());\n    }\nstruct RTriplet2 {\n    RSet2 a;\n    RSet2 b;\n    RSet2 c;\n};\n    RTriplet2 rtriplet2() {\n        return RTriplet2(rset2(), rset2(), rset2());\n    }\nstruct RTriplet3 {\n    RSet3 a;\n    RSet3 b;\n    RSet3 c;\n};\n    RTriplet3 rtriplet3() {\n        return RTriplet3(rset3(), rset3(), rset3());\n    }\nstruct RTriplet4 {\n    RSet4 a;\n    RSet4 b;\n    RSet4 c;\n};\n    RTriplet4 rtriplet4() {\n        return RTriplet4(rset4(), rset4(), rset4());\n    }\n\nconst RSet4 rs1 = RSet4(mat4(\n    7.3220e-1,   2.6310e-1,   1.4850e-1,   7.6960e-1,\n    2.6740e-1,   1.0910e+0,   6.7950e-1,   4.9680e-1,\n    8.1250e-1,   4.2080e-1,   6.4640e-1,   7.9180e-1,\n    6.1310e-1,   2.0290e-1,   9.1990e-1,   7.1260e-1\n) * 0.5 + 0.85, vec4(\n    6.8440e-1,   5.7020e-1,   3.5730e-1,   7.2590e-1\n) * 0.55 + 0.95, vec4(\n    3.3540e-1,   7.2490e-1,   6.9690e-1,   5.2740e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300));\nconst RSet4 rs2 = RSet4(mat4(\n    4.4400e-1,   6.7810e-1,   8.0430e-1,   1.0410e-1,\n    3.2070e-1,   4.9350e-2,   4.9570e-1,   5.2650e-1,\n    4.4050e-1,   3.9120e-1,   9.4240e-1,   3.1780e-1,\n    1.3450e-1,   3.5410e-1,   7.3850e-1,   1.1920e+0\n) * 0.5 + 0.85, vec4(\n    4.9660e-1,   9.6230e-1,   7.0430e-1,   9.7450e-1\n) * 0.55 + 0.95, vec4(\n    2.7730e-2,   5.1710e-1,   3.3970e-1,   1.0300e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300));\nconst RSet4 rs3 = RSet4(mat4(\n    6.0970e-1,   4.2360e-1,   6.5270e-1,   5.9520e-1,\n    3.7520e-1,   4.3880e-1,   9.5880e-3,   1.0380e+0,\n    5.1200e-1,   3.6450e-1,   6.3090e-1,   8.0340e-1,\n    5.4470e-1,   9.0890e-1,   7.6810e-1,   5.9460e-1\n) * 0.5 + 0.85, vec4(\n    6.5350e-1,   5.0250e-1,   1.5460e-1,   1.0800e-1\n) * 0.55 + 0.95, vec4(\n    4.4190e-1,   7.6040e-1,   7.7920e-1,   3.7080e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300));\nconst RSet3 rs1_3 = RSet3(mat3(rs1.q), vec3(rs1.l), rs1.r);\nconst RSet3 rs2_3 = RSet3(mat3(rs2.q), vec3(rs2.l), rs2.r);\nconst RSet3 rs3_3 = RSet3(mat3(rs3.q), vec3(rs3.l), rs3.r);\nconst RTriplet3 RT = RTriplet3(rs1_3, rs2_3, rs3_3);\n\nfloat randSin(float x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec2  randSin(vec2  x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec3  randSin(vec3  x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec4  randSin(vec4  x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\n#define RAND randSin\n\nfloat rmap(vec2 uv, RSet2 rs) {\n    return RAND(map(uv, rs.q, rs.l), rs.r);\n}\nfloat rmap(vec3 uv, RSet3 rs) {\n    return RAND(map(uv, rs.q, rs.l), rs.r);\n}\nfloat rmap(vec4 uv, RSet4 rs) {\n    return RAND(map(uv, rs.q, rs.l), rs.r);\n}\n\nvec2 rvec2(vec2 uv, RSet2 r1, RSet2 r2) {\n    return vec2(rmap(uv, r1), rmap(uv, r2));\n}\nvec2 rvec2(vec3 uv, RSet3 r1, RSet3 r2) {\n    return vec2(rmap(uv, r1), rmap(uv, r2));\n}\nvec2 rvec2(vec4 uv, RSet4 r1, RSet4 r2) {\n    return vec2(rmap(uv, r1), rmap(uv, r2));\n}\n\nvec3 rvec3(vec2 uv, RSet2 r1, RSet2 r2, RSet2 r3) {\n    return vec3(rmap(uv, r1), rmap(uv, r2), rmap(uv, r3));\n}\nvec3 rvec3(vec3 uv, RSet3 r1, RSet3 r2, RSet3 r3) {\n    return vec3(rmap(uv, r1), rmap(uv, r2), rmap(uv, r3));\n}\nvec3 rvec3(vec4 uv, RSet4 r1, RSet4 r2, RSet4 r3) {\n    return vec3(rmap(uv, r1), rmap(uv, r2), rmap(uv, r3));\n}\nvec3 rvec3(vec3 uv, RTriplet3 r) {\n    return vec3(rmap(uv, r.a), rmap(uv, r.b), rmap(uv, r.c));\n}\n\nfloat rand1(vec2  v, vec2 d, vec4 s) {return RAND( dot(d, RAND(v, s)), s);}\nfloat rand1(vec3  v, vec3 d, vec4 s) {return RAND( dot(d, RAND(v, s)), s);}\nfloat rand1(vec4  v, vec4 d, vec4 s) {return RAND( dot(d, RAND(v, s)), s);}\nvec2  rand2(vec2  v, mat2 d, vec4 s) {return RAND( d * RAND(v, s), s);}\nvec2  rand2(vec4  v, mat4 d, vec4 s) {return RAND( d * RAND(v, s), s).xy;}\nvec3  rand3(vec3  v, mat3 d, vec4 s) {return RAND( d * RAND(v, s), s);}\nvec4  rand4(vec4  v, mat4 d, vec4 s) {return RAND( d * RAND(v, s), s);}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define VORORANGE 1\nvec2 rectvoronoi(in vec3 x, mat3 d, vec4 s) {\n    ivec3 p = ivec3(floor( x ));\n    vec3 f = fract( x );\n\n    ivec3 mb;\n    vec3 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        vec3 rv = rand3(B, d, s );\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = length( r );\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = mb + ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        vec3 rv = rand3(B, d, s );\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\nvec2 rectvoronoi(in vec3 x, RSet3 r1, RSet3 r2, RSet3 r3) {\n    ivec3 p = ivec3(floor( x ));\n    vec3 f = fract( x );\n\n    ivec3 mb;\n    vec3 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        //vec3 rv = rand3(B, d, s );\n        vec3 rv = rvec3(B, r1, r2, r3);\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = length( r );\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = mb + ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        //vec3 rv = rand3(B, d, s );\n        vec3 rv = rvec3(B, r1, r2, r3);\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\nvec2 rectvoronoi(in vec3 x, RTriplet3 trip) {\n    ivec3 p = ivec3(floor( x ));\n    vec3 f = fract( x );\n\n    ivec3 mb;\n    vec3 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        //vec3 rv = rand3(B, d, s );\n        vec3 rv = rvec3(B, trip);\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = length( r );\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = mb + ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        //vec3 rv = rand3(B, d, s );\n        vec3 rv = rvec3(B, trip);\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 d3 = mat3(\n        14.4239141, 22.1623789, 14.2539214,\n        45.8097063, 19.6603408, 21.9881591,\n        20.6492482, 32.8228071, 31.9941736\n    );\n    vec4 s = vec4(\n        8442.39141, 7216.23789, 5425.39214, 9482.33014\n    );\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(iFrame == 0) {\n        vec2 UV = vec2(PI, PI2) * uv;\n        float v = rectvoronoi(\n            vec3(\n                sin(UV.x)*cos(UV.y),\n                sin(UV.x)*sin(UV.y),\n                cos(UV.x)\n            ) * 4.0, rs1_3, rs2_3, rs3_3\n        ).y;\n        fragColor = vec4(vec3(v),1.0);\n    }\n    else\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * Tile Renderer\n **\n * Renders a single tile of the image. Uses previous render as texture\n */\n#define MaximumRaySteps 200\n#define MaximumDistance 100.0\n#define MinimumDistance 0.001\n#define MaximumRadius 100.0\n\n#define Center vec3(0.0)\n\nstruct Ray {\n    // base\n    vec3 b;\n    // direction\n    vec3 d;\n};\n#define eray Ray(O3,O3)\n#define nray(b,d) Ray(b,normalize(d))\n\n#define AMBIENT_LIGHT   1\n#define POINT_LIGHT     2\n#define CONE_LIGHT      3\n#define DIRECTION_LIGHT 4\nstruct Light {\n    // type\n    int t;\n    // position and direction\n    Ray r;\n    // color and intensity\n    vec4 c;\n    // properties [falloff, spread, taper]\n    vec3 p;\n};\n#define elight Light(0,eray,O4,O3)\n#define ambientLight(c,i) Light(AMBIENT_LIGHT,eray,vec4(vec3(c),i),O3)\n#define pointLight(p,c,i,f) Light(POINT_LIGHT,Ray(p,O3),vec4(vec3(c),i),vec3(f,o2))\n#define directionLight(d,c,i,f) Light(DIRECTION_LIGHT,nray(O3,d),vec4(vec3(c),i),O3)\n\n#define LAMBERT_DIFFUSE   1\n#define ORENNAYAR_DIFFUSE 2\n#define PHONG_SPECULAR 1\nstruct Material {\n    // roughness\n    float r;\n    // albedo [ambient, diffuse, specular]\n    mat3 a;\n    // shading algorithm [diffuse, specular]\n    ivec2 s;\n};\n#define emat Material(0.,mO3,O2i)\n\nstruct Point {\n    // source and direction\n    Ray r;\n    // position\n    vec3 p;\n    // normal\n    vec3 n;\n    // march length\n    float l;\n    // iterations\n    int i;\n    // closest length\n    float cl;\n    // closest distance\n    float cd;\n    // penumbra\n    float pu;\n    // material\n    Material m;\n};\nPoint point() {\n    return Point(\n        // source and direction\n        eray,\n        // position\n        O3,\n        // normal\n        O3,\n        // march length\n        o1,\n        // iterations\n        0,\n        // closest length\n        o1,\n        // closest distance\n        o1,\n        // penumbra\n        o1,\n        // material\n        emat\n    );\n}\n\nstruct LightPath {\n    Point p;\n    Light l;\n    // normal\n    vec3 n;\n    // distance from light\n    float ilen;\n    // direction to light (incident ray)\n    vec3 iray;\n    // direction to camera (view ray)\n    vec3 vray;\n    // direction reflected light (reflected ray)\n    vec3 rray;\n    // direction to light in spherical coordinates (incident ray)\n    vec2 i;\n    // direction to camera in spherical coordinates (view ray)\n    vec2 v;\n    // direction reflected light in spherical coordinates (reflected ray)\n    vec2 r;\n    // energy\n    float e;\n};\nLightPath lightPath() {\n    return LightPath(\n        point(),\n        elight,\n        // normal\n        O3,\n        // distance from light\n        o1,\n        // direction to light (incident ray)\n        O3,\n        // direction to camera (view ray)\n        O3,\n        // direction reflected light (reflected ray)\n        O3,\n        // direction to light in spherical coordinates (incident ray)\n        O2,\n        // direction to camera in spherical coordinates (view ray)\n        O2,\n        // direction reflected light in spherical coordinates (reflected ray)\n        O2,\n        // energy\n        o1\n    );\n}\nLightPath lightPath(Point p, Light l, vec3 n) {\n    vec3 i;\n    float il;\n    if(l.t == DIRECTION_LIGHT) {\n        i = -l.r.d;\n        il = 0.0;\n    }\n    else {\n        i = l.r.b - p.p;\n        il = length(i);\n        i = normalize(i);\n    }\n    vec3 v = -p.r.d;\n    vec3 r = 2.0 * dot(i, n) * n - i;\n    vec3 t = normalize(cross(cross(n, i), n));\n    vec3 tv = normalize(cross(cross(n, v), n));\n    vec3 tr = normalize(cross(cross(n, r), n));\n    float energy;\n    if(l.t != DIRECTION_LIGHT) {\n        energy = l.c.a / pow(il, l.p[0]);\n        if(l.t == CONE_LIGHT)\n            energy *= pow((l.p[1] - acos(dot(-i, l.r.d))) / l.p[1], l.p[2]);\n    }\n    else\n        energy = l.c.a;\n    return LightPath(\n        p,\n        l,\n        n,\n        il,\n        i,\n        v,\n        r,\n        vec2(dot(n, i), 0.0), // incident\n        vec2(dot(n, v), dot(t, tv)), // view\n        vec2(dot(n, r), dot(t, tr)), // reflected\n        energy\n    );\n}\n\nstruct DistanceEstimation {\n    // original point\n    vec3 p;\n    // surface point\n    vec3 s;\n    // direction\n    vec3 d;\n    // distance\n    float l;\n    // normal\n    vec3 n;\n    // material\n    Material m;\n};\nfloat bicubic(vec2 uv) {\n    vec2 res0 = iChannelResolution[0].xy;\n    uv *= res0;\n    vec2 l = floor(uv);\n    vec2 f = fract(uv);\n    #ifdef BICUBIC\n    mat4 D = mat4(\n        texture(iChannel0, Mod((l - 1.) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l - I2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l - I2 + J2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l - I2 + 2. * J2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l - J2) / res0, 1.0)).x,\n    #else\n    mat2 D = mat2(\n    #endif\n        texture(iChannel0, Mod((l - O2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + J2) / res0, 1.0)).x,\n    #ifdef BICUBIC\n        texture(iChannel0, Mod((l + 2. * J2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + I2 - J2) / res0, 1.0)).x,\n    #endif\n        texture(iChannel0, Mod((l + I2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + 1.) / res0, 1.0)).x\n    #ifdef BICUBIC\n        ,\n        texture(iChannel0, Mod((l + 1. + J2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + 2. * I2 - J2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + 2. * I2) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + I2 + 1.) / res0, 1.0)).x,\n        texture(iChannel0, Mod((l + 2.) / res0, 1.0)).x\n    #endif\n    );\n    #ifdef BICUBIC\n    mat4 Dt = transpose(D);\n    mat4 X = mat4(\n        vec4(0.0),\n        D[2] - D[0],\n        D[3] - D[1],\n        vec4(0)\n    );\n    mat4 Y = transpose(mat4(\n        vec4(0.0),\n        Dt[2] - Dt[0],\n        Dt[3] - Dt[1],\n        vec4(0)\n    ));\n    mat2 XY = mat2(\n        Y[2].yz - Y[0].yz,\n        Y[3].yz - Y[1].yz\n    );\n    mat4 a = mat4(\n        1.0, 0.0, -3.0, 2.0,\n        0.0, 0.0, 3.0, -2.0,\n        0.0, 1.0, -2.0, 1.0,\n        0.0, 0.0, -1.0, 1.0\n    );\n    mat4 A = a *  mat4(\n        D[1][1], D[2][1], X[1][1], X[2][1],\n        D[1][2], D[2][2], X[1][2], X[2][2],\n        Y[1][1], Y[2][1], XY[0][0], XY[1][0],\n        Y[1][2], Y[2][2], XY[0][1], XY[1][1]\n    ) * transpose(a);\n    vec4 x = vec4(1.0, f.x, f.x * f.x, f.x * f.x * f.x);\n    vec4 y = vec4(1.0, f.y, f.y * f.y, f.y * f.y * f.y);\n    return dot(x, A * y);\n    #else\n    return mix(mix(D[0][0], D[0][1], f.y), mix(D[1][0], D[1][1], f.y), f.x);\n\t#endif\n}\nivec3 cell(vec3 p) {\n    return ivec3(floor((p + CELL_WIDTH / 2.0) / CELL_WIDTH));\n}\nconst Material MAIN_MAT = Material(\n    // roughness\n    0.0,\n    // albedo [ambient, diffuse, specular]\n    mat3(\n        vec3(1.0), // ambientalbedo\n        //vec3(0.3), // diffusealbedo\n        vec3(0.25), // diffusealbedo\n        //vec3(1.0), // diffusealbedo\n        //vec3(0.0), // diffusealbedo\n        vec3(0.75) // specularalbedo\n        //vec3(0.0) // specularalbedo\n    ),\n    // shading algorithm [diffuse, specular]\n    ivec2(\n        //LAMBERT_DIFFUSE, // diffusetype\n        ORENNAYAR_DIFFUSE, // diffusetype\n        PHONG_SPECULAR // speculartype\n    )\n);\nconst Material SPHERE_MAT = Material(\n    // roughness\n    .4,\n    // albedo [ambient, diffuse, specular]\n    mat3(\n        vec3(1.0), // ambientalbedo\n        //vec3(0.3), // diffusealbedo\n        vec3(0.0625), // diffusealbedo\n        //vec3(1.0), // diffusealbedo\n        //vec3(0.0), // diffusealbedo\n        vec3(.5) // specularalbedo\n        //vec3(0.0) // specularalbedo\n    ),\n    // shading algorithm [diffuse, specular]\n    ivec2(\n        //LAMBERT_DIFFUSE, // diffusetype\n        ORENNAYAR_DIFFUSE, // diffusetype\n        PHONG_SPECULAR // speculartype\n    )\n);\nfloat distanceEstimation(inout DistanceEstimation d) {\n    ivec3 c = cell(d.p);\n    float d2 = length(mod(d.p + 2.5, vec3(5.0)) - 2.5) - 1.0;\n    if(length(vec3(c)) < 0.5) {\n        d.l = length(d.p) - 1.0;\n        d.s = normalize(d.p);\n        vec3 S = abs(d.s);\n        //float x = max(S.x, max(S.y, S.z));\n        //S = d.s / x;\n        vec2 uv = vec2(acos(S.z) / PI, atan(S.y, S.x) / PI2);\n        //if(S.x > 0.999999)\n        //    uv = (S.yz + 1.0) / 6.0;\n        //if(S.x < -0.999999)\n        //    uv = (-S.yz + 1.0) / 6.0 + vec2(0.0, 1.0 / 3.0);\n        //if(S.y > 0.999999)\n        //    uv = (S.zx + 1.0) / 6.0 + vec2(1.0 / 3.0, 0.0);\n        //if(S.y < -0.999999)\n        //    uv = (-S.zx + 1.0) / 6.0 + vec2(1.0 / 3.0, 1.0 / 3.0);\n        //if(S.z > 0.999999)\n        //    uv = (S.xy + 1.0) / 6.0 + vec2(2.0 / 3.0, 0.0);\n        //if(S.z < -0.999999)\n        //    uv = (-S.xy + 1.0) / 6.0 + vec2(2.0 / 3.0, 1.0 / 3.0);\n        //float displacement = fbm(uv) * 0.5;\n        float displacement = bicubic(uv);\n        displacement *= 0.0625;\n        displacement *= 0.5;\n        //displacement *= 4.0;\n        //displacement *= 0.0;\n        d.s *= 1.0 + displacement;\n        d.l -= displacement;\n        d.m = MAIN_MAT;\n        return d.l;\n    }\n    else {\n        vec3 C = vec3(c) * CELL_WIDTH;\n        d.l = length(d.p - C);\n        d.s = normalize(d.p - C) + C;\n        d.l = d2;\n        d.s = normalize(d.p) + d.p - mod(d.p + 2.5, vec3(5.0)) - 2.5;\n        d.m = SPHERE_MAT;\n        return d.l;\n    }\n}\nvec3 normal(vec3 p) {\n    float diff = 0.00001;\n    DistanceEstimation d = DistanceEstimation(\n        vec3(0.0), //p\n        vec3(0.0), //s\n        vec3(0.0), //d\n        0.0, //l\n        vec3(0.0), //n\n        emat\n    );\n    d.p = p - diff * I3;\n    float nx = distanceEstimation(d);\n    d.p = p + diff * I3;\n    float px = distanceEstimation(d);\n    d.p = p - diff * J3;\n    float ny = distanceEstimation(d);\n    d.p = p + diff * J3;\n    float py = distanceEstimation(d);\n    d.p = p - diff * K3;\n    float nz = distanceEstimation(d);\n    d.p = p + diff * K3;\n    float pz = distanceEstimation(d);\n    return normalize(vec3(\n        px - nx,\n        py - ny,\n        pz - nz\n    ));\n}\nvoid trace(inout Point tracePoint, float k) {\n    float pdis = 1e20, dis;\n    tracePoint.r.d = normalize(tracePoint.r.d);\n    tracePoint.i = 0;\n    DistanceEstimation d = DistanceEstimation(\n        vec3(0.0),\n        vec3(0.0),\n        tracePoint.r.d,\n        0.0,\n        vec3(0.0),\n        emat\n    );\n\tfor (int steps = 0; steps < MaximumRaySteps; steps++) {\n        if(\n            tracePoint.i == 0\n            || abs(dis) > MinimumDistance\n            && tracePoint.l < MaximumDistance\n            && length(Center - tracePoint.p) < MaximumRadius\n        ) {\n            tracePoint.p = tracePoint.r.b + tracePoint.l * tracePoint.r.d;\n            d.p = tracePoint.p;\n            dis = distanceEstimation(d);\n            tracePoint.n = d.n;\n            tracePoint.m = d.m;\n            tracePoint.l += dis;\n            float y = dis*dis/(2.0*pdis);\n\t\t\tfloat d = sqrt(dis*dis-y*y);\n            pdis = dis;\n            if(steps == 0) {\n                tracePoint.cd = d;\n                tracePoint.cl = max(0.0,tracePoint.l-y);\n                tracePoint.pu = k * d/max(0.0,tracePoint.l-y);\n            }\n            else {\n                if(d < tracePoint.cd) {\n                    tracePoint.cd = d;\n                    tracePoint.cl = max(0.0,tracePoint.l-y);\n                }\n                tracePoint.pu = min(tracePoint.pu, k * d/max(0.0,tracePoint.l-y));\n            }\n            tracePoint.i++;\n        }\n\t}\n    if(length(Center - tracePoint.p) > MaximumRadius || tracePoint.l > MaximumDistance) {\n        tracePoint.p = vec3(0.0);\n        tracePoint.i = MaximumRaySteps;\n    }\n}\n\nvec3 lambert(Material m, LightPath lp) {\n    return m.a[1] / PI * lp.l.c.rgb * max(0.0, lp.e * lp.i.x);\n}\nvec3 orennayar(Material m, LightPath lp) {\n    float roughness = tan(0.999 * m.r * PI / 2.0);\n    float A = 1.0 - 0.5 * m.r / (m.r + 0.33);\n    float B = 0.45 * m.r / (m.r + 0.09);\n    float ca = max(lp.i.x, lp.v.x);\n    float cb = min(lp.i.x, lp.v.x);\n    float sa = sqrt(1.0 - ca * ca);\n    float tb = sqrt(1.0 / (cb * cb) - 1.0);\n    return m.a[1] / PI * lp.l.c.rgb * max(0.0, lp.e * lp.i.x * (A + (B * max(0.0, lp.v.y) * sa * tb)));\n}\nvec3 phong(Material m, LightPath lp) {\n    float shininess = tan(0.999 * (1.0 - m.r) * PI / 2.0);\n    return m.a[2] / PI * lp.l.c.rgb * max(0.0, lp.e * lp.i.x * pow(dot(lp.rray, lp.vray), shininess));\n}\nvoid lighting(inout vec3 r, inout vec3 a, Light l, Point p, vec3 n) {\n    if(l.t == AMBIENT_LIGHT) {\n        a += p.m.a[0] / PI * l.c.rgb * l.c.a;\n        a = clamp(a, 0.0, 1.0);\n    }\n    else {\n        LightPath lp =  lightPath(p, l, n);\n        vec3 L;\n        if(p.m.s[0] == LAMBERT_DIFFUSE)\n            L = lambert(p.m, lp);\n        else if(p.m.s[0] == ORENNAYAR_DIFFUSE)\n            L = orennayar(p.m, lp);\n        vec3 S;\n        if(p.m.s[1] == PHONG_SPECULAR)\n            L += phong(p.m, lp);\n        if(length(L) > 0.0001) {\n            Point sp = point();\n            sp.r.b = p.p + lp.iray * 0.01;\n            sp.r.d = lp.iray;\n            trace(sp, 1.0);\n            float sf = exm1_ex(sp.pu);\n            sf = 1.0;\n            if(sp.l < lp.ilen)\n                sf = 0.0;\n            L *= sf;\n        }\n        r = clamp(r + L, 0.0, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int rcell = iFrame / FRAMES_PER_CELL;\n    int rcycle = rcell / HILBERT_CELLS;\n    rcell -= rcycle * HILBERT_CELLS;\n    int rcellFrame = iFrame - rcell * FRAMES_PER_CELL;\n    \n    //rcell = 1;\n    vec2 hcell = vec2(hilbert(rcell)) / F_HILBERT_SIDE;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy / F_HILBERT_SIDE + hcell;\n    uv -= 0.5;\n    uv *= 2.0;\n    #ifndef BUMPMAP_CHECK\n    //vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    float h = 2.0 / iResolution.x;\n    uv.y *= iResolution.y / iResolution.x;\n    float t = 1.0 * iTime * 0.25;\n    t = 0.0;\n    \n    vec3 camera = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t),  cos(t), 0.0,\n           0.0,     0.0, 1.0\n    ) * vec3(3.0, -5.0, 4.0) * 0.4;\n    vec3 target = vec3(0.0);\n    vec3 up = K3;\n    \n    vec2 aperature = vec2(APERATURE_SIZE);\n    float focal = (length(camera) - 0.75) * SENSOR_DISTANCE /\n        (length(camera) - 0.75 + SENSOR_DISTANCE);\n    \n    vec3 cz = normalize(camera - target);\n    vec3 cx = normalize(cross(up, cz));\n    vec3 cy = normalize(cross(cz, cx));\n\n    // get the center of the aperature\n    vec3 A = camera;\n    // get the center of the sensor\n    vec3 S = A + cz * SENSOR_DISTANCE;\n    // get the focus vector\n    vec3 f = -focal * cz;\n    // get the focal point\n    vec3 F = A + f;\n    \n    float intensity = 2048.0;\n    Light ls[] = Light[] (\n        ambientLight(1.0, 0.0),\n        pointLight(\n            vec3(8.0, 8.0, 8.0), // position\n            normalize(vec3(0.8, 0.3, 1.0)), // color\n            intensity, // intensity\n            2.0 // falloff\n        ),\n        pointLight(\n            vec3(-8.0, -8.0, 8.0), // position\n            normalize(vec3(0.32, 0.9, 1.2)), // color\n            intensity, // intensity\n            2.0 // falloff\n        ),\n        pointLight(\n            vec3(-8.0, 8.0, -8.0), // position\n            normalize(vec3(1.0, 0.97, 0.46)), // color\n            intensity, // intensity\n            2.0 // falloff\n        ),\n        pointLight(\n            vec3(8.0, -8.0, -8.0), // position\n            normalize(vec3(0.53, 1.0, 0.16)), // color\n            intensity, // intensity\n            2.0 // falloff\n        )\n    );\n    vec3 bg = vec3(0.53, 0.81, 0.98);\n    \n    vec3 pixel = vec3(0.0);\n    \n    mat4 qr = mat4(\n        7.3220e-1,   2.6310e-1,   1.4850e-1,   7.6960e-1,\n        2.6740e-1,   1.0910e+0,   6.7950e-1,   4.9680e-1,\n        8.1250e-1,   4.2080e-1,   6.4640e-1,   7.9180e-1,\n        6.1310e-1,   2.0290e-1,   9.1990e-1,   7.1260e-1\n    ) * 0.5 + 0.85;\n    vec4 sr = vec4(\n        3.3540e-1,   7.2490e-1,   6.9690e-1,   5.2740e-1\n    ) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\n    \n    float fsn = float(SAMPLES);\n    float factor = 1.0 / (fsn * fsn);\n    for(int i = 0; i < SAMPLES; i++)\n        for(int j = 0; j < SAMPLES; j++) {\n            Point p = point();\n            \n    \t\t// get a random 2d vector [0.0, 1.0]\n            vec2 r = rand2(\n                vec4(uv, float(i * SAMPLES + j), iTime),\n                qr, sr\n            ) - 0.5;\n            vec2 cuv = uv + h * (factor * fsn * r - 0.5 + 0.5 / fsn);\n            \n            // calculate the vector from the center of the sensor\n            vec3 bd = (cx * uv.x + cy * uv.y) * SENSOR_SIZE;\n            bd *= -1.0;\n            float bdl = length(bd);\n\n            // calculate the position on the sensor\n            vec3 b = S + bd;\n            \n    \t\t// get a random 2d vector [0.0, 1.0]\n            r = rand2(\n                vec4(uv, iTime, float(i * SAMPLES + j)),\n                qr, sr\n            ) - 0.5;\n            // calculate the vector from the center of the aperature\n            vec3 ad = cx * r.x * aperature.x + cy * r.y * aperature.y;\n            vec3 adn = normalize(ad);\n            vec3 ads = adn / max(adn.x, adn.y);\n            //ad /= length(ads);\n            // calculate the position in the aperature\n            vec3 a = A + ad;\n\n            float Ix = focal * SENSOR_DISTANCE / (SENSOR_DISTANCE - focal);\n            float Iy = -focal * length(bd) / (SENSOR_DISTANCE - focal);\n            vec3 I = A - Ix * cz + Iy * normalize(bd);\n            \n            //p.r.b = b;\n            //p.r.d = normalize(a - b);\n            p.r.b = a;\n            p.r.d = normalize(I - a);\n            \n            trace(p, 1.0);\n\n            vec3 v;\n            if(p.i < MaximumRaySteps) {\n                vec3 n = p.n;\n                if(length(n) < 0.001)\n                    n = normal(p.p);\n                vec3 reflection = vec3(0.0), ambient = vec3(0.0);\n                for(int l = 0; l < 5; l++)\n                    lighting(reflection, ambient, ls[l], p, n);\n                float occlusion = 1.0 - float(p.i) / float(MaximumRaySteps);\n                \n                // Output to screen\n                v = clamp((reflection + ambient), 0.0, 1.0);\n                //v = clamp(occlusion * ambient, 0.0, 1.0);\n                //v = vec3(occlusion);\n                //v = n * 0.5 + 0.5;\n                //v = normalize(p) * 0.5 + 0.5;\n                //v = normalize(p) / length(p) * 0.5 + 0.5;\n                //v = mix(v, bg, log(clamp(p.marchlength - 100.0, 0.0, 1.0) + 1.0));\n            }\n            else {\n                v = vec3(0.0);\n                v = bg;\n            }\n            pixel += v * factor;\n        }\n    //float pf = float(iFrame) / float(iFrame + 1);\n    //float cf = 1.0 / float(iFrame + 1);\n    //vec3 combined = pf * texture(iChannel1, fragCoord / iResolution.xy).rgb + cf * pixel;\n    fragColor = vec4(pixel, 1.0);\n    #else\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n\t#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/**\n * Combiner\n **\n * Combines current image with image from Buffer A\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ires = vec2(iResolution);\n    vec2 icoord = vec2(fragCoord);\n    \n    vec2 cellSize = ires / F_HILBERT_SIDE;\n    \n    ivec2 cell = ivec2(floor(icoord / cellSize));\n    vec2 cellcoord = icoord - vec2(cell) * cellSize;\n    \n    int F = iFrame + 1;\n    int rcell = iFrame / FRAMES_PER_CELL;\n    int rcellFrame = iFrame - rcell * FRAMES_PER_CELL;\n    int rcycle = rcell / HILBERT_CELLS;\n    rcell -= rcycle * HILBERT_CELLS;\n    \n    //rcell = 1;\n    ivec2 hcell = hilbert(rcell);\n    \n    //#define TEST_CELL_NUM\n    #ifdef TEST_CELL_NUM\n    fragColor = vec4(float(rcell) / F_HILBERT_CELLS, vec2(hcell) / F_HILBERT_CELLS, 1.0);\n    #else\n    #ifdef BUFFER_PASSTHROUGH\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    #elif defined BUMPMAP_CHECK\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    #else\n    vec4 previous = texture(iChannel1, fragCoord / iResolution.xy);\n    if(length(vec2(hcell - cell)) < 0.5) {\n        vec4 current = vec4(0.);\n        for(vec2 ij = vec2(0.); ij.x < F_HILBERT_SIDE + 0.5; ij.x += 1.)\n            for(ij.y = 0.; ij.y < F_HILBERT_SIDE + 0.5; ij.y += 1.) {\n        \t\tvec2 uv = (cellcoord - (ij - F_HILBERT_SIDE + 1.) / F_HILBERT_SIDE)\n                    / cellSize;\n                current += texture(iChannel0, uv);\n            }\n        current /= F_HILBERT_CELLS;\n        float frames = float(rcycle * FRAMES_PER_CELL + rcellFrame);\n        fragColor = mix(previous, current, 1. / (frames + 1.));\n    }\n    else if(iFrame == 0)\n    \tfragColor = vec4(0., 0., 0., 1.);\n    else\n        fragColor = previous;\n    #endif\n    #endif\n}","name":"Buffer C","description":"","type":"buffer"}]}