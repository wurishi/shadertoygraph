{"ver":"0.1","info":{"id":"McXfzs","date":"1724189977","viewed":12,"name":"Integer Shader: Xor Pattern","username":"_JZ","description":"simple xor fractal patterns using only integer operations","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["xor","pattern","integer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    int threshold = 5;\n    int scalingFactor = 2;\n    //convert everything to integers\n    int time = int(iTime * 10.0);\n\n    int x = int(fragCoord.x/6.0); //scale image\n    int y = int(fragCoord.y/6.0);\n    \n    bool r = false;//1 bit color depth\n    bool g = false; \n    bool b = false;\n    \n    #define shader 1\n    \n    #if shader==1\n        threshold = 5;\n        int tmp_x = x + time;\n        \n        r = (tmp_x ^ y) % 7 >threshold;\n    \n        g = (tmp_x ^ y+1) % 7 >threshold;\n    \n        b = (tmp_x ^ y-1) % 7 >threshold;\n    #endif\n    \n    #if shader==2\n        threshold = 1;\n        int tmp_x = x + time;\n        int tmp_y = y + time;\n        \n        r = (tmp_x ^ tmp_y) % 7 >threshold;\n    \n        g = (tmp_x ^ tmp_y) % 7 >threshold;\n    \n        b = (tmp_x ^ tmp_y) % 7 >threshold;\n    #endif\n    \n    #if shader==3\n        threshold = 14-(time/4)%15;\n        int tmp_x = x + time;\n        \n        r = ((tmp_x ^ y) % 7 + (tmp_x ^ y) % 9) >threshold;\n    \n        g = ((tmp_x ^ y) % 7 + (tmp_x ^ y) % 9) >threshold;\n    \n        b = ((tmp_x ^ y) % 7 + (tmp_x ^ y) % 9) >threshold;\n    #endif\n    \n    #if shader==4 //no modulo\n    \n      int tmp_x;\n      int tmp_y;\n      float mirrorScale = 0.0; //set this to 1.0\n      #if 1 //use floatingpoint scaling\n\n        tmp_x = int(abs(fragCoord.x-iResolution.x/2.0)/6.0*iTime/4.0+iTime*iTime*mirrorScale); //zoom out (uses floating point math)\n        tmp_y = int(abs(fragCoord.y-iResolution.y/2.0)/6.0*iTime/4.0+iTime*iTime*mirrorScale); //somewhat works with int only\n      #else\n        tmp_x = abs(int(fragCoord.x)-int(iResolution.x/2.0))/4+int(iTime*iTime*mirrorScale);\n        tmp_y = abs(int(fragCoord.y)-int(iResolution.y/2.0))/4+int(iTime*iTime*mirrorScale);\n      #endif\n        threshold = time*5;\n        tmp_x = (tmp_x)<<scalingFactor;\n        tmp_y = (tmp_y)<<scalingFactor;\n        \n        r = (tmp_x ^ tmp_y) >threshold;\n    \n        g = (tmp_x ^ tmp_y+1) >threshold;\n    \n        b = (tmp_x ^ tmp_y-1) >threshold;\n    #endif\n    \n\n    vec3 col = vec3(float(r),float(g),float(b));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}