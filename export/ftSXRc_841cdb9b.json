{"ver":"0.1","info":{"id":"ftSXRc","date":"1628289464","viewed":113,"name":"Sinusoidal pulse","username":"RossBorchers","description":"A sinusoidal pulse at a regular interval.\n\nPULSE WIDTH: Scale of the pulse width. Clamped. \nPULSE_HEIGHT: Scale of pulse height.\nPULSE_INTERVAL: Space between pulses inclusive of the pulse itself.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test","graphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PULSE_WIDTH 2.\n#define PULSE_HEIGHT 1.\n#define PULSE_INTERVAL 5.\n\n#define DRAW_DEBUG true\n\n#define VIEW_SCALE 10.\n#define VIEW_PAN_SPEED (3.0/VIEW_SCALE)\n\n#define LINE_SHARPNESS 0.98\n#define LINE_THICKNESS 0.025\n\n#define PI 3.14159265359\n#define TWO_PI PI*2.\n\n//Compact Version: https://www.shadertoy.com/view/NtSSRt\n\nfloat Repeat(float x, float width, float interval)\n{\n    //Calculate repeating x value via mod, and offseting so only x equal to width is above 0.\n    //This creates a repeating local coordinate system that has gaps in it (based on the difference subtracted)\n    return mod(x-width, interval)-(interval-width);\n}\n\n\nfloat RepeatPulse(float x, float width, float height, float interval)\n{\n    // Get repeating domain (repeating local x coordinates for each pulse)\n    float pLocal = Repeat(x, width, interval);\n    \n    // Scale repeating domain so sin is stretched based on width.\n    float scaledLocal = pLocal/=width; \n\n    // Calculate radians from scaled local pos, subtract half PI so peak falls in center.\n    float rad = scaledLocal*TWO_PI - PI/2.;\n    \n    // Normalize sin result between 0 and 1\n    float s = sin(rad)/2.+.5; \n    \n    // Discretize repeating domain so anything >0 is 1 and anything <0 is 0.\n    // Used to disregard sin output when input is negative as that should be the area between pulses\n    float signalSwitch = ceil(clamp(pLocal, 0., 1.));\n    return s * height * signalSwitch;\n}\n\n\nvec3 Plot(vec2 p, float result, vec3 background, vec3 color)\n{\n    //Draw line. Modified from //https://www.shadertoy.com/view/MdBfR1\n    return mix(background, color, 1.-smoothstep(0., 1.-LINE_SHARPNESS, abs(p.y-result)-LINE_THICKNESS));\n}\n\nvec3 Checkerboard(vec2 p)\n{\n     //https://www.shadertoy.com/view/MdBfR1\n     //checker for every 1 unit. (scale p to see!)\n     return vec3( .13 ) + .01*mod(floor(p.x)+floor(p.y), 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1). Center on middle of screen.\n    vec2 p = (fragCoord-.5f*iResolution.xy)/iResolution.y;\n    p = (p + vec2(iTime, 0.) * VIEW_PAN_SPEED) * VIEW_SCALE; // Scale offset and pan\n    \n    //background checkerboard used from iq\n    vec3 col = Checkerboard(p);\n    \n    //Clamp width to be <= interval. > interval makes result discontinuous.\n    float widthClamped = clamp(PULSE_WIDTH, .01, PULSE_INTERVAL);\n    \n    if(DRAW_DEBUG)\n    { \n        //draw the local domain x value (RED) \n        float pLocal = Repeat(p.x, widthClamped, PULSE_INTERVAL);\n        col = Plot(p, pLocal, col, vec3(0.4,0,0));\n    \n        //draw the on/off signal switch\n        float signalSwitch = ceil(clamp(pLocal, 0., 1.));\n        col = Plot(p, signalSwitch, col, vec3(0,0.3,0.2));\n    }\n\n    // Use the domain repeat and signal switch to draw a sinusoidal pulse at a regular interval.\n    float pulse = RepeatPulse(p.x, widthClamped, PULSE_HEIGHT, PULSE_INTERVAL);\n    col = Plot(p, pulse, col, vec3(0.3, 0.8, 1));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}