{"ver":"0.1","info":{"id":"NsBSWV","date":"1621188126","viewed":117,"name":"Screen Explosion! Test Card","username":"JeanPaulSoftware","description":"Multi-monitor calibration card to be used with the upcoming Jean-Paul Software Screen Explosion!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["simple","testcard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ball {\n    vec2 startPos;\n    vec2 direction;\n    float timeOffset;\n    \n};\n\nfloat getEdgeColour (float x, float lineWidth) {\n    // Probably a better way to do this\n    float halfWidth = lineWidth * 0.5;\n    float minDist = 0.0;\n    if (x > halfWidth && x < (1.0 - halfWidth)) {\n        return 0.0;\n    }\n    \n    minDist = min(abs(halfWidth - x), abs(1.0 - halfWidth - x));  \n    return clamp((minDist) / halfWidth, 0.0, 1.0);\n\n}\n\nfloat distanceToCentre (vec2 uv) {\n    return distance(uv,  vec2(0.0, 0.0));\n}\n\n\nfloat circle (vec2 pos, float r, vec2 uv) {\n    float dist = length(pos - uv);\n    float c = smoothstep(\n        r - r * 0.01,\n        r + r * 0.01,\n        dist\n    );\n    return 1.0 - clamp(c, 0.0, 1.0);\n    \n}\n\nfloat meta(vec2 p, float r) {\n    return r / (dot(p, p) + 0.0001);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat scale = 4.2;\nfloat edgeSize = 0.02;\nint numVerticalBalls = 14;\nint numHorizontalBalls = 14; \n\n// Thanks to https://www.shadertoy.com/view/MtKXRt\nfloat circleContribution (vec2 uv, Ball[28] balls) {\n\n    float fieldStrength = 0.0;\n    int totalBalls = numVerticalBalls + numHorizontalBalls;\n    for (int i = 0; i < totalBalls; i++) {\n        vec2 pos = balls[i].startPos + sin(iTime + balls[i].timeOffset / 1.2) * balls[i].direction * vec2(6.5, 6.5);\n        fieldStrength += meta(uv - pos, 1.8);\n    }\n    \n    fieldStrength /= float(totalBalls);\n    float fwDe = 48./iResolution.y;\n    fieldStrength *= .5; // or / numBalls\n    \n    return smoothstep(0., fwDe, fieldStrength - 1.0);\n    return clamp(fieldStrength, 0.0, 1.0);\n}\n\n\n// Colour\n//vec3[5] palette = vec3[](vec3(219., 153., 90.) / 255., vec3(101., 66., 54.) / 255., vec3(214., 212., 160.) / 255., vec3(218., 118., 53.) / 255., vec3(226., 78., 27.) / 255.);\n\n// Black and white\nvec3[5] palette = vec3[5](vec3(30., 30., 30.) / 255., vec3(75., 75., 75.) / 255., vec3(150., 150., 150.) / 255., vec3(200., 200., 200.) / 255., vec3(210., 210., 210.) / 255.);\n\nBall[28] balls;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float ballSeparationX = 1.0;\n    float ballSeparationY = 1.0;\n    \n    // Balls\n    int count = 0;\n    for (int i = 0; i < numVerticalBalls; i++) {\n        balls[count++] = Ball(\n            vec2( -6.5 + ballSeparationX * float(i), 0.0),\n            vec2(0.0, 1.0),\n            float(i) * 1.02\n        );\n    \n    }\n    \n    for (int i = 0; i < numHorizontalBalls; i++) {\n        balls[count++] = Ball(\n            vec2(0.0, -6.5 + ballSeparationY * float(i)),\n            vec2(1.0, 0.0),\n            float(i) * 1.17\n        );\n    }\n    \n    uv *= scale;\n    \n    // Horizontal and vertical components\n    vec2 fractUV = fract(uv);\n    vec2 floorUV = floor(uv);\n    \n    // Radial components\n    float radFract = fract(distanceToCentre(uv));\n    float radFloor = floor(distanceToCentre(uv) + iTime);\n    \n    // Masks for whether we're in the middle or not\n    float inCentre = circle( vec2(0.0), 2.0, uv);\n    float outsideCentre = 1.0 - inCentre;\n    \n    // Which colour to use in the background\n    int colourIndex = int(radFloor) % 4;\n\n    // Balls and edges\n    float ballFactor = circleContribution(uv, balls);\n    vec3 edgeFactor = vec3(getEdgeColour(fract(radFract + iTime), edgeSize)) +  \n                      vec3(getEdgeColour(fractUV.x, edgeSize)) +\n                      vec3(getEdgeColour(fractUV.y, edgeSize));\n                      \n    vec2 fatUV = floor(uv * 40.);\n    float angle = iTime;\n\n    \n    // Again, probably a better way to do composition than this\n    vec3 colour = (    \n        // Background colour\n        outsideCentre * (\n            (1.0 - ballFactor) * palette[colourIndex] +\n            ballFactor * palette[4]\n        )\n        // To be replaced with a nice cat photo\n        + inCentre * texture(iChannel0, (uv + scale / 2.) / scale).xyz\n        // Lines\n        + outsideCentre * (1.0 - ballFactor) * edgeFactor * vec3(1.0)\n        \n    ) \n    // \"Film grain\"\n    * (0.9 + random(fatUV + vec2(sin(iTime * fatUV.y) * .5, cos(-iTime * fatUV.x) * .5)) * 0.1);\n                \n    \n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}