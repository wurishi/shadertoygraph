{"ver":"0.1","info":{"id":"fddczf","date":"1653984282","viewed":110,"name":"RDLOGO","username":"fractalfantasy","description":"Writing '* Shadertoy *' from time to time and simulate Reaction Diffusion 3d.\n<blanc>, F1 .. F4 different drawings..., F5 clear","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","simulation","font","shadertoy","bumpmapping","diffusion","reaction"],"hasliked":0,"parentid":"Xt3Bzj","parentname":"Shadertoy Reaction Diffusion 3d"},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*--------------------------------------------------\n\nshader:  ShadertoyReactionDiffusion3d_Image.glsl\n\n v1.0  2018-10-23  initial release\n\nWriting '* Shadertoy *' from time to time and simulate Reaction Diffusion 3d.\n\nThe reaction-diffusion system is visualized with a slightly modified version of\nShane's Bumped Sinusoidal Warp shadertoy here:\thttps://www.shadertoy.com/view/4l2XWK\n\nOriginal 'Simple Reaction Diffusion' see https://www.shadertoy.com/view/XslyD2\n\nPress F1 .. F4 or <spacebar> to restart reaction.\nPress mouse button for drawing.\n\niChannel0 defines the background\niChannel2 is used as input channel\n\n--------------------------------------------------*/\n\nfloat BumpMapping(vec2 pos)\n{\n    return 0.5 * (texture(iChannel2, pos).x + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;  // screen coordinates\n\n  // VECTOR SETUP - surface position, ray origin, unit direction vector, and light postion.\n  vec3 sp = vec3(uv, 0); // Surface position. Hit point, if you prefer. Essentially, a screen at the origin.\n  vec3 rd = normalize(vec3(uv - 1.0, 1.)); // Unit direction vector. From the origin to the screen plane.\n  vec3 lp = vec3(cos(iTime/0.8)*0.5, sin(iTime/2.0)*0.2+0.3, -1.); // Light position - Back from the screen.\n  vec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n\n  vec2 eps = 1.5 / iResolution.xy;\n  float f  = BumpMapping(uv); // Sample value multiplied by the amplitude.\n  float fx = BumpMapping(uv - vec2(eps.x, 0.0)); // left nearby sample\n  float fy = BumpMapping(uv - vec2(0.0, eps.y)); // lower nearby sample\n    \n  // Controls how much the bump is accentuated.\n  const float bumpFactor = 0.016;\n\n  // Using the above to determine the dx and dy function gradients.\n  fx = (fx-f) / eps.x;   // Change in X\n  fy = (fy-f) / eps.y;   // Change in Y.\n  sn = normalize(sn + vec3(fx, fy, 0)*bumpFactor);\n\n  // LIGHTING\n  // Determine the light direction vector, calculate its distance, then normalize it.\n  vec3 ld = lp - sp;\n  float lDist = max(length(ld), 0.001);\n  ld /= lDist;\n\n  // Light attenuation.\n  float atten = min(1./(0.25 + lDist*0.5 + lDist*lDist*0.05), 20.);\n  atten *= f*f*.5 + .5;\n\n  // Diffuse value.\n  float diff = max(dot(sn, ld), 0.);\n  // Enhancing the diffuse value a bit. Made up.\n  diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34;\n  // Specular highlighting.\n  float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 10.);\n\n  vec3 texCol;\n  texCol = 0.14*texture(iChannel0, 3.0*sp.xy).xyz;\n//texCol *= (diff*vec3(1, .97, .92)*1.3 + 0.5);\n\n  // use values above to produce the final color\n  vec3 col = (texCol + vec3(1., 0.6, .2)*spec*1.3)*atten;\n\n  fragColor = vec4(min(col, 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//------------------------------------------------\n// ShadertoyReactionDiffusion3d_Common.glsl\n//\n// v1.0  2018-10-23  initial release\n//\n// font: https://www.shadertoy.com/view/MtyXDV\n//------------------------------------------------\n\n// common reaction diffusion constants\nconst vec2 DiffusionRate = vec2(1.0, 0.5);\nconst float KillRate = 0.062;\nconst float FeedRate = 0.0545;\nconst float Speed = 40.0;\n\n#define fontChannel iChannel0\n#define inputChannel iChannel2\n\n//== geometric drawings ==========================\n\nvec2 uv         = vec2(0.0);  // -1 .. 1\nfloat aspect    = 1.4;\nvec2 ratio      = vec2(1.4, 1.0);\nvec2 pixelPos   = vec2(0.0);  // pixel position:  0 .. resolution-1\nvec2 resolution = vec2(0.0);  // window resolution\n\n/*\n//--- draw line segment from A to B ---\nfloat drawLineSegment(vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  vec2 h = uv - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return smoothstep(r, 0.5*r, d);\n}\n\n//--- draw circle at pos with given radius ---\nfloat circle(in vec2 pos, in float radius, in float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n\n//--- draw ring at given position ---\nfloat ring(vec2 pos, float radius, float thick)\n{\n  return mix(1.0, 0.0, smoothstep(thick, thick + 0.01, abs(length(uv-pos) - radius)));\n}\n*/\n\n//== font handling ===============================\n\n#define FONT_SIZE 0.4\n#define FONT_SPACE 0.5\n\nvec2 tp = vec2(0.0);  // text position\n\nuniform sampler2D fontTexture;\n\n//--- access to font image of ascii code characters ---\n\n#define SPACE tp.x -= FONT_SPACE;\n#define _     tp.x -= FONT_SPACE;\n\n#define S(a) c+=char(a);  tp.x-=FONT_SPACE;\n\n#define _note  S(10);   // \n#define _star  S(28);   // *\n#define _smily S(29);   // :-)\n#define _exc   S(33);   // !\n#define _add   S(43);   // +\n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n\n//---------------------------------------------------------\n// return font image intensity of character ch at text position tp\n//---------------------------------------------------------\nfloat char(int ch)\n{\n  vec4 f = any(lessThan(vec4(tp,1,1), vec4(0,0,tp)))\n    ? vec4(0)\n    : texture(fontTexture,0.0625*(tp + vec2(ch - ch/16*16,15 - ch/16)));\n  return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n}\n//----------------------------------------------------------------\n// set text starting position to x=line, y=column (left/top = 1,1)\n//----------------------------------------------------------------\nvoid SetTextPosition(float x, float y)  //\n{\n  tp = uv / FONT_SIZE;\n  tp.x = tp.x +17. - x;\n  tp.y = tp.y -9.4 + y;\n}\n//----------------------------------------------------------------\nconst vec3 backColor = vec3(0.10, 0.10, 0.10);\n      vec3 drawColor = vec3(1.0, 1.0, 1.0);\n      vec3 vColor    = backColor;\n//------------------------------------------------\nvoid SetColor(float red, float green, float blue)\n{\n  drawColor = vec3(red,green,blue);\n}\n//------------------------------------------------\nvec3 WriteShadertoy(inout float c)\n{\n  SetTextPosition(13.4, 9.);\n  SetColor(0., 1., 1.);\n _F _R _A _C _T _A _L _  _F _A _N _T _A _S _Y \n\n  return c * drawColor;\n}\n//------------------------------------------------\n// WebGL version info: http://webglreport.com/?v=2\n//------------------------------------------------\nvec3 WriteWebGL(inout float c)\n{\n  SetTextPosition(14., 9.);\n  SetColor(1., 0., 1.);\n   _V _I _R _T _U _A  \n\n  return vColor + c * drawColor;\n}\n\n//================================================\nvoid setGlobals( in vec2 iResolution, in vec2 fragCoord)\n{\n  resolution = iResolution;\n  aspect = resolution.x / resolution.y;\n  ratio = vec2(aspect, 1.0);\n  pixelPos = fragCoord.xy;  //  0 .. resolution\n  uv = (2.0*fragCoord.xy - resolution) / resolution.y;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//--------------------------------------------------\n// ShadertoyReactionDiffusion3d_BufferA.glsl\n//\n// Buffer A/B/C/D are duplicated to get higher speed \n//  without killing accuracy too much.\n//\n// iChannel2 is used as simulation input channel\n//--------------------------------------------------\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(inputChannel, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(inputChannel, uv + pixelSize).xy +\n            texture(inputChannel, uv - pixelSize).xy +\n            texture(inputChannel, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvec2 CalcReactionDiffusion (in vec2 uv)   \n{\n    // compute diffusion\n    vec2 current = clamp(texture(inputChannel, uv).xy, vec2(0.), vec2(1.));\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // compute reaction\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // apply using simple forward Euler\n    return current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y += 0.0006;   // move down\n\n    // calculate 2d reaction diffusion \n    vec2 newValue = CalcReactionDiffusion(uv);\n    fragColor += vec4(newValue, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//--------------------------------------------------\n// ShadertoyReactionDiffusion3d_BufferB.glsl\n//\n// Buffer A/B/C/D are duplicated to get higher speed \n//  without killing accuracy too much.\n//\n// iChannel2 is used as simulation input channel\n//--------------------------------------------------\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(inputChannel, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(inputChannel, uv + pixelSize).xy +\n            texture(inputChannel, uv - pixelSize).xy +\n            texture(inputChannel, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvec2 CalcReactionDiffusion (in vec2 uv)   \n{\n    // compute diffusion\n    vec2 current = clamp(texture(inputChannel, uv).xy, vec2(0.), vec2(1.));\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // compute reaction\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // apply using simple forward Euler\n    return current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n    // calculate 2d reaction diffusion \n    vec2 newValue = CalcReactionDiffusion(uv);\n    fragColor += vec4(newValue, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//--------------------------------------------------\n// ShadertoyReactionDiffusion3d_BufferC.glsl\n//\n// Buffer A/B/C/D are duplicated to get higher speed \n//  without killing accuracy too much.\n//\n// iChannel2 is used as simulation input channel\n//--------------------------------------------------\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(inputChannel, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(inputChannel, uv + pixelSize).xy +\n            texture(inputChannel, uv - pixelSize).xy +\n            texture(inputChannel, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvec2 CalcReactionDiffusion (in vec2 uv)   \n{\n    // compute diffusion\n    vec2 current = clamp(texture(inputChannel, uv).xy, vec2(0.), vec2(1.));\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // compute reaction\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // apply using simple forward Euler\n    return current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n    // calculate 2d reaction diffusion \n    vec2 newValue = CalcReactionDiffusion(uv);\n    fragColor += vec4(newValue, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n//--------------------------------------------------\n// ShadertoyReactionDiffusion3d_BufferD.glsl\n//\n// Buffer A/B/C/D are duplicated to get higher speed \n//  without killing accuracy too much.\n// BufferD additional handles key action and drawing\n//\n// iChannel0 hold the font image \n// iChannel1 hold random rgb image \n// iChannel2 is used as simulation input channel\n// iChannel3 is used as key input channel\n//--------------------------------------------------\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(inputChannel, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(inputChannel, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(inputChannel, uv + pixelSize).xy +\n            texture(inputChannel, uv - pixelSize).xy +\n            texture(inputChannel, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(inputChannel, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvec2 CalcReactionDiffusion (in vec2 uv)   \n{\n    // compute diffusion\n    vec2 current = clamp(texture(inputChannel, uv).xy, vec2(0.), vec2(1.));\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // compute reaction\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v +  FeedRate * (1. - u);\n    float reactionV =   u * v * v - (FeedRate + KillRate) * v;\n    \n    // apply using simple forward Euler\n    return current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n}\n\n//==========================================================\n//  k e y    handling\n//==========================================================\nconst int KEY_SPACE = 32;\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\nconst int KEY_F5 = 116;\n//----------------------------------------------------------\n// return true if given key is pressed\n//----------------------------------------------------------\nbool KeyPressed(int key) \n{\n  return texture(iChannel3, vec2(key,0.25) / 256.0).x > 0.5;\n}\n\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = abs(fragCoord.xy / iResolution.xy);\n    setGlobals(iResolution.xy, fragCoord);\n\n    // initialize / draw\n    vec2 sp = (iResolution.xy * 0.5 - fragCoord) / iResolution.y;\n    if((iTime < 0.5) || KeyPressed(KEY_SPACE))\n    {                       // wobbled circles \n        sp += sin(atan(sp.x, sp.y)*20.0) * 0.01; \n        float distSqr = dot(sp, sp);\n        float initVal = pow(sin(distSqr * 40.0) * 0.5 + 0.5, 5.0);\n        fragColor = vec4(1.0, initVal, 0.0, 1.0);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F1))  // circles\n    {\n        float distSqr = dot(sp, sp);\n        float initVal = pow(sin(distSqr * 40.0) * 0.5 + 0.5, 5.0);\n        fragColor = vec4(1.0, initVal, 0.0, 1.0);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F2)) \n    {\n        float distSqr = sp.x*sp.y;\n        float initVal = pow(sin(distSqr * 40.0) * 0.5 + 0.5, 5.0);\n        fragColor = vec4(1.0, initVal, 0.0, 1.0);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F3))    // random dots\n    {\n        uv.x *= aspect;\n        fragColor = texture(iChannel1, uv*0.1+iTime*0.01);\n        return;\n    }\n    \n    float ci = 0.0; \n    if(KeyPressed(KEY_F4))    // add '* Shadertoy *'\n    {\n        fragColor = vec4(WriteShadertoy(ci), 1.0);\n        //return;\n    }\n    \n    if(KeyPressed(KEY_F5))    // clear all dots\n    {\n        fragColor = vec4(0.5);\n//        return;\n    }\n    \n    // draw ellipse disk with mouse\n    vec2 mp = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0. && length(mp - uv) < 0.02) \n        fragColor = vec4(0.5);\n\n    // calculate 2d reaction diffusion \n    vec2 newValue = CalcReactionDiffusion(uv);\n//    fragColor = vec4(newValue, 0.0, 1.0);\n    \n    int t = int (iTime*10.) % 120;\n    if (t < 20)\n    {\n      WriteShadertoy(ci);\n      if (ci > 0.) newValue += vec2(0.1*ci, ci);\n    }\n    else if ((t > 60) && (t < 80))\n    {\n      WriteWebGL(ci);  \n      if (ci > 0.) newValue += vec2(0.1*ci, ci);\n    }\n    fragColor += vec4(newValue, 1.0, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}