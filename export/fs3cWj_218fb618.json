{"ver":"0.1","info":{"id":"fs3cWj","date":"1654035479","viewed":268,"name":"Entwined Circular Rings","username":"fizzer","description":"I loved the 3D renders of entwined rings from [url=https://archive.bridgesmathart.org/2007/bridges2007-81.html]this paper[/url] so much that I just had to re-create one of them.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["torus","reproduction","entwined"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A re-creation of one of the entwined rings renders from\n// https://archive.bridgesmathart.org/2007/bridges2007-81.html\n\nconst float pi = 3.14159265358979323;\nfloat r0, r1, th, s, r2;\n\n// Torus SDF and local position\nvec4 torus(vec3 p)\n{\n    vec2 q = vec2(length(p.xy) - r0, p.z);\n    return vec4(p, length(q) - r1);\n}\n\n// Rows of touching and alternating tori\nvec4 torusField(vec3 p)\n{\n    float period = (r2 + r1) * 2.;\n    float flip = mod(floor(p.y / period), 2.) * 2. - 1.;\n    p.y = (mod(p.y, period) - period / 2.) * flip;\n    p.yz = mat2(cos(th), sin(th), -sin(th), cos(th)) * p.yz;\n    p.x = mod(p.x, s) - s / 2.;\n    return torus(p);\n}\n\n// Combined cris-crossing tori\nvec4 torusField2(vec3 p)\n{\n    vec4 a = torusField(p);\n    vec4 b = torusField((p + vec3(s, s, 0) / 2.).yxz * vec3(1, 1, -1));\n    return a.w < b.w ? a : b;\n}\n\n// Separate distances and local positions (except floor) for material shading\nmat3x4 scene(vec3 p)\n{\n    p = p.xzy;\n    mat3x4 res;\n\n    res[0] = torusField2(p);\n    res[1] = torusField2(p + vec3(s, s, 0) / 2.);\n    res[2].w = p.z + (r0 * sin(th) + r1);\n\n    return res;\n}\n\nfloat map(vec3 p)\n{\n    mat3x4 res = scene(p);\n    return min(res[0].w, min(res[1].w, res[2].w));\n}\n\nvec3 distG(vec3 p)\n{\n    vec2 e = vec2(1e-3, 0);\n    return vec3(map(p + e.xyy), map(p + e.yxy), map(p + e.yyx)) -\n        vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n}\n\n// Soft shadow for SDF, from IQ and Sebastian Aaltonen:\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique, float s )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<70; i++ )\n    {\n        float h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n            res = min( res, s*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, s*d/max(0.0,t-y) );\n            ph = h;\n        }\n\n        t += h;\n\n        if( res<0.0001 || t>tmax ) break;\n\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Ambient Occlusion\n// From Simon Green and others..\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 5;\n    const float delta = 0.2;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    r0 = .5;\n    r1 = .045;\n    th = .9 + cos(iTime / 2.) * .2;\n    s = (r0 * cos(th) + r1) * 4.;\n    r2 = r0 * cos(th);\n\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    // Camera position and target.\n    vec3 campos = vec3(1.0, 3.0, -3.0);\n    vec3 camtarget = vec3(0);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 2.5));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n    \n    if(iMouse.z > 0.)\n        ro.xz += (iMouse.xy - iResolution.xy / 2.) / iResolution.xy * 5.;\n    \n    // SDF raymarching.\n    float t = 2.;\n    for(int i = 0; i < 80; ++i)\n    {\n        float d = map(ro + rd * t);\n        if((d) < 1e-3)\n            break;\n        if(t > 1e4)\n            break;\n        t += d;\n    }\n    \n    fragColor.rgb = vec3(0);\n    \n    if(t > 100.)\n    {\n        // Far clipping\n        fragColor.rgb = vec3(.1);\n    }\n    else\n    {\n        vec3 rp = ro + rd * t;\n\n        mat3x4 m = scene(rp);\n\n        // Material index\n        int matID;\n        if(m[0].w < m[1].w && m[0].w < m[2].w)\n            matID = 0;\n        else if(m[1].w < m[2].w)\n            matID = 1;\n        else\n            matID = 2;\n        \n        vec3 n = normalize(distG(ro + rd * t));\n\n        // Shadows.\n        vec3 r = reflect(rd, n);\n        vec3 ld = normalize(vec3(1.6, 1.5, 1));\n        float sh = calcSoftshadow(rp, ld, 1e-3, 10., 1, 9.);\n        float sh2 = calcSoftshadow(rp, r, 1e-2, 10., 1, matID == 2 ? 64. : 6.);\n        float sh3 = pow(clamp(ambientOcclusion(rp, n), 0., 1.), 2.);\n\n        // Surface colour.\n        vec3 diff;\n\n        if(matID == 2)\n        {\n            // Floor\n            diff = mix(vec3(.95), vec3(.95, .32, .1), .1) * .2 * texture(iChannel2, rp.xz * 2.).rgb;\n        }\n        else\n        {\n            // Tori\n            vec3 p = m[matID].xyz;\n            vec2 q = vec2(length(p.xy) - r0, p.z);\n            vec2 uv = vec2(atan(q.y, q.x), p.z);\n            float a = atan(q.y, q.x) / pi + atan(p.y, p.x) / pi;\n            vec3 col0 = matID == 1 ? vec3(.95) : vec3(.03, .03, 1);\n            vec3 col1 = matID == 1 ? vec3(1, .02, .02) : vec3(.03, 1., .5);\n            diff = mix(col0, col1, clamp((min(fract(a) * 2., 2. - fract(a) * 2.) - .5) * 20., 0., 1.));\n        }\n\n        // Fresnel\n        float fr = pow(clamp(1. - dot(n, -rd), 0.1, 1.), 2.) * (matID == 2 ? .2 : 1.);\n\n        // Lighting\n        vec3 l = mix(vec3(0), vec3(1.), sh) * max(0., dot(n, ld)) * .9 +\n                 vec3(sh3) * vec3(.4, .5, .7) * .5 + .0;\n\n        // Combined material and lighting\n        fragColor.rgb = mix(l * diff, (textureLod(iChannel0, r, matID == 2 ? 0. : 4.).rrr * sh2 + .025), fr);\n        \n        // Fog\n        fragColor.rgb = mix(vec3(.6) * vec3(.4, .5, .7).bgr, fragColor.rgb, exp2(-t * .005));\n      }\n\n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + .4)*.8;\n  \n    // Gamma + dither\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2)) +\n        \t\t\t\ttexelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rgb / 200.;\n}","name":"Image","description":"","type":"image"}]}