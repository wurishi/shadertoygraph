{"ver":"0.1","info":{"id":"4sffRj","date":"1731549547","viewed":1409,"name":"Marching Cubes Basis","username":"gltracy","description":"Marching Cubes basis configurations with ambiguity cases","likes":58,"published":1,"flags":0,"usePreview":1,"tags":["marchingcubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////\n// csg\nfloat opUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\n///////////////////////////////////////////////////\n// 2d primitive\nfloat udBox( vec2 v, vec2 a, vec2 b ) {\n    return length( v - clamp( v, a, b ) );\n}\n\nfloat sdDot( vec2 v, vec2 c, float r ) {\n    return length( v - c ) - r;\n}\n\nfloat udLine( vec2 v, vec2 p0, vec2 p1 ) {\n    p1 -= p0;\n    v  -= p0;\n    \n    float e = dot( v, p1 ) / dot( p1, p1 );\n    \n    return length( v - p1 * clamp( e, 0.0, 1.0 ) );\n}\n\n// @iq : https://www.shadertoy.com/view/XsXSz4\nfloat sdTri( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n///////////////////////////////////////////////////\n// 2d graphics\nvec4 sl_colorBuffer;\nvec4 sl_color;\nfloat sl_size;\nfloat sl_sharp;\nmat3 sl_mat;\n\nvoid slClearColor( float r, float g, float b, float a ) {\n    sl_colorBuffer = vec4( r, g, b, a );\n}\n\nvoid slColor( vec4 c ) {\n    sl_color = c;\n}\n\nvoid slSize( float s ) {\n    sl_size = s;\n}\n\nvoid slSharp( float s ) {\n    sl_sharp = s;\n}\n\nvoid slIdentity( void ) {\n    sl_mat = mat3( 1.0 );\n}\n\nvoid slMat( mat3 m ) {\n    sl_mat = m;\n}\n\nvec2 slMap( vec2 v ) {\n    vec3 p = sl_mat * vec3( v, 1.0 );\n    return p.xy / p.z;\n}\n\nfloat slMap( float v ) {\n    vec3 p = sl_mat * vec3( v, v, 0.0 );\n    return length( p.xy ) / sqrt( 2.0 );\n}\n\nvoid slDraw( float d )\t{\n    float size = slMap( sl_size );\n    float sharp = sl_sharp;\n    \n    float e = smoothstep( size * clamp( sharp, 0.0, 1.0 ), size, d );\n    \n    sl_colorBuffer.xyz = mix( sl_colorBuffer.xyz, sl_color.xyz, ( 1.0 - e ) * sl_color.a );\n}\n\nvec4 slGetPixel( void ) {\n    return sl_colorBuffer;\n}\n\n///////////////////////////////////////////////////\n// matrix\nfloat mtDet( mat2 m ) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\n\nmat3 mtMove( float x, float y ) {\n    return mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, 1.0);\n}\n\nmat3 mtScale( float x, float y ) {\n    return mat3( x, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat3 mtRot( float angle ) {\n    angle = radians( angle );\n    float c = cos( angle );\n    float s = sin( angle );\n    return mat3( c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////\n// Marching Cubes\nconst float MC_H = 0.288675; // 0.5 / sqrt( 3.0 )\nvec2 mc_verts[8], mc_edge_mids[12];\nvec4 mc_line_color = vec4( 0.0, 0.0, 0.0, 1.0 );\nvec4 mc_vert_color = vec4( 1.0, 0.3, 0.2, 1.0 );\nvec4 mc_face_color  = vec4( 0.4, 0.7, 1.0, 0.6 );\nvec4 mc_face_color2 = vec4( 1.0, 0.6, 0.0, 0.6 );\nvec4 mc_face_color3 = vec4( 1.0, 0.4, 0.3, 0.6 );\nvec4 mc_face_color4 = vec4( 0.6, 0.9, 0.3, 0.6 );\n\nvoid mcInit( void ) {\n    mc_verts[0] = vec2( 0.0, 0.0 );\n    mc_verts[1] = vec2( 1.0, 0.0 );\n    mc_verts[2] = vec2( 0.0 + 0.5, 0.0 + MC_H );\n    mc_verts[3] = vec2( 1.0 + 0.5, 0.0 + MC_H );\n\n    mc_verts[4] = vec2( 0.0, 1.0 );\n    mc_verts[5] = vec2( 1.0, 1.0 );\n    mc_verts[6] = vec2( 0.0 + 0.5, 1.0 + MC_H );\n    mc_verts[7] = vec2( 1.0 + 0.5, 1.0 + MC_H );\n\n    mc_edge_mids[0]  = (mc_verts[0] + mc_verts[1]) * 0.5;\n    mc_edge_mids[1]  = (mc_verts[2] + mc_verts[3]) * 0.5;\n    mc_edge_mids[2]  = (mc_verts[4] + mc_verts[5]) * 0.5;\n    mc_edge_mids[3]  = (mc_verts[6] + mc_verts[7]) * 0.5;\n    \n    mc_edge_mids[4]  = (mc_verts[0] + mc_verts[2]) * 0.5;\n    mc_edge_mids[5]  = (mc_verts[4] + mc_verts[6]) * 0.5;\n    mc_edge_mids[6]  = (mc_verts[1] + mc_verts[3]) * 0.5;\n    mc_edge_mids[7]  = (mc_verts[5] + mc_verts[7]) * 0.5;\n    \n    mc_edge_mids[8]  = (mc_verts[0] + mc_verts[4]) * 0.5;\n    mc_edge_mids[9]  = (mc_verts[1] + mc_verts[5]) * 0.5;\n    mc_edge_mids[10] = (mc_verts[2] + mc_verts[6]) * 0.5;\n    mc_edge_mids[11] = (mc_verts[3] + mc_verts[7]) * 0.5;\n}\n\n// no vertex 5\nvoid mcCubeBack( vec2 u ) {\n    slColor( mc_line_color );\n    \n    slDraw( udLine( u, mc_verts[0], mc_verts[1] ) );\n    slDraw( udLine( u, mc_verts[2], mc_verts[3] ) );\n    slDraw( udLine( u, mc_verts[6], mc_verts[7] ) );\n    \n    slDraw( udLine( u, mc_verts[0], mc_verts[2] ) );\n    slDraw( udLine( u, mc_verts[1], mc_verts[3] ) );\n    slDraw( udLine( u, mc_verts[4], mc_verts[6] ) );\n    \n    slDraw( udLine( u, mc_verts[0], mc_verts[4] ) );\n    slDraw( udLine( u, mc_verts[2], mc_verts[6] ) );\n    slDraw( udLine( u, mc_verts[3], mc_verts[7] ) );\n}\n\nvoid mcCubeFront( vec2 u ) {\n    slColor( mc_line_color );\n    \n    slDraw( udLine( u, mc_verts[4], mc_verts[5] ) );\n    slDraw( udLine( u, mc_verts[5], mc_verts[7] ) );\n    slDraw( udLine( u, mc_verts[1], mc_verts[5] ) );\n}\n\nvoid mcTri( vec2 u, vec2 v0, vec2 v1, vec2 v2 ) {\n    float sd = sdTri( u, v0, v1, v2 );\n    slDraw( max(sd, 0.0) );\n    \n    slColor( mc_line_color );\n    slDraw( abs(sd) );\n}\n\nvoid mcVerts( vec2 u, int bits ) {\n    int mask = 256;\n    for ( int i = 7; i >= 0; i-- ) {\n        mask /= 2;\n        if ( bits >= mask ) {\n            bits -= mask;\n            \n            float sd = sdDot( u, mc_verts[i], 0.05 );\n            \n            slColor( mc_vert_color );\n            slDraw( max(sd, 0.0) );\n            \n            slColor( mc_line_color );\n            slDraw( abs(sd) );\n        }\n    }\n}\n\nbool mcCheck( vec2 v ) {\n    return udBox( v, vec2( 0.0 ) - 0.1, vec2( 1.0 + 0.5, 1.0 + MC_H ) + 0.1 ) <= 1e-6;\n}\n\n///////////////////////////////////////////////////\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init context\n    slSize( 2.0 );\n    slSharp( 0.0 );\n    slIdentity();\n\n    // clear buffer\n    slClearColor( 1.0, 1.0, 1.0, 1.0 );\n\n    // camera\n    float scale = 6.0 / iResolution.y;\n    mat3 M = mtMove( 0.5 + 0.25, 0.5 + MC_H * 0.5 - 0.8 ) * mtScale( scale, scale );\n    \n    // pixel pos\n    vec2 u = fragCoord.xy - iResolution.xy * 0.5;\n\n    // init marching cube list\n    mcInit();\n    \n    // case 0\n\tslMat( mtMove( +4.0, -1.5 ) * M );\n    {\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcCubeFront( v );\n        }\n    }\n   \n    // case 1\n\tslMat( mtMove( 2.0, -1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );   \n        \tslColor( mc_face_color ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[8] );\n    \t\tmcCubeFront( v );\n \t\t\tmcVerts( v, 1 );\n        }\n    }\n    \n    // case 2\n\tslMat( mtMove( 0.0, -1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );   \n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[8], mc_edge_mids[6] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[6], mc_edge_mids[8], mc_edge_mids[9] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 2 );\n    \t}\n    }\n\n    // case 3\n\tslMat( mtMove( -2.0, -1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );    \n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[8] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[9], mc_edge_mids[2], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 32 );\n        }\n    }   \n\n    // case 4\n\tslMat( mtMove( -4.0, -1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[9] );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[10], mc_edge_mids[9] );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[9], mc_edge_mids[10], mc_edge_mids[11] );\n            mcCubeFront( v );\n            mcVerts( v, 2 + 8 );\n        }\n    }\n\n    // case 5\n\tslMat( mtMove( +4.0, 0.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[8], mc_edge_mids[11], mc_edge_mids[9] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[8], mc_edge_mids[10], mc_edge_mids[11] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 2 + 8 );\n        }\n    }\n   \n    // case 6\n    slMat( mtMove( +2.0, 0.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 ); \n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[9] );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[10], mc_edge_mids[9] );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[9], mc_edge_mids[10], mc_edge_mids[11] );\n            slColor( mc_face_color  ); mcTri( v, mc_edge_mids[8], mc_edge_mids[5], mc_edge_mids[2] );\n            mcCubeFront( v );\n            mcVerts( v, 2 + 8 + 16 );\n        }\n    }\n \n    // case 7\n\tslMat( mtMove( 0.0, 0.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v ); \n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[1], mc_edge_mids[11], mc_edge_mids[6] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[10], mc_edge_mids[5], mc_edge_mids[3] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[8] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[9], mc_edge_mids[2], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 8 + 32 + 64 );\n        }\n    } \n    \n    // case 8\n\tslMat( mtMove( -2.0, 0.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );   \n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[11], mc_edge_mids[6] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[8], mc_edge_mids[3] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[3], mc_edge_mids[11] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[8], mc_edge_mids[5], mc_edge_mids[3] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 8 + 64 );\n        }\n\t}\n  \n    // case 9\n\tslMat( mtMove( -4.0, 0.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[5] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[5], mc_edge_mids[11] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[9], mc_edge_mids[11] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[5], mc_edge_mids[3], mc_edge_mids[11] );\n            mcCubeFront( v );\n            mcVerts( v, 2 + 8 + 64 );\n        }\n    }\n    \n    // case 10\n\tslMat( mtMove( +4.0, +1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );   \n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[8] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[11], mc_edge_mids[3], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 128 );\n        }\n    } \n\n    // case 11\n\tslMat( mtMove( +2.0, +1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[8], mc_edge_mids[6] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[6], mc_edge_mids[8], mc_edge_mids[9] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[11], mc_edge_mids[3], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 2 + 128 );\n        }\n    }\n    \n    // case 12\n\tslMat( mtMove( 0.0, +1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v ); \n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[0], mc_edge_mids[9], mc_edge_mids[6] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[8], mc_edge_mids[5], mc_edge_mids[2] );\n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[11], mc_edge_mids[3], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 2 + 16 + 128 );\n        }\n    }\n\n   // case 13\n\tslMat( mtMove( -2.0, +1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );   \n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[5] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[5], mc_edge_mids[2] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[6], mc_edge_mids[1], mc_edge_mids[3] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[6], mc_edge_mids[3], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 8 + 16 + 128 );\n        }\n    }\n\n    // case 14\n\tslMat( mtMove( -4.0, +1.5 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[8], mc_edge_mids[10] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[10], mc_edge_mids[7] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[10], mc_edge_mids[3], mc_edge_mids[7] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[7], mc_edge_mids[6] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 8 + 128 );\n        }\n    }\n    \n     // case 3c\n\tslMat( mtMove( 2.0, +3.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[4], mc_edge_mids[9] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[7], mc_edge_mids[9] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[2], mc_edge_mids[7] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[8], mc_edge_mids[2] );\n            mcCubeFront( v );\n            mcVerts( v, 2 + 8 + 16 + 64 + 128 );\n        }\n    }\n    \n    // case 6c\n\tslMat( mtMove( 0.0, +3.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );   \n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[3], mc_edge_mids[6] );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[4], mc_edge_mids[8], mc_edge_mids[3] );\n            slColor( mc_face_color3 ); mcTri( v, mc_edge_mids[6], mc_edge_mids[3], mc_edge_mids[11] );\n            \n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[8], mc_edge_mids[3], mc_edge_mids[9] );\n            slColor( mc_face_color2 ); mcTri( v, mc_edge_mids[9], mc_edge_mids[3], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 8 + 16 + 32 + 64 );\n        }\n\t}\n    \n    // case 7c\n\tslMat( mtMove( -2.0, +3.0 ) * M );\n  \t{\n        vec2 v = slMap(u);\n        if ( mcCheck( v ) ) {\n            mcCubeBack( v );\n            mcVerts( v, 4 );   \n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[11], mc_edge_mids[6] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[8], mc_edge_mids[3] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[0], mc_edge_mids[3], mc_edge_mids[11] );\n            slColor( mc_face_color4 ); mcTri( v, mc_edge_mids[8], mc_edge_mids[5], mc_edge_mids[3] );\n            \n            slColor( mc_face_color ); mcTri( v, mc_edge_mids[9], mc_edge_mids[2], mc_edge_mids[7] );\n            mcCubeFront( v );\n            mcVerts( v, 1 + 8 + 32 + 64 );\n        }\n\t}\n    \n    fragColor = slGetPixel();\n}","name":"Image","description":"","type":"image"}]}