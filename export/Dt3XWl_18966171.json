{"ver":"0.1","info":{"id":"Dt3XWl","date":"1685842959","viewed":115,"name":"Heartbreaker","username":"luckyballa","description":"Particle Voronoi Tracking + XPBD == <3\n\nUse mouse to add some fun ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["collision","sss","simulation","particles","specular","jelly","voronoitracking","xpbd","selfcollision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const uint PARTICLE_COUNT = 750u;\nconst float MAX_VEL = 10.0;\nconst float MOUSE_BRUSH_RADIUS = 96.0;\nconst float DAMPING = 0.8;\nconst float RADIUS = 8.0;\n\n#define MAX_VELOCITY (MAX_VEL - MAX_VEL * smoothstep(1.0, 4.0, iTime) * 0.5 + MAX_VEL * (iMouse.z > 0.0 ?  0.1 : 0.0))\n\n\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\n#define PI 3.14159265\n\nstruct Entity {\n    vec2 position;\n    vec2 oldPosition;\n};\n\nconst Entity INVALID_ENTITY = Entity(vec2(-FLOAT_INF), vec2(0));\n\n\nuint wrap1d(uint flatId) {\n    return flatId % PARTICLE_COUNT;\n}\n\nvec2 wrap2d(vec2 id, vec2 resolution) {\n    return fract(id / resolution) * resolution;\n}\n\nuint to1d(vec2 id, vec2 resolution) {\n    return uint(id.x + id.y * resolution.x);\n}\n\nivec2 to2d(uint flatId, ivec2 resolution) {\n    return ivec2(flatId, flatId / uint(resolution.x)) % resolution;\n}\n\nEntity decodeEntity(sampler2D sampler, ivec2 id) {\n    vec4 raw = texelFetch(sampler, id, 0);\n    Entity entity;\n    entity.position = raw.rg;\n    entity.oldPosition = raw.ba;\n    return entity;\n}\n\nEntity decodeEntity(sampler2D sampler, uint flatId) {\n    return decodeEntity(sampler, to2d(flatId, textureSize(sampler, 0)));\n}\n\nvec4 encodeEntity(Entity entity) {\n    return vec4(entity.position, entity.oldPosition);\n}\n\nuvec4 fetchClosest(vec2 position, sampler2D voroBuffer) {\n    return floatBitsToUint(texelFetch(voroBuffer, ivec2(wrap2d(position, vec2(textureSize(voroBuffer, 0)))), 0));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\nuint rngSeed = 314159265u;\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\n\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat  dot2(vec2 v) { return dot(v, v); }\n\nfloat sdHeart(vec2 uv) { \n    return length(vec2(uv.x,uv.y - pow(abs(uv.x) * 0.45, 0.8)));\n}\n\nvec4 gsdHeart(vec2 uv) {\n  vec2 st = vec2(0.001);\n  float height = sdHeart(uv);\n\n  vec2 dxy = height - vec2(sdHeart(uv + vec2(st.x, 0.)),  sdHeart(uv + vec2(0., st.y)));\n    \n  return vec4(normalize(vec3(dxy * 2. / st, 1.)), height);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint flatID = to1d(floor(fragCoord), vec2(textureSize(iChannel0, 0)));\n    fragColor = encodeEntity(INVALID_ENTITY);\n    if (flatID >= PARTICLE_COUNT)\n        return;\n\n    uint flatSeed = murmur3(flatID); \n    rngSeed = flatSeed;\n\n    Entity current;\n    if (iFrame <= 8) {\n        float count = float(PARTICLE_COUNT);\n        current.position += vec2(nextFloat(), nextFloat()) * iResolution.xy;\n        current.oldPosition = current.position + vec2(nextFloat(), nextFloat()) * ((current.position / iResolution.xy) - 0.5) * iResolution.xy * 0.1;\n    } else {\n        current = decodeEntity(iChannel0, flatID);\n    }\n\n    vec2 p = current.position / iResolution.xy; p -= 0.5;\n    \n    float time = mod(iTime, 1.2);\n    float animation = pow(time, 0.75) * 0.5;\n    animation += sin(time * PI * 2.0 * -(p.y + 0.5) + dot2(p)) * exp(-time * 6.0);\n\n    float RADIUS = RADIUS * 0.5 + RADIUS * animation * 0.75;\n    RADIUS *= mix(1.0, 0.75, step(0., iMouse.z));\n    \n    vec2 force = gsdHeart(p).xy  * 60.0 * pow(abs(sdHeart(p)), 0.5) * (iMouse.z > 0.0 ?  0.444 : 1.0);\n    force += vec2(sin(float(flatID) + iTime + fragCoord.x), cos(float(flatID) + iTime + fragCoord.y)) * 8.0;\n\n    if (sign(iMouse.z) > 0.) {\n        vec2 diff = iMouse.xy - current.position;\n        float strength = 1.0 - length(diff) / MOUSE_BRUSH_RADIUS;\n        if (strength > 0.0) {\n            force += vec2(diff.y, -diff.x) * smoothstep(0., 1., strength) * 4.0;\n        }\n    }\n\n    vec2 velocity = current.position - current.oldPosition;\n    float v = length(velocity);\n    vec2 normalizedVelocity = velocity / max(v, 0.00001);\n    float dv = -v * DAMPING * iTimeDelta;\n    velocity += normalizedVelocity * dv;\n    velocity = clamp(velocity, -MAX_VELOCITY, MAX_VELOCITY);\n    \n    vec2 oldPosition = current.position;\n    current.position = clamp(current.position, vec2(RADIUS), iResolution.xy - vec2(RADIUS));\n    current.position += velocity + 0.5 * force * iTimeDelta;\n\n    uvec4 closest = fetchClosest(current.position, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        if (closest[i] == flatID || closest[i] == -1u) {\n            continue;\n        }\n\n        Entity other = decodeEntity(iChannel0, closest[i]);\n\n        float r2 = RADIUS * 2.0;\n        vec2 delta = current.position - other.position;\n        float dist = length(delta);\n\n        if (dist < r2) {\n            float cost = (r2 - dist);\n            float compliance = 0.00001 / (iTimeDelta * iTimeDelta);\n            float lambda = -cost / (2.0 + compliance);\n            vec2 grad = delta / dist;\n            vec2 correction = grad * lambda;\n            \n            current.position -= correction;\n        }\n    }\n\n    current.oldPosition = oldPosition;\n\n    fragColor = encodeEntity(current);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec2 center\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    Entity e = decodeEntity(iChannel0, index);\n    float dist = length(center - e.position);\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvoid fetchAndSortClosest( inout vec4 distances, inout uvec4 idList, in vec2 samplePoint, in vec2 cellCenter ) {\n    uvec4 ids = fetchClosest(samplePoint, iChannel1);\n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, idList, ids[i], cellCenter);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 closestIndices = uvec4(-1);\n    vec4 bestDistances = vec4(FLOAT_INF);\n    \n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + vec2( 0, -1), fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + vec2( 0,  1), fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + vec2(-1,  0), fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + vec2( 1,  0), fragCoord);\n    \n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, wrap1d(nextUint()), fragCoord);\n    }\n\n    fragColor = uintBitsToFloat(closestIndices);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uvec4 closestIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(fragCoord), 0));\n   \n    float d = 10000.0;\n    float d2 = 10000.0;\n    vec2 p = fragCoord / iResolution.xy; p -= 0.5;\n\n    vec3 col = vec3(0.8, 0.2, 0.3);\n    for (int i = 3; i >= 0; i--) {\n        uint id =  closestIndices[i];\n        if (id == -1u)\n            break;\n            \n        Entity entity = decodeEntity(iChannel0, id);\n        float newDist = length(entity.position - fragCoord);\n        \n        d = smin(d, newDist, RADIUS * 3.0);\n        d2 = smin(d2, newDist, RADIUS * 8.0);        \n   }\n   \n   \n    float dx = dFdx(d2);\n    float dy = dFdy(d2);\n    vec3 normal = normalize(vec3((dx), (dy), 2.0));\n    \n    vec3 lightDir = normalize(vec3(0.8, 0.8, 1.25));\n    vec3 viewDir = vec3(0.0, 0.0, 1.0);\n    float diff = pow(max(dot(lightDir, abs(normal)), 0.0), 4.0);\n    diff = mix(diff, dot(lightDir, normal), -0.5);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 12.0); \n\n    col = col * 0.1 + (diff * col * 1.0) + (spec * mix(vec3(1.0), col, 0.5));\n    col *= smoothstep(RADIUS, RADIUS * 0.75, d);\n    col = clamp(col, 0.0, 1.0);\n    col = mix(col, texelFetch(iChannel2, ivec2(fragCoord), 0).xyz, 0.55 + 0.75 * length(p));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}