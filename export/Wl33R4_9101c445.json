{"ver":"0.1","info":{"id":"Wl33R4","date":"1575689072","viewed":132,"name":"fish scale UVs 2","username":"sp0rk3d","description":"changed it to allow radius changes. messing with animation and color","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["scales"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float N21(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = sin(iTime * 0.01) * 5. + 10.;\n    \n    // Normalized pixel coordinates (from 0 to scale)\n    float mRez = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/mRez;\n\tuv *= scale;\n    \n    //float radius = cos(iTime + uv.x) * 0.25 + 0.75; //animated\n    float radius = 0.75; //static    \n    uv += vec2(\tsin(uv.y - iTime * 0.33) * ((1. - (uv.x/scale)) * 0.1 + 0.01), \n              \tsin(uv.x + iTime * 0.66) * (uv.x/scale * 0.3 + 0.01)\n              );\n    \n    vec2 uvr = round(uv);\n    \n    // offset vectors from center of uvr in order of priority\n    vec2 p0 = vec2(1., -1.);\n    vec2 p1 = vec2(0., -1.);\n    vec2 p2 = vec2(0.5, -.5);\n    vec2 p3 = vec2(1., 0.);\n    vec2 p4 = vec2(-0.5, -0.5);\n    vec2 p5 = vec2(0.5, 0.5);\n    vec2 p6 = vec2(-0.5, 0.5);\n    \n\t// sclae ID\n    vec2 ID = vec2(0.);\n    // distance\n    float Dist = 0.; \n    \n    if(distance(uv, uvr + p0) < radius){\n        Dist = distance(uv, uvr + p0);\n    \tID = uvr + p0;    \n    }else if(distance(uv, uvr + p1) < radius){\n        Dist = distance(uv, uvr + p1);\n    \tID = uvr + p1;    \n    }else if(distance(uv, uvr + p2) < radius){\n        Dist = distance(uv, uvr + p2);\n    \tID = uvr + p2;    \n    }else if(distance(uv, uvr + p3) < radius){\n        Dist = distance(uv, uvr + p3);\n    \tID = uvr + p3;    \n    }else if(distance(uv, uvr + p4) < radius){\n        Dist = distance(uv, uvr + p4);\n    \tID = uvr + p4;    \n    }else if(distance(uv, uvr) < radius){\n        Dist = distance(uv, uvr);\n    \tID = uvr;    \n    }else if(distance(uv, uvr + p5) < radius){\n        Dist = distance(uv, uvr + p5);\n    \tID = uvr + p5;    \n    }else if(distance(uv, uvr + p6) < radius){\n        Dist = distance(uv, uvr + p6);\n    \tID = uvr + p6;    \n    }\n\n    \n    // distance from center to edge of scale\n    Dist /= radius;\n    \n    // per scale uv\n    vec2 suv = vec2(uv - ID)/radius;\n    \n    // randomized ID by hash noise\n    float rID = N21(ID);\n    \n    // color\n    vec3 colA = vec3(36.,126.,246.)/255.;\n    vec3 colB = vec3(26.,88.,234.)/255.;\n    vec3 colC = vec3(.95);\n    vec3 wave = mix(colA, colB, N21(ID));\n    \n    float m = cos(Dist * 6.28 * 4.25)* 0.5 + 0.5;\n    m = smoothstep(0., 14.*scale/mRez, m-.8);\n    \n    vec3 col = mix(colC, wave, m);\n    \n    // Output to screen\n    fragColor = vec4(col * (suv.y * 0.5 + 0.5),1.0);\n}","name":"Image","description":"","type":"image"}]}