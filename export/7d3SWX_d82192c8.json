{"ver":"0.1","info":{"id":"7d3SWX","date":"1634046613","viewed":118,"name":"Oscillating Cellular Automata","username":"16384","description":"A cellular automata with an oscillating neighborhood that creates growing rotated squares","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata","cellularautomaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//chromatic aberration for a cellular automata!\n//because why not, it looks kinda fun\n//you can disable it below if you don't like it though\n//just change 'true' below to 'false'\n\n#define chromaticAberration true\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (chromaticAberration) {\n        float r = length(uv - vec2(0.5, 0.5));\n        vec2 thetaVec = normalize(uv - vec2(0.5, 0.5));\n\n        float bMod = r * 1.0;\n        float gMod = r * 0.995;\n        float rMod = r * 0.99;\n\n        vec2 rPos = vec2(0.5,  0.5) + thetaVec * rMod;\n        vec2 gPos = vec2(0.5,  0.5) + thetaVec * gMod;\n        vec2 bPos = vec2(0.5,  0.5) + thetaVec * bMod;\n\n        float red = texture(iChannel0, rPos).r;\n        float green = texture(iChannel0, gPos).g;\n        float blue = texture(iChannel0, bPos).b;\n\n        vec3 col = vec3(red, green, blue);\n        fragColor = vec4(col, 1.0);\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define C(i, j) texture(iChannel0, uv + vec2(i, j) / iResolution.xy).x\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(0.0);\n    if(iMouse.w > 0.0 || iFrame == 0) {\n        fragColor = rand(vec2(uv.x+iTime, uv.y)) > 0.8 && abs(length(uv-vec2(0.5, 0.5))) < 0.5 ? fragColor = vec4(1.0) : vec4(0.0);\n    } else {\n        float m = mod(float(iFrame), 2.0);\n        int neighbors = int(m * C(-1.0, -1.0) + (1.0 - m) * C(0.0, -1.0) + m * C(1.0, -1.0) + (1.0 - m) * C(-1.0, 0.0) + m * C(1.0, 0.0) + (1.0 - m) * C(-1.0, 1.0) + m * C(0.0, 1.0) + (1.0 - m) * C(1.0, 1.0));\n        \n        fragColor = neighbors > 1 && neighbors < 4 ? vec4(1.0) : vec4(0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = mix(texture(iChannel0, uv), texture(iChannel1, uv), 0.9);\n    //Adding blur so it's not quite as harsh on the eyes\n    //uncomment next line to take away blur effect\n    //fragColor = texture(iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}