{"ver":"0.1","info":{"id":"l3lXzS","date":"1710175567","viewed":52,"name":"NegativeSpace VFX","username":"Eboman","description":"Mouse x = FX amount\nMouse y = FX parameter control\nPress key 1 to 7 on keyboard = FX parameter on/off\nFX parameter descriptions in top shader comment","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","vfx","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\nCONTROLS_________________:\n\nMouse x = FX amount\nMouse y = FX parameter control\nPress key 1 to 5 on keyboard = FX parameter on/off\n\nFX parameters:\n1 = Light effect on/off\n2 = Sphere size\n3 = Camera X position\n4 = lines\n5 = Disco pattern\n6 = Speed\n7 = Light amount\n\n\nCREDITS__________________:\n\nBased on the Cypher shader by dila  \nhttps://www.shadertoy.com/view/MlsGRS\n\nRemixed into a video effect by:\nwww.eboman.com\n\n*/\n\n#define uMzero  (1.-(iMouse.x/iResolution.x))\n#define uMone   ((iMouse.y/iResolution.y)*10.) * kp(49) + (1. *(1.-kp(49))) \n#define uMtwo   (iMouse.y/iResolution.y) * kp(50) + (1. *(1.-kp(50)))\n#define uMthree ((iMouse.y/iResolution.y) * kp(51) + (0. *(1.-kp(51))))\n#define uMfour  ((iMouse.y/iResolution.y) * kp(52) + (0. *(1.-kp(52))))\n#define uMfive  ((iMouse.y/iResolution.y) * kp(53) + (0. *(1.-kp(53))))\n#define uMsix   (iMouse.y/iResolution.y) * kp(54) + (1. *(1.-kp(54)))\n#define uMseven (iMouse.y/iResolution.y) * kp(55) + (0.5 *(1.-kp(55)))\n#define uMeight (iMouse.y/iResolution.y) * kp(56) + (1. *(1.-kp(56)))\n\n#define STEPS 100.\n#define SLOWRAY .7\n\nfloat kp(int k){\n    float kp = texelFetch( iChannel1, ivec2(k,2), 0 ).x;\n    return kp;\n}\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius*(1.3*uMtwo);\n}\n\nfloat box(vec3 p, float size) {\n    p = abs(p) - size;\n    \n    float rot = pow(sin(iTime), 3.)*uMzero; \n    \n    p = vec3(p.x*cos(rot)-p.y*sin(rot)-0.4,p.x*sin(rot)+p.y*cos(rot)-(0.4*(1.-pow(uMzero, 1.4))), p.z);\n    \n    return length(max(p,0.0)) - min(max(p.x,max(p.y,p.z)),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat map(vec3 p) {\n    p = mod(p, 3.) -1.5;\n    return max(\n        (-sphere(p, 1.3 + .26*pow(sin(iTime*2.), 3.)))*pow(uMzero, 1.4),\n        box(p*(0.4*uMfive*uMzero+1.), 1.1)\n    );\n}\n\nfloat map2(vec3 p) {\n    float d = sdBox(p, vec3(1,1,0.1));\n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 c = vec2(.001,0.);\n    return normalize(vec3(\n        map(p+c.xyy) - map(p-c.xyy),\n        map(p+c.yxy) - map(p-c.yxy),\n        map(p+c.yyx) - map(p-c.yyx)     \n        ));\n}\n\nfloat light(vec3 p, vec3 ldir) {\n    return dot(normal(p), ldir) * .7 + .3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float mx = iMouse.x/iResolution.x;\n    float my = pow(iMouse.y/iResolution.y, 0.5);\n    \n    vec3 raydir = normalize(vec3(uv, 1.5));\n\n    bool hit = false;\n    vec3 eye1 = vec3(0.,0.,0.);\n    vec3 eye2 = vec3((10.*(uMthree)*pow(uMzero, 3.)),0.,(iTime*uMsix+0.3*cos(iTime*4.)));\n    vec3 eye = mix(eye1, eye2, pow(uMzero, 0.5));\n    vec3 p = eye;\n    float shading = 0.;\n    \n    vec3 ldir = normalize(vec3(.5,1.,-3.));\n    \n    for (float step = 0.; step < STEPS; step++) {\n        float d1 = map(p)*(4.*uMfour*pow(uMzero, 0.8)+1.);\n        float d2 = map2(p);\n        float d = d1;\n        if (d < 0.01) {\n            hit = true;\n            shading = step/STEPS;\n            break;\n        }\n        p += d * raydir * SLOWRAY;\n    }\n\n    float texzoom = 1.9-(1.6*uMzero);\n    vec2 texpos = vec2(0.5+(0.2*uMzero), 0.5+(0.2*uMzero));\n\n    p.xy*=vec2(iResolution.y / iResolution.x, 1); \n\n    vec3 videoXZ =texture(iChannel0, fract(p.xz*texzoom*(50.*pow(uMfive*uMzero, 2.)+1.)+texpos)).rgb;\n    vec3 videoYZ =texture(iChannel0, fract(p.yz*texzoom*(50.*pow(uMfive*uMzero, 2.)+1.)+texpos)).rgb;\n    vec3 videoXY =texture(iChannel0, fract(p.xy*texzoom*(50.*pow(uMfive*uMzero, 2.)+1.)+texpos)).rgb;\n    \n   vec3 nl = abs(normal(p));\n\n    vec3 color = vec3(0.);\n    if (hit) color = mix(videoXZ*nl.y, videoXZ*nl.y, light(p,ldir))+\n                     mix(videoYZ*nl.x, videoYZ*nl.x, light(p,ldir))+\n                     mix(videoXY*nl.z, videoXY*nl.z, light(p,ldir))+\n                     -shading;    \n    \n    color = mix(color, vec3(.0,.0,.0), clamp(length(p-eye)/80., 0., 1.));\n\n  // Interface\n   \n    vec2 uvif = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uvif -= 0.5; \n    uvif /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 fcolif = color / pow(abs(mix(1., mix(p.y, fract(p.x), sin(iTime)), sin(iTime*1.6)*kp(49)*(10.*((uMseven*4.)*uMzero)*(sin(iTime))))), uMseven) +0.05; \n    \n    fcolif = mix( fcolif, vec3(0.,1.,1.), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.45))*15.))*(1.-mx) );\n    fcolif = mix( fcolif, vec3(0.,1.,1.), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.45))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.38))*15.))*kp(49) );\n    fcolif = mix( fcolif, vec3(1.0*kp(49)+0.5,1.0*(kp(49)*-1.5)+0.5,1.0*(kp(49)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.38))*15.-0.3))));\n\n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.31))*15.))*kp(50)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(50)+0.5,1.0*(kp(50)*-1.5)+0.5,1.0*(kp(50)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.31))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.24))*15.))*kp(51)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(51)+0.5,1.0*(kp(51)*-1.5)+0.5,1.0*(kp(51)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.24))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.17))*15.))*kp(52)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(52)+0.5,1.0*(kp(52)*-1.5)+0.5,1.0*(kp(52)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.17))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.10))*15.))*kp(53)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(53)+0.5,1.0*(kp(53)*-1.5)+0.5,1.0*(kp(53)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.10))*15.-0.3))));\n      \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.03))*15.))*kp(54)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(54)+0.5,1.0*(kp(54)*-1.5)+0.5,1.0*(kp(54)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.03))*15.-0.3))));\n      \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,-0.04))*15.))*kp(55)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(55)+0.5,1.0*(kp(55)*-1.5)+0.5,1.0*(kp(55)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,-0.04))*15.-0.3))));\n/*        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,-0.11))*15.))*kp(56)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(56)+0.5,1.0*(kp(56)*-1.5)+0.5,1.0*(kp(56)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,-0.11))*15.-0.3))));\n*/    \n    // Final output\n    \n    fragColor = vec4(fcolif,1.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}