{"ver":"0.1","info":{"id":"tlsfRH","date":"1706892452","viewed":55,"name":"Metaballs Derivative","username":"mathieu_h","description":"Click on the canvas to adjust resolution of the grid in polar coordinates.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["metaballsderivative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4.\n#define PI 3.14159265359\n#define epsilon .0001\n\n\nfloat crop (float x, float a, float b)\n{\n    if(a<x && x<b)\n    {\n        return 1.0;\n    }\n    else\n    {\n        return 0.;\n    }\n}\n\nvec3 hsv(in float h, in float s, in float v)\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn v * mix( vec3(1.0), rgb, s);\n}\n\n\nfloat metaball(vec2 p, float r)\n{\n\treturn r / dot(p, p);\n}\n\nfloat sampleSDF_D0(in vec2 uv)\n{\n    float t = iTime;\n    //t = 10.7;\n    float t0 = sin(t * 0.313) * .46;\n\tfloat t1 = sin(t * 0.405) * .49;\n\tfloat t2 = cos(t * 0.504) * .57;\n\n\tfloat r = metaball(uv + vec2(t0, t2), .33) *\n\t\t\t  metaball(uv - vec2(t0, t1), .27) *\n\t\t\t  metaball(uv + vec2(t1, t2), .59);\n\treturn r   ;\n}\n\nvec2 sampleSDF_D1(in vec2 uv)\n{\n    float v = sampleSDF_D0(uv);\n    return normalize(\n        vec2(sampleSDF_D0(uv + vec2(1.0,0.0) * epsilon) - v,\n        \t sampleSDF_D0(uv + vec2(0.0,1.0) * epsilon) - v))/epsilon;\n}\n\n\nfloat stripes(float v)\n{ \n    float k = 0.03;\n    if (iMouse.z > 0.0)\n    {\n        k = iMouse.y / iResolution.y;\n    }   \n    float wave = sin(log(log(v))*2.*PI * 10.*k);\n    float lines = 0.5*sign(wave)+.5;\n   \treturn lines;\n\n}\n\nfloat rays(vec2 d)\n{\n    float k = .03;\n    if (iMouse.z > 0.0)\n    {\n        k = iMouse.x / iResolution.x;\n    }\n    float t = 1.0;\n    float n = 10.0 + 1000.* k;\n    float angle = acos(dot(normalize(d),vec2(0.1,0.0)));\n    float wave = sin(angle * n);\n    float lines = 0.5*sign(wave)+.5;\n    return lines;\n}\n                      \nvec3 color_ramp_2d(vec2 uv)\n{\n    float angle = acos(dot(normalize(uv),vec2(0.1,0.0)));\n    return hsv(angle, 1.0 - length(uv/10000000. ), 1.0);\n}                      \n\nfloat inv(float x) {return 1.0-x;}\n\nvec3 samplef(in vec2 uv)\n{\n    float d0 = sampleSDF_D0(uv);\n\tvec2 d1 =  normalize(sampleSDF_D1(uv)) * d0;\n    \n    \n    float rays = rays(d1) ;\n    float stripes = stripes(d0);\n    vec3 c  = vec3(1.0) *  (rays * inv(stripes) + stripes * inv(rays));\n    //c = vec3(1.0) * d0;\n    //* (1.-crop(d0,.0,1.0))\n    //vec3 c  = vec3(1.0) * rays + stripes; \n        \n    //return vec3(1.0)*crop(d0,.1,0.4);\n    return c;\n    //return vec3(1.0) * rays;\n    //return stripes(d0);\n    //return color_ramp_2d(d1);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n\t\t\t* vec2(iResolution.x / iResolution.y, 1) * 1.25;\n    vec3 col = vec3(0);\n\n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += samplef(uv + vec2(i, j) * (e/AA)) / (4.*AA*AA);\n        }\n    }\n#else\n    col += samplef(uv);\n#endif /* AA */\n    \n    fragColor = vec4(clamp(col, 0., 1.), 1);\n}","name":"Image","description":"","type":"image"}]}