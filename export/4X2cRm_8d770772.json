{"ver":"0.1","info":{"id":"4X2cRm","date":"1727104020","viewed":12,"name":"TP18Infographie ","username":"Djeinaba_dia","description":"Ray  tracing ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lancer de rayon simple\n// Camera setup and ray direction\nvec3 getRayDirection(vec2 uv, vec3 ro, vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + uv.x * right + uv.y * up);\n}\n//Intersection avec des primitives simples\n//Sphere (ellipsoïde)\nfloat intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n    vec3 oc = ro - center;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n//Box (boîte parallèle aux axes du repère monde)\n//Pour une boîte alignée avec les axes :\nfloat intersectBox(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax) {\n    vec3 invDir = 1.0 / rd;\n    vec3 t0 = (boxMin - ro) * invDir;\n    vec3 t1 = (boxMax - ro) * invDir;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n    float tFar = min(min(tmax.x, tmax.y), tmax.z);\n    return (tNear > 0.0 && tNear < tFar) ? tNear : -1.0;\n}\n//Cylindre\n//Pour un cylindre aligné sur l'axe des y :\nfloat intersectCylinder(vec3 ro, vec3 rd, vec3 center, float radius, float height) {\n    vec3 oc = ro - center;\n    oc.y = 0.0;\n    rd.y = 0.0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - 4.0 * a * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sqrt(h)) / (2.0 * a);\n    float y = ro.y + t * rd.y;\n    return (y > center.y - height / 2.0 && y < center.y + height / 2.0) ? t : -1.0;\n}\n//Texture procédurale\nvec3 checkerPattern(vec3 p) {\n    float scale = 10.0;\n    float pattern = mod(floor(p.x * scale) + floor(p.y * scale) + floor(p.z * scale), 2.0);\n    return mix(vec3(1.0), vec3(0.0), pattern);\n}\n//Modèle d’éclairement de base (Lambert)\nvec3 lambertLighting(vec3 normal, vec3 lightDir, vec3 lightColor, vec3 objectColor) {\n    float diff = max(dot(normal, lightDir), 0.0);\n    return lightColor * objectColor * diff;\n}\n//Réflexion\nvec3 reflectRay(vec3 ro, vec3 rd, vec3 normal) {\n    return normalize(reflect(rd, normal));\n}\n//Occlusion ambiante\nfloat ambientOcclusion(vec3 p, vec3 normal) {\n    float ao = 0.0;\n    for (float i = 0.1; i < 1.0; i += 0.1) {\n        vec3 samplePos = p + normal * i;\n        if (intersectSphere(samplePos, normal, vec3(0.0), 1.0) > 0.0) ao += 1.0;\n    }\n    return 1.0 - ao * 0.1;\n}\n//Mise en place complète (Main Shader)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = getRayDirection(uv, ro, vec3(0.0));\n\n    // Scene intersection\n    float tSphere = intersectSphere(ro, rd, vec3(0.0), 1.0);\n    vec3 color;\n\n    if (tSphere > 0.0) {\n        vec3 p = ro + tSphere * rd;\n        vec3 normal = normalize(p);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n        vec3 objectColor = checkerPattern(p);\n        \n        // Lambert lighting\n        color = lambertLighting(normal, lightDir, lightColor, objectColor);\n        \n        // Reflection\n        vec3 reflectedRay = reflectRay(p, rd, normal);\n        \n        // Ambient occlusion\n        float ao = ambientOcclusion(p, normal);\n        color *= ao;\n    } else {\n        // Background color (sky blue)\n        color = vec3(0.5, 0.7, 1.0);  // RGB for sky blue\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}