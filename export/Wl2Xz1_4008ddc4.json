{"ver":"0.1","info":{"id":"Wl2Xz1","date":"1565069069","viewed":110,"name":"based on tynach & ixora","username":"genericUsername","description":"Simulates colorblindness. Clicking on the far left simulates full colorblindness, the center is normal vision, and the far right corrects by 100%. Try dragging the mouse around!\n\nFrom left→right, top→bottom:\nOriginal\nTritanomaly\nProtanomaly\nDeuteranomaly","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simulation","colorblind","protanopia","deuteranopia","tritanopia","lms","protanomaly","deuteranomaly","tritanomaly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// These constants come from the assumption that blue and white will be the same\n// for a protan as for normal colour vision. Also applies to Deutan. For tritans\n// the constant assumes red and white will be the same for a tritan as for normal\n// colour vision. see this website to learn more\n// http://ixora.io/projects/colorblindness/color-blindness-simulation-research/\n#define prot_a 1.05116\n#define prot_b -0.0511585\n#define deut_a 0.951331\n#define deut_b 0.0486687\n#define trit_a -0.86744736\n#define trit_b 1.86727089\n\n/*\n//matrix to convert linear RGB into XYZ colour space\n//obtained from www.brucelindbloom.com\nconst mat3 LINEAR_RGB_TO_XYZ = mat3(\n    0.4124564, 0.3575761, 0.1804375,\n    0.2126729, 0.7151522, 0.0721750,\n    0.0193339, 0.1191920, 0.9503041\n);\n\n// Matrix to convert XYZ into LMS colour space using Hunt-Pointer-Estevez\n// transformation.\nconst mat3 XYZ_TO_LMS = mat3(\n0.4002, 0.7076, -0.0808,\n-0.2263, 1.1653, 0.0457,\n0, 0, 0.9182\n);\n*/\n\n// The product of LINEAR_RGB_TO_XYZ * XYZ_TO_LMS\nconst mat3 LINEAR_RGB_TO_LMS = mat3(\n    0.31399022, 0.63951294, 0.04649755,\n    0.15537241, 0.75789446, 0.08670142,\n    0.01775239, 0.10944209, 0.87256922);\n\n// The inverse of LINEAR_RGB_TO_LMS\nconst mat3 LMS_TO_LINEAR_RGB = mat3(\n    5.47221206, -4.6419601, 0.16963708, \n    -1.1252419, 2.29317094, -0.1678952, \n    0.02980165, -0.19318073, 1.16364789);\n\nvec3 RBGToLinearRGB(vec3 color)\n{\n    /*\n    This is a piecewise math function to remove the gamma from RGB\n    when v <= 0.04045, v' = v/12.92\n    when v  > 0.04045, v' = ((v+0.055)/1.055)^2.4\n    */\n    for (int i = 0; i < 3; i++){\n        if (color[i] <= 0.04045) {\n            color[i] = (color[i]/12.92);\n        } else {\n            color[i] = pow(((color[i] + 0.055)/1.055), 2.4);\n        }\n    }\n    return color;\n}\n\nvec3 LinearRBGToRGB(vec3 color)\n{\n    /*\n    This is a piecewise math function to give the gamma to RGB\n    It does the inverse of this:\n    when v <= 0.04045, v' = v/12.92\n    when v  > 0.04045, v' = ((v+0.055)/1.055)^2.4\n    */\n    for (int i = 0; i < 3; i++){\n        if (color[i] <= 0.0031308) {\n            color[i] = (color[i]*12.92);\n        } else {\n            color[i] = 1.055*pow(color[i], 0.41666666666666666666666666666667) - 0.055;\n        }\n    }\n    return color;\n}\n\nvec3 RGBToLMS(vec3 color)\n{\n    color = RBGToLinearRGB(color);\n    color = color * LINEAR_RGB_TO_LMS;\n    return color;\n}\n\nvec3 LMSToRGB(vec3 color)\n{    \n    color = color * LMS_TO_LINEAR_RGB;\n    color = LinearRBGToRGB(color);\n    return color;\n}\n\nvec3 applyProtan(vec3 color, float multiplier)\n{\n    // Perform color blindness adjustments\n    mat3 protanMatrix = mat3(\n\t\t1.0 - multiplier, multiplier*prot_a, multiplier*prot_b,\n\t\t0.0, 1.0, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n    \n    color = color*protanMatrix;\n    return color;\n}\n\nvec3 applyDeutan(vec3 color, float multiplier)\n{\n    // Perform color blindness adjustments\n    mat3 deutanMatrix = mat3(\n\t\t1.0, 0.0, 0.0,\n\t\tmultiplier*deut_a, 1.0 - multiplier, multiplier*deut_b,\n\t\t0.0, 0.0, 1.0\n\t);\n    \n    color = color*deutanMatrix;\n    return color;\n}\n\nvec3 applyTritan(vec3 color, float multiplier)\n{\n    // Perform color blindness adjustments\n    mat3 tritanMatrix = mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, 1.0, 0.0,\n\t\tmultiplier*trit_a, multiplier*trit_b, 1.0 - multiplier\n\t);\n    \n    color = color*tritanMatrix;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 color;\n\n\tvec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 texCoord = mod(fragCoord, iResolution.xy/vec2(2.0))/texRes;\n\ttexCoord *= texRes.x/iResolution.x*2.0;\n\n\tfloat amount = 1.0 - 2.0*iMouse.x/iResolution.x;\n\n\tfragColor = texture(iChannel0, texCoord);\n\tcolor = fragColor.rgb;\t\n\n\t// Calculate which quadrant is being computed\n\tint quadrant = int(dot(round(fragCoord/iResolution.xy), vec2(1.0, 2.0)));\n    \n    if(quadrant != 2)\n    {\n        // Convert to LMS\n        color = RGBToLMS(color);\n        \n        switch(quadrant){\n            case 3:\n                color = applyTritan(color, amount);\n                break;\n            case 1:\n                color = applyDeutan(color, amount);\n                break;\n            case 0:\n                color = applyProtan(color, amount);\n                break;\n        }\n        // Convert back to RGB\n        color = LMSToRGB(color);\n    }\n    \n\n\tfragColor.rgb = color;\n}","name":"Image","description":"","type":"image"}]}