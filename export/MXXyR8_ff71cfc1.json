{"ver":"0.1","info":{"id":"MXXyR8","date":"1725809558","viewed":63,"name":"Carbon Raymarching","username":"Mindam","description":"Graphics HW","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","carbon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// consts\nconst float PI = 3.141592;\n\n// render consts\nconst int MAX_ITER = 200;\nconst float MAX_DIST = 1e2;\nconst float STEP_EPS = 1e-6;\nconst float H = 1e-2;\nconst float BLICK_POW = 5e1;\nconst float SHADOW_K = 16.;\nconst float CORE_SMOOTH = 0.05;\n\n// scene consts\nfloat NUCLEON_SIZE = 0.3;\nfloat NUCLEON_OFFSET = 0.4;\nfloat CORE_OMEGA = 1.;\nfloat ELECTRON_SIZE = 0.1;\nfloat ELECTRON_OFFSET = 2.;\nfloat ELECTRON_OMEGA = 0.5;\n\n\n\n// render structures\nstruct camera {\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    float fov;\n};\n\nstruct light {\n    vec3 pos;\n    vec4 col;\n};\n\n\n\n// rotation matrices\nmat3 rotateAxis(vec3 axis, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    return mat3(\n        vec3(c + (1. - c) * x * x, (1. - c) * x * y - s * z, (1. - c) * x * z + s * y),\n        vec3((1. - c) * y * x + s * z, c + (1. - c) * y * y, (1. - c) * y * z - s * x),\n        vec3((1. - c) * z * x - s * y, (1. - c) * z * y + s * x, c + (1. - c) * z * z)\n    );\n}\n\nmat3 rotateX(float theta) {\n    return rotateAxis(vec3(1., 0., 0.), theta);\n}\n\nmat3 rotateY(float theta) {\n    return rotateAxis(vec3(0., 1., 0.), theta);\n}\n\nmat3 rotateZ(float theta) {\n    return rotateAxis(vec3(0., 0., 1.), theta);\n}\n\n\n\n// sdf functions\nfloat sdSphere(vec3 p, float s)\n{\n      return length(p) - s;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCore(vec3 p, vec3 cent)\n{\n    p = rotateAxis(normalize(vec3(1., 1., 1.)), PI * CORE_OMEGA * iTime) * p;\n    int nucleonCount = 12;\n    \n    vec3[] nucleons = vec3[] (\n    NUCLEON_OFFSET * normalize(vec3(3., 1., 1.)), NUCLEON_OFFSET * normalize(vec3(3., -1., -1.)),\n    NUCLEON_OFFSET * normalize(vec3(1., 3., 1.)), NUCLEON_OFFSET * normalize(vec3(-1., 3., -1.)),\n    NUCLEON_OFFSET * normalize(vec3(-1., 1., 3.)), NUCLEON_OFFSET * normalize(vec3(1., -1., 3.)),\n    NUCLEON_OFFSET * normalize(vec3(-3., 1., -1.)), NUCLEON_OFFSET * normalize(vec3(-3., -1., 1.)),\n    NUCLEON_OFFSET * normalize(vec3(-1., -3., -1.)), NUCLEON_OFFSET * normalize(vec3(1., -3., 1.)),\n    NUCLEON_OFFSET * normalize(vec3(1., 1., -3.)), NUCLEON_OFFSET * normalize(vec3(-1., -1., -3.))\n    );\n    \n    float res = sdSphere(p - (cent + nucleons[0]), NUCLEON_SIZE);\n    for (int i = 0; i < nucleonCount; i++)\n    {\n        res = opSmoothUnion(res, sdSphere(p - (cent + nucleons[i]), NUCLEON_SIZE), CORE_SMOOTH);\n    }\n    return res;\n}\n\nfloat sdOrbiltals(vec3 p, vec3 cent)\n{\n    int electronCount = 6;\n    vec3[] electrons = vec3[] (\n    rotateAxis(normalize(vec3(-3., 2., 0.)), PI * ELECTRON_OMEGA * iTime * 1.05) * ELECTRON_OFFSET * normalize(vec3(2., 3., 0.)),\n    rotateAxis(normalize(vec3(3., 2., 0.)), PI * ELECTRON_OMEGA * iTime * 1.07) * ELECTRON_OFFSET * normalize(vec3(-2., 3., 0.)),\n    rotateAxis(normalize(vec3(0., -3., 2.)), PI * ELECTRON_OMEGA * iTime * 1.11) * ELECTRON_OFFSET * normalize(vec3(0., 2., 3.)),\n    rotateAxis(normalize(vec3(0., 3., 2.)), PI * ELECTRON_OMEGA * iTime * 1.13) * ELECTRON_OFFSET * normalize(vec3(0., -2., 3.)),\n    rotateAxis(normalize(vec3(-3., 0., 2.)), PI * ELECTRON_OMEGA * iTime * 1.17) * ELECTRON_OFFSET * normalize(vec3(2., 0., 3.)),\n    rotateAxis(normalize(vec3(3., 0., 2.)), PI * ELECTRON_OMEGA * iTime * 1.19) * ELECTRON_OFFSET * normalize(vec3(-2., 0., 3.))\n    );\n    \n    float res = sdSphere(p - (cent + electrons[0]), ELECTRON_SIZE);\n    for (int i = 0; i < electronCount; i++)\n    {\n        res = min(res, sdSphere(p - (cent + electrons[i]), ELECTRON_SIZE));\n    }\n    return res;\n}\n\n\n\n// scene sdf function\nfloat sceneSDF(vec3 p )\n{ \n    return min(sdCore(p, vec3(0.)), sdOrbiltals(p, vec3(0.)));\n}\n\n\n\nvec3 getNormal(vec3 p)\n{\n    float dx1 = sceneSDF(p + vec3(H, 0, 0));\n    float dx2 = sceneSDF(p - vec3(H, 0, 0));\n    float dy1 = sceneSDF(p + vec3(0, H, 0));\n    float dy2 = sceneSDF(p - vec3(0, H, 0));\n    float dz1 = sceneSDF(p + vec3(0, 0, H));\n    float dz2 = sceneSDF(p - vec3(0, 0, H));\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\n\n\nvec3 trace(in vec3 start, in vec3 dir, out bool hit)\n{\n    vec3 p = vec3(0.);\n    float t = 0.;\n    float d = 0.;\n    \n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        p = start + dir * t;\n        d = sceneSDF(p);\n        t += d;\n        \n        if (d < STEP_EPS || t > MAX_DIST) break;\n    }\n    \n    if (d < STEP_EPS) hit = true;\n    \n    return p;\n}\n\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = STEP_EPS * 10.;\n    for( int i=0; i<MAX_ITER && t<MAX_DIST; i++ )\n    {\n        float h = sceneSDF(ro + rd*t);\n        if( h < STEP_EPS )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\n\ncamera mainCam = camera(vec3(0., 0., 5.), vec3(0., 0., -1.), vec3(0., 1., 0.), 100.);\n\nint lightCount = 6;\nlight[] ligths = light[] (\nlight(vec3(0., 4., 3.), vec4(1., 0., 0., 1.)),\nlight(vec3(-2., -3., 3.), vec4(0., 1., 0., 1.)),\nlight(vec3(2., -3., 3.), vec4(0., 0., 1., 1.)),\nlight(vec3(-2., 3., -3.), vec4(1., 1., 0., 1.)),\nlight(vec3(2., 3., -3.), vec4(1., 0., 1., 1.)),\nlight(vec3(0., -4., -3.), vec4(0., 1., 1., 1.))\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // angle of camera\n    vec2 mouseTheta = PI * (iMouse.xy * 2. - iResolution.xy) / iResolution.x;\n    float phi = mouseTheta.x;\n    float theta = mouseTheta.y;\n    \n    // moving camera\n    vec3 frameCameraPos = rotateY(phi) * mainCam.pos;\n    vec3 frameCameraDir = rotateY(phi) * mainCam.dir;\n    vec3 frameCameraUp = mainCam.up;\n    vec3 frameCameraRight = cross(frameCameraDir, frameCameraUp);\n    frameCameraPos = rotateAxis(frameCameraRight, -theta) * frameCameraPos;\n    frameCameraDir = rotateAxis(frameCameraRight, -theta) * frameCameraDir;\n    frameCameraUp = rotateAxis(frameCameraRight, -theta) * frameCameraUp;\n    float cameraDepth = 1. / tan(radians(mainCam.fov / 2.));\n    \n    // computing ray direction\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.x;\n    vec3 rayDir = normalize(frameCameraDir * cameraDepth + frameCameraRight * uv.x + frameCameraUp * uv.y);\n    \n    //tracing ray\n    bool hit = false;\n    vec3 p = trace(frameCameraPos, rayDir, hit);\n    \n    vec4 color = vec4(vec3(0.), 1.);\n    \n    // process hit case\n    if (hit)\n    {\n        vec3 n = getNormal(p);\n        vec3 hc = normalize(frameCameraPos - p);\n        for (int i = 0; i < lightCount; i++)\n        {\n            vec3 hl = normalize(ligths[i].pos - p);\n            float brightness = softshadow(p, hl, SHADOW_K) * max(0., dot(n, hl));\n            float blick = pow(brightness, BLICK_POW);\n            color = color + (0.05 + 0.475 * brightness + 0.475 * blick) * ligths[i].col;\n        }\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}