{"ver":"0.1","info":{"id":"ddGSDw","date":"1681172643","viewed":73,"name":"chatgpt sphere","username":"sunbro1337","description":"3d sphere with cube map and reflections generated by chatgpt3.5","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ai","chatgpt","chatgpt35"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -2.0); // camera position\n    vec3 rd = normalize(vec3(p.xy, 1.0)); // ray direction\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 skyColor = vec3(0.5, 0.7, 1.0);\n    vec3 groundColor = vec3(0.8, 0.8, 0.8);\n    vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 0.5;\n    float groundHeight = -0.5;\n\n    // get cube map\n    vec3 cubeMap = texture(iChannel1, rd).rgb;\n\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + rd * t;\n        float d = length(pos - spherePos) - sphereRadius; // sphere distance\n        if (d < 0.001) {\n            // add cube map to sphere\n            col = mix(vec3(1.0, 0.0, 0.0), cubeMap, 0.5);\n            vec3 normal = normalize(pos - spherePos);\n            float diffuse = max(dot(normal, lightDir), 0.0);\n            col *= diffuse;\n            // add specular lighting\n            vec3 halfway = normalize(lightDir - rd);\n            float specular = pow(max(dot(normal, halfway), 0.0), 32.0);\n            col += vec3(0.6, 0.6, 0.6) * specular;\n            fragColor = vec4(col, 1.0);\n            return;\n        }\n        if (pos.y < groundHeight) {\n            // add cube map to surface\n            col = mix(groundColor, cubeMap, 0.5);\n            fragColor = vec4(col, 1.0);\n            // add reflection\n            vec3 reflectionDir = reflect(rd, vec3(0.0, 1.0, 0.0));\n            vec3 reflectionPos = pos + reflectionDir * 0.5;\n            vec3 reflectionColor = vec3(0.7, 0.7, 0.7);\n            float reflectionDist = 0.0;\n            for (int j = 0; j < 5; j++) {\n                reflectionPos += reflectionDir * reflectionDist;\n                float reflectionDist = length(reflectionPos - spherePos) - sphereRadius;\n                if (reflectionDist < 0.001) {\n                    col += reflectionColor;\n                    break;\n                }\n                reflectionColor *= vec3(0.9);\n            }\n            fragColor = vec4(col, 1.0);\n            return;\n        }\n        t += d;\n    }\n    col = mix(skyColor, groundColor, smoothstep(0.0, 1.0, rd.y));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}