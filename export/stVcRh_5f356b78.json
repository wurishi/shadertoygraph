{"ver":"0.1","info":{"id":"stVcRh","date":"1664224933","viewed":139,"name":"orbofdistortion","username":"pb","description":"balls","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//see Buffer A please\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n\n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 ro,rd,pp;\nmat3 rot;\nvec3 light;\nbool hitPrism;\nfloat totdist;\n#define pi 3.14159265\n\n\nmat3 rot_xz_xy(float a1, float a2) {\n    //rotation matrices - can't live with'em, can't live without'em\n    //even the rodrigues formula is a matrix in the end...\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n                     \n    return mat3( c2*c1, s2, c2*s1,\n                -s2*c1, c2, -s2*s1,\n                  -s1,   0.,  c1 );\n}\n\nfloat dist_func01(vec3 p) {\n\n    hitPrism = false;\n    float prism = length(p) - 1.;\n\n    p = rot*p;\n    p = mod(p-2.,4.)-2.;\n    float dist = length(p) - .3;\n    if ( prism  < dist ) {\n        dist = prism;\n        hitPrism = true;\n    }\n    return dist;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .0001 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n  \n    float  rf = .6;  //have some fun change this\n    \n    float tt = mod(iTime,20.);\n\n    \n    light = normalize( vec3( .5, 0., -1.) ) ;\n    xy = (2.*xy - iResolution.xy) / iResolution.y;\n    \n    ro = vec3(0.,0.,-1.4);\n    rd = normalize( vec3(xy,1.) );\n    \n    vec3 p = ro;\n    \n    rot = rot_xz_xy(iTime/3.,iTime/5.);\n    \n    float init_eps=1e-8;\n    float n=0.,dist,threshold=init_eps;\n    totdist=0.;\n    vec3 color=vec3(0.);\n    float pc = 0.;\n\n    for(;n<300.;n++) {\n        \n        dist = dist_func01(p);\n        \n        if ( dist < init_eps && hitPrism )  {\n\n            vec3 pp = p - 70.*dist*rd;  //first mistake, play with it\n            vec3 nn = gradient(pp);\n            vec3 rd2 =  refract( rd, nn, rf);  //change ray direction\n            \n            p = pp + .1*rd2;  //second mistake,  play with it\n            \n            rd = rd2;\n            \n            color += vec3( 10.,3.,0.);\n            \n            pc += 1.;           \n        \n        }\n          \n        else if ( dist < threshold && !hitPrism ) {\n          \n            color += 3.*vec3(.3,.5,.8);\n            \n            vec3 nn = gradient(p+dist*rd) ;\n           \n            color *= max(0.,dot(nn,light));\n            \n            break;   \n           \n        }\n        \n        else {\n            p += dist * rd;\n        }\n        \n \n        totdist += dist;\n        threshold = init_eps * (1. + totdist*50. );\n \n  \n\n    }\n    \n    color *= exp(-totdist*totdist/600.);\n    \n    float sqpc = sqrt(pc);\n    color.r += .03*sqpc;\n    color.g += .02*sqpc;\n    \n    rgba = vec4(color,1.);\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}