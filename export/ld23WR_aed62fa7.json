{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI = 3.1415926;\n\nvec2 rotate( vec2 v, float theta )\n{\n\treturn vec2(v.x*cos(theta) - v.y*sin(theta), v.x*sin(theta) + v.y*cos(theta));\n}\n\n// function to draw a rotated \"magnet\" rect: half red, half black.\nvec4 compassRect( vec2 fragXy, vec2 centrePt, float width, float theta )\n{\n\tvec2 xy = fragXy - centrePt;\n\t\n\tvec2 xy2 = rotate(xy, theta);\n\n\t// black half\n\tfloat d1 = max( abs(xy2.x), abs(xy2.y+width) ); // distance function yeilding a square\n\tfloat a1;\n\tif( d1 < width ){\n\t\ta1 = 1.0;\n\t} else if( d1 < width + 1.0 ) {\n\t\ta1 = 1.0 - (d1 - width);\n\t}else{\n\t\ta1 = 0.0;\n\t}\n\t\n\t// red half\t\n\tfloat d2 = max( abs(xy2.x), abs(xy2.y-width) );\n\tfloat a2;\n\tif( d2 < width ){\n\t\ta2 = 1.0;\n\t} else if( d2 < width + 1.0 ) {\n\t\ta2 = 1.0 - (d2 - width);\n\t}else{\n\t\ta2 = 0.0;\n\t}\n\t\n\treturn vec4(1.0,1.0,1.0,1.0) - a1*vec4(1.0,1.0,1.0,0.0) - a2*vec4(0.0,1.0,1.0,0.0);\n}\n\n\n// Compute magnetic dipole field value (a vector) at field location samplePt\n// for a dipole located at dipolePt, with moment dipoleMoment.\n// this is a 2d implementation but it would be the same for 3d with vec3s.\n// http://en.wikipedia.org/wiki/Magnetic_field\n// http://en.wikipedia.org/wiki/Dipole#Field_of_a_static_magnetic_dipole\n\nvec2 evalDipoleField( vec2 samplePt, vec2 dipolePt, vec2 dipoleMoment )\n{\n\tconst float mu_0 = 0.0000012566371; // permeability of free space: http://en.wikipedia.org/wiki/Magnetic_constant\n\tvec2 mm = dipoleMoment; // vector dipole moment\n\t\n\t// rr: vector from position of dipole to position of interest\n\tvec2 rr = samplePt - dipolePt;\n  \n  \t// r: is the absolute value of rr: the distance from the dipole\n\tfloat r = length(rr);\n  \n\t// r_hat: rr/r the unit vector parallel to rr\n\tvec2 r_hat = rr / r;\n  \n  \t// B: computed field value\n  \tvec2 B = (mu_0/(4.0*PI*r*r*r)) * ( (3.0*dot(mm,r_hat)*r_hat) - mm );\n\n\treturn B; \n}\n\nvec2 evalField(vec2 samplePt)\n{\n\tvec2 dipolePt = iResolution.xy / 2.0;\n\tvec2 dipoleMoment = vec2(0.0, 1.0);\n\t\n\tvec2 fieldValue = evalDipoleField( samplePt, dipolePt, dipoleMoment );\n\t\n\tvec2 secondDipolePt = dipolePt + vec2(100,0);\n\t// click and drag to move the second dipole\n\tif( iMouse.x != 0.0 ){\n\t\tsecondDipolePt.xy = iMouse.xy;\n\t}\n\t\n\t// add a second dipole (offset and rotated by 90 degrees)\n\tfieldValue += evalDipoleField( samplePt, secondDipolePt, rotate(dipoleMoment,PI*0.5) );\n\t\n\treturn fieldValue;\n}\n\nfloat computeIsoWarpedStrength( vec2 v )\n{\n\t//return pow(length(v), 1.0/3.0) * 5.0;\n\t\n\treturn length(v) * 2.0;\n}\n\nfloat isolineIntensity( vec2 samplePt )\n{\n\t// (apply * 1000...0.0 scaling factor for rendering)\n\tvec2 v = evalField(samplePt) * 10000000000000.0;\n\tvec2 v_xl = evalField(samplePt+vec2(-1.0,0.0)) * 10000000000000.0;\n\tvec2 v_ya = evalField(samplePt+vec2(0.0,-1.0)) * 10000000000000.0;\n\tvec2 v_xr = evalField(samplePt+vec2(1.0,0.0)) * 10000000000000.0;\n\tvec2 v_yb = evalField(samplePt+vec2(0.0,1.0)) * 10000000000000.0;\n\t\n\tfloat warpedStrength = computeIsoWarpedStrength(v);\n\tfloat warpedStrength_xl = computeIsoWarpedStrength(v_xl);\n\tfloat warpedStrength_ya = computeIsoWarpedStrength(v_ya);\n\tfloat warpedStrength_xr = computeIsoWarpedStrength(v_xr);\n\tfloat warpedStrength_yb = computeIsoWarpedStrength(v_yb);\n\t\n\t// distance of current pos value from 0.5 isoline crossing\n\t// mod 1 so that we can generate isolines for each crossing of 0.5\t\n\tfloat d = abs(mod(warpedStrength,1.0)-0.5);\n\t\n\t// factors for normalization to local gradient. this gives us a 1px wide line\n\tfloat rx = abs(warpedStrength_xr - warpedStrength_xl) * 0.5;\n\tfloat ry = abs(warpedStrength_yb - warpedStrength_ya) * 0.5;\n\t\n\t// the min(..) term is our isolines \n\t// the +max(..) term fades out the lines if they are too close together\n\treturn clamp( min( d / rx, d / ry ) + max(rx, ry), 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat t = iTime * .5;\n\t\n\tfloat spacing = 10.0;\n\t\n\tvec2 dipolePt = iResolution.xy / 2.0;\n\tvec2 dipoleMoment = vec2(0.0, 1.0);\n\t\n\t//dipoleMoment = rotate(dipoleMoment, t);\n\t\n\t// pt is the point of interest. scaled to the grid.\n\tvec2 pt = floor((fragCoord.xy / spacing) + 0.5 ) * spacing;\n\t\n\tfragColor = vec4(0,0,0,0.0);\n\tfloat s=0.0;\n\t\n\t/*\n\t/// unsuccessful experiment to render overlapping vectors\n\tfor( int i=-1; i <= +1; ++i ){\n\t\tfor( int j=-1; j <= +1; ++j ){\n\t\t\tvec2 v = vec2(float(i),float(j)) * spacing;\n\t\t\t\n\t\t\tvec2 field = fieldStrength( pt+v, dipolePt );\n\t\t\tfloat theta = atan( field.x, field.y );\n\t\t\tfloat strength = length(field);\n\t\t\t\n\t\t\tfragColor += compassRect( fragCoord.xy, pt+v, spacing * 0.2 * sqrt(strength), theta );\n\t\t\ts += 1.0;\n\t\t}\n\t}\n\t\n\tfragColor /=s;\n\t*/\n\t\n\tvec2 field = evalField( pt );\t\n\tfield *= 10000000000000.0; // apply a scaling factor for rendering\n\t\n\tfloat theta = atan( field.x, field.y );\n\tfloat strength = length(field);\n\t//float displayStrength = strength;\n\tfloat displayStrength = sqrt(sqrt(strength));\n\t\n\tvec4 compass = compassRect( fragCoord.xy, pt, spacing * 0.2 * displayStrength, theta );\n\t\n\tfragColor = compass * isolineIntensity(fragCoord.xy);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld23WR","date":"1386347458","viewed":3591,"name":"2 Dipole Field","username":"RossBencina","description":"Vector field of two magnetic dipoles (at 90 degrees). Click to drag the second one.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["dipole","magneticfield"],"hasliked":0,"parentid":"","parentname":""}}