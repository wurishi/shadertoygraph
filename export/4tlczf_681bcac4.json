{"ver":"0.1","info":{"id":"4tlczf","date":"1505806883","viewed":183,"name":"Sobel filter Stroke","username":"Tibus","description":"Sobel filter as from https://fr.wikipedia.org/wiki/Filtre_de_Sobel\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sobel","contour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Half the inflation size\n#define INFLATE_SIZE 8\n#define CIRCLE_FILTER\n#define INFLATE_SMOOTH\n\nfloat inflate(vec2 uv)\n{\n    float vMax = 0.0;\n    \n    for(int y = -INFLATE_SIZE; y <= INFLATE_SIZE; ++y)\n    {\n        for(int x = -INFLATE_SIZE; x <= INFLATE_SIZE; ++x)\n        {\n            \n#ifdef CIRCLE_FILTER\n            float fx = float(x);\n            float fy = float(y);\n            float d  = sqrt(fx*fx+fy*fy);\n            \n            if(d > float(INFLATE_SIZE))\n                continue;\n#endif\n            \n            float v = texture(iChannel1, uv + vec2(x,y) / vec2(textureSize(iChannel1, 0))).x;\n            \n#ifdef CIRCLE_FILTER\n#ifdef INFLATE_SMOOTH\n            v *= 1.0 - smoothstep(float(INFLATE_SIZE) - 2.0, float(INFLATE_SIZE), d);\n#endif\n#endif\n            \n            vMax = max(vMax, v);\n        }\n    }\n\n    return vMax * texture(iChannel1, uv).y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel1, uv).y*0.5);\n    \n    if(uv.x < sin(iTime) * 0.5 + 0.5)\n        fragColor = texture(iChannel1, uv);\n    else\n        fragColor = fragColor+vec4(inflate(uv));\n    \n    if(abs(uv.x - (sin(iTime) * 0.5 + 0.5)) < 0.002)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Sobel filter as from https://fr.wikipedia.org/wiki/Filtre_de_Sobel\n\nfloat textureThreshold(vec2 uv)\n{\n    vec4 textap = texture(iChannel0, uv);\n    float luma = dot(textap.xyz, vec3(0.3, 0.6, 0.1));\n    return step(0.5, luma);\n}\n\nfloat Gx(vec2 uv)\n{\n    vec2 texelSize = vec2(1.0) / vec2(textureSize(iChannel0, 0));\n    \n    float result = 0.0f;\n    \n    result += -1.0 * textureThreshold(uv + vec2(-1.0, -1.0) * texelSize);\n    result += -1.0 * textureThreshold(uv + vec2(-1.0,  0.0) * texelSize);\n    result += -1.0 * textureThreshold(uv + vec2(-1.0,  1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0, -1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0,  0.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0,  1.0) * texelSize);\n    \n    return result;\n}\n\nfloat Gy(vec2 uv)\n{\n    vec2 texelSize = vec2(1.0) / vec2(textureSize(iChannel0, 0));\n    \n    float result = 0.0f;\n    \n    result += -1.0 * textureThreshold(uv + vec2(-1.0, -1.0) * texelSize);\n    result += -1.0 * textureThreshold(uv + vec2( 0.0, -1.0) * texelSize);\n    result += -1.0 * textureThreshold(uv + vec2( 1.0, -1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2(-1.0,  1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 0.0,  1.0) * texelSize);\n    result +=  1.0 * textureThreshold(uv + vec2( 1.0,  1.0) * texelSize);\n    \n    return result;\n}\n\nvec2 contour(vec2 uv)\n{\n    float gx = Gx(uv);\n    float gy = Gy(uv);\n    \n    return vec2(\n        sqrt(gx * gx + gy * gy), // contour\n        textureThreshold(uv) // base image\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(contour(uv), 0.0, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}