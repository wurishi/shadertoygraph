{"ver":"0.1","info":{"id":"ldXczX","date":"1489078707","viewed":5217,"name":"Wythoff construction","username":"mattz","description":"All of the convex regular uniform polyhedra, in one big shader.","likes":71,"published":1,"flags":16,"usePreview":1,"tags":["tiling","spherical","symmetry","polyhedron","wythoff","buckyball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Wythoff construction demo, by mattz.\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n\n   Keys do things:\n\n     D - toggle demo mode (no other keys work until you leave demo mode)\n\n     S - toggle sphere\n     C - toggle color scheme\n     T - toggle triangle visualizations\n\n     1,2 - toggle bits of first angle divisor (p)\n     3,4 - toggle bits of second angle divisor (q)\n     5,6 - toggle bits of third angle divisor (r)\n     7,8 - toggle bits of pipe location\n\n   Much of the code below could be simplified. There's probably a lot\n   of unnecessary normalization going on, for instance.\n\n   Also note the distance function only goes to the OUTSIDE of the\n   polyhedron, it is not a proper signed distance function (alas!)\n\n   Here are some helpful links that I used to learn about the math:\n\n     https://en.wikipedia.org/wiki/Wythoff_construction\n     http://www.gregegan.net/APPLETS/26/WythoffNotes.html\n     https://en.wikipedia.org/wiki/Spherical_polyhedron\n     https://en.wikipedia.org/wiki/List_of_uniform_polyhedra_by_Wythoff_symbol\n\n   Nope, I haven't yet figured out how to make snub polyhedra (type\n   4?) or the non-convex (star-like) uniform polyhedra yet. \n\n   I also never figured out how to antialias the edges of my raymarched shapes. Someday.\n\n   Tweet @matt_zucker with suggestions/comments/questions.\n\n*/\n\n// Here are some Wythoff symbols for well-known polyhedra:\n#define WS_TET   vec4(3,2,3,0) // Tetrahedron\n#define WS_OCT   vec4(4,2,3,0) // Octahedron\n#define WS_CUBE  vec4(3,2,4,0) // Cube\n#define WS_IKE   vec4(5,2,3,0) // Icosahedron\n#define WS_DOE   vec4(3,2,5,0) // Dodecahedron\n#define WS_CO    vec4(2,3,4,0) // Cuboctahedron\n#define WS_ID    vec4(2,3,5,0) // Icosidodecahedron\n#define WS_TUT   vec4(2,3,3,1) // Truncated tetrahedron\n#define WS_TOE   vec4(2,4,3,1) // Truncated octahedron\n#define WS_TIC   vec4(2,3,4,1) // Truncated cube\n#define WS_TI    vec4(2,5,3,1) // Truncated icosahedron \n#define WS_TID   vec4(2,3,5,1) // Truncated dodecahedron\n#define WS_SIRCO vec4(3,4,2,1) // Rhombicuboctahedron\n#define WS_SRID  vec4(3,5,2,1) // Rhombicosidodecahedron\n#define WS_GIRCO vec4(2,3,4,2) // Truncated cuboctahedron\n#define WS_GRID  vec4(2,3,5,2) // Truncated icosidodecahedron\n\n// Symbol of polyhedron to render.\nvec4 wythoff_symbol = WS_IKE;\n\n//////////////////////////////////////////////////////////////////////\n// Toggles for display:\n\nfloat demo_mode = 1.0;\nfloat color_by_face = 1.0;\nfloat show_triangles = 0.0;\nfloat sphericity = 0.0;\n\n// Demo also scales up/down object\nfloat scale = 1.0;\n\n//////////////////////////////////////////////////////////////////////\n// Keys and other handy constants:\n\nconst float KEY_C = 67.5/256.0;\nconst float KEY_D = 68.5/256.0;\nconst float KEY_R = 82.5/256.0; \nconst float KEY_S = 83.5/256.0;\nconst float KEY_T = 84.5/256.0;\n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\nconst float KEY_6 = 54.5/256.0;\nconst float KEY_7 = 55.5/256.0;\nconst float KEY_8 = 56.5/256.0;\n\nconst float pi = 3.141592653589793;\n\nconst float farval = 1e5;\n\nconst vec3 bg_color = vec3(0.9);\n\nconst mat3 basic_palette = mat3(vec3(1,1,0),\n                                vec3(1,0,0),\n                                vec3(0,0,1));\n\n// Light vector\nvec3 L = normalize(vec3(1.0, 0.5, 2.0));\n\n//////////////////////////////////////////////////////////////////////\n// Compare key state to default\n\nfloat key_state(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n//////////////////////////////////////////////////////////////////////\n// Axis-aligned rotations\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Constructs a spherical triangle from angle divisors p,q,r. The\n// three great circles will meet at angles pi/p, pi/q, pi/r.\n//\n// Great circles are represented as unit vectors corresponding to\n// their antipode. For instance, the great circle along the xy plane\n// is simply the vector (0, 0, 1).\n//\n// Everything you ever want to do with points and lines on spheres\n// boils down to dot products and cross products.\n//\n// If two great circles l1 and l2 meet at an angle theta, then\n//\n//   dot(l1, l2) = -cos(theta) = cos(pi - theta)\n//\n// So if the great circles are perpendicular, dot(l1, l2) = 0. And if\n// a unit vector v lies on a great circle l, then dot(l, v) = 0, too.\n//\n// This returns tri, a matrix of great circles. If a point v is inside\n// the triangle, then dot(tri[i], p) > 0 for all i.\n\nmat3 construct_tri(in vec3 pqr) {\n\n    // take pi/p, pi/q, pi/r\n    vec3 angles = pi/pqr;\n\n    // get cosines\n    vec3 c = cos(angles);\n\n    // only need sin(pi/p)\n    float sp = sin(angles.x);\n\n    // We want to construct three great circles l1, l2, l3 with the\n    // following properties:\n    //\n    //   dot(l1, l2) = -cp\n    //   dot(l2, l3) = -cq\n    //   dot(l3, l1) = -cr\n\n    // Without loss of generality we can fix one great circle at (1, 0, 0):\n    vec3 l1 = vec3(1, 0, 0);\n\n    // The next one is simply rotated by pi/p radians along the z axis:\n    vec3 l2 = vec3(-c.x, sp, 0);\n\n    // Now we need to solve a linear system:\n    //\n    //   dot(l3, l1) = x3*1 + y3*0 + z3*0 = x3 = -cr\n    //   dot(l3, l2) = -x3*cp + y3*sp + z3*0 = -cq\n    //\n    // Substituting 1 into 2, we get cr*cp + y3*sp = -cq, which means\n    // y3 = -(cq + cr*cp)/sp\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n\n    // z3 is chosen to make sure that l3 is a unit vector\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    \n    vec3 l3 = vec3(x3, y3, z3);\n\n    // Now we have all our great circles\n    return mat3(l1, l2, l3);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// This ridiculously handy function helps us solve a bunch of problems\n// thanks to point-line duality:\n//\n//   - it constructs one of the two points of intersection of the\n//     great circles a & b\n//\n//   - it constructs the great circle passing through the unit vectors\n//     a & b on the sphere\n//\n//   - it constructs the altitude from a point a to line b, or from a\n//     line a to a point b.\n\nvec3 intersect(vec3 a, vec3 b) {\n    return normalize(cross(a, b));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Constructs the great circle bisecting the angle formed by two great\n// circles l1 and l2.\n\nvec3 bisect(vec3 l1, vec3 l2) {\n    return intersect(cross(l1, l2), 0.5*(l1+l2));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Given a spherical triangle and a point x on a sphere, this\n// repeatedly mirrors x along edges of the triangle until it lands\n// inside.\n//\n// When I started this project, I thought I was going to have to\n// mirror the triangle until it landed on the point, but it turns out,\n// with all of the cross products flying around, that you have to\n// track the parity (even or odd) if you flip the triangle, and it\n// proved to be too much bookkeeping.\n//\n// Frankly, I'm not exactly sure why this works, or why 15 flips is\n// the magic number that gets every point inside the destination\n// triangle.\n//\n// I'm probably going to make another shader at some point to try to\n// understand why this converges. \n//\n// Upon return: the point x is inside the triangle, and the matrix M\n// holds the product of all mirror transformations. Its determinant\n// (not actually used anywhere except for visualization) is -1 for odd\n// number of flips, +1 for even.\n\nvoid flip_into_tri(in mat3 tri,\n                   inout vec3 x,\n                   out mat3 M) {\n    \n    // d holds signs of point/edge decisions for each edge of the triangle.\n    // if its components are all non-negative, we win.\n    vec3 d = x * tri; \n\n    // initialize M as the identity transformation\n    M = mat3(1.0);\n\n    // 5 iterations is the magic number\n    for (int k=0; k<5; ++k) {    \n\n        // if inside already, quit flippin'\n        if (min(d[0], min(d[1], d[2])) >= 0.0) { break; }\n\n        // for each edge of the triangle\n        for (int j=0; j<3; ++j) {\n\n            // if we are \"outside\" this edge\n            if (d[j] < 0.0) {\n\n                // flip along this edge\n                vec3 tj = tri[j];                \n\n                // update M by flipping each column\n                M = mat3(reflect(M[0], tj),\n                         reflect(M[1], tj),\n                         reflect(M[2], tj));\n\n                // reflect x\n                x = reflect(x, tj);\n\n                // update d\n                d = x * tri;\n                \n            }\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Precondition: we have flipped point x into the triangle. Now we do\n// the meat of the Wythoff construction method. First, we choose a\n// vertex, tri_vert, inside the triangle, according to the type of\n// triangle:\n//\n//    p | q r : the vertex is placed at point P\n//\n//    p q | r : the vertex is placed at the point on PQ that bisects\n//              the angle at R\n//\n//    p q r | : the vertex is placed at the incenter (intersection of\n//              bisectors)\n//\n// Then from the given vertex, we drop altitudes to one or more edges\n// of the triangle. Those altitudes will correspond the edges of our\n// polyhedron, and the vertex itself will become a polyhedron vertex.\n//\n// Once the point and altitudes are constructed, we need to classify x\n// as being in one of up to three possible regions (corresponding to\n// red, yellow, and blue in the simple color display) created by\n// splitting the triangle along the altitudes.\n//\n// In addition to which of the three regions we are selecting (encoded\n// as a one-hot vec3), we also compute the normal point (the triangle\n// vertex corresponding to that region), and the great circle\n// corresponding to the closest polyhedron edge.\n//\n// The dot product between x and edge may be positive or negative.\n\nvoid check_domain(in mat3 tri,\n                  in vec3 x,\n                  in float type,\n                  out vec3 tri_vert,\n                  out vec3 tri_region,\n                  out vec3 face_normal,\n                  out vec3 edge) {\n        \n    // Construct the three triangle vertices\n    vec3 p0 = intersect(tri[1], tri[2]); // Q\n    vec3 p1 = intersect(tri[2], tri[0]); // R\n    vec3 p2 = intersect(tri[0], tri[1]); // P\n     \n\n    // Place vertex for each type\n    if (type == 0.0) {\n        \n        // Place the vertex at P\n        tri_vert = p2;\n        \n    } else { \n        \n        // Bisect the angle at R\n        vec3 l_b1 = bisect(tri[2], tri[0]);\n\n        if (type == 1.0) {\n\n            // Get the intersection with edge PQ\n        \ttri_vert = intersect(l_b1, tri[1]);\n        \n        } else {\n        \n            // Place the vertex at the incenter\n            vec3 l_b2 = bisect(tri[0], tri[1]);\n            tri_vert = intersect(l_b1, l_b2);\n            \n        }\n        \n    }\n        \n    // In the worst case we will have to look at all three\n    // altitudes, so we might as well construct them now.\n    vec3 l_a0 = intersect(tri_vert, tri[0]);\n    vec3 l_a1 = intersect(tri_vert, tri[1]);\n    vec3 l_a2 = intersect(tri_vert, tri[2]);\n\n    // The altitudes were constructed so they all wind the same\n    // direction around the point p. That gives the code below\n    // some nice symmetry:\n    float d0 = dot(x, l_a0);\n    float d1 = dot(x, l_a1);\n    float d2 = dot(x, l_a2);\n\n    if (d1 < 0.0 && d2 >= 0.0) {\n        tri_region = vec3(1.0, 0, 0);\n        edge = abs(d1) < abs(d2) ? l_a1 : l_a2;\n    } else if (d2 < 0.0 && d0 >= 0.0) {\n        tri_region = vec3(0, 1.0, 0);\n        edge = abs(d2) < abs(d0) ? l_a2 : l_a0;\n    } else {\n        tri_region = vec3(0, 0, 1.0);\n        edge = abs(d0) < abs(d1) ? l_a0 : l_a1;\n    }\n\n    // Once we know the region, the polyhedron face normal is just the\n    // corresponding vertex P, Q, or R.\n    face_normal = mat3(p0, p1, p2) * tri_region;\n        \n}\n\n//////////////////////////////////////////////////////////////////////\n// Wrapper function for the functions above. Four main steps:\n//\n//   1) construct the spherical triangle\n//   2) flip the point x until it lies inside\n//   3) figure out what region of the triangle x is in\n//   4) clean up by mapping the triangle vertex, normal, and edge\n//      through the inverse of the transform that x underwent\n\nvoid wythoff(in vec4 wythoff_symbol, \n             in vec3 x,\n             out mat3 tri,\n             out mat3 M,\n             out vec3 tri_vert,\n             out vec3 tri_region,\n             out vec3 face_normal,\n             out vec3 edge) {\n\n    vec3 pqr = wythoff_symbol.xyz;\n    float type = wythoff_symbol.w;\n\n    // step 1\n    tri = construct_tri(pqr);\n\n    // step 2\n    flip_into_tri(tri, x, M);\n\n    // step 3\n    check_domain(tri, x, type, tri_vert, tri_region, face_normal, edge);\n\n    // step 4\n    face_normal = face_normal * M;\n    tri_vert = tri_vert * M;\n    edge = edge * M;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Distance function for raymarching.\n\nfloat map(in vec3 pos) {\n\n    // Handle scaling\n    pos /= scale;\n\n    // Get length of point & distance to sphere\n    float d = length(pos);\n    float d_sphere = d - 1.0;\n\n    // Do wythoff construction\n    mat3 tri, M;\n    vec3 tri_vert, tri_region, face_normal, edge;\n    \n    wythoff(wythoff_symbol, pos, tri, M, \n            tri_vert, tri_region, face_normal, edge);\n\n    // Compute distance to exterior of polyhedron\n    float d_poly = dot(pos, face_normal) - dot(face_normal, tri_vert);\n\n    // Mix polyhedron/sphere and go\n    return mix(d_poly, d_sphere, sphericity) * scale;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// RGB from hue\n\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's normal calculation\n\nvec3 calc_normal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    map(pos+eps.xyy) - map(pos-eps.xyy),\n                    map(pos+eps.yxy) - map(pos-eps.yxy),\n                    map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Based on IQ's ray marcher\n\nvec2 cast_ray( in vec3 ro, in vec3 rd) {\n\n    const int rayiter = 25;\n    const float dmax = 20.0;\n    \n    const float precis = 0.01;   \n    float h=8.0;\n\n    float t = 0.0;\n    float m = 1.0;\n\n    for( int i=0; i<rayiter; i++ ) {\n        if( abs(h)<precis||t>dmax ) continue;//break;\n        t += h;\n        h = map( ro+rd*t );\n    }    \n\n    if (t > dmax) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Color for ray\n\nvec3 shade(vec3 ro, vec3 rd) {\n\n    // Do raymarching\n    vec2 tm = cast_ray(ro, rd);\n\n    if (tm.y < 0.0) {\n\n        // No hit\n        return bg_color;\n\n    } else {\n\n        // We hit the polyhedron\n        vec3 p = ro + rd*tm.x;\n\n        // Redo Wythoff construcion to get vertex, region, normal, edge.\n        vec3 x = normalize(p);\n\n        mat3 tri, M;\n        vec3 tri_vert, tri_region, face_normal, edge;\n    \n        wythoff(wythoff_symbol, x, tri, M, \n                tri_vert, tri_region, face_normal, edge);\n\n        //////////////////////////////////////////////////\n        // Black lines\n\n        // Look at distance from edge to draw black lines\n        float d_black = abs(dot(edge, x)) - 0.005;\n\n        // Look at points on sphere\n        d_black = min(d_black, length(x - tri_vert) - 0.03*sphericity);\n\n        // Distance to coverage\n        float k_black = smoothstep(0.0, 0.01, d_black);\n\n        //////////////////////////////////////////////////\n        // Face coloring\n        \n        // Normal to RGB\n        vec3 per_face_color = face_normal*0.5 + 0.5;\n\n        // Red/Yellow/Blue\n        vec3 basic_color = basic_palette * tri_region;\n        \n        // Mix per-face/basic\n        vec3 base_color = mix(basic_color, per_face_color, color_by_face);\n\n        //////////////////////////////////////////////////\n        // Even/odd triangle coloring\n\n        // Light version of color for even triangles\n        vec3 lighter = 0.6*base_color + 0.4;\n\n        // Signed distances to triangle edge (note always positive\n        // cause M*x is guaranteed inside triangle)\n        vec3 d = M * x * tri;\n\n        // Get min dist for shading\n        float tri_dist = min(d.x, min(d.y, d.z));\n\n        // For odd triangles\n        vec3 darker = lighter * 0.8;\n\n        // In-between color for AA\n        vec3 mid = lighter * 0.9;\n\n        // Compute parity as determinant of reflection matrix\n        float parity = dot(M[0], cross(M[1], M[2]));\n\n        // Base color for even/odd\n        vec3 tri_color = parity < 0.0 ? darker : lighter;\n\n        // AA\n        tri_color = mix(mid, tri_color,\n                        smoothstep(0.0, 0.005, abs(tri_dist)));\n\n        //////////////////////////////////////////////////\n        // Final shading\n\n        vec3 final_color = mix(base_color, tri_color, show_triangles);\n      \n        vec3 n = calc_normal(p);\n    \n        float nDotL = clamp(dot(n, L), 0.0, 1.0);\n\n        return k_black * final_color * (nDotL * 0.5 + 0.5);\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Decode numbers 2,3,4,5 or 0,1,2,3 from two key toggles. This is\n// a very gross user interface\n\nfloat keys_to_num(float key, float default_value, float bias) {\n\n    default_value -= bias;\n\n    float hi = key_state(key, floor(default_value/2.0));\n    float lo = key_state(key+1.0/256.0, mod(default_value, 2.0));\n\n    return 2.0*hi + lo + bias;\n  \n}\n\n//////////////////////////////////////////////////////////////////////\n// Does GLSL support constant arrays across the board yet? \n\nvec4 choose_shape(float index) {\n\n    if (index < 1.0) {\n        return WS_TET;\n    } else if (index < 2.0) {\n        return WS_OCT;\n    } else if (index < 3.0) {\n        return WS_CUBE;\n    } else if (index < 4.0) {\n        return WS_IKE;\n    } else if (index < 5.0) {\n        return WS_DOE;\n    } else if (index < 6.0) {\n        return WS_CO;\n    } else if (index < 7.0) {\n        return WS_ID;\n    } else if (index < 8.0) {\n        return WS_TUT;\n    } else if (index < 9.0) {\n        return WS_TOE;\n    } else if (index < 10.0) {\n        return WS_TIC;\n    } else if (index < 11.0) {\n        return WS_TI;\n    } else if (index < 12.0) {\n        return WS_TID;\n    } else if (index < 13.0) {\n        return WS_SIRCO;\n    } else if (index < 14.0) {\n        return WS_SRID;\n    } else if (index < 15.0) {\n        return WS_GIRCO;\n    } else {\n        return WS_GRID;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Distance to character in SDF font texture\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+vec2(0.3, 0.2)+offset)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv-vec2(0.2, 0.3))-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Generate label for Wythoff symbol using SDF font texture\n\nvec2 label_symbol(vec2 text_pos, float text_size) {\n    \n    float d = farval;\n    \n    for (int i=0; i<3; ++i) {\n        d = min(d, font2d_dist(text_pos, text_size, vec2(wythoff_symbol[i], 12.0)));\n        text_pos -= vec2(1.0, 0)*text_size;\n        \n        if (wythoff_symbol.w == float(i)) {\n            text_pos += vec2(0.25, 0) * text_size;\n            d = min(d, font2d_dist(text_pos, text_size, vec2(12.0, 8.0)));\n            text_pos -= vec2(0.75, 0) * text_size;\n        }      \n        \n    }\n    \n    return vec2(smoothstep(vec2(0.0), vec2(1.0), d - vec2(2.0, 0.0)));\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Main program\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 fragCoordText = fragCoord;\n    float reveal_mode = key_state(KEY_R, 0.0);\n    \n    demo_mode = key_state(KEY_D, demo_mode);\n    float text_size = 24.0;\n\n    if(reveal_mode > 0.0 && demo_mode == 0.0) {\n        \n        wythoff_symbol.x =     2.0 * abs( floor(2.0*fract(4.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.x - 2.0)/2.0) ) + abs( floor(2.0*fract(8.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.x - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.y =     2.0 * abs( floor(2.0*fract(1.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.y - 2.0)/2.0) ) + abs( floor(2.0*fract(2.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.y - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.z =     2.0 * abs( floor(2.0*fract(6.0*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.z - 2.0)/2.0) ) + abs( floor(2.0*fract(3.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.z - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.w = min(2.0 * abs( floor(2.0*fract(1.5*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.w      )/2.0) ) + abs( floor(1.5*fract(1.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.w      ), 2.0) ), 2.0);\n\n        fragCoordText = mod(fragCoord*3.,iResolution.xy/vec2(16,12)*3.);\n        fragCoord = mod(fragCoord*vec2(16,12),iResolution.xy)*vec2(1,16./12.);\n        fragCoord.y -= iResolution.y*.125;\n        text_size = 24.0;\n        \n\n    }\n \n    //////////////////////////////////////////////////\n    // Set up model view and projection\n    \n    float t = iTime;\n    \n    const vec3 tgt = vec3(0);\n    const vec3 cpos = vec3(1.0,1.0,1.0)*10.005;\n    const vec3 up = vec3(0, 0, 1);\n    const float fovy = 0.125;\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * fovy / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,up)),\n        ry = cross(rx,rz);\n         \n    float thetay = t * 0.6;\n    float thetax = t * 0.3;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -4.5/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 4.0/iResolution.x; \n    }\n\n    mat3 Rmouse = rot_x(thetax)*rot_y(thetay);\n    mat3 Rview = mat3(rx,ry,rz)*Rmouse;    \n    L = Rview*Rmouse*(L*Rview);\n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    //////////////////////////////////////////////////\n    // Inititialize Wythoff symbol and settings\n    \n\n    if (demo_mode > 0.0) {\n\n        const float d_scale = 1.0;\n        const float d_long = 5.0;\n\n        const float t_appear = 0.5;\n        const float t_big = t_appear + d_scale;\n        const float t_poly_start = t_big + d_long;\n        const float t_poly_end = t_poly_start + 0.5;\n        const float t_color_start = t_poly_end + d_long;\n        const float t_color_end = t_color_start + 0.5;\n        const float t_shrink = t_color_end + d_long;\n        const float t_final = t_shrink + d_scale;\n        \n        float stage = floor(t / t_final);\n        float ts = mod(t, t_final);\n\n        sphericity = smoothstep(t_poly_end, t_poly_start, ts);\n\n        show_triangles = sphericity;\n        \n        color_by_face = smoothstep(t_color_start, t_color_end, ts);\n\n        scale = min(smoothstep(t_appear, t_big, ts),\n                    smoothstep(t_final, t_shrink, ts));\n        \n        float shape = mod(stage + 3.0, 16.0);\n\n        wythoff_symbol = choose_shape(shape);\n\n    } else {\n\n        color_by_face = key_state(KEY_C, color_by_face);\n        show_triangles = key_state(KEY_T, show_triangles);\n        sphericity = key_state(KEY_S, 0.0);\n    \n        if (reveal_mode == 0.0) {\n            wythoff_symbol.x = keys_to_num(KEY_1, wythoff_symbol.x, 2.0);\n            wythoff_symbol.y = keys_to_num(KEY_3, wythoff_symbol.y, 2.0);\n            wythoff_symbol.z = keys_to_num(KEY_5, wythoff_symbol.z, 2.0);\n            wythoff_symbol.w = min(keys_to_num(KEY_7, wythoff_symbol.w, 0.0), 2.0);\n        }\n\n    }\n\n    //////////////////////////////////////////////////\n    // Now composite our scene\n\n    // Don't attempt to render obviously bogus polyhedra.\n    bool valid = dot(1.0/wythoff_symbol.xyz, vec3(1.0)) > 1.0;\n\n    vec3 scene_color = bg_color;\n    vec3 text_color = valid ? vec3(0) : vec3(0.7, 0, 0);\n\n    if (valid && scale > 0.0) {\n        scene_color = shade(ro, rd);\n        text_color = vec3(0);\n    }\n\n    // Composite in text\n    vec2 text_pos = fragCoordText.xy - 12.49;\n\n    vec2 k = label_symbol(text_pos, text_size);\n\n    scene_color = mix(bg_color, scene_color, k.x);\n    scene_color = mix(text_color, scene_color, k.y);\n\n    // Done!\n    fragColor = vec4(scene_color, 1.0);\n\t\n}\n","name":"Image","description":"","type":"image"}]}