{"ver":"0.1","info":{"id":"fl2BWV","date":"1652837881","viewed":160,"name":"thin film irridescence","username":"c0rymcg","description":"A quick little simulation of what happens to light when it reflects off of a thin film, like oil on water or soap bubbles. \nNot spectacular on its own, but I thought it might be useful as a resource for other shaders that need this effect.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["film","soapbubble","irridescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2831853\n#define wavecount 50.\n//This simulates the behavior of light rays reflecting off of thin films.\n//The effect is caused by two relfections interacting, one reflecting from\n//the outside of the film and one from the inside.\n\n//at first I tried to find a way to calculate rgb values that would\n//approximate this effect, but nothing really worked well.\n//Instead, this shader runs the calculations for two reflections for \n//a range of wavelengths, which it then samples into RGB values in the \n//same way that our eyes would react.\n\n\n//for a bell-curve shape with controllable offset and width, returns the height value at X\nfloat gaussian(float delta, float width, float x){\n    return exp(-pow(x+delta,2.)/(2.*pow(width,2.)));\n}\n\n//for finding sphere intersections\nvec2 intersectRayWithSphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius){\n\tvec3 len = sphereCenter - rayOrigin;\n\tfloat tangentialClosest = dot(len, rayDirection); //distance along the ray where the ray is closest to the sphere\n\tfloat distSquared = dot(len, len) - tangentialClosest * tangentialClosest; //distance squared from ray to \n\tif (distSquared > sphereRadius * sphereRadius) return vec2(-1); // The ray misses the sphere.\n   \tfloat distToSurface = sqrt(sphereRadius * sphereRadius - distSquared);\n\tfloat t1 = tangentialClosest - distToSurface;\n\tfloat t2 = tangentialClosest + distToSurface;\n\tvec3 intersectionPointFront = rayOrigin + t1 * rayDirection;\n\tvec3 intersectionPointBack = rayOrigin + t2 * rayDirection;\n \treturn vec2(length(intersectionPointFront - rayOrigin), length(intersectionPointBack - rayOrigin));\n}\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    \n    vec3 col = vec3(0.);//start with black\n    \n    vec3 rayDir = normalize(vec3(uv.x-0.5,uv.y-0.25,1.));\n    fragColor = vec4(col*3./wavecount,1.0);\n    vec3 dist = vec3(intersectRayWithSphere(vec3(0.0), rayDir, vec3(0.,0., 6.), 2.0),1.); //outer surface\n    dist-= vec3(intersectRayWithSphere(vec3(0.0), rayDir,vec3(0.,0., 6.),1.99),1.); //subtract inner surface\n    \n    float thickness = (dist.x)*10000.;//\n    //thickness = mix(0.,2000.,uv.x);//this is the film's thickness, in nanometers\n    \n    \n    for(float i = 0.; i <wavecount; i++){\n        \n        float wavelen = mix(380.,700.,i/wavecount);//the color of light determined by wavelength (in nanometers)\n        \n        //Two waves will intersect. this point is the middle between the first two \n        //peaks, where the combined wave will be highest\n        float midpoint = thickness/2.;\n        \n        float wave1 = cos(midpoint*TAU/wavelen);//surface bounce\n        float wave2 = -cos((midpoint+thickness)*TAU/wavelen);//subsurface bounce\n            \n        float waveMAX = abs(wave1+wave2);//the combination of the two bounces tells us what the interference of this wave looks like\n            \n        //simulate the activation of retina cones based on light ray wavelength\n        col+=vec3(gaussian(-.8,.08,i/wavecount),gaussian(-.6,.08,i/wavecount),gaussian(-.3,.07,i/wavecount))*waveMAX;\n    }\n    \n    \n    fragColor = vec4(col*0.05,1.);\n    \n}\n\n/*float gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\nvec3 spectrum_to_rgb(float wavelength){\n    mat3 xyz = mat3(\n        3.240479, -1.537150, -0.498535,\n        -0.969256, 1.875992, 0.041556,\n        0.055648, -0.204043, 1.057311\n    );\n\n    vec3 result = vec3( \n         gaussian(wavelength, 1.056, 599.8, 37.9, 31.0)+gaussian(wavelength, 0.362, 442.0, 16.0, 26.7)+ gaussian(wavelength, -0.065, 501.1, 20.4, 26.2)\n        ,gaussian(wavelength, 0.821, 568.8, 46.9, 40.5)+gaussian(wavelength,0.286, 530.9, 16.3, 31.1)\n        ,gaussian(wavelength, 1.217, 437.0, 11.8, 36.0)+gaussian(wavelength, 0.681, 459.0, 26.0, 13.8)\n     );\n     \n    return result*xyz;\n    \n}*/","name":"Image","description":"","type":"image"}]}