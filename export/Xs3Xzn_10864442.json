{"ver":"0.1","info":{"id":"Xs3Xzn","date":"1457263265","viewed":3820,"name":"Castle Tunnel","username":"Hamneggs","description":"No I won't let down my hair, the windows are locked now! At least they replaced them with some high-efficiency models that allow enough light in so we don't have to use those awful candles anymore.","likes":70,"published":1,"flags":33,"usePreview":0,"tags":["procedural","ray","displacement","lighting","camera","marching","volumetric","mapping","effects","castle","multi","atmospheric","pass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Castle Tunnel v 1.1\n * Author: Gerard Geer (http://gerardgeer.com)\n * License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n *\n * This is a wild adventure in multipass and goofy lighting tricks.\n * Buffer A: Marches out to the first intersection, and stores it.\n * Buffer B: Takes Buffer A's results and calculates the surface normal.\n * Buffer C: Takes all that and calculates texturing for each pixel.\n * Buffer D: Uses an ultra simplified DF and fixt-stehp marching for\n *           those sick crepuscular rays.\n * Image:    Calculates the rest of the lighting and composites everything.\n *\n * Oh and by the way, turning the sconces on looks awful. Leave those lamps\n * off :)\n * \n * Based loosely on this pciture here:\n * https://commons.wikimedia.org/wiki/File:Tunnels_in_Cardiff_Castle.jpg\n *\n *  * If you want a slight speed boost, you can turn off sampled normal mapping\n *    sampled normal mapping by commenting out DO_IMG_NORM_MAPS in buffer B.\n *  * You can also turn off the crepuscular rays by commenting out \n *    GO_AHEAD_AND_MAKE_ME_CREPES_FOR_BREAKFAST in buffer D.\n *  * I really wish there was a pre-pre processing step here that would allow us\n *    to have global stuff. I'd write it for you.\n */\n\n// Fine, if you insist. We even took out the stained glass so you could have\n// enough light without them.\n// #define TURN_THE_LIGHTS_ON_IN_HERE\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.5\n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 80.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 120\n// Shadow marching steps.\n#define S_STEPS 100\n// Maximum acceptable marching result.\n#define EPSILON .015\n// Max ray depth.\n#define MAX_DEPTH 100.0\n\n// Entity IDs.\n#define ID_NONE\t\t0.0\n#define ID_GROUND\t1.0\n#define ID_WALLS\t2.0\n#define ID_CEILING\t3.0\n#define ID_CUTOUT\t4.0\n#define ID_CUTCEIL\t5.0\n#define ID_CAULDR\t6.0\n#define ID_CANDLES\t7.0\n#define ID_WINDOW\t8.0\n#define ID_END\t\t9.0\n\n// iChannel definitions.\n#define POS_BUFF iChannel0\n#define NRM_BUFF iChannel1\n#define TEX_BUFF iChannel2\n#define SFT_BUFF iChannel3\n\n// Some constants for rendering.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 TX_CPOS = vec2(2,2);\t\t\t\t\t\t// The pixel in which we store the camera position.\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.894427, 0.357771, -0.268328); \t// Sun direction.\nconst vec3 SKY_COLOR = vec3(0.53,0.81,0.92);\t\t// Sky color.\nconst vec3 SUN_COLOR = vec3(4.0);\t\t\t\t\t// Sun color.\nconst vec3 GROUND_COLOR = vec3(0.73,0.70,0.75);\t\t// Average color of the ground for GI.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t// ... and the second as well.\n\n/* \n    Reads a texel from a sampler2D at a given position.\n*/\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/* \n    Buff is a value that must be written to fragCoord.\n\tif the current frag coord is that of where we want to store\n\tour data, buff is overwritten. Otherwise, buff is returned\n\tas is.\n*/\nvoid write3( inout vec3 buff, in vec3 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.1,max(off.x,off.y)) );\n}\n\n/*\n\tReturns a psuedo random value given a 3D vector.\n\tFrom IQ's 3D Voronoi noise.\n*/\nfloat hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tReturns a psuedo-random value given a 2D vector.\n\tNot at all, 0% based on IQ's hash function.\n*/\nfloat hash( vec2 x )\n{\n\tx = vec2( dot(x,vec2(311.7, 74.7)),\n\t\t\t  dot(x,vec2(183.3,246.1)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tOh no! We're out of iChannels! Looks like we\n\thave to use IQ's procedural noise.\n*/\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n/*\n\tA 2D bumpmap of bricks. This is used for the ceiling.\n*/\nfloat brickBump( in vec2 p, in float s )\n{\n    p.x *= .5;\n    p.x += .5*floor(mod(p.y,2.0));\n    vec2 f = 2.0-fract(p) - 1.0;\n    return smoothstep(s,1.0,max(f.x,f.y));\n}\n\n/*\n\tThis provides the tile bumpmap for the ground.\n*/\nfloat groundBump( in vec3 p )\n{\n    vec3 f = fract(p);\n    return smoothstep(.966,.975,max(f.x,max(f.y,f.z)));\n}\n\n/*\n\tCreates the bumpmap for the wall. This is the simple version that's\n\tdefined in 2D space. It's used for the walls and the endcaps.\n*/\nfloat wallBump2D( in vec2 p )\n{\n    p *= 2.0;\n    p.x *= .5;\n    p.x += .5*floor(mod(p.y,2.0));\n    \n    vec2 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,f.y));\n    r *= .1 + hash(800.0*floor(p))*.8;\n    return 1.0 - r;\n}\n\n/*\n\tThe 3D version, on the other hand is defined in R^3 to be used in\n\tthe cutouts.\n*/\nfloat wallBump3D( in vec3 p )\n{\n    p *= 2.0;\n    p.z *= .5;\n    p.z += .5*floor(mod(p.y,2.0));\n    \n    vec3 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,max(f.y,f.z)));\n    r *= .1 + hash(800.0*floor(p))*.8;\n    return 1.0 - r;\n}\n\n/*\n\tSamples a texture in each of R^3s principle hyperplanes, and\n\tthen uses the given surface normal to return a linear combination\n\tof those samples.\n*/\nvec3 tex3D( in sampler2D t, in vec3 p, in vec3 n )\n{\n    n = abs(n);\n    return texture(t,p.xy).rgb*n.z\n          +texture(t,p.xz).rgb*n.y\n          +texture(t,p.zy).rgb*n.x;\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tThe seminal signed cube distance function. Back in the early\n\tdays IQ crafted this golden workhorse. Thank him.\n*/\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAn infinitely long box that extends along the X axis.\n\tAn adaptation of IQ's box.\n*/\nfloat xBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.zy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAnd another that goes down the Z.\n*/\nfloat zBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.xy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder along the X axis. IQ's again.\n*/\nfloat xCapCyl( vec3 p, vec2 c )\n{\n    // This is basically an infinite cylinder that's being chopped\n    // by a bounds.\n\tvec2 d = abs(vec2(length(p.zy),p.x)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tAnother that stands up tall along the Y axis.\n*/\nfloat yCapCyl( vec3 p, vec2 c )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tA cylinder that extends infinitely along the Z axis.\n*/\nfloat zCyl( vec3 p, float r )\n{\n\treturn length(p.xy)-r;\n}\n\n/*\n\tIQ's pill function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tThe base tunnel. It's an infinite box, with the middle hollowed\n\tout by another.\n*/\nfloat baseTunnel( in vec3 p )\n{\n    float d =  max( zBox(p-vec3(0,6,0),vec2(5,7)),\n                   -zBox(p-vec3(0,6,0),vec2(3,6)));\n    float f = 0.0;\n    if ( d > EPSILON*8.0 ) return d;\n    else if ( p.y > .15 )  return d + wallBump2D(p.zy)*.15;\n    else return d + groundBump(p)*.05;\n}\n\n/*\n\tThese form the far walls. We make these their own subfield so that\n\twe can use a 2D distance function on them and the walls. (As well as\n\ta 2D texturing function.)\n*/\nfloat yourPathEndsHere( in vec3 p )\n{\n    p.z = mod(p.z,172.0)-86.0;\n \tfloat d = box(p,vec3(5,12,1));\n    if ( d > EPSILON*8.0 ) return d;\n    else return d + wallBump2D(p.xy)*.15;\n}\n\n/*\n\tThe ceiling is actually a really large hollowed cylinder. It's\n\tintersected with the main tunnel so that only the ceiling\n\tpart remains.\n*/\nfloat ceiling( in vec3 p )\n{\n    p.y *= .75;\n    float r = max( zCyl(p,8.0),\n                  -zCyl(p,7.5));\n    r = max(r,zBox(p-vec3(0,6,0),vec2(4,6))); // Trim the excess that is outside the tunnel.\n    if( r > EPSILON ) return r;\n    else return r + brickBump(p.zx,.975)*.1;\n}\n\n/*\n\tThis subfield is just the windowpanes. It's actually just\n\tone big pane, but nobody's tellin.\n*/\nfloat windowPanes( in vec3 p )\n{\n    return abs(p.x-4.33);\n    p.x -= 4.33;\n    p.y -= 4.5;\n    p.z = mod(p.z,15.0)-7.5;\n    return box(p,vec3(.5));\n}\n\n/*\n\tThe subfield that cuts out holes in the side of the tunnel. It's\n\talso a box intersected with a cylinder.\n*/\nfloat windowCutouts( in vec3 p )\n{\n    // Base transformations to get them into position.\n    vec3 q = p;\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    float r =  max(xBox(b,vec2(1.5,4.5)),\n                   xCapCyl(c,vec2(3,4.0)));\n    \n    // Displacement mapping. If we're a safe distance away, we don't need to\n    // worry about calculating the surface. Otherwise...\n    if( r > EPSILON ) return r;\n    else if( p.y > 3.366 ) return r;// + (1.0-brickBump(p.xy*2.0,.95))*.1;\n    else return r+.15-wallBump3D(q)*.12;\n}\n\n/*\n\tThis subfield is max()'d with the tunnel to scallop those bits below\n\tthe window. It's just a positioned and mod()'d cube.\n*/\nfloat windowScallops( in vec3 p )\n{\n    vec3 q = p;\n    p.x -= 3.0;\n    p.y -= 4.0;\n    p.z = mod(p.z,15.0)-7.5;\n    float r = box(p,vec3(1,4.0,1.5));\n    if( r > EPSILON ) return r;\n    else return r+.15-wallBump3D(q)*.12;\n}\n\n/*\n\tA smooth version of the window cutout used for the window texture.\n*/\nfloat windowFrame( in vec3 p )\n{\n    // Base transformations to get them into position.\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    return max(xBox(b,vec2(1.5,4.5)),\n               xCapCyl(c,vec2(3,4.0)));\n}\n\n/*\n\tThe candles are just a cylinder.\n*/\nfloat candles( in vec3 p )\n{\n    // These need to be on top of the bottom of the cauldrons, so we have \n    // to elevate them.\n    p += vec3(2.4,-7.9,7.5);\n    p.z = mod(p.z,15.0)-7.5; // Repeat.\n    return yCapCyl(p,vec2(.1,.2));\n}\n\n/*\n\tThe cauldrons that house the candles on the other hand\n\tare a bunch of boxes that subtract from a hollowed box,\n\tplus two more for the mount.\n*/\nfloat cauldrons( in vec3 p )\n{\n    p += vec3(2.4,-8,7.5); // Translate.\n    p.z = mod(p.z,15.0)-7.5; // Repeat.\n    \n    vec3 q = p; // For the cage.\n    q.xz *= 1.0 - (q.y-.5)*.5; // Smush it.\n    \n    // Start out with a hollowed cube.\n    float r = max(-box(q,vec3(.3)*.9),\n                   box(q,vec3(.3)));\n    \n    \n    // Then chop out an x-shaped portion with boxes.\n    q = mod(q,.3)-.15;\n  \tfloat cutout = min(xBox(q,vec2(.125)),zBox(q,vec2(.125)));\n    r = max(r,-cutout);\n    // now we need to make an arm and a mount, with two other box calls.\n    p.x += .35;\n    r = min(r,box(p,vec3(.175,.025,.025)));\n    p.x += .2;\n    return min(r,box(p,vec3(.015,.25,.25)));\n}\n\n/*\n\tThis field is roughly the shape of the sky light's cast into the\n\ttunnel. This allows us to use the distance to it as the lighting\n\tcoefficient.\n\tOkay it's just a magic floating triangle thingy.\n*/\nfloat sketchySkyEmitter( in vec3 p )\n{\n    p.z = mod(p.z, 15.0)-7.5;\n    p.y -= 4.0;\n    float squish = 1.5 - p.x*.75;\n    return box(p,vec3(1.5,3.0,squish));\n}\n\n/*\n\tThis is the same idea, except for secondary illumination off the\n\twall. It's a giant floating pill!\n*/\nfloat sketchySecEmitter( in vec3 p )\n{\n    p.z = mod(p.z, 15.0)-7.5;\n    return capsule(p,vec3(1.0,3.0,0.0),\n                   \t vec3(1.0,7.0,0.0),\n                   \t 1.0);\n}\n\n/*\n\tThe global distance function.\n*/\nfloat dist( in vec3 p )\n{\n    float r = baseTunnel(p);\n    r = min(r,ceiling(p));\n    r = max(r,-windowCutouts(p));\n    r = max(r,-windowScallops(p));\n    r = min(r,cauldrons(p));\n    r = min(r,windowPanes(p));\n    r = min(r,yourPathEndsHere(p));\n    return min(r,candles(p));\n}\n\n/*\n\tA simpler distance function that the shadows\n\tuse. It doesn't take into account the cauldrons\n\tor the ceiling since neither are ever left unoccluded\n\tby something else.\n*/\nfloat sDist( in vec3 p )\n{\n    float r = baseTunnel(p);\n    r = max(r,-windowCutouts(p));\n    return max(r,-windowScallops(p));\n}\n/*\n\tAn even simpler shadow distance function for the candles.\n\tThe only thing those rays need to hit are the cauldrons.\n*/\nfloat csDist( in vec3 p )\n{\n    float r = baseTunnel(p);\n    return min(r,cauldrons(p));\n}\n\n/*\n\tReturns the id and distance of the nearest entity.\n*/\nfloat distID( in vec3 p )\n{\n    // Since the window cutout subfields exist WITHIN the base tunnel and ceiling,\n    // we have to make sure negative values don't get into the comparison. Using\n    // abs() instead of max() has the added benefit of biasing towards those cutout\n    // bits.\n\tvec2 closest = u(vec2(abs(ceiling(p))+EPSILON, ID_CEILING),\n\t\t\t         vec2(abs(baseTunnel(p)), mix(ID_GROUND,ID_WALLS,step(.1,p.y))));\n\t\t closest = u(closest, vec2(abs(windowCutouts(p)), mix(ID_CUTOUT,ID_CUTCEIL,step(8.425,p.y))));\n         closest = u(closest, vec2(abs(windowScallops(p)),ID_CUTOUT));\n    \t closest = u(closest, vec2(cauldrons(p), ID_CAULDR));\n    \t closest = u(closest, vec2(candles(p), ID_CANDLES));\n    \t closest = u(closest, vec2(windowPanes(p), ID_WINDOW));\n    \t closest = u(closest, vec2(yourPathEndsHere(p), ID_END));\n    return closest.t;\n\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, vec3 d )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || r > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r*.5;\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir, in float md, in float p )\n{    \n\tfloat t = EPSILON*4.0;\n\tfloat res = 1.0;\n    for ( int i = 0; i < S_STEPS; ++i )\n    {        \n        float d = sDist( start + ldir * t );\n        if ( d < EPSILON )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d*.25;\n\t\t\n\t\tif ( t > md)\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat cShadow( in vec3 start, in vec3 ldir, in float md, in float p )\n{    \n\tfloat t = EPSILON*4.0;\n\tfloat res = 1.0;\n    for ( int i = 0; i < S_STEPS; ++i )\n    {        \n        float d = csDist( start + ldir * t );\n        if ( d < EPSILON )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d*.25;\n\t\t\n\t\tif ( t > md)\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance. How he\n\tgoes from the Wikipedia implementation to this I would enjoy learning.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\n/*\n\tCalculates lighting for a given point.\n*/\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n )\n{\n    // Get ambient occlusion and shadow values.\n    float amb = occlusion(p,n);\n    \n    // Get light colors and irradiance for the sun light.\n    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;\n    // Shadow the sunlight.\n    float sdw = shadow(p,SUN_DIR,MAX_DEPTH,PENUMBRA_FACTOR);\n    \n    \n    // Do our distance based sky and secondary lighting.\n    float skyd = sketchySkyEmitter(p);\n    vec3 sky = clamp(1.0-skyd*.33,.0,1.0)*SKY_COLOR*.25;\n    float secd = sketchySecEmitter(p);\n    vec3 sec = clamp(1.0/secd,.0,1.0)*SUN_COLOR*.133;\n    \n    // We're not gonna use P anymore, so let's just reuse it.\n    \n    //-------------------------------------------------------\n    // IT'S CANDLE TIME.\n    //-------------------------------------------------------\n    #ifdef TURN_THE_LIGHTS_ON_IN_HERE\n        // First we make some animation constants.\n        float t = iTime * 6.0;\n        // Animate the position.\n        vec3 pAnim = vec3(noise(p+t),noise(p+1.0-t),noise(p+1.5+t))*.01;\n        // Animate the brightness based on time, as well as\n        // the 15 unit section in which the candle resides.\n        float bAnim = noise(vec3(t+floor((p-vec3(0,0,7.5))*.06667)));\n\n        // Use the same modulo as the candles.\n        vec3 q = p+vec3(2.4,-8.0,7.5);\n        q.z = mod(q.z,15.0)-7.5;\n\n        // Move it around like it's a candle flame.\n        q += pAnim;\n\n        // Get the direction to the *nearest* candle.\n        vec3 cDir = -normalize(q); \n\n        // Do lighting on that point, and work in the\n    \t// brightness animation.\n        vec3 can = orenNayar(n,-d,cDir)*vec3(.5,.45,.4)*bAnim;\n\n        // Calc shadows from the cauldron.\n        float cSdw = cShadow(p,cDir,length(q),PENUMBRA_FACTOR*.5)*.25;\n    #else\n        vec3 can = vec3(0);\n        float cSdw = 0.0;\n    #endif\n    \n    // Modulate all the lighting results by \n    sec *= amb;\n    sky *= amb;\n    sun *= sdw;\n    can *= cSdw;\n    \n    // Return the sum.\n    return sec+sky+sun+can;\n}\n/*\n\tShades a point, giving it lighting and taking into account distance.\n*/\nvec3 shade( in vec3 p, in vec3 d, in vec3 t, in float i, in vec3 n, in vec3 e )\n{\n    // Get the position's distance from the camera.\n    float l = length(p-e);\n    // And let's get the culled color since we need it.\n    vec3 cull = vec3(.06);\n    // Shortcut the glass.\n    if( i == ID_WINDOW ) return t;\n    // Brighten the candles if we need to.\n    #ifdef TURN_THE_LIGHTS_ON_IN_HERE\n    else if( i == ID_CANDLES ) return t*.75;\n    #endif\n    // If the ray didn't hit anything, we shortcut out.\n    if(l >= MAX_DEPTH)return vec3(.05);\n    // Otherwise we do texturing and lighting for this point.\n    vec3 result = t*light(p,d,e,n);\n    // Smooth out the transition between geometry and emptiness.\n    return mix(cull,result,clamp(MAX_DEPTH-l,0.0,1.0));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( vec2 uv, vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = texture(SFT_BUFF,fragCoord/iResolution.xy);return;\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, texture, normal, crapuscular ray coeff, and eye position.\n    vec3 p,d,t,n,c,e;\n    float i,s; // Entity ID and shutter.\n    \n    // Load the fragment position and entity ID.\n    vec4 posData = texture(POS_BUFF,fragCoord/iResolution.xy)*vec4(1000,1000,1000,1);\n    // Load the camera position and shutter value.\n    vec4 camData = readTexel(POS_BUFF,TX_CPOS);\n \tp = posData.xyz;\n    e = camData.xyz;\n    d = normalize(p-e);\n    t = texture(TEX_BUFF,fragCoord/iResolution.xy).rgb;\n    n = texture(NRM_BUFF,fragCoord/iResolution.xy).rgb;\n    c = texture(SFT_BUFF,fragCoord/iResolution.xy).rgb;\n    i = posData.w;\n    s = camData.w;\n    \n    // Store the final pixel color.\n    fragColor = postProcess(uv,shade(p,d,t,i,n,e)+c).rgbb*s;\n}\n\n/*\n\tThe Shadertoy VR entrypoint.\n*/\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, \n            in vec3 fragRayOri, in vec3 fragRayDir )\n{\n   //fragColor = texture(SFT_BUFF,fragCoord/iResolution.xy);return;\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, texture, normal, crapuscular ray coeff, and eye position.\n    vec3 p,d,t,n,c,e;\n    float i,s; // Entity ID and shutter.\n    \n    // Load the fragment position and entity ID.\n    vec4 posData = texture(POS_BUFF,fragCoord/iResolution.xy)*vec4(1000,1000,1000,1);\n    // Load the camera position and shutter value.\n    vec4 camData = readTexel(POS_BUFF,TX_CPOS);\n \tp = posData.xyz;\n    e = camData.xyz;\n    d = normalize(p-e);\n    t = texture(TEX_BUFF,fragCoord/iResolution.xy).rgb;\n    n = texture(NRM_BUFF,fragCoord/iResolution.xy).rgb;\n    c = texture(SFT_BUFF,fragCoord/iResolution.xy).rgb;\n    i = posData.w;\n    s = camData.w;\n    \n    // Store the final pixel color.\n    fragColor = postProcess(uv,shade(p,d,t,i,n,e)+c).rgbb*s;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * Castle Tunnel (Buffer A)\n * Author: Gerard Geer\n * License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n *\n * This buffer is pretty simple. It just marches out to the first intersection.\n *\n * An important note though: While nearly every surface is displacement mapped,\n * no part of the distance field in this buffer uses high frequency noise beyond\n * that of the basic bricks and such.\n * \n * We forego this so we don't have to calculate a texture-based FBM once per surface\n * per march per ray. It's just not practical. \n * \n * Instead I add high frequency stuff in the normal buffer. Since the bumps are so\n * small that one wouldn't notice their actual displacement, this gives us the\n * same result. (Other than the fact we cut out about, I'd say, roughly, a bazillion\n * texture lookups.)\n *\n * Oh, another important thing going on here. You remember all that hoopla about\n * about stateful shaders? Where you store stuff in fragments of one of Shadertoy's\n * fuuuhiiiiiinnee buffer objects? We do that here to calculate the camera position\n * once, and share it with everyone else. It's stored in plain sight at pixel\n * (2,2) in this buffer. (It's obscured by all the other stuff done in the render\n * though).\n *\n * Since we store the camera position and intersection No 1, this buffer also stores\n * ray direction. (Which is ||(intersection - cam position)||\n *\n * Distances are stored at 1/1000th their actual value to sidestep precision issues.\n */\n\n// Main marching steps.\n#define V_STEPS 120\n// Maximum acceptable marching result.\n#define EPSILON .01\n// Max ray depth.\n#define MAX_DEPTH 75.0\n\n// Entity IDs.\n#define ID_NONE\t\t0.0\n#define ID_GROUND\t1.0\n#define ID_WALLS\t2.0\n#define ID_CEILING\t3.0\n#define ID_CUTOUT\t4.0\n#define ID_CUTCEIL\t5.0\n#define ID_CAULDR\t6.0\n#define ID_CANDLES\t7.0\n#define ID_WINDOW\t8.0\n#define ID_END\t\t9.0\n\n// iChannel definition.\n#define POS_BUFF iChannel0\n#define NOISE_TEX iChannel1\n\n\n// Some constants for rendering.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 TX_CPOS = vec2(2,2);\t\t\t\t\t\t// The pixel in which we store the camera position.\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.894427, 0.357771, 0.268328); \t// Sun direction.\n\n/* \n    Buff is a value that must be written to fragCoord.\n\tif the current frag coord is that of where we want to store\n\tour data, buff is overwritten. Otherwise, buff is returned\n\tas is.\n*/\nvoid write4( inout vec4 buff, in vec4 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.1,max(off.x,off.y)) );\n}\n\n/*\n\tA linear Bezier function.\n*/\nvec3 lb(vec3 a, vec3 b, float t)\n{\n    return mix(a, b, t);\n}\n\n/*\n\tThe first derivative of a linear Bezier function.\n*/\nvec3 dlb(vec3 a, vec3 b, float t)\n{\n    return normalize( b - a );\n}\n\n/*\n\tA quadratic Bezier function.\n*/\nvec3 qb(vec3 a, vec3 b, vec3 c, float t)\n{\n\treturn mix( mix(a,b,t), mix(b,c,t), t);\n}\n\n/*\n\tThe first derivative of a quadratic Bezier function.\n*/\nvec3 dqb(vec3 a, vec3 b, vec3 c, float t)\n{\n    return normalize( (2.0-2.0*t)*(b-a) + 2.0*t*(c-b) );\n}\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n    vec3 fakeLeft = cross(cd,UP);\n    vec3 realUp = cross(fakeLeft,cd);\n    vec3 realLeft = cross(cd,realUp);\n\trd = normalize((cp + cd*f + normalize(realLeft)*uv.x + normalize(realUp)*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade(in float s, in float e, in float t, in float duration)\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n/*\n\tSets up camera direction and position along a linear Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid lCamPath(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = lb(a, b, smoothstep(s, e, t));\n\tcd = dlb(a, b, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a quadratic Bezier curve, based\n\ton start and end times, and start and end positions.\n*/\nvoid qCamPath(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = qb(a, b, c, smoothstep(s, e, t));\n\tcd = -cross(dqb(a, b, c, smoothstep(s, e, t)), UP);\n\tshutter = shutterfade(s, e, t, f);\n}\n\nvoid cCamPath(in float s, in float e, in float f,\n              in vec3 c, float d, in float sr, in float er, in float t,\n              out vec3 cp, out vec3 cd, out float shutter)\n{\n    float r = mix(sr,er,smoothstep(s,e,t));\n    cp = c+vec3(d*cos(r),0,d*sin(r));\n    cd = normalize(cp-c);\n    shutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tAnimates the camera, choosing a path based on the current time. Also\n\tperforms camera shuttering.\n\tAll the camera directions are pre-normalized, so they look a little\n\tfunky in the code itself.\n*/\nvoid animCam(in vec2 uv, in float t, out vec3 ro, out vec3 rd, out float shutter)\n{\n\t// \"Yeah I'm not gonna const-out all of those positions.\" ROUND 2\n\tvec3 cp, cd;\n\tt = mod(t, 60.0);\n\tif( t >= 0.0 && t < 5.0 )\n\t{\n\t\tlCamPath(0.0, 5.0, .5, \n                 vec3(-2.25, 8.0, 12.0), vec3(-2.25, 4.0, 12.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(.3,.05,.5));\n        cd = vec3(0.512615, 0.0854358, 0.854358);\n\t\tcamera(uv, cp, cd, .8, ro, rd);\n\t}\n\telse if( t >= 5.0 && t < 9.998 )\n\t{\n\t\tlCamPath(5.0, 10.0, .5, \n\t\t\t\t vec3(-2.0, 7.0, 12.0), vec3(-2.0, 7.0, 5.0),\n\t\t\t\t t, cp, cd, shutter);\n        cd = vec3(1,0,0);\n\t\tcamera(uv, cp, cd, .8, ro, rd);\n\t}\n    // This is for the screenshot.\n    else if(t >= 9.998 && t < 10.016)\n    {\n        camera(uv, vec3(-2.25, 6.0, 12.0), vec3(0.512615, 0.0854358, 0.854358), .8, ro, rd);\n    }\n    else if( t > 10.016 && t < 15.0 )\n\t{\n\t\tcCamPath(10.0, 15.0, .5,\n                 vec3(-2.5,8.0,0.0), 2.0, -1.2, 1.2,\n                 t, cp, cd, shutter);\n\t\tcamera(uv, cp, -cd, 1.0, ro, rd);\n\t}\n    else if( t >= 15.0 && t < 20.0 )\n\t{\n\t\tlCamPath(15.0, 20.0, .5, \n\t\t\t\t vec3(-2.0, 9.0, 10.0), vec3(-2.0, 9.0, -10.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(.33,-.66,-1));\n        cd = vec3(0.265534, -0.531068, -0.804648);\n\t\tcamera(uv, cp, cd, .80, ro, rd);\n\t}\n    else if( t >= 20.0 && t < 25.0 )\n\t{\n        cCamPath(20.0, 25.0, .5,\n                 vec3(3.0,6.0,-37.5), 5.0, 1.6, 4.5,\n                 t, cp, cd, shutter);\n\t\tcamera(uv, cp, -cd, .9, ro, rd);\n\t}\n    else if( t >= 25.0 && t < 30.0 )\n\t{\n\t\tlCamPath(25.0, 30.0, .5, \n\t\t\t\t vec3(-0.0, 3.0, -15.0), vec3(-0.0, 3.0, -5.0),\n\t\t\t\t t, cp, cd, shutter);\n        cd = vec3(0,0,-1);\n        float zoom = mix(4.0,1.25,smoothstep(25.0,30.0,t));\n\t\tcamera(uv, cp, cd, zoom, ro, rd);\n\t}\n    else if( t >= 30.0 && t < 35.0 )\n\t{\n\t\tlCamPath(30.0, 35.0, .5, \n                 vec3(2.25, 8.0, -30.0), vec3(2.25, 4.0, -30.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(-.3,.05,-.5));\n        cd = vec3(-0.512615, 0.0854358, -0.854358);\n\t\tcamera(uv, cp, cd, .8, ro, rd);\t\t\n\t}\n    else if( t >= 35.0 && t < 40.0 )\n\t{\n\t\tlCamPath(35.0, 40.0, .5, \n\t\t\t\t vec3(2.0, 6.0, 45.0), vec3(-2.0, 6.0, 45.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(.15,0,1));\n        cd = vec3(0.14834, 0., 0.988936);\n\t\tcamera(uv, cp, cd, 4.0, ro, rd);\t\t\n\t}\n    else if( t >= 40.0 && t < 45.0 )\n    {\n        lCamPath(40.0, 45.0, .5, \n                 vec3(0.0, 2.0, 3.0), vec3(0.0, 2.0, 10.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(.3,.25,.5));\n        cd = vec3(0.472866, 0.394055, 0.78811);\n\t\tcamera(uv, cp, cd, .8, ro, rd);\n    }\n    else if( t >= 45.0 && t < 50.0 )\n    {\n\t\tcCamPath(45.0, 50.0, .5,\n                 vec3(2.0,4.0,-7.5), 0.1, -1.2, 1.2,\n                 t, cp, cd, shutter);\n\t\tcamera(uv, cp, -cd, .8, ro, rd);\n    }\n    else if( t >= 50.0 && t < 55.0 )\n    {\n\t\tlCamPath(50.0, 55.0, .5, \n                 vec3(2.0, 2.5, 21.0), vec3(2.0, 2.5, 21.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(1,2,1));\n        cd = vec3(0.408248, 0.816497, 0.408248);\n        float zoom = mix(.75,1.5,smoothstep(50.0,55.0,t));\n\t\tcamera(uv, cp, cd, zoom, ro, rd);\n    }\n    else if( t >= 55.0 && t < 60.0 )\n    {\n        lCamPath(55.0, 60.0, .5, \n\t\t\t\t vec3(-2.0, 1.0, -30.0), vec3(-2.0, 1.0, -55.0),\n\t\t\t\t t, cp, cd, shutter);\n        // cd = normalize(vec3(.4,.3,-.4));\n        cd = vec3(0.624695, 0.468521, -0.624695);\n\t\tcamera(uv, cp, cd, 1.0, ro, rd);\n    }\n}\n/*\n\tReturns a psuedo random value given a 3D vector.\n*/\nfloat hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tReturns a psuedo-random value given a 2D vector.\n*/\nfloat hash( vec2 x )\n{\n\tx = vec2( dot(x,vec2(311.7, 74.7)),\n\t\t\t  dot(x,vec2(183.3,246.1)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tA 2D bumpmap of bricks. This is used for the ceiling only.\n\tThis one doesn't use an external bump map, and so each brick is even.\n\tThis, and all the other brick functions work by creating a local floating\n\tpoint space by calling fract(), and then doing transformations on that result.\n*/\nfloat brickBump( in vec2 p )\n{\n    // Go ahead and stretch out the incoming coordinates.\n    p.x *= .5;\n    // Move over every other row of bricks, using the floor of the\n    // Y coordinate.\n    p.x += .5*floor(mod(p.y,2.0));\n    // Transform the result to -1,1\n    vec2 f = 2.0-fract(p) - 1.0;\n    \n    // blend between a fractional distance (.966) from the center of our local\n    // space and the edge of it, so our bricks are a bit rounded. This\n    // cuts down some aliasing.\n    return smoothstep(.966,1.0,max(f.x,f.y));\n}\n\n/*\n\tThis provides the tile bumpmap for the ground.\n*/\nfloat groundBump( in vec3 p )\n{\n    // vec3 f = fract(p);\n    p = fract(p); // Reuse p. We weren't using it anyway.\n    return smoothstep(.966,.975,max(p.x,max(p.y,p.z)));\n}\n\n/*\n\tCreates the bumpmap for the wall. This is the simple version that's\n\tdefined in 2D space. It's used for the walls and the endcaps. It's\n\tremarkably similar to brickBump2D(), except it's also influenced by\n\ta texture based displacement map.\n*/\nfloat wallBump2D( in vec2 p )\n{\n    // Resize and scoot over every other row.\n    p *= 2.0;\n    p.x *= .5;\n    p.x += .5*floor(mod(p.y,2.0));\n    \n    // Dive into fractional space.\n    vec2 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,f.y));\n    r *= .1 + hash(800.0*floor(p))*.8 + .05; // We used to add some FBM here, \n    \t\t\t\t\t\t\t\t\t\t // but we don't need it in this \n    \t\t\t\t\t\t\t\t\t\t // pass. So let's just add the \n    \t\t\t\t\t\t\t\t\t\t // average value of what it\n    \t\t\t\t\t\t\t\t\t\t // would have been. The FBM is now\n    \t\t\t\t\t\t\t\t\t\t // taken care of in the normal pass.\n    return 1.0 - r;\n}\n\n/*\n\tThe 3D version, on the other hand is defined in R^3 to be used in\n\tthe cutouts.\n*/\nfloat wallBump3D( in vec3 p )\n{\n    p *= 2.0;\n    p.z *= .5;\n    p.z += .5*floor(mod(p.y,2.0));\n    \n    vec3 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,max(f.y,f.z)));\n    r *= .1 + hash(800.0*floor(p))*.8 + .05; // We used to add some FBM here, \n    \t\t\t\t\t\t\t\t\t\t // but we don't need it in this \n    \t\t\t\t\t\t\t\t\t\t // pass. So let's just add the \n    \t\t\t\t\t\t\t\t\t\t // average value of what it\n    \t\t\t\t\t\t\t\t\t\t // would have been.\n    return 1.0 - r;\n}\n\n/*\n\tSamples a texture in each of R^3s principle hyperplanes, and\n\tthen uses the given surface normal to return a linear combination\n\tof those samples.\n*/\nvec3 tex3D( in sampler2D t, in vec3 p, in vec3 n )\n{\n    n = abs(n);\n    return texture(t,p.xy).rgb*n.z\n          +texture(t,p.xz).rgb*n.y\n          +texture(t,p.zy).rgb*n.x;\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tThe seminal signed cube distance function.\n*/\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAn infinitely long box that extends along the X axis.\n*/\nfloat xBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.zy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAnother infinitely long box that extends along the Y\n\taxis.\n*/\nfloat yBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.xz) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAnd yet another that goes down the Z.\n*/\nfloat zBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.xy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder along the X axis.\n*/\nfloat xCapCyl( vec3 p, vec2 c )\n{\n    // This is basically an infinite cylinder that's being chopped\n    // by a bounds.\n\tvec2 d = abs(vec2(length(p.zy),p.x)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder that stands up tall along the Y axis.\n*/\nfloat yCapCyl( vec3 p, vec2 c )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tA cylinder that extends infinitely along the Z axis.\n*/\nfloat zCyl( vec3 p, float r )\n{\n\treturn length(p.xy)-r;\n}\n\n/*\n\tIQ's pill function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tThe base tunnel. It's an infinite box, with the middle hollowed\n\tout by another.\n*/\nfloat baseTunnel( in vec3 p )\n{\n    float d =  max( zBox(p-vec3(0,6,0),vec2(5,7)),\n                   -zBox(p-vec3(0,6,0),vec2(3,6)));\n    float f = 0.0;\n    if ( d > .1 ) return d;\n    else if ( p.y > .15 )  return d + wallBump2D(p.zy)*.15;\n    else return d + groundBump(p)*.05;\n}\n\n/*\n\tThese form the far walls. We make these their own subfield so that\n\twe can use a 2D distance function on them and the walls. (As well as\n\ta 2D texturing function.)\n*/\nfloat yourPathEndsHere( in vec3 p )\n{\n    p.z = mod(p.z,172.0)-86.0;\n \tfloat d = box(p,vec3(5,12,1));\n    if ( d > EPSILON*8.0 ) return d;\n    else return d + wallBump2D(p.xy)*.15;\n}\n\n/*\n\tThe ceiling is actually a really large hollowed cylinder. It's\n\tintersected with the main tunnel so that only the ceiling\n\tpart remains.\n*/\nfloat ceiling( in vec3 p )\n{\n    p.y *= .75;\n    float r = max( zCyl(p,8.0),\n                  -zCyl(p,7.5));\n    r = max(r,zBox(p-vec3(0,6,0),vec2(4,6))); // Trim the excess that is outside the tunnel.\n    if( r > EPSILON ) return r;\n    else return r + brickBump(p.zx)*.1;\n}\n\n/*\n\tThis subfield is just the windowpanes.\n*/\nfloat windowPanes( in vec3 p )\n{\n    return abs(p.x-4.33);\n    p.x -= 4.33;\n    p.y -= 4.5;\n    p.z = mod(p.z,15.0)-7.5;\n    return box(p,vec3(.5));\n}\n\n/*\n\tThe subfield that cuts out holes in the side of the tunnel. It's\n\talso a box intersected with a cylinder.\n*/\nfloat windowCutouts( in vec3 p )\n{\n    // Base transformations to get them into position.\n    vec3 q = p;\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    float r =  max(xBox(b,vec2(1.5,4.5)),\n                   xCapCyl(c,vec2(3,4.0)));\n    \n    // Displacement mapping. If we're a safe distance away, we don't need to\n    // worry about calculating the surface. Otherwise...\n    if( r > EPSILON ) return r;\n    else if( p.y > 3.366 ) return r;// + (1.0-brickBump(p.xy*2.0,.95))*.1;\n    else return r+.15-wallBump3D(q)*.12;\n}\n\n/*\n\tThis subfield is max()'d with the tunnel to scallop those bits below\n\tthe window. It's just a positioned and mod()'d cube.\n*/\nfloat windowScallops( in vec3 p )\n{\n    // Create a copy of our location so we don't provide wallBump3D()\n    // with the same value each repetition.\n    vec3 q = p;\n    // Translate the original location.\n    p.x -= 3.0;\n    p.y -= 4.0;\n    // Repeat it using modulo.\n    p.z = mod(p.z,15.0)-7.5;\n    // Get a preliminary result.\n    float r = box(p,vec3(1,4.0,1.5));\n    // Maybe displace it, if we're close enough to matter.\n    if( r > EPSILON ) return r;\n    else return r+.15-wallBump3D(q)*.12;\n}\n\n/*\n\tA smooth version of the window cutout used for the window texture.\n*/\nfloat windowFrame( in vec3 p )\n{\n    // Base transformations to get them into position.\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    return max(xBox(b,vec2(1.5,4.5)),\n               xCapCyl(c,vec2(3,4.0)));\n}\n\n/*\n\tThe candles are just a cylinder.\n*/\nfloat candles( in vec3 p )\n{\n    // These will be on top of the bottom of the cauldrons, so we have to elevate them.\n    p += vec3(2.4,-7.9,7.5);\n    p.z = mod(p.z,15.0)-7.5; // Repeat.\n    return yCapCyl(p,vec2(.1,.2));\n}\n\n/*\n\tThe cauldrons that house the candles on the other hand\n\tare a bunch of boxes that subtract from a hollowed box,\n\tplus two more for the mount.\n*/\nfloat cauldrons( in vec3 p )\n{\n    p += vec3(2.4,-8,7.5); // Translate.\n    p.z = mod(p.z,15.0)-7.5; // Repeat.\n    \n    vec3 q = p; // For the cage.\n    q.xz *= 1.0 - (q.y-.5)*.5; // Smush it.\n    \n    // Start out with a hollowed cube.\n    float r = max(-box(q,vec3(.3)*.9),\n                   box(q,vec3(.3)));\n    \n    \n    // Then chop out an x-shaped portion with boxes.\n    q = mod(q,.3)-.15;\n  \tfloat cutout = min(xBox(q,vec2(.125)),zBox(q,vec2(.125)));\n    r = max(r,-cutout);\n    // now we need to make an arm and a mount, with two other box calls.\n    p.x += .35;\n    r = min(r,box(p,vec3(.175,.025,.025)));\n    p.x += .2;\n    return min(r,box(p,vec3(.015,.25,.25)));\n}\n\n/*\n\tThe global distance function.\n*/\nfloat dist( in vec3 p )\n{\n    float r = baseTunnel(p);\n    r = min(r,ceiling(p));\n    r = max(r,-windowCutouts(p));\n    r = max(r,-windowScallops(p));\n    r = min(r,cauldrons(p));\n    r = min(r,windowPanes(p));\n    r = min(r,yourPathEndsHere(p));\n    return min(r,candles(p));\n}\n\n/*\n\tReturns the id and distance of the nearest entity.\n*/\nfloat distID( in vec3 p )\n{\n    // Since the window cutout subfields exist WITHIN the base tunnel and ceiling,\n    // we have to make sure negative values don't get into the comparison. Using\n    // abs() instead of max() has the added benefit of biasing towards those cutout\n    // bits.\n\tvec2 closest = u(vec2(abs(ceiling(p))+EPSILON, ID_CEILING),\n\t\t\t         vec2(abs(baseTunnel(p)), mix(ID_GROUND,ID_WALLS,step(.1,p.y))));\n\t\t closest = u(closest, vec2(abs(windowCutouts(p)), mix(ID_CUTOUT,ID_CUTCEIL,step(8.425,p.y))));\n         closest = u(closest, vec2(abs(windowScallops(p)),ID_CUTOUT));\n    \t closest = u(closest, vec2(cauldrons(p), ID_CAULDR));\n    \t closest = u(closest, vec2(candles(p), ID_CANDLES));\n    \t closest = u(closest, vec2(windowPanes(p), ID_WINDOW));\n    \t closest = u(closest, vec2(yourPathEndsHere(p), ID_END));\n    return closest.t;\n\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, vec3 d )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || r > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r*.45;\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Set up the camera.\n    float shutter = 0.0;\n    animCam(uv, iTime, p, d, shutter);\n    \n\t// Store the eye position.\n    e = vec3(p);\n    \n    // Do the actual ray marching.\n    march(p,d);\n    \n    // Store the camera position so we don't have to recalc it everywhere.\n    vec4 buff = vec4(p*.001,distID(p));\n    write4(buff, vec4(e,shutter), TX_CPOS, fragCoord);\n    \n    // Store the final pixel color.\n    fragColor = buff;\n}\n\n/*\n\tThe Shadertoy VR entrypoint.\n*/\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, \n            in vec3 fragRayOri, in vec3 fragRayDir )\n{\n   vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Set up the camera.\n    float shutter = 0.0;\n    animCam(uv, iTime, p, d, shutter);\n    p += fragRayOri;\n    \n\t// Store the eye position.\n    e = vec3(p);\n    \n    // Do the actual ray marching.\n    march(p,fragRayDir);\n    \n    // Store the camera position so we don't have to recalc it everywhere.\n    vec4 buff = vec4(p*.001,distID(p));\n    write4(buff, vec4(e,shutter), TX_CPOS, fragCoord);\n    \n    // Store the final pixel color.\n    fragColor = buff;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * Castle Tunnel (Buffer B)\n * Author: Gerard Geer\n * License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n *\n * Takes the positions determined in Buffer A, picks them up from Render To Texture,\n * Elementary and throws them right into Fink's Raymarcher's Normal Calculation Factory.\n * Life's tough for a near-post-industrial-revolution fragment. At least they get to\n * live in a castle.\n * \n * (The surface normals are calculated the normal way one does in raymarched scenes,\n * just with precomputed values.) \n */\n\n// Comment this out if you want more speed.\n#define DO_IMG_NORM_MAPS\n\n// Maximum successful marching distance.\n#define EPSILON .005\n\n// iChannel definition.\n#define POS_BUFF iChannel0\n#define NOISE_TEX iChannel1\n\n// Some constants for rendering.\n#define BUFF_RES iChannelResolution[0].xy\n\n\n/* \n    Reads a texel from a sampler2D at a given position.\n*/\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/* \n    Buff is a value that must be written to fragCoord.\n\tif the current frag coord is that of where we want to store\n\tour data, buff is overwritten. Otherwise, buff is returned\n\tas is.\n*/\nvoid write3( inout vec3 buff, in vec3 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.1,max(off.x,off.y)) );\n}\n\n/*\n\tReturns a psuedo random value given a 3D vector.\n*/\nfloat hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tReturns a psuedo-random value given a 2D vector.\n*/\nfloat hash( vec2 x )\n{\n\tx = vec2( dot(x,vec2(311.7, 74.7)),\n\t\t\t  dot(x,vec2(183.3,246.1)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tWe have an extra channel available here, so we can use the\n\ttexture-lookup version of IQ's noise!\n*/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( NOISE_TEX, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tAn FBM of such noise.\n*/\nfloat fbm( in vec3 p )\n{\n    float r = noise(p)*.500;\n    r += noise(p*2.0)*.250;\n    r += noise(p*4.0)*.125;\n    return r *1.1429;\n}\n\n/*\n\tA 2D bumpmap of bricks. This is used for the ceiling and the walls.\n*/\nfloat brickBump( in vec2 p, in float s )\n{\n    p.x *= .5;\n    p.x += .5*floor(mod(p.y,2.0));\n    vec2 f = 2.0-fract(p) - 1.0;\n    return smoothstep(s,1.0,max(f.x,f.y));\n}\n\n/*\n\tThis provides the tile bumpmap for the ground.\n*/\nfloat groundBump( in vec3 p )\n{\n    vec3 f = fract(p);\n    \n    #ifdef DO_IMG_NORM_MAPS\n    return smoothstep(.966,.975,max(f.x,max(f.y,f.z)))+fbm(p*2.0+hash(floor(p)));\n    #else\n    return smoothstep(.966,.975,max(f.x,max(f.y,f.z)))+.5;\n    #endif\n}\n\n/*\n\tCreates the bumpmap for the wall. This is the simple version that's\n\tdefined in 2D space. It's used for the walls and the endcaps.\n*/\nfloat wallBump2D( in vec2 p )\n{\n    p *= 2.0;\n    p.x *= .5;\n    p.x += .5*floor(mod(p.y,2.0));\n    \n    vec2 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,f.y));\n    \n    #ifdef DO_IMG_NORM_MAPS\n    r *= .1 + hash(800.0*floor(p))*.8 + fbm(vec3(p*8.0,0))*.1;\n    #else\n    r *= .1 + hash(800.0*floor(p))*.8+.05;\n    #endif\n    return 1.0 - r;\n}\n\n/*\n\tThe 3D version, on the other hand is defined in R^3 to be used in\n\tthe cutouts.\n*/\nfloat wallBump3D( in vec3 p )\n{\n    p *= 2.0;\n    p.z *= .5;\n    p.z += .5*floor(mod(p.y,2.0));\n    \n    vec3 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,max(f.y,f.z)));\n    #ifdef DO_IMG_NORM_MAPS\n    r *= .1 + hash(800.0*floor(p))*.8 + fbm(p*8.0)*.1;\n    #else\n    r *= .1 + hash(800.0*floor(p))*.8 + .05;\n    #endif\n    \n    return 1.0 - r;\n}\n\n/*\n\tSamples a texture in each of R^3s principle hyperplanes, and\n\tthen uses the given surface normal to return a linear combination\n\tof those samples.\n*/\nvec3 tex3D( in sampler2D t, in vec3 p, in vec3 n )\n{\n    n = abs(n);\n    return texture(t,p.xy).rgb*n.z\n          +texture(t,p.xz).rgb*n.y\n          +texture(t,p.zy).rgb*n.x;\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tThe seminal signed cube distance function.\n*/\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAn infinitely long box that extends along the X axis.\n*/\nfloat xBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.zy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAnother infinitely long box that extends along the Y\n\taxis.\n*/\nfloat yBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.xz) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAnd yet another that goes down the Z.\n*/\nfloat zBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.xy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder along the X axis.\n*/\nfloat xCapCyl( vec3 p, vec2 c )\n{\n    // This is basically an infinite cylinder that's being chopped\n    // by a bounds.\n\tvec2 d = abs(vec2(length(p.zy),p.x)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder that stands up tall along the Y axis.\n*/\nfloat yCapCyl( vec3 p, vec2 c )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tA cylinder that extends infinitely along the Z axis.\n*/\nfloat zCyl( vec3 p, float r )\n{\n\treturn length(p.xy)-r;\n}\n\n/*\n\tIQ's pill function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n/*\n\tThe base tunnel. It's an infinite box, with the middle hollowed\n\tout by another.\n*/\nfloat baseTunnel( in vec3 p )\n{\n    float d =  max( zBox(p-vec3(0,6,0),vec2(5,7)),\n                   -zBox(p-vec3(0,6,0),vec2(3,6)));\n    float f = 0.0;\n    if ( d > EPSILON*8.0 ) return d;\n    else if ( p.y > .15 )  return d + wallBump2D(p.zy)*.15;\n    else return d + groundBump(p)*.05;\n}\n\n/*\n\tThese form the far walls. We make these their own subfield so that\n\twe can use a 2D distance function on them and the walls. (As well as\n\ta 2D texturing function.)\n*/\nfloat yourPathEndsHere( in vec3 p )\n{\n    p.z = mod(p.z,172.0)-86.0;\n \tfloat d = box(p,vec3(5,12,1));\n    if ( d > EPSILON*8.0 ) return d;\n    else return d + wallBump2D(p.xy)*.15;\n}\n\n/*\n\tThe ceiling is actually a really large hollowed cylinder. It's\n\tintersected with the main tunnel so that only the ceiling\n\tpart remains.\n*/\nfloat ceiling( in vec3 p )\n{\n    p.y *= .75;\n    float r = max( zCyl(p,8.0),\n                  -zCyl(p,7.5));\n    r = max(r,zBox(p-vec3(0,6,0),vec2(4,6))); // Trim the excess that is outside the tunnel.\n    if( r > EPSILON ) return r;\n    else return r + brickBump(p.zx,.975)*.1;\n}\n\n/*\n\tThis subfield is just the windowpanes.\n*/\nfloat windowPanes( in vec3 p )\n{\n    return abs(p.x-4.33);\n    p.x -= 4.33;\n    p.y -= 4.5;\n    p.z = mod(p.z,15.0)-7.5;\n    return box(p,vec3(.5));\n}\n\n/*\n\tThe subfield that cuts out holes in the side of the tunnel. It's\n\talso a box intersected with a cylinder.\n*/\nfloat windowCutouts( in vec3 p )\n{\n    // Base transformations to get them into position.\n    vec3 q = p;\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    float r =  max(xBox(b,vec2(1.5,4.5)),\n                   xCapCyl(c,vec2(3,4.0)));\n    \n    // Displacement mapping. If we're a safe distance away, we don't need to\n    // worry about calculating the surface. Otherwise...\n    if( r > EPSILON ) return r;\n    else if( p.y > 3.366 ) return r;// + (1.0-brickBump(p.xy*2.0,.95))*.1;\n    else return r+.15-wallBump3D(q)*.12;\n}\n\n/*\n\tThis subfield is max()'d with the tunnel to scallop those bits below\n\tthe window. It's just a positioned and mod()'d cube.\n*/\nfloat windowScallops( in vec3 p )\n{\n    vec3 q = p;\n    p.x -= 3.0;\n    p.y -= 4.0;\n    p.z = mod(p.z,15.0)-7.5;\n    float r = box(p,vec3(1,4.0,1.5));\n    if( r > EPSILON ) return r;\n    else return r+.15-wallBump3D(q)*.12;\n}\n\n/*\n\tA smooth version of the window cutout used for the window texture.\n*/\nfloat windowFrame( in vec3 p )\n{\n    // Base transformations to get them into position.\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    return max(xBox(b,vec2(1.5,4.5)),\n               xCapCyl(c,vec2(3,4.0)));\n}\n\n/*\n\tThe candles are just a cylinder.\n*/\nfloat candles( in vec3 p )\n{\n    // These will be on top of the bottom of the cauldrons, so we have to elevate them.\n    p += vec3(2.4,-7.9,7.5);\n    p.z = mod(p.z,15.0)-7.5; // Repeat.\n    return yCapCyl(p,vec2(.1,.2));\n}\n\n/*\n\tThe cauldrons that house the candles on the other hand\n\tare a bunch of boxes that subtract from a hollowed box,\n\tplus two more for the mount.\n*/\nfloat cauldrons( in vec3 p )\n{\n    p += vec3(2.4,-8,7.5); // Translate.\n    p.z = mod(p.z,15.0)-7.5; // Repeat.\n    \n    vec3 q = p; // For the cage.\n    q.xz *= 1.0 - (q.y-.5)*.5; // Smush it.\n    \n    // Start out with a hollowed cube.\n    float r = max(-box(q,vec3(.3)*.9),\n                   box(q,vec3(.3)));\n    \n    \n    // Then chop out an x-shaped portion with boxes.\n    q = mod(q,.3)-.15;\n  \tfloat cutout = min(xBox(q,vec2(.125)),zBox(q,vec2(.125)));\n    r = max(r,-cutout);\n    // now we need to make an arm and a mount, with two other box calls.\n    p.x += .35;\n    r = min(r,box(p,vec3(.175,.025,.025)));\n    p.x += .2;\n    return min(r,box(p,vec3(.015,.25,.25)));\n}\n\n/*\n\tThe global distance function.\n*/\nfloat dist( in vec3 p )\n{\n    float r = baseTunnel(p);\n    r = min(r,ceiling(p));\n    r = max(r,-windowCutouts(p));\n    r = max(r,-windowScallops(p));\n    r = min(r,cauldrons(p));\n    r = min(r,windowPanes(p));\n    r = min(r,yourPathEndsHere(p));\n    return min(r,candles(p));\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load and re-inflate the fragment position.\n    vec3 p=texture(POS_BUFF,fragCoord/iResolution.xy).rgb*1000.0;\n    \n    // Store the surface normal.\n    fragColor = vec4(norm(p).rgbb);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/**\n * Castle Tunnel (Buffer C)\n * Author: Gerard Geer\n * License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n *\n * So you take a normal, and you take a position, ya look at 'em really hard,\n * and out pops a texel of a texture!\n *\n * Or rather, we use the products from buffers A and B to compute the various\n * semi-procedural textures used in the scene.\n */\n\n// Entity IDs.\n#define ID_NONE\t\t0.0\n#define ID_GROUND\t1.0\n#define ID_WALLS\t2.0\n#define ID_CEILING\t3.0\n#define ID_CUTOUT\t4.0\n#define ID_CUTCEIL\t5.0\n#define ID_CAULDR\t6.0\n#define ID_CANDLES\t7.0\n#define ID_WINDOW\t8.0\n#define ID_END\t\t9.0\n\n// iChannel definitions.\n#define POS_BUFF iChannel0\n#define NRM_BUFF iChannel1\n#define NOISE_TEX iChannel2\n#define STONE_TEX iChannel3\n\n// Some constants for rendering.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 TX_CPOS = vec2(2,2);\t\t\t\t\t\t// The pixel in which we store the camera position.\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.894427, 0.357771, 0.268328); \t// Sun direction.\nconst vec3 SKY_COLOR = vec3(0.53,0.81,0.92);\t\t// Sky color.\nconst vec3 SUN_COLOR = vec3(4.0);\t\t\t\t\t// Sun color.\nconst vec3 GROUND_COLOR = vec3(0.73,0.70,0.75);\t\t// Average color of the ground for GI.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t// ... and the second as well.\n\n/* \n    Reads a texel from a sampler2D at a given position.\n*/\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a psuedo random value given a 3D vector.\n*/\nfloat hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tReturns a psuedo-random value given a 2D vector.\n*/\nfloat hash( vec2 x )\n{\n\tx = vec2( dot(x,vec2(311.7, 74.7)),\n\t\t\t  dot(x,vec2(183.3,246.1)));\n\n\treturn fract(length(sin(x)*43758.5453123));\n}\n\n/*\n\tWe have an extra channel available here, so we can use the\n\ttexture-lookup version of IQ's noise!\n*/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( NOISE_TEX, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tAn FBM of such noise.\n*/\nfloat fbm( in vec3 p )\n{\n    float r = noise(p)*.500;\n    r += noise(p*2.0)*.250;\n    r += noise(p*4.0)*.125;\n    return r *1.1429;\n}\n\n/*\n\tCreates the bumpmap for the wall. This is the simple version that's\n\tdefined in 2D space. It's used for the walls and the endcaps.\n*/\nfloat wallBump2D( in vec2 p )\n{\n    p *= 2.0;\n    p.x *= .5;\n    p.x += .5*floor(mod(p.y,2.0));\n    \n    vec2 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,f.y));\n    r *= .1 + hash(800.0*floor(p))*.8 + fbm(vec3(p*8.0,0))*.1;\n    return 1.0 - r;\n}\n\n/*\n\tThe 3D version, on the other hand is defined in R^3 to be used in\n\tthe cutouts.\n*/\nfloat wallBump3D( in vec3 p )\n{\n    p *= 2.0;\n    p.z *= .5;\n    p.z += .5*floor(mod(p.y,2.0));\n    \n    vec3 f = 2.0*fract(p) - 1.0;\n    float r = 1.0 - smoothstep(.825,.95,max(f.x,max(f.y,f.z)));\n    r *= .1 + hash(800.0*floor(p))*.8 + fbm(p*8.0)*.1;\n    return 1.0 - r;\n}\n\n/*\n\tSamples a texture in each of R^3s principle hyperplanes, and\n\tthen uses the given surface normal to return a linear combination\n\tof those samples.\n*/\nvec3 tex3D( in sampler2D t, in vec3 p, in vec3 n )\n{\n    n = abs(n);\n    return texture(t,p.xy).rgb*n.z\n          +texture(t,p.xz).rgb*n.y\n          +texture(t,p.zy).rgb*n.x;\n}\n\n/*\n\tAn infinitely long box that extends along the X axis.\n*/\nfloat xBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.zy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder along the X axis.\n*/\nfloat xCapCyl( vec3 p, vec2 c )\n{\n    // This is basically an infinite cylinder that's being chopped\n    // by a bounds.\n\tvec2 d = abs(vec2(length(p.zy),p.x)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tA smooth version of the window cutout used for the window texture.\n*/\nfloat windowFrame( in vec3 p )\n{\n    // Base transformations to get them into position.\n    p.y -= 5.0;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    b.x *= 20.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    return max(xBox(b,vec2(1.45,4.5)),\n               xCapCyl(c,vec2(3,4.0)));\n}\n\n/*\n\tMixes between two colors based on the upward angle of the\n\tray direction for a plausible sky.\n*/\nvec3 sky( vec3 d )\n{\n    vec3 flatD = normalize(vec3(d.x,0.0,d.z));\n    float cTheta = dot(vec3(0,0,1),flatD);\n    float cPhi = dot(d,flatD);\n    vec3 ground = mix(vec3(.5,.7,.3),vec3(.1,.3,.1),fbm(vec3(cTheta,cPhi,0)*5.0));\n    return mix(ground,SKY_COLOR*1.75,smoothstep(-.2,-.1,d.y));\n}\n\n/*\n\tGenerates the texture for the walls. Notice that there is\n\talso grout! It's 2D since we only use it on something that's in the YZ plane.\n*/\nvec3 wallTex2D( in vec2 p )\n{\n    // Since the cutouts need to be textured on more than one hyperplane,\n    // we need to use a 3D texturing function.\n    float b = 1.0-wallBump2D(p);\n    vec3 grout = mix(vec3(.5),vec3(1.0),hash(p));\n    \n    // Now we need to to some texture sampling. Let's randomize\n    // the patch each brick takes.\n    vec2 q = p * 2.0;\n    q.x *= .5;\n    p += hash(floor(q));\n    vec3 bricks = texture(STONE_TEX,p*.025,-1000.0).rgb*.6 + texture(STONE_TEX,(p*2.+.125),-1000.0).rgb*.3+grout*.4;\n    return mix(grout,bricks,step(.1,b))*.375;\n}\n\n/*\n\tGenerates the texture for the cutout spots. This is 3D.\n*/\nvec3 wallTex3D( in vec3 p, in vec3 n )\n{\n    // Since the cutouts need to be textured on more than one hyperplane,\n    // we need to use a 3D texturing function.\n    float b = 1.0-wallBump3D(p);\n    vec3 grout = mix(vec3(.5),vec3(1.0),hash(p));\n    \n    // Now we need to to some texture sampling. Let's randomize\n    // the patch each brick takes.\n    vec3 q = p * 2.0;\n    q.x *= .5;\n    p += hash(floor(q));\n    vec3 bricks = tex3D(STONE_TEX,p*.025,n).rgb;\n    return mix(grout,bricks,step(.1,b))*.250+.125;\n}\n\n/*\n\tGenerates the tiled texture for the ground.\n*/\nvec3 groundTex( in vec2 p )\n{\n    vec2 f = fract(p);\n    vec2 g = floor(p);\n    float tile = .7+fbm(vec3(p*10.0+hash(g),0))*.3;\n    vec3 r = mix(vec3(.25),vec3(.75),hash(g))*tile;\n    \n    r = mix(r,vec3(.0)+hash(p)*.5,step(.975,max(f.x,f.y)));\n    return r;\n}\n\nvec3 windowTex( in vec3 p, in vec3 d )\n{\n    // Scale the wires.\n    vec3 q = p*5.0;\n    \n    // Rotate them 45 degrees.\n    q.zy *= mat2(0.7071,0.7071,-0.7071,0.7071); // Column major.\n    \n    // Work in fractional space.\n\tvec3 f = fract(q);\n    f = f*2.0-1.0;\n    \n    // Get a coefficient for how far away we are from the wires.\n    float wires = 1.0-smoothstep(0.8,1.05,max(f.z,f.y));\n    \n    // Oh the frame is fun. It's the distance to a subfield.\n    float frame = step(.15,abs(windowFrame(p)));\n    \n    // Compute the color of the features.\n    vec3 color = mix(vec3(.025,.02,.01),vec3(.01),frame);\n    \n    // Mix that color with what we would see outside the window.\n    return mix(color, sky(d), min(wires,frame));  \n}\n\n/*\n\tMost of the fancy effects are fake. The sss of the candles is\n\tno exception.\n*/\nvec3 candleTex( in vec3 p )\n{\n    vec3 cColor = vec3(.9,.8,.7);\n    return mix(cColor,cColor*.5,smoothstep(8.1,7.7,p.y));\n}\n\n/*\n\tTextures the cauldrons.\n*/\nvec3 cauldronTex( in vec3 p )\n{\n    float n = noise(p*15.0);\n    n = smoothstep(.6,.9,n);\n    return mix(vec3(.1),vec3(.2,.14,.1),n);\n}\n\n/*\n\tTakes a position and eye coordinate and returns the\n\ttexture of the nearest object to the given position.\n*/\nvec3 tex( in vec3 p, in vec3 d, in float i, in vec3 n, in vec3 e )\n{\n    if( i == ID_WALLS ) return wallTex2D(p.zy);\n    else if( i == ID_GROUND ) return groundTex(p.xz);\n    else if( i == ID_CAULDR ) return cauldronTex(p);\n    else if( i == ID_CANDLES ) return candleTex(p);\n    else if( i == ID_WINDOW ) return windowTex(p,d);\n    else if( i == ID_CEILING ) return vec3(.6);\n    else if( i == ID_CUTOUT ) return wallTex3D(p,n);\n    else if( i == ID_CUTCEIL ) return vec3(1.0);\n    else if( i == ID_END ) return wallTex2D(p.xy);\n    else return vec3(1,0,1);\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Position, direction, and eye.\n    vec3 p,d,n,e;\n    float i; // Entity ID.\n    \n    // Load the camera position from file.\n    e = readTexel(POS_BUFF,TX_CPOS).rgb;\n    // Load the other stuff.\n    vec4 pos = texture(POS_BUFF,fragCoord/iResolution.xy) * vec4(1000,1000,1000,1);\n    p = pos.xyz;\n    d = normalize(p-e);\n    n = texture(NRM_BUFF,fragCoord/iResolution.xy).rgb;\n    i = pos.w;\n    \n    \n    // Store the final pixel color.\n    fragColor = vec4(tex(p,d,i,n,e),i);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/**\n * Castle Tunnel (Buffer D)\n * Author: Gerard Geer\n * License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n *\n * This shader is fun. It \"calculates\" crepuscular rays.\n * This pass marches it's own (very simple field) using the camera position and ray \n * positions stored in buffer A.\n * \n * What's in this DF, you ask? A super basic version of the tunnel, and some funky\n * flip-turned version of the subfield used to cut out the window openings.\n * \n * To get the lightshafts we just march fixed-step until we hit the tunnel.\n * And if any step along the way happens to land us inside one of the light shafts,\n * we add a little to our 401k. (Or a value that represents how prominent the shafts\n * are along this ray.\n *\n * I was going to ray-trace this part, but getting that round top broke my resolve\n * to do so. :/\n */\n\n// Comment this out to disable crepuscular rays.\n#define GO_AHEAD_AND_MAKE_ME_CREPES_FOR_BREAKFAST\n\n// Occlusion samples.\n#define SFT_STEPS 400\n#define MAX_DEPTH 100.0\n\n// iChannel definitions.\n#define POS_BUFF iChannel0\n#define NRM_BUFF iChannel1\n\n// Some constants for rendering.\n#define BUFF_RES iChannelResolution[0].xy\nconst vec2 TX_CPOS = vec2(2,2);\t\t\t\t\t\t// The pixel in which we store the camera position.\nconst vec3 SUN_COLOR = vec3(1,.95,.9);\t\t\t\t\t// Sun color.\n\n/* \n    Reads a texel from a sampler2D at a given position.\n*/\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texture(buff, (p+.5)/BUFF_RES);\n}\n\n/*\n\tGenerates a quick rotation matrix.\n*/\nmat2 rotMat( in float r )\n{\n    float cr = cos(r), sr = sin(r);\n    return mat2(cr,sr,-sr,cr); // Column major.\n}\n\n/*\n\tThe seminal signed cube distance function.\n*/\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAn infinitely long box that extends along the X axis.\n*/\nfloat xBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.zy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tAnd yet another that goes down the Z.\n*/\nfloat zBox( vec3 p, vec2 b )\n{\n\tvec2 d = abs(p.xy) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n/*\n\tA capped cylinder along the X axis.\n*/\nfloat xCapCyl( vec3 p, vec2 c )\n{\n    // This is basically an infinite cylinder that's being chopped\n    // by a bounds.\n\tvec2 d = abs(vec2(length(p.zy),p.x)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/*\n\tThe base tunnel. It's an infinite box, with the middle hollowed\n\tout by another.\n*/\nfloat baseTunnel( in vec3 p )\n{\n    float d =  max( zBox(p-vec3(0,6,0),vec2(5,7)),\n                   -zBox(p-vec3(0,6,0),vec2(3,6)));\n    float f = 0.0;\n    return d;\n}\n\n/*\n\tThese form the far walls. We make these their own subfield so that\n\twe can use a 2D distance function on them and the walls. (As well as\n\ta 2D texturing function.)\n*/\nfloat yourPathEndsHere( in vec3 p )\n{\n    p.z = mod(p.z,172.0)-86.0;\n \tfloat d = box(p,vec3(5,12,1));\n    return d;\n}\n\n/*\n\tThe subfield that cuts out holes in the side of the tunnel. It's\n\talso a box intersected with a cylinder.\n*/\nfloat windowCutouts( in vec3 p )\n{\n    // Base transformations to get them into position.\n    p.y -= 3.8;\n    p.x -= 3.0;\n    p.z = mod(p.z, 15.0)-7.5; // Repeat along the Z axis.\n    p.xy *= rotMat(.38);\n    p.zx *= rotMat(.325);\n    \n    // Create copies of the position for the cylinder and the cube.\n    vec3 c = p, b = p;\n    // Do independent transformations for both parts.\n    c.y *= .75;\n    b.y -= 4.0;\n    // Here's the base distance sampling. Notice how we combine the xBox and \n    // the xCapCyl.\n    float r =  max(xBox(b,vec2(.95,3.60)),\n                   xCapCyl(c,vec2(2.95,20.0)));\n    \n    return r;\n}\n\n/*\n\tMarches out some sunshafts. It's SUPER EXPENSIVE.\n*/\nfloat sunshafts( in vec3 p, vec3 d )\n{\n\tfloat t = 0.0, r = 0.0;\n    vec3 c = p;\n\tfor(int i = 0; i < SFT_STEPS; ++i)\n\t{\n        c = p + t*d;\n\t\tif( min(baseTunnel(c),yourPathEndsHere(c)) < 0.0 ) return r;\n        r += .00125*step(0.0,-windowCutouts(c));\n        t += .125;\n\t}\n\treturn r;\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifndef GO_AHEAD_AND_MAKE_ME_CREPES_FOR_BREAKFAST\n    fragColor = vec4(0);return;\n    #endif\n    \n    //fragColor = texture(TEX_BUFF,fragCoord/iResolution.xy);return;\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, texture, normal, and eye.\n    vec3 p,d,e;\n    \n    // Load the camera position from file.\n    p = texture(POS_BUFF,fragCoord/iResolution.xy).xyz*1000.0;\n    e = readTexel(POS_BUFF,TX_CPOS).rgb;\n    d = normalize(p-e);\n    \n    // Store the final pixel color.\n    fragColor = vec4(sunshafts(e, d)*SUN_COLOR,1);\n}","name":"Buffer D","description":"","type":"buffer"}]}