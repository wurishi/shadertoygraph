{"ver":"0.1","info":{"id":"ldK3W3","date":"1456825278","viewed":1381,"name":"Heaven Forest","username":"Unix","description":"Shader Heaven Forest used in Secret Society Hoodlum Demo... Enjoy ;-)\nSecret Society : http://www.pouet.net/prod.php?which=65399","likes":56,"published":1,"flags":64,"usePreview":0,"tags":["tree","forest","secret","heaven","hoodlum","unix","society"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mss3zS","filepath":"https://soundcloud.com/imalogic/secret-society","previewfilepath":"https://soundcloud.com/imalogic/secret-society","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Lovera - Unix/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Shader used in SecretSociety Demo\n// Originally from Xyptonjtroz by Dave Hoskins + nimitz (twitter: @stormoid)\n\n#define ITR 100\n#define FAR 80.\n#define time iTime\n#define MOD3 vec3(.16532,.17369,.15787)\n#define SUN_COLOUR  vec3(1., .65, .35)\n#define FOUR-D_NOISE\t// ...Or this\n\n \nfloat height(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    h -= sin(h*10.0)*.1;\n    return h;\n}\n\nfloat camHeight(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    return h;\n}\n\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat smin( float a, float b)\n{\n\tconst float k = 2.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\nfloat tri(in float x){return abs(fract(x)-.5);}\n\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nfloat vine(vec3 p, in float c, in float h)\n{\n    p.y += sin(p.z*.1625+1.3)*8.5-.5;\n    p.x += cos(p.z*.1575)*1.;\n    vec2 q = vec2(mod(p.x, c)-c/2., p.y);\n    return length(q) - h*1.4 -sin(p.z*3.+sin(p.x*7.)*0.5)*0.1;\n}\n\nvec4 quad(in vec4 p){return abs(fract(p.yzwx+p.wzxy)-.5);}\n\nfloat Noise3d(in vec3 q)\n{\n    \n    float z=1.4;\n    vec4 p = vec4(q, iTime*.5);\n\tfloat rz = 0.;\n    vec4 bp = p;\n\tfor (float i=0.; i<= 2.; i++ )\n\t{\n      vec4 dg = quad(bp);\n        p += (dg);\n\n\t\tz *= 1.5;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.w+tri(p.y+tri(p.x)))))/z;\n        \n        bp = bp.yxzw*2.0+.14;\n\t}\n\treturn rz;\n}\n\nvec2 hash22(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nfloat map(vec3 p)\n{\n    p.y += height(p.zx);    \n    vec2 hs = hash22(floor(p.zx*20.));\n    p.xz *=.42;\n    p.zx = mod(p.zx,4.)-2.;\t\t\n\tfloat d = (p.y)+0.5;    \n\tp.y -= hs.x*2.4+1.15;\n\td = smin(d, vine(p.zyx+vec3(3.2+sin(iTime)*0.5,2.1,20.1+cos(iTime)*1.0),1.,0.5) );\n\td= smin(d,box(p, vec3(0.1,8.4,.1)));\n\n    return d*1.1;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.xz -= time*7.;\n    p.y -= time*.5;\n    return (max(Noise3d(p*.008+.1)-.1,0.0)*Noise3d(p*.1))*.3;\n}\n\nfloat march(in vec3 ro, in vec3 rd, out float drift, in vec2 scUV)\n{\n\tfloat precis = 0.0001;\n    float h=precis*2.0;\n    float d = hash12(scUV);\n    drift = 0.0;\n    for( int i=0; i<ITR; i++ )\n    {\n        vec3 p = ro+rd*d;\n        if(h < precis || d > FAR) break;\n        h = map(p);\n        drift +=  fogmap(p, d);\n        d += min(h*.65 + d * .002, 8.0);\n\t }\n    drift = min(drift*0.5, 1.0);\n\treturn d;\n}\n\nvec3 normal( in vec3 pos, in float d )\n{\n\tvec2 eps = vec2( d *d* .003+.01, 0.0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat bnoise(in vec3 p)\n{\n    p.xz*=.4;\n    float n = Noise3d(p*3.)*0.8;\n    n += Noise3d(p*1.5)*0.2;\n    return n*n*.2;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    p.xz *= .4;\n    //p *= 1.0;\n    vec2 e = vec2(.01,0.);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*10./(ds));\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint)\n{\n\tfloat res = 1.0;\n    \n    float t = mint;\n    for( int i=0; i<12; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.1, 1.5 );\n    }\n    return clamp( res, 0., 1.0 );\n}\n\nvec3 Clouds(vec3 sky, vec3 rd)\n{\n    \n    rd.y = max(rd.y, 0.0);\n    float ele = rd.y;\n    float v = (200.0)/rd.y;\n\n    rd.y = v;\n    rd.xz = rd.xz * v - time*8.0;\n\trd.xz *= .00004;\n    \n\tfloat f = Noise3d(rd.xzz*3.) * Noise3d(rd.zxx*1.3)*2.5;\n    f = f*pow(ele, .5)*2.;\n  \tf = clamp(f-.15, 0.01, 1.0);\n\n    return  mix(sky, vec3(1),f );\n}\n\n\nvec3 Sky(vec3 rd, vec3 ligt)\n{\n    rd.y = max(rd.y, 0.0);    \n    vec3 sky = mix(vec3(.1, .15, .25), vec3(.8), pow(.8-rd.y, 3.0));\n    return  mix(sky, SUN_COLOUR, min(pow(max(dot(rd,ligt), 0.0), 4.5)*1.2, 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t\n\tfloat fg;\n\t\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-1.9,0.07):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(0.+smoothstep(0.,1.,tri(time*1.5)*.3)*1.1, smoothstep(0.,1.,tri(time*3.)*3.)*0.00, -time*3.5-130.0);\n    ro.y -= camHeight(ro.zx)-.5;\n    \n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-.05,0.));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\n    vec3 ligt = normalize( vec3(-1.5 +(iTime*10.0), (iTime/10.0), -.5) );\n    float rz = march(ro,rd, fg, gl_FragCoord.xy);\n\tvec3 sky = Sky(rd, ligt);\n    \n    vec3 col = sky;\n   \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos, rz);\n        float d = distance(pos,ro);\n        nor = bump(pos,nor,d);\n        float shd = (shadow(pos,ligt,.01));\n        \n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 );\n        vec3 ref = reflect(rd,nor);\n        float spe = pow(clamp( dot( ref, ligt ), 0.0, 1.0 ),5.)*2.;\n        col = vec3(.1);\n\t    col = col*dif*shd + spe*shd*SUN_COLOUR +abs(nor.y)*vec3(.1, .1, .2);\n        col = mix(col, sky, smoothstep(FAR-25.,FAR,rz));\n    }\n    else\n    {\n        col = Clouds(col, rd);\n    }\n\n    // Fog mix...\n    col = mix(col, vec3(0.96, .8, .66), fg);\n  \n    // Post...\n\tcol = min(pow(col*1.,vec3(0.7)), 1.0);\n\tcol = smoothstep(0., 1., col);\n    \n    // Borders...\n    float f = smoothstep(0.0, 3.0, iTime)*.5;\n    col *= f+f*pow(70. *q.x*q.y*(1.0-q.x)*(1.0-q.y), .2);\n\t    \n\tfragColor = vec4( col, 1.0 );\n}\n ","name":"Image","description":"","type":"image"}]}