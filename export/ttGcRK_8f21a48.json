{"ver":"0.1","info":{"id":"ttGcRK","date":"1611316579","viewed":203,"name":"[TWITCH] Constructivist dream","username":"Flopine","description":"Shader inspired by constructivism art movement and made during a Twitch stream, you can watch all of them here: https://www.twitch.tv/flopine","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","abstract","constructivism","live","geometric","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define mo(p,d)p=abs(p)-d;if(p.y>p.x)p=p.yx\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p=(p-c*clamp(round(p/c),-l,l))\n#define hash11(x) fract(sin(x)*146.4)\n\n#define dt(speed) fract(iTime*speed)\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n  float per = (2.*PI)/rep;\n  float a = mod(atan(p.y,p.x),per)-per*0.5;\n  p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat torus (vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz),p.y)-t.x;\n  return length(q)-t.y;\n}\n\nfloat buildings (vec3 p)\n{\n  vec3 pp = p;\n\n  mo(p.xz, vec2(10.));\n  float g = cyl(p.xzy,0.5,50.);\n  p.x -= 5.;\n  float d = min(g,box(p,vec3(5.,50.,6.5)));\n\n  p = pp;\n  p.z -= 3.5;\n  p.x = abs(p.x)-15.;\n  crep(p.x, 1.,4.);\n  d = max(d,-cyl(p.xzy,0.3,45.));\n\n  return d;\n}\n\nfloat staircase (vec3 p)\n{\n  p.xz *= rot(PI/4.);\n  float width = 3.;\n  vec3 pp = p;\n  float d = cyl(p.xzy, 0.1, 50.);\n\n  float per = 10.;\n  p.xz *= rot(PI/5.);\n  crep(p.y,per,3.);\n  moda(p.xz,5.);\n  p.x -= width;\n  d = min(d,box(p,vec3(0.25,0.25,5.)));\n\n  p =pp;\n  moda(p.xz,5.);\n  p.x -= width*0.95;\n  d = min(d,cyl(p.xzy,0.1,50.));\n\n  p = pp;\n  float sper = 1.;\n  float sid = round(p.y/sper);\n  crep(p.y,sper, 50.);\n\n  p.xz *= rot(sid*0.3); \n  p.x -= width*0.5;\n  d = min(d,box(p,vec3(width*0.6,0.15,1.)));\n\n  return d;\n}\n\nfloat staircases (vec3 p)\n{\n  p.xz *= rot(PI/4.);\n  moda(p.xz, 4.);\n  p.x -= 20.;\n  return staircase(p);\n}\n\nfloat balcony (vec3 p)\n{\n  mo(p.xz, vec2(10.));\n  float per = 8.;\n  crep(p.y,per,6.);\n  p.xz *= rot(PI/4.);\n  float d = box(p,vec3(4.,1.5,4.));\n\n  crep(p.y,per,6.);\n  p.x += 2.;\n  d = max(d,-box(p,vec3(4.,0.2,4.)));\n\n  return d;\n}\n\nfloat g1 = 0.; float gid;\nfloat gems (vec3 p)\n{\n  p.y -= 4.;\n  mo(p.xz,vec2(10.));\n  p.z += 4.;\n  gid = round(p.y/8.);\n  crep(p.y, 8.,6.);\n  float d = dot(p,normalize(sign(p)))-0.4;\n\n  g1 += 0.01/(0.01+d*d);\n\n  return d;\n}\n\nfloat SDF (vec3 p)\n{\n  float scene = stmin(balcony(p),buildings(p),0.4,2.);\n  scene = min(scene,staircases(p));\n  scene = min(scene,gems(p));\n\n  return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.001,0.);\n  return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 getcam (vec3 ro, vec3 ta, vec2 uv)\n{\n  vec3 f = normalize(ta-ro);\n  vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n  vec3 u = normalize(cross(f,l));\n  return normalize(f+l*uv.x+u*uv.y);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n\n  vec3 ro=vec3(1.2,-6.5,-7.), rd=getcam(ro,vec3(0.),uv), p=ro, col=vec3(0.), l=normalize(vec3(1.,2.,-3.));\n\n  bool hit=false; \n\n  for(float i=0.;i<64.;i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      break;\n    }\n    p += d*rd*0.8;\n  }\n  float t = length(ro-p);\n\n  if (hit)\n  {\n    vec3 n = getnorm(p);\n    col = vec3(dot(n,l)*0.5+0.25);\n  }\n \n  col = mix(col,\n          vec3(0.1,0.4,0.9),\n          1.-exp(-0.0003*t*t)+texNoise(uv*0.45).x*length((p.y+3.)*0.2));\n  col += g1*hash11(gid+dt(0.03))*0.35;\n  col = pow(col,vec3(2.));\n\n  fragColor = vec4(sqrt(clamp(col,0.,1.)),1.);\n}","name":"Image","description":"","type":"image"}]}