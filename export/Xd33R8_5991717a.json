{"ver":"0.1","info":{"id":"Xd33R8","date":"1447914172","viewed":153,"name":"Hot Chocolate","username":"sixstring982","description":"A whimsical journey down the chocolate river","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chocolate","hot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_RAY_DIST 17.5\n#define FOG_START 0.0\n#define MARCH_ITERS 100\n#define MARCH_EPSILON 0.7\n#define SPECULAR_POW 32.0\n#define AUTOSPIN_SPEED 0.2\n#define CAMERA_DIST 3.0\n\nconst vec3 BG_COLOR = vec3(0.2, 0.1, 0.0);\n\n// ===================== DISTANCE MAP ==================\n\nfloat rdBox(in vec3 pos, in vec3 dims, in float r) {\n  return length(max(abs(pos) - dims, 0.0)) - r;\n}\n\nfloat twistRdBox(in vec3 pos, in vec3 dims, in float r) {\n    float c = cos(pos.y * 0.5 * sin(iTime));\n    float s = sin(pos.y * 0.5 * cos(iTime));\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xz,pos.y);\n    return rdBox(q, dims, r);\n}\n\nfloat repTwistRdBox(in vec3 pos, in vec3 reps, in vec3 dims, in float r) {\n    vec3 q = mod(pos, reps) - 0.5 * reps;\n    return twistRdBox(q, dims, r);\n}\n\nfloat sphere(in vec3 pos, in float r) {\n    return length(pos) - r;\n}\n\nfloat map(in vec3 pos) {\n    return repTwistRdBox(pos + vec3(5.0 * cos(iTime * 0.025), \n                                    5.0 * sin(iTime * 0.05), \n                                    5.0 * cos(iTime * 0.05)),\n                         vec3(2.0 * sin(iTime * 0.05) + 12.5,\n                              2.0 * cos(iTime * 0.05) + 12.5,\n                              2.0 * sin(cos(iTime * 0.05)) + 12.5), \n                         vec3(0.2 * sin(iTime * 0.05) + 1.0,\n                              0.2 * cos(iTime * 0.05) + 1.0,\n                              0.2 * sin(cos(iTime * 0.05)) + 1.0), \n                         0.1);\n}\n\n// ===================== LIGHTING =======================\n\nvec3 normalAt(in vec3 ro) {\n    const vec2 EV = vec2(MARCH_EPSILON, 0.0);\n    return normalize(vec3(map(ro + EV.xyy) - map(ro - EV.xyy),\n                          map(ro + EV.yxy) - map(ro - EV.yxy),\n                          map(ro + EV.yyx) - map(ro - EV.yyx)));\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd, in float dist) {\n    vec3 n = normalAt(ro);\n    float diffuse = max(0.0, dot(n, -rd));\n    float specular = min(1.0, pow(diffuse, SPECULAR_POW));\n    vec3 base = vec3(diffuse + specular);\n    vec3 cmap = texture(iChannel0, n).xyz;\n    base = mix(base, cmap, 0.25);\n    if (dist < FOG_START) {\n        return base;\n    } else {\n        return mix(base,\n                   BG_COLOR,\n                   pow((dist - FOG_START) / (MAX_RAY_DIST - FOG_START), 0.5));\n    }\n    return vec3(diffuse + specular);\n}\n\n\n// ===================== RAY MARCHING ===================\n\nvec3 march(in vec3 ro, in vec3 rd) {\n    float dist = 1e20;\n    float totalDist = 0.0;\n    for (int i = 0; i < MARCH_ITERS; i++) {\n        if (totalDist > MAX_RAY_DIST ||\n            dist < MARCH_EPSILON) {\n            break;\n        }\n        \n        dist = map(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (dist < MARCH_EPSILON) {\n        return lighting(ro, rd, totalDist);\n    } else {\n        return BG_COLOR;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cop = vec3(iTime, 0.0, 0.0);\n    vec3 target = cop + vec3(CAMERA_DIST * sin(iTime * AUTOSPIN_SPEED), \n                    0.0,\n                    CAMERA_DIST * cos(iTime * AUTOSPIN_SPEED));\n    vec3 up = normalize(vec3(sin(iTime * 0.2), \n                             cos(iTime * 0.2), \n                             sin(iTime * 0.2)));\n    \n    vec3 cameraDir = normalize(target - cop);\n    vec3 cameraRight = normalize(cross(cameraDir, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraDir));\n    \n    vec3 rayDir = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraDir);\n    \n    \n    \n    fragColor = vec4(march(cop, rayDir), 1.0);\n}","name":"","description":"","type":"image"}]}