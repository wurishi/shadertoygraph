{"ver":"0.1","info":{"id":"tlX3D7","date":"1556510896","viewed":172,"name":"Orthogonal Polynomials","username":"tpfto","description":"Plots a set of orthogonal polynomials. Legendre polynomials and Chebyshev polynomials are currently implemented, but I might add others later if there is popular demand.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","plot","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// plot first few orthogonal polynomials (https://en.wikipedia.org/wiki/Orthogonal_polynomial)\n// currently, only Legendre polynomials P_n(x) (https://en.wikipedia.org/wiki/Legendre_polynomials)\n// and Chebyshev polynomials T_n(x)/U_n(x) (https://en.wikipedia.org/wiki/Chebyshev_polynomials) are implemented\n\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// Solarized \"accent colors\"\n#define YELLOW vec3(0.71, 0.537, 0.0)\n#define ORANGE vec3(0.796, 0.294, 0.086)\n#define RED vec3(0.863, 0.196, 0.184)\n#define MAGENTA vec3(0.827, 0.212, 0.51)\n#define VIOLET vec3(0.424, 0.443, 0.769)\n#define BLUE vec3(0.149, 0.545, 0.824)\n#define CYAN vec3(0.165, 0.631, 0.596)\n#define GREEN vec3(0.522, 0.6, 0.0)\n\n// uncomment to switch to dark mode\n// #define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 2.25\n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.01 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 4.0\n\n// maximum supported polynomial order\n#define MAX_POLYNOMIAL_ORDER 9\n\n// Kronecker delta\n#define kd(n, k) ((n == k) ? 1.0 : 0.0)\n\n// Clenshaw's algorithm for a Chebyshev series; https://doi.org/10.1090/S0025-5718-1955-0071856-0\nfloat clenshaw_cheb(int n, float x)\n{\n\tfloat kind = 1.0; // 1 - first kind, 2 - second kind\n    float u = 0.0, v = 0.0, w = 0.0;\n    \n    for (int k = MAX_POLYNOMIAL_ORDER; k > 0; k--)\n    {\n        w = v;\n        v = u;\n        u = kd(n, k) + 2.0 * x * v - w;\n    }\n    \n    return kd(n, 0) + kind * x * u - v;\n}\n\n// Clenshaw's algorithm for a Legendre series\nfloat clenshaw_leg(int n, float x)\n{\n\tfloat u = 0.0, v = 0.0, w = 0.0, kk = 0.0;\n    \n    for (int k = MAX_POLYNOMIAL_ORDER; k > 0; k--)\n    {\n        kk = float(k);\n        w = v;\n        v = u;\n        u = kd(n, k) + ((2.0 * kk + 1.0) * x * v)/(kk + 1.0) - ((kk + 1.0) * w)/(kk + 2.0);\n    }\n    \n    return kd(n, 0) + x * u - 0.5 * v;\n}\n\nfloat Chebyshev(int n, vec2 p)\n{\n\treturn p.y - clenshaw_cheb(n, p.x);\n}\n\nfloat Legendre(int n, vec2 p)\n{\n\treturn p.y - clenshaw_leg(n, p.x);\n}\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// central difference\n#define GRAD_CHEB(n, p) (0.5 * vec2(Chebyshev(n, p - GRADH.xy) - Chebyshev(n, p + GRADH.xy), Chebyshev(n, p - GRADH.yx) - Chebyshev(n, p + GRADH.yx)) / GRADH.xx)\n\n// PLOT_Chebyshev(Order, Color, Destination, Screen Position)\n#define PLOT_Chebyshev(n, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(Chebyshev(n, p) / length(GRAD_CHEB(n, p)))))\n\n// central difference\n#define GRAD_LEG(n, p) (0.5 * vec2(Legendre(n, p - GRADH.xy) - Legendre(n, p + GRADH.xy), Legendre(n, p - GRADH.yx) - Legendre(n, p + GRADH.yx)) / GRADH.xx)\n\n// PLOT_Legendre(Order, Color, Destination, Screen Position)\n#define PLOT_Legendre(n, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(Legendre(n, p) / length(GRAD_LEG(n, p)))))\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - abs(c), 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0, tick = 1.0, axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad - 0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\tuv *= DISP_SCALE;\n\t\n    vec3 col = WHITE;\n    \n    // set up axes and ticks\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, grid(uv, true, true, false));\n    #else\n    col = mix(GRAY, LIGHT, grid(uv, true, true, false));\n    #endif\n    \n    // switch every 120 frames\n    if (step(121.0, mod(float(iFrame), 241.0)) == 0.0) {\n    PLOT_Chebyshev(1, YELLOW, col, uv);\n    PLOT_Chebyshev(2, BLUE, col, uv);\n    PLOT_Chebyshev(3, GREEN, col, uv);\n    PLOT_Chebyshev(4, RED, col, uv);\n    PLOT_Chebyshev(5, VIOLET, col, uv);\n    // PLOT_Chebyshev(6, MAGENTA, col, uv);\n    // PLOT_Chebyshev(7, CYAN, col, uv);\n    // PLOT_Chebyshev(8, ORANGE, col, uv);\n    } else {\n    PLOT_Legendre(1, YELLOW, col, uv);\n    PLOT_Legendre(2, BLUE, col, uv);\n    PLOT_Legendre(3, GREEN, col, uv);\n    PLOT_Legendre(4, RED, col, uv);\n    PLOT_Legendre(5, VIOLET, col, uv);\n    // PLOT_Legendre(6, MAGENTA, col, uv);\n    // PLOT_Legendre(7, CYAN, col, uv);\n    // PLOT_Legendre(8, ORANGE, col, uv);\n    }\n    \n    // clip plot\n    #ifdef DARK_MODE\n    col = mix(LIGHT, col, 1.0 - step(0.5 * DISP_SCALE, abs(uv.x)));\n    #else\n    col = mix(DARK, col, 1.0 - step(0.5 * DISP_SCALE, abs(uv.x)));\n    #endif\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}