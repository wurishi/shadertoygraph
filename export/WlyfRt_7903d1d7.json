{"ver":"0.1","info":{"id":"WlyfRt","date":"1614845506","viewed":197,"name":"Charge Interaction","username":"Quazi","description":"\"charges\" communicating attraction/repulsion long range through a wave field. Probably can find better settings with less clamping, but can't have particles form mach cones... they also self propel annoyingly at high speed which I couldn't fix yet.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"WtyfRt","parentname":"Fork reint part Quazi 436"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 U, in vec2 pos )\n{\n    U = vec4(0,0,0,0);\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    vec4 data = texel(ch0, vec2(p));\n    particle P = getParticle(data, pos);\n    U.r = P.M.y*P.M.x;\n    U.b = P.M.x;\n    U.g = -P.M.y*P.M.x;\n    \n    //gradient of wave\n    vec2 E = vec2(\n        (texel(ch1, pos+vec2(1,0)).r-texel(ch1, pos+vec2(-1, 0)).r)/2.0,\n        (texel(ch1, pos+vec2(0,1)).r-texel(ch1, pos+vec2( 0,-1)).r)/2.0\n    );\n    \n    vec4 data2 = texel(ch1, vec2(p));\n    U = vec4(0,0,0,0);\n    U.r = max(0.0,data2.r);\n    U.b = max(0.0,-data2.r);\n    if(P.M.x>=1e-5){\n        if(abs(P.M.y)<=1e-5){\n            U.rgb = vec3(0,0,0);\n        }else{\n            U.g = 1.0;\n        }\n    }\n    vec4 data3 = texel(ch2, vec2(p));\n    U += data3*100.0;\n    \n    //blur for coolness\n    range(i, -4, 4) range(j, -4, 4)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch0, tpos);\n        particle P0 = getParticle(data, tpos);\n        \n        vec2 p_delta = (P0.X-pos);\n        const float star_power = 0.35;\n        vec2 star = pow(abs(p_delta),vec2(1.,1.)*star_power);\n        float star_limit = 8.0;\n        float star_glow = pow(star.x+star.y,1./star_power);\n        if(P0.M.x>=1.e-5 && star_glow<star_limit){\n            float glowfac =max(1.0-star_glow/star_limit,0.0)*1.0;\n            U.r += glowfac;\n            U.b += glowfac;\n            U.g += glowfac*0.5;\n        }\n        \n    }\n    \n    //U.g = (E.x)*20.0;\n    //U.b = (E.y)*20.0;\n    \n    //U.g = floor(P.M.x/2.0);\n    //U.b = floor(P.M.x/3.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;\n    Reintegration(ch0, P, pos);\n\n    if(iFrame < 1)\n    {\n        if(true)\n        {\n            //random\n            vec3 rand = hash32(pos + vec2(0., 1.0)+0.28);\n            if(rand.z < 0.00001) \n            {\n                P.X = pos + 0.3*(rand.yz-0.5);\n                //P.V = 0.65*(rand.xy-0.5) + vec2(0., 0.);\n                //P.X = pos;\n                P.V = vec2(0.0,0.0);\n                P.M = vec2(mass, int(rand.y>0.5)*2-1);\n            }\n            else\n            {\n                P.X = pos;\n                P.V = vec2(0.);\n                P.M = vec2(1e-6);\n            }\n        }else{\n            //two\n            vec3 rand = hash32(pos + vec2(0., 1.0)+0.28);\n            if (p.x==300 && p.y==300)\n            {\n                P.X = pos;\n                //P.V = 0.65*(rand.xy-0.5) + vec2(0., 0.);\n                P.V = vec2(0.0, 0.);\n                P.M = vec2(mass, 1);\n            }\n            else if (p.x==int(R.x)-300 && p.y==200)\n            {\n                P.X = pos;\n                //P.V = 0.65*(rand.xy-0.5) + vec2(0., 0.);\n                P.V = vec2(-0.0, 0.);\n                P.M = vec2(mass, -1);\n            }\n            else\n            {\n                P.X = pos;\n                P.V = vec2(0.);\n                P.M = vec2(1e-6);\n            }\n            \n        \n        }\n    }\n    \n    U = saveParticle(P, pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, Bf(p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n\n//diffusion diameter\n// 0 - completely particle like\n// >1.0 - field-like\n#define dif 0.01\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#define mass 1.\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpackSnorm2x16(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = packSnorm2x16(clamp(x, vec2(-1.), vec2(1.)));\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n\nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        //float difR = dif;\n        //vec3 D = distribution(P0.X, pos, difR);\n        ////the deposited mass into this cell\n        //float m = P0.M.x*D.z;\n        ////add weighted by mass\n        //P.X += D.xy*m;\n        //P.V += P0.V*m;\n        //P.M.y += P0.M.y*m;\n        \n        ////add mass\n        //P.M.x += m;\n        \n        vec2 delta = P0.X - pos;\n        if((delta.x>=-0.5)&&(delta.x<0.5)&&(delta.y>=-0.5)&&(delta.y<0.5)){\n            P.X += P0.X*P0.M.x;\n            P.V += P0.V*P0.M.x;\n            P.M.y += P0.M.y*P0.M.x;\n            P.M.x += P0.M.x;\n        }\n\n    }\n    \n    //normalization\n    if(P.M.x >= 0.1)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }else{\n        P.M.x = 0.0;\n    }\n    //annhiliate\n    if(abs(P.M.y)<1e-3){\n        P.M.x = 0.0;\n        //P.M.y = 0.0;\n    }\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, sampler2D ch_wave, inout particle P, vec2 pos)\n{\n    //vec4 bg = vec4(1,1,1,1);\n    //float ramp_width = 4.0;\n    //vec2 b = R*0.5-vec2(ramp_width,ramp_width);\n    //vec2 q = abs((pos-R*0.5)) - b;\n    //float sd =length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    //bg.b=clamp(1.0-sd/ramp_width,0.0,1.0);\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n\n    //viscosity\n    F += 0.0;\n\n    //if(Mouse.z > 0.)\n    //{\n    //    vec2 dm =( P.X-Mouse.xy)/10.; \n    //    float d = distance(Mouse.xy, P.X)/60.;\n    //    F += -0.5*dm*exp(-d*d)*P.M.x;\n    //   // P.M.y += 0.1*exp(-40.*d*d);\n    //}\n    \n    //get gradient of \"potential\" at position (sort of)\n    vec2 PsX = (P.X+P.V*dt);\n    //PsX = P.X;\n    vec2 Ef = vec2(\n        (texel(ch_wave, PsX+vec2(1,0)).r-texel(ch_wave, PsX+vec2(-1, 0)).r)/2.0,\n        (texel(ch_wave, PsX+vec2(0,1)).r-texel(ch_wave, PsX+vec2( 0,-1)).r)/2.0\n    );\n    //Ef.x = 1.;\n    F -= Ef*P.M.y*0.3*P.M.x;\n    \n    //integrate\n    //P.V += clamp((clamp((pos-R*0.5),-b,b)+R*0.5-pos),-1.0,1.0);\n    P.V += F*dt/P.M.x-P.V*0.0;\n    //border \n    //vec3 N = bN(P.X);\n    //float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    //P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    //P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    //if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    float v_limit = 0.35;\n    P.V /= (v > v_limit)?(v/v_limit):1.0; //dont want mach cones.. (FTL)\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 U, in vec2 pos )\n{    \n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    \n    //define absorbing boundary to minimize echoes using rounded rect from sdf?\n    //vec4 bg = vec4(1,1,1,1);\n    //float ramp_width = 4.0;\n    //vec2 b = R*0.5-vec2(ramp_width,ramp_width);\n    //vec2 q = abs((pos-R*0.5)) - b;\n    //float sd =length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    //bg.b=clamp(1.0-sd/ramp_width,0.0,1.0);\n    //it gets attracted to the wall if absorbing!\n    \n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    vec4 wave_data = texel(ch1, pos);\n    float v = wave_data.r-wave_data.g;\n    vec4 L = -4.0*wave_data;\n    L += texel(ch1, pos+vec2( 1, 0));\n    L += texel(ch1, pos+vec2(-1, 0));;\n    L += texel(ch1, pos+vec2( 0, 1));;\n    L += texel(ch1, pos+vec2( 0,-1));;   \n    col.r = wave_data.r+v*0.995+0.25*L.r; //max wave speed is 0.5 cell per step (0.5^2 in wave eq)\n    col.g = wave_data.r;//store prev state\n    \n    if(false){\n        //test source mode\n        vec2 m_p = pos-R*0.25;\n        if(length(m_p) < 1.0){\n            col.r = 1.0;\n        }\n    }else{\n        if(true){\n            vec4 data = texel(ch0, vec2(p));\n            particle P = getParticle(data, pos);\n            //col.r = max(P.M.y*P.M.x,col.r);\n            col.r = mix(col.r,P.M.y*P.M.x,P.M.x*abs(P.M.y)>1e-3);\n            //col.r = mix(col.r,P.M.y*P.M.x,float(P.M.x>1e-5)*P.M.x);\n            //col.r += P.M.y*P.M.x;\n        }else{\n            vec4 accum = vec4(0,0,0,0);\n            float w_tot = 0.0;\n            range(i, -1, 1) range(j, -1, 1)\n            {\n                vec2 tpos = pos + vec2(i,j);\n                vec4 data = texel(ch0, tpos);\n                particle P0 = getParticle(data, tpos);\n                float r = length((P0.X+P0.V*dt)-pos);\n                float w = exp(-(r*r));\n                accum.r += P0.M.y*P0.M.x*w;\n                w_tot += w;\n            }\n            float constraint = accum.r/w_tot;\n            col.r = max(col.r,constraint);\n        }        \n    }\n    //if(bg.b<1.0){\n    //    col.r = 0.0;\n    //}\n    \n    U = col;\n    //U = vec4(pos.x/1000.0,0.0,0.0,0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, ch1, P, pos);\n    }\n    //length(pos-Mouse.xy) < 3. \n    if((int(pos.y)==int(Mouse.y)) && abs(pos.x-Mouse.x)>5.0 && abs(pos.x-Mouse.x)<6.1  && true && Mouse.z>0. && iFrame%10==0) \n    {\n        P.X = pos;\n        P.V = vec2((-1+2*(int(pos.x)%2))*-1,-1+2*(int(pos.x)%2));\n        P.M = vec2(1,-1+2*(int(pos.x)%2));\n    }\n    //if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    //{\n    //    P.X = pos;\n    //    P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n    //    P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    //}\n    \n    U = saveParticle(P, pos);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    vec4 data = texel(ch0, vec2(p));\n    particle P = getParticle(data, pos);\n    \n    U = vec4(0,0,0,0);\n    if(P.M.x>=1e-5){\n        if(abs(P.M.y)<=1e-5){\n            //U.rgb = vec3(0,0,0);\n        }else{\n            U.r = max(0.0,P.M.y);\n            U.b = max(0.0,-P.M.y);\n            U.g = 0.25;\n        }\n    }\n    \n    U = clamp(mix(texel(ch1, vec2(p)),U,0.01),0.,1.);\n    \n    \n    \n    //U.g = (E.x)*20.0;\n    //U.b = (E.y)*20.0;\n    \n    //U.g = floor(P.M.x/2.0);\n    //U.b = floor(P.M.x/3.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}