{"ver":"0.1","info":{"id":"ftsSRn","date":"1631419171","viewed":677,"name":"Quadtree DDA","username":"spalmer","description":"Fork of cool LOD voxel raymarching toy without cubemap\nMouse drag to define ray\nHold space to draw walls and shift to erase them\n\n","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","voxel","lod","dda","quadtree"],"hasliked":0,"parentid":"fljGDm","parentname":"2d voxel raymarching w/ LODs"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of 2d voxel raymarching w/ LODs by asherville https://shadertoy.com/view/fljGDm\n\n// had to redo avoiding Cubemap A just to keep the toy \n// simple enough for me to understand.. also reformat  ;)\n// I always wanted to do tree DDA but never got around to it\n\n// extract, decode highest resolution data for this pixel\nvoid sampleStorage(vec2 p, out float lod, out bool inShape)\n{\n    vec4 t = T(p, 0);\n    inShape = t.x > .5;\n    lod = t.y;\n}\n\nbool inBounds(vec2 p)\n{\n    return all(greaterThanEqual(p,vec2(0)))\n        && all(lessThan(p,vRes));\n}\n\n// fixed issue where raymarching breaks if ray pointing straight down\n// yeah, intrinsic sign seems to often return zero for zero\nfloat sign11(float x)\n{\n    return x<0. ? -1. : 1.;\n}\n\n// at least the points coloration is refactored out and only sqrt once\nvec2 trace(vec2 ro, vec2 rd, vec2 coord, out float pointd)\n{\n    vec2 p = ro\n    , s = vec2(sign11(rd.x), sign11(rd.y))\n    , s01 = max(s, 0.) // for hacking mod(p, voxelSize) when rd positive somehow\n    , ird = 1. / rd;\n    pointd = 9e9;\n    for (int i = 0; i < steps; ++i) {\n        // sample largest empty LOD and whether inside solid voxel\n        bool inside; // TODO should be communicated back to caller?\n        float lod; // if lod is zero, doesn't that mean it's inside? do we really need two data?\n        sampleStorage(p, lod, inside);\n\n        // hit something / went out of bounds?\n        if (inside || !inBounds(p)) break;\n\n        // size of the current voxel\n        float voxelSize = exp2(lod);\n\n        // intersect the xy lines\n        vec2 tMax = ird * (voxelSize * s01 - mod(p, voxelSize));\n\n        // step by the shorter distance\n        p += min(tMax.x, tMax.y) * rd;\n\n        // draw points (only for debugging)\n        vec2 v = p - coord;\n        pointd = min(pointd, dot(v, v)); // sqrt at end of loop only for closest\n\n        // which line is intersected?  this won't work in 3d, would need done differently\n        vec2 mask = step(tMax.xy, tMax.yx);\n\n        // HACK move past line a teeny bit into next voxel\n        // if you get this too small, it can get stuck sometimes in fullscreen\n        // on the right edge of the screen going leftward, but if you get it \n        // too big, it loses accuracy\n        p += 4e-4 * s * mask;\n    }\n    pointd = sqrt(pointd);\n    return p; // final position\n}\n\n// segment from iq\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\n// incorrect sdf but it works b/c doesn't matter which side the edge is actually on\nfloat sdGrid(vec2 coords, float gridSize, float gridWidth)\n{\n    vec2 grid = abs(mod(coords,gridSize) - gridSize*.5);\n    \n    return min(grid.x,grid.y) - gridWidth;\n}\n\n// he was too tired to figure out perfect antialiasing,\n// just multiplied random things together until it looked ok.\n// over-complex, and I dislike using smoothstep,\n// although it turns out its built-in clamping is convenient.\nvoid drawSDF(inout vec3 col, vec3 pcol, float d, float r)\n{\n    float psize = 1.0/iResolution.y;\n\n    d = (d - r/zoom*psize*vRes.y) * zoom;\n\n    col = mix(pcol, col, smoothstep(-psize,psize,d));\n}\n\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    vec2 p = fc; //viewportToStorage(fc);\n    vec2 m = iMouse.xy; //viewportToStorage(iMouse.xy);\n\n    // coord is outside of the data, return black (never happens)\n    //if (!inBounds(p)) { fragColor = vec4(0); return; }\n\n    float lod;\n    bool inside;\n    sampleStorage(p, lod, inside);\n\n    vec3 c = vec3(lod+1.)/float(lods) + 1./float(lods);\n\n    if (inside) c = vec3(0,.6,.6);\n\n    vec2 pos = abs(iMouse.zw);\n    if (distance(pos,m) < .5) pos = rayOrigin;\n    if (dot(m,m) < 1.5) //&& abs(iTimeDelta-1./60.) < 1e-3)\n        m = (sin(vec2(0,3.14159/2.)+iTime*.1)*.5+.5)*vRes; // thumbnail auto spin\n    // ray direction\n    vec2 d = normalize(m - pos);\n\n   #if SHOW_GRID    \n    if (!inside) {\n        float lodSize = exp2(lod);\n        float grid = sdGrid(p+lodSize*.5, lodSize, 0.);\n        drawSDF(c, .6*c, grid, .5);\n    }\n   #endif\n    \n    float pointd;\n    vec2 tr = trace(pos, d, p, pointd);\n    float s2 = sdSegment(p, pos, tr);\n    drawSDF(c, vec3(.9,.7,.5), s2, 1.);\n    float blink = sin(17.*iTime)*.05 + .95;\n    drawSDF(c, vec3(.9, .1, 0) * blink, pointd, 3.);\n\n    //if (iFrame < lods-1) c = vec3(0,0,1); // hide initial mip building (careful w thumbnail at frame 10 or so!)\n    o = vec4(c,1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// settings\n\n#define Buffer iChannel1\n#define vRes iChannelResolution[1].xy\n\n// max number of raymarching steps\n#define steps 50\n\n// show (or hide) the grid\n#define SHOW_GRID 1\n\n// number of lods - biggest grid winds up being 2^(lods-1) pixels across\n#define lods 10\n\n// zoom, 1.0 is fully zoomed out, try exp2(-float(z)) for thicker lines\n// but bigger numbers don't really work anymore, if they ever did\n#define zoom 1.0\n\n// where ray starts if mouse not pressed\n#define rayOrigin (vRes*.5)\n\n#define T0(U,l) textureLod(Buffer, vec2((U)/vRes), float(l))\n//#define T(U,l)  T0(floor((U)/float(1<<l)) * float(1<<l) + .5 * float(1<<l), l) // trying to emulate texelFetch array\n//#define T(U,l)  T0(floor((U)*exp2(-float(l))) * exp2(float(l)) + .5 * exp2(float(l)), l) // for starters, all these 1<<l are just exp2(l)\n#define T(U,l)  T0((floor((U)*exp2(-float(l))) + .5) * exp2(float(l)), l) // then can factor some out\n// so let me get this straight... it rounds to some point based on lod, then...\n// calls TO which then converts a buffer coordinate to a uv prior to textureLod,\n// or calls texelFetch which then simply shifts down and throws those bits away.\n// I guess this is emulating a point sample access even though the buffer is set to mipmap, which implies linear filtering on shadertoy\n// let's not do that, let's just do the fetch here the sensible way\n// FIXME has bug where when it fetches an lod that is offscreen, it breaks the tracing and grid and everything\n//#define T(U,l)  texelFetch(Buffer, ivec2(U) >> l, int(l))\n\n//#define viewportToStorage(pos) pos\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define iKbd iChannel2\n#define JunkNoise iChannel3\n\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    vec2 p = fc;\n    // last frame\n    vec4 last = T(p,0);\n    \n    // mouse position on storage\n    vec2 m = iMouse.xy; //viewportToStorage(iMouse.xy);\n    \n    bool mouseCircle = distance(m,p) < vRes.y*.125/zoom;\n    bool space = texelFetch(iKbd, ivec2(32, 0), 0).x > 0.;\n    bool shift = texelFetch(iKbd, ivec2(16, 0), 0).x > 0.;\n\n    bool mask = last.r > .5;\n\n    mask = mask || (space && mouseCircle);\n    \n    // erase\n    if (shift && mouseCircle) { mask = false; }\n    \n    if (iFrame == 0 || distance(T(vec2(0),0).zw, vRes) > .1) {  // reset when noise texture loaded and resolution changed\n        float seed = iDate.w*.1;   // initial noise\n        mask = texture(JunkNoise, p/vRes/9. + seed).g + distance(p,rayOrigin)*.0005 < .4;\n        // FIXME the noise texture is all kinds of problematic, waiting for it to be loaded, etc.\n        // just use some simple sinewave pattern!  polka dots!\n    }\n    // clear space around ray origin\n    if (distance(p, rayOrigin) < 50./zoom) mask = false; \n \n    // find the largest empty LOD for raymarching by scanning thru mips\n    // utilizes the built-in mipmapping to propagate data to mips.\n    // works since it only cares about nonzero!  Takes a few frames to propagate.\n    // I believe this breaks down for lods bigger than the number of bits per channel in the buffer somehow\n    int best = lods-1;    \n    for (int i = 0; i <= lods; ++i)     \n        if (T(p,i).x > 0.) { best = max(i-1,0); break; }\n    \n    vec4 data = vec4(mask, best, 0, 1);\n    if (length(fc-.5) < .5 && iChannelResolution[3].x > 0.)\n        data.zw = vRes;\n    \n    // Output to storage\n    o = data;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}