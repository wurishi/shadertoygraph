{"ver":"0.1","info":{"id":"M33Szs","date":"1719416812","viewed":90,"name":"colorful cellular automata","username":"Dalmador","description":"Similar to conway's game of life but with more states for each cell and modified rules.\nReset with random values by pressing r.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["simulation","automata","conway","ca","cameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 addr = fragCoord/ iResolution.xy;\n    // default shader colors\n    vec3 col = vec3(0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4)));\n    float dim = texture(iChannel0, addr).x;\n    fragColor =  vec4(col * dim, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// reset with r\n#define RESET_KEY 82\n\n// credit: https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * .1031);p *= p + 33.33;p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get information from last frame\n    float prev[9];\n    float sum = 0.;\n    for (float i = 0.; i < 9.; i++)\n    {\n        vec2 addr = uv + vec2(mod(i, 3.) - 1., floor(i / 3.) - 1.) / iResolution.xy;\n        prev[int(i)] = texture(iChannel0, addr).x;\n        sum += prev[int(i)]  == 1. && i != 4.? 1. : 0.;\n    } \n    \n    // rules to decide if a cell should get filled filled\n    bool filled = (sum == 2. && prev[4] <= 0.3) || (sum == 3. && (prev[4] > 0.9 || prev[4] == 0.) );\n    \n    // reset\n    if (texelFetch(iChannel1, ivec2(RESET_KEY, 0), 0).r > 0. || iFrame <= 1)\n    {\n        filled = rnd((uv.x*12.+uv.y)*float(iFrame+1)) <= 0.6 && length(fragCoord - iResolution.xy / 2.) < 10.;\n    }\n    \n    // fill cells that should get filled or change to next cell state\n    fragColor = vec4(filled? 1.: max(prev[4]- 1./4., 0.0));\n}","name":"Buffer A","description":"","type":"buffer"}]}