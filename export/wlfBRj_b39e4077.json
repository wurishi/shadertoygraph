{"ver":"0.1","info":{"id":"wlfBRj","date":"1597188304","viewed":63,"name":"CloudsAttempt#3000","username":"sunnyfree","description":"yep","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 RanNum(vec2 uv)\n{\n    float num = 0.;\n\n    vec3 a = fract(uv.xyx*vec3(520.152,123.432,593.21));\n    \n    a += dot(a, a+52.54); \n    \n    return fract(vec2((a.x*a.y),(a.y*a.z)));\n}\n\nvec2 RanPos(vec2 id, vec2 offset)\n{\n    vec2 pos = vec2(0.);\n    \n    float t = iTime;\n    pos = RanNum(id+offset)*iTime*0.1;\n    \n    return offset + sin(pos)*.4;\n}\n\nfloat LineMask(vec2 p, vec2 a, vec2 b)\n{\n    float mask = 0.; \n    vec2 pa = p - a; \n    vec2 ba = b - a;\n    float t = clamp(dot(pa,ba) / dot(ba,ba),0.,1.);    \n    mask = length(pa-ba*t);\n    return mask;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b )\n{\n    float d = LineMask(p, a ,b);\n    float m = smoothstep(.03,.01,d);\n    return m;\n}\n\nfloat CloudMask(vec2 uv, float multiplications)\n{\n    uv *= multiplications;\n    \n    \n    \n    //returning only the fractional component of uv.\n   \tvec2 guv = fract(uv)-0.5;\n    \n    //returning the id of the grid cell.\n    vec2 cellID = floor(uv);\n    \n    float mask = 0.;\n    \n    vec2 neighbors[9];\n    int index = 0;\n    \n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            //make a line to each neighboring cell\n            vec2 offset = vec2(x,y);\n            neighbors[index++] = RanPos(cellID,offset);\n        }\n    }\n    float d = 100.;\n    \n    for (int i = 0; i < 9; i++)\n    {\n        //get distance from each pixel to each neighbor\n        //if the distance is lower than the last one, replace it\n        float temp = distance(guv,neighbors[i]);\n        if (temp < d)\n        \td = temp;\n    }\n    return mask = 1.-d;\n    \n}\n\nfloat Layer(vec2 uv)\n{\n\tfloat t = iTime;\n    \n    uv += t*0.5;\n    \n    vec3 col = vec3(0.);\n    float ca = CloudMask(uv, 3.5);\n    float cb = CloudMask(uv, 25.213);\n    float c = mix(ca,cb,0.05);\n \t\n    ca = CloudMask(uv, 1.5);\n    c = mix(c,ca,0.7);\n    ca = CloudMask(uv, 10.);\n    c = mix(c, ca, 0.1);\n    \n    float mask = 0.;\n    mask += c;\n    col += vec3(mask)*vec3(0.5,0.5,0.5);\n    col = max(col - 0.2, 0.);\n    col = min(col * (col + 20.), 1.);\n    vec3 mask2 = vec3(c);\n    vec3 l = mix(col, mask2, 0.8); \n    l = max(l - 0.2, 0.);\n    float n = max(l.x-0.3,0.);\n    \n    return n;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    col += Layer(uv);\n    \n    float m = 0.;\n    float t = (iTime)*0.1;\n    float s = sin(t*0.5);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    for (float i = 0.; i <= 1.; i += 1./4.)\n    {\n        float z = fract(i+t);\n        float size = mix(10.,.5,z);\n        float fade = smoothstep(0.,.5,z) * smoothstep(1.,.8,z);;\n        m += Layer(uv*size+i*25.)*fade;\n    }\n    \n    col = vec3(0.5,0.6,0.7);\n    col += vec3(m);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}