{"ver":"0.1","info":{"id":"wsyGDm","date":"1570299907","viewed":303,"name":"Solitonic black hole","username":"michael0884","description":"By varying the non-linearity in space the sine-Gordon equation can have objects similar to black holes. When describing the spacial metric as seen from the point of view of the soliton, one can get something similar to the Schwarzschild metric.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//colormapping\nvoid mainImage( out vec4 color, in vec2 pos)\n{\n    vec4 field = F(pos);\n    //a weird colored energy mapping\n    color.xyz = vec3(0.7,0.3,0.1)*pow(3.*field.x,2.) + vec3(0.1,0.2,0.8)*pow(2.*field.y,2.);\n    //color.xz = vec2(1,-1)*nonlinearity(pos, size);\n    color.w = 0.f;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//the value of the field is the red channel, green is the time derivative of the value\n\nfloat LaplacianOperator(vec2 pos)\n{\n    vec4 a = F(pos);\n\tvec4 a00 = F(pos + vec2(-1,0));\n    vec4 a10 = F(pos + vec2(1,0));\n    vec4 a01 = F(pos + vec2(0,1));\n    vec4 a11 = F(pos + vec2(0,-1));\n \n\treturn (a00.x+a10.x+a01.x+a11.x-4.f*a.x)/(dx*dx);\n}\n\n\nvoid mainImage( out vec4 field, in vec2 pos)\n{\n    vec4 field_prev = F(pos);\n    float u = field_prev.x;\n    float du_dt = field_prev.y;\n    \n    //verlet integration of each point of the field \n\tfield.y = du_dt + dt*( LaplacianOperator(pos) - nonlinearity(pos, size)*sin(2.*PI*u) ); \n\tfield.x = u + dt*field.y;\n    \n    //mouse interaction\n     if(iMouse.z>0.)\n        field.x += 0.02*exp(-pow(length(iMouse.xy-pos)/20.,2.));\n    \n    //vacuum noise cancelling, also kills the particles after some time\n    {\n        float f_energy = pow(u,2.) + pow(du_dt,2.);\n        if(f_energy < noise_cancl)\n        {\n            float k = (1.-0.01*f_energy/noise_cancl);\n            field.x *= k;\n            field.y *= k;\n        }\n    }\n    \n    //initial conditions\n    if(iFrame <1) {\n        float particle_speed = 32.;\n        float particle_distance = 0.25;\n        //apply a already good intial condition to remove the spontaneous vacuum collapse to the black hole energy state\n    \tfield.x = 0.5*(0.5 + 0.5*tanh(-5.*nonlinearity(pos, size))) + \n            1.5*cos(particle_speed*pos.y/size.y)*exp(-pow(length(pos-vec2(0.5-particle_distance,0.5)*size)/12.,2.));\n        field.y = 1.2*sin(particle_speed*pos.y/size.y)*exp(-pow(length(pos-vec2(0.5-particle_distance,0.5)*size)/12.,2.));\n    }\n  \n    //unused\n    field.z = 0.f; \n \tfield.w = 1.f;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//the value of the field is the red channel, green is the time derivative of the value\n\nfloat LaplacianOperator(vec2 pos)\n{\n    vec4 a = F(pos);\n\tvec4 a00 = F(pos + vec2(-1,0));\n    vec4 a10 = F(pos + vec2(1,0));\n    vec4 a01 = F(pos + vec2(0,1));\n    vec4 a11 = F(pos + vec2(0,-1));\n \n\treturn (a00.x+a10.x+a01.x+a11.x-4.f*a.x)/(dx*dx);\n}\n\n\nvoid mainImage( out vec4 field, in vec2 pos)\n{\n    vec4 field_prev = F(pos);\n    float u = field_prev.x;\n    float du_dt = field_prev.y;\n    \n    //verlet integration of each point of the field \n\tfield.y = du_dt + dt*( LaplacianOperator(pos) - nonlinearity(pos, size)*sin(2.*PI*u) ); \n\tfield.x = u + dt*field.y;\n    \n    //mouse interaction\n     if(iMouse.z>0.)\n        field.x += 0.02*exp(-pow(length(iMouse.xy-pos)/20.,2.));\n    \n\n    //unused\n    field.z = 0.; \n \tfield.w = 1.;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//the value of the field is the red channel, green is the time derivative of the value\n\nfloat LaplacianOperator(vec2 pos)\n{\n    vec4 a = F(pos);\n\tvec4 a00 = F(pos + vec2(-1,0));\n    vec4 a10 = F(pos + vec2(1,0));\n    vec4 a01 = F(pos + vec2(0,1));\n    vec4 a11 = F(pos + vec2(0,-1));\n \n\treturn (a00.x+a10.x+a01.x+a11.x-4.f*a.x)/(dx*dx);\n}\n\n\nvoid mainImage( out vec4 field, in vec2 pos)\n{\n    vec4 field_prev = F(pos);\n    float u = field_prev.x;\n    float du_dt = field_prev.y;\n    \n    //verlet integration of each point of the field \n\tfield.y = du_dt + dt*( LaplacianOperator(pos) - nonlinearity(pos, size)*sin(2.*PI*u) ); \n\tfield.x = u + dt*field.y;\n    \n    //mouse interaction\n     if(iMouse.z>0.)\n        field.x += 0.02*exp(-pow(length(iMouse.xy-pos)/20.,2.));\n    \n\n    //unused\n    field.z = 0.; \n \tfield.w = 1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//the value of the field is the red channel, green is the time derivative of the value\n\nfloat LaplacianOperator(vec2 pos)\n{\n    vec4 a = F(pos);\n\tvec4 a00 = F(pos + vec2(-1,0));\n    vec4 a10 = F(pos + vec2(1,0));\n    vec4 a01 = F(pos + vec2(0,1));\n    vec4 a11 = F(pos + vec2(0,-1));\n \n\treturn (a00.x+a10.x+a01.x+a11.x-4.f*a.x)/(dx*dx);\n}\n\n\nvoid mainImage( out vec4 field, in vec2 pos)\n{\n    vec4 field_prev = F(pos);\n    float u = field_prev.x;\n    float du_dt = field_prev.y;\n    \n    //verlet integration of each point of the field \n\tfield.y = du_dt + dt*( LaplacianOperator(pos) - nonlinearity(pos, size)*sin(2.*PI*u) ); \n\tfield.x = u + dt*field.y;\n    \n    //mouse interaction\n     if(iMouse.z>0.)\n        field.x += 0.02*exp(-pow(length(iMouse.xy-pos)/20.,2.));\n    \n\n    //unused\n    field.z = 0.; \n \tfield.w = 1.;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define size iResolution.xy\n#define F(pos) texture(iChannel0, (pos)/size)\n\n//scales\n#define dt 0.04\n#define dx 0.1\n\n//nonlinearity\n#define K 0.9\n\n#define PI 3.14159265\n\n//vacuum noise cancelling \n#define noise_cancl 0.001\n\nfloat nonlinearity(vec2 pos, vec2 s)\n{\n   return K*(1.-8./(1.+pow(length(pos-0.5*s)*0.1,1.)));\n}","name":"Common","description":"","type":"common"}]}