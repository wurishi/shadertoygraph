{"ver":"0.1","info":{"id":"4fGXWt","date":"1715906531","viewed":60,"name":"Rotating (3D) Screen Cut","username":"nextrix","description":"shader suggestion from xaio","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cutter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iM iMouse\n#define R iResolution\n\n#define speed 17.\n#define twopi 3.14159*2.\n\n#define aspect R.x / R.y\n\nmat2 rot (float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nmat3 matrix3d(float x, float y, float z)\n{\n    float sinx = sin(x); float cosx = cos(x);\n    float siny = sin(y); float cosy = cos(y);\n    float sinz = sin(z); float cosz = cos(z);\n    return mat3(cosy * cosz, \n                -cosy * sinz,\n                siny, \n                cosx * sinz + cosz * sinx * siny, \n                cosx * cosz - sinx * siny * sinz, \n                -cosy * sinx, \n                sinx * sinz - cosx * cosz * siny, \n                cosz * sinx + sinx * siny * sinz, \n                cosx * cosy);\n}\n\nvec2 rot3D (vec2 uv, float dir) {\n\n    int _Use3DRot, _BSIV;\n    vec2 _rotcent;\n    float _Xrange, _XSpeed;\n    float _Yrange, _YSpeed;\n    float _Zrange, _ZSpeed;\n\n\n    float _XManual;// = mix(-180., 180., iM.y/R.y-0.5);\n    float _YManual = mix(0., 180., iM.x/R.x);\n    float _ZManual;\n    \n    if(iM.z <= 1.) {\n        _XManual = 0.5;\n        _YManual = 0.5;\n    }\n    \n    if (dir == 1.) {\n        _XManual = -_XManual;\n        _YManual = -_YManual;\n        _ZManual = -_ZManual;\n    }\n    \n    uv -= _rotcent;\n    float rx = radians(_Xrange * sin(iTime * _XSpeed) + (1.0 * _XManual)); \n    float ry = radians(_Yrange * sin(iTime * _YSpeed) + (1.0 * _YManual));\n    float rz = radians(_Zrange * sin(iTime * _ZSpeed) + _ZManual);\n    vec3 rotuv = vec3(uv - 0.5, 1);\n\n    vec3 rv = vec3(0, 0, 1);\n    rotuv.x *= aspect;\n    rv.x *= aspect; \t\n    rotuv *= matrix3d(+rx, +ry, 0.);\n    rv *= matrix3d(-rx, -ry, 0.);\n    rotuv.xy *= rot(rz);\n    rotuv.x /= aspect; rv.x /= aspect;\n    return (rv + rotuv * rv.z / rotuv.z).xy + 0.5 + _rotcent;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I.xy / R.xy - 0.5;\n    uv *= 2.;\n    uv+=0.5;\n    \n    vec4 Cut = vec4(0.,0.,0.,1.);\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    float CutTopY = 1.;\n    float CutBottomY = 1.;\n\n    float CutTopX  = -67.0;\n    float CutBottomX  =  67.0;\n    \n    float CutRotation  = iTime*speed;\n    float Distance = 10.;\n\n    \n    \n    Cut.xy = uv - 0.5;\n    \n    Cut.x *= aspect;\n    Cut.xy *= rot(3.1415*2. * CutRotation * 0.01);\n    Cut.x /= aspect;\n    \n    vec2 uv1 = rot3D(uv.xy, 1.);\n    uv.xy = rot3D(uv.xy, 0.);\n    \n\n    uv -= step(0., Cut.y) * (vec2(CutTopX * Distance * R.x*R.y * 0.0002, 0.0) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n    uv -= step(0.,-Cut.y) * (vec2(CutBottomX * Distance * R.x/R.y * 0.0002, 0.0) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n    \n    uv -= step(0., Cut.y) * (vec2(0.0, CutTopY * aspect * 0.02) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n    uv -= step(0., -Cut.y) * (vec2(0.0, -CutBottomY * aspect * 0.02) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n\n\n    uv1 -= step(0., Cut.y) * (vec2(CutTopX * Distance * R.x/R.y * 0.0002, 0.0) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n    uv1 -= step(0.,-Cut.y) * (vec2(CutBottomX * Distance * R.x*R.y * 0.0002, 0.0) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n    \n    uv1 -= step(0., Cut.y) * (vec2(0.0, CutTopY * aspect * 0.02) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n    uv1 -= step(0., -Cut.y) * (vec2(0.0, -CutBottomY * aspect * 0.02) * rot(-twopi * CutRotation * 0.01)) / vec2(aspect, 1.);\n\n\n    Cut.z = clamp(min((CutBottomY < 0. || CutTopY < 0. || CutTopX < 0. || CutBottomX < 0., 0., 1.), clamp((CutTopY + CutBottomY) * 5.0 + abs(Distance), 0., 1.)), 0., 1.);\n    Cut.w = min(min(max(-Cut.y - 0.02 * CutBottomY * aspect, Cut.y), max(Cut.y - 0.02 * CutTopY * aspect, -Cut.y)), abs(Cut.y) - 0.003);\n    \n    vec4 bgColor = mix(vec4(0,0,0,1), vec4(1,1,1,1), cos(8.*iTime));\n    \n    col = mix(bgColor, texture(iChannel0, uv1), step(0., -max(abs(uv1.x - 0.5), abs(uv1.y - 0.5)) + 0.5));\n    col = mix(col, texture(iChannel0, uv), step(0., -max(abs(uv.x - 0.5), abs(uv.y - 0.5)) + 0.5));\n    col = mix(bgColor, col, mix(1.0, step(0.0, Cut.w), Cut.z));\n    \n    O = col;\n}","name":"Image","description":"","type":"image"}]}