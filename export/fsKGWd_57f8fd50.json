{"ver":"0.1","info":{"id":"fsKGWd","date":"1633649074","viewed":102,"name":"2D Noise Slope Approx","username":"amally","description":"Estimating the slope (and therefore normals) of a 2D height field","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","slope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FBM_OCTAVES 4\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat dot(ivec2 a, ivec2 b) {\n    return float(a.x * b.x + a.y * b.y);\n}\n\nfloat random1( ivec2 p ) {\n    return fract(sin(dot(p,ivec2(127,311)))*43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    ivec2 floorUV = ivec2(floor(uv));\n    float ll = random1(floorUV);\n    float lr = random1(floorUV + ivec2(1,0));\n    float ul = random1(floorUV + ivec2(0,1));\n    float ur = random1(floorUV + ivec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n#define OFFSET 0.01\n#define XY_SCALE 1.\n\nvec3 normalOfFBM(vec2 uv) {\n    float px = fbm(uv + vec2(OFFSET, 0.));\n    float nx = fbm(uv - vec2(OFFSET, 0.));\n    float py = fbm(uv + vec2(0., OFFSET));\n    float ny = fbm(uv - vec2(0., OFFSET));\n    \n    float x = (px - nx) * XY_SCALE;\n    float y = (py - ny) * XY_SCALE;\n    float z = sqrt(1. - x * x - y * y);\n    \n    return vec3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(fbm(uv));\n    vec3 nor = normalOfFBM(uv);\n    nor = (nor + vec3(1.)) * 0.5;\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4(nor,1.0);\n}","name":"Image","description":"","type":"image"}]}