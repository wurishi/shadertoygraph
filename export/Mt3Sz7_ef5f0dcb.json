{"ver":"0.1","info":{"id":"Mt3Sz7","date":"1478698933","viewed":289,"name":"non-euclidean mirror ","username":"zproxy","description":"non-euclidean mirror.\n\nlets find out how does this work for  360 3D video","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noneuclidean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/4llSWf\n\n#define MIN_DIST 0.0003\n#define MAX_DIST 64.0\n#define MAX_STEPS 1024\n#define STEP_MULT 0.1\n#define NORMAL_OFFS 0.02\n\n#define DISABLE_WARP\n//#define HIDE_BOX\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n )\n{\n  return dot(p, normalize(n));\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s / 2.0;\n    return max(max(p.x,p.y),p.z);\n}\n//===================================================\n\nvec3 scale = vec3(1,1,1);\n\n//Defines the volume in which rays will speed up/slow down.\nfloat Warp(vec3 p)\n{\n    return sdBox(p + vec3(0,0,0.5), vec3(3.0,2.5,0.75));\n}\n\nfloat Scene(vec3 p)\n{\n    float d = 1000.0;\n    \n    p *= scale;\n    \n    // how to move floor?\n    d = opU(d, -sdPlane(p, vec3(0,0,2)));\n    \n    #ifndef HIDE_BOX\n    d = opU(d, sdBox(p,vec3(3,2.6,1.8)));\n    \n    // border?\n    //d = opU(d, sdBox(p,vec3(3,4,2)));\n    \n    // how to make warp area bigger?\n    d = opS(sdBox(p + vec3(0,0,0.5), vec3(4,2.5,0.75)), d);\n    #endif\n    \n    d = opU(d, sdSphere(p + vec3(2,0,0.5),0.25));\n    \n    \n    // right pillar\n    d = opU(d, sdBox(p + vec3(1.5,1.4,0.5), vec3(0.125,0.125,0.9)));\n    d = opU(d, sdSphere(p + vec3(1.5,1.4,1.0), 0.125));\n\n    // left pillar\n    d = opU(d, sdBox(p + vec3(1.5,-1.4,0.4), vec3(0.125,0.125,0.9)));\n    d = opU(d, sdSphere(p + vec3(1.5,-1.4,1.0), 0.125));\n\n    \n   \n    \n    //d = opU(d, -sdSphere(p,32.0));\n    \n\treturn d;\n}\n\nfloat MarchWarp(vec3 origin,vec3 dir)\n{\n    float dist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Warp(origin + dir * dist);\n        \n        dist += sceneDist * STEP_MULT;\n        \n        if(abs(sceneDist) < MIN_DIST || sceneDist > MAX_DIST)\n        {\n            break;\n        }\n    } \n    return dist;\n}\n\nvec3 MarchRay(vec3 origin,vec3 dir)\n{\n    bool inWarp = false;\n    \n    float dist = 0.0;\n    \n    //Distance to the \"warp zone\".\n    float warpDist = MarchWarp(origin,dir);\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(origin + dir * dist);\n        \n        //Reset the march distance, set the ray origin to the surface of the \"warp zone\", scale the map and ray origin.\n        #ifndef DISABLE_WARP\n        if(warpDist < dist && !inWarp)\n    \t{\n            scale.x = 4.0;\n            \n            dist = 0.0;\n            origin = origin + dir * warpDist;\n            origin /= scale;\n            \n            inWarp = true;\n    \t}\n        #endif\n        \n        if(warpDist < dist && !inWarp)\n    \t{\n            // just a mirror\n            //scale.x = -1.0;\n            \n            // mirror longated\n            //scale.x = -1.0/4.0;\n            \n            //scale.x = -8.0;\n            \n            // dolly zoom basically?\n            float zzmax = 15.0;\n            float zz =  zzmax * (1.0 + cos(iTime * 0.5)) / 2.0;\n            \n            if (zz < 0.0)\n                zz = 0.0;\n            \n            scale.x = -1.0 * (1.0 + zz);\n\n            \n            dist = 0.0;\n            origin = origin + dir * warpDist;\n            origin /= scale;\n            \n            inWarp = true;\n    \t}\n        \n        dist += sceneDist * STEP_MULT;\n        \n        if(abs(sceneDist) < MIN_DIST || sceneDist > MAX_DIST)\n        {\n            if(sceneDist < 0.0)\n            {\n                dist += MIN_DIST;\n            }\n            \n            break;\n        }\n    }\n    \n    return origin + dir * dist;\n}\n\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS,0,0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p+off.xyz) - Scene(p-off.xyz),\n            Scene(p+off.zxy) - Scene(p-off.zxy),\n            Scene(p+off.yzx) - Scene(p-off.yzx)\n        )\n    );\n}\n\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    position *= scale;\n   // vec3 color = vec3(1.0);\n    vec3 color = vec3(1.1, 0.9, 0.3);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .55 + .75;\n    \n    // can we make the floor checker larger?\n    float checker = \n        \n        // keep bmv pattern in mirror\n        sin(position.x * pi *2.0) \n        * sin(position.y * pi * 2.0) \n        * sin(position.z * pi * 2.0);\n    \n    color *= step(0.0,checker) * 0.25 + 0.75;\n    \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 0.7 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 angles = vec3(0);\n    \n    \n    if(iMouse.xy == vec2(0))\n    {\n    \tangles = vec3(iTime * 0.2, 1.3, 0.0);\n    }\n    else\n    {\n    \tangles = vec3((iMouse.xy/iResolution.xy)*pi,0);\n    }\n    \n    angles.xy *= vec2(2.0,1.0);\n    angles.y = clamp(angles.y,-tau/4.0, 1.5);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    //vec3 orig = vec3(0,0,-2) * rotate;\n    \n    // altitude\n    //vec3 orig = vec3(0,0,-3) * rotate + vec3(0,0,-3);\n    // could we orbit around the ball only?\n\n    // side\n    //    vec3 orig = vec3(0,0,-3) * rotate + vec3(0,3,0);\n\n    //vec3 orig = vec3(0,0,-3) * rotate + vec3(-2,0,0);\n//\tvec3 orig = vec3(0,0,-1) * rotate + vec3(-2,0,0);\n//\tvec3 orig = vec3(0,0,-0.5) * rotate + vec3(-2,0,-0.5);\n\n    //vec3 orig = vec3(0,0,-0.5) * rotate + vec3(-2.125,0,-0.5);\n    vec3 orig = vec3(0,0,-0.5) * rotate + vec3(-2.125,0.125,-0.5);\n\n    \n    vec3 dir = normalize(vec3(uv - res/2.0,0.5)) * rotate;\n    \n    vec3 hit = MarchRay(orig,dir);\n    vec3 norm = Normal(hit);\n    \n    vec3 color = Shade(hit,norm,dir,orig);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}