{"ver":"0.1","info":{"id":"3slXDN","date":"1551309199","viewed":143,"name":"BufferFu","username":"vame","description":"practicing concepts - using buffers to create something dynamic. Use your mouse to paint and also move the \"distortion ball\"\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//returns 1.0 if uv coordinate falls inside frame, 0 if outside - \n//a some value between 0 and 1 depending on smoothFactor and coordinate.\n//smoothFactor = 0 , no smoothing , hard corners.\nvec3 smoothedFrame(vec2 pos,vec2 size,float smoothFactor,vec2 uv){\n\n    vec2 cornerCoords = vec2(0.5)-size/2.0;\n    vec2 bl = smoothstep(cornerCoords,cornerCoords + vec2(smoothFactor),uv - pos);\n    vec2 tr = smoothstep(cornerCoords,cornerCoords + vec2(smoothFactor),1.0 - uv + pos);    \n    return vec3(bl.x*bl.y*tr.x*tr.y)*1.0;\n\n}\n\nvec3 smoothedCircle(vec2 pos,float size,float smoothFactor,vec2 uv){\n\n    //naive step\n    //return vec3(step(distance(pos,uv),size));\n    float distanceToCircleOrigo = distance(pos,uv);\n    \n    //why do we need 1.0\n    //because smoothStep returns if 1 if x is bigger than a and b in a,b,x\n    //when we define a circle , distances smaller than size should be 1, \n    //so we need to invert it.\n    \n    //rule to remember , smoothstep a b x , x larger than ab then 1..\n    return vec3(1.0-smoothstep(size,size+smoothFactor,distanceToCircleOrigo));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 bl = smoothstep(vec2(0.0),vec2(0.2),uv);\n    vec2 tr = smoothstep(vec2(0.0),vec2(0.2),1.0 - uv);\n    // Time varying pixel color\n    \n    vec2 blWhite = step(vec2(0.1),uv);\n    vec3 frame = vec3(bl.x*bl.y*tr.x*tr.y)*5.0;\n    \n    \n    float innerBoom = smoothstep(0.0f,0.1f,sin(iTime*5.4))*0.5;\n    float xBoom = cos(iTime*227.5*innerBoom)*0.03;\n    float yBoom = sin(iTime*126.5*innerBoom + innerBoom*2.3f)*0.03;\n    float smoothAnim = cos(iTime*2.0)*0.05 + 0.05;\n    \n    vec3 combinedShapes = smoothedFrame(vec2(xBoom,yBoom),vec2(0.5),smoothAnim,uv);\n    combinedShapes+=smoothedCircle(vec2(0.5 + xBoom,sin(iTime*2.3)*0.3+0.5),0.175,smoothAnim*0.5,uv);\n    vec3 col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*min(combinedShapes,vec3(1.0))*5.0;\n \n    col = texture(iChannel0,uv).rgb;//*min(combinedShapes,vec3(1.0))*5.0;;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord/iResolution.xy;\n    \n    float distFactor = texture(iChannel0,uv).a;\n    \n    //reading with distortion\n    uv.y+=sin(uv.x*iTime*0.003 + uv.y*5.3 + iTime*5.4)*(0.01 + distFactor);\n    uv.x+=sin(uv.y*iTime*0.003 + uv.y*8.3 + iTime*6.4)*(0.01 + distFactor);\n    //uv.y+=sin(uv.x*0.04 + uv.y*0.3 + iTime*0.004)*0.01;\n    //uv.x+=cos(uv.y*0.2+ uv.y*5.3 + iTime*0.04)*0.01;\n    fragColor = texture(iChannel0,uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 smoothedCircle(vec2 pos,float size,float smoothFactor,vec2 uv){\n\n    float distanceToCircleOrigo = distance(pos,uv);\n    \n    //why do we need 1.0\n    //because smoothStep returns if 1 if x is bigger than a and b in a,b,x\n    //when we define a circle , distances smaller than size should be 1, \n    //so we need to invert it.\n    \n    //rule to remember , smoothstep a b x , x larger than ab then 1..\n    return vec3(1.0-smoothstep(size,size+smoothFactor,distanceToCircleOrigo));\n\n}\n\nfloat colorSpewingBallRadius = 0.1;\nfloat colorSpewingBallRadiusOuterEdge = 0.2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float timeTick = sin(iTime);\n    \n    vec3 smoo = smoothedCircle(vec2(0.5,0.5),0.175,0.1,uv);\n    vec3 texCol = vec3(0.0);\n    float mouseInput = (1.0-smoothstep(colorSpewingBallRadius,colorSpewingBallRadiusOuterEdge,distance(uv.xy,iMouse.xy/iResolution.xy)))*iMouse.z;\n  \n    //reading previous frame and diminishing color by a factor : also clamping to keep values from going haywire.\n    texCol = clamp(texture(iChannel0,uv).rgb*(0.99),vec3(0.0),vec3(1.0));\n    vec3 adjustments = smoo*0.01;\n    vec3 dutchColors = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    if(mouseInput>0.01){\n        \n    adjustments+=dutchColors*mouseInput*0.01; //inputting mouse input..\n    }\n    //mouse input to alpha channel - used in buffer A to modify distortion strength.\n    fragColor = vec4(texCol+adjustments,mouseInput*0.0001);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}