{"ver":"0.1","info":{"id":"tdKcWh","date":"1607801234","viewed":170,"name":"Finale Assembly MS october2020","username":"MonsieurSoleil","description":"Shaderbattle","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["shaderbattle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (iTime/60.0)*140.0\n#define mod01 floor(mod(time * 4.0, 16.0))\n#define mod02 floor(mod(time * 2.0, 8.0))\n\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nstruct matter\n{\n \tfloat m;\n    int type;\n    bool reflected;\n};\n    \nfloat box(vec3 p, vec3 s)\n{\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sphere(vec3 p, float s)\n{\n\t\n    return length(p) - s;\n}\n\nvec3 kifs(vec3 p)\n{\n    float t1 = 0.5 + (time * 0.1 * 0.25);\n    float s = 2.0;\n    \n    for(int i = 0; i < 4; ++i)\n    {\n     \tp.yz *= rot(t1 + float(i) * 0.1);\n        p.yz = abs(p.xz);\n        p.yz -= s;\n    }\n    \n    \n    \n    return p;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n\tfloat mat01, mat02, mat03;\n    \n   \n    \n    \n    \n    p.xz *= rot(time * 0.2) * 1.05;\n    p.yz *= rot(time * 0.15) * 1.15;\n    p.xy *= rot(time * 0.05);\n    \n    vec3 p01 = p, p02 = p, p03 = p, p04 = kifs(p);\n    \n    mat02 = box(p, vec3(0.55 + 0.45 * abs(sin(time * 0.25))));\n    //mat02 = min(mat02, -box(p, vec3(3.5)));\n    \n    if(mat02 < 0.01)\n    {\n     \tmat.type = 1;   \n    }\n    \n    if(mod(mod02, 4.0) <= 1.0)\n    \tmat01 = box(p, vec3(1.05 + 0.10 * mod02));\n    if(mod(mod02, 4.0) > 1.0)\n        mat01 = sphere(p, 1.05 + 0.10 * mod02);\n    \n    float rep01 = 0.45;\n    \n    p02.y = (fract(abs(p04.y + time * 0.05) / rep01 - 0.5) - 0.5) * rep01;\n    float id = (floor(abs(p.y) / rep01 - 0.5) - 0.5) * rep01 * (16.0 * abs(sin(time * 0.5)));\n    \n    p03.y = (fract(abs(p04.y + time * 0.05) / rep01 - 0.5) - 0.5) * rep01;\n    float id02 = (floor(abs(p.y) / rep01 - 0.5) - 0.5) * rep01 * (16.0 * abs(sin(time * 0.5)));\n    \n   \t/*p02.xz *= rot(time * 0.2);\n    p02.yz *= rot(time * 0.1);\n    p02.xy *= rot(time * 0.1);*/\n    \n    mat01 = max(mat01, -box(p02 - vec3(0.5 * sin(p.x * 0.2), 0.0, 0.0), vec3(10.0, 0.15 + (sin(p.x * 0.1 * id * mod01) * 0.25) + (sin(p.z * 0.1) * 0.25), 10.0)));\n    \n    mat01 = max(mat01, -box(p02 - vec3(0.0, 0.0, 0.0), vec3(0.15 + (sin(p.z * 0.1 * id * mod01) * 0.25) + (sin(p.z * 0.1) * 0.25),10.0, 10.0)));\n    \n    \n    gg += 0.15/(0.11+abs(mat01));\n    \n    mat.m = min(mat01, mat02);\n}\n\nvec3 normals(vec3 p)\n{\n \tvec2 uv = vec2(0.01, 0.0);\n    \n    matter m01,m02,m03,m04;\n    \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n    \n    return normalize(m01.m - vec3(m02.m, m03.m,m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    vec3 o = vec3(0.0, 0.0, 4.0), t= vec3(0.0);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p = o + dir * 0.5;\n    \n   \tmatter mat;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 150; ++i)\n    {\n        //p.xy *= rot(0.001);\n        \n     \tmap(mat, p);\n        \n        if(mat.m < 0.01)\n        {\n            if(mat.type == 1)\n            {\n                vec3 n = normals(p);\n                dir = reflect(dir, -n);\n                \n                mat.m = 0.15;\n                mat.type = 0;\n                mat.reflected = true;\n            }\n         \tmat.m = 0.1;\n        }\n        \n        if(mod(mod02, 4.0) <= 1.0)\n        \tcol += gg * 0.00030 * vec3(0.0, 0.5, 1.0);\n        if(mod(mod02, 4.0) > 1.0)\n        \tcol += gg * 0.00030 * vec3(1.0, 0.5, 0.0);\n        \n        p += dir * mat.m * 0.5;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}