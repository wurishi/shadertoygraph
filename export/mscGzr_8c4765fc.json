{"ver":"0.1","info":{"id":"mscGzr","date":"1676908870","viewed":101,"name":"Jonix Mello","username":"Hultsborn10","description":"My variant of the Melodifestivalen logo","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["melodifestivalen","mello"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The logo for the annual Swedish Music Competition \"Melodifestivalen\"\n//https://melodifestivalen.se/\n\n#define BLUE    vec3(0.03, 0.66, 0.87) \n#define PURPLE  vec3(0.50, 0.31, 0.62) \n#define PINK    vec3(0.91, 0.21, 0.56) \n#define MAGENTA vec3(0.83, 0.03, 0.54) \n#define ORANGE  vec3(0.97, 0.35, 0.15) \n#define YELLOW  vec3(0.99, 0.62, 0.0) \n\n  \n  \n  \n\nfloat GetDist(vec2 p, vec2 a, vec2 b){\n    //Beräkna punkten p's avstånd till linjen från a till b\n    vec2 g = b - a;\n    vec2 h = p - a;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n    return d;\n}\n\n//Funktionen tar fram två punkter på en linje definierad av en linjefunktion\nvec4 GetLinePoints(vec2 line, float x){\n    float leftX = x - 1.5;\n    float leftY = line.x * leftX + line.y;\n    float rightX = x + 1.5;\n    float rightY = line.x * rightX + line.y;\n    vec4 linePoints = vec4(leftX, leftY, rightX, rightY);\n    return linePoints;\n}\n\n//Funktionen ger värden > 0 där det ska vara ett band.\n//Bandet anges med startpunkt a, slutpunkt b, en bredd och två linjer som skär av bandet\n//(funktion för linjerna: Y=X*line.x + line.y)\nfloat Band(vec2 p, vec2 a, vec2 b, float width, vec2 topLine, vec2 bottomLine){\n    float d = GetDist(p, a, b);\n    //Gör kantens \"smoothness\" omvänt proportionerlig mot upplösningen\n    //Det ger fina kanter oavsett upplösning\n    float edge = 4.0/iResolution.x;\n    //Skapa ett fint band med bredden och en mjuk kant\n    float band = smoothstep(width, width-edge, d);\n    //Ta fram den övre linjens position och jämför med p\n    float topY = p.x * topLine.x + topLine.y;\n    vec4 topPoints = GetLinePoints(topLine, p.x);\n    float topD = GetDist(p, vec2(topPoints.x, topPoints.y), vec2(topPoints.z, topPoints.w));\n    //Skapa en mjuk kant\n    float cutTop = smoothstep(0.0, edge, topD);\n    //Klipp bort överflödigt band över linjen\n    if(topY < p.y) cutTop = 0.0;\n    //Ta fram den undre linjens position och jämför med p\n    float bottomY = p.x * bottomLine.x + bottomLine.y;\n    vec4 bottomPoints = GetLinePoints(bottomLine, p.x);\n    float bottomD = GetDist(p, vec2(bottomPoints.x, bottomPoints.y), vec2(bottomPoints.z, bottomPoints.w));\n    //Skapa en mjuk kant\n    float cutBottom = smoothstep(0.0, edge, bottomD);\n    //Klipp bort överflödigt band under linjen\n    if(bottomY > p.y) cutBottom = 0.0;\n    //Returnera unionen av alla delarna\n    return cutTop * band * cutBottom;\n}\n\n//Funktionen skapar ett suddigt ljussken i bakgrunden\nfloat Blur(vec2 p, vec2 a, vec2 b){\n    float d = GetDist(p, a, b);\n    //Låt det glödande ljuset pulsera med en sinusvåg\n    //Vi vill endast ha värden mellan 0 och 1 här,\n    //så att vi inte riskerar att \"suga bort\" andra färger när vi senare adderar.\n    return clamp(0.15*(sin(iTime*2.0)+1.7) - d, 0.0, 1.0);\n}\n\n\n//Funktionen returnerar färgen från en glödande linje\nvec3 GetLineGlow(vec2 p, vec2 a, vec2 b, vec3 col){\n  //Vi är endast intresserade av avståndet närmast linjen\n  float d = 8.0*GetDist(p, a, b);\n  //Skapa en gräns för smoothstep som anpassas till skärmupplösning\n  float limit = 40.0/iResolution.x;\n  //Skapa en vit linje i centrum\n  float c = smoothstep(limit,0.00, d);\n  //Minska intensiteten och ta 1-avståndet, lägg till den vita centrumlinjen\n  return clamp(0.18*(1.0-d)*col+vec3(c),0.0, 1.0);  \n}\n\n//Funktionen returnerar summan av alla glödande linjer i en polygon\nvec3 GetPolyGlow(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec3 q, vec2 flip){\n  //Eventuel spegling i x-led\n  a *= flip;\n  b *= flip;\n  c *= flip;\n  d *= flip;\n  //Ta fram glödande linje för alla fyra linjerna i polygonen\n  vec3 col = GetLineGlow(p, a, b, q);\n  col += GetLineGlow(p, b, c, q);\n  col += GetLineGlow(p, c, d, q);\n  col += GetLineGlow(p, d, a, q);\n  //Returnera totalsumman\n  return col;  \n}\n\n//Returnerar summan av alla glödande linjer i figuren\nvec3 GetGlowingLines(vec2 p){\n  //Räkna om koordinaterna från -500 .. 500 till -0.25..0.25\n  float mag = 2000.0;\n  //Skapa alla punkter som behövs i den högra delen av figuren (sen speglar vi)\n  vec2 p1 = vec2(0,500)/mag;\n  vec2 p2 = vec2(-60,305)/mag;\n  vec2 p3 = vec2(365,290)/mag;\n  vec2 p4 = vec2(465,204)/mag;\n  vec2 p5 = vec2(305,-500)/mag;\n  vec2 p6 = vec2(189,-500)/mag;\n  vec2 p7 = vec2(-73,-313)/mag;\n  vec2 p8 = vec2(0,-412)/mag;\n  //Ta ut glödande färg för en polygon i taget\n  vec3 col = GetPolyGlow(p, p1, p5, p6, p2, MAGENTA, vec2(1,1));\n  //Obs, här speglas koordinaterna i x-led\n  col += GetPolyGlow(p, p1, p5, p6, p2, PINK, vec2(-1,1));\n  col += GetPolyGlow(p, p4, p8, p7, p3, ORANGE, vec2(1,1));\n  col += GetPolyGlow(p, p4, p8, p7, p3, PURPLE, vec2(-1,1));\n  col += GetPolyGlow(p, p4, p5, p6, p3, YELLOW, vec2(1,1));\n  col += GetPolyGlow(p, p4, p5, p6, p3, BLUE, vec2(-1,1));\n  return col;\n}\n\n\n//En matris för att rotera med vinkel a\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //Bakgrundsbild\n    //vec3 col = texture(iChannel0, uv).rgb; \n    //Bakgrunden är svart\n    vec3 col = vec3(0);\n\n    //Snurra bilden\n    uv *= Rot(iTime*0.3);\n    \n    //Zooma in och ut\n    float Zoom = 2.0*sin(iTime*0.5);\n    uv *= Zoom;\n    \n    //Bredden på ytorna\n    float bandWidth = 0.05; \n    \n    //Gult band\n    vec2 yellowStart = vec2(0.4, 0.15);\n    vec2 yellowEnd = vec2(0.245, -0.5);\n    float yellowBand = Band(uv, yellowStart, yellowEnd, bandWidth, vec2(-0.95, 0.5), vec2(0.0, -0.45 ));\n   \n    //Orange band\n    vec2 orangeStart = vec2(0.4, 0.145);\n    vec2 orangeEnd = vec2(-0.05, -0.35);\n    float orangeBand = Band(uv, orangeStart, orangeEnd, bandWidth, vec2(-0.95, 0.5), vec2(-1.1, -0.37));\n    \n    //Rosa band\n    vec2 pinkStart = vec2(0.1, 0.5);\n    vec2 pinkEnd = vec2(-0.28, -0.5);\n    float pinkBand = Band(uv, pinkStart, pinkEnd, bandWidth, vec2(-2.6, 0.375), vec2(0.0, -0.45 ));\n    \n    //Blått band\n    vec2 blueStart = vec2(-0.4, 0.15);\n    vec2 blueEnd = vec2(-0.25, -0.5);\n    float blueBand = Band(uv, blueStart, blueEnd, bandWidth, vec2(0.95, 0.5), vec2(0.0, -0.45));\n    \n    //Lila band\n    vec2 purpleStart = vec2(-0.4, 0.145);\n    vec2 purpleEnd = vec2(0.05, -0.35);\n    float purpleBand = Band(uv, purpleStart, purpleEnd, bandWidth, vec2(0.95, 0.5), vec2(1.4, -0.37));\n    \n    //Starkt rosa \n    vec2 magentaStart = vec2(-0.1, 0.5);\n    vec2 magentaEnd = vec2(0.28, -0.5);\n    float magentaBand = Band(uv, magentaStart, magentaEnd, bandWidth, vec2(2.6, 0.375), vec2(0.02, -0.45 ));\n    \n    //Lägg ihop alla band till en gemensam kontur\n    float allBands = yellowBand + orangeBand + pinkBand + blueBand + purpleBand + magentaBand;\n    //Minska ner konturens kanter\n    allBands *= 0.4;\n\n    //Skapa glödande sudd för alla färger\n    float yellowSoft = clamp(Blur(uv, yellowStart, yellowEnd)-allBands,0.0, 1.0);\n    vec3 yellowBlur = YELLOW * yellowSoft;\n\n    float orangeSoft = clamp(Blur(uv, orangeStart, orangeEnd)-allBands,0.0, 1.0);\n    vec3 orangeBlur = ORANGE * orangeSoft;\n    \n    float pinkSoft = clamp(Blur(uv, pinkStart, pinkEnd)-allBands,0.0, 1.0);\n    vec3 pinkBlur = PINK * pinkSoft;\n\n    float blueSoft = clamp(Blur(uv, blueStart, blueEnd)-allBands,0.0, 1.0);\n    vec3 blueBlur = BLUE * blueSoft;\n    \n    float purpleSoft = clamp(Blur(uv, purpleStart, purpleEnd)-allBands,0.0, 1.0);\n    vec3 purpleBlur = PURPLE * purpleSoft;\n\n    float magentaSoft = clamp(Blur(uv, magentaStart, magentaEnd)-allBands,0.0, 1.0);\n    vec3 magentaBlur = BLUE * blueSoft;\n    \n    //Lägg ihop alla banden (i rätt ordning) med mix-funktionen\n    //Då blir kanterna i överlappen mjuka\n    col = mix(col, MAGENTA, magentaBand);\n    col = mix(col, PURPLE, purpleBand);\n    col = mix(col, BLUE, blueBand);\n    col = mix(col, PINK, pinkBand);\n    col = mix(col, ORANGE, orangeBand);\n    col = mix(col, YELLOW, yellowBand);\n     \n    //Lägg till alla glödande färgerna\n    col += yellowBlur;\n    col += orangeBlur;\n    col += pinkBlur;\n    col += blueBlur;\n    col += purpleBlur;\n    col += magentaBlur;\n    \n    //Växla mellan hela band och glödande linjer\n    if (Zoom < 0.0)\n        //När zoomningen blir negativ så byter vi \n        //(fast använder negativa uv för att kompensera negativ zoom)\n        col = GetGlowingLines(-uv);\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}