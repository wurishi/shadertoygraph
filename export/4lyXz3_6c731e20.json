{"ver":"0.1","info":{"id":"4lyXz3","date":"1485190110","viewed":463,"name":"Circular Multiplication Graph","username":"n1kk","description":"A circle of multiplication relations. Point on a circle represents number. Multiply each number to get a second point and draw a line. Repeat for each number on a circle (200). Points loop (201 == 1). Animating multiplier value we see interesting patterns","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["circles","patterns","lines","multiplication"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define LINE_COUNT 400.\n//#define ANIMATE_HALF_FILL true\n\nfloat getLineThickness(float thickness) {\n    // thickness optimized for resolution\n    return thickness * 400. / max(iResolution.x, iResolution.y); \n}\n\n//------- CIRCLE\n\nfloat circle(vec2 origin, vec2 pos, float radius, float thickness)\n{\n    float n = 100.0 / getLineThickness(thickness);\n    return clamp(((1.0-abs(length(origin + pos)-radius))-(1.0 - 1.0/n)) * n, 0.0, 1.0);\n}\n\nfloat circle(vec2 origin, vec2 pos, float radius)\n{\n    return circle(origin, pos, radius, 1.0);\n}\n\nfloat circleFill(vec2 origin, vec2 pos, float radius)\n{\n    return clamp(((1.0-(length(origin+pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\nfloat circleGlow(vec2 origin, vec2 pos, float radius, float len, float str)\n{\n    float inCircle = ((1.0-(length(origin + pos)-(radius + len)))-0.99) * str;\n    return clamp(inCircle, 0.0, 1.0);   \n}\n\nfloat circleLineGlow(vec2 origin, vec2 pos, float radius, float len, float str)\n{\n    float inCircle = ((1.0-abs(length(origin + pos)-(radius)) + len)-0.99) * str;\n    return clamp(inCircle, 0.0, 1.0);   \n}\n\n// ------ LINE \n\nfloat line(in vec2 p, in vec2 a, in vec2 b, float thickness)\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    //return clamp(((1.0 - d)-0.99)* 100.0 , 0.0, 1.0);\n\t//float n = 100.0 / thickness;\n    float n = 100.0 / getLineThickness(thickness);\n    return clamp(((1.0 - d) - (1.0 - 1.0/n)) * n , 0.0, 1.0);\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn line(p, a, b, 1.0);\n}\n\nfloat lineGlow(in vec2 p, in vec2 a, in vec2 b, float str )\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float n = 10.0;\n    return 0.1 * str * clamp(((1.0 - d) - (1.0 - 1.0/n)) * n , 0.0, 1.0);\n}\n\n// ------- GEOM\n\nvec2 pointOnACircle(vec2 pos, float r, float a) {\n \treturn vec2(pos.x + r * sin(a),  pos.y + r * cos(a));\n}\n\n// ------ GRAPH\n\nfloat multCircle(vec2 origin, vec2 pos, float radius, float multiplier, \n           float cglow, float cglows, float lglow,\n           bool ccw, float angle_shift) {\n    float c = .0;\n    \n    c += circle(origin, pos, radius, 1.0);\n    c += circleLineGlow(origin, pos, radius, cglow, cglows);\n    \n    for (float i = 0.0; i <= LINE_COUNT; i++) {\n#ifdef ANIMATE_HALF_FILL\n        if (i > LINE_COUNT * \n            (.5 + .5 * smoothstep(-1., 1., sin(iTime*.5)))) break;\n#endif                \n        float rotation_dir = ccw ? -1. : 1.;\n        float angle1 = i * (2.*PI/LINE_COUNT);\n        float angle2 = multiplier * i * (2.*PI/LINE_COUNT);\n        \n        vec2 pos1 = pointOnACircle(pos, radius, angle_shift + angle1 * rotation_dir);\n        vec2 pos2 = pointOnACircle(pos, radius, angle_shift + angle2 * rotation_dir);\n        \n        c += line(origin, pos1, pos2, 0.8) * 0.5;\n        c += lineGlow(origin, pos1, pos2, lglow) * 0.5;\n    }\n    \n    return c;\n}\n\n/// =============== MAIN ===================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // origin\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime * 0.5;\n    \n    #define c(t, s) 0.5 + 0.25 * sin(t+s)\n    \n    vec3 colour1 = vec3(c(t,2.96), c(t,54.88), c(t,48.11));\n\tvec3 colour2 = vec3(c(t,12.51), c(t,2.58), c(t,71.99));\n    \n    vec3 c = vec3(0);\n    \n    bool clicked = iMouse.z > 0. || iMouse.w > 0.;\n    \n    #define C_RAD 0.9\n    #define C_POS vec2(0)\n    // 8.69 10.091 11.0 12.11 13.5 15.285 17.666 19.182\n    #define START_FRAME 102.5\n    \n    float speed = (clicked ? 0.1 : 0.5);\n    speed *= (0.4 + 0.15 * sin (iTime*0.1));\n    float M = START_FRAME + iTime * speed;\n    \n    float inCircle = circleFill(p, C_POS, C_RAD);\n    if (inCircle > .0) {\n   \t\tc += multCircle(p, C_POS, C_RAD, M, \n                        0.1, 0.5, 0.4,\n                       true, iTime*.05);\n        c *= colour1;\n    } else {\n    \tc += multCircle(p, C_POS, 2.0, START_FRAME + M * 0.05, \n                        0.1, 1.0, 0.9,\n                       false, -iTime*.01);\n    \tc *= colour2;\n    }\n    \n    c = clamp(c, 0.0, 1.0);\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}