{"ver":"0.1","info":{"id":"l32GWG","date":"1711510686","viewed":38,"name":"pumping rainbow ring","username":"ShadedSky","description":"raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants for ray marching\n#define MAX_MARCH_STEPS 256\n#define EPSILON 0.001\n#define FAR_CLIP 100.0\n\n// Camera position and zoom factor\nvec3 cameraPos = vec3(0.0, 0.0, 5.0);\nfloat zoomFactor = 1.0;\n\n// Distance function for the tunnel shape\nfloat map(vec3 p) {\n    // The tunnel shape is a sphere with radius 1 centered at the origin\n    return length(p) - 1.0;\n}\n\n// Function to estimate the surface normal at a point\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.01; // Epsilon value for numerical differentiation\n    return normalize(vec3(\n        // Estimate x-component of the normal\n        map(p + vec3(eps, 0.0, 0.0)) - map(p - vec3(eps, 0.0, 0.0)),\n        // Estimate y-component of the normal\n        map(p + vec3(0.0, eps, 0.0)) - map(p - vec3(0.0, eps, 0.0)),\n        // Estimate z-component of the normal\n        map(p + vec3(0.0, 0.0, eps)) - map(p - vec3(0.0, 0.0, eps))\n    ));\n}\n\n// Function to perform ray marching\nbool rayMarch(vec3 origin, vec3 direction, out vec3 hitPoint) {\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = origin + direction * totalDistance;\n        float dist = map(p);\n        if (dist < EPSILON) {\n            // If the distance to the surface is small, consider it a hit\n            hitPoint = p;\n            return true;\n        }\n        totalDistance += dist;\n        if (totalDistance >= FAR_CLIP) break; // Break if the ray travels too far\n    }\n    return false; // Return false if no hit is found\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Convert pixel coordinates to normalized device coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // Map normalized device coordinates to range [-1, 1] for both axes\n    uv = uv * 2.0 - 1.0;\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Adjust zoom level based on mouse position or any other input\n    zoomFactor = 1.0 + 2.0 * (0.5 - length(uv)) * 5.0 * sin(iTime);\n\n    // Calculate ray direction from camera position and adjusted UV coordinates\n    vec3 rayDir = normalize(vec3(uv * zoomFactor, -1.0));\n    \n    vec3 hitPoint; // Variable to store the intersection point with the surface\n    // Perform ray marching to trace the ray and find intersection points\n    if (rayMarch(cameraPos, rayDir, hitPoint)) {\n        // Estimate the surface normal at the intersection point\n        vec3 normalDir = estimateNormal(hitPoint);\n        // Calculate the reflection direction of the ray\n        vec3 reflectDir = reflect(rayDir, normalDir);\n        // Calculate the strength of the reflection\n        float reflection = dot(reflectDir, normalize(hitPoint - cameraPos));\n\n        // Rainbow coloring based on intersection point and time\n        vec3 rainbow = vec3(\n            0.5 + 0.5 * cos(hitPoint.x + iTime),\n            0.5 + 0.5 * cos(hitPoint.y + iTime),\n            0.5 + 0.5 * cos(hitPoint.z + iTime)\n        );\n\n        // Mix rainbow color with white based on reflection strength\n        vec3 color = mix(rainbow, vec3(1.0), reflection);\n\n        // Output final color\n        fragColor = vec4(color, 1.0);\n    } else {\n        // If no intersection point is found, set output color to black\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}