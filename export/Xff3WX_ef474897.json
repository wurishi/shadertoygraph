{"ver":"0.1","info":{"id":"Xff3WX","date":"1703589707","viewed":22,"name":"Ray_Marching_klahsiv","username":"klahsiv","description":"A simple ray marching shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 40\n#define MAX_DIST 100.\n#define EPSILON 0.01\n\nfloat SphereDistance(vec3 p, vec3 o, float radius){\n    return length(p - o) - radius;\n}\n\nfloat GroundPlaneDistance(vec3 p){\n    return abs(p.y);\n}\n\nfloat GetDist(vec3 p){\n    \n    floatd = MAX_DIST;\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    \n    vec3 ro = vec3 (0, 1, -10);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 col = vec3(0);\n    \n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        \n        vec3 p = ro + rd * dO;\n        float d = SphereDistance(p, vec3(0, 3, -1), 1.);\n        d = min(d, GroundPlaneDistance(p));\n        \n        if(d <= EPSILON || d >= MAX_DIST){\n            //dO *= ( (float)i / (float)MAX_STEPS);\n            break;\n        }\n        \n        dO += d;\n    }\n    \n    dO /= 10.;\n    col = vec3(dO);\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}