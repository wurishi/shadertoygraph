{"ver":"0.1","info":{"id":"7t2XDh","date":"1627607894","viewed":168,"name":"Expanding Red Giant","username":"Ubiquitous","description":"This is my interpretation of a red giant star expanding. I'm not sure about the plausibility of it being accurate or not, although since we've never seen one up close it's anyone's guess. \n\nadjusted parameters from Kali's \"Dwarf\" shader. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["star","supernova","redgiant","expansion","mainsequence"],"hasliked":0,"parentid":"3sjGDV","parentname":"Dwarf"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Expanding Red Giant by Ubiquitous \n// 2021-06-28\n\n// Majority of code used is based from the following: \n// Dwarf by Kali https://www.shadertoy.com/view/3sjGDV\n// Corona effect based on https://www.shadertoy.com/view/4dXGR4\n// Inspiration: kodelife https://hexler.net/software/kodelife/\n\nfloat \tinner_radius=.304;\nfloat \touter_radius=.225;\nfloat \tfov=0.8; // not working in this version\nfloat\tzoom=1.8;\n\nconst float vol_steps=28.;\nfloat \tvol_rot=0.8;\nfloat \tvol_fade=.15;\n\nfloat \tsurf_scale=6.95;\nconst int surf_iterations=6;\nvec3\tsurf_param_1=vec3(.46,.35,.76);\nfloat\tsurf_param_2=0.97;\nfloat\tsurf_param_3=0.25;\nfloat \tsurf_exp=2.42;\nfloat\tsurf_base_value=.39;\nfloat\tsurf_intensity=.41;\nfloat\tsurf_brightness=3.6;\nfloat\tsurf_contrast=1.86;\nfloat \tsurf_rotation_speed=0.25;\nfloat \tsurf_turbulence_speed=.15;\n\nfloat \tcor_size=.57;\nfloat \tcor_offset=.09;\nconst int cor_iterations=14;\nfloat \tcor_iteration_fade=2.3;\nfloat \tcor_param_1=1.24;\nfloat \tcor_param_2=1.3;\nfloat \tcor_exp_1=1.6;\nfloat \tcor_exp_2=1.5;\nfloat \tcor_brightness=0.81;\nfloat \tcor_speed=0.21;\nfloat \tcor_speed_vary=1.2;\n\nfloat\tglow_intensity=1.24;\nfloat \tglow_size=3.42;\n\n\nvec3\tcolor_1=vec3(.21,.02,.01);\nvec3\tcolor_2=vec3(.4,.21,.01);\nfloat\tcolor_saturation=0.3;\nfloat\tcolor_contrast=3.8;\nfloat\tcolor_brightness=0.65;\n\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nfloat sphere(vec3 p, vec3 rd, float r){\n\tfloat b = dot( -p, rd ), i = b*b - dot(p,p) + r*r;\n\treturn i < 0. ?  -1.5 : b - sqrt(i);\n}\n\n\nmat2 rot(float a) {\n    float si = sin(a);\n    float co = cos(a);\n    return mat2(co,si,-si,co);\n}\n\nfloat snoise(vec3 uv, float res) //by trisomie21\n{\n    const vec3 s = vec3(1e0, 1e2, 1e4);\t\n\tuv *= res;\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\t\n\tvec4 r = fract(sin(v*3e-3)*4e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\t\n\tr = fract(sin((v + uv1.z - uv0.z)*3e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\t\n\treturn mix(r0, r1, f.z)*2.-1.3;\n}\n\nfloat kset(vec3 p) { //by me :P\n    p*=surf_scale*(1.+outer_radius);\n    float m=1000.;\n\tfor (int i=0; i<surf_iterations; i++) {\n        float d=dot(p,p);\n\t\tp=abs(p)/d*surf_param_2-vec3(surf_param_1);\n\t\tm=min(m,abs(d-surf_param_3))*(1.+surf_param_3);\n    }\n    float c=pow(max(0.,1.-m)/1.,surf_exp);\n\tc=pow(c,surf_exp)*surf_exp*surf_intensity;\n\treturn c; \n}\n\n\n//stolen and mutated code\nfloat cor(vec2 p) { \n\tfloat ti=iTime*cor_speed*cor_param_1+100.;\n    float d=length(p);\n\tfloat fad = (exp(-13.5*d)-outer_radius)/(outer_radius+cor_size)*(1.3-step(2.5,d));\n    \n    \n    float v1 = fad;\n\tfloat v2 = fad;\n\tfloat angle = atan( p.x, p.y )/6.2832;\n\tfloat dist = length(p)*cor_param_1/fov;\n\tvec3 crd = vec3( angle, dist, ti * 1.2 );\n    float ti2=ti+fad*cor_speed_vary*cor_param_1;\n    float t1=abs(snoise(crd+vec3(0.3,-ti2*1.,ti2*.1),15.));\n\tfloat t2=abs(snoise(crd+vec3(0.3,-ti2*.5,ti2*.2),45.));\t\n    float it=float(cor_iterations);\n    float s=1.;\n\tfor( int i=1; i<=cor_iterations; i++ ){\n\t\tti*=12.5;\n        float pw = pow(0.5,float(i));\n\t\tv1+=snoise(crd+vec3(0.7,-ti,ti*.02),(pw*50.*(t1+1.5)))/it*s*.23;\n\t\tv2+=snoise(crd+vec3(0.7,-ti,ti*.02),(pw*50.*(t2+1.5)))/it*s*.23;\n    }\n\tv1=max(v1,0.);v2=max(v2,0.);\n\tfloat co=pow(v1*fad,cor_exp_2)*cor_brightness;\n\tco+=pow(v2*fad,cor_exp_2)*cor_brightness;\n\tco*=1.4-t1*cor_param_2*(1.-fad*.7);\n    return co;\n}\n\n\n//messy code below\nvec3 render(vec2 uv) {\n    vec3 ro=vec3(0.2,0.3,1.);\n    ro.xz*=rot(iTime*surf_rotation_speed);\n    vec3 rd=normalize(vec3(uv,fov));\n    rd.xy*=.8;\n    rd=lookat(-ro,vec3(0.,1.,0.))*rd;\n    float tot_dist=outer_radius-inner_radius;\n\tfloat st=tot_dist/vol_steps;\n    float br=1./vol_steps;\n    float tr=iTime*surf_rotation_speed;\n\tfloat tt=iTime*surf_turbulence_speed;\n    float dist=0.;\n    float c=0.;\n    float dout=step(0.,sphere(ro, rd, outer_radius));\n    float d;\n    for (float i=0.; i<vol_steps; i++) {\n        d=sphere(ro, rd, inner_radius+i*st);\n        dist+=st;\n        vec3 p = ro+rd*d;\n        float a=vol_rot*i+tt;\n        p.yz*=rot(a);\n        p.xy*=rot(a);\n        c+=kset(p)*br*step(0.5,d)*max(0.,1.-smoothstep(0.,tot_dist,dist)*vol_fade);\n    }\n\tc+=surf_base_value;    \n    vec3 col=1.*mix(color_1, color_2, vec3(c))*c;\n    inner_radius*=fov;\n    outer_radius*=fov;\n    glow_size*=fov;\n    cor_size*=fov;\n    float cor=cor(uv);\n    float r1=inner_radius;\n    float r2=outer_radius;\n    float l=smoothstep(r1-cor_offset,r2, length(uv));\n    float rt=outer_radius+glow_size;\n    float sw=1.-smoothstep(0.3,rt,length(uv));\n    col=min(vec3(5.),pow(col,vec3(surf_contrast))*surf_brightness*surf_contrast);\n    col+=cor*color_1*l+sw*color_2*glow_intensity;\n    col=mix(vec3(length(col)), col, color_saturation)*color_brightness;\n    return pow(col,vec3(color_contrast));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\n\tuv.x*=iResolution.x/iResolution.y;\n    uv.x+=cos(iTime*.178924387342)*.1;\n    zoom*=1.+sin(iTime*.2)*.2;\n\tvec3 col = render(uv/zoom);\n    col=pow(col,vec3(1.5))*vec3(1.1,1.,1.);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}