{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n\tvec3 pos;\n\tfloat rayon;\n};\n\t\nstruct plan_t\n{\n\tvec3 normale; // la normale au plan\n\tfloat d; //offset de l'Ã©quation\n};\n\t\nstruct surface_t\n{\n\tvec3 pos;\n\tvec3 normale;\n\tvec2 uv;\n\tint id;\n};\n\t\nstruct ray_t\n{\n\tvec3 pos;\n\tvec3 direction;\n};\n\nstruct material_t\n{\n\tvec3  couleur;\n\tfloat rugosite;\n};\n\nstruct mapping_t\n{\n\tvec3 rotation;\n};\n\t\nconst int NONE   = 0;\nconst int PLANE  = 1;\nconst int SPHERE = 2;\n\nconst float PI   = 3.14; //Valeur de PI\nfloat max_distance = 1e5; //distance par rapport Ã  la sphÃ¨re\n\nfloat intersectSphere( const in ray_t ray, const in sphere_t sphere, out surface_t surface)\n{\t\n\tmat4 espaceMonde =  mat4(\n\t\t1.0, 0.0, 0.0, -sphere.pos.x,\n\t\t0.0, 1.0, 0.0, -sphere.pos.y,\n\t\t0.0, 0.0, 1.0, -sphere.pos.z,\n\t\t0.0, 0.0, 0.0, 0.0\n\t);\n\t\n\tvec3 pos = vec3( vec4(ray.pos,1.0)*espaceMonde);\n\t\t\n\tfloat t,t1,t2;\n\tfloat a = pow(ray.direction.x, 2.0) + pow(ray.direction.y, 2.0) + pow(ray.direction.z, 2.0);\n\tfloat b = 2.0 *( (ray.direction.x*pos.x) + (ray.direction.y*pos.y) + (ray.direction.z*pos.z) );\n\tfloat c = pow(pos.x,2.0) + pow(pos.y,2.0)+pow(pos.z,2.0) - pow(sphere.rayon,2.0);\n\t\n\tfloat delta = pow(b,2.0) - (4.0*a*c);\n\tt1 = ( -b + sqrt(delta)) / (2.0*a);\n\tt2 = ( -b - sqrt(delta)) / (2.0*a);\n\t\n\tif (delta < 0.0) return max_distance; //Pas d'intersection\n\t\n\tif(t1 < t2){\n\t\tsurface.pos = ray.pos + (ray.direction * t1);\n\t}\n\telse{\n\t\tsurface.pos = ray.pos + (ray.direction * t2);\n\t}\n\n\t//vec3 positionLocale = surface.pos;\n\tvec3 positionLocale = vec3(vec4(surface.pos,1.0)*espaceMonde);\n\t\n\tfloat rho = sphere.rayon;\n\tfloat theta = atan(positionLocale.x, positionLocale.z )/(PI/2.0); //compris entre -1 et 1\n\tfloat phi = acos( positionLocale.y / rho )/PI; //compris entre 0 et 1\n\t\n\tsurface.id = SPHERE;\n\tsurface.uv = vec2((theta+1.0)*0.5,phi); \n\tsurface.normale = normalize((surface.pos - sphere.pos)/sphere.rayon);\n\t\n\treturn min(t1,t2);\n}\n\nfloat intersectPlan(const in plan_t plan, const in ray_t ray, const in mapping_t mapping, out surface_t surface)\n{\t\n\tvec3 cosinus = cos(mapping.rotation), sinus = sin(mapping.rotation);\n\tmat3 rotationX = mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cosinus.x,-sinus.z,\n\t\t0.0, sinus.x, cosinus.x\n\t);\n\tmat3 rotationY = mat3(\n\t\tcosinus.y, 0.0,  sinus.y,\n\t\t0.0, 1.0,  0.0,\n\t   -sinus.y, 0.0,  cosinus.y\n\t);\n\tmat3 rotationZ = mat3(\n\t\tcosinus.z,-sinus.z,  0.0,\n\t\tsinus.z, cosinus.z,  0.0,\n\t    0.0, 0.0,  1.0\n\t);\n\t\n\tmat3 rotation = rotationX * rotationY * rotationZ;\n\tvec3 planNormale = normalize( plan.normale ) * rotation;\n\t\n\tvec3 /* normal_by_origin */ no = planNormale * ray.pos;\n\tvec3 /* normal_by_direction */ nd = planNormale * ray.direction;\n\tfloat distance_from_origin = ( - no.x - no.y - no.z - plan.d) / ( nd.x + nd.y + nd.z );\n\t\n\tsurface.pos = ray.pos + ray.direction * distance_from_origin;\n\t\n\tvec3 localPosition = surface.pos * rotation;\n\tsurface.uv = vec2( localPosition.x,-localPosition.z );\n\t\n\tsurface.normale = plan.normale;\n\t\n\tsurface.id = PLANE;\n\treturn distance_from_origin < 0.0 ? max_distance : distance_from_origin;\n}\n\nfloat intersect(const in ray_t ray, out surface_t surface)\n{\n\tconst sphere_t sphere = sphere_t(vec3(0.0,0.0,0.0),1.0);\n\tconst plan_t plan = plan_t(vec3(0.0, 0.1, 0.01),0.1);\n\t\n\tconst mapping_t mappingSphere = mapping_t( vec3( 0.0, 0.0, 0.0 ) );\n\tconst mapping_t mappingPlan  = mapping_t( vec3( PI / 12.0, 0.0, 0.0 ) );\n\t\n\tsurface_t surfaceSphere, surfacePlan;\n\tfloat distance_from_origin_Plan = intersectPlan(plan, ray, mappingPlan,surfacePlan);\n\tfloat distance_from_origin_Sphere = intersectSphere(ray, sphere,surfaceSphere);\n\t\n\tif ((distance_from_origin_Plan < max_distance) && (distance_from_origin_Plan<distance_from_origin_Sphere)){\n\t\t//On se trouve sur le plan\n\t\t\n\t\tsurface = surfacePlan;\n\t\t//surface.uv *= 3.0;\n\t}\n\telse if(distance_from_origin_Sphere < max_distance){\n\t\t//On se trouve sur la sphere\n\t\t\n\t\tsurface = surfaceSphere;\n\t\t//surface.uv * 2.0;\n\t}\n\telse {\n\t\tsurface.id = NONE;\n\t\tsurface.pos = vec3( 0.0 );\n\t\tsurface.uv = vec2( 0.0 );\n\t\tsurface.normale = vec3( 0.0 );\n\t}\n\treturn min(distance_from_origin_Sphere,distance_from_origin_Plan);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coordinate = fragCoord.xy / iResolution.xy;\n\tvec2 coordinate_entered = 2.0 * coordinate - 1.0;\n\t\n\tfloat coeffCorrection = (iResolution.x/iResolution.y);\n\t\n\tray_t camera_ray;\n\tsurface_t surface;\n\t\n\tcamera_ray.pos = vec3(0.0, 0.0, 5.0);\n\tcamera_ray.direction = vec3((coordinate_entered.x * coeffCorrection) , coordinate_entered.y, -1.0);\n\t\n\tfloat distance_from_origin = intersect(camera_ray, surface);\n\n\t\tif (distance_from_origin < max_distance){\n\t\t\tconst vec3 _color = vec3(0.4, 0.1, 0.3);\n\t\t\tfragColor = vec4 (vec3(surface.uv,0.0), 1.0);\n\t\t}\n\t\telse{\n\t\t\tconst vec3 background_color = vec3(0.2, 0.8, 0.3);\n\t\t\tfragColor = vec4 (background_color, 1.0);\n\t\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dB3zt","date":"1392043591","viewed":162,"name":"UV Texturing","username":"MugiwaraLuffy","description":"UV Texturing of the scene","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colors","uv","sphere","plane","texturing"],"hasliked":0,"parentid":"","parentname":""}}