{"ver":"0.1","info":{"id":"7ljGR3","date":"1646874686","viewed":138,"name":"Star Hill","username":"inspirnathan","description":"Star Hill from Super Mario RPG (https://www.youtube.com/watch?v=_6jDv3ho4GM). Happy 26th anniversary, Super Mario RPG!","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["inspirnathan","starhill","mariorpg","supermariorpg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XlsSDX","filepath":"https://soundcloud.com/kcx_87/starhill-super-mario-rpg-cover","previewfilepath":"https://soundcloud.com/kcx_87/starhill-super-mario-rpg-cover","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** Star Hill by inspirnathan (Nathan Vaughn)\n** Inspired By Star Hill from the video game, Super Mario RPG: Legend of the Seven Stars Â©Nintendo, Square Enix\n** Happy 26th Anniversary, Super Mario RPG!\n**\n** Resources:\n** 2D Primitive SDFs: https://iquilezles.org/articles/distfunctions2d\n** 3D Primitive SDFs: https://iquilezles.org/articles/distfunctions\n** Music: https://soundcloud.com/kcx_87/starhill-super-mario-rpg-cover\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float N21(vec2 p) {\n  p = fract(p*vec2(233.34, 851.73));\n  p += dot(p, p+23.45);\n  return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n  float n = N21(p);\n  return vec2(n, N21(p+n));\n}\n\nvec2 opRep(vec2 p, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return q;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  uv *= 8.;\n  uv.x += iTime * 0.1;\n  uv.y += iTime * 0.05;\n  \n  vec2 p = N22(.5 * floor(uv*(50. + iTime * 0.1)));\n  \n  float res = length(opRep(uv - p - vec2(0, -4.9), vec2(1))) - .01;\n  \n  res = smoothstep(0.01, 0., res);\n  col = mix(vec3(0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//-------CONSTANTS--------------------------------------------------------------------\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(0, 0, 0.6);\nconst vec3 COLOR_AMBIENT = vec3(0);\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------STRUCTS----------------------------------------------------------------------\n\nstruct Material {\n  vec3 aCol; // ambient color: k_a * i_a\n  vec3 dCol; // diffuse color: k_d * i_d\n  vec3 sCol; // specular color: k_s * i_s\n  float alp; // specular shininess\n  float fre; // fresnel (higher value results in less rim lighting)\n  bool useFre;\n};\n\nstruct Surface {\n  int id; // identifier\n  float sd; // signed distance value\n  Material mat; // material\n  vec3 pos; // position in 3D space\n};\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------MATERIALS--------------------------------------------------------------------\n\nMaterial matStarHillBlue() {\n  Material mat;\n  mat.aCol = vec3(0, 0, 1) * .4;\n  mat.dCol = vec3(0, 0, 1) * 0.7;\n  mat.sCol = vec3(0);\n  mat.alp = 0.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\nMaterial matFlowerGloss() {\n  Material mat;\n  mat.aCol = vec3(0, 0, 1) * 0.8;\n  mat.dCol = vec3(.773, .988, .392) * 0.25;\n  mat.sCol = vec3(1) * 0.2;\n  mat.alp = 5.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\nMaterial matStarDarkGloss() {\n  Material mat;\n  mat.aCol = vec3(0, 1, 0) * 0.25;\n  mat.dCol = vec3(0, 1, 0) * 0.2;\n  mat.sCol = vec3(1) * 0.2;\n  mat.alp = 5.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\nMaterial matStarBrightGloss() {\n  Material mat;\n  mat.aCol = vec3(.773, .988, .392) * 0.75;\n  mat.dCol = vec3(.773, .988, .392) * 0.5;\n  mat.sCol = vec3(1) * 0.2;\n  mat.alp = 5.;\n  mat.fre = 5.;\n  mat.useFre = true;\n  \n  return mat;\n}\n\nMaterial matStarDoor() {\n  Material mat;\n  mat.aCol = vec3(0.65, 0.9, 0.5) * .2; // * .75; // 0.75 matches the back of the star door; I may use a point light to color the front of the door different from the back of the door\n  mat.dCol = vec3(0.65, 0.9, 0.5) * 1.5;\n  mat.sCol = vec3(1) * 0.5;\n  mat.alp = 1.;\n  mat.fre = 2.;\n  mat.useFre = true;\n  \n  return mat;\n}\n\nMaterial matGold() {\n  Material mat;\n  mat.aCol = vec3(1., 0.55, 0.) * 0.4;\n  mat.dCol = vec3(1., 0.55, 0.) * 0.8;\n  mat.sCol = vec3(1, 1, 1) * 0.6;\n  mat.alp = 5.;\n  mat.fre = 2.;\n  mat.useFre = true;\n  \n  return mat;\n}\n\nMaterial matBlack() {\n  Material mat;\n  mat.aCol = vec3(0, 0, 0);\n  mat.dCol = vec3(0.2);\n  mat.sCol = vec3(0.1);\n  mat.alp = 4.;\n  mat.fre = 0.;\n  mat.useFre = false;\n  \n  return mat;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------OPERATORS--------------------------------------------------------------------\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n  return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n  return mod(p+0.5*c,c)-0.5*c;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----2D PRIMITIVE DISTANCE FUNCTIONS-------------------------------------------------\n\nfloat sdStar5(vec2 p, float r, float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*smax(dot(k1,p),0.0, 0.05)*k1;\n    p -= 2.0*smax(dot(k2,p),0.0, 0.05)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----3D PRIMITIVE DISTANCE FUNCTIONS-------------------------------------------------\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//----EXTRUSIONS----------------------------------------------------------------------\n\nfloat opExtrusionStar( in vec3 p, in float h, float edgeSmoothness )\n{\n    p.x *= 0.9;\n    float s = sdStar5(p.xy, 2., 0.55);\n    vec2 w = vec2( s, abs(p.z) - h );\n    float d = min(max(w.x,w.y),0.) + length(max(w,0.)) - edgeSmoothness;\n    return d;\n}\n\n//------------------------------------------------------------------------------------\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//-------STAR HILL IDs----------------------------------------------------------------\n/*\n\n1. sdAsteroid\n2. Star Door (without keyhole)\n3. Keyhole (outside)\n4. Keyhole (inside)\n5. Wishing Star Body\n6. Wishing Star Face\n7. Wishing Flower Stem\n8. Wishing Flower Star\n\n*/\n//------------------------------------------------------------------------------------\n\n\n//-------STAR POSITIONS---------------------------------------------------------------\n\n// xyz = position, w = id of each star; I use a 0.5 plus an integer to make it easier to check the ID in the getText function\nconst vec4[] STARS = vec4[4](\n    vec4(1., 0.05, -1., 1.5),\n    vec4(-2, 0.05, -2.4, 2.5),\n    vec4(-1, 0.05, -8, 3.5),\n    vec4(1, 0.05, -11, 4.5)\n);\n\n//------------------------------------------------------------------------------------\n\n//-------STAR HILL DISTANCE FUNCTIONS-------------------------------------------------\n\nSurface sdAsteroid(vec3 p) {\n  float scale = 0.5;\n  float bump = 0.04 * texture(iChannel1, p.xy).r;\n  p += bump;\n  p /= scale;\n  p *= rotateX(0.3)*rotateY(-.8)*rotateZ(-1.);\n  float d1 = sdSphere(p, 2.);\n  float d2 = sdCappedCylinder(p - vec3(0, 2, 0), 0.7, 0.1);\n  float d3 = sdCapsule(p, vec3(0, 1.6, 0), vec3(0, 2, 0), 0.5);\n  float d4 = sdCapsule(p, vec3(0, 1., 0), vec3(0, 1.55, 0), 0.5);\n  float d5 = sdCappedCylinder((p - vec3(0, 1, 1.7))*rotateX(2.1), 0.5, 0.1);\n  float d6 = sdCapsule((p - vec3(0, 1, 1.7))*rotateX(2.1), vec3(0, -1, 0), vec3(0, 2, 0), 0.4);\n  float d7 = sdCappedCylinder((p - vec3(1.7, 1, 0))*rotateZ(1.), 0.5, 0.1);\n  float d8 = sdCapsule((p - vec3(1.7, 1, 0))*rotateZ(1.), vec3(0, -1, 0), vec3(0, 2, 0), 0.4);\n  \n  float res = 1e6;\n  \n  // Top crater\n  res = smin(d1, d2, 0.5);\n  res = smax(res, d3, 0.2);\n  res = smin(res, d4, 0.2);\n  \n  // side crater (near center)\n  res = smin(res, d5, 0.5);\n  res = smax(res, d6, 0.1);\n  \n  // side crater (away from center)\n  res = smin(res, d7, 0.5);\n  res = smax(res, d8, 0.2);\n  \n  res = res * scale;\n  return Surface(1, res, matStarHillBlue(), vec3(0));\n}\n\nfloat sdWishingStar(vec3 p) {\n  float d1 = sdSphere(p, 1.);\n  float d2 = sdRoundCone((abs(p) - vec3(0, 1., 0)), 0.5, 0.08, .9);\n  float d3 = sdRoundCone((abs(p) - vec3(0.7, 0.4, 0))*rotateZ(1.), 0.6, 0.08, 1.1);\n  \n  float res = 1e6;\n  \n\n  res = min(res, d1);\n  res = smin(res, d2, 0.4);\n  res = smin(res, d3, 0.4);\n  \n  return res;\n}\n\nfloat sdWishingFlowerStem(vec3 p) {\n  p -= vec3(0, -1, 0);\n  vec3 p1 = p - vec3(0, 0, 0);\n  vec3 p2 = p * vec3(-1, 1, 1);\n  vec3 p3 = p;\n  \n  float angle = 2.5*clamp( sin(1.1*p1.y+0.1)/3.8, 0.0, 1. );\n  float angle2 = -0.5*clamp( sin(1.1*p1.y)/3.8, 0.0, 1. );\n  p1.xy = rotate2d(angle)*p1.xy;  \n  p2.xy = rotate2d(angle)*p2.xy;\n  p3.yz = rotate2d(angle2)*p3.yz;\n\n  float d1 = sdVerticalCapsule(p1 - vec3(0), 2., .1); // curve starts acting strange if offset is not equal to vec3(0) here; change offset before rotation is done up above\n  float d2 = sdVerticalCapsule(p2, 2., .1);\n  float d3 = sdRoundCone(p3 - vec3(0, 0., 0), .15, .1, 1.8);\n  \n  return min(min(d1, d2), d3);\n}\n\nSurface sdWishingFlower(vec3 p, bool isActive) {\n  float scale = 0.3; // scale the whole flower\n  p /= scale;\n  float starScale = 0.4;\n  vec3 p2 = p / starScale;\n  p2 -= isActive ? vec3(0, 4.5, 0) : vec3(0, 2.5, 0);\n  p2 *= isActive ? rotateZ(iTime) : rotateZ(0.5);\n  \n  Material mat;\n  if (isActive) mat = matStarBrightGloss();\n  else mat = matStarDarkGloss();\n  \n  Surface d1 = Surface(7, sdWishingFlowerStem(p), matFlowerGloss(), vec3(0));\n  Surface d2 = Surface(8, sdWishingStar(p2)*starScale, mat, vec3(0));\n  \n  Surface res = opUnion(d1, d2);\n  res.sd *= scale;\n  \n  return res;\n}\n\nfloat sdFace(vec3 p) {\n  float d1 = sdSphere(p*vec3(1.6, 1, 1) - vec3(-0.5, 0.25, 0), 0.15);\n  float d2 = sdSphere(p*vec3(1.6, 1, 1) - vec3(0.5, 0.25, 0), 0.15);\n  float d3 = sdCappedTorus(-p, vec2(0.866025,0.5), 0.5, 0.07);\n\n  float res = 1e6;\n  \n  res = min(res, d1);\n  res = min(res, d2);\n  res = min(res, d3);\n  \n  return res;\n}\n\nSurface sdHappyWishingStar(vec3 p) {\n  float scale = 0.11;\n  p *= rotateX(0.8);\n  p /= scale;\n  float d1 = sdWishingStar(p);\n  float d2 = sdFace(p - vec3(0, 0, 0.9));\n\n  Surface res = opUnion(Surface(5, d1, matStarBrightGloss(), vec3(0)), Surface(6, d2, matBlack(), vec3(0)));\n  res.sd *= scale;\n  \n  return res;\n}\n\nfloat sdKeyholeSmall(vec3 p) {    \n    float thickness = 0.4;\n    float distFromStar = 0.2;\n    float d1 = sdCappedCylinder((p-vec3(0, 0.2, distFromStar))*rotateX(PI/2.), 0.22, thickness);\n    float d2 = sdTriPrism((p-vec3(0, -0.14, distFromStar))*vec3(0.8, 0.4, 1), vec2(0.1, thickness));\n    \n    return min(d1, d2);\n}\n\nfloat sdKeyholeBig(vec3 p) {    \n    float thickness = 0.1;\n    float distFromStar = 0.2;\n    float d1 = sdCappedCylinder((p-vec3(0, 0.2, distFromStar))*rotateX(PI/2.), 0.3, thickness);\n    float d2 = sdTriPrism((p-vec3(0, -0.08, distFromStar))*vec3(1., 0.4, 1), vec2(0.22, thickness));\n    \n    float res = min(d1, d2);\n    return max(res, -sdKeyholeSmall(p));\n}\n\nSurface sdStarDoor(vec3 p) {\n  float extrusionRadius = 0.25*(abs(p.z*2.));\n  float edgeSmoothness = 0.11;\n\n  Surface d1 = Surface(2, opExtrusionStar(p, extrusionRadius, edgeSmoothness), matStarDoor(), vec3(0));\n  Surface d2 = Surface(3, sdKeyholeSmall(p*vec3(1, 1, 2.5)), matBlack(), vec3(0));\n  Surface d3 = Surface(4, sdKeyholeBig(p*vec3(1, 1.1, 1)), matGold(), vec3(0));\n  \n  Surface res = opUnion(d1, d2);\n  res = opUnion(res, d3);\n  \n  return res;\n}\n\n//------------------------------------------------------------------------------------\n\n\n\n//-------DRAW SCENE-------------------------------------------------------------------\n\nSurface scene(vec3 p, vec3 ro) {\n  int arf = 15; // asteroid repeat factor\n\n  vec3 p1 = vec3(0, -1, 0);\n  Surface d1 = sdAsteroid(opRepLim(p - p1, 2.5, vec3(arf, 0, arf)));\n  d1.pos = p1;\n\n  vec3 p2 = vec3(1, -1, 1);\n  Surface d2 = sdAsteroid(opRepLim(p - p2, 2.5, vec3(arf, 0, arf)));\n  d2.pos = p2;\n\n  vec3 p3 = vec3(4.5, 1.0, -4);\n  Surface d3 = sdStarDoor((p - p3) * rotateY(1.4));\n  d3.pos = p3;\n  \n  Surface res = opUnion(d1, d2);\n  res = opUnion(res, d3);\n  \n  vec3 p4 = vec3(0, 0.1, -7);\n  Surface d4 = sdWishingFlower(opRepLim(p - p4, 5.2, vec3(4, 0, 4)), false);\n  d1.pos = p4;\n  res = opUnion(res, d4);\n  \n  vec3 p5 = vec3(-2.6, 0.05, -1.);\n  Surface d5 = sdWishingFlower(p-p5, true);\n  d1.pos = p5;\n  res = opUnion(res, d5);\n  \n  \n  for (int i = 0; i < STARS.length(); i++) {\n    vec3 p5 = STARS[i].xyz;\n    Surface d5 = sdHappyWishingStar(p - p5);\n    d5.pos = p5;\n    res = opUnion(res, d5);\n  }\n  \n  return res;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p, ro);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy, ro).sd +\n      e.yyx * scene(p + e.yyx, ro).sd +\n      e.yxy * scene(p + e.yxy, ro).sd +\n      e.xxx * scene(p + e.xxx, ro).sd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.aCol;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.dCol * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.sCol * pow(dotRV, mat.alp);\n\n  return ambient + diffuse + specular;\n}\n\nfloat fresnel(bool useFresnel, vec3 normal, vec3 rd, float exponent) {\n  return useFresnel ? pow(clamp(1. - dot(normal, -rd), 0., 1.), exponent) : 0.;\n}\n\nvec3 getPointLightStar(vec3 p) {\n  float d = length(p - vec3(5, -3, -4)); // distance\n  float f = 1.0 / (1. + 0.1 * d * d); // formula for light distribution\n  return vec3(0, 1, 0) * f;\n}\n\nvec3 getPointLightFlower(vec3 p, vec3 o) {\n  float d = length(p - o); // distance\n  float f = 1.0 / (1. + 2. * d + 4. * d * d); // formula for light distribution\n  return vec3(0, 1, 0) * f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 COLOR_BACKGROUND = texture(iChannel0, fragCoord/iResolution.xy).rgb + vec3(0, 0, .34);\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 1, 4); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // signed distance value to closest object\n\n  col = COLOR_BACKGROUND; // ray didn't hit anything\n  vec3 p = ro + rd * co.sd; // point discovered from ray marching\n  vec3 normal = calcNormal(p, ro); // surface normal\n\n  // light #1\n  vec3 lightPosition1 = vec3(0, 2, 2);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  float lightIntensity1 = 0.9;\n\n  // final color of object\n  col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat) + fresnel(co.mat.useFre, normal, rd, co.mat.fre);\n  if (co.id != 3 && co.id != 4) col += getPointLightStar(p);\n  \n  col = mix(COLOR_BACKGROUND, col, step(co.sd - MAX_DIST, 0.));\n  \n  vec2 ouv = fragCoord/iResolution.xy; // original UV with range <0,1>\n  \n  vec3 text = vec3(0);\n\n  col = mix(col, text, text);\n  \n\n  fragColor = vec4(col, 1.0);\n}\n\n//------------------------------------------------------------------------------------","name":"Buffer B","description":"","type":"buffer"}]}