{"ver":"0.1","info":{"id":"llsyDB","date":"1506323682","viewed":181,"name":"Torus (cloned) - Twin Shade A","username":"tgsstdio","description":"Majority of code from https://www.shadertoy.com/view/ll33Wn\n\nUsing code from\nTwin Shade - A - https://www.shadertoy.com/view/MtsyWB\nTwin Shade torus (cloned) - https://www.shadertoy.com/view/lllyDB","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dithering","toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//USE ANY SHADE CUTOFF VALUES YOU LIKE. Should be object specific\n\n#define LIGHT_SHADE_CUTOFF 0.33\n#define DARK_SHADE_CUTOFF 0.15\nconst vec3 TORUS_COLOR = vec3(1.0, 0.5, 0.1);\n#define SHADES 4.0\n\n/// FORK of https://www.shadertoy.com/view/ll33Wn (95% of code is from here)\n/// MY CHANGES due to diffuse toon shading\n\n#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.1\n#define EDGE_THICKNESS 0.015\n\nfloat TorusSDF(vec3 samplePoint, vec2 dimensions)\n{\n\treturn length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;\n}\n\nfloat SceneSDF(vec3 samplePoint)\n{\n    return TorusSDF(samplePoint, vec2(1.3, 0.45));\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\n// NEW CODE HERE (START)\nfloat lightA1[8] = float[8](\n    float(189),\n    float(216),\n    float(253),\n    float(253),\n    float(253),\n    float(216),\n    float(189), \n    float(21)    \n);\n    \nvec4 lightColorA1(vec2 fragCoord)\n{        \n    ivec2 gridPos = ivec2(fragCoord) % 8;         \n\n    float factor = lightA1[(gridPos.x + (7 - gridPos.y)) % 8]/255.;\n\n    return vec4(vec3(factor), 1.);\n}\n\nconst mat4 darkA1 = mat4(\n    21,189,253,253,\n    189,21,189,253,\n    253,189,21,189,\n    253,253,189,21\n)/255.;\n    \nvec4 darkColorA1(vec2 fragCoord)\n{        \n    ivec2 gridPos = ivec2(fragCoord) % 4;       \n    ivec2 mirrorPos = ivec2(fragCoord) % 8;   \n    \n    bvec2 mirror = lessThan(mirrorPos, ivec2(4));   \n    int xCoords = (mirror.x)\n        ? (7 - mirrorPos.x) % 4\n        : gridPos.x;\n    \n    int yCoords = (mirror.y)\n        ? (7 - mirrorPos.y) % 4\n        : gridPos.y;    \n    \n\tfloat factor = darkA1[xCoords][yCoords];  \n    return vec4(vec3(factor), 1.);\n}\n   \n\nvec3 ComputeLighting(vec3 point, vec2 fragCoord, vec3 lightDir, vec3 lightColor)\n{\n    vec3 color = vec3(AMBIENT);\n    float diffuse = dot(EstimateNormal(point), normalize(lightDir));\n    float colorIntensity = ceil(diffuse * SHADES) / SHADES;\n    colorIntensity = max(colorIntensity, AMBIENT);    \n   \n    if (diffuse >= LIGHT_SHADE_CUTOFF)        \n    \tcolor = lightColor * colorIntensity;\n    else if (diffuse >= DARK_SHADE_CUTOFF) \n        color = colorIntensity * (lightColor * lightColorA1(fragCoord).xyz);\n    else\n        color = colorIntensity * (lightColor * darkColorA1(fragCoord).xyz);\n    return color;\n}\n\n// NEW CODE HERE (END)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.6);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n    \n    vec3 color = ComputeLighting(hitPoint, fragCoord, lightDir, TORUS_COLOR);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}