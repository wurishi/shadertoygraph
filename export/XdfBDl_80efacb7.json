{"ver":"0.1","info":{"id":"XdfBDl","date":"1498688663","viewed":298,"name":"Railord","username":"pi","description":"An infinite roller coaster with a superconductor on it. More of a vomit dispenser than a roller coaster.","likes":11,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarch","raytrace","rollercoaster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsXSRf","filepath":"https://soundcloud.com/dj-meizong/radiation-original-mix","previewfilepath":"https://soundcloud.com/dj-meizong/radiation-original-mix","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n    float speed = 12.;\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n             );\n}\nmat3 lookat(vec3 o, vec3 t) {\n\tvec3 dir = normalize(t-o);\n    float yAxis = atan(dir.x,dir.z);\n    float xAxis = -asin(dir.y);\n    return rotate(vec3(1,0,0),xAxis)*rotate(vec3(0,1,0),yAxis);\n}\nvec3 path (float m) {\n    float t = m/10.;\n    vec2 core = vec2(noise(vec2(t/5.,t/3.))*2.,noise(vec2(t,t/3.)));\n\treturn vec3(core*4.,m);    \n}float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat rail(vec3 o) {\n\tfloat nL = length(o.xy-vec2(1,-1.2)-path(o.z).xy)-.2;\n    float nR = length(o.xy+vec2(1,1.2)-path(o.z).xy)-.2;\n    float mD =length(o.xy+vec2(asin(sin(o.z))/3.14*1.8,1.2)-path(o.z).xy)-.1;\n    return smin(mD,min(nL,nR),.1);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat cart(vec3 o) {\n    \n    o.y/=2.6;\n    o/=1.3;\n    float f = sdBox(o,vec3(o.y+1.5,.3,o.y+1.5)/3.);\n    return f;\n}\nvec2 map(vec3 pos) {\n\tfloat n = 0.;\n    \n    n=rail(pos);//length(pos)-1.;\n    \n    \tvec3 c = path(iTime*speed+3.);\n        vec3 v = pos-c;\n        v*=inverse(lookat(c,path(iTime*speed+3.+.1)));\n        float q = cart(v);    \n    \tn=min(q,n);\n    return vec2(n,n==q?1.:0.);\n}\nvec3 normal( in vec3 x)\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,\n                            map(x+e.yxy).x - map(x-e.yxy).x,\n                            map(x+e.yyx).x - map(x-e.yyx).x ) );\n}\nfloat FAR = 85.;\nfloat trace(vec3 o, vec3 d){\n\tfloat t=0.,q;\n    for (int i = 0;i < 160; i++) {\n    \tif((q=map(o+d*t).x)<.01||t>FAR) break;\n        t+=q*.9;    \n    }\n    return t;\n}\nfloat raycast_terrain(vec3 o, vec3 d) {\n    return (1.2+o.y)/-d.y;\n}\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 ground(vec2 u) {\n    float k = 0.;\n    k=(sign(sin(u.x*3.14))+sign(sin(u.y*3.14)));\n    float jt =  ((sin(u.x*3.14))+(sin(u.y*3.14)));\n    vec3 i = vec3(.2,.1,0)*pow(abs(1.-clamp(jt, 0., 1.)), 10.);\n    i+=abs(jt)/2.;\n    return i;\n}\nvec3 bGround(vec2 u) {\n    return ground(u);\n}\nvec3 pMarch(vec3 ro, vec3 rd)  {\n    float tr = raycast_terrain(ro,rd);\n    vec3 hit = ro+rd*tr;\n    if(tr<0.)\n        return vec3(0);\n    vec3 tex = bGround(hit.xz);\n    return tex;\n}\nconst float e= 2.71828;\nfloat fogDens = .05;\nvec3 sky(vec3 rd) {\n\treturn abs(rd).yxy;\n}\nvoid render(vec3 od, vec3 rd, out vec3 color) {\n    vec3 ro = path(iTime*speed)+vec3(0,1.25,0)+od;\n    color=vec3(0);\n    rd*=lookat(ro,path(iTime*speed+.1)+vec3(0,1.25,0));\n    float dist = trace(ro, rd);\n    float terr = raycast_terrain(ro,rd);\n    float dv = dist;\n    if(terr>0.&&terr<dist&&terr<FAR) {\n        dv=terr;\n        vec3 hit = ro+rd*terr;\n        color = ground(hit.xz);\n        float shd = (trace(hit,vec3(0,1,0)));\n        if(map(hit+vec3(0,1,0)*shd).x<.02)\n            color-=1./vec3(shd);\n    } else {\n        vec3 hit = ro+rd*dist;\n        float mit = map(hit).x;\n\n        if (mit<.01) {\n            vec3 n = normal(hit);\n            vec3 qit = hit;\n            if(map(hit).y>0.) {\n            \t\n            color = tex3D(iChannel2, (lookat(path(iTime*speed+3.),path(iTime*speed+3.+.1)))*(qit-path(iTime*speed+3.)), n);\n            color *= max(n.y,0.4);\n            }\n            else{\n            color = tex3D(iChannel0, qit/10., n).ggg;\n            color *= max(n.y,0.0);\n            vec3 pbr = pMarch(hit, n);\n            color+=pbr/5.;\n            }\n        }\n    }\n    color=mix(color,sky(rd),clamp(1./e*dv*fogDens,0.,1.));\n}\nvoid mainImage( out vec4 f, vec2 p )\n{\n    vec2 R = iResolution.xy, uv = (2.*p-R)/R.y;\n    vec3 od = vec3(0);\n    render(od,normalize(vec3(uv,1.6)), od);\n    f=vec4(od*min(1.,iTime),1)*(1.-length(uv)/2.3);\n}","name":"Image","description":"","type":"image"}]}