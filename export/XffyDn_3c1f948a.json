{"ver":"0.1","info":{"id":"XffyDn","date":"1726427948","viewed":27,"name":"Stochastic UV Tiling","username":"homamo","description":"Stochastic approach for making textures tileable using single texture sampler. Works best with abstract textures.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["uvs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ALMOST_ZERO 0.0001\n\nfloat ChangeRange(float x, float oldmin, float oldmax, float newmin, float newmax)\n{\n    float w = oldmax - oldmin;\n    return (abs(w) <= ALMOST_ZERO) ? ALMOST_ZERO : newmin + ((newmax - newmin) * ((x - oldmin) / w));\n}\n\nvec2 GetGradient(vec2 intPos, float t)\n{\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n       \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n// Fast pseudo-3d Perlin noise\n// https://www.shadertoy.com/view/MtcGRl\nfloat Pseudo3dNoise(vec3 pos)\n{\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\nfloat PerlinNoise(vec2 coords, float diffusion, float grain_size, float mix_ratio)\n{\n    diffusion = clamp(diffusion, ALMOST_ZERO, 1.0);\n    grain_size = clamp(grain_size, ALMOST_ZERO, 100.0);\n    coords /= grain_size;\n    float noiseVal = 0.5 + 0.5 * Pseudo3dNoise(vec3(coords * 10.0, 0.0));\n    float noiseUser = noiseVal - mix_ratio;\n    return noiseUser = noiseUser>0.0 ? 0.5 - 0.5* (exp(-noiseUser/diffusion) - 1.0) : 0.5 * exp(noiseUser/diffusion);\n}\n\nfloat TileDomain(vec2 noise_coords, float domain, float overlap, float scale, float diffusion)\n{\n    domain = fract(domain);\n    float mix_noise_large = ChangeRange(domain, 0.5 - overlap * 0.25, 0.5 + overlap * 0.25, 0.0, 1.0);\n    float mix_noise_small = PerlinNoise(noise_coords, diffusion, scale, mix_noise_large);\n    float mix_noise = PerlinNoise(noise_coords, 0.0, 0.005, mix_noise_small);\n    float domain_a = ChangeRange(domain, 0.0, overlap * 0.5 + 0.5, 0.5, 1.0);\n    float domain_b = ChangeRange(domain, 0.5 - overlap * 0.5, 1.0, 0.0, 0.5);\n    return mix(domain_a, domain_b, mix_noise);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 2.; // Repeates\n    vec2 uv_tiled = vec2(TileDomain(uv, uv.x, 0.3, 0.6, 0.9), TileDomain(uv, uv.y, 0.1, 0.6, 0.9));\n    \n    // Mouse: toggle tillable texture\n    if (iMouse.z <= 0.0)\n    {\n        // To do: use gradient to sample properly with mips\n        fragColor = textureGrad(iChannel0, uv_tiled, dFdx(uv), dFdy(uv) );\n        //fragColor = texture(iChannel0, uv_tiled );\n    }\n    else\n    {\n        fragColor = texture( iChannel0, uv + .5 );\n    }\n}","name":"Image","description":"","type":"image"}]}