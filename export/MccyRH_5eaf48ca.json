{"ver":"0.1","info":{"id":"MccyRH","date":"1731592446","viewed":151,"name":"Voronoi Tracking Cell Colonies","username":"Ebanflo","description":"Now respecting Newtonian physics! Mouse enabled!\nI found it much more difficult to optimize the physics using the Voronoi buffer.","likes":12,"published":3,"flags":32,"usePreview":1,"tags":["2d","simulation","particles","life","multipass"],"hasliked":0,"parentid":"lfXBW8","parentname":"Newtonian Cell-Forming Particles"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n// Copyright © 2024 Eben Kadile\n\n/*\nThe basic idea is that particles are attracted or\nrepelled from other particle types at different ranges\nvia a super simple scattering physics defined in Buffer A.\n*/\n\n\n#define VORONOI_RENDER\n\nconst mat4x4 palette = mat4x4(0.3, 0.7, 0.2, 1.0,\n                              0.0, 0.7, 0.5, 1.0,\n                              0.4, 0.2, 0.9, 1.0,\n                              0.8, 0.2, 0.5, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float dist = 1e6;\n    int atom_id = 0;\n\n    #ifdef VORONOI_RENDER\n    vec4 voronoi_tracker = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    for(int i = 0; i < 4; i++) {\n        int i_atom_id = int(voronoi_tracker[i]);\n        vec4 atom = get_atom(iChannel0, i_atom_id);\n        vec2 offs = fragCoord - atom.xy*iResolution.y;\n        float dsqr = dot(offs, offs);\n        if(dsqr < dist) {\n            dist = dsqr;\n            atom_id = i_atom_id;\n        }\n    }\n    #else\n    for(int i = 0; i < TOT_ATOMS; i++) {\n        vec4 atom = get_atom(iChannel0, i);\n    \tvec2 offs = fragCoord - atom.xy*iResolution.y;\n        float dsqr = dot(offs, offs);\n\n        if(dsqr < dist) {\n            dist = dsqr;\n            atom_id = i;\n        }\n    }\n    #endif\n    int atom_type = get_atom_type(atom_id);\n    fragColor = palette[atom_type] * smoothstep(2.0, 1.5, sqrt(dist));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n// Copyright © 2024 Eben Kadile\n\n#define PI 4.0*atan(1.0)\n#define ASPECT iResolution.xy/iResolution.y\n#define MOUSE iMouse.xy/iResolution.y\n#define MOUSE_RADIUS 0.3\n\n#define CELL_CHAIN_PARAMS\n//#define EXPERIMENTAL_PARAMS\n\n#ifdef CELL_CHAIN_PARAMS\n#define N_ATOMS_0 1024\n#define N_ATOMS_1 1024\n#define N_ATOMS_2 1024\n#define N_ATOMS_3 1024\n#define TOT_ATOMS N_ATOMS_0 + N_ATOMS_1 + N_ATOMS_2 + N_ATOMS_3\n\nconst float max_init_speed = 1e-5;\nconst float max_speed = 3e-3;\n\n// green, cyan, violet, magenta\n// radius at which forces switch from attractive to repulsive\nconst mat4x4 close = mat4x4(0.05, 0.1, 0.05, 0.1,\n                            0.1, 0.1, 0.1, 0.2,\n                            0.05, 0.1, 0.05, 0.2,\n                            0.1, 0.2, 0.2, 0.1);\nconst mat4x4 attraction = -mat4x4(0.3, 0.3, 0.1, 0.03,\n                                  0.3, 1, 0.3, 0.1,\n                                  0.1, 0.3, 0.3, 0.03,\n                                  0.03, 0.1, 0.03, 0.1);\nconst mat4x4 repulsion = mat4x4(1, 3, 1, 3,\n                                3, 1, 1, 3,\n                                1, 1, 1, 1,\n                                3, 3, 1, 1);\nconst mat4x4 range = mat4x4(0.1, 0.2, 0.1, 0.2,\n                            0.2, 0.2, 0.2, 0.4,\n                            0.1, 0.2, 0.1, 0.4,\n                            0.2, 0.4, 0.4, 0.2);\nconst vec4 masses = vec4(1e3, 1e3, 1e3, 1e3);\n#endif\n\n#ifdef EXPERIMENTAL_PARAMS\n#define N_ATOMS_0 4096\n#define N_ATOMS_1 4096\n#define N_ATOMS_2 4096\n#define N_ATOMS_3 4096\n#define TOT_ATOMS N_ATOMS_0 + N_ATOMS_1 + N_ATOMS_2 + N_ATOMS_3\n\nconst float max_init_speed = 1e-5;\nconst float max_speed = 3e-3;\n\n// green, cyan, violet, magenta\n// radius at which forces switch from attractive to repulsive\nconst mat4x4 close = mat4x4(0.005, 0.01, 0.005, 0.01,\n                            0.01, 0.01, 0.01, 0.02,\n                            0.005, 0.01, 0.005, 0.02,\n                            0.01, 0.02, 0.02, 0.01);\nconst mat4x4 attraction = -mat4x4(1, 1, 0.3, 0.1,\n                                  1, 3, 1, 0.3,\n                                  0.3, 0.3, 1, 0.1,\n                                  0.1, 0.3, 0.1, 0.3);\nconst mat4x4 repulsion = mat4x4(3, 10, 3, 10,\n                                10, 3, 3, 10,\n                                3, 3, 3, 3,\n                                10, 10, 3, 3);\nconst mat4x4 range = mat4x4(0.01, 0.02, 0.01, 0.02,\n                            0.02, 0.02, 0.02, 0.04,\n                            0.01, 0.02, 0.01, 0.04,\n                            0.02, 0.04, 0.04, 0.02);\nconst vec4 masses = vec4(1e3, 1e3, 1e3, 1e3);\n\n#endif\n\nint get_atom_type(int i) {\n    return 3 - int(i < N_ATOMS_0)\n             - int(i < N_ATOMS_0 + N_ATOMS_1)\n             - int(i < N_ATOMS_0 + N_ATOMS_1 + N_ATOMS_2);\n}\n\nfloat potential(int t1, int t2, float d2) {\n    float d = sqrt(d2);\n    float close_potential = mix(repulsion[t1][t2], attraction[t1][t2], d/close[t1][t2])\n                          * step(0.0, close[t1][t2] - d);\n    float far_potential = attraction[t1][t2]\n                        * (1.0 - (d - close[t1][t2])/(range[t1][t2] - close[t1][t2]))\n                        * step(0.0, range[t1][t2] - d)*step(0.0, d - range[t2][t1]);\n    return close_potential + far_potential;\n}\n\nvec4 get_atom(sampler2D buf, int id) {\n    ivec2 res = textureSize(buf, 0);\n\tivec2 uv = ivec2(\n        (id/4)%res.x,\n        id%4 + 4*((id/4)/res.x)\n    );\n\n    return texelFetch(buf, uv, 0);\n}\n\n\nvec2 perp(vec2 v) {\n    return vec2(-v.y,v.x);\n}\n\nvec2 wrap(vec2 v, vec2 size) {\n\treturn mod(v + size/2.0, size) - size/2.0;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 expi(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 rotate(vec2 x, float t) {\n    return cmul(x, expi(t));\n}\n\n\n// Dave Hoskin's hash\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n// Copyright © 2024 Eben Kadile\n\n//#define VORONOI_SIMULATE\n#define CLOSE_VORONOI_SAMPLING_WIDTH 3\n#define FAR_VORONOI_SAMPLING_WIDTH 3\n#define N_SAMPLES 196\n\nivec2 id_to_neighbor(int id) {\n    // shenanigans to try to get both super-near and super far particles\n    // so far not working well\n    /*\n    if(id < 9) {\n        return CLOSE_VORONOI_SAMPLING_WIDTH*(ivec2(id%3, id/3) - 1);\n    } else {\n        id -= 9;\n        if(id < 5) {\n            return FAR_VORONOI_SAMPLING_WIDTH*ivec2(id - 2, 2);\n        } else if(id < 6) {\n            id -= 5;\n            return FAR_VORONOI_SAMPLING_WIDTH*ivec2(2*(id%2) - 1, id/2 - 1);\n        } else {\n            id -= 11;\n            return FAR_VORONOI_SAMPLING_WIDTH*ivec2(id - 2, -2);\n        }\n    }\n    */\n    return FAR_VORONOI_SAMPLING_WIDTH*(ivec2(id%7, id/7) - 3);\n}\n\nint voronoi_get_atom_id(int i, vec2 cur_atom_xy) {\n    int fst_neighbor_id = i%49;\n    int snd_neighbor_id = i/49;\n    ivec2 fst_neighbor = id_to_neighbor(fst_neighbor_id);\n\n    ivec2 cur_atom_icoords = ivec2(iResolution.y*cur_atom_xy);\n\n    int fst_atom_id = int(texelFetch(iChannel2, cur_atom_icoords + fst_neighbor, 0)[snd_neighbor_id]);\n\n    return fst_atom_id;\n}\n\nfloat atom_is_new(inout int visited_atoms[N_SAMPLES], int new_atom) {\n    for(int i = 0; i < N_SAMPLES; i++) {\n        if(visited_atoms[i] < 0) {\n            visited_atoms[i] = new_atom;\n            return 1.0;\n        } else if(visited_atoms[i] == new_atom) {\n            return 0.0;\n        }\n    }\n    return 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    ivec2 pixel = ivec2(fragCoord.xy);\n    int pixel_id = pixel.y%4 + 4*pixel.x + 4*int(iResolution.x)*(pixel.y/4);\n    vec4 pixel_atom = get_atom(iChannel0, pixel_id);\n    int pixel_type = get_atom_type(pixel_id);\n    vec2 pixel_velocity = pixel_atom.zw;\n\n    if(pixel_id < TOT_ATOMS) {\n        if(iFrame < 30) {\n            vec4 rnd = get_atom(iChannel1, pixel_id);\n            \n            #ifdef LOW_ENTROPY_INIT\n            pixel_atom.xy = vec2(0.2 + 0.7*float(pixel_id%3), 0.2 + 0.3*float(pixel_id%3));\n            pixel_atom.xy += 0.3*rnd.xy - 0.1;\n            #else\n            pixel_atom.xy = rnd.xy*ASPECT;\n            #endif\n\n            pixel_velocity = 2.0*max_init_speed*(rnd.zw - 0.5);\n        } else if(iMouse.z < 1e-4 || distance(pixel_atom.xy, MOUSE) > MOUSE_RADIUS) {\n            vec2 force = vec2(0);\n            \n            #ifdef VORONOI_SIMULATE\n            // any better way to not double count particles in GLSL??\n            int[N_SAMPLES] visited_atoms;\n            for(int i = 0; i < N_SAMPLES; i++) visited_atoms[i] = -1;\n            for(int i = 0; i < N_SAMPLES; i++) {\n                int i_atom_id = voronoi_get_atom_id(i, pixel_atom.xy);\n                vec4 i_atom = get_atom(iChannel0, i_atom_id);\n                int i_type = get_atom_type(i_atom_id);\n                float factor = float(i_atom_id != pixel_id)*atom_is_new(visited_atoms, i_atom_id);\n            #else\n            for(int i = 0; i < TOT_ATOMS; i++) {\n                vec4 i_atom = get_atom(iChannel0, i);\n                int i_type = get_atom_type(i);\n                float factor = float(i != pixel_id);\n            #endif\n                \n                vec2 dir = pixel_atom.xy - i_atom.xy;\n                dir = wrap(dir, ASPECT);\n                float d2 = dot(dir, dir);\n\n                force += factor*potential(pixel_type, i_type, d2)*dir;\n            }\n            pixel_velocity += force/masses[pixel_type];\n            \n            float pixel_speed = length(pixel_velocity);\n            pixel_velocity *= pixel_speed < max_speed ? 1.0 : max_speed/pixel_speed;\n        }\n        pixel_atom.zw = pixel_velocity;\n        pixel_atom.xy += pixel_velocity;\n        pixel_atom.xy = mod(pixel_atom.xy, ASPECT);\n        fragColor = pixel_atom;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// === Voronoï buffer: manage tracking of particles Ids\n// This is Fabrice's code\n// https://www.shadertoy.com/view/wtyGWc\n// Except more verbose because I am bad at understanding lots of macros\n\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 icoords = ivec2(fragCoord);\n    vec4  i = vec4(0),\n         i0 = texelFetch(iChannel1, icoords, 0),\n         ia = texelFetch(iChannel1, icoords + ivec2(0, 1), 0),\n         ib = texelFetch(iChannel1, icoords + ivec2(1, 0), 0),\n         ic = texelFetch(iChannel1, icoords + ivec2(0, -1), 0),\n         id = texelFetch(iChannel1, icoords + ivec2(-1, 0), 0);\n         \n    vec4 d = vec4(1e9);\n    for(int k = 0; k < 4; k++) {\n        float this_i = i0[k];\n        vec2 atom = get_atom(iChannel0, int(this_i)).xy;\n        vec2 dir = atom - fragCoord/iResolution.y;\n        dir = wrap(dir, ASPECT);\n        list_insert(i, d, this_i, dot(dir, dir));\n        \n        this_i = ia[k];\n        atom = get_atom(iChannel0, int(this_i)).xy;\n        dir = atom - fragCoord/iResolution.y;\n        dir = wrap(dir, ASPECT);\n        list_insert(i, d, this_i, dot(dir, dir));\n        \n        this_i = ib[k];\n        atom = get_atom(iChannel0, int(this_i)).xy;\n        dir = atom - fragCoord/iResolution.y;\n        dir = wrap(dir, ASPECT);\n        list_insert(i, d, this_i, dot(dir, dir));\n        \n        this_i = ic[k];\n        atom = get_atom(iChannel0, int(this_i)).xy;\n        dir = atom - fragCoord/iResolution.y;\n        dir = wrap(dir, ASPECT);\n        list_insert(i, d, this_i, dot(dir, dir));\n        \n        this_i = id[k];\n        atom = get_atom(iChannel0, int(this_i)).xy;\n        dir = atom - fragCoord/iResolution.y;\n        dir = wrap(dir, ASPECT);\n        list_insert(i, d, this_i, dot(dir, dir));\n    }\n    \n    // randomly inject particles into the buffer\n    // important for the buffer converging to a correct state\n    // and also preventing too-fast particles from escaping tracking\n    for(int k = 0; k < 64; k++) {\n        int i_ = int(float(TOT_ATOMS)*hash13(vec3(fragCoord + float(k) + float(iFrame), 153*k + 90*iFrame)));\n        vec2 atom = get_atom(iChannel0, int(i_)).xy;\n        vec2 dir = atom - fragCoord/iResolution.y;\n        dir = wrap(dir, ASPECT);\n        list_insert(i, d, float(i_), dot(dir, dir));\n    }\n\n    fragColor = i;\n\n}","name":"Buffer B","description":"","type":"buffer"}]}