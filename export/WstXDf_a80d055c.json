{"ver":"0.1","info":{"id":"WstXDf","date":"1573060569","viewed":42,"name":"4D-BristorBrot, serial view","username":"dougfractal","description":"BristorBrot  formula using a time to vary parallel view","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractals","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//lens flares\n\nfloat lodFlares;\n\nvec3 ghostFlare(vec2 uv, float scale){\n    uv /= scale;\n    float threshold = .75;\n    return vec3(max(texture(iChannel0, uv*0.95+.5, lodFlares).r - threshold, 0.0),\n                max(texture(iChannel0, uv*1.00+.5, lodFlares).g - threshold, 0.0),\n                max(texture(iChannel0, uv*1.05+.5, lodFlares).b - threshold, 0.0));\n}\n\nvec3 haloFlare(vec2 uv, float scale){\n    float weight = 1.0-smoothstep(0.0, .05, abs(.5-length(uv)));\n    uv -= scale*normalize(uv);\n    float threshold = .6;\n    return weight * max(texture(iChannel0, vec2(.5) + uv*1.00, lodFlares).rgb - threshold, vec3(0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    lodFlares = log2(iResolution.y*.15);\n    float lodLargeBloom = log2(iResolution.y*.15);\n    float lodSmallBloom = log2(iResolution.y*.05);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    vec3 bloom = max(texture(iChannel0, uv, lodLargeBloom).rgb - .3, vec3(0.0))*.65\n               + max(texture(iChannel0, uv, lodSmallBloom).rgb - .6, vec3(0.0))*.3;\n    \n    uv -= .5;\n    vec2 radialUV = vec2(atan(uv.x, uv.y), 0.5);\n    float flareStrength = texture(iChannel1, radialUV).r * texture(iChannel1, uv).r;\n    \n    float l = length(uv);\n    vec3 flareTint = 4.0*flareStrength * (vec3(sin(l*20.0), cos(l*10.0+2.0), sin(l*15.0))*.3+.5);\n    \n    vec3 lensFlare = flareTint * (ghostFlare(uv, -.75) + haloFlare(uv, -.5));\n    \n    fragColor.rgb += lensFlare + bloom;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// original idea https://www.shadertoy.com/view/wd33zl by loicvdb\n//   changed Mandelbulb fractal to Julia-BristorBrot (ABS variant) \n\n#define Epsilon .00197192\n#define RenderDistance 6.0\n#define IoR .515\n#define GlassColor vec3(1.0, .9, .6)\n\nfloat Power = 2.0;//8.0;\n\nvec3 CamPos = vec3(0, .9, -4.5);\nvec3 CamRot = vec3(.15, .1, .0);\nfloat CamFocalLength = 2.0;\n\nfloat distanceEstimation(vec3 pos3d) {  \n    \n   \tfloat time = cos(float(-iFrame)*.005)*1.2;\n   \n   bool drawparellel=false;\n    \n\n                        float cs = cos(float(iFrame)*.01);\n                        float sn = sin(float(iFrame)*.01);\n    \n  vec4 pos =  (drawparellel) ?  vec4(pos3d.x,  sn*pos3d.y,   cs*pos3d.y, pos3d.z  ) : vec4(vec3(pos3d), time);\n\t\t\t\t\t\t\n   \n    \n    float r = length(pos);\n    if(r > 4.0) return r-1.2;\n    \n    vec4 z = pos;\n    //float time = cos(iTime*0.1);\n  \n  //  vec3 julia = vec3(-.833,.23432,.01);\n  //  julia.x -=time*.325;\n  //  julia.y -=time*.1;\n   // pos = julia;   //  comment out to  disable juila mode\n    \n    \n    \n    \n    \n    \n    \n  // z.w = time*.1;\n    \n    vec4 z1;\n    float sign= 1.0;\n    \n\tfloat dr = 1.0, theta, phi;\n\tfor (int i = 0; i < 100; i++) {\n\t\tr = length(z);\n\t\tif (r>2.5) break;\n        \n        // Bristorbrot (abs) formula\n        //sign = (z.x<.0)? sign :-sign;\n        z1.x = z.x*z.x - z.y*z.y - z.z*z.z - z.w*z.w;\n     //  z1.y = z.y*(2.0*z.x - abs(z.z)*sign);    \n      // z1.z = z.z*(2.0*z.x + abs(z.y)*sign);\n        // original bristorbrot 3D formula\n       // z1.y = z.y*(2.0*z.x - (z.z));    \n       // z1.z = z.z*(2.0*z.x + (z.y));\n        \n        //  original bristorbrot 4D formula\n       // z1.y = z.y*(2.0*z.x - (z.z));    \n       // z1.z = z.z*(2.0*z.x + (z.y));\n        \n        z1.y = z.y*(2.0*z.x - z.z - z.w);    \n        z1.z = z.z*(2.0*z.x + z.y - z.w);\n\t\tz1.w = z.w*(2.0*z.x + z.y + z.z);       \n      \n        \n        \n        \n        \n        z = z1+pos;\n       // w= w1 + wc\n        dr = 2.0*r * dr +1.0;\n        \n        // Mandelbulb formula\n\t\t//theta = acos(z.y/r);\n\t\t//phi = atan(z.z,z.x);\n\t\t//dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        \n\t\t//theta *= Power;z\n\t\t//phi *= Power;\n\t\t//z = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\nvec3 normalEstimation(vec3 pos){\n   \n  vec3 xDir = vec3(Epsilon, 0.0, 0.0);\n  vec3 yDir = vec3(0.0, Epsilon, 0.0);\n  vec3 zDir = vec3(0.0, 0.0, Epsilon);\n\n  float normalX = distanceEstimation(pos + xDir)\n                - distanceEstimation(pos - xDir);\n  float normalY = distanceEstimation(pos + yDir)\n                - distanceEstimation(pos - yDir);\n  float normalZ = distanceEstimation(pos + zDir)\n                - distanceEstimation(pos - zDir);\n\n  return normalize(vec3(normalX, normalY, normalZ));\n}\n\nvec3 background(vec3 dir){\n    if(dot(dir, normalize(vec3(-.5, .2, 1)))>.995) return vec3(5.0);\n    return texture(iChannel0, dir).rgb*1.5;\n}\n\nfloat fresnel(vec3 dir, vec3 normal) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0, etat = IoR;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n  if (sint >= 1.0) return 1.0;\n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nbool hit(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < 500; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon) break;\n        if(dist > RenderDistance) return false;\n        pos += dist*dir;\n    }\n    for(int i = 0; i < 4; i++){\n        float dist = distanceEstimation(pos)-Epsilon;\n        pos += dist*dir;\n    }\n    normal = normalEstimation(pos);\n    return true;\n}\n\nvec3 reflectCol(vec3 dir, vec3 normal){\n\treturn background(reflect(dir, normal));\n}\n\nvec3 refractCol(vec3 dir, vec3 normal){\n    return GlassColor * vec3(background(refract(dir, normal, 0.90/IoR)).r,\n                             background(refract(dir, normal, 1.00/IoR)).g,\n                             background(refract(dir, normal, 1.10/IoR)).b);\n}\n\nvec3 glassCol(vec3 dir, vec3 normal){\n    float fres = fresnel(dir, normal)*.55;\n    return (1.0-fres)*refractCol(dir, normal) + fres*reflectCol(dir, normal);\n}\n\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    vec3 normal;\n    if(hit(pos, dir, normal)){\n        return vec4(max(glassCol(dir, normal), vec3(0)), length(pos-CamPos));\n    }\n   \treturn vec4(background(dir), RenderDistance);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //float time = iTime;\n    float time = float(-iFrame)*.01;\n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    \n    CamRot.y += time/20.0;\n    CamPos *= rotationMatrix(vec3(0, time/20.0, 0));\n    \n    if( iMouse.z > 0.0 )\n        CamRot.y += (iMouse.x/iResolution.x-.5)*.75;\n    \n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n    \n    fragColor = colorAndDepth(CamPos, rayDir);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define GoldenAngle 2.39996323\n\n#define Aperture .00613696\n#define DoFClamping 0.7306\n//change the sample count to 256 or more if you see some dots in the DoF\n#define DoFSamples 256 \n\n\nfloat FocalDistance = 2.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float time = iTime;\n    \n    \n    if( iMouse.z > 0.0 )\n        FocalDistance *= 1.0 + (iMouse.y/iResolution.y-.5)*.65;\n    else\n        FocalDistance *= 1.0 + sin(pow(abs(sin(time/4.0)), 70.0) * 6.0) *.25;\n    \n    vec3 col = vec3(0);\n    float samples = 0.0, r, phi, dr, influence;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        r = sqrt(float(i) / float(DoFSamples))*DoFClamping;\n        phi = GoldenAngle * float(i);\n        d = r * vec2(cos(phi), sin(phi));\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(atan(abs(p.a-FocalDistance), p.a), DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p.rgb;\n        samples += influence;\n    }\n    col /= samples;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}