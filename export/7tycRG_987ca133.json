{"ver":"0.1","info":{"id":"7tycRG","date":"1661695514","viewed":108,"name":"Abstract painting","username":"grom12345","description":"Instructions:\n1. Start the timeline from the beginning ([|<]) and quickly make the shader fullscreen.\n2. Wait for the piece to evolve.\n3. Enjoy the art.\n\nThis piece is made for the creative code challenge: #WCCChallenge\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise","painting","art","cellularautomaton"],"hasliked":0,"parentid":"slKyWm","parentname":"Automata paint"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 N(float angle) {\n\n   return vec2(sin(angle), cos(angle));\n}\nmat2 Rot(float a) {\n    vec2 sc = N(a);\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=.5;\n    float r = texture(iChannel1, uv).r;\n    float g = texture(iChannel2, uv).r;\n    float b = texture(iChannel3, uv).r;\n    float a = texture(iChannel0, uv).r*1.;\n    vec4 col;\n    float aspect = iResolution.x/iResolution.y;\n    if(abs(uv.x-.25)>.253/aspect||abs(uv.y-.25)>.203) col = vec4(0);\n    else col = (1.-(vec4(r, g, b, 1)*.5+a));\n    \n    float t= 0.;//1.;\n    col.rg*=Rot(t*0.0487);\n    col.gb*=Rot(t*0.05643);\n    col.rb*=Rot(t*0.07623);\n    //col = normalize(col);\n    \n    col = pow(abs(col)+.0, vec4(2.2));\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec4 col = vec4(0);//texture(iChannel0, uv);\n    vec4 color1; \n    float aspect = iResolution.x/iResolution.y;\nif(abs(uv.x+.25*aspect)>.25||abs(uv.y+.25)>.2) color1 = vec4(0);\nelse{  \n    vec4 color [9];\n    int u = 1*int(mod((iTime+start)*0.0643, 4.));\n\ncolor[0] = texelFetch(iChannel1, ivec2(fragCoord), 0);\ncolor[1] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, -u), 0);\ncolor[2] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, -u), 0);\ncolor[3] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, -u), 0);\ncolor[4] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, 0), 0);\ncolor[5] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, 0), 0);\ncolor[6] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, u), 0);\ncolor[7] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, u), 0);\ncolor[8] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, u), 0);\n\ncolor1 = color[1];\n\nfor (int index = 2; index < 9 ; index++)\n{\ncolor1 += color[index];\n}\n\n\nfloat r = mod(floor((iTime+start)*.0954+34.34), 3.);\nfloat life = .9999*(1.-r*.001);\nfloat death = 0.986;\nfloat birth = 1.7*(1.+r*.02);\n\nfloat many = 7.25;\nfloat few = 3.0; \nfloat ordinary = 0.5;\n\nif (color[0].r > ordinary){ \n   if (length(color1.rgb) >= few || length(color1.rgb) <= many){\n      color1 = color1 * life;\n   }else{\n      color1 = color1 * death;\n   } \n} else {\n   if (length(color1.rgb) >= many){\n       color1 = color1 * birth;\n   } else {\n       color1 = color1 * death;\n    }\n}\n\ncolor1 /= 8.0;\n//color1 = color[0];\n}\nif(iFrame<100) color1 = texture(iChannel0, uv);\n        float box = clamp(-sdBox(uv+vec2(.25*aspect, .25), vec2(.2, .15))*10., .0, 1.);  \n        float m = crack(fragCoord.xy*.0005, iTime*.0134+15.);\n        color1 = clamp(color1+vec4(m)*.01*box, 0., 1.);\n    \n    fragColor = vec4(color1.rgb, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec4 col = vec4(0);//texture(iChannel0, uv);\n    vec4 color1; \n    float aspect = iResolution.x/iResolution.y;\nif(abs(uv.x+.25*aspect)>.25||abs(uv.y+.25)>.2) color1 = vec4(0);\nelse{\n    vec4 color [9];\n    int u = 1*int(mod((iTime+start)*0.086, 4.));\n\ncolor[0] = texelFetch(iChannel1, ivec2(fragCoord), 0);\ncolor[1] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, -u), 0);\ncolor[2] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, -u), 0);\ncolor[3] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, -u), 0);\ncolor[4] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, 0), 0);\ncolor[5] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, 0), 0);\ncolor[6] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, u), 0);\ncolor[7] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, u), 0);\ncolor[8] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, u), 0);\n\ncolor1 = color[1];\n\nfor (int index = 2; index < 9 ; index++)\n{\ncolor1 += color[index];\n}\n\n\nfloat r = mod(floor((iTime+start)*.11+32.98), 3.);\nfloat life = .9999*(1.-r*.001);\nfloat death = 0.986;\nfloat birth = 1.7*(1.+r*.02);\n\nfloat many = 7.25;\nfloat few = 3.0; \nfloat ordinary = 0.5;\n\nif (color[0].r > ordinary){ \n   if (length(color1.rgb) >= few || length(color1.rgb) <= many){\n      color1 = color1 * life;\n   }else{\n      color1 = color1 * death;\n   } \n} else {\n   if (length(color1.rgb) >= many){\n       color1 = color1 * birth;\n   } else {\n       color1 = color1 * death;\n    }\n}\n\ncolor1 /= 8.0;\n//color1 = color[0];\n}\nif(iFrame<100) color1 = texture(iChannel0, uv);\n        float box = clamp(-sdBox(uv+vec2(.25*aspect, .25), vec2(.2, .15))*10., .0, 1.);\n        float m = crack(fragCoord.xy*.0005, iTime*.045+54.);\n        color1 = clamp(color1+vec4(m)*.01*box, 0., 1.);\n        \n    fragColor = vec4(color1.rgb, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec4 col = vec4(0);//texture(iChannel0, uv);\n    vec4 color1; \n    float aspect = iResolution.x/iResolution.y;\nif(abs(uv.x+.25*aspect)>.25||abs(uv.y+.25)>.2) color1 = vec4(0);\nelse{  \n    vec4 color [9];\n    int u = 1*int(mod((iTime+start)*0.06, 4.));\n\ncolor[0] = texelFetch(iChannel1, ivec2(fragCoord), 0);\ncolor[1] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, -u), 0);\ncolor[2] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, -u), 0);\ncolor[3] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, -u), 0);\ncolor[4] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, 0), 0);\ncolor[5] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, 0), 0);\ncolor[6] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, u), 0);\ncolor[7] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, u), 0);\ncolor[8] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, u), 0);\n\ncolor1 = color[1];\n\nfor (int index = 2; index < 9 ; index++)\n{\ncolor1 += color[index];\n}\n\n\nfloat r = mod(floor((iTime+start)*.09+34.34), 3.);\nfloat life = .9999*(1.-r*.001);\nfloat death = 0.986;\nfloat birth = 1.7*(1.+r*.02);\n\nfloat many = 7.25;\nfloat few = 3.0; \nfloat ordinary = 0.5;\n\nif (color[0].r > ordinary){ \n   if (length(color1.rgb) >= few || length(color1.rgb) <= many){\n      color1 = color1 * life;\n   }else{\n      color1 = color1 * death;\n   } \n} else {\n   if (length(color1.rgb) >= many){\n       color1 = color1 * birth;\n   } else {\n       color1 = color1 * death;\n    }\n}\n\ncolor1 /= 8.0;\n//color1 = color[0];\n}\nif(iFrame<100) color1 = texture(iChannel0, uv);\n        float box = clamp(-sdBox(uv+vec2(.25*aspect, .25), vec2(.2, .15))*10., .0, 1.);  \n        float m = crack(fragCoord.xy*.0005, iTime*.012+10.);\n        color1 = clamp(color1+vec4(m)*.01*box, 0., 1.);\n    \n    fragColor = vec4(color1.rgb, 1);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec4 col = vec4(0);//texture(iChannel0, uv);\n    vec4 color1; \n    float aspect = iResolution.x/iResolution.y;\nif(abs(uv.x+.25*aspect)>.25||abs(uv.y+.25)>.2) color1 = vec4(0);\nelse{\n    vec4 color [9];\n    int u = 1*int(mod((iTime+start)*0.0832, 4.));\n\ncolor[0] = texelFetch(iChannel1, ivec2(fragCoord), 0);\ncolor[1] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, -u), 0);\ncolor[2] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, -u), 0);\ncolor[3] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, -u), 0);\ncolor[4] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, 0), 0);\ncolor[5] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, 0), 0);\ncolor[6] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(-u, u), 0);\ncolor[7] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(0, u), 0);\ncolor[8] = texelFetch(iChannel1, ivec2(fragCoord)+ivec2(u, u), 0);\n\ncolor1 = color[1];\n\nfor (int index = 2; index < 9 ; index++)\n{\ncolor1 += color[index];\n}\n\n\nfloat r = mod(floor((iTime+start)*.124+32.98), 3.);\nfloat life = .9999*(1.-r*.001);\nfloat death = 0.986;\nfloat birth = 1.7*(1.+r*.02);\n\nfloat many = 7.25;\nfloat few = 3.0; \nfloat ordinary = 0.5;\n\nif (color[0].r > ordinary){ \n   if (length(color1.rgb) >= few || length(color1.rgb) <= many){\n      color1 = color1 * life;\n   }else{\n      color1 = color1 * death;\n   } \n} else {\n   if (length(color1.rgb) >= many){\n       color1 = color1 * birth;\n   } else {\n       color1 = color1 * death;\n    }\n}\n\ncolor1 /= 8.0;\n//color1 = color[0];\n}\nif(iFrame<100) color1 = texture(iChannel0, uv);\n        float box = clamp(-sdBox(uv+vec2(.25*aspect, .25), vec2(.2, .15))*10., .0, 1.);\n        float m = crack(fragCoord.xy*.0005, iTime*.0465+542.);\n        color1 = clamp(color1+vec4(m)*.01*box, 0., 1.);\n        \n    fragColor = vec4(color1.rgb, 1);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define start 0.//185.//224.//33.\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvec2 hash1( vec2 p )\n{\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\nvec2 voronoi( in vec2 x )\n{\n    vec2 p = floor( x );\n    vec2 f = fract( x );\n\n    vec2 res = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        if( d < res.x )\n        {\n            res.y = res.x;\n            res.x = d;\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return sqrt( res );\n}\n\nfloat getBorder( in vec2 p, float d )\n{\n    vec2 c = voronoi( p );\n\n    float dis = c.y - c.x;\n\n    return 1.0 - smoothstep(0.0,d,dis);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec3 concreteCol(vec2 uv){\n//1. Color\n    float n = noise(uv*50.);\n    \n    float v = voronoi(uv*40.).x;\n    \n    float f = v*.3+.5;\n\t\n    return mix(vec3(0.3, 0.2, 0.001), vec3(1,1,1), f);\n}\nfloat crack(vec2 uv, float t){\nfloat n = noise(uv*5.+t);\nfloat n1 = noise(uv*5.-t);\nfloat cracks = getBorder(uv*3.+n-n1, 0.1);\n    return cracks*.5;\n  \n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}","name":"Common","description":"","type":"common"}]}