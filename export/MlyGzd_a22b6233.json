{"ver":"0.1","info":{"id":"MlyGzd","date":"1527859431","viewed":274,"name":"Nyan Cat Squadron","username":"Gnurou","description":"Playing with Nyan-kun. Work in progress. Probably a lot that can be optimized.","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["nyan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Use camera as background instead of generated stars?\n#define ENABLE_TEXTURE_BG false\n#define NB_CATS 10\n#define NB_STARS 10\n#define NB_RAINBOW_COLS 6\n\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define STAR_W 7\n#define STAR_H 7\n#define STAR_NB_FRAMES 4\n\nbool bounding_box_check(vec2 uv, vec2 top, vec2 bottom)\n{\n    return all(lessThan(top, uv)) && all(lessThan(uv, bottom));\n}\n\nvec4 nyancat_rainbow(in vec2 uv, in float factor)\n{\n    const vec3 colors[] = vec3[](\n        vec3(0.5, 0.0, 1.0),\n        vec3(0.0, 0.7, 1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(1.0, 0.5, 0.0),\n        vec3(1.0, 0.0, 0.0)\n    );\n    const float start = 0.21;\n    const float size = 0.57;\n    const float ssize = size / float(NB_RAINBOW_COLS);\n    const float shift = 0.014;\n    // TODO replace this with parameter, set properly from\n    // caller\n    const float rear = .25;\n    float pos = start;\n    vec4 col;\n    \n#define RAINBOW_LENGTH 4.    \n    // Early return if bounding box check fails\n    if (!bounding_box_check(uv, vec2(-RAINBOW_LENGTH, start),\n                                vec2(rear, start + size + shift)))\n        return vec4(0.);\n    \n    if (int(mod(uv.x * 6.0 + round(iTime * 3.0), 2.0)) == 1)\n        pos += shift;\n\n    for (int i = 0; i < NB_RAINBOW_COLS; i++) {\n\t    float c;\n        float end = pos + ssize;\n\t    c = 1.0 - step(uv.y, pos);\n\t    c *= step(uv.y, end);\n\t    c *= step(uv.x, rear);    \n\t    col.rgb += colors[i] * c;\n        col.a += c;\n        pos = end;\n    }\n    \n    // Make fade out vary with time.\n    float rstart = -RAINBOW_LENGTH - abs(sin(iTime * 3.0) / 4.);\n    col.a = col.a != 0. ?\n        smoothstep(rstart, rear, uv.x - rear) : \n    \t0.0;\n    \n    return vec4(col);\n}\n\nvec4 nyancat(in vec2 uv, in float factor, in float angle)\n{\n\tint frame = int(floor(mod((iTime + factor) * 13.0, 6.0)));\n\n    vec4 c = nyancat_rainbow(uv + 0.5, factor);\n\n    uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));    \n    uv += 0.5;\n    \n    uv = clamp(uv, 0.0, 1.0);\n    \n    // Return early is bounding box test fails\n    if (!bounding_box_check(uv, vec2(0., 0.), vec2(1., 1.)))\n        return c;\n\n    // Scale to 1 frame\n    uv.x *= 40.0 / 256.0;\n    // Choose frame\n    uv.x += float(frame) * (40.0 / 256.0);\n    \n    vec4 t = texture(iChannel0, uv);\n    \n    return vec4(mix(c.rgb, t.rgb, t.a), clamp(c.a + t.a, 0.0, 1.0));\n}\n\n// TODO return Z as well so we know how to mix colors\nvec4 nyancat_moving(in vec2 uv, in float factor)\n{\n\tconst float rotCenter = 0.5;\n    // Rotation center\n    uv -= rotCenter;\n    // Fix aspect ration\n    uv.x /= iResolution.y / iResolution.x;\n    \n    // Initial position\n    uv += vec2(-.6 + rand(vec2(factor * 1.5, factor)), -.5 + rand(vec2(factor * 2.3, factor)));\n\n    // Translate\n    //uv -= vec2(sin(iTime * factor / 2.0) / 2.0, sin(iTime / 3.3 * factor) / 3.0);\n    \n    uv += vec2(sin(iTime + factor) / (factor + 1.0),\n               sin(iTime + factor) / (factor + 10.0));\n    \n    // Scale\n    float scalefactor = ((sin(iTime) / 2.0) + factor + 1.7);\n    uv *= mat2(scalefactor, 0.0, 0.0, scalefactor);\n\n    // Rotate\n    const float fac = 15.0;\n    const float speed = 7.0;\n    float angle = sin(iTime * speed) / factor / fac;\n    angle = abs(angle);\n\n    return nyancat(uv, factor, angle);\n}\n\nvec4 gen_bg(in vec2 uv)\n{\n    vec2 bguv = uv / iResolution.xy;\n    if (!ENABLE_TEXTURE_BG) {\n\t    float scalefactor2 = (sin(iTime) / 5.0) + 1.0;\n   \t\tbguv *= mat2(scalefactor2, 0.0, 0.0, scalefactor2);\n    \tbguv.x += iTime / 1.2;\n    }\n\n    return texture(iChannel1, bguv);\n}\n\n// Star is drawn from (-.5, -.5) to (.5, .5)\nvec4 gen_star(in vec2 uv, float factor)\n{\n    const float xstep = 1.0 / float(STAR_W);\n    const float ystep = 1.0 / float(STAR_H);\n    \n    // Move to center\n    uv -= .5;\n    \n    // Fix aspect ratio\n    uv.x /= iResolution.y / iResolution.x;\n\n#define SCALE_DOWN 10.\n    // Scale down\n    // TODO vary size and speed down as star is further away?\n    uv *= SCALE_DOWN;\n\n    // Randomize y and starting x according to factor\n    // TODO also randomize y according to iTime modulo width of scene\n    uv.y += ((factor * SCALE_DOWN) - (SCALE_DOWN / 2.));\n    uv.x += ((rand(vec2(factor)) * SCALE_DOWN) - (SCALE_DOWN / 2.));\n\n    // Scroll x according to time and speed\n    // TODO aspect ratio not taken into account?\n    float speed = SCALE_DOWN / 1.2;\n    uv.x = -(SCALE_DOWN / 2.) + mod(uv.x + iTime * speed, SCALE_DOWN);\n    \n    // Return early if bounding box test fails\n    if (!bounding_box_check(uv, vec2(-.5, -.5), vec2(.5, .5)))\n        return vec4(0.);\n\n    int frame = int(mod((iTime + factor * PI * 10.) * 6.,\n                        float(STAR_NB_FRAMES) + 10.));\n    \n    // Early return if end of animation\n    if (frame >= STAR_NB_FRAMES)\n        return vec4(0.);\n\n    // DEBUG: is the correct frame selected?\n    // return vec4(vec3(float(frame) / float(STAR_NB_FRAMES)), 1.);\n    \n    // Find the pixel coordinate of the star \n    int py = int(floor((uv.y + .5) * float(STAR_H)));\n    int px = int(floor((uv.x + .5) * float(STAR_W)));\n    \n    // Mirror x and y to get the correct pixel data\n    py = abs(py - 3);\n    px = abs(px - 3);\n    \n    vec4 p1 = vec4(1.);\n    vec4 p0 = vec4(0.);\n    \n    // Early filter of most transparent pixels\n\tif (frame != 3 && (px != 0 && py !=0))\n        return p0;\n    \n    // For frame 0, the second pixel on each axis is set\n    if (frame == 0)\n        return (px | py) == 1 ? p1 : p0;\n    \n    // For frame 1, the second and third pixel on each axis is set\n    if (frame == 1) {\n        px |= py;\n        return (px == 1 || px == 2) ? p1 : p0;\n    }\n    \n    if (frame == 2)\n        return (px | py) != 1 ? p1 : p0;\n    \n    if (frame == 3) {\n        if (px == 0 || py == 0) {\n            px |= py;\n            return px == 3 ? p1 : p0;\n        }\n        \n        return px == 2 && py == 2 ? p1 : p0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n  \tvec3 col;\n    vec4 fg;\n\n    // Background\n\tif (ENABLE_TEXTURE_BG)\n\t    col = gen_bg(fragCoord.xy).rgb;\n    else\n    \tcol = vec3(.16, .16, .45);\n\n    for (int i = 0; i < NB_STARS; i++) {\n\t    fg = gen_star(uv, rand(vec2(float(i))));\n  \t    col = mix(col, fg.rgb, fg.a);\n    }\n\n    for (int i = 0; i < NB_CATS; i++) {\n\t    fg = nyancat_moving(uv, float(NB_CATS - i));\n\t    col = mix(col, fg.rgb, fg.a);\n    }\n    // TODO make sure cat is drawn on (-.5, .5) scale inside\n    // function (makes bounding box check easier).\n//    fg = nyancat_moving(uv, 1.0);\n//    uv -= .5; fg = nyancat(uv, 1.0, 0.);\n//    fg = nyancat_rainbow(uv - vec2(.75, 0.), 1.0);\n    col = mix(col, fg.rgb, fg.a);\n\t\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}