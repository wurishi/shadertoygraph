{"ver":"0.1","info":{"id":"4sXfzB","date":"1496662120","viewed":363,"name":"Museum of Planets (lite?)","username":"Noobenstein","description":"Combination of \"Fast pseudo-3d Perlin noise\" and \"Museum of random planets\" (both by Luke Rissacher). Originals here: https://www.shadertoy.com/view/MtcGRl https://www.shadertoy.com/view/XttGzj","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","raymarching","perlin","random","optimization","planets","flownoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DEPTH = 3.0;\nconst float START_PLANET = 18.0;\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nfloat Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nvec3 HueToRgb(float h) {\n    vec3 rgb = 2.0 - abs(6.0 * h - vec3(3, 2, 4));\n    rgb.r = 1.0 - rgb.r;\n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HsvToRgb(vec3 hsv) {\n    vec3 rgb = HueToRgb(hsv.x);\n    return ((rgb - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n\n// Gradient noise functions courtesy Inigo Q\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture(iChannel0, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat noise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n\n\nfloat Rand(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Rand(float pos) {\n    return Rand(vec2(pos));\n}\n\nfloat SphereDistance(vec3 localPos, float radius) {\n\treturn length(localPos) - radius;\n}\n\nfloat SceneDistance(vec3 pos, out float layer) {\n    if (pos.x < 0.0) {\n        return 1.0;\n    }\n    \n    float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n    \n    vec3 planetPos = pos;\n    planetPos.x = mod(planetPos.x, 2.0) - 1.0;\n    float rotationSpeed = mix(-1.0, 1.0, fract(planetNumber / 2.3));\n    planetPos.xz = Rotate(planetPos.xz, rotationSpeed * iTime);\n    \n    float terrainDetail = mix(0.1, 5.5, Rand(planetNumber + 0.16));\n    float layerHeight = mix(0.005, 0.05, Rand(planetNumber + 0.55));\n    float layerCount = floor(mix(3.5, 20.5, Rand(planetNumber + 0.36)));\n    float noiseValue = 0.5 * noise((normalize(planetPos) + planetNumber) * terrainDetail) + 0.5;\n    layer = floor(noiseValue * layerCount);\n\t\n\tfloat baseSize = mix(0.2, 0.4, Rand(planetNumber + 0.28));\n    float d1 = SphereDistance(planetPos, baseSize + (layer - 1.0) * layerHeight);\n    float d2 = SphereDistance(planetPos, baseSize + layer * layerHeight);\n    \n    float layerTransition = smoothstep(0.0, 0.3, fract(noiseValue * layerCount) + 0.06);\n    return mix(d1, d2, layerTransition);\n}\n\nfloat SceneDistance(vec3 pos) {\n    float dummy;\n    return SceneDistance(pos, dummy);\n}\n\nfloat RayMarch(vec3 startPos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = startPos + dir * depth;\n        float dist = SceneDistance(pos);\n        if (dist < 0.0001) {\n        \treturn depth;\n        }\n        depth += 0.6 * dist;\n        if (depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nvec3 SceneNormal(vec3 pos) {\n\tconst float DX = 0.004;\n\tconst vec3 dx = vec3(DX, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, DX, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, DX);\n    return normalize(vec3(\n        SceneDistance(pos + dx) - SceneDistance(pos - dx),\n        SceneDistance(pos + dy) - SceneDistance(pos - dy),\n        SceneDistance(pos + dz) - SceneDistance(pos - dz)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float FOV = radians(45.0);\n    vec3 eyePos = vec3(0.5 * iTime - 1.0, 0.0, -2.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) * 0.5;\n    vec3 rayDir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    vec3 lightDir = normalize(vec3(0.5, 0.8, -1.0));\n   \n    float depth = RayMarch(eyePos, rayDir);\n    if (depth < MAX_DEPTH) {\n        \n        vec3 pos = eyePos + rayDir * depth;\n        float layer;\n        vec3 normal = SceneNormal(pos);\n        SceneDistance(pos, layer);\n        \n        float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n        \n        float baseHue = Rand(planetNumber + 1.72);\n        float hueStep = mix(0.02, 0.15, pow(Rand(planetNumber + 0.492), 2.0));\n        \n        float baseSat = pow(Rand(planetNumber + 0.195), 0.2);\n        float satStep = mix(-0.2, 0.2, Rand(planetNumber + 0.777));\n        \n        float baseVal = mix(0.5, 1.0, pow(Rand(planetNumber + 0.888), 0.3));\n        float valStep = mix(0.0, 0.2, Rand(planetNumber + 0.992));\n        \n        vec3 color = HsvToRgb(\n            vec3(fract(baseHue + layer * hueStep), \n\t             clamp(baseSat + layer * satStep, 0.0, 1.0), \n                 0.3 + 0.7 * fract(baseVal + layer * valStep)));\n        float diffuse = 2.0 * clamp(dot(lightDir, normal), 0.0, 1.0);\n    \tfragColor = vec4(diffuse * color, 1.0);\n    }\n    else {\n        float gradient = abs(2.0 * (fragCoord.y / iResolution.y) - 1.0);\n        vec3 skyColor = HsvToRgb(vec3(fract(0.015 * iTime) + 0.5, 1.0, 0.1 * gradient));\n        fragColor = vec4(skyColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}