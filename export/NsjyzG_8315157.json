{"ver":"0.1","info":{"id":"NsjyzG","date":"1643712818","viewed":231,"name":"Nyoom Wave","username":"panna_pudi","description":"*nyoooooms*","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["wave","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Nyoom Wave by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane, z0rg, Tater\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// It's a lame version of Square Wave by cmarangu\n// https://www.shadertoy.com/view/tstXR7\n//\n// 0b5vr's grid traversal\n// https://www.shadertoy.com/view/stdXWH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float pix = 1.3 / iResolution.y;\n    \n    vec3 col;\n    col.r = texture(iChannel0, uv + vec2(pix,   0.)).r;\n    col.g = texture(iChannel0, uv + vec2(-pix,-pix)).g * .9;\n    col.b = texture(iChannel0, uv + vec2(pix,  pix)).b;\n    \n    // blur kernel\n    mat3 conv = mat3(1, 2, 1,\n                     2, 4, 2,\n                     1, 2, 1);\n    vec3 bcol = vec3(0.);\n    float n = 4.;\n    for(float k = 0.; k <= n; k++) {\n        for(int i = -1; i <= 1; i++) {\n            for(int j = -1; j <= 1; j++) {\n                ivec2 off = ivec2(i, j);\n                bcol += texture(iChannel0, uv + vec2(off) * k * pix).rgb\n                        * conv[off.x + 1][off.y + 1];\n            }\n        }\n    }\n    bcol /= 20. * n;\n    \n    col = mix(col, bcol, .25);\n    \n    col = pow(col, vec3(1.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float map(vec3 p) {\n    vec3 ap = abs(p);\n    float box = length(max(vec3(ap.x, p.y, ap.z) - vec3(0.1), 0.)) - 0.01;\n    return box;\n}\n\nfloat AO(float eps, vec3 p, vec3 n) {\n    return clamp(map(p - eps * n) / eps, 0., 1.);\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\n// https://www.shadertoy.com/view/stdXWH\nvec3 traverse_grid_2d(vec2 ro, vec2 rd) {\n    const float GRID_WIDTH = .25;\n\n    vec2 grid = floor((ro + rd * 1E-4 * GRID_WIDTH) / GRID_WIDTH) * GRID_WIDTH +\n                0.5 * GRID_WIDTH;\n\n    vec2 src = (ro - grid) / rd;\n    vec2 dst = abs(0.5 * GRID_WIDTH / rd);\n    vec2 bv = -src + dst;\n    float b = min(bv.x, bv.y);\n    return vec3(grid, b);\n}\n\nfloat grid_offset(vec2 grid, float t) {\n    grid *= 10.;\n    ivec2 xgrid = ivec2(grid);\n    float off = t * 20.;\n    \n    // off = off - (grid.x + sin(grid.y) + 16.) * .5;\n    // off = (grid.x + sin(grid.y + t) + 16.) * .5;\n    // off = off - (grid.x + float(int(xgrid.x) | int(xgrid.y) % 9) + 16.) * .5;\n    off = off - (grid.x + mod(grid.x + grid.y, 9.) + 16.) * .5;\n    \n    off = clamp(off, 0., 1.);\n    return off * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy * 2. - 1.) * vec2(aspect, 1.);\n    uv *= .51;\n    \n    float t = mod(iTime / 8., 1.); // maybe 1.1?\n    float frame = floor(iTime / 8.);\n\n    vec3 ro = vec3(uv * 1., -6.);\n    vec3 rd = normalize(vec3(0., 0., 1.));\n\n    ro.yz *= rot(atan(1. / sqrt(2.)));\n    rd.yz *= rot(atan(1. / sqrt(2.)));\n    ro.xz *= rot(PI / 4.);\n    rd.xz *= rot(PI / 4.);\n\n    float rl = 0.0;\n    vec3 rp = ro + rd * rl;\n    vec3 grid_center = vec3(0.);\n    float len_to_border = 3.5;\n    vec2 rd_xz_normalized = normalize(rd.xz);\n    float grid_factor = 1.0 / length(rd.xz);\n\n    bool hit = false;\n    for (int i = 0; i < 100; i++) {\n        if (len_to_border <= rl) {\n            rl = len_to_border;\n            rp = ro + rd * rl;\n\n            vec3 grid = traverse_grid_2d(rp.xz, rd_xz_normalized);\n            grid_center = vec3(grid.x, 0.0, grid.y);\n            grid_center.y += grid_offset(grid_center.xz, t);\n\n            len_to_border += grid.z * grid_factor;\n        }\n        float dist = map(rp - grid_center);\n        rl += dist;\n        rp += dist * rd;\n\n        if (abs(dist) < 1e-3) { hit = true; break; }\n        if (distance(rp, ro) > 10.) { break; }\n    }\n\n    vec3 col = vec3(0.5);\n\n    if (hit) {\n        vec3 pos = rp - grid_center;\n        vec3 nor = get_norm(pos);\n        vec3 l = normalize(vec3(1., 1., -1.));\n\n        vec3 albedo = vec3(0.5);\n        if (dot(nor, vec3(0., 1., 0.)) > 0.15) {\n            albedo = vec3(132, 15, 173) / 255. * 2.;\n        }\n        if (dot(nor, vec3(1., 0., 0.)) > 0.9) {\n            float rnd = hash21(grid_center.xz + frame);\n            float freq = 0.05;\n            if (rnd < freq) {\n                rnd = rnd / freq * 3.;\n                if (rnd < 1.) {\n                    vec2 p = pos.zy * 18. + vec2(0.2, 1.);\n                    p *= rot(PI / 4.);\n                    albedo = mix(albedo, vec3(.1, 1., 1.) * 5., kitty(p));\n                } else if (rnd < 2.) {\n                    vec2 p = pos.zy * 5. + vec2(0., .3);\n                    albedo = mix(albedo, vec3(1.) * 5., bnuuy(p));\n                } else {\n                    vec2 p = pos.zy * 6. + vec2(0., .3);\n                    p *= rot(PI / 4.);\n                    albedo = mix(albedo, vec3(1., 0.5, 0.5) * 5., piggy(p));\n                }\n            }\n        }\n\n        float ao = 1. - AO(5., nor, pos) ;\n\n        vec3 r = reflect(rd, nor);\n        float shade = length(sin(r * 3.) * .5 + .5) / sqrt(3.);\n        col = albedo * shade * ao;\n    }\n\n    col = mix(col, texture(iChannel0, fragCoord / iResolution.xy).rgb, 0.15);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = PI * 2.;\n\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sd_circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_square(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float tr) {\n    float k = dot(p - a, b - a) / dot(b - a, b - a);\n    float hit = clamp(k, 0., 1.);\n    float d =  distance(p, mix(a, b, hit));\n    vec2 dir = b - a;\n    return step(tr, 1. - d);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdUnevenCapsule(vec2 p, float r1, float r2, float h) {\n    p.x = abs(p.x);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(p, vec2(-b, a));\n    if (k < 0.0) return length(p) - r1;\n    if (k > a * h) return length(p - vec2(0.0, h)) - r2;\n    return dot(p, vec2(a, b)) - r1;\n}\n\nfloat tongue(vec2 p, float r1, float r2, float h, float tr) {\n    float d = sdUnevenCapsule(p, r1, r2, h);\n    return step(tr, 1. - d);\n}\n\n#define sabs(x, k) sqrt((x) * (x) + k)\n#define lofi(x, n) floor((x)*(n)) / (n)\n\n// https://www.shadertoy.com/view/NlGXWw\nfloat kitty(vec2 uv) {\n    uv = lofi(uv, 5000.);\n    float kat = 0.;\n\n    // eyes\n    kat += line(uv, vec2(0.33, 0.21), vec2(0.63, 0.30), 0.94);\n    kat += line(uv, vec2(-0.63, 0.29), vec2(-0.42, 0.23), 0.93);\n\n    // nosie\n    kat += line(vec2(sabs(uv.x, 0.001), uv.y), vec2(-0.05, 0.0), vec2(0.05, 0.01), 0.982);\n\n    // ears\n    kat += line(uv, vec2(-1.0, 0.9), vec2(-1.05, 1.3), 0.98);\n    kat += line(uv, vec2(-0.60, 1.05), vec2(-1.05, 1.3), 0.98);\n\n    kat += line(uv, vec2(1.0, 0.9), vec2(1.05, 1.3), 0.98);\n    kat += line(uv, vec2(0.60, 1.05), vec2(1.05, 1.3), 0.98);\n\n    kat += line(uv, vec2(-0.61, 0.96), vec2(-0.83, 1.09), 0.992);\n    kat += line(uv, vec2(-0.66, 0.95), vec2(-0.83, 1.02), 0.992);\n    kat += line(uv, vec2(-0.66, 0.95), vec2(-0.83, 1.03), 0.992);\n\n    kat += line(uv, vec2(0.61, 0.96), vec2(0.83, 1.09), 0.992);\n    kat += line(uv, vec2(0.74, 0.95), vec2(0.83, 1.02), 0.992);\n    kat += line(uv, vec2(0.75, 0.95), vec2(0.83, 1.03), 0.992);\n\n    // whiskers\n    kat += line(uv, vec2(-1.64, 0.21), vec2(-1.20, 0.1), 0.99);\n    kat += line(uv, vec2(-1.61, 0.12), vec2(-1.20, -0.049), 0.99);\n    kat += line(uv, vec2(-1.48, -0.12), vec2(-1.20, -0.113), 0.99);\n\n    kat += line(uv, vec2(1.45, 0.21), vec2(1.18, 0.1), 0.99);\n    kat += line(uv, vec2(1.35, -0.01), vec2(1.20, -0.049), 0.99);\n    kat += line(uv, vec2(1.45, -0.12), vec2(1.20, -0.113), 0.99);\n\n    // mouth\n    vec2 el = vec2(0., sabs(uv.x - 0.3, 0.06));\n    vec2 mp = uv - el - vec2(0.3, -0.3);\n    kat += line(mp, vec2(-0.30, -0.4), vec2(0.16, -0.4), 0.98);\n\n    kat += line(uv - vec2(-0.3, sabs(uv.x + 0.3, 0.38) - 0.6), vec2(-0.15, -0.4),\n                vec2(0.29, -0.4), 0.98);\n\n    // tongue\n    vec2 tp = uv * vec2(1.1, -1.) - vec2(-0.01, 0.42);\n    kat += tongue(tp, 0.1, 0.15, 0.2, 0.999);\n    kat -= line(uv - vec2(-0.01, 0.0), vec2(0., -0.7), vec2(0., -0.5), 0.99);\n    return kat;\n}\n\nfloat sd_line(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p - a, b - a) / dot(b - a, b - a);\n    vec2 q = mix(a, b, clamp(k, 0., 1.));\n    return distance(p, q);\n}\n\nfloat bnuuy(vec2 p) {\n    float d = 1e9;\n    float head = abs(sd_circle(p * vec2(0.8, 1.) + vec2(0., .2), 0.25)) - 0.01;\n    \n    // patch is a reserved word?!\n    vec2 q = p - vec2(0.11, -0.15);\n    q *= rot(PI / 4.);\n    float potch = abs(sd_square(q, vec2(0.1, 0.03))) - 0.01;\n    q *= rot(PI / 2.);\n    potch = max(potch, -sd_square(q, vec2(0.1, 0.03)));\n    potch = min(potch, abs(sd_square(q, vec2(0.1, 0.03))) - 0.01);\n    \n    q = p * vec2(1., 0.8) - vec2(-0.15, -0.13);\n    float eye = sd_circle(q, 0.03);\n    \n    q = p - vec2(0., -0.3);\n    float nose = sd_circle(q * vec2(0.5, 1.), 0.02);\n    \n    q = vec2(abs(p.x), p.y);\n    float ears = abs(sd_line(q, vec2(0.15, 0.), vec2(0.2, 0.3)) - 0.15) - 0.01;\n    ears = min(ears, sd_line(q, vec2(0.15, 0.), vec2(0.2, 0.3)) - 0.025);\n    ears = max(ears, -sd_circle(p * vec2(0.8, 1.) + vec2(0., .2), 0.25));\n    \n    d = min(d, head);\n    d = min(d, potch);\n    d = min(d, eye);\n    d = min(d, nose);\n    d = min(d, ears);\n    return step(d, 0.);\n}\n\nfloat piggy(vec2 p) {\n    float d = 1.9;\n    float body = sd_circle(p * vec2(0.85, 1.) - vec2(0.1, 0.0), 0.35);\n    \n    vec2 q = p - vec2(0.11, -0.25);\n    q = vec2(abs(q.x), q.y);\n    q *= rot(PI / 3.);\n    q -= vec2(0.2, 0.2);\n    float legs = sd_square(q, vec2(0.05, 0.08));\n    \n    float tail = sd_line(p, vec2(0.5, 0.15), vec2(0.6, 0.2));\n    tail = min(tail, sd_line(p, vec2(0.55, 0.22), vec2(0.6, 0.15)));\n    \n    float head = abs(sd_circle(p - vec2(-0.35, 0.1), 0.2)) - 0.01;\n    head = min(head, sd_circle(p - vec2(-0.4, 0.2), 0.025));\n    head = min(head, abs(sd_square(p - vec2(-0.6, 0.1), vec2(0.05, 0.05))) - 0.01);\n    head = max(head, - body);\n    \n    d = min(d, abs(body) - 0.01);\n    d = min(d, abs(legs) - 0.01);\n    d = min(d, tail - 0.01);\n    d = min(d, head);\n    return step(d, 0.);\n}","name":"Common","description":"","type":"common"}]}