{"ver":"0.1","info":{"id":"csVfRV","date":"1698673232","viewed":97,"name":"Sea of Fog - Visualizer Fork","username":"smlk0","description":"Further learning with:\nFork of \"Sea of fog\" by jaszunio15.\nhttps://shadertoy.com/view/tsdSzn\n\nsoundcloud: https://soundcloud.com/floatingpoints/bias","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["3d","sea","distortion","volumetric","fog","learning","flow","polarlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MscGRj","filepath":"https://soundcloud.com/floatingpoints/bias","previewfilepath":"https://soundcloud.com/floatingpoints/bias","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 fancyLayer(vec2 uv, float cut) {\n\n    uv *= 0.1;\n\n    for (float i = DISTORTION_BASE_ITERATION; i <= DISTORTION_BASE_ITERATION + DISTORTION_ITERATIONS; i++) {\n    \n     \tuv.x += STRENGTH * sin(uv.y * pow(DISTORTION_POW, i) + TIME * DISTORTION_SPEED + i * 0.18) / pow(DISTORTION_POW, i);\n        uv.y += STRENGTH * sin(uv.x * pow(DISTORTION_POW, i) + TIME * DISTORTION_SPEED + i * 0.21) / pow(DISTORTION_POW, i);\n    }\n    \n    float fancyness = noise12(uv * 10.0 + TIME * 0.1 * 5.0);\n    float noise = noise12(uv * 2.0 + TIME * 0.5 + 21.0);\n    \n    return (smoothstep(cut - VOLUMETRIC_CUT_WIDTH, cut + VOLUMETRIC_CUT_WIDTH, fancyness) * (2.0 + fancyness) / 3.0) * vec3(0.5,1.0,1.0);\n}\n\n\nvec3 uvToCastPlane(vec2 uv) {\n\n \treturn vec3(uv.x, uv.y, -1.0 + sin(TIME * 0.2) * 0.2);   \n}\n\nvec3 rayCastPlane(vec3 rayOrigin, vec3 rayDirection, float planeHeight) {\n\n    rayDirection /= rayDirection.y;\n    float distanceToPlane = rayOrigin.y - planeHeight + 1.0;\n    rayDirection *= distanceToPlane;\n    return vec3(rayOrigin.xz + rayDirection.xz, length(rayDirection));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    vec3 angle = vec3(-0.42 + cos(TIME * 0.3) * 0.08, sin(TIME * 0.2) * 0.5, cos(TIME * 0.21) * 0.1);\n    mat3x3 rotationMatrix = mat3x3(cos(angle.z), -sin(angle.z), 0.0,\n                                  sin(angle.z), cos(angle.z), 0.0,\n                                  0.0, 0.0, 1.0)\n        \t\t\t\t  * mat3x3(1.0, 0.0, 0.0,\n                                  0.0, cos(angle.x), -sin(angle.x),\n                                  0.0, sin(angle.x), cos(angle.x))\n        \t\t\t\t  * mat3x3(cos(angle.y), 0.0, -sin(angle.y),\n                                  0.0, 1.0, 0.0,\n                                  sin(angle.y), 0.0, cos(angle.y));\n    \n    vec3 cameraShift = vec3(0.0, sin(TIME * 0.24) * 0.12 - 0.36, TIME * 1.3);\n    \n    vec3 rayOrigin = cameraShift;\n    vec3 castPoint = uvToCastPlane(uv) * rotationMatrix + cameraShift;\n    vec3 rayDirection = castPoint - rayOrigin;\n    \n    float planeDistance = rayCastPlane(rayOrigin, rayDirection, -0.5).z;\n    float fog = rayDirection.y > 0.0 ? 1.0 : 0.0 + (planeDistance * 0.05);\n\n    float bass  = 0.0; \n    int max_range = 11;\n    for (int range = 0; range < max_range; range++) {\n        \n        bass += texelFetch( iChannel0, ivec2(range,0), 0 ).x;\n    }\n    bass /= float(max_range - 1);\n    \n    vec3 col = vec3(0.0);\n    \n    for (float i = 1.0; i <= LAYERS_COUNT ; i++) {\n    \n        vec2 planeUV = rayCastPlane(rayOrigin, rayDirection, -0.5 - i * LAYERS_DISTANCE - 1.0 * LAYERS_DISTANCE).xy;\n        col += fancyLayer(planeUV, 1.2 - (0.3 * bass) - pow(i / LAYERS_COUNT, 2.0)) * COLOR_MULTIPLIER * pow(0.99, i);\n    }\n    \n    float vignette = smoothstep(2.5, 0.4, length(uv));\n\tcol = smoothstep(1.0, 0.0, col) * vignette;\n    col -= fog;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TIMESCALE 1.0\n#define TIME (iTime * TIMESCALE)\n\n#define STRENGTH 0.5\n#define LAYERS_COUNT 100.0\n#define LAYERS_DISTANCE 0.0095\n#define COLOR_MULTIPLIER 0.074\n#define NOISE_SHARPNESS 1.0 //animate\n#define VOLUMETRIC_CUT_WIDTH 0.05\n#define DISTORTION_POW 1.3\n#define DISTORTION_SPEED 0.4\n#define DISTORTION_BASE_ITERATION 5.0\n#define DISTORTION_ITERATIONS 10.0\n\nfloat hash12(vec2 x)   \n{\n    return fract(sin(dot(x, vec2(342.243, 234.4281))) * 235.2412);\n}\n\nfloat hash11(float x)   \n{\n    return fract(sin(x * 342.243) * 235.2412);\n}\n\nfloat noise12(vec2 uv)\n{\n \tvec2 rootUV = floor(uv);\n    vec2 fractUV = smoothstep(0.0, 1.0, fract(uv));\n    \n    float v00 = hash12(rootUV + vec2(0.0, 0.0));\n    float v01 = hash12(rootUV + vec2(0.0, 1.0));\n    float v10 = hash12(rootUV + vec2(1.0, 0.0));\n    float v11 = hash12(rootUV + vec2(1.0, 1.0));\n    \n    float v0 = mix(v00, v01, fractUV.y);\n    float v1 = mix(v10, v11, fractUV.y);\n    \n    return pow(mix(v0, v1, fractUV.x), NOISE_SHARPNESS);\n}","name":"Common","description":"","type":"common"}]}