{"ver":"0.1","info":{"id":"XlcXWr","date":"1478904179","viewed":165,"name":"Hillz","username":"VoidChicken","description":"A basic hill raymarcher with a raycasted distance field for the plane.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","simple","raymarch","raycast","distance","field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(x) (fract(x)<.5?floor(x):ceil(x))\nvec3 tex( vec2 u ) {\n    float k = 0.;\n    k=(sign(sin(u.x*3.14))+sign(sin(u.y*3.14)));\n    float jt =  ((sin(u.x*3.14))+(sin(u.y*3.14)));\n    vec3 i = vec3(.2,.1,0)*pow(abs(1.-clamp(jt, 0., 1.)), 10.);\n    i+=abs(jt)/2.;\n    return i;\n}\nfloat pRTd( vec3 o, vec3 d ) {\n    if (d.y>=0.) return 10.; \n    return ((o.y-2.)/(-d.y));\n}\nfloat smin( float a, float b )\n{\n    float k = 2.;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat map ( vec3 o, vec3 d ) {\n    vec2 sph = (mod(o.xz, 10.)-5.);\n\treturn smin(pRTd(o, d), length(vec3(sph.x, o.y, sph.y))-(4.));    \n}\nfloat trace( vec3 o, vec3 d ) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+d*t, d);\n        if (t>30.||f<.02) break;\n        t+=f*.7;\n    }\n    return t;\n}\nvoid render ( vec2 u, out vec4 c ) {\n    vec3 col = vec3(1);\n    vec3 o = vec3 (0, 6, iTime*3.),\n        d = normalize(vec3(vec2(iResolution.x/iResolution.y, 1)*(u*2.-1.), 1));\n\t\n    float t = 0.;\n    float hit = 0.;\n    t=trace(o, d);\n    \n    vec3 r = o+t*d;\n    hit=-(map(r, d)-.2);\n    \n    if (hit>=0.) {\n   \t\t col=mix(col, tex(r.xz).rgb, (1.-t/30.));   \n    }\n    col=col*col;\n    col+=texture(iChannel0, u.xy+1000.*(iTime)).r/20.;\n\tcol*=min(1.,iTime*.25);\n    c=1.-exp(-col.xyzx*(1.-pow(length(u-.5), 2.))*2.13);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    render ( uv, fragColor );\n}","name":"Image","description":"","type":"image"}]}