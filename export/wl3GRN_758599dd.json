{"ver":"0.1","info":{"id":"wl3GRN","date":"1575732048","viewed":135,"name":"font flow","username":"Anskiere","description":"-","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define REMAP_TEMP(TYPE) TYPE remap(TYPE a, TYPE b, TYPE c, TYPE d, TYPE x) { TYPE t = (x - a) / (b - a); TYPE res = c + (d - c)*t; return res; }\n#define time (float(iFrame) / 30.)\nconst float maxDist = 10.;\nconst float planeDist = 2.;\n\nconst float pi = 3.1415926;\nconst float hpi = pi / 2.;\n\nvec2 rot(vec2 p, float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\tmat2 m = mat2(ca, sa, -sa, ca);\n\treturn m * p;\n}\n\nREMAP_TEMP(float)\nREMAP_TEMP(vec3)\n\nvec3 getRay(vec2 uv, out vec3 ro)\n{\n    vec3 cam = vec3(-0.75, 0.75, 3);\n    ro = cam;\n    vec3 origin = vec3(0, 0, 0);\n    vec3 look = normalize(origin - cam);\n    vec3 upGlob = vec3(0,1,0);\n    vec3 right = normalize(cross(upGlob, look));\n    vec3 camUp = normalize(-cross(right, look));\n\n    vec3 p = cam + camUp * uv.y + right * uv.x;\n    p += look * planeDist;\n\n    vec3 res = p - cam;\n    return normalize(res);\n}\n\nfloat getCube(vec3 p, float size)\n{\n\tp = abs(p);\n\treturn max(max(p.x, p.y), p.z) - size;\n}\n\nfloat inter(float a, float b)\n{\n\treturn max(a, b);\n}\n\nfloat sdFont(float n, vec2 luv, out vec2 derivative)\n{\n\tn = mod(n, 26.);\n\tn += 65.;\n\n\tluv.x = clamp(luv.x, 0., 1.);\n\tluv.y = clamp(luv.y, 0., 1.);\n\n\tfloat m = mod(n, 16.);\n\tvec2 ij = vec2(m, 15. - floor(n / 16.));\n    \n\tfloat s = texture(iChannel0, (ij + luv)/16.).w;\n    derivative = texture(iChannel0, (ij + luv)/16.).yz;\n    derivative = derivative*2.-1.;\n    \n    s -= 0.5;\n    \n\treturn s;\n}\n\nfloat getSd(vec3 p, out vec2 derivative)\n{\n    p.x = -p.x;\n\n\tfloat sdC = getCube(p, 1.);\n\n    float t = time*0.75;\n    t = floor(t) + smoothstep(0., 1., fract(t));\n    t -= p.z*1.;\n    \n    float k1 = floor(t);\n    float k2 = k1 + 1.;\n\tp = remap(vec3(-1), vec3(1), vec3(0), vec3(1), p);\n    vec2 d1;\n\tfloat sdF1 = sdFont(k1, vec2(p.x, p.y), d1);\n    vec2 d2;\n\tfloat sdF2 = sdFont(k2, vec2(p.x, p.y), d2);\n\n\tfloat sdF = mix(sdF1, sdF2, fract(t));\n    derivative = mix(d1, d2, fract(t));\n\n\tfloat res = inter(sdF, sdC);\n    \n    return res;\n}\n\nfloat raymarch(vec3 sp, vec3 ray, out vec2 derivative)\n{\n\tfloat depth = 0.;\n\n\tfor(int i = 0; i < 250; i++)\n\t{\n\t\tvec3 p = sp + ray * depth;\n        \n\t\tfloat dist = getSd(p, derivative);\n\n\t\tif (dist <= 0.001)\n\t\t  return depth + dist;\n\n\t\tdepth += dist;\n\n\t\tif (depth >= maxDist)\n\t\t  return maxDist;\n\t}\n\n\treturn maxDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n\tuv.x /= iResolution.y / iResolution.x;\n    uv *= 2.;\n\n\tvec3 ro;\n    vec3 ray = getRay(uv, ro);\n    vec2 derivative;\n\tfloat d = raymarch(ro, ray, derivative);\n    \n\tvec3 col = vec3(1);\n\n\tif (d >= maxDist)\n\t{\n\t    fragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tvec3 intP = ro + d*ray;\n    vec3 n = vec3(derivative.x, -derivative.y, 0);\n    n = normalize(n);\n    \n\tvec3 lightDir = normalize(vec3(1,0.5,1));\n\n\tvec3 res = col;\n    \n    float dd = (dot(n, lightDir));\n    dd = remap(0.0, 1.0, 0.5, 1.0, dd);\n    dd = floor(dd * 7.) / 7.;\n    \n    res = mix(vec3(0, .14, .12), vec3(1, 0.84, 0), dd);\n    res = pow(res, vec3(0.7));\n    fragColor = vec4(res,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}