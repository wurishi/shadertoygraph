{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tI've been planning to do something like this for years,\n\tbut I never had the knowledge or time. Today I have both! Oh yeah!\n\n\tInspired by the floating mountains of avatar. \n\tGoing for a more exotic tropical look.\n\n\tInstructions:\n\n\t\t- if you wait you get different ladscapes\n\t\t- click and drag slowly to look around with mouse\n\t\t- wait until water rises and lowers, \n\t\t- if bored with landscape change time_offset parameter\n\t\t- you can pause and look around with mouse\n\t\t- to increase performance reduce iteration count\n\t\t- you can increase precision with high_precision_trace switch\n\n\tScreenshot: http://i.snag.gy/ckSmg.jpg\n\tSoundtrack: http://www.youtube.com/watch?v=aHMmoSX3hhM\n\n\tFeatures:\n\t\n\t\t- mouselook\n\t\t- soft shadows shadows\n\t\t- ambient occlusion\n\t\t- 2 distance fields & 2 materials\n\t\t- lens flare with occlusion\n\t\t- moving clouds & moving lightsource\n\t\t- 3d noise based terrain\n\t\t- 2d texture based mipmapped noise functions\n\t\t- reflection with occlusion\n\t\t- depth of field (nearby objects)\n\t\t- motion blur\n\t\t- post processing\n\t\t- changing water level\n\n\tI'm getting 20-30 fps on nvidia 9800. (not fullscreen)\n\n\tPlease post bugs in comment section!!! \n\tYou can compare the render with my screenshot.\n\tScreenshot again: http://i.snag.gy/ckSmg.jpg\n\n\tHistory:\n\n\t\t- 19/02/2014 published\n\n*/\n\n//parameters\n#define time_offset 0\n#define general_speed 1.0\n#define camera_speed 2.0\n#define trace_iterations 100\n#define light_occlusion_iterations 10\n#define relection_occlusion_iterations 10\n#define flare_occlusion_iterations 20\n\n//switches\n//#define high_precision_trace\n#define motion_blur\n#define render_water\n#define render_terrain\n\n//the following switches exclude each other\n//#define shading_normal_only\n//#define shading_light_occlusion_only\n//#define shading_ambient_occlusion_only\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n\nvec3 air_color = vec3(.3,.45,.6);\nfloat t;\n//dinst2 function computes distance and fog density ;)\n#ifdef render_terrain\nvec2 terra(vec3 p)\n{\n\tfloat q = length(p.xz)*.125;\n\tfloat lod = -16.0;\n\tvec3 nnn = noise(p*.125,lod);\n\tvec3 n1 =  p.y*.0125+nnn*8.0;\n\tvec3 n2 = p.y*.15+noise(p*.25+nnn.y,lod)*4.0;\n\tvec3 n3 = noise(p*vec3(1.0,0.5,1.0)+nnn.z,lod);\n\tfloat d = n1.x+n2.x+n3.x + noise(p.xz*4.10).x*.44*nnn.z;\n\tfloat density  = max(.0,pow(-p.y*.5,2.5)*.2)*(max(.0,pow(n1.y+nnn.z*.5+n2.y*.1,3.0)*.0000016)+.000025);\n\treturn vec2(d,density*.3);\n}\n#else\nvec2 terra(vec3 p)\n{\n\treturn vec2(1024.0*1024.0,.0);\n}\n#endif\n\n#ifdef render_water\nvec2 water(vec3 p)\n{\n\treturn vec2(p.y+38.0-sin(t*.04)*12.0,.0);\n}\n#else\nvec2 water(vec3 p)\n{\n\treturn vec2(1024.0*1024.0,.0);\n}\n#endif\n\nvec2 dist2(vec3 p)\n{\n\tvec2 f1 = terra(p);\n\tvec2 f2 = water(p);\n\treturn vec2(min(f1.x,f2.x),f1.y+f2.y);\n}\n\nfloat dist(vec3 p)\n{\n\treturn dist2(p).x;\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\t#define ambocce 1.9\n\n\tacc+=dist(p+vec3(-ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,+ambocce));\n\treturn 0.5+acc /(16.0*ambocce);\n}\n\nvec3 lensflare(vec2 uv,vec2 pos)\n{\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(-main.x,-main.y);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*32.0+1.0);\n\t\n\tf0 = f0+f0*(sin(noise((pos.x+pos.y)*2.2+ang*4.0+5.954)*16.0)*.1+dist*.1+.8).x;\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc = c*1.3 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c*=(noise(vec3(uv*.7,t*.03712))*.6+.7)*(noise(uv*8.0).y*.4+.9);;\n}\n\nvec3 normal(vec3 p) //returns the normal, uses the distance function\n{\n\tfloat e = .1;\n\tfloat d=dist(p);\n\tvec3 n = normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n\tn = normalize(n*4.0+( noise(p*vec3(2.5,14.5,2.5))-vec3(.5) )*2.0+( noise(p*7.0)-vec3(.5)) );\n\treturn n;\n\t\n}\n\nfloat cloud(vec3 d)\n{\n\tfloat a = .0;\n\tvec2 geo = d.xz/(pow(d.y,.5))*.5;\n\tgeo += + vec2(t*.005);\n\tgeo += noise(geo).yz*.5;\n\ta = (noise(geo*256.0).y)*.02+(noise(geo*08.0).y)*.30;\n\tgeo += noise(geo*4.0).yz*.2;\n\ta = a\n\t\t+(noise(geo*32.0).y)*.07\n\t\t+(noise(geo*16.0).y)*.15\n\t\t+(noise(geo*128.0).y)*.03\n\t\t+(noise(geo*04.0).y)*.60\n\t\t;\n\ta = min(max(.0,a),1.0);\n\treturn a;\n}\n\nvec3 backdrop(vec3 d)\n{\n\tfloat cl = cloud(d);\n\tvec3 ac = air_color*(-d.y*.5+.7);\n\treturn mix(mix(mix(ac,vec3(1.0),pow(cl,5.0)),vec3(.1)+ac*.5,pow(cl,4.0)*.5),ac,.7);;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\n    #ifdef motion_blur\n    t = (iTime + noise(fragCoord.xy).y/24.0 + float(time_offset))*general_speed;\n    #else\n    t = (iTime + float(time_offset))*general_speed;\n    #endif\n\n\t\n\tvec3 p = vec3(.0,.0,8.0);\n\tvec3 d = normalize(vec3(uv,-0.5 ));\n\t\n\t\n\t\n\tmouse.xy+=vec2(.7422+sin(t*.16)*.01,.5+sin(t*.17)*.01);\n\t\n\tmouse*=16.0;\n\t\n\tmat3 rotation = rotate_x(mouse.y)*rotate_y(mouse.x);\n\tmat3 inv_rotation = rotate_y(-mouse.x)*rotate_x(-mouse.y);\n\tp*=rotation; d*=rotation;\n\t\n\tp.x+=t*camera_speed-1.0/(t*.3)-540.0+sin(t*.031)*40.0;\n\tp.y-=24.0;\n\tp.xz+=vec2(sin(t*.12),sin(t*.13))*4.0;\n\t\n\tvec3 start_pos = p;\n\t\n\td+=(noise(uv*iResolution.y)-vec3(.5))*.001;\n\tp+=d*noise(uv*iResolution.y)*.05;\n\t\n\tvec3 c = backdrop(d);\n\t\n\tfloat acc = .0;\n\tfloat ds;\n\tfor (int i=0; i<trace_iterations; i++)\n\t{\n\t\tvec2 distres = dist2(p);\n\t\t#ifdef high_precision_trace\n\t\tfloat ds = distres.x*.5;\n\t\t#else\n\t\tfloat ds = distres.x;\n\t\t#endif\n\t\tfloat de = distres.y;\n\t\tp+=ds*d;\n\t\tacc+=de*ds;\n\t\t//if (ds<.01) break;\n\t\tif (acc>1.0 || ds<.01|| p.y>8.0) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tacc = min(acc,1.0);\n\t\n\tvec3 light = normalize(vec3(sin(t*0.047),1.0-cos(t*.0471)*cos(t*.0271)*.8,cos(t*.0317)));\n\t\n\tfloat flare = dot(d,light)*.5+.5;\n\tc+=pow(flare,800.0)*1.5;\n\t\n\tif (acc<1.0&&dist(p)<2.1)\n\t{\n\t\tfloat od = 1.0;\n\t\tvec3 odir = light;\n\t\tvec3 opos = p+odir;\n\t\t\n\t\t\n\t\tfor (int i=0; i<light_occlusion_iterations; i++)\n\t\t{\n\t\t\tfloat dd = dist(opos);\n\t\t\tod = min(dd*2.0,od);\n\t\t\t#ifdef high_precision_trace\n\t\t\topos+=dd*odir*1.0;\n\t\t\t#else\n\t\t\topos+=dd*odir*2.0;\n\t\t\t#endif\n\t\t\tif (od<.02||opos.y>4.0) break;\n\t\t}\n\t\t\n\t\t\n\t\tod = max(od,.0);\n\t\tvec3 n = normal(p);\n\t\t\n\t\tfloat diffuse = dot(n,light)*.8+.2; \n\t\t\tdiffuse = pow(max(.0,diffuse*od),.7); \n\t\t\tdiffuse = diffuse*.7 + .3;\n\t\t\n\t\tfloat ao = amb_occ(p)*.8+.2;\n\t\t\t\n\t\t\tfloat ao2 = dist(p+n)*1.0*.5+.4;\n\t\t\n\t\tif (terra(p).x<water(p).x)\n\t\t{\n\t\t\t\n\t\t\tfloat shade = (dist(p-d)*.7+.3);\n\t\t\t//float vertical = noise(p*vec3(2.5,14.5,2.5)).y*.5+.5;\n\t\t\t\n\t\t\tfloat top = max(.0,n.y);\n\t\t\tn+=top*noise(p.xz*16.0)*.5;\n\t\t\tn+=top*noise(p.xz*64.0)*.5;\n\t\t\tn=normalize(n);\n\t\t\ttop = max(.0,n.y);\n\t\t\t\n\t\t\tfloat specular  = pow(dot(reflect(d,n),light)*.5+.5,40.0)*od;\n\t\t\t\n\t\t\tc = mix(noise(p*vec3(.1,0.1,.1)),vec3(.6,.4,.2),.5+noise(p)*.6);\n\t\t\tc = mix(c,texture(iChannel1,p.xz*.05).xyz,top);\n\t\t\tc = mix(c,\n\t\t\t\t\tmix(texture(iChannel1,p.xz*.75).xyz,texture(iChannel1,p.xz*.35).xyz,.5)\n\t\t\t\t\t*vec3(.4,.6,.2),top*c.y);\n\t\t\t \n\t\t\tao2=min(ao2,1.0);\n\t\t\t#ifdef shading_normal_only\n\t\t\tc=n*.3+vec3(.3);\n\t\t\t#else\n\t\t\t#ifdef shading_light_occlusion_only\n\t\t\tc=vec3(od*.35+.15);\n\t\t\t#else\n\t\t\t#ifdef shading_ambient_occlusion_only\n\t\t\tc=vec3(ao*ao2*.5);\n\t\t\t#else\n\t\t\tc*=ao*ao2*diffuse;\n\t\t\t#endif\n\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat dterra = terra(p).x;\n\t\t\tvec3 n = vec3(.0,1.0,.0);//*(sin(dterra*16.0)*.5/(1.0+dterra*4.0)+.5);\n\t\t\tn+=(noise(p.xz*8.0+vec2(1.4,-1.3)*t)-.5)*.3;\n\t\t\tn+=(noise(p.xz*16.0+vec2(-1.8,+1.5)*t)-.5)*.3;\n\t\t\tn+=(noise(p.xz*32.0+vec2(1.7,1.5)*t)-.5)*.3;\n\t\t\tn+=(noise(p.xz*256.0+vec2(-1.1,-1.2)*t)-.5)*.3;\n\t\t\tn=normalize(n);\n\t\t\t\n\t\t\tfloat diffuse = dot(n,light)*.5+.5; \n\t\t\tdiffuse = diffuse * od; \n\t\t\tdiffuse = diffuse*.7 + .3;\n\t\t\t\n\t\t\tfloat or = 1.0;\n\t\t\tvec3 odir = reflect(d,n);\n\t\t\tvec3 opos = p+odir;\n\t\t\t\n\t\t\tfor (int i=0; i<relection_occlusion_iterations; i++)\n\t\t\t{\n\t\t\t\tfloat dd = dist(opos);\n\t\t\t\tor = min(dd*1.0,or);\n\t\t\t\t#ifdef high_precision_trace\n\t\t\t\topos+=dd*odir*1.0;\n\t\t\t\t#else\n\t\t\t\topos+=dd*odir*8.0;\n\t\t\t\t#endif\n\t\t\t\tif (or<.02||opos.y>4.0) break;\n\t\t\t}\n\t\t\t\n\t\t\tor = max(.0,or);\n\t\t\tvec3 water_color = vec3(.1,.4,.3);\n\t\t\twater_color = mix(vec3(.1,.4,.3)*.1,vec3(.3,.4,.4),1.0/(0.7+dterra));\n\t\t\twater_color = mix(water_color,noise(p.xz*.2)*.4,.1);\n\t\t\t\n\t\t\tfloat specular = dot(reflect(d,n),light)*.5+.5;\n\t\t\t//specular *= 1.0-cloud(reflect(d,n));\n\t\t\t#ifdef shading_normal_only\n\t\t\tc=n*.3+vec3(.3);\n\t\t\t#else\n\t\t\t#ifdef shading_light_occlusion_only\n\t\t\tc=vec3(od*.35+.15);\n\t\t\t#else\n\t\t\t#ifdef shading_ambient_occlusion_only\n\t\t\tc=vec3(ao*ao2*.5);\n\t\t\t#else\n\t\t\tc = (vec3(.0)\n\t\t\t\t+ backdrop(n)*or \n\t\t\t\t+ water_color*diffuse\n\t\t\t\t+ vec3(pow(specular,4.0)*.3+pow(specular,40.0)*.5+pow(specular,180.0)*1.0)*or\n\t\t\t\t)*ao*ao2;\n\t\t\t\t;\n\t\t\t#endif \n\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t\t//c=vec3(ao*ao2*.2+.4)*(od*.5+.5);\n\t\t\n\t}\n\t\n\tc = mix(c,air_color,acc);\n\t\n\tfloat of = 1.0;\n\t\n\t{\n\t\tvec3 odir = light;\n\t\tvec3 opos = start_pos;\n\t\t\t\t\n\t\tfor (int i=0; i<flare_occlusion_iterations; i++)\n\t\t{\n\t\t\tfloat dd = dist(opos);\n\t\t\tof = min(dd*6.0+0.2,of);\n\t\t\t#ifdef high_precision_trace\n\t\t\topos+=dd*odir*1.0;\n\t\t\t#else\n\t\t\topos+=dd*odir*2.0;\n\t\t\t#endif\n\t\t\tif (of<.02||opos.y>4.0) break;\n\t\t}\n\t}\n\n\tof = max(.0,of);\n\t\n\tvec3 projected_flare = (-light*inv_rotation);\n\tif (projected_flare.z>.0)\n\tc += max(vec3(.0),lensflare(uv*1.2,-projected_flare.xy/projected_flare.z*.6)*projected_flare.z*of);//*(1.0-cloud(light));\n\t\n\t//c = vec3(of);\n\t\n\tc*=1.0+1.0/(1.0+t*4.0);\n\t\n\tc-=length(uv)*.1;\n\tc+=noise(vec3(uv*iResolution.y,iTime*60.0))*0.02;\n\tc=mix(c,vec3(length(c)),length(c)*2.0-1.0);\n\tc = max(vec3(.0),c);\n\t\n\tfragColor = vec4(pow(c,vec3(1.0/1.8)),1.0);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSGDy","date":"1392758281","viewed":7662,"name":"Floating Mountains","username":"mu6k","description":"Look around with mouse! Raymarched noise based terrain. Wait for the water to lower/rise!","likes":124,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raytracing","noise","terrain","blur","lens","shadow","water","volumetric","fog","occlusion","flare","depth","motion"],"hasliked":0,"parentid":"","parentname":""}}