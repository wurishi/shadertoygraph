{"ver":"0.1","info":{"id":"ws2fWG","date":"1590766157","viewed":55,"name":"Rotating Plasma demo #1","username":"movax20h","description":"Just my first shader, some pieces borrowed from here and there.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["oldschool","plasma","pixelize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://www.bidouille.org/prog/plasma\n// Inspired by https://www.shadertoy.com/view/MdXGDH\n// https://www.shadertoy.com/view/4ssGR7 - pixelisation and pallete reduction\n\n#if HW_PERFORMANCE\n#define AA 1\n#else\n#define AA 0\n#endif\n\n#define PI 3.141592654\n\nfloat cc(float x) {\n    return 0.5 + 0.5*cos(x);\n}\n\n// Pixelize?\n//const int ps = 30;\n\n\n// A helper to select two variants of algorithm.\n// Always first.\n// Always second.\n// Left-right side split.\n// Digonal fropm corner to corner.\n// Rotating splitting line.\n\nmat2 rot(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nconst float rot_constant = 0.2;\n\nbool comparator(in vec2 uv1, in vec2 uv2) {\n\t//return true;\n    //return false;\n    //return uv1.x < cc(iTime);\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv3 = vec2((1.0-2.0*uv1.x), (1.0-2.0*uv1.y*aspect));\n    vec2 uv5 = rot(iTime * rot_constant) * uv3;\n    return uv5.x < 0.0;  // Rotating line, independent of the aspect ratio.\n\n    //return uv2.x + uv2.y >= 1.0;  // Diagonal from corner to corner.\n}\n\nvec2 pixelize(int ps, vec2 uv) {\n    // Pixelisation.\n    if (ps > 0) {\n\t   uv.x = float(int(1000.0 * uv.x / float(ps)) * ps) / 1000.0;\n       uv.y = float(int(1000.0 * uv.y / float(ps)) * ps) / 1000.0;\n\t}\n    return uv;\n}\n\nvec2 rotate(vec2 xy, float theta) {\n\treturn rot(theta) * xy;\n}\n\nvec3 palleteMix(vec3 col1, vec3 col2, float p) {\n    vec3 col = mix(col1, col2, p);\n\treturn col;\n}\n\nvec3 palleteReduction(int ps, in vec3 col) {\n    if (ps > 1) {\n        // Reduce color pallet to handful of colors.\n        float dc = float(34 - ps);\n   \t\tcol.r = float(int(col.r * dc)) / dc;\n   \t\tcol.g = float(int(col.g * dc)) / dc;\n   \t\tcol.b = float(int(col.b * dc)) / dc;\n\n    }\n    return col;\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord) {\n    // Correct aspect ratio normalization. Squares are square.\n    vec2 uv1 = fragCoord / max(iResolution.x, iResolution.y);\n        \n    // vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    // vec2 uv1 = uv * aspect;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = fragCoord / iResolution.xy; // Squares are rectangles, not good/\n\n    // Compare two different methods.\n    vec2 uv = comparator(uv1, uv2) ? uv1 : uv2;\n\n    uv = uv1;\n\n    // Slowly vary level of pixelization back from 0 to 32 pixels wide.\n    //int ps = int(10.0 + 22.0 * cc(iTime * 0.833));\n    int ps = 24;\n    if (comparator(uv1, uv2)) {\n        ps = 1;\n    }\n    //int ps = 14;\n\n    // Rotate the uv field itself, so pixels rotate. :)\n    uv.xy = rotate(uv.xy, iTime * rot_constant);\n\n    uv = pixelize(ps, uv);\n\n    \n    /*\n\n    float m = 1.0; //c(10.0*iTime + 50.0*uv.x + 40.0*uv.y);\n\n    //float m1 = c(13.0*uv.x + 14.0*uv.y + c(21.0*iTime));\n    //float m2 = c(30.0*uv.x + 11.0*uv.y + c(9.0*iTime) + c(iTime));\n\n    float m1 = c(13.0*uv.x + 14.0*uv.y + 21.0*iTime);\n    float m2 = c(30.0*uv.x + 11.0*uv.y + 9.0*iTime + c(iTime));\n\n    m *= c(c(m1*1.5) + c(m2*14.0))*0.5;\n\n    //m *= m;\n    //m *= m;\n    \n    float cx = uv.x + 0.5*sin(iTime * 0.2);\n    float cy = uv.y + 0.5*sin(iTime * 0.33333);\n    \n    float m3 = sin(8.0 * sqrt(1.0 + 10.0 * (cx*cx + cy*cy)) + iTime);\n    \n    \n    m *= m3;\n    \n    // Output to screen\n    fragColor = vec4(vec3(1.0, 1.0, 1.0)*m, 1.0);\n\n    */\n    \n\n    float u_time = iTime * 5.0;\n    vec2 u_k = vec2(0.03, 0.03)*(max(200.0, iMouse.x + 200.0)* 0.005);\n    vec2 v_coords = fragCoord;\n    \n    //vec2 c = v_coords * u_k - u_k/2.0;\n    vec2 c = uv / u_k;\n\n    float v = 0.0;\n\n    v += sin((c.x+u_time));\n    v += sin((c.y+u_time)/2.0);\n    v += sin((c.x*cos(2.0*iTime+0.1)+c.y*sin(iTime)+u_time)/2.0);\n    \n    c += 0.5 * u_k * vec2(sin(u_time/3.0), cos(u_time/2.0));\n\n    //v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+u_time);\n    v += sin(length(vec3(c.xy, 1.0)) + u_time);\n\n    v = 0.5 * v;\n\n    // Two different style palletes.\n    vec3 col1 = vec3(0.1, 0.9*sin(PI*v), 0.8*cos(PI*v));\n    vec3 col2 = vec3(0.8*sin(PI*v + 0.9), 0.4, 0.9*cos(PI*v + 0.8));\n\n    // Mix two different color pallets dependend on time.\n    vec3 col = palleteMix(col1, col2, cc(mod(2.0*iTime, 2.0*PI)));\n\n    // Move colors from -1.0 - 1.0 range to 0.0 - 1.0 range.\n    col = col*0.5 + 0.5;\n    \n    // Darken colors a bit.\n    col *= 0.6;\n    \n    // Pallete reduction in linear space.\n    col = palleteReduction(ps, col);\n\n    // Perform gamma correction (poor-mans sRGB).\n    col = pow(col, vec3(0.424242));\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   render(fragColor, fragCoord);\n}\n","name":"Image","description":"","type":"image"}]}