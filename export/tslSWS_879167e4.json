{"ver":"0.1","info":{"id":"tslSWS","date":"1552065084","viewed":530,"name":"4xhalfres temporal supersampling","username":"public_int_i","description":"4x temporal super sampling on the right, click to move comparison slider","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["aliasing","supersampling","anti","temporal","resolution","half"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Image - Temporal supersampling blending.\n\nThis method renders frames at half resolution with jittered uvs then combines the past 4\nframes for supersampling resulting in anti-aliasing/motion blur and the appearance of a \nhigher resolution.\n\nCredit to Timothy Lottes, I found this on his Twitter.\nI'm guessing he deleted his twitter I can't find it anymore?\n*/\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 uv = u*.5/(iResolution.xy+.5);\n    \n    //comparison slider\n    float sx = iMouse.w>0.?iMouse.x:iResolution.x*.5;\n    if (u.x <= sx) {\n        o = textureLod(iChannel0,uv,0.);\n        if (sx-u.x < 4.) o = vec4(.3);\n    \treturn;\n    }\n\n    //blend half resolution frames\n    o = (textureLod(iChannel0,uv,0.)+\n         textureLod(iChannel0,uv+vec2(.5,0),0.)+\n         textureLod(iChannel0,uv+vec2(0,.5),0.)+\n         textureLod(iChannel0,uv+.5,0.))/4.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*Buf A - Renders spinning block and circle at half resolution in one corner and\ncopies past frames into other corners.*/\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 hr = iResolution.xy*.5,\n        fuv = floor(u/hr),\n        muv = u-fuv*hr;\n    float id = dot(fuv,vec2(1,2));\n    if (id < 1.) {\n        //aspect correct uv and jitter for supersampling\n        vec2 uv = muv*2.-hr;\n        float sx = iMouse.w>0.?iMouse.x*.5:hr.x*.5;\n        if (u.x > sx) {\n            #define jd .8\n            vec2 jitter[4] = vec2[](vec2(-jd), vec2(jd),vec2(-jd*.7,jd),vec2(jd,-jd*.7));\n            uv += jitter[iFrame%4];\n        }\n        uv /= hr.y;\n\n        //spinning block\n        mat2 r = rot(iTime*.3);\n        float d = length(max(abs(uv*r)-.2,0.));\n        //floating circle\n        d = min(d,length(uv+sin(iTime*vec2(1.93,.74)))-.2);\n        o = vec4(max(0.,1.-max(0.,d)*1e7));\n    } else {\n       \t//copy last frames\n        id--;\n        o = texelFetch(iChannel0,ivec2(muv+vec2(mod(id,2.),floor(id/2.))*hr),0);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}