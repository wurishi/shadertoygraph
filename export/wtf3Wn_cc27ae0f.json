{"ver":"0.1","info":{"id":"wtf3Wn","date":"1556194249","viewed":957,"name":"Fire tornado","username":"skaplun","description":"Based on animations made by Cody Winchester(@CodyWinch)\nBloom effect borrowed from  robobo1221\nInteractive","likes":44,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","voronoi","noise","postprocessing","animation","bloom","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define colorRange 36.0\nfloat bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).a;\n}\n\nfloat getBloom(vec2 uv){\n    float blur = 0.;\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv), 2.2)       \t   + blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv), 2.2) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv), 2.2) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv), 2.2) * 1.9 \t   + blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv), 2.2) * 2.2 \t   + blur;\n    return blur * colorRange;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if(colorize(screnSpace(fragCoord.xy, iResolution.xy), iTime)){\n    \tfragColor = vec4(mix(texture(iChannel0, uv).rgb, vec3(2.75, 2., .2), pow(getBloom(uv), .66)), 1.);\n    }else{\n\t\tfragColor = vec4(texture(iChannel0, uv).rgb, 1.);\n    }\n    fragColor.rgb *= stripe(screnSpace(fragCoord.xy, iResolution.xy), iTime);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Cylinder{vec3 A, B;float r;};\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n\n//Noise\nvec2 hash(vec2 p){\n    p = mod(p, 4.); \n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 getVoronoi(vec2 x, float time){\n    vec2 n = floor(x),\n         f = fract(x),\n         mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ ){\n        for( int i=-1; i<=1; i++ ){\n            vec2 g=vec2(float(i),float(j));\n            vec2 o=0.5+0.5*sin(time + 6.2831*hash(n+g));\n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            if( d<md ) {md=d;mr=r;}\n\t\t}\n    }\n    return vec3(md,mr);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n//geometry\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 getCylAtPos(float yFactor, float time){\n\tyFactor += 1.;\n    float s = cos(yFactor * 1.25 + 2.) + .75 + exp(-10. * yFactor);\n    return  vec3(vec2(fbm1x(yFactor, time),\n                 \t  fbm1x(yFactor + 78.233, time)) * (.5 + .2*yFactor), .5 + s);\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nfloat sdCylinder(vec3 p, vec3 c){\n  return length(p.xz - c.xy) - c.z;\n}\n\nbool cylinderVSline(const in Ray ray, const in Cylinder cyl, inout HitRecord rec) {\n    // Solution : http://www.gamedev.net/community/forums/topic.asp?topic_id=467789\n    float cxmin, cymin, czmin, cxmax, cymax, czmax;\n    if (cyl.A.z < cyl.B.z) {\n        czmin = cyl.A.z - cyl.r;\n        czmax = cyl.B.z + cyl.r;\n    } else {\n        czmin = cyl.B.z - cyl.r;\n        czmax = cyl.A.z + cyl.r;\n    }\n    if (cyl.A.y < cyl.B.y) {\n        cymin = cyl.A.y - cyl.r;\n        cymax = cyl.B.y + cyl.r;\n    } else {\n        cymin = cyl.B.y - cyl.r;\n        cymax = cyl.A.y + cyl.r;\n    }\n    if (cyl.A.x < cyl.B.x) {\n        cxmin = cyl.A.x - cyl.r;\n        cxmax = cyl.B.x + cyl.r;\n    } else {\n        cxmin = cyl.B.x - cyl.r;\n        cxmax = cyl.A.x + cyl.r;\n    }\n\n    vec3 AB = cyl.B - cyl.A;\n    vec3 AO = ray.origin - cyl.A;\n    vec3 AOxAB = cross(AO, AB);\n    vec3 VxAB  = cross(ray.direction, AB);\n    float ab2 = dot(AB, AB);\n    float a = dot(VxAB, VxAB);\n    float b = 2. * dot(VxAB, AOxAB);\n    float c = dot(AOxAB, AOxAB) - (cyl.r * cyl.r * ab2);\n    float d = b * b - 4. * a * c;\n    if (d < 0.)\n        return false;\n    float[2] coef = float[2](1., -1.); \n    for(int i=0; i<2; i++){\n\t    float time = (-b - coef[i] * sqrt(d)) / (2. * a);\n\n        rec.dist[i] = time;\n        rec.ptnt[i] = ray.origin + ray.direction * time;\n        rec.nrm[i] = normalize(rec.ptnt[i] - vec3(0., rec.ptnt[i].y, 0.));\n    }\n    return true;\n}\n\nvec2 screnSpace(vec2 coord, vec2 res){\n\treturn (2. * coord - res)/res.y;\n}\n\nbool colorize(vec2 uv, float time){\n\ttime *= .5;\n    return step(.75, abs((uv.x - uv.y * .25 + .125) - sin(time) * 3.)) > 0.;\n}\n\nfloat stripe(vec2 uv, float time){\n\ttime *= .5;\n    return smoothstep(.01, .02, abs(abs((uv.x - uv.y * .25 + .125) - sin(time) * 3.) - .75));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_MARCHING_STEPS 128\n#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define BUMP_STRENGTH .3\n#define colorRange 12.0\n\nfloat world(vec3 p){\n    vec3 cyl = getCylAtPos(p.y, iTime);\n    vec2 point = vec2(atan(p.x - cyl.x, p.z - cyl.y)  * 4./6.2831 - p.y * 4., p.y - iTime) * 2.;\n    float n = getVoronoi(point, iTime).x * BUMP_STRENGTH;\n    return sdCylinder(p, cyl - vec3(0., 0., n));\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = world(eye + depth * marchingDirection);\n        if (dist < MIN_FLOAT) {\n            return depth;\n        }\n        depth += dist * .5;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a = (iResolution.x - iMouse.x) * .05;\n    vec3 eye = vec3(7.5 * sin(a), -.5, 7.5 * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    float baseDist;\n    if(plane_hit(eye, worldDir, vec3(0., -1., 0.), vec3(0., -1., 0.), baseDist)){\n    \tvec3 p = eye + worldDir * baseDist;\n        float f = mod(floor(p.z) + floor(p.x), 2.);\n        color = .4 + f * vec3(.6);\n    }else{\n    \tbaseDist = MAX_FLOAT;\n    }\n    \n    float glow = 0.;\n    float dist = march(eye, worldDir, MIN_DIST, MAX_DIST);\n    if (dist < MAX_DIST - MIN_FLOAT && dist <= baseDist) {\n        baseDist = dist;\n        vec3 p = (eye + dist * worldDir);\n        vec3 cyl = getCylAtPos(p.y, iTime);\n        float bump = 1. - (cyl.z - distance(p.xz, cyl.xy))/(BUMP_STRENGTH*.5);\n        if(colorize(screnSpace(fragCoord.xy, iResolution.xy), iTime)){\n        \tglow = step(bump, .35);\n            vec3 clr = vec3(min(.1, glow));\n            color = mix(color, clr, smoothstep(-1., -.9, p.y));\n        }else{\n\t\t\tcolor = vec3(bump);\n        }\n    }\n    \n    float yFactor = (eye + dist * worldDir).y;\n    HitRecord rec;\n    Cylinder cyl = Cylinder(vec3(0.), vec3(0., 1., 0.), 2. - sin(yFactor * .75 + 1.) * .66);\n    if(cylinderVSline(Ray(eye, worldDir), cyl, rec)){\n        for(int i=0; i<2; i++){\n\t\t\tif((rec.dist[i] < baseDist)){\n                float ang = atan(rec.ptnt[i].x, rec.ptnt[i].z);\n                float f = getVoronoi(vec2(ang - rec.ptnt[0].y * 2.5, rec.ptnt[0].y - iTime * 2.) * 4./6.2831, iTime * .1).x;\n                float a = smoothstep(.4, .5, pow(f, .75)) * (.1 + smoothstep(-1., 2., yFactor) * .1);\n                if(colorize(screnSpace(fragCoord.xy, iResolution.xy), iTime)){\n                \tcolor = mix(color, vec3(.3, .7, 1.), a);\n                \tglow *= 1. - a;\n                }else{\n\t\t\t\t\tcolor += step(.1, a);\n                }\n        \t}\n        }\n    }\n    \n    fragColor = vec4(color, pow(glow, 1. / 2.2) / colorRange);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float makeBloom(float lod, vec2 offset, vec2 bCoord){\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    offset += pixelSize;\n    float lodFactor = exp2(lod);\n    float bloom = 0.;\n    vec2 scale = lodFactor * pixelSize;\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return 0.;\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n            bloom = pow(texture(iChannel0, vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).a, 2.2)*wg + bloom;\n            totalWeight += wg;\n        }\n    }\n    bloom /= totalWeight;\n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\t  blur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\t  blur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\t  blur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\t  blur += makeBloom(6.,vec2(0.2,0.3), uv);\n\t\n    fragColor = vec4(texture(iChannel0, uv).rgb, pow(blur, 1. / 2.2));\n}","name":"Buffer B","description":"","type":"buffer"}]}