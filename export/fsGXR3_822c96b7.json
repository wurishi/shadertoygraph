{"ver":"0.1","info":{"id":"fsGXR3","date":"1634995951","viewed":84,"name":"CAGradientLayer: Axial","username":"barton","description":"Possible implementation for rendering CAGradientLayer with Axial gradient type like Core Animation framework.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradient","layer","calayer","cagradientlayer","axial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// CAGradientLayer Rendering (Axial)\n// \n// This shader shows possible implementation for rendering CAGradientLayer\n// with Axial gradient type.\n//\n// There is such framework like Core Animation for iOS/macOS.\n// In iOS/macOS CAGradientLayer will be ceated like:\n//\n// let targetLayer = CAGradientLayer()\n// targetLayer.type = .axial\n// targetLayer.colors = [UIColor.blue, UIColor.green, UIColor.red].map({ $0.cgColor })\n// targetLayer.locations = [0, 0.5, 1]\n// targetLayer.startPoint = CGPoint(x: 0.0, y: 0.0)\n// targetLayer.endPoint = CGPoint(x: 1.0, y: 1.0)\n// targetLayer.bounds = CGRect(x: 0, y: 0, width: 700, height: 700)\n// targetLayer.position = CGPoint(x: view.bounds.size.width/2, y: view.bounds.size.height/2)\n// targetLayer.cornerRadius = 500\n// targetLayer.maskedCorners = [.layerMinXMaxYCorner, .layerMaxXMinYCorner]\n// targetLayer.borderWidth = 30\n// targetLayer.borderColor = UIColor.yellow.cgColor\n// view.layer.addSublayer(targetLayer)\n//\n// By some reason the radius could be greater than some critical value and layer's shape\n// will start changing. But as I used SDF algorithm for rounded corners they will get form\n// changes but what about unmasked corners? Unmasked corners should be changed as well.\n// This shader handles such case.\n//\n//---------------------------------------------------\n//\n// In case of using Metal this shader will look like:\n//\n// float4 makeAxialGradientColor(float2 uv, GradientUniform gradientUniform, const device float4 *colors, const device float *locations) {\n//     uv = float2(uv.x, 1 - uv.y);\n//    \n//     float2 startPoint = gradientUniform.startPoint;\n//     float2 endPoint = gradientUniform.endPoint;\n//\n//     float2 pt = uv - startPoint;\n//     float2 dt = endPoint - startPoint;\n//     float t = dot(pt, dt)/dot(dt, dt);\n//\n//     return makeInterpolateColor(colors, locations, gradientUniform.stops, t);\n// }\n//\n// fragment half4 gradient_axial_fragment(GradientVertexOutput input [[ stage_in ]],\n//                                        constant LayerUniform &layerUniform [[ buffer(0) ]],\n//                                        constant GradientUniform &gradientUniform [[ buffer(1) ]],\n//                                        const device float4 *colors [[ buffer(2) ]],\n//                                        const device float *locations [[ buffer(3) ]]) \n// {\n//     \n//     float4 color = makeAxialGradientColor(input.uv, gradientUniform, colors, locations);\n//     float mask = makeRoundedRectBackgroundMask(input.uv, layerUniform);\n//     \n//     return half4(color.r, color.g, color.b, color.a * mask);\n// }\n\n#define kTopLeftCorner      0x1\n#define kTopRightCorner     0x2\n#define kBottomLeftCorner   0x4\n#define kBottomRightCorner  0x8\n\nstruct LayerUniform {\n    vec2 size;\n    float cornerRadius;\n    int maskedCorners;\n    float borderWidth;\n    vec4 borderColor;\n    float opacity;\n};\n\nstruct GradientUniform {\n    vec2 startPoint;\n    vec2 endPoint;\n    int stops;\n};\n\n// In real situation these constants will come in fragment shader as reference to corresponding\n// buffers and it will not exist such way. Just example for ShaderToy.\nconst vec4 colors[3] = vec4[](vec4(0, 0, 1, 1), vec4(0, 1, 0, 1), vec4(1, 0, 0, 1));\nconst float locations[3] = float[](0.0, 0.5, 1.0);\n\n// Calculate SDF for rect by size.\nfloat sdfRect(vec2 point, vec2 size) {\n    vec2 q = abs(point) - size/2.0;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\n// Calculate SDF for rect by size with corner radius.\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius) {\n    vec2 q = abs(point) - size/2.0 + cornerRadius;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - cornerRadius;\n}\n\n// Calculate SDF for rect with corner radius and masked corners;\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius, int maskedCorners) {\n    if (maskedCorners == 0) {\n        return sdfRect(point, size);  \n    } else if ((point.x < 0.0 && point.y > 0.0) && (maskedCorners & kTopLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y > 0.0 && (maskedCorners & kTopRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x < 0.0 && point.y < 0.0 && (maskedCorners & kBottomLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y < 0.0 && (maskedCorners & kBottomRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    }\n    \n    float d1 = sdfRect(vec2(point.x, 0), size, cornerRadius);\n    float d2 = sdfRect(vec2(0, point.y), size, cornerRadius);\n    \n    return max(d1, d2);\n}\n\nfloat makeBackgroundMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    \n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask = smoothstep(0.8, -0.8, d + 0.16);\n    \n    return mask;\n}\n\nfloat makeBorderdMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    float borderWidth = layerUniform.borderWidth;\n\n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask1 = smoothstep(d - 0.8, d + 0.8, 0.16);\n    float mask2 = smoothstep(abs(d) - 0.8, abs(d) + 0.8, borderWidth - 0.16);\n    \n    return mask1 * mask2;\n}\n\n// Under Metal the interpolate fuction will use pointers for colors and locations.\nvec4 makeInterpolateColor(vec4[3] colors, float[3] locations, int count, float location) {\n    int lower = 0;\n    int upper;\n    \n    for (upper = 0; upper < count; upper++) {\n        if (locations[upper] > location) {\n            break;\n        }\n\n        lower = upper;\n    }\n    \n    float numerator = location - locations[lower];\n    float denominator = locations[upper] - locations[lower];\n    float fraction = denominator != 0.0 ? clamp(numerator / denominator, 0.0, 1.0) : 0.0;\n    \n    return mix(colors[lower], colors[upper], fraction);\n}\n\n// Under Metal the gradient_axial fuction will use pointers for colors and locations.\nvec4 makeAxialGradientColor(vec2 uv, GradientUniform gradientUniform, vec4[3] colors, float[3] locations) {\n    uv.y = 1.0 - uv.y; // For CoreAnimation 0.0, 0.0 will be at the top left corner. \n    \n    vec2 startPoint = gradientUniform.startPoint;\n    vec2 endPoint = gradientUniform.endPoint;\n    \n    vec2 dt = endPoint - startPoint;\n    vec2 pt = uv - startPoint;\n    float t = dot(pt, dt)/ dot(dt, dt);\n    \n    return makeInterpolateColor(colors, locations, gradientUniform.stops, t);\n}\n\n// Some extra function for extra code addition.\nfloat normalizeInRange(float value, float minValue, float maxValue) {\n    return (value - minValue)/(maxValue - minValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float initialRadius = 500.0;\n    float upadtedRadius = abs(initialRadius * sin(iTime * 0.5));\n\n    // Input uniform for fragment shader.\n    LayerUniform layerUniform;\n    layerUniform.size = vec2(700, 700);\n    layerUniform.cornerRadius = upadtedRadius;\n    layerUniform.maskedCorners = kTopLeftCorner | kBottomRightCorner;\n    //layerUniform.maskedCorners = kTopLeftCorner | kTopRightCorner | kBottomLeftCorner | kBottomRightCorner;\n    layerUniform.borderWidth = 30.0;\n    layerUniform.borderColor = vec4(1, 1, 0, 1);\n    layerUniform.opacity = 1.0;\n    \n    // Input uniform for fragment shader.\n    GradientUniform gradientUniform;\n    gradientUniform.startPoint = vec2(0.0, 0.0);\n    gradientUniform.endPoint = vec2(1.0, 1.0);\n    gradientUniform.stops = 3;\n    \n    vec2 uv = (fragCoord/iResolution.xy) - 0.5;\n    \n    float backgroundMask = makeBackgroundMask(uv, layerUniform);\n    float borderMask = makeBorderdMask(uv, layerUniform);\n    \n    // Some extra code to make gradient inside current layer. In real situation such extra code\n    // will not exist at all.\n    vec2 center = vec2(0.5) * iResolution.xy;\n    float startX = center.x - layerUniform.size.x/2.0;\n    float endX = center.x + layerUniform.size.x/2.0;\n    float normalX = normalizeInRange(fragCoord.x, startX, endX);\n    \n    float startY = center.y - layerUniform.size.y/2.0;\n    float endY = center.y + layerUniform.size.y/2.0;\n    float normalY = normalizeInRange(fragCoord.y, startY, endY);\n    \n    if ((normalX >= 0.0) && (normalX <= 1.0) && (normalY >= 0.0) && (normalY <= 1.0)) {\n        vec2 uvUpdated = vec2(normalX, normalY);\n        \n        vec4 gradientColor = makeAxialGradientColor(uvUpdated, gradientUniform, colors, locations);\n        vec4 c1 = mix(vec4(0), gradientColor, backgroundMask);\n        vec4 c2 = mix(c1, layerUniform.borderColor, borderMask);\n        \n        fragColor = c2;\n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}