{"ver":"0.1","info":{"id":"4XjBWG","date":"1730149487","viewed":51,"name":"PT-0: Understanding BSDF PDF LTE","username":"kastanileel","description":"This shader was created to gain an understanding of the mathematically correct application of the light transport equation.\n-Each object has a Lambertian diffuse material\n-The PDF used for sampling directions can be switched with the SAMPLE_UNIFORM flag.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["path","bsdf","pdf","lte"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Resources:\n// - https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html\n// - https://pbr-book.org/4ed/Light_Transport_I_Surface_Reflection/The_Light_Transport_Equation\n// - https://pbr-book.org/4ed/Monte_Carlo_Integration\n// - https://www.shadertoy.com/view/4tl3z4\n// - https://iquilezles.org/articles/intersectors/\n\n// BUFFER A: Raytracing stuff\n// COMMON: Helper functions & structs\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159f\n#define EPSILON 0.0001\n//-----------------------------------------------------\n// Random functions\n//-----------------------------------------------------\n\nfloat hash1(inout float seed) {\n    seed = seed + 0.1f;\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    seed = seed + 0.1f;\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    seed = seed + 0.1f;\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\nvec2 antiAliasingOffset(inout float seed, vec2 resolution){\n    return hash2(seed);\n}\n\nvec3 randomCosineDirectionHemisphere(inout float seed){\n    vec2 rr = hash2(seed);\n    \n    float phi = 2.0*PI*rr.x;\n    float x = cos(phi)*sqrt(rr.y);\n    float y = sin(phi)*sqrt(rr.y);\n    float z = sqrt(1.0-rr.y);\n    \n    return vec3(x, y, z);\n}\n\nvec3 randomUniformDirectionSphere(inout float seed){\n    vec2 rr = hash2(seed);\n  \n    float x = cos(2.0f*PI*rr.x) * 2.0f * sqrt(rr.y*(1.0-rr.y));\n    float y = sin(2.0f*PI*rr.x) * 2.0f * sqrt(rr.y*(1.0-rr.y));\n    float z = 1.0 - 2.0*rr.y;\n\n    return normalize(vec3(x, y, z));\n}\n//-----------------------------------------------------\n// Structs\n//-----------------------------------------------------\nstruct ONB {\n    vec3 u, v, w;\n};\n\nONB buildONB(vec3 normal){\n    ONB onb;\n    onb.w = normal;\n    \n    // make sure a is nonparallel to onb.w\n    vec3 a = vec3(1.0f, 0.0f, 0.0f);\n    if(abs(onb.w.x) > 0.9f){\n        a = vec3(0.0f, 1.0f, 0.0f);\n    }\n    \n    onb.v = normalize(cross(onb.w, a));\n    onb.u = cross(onb.w, onb.v);\n    \n    return onb;\n}\n\nvec3 onbTransform(ONB onb, vec3 vector) {\n    return onb.u * vector.x + onb.v * vector.y + onb.w * vector.z;\n}\n\nstruct Material {\n    vec3 emission;\n    vec3 albedo;\n};\n\nvec3 evaluateLambertianBRDF(Material material, vec3 theta_out, vec3 normal, vec3 theta_in){\n    return material.albedo/PI;\n}\n\nvec3 sampleCosineWeighted(vec3 theta_out, vec3 normal, inout float pdf, inout float seed) {\n    ONB onb = buildONB(normal);\n    vec3 scatterDirection = onbTransform(onb, randomCosineDirectionHemisphere(seed));\n    \n    pdf = max(EPSILON, dot(normalize(scatterDirection), normal))/PI;\n    \n    return normalize(scatterDirection);\n}\n\nvec3 sampleUniform(vec3 theta_out, vec3 normal, inout float pdf, inout float seed) {\n   \n    vec3 scatterDirection = randomUniformDirectionSphere(seed);\n    \n    if( dot(scatterDirection, normal) < 0.0f)\n        scatterDirection = -scatterDirection;\n        \n    pdf = 1.0f/(2.0f*PI);\n    \n    return normalize(scatterDirection);\n}\n\nbool isEmitter(Material material) {\n    return length(material.emission) > 0.0f;\n}\n\nstruct Payload {\n    vec3 throughput;\n    vec3 accumulatedColor;\n    int bounces;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    Payload payload;\n};\n\nstruct Camera {\n    vec3 origin;\n    vec3 forward;\n    vec3 up;\n    vec3 right;\n};\n\nstruct HitRecord {\n    vec3 point;\n    vec3 normal;\n    int primitiveID;\n    bool didHit;\n};\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in Ray ray, in vec4 sph ) {\n    vec3 oc = ray.origin - sph.xyz;\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in Ray ray, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ray.origin)) / dot( pla.xyz, ray.direction );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_BOUNCES 6\n#define SAMPLE_UNIFORM true\n\n#define NUM_SPHERES 2\n#define NUM_PLANES 5\n\nvec4 spheres[NUM_SPHERES];\nvec4 planes[NUM_PLANES];\nMaterial materials[NUM_SPHERES+NUM_PLANES];\nCamera camera;\n\nvoid initialize() {\n    // Camera\n    camera.origin = vec3(0.0f, 1.0f, 1.0f);\n    camera.forward = normalize(vec3(0.0f, 0.0f, -1.0f));\n    camera.up = normalize(vec3(0.0f, 1.0f, 0.0f));\n    camera.right = normalize(vec3(1.0f, 0.0f, 0.0f));\n    \n    // Cornell Box\n    spheres[0] = vec4(0.5f, 0.5f, -0.5f, 0.5f);\n    spheres[1] = vec4(-1.0f, 1.5f, -0.5f, 0.4f);\n    planes[0] = vec4( 0.0, 0.0,1.0,2.0);    \n    planes[1] = vec4( 0.0, 1.0,0.0,0.0);    \n    planes[2] = vec4( 1.0, 0.0,0.0,2.0);\n    planes[3] = vec4( -1.0, 0.0,0.0,2.0);\n    planes[4] = vec4( 0.0, -1.0, 0.0,3.0);\n    \n    materials[0] = Material(vec3(0.0f), vec3(0.75f));    \n    materials[1] = Material(vec3(16.86, 10.76, 8.2)*1.3f, vec3(0.0f));\n    materials[2] = Material(vec3(0.0f), vec3(.7295, .7355, .729));   \n    materials[3] = Material(vec3(0.0f), vec3(.7295, .7355, .729));\n    materials[4] = Material(vec3(0.0f), vec3(.117, .4125, .115));\n    materials[5] = Material(vec3(0.0f), vec3(.611, .0555, .062));\n    materials[6] = Material(vec3(0.0f), vec3(.7295, .7355, .729));\n\n}\n\nRay raygen(vec2 uv, inout float seed) {\n    Ray ray;\n   // uv += antiAliasingOffset(seed, iResolution.xy);\n    ray.origin = camera.origin;\n    ray.direction = normalize(((camera.origin+camera.forward) + camera.right * uv.x + camera.up *uv.y)-camera.origin);\n    \n    Payload payload;\n    payload.throughput = vec3(1.0f);\n    payload.accumulatedColor =vec3(0.0f);\n    payload.bounces = 0;\n    ray.payload = payload;\n    \n    return ray;\n}\n\nHitRecord intersectScene(Ray ray) {\n    HitRecord hit;\n    \n    int primitiveID = -1;\n    float t = 1e20;\n    vec3 normal;\n    \n    for(int i = 0; i < NUM_SPHERES; i++){\n        float it = iSphere( ray, spheres[i] );\n        if( it > EPSILON && it < t ) {\n            t = it;\n            normal = nSphere(ray.origin + ray.direction * t, spheres[i] ); \n            primitiveID = i;\n        }\n    }\n\t\n    for(int i = NUM_SPHERES; i < NUM_SPHERES+NUM_PLANES; i++){\n        float it = iPlane(ray, planes[i-NUM_SPHERES]);\n        if( it > EPSILON && it < t ) {\n            t = it;\n            normal = nPlane(ray.origin + ray.direction * t, planes[i-NUM_SPHERES] ); \n            primitiveID = i;\n        }\n    }\n    \n    hit.point = ray.origin + ray.direction * t;\n    hit.normal = normalize(normal);\n    hit.primitiveID = primitiveID;\n    hit.didHit = primitiveID != -1;\n\t\t\t\t\t  \n    return hit;\t\t\t\t\t  \n}\n\n\nvoid closestHit(inout Ray ray, in HitRecord hit, inout float seed) {\n    \n    Material material = materials[hit.primitiveID];\n    \n   if (isEmitter(material)) {\n        ray.payload.accumulatedColor += material.emission * ray.payload.throughput;\n        ray.payload.bounces = MAX_BOUNCES;\n        return;\n    }\n    \n    float pdf;\n    vec3 sampledDirection;\n    if(SAMPLE_UNIFORM) \n        sampledDirection = sampleUniform(-ray.direction, hit.normal, pdf, seed);\n     else\n        sampledDirection = sampleCosineWeighted(-ray.direction, hit.normal, pdf, seed);\n        \n    vec3 brdf = evaluateLambertianBRDF(material, -ray.direction, hit.normal, sampledDirection); \n    float cos_theta = max(0.0f, dot(sampledDirection, hit.normal));\n      \n    ray.payload.throughput *= (brdf * cos_theta)/pdf;\n    ray.origin = hit.point + hit.normal * EPSILON; \n    ray.direction = sampledDirection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord*2.0f)/iResolution.xy - 1.0f;\n    uv.x *= iResolution.x/iResolution.y;\n    float seed = uv.x + uv.y * 3.43121412313 + fract(1.12345314312*iTime);\n\n    initialize(); \n    Ray ray = raygen(uv, seed);\n\n    while(ray.payload.bounces < MAX_BOUNCES){\n\n       HitRecord hit = intersectScene(ray);\n       if (!hit.didHit)\n           break;\n\n       closestHit(ray, hit, seed);\n       ray.payload.bounces += 1;\n    }\n    \n    vec3 previousColor = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float ratio = 1.0f/(float(iFrame+1));\n    vec3 accumulatedColor = ratio * ray.payload.accumulatedColor + (1.0f-ratio)*previousColor;\n    \n    fragColor.xyz = accumulatedColor;\n}","name":"Buffer A","description":"","type":"buffer"}]}