{"ver":"0.1","info":{"id":"wtj3Wm","date":"1559860656","viewed":169,"name":"Infinite plane fractal","username":"HalfHeuslerAlloy","description":"Trying to generate an infinite plane of fractals","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ambient Light\n#define AmbientI  vec3(0.2,0.1,0.4)\n//Sun colour\n#define White vec3(1.0,0.7,0.4)\n//Fog rate\n#define FogRate 0.01\n\n//Alpha is reflection strenght\n#define Alpha 20.0\n//ColOffset\n#define ColOffset 6.0\n//ColRate\n#define ColRate 1.0\n\n//camera height\n#define ZHieght 2.0\n\n//Curvature\n#define Curve 0.005\n\n//Speed\n#define SpeedSetting vec3(2.0,2.0,1.0)\n//Time Offset\n#define StrT 0.0\n\n// Turn on anti-aliasing, sort off doesn't work right now, very very slow\n//#define AntiAliasing\n\nfloat ChaosFunc(vec3 P){\n    float Time = (P.x*0.103+sin(P.x*0.4)+P.y*0.051+sin(P.y*0.5))*5.0 + 0.0;\n    return Time;\n}\n\n\nvec2 FoldedFractal(vec3 P)\n{\n    \n    float Time = ChaosFunc(P);\n    \n    P.xy=mod(P.xy,1.0)-0.5;\n    \n    P.z = P.z * (1.0+0.5*sin( Time*0.32374681732 ));\n    \n    float i = 0.0;\n    float Col = 999.0;\n    \n    float NormL = 0.0;\n    \n    float Spd = 1.0;\n    float Str = 0.0;\n    \n    \n    float Scale = 1.7+0.3*sin(Time*0.1316);\n    //float Scale = min(abs(P.z)/2.0+1.05,2.0);\n    \n    vec3 Offset = normalize( vec3(0.8+0.3*sin(Time*0.5113),\n                                  0.8+0.3*sin(Time*0.3251),\n                                  0.5+0.3*sin(Time*0.4338)));\n    \n    float Ang1 = 3.141592/4.0+0.2*sin(Time*0.1381);\n    \n    float Ang2 = 0.1*sin(Time*0.1135);\n    \n    mat2 Rot1 = mat2(cos(Ang1),-sin(Ang1),\n                     sin(Ang1), cos(Ang1));\n    mat2 Rot2 = mat2(cos(Ang2),-sin(Ang2),\n                     sin(Ang2), cos(Ang2));\n    \n    \n    while((i<40.0)&&(P.x*P.x+P.y*P.y+P.z*P.z<40.0)){\n        \n        i += 1.0;\n        \n        P=abs(P);\n        \n        //P = Scale*P - Offset*(Scale-1.0);\n        \n        P.xz = Rot2 * P.xz;\n        P.yx = Rot1 * P.yx;\n        \n\t\tif(P.x-P.y < 0.0){P.xy = P.yx;}\n\t\tif(P.x-P.z < 0.0){P.xz = P.zx;}\n\t\tif(P.y-P.z < 0.0){P.yz = P.zy;}\n        \n        Col=min(Col,P.x*P.x+P.y*P.y+P.z*P.z);\n        \n        P.z = abs(P.z);\n        \n        P = Scale*P - Offset*(Scale-1.0);\n        \n        \n    }\n    \n    return vec2((length(P)-2.0)/pow(Scale,i),Col);\n}\n\nvec2 DisEstTorus(vec3 P)\n{\n    const float Rmajor = 0.5;\n    const float Rminor = 0.2;\n    \n    float Dis = length(P.xy) - Rmajor;\n    \n    return vec2(length(vec2(Dis,P.z))-Rminor,0.0);\n}\n\nvec2 DisEst(vec3 P)\n{\n    \n    vec2 Ret = FoldedFractal(P);\n    \n    //return Ret; // No Floor\n    \n    return vec2( (min(Ret.x,abs(P.z))) , Ret.y); //Floor\n}\n\n\nfloat Shadows(vec3 P)\n{\n    const float k = 10.0; //Shadow Softness\n    \n    const vec3 LightRay = vec3(1.0,-1.0,-1.0)/sqrt(3.0);\n    \n    float I = 1.0;\n    \n    float Dis = DisEst(P).x;\n    \n    P += LightRay * Dis;\n    \n    float TotalDis = Dis;\n    \n    int Steps = 0;\n    \n    while( (Steps<100) && (Dis<3.0) && (I>0.001))\n    {\n        Steps+=1;\n        \n        Dis = DisEst(P).x;\n        \n        I = min(I,k*Dis/TotalDis);\n        \n        P=P+LightRay*Dis;\n        \n        TotalDis+=Dis;\n    }\n    return I;\n    \n}\n\nvec3 SurfNorm(vec3 P)\n{\n    float Delta=DisEst(P).x*2.0;\n    \n    vec3 Delx= vec3(Delta,0.0,0.0);\n    vec3 Dely= vec3(0.0,Delta,0.0);\n    vec3 Delz= vec3(0.0,0.0,Delta);\n    \n    vec3 Norm = vec3(0.0,0.0,0.0);\n    \n    Norm.x = DisEst(P+Delx).x-DisEst(P-Delx).x;\n    Norm.y = DisEst(P+Dely).x-DisEst(P-Dely).x;\n    Norm.z = DisEst(P+Delz).x-DisEst(P-Delz).x;\n        \n    Norm=Norm/length(Norm);\n    return Norm;\n}\n\nvec3 PhongLighting(vec3 P,vec3 Col,vec3 CamPos)\n{\n    \n    \n    float i=1.0;\n    \n    i=Shadows(P);\n\n\tif(i==0.0){return AmbientI*Col;}\n    \n    \n\n\tconst vec3 LightRay = vec3(1.0,-1.0,-1.0)/sqrt(3.0);\n    \n    vec3 V=(CamPos-P)/length(CamPos-P);\n    \n    vec3 N=SurfNorm(P+V*DisEst(P).x*5.0);\n    \n    vec3 R=2.0*dot(LightRay,N)*N-LightRay;\n    \n    vec3 Ia=AmbientI*Col;\n    \n    vec3 Id=White*Col*( dot(LightRay,N) )*i;\n    \n    vec3 Ir= White*( pow(max(dot(R,V),0.0),Alpha) )*i;\n    \n    return Ia+Id+Ir;\n}\n\nvec3 RayMarch(vec3 Ray,vec3 Origin)\n{\n    float Dis,TotalDis,Steps;\n    vec2 DisEstReturn;\n    const vec3 Sky = vec3(0.6,0.6,1.0);\n    \n    \n    Dis = DisEst(Origin).x;\n    float DisMin=Dis;\n    Steps = 0.0;\n    TotalDis = 0.0;\n    float Hit=0.0002;\n    vec3 Pos = Origin;\n    while( (Dis<30.0) && (Dis>(Hit*TotalDis)) && (Steps<400.0) )\n    {\n        Steps+=1.0;\n        DisEstReturn=DisEst(Pos);\n        Dis = DisEstReturn.x;\n        Pos = Pos + Ray*Dis * 0.5;\n        \n        Ray.z = Ray.z - Curve*Dis; //Global transform\n        \n        Ray = Ray/max(length(Ray),1.0);\n            \n        TotalDis = TotalDis + Dis * 0.5;\n        DisMin=min(DisMin,Dis);\n    }\n    if((Dis)<(Hit*TotalDis*100.0))\n    {\n        //float Col = DisEstReturn.y*1.0/sqrt(TotalDis) + 20.0;\n        float Col = DisEstReturn.y*0.5*ColRate + 18.0 + ColOffset;\n        \n        vec3 IntColVec = vec3(0.4+0.4*sin( Col*12.0+0.000  ),\n                           0.4+0.4*sin( Col*12.0+2.094  ),\n                           0.4+0.4*sin( Col*12.0+4.189  ));\n        \n        vec3 ColVec = vec3(0,0,0);\n        \n        ColVec += PhongLighting(Pos + 0.3*Dis*vec3( 0.943,     0,-0.333),IntColVec,Origin);\n        //ColVec += PhongLighting(Pos + 0.3*Dis*vec3(-0.471, 0.816,-0.333),IntColVec,Origin);\n        //ColVec += PhongLighting(Pos + 0.3*Dis*vec3(-0.471,-0.816,-0.333),IntColVec,Origin);\n        //ColVec += PhongLighting(Pos + 0.3*Dis*vec3( 0.943,     0, 1.000),IntColVec,Origin);\n        \n        ColVec /= 1.0;\n        \n        ColVec *= (1.2-(Steps/800.0));\n        \n        float Fog = FogRate*TotalDis*TotalDis;\n        \n        ColVec = (ColVec+Sky*Fog)/(1.0+Fog);\n      \n        return ColVec;\n    }\n    \n    float Glow=0.01/(DisMin)*(1.0-(Steps/800.0));\n    \n    if(Dis>0.1)\n    {\n        return Sky*-1.0*sign(Ray.z-0.1);\n    }\n    \n    \n    return Sky*Glow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 Speed = SpeedSetting;\n    \n    const vec2 StartP = vec2(00.0,00.0);\n    \n    vec3 CamPos = Speed * vec3((iTime+StrT+StartP.x)*0.4,(iTime+StrT+StartP.y)*0.33,-ZHieght); //x,y,z\n    \n    vec2 Mouse = iMouse.xy;\n    if(iMouse.xy==vec2(0.0,0.0))\n    {\n        Mouse = 0.5*iResolution.xy;\n    }\n    \n    \n    //vec2 CamRot = vec2((-0.1),3.0*(-0.3))*240.0*3.1415926535/180.0;\n    vec2 CamRot = vec2((0.5-Mouse.y/iResolution.y),3.0*(0.5-Mouse.x/iResolution.x))*240.0*3.1415926535/180.0;\n    \n    mat2 RotP = mat2(cos(CamRot.x),-sin(CamRot.x),sin(CamRot.x),cos(CamRot.x));\n    \n    mat2 RotY = mat2(cos(CamRot.y),-sin(CamRot.y),sin(CamRot.y),cos(CamRot.y));\n    \n    float CamF = 1.2;\n    \n    //CamPos.xz = RotP * CamPos.xz;\n        \n    //CamPos.xy = RotY * CamPos.xy;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 1.0-2.0*fragCoord/iResolution.xy;\n    \n    uv.x=uv.x*iResolution.x/iResolution.y;\n    \n    \n    #ifndef AntiAliasing\n    vec3 Ray=vec3(CamF,uv.x,uv.y);\n    \n    Ray=normalize(Ray);\n    \n    Ray.xz = RotP * Ray.xz;\n        \n    Ray.xy = RotY * Ray.xy;\n    vec3 col=RayMarch(Ray,CamPos);\n    #endif\n    \n    \n    #ifdef AntiAliasing\n    \n    vec2 px = uv/iResolution.xy;\n    \n    vec3 Ray=vec3(CamF,uv.x+px.x*0.5,uv.y+px.y*0.5);\n    \n    Ray=normalize(Ray);\n    \n    Ray.xz = RotP * Ray.xz;\n        \n    Ray.xy = RotY * Ray.xy;\n    \n    vec3 col=RayMarch(Ray,CamPos);\n    \n    Ray=vec3(CamF,uv.x+px.x*0.5,uv.y+px.y*0.5);\n    \n    Ray=normalize(Ray);\n    \n    Ray.xz = RotP * Ray.xz;\n        \n    Ray.xy = RotY * Ray.xy;\n    \n    col+=RayMarch(Ray,CamPos);\n    \n    Ray=vec3(CamF,uv.x-px.x*0.5,uv.y+px.y*0.5);\n    \n    Ray=normalize(Ray);\n    \n    Ray.xz = RotP * Ray.xz;\n        \n    Ray.xy = RotY * Ray.xy;\n    \n    col+=RayMarch(Ray,CamPos);\n    \n    Ray=vec3(CamF,uv.x+px.x*0.5,uv.y-px.y*0.5);\n    \n    Ray=normalize(Ray);\n    \n    Ray.xz = RotP * Ray.xz;\n        \n    Ray.xy = RotY * Ray.xy;\n    \n    col+=RayMarch(Ray,CamPos);\n    \n    col *= 0.25;\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}