{"ver":"0.1","info":{"id":"sdyfWV","date":"1658860048","viewed":102,"name":"My perlin noise","username":"maze_maze","description":"A simple implementation of Perlin noise with use of my own hash function\nThe hash function https://www.shadertoy.com/view/fdKBDV","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","fbm","perlin","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smootherstep(float t) {\n    return (t * (t * 6.0 - 15.0) + 10.0) * t * t * t;\n}\n\nfloat gradNoise2D(ivec2 pos, vec2 offset) {\n    // Handmade formula from my other post https://www.shadertoy.com/view/fdKBDV\n    float value = float((pos.x * 676769 ^ pos.y * 53769) * 676769) * 0.001;\n    return dot(vec2(cos(value), sin(value)), offset);\n}\nfloat perlin2D(vec2 pos) {\n    vec2 offset = fract(pos);\n    vec2 offset1 = offset - 1.0;\n    ivec2 posf = ivec2(pos - offset);\n    ivec2 posc = posf + 1;\n    \n    float sox = smootherstep(offset.x);\n    return mix(\n        mix(gradNoise2D(posf, offset), gradNoise2D(ivec2(posc.x, posf.y), vec2(offset1.x, offset.y)), sox),\n        mix(gradNoise2D(ivec2(posf.x, posc.y), vec2(offset.x, offset1.y)), gradNoise2D(posc, offset1), sox),\n        smootherstep(offset.y)\n    ) * 1.41421356237;\n}\n\nfloat noise3D(ivec3 p) {\n    return float((p.x * 676769 ^ p.y * 53769 ^ p.z * 24869) * 676769) * 4.656613e-10;\n}\nfloat gradNoise3D(ivec3 pos, vec3 offset) {\n    // Handmade formula from my other post https://www.shadertoy.com/view/fdKBDV\n    return dot(vec3(noise3D(pos), noise3D(pos + 1), noise3D(pos + 2)), offset);\n}\nfloat perlin3D(vec3 pos) {\n    vec3 offset = fract(pos);\n    vec3 offset1 = offset - 1.0;\n    ivec3 posf = ivec3(pos - offset);\n    ivec3 posc = posf + 1;\n    \n    float sox = smootherstep(offset.x);\n    float soy = smootherstep(offset.y);\n    return mix(\n        mix(\n            mix(\n                gradNoise3D(posf, offset),\n                gradNoise3D(ivec3(posc.x, posf.y, posf.z), vec3(offset1.x, offset.y, offset.z)),\n                sox\n            ),\n            mix(\n                gradNoise3D(ivec3(posf.x, posc.y, posf.z), vec3(offset.x, offset1.y, offset.z)),\n                gradNoise3D(ivec3(posc.x, posc.y, posf.z), vec3(offset1.x, offset1.y, offset.z)),\n                sox\n            ),\n            soy\n        ),\n        mix(\n            mix(\n                gradNoise3D(ivec3(posf.x, posf.y, posc.z), vec3(offset.x, offset.y, offset1.z)),\n                gradNoise3D(ivec3(posc.x, posf.y, posc.z), vec3(offset1.x, offset.y, offset1.z)),\n                sox\n            ),\n            mix(\n                gradNoise3D(ivec3(posf.x, posc.y, posc.z), vec3(offset.x, offset1.y, offset1.z)),\n                gradNoise3D(posc, offset1),\n                sox\n            ),\n            soy\n        ),\n        smootherstep(offset.z)\n    ) * 1.41421356237;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / 16.0 + iTime * 2.0;\n\n    switch (int(fragCoord.x / iResolution.x * 2.)) {\n    case 0:\n        fragColor = vec4(vec3(perlin2D(uv) * 0.5 + 0.5), 1.0);\n        break;\n    default:\n        fragColor = vec4(vec3(perlin3D(vec3(uv, iTime)) * 0.5 + 0.5), 1.0);\n        break;\n    }\n}","name":"Image","description":"","type":"image"}]}