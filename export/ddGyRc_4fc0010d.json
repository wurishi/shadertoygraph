{"ver":"0.1","info":{"id":"ddGyRc","date":"1696375227","viewed":48,"name":"implicit circle","username":"theaggressiveprogrammer","description":"Shader to draw an antialiased circle based on the circle's implicit equation. A square root is only calculated near the border region where the antialiasing is applied. The antialiasing region thickness is variable according to the window resolution.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circle","blending","implicit","adaptiveantialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 circle(vec2 p, vec2 c, float r, float w, vec3 obj, vec3 bckg) {\n    float x = p.x - c.x;\n    float y = p.y - c.y;\n    float d = x*x + y*y;\n    float r2 = r*r;\n    vec3 col = obj; // assuming it's inside the circle\n    if (d > r2) {   \n      col = bckg;   // it was outside, assuming it's outside antialiasing area\n      if ( (d-r2) < (w*w) ) {         // it's inside antialiasing area\n        float n = sqrt(d-r2);         // calculate the square root for step function\n        float v = smoothstep(0.,w, n);// apply step function\n        //col = vec3(smoothstep(0.,a, n), smoothstep(0.,a, n), 1.); // this only works for backg = white, obj = blue\n        // blend background color with object color using the smoothstep value\n        col = vec3(v*bckg.x+((1.-v)*obj.x), v*bckg.y+((1.-v)*obj.y), v*bckg.z+((1.-v)*obj.z));\n      }\n    }\n    return col;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.y; // only scale according to y coordinates\n    float iy = 1.0/iResolution.y;      // size of the pixel\n    float ar = iResolution.x * iy;     // apect ratio\n    vec3 bckg =  vec3(0.9,0.9,1.);     // background color\n    vec3 obj = vec3(0.2, 0.5, 1.);     // circle color\n    vec2 c = vec2(0.5*ar, 0.5);        // circle center\n    // the antializing area thickness \"y\" varies according to y = a*x +b,  where x is iResolution.y\n    float minr = 236.; // minimum resolution (Shadertoy resolution)\n    float maxr = 768.; // maximum resolution (full screen)\n    float maxpx = 26.; // number of pixels of antialisiang region thickness for full screen\n    float minpx = 14.; // number of pixels of antialisiang region thickness for Shadertoy resolution\n    float a = (maxpx - minpx) / (maxr - minr); // slope of y = a*x + b, the number of pixels\n    float b = minpx - (a * minr);              // b parameter of y = a*x + b\n    //multiply the nunmber of pixels a*x + b by the size of the pixel (1/x) -> a + iy*b\n    vec3 col = circle(uv, c, 0.35, a + iy*b, obj, bckg);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif","name":"Image","description":"","type":"image"}]}