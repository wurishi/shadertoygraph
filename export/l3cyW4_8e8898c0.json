{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n#define PID 1\n\nconst float PI = 3.14159;\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nmat3 setCamera(vec3 ro, vec3 tg, float cr){\nvec3 cw = normalize(tg-ro);\nvec3 cu = normalize(cross(cw,vec3(sin(cr), cos(cr), 0.0)));\nvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n\nmat2 rotate2D(float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nconst float PI2 = acos(-1.0);\nconst float TAU = 2.0 * PI;\n\nmat2 rotate(float a) \n{\n  float c = cos(a), s = sin(a);\n  return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float n) \n{\n  n = TAU / n;\n  float a = atan(p.x, p.y) + n;\n  return p * rotate(floor(-a / n)*n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    vec3 col = vec3(0);\n   \tvec2 uv3=fragCoord.xy/iResolution.xy-.5;\n\tuv3.y*=iResolution.y/iResolution.x;\n    float t = iTime;\n   vec2 R = iResolution.xy;\n  vec2 uv2 = (2.0 * fragCoord - R) / R.y;\n  vec2 mp = (2.0 * iMouse.xy) / R.y;\n   vec3 from=vec3(1.,.5,0.5);\n\tvec3 dir=vec3(uv3*zoom,1.);\n  \n\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=rotate2D(iTime*0.03);// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\n  \n  float n = 5.0;\n  if (mp.x >= 0.1) \n    n = 2. + 4.*mp.x;\n n*= 2. + floor(4.*mp.x);\n  uv2= pmod(uv2,n) + 0.2*sin(iTime);\n    vec3 ro = vec3(0, 0, -1);\n    vec3 tg = vec3(0);\n\n\n\n    mat3 ca = setCamera(ro, tg, 0.);\n    vec3 rd = ca * normalize(vec3(uv2, 1.));\n\n    vec3 p,q;\n    float td=.1, d;\n\n\n\n\n\n\nuv.y*=iResolution.y/iResolution.x;\n\t\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\n\t\n\t\n\t\n    for(int i=0;i<40;++i){\n        p = ro + td * rd;\n        \n        for(int i=0;i<4;++i){\n            p=abs(p)-.3*v*.03;\n           \n            p.yz*=rotate2D(PI2*.5);\n            p.xz*=rotate2D(PI2*.25);\n          \n        }\n         \n        q=mod(abs(p-.5),1.)-.5;\n      \n        d = abs(length(q) - .65);\n  \n        if(d < 0.001){\n            col += hsv(sin(q.x*q.y*8.+t), .8, .02/abs(sin(atan(q.x, q.z)*2.+t)*sin(atan(q.y, q.z)*2.+t)+.1));\n            d+=0.003;\n        }\n        td += d;\n    }\n    \n    \n\n    fragColor = vec4(col*v*.01*3.,1.0);\n    \n  \t\n    \n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"l3cyW4","date":"1735059525","viewed":161,"name":"caleidoscopus rotatus","username":"nayk","description":"fractal from glslslsandbox and starnest","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["fractal","color","rotate"],"hasliked":0,"parentid":"","parentname":""}}