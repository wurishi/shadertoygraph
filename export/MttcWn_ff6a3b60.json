{"ver":"0.1","info":{"id":"MttcWn","date":"1532280938","viewed":229,"name":"Double slit experiment","username":"Dmytry","description":"Click on the screen to move slits. Red is left slit only, green is both slits. Can use either numerical integration or analytic. Note: vertical axis is not to scale, the slits are 50cm away from the screen, and the screen is 2cm wide.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["interference","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUMERICAL 0 // change to 1 to integrate numerically\n\n#ifdef NUMERICAL\nconst int antialias=10;\n#else\nconst int antialias=1;\n#endif\n\nconst float dist=0.5;// distance to the screen, 0.5m\n\nconst float width=20E-3;// width of the screen, 20mm\nconst float slit_size=0.2E-3;// 0.2mm\nconst float wavelength=500E-9; // 500nm\n\n// Note: analytical solution uses far field approximations for each slit, meaning that\n// if you change the constants and put the screen too close or set slit_size is too big, \n// it will be inaccurate.\n// However, the slits can be far from each other without undue inaccuracies.\n\nconst int slits=2;\n\nconst int sources_per_slit=300;// only when using numerical integration\n\nconst float pi=3.1415926;\n\nvec2 exp_i(float alpha){// e^i*alpha\n    return vec2(cos(alpha), sin(alpha));\n}\n\nfloat random(float seed){\n    // shitty random number generator\n    return fract(sin(seed*78.233211234) * 4758.5453);\n}\n\nfloat sinc(float a){\n    if(abs(a)>1E-5){\n    \treturn sin(a)/a;\n    }else{\n        return 1.0;\n    }\n}\nvec2 cplx_mul(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nfloat len2(vec2 v){\n    return dot(v,v);\n}\n\nfloat make_line(float v, float y){\n    //return clamp(4.0-abs((v-y)*iResolution.y - 3.0), 0.0, 1.0);\n    return v<y?0.0:1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float slit_separation=0.7E-3;\n    \n    if(iMouse.x>0.0 || iMouse.y>0.0){\n        float mouse=abs(2.0*iMouse.x/iResolution.x - 1.0);\n        slit_separation=max(mouse*width, slit_size);\n    }\n    \n    vec3 color_sum=vec3(0);\n    for(int antialias_i=0; antialias_i<antialias; ++antialias_i){\n    \n        float x=((fragCoord.x+float(antialias_i)/float(antialias))/iResolution.x-0.5)*width;\n        float y=fragCoord.y/iResolution.y;    \n        float w=2.0*pi/wavelength;        \n        vec2 sum=vec2(0);    \n        //vec2 sum_one_slit=vec2(0,0);\n        \n        vec2 per_slit[slits];\n        bool in_slit=false;   \n        for(int slit_i=0; slit_i<slits; ++slit_i){\n            vec2 slit_sum=vec2(0);\n            \n            float slit_pos=(float(slit_i)-float(slits-1)/2.0)*slit_separation;\n            if(abs(x-slit_pos)<0.5*slit_size)in_slit=true;            \n            #if(NUMERICAL)\n            for(int i=0;i<sources_per_slit;++i){\n                float i_f=float(i) /* +2.0*random(float(i)+0.5*float(slit_i)+iTime) */;\n                float pos_on_slit=(i_f/float(sources_per_slit-1)-0.5)*slit_size;\n                float px=x-slit_pos-pos_on_slit;\n                // Floats are not precise enough\n                // float l=sqrt(px*px+distance*distance);\n                // Approximate by taylor expansion around dx=0 , minus a constant            \n                float l=0.5*px*px/dist;\n                slit_sum+=exp_i(l*w);\n            }\n            slit_sum*=1.0/float(sources_per_slit);\n            #else\n            float px=x-slit_pos;\n            float so=px/dist;\n            float v=sinc(pi*slit_size*so/wavelength);\n            float phase=pi*so/wavelength;                        \n            slit_sum=exp_i(w*0.5*px*px/dist)*v;\n            #endif\n            per_slit[slit_i]=slit_sum;\n            sum+=slit_sum;\n        }\n        float scale=1.0/float(slits);\n        sum*=scale;\n\n        // Draw graphs\n        vec3 color=vec3(make_line(len2(per_slit[0]*scale),y), make_line(len2(sum), y), 0.0);//make_line(len2(per_slit[1]),y)\n\n        if(y>0.95 && !in_slit)color=vec3(1.0);\n        \n        color_sum+=color;\n    }\n    \n    fragColor = vec4(color_sum/float(antialias),1.0);\n}","name":"Image","description":"","type":"image"}]}