{"ver":"0.1","info":{"id":"tsBSWK","date":"1567099059","viewed":218,"name":"Ray Marching Lightning","username":"pavleeto","description":"Add Light to the scene","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereDE(vec3 position, vec3 center, float radius)\n{\n    return max(0.0, length(position - center) - radius);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sceneDE(vec3 position)\n{\n    float answer = min(sphereDE(position, vec3(sin(iTime)*5.0, 0.0, 0.0), 2.0),\n                       sphereDE(position, vec3(-sin(iTime)*5.0, 0.0, 0.0), 2.0));\n    answer = min(answer, sphereDE(position, vec3(cos(iTime*2.0)*10.0, 0.0, -sin(iTime*2.0)*10.0), 1.0));\n    answer = min(answer, sdPlane(position, normalize(vec4(0.0, 1.0, 0.0, 2.0))));\n    return answer;\n}\n\nvec3 estimateNormal(vec3 p) {\n    const float EPSILON = 1e-4;\n    return normalize(vec3(\n        sceneDE(vec3(p.x + EPSILON, p.y, p.z)) - sceneDE(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDE(vec3(p.x, p.y + EPSILON, p.z)) - sceneDE(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDE(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDE(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 raymarching(vec3 eye, vec3 dir, vec3 inf)\n{\n    const float MAX_STEPS = 200.0;\n    const float MIN_DIST = 1e-5;\n    \n    float steps = 0.0;\n    float totalDist = 0.0;\n    while (steps++ < MAX_STEPS)\n    {\n        vec3 pos = eye + totalDist * dir;\n        float delta = sceneDE(pos);\n        totalDist += delta;\n        \n        if (delta < MIN_DIST) break;\n    }\n    \n    vec3 finalPos = eye + totalDist * dir;\n    // if finalPos > MIN_DIST, infinity\n    return finalPos + step(MIN_DIST, sceneDE(finalPos)) * inf;  \n}\n\nvec3 phongLightningModel(float coeffDiffuse,\n                         vec3 eye,\n                         vec3 pos,\n                         vec3 normalInPos,\n                         vec3 lightPos, \n                         vec3 lightColor)\n{\n    vec3 lightDir = normalize(lightPos - pos);\n   \tfloat angleLightDir = dot(normalInPos, lightDir);\n    \n    return lightColor * (coeffDiffuse * angleLightDir) * step(0.0, angleLightDir);\n}\n\nvec3 computeLightning(vec3 eye, vec3 pos)\n{\n    const vec3 light1Pos = vec3(0, 10, 0);\n    const vec3 light1Color = vec3(0.8, 0.8, 0.8);\n    const vec3 ambient = vec3(0.08, 0.08, 0.08);\n    vec3 normalInPos = estimateNormal(pos);\n    \n    return ambient + phongLightningModel(0.8,\n                                         eye,\n                                         pos,\n                                         normalInPos,\n                                         light1Pos,\n                                         light1Color);\n}\n\n\nvec4 rayDir(vec2 uv, float fov, float aspect)\n{\n    vec2 coeffs = ((uv - 0.5) * 2.0) * tan(fov/2.0);\n    coeffs.x *= aspect;\n    vec4 dir = vec4(coeffs, -1.0, 0.0);\n    \n    return normalize(dir);\n}\n\nmat4 lookAt(vec3 eye, vec3 on, vec3 up)\n{\n    vec3 f = normalize(on - eye);\n    vec3 r = cross(f, up);\n    vec3 u = cross(r, f);\n    \n    return mat4(\n        vec4(r, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat aspect = iResolution.x / iResolution.y;\n    \n    // rayDir\n    vec3 eye = vec3(cos(iTime/2.3)*20.0, 2.0, sin(iTime/2.3)*20.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    mat4 worldToCam = lookAt(eye, center, vec3(0.0, 1.0, 0.0));\n    vec3 dir = (worldToCam * rayDir(uv, radians(45.0f), aspect)).xyz;\n    \n    vec3 pos = raymarching(eye, dir, vec3(1e4, 1e4, 1e4));\n    vec3 color = computeLightning(eye, pos);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}