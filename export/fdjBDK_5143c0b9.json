{"ver":"0.1","info":{"id":"fdjBDK","date":"1647104029","viewed":131,"name":"3body problem - verlet","username":"metabog","description":"New, more stable version of my previous sketch, using verlet integration for better stability/less singularities.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A fractal-like visual based off tracking the position of one body in a 3 body gravitational bound system\n//Mouse position sets the start position of the second body. Pixel position is mapped to the start position of\n//the body we are tracking. Then map the color to be how long it took the tracked body to escape.\n\nvec2 mpos = vec2(0.5,0.5);\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 compute_grav_pull(vec2 me, vec2 other, float mass)\n{\n    vec2 vec = other-me;\n    float d = length(vec);\n    vec = normalize(vec);\n    \n    //multiply by 100 to apply some distance scale otherwise all the bodies will be very close by\n    //and explode off of each other's steep gravity wells very quickly\n    //there are no collisions so acceleration approaches infinity near the centres of objects!\n    d=max(0.01,d);//no black holes lol\n    float pull = 1.0f/(d*100.0); \n    vec *= pull * 1.0 * mass;\n    \n    return vec;\n}\n\n//clamp velocities because simulation breaks down at high speeds\n//reduce this and the image becomes smoother due to less singularities\n//but also proably no as realistic\nfloat max_velocity = 0.5; \n\n//change these to set the starting velocities of the other bodies\nvec2 body1_start_vel = vec2(-0.001,0.006);\nvec2 body2_start_vel = vec2(0.001,-0.006);\n\n//the masses of the bodies\nfloat b1mass = 1.0;\nfloat b2mass = 1.3;\nfloat movermass = 0.3;\n\nfloat dt = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if(iMouse.x>0.0 && iMouse.y > 0.0)\n        mpos = iMouse.xy/iResolution.xy;\n\n    vec2 b1pos = vec2(0.25,0.5);\n    vec2 b2pos = vec2(mpos.x,mpos.y);\n    \n    vec2 b1vel = body1_start_vel;\n    vec2 b2vel = body2_start_vel;\n    \n    \n    //start at uv coords\n    vec2 moverpos = uv;\n    \n    //set start velocity for the tracked body to rotate slowly\n    vec2 movervel = vec2(cos(iTime*0.1), sin(iTime*0.1))*0.03;\n    //movervel = vec2(0,0.01);\n    int maxiter = 128;\n    \n    int iter_reached = 0;\n   \n    vec2 b1acc = vec2(0.0,0.0);\n    vec2 b2acc =  vec2(0.0,0.0);\n    vec2 moveracc =  vec2(0.0,0.0);\n   \n    bool escaped = false;\n    while(iter_reached<maxiter)\n    {\n        //VERLET INTEGRATION UPDATE\n        vec2 new_b1pos = b1pos + b1vel*dt + b1acc*dt*dt*0.5;\n        vec2 new_b2pos = b2pos + b2vel*dt + b2acc*dt*dt*0.5;\n        vec2 new_moverpos = moverpos + movervel*dt + moveracc*dt*dt*0.5;\n        \n        //get the new velocities\n        vec2 new_b1acc  = compute_grav_pull(b1pos, b2pos, b2mass) + compute_grav_pull(b1pos,moverpos, movermass);\n        vec2 new_b2acc  = compute_grav_pull(b2pos, b1pos, b1mass) + compute_grav_pull(b2pos,moverpos,movermass);\n        vec2 new_moveracc = compute_grav_pull(moverpos, b1pos,b1mass) + compute_grav_pull(moverpos,b2pos,b2mass);\n\n        vec2 new_b1vel = max(min(b1vel + (b1acc + new_b1acc)*dt*0.5, vec2(max_velocity,max_velocity)), - vec2(max_velocity,max_velocity));\n        vec2 new_b2vel = max(min(b2vel + (b2acc + new_b2acc)*dt*0.5, vec2(max_velocity,max_velocity)), - vec2(max_velocity,max_velocity));\n        vec2 new_movervel = max(min(movervel + (moveracc + new_moveracc)*dt*0.5, vec2(max_velocity,max_velocity)), - vec2(max_velocity,max_velocity));\n       \n        b1acc = new_b1acc;\n        b2acc = new_b2acc;\n        moveracc = new_moveracc;\n        \n        b1vel = new_b1vel;\n        b2vel = new_b2vel;\n        movervel = new_movervel;\n        \n        b1pos = new_b1pos;\n        b2pos = new_b2pos;\n        moverpos = new_moverpos;\n        \n        if(length(moverpos-vec2(0.5,0.5))>1.5)\n        {\n            escaped = true;\n            break;\n        }\n        iter_reached++;\n    }\n    \n    bool blacken_captures = false;\n    \n    float d = (escaped || !blacken_captures) ? float(iter_reached)/float(maxiter) : 0.0;\n    fragColor = vec4(hsv2rgb(vec3(d*3.9,0.6,d)),1.0);\n}","name":"Image","description":"","type":"image"}]}