{"ver":"0.1","info":{"id":"fsySDm","date":"1635168157","viewed":364,"name":"Phasor graph","username":"ThibaultTricard","description":"An idealized representation of the graphs used in \"A brick in the wall: Staggered orientable infills for additive manufacturing\"\narticle : https://hal.inria.fr/hal-03352656/\nteam : https://mfx.loria.fr/","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["phasornoisegraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// This is An idealized representation of the graphs used in \n//\"A brick in the wall: Staggered orientable infills for additive manufacturing\" \n// SCF 2021 by T. Tricard, J. Etienne, C. Zanni, S. Lefebvre\n//\n// Feel free to reuse, please cite our work\n//\n// Link to paper : https://hal.inria.fr/hal-03352656/\n// Research Teams :\n// https://mfx.loria.fr/\n// =====================================================================\n// This shader computes an phasor noise following an orientation field Buffer C\n// with frequency variation computed by the Buffer D\n//    regularized so as to avoid curve discontinuities.\n// Buffer A compute the initial distribution and optimize neighbor kernels phase \n// of the first set of kernel that create the red lines\n// Buffer B compute the initial distribution and optimize neighbor kernels phase \n// of the second set of kernel that create the green lines\n//\n// The result is phase-filtered here, then used to compute the graph displayed here.\n// The graph is animated to represent the staggering effects.\n// Author : Thibault Tricard 2021\n\n\n\n#define regularized true\n\n#define edges true\n\n#define animate true\n\n#define showSawtooth false\n\n#define showOrthogonal true\n\n#define vertex true\n\nfloat cellsize = 1./30.,\n     _b = 1.,\n     _a = 1.,\n     dir,\n     f;\n\n\nbool field;\n\n\n//closed form of the phasor kernel filtered to reduce \nvec2 phasorkernel(vec2 x, float fj, vec2 dj, float phi, float filtering){ \n    float fx = f;//in this case the frequency field is constant so fx = fj; \n    vec2  dx =  CosSin(dir),\n        djx = ( fj*dj - fx*dx ) * filtering;\n    float a =  _a*_a * M_PI,\n          b =  _b*_b * M_PI,\n       gaus =   exp( -    a*b    / (a+b) * dot( x , x ) ) \n              * exp( - M_PI*M_PI / (a+b) * dot(djx,djx) ),\n        osc =   TAU * dot(x, dj) * fj  \n              - TAU * dot(x,djx) * a / (a+b)\n              + phi;\n    \n    return gaus * CosSin(osc);  \n}\n\n\n\n//evaluation on one cell of the noise\nvec2 eval_cell(ivec2 gij, vec2 at ){  \n    vec2 res = vec2(0);\n    int gidx = coord2index(gij,grid_size);\n    for(int i = 0; i< nb_Kernel; i++ ) {\n        //compute the kernel coordinate id\n        int kid = gidx * nb_Kernel * 2 + i * 2;\n        //compute the kernel coordinate in the buffer \n        ivec2 c1 = index2coord( kid ,resx),\n              c2 = index2coord(kid+1,resx);\n        //fetch the kernel k\n\t\tvec4  k1,\n              k2;\n        if(!field){\n            k1 = texelFetch(iChannel0,c1,0);\n            k2 = texelFetch(iChannel0,c2,0);\n        }else{\n            k1 = texelFetch(iChannel1,c1,0);\n            k2 = texelFetch(iChannel1,c2,0);\n        }\n        //flag for the interface\n        float    phi = regularized  ? k1.w : 0.,\n           filtering = regularized ? 1.   : 0.;\n        //computing the impacte of the phasor kernel\n        res += phasorkernel( at-k1.xy, k2.w, k2.xy, phi,filtering); \n    }\n    return res;\n}\n\n//evaluation of the phasor noise\nvec2 phasor(ivec2 gij, vec2 ij) {      \n    vec2 res = vec2(0);\n    //loop on the neighbor cells\n    for(int i =-2; i<=2; i++)\n    \tfor(int j =-2; j<=2; j++)\n            //evaluation of the cell\n        \tres += eval_cell( gij + ivec2(i,j), ij - vec2(i,j) );\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n   \n    vec2 pos = fragCoord/iResolution.x/cellsize,\n          ij = fract(pos),\n         gij = floor(pos+1.),\n          xy = ( ij + gij ) / float(grid_size) * iResolution.y;\n    dir = texelFetch(iChannel2, ivec2(xy),0).x * TAU;\n    f = 2.0 - texelFetch(iChannel3, ivec2(xy),0).x ;\n    \n    // compute the first phasor noise\n    vec2 n1 = phasor(ivec2(gij),ij);\n    \n    // setup the shader for computing the second phasor noise \n    field = true;\n    dir = texelFetch(iChannel2, ivec2(xy),0).x * TAU + M_PI/2.0;\n    \n    // compute the second phasor noise\n    vec2 n2 = phasor(ivec2(gij),ij);\n    \n    // argument of the first phasor noise\n    float phi = atan(n1.y,n1.x)/TAU +.5;\n    \n    // argument of the second phasor noise\n    float theta = atan(n2.y,n2.x)/TAU +.5;\n    \n    fragColor = vec4(1.0);\n    \n    if(animate){\n        //shift the first phasor noise\n        phi += iTime;\n        phi = phi - float(int(phi));\n        \n        //shift the second phasor noise\n        theta += iTime;\n        theta = theta - float(int(theta));\n    }\n    \n    if(showSawtooth){\n        //draw the first phasor noise\n        fragColor = vec4(phi);\n    }\n    \n    if (phi < 0.55 &&  phi > 0.45 && edges){\n        //draw the first set of edges\n        fragColor = vec4 (0.7,0.1,0.1,1.0);\n    }\n    \n    if(showOrthogonal){\n        if(showSawtooth){\n            //draw the second phasor noise\n            fragColor = vec4(theta);\n        }\n\n        if (theta < 0.55 &&  theta > 0.45 && edges){\n            //draw the second set of edges\n            fragColor = vec4 (0.1,0.7,0.1,1.0);\n        }\n    }\n    \n    if(vertex){\n        //draw the vertex of the graph\n        float d = (theta - 0.5) * (theta - 0.5) + (phi - 0.5) * (phi - 0.5);\n        if(d < 0.02){\n            fragColor = vec4 (0.1,0.1,0.1,1.0);\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ===============================================\n// Main constants and utility functions\n\n#define nb_Kernel    8\n#define grid_size   32\n#define      resx  128              // [$$ KEZAKO ? ]\n#define M_PI         3.14159265358979323846\n#define TAU      ( 2.*M_PI )\n\n#define index2coord(id,size)   ivec2( (id)%(size), (id)/(size) )\n#define coord2index(P,size)   ( (P).x + (P).y * (size) )\n#define CosSin(a)              vec2( cos(a), sin(a) )\n\n///////////////////////////////////////////////\n//prng\n///////////////////////////////////////////////\n\nint N = 15487469;\nint x_;\nvoid seed(int s)            { x_ = s;                            }\nint next()                  { x_ *= 3039177861; return x_ %=  N; }\nfloat uni_0_1()             { return  float(next()) / float(N);  }\nfloat uni(float m, float M) { return mix( m, M, uni_0_1() );     }\n\n\nint morton(int x, int y)\n{\n  int z = 0;\n  for (int i = 0 ; i < 32* 4 ; i++)\n    z |= ( ( x & (1 << i) ) <<  i      ) \n      |  ( ( y & (1 << i) ) << (i + 1) );\n \n  return z;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//=================================================================\n// Build a sparse distribution of kernels ( as for Gabor noise ) \n//    nb_Kernel taken uniformly in each cell of a grid_size x grid_size grid.\n// Then process 50 steps of kernel phase optimization\n//    so as to better align neighboor phases.\n//\n// Data structure:\n// this buffer stores particles:  8 floats per particle stored in RGBA fields of 2 consecutive pixels.\n//    slot 1 ( even pixels ) => Pos: x, y   ; 0, phi\n//\t  slot 2 ( odd pixels )  => Dir: dx, dy ; 0, f\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int      idx = coord2index( ivec2(fragCoord), resx ),\n      field_size = nb_Kernel * 2 *grid_size*grid_size,\n            gidx = (idx) / 2 / nb_Kernel;\n\tivec2    gij = index2coord( gidx , grid_size  );\n    \n    if (idx > field_size) discard;\n    \n    fragColor =vec4(0);\n    if( iFrame == 1 ) { // --------------- initialization ---------\n        int s = morton( morton(gij.x,gij.y), idx );\n\t\tseed(s);\n        if( idx%2 == 0)  // --- particle slot1: position and phi\n           \tfragColor = vec4(uni_0_1(), uni_0_1(),0,0);\n        else {           // --- particle slot2: direction and frequency\n            //We compute the position of the kernel on direction field \n           \tvec2   xy = ( vec2( uni_0_1(), uni_0_1() ) + vec2(gij) ) / float(grid_size) * iResolution.y;\n           \tfloat dir = texelFetch(iChannel1, ivec2(xy),0).x * TAU;\n            //We use the guassian to modify the frequencies of the kernels\n            float f = 2.0 - texelFetch(iChannel2, ivec2(xy),0).x;\n           \tfragColor = vec4(CosSin(dir), 0 ,f);\n        }\n        return;      \n    }\n    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord) ,0); // restore previous state\n\n    if(iFrame < 50) { // ---------- alignement process -----\n        \n        if( idx % 2 == 0 ) {       // --- particle slot1\n            //fetch the kernel k\n            vec4 k_part1 = texelFetch(iChannel0, ivec2(fragCoord) \t\t\t  ,0), // slot 1\n                 k_part2 = texelFetch(iChannel0, ivec2(fragCoord) +ivec2(1,0) ,0); // slot 2\n            vec2 phi = vec2(0);\n            // --- loop on the neighbor grid cells to optimize the phase of the kernel k \n            // --- with all the kernels n that interract with it\n            for (int i = -1; i <=1; i ++)\n                for (int j = -1; j <=1; j ++) {\n                    //computation of the index of the cell\n                    gidx = coord2index( gij+ivec2(i,j) , grid_size );\n                    //loop on the kernels in this cell\n                    if(gij.x >=0 && gij.x < grid_size && gij.y >=0 && gij.y  < grid_size)\n                        for(int l = 0; l< nb_Kernel; l ++) {\n                            ////computation of the id of the kernel n\n                            int kid = gidx * nb_Kernel * 2 + l * 2; \n                            //compute the current kernel coordinate \n                            ivec2 c1 = index2coord( kid , resx ),\n                                  c2 = index2coord(kid+1, resx );\n\n                            //fetch the kernel n\n                            vec4 nvalue1 = texelFetch(iChannel0,c1,0),\n                                 nvalue2 = texelFetch(iChannel0,c2,0);\n                            //We want to compute the relative phase shift between the kernel k and n\n                           \n                            //We first compute position of the kernel n relative to the cell of the kernel k\n                            vec2 npos = vec2(i,j)  + nvalue1.xy;\n                            float osc = TAU *  nvalue2.w * dot( k_part1.xy - npos, nvalue2.xy) + nvalue1.w;\n                            \n                            //we use the dot product of the direction of the two kernel to weight this phase shift\n                            //because we want to prioritize the phase alignment of kernel with same direction\n                            float w = dot(k_part2.xy, nvalue2.xy);\n                            phi += w * CosSin(osc) / 2.;\n                        } \n                }  \n\n            //update of the phase value\n            if (phi.x !=0.0){\n                fragColor.w =  atan( phi.y, phi.x );\n            }\n        } \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//=================================================================\n// Build a sparse distribution of kernels ( as for Gabor noise ) \n//    nb_Kernel taken uniformly in each cell of a grid_size x grid_size grid.\n// Then process 50 steps of kernel phase optimization\n//    so as to better align neighboor phases.\n//\n// Data structure:\n// this buffer stores particles:  8 floats per particle stored in RGBA fields of 2 consecutive pixels.\n//    slot 1 ( even pixels ) => Pos: x, y   ; 0, phi\n//\t  slot 2 ( odd pixels )  => Dir: dx, dy ; 0, f\n//\n// This buffer store the kernel with an orthogonal direction compared to the buffer A\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int      idx = coord2index( ivec2(fragCoord), resx ),\n      field_size = nb_Kernel * 2 *grid_size*grid_size,\n            gidx = (idx) / 2 / nb_Kernel;\n\tivec2    gij = index2coord( gidx , grid_size  );\n    \n    if (idx > field_size) discard;\n    \n    fragColor =vec4(0);\n    if( iFrame == 1 ) { // --------------- initialization ---------\n        int s = morton( morton(gij.x,gij.y), idx );\n\t\tseed(s);\n        if( idx%2 == 0)  // --- particle slot1: position and phi\n           \tfragColor = vec4(uni_0_1(), uni_0_1(),0,0);\n        else {           // --- particle slot2: direction and frequency\n            //We compute the position of the kernel on direction field \n           \tvec2   xy = ( vec2( uni_0_1(), uni_0_1() ) + vec2(gij) ) / float(grid_size) * iResolution.y;\n           \tfloat dir = texelFetch(iChannel1, ivec2(xy),0).x * TAU + M_PI/2.0;\n            //We use the guassian to modify the frequencies of the kernels\n            float f = 2.0 - texelFetch(iChannel2, ivec2(xy),0).x;\n           \tfragColor = vec4(CosSin(dir), 0 ,f);\n        }\n        return;      \n    }\n    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord) ,0); // restore previous state\n\n    if(iFrame < 50) { // ---------- alignement process -----\n        \n        if( idx % 2 == 0 ) {       // --- particle slot1\n            //fetch the kernel k\n            vec4 k_part1 = texelFetch(iChannel0, ivec2(fragCoord) \t\t\t  ,0), // slot 1\n                 k_part2 = texelFetch(iChannel0, ivec2(fragCoord) +ivec2(1,0) ,0); // slot 2\n            vec2 phi = vec2(0);\n            // --- loop on the neighbor grid cells to optimize the phase of the kernel k \n            // --- with all the kernels n that interract with it\n            for (int i = -1; i <=1; i ++)\n                for (int j = -1; j <=1; j ++) {\n                    //computation of the index of the cell\n                    gidx = coord2index( gij+ivec2(i,j) , grid_size );\n                    //loop on the kernels in this cell\n                    if(gij.x >=0 && gij.x < grid_size && gij.y >=0 && gij.y  < grid_size)\n                        for(int l = 0; l< nb_Kernel; l ++) {\n                            ////computation of the id of the kernel n\n                            int kid = gidx * nb_Kernel * 2 + l * 2; \n                            //compute the current kernel coordinate \n                            ivec2 c1 = index2coord( kid , resx ),\n                                  c2 = index2coord(kid+1, resx );\n\n                            //fetch the kernel n\n                            vec4 nvalue1 = texelFetch(iChannel0,c1,0),\n                                 nvalue2 = texelFetch(iChannel0,c2,0);\n                            //We want to compute the relative phase shift between the kernel k and n\n                           \n                            //We first compute position of the kernel n relative to the cell of the kernel k\n                            vec2 npos = vec2(i,j)  + nvalue1.xy;\n                            float osc = TAU *  nvalue2.w * dot( k_part1.xy - npos, nvalue2.xy) + nvalue1.w;\n                            \n                            //we use the dot product of the direction of the two kernel to weight this phase shift\n                            //because we want to prioritize the phase alignment of kernel with same direction\n                            float w = dot(k_part2.xy, nvalue2.xy);\n                            phi += w * CosSin(osc) / 2.;\n                        } \n                }  \n\n            //update of the phase value\n            if (phi.x !=0.0){\n                fragColor.w =  atan( phi.y, phi.x );\n            }\n        } \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//===============================================================================\n// Compute a procedural guaussian orientation field as in Procedural Phasor Noise\n//     used as stub user input data.\n// It returns an angle normalised between 0. and 1.\n\n\nfloat _bandwith = 4.,                         \n      _kernelRadius;\nint _impPerKernel = 10,\n    _seed = 1;\n\n\nfloat gaussian(vec2 X, float b)\n{   return exp(- M_PI * b*b * dot(X,X) ); }\n\nvoid init_grid()                       \n{   _kernelRadius = sqrt( -log(0.05) / M_PI) / _bandwith; }\n\n\nvec2 cell(ivec2 ij, vec2 uv, float b)   \n{\n\tint  nImpulse = _impPerKernel,\n                s = morton(ij.x,ij.y) + 333;\n\tfloat  cellsz = 2. * _kernelRadius;\n\tvec2    noise = vec2(0);\n\tseed( s +_seed );\n    \n\tfor ( int impulse = 0; impulse <= nImpulse ; impulse++ ) {\n\t\tvec2 impulse_centre = vec2( uni_0_1() , uni_0_1() ),\n\t\t     d = ( uv - impulse_centre ) *cellsz;\n\t\tfloat omega = uni( -2.4, 2.4 );\n\t\tnoise += gaussian(d, b) *  CosSin(omega);\t\t\n\t}\n\treturn noise;\n}\n\nvec2 eval_noise(vec2 uv, float b)       \n{   \n\tfloat cellsz = 2. *_kernelRadius;\n\tvec2  _ij = uv / cellsz,\n           ij = floor(_ij),\n\t      fij = fract(_ij ),\n\t    noise = vec2(0);\n    \n\tfor (int j = -2; j <= 2; j++)\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tvec2 nij = vec2(i,j);\n\t\t\tnoise += cell( ivec2(ij + nij) , fij - nij, b );\n\t\t}\n\n    return noise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.y = -uv.y;\n    init_grid();\n\n    vec2 gaussian_field = normalize( eval_noise(uv,_bandwith) );\n    \n    float angle = atan( gaussian_field.y, gaussian_field.x ) / TAU;\n    fragColor = vec4( angle , 0, 0, 1 ); \n \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//===============================================================================\n// Compute a procedural guaussian field\n//     used as stub user input data.\n// It returns a value between 0. and 1.\n\n\nfloat _bandwith = 4.,                         \n      _kernelRadius;\nint _impPerKernel = 10,\n    _seed = 4;\n\n\nfloat gaussian(vec2 X, float b)\n{   return exp(- M_PI * b*b * dot(X,X) ); }\n\nvoid init_grid()                       \n{   _kernelRadius = sqrt( -log(0.05) / M_PI) / _bandwith; }\n\n\nfloat cell(ivec2 ij, vec2 uv, float b)   \n{\n\tint  nImpulse = _impPerKernel,\n                s = morton(ij.x,ij.y) + 333;\n\tfloat  cellsz = 2. * _kernelRadius;\n\tfloat    noise = 0.0;\n\tseed( s +_seed );\n    \n\tfor ( int impulse = 0; impulse <= nImpulse ; impulse++ ) {\n\t\tvec2 impulse_centre = vec2( uni_0_1() , uni_0_1() ),\n\t\t     d = ( uv - impulse_centre ) *cellsz;\n\t\tfloat w = uni( -1.0, 1.0 );\n\t\tnoise += gaussian(d, b) *  w;\t\t\n\t}\n\treturn noise;\n}\n\nfloat eval_noise(vec2 uv, float b)       \n{   \n\tfloat cellsz = 2. *_kernelRadius;\n    float noise = 0.0;\n\tvec2  _ij = uv / cellsz,\n           ij = floor(_ij),\n\t      fij = fract(_ij );\n    \n\tfor (int j = -2; j <= 2; j++)\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tvec2 nij = vec2(i,j);\n\t\t\tnoise += cell( ivec2(ij + nij) , fij - nij, b );\n\t\t}\n\n    return noise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.y = -uv.y;\n    \n    uv = uv + vec2(0.5,0.0);\n    init_grid();\n    \n    float gaussian_field = eval_noise(uv,_bandwith) *0.5 +0.5;\n    gaussian_field= max(gaussian_field,0.0);\n    fragColor = vec4( gaussian_field, 0, 0, 1 ); \n \n}","name":"Buffer D","description":"","type":"buffer"}]}