{"ver":"0.1","info":{"id":"XdyGzR","date":"1452866828","viewed":2196,"name":"Another CRT shader.","username":"frutbunn","description":"Stock shader used in my new HTML5/Canvas CRT emulator library. Some of the code may look familiar, as I learnt a great deal from examples on this site! :)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define CURVATURE 1.\n#define SCANLINES 1.\n#define CURVED_SCANLINES 1.\n#define BLURED 1.\n#define LIGHT 1.\n#define COLOR_CORRECTION 1.\n//#define ASPECT_RATIO 1.\n\nconst float gamma = 1.;\nconst float contrast = 1.;\nconst float saturation = 1.;\nconst float brightness = 1.;\n\nconst float light = 9.;\nconst float blur = 1.5;\n\nvec3 postEffects(in vec3 rgb, in vec2 xy) {\n    rgb = pow(rgb, vec3(gamma));\n    rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*brightness)), rgb*brightness, saturation), contrast);\n\n    return rgb;\n}\n\n// Sigma 1. Size 3\nvec3 gaussian(in vec2 uv) {\n    float b = blur / (iResolution.x / iResolution.y);\n\n    uv+= .5;\n\n    vec3 col = texture(iChannel0, vec2(uv.x - b/iResolution.x, uv.y - b/iResolution.y) ).rgb * 0.077847;\n    col += texture(iChannel0, vec2(uv.x - b/iResolution.x, uv.y) ).rgb * 0.123317;\n    col += texture(iChannel0, vec2(uv.x - b/iResolution.x, uv.y + b/iResolution.y) ).rgb * 0.077847;\n\n    col += texture(iChannel0, vec2(uv.x, uv.y - b/iResolution.y) ).rgb * 0.123317;\n    col += texture(iChannel0, vec2(uv.x, uv.y) ).rgb * 0.195346;\n    col += texture(iChannel0, vec2(uv.x, uv.y + b/iResolution.y) ).rgb * 0.123317;\n\n    col += texture(iChannel0, vec2(uv.x + b/iResolution.x, uv.y - b/iResolution.y) ).rgb * 0.077847;\n    col += texture(iChannel0, vec2(uv.x + b/iResolution.x, uv.y) ).rgb * 0.123317;\n    col += texture(iChannel0, vec2(uv.x + b/iResolution.x, uv.y + b/iResolution.y) ).rgb * 0.077847;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy / iResolution.xy) - vec2(.5);\n    \n    // Curvature/light\n    float d = length(st*.5 * st*.5);\n#ifdef CURVATURE\n    vec2 uv = st*d + st*.935;\n#else\n    vec2 uv = st;\n#endif\n\n    // Fudge aspect ratio\n#ifdef ASPECT_RATIO\n    uv.x *= iResolution.x/iResolution.y*.75;\n#endif\n    \n    // CRT color blur\n#ifdef BLURED\n    vec3 color = gaussian(uv);\n#else\n    vec3 color = texture(iChannel0, uv+.5).rgb;\n#endif\n\n    // Light\n#ifdef LIGHT\n    float l = 1. - min(1., d*light);\n    color *= l;\n#endif\n\n    // Scanlines\n#ifdef CURVED_SCANLINES\n    float y = uv.y;\n#else\n    float y = st.y;\n#endif\n\n    float showScanlines = 1.;\n    if (iResolution.y<360.) showScanlines = 0.;\n    \n#ifdef SCANLINES\n    float s = 1. - smoothstep(320., 1440., iResolution.y) + 1.;\n    float j = cos(y*iResolution.y*s)*.1; // values between .01 to .25 are ok.\n    color = abs(showScanlines-1.)*color + showScanlines*(color - color*j);\n    color *= 1. - ( .01 + ceil(mod( (st.x+.5)*iResolution.x, 3.) ) * (.995-1.01) )*showScanlines;\n#endif\n\n    // Border mask\n#ifdef CURVATURE\n        float m = max(0.0, 1. - 2.*max(abs(uv.x), abs(uv.y) ) );\n        m = min(m*200., 1.);\n        color *= m;\n#endif\n\n    // Color correction\n#ifdef COLOR_CORRECTION\n    color = postEffects(color, st);\n#endif\n\n\tfragColor = vec4(max(vec3(.0), min(vec3(1.), color)), 1.);\n}","name":"","description":"","type":"image"}]}