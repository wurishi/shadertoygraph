{"ver":"0.1","info":{"id":"tts3zB","date":"1556825024","viewed":1246,"name":"GPU hacks #04 - OpenGL Compute","username":"PrzemyslawZaworski","description":"OpenGL Compute Shader - simple framework.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nSave as chess.c and compile:\ngcc -s -o chess.exe chess.c -mwindows -lopengl32\nor \ncl chess.c opengl32.lib user32.lib gdi32.lib\n*/\n\n\n/*\n#include <windows.h>\n#include <GL/gl.h>\n\n#define width 1280\n#define height 720\n\ntypedef int (WINAPI *PFNWGLSWAPINTERVALEXTPROC)(int i);\ntypedef GLuint (WINAPI *PFNGLCREATEPROGRAMPROC)();\ntypedef GLuint (WINAPI *PFNGLCREATESHADERPROC)(GLenum t);\ntypedef void (WINAPI *PFNGLSHADERSOURCEPROC)(GLuint s, GLsizei c, const char*const*string, const GLint* i);\ntypedef void (WINAPI *PFNGLCOMPILESHADERPROC)(GLuint s);\ntypedef void (WINAPI *PFNGLATTACHSHADERPROC)(GLuint p, GLuint s);\ntypedef void (WINAPI *PFNGLLINKPROGRAMPROC)(GLuint p);\ntypedef void (WINAPI *PFNGLUSEPROGRAMPROC)(GLuint p);\ntypedef void (WINAPI *PFNGLDISPATCHCOMPUTEPROC) (GLuint x, GLuint y, GLuint z);\ntypedef void (WINAPI *PFNGLBINDIMAGETEXTUREPROC) (GLuint a, GLuint b, GLint c, GLboolean d, GLint e, GLenum f, GLenum g);\ntypedef GLint (WINAPI *PFNGLGETUNIFORMLOCATIONPROC) (GLuint p, const char *n);\ntypedef void (WINAPI *PFNGLUNIFORM1FPROC) (GLint s, GLfloat v0);\ntypedef void (WINAPI *PFNGLUNIFORM2IPROC) (GLint s, GLint v0, GLint v1);\n\nstatic const char* ComputeShader = \\\n\t\"#version 430 \\n\"\n\t\"writeonly uniform image2D writer;\"\n\t\"uniform float iTime;\"\n\t\"uniform ivec2 iResolution;\"\n\t\"layout (local_size_x = 8, local_size_y = 8) in;\"\n\t\"void main()\"\n\t\"{\"\n\t\t\"vec2 fragCoord = gl_GlobalInvocationID.xy;\"\n\t\t\"vec2 p = ceil (fragCoord/30.0 + sin(iTime));\"\n\t\t\"vec4 fragColor = mod(p.xxxx + p.y, 2.);\"\n\t\t\"imageStore(writer,ivec2(gl_GlobalInvocationID),fragColor);\"\n\t\"}\" ;\n\nvoid MakeBuffer() \n{\n\tglBindTexture(GL_TEXTURE_2D, 1);\n\tglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n\tglTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,width,height,0,GL_RGBA,GL_FLOAT,0);\n\t((PFNGLBINDIMAGETEXTUREPROC)wglGetProcAddress(\"glBindImageTexture\"))(0,1,0,GL_FALSE,0,0x88B9,GL_RGBA8);\n\tglEnable(GL_TEXTURE_2D);\n}\n\nint MakeShader(const char* source, GLenum type)\n{\n\tint p = ((PFNGLCREATEPROGRAMPROC)wglGetProcAddress(\"glCreateProgram\"))();\n\tint s = ((PFNGLCREATESHADERPROC)wglGetProcAddress(\"glCreateShader\"))(type);\t\n\t((PFNGLSHADERSOURCEPROC)wglGetProcAddress(\"glShaderSource\"))(s,1,&source,0);\n\t((PFNGLCOMPILESHADERPROC)wglGetProcAddress(\"glCompileShader\"))(s);\n\t((PFNGLATTACHSHADERPROC)wglGetProcAddress(\"glAttachShader\"))(p,s);\n\t((PFNGLLINKPROGRAMPROC)wglGetProcAddress(\"glLinkProgram\"))(p);\n\treturn p;\n}\n\nstatic LRESULT CALLBACK WindowProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\n{\n\tif( uMsg==WM_CLOSE || uMsg==WM_DESTROY || (uMsg==WM_KEYDOWN && wParam==VK_ESCAPE) )\n\t{\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\t}\n\tif( uMsg==WM_SIZE )\n\t{\n\t\tglViewport( 0, 0, lParam&65535, lParam>>16 );\n\t}\n\treturn(DefWindowProc(hWnd,uMsg,wParam,lParam));\n} \n\nint WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )\n{\n\tMSG msg;\n\tint exit = 0;\n\tPIXELFORMATDESCRIPTOR pfd = { 0,0,PFD_DOUBLEBUFFER };\n\tWNDCLASS win;\n\tZeroMemory( &win, sizeof(WNDCLASS) );\n\twin.style = CS_OWNDC|CS_HREDRAW|CS_VREDRAW;\n\twin.lpfnWndProc = WindowProc;\n\twin.hInstance = 0;\n\twin.lpszClassName = \"noname\";\n\twin.hbrBackground =(HBRUSH)(COLOR_WINDOW+1);\n\tRegisterClass(&win);\n\tHDC hdc = GetDC(CreateWindowEx(0, win.lpszClassName, \"Compute Shader\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, width, height, 0, 0, 0, 0));\n\tSetPixelFormat(hdc,ChoosePixelFormat(hdc,&pfd),&pfd);\n\twglMakeCurrent(hdc,wglCreateContext(hdc));\n\t((PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress (\"wglSwapIntervalEXT\")) (0);\t\n\tglOrtho(0, width, 0, height, -1, 1);\n\tint CS = MakeShader(ComputeShader,0x91B9);\n\tMakeBuffer();\n\t((PFNGLUSEPROGRAMPROC)wglGetProcAddress(\"glUseProgram\"))(CS);\n\tint iTime = ((PFNGLGETUNIFORMLOCATIONPROC)wglGetProcAddress(\"glGetUniformLocation\"))(CS,\"iTime\");\n\tGLint iResolution = ((PFNGLGETUNIFORMLOCATIONPROC)wglGetProcAddress(\"glGetUniformLocation\"))(CS,\"iResolution\");\n\t((PFNGLUNIFORM2IPROC)wglGetProcAddress(\"glUniform2i\"))(iResolution, width, height);\t\n\twhile( !exit )\n\t{\n\t\twhile(PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )\n\t\t{\n\t\t\tif( msg.message==WM_QUIT ) exit = 1;\n\t\t\tTranslateMessage( &msg );\n\t\t\tDispatchMessage( &msg );\n\t\t}\n\t\tglBindTexture(GL_TEXTURE_2D, 1);\n\t\t((PFNGLUNIFORM1FPROC)wglGetProcAddress(\"glUniform1f\"))(iTime, GetTickCount()*0.001f);\n\t\t((PFNGLDISPATCHCOMPUTEPROC)wglGetProcAddress(\"glDispatchCompute\"))(width/8, height/8, 1);\t\t\n\t\tglBegin(GL_QUADS);\n\t\tglTexCoord2i(0, 0); glVertex2i(0, 0);\n\t\tglTexCoord2i(0, 1); glVertex2i(0, height);\n\t\tglTexCoord2i(1, 1); glVertex2i(width, height);\n\t\tglTexCoord2i(1, 0); glVertex2i(width, 0);\n\t\tglEnd();\n\t\twglSwapLayerBuffers(hdc,WGL_SWAP_MAIN_PLANE);\n\t} \n\treturn 0;\n}\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ceil(fragCoord/30. + sin(iTime));   \n    fragColor = mod(p.xxxx + p.y, 2.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n// cl ssbo.c opengl32.lib user32.lib gdi32.lib\n// Shader Storage Buffer Object example\n#include <windows.h>\n#include <GL/gl.h>\n\n#define width 1920\n#define height 1080\n\n#define GL_SHADER_STORAGE_BUFFER          0x90D2\n#define GL_READ_ONLY                      0x88B8\n#define GL_DYNAMIC_DRAW                   0x88E8\n#define GL_SHADER_STORAGE_BARRIER_BIT     0x00002000\n#define GL_COMPUTE_SHADER                 0x91B9\n\ntypedef GLuint(__stdcall *PFNGLCREATEPROGRAMPROC)();\ntypedef GLuint(__stdcall *PFNGLCREATESHADERPROC)(GLenum t);\ntypedef void(__stdcall *PFNGLSHADERSOURCEPROC)(GLuint s, GLsizei c, const char*const*string, const GLint* i);\ntypedef void(__stdcall *PFNGLCOMPILESHADERPROC)(GLuint s);\ntypedef void(__stdcall *PFNGLATTACHSHADERPROC)(GLuint p, GLuint s);\ntypedef void(__stdcall *PFNGLLINKPROGRAMPROC)(GLuint p);\ntypedef void(__stdcall *PFNGLUSEPROGRAMPROC)(GLuint p);\ntypedef void (__stdcall *PFNGLDISPATCHCOMPUTEPROC) (GLuint x, GLuint y, GLuint z);\ntypedef void (__stdcall *PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);\ntypedef void (__stdcall *PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);\ntypedef void (__stdcall *PFNGLBUFFERDATAPROC) (GLenum target, signed long int size, const void *data, GLenum usage);\ntypedef void (__stdcall *PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);\ntypedef void *(__stdcall *PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);\ntypedef GLboolean (__stdcall *PFNGLUNMAPBUFFERPROC) (GLenum target);\ntypedef void (__stdcall *PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);\ntypedef int (__stdcall *PFNGLGETUNIFORMLOCATIONPROC) (GLuint p, const char *n);\ntypedef void (__stdcall *PFNGLUNIFORM1FPROC) (GLint s, GLfloat v0);\ntypedef void (__stdcall *PFNGLUNIFORM2IPROC) (GLint s, GLint v0, GLint v1);\n\nPFNGLCREATEPROGRAMPROC glCreateProgram;\nPFNGLCREATESHADERPROC glCreateShader;\nPFNGLSHADERSOURCEPROC glShaderSource;\nPFNGLCOMPILESHADERPROC glCompileShader;\nPFNGLATTACHSHADERPROC glAttachShader;\nPFNGLLINKPROGRAMPROC glLinkProgram;\nPFNGLUSEPROGRAMPROC glUseProgram;\nPFNGLDISPATCHCOMPUTEPROC glDispatchCompute;\nPFNGLGENBUFFERSPROC glGenBuffers;\nPFNGLBINDBUFFERBASEPROC glBindBufferBase;\nPFNGLBUFFERDATAPROC glBufferData;\nPFNGLMEMORYBARRIERPROC glMemoryBarrier;\nPFNGLMAPBUFFERPROC glMapBuffer;\nPFNGLUNMAPBUFFERPROC glUnmapBuffer;\nPFNGLBINDBUFFERPROC glBindBuffer;\nPFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;\nPFNGLUNIFORM1FPROC glUniform1f;\nPFNGLUNIFORM2IPROC glUniform2i;\n\nvoid glInit()\n{\n\tglCreateProgram = (PFNGLCREATEPROGRAMPROC)wglGetProcAddress(\"glCreateProgram\");\n\tglCreateShader = (PFNGLCREATESHADERPROC)wglGetProcAddress(\"glCreateShader\");\n\tglShaderSource = (PFNGLSHADERSOURCEPROC)wglGetProcAddress(\"glShaderSource\");\n\tglCompileShader = (PFNGLCOMPILESHADERPROC)wglGetProcAddress(\"glCompileShader\");\n\tglAttachShader = (PFNGLATTACHSHADERPROC)wglGetProcAddress(\"glAttachShader\");\n\tglLinkProgram = (PFNGLLINKPROGRAMPROC)wglGetProcAddress(\"glLinkProgram\");\n\tglUseProgram = (PFNGLUSEPROGRAMPROC)wglGetProcAddress(\"glUseProgram\");\n\tglDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC)wglGetProcAddress(\"glDispatchCompute\");\n\tglGenBuffers = (PFNGLGENBUFFERSPROC)wglGetProcAddress(\"glGenBuffers\");\n\tglBindBufferBase = (PFNGLBINDBUFFERBASEPROC)wglGetProcAddress(\"glBindBufferBase\");\n\tglBufferData = (PFNGLBUFFERDATAPROC)wglGetProcAddress(\"glBufferData\");\n\tglMemoryBarrier = (PFNGLMEMORYBARRIERPROC)wglGetProcAddress(\"glMemoryBarrier\");\n\tglMapBuffer = (PFNGLMAPBUFFERPROC)wglGetProcAddress(\"glMapBuffer\");\n\tglUnmapBuffer = (PFNGLUNMAPBUFFERPROC)wglGetProcAddress(\"glUnmapBuffer\");\n\tglBindBuffer = (PFNGLBINDBUFFERPROC)wglGetProcAddress(\"glBindBuffer\");\n\tglGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)wglGetProcAddress(\"glGetUniformLocation\");\n\tglUniform1f = (PFNGLUNIFORM1FPROC)wglGetProcAddress(\"glUniform1f\");\n\tglUniform2i = (PFNGLUNIFORM2IPROC)wglGetProcAddress(\"glUniform2i\");\n}\n\nstatic const char* ComputeShader = \\\n\t\"#version 430 core\\n\"\n\t\"layout (local_size_x = 8, local_size_y = 8) in;\"\n\t\"layout(std430, binding=0) writeonly buffer Pixels {float image[];};\"\n\t\"uniform float iTime;\"\n\t\"uniform ivec2 iResolution;\"\n\t\n\t\"float encode(vec4 c)\"\n\t\"{\"\n\t\t\"int rgba = (int(c.w * 255.0) << 24) + (int(c.z * 255.0) << 16) + (int(c.y * 255.0) << 8) + int(c.x * 255.0);\"\n\t\t\"return intBitsToFloat(rgba);\"\n\t\"}\"\n\t\n\t\"void main()\"\n\t\"{\"\n\t\t\"vec2 fragCoord = gl_GlobalInvocationID.xy;\"\n\t\t\"vec2 p = ceil(fragCoord/30. + sin(iTime)); \"  \n\t\t\"vec4 fragColor = mod(p.xxxx + p.y, 2.);\"\n\t\t\"image[iResolution.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x] = encode(clamp(vec4(fragColor.zyx,1.0),vec4(0.0),vec4(1.0)));\"\n\t\"}\" ;\n\t\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif (uMsg==WM_CLOSE || uMsg==WM_DESTROY || (uMsg==WM_KEYDOWN && wParam==VK_ESCAPE))\n\t{\n\t\tPostQuitMessage(0); return 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"Demo\"};\n\tRegisterClass(&win);\n\tHDC hdc = GetDC(CreateWindowEx(0, win.lpszClassName, \"Demo\", WS_VISIBLE|WS_POPUP, 0, 0, width, height, 0, 0, 0, 0));\n\tPIXELFORMATDESCRIPTOR pfd = {0, 0, PFD_DOUBLEBUFFER};\n\tSetPixelFormat(hdc,ChoosePixelFormat(hdc,&pfd),&pfd);\n\twglMakeCurrent(hdc,wglCreateContext(hdc));\n\tShowCursor(0);\n\tglInit();\n\tBITMAPINFO bmi = {{sizeof(BITMAPINFOHEADER),width,height,1,32,BI_RGB,0,0,0,0,0},{0,0,0,0}};\n\tunsigned char *buffer = (unsigned char *) malloc(width*height*4);\n\tint P = glCreateProgram();\n\tint CS = glCreateShader(GL_COMPUTE_SHADER);\n\tglShaderSource(CS, 1, &ComputeShader, 0);\n\tglCompileShader(CS);\n\tglAttachShader(P, CS);\n\tglLinkProgram(P); \n\tglUseProgram(P);\n\tunsigned int SSBO = 0;\n\tglGenBuffers(1, &SSBO);\n\tglBindBufferBase (GL_SHADER_STORAGE_BUFFER, 0, SSBO);\n\tglBufferData (GL_SHADER_STORAGE_BUFFER, width*height*4, 0, GL_DYNAMIC_DRAW);\n\tint iTime = glGetUniformLocation(P,\"iTime\");\n\tint iResolution = glGetUniformLocation(P,\"iResolution\");\n\tglUniform2i(iResolution, width, height);\n\twhile (!exit)\n\t{\n\t\twhile(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif( msg.message==WM_QUIT ) exit = 1;\n\t\t\tTranslateMessage( &msg );\n\t\t\tDispatchMessage( &msg );\n\t\t}\n\t\tglUniform1f(iTime, GetTickCount()*0.001f);\n\t\tglDispatchCompute(width/8, height/8, 1);\n\t\tglMemoryBarrier (GL_SHADER_STORAGE_BARRIER_BIT);\n\t\tglBindBuffer(GL_SHADER_STORAGE_BUFFER, SSBO);\n\t\tbuffer = (unsigned char *) glMapBuffer (GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY);\n\t\tStretchDIBits(hdc,0,0,width,height,0,0,width,height,buffer,&bmi,DIB_RGB_COLORS,SRCCOPY);\n\t\tglUnmapBuffer (GL_SHADER_STORAGE_BUFFER);\t\n\t}\n\tfree(buffer);\n\treturn 0;\n}\n\n*/\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}