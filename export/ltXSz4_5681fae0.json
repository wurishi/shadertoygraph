{"ver":"0.1","info":{"id":"ltXSz4","date":"1434815042","viewed":1759,"name":"NightRide","username":"kuvkar","description":"boat ride at night.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["waves","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst float WLEN = 8.0;\nconst float phase = 2.2;\n\n\nstruct Ray\n{\n    vec3 o;\n    vec3 p;\n    vec3 d;\n};\n\n    \nvoid flter(inout vec4 col, float f)\n{\n    col -= f;\n    col = clamp(col, 0.0, 1.0);\n    col /= 1.0 - f;\n}\n\nfloat flter(float f, float a)\n{\n    f -= a;\n    f = clamp(f, 0.0, 1.0);\n    f /= 1.0 - a;\n    return f;\n}\n    \nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    \n    float h1 = (sin ( dot(d, uv) / WLEN + phase * t)) * 0.5;\n    \n    float h2 = (sin ( dot(d, uv) / WLEN + phase * t));\n    h2 *= h2;\n    h2 *= 0.2;\n    \n    float h3 = (sin ( dot(d, uv) / WLEN + phase * t));\n    h3 *= h3 * h3;\n    h3 *= 0.1;\n        \n    float w = sin(dot(uv.yx * .015, d)) * 0.5 + 0.5; \n    return mix(w, 1.0, 0.9) * (h1 + h2 + h3) * A;\n}\n\nfloat waves(in vec2 uv, float t, float A)\n{\n    float w1 = wv(uv, vec2(1.0, -0.1), t, A) * 0.4;\n    float w2 = wv(uv * 14.0, vec2(0.5, 0.2), t, A) * 0.015;\n    \n    vec2 d2 = vec2(0.4, 0.7);\n    float w3 = wv(uv * 2.0, d2, t * 1.5, A) * 0.25;\n\n    vec2 d3 = (vec2(0.7, 0.5));\n    float w4 = wv(uv * 5.0, d3, t * 1.5, A) * 0.15;\n    float w5 = wv(uv * 14.0, vec2(0.0, 0.5), t, A) * 0.015;\n    \n    return w5 + w4 + w3 + w2 + w1;\n}\n\nfloat map(in vec3 rp)\n{\n    \n    vec2 uv = rp.xz * 0.08;\n    float b = texture(iChannel0, uv, -100.0).r * 0.5;\n    b += texture(iChannel0, uv * 2.0, -100.0).r * 0.25;\n    b += texture(iChannel0, uv * 4.0, -100.0).r * 0.0125;\n    b *= 0.025;\n    // choppy waves by offsetting ray\n    rp.x += pow(max(rp.y, 0.0), 2.3) * 0.45;\n    \n    float A = 4.0;\n    float w = rp.y - waves(rp.xz, 2.0 + iTime * 0.5, A);\n    return w + b;\n}\n\nvec3 grad(vec3 rp)\n{\n    vec2 off = vec2(0.001, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nvec3 light = normalize(vec3(-0.2, 0.1, -1.0));\n\n\nbool trace(inout Ray r, inout vec4 color)\n{\n    vec3 rd = r.d;\n    float topy = 2.8;\n    r.p += r.d * (r.p.y - topy) / abs(r.d.y);\n    \n    float dist = 0.0;\n    bool hit = false;\n\tfor (int i = 0; i < 85; ++i)\n    {\n        float h = map(r.p);\n        if ( h < 0.7)\n        {\n            hit = true;\n            \n        }\n        float trvl = max(h * (0.25 * exp(max(0.0, dist - 5.0) * .07)), 0.01); \n        r.p += r.d * trvl;\n        dist += trvl;\n        if(dist > 180.0)\n        {\n            return false;\n        }\n    }\n    \n    if (hit)\n    {\n        vec3 rp = r.p;\n        vec3 g = grad(r.p);\n        // diffuse\n        float d = dot(g, light);\n        d = clamp(d, 0.1, 1.0) * 0.4;\n        color = vec4(0.6, 0.85, 0.9, 1.0) * d;\n\n        // rim\n        float r = 1.0 - clamp(dot(-r.d, g), 0.0, 1.0);\n\n        r = pow(r, 4.0);\n        color += vec4(0.6, 0.8, 0.95, 1.0) * r * 0.6;\n\n        // static foam\n        vec4 wcol = texture(iChannel1, rp.xz * 0.003, -100.0);\n        wcol = vec4(wcol.r);\n        flter(wcol, 0.7);\n        color += wcol * 0.6;\n\n        // dynamic foam\n        vec4 topfoam = texture(iChannel1, rp.xz * 0.02, -100.0).rrrr;\n        vec4 topfoam2 = texture(iChannel1, (rp.zy +vec2(0.0, -iTime * 5.0)) * 0.05, -100.0).rrrr;\n\n        topfoam = mix(topfoam, topfoam2, dot(g, normalize(vec3(-1.0, -0.0, 0.5))));\n        topfoam = clamp(topfoam, 0.0, 1.0);\n        float f = smoothstep(2.0, 2.4, rp.y);\n        topfoam = mix(vec4(0.0), topfoam, f) * 0.5;\n        color += topfoam;\n\n        // spec\n        vec3 H = normalize(-rd + normalize(vec3(0.0, 2.0, 9.0)));\n        float spc = dot(H, g);\n        spc = clamp(spc, 0.0, 1.0);\n        spc = pow(spc, 30.0);\n\n        color += vec4(0.7, 0.7, 0.6, 1.0) * spc * 0.6;\n        \n    }\n    \n    return hit;\n}\n\nfloat fbm (vec2 uv)\n{\n    float f = (texture(iChannel0, uv).r - 0.5, -100.0) * 0.5;\n    f += (texture(iChannel0, uv * 2.0).r - 0.5, -100.) * 0.25;\n    f += (texture(iChannel0, uv * 4.0).r - 0.5, -100.) * 0.125;\n    f += (texture(iChannel0, uv *  8.0).r - 0.5, -100.) * 0.125 * 0.5;\n    f += (texture(iChannel0, uv * 16.0).r - 0.5, -100.) * 0.125 * 0.5 * 0.5;\n    f += (texture(iChannel0, uv * 32.0).r - 0.5, -100.) * 0.125 * 0.5 * 0.5 * 0.5;\n    return clamp(f + 0.5, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    fragColor = vec4(1.0);\n    \n    // movement\n    vec3 _uv = vec3(uv, 0.0);\n    _uv.y += sin(iTime * 0.5) * 0.05;\n    _uv *= rotz(sin(iTime * 0.5) * 0.1);\n    \n    uv = vec2(_uv);\n    \n    // tracing\n    Ray r;\n    r.o = vec3(0.0, 10.0, -1.0 + iTime * 5.0);\n    r.p = r.o;\n    r.d = normalize(vec3(uv + vec2(0.0, -0.1), 1.));\n    \n    vec3 ro = r.o;\n    bool hit = trace(r, fragColor);\n    \n    // bg fog\n    float l = length(ro - r.p);\n    float s = smoothstep(70.0, 170.0, l);\n    vec4 fog = vec4(0.3, 0.7, 0.95, 1.0);\n    float fg = smoothstep(-0.3, 0.3, uv.y);\n    fog = mix(fog, vec4(0.2), fg);\n    fragColor = mix(fragColor, fog,  s);\n\n    \n\t// out of gamut correction    \n    float m = max(fragColor.r, fragColor.g);\n    m = max(fragColor.b, m);\n    m /= max(1.0, m);\n    \n    // clouds\n    vec2 skyuv = vec2(r.d.x / r.d.y, r.d.z / r.d.y) * 0.005;\n    float t = iTime * .012;\n    \n    float f = fbm(skyuv + vec2(0.0, t));\n    f = flter(f, 0.5) * 0.5;\n\n    float f2 = fbm(skyuv * 1.5 + vec2(0.0, t * 1.1));\n    f += flter(f2, 0.4) * 0.25;\n\n    float f3 = fbm(skyuv * 2.5 + vec2(0.0, t * 1.4));\n    f += flter(f2, 0.2) * 0.0125;\n    f = clamp(f, 0.0, 1.0) * smoothstep(0.05, 0.5, uv.y);\n    \n    vec4 sky = vec4(1.0) * f;\n    \n    float moon = 1.0 - smoothstep(0.04, 0.05, length(uv - vec2(0.0, 0.2)));\n    float halo = 1.0 - smoothstep(0.04, 0.4, length(uv - vec2(0.0, 0.2)));\n    \n    vec4 mooncol = moon * mix(texture(iChannel1, uv * 2.0, -100.0).rrrr, vec4(1.0), 0.3);\n    mooncol += halo * vec4(1.0) * 0.2;\n    mooncol = clamp(mooncol, 0.0, 1.0);\n    \n    fragColor += mix(mooncol, sky, clamp(f * 15.0, 0.0, 1.0));\n\t\n}","name":"Image","description":"","type":"image"}]}