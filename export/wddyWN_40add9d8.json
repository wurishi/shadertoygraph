{"ver":"0.1","info":{"id":"wddyWN","date":"1600976168","viewed":174,"name":"Raymarching with PBR","username":"RodzLabs","description":"This shader was generated using Material Maker.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","generated","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand31(vec3 p) {\n\treturn fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\nvec3 rand33(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat tex3d_fbm_value(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec3 f = fract(coord);\n\tfloat p000 = rand31(mod(o, size));\n\tfloat p001 = rand31(mod(o + vec3(0.0, 0.0, 1.0), size));\n\tfloat p010 = rand31(mod(o + vec3(0.0, 1.0, 0.0), size));\n\tfloat p011 = rand31(mod(o + vec3(0.0, 1.0, 1.0), size));\n\tfloat p100 = rand31(mod(o + vec3(1.0, 0.0, 0.0), size));\n\tfloat p101 = rand31(mod(o + vec3(1.0, 0.0, 1.0), size));\n\tfloat p110 = rand31(mod(o + vec3(1.0, 1.0, 0.0), size));\n\tfloat p111 = rand31(mod(o + vec3(1.0, 1.0, 1.0), size));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_perlin(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec3 f = fract(coord);\n\tvec3 v000 = normalize(rand33(mod(o, size))-vec3(0.5));\n\tvec3 v001 = normalize(rand33(mod(o + vec3(0.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v010 = normalize(rand33(mod(o + vec3(0.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v011 = normalize(rand33(mod(o + vec3(0.0, 1.0, 1.0), size))-vec3(0.5));\n\tvec3 v100 = normalize(rand33(mod(o + vec3(1.0, 0.0, 0.0), size))-vec3(0.5));\n\tvec3 v101 = normalize(rand33(mod(o + vec3(1.0, 0.0, 1.0), size))-vec3(0.5));\n\tvec3 v110 = normalize(rand33(mod(o + vec3(1.0, 1.0, 0.0), size))-vec3(0.5));\n\tvec3 v111 = normalize(rand33(mod(o + vec3(1.0, 1.0, 1.0), size))-vec3(0.5));\n\tfloat p000 = dot(v000, f);\n\tfloat p001 = dot(v001, f - vec3(0.0, 0.0, 1.0));\n\tfloat p010 = dot(v010, f - vec3(0.0, 1.0, 0.0));\n\tfloat p011 = dot(v011, f - vec3(0.0, 1.0, 1.0));\n\tfloat p100 = dot(v100, f - vec3(1.0, 0.0, 0.0));\n\tfloat p101 = dot(v101, f - vec3(1.0, 0.0, 1.0));\n\tfloat p110 = dot(v110, f - vec3(1.0, 1.0, 0.0));\n\tfloat p111 = dot(v111, f - vec3(1.0, 1.0, 1.0));\n\tvec3 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(mix(p000, p100, t.x), mix(p010, p110, t.x), t.y), mix(mix(p001, p101, t.x), mix(p011, p111, t.x), t.y), t.z);\n}\n\nfloat tex3d_fbm_cellular(vec3 coord, vec3 size, float seed) {\n\tvec3 o = floor(coord)+rand3(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec3 f = fract(coord);\n\tfloat min_dist = 3.0;\n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n\t\t\tfor (float z = -1.0; z <= 1.0; z++) {\n\t\t\t\tvec3 node = 0.4*rand33(mod(o + vec3(x, y, z), size)) + vec3(x, y, z);\n\t\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y + (f - node).z * (f - node).z);\n\t\t\t\tmin_dist = min(min_dist, dist);\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\nvec2 sdf3dc_union(vec2 a, vec2 b) {\n\treturn vec2(min(a.x, b.x), mix(b.y, a.y, step(a.x, b.x)));\n}\nvec2 sdf3dc_sub(vec2 a, vec2 b) {\n\treturn vec2(max(-a.x, b.x), a.y);\n}\nvec2 sdf3dc_inter(vec2 a, vec2 b) {\n\treturn vec2(max(a.x, b.x), mix(a.y, b.y, step(a.x, b.x)));\n}\nfloat noise3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p){\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\n}\n\n//from https://www.shadertoy.com/view/4sSfzK\n\nvec3 EnvRemap(vec3 c) {\n\treturn pow(2. * c, vec3(2.2));\n}\n\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl) {\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\nfloat DistributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * 3.14159265359);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth) {\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nconst float p_o11766_CamY = 0.000000000;\nconst float p_o11766_LookAtX = 0.000000000;\nconst float p_o11766_LookAtY = 0.000000000;\nconst float p_o11766_LookAtZ = 0.000000000;\nconst float p_o11766_CamD = 1.100000000;\nconst float p_o11766_SunX = 2.760000000;\nconst float p_o11766_SunY = 4.190000000;\nconst float p_o11766_SunZ = 3.030000000;\nconst float p_o11794_distort = 0.020000000;\nconst float p_o11767_r = 0.120000000;\nconst int seed_o11781 = 15393;\nconst float p_o11781_scale_x = 24.000000000;\nconst float p_o11781_scale_y = 24.000000000;\nconst float p_o11781_scale_z = 8.000000000;\nconst float p_o11781_iterations = 1.000000000;\nconst float p_o11781_persistence = 0.450000000;\nfloat o11781_fbm(vec3 coord, vec3 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += tex3d_fbm_value(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nconst float p_o11783_x = 0.000000000;\nconst float p_o11783_y = -0.140000000;\nconst float p_o11783_z = 0.000000000;\nconst float p_o11782_sx = 0.300000000;\nconst float p_o11782_sy = 0.010000000;\nconst float p_o11782_sz = 0.300000000;\nconst float p_o11782_r = 0.000000000;\nvec2 o11766_input_sdf(vec3 p) {\nfloat o11767_0_1_sdf3d = length(((p).xyz))-p_o11767_r;\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec2 o11794_0_1_sdf3dc = vec2(vec2(o11767_0_1_sdf3d, 0.0).x+p_o11794_distort*dot(o11781_0_1_tex3d, vec3(1.0/3.0)), vec2(o11767_0_1_sdf3d, 0.0).y);\nvec3 o11782_0_q = abs(((p)-vec3(p_o11783_x, p_o11783_y, p_o11783_z))) - vec3(p_o11782_sx, p_o11782_sy, p_o11782_sz);\nfloat o11782_0_1_sdf3d = length(max(o11782_0_q,0.0))+min(max(o11782_0_q.x,max(o11782_0_q.y,o11782_0_q.z)),0.0)-p_o11782_r;\nvec2 o11783_0_1_sdf3dc = vec2(o11782_0_1_sdf3d, 0.0);\nvec2 o11784_0_1_sdf3dc = sdf3dc_union(o11794_0_1_sdf3dc, o11783_0_1_sdf3dc);\n\nreturn o11784_0_1_sdf3dc;\n}\nconst float p_o11768_g_0_pos = 0.426068000;\nconst float p_o11768_g_0_r = 0.534729004;\nconst float p_o11768_g_0_g = 1.000000000;\nconst float p_o11768_g_0_b = 0.507812977;\nconst float p_o11768_g_0_a = 1.000000000;\nconst float p_o11768_g_1_pos = 0.427967000;\nconst float p_o11768_g_1_r = 1.000000000;\nconst float p_o11768_g_1_g = 0.511718988;\nconst float p_o11768_g_1_b = 0.511718988;\nconst float p_o11768_g_1_a = 1.000000000;\nvec4 o11768_g_gradient_fct(float x) {\n  if (x < p_o11768_g_0_pos) {\n    return vec4(p_o11768_g_0_r,p_o11768_g_0_g,p_o11768_g_0_b,p_o11768_g_0_a);\n  } else if (x < p_o11768_g_1_pos) {\n    return mix(vec4(p_o11768_g_0_r,p_o11768_g_0_g,p_o11768_g_0_b,p_o11768_g_0_a), vec4(p_o11768_g_1_r,p_o11768_g_1_g,p_o11768_g_1_b,p_o11768_g_1_a), ((x-p_o11768_g_0_pos)/(p_o11768_g_1_pos-p_o11768_g_0_pos)));\n  }\n  return vec4(p_o11768_g_1_r,p_o11768_g_1_g,p_o11768_g_1_b,p_o11768_g_1_a);\n}\nvec3 o11766_input_albedo(vec4 p) {\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec3 o11768_0_1_tex3d = o11768_g_gradient_fct(dot(o11781_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn o11768_0_1_tex3d;\n}\nconst float p_o11795_g_0_pos = 0.450529000;\nconst float p_o11795_g_0_r = 0.000000000;\nconst float p_o11795_g_0_g = 0.000000000;\nconst float p_o11795_g_0_b = 0.000000000;\nconst float p_o11795_g_0_a = 1.000000000;\nconst float p_o11795_g_1_pos = 0.454545000;\nconst float p_o11795_g_1_r = 1.000000000;\nconst float p_o11795_g_1_g = 1.000000000;\nconst float p_o11795_g_1_b = 1.000000000;\nconst float p_o11795_g_1_a = 1.000000000;\nvec4 o11795_g_gradient_fct(float x) {\n  if (x < p_o11795_g_0_pos) {\n    return vec4(p_o11795_g_0_r,p_o11795_g_0_g,p_o11795_g_0_b,p_o11795_g_0_a);\n  } else if (x < p_o11795_g_1_pos) {\n    return mix(vec4(p_o11795_g_0_r,p_o11795_g_0_g,p_o11795_g_0_b,p_o11795_g_0_a), vec4(p_o11795_g_1_r,p_o11795_g_1_g,p_o11795_g_1_b,p_o11795_g_1_a), ((x-p_o11795_g_0_pos)/(p_o11795_g_1_pos-p_o11795_g_0_pos)));\n  }\n  return vec4(p_o11795_g_1_r,p_o11795_g_1_g,p_o11795_g_1_b,p_o11795_g_1_a);\n}\nvec3 o11766_input_roughness(vec4 p) {\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec3 o11795_0_1_tex3d = o11795_g_gradient_fct(dot(o11781_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn o11795_0_1_tex3d;\n}\nconst float p_o11808_g_0_pos = 0.418182000;\nconst float p_o11808_g_0_r = 1.000000000;\nconst float p_o11808_g_0_g = 1.000000000;\nconst float p_o11808_g_0_b = 1.000000000;\nconst float p_o11808_g_0_a = 1.000000000;\nconst float p_o11808_g_1_pos = 0.422290000;\nconst float p_o11808_g_1_r = 0.000000000;\nconst float p_o11808_g_1_g = 0.000000000;\nconst float p_o11808_g_1_b = 0.000000000;\nconst float p_o11808_g_1_a = 1.000000000;\nvec4 o11808_g_gradient_fct(float x) {\n  if (x < p_o11808_g_0_pos) {\n    return vec4(p_o11808_g_0_r,p_o11808_g_0_g,p_o11808_g_0_b,p_o11808_g_0_a);\n  } else if (x < p_o11808_g_1_pos) {\n    return mix(vec4(p_o11808_g_0_r,p_o11808_g_0_g,p_o11808_g_0_b,p_o11808_g_0_a), vec4(p_o11808_g_1_r,p_o11808_g_1_g,p_o11808_g_1_b,p_o11808_g_1_a), ((x-p_o11808_g_0_pos)/(p_o11808_g_1_pos-p_o11808_g_0_pos)));\n  }\n  return vec4(p_o11808_g_1_r,p_o11808_g_1_g,p_o11808_g_1_b,p_o11808_g_1_a);\n}\nvec3 o11766_input_metallic(vec4 p) {\nvec3 o11781_0_1_tex3d = vec3(o11781_fbm((p).xyz, vec3(p_o11781_scale_x, p_o11781_scale_y, p_o11781_scale_z), int(p_o11781_iterations), p_o11781_persistence, float(seed_o11781)));\nvec3 o11808_0_1_tex3d = o11808_g_gradient_fct(dot(o11781_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn o11808_0_1_tex3d;\n}\nconst float p_o11785_g_0_pos = 0.000000000;\nconst float p_o11785_g_0_r = 0.000000000;\nconst float p_o11785_g_0_g = 0.059570000;\nconst float p_o11785_g_0_b = 0.238280997;\nconst float p_o11785_g_0_a = 1.000000000;\nconst float p_o11785_g_1_pos = 1.000000000;\nconst float p_o11785_g_1_r = 0.156250000;\nconst float p_o11785_g_1_g = 0.248535007;\nconst float p_o11785_g_1_b = 1.000000000;\nconst float p_o11785_g_1_a = 1.000000000;\nvec4 o11785_g_gradient_fct(float x) {\n  if (x < p_o11785_g_0_pos) {\n    return vec4(p_o11785_g_0_r,p_o11785_g_0_g,p_o11785_g_0_b,p_o11785_g_0_a);\n  } else if (x < p_o11785_g_1_pos) {\n    return mix(vec4(p_o11785_g_0_r,p_o11785_g_0_g,p_o11785_g_0_b,p_o11785_g_0_a), vec4(p_o11785_g_1_r,p_o11785_g_1_g,p_o11785_g_1_b,p_o11785_g_1_a), ((x-p_o11785_g_0_pos)/(p_o11785_g_1_pos-p_o11785_g_0_pos)));\n  }\n  return vec4(p_o11785_g_1_r,p_o11785_g_1_g,p_o11785_g_1_b,p_o11785_g_1_a);\n}\nvec3 o11766_input_sky(vec4 p) {\nvec3 o11785_0_1_tex3d = mix(o11785_g_gradient_fct((p).y+0.3).rgb, vec3(1.0), clamp((p).y*10., 0., 1.) * pow(fbm(vec3((p).xz/(p).y+0.25*vec2(iTime), 0.25*iTime)), 2.0));\n\nreturn o11785_0_1_tex3d;\n}\nvec3 normal_o11766(vec3 p) {\n\tfloat d = o11766_input_sdf(p).x;\n    vec2 e = vec2(.00001,0);\n    vec3 n = d - vec3(\n        o11766_input_sdf(p-vec3(e.xyy)).x,\n        o11766_input_sdf(p-vec3(e.yxy)).x,\n        o11766_input_sdf(p-vec3(e.yyx)).x);\n    return normalize(n);\n}\n\nvoid march_o11766(out float d, out vec3 p, out vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = o11766_input_sdf(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o11766(in vec3 pos, in vec3 nor){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i=0; i<5; i++){\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = o11766_input_sdf(pos + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o11766(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for(int i=0; i<32; i++) {\n\t\tfloat h = o11766_input_sdf(ro+rd*t).x;\n        res = min(res, 2.0*h/t);\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 SHIrradiance_o11766(vec3 nrm) {\n\tvec3 irr = vec3(0.0);\n\tfloat sum = 0.0;\n\tfor (float x = -1.0; x < 1.1; x += 0.66666666666666) {\n\t\tfor (float y = -1.0; y < 1.1; y += 0.66666666666666) {\n\t\t\tfor (float z = -1.0; z < 1.1; z += 0.66666666666666) {\n\t\t\t\tvec3 v = normalize(vec3(x, y, z));\n\t\t\t\tfloat factor = 1.0+dot(nrm, v);\n\t\t\t\tirr += factor*o11766_input_sky(vec4(v, 0.0));\n\t\t\t\tsum += factor;\n\t\t\t}\n\t\t}\n\t}\n\treturn irr/sum;\n}\n\n//from https://www.shadertoy.com/view/4sSfzK\nvec3 PBR_o11766(vec3 p, vec3 normal, vec3 cameraPos, vec3 albedo, float roughness, float metallic, vec3 lightPos, vec3 lightColor, float ao) {\n\tvec3 diffuseColor = mix(albedo, vec3(0.0), metallic);\n\tvec3 specularColor = mix(vec3(0.02), albedo, metallic);\n\tfloat roughnessE = roughness * roughness;\n\tfloat roughnessL = max(.01, roughnessE);\n\tvec3 rayDir = normalize(p-cameraPos);\n\tvec3 viewDir = -rayDir;\n\tvec3 lightDir = normalize(lightPos-p);\n\tvec3 refl = reflect(rayDir, normal);\n\tvec3 halfVec = normalize(viewDir + lightDir);\n\tfloat vdoth = clamp(dot(viewDir, halfVec), 0.0, 1.0);\n\tfloat ndoth = clamp(dot(normal, halfVec), 0.0, 1.0);\n\tfloat ndotv = clamp(dot(normal, viewDir), 0.0, 1.0);\n\tfloat ndotl = clamp(dot(normal, lightDir), 0.0, 1.0);\n\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\n\tvec3 env1 = EnvRemap(o11766_input_sky(vec4(refl, 0.0)));\n\tvec3 env2 = EnvRemap(o11766_input_sky(vec4(refl, 0.0)));\n\tvec3 env3 = EnvRemap(SHIrradiance_o11766(refl));\n\tvec3 env = mix(mix(env1, env2, clamp(roughnessE * 4.0, 0.0, 1.0)), env3, clamp((roughnessE - 0.25) / 0.75, 0.0, 1.0));\n\tvec3 diffuse = diffuseColor * EnvRemap(SHIrradiance_o11766(normal));\n\tvec3 specular = envSpecularColor * env;\n\n\tdiffuse += diffuseColor * lightColor * clamp(dot(normal, lightDir), 0.0, 1.0);\n\n\tvec3 lightF = FresnelTerm(specularColor, vdoth);\n\tfloat lightD = DistributionTerm(roughnessL, ndoth);\n\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\n\tspecular += lightColor * lightF * (lightD * lightV * 3.14159265359 * ndotl);\n\n\tdiffuse *= ao;\n\tspecular *= clamp(pow(ndotv + ao, roughnessE) - 1. + ao, 0.0, 1.0);\n\n\tvec3 color = diffuse + specular;\n\treturn pow(color * .4, vec3(1. / 2.2));\n}\n\nvec3 raymarch_o11766(vec2 uv) {\n    uv-=0.5;\n    vec3 cam=vec3((0.5*sin(iTime)), p_o11766_CamY, (0.5*cos(iTime)));\n\tvec3 lookat=vec3(p_o11766_LookAtX, p_o11766_LookAtY, p_o11766_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0, 1.0, 0.0), ray));\n\tvec3 cY=normalize(cross(cX, ray));\n\tvec3 rd = normalize(ray*p_o11766_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o11766(d, p, dS, ro, rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 sky = o11766_input_sky(vec4(rd, 0.0));\n\tif (d < 50.0) {\n\t\tfloat fog=max(1.0-(d/50.0),0.0);\n\t\tvec3 light=normalize(vec3(p_o11766_SunX,p_o11766_SunY,p_o11766_SunZ));\n\t\tvec3 albedo = o11766_input_albedo(vec4(p, dS.y));\n\t\tfloat roughness = dot(o11766_input_roughness(vec4(p, dS.y)), vec3(1.0/3.0));\n\t\tfloat metallic = dot(o11766_input_metallic(vec4(p, dS.y)), vec3(1.0/3.0));\n\t    vec3 n = normal_o11766(p);\n\t\tfloat l = clamp(dot(light, n), 0.0, 1.0);\n\t\tfloat cAO = calcAO_o11766(p,n);\n\t\tfloat shadow = calcSoftshadow_o11766(p, light, 0.05, 5.0);\n\t\tcolor = PBR_o11766(p, n, cam, albedo, roughness, metallic, vec3(p_o11766_SunX,p_o11766_SunY,p_o11766_SunZ), vec3(1.0), pow(cAO, 0.2)*shadow);\n\t\t//color = color*(fog)*1.4+sky*(1.0-fog)\n\t} else {\n\t    color = sky;\n\t}\n    return color;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o11766_0_d = vec4(raymarch_o11766((UV)),1.0);\n\nvec4 o11766_0_1_rgba = o11766_0_d;\nfragColor = o11766_0_1_rgba;\n}\n","name":"Image","description":"","type":"image"}]}