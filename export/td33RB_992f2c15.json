{"ver":"0.1","info":{"id":"td33RB","date":"1568775212","viewed":164,"name":"Repeating Ray March","username":"AlexWalley","description":"Learning how to make repetitive patterns with raymarching. It is a bit dark though, I would love to take comments and suggestions!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n   \treturn length(max(d, 0.)) + \n        \tmin(max(d.x, max(d.y, d.z)), 0.);\n}\nfloat sdBoxColor(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n   \treturn length(max(d, 0.));\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 map(vec3 p){\n    \n    p.xz = fract(p.xz) - 0.5;\n    p = fract(p) - 0.5;\n    \n    float barThickness = 0.45;\n    float boxDist1 = sdBox(p, vec3(0.5));\n    float boxDist2 = sdBox(p, vec3(0.6, barThickness, barThickness));\n    float boxDist3 = sdBox(p, vec3(barThickness, barThickness, 0.6));\n    float boxDist4 = sdBox(p, vec3(barThickness, 0.6, barThickness));\n    \n    float yoff = fract(iTime)-0.5;\n    \n    \n    vec3 sphPos = vec3(0.5, yoff*sign(p.x), 0.5);\n    float sphDist = length(p-sphPos) - 0.2;\n    float sphDist2 = length(p+sphPos)-0.2;\n    \n    sphPos = vec3(0.5, yoff*sign(p.x), -0.5);\n    float sphDist3 = length(p-sphPos) - 0.2;\n    float sphDist4 = length(p+sphPos)-0.2;\n    \n    vec2 res = vec2(0.);\n    res = vec2(max(-boxDist2, boxDist1), (boxDist1 < boxDist2) ? 3. : 3.);\n    res = vec2(max(-boxDist3, res.x), res.y);\n    res = vec2(max(-boxDist4, res.x), res.y);\n    \n    float a = 0.;\n    float b = 0.;\n    \n    //Ball on grid\n    float k = 0.11;\n    res.x = smin(res.x, sphDist,  k);\n    res.x = smin(res.x, sphDist2, k);\n  \tres.x = smin(res.x, sphDist3, k);\n    res.x = smin(res.x, sphDist4, k);\n    \n    return res;\n}\n\n//https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k){\n \n    float res = 1.0;\n    for(float t = mint; t < maxt;){\n        float h = map(ro + rd*t).x;\n        if(h < SURF_DIST) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    float dS = 0.;\n    float t;\n    for(t = 0.; t < MAX_STEPS; t++){\n\t\tdS = map(ro+rd*dO).x;\n        \n        if(dO > MAX_DIST) return vec2(dO, -1.);\n        if(dS < SURF_DIST) return vec2(dO, map(ro+rd*dO).y);\n        \n        dO += dS;\n    }\n    return vec2(dO, -1.);\n}\n\nvec3 applyFog(vec3 rgb, float dist){\n\n    float amount = 1.0 - exp(-dist*2.*rgb.b);\n    return mix(rgb, vec3(0.), amount);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 e = vec2(0.01, 0.);\n    float d = map(p).x;\n    return normalize(d - vec3(map(p-e.xyy).x,\n                    \t\t  map(p-e.yxy).x,\n                   \t\t\t  map(p-e.yyx).x));\n}\n\nvec3 getLight(vec3 p, vec3 ro){\n\n    vec3 lightPos = vec3(0, 0., 0.);\n    lightPos = ro + vec3(3.*sin(iTime), 0., 3.*cos(iTime));\n    vec3 n = getNormal(p);\n    \n    vec3 l = normalize(lightPos-p);\n    \n    float sunDif = max(dot(n,l), 0.);\n   \tfloat hardSha = (rayMarch(p+n*SURF_DIST*2., l).y > 0.) ? 0. : 1.;\n    float softSha = softShadow(p, l, 1., 100., 32.);\n    float skyDif = clamp(0.5 + 0.5*dot( vec3(0.,1.,0.), n), 0., 1.);\n    float bounceDif = clamp(dot(n, vec3(0.,-1.,0.)), 0., 1.);\n    float specular = pow(max( dot( reflect(-l, n), normalize(p-ro) ), 0.), 2.);\n    \n    vec3 mat = vec3(0.2);\n    \n    vec3 res = vec3(0.);\n    //res += mat*sunDif*(hardSha+0.3)*vec3(0.8, 0.6, 0.3);\n    res += mat*sunDif*softSha*vec3(0.8, 0.6, 0.3);\n    res += specular*vec3(0.8, 0.6, 0.3);\n    res += mat*vec3(0.8, 0.3, 0.6)*0.1;\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;   \n    vec3 col = vec3(0.);\n\n    \n    //============CAMERA==================\n    float zoom = 0.5;\n    \n    float t = mod(iTime, 200.)*0.2;\n    \n    vec3 ro = vec3(3.*sin(t), 1., 3.*cos(t));\n    ro = vec3(1.0);\n    //ro = vec3(1., sin(iTime)*0.5+0.5, 0.);\n    \n    \n    vec3 lookat = vec3(0.);\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0.,1.,0.),f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = i-ro;\n    \n    //Taken from Shane https://www.shadertoy.com/view/4dt3zn\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    \n    vec2 march = rayMarch(ro, rd);\n    vec3 p = ro+rd*march.x;\n    vec3 light = getLight(p, ro);\n    //Coloring\n    if(march.y < 3.5){ // Box\n    \tcol = vec3(0.4, 0.2, 0.9)*light;   \n    }\n    if(march.y < 2.5){//Ball\n     \tcol = vec3(0.4, 0.9, 0.2)*light;   \n    }\n    if(march.y < 1.5){//Ground\n\t\tcol = vec3(1.)*light;\n    }\n    if(march.y <= -0.5){//Sky\n\t\tcol = vec3(0.4, 0.65, 0.8) - 0.7*rd.y;\n        col = mix(col, vec3(1.), exp(-rd.y*15.));\n        col = vec3(0.0);\n    }\n    \n    col = applyFog(col, march.x);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}