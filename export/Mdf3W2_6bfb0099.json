{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// finds closest point to implicit by checking when the first derivative\n// of the DE goes from negative to positive (a minima) and then\n// does a newton step using the second derivative to find the point\n// where the first derivative is 0.\n\n// this equates to finding minima in the DE: https://www.shadertoy.com/view/ldsGWl\n\n// this is used to find if the implicit surface intersects the cone, and uses this\n// to approximate AA, as in http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf \n\n// the spheres have a simple procedural volume texture that is filtered procedurally\n\n// it doesnt handle intersection between primitives. how to handle this?\n\n// this is useful for approximating DoF (ramp up the cone radius mult below to see this).\n// for small cones (such as per-pixel cones for doing AA) the difference may not be visible.\n#define do_newton_step\n\n// you should be able to get values up to around 6-8 with the newton step without\n// seeing banding/shelling at the silhouette\n// TODO derive real pixel cone radius\n#define cone_radius_mult (.8+max(0.,5.*sin(iTime)))\nfloat cone_r( float z ) { return cone_radius_mult * z / (.375*iResolution.x); }\n\n\nvec4 sph1 = vec4(0.,0.,0.,1.);\nvec4 sph2 = vec4(.1,1.,0.,.5);\nvec4 sph3 = vec4(1.5,1.,0.,.5);\n\nfloat sdSph( vec3 pos, vec4 sph ) { return length( pos - sph.xyz ) - sph.w; }\n\nfloat sceneDist(vec3 pos, float len, out float alpha )\n{\n\t// i really should compute this cone radius analytically. i guess\n\t// it is a cone that is stretched by the aspect ratio\n\tfloat pixel_r = cone_r( len );\n\t\n\tfloat dist = min( min( sdSph(pos,sph1), sdSph(pos,sph2) ), sdSph(pos,sph3) );\n\tdist += pixel_r;\n\t\n\t// approximate overlap of pixel cone with shape as a simple proportion of radius\n\talpha = 1. - clamp( dist / (2. * pixel_r), 0., 1. ) ;\n\t\n\treturn dist;\n}\n\nvec3 volTex( in vec3 pp, float z )\n{\n\tfloat bright;\n\t\n\tfloat grid = 0.05, scale = 0.15;\n\t\n\t// this isnt sufficient - it needs to blur not only on the screen\n\t// space sampling (as current), it also needs to blur on the surface\n\t// angle. could use surface normal.\n\tfloat r = cone_r(z)*grid*2.; //todo unfudge\n\tfloat m;\n\t\n\tm = mod(scale*pp.x,grid*2.);\n\tbright = smoothstep(grid/2.-r,grid/2.+r,m) - smoothstep(grid*3./2.-r,grid*3./2.+r,m);\n\tm = mod(scale*pp.y,grid*2.);\n\tbright += smoothstep(grid/2.-r,grid/2.+r,m) - smoothstep(grid*3./2.-r,grid*3./2.+r,m);\n\tm = mod(scale*pp.z,grid*2.);\n\tbright += smoothstep(grid/2.-r,grid/2.+r,m) - smoothstep(grid*3./2.-r,grid*3./2.+r,m);\n\tbright /= 3.;\n\t\n\tbright = 1.2*smoothstep(-.1,1.,bright);\n\treturn vec3( bright );\n}\n\nvec3 sceneColour( vec3 pos, float z )\n{\n\tfloat d1 = sdSph(pos,sph1), d2 = sdSph(pos,sph2), d3 = sdSph(pos,sph3);\n\t\n\tvec3 tint;\n\tif( d1 < d2 )\n\t{\n\t\tif( d1 < d3 )\n\t\t\ttint = vec3(0.15,0.6,0.2);\n\t\telse\n\t\t\ttint = vec3(.9);\n\t}\n\telse\n\t{\n\t\tif( d2 < d3 )\n\t\t\ttint = vec3(0.,.3,1.);\n\t\telse\n\t\t\ttint = vec3(.9);\n\t}\n\t\n\treturn tint * volTex(pos,z);\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n    pp.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro;\n\tvec3 rd = computePixelRay( pp, ro );\n\tfloat s = 0.0, last_s = 0.;\n\tfloat last_d = 1000., last_dd = 0.; // last dist, last dist derivative\n\t\n\tvec4 col = vec4(0.1);\n\t\n\tfloat hitDist = 0.005;\n\t\n\tfor( int i = 0; i < 40; i++ )\n\t{\n\t\tif( col.w > 0.99 || last_d < hitDist )\n\t\t\tcontinue;\n\t\t\n\t\tvec3 pos = ro + s * rd;\n\t\t\n\t\tfloat alpha;\n\t\tfloat d = sceneDist( pos, s, alpha );\n\t\t\n\t\tfloat dd = (d - last_d)/(s-last_s); // dist deriv\n\t\tif( dd >= 0. && last_dd < 0. ) // did we cross a minima?\n\t\t{\n\t\t\tfloat reals = s; // closest pt ray param\n\t\t\t\n\t\t\t#ifdef do_newton_step\n\t\t\t// do a newton step to find closest pt\n\t\t\tfloat ddd = ( dd - last_dd ) / ( s - last_s ); // second order finite diff\n\t\t\treals = s - dd/ddd; // netwon step\n\t\t\t#endif\n\t\t\t\n\t\t\tvec3 realPos = ro + reals*rd; // closest pt\n\t\t\t\n\t\t\tsceneDist( realPos, reals, alpha ); // get alpha\n\t\t\tvec3 sceneC = sceneColour(realPos,reals); // get colour\n\t\t\t\n\t\t\talpha *= 1. - col.w; // blend\n\t\t\tcol.xyz += alpha * sceneC;\n\t\t\tcol.w += alpha;\n\t\t}\n\t\t\n\t\tlast_dd = dd;\n\t\tlast_d = d;\n\t\tlast_s = s;\n\t\ts += d;\n\t}\n\t\n\tif( last_d < hitDist )\n\t{\n\t\tvec3 last_pos = ro + last_s*rd; // closest pt\n\t\tvec3 sceneC = sceneColour(last_pos,last_s); // get colour\n\t\tfloat alpha = 1. - col.w; // blend\n\t\tcol.xyz += alpha * sceneC;\n\t\tcol.w += alpha;\n\t}\n\tfragColor = col;\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 2.8 + 100.*iMouse.x/iResolution.x;\n\t// use mouse x coord\n\tfloat a = iTime*10.;\n\t//if( iMouse.z > 0. )\n\t//\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,1.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,.4,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdf3W2","date":"1383558105","viewed":578,"name":"Closest point to implicit","username":"huwb","description":"This finds the closest ray point to an implicit by monitoring the derivative of the DE and using 1 newton step to find the minima. Here i use it to blur the edge to approx AA as in http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","aliasing","antialiasing","filtering","conetracing","newton"],"hasliked":0,"parentid":"","parentname":""}}