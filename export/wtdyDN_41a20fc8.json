{"ver":"0.1","info":{"id":"wtdyDN","date":"1609161559","viewed":82,"name":"Test sphere normal","username":"MauroTheGoofy","description":"Test sphere normnal","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spherenormal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define M_PI 3.1415926535897932384626433832795\n#define MAX_STEPS 1000\n#define MAX_DIST 100.0\n#define SURF_DIST .001\n\n\nfloat sdSphere( vec3 p, float r )\n{\n  return length(p)-r;\n}\n\n\n\n// Sdf\n\nfloat scene(vec3 p){\n  vec3 sphere1Pos = vec3(0., 0., 6.);\n  float sphere1Radius = 1.5;\n  float sphere = sdSphere(p - sphere1Pos, sphere1Radius);\n  return sphere;\n}\n\nfloat RayMarching(vec3 ro, vec3 rd){\n  vec3 rayPos = ro;\n  float t = 0.;\n  for(int i=0; i < MAX_STEPS; i++){\n    vec3 pos = ro + t*rd;\n    float h = scene(pos);\n    if(h < 0.0001 || t > MAX_DIST) break;\n    t +=h;\n  }\n  return t;\n}\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(scene(p+h.xyy) - scene(p-h.xyy),\n                           scene(p+h.yxy) - scene(p-h.yxy),\n                           scene(p+h.yyx) - scene(p-h.yyx) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n  uv *= vec2(1.0,1.0);   \n  // Camera pos / ray origin\n  vec3 ro = vec3(0.);\n  // Ray direction\n  vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n  float t = RayMarching(ro, rd);\n  vec3 color = vec3(0.);\n  if(t < MAX_DIST-SURF_DIST){\n    color = vec3(1.);\n    vec3 normal = calcNormal(ro+rd*t);\n   // normal += 1.0;\n//\tnormal /= 2.0;\n    color = normal;\n  }\n\n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}