{"ver":"0.1","info":{"id":"3dVGRz","date":"1569645286","viewed":74,"name":"itsukushijima","username":"zaki","description":"torii","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["torii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MIN_DIST=0.001;\nfloat MAX_DIST=100.0;\nint MAX_STEP=100;\nfloat PI=3.141592;\n\nfloat mat = 0.0;\nfloat g = 0.0;\n\nfloat box(vec3 pos, vec3 dim)\n{\n    vec3 d = abs(pos) - dim;\n  \treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat rnd(float t) { return fract(sin(t * 2838.237) * 237.1236); }\n\nfloat dot2(vec2 v) { return dot(v, v); }\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat pillar(in vec3 pos, in float h, in float r1, in float r2)\n{\n    vec2 q = vec2(length(pos.xz), pos.y);\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n\nfloat beam(vec3 pos, vec3 off, vec3 size, float bend)\n{\n\tvec3 p = pos - off;\n    p.y += cos(abs(pos.x / bend));\n    return box(p, size);\n}\n\nvec2 matmin(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 base(vec3 pos)\n{\n    vec3 p = pos;\n    vec2 prim = vec2(pillar(p + vec3(0.0, 1.0, 0.0), 0.5, 100.0, 100.0), 2.0);\n    prim.x += cos(pos.x * 0.5 + iTime * 0.54) * 0.12;\n    prim.x += cos(pos.z * 0.5 + iTime * 0.43) * 0.11;\n    \n    return prim;\n}\n\n\nvec3 light()\n{\n    vec3 light = normalize(vec3(3.0, -1.0, 2.0));\n    light.xz *= rot(iTime * 0.1);\n    light.xy *= rot(iTime * 0.3);\n    light = normalize(light);\n\n    return light;\n}\n\nvec2 lll(vec3 pos)\n{\n    vec3 lp1 = vec3(6.0 + sin(iTime * 0.9) * 5.0, 4.0 + sin(iTime * 0.8), cos(iTime * 0.9) * 5.0);\n    float d1 = length(pos - lp1) - 0.1;\n    \n    g += 0.2 * (0.1 / (max(0.0, pow(d1, 2.0))));\n\n    vec3 lp2 = vec3(-6.0 - sin(iTime * 0.7) * 5.0, 4.0 - 2.0*sin(iTime * 0.5), cos(iTime * -0.9) * 5.0);\n    float d2 = length(pos - lp2) - 0.1;\n    \n    g += 0.2 * (0.1 / (max(0.0, pow(d2, 2.0))));\n\n    \n    return vec2(min(d1, d2), 0.0);\n}\n\nvec2 torii(vec3 pos)\n{\n    vec2 r = vec2(0);\n    \n    float tr1 = beam(pos, vec3(0.0, 10.0, 0.0), vec3(5.0, 0.2, 0.5),  6.0);\n    float tr2 = beam(pos, vec3(0.0, 10.1, 0.0), vec3(5.2, 0.1, 0.6),  6.0);\n    float tr3 = beam(pos, vec3(0.0,  9.5, 0.0), vec3(4.7, 0.4, 0.5),  6.0);\n    float tr4 = beam(pos, vec3(0.0,  7.5, 0.0), vec3(4.7, 0.4, 0.5), 10.0);\n\n    vec3 p1 = pos;\n    p1.x = abs(p1.x);\n    p1 -= vec3(3.5, 4.2, 0.0);\n    float c1 = pillar(p1, 5.0, 0.5, 0.3);\n    \n    vec3 p2 = pos;\n    p2.x = abs(p2.x);\n    p2.z = abs(p2.z);\n    p2 -= vec3(3.5, 1.8, 3.0);\n    float c2 = pillar(p2, 2.5, 0.4, 0.3);\n    \n    p2.y -= 2.7;\n    float cb = box(p2, vec3(0.6, 0.2, 0.6));\n    \n    vec3 cp1 = pos;\n    cp1.x = abs(cp1.x);\n    float cb1 = beam(cp1, vec3(3.5, 4.0, 0.0), vec3(0.2, 0.3, 4.0), 8.0);\n    float cb2 = beam(cp1, vec3(3.5, 2.0, 0.0), vec3(0.2, 0.3, 4.0), 8.0);\n    \n\tr = matmin(\n        \tvec2(min(min(min(tr1, tr2), tr3), tr4), 0.0),\n        \tmatmin(\n            \tmatmin(vec2(min(c1, c2), 0.0), vec2(cb, 0.0)),\n        \t\tvec2(min(cb1, cb2), 0.0)\n        \t)\n        );\n    r = matmin(r, base(pos));\n    r = matmin(r, lll(pos));\n    return r;\n}\n\nvec2 sdf(vec3 pos)\n{\n\tvec2 tr = torii(pos);\n    return tr;\n}\n\nvec3 norm(vec3 pos)\n{\n\tvec2 e = vec2(0.01, 0.0);\n    \n    return normalize(sdf(pos).x - vec3(\n    \tsdf(pos + e.xyy).x,\n        sdf(pos + e.yxy).x,\n        sdf(pos + e.yyx).x\n    ));\n}\n\nfloat march(vec3 pos, vec3 ray)\n{\n\tfloat t = 0.0;\n    int m = 0;\n    vec3 p = pos;\n    \n    for (; m < MAX_STEP; ++m)\n    {\n    \tvec2 d = sdf(p);\n        t+=d.x;\n        mat=d.y;\n        \n        if (t > MAX_DIST) {mat=1.0;t=MAX_DIST-MIN_DIST;break;}\n        if (t < MIN_DIST) break;\n        \n        p = p + d.x * ray;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float asp = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.y *= asp;\n\n    vec3 org = vec3(0.0, 5.0, -40.0);\n    vec3 ray = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    org.z += sin(iTime * 0.0576) * 10.0;\n    \n    org.xz *= rot(iTime * -0.01 + PI/4.0);\n    ray.xz *= rot(iTime * -0.01 + PI/4.0);\n    \n    float d = march(org, ray);\n    vec3 pp = org + d * ray;\n    vec3 n = norm(pp);\n\tvec3 light = light();\n    \n    vec3 col = vec3(0.5, 0.6, 0.9) * pow(d / MAX_DIST, 2.0);\n    col = vec3(0.9, 0.4, 0.3) * pow(abs(dot(n, light)), 2.0);\n\n    float dd = dot(light, vec3(0.0, 1.0, 0.0)) * 0.3 + 0.7;\n    float rf = 0.1;\n    if (mat == 1.0)\n    {\n        col = mix(vec3(0.02, 0.0, 0.01), vec3(0.7, 0.7, 0.9), smoothstep(0.1, 1.0, dd));\n        if (dd < 0.5) col.r += sin(0.5 - dd) * 0.2;\n        \n        col *= (1.2 - uv.y);\n        rf = 0.0;\n    }\n    if (mat == 2.0)\n    {\n        float l = 1.0 - pow(abs(dot(n, light)), 2.0);\n    \tcol = mix(vec3(0.01, 0.2, 0.2) * l, vec3(0.1, 0.3, 0.8) * l, dd);\n        rf = 0.5;\n    }\n    col += vec3(rf)*smoothstep(0.8, 1.0, dot(n,-light));\n\n    col *= clamp(1.3 - length(uv), 0.0, 1.0);\n    \n    col += vec3(0.4) * g;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}