{"ver":"0.1","info":{"id":"3dyGW3","date":"1571032095","viewed":162,"name":"LinesZ8Q","username":"foran","description":"LinesZ8Q","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["linesz8q"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 50\n#define HITTHRESHOLD .009\n#define FAR 25.\n#define AA 1\n#define NIFS 2\n#define SCALE 2.3\n#define TRANSLATE 3.5\n\nmat2x2 rot(float angle)\n{\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat2x2(c,-s,\n    s,c);\n}\n\nvec4 sd2d(vec2 p,float o)\n{\n    float time=.25*o+.6*iTime;\n    float s=.5;\n    p*=s;\n    float RADIUS=(1.5+sin(iTime));\n    int i;\n    vec3 col;\n    p=p*rot(-.4*time);// twist\n    \n    for(i=0;i<NIFS;i++)\n    {\n        if(p.x<0.){p.x=-p.x;col.g++;}\n        p=p*rot(.9*sin(time));\n        if(p.y<0.){p.y=-p.y;col.b++;}\n        if(p.x-p.y<0.){p.xy=p.yx;col.r++;}\n        p=p*SCALE-TRANSLATE;\n        p=p*rot(.3*(iTime));\n    }\n    \n    float d=.425*(length(p)-RADIUS)*pow(SCALE,float(-i))/s;\n    col/=float(NIFS);\n    vec3 oc=mix(vec3(.7,col.g,.2),vec3(.2,col.r,.7),col.b);\n    \n    return vec4(oc,d);\n}\n\nvec4 map(vec3 p)\n{\n    return sd2d(p.xz,p.y);\n}\n\nfloat shadow(vec3 ro,vec3 rd)\n{\n    float h=0.;\n    float k=3.;//shadowSmooth\n    float res=1.;\n    float t=.2;//bias\n    for(int i=0;t<15.;i++)// t < shadowMaxDist\n    {\n        h=map(ro+rd*t).w;\n        res=min(res,k*h/t);\n        if(h<HITTHRESHOLD)\n        {\n            break;\n        }\n        t=t+h;\n    }\n    return clamp(res+.05,0.,1.);\n}\n//---------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//-----------------\n//camera\nfloat height=-.4;\nfloat rot=iTime*.1;\nfloat dist=9.+1.*sin(.5*iTime);\nvec3 ro=dist*vec3(cos(rot),height,sin(rot));\nvec3 lookAt=vec3(0.,0.,0.);\nvec3 fw=normalize(lookAt-ro);\n\nvec3 right=normalize(cross(vec3(0.,1.,1.),fw));\nvec3 up=normalize(cross(fw,right));\nright=normalize(cross(up,fw));\n\n//light\nrot+=sin(iTime)*.2;\nvec3 lightPos=dist*vec3(cos(rot),height,sin(rot));\n\n//raymarch\nvec3 pos,closest;\nfloat t;\nfloat smallest;\nint i,iAtClosest;\nvec3 sdfCol;\nvec3 col;\n\nfor(int x=0;x<AA;x++)\nfor(int y=0;y<AA;y++)\n{\n    t=0.;smallest=500.;\n    vec2 o=vec2(float(x),float(y))/float(AA)-.5;\n    vec2 uv=(fragCoord+o)/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 rd=normalize(fw*.5+right*uv.x+up*uv.y);\n    \n    for(i=0;i<MAXSTEPS;i++)\n    {\n        pos=ro+rd*t;\n        vec4 mr=map(pos);\n        float d=mr.w;\n        if(d<smallest)smallest=d;closest=pos;iAtClosest=i;sdfCol=mr.rgb;\n        if(abs(d)<HITTHRESHOLD||t>FAR){break;}\n        t+=d;\n    }\n    pos=closest;\n    i=iAtClosest;\n    vec3 c;\n    if(t<FAR)\n    {\n        c=sdfCol;\n        vec3 toLight=normalize(lightPos-pos);\n        float s=shadow(pos,toLight);\n        c*=s;\n        c=mix(c,1.5*c,1.-s);\n    }\n    else\n    {\n        c=vec3(0.);\n    }\n    col+=c;\n}\ncol/=float(AA*AA);\n\n\n    fragColor = vec4 (col,t);\n}","name":"Image","description":"","type":"image"}]}