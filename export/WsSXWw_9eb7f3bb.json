{"ver":"0.1","info":{"id":"WsSXWw","date":"1553921057","viewed":230,"name":"Web Cam Sphere","username":"kindpotato","description":"I try and render a sphere based only on what I know. Point your camera at a mercator projection of the world map for a spinning GLOBE.","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["imtryingtomakeasphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float quadraticRoots(float a, float b, float c){\n    if ((b*b) - (4.*a*c) > 0.)\n\t\treturn (-b-sqrt((b*b) - (4.*a*c)))/(2.*a);\n   \treturn 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    //Based on uv\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),-1));\n    \n    const vec3 ballPos = vec3(0,0,-100.);\n    const float ballRadius =  20.;\n    float bailOut = length(ballPos)+ballRadius;\n    //Start marching out close to the ball\n    vec3 marching = viewingNormal*(length(ballPos)-ballRadius-0.5);\n    vec3 quadEquation = vec3(1.,\n                             -2.*dot(viewingNormal,ballPos),\n                             ballPos.x*ballPos.x + ballPos.y*ballPos.y + ballPos.z*ballPos.z\n                        \t-ballRadius*ballRadius);\n    //t is how long the viewingVector goes before meeting the circle\n    float t = quadraticRoots(quadEquation.x,quadEquation.y,quadEquation.z);\n   \n    vec3 normal = vec3(0);\n    vec3 position = vec3(0);\n    if (t != 0.){\n    \tposition = viewingNormal*t;\n        normal = normalize(viewingNormal*t-ballPos);\n    }\n    /*while (length(marching) < bailOut) {\n    \tif (distance(marching,ballPos) < ballRadius){\n            vec3 a = marching-10.*viewingNormal;\n            for (int i = 0; i < 6; ++i){\n                if (length((a+marching)/2. - ballPos) < ballRadius)\n                \tmarching = (a+marching)/2.;\n                else\n                    a = (a+marching)/2.;\n                \n\t\t\t\t\n            }\n            //After this point marching will be sufficiently close the\n            //surface of the ball\n            normal = normalize(marching - ballPos);\n            \n            break;\n        }\n        marching += 10.*viewingNormal;\n        \n\t}*/\n    if (normal != vec3(0)){\n        vec3 color = vec3(0);\n    \tvec3 lightPos = vec3(400.*cos(iTime),400.*sin(iTime),200.+30.*cos(5.*iTime));\n        vec3 reflected = reflect(viewingNormal,normal);\n        vec3 surfaceToLight = lightPos-marching;\n        float lightLen = length(surfaceToLight);\n        \n        /*float intoLight = max(0.,dot (reflected,normalize(surfaceToLight)));\n        float awayFromLight = sqrt(1.-intoLight*intoLight);\n        float lightDist = awayFromLight*lightLen/intoLight;\n        \n        if (lightDist < 40.){\n            color += vec3(1);\n        }*/\n        float latitude = 0.5+asin(dot(vec3(0,1,0),normal))/3.14159;\n        vec2 orientation = vec2(sin(iTime),cos(iTime));\n        vec2 nOrientation = normalize(vec2(normal.x,normal.z));\n        \n        float longitude = 0.5 * (0.5+asin(dot(orientation,nOrientation))/3.14159);\n        if (dot(vec2(orientation.y,-orientation.x),nOrientation) < 0.){\n            longitude = 1.-longitude;\n        }\n        longitude = 1. - longitude;\n        \n        vec3 textureColor = texture(iChannel0,vec2(longitude,latitude)).rgb;\n        \n        \n        //Diffuse\n        color += max(0.,0.8*dot(normal,surfaceToLight/lightLen));\n        color *= vec3(0.8,1,1);\n        //Sky Diffuse\n        color += 0.9*vec3(0.8,0.8,1)*(0.5+asin(dot(vec3(0,1,0),normal))/3.14159);\n        color *= textureColor;\n        //Shine\n        color += 0.75*pow(max(0.,dot (reflected,normalize(surfaceToLight))),10.);\n        fragColor = vec4(color,1);\n        \n        \n        return;\n    \t\n    }\n    fragColor = vec4(0.8,0.8,1,1);\n    if (viewingNormal.y < 0.)\n        fragColor = vec4(0,0,0,1);\n}","name":"Image","description":"","type":"image"}]}