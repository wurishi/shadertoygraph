{"ver":"0.1","info":{"id":"XdScRy","date":"1492684056","viewed":128,"name":"3Object Reflection.","username":"sw","description":"camera( https://www.shadertoy.com/view/4lVXRm)\ncamera\nWASD+Mouse","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["reflection","easy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define load(P) texture(iChannel1, (P + 0.5) / iChannelResolution[1].xy, -100.0)\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    ro = load(vec2(1.0, 0.0)).xyz;\n    vec2 m = load(vec2(1.0, 1.0)).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n    \n    rd = normalize(rd);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdFloor(vec3 p){\n    return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat getMinDist(float d1,float d2,out int ColorNumber,int NewColorNumber)\n{\n\tif( d1<d2 )\n\t{\n\t\tColorNumber=NewColorNumber;\n\t\treturn d1;\n\t}\n\treturn d2;\n}\nfloat sdAll(vec3 p,out int ColorNumber)\n{\n    vec3 boxPos=vec3(sin(iTime*0.8)*3.0,0,-8);\n    vec3 spherePos=vec3(-2,-2,-9);\n    vec3 spherePos2=vec3(sin(iTime*0.5)*5.0,-4,-15);\n    vec3 spherePos3=vec3(2,1,-6.0);\n\n\n\tColorNumber=0;\n\tfloat mindist=999999.0;\n\n    float d1 = sdBox(p+boxPos,vec3(1,1,1));\n    mindist = getMinDist(d1,mindist,ColorNumber,0);\n    float d2 = sdFloor(p);\n    mindist = getMinDist(d2,mindist,ColorNumber,1);\n    float d3 = sdSphere(p+spherePos,1.0);\n    mindist = getMinDist(d3,mindist,ColorNumber,2);\n    float d4 = sdSphere(p+spherePos2,4.0);\n    mindist = getMinDist(d4,mindist,ColorNumber,3);\n\tfloat d5 = sdSphere(p+spherePos3,0.5);\n    mindist = getMinDist(d5,mindist,ColorNumber,4);\n\n    \n    //ColorNumber = d1<d2 ? 0 : d2<d3 ? 1 : 2;\n   //return min(min(d1,d2),d3);\n   return mindist;\n}\n\nfloat sdAll(vec3 p)\n{\n\tint ColorNumber;\n\treturn sdAll(p,ColorNumber);\n}\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        sdAll(p + vec3(  d, 0.0, 0.0)) - sdAll(p + vec3( -d, 0.0, 0.0)),\n        sdAll(p + vec3(0.0,   d, 0.0)) - sdAll(p + vec3(0.0,  -d, 0.0)),\n        sdAll(p + vec3(0.0, 0.0,   d)) - sdAll(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nfloat getShadow(vec3 RayPos, vec3 RayDir){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t = 0.0; t < 50.0; t++){\n        h = sdAll(RayPos + RayDir * c);\n        if(h < 0.001){\n            return shadowCoef;\n        }\n        r = min(r, h * 20.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nfloat getAO(vec3 p,vec3 normal)\n{\n\tfloat ao=0.0;\n\tconst float len=0.2;\n\tao += sdAll(p+vec3(-len,len,-len)*normal);\n\tao += sdAll(p+vec3(-len,len,+len)*normal);\n\tao += sdAll(p+vec3(+len,len,-len)*normal);\n\tao += sdAll(p+vec3(+len,len,+len)*normal);\n    ao = 0.5+(ao/4.0);\n\treturn clamp(ao,0.5,1.0);\n}\n\nvec3 getColor(vec3 RayPos, int ColorNumber)\n{\n\tif( ColorNumber==0 )\n\t{\n\t\treturn vec3(0.3,0.3,0.9);\n\t}else if(ColorNumber==1)\n\t{\n\t\tvec2 dxz=RayPos.xz/5.0; // tile size\n\t\tdxz=mod(dxz,2.0);\n\t\tfloat x = dxz.x <1.0 ? 0.0 : 1.0;\n\t\tfloat z = dxz.y <1.0 ? 0.0 : 1.0;\n\t\tfloat d = x+z;\n\t\td = d==1.0 ? 1.0 : 0.8;\n\t\treturn vec3(d,d,d);\n\t}else if(ColorNumber==2)\n\t{\n\t\treturn vec3(0.9,0.3,0.3);\n\t}else if(ColorNumber==3)\n\t{\n\t\treturn vec3(0.2,0.9,0.9);\n\t}else if(ColorNumber==4)\n\t{\n\t\treturn vec3(0.9,0.9,0.2);\n\t}\n\treturn vec3(0,0,0);\n}\n\nvec4 getReflectColor(vec3 RayPos,vec3 RayDir)\n{\n\tint ColorNumber;\n\tfloat dist=0.0;\n    float rLen=0.0;\n    vec4 result;\n    vec3 RayStart=RayPos+RayDir*0.001;\n    for(int i = 0; i < 64; i++){\n        dist = sdAll(RayPos,ColorNumber);\n        rLen += dist;\n        RayPos = RayStart + RayDir * rLen;\n    }\n    \n    vec4 SurfaceColor=vec4(0.0);\n    if( dist<0.001 )\n    {\n        SurfaceColor.xyz=getColor(RayPos,ColorNumber);\n    \tSurfaceColor.w=0.4;\n    }else\n    {\n        SurfaceColor.xyz = texture(iChannel0,RayDir).xyz;\n    \tSurfaceColor.w=0.4;\n    }\n    return SurfaceColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    vec3 cPos = vec3(0.0, 0.0,  0.0);\n    vec3 ray;\n\n    Camera(fragCoord,cPos,ray);\n    \n    // marching loop\n    float dist = 0.0;\n    float rLen = 0.0;     \n    vec3  rPos = cPos; \n    \n    int ColorNumber=0;\n        \n    for(int i = 0; i < 256; i++){\n        dist = sdAll(rPos,ColorNumber);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n    \n    // hit check\n    if(abs(dist) < 0.001){\n        // Light Direction\n        float offsetX=sin(iTime);\n\t\tvec3 lightDir = vec3( -0.5, 0.57, -0.57);\n        lightDir=normalize(lightDir);\n\n        // color\n        vec3 SurfaceColor=getColor(rPos,ColorNumber);\n\n        vec3 normal=getNormal(rPos);\n\t\tvec4 ReflectColor = getReflectColor(rPos,reflect(ray,normal));\n\n        float shadow=getShadow(rPos+normal*0.001,lightDir);\n\t\tfloat ao=getAO(rPos+normal*0.001,normal);\n        float lighing=dot( lightDir,normal );\n        // no lighting\n        if( ColorNumber==1)\n        {\n            lighing = 1.0;\n            ao = 1.0;\n        }\n        // surface + reflect\n        vec3 CalcColor;\n        CalcColor = mix(SurfaceColor,ReflectColor.xyz,ReflectColor.w);\n\n        fragColor.xyz = CalcColor * lighing*shadow*ao;\n    }else\n    {\n        fragColor.xyz = texture(iChannel0,ray).xyz;\n    }\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(fragCoord, P + 0.5))) fragColor = V\n#define load(P) texture(iChannel1, (P + 0.5) / iChannelResolution[1].xy, -100.0)\n#define key(K)  step(0.5, texture( iChannel0, vec2(K, 1.0/6.0) ).x)\n\nconst vec2 MEMORY_BOUNDARY = vec2(4.0, 3.0);\n\nconst vec2 POSITION = vec2(1.0, 0.0);\n\nconst vec2 VMOUSE = vec2(1.0, 1.0);\nconst vec2 PMOUSE = vec2(2.0, 1.0);\n\nconst vec2 TARGET = vec2(0.0, 2.0);\n\nconst vec2 RESOLUTION = vec2(3.0, 1.0);\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const float KEY_BIND_FORWARD = FORWARD; const float KEY_BIND_BACKWARD = BACKWARD; const float KEY_BIND_RIGHT = RIGHT; const float KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\treturn vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(fragCoord, MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord - 0.5);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    store(TARGET, vec4(target, 0.0));\n    \n    position += (target - position) * iTimeDelta * 5.0; \n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4( pm + (iMouse.zw - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buf A","description":"","type":"buffer"}]}