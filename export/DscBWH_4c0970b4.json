{"ver":"0.1","info":{"id":"DscBWH","date":"1697083274","viewed":64,"name":"Smooth corner","username":"biasia","description":"mask video","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","squircle"],"hasliked":0,"parentid":"wt3fW8","parentname":"Fast 16x MSAA Squircle"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 _normalize(vec2 p, vec2 pos, vec2 size, float r) {\n    float x, y;\n\n    if (p.x < pos.x + r)\n        x = p.x - (pos.x + r);\n    else if (p.x < pos.x + size.x - r)\n        x = 0.0;\n    else\n        x = p.x - (pos.x + size.x - r);\n\n    if (p.y < pos.y + r)\n        y = p.y - (pos.y + r);\n    else if (p.y < pos.y + size.y - r)\n        y = 0.0;\n    else\n        y = p.y - (pos.y + size.y - r);\n\n  return vec2(x, y);\n}\n\nfloat dist(vec2 p, float radius) {\n    return p.x * p.x * p.x * p.x + p.y * p.y * p.y * p.y;\n    return p.x * p.x * p.x * p.x * 0.125 + p.y * p.y * radius * radius;\n    // return p.x * p.x * radius * radius + p.y * p.y * p.y * p.y;\n}\n\nfloat squircle_cov(vec2 p, float radius) {\n    float r = radius * radius * radius * radius;\n    float delta = 10.0 * radius * radius * radius;\n    float inner = r - delta;\n    float outer = r + delta;\n\n    float d = dist(p, radius);\n    \n    float cov;\n    if (d < inner) {\n        cov = 1.0;\n    } else if (d > outer) {\n        cov = 0.0;\n    } else {    \n        cov = 0.0;\n        int i,j;\n        float step = 0.125;\n        for (i = 0; i < 8; i++) {\n            for (j = 0; j < 8; j++) {\n                vec2 sp = p - vec2(float(i) - 1.5, float(j) - 1.5) * step;\n                if (dist(sp, radius) < r)\n                    //cov += 1.0 / 64.0;\n                    cov += smoothstep(0., 0.001,r-dist(sp, radius))/64.0;\n            }\n        }\n    }\n    \n    return cov;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 img = texture(iChannel0, (fragCoord.xy / iResolution.xy)).rgb;\n    float radius = 230.;\n    vec2 size = vec2(2400., 2200.);\n    \n    \n\tvec2 pos = floor(iResolution.xy / 2.0) - vec2(361., 280.);\n    vec2 uv1 = _normalize(fragCoord.xy, pos + vec2(0.02, iResolution.y / 6.0), size, radius);\n \n\n    vec3 fg1 = vec3(1., 1., 1.);\n    vec3 bg =  vec3(0.,0.,0.);\n\n    vec3 color;\n    float cov1 = squircle_cov(uv1, radius);\n    color = mix(bg, img, cov1);\n    \n    fragColor = vec4(color, 1.0); \n}\n","name":"Image","description":"","type":"image"}]}