{"ver":"0.1","info":{"id":"wsd3WS","date":"1733551051","viewed":85,"name":"Wave vision simulation","username":"Txoka","description":"Wave simulation of light bouncing off of objects and (somewhat) resolving an image inside an \"eye\".","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    o = texelFetch(iChannel0,ivec2(u),0);  \n    \n    if(walls(AC(u))>0.)o.r+=walls(AC(u));\n    if(refraction(AC(u))!=1.)o.g+=0.1;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float dx=1.;\nconst float s2=dx/sqrt(2.);\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 uv = AC(u);\n    float dt=refraction(uv);\n    //light source\n    vec2 lpos = vec2(-1.1,-.85);\n    if (iMouse.w > 0.) lpos = AC(iMouse.xy);\n    float ls = length(uv-lpos);\n    if ((iFrame==0 || iMouse.w > 0.) && ls <= LIGHT_RADIUS) {\n        o = vec4(ls/LIGHT_RADIUS*LIGHT_INTENSITY,0,0,0);\n        return;\n    } else if (iMouse.w > 0.) {\n        o = vec4(0);\n        return;\n    }\n    \n    //wave propagation\n    ivec2 iu = ivec2(u);\n\t#define ts(x,y) texture(iChannel0,(u+vec2(x,y))/R.xy)\n    vec4 s = ts(0,0),d = (\n        ts(dx,0)+\n        ts(-dx,0)+\n        ts(0,dx)+\n        ts(0,-dx)+\n        ts(s2,s2)+\n        ts(-s2,-s2)+\n        ts(s2,-s2)+\n        ts(-s2,s2)\n    )/8.-s;\n    d/=dx;\n   \t\n    //s.xy = dt*d.x*vec2(1,1) + s.xy*mat2(1,1,0,1);\n    s.xy = dt*d.x*vec2(1,0) + s.xy*mat2(1,1,-1,0);\n\n    \n    //walls light blocking, i think this should actually be done by changing the laplacian neighbour samples?\n    s*=1.-walls(uv);\n    o = s;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Buf B - Sample light wave values over time from Buf A and draw walls.\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    vec2 uv=AC(u);\n    ivec2 iu = ivec2(u);\n    vec4 l = abs(texelFetch(iChannel0,iu,0).xyxy);\n    //l*=l;\n    if (iMouse.w < 1.) l += texelFetch(iChannel1,iu,0);\n    \n    o = l;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define AC(p) ((p*2.-R.xy)/R.y)\n\n#define LIGHT_RADIUS .01\n#define LIGHT_INTENSITY .1\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n//distance function for walls\nfloat walls(vec2 p) {\n    vec2 r=(hash(p.xyyx).xy-.5);\n\t\n   \t//if(abs(p.x)<0.01)if(abs(p.y)>0.11)return 1.;\n   \t//if(distance(-abs(p)+r*.2,vec2(-.6,0))>0.95)return 0.1;\n   \t//float v=smoothstep(.01,0.,distance(p,vec2(-0.8,.4))-.2);\n   \t//v=max(v,smoothstep(.01,0.,distance(p,vec2(-0.8,-.4))-.03));\n   \t//v=max(v,smoothstep(.01,0.,distance(p,vec2(-0.9,0))-.1));\n    //return 0.;\n   \t//if(p.y*p.y*10.>p.x+1.75)return 1.;\n    float n=smoothstep(.05,0.,distance(p,vec2(-1.75,0))-1.);\n    n=abs(p.y)>0.2?n:0.;\n    //float b=smoothstep(.05,0.,distance(p,vec2(-.62,0))-.2);\n    //b=(abs(p.y)>0.1&&p.x>-.75)?b:0.;\n    if(abs(p.x)+r.x*.1>1.7)return 0.05;\n    if(abs(p.y)+r.x*.1>0.93)return 0.05;\n    //n=max(n,b);\n    n=n*(1.-n)*4.;\n    n=max(n,smoothstep(.005,0.,distance(p,vec2(.5,-.5))-.05));\n    return max(n,smoothstep(.005,0.,distance(p,vec2(.5,.5))-.05));\n    //float f=distance(p,vec2(.5,0))+distance(p,vec2(-.5,0));\n   \t//return smoothstep(2.,2.05,f);\n}\nfloat refraction(vec2 p){\n    //p*=2.;\n    p.x-=0.1;\n    float w=smoothstep(.01,0.,distance(p,vec2(-.85,0))-.2);\n    float k=smoothstep(.01,0.,distance(p,vec2(-1.05,0))-.3);\n    return 1.-max(0.,w-k)*0.5;\n    //if(distance(p,vec2(-.3,0))<0.1)return 1.5;\n    //return smoothstep(0.,.01,length(p)-.1)*0.5+0.5;\n\t//if(distance(u,vec2(.2,0))<.4&&distance(u,vec2(-.2,0))<.4)return 0.5;\n    return 1.;\n}","name":"Common","description":"","type":"common"}]}