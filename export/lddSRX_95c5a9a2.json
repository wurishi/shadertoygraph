{"ver":"0.1","info":{"id":"lddSRX","date":"1460741387","viewed":458,"name":"Participating Media  Experiment","username":"tomkel","description":"experiments with participating media. Lots wrong! ","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 cLight \t\t= vec3( 1100.0,1100.0,1000.0 );\nconst vec4 cLightColour = vec4(1.0,1.0,1.0,1.0 ) ;\nconst float cScatter \t= 0.002;\t// scatter prob\nconst float cAbsorb \t= 0.001;\t// absorb prob\nconst float cG \t\t\t= -0.2;\t\t// Heney-Greenstein \"thick fog\" phase fn param. sign forard/backward, mag particle size\nconst float cIntensity \t= 120.0;\n\nconst float cA \t\t\t= 0.0;\nconst float cB \t\t\t= 1.0;\nconst float cC \t\t\t= 0.0;\n\nfloat sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    return distance( spherepos, raypos ) - r;\n}\n\nfloat atten( float d, float A, float B, float C, float intensity )\n{\n    return intensity / ( A*d*d + B*d + C );\n}\n\n\nvec4 getlight( vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    vec3  tolight = lightpos - position;\n    vec3 n = normalize( tolight );\n    return max( dot( normal, n ), 0.0 ) * cLightColour  * atten( length( tolight ), cA, cB, cC, cIntensity ); //cIntensity /  length( tolight) ;//, tolight );\n}\n\n\nfloat sdf( vec3 raypos )\n{ \n    vec3 rayposmod = mod( raypos,  vec3( 50.0,50.0,50.0 ));\n    return max( sphere( vec3( 25.0,25.0, 25.0), 10.0, rayposmod ), sphere( vec3( 1000.0,1000.0,1000.0 ), 100.0, raypos )  );\n}\n\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ) - sdf( raypos - vec3( delta,0,0 ) );\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ) - sdf( raypos - vec3( 0,delta,0 ) );\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ) - sdf( raypos - vec3( 0,0,delta ) );\n    return vec3( -dx,-dy,-dz );\n}\n\nfloat hg( float costheta )\n{\n    const float g = cG; \n    float num =  1.0 - g*g ;\n    float denom = 2.0 * pow( 1.0 + g*g - 2.0 * g * costheta, 3.0/2.0 );\n    return cScatter * num / denom ;\n}\n\nfloat outsc( float d )\n{\n    const float ab = cAbsorb;\n    const float sc = cScatter;\n    const float ex = sc + ab;\n    \n    return exp(-ex*d );\n}\n\nvec4 inscray( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    vec4 lighting = cLightColour  * atten( distance( origin, cLight  ), cA, cB, cC, cIntensity );\n    for ( int i = 0; i < 100; i++ )\n    {\n        float dist =  distance( p , cLight ) ; \n        float step = sdf(p); \n   \n        if ( step > dist )\n        {\n            return lighting;\n        } \n        else if ( step  <  ep )\n        {\n           return vec4(0,0,0,0);\n                 \n        } \n        \n        p += ray * step;\n    } \n    \n     return lighting;\n}\n\n\nvec4 march( vec3 ray, vec3 origin, float ep, vec3 axis  )\n{\n    vec3 p = origin;\n    const float stepsize = 4.0;\n    vec4 inscattered =vec4( 0,0,0,0 );\n    for ( int i = 0; i < 256; i++ )\n    {\n        float d = length( p -origin );\n        float step = min( sdf(p), stepsize );\n        if ( step  <  ep || d > 1000.0 )\n        {\n            vec3 normal = normalize( grad( p, 0.1 ) );\n            vec4 s = getlight( -normal, p,  cLight, vec4(1.0,1.0,1.0,1.0 )); \n            \n            return s * vec4( 0.7,0.7,1.0,1.0) * outsc(d) + inscattered;\n                 \n        }\n       \n        vec3 isray = normalize ( cLight-p   );\n        \n       inscattered +=  inscray( isray, p, 1.0 ) * outsc(d) * hg( dot( -isray, normalize(ray) ) ) * step;\n       \n        \n        p += ray * step;\n    }\n    \n    return inscattered;\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec3 origin = vec3( 0.0, 0.0,  -250.0  );\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    float angle =  (iMouse.x / iResolution.x - 0.5 ) * 3.142 * 2.0;\n    origin = rotatevecY( origin, iTime );\n    ray = rotatevecY( ray, iTime );\n\t\n   vec3  axis = rotatevecY( vec3(0,0,1),  angle );\n    \n\tfragColor = march( ray, origin + vec3( 1000.0, 1000.0, 1000.0 ), 0.01, axis );\n}","name":"Image","description":"","type":"image"}]}