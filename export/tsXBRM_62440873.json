{"ver":"0.1","info":{"id":"tsXBRM","date":"1587912448","viewed":177,"name":"RBF Face Transform","username":"lzjseed","description":"Try to move the mouse.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","cute","game","cartoon","colorful","cat","funny","face","pikachu","pokemon","rabbit","rbf","conjugategradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float drawTriangle(vec2 p,vec2 p1,vec2 p2,vec2 p3)\n{\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 vv = p  - p1;\n    \n    float d = 1.0 / (v1.x * v2.y - v2.x * v1.y);\n    float u = (vv.x * v2.y - v2.x * vv.y) * d;\n    float v = (v1.x * vv.y - vv.x * v1.y) * d;\n    \n    return (u < 0.0 || v < 0.0 || u + v > 1.0) ? 1.0 : 0.0;\n}\n\nfloat drawRect(vec2 p,vec2 r)\n{\n    vec2 ap = abs(p);\n       \n    return (ap.x > r.x || ap.y > r.y) ? 1.0 : 0.0;\n}\n\nfloat drawCircle(vec2 p,vec2 a,float r)\n{\n    return smoothstep(0.0,0.01,length(p-a) - r);\n}\n\nfloat drawEllipse(vec2 p,vec2 r)\n{\n    vec2 b = p / r;\n    \n    return smoothstep(0.96,1.0,length(b));\n}\n\nvoid drawEllipseX(inout vec3 col,vec2 p,float[N] params)\n{\n    float a = params[2];\n    vec2 scale = vec2(params[3],params[4]);\n    vec3 c = vec3(params[5],params[6],params[7]);\n \t\n    p -= vec2(params[0],params[1]);\n    \n    mat2 rot = mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    vec2 pos = rot * p;\n    \n    float t = drawEllipse(pos,scale);\n    \n    col = mix(c,col,t);\n}\n\nvoid drawTriangleX(inout vec3 col,vec2 p,vec2 p1,vec2 p2,vec2 p3,float[N] params)\n{\n    float a = params[2];\n    vec2 scale = vec2(params[3],params[4]);\n    vec3 c = vec3(params[5],params[6],params[7]);\n \t\n    p -= vec2(params[0],params[1]);\n    \n    mat2 rot = mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    vec2 pos = rot * p;\n    \n    float t = drawTriangle(pos,scale*p1,scale*p2,scale*p3);\n    \n    col = mix(c,col,t);\n}\n\n\nvoid renderPart(inout vec3 col,vec2 pos,vec2 offset,Vec v,int part)\n{\n    vec2 p = pos - offset;\n    vec2 p2 = p;\n    p2.x = abs(p2.x);\n    \n    if(part < 1)\n    {\n        drawEllipseX(col,p2,v.v);\n    }\n    else if(part < 2)\n    {\n        drawEllipseX(col,p,v.v);\n    }\n    else if(part < 3)\n    {\n        drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),v.v);\n    }\n}\n/*\nvoid renderFace1(inout vec3 col,vec2 pos,vec2 offset,Vec v)\n{\n    vec2 p = pos - offset;\n    vec2 p2 = p;\n    p2.x = abs(p2.x);\n    \n    float[] params1 = float[8](0.25,0.0,0.0,0.04,0.06,1.0,0.5,0.5);\n    float[] params2 = float[8](0.246,0.0,0.0,0.02,0.03,0.0,0.0,0.0);\n    float[] params3 = float[8](0.0,0.0,0.0,0.25,0.2,1.0,0.5,0.5);\n    float[] params4 = float[8](0.1,0.06,0.0,0.06,0.04,1.0,1.0,1.0);\n    float[] params5 = float[8](0.1,0.06,0.0,0.03,0.03,0.0,0.0,0.0);\n    float[] params6 = float[8](0.0,-0.1,0.0,0.1,0.06,1.0,0.0,0.5);\n    float[] params7 = float[8](0.05,-0.1+0.048,-0.35,0.3,0.5,1.0,1.0,1.0);\n    float[] params8 = float[8](0.05,-0.1-0.036,-0.5,0.2,0.2,1.0,1.0,1.0);\n    \n    //ears\n    drawEllipseX(col,p2,params1);\n    drawEllipseX(col,p2,params2);\n    \n    //face\n    drawEllipseX(col,p,params3);\n    \n    //eyes\n    drawEllipseX(col,p2,params4);\n    drawEllipseX(col,p2,params5);\n    \n    //mouth\n    drawEllipseX(col,p,params6);\n    \n    //teeth\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params7);\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params8);\n}\n\nvoid renderFace2(inout vec3 col,vec2 pos,vec2 offset,Vec v)\n{\n    vec2 p = pos - offset;\n    vec2 p2 = p;\n    p2.x = abs(p2.x);\n    \n    float[] params1 = float[8](0.16,0.15,1.0,0.06,0.06,0.0,0.5,0.5);\n    float[] params2 = float[8](0.161,0.15,1.0,0.03,0.03,0.1,0.3,0.3);\n    float[] params3 = float[8](0.0,0.0,0.0,0.2,0.2,0.0,0.5,0.5);\n    float[] params4 = float[8](0.1,0.06,0.0,0.04,0.04,1.0,1.0,1.0);\n    float[] params5 = float[8](0.093,0.06,0.0,0.025,0.025,0.0,0.0,0.0);\n    float[] params6 = float[8](0.0,-0.06,0.0,0.1,0.02,1.0,0.0,0.5);\n    float[] params7 = float[8](0.02,-0.06-0.02,-3.14159,0.16,0.3,1.0,1.0,1.0);\n    float[] params8 = float[8](0.07,-0.06+0.01,-0.31,0.2,0.7,1.0,1.0,1.0);\n    \n    //ears\n    drawEllipseX(col,p2,params1);\n    drawEllipseX(col,p2,params2);\n    \n    //face\n    drawEllipseX(col,p,params3);\n    \n    //eyes\n    drawEllipseX(col,p2,params4);\n    drawEllipseX(col,p2,params5);\n    \n    //mouth\n    drawEllipseX(col,p,params6);\n    \n    //teeth\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params7);\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params8);\n}\n\nvoid renderFace3(inout vec3 col,vec2 pos,vec2 offset,Vec v)\n{\n    vec2 p = pos - offset;\n    vec2 p2 = p;\n    p2.x = abs(p2.x);\n    \n    float[] params1 = float[8](0.13,0.19,1.1,0.16,0.04,0.7,0.6,0.2);\n    float[] params2 = float[8](0.131,0.19,1.1,0.13,0.02,0.6,0.5,0.3);\n    float[] params3 = float[8](0.001,0.001,0.001,0.15,0.21,0.7,0.6,0.2);\n    float[] params4 = float[8](0.07,0.06,0.4,0.06,0.04,1.0,0.0,0.0);\n    float[] params5 = float[8](0.08,0.06,0.0,0.0252,0.0253,0.3,0.1,0.6);\n    float[] params6 = float[8](0.0,-0.09,0.0,0.1,0.04,1.0,0.0,0.5);\n    float[] params7 = float[8](0.023,-0.048,-0.218,0.16,0.7,1.0,1.0,1.0);\n    float[] params8 = float[8](0.072,-0.12,-2.94159,0.2,0.7,1.0,1.0,1.0);\n    \n    //ears\n    drawEllipseX(col,p2,params1);\n    drawEllipseX(col,p2,params2);\n    \n    //face\n    drawEllipseX(col,p,params3);\n    \n    //eyes\n    drawEllipseX(col,p2,params4);\n    drawEllipseX(col,p2,params5);\n    \n    //mouth\n    drawEllipseX(col,p,params6);\n    \n    //teeth\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params7);\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params8);\n}\n\nvoid renderFace4(inout vec3 col,vec2 pos,vec2 offset,Vec v)\n{\n    vec2 p = pos - offset;\n    vec2 p2 = p;\n    p2.x = abs(p2.x);\n    \n    float[] params1 = float[8](0.16,0.16,3.1,0.12,0.2,0.8,0.8,0.8);\n    float[] params2 = float[8](0.161,0.16,3.1,0.07,0.14,0.5,0.3,0.3);\n    float[] params3 = float[8](0.002,0.002,0.002,0.315,0.151,0.8,0.8,0.8);\n    float[] params4 = float[8](0.026,-0.072,0.0,0.02,0.03,1.0,1.0,1.0);\n    float[] params5 = float[8](0.08,-0.072,0.0,0.02,0.0253,1.0,1.0,1.0);\n    float[] params6 = float[8](0.0,-0.05,0.0,0.2,0.007,0.6,0.6,0.6);\n    float[] params7 = float[8](0.033,0.028,1.69,0.32,1.5,1.0,1.0,1.0);\n    float[] params8 = float[8](0.050,0.032,1.69,0.22,0.67,0.0,0.0,0.0);\n    \n    //ears\n    drawEllipseX(col,p2,params1);\n    drawEllipseX(col,p2,params2);\n    \n    //face\n    drawEllipseX(col,p,params3);\n    \n    //eyes\n    drawEllipseX(col,p2,params4);\n    drawEllipseX(col,p2,params5);\n    \n    //mouth\n    drawEllipseX(col,p,params6);\n    \n    //teeth\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params7);\n    drawTriangleX(col,p2,vec2(0.0,-0.1),vec2(-0.1,0.0),vec2(0.1,0.0),params8);\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0,0.6,0.9);\n    Vec v = NewVec(P);\n    \n    renderFace1(col,uv,vec2(0.0,0.3),v);\n    renderFace2(col,uv,vec2(0.0,-0.3),v);\n    renderFace3(col,uv,vec2(-0.8,-0.3),v);\n    renderFace4(col,uv,vec2(0.8,-0.3),v);\n    fragColor = vec4(col,1.0); \n}\n*/\n\nVec ReadData(int x,int y)\n{\n   Vec v;\n   v.dim = P;\n   for(int i = 0;i < P;i ++)\n   {\n       v.v[i] = texelFetch(iChannel0,ivec2(x * P + i,y),0).r;\n   }\n    \n   return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    vec2 pos[O];\n    \n    for(int i = 0;i < O; i ++)\n    {\n        float rad = 3.1415926 / (180.0/(360.0/float(O))) * float(i);\n        \n        pos[i] = vec2(sin(rad),cos(rad)) * 0.75;\n    }\n    \n    int[] part = int[8](0,0,1,0,0,1,2,2);\n    Vec res;\n    for(int i = 0;i < 8;i ++)\n    {\n        for(int j = 0;j < O; j ++)\n        {\n            res = ReadData(j,i);\n\n            renderPart(col,uv,pos[j],res,part[i]); \n        }\n       \t\n        res = ReadData(O,i);\n        renderPart(col,uv,vec2(0.0),res,part[i]); \n    }\n    \n    fragColor = vec4(col,1.0); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Vec resolve(inout Mat PxO,vec2[O] pos,vec2 curpos)\n{\n    Mat OxO = NewMat(O,O);\n    Mat PxO_w = NewMat(P,O);\n    \n    for(int i = 0;i < O; i ++)\n    {\n        for(int j = 0;j < O; j ++)\n        {\n            vec2 k = pos[i] - pos[j];\n            \n            OxO.v[i].v[j] = rbf(dot(k,k));\n        }\n    }\n    \n    for(int i = 0;i < P; i ++)\n    {\n        conjugateGradient(PxO.v[i],OxO,O*8,PxO_w.v[i]);\n    }\n    \n    Vec cur = NewVec(O); \n    \n    for(int i = 0;i < O; i ++)\n    {\n        vec2 k = pos[i] - curpos;\n            \n        cur.v[i] = rbf(dot(k,k));\n    }\n    \n    Vec result = Mul(PxO_w,cur);\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos[O];\n    \n    for(int i = 0;i < O; i ++)\n    {\n        float rad = 3.1415926 / (180.0/(360.0/float(O))) * float(i);\n        \n        pos[i] = vec2(sin(rad),cos(rad)) * 0.75;\n    }\n    \n    vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    float recordData = texelFetch(iChannel0,ivec2(iResolution.x - 1.0,iResolution.y - 1.0),0).r;\n    if(recordData < 0.1)\n    {\n        mouse = vec2(0.0);\n    }\n    if(iMouse.z > 0.0)\n    {\n        if(int(fragCoord.x) == int(iResolution.x - 1.0) && int(fragCoord.y) == int(iResolution.y - 1.0))\n        {\n            fragColor = vec4(1.0,1.0,1.0,1.0);\n        \treturn;\n        }\n    }\n    \n    Mat PxO = NewMat(P,O);\n    \n    int y = int(fragCoord.y) % P;\n    int x = int(fragCoord.x);\n    \n    if(y == 0)\n    {\n        SetCol(PxO,0,float[P](0.25,0.0,0.0,0.04,0.06,1.0,0.5,0.5));\n    \tSetCol(PxO,1,float[P](0.16,0.15,1.0,0.06,0.06,0.0,0.5,0.5));\n        SetCol(PxO,2,float[P](0.13,0.19,1.1,0.16,0.04,0.7,0.6,0.2));\n        SetCol(PxO,3,float[P](0.16,0.16,3.1,0.12,0.2,0.8,0.8,0.8));\n    }\n    else if(y == 1)\n    {\n    \tSetCol(PxO,0,float[P](0.246,0.0,0.0,0.02,0.03,0.0,0.0,0.0));\n    \tSetCol(PxO,1,float[P](0.161,0.15,1.0,0.03,0.03,0.1,0.3,0.3));  \n        SetCol(PxO,2,float[P](0.131,0.19,1.1,0.13,0.02,0.6,0.5,0.3));\n        SetCol(PxO,3,float[P](0.161,0.16,3.1,0.07,0.14,0.5,0.3,0.3));\n    }\n    else if(y == 2)\n    {\n    \tSetCol(PxO,0,float[P](0.001,0.01,0.001,0.25,0.2,1.0,0.5,0.5));\n    \tSetCol(PxO,1,float[P](0.002,0.02,0.01,0.2,0.2,0.01,0.5,0.5));\n        SetCol(PxO,2,float[P](0.001,0.001,0.001,0.15,0.21,0.7,0.6,0.2));\n        SetCol(PxO,3,float[P](0.002,0.002,0.002,0.315,0.151,0.8,0.8,0.8));\n    }\n    else if(y == 3)\n    {\n        SetCol(PxO,0,float[P](0.1001,0.061,0.001,0.06,0.04,1.0,1.0,1.0));\n    \tSetCol(PxO,1,float[P](0.1,0.06,0.0,0.04,0.04,1.0,1.0,1.0));\n        SetCol(PxO,2,float[P](0.07,0.06,0.4,0.06,0.04,1.0,0.0,0.0));\n        SetCol(PxO,3,float[P](0.026,-0.072,0.0,0.02,0.03,1.0,1.0,1.0));\n    }\n    else if(y == 4)\n    {\n        SetCol(PxO,0,float[P](0.1,0.06,0.001,0.03,0.03,0.01,0.01,0.01));\n    \tSetCol(PxO,1,float[P](0.093,0.06,0.0001,0.025,0.025,0.0,0.0,0.0));\n        SetCol(PxO,2,float[P](0.08,0.06,0.0,0.0252,0.0253,0.3,0.1,0.6));\n        SetCol(PxO,3,float[P](0.08,-0.072,0.0,0.02,0.0253,1.0,1.0,1.0));\n    }\n    else if(y == 5)\n    {\n        SetCol(PxO,0,float[P](0.001,-0.1,0.001,0.1,0.06,1.0,0.01,0.5));\n    \tSetCol(PxO,1,float[P](0.0,-0.06,0.0,0.1,0.02,1.0,0.0,0.5));\n        SetCol(PxO,2,float[P](0.0,-0.09,0.0,0.1,0.04,1.0,0.0,0.5));\n        SetCol(PxO,3,float[P](0.0,-0.05,0.0,0.2,0.007,0.6,0.6,0.6));\n    }\n    else if(y == 6)\n    {\n        SetCol(PxO,0,float[P](0.05,-0.1+0.048,-0.35,0.3,0.5,1.0,1.0,1.0));\n    \tSetCol(PxO,1,float[P](0.02,-0.06-0.02,-3.14159,0.16,0.3,1.0,1.0,1.0));\n        SetCol(PxO,2,float[P](0.023,-0.048,-0.218,0.16,0.7,1.0,1.0,1.0));\n        SetCol(PxO,3,float[P](0.033,0.028,1.69,0.32,1.5,1.0,1.0,1.0));\n    }\n    else if(y == 7)\n    {\n        SetCol(PxO,0,float[P](0.05,-0.1-0.036,-0.5,0.2,0.2,1.0,1.0,1.0));\n    \tSetCol(PxO,1,float[P](0.07,-0.06+0.01,-0.31,0.2,0.7,1.0,1.0,1.0));\n        SetCol(PxO,2,float[P](0.072,-0.12,-2.94159,0.2,0.7,1.0,1.0,1.0));\n        SetCol(PxO,3,float[P](0.050,0.032,1.69,0.22,0.67,0.0,0.0,0.0));\n    }\n    else\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    \n    int index = x / P;\n    \n    if(index < O)\n    {\n     \tVec res = GetCol(PxO,index);\n    \n        if(x < P*(index + 1) && x >= P*index)\n        {\n            fragColor = vec4(res.v[x - P*index]);\n            return;\n        }   \n    }\n    else if(index == O)\n    {\n    \tVec part = resolve(PxO,pos,mouse);\n        if(x < P*(index + 1) && x >= P*index)\n        {\n            fragColor = vec4(part.v[x - P*index]);\n            return;\n        }\n    }\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rbf(float n)\n{\n   return exp(-0.1 * n);\n}\n\n#define N (8)\n\n/*\nP = params  number\nO = object  number\n*/\n#define P  (8)\n#define O  (4)\n\nstruct Vec\n{\n\tfloat v[N];\n    int   dim;\n};\n\nstruct Mat\n{\n    Vec   v[N];\n    int   row;\n    int   col;\n};\n    \nVec NewVec(int dim)\n{\n   \tVec v;\n   \tv.dim = min(dim,N);\n    for(int i = 0;i < v.dim;i ++)\n    {\n        v.v[i] = 0.0;\n    }\n    \n   \treturn v;\n}\n\nMat NewMat(int row,int col)\n{\n   \tMat m;\n   \tm.row = min(row,N);\n    m.col = min(col,N);\n    \n    for(int i = 0;i < m.row;i ++)\n    {\n         m.v[i] = NewVec(m.col);\n    }\n    \n   \treturn m;\n}\n    \nfloat Dot(Vec a,Vec b)\n{\n    float result = 0.0;\n    for(int i = 0;i < min(a.dim,b.dim);i ++)\n    {\n        result += a.v[i] * b.v[i];\n    }\n    \n    return result;\n}\n\nvoid SetCol(inout Mat m,int col,float[P] v)\n{\n    for(int i = 0;i < min(P,m.row); i ++)\n    {\n        m.v[i].v[col] = v[i];\n    }\n}\n\nvoid SetRow(inout Mat m,int row,Vec v)\n{\n    m.v[row] = v;\n}\n\nvoid SetCol(inout Mat m,int col,Vec v)\n{\n    for(int i = 0;i < min(m.row,v.dim); i ++)\n    {\n    \tm.v[i].v[col] = v.v[i];\n    }\n}\n\nVec GetRow(Mat m,int row)\n{\n    return m.v[row];\n}\n\nVec GetCol(Mat m,int col)\n{\n    Vec v;\n    v.dim = m.row;\n    \n    for(int i = 0;i < v.dim; i ++)\n    {\n        v.v[i] = m.v[i].v[col];\n    }\n    \n    return v;\n}\n\nVec Mul(Mat m,Vec v)\n{\n    Vec result;\n    result.dim = m.row;\n    for(int i = 0;i < m.row;i ++)\n    {\n        result.v[i] = Dot(m.v[i],v);\n    }\n    return result;\n}\n\nVec MulT(Mat m,Vec v)\n{\n    Vec result;\n    result.dim = m.col;\n    for(int i = 0;i < m.col;i ++)\n    {\n        float r = 0.0;\n        for(int j = 0;j < min(m.row,v.dim);j ++)\n        {\n            r += m.v[j].v[i] * v.v[j];\n        }\n        result.v[i] = r;\n    }\n    return result;\n}\n\nVec Add(Vec a,Vec b)\n{\n    Vec result;\n    result.dim = min(a.dim,b.dim);\n    for(int i = 0;i < result.dim;i ++)\n    {\n        result.v[i] = a.v[i] + b.v[i];\n    }\n    return result;\n}\n\nVec Sub(Vec a,Vec b)\n{\n    Vec result;\n    result.dim = min(a.dim,b.dim);\n    for(int i = 0;i < result.dim;i ++)\n    {\n        result.v[i] = a.v[i] - b.v[i];\n    }\n    return result;\n}\n\nVec Scale(Vec a, float b)\n{\n    Vec result;\n    result.dim = a.dim;\n    for(int i = 0;i < result.dim;i ++)\n    {\n        result.v[i] = a.v[i] * b;\n    }\n    return result;\n}\n\nvoid conjugateGradient(Vec b,Mat A,int itercount,inout Vec x)\n{\n    Vec r = Sub(b,Mul(A,x));\n    Vec d = r;\n    \n    float delta = Dot(r,r);\n    for(int i = 0; i < itercount;i ++)\n    {\n        Vec Ad = Mul(A,d);\n\n        float alpha = delta / Dot(d,Ad);\n\n        x = Add(x,Scale(d,alpha));\n        r = Sub(r,Scale(Ad,alpha));\n\n        float delta2 = Dot(r,r);\n\n        if(sqrt(delta2) < 1e-10)\n        {\n            break;\n        }\n\n        float beta = delta2 / delta;\n\n        d = Add(r,Scale(d,beta));\n\n        delta = delta2;\n    }\n}","name":"Common","description":"","type":"common"}]}