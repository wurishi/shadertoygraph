{"ver":"0.1","info":{"id":"3d2cDz","date":"1586613552","viewed":120,"name":"Paths for days","username":"piluve","description":"Simple indirect diffuse path tracing. This is an experiment to understand path tracing. ","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["tracing","indirect","diffuse","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    if(iFrame > 0)\n    {\n        color = texture(iChannel0, uv).rgb;\n        color /= float(iFrame);\n    }\n    const float g = 1.0 / 2.2;\n    color = pow(color, vec3(g));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tPaths for days\n\tnachocpol@gmail.com\n\n\tWanted to try some diffuse indirect path tracing. \n\tTO-DO: shadows!\n\n\thttps://iquilezles.org/articles/simplepathtracing\t\n\thttps://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing\n*/\n\n#define PI 3.14159265\n\nfloat farPlane = 200.0;\nfloat nearPlane = 0.5;\nint maxSteps = 256;\nint bounces = 4;\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat SphereDist(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat BoxDist(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 Map(vec3 p)\n{\n    float sphereA = SphereDist(p, 1.0);\n    float flr     = BoxDist(p, vec3(2.0, 0.05, 2.0));\n    float ceiln   = BoxDist(p - vec3(0.0,4.0,0.0), vec3(2.0, 0.05, 2.0));\n    float lftWall = BoxDist(p - vec3(-2.0,2.0,0.0), vec3(0.05, 2.0, 2.0));\n    float rigWall = BoxDist(p - vec3( 2.0,2.0,0.0), vec3(0.05, 2.0, 2.0));\n    float bckWall = BoxDist(p - vec3( 0.0,2.0,2.0), vec3(2.0, 2.0, 0.05));\n    \n    float d = min(sphereA, flr);\n    d = min(d, lftWall);\n    d = min(d, rigWall);\n    d = min(d, bckWall);\n    d = min(d, ceiln);\n    \n    float id = 1.0; // White\n    if(d == lftWall)\n    {\n        id = 2.0;   // Red\n    }\n    else if(d == rigWall)\n    {\n        id = 3.0;   // Green\n    }\n    \n    return vec2(d, id);\n}\n\nvec3 Normal(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.0);\n    return normalize(vec3(\n        Map(p + eps.xyy).x - Map(p - eps.xyy).x,\n        Map(p + eps.yxy).x - Map(p - eps.yxy).x,\n        Map(p + eps.yyx).x - Map(p - eps.yyx).x\n    ));\n}\n\nvec2 Scene(vec3 ro, vec3 rd)\n{\n    float curD = nearPlane;\n    \n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * curD;\n        vec2 hit = Map(p);\n        if(hit.x < 0.001)\n        {\n            return vec2(curD, hit.y);\n        }\n        curD += hit.x;\n        if(curD >= farPlane)\n        {\n            break;\n        }\n    }\n    \n    return vec2(farPlane, -1.0);\n}\n\nvec3 HemisphereCosDir( float seed, vec3 normal)\n{\n    float u = rand( 78.233 + seed);\n    float v = rand( 10.873 + seed);\n\n    // http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\n}\n\nvec3 Shade(vec3 ro, vec3 rd, float seed)\n{\n    vec3 color = vec3(0.0);\n    vec3 atten = vec3(1.0);\n    \n    for(int b = 0; b < bounces; ++b)\n    {\n        vec2 hit = Scene(ro, rd);\n    \tif(hit.y >= 0.0)\n    \t{\n            vec3 position = ro + rd * hit.x;\n        \tvec3 normal = Normal(position);\n        \n        \t// Direct light:\n            float radius = 4.0;\n        \tvec3 toLight = vec3(0.0,3.5,1.0) - position;\n            float lightAtten = 1.0 - min((length(toLight) / radius),1.0);\n        \tfloat NdotL = max(dot(normal, normalize(toLight)), 0.0);\n        \tvec3 Li = vec3(1.0, 0.9, 0.6) * 2.0 * NdotL * (lightAtten * lightAtten);\n        \n        \tvec3 albedo = vec3(0.45);\n        \tif(hit.y == 2.0)\n        \t{\n            \talbedo = vec3(1.0,0.0,0.0);\n        \t}\n        \telse if(hit.y == 3.0)\n        \t{\n            \talbedo = vec3(0.0,1.0,0.0);\n        \t}\n        \tatten *= albedo;\n            \n        \tcolor += Li * atten; \n            \n            // Random dir in hemisphere oriented along normal (cos distribution):                        \n            rd = HemisphereCosDir(seed, normal);\n            ro = position;\n    \t}\n    \telse\n    \t{\n            if(b == 0) \n            {\n                return vec3(0.0);\n            }\n            break;\n    \t}   \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 2.0, -5.0);\n    vec3 rd = normalize(vec3(ndc,1.8));\n    \n    float seed = rand(fragCoord.xy) + float(iFrame) * 321.123;\n    vec3 mapColor = Shade(ro, rd, seed);\n    \n    // Acum color:\n    vec3 prevColor = texture(iChannel0, uv).rgb;\n    if(iFrame == 0)\n    {\n        prevColor = vec3(0.0);\n    }\n    fragColor = vec4(prevColor + mapColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}