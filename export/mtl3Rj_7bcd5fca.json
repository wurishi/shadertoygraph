{"ver":"0.1","info":{"id":"mtl3Rj","date":"1672072034","viewed":98,"name":"bass, middle, treble","username":"NivBehar","description":"Continues smooth variables for bass, middle and treble which can be used for reacting to sound\nreferences:\nhttps://www.shadertoy.com/view/Xds3Rr\nhttps://www.shadertoy.com/view/3sGyWz\nhttps://www.youtube.com/watch?v=lEUuC3LQnzs&list=PL3POsQzaCw53p2tA6AWf7\n","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["sound","bass","middle","treble"],"hasliked":0,"parentid":"Wt33Dn","parentname":"Continues private"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n1.Screen is devided to 3 bands: bass (red), middle (green), and treble (blue).\n\n2.Each band divided to 2: pure sound with some midifications (left squere) and smooth sound (right squere).\n\n3.For each smooth sound, there is a variable called\nx_sound_cont (x represents bass\\mid\\treb) that increases with time as long as the refered \nsound goes on (made by sending the sound variable at the previous frame to the current\nframe and adding it to the x_sound_cont variable).\nfor each of those there is a circle which moves right and left, at the speed of x_sound_cont.\n\n4. bottom white line is y = 1, second is y = 1.5\n\nHow to use it:\n\n   a.   use BufA(x, y) with:\n        x = 1 -> bass\n            y = 0 -> pure sound\n            y = 3 -> smooth sound\n            y = 2 -> smooth sound cont\n\n        x = 2 -> middle\n            y = ...\n\n        x = 3 -> treble\n            y = ...\n            \n   b.   you can tune some values in BufferA at the #define section\n\n*/\n\n# define SCALE_SOUND 1.\n# define SCALE_SMOOTH_SOUND 1.\n# define SCALE_SOUND_CONT 1.\n\n// drawing the bands for bass\\treble\\middle\nvec3 getBand(vec3 col ,vec2 UV, float posX, float top, float width, bool isPure, float top2)\n{\n    vec3 ret = vec3(0.);\n    if(abs(UV.x - posX) < width/2.)\n    {\n        if(UV.y < top)\n            ret = col;\n            \n        // white bar on top of the pure sound, which is the same as the smooth sound (for better comparing)\n        if(isPure && UV.y > top2 - 0.01 && UV.y < top2 + 0.01)\n            ret = vec3(1.);\n    }\n\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= 2.;\n    \n    vec3 col = vec3(0.); // final color\n    float r = 0.025; // radius of the circles\n    bool is_odd; // used to calculate circles positions\n    \n    float width = 0.13; // width of the band\n    float base_pos = 1./7.; // base position for the bands\n    \n    \n    // bass parameters\n    float bass = BufA(0.,0.).x * SCALE_SOUND;\n    float smooth_bass = GET_BASS * SCALE_SMOOTH_SOUND;\n    float smooth_bass_cont = GET_BASS_CONT * SCALE_SOUND_CONT;\n    \n    //             col             uv  posX         top   width   isPure  smooth\n    col += getBand(vec3(1.,0.,0.), uv, base_pos*1., bass, width,  true,   smooth_bass);\n    col += getBand(vec3(1.,0.,0.), uv, base_pos*2., smooth_bass, width,  false,  smooth_bass);\n    \n    // bass top circle\n    vec2 bass_pos = vec2(0.,1.6);\n    // when the floor value is odd, the circle will go right, else - left\n    is_odd = mod(floor(smooth_bass_cont), 2.) == 1.;\n    bass_pos.x = is_odd ? fract(smooth_bass_cont) : 1.-fract(smooth_bass_cont);\n    col.x += smoothstep(r+0.001,r, length(uv-bass_pos));\n    \n    \n    // middle parameters\n    float mid = BufA(1.,0.).x * SCALE_SOUND;\n    float smooth_mid = GET_MID * SCALE_SMOOTH_SOUND;\n    float smooth_mid_cont = GET_MID_CONT * SCALE_SOUND_CONT;\n\n    //             col             uv  posX         top  width   isPure  smooth\n    col += getBand(vec3(0.,1.,0.), uv, base_pos*3., mid, width,  true,   smooth_mid);\n    col += getBand(vec3(0.,1.,0.), uv, base_pos*4., smooth_mid, width,  false,  smooth_mid);\n    \n    // middle top circle\n    vec2 mid_pos = vec2(0.,1.75);\n    // when its odd, the circle will go right, else - left\n    is_odd = mod(floor(smooth_mid_cont), 2.) == 1.;\n    mid_pos.x = is_odd ? fract(smooth_mid_cont) : 1.-fract(smooth_mid_cont);\n    col.y += smoothstep(r+0.001,r, length(uv-mid_pos));\n\n\n    // treble parameters\n    float treb = BufA(2.,0.).x * SCALE_SOUND;\n    float smooth_treb = GET_TREB * SCALE_SMOOTH_SOUND;\n    float smooth_treb_cont = GET_TREB_CONT * SCALE_SOUND_CONT;\n    \n    //             col             uv  posX         top   width   isPure  smooth\n    col += getBand(vec3(0.,0.,1.), uv, base_pos*5., treb, width,  true,   smooth_treb);\n    col += getBand(vec3(0.,0.,1.), uv, base_pos*6., smooth_treb, width,  false,  smooth_treb);\n    \n    // treble top circle\n    vec2 treble_pos = vec2(0.,1.9);\n    // when its odd, the circle will go right, else - left\n    is_odd = mod(floor(smooth_treb_cont), 2.) == 1.;\n    treble_pos.x = is_odd ? fract(smooth_treb_cont) : 1.-fract(smooth_treb_cont);\n    col.z += smoothstep(r+0.001,r, length(uv-treble_pos));\n    \n    // draw y = 1 and y = 1.5\n    if((uv.y < 1.009 && uv.y > 0.998) || (uv.y < 1.509 && uv.y > 1.498))\n        col = vec3(1.);\n    \n    //if(uv.x < 0.5)\n        //col = vec3(1.,0.5,2.);\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtBSWG","filepath":"https://soundcloud.com/proton/premiere-vridian-coming-of-age-original-mix","previewfilepath":"https://soundcloud.com/proton/premiere-vridian-coming-of-age-original-mix","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define time iTime\n\n// bass bands\n# define BASS_START 0\n# define BASS_END 14\n// middle bands\n# define MID_START 15\n# define MID_END 143\n// treble bands\n# define TREBLE_START 144\n# define TREBLE_END 511\n\n// this shader works differently for higher\\lower fps,\n// so this values has to be tuned to get nice results \n// ** Update - after switching dependency to relay on iTimeDelta, I think its the same for all fps values.\n\n\n/*------------ Tuning ------------*/\n\n/*---- Smooth Sound values ----*/\n// lower value - less time for the smooth sound stay on top of the pure sound\n#define DECREASE_MIN 0.001\n// lower value - lower decrease time. should be above 1.\n#define DECREASE_MUL 8.\n\n/*---- Smooth Sound Continues values ----*/\n/* play with this to get smaller\\bigger \"acceleration\" for the circles\n   lower value - more deceleration\n   should be below 1 */\n#define DELTA_INCREASE 0.15\n\n/* should be a value between 0 and 1\n   play with this to get smaller\\bigger \"deceleration\" for the circles\n   lower value - less acceleration */\n#define DELTA_MUL 0.9\n\n/* bigger DELTA_COUNT_MAX value will take into account more of the \"acceleration\"\n   lower value will restrain the acceleration\n   in other words - saturate it */\n#define DELTA_COUNT_MAX 10.\n\nfloat getSound(int start, int end)\n{\n    float ret = 0.;\n    for(int i = start; i <= end; i++)\n    {\n        float samp = texelFetch(iChannel0, ivec2(i, 0), 0).x;\n        \n        samp = samp*samp + 0.5*samp;\n        if(samp > 0.8)\n            samp *= 0.8; // just to reduce the magnitude of the low frequencies\n        ret += samp;\n    }\n    \n    ret /= float(end - start + 1);\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fpsInv = 60./iFrameRate;\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 operation = fragCoord - 0.5;\n\n    int start, end;\n    \n    float sound; // pure sound samples average\n    float prev_sound; // previous sound\n    float smooth_sound; // smooth sound\n    float prev_smooth_sound; // previous smooth sound\n    float decrease;\n    float smooth_sound_cont; // smooth sound continues\n    float prev_smooth_sound_cont; // previous smooth sound continues\n    float delta;\n    float delta_count;\n\n    // Initialize values\n    if(iFrame == 0)\n    {\n        sound = 0.;\n        prev_sound = 0.;\n        smooth_sound = 0.;\n        prev_smooth_sound = 0.;\n        decrease = 0.;\n        smooth_sound_cont = 0.;\n        prev_smooth_sound_cont = 0.;\n        delta = 0.;\n        delta_count = 0.;\n    }\n    \n    // fragCoord.x determines to calculate bass\\mid\\treble\n    if(operation.x == 0.) { start = BASS_START; end = BASS_END;}\n    if(operation.x == 1.) { start = MID_START; end = MID_END;}\n    if(operation.x == 2.) { start = TREBLE_START; end = TREBLE_END;}\n    \n    // prev sound\n    sound = getSound(start, end);\n    prev_sound = BufA(operation.x, 0.).x;\n    \n    // sound type 2\n    prev_smooth_sound_cont = BufA(operation.x, 2.).x;\n    prev_smooth_sound = BufA(operation.x, 3.).x;;\n    decrease = BufA(operation.x, 4.).x;\n    if(sound > prev_smooth_sound)\n    {\n        smooth_sound = sound;\n        decrease = DECREASE_MIN;\n    }\n    else\n    {\n        smooth_sound = prev_smooth_sound - decrease;\n        decrease *= 1. + iTimeDelta * DECREASE_MUL;\n    }\n    \n    // smooth_sound_cont - circles motion\n    delta = BufA(operation.x, 5.).x;\n    delta_count = BufA(operation.x, 6.).x;\n    if(sound > prev_sound)\n    {\n        // this statement is to prevent exreme acceleration, when bass\\middle\\treble goes higher very quickly.\n        // in other words - saturate it.\n        // bigger value - accept a bigger acceleration.\n        // to notice the difference, just comment the if statement and reset the shader,\n        // then look at the blue circle which represent the treble\n        if(delta_count < DELTA_COUNT_MAX)\n        {\n            //delta += DELTA_INCREASE;\n            delta += iTimeDelta * DELTA_INCREASE;\n            delta_count += 1.; // for each delta increase\n        }\n    }\n    else\n    {\n        delta_count = 0.; // reset the counting\n        delta *= DELTA_MUL;\n    }\n    smooth_sound_cont = smooth_sound*iTimeDelta + delta + prev_smooth_sound_cont; \n    \n    // to prevent the value to go extremely high, can be useful in some cases when we only care about the fraction value\n    //if(smooth_sound_cont > 50.)\n    //    smooth_sound_cont -= floor(smooth_sound_cont);\n    \n    // fragCoord.y determines to calculate sound\\smoth_sound\\etc..\n    if(operation.y == 0.)\n        fragColor = vec4(sound, 0.,0.,1.0);\n    if(operation.y == 2.)\n        fragColor = vec4(smooth_sound_cont, 0.,0.,1.0);\n    if(operation.y == 3.)\n        fragColor = vec4(smooth_sound, 0.,0.,1.0);\n    if(operation.y == 4.)\n        fragColor = vec4(decrease, 0.,0.,1.0);\n    if(operation.y == 5.)\n        fragColor = vec4(delta, 0.,0.,1.0);\n    if(operation.y == 6.)\n        fragColor = vec4(delta_count, 0.,0.,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BufA(x, y) texture(iChannel1, (vec2(x, y) + 0.5) / iResolution.xy)\n#define BufB(x, y) texture(iChannel2, (vec2(x, y) + 0.5) / iResolution.xy)\n#define GET_BASS BufA(0.,3.).x\n#define GET_BASS_CONT BufA(0.,2.).x\n#define GET_MID BufA(1.,3.).x\n#define GET_MID_CONT BufA(1.,2.).x\n#define GET_TREB BufA(2.,3.).x\n#define GET_TREB_CONT BufA(2.,2.).x\n#define GET_SOUND (GET_BASS + GET_MID + GET_TREB)/3.\n#define GET_SOUND_CONT (GET_BASS_CONT + GET_MID_CONT + GET_TREB_CONT)/3.","name":"Common","description":"","type":"common"}]}