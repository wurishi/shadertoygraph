{"ver":"0.1","info":{"id":"DsBcDm","date":"1691518292","viewed":59,"name":"Exploding Crystals","username":"sagescherrytree","description":"Followed an interesting raymarch structure to practise more on how I can mathematically create cool shapes with SDFs. \nReference: https://www.shadertoy.com/view/MdlBW7","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897;\nvec3 col = vec3(0.99, 0.1, 0.05) * 0.9;\n// Value to create glow\nfloat accum;\n\nvec3 palette(float t) {\n    //vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 a = vec3(0.500, 0.500, 0.770);\n    //vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.610, 0.500, 0.790);\n    //vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 c = vec3(0.801, 0.800, 0.664);\n    //vec3 d = vec3(0.263,0.416,0.557);\n    //vec3 d = vec3(1.388, -0.842, -0.132);\n    //vec3 d = vec3(1.388, -0.842, 0.628);\n    vec3 d = vec3(-0.682, -0.485, 2.675);\n    //vec3 d = vec3(-0.682, -0.485, -2.675);\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvoid rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec3 random(vec3 r) {\n    return 1.0 + fract(sin(vec3(dot(r, vec3(127.1, 311.7, 214.2)), dot(r, vec3(269.5, 183.3, 533.2)), dot(r, vec3(424.53, 321.4, 214.9)))) * 43758.5453);\n}\n\nfloat random2(float a) {\n    return fract(0.2 * sin(a * 4.2145) + 1.4315);\n}\n\nfloat SDF_Sphere(vec3 query, float radius ) {\n    return length(query) - radius;\n}\n\nfloat SDF_Box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SDF_RoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) - r;\n}\n\nfloat SDF_Octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat smooth_min( float a, float b, float k ) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat opUnion( float d1, float d2 ) { \n    return min(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nSmoothMinResult smooth_min_lerp( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*0.5;\n    if(a < b) {\n        return SmoothMinResult(a-s,m);\n    }\n    return SmoothMinResult(b-s,1.0-m);\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nfloat sceneSDF1(vec3 query) {\n    // Switch query's coordinates using a temp swap\n    // query = vec3(-query.y, query.x, query.z)\n    float a = query.x;\n    query.x = -query.y;\n    query.y = a;\n    \n    // Rotate query on x axis by time\n    rotate( query.yz, iTime );\n    \n    float result = SDF_Sphere(query, 0.2);\n    // Bounds: for creating randomly generated rectangular prisms around a sphere structure.\n    // For that, we use theta and rng locations to make rectangles.\n    for (float i = -5.0; i < 6.0; ++i) {\n        float theta = (i/ 6.0) * PI * 0.5;\n        float boxNum = random2(i) + 3.0;\n        float radius = cos(theta) * random2(i);\n        float boxSize = abs(radius) * 0.12;\n        float boxOffSet = -sin(theta) * random2(i);\n        \n        rotate(query.yz, PI / (4.0 * boxNum));\n        \n        vec3 t = query;\n        float boxLength = 0.2 + sin(iTime) * 0.1;\n        t = query + vec3(boxOffSet, 0.5 * clamp(0.0, 0.5, cos (random2(iTime))), 0.2);\n        RepeatAngle(t.yz, boxNum);\n        t.y -= radius;\n        rotate(t.xy, -theta);\n        // Create box at input t\n        result = opSmoothUnion(result, SDF_Octahedron(t, boxLength * 0.5), 0.05);\n        \n        // Extra boxes\n        t = query;\n        // An offset box\n        boxLength = 0.2 + sin(iTime) * 0.1;\n        rotate(query.yz, PI / boxNum);\n        t = query + vec3(boxOffSet, sin(iTime) * 0.2, 0.0);\n        RepeatAngle(t.yz, boxNum);\n        t.y -= radius;\n        rotate(t.xy, -theta);\n        result = opSmoothUnion(result, SDF_Octahedron(t, boxLength * boxSize + 0.3), 0.1);\n    }\n    \n    return result;\n}\n\n// Complexity\nfloat sceneSDF(vec3 query) {\n    float result = sceneSDF1(query);\n    result = opSmoothUnion(result, sceneSDF1(query + vec3(1.0)), 0.05);\n    result = opSmoothUnion(result, sceneSDF1(query + vec3(1.0, -1.0, -1.0)), 0.05);\n    result = opSmoothUnion(result, sceneSDF1(query + vec3(-1.9, -0.5, -1.0)), 0.05);\n    result = opSmoothUnion(result, sceneSDF1(query + vec3(-1.0, 1.0, 1.0)), 0.05);\n    result = opSmoothUnion(result, SDF_Octahedron(query + vec3(-0.5, -0.2, 0.1), 0.13), 0.05);\n    return result;\n}\n\n// Calculate normal colour\nvec3 SDF_Normal(vec3 query) {\n    vec3 epsilon = vec3(0.0001, 0.0, 0.0);\n    return normalize( vec3( sceneSDF(query + epsilon.xyy) - sceneSDF(query - epsilon.xyy),\n                            sceneSDF(query + epsilon.yxy) - sceneSDF(query - epsilon.yxy),\n                            sceneSDF(query + epsilon.yxx) - sceneSDF(query - epsilon.yxx)));\n}\n\n// Contains ray.origin (position in world space) + ray.direction \n// @return colour of position of intersection\n// Distance based raymarching\nfloat raymarchFloat(Ray ray) {\n    // Iterate until we have something that hits inside an object\n    // If hit within obj, return -1\n    // Maximum distance\n    accum = 0.0;\n    const float maxDist = 5.0;\n    \n    vec3 query = ray.origin;\n    \n    float SDF = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        // Result of signed distance function\n        if (SDF < 0.001 || t > maxDist) {\n            break;\n        }\n        SDF = sceneSDF(query + ray.direction * t);\n        t += SDF;\n        \n        if (abs(SDF) < 0.35) {\n            accum += (0.35 - abs(SDF)) / 24.0;\n        }\n    }\n    if (t > maxDist) {\n        t = -1.0;\n    }\n    // Return how many times t along ray one needs to move to get to intersection. \n    return t;\n}\n\n// Up to changes\nvec3 KeyColor = vec3( 0.71, 0.85, 0.94);\nvec3 FillColor = vec3( 0.34, 0.45, 0.94); \n\nvec3 Sky( vec3 rayDir )\n{\n    vec3 skyPos = rayDir;\n\n    vec3 color = vec3(0.73, 0.91, 0.99) * mix(0.8, 1.0, smoothstep( 0.0, 1.0, saturate( -1.0 * skyPos.y + 0.3 ) ) );\n    color = mix( color, vec3(0.792, 0.921, 0.9423), smoothstep( 0.0, 1.0, saturate( -1.5 * skyPos.x - 0.3 ) ) );\n    return color;\n}\n\n// Ambient Occlusion\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = sceneSDF(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord/iResolution.xy;\n    \n    vec2 uv = -1.0 + 2.0 * uv0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Update ray position\n    vec3 rayPos = vec3(0.0, 0.0, -2.5);\n    vec3 rayDir = normalize(vec3(uv.xy, 2.0));\n    \n    // Can we update camPos\n    Ray ray = Ray(rayPos, rayDir);\n    \n    // Background colour\n    vec3 col = Sky(rayDir);\n\n    // Time varying pixel color\n    float result = raymarchFloat(ray);\n    \n    // Colour variation, I hope\n    if (result > 0.0) {\n        vec3 pos = rayPos + result * rayDir;\n        vec3 normal = SDF_Normal(pos);\n        \n        // Lighting\n        vec3 lightDir = normalize( vec3( 0.5, 0.5, -0.5 ) );\n        float d = max(length(lightDir), 0.001);\n        lightDir /= d; // Normalize light direction vector again.\n        \n        float diffuse = max(dot(pos, normal), 0.0);\n        float ao = cao(pos, normal);\n        \n        col = 0.8 * mix(FillColor, KeyColor, ao) ;\n        float specOcc = 0.3 + 0.8 * smoothstep( 0.0, 1.0, saturate( 2.0 * length( pos.xy ) ) );\n        float fresnel = saturate( pow( 1.8 + dot( rayDir, normal ), 8.0 ) );\n        col += 0.5 * Sky( normal ) * mix( 0.1, 1.0, fresnel );\n        col += 0.3 * KeyColor * saturate( dot( normal, lightDir ) );\n        col *= 0.85;\n        \n        // Some reflections\n        col *= (specOcc * specOcc * 0.25 + 0.75);\n        \n        col = mix(col.xzy, col, diffuse * 0.85 + 0.3);\n       \n        // Glow\n        /*\n        vec3 accumCol = vec3(1.0, 0.3, 0.1) * accum;\n        vec3 gc = pow(min(vec3(1.5, 1.0, 1.0) * accum, 1.0), vec3(1.0, 2.5, 12.0)) * 0.5 + accumCol * 0.5;\n        col += col * gc * 12.0;*/\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITERATIONS 60.f\n#define T_MAX 200.f\n#define ISECT_EPSILON 0.0001\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct MarchResult {\n    // How far along the ray was our intersection found?\n    // -1 if found nothing\n    float t;\n    // How many march iterations did we take?\n    float iterations;\n};\n\nstruct SmoothMinResult {\n    float dist;\n    float material_t;\n};","name":"Common","description":"","type":"common"}]}