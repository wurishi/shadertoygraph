{"ver":"0.1","info":{"id":"Xl2BRh","date":"1524535099","viewed":467,"name":"Outrun Sunset","username":"aflesher","description":"An outrun sunset","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["grid","sun","outrun","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(in vec2 st, in float radius, in float edge){\n    vec2 dist = st - vec2(0.5);\n    return 1.0 - smoothstep(radius - (radius * edge),\n                         radius + (radius * edge),\n                         dot(dist , dist) * 4.0);\n}\n\nfloat line(float center, float size, float edge, float y) {\n\treturn max(\n        max(\n        \tsmoothstep(center - size - edge, center - size, y) *\n            smoothstep(center + size + edge, center + size, y),\n        \tsmoothstep(center + size + edge - 1.0, center + size - 1.0, y)\n        ),\n        smoothstep(center - size + 1.0 - edge, center - size + 1.0, y)\n    );\n}\n\nvec3 bottomGrid(in vec2 st, in vec3 col) {\n    vec2 lines = vec2(10.0, 20.0);\n    float activeVLines = 5.0;\n    float maxVlines = 40.0;\n    vec2 shift = vec2(mix(lines.x, maxVlines, st.y), lines.y);\n    \n    vec2 suv = vec2((st.x * shift.x) - (shift.x * 0.5), st.y * shift.y);\n    vec2 fuv = fract(suv);\n    vec2 iuv = floor(suv);\n    \n    // black\n    col *= step(activeVLines, suv.y);\n    \n    // glow lines\n    vec3 glowCol = vec3(0.3, 1.0, 0.3);\n    float time = 1.0 - fract(iTime * 0.6);\n    \n    float gvLine = line(0.0, 0.04, 0.08, fuv.x);\n    float ghLine = max(\n        line(time, 0.12, 0.24, fuv.y),\n        line(0.0, 0.12, 0.12, fuv.y) * step(activeVLines - 0.16, suv.y)\n    );\n    \n    col = mix(col, glowCol, max(ghLine, gvLine) * step(suv.y, activeVLines + .16) * 0.3);\n    \n    // lines\n    vec3 lineCol = vec3(1.0, 1.0, 1.0);\n    \n    float vLine = line(0.0, 0.0025, 0.03, fuv.x);\n    float hLine = max(\n        line(time, 0.015, 0.06, fuv.y),\n        line(0.0, 0.03, 0.03, fuv.y) * step(activeVLines - 0.04, suv.y)\n    );\n    \n    col = mix(col, lineCol, max(hLine, vLine) * step(suv.y, activeVLines + .04));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scaleX = iResolution.x / iResolution.y;\n    vec2 sunUV = vec2((uv.x * scaleX) - ((scaleX - 1.0) * 0.5), uv.y);\n    vec2 texelSize = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\n    \n    float sunPct = circle(sunUV, 0.5, 0.01);\n    \n    // background\n    fragColor += (1.0 - fragColor.r) * vec4(0.2, 0.129, 0.286, 1);\n    \n    // stars\n    fragColor.rgb += vec3(max(90.* fract(dot(sin(fragCoord),fragCoord))-89.5, 0.0));\n    fragColor.rgb += vec3(max(70.* fract(dot(cos(fragCoord),fragCoord))-69.7, 0.0));\n    \n    // sun haze\n    float sunHazePct = circle(sunUV, 0.57, 0.2) * 0.35;\n    fragColor.rgb = ((1.0 - sunHazePct) * fragColor.rgb) + (vec3(0.909, 0.167, 0.596) * sunHazePct);\n    \n    // sun color\n    // get a 0 -> 1 value within our sun\n    float sunValue = smoothstep(0.3, 0.63, uv.y);\n    // line size increases the closer we are to the bottom of the sun\n    float lineSize = floor(mix(80.0, 0.0, sunValue)) * texelSize.y;\n    // lerp between our sun colors to get a gradient\n    vec3 sunColor = mix(vec3(0.909, 0.167, 0.596), vec3(1, 0.913, 0.305), sunValue);\n    \n    // line speed ( 1 - to make it go down)\n    float lineInt = 1.0 - fract(iTime * 0.3);\n    \n    // line count\n    float lineY = fract(uv.y * 14.0);\n    \n    // select our lines, invert so that active lines = 0\n    float lines = 1.0 - line(lineInt, lineSize, 0.05, lineY);\n    \n    // cutoff the top lines\n    lines = max(lines, step(0.6, uv.y));\n    \n    // cancel out sun on lines\n    sunPct *= lines;\n    \n    // add main circle\n    fragColor.rgb = ((1.0 - sunPct) * fragColor.rgb) + (sunColor * sunPct);\n    \n    fragColor.rgb = bottomGrid(uv, fragColor.rgb);\n}","name":"Image","description":"","type":"image"}]}