{"ver":"0.1","info":{"id":"wsGczK","date":"1639053668","viewed":152,"name":"Black_Hole","username":"irisdogg","description":"test shader to make a black hole like effect","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["space","stars","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on a tutorial: https://www.youtube.com/watch?v=rvDo9LvfoVE\n\n#define NUM_LAYERS 4.0\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0.0, 1.0)\n\nmat2 Rot(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, s, -s, c);\n}\n\n// Star and Starfield inspired by this tutorial https://www.shadertoy.com/view/tlyGW3\nfloat Star(vec2 uv, float flare) {\n    float dist = length(uv);\n    float m = 0.05 / dist;\n    \n    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n    m += rays * flare;\n  \tuv *= Rot(3.1415/4.0);\n    rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n    m += rays * 0.3 * flare;\n    \n    // smooth out the flare\n    m *= smoothstep(1.0, 0.2, dist);\n    return m;\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    \n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            \n            vec2 offset = vec2(x,y);\n        \t\n            float rand = Hash21(id + offset); // random between 0 and 1\n            float size = fract(rand * 345.32);\n            float star = Star(gv - offset - vec2(rand, fract(rand*34.0)) + 0.5, smoothstep(0.9, 1.0, size));\n        \tvec3 color = sin(vec3(0.2, 0.3, 0.9) * fract(rand * 2565.2)*2.) * 0.5 + 0.5;\n            star *= sin(iTime * 1.0 + rand * 6.2831) * 0.5 + 1.0;\n            col += star * size * color;\n        }\n    } \n\treturn col;    \n}\n\nvec4 BlackHole(vec2 uv) {\n    \n    vec4 col = vec4(0.0);\n    \n    vec4 circle2 = vec4(0.0);\n    \n    float radius = 4.0;\n    \n    float d = length(uv);\n    d /= 2.0;\n    \n    // Make the circle smooth\n    col.rgb = mix(col.rgb, vec3(1.0), S(0.0, 1.0, d)); \n\n    // don't color the pixels that are outside of the circle\n    // to make the \n    if(length(uv) > radius)\n    {\n        col.rgb = vec3(0.0);\n    }\n    \n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 M = (iMouse.xy - iResolution.xy*0.5) / iResolution.y; // on click move mouse around\n    // To zoom out I can multiple the uv by a larger number\n    uv *= 14.0;\n    \n    float t = iTime* 0.01;\n    uv += M * 4.0;\n    uv *= Rot(t);\n    //if( gv.x > 0.48 || gv.y > 0.48) col.r = 1.0;\n    vec4 col = vec4(0.0);\n    \n    for(float i = 0.0; i< 1.0; i+=1.0/NUM_LAYERS)\n    {\n        float depth = fract(i+t);\n        float scale = mix( 5., 0.5, depth);\n        float fade = depth * smoothstep(1.0, 0.9, depth);\n        col += vec4(StarLayer(uv * scale+i*43.2) * fade, 0);\n    }\n    \n    col -= BlackHole(uv);\n    \n    \n    float effectRadius = 0.5;\n    float effectAngle = 2.5 * 3.14159;\n    \n    float len = length(uv * vec2(iResolution.x / iResolution.y, 1.));\n    float angle = atan(uv.y, uv.x) + effectAngle * smoothstep(effectRadius, 0., len);\n    float radius = length(uv);\n    //vec4 test = texture(iChannel0, vec2(radius * cos(angle), radius * sin(angle)) + center);\n    /*\n    vec2 center = iMouse.xy / iResolution.xy;\n    center = center == vec2(0., 0.) ? vec2(.5, .5) : center;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - center;\n\t*/\n    //col += test;\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}