{"ver":"0.1","info":{"id":"MfsSRr","date":"1706022343","viewed":103,"name":"Drawing practice #1","username":"hasenpfote","description":"You can toggle the output using OUTPUT_MODE in the Image tab.\nAdjust the filter's application area by dragging the mouse.\nLeft side: Original image, Right side: Filtered image","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["kuwahara","edgedetection","crosshatch","drawing","npr","bilateral","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * In this pass, edge detection, crosshatching, and posterization to determine\n * the final colors.\n */\n\n/** 0 represents monochrome output, while 1 represents colored output. */\n#define OUTPUT_MODE 1\n\n#define ENABLE_EDGE\n#define ENABLE_CROSSHATCH\n#define ENABLE_POSTERIZATION\n\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//==============================================================================\n\nvec4 load_state(in int id){\n    return load_state(iChannel3, id);\n}\n\nvec3 fetch(in vec2 pos){\n    return texture(iChannel0, pos / iResolution.xy).rgb;\n}\n\n//==============================================================================\n\n#ifdef ENABLE_EDGE\nvec2 grad(in vec2 pos, in float delta){\n    // 2nd order central difference\n    vec2 d = vec2(delta, 0.);\n    return vec2(\n        fetch(pos + d.xy).r - fetch(pos - d.xy).r,\n        fetch(pos + d.yx).r - fetch(pos - d.yx).r\n    ) / (2. * delta);\n}\n\n/**\n *  The function examines whether there is a potential for lines to be drawn at\n *  the given point and emphasizes if necessary.\n */\nfloat edge(in vec2 pos){\n    const int num_intervals = 3;\n    const float range = 4.;\n    const float dn = 1. / float(num_intervals);\n    const float limit = 0.86602540; // cos(theta)\n    const float gain = 10.;\n\n    vec2 g0 = grad(pos, 0.5);\n    vec2 n0 = vec2(-g0.y, g0.x);\n    float l0 = length(n0);\n\n    if(l0 == 0.)\n        return 1.;\n\n    n0 /= l0;\n\n    float sum = l0;\n    vec4 delta = range * vec4(n0, -n0) * dn;\n    vec4 p = vec4(pos, pos);\n\n    for(int i = 1; i <= num_intervals; i++){\n        p += delta;\n\n        float attenuation = 1. - float(i) / float(num_intervals+1);\n        vec4 g = vec4(\n            grad(p.xy, 0.5),\n            grad(p.zw, 0.5)\n        );\n        vec2 d = vec2(\n            abs(dot(n0, vec2(-g.y, g.x))),\n            abs(dot(n0, vec2(-g.w, g.z)))\n        );\n        vec2 c = step(limit * vec2(length(g.xy), length(g.zw)), d);\n\n        sum += dot(d, c) * attenuation;\n    }\n\n    sum *= gain;\n\n    return 1. - tanh(0.5 * sum / float(2 * num_intervals)); // 0.5 = 1/sqrt(2)^2\n}\n#endif\n\n//==============================================================================\n\n#ifdef ENABLE_CROSSHATCH\nconst vec4 HATCH_WIDTH = vec4(1.5, 1.5, 1., 1.);\nconst vec4 HATCH_DENSITY = vec4(6., 6., 4., 4.);\nconst vec4 HATCH_THRESHOLD = vec4(0.6, 0.45, 0.3, 0.15);\nconst vec4 HATCH_STRENGTH = vec4(0.8, 0.65, 0.5, 0.35);\n\n/**\n * This function has been enhanced based on the concepts found in the following\n * article.\n *\n * glsl crosshatch\n * https://machinesdontcare.wordpress.com/2011/02/02/glsl-crosshatch/\n */\nfloat crosshatch(in vec2 pos, in float lightness){\n    vec4 density = vec4(\n        0.4 * pos.x + pos.y,\n        0.6 * pos.x - pos.y,\n        0.8 * pos.x + pos.y - (0.5*HATCH_DENSITY.z),\n        1.0 * pos.x - pos.y - (0.5*HATCH_DENSITY.w)\n    );\n    vec4 width = mod(density, HATCH_DENSITY);\n    vec4 cond = step(vec4(lightness), HATCH_THRESHOLD) * step(width, HATCH_WIDTH);\n    vec4 strength = mix(vec4(1.), HATCH_STRENGTH, cond);\n\n    vec2 min_strength = min(strength.xy, strength.zw);\n    return min(min_strength.x, min_strength.y);\n}\n#endif\n\n//==============================================================================\n\n#ifdef ENABLE_POSTERIZATION\nfloat posterize(in float x, in float levels){\n    float scaled = x * levels;\n    float lower = floor(scaled) / levels;\n    float upper = ceil(scaled) / levels;\n\n    return mix(lower, upper, step(upper - x, x - lower));\n}\n\n// https://www.shadertoy.com/view/dtXBzB\nvec3 kuwahara_filter(in vec2 pos, in int a){\n    int side_length = a + 1;\n    int num_samples = side_length * side_length;\n    vec2[4] origins = vec2[](\n        pos + vec2(0., 0.), // 1st quadrant\n        pos + vec2(-a, 0.), // 2nd quadrant\n        pos + vec2(-a, -a), // 3rd quadrant\n        pos + vec2(0., -a)  // 4th quadrant\n    );\n\n    mat4x3 colors;\n    mat4x3 sums = mat4x3(0.);\n    vec4 v_sum_sq = vec4(0.);\n    for(int i = 0; i < side_length; i++){\n        for(int j = 0; j < side_length; j++){\n            vec2 xy = vec2(j, i);\n            colors[0] = fetch(origins[0] + xy);\n            colors[1] = fetch(origins[1] + xy);\n            colors[2] = fetch(origins[2] + xy);\n            colors[3] = fetch(origins[3] + xy);\n            sums += colors;\n\n            vec4 _brightness = vec4(colors[0].r, colors[1].r, colors[2].r, colors[3].r);\n            v_sum_sq += _brightness * _brightness;\n        }\n    }\n\n    vec4 v_sum = vec4(sums[0].r, sums[1].r, sums[2].r, sums[3].r);\n    vec4 v_variance = v_sum_sq / float(num_samples) - (v_sum * v_sum) / float(num_samples * num_samples);\n\n    int index = v_variance[0] < v_variance[1] ? 0 : 1;\n    index = v_variance[index] < v_variance[2] ? index : 2;\n    index = v_variance[index] < v_variance[3] ? index : 3;\n\n    return sums[index].rgb / float(num_samples);\n}\n#endif\n\n//==============================================================================\n\n/**\n * Returns the weight of a separator at the specified position.\n */\nfloat vert_separator(in float pos, in float sep){\n    pos -= sep;\n    return pos * pos < 4. ? 0. : 1.;\n}\n\n#ifdef DEBUG_DISPLAY\nint text(in vec2 pos){\n    const float font_scale = 5.;\n\n    float short_side = iResolution.y;\n    vec2 c_size = text_size(short_side, font_scale);\n    vec2 c_spacing = text_spacing(short_side, font_scale);\n    vec2 uv = pos / short_side;\n    vec2 o = text_pos(vec2(0., 1.), c_size.y);\n    vec2 p = o;\n    int res = 0;\n\n#define CRLF text_newline(p, o.x, c_spacing.y)\n#define C(c) do{ res |= font_draw_char(c, p, c_size, uv); text_advance_to(p, c_spacing.x); }while(false)\n#define I(_x) res |= font_draw_decimal(_x, p, c_size, uv, 1)\n#define F(_x) res |= font_draw_decimal(_x, p, c_size, uv, 2)\n\n    // fps:F\n    C(102); C(112); C(115); C(58); F(iFrameRate); CRLF;\n\n    return res;\n\n#undef F\n#undef I\n#undef C\n#undef CRLF\n}\n#endif\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float vsep_pos = load_state(SID_SEPARATOR).x * iResolution.x;\n    vec3 lab;\n\n    if(fragCoord.x < vsep_pos){\n        lab = fetch(fragCoord);\n    }else{\n#if (OUTPUT_MODE == 0)\n        lab = linear_srgb_to_oklab(vec3(1.));\n#else\n#ifdef ENABLE_POSTERIZATION\n#if 0 // cheap reference\n        lab = fetch(fragCoord);\n        lab.r = posterize(lab.r, 8.);\n#else\n        lab = kuwahara_filter(fragCoord, 3);\n#endif\n#else\n        lab = fetch(fragCoord);\n#endif // ENABLE_POSTERIZATION\n#endif // OUTPUT_MODE\n#ifdef ENABLE_EDGE\n        lab.r *= edge(fragCoord);\n#endif // ENABLE_EDGE\n#ifdef ENABLE_CROSSHATCH\n        lab.r *= crosshatch(fragCoord, fetch(fragCoord).r);\n#endif // ENABLE_CROSSHATCH\n    }\n\n    vec3 color = oklab_to_linear_srgb(lab);\n\n    color *= vert_separator(fragCoord.x, vsep_pos);\n#ifdef DEBUG_DISPLAY\n    vec4 state_debug = load_state(SID_DEBUG);\n    if(state_debug.x > 0.){\n        int txt = text(fragCoord);\n        color = mix(color, vec3(0., 1., 0.), float(txt));\n    }\n#endif\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//#define DEBUG_DISPLAY\n\n#define SID_DEBUG     0\n#define SID_SEPARATOR 1\n\n//==============================================================================\n\n// https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v){\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 hash22(vec2 p){\n    uvec2 hash = pcg2d(uvec2(p));\n    return vec2(hash) * (1. / float(0xffffffffu));\n}\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n// Oklab\n// https://bottosson.github.io/posts/oklab/\n//==============================================================================\n\nvec3 linear_srgb_to_lms_prime(in vec3 rgb){\n    const mat3 m = mat3(\n        0.4122214708, 0.2119034982, 0.0883024619,\n        0.5363325363, 0.6806995451, 0.2817188376,\n        0.0514459929, 0.1073969566, 0.6299787005\n    );\n\n    vec3 lms = m * rgb;\n\n    return sign(lms) * pow(abs(lms), vec3(1./3.));\n}\n\nvec3 linear_srgb_to_oklab(in vec3 rgb){\n    const mat3 m = mat3(\n         0.2104542553,  1.9779984951,  0.0259040371,\n         0.7936177850, -2.4285922050,  0.7827717662,\n        -0.0040720468,  0.4505937099, -0.8086757660\n    );\n\n    vec3 lms_prime = linear_srgb_to_lms_prime(rgb);\n\n    return m * lms_prime;\n}\n\nvec3 lms_prime_to_linear_srgb(in vec3 lms_prime){\n    const mat3 m = mat3(\n         4.0767416621, -1.2684380046, -0.0041960863,\n        -3.3077115913,  2.6097574011, -0.7034186147,\n         0.2309699292, -0.3413193965,  1.7076147010\n    );\n\n    vec3 lms = lms_prime * lms_prime * lms_prime;\n\n    return m * lms;\n}\n\nvec3 oklab_to_linear_srgb(in vec3 lab){\n    const mat3 m = mat3(\n        1.,            1.,            1.,\n        0.3963377774, -0.1055613458, -0.0894841775,\n        0.2158037573, -0.0638541728, -1.2914855480\n    );\n\n    vec3 lms_prime = m * lab;\n\n    return lms_prime_to_linear_srgb(lms_prime);\n}\n\n//==============================================================================\n// State buffer\n//==============================================================================\n\nconst ivec2 STATE_BUFFER_SIZE = ivec2(128);\n\nvec4 load_state(in sampler2D sampler, in int id){\n    ivec2 pos = ivec2(id % STATE_BUFFER_SIZE.x, id / STATE_BUFFER_SIZE.y);\n    return texelFetch(sampler, pos, 0);\n}\n\nint pos_to_sid(in ivec2 pos){\n    int factor = 1 - 2 * int(any(greaterThanEqual(pos, STATE_BUFFER_SIZE)));\n    return (pos.y * STATE_BUFFER_SIZE.x + pos.x) * factor;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return id == pos_to_sid(pos);\n}\n\n//==============================================================================\n\n#ifdef DEBUG_DISPLAY\n//\n// This font is based on the following work:\n// [Simple Bitmap Text - integers - iq] https://www.shadertoy.com/view/4s3fzl\n//\n\n/**\n * The data is based on the following 4x6 font.\n * http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n */\nconst int[95] FONT_DATA = int[](\n    0x000000, // \n    0x222020, // !\n    0x550000, // \"\n    0x575750, // #\n    0x236362, // $\n    0x412410, // %\n    0x253570, // &\n    0x640000, // '\n    0x244420, // (\n    0x422240, // )\n    0x527250, // *\n    0x027200, // +\n    0x000064, // ,\n    0x007000, // -\n    0x000020, // .\n    0x112440, // /\n    0x355560, // 0\n    0x262270, // 1\n    0x612470, // 2\n    0x612160, // 3\n    0x157110, // 4\n    0x746160, // 5\n    0x246520, // 6\n    0x713220, // 7\n    0x252520, // 8\n    0x253120, // 9\n    0x002020, // :\n    0x002064, // ;\n    0x124210, // <\n    0x007070, // =\n    0x421240, // >\n    0x612020, // ?\n    0x755470, // @\n    0x257550, // A\n    0x656560, // B\n    0x344430, // C\n    0x655560, // D\n    0x746470, // E\n    0x746440, // F\n    0x345530, // G\n    0x557550, // H\n    0x722270, // I\n    0x111520, // J\n    0x556550, // K\n    0x444470, // L\n    0x577550, // M\n    0x575550, // N\n    0x255520, // O\n    0x656440, // P\n    0x255730, // Q\n    0x656550, // R\n    0x347160, // S\n    0x722220, // T\n    0x555570, // U\n    0x555520, // V\n    0x557750, // W\n    0x552550, // X\n    0x552220, // Y\n    0x712470, // Z\n    0x644460, // [\n    0x442110, // back slash\n    0x622260, // ]\n    0x250000, // ^\n    0x00000F, // _\n    0x620000, // `\n    0x003570, // a\n    0x446560, // b\n    0x003430, // c\n    0x113530, // d\n    0x007630, // e\n    0x127220, // f\n    0x007517, // g\n    0x446550, // h\n    0x202220, // i\n    0x202226, // j\n    0x445650, // k\n    0x222220, // l\n    0x007750, // m\n    0x006550, // n\n    0x002520, // o\n    0x006564, // p\n    0x003531, // q\n    0x006440, // r\n    0x003260, // s\n    0x027230, // t\n    0x005570, // u\n    0x005520, // v\n    0x005770, // w\n    0x005250, // x\n    0x005524, // y\n    0x006230, // z\n    0x326230, // {\n    0x222220, // |\n    0x623260, // }\n    0x5A0000  // ~\n);\n\nconst ivec2 FONT_CELL_SIZE = ivec2(4, 6);\n\nconst int FONT_MAX_INT_DIGITS = 4; // Configure the integer maximum digit count from 1 to 10.\nconst int FONT_MAX_INT_PLACE = 1000; // 10^{MAX_INT_DIGITS-1}\n\nint font_draw_char(in int ascii, in vec2 pos, in vec2 size, in vec2 uv){\n    ascii -= 32;\n    if(ascii < 0 || ascii > 94)\n        return 0;\n\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv -= pos;\n\n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;\n\n    // Multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= vec2(FONT_CELL_SIZE);\n\n    // Compute bitmap texel coordinates\n    ivec2 iuv = ivec2(round(uv));\n\n\t// Bounding box check. With branches, so we avoid the maths and lookups    \n    if(iuv.x < 0 || iuv.x >= FONT_CELL_SIZE.x || iuv.y < 0 || iuv.y >= FONT_CELL_SIZE.y)\n        return 0;\n\n    // Compute bit index\n    iuv.x = FONT_CELL_SIZE.x - 1 - iuv.x;\n    int index = FONT_CELL_SIZE.x * iuv.y + iuv.x;\n\n    // Get the appropriate bit and return it.\n    return (FONT_DATA[ascii] >> index) & 0x1;\n}\n\nint font_draw_decimal(in uint x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    uint place = uint(FONT_MAX_INT_PLACE);\n    float spacing = 1.25 * size.x; // 1.25 = (MAP_SIZE.x+1) / MAP_SIZE.x\n\n    for(int i = FONT_MAX_INT_DIGITS - 1; i >= 0; i--){\n        uint quotient = x / place;\n        if(quotient > 0u || i < min_digits){\n            uint digit = quotient % 10u;\n            res |= font_draw_char(int(48u + digit), pos, size, uv);\n            pos.x += spacing;\n        }\n        place /= 10u;\n    }\n\n    return res;\n}\n\nint font_draw_decimal(in int x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n\n    if(x < 0){\n        res |= font_draw_char(45, pos, size, uv);\n        x = -x;\n        pos.x += 1.25 * size.x;\n    }\n\n    res |= font_draw_decimal(uint(x), pos, size, uv, min_digits);\n\n    return res;\n}\n\nint font_draw_decimal(in float x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    float spacing = 1.25 * size.x;\n\n    if(x < 0.){\n        res |= font_draw_char(45, pos, size, uv);\n        x = -x;\n        pos.x += spacing;\n    }\n\n    float fx, ix;\n    fx = modf(x, ix);\n\n    res |= font_draw_decimal(uint(ix), pos, size, uv, 1);\n\n    res |= font_draw_char(46, pos, size, uv);\n    pos.x += spacing;\n\n    res |= font_draw_decimal(uint(pow(10., float(min_digits)) * fx), pos, size, uv, min_digits);\n\n    return res;\n}\n\nvec2 text_size(in float base_dim, in float fs){\n    return fs * vec2(FONT_CELL_SIZE) / base_dim;\n}\n\nvec2 text_spacing(in float base_dim, in float fs){\n    return fs * vec2(FONT_CELL_SIZE + 1) / base_dim;\n}\n\nvec2 text_pos(in vec2 p, in float s){\n    p.y -= s;\n    return p;\n}\n\nvoid text_advance_to(inout vec2 p, in float spacing){\n    p.x += spacing;\n}\n\nvoid text_newline(inout vec2 p, in float left, in float spacing){\n    p.x = left;\n    p.y -= spacing;\n}\n#endif // DEBUG_DISPLAY\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_F1     112\n#define KEY_COMMA  188\n#define KEY_PERIOD 190\n\nvec4 load_state(in int id){\n    return load_state(iChannel0, id);\n}\n\nbool is_mouse_down(){\n    return iMouse.z > 0.;\n}\n\nbool is_key_pressed(int code){\n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 pos = ivec2(fragCoord);\n    vec4 state;\n\n    if(can_store_state(SID_DEBUG, pos)){\n        state = load_state(SID_DEBUG);\n        if(iFrame > 0){\n            if(is_key_pressed(KEY_F1)){\n                state.x = float(!bool(state.x));\n            }\n        }else{\n            state = vec4(1.);\n        }\n    }else if(can_store_state(SID_SEPARATOR, pos)){\n        state = load_state(SID_SEPARATOR);\n        if(iFrame > 0){\n            if(is_mouse_down()){\n                state.x = iMouse.x / iResolution.x;\n            }\n        }else{\n            state = vec4(0.5, 0., 0., 0.);\n        }\n    }else{\n        discard;\n    }\n\n    fragColor = state;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * In this pass, noise reduction is applied. The output is in the Oklab color\n * space.\n */\n\n#define USE_LUT\n\n/** Radius of the gaussian kernel. */\nconst int KERNEL_RADIUS = 2;\n\n/** Standard deviation for the domain kernel. */\nconst float SIGMA_D = 10.;\n\n/** Standard deviation for the range kernel. */\nconst float SIGMA_R = 0.1;\n\n//==============================================================================\n\nvec3 fetch(in vec2 pos){\n    return srgb_to_linear(texture(iChannel0, pos / iResolution.xy).rgb);\n}\n\n//==============================================================================\n\nfloat weight(in vec2 x, in vec3 intensity){\n#ifdef USE_LUT\n    return exp(- 0.5 * (x.x + x.y + dot(intensity, intensity)/(SIGMA_R*SIGMA_R)));\n#else\n    return exp(- 0.5 * (dot(x,x)/(SIGMA_D*SIGMA_D) + dot(intensity, intensity)/(SIGMA_R*SIGMA_R)));\n#endif\n}\n\n// https://en.wikipedia.org/wiki/Bilateral_filter\nvec3 bilateral_filter(in vec2 pos){\n#ifdef USE_LUT\n    const float vd = SIGMA_D * SIGMA_D;\n    float lut[KERNEL_RADIUS + 1];\n\n    for(int i = 0; i <= KERNEL_RADIUS; i++){\n        lut[i] = float(i*i) / vd;\n    }\n#endif\n\n    vec4 sum = vec4(0.);\n    vec3 c0 = fetch(pos);\n\n    for(int i = -KERNEL_RADIUS; i <= KERNEL_RADIUS; i++){\n#ifdef USE_LUT\n        float y_d = lut[abs(i)];\n#endif\n        for(int j = -KERNEL_RADIUS; j <= KERNEL_RADIUS; j++){\n            vec2 offset = vec2(i, j);\n            vec3 c = fetch(pos + offset);\n            vec3 intensity = c - c0;\n#ifdef USE_LUT\n            float w = weight(vec2(lut[abs(j)], y_d), intensity);\n#else\n            float w = weight(offset, intensity);\n#endif\n            sum.rgb += w * c;\n            sum.a += w;\n        }\n    }\n\n#undef USE_LUT\n\n    return sum.rgb / sum.a;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = bilateral_filter(fragCoord);\n\n    fragColor = vec4(linear_srgb_to_oklab(color), 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}