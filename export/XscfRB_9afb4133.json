{"ver":"0.1","info":{"id":"XscfRB","date":"1525608464","viewed":188,"name":"Sierpinski triangle fractal","username":"akhgary","description":"my first practice on frame buffer object and feedback loop.\n\nbuffer A aggregates all points by fetching points from buffer B\n\ndoes any one know how to resize produced image as the view port size changes?\n\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal","triangle","buffer","fbo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sierpinski triangle\n// https://en.wikipedia.org/wiki/Sierpinski_triangle\n\n// Numberphile video\n// https://www.youtube.com/watch?v=kbKtFN71Lfs\n\n// random number generator\n// https://stackoverflow.com/a/4275343/4767498\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 oldRes = texelFetch(iChannel1, ivec2(0,1), 0).xy;\n    vec3 fb = oldRes!=iResolution.xy \n        \t? vec3(0)\n        \t: texelFetch(iChannel0, ivec2(fragCoord), 0).xyz; // frame buffer\n    \n    float points = 0.;\n    \n    for(int i=0; i<int(iResolution.x/10.); i++){\n        vec4 m = texelFetch(iChannel1, ivec2(i,0), 0); // fetch points from first row\n        \n        points += 1.-smoothstep(.0,2./iResolution.y, length(uv-m.xy)-1e-3);\n        points += 1.-smoothstep(.0,2./iResolution.y, length(uv-m.zw)-1e-3);\n    }\n    \n    \n    fragColor = vec4(clamp(fb+points,0.,1.),1.); // feedback loop\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// first row of this buffer contains data points. rest is black.\n// each fragment color contains two points to fill the pattern faster.\n\nfloat rand(vec2 co, float seed){\n    return fract(sin(dot(co.xy*seed,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y>0.5) \n    {\n        fragColor.xy = iResolution.xy; // store resolution\n        return; // dont waste power\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // fetch previous points\n    vec4 p = texelFetch(iChannel0, ivec2(fragCoord), 0); \n       \n    float dice1 = rand(uv,iTime); // two rolling dices\n    float dice2 = rand(uv,dice1); // twice the speed!\n    \n    // choose destination points\n    vec4 d = vec4(dice1 < 1./3. ? A : dice1 < 2./3. ? B : C,\n                  dice2 < 1./3. ? A : dice2 < 2./3. ? B : C);\n    \n    fragColor = (p+d)/2.; // calculate mid points and store the results.\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// coordinates of the sierpinski triangle\nvec2 A = vec2(0,1), B = vec2(-1), C = vec2(1,-1);\n","name":"Common","description":"","type":"common"}]}