{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float PI=3.14159;\nconst float speed=0.0005;\n\nconst float smple=30.; // You should be able to increase both those value quite significantly\nconst float points=4.;  // but it appears to break randomly on some GPUs.\n\nvec2 uv;\n\n// Order n bezier curve\nstruct Bez{\n\tvec2 p[int(points)];\n};\n\nvec2 sstep(vec2 x){\n\treturn smoothstep(0.,1.,fract(x))+floor(x);\n}\n\t\n// Get noise value from vector\nfloat hash(vec2 v){\n\tv=fract(v);\n\tv=(sstep(v*64.)+0.5)/64.;\n\treturn texture(iChannel0,v).r;\n}\n\t\n// Get noise value from f in [0,1]\nfloat hash(float f){\n\tf=fract(f);\n\tfloat r = iChannelResolution[0].y;\n\tfloat x = fract(f*r);\n\tfloat y = f-x;\n\treturn hash(vec2(x,y));\n}\n\n// Distance/closest point from a segment\nvec2 linep(vec2 a, vec2 b){\n\ta-=uv,\n\tb-=uv;\n\tvec2 dir = normalize(b-a);\n\tvec2 p = a+dir*clamp(dot(-a,dir),0.,length(b-a));\n\treturn p;\n\t\t\n}\nvec2 linep(vec4 s){ return linep(s.xy,s.zw);}\nfloat line(vec2 a, vec2 b){return length(linep(a,b));}\nfloat line(vec4 s){ return line(s.xy,s.zw);}\n\n// Dotted line. Terrible, terrible code, for your own sake don't look.\nfloat dotline(vec2 a, vec2 b){\n\ta-=uv,\n\tb-=uv;\n\tvec2 dir = normalize(b-a);\n\t\n\tfloat x = dot(-a,dir);\n\t\n\tfloat dv=40.;\n\tfloat stretch = 0.5; // (0=circle dot , 1=line)\n\t\n\tfloat md=fract(iTime*-1.);\n\t\n\tx+=md/dv;\n\t\n\tfloat ix=floor(x*dv+0.5)/dv;\n\tfloat fx=fract(x*dv+0.5)-0.5;\n\t\n\tfx=clamp(fx,-stretch/2.,stretch/2.);\n\tx=clamp(ix+fx/dv-md/dv,0.,length(b-a));\n\tvec2 p = a+dir*x;\n\t\n\treturn length(p);\n}\n\t\n\n// Bezier curve point with d in [0,1]\nvec2 bezred(Bez b, float d){\n\tfor(int x=int(points) ; x>1 ; x--){\n\t\tfor(int i=0 ; i<=int(points) ; i++){\n\t\t\tif(i+1>=x) break;\n\t\t\tb.p[i]=mix(b.p[i],b.p[i+1],d);\n\t\t}\n\t}\n\treturn b.p[0];\n}\n\n// closest Bezier control points\nvec2 bezierp(Bez b){\n\tvec2 r;\n\tfloat d=-1.;\n\tfor(int i=0 ; i<int(points) ; i++){\n\t\tif(d==-1.||d>length(b.p[i]-uv)){\n\t\t\td=length(b.p[i]-uv);\n\t\t\tr=b.p[i]-uv;\n\t\t}\n\t}\n\treturn r;\n}\n\n// Closest distance from Bezier curve\nvec2 bezier(Bez b){\n\t\n\tvec4 l=vec4(b.p[0],vec2(0.));\n\tfloat dist=-1.;\n\tfloat d=0.;\n\tvec2 p;\n\t\n\tfor(float i=1. ; i<=smple ; i++){\n\t\t\n\t\td=i/smple;\n\t\t\n\t\tl.zw=bezred(b,d);\n\t\tif(dist<0.){\n\t\t\tp=linep(l);\n\t\t\tdist=length(p);\n\t\t}else{\n\t\t\tvec2 t=linep(l);\n\t\t\tif(dist>length(t)){\n\t\t\t\tdist=length(t);\n\t\t\t\tp=t;\n\t\t\t}\n\t\t}\n\t\tl.xy=l.zw;\n\t}\n\treturn p;\n}\nfloat bezierd(Bez b){ return length(bezier(b));}\n\n// Randomish bezier generation\nBez beziergen(){\n\tBez b;\n    float stime = sin(speed*iTime/PI)/2.+0.5;\n\tfloat vd=points;\n\tfor(float i=0. ; i<points ; i++){\n\t\tb.p[int(i)]=vec2(hash(stime+i/vd),hash(stime+(i+0.5)/vd))*2.-1.;\n\t}\n\treturn b;\n}\n\n// Basically the bezier distance again\nfloat heightmap(){\n\treturn bezierd(beziergen());\n}\n\n// Normalmap calculation. Horrible and extremely inefficient as well, because I set uv as global...\nvec3 normalmap(){\n\tvec2 buv=uv;\n\tfloat eps=0.005;\n\tvec4 hs;\n\t\n\tuv=buv+eps*vec2(-1.,-1.);\n\ths[0]=heightmap();\n\tuv=buv+eps*vec2( 1.,-1.);\n\ths[1]=heightmap();\n\tuv=buv+eps*vec2(-1., 1.);\n\ths[2]=heightmap();\n\tuv=buv+eps*vec2( 1., 1.);\n\ths[3]=heightmap();\n\tuv=buv;\n\t\n\tfloat slopex=((hs[1]+hs[3])/2.-(hs[0]+hs[2])/2.);\n\tfloat slopey=((hs[2]+hs[3])/2.-(hs[0]+hs[1])/2.);\n\n\treturn normalize(vec3(slopex,slopey,2.*eps));\n}\n\n// Color from pixel location\nvec3 shade(){\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n\tvec3 color;\n\tvec3 nm=normalmap();\n\t\n\tfloat d = heightmap();\n\t\n\tfloat lum=dot(nm,normalize(vec3(0.4)));\n\t\n\t\n\tlum = mix(lum,1.,0.8);\n\t\n\tcolor=nm/2.+0.5;\n\t\n\tcolor *= vec3(smoothstep(0.005,0.01,d));\n\tcolor += sin(d*200.)*0.01;\n\t\n\tvec2 bp=bezierp(beziergen());\n\t\n\tbp=abs(bp);\n\tvec2 bpx = vec2(bp.x,max(0.,bp.y-0.025));\n\tvec2 bpy = vec2(max(0.,bp.x-0.025),bp.y);\n\t\n\t//float bd = sqrt(bp.x)+sqrt(bp.y);\n\t\n\tfloat bd = min(length(bpx),length(bpy));\n\t\n\tcolor = abs(color-smoothstep(0.01,0.005,bd));\n\t\n\tvec2 buv=uv;\n\tuv=mouse;\n\tvec2 mp=bezier(beziergen())+uv;\n\tuv=buv;\n\tfloat md=dotline(mouse,mp);\n\t\n\tcolor *= smoothstep(0.003,0.006,md);\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssXWn","date":"1399141313","viewed":995,"name":"Bezier distance","username":"cafe","description":"A bunch of that code is probably terribly slow, I'd love any pointer to optimize it!\n\nAlso I have absolutely no idea if it's possible to determine the distance analytically, I'm totally bruteforcing it.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["distancefromanyorderbeziercurve"],"hasliked":0,"parentid":"","parentname":""}}