{"ver":"0.1","info":{"id":"7dlBD4","date":"1644895135","viewed":124,"name":"heart noise","username":"jorge2017a2","description":"heart noise","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["heartnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//iq\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec3 corazonIIa(vec2 p, vec3 colObj, vec3 colOut)\n{   float d1= sdHeart(p-vec2(0.0,0.5) );\n    colOut= DrawFigSolo(colObj, colOut,d1);\n    return colOut;\n}\n\nvec3 corazonIIb(vec2 p, vec3 colObj, vec3 colOut)\n{   float d1= sdHeart(p-vec2(0.0,0.5) );\n    colOut= DrawFigBorde(colObj, colOut,d1);\n    return colOut;\n}\n\nvec3 todoCorazon(vec2 uv, vec2 pt, vec3 col)\n{   vec2 uv0a=uv-vec2(0.5,0.25)+pt;\n    uv+=pt;\n    vec2 uv2=uv-vec2(-0.7,-1.7);\n    vec2 uv0b=uv-vec2(-0.7,-1.9);\n    uv.y= opRep1D( uv.y, 3.5 );\n    uv.x= opRep1D( uv.x, 1.5 );\n    \n    uv2.y= opRep1D( uv2.y, 3.5 );\n    uv2.x= opRep1D( uv2.x, 1.5 );\n    \n    uv0a.y= opRep1D( uv0a.y, 3.5 );\n    uv0a.x= opRep1D( uv0a.x, 1.5 );\n    \n    uv0b.y= opRep1D( uv0b.y, 3.5 );\n    uv0b.x= opRep1D( uv0b.x, 1.5 );\n \n    col= corazonIIa(uv0a,vec3(0.5,.2,0.3), col);\n    col= corazonIIa(uv0b,vec3(0.25,.2,0.3), col);\n    col= corazonIIb(uv,vec3(0.8,.2,0.3), col);\n    col= corazonIIb(uv2,vec3(1.0,.0,0.0), col);\n    return col;\n}    \n\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nvec2 noise(float x) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return  vec2( hash(i), hash(i + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=2.0;\n    uv*=esc;\n    \n    vec2 n1=noise(uv.x+uv.y);\n    vec3 col=mix( vec3(1.0),vec3(0.0),n1.x);\n    col=mix( vec3(0.0),vec3(1.0),n1.y)*uv.y;\n    vec2 pta=vec2(iTime);\n    vec2 ptb=vec2(-iTime,iTime)-vec2(0.0,1.0);\n    col= todoCorazon(uv, pta, col);\n    col= todoCorazon(uv, ptb, col)*(1.25-n1.y);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//modificado por jorge2017a2\n///referencia FMS-Cat\n\n#define TRANSPOSE 2.0\n#define bpm 160.0\n#define BPM 160.0  \n#define AMEN_BPM 170.0\n\n#define aSaturate(i) clamp(i, -1.,1.)\n#define saturate(i) clamp(i, 0.,1.)\n#define clip(i) clamp(i, -1.,1.)\n#define beat 60.0/BPM\n#define linearstep(a,b,x) saturate(((x)-(a))/((b)-(a)))\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define tri(p) (1.-4.*abs(fract(p)-0.5))\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define n2f(n) (440.0*pow(2.0,((n)+TRANSPOSE)/12.0))\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nvec2 noise(float x) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return  vec2( hash(i), hash(i + 1.0));\n}\n\n\nfloat kick( float t ) {\n  if ( t < 0.0 ) { return 0.0; }\n\n  float attack = 4.0;\n  float lorate = 0.06;\n\n  return clip( 10.0 * exp( -4.0 * t ) * sin( TAU * lofi(\n    52.0 * t - attack * ( exp( -40.0 * t ) + exp( -200.0 * t ) ),\n    lorate\n  ) ) );\n}\n\n\n\nvec2 rimshot( float t ) {\n  if ( t < 0.0 ) { return vec2( 0.0 ); }\n\n  float attack = exp( -t * 1000.0 ) * 0.2;\n  vec2 wave = (\n    tri( t * 450.0 * vec2( 1.005, 0.995 ) - attack ) +\n    tri( t * 1800.0 * vec2( 0.995, 1.005 ) - attack )\n  );\n  return clip( 4.0 * wave * exp( -t * 400.0 ) );\n}\n\nfloat kickfreq( float t, float freq ) \n{\n  if ( t < 0.0 ) { return 0.0; }\n\n  float attack = 8.0;\n  float lorate = 0.12;\n\n  return aSaturate( 6.0 * exp( -4.0 * t ) * sin( TAU * lofi(\n    freq * t - attack * ( exp( -40.0 * t ) + exp( -200.0 * t ) ),\n    lorate\n  ) ) );\n}\n\n\nvec2 snare( float t )\n{\n  if ( t < 0.0 ) { return vec2( 0.0 ); }\n  return aSaturate( (\n    noise( t ).xy * 2.0 +\n    sin( t * 1400.0 * vec2( 1.005, 0.995 ) - exp( -t * 80.0 ) * 30.0 )\n  ) * 2.0 * exp( -t * 10.0 ) );\n}\n\nvec2 mainSound( int samp, float time )\n{ vec2 dest = vec2( 0.0 );\n    \n    float time0=mod(time-5.,12.);\n\tdest+= vec2( fract(sin(6.2831*440.0*time0)*100.)*exp(-1.0*time0))*min(1.,time0);\n    \n    float t1=time;\n    float t=mod(t1, 2.0);\n    float k1=kick(t);\n    dest+=k1;\n    float t2=mod(time,0.5);\n    float t3=mod(time,0.25);\n \n    vec2 s1= snare( t2);\n    dest+=s1;\n     \n     \n  float kickTime = mod( t1, 1.0*beat );\n  float sidechain = linearstep( 0.0, 0.6 *beat, kickTime );\n    dest += 0.5 * kickfreq( kickTime, n2f( -36.0 ) );\n    dest += 0.5 * kickfreq( t3, n2f( -22.0 ) );\n  \n    return vec2(dest*0.5);\n}","name":"Sound","description":"","type":"sound"}]}