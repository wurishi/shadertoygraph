{"ver":"0.1","info":{"id":"7dKXWR","date":"1634494155","viewed":1286,"name":"Tiny Planet [425 Chars]","username":"Xor","description":"[url=https://t.co/cMXzKKi83W]Twigl version[/url] is only 273 chars!\nThis version is a bit longer because of the lack of rotate3D and snoise3D.","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["golf","twigl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TWIGL: https://bit.ly/3phgg37\n//<512 Chars playlist: shadertoy.com/playlist/N3SyzR\n\n//Sample noise from volume texture:\n#define N(p) (texture(iChannel0,(p)/18.).r*2.-1.)\n#define A(p) (mix( x*dot(p,x), p, cos(t) ) + sin(t) *cross(p,x))\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O -= O;\n    float s = 3.,//Raymarch step size\n    i = 0.,//Loop iteration\n    r,//Radius from planet center (used for rings)\n    t = iTime*.3+.7;//Time variable for rotation\n    \n    vec3 p,//Raymarch sample point's position\n    q,//Rotated position\n    R = iResolution,//Resolution variable\n    d = normalize(vec3(I+I-R.xy, -R)),\n    x = vec3(.32,.95,0);//Raymarch direction\n    \n    //Raymarch loop (3e1 steps and min step size of 1e-3):\n    for(p.z=s; i++<3e1&&s>1e-3; p+=d*s)\n    //Update the SDF at the new sample point:\n    s = min(max(abs(r=length(q=A(p))-1.)-.2, //Ring radius (a hollow sphere)\n    abs(q.y)+N(q+r*3e1)/2e2),//Ring width with some noise\n    r+.4)//Planet sphere\n    +N(q/.2)*N(q/.04)/3e2,//Add some noise to the whole SDF\n    \n    //Add sample brightness based on step size and direction for color:\n    O.rgb += max((1.-d)/2e2/(.1+s),\n    N(A(d)/.01)-1.1+i/9e1);//Stars as a simple noise function with occlusion.\n}\n\n/*\n//490 char original:\n\n//Sample noise from volume texture:\n#define N(p) (texture(iChannel0,(p)/18.).r*2.-1.)\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    O -= O;\n    float s = 3.,//Raymarch step size\n    i = 0.,//Loop iteration\n    r;//Radius from planet center (used for rings)\n    \n    //A simplified version of rotate3D:\n    vec4 a = vec4(.32,.95,0,1),\n    t = sin(iTime*.3+.7+vec4(0,2,1,3)*1.57);\n    mat3 A = mat3(\n        a.xyz * a.x * ++t.w + a.wzy*t.zxy,\n        a.xyz * a.y * t.w + a.zwx*t.yzx,\n        a.xyz * a.z * t.w + a.yxw*t.xyz);\n    \n    vec3 p,//Raymarch sample point's position\n    q,//Rotated position\n    R = iResolution,//Resolution variable\n    d = normalize(vec3(I+I-R.xy, -R));//Raymarch direction\n    \n    //Raymarch loop (3e1 steps and min step size of 1e-3):\n    for(p.z=s; i++<3e1&&s>1e-3; p+=d*s)\n    //Update the SDF at the new sample point:\n    s = min(max(abs(r=length(q=p*A)-1.)-.2, //Ring radius (a hollow sphere)\n    abs(q.y)+N(q+r*3e1)/2e2),//Ring width with some noise\n    r+.4)//Planet sphere\n    +N(q/.2)*N(q/.04)/3e2,//Add some noise to the whole SDF\n    \n    //Add sample brightness based on step size and direction for color:\n    O.rgb += max((1.-d)/2e2/(.1+s),\n    N(d*A/.01)-1.1+i/9e1);//Stars as a simple noise function with occlusion.\n}\n*/","name":"Image","description":"","type":"image"}]}