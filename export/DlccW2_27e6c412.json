{"ver":"0.1","info":{"id":"DlccW2","date":"1699633582","viewed":27,"name":"TP Informatique graphique M1","username":"TheOddlySeagull","description":"Shadertoy TP Informatique graphique et image (LIF02)\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#iChannel0 \"texture.png\" //- VS code extension, custom texture. A placeholder texture is used here due to Shadertoy not allowing me to import my own texture.\n\n/*\nMaterial 0: Checkboard\nMaterial 1: Red\nMaterial 2: iChannel0 texture (not in shadertoy, a placeholder texture is used instead)\nMaterial 3: Blue\nMaterial 4: Mirror (if used on a rotated object, the normal will need to be rotated too with the opposite angle)\nMaterial 5: 3D Checkerboard (do not use if a flat side is alligned with a change (whole number+0.0001))\n*/\n\n//############################################################################################################\n// Globals\n//############################################################################################################\n\n// Rendering\n// Global variable to toggle normal visualization\nbool visualizeNormals = false;\nbool enable_daynight = false;\nconst float PI = 3.1415926535897932384626433832795;\n\n//Ambient occlusion\nint nbIntersectAmbiantOcclusion=8; // Number of samples, 0 to disable\nfloat distanceAmbiantOcclusion=0.5; // Max distance to consider an intersection\n\n//Soft shadow (heavy on performance), use multiple light source\nvec3 nbLightSource = vec3(4,4,2); // nuber of light source in each direction\nfloat step = 0.01; // step between each light source\n\n//############################################################################################################\n// Shapes structures\n//############################################################################################################\n\n// Sphere:\nstruct Sphere{\n    vec3 center;// Center\n    float radius;// Radius\n    int texture_id;// Texture Id\n    };\n\n// Plane:\n/*\n    Provided in base code\n*/\nstruct Plane{\n    vec3 normal;// Normal\n    vec3 point;// Point\n    int texture_id;// Texture Id\n};\n\n// Cylinder:\nstruct Cylinder {\n    vec3 center;    // Center\n    float radius;   // Radius\n    float height;   // Height\n    int texture_id;     // Texture Id\n};\n\n\n// Capsule:\n/*\n    Provided by Alexandre\n*/\nstruct Capsule{\n    vec3 center;    // Center\n    float radius;   // Radius\n    float height;   // Height\n    int texture_id;     // Texture Id\n};\n\n\n// Cube:\nstruct Cube {\n    vec3 center;    // Center of the cube\n    vec3 half_size;    // Scale (half-size) of the cube (width, height, depth)\n    int texture_id;     // Texture Id\n    };\n\n\n// Ellipsoid:\nstruct Ellipsoid {\n    vec3 center;    // Center of the ellipsoid\n    vec3 half_radius;    // Radii (half-size) of the ellipsoid (x, y, z)\n    int texture_id;     // Texture Id\n};\n\n\n// Torus:\nstruct Torus {\n    vec3 center;    // Center of the torus\n    float major_radius;   // Major radius (from center to the center of the tube)\n    float tube_radius;   // Tube radius\n    int texture_id;     // Texture Id\n};\n\n\n//############################################################################################################\n// Materials\n//############################################################################################################\n\n//This structure is used to store the material information\nstruct Material\n{\n    vec3 diffuse;// Diffuse\n};\n\n\n//This function is used to create a material that looks like a checkerboard\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n//This function is used to create a material that looks like a 3D checkerboard\nbool Checkers3D(in vec3 p)\n{\n    bool inside = false;\n    //Damier volumique paramétré par la taille du côté\n    if (mod(floor(p.x+0.0001),2.)==0.)\n    {\n        inside = !inside;\n    }\n    if (mod(floor(p.y+0.0001),2.)==0.)\n    {\n        inside = !inside;\n    }\n    if (mod(floor(p.z+0.0001),2.)==0.)\n    {\n        inside = !inside;\n    }\n    return inside;\n}\n\n//This function returns the material properties (color) at a given 3D point p with the specified texture index i.\n\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Material(vec3(.9,.0,.0));\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col);\n    }\n    else if(i==2)\n    {\n        // import png\n        vec3 col=texture(iChannel0,p.xy*0.1).rgb;\n        return Material(col);\n    }\n    else if (i == 3) {\n        return Material(vec3(0.0, 0.0, 1.0));\n    }\n    //4 is mirror\n    else if (i == 4) {\n        // should not happen exept if mirrorTry reach maxMirrorTry\n        return Material(vec3(0.0));\n        \n    }\n    else if (i == 5) {\n        // compute checkboard\n        bool f = Checkers3D(p);\n        vec3 col = vec3(.4, .5, .7) + float(f) * vec3(.1);\n        return Material(col);\n\n    }\n    return Material(vec3(0));\n\n}\n\n//############################################################################################################\n// Intersection elements\n//############################################################################################################\n\n// Hit:\n//This structure is used to store the intersection information\nstruct Hit{\n    float depth;// Intersection depth\n    vec3 normal;// Normal\n    int texture_id;// Texture Id\n};\n\n// Ray:\n//This structure is used to store the ray information\nstruct Ray {\n    vec3 origin; // Origin\n    vec3 direction; // Direction\n};\n\n\n\n\n//This function is used to compute the point on the ray at a given depth\nvec3 Point(Ray ray,float t)\n{\n    return ray.origin+t*ray.direction;\n}\n\n//This function is used to compute the ray at a given point\nfloat Distance(vec3 a, vec3 b) {\n    float dx = a.x - b.x;\n    float dy = a.y - b.y;\n    float dz = a.z - b.z;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\n//############################################################################################################\n// Shape Intersection functions\n//############################################################################################################\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.origin-sph.center;\n    float b=dot(oc,ray.direction);\n    float c=dot(oc,oc)-sph.radius*sph.radius;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.center),sph.texture_id);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane plane,out Hit hit)\n{  \n    float d=dot(plane.normal,ray.direction);\n    if(d!=0.)\n    {\n        float t=dot(plane.point-ray.origin,plane.normal)/d;\n        if(t>0.)\n        {\n            hit=Hit(t,plane.normal,plane.texture_id);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x)\n{\n    // Transform the ray into the local cylinder space\n    vec3 ro = (ray.origin - cyl.center) / vec3(cyl.radius, cyl.radius, cyl.height);\n    vec3 rd = ray.direction / vec3(cyl.radius, cyl.radius, cyl.height);\n\n    // Solve the quadratic equation for the cylinder intersection\n    float a = rd.x * rd.x + rd.y * rd.y;\n    float b = 2.0 * (ro.x * rd.x + ro.y * rd.y);\n    float c = ro.x * ro.x + ro.y * ro.y - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Check intersection with the sides\n        float t = min(t1, t2);\n        vec3 intersectionPoint = ro + t * rd;\n\n        if (t > 0.0 && abs(intersectionPoint.z) <= 1.0) {\n            vec3 normal = normalize(vec3(intersectionPoint.x, intersectionPoint.y, 0.0));\n            int textureId = cyl.texture_id;\n            x = Hit(t, normal, textureId);\n            return true;\n        }\n\n        // Check intersection with the top cap\n        t = (1.0 - ro.z) / rd.z;\n        intersectionPoint = ro + t * rd;\n        if (t > 0.0 && length(intersectionPoint.xy) <= 1.0) {\n            vec3 normal = vec3(0.0, 0.0, 1.0);\n            int textureId = cyl.texture_id;\n            x = Hit(t, normal, textureId);\n            return true;\n        }\n\n        // Check intersection with the bottom cap\n        t = (-1.0 - ro.z) / rd.z;\n        intersectionPoint = ro + t * rd;\n        if (t > 0.0 && length(intersectionPoint.xy) <= 1.0) {\n            vec3 normal = vec3(0.0, 0.0, -1.0);\n            int textureId = cyl.texture_id;\n            x = Hit(t, normal, textureId);\n            return true;\n        }\n\n    }\n\n    return false;\n}\n\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x){\n    Hit c;\n    Hit s1;\n    Hit s2;\n    Cylinder cyl = Cylinder(cap.center, cap.radius, cap.height, cap.texture_id );\n    bool intersectC = IntersectCylinder(ray, cyl, c);\n    bool intersectS1 = IntersectSphere(ray, Sphere(cap.center + vec3(0, 0, cap.height), cap.radius, cap.texture_id), s1);\n    bool intersectS2 = IntersectSphere(ray, Sphere(cap.center - vec3(0, 0, cap.height), cap.radius, cap.texture_id), s2);\n    if (intersectC || intersectS1 || intersectS2){\n        if (intersectC && intersectS1 && intersectS2){\n            if (c.depth < s1.depth && c.depth < s2.depth){\n                x = c;\n            } else if (s1.depth < c.depth && s1.depth < s2.depth){\n                x = s1;\n            } else {\n                x = s2;\n            }\n        } else if (intersectC && intersectS1){\n            if (c.depth < s1.depth){\n                x = c;\n            } else {\n                x = s1;\n            }\n        } else if (intersectC && intersectS2){\n            if (c.depth < s2.depth){\n                x = c;\n            } else {\n                x = s2;\n            }\n        } else if (intersectS1 && intersectS2){\n            if (s1.depth < s2.depth){\n                x = s1;\n            } else {\n                x = s2;\n            }\n        } else if (intersectC){\n            x = c;\n        } else if (intersectS1){\n            x = s1;\n        } else {\n            x = s2;\n        }\n    return true;\n    }\n    return false;\n}\n\nbool IntersectCube(Ray ray, Cube cube, out Hit x) {\n    vec3 c = cube.center;\n    vec3 s = cube.half_size;\n\n    // Transform the ray into the local cube space\n    vec3 ro = (ray.origin - c) / s;\n    vec3 rd = ray.direction / s;\n\n\n    // Check the intersection with the slab in each dimension\n    vec3 t1 = (-0.5 - ro) / rd;\n    vec3 t2 = (0.5 - ro) / rd;\n\n    float tNear = max(max(min(t1.x, t2.x), min(t1.y, t2.y)), min(t1.z, t2.z));\n    float tFar = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));\n    \n    if (tNear > tFar || tFar < 0.0)\n        return false;\n    \n    // Check if the intersection point is in front of the ray's origin\n    if (tNear > 0.0) {\n        vec3 intersectionPoint = ro + tNear * rd;\n\n        // Calculate the normal based on which face was hit\n        vec3 normal = vec3(0.0);\n\n        float maxComp = max(max(abs(intersectionPoint.x), abs(intersectionPoint.y)), abs(intersectionPoint.z));\n        \n        if (maxComp == abs(intersectionPoint.x))\n            normal.x = sign(intersectionPoint.x);\n        else if (maxComp == abs(intersectionPoint.y))\n            normal.y = sign(intersectionPoint.y);\n        else\n            normal.z = sign(intersectionPoint.z);\n\n        int textureId = cube.texture_id;\n                x = Hit(tNear, normalize(normal), textureId);\n        return true;\n    }\n\n    return false;\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    // Transform the ray into the local ellipsoid space\n    vec3 ro = (ray.origin - ellipsoid.center) / ellipsoid.half_radius;\n    vec3 rd = ray.direction / ellipsoid.half_radius;\n\n    // Ellipsoid equation: (x^2 / a^2) + (y^2 / b^2) + (z^2 / c^2) = 1\n    // Where (a, b, c) are the radii of the ellipsoid\n\n    // Calculate coefficients for the quadratic equation\n    float a2 = dot(rd, rd);\n    float b2 = 2.0 * dot(ro, rd);\n    float c2 = dot(ro, ro) - 1.0;\n\n    float discriminant = b2 * b2 - 4.0 * a2 * c2;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b2 - sqrt(discriminant)) / (2.0 * a2);\n        float t2 = (-b2 + sqrt(discriminant)) / (2.0 * a2);\n\n        // Find the closest intersection point\n        float t = min(t1, t2);\n\n        // Check if the intersection point is in front of the ray's origin\n        if (t > 0.0) {\n            vec3 intersectionPoint = ro + t * rd;\n\n            // Calculate the normal based on the ellipsoid equation\n            vec3 normal = vec3(\n                2.0 * intersectionPoint.x / (ellipsoid.half_radius.x * ellipsoid.half_radius.x),\n                2.0 * intersectionPoint.y / (ellipsoid.half_radius.y * ellipsoid.half_radius.y),\n                2.0 * intersectionPoint.z / (ellipsoid.half_radius.z * ellipsoid.half_radius.z)\n            );\n\n            int textureId = ellipsoid.texture_id;\n            x = Hit(t, normalize(normal), textureId);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Function to calculate the intersection of a ray with a torus\nfloat iTorus(vec3 ro, vec3 rd, in vec3 center, in vec2 tor) {\n    // Calculate the direction from the ray origin to the torus center\n    vec3 rc = ro - center;\n    \nfloat po = 1.0;\n    \n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n\t\n    float m = dot(rc, rc);\n    float n = dot(rc, rd);\n\n    // Bounding sphere\n    {\n\tfloat h = n * n - m + (tor.x + tor.y) * (tor.x + tor.y);\n\tif (h < 0.0) return -1.0;\n\t    }\n    \n\t// Find quartic equation\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * rd.z * rd.z + k;\n    float k1 = k * n + Ra2 * rc.z * rd.z;\n    float k0 = k * k + Ra2 * rc.z * rc.z - Ra2 * ra2;\n\t\n    // Prevent |c1| from being too close to zero\n    if (abs(k3 * (k3 * k3 - k2) + k1) < 0.01) {\n        po = -1.0;\n        float tmp = k1;\n        k1 = k3;\n        k3 = tmp;\n        k0 = 1.0 / k0;\n        k1 = k1 * k0;\n        k2 = k2 * k0;\n        k3 = k3 * k0;\n    }\n\t\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n    \nfloat h = R * R - Q * Q * Q;\n    float z = 0.0;\n\t\n    if (h < 0.0) {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    } else {\n        // 2 intersections\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\t\t\n\n    z = c2 - z;\n\t\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n    \n    if (abs(d1) < 1.0e-4) {\n        if (d2 < 0.0) return -1.0;\n        d2 = sqrt(d2);\n    } else {\n        if (d1 < 0.0) return -1.0;\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\t\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n    \n    if (h > 0.0) {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = -d1 + h - k3;\n        t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        \n        if (t1 > 0.0) result = t1; \n        if (t2 > 0.0) result = min(result, t2);\n    }\n\n    h = d1 * d1 - z - d2;\n    \n    if (h > 0.0) {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = d1 + h - k3;\n        t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        \n        if (t1 > 0.0) result = min(result, t1);\n        if (t2 > 0.0) result = min(result, t2);\n    }\n\n    return (result > 0.0) ? result : -1.0;\n}\n\n// Function to calculate the normal of a torus\nvec3 nTorus(vec3 intersectPos, Torus torus) {\n    vec3 pos = torus.center-intersectPos;\n    vec2 tor = vec2(torus.major_radius, torus.tube_radius);\n    vec3 normal = normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.00,1.00,-1.00)));\n    return vec3(0);\n}\n\nbool IntersectTorus(Ray ray, Torus torus, out Hit x) {\n    float t = iTorus(ray.origin, ray.direction, torus.center, vec2(torus.major_radius, torus.tube_radius));\n\n    if (t > 0.0) {\n        vec3 p = Point(ray, t);\n        vec3 n = nTorus(p, torus);\n        // Transform the normal from object space to world space if needed\n        int textureId = torus.texture_id;\n        x = Hit(t, n, textureId);\n        return true;\n    }\n\n    return false;\n}\n\n//############################################################################################################\n// Shape rotation functions\n//############################################################################################################\n\n// Function to rotate a point\nvec3 rotate(vec3 point, float angle, vec3 axis) {\n    // Calculate the rotation matrix\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n\n    mat3 rotationMatrix = mat3(\n        t * axis.x * axis.x + c, t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y,\n        t * axis.x * axis.y + s * axis.z, t * axis.y * axis.y + c, t * axis.y * axis.z - s * axis.x,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * axis.z * axis.z + c\n    );\n\n    // Rotate the point\n    return rotationMatrix * point;\n}\n\n\n// Function to rotate a ray\nRay rotateRay(Ray ray, float angle, vec3 axis) {\n    // Rotate the ray origin\n    vec3 origin = rotate(ray.origin, angle, axis);\n\n    // Rotate the ray direction\n    vec3 direction = rotate(ray.direction, angle, axis);\n\n    return Ray(origin, direction);\n}\n\n//############################################################################################################\n// Shape scaling functions\n//############################################################################################################\n\n// Function to scale a point\nvec3 scalePoint(vec3 point, vec3 scale) {\n    vec3 scaledPoint = vec3(point.x * scale.x, point.y * scale.y, point.z * scale.z);\n    return scaledPoint;\n}\n\n// Function to scale a ray\nRay scaleRay(Ray ray, vec3 scale) {\n    //scale equal 1/scale to make it bigger if scale is bigger\n    scale = vec3(1.0 / scale.x, 1.0 / scale.y, 1.0 / scale.z);\n\n    // Scale the ray origin\n    vec3 origin = scalePoint(ray.origin, scale);\n\n    // Scale the ray direction\n    vec3 direction = scalePoint(ray.direction, scale);\n\n    return Ray(origin, direction);\n}\n\n//############################################################################################################\n// Shape translation functions\n//############################################################################################################\n\n// Translation operator\nvec3 applyTranslation(vec3 translation, vec3 point) {\n    return point + translation;\n}\n\n// Ray translation\nRay translateRay(Ray ray, vec3 translation) {\n    // Translate the ray origin\n    vec3 origin = applyTranslation(translation, ray.origin);\n\n    return Ray(origin, ray.direction);\n}\n\n\n\n//############################################################################################################\n// Scene Intersection\n//############################################################################################################\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x)\n{\n\n    // Spheres\n    Sphere sph1 = Sphere(vec3(0.0, 0.0, 0.0), 1.0, 5);\n    Sphere sph2 = Sphere(vec3(0.5, 1.0, 0.5), 1.0, 4);\n    \n    // Plane\n    Plane pl = Plane(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 2);\n\n    // Cylinder\n    Cylinder cylinder = Cylinder(vec3(0.0, 0.0, 1.0), 0.5, 2.0, 4);\n\n    // Capsule\n    Capsule cap = Capsule(vec3(0.0, 0.0, 1.0), 0.5, .7, 5);\n\n    // Cubes\n    Cube cube1 = Cube(vec3(0.0, 0.0, 4.0), vec3(1.0, 6.0, 2.0), 4);\n    Cube cube2 = Cube(vec3(0.0, 0.0, 1.0), vec3(1.0, 2.0, 2.0), 1);\n    Cube rotatedCube = Cube(vec3(-0.5, 2.1, 4.0), vec3(1.0, 2.0, 2.0), 5);\n\n    // Ellipsoid\n    Ellipsoid ellipsoid = Ellipsoid(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.5, 0.75), 3);\n\n    // Torus\n    Torus torus = Torus(vec3(0.0, 0.0, 1.0), 2.5, 0.5, 3);\n\n    //---------------------------------------------------------------------------------\n    // Transforming\n    //---------------------------------------------------------------------------------\n\n    // Translation\n    vec3 translateSph1 = vec3(0.0, -5.0, 3.0);\n    vec3 translateSph2 = vec3(0.0, -5.0, 1.0);\n    vec3 translateCylinder = vec3(2.0, -3.0, 0.0);\n    vec3 translateCapsule = vec3(-2.0, -4.0, 1.0);\n    vec3 translateCube1 = vec3(-2.0, 1.0, 1.0);\n    vec3 translateCube2 = vec3(-4.0, 2.0, 2.0);\n    vec3 translateEllipsoid = vec3(0.0, 5.0, 0.0);\n    vec3 translateTorus = vec3(0.0, -5.0, 3.25);\n\n    // Rotation\n    vec3 rotationAxis = normalize(vec3(0.0, 1.0, 0.0));\n    float rotationAngle = radians(20.0);\n\n    //---------------------------------------------------------------------------------\n    // Apply transformations\n    //---------------------------------------------------------------------------------\n\n    // Apply translations\n    sph1.center = applyTranslation(translateSph1, sph1.center);\n    sph2.center = applyTranslation(translateSph2, sph2.center);\n    cylinder.center = applyTranslation(translateCylinder, cylinder.center);\n    cap.center = applyTranslation(translateCapsule, cap.center);\n    cube1.center = applyTranslation(translateCube1, cube1.center);\n    cube2.center = applyTranslation(translateCube2, cube2.center);\n    ellipsoid.center = applyTranslation(translateEllipsoid, ellipsoid.center);\n    torus.center = applyTranslation(translateTorus, torus.center);\n\n    // Intersect transformed ray with the scene\n    x = Hit(1000.0, vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n    if (IntersectSphere(ray, sph1, current) && current.depth < x.depth)\n    {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectSphere(ray, sph2, current) && current.depth < x.depth)\n    {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectPlane(ray, pl, current) && current.depth < x.depth)\n        {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectCylinder(ray, cylinder, current) && current.depth < x.depth) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectCapsule(ray, cap, current) && current.depth < x.depth)\n    {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectCube(ray, cube1, current) && current.depth < x.depth) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectCube(scaleRay(ray, vec3(2.)), cube2, current) && current.depth < x.depth) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCube(rotateRay(ray, rotationAngle, rotationAxis), rotatedCube, current) && current.depth < x.depth) {\n        x = current;\n        x.normal = rotate(x.normal, rotationAngle, -rotationAxis);\n        ret = true;\n    }\n\n    if (IntersectEllipsoid(ray, ellipsoid, current) && current.depth < x.depth) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectTorus(ray, torus, current) && current.depth < x.depth) {\n        x = current;\n        ret = true;\n    }\n\n    return ret;\n}\n\n\n//############################################################################################################\n// ambient occlusion\n//############################################################################################################\n// Hemisphere direction\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n   \n    return d;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int N,float distanceMax)\n{\n    Hit hit;\n    bool hasHit = false;\n    int nbIntersect=0;\n    for(int i=0;i<N;i++)\n    {\n        vec3 d= Hemisphere (i,n); // d dans la demi-sphere\n        hasHit=Intersect(Ray(p+0.001*d,d),hit);\n        if (hit.depth<distanceMax && hasHit) nbIntersect+=1;\n    }\n\n    return 1.-float(nbIntersect)/float(N);\n}\n\n//############################################################################################################\n// Main\n//############################################################################################################\n\n// Background\n/*\n    This function is used to compute the background color\n*/\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(0.5,1.0,1.0),vec3(.0,.075,.49),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nfloat map( in vec3 p )\n{\n    float d = 1e10;\n    d = min(d, length(p - vec3(0, 0, 1)) - 1.0);\n    d = min(d, length(p - vec3(0, 0, -1)) - 1.0);\n    d = min(d, length(p - vec3(0, 1, 0)) - 1.0);\n    d = min(d, length(p - vec3(0, -1, 0)) - 1.0);\n    d = min(d, length(p - vec3(1, 0, 0)) - 1.0);\n    d = min(d, length(p - vec3(-1, 0, 0)) - 1.0);\n    return d;\n}\n\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx = Intersect(ray, x);\n\n    \n    if (idx)\n    {\n        \n        // Compute the intersection point\n        vec3 p = Point(ray, x.depth);\n\n        // Get the material at the intersection point\n        \n        //if mirror, reflect ray compute reflection and\n        //darken the texture for each mirrorTry\n        float mirrorEfficiency = 0.75;\n        int mirrorTry = 0;\n        int maxMirrorTry = 32;\n        while (x.texture_id == 4 && mirrorTry < maxMirrorTry) {\n            mirrorTry++;\n            vec3 n = x.normal;\n            vec3 r = reflect(ray.direction, n);\n            ray = Ray(p + 0.001, r);\n            if (!Intersect (ray, x))\n            {\n                vec3 background = Background(ray.direction);\n                vec3 color = background *= (mirrorEfficiency/float(mirrorTry));\n                return color;\n            }\n            // Compute the intersection point\n            p = Point(ray, x.depth);\n        }\n        Material mat = Texture(p, x.texture_id);\n\n\n        if (mirrorTry!=0) {\n            mat.diffuse *= mirrorEfficiency/float(mirrorTry);\n        }\n\n        // Compute the ambient occlusion\n        if (nbIntersectAmbiantOcclusion!=0)\n        mat.diffuse *= AmbientOcclusion(p, x.normal,nbIntersectAmbiantOcclusion, distanceAmbiantOcclusion);\n        \n\n        // smooth shadow\n        float shadow = 1.0;\n        vec3 lightPos = vec3(4, 8, 50);\n\n        float intensity = 1.0;\n\n        //Daynight cycle on lightIntensity using iTime\n        if (enable_daynight)\n            intensity = clamp((0.75 + 0.5 * sin(iTime)), 0.0, 1.0);\n\n        vec3 lightIntensity = vec3(intensity);\n        vec3 lightAmbient = vec3(0.5, 0.5, 0.5);\n        vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);\n        vec3 lightSpecular = vec3(0.9, 0.9, 0.9);\n        vec3 ambient = lightAmbient * mat.diffuse;\n\n        // Compute the normal\n        vec3 n = x.normal;\n\n        // Compute the light direction\n        vec3 light_pos_1 = normalize(lightPos - p);\n\n\n        // Compute the view direction\n        vec3 v = normalize(-ray.direction);\n\n        // Compute the reflection direction\n        vec3 r = reflect(-light_pos_1, n);\n\n        // Compute the diffuse term\n        float diff = max(dot(n, light_pos_1), 0.25);\n\n        // Compute the specular term\n        float spec = pow(max(dot(r, v), 0.0), 32.0);\n\n        // Compute the diffuse term\n        vec3 diffuse = lightDiffuse * mat.diffuse * diff;\n\n        // Compute the specular term\n        vec3 specular = lightSpecular * spec;\n\n        // Compute the shadow\n        Ray shadowRay = Ray(p, light_pos_1);\n        Hit shadowHit;\n\n        //Avoid self-shading\n        shadowRay = Ray(p + 0.001 * n, light_pos_1);\n\n        \n\n        // Toggle normal visualization\n        if (visualizeNormals)\n        {\n            // Visualize normals as colors (for debugging)\n            vec3 normalColor = 0.5 * x.normal + 0.5;\n            return normalColor;\n        }\n        else\n        {\n            //avoid self shadow\n            for (int i = 0; i < int(nbLightSource.x); i++) {\n               for (int j = 0; j < int(nbLightSource.y); j++) {\n                    for (int k = 0; k < int(nbLightSource.z); k++) {\n                   if (Intersect(shadowRay, shadowHit)) {\n                       if (shadowHit.depth < Distance(p, lightPos)) {\n                            shadow -= 1./float(nbLightSource*nbLightSource*nbLightSource);\n                        }\n                    }\n                    shadowRay.direction = vec3(float(i) * step, float(j) * step, float(k) * step)+light_pos_1 ;\n                    }\n               }\n            }\n\n        // Compute the color\n        vec3 color = (ambient + (diffuse + specular) * shadow) * lightIntensity;\n\n        return color;\n        }\n    }\n    \n    else\n    {\n        return Background(ray.direction);\n    }\n\n    return vec3(0);\n}\n\n// Main\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    //zoom out\n    ro *= 2.0;\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n\n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}\n\n//############################################################################################################\n\n","name":"Image","description":"","type":"image"}]}