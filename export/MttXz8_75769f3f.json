{"ver":"0.1","info":{"id":"MttXz8","date":"1478276618","viewed":2814,"name":"Mandelbrot Filaments & Lightning","username":"ttoinou","description":"Upgraded IQ's Mandelbrot DE with gradient for better coloring. Featuring thin filaments (1D border of the fractal) and lightning strikes where the distance to the set changes dramatically (something to do with the electrostatic potential ?). Click : angle","likes":44,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal","mandelbrot","gradient","distance","depth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    color = texture(iChannel0,coord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// modified version of\n// https://www.shadertoy.com/view/lsX3W4\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATIONS 500\n#define BAILOUT    (128.)\n#define BAILOUT2   (BAILOUT*BAILOUT)\n//#define AA_ENABLE   \n#define AA_FLIPQUAD \n#define AA_RADIUS   4\n\n// doesn't feel like it's doing much good\n// but gives a nice \"papyrus\" texture if AA_RANDOMRADIUS > 1.\n#define AA_RANDOM\n// should be 1.\n#define AA_RANDOMRADIUS (4.)\n\n#define PI (3.14159265359)\n\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\n#define HASHSCALE1 .1031\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smoooth(float x){\n    return 0.5 - 0.5*cos(x*PI);\n}\n\nvec4 mandelbrot( in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\t//float tz = 0.5 - 0.5*cos(0.225*iTime);\n    //float zoo = pow( 0.5, 13.0*tz );\n    \n\t//float tz = 0.5 - 0.5*cos(1.225*iTime);\n    //float zoo = pow( 0.5, 10. + 2.0*tz );\n    \n    float tz = 0.5 - 0.5*cos(0.225*iTime);\n    float tz2 = 0.5 + 0.5*sin(0.225*iTime*.5);\n    float zoo = pow( 0.5, 14.*tz-.5 );\n    float a = iTime/6.;\n    \n\tvec2 c = mix( vec2( -1.2577776425405087 , -0.35897390816984004 ),\n                  vec2( -0.3083400668881918 , 0.6384704937518136 ),\n                  //smoooth((tz-1.)/2.) )\n                  //smoooth(smoooth(smoooth(smoooth((tz-1.)/2.)))) )\n                  smoooth(smoooth(smoooth(smoooth( tz2 )))) )\n        + p*zoo*mat2(cos(a),sin(a),-sin(a),cos(a));\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iter = 0;\n    for( int i=0; i<ITERATIONS; i++ )\n    {\n        if( m2>BAILOUT2 ) continue;\n\n\t\t// Z' -> 2Â·ZÂ·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> ZÂ² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iter = i;\n    }\n\n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\tfloat potential = float(iter) - log( log(length(z)) / log(BAILOUT) )/log(2.);\n\n\t\n    // do some soft coloring based on distance\n\t//d = clamp( 2.0*d/zoo, 0.0, 1.0 );\n\t//d = pow( d, 0.25 );\n    \n    bool inside = iter == ITERATIONS-1;\n    \n    return vec4( inside ? 0. : (d/zoo) , potential , iter , inside );\n    \n}\n\n\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec4 i1,i2;\n    \n    #ifdef AA_ENABLE\n        \n        #ifdef AA_FLIPQUAD\n    \t\t// https://www.shadertoy.com/view/MtSGRG\n        \tvec4 i3,i4;\n        \n            bool xOdd = (floor(mod(coord.x,2.0)) == 1.0);\n            bool yOdd = (floor(mod(coord.y,2.0)) == 1.0);\n\n            vec2 a = vec2(xOdd ? 0.25 : -0.25, yOdd ? -0.5  :  0.5 );\n            vec2 b = vec2(xOdd ? 0.5  : -0.5 , yOdd ?  0.25 : -0.25 );\n            vec2 c = a * vec2(-1);\n            vec2 d = b * vec2(-1);\n\n            i1 = mandelbrot(coord.xy + a);\n            i2 = mandelbrot(coord.xy + b);\n            i3 = mandelbrot(coord.xy + c);\n            i4 = mandelbrot(coord.xy + d);\n\n            i1 = (i1 + i2 + i3 + i4)/4.;\n        #else\n\t\t\t// Brutal AA\n            i1 = mandelbrot(coord);\n\n            vec2 pos;\n            float radius = float(AA_RADIUS);\n\n            for( int i = 0 ; i < AA_RADIUS ; i++ ){\n\n                for( int j = 0 ; j < AA_RADIUS ; j++ ){\n\n                    if( i + j > 0 ){\n\n                        #ifdef AA_RANDOM\n                            pos = vec2(i,j);\n\n                            pos = (pos -\n                              hash23(vec3(coord,\n                                  hash13( vec3(pos,iTime) )\n                              ))*AA_RANDOMRADIUS\n                            )/radius;\n\n                        #else\n                            pos = vec2(i,j)/radius;\n                        #endif\n\n                        i2 = mandelbrot(coord+pos);\n                        i1 += i2;\n                        //if( i2.r > i1.r ){ i1 = i2; }\n                    }\n\n                }\n            }\n\n            i1 /= radius*radius;\n\t\t#endif\n    #else\n        i1 = mandelbrot(coord);\n    #endif\n    \n    // inside mandelbrot is black\n    //i1.rg *= i1.a > 0. ? 0. : 1.;\n    \n    color = i1;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//#define FASTGRADIENT\n#define PI (3.14159265359)\n\n// https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 mandelbrot(vec2 coord){\n    return texture(iChannel0,coord/iResolution.xy);\n}\n\nfloat distMod(float x, float y, float m){\n    float d = mod(x-y,m);\n    return min( abs(d) , abs(m-d) );\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec4 mandel = vec4(0.);\n    vec4 col;\n    vec2 pos;\n    float sum = 0.;\n    float colX = 0.;\n    float colY = 0.;\n    float laplacian = 0.;\n    float s = sqrt(2.);\n    \n    #ifdef FASTGRADIENT\n\n        mandel = mandelbrot(coord);\n    \tfloat a = mandelbrot(coord+vec2(1.,0.)).r;\n    \tfloat b = mandelbrot(coord-vec2(1.,0.)).r;\n    \tfloat c = mandelbrot(coord+vec2(0.,1.)).r;\n    \tfloat d = mandelbrot(coord-vec2(0.,1.)).r;\n    \n        colX = a - b;\n        colY = c - d;\n    \tlaplacian = 4.1*mandel.r - (a+b+c+d);\n    \n    \tcolX *= 3.5;\n    \tcolY *= 3.5;\n    \tlaplacian *= 80.;\n    \n   \t#else\n    \n        #define gradient(dx,dy,cx,cy,la) pos = vec2(dx,dy); col = mandelbrot(coord+pos); colX += cx*col.r; colY += cy*col.r; laplacian += la*col.r; mandel += length(pos)*col; sum += length(pos); \n\n\n        gradient(-1,-1,-1., 1.,-1.)\n        gradient( 0,-1, 0., s ,-s)\n        gradient( 1,-1, 1., 1.,-1.)\n\n        gradient(-1, 0,-s ,0.,-s)\n        gradient( 0, 0, 0.,0.,8.*(1. + s))\n        gradient( 1, 0, s ,0.,-s)\n\n        gradient(-1, 1,-1.,-1.,-1.)\n        gradient( 0, 1, 0.,-s ,-s)\n        gradient( 1, 1, 1.,-1.,-1.)\n\n        mandel /= sum;\n    #endif\n    \n    \n    float logDist = log(mandel.r);\n    float magn = sqrt(colX*colX + colY*colY)*iResolution.y/16.;\n    float sqrtMagn = sqrt(magn);\n    float angle = atan(colY,colX)/PI*0.5+0.5;\n    float showAngle = iMouse.x/iResolution.x - ( iMouse.z > .5 ? 0. : iTime*3. );\n    \n    // removing colors\n    // in valleys where angle\n    // changes brutally\n    float valleys = (magn/(laplacian*.15));\n    valleys -= smoothstep( 0. , 1. , fwidth(valleys) );\n    //valleys = 1.;\n    \n    float distAngle = distMod(angle,showAngle,1.);\n    float angleMap = clamp(1. - distAngle*3.,0.,1.);\n    float darkCoeff = 1e4;\n    \n    if( iMouse.z > .5 ){\n        \n    \tcolor.rgb = hsv2rgb_smooth(vec3(\n            showAngle,\n            1.,\n            sqrtMagn*angleMap\n        ));\n        \n        \n    } else {\n        \n        color.rgb = hsv2rgb_smooth(vec3(\n            logDist*0.8 - iTime/1.5, // 1.5 is perfect when zooming in (zoom compensation)\n            clamp(valleys,0.,1.),\n            pow( (1. - exp(-magn/darkCoeff))/(1. - exp(-1./darkCoeff)) , 0.8 )\n        ));\n        \n    }\n    \n    // lightning impact on spikes\n    // = high duaddy hubbard potential\n    // (like radio antennas ?)\n    color = mix(color,vec4(1.),  pow(magn,1.6)*1.2 );\n    \n    // dead pixels removal\n    color = (clamp(color,0.,1.));\n    \n    vec4 previous = texture(iChannel1,coord/iResolution.xy);\n    color = mix(color,previous,0.2);\n}","name":"Buf B","description":"","type":"buffer"}]}