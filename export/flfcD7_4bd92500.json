{"ver":"0.1","info":{"id":"flfcD7","date":"1648105758","viewed":88,"name":"Assignment Computer Graphics 1 2","username":"YannClodong","description":"Assignment coputer graphics 1","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["assignment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//buffer A\n\nconst int materialsNo = 3;\nMaterial materials[materialsNo];\n\nconst int spheresNo = 2;\nSphere spheres[spheresNo];\n\nconst int planeNo = 2;\nPlane planes[planeNo];\n\nconst int triangleNo = 1;\nTriangle triangles[triangleNo];\n\nconst int lightsNo = 2;\nLight lights[lightsNo];\n\nconst int reflexionStackSize = 10;\n\n\nconst float Tmax = 500.;\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-16,2.,-2.);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               Tmax);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, s.materialId); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.materialId);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n, t, plane.materialId);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle t) \n{\n    Plane plane = Plane(t.A, cross(t.B - t.A, t.C - t.A), t.materialId);\n    TraceResult pin = intersectPlane(ray, plane);\n    vec3 p = ray.p0 + ray.v * pin.t;\n    vec3 n = normalize(pin.n);\n    \n    float A0 = dot(cross(t.B - t.A, t.C - t.A), n) / 2.;\n    float Aa = dot(cross(t.B - p, t.C - p), n) / (2. * A0);\n    float Ab = dot(cross(t.C - p, t.A - p), n) / (2. * A0);\n    float Ac = 1. - Aa - Ab;\n    \n    \n    if(Aa < 0. || Ab < 0. || Ac < 0.)\n        return TraceResult(vec3(0, 0, 0), 0., t.materialId);\n    else \n        return pin;\n}\n\nTraceResult raycast(Ray ray, int ignoreSphere, int ignorePlane, int ignoreTriangle)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        if(i == ignoreSphere) continue;\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        if(i == ignorePlane) continue;\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < triangleNo; i++) \n    {\n        if(i == ignoreTriangle) continue;\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n            res = res2;\n    }\n        \n    return res;\n}\n\n\n\nTraceResult raycast(Ray ray) {\n    return raycast(ray, -1, -1, -1);\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n// https://learnopengl.com/PBR/Theory\n// Normal distribution function\nfloat NormalDistribution(float NH, float roughness) {\n    float alpha = roughness * roughness;\n    float sqAlpha = alpha * alpha;\n    float denominator = NH * NH * (sqAlpha - 1.f) + 1.f;\n    float sqDenominator = denominator * denominator;\n    return sqAlpha / max(pi * sqDenominator, 0.00000001);\n}\n\n// https://learnopengl.com/PBR/Theory\n// Schlick Geometry\nfloat SchlickGeometryGGX(float NV, float k) {\n    return NV / min(NV * (1. - k) + k, .00000001);\n}\n\n// https://learnopengl.com/PBR/Theory\n// Smith Geometry\nfloat SmithGeometry(vec3 N, vec3 V, vec3 L, float k) {\n    float NV = max(dot(N, V), 0.f);\n    float NL = max(dot(N, L), 0.f);\n    \n    float schlick1 = SchlickGeometryGGX(NV, k);\n    float schlick2 = SchlickGeometryGGX(NL, k);\n    \n    return schlick1 * schlick2;\n}\n\n\nvec4 computeLight(Ray ray, TraceResult tr, Light light) {\n    vec3 pp = ray.p0 + ray.v * tr.t;\n    \n    vec3 v = -ray.v;\n    \n    vec3 l = light.position - pp;\n    float lightDist = length(l);\n    l /= lightDist;\n    \n    // Retrieve material\n    Material mat = materials[tr.materialId];\n    \n    // Compute light perdition with distance\n    vec3 radiance = vec3(1);      \n    \n    float specular = 0.;\n    float diffuse = 0.;\n    vec3 n = tr.n;\n\n    vec3 reflectedRay = -reflect(ray.v, tr.n);\n\n    vec3 h = normalize(v + l);\n\n    float NH = max(dot(n, h), 0.);\n    float HV = max(dot(h, v), 0.);\n\n\n    float normalDistributed = NormalDistribution(NH, mat.roughness);\n    float smith = SmithGeometry(n, v, l, mat.roughness);\n\n    specular = min(normalDistributed / 4.f, 1.f);\n\n    diffuse = (1.f - specular) * max(dot(-reflectedRay, l), 0.f);\n    \n    vec3 result = (specular * mat.metalness + diffuse * (1.f - mat.metalness)) * radiance;\n    \n    return vec4(result * radiance + mat.emission, 1);\n}\n\nvec4 computeLight2(Ray ray, TraceResult tr) {\n    float remainDist = Tmax;\n    \n    int head = -1;\n    ReflRefrStackElement stack[reflexionStackSize];\n    \n    stack[0] = ReflRefrStackElement(tr, ray, vec3(1), false);\n    head = 0;\n    \n    vec4 result = vec4(0);\n    float numberOfLights = 01.;\n    \n    do {\n        ReflRefrStackElement el = stack[head--];\n        \n        tr = el.tr;\n        ray = el.ray;\n        bool inside = el.inside;\n        \n        vec3 factor = el.factor;\n        if(length(factor) == 0.)\n            continue;\n       \n        \n        \n        \n        Material mat = materials[tr.materialId];\n        vec3 pp = ray.p0 + ray.v * tr.t;\n        \n        remainDist -= tr.t;\n        if(remainDist <= 0.) {\n            result += missColor(ray);\n            numberOfLights++;\n            break;\n        }\n        \n        result += vec4(mat.emission * factor, 1);\n        \n        \n        // Compute light at this point\n        //for(int l = 0; l < lightsNo; l++) {\n        //    Light light = lights[l];\n        //    numberOfLights += light.intensity;\n        //    result += mat.opacity * (1. - mat.reflectivness) * factor * computeLight(ray, tr, light);\n        //}\n        \n        for(int l = 0; l < lightsNo; l++) {\n            Light light = lights[l];\n            numberOfLights += light.intensity * mat.opacity * (1. - mat.reflectivness);\n            result += computeLight(ray, tr, light) * mat.opacity * (1. - mat.reflectivness) * vec4(factor, 1) * light.intensity * vec4(light.color * mat.color, 1);\n            //result += factor * light.intensity * light.color * mat.color * dot(normalize(light.position - pp), normalize(reflect(ray.v, tr.n)));\n        }\n        \n        \n        \n        // reflected ray\n        if(mat.reflectivness != 0. && !inside) {\n            Ray reflectedRay = Ray(pp + 0.01 * normalize(tr.n), 0.01, reflect(ray.v, tr.n), remainDist);\n            TraceResult reflectedTr = raycast(reflectedRay);\n            if(reflectedTr.t < remainDist)\n                stack[++head] = ReflRefrStackElement(reflectedTr, reflectedRay, mat.opacity * mat.reflectivness * factor * mat.color, inside);\n            else {\n                result += missColor(reflectedRay) * vec4(mat.color, 1) * mat.reflectivness * vec4(factor, 1);\n                //numberOfLights++;\n            }\n        }\n        //refracted ray\n        // Check whether of not the stack is borred up\n        if(reflexionStackSize <= head)\n            continue;\n        \n        if(mat.opacity != 1.) {\n            vec3 n = -normalize(tr.n * dot(tr.n, ray.v));\n            \n            float eta = 1. / mat.indice;\n            if(inside)\n                eta = 1. / eta;\n                \n            Ray refractedRay = Ray(pp - n * 0.001, 0.01, refract(normalize(ray.v), n, eta), remainDist);\n            TraceResult refractedTr = raycast(refractedRay);\n            \n            if(refractedTr.t < remainDist)\n                stack[++head] = ReflRefrStackElement(refractedTr, refractedRay, (1.- mat.opacity) * factor * mat.color, !inside);\n            else {\n                result += missColor(refractedRay) * vec4(mat.color, 1) * (1. - mat.opacity) * vec4(factor, 1);\n            }\n        }\n        \n    } while(head >= 0);\n    \n    return 1.1 * result / numberOfLights;\n}\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 ambientLight)\n{\n    return computeLight2(ray, tr);\n}\n\n\nfloat bounce(float t, float a, float f, float A) {\n    float fx = f * (1.-exp(-3.*a*t)) + 3.;\n    return A * abs(sin(fx * t))*exp(-a * pi*(fx * t/pi));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of 2 spheres\n    // Planes materials\n    materials[0] = Material(PLANEColor, PLANERoughness, PLANEEmission, PLANEMetalness, PLANEReflectivness, PLANEOpacity, PLANEIndice);\n    // Spheres materials\n    materials[1] = Material(BALL2Color, BALL2Roughness, BALL2Emission, BALL2Metalness, BALL2Reflectivness, BALL2Opacity, BALL2Indice);\n    materials[2] = Material(BALL1Color, BALL1Roughness, BALL1Emission, BALL1Metalness, BALL1Reflectivness, BALL1Opacity, BALL1Indice);\n\n    \n    lights[0] = Light(LIGHT1Position, LIGHT1Color, LIGHT1Intensity);\n    lights[1] = Light(LIGHT2Position, LIGHT2Color, LIGHT2Intensity);\n    \n    float t = mod(iTime, 2.*pi);\n    float y = bounce(t, .1, 4., 20.);\n    spheres[0] = Sphere(vec3(0, y + 2., 0.), 2.f, 1);\n    \n    t = mod(iTime + 2., 2.*pi);\n        \n    spheres[1] = Sphere(vec3(-10.,1., 0.), 1.f, 2);\n    \n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), 0);\n    //planes[1] = Plane(vec3(10, 0, 0), vec3(-1, 0, 0), 0);\n    triangles[0] = Triangle(vec3(0, 2, 0), vec3(0, 3, 0), vec3(-1, 3, 0), 0);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result, vec3(0, 0, 0));\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Common\n\n/// Nearest ball\n#define BALL1Color vec3(1)\n#define BALL1Roughness 0.1\n#define BALL1Emission vec3(0)\n#define BALL1Metalness 0.\n#define BALL1Reflectivness 1.\n#define BALL1Opacity 0.\n#define BALL1Indice 1.5\n\n/// Farest ball\n#define BALL2Color vec3(.6, .6, 1)\n#define BALL2Roughness 0.1\n#define BALL2Emission 0.1 * vec3(0,0,1)\n#define BALL2Metalness .9\n#define BALL2Reflectivness .4\n#define BALL2Opacity 1.\n#define BALL2Indice 1.\n\n/// Plane\n#define PLANEColor vec3(1, 1, 1)\n#define PLANERoughness 7.\n#define PLANEEmission vec3(0)\n#define PLANEMetalness .01\n#define PLANEReflectivness 1.\n#define PLANEOpacity 1.\n#define PLANEIndice 1.\n\n/// Lights\n#define LIGHT1Position vec3( -5.,4.,10.)\n#define LIGHT1Color vec3 (1, 1, 1)\n#define LIGHT1Intensity 3.\n\n#define LIGHT2Position vec3(-4.,20000000000.,-0.)\n#define LIGHT2Color vec3 (1, 1, 1)\n#define LIGHT2Intensity 10.\n\nconst float pi = 3.1415926535897932384626433832795;\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int materialId;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;    // normal\n    int materialId;\n};\n\nstruct Triangle {\n    vec3 A;\n    vec3 B; \n    vec3 C;\n    int materialId;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int materialId;\n};\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,~7]\n    vec3  emission;\t    // [0, inf]\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    float reflectivness;\n    float opacity;\n    float indice;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\nstruct ReflRefrStackElement {\n    TraceResult tr;\n    Ray ray;\n    vec3 factor;\n    bool inside;\n};\n\n\n","name":"Common","description":"","type":"common"}]}