{"ver":"0.1","info":{"id":"cddBzX","date":"1697471393","viewed":59,"name":"Eisenstein Series Modular Form","username":"Justaway","description":"Eisenstein series modular form","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["form","series","modular","eisenstein"],"hasliked":0,"parentid":"4lcBDs","parentname":"Zeta with reflection formula"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nvec2 cpow(vec2 z1, vec2 z2)\n{\n\tfloat a2b2 = z1.x * z1.x + z1.y * z1.y;\n\tfloat t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n\tfloat t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n\treturn vec2(t1 * cos(t2), t1 * sin(t2));\n}\n\nvec2 cdiv(vec2 z1, vec2 z2)\n{\n\treturn z1 * mat2(z2, -z2.y, z2.x) / dot(z2, z2);\n}\n\nvec2 cprod(vec2 z1, vec2 z2)\n{\n\treturn vec2(\n\t\tz1.x * z2.x - z1.y * z2.y,\n\t\tz1.x * z2.y + z1.y * z2.x);\n}\n\nvec4 gradient(float theta)\n{\n    vec4 color = vec4(0.0);\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec4 plotDomain(vec2 z)\n{\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvec2 unitDisk(vec2 z)\n{\n    vec2 temp = vec2(0.0);\n    temp = vec2(1.0,0.0) + z;\n    temp = cdiv(temp, vec2(1.0,0.0) - z);\n    temp = cprod(vec2(0.0,1.0), temp);\n    return temp;\n}\n\nvec2 eisensteinSeries(vec2 z)\n{\n#define POWER 16\n    vec2 sum = vec2(0);\n    vec2 temp = vec2(0);\n    for(int m = -POWER; m <= POWER; m++)\n    {\n        for(int n = -POWER; n <= POWER; n++)\n        {\n            if(n == 0 && m == 0) continue;\n            temp = vec2(float(m),0.0) + cprod(vec2(float(n),0.0),z);\n            temp = cpow(temp, vec2(4.0,0.0));\n            temp = cdiv(vec2(1.0,0.0),temp);\n            sum += temp;\n        }\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    vec2 z = unitDisk(uv*2.0)+ vec2(sin(iTime * 0.05) * 5.0, 0.0);\n    if(length(uv*2.0) < 1.0)\n    {\n        fragColor = plotDomain(eisensteinSeries(z));\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}