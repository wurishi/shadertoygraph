{"ver":"0.1","info":{"id":"ds3SWS","date":"1680329223","viewed":147,"name":"Almost loop-free text-drawing","username":"ianertson","description":"Almost loop-free.... There's just one loop here and it's for counting digits in a floating point number.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["text","font","loops"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Almost loop-free text-drawing.\n    The only loop here is for counting digits in a floating point number.\n    Ditch the ability to draw floats and this is 100% loop-free.\n*/\n\n#define R (iResolution.xy)\n#define T (iTime)\n#define ZERO (min(0, int(iTime)))\n\n#define ORD(n) (48 + n)\n#define IS_NUM(n) (n >= 0 && n <= 9)\n#define NUM_CAP 9\n#define NUM_PREC 2\n#define FRACT_BIAS 0.00001\nconst int p10[] = int[](1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 1000000000);\n\n#define DRAW_TEXT(uv, col, TEXT, POS)\\\n    {\\\n        const int chars[] = int[]TEXT;\\\n        float len = float(chars.length());\\\n        vec2 uv = uv - POS;\\\n        vec2 tl = vec2(len+0.5, (len+0.5)/16.0*9.);\\\n        vec2 lv = fract(uv*tl);\\\n        vec2 id = floor(uv*tl);\\\n        id = abs(id);\\\n        int c = chars[clamp(int(id.x), 0, chars.length()-1)];\\\n        float reach = id.y*len+id.x;\\\n        col += (reach < len) ? drawChar(lv, c, 1.) : 0.0;\\\n    }\n\nfloat drawChar(in vec2 uv, in int i, in float s) {\n    vec2 coord = (fract(uv/s) + vec2(i,(IS_NUM(i) ? 12 : 15)-i/16))/16.;\n    float c = texture(iChannel0, coord).w;\n    float f = fwidth(c);\n    return 1.0-smoothstep(0.5-f, 0.5+f, c);\n}\n\nivec3 countDigits(in float w, in bool isFract) {\n    float v = 0.0;\n    int d = int(w);\n    ivec3 c = ivec3(0, 0, 0);\n    int cap = isFract ? NUM_PREC : NUM_CAP;\n    for (int j = ZERO; (j < NUM_CAP && c.x < cap); j++) {\n        int k = int(d/(p10[clamp((NUM_CAP-1)-j, 0, NUM_CAP-1)]));\n        if (k % 10 == 0 && c.x <= 0) c.y += 1;\n        else c.x += 1;\n    }\n    return c;\n}\n\nfloat drawNumber(in vec2 uv, in float w, in float s, in int start) {\n    float v = 0.0;\n    int d = int(w);\n    int k = int(d/(p10[clamp((NUM_CAP-1)-start, 0, NUM_CAP-1)]));\n    v = max(v, drawChar(uv, d == 46 ? d : (k % 10), s));\n    return v;\n}\n\nfloat drawFloat(in vec2 uv, in vec2 pos, in float n, in float s) {\n    uv = uv - pos;\n    float v = 0.0;\n    float f = fract(n) + FRACT_BIAS;\n    float fw = (f * 10000000.0f);\n    ivec3 cw = countDigits(floor(n), false);\n    ivec3 cf = f > FRACT_BIAS ? countDigits(fw, true) : ivec3(0);\n    ivec3 tot = cw + cf;\n    \n    float wholeLen = float(cw.x+1);\n    float fractLen = float(cf.x);\n    float total = (wholeLen + fractLen);\n    float mi = min(wholeLen, fractLen);\n   \n    float xt = ceil(total/2.)+1.;\n    float yt = ((xt+4.) / 16.0 * 9.);\n    float tile = max(2., (1.0 + (mi/float(NUM_PREC))));\n    \n    vec2 uvid = (floor(uv*vec2(tile, 1.)));\n    vec2 glv = fract(uv*vec2(tile, 1.));\n    vec2 clv = glv;\n    vec2 alv = abs(glv*2.0-1.0);\n\n    vec2 lv = fract(glv*vec2(xt, yt));\n    vec2 id = floor(glv*vec2(xt, yt));\n    id = abs(id);\n    \n    if (uvid.x < 1.0 && (id.x < wholeLen-1. || cw.x <= 0))\n    {\n        float reach = id.y*wholeLen+id.x;\n        int startWhole = cw.x <= 0 ? 0 : (cw.y + int(id.x));\n        v = max(v, reach < wholeLen ? drawNumber(lv, floor(n), s, startWhole) : 0.0);\n    }\n    \n    if (f > 0.0 && uvid.x >= 1. && (id.x < fractLen+1. || cf.x <= 0)) {\n        float reach = id.y*fractLen+id.x;\n        int startFract = cf.x <= 0 ? 0 : ((cf.y) + int(id.x))-1;\n        v = max(v, (reach < fractLen+1.-id.y) ? drawNumber(lv, id.x <= 0.0 ? 46. : fw, s, startFract) : 0.0);\n    }\n\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    float tile = 2.;\n    vec2 gv = fract(uv*tile);\n    vec2 id = floor(uv*tile);\n    vec2 alv = abs(gv*2.0-1.0);\n\n    if (id.x <= 0.) {\n        if (id.y <= 0.) {\n             col += drawFloat(gv, vec2(0, 1.0/3.), mix(256.0, 1024.0, 0.5+sin(T*0.25)*0.5), 1.);\n        } else {\n            // \"1, 2, 3, 4, 5\"\n            DRAW_TEXT(gv, col, (1, 2, 3, 4, 5), vec2(0, 1.0/3.));\n        }\n    } else if (id.x > 0.) {\n        if (id.y <= 0.) {\n            // \"shadertoy\"\n            DRAW_TEXT(gv, col, (115, 104, 97, 100, 101, 114, 116, 111, 121), vec2(0, 1.0/3.))\n        } else {\n            // \"hello\"\n            DRAW_TEXT(gv, col, (104, 101, 108, 108, 111), vec2(0, 1.0/3.));\n        }\n    }\n    \n    col += max(\n        smoothstep(0.48, 0.5, alv.x-0.5),\n        smoothstep(0.48, 0.5, alv.y-0.5)\n    );\n    \n    O = vec4(col, 0.);\n}\n","name":"Image","description":"","type":"image"}]}