{"ver":"0.1","info":{"id":"MtscRN","date":"1503866681","viewed":196,"name":"A raymaching test","username":"jope246","description":"A basic raymarching test with phong shading (diffuse + specular + ambient). Also calculates attenuation.\n\nBased on a few tutorials:\nhttps://www.shadertoy.com/view/MdBfRK\nhttps://www.tomdalling.com/blog/modern-opengl/\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nfloat map(vec3 p) {\n    \n    float d = distance(p, vec3(0,0,-3)) - 1.0;\n    d = min(d, distance(p, vec3(2,0,-4)) - 1.0);\n    \n    d = min(d, p.y+1.0);                       \n    \n    return d;\n}\n\n\nvec3 findNormal(vec3 p) {\n\t\n    vec3 normal;\n    normal.x = map(p + vec3(0.005,0.0,0.0)) - map(p - vec3(0.005,0.0,0.0));\n    normal.y = map(p + vec3(0.0,0.005,0.0)) - map(p - vec3(0.0,0.005,0.0));\n    normal.z = map(p + vec3(0.0,0.0,0.005)) - map(p - vec3(0.0,0.0,0.005));\n    return normalize(normal);                                      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    vec3 ro = vec3(0,0,1);\n    \n    vec3 rd = normalize(vec3(uv,0.0) - ro);\n    \n    float h,t = 1.0;\n    for (int i=0;i<256;i++) {\n    \t\n        h = map(ro + rd*t);\n        t += h;\n        \n        if (h < 0.01) break;\n    }\n    \n    vec4 color = vec4(0,0,0,1.0);\n    \n  \tif (h < 0.01) {\n    \t\n        vec3 p = ro + rd*t;\n        vec3 light = vec3(cos(iTime) * 3.0,3,0);\n        vec2 angle = vec2(iTime,.3);\n\t\trotate(light,angle);\n        \n        vec3 light_intensity = vec3(1.0);\n        vec4 surfaceColor = vec4(1);\n        vec3 normal = findNormal(p);\n        \n        vec3 surface_to_light = normalize(light - p);\n        vec3 light_to_surface = -surface_to_light;\n        vec3 surface_to_camera = normalize(ro - p);\n        vec3 reflection = reflect(light_to_surface,normal);\n        \n        float amb = 0.01;\n        vec3 amb_comp = surfaceColor.rgb * amb * light_intensity;\n        \n        float diff = clamp(dot(normal, normalize(surface_to_light)), 0.0, 1.0);\n        vec3 diff_comp = surfaceColor.rgb * diff * light_intensity;\n        \n        float spec = 0.0;\n        float cosOfAngle = clamp(dot(surface_to_camera,reflection),0.0,1.0);\n        if (diff > 0.0)\n            spec = pow(cosOfAngle, 100.0);\n\t\tvec3 spec_comp = spec * light_intensity;\n        \n        float attenuation = 1.0 / (1.0 + pow(length(surface_to_camera),2.0));\n        \n        color = vec4(pow(amb_comp + attenuation*(diff_comp + spec_comp), vec3(0.4545)), surfaceColor.a);\n    }\n    \n\tfragColor = vec4(color);\n}","name":"Image","description":"","type":"image"}]}