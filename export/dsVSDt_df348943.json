{"ver":"0.1","info":{"id":"dsVSDt","date":"1681819725","viewed":320,"name":"4kGFX - Neighbours","username":"Flopine","description":"Made for the 4k executable graphics compo @ Revision 2023, with Blossom by LunaSorcery: https://github.com/lunasorcery/Blossom\nThe executable can be downloaded here: https://www.pouet.net/prod.php?which=94182","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","reflection","demoscene","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n// Made for the 4k executable graphics compo @ Revision 2023\n// with Blossom by LunaSorcery: https://github.com/lunasorcery/Blossom\n\n// The executable can be downloaded here: https://www.pouet.net/prod.php?which=94182\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 tex = texture(iChannel0,fragCoord.xy/iResolution.xy);\n\t\n    vec3 color = tex.rgb/tex.a;\n\tfragColor = vec4(pow(color,vec3(.4545)),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct obj{\n    float d;\n    vec3 c;\n    int mat;\n};\n\nobj minobj (obj a, obj b)\n{\n    if(a.d<b.d)return a;\n    else return b;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec3 pal (float t, vec3 c)\n{return vec3(.5)+vec3(.55)*cos(TAU*(c*t+vec3(0.1,.56,.64)));}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(164.5, 349.1)))*6421.4);}\n\nvec2 edge (vec2 p)\n{return (abs(p.x) > abs(p.y)) ? vec2(sign(p.x),.0) : vec2(0.0, sign(p.y));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.0, max(q.x,max(q.y,q.z)))+length(max(q,.0))-0.02;\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = max(abs(p),abs(p.yzx));\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    vec3 pp = p;\n    \n    float c = 1.;\n    float id = round(p.y/c);\n    p.y -= c*clamp(round(p.y/c),-1., 1.);\n    \n    vec2 center = floor(p.xz)+.5,\n    neigh = center+edge(p.xz-center);\n    float noise = hash21(center*.1),\n    cor = mix(.1,.4,noise),\n    \n    me = (noise > .8) ? \n                max(-sc(p-vec3(center.x, 0.0, center.y), 0.2), box(p-vec3(center.x, 0.0, center.y), vec3(cor))) :\n                box(p-vec3(center.x, 0.0, center.y), vec3(cor)),\n    next = box(p-vec3(neigh.x, 0.0, neigh.y), vec3(.45));\n    obj set = obj(min(me,next), pal(noise,vec3(1.)), 1);\n    \n    p = pp;\n    p.y -= .7;\n    c = .3;\n    p.y -= c*clamp(round(p.y/c),-2., 2.);\n    p.xz = mod(p.xz,4.)-2.;\n    float s = sc(p, 0.1);\n    s = max(s, abs(p.y)-1.5);\n    \n    return minobj(obj(s,vec3(0.9),2),set);\n}\n\nvec3 gn (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat AO (vec3 p, vec3 n, float e)\n{return clamp(SDF(p+e*n).d/e,0.,1.);}\n\nfloat spec (vec3 rd, vec3 l, vec3 n)\n{return pow(max(dot(n, normalize(l-rd)),0.), 8.);}\n\nvec3 raymarch_color (vec3 p, vec3 rd, vec3 ro, vec3 l, vec2 uv)\n{\n    vec3 new_color = vec3(0.);\n    bool hit=false; obj O; float a=1.;\n    for (float i=0.0; i<100.; i++)\n    {\n        O = SDF(p);\n        if (O.d<0.01)\n        { \n            hit=true;\n            if(O.mat == 2)\n            {\n                vec3 n = gn(p);\n                rd = normalize(reflect(rd,normalize(n+(rnd33(vec3(uv*1000.,iFrame*500))-.5)*.1 )));\n                p += n*0.05;\n                a *= 0.8;\n            }\n            else break;\n        }\n        p += O.d*rd;\n    }\n\n    float t = length(ro-p);\n    if (hit)\n    {\n        vec3 n = gn(p);\n        float ao = AO(p,n,.05)+AO(p,n,.15)+AO(p,n,.4);\n        float sp = spec(rd,l,n);\n\n        new_color = O.c*max(a,0.);\n        new_color *= ao/3.;\n        new_color += sp;\n    }\n    \n    new_color = mix(new_color, vec3(0.), 1.-exp(-0.001*t*t));\n    \n    return new_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;   \n    vec2 uu = fragCoord.xy/iResolution.xy;\n    \n    uv += (rnd33(vec3(uv*1000.,iFrame*50))-.5).xy/iResolution.y;  \n    vec3 ro = vec3(uv*5.,-20.), rd=vec3(.0,0.,1.),p=ro,\n    col=vec3(.0), l=normalize(vec3(-.1,1.2,-1.5));  \n    \n\tcol = raymarch_color(p, rd, ro, l, uv);   \n    \n    fragColor = vec4(col, 1.);\n    \n    if(iFrame>0)\n    {\n        fragColor += vec4(texture(iChannel0, uu).rgb, iFrame);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI acos(-1.)\n#define TAU (2.*PI)\n\n// Dave Hoskins noise function\n// https://www.shadertoy.com/view/4djSRW\nvec3 rnd33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n} ","name":"Common","description":"","type":"common"}]}