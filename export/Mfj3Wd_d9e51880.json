{"ver":"0.1","info":{"id":"Mfj3Wd","date":"1704834787","viewed":145,"name":"Separable Bokeh/DOF","username":"drcd1","description":"Implements morphological operations to produce a separable hexagonal bokeh filter in the style of \nhttps://dipaola.org/art/wp-content/uploads/2017/09/cgf2012.pdf","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["dof","bokeh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n\n    // Output to screen\n    vec3 col =  texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(toSRGB(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x<2.5 && fragCoord.y<2.5){\n        if(iFrame==0){\n            fragColor.xy = vec2(0.5);\n            return;\n        }\n        \n        if(iMouse.z>0.5){\n            fragColor.xy = iMouse.xy/iResolution.xy;\n        } else {\n            fragColor.xy = texture(iChannel0,vec2(0.0f)).rg;\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define PI 3.14159\nstruct Camera {\n\n    vec3 pos;\n    mat3 coords;\n    float tanfovy;\n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nRay getRay(vec2 coords, Camera c){\n    Ray r;\n    r.o = c.pos;\n    r.d = vec3(coords.x*iResolution.x/iResolution.y*c.tanfovy, coords.y*c.tanfovy, -1.0f);\n    r.d = c.coords*r.d;\n    r.d = normalize(r.d);\n    return r;\n\n}\n\n\nmat3 makeCoords(vec3 dir, vec3 up){\n    vec3 z =-dir;\n    vec3 x = normalize(cross(up,z));\n    vec3 y = normalize(cross(z,x));\n    return (mat3(x,y,z));\n\n}\nfloat sdf(vec3 p){\n\n mat3 rot1 = mat3(0.54595534,  0.44400524,  0.71048724,\n       -0.45747845,  0.86842817, -0.19117003,\n       -0.70188763, -0.2206623 ,  0.67724582);\n       \n mat3 rot2 = mat3( 0.09396874,  0.3996809 ,  0.91182512,\n        0.27293148, -0.89113105,  0.36248291,\n        0.95743317,  0.21480372, -0.19282396);\n\n\n\n\nvec3 p_orig = p;\n    float d1 = (length(p-vec3(0.2,0.0,0.0)));\n    float d2 = length(p-vec3(0.0,0.4,0.0));\n    \n    float ds = 10.0f;\n    \n    p = fract(p/ds);\n    p*=ds;\n    float d3 = length(p-vec3(0.5,0.5,0.5)*ds)-0.2;\n    \n    p = rot1*p_orig;\n    ds = 7.6;\n    p=fract(p/ds);\n    p = p*ds;\n    \n    float d4 = length(p-vec3(0.5,0.5,0.5)*ds)-0.2;\n    \n    \n    p = rot2*p_orig;\n    ds = 12.1;\n    p=fract(p/ds);\n    p = p*ds;\n    \n    float d5 = length(p-vec3(0.5,0.5,0.5)*ds)-0.2;\n  \n    d3 = min(min(d3,d4),d5);\n   // float d4 = length(p-vec3(1.0,-1.4,4.0));\n   // float d5 = length(p-vec3(-2.0,1.4,-2.0));\n   // float d6 = length(p-vec3(-3.0,1.4,2.0));\n    \n    float repeatD = max(length(p_orig)-ds*5.0,d3); \n    \n    \n    return min(min(d1-0.2,d2-0.4),repeatD);\n}\n\n\n\nvec3 sdfGrad(vec3 p){\n    float d = sdf(p);\n    return normalize(\n    vec3(\n    sdf(p+vec3(0.01,0.0,0.0))-d,\n    sdf(p+vec3(0.0,0.01,0.0))-d,\n    sdf(p+vec3(0.0,0.0,0.01))-d));\n\n}\n\nfloat noise(vec3 p){\n\n    float x = p.x+501.123*p.y+1203.51*p.z;\n    return sin(x*2041.2352) *0.5+0.5;\n\n}\n\nvec3 shade(vec3 p){\n    if(length(p)>1.0){\n        p = p+0.5-fract(p+0.5);\n        return vec3(noise(p), noise(p*2.0), noise(p*5.0))*5.0;\n    }\n    vec3 l = normalize(vec3(1.0,1.0,1.0));\n    vec3 n = sdfGrad(p);\n    vec3 col = vec3(0.2,0.1,0.1);\n    col += max(dot(n,l),0.0f)*vec3(0.8,0.8,0.8);\n    l = normalize(vec3(-1.0,0.5,0.5));\n    col += max(dot(n,l),0.0f)*vec3(0.1,0.4,0.8);\n    l = normalize(vec3(0.2,-0.5,0.5));\n    col += max(dot(n,l),0.0f)*vec3(0.4,0.2,0.1);\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera c;\n    vec2 sph = texture(iChannel0,vec2(0.0,0.0)).rg;\n    c.pos = vec3(cos(-sph.x*2.0f*PI)*sin(sph.y*PI),sin(-sph.x*2.0f*PI)*sin(sph.y*PI),cos(sph.y*PI));\n    c.pos*=7.0f;\n    \n    //c.pos = vec3(sph.x,sph.y,-3.0f);\n    c.tanfovy = 0.2f;\n    c.coords = makeCoords(normalize(-c.pos), vec3(0.0f,0.0f,1.0f));\n    \n    Ray r = getRay(fragCoord/iResolution.xy*2.0-1.0,c);\n    vec3 p = r.o;\n    vec3 col;\n    for(int i = 0; i<50; i++){\n        float d = sdf(p);\n        if(d<0.001){\n            col = shade(p);\n            fragColor = vec4(col,length(p)/1000.0);\n            return;\n        }else {\n            p = p+d*r.d;\n        }\n    \n    }\n    \n    \n    \n    vec3 dir = r.d.xzy;\n    dir.z = -dir.z;\n    col = fromSRGB(texture(iChannel1,dir).rgb);\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(fract(r.d.z)),1.0);\n    \n    \n    \n    \n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float toSRGBf(float col){\n\n    return pow(col,1.0/2.4);\n}\nfloat fromSRGBf(float col){\n    return pow(col,2.4);\n}\n\nvec3 toSRGB(vec3 col){\nreturn vec3(toSRGBf(col.x),toSRGBf(col.y),toSRGBf(col.z));\n}\nvec3 fromSRGB(vec3 col){\nreturn vec3(fromSRGBf(col.x),fromSRGBf(col.y),fromSRGBf(col.z));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n\n    // Output to screen\n    vec4 col =  texture(iChannel0, fragCoord/iResolution.xy).rgba;\n    \n    float thresh = 7.0;\n    \n    int samples = 10;\n    int totSamp = samples*2+1;\n    if(col.a*1000.0<thresh){\n    \n        fragColor = vec4((col.rgb),col.a);\n\n    } else {\n        float fac = 1.0/(float(totSamp*totSamp));\n        float w;\n        vec3 sum = vec3(0.0f);\n        for(int i = -samples; i<=samples; i++){\n            //for(int j = -samples; j<=samples;j++){\n                vec2 uv = vec2(float(i),0.0);\n                \n                uv.y*=iResolution.x/iResolution.y;\n                uv*=1.0/float(samples);\n                vec4 c = texelFetch(iChannel0, ivec2(fragCoord + uv*0.025*iResolution.xy),0).rgba;\n                if(c.a*1000.0>=thresh){\n                    sum+=c.rgb;\n                    w+=1.0;\n                }\n           // }\n        }\n        fragColor=vec4(sum/w,col.a);\n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n\n    // Output to screen\n    vec4 col =  texture(iChannel0, fragCoord/iResolution.xy).rgba;\n    \n    float thresh = 7.0;\n    \n    int samples = 10;\n    int totSamp = samples*2+1;\n    if(col.a*1000.0<thresh){\n    \n        fragColor = vec4((col.rgb),col.a);\n\n    } else {\n        float fac = 1.0/(float(totSamp*totSamp));\n        float w;\n        vec3 sum = vec3(0.0f);\n        for(int i = -samples; i<=samples; i++){\n            //for(int j = -samples; j<=samples;j++){\n                vec2 uv = vec2(float(i)*0.5,float(i));\n                \n                uv.y*=iResolution.x/iResolution.y;\n                uv*=1.0/float(samples);\n                vec4 c = texelFetch(iChannel0, ivec2(fragCoord+ uv*0.025*iResolution.xy),0).rgba;\n                if(c.a*1000.0>=thresh){\n                    sum+=c.rgb;\n                    w+=1.0;\n                }\n            //}\n        }\n        sum = sum/w;\n        vec3 sum2=vec3(0.0f);\n        w=0.0;\n        for(int i = -samples; i<=samples; i++){\n            //for(int j = -samples; j<=samples;j++){\n                vec2 uv = vec2(-float(i)*0.5,float(i));\n                \n                uv.y*=iResolution.x/iResolution.y;\n                uv*=1.0/float(samples);\n                vec4 c = texelFetch(iChannel0, ivec2(fragCoord+ uv*0.025*iResolution.xy),0).rgba;\n                if(c.a*1000.0>=thresh){\n                    sum2+=c.rgb;\n                    w+=1.0;\n                }\n            //}\n        }\n        sum2 /=w;\n        fragColor=vec4(min(sum,sum2),col.a);\n    }\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}