{"ver":"0.1","info":{"id":"MdlBWH","date":"1496088697","viewed":17603,"name":"The Mountain","username":"banthar","description":"Animated 80s style album cover \"inspired\" by https://gunshipmusic.bandcamp.com/.\nLook around with mouse.","likes":80,"published":1,"flags":96,"usePreview":1,"tags":["procedural","ray","80s","music","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdlSWn","filepath":"https://soundcloud.com/gunshipmusic/gunship-the-mountain-april-towers-remix-final-master","previewfilepath":"https://soundcloud.com/gunshipmusic/gunship-the-mountain-april-towers-remix-final-master","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 6.28318530718;\n\nmat4 perspective(float r, float t, float f, float n) {\n    return mat4(\n\t\t  r,  0,      0,       0,\n\t\t  0,  t,      0,       0,\n\t\t  0,  0,(f+n)/(n-f),   -1,\n\t\t  0,  0,(f*n)/(n-f), 0\n        );\n}\n\nmat4 rotateX(float a) {\n    return mat4(\n        1,0,0,0,\n\t\t0,cos(a),-sin(a),0,\n\t\t0,sin(a),cos(a),0,\n\t\t0,0,0,1);\n}\n\n\nmat4 rotateY(float a) {\n    return mat4(\n\t\tcos(a),0,sin(a),0,\n\t\t0,1,0,0,\n\t\t-sin(a),0,cos(a),0,\n\t\t0,0,0,1\n    );\n}\n\nmat4 rotateZ(float a) {\n    return mat4(\n\t\tcos(a),-sin(a),0,0,\n\t\tsin(a),cos(a),0,0,\n\t\t0,0,1,0,\n\t\t0,0,0,1\n    );\n}\n\nmat4 translate(vec3 v) {\n\treturn mat4(\n\t\t1,0,0,0,\n\t\t0,1,0,0,\n\t\t0,0,1,0,\n\t\tv.xyz,1\n    );\n}\n\nvec4 gridI(vec4 b) {\n    float p = 0.1;\n    return floor(b)*p + max(fract(b)-1.0+p, 0.0);\n}\n\nfloat crtI(float x) {\n    return 0.5 * x - 0.5*cos(x*2.0);\n}\n\nvec4 grid(vec4 b) {\n    vec4 fw = fwidth(b)*2.0;\n    vec4 p = (gridI(b+fw) - gridI(b))/fw;\n    float line = max(p.x,p.y);\n\n    fw*=4.0;\n    vec4 q = (gridI(b+fw) - gridI(b))/fw;\n    float shadow = max(q.x,q.y);\n\n    \n    float f = b.y * 32.0;\n    float df = fwidth(f)*10.0;\n    float crt = (crtI(f+df)-crtI(f)) / df / sqrt(b.z)*.25+.1;\n    \n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    \n    color = max(color, vec4(.9,.3,.4,1.0)*line);\n    color = max(color, vec4(.4,.3,.9,1.0)*shadow);\n    color = max(color, vec4(.5,.0,1.0,1.0)*crt);\n    \n    return color;\n}\n\nvec4 star_plane(vec2 uv) {\n    uv = uv.xy + uv.yx*vec2(1,-1);\n    vec2 res = vec2(iChannelResolution[1]);\n    vec2 pos = uv*res;\n    vec2 cell_center = floor(pos)+.5;\n    vec4 q = textureLod(iChannel1, cell_center/res, 0.0);\n    q*=q;\n    float blue = q.x;\n    float f = 0.25;\n    return vec4(1.0-blue*f,1.0-blue*f,1.0-f*(1.0-blue),1)*clamp(q.t *8.0 * (0.25*q.z-distance(pos - cell_center, (q.xy-.5)*.5/q.z)),0.0,1.0);\n}\n\n\nvec4 star_dust_plane(vec2 uv) {\n    vec2 res = vec2(iChannelResolution[1]);\n    float q = texture(iChannel1, uv*0.5).r*0.25 + texture(iChannel1, uv*0.25).r*0.75;\n    float n = mix(1.0, texture(iChannel1, uv*32.0).r, 0.5);\n    return vec4(0.1,0.1,0.2,1)*q*n;\n    return vec4(0.1,0.1,0.2,1) * n * smoothstep(0.25,0.75,q);\n}\n\nvec4 stars(vec3 eye) {\n    eye /= max(abs(eye.x),max(abs(eye.y),abs(eye.z)));\n    vec3 eye_m = abs(eye);\n    vec2 pq;\n    if(eye_m.x > eye_m.y && eye_m.x > eye_m.z) {\n        pq = eye.yz;\n    } else if(eye_m.z > eye_m.x && eye_m.z > eye_m.y) {\n        pq = eye.xy;\n    } else if(eye_m.y > eye_m.x && eye_m.y > eye_m.z) {\n        pq = eye.zx;\n    }\n    vec2 st = fract(pq*16.0);\n    vec4 fragColor = star_plane(pq*0.2);\n\tfragColor += star_plane(pq*0.1);\n\treturn fragColor;    \n}\n\n\nvec4 sun(vec2 uv) {\n    float h = min(uv.y-0.1,0.)+0.8;\n    float r = max(length(uv),min(.51,(1.0+sin(max(h*h*64.0,0.)))*.5));\n    vec4 a = vec4(1.0,0.2,0.4,1.0);\n    vec4 b = vec4(1.0,0.9,0.3,1.0);\n    float c = uv.y+0.5-uv.x*.25;\n    c += length(uv)*length(uv)*.5;\n    float n = 0.0;\n    n = (texture(iChannel1, uv*.5).r);\n    n += (texture(iChannel1, uv*.2).r)*2.0;\n    n += (texture(iChannel1, uv*.05).r)*4.0;\n    n += (texture(iChannel1, uv*.02).r)*7.0;\n    c += ((n/14.0)-.5)*.25;\n    vec4 sun = mix(a,b,c);\n    vec4 sky = vec4(1.0,0.2,0.4,clamp(0.5-(r-.5)*1.0,0.0,1.0));\n    \n    float a0 = sin(max(h*h*64.0,0.))*0.005/fwidth(uv.y);\n    float a1 = length(uv);\n    float f = smoothstep(0.5,0.5 + length(fwidth(uv)), a1);\n    return mix(sun, sky, max(min(1.0,a0),f));\n}\n\n\nconst float F = (sqrt(3.0)-1.0)/2.0;\n\n\nfloat height(vec2 uv) {\n    return textureLod(iChannel1, uv/100.0, 0.).r -0.1;\n}\n\nfloat elev_s(vec2 uv) {\n    float f = cos((uv.x+uv.y)*0.2);\n    f=0.2+f*f*0.7;\n\treturn max(0.15, f* (5.0 - abs(20.0 - length(uv)) + height(uv/4.0)*4.0));\n}\n\nfloat elev(vec2 uv) {\n    return elev_s(uv-uv.yx * (1.0-2.0*F));\n}\n\nvec4 mountain2(vec3 pos, vec3 normal) {\n    pos.xy += normal.xy * 0.0;\n    float F = (sqrt(3.0)-1.0)/2.0;\n\tpos.xy += (pos.x + pos .y) * F;\n\tnormal.xy += (normal.x + normal.y) * F;\n    \n    vec3 s = sign(normal.xyz);\n\tvec3 sn = (s + 1.0 ) /2.0;\n    vec2 ipos = floor(pos.xy);\n    vec3 fpos = pos - vec3(ipos,0.0);\n\n    float e0 = 0.0;\n    vec3 pos0 = vec3(0.0, 0.0, 0.0);\n    \n    const int d = 50;\n    float f0 = 0.0;\n    for(int i=0;i<d;i++) {\n        float e1;\n        \n        vec2 old_ipos = ipos;\n        \n        vec3 a = ((s+1.)/2. - s*fpos)/normal*s;\n        if(a.x >= a.y) {\n            if(fpos.x * s.y <= fpos.y * s.y) {\n            \tfpos += normal * a.y;\n            \tfpos.y = -(s.y - 1.)/2.;\n            \tipos.y += s.y;\n                e1 = mix(elev(ipos.xy + vec2(0,1.0-sn.y)), elev(ipos.xy+ vec2(1,1.0-sn.y)), fpos.x);\n            } else {\n                fpos += (fpos.x-fpos.y)/(normal.y-normal.x) * normal;\n                fpos.y = fpos.x;\n                e1 = mix(elev(ipos.xy + vec2(0,0)), elev(ipos.xy+ vec2(1,1)), fpos.x);\n            }\n        } else {\n            if(fpos.x *s.x >= fpos.y * s.x) {\n            \tfpos += normal * a.x;\n            \tfpos.x = -(s.x - 1.)/2.;\n            \tipos.x += s.x;\n                e1 = mix(elev(ipos.xy + vec2(1.0-sn.x,0)), elev(ipos.xy+ vec2(1.0-sn.x,1)), fpos.y);\n            } else {\n                fpos += (fpos.x-fpos.y)/(normal.y-normal.x) * normal;\n                fpos.y = fpos.x;\n                e1 = mix(elev(ipos.xy + vec2(0,0)), elev(ipos.xy+ vec2(1,1)), fpos.x);\n            }\n        }\n\n        vec3 pos1 = fpos + vec3(ipos,0);\n        f0 = max(f0, (0.05 - distance(e1, fpos.z))*20.0);\n        if(e1 >= fpos.z) {\n            float t = (e0 - pos0.z) / (pos1.z - pos0.z - e1 + e0);\n            vec3 fpost = pos0 + t * (pos1 - pos0);\n            vec2 uv = fract(fpost.xy);\n            vec2 fv = abs(uv-0.5) * 2.0;\n            float f = max(max(fv.x, fv.y), 1.0-2.0*abs(uv.x-uv.y));\n            \n            float tq = 0.9;\n            \n            float p = smoothstep(tq, tq*1.1, f) + 0.05 * smoothstep(0.5, 1.0, f);\n            p = max(p,f0);\n            float q = 0.6 * max(0.0,elev(floor(fpost.xy) + vec2(0,0)) - elev(floor(fpost.xy)+ vec2(1,0)));\n            \n            return vec4(max(mix(vec3(1,1,1), vec3(0.05,0.7,0.93), 1.0-0.1*fpost.z)*p, vec3(0.15,0.3,0.5)*q),1);\n        }\n\t\te0 = e1;\n        pos0 = pos1;\n        \n    }\n    return vec4(0.05,0.7,0.93,f0);\n}\n\nconst float speed = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 pos = texture(iChannel2, vec2(0.5,0.5)/iChannelResolution[2].xy).xyz;\n    vec3 rot = texture(iChannel2, vec2(1.5,0)/iChannelResolution[2].xy).xyz;\n    float yaw = rot.x;\n    float pitch = -rot.y;\n    float l = 319.0;\n    float t = fract(iTime/319.0*speed);\n    vec4 eye = vec4(0,t*400.0,1,0);\n\tvec4 screen = vec4((fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y), 2.0, 1.0);\n    vec4 eyeV = normalize(rotateZ(yaw)*rotateX(pitch)*screen);\n    vec4 floorHit = vec4((eye+eyeV*eye.z/eyeV.z).xy, eye.z/eyeV.z, 1.0);\n    vec4 horizon = vec4(0,1,0,0);\n    if(floorHit.z>0.0) {\n   \t\tfragColor = grid(floorHit);\n    } else {\n        vec4 skyV = rotateX(t-0.4)*rotateZ(-t*0.1)*eyeV;\n\t    vec4 skyHit = vec4((horizon+skyV*horizon.y/skyV.y).xz, horizon.y/skyV.y, 1.0);\n        vec4 air = mix(vec4(0.2,0.5,1.0,1.0)*(1.0-t),vec4(1.0-t,0.2,1.0-0.5*t,1),skyV.y);\n        fragColor = max(air*(1.0-t), t*stars(skyV.xyz));\n        if(skyV.y > 0.01) {\n        \tvec4 sunColor = sun(skyHit.xy*-1.0+0.0*vec2(0,mix(-0.6,0.5,t)));\n        \tfragColor = mix(fragColor, sunColor, sunColor.a);\n        }\n        eyeV.xy *= -1.0;\n        vec4 mountainColor = mountain2(eye.xyz*vec3(0.01,0.01,0.12) - eyeV.xyz*5.0, -eyeV.xyz);\n        fragColor = mix(fragColor, mountainColor, mountainColor.a);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float tau = 6.28318530718;\n\nmat4 rotateX(float a) {\n    return mat4(\n        1,0,0,0,\n\t\t0,cos(a),-sin(a),0,\n\t\t0,sin(a),cos(a),0,\n\t\t0,0,0,1);\n}\n\n\nmat4 rotateY(float a) {\n    return mat4(\n\t\tcos(a),0,sin(a),0,\n\t\t0,1,0,0,\n\t\t-sin(a),0,cos(a),0,\n\t\t0,0,0,1\n    );\n}\n\nmat4 rotateZ(float a) {\n    return mat4(\n\t\tcos(a),-sin(a),0,0,\n\t\tsin(a),cos(a),0,0,\n\t\t0,0,1,0,\n\t\t0,0,0,1\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragCoord -= 0.5;\n    if(fragCoord.x < 3.0 ) {\n    if(iFrame == 0) {\n        if(fragCoord.x == 0.0 ) {\n    \t\tfragColor.rgb = vec3(0,0,0);\n        } else {\n    \t\tfragColor.rg = vec2(0,-1.9);\n        }\n        return;\n    }\n        \n        vec3 old_pos = texture(iChannel0, vec2(0.5,0)/iChannelResolution[0].xy).xyz;\n        vec2 old_rot = texture(iChannel0, vec2(1.5,0)/iChannelResolution[0].xy).xy;\n        vec2 old_abs_rot = texture(iChannel0, vec2(2.5,0)/iChannelResolution[0].xy).xy;\n\n        \n        vec2 rot;\n        if(iMouse.z >= 0.0) {\n        \tvec2 mouse = 0.25 * tau * (iMouse.xy-abs(iMouse.zw)) / min(iResolution.x,iResolution.y);\n            rot = old_abs_rot + mouse * vec2(-1,1);\n            rot.y = clamp(rot.y, -0.5*tau, 0.0);\n        } else {\n            rot = old_rot;\n            old_abs_rot = old_rot;\n        }\n\n        \n\t    vec4 v = vec4(\n\t    \ttexture(iChannel1, vec2(68.0/255.0,0)).r - texture(iChannel1, vec2(65.0/255.0,0)).r,\n\t        0,\n            texture(iChannel1, vec2(87.0/255.0,0)).r - texture(iChannel1, vec2(83.0/255.0,0)).r,\n            0\n    \t) * 0.1;\n        \n        vec3 pos = old_pos + (rotateZ(rot.x)*rotateX(rot.y)*v).xyz;\n\n        \n        if(fragCoord.x == 0.0 ) {\n    \t\tfragColor.rgb = pos;\n        } else if(fragCoord.x == 1.0 ) {\n    \t\tfragColor.rg = rot;\n        } else if(fragCoord.x == 2.0 ) {\n    \t\tfragColor.rg = old_abs_rot;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}