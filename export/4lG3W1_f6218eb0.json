{"ver":"0.1","info":{"id":"4lG3W1","date":"1474321129","viewed":145,"name":"Ray-tracing","username":"Sabouh","description":"Ray-tracing \n\nYou can change properties of each objects in the function line 243\n\nYou can move the camera using your mouse\n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","transparent","mirror","rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Inspired by inigo quilez's articles\n https://iquilezles.org/articles/distfunctions\n + Romain Vergne's lectures \n Shader : Ray-Tracing\n Author : Sabouh \n*/\n \n//to get a higher float precision\nprecision highp float;\nconst float PI = 3.1415926535897932384626433832795;\nconst int PLANE_NB = 3;\nconst int SPHERE_NB = 5;\nconst int OBJ_NB = PLANE_NB + SPHERE_NB;\nconst int LIGHT = OBJ_NB +1;\nconst int LIGHT2 = LIGHT +1;\nconst int LIGHT_NB = 2;\nconst int MAX_NB = 10;\nconst float MAX_VALUE = 100.;\nconst int MAX_INT_VALUE = 50;\nconst int STEP_NB =6;\nconst vec4 background = vec4(0.,0.,0.,1.);\n\n//*******************************Tools**************************\n//Structures definition\n\n//Light\nstruct Light{\n\tvec3 p;//position\t\n};\n\n//MarchingPack\nstruct MarchingPack{\n\tfloat dist;\n\tfloat index;\n\tbool hit;\n\t\n};\n    \n    \n//Properties\nstruct Properties{\n\tvec3 specColor; //specular color\n\tfloat roughness; //roughness\n\tbool reflective; //is reflective\n    float c_refl; //reflective coefficient\n    bool transmissive; //is transmissive\n    float c_trans;//transmissive coefficient\n    int distrib;//distribution {1,2,3}\n    int geom;//geom func {1,2}\n\t\n};\n\n//Ray\nstruct Ray{\n\tvec3 o; //origin\n\tvec3 d; //direction\n};\n\n//Camera\nstruct Camera{\n\tvec3 e;//eye\n    vec3 r;//right\n    vec3 u;//up\n    vec3 v;//view\n\t\n};\n\nstruct Color{\n\tvec4 c;\n};\n\n//Plane\nstruct Plane{\n\tvec3 n; //normal\n\tfloat d; //offset\n};\n\n//Sphere\nstruct Sphere{\n\tvec3 c; //center\n\tfloat r; //rayon\n};\n\n//Distance functions\n\nfloat sdSphere( vec3 p, vec4 o){\n    float dist = length(o.xyz-p) - o.w;\n    return dist;\n}\n\n\n//n.xyz is the normal and n.w the offset\nfloat sdPlane( vec3 p, vec4 n ){\n    \n  n.xyz = normalize(n.xyz);\n    vec3 q = n.w* n.xyz;\n  return dot(q-p,n.xyz) + n.w;\n}\n\n\nfloat sdSphereOrigin( vec3 p, float s){\n\treturn length(p)-s;\n}\n\nfloat sdPlaneFlat( vec3 p )\n{\n  return p.y;\n}\n\n\n//Distance operations\n\n//union\nvec2 opU(vec2 d1,vec2 d2){\n\treturn d1.x<d2.x ? d1 : d2; //if d1.x < d2.x return d1 else d2\n}\n\n//substraction\nfloat opS(float d1, float d2){\n\treturn max(-d1,d2);\n}\n\n//intersection\nfloat opI(float d1,float d2){\n\treturn max(d1,d2);\n}\n\n\n//OTHER\n\n//intersection Ray-Sphere\nvec2 intersectSphere(Ray r, vec4 o, float index){\n\tfloat a,b,c;\n\ta = dot(r.d,r.d);\n\tb = dot(2.*(r.o-o.xyz),r.d);\n\tc =(dot(r.o-o.xyz,r.o-o.xyz)) - pow(o.w,2.) ;\n\t\n\tfloat delta =  pow(b,2.)-4.*a*c ;\n\tif(delta <0.){\n\t\treturn vec2(MAX_VALUE,-1);\n\t}else{\n\t\tfloat t1,t2;\n\t\tt1 = (-b + sqrt(delta) )/(2.*a);\n\t\tt2 = (-b - sqrt(delta) )/(2.*a);\n\t\tif(t1 <0.){\n\t\t\treturn vec2(t2,index);\n\t\t}else if(t2<0.){\n\t\t\treturn vec2(t1,index);\n\t\t}else{\n\t\t\treturn t1<=t2 ? vec2(t1,index) : vec2(t2,index);\n\t\t}\n\t}\n}\n\n//intersection Ray-Plane\nvec2 intersectPlane(Ray r, vec4 n,float index){\n    vec3 norm = normalize(n.xyz);\n\tfloat t = -( n.w + dot(r.o,norm)) / dot(r.d,norm);\n\tif(t>=0.){\n\t\treturn vec2(t,index);\n\t\t\n\t}else{\n\t\treturn vec2(MAX_VALUE,-1);\n\t}\n}\n\n\n//Init\nvec4 getColor(float index){\n\t//vec4 colors[OBJ_NB] colors = vec4[](vec4(1,0,0,1),vec4(0,0,1,1));\n\tif(index == 1.){\n\t\treturn vec4(0.,1.,1.,1.); //cyan 3\n\t}else if(index == 2.){\n\t\treturn vec4(0.,1.0,0.,1.); //green 2\n\t}else if(index == 3.){\n\t\treturn vec4(0.,0.,1.,1.); //blue 1\n\t}else if(index == 4.){\n\t\treturn vec4(1.,0.,0.,1.); //red 4\n\t}else if(index == 5.){ \n\t\treturn vec4(1.,0.,1.,1.); //magenta 5\n\t}else if(index == 6.){ \n\t\treturn vec4(1.,1.,0.,1.); //yellow 6\n\t}else if(index == 7.){ \n\t\treturn vec4(0.1,0.,0.,1.); //blood red 7\n\t}else if(index == 8.){ \n\t\treturn vec4(0.1,0.1,0.1,1.); // 7\n\t}else if(index == float(LIGHT)){ \n\t\treturn vec4(1.,0.,0.,0.); //yellow\n\t}else if(index == float(LIGHT2)){ \n\t\treturn vec4(1.,0.,0.,0.); //yellow\n\t}else{\n\t\treturn background;//ERROR WHITE\n\t\t\n\t}\n}\n\nvec4 createSphere(vec3 c, float r, float phi, float teta){\n\tfloat x,y,z;\n\tx = c.x + r*sin(phi)*cos(teta);\n\ty = c.y + r*sin(phi)*sin(teta);\n\tz = c.z + r*cos(phi);\n    return vec4(x,y,z,r);\n    \n}\n\n\nvec4 getObject(float index){\n    vec4 res ;\n\tif(index == 1.){\n\t\tres =  vec4(0.,0.,1.,0.); //Plan (x,y)\n\t}else if(index == 2.){\n\t\tres = vec4(1.,0.,0.,0.); //Plan (y,z)\n\t}else if(index == 3.){\n\t\tres = vec4(0.,1.,0.,0.); //Plan (x,z)\n\t}else if(index == 4.){\n\t\tres = createSphere(vec3(-10.,10.,2.),1., PI/2.*iTime, PI/2.); \n\t\t//res = createSphere(vec3(2.,2.,2.),0.5, PI, PI); \n\t}else if(index == 5.){ \n\t\tres = createSphere(vec3(-2.,2.,2.),1., PI/2., PI); \n\t\t//res = createSphere(vec3(-2.,2.,2.), 0.5, PI, PI);\n\t}else if(index == 6.){ \n\t\tres = createSphere(vec3(-10.,5.,4.), 1., PI/2.*iTime, PI); \n\t\t//res = createSphere(vec3(2.,-2.,2.), 0.5, PI, PI);\n\t}else if(index == 7.){ \n\t\tres = createSphere(vec3(10.,10.,2.), 0.8, PI/2.*iTime, PI); \n\t\t//res = createSphere(vec3(10.,10.,2.),1., PI, PI);\n\t}else if(index == 8.){ \n\t\tres = createSphere(vec3(-2.,2.,10.), 1., PI/2.*iTime, PI); \n\t\t//res = createSphere(vec3(-2.,2.,10.), 1., PI, PI);\n\t}else if(index == float(LIGHT)){ \n\t\tres = createSphere(vec3(-1.,2.,5.),1., PI, PI); \n\t}else if(index == float(LIGHT2)){ \n\t\tres = createSphere(vec3(1.,2.,5.),1., PI, PI); \n\t}else{\n\t\tvec4 res = vec4(MAX_VALUE,MAX_VALUE,MAX_VALUE,MAX_VALUE);//ERROR \n\t\t\n\t}\t\n    return res;\n}\n\n//return Properties of the object\n//Properties( specColor, roughness, reflective, c_refl,transmissive, c_trans,distrib,geom)\nProperties getProperties(float index){\n    \n\tif(index == 1.){\n\t\treturn Properties(vec3(1.,1.,1.),0.1,true,1.,false,0.,1,1); //cyan 3\n\t}else if(index == 2.){\n\t\treturn Properties(vec3(1.,1.,1.),1.,false,0.7,true,1.,1,2); //green 2\n\t}else if(index == 3.){\n\t\treturn Properties(vec3(1.,1.,1.),5.,true,0.5,false,1.,2,1); //blue 1\n\t}else if(index == 4.){\n\t\treturn Properties(vec3(1.,1.,1.),5.,true,1.,false,0.,2,2); //red 4\n\t}else if(index == 5.){ \n\t\treturn Properties(vec3(1.,1.,1.),3.,false,0.,false,0.,3,1); //magenta 5.\n\t}else if(index == 6.){ \n\t\treturn Properties(vec3(1.,1.,1.),0.1,true,1.,false,0.,1,2); //yellow 6\n\t}else if(index == 7.){ \n\t\treturn Properties(vec3(1.,1.,1.),1.,false,0.,false,0.,1,1); //blood red 7\n\t}else if(index == 8.){ \n\t\treturn Properties(vec3(1.,1.,1.),1.,false,0.,true,1.45,1,2); // grey 7\n\t}else if(index == float(LIGHT)){ \n\t\treturn Properties(vec3(1.,0.,0.),0.,false,1.,false,0.,0,0); //yellow\n\t}else if(index == float(LIGHT2)){ \n\t\treturn Properties(vec3(1.,0.,0.),0.,false,1.,false,0.,0,0);//yellow\n\t}else{\n        //ERROR\n\t\treturn Properties(vec3(0.,0.,0.),0.,false,0.,false,0.,0,0); \n\t\t\n\t}\n}\n\n\nvec3 getNormal2(Camera c,vec3 pos, float index){\n    vec3 n;\n    if(index <= float(PLANE_NB)){\n        n = normalize( getObject(index).xyz );\n    }else{\n       \tn = normalize( pos - getObject(index).xyz );\n    }\n    return n;\n}\nvec3 getNormal(Camera c,vec3 pos, float index){\n    vec3 n;\n    if(index <= float(PLANE_NB)){\n        n = normalize( getObject(index).xyz );\n        if(dot(n,c.e) <0.){\n            n = -n;\n        }\n    }else{\n       \tn = normalize( pos - getObject(index).xyz );\n    }\n    return n;\n}\n\nfloat getIntensity(vec3 pos,vec3 l,vec3 n,float index){\n    float intensity;\n    if(index <= float(PLANE_NB)){\n\t\t\n        intensity =   max( dot(normalize(l -pos),n),dot(normalize(l -pos),-n))   ;\n    }else{\n        intensity =   dot(normalize(l -pos),n)  ;\n    }\n    return intensity;\n}\n\n\n\n//-------------------------------------------------------------------------------------\n//Fresnel coef (here Schlick)\nvec3 F(vec3 color, vec3 l,vec3 h){\n    return color +(1.-color)*pow(1.-dot(l,h),5.);\n}\n\n\n// Cook-Terrance\nfloat Gct(vec3 l, vec3 v,vec3 h, vec3 n){\n    \n    return min(1., min( (2.*dot(n,h)*dot(n,v))/dot(v,h) , (2.*dot(n,h)*dot(n,l))/dot(v,h) ));\n}\n\n\n// implicit function G\nfloat Gimpl(vec3 l, vec3 v,vec3 m,vec3 n){\n    return dot(n,l)*dot(n,v);\n}\n\n//shadowing func\nfloat G(vec3 l, vec3 v,vec3 m,vec3 n,float index){\n    int geom = getProperties(index).geom;\n    if(geom == 1){\n    \treturn Gimpl(l,v,m,n);\n    }\n    if(geom == 2){\n    \treturn Gct(l,v,m,n);\n    }\n    \n    return Gct(l,v,m,n);\n}\n\n\n//GGX\nfloat Dtr(vec3 m,vec3 n,float index){\n\tfloat alpha = getProperties(index).roughness;\n    float scal = dot(n,m);\n    return pow(alpha,2.) /(PI*pow(pow(dot(n,m),2.)*(pow(alpha,2.)-1.)+1.,2.) );\n}\n\n//Beckmann\nfloat Db(vec3 m,vec3 n,float index){\n\tfloat alpha = getProperties(index).roughness;\n    float scal = dot(n,m);\n    return 1./( PI*pow(alpha,2.)*pow(scal,4.)) * exp(-( (1.-pow(scal,2.))/( pow(alpha,2.)*pow(scal,2.))) );\n}\n\n\n//Phong\nfloat Dp(vec3 m,vec3 n,float index){\n\tfloat alpha = getProperties(index).roughness;//rugosite de l'objet (+ alpha est gd + mat est spec)\n    return (alpha+2.)/(2.*PI)*pow(dot(n,m),alpha);\n}\n\n//distribution\nfloat D(vec3 m,vec3 n,float index){\n    m = m/2.;\n    int distrib = getProperties(index).distrib;\n    if(distrib==1){\n        return Dp(m,n,index);\n    }\n    if(distrib==2){\n\t\treturn Db(m,n,index);\n    }\n    if(distrib==3){\n\t\treturn Dtr(m,n,index);\n    }\n\treturn Dp(m,n,index);\n}\n\n//microfacettes theories\nvec3 spec(vec3 l, vec3 v,vec3 n,float index){\n\tvec3 h = normalize(l+v);\n    vec3 f0 = getProperties(index).specColor;\n    return ( F(f0,l,h)*G(l,v,h,n,index)*D(h,n,index) )/( 4.*dot(n,l)*dot(n,v) );\n\n}\n\n//lambert\nvec3 diff(vec3 l, vec3 v,vec3 n,float index,vec3 color){\n\t//vec3 h = normalize(l+v);\n    \n    return color/PI;\n\n}\n\nvec3 brdf(vec3 l,vec3 v,vec3 n, vec3 color, float index){\n\treturn diff(l,v,n,index,color)+spec(l,v,n,index);\n}\n\n\n//------------------------------------------------------------------\n\n//Direct Illumination 1 light, diffus\nvec4 directIllum(Camera c,Light l,vec3 pos,float dist, float index,float D){\n\t//compute the normal\n\tvec3 n = getNormal2(c,pos,index);\n\t//compute intensity\n    float intensity = getIntensity(pos,l.p,n,index);\n    if(intensity <=0.){\n        intensity = 0.*PI;\n    }else{\n        intensity = PI*intensity;\n    }\n    \n\tfloat t ;\n\tvec4 obj;\n\tvec3 color;\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\t color = getColor(index).xyz;\n    }else if(mod(iTime,9.) <6. ){\n    \t//height map\n        float h = (dist/(D));\n     \tcolor = vec3(h,h,h);\n    }else{\n    \t//normal map\n        color = n;\n    }\n    vec3 newColor = intensity * brdf(normalize(l.p-pos),normalize(c.e-pos), n, color,index);\n    return vec4(newColor,1.);\n}\n\n\n\nvec4 displayColor(vec3 pos,float dist, float index,float D){\n\t\n\t\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\treturn getColor(index);\n    }else if(mod(iTime,9.) <6. ){\n    \t//height map\n        float h = dist/(D);\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4((getObject(index)).xyz,1.0) ;\n    \t}else{\n        \tvec3 n = pos - getObject(index).xyz;\n\t\t\treturn vec4(n,1.0);\n    \t}\n    }\n\t\n}\n//------------------------------------------------------\n\n\n//manage intersections \nvec2 checkIntersection(Ray r, vec4 o, float index){\n\tif(index <= float(PLANE_NB) ){\n\t\treturn intersectPlane(r,o,index);\n\t}else{\n\t\treturn intersectSphere(r,o,index);\n\t}\n}\n\nbool isOk(float prevIndex, float interIndex){\n    Properties propPrev;\n    Properties propInter = getProperties(interIndex);//properties of the intersected obj\n\t\tif(prevIndex !=-1.){\n            propPrev = getProperties(prevIndex);//properties of the point of origin \n\t\t}\n\t\treturn \n\t\t(prevIndex == -1.\n         \t||( prevIndex !=-1. \n\t\t\t\t&&(\n\t\t\t\t\t( propInter.reflective && propPrev.reflective && interIndex != prevIndex) //reflection of reflective obj\n                    ||( propInter.reflective && propPrev.transmissive && interIndex != prevIndex) //refraction of reflective obj\n\t\t\t\t\t||( propInter.transmissive && propPrev.reflective && interIndex != prevIndex) //reflection of transsmissive obj\n                    ||( propInter.transmissive && propPrev.transmissive && interIndex != prevIndex) //refraction of transmissive obj\n\t\t\t\t\t\n                    ||(!propInter.reflective && !propInter.transmissive && propPrev.reflective && interIndex!= prevIndex) //reflection of opaque object\n\t\t\t\t\t||(!propInter.reflective && !propInter.transmissive && propPrev.transmissive && interIndex!=prevIndex) //refraction of opaque object\n                   \n\t\t\t\t)\n\t\t\t)\n\t\t);\n     \n}\n\n//RayCasting\nMarchingPack rayC(Ray r,float index){\n\t//cast a ray w/ camera\n    float t = 0.;\n\tfloat t1 = 0.1;\n\tvec3 pos; \n    \t\n\tvec2 minDist = vec2(MAX_VALUE,-1);\n\tvec2 maxDist = vec2(-1,-1);\n    \n\tfloat j;\n    Properties prop ,propIndex;\n    //for each object of the scene\n\tfor(int i=1; i<=OBJ_NB ;i++){\n\t\t//test intersection btw ray and object\n\t\tj=float(i);\n        vec2 dist = checkIntersection(r,getObject(j),j);\n        \n            \n        if( dist.x >=0. && dist.y !=-1. && isOk(index,dist.y)){\n        \tif( dist.x < minDist.x){\n            \tminDist = dist;\n            }\n        }\n        \n    \t\n\t}\n\t//compute pixel colour\n    MarchingPack cp ;\n    if(minDist.y == -1.){\n    \tcp = MarchingPack(minDist.x,minDist.y,false);\n    }else{\n    \tcp = MarchingPack(minDist.x,minDist.y, true);\n    }\n    \n    return cp;\n}\n\n\n\n//RayCasting\nMarchingPack rayCL(Ray r,Light l,float index){\n\tvec3 pos; \n    \t\n\tvec2 minDist = vec2(length(r.o-l.p),-1);\n\tvec2 maxDist = vec2(-1,-1);\n    \n\tfloat j;\n    //for each object of the scene\n\tfor(int i=1; i<=OBJ_NB ;i++){\n\t\t//test intersection btw ray and object\n\t\tj=float(i);\n        if(j != index){\n            vec2 dist = checkIntersection(r,getObject(j),j);\t\n            //remember the object if dist < previous tests\n            if(dist.y != -1. && dist.x < minDist.x){\n                minDist = dist;\n            }\n       }\n\t}\n\t//compute pixel colour\n    MarchingPack cp ;\n    if(minDist.y == -1.){\n    \tcp = MarchingPack(minDist.x,minDist.y,false);\n    }else{\n    \tcp = MarchingPack(minDist.x,minDist.y, true);\n    }\n    \n    return cp;\n}\n\n                               \n//-------------------------------------------------------\n\n\n//Direct Illumination 1 light, diffus\nvec3 directIllumination(Camera c,vec3 pos, float dist, float index,float D){\n\tvec3 color = vec3(0.,0.,0.);\n    Light l;\n    Ray shadowRay;\n    MarchingPack rmpl;\n    for(int i=1; i<= LIGHT_NB;i++){\n        l = Light(getObject(float(OBJ_NB+i)).xyz);\n\t\tshadowRay = Ray(pos,normalize(l.p-pos));\n    \trmpl = rayCL(shadowRay,l,index);\n        if(!rmpl.hit){\n\t\t\tcolor += directIllum(c,l, pos, dist,  index, D).xyz;\n        }\n    }\n\treturn color/float(LIGHT_NB);\n}\n                        \n//ray Tracing\nvec4 rayTracing(vec2 fragCoord){\n\t//cast a ray w/ camera\n\t\n\t//(x,y) in range [-1;1] \n\tfloat x = (2.*fragCoord.x - iResolution.x )/iResolution.x;\n\tfloat y = (2.*fragCoord.y - iResolution.y )/iResolution.y;\n   \n\tfloat xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;\n\tfloat yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;\n\t\n\t//camera\n\tCamera c;\n    vec3 u1;\n\t//c.e = vec3(xMouse*15.,yMouse*15.,15.);//cam position\n\tc.e = vec3( xMouse*15.,15. + yMouse*15.,15.);//cam position\n\tc.v = normalize(-c.e);\n\tu1 = vec3(0.,1.,0.);\n\tc.r = normalize(cross(c.v,u1));\n\tc.u = normalize(cross(c.r,c.v));\n\t\n\t//Ray\n\tRay r;\n\tfloat D = 1./tan(PI/4.);\n\tr.o = c.e;\n\tvec3 rd = x*c.r + y *c.u+ D*c.v;\n\tr.d = normalize(rd);    \n    \n    //Ray Tracing\n    float index = -1.;\n    vec3 accum = vec3(0.,0.,0.);\n    vec3 mask = vec3(1.,1.,1.);\n    vec3 color,pos, refl_ray,refr_ray;\n\tfloat epsilon =0.;\n    float nu1 = 1.;//suppose it's air\n    float scal,nu,nu2;\n    for(int i=1;i<=STEP_NB;i++){\n\t\tMarchingPack rmp = rayC(r,index);\n        if(rmp.hit){\n    \t\tpos = r.o+r.d*rmp.dist;\n\t\t\tcolor = directIllumination(c,pos, rmp.dist, rmp.index,c.e.z*2.);\n\t\t\tProperties prop = getProperties(rmp.index);\n            vec3 n = getNormal(c,pos,rmp.index);\n            accum =  accum + mask*color;\n            if(prop.reflective){ \n                \n\t\t\t\tmask = mask*prop.c_refl;\n                refl_ray =  normalize ( 2.*n*(dot(n,-r.d)) + r.d );\n\t\t\t\tr = Ray(pos,refl_ray);\n                \n            }else if(prop.transmissive){\n                \n\t\t\t\tmask = mask*prop.c_trans;\n                nu2 = prop.c_trans;\n                nu = nu1/nu2;\n                scal = dot(n,-r.d);\n                refr_ray = ( nu*scal - sqrt( 1.- nu*nu*(1. - scal*scal)) )*n - nu*(-r.d);\n                refr_ray = normalize(refr_ray);\n\t\t\t\tr = Ray(pos,refr_ray);\n                nu1 = prop.c_trans;\n                \n            }else{//ray is absorbed\n    \t\t\treturn vec4(accum,1.);\n                \n            }\n            \n         \tindex = rmp.index;\n            \n        }else{\n            color = mask;\n    \t\treturn vec4(accum,1.);\n        }\n    }\n    \n    return vec4(accum,1.);\n   // return vec4(accum/float(STEP_NB),1.);\n\t\n    \n    \n}\n\n\n//************************Application********************************************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t  \n\tfragColor = rayTracing(fragCoord);\n    \n}","name":"Image","description":"","type":"image"}]}