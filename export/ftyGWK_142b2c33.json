{"ver":"0.1","info":{"id":"ftyGWK","date":"1638295499","viewed":39,"name":"Fractal-Explorer","username":"ethann","description":"Allows for the exploration of various fractals","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct Light\n{\n vec3 color;\n vec3 position;\n float attenuation;\n};\n\nstruct Camera\n{\n  float fov;\n  vec3 center;\n};\n\nvec3 rotateX(vec3 pos, float ang){\n    return mat3(1, 0, 0,\n                0, cos(ang), - sin(ang),\n                0, sin(ang), cos(ang)) * pos;\n}\nvec3 rotateY(vec3 pos, float ang){\n    return mat3(cos(ang), 0, sin(ang),\n                0, 1, 0,\n                -sin(ang), 0, cos(ang)) * pos;\n}\nvec3 rotateZ(vec3 pos, float ang){\n    return mat3(cos(ang), - sin(ang), 0,\n                sin(ang), cos(ang), 0,\n                0, 0, 1) * pos;\n}\nvec3 rotate(vec3 pos, vec3 angs){\n    if(angs.x != 0.0){\n        pos = rotateX(pos, angs.x);\n    }\n    if(angs.y != 0.0){\n        pos = rotateY(pos, angs.y);\n    }\n    if(angs.z != 0.0){\n        pos = rotateZ(pos, angs.z);\n    }\n    return pos;\n}\nvec3 forwardTetraFold(vec3 z){\n   if(z.x+z.y<0.) z.xy = -z.yx;\n   if(z.x+z.z<0.) z.xz = -z.zx;\n   if(z.y+z.z<0.) z.zy = -z.yz;\n   return z;\n}\nvec3 backwardTetraFold(vec3 z){\n   if(z.x-z.y<0.) z.xy = z.yx;\n   if(z.x-z.z<0.) z.xz = z.zx;\n   if(z.y-z.z<0.) z.yz = z.zy;\n   return z;\n}\nvec3 tetraFold(vec3 z){\n    z = forwardTetraFold(z);\n    z = backwardTetraFold(z);\n    return z;\n}\nvec3 cubeFold(vec3 z){\n return abs(z);\n}\nvec3 halfOctFold(vec3 z){\n     if(z.x-z.y<0.) z.xy = z.yx;\n     if(z.x+z.y<0.) z.xy = -z.yx;\n     if(z.x-z.z<0.) z.xz = z.zx;\n     if(z.x+z.z<0.) z.xz = -z.zx;\n     return z;\n}\nvec3 octFold(vec3 z){\n    z = cubeFold(z);\n    if(z.x-z.y<0.) z.xy = z.yx;\n    if(z.x-z.z<0.) z.xz = z.zx;\n    if(z.y-z.z<0.) z.yz = z.zy;\n    return z;\n}\n\n// Dodecahedron serpinski\n// From Knighty: http://www.fractalforums.com/index.php?topic=3158.msg16982#msg16982\n// The normal vectors for the dodecahedra-siepinski folding planes are:\n// (phi^2, 1, -phi), (-phi, phi^2, 1), (1, -phi, phi^2), (-phi*(1+phi), phi^2-1, 1+phi), (1+phi, -phi*(1+phi), phi^2-1) and x=0, y=0, z=0 planes.\n\n// Pre-calculations\n\nconst float phi = 1.61803399; \n\n\nconst float _IKVNORM_ = 1.0 / sqrt(pow(phi * (1.0 + phi), 2.0) + pow(phi * phi - 1.0, 2.0) + pow(1.0 + phi, 2.0));\nconst float _C1_ = phi * (1.0 + phi) * _IKVNORM_;\nconst float _C2_ = (phi * phi - 1.0) * _IKVNORM_;\nconst float _1C_ = (1.0 + phi) * _IKVNORM_;\n\nconst vec3 phi3 = vec3(0.5, 0.5 / phi, 0.5 * phi);\nconst vec3 c3   = vec3(_C1_, _C2_, _1C_);\n\nvec3 DodecahedronFold(vec3 z)\n{\n    float t = z.x * phi3.z + z.y * phi3.y - z.z * phi3.x; \n    if (t < 0.0) z += vec3(-2.0, -2.0, 2.0) * t * phi3.zyx;\n    \n    t = -z.x * phi3.x + z.y * phi3.z + z.z * phi3.y; \n    if (t < 0.0) z += vec3(2.0, -2.0, -2.0) * t * phi3.xzy;\n    \n    t = z.x * phi3.y - z.y * phi3.x + z.z * phi3.z; \n    if (t < 0.0) z += vec3(-2.0, 2.0, -2.0) * t * phi3.yxz;\n    \n    t = -z.x * c3.x + z.y * c3.y + z.z * c3.z; \n    if (t < 0.0) z += vec3(2.0, -2.0, -2.0) * t * c3.xyz; \n    \n    t = z.x * c3.z - z.y * c3.x + z.z * c3.z; \n    if (t < 0.0) z += vec3(-2.0, 2.0, -2.0) * t * c3.zxy;\n   \n    return z;\n}\n\nvec3 phong(vec3 pos, vec3 norm, Camera c, Material m, Light l){\n    \n    vec3 intensity = l.color / (l.attenuation * pow(length(l.position - pos),2.0));\n    vec3 dirLight = normalize(l.position-pos);\n    \n    vec3 diffuse = max(dot(dirLight, norm), 0.f) * intensity * m.diffuse;\n    vec3 specular = pow(max(dot(normalize(c.center-pos), reflect(dirLight, norm)), 0.f), m.shininess) * intensity * m.specular;\n    return diffuse + specular + l.color * m.ambient; \n}\n\nRay generateRay(Camera c, vec2 point){\n    vec3 dir = normalize(-c.center);\n    vec3 up = normalize(vec3(0,0,1));\n    vec3 horiz = normalize(cross(dir,up));\n    float fov = 90.0;\n    \n    float d = 1.0/tan(radians(c.fov)/2.0);\n    vec3 newDir = d * dir + point.x * horiz + point.y * up;\n    \n    Ray r;\n    \n    r.origin = c.center;\n    r.direction = normalize(newDir);\n    \n    return r;\n}\n\nfloat DE(vec3 z)\n{\n    int n = 0;\n    float scale = 2.;\n    float dist = 0.0;\n    while (n < 20 &&  dist < 3.) {\n       //pre-fold rotation\n       z = rotate(z, vec3(0., 0.0, -0.5));   \n       //fold\n       z = DodecahedronFold(z);\n       //post-fold rotation\n       z = rotate(z, vec3(0.1, -.1, -0.2)); \n       z = z*scale -(scale-1.0);\n       n++;\n       dist = (length(z)) * pow(scale, -float(n));\n    }\n    return dist;\n}\n\nvec3 orbit_trap(vec3 z)\n{\n    int n = 0;\n    float scale = 2.;\n    float dist = 0.0;\n    vec3 color = vec3(z);\n    while (n < 20 &&  dist < 3.) {\n       //pre-fold rotation\n       z = rotate(z, vec3(0., 0.0, -0.5));   \n       //fold\n       z = DodecahedronFold(z);\n       //post-fold rotation\n       z = rotate(z, vec3(0.1, -.1, -0.2)); \n       z = z*scale -(scale-1.0);\n       n++;\n       dist = (length(z)) * pow(scale, -float(n));\n       \n       if(z.x < color.x){\n           color.x = z.x;\n       }\n       if(z.y < color.y){\n           color.y = z.y;\n       }\n       if(z.z < color.z){\n           color.z = z.z;\n       }\n    }\n    return color;\n}\n\nvec3 norm(vec3 pos, float eps){\n    vec3 x_eps = vec3(eps,0.,0.);\n    vec3 y_eps = vec3(0.,eps,0.);\n    vec3 z_eps = vec3(0.,0.,eps);\n    return normalize(vec3(DE(pos+x_eps)-DE(pos-x_eps),\n                        DE(pos+y_eps)-DE(pos-y_eps),\n                        DE(pos+z_eps)-DE(pos-z_eps)));\n}\n\nconst int max_ray_steps = 50;\nconst float min_distance = .01;\n\nvec3 trace(Ray r, Camera c, Material m, Light l){\n    float totalDistance = 0.0;\n    int steps;\n    vec3 p;\n    vec3 orbit;\n    for (steps=0; steps < max_ray_steps; steps++) {\n        p = r.origin + totalDistance * r.direction;\n        float distance = DE(p);\n        totalDistance += distance;\n        if (distance < min_distance) break;\n    }\n    \n    vec3 norm = norm(p, min_distance);\n    //Phong Shading Term\n    vec3 color = phong(p, norm, c, m, l);\n    \n    //Ambient Occlusion\n    //float ao = max(.3*float(steps)/float(max_ray_steps),0.);\n    \n    \n    //Position-based Coloring\n    /*p += vec3(.5);\n    p = normalize(p);\n    color *= p;*/\n    \n    return color *(orbit_trap(p) + vec3(1.0));\n  \n  //Distance Shading Mode\n  //return vec3(1.0-float(steps)/float(max_ray_steps));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    \n    Material m;\n    m.ambient = vec3(0.0);\n    m.diffuse = vec3(0.5);\n    m.specular = vec3(0.1);\n    m.shininess = 20.f;\n    \n    Light l; \n    l.color = vec3(1.);\n    l.position = vec3(2.5);\n    l.attenuation = 0.025;\n    \n\n    vec2 loop = vec2(cos(iMouse.x/100.0),sin(iMouse.x/100.0));\n    float height = (iMouse.y-iResolution.y/2.0)/iResolution.y*1.7;\n    vec3 center = normalize(vec3(loop*(1.0-height*height),height))*3.0;\n    \n    Camera c;\n    c.center = center;\n    c.fov = 90.0;\n    fragColor = vec4(trace(generateRay(c, uv), c, m, l), 1.0);\n}","name":"Image","description":"","type":"image"}]}