{"ver":"0.1","info":{"id":"lctXzM","date":"1724671015","viewed":65,"name":"Island shader","username":"2x_Helix","description":"Dynamic Island generation.\nPrimarily replicating the island shader series produced by Barney Codes: https://www.youtube.com/watch?v=bMTeCqNkId8&t\nPerlin noise: https://www.shadertoy.com/view/XdcXzH","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Island Shader generation\nPrimarily replicating the island shader series produced by Barney Codes: \nhttps://www.youtube.com/watch?v=bMTeCqNkId8&t\n*/\nconst float pi = 3.14;\n\nconst float waterLevel = 0.3;\nconst float slopeCutoff = 0.15;  // FIXME: Normals varying with resolution really affects slopes noticably\n\n\n// Colours\nconst vec4 colorNight = vec4(0.149,0.125,0.333,1.);\nconst vec4 colorDay = vec4(0.792,0.722,0.569,1.);\n\n// Terrain colours\nconst vec4 colorWater = vec4(0.384,0.8,0.9, 1.);\nconst vec4 colorSand = vec4(0.835,0.710,0.616,1.);\nconst vec4 colorGrass = vec4(0.588,0.663,0.357,1.);\nconst vec4 colorBush = vec4(0.392,0.514,0.247,1.);\nconst vec4 colorForest = vec4(0.294,0.455,0.247,1.);\nconst vec4 colorStone = vec4(0.427,0.459,0.518,1.);\nconst vec4 colorSlate = vec4(0.518,0.553,0.604, 1.);\nconst vec4 colorSnow = vec4(0.824,0.878,0.871,1.);\n\nvec4 getAlbedo(float height, vec3 normal) {   \n    float flatness = dot(normal, vec3(0.,0.,1.));\n    float isFlat = step(slopeCutoff, flatness);\n    \n    // Determine colours\n    vec4 color = colorSnow;\n    if (height < 0.2) {\n        color = colorStone;\n    }\n    else if (height < 0.4) {\n        color = colorSand;\n    }\n    else if (height < 0.5) {\n        color = colorGrass;\n    }\n    else if (height < 0.6) {\n        color = colorBush;\n    }\n    else if (height < 0.7) {\n        color = colorForest; \n    }\n    else if (height < 0.8) {\n        color = colorStone;\n    }\n    else if (height < 0.9) {\n        color = colorSlate;\n    }\n    \n    // Cutoff for sharp drops in terrain\n    return color * isFlat + colorSlate * (1. - isFlat);\n}\n\nfloat getHeightRaw(vec2 uv, vec3 pix) {\n    // Linear interpolate height (think also used for perlin noise)\n    vec2 res = 1. / iResolution.xy;\n    vec2 p = uv * res;\n    vec2 lerpP = fract(p);\n    p = floor(p);\n    p *= iResolution.xy;\n    \n    // Sample neighbouring pixels\n    float tl = texture(iChannel0, uv).r;\n    float bl = texture(iChannel0, uv + pix.zy).r;\n    \n    float tr = texture(iChannel0, uv + pix.xz).r;\n    float br = texture(iChannel0, uv + pix.xy).r;\n    \n    float t = mix(tl, tr, lerpP.x);\n    float b = mix(bl, br, lerpP.x);\n    \n    return mix(t, b, lerpP.y);\n}\n\nfloat getHeight(vec2 uv, vec3 pix) {\n    return max(getHeightRaw(uv, pix), waterLevel);\n}\n\nvec3 getNormal(vec2 pos, vec3 pix) {\n    // Sample neighbouring pixels to calculate the normal vector\n    float h = 200.;\n    float l = h * getHeight(pos - pix.xz, pix);\n    float r = h * getHeight(pos + pix.xz, pix);\n    \n    float d = h * getHeight(pos - pix.zy, pix);\n    float u = h * getHeight(pos + pix.zy, pix);\n    \n    return normalize(vec3(l-r, d-u, 1.));\n}\n\n\nfloat dayNightCycle(float t) {\n    return 0.5 * sin(t / pi) + 0.5;\n}\n\nfloat getOcclusion(vec3 p, vec3 normal, vec3 pix) {\n    //vec3 sunPos = (iMouse.xy == vec2(0.)) ? vec3(0., 1., 2.) : vec3(iMouse.xy/iResolution.xy, 2.);  // Default sun position is top left\n    vec3 pStart = p;\n    float dayNight = dayNightCycle(iTime);\n    vec3 sunPos = vec3(abs(2.*dayNight - 1.), // [0, 1]\n                       1. - abs(dayNight - 0.5), \n                       1. + dayNight);\n    vec3 sunDir = sunPos - vec3(0.5, 0.5, 0.);\n    vec3 stepDir = normalize(sunDir);\n    \n    int MAX_STEPS = 200;\n    float minStepSize = min(pix.x, pix.y);  // Min step for raycast\n\n\n    float inShadow = 0.;\n    int n = 0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        n++;\n        \n        // Get height at new location\n        float h = getHeight(p.xy, pix);\n        if (h > p.z) {\n            // Ray inside terrain, inShadow\n            inShadow = 1.;\n            break;\n        }\n        if (p.z > 1.) {\n            // Above height limit, not in shadow\n            break;\n        }\n        \n        // Step towards sun by distance to heightmap\n        p += stepDir * max(minStepSize, (p.z - h) * 0.05);\n    }\n    if (n == MAX_STEPS) {\n        inShadow = 1.;\n    }\n    float rayDist = length(p - pStart);\n    float shadowIntensity = inShadow * 0.5 * (1. - smoothstep(0., 0.7, rayDist));\n    \n    float normalShadow = (dot(normal, -stepDir) + 1.) / 2.;\n    return clamp(shadowIntensity + normalShadow, 0., 1.);\n}\n\nfloat waterPass(float height) {\n    float waterDepth = waterLevel - height;\n\n    // Add water if below water level\n    float isWater = step(0., waterDepth);\n    // Add waves if shallow water\n    float isWave = isWater * (1. - smoothstep(0., 0.05, waterDepth));\n    isWave *= (sin(cos(iTime*2.)*2. + waterDepth * 500.) + 1.) / 2.;\n    return easeOut(waterDepth / waterLevel);\n}\n\n\n\nvec4 ambientSkyLight() {\n    return mix(colorNight, \n               colorDay, \n               dayNightCycle(iTime));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pix = vec3(1./iResolution.x, 1./iResolution.y, 0.); // Normalised pixel size\n    \n    float height = getHeight(uv, pix);\n    vec3 p = vec3(uv, height);\n    vec3 normal = getNormal(uv, pix);\n    \n    vec4 color;\n    \n    // Terrain color\n    vec4 albedo = getAlbedo(getHeightRaw(uv, pix), normal);\n    color = albedo;\n\n    // Multiply to simulate water filtering apparently\n    color *= mix(vec4(1.), colorWater, waterPass(getHeightRaw(uv, pix)) * 4.);  \n    // Wave color\n    //color = mix(color, colorWater, waterPass(getHeightRaw(uv, pix)));\n    \n    // Shadow \n    float shadowBrightness = 0.5;\n    float inShadow = getOcclusion(p, normal, pix);\n    vec4 shadowCol = vec4(color.rgb * shadowBrightness, 1.);\n    color = mix(color, shadowCol, inShadow);\n    \n    \n    // sun/moonlightambient sunlight (mouse pos)\n    //vec4 ambient = mix(vec4(0.792,0.722,0.569,1.), \n    //                    vec4(0.149,0.125,0.333,1.), iMouse.x/iResolution.x);\n    color = mix(color, ambientSkyLight(), 0.3);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*  Perlin noise functions from:\n    https://www.shadertoy.com/view/XdcXzH\n*/\n\n#define _PerlinPrecision 8.0\n#define _PerlinOctaves 8.0\n#define _PerlinSeed 10.0\n\n\nfloat rnd(vec2 xy) {\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\n\nfloat inter(float a, float b, float x) {\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\n\nfloat perlin(vec2 uv) {\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\t\t\t\t\t// Final heightmap value\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta----b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|    |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc----d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\n// Falloff positioned in centre of screen\nfloat islandMod(vec2 uv) {\n    float maxDim = min(iResolution.x, iResolution.y);\n    maxDim = maxDim/2. * maxDim/2.;\n    \n    float dx = iResolution.x/2. - uv.x;\n    float dy = iResolution.y/2. - uv.y;\n    \n    float dSq = (dx * dx) + (dy * dy);\n    \n    return map(dSq, 0., maxDim, 1., 0.);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Idea: moving island simulating tectonic movement, sun slowly changes position over time\n    uv.x += sin(iTime*0.2)*0.4 + 3.0;\t// Used for camera movement (perlin noise shader code file)\n    uv.y += iTime*0.1;\n    // Movement for phone shader\n    //uv.x += sin(iTime/20.*0.2)*0.4 + 3.0;\t// Used for camera movement (perlin noise shader code file)\n    //uv.y += iTime/20.*0.1;\n    \n    float sampleFrequency = 0.5;\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    \n    // Calculate height    \n    float height = 1. - perlin(uv * sampleFrequency);  // https://www.shadertoy.com/view/XdcXzH\n    \n    // Falloff from center\n    height *= islandMod(fragCoord);  // Mask, can invert smaller edge islands which is nice\n    \n    // boost contrast\n    height *= 1.3;\n    \n    \n    fragColor = vec4(vec3(height),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*  Maps value within range [min1,max1] to point within [min2,max2] \n    See: https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n*/\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat easeOut(float x) {\n    return clamp(1. - pow(1. - x, 3.), 0., 1.);  // Must change exponent to odd number, was 6\n}","name":"Common","description":"","type":"common"}]}