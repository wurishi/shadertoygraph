{"ver":"0.1","info":{"id":"DdVcDc","date":"1696696405","viewed":31,"name":"First_homework","username":"Andru55555555555","description":"A monster emerges from the darkness","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gamedev"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( abs(p.x), 8.0 ) + pow ( abs(p.y), 8.0 ), 1.0 / 8.0 );\n}\n\nfloat torus ( in vec3 pos, in vec2 t )\n{\n    vec3 pt =  pos;\n    vec2 q  = vec2 ( length ( pt.xz ) - t.x, pt.y );\n\n    return length8 ( q ) - t.y;\n}\n\nfloat sdPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a: b;\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e8, -1.);\n    res = opU(res, vec2(sdSmoothUnion(sdSphere(pos - vec3(0,.6, -0.6), 0.2),\n    sdSmoothUnion(sdSphere(pos, 0.5), sdSphere(pos - vec3(-0,.6, 0.6), 0.2), 0.5), .6)\n                        , 1.));\n                        \n    res.x = sdSmoothUnion(res.x, sdSphere(pos - vec3(0, -1, 0), 1.) , .25);\n    res.x = sdSmoothUnion(res.x, sdSphere(pos - vec3(0.5, 0, 0), .05) , .15);\n    res.x = sdSmoothUnion(res.x, sdSphere(pos - vec3(0.5, 0, 0), .05) , .15);\n    res.x = sdSmoothUnion(res.x, sdSphere(pos - vec3(0.5, 0, 0), .05) , .15);\n    return res;\n}\n\nvec3 calcNorm(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy*map(p+ k.xyy*h).x +\n                    k.yyx*map(p+ k.yyx*h).x + \n                    k.yxy*map(p+ k.yxy*h).x+\n                    k.xxx*map(p+ k.xxx*h).x);\n}\n\n\nvec2 raycast(vec3 ro, vec3 rd) {\n    float epsilon = 0.01; \n    int iters = 100;\n    float t = 0.0;\n    for(int i = 0; i < iters; ++ i) {\n        vec3 pos = ro + rd*t;\n        vec2 res = map(pos); \n        if (res.x < epsilon) {\n            return vec2(t, res.y);\n        }\n        if (i + 1 >= iters) {\n            return vec2(t, -1);\n        }\n        t += res.x;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec3 light = normalize(vec3(-.4 + .9 * sin(iTime), 0.5, 0.1));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 ro_start = vec3(5. + 0.4 * sin(iTime), -0.1, 0.4 * sin(iTime)); \n    \n    \n    vec3 r_direction = vec3(-1., (fragCoord.y - iResolution.y /2.0)/iResolution.x, -fragCoord.x/iResolution.x + 0.5);\n\n\n    vec3 rd = normalize(r_direction);\n    vec2 res = raycast(ro_start, rd);\n    float t = res.x;\n    float m = res.y ;\n    // Time varying pixel color\n    vec3 col = vec3(0.,0.,0.);\n    if (m != -1.0) {\n        if (m == 1.) {\n            col = vec3(0.,1.,0.);\n        } else if (m == 2.) {\n            col = vec3(0.,0.,1.);\n        }\n        vec3 pos = ro_start + rd*t;\n        vec3 nor = calcNorm(pos);\n        float diff = clamp(dot(nor, -light), 0.0, 1.0);\n        col = 0.25 * col + 0.75*diff*col;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}