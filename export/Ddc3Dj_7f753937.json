{"ver":"0.1","info":{"id":"Ddc3Dj","date":"1677814563","viewed":112,"name":"Some more textures","username":"ianertson","description":"Remade some of my old procedural textures, use them however you want :)\nLook around with the mouse :D","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","textures","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX_0 2\n#define ID_BOX_1 3\n#define ID_BOX_2 4\n\nvec3 hash23(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p+(seed*13.08372718569))/256., 0.0).xyz;\n}\n\nvec3 hash23s(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash23(id + vec2(0, 0), seed), hash23(id + vec2(1, 0), seed), lv.x),\n        mix(hash23(id + vec2(0, 1), seed), hash23(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat hash21(in vec2 p, in float seed) {\n    return textureLod(iChannel2, (p+(seed*13.08372718569))/256., 0.0).r;\n}\n\nfloat hash21s(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21(id + vec2(0, 0), seed), hash21(id + vec2(1, 0), seed), lv.x),\n        mix(hash21(id + vec2(0, 1), seed), hash21(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise23(in vec2 p, in float seed, in float freq, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * hash23(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 noise23s(in vec2 p, in float seed, in float freq, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * hash23s(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat noise21(in vec2 p, in float seed, in float freq, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * hash21(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat noise21s(in vec2 p, in float seed, in float freq, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * hash21s(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int id = ID_NONE;\n    int skip = data.skip;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    \n    const float margin = 1.1;\n    const float size = 1.0;\n    const float count = 3.0;\n    const float r = 0.05;\n    \n    float time = T;\n    float rota = time*0.2;\n    \n    Object oBox0 = Object(vec3((size*(count-1.))+margin, size + nsin(time) + (r*2.), 0), vec3(0.0, rota, 0.0));\n    Object oBox1 = Object(vec3(0., size + nsin(time+1.) + (r*2.), 0), vec3(0.0, rota+1., 0.0));\n    Object oBox2 = Object(vec3(-((size*(count-1.))+margin), size + nsin(time+2.) + (r*2.), 0), vec3(0.0, rota+2., 0.0));\n    \n    float box0 = boxSDF(rotPoint(p - oBox0.p, oBox0.r), vec3(size)) - r;\n    float box1 = boxSDF(rotPoint(p - oBox1.p, oBox1.r), vec3(size)) - r;\n    float box2 = boxSDF(rotPoint(p - oBox2.p, oBox2.r), vec3(size)) - r;\n    \n    SAMPLE(ground, o, ID_GROUND);\n    SAMPLE(box0, oBox0, ID_BOX_0);\n    SAMPLE(box1, oBox1, ID_BOX_1);\n    SAMPLE(box2, oBox2, ID_BOX_2);\n    \n    data.id = id;\n    data.o = o;\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0+d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    \n    data.p = p;\n    data.n = n;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    float d = 0.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= far) return 1.0;\n    }\n    \n    return clamp(d/(1.0+d), AMBIENT, 1.0);\n}\n\n//#define DEBUG_TEXTURE plankTexture\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    const float tile = 2.0;\n    \n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    \n    vec3 p1 = rgb(154, 109, 76);\n    vec3 p2 = rgb(94, 64, 39);\n    vec3 p3 = rgb(229, 173, 111);\n    vec3 p4 = rgb(139, 96, 69);\n    \n    vec3 hf1 = noise23(uv, 0.333328281, 48.0, 3);\n    vec3 lf1 = noise23s(uv, 1.13212555, 5.0, 6);\n    vec3 idr1 = hash23(id.yy, 1.111982815);\n    vec3 idr2 = hash23(id.yy, 2.222391114);\n    vec3 plankCol = mix(mix(mix(p1, p2, hf1.x), p3, hf1.y), p4, hf1.z);\n    vec3 idCol = mix(mix(mix(p4, p3, idr1.x), p2, idr1.y), p1, idr1.z);\n    \n    \n    col += plankCol;\n    col = mix(col, col*idCol, lf1.z);\n    col = mix(col, idCol, lf1.x*hf1.y);\n    \n    float thick = mix(0.44, 0.39, hf1.x);\n    \n    float g = max(0.0, 1.0-round((1.-alv.y)+thick));\n    float ga = max(0.0, 1.0-ceil(lv.y-0.05));\n    \n    float sg = max(0.0, 1.0-smoothstep(0.0, 0.4, 1.0-alv.y));\n    \n    g = mix(g, sg, 0.7);\n    ga = mix(ga, sg, clamp(hf1.x*2.*lf1.x, 0.0, 1.0));\n    \n    vec3 sepCol = pow(mix(mix(mix(p1, p2, lf1.x), p3, lf1.y), p4, lf1.z), vec3(5.));\n    \n    col = mix(col, sepCol, g);\n    col = mix(col, p3, max(0.0, ga-(g*0.69)));\n    \n    float cracks = max(0.0, 1.0-(g+ga)) * max(0.0, 1.0-smoothstep(0.0, 0.01, abs(abs(lf1.x-lf1.y)-(hf1.z*0.03))));\n   \n    \n    col = mix(col, mix(p2, p1, lf1.x*hf1.y*0.5), cracks*hf1.x);\n    \n    vec3 grain = textureLod(iChannel3, uv+0.0292981512, 0.0).xyz;\n    \n    float pgrain = clamp((grain.x*grain.z*lf1.z)*2., 0.0, 1.0);\n    \n    col = mix(col, col*col, pgrain);\n    \n    m.spec = clamp(ga*hf1.z, pgrain, 1.0);\n    \n    return col;\n}\n\nvec3 brickTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    const float tile = 4.0;\n    \n    float idy = floor(uv.y*tile);\n    \n    vec2 uuv = uv;\n    uuv.x += (idy/tile)/2.;\n    uuv *= tile;\n    \n    vec3 hf1 = noise23(uv, 0.398287185, 96., 2);\n    vec3 hf2 = noise23s(uv, 1.93772812, 96., 2);\n    vec3 lf = noise23s(uv, 3.333392211, 6., 6);\n    \n    \n    vec2 id = floor(uuv);\n    vec2 lv = fract(uuv);\n    vec2 alv = abs(lv*2.0-1.0);\n    float thick = mix(mix(0.01, 0.06, hf1.x*hf2.z), 0.07, lf.x*lf.x*lf.y);\n    float g = max(0.0, floor(max(alv.x, alv.y)+thick));\n    float ga = max(0.0, 1.0-ceil(min(lv.x, lv.y)-0.016));\n    \n    \n    vec3 idr1 = hash23(id, 3.292189315);\n    vec3 idr2 = hash23(id*4.293123, 0.028781234);\n    \n    vec3 b1 = rgb(132, 78, 68);\n    vec3 b2 = rgb(133, 65, 51);\n    vec3 b3 = rgb(176, 76, 43);\n    vec3 b4 = rgb(117, 65, 38);\n    \n    vec3 brickCol = mix(mix(mix(b1, b2, hf1.x), b3, hf1.y), b4, hf1.z);\n    brickCol = mix(mix(mix(b4, b3, idr1.x), b2, idr1.y), b1, idr1.z);\n    brickCol = mix(brickCol, brickCol*brickCol, idr2.x);\n    col += brickCol;\n    \n    vec3 w1 = rgb(138, 131, 116);\n    vec3 w2 = rgb(201, 195, 178);\n    vec3 w3 = rgb(169, 147, 125);\n    vec3 w4 = rgb(94, 83, 77);\n    \n    vec3 sepCol = mix(mix(mix(w1, w2, hf2.x), w3, hf2.y), w4, hf2.z);\n    \n    col = mix(col, sepCol, g);\n    \n    col = mix(col, col*col, lf.x*lf.x);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    col = mix(col, col*col, mix(grain.x*idr1.z, grain.y*idr2.z*lf.y, lf.z));\n    col = mix(col, col*col, ga);\n    \n    m.spec = clamp(g*hf2.y, grain.z*grain.x*0.5, 1.0);\n    \n    return col;\n}\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = noise23s(uv, 2.3339281, 60., 4);\n    vec3 lf1 = noise23s(uv, 0.9288737, 20., 4);\n    float grain = textureLod(iChannel2, uv/2., 0.0).r;\n    \n    vec3 w1 = rgb(133, 107, 82);\n    vec3 w2 = rgb(143, 110, 78);\n    vec3 w3 = rgb(99, 58, 36);\n    vec3 w4 = rgb(171, 102, 61);\n    \n    vec3 woodCol = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += woodCol;\n    \n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    vec2 lvs = lv*lv*(3.0-2.0*lv);\n    vec2 lvc = lv*2.0-1.0;\n    vec2 alv = abs(lvc);\n    \n    const float seed = 3.3928195;\n    float idr = mix(mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lvs.x),\n                mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lvs.x), lvs.y);\n    \n    \n\n    \n    float ra = max(0.0, 0.4 + 0.2*((0.5-idr)*0.5));\n    float fe = ra*(0.9*mix(1.0, 0.5, idr*idr*idr*0.7));\n    lvc += vec2(cos(idr*6.), sin(idr*6.))*0.5*idr;\n    col = mix(col, mix(col*col, col*idr, idr), smoothstep(0.6-0.3, 0.6+0.3, idr) * max(0.0, 1.0-smoothstep(ra-fe, ra+fe, length(lvc))));\n    \n    \n    \n    float s = pow(exp((cos((idr*idr*idr*(9.21223*(0.5+length(lvc))))*(lvc.x-((0.1+(idr*2.))*\n        sin((lvc.y-sin(lvc.x*M_PI*(0.5+(idr))))*M_PI)))*TAU)) - 1.), 3.0);\n    \n    col = mix(col, mix(w3, w4, hf1.x*lf1.z)*col, clamp(s*lf1.x*hf1.z*2., 0.0, 1.0));\n    col = mix(col, col*col, grain*grain);\n    \n    m.spec = clamp(s*s*grain, grain*lf1.x, 1.0);\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = noise23(uv, 0.3219818, 60., 2);\n    vec3 hf2 = noise23(uv, 1.9926439, 60., 3);\n    vec3 lf1 = noise23s(uv, 0.99938281, 0.3, 2);\n    \n    \n    vec3 g1 = rgb(108, 119, 77);\n    vec3 g2 = rgb(127, 116, 59);\n    vec3 g3 = rgb(67, 70, 44);\n    vec3 g4 = rgb(90, 94, 67);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    grassCol = mix(grassCol, grassCol*grassCol, hf2.z);\n    \n    vec3 m1 = rgb(133, 120, 106);\n    vec3 m2 = rgb(126, 117, 98);\n    vec3 m3 = rgb(125, 88, 63);\n    vec3 m4 = rgb(80, 72, 52);\n    \n    vec3 mudCol = mix(mix(mix(m1, m2, hf2.x), m3, hf2.y), m4, hf2.z);\n    \n    float r1 = noise21s(uv, 1.0293915, 3., 6);\n    float mudReg = (1.0-smoothstep(0.02, 0.6, r1));\n    float mudLow = (1.0-smoothstep(0.3, 0.5, lf1.x));\n    //return vec3(mudLow);\n    mudReg *= clamp(mudLow*2., 0.0, 1.0);\n    mudReg = mix(mudReg, mudLow, 0.5);\n    mudReg += hf2.x*hf2.x*hf2.z;\n    \n    col += grassCol;\n    col += col * mudCol * mudReg;\n    col = mix(col, mudCol, clamp(mudReg*mudReg*2., 0., 1.0));\n    \n    col = mix(col, col*col, lf1.z*lf1.z*lf1.z*lf1.z);\n    \n    m.spec = clamp(mudReg*hf1.y, hf1.x*hf1.y*hf2.z*0.3, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n)*0.8;\n    \n    col = grassTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoBox_0(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(rotPoint(p - data.o.p, data.o.r), rotPoint(n, data.o.r));\n    \n    col = woodTexture(uv, p, data.m);\n    \n    float e = 0.006;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(woodTexture(uv + vec2(e, 0), p, data.m)),\n        luma(woodTexture(uv + vec2(0, e), p, data.m)),\n        0.5\n    )), 0.1, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox_1(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(rotPoint(p - data.o.p, data.o.r), rotPoint(n, data.o.r))/2.;\n    \n    col = brickTexture(uv, p, data.m);\n    \n    float e = 0.009;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(brickTexture(uv + vec2(e, 0), p, data.m)),\n        luma(brickTexture(uv + vec2(0, e), p, data.m)),\n        0.3\n    )), 0.1, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox_2(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(rotPoint(p - data.o.p, data.o.r), rotPoint(n, data.o.r));\n    \n    col = plankTexture(uv, p, data.m);\n    \n    float e = 0.006;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(plankTexture(uv + vec2(e, 0), p, data.m)),\n        luma(plankTexture(uv + vec2(0, e), p, data.m)),\n        0.4\n    )), 0.1, 0.9);\n    data.n = bump;\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX_0: return getAlbedoBox_0(data); break;\n        case ID_BOX_1: return getAlbedoBox_1(data); break;\n        case ID_BOX_2: return getAlbedoBox_2(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    \n    vec3 blue = vec3(0.29, 0.69, 0.9);\n    vec3 col = pow(blue, vec3(1.0 + dotup));\n    \n    return col;\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 att = getLightAtt(light, p, n);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    float shadow = getShadow(data.id, p+(n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 2.0, LIGHT_AMBIENT);\n    float d =  FAR;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    if (march(data, ro, rd)) {\n        d = data.d;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd, diffuse);\n        }\n    } else {\n        col += getSky(ro, rd);\n    }\n    \n    float depth = d / FAR;\n    \n   \n    col += (smoothstep(0.0, 1., depth) * max(0.0, 1.0 - smoothstep(0.0, 0.5, dotup)))*depth*0.6;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    \n    vec3 ro = vec3(0, 0.5, -6.);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (length(m.xy) > 0.0001 && m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float time = T*0.4;\n        rd.yz *= rot(radians(-25.));\n        ro.xz *= rot(time);\n        rd.xz *= rot(time);\n        ro.y += 3.;\n    }\n    \n    ro.y += 1.2;\n    ro.z -= 0.6;\n    \n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col += (col*col*luma(col));\n    #endif\n    \n    col /= 1.0 + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    col = mix(col, col*col, smoothstep(0.5, 1.3, length(uv)));\n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define nsin(v) (0.5+(0.5*sin(v)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OB, id_) if (id_ != skip && var < dist) { dist = var; id = id_; o = OB; }\n#define AMBIENT 0.05\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 rotPoint(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\nstruct Object {\n    vec3 p;\n    vec3 r;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n    int skip;\n    Material m;\n    Object o;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * NdotL * light.s; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(\n        light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\n","name":"Common","description":"","type":"common"}]}