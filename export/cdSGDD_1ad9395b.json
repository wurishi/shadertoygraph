{"ver":"0.1","info":{"id":"cdSGDD","date":"1674651272","viewed":86,"name":"Boba Landscape","username":"RedWool","description":"If you know how to optimize please tell, this is my first time doing landscapes","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["m"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float t)\n{\n    return fract(sin(t*133.7)*321.417);\n}\n\nfloat hash2 (vec2 v)\n{\n    //return hash(length(vec2(hash(v.x)*v.x+1.32*v.y, hash(v.y)*v.x*213.321)));\n    return hash(hash(v.x)+hash(v.x+v.y)+hash(v.y)+dot(v, vec2(-2.3, 3.7)));\n}\n\nfloat noise2(vec2 uv)\n{\n    vec2 i = floor(uv), f = fract(uv), u = f*(f*(3.-2.*f));\n    \n    float \n    a = hash2(i),\n    b = hash2(i+vec2(1,0)),\n    c = hash2(i+vec2(0,1)),\n    d = hash2(i+vec2(1));\n    \n    return mix(a, b, u.x) + \n    (c - a) * u.y * (1.-u.x) +\n    (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 uv)\n{\n    float v, a = 0.5, f = 1., l = 0.5, r = 2.;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        v += a*noise2(uv*f+iTime*.1);\n        \n        a *= l;\n        f *= r;\n    }\n    \n    return v;\n}\n\nfloat sdfSphere(vec3 p, vec3 c, float r)\n{\n    return length(c - p) - r;\n}\n\nfloat sdfPlane(vec3 p, float y)\n{\n    return p.y - y;\n}\n\nfloat map(vec3 pos)\n{\n    //float r = sdfSphere(pos, vec3(0,abs(sin(iTime*2.))*abs(cos(iTime*.2)*5.)+2.5,0), 1.);\n    //r = min(r, \n    vec2 p = floor(pos.xz/200.)*200.+vec2(100.);\n    float y = fbm(pos.xz*.01)*2. + fbm(pos.xz*.002)*800.,\n    yLev = fbm(p*.01)*2. + fbm(p*.002)*800.;\n    \n    return min(sdfPlane(pos, y)-1., sdfSphere(pos, vec3(p.x,yLev+15.+sin(iTime-p.x+p.y*34.7)*5.,p.y), 30.)-10.);\n    \n    //return r;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 s = vec3(.01,0,0);\n    \n    vec3 n = vec3(\n    map(p+s.xyy) - map(p-s.xyy),\n    map(p+s.yxy) - map(p-s.yxy),\n    map(p+s.yyx) - map(p-s.yyx));\n    return normalize(n);\n}    \n\n\nfloat rayMarch(out vec3 pos, vec3 dir, out float minDist, out float minRange)\n{\n    const int maxStep = 200;\n    const float maxMarch = 1500.;\n    const float minMarch = .1;\n    \n    minDist = maxMarch;\n    minRange = 0.;\n    float cd = 0., d;\n    vec3 co;\n    \n    for (int i = 0; i < maxStep; i++)\n    {\n    //break;\n        co = pos + dir * cd;\n        \n        d = map(co);\n        \n        if (minDist > d)\n        {\n            minDist = d;\n            minRange = cd;\n        }\n        \n        if (d < minMarch)\n        {\n            pos = co;\n            return cd;\n        }\n        if (d > maxMarch)\n        {\n            break;\n        }\n        cd += d;\n    }\n    return -1.;\n}\n\nvec3 material(vec3 pos, vec3 dir, vec2 uv)\n{\n    float cd, cp;\n    if (rayMarch(pos,dir,cd,cd)>=0.)\n    {\n        vec3 dirL = normalize(vec3(0,5,50));\n        \n        pos += dirL*10.;\n        float inten = (dot(normal(pos),dirL) * .8 + .6)*\n        step(0.,rayMarch(pos,-dirL,cd,cp)) * \n        clamp((cp - cd * 5.)/cp,0.,1.);\n        \n        float pct = step(sin(fbm(floor(pos.xz/50.+25.)*50.)*20.)*10.+15., length(mod(pos.xz,50.)-vec2(25.)));\n        \n        return (vec3(.9,.9,.9) * pct + (1. - pct) * vec3(.5,.8,.5)) * inten ;\n    }\n            \n\n    return (2.-length(uv*3.) - sin( + uv.x * uv.y*10.*fbm(floor(uv*40.)+cos(fbm(uv*10.)*50.))+iTime*2.) - fbm(floor(uv*10.)*fbm(uv*10.+iTime))) * vec3(.4,.4,1) +\n    texture(iChannel0, uv+fbm(dir.xy*3.+iTime*.01)).rgb*2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    m *= 1.5;\n\n    vec3 ro = vec3(0,fbm(vec2(0))*2. + fbm(vec2(0))*800.+400.,0);\n    vec3 rd = vec3(uv.x+m.x, uv.y+m.y, 1);\n    // Time varying pixel color\n    vec3 col = material(ro, rd, uv+m-vec2(0,.3));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}