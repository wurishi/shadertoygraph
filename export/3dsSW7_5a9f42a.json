{"ver":"0.1","info":{"id":"3dsSW7","date":"1551627974","viewed":235,"name":"Ribbon 1","username":"OliverSchaff","description":"My first Shadertoy shader.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["warping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float e;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//  Function from Iñigo Quiles\n//  iquilezles.org/articles/functions\nfloat expStep(in float x, in float k, in float n ){\n    return exp( -k*pow(x,n) );\n}\n\n// Copyright © 2013 Inigo Quilez\n// More info here:\n//\n// https://iquilezles.org/articles/distance\nfloat ellipse(in float r1, in float r2,in vec2 p)\n{\n    float f = length( p*vec2(r1,r2));\n    return abs(f-1.0);\n}\n\nvoid renderEllipse(in float r1, in float r2, in vec2 st, inout vec3 col)\n{\n    float f = ellipse(r1,r2,st);\n    float g = length( vec2(ellipse(r1,r2,st+vec2(e,0.0))-ellipse(r1,r2,st-vec2(e,0.0)),\n                           ellipse(r1,r2,st+vec2(0.0,e))-ellipse(r1,r2,st-vec2(0.0,e))) )/(2.0*e);\n    col = mix( col, vec3(1.0,0.3,0.3),expStep(f/g,180.,0.8));\n}\n\nmat2 rotate2d(in float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // e is used for antialiasing\n    e = 1.0/iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x *= aspectRatio;\n\n    // we make a copy of the original coordinate.\n    // this will be used for calculating the distortion effect\n    vec2 pix = uv;\n    \n    // start color\n    vec3 col = vec3(0.0003,1.0,1.0);\n    \n    float u = 0.0; // the angle by which each allipse is rotated\n    const int n = 300; // number of ellipses\n    float du = 2.*3.14159/float(n); // delta-angle by which each allipse is rotated\n    vec2 ribbonCenter = vec2(0.5*aspectRatio, 0.5); // center of the ribbon\n\tvec2 ellipseShift; // vector from the center of the ribbon to the ellipse\n    vec2 ellipseCenter; // vector fronm the uv-plane (0,0) point to the ellipse\n    vec2 distort; // distortion applied to the uv plane before the ellipse is drawn\n    for (int i = 0; i < n; i++) {\n        \n        // calculate the position and rotation for the next ellipse\n        u += du;\n        ellipseShift = 0.28*vec2(cos(u), sin(u));\n        ellipseCenter = ribbonCenter+ellipseShift;\n        distort = 0.12*(vec2(noise(3.*(pix+vec2(0.6*sin(iTime)*sin(2.0*u), 0.5*iTime))))-vec2(0.5));\n        \n        \n        // shift the point where the ellipse is to be drawn into the (0,0) point\n        uv -= ellipseCenter;\n        \n        // apply a distortion to the uv plane\n        uv += distort;\n        \n        // rotate the uv-plane\n        // each ellipse is drawn with a different rotation angle u\n        uv = rotate2d(u) * uv;\n        \n        // render the ellipse\n        renderEllipse(1.0/0.13, 1.0/0.04, uv, col);\n        \n        // undo the rotation and all shifts\n        uv = rotate2d(-u) * uv;\n        uv -= distort;\n        uv += ellipseCenter;\n    }\n    \n    // Output to screen\n    fragColor += vec4(col,1.0);\n    // I borrowed this line from a commet to this shader: https://www.shadertoy.com/view/XttXRs\n    // I still need to learn what it actually does, though...\n    fragColor.xyz = sqrt(pow(vec3(1.5, 1, 1)*(fragColor.x), vec3(0.7, 4, 16)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n","name":"Common","description":"","type":"common"}]}