{"ver":"0.1","info":{"id":"3d3fR4","date":"1604606119","viewed":241,"name":"City Game","username":"kastorp","description":"Restore all connections to the city center!\n\n","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["traffic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// City Game by KASTORP\n// previous versions (unlisted):\n//  \"Traffic sim 2\"  https://shadertoy.com/view/tdVcWK\n//  \"traffic Sim\" \t https://www.shadertoy.com/view/3sKyDW\n// next version: \n//  \"City Game  II\" https://www.shadertoy.com/view/3dtBRB \n/*------------------------------------------------------\n\nthe city needs your help!\nrestore all the connections:\n- connects all road to the center (yellow square)\n- connect all buildings to roads\n\nUnconnected roads/building are darker, and the counter shows their number \n\nControls:\n mouse: add connected road (only if pointer is green)\n SHIFT +mouse:  bulldoze\n B + mouse: add building\n mouse in left panel: zoom & rotate view\n\nThe game is tested only on windows + chrome + Angle \n(sorry I can't help with compatibility issues)\n------------------------------------------------------*/\n\n#define GCOL(th) (th +float(THEIGHT)*.3 )/float(THEIGHT)/1.3\n\nvec4 char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    return textureGrad( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n\n// --- display int4\nvec4 pInt(float d, vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = d-1.; i>=0.; i--) \n        n /= 10.,\n        v += char(p - vec2(.5*i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n#define pString(p,st)  for(int _i= st.length()-1 ;_i>=0;_i-- ) Q+= char(p -vec2(.5*float(_i),0.), st[_i]).x; \n\n\nMain {\n\n//SETUP VIEW---------------------\n    vec2 P= U / ZOOM;\n    vec2 M = (iMouse.x<1.? R/2.:  iMouse.xy)/ZOOM;\n    if(iMouse.x>R.x*ZX)  M =A(vec2(0.)).xy/ZOOM;\n    \n\n     \n    //if isometric 3d, the tracing is on horizontal slices\n    float dj=2.5;\n    for(float j =float(!zoomMode?0 : HEIGHT+THEIGHT) ; j>=0. ;j-=dj){\n       \n        if( zoomMode)  {\n            float tz = 1.//+ pow(sin(iTime*.2),8.)\n            \t,rz=tz -1., zz=tz*.6 ,zh=2. ;\n            if(iMouse.x>R.x*ZX){\n                rz=-.4 +  (iMouse.x-R.x*ZX)/(R.x*ZX) *3.14*4.;\n                zz= .4 + iMouse.y/R.y*4. *.2;\n                zh= 2.5 - (iMouse.y/R.y)*1.5;\n                \n            }\n            float h=  ZOOM2V* float(j)* zz ;\n            \n            P=  (rot(.4 + rz*1.6 )* ((U - vec2(0.,-R.y/5.+h)) *vec2(1.,zh)-vec2(R.x*(.5+ ZX*.5),R.y*1.)) /ZOOM/ZOOM2H /zz  +M ); \n\t\t\tif(HEIGHT==0)  P=   ((U - vec2(R.x*.75,R.y*.5)) /ZOOM/ZOOM2H   +M ); \n        }\n        \n//VEHICLE/BLOCK VARIABLES----------------------\n        \n        vec2 P0 = floor(P)+.5; //position center\n        vec4 data=A(P0);\n        vec3 coord= buffer2coord(P0);\n\n        vehicle v = decodeVehicle(data,coord); //CURRENT VEHICLE\n        vec3 bcoord= vec3( coord.xy,0.); \n        block b = decodeBlock(A(coord2buffer(bcoord)),bcoord.xy); //CURRENT BLOCK\n        if(max(bcoord.x,bcoord.y)<1.) b.btype=0;\n        vec2 point = buffer2point(P); //RELATIVE COORDS\n       \n        //TERRAIN HEIGHT AND SLOPE\n        float th = +float(b.th);\n        if(int(mod(bcoord.x,2.))==1 && int(mod(bcoord.y,2.))==0) {\n        \tvec3 bcoord1 = vec3(coord.xy + DIRS[0],0.);\n            float th1= float(decodeBlock(A(coord2buffer(bcoord1)),bcoord1.xy).th);\n            vec3 bcoord2 = vec3(coord.xy + DIRS[2],0.);\n            float th2= float(decodeBlock(A(coord2buffer(bcoord2)),bcoord2.xy).th);\n            th=(th1*point.y +th2*(6.-point.y))/6.;\n        }\n        else if(int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==1){\n            vec3 bcoord1 = vec3(coord.xy + DIRS[1],0.);\n            float th1= float(decodeBlock(A(coord2buffer(bcoord1)),bcoord1.xy).th);\n            vec3 bcoord2 = vec3(coord.xy + DIRS[3],0.);\n            float th2= float(decodeBlock(A(coord2buffer(bcoord2)),bcoord2.xy).th);\n            th=(th1*point.x +th2*(6.-point.x))/6.;\n        }\n        else if( int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==0){\n            vec3 bcoord1 = vec3(coord.xy + DIRS[0]+ DIRS[1],0.);\n            float th1= float(decodeBlock(A(coord2buffer(bcoord1)),bcoord1.xy).th);\n            vec3 bcoord2 = vec3(coord.xy + DIRS[2]+ DIRS[1],0.);\n            float th2= float(decodeBlock(A(coord2buffer(bcoord2)),bcoord2.xy).th);\n             vec3 bcoord3 = vec3(coord.xy + DIRS[2]+ DIRS[3],0.);\n            float th3= float(decodeBlock(A(coord2buffer(bcoord3)),bcoord3.xy).th);\n            vec3 bcoord4 = vec3(coord.xy + DIRS[0]+ DIRS[3],0.);\n            float th4= float(decodeBlock(A(coord2buffer(bcoord4)),bcoord4.xy).th);\n           \n           th=(th1*point.y*point.x \n               +th2*(6.-point.y)*( point.x)  \n               + th3*(6.-point.y)*(6.- point.x) \n               +th4*point.y*(6.-point.x))/36.;\n        }\n        \n\n        \n        if( float(j)<=max(th+10.,float(b.bh)) ) {\n        \n            float pd= v.vtype==0? 10.:vdist(mod(point,1.),v,float(j) -th>1.5); //DISTANCE FROM VEHICLE\n        \tint vtype=v.vtype; //closest vheicle type\n            float fJun= (b.btype==1)?2.:0.; //used by stripes        \n        \tbool outside =  min(P.x,P.y)<0. || max(P.x/RZ.x,P.y/RZ.y)>1.; //true if outside buffer A\n\t\t\tbool brake =v.brake;\n\n            //neghtbours\n            for(int i =0;i<4;i++){\n                vec3 ncoord =buffer2coord(P0 + DIRS[i]);\n                vec4 ndata = A(P0 + DIRS[i]);\n                vehicle nv = decodeVehicle(ndata,ncoord);\n                if(nv.vtype>0) {\n                    float npd=vdist(mod(point,1.) - DIRS[i],nv,float(j) -th>1.5);\n                    if(pd>npd) {\n                        pd=npd;\n                        brake=nv.brake;\n                        vtype=nv.vtype;\n                    }\n                }\n            }\n\n            //optional turn\n            vec2 nx1 =next(point,b,true); //relative coordinates of next block\n            if(nx1.y>0.) nx1.xy = floor(DIRS[int(nx1.x)]+ P)+.5; //absolute coordinates of next block\n            vehicle nv1 = decodeVehicle(A(nx1.xy),buffer2coord(nx1.xy)); //vehicle on next block\n\n            //default direction\n            vec2 nx2 =next(point,b,false); //relative coordinates of next block\n            if(nx2.y>0.) nx2.xy = floor(DIRS[int(nx2.x)]+ P)+.5; //absolute coordinates of next block\n            vehicle nv2 = decodeVehicle(A(nx2.xy),buffer2coord(nx2.xy)); //vehicle on next block\n\n    //RENDERING---------------------\n\n            //OUTSIDE ROAD\n            if( DEBUG>0 && (abs(point.x-3.)>2.95 || abs(point.y-3.)>2.95)) Q=vec4(0.); //DEBUG borders   \n            else if(WIN && zoomMode && abs(U.x-iResolution.x*ZX)<2.) Q=vec4(0.);\n            else if(isBlockCoord(coord) || !v.road || b.btype==0  || outside ){\n                //    || max(coord.x,coord.y)<.5) {\n\n\n                //BUILDINGS\n                if(b.btype==0 && b.ltype>0 && b.th>=1 &&!outside \n                  &&  sdBox(point - vec2(3.),vec2(1.8))<1. \n                  && max(coord.x,coord.y)>.5\n                  ) {\n\n                    float h= float(b.bh) + th;\n                   \n                    //if(zoomMode &&  iMouse.x>R.x/2. && iMouse.y >R.y*.55) h=th+15.;\n                    h= (floor(h/10.)*10.);\n                    \n                    float fl=j >= (h) || j<=th+10. || int(j)%5==0  ? .5:.5+float(j-th)/float(HEIGHT)*2.;\n                    \n                    if(b.ltype==3 &&b.dist<=1) Q= vec4(1.6*fl,1.6*fl,0. ,h  );\n                    else if(b.conns==0 ) Q= vec4(.2*fl,0.,.2*fl ,h  );\n                    //Q= vec4(.3+ hash22(coord.xy).x*fl,.1, .7*hash22(coord.xy).y*fl,h );\n                    else Q= vec4(.6*fl+ hash22(coord.xy).x*.3,.6*fl, .6*fl+hash22(coord.xy).y*.3,h  );\n                    //Q= vec4(.5*fl,.3*fl,.3*fl + hash22(coord.xy).x*.3 ,h);               \n                }\n\n                //ROUNDABOUT CENTER\n                else if(b.btype==1 && sdBox(point.xy-3.,vec2(1.))<0.)                     \n                    Q= length(point.xy-3.)<1.? vec4(0.,GCOL(th),.0,th):(b.dist<MAX_DIST?vec4(.4,.4,.4,th): vec4(.1,.1,.1,th));\n\n                /*else if (             \n                    (b.th>0 && th<1. && b.conns==0 && b.ltype==2 && b.btype==0)|| \n                    (b.th>0 && th<1. && b.btype>0 && b.dist>=MAX_DIST)\n                ) Q=vec4(0.,0.,.5,0.);*/ //DEBUG HIDDEN UNCONNECTEDS\n                //WATER\n                else if(th<1.) Q=vec4( mix(  vec3(0.,.5,1.)  ,vec3(1.),th*.5  +snoise(P/2. ) *.3  ) ,0.);\n                //GRASS\n                else Q=vec4(0.,GCOL(th)*(j-th>=9.?1.2:1.) ,0.,floor(hash(P0)*  1.5)*10.+th);\n                //else Q=vec4(0.,GCOL(th),0.,th);\n            } \n\n            //VEHICLE\n            else if(pd<.0 ) Q=vec4( brake && abs(j-th-1.)<.5 ? vec3(1.,0.,0.): VCOLOR[vtype-1] ,3.+th);\n            \n            //STRIPES:\n            else if((b.conns&1)>0 &&  abs(point.x-3.05 ) <.10   &&  point.y>3. + fJun)  Q=vec4(1.,1.,1.,th);\n            else if((b.conns&4)>0 &&  abs(point.x-3.05 ) <.10   &&  point.y<3. - fJun)  Q=vec4(1.,1.,1.,th);\n            else if((b.conns&2)>0 &&  abs(point.y-3.05 ) <.10   &&  point.x>3. + fJun)  Q=vec4(1.,1.,1.,th);\n            else if((b.conns&8)>0 &&  abs(point.y-3.05 ) <.10   &&  point.x<3. - fJun)  Q=vec4(1.,1.,1.,th);\n\n            //NEXT BLOCK \n            #if DEBUG>0\n            else if( nx1.y>0. \n                    //&& (abs(P.x-nx.x)+ abs(P.y-nx.y)   )<1.){  // INVERT ARROW\n                    && ((abs(P.x-P0.x)+ abs(P.y-P0.y))   )<.5  && max(abs(P.x-nx1.x), abs(P.y-nx1.y) )<1.){ \n                if(!nv1.road ) Q=vec4(ALERT_COLOR,th); //shold not happen\n                else if(nv1.vtype==0) Q=vec4(DEBUG_COLOR,th);\n\n                else Q=vec4(DEBUG_COLOR1,th);\n            }\n            else if( nx2.y>0. \n                    //&& (abs(P.x-nx.x)+ abs(P.y-nx.y)   )<1.){  // INVERT ARROW\n                    && ((abs(P.x-P0.x)+ abs(P.y-P0.y))   )<.5  && max(abs(P.x-nx2.x), abs(P.y-nx2.y) )<1.){ \n                if(!nv2.road ) Q=vec4(ALERT_COLOR,th); //shold not happen\n                else if(nv2.vtype==0) Q=vec4(DEBUG_COLOR,th) ;\n\n                else Q=vec4(DEBUG_COLOR3,th);\n            }\n            #endif\n            //RONDABOUT SIDES\n            else if(b.btype==1 && sdBox(point.xy-3.,vec2(2.))<0. && length(point.xy-3.)>2.2)  Q= vec4(.0,GCOL(th),.0,th);\n            //ASPHALT\n            else if(b.dist<MAX_DIST \n                 #if DEBUG>0\n                   && length(point -vec2(3.) -DIRS[b.dir]*1.)<1. && sdBox(point -vec2(3.),vec2(1.))>0.\n                 #endif\n                   ) Q=vec4(.4,.4,.4,th);\n            else Q=vec4(.1,.1,.1,th);\n\n            //HIGHLIGHT\n            if( length(buffer2coord(  iMouse.zw/ZOOM +.5).xy-bcoord.xy )<1. )  Q+= keyDown(CH_SHIFT) ||keyDown(CH_B) ? vec4(1.,0.,0.,th): vec4(0.,1.,0.,th);\n\n\n            if(Q.w>= float(j)) { \n                Q*= (float(j) -th<=1.5  ? 1.:.5);        \n                break;\n            };\n    \t}\n        //\n        if(j <= th+10.) dj=1.;\n        if(j < th+4.) dj=.5;\n        if(j < th+1.) dj=.2;\n    }  \n    \n    //COUNTER\n    vec4 c= A(vec2(1.,0.));\n    \n    //CARS\n    if(c.g>0.){\n        pString( U/R*22. -vec2(16.5,19.), int[] (67,65,82,83,58));\n        if(pInt(5., U/R*22. -vec2(19.,19.),(c.g ) ).x >0.4) Q=vec4(1.,1.,0.,0.); \n    }\n    \n    //WIN\n    if(c.b<2.){\n        U.x+=  (-1.+ mod(iTime/3.,2.))*R.x;\n        pString( U/R*3. -vec2(1.,1.), int[] (64+23,64+9,64+14));\n    }else {\n        \n        Q += char(U/R*11. -vec2(8.5,10.) ,29   ).x;\n        Q +=pInt(2., U/R*11. -vec2(9.2,10.),(101.- c.b/c.r*100. ) ).x; \n        Q += char(U/R*11. -vec2(10.2,10.) ,37   ).x;\n    }\n     \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//SETTINGS\n\n#define CITY_SIZE 200. //20 small 40 medium 100 big\n#define MIN_ZOOM 3. //minimum zoom (for small resolutions)\n#define R iResolution.xy\n#define ZOOM max(MIN_ZOOM, R.y/6./CITY_SIZE ) //zoom factor for left panel\n\n#define ZOOM2H 5. // horizontal zoom for right panel\n#define ZOOM2V (3. *ZOOM/6.) // vertical zoom for right panel\n#define HEIGHT 100 //max building height\n#define THEIGHT 80 // max terrain height (-5 water level)\n#define VEHICLE_DENSITY 0.5 //0.=no traffic 1.= full\n#define VMAX float[2] (20.,14.) // max speed by vehicle type\n#define VCOLOR vec3[2] (vec3(1.,1.,0.) ,vec3(1.,.5,1.)) // color by vehicle type\n#define ACC_DIST 2.0 // higher value: less reactive cars\n#define DEC_DIST 1.7 //lower values causes vehicle crashes and disappereance\n#define TURN 0. //0.= always (no congestions) , 1.= never (high congestions)\n\n//DEBUG\n#define DEBUG 0 // set to 1 to display debug colors\n#if DEBUG>0\n    #define ALERT_COLOR vec3(0.,1.,1.)\n    #define DEBUG_COLOR vec3(0.2,0.,0.)\n    #define DEBUG_COLOR2 vec3(0.,.2 ,0.)\n\t#define DEBUG_COLOR1 vec3(.0,1.,0.)\n\t#define DEBUG_COLOR3 vec3(.0,1.,0.)\n#endif\n\n//INTERNAL\n#define VSTEP pow(2.,6.)\n#define BLOCK_BUFFER vec2(6.,6.)\n#define ZX .7\n#define BMAX floor(iResolution.xy/BLOCK_BUFFER/ZOOM*vec2(ZX,1.) -2.)\n#define OSTEP VSTEP\n#define MAX_DIST min((1<<10)-2,int(CITY_SIZE*3.))\n\n\n//RESOLUTION\n#define R iResolution.xy\n#define RZ (R/ZOOM)\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n//BUFFER INPUT\n//#define A(U) texture(iChannel0,(U)/R)\n#define A(U) texelFetch(iChannel0, ivec2(mod(U,R) ), 0)\n#define WIN A(vec2(1.,0.)).b>1.\n#define zoomMode  (!keyToggle(CH_Z) &&  U.x > iResolution.x*(WIN?ZX:0.))\n\n    \n    //Neighborhood;\n    // 0 1 2\n    // 3 4 5\n    // 6 7 8  \n#define TS vec2(textureSize(iChannel0,0))\n \n//#define Directions vec2 d[4] = vec2[] (vec2(0,1), vec2(-1,0),vec2(1,0) ,vec2(0,-1));            \n     \nconst vec2 DIRS[4] = vec2[] (vec2(0,1), vec2(1,0),vec2(0,-1) ,vec2(-1,0));  \nconst float PI = 3.14159265359;\n\n//KEYBOARD\n\n#define CH_Z 90  \n#define CH_SHIFT 16 \n#define CH_B 66 \n#define keyDown(k) (texelFetch(iChannel1, ivec2(k,0), 0).r>.5)\n#define keyPress(k) (texelFetch(iChannel1, ivec2(k,1), 0).r>.5)\n#define keyToggle(k) (texelFetch(iChannel1, ivec2(k,2), 0).r>.5)\n            \nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\nvec2 hash22( vec2 p ) { float t = hash(p);\treturn vec2( t,hash(t)); }\n\n\n\n//PACKING/UNPACKING         \n//from https://www.shadertoy.com/view/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\n//lazy version:\n//#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n//strict version (use in case of strange behaviours):\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n\n       \n//VEHICLE (or Cell)\nstruct vehicle {\n    vec2 block_pos; // block xy  (not persistent)\n    int pos; //  (not persistent)\n    bool road;\n    int vtype; //2 bit 0=none 1=car,2=slowcar \n    int dir_in; // 0..3 DIRS[i]\n    int dir_out;   // 0..3 DIRS[i]     \n\tfloat offset; // -.5 ... +.5\n\tfloat vel; // 0. ...  +1.\n\tvec2 target; //target block (unused yet)\n    bool brake;   \n};\n    \nvehicle newVehicle(vec3 coord, bool road, int vtype,float vel, float off, vec2 tg , int di, int dout){\n    vehicle o;\n    o.block_pos=coord.xy;   \n    o.pos=int(coord.z); \n    o.road=road;\n    o.vtype=vtype; \n    o.dir_in= di ;\n    o.dir_out=dout;\n\to.offset= off; \n\to.vel=vel; \n\to.target=tg; \n    o.brake=false;\n\n    return o;\n}\n\nvehicle decodeVehicle(vec4 t,vec3 coord) {\n\tvehicle o;\n    o.pos=int(coord.z);\n    o.block_pos= coord.xy;   \n    o.vtype= int(gb(t.g,0., 2.));  \n    o.dir_in = int(gb(t.g,2., 2.));\n    o.dir_out = int(gb(t.g,4., 2.));\n    o.road=gb(t.g,6., 1.)<.5;\n\n\to.offset= gb(t.b,0., 6.) /pow(2.,6.)  -.51; \n\to.vel= gb(t.b,6., 6.) /pow(2.,6.);\n    o.brake=gb(t.b,13., 1.)<.5;\n    \n\to.target= vec2(  \n        gb(t.a,0., 8.),\n        gb(t.a,8., 8.)\n        );\n          \n    return o;\n}\n\n\nvec4 encodeVehicle(vehicle o) {\n\tvec4 t=vec4(0.);\n    \n    sb(t.g,0.,2.,float(o.vtype));\n\tsb(t.g,2.,2.,float(o.dir_in));\n    sb(t.g,4.,2.,float(o.dir_out));\n    sb(t.g,6.,1.,o.road?0.:1.);\n    \n    sb(t.b,0.,6.,(o.offset +.51)* pow(2.,6.));\n    sb(t.b,6.,6.,o.vel * pow(2.,6.));\n    sb(t.b,13.,1.,o.brake?0.:1.);\n    \n    \n    sb(t.a,0.,8.,o.target.x);\n    sb(t.a,8.,8.,o.target.y);\n\n    return t;\n}\n\n//BLOCK (or Tile)\nstruct block {\n    vec2 block_pos;\n    int btype; //3 bit 0=none 1=cross 4=street,...\n    int ltype; //0=none  2=building 3=center\n    int bh; //building height\n    int th; //terrain height\n    int conns; // 4 bits\n    float counter;\n    int dist; //distant from center\n    int dir; //dir to center\n       \n};\n\nblock newBlock(vec3 coord, int btype,int ltype, int bh, int th ){\n\tblock o;\n    o.block_pos= coord.xy;\n    o.btype=btype; \n    o.ltype=ltype;\n    o.th=th;\n    o.bh=bh;\n    o.conns=15;\n  \to.counter=0.;\n    o.dist=MAX_DIST;\n    o.dir=0;\n    return o;               \n}              \n                 \nblock decodeBlock(vec4 t,vec2 coord) {\n\tblock o;\n    o.block_pos= coord;\n    o.btype = int(gb(t.r,0., 3.)); \n    o.ltype = int(gb(t.r,3., 3.)); \n    o.conns = int(gb(t.r,6., 4.));\n    o.bh = int(gb(t.g,0., 8.));\n    o.th = int(gb(t.g,8., 8.));\n    o.counter=t.b;\n    o.dist= int(gb(t.a,0., 10.));\n    o.dir= int(gb(t.a,10., 2.));\n    return o;\n}\n\nvec4 encodeBlock(block o) {\n\tvec4 t=vec4(0.);\n    \n    sb(t.r,0.,3.,float(o.btype));\n    sb(t.r,3.,3.,float(o.ltype));\n    sb(t.r,6.,4.,float(o.conns));\n    sb(t.g,0.,8.,float(o.bh));\n    sb(t.g,8.,8.,float(o.th));\n    \n    t.b=o.counter;\n    sb(t.a,0.,10.,float(o.dist));\n    sb(t.a,10.,2.,float(o.dir));\n    return t;\n}\n\n//MAPPING FUNCTIONS\nbool isBlockCoord(vec3 coord) {\n    return (int(coord.z)== 0);\n}\n    \nvec3 buffer2coord (vec2 b) {  \n    return vec3(\n        floor(b.x/BLOCK_BUFFER.x),\n        floor((b.y-1.)/BLOCK_BUFFER.y),\n        floor(mod(b.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((b.y-1.), BLOCK_BUFFER.y))\n     );\n\n}\n\nvec2 buffer2point(vec2 b){\n\treturn vec2(\n    \t\tmod(b.x, BLOCK_BUFFER.x),\n        \tmod((b.y-1.), BLOCK_BUFFER.y)\n    );\n}\n    \nvec2 coord2buffer(vec3 c){\n\treturn vec2(\n        floor(c.x) * BLOCK_BUFFER.x  + floor(c.z/BLOCK_BUFFER.x),\n        floor(c.y) * BLOCK_BUFFER.y  + floor(mod(c.z,BLOCK_BUFFER.x)) +1.\n    );\n}\n\n\n//iq\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 rpos(float off, int di, int dout){\n    //45° path\n    return .5 + mix(DIRS[di], DIRS[dout],.5+off)*.5;\n    //90° path\n\tif(off<0.) return  .5- DIRS[di]*off; else return  .5+ DIRS[dout]*off;\n}\n\nfloat vdist(vec2 p, vehicle nv,bool top){\n vec2 dir = normalize(rpos(nv.offset+.5,nv.dir_in,nv.dir_out)-rpos(nv.offset-.5,nv.dir_in,nv.dir_out));\n vec2 pos=p-rpos(nv.offset,nv.dir_in,nv.dir_out);\n    pos= vec2(pos.x* dir.x + pos.y*dir.y , pos.y*dir.x-pos.x*dir.y);\n return sdBox(pos,vec2(top? 0.2: 0.3 ,0.2));\n}\n\n//ROUTING\nvec2  next(vec2 point, block b,bool turn){\n    \n    //block position is always excluded\n\tif( abs(point.x-.5) <.5 && abs(point.y-.5)<.5) return vec2(0.);\n     \n    vec2 d = (vec2(point.x-3.,point.y-3.));\n    \n    float dm=max(abs(d.x),abs(d.y));\n   \n\n    // CROSS   \n    if(b.btype==1 ){\n        //TURN DIRECTION\n        if(turn==true){\n        \tif(abs(point.x-4.5) <.5 && abs(point.y-2.5)<.5 && (b.conns&2)>0) return vec2(1.,2.);\n            if(abs(point.y-4.5) <.5 && abs(point.x-3.5)<.5 && (b.conns&1)>0) return vec2(0.,2.);\n            if(abs(point.x-1.5) <.5 && abs(point.y-3.5)<.5 && (b.conns&8)>0) return vec2(3.,2.);\n            if(abs(point.y-1.5) <.5 && abs(point.x-2.5)<.5 && (b.conns&4)>0) return vec2(2.,2.);\n        \n        }\n        // DEFAULT DIRECTION\n        else{\n            if( (abs(point.x-3.5) <1.5 && abs(point.y-4.5)<.5 ) || (abs(dm-2.5) <.5 && abs(d.y-.5)<.5 )) return vec2(3.,15.);   \n            if( (abs(point.x-4.5) <.5 && abs(point.y-2.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x-.5)<.5 ))return vec2(0.,15.);\n            if( (abs(point.x-2.5) <1.5 && abs(point.y-1.5)<.5)  || (abs(dm-2.5) <.5 && abs(d.y+.5)<.5 ))return vec2(1.,15.);\n            if( (abs(point.x-1.5) <.5 && abs(point.y-3.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x+.5)<.5 )) return vec2(2.,15.);\n        }\n    }\n    //JUNCTION\n\tif(b.btype==4 && turn==false){ \n        \n        bool central = (abs(dm) <1.);\n        \n        //UP\n        if(abs(point.x-3.5)<.5 &&(\n            ( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&2)==0 && abs(point.y-2.5)<.5  )  \n            ||( (b.conns&1)==1 && abs(point.y-3.5)<.5  )  \n        )) return vec2(0.,15.);\n\t\t//DOWN\n         if(abs(point.x-2.5)<.5 &&(\n            ( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&8)==0 && abs(point.y-3.5)<.5  )  \n            ||( (b.conns&4)==4 && abs(point.y-2.5)<.5  )  \n        )) return vec2(2.,15.);\n        //RIGHT\n        if(abs(point.y-2.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&4)==0 && abs(point.x-2.5)<.5  )  \n            ||( (b.conns&2 )==2 && abs(point.x-3.5)<.5  )  \n        )) return vec2(1.,15.);\n        //LEFT\n        if(abs(point.y-3.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&1)==0 && abs(point.x-3.5)<.5  )  \n            ||( (b.conns&8 )==8 && abs(point.x-2.5)<.5  )  \n        )) return vec2(3.,15.);\n        \n    }\n    \n    return vec2(.0,0.);\n\n    \n    /* COULD BE USEFUL IN THE FUTURE \n    vec2 n = vec2(-sign(d.y),sign(d.x));\n    float rot = ((d.x>0.?0.:1.)+(d.y>0.?0.:2.))*PI/2.+.001; \n    vec2 rotv =vec2(sin(rot),cos(rot));\n    vec2 nd=  vec2(rotv.y* d.x - rotv.x*d.y , rotv.y* d.y + rotv.x*d.x); \n    vec2 nx = n* ( nd.x-nd.y>.5? vec2(0.,1.) : vec2(1.,0.));\n    //vec2 nx = vec2(point.y>=3.0? -1.:1.,point.x>=3.0? 1.:-1.);\n    \n    */\n}\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\nfloat fbm_noise(vec2 uv, int steps) {\n\tfloat v = 0.;\n    for(int i = 0; i < steps; i++){\n        float factor = pow(2.,float(i + 1)) / 2.;\n    \tv += snoise(uv * factor) / factor;\n    }\n    return v / ((pow(.5,float(steps))- 1.) / -.5);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\nMain {\n    \n \tQ =vec4(0.);\n \n\tvec3 coord = buffer2coord(U);\n    vec3 bcoord= vec3( coord.xy,0.);\n    \t\t\n    //discard texels outside view\n    if(coord.x>BMAX.x || coord.y> BMAX.y) discard;\n    \n    //reset:\n    if (iFrame<2 || TS.x != A(vec2(0.)).z){\n\n       \tint ltype=int(.8+ fbm_noise(100. + bcoord.xy/30.+iTime*100.,2))*2;\n        int btype=min(int(.5 + hash(U +iTime)*(ltype==2?1.6: .7)),1);\n       \n     \n        if(isBlockCoord(coord)){\n             int th= max(0, -5+ int(fbm_noise(bcoord.xy/15.+iTime*100.,2)*float(THEIGHT+5)));\n\t\t\t\tth= int(float(th+6)/10.)*10;\n            if(mod(coord.x,2.)+mod(coord.y,2.)<.5)  btype= 0;     \n            //int ltype=2;// min(int(hash(U +iTime*.2)*2.),1)*2;\n            if(th==0) {btype=0;}\n            int bh= 50+ int(floor(hash(bcoord.xy)*float(HEIGHT-50)/10.)*10.);\n            \n            float ctr=sdBox(bcoord.xy-vec2(8.),vec2(.5));\n            if(ctr<=0.) {\n                ltype=3;\n                btype=0;\n                bh=HEIGHT;\n                th=max(th,10);\n            }\n            else if(ctr<=1.) {btype=1;}\n            \n        \tblock b = newBlock(coord,btype,ltype,bh,th);\n            \n            Q= encodeBlock(b);\n        \n        }       \n        else {\n            vehicle v = newVehicle( coord, false, 0, 0.,0. ,vec2(0.),0,0);\n            if(hash(U)<VEHICLE_DENSITY) {\n          \t\t v = newVehicle(\n                coord,\n                true,\n                int(1.5+ hash(U*5.)*1.4),\n        \t\t//vec3(mod(U.x , BMAX.x), mod(U.y ,  BMAX.y),float(int(U.x)% PMAX )),\n                \n                3./  VSTEP,\n                -.52,\n                vec2(vec2(mod(U.x , BMAX.x), mod(U.y ,  BMAX.y))),\n                0,\n                0\n                );\n      \t\t\n            }\n        \t//packing\n            Q= encodeVehicle(v);\n        }\n        \n    \n    } else if(U.y>0.5){\n        \n        Q = A(U);\n        \n        block b = decodeBlock(A(coord2buffer(bcoord)),bcoord.xy);\n        \n        //block logic\n        if(isBlockCoord(coord)){\n            \n            \n \n            //MOUSE click\n            vec3 mcoord=buffer2coord(  iMouse.zw/ZOOM +.5);\n            if(!zoomMode &&  length(mcoord.xy-bcoord.xy )<1. &&b.ltype!=3) \n            { \n                if(keyDown(CH_SHIFT)) {b.btype= 0; b.ltype=0;b.dist=MAX_DIST;  }\n                else if(keyDown(CH_B)) {b.btype= 0; b.ltype=2;b.dist=MAX_DIST; }\n                else b.btype=1;\n              \n            }\n            \n        \t//connections:\n        \tint conX =0,conY=0, conns=0 , dmin=MAX_DIST,dir=0,buildings=0;\n            for(int i=0;i<4;i++){\n            \tvec3 nbCoord=vec3(coord.xy + DIRS[i], coord.z);\n                if(nbCoord.x>=0. && nbCoord.x<= BMAX.x && nbCoord.y>=0. && nbCoord.y<= BMAX.y){\n                    block nb = decodeBlock(A(coord2buffer(nbCoord)),nbCoord.xy);\n                    if((nb.btype>0  )  && i%2==0) conY++;\n                    if((nb.btype>0 ) && i%2==1) conX++;\n                    if(nb.btype>0 || nb.ltype==3 ) conns +=  int(pow(2., float(i)));// 1>>i;\n\t\t\t\t\tif(nb.btype==0 && nb.ltype>0 ) buildings +=1;\n                    if(nb.dist<dmin) {dmin= nb.dist;dir=i;}\n                }\n            }\n            \n            //DISTANCE FROM CENTER\n            if(b.ltype==3) b.dist=0;\n            else if( dmin< b.dist && b.btype>0 ){b.dist=dmin+1; b.dir=dir;}\n            else if( b.dist<  dmin ){ b.dist =MAX_DIST;}\n            \n            //if(mod(coord.x,2.)+mod(coord.y,2.)<.5) b.btype=0; else \n            \n            if(conX+conY<1 && b.btype!=0 ) b.btype=0;\n            else if(conX+conY==1  && b.btype!=0  && buildings==0 &&abs(float(iFrame)-A(vec2(0.)).w) <5.) b.btype=0; \n            else if(conX+conY>2 &&  b.btype!=0  ) b.btype=1;\n            else if(b.btype!=0 ) b.btype=4;\n                \n            b.conns=conns;\n            \n\t\t\t//COUNTER\n            b.counter=0.;\n            for(float k=1.;k<36.;k++){\n            \tvec3 vcoord =vec3(coord.xy,k);\n        \t\tvec4 vdata = A(coord2buffer(vcoord));\n        \t\tvehicle v = decodeVehicle(vdata,vcoord);\n                if(v.vtype==1 &&v.road)b.counter+=1.;\n            }     \n                \n            Q= encodeBlock(b);\n                \n                \n        }\n        //vehicle logic\n        else{\n            //unpacking\n            vehicle v = decodeVehicle(Q,coord);\n            vec2 point=buffer2point(U);\n   \t\t\tv.road=true;\n            v.brake=false;\n\n            //logic\n            float fCross= (b.btype==1)?1.:0.;\n            if( b.btype==0 || b.btype==2)  {v.road=false;}\n            else if(b.btype==1 &&  (abs(point.x-3.) +abs(point.y-3.) >3.  || abs(point.x-3.) +abs(point.y-3.) <2. )) {v.road=false;}\n \n            \n            else if((b.conns&1)==0 &&  abs(point.y-1. ) >3. +fCross  )  {v.road=false;}\n            else if( (b.conns&2)==0 &&  abs(point.x-1. ) >3. +fCross )  {v.road=false;}\n            else if( (b.conns&4)==0 &&  abs(point.y-5. ) >3. +fCross  )  {v.road=false;}\n            else if( (b.conns&8)==0 &&  abs(point.x-5. ) >3. + fCross )  {v.road=false;}\n            else if( b.btype==4 &&  (min(abs(point.x-3.),abs(point.y-3.)) >1.)    ) {v.road=false;}\n            \n\t\t\t//clean vehicles outside road\n            if(!v.road ) v = newVehicle( coord, false, 0, 0.,0. ,vec2(0.),0,0);\n            \n            else if(v.vtype>0 ) {\n                \n               \n                //next direction (initialization)\n                if(v.offset <=-.5){\n                    vec2 nx =next(point,b,false);\n                    if(nx.y>0.) {v.dir_out=int(nx.x); }\n\n                    vec2 nx2 =next(point,b,true);\n                    if(nx2.y>0.  ) {v.dir_out=int(nx2.x); nx=nx2;}\n                }\n                \n                \n                vec3 ncoord =buffer2coord(U + DIRS[v.dir_out]);\n        \t\tvec4 ndata = A(U + DIRS[v.dir_out]);\n        \t\tvehicle nv = decodeVehicle(ndata,ncoord);\n                \n                float dist =(nv.vtype==0) ? ACC_DIST : (1.+ nv.offset-v.offset +nv.vel- v.vel);                \n                    \n                vec2 n1= U + DIRS[v.dir_out];\n                vec2 nx1 =next(buffer2point(n1),b,false);\n\t\t\t\t\n                //precedence\n                for(int i =0;i<4;i++){\n\n                    vec2 n2= n1 + DIRS[i];\n                    vec3 n2coord = buffer2coord(n2);\n                    vec4 n2data = A(n2);\n                    vehicle nv2 = decodeVehicle(n2data,n2coord);                        \n                    vec2  nx2 =next(buffer2point(n2),b,false);\n\n                    if(nv2.road && nv2.vtype>0 \n                       && abs( nv2.dir_out -i)==2 \n                       && v.dir_out!=nv2.dir_out\n                       && int(nx1.x) == nv2.dir_out\n                      ) {\n                        dist=-1.; // always break if another car has precedence\n\n                    }\n                }\n                            \n                \n                if(dist >=ACC_DIST) v.vel = clamp(v.vel+1./VSTEP,1.,VMAX[v.vtype-1]/VSTEP)  ;\n                \n                if(dist < DEC_DIST) {\n                    v.vel=  clamp(v.vel-1./VSTEP,0.,3./VSTEP)  ;\n                    v.brake=true;\n                }\n               \n                 \n                //update offset                          \t                \n                v.offset += v.vel;\n                      \n                //vehicle leaving cell\n                if(v.offset>=.5) {\n                    v.offset=-.5;v.vel=1./VSTEP;\n                    v = newVehicle( coord, false, 0, 0.,0. ,vec2(0.),0,0);\n                    v.road=true;\n                    \n                };\n\n                           \n            }\n            \n            if(v.vtype==0){ \n                //incoming vehicles   \n                for(int i =0;i<4;i++){\n                    vec3 ncoord =buffer2coord(U + DIRS[i]);\n                    vec4 ndata = A(U + DIRS[i]);\n                    vehicle nv = decodeVehicle(ndata,ncoord);\n                    if(nv.vtype>0 && nv.offset+nv.vel>=.5 && abs(nv.dir_out -i)==2 ){\n                        //vec2 nx =next(point,b,false);\n                        //if(nx.y>0. &&  abs(int(nx.x)-i)==2) {\n                        \n                        //if(b.dist>1 || nv.vtype==2){ // cars going to city center will disappear\n\t\t\t\t\t\t\tv.vtype=nv.vtype;\n                            v.offset=nv.offset+nv.vel -1.;\n                       \t\tv.vel=nv.vel;\n                        \tv.dir_in= i;\n                            //v.dir_out=nv.dir_in;\n                        \n                            //next direction                          \n                            vec2 nx =next(point,b,false);\n                        \n                        \t//default direction\n                            if(nx.y>0.) {v.dir_out=int(nx.x); }\n\n                        \t//turn direction (if allowed)\n                            vec2 nx2 =next(point,b,true);\n                        \t//connected... turn only if direction to destination\n                            if(nx2.y>0. && b.dist<MAX_DIST  &&nv.vtype== 1){\n                               if( int(nx2.x)==b.dir ) {v.dir_out=int(nx2.x); nx=nx2;}\n                            }\n                        \t//else turn randomly \n                            else if(nx2.y>0. && hash(iTime +U)> TURN ) {v.dir_out=int(nx2.x); nx=nx2;}\n                            \n                \t\t//}\n               \t\t }\n                }\n    \n            }\n                  \n            //packing\n            Q= encodeVehicle(v);\n        }\n    } else {\n    //COUNTERS\n    \n        int sh = int(mod(U.x -.5,BLOCK_BUFFER.x));\n        Q=vec4(0.); //r=?,g=?, b=unconnected,a=?\n        if(sh==1){\n            vec3 coord = buffer2coord(U+vec2(-1.,1.));\n\n            //subtotal over columns\n            for(float k=  -1.;k<BMAX.y+1.;k++){\n                vec3 nbCoord=vec3(coord.xy +DIRS[0]*k, coord.z);\n                block nb = decodeBlock(A(coord2buffer(nbCoord)),nbCoord.xy);\n\n                Q.g += nb.counter;\n\t\t\t\tif(nb.th>=1 && ( nb.btype>0  || (nb.ltype==2 && nb.btype==0))) Q.r+=1.;\n                if(nb.th>=1 && nb.conns==0 && nb.ltype==2 && nb.btype==0) Q.b +=1.;\n                if(nb.th>=1 && nb.btype>0 && nb.dist>=MAX_DIST) Q.b +=1.;\n            }\n\n            //total over rows\n            if(U.x <2.)for(float k=1.;k<BMAX.x+1. ;k++){\n                Q +=A(U + vec2(BLOCK_BUFFER.x,0)*k );\n            }\n\n        }   \n    }\n    \n    \n    // save CURRENT TEXTURE SIZE\n    if(max(U.x,U.y)<1.) Q= vec4(iMouse.x<1.? R/2.: iMouse.x>iResolution.x/2.? A(U).xy: iMouse.xy,TS.x, iFrame==0 || TS.x != A(U).z ? float(iFrame):A(U).w);\n}","name":"Buffer A","description":"","type":"buffer"}]}