{"ver":"0.1","info":{"id":"stjcRc","date":"1650209513","viewed":104,"name":"Couché de soleil","username":"HanoRobelthon","description":"Expérimentation en 3D","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["lifgraphique"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 calcNormal(in vec3 p);\n\n/*\nTextures\n*/\nTexture Damier(vec3 p, float size, vec3 displacement);\nTexture DamierDef(in vec3 p, in vec2 defCoeff, in float size, in vec3 displacement);\nTexture Point(vec3 p);\nTexture Bois(vec3 p);\nTexture Marbre(vec3 p);\nTexture Sable(vec3 p);\nTexture Metal(vec3 p);\nTexture Rouille(vec3 p);\nTexture MarbreNoir(vec3 p);\nTexture Verre(vec3 p);\nTexture Eau(vec3 p);\nTexture Terrain(vec3 p);\n\nTexture Tex(vec3 p, int iTex) {\n    switch(iTex) {\n    case BLACK: \n        return Texture(vec3(0.2), brillant);\n        break;\n    case WHITE: \n        return Texture(vec3(1.),mat);\n        break;\n    case RED: \n        return Texture(vec3(1., 0., 0.), mat);\n        break;\n    case GREEN: \n        return Texture(vec3(0., 1., 0.),  mat);\n        break;\n    case BLUE: \n        return Texture(vec3(0., 0., 1.), brillant);\n        break;\n    case ORANGE: \n        return Texture(vec3(230., 150., 40.)/255.,  mat);\n        break;\n    case NICE_GREEN: \n        return Texture(vec3(134., 205., 162.)/255., mat);\n        break;\n    case NICE_PURPLE: \n        return Texture(vec3(190., 133., 204.) / 255., mat);\n        break;\n    case YELLOWISH_WHITE: \n        return Texture(vec3(233., 210., 210.) / 255., mat);\n        break;\n    case DAMIER:\n        return Damier(p, 25., vec3(0));\n        break;\n    case DAMIER_DEF:\n        return DamierDef(p, vec2(5., 3.), 25., vec3(0));\n        break;\n    case POINT:\n        return Point(p);\n        break;\n    case BOIS:\n        return Bois(p);\n        break;\n    case MARBRE:\n        return Marbre(p);\n        break;\n    case SABLE:\n        return Sable(p);\n        break;\n    case ROUILLE:\n        return Rouille(p);\n        break;\n    case MARBRE_NOIR:\n        return MarbreNoir(p);\n        break;\n    case VERRE:\n        return Verre(p);\n        break;\n    case METAL:\n        return Metal(p);\n        break;\n    case EAU:\n        return Eau(p);\n        break;\n    case TERRAIN:\n        return Terrain(p);\n        break;\n    case HERBE:\n        return Herbe(p);\n        break;\n    }\n}\n\n\n\n\nTexture Terrain(in vec3 p) {\n    Texture res;\n    \n    vec3 normal = calcNormal(p);\n    float pente = 1. - dot(vec3(0, 1, 0), normal);\n    \n    res.specIndex = 5.;\n    res.specCoeff = 0.25;\n    res.reflectCoeff = 0.;\n    res.transparency = 0.;\n    \n    float noise = Noise(p);\n    \n    \n    vec3 pierre = vec3(0.4);\n    \n    \n  //montagne haute\n    if(p.y > 150. - noise * 50.) {\n        if(pente > 0.9) {\n            res.col = pierre;\n        }\n        else\n            res.col = vec3(0.8);\n    }\n  //montagne basse\n    else if(p.y > 100. - noise * 50.) {\n      //si trop pentue pierre\n        if(pente > 0.6) {\n            res.col = pierre;\n        }\n      //si vers le nord neige\n        else if(dot(normal, vec3(-1, 0, 1)) > 0.2) {\n            res.col = vec3(0.8);\n        }\n      //on remet un peu de neige sur le versant sud\n        else if(pente > 0.5)\n            res.col = pierre;\n        else\n            res.col = vec3(0.8);\n    }\n  //plaine\n    else if(p.y > 10. - noise) {\n        if(pente > 0.1) {\n            res.col = pierre;\n        }\n        else {\n            res = Herbe(p);\n        }\n    }\n  //plage\n    else {\n        res = Sable(p);\n    }\n    \n    \n    \n    \n    return res;\n}\n\n\n\nfloat wave(in float x, in float i) {\n    return (1. - abs(cos(x * i))) / i;\n}\n\nObjet ocean(vec3 point, in float terrain_height) {\n    Objet res;\n    \n    \n    float wave_speed = 0.1;\n    float wave_height = 3.;\n    float wave_distance = 30.;\n    if(point.y > -1. && point.y < wave_height * 2.) { //calcul de l'océan\n        \n        \n        vec3 p = point;\n\n\n        float noise = Noise(vec3(point.x, 0, point.z));\n\n        \n        float height = 0.;\n        \n        for(int i = 1; i < 4; i++) {\n            height += wave_height * wave((point.z) / wave_distance - iTime * wave_speed, float(i));\n            wave_height *= 0.5;\n            wave_distance *= 0.5;\n            wave_speed *= 2.;\n        }\n\n        res.dist = point.y - height;\n        res.dist /= 5.;\n\n        //Si la profondeur d'eau est faible\n        //ajouter de la \"mousse\"\n        if(height - terrain_height + noise * 2. < 4.)\n            res.iTex = WHITE;\n        else\n            res.iTex = EAU;\n        res.texPos = vec3(0);\n        res.texAngle = vec3(0);\n    }\n    else\n        res = demiEspace(vec3(0, 0., 0), vec3(0, 1, 0), point, WHITE, vec3(0), vec3(0));\n    return res;\n}\n\n\n\nfloat plateau(in float height, in float hmin, in float hmax) {\n    return height - (hmax - hmin) * smoothstep(hmin, hmax, height);\n}\n\nfloat f(in vec3 point, out float coeff) {\n        \n    //depth     \n    //<---[-]-- 0 ---[+]---->\n    //          |\n    //          |   \n    //          |  /\\\n    //          | /  \\/\\\n    //    ______|/      \\_____\n    //___/      |\n    //sea plain | mount  plain2\n    \n    \n    float sea_height = -50.;\n    float sp_transition = 750.;\n    \n    float plain_length = 750.;\n    float plain_height = 20.;\n    float pm_transition = 500.;\n    \n    float mount_length = 700.;\n    float mount_height = 100.;\n    \n    float base_height = 0.;\n    \n    //plain2\n    if(point.z > mount_length) {\n        coeff = smoothstep(mount_length, mount_length + pm_transition, point.z);\n        base_height = mix(mount_height, plain_height, coeff);\n    }\n    //mount\n    else if(point.z > 0.) {\n        coeff = smoothstep(0., pm_transition, point.z);\n        base_height = mix(plain_height, mount_height, coeff);\n    }\n    //plain1\n    else if(point.z > -plain_length) {\n        coeff = smoothstep(-plain_length, -plain_length + sp_transition, point.z); \n        base_height = mix(sea_height, plain_height, coeff);\n    }\n    //sea\n    else {\n        base_height = sea_height;\n    }\n  \n    coeff = smoothstep(plain_height - (plain_height - sea_height) * 0.2, mount_height, base_height);\n    return base_height;\n}\n\n\nObjet terrain(in vec3 point, out float height) {\n    Objet res;\n    \n    bool NO_OPTI = false;\n    bool BASE_FUNC = false;\n    \n    float coeff;\n    \n    float base_height = f(point, coeff);\n    float final_height;\n    \n    int total_octave = 7;\n    float freq = 100.;\n    float ampl = 50.;\n    \n    //Si le point est au dessus de la fonction fondamentale et de la somme max de l'amplitude du fbm\n    //Pas la peine de calculer le détail\n    if((point.y < base_height + ampl * 2. || NO_OPTI) && !BASE_FUNC) {\n    \n        //fBm ajoutée à la hauteur de base\n        final_height = base_height;\n        \n        \n        for(int i = 0; i < 2; i++) {\n            final_height += coeff * ampl * ridge(vec3(point.x, 0, point.z) / freq);\n            freq *= 0.4;\n            ampl *= 0.5;\n        }\n        \n        //Si le point est au dessus de 2 couche de bruit\n        //pas la peine de calculer le détail\n        if(point.y < final_height + ampl * 2. || NO_OPTI) {\n            for(int i = 0; i < total_octave - 2; i++) {\n                final_height += coeff *ampl * ridge(vec3(point.x, 0, point.z) / freq);\n                freq *= 0.5;\n                ampl *= 0.5;\n            }\n        }\n        \n    }\n    else {\n        final_height = base_height;\n    }\n    \n    res.dist = point.y - final_height;\n    res.dist /= 10.;\n    res.iTex = TERRAIN;\n    res.texPos = vec3(0);\n    res.texAngle = vec3(0);\n    \n    height = final_height;\n    return res;\n}\n\n\n\nObjet arbre(in vec3 point, float height) {\n    Objet res;\n\n    res.dist = 1000.;\n    res.iTex = GREEN;\n    res.texPos = vec3(0);\n    res.texAngle = vec3(0);\n\n    if(point.y < height + 20.) {\n\n       //Taille de la grille, où chaque arbre est au centre d'une case\n        float grid_size = 10.;\n       //Taille relative de l'arbre\n        float sphere_size = 0.2;\n\n       //on va transformer le point, on garde donc une trace avant transformation\n       //on retire la coordonée verticale qui ne nous sera pas utile\n        vec3 p = vec3(point.x, 0., point.z);\n        float noise = Noise(point) * 0.2;\n\n        float y = point.y;\n        \n      //on ramène tous les point sur une même case en 0, 0; de taille grid_size\n        point = fract(point / grid_size);\n\n      //on centre le point dans la case, + un peu de noise pour avoir un effet de feuillage\n        point -= vec3(0.5) + noise;\n\n        point.y = (y - height)/ grid_size * 0.2 - 0.1;\n        //point.y = (y + f_sol(p).dist)/ grid_size * 0.2 - 0.1;\n        point /= sphere_size * 1.5;\n\n\n      //distance à un cercle\n        res.dist = length(point - 0. * vec3(noise, 0, noise)) - 0.5;\n    \n    }\n    \n    \n    return res;\n}\n\n\nObjet ponton(in vec3 point) {\n    Objet res;\n    \n    vec3 base_coord = vec3(200, 0, -275);\n    point = translat(point, base_coord);\n    vec3 p;\n    \n   //longueur\n    p = translat(point, vec3(9.5, 5, -3));\n    p.x = abs(p.x + 9.5) - 9.5;\n    res = box(vec3(0), vec3(1, 2, 55), p, BOIS, vec3(0), vec3(0));\n    \n   //planche\n    p = translat(point, vec3(0, 7.5, -56));\n    \n    if(p.z > -4.6) {\n        //répétition\n        p.z = fract(p.z / 4.5);\n        p.z -= 0.5;\n        p.z *= 4.5;\n\n        res = opU(res, box(vec3(0), vec3(11, 0.5, 2), p, BOIS, vec3(0), vec3(0)));\n    }\n  \n    \n   //pieds\n    p = translat(point, vec3(12, 0, -45));\n    if(p.z > -25.) {\n        \n        \n        //répétition\n        p.z = fract(p.z / 20.);\n        p.z -= 0.5;\n        p.z *= 20.;\n\n        //symétrie\n        p.x = abs(p.x + 12.) - 12.;\n\n        res = opU(res, cylindre(vec3(0), vec3(0, 1, 0), 10., 2., p, BOIS, vec3(0), vec3(0)));\n    }\n    return res;\n}\n\n\n//=====Code=====//\n\nObjet World(in vec3 point) {\n    Objet res;\n    \n    \n    \n    float depth = (point.z + pow(point.x / 50., 2.)) + Noise(vec3(point.x, 0, point.z) / 50.) * 30.;\n    vec3 p = vec3(point.x, point.y, depth);\n    float height;\n    \n    res = terrain(p, height);\n    //if(height > 10. && height < 20. && p.z > -50.)\n    //    res = opU(res, arbre(point, height));\n    \n    \n    res = opU(res, ocean(p, height));\n    res = opU(res, ponton(point));\n    \n    return res;\n}\n\n\n/*\nSource:\n    Votre shader\n*/\n\n#define MIN_STEP_SIZE 0.05\n#define NB_LIGHTS 1\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * MIN_STEP_SIZE;\n    return normalize(\n        e.xyy * World(p + e.xyy).dist +\n        e.yyx * World(p + e.yyx).dist +\n        e.yxy * World(p + e.yxy).dist +\n        e.xxx * World(p + e.xxx).dist);\n}\n\n\nObjet SphereTracing(in vec3 ray, in vec3 dir, in float renderDistance, in int signe) {\n    float t = 1.f;\n    Objet step;\n    \n    do {\n        step = World(ray + dir * t);\n        step.dist = float(signe) * (step.dist); //Gère la transparence\n        t += max(step.dist, MIN_STEP_SIZE);\n        \n    } while(step.dist > MIN_STEP_SIZE && t < renderDistance);\n    t -= 2. * MIN_STEP_SIZE;\n    return Objet(t, step.iTex, step.texPos, step.texAngle);\n}\n\n\n\nfloat Shadow(in vec3 rayStart, in vec3 l, in float renderDistance) {\n    Objet o = SphereTracing(rayStart, l, renderDistance, 1);\n    \n    if(o.dist < renderDistance - MIN_STEP_SIZE)\n        return 0.;\n    return 1.;\n}\n\n#define GAMMA_IN(x) pow(x, vec3(2.2))\n#define GAMMA_OUT(x) pow(x, vec3(1. / 2.2))\n\n\n\n#define DEBUG false\n#define ONLY_DEPTH false\n\nvec3 castRay(inout vec3 rayPos, inout vec3 rayDir, Light light[NB_LIGHTS], float renderDistance, out float reflectance, out float transparency, in bool only_pos) {\n\n    Objet impact = SphereTracing(rayPos, rayDir, renderDistance, (only_pos == false) ? 1 : -1);\n    vec3 impactPos = rayPos + impact.dist * rayDir;\n\n    vec3 finalCol;\n    \n    \n    if(impact.dist < renderDistance - 2. * MIN_STEP_SIZE) {\n        \n        \n        if(!only_pos && !ONLY_DEPTH) { //si on veut connaitre les informations de texture\n            \n          //Rotation et translation de la texture\n            vec3 texPos = rota(impactPos, impact.texAngle, impact.texPos);\n            texPos = texPos - impact.texPos;\n            \n          //On récupère la texture\n            Texture tex = Tex(texPos, impact.iTex);\n            \n          //On calcule les différents vecteurs\n            vec3 n = calcNormal(impactPos);\n            vec3 r = reflect(rayDir, n);\n            vec3 v = normalize(rayPos - impactPos);\n            \n            \n          \n            \n            vec3 l;\n            vec3 spec, diffus;\n            vec3 ambiant = (tex.col + NIGHT_SKY) * 0.3;\n            float shadow;\n            \n          //calcul de la couleur pour chaque lumière\n            for(int i = 0; i < NB_LIGHTS; i++) {\n                l = normalize(light[i].pos - impactPos);\n                \n                spec = tex.specCol * light[i].col * tex.specCoeff * pow(max(dot(r, l), 0.), tex.specIndex) * light[i].intensity;\n                diffus = tex.col * light[i].col * max(dot(n, l), 0.) * light[i].intensity;\n                ambiant *= light[i].col;\n                \n                shadow = Shadow(impactPos, l, renderDistance);\n\n                \n              //Gamma correction\n              ////https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear\n                spec = GAMMA_IN(spec);\n                diffus = GAMMA_IN(diffus);\n                \n                finalCol += shadow * (diffus + spec);\n            }\n            ambiant = GAMMA_IN(ambiant);\n            finalCol += ambiant;\n            \n          //atmosphere\n            //float atmos = smoothstep(0., renderDistance, impact.dist * 0.4) * 4.;\n            float atmos = exp((impact.dist - renderDistance - 200.) / 400.);\n            \n            finalCol += atmos * NIGHT_SKY;//(0.5 * atmos) * 0.3;\n\n            \n          //Update les paramètres pour la réflexion et/ou transparence (donnée-résultat)\n            reflectance = tex.reflectCoeff;\n            transparency = tex.transparency;\n            rayDir = r;\n            \n            \n        } //if !only_pos\n        else if(ONLY_DEPTH) {\n            Texture tex = Tex(impactPos, impact.iTex);\n            finalCol = tex.col * vec3(1. - impact.dist / renderDistance);\n        }\n        rayPos = impactPos;\n        \n        \n    }\n    else { //Trop loin\n        finalCol = SKY ;\n        finalCol = GAMMA_IN(finalCol);\n        \n        finalCol *= mix(SKY, NIGHT_SKY, smoothstep(0., 1000., impactPos.y));\n        \n        vec3 l = normalize(light[0].pos - rayPos);\n        float coeff = (1. + dot(rayDir, l)) * 0.5;\n\n\n        //lune\n        if(coeff > 0.9999) {   \n            finalCol = vec3(1., 0.9, 0.8);\n        }\n        else {\n            finalCol += pow(coeff, 50.) * 0.5 * light[0].col;\n        }\n        \n        reflectance = 0.;\n        transparency = 0.;\n    }\n    \n    \n    \n    return finalCol;\n}\n\n\nvec4 render(vec3 rayPos, vec3 rayDir, Light light[NB_LIGHTS], float renderDistance) {\n    if(!ONLY_DEPTH) {\n        vec3 col;\n        float reflectance = 0.;\n        float transparency = 0.;\n        float NULL;\n\n        vec3 reflectPos = rayPos;\n        vec3 reflectDir = rayDir;\n\n      //On récupère la couleur direct de l'objet, et la positions d'impact et la direction du reflet (inout)\n        vec3 Impact = castRay(reflectPos, reflectDir, light, renderDistance, reflectance, transparency, false);\n\n        rayPos = reflectPos;\n\n      //Si l'objet réfléchie la lumière\n        vec3 Reflet = vec3(0);\n        if(!DEBUG && reflectance > 0.) {\n            Reflet = castRay(reflectPos, reflectDir, light, renderDistance, NULL, NULL, false);\n            col = Reflet;\n        }\n\n        vec3 transPos = rayPos + rayDir; //Entrer dans l'objet pour la transparence\n        //vec3 transDir = rayDir;\n\n        //rayDir = -rayDir;\n        vec3 Transparence = vec3(0);\n        if(!DEBUG && transparency > 0.) {\n            //Transparence = castRay(transPos, rayDir, light, renderDistance, NULL, NULL, true);\n            //transPos += rayDir;\n            //Transparence = castRay(transPos, rayDir, light, renderDistance, NULL, NULL, false);\n\n            //col = mix(Reflet, Transparence, length(Reflet));\n        }\n\n      //Couleur finale\n        col = mix(Impact, col, reflectance);\n\n      //Gamma correction\n      //https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear\n        col = GAMMA_OUT(col);\n        return vec4(col, 1.);\n    }\n    else {\n        vec3 col;\n        float NULL;\n        \n        col = castRay(rayPos, rayDir, light, renderDistance, NULL, NULL, false);\n        \n        \n        \n        return vec4(col, 1.);\n    }\n}\n\n\n\n//=====Main=====//\n\n\n//Camera\nvec3 camPos = vec3(100.f, 15.f, -250.f);\n//vec3 camPos = vec3(-200.f, 100.f, 0.f);\n\n//x: verticale, y: horizontal\nvec2 camAngle = vec2(0.05, 2.);\nvec3 camDir;\nvec3 camCross;\nvec3 camTop;\n\nfloat camDist = 0.f; //gère la distance du near field\n\nfloat renderDistance = 2000.f;\nvec2 screenSize = vec2(8.f, 4.5) * 0.1;//50.f; //gère l'éloignement de la caméra\n\n\n\nvoid processInput() {\n    float dx = iMouse.x - abs(iMouse.z);\n    float dy = iMouse.y - abs(iMouse.w);\n    //dx = iTime * 40.;\n    camAngle = camAngle + vec2(dy * 0.005, dx * 0.01);\n    \n    \n}\n\nvoid processCam() {\n    camDir = vec3(       \n        cos(camAngle.x) * sin(camAngle.y),\n        sin(camAngle.x),\n        cos(camAngle.x) * cos(camAngle.y)\n    );\n    camCross = vec3(\n        sin(camAngle.y + PI * 0.5),\n        0.f,\n        cos(camAngle.y + PI * 0.5)\n    );\n    camTop = cross(camDir, camCross);\n\n    camPos += -camDir * camDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    processInput();\n    processCam();\n\n\n    vec3 baseCoord = vec3(fragCoord.xy / iResolution.xy - 0.5, 0.f) * vec3(screenSize, 0.);\n\n    vec3 rayStart = camPos + camDir + camCross * baseCoord.x + camTop * baseCoord.y;\n\n\n    Light light[NB_LIGHTS] = Light[NB_LIGHTS](\n        Light(vec3(2000, 300, -1000), vec3(1., 0.7, 0.4), 1.)//, 1. 0.7 0.4\n        //Light(normalize(vec3(.5, 500, -4.)) * 100., vec3(0.5, 0.5, 0.6), .9)\n    );\n\n    //fragColor = render(rayStart, camDir, light, renderDistance);\n    fragColor = render(rayStart, normalize(rayStart - camPos), light, renderDistance);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926538\n#define RAD PI / 180.\n#define BLACK 0\n#define WHITE 1\n#define RED 2\n#define GREEN 3\n#define BLUE 4\n#define ORANGE 5\n#define NICE_GREEN 6\n#define NICE_PURPLE 7\n#define YELLOWISH_WHITE 8\n#define DAMIER 9\n#define POINT 10\n#define BOIS 11\n#define MARBRE 12\n#define DAMIER_DEF 13\n#define SABLE 14\n#define ROUILLE 15\n#define MARBRE_NOIR 16\n#define VERRE 17\n#define METAL 18\n#define EAU 19\n#define TERRAIN 20\n#define HERBE 21\n\n#define SKY vec3(0.7, 0.2, 0.6)\n#define NIGHT_SKY vec3(0.1, 0.1, 0.5)\n\n\n\n//specCoeff, specIndex\n#define mat vec3(1.), 0., 1., 0., 0.\n#define brillant vec3(1.), 1., 15., 0.01, 0.\n#define transparent vec3(1.), 0.25, 15., 0.01, 0.5\n\n\nstruct Objet {\n    float dist;\n    int iTex;\n    vec3 texPos;\n    vec3 texAngle;\n};\n\nstruct Texture {\n    vec3 col;\n    vec3 specCol;\n    float specCoeff;\n    float specIndex;\n    float reflectCoeff;\n    float transparency;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    float intensity;\n};\n\n\n\n//=====Opérateurs=====//\n\n\nObjet opU(in Objet a, in Objet b) {\n    if(a.dist < b.dist)\n        return a;\n    return b;\n    //return a.dist < b.dist ? a : b;\n}\n\nObjet opI(in Objet a, in Objet b) {\n    if(a.dist > b.dist)\n        return a;\n    a.dist = b.dist;\n    return a;\n}\n\nObjet opP(in Objet a, in Objet b) {\n    if(a.dist > -b.dist)\n        return a;\n    a.dist = -b.dist;\n    return a;\n}\n\nObjet opULisse(in Objet a, in Objet b, in float r) {\n    Objet res = opU(a, b);\n    \n    float h = max(r - length(a.dist - b.dist), 0.f) / r;\n    res.dist -= (1.f/6.f) * r * h * h * h;\n    return res;\n}\n\nvec3 translat(vec3 P, vec3 dir) {\n    return P - dir;\n}\n\n\nvec3 rotaX(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 xRot;\n    xRot[0] = vec3(1,  0, 0);\n    xRot[1] = vec3(0, cosA, sinA);\n    xRot[2] = vec3(0, -sinA, cosA);\n\n    P = translat(P, orig);\n    P = xRot * P;\n    return translat(P, -orig);\n}\n\nvec3 rotaY(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n\n    mat3 yRot;\n    yRot[0] = vec3(cosA,  0, -sinA);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(sinA, 0,  cosA);\n\n    P = translat(P, orig);\n    P = yRot * P;\n    return translat(P, -orig);\n}\n\nvec3 rotaZ(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 zRot;\n    zRot[0] = vec3(cosA,  sinA, 0);\n    zRot[1] = vec3(-sinA, cosA, 0);\n    zRot[2] = vec3(0, 0,  1);\n\n    P = translat(P, orig);\n    P = zRot * P;\n    return translat(P, -orig);\n}\n\nvec3 rota(in vec3 P, in vec3 angle, in vec3 orig) {\n    vec3 cosA =  vec3(cos(-angle.x), cos(-angle.y), cos(-angle.z));\n    vec3 sinA = vec3(sin(-angle.x), sin(-angle.y), sin(-angle.z));\n    \n    mat3 xRot;\n    xRot[0] = vec3(1,  0, 0);\n    xRot[1] = vec3(0, cosA.x, sinA.x);\n    xRot[2] = vec3(0, -sinA.x, cosA.x);\n    \n    mat3 yRot;\n    yRot[0] = vec3(cosA.y,  0, -sinA.y);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(sinA.y, 0,  cosA.y);\n    \n    mat3 zRot;\n    zRot[0] = vec3(cosA.z,  sinA.z, 0);\n    zRot[1] = vec3(-sinA.z, cosA.z, 0);\n    zRot[2] = vec3(0, 0,  1);\n    \n    P = translat(P, orig);\n    P = xRot * yRot * zRot * P;\n    return translat(P, -orig);\n}\n\nvec3 scale(in vec3 P, in vec3 factor, in vec3 orig) {\n    P = translat(P, orig);\n    P /= factor;\n    return translat(P, -orig);\n}\n\n//Retourne une valeur entre _min et _max selon x\nfloat bettersmoothstep(in float _min, in float _max, in float x) {\n    return _min + (_max - _min) * smoothstep(_min, _max, x);\n}\n\n\n//===================//\n// Fonction de bruit //\n//===================//\n//récupéré du TP 3\n\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat fbm(vec3 point, int octave, float ampl, float lambda) {\n    float res = 0.;\n    vec3 p = vec3(point.x, 0, point.z);\n    \n    for(int i = 0; i < octave; i++) {\n        ampl *= 0.5;\n        lambda *= 0.5;\n        res += ampl * Noise(p / lambda);\n        \n    }\n    return res;\n}\n\n\nfloat ridge(vec3 p) {\n    return 1. - 2. * abs(Noise(p));\n}\n\nfloat ridge_fbm(vec3 point, int octave, float ampl, float lambda, float hmin, float hmax) {\n    vec3 p = vec3(point.x, 0, point.z);\n    float res = 0.;\n    float att = 1.;\n    \n    for(int i = 0; i < octave; i++) {\n        res += att * ampl * ridge(p / lambda);\n        ampl *= 0.5;\n        lambda *= 0.5;\n        att = smoothstep(hmin, hmax, res);\n    }\n    \n    return res;\n}\n\n//===============//\n//               //\n//   Primitive   //\n//               //\n//===============//\n\n\n/*Liste des primitives\nObjet sphere(in vec3 centre, in float rayon, in vec3 point, in int iTex)\nObjet demiEspace(in vec3 a, in vec3 n, in vec3 point, in int iTex)\nObjet plan(in vec3 a, in vec3 n, in float e, in vec3 point, in int iTex)\nObjet box2(in vec3 c, in vec3 len, in vec3 point, in int iTex)\nObjet box(in vec3 c, in vec3 len, in vec3 point, in int iTex)\nObjet gellule(in vec3 A, in vec3 B, in float rayon, in vec3 point, in int iTex)\nObjet tore(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex)\nObjet disque(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex)\nObjet cylindre(vec3 point, int iTex)\nObjet cylindre(vec3 c, vec3 n, float r, vec3 point, int iTex)\nObjet cylindre(vec3 b, vec3 n, float length, float r, vec3 point, int iTex)\nObjet tube(in vec3 A, in vec3 n, float length, in float r, in float epaisseur, in vec3 point, in int iTex)\nObjet cone(in vec3 A, in vec3 B, in float radiusBottom, in float radiusTop, in vec3 point, in int iTex)\n*/\n\n/*\nParam:\n    centre: centre de la sphère\n    rayon: rayon de la sphère\n\nRésultat:\n    la coordonnée x représente la distance à la sphère paramétrée.\n*/\nObjet sphere(in vec3 centre, in float rayon, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return Objet(distance(centre, point) - rayon, iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    a: un point à la surface du demi-espace\n    n: un vecteur normale pointant à l'extérieur de la surface\n\nRésultat:\n    la coordonnée x représente la distance au demi-espace paramétrée\n*/\nObjet demiEspace(in vec3 a, in vec3 n, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    return Objet(dot(point - a, n), iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    a: un point contenu dans le plan\n    n: la normale au plan\n    e: demi-épaisseur du plan\n    \nRésultat:\n    la coordonnée x représente la distance au plan\n    \nDesc:\n    On donne une épaisseur à un plan, comme une planche infini\n*/\nObjet plan(in vec3 a, in vec3 n, in float e, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    return Objet(abs(dot(point - a, n)) - e, iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    c: barycentre de la boite\n    len: longueur des côté\n    \nRésultat:\n    la coordonnée x représente la distance à une boite de barycentre c, de côté len\n    \nSource:\n    Inigo Quilez: https://www.youtube.com/watch?v=62-pRVZuS5c\n*/\nObjet box2(in vec3 c, in vec3 len, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return Objet(length(max(abs(point - c) - len, 0.f)), iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    c: barycentre de la boite\n    len: longueur des côté\n    \nRésultat:\n    la coordonnée x représente la distance à une boite de barycentre c, de côté len\n    Fonctionne mieux avec le calcul de normal\n*/\nObjet box(in vec3 c, in vec3 len, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return opI(\n        opI(\n            plan(c, vec3(0, 1, 0), len.y, point, iTex, texPos, texAngle),\n            plan(c, vec3(0, 0, 1), len.z, point, iTex, texPos, texAngle)\n        ),\n        plan(c, vec3(1, 0, 0), len.x, point, iTex, texPos, texAngle)\n    );\n}\n\n\n/*\nParam:\n    A: Première extrémité du segement\n    B: Deuxième extrémité du segment\n    rayon: rayon d'épaisseur autour du segment\n    \nRésultat:\n    la coordonnée x représente la distance à un segment d'épaisseur rayon\n*/\nObjet gellule(in vec3 A, in vec3 B, in float rayon, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    vec3 AP = point - A;\n    vec3 AB = B - A;\n    if(dot(AB, AP) < 0.f) {\n        return Objet(length(AP) - rayon, iTex, texPos, texAngle);\n    }\n    if(dot(AB, point - B) > 0.f) {\n        return Objet(length(point - B) - rayon, iTex, texPos, texAngle);\n    }\n    else {\n        float baseTri = dot(AP, normalize(B - A));\n        return Objet(sqrt(length(AP) * length(AP) - baseTri * baseTri) - rayon, iTex, texPos, texAngle);\n    }\n}\n\n/*\nParam:\n    c: centre du cercle\n    n: normale au cercle\n    r: rayon du cercle\n    ri: rayon intérieur de l'épaisseur du cercle\n    \nRésultat:\n    la coordonnée x représente la distance à un cercle d'épaisseur ri\n*/\nObjet tore(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    vec3 CP = point - c;\n    float distPlan = dot(CP, n);\n    float baseTri = sqrt(length(CP) * length(CP) - distPlan * distPlan) - r;\n    return Objet(sqrt(distPlan * distPlan + baseTri * baseTri) - ri, iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    c: centre du disque\n    n: normale au disque\n    r: rayon du disque\n    ri: rayon intérieur de l'épaisseur du disque\n    \nRésultat:\n    la coordonnée x représente la distance à un disque d'épaisseur ri\n*/\nObjet disque(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    vec3 CP = point - c;\n    float distPlan = dot(CP, n);\n    float baseTri = sqrt(length(CP) * length(CP) - distPlan * distPlan) - r;\n    if(baseTri < 0.f)\n        return Objet(abs(distPlan) - ri, iTex, texPos, texAngle);\n    return Objet(sqrt(distPlan * distPlan + baseTri * baseTri) - ri, iTex, texPos, texAngle);\n}\n\n/*\nRésultat:\n    la coordonnée x représente la distance à un cylindre de rayon 0.5 (diamètre 1.f), infini.\n*/\nObjet cylindre(vec3 point, int iTex, vec3 texPos, in vec3 texAngle) {\n    float baseTri = dot(vec3(0, 1, 0), point);\n    return Objet(\n        sqrt(length(point) * length(point) - baseTri * baseTri) - 0.5,\n        iTex, texPos, texAngle\n    );\n}\n\n/*\nParam:\n    c: barycentre du cylindre (infini)\n    n: vecteur directeur du cylindre\n    r: rayon de l'épaisseur du cylindre\n\nRésultat:\n    la coordonnée x représente la distance à un cylindre infini parametré\n*/\nObjet cylindre(vec3 c, vec3 n, float r, vec3 point, int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    point = (point - c);\n    float baseTri = dot(n, point);\n    return Objet(\n        sqrt(length(point) * length(point) - baseTri * baseTri) - r,\n        iTex, texPos, texAngle\n    );\n}\n\n/*\nParam:\n    b: point à la base du cylindre\n    n: vecteur normale à la base (pointe vers l'intérieur du cylindre)\n    height: hauteur du cylindre\n    r: rayon de l'épaisseur dy cylindre\n    \nRésultat:\n    la coordonnée x renvoie la distance à un cylindre paramétré de longueur length\n\n*/\nObjet cylindre(vec3 b, vec3 n, float length, float r, vec3 point, int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    return \n        opI(\n            cylindre(b, n, r, point, iTex, texPos, texAngle),\n            plan(b + 0.5 * length, n, 0.5 * length, point, iTex, texPos, texAngle)\n        );\n}\n\n/*\nParam:\n    A: point à la base\n\n*/\nObjet tube(in vec3 A, in vec3 n, float length, in float r, in float epaisseur, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return opP(\n        cylindre(A, n, length, r, point, iTex, texPos, texAngle),\n        cylindre(A, n, r - epaisseur, point, iTex, texPos, texAngle)\n    );\n}\n\n/*\nParam:\n    A: Base du cone\n    B: Haut du cone\n    radiusBottom: rayon de la base\n    radisuTop: rayon du haut\n    \nRésultat:\n    la coordonnée x représente la distance à un cone paramétré\n    \nDesc:\n    la pente est donné par une interpolation linéaire entre le rayon de la base et au sommet\n    La distance n'est pas exact, puisque la distance se fait perpendiculairement à AB et non pas à la pente.\n\n*/\nObjet cone(in vec3 A, in vec3 B, in float radiusBottom, in float radiusTop, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    Objet res;\n    vec3 norm = normalize(B - A);\n    \n    vec3 AP = point - A;\n    \n    float projP = dot(AP, norm);\n\n    \n    float heightRatio = projP / distance(A, B);\n    res = Objet(\n        sqrt(length(AP) * length(AP) - projP * projP) - (heightRatio * radiusTop + (1.f - heightRatio) * radiusBottom),\n        iTex, texPos, texAngle\n    );\n    \n    return opI(res, \n        plan(A + 0.5 * length(B - A), norm, 0.5*length(B-A), point, iTex, texPos, texAngle)\n    );\n}\n\n\n//=============//\n//             //\n//   TEXTURE   //\n//             //\n//=============//\n\n\n\nTexture Damier(in vec3 p, in float size, in vec3 displacement) {\n    //float size = 25.;\n    //vec3 displacement = vec3(0, 0, 0);\n    \n    int r = int(floor(displacement + p.x / size)) + int(floor(displacement + p.z / size)) + int(floor(displacement + p.y / size));\n    if(r % 2 == 0)\n        return Texture(vec3(0.2, 0.2, 0.2), mat);\n    return Texture(vec3(1, 1, 1), mat);\n}\n\nTexture DamierDef(in vec3 p, in vec2 defCoeff, in float size, in vec3 displacement) {\n    float def = Noise(p / defCoeff.x) * defCoeff.y;\n    p.x += def;\n    p.y += def;\n    p.z += def;\n    \n    return Damier(p, size, displacement);\n}\n\nTexture Point(in vec3 p) {\n    float size = 10.;\n    p += vec3(5.);\n    p = vec3(fract(p.x / size), fract(p.y / size), fract(p.z / size));\n    \n    p -= vec3(0.5);\n    \n    if(length(p.xyz) < 0.2)\n        return Texture(vec3(0.2, 0.2, 0.2), mat);\n    return Texture(vec3(1, 1, 1),mat);   \n}\n\nTexture Bois(in vec3 p) {\n    float freq = 3.;\n\n\n    p *= freq;\n    float d = length(p.xz) + 3. * Noise(vec3(p.x, 0, p.z) / 6.);\n    d = pow(cos(d), 6.) * .5;\n    \n    vec3 colB = vec3(169,137,86) / 255.;\n    vec3 colA = vec3(96,76,49) / 255.;\n    \n    Texture res;\n    res.specIndex = 1.;\n    res.specCoeff = 0.25;\n    res.reflectCoeff = 0.;\n    res.transparency = 0.;\n    res.col = mix(colB, colA, d);\n    \n    res.specCol = res.col;\n    \n    return res;\n}\n\nTexture Marbre(in vec3 p) {\n    Texture res;\n    vec3 colA = vec3(230)/255.;\n    vec3 colB = vec3(200)/255.;\n    vec3 colD = vec3(100, 85,75)/255.;\n\n    float freq = 0.4;\n    float ampl = 4.;\n    \n\n    float height = p.y + Noise(p * freq) * ampl;\n    float noise = Noise(vec3(height) / freq);\n    \n    float d = plan(vec3(0), vec3(0, 1, 0), 0.25, fract(vec3(height + noise * 3.) / 10.), WHITE, vec3(0), vec3(0)).dist;\n    //d *= (Noise(p) > 0.5) ? 0. : 1.;\n    if(d < -0.2) \n        res.col = colD;\n    else \n        res.col = mix(colA, colB, noise);\n   \n    \n    //sans gamma correction mix(0.25, 0., noise)\n    res.specCoeff = mix(1., 0.25, noise);\n    res.specCol = res.col;\n    res.reflectCoeff = mix(.05, 0., noise);\n    res.transparency = 0.;\n    res.specIndex = 30.;\n    return res;\n}\n\nTexture MarbreNoir(in vec3 p) {\n    Texture res;\n    \n    //veine principalement repris de Maxime\n    float height = fract(p.y*Noise(p/16.) * 0.2)*Noise(p/16.);\n    \n    float plan = plan(vec3(0.,0.,0.), vec3(0, 1, 0), 0.02, vec3(p.x, height, p.z), WHITE, vec3(0), vec3(0)).dist;\n\n    \n    if(plan <= 0.) { //veine\n    \n    \n        res.col = vec3(0.7);\n        res.specCoeff = 0.25;\n        res.specIndex = 1.;\n        res.transparency = 0.;\n        res.reflectCoeff = 0.;\n        \n        \n    }\n    else { //marbre\n    \n    \n        vec3 colClair = vec3(66) / 255.;\n        vec3 colSombre = vec3(30) / 255.;\n    \n        float BigNoise = Noise(p * 0.15);\n        float SmallNoise = Noise(p * 10.);\n    \n        float rep = 0.2;\n    \n        vec3 background_color = mix(\n                mix(colSombre, colClair, BigNoise),\n                mix(colClair, colSombre, SmallNoise),\n                rep);\n    \n        float background_index = mix(\n                mix(30., 5., BigNoise),\n                mix(5., 30., SmallNoise),\n                rep);\n        \n        res.col = background_color;\n        res.specCoeff = 0.5;\n        res.specIndex = background_index;\n        res.reflectCoeff = 0.05;\n        res.transparency = 0.;\n        \n        \n    }\n    res.specCol = res.col;\n    return res;\n}\n\nTexture Sable(in vec3 p) {\n    Texture res;\n    \n    float freq = 8.;\n    \n    float noise = Noise(p * freq);\n    \n    vec3 colA = vec3(227,222,187) / 255.;\n    vec3 colB = vec3(150,152,105) / 255.;\n\n    res.col = mix(colA, colB, noise);\n    res.specCol = mix(colA, vec3(1.), noise);\n    res.specIndex = mix(5., 0., noise);\n    res.specCoeff = mix(0.75, 0.25, noise);\n    res.transparency = 0.;\n    \n    return res;\n}\n\nTexture Rouille(in vec3 p) {\n    Texture res;\n    \n    vec3 clair = vec3(0.75);\n    vec3 sombre = vec3(0.65);\n    vec3 rouilleO = vec3(154,97,63)/255.;\n    vec3 rouilleB = vec3(111,73,61) /255.;\n    \n    \n    float repartition = 0.6;\n    //turbulence avec 2 niveau de bruit\n    float noise =  Noise(p * 0.2) * repartition + Noise(p * 8.) * (1. - repartition) ;\n    \n    \n    //couleur  specIndex specCoeff relfectCoeff\n    //clair     25.       1.        0.1 \n    //sombre    5.        1.        0.05\n    //rouilleO  5.        0.25      0.\n    //rouilleB  1.        0.        0.\n    \n    //         vvv    Coeff de rouille: 0 = entièrement rouillé\n    if(noise > 0.4) { //rouille\n        res.col = mix(sombre, mix(rouilleO, rouilleB, noise), noise);\n        res.specIndex = mix(5., mix(5., 1., noise), noise);\n        res.specCoeff = mix(1., mix(0.25, 0., noise), noise);\n        res.reflectCoeff = mix(0.1, 0., noise);\n        res.transparency = 0.;\n        \n    } else { //background: rayure\n        noise = Noise(vec3(p.y) * 10.);\n        res.col = mix(clair, sombre, noise);\n        res.specIndex = mix(25., 5., noise);\n        res.specCoeff = 1.;\n        res.reflectCoeff = mix(0.1, 0.05, noise);\n        res.transparency = 0.;\n    }\n    \n    \n    res.specCol = res.col;\n    return res;\n}\n\nTexture Metal(in vec3 p) {\n    Texture res;\n    \n    vec3 clair = vec3(0.75);\n    vec3 sombre = vec3(0.65);\n    \n    float noise = Noise(vec3(p.y) * 10.);\n    res.col = mix(clair, sombre, noise);\n    res.specIndex = mix(25., 5., noise);\n    res.specCoeff = 1.;\n    res.reflectCoeff = mix(0.1, 0.05, noise);\n    res.transparency = 0.;\n    \n    \n    \n    res.specCol = res.col;\n    return res;\n}\n\n\n\nTexture Verre(in vec3 p) {\n    Texture res;\n    res.col = vec3(0.8);\n    res.specIndex = 20.;\n    res.specCol = res.col;\n    res.specCoeff = 0.25;\n    res.reflectCoeff = 0.1;\n    res.transparency = 0.1;\n    return res;\n}\n\nTexture Eau(in vec3 p) {\n    Texture res;\n    res.col = vec3(7,66,127) / 255.;\n    res.specCol = vec3(1., 0.6, 0.8);\n    res.specIndex = 50.;\n    res.specCoeff = 0.5;\n    res.reflectCoeff = 0.1;\n    res.transparency = 0.;\n    \n    return res;\n}\n\nTexture Herbe(in vec3 p) {\n    Texture res;\n    \n    float noise = Noise(p * 3.);\n    \n    res.col = vec3(31, 138, 19) / (255. + noise * 100.);\n    res.specCol = vec3(1.);\n    res.specIndex = 1.;\n    res.specCoeff = 0.15 + (noise - 0.5) * 0.1;\n    res.reflectCoeff = 0.;\n    res.transparency = 0.;\n    \n    return res;\n}\n\n//===============//\n//               //\n//   Animation   //\n//               //\n//===============//\n\n\n//retourne la distance parcourue\nfloat updatePos(inout vec3 pos, inout vec3 speed, in vec3 acc, in float dt) {\n    vec3 dist = pos;\n    pos = pos + speed * dt + acc * dt * dt;\n    speed = speed + acc * dt;\n    dist -= pos;\n    return length(dist);\n}\n\n","name":"Common","description":"","type":"common"}]}