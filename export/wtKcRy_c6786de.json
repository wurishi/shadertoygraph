{"ver":"0.1","info":{"id":"wtKcRy","date":"1611362067","viewed":179,"name":"voronoi texture (vlllll)","username":"valalalalala","description":"Use a voronoi pattern to modify the geometry of a sphere and act as a texture.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"voronoi texture\"                                         // //\n     //                                                            //  //\n    //  Use a voronoi pattern to modify the geometry of a sphere  //   //\n   //  and act as a texture.                                     //    //   \n  //  see https://www.shadertoy.com/view/WlKyDm                 //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////\n// scene controls\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\n#define ZED   .0\n#define PI2   6.283185307179586\n\n////////////////////////////////////////////////////////////////\n// ray marching\n\n#define STEPS 99\n#define CLOSE .001\n#define FAR   99.\n#define EPZ   vec2( ZED, CLOSE )\n\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv)  ( ( 2. * uv - iResolution.xy ) / iResolution.y )\n#define TRIG(a)    vec2( cos( a  * PI2 ), sin( a * PI2 ) )\n\n////////////////////////////////////////////////////////////////\n\nfloat getDistance( vec3 p ) {\n    vec3 vv = voronoi( p, iTime );\n    \n    vec3 n = normalize( p );\n    float v = dot( abs( n ), vv );\n    v = pow( v, 4. );\n      \n    float r = 2. - v * .04; \n    float d = length(p)-r;\n    \n    return d *.8;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat march( vec3 a, vec3 ab ) {\n    float d = .0;\n    for ( int i = 0 ; i < STEPS ; i++ ) {\n        vec3 b = a + d * ab;\n        float n = getDistance( b );\n        d += n;\n        if ( abs( n ) < CLOSE || d > FAR ) break;\n    }\n    return d;\n}\n\nvec3 getDistances( vec3 a, vec3 b, vec3 c ) {\n    return vec3( getDistance( a ), getDistance( b ), getDistance( c ) );\n}\n\nvec3 getNormal( vec3 p ) {\n    return normalize( getDistance( p ) - \n        getDistances( p - EPZ.yxx, p - EPZ.xyx, p - EPZ.xxy )\n    );\n}\n\n////////////////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( TRIG( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec2 getMouse() {\n    return iMouse.z > .0\n        ? FROM_SCREEN( iMouse.xy )\n        : vec2( .44 * cos( iTime * .22 ), .33 )\n    ;  \n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 primaryColor() {\n    vec2 t = TRIG( iTime * .01 );\n    vec3 c = vec3(1.,.2,.1);\n    mat2 rotate = mat2( t.x, -t.y, t.y, t.x );\n    c.xy *= rotate;\n    c.zx *= rotate;\n    return abs( c );\n}\n\nvec3 colorHit( vec3 p ) {\n    vec3 vv = voronoi( p, iTime );\n    vec3 n = getNormal( p );\n    float v = dot( abs( n ), vv );\n    \n    // light overhead\n    float l = max( .1, pow( MAP_11_01( n.y ), 2. ) );\n\n    // surprisingly important...\n    v = clamp(v,.0,1.);\n    \n    return l * v * primaryColor();\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    uv = uv + TRIG( iTime * .0033 ) * 13.;\n    float v = voronoi( uv, iTime );\n    return .66 * v * primaryColor();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = FROM_SCREEN( fragCoord );\n    float view = 4.;\n    float zoom = 2.2;\n    \n    ////\n    \n    vec2 m = getMouse();  \n    vec2 t = view * TRIG( m.x );\n    \n    vec3 a = vec3( t.x, view * TRIG( m.y ).y, t.y );       \n    vec3 b = vec3( ZED );\n\n    vec3 ab = normalize( makeCamera( a, b, .0 ) * vec3( uv, zoom ) );\n    \n    ////\n\n    float d = march( a, ab );\n    float hit = step( d, FAR );\n    vec3 p = hit * ( a + ab * d );\n    \n    ////\n    \n    vec3 color = mix( colorMiss( uv ), colorHit( p ), hit );\n    \n    float foginess = pow( d / FAR, .33 ) * hit;\n    vec3 fog = vec3( .22, .11, .4 );\n    color = mix( color, fog, foginess );\n    \n    fragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"voronoi texture\"                                         // //\n     //                                                            //  //\n    //  Use a voronoi pattern to modify the geometry of a sphere  //   //\n   //  and act as a texture.                                     //    //   \n  //  see https://www.shadertoy.com/view/WlKyDm                 //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// scene controls\n\n// alternative distance metrics\n\n#define MANHATTAN_\n#define DOTTY_\n\n// alternative voronoi combinations\n#define FBM_\n#define IFBM_\n\n// for some reason... mix isn't working for me...\n#define MIX(x,y,a)   ((1.-a) * x + y * a)\n#define MIX2(x,y,a)  mix(x,y,a)\n#define USE_MIX_INSTEAD_OF_IFS_NOT\n\n////////////////////////////////////////////////////////////////\n\n#define MAP_11_01(v)     ( v * .5 + .5 )\n\n////////////////////////////////////////////////////////////////\n// functions \n\nvec2 hash22( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( vec2( q.x * q.y, q.y * q.z ) );\n}\n\nvec4 makeVoronoiPoint( in vec2 id, float time ) {\n    vec2 n = hash22( id ) ;\n    vec2 point = sin( n * time ) * .5 + .5;\n    return vec4( point.xy, n.xy );\n}\n\nfloat voronoiDistanceMetric( in vec2 st ) {\n    #ifdef MANHATTAN\n    return abs( st.x ) + abs( st.y );\n    #endif\n    \n    #ifdef DOTTY\n    st = abs( st );\n    return dot( st, st ) / ( st.x + st.y );\n    #endif\n   \n    return length( st );\n}\n\nvec3 calculateVoronoiDistance( in vec2 st, in vec2 id, in vec2 neighbor, float time ) {\n    vec4 voronoiPoint = makeVoronoiPoint( id + neighbor, time );\n    st -= voronoiPoint.xy + neighbor;\n    \n    float d = voronoiDistanceMetric( st );\n\n    return vec3( d, voronoiPoint.xy );\n    return vec3( d, id );\n}\n\nvec3 calculateVoronoiPoint( in vec2 st, in vec2 id, float time ) {\n    vec3 voronoi_n1_n1 = calculateVoronoiDistance( st, id, vec2( -1., -1. ), time );\n    vec3 voronoi_n1_n0 = calculateVoronoiDistance( st, id, vec2( -1., -0. ), time );\n    vec3 voronoi_n1_p1 = calculateVoronoiDistance( st, id, vec2( -1., +1. ), time );\n    vec3 voronoi_n0_n1 = calculateVoronoiDistance( st, id, vec2( -0., -1. ), time );\n    vec3 voronoi_n0_n0 = calculateVoronoiDistance( st, id, vec2( -0., -0. ), time );\n    vec3 voronoi_n0_p1 = calculateVoronoiDistance( st, id, vec2( -0., +1. ), time );\n    vec3 voronoi_p1_n1 = calculateVoronoiDistance( st, id, vec2( +1., -1. ), time );\n    vec3 voronoi_p1_n0 = calculateVoronoiDistance( st, id, vec2( +1., -0. ), time );\n    vec3 voronoi_p1_p1 = calculateVoronoiDistance( st, id, vec2( +1., +1. ), time );\n\n    vec3 closest = vec3( 1e33 );\n#ifdef USE_MIX_INSTEAD_OF_IFS\n    closest = MIX( closest, voronoi_n1_n1, step( voronoi_n1_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n1_n0, step( voronoi_n1_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_n1_p1, step( voronoi_n1_p1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_n1, step( voronoi_n0_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_n0, step( voronoi_n0_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_p1, step( voronoi_n0_p1.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_n1, step( voronoi_p1_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_n0, step( voronoi_p1_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_p1, step( voronoi_p1_p1.x, closest.x ) );\n#else\n    if ( voronoi_n1_n1.x < closest.x ) closest = voronoi_n1_n1;\n    if ( voronoi_n1_n0.x < closest.x ) closest = voronoi_n1_n0;\n    if ( voronoi_n1_p1.x < closest.x ) closest = voronoi_n1_p1;\n    if ( voronoi_n0_n1.x < closest.x ) closest = voronoi_n0_n1;\n    if ( voronoi_n0_n0.x < closest.x ) closest = voronoi_n0_n0;\n    if ( voronoi_n0_p1.x < closest.x ) closest = voronoi_n0_p1;\n    if ( voronoi_p1_n1.x < closest.x ) closest = voronoi_p1_n1;\n    if ( voronoi_p1_n0.x < closest.x ) closest = voronoi_p1_n0;\n    if ( voronoi_p1_p1.x < closest.x ) closest = voronoi_p1_p1;\n#endif\n    return closest;\n}\n\nfloat vornoing( in vec2 uv, float scale, float time ) {\n    uv *= scale;\n    \n    vec2 st = fract( uv );\n    vec2 id = uv - st;\n\n    vec3 closest = calculateVoronoiPoint( st, id, time );\n    return closest.x;\n}\n\nfloat voronoi( vec2 uv, float time ) {\n    float s = 1.;\n    #ifdef FBM\n    return .0\n        + .1 * vornoing( uv + 33. * s,  1., time )\n        + .2 * vornoing( uv + 17. * s,  3., time )\n        + .3 * vornoing( uv +  9. * s,  7., time )\n        + .4 * vornoing( uv +  5. * s, 13., time )\n    ;\n    #endif\n\n    #ifdef IFBM\n    return .0\n        + .4 * vornoing( uv + 33. * s,  1., time )\n        + .3 * vornoing( uv + 17. * s,  3., time )\n        + .2 * vornoing( uv +  9. * s,  7., time )\n        + .1 * vornoing( uv +  5. * s, 13., time )\n    ;\n    #endif\n\n    return vornoing( uv, 7., time );\n}\n\nvec3 voronoi( vec3 p, float time ) {\n    return vec3(\n        voronoi( MAP_11_01( p.yz ), time ),\n        voronoi( MAP_11_01( p.zx ), time ),\n        voronoi( MAP_11_01( p.xy ), time )\n    );\n}\n","name":"Common","description":"","type":"common"}]}