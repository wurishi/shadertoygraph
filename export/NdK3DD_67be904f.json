{"ver":"0.1","info":{"id":"NdK3DD","date":"1631577512","viewed":102,"name":"Green matrix dude","username":"NataliaP","description":"_","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define r(s) fract(43.*sin(s.x*13.+s.y*78.))\n\nconst vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat dBox ( vec3 p, vec3 b )\n{\n\treturn length8 ( max ( abs ( p ) - b, 0.0 ) );\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat dGreenDude (in vec3 q) \n{\n    return min(min(min(dBox ( q, vec3 ( 0.5, 0.5, 0.7 )), \n      dBox ( q + vec3( 0.0, 0.0, 0.8), vec3 ( 0.4, 0.4, 0.4 ))),\n      dBox ( q + vec3( - 0.7, 0.0, -0.9), vec3 ( 0.2, 0.5, 0.2 ))),\n      dBox ( q + vec3( + 0.7, 0.0, -0.9), vec3 ( 0.2, 0.5, 0.2 )));\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p + vec3(cos(iTime), sin(iTime), 0);\n   \n   return dGreenDude(q);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 i = fragCoord;\n    vec2 j = fract(i*=50./iResolution.x), \n        p1 = i-j+ vec2(2,floor(iTime*20.*fract(sin(i-j).x)));\n    i      = abs(j-.5);\n    vec4 o =  vec4(r(floor(p1*23.+5.*j))>.5&&i.x<.3&&i.y<.45 ?   1. - r(p1)*\n         (2.-dot(i,i)*6.)  :  1.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 10.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 0, 1 );\n\t}\n\n    // Output to screen\n    fragColor = 1.2*color - 0.18*o;\n}\n","name":"Image","description":"","type":"image"}]}