{"ver":"0.1","info":{"id":"ftKGRm","date":"1637462964","viewed":59,"name":"near misses","username":"Mr_Steve","description":"hat tip to inspirnathan","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rotations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rotation matrices\nmat3 rotateX(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1.,0.,0.),\n        vec3(0.,c,-s),\n        vec3(0.,s,c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// identity matrix\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n float sd;\n vec3 col;\n};\n\nSurface sdBox(vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform){\n    p = (p - offset) * transform - vec3(3.,0.,0.);\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.)) + min(max(q.x, max(q.y,q.z)), 0.);\n    return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col){\n    float d = p.y + 1.;\n    return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2){\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface sdScene(vec3 p){\n    vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    Surface co = sdFloor(p, floorColor);\n    co = minWithColor(co,sdBox(\n        p,\n        vec3(.5),\n        vec3(0.,.5,-4.),\n        vec3(1.,0.,0.),\n        rotateY(iTime)\n    ));\n    co = minWithColor(co,sdBox(\n        p,\n        vec3(.25),\n        vec3(0.,1.5,-4.),\n        vec3(.5,.8,.2),\n        rotateY(-iTime) * rotateX(iTime*0.5)\n    ));\n    co = minWithColor(co,sdBox(\n        p,\n        vec3(.25,.1,.2),\n        vec3(0.,.25,-4.),\n        vec3(.1,.5,.8),\n        rotateY(-iTime*0.3) * rotateZ(iTime*0.75)\n    ));\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end){\n    float depth = start;\n    Surface co;\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        vec3 p = ro + depth *rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > end) break;\n    }\n    \n    co.sd = depth;\n    \n    return co;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1.0, 1.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    \n    if (co.sd > MAX_DIST){\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + rd * co.sd;\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2.0, 2.0, 7.0);\n        vec3 lightDirection = normalize(lightPosition - p);\n        \n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.0);\n        \n        col = dif * co.col + backgroundColor * 0.2;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}