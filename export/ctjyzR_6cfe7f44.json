{"ver":"0.1","info":{"id":"ctjyzR","date":"1692162710","viewed":37,"name":"light2d_3_shape","username":"shicz86","description":"2d ray marching\nthis demo can be optimised,but i just want to translate the orginal c version to shadertoy.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec4 data = texture(iChannel0,uv);\n    vec3 col = data.xyz/data.w;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ref:https://zhuanlan.zhihu.com/p/30816284\n\n// light2d_1_basic        https://www.shadertoy.com/view/DtSczR\n// light2d_2_csg          https://www.shadertoy.com/view/mlSyzz\n// light2d_3_shape        https://www.shadertoy.com/view/ctjyzR\n// light2d_4_reflection   https://www.shadertoy.com/view/dtSyzh\n// light2d_5_refraction   https://www.shadertoy.com/view/ctjcRc\n// light2d_6_fresnel      https://www.shadertoy.com/view/Dl2czt\n// light2d_7_beer-lambert https://www.shadertoy.com/view/dl2yWG\n\n#define TWO_PI 6.28318530718f\n#define N 64\n#define MAX_STEP 64\n#define MAX_DISTANCE 2.0f\n#define EPSILON 1e-6f\n\nstruct Result\n{\n    float sd;\n    float emissive;\n};\n\nfloat random (vec2 pos) \n{\n    return fract(sin(dot(pos.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nResult unionOp(Result a,Result b)\n{\n    if(a.sd<b.sd)\n        return a;\n    else\n        return b;\n}\n\nResult intersectOp(Result a,Result b)\n{\n    Result r;\n    float sd;\n    if(a.sd>b.sd)\n    {\n        r = b;\n        sd = a.sd;\n    }\n    else\n    {\n        r = a;\n        sd = b.sd;\n    }\n    r.sd = sd;\n    return r;\n}\n\nResult subtractOp(Result a,Result b)\n{\n    Result r = a;\n    float sd;\n    if(a.sd>-b.sd)\n        sd = a.sd;\n    else\n        sd = -b.sd;\n    r.sd = sd;\n    return r;\n}\n\nfloat CircleSDF(vec2 pos,vec2 center,float r)\n{\n    return length(pos-center)-r;\n}\n\nfloat PlaneSDF(vec2 pos,vec2 p,vec2 n)\n{\n    return dot(pos-p,n);\n}\n\nfloat SegmentSDF(vec2 pos,vec2 a,vec2 b)\n{\n    vec2 v = pos-a;\n    vec2 u = b-a;\n    float t = max(min(dot(v,u)/dot(u,u),1.0f),0.0f);\n    return length(v-u*t);\n}\n\nfloat CapsuleSDF(vec2 pos,vec2 a,vec2 b,float r)\n{\n    return SegmentSDF(pos,a,b)-r;\n}\n\nfloat BoxSDF(vec2 pos,vec2 c,float theta,vec2 s)\n{\n    float costheta = cos(theta);\n    float sintheta = sin(theta);\n    float dx = abs((pos.x-c.x)*costheta+(pos.y-c.y)*sintheta)-s.x;\n    float dy = abs((pos.y-c.y)*costheta-(pos.x-c.x)*sintheta)-s.y;\n    float ax = max(dx,0.0f);\n    float ay = max(dy,0.0f);\n    return min(max(dx,dy),0.0f)+sqrt(ax*ax+ay*ay);\n}\n\nfloat TriangleSDF(vec2 pos,vec2 a,vec2 b,vec2 c)\n{\n    float d = min(min(SegmentSDF(pos,a,b),SegmentSDF(pos,b,c)),SegmentSDF(pos,c,a));\n    float sd;\n    if((b.x-a.x)*(pos.y-a.y)>(b.y-a.y)*(pos.x-a.x) &&\n        (c.x-b.x)*(pos.y-b.y)>(c.y-b.y)*(pos.x-b.x) &&\n        (a.x-c.x)*(pos.y-c.y)>(a.y-c.y)*(pos.x-c.x))\n    {\n        sd = -d;\n    }\n    else\n        sd = d;\n    return sd;\n}\n\nResult scene(vec2 pos)\n{\n    Result a = Result(CircleSDF(pos,vec2(0.0f,0.0f),0.2f),2.0f);\n    Result b = Result(PlaneSDF(pos,vec2(0.0f,0.0f),vec2(0.0f,-1.0f)),0.8f);\n    return intersectOp(a,b);\n    \n    //Result c = Result(CapsuleSDF(pos,vec2(-0.1f,0.1f),vec2(0.1f,-0.1f),0.1f),1.0f);\n    //return c;\n    \n    //Result d = Result(BoxSDF(pos,vec2(0.0f,0.0f),-TWO_PI/16.0f,vec2(0.3f,0.1f)),1.0f);\n    //return d;\n    \n    //Result e = Result(BoxSDF(pos,vec2(0.0f,0.0f),-TWO_PI/16.0f,vec2(0.3f,0.1f))-0.1f,1.0f);\n    //return e;\n    \n    //Result f = Result(TriangleSDF(pos,vec2(0.0f,0.2f),vec2(0.3f,-0.3f),vec2(-0.2f,-0.1f)),1.0f);\n    //return f;\n    \n    //Result g = Result(TriangleSDF(pos,vec2(0.0f,0.2f),vec2(0.3f,-0.3f),vec2(-0.2f,-0.1f))-0.1f,1.0f);\n    //return g;\n}\n\nfloat trace(vec2 origin,vec2 dir)\n{\n    float t = 0.0f;\n    for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;i++)\n    {\n        Result r = scene(origin+dir*t);\n        if(r.sd<EPSILON)\n            return r.emissive;\n        t += r.sd;\n    }\n    return 0.0f;\n}\n\n// https://stackoverflow.com/questions/33270823/how-to-cast-int-to-float-in-glsl-webgl\nfloat lightSample(vec2 pos)\n{\n    float sum = 0.0f;\n    float n_float = float(N);\n    float rand = random(pos)+iTime;\n    for(int i=0;i<N;i++)\n    {\n        float i_float = float(i);\n        //float rand = random(pos+random(vec2(i_float,i_float)));\n        //float a = TWO_PI*rand;// uniform sampling\n        //float a = TWO_PI*i_float/n_float; // stratified sampling\n        float a = TWO_PI*(i_float+rand)/n_float; // jittered sampling\n        sum += trace(pos,vec2(cos(a),sin(a)));\n    }\n    return sum/n_float;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float col = lightSample(uv);\n    vec4 data = texture(iChannel0,fragCoord/iResolution.xy);\n    if(iFrame==0)\n    {\n        data=vec4(0.);\n    }\n    data += vec4(vec3(col),1.0);\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}