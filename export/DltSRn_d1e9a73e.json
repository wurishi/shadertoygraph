{"ver":"0.1","info":{"id":"DltSRn","date":"1689188416","viewed":108,"name":"The Cornell Spheres","username":"TextBox","description":"My attempt at raytracing.\nFeel free to suggest improvements in the comments below.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","globalillumination","pathtracing","rendering","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Material\n{\n    vec4 c;\n    float r;\n    float m;\n    float f0;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nstruct Hit\n{\n    float t;\n    Material m;\n    vec3 n;\n};\n\nstruct Sphere\n{\n    vec3 o;\n    float r;\n    Material m;\n};\n\nstruct Plane\n{\n    vec3 o;\n    vec3 n;\n    Material m;\n};\n\nstruct Light\n{\n    vec3 o;\n    vec4 c;\n    float r;\n};\n\nconst Material nm = Material(vec4(0), 0.0, 0.0, 0.0);\n\nconst Material sphm = Material(vec4(1, 1, 1, 1), 1.0, 0.0, 0.0);\nconst Material sph2m = Material(vec4(0, 1, 0, 1), 0.5, 1.0, 0.4);\nconst Material sph3m = Material(vec4(0, 0, 1, 1), 0.1, 0.0, 0.1);\n\nconst Material plnm = Material(vec4(0.8, 0.8, 0.8, 1), 1.0, 0.0, 0.0);\nconst Material pln2m = Material(vec4(1.0, 0, 0, 1), 1.0, 0.0, 0.0);\nconst Material pln3m = Material(vec4(0.0, 1.0, 0.0, 1), 1.0, 0.0, 0.0);\n\nSphere sph = Sphere(vec3(-0.1, 0.05, 0.), 0.05, sphm);\nSphere sph2 = Sphere(vec3(0, 0.05, 0.05), 0.05, sph2m);\nSphere sph3 = Sphere(vec3(0.1, 0.05, 0.0), 0.05, sph3m);\n\nPlane pln = Plane(vec3(0, 0, 0), vec3(0, 1, 0), plnm);\nPlane pln2 = Plane(vec3(-0.15, 0, 0), vec3(1, 0, 0), pln2m);\nPlane pln3 = Plane(vec3(0.15, 0, 0), vec3(-1, 0, 0), pln3m);\nPlane pln4 = Plane(vec3(0, 0.3, 0), vec3(0, -1, 0), plnm);\nPlane pln5 = Plane(vec3(0, 0, 0.15), vec3(0, 0, -1), plnm);\n\nLight l = Light(vec3(0, 0.2, 0.0), vec4(0.35), 0.05);\n\n///////////////////////////////////////////////////////////////////////\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 randomvec(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n///////////////////////////////////////////////////////////////////////\n\nHit sintersect(Sphere sph, Ray r)\n{   \n    r.o = r.o - sph.o;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.o, r.d);\n    float c = dot(r.o, r.o) - sph.r * sph.r;\n    float d = sqrt(b * b - 4.0 * a * c);\n    \n    if (d >= 0.0)\n    {\n        float t = (-b - d) / (2.0 * a);\n        return Hit(t, sph.m, normalize(r.o + r.d * t));\n    }\n    else\n        return Hit(-1.0, nm, vec3(0));\n}\n\nHit pintersect(Plane p, Ray r)\n{\n    float d = dot(p.n, r.d - p.o);\n    if (d < 0.0) \n        return Hit(dot(p.o - r.o, p.n) / dot(r.d, p.n), p.m, p.n);\n    else\n        return Hit(-1.0, nm, vec3(0));\n}\n\nHit compare(Hit a, Hit b)\n{\n    if (a.t < 0.0)\n        return b;\n    else if (b.t < 0.0)\n        return a;\n    else if (a.t < b.t)\n        return a;\n    else\n        return b;\n}\n\nHit intersectscene(Ray r)\n{    \n    Hit h = compare(sintersect(sph, r), sintersect(sph2, r));\n    h = compare(h, sintersect(sph3, r));\n    h = compare(h, pintersect(pln, r));\n    h = compare(h, pintersect(pln2, r));\n    h = compare(h, pintersect(pln3, r));\n    h = compare(h, pintersect(pln4, r));\n    h = compare(h, pintersect(pln5, r));\n    return h;\n}\n\nvec4 CookTorrance(Ray r, Hit h)\n{\n    // BRDF = KD * Lambert + Cook Torrance\n    \n    vec3 hp = r.o + r.d * h.t; \n    vec3 vv = normalize(r.o - hp);\n    vec3 lv = normalize(l.o - hp);\n    vec3 hv = normalize(lv + vv);\n    \n    float nom = h.m.r * h.m.r;\n    float mdist = nom / (3.14159 * pow(pow(max(dot(hv, h.n), 0.0), 2.0) * (nom - 1.0) + 1.0, 2.0)); // Trowbridge-Reitz\n    \n    float k = h.m.r / 2.0;\n    float geomV = max(dot(h.n, vv), 0.0) / (max(dot(h.n, vv), 0.0) * (1.0 - k) + k); // geometry schlick\n    float geomL = max(dot(h.n, lv), 0.0) / (max(dot(h.n, lv), 0.0) * (1.0 - k) + k);\n    float smith = geomV * geomL;\n    \n    vec3 f0 = mix(vec3(h.m.f0), h.m.c.rgb, h.m.m);\n    vec3 fresnel = f0 + (1.0 - f0) * pow(1.0 - max(dot(hv, vv), 0.0), 5.0); // this is ks\n    \n    vec3 cook = (mdist * smith * fresnel) / (4.0 * max(dot(h.n, vv), 0.0) * max(dot(h.n, lv), 0.0) + 0.0001); \n    vec3 lambert = h.m.c.rgb / 3.14159;\n    vec3 BRDF = (1.0 - fresnel) * lambert + cook;\n    return vec4(vec3(BRDF), 1.0);\n}\n\nfloat CalcShadow(vec3 hp)\n{\n    vec3 lp = l.o + randomvec(g_seed) * l.r; \n    vec3 lv = normalize(lp - hp);\n    float ll = length(lp - hp);\n    Ray sr = Ray(hp + lv * 0.0001, lv);\n    Hit sh = intersectscene(sr);\n    float hl = length((hp + lv * sh.t) - hp);\n    if (ll > hl) \n        return 0.4;\n    else\n        return 1.0;\n}\n\nvec4 LightScene(Ray r)\n{         \n    vec4 c = vec4(0);\n    vec4 e = l.c;\n    float s = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        Hit h = intersectscene(r);\n        if (h.t < 0.0)\n            break; \n            \n        vec3 hp = r.o + r.d * h.t;\n        vec3 lv = normalize(l.o - hp);\n        float a = 1.0 / distance(l.o, hp);\n        \n        if (i == 0)\n            s = CalcShadow(hp);\n        \n        vec4 BRDF = CookTorrance(r, h);\n        c += (e * a + h.m.c * (1.0 - h.m.r)) * BRDF * max(dot(h.n, lv), 0.0) * s; \n        r.d = normalize(h.n + h.m.r * randomvec(g_seed));\n        e *= h.m.c * max(dot(r.d, h.n), 0.0);\n        \n        r.o = hp + h.n * 0.0001;\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    Ray r = Ray(vec3(0.0, 0.1, -0.2), vec3(uv.x, uv.y, 1));\n\t\n    vec4 c = vec4(0);\n    int s = 16;\n    for (int i = 0; i < s; i++)\n        c += LightScene(r);\n    c /= float(s);\n    \n    vec4 tex = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = (tex * float(iFrame) + c) / (float(iFrame) + 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}