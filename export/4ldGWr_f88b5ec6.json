{"ver":"0.1","info":{"id":"4ldGWr","date":"1468778329","viewed":252,"name":"Spinning S#!t","username":"rwvens","description":"Based on that other concentric rings shader.\n\nI played with it too long and I must now warn of potential side effects including but not limited to [REDACTED].","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","rings","radial","concentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 mm2(in float a){float c = abs( cos(a) ), s = sin(a);return mat2(c,-s,s,c);}\n\nconst float pi = 3.14159265;\nconst float halfpi = pi * 0.5;\n\nfloat saturate( float a )\n{\n\treturn clamp( a, 0.0, 1.0 );\n}\n\n//\n// Fractional Brownian Motion code by IQ.\n\nfloat noise( float x, float y )\n{\n\treturn sin(1.5*x)*sin(1.5*y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm4( float x, float y )\n{\n    vec2 p = vec2( x, y );\n    float f = 0.0;\n    f += 0.5000*noise( p.x, p.y ); p = m*p*2.02;\n    f += 0.2500*noise( p.x, p.y ); p = m*p*2.03;\n    f += 0.1250*noise( p.x, p.y ); p = m*p*2.01;\n    f += 0.0625*noise( p.x, p.y );\n    return f/0.9375;\n}\n\n// Thanks, Inigo!\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//\n\nconst float linesmooth = 0.0333;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 mainuv = ( fragCoord.xy / iResolution.xy );\n\n    float finalval = 0.0;\n    \n    float rings = 55.0;\n\n    float scale = 1.0;\n    vec2 uv = mainuv * scale - scale * 0.5;\n    uv.x *= aspect;\n        \n    float mainval = 5.0;\n  \tfloat inverseLength = saturate( length( uv ) );\n        \n    float core = pow(mod(inverseLength - iTime * 0.1, 1.0),texture(iChannel0, vec2(0.05, 0)).x*2.0+.25) * rings;\n    float coreident = ceil( core );\n    \n    float colorIdent = fbm4( coreident, iTime * 0.3 );\n    float music = texture(iChannel0, vec2(1.0-coreident/rings, 0)).x;\n    music = music * music;\n\n    vec2 rotatedUVs = uv * mm2( halfpi + fbm4( coreident * 0.01 , iTime*.3 + music/10.0) * pi * pi );\n    rotatedUVs *= mm2( halfpi - fbm4( coreident * 2.0 , iTime*.3 + music/10.0 ) * pi * pi );\n    float arc = ( pi + atan( rotatedUVs.y, rotatedUVs.x ) ) / halfpi;\n    arc /= pi;\n    float arcmod = fract(  arc*colorIdent*colorIdent*100.0+music*music*1.0) \n                 * fract( -arc*colorIdent*colorIdent*100.0+music*music*1.0);\n    float arcpos = smoothstep( 0.2, 0.2025 - coreident * 0.0001, arcmod);\n\n    \n    mainval *= colorIdent * arcpos * music;\n        \n    float coresmooth = fract( core ) * fract( -core );\n  \tfloat corewidth  = fwidth( coresmooth );\n   \tfloat edgethreshold = 0.1;\n    mainval *= smoothstep( edgethreshold - corewidth, edgethreshold + corewidth, coresmooth );\n    finalval += mainval;\n    \n    //\n    \n    finalval = max( finalval, 0.0 ) + 0.0025 * coresmooth;\n    finalval = min( finalval, 1.0 );\n\n    vec3 tint = palette(arc+iTime*.03,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\tfragColor = vec4( vec3( pow( finalval, 1.0 / 2.2 ) ) * 1.0-(1.0-tint)*.15, 1.0 );\n}","name":"Image","description":"","type":"image"}]}