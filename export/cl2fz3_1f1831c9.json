{"ver":"0.1","info":{"id":"cl2fz3","date":"1694318540","viewed":93,"name":"maths functions curves","username":"Yukiya25","description":"It's just a practice to write some maths curves with their gradient behind. \nI wanted to move a little ball on each graph but it became too complicated at my level for the moment. \nThanks for watching.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["curves","plot","practice","maths","bookofshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//it's just a practice for me to remember the curves behavior. there's any licence use itã€€for free.\n// the uv handling on each channel is a bit messy. Since that was done by many tries and errors. Any comment or improvment are welcome.\n\nivec2 chl;\nvec3 color;\nvec2 uv;\nvec3 lineColor=vec3(1.0,0.,0.);\n//vec3 ballColor =vec3(0.,0.,1.);\nfloat thk = 0.01;\n\nfloat plot(vec2 st,float pct,float thk){\n    return smoothstep(pct-thk,pct,st.y)-\n    smoothstep(pct,pct+thk,st.y);\n}\n\nvec3 drawColor(ivec2 chl,float y,vec2 uv,float thk){\n    float plot = plot(uv,y,thk);\n    vec3 background =vec3(y);\n    return (1.-plot)*background+plot*lineColor;\n    \n}\n//FUNCTIONS -------------------------------------------\n\nfloat y1(float x){\n    return smoothstep(0.1,0.9,x);\n}\nfloat y2(float x){\n    return 1.*x;\n}\nfloat y3(float x){\n    return abs(x);\n}\nfloat y4(float x){\n    return pow(x,4.);\n}\nfloat y5(float x){\n    return mod(x,2.0);\n}\nfloat y6(float x){\n    return sqrt(1.-pow(x,2.));\n}\nfloat y7(float x){\n    x=abs(x);\n    if(x>1.) return 0.;\n    x /=0.5;\n    return 1.0-x*x*(2.-x);\n}\nfloat y8(float x){\n    return 8.*x*exp(1.-8.*x);\n}\nfloat y9(float x){\n    return 0.75*(1.+cos(12.*x)/5.)*cos(x+1.)+3.35-3.32+3.32/2.;\n}\nfloat y10(float x){\n    return 0.25*sin(12.*x);\n}\nfloat y11(float x){\n    return atan(x*x*x*x*x);\n}\nfloat y12(float x){\n    return atan(cos(2.*x)/sin(x));\n}\n//-------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float column = 3.;\n    float row = 4.;\n    float nbCase=column*row;\n\n    uv = vec2(fragCoord.x * column, fragCoord.y * row) / iResolution.xy;\n    chl = ivec2(vec2(column,row)*fragCoord.xy / iResolution.xy);\n    \n    ivec2 cl2 = ivec2(0,0);\n    ivec2 cl1 = ivec2(0,1);\n    ivec2 cl3 = ivec2(0,2);\n    ivec2 cl4 = ivec2(0,3);\n    ivec2 cl5 = ivec2(1,0);\n    ivec2 cl6 = ivec2(1,1);\n    ivec2 cl7 = ivec2(1,2);\n    ivec2 cl8 = ivec2(1,3);\n    ivec2 cl9 = ivec2(2,0);\n    ivec2 cl10 = ivec2(2,1);\n    ivec2 cl11 = ivec2(2,2);\n    ivec2 cl12 = ivec2(2,3);\n    \n    //the thickness of the plotline is fixed in each channel with a factor since the uv changes a bit\n    \n    color = chl == cl1? drawColor(cl1 , y1(uv.x-float(cl1.x)) , vec2(uv.x,uv.y-float(cl1.y)) , 1.7*thk):\n            chl == cl2? drawColor(cl2 , y2(uv.x-float(cl2.x)) , vec2(uv.x,uv.y-float(cl2.y)) , 1.1*thk):\n            chl == cl3? drawColor(cl3 , y3(2.*uv.x-float(cl3.x)-1.), vec2(uv.x,uv.y-float(cl3.y)) , 2.*thk):\n            chl == cl4? drawColor(cl4 , y4(uv.x-float(cl4.x)) , vec2(uv.x,uv.y-float(cl4.y)) , 2.*thk):\n            chl == cl5? drawColor(cl5 , y5(8.*uv.x-float(cl5.x)-1.) , vec2(uv.x,uv.y-float(cl5.y)) , 6.*thk):\n            chl == cl6? drawColor(cl6 , y6(2.*uv.x-float(cl6.x)-2.) , vec2(uv.x,uv.y-float(cl6.y)) , 2.*thk):\n            chl == cl7? drawColor(cl7 , y7(uv.x-float(cl7.x)-0.5) , vec2(uv.x,uv.y-float(cl7.y)) , 2.*thk):\n            chl == cl8? drawColor(cl8 , y8(uv.x-float(cl8.x)) , vec2(uv.x,uv.y-float(cl8.y)) , 3.*thk):\n            chl == cl9? drawColor(cl9 , y9(2.*uv.x-float(cl9.x)-1.) , vec2(uv.x,uv.y-float(cl9.y)+0.5) , 4.*thk):\n            chl == cl10? drawColor(cl10 , y10(uv.x-float(cl10.x)+0.1) , vec2(uv.x,uv.y-float(cl10.y)-0.5) , 2.*thk):\n            chl == cl11? drawColor(cl11 , y11(4.*uv.x-float(cl11.x)-8.) , vec2(uv.x,3.3*uv.y-float(cl10.y)-7.3) , 6.*thk):\n            chl == cl12? drawColor(cl12 , y12(12.*uv.x-float(cl12.x)) , vec2(uv.x,12.*uv.y-float(cl12.y)-40.) , 20.*thk):\n            vec3(0.0);\n\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}