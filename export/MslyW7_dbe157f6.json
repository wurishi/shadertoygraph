{"ver":"0.1","info":{"id":"MslyW7","date":"1488536742","viewed":144,"name":"interdimensional rift","username":"Mopnex","description":"interdimensional rift","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interdimensionalrift"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterations 4\n#define formuparam2 0.89\n \n#define volsteps 4\n#define stepsize 0.35190\n \n#define zoom 9.900\n#define tile   0.450\n#define speed2  -0.1\n \n#define brightness 0.1\n#define darkmatter 0.400\n#define distfading 0.8560\n#define saturation 0.400\n\n\n#define transverseSpeed -0.1\n#define cloud 0.2\n\n \nfloat triangle(float x, float a)\n{\n \n \nfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\nreturn output2;\n}\n \n\nfloat field(in vec3 p) {\n\nfloat strength = 8. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\nfloat accum = 0.;\nfloat prev = 0.;\nfloat tw = 0.;\n\n\nfor (int i = 0; i < 6; ++i) {\nfloat mag = dot(p, p);\np = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(iTime*0.2 + 2.0), -1.1+0.3*cos(iTime*0.15));\nfloat w = exp(-float(i) / 7.);\naccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\ntw += w;\nprev = mag;\n}\nreturn max(0., 5. * accum / tw - .7);\n}\n\nfloat Sphere_radius;\n\nvec3 getSurfacePosition(vec2 coord) {\n    \n    float mov_radius;\n    vec2  screen_center;\n    vec3  Sphere_center;\n\n    float index;\n    vec2  tmpv2;\n    float acc;\n    \n    index = 1.0;\n    \n    mov_radius = min(iResolution.x, iResolution.y)*0.25;\n    screen_center = iResolution.xy * 0.5;\n    acc = 0.0;\n    \n    for (int k=0; k<5; k++) {\n        index += 1.0;\n        Sphere_center = vec3(screen_center.x + mov_radius * -cos(iTime*index),\n           screen_center.y + mov_radius * sin(iTime*(5.0-index)*1.013),\n           0.0);\n      \n        tmpv2 = Sphere_center.xy - coord.xy;\n        acc += Sphere_radius/length(tmpv2);\n    }\n    if (acc > 1.00) {\n        acc = 1.0 - 1.0/acc;\n        acc *= Sphere_radius;\n        \n        acc = (Sphere_radius * acc)/(Sphere_radius*0.30 + acc);\n        acc = (Sphere_radius * acc)/(Sphere_radius*0.30 + acc);\n        acc = (Sphere_radius * acc)/(Sphere_radius*0.20 + acc);\n        \n        } else {\n          acc = -200.0;\n      }\n      \n      return vec3(coord, acc);\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 screen_center;\n\n    vec3 ViewDirection;\n    ViewDirection = vec3 (.0,.0,-1.0);\n    \n    float mov_radius;\n    \n    mov_radius = min(iResolution.x, iResolution.y)*0.25;  \n    screen_center = iResolution.xy * 0.5;\n    \n    Sphere_radius = mov_radius*0.2;\n      \n      \n/*******************************************************************************************/\n    vec3 LightColor;\n    vec3 SpecularLightColor[3];\n    vec3 DiffuseLightColor[3];\n    vec3 AmbientLightColor;\n    \n    float DiffuseLightIntensity;\n    float SpecularLightIntensity;\n    float AmbientLightIntensity;\n    \n    DiffuseLightColor[0] = vec3(1.0,0.3,0.2);\n    SpecularLightColor[0] = vec3(0.5,0.7,0.8);\n    \n    DiffuseLightColor[1] = vec3(0.2,0.2,1.0);\n    SpecularLightColor[1] = vec3(0.8,0.8,0.5);\n    \n    DiffuseLightColor[2] = vec3(0.6,1.0,0.2);\n    SpecularLightColor[2] = vec3(0.4,0.5,0.8);\n    \n    AmbientLightColor = vec3(0.1,0.1,0.15);\n    \n    vec3 LightPosition[3];\n    vec3 LightDirection;\n    vec3 SpecularDirection;\n    \n    /***********************************************************/\n    /* Geometry                                                */\n    /***********************************************************/\n    vec3  SurfaceNormal;\n    vec3  SurfacePosition;\n    vec3  Sphere_center;\n    vec3  SurfDX;\n    vec3  SurfDY;\n    vec2  tmpv2;\n    \n    float dist_from_center;\n    \n    dist_from_center = 0.0;\n    \n    float index;\n    float inv;\n    float acc;\n    \n    inv = .0;\n    acc = .0;\n    index = 1.0;\n    \n    SurfacePosition = getSurfacePosition(fragCoord.xy);\n  \n/*****************************************************************************************************************/\n  \nvec2 uv2 = 2. * fragCoord.xy / iResolution.xy - 1.;\nvec2 uvs = uv2 * iResolution.xy / max(iResolution.x, iResolution.y);\n\nfloat time2 = iTime*0.7;       \nfloat speed = speed2;      \nspeed = 0.1;\n\n    float formuparam = formuparam2;\n    \n//get coords and direction\n\nvec2 uv = uvs;\n       \n//mouse rotation\nfloat a_xz = 0.9;\nfloat a_yz = -.6;\nfloat a_xy = 0.9 + iTime*0.04;\n\nmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\nmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\nmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\nfloat v2 =1.0;\nvec3 dir=vec3(uv*zoom,1.);\nvec3 from=vec3(0.0, 0.0,0.0);\nvec3 forward = vec3(0.,0.,1.);\n\nfrom.x += transverseSpeed*(1.0)*cos(0.01*iTime) + 0.001*iTime;\nfrom.y += transverseSpeed*(1.0)*sin(0.01*iTime) +0.001*iTime;\n\nfrom.z += 0.003*iTime;\n\ndir.xy*=rot_xy;\nforward.xy *= rot_xy;\n\ndir.xz*=rot_xz;\nforward.xz *= rot_xz;\n\ndir.yz*= rot_yz;\nforward.yz *= rot_yz;\n\nfrom.xy*=-rot_xy;\nfrom.xz*=rot_xz;\nfrom.yz*= rot_yz;\n \n//zoom\nfloat zooom = (time2-3311.)*speed;\nfrom += forward* zooom;\nfloat sampleShift = mod( zooom, stepsize );\n \nfloat zoffset = -sampleShift;\nsampleShift /= stepsize; // make from 0 to 1\n\n//volumetric rendering\nfloat s=0.24;\nfloat s3 = s + stepsize/2.0;\nvec3 v=vec3(0.);\nfloat t3 = 0.0;\n\n\nvec3 backCol2 = vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\nvec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset);\n\np2 = abs(vec3(tile)-mod(p2,vec3(tile*3.5))); // tiling fold\np3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n\n#ifdef cloud\nt3 = field(p3);\n#endif\n\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\nfloat D = abs(length(p2)-pa); // absolute sum of average change\n\nif (i > 2)\n{\na += i > 7 ? min( 12., D) : D;\n}\npa=length(p2);\n}\n\n\na*=a*a; // add contrast\n// brightens stuff up a bit\nfloat s1 = s+zoffset;\n// need closed form expression for this, now that we shift samples\nfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\nv+=fade;\n\n// fade out samples as they approach the camera\nif( r == 0 )\nfade *= (1. - (sampleShift));\n// fade in samples as they approach from the distance\nif( r == volsteps-1 )\nfade *= sampleShift;\nv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\nbackCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;\n\n\ns+=stepsize;\ns3 += stepsize;\n\n}\n       \nv=mix(vec3(length(v)),v,saturation); //color adjust\n \nvec4 forCol2 = vec4(v*.01,1.);\n\n#ifdef cloud\nbackCol2 *= cloud;\n#endif\n\nbackCol2.b *= 0.01;\nbackCol2.r *= 0.01;\nbackCol2.b = 0.5*mix(backCol2.b, backCol2.g, 1.2);\nbackCol2.g = 0.01;\nbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(iTime*0.01) + 1.0));\n  \n/*****************************************************************************************************************/\n\n  \n    if (SurfacePosition.z > 0.0) { \n        SurfDX = getSurfacePosition(vec2(fragCoord.x + 1.0, fragCoord.y));\n        SurfDY = getSurfacePosition(vec2(fragCoord.x, fragCoord.y+1.0));\n        SurfDX.z *= 1.0;\n        SurfDY.z *= 1.0;\n        SurfaceNormal = normalize(cross(SurfDX - SurfacePosition, SurfDY - SurfacePosition));\n        } else {\n            SurfaceNormal = vec3(0.0,0.0,0.25);\n        }\n        \n        /***********************************************************/\n        \n        LightColor = vec3(.0,.0,.0);\n        \n        LightPosition[0] = vec3(iResolution.xy, Sphere_radius*3.0);\n        LightPosition[1] = vec3(screen_center.x + cos(iTime*0.92) * mov_radius,\n            screen_center.y - cos(iTime*1.011)* mov_radius,\n            Sphere_radius* 8.0 * cos(iTime*1.013));\n        LightPosition[2] = vec3(screen_center.x + sin(iTime*1.019) * mov_radius,\n            screen_center.y - sin(iTime*1.209) * mov_radius,\n            Sphere_radius* 4.0 * (1.0 + cos(iTime*1.007)));\n        \n        for (int i=0; i<3; i++) {\n            LightDirection = normalize(LightPosition[i] - SurfacePosition);\n            \n            /***********************************************************/\n            /* Diffuse Light                                           */\n            /***********************************************************/\n            \n            DiffuseLightIntensity = clamp(dot(LightDirection, SurfaceNormal),.0,1.0);\n            \n            /***********************************************************/\n            /* Specular Light                                          */\n            /***********************************************************/\n            \n            SpecularDirection = LightDirection - 2.0 * SurfaceNormal * dot(LightDirection, SurfaceNormal);\n            \n            SpecularLightIntensity = clamp(dot(ViewDirection, SpecularDirection),.0,1.0);\n            \n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n            SpecularLightIntensity *= SpecularLightIntensity*SpecularLightIntensity;\n\n            LightColor += DiffuseLightColor[i] * DiffuseLightIntensity +\n            SpecularLightColor[i] * SpecularLightIntensity;\n            \n            AmbientLightIntensity += clamp(DiffuseLightIntensity,.0,.5);\n        }\n        \n        \n        /***********************************************************/\n        /* Ambient Light                                           */\n        /***********************************************************/\n\n        AmbientLightIntensity = 1.0 - AmbientLightIntensity;\n        \n        \n        /***********************************************************/\n        /* Lighting Finalizing                                     */\n        /***********************************************************/\n        \n        LightColor += AmbientLightIntensity*AmbientLightColor;\n        \n/*************************************************************************************************/\n        if (SurfacePosition.z > 0.0) {\n    fragColor =forCol2+ vec4(LightColor*backCol2,1.0);\n        } else fragColor = vec4(0.0,0.0,0.0,0.0);\n        /*} else {\n            SurfaceNormal = vec3(0.0,0.0,0.0);\n    fragColor = vec4(SurfaceNormal,0.0);\n        }*/\n    }","name":"Image","description":"","type":"image"}]}