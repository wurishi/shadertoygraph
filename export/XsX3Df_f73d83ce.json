{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//inspired by http://lodev.org/cgtutor/randomnoise.html and lots of stuff from\n//other shadertoy people\n\n#define M_PI 3.1415926535897932384626433832795\n#define STAR_INTENSITY 1.5\n#define PLANET_AMBIENT 0.2\n#define DOT_INTENSITY 0.1\n#define CLOUD_DISTANCE vec2(0.05,0.05) //cloud distance\n#define CLOUD_SHADOW_INTENSITY 0.3\n#define ATHMOSPHERE_DIFFUSION 1. //Higher > less diffusion\n\n\n\n#define SPECULAR_INTENSITY 0.6\n#define SPECULAR_SHININESS 5.\n\n\n#define EXTERNAL_HALO_GLOW .95 //between 1 and 0\n#define SCALE 1.4\n\n\n#define RAY_PRECISION 0.0001\nconst vec3 planetColor = vec3(0.4,0.1,0.1);\nconst vec3 starColor = vec3(1.,0.5,0.5);\n\n#define USE_PROCEDURAL\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( noiseTexture, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nvec4 projectionOnSphere(vec2 screenPos){\n\n    vec3 rayOrigin = vec3( 0.0, 0.0, 2.5 );\n    vec3 rayDir = normalize( vec3( screenPos, -2.0 ) );\n\n    // intersect sphere\n    float b = dot(rayOrigin,rayDir);\n    float c = dot(rayOrigin,rayOrigin) - 1.0;\n    float h = b*b - c;\n\n    float t = -b - sqrt(h);\n    vec3 pos = rayOrigin + t*rayDir;\n\t//if(length(pos) > SCALE)\n\t//{\n\t\treturn vec4(-pos, length(pos));\t\n\t//}\n    //return vec4(pos, length(pos));\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat smoothNoise(vec3 q){\n\tfloat f = 0.5000*noise( q ); q = q*2.01;\n    f += 0.2500*noise( q ); q = q*2.02;\n    f += 0.1250*noise( q ); q = q*2.03;\n    f += 0.0625*noise( q ); q = q*2.01;\n\treturn f;\n}\n\n#define NB_LUT 4\n\nvec4 mapping(float dist, float min, float max, mat4 LUT, vec4 LUT_DIST){\t\n\t\n\tfloat distLut = (dist - min) / max;\n\tint i1;\n\tfor(int i=0;i <NB_LUT;++i){\n\t\tif(distLut < LUT_DIST[i+1]){i1 = i;break;}\n\t}\n\tvec4 col1,col2;\n\tfloat mixVal;\n\tif\t\t(i1 == 0){\n\t\tcol1 = LUT[0];col2 = LUT[1];\n\t\tmixVal = (distLut - LUT_DIST[0]) / (LUT_DIST[1] - LUT_DIST[0]);\n\t}else if(i1 == 1){\n\t\tcol1 = LUT[1];col2 = LUT[2];\n\t\tmixVal = (distLut - LUT_DIST[1]) / (LUT_DIST[2] - LUT_DIST[1]);\n\t}else{\n\t\tcol1 = LUT[2];col2 = LUT[3];\n\t\tmixVal = (distLut - LUT_DIST[2]) / (LUT_DIST[3] - LUT_DIST[2]);\n\t}\n\t\n\t\n\t//return vec4(mixVal);\n\treturn mix(col1,col2,mixVal);\n\t\n}\n\nmat4 LAVA_COLOR  = mat4( 0.  ,0.  ,0. ,0.,\n\t\t\t\t  0.6,0.1,0.1 ,1.,\n\t\t\t\t  0.9 , 0.6  ,0.3,1.,\n\t\t\t\t  1.  ,0.9  ,0.5 ,1.);\nvec4 LAVA_COLOR_DIST = vec4(0.,0.4,0.9,1.);\nvec4 getLava(vec3 position, float dotNL ) {\n\t\n    vec3 q = position;\n    \n\t#define LAVA_DENSITY 3.\n    q *= LAVA_DENSITY;\n    float f  = smoothNoise(q);\n\t#define LAVA_COMPLEXITY 15.\n\t\n\t\n\t//x,y,z period and height, width depth for noise\n\tfloat xp = 2., nh = 10., yp = 1., nw = 1., zp = 2., nd = 1.;\n\tfloat xyzVal = position.x * xp/nh +position.y*yp/nh+position.z;\n\tfloat lava = sin( xyzVal + f * LAVA_COMPLEXITY );\n\t#define LAVA_NOISE 50.\n\t//lava += 0.5 * f;\n\t\n\tvec4 lavaColorDist = LAVA_COLOR_DIST;\n\tlavaColorDist[2] -= f*0.5;\n\t\n\t\n\t//Color mapping\n\tvec4 color = mapping(1. - sqrt(lava), 0.,1.,LAVA_COLOR, lavaColorDist);\n\t\n\t//light on visible lava even in dark side\n\tcolor += clamp( -dotNL, 0.,1.) * vec4(color.x*color.x*color.x,color.y*color.y*color.y, color.z*color.z*color.z,1.);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//UNIFORMS\n\tfloat ct = cos(iTime *0.1 - 2.*iMouse.x/iResolution.x);\n\tfloat st = sin(iTime *0.1 - 2.*iMouse.x/iResolution.x);\t\t\n\n\t\t\n\tmat4 cameraRotation = mat4(ct,0.,st,0.,\n\t\t\t\t\t\t\t   0.,1.,0.,0.,\n\t\t\t\t\t\t\t  -st,0.,ct,0.,\n\t\t\t\t\t\t\t   0.,0.,0.,1.);\n\t//START\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n\tuv.x = ratio*(uv.x - 0.25) ;\n\tuv = uv * 2. * SCALE - 1.*SCALE ;\n\t//uv with modified texture coordinates\n\n\tvec4 pos3d  = projectionOnSphere(uv) * cameraRotation;\n\tvec3 pos = pos3d.xyz;\n\tvec3 N = normalize(pos3d.xyz);\n\t\n\tvec3 L = vec3(1.,0.,0.);\n\tvec3 viewvec = vec3(0.,0.,1.);\n\t//vec3 viewvec = vec3(vec4(0.,0.,1.,1.) * cameraRotation);\n\t\n\t\n\tvec2 sphereCoord = vec2(0.5+ atan(pos.z, pos.x) / 2. / M_PI, 0.5 - asin(pos.y)/M_PI );\n\t\n\n\tfloat dotStar = dot(N, L);\n\tfloat planetLight = pow( dotStar*0.5+0.5 , ATHMOSPHERE_DIFFUSION);\n\tfloat lightAttenuation =  clamp(STAR_INTENSITY * planetLight, PLANET_AMBIENT, 1.);// * (MAX_DIST-distanceStar)/MAX_DIST;\n\t\n\tfloat dotSpecular = dot( normalize(L - 2. * dotStar * N), viewvec);\n\tfloat specular = SPECULAR_INTENSITY * max(pow(dotSpecular, SPECULAR_SHININESS), 0.);\n\tvec3 specularColor = specular * normalize(mix(vec3(1.0), starColor, 0.5));\n\t\n\t#define LAVA\n\t#ifdef\tLAVA\n\tvec4 ground = getLava(pos, dotStar);\n\t\n\t//pseudo raycast\t\n\t#endif\n\t\n\t\n\tvec3 color = ground.xyz + specularColor;\n\t\n\t\n\tvec4 finalColor = vec4(color * lightAttenuation , 1.0);\n\t\n\tfloat dcenter = dot(uv,uv); //from 0 to 4\n\tvec3 compCol = normalize(planetColor);//couleur complÃ©mentaire\n\t\n\t//athmosphere spec => light when sun on the side\n\tfloat athmospereSpec = specular * dot(viewvec,L);\n\t\n\tfloat haloGradient = (2. - pos3d.w);\n\tif ( pos3d.w < 1. + RAY_PRECISION) {\n\t\tfloat mixVal = clamp(pow( dcenter, 5.) * 2.5 ,0.,1.) - clamp( -dot(L,viewvec), 0., 1.) * 0.3;\n\t\tfinalColor = mix( finalColor, vec4(compCol * lightAttenuation * lightAttenuation,1.) , max(0.05, mixVal) )  ;\n\t\t\n\t}else if(pos3d.w < 2.){\n\t\t\t\n\t\t\tvec3 haloColor = (compCol + athmospereSpec*0.5);\n\t\t\tfloat haloVal = pow(  haloGradient * EXTERNAL_HALO_GLOW , 8.) * lightAttenuation * lightAttenuation + athmospereSpec - clamp( -dot(L,viewvec), 0., 1.) * 0.2;\n\t\t\t\t\t\t  \n\t\t\tfinalColor = vec4(haloColor * haloVal, 1. ) ;\n\t\t\t//finalColor += planetWind * haloGradient;\n\t\t\t\n\t}else\n\t{\n\t\tfinalColor = vec4(0.,0.,0.,1.);//starField;\n\t\t\n\t}\n\t\n\tmat4 LAVA_HALO_COLOR  = mat4( 0.  ,0.  ,0. ,0.,\n\t\t\t\t  0.3,0.1,0.1 ,1.,\n\t\t\t\t  0.9 , 0.6  ,0.3,1.,\n\t\t\t\t  1.  ,0.9  ,0.5 ,1.);\n\tvec4 LAVA_HALO_DIST = vec4(0.,0.5,0.7,1.);\n\t#define haloWidth .9\n\t#define innerHaloWidth 0.6\n\tif(dcenter < haloWidth && dcenter > innerHaloWidth){\n\t\tfloat angleHaloX = dot(normalize(uv),vec2(0.,1.));\n\t\tfloat angleHaloY = dot(normalize(uv),vec2(1.,0.));\n\t\tvec4 posHalo = vec4(angleHaloX,angleHaloY,iTime * .02,1.);\n\t\tfloat lavaHaloVal = smoothNoise(posHalo.xyz*20.) ;\n\t\t\n\t\tfloat haloAtt = 0.5 - abs((dcenter - innerHaloWidth)/(haloWidth - innerHaloWidth) - 0.5);\n\t\tfinalColor +=  mapping(lavaHaloVal*lavaHaloVal, 0., 1., LAVA_HALO_COLOR, LAVA_HALO_DIST) * haloAtt * lightAttenuation * 2.;  \n\t} \n\t\n\t\n\t\n\tfragColor = finalColor;\n\t\n\t\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsX3Df","date":"1380319785","viewed":482,"name":"Lava in space","username":"baccanno","description":"For a project trying to do cheap and good looking lava. I wanted to make light coming out of the lava rivers and bump mapping but I took a more simple solution. Hope you like it !\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","light","star","lava"],"hasliked":0,"parentid":"","parentname":""}}