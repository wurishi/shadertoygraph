{"ver":"0.1","info":{"id":"wt3yRr","date":"1608331848","viewed":173,"name":"Random Complex Polar Grid","username":"jllusty","description":"Plots a uniform grid with random colors transformed by a complex function.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["grid","random","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 4.*atan(1.);\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rand(vec2 n) { \n\tfloat a = fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    float b = fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    return vec2(a,b);\n}\n\nfloat rand1(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 mond(vec2 n) {\n    float theta = rand1(atan(n.y, n.x));\n    vec3 c1 = vec3(250., 201., 1.)/255.;\n    vec3 c2 = vec3(1.);\n    vec3 c3 = vec3(34., 80., 149.)/255.;\n    vec3 c4 = vec3(1.);\n    vec3 c5 = vec3(221., 1., 0.)/255.;\n    float c = theta;\n    if(c < 1./5.) { return c1; }\n    if(c < 2./5.) { return c2; }\n    if(c < 3./5.) { return c3; }\n    if(c < 4./5.) { return c4; }\n    return c5;\n}\n\nvec2 mult(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 func(in vec2 z) {\n    return mult(z - vec2(2.0*(1.0 + 0.5*sin(iTime/3.)), 0.0)*rotate(iTime/4.), z + vec2(2.0f*(1.0 + 0.5*sin(iTime/3.)), 0.0)*rotate(iTime/4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  5.* ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 pos = uv;\n    \n    uv = func(uv);\n\n    float r = length(uv)/4.;\n    \n    if (int(floor(r)) % 2 == 0) {\n        float freq = 1.5*rand(vec2(floor(r),1)).y;\n        uv *= rotate(freq*iTime);\n    }\n    else {\n        float freq = 2.*rand(vec2(floor(r),-1)).y;\n        uv *= rotate(-freq*iTime);\n    }\n    \n    float theta = atan(uv.y,uv.x)+pi;\n\n    float n = 7.;    \n    float eps = 5./iResolution.x;\n    float gEps = 0.01;\n    float stretch = length(func(pos+vec2(gEps,0.))-func(pos))/gEps;\n    float dt = abs(mod(theta+pi/n,2.*pi/n)-pi/n)/stretch;\n    float ct = smoothstep(2.*eps,eps,dt*r);\n    if (r < 1.)  { dt = dt/r; }\n    \n    //lr = ceil(log2(r+1.))-log2(r+1.)/(ceil(log2(r+1.))-floor(log2(r+1.)));\n    float dr = abs(fract(r+.5)-.5)/stretch;\n    float cr = smoothstep(2.*eps,eps,dr);\n    float cc = max(ct,cr);\n    \n    vec2 dc = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    \n    //vec2 rv = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    //vec3 pal = mond(rv);\n    \n    float val = dot(dc, vec2(1));\n    // IQ's versatile cosine palette.\n    vec3 col = .5 + .47*cos(6.2831*val + vec3(0, 1, 2));\n    col = mix(col, vec3(0), cc);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n    //vec3 col = mix(pal,vec3(0.),cc);\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}