{"ver":"0.1","info":{"id":"lsKyW1","date":"1521897355","viewed":108,"name":"Wheels_2_Anvoker","username":"Anvoker","description":"Tiling rotating wheels. Improved thanks to FabriceNeyret2 <3\n\nTook to figure out how to draw hard edges instead of smoothstep. Still don't fully understand everything FabriceNeyret2 presented, but I'm getting there. Commenting everything for my own sake.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner","circle","wheel","rotating","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Setup=========\nconst int n = 8;\nconst float rotSpeed = 0.5;\nconst float circleBorder = 0.75;\nconst float lineBorder = 0.025 / float(n);\nconst vec3 backCol = vec3(0.1, 0.1, 0.1);\nconst vec3 lineCol = vec3(0.0, 0.75, 0.0);\nconst vec3 circCol = vec3(0.75, 0.0, 1.0);\n//==============\n\nconst float nf = float(n);\nconst float r = 1.0 / float(n * 2);\nconst float rSqr = r * r;\nconst float rSqr2 = rSqr * circleBorder;\n\n#define M_PI 3.141593\n\nvec3 drawCircles(vec2 uv)\n{\n    // Tiles and shifts the coordinate system\n    uv = (fract(uv * nf) - 0.5) / nf;\n    \n    float t  = iTime,\n    // Outer Radius\n      rtime  = abs(cos(t * rotSpeed)) * rSqr,\n        \n    // Inner Radius\n      rtime2 = abs(cos(t * rotSpeed)) * rSqr2,\n        \n    // Short for uv.x * uv.x + uv.y * uv.y\n      circle = dot(uv,uv);\n    \n    // Rotates the coordinate system so the lines rotate\n    uv *= mat2(cos(t),-sin(t),sin(t),cos(t));\n\n    // First step gives 1.0 for every coord outside of the \n    // circle minus border thickness\n    \n    // Second step gives 1.0 for every coord inside the circle\n    \n    // Multiplied together they give 1.0 only for coords\n    // on the border of the circle\n#define CircleStep(v) step(rtime2, abs(v)) * step(abs(v), rtime) \n    \n    // I don't fully understand why this works\n#define LineStep(v) step(abs(v), lineBorder)\n    \n    float lines = LineStep(uv.x)\n        \t    + LineStep(uv.y)\n                + LineStep((uv.x+uv.y)*.707)\n                + LineStep((uv.x-uv.y)*.707);\n    \n    // Clamping prevents lines from drawing over each other\n    lines = clamp(lines, 0.0, 1.0);\n    \n    // Returns 1.0 only if the current coord is inside radius\n#define isInsideCircle(r) step(0.0, r - circle)\n\n    return backCol\n         + circCol * CircleStep(circle)\n         + lineCol * isInsideCircle(rtime2)\n                   * lines;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.x;\n    \n    vec3 col = drawCircles(uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}