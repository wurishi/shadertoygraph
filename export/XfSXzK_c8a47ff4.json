{"ver":"0.1","info":{"id":"XfSXzK","date":"1706531759","viewed":100,"name":"Gaussian Vogel Golden Spiral","username":"chronos","description":"Vogel golden spiral with brightness scaled by a normal distribution, like a blur kernel, and sample areas scaled to fit total area.\nThis version modifies the forked shader by introducing non-isotropic 'kernel' shape as well as 'sample-regions' themselves.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["spiral","bokeh","angle","gaussian","discs","kernel","fibonacci","sunflower","vogel","phyllotaxis","spread","golden","layout","ratio","method"],"hasliked":0,"parentid":"4fBXRG","parentname":"Vogel's Method"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    /////////////////////////////////////////////////\n    Gaussian Vogel Golden Spiral by chronos\n    /////////////////////////////////////////////////\n    \n    \n    Vogel golden spiral with brightness scaled by a normal distribution, like a blur kernel, and sample areas scaled to fit total area.\n    This version modifies the forked shader by introducing non-isotropic 'kernel' shape as well as 'sample-regions' themselves.\n    Can also switch between oval/disc sample regions, and gaussian ones.\n    Finally, added optional colors for visualization.\n    \n    \n\n    // Forked shader description:\n    -----------------------------------------------------------\n    based on\n    http://blog.marmakoide.org/?p=1\n    found via\n    https://www.shadertoy.com/view/4d2Xzw by Dave_Hoskins\n    \n*/\n\nconst float PI     = 3.14159265;\nconst float TWO_PI = 6.283185307; // aka Tau\nconst float PHI = (1. + sqrt(5.))/2.; // Golden ratio\n\nconst float golden_angle = TWO_PI * (1. - 1./PHI);\n//const float golden_angle = PI * (3. - sqrt(5.));\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\n// Disable to use circular shapes\n#define USE_NONISOTROPIC_SAMPLES 1\n\n// Disable to draw discs / ovals\n#define DRAW_GAUSSIANS 1\n\n#define USE_COLOR 1\n\n#define NUM_COLORS 3\n\nfloat normal_distribution(float r)\n{\n    r *= PI;\n    return exp(-(r*r)/2.)/sqrt(2. * PI);\n}\n\nfloat normal_distribution2(float t) // t = r * r\n{\n    t *= PI * PI;\n    return exp(-t/2.)/sqrt(2. * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if (length(iMouse.xy) < 10.) mouse.xy = vec2(cos(iTime), sin(iTime)) + 0.1;\n\n    float ps = 2./ iResolution.y;\n\n    vec3 color = vec3(0);\n\n    \n    float num_samples = 150. * (mouse.y + 1.);\n    float rcp_num_samples = 1./num_samples;\n    \n    \n    // Find target disc area.\n    // Regardless of derivation the area should scale with the reciprocal sqare root of the number of samples.\n    // You can see the derivation in the forked shader: https://www.shadertoy.com/view/4fBXRG\n    // The principle is the same in all cases.\n    #if 1\n    float disc_radius = sqrt(2. / (num_samples * PI));\n    #elif 0\n    float disc_radius = 1. / (sqrt(num_samples) - 1.);\n    #else\n    float disc_radius = sqrt(1. / num_samples);\n    #endif\n    \n    float angle = iTime * .3;\n    vec2 scale = vec2(1,.5);\n    \n    vec2 cs = vec2(cos(angle), sin(angle));\n    mat2 S = mat2(scale.x, 0, 0, scale.y);\n    mat2 R = mat2(cs.x, cs.y, -cs.y, cs.x);\n    \n    mat2 RS = R * S;\n    \n    #if !USE_NONISOTROPIC_SAMPLES\n    disc_radius *= sqrt(determinant(S));\n    #endif\n    \n    //mat2 Cov = RS * transpose(RS);\n    \n    for(float i = .5; i < num_samples; i++) // Samples half-integers between 0 and num_samples\n    {\n        float t = i * rcp_num_samples;\n        \n        float r = sqrt(t);\n        float th = golden_angle * i;\n        \n        vec2 pos = r * vec2(cos(th), sin(th));\n        \n        #if USE_NONISOTROPIC_SAMPLES\n        float d = length( R * (pos - inverse(RS)*uv));\n        #else\n        pos = RS * pos;\n        float d = length( pos - uv);\n        #endif\n        \n        #if DRAW_GAUSSIANS\n        float gaussian_std = 1.; // try e.g  .75;  .5; or 2.;\n        float alpha = exp(-pow(d / (disc_radius * gaussian_std), 2.));\n        #else\n        float alpha = smoothstep(ps, -ps, d-disc_radius);\n        #endif\n        \n        \n        #if USE_COLOR\n        vec3 sample_color = (.5 + .5*cos( 2. * PI * (fract(i/float(NUM_COLORS))+vec3(0,.1,.2)) )) * 10.;\n        #else\n        vec3 sample_color = vec3(1);\n        #endif\n        \n        // These two methods are not equivalent in the case of overlap.\n        // Both are order-dependent.\n        #if 1\n        color = mix(color, sample_color, alpha * normal_distribution2(t));\n        #else\n        color = mix(color, sample_color * normal_distribution2(t), alpha);\n        #endif\n    }\n\n    #if USE_COLOR\n    color = tanh(color);\n    #endif\n\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}