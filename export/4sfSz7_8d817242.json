{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define DETECT_BLINK 1.5\n#define DETECT_BORDER 4.0\n#define DETECT_CROSS 8.0\n#define DETECT_SEQUENCE 10.0\n\n\n// hash function\nfloat hash(int n) {\n    return fract(sin(float(n))*43758.5453);\n}\n\n// round box distance function\nfloat roundBox(vec2 p, vec2 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n// square signal\nfloat signal(float value) {\n\tvalue -= floor(value);\n\tif (value < 0.5) return 0.0;\n\treturn 1.0;\n}\n\n// pixel coordinate to screen content\nvec3 getPixel(vec2 p) {\n\t\n\t// stretch to get the real ratio\n\tp.y *= iResolution.y / iResolution.x;\n\t\n\t// small border around the whole screen\n\tfloat border = roundBox(p, vec2(0.92, 0.42), 0.0);\n\tif (border > 0.02) return vec3(0.0);\n\tif (border > 0.01) return vec3(1.0);\n\tif (border > 0.00) return vec3(0.0);\n\t\n\t// change the scale\n\tp *= 0.425;\n\t\n\t// translation with time\n\tvec2 trans = vec2(iTime)*vec2(0.0331,0.0051);\n\t\n\t// now do some stuff detection\n\tint detectID = int(iTime / DETECT_SEQUENCE);\n\tfloat detectTime = mod(iTime, DETECT_SEQUENCE);\n\tvec2 center = vec2(hash(detectID), hash(detectID*1500))*2.0-1.0;\n\tcenter.x *= .3; center.y *= .1;\n\tcenter -= vec2(mod(trans.x, 0.8)-.4, mod(trans.y,.4)-.2);\n\t\n\tif (detectTime < DETECT_BLINK) {\n\t\tif (signal(detectTime*5.0) < 0.5) {\n\t\t\tfloat detectBorder = roundBox(p-center, vec2(0.001, 0.001), 0.0);\n\t\t\tif (detectBorder < 0.005) {\n\t\t\t\treturn vec3(1.0);\n\t\t\t}\n\t\t}\n\t} else if (detectTime < DETECT_BORDER) {\n\t\tdetectTime = min(detectTime, DETECT_BORDER);\n\t\tfloat size = (detectTime-DETECT_BLINK)/(DETECT_BORDER-DETECT_BLINK)*0.02;\n\t\tfloat detectBorder = abs(roundBox(p-center, vec2(size, size), 0.01));\n\t\tif (detectBorder < 0.002) {\n\t\t\treturn vec3(1.0);\n\t\t}\n\t} else if (detectTime < DETECT_CROSS) {\n\t\tfloat detectBorder = roundBox(p-center, vec2(0.02, 0.02), 0.01);\n\t\tif (detectBorder > 0.002) {\n\t\t\tdetectBorder = roundBox(p-center, vec2(100.0, 0.002), 0.0);\n\t\t\tif (detectBorder < 0.0001) return vec3(1.0);\n\t\t\tdetectBorder = roundBox(p-center, vec2(0.002, 100.0), 0.0);\n\t\t\tif (detectBorder < 0.0001) return vec3(1.0);\n\t\t}\n\t\tdetectBorder = abs(roundBox(p-center, vec2(0.02, 0.02), 0.01));\n\t\tif (detectBorder < 0.002) {\n\t\t\treturn vec3(1.0);\n\t\t}\n\t}\n\t\n\t// translate the background\n\tp += trans;\n\t// what the fuck am i doing\n    vec3 uv = vec3(texture(iChannel1, p));\n\tuv.x *= cos(uv.y+iTime)*.35124;\n\tuv.y /= cos(uv.x*sqrt(uv.y))*.23312/abs(uv.y);\n    vec3 co = vec3(texture(iChannel1, uv.xy));\n    return co*.8;\n}\n\n// pixel coordinate to screen value, with scanline and glitches etc\nvec3 getScreen(vec2 p) {\n\t\n\t// fade to black on outside\n\tfloat boundValue = roundBox(p, vec2(0.72, 0.6), 0.1)*5.0;\n\tboundValue = 1.0 - clamp(boundValue, 0.0, 1.0);\n\t\n\t// screen scanline\n\tfloat scanline = sin(p.y*3.1415*110.0)*.5+.5;\n\tscanline = sqrt(scanline);\n\t\n\t// glitch the point around\n\tfloat glitch = sin(18.245*iTime)*cos(11.323*iTime)*sin(4.313*iTime);\n\tglitch *= glitch;\n\tp.x += sin(p.y*19.1)*glitch*.01;\n\tp.x += sin(p.y*459.1)*glitch*glitch*.02;\n\t\n\t// get the screen content\n\tvec3 color = getPixel(p);\n\t\n\t// and blend everything together\n\tfloat factor = scanline*boundValue;\n\treturn color*factor*.6+vec3(0, factor*color.g*.8, 0);\n}\n\n// pixel coordinate to physical screen value\nvec3 getScreenBorder(vec2 p) {\n\t// outer border\n\tfloat boundOut = roundBox(p, vec2(1.15, 1.15), 0.0)*8.0;\n\tboundOut = clamp(boundOut, 0.5, 1.0);\n\t\n\t// inner border\n\tvec3 cin = vec3(texture(iChannel0, p*.88));\n\tcin = vec3(cin.r*.02, cin.g*.18, cin.b*.03);\n\t\n\t// add light to simulate screen normal\n\tfloat light = sin((atan(p.x, p.y)+0.2)*2.0);\n\tcin += light*.10+0.13;\n\tfloat boundIn = roundBox(p, vec2(0.99, 0.9), 0.05)*150.0;\n\tboundIn = clamp(boundIn, 0.0, 1.0);\n\t\n\t// add a slight green haze\n\tfloat hazeV = roundBox(p, vec2(0.83, 0.73), 0.03)*3.5;\n\thazeV = 1.0 - clamp(hazeV, 0.8, 1.0);\n\thazeV += (sin(iTime*2.3) + sin(iTime*20.912) * .4)*.06;\n\tvec3 haze = vec3(0.0, hazeV*.14, 0.0);\n\t\n\t// return values\n\treturn mix(cin*boundIn, vec3(0), boundOut) + haze;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\t// move the point away from the center\n\tvec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tp += p*dot(p, p)*0.22;\n\t\n\t// add a small led\n\tvec2 delta = vec2(0.97, 0.04) - (fragCoord.xy / iResolution.xy);\n\tdelta.y *= iResolution.y / iResolution.x;\n\tfloat ledv = clamp(1.5 - length(delta)*150.0, 0.0, 1.0);\n\tledv *= sin(2.0*iTime)*.5+.5;\n\tvec3 led = vec3(ledv*.4, ledv, ledv*.4);\n\t\n\tfragColor = vec4(getScreenBorder(p)+getScreen(p)+led, 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfSz7","date":"1398144775","viewed":3195,"name":"Old-School Terminal","username":"Klems","description":"I tried to emulate the look of an old computer screen. Kinda like a satellite scanning an alien planet, or something like that.","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["2d","retro","crt","analog"],"hasliked":0,"parentid":"","parentname":""}}