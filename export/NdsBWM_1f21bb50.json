{"ver":"0.1","info":{"id":"NdsBWM","date":"1644960253","viewed":259,"name":"Snow Terrain and Clouds","username":"Famousghost","description":"1. My first raymarching shader using perlin noise with fbm\n2. If something is wrong tell me please ( assuming whole shader isn't so bad ;) )\n3. If you have some tips for me you can leave in comments below\n\nEnjoy view.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fbmnoiseraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.001\n#define MAX_DIST 50.0\n\nstruct Object\n{\n    int id;\n    float d;\n};\n\nObject sdPlane(in int id, in vec3 p, in vec3 normal, in float h, in float value)\n{\n    return Object(id, dot(p, normal) + h + value);\n}\n\nObject minValue(Object a, Object b)\n{\n    if(a.d < b.d)\n    {\n        return a;\n    }\n    return b;\n}\n\nObject sdScene(in vec3 p)\n{\n    float val1 = fbm(p.xz * 0.8f);\n    float val2 = fbm(vec3(p.xz + iTime * 0.08f, p.z + iTime * 0.2f));\n      return minValue(sdPlane(1, p, vec3(0.0f, 1.0f, 0.0f), 1.0f, val1), sdPlane(2, p, vec3(0.0f, -1.0f, 0.0f), 1.0f, val2));\n}\n\nObject rayMarching(in vec3 ro, in vec3 rd)\n{\n    Object buf;\n    buf.d = 0.0f;\n    buf.id = 0;\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ro + rd * buf.d;\n        Object tmp = sdScene(p);\n        buf.d += tmp.d;\n        buf.id = tmp.id;\n        if(tmp.d >= MAX_DIST || tmp.d <= MIN_DIST)\n            break;\n    }\n    return buf;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    float e = 0.005f;\n    return normalize(vec3(sdScene(vec3(p.x - e, p.y, p.z)).d - sdScene(vec3(p.x + e, p.y, p.z)).d,\n                          sdScene(vec3(p.x, p.y - e, p.z)).d - sdScene(vec3(p.x, p.y + e, p.z)).d,\n                          sdScene(vec3(p.x, p.y, p.z - e)).d - sdScene(vec3(p.x, p.y, p.z + e)).d));\n                     \n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal)\n{\n    float occ = 0.0f;\n    float weight = 1.0f;\n    for(int i =0 ; i < 8; ++i)\n    {\n        float len = 0.01f + 0.005f * float(i * i);\n        float dist = sdScene(p + normal * len).d;\n        occ += (len - dist) * weight;\n        weight *= 0.85f;\n    }\n    return 1.0f - clamp(0.6f * occ, 0.0f, 1.0f);\n}\n\nfloat clamp01(float a)\n{\n    return clamp(a, 0.0f, 1.0f);\n}\n\nfloat diffuse(vec3 lightDir, vec3 p, vec3 normal)\n{\n    float diff = clamp01(dot(lightDir, normal));\n    vec3 dir = normalize(lightDir - p);\n    Object obj = rayMarching(p - 0.05f * normal, dir);\n\n    if(obj.d <= (MAX_DIST - length(p)) && obj.id != 2)\n    {\n        diff *= 0.3f;\n    }\n    \n    return diff;\n}\n\nfloat specular(vec3 lightPos, vec3 p, vec3 rd, vec3 normal, float specularStrength)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    return pow(clamp01(dot(reflect(-lightDir, normal), rd)), specularStrength);\n}\n\n#define A 0.5\n#define FALL_OF_DENSITY 0.2\n//https://iquilezles.org/articles/fog/\nvec3 applyFog(in vec3 color,\n              in float dist,\n              in vec3 ro,\n              in vec3 rd)\n{\n    float t = (A / FALL_OF_DENSITY) * exp(-FALL_OF_DENSITY * ro.y) * ((1.0f - exp(-FALL_OF_DENSITY * rd.y * dist)) / FALL_OF_DENSITY * rd.y);\n    vec3  fogColor  = vec3(0.4f);\n    return mix(color, fogColor, clamp(t, 0.0f, 1.0f));\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.0f, -0.9f, iTime * 0.1f);\n    vec3 rd = normalize(vec3(uv, 1.0f));\n    \n    Object obj = rayMarching(ro, rd);\n    \n    vec3 col = vec3(0.4f);\n    \n    vec3 lightDir = normalize(vec3(sin(iTime) * 100.0f, -1.0f, cos(iTime) * 100.0f));//vec3(-200.0f, 40.0f, 100.0f + iTime * 0.1f);\n    vec3 p = ro + rd * obj.d;\n    float val = 0.0f;\n    if(obj.d <= MAX_DIST)\n    {\n        \n        if(obj.id == 1)\n        {\n            vec3 normal = getNormal(p);\n\n            vec3 result = texture(iChannel0, p.xz * 10.0).rgb;\n\n            vec3 noise = texture(iChannel0, p.xz * 6.0).rgb;\n            \n            if(p.y > -1.55f * clamp(0.0, 1.0, noise.r * 2.5))\n            {\n                result = texture(iChannel1, p.xz).rrr * 3.0f;\n            }\n            \n            float occ = ambientOcclusion(p, normal);\n            \n\n            col = vec3((diffuse(lightDir, p, normal) + specular(lightDir, p, rd, normal, 8.0f))  *occ)* result;\n            \n            col = applyFog(col, obj.d, ro, rd);\n            \n        }\n        else if(obj.id == 2)\n        {\n            col = vec3(fbm(vec3(p.xz + iTime * 0.08f, p.z + iTime * 0.1f)));\n        }\n        vec3 pValue = vec3(p.xz * 0.08f, p.z + iTime * 0.1f) / 4.0f;\n        val = fbm(pValue+fbm(pValue+fbm(pValue)));\n        col = mix(vec3(0.4), col, exp(obj.d * obj.d * -0.02f) * val);\n    }\n\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OCTAVE 6\n\nfloat random(in vec3 p)\n{\n    return fract(sin(dot(p, vec3(18.3234f, 33.54323f, 19.5343f))) * 452231.34345f);\n}\n\nfloat random(in vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(18.3234f, 33.54323f))) * 452231.34345f);\n}\n\nfloat simplexNoise(in vec2 uv)\n{\n    vec2 ip = floor(uv);\n    vec2 fp = fract(uv);\n    \n    float x1 =  random(ip + vec2(0.0f, 0.0f));\n    float x2 =  random(ip + vec2(1.0f, 0.0f));\n    float x3 =  random(ip + vec2(0.0f, 1.0f));\n    float x4 =  random(ip + vec2(1.0f, 1.0f));\n    \n    vec2 u = fp * fp * (3.0f - 2.0f * fp);\n    \n    float a = mix(x1, x2, u.x);\n    float b = mix(x3, x4, u.x);\n    \n    return mix(a, b, u.y);\n    \n}\n\nfloat simpleNoise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float x1 =  random(ip + vec3(0.0f, 0.0f, 0.0f));\n    float x2 =  random(ip + vec3(1.0f, 0.0f, 0.0f));\n    float x3 =  random(ip + vec3(0.0f, 1.0f, 0.0f));\n    float x4 =  random(ip + vec3(1.0f, 1.0f, 0.0f));\n    \n    float x5 =  random(ip + vec3(0.0f, 0.0f, 1.0f));\n    float x6 =  random(ip + vec3(1.0f, 0.0f, 1.0f));\n    float x7 =  random(ip + vec3(0.0f, 1.0f, 1.0f));\n    float x8 =  random(ip + vec3(1.0f, 1.0f, 1.0f));\n    \n    vec3 u = fp * fp * (3.0f - 2.0f * fp);\n    \n    float x1x2 =   mix(x1, x2, u.x);\n    float x3x4 =   mix(x3, x4, u.x);\n    float x5x6 =   mix(x5, x6, u.x);\n    float x7x8 =   mix(x7, x8, u.x);\n    \n    float x1x2x3x4 = mix(x1x2, x3x4, u.y);\n    float x5x6x7x8 = mix(x5x6, x7x8, u.y);\n    \n    \n    return mix(x1x2x3x4, x5x6x7x8, u.z);\n}\n\nfloat fbm(in vec3 p)\n{\n    float result = 0.0f;\n    float amp = 0.5f;\n    const float gain = 0.5f;\n    const float lacunarity = 1.4f;\n    for(int i = 0; i < OCTAVE; ++i)\n    {\n        result += simpleNoise(p) * amp;\n        amp *= gain;\n        p.xyz += p.xyz * lacunarity;\n    }\n    return result;\n}\n\nfloat fbm(in vec2 uv)\n{\n    float result = 0.0f;\n    float amp = 0.5f;\n    const float gain = 0.4f;\n    const float lacunarity = 1.4f;\n    for(int i = 0; i < OCTAVE; ++i)\n    {\n        result += simplexNoise(uv) * amp;\n        amp *= gain;\n        uv += uv * lacunarity;\n    }\n    return result;\n}","name":"Common","description":"","type":"common"}]}