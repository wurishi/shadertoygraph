{"ver":"0.1","info":{"id":"XfdyRX","date":"1730955106","viewed":1258,"name":"The Chaos Factory","username":"cmgz","description":"The Chaos Factory\nI needed a small 2D physics engine for other shaders to I implemented this (Box2D-lite, https://github.com/erincatto/box2d-lite, MIT License)\nYou can add/push/pull boxes with the top-left selection!","likes":106,"published":3,"flags":32,"usePreview":1,"tags":["2d","collision","simulation","interactive","bounce","box","box","solver","physics","dynamic","rigidbody","factory","friction","impulse","box2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThe Chaos Factory\n\nGPU implementation of Erin Catto's Box2D-lite (https://github.com/erincatto/box2d-lite, MIT License)\n\nBroad phase and revolute joints\n\nNever got any stacking to work, even when accumulating impulses, even across multiple frames \nThat's why the demo is as little static as possible...\nYou can add/push/pull boxes with the top-left selection!\n\nSpecial thanks to the shadertoy community :\n- Dave_Hoskins for its hash functions\n- iq for its sdf functions (and many other resources)\n- FabriceNeyret2 and P_Malin for text rendering (and many other resources)\n- s23b for blueprint-like rendering (please check https://www.shadertoy.com/view/4tySDW)\n\n*/\n\n\n// Rendering\n\nfloat sdBox(vec2 p, vec2 b) // https://www.youtube.com/watch?v=62-pRVZuS5c\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) // https://www.shadertoy.com/view/3tdSDj\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    return length(pa-h*ba);\n}\n\nfloat sdTriangle(  in vec2 p, in float r ) // https://www.shadertoy.com/view/Xl2yDW\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p -= vec2(0.5,0.5*k)*max(p.x+k*p.y,0.0);\n    p.x =  p.x - clamp(p.x,-r,r);\n    p.y = -p.y - r*(1.0/k);\n    return length(p)*sign(p.y);\n}\n\n// modified version of sdSegment for a dotted segment\nfloat sdDotted(vec2 p, vec2 a, vec2 b, int sep) // sep is number of separation\n{\n    float n = 2.*float(sep)+1., dh = 1./n;\n    vec2 pa = p-a, ba = b-a;\n    \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float rh = fract(n*h/2.);\n    if(rh > .5001)\n    {\n        float closest_h = floor(n*h)*dh; \n        return min(length(pa-closest_h*ba), length(pa-(closest_h+dh)*ba));\n    }\n    return length(pa-h*ba);\n}\n\nfloat sdArrow(vec2 p, float l)\n{\n    return min(sdTriangle(p, .03), sdSegment(p, vec2(0, -l), vec2(0))-0.004);\n}\n\nfloat sdDottedArrow(vec2 p, float l, int sep)\n{\n    return min(sdTriangle(p, .03), sdDotted(p, vec2(0, -l), vec2(0), sep)-0.004);\n}\n\nfloat sdBody(vec2 p, Body b)\n{\n    return sdBox(rot(-b.ang)*(p-b.pos), b.size);\n}\n\nfloat sdJoint(vec2 p, Joint j, sampler2D buff)\n{\n    // load associated bodies\n    Body b0 = loadBody(buff, j.b0_id);\n    Body b1 = loadBody(buff, j.b1_id);\n\n    // Have the dotted line relative to the joint's softness\n    float d = FLT_MAX;\n    vec2 off = rot(b0.ang)*j.loc_anc0;\n    float sep_size = j.softness * .003;\n    int sep0 = int(length(off)/sep_size*.5);\n    int sep1 = int(length(b1.pos-b0.pos-off)/sep_size*.5);\n    if(b0.inv_mass != 0.) d = min(d, sdDotted(p, b0.pos, b0.pos+off, sep0)-0.003);\n    if(b1.inv_mass != 0.) d = min(d, sdDotted(p, b1.pos, b0.pos+off, sep1)-0.003);\n    \n    return d;\n}\n\nfloat drawChar(vec2 char_p, int char_id) // https://www.shadertoy.com/view/llySRh\n{\n    if (char_p.x < .0 || char_p.x>1. || char_p.y<0. || char_p.y>1.) return 0.;\n    vec2 p = char_p/16.; \n    return textureGrad(iChannel2, p + fract(vec2(char_id,15-char_id/16)/16.), dFdx(p), dFdy(p)).x;\n}\n\nfloat drawCharIt(vec2 char_p, int char_id) // https://www.shadertoy.com/view/ldfcDr\n{\n    char_p.x += (1.-char_p.y)*0.3f;\n    return drawChar(char_p, char_id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    float px = rcp(min(iResolution.x, iResolution.y));\n    vec2 uv = VIEW(fragCoord);\n    \n    Globals g = loadGlobals(iChannel0);\n    \n    // Bodies and background\n    float body_d = FLT_MAX;\n    float outline_d = FLT_MAX; // to get outline inside overlapping moving boxes\n    int closest_b_id = -1;\n    Body closest_b = loadBody(iChannel0, 0);\n    for(int b_id = 0; b_id < g.n_body; b_id++)\n    {\n        if(isInvisibleBody(b_id)) continue;\n        Body b = loadBody(iChannel0, b_id);\n        if(dot2(uv-b.pos) > dot2(b.size)) continue; // helps framerate a bit with lots of bodies\n        float b_d = sdBody(uv, b);\n        if(b_d < body_d)\n        {\n            body_d = b_d;\n            closest_b = b;\n            closest_b_id = b_id;\n        }\n        \n        outline_d = min(abs(outline_d), abs(b_d));\n    }\n    \n    vec3 col = vec3(0, .35, .58) - .07 * saturate(dot2(uv*.5)); // background\n    if(body_d > 0.0)\n    {\n        // background grids\n        vec4 grid_uv = vec4(24,24,6,6)*(uv.xyxy-VIEW_ZOOM-iTime*.005*vec4(5,-3,-5,3));\n        vec4 grid = smoothstep(1.-max(10.*px,0.01)*vec4(4,4,1,1), vec4(1), sin(PI*grid_uv))*vec4(.5,.5,1,1);\n        col = mix(col, vec3(.7), max(grid.x, max(grid.y, max(grid.z, grid.w))));\n        \n        // Arrows\n        float arr_d = FLT_MAX;\n        #define ARR_ANIM(P) vec2(0,.05*sin(3.*iTime+1000.*P))\n        arr_d = min(arr_d, sdDottedArrow(uv-vec2(1,0)+ARR_ANIM(0.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(uv-vec2(1.9,-.5)+ARR_ANIM(1.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(rot(-1.2)*(uv-vec2(0,.75))+ARR_ANIM(2.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(rot(.8)*(uv-vec2(.3,-.5))+ARR_ANIM(3.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(rot(PI*.5)*(uv-vec2(-.7,-.83))+ARR_ANIM(3.), .3, 3));\n        arr_d = min(arr_d, sdArrow(rot(1.72)*(uv-vec2(-.9,-.15))+ARR_ANIM(4.), .1));\n        arr_d = min(arr_d, sdArrow(rot(-1.72)*(uv-vec2(-1.3,-.43))+ARR_ANIM(5.), .1));\n        arr_d = min(arr_d, sdArrow(rot(1.72)*(uv-vec2(-1.4,-.61))+ARR_ANIM(6.), .1));\n        arr_d = min(arr_d, sdArrow(rot(2.6)*(uv-vec2(-1.83,.7))+ARR_ANIM(7.), .1));\n        arr_d = min(arr_d, sdArrow(rot(-2.6)*(uv-vec2(-1.15,.7))+ARR_ANIM(8.), .1));\n        if(g.funnel_b_id >= 0) // funnel arrow\n        {\n            vec2 f_dir = loadBody(iChannel0, g.funnel_b_id).pos - vec2(-1.75,.1);\n            arr_d = min(arr_d, sdArrow(rot(PI*0.5-atan(f_dir.y,f_dir.x))*(uv-vec2(-1.75,.1))-vec2(0,.1), .1));\n        }\n        if(MOUSE_DOWN) // force arrows\n        {\n            vec2 m = VIEW(iMouse);\n            if(g.mode==0) arr_d = min(arr_d, sdDottedArrow(rot(PI*.25)*abs(uv-m)-vec2(0,.2+.1*sin(5.*iTime)), .15, 2));\n            if(g.mode==1) arr_d = min(arr_d, sdDottedArrow(rot(PI*1.25)*abs(uv-m)-vec2(0,-.2+.1*sin(5.*iTime)), .15, 2));\n        }\n\n        col = mix(col, vec3(.8), 1.0-smoothstep(0.,.008, arr_d));    \n\n    } \n    else // bodies\n    {\n        if(closest_b.inv_mass == 0.0 && abs(closest_b.ang_vel) < EPS) // solid lines pattern\n        {\n            float ang = round((4.*closest_b.ang-PI)/(2.*PI))/2.*PI+PI*.25;\n            vec2 ruv = vec2(cos(ang) * uv.x, sin(ang) * uv.y);\n            col = mix(col, vec3(1), smoothstep(-.07, -0.06, body_d) * smoothstep(1.-max(75.*px,0.1), 1. ,.5+.5*sin(PI*40.*(ruv.x + ruv.y))));\n        }\n        \n        col *= (closest_b_id < FACTORY_FIXED_BODIES) ? 0.8 : 1.2; // bodies color\n        // if(closest_b_id == g.funnel_b_id) col = col.zyx; // visualize closest body to the funnel exit\n    }\n\tcol = mix( col, vec3(1), 1.0-smoothstep(0.,.008, abs(closest_b_id >= FACTORY_FIXED_BODIES ? outline_d : body_d)) ); // outline\n\n    // Joints\n    float joint_d = FLT_MAX;\n    int closest_j_id = -1;\n    for(int joint_id = 0; joint_id < g.n_joint; joint_id++)\n    {\n        Joint j = loadJoint(iChannel0, g, joint_id);\n        float j_d = sdJoint(uv, j, iChannel0);\n        \n        if(j_d < joint_d)\n        {\n            joint_d = j_d;\n            closest_j_id = joint_id;\n        }\n    }\n    Joint closest_j = loadJoint(iChannel0, g, closest_j_id);\n    col = mix( col, vec3(1), 1.-smoothstep(.0, 0.004, (joint_d)));\n    \n    // Texts\n    #define PRINT_CHR(P,C,D,F) D=max(D,F(P,C));\n    #define PRINT_STR(P,A,D,F) for(int i=0;i<A.length();i++,P.x-=.44)D=max(D,F(P,A[i]));\n    #define PRINT_INT(P,N,D,F) for(int i=0,n=N;n>0||i==0;i++,n/=10,P.x+=.44)D=max(D,F(P,48+n%10));\n    float char_d = 0.;\n    vec2 p = vec2(6,6.3)*(uv-vec2(-.6,1.27));\n    int title[] = int[](84,104,101,32,67,104,97,111,115,32,70,97,99,116,111,114,121);\n    PRINT_STR(p, title, char_d, drawChar)\n    p = (p+vec2(8.8, .58))*1.4;\n    int subtitle[] = int[](71,80,85,32,105,109,112,108,101,109,101,110,116,97,116,105,111,110,32,111,102,32,66,111,120,50,68,45,108,105,116,101);\n    PRINT_STR(p, subtitle, char_d, .8*drawCharIt)\n    p = vec2(8,8.3)*(uv-vec2(-1.95,-1.27));\n    int hint_0[] = int[](67,108,105,99,107,32,116,111,32,112,117,115,104,32,98,111,120,101,115,33);\n    int hint_1[] = int[](67,108,105,99,107,32,116,111,32,112,117,108,108,32,98,111,120,101,115,33);\n    int hint_2[] = int[](67,108,105,99,107,32,116,111,32,97,100,100,32,109,111,114,101,33,32,32);\n    if(g.mode == 0) PRINT_STR(p, hint_0, char_d, (.5+.5*sin(2.*iTime))*drawChar)\n    if(g.mode == 1) PRINT_STR(p, hint_1, char_d, (.5+.5*sin(2.*iTime))*drawChar)\n    if(g.mode == 2) PRINT_STR(p, hint_2, char_d, (.5+.5*sin(2.*iTime))*drawChar)\n    int boxes[] = int[](66,111,120,101,115,32,58,32);\n    p = p-vec2(-8.6,1.15);\n    PRINT_STR(p, boxes, char_d, .8*drawCharIt)\n    p.x -= float(boxes.length())*.44;\n    PRINT_INT(p, bodyMax(g.res), char_d, .8*drawCharIt)\n    p.x += .44;\n    PRINT_CHR(p, 47, char_d, .8*drawCharIt)\n    p.x += .88;\n    PRINT_INT(p, g.n_body, char_d, .8*drawCharIt)\n    p = vec2(8,8.3)*(uv-vec2(-1.87,.04));\n    PRINT_INT(p, g.n_funnel, char_d, drawChar)\n    col = mix(col, vec3(1), char_d);    \n    \n    // Icons\n    float icon_d = FLT_MAX;\n    p = uv - vec2(-1.7, 1.3);\n    #define ANIM_ICON(GM, M) ((GM == M) ? sin(5.*iTime) : 0.0)\n    icon_d = min(icon_d, sdArrow(rot(PI*.25)*(abs(p)-vec2(.05+.005*ANIM_ICON(g.mode, 0))), .05));\n    icon_d = min(icon_d, sdArrow(rot(PI*1.25)*(abs(p-vec2(.3, 0))-vec2(.035+.005*ANIM_ICON(g.mode, 1))), .05));\n    icon_d = min(icon_d, abs(sdBox(rot(-.2)*(p-vec2(.6,-.03)), vec2(.04)))-.004);\n    icon_d = min(icon_d, sdBox((1.+.1*ANIM_ICON(g.mode, 2))*(p-vec2(.64,.04)), vec2(.04,.01)));\n    icon_d = min(icon_d, sdBox((1.+.1*ANIM_ICON(g.mode, 2))*(p-vec2(.64,.04)), vec2(.01,.04)));\n    col = mix(col, vec3(1.,.73, 0.), 1.-step(0., sdBox(p - vec2(float(g.mode) * .3, 0), vec2(.1))));\n    p.x = p.x - .3*clamp(round(p.x/.3), 0., 2.);\n    icon_d = min(icon_d, abs(sdBox(p, vec2(.09))-.01)-.005);\n    col = mix(col, vec3(1), 1.-smoothstep(.0, 0.004, icon_d));    \n   \n    fragColor = vec4(pow(col,vec3(1.21)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common\n\n// Constants\n#define PI (3.141592)\n#define FLT_MAX (1e12)\n#define EPS (1e-12)\n\n// Engine internals\n#define GRAVITY (vec2(0,-1.)) \n#define ALLOWED_PENETRATION (.0005)\n#define K_BIAS_FACTOR (.2)\n#define MAX_VELOCITY (10.)\n#define MAX_ANG_VELOCITY (100.)\n\n// Factory example \n#define SPAWN_COOLDOWN (.05)\n#define VIEW_ZOOM (1.4+.1*exp(-iTime))\n#define VIEW_OFFSET (vec2(0,.05))\n#define VIEW(P) (VIEW_ZOOM*(2.0*(P).xy-iResolution.xy)/iResolution.y+VIEW_OFFSET)\n#define FACTORY_FIXED_BODIES (70)\n#define FACTORY_MOVING_BODIES (60)\n#define FACTORY_JOINTS (30)\n#define BOX_SIZE 1.*(.03 + vec2(.03*rnd.xz))\n#define BOX_MASS (.05)\n#define BOX_FRICTION (10.)\n#define INIT_SEED (int(3. + 1.*iDate.w*100.))\n\n#define MOUSE_DOWN (iMouse.z > 0.)\n\nvec3 hash31(uint q) // https://www.shadertoy.com/view/XdGfRR\n{\n\tuvec3 n = q * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn vec3(n) * 2.328306437080797e-10;\n}\n\nfloat rcp(float x) { return 1. / x; }\nvec2 rcp(vec2 v) { return vec2(rcp(v.x), rcp(v.y)); }\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nfloat dot2(vec2 v) { return dot(v, v); }\nfloat cross2(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\nvec2 cross2(vec2 a, float b) { return vec2(a.y * b, a.x * -b); }\nvec2 cross2(float a, vec2 b) { return vec2(b.y * -a, b.x * a); }\nfloat smoothsquare(float x, float eps) { float s = sin(2.*PI*x); return .5+.5*s*rcp(sqrt(s*s+eps*eps)); }\nmat2 m_abs(mat2 m) { return mat2(abs(m[0]), abs(m[1])); }\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nstruct Globals\n{\n    ivec2 res;\n    int n_body;\n    int n_joint;\n    float time;\n    // factory example specific fields :\n    float t_added; \n    int n_funnel;\n    int funnel_b_id;\n    int mode;\n};\n\n#define size_of_Globals (9)\n#define pixel_count_of_Globals (3)\n\nstruct Body \n{\n    vec2 pos;    \n    vec2 vel;\n    \n    float ang;\n    float ang_vel;\n    \n    vec2 size;\n    float inv_mass;\n    float inv_friction;\n    float inv_i;\n};\n\n#define size_of_Body (11)\n#define pixel_count_of_Body (3)\n\nstruct Joint\n{\n    int b0_id;\n    int b1_id;\n    vec2 loc_anc0;\n    vec2 loc_anc1;\n    float bias_factor;\n    float softness;\n    vec2 r0;\n    vec2 r1;\n    mat2 M;\n    vec2 bias;\n    vec2 P;\n};\n\n#define size_of_Joint (20)\n#define pixel_count_of_Joint (5)\n\nstruct Contact\n{\n    vec2 pos;\n    vec2 normal;\n    float sep;\n    \n    float mass_n;\n    float mass_t;\n    float bias;\n};\n\n#define size_of_Contact (8)\n#define pixel_count_of_Contact (2)\n\nint address(int width, ivec2 addr2D)\n{\n    return addr2D.x + addr2D.y * width; \n}\n\nint bufferAddress(sampler2D buff, ivec2 addr2D)\n{\n    return address(textureSize(buff, 0).x, addr2D);\n}\n\nivec2 address2D(int width, int addr)\n{\n    return ivec2(addr % width, addr / width);\n}\n\nivec2 address2D(ivec2 res, int addr)\n{\n    return address2D(res.x, addr);\n}\n\nivec2 address2D(vec2 res, int addr)\n{\n    return address2D(int(res.x), addr);\n}\n\nivec2 bufferAddress2D(sampler2D buff, int addr)\n{\n    return address2D(textureSize(buff, 0).x, addr);\n}\n\nint bodyStartAddress() \n{ \n    return pixel_count_of_Globals; \n}\n\nint bodyAddress(int b_id)\n{\n    return bodyStartAddress() + pixel_count_of_Body * b_id;\n}\n\nint jointStartAddress(Globals g) \n{ \n    return bodyStartAddress() + g.n_body * pixel_count_of_Body; \n}\n\nint jointAddress(Globals g, int j_id)\n{\n    return jointStartAddress(g) + pixel_count_of_Joint * j_id;\n}\n\nint contactStartAddress(Globals g)\n{\n    return jointStartAddress(g) + g.n_joint * pixel_count_of_Joint;\n}\n\nint contactAddress(Globals g, int c_id)\n{\n    return contactStartAddress(g) + pixel_count_of_Contact * c_id;\n}\n\nint nContact(Globals g)\n{\n    return g.n_body * (g.n_body - 1); // one contact foreach pair of body\n}\n\nint jointMax() // linear space in memory\n{ \n    return 1000; \n}\n\nint bodyMax(ivec2 res) //  quadratic space in memory because of contacts\n{\n    float c = float(pixel_count_of_Globals+pixel_count_of_Joint*jointMax()-res.x*res.y);\n    float sb = float(pixel_count_of_Body);\n    float sc = float(pixel_count_of_Contact);\n    float sbc = sb - sc;\n    return int((sqrt(sbc*sbc-4.*sc*c)-(sbc))/(2.*sc));\n}\n\nGlobals loadGlobals(sampler2D buff)\n{\n    Globals g;\n    vec4 data0 = texelFetch(buff, bufferAddress2D(buff, 0), 0);\n    vec4 data1 = texelFetch(buff, bufferAddress2D(buff, 1), 0);\n    vec4 data2 = texelFetch(buff, bufferAddress2D(buff, 2), 0);\n    g.res = ivec2(data0.xy);\n    g.n_body = int(data0.z);\n    g.n_joint = int(data0.w);\n    g.time = data1.x;\n    g.t_added = data1.y;\n    g.n_funnel = int(data1.z);\n    g.funnel_b_id = int(data1.w);\n    g.mode = int(data2.x);\n    return g;\n}\n\nvoid storeGlobals(int buff_w, Globals g, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int fragAddr = address(buff_w, fragCoord);\n\n    if(fragAddr == 0) fragColor = vec4(g.res, g.n_body, g.n_joint);\n    if(fragAddr == 1) fragColor = vec4(g.time, g.t_added, g.n_funnel, g.funnel_b_id);\n    if(fragAddr == 2) fragColor = vec4(g.mode, -1, -1, -1);\n}\n\nBody loadBody(sampler2D buff, ivec2 res, int b_id)\n{\n    Body b;\n    \n    int addr = bodyAddress(b_id);\n    \n    vec4 data0 = texelFetch(buff, address2D(res, addr), 0);\n    vec4 data1 = texelFetch(buff, address2D(res, addr+1), 0);\n    vec4 data2 = texelFetch(buff, address2D(res, addr+2), 0);\n    \n    b.pos = data0.xy;\n    b.vel = data0.zw;\n    \n    b.ang = data1.x;\n    b.ang_vel = data1.y;\n    \n    b.size = data1.zw;\n    b.inv_mass = data2.x;\n    b.inv_friction = data2.y;\n    b.inv_i = data2.z;\n    \n    return b;\n}\n\nBody loadBody(sampler2D buff, int b_id)\n{\n    return loadBody(buff, textureSize(buff, 0), b_id);\n}\n\nvoid storeBody(int res_x, int b_id, Body b, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int addr = bodyAddress(b_id);\n    int fragAddr = address(res_x, fragCoord);\n    \n    if(fragAddr == addr) fragColor = vec4(b.pos, b.vel);\n    if(fragAddr == addr + 1) fragColor = vec4(b.ang, b.ang_vel, b.size);\n    if(fragAddr == addr + 2) fragColor = vec4(b.inv_mass, b.inv_friction, b.inv_i, -1);\n}\n\nfloat computeInvI(Body b)\n{\n    return 12. * b.inv_mass / dot2(b.size);\n}\n\nJoint loadJoint(sampler2D buff, Globals g, int j_id)\n{\n    Joint j;\n    \n    int addr = jointAddress(g, j_id);\n    \n    vec4 data0 = texelFetch(buff, address2D(g.res, addr), 0);\n    vec4 data1 = texelFetch(buff, address2D(g.res, addr+1), 0);\n    vec4 data2 = texelFetch(buff, address2D(g.res, addr+2), 0);\n    vec4 data3 = texelFetch(buff, address2D(g.res, addr+3), 0);\n    vec4 data4 = texelFetch(buff, address2D(g.res, addr+4), 0);\n    \n    j.b0_id = int(data0.x);\n    j.b1_id = int(data0.y);\n    j.loc_anc0 = data0.zw;\n    j.loc_anc1 = data1.xy;\n    j.bias_factor = data1.z;\n    j.softness = data1.w;\n    j.r0 = data2.xy;\n    j.r1 = data2.zw;\n    j.M = mat2(data3);\n    j.bias = data4.xy;\n    j.P = data4.zw;\n    \n    return j;\n}\n\nvoid storeJoint(int res_x, Globals g, int j_id, Joint j, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int addr = jointAddress(g, j_id);\n    int fragAddr = address(res_x, fragCoord);\n    \n    if(fragAddr == addr) fragColor = vec4(float(j.b0_id), float(j.b1_id), j.loc_anc0);\n    if(fragAddr == addr + 1) fragColor = vec4(j.loc_anc1, j.bias_factor, j.softness);\n    if(fragAddr == addr + 2) fragColor = vec4(j.r0, j.r1);\n    if(fragAddr == addr + 3) fragColor = vec4(j.M);\n    if(fragAddr == addr + 4) fragColor = vec4(j.bias, j.P);\n}\n\nContact loadContact(sampler2D buff, Globals g, int c_id)\n{\n    Contact c;\n    \n    int addr = contactAddress(g, c_id);\n    \n    vec4 data0 = texelFetch(buff, address2D(g.res, addr), 0);\n    vec4 data1 = texelFetch(buff, address2D(g.res, addr+1), 0);\n    \n    c.pos = data0.xy;\n    c.normal = data0.zw;\n    c.sep = data1.x;\n\n    c.mass_n = data1.y;\n    c.mass_t = data1.z;\n    c.bias = data1.w;\n    \n    return c;\n}\n\nvoid storeContact(int res_x, Globals g, int c_id, Contact c, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int addr = contactAddress(g, c_id);\n    int fragAddr = address(res_x, fragCoord);\n    \n    if(fragAddr == addr) fragColor = vec4(c.pos, c.normal);\n    if(fragAddr == addr + 1) fragColor = vec4(c.sep, c.mass_n, c.mass_t, c.bias);\n}\n\n#define INVALID_VALUE -10000.\nvoid setInvalidContact(inout Contact c)\n{\n    c.pos.x = INVALID_VALUE;\n}\n\nbool isContactValid(Contact c)\n{\n    return c.pos.x > INVALID_VALUE + 1.;\n}\n\n// overload so we don't have to sample the entire contact\nbool isContactValid(sampler2D buff, Globals g, int c_id)\n{\n    int addr = contactAddress(g, c_id);\n    float posx = texelFetch(buff, address2D(g.res, addr), 0).x;\n    return posx > INVALID_VALUE + 1.;\n}\n\nvoid getContactBodyIds(int c_id, out int b0_id, out int b1_id)\n{\n    c_id = c_id / 2; // 2 contacts per pair\n    \n    int i = int((1.+sqrt(1.+8.*float(c_id)))/2.);\n    int j = c_id - (i*(i-1))/2;\n    \n    b0_id = min(i, j);\n    b1_id = max(i, j);\n}\n\nint getContactId(int b0_id, int b1_id)\n{\n    if(b0_id < b1_id) return b0_id +(b1_id*(b1_id-1))/2;\n    return b1_id +(b0_id*(b0_id-1))/2;\n}\n\nvoid applyContactImpulse(inout Body b0, inout Body b1, inout Contact c)\n{\n    vec2 r0 = c.pos - b0.pos;\n    vec2 r1 = c.pos - b1.pos;\n\n    vec2 dv = b1.vel + cross2(b1.ang_vel, r1) - b0.vel - cross2(b0.ang_vel, r0);\n    float v_n = dot(dv, c.normal);\n    float dp_n = c.mass_n * (-v_n + c.bias); \n    dp_n = max(0., dp_n); \n\n    vec2 p_n = dp_n * c.normal;\n\n    // Normal impulse\n    b0.vel -= b0.inv_mass * p_n;\n    b0.ang_vel -= b0.inv_i * cross2(r0, p_n); \n\n    b1.vel += b1.inv_mass * p_n;\n    b1.ang_vel += b1.inv_i * cross2(r1, p_n); \n\n    dv = b1.vel + cross2(b1.ang_vel, r1) - b0.vel - cross2(b0.ang_vel, r0);\n    vec2 tangent = cross2(c.normal, 1.);\n    float v_t = dot(dv, tangent);\n    float dp_t = c.mass_t * (-v_t);\n    float friction = sqrt(b0.inv_friction * b1.inv_friction);\n    float max_friction = abs(friction * dp_n);\n    dp_t = clamp(dp_t, -max_friction, max_friction);\n\n    vec2 p_t = dp_t * tangent;\n\n    // Tangent impulse\n    b0.vel -= b0.inv_mass * p_t;\n    b0.ang_vel -= b0.inv_i * cross2(r0, p_t); \n\n    b1.vel += b1.inv_mass * p_t;\n    b1.ang_vel += b1.inv_i * cross2(r1, p_t);\n}\n\nvec2 computeJointImpulse(Body b0, Body b1, Joint j)\n{\n    vec2 dv = b1.vel + cross2(b1.ang_vel, j.r1) - b0.vel - cross2(b0.ang_vel, j.r0);\n    vec2 impulse = j.M * (j.bias - dv - j.softness * j.P);\n    return impulse;\n}\n\nvoid applyJointImpulse(inout Body b0, inout Body b1, inout Joint j)\n{\n    vec2 impulse = computeJointImpulse(b0, b1, j);\n    \n    b0.vel -= b0.inv_mass * impulse;\n    b0.ang_vel -= b0.inv_i * cross2(j.r0, impulse);\n\n    b1.vel += b1.inv_mass * impulse;\n    b1.ang_vel += b1.inv_i * cross2(j.r1, impulse);\n\n    j.P += impulse;\n}\n\nbool isInvisibleBody(int b_id)\n{\n    return (b_id >= 67 && b_id <= 69);\n}\n\nvoid initGlobals(ivec2 res, inout Globals g)\n{\n    g.res = res;\n    g.n_body = FACTORY_FIXED_BODIES + FACTORY_MOVING_BODIES;\n    g.n_joint = FACTORY_JOINTS;\n    g.time = 0.;\n    g.t_added = -1.;\n    g.n_funnel = 0;\n    g.funnel_b_id = -1;\n    g.mode = 2;\n}\n\n// Applying the impulses from contacts and joints\n// Theoretically, the more iterations the better, here we have 3, each in buffer B/C/D\n// Reference code uses 10 iterations and is single threaded, so each iteration uses updated bodies velocities\n// Here we can only use the velocities from previous iteration, and that's why stacking is not possible (i think)\n// Using accumulated impulses (as in reference) and multiple frames to reach ~12 iterations did not help\nvoid physicsIteration(out vec4 fragColor, vec2 fragCoord, vec2 iResolution, sampler2D prev_buff)\n{\n    fragColor = vec4(-1);\n    \n    Globals g = loadGlobals(prev_buff);\n\n    int res_x = int(iResolution.x);\n    int id = address(res_x, ivec2(fragCoord));\n    int g_id = id / pixel_count_of_Globals;\n    int b_id = (id - bodyStartAddress()) / pixel_count_of_Body;\n    int j_id = (id - jointStartAddress(g)) / pixel_count_of_Joint;\n    int c_id = (id - contactStartAddress(g)) / pixel_count_of_Contact;\n    if(g_id == 0) // Globals\n    {\n        // Copy\n        fragColor = texelFetch(prev_buff, ivec2(fragCoord), 0);\n    }\n    else if(b_id >= 0 && b_id < g.n_body) // Body\n    {\n        // Load\n        Body b = loadBody(prev_buff, b_id);\n\n        // Apply contact impulses\n        // Iterate contacts pointing to this body\n        for(int i = 0; i < g.n_body; i++) //\n        {\n            if(i == b_id) continue;\n            Body b_i = loadBody(prev_buff, i);\n\n            int c_id = getContactId(b_id, i);\n            for(int j = 0; j < 2; j++)\n            {\n                int c_ij_id = 2 * c_id + j;\n\n                if(!isContactValid(prev_buff, g, c_ij_id)) continue;\n                Contact c = loadContact(prev_buff, g, c_ij_id);\n\n                if(b_id > i)\n                {\n                    applyContactImpulse(b_i, b, c);\n                }\n                else\n                {\n                    applyContactImpulse(b, b_i, c);\n                }\n            }        \n        }\n       \n        // Apply joint impulses\n        // Iterate every joint pointing to this body\n        for(int joint_id = 0; joint_id < g.n_joint; joint_id++)\n        {\n            Joint j = loadJoint(prev_buff, g, joint_id);\n            if(j.b0_id == b_id)\n            {\n                Body b1 = loadBody(prev_buff, j.b1_id);\n                applyJointImpulse(b, b1, j);\n            }\n            else if(j.b1_id == b_id)\n            {\n                Body b0 = loadBody(prev_buff, j.b0_id);\n                applyJointImpulse(b0, b, j);\n            }\n        }\n       \n        // Store\n        storeBody(res_x, b_id, b, ivec2(fragCoord), fragColor);\n    }\n    else if(j_id >= 0 && j_id < g.n_joint) // Joint\n    {\n        // Load \n        Joint j = loadJoint(prev_buff, g, j_id);\n        \n        // Accumulate impulse\n        Body b0 = loadBody(prev_buff, j.b0_id);\n        Body b1 = loadBody(prev_buff, j.b1_id);\n        applyJointImpulse(b0, b1, j);\n        \n        // Store\n        storeJoint(res_x, g, j_id, j, ivec2(fragCoord), fragColor);\n    }\n    else if(c_id >= 0 && c_id < nContact(g)) // Contact\n    {\n        // Copy\n        fragColor = texelFetch(prev_buff, ivec2(fragCoord), 0);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Physics Integration (and scene initialization)\n\nint clipSegmentToLine(vec2 p0, vec2 p1, vec2 normal, float offset,\n inout vec2 out_p0, inout vec2 out_p1)\n{\n    int out_n = 0;\n    \n    // Distance to plane\n    float dist0 = dot(normal, p0) - offset;\n    float dist1 = dot(normal, p1) - offset;\n    \n    // If points are behind the plane\n    if(dist0 <= 0.) { out_n += 1; out_p0 = p0;  }\n    if(dist1 <= 0.) { out_n += 1; if(out_n == 1) out_p0 = p1; else out_p1 = p1; }\n    \n    // If points are on different sides of the plane\n    if(dist0 * dist1 < 0.)\n    {\n        out_n += 1;\n        vec2 p = mix(p0, p1, dist0 / (dist0 - dist1)); \n        if(out_n == 1) out_p0 = p; else out_p1 = p;\n    }\n    \n    return out_n;\n}\n\nvoid computeIncidentEdge(vec2 h, vec2 pos, mat2 rot, mat2 rot_t, vec2 normal, \n inout vec2 clip_p0, inout vec2 clip_p1)\n{\n    vec2 n = -(rot_t * normal);\n    vec2 nAbs = abs(n);\n    if(nAbs.x > nAbs.y)\n    {\n        float s = 2.*step(0., n.x)-1.;\n        clip_p0 = vec2(s, -s) * h;\n        clip_p1 = s * h;\n    }\n    else\n    {\n        float s = 2.*step(0., n.y)-1.;\n        clip_p0 = s * h;\n        clip_p1 = vec2(-s, s) * h;\n    }\n    \n    clip_p0 = pos + rot * clip_p0; \n    clip_p1 = pos + rot * clip_p1; \n}\n\nvoid trySeparatingAxis(float face, float h, int axis, vec2 sc, float d,\n inout int sep_axis, inout float sep, inout vec2 normal) \n{\n    const float tol_rel = .95;\n    const float tol_abs = .1;\n    \n    if(face > tol_rel * sep + tol_abs * h)\n    {\n        sep_axis = axis;\n        sep = face;\n        normal = d > 0. ? sc : -sc;\n    }\n}\n\nbool ignoreCollision(int b0_id, int b1_id) // This assumes b0_id < b1_id\n{\n    if(isInvisibleBody(b1_id)) return true; // only check b1_id since invisible bodies are highest hand-placed ids\n    return false;\n}\n\nvoid collide(int c_id, int b0_id, Body b0, int b1_id, Body b1, inout Contact c)\n{\n    setInvalidContact(c);\n\n    if(b0.inv_mass == 0. && b1.inv_mass == 0.) return;\n    if(ignoreCollision(b0_id, b1_id)) return; \n\n    // Setup\n    vec2 h0 = b0.size;\n    vec2 h1 = b1.size;\n    \n    mat2 rot0 = rot(b0.ang);\n    mat2 rot1 = rot(b1.ang);\n    \n    mat2 rot0_t = transpose(rot0); // rot(-b0.ang)\n    mat2 rot1_t = transpose(rot1);\n\n    vec2 dp = b1.pos - b0.pos;\n    vec2 d0 = rot0_t * dp;\n    vec2 d1 = rot1_t * dp;\n\n    mat2 m = m_abs(rot0_t * rot1); \n    mat2 m_t = transpose(m);\n\n    vec2 face0 = abs(d0) - m * h1 - h0;\n    if(face0.x > 0. || face0.y > 0.) return;\n    \n    vec2 face1 = abs(d1) - m_t * h0 - h1;\n    if(face1.x > 0. || face1.y > 0.) return;\n    \n    // Find separating axis\n    int sep_axis = 0;\n    float sep = face0.x;\n    vec2 normal = d0.x > 0. ? rot0[0] : -rot0[0];\n    \n    trySeparatingAxis(face0.y, h0.y, 1, rot0[1], d0.y, sep_axis, sep, normal);\n    trySeparatingAxis(face1.x, h1.x, 2, rot1[0], d1.x, sep_axis, sep, normal);\n    trySeparatingAxis(face1.y, h1.y, 3, rot1[1], d1.y, sep_axis, sep, normal);\n    \n    vec2 ref_normal = vec2(-1);\n    float ref_side = -1.;\n    vec2 clip_normal = vec2(-1);\n    vec2 clip_sides = vec2(-1);\n    vec2 clip_p0 = vec2(-1);\n    vec2 clip_p1 = vec2(-1);\n    \n    // Setup clipping plane\n    if(sep_axis == 0)\n    {\n        ref_normal = normal;\n        ref_side = dot(b0.pos, ref_normal) + h0.x;\n        clip_normal = rot0[1];\n        float clip_side = dot(b0.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h0.y;\n        computeIncidentEdge(h1, b1.pos, rot1, rot1_t, ref_normal, clip_p0, clip_p1);\n    }\n    else if(sep_axis == 1)\n    {\n        ref_normal = normal;\n        ref_side = dot(b0.pos, ref_normal) + h0.y;\n        clip_normal = rot0[0];\n        float clip_side = dot(b0.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h0.x;\n        computeIncidentEdge(h1, b1.pos, rot1, rot1_t, ref_normal, clip_p0, clip_p1);\n    }\n    else if(sep_axis == 2)\n    {\n        ref_normal = -normal;\n        ref_side = dot(b1.pos, ref_normal) + h1.x;\n        clip_normal = rot1[1];\n        float clip_side = dot(b1.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h1.y;\n        computeIncidentEdge(h0, b0.pos, rot0, rot0_t, ref_normal, clip_p0, clip_p1);\n    }\n    else\n    {\n        ref_normal = -normal;\n        ref_side = dot(b1.pos, ref_normal) + h1.y;\n        clip_normal = rot1[0];\n        float clip_side = dot(b1.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h1.x;\n        computeIncidentEdge(h0, b0.pos, rot0, rot0_t, ref_normal, clip_p0, clip_p1);\n    }\n    \n    // Clip\n    vec2 clip1_p0 = vec2(-1);\n    vec2 clip1_p1 = vec2(-1);\n    vec2 clip2_p0 = vec2(-1);\n    vec2 clip2_p1 = vec2(-1);\n    \n    int np = clipSegmentToLine(clip_p0, clip_p1, -clip_normal, clip_sides.x, clip1_p0, clip1_p1);\n    if(np < 2) return;\n    \n    np = clipSegmentToLine(clip1_p0, clip1_p1, clip_normal, clip_sides.y, clip2_p0, clip2_p1);\n    if(np < 2) return;\n\n    // Fill contact\n    vec2 c_p = (c_id % 2 == 0) ? clip2_p0 : clip2_p1;\n    float c_sep = dot(ref_normal, c_p) - ref_side;\n    if(c_sep <= 0.)\n    {\n        c.pos = c_p - c_sep * ref_normal;\n        c.normal = normal;\n        c.sep = c_sep;        \n    }\n}\n\n// Compute some values for the contact, maybe it's not worth losing 3 floats in the buffer if you want more bodies\nvoid preStepContact(float dt, Body b0, Body b1, inout Contact c)\n{\n    // because values are still from the previous frame we should integrated values (i don't see much difference)\n    \n    vec2 r0 = c.pos - (b0.pos + dt * b0.vel);\n    vec2 r1 = c.pos - (b1.pos + dt * b1.vel);\n    \n    float rn0 = dot(r0, c.normal);\n    float rn1 = dot(r1, c.normal);\n    \n    float k_normal = b0.inv_mass + b1.inv_mass + b0.inv_i * (dot2(r0) - rn0*rn0) + b1.inv_i * (dot2(r1) - rn1*rn1); \n    c.mass_n = 1. / k_normal;\n    \n    vec2 tangent = cross2(c.normal, 1.);\n    float rt0 = dot(r0, tangent);\n    float rt1 = dot(r1, tangent);\n    float k_tangent = b0.inv_mass + b1.inv_mass + b0.inv_i * (dot2(r0) - rt0*rt0) + b1.inv_i * (dot2(r1) - rt1*rt1); \n    c.mass_t = 1. / k_tangent;\n    \n    c.bias = -K_BIAS_FACTOR * (1. / dt) * min(0., c.sep + ALLOWED_PENETRATION);\n}\n\nvoid preStepJoint(Body b0, Body b1, float dt, inout Joint j)\n{\n    mat2 rot0 = rot(b0.ang);\n    mat2 rot1 = rot(b1.ang);\n    j.r0 = rot0 * j.loc_anc0;\n    j.r1 = rot1 * j.loc_anc1;\n\n    mat2 k1 = (b0.inv_mass + b1.inv_mass) * mat2(1, 0, 0, 1);\n    mat2 k2 = b0.inv_i * mat2(j.r0.y * j.r0.y, -j.r0.x * j.r0.y, - j.r0.x * j.r0.y, j.r0.x * j.r0.x);\n    mat2 k3 = b1.inv_i * mat2(j.r1.y * j.r1.y, -j.r1.x * j.r1.y, - j.r1.x * j.r1.y, j.r1.x * j.r1.x);\n    \n    mat2 k = k1 + k2 + k3 + mat2(j.softness, 0, 0, j.softness);\n    j.M = inverse(k);\n    \n    vec2 p0 = b0.pos + j.r0;\n    vec2 p1 = b1.pos + j.r1;\n    vec2 dp = p1 - p0;\n    j.bias = -j.bias_factor * (1. / dt) * dp; \n    \n    j.P = vec2(0);\n}\n\nvoid addBody(inout Body b)\n{\n    vec3 rnd = hash31(uint(iFrame+int(iMouse.x)));\n    b.pos = VIEW(iMouse);\n    b.ang = rnd.z;\n    b.vel = 3.*vec2(rnd.x-.5, rnd.y);\n    b.size = BOX_SIZE;\n    b.inv_mass = rcp(BOX_MASS);\n    b.inv_friction = rcp(BOX_FRICTION);\n    b.inv_i = computeInvI(b);\n}\n\nvec2 getForce(Globals g, int b_id, Body b)\n{\n    vec2 m_force = vec2(0.0);\n    if(iMouse.z > 0.5 && g.mode <= 1) \n    {\n        vec2 m = VIEW(iMouse.xy);\n        vec2 dir = ( b.pos - m);\n        m_force = -sign(float(g.mode)-.5) * .05 * dir / (dot2(dir)); // repulsive or attractive force\n    }\n\n    if(b_id == 21) m_force = 15.*vec2(sin(2.*g.time), 0.); // spring\n    if(b_id == 26) m_force = fract(g.time * .1) > .5 ? vec2(7,0) : vec2(0); // pinch\n    if(b_id == 27) m_force = fract(g.time * .1) > .5 ? vec2(-7,0) : vec2(0); // pinch\n\n    if(b.inv_mass > 0.)  return b.inv_mass * m_force + GRAVITY;\n    return vec2(0);\n   \n}\n\nfloat getTorque(Globals g, int b_id, Body b)\n{\n    float torque = 0.;\n    if(b_id >= 8 && b_id <= 9 && b.ang_vel < 2.) torque = 2.;\n    if(b_id >= 10 && b_id <= 16 && b.ang_vel < 7.) torque = 7.;\n    if(b_id == 23 && b.ang_vel < 2.) torque = 2.;\n    if(b_id == 25 && b.ang_vel > -3.) torque = -2.;\n    if(b_id >= 30 && b_id <= 36 && b.ang_vel > -7.) torque = -7.;\n    if(b_id >= 42 && b_id <= 43 && b.ang_vel < 2.) torque = 2.;\n    if(b_id >= 57 && b_id <= 62 && b.ang_vel > -5.) torque = -5.;\n    \n    if(b.inv_i == 0.) return torque;\n    return torque * b.inv_i;\n}\n\nvoid jointAnimation(Globals g, int j_id, inout Joint j)\n{\n    // Pinch\n    if(j_id == 11 || j_id == 12) j.softness = mix(20., .5, smoothsquare(g.time * .1, .1)); // vertical\n    if(j_id == 13 || j_id == 14) j.softness = mix(10., .5, smoothsquare(g.time * .1 + .1, .1)); // pinching\n\n    // Bottom-right spring\n    if(j_id >= 17 && j_id <= 20) j.softness = fract(g.time * .1 + .1) < .9 ? 50. : .2; \n}\n\n// Add some fun setting up a scene to showcase the capabilities of the system (slowing compilation though)\nvoid initBody(Globals g, int b_id, inout Body b)\n{\n    b = Body(vec2(0), vec2(0), 0., 0., vec2(0), 0., 0., 0.);\n\n    // Factory\n    vec2 p = vec2(0);\n    b.inv_friction = 0.1;\n    if(b_id <= 3) // Four walls 0 - 3\n    { \n        if      (b_id == 0) { b.pos = vec2(0,-2.15); b.size = vec2(1.8,1); }\n        else if (b_id == 1) { b.pos = vec2(0,2.1); b.size = vec2(3,1); }\n        else if (b_id == 2) { b.pos = vec2(-3,0); b.size = vec2(1,2); }\n        else                { b.pos = vec2(3,0); b.size = vec2(1,2); }\n    }\n    else if (b_id <= 7) // Funnel 4 - 7\n    {\n        p = vec2(-1.5, .5);\n        if      (b_id == 4) { b.pos = p+vec2(.3,0); b.size = vec2(.4,.02); b.ang = PI*.3; }\n        else if (b_id == 5) { b.pos = p+vec2(-.3,0); b.size = vec2(.4,.02); b.ang = -PI*.3; }\n        else if (b_id == 6) { b.pos = p+vec2(-.075,-.37); b.size = vec2(.02,.06); }\n        else                { b.pos = p+vec2(.075,-.37); b.size = vec2(.02,.06); }\n    }\n    else if (b_id <= 9) // Top Mill 8 - 9\n    {\n        b.pos = vec2(-1.5, .5);\n        b.size = (b_id == 9) ? vec2(.2,.02) : vec2(.02,.2);\n    }\n    else if (b_id <= 16) // Up treadmill 10 - 16\n    {\n        b.pos = vec2(-.8, .8) + float(b_id-10) * vec2(.2, -.1);\n        b.ang = (b_id % 2 == 0) ? 0. : PI*.25;\n        b.size = vec2(.04,.1);\n    }\n    else if (b_id <= 21) // Spring 17 - 21\n    {\n        b.pos = vec2(-2.02, -.82) + vec2(float(b_id-17) *.15, 0);\n        b.size = (b_id == 21) ? vec2(.06,.1) : vec2(.02,.1);\n        b.inv_mass = (b_id == 17) ? 0. : rcp(10.);\n    }\n    else if (b_id <= 24) // Flipper 22 - 24\n    {\n        p = vec2(-2., -.82);\n        if      (b_id == 22) { b.pos = p+vec2(1.75,-.16); b.ang = -.05; b.size = vec2(.45,.04); b.inv_mass = rcp(20.); }\n        else if (b_id == 23) { b.pos = p+vec2(2.3,-.2); b.ang = 1.; b.size = vec2(.2, .02); }\n        else                 { b.pos = p+vec2(.2,-.5); b.size = vec2(1.1,.4); }// Bottom Edge\n    }\n    else if (b_id <= 29) // Pinch 25 - 29\n    {\n        p = vec2(1.,.2);\n        if      (b_id == 25) { b.pos = p+vec2(0,.5); b.size = vec2(.27, 0.03); }\n        else if (b_id == 26) { b.pos = p+vec2(.175,.2); b.ang = PI*.25; b.size = vec2(.2, .03); }\n        else if (b_id == 27) { b.pos = p+vec2(-.175,.2); b.ang = -PI*.25; b.size = vec2(.2, .03); }\n        else if (b_id == 28) { b.pos = p+vec2(-.34,.5); b.size = vec2(.06, .03); }\n        else                 { b.pos = p+vec2(.34,.5); b.size = vec2(.06, .03); }\n        b.inv_mass = b_id <= 27 ? rcp(10.) : rcp(1.);\n    }\n    else if (b_id <= 36) // Top treadmill 30 - 36\n    {\n        b.pos = vec2(-.8, 1.1) + vec2(float(b_id-30)*.2, 0);\n        b.ang = (b_id % 2 == 0) ? 0. : PI*.25;\n        b.size = vec2(.04,.1);\n    }\n    else if (b_id <= 41) // Bottom basin 37 - 41\n    {\n        p = vec2(1.,-.8);\n        if      (b_id == 37) { b.pos = p; b.size = vec2(.14,.04); }\n        else if (b_id == 38) { b.pos = p+vec2(-.26, .16); b.ang = PI*.25; b.size = vec2(.04,.16); }\n        else if (b_id == 39) { b.pos = p+vec2(.26, .16); b.ang = -PI*.25; b.size = vec2(.04,.16); }\n        else if (b_id == 40) { b.pos = p+vec2(-.44, -.1); b.size = vec2(.04,.4); }\n        else                 { b.pos = p+vec2(.545, .05); b.size = vec2(.16,.25); }\n        b.inv_mass = (b_id <= 39) ? rcp(.5) : 0.;\n    }\n    else if (b_id <= 43) // Center Mill 42 - 43\n    {\n        b.pos = vec2(0., -.2);\n        b.size = (b_id == 42) ? vec2(.4,.02) : vec2(.02,.4);\n    }\n    else if (b_id <= 46) // Right spring 44 - 46\n    {\n        p = vec2(1.9, -1.28);\n        b.pos = p + vec2(0, float(b_id-44)*.3);\n        b.size = vec2(.09,.03);\n        b.inv_mass = (b_id == 44) ? 0. : rcp(40.);\n    }\n    else if (b_id <= 47) // Right trapdoor 47\n    {\n        b.pos = vec2(1.5,.92); b.size = vec2(.025,.09); b.inv_mass = rcp(.05);\n    }\n    else if (b_id <= 56) // Right pipe 48 - 56\n    {\n        if      (b_id == 48) { b.pos = vec2(1.65,-.15); b.size = vec2(.16,.85); }\n        else if (b_id == 49) { b.pos = vec2(2.48,1.13); b.ang = .4; b.size = vec2(.6,.6); }\n        else if (b_id == 50) { b.pos = vec2(3.29,1.37); b.ang = .8; b.size = vec2(.6,.4); }\n        else if (b_id == 51) { b.pos = vec2(2.,1.54); b.ang = 1.2; b.size = vec2(.6,.8); }\n        else if (b_id == 52) { b.pos = vec2(1.69,1.11); b.size = vec2(.2,.1); }\n        else if (b_id == 53) { b.pos = vec2(1.7,.69); b.ang = .52; b.size = vec2(.1,.05); }\n        else if (b_id == 54) { b.pos = vec2(1.68,.71); b.ang = 1.04; b.size = vec2(.1,.05); }\n        else if (b_id == 55) { b.pos = vec2(1.59,.74); b.size = vec2(.1,.08); }\n        else                 { b.pos = vec2(1.9,-1.45); b.size = vec2(.4,.2); }\n        b.inv_friction = .001;\n    }\n    else if (b_id <= 62) // Down treadmill 57 - 62\n    {\n        b.pos = vec2(.7, -1.2) + vec2(float(b_id-57)*.2,0);\n        b.ang = (b_id % 2 == 0) ? PI*.25 : 0.;\n        b.size = vec2(.04,.1);\n    }\n    else if (b_id <= 66) // Down ramps 63 - 66\n    {\n        p = vec2(-1.5, -.15);\n        if      (b_id == 63) { b.pos = p; b.ang = -PI*.05; b.size = vec2(.6,.02); }\n        else if (b_id == 64) { b.pos = p+vec2(.6,-.3); b.ang = PI*.05; b.size = vec2(.4,.02); }\n        else if (b_id == 65) { b.pos = p+vec2(1.,.15); b.size = vec2(.02,.4); }\n        else                 { b.pos = p+vec2(-.2,-.5); b.ang = -PI*.05; b.size = vec2(.3,.02); }\n        b.inv_friction = .001;\n    }\n    else if (b_id <= 69) // Invisible boxes 67 - 69 (to prevent boxes from being stuck)\n    {\n        if      (b_id == 67) { b.pos = vec2(-1.75,-.82); b.ang = -PI*.05; b.size = vec2(.32,.16); }\n        else if (b_id == 68) { b.pos = vec2(-.36,-1.18); b.ang = -PI*.1; b.size = vec2(.42,.12); }\n        else                 { b.pos = vec2(1.9,-1.25); b.size = vec2(.12,.1); }\n        b.inv_friction = .1;\n    }\n    else // Dynamic Boxes 70+\n    {\n        vec3 rnd = hash31(uint(b_id+INIT_SEED));\n        b.pos = vec2(3., 1.5)*(rnd.xy-vec2(.6,.4));\n        b.ang = rnd.z;\n        b.size = BOX_SIZE;\n        b.inv_mass = rcp(BOX_MASS);\n        b.inv_friction = rcp(BOX_FRICTION);\n    }     \n\n    b.inv_i = computeInvI(b); \n}\n\n// Some helpers for initializing joint (the anchor position is most of the time dependant on bodies positions)\nvoid initJoint(int b0_id, int b1_id, vec2 loc_anc0, vec2 loc_anc1, inout Joint j)\n{\n    if (b0_id <= b1_id)\n    {\n        j.b0_id = b0_id; j.loc_anc0 = loc_anc0;\n        j.b1_id = b1_id; j.loc_anc1 = loc_anc1;\n    }\n    else \n    {\n        j.b0_id = b1_id; j.loc_anc0 = loc_anc1;\n        j.b1_id = b0_id; j.loc_anc1 = loc_anc0;\n    }\n}\n\nvoid initJoint(Globals g, int b0_id, int b1_id, vec2 anchor, inout Joint j)\n{\n    Body b0; initBody(g, b0_id, b0);\n    Body b1; initBody(g, b1_id, b1);\n   \n    vec2 loc_anc0 = transpose(rot(b0.ang)) * (anchor - b0.pos);\n    vec2 loc_anc1 = transpose(rot(b1.ang)) * (anchor - b1.pos);    \n    \n    initJoint(b0_id, b1_id, loc_anc0, loc_anc1, j);\n}\n\nvoid initJoint_Mid(Globals g, int b0_id, int b1_id, vec2 offset, inout Joint j)\n{\n    Body b0; initBody(g, min(b0_id, b1_id), b0);\n    Body b1; initBody(g, max(b0_id, b1_id), b1);\n   \n    vec2 anchor = (b0.pos + b1.pos) * .5 + offset;\n    vec2 loc_anc0 = transpose(rot(b0.ang)) * (anchor - b0.pos);\n    vec2 loc_anc1 = transpose(rot(b1.ang)) * (anchor - b1.pos);    \n    \n    initJoint(b0_id, b1_id, loc_anc0, loc_anc1, j);\n}\n\nvoid initJoint_Mid(Globals g, int b0_id, int b1_id, inout Joint j)\n{\n    initJoint_Mid(g, b0_id, b1_id, vec2(0), j);\n}\n\nvoid initJoint_Second(Globals g, int b0_id, int b1_id, vec2 offset, inout Joint j)\n{\n    Body b0; initBody(g, b0_id, b0);\n    Body b1; initBody(g, b1_id, b1);\n   \n    vec2 anchor = b1.pos + offset;\n    vec2 loc_anc0 = transpose(rot(b0.ang)) * (anchor - b0.pos);\n    vec2 loc_anc1 = transpose(rot(b1.ang)) * (anchor - b1.pos);    \n    \n    initJoint(b0_id, b1_id, loc_anc0, loc_anc1, j);\n}\n\nvoid initJoint_Second(Globals g, int b0_id, int b1_id, inout Joint j)\n{\n    initJoint_Second(g, b0_id, b1_id, vec2(0), j);\n}\n\nvoid initJoint(Globals g, int j_id, inout Joint j)\n{\n    j = Joint(-1, -1, vec2(0), vec2(0), 0., 0., vec2(0), vec2(0), mat2(0), vec2(0), vec2(0));\n    if(j_id <= 7) // Spring 0 - 7\n    {\n        if      (j_id == 0) initJoint_Mid(g, 17, 18, vec2(0,.1), j);\n        else if (j_id == 1) initJoint_Mid(g, 17, 18, vec2(0,-.1), j);\n        else if (j_id == 2) initJoint_Mid(g, 18, 19, vec2(0,.1), j);\n        else if (j_id == 3) initJoint_Mid(g, 18, 19, vec2(0,-.1), j);\n        else if (j_id == 4) initJoint_Mid(g, 19, 20, vec2(0,.1), j);\n        else if (j_id == 5) initJoint_Mid(g, 19, 20, vec2(0,-.1), j);\n        else if (j_id == 6) initJoint_Mid(g, 20, 21, vec2(0,.1), j);\n        else                initJoint_Mid(g, 20, 21, vec2(0,-.1), j);\n        j.softness = 10.; \n        j.bias_factor = .5;\n    }\n    else if (j_id <= 9) // Flipper 8 - 9\n    {\n        if (j_id == 8) { initJoint_Second(g, 24, 22, vec2(-.4,.04), j); j.softness = .01; }\n        else           { initJoint_Second(g, 0, 22, vec2(0,-.2), j); j.softness = 3.; }\n        j.bias_factor = .5;\n    }\n    else if (j_id <= 16) // Pinch 10 - 16\n    {\n        if      (j_id == 10) initJoint_Second(g, 1, 25, j);\n        else if (j_id == 11) initJoint_Second(g, 26, 25, j);\n        else if (j_id == 12) initJoint_Second(g, 27, 25, j);\n        else if (j_id == 13) initJoint_Mid(g, 26, 27, vec2(0,.1), j);\n        else if (j_id == 14) initJoint_Mid(g, 26, 27, vec2(0,-.1), j);\n        else if (j_id == 15) initJoint_Second(g, 25, 28, vec2(.04,0), j);\n        else                 initJoint_Second(g, 25, 29, vec2(-.04,0), j);\n        j.bias_factor = .02;\n        j.softness = 0.; // will be overriden by JointAnimation\n    }\n    else if (j_id <= 20) // Bottom-right Spring 17 - 20\n    {\n        if      (j_id == 17) initJoint_Mid(g, 44, 45, vec2(-.1, 0), j);\n        else if (j_id == 18) initJoint_Mid(g, 44, 45, vec2(.1, 0), j);\n        else if (j_id == 19) initJoint_Mid(g, 45, 46, vec2(-.1, 0), j);\n        else                 initJoint_Mid(g, 45, 46, vec2(.1, 0), j);\n        j.bias_factor = .2;\n        j.softness = 10.; // will be overriden by JointAnimation\n    }\n    else if (j_id <= 21) // Top-right trapdoor 21\n    {\n        initJoint_Second(g, 52, 47, vec2(0,.1), j);\n        j.softness = 0.; j.bias_factor = .075;\n    }\n    else if (j_id <= 29) // Bottom Bassin 22 - 29\n    {\n        if      (j_id == 22) initJoint_Second(g, 0, 37, vec2(.15, -.35), j);\n        else if (j_id == 23) initJoint_Second(g, 0, 37, vec2(-.15, -.35), j);\n        else if (j_id == 24) initJoint_Second(g, 0, 38, vec2(.15, -.5), j);\n        else if (j_id == 25) initJoint_Second(g, 0, 38, vec2(-.15, -.5), j);\n        else if (j_id == 26) initJoint_Second(g, 0, 39, vec2(.15, -.5), j);\n        else if (j_id == 27) initJoint_Second(g, 0, 39, vec2(-.15, -.5), j);\n        else if (j_id == 28) initJoint_Mid(g, 37, 38, j);\n        else                 initJoint_Mid(g, 37, 39, j);\n        j.softness = 20.; j.bias_factor = .1;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(-1);\n \n    Globals g_prev = loadGlobals(iChannel0);\n\n    bool is_first_frame = (iFrame == 0);\n    if(is_first_frame) initGlobals(ivec2(iResolution), g_prev);\n\n    int res_x = int(iResolution.x);\n    bool is_buffer_smaller = (g_prev.res.x > res_x) || (g_prev.res.y > int(iResolution.y)); \n    bool is_init = is_first_frame || is_buffer_smaller;\n    bool is_body_added = !is_init \n     && (MOUSE_DOWN)\n     && (g_prev.mode == 2)\n     && (g_prev.n_body < bodyMax(ivec2(iResolution))) \n     && (g_prev.t_added + SPAWN_COOLDOWN < g_prev.time);\n\n    Globals g_next = g_prev;\n    if(is_init) initGlobals(ivec2(iResolution), g_next);\n    g_next.res = ivec2(iResolution);\n    if(is_body_added) \n    {\n        g_next.n_body += 1;\n        g_next.t_added = g_prev.time;\n    }\n\n    int id = address(res_x, ivec2(fragCoord));\n    int g_id = id / pixel_count_of_Globals;\n    int b_id = (id - bodyStartAddress()) / pixel_count_of_Body;\n    int j_id = (id - jointStartAddress(g_next)) / pixel_count_of_Joint;\n    int c_id = (id - contactStartAddress(g_next)) / pixel_count_of_Contact;\n    float dt = rcp(60.); // factory calibrated with 60 fps, using iTimeDelta is more correct \n\n    if(g_id == 0) // Globals\n    {\n        g_next.time += dt;\n        \n        // Factory example specific : update funnel counter and b_id \n        vec2 funnel_p = vec2(-1.5, .07);\n        Body funnel_b = loadBody(iChannel0, g_prev.funnel_b_id);\n        if(g_prev.funnel_b_id >= 0 && funnel_b.pos.y < funnel_p.y) g_next.n_funnel = g_prev.n_funnel + 1;\n        g_next.funnel_b_id = -1;\n        float funnel_d = FLT_MAX;\n        for(int i = 70; i < g_prev.n_body; i++) \n        {\n            Body b_i = loadBody(iChannel0, i);\n            if(b_i.pos.y < funnel_p.y) continue;\n            float b_d = dot2(b_i.pos - funnel_p);\n            if(b_d > .1) continue;\n            if(g_next.funnel_b_id < 0 || b_d < funnel_d)\n            {\n                g_next.funnel_b_id = i;\n                funnel_d = b_d;\n            }\n        }\n        \n        // Factory example specific : select mode\n        if(MOUSE_DOWN)\n        {\n            vec2 m = VIEW(iMouse);\n            if(length(m-vec2(-1.7, 1.3)) < .15) g_next.mode = 0; \n            if(length(m-vec2(-1.4, 1.3)) < .15) g_next.mode = 1; \n            if(length(m-vec2(-1.1, 1.3)) < .15) g_next.mode = 2; \n        }\n        \n        // Store\n        storeGlobals(res_x, g_next, ivec2(fragCoord), fragColor);\n    }\n    else if(b_id >= 0 && b_id < g_next.n_body) // Body\n    {\n        // Load\n        Body b = loadBody(iChannel0, g_prev.res, b_id);\n        if(is_init) initBody(g_next, b_id, b);\n        if(b_id >= g_prev.n_body) addBody(b);\n\n        // Limit velocities\n        if(length(b.vel) > MAX_VELOCITY) b.vel /= length(b.vel) * MAX_VELOCITY;\n        if(abs(b.ang_vel) > MAX_ANG_VELOCITY) b.ang_vel = clamp(b.ang_vel, -MAX_ANG_VELOCITY, MAX_ANG_VELOCITY);   \n\n        // Integrate velocities \n        b.pos += b.vel * dt;\n        b.ang += b.ang_vel * dt;\n\n        // Integrate forces\n        b.vel += getForce(g_next, b_id, b) * dt;\n        b.ang_vel += getTorque(g_next, b_id, b) * dt;\n\n        // Store\n        storeBody(res_x, b_id, b, ivec2(fragCoord), fragColor);\n    }\n    else if(j_id >= 0 && j_id < g_next.n_joint) // Joint\n    {\n        // Load\n        Joint j = loadJoint(iChannel0, g_prev, j_id);\n        if(is_init) initJoint(g_next, j_id, j);\n        jointAnimation(g_next, j_id, j);\n\n        // Load associated bodies\n        Body b0 = loadBody(iChannel0, g_prev.res, j.b0_id);\n        if(is_init) initBody(g_next, j.b0_id, b0);\n        if(j.b0_id >= g_prev.n_body) addBody(b0);\n\n        Body b1 = loadBody(iChannel0, g_prev.res, j.b1_id);\n        if(is_init) initBody(g_next, j.b1_id, b1);\n        if(j.b1_id >= g_prev.n_body) addBody(b1);\n\n        // Pre Step\n        preStepJoint(b0, b1, dt, j);\n\n        // Store\n        storeJoint(res_x, g_next, j_id, j, ivec2(fragCoord), fragColor);\n    }\n    else if(c_id >= 0 && c_id < nContact(g_next)) // Contact\n    {\n        // Load\n        Contact c = loadContact(iChannel0, g_prev, c_id);\n\n        // Load associated bodies\n        int b0_id = -1, b1_id = -1;\n        getContactBodyIds(c_id, b0_id, b1_id);\n\n        Body b0 = loadBody(iChannel0, g_prev.res, b0_id);\n        if(is_init) initBody(g_next, b0_id, b0);\n        if(b0_id >= g_prev.n_body) addBody(b0);\n\n        Body b1 = loadBody(iChannel0, g_prev.res, b1_id);\n        if(is_init) initBody(g_next, b1_id, b1);\n        if(b1_id >= g_prev.n_body) addBody(b1);\n\n        // Collide\n        collide(c_id, b0_id, b0, b1_id, b1, c);\n\n        // Pre Step\n        preStepContact(dt, b0, b1, c);\n\n        // Store\n        storeContact(res_x, g_next, c_id, c, ivec2(fragCoord), fragColor);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Physics Iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    physicsIteration(fragColor, fragCoord, iResolution.xy, iChannel0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Physics Iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    physicsIteration(fragColor, fragCoord, iResolution.xy, iChannel0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Physics Iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    physicsIteration(fragColor, fragCoord, iResolution.xy, iChannel0);\n}","name":"Buffer D","description":"","type":"buffer"}]}