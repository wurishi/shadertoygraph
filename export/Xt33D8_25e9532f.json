{"ver":"0.1","info":{"id":"Xt33D8","date":"1469211403","viewed":233,"name":"Pokestop","username":"SamGondelman","description":"A Pokestop from Pokemon Go.  Move towards it to activate it!\n\nMove with WASD/arrow keys, E/C for up/down, click and drag to rotate camera (center of screen is forward)","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","firstperson","multipass","pokemon","pokemongo","pokestop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Math constants\nconst float PI = 3.14159265359;\nconst float EPS = 0.0001;\nconst float FLT_MAX = 1.0 / 0.000000000001; // hacky but GLSL doesn't have a FLT_MAX by default\n\n// Raymarching constants\nconst float TMAX = 100.0;\nconst int MAX_STEPS = 75;\nconst float DIST_THRESHOLD = 0.00001;\n\n// Texel addresses\nconst vec2 txPlayerPos = vec2(0.0,0.0);\nconst vec2 txTimers = vec2(2.0,0.0);\n\n// Other constants/helpers\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n#define clamp01(a) clamp(a, 0.0, 1.0)\n\nstruct Ray {\n    vec3 src;\n    vec3 dir;\n    float t;\n    vec3 pos;\n    vec3 nor;\n    int matID;\n    int iter;\n};\n\n// GLSL default parameters don't seem to work so this is for any call to map\n// where you don't actually care about the material of what you hit\nint junkMatID;\n\n// Primitives\nfloat plane(vec3 p, float y) {\n    return p.y - y;\n}\n\nfloat box(vec3 p, vec3 dim) {\n    vec3 d = abs(p) - dim;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cone(vec3 p, float r, float h) {\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*r/h;\n    float d2 = max(sqrt(dot(p.xz,p.xz)*(1.0-si*si)) + q*si, q);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// CSG operations\nfloat intersectionDist(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat subtractionDist(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n// Transformations\nvec3 rX(vec3 p, float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    vec3 q = p;\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n    return p;\n}\n\nvec3 rY(vec3 p, float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    vec3 q = p;\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n    return p;\n}\n\nvoid propose(inout float val, inout int matID, float proposedVal, int proposedMatID) {\n    if (proposedVal < val) {\n        val = proposedVal;\n        matID = proposedMatID;\n    }\n}\n\nfloat map(vec3 p, inout int matID, vec3 timers) {\n    float cubeTime = timers[0];\n    float growTime = timers[1];\n    float distTime = timers[2];\n    \n    float res = FLT_MAX;\n    \n    propose(res, matID, plane(p, 0.0), 1);\n    propose(res, matID, cylinder(p, 1.0, 0.05), 2);\n    float height = 4.0;\n    float heightOffset = 0.05 * cos(1.1 * iTime);\n    propose(res, matID, cylinder(p - vec3(0, height/2.0, 0), 0.05, height/2.0), 2);\n    propose(res, matID, box(p - vec3(0, height, 0), vec3(1.0, 0.05, 1.0)), 2);\n    const float CUBE_GROW_TIME = 0.25;\n    float cubeRatio = 1.0 - cubeTime/CUBE_GROW_TIME;\n    propose(res, matID, box(rY(rX(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                  45.0 + iTime * 20.0), 45.0 + iTime * 20.0),\n                            vec3(0.75*cubeRatio)), 2);\n    \n    const float GROW_TIME = 0.5;\n    float ratio = growTime/GROW_TIME;\n    float outerRing = subtractionDist(\n        \t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*2.5, 0.05),\n    \t\t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*2.1, 0.1));\n    propose(res, matID, outerRing, 2);\n    \n    float outerRing2 = subtractionDist(\n        \t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*2.4, 0.1),\n    \t\t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*2.2, 0.15));\n    propose(res, matID, outerRing2, 2);\n    \n    float smallRing1 = subtractionDist(\n        \t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*2.875, 0.125),\n    \t\t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*2.725, 0.15));\n    float t1 = iTime / 5.0;\n    float angle1 = 110.0 + 150.0 * abs(cos(5.0*t1)*cos(t1) + sin(2.0*t1)*cos(0.5*t1))/ 2.0;\n    float cone1 = cone(rX(p - vec3(0, (1.0 + heightOffset) * height, 0) - vec3(0, 0.75 * height, 0),\n                          angle1),\n                       1.0, 0.75*height);\n    float plane1 = plane(rX(p - vec3(0, (1.0 + heightOffset) * height, 0) - vec3(0, 0.75 * height, 0.0), angle1), 0.0);\n    //propose(res, matID, intersectionDist(cone1, plane1), 2);\n    propose(res, matID, intersectionDist(smallRing1, intersectionDist(cone1, plane1)), 2);\n    \n    float smallRing2 = subtractionDist(\n        \t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*1.875, 0.125),\n    \t\t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 360.0 * ratio), \n                                    90.0),\n                                    ratio*1.725, 0.15));\n    float t2 = iTime / 6.5;\n    float angle2 = -110.0 + 230.0 * abs(cos(2.0*t2)*cos(4.5*t2) + sin(2.25*t2)*cos(0.25*t2) + 0.5)/ 2.0;\n    float cone2 = cone(rX(p - vec3(0, (1.0 + heightOffset) * height, 0) - vec3(0, 0.75 * height, 0),\n                          angle2),\n                       1.0, 0.75*height);\n    float plane2 = plane(rX(p - vec3(0, (1.0 + heightOffset) * height, 0) - vec3(0, 0.75 * height, 0.0), angle2), 0.0);\n    //propose(res, matID, intersectionDist(cone2, plane2), 2);\n    propose(res, matID, intersectionDist(smallRing2, intersectionDist(cone2, plane2)), 2);\n    \n    float ballBottom = subtractionDist(\n        \t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 180.0 * ratio), \n                                    90.0),\n                                    ratio*1.5, 0.05),\n    \t\t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 + 180.0 * ratio), \n                                    90.0),\n                                    ratio*0.725, 0.1));\n    propose(res, matID, intersectionDist(ballBottom, plane(p, (1.75 + heightOffset) * height - 0.1)), 2);\n\n    float ballTop = subtractionDist(\n        \t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 - 180.0 * ratio), \n                                    90.0),\n                                    ratio*1.5, 0.05),\n    \t\t\t\t\t   cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 - 180.0 * ratio), \n                                    90.0),\n                                    ratio*0.725, 0.1));\n    propose(res, matID, intersectionDist(ballTop, -plane(p, (1.75 + heightOffset) * height + 0.1)), 2);\n    \n    const float ROT_STEP = 1.5;\n    const float ROT_REST = 1.0;\n    float rotOffset = 180.0 * sin(PI / 2.0 * min(ROT_STEP, mod(distTime, ROT_STEP + ROT_REST)) / ROT_STEP);\n    if (mod(floor(distTime / (ROT_STEP + ROT_REST)), 3.0) < 2.0) {\n        rotOffset = 180.0 + rotOffset;\n    } else {\n        rotOffset = 360.0 - 2.0 * rotOffset;\n    }\n    propose(res, matID, cylinder(rX(rY(p - vec3(0, (1.75 + heightOffset) * height, 0),\n                                       90.0 - 720.0 * ratio + rotOffset), \n                                    90.0),\n                                    ratio*0.5, 0.05), 2);\n\n    \n    \n    return res;\n}\n\n\n// Lighting\nfloat directionalLightDiffuse(vec3 nor, vec3 ldir) {\n    return clamp01(dot(nor, -ldir));\n}\n\n// Coloring different materials\nvec3 sky(vec3 dir) {\n    return mix(vec3(0.25, 0.85, 0.5),\n               vec3(0.25, 0.2, 0.75),\n               (dir.y+1.0)/2.0);\n}\n\nvec3 ground(vec3 p) {\n    return texture(iChannel1, p.xz/5.0).xyz;\n}\n\nvec3 LIGHT_DIR = vec3(-0.577);\n\nvec3 computeColor(Ray ray) {\n    vec3 col = vec3(0.0);\n    \n    // Default lighting\n    float sunLight = directionalLightDiffuse(ray.nor, LIGHT_DIR);\n    \n    // Switch on matID\n    // a return -> different/no lighting\n    // no return -> default lighting\n \tif (ray.matID == 0) {\n    \treturn sky(ray.dir);\n    } else if (ray.matID == 1) {\n        col = ground(ray.pos);\n    } else if (ray.matID == 2) {\n        col = vec3(0.345, 1.0, 1.0);\n        col = mix(vec3(0.133, 0.294, 0.784), col, sunLight);\n    }\n\n    col = col;//* sunLight + 0.1;\n    \n    return col;\n}\n\nvec3 calculateNormal(vec3 pos, vec3 timers) {\n    const vec3 e = vec3(EPS, 0.0, 0.0);\n\tfloat p = map(pos, junkMatID, timers);\n\treturn normalize(vec3(map(pos + e.xyy, junkMatID, timers) - p,\n           \t\t\t\t  map(pos + e.yxy, junkMatID, timers) - p,\n                          map(pos + e.yyx, junkMatID, timers) - p));\n}\n\nvec3 raymarch(inout Ray ray, vec3 timers) {\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        h = map(ray.src + t*ray.dir, ray.matID, timers);\n        t += h;\n        ray.iter = i;\n        if (t > TMAX || h < DIST_THRESHOLD) break;\n    }\n    ray.t = t;\n    ray.pos = ray.src + ray.t*ray.dir;\n    ray.nor = calculateNormal(ray.pos, timers);\n    int missed = int(step(TMAX, ray.t));\n    ray.matID = (1- missed) * ray.matID;\n    ray.nor *= float(1-missed);\n    return computeColor(ray);\n}\n\nvec4 render(Ray ray, vec3 timers) {\n    vec3 res = raymarch(ray, timers);\n    float t1 = mix(ray.t, TMAX, step(float(ray.matID), 0.5));\n    \n    return vec4(clamp01(res), t1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0+2.0*uv; \t\t\t\t\t\t// Pixel space of the focal plane\n\tp.x *= iResolution.x/iResolution.y;\n    \n    Ray ray;\n    ray.pos = vec3(0.0);\n    ray.nor = vec3(0.0);\n    ray.matID = 0;\n    ray.t = 0.0;\n    \n\t// camera\n\tvec3 playerPos = texture(iChannel0, (txPlayerPos+0.5)/iChannelResolution[0].xy).xyz;\n\tfloat d = 5.5; \t\t\t\t\t\t\t\t// Distance between eye and focal plane\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0.5, 0.529);\n    }\n    vec3 w = normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n    vec3 u = normalize(cross(w,UP));\n\tvec3 v = normalize(cross(u,w));\n    ray.dir = normalize(p.x*u + p.y*v + d*w);\n    ray.src = playerPos;\n    \n    float cubeTime = texture(iChannel0, (txTimers+0.5)/iChannelResolution[0].xy).x;\n\tfloat growTime = texture(iChannel0, (txTimers+vec2(1, 0)+0.5)/iChannelResolution[0].xy).x;\n\tfloat distTime = texture(iChannel0, (txTimers+vec2(2, 0)+0.5)/iChannelResolution[0].xy).x;\n\n\tvec3 timers = vec3(cubeTime, growTime, distTime);\n    \n\tfragColor = render(ray, timers);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\tPlayer Movement\n\t\n\tThis buffer keeps track of the players position and velocity.\n\n\tPressing a key will set your goal velocity, and you will accelerate towards that\n\tvelocity non-linearly for smooth starts and stops.\n\n\tWASD to move\n\tE/C to go up/down\n\n**/\n// Math constants\nconst float PI = 3.14159265359;\nconst float EPS = 0.0001;\n\n// Texel addresses\nconst vec2 txPlayerPos = vec2(0.0,0.0);\nconst vec2 txPlayerVel = vec2(1.0,0.0);\nconst vec2 txTimers = vec2(2.0,0.0);\n\n// Texel storage constants\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_S  = 83.5/256.0;\nconst float KEY_D  = 68.5/256.0;\n\nconst float KEY_E  = 69.5/256.0;\nconst float KEY_C  = 67.5/256.0;\n\n// Other constants\nconst float PLAYER_HEIGHT = 1.0;\nconst float VEL_MAG = 50.0;\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\n// Render buffer helpers\nvec4 loadValue(in vec2 re) {\n    return texture(iChannel0, (0.5 + re)/iChannelResolution[0].xy, -100.0);\n}\n\nfloat isInside(vec2 p, vec2 c) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\n\nvoid storeValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 5.0 || fragCoord.y > 1.0) discard;\n    \n    vec3 playerPos = loadValue(txPlayerPos).xyz;\n    vec3 playerVel = loadValue(txPlayerVel).xyz;\n    float cubeTime = loadValue(txTimers).x;\n    float growTime = loadValue(txTimers + vec2(1, 0)).x;\n    float distanceTime = loadValue(txTimers + vec2(2, 0)).x;\n    \n    // Reset position at beginning or if 1/2/3 is pressed\n    if(iFrame == 0) {\n        const float OFFSET = 30.0;\n        playerPos = vec3(OFFSET, PLAYER_HEIGHT, 0.0);\n        playerVel = vec3(0);\n        distanceTime = 0.0;\n    }\n    \n    vec3 goalVelocity = vec3(0.0);\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0.5, 0.529);\n    }\n    vec3 w = normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n\tvec3 u = normalize(cross(w,UP));\n    \n    float s = 1.0;\n    \n    // WASD/arrow key movement\n    if (texture(iChannel1, vec2(KEY_UP, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_W, 0.25)).x > 0.5) {\n        goalVelocity += s*VEL_MAG*w;\n    }\n    if (texture(iChannel1, vec2(KEY_DOWN, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_S, 0.25)).x > 0.5) {\n        goalVelocity += -s*VEL_MAG*w;\n    }\n    if (texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_D, 0.25)).x > 0.5) {\n        goalVelocity += s*VEL_MAG*u;\n    }\n    if (texture(iChannel1, vec2(KEY_LEFT, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_A, 0.25)).x > 0.5) {\n        goalVelocity += -s*VEL_MAG*u;\n    }\n    \n    // E,Q for up/down\n    if (texture(iChannel1, vec2(KEY_E, 0.25)).x > 0.5) {\n        goalVelocity += s*VEL_MAG*UP;\n    }\n    if (texture(iChannel1, vec2(KEY_C, 0.25)).x > 0.5) {\n        goalVelocity -= s*VEL_MAG*UP;\n    }\n    \n    vec3 accel = 15.0*(goalVelocity - playerVel);\n    \n    playerVel = playerVel + accel * iTimeDelta;\n    playerPos += playerVel * iTimeDelta;\n    \n    if (playerPos.y < PLAYER_HEIGHT) {\n        playerPos.y = PLAYER_HEIGHT + EPS;\n        playerVel.y = 0.0;\n    }\n    \n    if (dot(playerPos.xz, playerPos.xz) < 25.0*25.0) {\n        cubeTime += iTimeDelta;\n        cubeTime = min(0.25, cubeTime);\n        growTime += iTimeDelta;\n        growTime = min(0.5, growTime);\n        distanceTime += iTimeDelta;\n    } else {\n        cubeTime -= 2.0 * iTimeDelta;\n        growTime -= 2.0 * iTimeDelta;\n        distanceTime -= 2.0 * iTimeDelta;\n        cubeTime = max(0.0, cubeTime);\n        growTime = max(0.0, growTime);\n        distanceTime = max(0.0, distanceTime);\n    }\n    \n    fragColor = vec4(0.0); \n    storeValue(txPlayerPos, vec4(playerPos,0.0), fragColor, fragCoord);\n    storeValue(txPlayerVel, vec4(playerVel,0.0), fragColor, fragCoord);\n    storeValue(txTimers, vec4(cubeTime), fragColor, fragCoord);\n    storeValue(txTimers + vec2(1, 0), vec4(growTime), fragColor, fragCoord);\n    storeValue(txTimers + vec2(2, 0), vec4(distanceTime), fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"}]}