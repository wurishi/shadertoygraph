{"ver":"0.1","info":{"id":"ldt3zj","date":"1451034783","viewed":504,"name":"Shifting Rock","username":"hanmaokun","description":"A steal and composition of guil's \"Rocky Coast\" and Malhar's \"Shifting Islands\", with a view angle of looking straight down from up. I had to say I am no expert on CG, and don't really understand the alg inside, but this awesome community makes it easy :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","sea","rock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define CHANGE_SPEED \t0.06\t\t\t/* terrain changing speed */\n\nconst float scope = 2.2;\n\nfloat dh = 0.;\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\n/*\n * shifting terrain model\n *\n * steal from Malhar's work: \"Shifting Islands\".\n * (https://www.shadertoy.com/view/MsBSDW)\n */\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec2 pos)\n{\n  vec3 v = vec3(pos * 0.6, iTime * CHANGE_SPEED);\n\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  float result = 50.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n\n  return result;\n}\n\n/*\n * main scene model.\n *\n * steal from guil's work: \"Rocky coast\".\n * (https://www.shadertoy.com/view/ltlGDX)\n */\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ )\n\t{\n        p=m2*p*f+.6;\n        f*=1.2;\n        res+=sin(p.x+sin(2. * p.y));\n\t}\n\treturn res/3.;\n}\n\nfloat fbmabs( vec2 p ) {\n\tp *= 0.5;\n\tfloat f=1.;\n\tfloat r = 0.0;\n    for(int i = 0;i<8;i++){\n\t\tr += abs(snoise( p*f ))/f;\n\t    f *=2.;\n        p-=vec2(.01,.01)*r;\n\t}\n\treturn r;\n}\n\nfloat sea( vec2 p )\n{\n\tfloat f = 1.;\n\tfloat r = 0.0;\n    for(int i = 0; i<8; i++){\n\t\tr += (1.-abs(noise( p*f -.12*iTime)))/f;\n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r/4.+.5;\n}\n\nfloat rocks(vec2 p){\n    return 1.35*fbmabs(p);\n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-.4*fbmabs(scope*p.xz);\n\tfloat d2 =p.y-.4*sea(scope*p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\n\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .05,//.008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\n\treturn sin(vec3(1.7,1.5,1)+1. + .45*fbmabs(p*4. - .02*iTime));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n/*\n * main entry.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n\n    vec3 li = normalize(vec3(-2., 2., -2.));\n\n    /*\n     * world coordinates calc.\n     * according to 'http://9bitscience.blogspot.jp/2013/07/raymarching-distance-fields_14.html';\n     * this is looking straight down from 'up'.\n     */\n\tvec3 right = vec3(1, 0, 0);\n\tvec3 front = vec3(0, 0, 1);\n\tvec3 ro = right * p.x + front * p.y;\n\tro.y += 1.0;\n\tvec3 rd = normalize(cross(right, front));\n\n\t/*\n\t * raymarching.\n\t */\n    float t = march(ro, rd);\n\n    if(t > -0.001)\n    {\n        if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n\n        float k=rocks(scope*pos.xz);\n\n        vec3 nor = normalRocks(scope*pos.xz);\n        float r = max(dot(nor, li), 0.05)/2.;\n        if(dh < 0. && dh > -.08) r+=.5*exp(20. * dh);\n\n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.08){\n        \tvec3 nor = normalSea(scope*pos.xz);\n        \tnor = reflect(rd, nor);\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.yz);\n        }\n\t    col = .1+col1;\n\n\t}\n\n   \tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}