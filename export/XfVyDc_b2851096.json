{"ver":"0.1","info":{"id":"XfVyDc","date":"1732485582","viewed":13,"name":"Raymarching Pathtracing Plane","username":"Longingly","description":"A demo shader i made for practice","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfSphere(vec3 p, float size) {\n    return length(p) - size;\n}\n\nvec3 normalSphere(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\nfloat sdfPlane(vec3 p, float planeY) {\n    return p.y - planeY;\n}\n\nvec3 normalPlane(vec3 p) {\n    return vec3(0.0, 1.0, 0.0); // Normal of the plane is constant\n}\n\nfloat sdfCube(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float c = cos(angle);\n    float s = sin(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        vec3(c + axis.x * axis.x * oc, axis.x * axis.y * oc - axis.z * s, axis.x * axis.z * oc + axis.y * s),\n        vec3(axis.y * axis.x * oc + axis.z * s, c + axis.y * axis.y * oc, axis.y * axis.z * oc - axis.x * s),\n        vec3(axis.z * axis.x * oc - axis.y * s, axis.z * axis.y * oc + axis.x * s, c + axis.z * axis.z * oc)\n    );\n}\n\nfloat improvedSine(float seed, float a, float b) {\n    return mix(a, b, (sin(iTime * seed) + 1.0) * 0.5);\n}\n\nfloat improvedCosine(float seed, float a, float b) {\n    return mix(a, b, (cos(iTime * seed) + 1.0) * 0.5);\n}\n\nvec4 map(vec3 p) {\n    // Return type: r, g, b, distance\n    vec4 result = vec4(vec3(0.0), 9999.0);\n\n    const int NUM_SPHERES = 3;\n    vec3 spherePositions[NUM_SPHERES];\n    float sphereSizes[NUM_SPHERES];\n    vec3 sphereColors[NUM_SPHERES];\n\n    spherePositions[0] = vec3(1.0, 0.0, 0.5);\n    sphereSizes[0] = 0.5;\n    sphereColors[0] = vec3(1.0, 0.0, 0.0);\n\n    spherePositions[1] = vec3(-1.0, 0.0, 1.0);\n    sphereSizes[1] = 0.5;\n    sphereColors[1] = vec3(0.0, 1.0, 0.0);\n\n    spherePositions[2] = vec3(2.0, 0.0, 1.5);\n    sphereSizes[2] = 0.5;\n    sphereColors[2] = vec3(0.0, 0.0, 1.0);\n\n    float planeY = -1.0;\n    float planeDist = sdfPlane(p, planeY);\n\n    // Loop through spheres\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        vec3 spherePos = spherePositions[i];\n        spherePos.x += sin(iTime + float(i)); // Animate sphere positions\n        float sdf = sdfSphere(p - spherePos, sphereSizes[i]);\n        if (sdf < result.w) {\n            result.w = sdf;\n            result.xyz = sphereColors[i];\n        }\n    }\n\n    // Check plane after spheres\n    if (planeDist < result.w) {\n        result.w = planeDist;\n        result.xyz = vec3(-1); // Color of a reflective surface\n    }\n\n    return result;\n}\n\nvec3 bouncePlane(vec3 bouncePoint, vec3 rayDir, vec3 rayOrigin) {\n    vec3 normal = normalPlane(bouncePoint);\n    vec3 bounceIn = rayDir;\n    vec3 bounceOut = reflect(bounceIn, normal);\n\n    vec3 ro = bouncePoint + normal * 0.001; // Offset to prevent self-intersection\n    vec3 rd = bounceOut;\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n\n    float minimumD = 0.1;\n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        vec4 a = map(p);\n\n        float d = a.w;\n        if (i == 0 && a.w < minimumD) {\n            d = minimumD;\n        }\n\n        t += d;\n        col = a.xyz;\n\n        if (d < 0.001) break;\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = vec3(0.0);\n\n    float t = 0.0;\n    bool hitPlane = false;\n    vec3 bouncePoint;\n\n    int i = 0;\n    for (i = 0; i < 160; i++) {\n        vec3 p = ro + rd * t;\n        vec4 a = map(p);\n        float d = a.w;\n\n        t += d;\n        col = a.xyz;\n\n        // Check if the ray hits the plane\n        if (d < 0.001 && a.xyz == vec3(-1)) {\n            hitPlane = true;\n            bouncePoint = p;\n            break;\n        }\n\n        if (d < 0.001) break;\n    }\n    \n    if (i > 40) col = vec3(0.200,0.200,0.200);\n\n    // Handle reflection from the plane\n    if (hitPlane) {\n        vec3 reflectedCol = bouncePlane(bouncePoint, rd, ro);\n        col = mix(reflectedCol, vec3(0.753,0.753,0.753), .7);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}