{"ver":"0.1","info":{"id":"MfjGWz","date":"1704111309","viewed":44,"name":"BrotTest1","username":"steveroome","description":"mandelbrot testing","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["mandelbrottesting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Steve Roome 20240101 : Beerware/if you want to use this code in your own code: you might be mad, but sure, reference this.\n\n// I thought I should try and remember how shaders work... re-learning stuff.\n\n// TODO: save state (into another texture) that we can use in future frames\n// make keyboard controls do something useful.\n\n// Pressing any of these keys highlights one triangle around the origin in both the camera and brot frame of reference\n\n// i.e. when the two darker regions line up the brot isn't rotated.\n\n// Changelog:\n// 20240101 AM, wrote it.\n// 20240101 PM,\n//  added smooth mandelbrot iteration value,\n//  which is just iter += 1.0-log(log2(abs(sqrt( magnitude(lastpos) )))\n//  tbh, it's annoying to have to sqrt something, but the rest is a mess anyway\n\n\nconst int KB_LEFT  = 37;\nconst int KB_UP    = 38;\nconst int KB_RIGHT = 39;\nconst int KB_DOWN  = 40;\n\n#define iskeydown(KEYNUM) vec4(texelFetch( iChannel0, ivec2(KEYNUM,0), 0 )).x\n\nvec2 rot2(in vec2 A, in float theta) {\n  return vec2(cos(theta)*A.x - sin(theta)*A.y, sin(theta)*A.x + cos(theta)*A.y);\n}\n\nvec4 brot(vec2 pos) { // Mandelbrot colour from vec2\n  int iter;\n  vec2 p, start;\n  start = p = pos;\n\n  const int maxiter=200;\n  \n  float ysq, tmpx, xsq, rsq;\n  for (iter=0;iter<maxiter;iter++) {\n  \n    ysq  = p.y * p.y;\n    tmpx = p.x;\n    xsq  = p.x * p.x;\n    rsq  = xsq + ysq;\n    \n    p.x = start.x + xsq - ysq;\n    p.y = start.y + (2.0 * tmpx * p.y);\n       if (rsq>1e5) break;\n \n  }\n  \n  // iter=maxiter-iter;\n  \n  float fiter = (rsq>4.0) ? 1.0 + log(log2(distance(p, vec2(0.0)))) : 0.0;\n  \n\n  fiter =cos(0.0232 * (float(iter) - fiter));\n   \n  float grn = .6*sin(13.0*fiter);\n  float blu = .4*sin(38.0*fiter);\n  float red = .8*sin(7.0*fiter);\n  return vec4(red,grn,blu, 1.0);\n}\n\nfloat grid(in vec2 pos, int tics) {\n   float dg = float(tics);\n   float xt = abs(distance(pos.x*dg, round(pos.x*dg)));\n   float yt = abs(distance(pos.y*dg, round(pos.y*dg)));\n   return pow(max(xt,yt),3.0);\n}\n\nfloat arrowcol(in vec2 uv) {\n    float col;\n\n    col = max(col, ((uv.y>-uv.x) && (uv.y<uv.x)) ? iskeydown(KB_RIGHT) : 0.0);   \n    col = max(col, ((uv.y>uv.x) && (uv.y<-uv.x)) ? iskeydown(KB_LEFT)  : 0.0);\n    col = max(col, ((uv.x>-uv.y) && (uv.x<uv.y)) ? iskeydown(KB_UP)    : 0.0);\n    col = max(col, ((uv.x>uv.y) && (uv.x<-uv.y)) ? iskeydown(KB_DOWN)  : 0.0);\n    return (1.0- col*0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar= min(iResolution.x,iResolution.y);\n    vec2 aruv = (fragCoord-0.5*iResolution.xy)/ar; // ta Fabrice.\n    vec2 uv = rot2(aruv*(1.5+0.5*cos(iTime/3.0)), iTime/5.0);\n    \n    float grid1= grid(uv,10);\n    float grid2= grid(uv,1);\n    float gg = pow((grid1+grid2)/2.0,5.0);\n    fragColor= arrowcol(uv)*arrowcol(aruv)*max(brot(uv), vec4((grid1+grid2)/2.0 , grid1, gg,1.0));\n}\n","name":"Image","description":"","type":"image"}]}