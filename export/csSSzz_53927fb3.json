{"ver":"0.1","info":{"id":"csSSzz","date":"1669784739","viewed":195,"name":"Regular Hyperbolic Tessellations","username":"diabolix17","description":"See code for different options. Click to move around. I adapted an older shader with triangle tessellations to tessellate with arbitrary regular polygons instead. Was surprised by how little code is required.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["tiling","tessellation","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Color schemes:\n// 0 is \"wireframe\",\n// 1 is a texture generated by the function \"tex\" (generates the effect you see by default),\n// 2 is the texture in iChannel0.\n// There is an add-on for Firefox and Chrome that allows you to use custom textures.\n// You can make some really nice faux Escher tilings with that.\n#define COLOR_SCHEME 1\n\n// The Schl√§fli symbol of the tessellation.\n// P is the number of sides of the polygon and Q is the number of polygons meeting at each vertex.\n// As long as 1/P + 1/Q < 1/2 the tiling will exist.\n#define P 7\n#define Q 3\n\n// Uncomment to see the Beltrami or upper half plane models instead\n//#define BELTRAMI\n//#define UPPER_HALF_PLANE\n\n// Multisampling with SAMPLES^2 samples\n#define SAMPLES 2\n\n// Uncomment to show the edges of the polygons\n#define EDGE_OVERLAY\n#define EDGE_THICKNESS 0.01\n\n// -------------------------------------------------------------------------------------\n\n#define PI 3.141592653\n#define MAX_ITER 100\n\n// Complex number functions\nvec2 conj(vec2 a){\n    return vec2(a.x,-a.y);\n}\n\nvec2 comp_mul(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 comp_inv(vec2 a){\n    return vec2(a.x, -a.y) / dot(a,a);\n}\n\nvec2 comp_div(vec2 a, vec2 b){\n    return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y));\n}\n\n\n// There is a unique hyperbolic translation that takes m to the origin.\n// This function applies that translation to p.\nvec2 map_to_origin(vec2 m, vec2 p){\n    return comp_div(p-m, comp_mul(-conj(m), p) + vec2(1.0,0.0));\n}\n\nvec2 line_intersection(vec2 P1, vec2 d1, vec2 P2, vec2 d2){\n    float det = d2.x*d1.y - d1.x*d2.y;\n    if(det == 0.0){\n        return vec2(0.0);\n    }\n    float det1 = (P2-P1).y*d2.x - d2.y*(P2-P1).x;\n    float l1 = det1 / det;\n    return P1 + l1*d1;\n}\n\n// compute the circle (center and radius) corresponding to the hyperbolic line through a and b\nvec3 hyp_line_circle(vec2 a, vec2 b){\n    vec2 a1 = comp_inv(conj(a));\n    vec2 b1 = comp_inv(conj(b));\n    \n    vec2 p1 = 0.5*(a+a1);\n    vec2 p2 = 0.5*(b+b1);\n    \n    vec2 c = line_intersection(p1,vec2(-a1.y,a1.x),p2,vec2(-b1.y,b1.x));\n    float r = length(a - c);\n    return vec3(c,r);\n}\n\nvec2 circle_inversion(vec2 p, vec3 circle){\n    return circle.z*circle.z*comp_inv(conj(p-circle.xy)) + circle.xy;\n}\n\nvec2 beltrami_to_poincare(vec2 p){\n    float z = sqrt(1.0 - dot(p,p));\n    float alpha = 1.0/(z+1.0);\n    return alpha * p;\n}\n\nvec2 upper_half_plane_to_poincare(vec2 p){\n    p += vec2(0.0,1.0);\n    return comp_div(p - vec2(0.0,1.0), p + vec2(0.0,1.0));\n}\n\nvec4 tex( vec2 tex_coords )\n{\n    float shade = 1.0 - length(tex_coords);\n    return vec4(0.5*shade, shade, 0.5*shade, 1.0);\n}\n\nvec4 shader(vec2 uv){\n    float p = float(P);\n    float q = float(Q);\n\n    if(1.0/p + 1.0/q >= 0.5){\n        return vec4(0.0, 0.0, 1.0, 1.0);\n    }\n    \n    vec2 coords = 2.0*uv-vec2(1.0);\n    coords.x *= iResolution.x / iResolution.y;\n\n#ifndef UPPER_HALF_PLANE\n    if(length(coords) >= 1.0){\n        return vec4(0.3, 0.0, 0.2, 1.0);\n    }\n#endif\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = 2.0*mouse - vec2(1.0);\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    // the beauty of a fragment shader: to apply any transformation whatsoever to the output image, we can\n    // simply apply the inverse transformation to the coordinates at the beginning without changing anything else\n    \n#ifdef BELTRAMI\n    coords = beltrami_to_poincare(coords);\n    mouse = beltrami_to_poincare(mouse);\n#endif\n\n#ifdef UPPER_HALF_PLANE\n    coords = upper_half_plane_to_poincare(coords);\n    mouse = upper_half_plane_to_poincare(mouse);\n#endif\n\n    if(length(mouse) < 1.0){\n        coords = map_to_origin(mouse,coords);\n    }\n    \n    // The following is the core procedure (rest is almost all bells and whistles). It's really quite simple.\n    // --------------------------------------------------------------------------------------------------\n    \n    // compute the radius of the polygon (length of line from origin to any vertex)\n    // using the hyperbolic law of cosines\n    float r = tanh(0.5*acosh((cos(PI/float(Q)) + cos(PI/float(Q))*cos(2.0*PI/float(P)))/(sin(PI/float(Q))*sin(2.0*PI/float(P)))));\n    \n    // compute the vertices of the polygon in the middle and the circles corresponding to its sides\n    vec2 vertices[P];\n    vec3 circles[P];\n    for(int i = 0; i < P; i++){\n        vertices[i] = r*vec2(cos(float(i)*2.0*PI/p),sin(float(i)*2.0*PI/p));\n    }\n    \n    for(int i = 0; i < P; i++){\n        circles[i] = hyp_line_circle(vertices[i], vertices[(i+1) % P]);\n    }\n\n    // test for each side of the polygon whether the current coordinate is in the correct half-space\n    // if not, reflect across that side (aka invert in the circle corresponding to it)\n\n    bool inside;\n    int iter = 0;\n\n    while(!inside && iter < MAX_ITER){\n        \n        inside = true;\n\n        for(int i = 0; i < P; i++){\n        \n            if(length(coords - circles[i].xy) < circles[i].z){\n                inside = false;\n                coords = circle_inversion(coords, circles[i]);\n                iter++;\n            }\n        }\n    }\n    // ---------------------------------------------------------------------------------------------------\n    \n    if(COLOR_SCHEME == 0){\n        \n        for(int i = 0; i < P; i++){\n            if(abs(length(coords-circles[i].xy) - circles[i].z) < EDGE_THICKNESS){\n                return vec4(0.0, 0.0, 0.0, 1.0);\n            }\n        }\n    \n        return vec4(1.0);\n    }\n    \n    vec4 color;\n\n    vec2 tex_coords = coords / r;\n    \n    if(COLOR_SCHEME == 1){\n        color = tex(tex_coords);\n    }\n    \n    if(COLOR_SCHEME == 2){\n        color = texture(iChannel0, tex_coords);\n    }\n\n#ifdef EDGE_OVERLAY\n    for(int i = 0; i < int(P); i++){\n        if(abs(length(coords-circles[i].xy) - circles[i].z) < EDGE_THICKNESS){\n            color = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n#endif    \n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixel_size = vec2(1.0/iResolution.x,1.0/iResolution.y);\n    uv -= pixel_size / 2.0;\n    vec2 pixel_inc = pixel_size / float(SAMPLES+1);\n    vec4 color = vec4(0.0);\n    for(int i = 1; i <= SAMPLES; i++){\n        for(int j = 1; j <= SAMPLES; j++){\n            color += shader(uv + float(i)*pixel_inc.x + float(j)*pixel_inc.y);\n        }\n    }\n    \n    fragColor = color/float(SAMPLES * SAMPLES);\n    \n}","name":"Image","description":"","type":"image"}]}