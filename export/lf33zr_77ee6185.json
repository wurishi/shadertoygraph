{"ver":"0.1","info":{"id":"lf33zr","date":"1711304415","viewed":207,"name":"Duck Song","username":"Hyeve","description":"MAKE SURE TO START THE MUSIC!!!\nPause the shader, hit the restart button (next to pause), then unpause.\n\nCreated for a MAJ7 cover ring event. See their full release here: https://www.youtube.com/watch?v=X-3qJXWv3Rw","likes":13,"published":1,"flags":96,"usePreview":1,"tags":["3d","raymarching","music","audio","duck","ducks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 fxaa(vec2 frag) {\n    //Manually minified FXAA antialiasing\n    \n    const float CONTRAST_THRESHOLD = 0.05;\n    const float RELATIVE_CONTRAST_THRESHOLD = 0.1;\n    const float OFFSETS[10] = float[10]( 1., 1., 1., 1.5, 2., 2., 2., 3., 4., 5. );\n    \n    #define re(x) texture(iChannel0, (x)/iResolution.xy)\n    #define lu(x) (x.r*.2126+x.g*.7152+x.b*.0722)\n    #define rl(x) lu(re((x)))\n    #define r(x, y) rl(frag+vec2(x,y))\n    \n    float M = r(0,0),N =r(0,1),NE=r(1,1),E =r(1,0),SE=r(1,-1),S =r(0,-1),SW=r(-1,-1),W =r(-1,0),NW=r(-1,1),\n    LC=min(N,min(E,min(S,min(W,M)))),HC=max(N, max(E, max(S, max(W, M)))),CT=HC-LC;\n    if(CT<max(CONTRAST_THRESHOLD,RELATIVE_CONTRAST_THRESHOLD*HC)) return re(frag);\n    \n    float LA = smoothstep(0.,1.,clamp(0.,1., abs((2.*(N+E+S+W)+NE+NW+SE+SW)*(1./12.)-M)/CT));\n\tbool IH = abs(N+S-2.*M)*2.+abs(NE+SE-2.*E)+abs(NW+SW-2.*W)>abs(E+W-2.*M)*2.+abs(NE+NW-2.*N)+abs(SE+SW-2.*S);\n    \n    float PL=IH?N:E,NL=IH?S:W,PG=abs(PL-M),NG=abs(NL-M),DR=1.,GR,OL;\n\n    OL=PL;GR=PG;\n\tif (PG<NG) {DR=-1.0;OL=NL;GR=NG;}\n\n    vec2 EF=frag,ES=vec2(0,1);EF.x+=.5*DR;\n    if(IH){EF.y+=.5*DR;ES=vec2(1,0);}\n    \n    float EL=(M+OL)*.5,GT=GR*.25;\n\tvec2 PF=EF+ES,NF=EF-ES,FO=vec2(0.);\n\tfloat PLD=rl(PF)-EL,NLD=rl(NF)-EL;\n\tbool PE=abs(PLD)>=GT,NED=abs(NLD)>=GT;\n    int i;\n    for(i=0;i<10&&!PE;i++){PF+=ES*OFFSETS[i];PLD=rl(PF)-EL;PE=abs(PLD)>=GT;}\n    for(i=0;i<10&&!NED;i++){NF-=ES*OFFSETS[i];NLD=rl(NF)-EL;NED=abs(NLD)>=GT;}\n    \n    float PD=PF.y-frag.y,ND=frag.y-NF.y,MD,EB=0.,BL;\n\tif(IH){PD=PF.x-frag.x;ND=frag.x-NF.x;}\n    MD=min(PD,ND);\n    bool DS=PD<=ND?PLD>=0.:NLD>=0.;\n\tif(DS!=(M-EL>=0.))EB=0.5-MD/(PD+ND);\n    BL=max(LA*LA,EB)*DR;\n\n\tif(IH)FO.y+=BL;\n\telse FO.x+=BL;\n    \n    return re(frag+FO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = fxaa(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldy3RR","filepath":"https://soundcloud.com/jneen-collective/abandoned-beach-snes-port-kirby-and-the-forgotten-land","previewfilepath":"https://soundcloud.com/jneen-collective/abandoned-beach-snes-port-kirby-and-the-forgotten-land","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--------- REACTIVE PARAMETERS ---------\nconst vec3 COL_A = vec3(1., 1., 1.);\nconst vec3 COL_B = vec3(1.35,1.2,0.45);\nconst vec3 COL_C = vec3(0.6, 0.8, 1.2);\n\nconst float SPEED_MULTIPLIER = 1.0; \nconst float AUDIO_RATE = 22050.0;\nconst float AUDIO_VOL = -2.;\nconst float GAMMA = 1.2;\n\n\n//--------- AUDIO INPUT --------- //Replace with real input!!\nvec2 spectrumAt(float x) {\n  float idx = 55.0 / AUDIO_RATE * 0.5 * pow(2.0, x);\n\n  if (x < 0. || idx > 1.0) return vec2(0);\n  \n  float fft = texture(iChannel0, vec2(idx, 0)).x;\n  \n  fft *= 2.0 * log(1.0 + x);\n  fft += AUDIO_VOL;\n  fft = max(0.0, fft);\n  fft *= 1.0 + idx;\n  \n  return vec2(fft); //Shadertoy only provides mono audio :(\n}\n\n\n//--------- SHADER GLOBALS ---------\nfloat TIME;\nvec2 UV;\nbool LIGHTING_PASS = false;\n\n\n//--------- GENERAL CONSTANTS ---------\nconst float MAX_SCENE_DEPTH = 80.;\nconst int MAX_SCENE_STEPS = 256;\nconst float MAX_SHADOW_DIST = 24.;\nconst int MAX_SHADOW_STEPS = 64;\nconst float HIT_DIST = 1e-4;\nconst float OFFSET_DIST = HIT_DIST * 2.;\nconst float SKIP_DIST = OFFSET_DIST * 3.;\nconst float VIGNETTE_STRENGTH = 0.8;\nconst float VIGNETTE_POWER = 5.;\n\n\n//--------- LIGHTING PARAMATERS ---------\nvec3 LIGHT_POS = vec3(0, 400, -800);\nfloat AMBIENT_BRIGHTNESS = 0.5;\nfloat FOG_ONSET = 60.;\nfloat FOG_SMOOTH = 30.;\nfloat FOG_POWER = 3.;\nfloat AO_DIST = 3.;\nfloat AO_POWER = 0.25;\nfloat SHADOW_SOFTNESS = 0.8;\nfloat SHADOW_STRENGTH = 0.3;\nfloat UMBRA_POINT = 0.5;\nfloat UMBRA_CONTRAST = 0.5;\nvec4 TONEMAP_VALUES = vec4(0.4, 0.9, 0.2, 999.);\nvec4 TONEMAP_HUESAT = vec4(1.5, 0.5, 0.5, 1.);\nfloat SUBSURF_DIST = 15.;\nfloat SUBSURF_BRIGHTNESS = 1.5;\nvec3 COLOR = vec3(0.);\nfloat GLOSS = 0.2;\nfloat SPECULAR = 0.2;\n\n\n//--------- JNEEN SPIRAL STUFF ---------\nvec2 spiralCoordinates(vec2 p) {\n    vec2 polar = vec2(length(p), atan(p.y, p.x)/6.286+.5);\n    float spiralRadius = floor(polar.x - polar.y) + polar.y;\n    float spiralDist = polar.x - spiralRadius;\n    return vec2(spiralDist, spiralRadius);\n}\n\nfloat adjustDist(float dist) {\n  dist -= .02;\n  if (dist < 0.) dist = -1.;\n  dist += .02;\n  return dist;\n}\n\nfloat positiveSpiralDist(vec2 spiral, float i) {\n  float relative = spiral.x + 2.*i;\n  return max(relative - adjustDist(spectrumAt(spiral.y-i).x), -relative);\n}\n\nfloat negativeSpiralDist(vec2 spiral, float i) {\n  float relative = -spiral.x + 2.*i;\n  return max(relative - adjustDist(spectrumAt(spiral.y+i).y), -relative);\n}\n\nfloat zeroSpiralDist(vec2 spiral) {\n  vec2 audio = spectrumAt(spiral.y);\n  float dist = spiral.x;\n  float outer = dist - adjustDist(audio.x);\n  float inner = -dist - adjustDist(audio.y);\n  if ((dist >= 0. && outer < 0.) || (dist < 0. && inner < 0.)) return max(outer, inner);\n  return dist >= 0. ? outer : inner;\n}\n\nfloat spectrumSpiral(vec2 p) {\n    vec2 spiral = spiralCoordinates(p * 20./(1.+3.*0.));\n    spiral.x *= 2.;\n    spiral.x -= 1.;\n    float d = zeroSpiralDist(spiral);\n    d = min(d, positiveSpiralDist(spiral, 1.));\n    d = min(d, positiveSpiralDist(spiral, 2.));\n    d = min(d, positiveSpiralDist(spiral, 3.));\n    d = min(d, positiveSpiralDist(spiral, 4.));\n    d = min(d, negativeSpiralDist(spiral, 1.));\n    d = min(d, negativeSpiralDist(spiral, 2.));\n    d = min(d, negativeSpiralDist(spiral, 3.));\n    d = min(d, negativeSpiralDist(spiral, 4.));\n    return d;\n}\n\nfloat renderSpiral(float dist) {\n  float o = step(0., -dist);\n  return clamp(mix(o, o * (1.-dist), .1),0.,1.);\n}\n\n\n//--------- GENERAL FUNCTIONS ---------\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define quantize(value, steps) (floor((value)*(steps))/(steps))\n\nfloat xor(float a, float b)\n{\n    return max(min(a,b), -max(a,b));\n}\n\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\nvec3 rgb_to_hsv(vec3 col) {\n    vec4 k = vec4(0., -1./3., 2./3., -1.),\n    p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g)),\n    q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    \n    float d = q.x - min(q.w, q.y);\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6. * d)), d / (q.x), q.x);\n}\n\n\nvec3 hsv_to_rgb(vec3 col) {\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(col.xxx + k.xyz) * 6. - k.www);\n    return col.z * mix(k.xxx, clamp(p - k.xxx, 0., 1.), col.y);\n}\n\nvec2 to_radial(vec2 xy) {\n    return vec2(length(xy), atan(xy.x,xy.y));\n}\n\nvec3 recolor(vec3 base_color, float diffuse, vec3 light_color, vec4 hs_params, vec4 v_params) {\n\n  vec3 base_hsv = rgb_to_hsv(base_color);\n  vec3 tinted_hsv = rgb_to_hsv(base_color * light_color);\n  float value = quantize(pow(max(diffuse * base_hsv.z  +v_params.z, 0.),v_params.x)*v_params.y,v_params.w);\n  float hueShiftLow = pow(max(0.5 - value * 0.5,0.), hs_params.x);\n  float hueShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.x);\n  float hueShiftDir = (base_hsv.x > .19 && base_hsv.x < .69) ? 1. : -1.; //Towards yellow / sunlight\n  float hueShift = (hueShiftLow + hueShiftHigh) * hs_params.y * hueShiftDir;\n  float hue = tinted_hsv.x + hueShift;\n  float satShift = pow(max(0.5 - value * 0.5, 0.), hs_params.z) * hs_params.w;\n  float sat = tinted_hsv.y + satShift * step(1e-3, tinted_hsv.y);\n  return hsv_to_rgb(vec3(hue,sat,value));\n}\n\nfloat smooth_min(float a, float b, float smoothing) {\n    float h = clamp(.5 + .5 * (b - a) / smoothing, 0., 1.);\n    return mix(b, a, h) - smoothing * h * (1. - h);\n}\n\nfloat sdf_box(vec3 pos, vec3 size) {\n    vec3 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\nfloat sdf_cylinder(vec3 pos, vec2 size) {\n    vec2 w = vec2(length(pos.xy) - size.x, abs(pos.z) - size.y);\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 tap_note(float n) {\n    vec2 audio = vec2(0);\n    for(int i = 0; i < 7; i++) {\n        audio += spectrumAt(n + float(i));\n    }\n    return audio / 8.;\n}\n\nvec2 mixed_aud(float x, float s) {\n    if(x < s) {\n        float a = x / s;\n        return mix(spectrumAt(8.), spectrumAt(0.), a);\n    }\n    else return spectrumAt(x);\n}\n\n\n//--------- SCENE FUNCTIONS ---------\nvec4 scene2d(vec2 uv) {\n    float spir = spectrumSpiral(uv-vec2(0.,0.001));\n    vec4 col = vec4(COL_A, 0.8) * renderSpiral(spir-.01);\n    col = mix(col, vec4(COL_A, 1.), renderSpiral(spectrumSpiral(uv)));\n    return col;\n}\n\n\nfloat duck(vec3 pos) {\n    float bb = sdf_box(pos - vec3(0.3, 1.2, 0.), vec3(3.8, 5., 3.4));\n    if(bb > 0.1 && !LIGHTING_PASS) return bb;\n    if(bb > 1.) return bb;\n    float head = length(pos - vec3(1.5, 2., 0.)) - 2.;\n    vec3 thinpos = pos;\n    thinpos.z *= 1.2;\n    float base = sdf_cylinder(thinpos.xzy, vec2(2., 0.)) - 1.5;\n    thinpos.z = abs(thinpos.z) - 2.5;\n    float wing = sdf_cylinder(thinpos.xzy - vec3(0.8, 0., 0.), vec2(1., 0.)) - 0.5;\n    float body = smooth_min(smooth_min(base, wing, 0.3), head, 0.3) * 0.8;\n    vec3 bpos = pos;\n    bpos.y -= 0.1 * pow(abs(bpos.z), 1.2);\n    if(bpos.y < 2.) bpos.x += 0.2;\n    float beak = sdf_cylinder(bpos.xzy - vec3(3.2, 0., 2.), vec2(0.7, 0.1)) - 0.2;\n    float beak_bump = length(bpos - vec3(3.2, 2., 0.)) - 0.6;\n    beak = smooth_min(beak, beak_bump, 0.3);\n    float beakness = clamp((body - beak + 0.1) * 25., 0., 1.);\n    float eyeness = 1.0 - smoothstep(-0.01, 0.01, length(thinpos - vec3(3., 3., -1.)) - 0.4);\n    float pupilness = 1.0 - smoothstep(-0.01, 0.01, length(thinpos - vec3(3., 2.95, -1.1)) - 0.2);\n    vec3 dcol = mix(COL_B, vec3(1.,0.55,0.15), beakness);\n    dcol = mix(dcol, vec3(0.), eyeness);\n    dcol = mix(dcol, vec3(1.), pupilness);\n    float dd = smooth_min(body, beak, 0.3);\n    if(dd < 0.01) COLOR = dcol;\n    return dd;\n}\n\n\nfloat scene(vec3 pos)\n{\t\t   \n    \n    \n    float ocean = pos.y + 4.;\n   \n\n    if(!LIGHTING_PASS) {\n\n        vec2 osp1 = pos.xz + vec2(sin(TIME * 0.1), sin(TIME * 0.05)) * 3.;\n        vec2 osp2 = pos.xz + vec2(20, -30) + vec2(cos(TIME * 0.1), sin(TIME * 0.05)) * 7.;\n        vec2 osp3 = pos.xz - vec2(35, 21) + vec2(cos(TIME * 0.05), cos(TIME * 0.1)) * 7.;\n        \n        const float PI = 3.1415926535;\n        const float TAU = (PI * 2.0);\n        \n        float r1 = (to_radial(osp1).y + PI) / TAU;\n        vec2 a1 = mixed_aud(pow(r1, 0.2) * 8., 0.1);\n        float s1 = a1.x;\n        \n        float r2 = (to_radial(osp2).y + PI) / TAU;\n        vec2 a2 = mixed_aud(pow(r2, 0.2) * 8., 0.1);\n        float s2 = a2.x;\n        \n        float r3 = (to_radial(osp3).y + PI) / TAU;\n        vec2 a3 = mixed_aud(pow(r3, 0.2) * 8., 0.1);\n        float s3 = a3.x;\n\n        float osd1 = length(osp1) + s1;\n        float osd2 = length(osp2) + s2;\n        float osd3 = length(osp3) + s3;\n        osd1 += sin(osd1 * 5.);\n        osd2 += cos(osd2 * 3.);\n        osd3 += cos(osd3 * 2. + 0.5); \n        float osd4 = xor(osd1, xor(osd2, osd3));\n        float foam = pow(fract(osd4 * 0.05 - TIME * 0.1), 2.);\n        \n        COLOR = mix(COL_C, COL_A, round(foam));\n    }\n    \n    float scene_dist = ocean;\n   \n    float N1 = 1. / 8.;\n    float N2 = 2. / 8.;\n    float N3 = 3. / 8.;\n    float N4 = 4. / 8.;\n    float N5 = 5. / 8.;\n    float N6 = 6. / 8.;\n    float N7 = 7. / 8.;\n    float N8 = 8. / 8.;\n    \n    float bounce = 3.;\n    \n    vec2 a1 = tap_note(N1) * bounce;\n    vec2 a2 = tap_note(N2) * bounce;\n    vec2 a3 = tap_note(N3) * bounce;\n    vec2 a4 = tap_note(N4) * bounce;\n    vec2 a5 = tap_note(N5) * bounce;\n    vec2 a6 = tap_note(N6) * bounce;\n    vec2 a7 = tap_note(N7) * bounce;\n    vec2 a8 = tap_note(N8) * bounce;\n    \n    float T1 = TIME;\n    float T2 = TIME * 0.9;\n    float T3 = TIME * 0.8;\n    float T4 = TIME * 0.7;\n    float T5 = TIME * 0.6;\n    float T6 = TIME * 0.5;\n    \n    \n    vec3 dp1 = rotate(pos + vec3(7., 3.5 + a4.x, 10.), vec3(cos(T4)*0.05, cos(T3) * 0.22 - 1., sin(T1)*0.05));\n    scene_dist = min(scene_dist, duck(dp1));\n    vec3 dp2 = rotate(pos + vec3(-12., 3.5 + a8.y, 5.), vec3(sin(T2)*0.06, sin(T5) * 0.15 - 2.2, cos(T5)*0.04));\n    scene_dist = min(scene_dist, duck(dp2));\n    vec3 dp3 = rotate(pos + vec3(0., 3.5 + a5.x, 2.), vec3(sin(T1)*0.06, sin(T4) * 0.21 - 1.7, sin(T2)*0.06));\n    scene_dist = min(scene_dist, duck(dp3));\n    vec3 dp4 = rotate(pos + vec3(30., 3.5 + a1.y, -25.), vec3(cos(T3)*0.04, cos(T6) * 0.25 - 1., cos(T4)*0.05));\n    scene_dist = min(scene_dist, duck(dp4));\n    vec3 dp5 = rotate(pos + vec3(12., 3.5 + a7.y, -10.), vec3(sin(T2)*0.03, sin(T5) * 0.18 - 1.3, cos(T1)*0.07));\n    scene_dist = min(scene_dist, duck(dp5));\n    vec3 dp6 = rotate(pos + vec3(-15., 3.5 + a6.x, -15.), vec3(cos(T4)*0.08, cos(T3) * 0.17 - 2.2, sin(T3)*0.04));\n    scene_dist = min(scene_dist, duck(dp6));\n    vec3 dp7 = rotate(pos + vec3(-5., 3.5 + a2.y, -30.), vec3(sin(T1)*0.05, cos(T4) * 0.24 - 1.7, sin(T2)*0.07));\n    scene_dist = min(scene_dist, duck(dp7));\n    vec3 dp8 = rotate(pos + vec3(-30., 3.5 + a3.x, -28.), vec3(cos(T3)*0.06, cos(T6) * 0.29 - 2.3, cos(T3)*0.06));\n    scene_dist = min(scene_dist, duck(dp8));\n\n\treturn scene_dist;\n}\n\nvec3 background(vec3 dir, float blur) {\n    float rid = round(dir.y * 5. + 0.5) + TIME * 0.4;\n    float idx = dir.y * 5. + sin(dir.x * 5. + rid * 1.5) * 0.1 + cos(dir.x * 8. + rid * 2.) * 0.05;\n    vec2 audio = spectrumAt(pow(abs(dir.x), 0.2) * 8.);\n    float ax = idx > 1. ? -audio.y : audio.x;\n    idx += ax * 0.2;\n    float row = round(idx + 2.) / 5.;\n    vec3 result = recolor(COL_C, row + 0.5, vec3(1.), vec4(1., 1., 1.8, 3.), vec4(1., 0.5, 0.8, 999.));\n    return result;\n}\n\nvec3 camera_path() {\n    return vec3(sin(TIME * 0.25) * 0.25, 1. + cos(TIME * 0.5) * 0.25, -22);\n}\n\nvec3 camera_look(vec2 uv) {\n    uv *= angle(sin(TIME * 0.5) * 0.02);\n    return normalize(vec3(uv, 1) - vec3(0., 0.05, 0.));\n}\n\nvec2 uv(vec2 frag, vec2 res) {\n    return vec2(frag.xy - .5 * res.xy) / res.y;\n}\n\n\n//--------- RENDERING FUNCTIONS ---------\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    float min_dist = max_dist;\n    \n    for(int i = 0; i < max_steps; i++) {\n        float scene_dist = scene(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n\n        if(scene_dist < min_dist && current_dist < max_dist) min_dist = scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n\n    return vec2(current_dist, min_dist);\n}\n  \nvec4 calc_lighting(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir, float total_dist)\n{\n    vec3 background_col = background(ray_dir, 0.0);\n    \n    if(total_dist > MAX_SCENE_DEPTH) {\n        vec3 result = background_col;\n        result *= max(max(result.r, max(result.g, result.b)), 1.);\n        return vec4(result, 1.);\n    }\n  \n    vec3 light_dir = normalize(LIGHT_POS - hit_pos);\n    vec3 reflection_dir = reflect(ray_dir, mapped_normal);\n\n    float diffuse = dot(mapped_normal, light_dir);\n    if(diffuse > 0.) diffuse = UMBRA_POINT + pow(diffuse, 1.0 - UMBRA_CONTRAST) * (1. - UMBRA_POINT);\n    else diffuse = UMBRA_POINT - pow(abs(diffuse), 1.0 + UMBRA_CONTRAST) * UMBRA_POINT;\n    diffuse = max(diffuse, AMBIENT_BRIGHTNESS);\n    \n    vec3 diffuse_color = COLOR;\n   \n    float reflected_diffuse = dot(reflection_dir, light_dir) * 0.5 + 0.5;\n    diffuse += pow(reflected_diffuse,  1.0 + SPECULAR * 50.) * SPECULAR; \n    \n    float glossiness = (dot(ray_dir, mapped_normal) * 0.5 + 0.5) * GLOSS;\n    vec3 gloss_color = background(reflection_dir, 1.0 - glossiness) * 2.0;\n    diffuse_color = mix(diffuse_color, gloss_color, glossiness);\n    \n    if(SUBSURF_BRIGHTNESS > 0.) {\n        float subsurf_level = pow(max(scene(hit_pos + light_dir * SUBSURF_DIST) / SUBSURF_DIST, 0.), 1.5);\n        diffuse = max(diffuse, subsurf_level * SUBSURF_BRIGHTNESS);\n    }\n    \n    if(AO_POWER > 0.) {\n        float occlusion = raymarch(hit_pos + normal * 0.005, normal, 1e-3, AO_DIST, 12).x;            \n        diffuse *= pow(clamp(occlusion / AO_DIST, 1e-5, 1.), AO_POWER);\n    }\n\n    if(SHADOW_STRENGTH > 0.) {\n       float min_dist = raymarch(hit_pos + normal * SHADOW_SOFTNESS, light_dir, 1e-3, MAX_SHADOW_DIST, MAX_SHADOW_STEPS).y;\n       float occlusion = clamp(min_dist / SHADOW_SOFTNESS, 0.0, 1.);\n       diffuse *= occlusion * SHADOW_STRENGTH + (1.0 - SHADOW_STRENGTH);\n    }\n    \n    vec3 result = recolor(diffuse_color, diffuse, vec3(1.), TONEMAP_HUESAT, TONEMAP_VALUES);\n    result *= max(max(result.r, max(result.g, result.b)), 1.);\n    \n    float fog = pow(min(max(total_dist - FOG_ONSET, 0.0) * (1.0 / FOG_SMOOTH), 1.0), FOG_POWER);\n    result = mix(result, background_col, fog); \n    \n    return vec4(result, 1.0);\n}\n\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(OFFSET_DIST);\n    return normalize(scene(pos) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n    TIME = mod(real_time, 136.);\n    UV = uv(frag, res);\n    \n    vec3 ray_origin = camera_path();\n    vec3 ray_dir = camera_look(UV);\n    \n    float dist = raymarch(ray_origin, ray_dir, HIT_DIST, MAX_SCENE_DEPTH, MAX_SCENE_STEPS).x;\n    vec3 hit_pos = ray_origin + ray_dir * dist;\n \n    vec3 normal = calc_normal(hit_pos);\n    normal = dot(normal, -ray_dir) > 0. ? normal : reflect(normal, ray_dir);\n   \n    LIGHTING_PASS = true;\n    vec4 final_color = calc_lighting(hit_pos, normal, normal, ray_dir, dist);\n    LIGHTING_PASS = false;\n        \n\tvec4 color2d = scene2d(UV);\n    final_color.rgb = mix(final_color.rgb, color2d.rgb, color2d.a);\n     \n    if(VIGNETTE_STRENGTH > 0.) final_color *= 1. - pow(length(UV), VIGNETTE_POWER) * VIGNETTE_STRENGTH;\n    \n    vec3 color = clamp(pow(final_color, vec4(1.0 / GAMMA)).rgb, vec3(5e-2), vec3(3.95));\n    return vec4(color, 1.);\n}\n//--------- ------------------- ---------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = render(fragCoord.xy, iResolution.xy, iTime * SPEED_MULTIPLIER);\n}","name":"Buffer A","description":"","type":"buffer"}]}