{"ver":"0.1","info":{"id":"sttfRj","date":"1663491065","viewed":95,"name":"Homework 1 - Beer mug","username":"KULICH","description":"Homework 1","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 200.0\n#define SURFACE_DISTANCE 0.001\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat length8 ( in vec2 p )\n{\n    return pow(pow(abs(p.x), 8.0) + pow(abs(p.y), 8.0), 1.0 / 8.0);\n}\n\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    float x = length(p.xz) - radius.x;\n    return length(vec2(x, p.y)) - radius.y;\n}\nfloat sdTorus8(vec3 p, vec2 radius)\n{\n    float x = length8(p.xz) - radius.x;\n    return length(vec2(x, p.y)) - radius.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n\n#define GLASS_WIDTH 0.3\n#define GLASS_HEIGHT 0.5\nfloat GetDist(vec3 point, mat3 m)\n{\n    vec3 q = m * point;\n    \n\t//vec4 sphere = vec4(0, 1, 6, 1);\n    //float sphereDist =  length(point-sphere.xyz)-sphere.w;\n    \n    float planeDist = point.y + 1.4;\n    \n    float roundBoxDist = sdRoundBox(q, vec3(GLASS_WIDTH, GLASS_HEIGHT, GLASS_WIDTH), 0.1);\n    float roundBoxDist2 = sdRoundBox(q + vec3(0, 0.2, 0), vec3(GLASS_WIDTH - 0.1, GLASS_HEIGHT - 0.1, GLASS_WIDTH - 0.1), 0.1);\n    float linkDist = sdLink(q + vec3(0.55, 0,0), 0.2, 0.2, 0.07);\n\n    float dist = smoothSubtraction(roundBoxDist2, roundBoxDist, 0.1);\n    dist = unionSDF(dist, planeDist);\n    dist = smoothUnion(dist, linkDist, 0.1);\n    for (int i = 0; i < 12; i++)\n    {\n        dist = smoothUnion(dist, sdTorus8(q + vec3(0., -0.55 + 0.1 * float(i), 0.), vec2(0.38, 0.0025)), 0.07);\n    }\n\n    return dist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, mat3 m)\n{\n    float distanceFromOrigin = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = ro + rd * distanceFromOrigin;\n        float distanceToSurface = GetDist(point, m);\n        distanceFromOrigin += distanceToSurface;\n        if (distanceFromOrigin > MAX_DISTANCE || distanceToSurface < SURFACE_DISTANCE)\n        {\n            break;\n        }\n    }\n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 p, mat3 m) {\n    float d = GetDist(p, m);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = d - vec3(\n        GetDist(p - e.xyy, m), \n        GetDist(p - e.yxy, m), \n        GetDist(p - e.yyx, m)\n      );\n    return normalize(normal); \n}\n\nfloat GetLight(vec3 pointToShade, vec3 camera, out float sp, mat3 m)\n{\n    vec3 lightPos = vec3(-1, 4, -8);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime) * 2.);\n    vec3 light = normalize(lightPos - pointToShade);\n    vec3 normal = GetNormal(pointToShade, m);\n    \n    float diffuse = clamp(dot(normal, light), 0., 1.);\n    \n    float pointLightDist = RayMarch(pointToShade + normal * SURFACE_DISTANCE * 2., light, m);\n    if (pointLightDist < length(lightPos - pointToShade))\n    {\n        diffuse *= 0.25;\n    }\n    \n    vec3  v  = normalize(camera - pointToShade);\n    float nl = max(0.0, dot(normal, light));\n    vec3  h  = normalize(light + v);\n    float hn = max (0.0, dot(h, normal));\n    sp = pow (hn, 110.0);\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n\t\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z-.5);\n    mat3 m     = rotateX(6.0*mouse.y) * rotateY(-6.0*mouse.x);\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float dist = RayMarch(ro, rd, m);\n    vec3 p = ro + rd * dist;\n    \n    float sp = 0.;\n    float diffuseLighting = GetLight(p, ro, sp, m);\n    col = vec3(diffuseLighting) * 0.5 * vec3 ( 0.8, 1, 1 ) + 0.5 * sp * vec3 ( 0.5, 1, 1 );\n    \n    col = pow(col, vec3(.65));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}