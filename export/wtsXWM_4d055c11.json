{"ver":"0.1","info":{"id":"wtsXWM","date":"1563387511","viewed":94,"name":"Mandelbulb by veggie","username":"Veggiebob","description":"mandelbulb.\ndistance function stolen from https://www.shadertoy.com/view/MlffDs thanks MacSlow\nnot sure why mine isn't working :(","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbulb","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this does a kind of anti-aliasing, I suppose?\n//it blurs the point if it seems like an 'outlier'\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 f = fragCoord;\n    vec2 re = iResolution.xy;\n    vec2 uv = f/re;\n\t\n    vec3 col = vec3(0.);\n    \n    float r = 3.;\n    vec2 uvu = vec2(f.x, f.y+r)/re;\n    vec2 uvd = vec2(f.x, f.y-r)/re;\n    vec2 uvl = vec2(f.x-r, f.y)/re;\n    vec2 uvr = vec2(f.x+r, f.y)/re;\n    \n    vec3 t = texture(iChannel0, uv).rgb;\n    vec3 tu = texture(iChannel0, uvu).rgb;\n    vec3 td = texture(iChannel0, uvd).rgb;\n    vec3 tl = texture(iChannel0, uvl).rgb;\n    vec3 tr = texture(iChannel0, uvr).rgb;\n    \n    vec3 a = t;\n    vec3 b = tu;\n    vec3 c = td;\n    vec3 d = tl;\n    vec3 e = tr;\n    //from: https://www.khanacademy.org/computer-programming/order-nums-with-min-max/5581525737111552\n    vec3 n1 = min(a,min(b,min(c,min(d,e))));\n    vec3 n2 = min(max(min(d,min(c,min(a,b))),e),min(min(max(a,b),max(min(a,b),max(min(a,b),c))),max(d,min(c,min(b,a)))));\n    vec3 n3 = min(max(max(e,min(d,min(c,min(b,a)))),min(max(d,min(c,min(a,b))),min(max(c,min(a,b)),max(a,b)))),min(max(max(d,min(a,min(b,c))),min(max(min(a,b),c),max(a,b))),max(max(c,min(a,b)),max(a,b))));\n    vec3 n4 = min(max(max(max(e,min(a,min(b,min(c,d)))),min(max(d,min(a,min(b,c))),min(max(c,min(a,b)),max(a,b)))),min(max(max(d,min(a,min(b,c))),min(max(c,min(a,b)),max(a,b))),max(max(c,min(a,b)),max(a,b)))),max(max(c,min(a,b)),max(a,b)));\n    vec3 n5 = max(a,max(b,max(c,max(d,e))));\n    \n    vec3 Q1 = mix(n1, n2, 0.5);\n    vec3 Q3 = mix(n4, n5, 0.5);\n    vec3 IQR = Q3-Q1;\n    float range = 0.2;//1.+sin(iTime);\n    if((t).r<(Q3+IQR*range).r&&(t).r>(Q1-IQR*range).r)\n        col = t;\n    else \n        col = (tu+td+tl+tr)/4.;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITERS 3\n#define N 8.\n#define MAX_STEPS 256\n//https://iquilezles.org/articles/distancefractals\n//https://www.shadertoy.com/view/MlffDs\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\n}\nvec3 vpow (vec3 v, float n) {\n    float r = length(v);//sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\n    float theta = acos(v.z/v.r);\n    float phi = atan(v.y/v.x);\n    return pow(r, n)*vec3(\n        sin(n*theta)*cos(n*phi),\n        sin(n*theta)*sin(n*phi),\n        cos(n*theta)\n    );\n}\n\nfloat mandelbulb (vec3 c) {\n    vec3 k = c;\n    float dr = 1.;\n    float r;\n    for(int i = 0; i<MAX_ITERS; i++) {\n        k = vpow(k, N) + c;\n        r = length(k);\n        if(r>2.) break;\n        dr = pow(r, N-1.) * N * dr + 1.;\n    }\n    return .5 * log (r) * r / dr;\n}\nfloat mandelbulb (vec3 pos, in float n, in float bail, in int iter)\n{\n    vec3 z = pos;\n    float dr = 1.;\n    float r = .0;\n    for (int i = 0; i < iter; i++) {\n        r = length (z);\n        if (r > bail) break;\n\n        // from cartesian to polar\n        float theta = acos (z.z / r);\n        float phi = atan (z.y, z.x);\n        dr = pow(r, n - 1.) * n * dr + 1.;\n\n        // scale and rotate the point\n        float zr = pow (r, n);\n        theta = theta * n;\n        phi = phi * n;\n\n        // back to cartesian\n        z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n        z += pos;\n    }\n\n    return .5 * log (r) * r / dr; // I just don't get this distance estimator here\n}\nfloat sdf (vec3 p) {\n    return mandelbulb(p, N, 2., MAX_ITERS);\n    //return mandelbulb(p);\n}\nvec4 trace (vec3 o, vec3 r) {\n    vec3 p = o;\n    float t = 0.;\n    float s;\n    int i;\n    for(i = 0; i<MAX_STEPS; i++) {\n        p = o+r*t;\n        s = sdf(p);\n        t+=s*0.2;\n\t\tif(s<0.001) break;\n    }\n    return vec4(p, float(i));\n}\nconst float E = 0.0001;\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z))-sdf(vec3(p.x-E, p.y, p.z)),\n        sdf(vec3(p.x, p.y+E, p.z))-sdf(vec3(p.x, p.y-E, p.z)),\n        sdf(vec3(p.x, p.y, p.z+E))-sdf(vec3(p.x, p.y, p.z-E))\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    float aspect = iResolution.y/iResolution.x;\n    uv.x/=aspect;\n    mouse.x/=aspect;\n    vec3 cam = vec3(0., 0., -2.);\n    vec3 ray = normalize(vec3(uv.xy*1.3, 1.));\n    \n    vec3 rot = vec3(mouse.y*6., -mouse.x*3., 0.);\n    \n    cam.xz = rotate2D(cam.xz, rot.y);\n    ray.xz = rotate2D(ray.xz, rot.y);\n    \n    cam.zy = rotate2D(cam.zy, rot.x);\n    ray.zy = rotate2D(ray.zy, rot.x);\n    \n    \n    vec4 t = trace(cam, ray);\n    vec3 e = t.xyz;\n    vec3 light = vec3(0., 10., -10.);\n    vec3 toLight = normalize(light-e);\n    vec3 norm = estimateNormal(e);\n    float diffuse = max(0.,dot(toLight, norm))*0.8;\n    vec3 refl = reflect(ray, norm);\n    float specular = pow(max(0.0, dot(refl, toLight)), 4.0)*0.5;\n    float d = length(e-cam);\n    float fog = 1.0 / (1.0 + d*d*0.01);\n    \n    vec3 col = vec3(1.);//texture(iChannel0, refl).rgb*1.+0.8;\n    col -= pow(t.w/float(MAX_STEPS), 2.)*0.8;//ao\n    col *= (diffuse+specular)*1.0 + 0.1;//other light\n    col *= fog;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}