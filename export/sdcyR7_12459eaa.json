{"ver":"0.1","info":{"id":"sdcyR7","date":"1653168012","viewed":122,"name":"Hopf_Fibration","username":"afoksha","description":"Renders Hopf fibration","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3sphere","hopf","fiberbundle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==============================================================================================================================================================\n//  Created by Alexander Foksha\n//\n//  Do with this or without this code whatever you wish at your own risk.\n//  You have been warned !!\n//==============================================================================================================================================================\n\nconst float pi = 3.14159265358979324f;\nconst float two_pi = 6.28318530717958648f;\nconst float gamma = 2.2f;\n\n/* right multiplications by basic quaternions i, j, k */\nvec4 mulr_i(vec4 p) { return vec4(p.wz, -p.yx); }\nvec4 mulr_j(vec4 p) { return vec4(-p.z, p.wx, -p.y); }\nvec4 mulr_k(vec4 p) { return vec4(p.y, -p.x, p.w, -p.z); }\n\n/*\n    // phi = (sqrt(5) + 1) / 2\n    // psi = (sqrt(5) - 1) / 2\n\nVertices of the dodecahedron, of length = sqrt(3)\n\nconst vec3 vertices[20] = vec3[]\n(\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3(-1.0,  1.0, -1.0),\n    vec3( 1.0,  1.0, -1.0),\n    vec3(-1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3(-1.0,  1.0,  1.0),\n    vec3( 1.0,  1.0,  1.0),\n\n    vec3(-psi,  0.0, -phi),\n    vec3( psi,  0.0, -phi),\n    vec3(-psi,  0.0,  phi),\n    vec3( psi,  0.0,  phi),\n\n    vec3(-phi, -psi,  0.0),\n    vec3(-phi,  psi,  0.0),\n    vec3( phi, -psi,  0.0),\n    vec3( phi,  psi,  0.0),\n\n    vec3( 0.0, -phi, -psi),\n    vec3( 0.0, -phi,  psi),\n    vec3( 0.0,  phi, -psi),\n    vec3( 0.0,  phi,  psi)\n);\n\nVertices of the icosahedron, of length = sqrt(5 + sqrt(5)) / sqrt(2)\n\nconst vec3 vertices[12] = vec3[]\n(\n    vec3( 0.0, -1.0, -phi),\n    vec3( 0.0, -1.0,  phi),\n    vec3( 0.0,  1.0, -phi),\n    vec3( 0.0,  1.0,  phi),\n    vec3(-1.0, -phi,  0.0),\n    vec3(-1.0,  phi,  0.0),\n    vec3( 1.0, -phi,  0.0),\n    vec3( 1.0,  phi,  0.0),\n    vec3(-phi,  0.0, -1.0),\n    vec3( phi,  0.0, -1.0),\n    vec3(-phi,  0.0,  1.0),\n    vec3( phi,  0.0,  1.0)\n};\n\n*/\n\nconst float phi = 0.9341723589627157f;              /* (sqrt(5) + 1) / (2 * sqrt(3)) */\nconst float psi = 0.3568220897730899f;              /* (sqrt(5) - 1) / (2 * sqrt(3)) */\nconst float ir3 = 0.5773502691896258f;              /* 1 / sqrt(3) */\n\nfloat dodecahedron_sdf(vec3 p)\n{\n    vec4 dp;\n\n    vec3 q = abs(p);\n    dp.w = dot(q, vec3(ir3));           /* maximal dot product with first 8 vertices */\n    dp.xyz = phi * q + psi * q.yzx;     /* maximal dot product with next 4 in x component,\n                                           then another 4 in y component, and the last 4\n                                           in z-component */\n\n    dp.xy = max(dp.xy, dp.zw);\n    float s = min(max(dp.x, dp.y), 1.0f);           /* to avoid evaluation of arc cosine of an argument > 1 */\n\n    return acos(s);\n}\n\nconst float alpha = 0.8506508083520399f;            /* sqrt((sqrt(5) + 1) / (2 * sqrt(5))) */\nconst float beta  = 0.5257311121191336f;            /* sqrt(2) / sqrt(5 + sqrt(5)) */\n\nfloat icosahedron_sdf(vec3 p)\n{\n    vec3 q = abs(p);\n\n    vec3 dp = alpha * q + beta * q.zxy;\n    float s = clamp(max(dp.x, dp.y), dp.z, 1.0f);   /* to avoid evaluation of arc cosine of an argument > 1 */\n\n    return acos(s);\n}\n\nfloat id0 = 0.0f;\nfloat id1 = 0.0f;\n\nfloat sdf(vec4 p)\n{\n    /*\n        The adjoint representation ( q -> pqp^{-1} ) induced by the quaternion p = w + xi + yj + zk \n        on the tangent plane to the unit element q = 1 acts on the axis Z ( = point k) as follows:\n\n            (w + xi + yj + zk) * k * (w - xi - yj - zk) =\n                (w + xi + yj + zk) * (z + yi - xj + wk) =\n                2 * (xz + yw) * i + 2 * (yz - xw) * j + (ww + zz - xx - yy) * k\n\n        All quaternions that map original Z-axis to this same vector constitute the fiber.\n\n        The distance from a point in 3-sphere to a fiber is then simply the distance\n        on the surface of the 2-sphere between the projection of the point and the projection\n        of the fiber.\n    */\n\n    vec3 rZ = vec3(\n               2.0f * (p.x * p.z + p.y * p.w),\n               2.0f * (p.y * p.z - p.x * p.w),\n        1.0f - 2.0f * (p.x * p.x + p.y * p.y)\n    );\n\n    /* we will display the fibers that project inside spherical circles of radius R1 around \n       vertices of dodecahedron (brown fibers) or those that project inside spherical circles \n       of radius R2 around vertices of dual icosahedron (green fibers) and fibers that project \n       into intersection of circles around vertices of first and second type of radius R3 \n       (yellow strips), as we get it almost for free */\n\n    float sdf1 = dodecahedron_sdf(rZ);\n    float sdf2 = icosahedron_sdf(rZ);\n\n    const float R1 = 0.093f;\n    const float R2 = 0.133f;\n    const float R3 = 0.339f;\n    \n    float q0 = min(sdf1 - R1, sdf2 - R2);\n    float q1 = max(sdf1, sdf2) - R3;\n    id0 = step(sdf2 - R2, sdf1 - R1);\n    id1 = step(q1, q0);\n    return 0.5f * min(q0, q1);\n}\n\nvec3 hue()\n{\n    return 2.44f * mix(\n        mix(\n            normalize(vec3(5.7f, 2.1f, 1.8f)), \n            normalize(vec3(2.1f, 5.2f, 1.2f)), \n        id0),\n        vec3(5.9f, 5.1f, 0.7f),\n        id1\n    ); \n}\n\n//==============================================================================================================================================================\n//   SDF gradient :: 4-point tetrahedral evaluation\n//\n//   A good thing is that 3-sphere is a parallelizable manifold, so that at any point\n// one can explicitly specify tangent basis triple, which smoothly varies with the point\n//\n//   Such a basis for example is: { p*i, p*j, p*k }\n//==============================================================================================================================================================\nvec4 spherical_gradient4(vec4 p)\n{\n    const float eps = 0.0525f;\n\n    vec4 pi = mulr_i(p);\n    vec4 pj = mulr_j(p);\n    vec4 pk = mulr_k(p);\n\n    float v0 = sdf(normalize(p + eps * (+ pi - pj - pk)));\n    float v1 = sdf(normalize(p + eps * (- pi - pj + pk)));\n    float v2 = sdf(normalize(p + eps * (- pi + pj - pk)));\n    float v3 = sdf(normalize(p + eps * (+ pi + pj + pk)));\n\n    vec3 g = normalize(\n        vec3(\n              v0 - v1 - v2 + v3,\n            - v0 - v1 + v2 + v3,\n            - v0 + v1 - v2 + v3\n        )\n    );\n\n    return g.x * pi + g.y * pj + g.z * pk;\n}\n\n//==============================================================================================================================================================\n//   SDF gradient :: standard 6-point evaluation\n//==============================================================================================================================================================\nvec4 spherical_gradient6(vec4 p)\n{\n    const float eps = 0.0125f;\n\n    vec4 pi = mulr_i(p);\n    vec4 pj = mulr_j(p);\n    vec4 pk = mulr_k(p);\n\n    float norm = sqrt(1.0 + eps * eps);\n    float inv_norm = 1.0f / norm;\n    float f = eps * inv_norm;\n    vec4 pn = inv_norm * p;\n\n\n    float di = sdf(pn + f * pi) - sdf(pn - f * pi);\n    float dj = sdf(pn + f * pj) - sdf(pn - f * pj);\n    float dk = sdf(pn + f * pk) - sdf(pn - f * pk);\n\n    vec3 g = normalize(vec3(di, dj, dk));\n    return g.x * pi + g.y * pj + g.z * pk;\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.00005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    while (t < two_pi && d > eps)\n    {\n        t += d;\n        p = cos(t) * origin + sin(t) * ray;\n        d = sdf(p);\n    }\n\n    if (d < eps)\n        dist = t;\n\n    return p;\n}\n\n/* p and n are assumed perpendicular and lie on the unit sphere */\nvec3 sample_tex4d(sampler2D sampler, vec4 p, vec4 n)\n{\n    /* we use the same idea as the idea going around for 3d case -- \n       sample in all planes and blend with appropriate weights */\n    const float scale = 7.0f;\n\n    /* we have 6 possible planes xy, yz, zw, wz, xz and yw */\n    vec3 rgb_xy = pow(texture(sampler, scale * p.xy).rgb, vec3(gamma));\n    vec3 rgb_yz = pow(texture(sampler, scale * p.yz).rgb, vec3(gamma));\n    vec3 rgb_zw = pow(texture(sampler, scale * p.zw).rgb, vec3(gamma));\n    vec3 rgb_wx = pow(texture(sampler, scale * p.wx).rgb, vec3(gamma));\n    vec3 rgb_xz = pow(texture(sampler, scale * p.xz).rgb, vec3(gamma));\n    vec3 rgb_yw = pow(texture(sampler, scale * p.yw).rgb, vec3(gamma));\n    \n    /* projections of the area element spanned by vectors p and n \n       onto 6 coordinate planes are */\n       \n    vec3 area_012 = p.xyz * n.yzw - p.yzw * n.xyz; /* xy, yz and zw */\n    vec3 area_345 = p.wxy * n.xzw - p.xzw * n.wxy; /* wx, xz and yw */   \n    \n    /* when the shaded fragment position { x, y, z, w } varies, it varies in such a way \n       that the differential in the neighbourhood stays orthogonal to both n and p directions, \n       so samples in 'perpendicular' planes should obtain higher weights, which means, in terms \n       of areas, the lower the area the higher should be the weight \n       \n       also note, that sum of squares of elements of area_012 and area_345 should \n       add to 1 = the square of the area element spanned by p and n\n    */\n    \n    const float tau = 7.0f;\n    area_012 = exp(-tau * area_012 * area_012);\n    area_345 = exp(-tau * area_345 * area_345);\n    \n    float w = dot(area_012 + area_345, vec3(1.0f));     /* total weight */\n    float inv_w = 1.0f / w;\n\n    return inv_w * (area_012.x * rgb_xy + \n                    area_012.y * rgb_yz +\n                    area_012.z * rgb_zw +\n                    area_345.x * rgb_wx +\n                    area_345.y * rgb_xz +\n                    area_345.z * rgb_yw);\n}\n\nconst int LIGHT_COUNT = 8;\n\nconst vec4 light_ws[LIGHT_COUNT] = vec4[]\n(\n    vec4( 0.0f,  0.0f,  0.0f,  1.0f),\n    vec4( 1.0f,  0.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  1.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  0.0f,  1.0f,  0.0f),\n    vec4( 0.0f,  0.0f,  0.0f, -1.0f),\n    vec4(-1.0f,  0.0f,  0.0f,  0.0f),\n    vec4( 0.0f, -1.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  0.0f, -1.0f,  0.0f)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.83f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 0.5f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n\n    /* if anyone knows how to smoothly fly through without entering areas\n       with sdf < 0 let me know */\n\n    vec4 camera_ws = vec4(-c1 * s0, s1 *  c0 * s2, c0 * c2, s0 * s1);\n    camera_ws = normalize(camera_ws);\n\n    vec4 X = mulr_i(camera_ws);\n    vec4 Y = mulr_j(camera_ws);\n    vec4 Z = mulr_k(camera_ws);\n\n    vec4 camera_X =  c3 * X + s3 * Y;\n    vec4 Y1 = -s3 * X + c3 * Y;\n\n    vec4 camera_Y =   c2 * Y1 + s2 * Z;\n    vec4 camera_Z =  -s2 * Y1 + c2 * Z;\n\n    vec4 view_ray = uv.x * camera_X + uv.y * camera_Y - camera_Z;\n    view_ray = normalize(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f)\n    {\n        /*\n           normal, view, and light vectors should be tangent at 'position' point on the sphere\n           for the light calculations to make sense, which actually means that they must be normal\n           to 'position' viewed as 4-vectors\n\n           !! view_ray can not be used as a view vector because it is tangent at 'camera_ws'\n           point, but we need a vector tangent at 'position' point\n        */\n        vec3 h = hue(); \n        vec4 normal = spherical_gradient6(position);\n        vec3 rgb = h * sample_tex4d(iChannel0, position, normal);\n\n        vec4 view = normalize(camera_ws - dot(camera_ws, position) * position);\n\n        color = 0.0125f * rgb;                      /* ambient */\n\n        for (int i = 0; i < LIGHT_COUNT; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light, position);\n            light = light - dp * position;\n            light = normalize(light);\n\n            /* close to 1 if light is close to the fragment */\n            float d = 0.5f + 0.5f * dp;\n            float a = 1.24f * d * d * exp(-1.27f * dist);\n\n            float cos_theta = max(dot(light, normal), 0.0f);\n            vec4 h = normalize(light + view);\n\n            float cos_alpha = max(dot(h, normal), 0.0f);\n            vec3 diffuse  = (0.475f * cos_theta) * rgb;\n            vec3 specular = vec3(0.562f) * pow(cos_alpha, 88.0f);\n\n            color += a * (diffuse + specular);\n        }\n    }\n    \n    /* everyone does it, i will do it also */\n    color = color / (1.0f + color);\n    color = pow(color, vec3(1.0f / gamma));\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}