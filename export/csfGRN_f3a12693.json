{"ver":"0.1","info":{"id":"csfGRN","date":"1666978867","viewed":63,"name":"Particle Interaction","username":"jean80it","description":"particle interaction","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["interaction","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is part of several I wrote to create animations\n// to support a presentation about Quantum Electrodynamics.\n// it is not supposed to be \"proof\" for anything, but to provide \n// good visualization of some concepts to help intuition.\n\n\n#define sqr(x) (x * x)\n\nfloat AAK = 0.001;  // anti aliasing constant: \n                    // determines how wide is transition \n                    // between inside and outside of an SDF\n                    // while drawing\n\nfloat sdCircle(vec2 uv, vec2 center, float r)\n{\n    return distance(center, uv) - max(0.0, r);\n}\n\nfloat drawSdMask(float sd)\n{\n    return smoothstep(AAK, -AAK, sd);\n}\n\nvoid drawSd(float sd, inout vec3 c, vec3 newCol)\n{\n    float m = drawSdMask(sd);\n    c = mix(c, newCol, m);\n}\n\nvoid drawSd(float sd, inout vec3 c, vec3 newCol, float alpha)\n{\n    float m = drawSdMask(sd) * alpha;\n    c = mix(c, newCol, m);\n}\n\nvec3 gradient(float sd, float r1, float r2, vec3 col1, vec3 col2)\n{\n    return sqrt(mix(col1 * col1, col2 * col2, smoothstep(r1, r2, sd)));\n}\n\nvec3 circularGradient(vec2 uv, vec2 center, float r1, float r2, vec3 col1, vec3 col2)\n{\n    return gradient(sdCircle(uv, center, 0.0), r1, r2, col1, col2);\n}\n\nfloat sdSquiggle(vec2 uv, vec2 A, vec2 B, float thickness, float offs)\n{\n    vec2 lv = (B - A);  // longitudinal vector, in the AB direction\n    vec2 lvn = normalize(lv);  // longitudinal vector, normalized\n    float lC = dot(lvn, A);\n    \n    vec2 ov = vec2(lv.y, -lv.x);  // orthogonal vector\n    vec2 ovn = vec2(lvn.y, -lvn.x);\n    float oC = dot(ovn, A);\n\n    float lDist = (dot(lvn, uv) - lC) / length(lv);  // distance from ortho line\n    \n    if (lDist < 0.0) return distance(uv, A);\n    if (lDist > 1.0) return distance(uv, B);\n    \n    float perturb = (sin(lDist * 20.0 + offs) * 0.07 +\n                    sin(lDist * 31.5 + offs * 1.3) * 0.08) *\n                    smoothstep(0.0, 0.5, lDist) *\n                    smoothstep(1.0, 0.5, lDist);\n    \n    float oDist = dot(ovn, uv - perturb * ovn) - oC;  // distance from line\n\n    return abs(oDist) - thickness;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1), aspect correct\n    vec2 uv = fragCoord/iResolution.y;\n\n    // configuration\n    float particleSize = 0.1;\n    vec2 gradDispl = particleSize * vec2(0.25, 0.25);\n    float gradSize = particleSize * 1.5;\n    \n    float squiggleThickness = 0.005;\n    float squiggleOffs = iTime * 10.0;\n    \n    vec3 colSquiggle = vec3(0.5, 0.8, 0.0);\n    vec3 colOrange = vec3(1.0, 0.45, 0.35);\n    vec3 colTeal = vec3(0.4, 0.5, 1.0);\n    \n    // particles positions\n    vec2 posA = vec2(0.4, 0.40) + \n                sin(iTime * 25.0) * vec2(0.001, 0.001) + // small fast oscillation\n                cos(iTime * 13.5) * vec2(-0.002, 0.005) + \n                sin(iTime * 0.5) * vec2(0.01, 0.01) + // large slow oscillation \n                cos(iTime * 1.5) * vec2(-0.02, 0.05);\n\n    vec2 posB = vec2(1.35, 0.2) + \n                sin(iTime * 28.0) * vec2(0.002, 0.0005) + \n                cos(iTime * 17.5) * vec2(-0.002, 0.005) + \n                sin(iTime * 1.0) * vec2(-0.01, 0.01) +\n                cos(iTime * 2.5) * vec2(-0.02, 0.05);\n\n    vec2 posC = vec2(1.2, 0.80) + \n                sin(iTime * 22.0) * vec2(0.001, 0.001) + \n                cos(iTime * 10.5) * vec2(-0.002, 0.005) + \n                sin(iTime * 2.0) * vec2(0.01, -0.01) +\n                cos(iTime * 1.5) * vec2(0.02, 0.05);\n\n\n    // regulate squiggle appearance by using the highest values\n    // of a chaotic wave function\n    float squiggle1On = map(\n                        (sin(iTime * 2.0) * 0.5 + 0.5) * \n                        (sin(iTime * 2.73) * 0.5 + 0.5),\n                        0.6, 1.0,\n                        0.0, 1.0);\n\n    float squiggle2On = map(\n                        (sin(iTime * 1.8 + 0.1) * 0.5 + 0.5) * \n                        (sin(iTime * 2.0) * 0.5 + 0.5),\n                        0.6, 1.0,\n                        0.0, 1.0);\n                        \n    float squiggle3On = map(\n                        (sin(iTime * 3.0) * 0.5 + 0.5) * \n                        (sin(iTime * 2.73 + 0.2) * 0.5 + 0.5),\n                        0.6, 1.0,\n                        0.0, 1.0);\n                        \n    float squiggle4On = map(\n                        (sin(iTime * 1.0 + 0.3) * 0.5 + 0.5) * \n                        (sin(iTime * 3.5 + 0.4) * 0.5 + 0.5),\n                        0.6, 1.0,\n                        0.0, 1.0);\n\n     vec3 colBackground = clamp(sqrt(mix(sqr(vec3(0.25, 0.2, 0.1)), \n                                   sqr(vec3(0.1, 0.22, 0.3)), \n                                   uv.y + uv.x / 2.0)),\n                                   0.0, 1.0);\n\n    vec3 col = colBackground;\n    \n    drawSd(sdSquiggle(uv, posA, posB, squiggleThickness, squiggleOffs),\n            col,\n            colSquiggle,\n            squiggle1On);\n            \n    drawSd(sdSquiggle(uv, posB, posC, squiggleThickness, squiggleOffs),\n            col,\n            colSquiggle,\n            squiggle2On);\n            \n    drawSd(sdSquiggle(uv, posB, posA, squiggleThickness, squiggleOffs),\n            col,\n            colSquiggle,\n            squiggle3On);\n            \n    drawSd(sdSquiggle(uv, posA, posC, squiggleThickness, squiggleOffs),\n            col,\n            colSquiggle,\n            squiggle4On);\n            \n    drawSd(sdCircle(uv, posA, particleSize),\n            col,\n            circularGradient(uv, posA + gradDispl, 0.00, gradSize, colOrange, colTeal));\n    \n    drawSd(sdCircle(uv, posB, particleSize),\n            col,\n            circularGradient(uv, posB + gradDispl, 0.00, gradSize, colOrange, colTeal));\n    \n    drawSd(sdCircle(uv, posC, particleSize),\n            col,\n            circularGradient(uv, posC + gradDispl, 0.00, gradSize, colOrange, colTeal));\n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}