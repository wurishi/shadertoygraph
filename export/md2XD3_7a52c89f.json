{"ver":"0.1","info":{"id":"md2XD3","date":"1672149482","viewed":74,"name":"pythagtripfractlinemaybe v.01","username":"spontificus","description":"playing with pythagorean triples, and stumbled across an inaccurate method for approximating angles.\n- comparing integer hex-grid based angle(purple) vs benchmark atan(dy,dx) in green\n- hexgrids don't play well with angles not multiples of 30","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hexagonal","postaesthetic"],"hasliked":0,"parentid":"stKfRt","parentname":"Fixed width shaps, no sqrt"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nbool myInRange(int t, int v1, int v2) {\n    return (abs(t - v1) + abs(v2 - t) <= abs(v2 - v1));\n}\n\n// centered and anti-square\nivec3 screenToHex( vec2 p ) {\n    int j = int(iResolution.y-p.y)/2 - int(iResolution.y/4.);\n    int i = (int(p.x) - j )/2 - int(iResolution.x/4.);\n    return ivec3(i,j,-(i+j));\n}\n\n\n// squarerootless \"solution\"\nint hexDist(ivec3 p1, ivec3 p2) {\n    //return (p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y);\n    return (p2.x-p1.x)*(p2.x-p1.x)-(p2.y-p1.y)*(p2.z-p1.z);\n}\n\n// returns true only if c is on right-hand side of line p1-p2 somehow\nint lineDist(ivec3 p1, ivec3 p2, ivec3 v) {\n    // translate relative to p1\n    int i = p2.x-p1.x;\n    int j = p2.y-p1.y;\n    int k = p2.z-p1.z;\n    int fragI = v.x - p1.x;\n    int fragJ = v.y - p1.y;\n    int fragK = v.z - p1.z;\n    \n    \n    // weird line alg\n    // how does it even work?\n    int p1I = (-k-i-fragI);\n    int p1J = (-i-j-fragJ);\n    int p1K = (-j-k-fragK);\n    int mp1 = p1I*p1I + p1J*p1J + p1K*p1K;\n    \n    int p2I = (-j-i-fragI);\n    int p2J = (-k-j-fragJ);\n    int p2K = (-i-k-fragK);\n    int mp2 = p2I*p2I + p2J*p2J + p2K*p2K;\n    return ( (mp2) - (mp1) );\n}\n\nint lineDist2(ivec3 p1, ivec3 p2, ivec3 v) {\n    // translate relative to p1\n    int i = p2.x-p1.x;\n    int j = p2.y-p1.y;\n    int k = p2.z-p1.z;\n    int fragI = v.x - p1.x;\n    int fragJ = v.y - p1.y;\n    int fragK = v.z - p1.z;\n    \n    \n    // weird line alg\n    // how does it even work?\n    int p1I = (-k-i-fragI);\n    int p1J = (-i-j-fragJ);\n    int p1K = (-j-k-fragK);\n    int mp1 = p1I*p1I + p1J*p1J + p1K*p1K;\n    \n    int p2I = (-j-i-fragI);\n    int p2J = (-k-j-fragJ);\n    int p2K = (-i-k-fragK);\n    int mp2 = p2I*p2I + p2J*p2J + p2K*p2K;\n    return ( abs(abs(mp2) - abs(mp1)) );\n}\n\n\nbool line(ivec3 p1, ivec3 p2, ivec3 v) {\n    return lineDist2(p1,p2,v) < 0;\n\n}\n\n\nint hexantOrder[] = int[](0, 3, 1, 2, 5, 4);\nint getHexant(ivec3 v) {\n    int num = 0;\n    if (v.x >= 0) {\n        num += 4;\n    }\n    \n    if (v.y >= 0) {\n        num += 2;\n    }\n        \n    if (v.z >= 0) {\n        num += 1;\n    }\n    \n    return hexantOrder[num % 6];\n}\n\n\n#define PI 3.1415926538\n\nfloat hexAngle(ivec3 inputs) {\n    int i = inputs.x;\n    int j = inputs.y;\n    int k = inputs.z;\n    \n    int tot = abs(i)+abs(j);\n    \n    int hexant = getHexant(inputs);\n    int targetIndex = hexant % 3;\n    int targetSign = hexant % 2;\n    int target = inputs[2-targetIndex];\n    if (targetSign == 0) {\n        target *= -1;\n    }\n    \n    int progIndex = (targetIndex + 1) % 3;\n    int prog = inputs[2-progIndex];\n    if (targetSign == 1) {\n        prog *= -1;\n    }\n    \n    return (float((hexant*target + prog))/float(target*6))*PI*2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec3 center = ivec3(0,0,0);\n    ivec3 fragHex = screenToHex(fragCoord.xy);\n    int fragI = fragHex.x;\n    int fragJ = fragHex.y;\n    int fragK = fragHex.z;\n    \n    ivec3 mouseHex = screenToHex(iMouse.xy);  \n    int mouseI = mouseHex.x;\n    int mouseJ = mouseHex.y;\n    int mouseK = mouseHex.z;\n\n    vec4 col = vec4(.1,.1,.1,1.);\n   \n\n\n    if ( fragHex == mouseHex ) {\n        col = vec4(1., 1., 1., 1.);\n    }\n    \n    // line\n    int i = mouseI; // e.g. 6, 7, [-13]\n    int j = mouseJ;\n    int k = mouseK;\n\n    float hexAng = hexAngle(fragHex);\n    float mouseAng = hexAngle(mouseHex);\n    \n    float sysMouseAng = atan(float(mouseHex.y)*sqrt(3.)/2., float(mouseHex.x) + float(mouseHex.y)/2.);\n    if (sysMouseAng < 0.) {\n        sysMouseAng += PI*2.;\n    }\n    \n    // show incorrectly calculated arc in purple\n    if (abs(hexAng - mouseAng) <0.025) {\n      col = vec4(1., 0., 1., 1.);\n    }\n    \n    // show correct trig/atan solution in green\n    if (abs(hexAng - sysMouseAng) <0.025) {\n      col += vec4(0., 1., 0., 1.);\n    }\n\n    \n    // center dot\n    if (fragI == 0 && fragJ == 0 ) {\n        col = vec4(0., 0., 0., 1.);   \n    }   \n    \n    // 30 degree lines\n    if ( abs(fragI) == abs(fragJ) || abs(fragJ) == abs(fragK) || abs(fragI) == abs(fragK)) {\n        col = vec4(.3, .3, .3, 1.);\n    }\n    \n    // draw i,j,k axes\n    if (fragI == 0) col = vec4(1., 0., 0., 1.);\n    if (fragJ == 0) col = vec4(0., 1., 0., 1.);\n    if (fragK == 0) col = vec4(0., 0., 1., 1.);\n    \n    fragColor = col;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}