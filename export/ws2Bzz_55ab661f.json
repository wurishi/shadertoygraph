{"ver":"0.1","info":{"id":"ws2Bzz","date":"1589450699","viewed":200,"name":"Path Tracing test","username":"RoyaleNoir","description":"Cleaner this time,\nPress up arrow to reset samples (i.e. when resolution changes).\nIf any weird squares appear, reset the shader. I can't figure out how to fix it","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 RAWImage = texture(iChannel0, uv);\n    \n    vec4 HDRImage = RAWImage * 8.0;\n    \n    HDRImage = HDRImage / (1.0 + HDRImage);\n    \n    fragColor = pow(HDRImage, vec4(1.0/2.2));\n    //fragColor = RAWImage;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Floats are fun\n#define EPSILON 0.00001\n#define M_PI 3.14159265\n\n//Util Functions\nvec3 rotateY(vec3 p, float t)\n{\n    vec3 r;\n    r.x = p.x * cos(t) - p.z * sin(t);\n    r.y = p.y;\n    r.z = p.x * sin(t) + p.z * cos(t);\n    return r;\n}\n\nvec3 getTangent(vec3 normal)\n{\n    vec3 tangent;\n\n\tvec3 c1 = cross(normal, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(normal, vec3(0.0, 1.0, 0.0));\n\n\tif( length(c1) > length(c2) )\n\t{\n\t\ttangent = c1;\n\t}\n\telse\n\t{\n\t\ttangent = c2;\n\t}\n    \n    return normalize(tangent);\n}\n\n//Materials\nstruct Material\n{\n    vec3 albedo;\n    float rough;\n    float metal;\n    \n    float emission;\n    \n    bool trans;\n    float IOR;\n};\n    \nMaterial createMat(vec3 albedo, float rough, float metal, float IOR, bool trans)\n{\n    Material mat;\n    mat.albedo = albedo;\n    mat.rough = rough;\n    mat.metal = metal;\n    mat.IOR = IOR;\n    mat.trans = trans;\n    return mat;\n}\n\n//Ray Struct / Helper functions\n//A ray is defined as an origin, a (normalized) direction vector, and a multiplier\nstruct Ray\n{\n    vec3 o;\t//Origin\n    vec3 d;\t//Direction\n};\n\n//Gets the position of a ray\nvec3 getRayPos(Ray r, float t)\n{\n    return r.o + r.d * t;\n}\n\nRay createRay(vec3 o, vec3 d)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    return r;\n}\n\n//Intersection Functions\n\nvec4 traceSphere(Ray r, vec3 center, float radius)\n{\n    vec3 offset = r.o - center;\n    \n    //Quadratic Parameters\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(offset, r.d);\n    float c = dot(offset, offset) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    float t;\n    vec3 norm;\n    \n    if(discriminant < 0.0)\n    {\n        t = -1.0;\n    }\n    else\n    {\n        t = (-b - sqrt(discriminant)) / (2.0*a);\n        norm = normalize(getRayPos(r, t) - center);\n    }\n    \n    return vec4(norm, t);\n}\n\nvec4 tracePlane(Ray r, vec3 center, vec3 normal)\n{\n    float t = -1.0;\n    \n    float denom = dot(normal, r.d);\n    if (abs(denom) > EPSILON)\n\t{\n        t = dot((center - r.o), normal) / denom;\n\t}\n    \n    return vec4(normal, t);\n}\n\nvec4 traceBox(Ray r, vec3 boxMin, vec3 boxMax, float rot)\n{\n    r.o -= boxMin;\n    //Do Rotation\n    \n    r.o = rotateY(r.o, rot);\n    r.d = rotateY(r.d, rot);\n    \n    r.o += boxMin;\n    \n    vec3 tMin = (boxMin - r.o) / r.d;\n    vec3 tMax = (boxMax - r.o) / r.d;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    bool hit = tNear < tFar;\n    \n    vec3 center = (boxMin + boxMax) * 0.5;\n    vec3 hitPos = getRayPos(r, tNear);\n    \n    vec3 boxSize = boxMax - boxMin;\n    \n    vec3 hitDir = (hitPos - center) / boxSize;\n    \n    float hitX = (abs(hitDir.x) > abs(hitDir.y)) && (abs(hitDir.x) > abs(hitDir.z)) ? sign(hitDir.x) : 0.0;\n    float hitY = (abs(hitDir.y) > abs(hitDir.x)) && (abs(hitDir.y) > abs(hitDir.z)) ? sign(hitDir.y) : 0.0;\n    float hitZ = (abs(hitDir.z) > abs(hitDir.y)) && (abs(hitDir.z) > abs(hitDir.x)) ? sign(hitDir.z) : 0.0;\n    \n    vec3 normal = normalize(vec3(hitX, hitY, hitZ));\n    \n    normal = rotateY(normalize(normal), -rot);\n    \n\treturn vec4(normal * float(hit), hit ? tNear : -1.0);\n}\n\n//Schlick Fresnel Function\nfloat Fresnel(float cosTheta, float R0)\n{\n    return R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//Correlated Geometry Function\nfloat G2(float NdotL, float NdotV, float alpha)\n{\n    float num = 2.0 * NdotL * NdotV;\n    float denom = mix(num, NdotL + NdotV, alpha);\n    \n    return num / denom;\n}\n\n//Beckmann Distribution Function\nfloat Distribution(float NdotH, float a)\n{\n    float a2 = a * a;\n    float NdotH2 = NdotH * NdotH;\n    \n    float norm = 1.0 / (M_PI * a2 * NdotH2 * NdotH2);\n    \n    float expon = (NdotH2 - 1.0) / (a2 * NdotH2);\n    \n    return norm * exp(expon);\n}\n\n//Distribution Function\n\nvec3 BRDF(Material mat, vec3 n, vec3 wo, vec3 wi, bool ref, vec3 specTint)\n{\n    if(length(mat.albedo) < EPSILON)\n        return vec3(0);\n    \n    vec3 h = normalize(wo + wi);\n    \n    //Cook-Torrance (sans. Fresnel)\n    float g = G2(dot(wi, n), dot(wo, n), mat.rough);\n    float d = Distribution(dot(n, h), mat.rough);\n    float spec = (g * d) / (4.0 * dot(wo, n) * dot(wi, n));\n    \n    //Hammon Diffuse\n    float facing = 0.5 - 0.5 * dot(wo, wi);\n    float rgh = facing * (0.9 - 0.4 * facing) * ((0.5 + dot(n, h)) / dot(n, h));\n    \n    float smt = 1.05 \n        * (1.0 - pow(1.0 - dot(n, wi), 5.0))\n        * (1.0 - pow(1.0 - dot(n, wo), 5.0));\n    \n    float single = 1.0 / M_PI * mix(smt, rgh, mat.rough);\n    float multi = 0.1159 * mat.rough;\n    \n    vec3 diffuse = mat.albedo * (single + mat.albedo * multi);\n\n    //return (1.0 - f) * diffuse + spec;\n    return ref? vec3(spec) * specTint : mix(diffuse, vec3(0), mat.metal);\n}\n\nvec3 cosHemis(vec2 xi, float offset)\n{\n    //Based on my highly scientific Desmos graphing, this doesn't affect the distribution,\n    //it just allows more randomness.\n    xi.x = mod(xi.x + offset, 1.0);\n    xi.x = clamp(xi.x, 0.0, 1.0);\n    \n    float theta = asin(sqrt(xi.x));\n    float phi = 2.0 * M_PI * xi.y;\n    \n    float x = cos(phi) * sin(theta);\n    float y = cos(theta);\n    float z = sin(phi) * sin(theta);\n    \n    return vec3(x, y, z);\n}\n\nvec3 BRDFHemis(vec2 xi, float offset, float a)\n{\n    //Based on my highly scientific Desmos graphing, this doesn't affect the distribution,\n    //it just allows more randomness.\n    xi.x = mod(xi.x + offset, 1.0);\n    xi.x = clamp(xi.x, 0.0, 1.0);\n    \n    float a2 = a * a;\n    \n    float theta = atan(sqrt(-a2 * log(1.0 - xi.x)));\n    float phi = 2.0 * M_PI * xi.y;\n    \n    float x = cos(phi) * sin(theta);\n    float y = cos(theta);\n    float z = sin(phi) * sin(theta);\n    \n    return vec3(x, y, z);\n}\n\nfloat BRDFProb(vec3 wo, vec3 wm, float a)\n{\n    float mdotg = dot(wm, vec3(0, 1, 0));\n    \n    float num = Distribution(mdotg, a) * mdotg;\n    float den = 4.0 * dot(wo, wm);\n    \n    return num / den;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getScene(Ray ray, out Material mat)\n{\n    //Materials\n    float testRough = 0.6;\n    \n    Material matWhite = createMat(vec3(0.737, 0.748, 0.710), testRough, 0.0, 1.547, false);\n\tMaterial matRed = \tcreateMat(vec3(0.642, 0.061, 0.056), testRough, 0.0, 1.547, false);\n\tMaterial matGreen = createMat(vec3(0.149, 0.406, 0.094), testRough, 0.0, 1.547, false);\n    Material matMetal = createMat(vec3(1.0, 1.0, 1.0), \t0.002, 1.0, 0.3, false);\n    Material matGlass = createMat(vec3(0.99, 0.99, 0.99), \t0.002, 0.0, 1.5, true);\n    \n    vec4 scene;\n    scene = tracePlane(ray, vec3(-5.528, 0, 0), vec3(0, 1, 0));\n    \n    vec4 ceiling = tracePlane(ray, vec3(5.56, 5.488, 0), vec3(0, -1, 0));\n    mat = matWhite;\n    \n    if((ceiling.a < scene.a) && ceiling.a > 0.0 || scene.a < 0.0)\n    {\n        //White\n        mat = matWhite;\n        \n        vec3 pos = getRayPos(ray, ceiling.a);\n        \n        if(pos.x > -3.43 && pos.x < - 2.13\n          && pos.z < 3.32 && pos.z > 2.27)\n        {\n            mat.emission = 1.0;\n        }\n        \n        scene = ceiling;\n    }\n    \n    vec4 back = tracePlane(ray, vec3(-5.496, 0, 5.592), vec3(0, 0, -1));\n    \n    if((back.a < scene.a) && back.a > 0.0 || scene.a < 0.0)\n    {\n        //White\n         mat = matWhite;\n        scene = back;\n    }\n    \n    vec4 right = tracePlane(ray, vec3(0.000, 0.000, 5.592), vec3(-1, 0, 0));\n    \n    if((right.a < scene.a) && right.a > 0.0 || scene.a < 0.0)\n    {\n        //Green\n        mat = matGreen;\n        scene = right;\n    }\n    \n    //TODO: Angled like in irl\n    vec4 left = tracePlane(ray, vec3(-5.496, 0.000, 0.0), vec3(1, 0, 0));\n    \n    if((left.a < scene.a) && left.a > 0.0 || scene.a < 0.0)\n    {\n        //Red\n         mat = matRed;\n        scene = left;\n    }\n    \n    vec4 small = traceBox(ray, vec3(-1.3, 0.0, 0.64), vec3(0.37, 1.65, 2.31), -1.28);\n    \n    if((small.a < scene.a) && small.a > 0.0 || scene.a < 0.0)\n    {\n        //White\n         mat = matWhite;\n        scene = small;\n    }\n    \n    vec4 tall = traceBox(ray, vec3(-4.23, 0.0, 2.47), vec3(-2.58, 3.3, 4.16), -0.3);\n    \n    if((tall.a < scene.a) && tall.a > 0.0 || scene.a < 0.0)\n    {\n        //White\n         mat = matMetal;\n        scene = tall;\n    }\n    \n    //vec4 ball = traceSphere(ray, vec3(-4, 1.0, 1), 1.0);\n    \n    //if((ball.a < scene.a) && ball.a > 0.0 || scene.a < 0.0)\n    //{\n        //Metal\n     //   mat = matGlass;\n        //scene = ball;\n    //}\n    \n    if(getRayPos(ray, scene.a).z < 0.0)\n    {\n        scene.a = -1.0;\n        mat.albedo = vec3(0);\n    }\n    \n    return scene;\n}\n\n//Returns Emission and outputs info needed for integration\nvec3 getSample(inout Ray ray, inout vec3 kr, out float prob, in int bounce, inout bool inGl)\n{\n    //Russian Roullette Time!\n    //float Pi = min(1.0, float(bounce) * 0.0625);\n    \n    vec2 sampleOffset3 = (iTime + EPSILON) * vec2(M_PI * 2.95635, M_PI * 9.3465) + float(bounce) * vec2(M_PI * 8.3456, M_PI * 1.0456);\n    float noise3 = texture(iChannel0, (gl_FragCoord.xy) / iChannelResolution[0].xy + sampleOffset3).r;\n    \n    //Light Color\n    vec3 lightCol = vec3(18.4, 11.5036, 2.864);\n    //vec3 lightCol = vec3(15, 15, 15);\n    \n    //Information returned by getScene()\n    Material mat;\n    vec4 scene = getScene(ray, mat);\n    \n    //Useful Info\n    vec3 Normal = scene.rgb;\n    vec3 Pos = getRayPos(ray, scene.a - EPSILON);\n    \n    //Sampling Directions\n    vec3 Tangent = getTangent(Normal);\n    vec3 Binormal = cross(Normal, Tangent);\n    mat3 TBN = mat3(Tangent, Normal, Binormal);\n    \n    if(!mat.trans)\n    {\n    \t//Emission\n    \tvec3 Le;\n    \t\n    \tvec2 sampleOffset1 = (iTime + EPSILON) * vec2(M_PI * 2.89425, M_PI * 3.293672) + float(bounce) * vec2(M_PI * 2.62553, M_PI * 9.251345);\n    \tvec2 noise1 = texture(iChannel0, (gl_FragCoord.xy) / iChannelResolution[0].xy + sampleOffset1).rg;\n    \t\n    \tvec2 sampleOffset2 = (iTime + EPSILON) * vec2(M_PI * 2.9735, M_PI * 7.9265) + float(bounce) * vec2(M_PI * 7.0265, M_PI * 5.9126);\n    \tvec2 noise2 = texture(iChannel0, (gl_FragCoord.xy) / iChannelResolution[0].xy + sampleOffset2).rg;\n    \t\n    \tvec3 specCol = mix(vec3(1), mat.albedo, mat.metal);\n    \t\n    \tfloat r0 = pow((1.0 - mat.IOR) / (1.0 + mat.IOR), 2.0);\n    \t\n    \t//float r0 = mix(0.04, mr0, mat.metal);\n    \tfloat Fres = Fresnel(dot(-ray.d, normalize(Normal - ray.d)), r0);\n    \tFres = mix(Fres, 1.0, mat.metal);\n        \n    \tbool refl = noise3 <= Fres;\n    \t\n    \tvec3 wm = BRDFHemis(noise1, max(iTime + 0.9, EPSILON), mat.rough);\n    \tvec3 wo = reflect(inverse(TBN) * ray.d, wm);\n    \t\n    \tvec3 rayDir = TBN * (refl? wo : cosHemis(noise1, max(iTime + 0.9, EPSILON))); \n    \tfloat cosTheta = max(dot(rayDir, Normal), EPSILON);\n\t\t\n    \t//Next Event Estimation\n    \tvec3 lightPos = vec3(-2.78, 5.488 - EPSILON, 2.795) + ((vec3(noise2.x, 0.5, noise2.y) * 2.0 - 1.0) * 1.3);\n    \tvec3 lightDir = normalize(lightPos - Pos);\n    \t\n    \tfloat lightAtten = 1.0 / dot(lightPos - Pos, lightPos - Pos);\n    \tMaterial lightMat;\n    \t\n    \tvec3 directBRDF = BRDF(mat, Normal, -ray.d, lightDir, refl, specCol) * max(dot(lightDir, Normal), 0.0);\n    \tfloat hitLight = getScene(createRay(Pos, lightDir), lightMat).a >= length(lightPos - Pos)? 1.0 : 0.0;\n    \t\n    \t//Hacky way of dealing with ceiling\n    \tif(lightDir.y < EPSILON)\n    \t    hitLight = 0.0;\n    \t\n    \tkr *= BRDF(mat, Normal, -ray.d, rayDir, refl, specCol) * cosTheta;\n    \t\n    \tif(!refl)\n    \t\tLe += hitLight * lightCol * lightAtten * directBRDF;\n    \telse\n    \t    Le += mat.emission * lightCol;\n    \t\n    \tLe += bounce == 0 ? mat.emission * lightCol : vec3(0);\n    \t\n    \tLe /= 1.0;\n    \t\n    \tkr /= refl? BRDFProb(wo, wm, mat.rough) : cosTheta;\n    \t\n    \tray = createRay(Pos, rayDir);\n    \t\n    \treturn scene.a > 0.0 ? Le : vec3(0);\n    }\n    else //Hit glass\n    {\n        //r0 is the same both ways\n    \tfloat r0 = pow((1.0 - mat.IOR) / (1.0 + mat.IOR), 2.0);\n        \n        float Fres = Fresnel(dot(-ray.d, Normal), r0);\n    \t\n    \tbool refl = noise3 <= Fres;\n        \n        prob -= 1.0;\n        \n        if(refl)\n        {\n            ray.o = Pos;\n            ray.d = reflect(ray.d, Normal);\n            //kr *= 0.0;\n            return vec3(0);\n        }\n        \n        else\n        {\n        \tvec3 gPos;\n        \tif(!inGl)\n        \t{\n        \t    gPos = getRayPos(ray, scene.a + EPSILON);\n        \t\tray.d = refract(ray.d, Normal, 1.0 / mat.IOR);\n        \t}\n        \telse\n        \t{\n        \t    gPos = getRayPos(ray, scene.a);\n        \t    ray.d = refract(ray.d, Normal, mat.IOR);\n        \t}\n            //kr *= 0.0;\n        \tray.o = gPos;\n        \tinGl = !inGl;\n        \t\n        \treturn vec3(0);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 sampleOffset = iTime * vec2(M_PI * 1.8, M_PI * 8.9);\n    vec3 noise = texture(iChannel0, (gl_FragCoord.xy) / iChannelResolution[0].xy + sampleOffset).rgb;\n    \n    noise = noise * 2.0 - 1.0;\n    \n    vec3 aaOff = vec3(noise.r, noise.g, 0) * 4.0 / vec3(iResolution.x, iResolution.y, 1.0);\n    \n    vec3 camPos = vec3(-2.78, 2.73, -8) + aaOff;\n    vec3 viewDir = normalize(vec3(uv * 0.025, 0.035));\n    \n    Ray viewRay = createRay(camPos, viewDir);\n    \n    vec3 fr = vec3(1.0);\n    vec3 L0;\n    \n    int bounces = 4;\n    \n    float prob = float(bounces);\n    bool inGl = false;\n    int bounce;\n    \n    for(int i = 0; i < bounces; i++)\n    {        \n    \tL0 += fr * getSample(viewRay, fr, prob, i, inGl);\n        //if(!cont)\n            //break;\n    }\n    \n    L0 *= float(bounces)/prob;\n    \n    // Output to screen\n    fragColor = vec4(L0, 1.0);\n    \n    if(iTime < -EPSILON)\n        fragColor = vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_UP = 38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 oldFrames = texture(iChannel1, uv);\n    vec4 newFrame = texture(iChannel0, uv);\n    \n    float hack = texture(iChannel3, vec2(0)).r;\n    \n    vec3 combinedFrames = (max(newFrame, vec4(EPSILON)) + max(oldFrames, vec4(EPSILON)) * oldFrames.a).rgb;\n    \n    if(oldFrames.a <= EPSILON)\n        combinedFrames = newFrame.rgb;\n    \n    //I know this will break if you leave it running for about 10^16 times the age of the universe\n    //That's probably long enough\n    if(iTime > EPSILON)\n    \toldFrames.a += 1.0;\n    \n    vec2 keyPos = vec2(KEY_UP, 0) / iChannelResolution[2].xy;\n    \n    if(texture( iChannel2, keyPos).x > EPSILON || (hack > 0.5 && oldFrames.a < -EPSILON))\n    {\n        oldFrames.a = 0.0;\n    }\n        \n    fragColor = vec4(max(combinedFrames / oldFrames.a, vec3(EPSILON)), oldFrames.a);\n    //fragColor = newFrame;\n    \n    if(hack < EPSILON)\n        fragColor = vec4(-1);\n}","name":"Buffer B","description":"","type":"buffer"}]}