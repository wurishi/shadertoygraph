{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define pi 3.14159265358979\n#define sqrt3_divide_6 0.289\n#define sqrt6_divide_12 0.204\n\nconst float seg = 3.0;\nconst float segwidth = 1./(2.*seg-1.);\n\nfloat _CircleRadius = 0.1;\nfloat _OutlineWidth = 0.02;\nvec4 _OutlineColor = vec4(0.,0.,0.,0.);\nfloat _LineWidth = 0.08;\nvec4 _LineColor = vec4(186.0/256.0,42.0/256.0,42.0/256.0,0.);\nfloat _Antialias = 0.01;\nvec4 _BackgroundColor = vec4(227./256.,206./256.,178./256.,0.);\n\nfloat line(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    return (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat dashedline(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    vec2 prePoint = point1;\n    vec2 curPoint;\n    float d = 1.;\n    for (float t=segwidth; t<1.1; t+=2.*segwidth) {\n        curPoint = point1*(1.-t)+t*point2;\n        d = min(d, line(pos, prePoint, curPoint, width));\n        prePoint = point1*(1.-(t+segwidth))+(t+segwidth)*point2;\n    }\n    \n    return d;\n}\n\nfloat circle(vec2 pos, vec2 center, float radius) {\n    float d = length(pos - center) - radius;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 originalPos = (2.0 * fragCoord - iResolution.xy)/iResolution.yy;\n    vec2 pos = originalPos;\n    \n    // Twist\n    //pos.x += 0.5 * sin(5.0 * pos.y);\n\n    vec2 split = vec2(0, 0); \n    if (iMouse.z > 0.0) {       \n        split = (-iResolution.xy + 2.0 * iMouse.xy) / iResolution.yy;\n    }\n    \n    // Background\n    vec3 col = _BackgroundColor.rgb * (1.0-0.2*length(originalPos));\n    \n    // Apply X Y Z rotations\n    // Find more info from http://en.wikipedia.org/wiki/Rotation_matrix\n    float xSpeed = 0.3;\n    float ySpeed = 0.5;\n    float zSpeed = 0.7;\n    mat3 matrix = mat3(1., 0., 0.,\n                      0., cos(xSpeed*iTime), sin(xSpeed*iTime),\n                      0., -sin(xSpeed*iTime), cos(xSpeed*iTime));\n    matrix = mat3(cos(ySpeed*iTime), 0., -sin(ySpeed*iTime),\n                      0., 1., 0.,\n                      sin(ySpeed*iTime), 0., cos(ySpeed*iTime))*matrix;\n    matrix = mat3(cos(zSpeed*iTime), sin(zSpeed*iTime), 0.,\n                 \t  -sin(zSpeed*iTime), cos(zSpeed*iTime), 0.,\n                 \t  0., 0., 0.)*matrix;\n    \n    float l = 1.5;\n    vec3 p0 = vec3(0., 0., sqrt6_divide_12 * 3.) * l;\n    vec3 p1 = vec3(-0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    vec3 p2 = vec3(0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    vec3 p3 = vec3(0, sqrt3_divide_6 * 2., -sqrt6_divide_12) * l;\n    \n    p0 = matrix * p0;\n    p1 = matrix * p1;\n    p2 = matrix * p2;\n    p3 = matrix * p3;\n    \n    vec2 point0 = p0.xy;\n    vec2 point1 = p1.xy;\n    vec2 point2 = p2.xy;\n    vec2 point3 = p3.xy;\n\n    float d = line(pos, point0, point1, _LineWidth);\n    d = min(d, line(pos, point1, point2, _LineWidth));\n    d = min(d, line(pos, point2, point3, _LineWidth));\n    d = min(d, line(pos, point0, point2, _LineWidth));\n    d = min(d, line(pos, point0, point3, _LineWidth));\n    d = min(d, line(pos, point1, point3, _LineWidth));\n    d = min(d, circle(pos, point0, _CircleRadius));\n    d = min(d, circle(pos, point1, _CircleRadius));\n    d = min(d, circle(pos, point2, _CircleRadius));\n    d = min(d, circle(pos, point3, _CircleRadius));\t\n\n    if (originalPos.x < split.x) {\n        col = mix(_OutlineColor.rgb, col, step(0., d - _OutlineWidth));\n\t    col = mix(_LineColor.rgb, col, step(0., d));\n    } else if (originalPos.y > split.y) {\n        float w = _Antialias;\n        col = mix(_OutlineColor.rgb, col, smoothstep(-w, w, d - _OutlineWidth));\n        col = mix(_LineColor.rgb, col, smoothstep(-w, w, d));      \n    } else {\n        float w = fwidth(0.5*d) * 2.0;\n        col = mix(_OutlineColor.rgb, col, smoothstep(-w, w, d - _OutlineWidth));\n        col = mix(_LineColor.rgb, col, smoothstep(-w, w, d));\n    }\n    \n    // Draw split lines\n    col = mix(vec3(0), col, smoothstep(0.005, 0.007, abs(originalPos.x - split.x)));\n    col = mix(col, vec3(0), (1. - smoothstep(0.005, 0.007, abs(originalPos.y - split.y))) * step(split.x, originalPos.x));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tB3zm","date":"1427527303","viewed":2574,"name":"Tetrahedron","username":"candycat","description":"Draw a tetrahedron with/without AA. Uncomment line 28 to see the difference between _Antialias and fwidth.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["tetrahedron","aa"],"hasliked":0,"parentid":"","parentname":""}}