{"ver":"0.1","info":{"id":"4XSXRc","date":"1711261789","viewed":51,"name":"Poppin Dance Concepts: Flex","username":"zma","description":"Concept elements","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","concepts","elements","poppin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\n\nconst vec3 size = vec3(3, 1.5, 0.1);\nconst vec3 size1 = vec3(1.5, 1, 0.1);\n\nfloat square(float a){\n    return a*a;\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    return vec2( tN, tF );\n}\n\n\nvec3 rotate(vec3 p, const float yaw, const float pitch)\n{\n    p.xz = vec2( p.x*cos(yaw)+p.z*sin(yaw),\n                 p.z*cos(yaw)-p.x*sin(yaw));\n    p.yz = vec2( p.y*cos(pitch)+p.z*sin(pitch),\n                 p.z*cos(pitch)-p.y*sin(pitch));\n    return p;\n}\n\n//Caculate distance from ray origin\nfloat plane(vec3 o, vec3 d, vec3 center, vec2 yawpitch, vec3 size){\n    o = o - center;\n    float yaw = yawpitch.x;\n    float pitch = yawpitch.y;\n    d = rotate(d, yaw, pitch);\n    o = rotate(o, yaw, pitch);\n    \n    float t = boxIntersection(o, d, size).x;\n    vec3 p = o + t*d;\n    \n    if(abs(p.x)<=size.x && abs(p.y)<=size.y && abs(p.z)<=size.z)\n    return t;\n    else return -1.;\n}\n\nvec4 animatePlane(vec3 o, vec3 d, float fTime, vec3 psize, vec2 angle, vec3 offset){\n    float planeXAngle = angle.x;\n    float planeYAngle = angle.y;\n    vec3 planePos = vec3(0, 3,-6) + offset;\n    \n    //Rotate with X Axis : [-1 - -2]\n    if(fTime<=0. && fTime >= -1.)\n    {\n    \tplaneXAngle += fTime*PI;\n    }\n    //Rotate with Y Axis : [0-1]\n\telse if(fTime >=0. && fTime <= 1.)\n    {\n        planeYAngle += fTime*PI;\n    }\n    \n    float t = plane(o, d, planePos, vec2(planeXAngle, planeYAngle), psize);\n\n    return vec4(t);\n}\n\nvec3 randomTimer(float time){\n    float u = floor(time);\n    float v = fract(time);\n    \n    float a = mod(u, 2.);\n    float b = mod(u, 5.);\n    float c = mod(u, 7.);\n        \n    return vec3(a+v, b+v, c+v);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord.xy/iResolution.xy;\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0., 2., -4.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 groundcolor = vec3(0., 0.5, 0.);\n    \n    \n    \n    float fTime = fract(iTime*0.2)*4.0;\n    //float fTime2 = 1.*fTime1 * fTime1;\n    //float fTime3 = fTime2 * fTime2;\n    float t = fTime;\n    float ct = cos(t);\n    float st = sin(t);\n    \n    mat2 rotate2 = mat2(ct, -st, st, ct);\n    vec3 norm;\n    vec3 pos;\n    vec3 col = vec3(0.);\n    float occ = 1.;\n    \n    //The 3 axis of the camera\n    vec3 camR = vec3(1,0,0);\n    vec3 camU = vec3(0,1,0);\n    vec3 camD = vec3(0,0,-1);\n    vec3 o = vec3(0.,1.,0.);//Camera origin\n    vec3 d = normalize(uv.x*camR+uv.y*camU+camD);\n      \n    vec3 size = vec3(2., .1, 1.);\n    float r = 0.1;\n    \n    vec3 rtime = randomTimer(iTime);\n        \n    vec3 offset = vec3(0, 0, 0);\n    \n    vec4 c1 =animatePlane(o, d, 2.03*sin(rtime.x), size, vec2(0,0), offset);\n    offset.y -= 2.5;\n    vec4 c2 = animatePlane(o, d, 2.03*sin(rtime.y), size1, vec2(0, 0), offset);\n    offset.y -= 2.5;\n    vec4 c3 = animatePlane(o, d, 2.03*sin(rtime.z), size, vec2(0, 0), offset);\n       \n    // Output to screen\n    fragColor = 0.39*(c1 + c2 + c3);\n}","name":"Image","description":"","type":"image"}]}