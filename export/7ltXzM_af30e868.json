{"ver":"0.1","info":{"id":"7ltXzM","date":"1638893686","viewed":318,"name":"Triangle integration (brute)","username":"mrboggieman","description":"Example of brute-force (per-pixel) averaging of a texture colour for a triangle (integral). Drag the mouse to change the triangle coord. Based on https://github.com/andrewlowndes/texture-filtering","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["filtering","mipmap","area","integral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//signed dist func from https://www.shadertoy.com/view/XsXSz4)\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Triangle tri = getTriangle(iMouse.xy);\n    float distToTri = sdTriangle(fragCoord, tri.p1, tri.p2, tri.p3);\n    \n    vec4 bgColour = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //if the pixel is within the triangle, draw our averaged value\n    if (distToTri < 0.5) {\n        vec4 areaColour = texelFetch(iChannel1, ivec2(0, 0), 0);\n        float blend = clamp(0.5-distToTri, 0.0, 1.0);\n        fragColor = mix(bgColour, areaColour, blend);\n        return;\n    }\n    \n    //otherwise just show the texture behind for reference\n    fragColor = bgColour;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Triangle {\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n};\n\nTriangle getTriangle(vec2 mouse) {\n    return Triangle(vec2(20.0, 20.0), mouse, vec2(450.0, 50.0));\n}\n\nstruct Aabb {\n    vec2 minPos;\n    vec2 maxPos;\n};\n\nstruct LineEquation {\n    float gradient;\n    float intersect;\n};\n\nstruct Line {\n    vec2 p1;\n    vec2 p2;\n};\n\nstruct LineRange {\n    vec2 pStart;\n    vec2 pEnd;\n    vec2 xRange;\n    LineEquation equation;\n};\n\nconst float epsilon = 0.00001;\n\nfloat vec2Determinant(vec2 p1, vec2 p2) {\n    return (p1.x * p2.y) - (p1.y * p2.x);\n}\n\nfloat inverseLerp(float a, float diff, float val) {\n    return clamp((val - a) / diff, 0.0, 1.0);\n}\n\nvec4 intersectLineSquare(vec2 pos, vec2 dir, Aabb bounds) {\n    return vec4(\n        inverseLerp(pos.x, dir.x, bounds.minPos.x),\n        inverseLerp(pos.x, dir.x, bounds.maxPos.x),\n        inverseLerp(pos.y, dir.y, bounds.minPos.y),\n        inverseLerp(pos.y, dir.y, bounds.maxPos.y)\n    );\n}\n\nvec4 sort(vec4 nums) {\n    float a = min(nums.x, nums.y);\n    float b = max(nums.x, nums.y);\n    float c = min(nums.z, nums.w);\n    float d = max(nums.z, nums.w);\n    float e = min(b, c);\n    float f = max(b, c);\n    float h = max(a, e);\n    float i = min(f, d);\n\n    return vec4(min(a, e), min(h, i), max(h, i), max(f, d));\n}\n\nLineEquation getLineEquation(Line line) {\n    vec2 direction = line.p2 - line.p1;\n\n    float gradient = direction.y / direction.x;\n    float intersect = line.p1.y - line.p1.x * gradient;\n\n    return LineEquation(gradient, intersect);\n}\n\nvec2[12] intersectTriangleSquare(Triangle triangle, Triangle edges, Aabb bounds) {\n    vec4 t1s = sort(intersectLineSquare(triangle.p1, edges.p1, bounds));\n    vec4 t2s = sort(intersectLineSquare(triangle.p2, edges.p2, bounds));\n    vec4 t3s = sort(intersectLineSquare(triangle.p3, edges.p3, bounds));\n    \n    return vec2[12](\n        clamp(triangle.p1 + edges.p1 * t1s.x, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p1 + edges.p1 * t1s.y, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p1 + edges.p1 * t1s.z, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p1 + edges.p1 * t1s.w, bounds.minPos, bounds.maxPos),\n\n        clamp(triangle.p2 + edges.p2 * t2s.x, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p2 + edges.p2 * t2s.y, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p2 + edges.p2 * t2s.z, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p2 + edges.p2 * t2s.w, bounds.minPos, bounds.maxPos),\n        \n        clamp(triangle.p3 + edges.p3 * t3s.x, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p3 + edges.p3 * t3s.y, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p3 + edges.p3 * t3s.z, bounds.minPos, bounds.maxPos),\n        clamp(triangle.p3 + edges.p3 * t3s.w, bounds.minPos, bounds.maxPos)\n    );\n}\n\nvoid sum_line(in uvec3 range, in bool isInside, inout vec4 colour, inout int numPixels, in sampler2D texture, in Triangle triangle, in Triangle edges) {\n    if (isInside) {\n        for (uint x=range.x; x<range.y; x++) {\n            colour += texelFetch(texture, ivec2(x, range.z), 0);\n        }\n    } else {\n        //process each outer pixel separately so we have per-pixel shading\n        uint yMax = range.z + uint(1);\n\n        for (uint x=range.x; x<range.y; x++) {\n            Aabb bounds = Aabb(vec2(x, range.z), vec2(x + uint(1), yMax));\n\n            //as a test, determine the coverage of the triangle in outside cells and use as antialiasing\n            vec2[12] polygon = intersectTriangleSquare(triangle, edges, bounds);\n            \n            float percentCoverage = clamp(abs((\n                vec2Determinant(polygon[0], polygon[1]) +\n                vec2Determinant(polygon[1], polygon[2]) +\n                vec2Determinant(polygon[2], polygon[3]) +\n                vec2Determinant(polygon[3], polygon[4]) +\n                vec2Determinant(polygon[4], polygon[5]) +\n                vec2Determinant(polygon[5], polygon[6]) +\n                vec2Determinant(polygon[6], polygon[7]) +\n                vec2Determinant(polygon[7], polygon[8]) +\n                vec2Determinant(polygon[8], polygon[9]) +\n                vec2Determinant(polygon[9], polygon[10]) +\n                vec2Determinant(polygon[10], polygon[11]) +\n                vec2Determinant(polygon[11], polygon[0])\n            ) / 2.0), 0.0, 1.0);\n\n            colour += texelFetch(texture, ivec2(x, range.z), 0) * percentCoverage;\n        }\n    }\n}\n\nfloat solveLineX(LineEquation equation, float y) {\n    if (abs(equation.gradient) > epsilon) {\n        return (y - equation.intersect) / equation.gradient;\n    } else {\n        return -1.0;\n    }\n}\n\nLineRange getLineRange(Line line) {\n    vec2 pStart;\n    vec2 pEnd;\n    \n    //TODO: make a branchless version\n    if (line.p1.y < line.p2.y) {\n        pStart = line.p1;\n        pEnd = line.p2;\n    } else if (line.p1.y > line.p2.y) {\n        pStart = line.p2;\n        pEnd = line.p1;\n    } else if (line.p1.x < line.p2.x) {\n        pStart = line.p1;\n        pEnd = line.p2;\n    } else {\n        pStart = line.p2;\n        pEnd = line.p1;\n    }\n\n    return LineRange(\n        pStart,\n        pEnd,\n        vec2(min(line.p1.x, line.p2.x), max(line.p1.x, line.p2.x)),\n        getLineEquation(line)\n    );\n}\n\nvec2 triangleMax(Triangle triangle) {\n    return max(max(triangle.p1, triangle.p2), triangle.p3);\n}\n\n\nvec2 triangleMin(Triangle triangle) {\n    return min(min(triangle.p1, triangle.p2), triangle.p3);\n}\n\nvoid sum_triangle(in Triangle triangle, inout vec4 colour, inout int numPixels, in sampler2D tex, in Triangle edges) {\n    vec2 minPos = triangleMin(triangle);\n    vec2 maxPos = triangleMax(triangle);\n\n    Line[3] lines = Line[3](\n        Line(triangle.p1, triangle.p2),\n        Line(triangle.p2, triangle.p3),\n        Line(triangle.p3, triangle.p1)\n    );\n\n    LineRange[3] lineRanges = LineRange[3](\n        getLineRange(lines[0]),\n        getLineRange(lines[1]), \n        getLineRange(lines[2])\n    );\n\n    int maxY = int(ceil(maxPos.y));\n    int prevY = int(minPos.y);\n\n    if (maxY - prevY < 1) {\n        sum_line(uvec3(minPos.x, maxPos.x, prevY), false, colour, numPixels, tex, triangle, edges);\n        return;\n    }\n\n    for (int y=prevY+1; y<=maxY; y++) {\n        //we just need to get four numbers, the outer min and max and inner min and max values\n        ivec4 range = ivec4(-1);\n\n        for (int i=0; i<3; i++) {\n            LineRange line = lineRanges[i];\n\n            if (line.pEnd.y >= float(prevY) && line.pStart.y < float(y)) {\n                float fromX = solveLineX(line.equation, float(prevY));\n\n                if (fromX > -1.0) {\n                    fromX = clamp(fromX, line.xRange.x, line.xRange.y);\n                } else {\n                    fromX = line.pStart.x;\n                }\n\n                float toX = solveLineX(line.equation, float(y));\n\n                if (toX > -1.0) {\n                    toX = clamp(toX, line.xRange.x, line.xRange.y);\n                } else {\n                    toX = line.pEnd.x;\n                }\n\n                ivec2 xRange = ivec2(min(fromX, toX), max(fromX, toX));\n\n                if (range.x < 0) {\n                    //first entry\n                    range.xy = xRange;\n                } else if ((xRange.x <= range.y + 1 && xRange.x >= range.x - 1) || (xRange.y <= range.y + 1 && xRange.y >= range.x - 1)) {\n                    //extends the first entry\n                    range.xy = ivec2(min(range.x, xRange.x), max(range.y, xRange.y));\n                } else if (range.z < 0) {\n                    //must be a new second range, determine if we need to swap or not to keep them ordered\n                    if (xRange.x > range.y) {\n                        range.zw = xRange;\n                    } else {\n                        range = ivec4(xRange, range.xy);\n                    } \n                } else {\n                    //extends the second range\n                    range.zw = ivec2(min(range.z, xRange.x), max(range.w, xRange.y));\n                }\n            }\n        }\n\n        //we have an inside\n        if (range.z > range.y) {\n            sum_line(uvec3(range.x, range.y, prevY), false, colour, numPixels, tex, triangle, edges);\n            sum_line(uvec3(range.y + 1, range.z - 1, prevY), true, colour, numPixels, tex, triangle, edges);\n            sum_line(uvec3(range.z, range.w, prevY), false, colour, numPixels, tex, triangle, edges);\n        } else {\n            sum_line(uvec3(range.x, max(range.y, range.w), prevY), false, colour, numPixels, tex, triangle, edges);\n        }\n\n        prevY = y;\n    }\n}\n\nfloat triangleArea(Triangle triangle) {\n    return abs((\n        vec2Determinant(triangle.p1, triangle.p2) +\n        vec2Determinant(triangle.p2, triangle.p3) +\n        vec2Determinant(triangle.p3, triangle.p1)\n    ) / 2.0);\n}\n\nvec4 triangleCoverage(Triangle triangle, sampler2D tex) {\n    float area = triangleArea(triangle);\n\n    Triangle edges = Triangle(triangle.p2 - triangle.p1, triangle.p3 - triangle.p2, triangle.p1 - triangle.p3);\n\n    vec4 colour = vec4(0.0);\n    int numPixels = 0;\n\n    sum_triangle(triangle, colour, numPixels, tex, edges);\n    return colour / area;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//just evaluate the one triangle for now and put the pixel in a buffer so we can reuse across many pixels\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Triangle tri = getTriangle(iMouse.xy);\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n       fragColor = triangleCoverage(tri, iChannel0);\n    } else {\n       fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}