{"ver":"0.1","info":{"id":"X3XGWX","date":"1707961821","viewed":126,"name":"black hole and disk - blue","username":"anctst","description":"less step, higher quality","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["blackhole","raymatching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random_f(vec2 p)\n{\n    vec2 pp = p;\n    pp.x = mod(pp.x, 48.0);\n\n    float a = dot(pp, vec2(12.1716, 39.1172));\n    a = sin(a) * 25.214f;\n\n    return abs(fract(a)*2.0 - 1.0);\n}\n\n\nfloat mathFunc(float x) // disk brightness relates to distance\n{\n    return 1.0 / (exp(15.0*(3.0-x)) + 1.0) - 1.0 / (exp(2.0*(6.6-x)) + 1.0);\n}\n\n\nfloat brightness(vec2 p) // fbm noise\n{\n    float lp = length(p);\n    float phi = acos(p.x/lp)/6.2831853072 -0.5;\n    phi = 0.5 + sign(p.y)*phi;\n\n    vec2 r = vec2(48.0*phi + iTime*0.5 - iMouse.x*0.03 - lp*6.0, lp*8.0 + iTime*0.6);\n\n    float result = 0.0;\n    float muilt = 1.0;\n\n    for(int i = 0; i < 4; i += 1){\n\n        vec2 ri = floor(r);\n        vec2 rf = fract(r);\n        vec2 fr = 1.f - rf;\n\n        float a1 = random_f(ri);\n        float a2 = random_f(ri + vec2(1.f, 0.f));\n        float a3 = random_f(ri + vec2(0.f, 1.f));\n        float a4 = random_f(ri + vec2(1.f, 1.f));\n\n        result += (fr.y * (a1*fr.x + a2*rf.x) + rf.y * (a3*fr.x + a4*rf.x)) / muilt;\n\n        muilt *= 1.7;\n        r *= 2.0;\n    }\n\n    return result * 2.0 * mathFunc(lp);\n    //return 2.0 * mathFunc(lp);\n}\n\n\nvec3 colorMix(float t)\n{\n    if(t == 0.0){\n        return vec3(0.0);\n    }\n\n    vec3 c1 = vec3(0.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.0, 0.3, 0.9);\n    vec3 c3 = vec3(1.0, 1.0, 1.0);\n\n    t = 1.0 - exp(-0.6*t);\n    float s = 1.0 - t;\n    vec3 col = s*s*c1 + 2.0*s*t*c2 + t*t*c3;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    float angle = iResolution.y * 0.52 - iMouse.y;\n    float ss = sin(angle*0.01);\n    float cc = cos(angle*0.01);\n    float dr = 0.4; // step length\n    float pi2 = 6.28318531;\n    float init_r = 13.0, R = 10.7; // camera distance ; disk radius\n    float dt;\n\n    vec3 vct_r = vec3(init_r*cc, 0.0, init_r*ss);\n    vec3 vct_v = vec3(-1.25*cc -uv.y*ss, uv.x, uv.y*cc -1.25*ss) / length(vec3(1.0, uv.x, uv.y));\n    float crs = length(cross(vct_r, vct_v));\n    float c00 = -1.5*crs*crs;\n\n    float r = 3.0;\n    float dlt, phi, a, b, c, l1, l2;\n    vec3 dlt_dr;\n    vec3 last_r = vct_r;\n    last_r.z *= 100.0;\n    float col = 0.0;\n    float dcol, t;\n\n    while(r > 1.0 && r < init_r + 0.001)\n    {\n        r = length(vct_r);\n        dt = dr / length(vct_v);\n\n        vct_v += c00/(r*r*r*r*r)*dt * vct_r;\n        dlt_dr = vct_v * dt;\n        vct_r += dlt_dr;\n        dlt_dr.z *= 100.0;\n\n        a = dot(dlt_dr, dlt_dr);\n        b = dot(dlt_dr, last_r);\n        c = dot(last_r, last_r) - R*R;\n        dlt = b*b - a*c;\n\n        dcol = mathFunc(length(vct_r.xy));\n\n        l1 = length(last_r);\n        l2 = length(last_r + dlt_dr);\n\n        if(l1 > R){\n            if(l2 < R){\n                t = -(b + sqrt(dlt)) / a;\n                col += (1.0 - t) * dcol;\n                col += brightness(t*dlt_dr.xy + last_r.xy);\n            }else{\n                if(dlt > 0.0 && -b/a < 1.0 && b <= 0.0){\n                    t = -(b + sqrt(dlt)) / a;\n                    col += 2.0 * sqrt(dlt) / a * dcol;\n                    col += brightness(t*dlt_dr.xy + last_r.xy);\n                }\n            }\n        }else{\n            if(l2 > R){\n                col += (-b + sqrt(dlt)) / a * dcol;\n            }else{\n                col += dcol;\n            }\n        }\n        last_r = vct_r;\n        last_r.z *= 100.0;\n    }\n\n    fragColor = vec4(colorMix(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}