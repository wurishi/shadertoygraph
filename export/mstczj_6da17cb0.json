{"ver":"0.1","info":{"id":"mstczj","date":"1695334361","viewed":121,"name":"Even better distance field gen","username":"Carandiru","description":"Fast Sweeping Method of distance field generation. version 2.\n[distance]\nclick to focus magnifying glass","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["distance","field","generation","eikonal","fsm"],"hasliked":0,"parentid":"DsccRM","parentname":"distance field gen testing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fast Sweeping Method of distance field generation. version 2.\n//\n// full neighbourhood w/ rounding of contours, better interpolation -- buffer A\n// \n// *click to focus magnifying glass*\n//\n// [distance]\n\n\n// https://www.shadertoy.com/view/3sdyRH - oneshades magnification (modified)\nconst float lensBorderColor = 0.0;\nconst float lensBorderWidth = pi*2.0f;\nconst float lensRadius = 1024.0f*0.5f*0.5f*0.66f;\nconst float lensMag = 6.0;\n\nconst float _halfBorderWidth = lensBorderWidth / 2.0;\nconst float _innerRadius = lensRadius - _halfBorderWidth;\nconst float _outerRadius = lensRadius + _halfBorderWidth;\n\nvec2 offset(in bool mouseActive) { return(vec2(mix(iTime*21.8034f, iTime*21.8f, mouseActive), 0.0f)); }\n\nbool magnify(inout float sampling, in vec2 fragCoord) {\n    float sinTime = sin(0.15 * iTime);\n    float cosTime = cos(0.15 * iTime);\n    vec2 mousePos = 0.5 * R + vec2(cosTime * R.x * 0.390625, sinTime * cosTime * R.y * 0.520833); // automove\n    \n    bool mouseActive = (iMouse.z > 0.0);\n    \n    if (mouseActive) {\n        mousePos = iMouse.xy;\n    }\n\n    float dist = sqrt(pow(fragCoord.x - mousePos.x, 2.0) + pow(fragCoord.y - mousePos.y, 2.0));\n\n    bool inside_lens = (dist <= _innerRadius);\n    \n    if (inside_lens) {\n        vec2 coord = mousePos + ((fragCoord - mousePos) / lensMag);\n        float unfocused = length(fragCoord - coord)*0.01618034f;\n        float focused = mix(0.5f + unfocused*pow(unfocused * 0.5f, 5.0f), 0.0f, mouseActive);\n        float zoomed = textureLod(iChannel0, (coord + offset(mouseActive)) / R, focused ).x;\n        sampling = mix(zoomed*(1.0f - sampling), zoomed, mouseActive);\n    }\n    \n    if (dist > _innerRadius && dist <= _outerRadius) {\n        sampling = lensBorderColor;\n    }\n    \n    return(inside_lens);\n}\n\nconst vec3 gui_green = vec3(266.666e-3f, 913.725e-3f, 537.254e-3f);\nconst vec3 gui_bleed = vec3(619.607e-3f, 1.0f, 792.156e-3f);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{                   \n    float sampling = textureLod(iChannel0, (fragCoord + offset(false)) / R, 0.0f).x;\n    bool inside_lens = magnify(sampling, fragCoord);\n    \n    sampling *= 100.0f; // amplify distance field so it is visible\n    \n    // dither gently\n    float bn = textureLod(iChannel2, fragCoord / 1024.0f, 0.0f).r;\n    \n    vec3 color = vec3(sampling);\n    color = color + sampling * gui_bleed * bn + bn * (17.0f/255.0f);\n    \n    // night-vision magnifying lens\n    if (inside_lens) {\n        \n        vec3 lens_color = gui_bleed * gui_bleed;\n        \n        if ( bool(int(fragCoord.y) & 1) ) {\n            sampling = sampling*sampling;\n            lens_color = gui_green * gui_green;\n        }\n        \n        if (iFrame % 240 < 120) {\n            lens_color = vec3(2); // periodic boost gray (disable if you want green lens all the time)\n        }\n        \n        color = sampling * lens_color + gui_bleed * bn * (17.0f/255.0f); // shows distance field edging / interior structure better\n    }\n    \n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fast Sweeping Method of distance field generation. version 2.\n//\n// ChatGPT suggests FSM over jumpflooding, especially for large resolution / grid sizes!\n// \n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / R;\n    \n    float gridSize = length(R);\n    float invgridSize = (1.0f)/gridSize;\n    \n    vec2 gridPos = vec2(uv * R);\n              \n    float minDistance = 1.0f;\n\n    const int target = 12; // if only moore neighbourhood - *12* iterations finishes distance field (capturing enough distance detail and full range)\n                           // if full neighbourhood       - *12*  iterations   \"\"        \"\"      \"\"      !!!\n    if (bool(iFrame < target))\n    {\n        minDistance = 1.0f - step(0.5f, length(textureLod(iChannel1, uv, 0.0f).rgb));\n        \n        // Perform the fast sweeping \n\n        \n        // side adjacent neighbours:\n        \n        vec2 rounded = invgridSize * vec2(cos(pi/4.0f), sin(pi/4.0f)); // **removes \"diamond\" \"square\" and replaces with \"circular\" holes and distances\n        \n        // forward\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2(-1, 0)).r + rounded.x);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 1, 0)).r + rounded.x);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 0,-1)).r + rounded.y);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 0, 1)).r + rounded.y);\n\n        // reverse\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 1, 0)).r + rounded.x);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2(-1, 0)).r + rounded.x);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 0, 1)).r + rounded.y);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 0,-1)).r + rounded.y);\n\n\n   \n        // corner adjacent neighbours:\n            \n            // *redundant invgridsize equals the length   invgridSize = length(rounded.xy);  // for corners only\n        \n        // forward\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2(-1,-1)).r + invgridSize);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 1, 1)).r + invgridSize);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 1,-1)).r + invgridSize);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2(-1, 1)).r + invgridSize);\n\n        // reverse\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 1, 1)).r + invgridSize);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2(-1,-1)).r + invgridSize);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2(-1, 1)).r + invgridSize);\n        minDistance = min(minDistance, textureLodOffset(iChannel0, gridPos/R, 0., ivec2( 1,-1)).r + invgridSize);\n    }\n    else {\n        minDistance = textureLod(iChannel0, uv, 0.0f).r;\n    }\n    \n    \n    \n    \n    fragColor = vec4(minDistance, 0.0f, 0.0f, 0.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define t iTime\n#define dt iTimeDelta\n#define ff float(iFrame)\n#define pi 3.14\n\n\n#define fma(a,b,c) (a*b+c)\nvec2 rotate( in vec2 p, in vec2 cossin )\n{\n\t#define c_ x\n\t#define s_ y\n\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\nvec2 rotate( in vec2 p, in float angle )\n{\n    return rotate(p, vec2(cos(angle), sin(angle)));\n}\n\nvec2 diamondize(in vec2 uv, in float resolution) // original - dominionxvii - https://www.shadertoy.com/view/dlBfz1\n{\n    vec2 diamondUV = rotate(uv, radians(45.));\n    diamondUV = floor(diamondUV * resolution) / resolution;\n    diamondUV = rotate(diamondUV, -radians(45.));\n    \n    return diamondUV;\n}","name":"Common","description":"","type":"common"}]}