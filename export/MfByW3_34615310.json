{"ver":"0.1","info":{"id":"MfByW3","date":"1723059282","viewed":91,"name":"// _ball_8.1 HLSL","username":"oleg304","description":"just modified shader for star","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","star","hlsl"],"hasliked":0,"parentid":"Mfjczy","parentname":"red star"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//// forked from https://www.shadertoy.com/view/Mfjczy\n\n//// GLSL -> HLSL\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define lerp     mix\n#define atan2    atan\n#define frac     fract\n#define fmod     mod\n#define float2x2 mat2     \n#define mul(a, b) a*b \n#define texSampl 1.\n#define Texture2DSample(iChannel0, texSampl, uv) texture(iChannel0, uv)\n#define ddx dFdx\n#define ddy dFdy\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n//// end GLSL -> HLSL\n\n//// stuct for UE material custom node\n\n// struct Func {\n\nfloat rand(float2 n) {return frac(sin(dot(n, float2(12.9898, 78.233))) * 43758.5453);}\n\nfloat noise(float2 p) {\n    float2 i = floor(p), f = frac(p);\n    f = f*f*(3.-2.*f);\n    return lerp(lerp(rand(i), rand(i + float2(1.,0.)), f.x), lerp(rand(i + float2(0.,1.)), rand(i+float2(1.,1.)), f.x), f.y);\n}\n\nfloat fbm(float2 p) {\n    float v = 0., a = .5;\n    for (int i = 0; i < 5; i++) {v+=a*noise(p); p*=2.; a*=.5;}\n    return v;\n}\n\nfloat noiseImage(float2 uv) {return fbm(uv*10.);}\n\nfloat snoise(float3 uv, float res) {\n\tconst float3 s = float3(1e0, 1e2, 1e4);\n\tuv *= res;\n\tfloat3 uv0 = floor(fmod(uv, res))*s;\n\tfloat3 uv1 = floor(fmod(uv+float3(1.,1.,1.), res))*s;\n\tfloat3 f = frac(uv); f = f*f*(3.-2.*f);\n\tfloat4 v = float4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z, uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\tfloat4 r = frac(sin(v*1e-3)*1e5);\n\tfloat r0 = lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y);\n\tr = frac(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y);\n\treturn lerp(r0, r1, f.z)*2.-1.;\n}\n\nfloat res(float2 uv, float time) {\t\n    time *= 0.1;\n\tfloat aspect = 1.7, iColor = 1., brightness = .1, starSphere= 0.;\n    \n\tfloat radius\t= .24 + brightness*.2;\n\tfloat invRadius = 1./radius;\n\tfloat2 p \t\t= -.5 + uv;\n\tp.x *= aspect;\n\tfloat fade\t\t= pow(length(2.*p),.5);\n\tfloat fVal\t\t= 1.-fade;\n\tfloat angle\t\t= atan2( p.x, p.y )/3.14;\n\tfloat dist\t\t= length(p);\n\tfloat3 coord\t= float3(angle, dist, time*.1);\n    float corona\t= pow(fVal* max(1.1-fade,0.),2.)*50.;\n\tcorona\t\t\t+= pow(fVal*max(1.1-fade,0.),2.)*50.;\n\tcorona\t\t\t*= 1.2-abs( snoise( coord + float3(0.,-time*(.35+brightness*.001),time*.015),15.));\t\n\tfloat2 sp = -1.+2.* uv;\n\tsp.x *= aspect;\n\tsp *= ( 2. - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.-sqrt(abs(1.-r)))/(r)+brightness*.5;\n\tif( dist < radius ){\n\t\tcorona *= pow(dist*invRadius,24.);\n  \t\tfloat2 newUv = sp*f;\n\t\tnewUv += float2(time,0.);\n\t\tfloat texSample\t= noiseImage(newUv);\n\t\tfloat uOff\t= (texSample * brightness*4.5+time);\n\t\tfloat2 starUV = newUv + float2(uOff, 0.);\n\t\tstarSphere\t= noiseImage(starUV);\n\t}\n    return f*(.75+brightness*.3)+starSphere*iColor*.3+corona*iColor;\n    }\n \n// float iTime; }; Func f; return f.res(in_uv, in_time);\n//// end HLSL part\n\n//// HLSL -> ShaderToy\nvoid mainImage(out float4 fragColor, in float2 fragCoord) {\n    float t = iTime;\n    float2 uv\t= fragCoord.xy / iResolution.xy;\n    fragColor = vec4(res(uv, t)*vec4(.2,.5,1.,1.));\n}","name":"Image","description":"","type":"image"}]}