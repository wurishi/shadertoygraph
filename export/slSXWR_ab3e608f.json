{"ver":"0.1","info":{"id":"slSXWR","date":"1627402529","viewed":108,"name":"HSL Color Line Shadebobs","username":"bloxard","description":"Animated HSL colored line generating the old school Shadebobs effect. \nI needed to make a test of the simplest shader that I could think of that used multiple accumulating screen buffers.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["line","hsl","multipass","accumulate","shadebobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Per Bloksgaard, 2021 - https://perbloksgaard.dk\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0,fragCoord.xy/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n\tfloat bL = length(lE-lS);\n\tvec3 bD = (lE-lS)/bL;\n\tvec3 tD = lS-rP;\n\tfloat aDb = dot(rD,bD);\n\tfloat aDt = dot(rD,tD);\n\tfloat bDt = dot(bD,tD);\n\tfloat u = (aDt-bDt*aDb)/(1.-aDb*aDb);\n\tfloat v = max(min(u*aDb-bDt,bL),0.);\n\tu = max(min(v*aDb+aDt,1e6),0.);\n\treturn length((rP+rD*u)-(lS+bD*v));\n}\n\nvec3 HSL2RGB_CubicSmooth(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z+ c.y*(rgb-0.5)*(1.-abs(2.*c.z-1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 s = (-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n\tvec3 vCamPos = vec3(cos(iTime)*1.6,0.0,sin(iTime)*1.6);\n\tvec3 vCamTarget = vec3(cos(-iTime*0.21)*0.1,cos(iTime*0.12)*0.1,sin(iTime*0.15)*0.1);;\n\tvec3 vCamForward = normalize(vCamTarget-vCamPos);\n\tvec3 vCamRight = normalize(cross(vCamForward,vec3(0.,1.,0.)));\n\tvec3 vCamUp = normalize(cross(vCamRight,vCamForward));\n\tvec3 vRayDir = normalize(s.x*vCamRight+s.y*vCamUp+vCamForward*0.5);\n\n\tvec3 so = vec3(cos(0.174-iTime*0.747),sin(-0.33+iTime* 1.176),0.213+cos(0.3+iTime*1.713));\n\tvec3 sd = vec3(sin(0.433+iTime*1.723),cos(0.172+iTime*-1.331),0.635+sin(0.9-iTime*0.534));\n\t\n\tfloat dist = RayLineSegmentDistance(vCamPos, vRayDir, so, sd);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 color = clamp(texture(iChannel0,uv).xyz,0.,1.);\n    color *= 0.993+sin(iTime*0.6)*7e-3;\n\tvec3 hsl = HSL2RGB_CubicSmooth(vec3(sign(sin(iTime*0.13))*(fract(iTime*0.13)*6. - dist*7.2),1.,clamp(0.52-dist*0.52,0.,0.6)));\n    color += hsl * max(1.-dist*6.5,0.);\n    fragColor = vec4(color,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}