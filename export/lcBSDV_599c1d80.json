{"ver":"0.1","info":{"id":"lcBSDV","date":"1706831744","viewed":52,"name":"Sdf","username":"Mathtician","description":"Simple implementation of 4D signed distance functions, used to render a tiger","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float camDist = 5.0; // Distance of camera from origin\nconst float camRange = 2.0; // Max distance of hyperplane from origin\nvec4 camPos;\nmat3x4 camOri;\n\n// Tiger of radius 1: change this and sdf4_grad to render other shapes\nfloat sdf4(in vec4 rayPos4) {\n    vec2 v1 = rayPos4.xy;\n    vec2 v2 = rayPos4.zw;\n    vec2 v3 = vec2(length(v1)-1.0, length(v2)-1.0);\n    return length(v3)-0.5;\n}\n\n// Gradient of SDF: used for surface normals\nvec4 sdf4Grad(in vec4 rayPos4) {\n    vec2 v1 = rayPos4.xy;\n    vec2 v2 = rayPos4.zw;\n    vec2 v3 = vec2(length(v1)-1.0, length(v2)-1.0);\n    vec2 d1 = normalize(v1);\n    vec2 d2 = normalize(v2);\n    // Next normalize is unnecessary because 3D SDF is normalized,\n    // but kept for mathematical correctness\n    vec2 d3 = normalize(v3);\n    return vec4(d3.x*d1, d3.y*d2);\n}\n\n// Convert 3D camera coords to 4D and compute 4D SDF\nfloat sdf(in vec3 rayPos) {\n    vec4 rayPos4 = camOri*rayPos+camPos;\n    return sdf4(rayPos4);\n}\n\n// Use chain rule to turn 4D gradient into 3D gradient in camera coords\nvec3 sdfGrad(in vec3 rayPos) {\n    vec4 rayPos4 = camOri*rayPos+camPos;\n    vec4 normal4 = sdf4Grad(rayPos4);\n    return normal4*camOri;\n}\n\nfloat marchRay(inout vec3 rayPos, in vec3 rayDir, in int nIters) {\n    float dist;\n    // Take n_iters steps towards the object\n    for (int i = 0; i < nIters; i++) {\n        dist = sdf(rayPos);\n        rayPos += rayDir*dist;\n    }\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Parameter to control with mouse position:\n    // used to move hyperplane, but try substituting for some coords of quat1 or quat2\n    // (and uncommenting camPos = camPosBase) to control rotation of hyperplane instead\n    float xNorm = float(iMouse.x)/iResolution.x*2.0-1.0;\n    float yNorm = float(iMouse.y)/iResolution.x*2.0-1.0;\n\n    // Camera orientation in 4d defined by 2 unit quaternions\n    vec4 quat1 = normalize(vec4(1.1, 1.0, 1.5, 0.0));\n    vec4 quat2 = normalize(vec4(0.4, 0.0, 0.0, 1.0));\n    \n    mat4 rot1 = mat4 (\n        quat1.xyzw * vec4(+1.0, +1.0, +1.0, +1.0),\n        quat1.yxwz * vec4(-1.0, +1.0, -1.0, +1.0),\n        quat1.zwxy * vec4(-1.0, +1.0, +1.0, -1.0),\n        quat1.wzyx * vec4(-1.0, -1.0, +1.0, +1.0));\n    mat4 rot2 = mat4 (\n        quat2.xyzw * vec4(+1.0, +1.0, +1.0, +1.0),\n        quat2.yxwz * vec4(-1.0, +1.0, +1.0, -1.0),\n        quat2.zwxy * vec4(-1.0, -1.0, +1.0, +1.0),\n        quat2.wzyx * vec4(-1.0, +1.0, -1.0, +1.0)\n    );\n    mat4 rot = rot1 * rot2;\n    \n    camOri = mat3x4 (rot[0], rot[1], rot[2]);\n    vec4 camPosBase = -camDist*rot[2]; // +z points toward origin in central cross-section\n    vec4 camPosDir = rot[3]; // Cross-sections move perpendicular to hyperplane\n\n    // Move hyperplane based on mouse position (or not, if line below is uncommented)\n    camPos = camPosBase+xNorm*camPosDir*camRange;\n    // camPos = camPosBase;\n\n    // Pixel coordinates from -1 to 1 in x, proportional in y\n    vec2 uv = fragCoord/iResolution.x*2.0-vec2(1.0, iResolution.y/iResolution.x);\n\n    // Direction of ray cast \n    float fov = 1.0;\n    vec3 rayDir = normalize(vec3(uv*fov, 1.0));\n\n    // March ray from camera\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    float dist = marchRay(rayPos, rayDir, 50);\n    float epsilon = 0.001;\n    float onSurface = float(dist < epsilon);\n    vec3 normal = normalize(sdfGrad(rayPos));\n    \n    vec3 lightDir = normalize(vec3(1.0, 0.0, -1.0));\n    \n    // Color determined by surface normal\n    float dirBrightness = 0.5;\n    float ambBrightness = 0.3;\n    float lightStrength = max(dot(normal, lightDir)*ambBrightness, 0.0)+ambBrightness;\n    vec3 surfaceCol = vec3(1.0, 1.0, 0.0);\n    \n    \n    // If the last step was sufficiently small, assume on the surface\n    fragColor = vec4(onSurface * lightStrength * surfaceCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}