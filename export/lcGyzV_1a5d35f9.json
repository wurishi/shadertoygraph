{"ver":"0.1","info":{"id":"lcGyzV","date":"1732097884","viewed":102,"name":"Scratch Hologram Experiment","username":"sirjofri","description":"scratch hologram simulation - best viewed in fullscreen (use r to  regenerate the scratch texture)\n\nFor some reason, in the \"upper\" part of the light cycle, the parallax effect \"breaks\", especially in the small viewport.","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["hologram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Scratch Hologram Simulation\n    \n    - Buffer A is heavy and generates the scratch texture in the first frame\n    - Image calculates the light response to the scratch texture\n    - So, to generate the scratch texture, you have to restart the shader\n    - Press R to repaint (useful in fullscreen mode)\n    \n    Use the mouse to move the light\n\n*/\n\nvec3 light;\n\nfloat calcspec(vec3 n)\n{\n    float d = dot(n.xy, light.xy);\n    return smoothstep(0.995, 1., d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.5);\n    \n    //uv.x *= iResolution.x/iResolution.y;\n    vec4 holo = texture(iChannel1, uv);\n    \n    if (iMouse.z > 0.)\n        light = vec3(normalize(vec2(mouse.x, mouse.y)), .5);\n    else\n        light = vec3(normalize(vec2(cos(iTime), sin(iTime))), .5);\n    \n    \n    float spec = calcspec(holo.xyz) * holo.w;\n\n    float tex = textureLod(iChannel0, uv * zoom, lod).x;\n    float tmix = mix(spec, tex, 0.1);\n\n    // replace tmix with holo.xyz to view the scratch texture\n    fragColor = vec4(vec3(tmix), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define X 32\n#define Y 32\n/* for best visuals, set BX and BY to 4 in fullscreen mode */\n#define BX 1\n#define BY 1\n\n// Adding noise doesn't _really_ change a thing, plus it uses an additional sampler\n#define NOISE 0\n\nfloat sampl(vec2 uv)\n{\n    return textureLod(iChannel0, uv * zoom, lod).x;\n}\n\nvec3 s2circle(vec2 uv, float h)\n{\n    float offset = 0.0;    // offset to the bottom to get arc within image\n    float minrad = 0.0;    // minimum radius, since we offset the image\n    float maxheight = 0.1; // adjust the height-to-radius\n    return vec3(uv - vec2(0., offset), h*maxheight + minrad);\n}\n\nfloat scratchwid;\nvec4 drawcircle(vec2 uv, vec3 c)\n{\n    float d = distance(uv, c.xy);\n    float m = step(c.z - scratchwid, d);\n    m -= step(c.z + scratchwid, d);\n    \n    vec2 n = normalize(uv - c.xy);\n    \n    return vec4(vec3(n, 0.5), m);\n}\n\nfloat rand(int i)\n{\n#if NOISE == 1\n    return texelFetch(iChannel3, ivec2(i%64, i/64), 0).x;\n#else\n    return 1.;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    scratchwid = 1.5/iResolution.x;\n    \n    float repaint = texelFetch(iChannel2, ivec2(82, 1), 0).x;\n    if (repaint < 0.5) {\n        if (iFrame > 0) {\n            fragColor = texture(iChannel1, uv);\n            return;\n        }\n    }\n    \n    vec3 circles[X * Y];\n    vec3 normal = vec3(0., 0., 1.);\n    float mask = 0.;\n    \n    vec2 baseoffset = vec2(1./float(BX), 1./float(BY));\n    \n    for (int bx = 0; bx < BX; bx++) {\n        for (int by = 0; by < BY; by++) {\n            vec2 off = baseoffset * vec2(float(bx), float(by));\n            for (int x = 0; x < X; x++) {\n                for (int y = 0; y < Y; y++) {\n                    vec2 xy = vec2(float(x)/float(X), float(y)/float(Y)) / vec2(float(BX), float(BY));\n                    xy += off;\n                    circles[y*X + x] = s2circle(xy, sampl(xy));\n                }\n            }\n\n            for (int i = 0; i < X*Y; i++) {\n                vec4 drawn = drawcircle(uv, circles[i]);\n                if (drawn.w > 0.5 && (mask < 0.5 || rand(i) > 0.5)) {\n                    normal = drawn.xyz;\n                    mask = 1.;\n                }\n            }\n        }\n    }\n\n    fragColor = vec4(normal, mask);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float zoom = 1.;\nfloat lod = 0.;","name":"Common","description":"","type":"common"}]}