{"ver":"0.1","info":{"id":"4sGGDy","date":"1456093907","viewed":313,"name":"Raytrace Collab v2","username":"alleycatsphinx","description":"Second version of a collaborative project","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["distancefields","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ro, rd is ray origin and ray direction\n\nconst vec3 sunDir = normalize(vec3(0.5, 0.5, 0.5));\nconst float waterHeight = 50.0;\n\nconst float tmin = 0.1;\nconst float tmax = 10000.0;\n\n// Colors\nconst vec4 skyColor = vec4(0.3, .55, 0.76, 1.0);\n\nconst vec4 dirtColor = vec4(0.55, .5, 0.3, 1.0);\n\nfloat bound(float angle)\n{\n\treturn max(angle, .00392156);\n}\n\nfloat fold(in float x)\n{\n\treturn bound(abs(fract(x)-.5));\n}\n\nvec3 fold(in vec3 p)\n{\n\treturn vec3(fold(p.x), fold(p.y), fold(p.z));\n}\n\nfloat origami(in vec3 position)\n{\n\tfloat amplitude = .5;\t\n    float frequency\t= 2.;\n\tfloat result\t= 0.;\n\tfor(int i = 0; i < 4; i++)\n\t{\n        position \t+= fold(position + fold(position).yzx).zxy;\n        position \t*= frequency;\n        position\t+= .0125;\n        result\t\t+= length(position)*amplitude;\n\t\tamplitude \t*= .5;\n\t}\n\treturn result;\n}\n\n// Height map\nfloat terrain(vec2 x)\n{\n    vec2 uv = vec2(0.5, 0.5) + (x / iResolution.xy / 20.0);\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)\n        return 0.0;\n    vec4 d \t\t\t= texture(iChannel0, uv);\n    float size \t\t= 256.0;\n    return (d.r * size + d.g * size * size) / 50.0;\n    //return 0.0;\n}\n\n\nfloat distTerrain(vec3 pos)\n{\n    float heightmap \t= terrain(pos.xz);\t\n  \n    float volume \t\t= origami(vec3(pos.x - heightmap * 3., pos.y - heightmap * 8., pos.z)*.00035);   \n \t\n    volume\t\t\t\t*= 128.;\n    heightmap\t\t\t*= 1.125;\n    \n    return pos.y - heightmap + volume;\n}\n\nfloat traceTerrain(vec3 ro, vec3 rd)\n{\n    float t \t= tmin;\n    bool h \t\t= false;\n    for (int i = 0; i < 256; i++) \n    {\n\t\tif(!h)//confusingly faster this way, at least on my machine\n        {\n        \tvec3 pos \t= ro + t * rd;\n\n        \tfloat dist \t= distTerrain(pos);\n\t\t\tt \t\t\t= t + dist * .35;\n\t        h \t\t\t= dist < (0.005 * t) || t > tmax;;\n\n            \n        }\n    }\n    return t;\n}\n\n// Rendering\n\nfloat shadow(const in vec3 position, const in vec3 direction)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= 5.95;\n\tfloat umbra\t\t= .005;\n\t\n    \tfor(int i = 1; i < 12; ++i)\n    \t{\n\t\tfloat range\t= max(0., distTerrain(position + direction * penumbra));\n\t\t\n\t\tif ( range < umbra) return umbra;\n\t\t\n\t\texposure \t= min( exposure, 3. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t\n\treturn clamp(exposure, 0., 1.);\n}\n\n\nvec3 renderSky(vec3 ro, vec3 rd)\n{\n \treturn skyColor.rgb - rd.y * .75;   \n}\n\nvec3 hsv(in float h, in float s, in float v){\n    return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\nvec3 tetraNormal(const in vec3 position, const in float epsilon)\n{\n\tvec2 offset = vec2(epsilon, -epsilon);\n\tvec4 simplex = vec4(0.);\n\tsimplex.x = distTerrain(position + offset.xyy);\n\tsimplex.y = distTerrain(position + offset.yyx);\n\tsimplex.z = distTerrain(position + offset.yxy );\n\tsimplex.w = distTerrain(position + offset.xxx);\n\t\n\tvec3 normal = offset.xyy * simplex.x + offset.yyx * simplex.y + offset.yxy * simplex.z + offset.xxx * simplex.w;\n\treturn normalize(normal);\n}\n\nvec3 terrainNormal(vec3 pos, float t) // (thanks iq again)\n{\n    vec2 eps = vec2(0.001 * t, 0.0);\n    return normalize(vec3(\n        terrain(pos.xz - eps.xy) - terrain(pos.xz + eps.xy), \n        2.0 * eps.x,\n        terrain(pos.xz - eps.yx) - terrain(pos.xz + eps.yx)\n    ));\n}\n\nvec3 zonal_harmonic(vec3 normal, vec3 light_direction)\n{\n    vec3 light\t\t\t= vec3(0.);   \n\tvec4 n4\t\t\t\t= vec4(normalize(normal+light_direction), 1.);\n    \n    //offsets for direction and spread of red, green and blue\n    vec4 red\t\t\t= vec4(  0.7,  .9,  0.4,  0.4);\n    vec4 green\t\t\t= vec4(  0.4,  .6,  -.1,  0.1);\n    vec4 blue\t\t\t= vec4(  0.2,  .35,  -.4,  -.2);   \n\n    light.r \t\t\t= dot(  red, n4); \n\tlight.g \t\t\t= dot(green, n4);\n\tlight.b \t\t\t= dot( blue, n4);\n    \n    return light;\n}\n\nvec3 renderTerrain(vec3 ro, vec3 rd, float t)\n{\n    vec3 pos \t\t\t= ro + rd * t;\n    vec3 norm \t\t\t= tetraNormal(pos, t*.00125);\n    norm\t\t\t\t= (norm);\n    \n    float upward_face\t= clamp(pow(norm.y, .5), 0., 1.);\n  \n    vec3 col \t\t\t= dirtColor.rgb;\n\n    vec3 stripes\t\t= hsv(1.-length(norm.xz)*4.+pos.y*.1*norm.y*.125, .4, 1.);\n    col\t\t\t\t\t= mix(col, stripes, 1.-upward_face);\n    \n    norm\t\t\t\t= normalize(norm + terrainNormal(pos, t));\n   \n    vec3 light_color \t= zonal_harmonic(norm, sunDir);\n\t\n    float shadows\t\t= shadow(pos+sunDir, sunDir);\n    \n    \n    float incidence\t\t= max(0., dot(norm, sunDir));\n\tcol \t\t\t\t= .25 * col * shadows + col * light_color * incidence;\n\n    col \t\t\t\t*= shadows*light_color*.45+.55;\n    \n    return col;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(1, 1, 1);\n\n    float terrainT = traceTerrain(ro, rd);\n\n    if (terrainT > tmax)\n    {\n        col = renderSky(ro, rd);\n    }\n    else\n    {\n        col = renderTerrain(ro, rd, terrainT);\n       \n    }\n\n    return vec4(col, terrainT);\n}\n\n// Camera\nvec3 cameraPos()\n{\n//    float theta = iTime * .0125;\n    float theta = (8.*atan(1.)) * iMouse.x/iResolution.x + 4.5;\n\tvec3 pos\t= vec3(cos(theta), .0, sin(theta)) * 2.75;\n    pos.y\t\t+= terrain(pos.xz)*.0001;\n    return pos;\n}\n\nvec3 cameraDir()\n{\n \treturn normalize(vec3(0.0, 0.0, 0.0) - cameraPos());   \n}\n\nmat3 buildViewMatrix(vec3 ro, vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 buildRayDirection(vec2 xy, mat3 view)\n{\n    vec2 s = xy * vec2(iResolution.x / iResolution.y, 1.0);\n    return view * normalize(vec3(s.xy, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = 1100.0 * cameraPos();\n    vec3 ta = ro + 1100.0 * cameraDir();\n    //ro.y = max(ro.y, max(terrain(ro.xz), waterHeight + 10.0) + 1.0);\n    float cr = 0.01;\n\n    mat3 view = buildViewMatrix(ro, ta, cr);\n\n    vec2 xy = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    // Camera ray\n    vec3 rd = buildRayDirection(xy, view);\n\n    vec4 col = render(ro, rd);\n\n    // Gamma correction\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    \n\tfragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// value noise, and its analytical derivatives (thanks iq :D)\nvec3 noised(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    float a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n    float b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n    float c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n    float d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n    return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n                6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat terrain( in vec2 x )\n{\n    vec2  p = x * 0.03;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    for( int i = 0; i < 8; i++ ) {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x / (1.0 + dot(d,d));\n        b *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    return a * 25000.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 1) {\n        float h = terrain(fragCoord);\n        float size = 10.0;\n        fragColor = vec4(mod(h / 255.0, 1.0), mod(floor(h / 255.0) / 255.0, 1.0), 0.0, 1.0);\n    } else {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        fragColor = texture(iChannel1, uv);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}