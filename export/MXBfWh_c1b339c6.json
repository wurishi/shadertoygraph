{"ver":"0.1","info":{"id":"MXBfWh","date":"1729380606","viewed":126,"name":"Twist twist twist","username":"eliemichel","description":"Helixify was fun, right? https://www.shadertoy.com/view/MXjBWR\nLet's go deeper now! Helixify of helixify of helixify... the approximation starts to feel at some point, but still looking fun.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["3d","sdf","helix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Helixify was fun, right? https://www.shadertoy.com/view/MXjBWR\n// Let's go deeper now! Helixify of helixify of helixify... the approximation\n// starts to feel at some point, but still looking fun.\n//\n// Copyright (c) Élie Michel -- MIT licensed (for what is not borrowed from other shaders)\n//\n// CREDITS:\n// Shading is borrowed from iq https://www.shadertoy.com/view/Xds3zN\n\n#define EPSILON 1e-3\n#define MAX_ITER 100\n#define TWO_PI 6.28318530718\n\n//------------------------------------------------------------\n// Core of the helix shape.\n// Copyright (c) Élie Michel -- MIT licensed\n// See https://www.shadertoy.com/view/MXjBWR for detailed comments\n// This is a macro because it is a second-order function\n#define MAKE_HELIXIFY(name, largeShape2D, smallShape3D) \\\nfloat name(vec3 pos, float stepSize) { \\\n    float dist_xz = largeShape2D(pos.xz); \\\n    float frac_cu = atan(pos.z, pos.x) / TWO_PI; \\\n     \\\n    int base_n = int(floor(pos.y / stepSize - frac_cu)); \\\n     \\\n    float dist_y = 2.0 * stepSize; \\\n    float cu = 0.0; \\\n    for (int n = base_n - 1 ; n <= base_n + 1 ; ++n) { \\\n        float candidate_cu = float(n) + frac_cu; \\\n        float helix_y = candidate_cu * stepSize; \\\n        float candidate_dist_y = pos.y - helix_y; \\\n        if (abs(candidate_dist_y) < abs(dist_y)) { \\\n            dist_y = candidate_dist_y; \\\n            cu = candidate_cu; \\\n        } \\\n    } \\\n     \\\n    vec3 local_pos = vec3(dist_xz, dist_y, cu); \\\n    return smallShape3D(local_pos); \\\n}\n\n//------------------------------------------------------------\n// Core scene definition\n\n// Shape of 1 turn of the helix\nfloat smallShape3D_1(vec3 pos) {\n    return length(pos.xy) - 0.005;\n}\n\n// Cross-section of the helix\nfloat largeShape2D_1(vec2 pos) {\n    return length(pos) - 0.02;\n}\n\nMAKE_HELIXIFY(helixify_1, largeShape2D_1, smallShape3D_1)\n\n// Cross-section of the helix\nfloat largeShape2D_2(vec2 pos) {\n    return length(pos) - 0.1;\n}\n\n// Shape of 1 turn of the helix\nfloat smallShape3D_2(vec3 pos) {\n    float bump = 0.01 * (sin(4. * iTime - 5. * pos.z) * .5 + .5) - 0.002;\n    return (helixify_1(pos.xzy * vec3(1.0, 0.5, 1.0), 0.05) - bump);\n}\n\nfloat smallShape3D_2c(vec3 pos) {\n    return length(pos.xy) - 0.01;\n}\n\nMAKE_HELIXIFY(helixify_2, largeShape2D_2, smallShape3D_2)\n\nMAKE_HELIXIFY(helixify_2c, largeShape2D_2, smallShape3D_2c)\n\n// Cross-section of the helix\nfloat largeShape2D_3(vec2 pos) {\n    return length(pos) - 0.4;\n}\n\n// Shape of 1 turn of the helix\nfloat smallShape3D_3(vec3 pos) {\n    pos.z += 0.025 * iTime;\n    return helixify_2(pos.xzy * vec3(1.0, 3.0, 1.0), 0.2);\n}\n\n// Shape of 1 turn of the helix\nfloat smallShape3D_3c(vec3 pos) {\n    pos.z += 0.025 * iTime;\n    return helixify_2c(pos.xzy * vec3(1.0, 3.0, 1.0), 0.2);\n}\n\nfloat smallShape3D_3b(vec3 pos) {\n    return length(pos.xy) - 0.04;\n}\n\nMAKE_HELIXIFY(helixify_3, largeShape2D_3, smallShape3D_3)\n\nMAKE_HELIXIFY(helixify_3b, largeShape2D_3, smallShape3D_3b)\n\nMAKE_HELIXIFY(helixify_3c, largeShape2D_3, smallShape3D_3c)\n\nvec2 sdmUnion(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 sceneDist(vec3 pos) {\n    float sd = helixify_3(pos, 1.2);\n    return sdmUnion(\n        sdmUnion(\n            vec2(helixify_3(pos, 1.2), 0.0),\n            vec2(helixify_3b(pos, 1.2), 1.0)\n        ),\n        vec2(helixify_3c(pos, 1.2), 2.0)\n    );\n}\n\n//------------------------------------------------------------\n// Shading, borrowed from iq\n\nvec3 calcNormal( in vec3 pos )\n{\n    if (pos.y < EPSILON) return vec3(0.0, 1.0, 0.0);\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = sceneDist( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = sceneDist( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 computeShading(vec3 pos, vec3 nor, vec3 rd, float t, float m) {\n    vec3 ref = reflect( rd, nor );\n    vec3 col = (\n        m == 0.0\n        ? vec3(1.0, 0.5, 0.0) * 0.5\n        : m == 1.0\n        ? vec3(1.0, 1.0, 0.0) * 0.5\n        : vec3(0.4, 0.1, 0.3) * 0.5\n    );\n    float ks = 0.4;\n    float occ = calcAO( pos, nor );\n\n    vec3 lin = vec3(0.0);\n    // sun\n    {\n        vec3  lig = normalize( vec3(0.5, -0.1, -0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n              dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n              spe *= dif;\n              spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n        lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n        lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n    }\n    // sky\n    {\n        float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n              dif *= occ;\n        float spe = smoothstep( -0.2, 0.2, ref.y );\n              spe *= dif;\n              spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n              spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n        lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n        lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n    }\n    \n    return mix( lin, vec3(1.0, 0.8, 0.0), 1.0-exp( -0.001*t*t*t ) );\n}\n\n//------------------------------------------------------------\n// Main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    vec3 direction = normalize(vec3(uv.xy, 1.0));\n    direction.yz = direction.zy;\n    vec3 pos = vec3(0.0, iTime, 0.0);\n    \n    float fac = -1.0;\n    float t = 0.0;\n    float m = 0.0;\n    for (int i = 0 ; i < MAX_ITER ; ++i) {\n        vec2 sd_m = sceneDist(pos);\n        float sd = sd_m.x;\n        m = sd_m.y;\n        if (sd < EPSILON) {\n            fac = float(i) / float(MAX_ITER);\n            break;\n        }\n        pos += .95 * direction * sd;\n        t += .95 * sd;\n    }\n    \n    if (fac >= 0.0) {\n        vec3 normal = calcNormal(pos);\n        vec3 col = vec3(fac);\n        col = normal * 0.5 + 0.5;\n        col = computeShading(pos, normal, direction, t, m);\n        col = pow(col, vec3(0.4545));\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = mix(\n            vec4(0.0, 0.0, 0.0, 1.0),\n            pow(vec4(1.0, 0.8, 0.0, 1.0), vec4(0.4545)),\n            step(length(uv), 0.05)\n        );\n    }\n}\n","name":"Image","description":"","type":"image"}]}