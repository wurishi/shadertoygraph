{"ver":"0.1","info":{"id":"lf3fRr","date":"1732625601","viewed":118,"name":"fractal  shining star","username":"nayk","description":"source fractal 62","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractal","star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(5.,10.,20.))*5.5+.5)\n#define pi 3.14\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (2.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = C/iResolution.xy;\n    vec2 p3;\n    vec2 pos=p3;\n    float t=iTime;\n      uv -= vec2(0.5, 0.5);\n    // *5 instead of *2 for better visual scale\n    uv *= 5.0;\n\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n  \n    // Parameters for the wave packets\n    float freqMultiplier = 20.0;\n    float timeMultiplier = 2.0;\n    float time = iTime;\n\n    // Pyramid dimensions and scaling\n    float pyramidHeight = 1.0; // Height of the pyramid\n    float baseSize = 1.5;      // Base width\n    float depthPerspective = 1.2; // Perspective scaling\n\n    // Four wave packet positions, forming pyramid sides\n    vec2 wavePos[4];\n    wavePos[0] = vec2(-baseSize, 0.0);   // Bottom-left\n    wavePos[1] = vec2(baseSize, 0.0);    // Bottom-right\n    wavePos[2] = vec2(0.0, pyramidHeight); // Top-center (pyramid apex)\n    wavePos[3] = vec2(0.0, -pyramidHeight); // Bottom-center (inverted apex)\n\n    // Oscillators at each vertex\n    float waves[4];\n    for (int i = 0; i < 4; i++) {\n        float distance = length(uv - wavePos[i]);\n        waves[i] = (sin(freqMultiplier * distance + timeMultiplier * time)) / (distance + 0.1);\n    }\n\n    // Composite wave interaction at central point\n    float compositeWave = 0.0;\n    for (int i = 0; i < 4; i++) {\n        compositeWave += waves[i];\n    }\n\n    compositeWave /= 4.0; // Normalize\n\n    // Coloring: composite wave is mapped to color\n    float intensity = abs(compositeWave);\n    vec2 p2=abs(.5-fract(p3*8.+4.));\nfloat h=0.;\n    h+=sin(length(p3)+t);\n    p3=floor(p3*2.+1.);\n    float l=length(p2*p2);\n    h+=(cos(p3.x+t)+sin(p3.y+t))*.5;\n    h+=max(0.,5.-length(p3-vec2(18.,0.)))*1.5;\n    h+=max(0.,5.-length(p3+vec2(18.,0.)))*1.5;\n   \n    t*=.5;\n    h+=(cos(p3.x+t)+sin(p3.y+t))*.3;\n   \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.5,0.5,0.5),H(g*.1),.8)*3./e/8e3\n    )\n    {\n        p=g*d;\n      \n       \n    p.z+=iTime*5.5;\n            \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        \n        s=2.;\n       \n        for(int i=0;i++<8;){\n       \n            p=.3-abs(p);\n           \n            p.xz=Rot2D(p.xz+intensity,iTime*0.05);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n              p.y<p.x?p=p.xyz:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            \n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 )*intensity;\n         }\n         g+=e=length(p.yzzz)/s;\n    }\n      O*= vec4(happy_star(uv, anim) * vec3(0.5,0.5,0.55)*10.5, 1.0);\n      O+= vec4(happy_star(uv, anim) * vec3(0.5,0.5,0.55)*5.5, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}