{"ver":"0.1","info":{"id":"Ms2BDy","date":"1502101234","viewed":351,"name":"Gradient & Laplacian of Noise","username":"Dodecaplex","description":"Calculating the gradient and Laplacian (divergence of gradient) of iq's fractal noise functions.\nToggle between simplex and value noise in Buffer A, and note the artifacts / discontinuities!","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","gradient","derivative","laplacian","laplace","divergence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRAD_H 0.0001\n#define LAPLACE_SCALE 0.00005\n\nvec2 grad(in vec2 uv) {\n\tfloat dfdx = texture(iChannel0, vec2(uv.x + GRAD_H, uv.y)).r - texture(iChannel0, vec2(uv.x - GRAD_H, uv.y)).r;\n    float dfdy = texture(iChannel0, vec2(uv.x, uv.y + GRAD_H)).r - texture(iChannel0, vec2(uv.x, uv.y - GRAD_H)).r;\n    return vec2(dfdx, dfdy) / (2.0*GRAD_H);\n}\n\nfloat laplace(in vec2 uv) { // divergence of gradient\n    float dgdx = grad(vec2(uv.x + GRAD_H, uv.y)).x - grad(vec2(uv.x - GRAD_H, uv.y)).x;\n    float dgdy = grad(vec2(uv.x, uv.y + GRAD_H)).y - grad(vec2(uv.x, uv.y - GRAD_H)).y;\n    return (dgdx + dgdy) / (2.0*GRAD_H);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    if (uv.x < 0.5) {\n        if (uv.y < 0.5) { // bottom-left [plain noise]\n       \t\tfragColor = texture(iChannel0, uv);\n        } else {  // top-left [laplacian only]\n            float lp = laplace(uv);\n            lp *= LAPLACE_SCALE;\n            fragColor = vec4(lp, lp, lp, 1.0);\n        }\n    } else {\n        // bottom-right [gradient only]\n        // top-right    [gradient + laplacian]\n        fragColor = vec4(normalize(grad(uv)), uv.y > 0.5 ? LAPLACE_SCALE * laplace(uv) : 0.0, 1.0);\n    }\n    fragColor = fragColor*0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#if 1\n// 2D Simplex Noise by iq - https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    p*=0.5;\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n#else\n// 2D Value Noise by iq - https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n#endif\n\nfloat f(in vec2 p) {\n    p *= 6.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float n;\n    n  = 0.5000*noise(p + 1.0 * vec2(cos(0.250 * iTime), sin(0.212 * iTime))); p = m*p;\n    n += 0.2500*noise(p + 2.0 * vec2(cos(0.441 * iTime), sin(0.470 * iTime))); p = m*p;\n    n += 0.1250*noise(p + 3.0 * vec2(cos(0.654 * iTime), sin(0.622 * iTime))); p = m*p;\n    n += 0.0625*noise(p + 4.0 * vec2(cos(0.805 * iTime), sin(0.772 * iTime))); p = m*p;\n    return n;\n}\n\nfloat gaussian(in vec2 uv, in vec2 mu, in vec2 sigma) { // to see laplacian of gaussian (just for fun)\n    return exp(-dot((uv-mu)*(uv-mu) / (2.0*sigma*sigma), vec2(1.0, 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float n = f(uv);\n    n*=2.0;\n    // n = 100.0*gaussian(uv, 0.5 + 0.125*vec2(cos(iTime), sin(iTime)), 0.25 + 0.125*vec2(sin(0.9*iTime)));\n    fragColor = vec4(n, n, n, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}