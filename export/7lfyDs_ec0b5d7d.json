{"ver":"0.1","info":{"id":"7lfyDs","date":"1648926123","viewed":54,"name":"CGFS reflections","username":"mnopqr1","description":"Adapted from https://gabrielgambetta.com/computer-graphics-from-scratch/","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","keyboard"],"hasliked":0,"parentid":"stlcDf","parentname":"CGFS Ch 5 Keyboard"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFTY 99999.99\n#define MAX_DEPTH 5\n\nstruct Ray { vec3 origin; vec3 direction; };\n\nstruct Sphere { vec3 center; float radius; vec3 color; float specular; float reflective; };\n\n#define POINT 1 \n#define AMBIENT 2 \n#define DIRECTIONAL 3\n\nstruct Light { int type; float intensity; vec3 vector; vec3 color; };\n\nstruct Scene { Sphere[4] spheres; Light[3] lights; vec3 bgcolor; };\n\nstruct Intersection { int obj_id; float t; };\n\nstruct Camera { vec3 position; };\n\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\n\nfloat[2] intersectRaySphere(Ray ray, Sphere sphere) {\n    float[2] ts = float[2](INFTY,INFTY);\n    float r = sphere.radius;\n    vec3 CO = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0f * dot(CO, ray.direction);\n    float c = dot(CO, CO) - r * r;\n    float D = b * b - 4.0f * a * c;\n    if (D < 0.0f) return ts;\n    ts[0] = (-b + sqrt(D)) / (2.0f * a);\n    ts[1] = (-b - sqrt(D)) / (2.0f * a);\n    return ts;\n}\n\nIntersection closestIntersection(Scene scene, Ray ray, float t_min, float t_max) {\n    float closest_t = INFTY;\n    int closest_sphere_id = -1;\n    for (int i = 0; i < scene.spheres.length(); i++) {\n        float[2] ts = intersectRaySphere(ray, scene.spheres[i]);\n        for (int k = 0; k < 2; k++) {\n            if (t_min < ts[k] && ts[k] < t_max && ts[k] < closest_t) {\n                closest_t = ts[k];\n                closest_sphere_id = i;\n            }\n        }\n    }\n    return Intersection(closest_sphere_id, closest_t);\n}\n\nvec3 reflectRay(vec3 R, vec3 N) {\n    return 2.0 * N * dot(N,R) - R;\n}\n\nfloat lightIntensity(vec3 P, vec3 N, Scene scene, vec3 V, float s) {\n    float its = 0.0;\n    vec3 L = vec3(0,0,0);\n    float t_max;\n    for (int i = 0; i < scene.lights.length(); i++) {\n        Light light = scene.lights[i];\n        if (light.type == AMBIENT) {\n            its += light.intensity;\n        } else {\n            if (light.type == POINT) {\n                L = light.vector - P;\n                t_max = 1.0f;\n            } else {\n                L = light.vector; \n                t_max = INFTY;\n            }\n\n            // shadow check\n            Intersection shadow = closestIntersection(scene, Ray(P, L), 0.001, t_max);\n            if (shadow.obj_id != -1) {\n               continue;\n            }\n            // diffuse\n            float N_dot_L = dot(N,L);\n            if (N_dot_L > 0.0) {\n                its += light.intensity * N_dot_L / (length(N) * length(L));\n            }\n\n            // specular\n            if (s != -1.0) {\n                vec3 R = reflectRay(L, N);\n                float R_dot_V = dot(R, V);\n                if (R_dot_V > 0.0f) {\n                    its += light.intensity * pow((R_dot_V) / (length(R) * length(V)), s);\n                }\n            }\n        }\n    }\n\n    return its;\n}\n\nvec3 traceRay(Scene scene, Ray ray, float t_min, float t_max, int max_depth) {\n\n    vec3 finalColor = vec3(0.0);\n    float frac = 1.0;\n    Ray cur_ray = ray;\n    float cur_t_min = t_min;\n    float cur_t_max = t_max;\n    \n    for (int b = 0; b < max_depth; b++) {\n        Intersection inters = closestIntersection(scene, cur_ray, t_min, t_max);\n\n        if (inters.obj_id == -1) {\n            finalColor += frac * scene.bgcolor;\n            break;\n        } else {\n            Sphere closest = scene.spheres[inters.obj_id];\n            vec3 P = ray.origin + inters.t * ray.direction;\n            vec3 N = normalize(P - closest.center);\n            \n            vec3 localColor = closest.color * lightIntensity(P, N, scene, -ray.direction, closest.specular);\n            finalColor += localColor * (1.0 - closest.reflective) * frac;\n            \n            vec3 R = reflectRay(-ray.direction, N);\n            cur_ray = Ray(P, R);\n            cur_t_min = 0.001;\n            cur_t_max = INFTY;\n            frac *= closest.reflective;\n            if (frac < 0.001) break;\n            \n        }\n    }\n    return finalColor;\n    \n}\n\nvec2 canvasToWorld(vec2 v) {\n     vec2 uv = v / iResolution.xy - vec2(0.5);\n     vec2 ab = uv * vec2((iResolution.x)/(iResolution.y), 1.0);\n     return ab;\n }\n \n\nfloat buzz(float amp) {\n    return amp * cos(iTime);\n}\n\nvec3 getCoord() {\n    return vec3(\n    \ttexelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n}\n\nconst vec3 RED = vec3(0.7333, 0.1412, 0.1412);\nconst vec3 BLUE = vec3(0.6549, 0.6549, 0.9922);\nconst vec3 GREEN = vec3(0.1843, 0.3333, 0.1843);\nconst vec3 GREY = vec3(0.8549, 0.8549, 0.8549);\nconst vec3 BACKGROUND = vec3(0.0275, 0.2039, 0.4314);\n\n//const vec3 RED = vec3(1.0,0.0,0.0);\n//const vec3 GREEN = vec3(0.0,1.0,0.0);\n//const vec3 BLUE = vec3(0.0,0.0,1.0);\n//const vec3 GREY = vec3(0.0,1.0,1.0);\n//const vec3 BACKGROUND = vec3(0.0,0.0,0.0);\nScene initScene() {\n    Sphere sp1 = Sphere(vec3(0,-1.0 + buzz(2.0),3.0), \n                        1.0f, \n                        RED,\n                        500.0,\n                        0.2);\n    Sphere sp2 = Sphere(vec3(2.0+buzz(0.3),1.0,4.0), \n                        1.0f, \n                        BLUE, \n                        500.0,\n                        0.5);\n    Sphere sp3 = Sphere(vec3(-2.0+buzz(10.0),1.0,4.0), \n                        1.0f,\n                        GREEN, \n                        10.0,\n                        0.3);\n    Sphere sp4 = Sphere(vec3(0,-5001,0), \n                        5000.0f, \n                        GREY, \n                        1000.0,\n                        0.2);\n    Light li1 = Light(AMBIENT, 0.2, vec3(0,0,0), WHITE);\n    Light li2 = Light(POINT, 0.6, vec3(2.0, 1.0, 0.0), WHITE);\n    Light li3 = Light(DIRECTIONAL, 0.2, vec3(1.0,4.0,4.0), WHITE);\n    return Scene(Sphere[4](sp1,sp2,sp3,sp4), \n               Light[3](li1, li2, li3),\n               BACKGROUND);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 abc = vec3(canvasToWorld(fragCoord), 1.0);\n    Scene scene = initScene();\n    Camera cam = Camera(vec3(getCoord()));    \n    Ray ray = Ray(cam.position, abc);\n    vec3 col = traceRay(scene, ray, 1.0f, INFTY, MAX_DEPTH);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// buffer A\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_A = 65; // move left\nconst int KEY_D = 68; // move right\nconst int KEY_W = 87; // move forward\nconst int KEY_S = 83; // move backward\nconst float speed = 10.0;\n\nint[6] keys = int[6](KEY_D, KEY_A, KEY_UP, KEY_DOWN, KEY_W, KEY_S);\n\nfloat keyPressed(int key) {\n   return (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(key, 0), 0).r;\n}\n\nfloat getKeyInput(int increase_key, int decrease_key) {\n    return keyPressed(increase_key) - keyPressed(decrease_key);\n}\n\nfloat getPrevious(int register) {\n    return texelFetch(iChannel0, ivec2(register, 0), 0).r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int dir = int(fragCoord.x);\n    float outData = getPrevious(dir) + getKeyInput(keys[2 * dir], keys[2*dir+1]);\n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}