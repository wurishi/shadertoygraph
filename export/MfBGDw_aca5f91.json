{"ver":"0.1","info":{"id":"MfBGDw","date":"1704281140","viewed":99,"name":"小组图形学作业","username":"xxxxic","description":"Study from iq shader：https://www.shadertoy.com/view/tt2XzG","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\n// 圆柱sd函数\nfloat sdCylinder(in vec3 pos, in float r){\n    return length(pos.xz) - r;\n}\n// 球sd函数\nfloat sdBall(in vec3 pos, in float r){\n    return length(pos) - r;\n}\n// 长方体sd函数（仅限制了xz坐标，y方向无限延伸）\nfloat sdBox(in vec2 pos, in vec2 r){\n    return length(max(abs(pos) - r, 0.0));\n}\n// 长方体sd函数\nfloat sdBox(in vec3 pos, in vec3 r){\n    return length(max(abs(pos) - r, 0.0));\n}\n\nfloat smax(in float a, in float b, in float k){\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + (0.25/k) * h * h;\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    \n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// 连接相对齿轮的sd函数\nfloat sdVStick(in vec3 p, in float h){\n    p.y = max(p.y-h, 0.0);\n    return length(p);\n}\n\nvec2 rot45(in vec2 v){\n    return vec2(v.x + v.y, v.x - v.y) * 0.707107;\n}\n\n// 计算旋转矩阵\nmat2 rot(float angle){\n    float vcos= cos(angle);\n    float vsin = sin(angle);\n    return mat2(vcos, -vsin, vsin, vcos);\n}\n\n// 材质，可实现不同部位不同颜色\nstruct material{\n    float d;\n    float id;\n    vec3 col;\n    vec3 pos;\n};\n\n//---------------------------------------------------\n\nmaterial gear(in vec3 pos, in float time, in float offset, in float re){\n    material mat;\n    \n    float rot_angle = (time * sign(pos.y) + offset * PI / 12.0) * re;\n    pos.xz = rot(rot_angle) * pos.xz;\n    \n    pos.y = abs(pos.y);\n    float basic = PI / 6.0;  // 沿y轴的旋转角度单位\n    float sector = round(atan(pos.z, pos.x) / basic);  // 根据pos的实际位置划分sector\n    float angle = sector * basic;\n    vec3 q = pos;\n    q.xz = rot(angle) * q.xz;  // 分别得到每个长方体的专属坐标轴\n\n    // 在（0.17， 0.0）处生成0.08 * 0.036，y方向无限延伸的长方体 \n    float bs = sdBox(q.xz - vec2(0.19, 0.0), \n                            vec2(0.03, 0.015)) - 0.01;  // 作圆滑处理\n                            \n    // 在（0.0， 0.0）处生成 r = 0.155，向外向内拓宽0.018，y方向无限延伸的圆柱\n    float cy = abs(sdCylinder(pos, 0.155)) - 0.018;\n    // 生成齿轮的交叉杆\n    //float cs = sdCross(pos-vec3(0.0, 0.5, 0.0), vec3(0.15, 0.005, 0.005)) - 0.003;\n    float cs = sdCross( pos.xz, vec2(0.15,0.022), 0.02 );\n    vec2 w = vec2( cs, abs(q.y-0.485)-0.005 );\n    cs = min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.003;\n    //vec2 w = vec2( cs, abs(q.y-0.5)-0.005 );\n    //cs = min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.003;\n    // 生成连接上下齿轮的棍子\n    float sk = sdVStick(pos, 0.5) - 0.01;\n    // 限制棍子长度，y 取值 [-0.5, 0.5]\n    sk = max(sk, abs(pos.y) - 0.5);\n    \n    bs = min(bs, cs);\n    bs = min(bs, cy);\n    \n    // 用半径0.5，厚度为0.06的球壳去切割上述图形，得到独立的上下齿轮\n    float r = length(pos);\n    bs = smax(bs, abs(r - 0.5) - 0.03, 0.005);\n    \n    // 连接棍子\n    bs = min(bs, sk);\n    mat.d = bs;\n    mat.pos = q.xyz;\n    return mat;\n}\n\nmaterial map(in vec3 pos, in float time){\n    material mat_1 = gear(pos.xyz, time, 0.0, 1.0);\n    material mat_2 = gear(pos.yzx, time, 0.0, 1.0);\n    material mat_3 = gear(pos.zxy, time, 0.0, 1.0);\n    \n    vec3 qx = vec3(rot45(pos.zy), pos.x);\n    if(abs(qx.x) > abs(qx.y)) qx = qx.zxy;\n    vec3 qy = vec3(rot45(pos.xz), pos.y);\n    if(abs(qy.x) > abs(qy.y)) qy = qy.zxy;\n    vec3 qz = vec3(rot45(pos.xy), pos.z);\n    if(abs(qz.x) > abs(qz.y)) qz = qz.zxy;\n        \n    material mat_4 = gear(qx, time, 1.0, -1.0);\n    material mat_5 = gear(qy, time, 1.0, -1.0);\n    material mat_6 = gear(qz, time, 1.0, 1.0);\n    \n    material mat;\n    if(mat_1.d < mat_2.d && mat_1.d < mat_3.d)\n        mat = mat_1;\n    else if(mat_2.d < mat_3.d)\n        mat = mat_2;\n    else\n        mat = mat_3;\n    \n    if(mat_4.d < mat.d) mat = mat_4;\n    if(mat_5.d < mat.d) mat = mat_5;\n    if(mat_6.d < mat.d) mat = mat_6;\n    \n    float d1 = mat.d;\n    d1 = min(d1, sdBall(pos, 0.12));\n    mat.d = d1;\n    \n    return mat;\n}\n\n//------------------------------------------------\n\n#define ZERO min(iFrame,0)\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occlusion = 0.0; // 初始遮蔽值为0\n    float attenuation = 1.0; // 初始衰减系数为1\n    for( int i=ZERO; i<5; i++ )\n    {\n        float height = 0.01 + 0.12 * float(i) / 4.0; // 计算高度\n        float distance = map(pos + height * nor, time).d; // 计算距离\n        \n        occlusion += (height - distance) * attenuation; // 更新遮蔽值\n        attenuation *= 0.95; // 更新衰减系数\n    }        \n\n    // 计算环境光遮蔽\n    float length = length(pos);\n    float focc  = 0.1+0.9*clamp(0.5+0.5*dot(nor,pos/length),0.0,1.0);\n          focc *= 0.1+0.9*clamp(length*2.0,0.0,1.0);\n    return clamp(1.0 - 3.0 * occlusion, 0.0, 1.0) * focc; // 返回修正后的遮蔽值\n}\n\n// 计算硬阴影的函数\nfloat calcHardShadow(in vec3 ro, in vec3 rd, in float k, in float time)\n{\n    for (float t = 0.001; t < 1.0; )\n    {\n        float height = map(ro + rd * t, time).d; // 计算高度\n        \n        if (height < 0.001f)\n            return 0.0f; // 如果高度小于阈值，返回0表示有阴影\n        \n        t += height; // 更新射线距离\n    }\n    \n    return 1.0f; // 如果没有遇到阴影，返回1表示没有阴影\n}\n\n// 计算软阴影的函数\nfloat calcSoftShadow(in vec3 ro, in vec3 rd, in float k, in float time)\n{\n    float shadowValue = 1.0; // 初始阴影值为1\n    \n    float maxDistance = 2.0; // 射线最大距离\n    float distance = 0.001; // 初始射线距离\n    \n    // 射线追踪\n    for (int i = 0; i < 64; i++)\n    {\n        float height = map(ro + rd * distance, time).d; // 计算高度\n        shadowValue = min(shadowValue, k * height / distance); // 更新阴影值\n        distance += clamp(height, 0.012, 0.2); // 更新射线距离\n        \n        if (shadowValue < 0.001 || distance > maxDistance)\n            break; // 如果阴影值小于阈值或者超出最大距离，跳出循环\n    }\n    \n    return clamp(shadowValue, 0.0, 1.0); // 返回修正后的阴影值\n}\n\nvec3 BlinnPhongShading(material mat, vec3 p, vec3 n, vec3 lightColor, vec3 lightDir, vec3 camPosition, float iTime, \n                       float ambientStrength, float diffuseStrength, float specularStrength, float specularPower) {  \n    //添加阴影\n    float shadow = calcSoftShadow(p, lightDir, 32.0, iTime);\n\n\t// 环境光分量\n\tvec3 ambient = ambientStrength * lightColor * mat.col * shadow;\n\n\t// 漫反射光分量\n\tvec3 diffuse = diffuseStrength * max(0.0, dot(n, lightDir)) * lightColor * mat.col * shadow;\n\n\t// 高光分量\n\tvec3 viewDir = normalize(camPosition - mat.pos);\n\tvec3 halfDir = normalize(lightDir + viewDir);\n\tvec3 specular = specularStrength * lightColor * pow(max(0.0, dot(n, halfDir)), specularPower) * shadow;\n\n\tvec3 color = ambient + diffuse + specular;\n\n\t// 防止颜色越界\n\treturn vec3(clamp(color.r, 0.0f, 1.0f), clamp(color.g, 0.0f, 1.0f), clamp(color.b, 0.0f, 1.0f));\n}\n\n\n//------------------------------------------------\n\n// 法向量\nvec3 GetNormal(vec3 p, float time){\n    float d = map(p, time).d;\n    vec2 e = vec2(0.001, 0.0);\n    float dx = d - map(p-e.xyy, time).d;\n    float dy = d - map(p-e.yxy, time).d;\n    float dz = d - map(p-e.yyx, time).d;\n    return normalize(vec3(dx, dy, dz));\n}\n\n// 相机\nmat3 CameraToWorld(vec3 ro,vec2 uv,vec3 lookAt){\n    vec3 f= normalize(lookAt - ro);\n    vec3 r = cross(vec3(1, 1, 0), f);\n    //vec3 r = cross(vec3(0, 1, 0), f);\n    vec3 u = cross(f, r);\n    return mat3(r, u, f);\n}\n\nmaterial Raymarch(vec3 ro, vec3 rd, float time){\n    float d;\n    material mat;\n    for(int i = 0; i < 255; i ++){\n        vec3 p = ro + rd * d;\n        mat = map(p, time);\n        float d0 = mat.d;\n        if(d0 <= 0.001 || d >= 40.0) \n            break;\n        d += d0;\n    }\n    mat.d = d;\n    return mat;\n}\n\n// 调整为窗口比例: 使得x，y表示的单位长度在视觉上看起来相同\nvec2 fixUV(in vec2 uv){\n    uv=0.7*(2.*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fixUV(fragCoord);\n    \n    // 观察视角\n    vec3 ro = vec3(0.0, 1.0, -1.5);\n    \n    // 相机旋转速度\n    ro.xz *= rot(iTime * 0.5);\n    vec3 rd = CameraToWorld(ro,uv,vec3(0.0))*(normalize(vec3(uv,1.2)));\n    \n    // background\n    vec3 col = vec3(0.0);\n    \n    material mat = Raymarch(ro, rd, iTime);\n    // 根据纹理获取材质属性\n    vec3 textureColor = texture(iChannel0, mat.pos.yz * 2.0).xyz;\n    mat.col = 0.22 * textureColor;\n    \n    col = vec3(0.0);\n    if(mat.d < 40.0 && mat.d > 0.0){        \n        // 计算片元位置和法向量\n        vec3 p = ro + rd * mat.d;\n        vec3 n = GetNormal(p, iTime);\n        \n        // 计算阴影和光照\n\n        // 计算环境光遮蔽\n        float occlusion = calcAO(p, n, iTime);\n\n        // 初始化颜色\n        vec3 color = vec3(0.0);\n\n        // 计算顶部光照\n        {\n            // 定义各项系数\n            float ambientStrength = 0.1f;  // 环境光分量的强度\n            float diffuseStrength = 3.0f;  // 漫反射光分量的强度\n            float specularStrength = 1.0f;  // 高光分量的强度\n            float specularPower = 16.0;  // 光斑的锐利程度\n            \n            vec3 lightColorTop = vec3(0.7, 0.8, 1.1);\n            vec3 lightDirTop = normalize(vec3(1.0, 3.0, -1.0));\n            vec3 c_top = BlinnPhongShading(mat, p, n, lightColorTop, lightDirTop, ro, iTime,\n                                           ambientStrength,diffuseStrength,specularStrength,specularPower);\n            color += c_top * occlusion;\n        }\n\n        // 计算侧面光照\n        {\n            // 定义各项系数\n            float ambientStrength = 0.5f;  // 环境光分量的强度\n            float diffuseStrength = 1.0f;  // 漫反射光分量的强度\n            float specularStrength = 0.8f;  // 高光分量的强度\n            float specularPower = 16.0;  // 光斑的锐利程度\n            \n            vec3 lightColorSide = vec3(1.0, 0.55, 0.30);\n            vec3 lightDirSide = normalize(vec3(0.8, 0.2, 0.6));\n            vec3 c_side = BlinnPhongShading(mat, p, n, lightColorSide, lightDirSide, ro, iTime,\n                                            ambientStrength,diffuseStrength,specularStrength,specularPower);\n            color += c_side;\n        }\n\n        // 返回最终颜色\n        col = color;\n    }else{\n        vec2 uv = vec2( atan(rd.z, rd.x)/(2.0*PI) + 0.5, 0.5 );\n        //vec2 uv = vec2( atan(rd.z, rd.x)/(2.0*PI) + 0.5, asin(rd.y)/PI + 0.5 );\n        col = 0.37 * texture(iChannel0, uv).rgb;\n    }\n   \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}