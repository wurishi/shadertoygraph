{"ver":"0.1","info":{"id":"43GXzt","date":"1720323840","viewed":92,"name":"Sphere field","username":"coproduto","description":"Just some raymarched spheres.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n\nvec2 normalizeCoords(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = 2. * (uv - vec2(.5));\n    return vec2(nuv.x * ASPECT_RATIO, nuv.y);\n}\n\nfloat sdSp(vec3 p, float b) {\n    return length(p) - b;\n}\n\nfloat map(vec3 p, vec3 s,vec3 l, float r) {\n    vec3 q = p - s * clamp(round(p/s), -l, l);\n    return sdSp(q, r); \n}\n\n#define FOCAL_DISTANCE 2.\n#define EYE_DISTANCE 5.3\n#define RADIUS 0.3\n#define MAX_T 300.0\n#define DELTA_T 0.01\n#define TOLERANCE 0.001\n#define EPSILON 0.001\n\nvec3 ray(float fd, vec2 normalizedCoord) {\n    return normalize(vec3(normalizedCoord, fd));\n}\n\nfloat sdScene(vec3 samplePoint) {\n    return map(samplePoint, vec3(4.), vec3(30.), RADIUS);\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 sdNormal(vec3 p) {\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ) + \n                      k.yyx*sdScene( p + k.yyx*h ) + \n                      k.yxy*sdScene( p + k.yxy*h ) + \n                      k.xxx*sdScene( p + k.xxx*h ) );\n}\n\nvec2 march(vec3 camera, vec3 dir) {\n    float d = DELTA_T;\n    for (float t = 0.; t < MAX_T; t += d) {\n        vec3 s = camera + dir * t;\n        float dist = sdScene(s);\n        if (dist < TOLERANCE * t) {\n            float intensity = dot(normalize(camera), sdNormal(s));\n            return vec2(intensity, 2. * dot(camera, 0.5 * s));\n        }\n        d = dist * 0.5;\n    }\n    return vec2(0.);\n}\n\nmat3 cameraRotation(float angle) {\n  return mat3(\n      cos(angle),  0., -sin(angle),\n      0.,          1., 0.,\n      sin(angle),  0., cos(angle)\n  );\n}\n\nmat4 cameraTransform(vec3 tr, float angle) {\n  mat4 translate = mat4(\n      1.,   0.,   0.,   0.,\n      0.,   1.,   0.,   0.,\n      0.,   0.,   1.,   0.,\n      tr.x, tr.y, tr.z, 1.\n  );\n  \n  mat4 rotate = mat4(cameraRotation(angle));\n  \n  return rotate * translate;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 nc = normalizeCoords(fragCoord);\n    \n    float angle = 0.2 * iTime;\n    vec3 cameraTranslation = vec3(0., 0., -EYE_DISTANCE);\n    mat4 cameraMatrix = cameraTransform(cameraTranslation, angle);\n    \n    vec3 rayDir = cameraRotation(angle) * ray(FOCAL_DISTANCE, nc);\n    vec4 origin4 = vec4(vec3(0.), 1.);\n    vec3 cameraPosition = vec3(cameraMatrix * origin4);\n    vec2 res = march(cameraPosition, rayDir);\n\n    fragColor = res.x * vec4(0.3 * res.y, 0.1, cos(0.9 + 0.3 * res.y), 1.);\n}","name":"Image","description":"","type":"image"}]}