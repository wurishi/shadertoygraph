{"ver":"0.1","info":{"id":"dssfWj","date":"1689197851","viewed":125,"name":"Winding Field Jump Flood SDF","username":"chronos","description":"Dipole winding number field jump flood signed distance field.\n\nor DWNFJFSDF for short! xD\n\nRead the image tab!","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["number","field","dipole","winding"],"hasliked":0,"parentid":"DssBW2","parentname":"Dipole Winding Number Field"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nUsing Jump flood algorithm to create a signed distance field from the isosurface of the dipole winding number field.\n\nThe winding number field is used to create an isosurface from a set of points.\nThen the jump flood algorithm is used to generate an unsigned distance field from the isosurface.\nFinally, the winding number field is used to generate a sign for the distance field.\n\nI haven't seen this method implemented anywhere else yet.\nLet me know if you use this method for something cool!\n\nNote that there are some singularities in the WNF where the dipoles are located!\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    #if 1\n    vec4 samp = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float dist = length(samp.rg);\n    color = vec3(.5*(1.+normalize(samp.rg)), dist / 500.);\n    \n    \n    vec4 mouse_samp = texelFetch(iChannel1, ivec2(iMouse.xy), 0);\n    float mouse_dist = length(mouse_samp.rg);\n    float mouse_winding_number = texelFetch(iChannel0, ivec2(iMouse.xy), 0).b;\n    \n    float sphere = smoothstep(2., 1., abs(distance(fragCoord.xy, iMouse.xy) - mouse_dist));\n    \n    mouse_winding_number = -sign(mouse_winding_number-.5);\n    vec3 circle_color = max(vec3(-mouse_winding_number, mouse_winding_number, 1.-abs(mouse_winding_number)), 0.);\n    \n    \n    float pixel_winding_number = -sign(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).b-.5);\n    color = mix(color, 1.-color, (1.+pixel_winding_number)*.5);\n    \n    \n    color = mix(color, circle_color, sphere);\n    \n    vec2 line_seg = project_point_to_line_segment(fragCoord, iMouse.xy, iMouse.xy+mouse_samp.rg);\n    \n    const float dir_alpha = 0.5;\n    float dir_indicator = dir_alpha * smoothstep(2.1, 2., distance(fragCoord, line_seg));\n    color = mix(color, vec3(1), dir_indicator);\n    \n    color += dist / 1000.;\n    \n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n    \n    #else\n    \n    vec3 samp = texelFetch(iChannel0, ivec2(fragCoord), 0).aaa;\n    color = vec3(samp);\n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#if 1\n\n\nstruct point\n{\n    vec2 position;\n    vec2 normal;   // dipole direction\n    float area;    // represented surface area \n};\n\nfloat winding(vec2 query, point p)\n{\n    // 3D greens function:  -1 / (4. * PI * r), where r = distance(query, point_position)\n    float r = distance(p.position, query);\n    return p.area * dot(p.position - query, p.normal) / (4. * PI * pow(r, 3.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    vec2 query = uv;\n        \n    const float num_points = 10.;\n\n    float winding_number = 0.;\n    \n    for(float i = 0.; i < num_points; ++i)\n    {\n        float radius = 0.5 + cos(i)*0.25;\n    \n        point p;\n        float angle = (i / num_points) * 2. * PI;\n        p.position = radius * vec2(cos(angle), sin(angle));\n        p.normal = normalize(p.position);                   // Outward pointing normals\n        p.area = (1. / num_points) * 2. * PI * radius;      // perimeter of circle by number of segments, in place of surface area.\n        winding_number += winding(query, p);\n    }\n    \n    // Mouse interaction\n    if(false)\n    {\n        point p;\n        p.position = mouse;\n        p.normal = normalize(p.position);                   \n        p.area = (1. / num_points) * 2. * PI * length(mouse);\n        winding_number += winding(query, p);\n    }\n    \n    vec2 gradient = vec2(dFdx(winding_number), dFdy(winding_number));\n    float gradient_length = length(gradient);\n    vec2 unit_gradient = normalize(gradient);\n    float level = 0.5; // See page 7, figure 8 of paper\n    float eps = 5. * gradient_length;   // arbitrary small-ish number\n    float iso = smoothstep(level-eps, level, winding_number) * smoothstep(level+eps, level, winding_number);\n    \n    // Sigmoid to remap [-inf, inf] to [-1, 1]\n    //winding_number = tanh(winding_number);\n    \n    vec3 color = max(vec3(-winding_number, winding_number, 1.-abs(winding_number)), 0.);\n\n    color = mix(color, vec3(1), iso);\n\n    //fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n    \n    \n    //fragColor = vec4(pow(.5*(unit_gradient+1.), vec2(1./GAMMA)), 0.,1.0);\n    //fragColor = vec4(vec2(iso < 1. ? 9e9 : 0.), 0., iso);\n    \n    fragColor = vec4(0., 0., winding_number, iso);\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec4 color = vec4(0);\n    \n    if(length(uv) < 0.125) \n    {\n        color.rg = -0.*(fragCoord - iResolution.xy / 2.) ;\n        color.a = 1.;\n    }\n\n    fragColor = color;\n}\n#endif","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ij = ivec2(fragCoord);\n    \n    const int STEP_FRAMES = 30;\n    if(iFrame % STEP_FRAMES != 0)\n    {\n       fragColor = texelFetch(iChannel1, ij, 0);\n       return;\n    }\n\n    const int N = 9;\n    \n    // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n    int jump_size = (1 << N) >> min(iFrame/STEP_FRAMES, N); \n    \n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(0);\n    float current_fill = 0.;\n    \n    \n    if(iFrame == 0)\n    {\n        fragColor = texelFetch(iChannel0, ij, 0);\n        return;\n    }\n    \n    \n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    {\n        ivec2 jump = jump_size*ivec2(x,y);\n        ivec2 coord = ij + jump;\n        if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n        {\n            continue;\n        }\n\n        vec4 samp = texelFetch(iChannel1, coord, 0);\n\n        bool samp_fill = samp.a >= 0.5;\n        vec2 samp_offset = samp.rg;\n\n        vec2 candidate_offset = vec2(jump) + samp_offset;\n        float candidate_dist = length(candidate_offset);\n\n        if (candidate_dist <= current_dist && samp_fill)\n        {\n            current_dist = candidate_dist;\n            current_offset = candidate_offset;\n            current_fill = 1.;\n        }\n\n    }\n\n    // save offset and fill\n    fragColor = vec4(current_offset, 0., current_fill);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float GAMMA = 2.2;\nconst float PI = 3.14159265359;\n\n\nvec2 project_point_to_line_segment(vec2 point, vec2 a, vec2 b)\n{\n    vec2 ab = b - a;\n    vec2 ap = point - a;\n    return clamp(dot(ap, ab) / dot(ab,ab), 0., 1.) * ab + a;\n}","name":"Common","description":"","type":"common"}]}