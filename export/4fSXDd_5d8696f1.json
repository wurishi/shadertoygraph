{"ver":"0.1","info":{"id":"4fSXDd","date":"1706956159","viewed":96,"name":"Konod's value noise","username":"Konod","description":"A non-expensive method for generating noise. You can adjust the frequencies of the noise with the behaviour of the weight. For instance, the noise here is pink noise. (cf https://en.wikipedia.org/wiki/Colors_of_noise)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","valuenoise","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash2to1(vec2 p) {\n    p = fract(p*vec2(3.512,7.987));\n    p += dot(p, p+vec2(618.2, 828.9));\n    return fract(p.x*p.y);\n}\n\nfloat valueNoise(vec2 uv) {\n    vec2 cellBL = floor(uv);\n    vec2 cellBR = floor(uv + vec2(1., 0.));\n    vec2 cellTL = floor(uv + vec2(0., 1.));\n    vec2 cellTR = floor(uv + vec2(1., 1.));\n    \n    vec2 cellUV = smoothstep(0., 1., fract(uv));\n    float noiseBL = hash2to1(cellBL);\n    float noiseBR = hash2to1(cellBR);\n    float noiseTL = hash2to1(cellTL);\n    float noiseTR = hash2to1(cellTR);\n    \n    float noiseB = mix(noiseBL, noiseBR, cellUV.x);\n    float noiseT = mix(noiseTL, noiseTR, cellUV.x);\n    float noise = mix(noiseB, noiseT, cellUV.y);\n    return noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv += vec2(1., 1.) + iTime * vec2(0.2, 0.3); //We want to avoid near-zero uv values, as it is not displaced correctly.\n    uv *= 4.;\n\n    float noise = 0.;\n    float sumWeight = 0.;\n    float weight = 1.;\n    for (int i = 0; i < 6; ++i) {\n        noise += valueNoise(uv) * weight;\n        sumWeight += weight;\n        weight *= 0.5;\n        uv *= 2.;\n    }\n    \n    noise /= sumWeight;\n    \n    fragColor = vec4(vec3(noise), 1.0);\n}","name":"Image","description":"","type":"image"}]}