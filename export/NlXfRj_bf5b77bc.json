{"ver":"0.1","info":{"id":"NlXfRj","date":"1651083735","viewed":56,"name":"Raymarcher Two","username":"TheKGS","description":"I combined it with with my other shader.\n\nThere's something wrong with the normal calculation which I need to sort out but it *looks* ok.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float surf(vec2 uv, vec2 pnt, float scale, float speed)\n{\n    float dst = length(uv - vec2(pnt.x, pnt.y));\n    return 0.5 + 0.5 * sin(dst * scale - iTime * speed);\n}\n\nfloat pointonsurface(vec2 point)\n{\n    return (0.08 * surf(point, vec2(0.5, 0.5), 179., 2.0) + \n            0.01 * surf(point, vec2(0.2, 1.2), 240., 5.0) +\n            0.01 * surf(point, vec2(0.3, -0.5), 170., 1.0) + 1.5) / 3.0;\n}\n\nvec3 fixvector(vec3 i)\n{\n    i = normalize(i);\n    vec3 f = abs(i);\n    if (f.x >= f.y && f.x >= f.z)\n        return i * 1.0/f.x;\n    else if (f.y >= f.x && f.y >= f.z)\n        return i * 1.0/f.y;\n    else\n        return i * 1.0/f.z;\n}\n\nvec3 getNormal(vec2 uv)\n{\n    float d = 1.0/450.;\n\n    vec2 phor = uv + vec2(d, .0);\n    vec2 pver = uv + vec2(.0, d);\n    \n    float h = pointonsurface(phor);\n    float v = pointonsurface(pver);\n    float p = pointonsurface(uv);\n\n    vec3 uvp = vec3(uv, p);\n    vec3 A = vec3(uv.x,     uv.y + d, v) - uvp;\n    vec3 B = vec3(uv.x + d, uv.y,     h) - uvp;\n    vec3 norm = cross(B, A);\n\n    if (uv.x >= 0.0)\n        return fixvector(norm);\n\n    return vec3(p,p,p);\n}\n\n\n\n\nfloat dfsphere(vec3 point, vec3 center, float radius)\n{\n    return length(point - center) - radius;\n}\n\nfloat dfcube(vec3 point, vec3 center, vec3 size)\n{\n    vec3 dv = abs(point - center) - size;\n    return length(max(dv, 0.0)) + min(max(dv.x, max(dv.y,dv.z)),0.0);\n}\n\nvec3 normsphere(vec3 point, vec3 sphere)\n{\n    return normalize(point - sphere);\n}\n\n\nvec3 normcube(vec3 point, vec3 cube)\n{\n    vec3 o = abs(point);\n    if (o.x >= o.y && o.x >= o.z)\n        return vec3(-1.0, 0.0, 0.0);\n    if (o.y >= o.x && o.y >= o.z)\n        return vec3(0.0, -1.0, 0.0);\n    if (o.z >= o.x && o.z >= o.y)\n        return vec3(0.0, 0.0, -1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    //vec3 norm = vec3(0.0, 0.0, 0.0);\n    vec3 norm = getNormal(uv);\n    vec3 direction = vec3(uv, 1.0) - vec3(0.5, 0.5, 0.0) + 0.003 * norm;\n    direction = normalize(direction);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 curpoint = vec3(0.0, 0.0, 0.0);\n    vec3 rcurpoint = vec3(0.0, 0.0, 0.0); // actual point position\n    float d = 0.0;\n    \n    for (int i = 0; i <= 90; i++){\n        // compute which block we are in\n        vec3 block = floor(rcurpoint + vec3(0.5, 0.5, 0.5));\n        float t = 0.5 + 0.5 * sin(iTime + block.z * 2.0);\n        d = t * dfsphere(curpoint, vec3(0.0, 0.0, 1.0), 0.2) +\n            (1.0 - t) *dfcube(curpoint, vec3(0.0, 0.0, 1.0), vec3(0.2, 0.2, 0.2));\n        //d = df(curpoint, vec3(0.0, 0.0, 1.0), 0.2);\n        //d = dfcube(curpoint, vec3(0.0, 0.0, 1.0), vec3(0.2, 0.2, 0.2));\n\n        if (d <= 0.001)\n        {\n            vec3 norms1 = normsphere(curpoint, vec3(0.0, 0.0, 4.0));\n            vec3 norms2 = normsphere(curpoint, vec3(0.0, 0.0, 1.0));\n            vec3 norms3 = normsphere(curpoint, vec3(0.0, 0.0, 1.0));\n            \n            vec3 normc1 = normcube(curpoint, vec3(0.0, 0.0, 4.0));\n            vec3 normc2 = normcube(curpoint, vec3(0.0, 0.0, 1.0));\n            vec3 normc3 = normcube(curpoint, vec3(0.0, 0.0, 1.0));\n\n            vec3 lightv1 = vec3(0.0, -1.0, -0.4);\n            vec3 lightv2 = vec3(0.0, -1.0, -0.2);\n            vec3 lightv3 = vec3(0.0, -1.0, 0.1);\n\n            col.x = dot(t * norms1 + (1.0 - t) * normc1, lightv1);\n            col.y = dot(t * norms2 + (1.0 - t) * normc2, lightv2);\n            col.z = dot(t * norms3 + (1.0 - t) * normc3, lightv3);\n\n            if (mod(block.x + block.y + block.z, 2.0) < 0.00001)\n                col = col * float(i) / 50.0;\n            else\n                col = col * float(i) / 100.0;\n            \n            break;\n        }\n\n        curpoint = curpoint + d * direction;\n        rcurpoint = rcurpoint + d * direction;\n        vec3 offs = vec3(-0.5, -0.5, 0.0);\n        curpoint = mod ((curpoint - offs), vec3(1.0, 1.0, 1.0)) + offs;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}