{"ver":"0.1","info":{"id":"Mt3BD4","date":"1540035185","viewed":95,"name":"Character Project-SNOWMAN","username":"cake7914","description":"snowman","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["snowman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n    \n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nShape snowman(vec3 s){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 h = s; // Head\n  vec3 b = s; // Body\n  vec3 t = s; // Bottom\n  vec3 u = s; // Buttons\n  vec3 a = s; // Arms\n  vec3 f = s; // Fingers\n  vec3 e = s; // Eyes\n  vec3 r = s; // Hat\n  vec3 m = s; // Mouth\n  vec3 g = s; // Ground\n  vec3 c = s; // Clouds\n  vec3 w = s; // Snow\n  vec3 q = s; // Snowball\n    \n  // Head\n  vec4 hColor = vec4(1., 1., .2, 1.); \n  float head = sphere(s-vec3(0., 2.9, 0.), 2.);\n  \n  // Body\n  vec4 bColor = vec4(.2, 0.5, 0., 1.);\n  float body = sphere(b-vec3(0., -1.5, 0), 3.);\n    \n  // Bottom\n  vec4 tColor = vec4(1., 0., 0., 1.);\n  float bottom = sphere(t-vec3(0., -6., 0), 3.75);\n  \n  // Buttons\n  vec4 uColor = vec4(0., 0., 0., 1.);\n  float button1 = sphere(u-vec3(0., -2., -2.75), .5); // I cannot just repeat along the y axis because of the different\n  float button2 = sphere(u-vec3(0., -0.3, -2.5), .5); // Circumferences of the circles - different buttons have to be farther out, etc\n  \n  // Arms\n  vec4 aColor = vec4(.5, .2, .3, 1.);\n  a.x  = abs(a.x);\n  a.xy *= rot(radians(35.)*sin(iTime)+.5); // Happy snowman :)\n  float arms = fBox(a-vec3(3.5, -2., 0.), vec3(2., .3, 2.));\n  \n  // Fingers\n  //f.x = abs(f.x);\n  //f.xy *= rot(radians(35.)*sin(iTime)); // Happy snowman :)\n  //float finger1 = fBox(f-vec3(5.6, -1.5, 0.), vec3(.2, .5, .5));\n  //float finger2 = fBox(f-vec3(5.6, -2.75, 0.), vec3(.2, .5, .5));\n    \n  // Eyes\n  vec4 eColor = vec4(.2, .6, .7, 1.);\n  e.x = abs(e.x);\n  float eyes = sphere(e-vec3(.75, 3., -2.), .45);\n    \n  // Mouth\n  vec4 mColor = vec4(1., 1., 1., 1.);\n  float mouth = fBox(m-vec3(0., 2., -2.), vec3(1., .25, 1.));\n    \n  // Hat\n  vec4 rColor = vec4(.1, .1, 1., 1.);\n  float hatBottom = fBox(r-vec3(0., 5., 0.), vec3(2., .35, 1.));\n  float hatTop = fBox(r-vec3(0., 6.5, 0.), vec3(1., 1.5, 1.));\n  \n  // Clouds\n  vec4 cColor = vec4(.5, .5, sin(iTime)+.75*3., 1.);\n  float repeat = pMod1(c.x,9.75);\n  c.x = abs(c.x);\n  float clouds = sphere(c-vec3(4., 9., 0.), 3.);\n  \n  // Snow\n  vec4 wColor = vec4(1., 1., 1., 1.);\n  float repeat2 = pMod1(w.x,10.);\n  float repeat3 = pMod1(w.y,8.);\n  w.x = abs(w.x)+1.;\n  w.y = abs(w.y);\n  float snow = sphere(w-vec3(4., 3., 0.), .4);\n    \n  // Snowball\n  q.xy *= rot(radians(35.)*sin(iTime)+.5);\n  float snowball = sphere(q-vec3(6., -2., 0.), 1.25);\n    \n  // Ground\n  vec4 gColor = vec4(2., 2., 2., 1.);\n  float ground = fBox(g-vec3(0., -10., 0.), vec3(20., 2., 0.));\n\n  shape.dist = min(shape.dist, head);\n  shape.dist = min(shape.dist, body);\n  shape.dist = min(shape.dist, bottom);\n  shape.dist = max(shape.dist, -button1);\n  shape.dist = max(shape.dist, -button2);\n  shape.dist = min(shape.dist, arms);\n  //shape.dist = min(shape.dist, finger1);\n  //shape.dist = min(shape.dist, finger2);\n  shape.dist = max(shape.dist, -eyes);\n  shape.dist = max(shape.dist, -mouth);\n  shape.dist = min(shape.dist, hatBottom);\n  shape.dist = min(shape.dist, hatTop);\n  shape.dist = min(shape.dist, clouds);\n  shape.dist = min(shape.dist, snow);\n  shape.dist = min(shape.dist, snowball);\n\n  shape.dist = fOpUnionColumns(shape.dist, ground, 3., 3.); // float fOpUnionColumns(float a, float b, float r, float n)\n  \n  //shape.color = hColor;\n    \n    shape.color = mix(hColor, bColor, mixColors(body, head, 0.));    \n    shape.color = mix(tColor, shape.color, mixColors(shape.dist, bottom, 0.));\n  \tshape.color = mix(uColor, shape.color, mixColors(shape.dist, button1, 0.));\n    shape.color = mix(uColor, shape.color, mixColors(shape.dist, button2, 0.));\n    shape.color = mix(aColor, shape.color, mixColors(shape.dist, arms, 0.));\n  \tshape.color = mix(eColor, shape.color, mixColors(shape.dist, eyes, 0.));\n  \tshape.color = mix(mColor, shape.color, mixColors(shape.dist, mouth, 0.));\n    shape.color = mix(rColor, shape.color, mixColors(shape.dist, hatBottom, 0.));\n    shape.color = mix(rColor, shape.color, mixColors(shape.dist, hatTop, 0.));\n  \tshape.color = mix(gColor, shape.color, mixColors(shape.dist, ground, 0.));\n  \tshape.color = mix(wColor, shape.color, mixColors(shape.dist, snow, 0.));\n  \tshape.color = mix(cColor, shape.color, mixColors(shape.dist, clouds, 0.));\n\tshape.color = mix(wColor, shape.color, mixColors(shape.dist, snowball, 0.));\n\n  return shape;\n}\n\n\nShape map(vec3 s){\n  Shape face = snowman(s);\n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., -20.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  //scene.xz *= rot(sin(iTime*2.));\n  fragColor = vec4(0.1);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape s = map(scene); // Calc SDF\n    if(s.dist < 0.0001){\n      fragColor = s.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n      \n    scene += f * s.dist;\n\n\t}\n}","name":"Image","description":"","type":"image"}]}