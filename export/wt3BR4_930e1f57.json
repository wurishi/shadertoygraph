{"ver":"0.1","info":{"id":"wt3BR4","date":"1612309607","viewed":441,"name":"Constant thickness grid","username":"hamtarodeluxe","description":"Trying to draw an anti-aliased constant thickness grid, as if its lines were screen space.\nThere might be room for improvement. Wish I could go thinner without pattern :)\n","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["grid","lines","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trying to draw an anti-aliased constant thickness grid, as if its lines were screen space.\n// After intersecting the ground plane, grid collisions are searched along the view ray. Grid dilates with distance.\n// Right is the naive constant thickness 2D grid render.\n\nfloat linStep(float x0, float x1, float t)\n{\n    return smoothstep(x0, x1, t);\n    return clamp((t - x0) / (x1 - x0), 0.f,1.f);\n}\n\n// Intersect the 2D unit grid.\n// Returns first and second intersections\n// distances along the ray.\nvec2 intersectGrid(vec2 p, vec2 r)\n{\n    vec2 t = fract(sign(r) * p ) / abs(r);\n    return t.x < t.y ? t.xy : t.yx;\n/*\n    vec2 s = sign(r);\n    vec2 t = vec2(s.x < 0.0f ? fract(p.x) : 1.0f-fract(p.x),\n                  s.y < 0.0f ? fract(p.y) : 1.0f-fract(p.y)) / r;\n    t = abs(t.xy);\n\n    return t.x < t.y ? t.xy : t.yx;\n*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy ) / iResolution.x;\n   \n    // Camera\n    vec3 camPos = vec3 ( 5.*sin(0.1*iTime),2.3,5.0*cos(0.1*iTime));\n   \tvec3 lookAt = vec3 (0.,0.,0.);\n    vec3 fw = normalize(lookAt-camPos);\n    vec3 right = cross(vec3(0.,1.,0.), fw);\n    vec3 up = cross (fw, right);\n    vec3 rd = normalize( fw * 0.6 + right * uv.x + up * uv.y);\n    \n    // Raycast ground\n    vec3 isec = camPos + (camPos.y)* (rd/abs(rd.y));\n    \n    vec2 p = isec.xz;\n    vec2 rdGrid = normalize(rd.xz);\n    \n    vec2 scale = vec2(0., 1.7) / iResolution.x;    \n    float v = 1.0f;\n    vec2 t;\n    vec2 rdSearch2D;\n    vec3 rdSearch;\n    \n    // Intesects in direction +rd\n    rdSearch2D = rdGrid;\n    rdSearch = rd;\n    t = intersectGrid(p, rdSearch2D);\n    {\n        // First intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.x);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n    {\n        // Second intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.y);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n    \n    // Intesects in direction -rd\n    rdSearch2D = -rdGrid;\n    rdSearch = -rd;\n    t = intersectGrid(p, rdSearch2D);\n    {\n        // First intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.x);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n    {\n        // Second intersection\n        vec3 isec2 = isec + (rdSearch/abs(rdSearch.x)) *  abs(rdSearch2D.x*t.y);\n        float s = length(camPos - vec3(isec2.x, 0, isec2.z));\n        v *= linStep(scale.x * s, scale.y * s, abs(isec2.y));\n    }\n\n    // Naive 2D grid render, for\n    // view forward parallel rays.\n    // Also used for reference.\n    {\n        vec2 frp = fract(p);\n        vec2 ceilp = ceil(p);\n        vec2 floorp = floor(p);\n        vec2 d = vec2(frp.x > 0.5f ? ceilp.x : floorp.x, frp.y > 0.5f ? ceilp.y :floorp.y);\n        vec2 dd = abs(p - d);\n        vec2 closest = dd.x < dd.y ? vec2(d.x, p.y) :  vec2(p.x, d.y);               \n        float s = length(camPos - vec3(closest.x, 0., closest.y));\n        float sdf = length(p-closest);\n        \n        float v0 = linStep(scale.x * s, scale.y * s, sdf);\n        v *= v0;\n        \n        // Naive method reference.\n        if (uv.x>0.)\n            v = linStep(scale.x * s, scale.y * s, sdf);\n    }\n    \n    fragColor = rd.y < 0.0f ? vec4(mix(0.53, 0.006, v)) : vec4(0.);\n    fragColor = pow(fragColor, vec4(1./2.2) );\n}","name":"Image","description":"","type":"image"}]}