{"ver":"0.1","info":{"id":"tsdSWn","date":"1572531131","viewed":273,"name":"Rasterization-Projection","username":"sapporo_dynamite","description":"software rasterization\nimplemented Projection Stage","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["rasterizer","zbuffer","perspectivecorrect","cullmode","fillmode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tRasterizer\n\n\tSoftware Rasterization\n\tImplemented Projection Stage\n\n\tauthor:\n\tsapporo_dynamite/2019 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n　　Reference：\n\n\tShader\n\t\tUI easy to integrate \n    \tfrom XT95 Shader : https://www.shadertoy.com/view/ldKSDm\n\n\t\tRasterizer - Cube \n\t\tiq　: https://www.shadertoy.com/view/XdlGzn\n\n\tURL\n\t\t透視投影変換 - ぽんこつでばいす\n\t\thttp://angra.blog31.fc2.com/blog-entry-114.html\n\n\t\t床井研究室 - 第5回 座標変換 - 和歌山大学\n\t\thttp://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20090829\n*/\n\n/*\n2019/10/30\n\t0.0.0 → 1.0.0\n\t・最初のリリース\n*/\n\nstruct Triangle\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 c0;\n    vec3 c1;\n    vec3 c2;\n};\n\nTriangle triangles[1];\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setPerspective( float fovy, float aspect, float near, float far)\n{\n    float d = 1. / (tan( radians(fovy) * 0.5 ));\n    float q = far  / ( far - near );\n    return mat4( d/aspect,    0,   0,        0,\n        \t\t        0,    d,   0,        0,\n                        0,    0,  -q,       -1,\n                        0,    0,  -q * near, 0 );\n}\n\nmat4 SetOrtho( float l, float r, float b, float t, float near, float far)\n{\n    float q = far  / ( far - near );\n    return mat4( 2./(r-l),        0,              0,                             0,\n                 0,               2./(t-b),       0,                             0,\n                 0,               0,              (1. / (far - near) * 0.5),     0,\n                 -(r+l)/(r-l),   -(t+b)/(t-b),    (-near / (far - near) + 0.5),  1 );\n}\n\n\nvoid createTriangle( void )\n{\n    triangles[0].p0 = vec3( 0.0,  1.0, -0.0); \n    triangles[0].c0 = vec3( 1.0,  0.0,  0.0); \n    triangles[0].p1 = vec3(-1.0, -1.0, -0.0);\n    triangles[0].c1 = vec3( 0.0,  1.0,  0.0); \n    triangles[0].p2 = vec3( 1.0, -1.0, -0.0);\n    triangles[0].c2 = vec3( 0.0,  0.0,  1.0);\n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nfloat edge(vec2 a, vec2 b, vec2 c) \n{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n} \n\nfloat line( vec2 a, vec2 b, vec2 p, float r)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (length( pa - ba*h ) - r);    \n}\n\nbool uiBool(int id) {\n    return texture(iChannel0, vec2(float(id)+.5,2.5)/iResolution.xy).x > 0.0;\n}\nvec4 uiSlider(int id){\n    return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}\n\nfloat uiSliderMinMax(int id, float min_v, float max_v){\n    vec4 v = uiSlider(id);\n    return (1.0 - v.r) * min_v + v.r * max_v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    bool PERSP = uiBool(1);\n    bool OUT_COLOR = uiBool(2);\n    bool PERSP_CORRECT = true;\n    bool FILL_SOILD =  true;\n    bool CULL_MODE  =  true;\n   \n    float n = uiSliderMinMax(0, 0.1, 4.);\n    float f = uiSliderMinMax(1, 3., 9.9);\n    float aspect = iResolution.x / iResolution.y;\n    float fov = uiSliderMinMax(2, 1., 99.);\n    \n    // Projeciotn Matrix\n    mat4 proj = PERSP ? setPerspective(fov, aspect, n, f) : SetOrtho(-1.5 * aspect, 1.5 * aspect, -1.5, 1.5, n, f);    \n    \n    mat4 modelViewProj = proj * setTranslation( 0.0, 0.0, -3.5 ) * setRotation( 0.0, 3.1*sin(0.3*iTime), 0.0);\n    \n    vec2 px = (-iResolution.xy + 2.0*fragCoord) / iResolution.xy;\n    \n    // clear color\n    vec3 col = vec3(float(0x4c)/255.0, float(0x7f)/255.0, float(0xb2)/255.0);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n       \n    // line width\n    float line_width = 0.004;\n    \n    // clear zbuffer\n    float mindist = -1000000.0;\n    \n    // setup triangle\n    createTriangle();\n        \n    // 三角形の描画\n    // render triangles\n    for( int i = 0; i < 1; i++ )\n    {\n        // モデル&ビュー&投影 座標系 変換\n        // transform modelViewProj space\n        vec4 v0 = (modelViewProj * vec4(triangles[i].p0, 1));\n        vec4 v1 = (modelViewProj * vec4(triangles[i].p1, 1));\n        vec4 v2 = (modelViewProj * vec4(triangles[i].p2, 1));\n        \n        // クリップ座標系 変換\n        // transform clip space\n        float w0 = 1.0 / v0.w;\n        float w1 = 1.0 / v1.w;\n        float w2 = 1.0 / v2.w;\n            \n        \n        // 正規化デバイス座標系 変換\n        // transform NDC\n        vec3 c0_ndc = triangles[i].c0 * (PERSP_CORRECT ? w0 : 1.0);\n        vec3 c1_ndc = triangles[i].c1 * (PERSP_CORRECT ? w1 : 1.0);\n        vec3 c2_ndc = triangles[i].c2 * (PERSP_CORRECT ? w2 : 1.0);\n        \n        // xy\n        vec2 v0_ndc = v0.xy * w0;\n        vec2 v1_ndc = v1.xy * w1;\n        vec2 v2_ndc = v2.xy * w2;\n        \n        // z\n        float z0_ndc = v0.z * w0;\n        float z1_ndc = v1.z * w1;\n        float z2_ndc = v2.z * w2;\n       \n        // サブ三角形の面積計算\n        // calculate areas for subtriangles        \n        float e = edge( v1_ndc, v0_ndc, v2_ndc);\n        \n        vec3 area_ccw = vec3( edge( v1_ndc, v0_ndc, px),\n                              edge( v2_ndc, v1_ndc, px),\n                              edge( v0_ndc, v2_ndc, px) );\n        \n        vec3 line_area = vec3( line(v0_ndc, v1_ndc, px, line_width),\n                               line(v1_ndc, v2_ndc, px, line_width),\n                               line(v2_ndc, v0_ndc, px, line_width) );\n      \n         // ピクセルが三角形に重なるかどうか  \n         // pixel overlaps the triangle\n         bool ccw_test  = all(greaterThan(area_ccw,vec3(0.0))) && FILL_SOILD;\n         bool cw_test   = all(lessThan(area_ccw,vec3(0.0))) && FILL_SOILD && CULL_MODE;\n         bool line_test = !all(greaterThan(line_area,vec3(0.0))) && !FILL_SOILD;;\n        \n         \n         // ラスタライズ\n         // Rasterize \n         if( ccw_test || cw_test || line_test)\n         {\n             // 重心座標は サブ三角形の面積を全体の三角形の面積で割ったもの \n             // barycentric coordinates are the sub-triangle area divided by total triangle area.\n              vec3 ba = vec3(ccw_test || cw_test) * area_ccw.yzx / ( area_ccw.x + area_ccw.y + area_ccw.z) + \n                        vec3(line_test)  *  area_ccw.yzx / ( e );\n             \n\n             // 頂点属性の 重心補間\n             // barycentric interpolation of attributes and 1/z\n             float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n             vec2  uv = vec2(0, 0);            \n             vec3  color = vec3(ba.x * c0_ndc.x + ba.y * c1_ndc.x + ba.z * c2_ndc.x,\n                                ba.x * c0_ndc.y + ba.y * c1_ndc.y + ba.z * c2_ndc.y,\n                                ba.x * c0_ndc.z + ba.y * c1_ndc.z + ba.z * c2_ndc.z );\n             \n             // zs[ 0～1 ]\n             float zs = ba.x*z0_ndc + ba.y*z1_ndc + ba.z*z2_ndc;\n             // 補間された値 を 戻す\n             // recover interpolated attributes\n             float z =  1.0/iz;\n             \n             // z near/far clip\n             // ニア/ファー クリップ\n             if( zs >= 0.0 && zs <= 1.0)\n             {\n                 // depth buffer test\n                 // Zバッファ テスト\n                 if( zs > mindist )\n                 {\n                        mindist = zs;\n                        color *= (PERSP_CORRECT ? z : 1.0);\n                        col = OUT_COLOR ? vec3( color) :vec3( zs ) ;\n                 }\n             }\n         }\n    }\n      \n    // UI を 合成 \n    // UI integration\n    vec4 ui = texture(iChannel0, uv);\n    col = mix(col,ui.rgb, ui.a);\n    \n    // 出力\n    // Output to screen\n    fragColor = vec4(col,1.0);\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n\n// NO MINIFIED VERSION : https://www.shadertoy.com/view/XsySzG\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.3,1.,.3)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _dsh  col += vec4( char(ch_dsh) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v, 0.,1.);\n#define _slider_minmax(x,y,id,v, min_v,max_v) setCursor(x,y);print_slider(id,v, min_v, max_v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n#define _bool(x,y,id,v,key) setCursor(x,y);print_bool(id,v,key);\n\n/* gfx func */ \nvoid setCursor(int x, int y)\n{\n    pos = vec2(float(x),iResolution.y-float(y));\n}\nfloat extract_bit(float n, float b)\n{    \n    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}\nfloat char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}\nvec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}\nvec3 widgetSelected(){    \n    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;\n}\nvec4 uiSlider(int id){\n    return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}\nvec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}\nvec4 uiBool(int id) {\n    return texture(iChannel0, vec2(float(id)+.5,2.5)/iResolution.xy);\n}\nfloat roundBox( in vec2 p, in vec2 b, in float r ) {    \n    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}\n\nvoid check_box(){\n    \n}\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nvoid print_bool( int id, bool v, int key)\n{\n    vec2 puv = uv-vec2(.5);\n    vec3 select = widgetSelected();\n    vec4 value = uiBool(id);\n    value.r = v ? 1.0 - float(keyToggle(key)) : float(keyToggle(key));\n    if(value.g == 0.)value.r = float(v);\n    if(puv.x == float(id) && puv.y==2.)        col = vec4(value.r,1.,0.,0.);\n}\n\nvoid print_slider( int id, float v , float min_v, float max_v){    \n    vec2 puv = uv-vec2(.5);\n    vec3 select = widgetSelected();\n    float sl2 = SLIDER_LENGTH/2.;\n    vec4 value = uiSlider(id); \n    if(value.a == 0.){\n        value.r = v;  \n    }\n    bool selected = ( select.r == .1 && select.g*255. == float(id) );\n    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;\n    if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);\n    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);\n    float layer = clamp(sign(-d),0.,1.);\n    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );\n   \n    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );\n    col.a += layer + clamp( 1.-abs(d) , 0., 1.);\n    float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;\n    _float((1.0 -value.r) * min_v + value.r * max_v);    pos.x = oldx; \n    if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0,0, 1.);\n    if(puv.x == 0. && puv.y == 2.)    {        \n        if(iMouse.w<.5)            col = vec4(0.);\n        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);\n         }\n}\nvoid print_color( int id, vec3 v){    \n    vec2 puv = uv-vec2(.5);\n    vec3 select = widgetSelected();\n    float sl2 = SLIDER_LENGTH/2.;\n    vec4 color = uiColor(id);\n    if(color.a == 0.)        color.rgb = v;\n    bool selected = ( select.r == .2 && select.g*255. == float(id) ); \n    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;\n    if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );\n    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);\n    float layer = clamp(sign(-d),0.,1.);\n    //col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));\n    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );\n    col.a += layer + clamp( 1.-abs(d) , 0., 1.); \n    if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)\n        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) ); \n    if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);\n    if(puv.x == 0. && puv.y == 2.)    \n    {        \n        if(iMouse.w<.5)col = vec4(0.);\n        else if(mouseAndNoSelect)\n        col = vec4(.2,float(id)/255.,0.,0.);    \n    }\n}\nvoid print_box(vec2 p, vec2 s, vec4 c){    \n    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)       \n        col += c;\n}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    _box(vec2(5,10),vec2(158,iResolution.y-20.),vec4(0.,0.,0.,.25))\n        \n    _cursor(10,int(iResolution.y)-20) _P _r _o _j _e _c _t _i _o _n _spc _t _e _s _t\n   \n    _cursor(10, 30) _P _r _e _s _s _K _e _y _spc _int(1.0) _dsh _int(2.0)\n    _bool(10, 50, 1, true, 49)  _k _int(1.0) _spc _P _r _o _j _spc\n    if(uiBool(1).r>0.5) {_P _e _r _s _p _e _c _t _i _v _e} else {_O _r _t _h _o};\n    _bool(10, 70, 2, true, 50)  _k _int(2.0) _spc _O _u _t _C _o _l _o _r _spc\n    if(uiBool(2).r>0.5) {_C _o _l _o _r} else {_Z _B _u _f _f _e _r};\n\n    _slider_minmax(10, 90, 0, 0., 0.1, 4.0) _Z _N _e _a _r;    \n    _slider_minmax(10, 110, 1, 0.9, 3.0, 9.9) _Z _F _a _r;    \n    _slider_minmax(10, 130, 2, 0.5, 1., 99.0) _F _o _v _y;  \n    fragColor = min(col.rgba,1.);\n}\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}