{"ver":"0.1","info":{"id":"Wd2XRz","date":"1553087464","viewed":81,"name":"March Me","username":"BowToes","description":"to the motherland. This is yet another ray marching practice shader. The hardest part I've been having difficulty with is the lighting and shading. More info in the comments. Also infinite donuts","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["none"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n#define MAX_MARCH 500\n#define EPS 0.00001\n// the difference in size between\n// MIN_DIST and EPS can cause interesting\n// lighting. No clue why though\n\nfloat sdScene(in vec3 p)\n{    \n    mat3 ry = rotZ(degrees(-iTime));\n    vec3 rp = ry*opRep(p+1.*VY, (VX+VY)*3.);\n    float d1 = sdTorus(rp, vec2(1., 0.5));\n    float d2 = sdPlane(p, vec4(0, 1, 0, 1.));\n    return opU(d1,d2);\n}\n\n// iq\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*EPS ) + \n                      k.yyx*sdScene( p + k.yyx*EPS ) + \n                      k.yxy*sdScene( p + k.yxy*EPS ) + \n                      k.xxx*sdScene( p + k.xxx*EPS ) );\n}\n\n// A little from iq's and jamie wong's tutorials.\nvec4 march(in vec3 o, in vec3 d)\n{\n    float s = MIN_DIST;\n    vec3 p;\n    for (int i = 0; i < MAX_MARCH; i++)\n    {\n        p = o + s * d;\n        float sd = sdScene(p);\n        if (sd <= EPS)\n            break;\n        s += sd;\n        if (s > MAX_DIST)\n        { s = MAX_DIST; break; }\n    }\n    return vec4(p, s+EPS);\n}\n\n\n// I did my best with this to copy as little\n// from others' code as possible, taking from the \n// wiki page instead: https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n// I also took the shadow code from https://www.shadertoy.com/view/tdlXDs\nvec3 light(in vec3 eye, in vec4 mch, in L l, in M m)\n{\n    // This code kinda works, but for certain\n    // material parameters it breaks and I don't\n    // know why.\n    vec3 p = mch.xyz;\n    vec3 N = calcNormal(p);\n    vec3 V = normalize(eye - p);\n    vec3 L = normalize(l.p - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float LN = dot(L, N);\n    float RV = dot(R, V);\n    \n    // I'd like to figure out\n    // how to dim the light as\n    // the point gets further from\n    // the lihgt but I haven't been able.\n    float shadow = 1.;\n    vec4 d = march(p, L);\n    if (d.w < length(l.p - p))\n        shadow = 0.1;\n    \n    vec3 diffuse = LN * m.d * (m.kd+l.c);\n    vec3 specular = m.ks * pow(max(0., RV), m.alpha) * m.s;\n    \n    return shadow * (diffuse + specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dTime = degrees(iTime);\n    \n    L l1, l2, l3, l4;\n    M ma;\n    // Lights and material config\n    {\n    \tl1.p = vec3(0, .25, 0);\n    \tl1.c = 1.5*normalize(vec3(1.0, .0, 0.0));\n    \t\n    \tl2.p = vec3(5, 1, 5)*rotY(dTime);\n    \tl2.c = 1.5*normalize(vec3(0.0, 1., 0.0));\n    \t\n    \tl3.p = vec3(5, 1, 5)*rotY(-dTime*3.+100.);\n    \tl3.c = 1.5*normalize(vec3(0.0, 0.0, 1.0));\n        \n    \tl4.p = vec3(0, 10, 0);\n        l4.c = 1.5*normalize(vec3(1.0, 1.0, 0.8));\n        \n    \tma.d = vec3(1, 1, 1.0);\n    }\n    \n    float t = 0.*iTime;\n    vec2 m = dots(iMouse.xyx) != 0. ? (2.*iMouse.xy - iResolution.xy)/iResolution.y\n        \t : vec2(0.);\n    mat3 rt = rot(degrees(vec3(0, t+m.x, 0.*-t/2.)));\n    \n    vec3 eye = rt * vec3(0, max(0.,-10.*m.y), 6);\n    vec3 dir = rt * rotX(45.*m.y) * pix2dir(radians(60.), iResolution.xy, fragCoord);\n    \n    \n    vec4 res = march(eye, dir);\n    vec3 col = vec3(0, 0, 0);\n    if (res.w <= MAX_DIST - EPS)\n    {\n        // I square the lights, then square root their average in accordance with\n        // https://www.youtube.com/watch?v=LKnqECcg6Gw\n        \n        col += sqr(light(eye, res, l1, ma));\n        col += sqr(light(eye, res, l2, ma));\n        col += sqr(light(eye, res, l3, ma));\n        col += sqr(light(eye, res, l4, ma));\n        col = sqrt(col/4.);\n    }\n    col += ma.a*ma.ka;\n    \n    fragColor = vec4(clamp(col, 0., 1.), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SIN(x) (.5+.5*sin(x))\n#define COS(x) (.5+.5*cos(x))\n\n#define eix(x) (vec2(cos(x), sin(x)))\n#define EIX(x) (vec2(COS(x), SIN(x)))\n\n#define VX vec3(1., 0., 0.)\n#define VY vec3(0., 1., 0.)\n#define VZ vec3(0., 0., 1.)\n\nvec3 sqr(vec3 x) {return x * x;}\nfloat sqr(float x) {return x * x;}\n\nconst float PI = acos(-1.);\n\n// Light struct, position & color\nstruct L\n{\n    vec3 p, c;\n};\n// Phong material struct\nstruct M\n{\n    vec3 d, s, a;\n    float alpha, kd, ks, ka;\n};\n\nfloat dots(vec3 n) { return dot(n,n); }\nfloat dot2(vec3 a, vec3 b) { return max(0., dot(a,b)); }\n    \nmat3 rotX(float t)\n{\n    t = radians(t);\n    return mat3\n    (\n        1,    0,     0,\n        0,  cos(t), sin(t),\n        0, -sin(t), cos(t)\n    );\n}\nmat3 rotY(float t)\n{\n    t = radians(t);\n    return mat3\n    (\n        cos(t), 0, -sin(t),\n          0,    1,   0,\n        sin(t), 0,  cos(t)\n    );\n}\nmat3 rotZ(float t)\n{\n    t = radians(t);\n    return mat3\n    (\n         cos(t), sin(t), 0,\n        -sin(t), cos(t), 0,\n           0,      0,    1\n    );\n}\nmat3 rot(vec3 t)\n{ return rotX(t.x)*rotY(t.y)*rotZ(t.z); }\nmat3 rot(float x, float y, float z)\n{ return rotX(x)*rotY(y)*rotZ(z); }\n\nvec3 pix2dir(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    return normalize(vec3(2. * fragCoord - size, \n                          -size.y / tan(.5 * fieldOfView)));\n}\n\n// ++== SDFs ==++ //\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(in vec3 p, in float r)\n{ return length(p) - r; }\nfloat sdBox(in vec3 p, in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0))\n         + min(max(d.x,max(d.y,d.z)), 0.0); // remove this line for an only partially signed sdf \n}\nfloat sdBox(in vec3 p, in float x, in float y, in float z)\n{ return sdBox(p, vec3(x, y, z)); }\nfloat sdPlane( vec3 p, vec4 n )\n{ return dot(p,n.xyz) + n.w; }\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{ return length(p.xz-c.xy)-c.z; }\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ++== SDF ops ==++ //\n//\nfloat opRound(float p, float r)\n{ return p - r; }\nvec3 opBend(in vec3 p, in float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\nfloat opU(float d1, float d2) { return min( d1,d2); }\nfloat opS(float d1, float d2) { return max(-d1,d2); }\nfloat opI(float d1, float d2) { return max( d1,d2); }\nfloat opSU(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSS(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat opSI(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\nvec3 opRep(in vec3 p, in vec3 c)\n{ return mod(p,c)-0.5*c; }\n// --== SDF ops ==-- //\n// --== SDFs ==-- //","name":"Common","description":"","type":"common"}]}