{"ver":"0.1","info":{"id":"dljBz1","date":"1693837350","viewed":44,"name":"shadowww","username":"nenuser","description":"shadowwww","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shadowwww"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_CYLINDERS 10 \n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n} sphere;\n\nstruct Light\n{\n\tvec3 direction;    \n} light;\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n}plane;\n\nstruct Cylinder\n{\n    vec3 color;\n    vec3 position;\n    vec3 axis;   // normalized direction of the cylinder's axis\n    float diameter;\n    float height;\n} cylinder;\n\n\nconst int numCylinders = 3; // Or however many cylinders you need\nCylinder cylinders[numCylinders];\n\nconst int numSpheres = 2;  // or any number you'd like\nSphere spheres[numSpheres];\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n   camera.direction = normalize(camera.position);\n    camera.zoom = 2.0;\n       // For example, let's assume we have 3 cylinders\n    \n    // Initialize the cylinders\n    cylinders[0].position = vec3(0.1, 0.06, 2.2);\n    cylinders[0].axis = normalize(vec3(1.7, 0.8, -2.));\n    cylinders[0].diameter = 0.2;\n    cylinders[0].height = 1.;\n    cylinders[0].color = vec3(0.1, 0.0, 1.0);\n\n    // Initialize the second cylinder\n    cylinders[1].position = vec3(-0.3, 0.2, 2.1);\n    cylinders[1].axis = normalize(vec3(-0.5, 0.5, 1.0));\n    cylinders[1].diameter = 0.1;\n    cylinders[1].height = 0.5;\n    cylinders[1].color = vec3(1.0, 0.0, 0.0);\n     cylinders[2].position = vec3(0.0, -0.5, 0.0);\n    cylinders[2].axis = normalize(vec3(1.0, 1.0, 1.0));\n    cylinders[2].diameter = 0.15;\n    cylinders[2].height = 0.7;\n    cylinders[2].color = vec3(0.0, 1.0, 0.0);\n    \n    plane.point = vec3(0., -0.5, 0.);\n    plane.normal = vec3(0., 1., 0.);\n    plane.color = vec3(0.5, 0.5, 0.5);  // Plane color is grey\n    \n    \n    spheres[1].position = vec3(0.5, 0.5, 1.);\n    spheres[1].radius = 0.3;\n    spheres[1].color = vec3(0.2, 0.9, 0.3);\n    \n    spheres[0].position = vec3(-0.5, 1., -1.);\n    spheres[0].radius = 0.3;\n    spheres[0].color = vec3(0.9, 0.9, 0.3);\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nmat3 rotationToY(vec3 dir)\n{\n    vec3 yAxis = vec3(0.0, 1.0, 0.0);\n    vec3 v = cross(dir, yAxis);\n    float s = length(v);\n    float c = dot(dir, yAxis);\n    \n    mat3 vMat = mat3(0, -v.z, v.y,\n                     v.z, 0, -v.x,\n                     -v.y, v.x, 0);\n\n    return mat3(1.0) + vMat + vMat * vMat * ((1.0 - c) / (s * s));\n}\n\nbool intersectCaps(Cylinder cylinder, vec3 rayOriginLocal, vec3 rayDirLocal, out vec3 surfaceNormal, out float tHit)\n{\n    // Check bottom cap (y = 0 in the local coordinate system)\n    float tBottom = -rayOriginLocal.y / rayDirLocal.y;\n    vec3 pBottom = rayOriginLocal + tBottom * rayDirLocal;\n    if (tBottom > 0.0 && pBottom.x * pBottom.x + pBottom.z * pBottom.z <= (cylinder.diameter * 0.5) * (cylinder.diameter * 0.5))\n    {\n        tHit = tBottom;\n        surfaceNormal = vec3(0.0, -1.0, 0.0);\n        return true;\n    }\n    \n    // Check top cap (y = height in the local coordinate system)\n    float tTop = (cylinder.height - rayOriginLocal.y) / rayDirLocal.y;\n    vec3 pTop = rayOriginLocal + tTop * rayDirLocal;\n    if (tTop > 0.0 && pTop.x * pTop.x + pTop.z * pTop.z <= (cylinder.diameter * 0.5) * (cylinder.diameter * 0.5))\n    {\n        tHit = tTop;\n        surfaceNormal = vec3(0.0, 1.0, 0.0);\n        return true;\n    }\n    \n    return false;\n}\n\nbool intersect(vec3 rayOrigin, vec3 rayDirection, out vec3 surfaceNormal, Cylinder cylinder)\n{\n    mat3 rotationMatrix = rotationToY(cylinder.axis);\n    mat3 inverseRotation = transpose(rotationMatrix);\n    \n    vec3 rayOriginLocal = inverseRotation * (rayOrigin - cylinder.position);\n    vec3 rayDirLocal = inverseRotation * rayDirection;\n\n    float r = cylinder.diameter * 0.5;\n\n    float a = rayDirLocal.x * rayDirLocal.x + rayDirLocal.z * rayDirLocal.z;\n    float b = 2.0 * (rayOriginLocal.x * rayDirLocal.x + rayOriginLocal.z * rayDirLocal.z);\n    float c = rayOriginLocal.x * rayOriginLocal.x + rayOriginLocal.z * rayOriginLocal.z - r * r;\n\n    float t0, t1;\n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = min(t0, t1);\n        vec3 PhitLocal = rayOriginLocal + t * rayDirLocal;\n\n        float yDiff = PhitLocal.y;\n        if(yDiff < 0.0 || yDiff > cylinder.height)\n        {\n            // If there's no intersection with the cylindrical part, check the caps\n            if(intersectCaps(cylinder, rayOriginLocal, rayDirLocal, surfaceNormal, t))\n            {\n                return true;\n            }\n            return false;\n        }\n\n        vec3 Phit = rotationMatrix * PhitLocal + cylinder.position;\n        surfaceNormal = normalize(rotationMatrix * vec3(PhitLocal.x, 0.0, PhitLocal.z));\n\n        if (abs(yDiff) < 0.0001 || abs(yDiff - cylinder.height) < 0.0001)\n        {\n            surfaceNormal.y = -sign(yDiff - (0.5 * cylinder.height));\n        }\n        \n        return true;\n    }\n    return false;\n}\n\n\n\n\n\n\nbool intersectPlane(vec3 direction, out vec3 Phit)\n{\n    float denom = dot(plane.normal, direction);\n    if (abs(denom) < 0.0001) return false;  // parallel to the plane\n    \n    float tTemp = dot(plane.point - camera.position, plane.normal) / denom;\n    if (tTemp >= 0.) {\n        Phit = camera.position + direction * tTemp;\n        return true;\n    }\n    \n    return false;\n}\n\nbool intersect_sphere(Sphere sphere, vec3 rayOrigin, vec3 rayDirection, out vec3 surfaceNormal, out float tHit)\n{\n    vec3 L = rayOrigin - sphere.position;\n    \n    float a = dot(rayDirection, rayDirection);\n    float b = 2. * dot(rayDirection, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0, t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        tHit = t0;\n        if (t1 < t0)\n        {\n            tHit = t1;\n        }\n        \n        vec3 Phit = rayOrigin + tHit * rayDirection;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\nbool isInShadow(vec3 point, vec3 toLight)\n{\n    vec3 surfaceNormal;\n    float tHit;\n\n    // Check for shadows due to cylinders\n    for (int i = 0; i < numCylinders; ++i) \n    {\n        if (intersect(point + 1e-4 * toLight, toLight, surfaceNormal, cylinders[i]))\n        {\n            return true;\n        }\n    }\n\n    // Check for shadows due to spheres\n    for (int i = 0; i < numSpheres; ++i)\n    {\n        if (intersect_sphere(spheres[i], point + 1e-4 * toLight, toLight, surfaceNormal, tHit))\n        {\n            if (tHit > 1e-4) // To avoid self-shadowing\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    vec3 Phit;\n    float tHit;\n\n    // Check for intersections with cylinders\n    for (int i = 0; i < numCylinders; ++i) \n    {\n        if (intersect(camera.position, direction, surfaceNormal, cylinders[i]))\n        {\n            float coeff = -dot(light.direction, surfaceNormal);\n            vec3 potentialColor = coeff * cylinders[i].color;\n            \n            if (!isInShadow(camera.position + tHit * direction, -light.direction))\n            {\n                return potentialColor;  // Exit early if a cylinder is hit\n            }\n            else\n            {\n                return 0.5 * potentialColor;  // Shadowed color\n            }\n        }\n    }\n\n    // Check for intersections with spheres\n    for (int i = 0; i < numSpheres; ++i)\n    {\n        if (intersect_sphere(spheres[i], camera.position, direction, surfaceNormal, tHit))\n        {\n            vec3 Phit = camera.position + tHit * direction;\n            float coeff = -dot(light.direction, surfaceNormal);\n            vec3 potentialColor = coeff * spheres[i].color;\n            \n            if (!isInShadow(Phit, -light.direction))\n            {\n                return potentialColor;  // Exit early if a sphere is hit\n            }\n            else\n            {\n                return 0.5 * potentialColor;  // Shadowed color\n            }\n        }\n    }\n\n    // Check for intersections with the plane\n    if (intersectPlane(direction, Phit))\n    {\n        vec3 col = plane.color;\n        \n        if (isInShadow(Phit, -light.direction))\n        {\n            col *= 0.5;  // Darken the color if in shadow\n        }\n        \n        return col;\n    }\n\n    return vec3(0., 0., 0.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupScene();\n\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;  // Adjust for aspect ratio\n\n    vec3 initialRayDir = normalize(vec3(uv.x, uv.y, -camera.zoom));\n\n    // Create an \"up\" vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Create a \"right\" vector\n    vec3 right = normalize(cross(camera.direction, up));\n\n    // Recalculate the \"up\" vector\n    up = normalize(cross(right, camera.direction));\n    \n    vec3 term1 = initialRayDir.x  * right;\n    vec3 term2 = initialRayDir.y * up;\n    vec3 term3 = initialRayDir.z * camera.direction;\n\n    // Apply rotation\n    vec3 rotatedRayDir = term1 + term2 + term3;\n\n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n\n    vec3 col = rayTrace(rotatedRayDir);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}