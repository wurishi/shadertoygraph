{"ver":"0.1","info":{"id":"Xl33Wn","date":"1468620741","viewed":707,"name":"Worley Algorithm (Cell Noise )","username":"Yeis","description":"Application of Worley Cell Noise Algorithm, basic immplementation","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley","yeis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float length2(vec2 p){\n    //producto punto entre los 2 vectore vx*vx + vY*vY\n    return dot(p,p);\n}\nfloat noise(vec2 p )\n{\n    //funcion de ruido pseudo-aleatoria basada en la funcio seno \n    return fract(cos(fract(sin(p.x)*(41.13311))+ p.y)*31.0011);\n}\n\nfloat worley(vec2 p) {\n    //ponemos un numero grandote \n float d = 1e30;\n    //checamos todos los puntos vecinos en 9 direcciones \n for (int xo = -1; xo <= 1; ++xo) {\n  for (int yo = -1; yo <= 1; ++yo) {\n   vec2 tp = floor(p) + vec2(xo, yo);\n   d = min(d, length2(p - tp - noise(tp)));\n  }\n }\n    //funcion exponencial mamona 3.0*exp(-4.0*abs(2.0*d - 1.0)).\n  return 3.0*exp(-4.0*abs((2.5*d)-1.0));\n}\n\nfloat fworley(vec2 p)\n{\n    return sqrt(sqrt(sqrt(worley(p * 5.0 + 0.05 * iTime) * \n                          sqrt(worley(p*50.0+ 0.12+ -0.1*iTime)) *\n                         sqrt(sqrt(worley(p*-10.0+00.03*iTime))))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n    float wolo = fworley(uv*iResolution.xy / 1500.0);\n    //Repeat the grid pattern 5 times by multiplying by uv.\n \twolo *= exp(-length2(abs(0.7*uv-1.0)));\n    fragColor = vec4(wolo * vec3(.1, 0.5*wolo, pow(wolo, 0.50-wolo)), 1.0);\n}\n\n//link http://ibreakdownshaders.blogspot.mx/","name":"Image","description":"","type":"image"}]}