{"ver":"0.1","info":{"id":"ttdSD7","date":"1581133000","viewed":208,"name":"Physically Based Raytracing","username":"JackSolace","description":"Physically Based Raytrace of a sphere\nBased on https://www.shadertoy.com/view/XlKSDR\n\nSecond bounce only, 9 rays per fragment default","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","specular","reflect","learn","pbr","physicallybased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Feb 2020\n//Physically Based Raytrace of a sphere\n//Based on https://www.shadertoy.com/view/XlKSDR\n\n#define PI 3.14159265359\n\n//Ray hit struct\nstruct Hit {\n\tvec3 pos;\n    vec3 normal;\n    float mat;\n};\n   \n//ray struct\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n\tvec3 center;  // Center of the Sphere\n\tfloat radius; // Radius of the Sphere\n    float mat;\n};\n    \nstruct Plane {\n\tvec3 normal; //Normal vector\n    vec3 point; //Some point such that for all points p in the plane dot((p-point),normal) == 0\n\tfloat mat;\n};\n\n    \n    \n// From the Wikipedia page on Line-Plane intersection\nfloat intersect_plane(in Ray ray, in Plane plane) {\n\tfloat denominator = dot(ray.direction,plane.normal);\n    if(abs(denominator) >= 0.01) {//make sure Ray is not parallel to plane (or nearly parallel)\n        return dot((plane.point - ray.origin),plane.normal)/denominator;\n    }\n\treturn -1.0; // Any negative number to indicate no intersect (or intersection from behind)\n}\n\n// From the Wikipedia page on Line-sphere intersection\nfloat intersect_sphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance from the ray origin to point of intersection\n    //bear in mind that there may be more than one solution\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, get ray intersection depth\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant);\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\n//Get the sphere surface normal from the intersection point\nvec3 sphere_normal(in vec3 intersect, in Sphere sphere) {\n\treturn normalize(intersect - sphere.center);\n} \n\n//Get the 3d point that is depth along the ray\nvec3 intersection_point(in Ray ray, in float depth) {\n\treturn ray.origin + ray.direction*depth;\n}\n\n//Scene Setup and Trace\nHit trace_ray(in Ray ray) {\n    //init sphere\n\tSphere sphere = Sphere(vec3(0.0),0.4,1.0);\n    //init plane\n    Plane plane = Plane(vec3(0.0,1.0,0.0),vec3(0.0,-0.4,0.0),2.0);\n    //init result\n    Hit result = Hit(ray.origin, vec3(0.0), 0.0);\n    //sphere check\n    float sphere_t = intersect_sphere(ray,sphere);\n    //plane check\n    float plane_t = intersect_plane(ray,plane);\n    float max_t = 8.0;//back cut-off\n    float min_t = 0.001; //front cut-off\n    \n    //Did we hit the Plane\n    if (plane_t > min_t && plane_t < max_t) {\n    \tresult.pos = ray.origin + plane_t*ray.direction;\n        result.normal = plane.normal;\n        result.mat = 2.0;\n    }\n    //Did we hit the Sphere\n    if (sphere_t > min_t && sphere_t < max_t){\n    \tresult.pos = ray.origin + sphere_t*ray.direction;\n        result.normal = sphere_normal(result.pos,sphere);\n        result.mat = 1.0;\n    }\n    \n    return result;\n}\n\n//geometric attenuation (or shadow factor)\nfloat geometric_attenuation(float roughness, float normal_look_angle, float normal_light_angle)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = normal_light_angle * sqrt(normal_look_angle * (normal_look_angle - normal_look_angle * r2) + r2);\n\tfloat gl = normal_look_angle * sqrt(normal_light_angle* (normal_light_angle - normal_light_angle * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\n//microfacets (minute roghness in the surface)\nfloat microfacet_distribution(float roughness, float normal_half_angle){\n\tfloat r2 = roughness * roughness;\n\tfloat d = (normal_half_angle * r2 - normal_half_angle) * normal_half_angle + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\n//Fresnel Reflection coefficient (vector)\nvec3 fresnel_vec(vec3 specular_color,float look_light_angle) {\n\treturn specular_color + (1.0 - specular_color) * pow((1.0 - look_light_angle),5.0);\n}\n\n//Fresnel Reflection coefficient (scalar)\nfloat fresnel_scalar(float f0, float f90, float look_half_angle) {\n    return f0 + (f90 - f0) * pow(1.0 - look_half_angle, 5.0);\n}\n\nfloat Burley(float linearRoughness, float normal_look_vector, float normal_light_angle, float light_half_angle) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * light_half_angle * light_half_angle;\n    float lightScatter = fresnel_scalar(1.0, f90, normal_light_angle);\n    float viewScatter  = fresnel_scalar(1.0, f90, normal_look_vector);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 spherical_harmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 dfg_karis(float roughness, float normal_look_angle) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * normal_look_angle)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 render_ray(Ray ray) {\n\t// init \"sky\" color\n    vec3 color = vec3(0.65, 0.85, 1.0) + ray.direction.y * 0.8;\n\n    // raytrace\n    Hit result = trace_ray(ray);\n\n    vec3 light_pos = vec3(10.0);\n    vec3 light_dir = normalize(result.pos - light_pos);\n    vec3 look = -ray.direction;//vector to camera\n    \n    if (result.mat > 0.999){//hit someting\n       \n        vec3 half_vec = normalize(look - light_dir);\n        \n        //important angles\n        float normal_look_angle = clamp(dot(result.normal, look),0.0,1.0);\n        float normal_light_angle = clamp(dot(result.normal, normalize(light_pos)), 0.0,1.0);\n        float look_light_angle = clamp(dot(look, normalize(light_pos)), 0.0,1.0);\n        float normal_half_angle = clamp(dot(result.normal, half_vec), 0.0,1.0);\n        float look_half_angle = clamp(dot(look,half_vec), 0.0,1.0);\n        float light_half_angle = clamp(dot(normalize(light_pos),half_vec), 0.0,1.0);\n        \n        //material constants (play with these)\n        float metallic = 0.0; \n        float reflect_intensity = 1.0;\n        float specular_intensity = 2.5;\n        float roughness = 0.0;\n   \t\t\n        vec3 base_color = vec3(0.0);\n        //shadow check ray\n        Ray shadow_ray = Ray(result.pos+0.0001*light_pos, normalize(light_pos));\n       \t//Ray Trace shadow\n        Hit shadow = trace_ray(shadow_ray);\n            \n        if (result.mat > 1.999) {//plane (play with theses values)\n            //checkerboard\n            base_color = 0.4 + mod(floor(6.0 * result.pos.z) + floor(6.0 * result.pos.x), 2.0)*vec3(0.5);\n            roughness = 0.1;//play with this\n        }else{//sphere (play with these values)\n        \tbase_color = vec3(0.3,0.0,0.3);//sphere color\n            roughness = 0.3;//play with this\n        }\n        \n        \n        float linear_roughness = roughness*roughness;\n        //init specular color\n        vec3 specular_initial = 0.04 * (1.0 - metallic) + base_color*metallic;\n        //init diffuse color\n        vec3 diffuse_initial = (1.0 - metallic) * base_color;\n        // Cook-Torrance\n        vec3 specular = (microfacet_distribution(linear_roughness,normal_half_angle) \n            \t\t* geometric_attenuation(linear_roughness, normal_look_angle, normal_light_angle))\n            \t\t* fresnel_vec(specular_initial,light_half_angle); \n       \t//This is the wierd one (lots of different solutions dpending on what you read)\n        vec3 diffuse = diffuse_initial * Burley(linear_roughness, normal_look_angle, normal_light_angle, light_half_angle);\n        \n        //combine\n        color = diffuse + specular;\n\n        //alter combo by shadows and light angle\n        color *= (specular_intensity * clamp( 1.0 - shadow.mat, 0.0, 1.0) * normal_light_angle);\n        //Reflection Check\n        vec3 ref_dir = reflect(ray.direction, result.normal);\n       \tRay reflected_ray = Ray(result.pos + 0.0001*ref_dir,ref_dir);\n        Hit reflected = trace_ray(reflected_ray);\n        \n        \n        //reflected Diffuse calculation\n        vec3 reflected_diffuse = spherical_harmonics(result.normal) * (1.0/PI);\n        //reflected Specular initial\n        vec3 reflected_specular = vec3(0.65, 0.85, 1.0) + reflected_ray.direction.y * 0.8;\n        //what did the reflect hit?\n        if (reflected.mat > 0.999) {\n            if (reflected.mat > 1.999) {\n                //reflected onto the gorund\n            \treflected_specular = 0.4 + mod(floor(6.0 * reflected.pos.z) + floor(6.0 * reflected.pos.x), 2.0)*vec3(0.5);\n            }else{\n                //reflected onto the sphere\n            \treflected_specular = vec3(0.3,0.0,0.3);\n            }\n        }\n        \n        //how to combine the diffuse and specular reflections\n        vec2 dfg = dfg_karis(roughness, normal_look_angle);\n        vec3 spec_color = specular_initial * dfg.x + dfg.y;\n        vec3 reflected_combo = diffuse_initial * reflected_diffuse + reflected_specular * spec_color; \n        //combine 1st and second bounces\n        color += reflected_combo*reflect_intensity;\n        \n    }\n\n    // gamma color calculation    \n    color = pow(color, vec3(1.0/2.2));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n//Camera + Ray Setup\n//----------------------------------------------------------------------\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.25*cos(an), 0.4, 1.25*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize total color\n    vec3 total = vec3(0.0);\n    \n    #define AA 3\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    #else  \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    Ray ray = Ray(ray_origin, ray_direction);\n    \n//Render Fragment\n//----------------------------------------------------------------------\n    \n        \n\ttotal += render_ray(ray);\n        \n    #if AA>1\n    }\n    total /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}