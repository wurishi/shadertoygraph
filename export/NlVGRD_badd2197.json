{"ver":"0.1","info":{"id":"NlVGRD","date":"1637266848","viewed":235,"name":"Convolution Maze 2","username":"kastorp","description":"the gaussian blur can be decomposed on two axis, allowing larger kernels and/or better performances","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["convolution","ca"],"hasliked":0,"parentid":"7ld3zs","parentname":"Convolution maze (fork)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Convolution Maze 2 by Kastorp \nvoid mainImage( out vec4 O, in vec2 U )\n{    \n    vec4 v=texelFetch(iChannel0,ivec2(U),0);    \n    O =  .5+ .5* sin(  v*vec4(.9,.7,0.6,0) + vec4(.1));   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// blur on x axis and combine\nvoid mainImage( out vec4 O, in vec2 u )\n{    \n    SETZ\n    vec2  s=vec2(0),b=s;     \n    for(float i = -z; i<=z;i++) {\n        float  l=(i*i)/(z*z);\n        vec2 e=exp(-l*k1);\n        s+=  e;           \n        vec2 d = A(u+vec2(i,0)).xy;             \n        b+=d*e;                                   \n    }    \n    \n    O= ((iFrame%1200)==0) ? \n        vec4(1)* smoothstep(.01,0.,abs(.1+.01*sin(u.x*u.y)-length((2.*u-R.xy)/R.y))):\n        vec4(clamp( z* dot(b/s,k2),0.,1.),b.x/s.x,b.y/s.y,0) ;   \n        \n    if(iMouse.z>0.) O =mix(O,1.-300.*O, max(0.,z-length(u-iMouse.xy))); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//blur on y axis and keep separated\nvoid mainImage( out vec4 O, in vec2 u )\n{     \n    SETZ\n    vec2  s=vec2(0),b=s;  \n    for(float j = -z; j<=z;j++){\n        float  l=(j*j)/z/z;\n        vec2 e=exp(-l*k1);\n        s+=  e;        \n        float d = A(u+vec2(0,j)).x;             \n        b+=d*e;                              \n    }        \n    O=vec4(z*b/s,0,0);    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define A(u) texelFetch(iChannel0,ivec2(u),0)\n#define R iResolution\n\nvec2 k1= vec2(6.5,6.95),  //value is >1 to get gaussian tails\n     k2= vec2(-1,1.001);\n#define SETZ float z=30.-textureLod(iChannel1,(u/R.xy),6.).y*18.;\n//#define SETZ float z =30.;  //kernel dimension\n","name":"Common","description":"","type":"common"}]}