{"ver":"0.1","info":{"id":"WlfGR2","date":"1558963786","viewed":660,"name":"Darwinator","username":"iapafoto","description":"Make evolved a population of 280 creatures in real time.\nLots of comments in the code for those who are interested by how it works (Far far the most algorithmic shader I have ever made!)\n[Use mouse to watch other creatures]","likes":44,"published":1,"flags":32,"usePreview":0,"tags":["collision","genetic","physic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n//\n// Simulate and make evolved a population of 280 creatures in real time.\n// Lots of comments in the code for those who are interested by how it works (Far far the most algorithmic shader I have ever made!)\n// [Use mouse to watch other creatures]\n//\n//-----------------------------------------------------\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [dr2]            More Balls               - https://www.shadertoy.com/view/MsfyRn\n// [cornusammonis]  Pixel sorting            - https://www.shadertoy.com/view/XdcGWf\n// [FabriceNeyret2] message: click to see #2 - https://www.shadertoy.com/view/llyXRW\n\n\n//#define DISPLAY_CONNEXIONS\n    \n\nvec3 vnBall, rdSign;\nfloat dstFar;\nint idBall;\n\nint gCreatureIdToDraw;\n\n\n// Adapted from [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel1, uv, 0.).w - 127./255.);\n}\n\nfloat sdNumber(in vec2 p, in float number, in float scale) { \n    p /= scale;\n \tfloat d = 999., w = .45; // letter width  \n    p.x += w*float(5)*.5; // center text arround 0\n    \n    float result = 0.;\n\tfor(int i = 5; i >= 0; i--) {\n        float digit = mod( number / pow(10., float(i)) , 10.);\n        if (abs(number) > pow(10., float(i)) || /*zeros > i  ||*/ i == 0) {\n    \t\td = min(d, sdFont(p, 48+int(digit)));   \n        }\n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nfloat udRoundBox(vec2 p, vec2 b, float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdClock(in vec2 p, in float r, in float time) {\n    time *= -1./12.;\n    float s = sin(2.*PI*time), c = cos(2.*PI*time);\n//    float d = sdLine(p, vec2(c,s)*r*.4,-vec2(c,s)*r*.1)-2.2;\n    float d = length(p - vec2(c,s)*r*.35)-4.;\n    s = sin(12.*6.28*time), c = cos(12.*6.28*time);\n    d = min(d, sdLine(p, vec2(c,s)*r*.8,-vec2(c,s)*r*.8)-.4);\n    return min(d, abs(length(p)-r*.6)-.4);\n}\n\n\n//-------------------------------------------------------------------------------------------\n// [id] Balls and shadows - https://www.shadertoy.com/view/lsSSWV\n//-------------------------------------------------------------------------------------------\n// sphere related functions\n//-------------------------------------------------------------------------------------------\n\nfloat sphShadow(in vec3 ro, in vec3 rd, in vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ),\n          c = dot( oc, oc ) - sph.w*sph.w;\n    return step( min( -b, min( c, b*b - c ) ), 0. );\n}\n            \nvec2 sphDistances(in vec3 ro, in vec3 rd, in vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ),\n     c = dot( oc, oc ) - sph.w*sph.w,\n     h = b*b - c,\n     d = sqrt( max(0.,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.)) );\n}\n\nfloat sphSoftShadow(in vec3 ro, in vec3 rd, in vec4 sph) {\n    vec2 r = sphDistances( ro, rd, sph );\n    return r.y>0. ? max(r.x,0.)/r.y : 1.;\n}    \n            \nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec4 sph) {\n    vec3  r = sph.xyz - pos;\n    float l = length(r), d = dot(nor,r), res = d;\n    if (d<sph.w) \n        res = pow(clamp((d+sph.w)/(2.*sph.w),0.,1.),1.5)*sph.w;\n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0., 1. );\n}\n\n\n//-------------------------------------------------------------------------------------------\n// rendering functions\n//-------------------------------------------------------------------------------------------\n\nfloat shadow( in vec3 ro, in vec3 rd ) {\n\tfloat res = 1.0;\n    int nbElt = LoadNbElt(iChannel0, gCreatureIdToDraw);    \n    for (int n = 0; n < nbElt; n ++) {\n        vec4 p = Load(iChannel0, POSITION, gCreatureIdToDraw, n);\n        res = min( res, 8.0*sphSoftShadow(ro,rd, p) );\n    }\n    return res;\t\t\t\t\t  \n}\n\nfloat occlusion( in vec3 pos, in vec3 nor ) {\n\tfloat res = 1.0;\n    int nbElt = LoadNbElt(iChannel0, gCreatureIdToDraw);\n    for (int n = 0; n < nbElt; n ++) {\n        vec4 p = Load(iChannel0, POSITION, gCreatureIdToDraw, n);\n        res *= 1.0 - sphOcclusion( pos, nor, p ); \n    }\n    return res;\t\t\t\t\t  \n}\n\n// ---------------------------------------------------------------------------\n\nfloat BallHit(vec3 ro, vec3 rd) {\n    vec4 p;\n    vec3 u;\n    float b, d, w, dMin = dstFar;\n    int nbElt = LoadNbElt(iChannel0, gCreatureIdToDraw);\n\n    for (int n = 0; n < nbElt; n ++) {\n        p = Load(iChannel0, POSITION, gCreatureIdToDraw, n);\n        u = ro - p.xyz;\n        b = dot (rd, u);\n        w = b * b - dot (u, u) + p.w * p.w;\n        if (w >= 0.) {\n            d = - b - sqrt (w);\n            if (d > 0. && d < dMin) {\n                dMin = d;\n                vnBall = (u + d * rd) / p.w;\n                idBall = n;\n            }\n        }\n    }\n    return dMin;\n}\n\n// Color is linked to positon in creature\nvec3 getEltColor(int creatureId, int eltId) {\n    vec3 color = vec3(1);\n    while(eltId > 0) {\n        int connexion = int(Load(iChannel0, LINK, creatureId, eltId).x); // Parent is in x pos        \n        if (connexion == NO_LINK) break;\n        \n\t\tint parentId = CON_TO(connexion);\n        int connectToParentOn = CON_AT(connexion);\n\t\t\n        color = mix(color, connectToParentOn == 1 ? vec3(1,0,0) : \n                           connectToParentOn == 2 ? vec3(0,1,0) :\n                           connectToParentOn == 3 ? vec3(0,0,1) : vec3(1),  .4);\n        eltId = parentId;\n    }\n    return color;\n}\n\n\nvec3 light = normalize( vec3( -0.4, 0.3, -1.5 ) );\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps;             \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\nvec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in float id, in vec3 uvw, in float dis )\n{\n    vec3 ref = reflect(rd,nor);\n    \n    if (id>=0.) {\n     nor = doBumpMap(iChannel2, uvw*3., nor, .2/(1. + dis/5.));\n    }\n    float occ = occlusion( pos, nor );\n    //occ = pow(occ,2.);\n    /*\n    float fre = clamp(1.+dot(rd,nor),.0,1.);\n    \n    occ = occ*.5 + .5*occ*occ;\n    \n    vec3 lin = vec3(0.);\n    lin += 1.*vec3(.6,.6,.6)*occ;\n    lin += .5*vec3(.3,.3,.3)*(.2+.8*occ);\n    lin += .3*vec3(.5,.4,.3)*pow( fre, 2. )*occ;\n    lin += .02*nor.z + .1*nor;\n*/\n    float sh = shadow(pos+rd*.01, light );\n  //  float dif = clamp(nor.z, .0, 1. ) + .2*sh;\n    \n   // lin = lin*.7 + .8*dif;\n    \n    vec3 col;\n  \n    if (id >= 100.) {\n        col = id == 100. ? vec3(1,1,0) : \n        id == 101. ? vec3(1,0,0) : \n        id == 102. ? vec3(0,1,0) : \n        vec3(0,0,1);\n       \n    } else if (id >= 0.) {\n        col = getEltColor(gCreatureIdToDraw, int(id)); \n        col *= mix(.2, 1.2, smoothstep(.7,.9, cos(10.*3.141592*uvw.z)));\n        \n#ifdef DISPLAY_CONNEXIONS\n    \tvec4 posr = Load(iChannel0, POSITION, gCreatureIdToDraw, int(id));  \n    \tvec4 qt = Load(iChannel0, ORIENTATION, gCreatureIdToDraw, int(id));     \n \t\tmat3 rot = QtToRMat(qt);\n        col = mix(vec3(0), col, smoothstep(.02,.03,length(posr.xyz+posr.w*rot*Tetrahedron[0] - pos)));\n        col = mix(vec3(1,0,0), col, smoothstep(.02,.03,length(posr.xyz+posr.w*rot*Tetrahedron[1] - pos)));\n        col = mix(vec3(0,1,0), col, smoothstep(.02,.03,length(posr.xyz+posr.w*rot*Tetrahedron[2] - pos)));\n        col = mix(vec3(0,0,1), col, smoothstep(.02,.03,length(posr.xyz+posr.w*rot*Tetrahedron[3] - pos)));\n#endif    \n        \n    } else {\n        float k = .2*smoothstep(.97,.98, fract(4.*uvw.x)) + .2*smoothstep(.97,.98, fract(4.*uvw.y));\n        col = mix(vec3(.2), vec3(.8), clamp(k+smoothstep(.98,.99, cos(2.*3.141592*length(uvw.xy))),0.,1.)); \n        \n        // Draw trajectory of creature \n        float simulationTime = iTime - LoadConf(iChannel0, 3).w;\n\t\tfloat dmin = 999.; \n        \n        for(float i=0.; i<simulationTime-1.; i++) {\n            vec3 posAtTime = texelFetch(iChannel0, ivec2(POS_MOVES + int(i), gCreatureIdToDraw), 0).xyz;\n        \tdmin = min(dmin, length(pos.xy - posAtTime.xy) -.02);\n        }\n        \n        col = mix(vec3(0.), col, smoothstep(.01,.02, dmin));\n    }\n    \n    \n          //  float shd = softShadow(sp, light, 0.005, 4., 8.); // Shadows.\n     //   float ao = calculateAO(ro, n); // Ambient occlusion.\n        float dif = max( dot( light, nor ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-light, nor), -rd ), 0.0 ), 29.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, nor), 0.0, 1.0); // Fresnel reflection term.\n       \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + light)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2 + .06*occ;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n     //   col = colTxt;\n    float d2 = 1.;\n        col = (col*(dif*d2 + .1) + fre2*spe*2.)*sh*occ + amb*col;\n    \n    \n    //col += .1 * pow( clamp(dot(-rd,nor), 0.0, 1.0 ), 3.0 ) * occ;\n    //col += 1. * pow( clamp(reflect(rd,nor).y, 0.0, 1.0 ), 4.0 ) * dif;// * vec3(1,.9,.8);\n    // col = pow(col,vec3(.73));\n    return col;\n}    \n\n\nvec3 ShowScene (vec3 ro, vec3 rd) {\n    vec3 col, col2, vn, w;\n    float dstBall, dstObj, c, spec;\n    dstBall = BallHit (ro, rd);\n    rdSign = sign (rd);\n   \n    dstObj = -(ro.z-CUBE_SIZE.z+.5)/rd.z;\n    \n    if (min(dstBall, dstObj) < dstFar) {\n        if (dstBall < dstObj) {\n            vec3 pos = ro + dstBall*rd;\n            vec3 nor = vnBall;\n            vec3 uvw = pos-Load(iChannel0, POSITION, gCreatureIdToDraw, idBall).xyz;\n            uvw *= QtToRMat (Load(iChannel0, ORIENTATION, gCreatureIdToDraw, idBall));\n            return shade(rd, pos, nor, float(idBall), uvw, dstBall);\n            \n        } else if (dstObj < dstFar) {\n\n            vec3 pos = ro + rd * dstObj;\n            vec3 nor = vec3(0,0,-1);\n        \n            return shade( rd, pos, nor,  float(-1.), pos, dstObj);\n        }\n        return vec3(1);\n    }\n    return vec3(0.);\n\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n    cr = .1*cos(.1*iTime);\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0., sin(cr), -cos(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord) {\n    \n    vec2 canvas, uv, ut;\n    canvas = iResolution.xy;\n    uv = 2. * fragCoord.xy / canvas - 1.;\n    uv.x *= canvas.x / canvas.y;\n    vec2  q = fragCoord.xy/iResolution.xy;\n    \n    bool isIconic = (iResolution.x < 400.);\n    if (isIconic) {\n        float scale = (.9+.1*cos(8.*iTime))*65.;\n        float dTxt = scale*sdFont((fragCoord - vec2(145,80))/scale, 21);\n        fragColor.xyz = vec3(.1);\n        fragColor.xyz = mix(vec3(0), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt-2.));\n        fragColor.xyz = mix(vec3(0,.5,1), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt));\n    \treturn;\n    }\n    \n    vec4 stDat = LoadConf(iChannel0, 3);\n    int stage = int(stDat.z);\n    float timeStage = stDat.w;\n\n   // mat3 vuMat;\n    //vec4 qtVu;\n    vec3 col, rd, ro;\n\n    float maxx = 50.;\n    \n    gCreatureIdToDraw = int(float(NB_CREATURE-1)*(iMouse.y/iResolution.y));\n\n    bool selectOrdered = iMouse.x == 0. || iMouse.x > iResolution.x-maxx;\n        \n    if (selectOrdered) {\n    \tgCreatureIdToDraw = int(LoadRank(iChannel0, gCreatureIdToDraw).x);\n    }\n    if (isIconic) gCreatureIdToDraw = 0;\n    \n\tvec3 gravityCenter = LoadCenter(iChannel0, gCreatureIdToDraw);\n \tint nbElt = LoadNbElt(iChannel0, gCreatureIdToDraw);\n    \n\n\n   // qtVu = LoadConf (iChannel0, 1);\n  //  vuMat = QtToRMat (qtVu);\n   // b = length(CUBE_SIZE);\n    dstFar = 999.;\n      \n    vec3 a = mix(vec3(cos(.1*iTime), sin(.1*iTime), -.5),vec3(1,1,-.5), smoothstep(1.,0.,iTime-timeStage)); \n    \n    \n    vec3 ta = isIconic ? vec3(0) : gravityCenter; //vec3 (0., 0., - 100. /* b*/) * vuMat;\n    ro = ta + 2.7*pow(float(nbElt),.45)*(.9+.1*cos(iTime))*a;\n           // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 1.);\n\n        // ray direction\n    rd = ca * normalize( vec3(uv.xy, 4.5) );\n\n    col = ShowScene (ro, rd);\n\n    \n   \tfragColor = vec4(pow(col,vec3(.7)), 1.);\n   //\tfragColor = vec4(col,1);\n    fragColor = fragColor * pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n    int creatureId = int(float(NB_CREATURE)*fragCoord.y/iResolution.y);\n\n    float cycle = 5.;\n    \n    if (!isIconic) {\n        if (fragCoord.x >= iResolution.x - maxx) {\n\n            vec2 rank = LoadRank(iChannel0, creatureId).xy;\n            float dd = ((fragCoord.x - (iResolution.x - maxx))/maxx);\n            fragColor = gCreatureIdToDraw == int(rank.x) ? vec4(0,0,1,1) :\n             \t\tdd+4. < rank.y/cycle ? vec4(0,.1,1,1) :\n                    dd+3. < rank.y/cycle ? vec4(0,.2,1,1) :\n            \t\tdd+2. < rank.y/cycle ? vec4(0,.3,1,1) :\n                    dd+1. < rank.y/cycle ? vec4(0,.4,1,1) :\n                    dd    < rank.y/cycle ? vec4(0,.5,1,1) : \n                    fragColor*1.2;\n\n        } else if (fragCoord.x >= iResolution.x - 2.*maxx) {\n\n            float score = LoadScore(iChannel0, creatureId);\n            float dd = ((fragCoord.x - (iResolution.x - 2.*maxx))/maxx);\n            fragColor = gCreatureIdToDraw == creatureId ? vec4(1,0,0,1) :\n                        dd+4. < score/cycle ? vec4(1,.0,0,1) :\n                        dd+3. < score/cycle ? vec4(1,.05,0,1) :\n                        dd+2. < score/cycle ? vec4(1,.2,0,1) :\n                        dd+1. < score/cycle ? vec4(1,.35,0,1) :\n                        dd    < score/cycle ? vec4(1,.5,0,1) : \n                        fragColor*1.2;\n        }\n      \n        float dTxt4 = sdNumber(fragCoord-vec2(10,iResolution.y-50.), stDat.y, 60.);\n        fragColor.xyz = mix(vec3(0), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt4-2.));\n        fragColor.xyz = mix(vec3(.5,1.,.5), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt4));\n\n        float dTxt = sdNumber(fragCoord-vec2(iResolution.x-155., clamp(iMouse.y, 10., iResolution.y-10.)), float(gCreatureIdToDraw), 30.);\n        if (selectOrdered) {\n            dTxt = min(dTxt, length(fragCoord.xy - vec2(iResolution.x-maxx-3., iMouse.y)) -4.);\n            fragColor.xyz = mix(vec3(0), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt-2.));\n            fragColor.xyz = mix(vec3(0,.5,1), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt));\n\n        } else {\n            dTxt = sdNumber(fragCoord-vec2(iResolution.x-155., clamp(iMouse.y, 10., iResolution.y-10.)), float(gCreatureIdToDraw), 30.);\n            dTxt = min(dTxt, length(fragCoord.xy - vec2(iResolution.x-maxx*2.-3., iMouse.y)) -4.);\n            fragColor.xyz = mix(vec3(0), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt-2.));\n            fragColor.xyz = mix(vec3(1,0,0), fragColor.xyz, .25+.75*smoothstep(0.,1., dTxt));\n        }\n    }\n    \n    float k = .5*cos(iTime*10.)*smoothstep(.75,1.,(iTime-timeStage)/LIFE_CYCLE);\n    float dClock = (1.+.2*k)*sdClock((fragCoord.xy - vec2(40))/(1.+.2*k), 30., 12.*(iTime-timeStage)/LIFE_CYCLE-3.);\n    fragColor.xyz = mix(vec3(0), fragColor.xyz, .25+.75*smoothstep(0.,1., dClock-2.));\n    fragColor.xyz = mix(mix(vec3(1,.5,0), vec3(1,1,0),k), fragColor.xyz, .25+.75*smoothstep(0.,1., dClock));\n        \n    \n    // Do second post traitment !\n    fragColor = vec4(pow(fragColor.xyz,vec3(.43)), 1.);\n    fragColor = fragColor * pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.1);\n    // display buffers\n    // fragColor = mix(fragColor,texelFetch(iChannel0, ivec2(fragCoord.xy), 0),.5);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n//\n// Simulate and make evolved a population of 280 creatures in real time.\n// Lots of comments in the code for those who are interested by how it works (Far far the most algorithmic shader I have ever made!)\n// [Use mouse to watch other creatures]\n//\n//-----------------------------------------------------\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [dr2]            More Balls               - https://www.shadertoy.com/view/MsfyRn\n// [cornusammonis]  Pixel sorting            - https://www.shadertoy.com/view/XdcGWf\n// [FabriceNeyret2] message: click to see #2 - https://www.shadertoy.com/view/llyXRW\n\n\n\n\n// +---------------------------------------------------------+\n// |           !!!!  NEED REINIT IF CHANGED !!!!             |  \n// +---------------------------------------------------------+\n// Min Shadertoy resolution = 500 * 290 = mini\n// => max 280 creatures\n// => max 100 spheres by creature\n\n#define NB_CREATURE    280  // Max number of creature simulated in same time\n#define NB_ELT         64  // Max number of elements by creatures (cannot add if biggest) \n\n\n// +----------------------------------------------------------+\n// |         COULD BE MODIFIED DURING SIMULATION              |  \n// +----------------------------------------------------------+\n\n#define NB_MIN_ELT      16  // Min number of elements by creatures (cannot remove if smallest)\n\n#define FIX_DURATION     1. // Time to watch creature before animation\n#define LIFE_CYCLE      30.\t// Life cycle of each generation\n#define NB_MUTATIONS     4  // Number max of mutations at each generation\n#define NB_INITIAL_MUTATIONS 100  // Number max of mutations for init\n#define NB_CREATURE_TO_KEEP (NB_CREATURE/20) // Save the 5% best creatures without mutations\n\n#define RAYON_MIN      .15  // in meters (too small values make at instable in real time (dt )\n#define RAYON_MAX      .60  // in meters\n\n// -- PHYSICS -------------------------------------------------\n\n#define DT            .004  // Step for mecanic calculus (real time => time beween two frame at 240fps)\n#define DENSITY       1000. // kg/m3 (density of water here)\n#define GRAV          9.81  // m/s-1 (on earth)\n\n// Enable to stop creature in order to DEBUG mutations\n//#define STATIC_EVOLUTION\n\n\n// +----------------------------------------------------------+\n// |       !!!!  DO NOT CHANGE AFTER THIS LINE !!!!           |  \n// +----------------------------------------------------------+\n\n// -- Step of the algorithm -----------------------------------\n\n#define STAGE_INIT            0  // First initialisation\n#define STAGE_SELECTION       1  // Selection of succesfull creature\n// Mutation loop\n#define STAGE_MUTATE_ADN      2  // Randomly Mutate ADN of creatures\n#define STAGE_MAKE_BODY       3  // Create Body according to mutated ADN\n#define STAGE_VERIFY_BODY     4  // Verify viability of body\n#define STAGE_RESTORE_INVALID 5  // Restore previous body if invalid (Thank s Good)\n// End of Mutation loop\n#define STAGE_FINALISE_BODY   6  // Recreate Body from validated ADN \n#define STAGE_SIMULATE        7  // Simulate creature life\n// At end go back to\n\n#define NO_LINK               0xFFFF\n\n// -- Position of elements in BufferPicture ------------------\n#define LINE_CONF\t    NB_CREATURE\n\n#define POSITION        0\n#define ORIENTATION     1\n#define VELOCITY        2\n#define ROT_VELOCITY    3\n#define LINK            4\n\n#define POS_NB_ELT \t\tNB_ELT*5+1\n#define POS_SCORE  \t\tNB_ELT*5+2\n#define POS_RANK   \t\tNB_ELT*5+3\n#define POS_MOVES   \tNB_ELT*5+5\n\n// Room to save ADN during mutation process (to unable to undo problemetic mutations)\n#define SAVE_POSITION   VELOCITY \n#define SAVE_LINK       ROT_VELOCITY \n#define POS_SAVE_NB_ELT NB_ELT*5+4\n\n// -- Constants ----------------------------------------------\n#define PI              3.141592653589\n#define CUBE_SIZE       vec3(50,50,2.5)\n\n// -- Functions ----------------------------------------------\n#define CON_TO(c)       int(c)%1000\n#define CON_AT(c)       (int(c)%10000)/1000\n#define CON_TYPE(c)     int(c)/10000\n\n\n// Force of muscles and ligaments\nconst float dSpringK = 5000.;\n\n\nconst vec3 Tetrahedron[4] = vec3[4](\n    vec3(0,0,1),\n\tvec3( sqrt(6.),-sqrt(2.),-1)/3.,\n\tvec3(-sqrt(6.),-sqrt(2.),-1)/3.,\n\tvec3(0,2.*sqrt(2.),-1)/3.\n);\n\nvec4 gRotTetra[4];\n\n\n\n\t//mat3 mat = RMat(normalize(vec3(-Tetrahedron[i].y,Tetrahedron[i].x,0)), aTetra);\n    //return RMatToQt(mat);\n\n/*\nvec4 rotTetra2(int i) {\n    // Strange results  sometimes => Nan in calcul !\n    return Quaternion(normalize(vec3(Tetrahedron[i].y,-Tetrahedron[i].x,0)), 1.91063323+PI);\n//const float aTetra = (PI-2.*asin(sqrt(3./3.)));\n*/\n\n\n// +---------------------------+\n// |            Tools          |\n// +---------------------------+\n\n// iq\nfloat hash1( uint n ) {\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash11(float p) {\n    return hash1(uint(p*1111.11));\n}\n\n\n\n// +---------------------------+\n// |        Save / Load        |\n// +---------------------------+\n\nvec4 LoadConf (sampler2D txBuf, int idVar) {\n    return texelFetch(txBuf, ivec2(idVar, LINE_CONF), 0);\n}\n\nvec4 Load(sampler2D txBuf, int kind, int idCreature, int eltId) {\n    return texelFetch(txBuf, ivec2(NB_ELT*kind + eltId, idCreature), 0);\n}\n\nvoid Save(int kind, int idCreature, int idElt, vec4 val, inout vec4 fCol, vec2 fCoord) {\n\tvec2 iFrag = floor(fCoord);\n    if ((NB_ELT*kind + idElt) == int(iFrag.x) && idCreature == int(iFrag.y)) fCol = val;\n}\n\nint LoadNbElt(sampler2D txBuf, int idCreature) {\n    return int(texelFetch(txBuf, ivec2(POS_NB_ELT, idCreature), 0).x);\n}\n\nfloat LoadScore(sampler2D txBuf, int idCreature) {\n    return texelFetch(txBuf, ivec2(POS_SCORE, idCreature), 0).w;\n}\n\nvec3 LoadCenter(sampler2D txBuf, int idCreature) {\n    return texelFetch(txBuf, ivec2(POS_SCORE, idCreature), 0).xyz;\n}\n\nvec2 LoadRank(sampler2D txBuf, int idCreature) {\n    return texelFetch(txBuf, ivec2(POS_RANK, idCreature), 0).xy;\n}\n\n// +---------------------------+\n// |        Quaternions        |\n// +---------------------------+\n\nvec4 Quaternion(vec3 n, float a) {\n    return normalize(vec4(n*sin(a*.5), -cos(a*.5)));\n}\n\n// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm\nvec4 QtMul(vec4 q1, vec4 q2) {\n    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n\n//vec4 QtDiv(vec4 a, vec4 b) {\n//\treturn vec4(cross(-a.xyz,b.xyz) - a.w*b.xyz + b.w*a.xyz, a.w*b.w+dot(a.xyz,b.xyz));\n//}\n\n//vec3 QtRot(vec3 v, vec4 q) {\n//    return QtMul(QtMul(q, vec4(v,0)), vec4(-q.xyz,q.w)).xyz;\n//}\n\n//------------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nmat3 QtToRMat(vec4 q) {\n    mat3 m;\n    float a1, a2, s;\n    q = normalize (q);\n    s = q.w * q.w - 0.5;\n    m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n    a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n    a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n    a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n    return 2. * m;\n}\n\n//------------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nvec4 RMatToQt(mat3 m) {\n    vec4 q;\n    const float tol = 1e-6;\n    q.w = .5 * sqrt(max(1. + m[0][0] + m[1][1] + m[2][2], 0.));\n    if (abs(q.w) > tol) q.xyz =\n        vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4.*q.w);\n    else {\n        q.x = sqrt (max(.5 * (1. + m[0][0]), 0.));\n        if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n        else {\n            q.y = sqrt (max (.5 * (1. + m[1][1]), 0.));\n            if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n            else q.z = 1.;\n        }\n    }\n    return normalize (q);\n}\n\n/*\nmat3 RMat(vec3 u, float a) {\n\tfloat ca = cos(a), sa = sin(a);\n    return mat3(\n        ca + u.x*u.x*(1.-ca),                 u.x*u.y*(1.-ca) - u.z * sa,    u.x*u.z*(1.-ca) + u.y*sa,\n             u.y*u.x*(1.-ca) + u.z * sa, ca + u.y*u.y*(1.-ca),               u.y*u.z*(1.-ca) - u.x*sa,        \n             u.z*u.x*(1.-ca) - u.y * sa,      u.z*u.y*(1.-ca) + u.x*sa, ca + u.z*u.z*(1.-ca));\n}\n*/\n\n//------------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nmat3 LpStepMat (vec3 a) {\n    mat3 m1, m2;\n    vec3 t, c, s;\n    float b1, b2;\n    t = .25 * a * a;\n    c = (1. - t) / (1. + t);\n    s = a / (1. + t);\n    m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n    b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n    m1[0][1] = b1 + b2;    m2[1][0] = b1 - b2;\n    b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n    m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n    b1 = c.y * s.z;\n    m1[1][0] = - b1;       m2[0][1] = b1;  \n    b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n    m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n    b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n    m1[1][2] = b1 + b2;    m2[2][1] = b1 - b2;\n    m1[2][0] = s.y;        m2[0][2] = - s.y;\n    b1 = s.x * c.y;\n    m1[2][1] = - b1;       m2[1][2] = b1;\n    b1 = c.x * c.y;\n    m1[2][2] = b1;         m2[2][2] = b1;\n    return m1 * m2;\n}\n\n\n// +------------------------------------------------------+\n// |                      UTILS                           |\n// +------------------------------------------------------+\n\nbool getConnexionBases(sampler2D txBuf, int creatureId, vec4 connexions, int con_pos, vec4 qm1, out vec4 pc2, out mat3 rot1, out mat3 rot2) {\n    if (int(connexions[con_pos]) == NO_LINK)\n        return false;\n    \n    int other_con_pos = CON_AT(connexions[con_pos]);\n    int parentId =      CON_TO(connexions[con_pos]);\n\n    pc2 =      Load(txBuf, POSITION,    creatureId, parentId);\n    vec4 qm2 = Load(txBuf, ORIENTATION, creatureId, parentId);\n\n    // Orientation of connexion point\n    if (con_pos == 0) {\n        rot1 = QtToRMat(qm1);\n        rot2 = QtToRMat(QtMul(qm2,gRotTetra[other_con_pos]));\n    } else {\n        rot1 = QtToRMat(QtMul(qm1,gRotTetra[con_pos]));\n        rot2 = QtToRMat(qm2);\n    }\n    return true;\n}\n\n\n// +------------------------------------------------------+\n// |                    STAGE INIT                        |\n// +------------------------------------------------------+\n// Init ADN of creatures \n// First Sphere, other at NO_LINK\n#define INIT_NB_ELT 4 \nvec4 InitADN(int creatureId, int eltId) {\n    return\n       eltId == 0 ? vec4(NO_LINK, 10001, 10002, 10003) :\n       eltId == 1 ? vec4(11000, NO_LINK, NO_LINK, NO_LINK) :\n       eltId == 2 ? vec4(12000, NO_LINK, NO_LINK, NO_LINK) :\n       eltId == 3 ? vec4(13000, NO_LINK, NO_LINK, NO_LINK) :\n       vec4(NO_LINK); // No link at starts\n}\n\n// +------------------------------------------------------+\n// |                 STAGE_MAKE_BODY                      |\n// +------------------------------------------------------+\n// Create Initial Pos from ADN\n\nvoid InitBodyFromADN(sampler2D txBuf, int nbElt, int creatureId, int eltId, out vec3 rm, out vec4 qm, out float rad) {\n    vec3 e;\n    float mIdf, nbEdge;\n\n    rm = vec3(0);\n    qm = vec4(0,0,0,-1);\n    rad = Load(txBuf, POSITION, creatureId, eltId).w;\n    float radChild = rad;\n    \n    while (eltId > 0) {\n        int connexion = int(Load(txBuf, LINK, creatureId, eltId)[0]);       \n        if (connexion == NO_LINK) break;\n\t\t\n\t\tint parentId = CON_TO(connexion);\n        int connectToParentOn = CON_AT(connexion);\n\t\t\n        float radParent = Load(txBuf, POSITION, creatureId, parentId).w;\n        vec4 qt = gRotTetra[connectToParentOn];\n        mat3 rot = QtToRMat(gRotTetra[connectToParentOn]);\n       \n        rm = rot*rm + (radChild+radParent)*Tetrahedron[connectToParentOn];\n        qm = QtMul(qt, qm);\n        \n        // repeat on parent\n        radChild = radParent;\n        eltId = parentId; \n    }\n\n}\n\n\n// +---------------------------------------------------+\n// |         Create random mutation on ADN             |\n// +---------------------------------------------------+\n// Could modify links, nbElt and/or rayon\n\nint doMutation(sampler2D txBuf, int creatureId, int pxId, float time,  inout vec4 fCol, vec2 fragCoord) {\n        \n    int nbElt = LoadNbElt(txBuf, creatureId);\n\tint varColId = pxId/NB_ELT;\n    \n\t// Determine what mutation this time\n    float rand = hash11(float(creatureId) + time + 123.1234);\n\n    float randElt = hash11(float(creatureId) + 5.*time);        \n    int eltId = clamp(int(randElt*float(nbElt))%nbElt,0,nbElt-1);\n    \n    if (rand < .2 && nbElt < NB_ELT) {\n    \t// Add leaf element\n        \n        // find a random parent\n        int newId = nbElt;\n        int parentId = eltId;        \n\t    int randLink = int(4.*hash11(float(creatureId+parentId) + time)); // Start at this link\n        \n        vec4 parentLinks = Load(txBuf, LINK,        creatureId, parentId),\n         \t parentPos   = Load(txBuf, POSITION,    creatureId, parentId),\n         \t parentQm    = Load(txBuf, ORIENTATION, creatureId, parentId);\n        mat3 parentRot   = QtToRMat(parentQm); // Go to parent orientation\n\t\t\n        int id = 0;\n        for (int iLink=0; iLink<3; iLink++) {\n            int connectToParentOn = 1+(iLink+randLink)%3;\n\t        int connexion = int(parentLinks[connectToParentOn]); // Parent is in x pos        \n            if (connexion == NO_LINK) { \n                // No child at this position this is the good place to create element\n                float rad = mix(RAYON_MIN, RAYON_MAX, .5*hash11(float(newId+creatureId)+time));\n\n                // Create new Element  \n                int tractionMode = 1+int(8.*hash11(float(creatureId)+1234.5 + time));\n                vec4 linkNew = vec4(tractionMode*10000 + connectToParentOn*1000 + parentId, NO_LINK, NO_LINK, NO_LINK);\n\n                // Update parent links\n                parentLinks[connectToParentOn] = float(tractionMode*10000 + newId);\n\n\t\t\t\tint varColId = pxId/NB_ELT;\n\t\t\t\teltId = pxId%NB_ELT;\n\t\t\t\t\n                // Save all attributes\n                if (pxId == POS_NB_ELT) {\n                    fCol = vec4(nbElt+1);  \n\t\t\t\t\t\n\t\t\t\t} else if (varColId == LINK) {\n\t\t\t\t\t// Connexion\n                    if (eltId == parentId) {                                                \n                        fCol = parentLinks;\n                    } else if (eltId == nbElt) {\n                        fCol = linkNew;\n                    }\n\t\t\t\t\t\n                } else if (varColId == POSITION) {\n\t\t\t\t\t// Position, Orientation, Speeds\n                    if (eltId == newId) {\n                        fCol = vec4(0,0,0,rad);\n                    }\n                }\n                return 0;\n            }\n        }\n        \n    } else if (rand < .3 && nbElt>NB_MIN_ELT) {\n        \n        // Remove Elt \n   \t\t// (only for leaf => suppress one elements, replace if by list element and change nb of elements)\n\n        // Replace the element by last element of list, too complicate if not a leaf\n        int lastEltId = nbElt-1;\n        vec4 lastEltConnexions = Load(txBuf, LINK, creatureId, lastEltId);       \n\n        if (int(lastEltConnexions[1]) != NO_LINK ||\n            int(lastEltConnexions[2]) != NO_LINK ||\n            int(lastEltConnexions[3]) != NO_LINK) return -1;\n        \n        int i=0;\n        while(i<nbElt) { // Just security\n            i++;\n            vec4 connexions = Load(txBuf, LINK, creatureId, eltId);\n            int randLink = int(4.*hash11(float(creatureId+eltId) + 777. + time)); // Start at this link\n            bool isLeaf = true;\n            for (int i=0; i<3; i++) {\n                if (int(connexions[1+(i+randLink)%3]) != NO_LINK) {\n                    // Not a leaf, we progress on this element\n                    eltId = CON_TO(connexions[1+(i+randLink)%3]);\n                    isLeaf = false;\n                    break;\n                }\n        \t}\n            if (!isLeaf) {\n                continue;\n            }\n\t        \n            int parentId = CON_TO(connexions[0]);               \n            vec4 parentConnexions = Load(txBuf, LINK, creatureId, parentId);\n               \n            // Ok we are in a leaf => remove it\n\t\t\tint id = pxId%NB_ELT;\n\t\t\t\t\n            if (pxId == POS_NB_ELT) {\n                // Remove last one\n            \tfCol = vec4(nbElt-1);   \n                \n            } else if (varColId == POSITION) {\n                // Elt  => Save p of last elt in eltId\n                if (id == eltId && eltId != lastEltId) {\n                    fCol = Load(txBuf, POSITION, creatureId, lastEltId);\n                }\n\n            } else if (varColId == LINK) {\n                // Remove link from parent\n                int connectToParentOn = CON_AT(connexions[0]);\n                parentConnexions[connectToParentOn] = float(NO_LINK);\n                Save(LINK, creatureId, parentId, parentConnexions, fCol, fragCoord);\n\n                // change link from parent and childs of the last element => id became eltId\n                if (eltId != lastEltId) {\n                    vec4 lastEltConnexions = Load(txBuf, LINK, creatureId, lastEltId);       \n                    int lastEltParentId = CON_TO(lastEltConnexions[0]);\n                    vec4 lastEltParentConnexions = lastEltParentId == parentId ?\n                        parentConnexions : // Same parent => both modif must be integrated\n                        Load(txBuf, LINK, creatureId, lastEltParentId);\n\n                    int lastEltConnectToParentOn = CON_AT(lastEltConnexions[0]);\n                    lastEltParentConnexions[lastEltConnectToParentOn] += float(eltId - lastEltId);            \n\t\t\t\t\t\n                    Save(LINK, creatureId, eltId,    \t\tlastEltConnexions,       fCol, fragCoord);\n                    Save(LINK, creatureId, lastEltParentId, lastEltParentConnexions, fCol, fragCoord);\n                }\n            }\n            break;\n        }\n\t\t\n    } else if (rand < .65) {\n\t    // Change traction mode of one link of one element\n        vec4 connexions = Load(txBuf, LINK, creatureId, eltId);\n        int randLink = int(4.*hash11(float(creatureId+eltId) + 777. + time)); // Start at this link\n        \n\t\tfor (int i=0; i<3; i++) {\n            \n            int conId = 1+(i+randLink)%3;\n            int connexion = int(connexions[conId]);\n            if (connexion != NO_LINK) {\n                int randMove = int(101.*hash11(float(creatureId+eltId+connexion) + 1717. + time));                  \n\t\t\t\tint moveMode = (randMove%100);\n                \n                int childLinkPos = CON_AT(connexion);  \n                int childId = CON_TO(connexion);\n                \n                connexions[conId] = float(moveMode*10000 + childLinkPos*1000 + childId);\n                \n                // Change move mode of child also               \n\t\t        vec4 connexionsChild = Load(txBuf, LINK, creatureId, childId);\n                int connexionChild = int(connexionsChild[childLinkPos]);\n                int parentLinkPos = CON_AT(connexionChild);  // = 0\n                int parentId = CON_TO(connexionChild); // = eltId\n                \n                connexionsChild[childLinkPos] = float(moveMode*10000 + parentLinkPos*1000 + parentId);\n               // if (parentId == eltId) {\n                Save(LINK, creatureId, eltId,   connexions,      fCol, fragCoord);\n                Save(LINK, creatureId, childId, connexionsChild, fCol, fragCoord);\n               // }\n\t\t\t\treturn 0;\n            }\n        }\n        \n    \n    } else  {\n\t    // Change size of element \n        if (varColId == POSITION) {\n            vec4 pos = Load(txBuf, POSITION, creatureId, eltId);\n            float dr = .25*(RAYON_MAX-RAYON_MIN)*(hash11(11.1+time+float(creatureId+eltId))-.5);\n            pos.w = clamp(pos.w + dr, RAYON_MIN, RAYON_MAX);\n            Save(POSITION, creatureId, eltId, pos, fCol, fragCoord);\n        }\n        return 0;\n    }\n        \n    return -1;\n}\n\n\n\n// +---------------------------------------------------+\n// |       Verify Intesection of Elt With others       |\n// +---------------------------------------------------+\n\nbool checkValidity(sampler2D txBuf, int nbElt, int creatureId, int eltId) {\n    vec4 pos = Load(txBuf, POSITION, creatureId, eltId);\n    float eps = RAYON_MIN*.1;\n    for (int id=0; id<nbElt; id++) {\n        if (id == eltId) continue;\n        vec4 pElt = Load(txBuf, POSITION, creatureId, id);\n        if (length(pElt.xyz-pos.xyz) < pos.w+pElt.w-eps) {\n            return false; // Elements intersects => Invalid Creature\n        }\n    }\n\t\n    return true;\n}\n\n\nbool isFullValidCreature(sampler2D txBuf, int nbElt, int creatureId) {\n    // If one element is flaged as invalid the creature is invalid => Avoid mutation\n    for (int id=0; id<nbElt; id++) {\n        if (Load(txBuf, VELOCITY, creatureId, id).x < .5)\n            return false;\n    }\n    return true;\n}\n\n\n\n\n// +---------------------------------------------------+\n// |                 Animate creatures                 |\n// +---------------------------------------------------+\n\n\n// Spring force\nvoid applyForce(vec4 pc1, mat3 rot1, vec4 pc2, mat3 rot2, vec3 n1, vec3 n2,float springLen, inout vec3 am, inout vec3 wam, float kForce) {\n    vec3 p1 = pc1.xyz + pc1.w*rot1*n1,\n     \t p2 = pc2.xyz + pc2.w*rot2*n2,\n         v = p1 - p2;\n    float dLen = length(v);\n\tvec3 springForce = kForce* (dLen-springLen) * v/dLen;\n    am -= springForce;\n    wam -= cross(p1 - pc1.xyz, springForce);\n}\n\nvoid Simulate(float time, sampler2D txBuf, int creatureId, int nbElt, int eltId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float rad) {\n\n    // Friction between Elements of the creature\n    const float fricNB = 5., fricSB = 5., fricSWB = 10., fricTB = 40.;\n    \n    // Friction to the ground\n    const float fricN = 240., fricS = 240., fricSW = 160., fricT =248.;\n    \n    // Damping factor\n    float fDamp = 0.;\n\n    vec3  vmN, wmN, dr, dv, am, wam;\n    float rSep, radSum, fc, ft, ms, h, fOvlap = 15000.;\n    \n    time *= 5.;\n    \n    vec4 pc1 = Load(txBuf, POSITION, creatureId, eltId);\n    qm = Load(txBuf, ORIENTATION,    creatureId, eltId);\n    vm = Load(txBuf, VELOCITY,       creatureId, eltId).xyz;\n    wm = Load(txBuf, ROT_VELOCITY,   creatureId, eltId).xyz;\n\n    rm = pc1.xyz;\n    rad = pc1.w;\n\n    ms = rad*rad*rad*DENSITY; // Mass\n\n    am = wam = vec3(0); // Sum or forces\n \n    // Slow it a bit\n    vm *= .99;\n    wm *= .97;\n\n#ifdef STATIC_EVOLUTION\n    // DEBUG position => no moves\n     return;\n#endif\n    \n\t// Keep it in the air before simulation\n    if (time < FIX_DURATION) {\n        return;\n    }\n    \n    // Check intersection between Elements of the creature\n    for (int n = 0; n < nbElt; n ++) {\n        vec4 pc2 = Load(txBuf, POSITION, creatureId, n);\n\n        dr = pc1.xyz - pc2.xyz;\n        \n        rSep = length(dr);\n        radSum = pc1.w + pc2.w;\n\n        if (n != eltId && rSep < radSum) {\n            \n            // Impulsion de contact\n            fc = fOvlap * (radSum / rSep - 1.);\n            \n            vmN = Load(txBuf, VELOCITY, creatureId, n).xyz;\n            wmN = Load(txBuf, ROT_VELOCITY, creatureId, n).xyz;\n\n            dv = vm - vmN;\n            h = dot(dr, dv) / (rSep)*(rSep);\n\n            // friction\n            fc = max(fc - fricNB * h, 0.);\n            am += fc * dr;\n            dv -= h * dr + cross ((2.*pc1.w * wm + 2.*pc2.w * wmN) / (2.*pc1.w + 2.*pc2.w), dr);\n            ft = min (fricTB, fricSB * abs (fc) * rSep / max (0.001, length (dv)));\n            \n            am -= ft * dv;\n            wam += (ft / rSep) * cross (dr, dv);\n        }\n    }\n    \n    \n    vec4 connexions = Load(txBuf, LINK, creatureId, eltId);\n    mat3 rot = QtToRMat(qm);\n    \n    float anim1 = .3*cos(time);\n    mat3 rot1, rot2;\n    \n    // For each possible connexions to other Elts\n    for (int con_pos=0; con_pos<4; con_pos++) {\n        vec4 pc2; \n        if (getConnexionBases(txBuf, creatureId, connexions, con_pos, qm, pc2, rot1, rot2)) {\n            \n\t        int move_con = CON_TYPE(connexions[con_pos]);\n          //  if (move_con == 0) continue; // move_con == 9 => No muscles\n            anim1 = .3*cos(time + float(move_con/10)*6.28);\n            \n            float anim = move_con >= 10 && move_con <20 ? 0. : anim1, // move_con == 8 => fixed articulation\n\t\t\t \t  a = PI*2.*float(move_con)/8.,\n             \t  ca = cos(a), sa = sin(a),\n            \t  kForce = dSpringK*mix(5., 100.*(pc1.w*pc1.w*pc1.w + pc2.w*pc2.w*pc2.w), .6); // biggest link => strongest\n            \n            \n            // Ligaments\n            if (con_pos == 0)\n                applyForce(pc1, rot1, pc2, rot2, vec3(0,0,1), vec3(0,0,-1),  0., am, wam, 2.*kForce);\n            else \n                applyForce(pc1, rot1, pc2, rot2, vec3(0,0,-1), vec3(0,0,1),  0., am, wam, 2.*kForce);\n            \n            if (move_con < 10) continue; // move_con == 9 => No muscles\n            applyForce(pc1, rot1, pc2, rot2, vec3(ca,sa,0), vec3(ca,sa,0), pc1.w+pc2.w, am, wam, 2.*kForce);\n            applyForce(pc1, rot1, pc2, rot2,-vec3(ca,sa,0),-vec3(ca,sa,0), pc1.w+pc2.w, am, wam, 2.*kForce);\n\t\t\t\n            // Muscles\n            if (move_con == 9) continue; // move_con == 9 => No muscles\n            applyForce(pc1, rot1, pc2, rot2, vec3(sa,ca,0),vec3(sa,ca,0), (pc1.w+pc2.w)*(1.+anim), am, wam, kForce);\n            applyForce(pc1, rot1, pc2, rot2,-vec3(sa,ca,0),-vec3(sa,ca,0), (pc1.w+pc2.w)*(1.-anim), am, wam, kForce);\n        }\n    }\n    \n\n    // Intersection with the ground \n    float radAv = rad + .5;\n    dr = vec3(0,0,rm.z-CUBE_SIZE.z);\n    rSep = length (dr);\n    \n    if (rSep < radAv) {\n        // Out of the ground\n        rm -= .5*normalize(dr)*(rSep-radAv);\n\n        fc = fOvlap * (radAv / rSep - 1.);\n        dv = vm;\n        h = dot (dr, dv) / (rSep * rSep);\n        fc = max (fc - fricN * h, 0.);\n\n        am += fc * dr;\n        dv -= h * dr + cross (wm, dr);\n\n        ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n        am -= ft * dv;\n        wam += (ft / rSep) * cross (dr, dv);\n    }\n\n    // Integrate all\n    am -= vec3 (0., 0., -ms*GRAV) + fDamp * vm;\n\n    vm += DT * am/ms;\n    rm += DT * vm;\n    wm += DT * wam / (ms*rad); //*rad*.5);//*(ms * rad) ;  // (ms*rad*rad*.5) for inertia matrix\n  \n    qm = normalize(QtMul(RMatToQt(LpStepMat(.5 * DT * wm)), qm));\n}\n\n\n// +---------------------------+\n// |         Main Loop         |\n// +---------------------------+\n\nvoid mainLoop(float iTime, vec4 iMouse, vec2 iResolution, int iFrame, sampler2D txBuf, out vec4 fragColor, in vec2 fragCoord) {\n    gRotTetra[0] = vec4(0,0,0,1);\n    for (int i=1; i<4; i++) {\n        gRotTetra[i] = Quaternion(normalize(vec3(Tetrahedron[i].y,-Tetrahedron[i].x,0)), 1.91063323+PI);\n    }\n    \n    vec4 configuration = LoadConf(txBuf, 3);\n    \n    int generationId, stage, nextStage;\n    float timeStage = 0.;\n    \n    if (iFrame == 0) {\n        generationId = 0;\n        stage = STAGE_INIT;       // Init first ADN\n        nextStage = STAGE_MUTATE_ADN; // Next: Make diversity on population\n    } else {\n        generationId = int(configuration.y);\n        stage = int(configuration.z);\n        timeStage = configuration.w;\n        nextStage = stage;\n    }\n\n    vec2 iFrag = floor(fragCoord);\n    int pxId = int(iFrag.x);\n    \n    \n    // By default : do not change value \n    fragColor = texelFetch(txBuf, ivec2(iFrag), 0);\n        \n    // Win some cycles \n    if (iFrag.y >= float(NB_CREATURE+1)// ||\n       // (stage == STAGE_SIMULATE && pxId >= 4*NB_ELT && pxId != POS_RANK && pxId != POS_SCORE) \n       // (stage == STAGE_MAKE_BODY && pxId >= ELT_SIZE*(NB_ELT+1)+3)\n       ) {      \n\t\treturn;\n    }\n\n    // Configuration\n    if (int(iFrag.y) == LINE_CONF) {  \n\n        if (pxId == 3) {\n            // Change states (sequence of actions)\n            if (stage == STAGE_INIT) {\n                nextStage = STAGE_SELECTION;\n                timeStage = -float(NB_INITIAL_MUTATIONS); // Starts with some mutations :)\n                \n            } else if (stage == STAGE_SELECTION) {\n                nextStage = STAGE_MUTATE_ADN;\n                \n     // -- Mutation stages ----------------------------           \n            } else if (stage == STAGE_MUTATE_ADN) {\n                nextStage = STAGE_MAKE_BODY;\n                \n            } else if (stage == STAGE_MAKE_BODY) {    \n                nextStage = STAGE_VERIFY_BODY;\n                \n            } else if (stage == STAGE_VERIFY_BODY) {\n                nextStage = STAGE_RESTORE_INVALID;\n                \n            } else if (stage == STAGE_RESTORE_INVALID) { \n \t\t\t\ttimeStage++;\n                nextStage = int(timeStage) >= NB_MUTATIONS ?\n                     STAGE_FINALISE_BODY : \n                \t STAGE_MUTATE_ADN;                \n                \n\t// ------------------------------------------------- \n                \n            } else if (stage == STAGE_FINALISE_BODY) {\n  \t             nextStage = STAGE_SIMULATE;   \n                 timeStage = iTime;\n  \n            } else if (stage == STAGE_SIMULATE) {\n                // End simulation\n                float tSimulation = (iTime - timeStage);\n                if (tSimulation > LIFE_CYCLE) {\n                    nextStage = STAGE_SELECTION;\n                    timeStage = 0.;\n                    generationId++;\n                }\n            }\n\n            configuration = vec4(0, generationId, nextStage, timeStage);\n        }\n\t\t\n\t\t// Save config\n        fragColor = configuration;\n\n    } else {\n\n        // Creatures\n\t\tint creatureId = int(iFrag.y);\n\t\tint eltId = pxId%NB_ELT;\n\t\tint varColId = pxId/NB_ELT;\n\t    int nbElt = LoadNbElt(txBuf, creatureId);\n        \n        vec4 p, qm;\n    \tvec3 rm, vm, wm;\n        float rad;\n        \n\t// -- Init ---------------------------------------------------------\n\t\n        if (stage == STAGE_INIT) {\n            if (pxId == POS_RANK) {\n                fragColor = vec4(creatureId);\n                \n            } else if (pxId == POS_NB_ELT) {\n            \tfragColor = vec4(INIT_NB_ELT);\n            \t//fragColor = vec4(5);\n                \n            } else if (varColId < LINK) {\n\t\t\t\trad = mix(RAYON_MIN, RAYON_MAX, hash11(float(eltId+creatureId) + 0.1));\n                fragColor = varColId == POSITION ? vec4(0,0,0, rad) :\n\t\t\t\t\t\t    varColId == ORIENTATION ? vec4(0,0,0,1) : vec4(0);\n                    \n            } else if (varColId == LINK) {\n                fragColor = InitADN(creatureId, eltId);\n                \n            } else if (pxId == POS_RANK) {\n                fragColor = vec4(creatureId);\n            }\n            \n      // -- Selection of creature that will be copied ------------------------\n\n        } else if (stage == STAGE_SELECTION) {\n                        \n            int srcCreatureId;\n\n            if (creatureId < NB_CREATURE_TO_KEEP) {\n                // Select the nieme best creature \n                srcCreatureId = int(LoadRank(txBuf, creatureId).x);\n           \n            } else {\n                // Select randomly with more chances for successfull ones\n                float hash = hash11(float(creatureId) + 31.24*iTime + 1716.7);\n                srcCreatureId = int(LoadRank(txBuf, int(.75*float(creatureId)*hash)).x);\n            }\n\n            // Save ADN of creature srcCreatureId before mutation (to be able to undo invalid mutations)\n            if (pxId == POS_SAVE_NB_ELT) {\n                // Save nbElt before mutation\n                fragColor = vec4(LoadNbElt(txBuf, srcCreatureId));\n                    \n            } else if (varColId == SAVE_POSITION) {\n                // Save rayon before mutation in velocity\n                fragColor = Load(txBuf, POSITION, srcCreatureId, eltId);\n                \n            } else if  (varColId == SAVE_LINK) {\n                // Save links before mutation in rotVelocity\n                fragColor = Load(txBuf, LINK, srcCreatureId, eltId);\n                \n            } else {    \n            \t// Copy full srcCreatureId line\n            \tfragColor = texelFetch(txBuf, ivec2(pxId, srcCreatureId), 0);\n            }\n            \n            \n\t// -- Mutate ADN -----------------------------------------------------\n\t\n        } else if (stage == STAGE_MUTATE_ADN) {\n            \t\n            if (creatureId >= NB_CREATURE_TO_KEEP) { \n                if (varColId == POSITION || varColId == LINK || pxId == POS_NB_ELT) { \n                    // Mutate ADN (Links / rayons / nbElt)\n                    doMutation(txBuf, creatureId, pxId, iTime, fragColor, fragCoord);             \n                }\n            }\n        \n\t// -- Make Body ------------------------------------------------------\n            \n        } else if (stage == STAGE_MAKE_BODY) {\n\n            if ((varColId == POSITION || varColId == ORIENTATION) && eltId < nbElt) {\n                       \n\t\t\t\t// ------------------------------------------------------------------\n                // Init creature position and orientation from its ADN\n                InitBodyFromADN(txBuf, nbElt, creatureId, eltId, rm, qm, rad);\n                // Save Positon and Orientation\n                fragColor = varColId == POSITION ? vec4(rm, rad) : qm;\n            }\n            \n        } else if (stage == STAGE_VERIFY_BODY) {\n            \n            if (varColId == SAVE_POSITION) {\n                // Flag have to cohabit with saved rayon, so we have to compose it\n                float savedRad = Load(txBuf, SAVE_POSITION, creatureId, eltId).w; \n                int flag = checkValidity(txBuf, nbElt, creatureId, eltId) ? 1 : -1;\n                fragColor = vec4(flag,flag,flag,savedRad);\n            }\n            \n        } else if (stage == STAGE_RESTORE_INVALID) {\n\n            if (!isFullValidCreature(txBuf, nbElt, creatureId)) {\n\t\t\t\t// Invalid creature => Restore creature ADN\n                if (pxId == POS_NB_ELT) {\n                    fragColor = texelFetch(txBuf, ivec2(POS_SAVE_NB_ELT, creatureId), 0);\n\n                } else if (varColId == POSITION) {\n                    fragColor = Load(txBuf, SAVE_POSITION, creatureId, eltId);\n\n                } else if  (varColId == LINK) {\n                    fragColor = Load(txBuf, SAVE_LINK, creatureId, eltId);\n\n                }\n\n            } else { \n                // Valid creature => Save the new valid ADN for undo process\n                if (pxId == POS_SAVE_NB_ELT) {\n                    // Save nbElt before mutation\n                    fragColor = vec4(LoadNbElt(txBuf, creatureId));\n\n                } else if (varColId == SAVE_POSITION) {\n                    // Save rayon before mutation in velocity\n                    fragColor = Load(txBuf, POSITION, creatureId, eltId);\n\n                } else if  (varColId == SAVE_LINK) {\n                    // Save links before mutation in rotVelocity\n                    fragColor = Load(txBuf, LINK, creatureId, eltId);\n                }\n            }\n            \n      \t} else if (stage == STAGE_FINALISE_BODY) {        \n            \n            if (pxId == POS_RANK) {\n                fragColor = vec4(creatureId); // Init rank\n                \n            } else if (pxId == POS_SCORE) {\n                fragColor = vec4(0); // Init Score\n\n            } else if (varColId == VELOCITY || varColId == ROT_VELOCITY) {\n                fragColor = vec4(0); // Static at starts\n                \n            } else if ((varColId == POSITION || varColId == ORIENTATION) && eltId < nbElt) {\n                // Init creature position and orientation from its validated ADN\n                InitBodyFromADN(txBuf, nbElt, creatureId, eltId, rm, qm, rad);\n                // Save Positon and Orientation\n                fragColor = varColId == POSITION ? vec4(rm, rad) : qm;\n            }\n\n        }  else if (stage == STAGE_SIMULATE) {\n                        \n            if (pxId == POS_SCORE) {\n                // Score creature in real time (to enable real time ranking)\n                vec3 sum = vec3(0);\n                float sumMass = 0., distMin = 1e5;\n\t\t\t\t\n                for (int i=0; i<nbElt; i++) {\n                \tvec4 pos = Load(txBuf, POSITION, creatureId, i);\n                    float mass = pos.w*pos.w*pos.w;\n                    sum += pos.xyz*mass;\n                    sumMass += mass;\n                    distMin = min(distMin, length(pos.xyz-vec3(0,0,CUBE_SIZE.z)));\n                }\n                \n                vec3 g = sum/sumMass; // Gravity center\n                float score = length(g.xy);\n                if (isnan(score)) score = 0.; \n\t\t\t\tfragColor = vec4(g, score);               \n                            \n            } else if (pxId >= POS_MOVES) {\n                \n                int idTime = int(iTime - timeStage);\n                if (pxId == POS_MOVES+idTime) {\n                    // Save curent position\n                \tfragColor = texelFetch(txBuf, ivec2(POS_SCORE, creatureId), 0);\n                } else if (pxId > POS_MOVES+idTime) {\n                \tfragColor = vec4(0); // reset others\n                }\n                \n            } else if (pxId == POS_RANK) {\n\t\t\t\t// Bubble Sort POS_SCORE\n                // cf: [cornusammonis] - Pixel sorting - https://www.shadertoy.com/view/XdcGWf)\n              \t// Best creatureId to Bottom\n                int creaId =  int(LoadRank(txBuf, creatureId).x);\n                float score = LoadScore(txBuf, creaId);\n                \n                if (int(mod(float(iFrame) + fragCoord.y, 2.)) == 0) {\n\t                int creaId_s = int(LoadRank(txBuf, creatureId-1).x);\n    \t            float score_s = LoadScore(txBuf, creaId_s);\n                    if (creatureId>0 && score_s < score) { \n                        creaId = creaId_s; //score = score_s;\n                    }\n                } else {\n                    int creaId_n = int(LoadRank(txBuf, creatureId+1).x);\n\t                float score_n = LoadScore(txBuf, creaId_n);\n                    if (creatureId < NB_CREATURE-1 && score_n > score) { \n                        creaId = creaId_n;     //score = score_n;\n                    }\n                }\n               \tfragColor = vec4(creaId, score, 0, 0);   \n                \n            } else if (varColId < LINK && eltId < nbElt) {\n                \n\t            // Do physical simulation\n                float tSimulation = iTime - timeStage;\n                \n                Simulate(tSimulation, txBuf, creatureId, nbElt, eltId, rm, vm, qm, wm, rad);\n\t\t\t\t\n                // Save new positions, orientation and speeds\n                fragColor = varColId == POSITION ? vec4(rm, rad) :\n\t\t\t\t\t\t    varColId == ORIENTATION ? qm :\n\t\t\t\t\t\t    varColId == VELOCITY ? vec4(vm,0) : vec4(wm,0);\n            }\n        }\n    }\n    \n\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}