{"ver":"0.1","info":{"id":"43cGzl","date":"1716858868","viewed":48,"name":"lighting and Shadow ","username":"akr51","description":"For lesson E14 in my shadertoy tutorial series","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ITR 120\n#define MAX 80.0\n#define SRF 0.001\n\n\nmat2 r2(float t)\n{\n\n\n\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p.xy *= r2(iTime);\n       p.zy *= r2(iTime * 0.5);\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n\nfloat map(vec3 sp)\n{\n\n\n    float d = sdBoxFrame(sp + vec3(0.0, -1.0, 0.0), vec3(1.0), 0.2);\n    return min(d, sp.y + 1.0);\n\n\n}\n\n\nvec3 nml(vec3 p)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p) - vec3(map(p - d.xyy), map(p - d.yxy), map(p - d.yyx)));\n    \n}\n\n\nfloat mrch(vec3 ro, vec3 rd)\n{\n\n\n    float d0 = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n    \n        vec3 sp = ro + rd * d0;\n        float ds = map(sp);\n        d0 += ds;\n        \n        if (d0 > MAX || abs(ds) < SRF) break;\n    \n    }\n    \n    return d0;\n\n}\n\n\n\nfloat illuminate(vec3 sp, vec3 lp)\n{\n\n\n\n      vec3 l = normalize(lp - sp);\n      vec3 n = nml(sp);\n      float df = clamp(dot(n, l), 0.0, 1.0);\n      \n      float d = mrch(sp + n * 0.02, l);\n      \n      if (d < length(lp - sp))\n      {\n      \n      \n          df *= 0.1;\n      \n      }\n      \n      return df;\n\n}\n\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n\n\n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w) * normalize(vec3(uv, 2.0));\n    \n\n\n}\n\n\n\nvoid mainImage( out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    \n    vec3 ro = vec3(0.0, 0.1, -5.0);\n    vec3 fx = vec3(0.0, 0.01, 0.0);\n    vec3 lp = vec3(0.4, 0.2, -2.0);\n    vec3 rd = dir(uv, ro, fx);\n    vec3 cl = vec3(0.0);\n    \n    float d0 = mrch(ro, rd);\n    \n    if (d0 < MAX)\n    {\n    \n        vec3 sp = ro + rd * d0;\n        float df = illuminate(sp, lp);\n        cl += df * vec3(1.0, 0.2, 0.3);\n    \n    \n    }\n    \n    // some people like gamma correction:\n    cl = pow(cl, vec3(0.4545));\n    \n    c_out = vec4(cl, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}