{"ver":"0.1","info":{"id":"DlBXzR","date":"1675535529","viewed":87,"name":"random space nuggets","username":"Masqualero","description":"raymarch","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\nfloat getDist(vec3 p){\n    float sds = 5.0 ;\n    vec3 pc = mod(p + sds, sds*2.0) - sds ;\n    \n    vec4 s = vec4(0, 0, 0, 2);\n    float sphereDist = length(pc - s.xyz) - s.w ;\n    \n    float d = sphereDist ;\n    \n    d += sin(iTime * 10.0 + p.x * 2.0) * sin(iTime * 10.0 + p.z * 2.0) * sin(iTime * 10.0 + p.y * 2.0);//texture(iChannel0, p.xyz * 0.05).x ;\n    // distance is altered by stuff\n    \n    \n    return d ;\n\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for (int i=0 ; i<MAX_STEPS; i++){\n        \n        vec3 p  = ro +  rd * dO ;\n        float dS = getDist(p);\n        dO += dS ;\n        \n        if(dO > MAX_DIST || dS <SURF_DIST) break;\n        \n    }\n    \n    return dO ;\n}\n\nvec3 getNormal(vec3 p){\n\n    float d = getDist(p) ;\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d-vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)) ;\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 pz){\n    vec3 lightPos = vec3(0.0, 0.0, -6.0) + pz ;\n    lightPos.xz += vec2(cos(iTime), sin(iTime * 1.3 + 2.0)) * 10.0 ;\n    vec3 l = normalize(lightPos - p) ;\n    vec3 n = getNormal(p);\n    \n    float dif = clamp( dot(n, l), 0.0, 1.0 ) ;\n    \n    float d = rayMarch(p + n, l);\n    \n    if (d<(length(lightPos - p))) dif*=0.4 ;\n    \n    dif = (1.0 - 0.3) * dif + 0.3 ;\n    \n    return dif ;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y ; \n    vec3 ro = vec3(2.9, 1.7, 1.3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0)) ;\n    \n    //---------\n    \n    rd.yz = rotate(rd.yz, iTime * 1.5) ;\n    rd.xz = rotate(rd.xz, iTime * 0.6 + 0.5) ;\n    ro += vec3(iTime, iTime, iTime) * vec3(2, 5, 9) ;\n    //rd.yz = rotate(rd.yz, iTime * 0.01) ;\n    \n    float d = rayMarch(ro, rd) ;\n    \n    vec3 p = ro + rd * d ;\n    \n    float dif = getLight(p, ro) ;\n    vec3 col = vec3(dif);\n    \n    col *= vec3(clamp(uv, -1.0, 1.0) * 0.5 + 0.5, clamp(d/100.0, 0.0, 1.0)) ;\n    \n    float dperc = (d / MAX_DIST) ;\n    \n    dperc = dperc * dperc ;\n    \n    vec3 sky = mix(vec3(1, 1, 1), vec3(0.5, 0.9, 1), rd.y * 0.5 + 0.5) ;\n    \n    col = (1.0 - dperc) * col + dperc * sky;\n    \n    if (d>=MAX_DIST) col=sky ;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}