{"ver":"0.1","info":{"id":"fty3zK","date":"1637958499","viewed":469,"name":"Interactive Julia","username":"AntoineC","description":"The Julia set for Zn+1 = b*abs(a*Zn)+c offers a pretty amazing variety of shapes and textures.\n\nZoom in: hold click (or up arrow)\nZoom out: hold shift-click (or down arrow)\nPan: mouse drag\nReset: space bar\n\n","likes":27,"published":1,"flags":48,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ----------------------------------------------------------------------------------------\n//\t\"Interactive Julia\" by Antoine Clappier - Nov 2021\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n//\n//     The Julia set for Zn+1 = b*abs(a*Zn^3)+c offers a pretty amazing\n//     variety of shapes and textures.\n//\n//     Interactive version of my previous animated shader:\n//     https://www.shadertoy.com/view/ftGGDR     \n\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n\t// Read accumulation buffer:\n\tcolor = texture(iChannel0, coord/iResolution.xy);\n\n\t// \"De-banding\" with 1-bit random dithering (use Dave Hoskins hash33):\n\tvec3 p = fract(vec3(coord, iFrame) * vec3(.1031, .1030, .0973));\n\tp += dot(p, p.yxz+19.19);\n\tvec3 noise = fract((p.xxy + p.yxx)*p.zyx);\n\tcolor.rgb += (noise-0.5)/255.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Pi        3.14159265359\n#define Tau       6.28318530718\n#define ToRad(a)  ((a)*Pi/180.0)\n#define ToDeg(a)  ((a)*180.0/Pi)\n#define Rot(a)    mat2(cos(ToRad(a)),sin(ToRad(a)),-sin(ToRad(a)),cos(ToRad(a)))\n#define Scale(s)  mat2((s),0.,0.,(s))\n\n\nfloat PreScale             = 0.0;\nfloat PreGamma             = 1.0;\nbool  RepeatEnabled        = false;\nfloat RepeatFrequency      = 1.0;\nfloat ContrastStrength     = 0.0;\nfloat ContrastHighlight    = 1.0;\nfloat PostGamma            = 1.0;\nint   MaxIter              = 256;\nfloat Rotation             = 0.0;\nvec2  A                    = vec2(1.0,0.0);\nvec2  B                    = vec2(1.0,0.0);\nvec2  C                    = vec2(-0.512511,0.521295);\nvec3  Loc0                 = vec3(0.0,0.0,1.0);\nvec2  Dst0                 = vec2(0.0,0.0);\nvec3  Loc1                 = vec3(0.0,0.0,1.0);\nvec2  Dst1                 = vec2(0.0,0.0);\nvec3  Loc2                 = vec3(0.0,0.0,1.0);\nvec2  Dst2                 = vec2(0.0,0.0);\nvec3  BackColor            = vec3(0.286,0.353,0.459);\nfloat R0                   = 0.20884;\nfloat R1                   = 2.21687;\n\n\n// -----------------------------------------------------------------------\n// --- Fractal: ----------------------------------------------------------\n// -----------------------------------------------------------------------\n\nvec2 Cube(vec2 z)\n{\n    vec2 b = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n    return vec2(z.x*b.x - z.y*b.y, z.x*b.y + z.y*b.x);\n}\n\nvec2 Mul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 Julia(vec2 z)\n{\n    float d = 0.0;\n    vec2 z0 = z;\n    float magnitude0 = length(z);\n    for(int i=0; i<MaxIter; i++)\n    {\n        // Formula: Zn+1 = b*abs(a*Zn^3) + c\n        //  Based on a formula seen a while ago on Tom Beddard's blog.\n        //  The Mandelbrot set is uninteresting.\n        //  But the Julia sets are quite varied and surprising!\n\n        z = Mul(abs(Mul(A, Cube(z))), B) + C;\n\n        float magnitude = length(z);\n        if(magnitude > 32.0)\n        {\n            return vec2(0.0);\n        }\n\n        d += exp(-1.0/abs(magnitude0 - magnitude));\n        z0 = z;\n        magnitude0 = magnitude;\n    }\n\n    return vec2(log(d), 1.0);\n}\n\n\n// -----------------------------------------------------------------------\n// --- Scenes: -----------------------------------------------------------\n// -----------------------------------------------------------------------\n\n\nvec2 Jitter(in vec2 fragCoord)\n{\n    // Using Dave Hoskin's hash:\n    vec3 p3 = fract(vec3(fragCoord, iTime) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fragCoord + vec2(fract((p3.xx+p3.yz)*p3.zy) - 0.5);\n}\n\nvoid SetSceneParameters(float scene)\n{\n    // Settings were created interactively using Synthclipse\n    // A nice IDE to code Shadertoys.\n    if(scene == 0.0)\n    {\n        // Setting7:\n        A=vec2(-0.05050397,-0.168316); B=vec2(0.96969604,-1.242424); C=vec2(-0.909088,0.8788879); ContrastStrength=0.72245; Dst0=vec2(1.51278,0.0); Dst1=vec2(0.25989,0.50691); Loc0=vec3(0.52830005,0.0,5.05447); Loc1=vec3(0.25989,1.6831,3.45227); Loc2=vec3(0.0,0.0,0.38554); MaxIter=232; PostGamma=1.5959187; PreGamma=1.0685698; PreScale=-0.18775594; R0=1.1245; R1=5.644266; RepeatFrequency=2.2; Rotation=65.47356;\n    }\n    else if(scene == 1.0)\n    {\n        // Setting10:\n        A=vec2(2.0,1.0026519); B=vec2(-0.27045596,0.74801207); C=vec2(-0.014915943,-0.48476005); ContrastStrength=0.50204; Dst0=vec2(-0.09985,0.0516); Dst1=vec2(0.0,0.75789); Loc0=vec3(-0.1517,0.08739,41.14481); Loc1=vec3(0.0,0.25713,6.7275); MaxIter=243; PostGamma=0.6497946; PreGamma=1.099593; PreScale=1.1199999; RepeatEnabled=true; RepeatFrequency=0.72755504; Rotation=21.132;\n    }\n    else if(scene == 2.0)\n    {\n        // Setting1:\n        A=vec2(1.0,1.071604); B=vec2(0.92345595,-1.120988); BackColor=vec3(0.28627452,0.45882353,0.42352942); C=vec2(-0.34274006,0.3664961); ContrastHighlight=0.155102; ContrastStrength=0.395918; Dst0=vec2(0.0,0.31722); Dst1=vec2(0.38814,0.0); Loc0=vec3(-0.3941,0.31722,6.11591); Loc1=vec3(0.38814,-0.53359,4.17725); MaxIter=252; PostGamma=1.8440815; PreGamma=0.6546016; PreScale=0.42379594; R1=2.538152; RepeatFrequency=0.63; Rotation=14.2956;\n    }\n    else if(scene == 3.0)\n    {\n        // Setting9:\n        A=vec2(2.0,2.0); B=vec2(-0.29177594,0.75862); BackColor=vec3(0.26666668,0.36078432,0.45882353); C=vec2(-0.07557595,-0.40087605); ContrastStrength=0.62576604; Dst0=vec2(-0.20006,0.0); Dst1=vec2(0.24391,0.4249); Loc0=vec3(-0.26006,0.0,54.76373); Loc1=vec3(0.24842,0.43541,276.8017); Loc2=vec3(0.0,0.0,1.21); MaxIter=243; PostGamma=0.773876; PreGamma=0.6546016; PreScale=1.232652; R1=1.95984; RepeatFrequency=2.2; Rotation=134.94635;\n    }\n    else if(scene == 4.0)\n    {\n        // Setting11:\n        A=vec2(2.0,0.8859401); B=vec2(-1.1830239,0.3662479); BackColor=vec3(1.0,0.9607843,0.8); C=vec2(0.3154359,-0.30016804); ContrastHighlight=0.0; ContrastStrength=-0.640816; Dst0=vec2(-0.715,0.0); Dst1=vec2(0.0,-0.36); Loc0=vec3(-0.65108,0.0,66.26409); Loc1=vec3(0.0,0.0,15.86309); Loc2=vec3(0.0,0.0,1.4641); MaxIter=243; PostGamma=0.96; PreGamma=4.0; PreScale=1.134692; R0=0.353412; R1=1.783132; RepeatEnabled=true; RepeatFrequency=0.9663227; Rotation=112.032715;\n    }\n    else if(scene == 5.0)\n    {\n        // Setting12:\n        A=vec2(0.11140394,-0.992044); B=vec2(-0.854112,0.3662479); BackColor=vec3(0.38039216,0.4392157,0.56078434); C=vec2(0.581028,0.562248); ContrastHighlight=0.0; ContrastStrength=0.191836; Dst0=vec2(-0.59736,0.11306); Dst1=vec2(0.0,-1.06502); Loc0=vec3(-0.59736,-0.05234,23.22517); Loc1=vec3(0.0,-0.76502,13.11); Loc2=vec3(0.0,0.0,0.75131); MaxIter=345; PostGamma=0.96; PreScale=-0.808512; R0=0.096384; R1=3.084336; RepeatEnabled=true; RepeatFrequency=1.494685; Rotation=57.81492;\n    }\n    else if(scene == 6.0)\n    {\n        // Setting6:\n        A=vec2(-0.31983197,-0.030303955); B=vec2(0.96969604,-0.19192004); BackColor=vec3(0.19607843,0.2627451,0.4); C=vec2(-0.90909195,0.878788); ContrastHighlight=0.0; ContrastStrength=-0.67347; Dst0=vec2(-0.88277,0.0); Dst1=vec2(0.0,-1.01423); Loc0=vec3(0.0,0.0,4.17725); Loc1=vec3(0.0,-1.23423,13.11); Loc2=vec3(0.0,0.0,0.51316); MaxIter=243; PostGamma=1.5959187; PreScale=-0.773672; R0=1.140564; R1=3.598392; RepeatEnabled=true; RepeatFrequency=0.8071442; Rotation=57.81492;\n    }\n    else if(scene == 7.0)\n    {\n        // Setting5:\n        A=vec2(0.24242401,-0.07070804); B=vec2(0.9798,-0.18182003); BackColor=vec3(0.28627452,0.45882353,0.42352942); C=vec2(-0.15151596,0.878788); ContrastHighlight=0.155102; ContrastStrength=1.0; Dst0=vec2(0.0,0.31722); Dst1=vec2(0.38814,0.0); Loc0=vec3(0.0,0.0,0.51316); Loc1=vec3(0.38814,-0.53359,4.17725); Loc2=vec3(0.0,0.0,0.51316); MaxIter=342; PostGamma=2.386938; PreGamma=0.6546016; PreScale=-0.432652; R1=2.538152; RepeatFrequency=0.63; Rotation=5.37984;\n    }\n}\n\n\n// -----------------------------------------------------------------------\n// --- Image processing: -------------------------------------------------\n// -----------------------------------------------------------------------\nvec3 Cubic(vec3 c, float d0, float d1)\n{\n    return c*((d0+d1-2.)*c*c +(3.-2.*d0-d1)*c + d0);\n}\n\nvec3 Contrast(vec3 c)\n{\n    float s = ContrastStrength, h = ContrastHighlight;\n    float d0 = 1.-s, d1 = (1.-h) + h*(1.-s);\n    return Cubic(Cubic(c, d0, d1), d0, d1);\n}\n\nvec3 Repeat(vec3 c)\n{\n    // Triangle:\n    return abs(2.0*fract(RepeatFrequency*c+0.5) - 1.0);\n}\n\nvec3 Curve(vec3 c)\n{\n    c = max(c, 0.0);\n    c = c*pow(2.0, PreScale);\n    c = pow(c, vec3(PreGamma));\n    c = RepeatEnabled ? c = Repeat(c) : c;\n    c = clamp(c, 0.0, 1.0);\n    c = Contrast(c);\n    c = pow(c, vec3(PostGamma));\n\n    return c;\n}\n\n\n\n// -----------------------------------------------------------------------\n// --- Rendering: --------------------------------------------------------\n// -----------------------------------------------------------------------\nuniform float aa; //! slider[0,1,8]\nuniform float bb; //! slider[0,1,8]\n\nvoid Render(out vec4 fragColor, in vec2 fragCoord)\n{\n    // local coordinate:\n    vec2 p, c, r = iResolution.xy, f = fragCoord;\n    p = r.x < 2.0*r.y ? 4.0*f/r.x + vec2(0.0, 1.0-2.0*r.y/r.x) : 2.0*f/r.y + vec2(2.0-r.x/r.y, 0.0);\n\n    // Select scene based on coordinate:\n    vec2 scene = floor(p);\n    if((scene.x < 0.0) || (scene.y < 0.0) || (scene.x > 3.0) || (scene.y > 1.0))\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    SetSceneParameters(scene.x + 4.0*scene.y);\n    p = 1.1*(2.0*fract(p)-1.0);\n\n\n    // Transform:\n    mat2 tfm = Rot(Rotation)/Loc2.z;\n\n    // Render:\n    vec2 cm   = Julia(tfm*p);\n    vec3 col  = Curve(vec3(cm.x));\n    vec3 back = mix(vec3(0.0), vec3(0.286,0.353,0.459), smoothstep(0.21, 2.22, length(p)));\n    col = mix(back, col, cm.y);\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n// --- Key toggles -----------------------------------------------------\n// Fabrice Neyret - https://www.shadertoy.com/view/llySRh\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define KeyToggle(ascii)  ( texelFetch(iChannel1,ivec2(ascii,2),0).x > 0.)\n#define KeyDown(ascii)    ( texelFetch(iChannel1,ivec2(ascii,1),0).x > 0.)\n#define KeyPressed(ascii) ( texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\n\n#define Key_Shift 16\n#define Key_Ctrl  17\n#define Key_Space 32\n#define Key_Up    38\n#define Key_Down  40\n\n// ---------------------------------------------------------------------\n// --- Load/Store from IQ (https://www.shadertoy.com/view/MddGzf) ------\n// ---------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 Load(in vec2 address) { return texture(iChannel0, (0.5+address) / iResolution.xy, -100.0 ); }\nvoid Store(in vec2 address, in vec4 value, inout vec4 fragColor, in vec2 fragCoord) { fragColor = (isInside(fragCoord,address) > 0.0) ? value : fragColor; }\n\n// Address:\nconst vec2 mResolution    = vec2(0.0, 0.0);\nconst vec2 mMouse         = vec2(1.0, 0.0);\nconst vec2 mTransZoom     = vec2(2.0, 0.0);\nconst vec2 mMouseDownTime = vec2(3.0, 0.0);\nconst vec2 mAction        = vec2(4.0, 0.0);\n\n\n\n\n// ---------------------------------------------------------------------\n// ---------------------------------------------------------------------\n// ---------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load state:\n    vec2 resolution0 = Load(mResolution).xy;\n    vec2 resolution1 = iResolution.xy;\n    vec4 mouse0 = Load(mMouse);\n    vec4 mouse1 = iMouse;\n    vec3 transZoom0 = iFrame == 0 ? vec3(0,0,1) : Load(mTransZoom).xyz;\n    vec3 transZoom1 = transZoom0;\n    float mouseDownTime = mouse0.z < 0.0 && mouse1.z > 0.0 ? iTime : Load(mMouseDownTime).x;\n    float action = Load(mAction).x;\n\n    bool up   = KeyPressed(Key_Up);\n    bool down = KeyPressed(Key_Down);\n\n#ifdef SYNTHCLIPSE_ONLY\n    bool zooming  = iMouse.z > 0.0 && (length(iMouse.xy-abs(iMouse.zw)) <= 5.0 || action == 1.0) && iTime-mouseDownTime > 0.1;\n    bool dragging = iMouse.z > 0.0 && (length(iMouse.xy-abs(iMouse.zw)) > 5.0 || action == 2.0);\n#else\n    bool zooming  = iMouse.z > 0.0 && (length(iMouse.xy-abs(iMouse.zw)) <= 5.0 || action == 1.0) && iTime-mouseDownTime > 0.1;\n    bool dragging = iMouse.z > 0.0 && iMouse.w < 0.0 && (length(iMouse.xy-abs(iMouse.zw)) > 5.0 || action == 2.0);\n#endif\n\n\n    // Update transform:\n    action = 0.0;\n    if(zooming || up || down)\n    {\n        transZoom1.z *= KeyPressed(Key_Shift) || down ? 1.0/0.94 : 0.97;\n        transZoom1.xy += mouse1.xy*(transZoom1.z - transZoom0.z);\n        action = 1.0;\n    }\n    else if(dragging)\n    {\n        transZoom1.xy += transZoom1.z*(mouse1.xy - mouse0.xy);\n        action = 2.0;\n    }\n\n    if(resolution0 != resolution1 || KeyPressed(Key_Space))\n    {\n        transZoom1 = vec3(0,0,1);\n    }\n\n    // Invalidate buffer?\n    bool invalidate = iFrame == 0;\n    invalidate = invalidate || resolution0 != resolution1;\n    invalidate = invalidate || transZoom0 != transZoom1;\n\n    // Get accumulated color at previous coordinate:\n    vec4 color = invalidate ? vec4(0) : texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Render:\n    if(color.w < 64.0)\n    {\n        Render(fragColor, Jitter(fragCoord)*transZoom1.z - transZoom1.xy);\n\n        // Accumulate in linear space:\n        color.rgb = pow(color.rgb, vec3(2.2)) * color.w + pow(fragColor.rgb, vec3(2.2));\n        color.w++;\n        color.rgb = pow(color.rgb/color.w, vec3(1./2.2));\n    }\n    fragColor = color;\n\n\n    // Store state:\n    //  Only update time when an actual translation occurs.\n    Store(mResolution,    vec4(resolution1, 0.0, 0.0),  fragColor, fragCoord);\n    Store(mMouse,         mouse1,                       fragColor, fragCoord);\n    Store(mTransZoom,     vec4(transZoom1, 0.0),        fragColor, fragCoord);\n    Store(mMouseDownTime, vec4(mouseDownTime),          fragColor, fragCoord);\n    Store(mAction,        vec4(action),                 fragColor, fragCoord);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}