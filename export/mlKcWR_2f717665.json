{"ver":"0.1","info":{"id":"mlKcWR","date":"1700430154","viewed":28,"name":"Deezer new Logo","username":"Karp","description":"https://koto.studio/work/deezer/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","help","tuto"],"hasliked":0,"parentid":"NdVGzw","parentname":"MyShaderToy ToolBox"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn clamp01(sdfCircle * (10.0/blur));\n}\nfloat Oval(vec2 uv, vec2 center, vec2 shape, float size, float blur) \n{\n    float sdf = sdEllipse(uv-center, shape * size);\n\treturn clamp01(sdf * (10.0/blur));\n}\n\nfloat Wave(vec2 uv, float time) \n{\n\tfloat a = abs(mod(time,6.0) - 3. - uv.x);\n    return clamp01(1.5 - (a * 3.)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy, iResolution.xy); \n    \n    //Parameter\n    float AA = 0.1;\n    float time = iTime * 2.;\n    vec3 mainColor = RGB(1, 0, 1);\n    vec3 subColor = RGB(164, 56, 255);\n    vec3 sub2Color = RGB(255-164, 255-56, 0);\n    \n    vec2[] size = vec2[] ( vec2(.045,.150),vec2(.070,.350),vec2(.110,.500),vec2(.090,.540),vec2(.135,.530),vec2(.090,.540),vec2(.110,.500),vec2(.070,.350),vec2(.045,.150));\n    vec2[] pos =  vec2[] ( vec2(-.63,.400),vec2(-.500,.40),vec2(-.360,.33),vec2(-.200,.20),vec2(0.000,.00),vec2(0.200,.20),vec2(0.360,.33),vec2(0.500,.40),vec2(0.630,.40));\n    \n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = subColor;\n    \n    vec2 sUV = uv * 1.;\n    sUV += vec2(0.,0.25);\n    \n    float circleMask = .0;\n    \n    for(int i = 0; i < 9;i++)\n    {\n        circleMask = Oval(sUV, pos[i], size[i] * vec2(1.,1. + .35 * Wave(pos[i],time)), 1., AA);\n        pix = mix(mainColor, pix, circleMask); \n    }\n        \n    fragColor = vec4(pix, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Constant\n#define PI  3.14159265359\n#define TAU 6.28318530717\n\n//Color\n#define black   vec3(0.0)\n#define grey    vec3(0.5)\n#define white   vec3(1.0)\n//\n#define red     vec3(1.0,0.0,0.0)\n#define green   vec3(0.0,1.0,0.0)\n#define blue    vec3(0.0,0.0,1.0)\n//\n#define cyan    vec3(0.0,1.0,1.0)\n#define yellow  vec3(1.0,1.0,0.0)\n#define magenta vec3(1.0,0.0,1.0)\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n///UV (TextCoord)\nvec2 CenterUV(vec2 fragCoord, vec2 resolution)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5 * resolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 FullScreenUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n    uv = 2.0 * uv.xy / resolution.xy;\n\t// [-iResolution.x/2, iResolution.x/2] -> [-1.0, 1.0]\n    // [-iResolution.y/2, iResolution.y/2] -> [-1.0, 1.0]\n    \n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n\tuv = 2.0 * uv.xy / resolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    //angle in degree (TAU = 2PI = 360 degrees)\n\tangle = angle * PI / 180.0;\n    return uv * mat2( cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n}\n\n///COLOR\nvec3 RGB(int R, int G, int B)\n{\n    float rat = 1.0/255.0;\n    return vec3(float(R)*rat, float(G)*rat, float(B)*rat);\n}\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 HSV2RGB(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Source: https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 RGB2HSV(vec3 c){\n\tvec4 K=vec4(0.,-1./3.,2./3.,-1.),\n\t     p=mix(vec4(c.bg ,K.wz),vec4(c.gb,K.xy ),step(c.b,c.g)),\n\t     q=mix(vec4(p.xyw,c.r ),vec4(c.r ,p.yzx),step(p.x,c.r));\n\tfloat d=q.x-min(q.w,q.y),\n\t      e=1e-10;\n\treturn vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\nvec3 HueShiftcolor(vec3 c, float shift)\n{\n    c = RGB2HSV(c);\n    c = vec3(mod(c.x + shift,1.), c.yz);\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Maths\nfloat clamp01(float value) {return clamp(value,0.0,1.0);}\nfloat saturate(float value) {return clamp(value,0.0,1.0);}","name":"Common","description":"","type":"common"}]}