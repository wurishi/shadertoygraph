{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n// Overview:\n\n// Analysed in my FPI talk: http://www.huwbowles.com/fpi-gdc-2016/ (see slide notes)\n// Pixel intensity shows iteration count\n// Time switches between normal sphere march and the improved sphere march in this shader\n// Click-drag to explore different rays\n// Lower half of screen visualises the distance estimates along the ray (x-axis)\n// The new code is in the raymarchFPI() function\n\n// Description:\n\n// This is normal fixed point iteration but switches to the secant method whenever a\n// surface crossing is detected. This has super linear convergence properties, and\n// is guaranteed to converge safely since I'm only applying it at crossings (as opposed\n// to the normal secant method which may extrapolate instead of strictly interpolating).\n\n// The nice thing is that the raymarch loop rearranges nicely to avoid doing any\n// additional DE computations (except if the step crosses the surface, in which\n// case the step is reduced and the DE is evaulated at the new step location).\n\n// A halfway approach would be to do this correction just once - when the sphere\n// march crosses the surface for the first time, a correction is done using\n// the estimated surface position, and then the raymarch terminates. This might be\n// an easy and cheap addition to existing sphere march shaders. Future work..\n\n// There are still situations where the iteration will completely overstep surface\n// features, hence the missing parts of the bumps in the render. This can be addressed\n// by reducing step size at the expense of efficiency.\n\n\n#define ITERCNT 60\n\n// turn on and off new approach over time\n#define NEW_LIMIT_STEP (fract(iTime/4.)>.5)\n\n\n// the wavy surface\nfloat surfHeight( vec2 xz )\n{\n\tfloat result = 3.* (cos(xz.x) + cos(xz.y));\n\tresult *= 1.-exp(-length(xz)/10.);\n\treturn result;\n}\n\n// evaluate the ray\nvec3 rayPt( vec3 ro, vec3 rd, float t )\n{\n\treturn ro + rd * t;\n}\n\n// the distance estimate - a poor mans distance field. return the\n// height difference from the surface.\nfloat distField( vec3 pt )\n{\n\tfloat dSurf = pt.y - surfHeight(pt.xz);\n\treturn dSurf;\n}\n\n// raymarch\nfloat raymarchFPI( vec3 ro, vec3 rd, out float cnt )\n{\n\t// initial guess for t - just pick the start of the ray\n\tfloat t = 0.;\n\t\n\tfloat d = distField( rayPt(ro,rd,t) );\n\tfloat dNext;\n\t\n\tcnt = 0.;\n\tfor( int i = 0; i < ITERCNT; i++ )\n\t{\n\t\t// termination condition - iteration has converged to surface\n\t\tif( abs(d) < 0.001 )\n\t\t\tcontinue;\n\t\t\n\t\tdNext = distField( rayPt(ro,rd,t+d) );\n\t\t\n\t\t// NEW ALGORITHM\n\t\t// are we crossing the surface? (sign(d) != sign(dNext)).\n\t\t// im detecting this by dividing the two and checking\n\t\t// if the result is negative. the only reason i use a divide is because\n\t\t// ill reuse the division result later. i thought it would be unstable but\n\t\t// it seems to work fine!\n\t\tfloat dNext_over_d = dNext/d;\n\t\tif( NEW_LIMIT_STEP && dNext_over_d < 0.0 )\n\t\t{\n\t\t\t// fit a line from (current t, current d) to (next t, next d),\n\t\t\t// and set t to the approximated intersection of the line with d=0\n\t\t\t\n\t\t\t// the human readable version\n\t\t\t// float grad = (dNext - d) / d;\n\t\t\t// d /= -grad;\n\t\t\t// steeper gradient means smaller step. this is analytically\n\t\t\t// correct (to a linear approximation of the surface)\n\n\t\t\t// optimised (confuscated) version\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\t\n\t\t\t// re-evaluate at the partial step location\n\t\t\tdNext = distField( rayPt(ro,rd,t+d) );\n\t\t\t\n\t\t\t// OPTION - terminate march after doing one correction step..\n\t\t}\n\t\t// END OF NEW ALGORITHM\n\t\t\n\t\tt += d;\n\t\td = dNext;\n\t\t\n\t\tcnt += 1.;\n\t}\n\t\n\treturn t;\n}\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.1);\n\t\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tpp.x *= aspect;\n    \n\tif( pp.y > 0. )\n\t{\n\t\t// top half of screen. draw the 3d scene with a cross indicating\n\t\t// a particular ray\n\n\t\tpp.y = 2. * (pp.y-.5);\n\t\t\n\t\t// cross\n\t\tif( \n\t\t\t(abs(pp.x) < 0.0125/aspect && abs(pp.y) < 0.1) ||\n\t\t\t(abs(pp.y) < 0.0125 && abs(pp.x) < 0.1/aspect) )\n\t\t{\n\t\t\tfragColor.rgb = vec3(0.,1.,0.);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpp.x *= 2.;\n\t\t\n\t\t// ray march and shade based on iteration count\n\t\tvec3 ro;\n\t\tvec3 rd = computePixelRay( pp, ro );\n\t\t\n\t\tfloat cnt;\n\t\tfloat t = raymarchFPI(ro,rd, cnt);\n\t\tfloat iters = clamp(cnt/float(ITERCNT),0.,1.);\n\t\t\n\t\tfragColor.xyz = vec3( iters );\n\t}\n\telse\n\t{\n\t\t// bottom half of screen. here we will draw the graph. this is done by finding\n\t\t// out which pixel we are on, computing a graph coordinate from that, and then\n\t\t// checking if we are close to the curve.\n\t\t\n\t\t// axis\n\t\tif( abs(fragCoord.y - iResolution.y/4.) < 1.)\n\t\t{\n\t\t\tfragColor.rgb = vec3(0.4);\n\t\t}\n\t\t\n\t\t// compute ray for the middle of the screen. this is where the cross\n\t\t// is located, and this is the ray that is graphed\n\t\tvec3 ro;\n\t\tvec3 rd = computePixelRay( vec2(0.), ro );\n\t\t\n\t\t// compute the t (x-axis) value for this pixel\n\t\tfloat tmax = 50.0;\n\t\tfloat thist = tmax * fragCoord.x / iResolution.x;\n\t\t\n\t\t// evaluate the distance field for this value of t\n\t\tvec3 thisPt = rayPt( ro, rd, thist );\n\t\tfloat dist = distField( thisPt );\n\t\t\n\t\t// compute the dist (y-axis) value for this pixel\n\t\t// compute max y axis value from x axis range\n\t\tfloat maxDist = tmax * (iResolution.y*0.5/iResolution.x);\n\t\tfloat thisDist = maxDist * (pp.y+.5);\n\t\t\n\t\t// we'll also want the gradient, which tells us whether the\n\t\t// iteration will converge. compute it using forward differences\n\t\t// along the ray\n\t\tfloat eps = tmax/iResolution.x;\n\t\tvec3 nextPt = rayPt( ro, rd, thist + eps );\n\t\tfloat nextDist = distField(nextPt );\n\t\tfloat distGradient = (nextDist - dist) / eps;\n\t\t\n\t\t\n\t\t// when using FPI, the iterated function is t = distField + t\n\t\t// therefore the gradient of the iteration is d/dt(distField) + 1\n\t\tfloat fpiGrad = distGradient + 1.;\n\t\t\n\t\t// for fpi to converge, the gradient has to be in (-1,1). the next\n\t\t// few lines compute a color, blending to red over the last 20% of\n\t\t// this range\n\t\tfpiGrad = abs(fpiGrad);\n\t\tfpiGrad = smoothstep( .8, 1., fpiGrad );\n\t\tfloat g = 1.5 + -2.*fpiGrad;\n\t\tfloat r =  2.*fpiGrad;\n\t\tvec3 lineColor = clamp(vec3(r,g,0.),.0,1.);\n\t\tlineColor.g *= .85;\n\t\t\n\t\t// iq's awesome distance to implicit https://iquilezles.org/articles/distance\n\t\tfloat alpha = abs(thisDist - dist)*iResolution.y/sqrt(1.+distGradient*distGradient);\n\t\t// antialias\n\t\talpha = smoothstep( 80., 30., alpha );\n\t\tfragColor.rgb = (1.-alpha) * fragColor.rgb + lineColor * alpha;\n\t\t\n\t\t\n\t\t// additional visualisation - for sphere tracing, visualise each sphere\n\t\t// need each t value, then plot circle at each t with the radius equal to the distance\n\t\t\n\t\tfloat stepTotalAlpha = 0.;\n\t\t\n\t\tfloat stept = 0.;\n\t\t\n\t\t\tvec3 stepPt = rayPt( ro, rd, stept );\n\t\t\t\n\t\t\tfloat d = distField( stepPt );\n\t\t\n\t\tfloat dNext;\n\t\tfloat tNext;\n\t\t\n\t\tfloat last_t = 10000.; // something far away from t0\n\t\tfor( int i = 0; i < ITERCNT; i++ )\n\t\t{\n\t\t\t// termination condition - iteration has converged to surface\n\t\t\tif( abs(last_t - stept) < 0.001 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tlast_t = stept;\n\t\t\t\n\t\t\ttNext = stept + d;\n\t\t\tdNext = distField( rayPt(ro,rd,tNext) );\n\t\t\t\n\t\t\tfloat dNext_over_d = dNext / d;\n\t\t\tif( NEW_LIMIT_STEP && dNext_over_d < 0.0 )\n\t\t\t{\n\t\t\t\td /= 1.0 - dNext_over_d;\n\t\t\t\ttNext = stept + d;\n\t\t\t\tdNext = distField( rayPt(ro,rd,tNext) );\n\t\t\t}\n\t\t\t\n\t\t\tfloat stepx = -aspect + 2.*aspect * stept / tmax ;\n\t\t\tfloat stepDist = abs( d );\n\t\t\tfloat R = length( vec2(stepx,-.5) - pp );\n\t\t\t\n\t\t\tfloat circleR = stepDist / ( maxDist);\n\t\t\t// circle boundary\n\t\t\tfloat stepAlpha = 0.2*smoothstep( 5.0/iResolution.x, 0.0, abs(circleR - R) );\n\t\t\t// add a dot at the center\n\t\t\tstepAlpha += 0.3*smoothstep(5.0/iResolution.x,0.0,R);\n\t\t\t\t\n\t\t\tstepTotalAlpha += stepAlpha;\n\t\t\t\n\t\t\tstept = tNext;\n\t\t\td = dNext;\n\t\t}\n\t\tfragColor.rgb += (1.-alpha) * clamp(stepTotalAlpha,0.,1.)*vec3(1.0,1.0,0.);\n\t}\n}\n\n\n\n\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = iTime*1. + .1;\n\t//if( iMouse.z > 0. )\n\t//\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,2.5,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,2.2,0.);\n     \n    // camera frame\n\txoff = 0.;\n\tfloat yoff = 0.;\n\t//if( iMouse.z > 0. )\n\t{\n\t\txoff = -3.5*(iMouse.x/iResolution.x - .5)+.5;\n        if( iMouse.y != 0. )\n\t\t\tyoff = 2.*(4.*iMouse.y/iResolution.y-1.5);\n\t}\n\t\n\tvec3 toTarget = target-cameraPos;\n\tvec3 right = vec3(-toTarget.z,0.,toTarget.x);\n\t\n    vec3 fo = normalize(target-cameraPos + vec3(0.,yoff,0.) + xoff*right );\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdj3W3","date":"1394657513","viewed":647,"name":"Secant Step","username":"huwb","description":"Detect if we cross the surface and if so borrow a step from the Secant Method to linearly approximate the intersection. Alternating on and off over time. Analysed in FPI talk here: http://www.huwbowles.com/fpi-gdc-2016/","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fpi","convergence","iteration"],"hasliked":0,"parentid":"","parentname":""}}