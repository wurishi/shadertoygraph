{"ver":"0.1","info":{"id":"ls2cWt","date":"1495039627","viewed":264,"name":"Poincaré Hyperbolic Disk","username":"decrooks","description":"Poincaré Hyperbolic Disk Tiling","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["disk","hyperbolic","poincare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\nstruct Circle {\n    float radius;\n    vec2 center;\n};\n\nconst int numCircles = 3;\nCircle circles[3];\n\n\n/*\n\tOrthoganl Circles represent strait line in hyperbolic space.\n\t\n\tsee http://mathworld.wolfram.com/PoincareHyperbolicDisk.html.\n\n*/\nCircle orthogonalCircle(float theta1,float theta2) {\n    \n    float theta = 0.5*(theta1 + theta2);\n    float dTheta = 0.5*(theta1 - theta2);\n    \n    float r = abs(tan(dTheta));\n   //  float r = 0.5;\n    float R = 1.0/cos(dTheta);\n    \n    vec2 center = vec2(R*cos(theta),R*sin(theta));\n    \n    return Circle(r,center);\n}\n\n\nvoid createCircles() {\n\n    float t = 0.5 - 0.5*cos(iTime);\n\n  \tfloat theta = TWO_PI/3.0;\n   \n    \n    float dTheta = 2.43 + 0.152*t;\n    \n\t//for(int i;i<numCircles  )\n    circles[0] = orthogonalCircle(0.0,dTheta);\n    circles[1] = orthogonalCircle(theta,theta + dTheta);\n    circles[2] = orthogonalCircle(2.0*theta,2.0*theta +  dTheta);\n}\n\nbool circleContains(vec2 p, Circle c) {\n    \n   return distance(c.center,p) < c.radius;\n    \n}\n\n\n/*\n\tCircle inversion exchanges the inside with the outside of a circle.\n\tReflections in hyperbolic space.\n*/\nvec2 circleInverse(vec2 p, Circle c){\n    \n\treturn ((p - c.center) * c.radius * c.radius)/(length(p - c.center) * length(p - c.center) ) + c.center;\n    \n}\n\nbool isEven(int i){\n    \n    return mod(float(i),2.0) == 0.0;\n    \n}\n\n/*\n\tIterated Inversion System \n    see this paper http://archive.bridgesmathart.org/2016/bridges2016-367.pdf\n    and this shader https://www.shadertoy.com/view/XsVXzW by soma_arc.\n\n\tThis algorythim for draws tileings on the poncaire disk model of hyperbolic space.\n\t\n\tOur array of circles represent the reflections that generate the tiling.\n\tWe repeatedly invert the point in each of the circles and keep track of the total number of inversions.\n\n*/\n\nbool iteratedInversion(vec2 p) {\n    \n\n    int count = 0;\n    bool flag = true;\n    \n    for(int i=0; i<100; i++) {\n        \n        flag = true;\n        \n        \n        for(int j = 0; j<numCircles; j++) {\n            Circle c = circles[j];\n\n            if(circleContains(p, c)) {\n                \n                p = circleInverse(p,c);\n                flag = false;\n                count++;  \n                \n        \t} \n            \n        }\n        \n        if(flag) {\n           break;\n        }\n        \n    }\n    \n    return isEven(count);\n    \n}\n\nfloat drawCircles(vec2 p) {\n    \n    float  d0 =  abs(distance(circles[0].center,p) - circles[0].radius);\n    float  d1 = abs(distance(circles[1].center,p) - circles[1].radius);\n    float  d2 =  abs(distance(circles[2].center,p) - circles[2].radius);\n    \n    float disk = abs(length(p) - 1.0);\n   \n    float d =  min(min(min(d0,d1),d2),disk);\n    \n    if(d<0.01) {\n     \treturn 0.0;   \n    }\n    else {\n        return 1.0 - 0.5*d;  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tcreateCircles();\n    \n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float r = length(uv);\n    \n    vec4 black = vec4(vec3(0.0),1.0);\n    vec4 white = vec4(1.0);\n    \n    \n    //Uncomment this to see the circles that generate the tiling\n    //fragColor = vec4(vec3(drawCircles( uv)),1.0); return;\n   \n   \n    if (r<1.0){\n        if (iteratedInversion(uv)) {\n\n            fragColor = white;\n\n        }\n        else {\n\n            fragColor = black;\n\n        }   \n    }\n    else {\n        fragColor = black;\n    }\n}","name":"Image","description":"","type":"image"}]}