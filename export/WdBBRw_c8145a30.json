{"ver":"0.1","info":{"id":"WdBBRw","date":"1589660482","viewed":220,"name":"vortex path","username":"sukupaper","description":"NB: You can get more fps by setting up MBLUR to 1","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","light","truchet","vortex","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float t;\nvec3 map;\n\nfloat anim1(float x, float sm){\n  float xmd = mod(x,2.) - .5;\n  return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - 1.);\n}\n\nfloat h(vec2 p){ return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.585); }\nfloat hm(vec2 p, float v){ return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.585 + v); }\n\nfloat c(vec2 p, float s) { return length(p) - s; }\nfloat sq(vec2 p, float s, float r) { return length(max(abs(p) - s,0.)) - r; }\nfloat ushape(vec2 p, float t, float sel) {\n    p.x += sel;\n    float d = max(abs(min(c(p - vec2(.5),.5),c(p + vec2(.5),.5))) - t,sq(p,.5,.001));\n    p.x -= 1.;\n    d = min(d,max(abs(min(c(p - vec2(.5,-.5),.5),c(p + vec2(.5,-.5),.5))) - t,sq(p,.5,.001)));\n    return d - .05;\n}\nfloat pattern(vec2 p, float sz) {\n    float pz = p.y;\n    p *= sz;\n    vec2 pf = floor(p); \n    p = fract(p) - .5;\n    float rep = 0.02;\n    float d = ushape(p,rep*.5,step(h(pf),.75));\n    int lim = int(anim1(t*.5 + pz*.25,.5)*11.);\n    for(int i = 0; i < 11; i++) {\n        if(i == lim) break;\n        d = abs(d - rep) - rep;\n    }\n    return d/sz;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat df(vec3 p) {\n    p.z += t;\n    p.y += .5;\n    p.xy *= rot(cos(p.z));\n    p.y -= .5;\n    map = p;\n    return max(-1.,-(length(p.xy) - 1.));\n}\n\n#define EPSI .001\nvec3 normal(vec3 p){\n    vec2 u = vec2(0.,EPSI); float d = df(p);\n    return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d);\n}\n\n#define MIN_DIST 0.\n#define MAX_DIST 100.\n#define MAX_STEPS 80\n#define LIM .001\nfloat cptI = 0.;\nvec3 rm(vec3 c, vec3 r) {\n    vec3 color = vec3(1.0);\n    vec3 p = c + r*MIN_DIST;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = df(p);\n        if(d < LIM) {\n            vec3 n = normal(p);\n            color = n*.75+.5;\n            vec3 dph = float(i)*.025*vec3(1.);\n            vec2 pr = vec2(atan(map.x,map.y),map.z);\n            float d1 = pattern(pr/vec2(3.14159265359*.25,1.) + vec2(t*2.,2.*t),1.);\n            float aa = 1./iResolution.x;\n            color = mix(color+dph,dph*(n*.5 + .5),smoothstep(-aa,aa,d1));\n            color = mix(color, color + map*.5+.5, .0001);\n            cptI = float(i);\n            return color;\n        }\n        if(distance(c,p) > MAX_DIST) return color;\n        p += d*r;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    float tScale = .5 +  .0001*(cos(iTime*.5)*.5+.5);\n    t = iTime*tScale;\n    vec2 xyshift = vec2(cos(t*2.)*.53,sin(t*2.)*.53);\n    t -= pow(length((st + xyshift)*.5),1.3)*(.5+.5*cos(t*.5));\n    vec3 c = vec3(xyshift,(-2.));\n    vec3 r = normalize(vec3(st,.35));\n    r.xy *= rot(-t*1.2);\n    r.xz *= rot(3.14*anim1(iTime*.05,.05));\n    \n    #define MBLUR 1\n    vec3 color = vec3(0.);\n    for(int i = 0; i < MBLUR; i++) {\n        t += (.51*(1.-(cos(iTime*.5)*.5+.5)))/60.;\n        color += rm(c,r);\n    }\n    color /= float(MBLUR);\n    fragColor = vec4(color + pow(length(st)*.7,4.),1.0);\n}","name":"Image","description":"","type":"image"}]}