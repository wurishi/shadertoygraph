{"ver":"0.1","info":{"id":"7l3GW2","date":"1636974536","viewed":183,"name":"Voronoi Incircles Approximation","username":"nr4","description":"Numeric approximation of cell centers. Applied to incircles of the voronoi cells.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","circle","approximation","incircle","inscribed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Voronoi Incircles Approximation\n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\n\nfloat sm(float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nvec2 lf2(vec2 t)\n{\n    return .5+.5*vec2(lfnoise(t+.5*iTime), lfnoise(13.327+t+.5*iTime));\n}\n\nstruct VoronoiCell2\n{\n    vec2 controlPoint;\n    vec2 center;\n    float incircleRadius;\n    vec2 gridIndex;\n    float dist;\n};\n\nvec2 scramble2(vec2 x)\n{\n    x = floor(x);\n    return x + lf2(x);\n}\n\nvec3 dnvoronoi(vec2 x)\n{\n    float n,\n        ret = 1.e3,\n        df = 1.e3,\n        d,\n        rc = 1.e3;\n    vec2 y = floor(x),\n        pf = c.yy,\n        ps = c.yy,\n        p,\n        nv;\n    \n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = scramble2(y+vec2(ivec2(i,j)));\n            \n            d = length(x-p);\n            \n            if(d < df)\n            {\n                df = d;\n                pf = p;\n            }\n        }\n    d = 1.e3;\n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = scramble2(y+vec2(ivec2(i,j)));\n            \n            vec2 o = p-pf;\n            float na = .5*length(o)-dot(x-pf,normalize(o));\n            if(na < ret)\n            {\n                ret = na;\n                nv = o;\n            }\n        }\n        \n    return vec3(ret, nv);\n}\n\nVoronoiCell2 voronoi2(vec2 x, float cellSize)\n{\n    // Scale to grid size 1\n    x /= cellSize;\n\n    VoronoiCell2 cell;\n    \n    float dmin = 1.e3, d;\n    vec2 p;\n    \n    cell.gridIndex = floor(x);\n    \n    // Find nearest control point\n    for(int i=-1; i<=1; ++i)\n        for(int j=-1; j<=1; ++j)\n        {\n            p = scramble2(cell.gridIndex + vec2(ivec2(i,j)));\n            d = length(x-p);\n            \n            if(d < dmin)\n            {\n                dmin = d;\n                cell.controlPoint = p;\n            }\n        }\n    \n    // Approximate cell center\n    // TODO: Is there a better way than this? 3 Sides determine an incircle, and the biggest one of these\n    // is the polygon incircle. But that requires the polygon vertices! Those are annoying to determine.\n    cell.center = cell.controlPoint;\n    for(int i=0; i<55; ++i)\n    {\n        cell.center -= dnvoronoi(cell.center).yz/float(i+1)*.4;\n    }\n    \n    // Find voronoi distance\n    cell.dist = 1.e3;\n    cell.incircleRadius = dnvoronoi(cell.center).x;\n    for(int i=-1; i<=1; ++i)\n        for(int j=-1; j<=1; ++j)\n        {\n            p = scramble2(cell.gridIndex + vec2(ivec2(i,j)));\n            vec2 o = p-cell.controlPoint;\n            cell.dist = min(cell.dist, .5*length(o)-dot(x-cell.controlPoint,normalize(o)));\n        }\n        \n    // Rescale\n    cell.controlPoint *= cellSize;\n    cell.center *= cellSize;\n    cell.dist *= cellSize;\n    cell.incircleRadius *= cellSize;\n    \n    return cell;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    uv += 5.3;\n\n    float size = 1./8.;\n    VoronoiCell2 cell = voronoi2(uv, size);\n    \n    // Cell color, grid cell color and bounds\n    vec3 col = mix(c.xxx-.4*c.yxx*(.5+.5*lfnoise(13.*cell.controlPoint))/*-.4*c.xxy*hash12(cell.gridIndex)*/, c.yyy, sm(cell.dist-.002));\n    \n    // Distance isolines\n    col = mix(col, col - .4*c.yxx, sm(abs(mod(cell.dist+.005,.01)-.005)));\n    \n    // Cell centers\n    float d = length(uv-cell.center)-.003;\n    col = mix(col, c.xxx, sm(d));\n    col = mix(col, c.yyy, sm(abs(d-.002)-.001));\n    \n    // Cell incircles\n    col = mix(col, mix(col, c.yyy,.5), sm(length(uv-cell.center)-cell.incircleRadius));\n    \n    // Cell control points\n    d = length(uv-cell.controlPoint)-.003;\n    col = mix(col, c.yyy, sm(d));\n    col = mix(col, c.xxx, sm(abs(d-.002)-.001));\n    \n    // Rectangular base grid\n    col = mix(col, .1*c.xxx, sm(min(abs(uv.x/size-cell.gridIndex.x),abs(uv.y/size-cell.gridIndex.y))-.002/size));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}