{"ver":"0.1","info":{"id":"7lSyzW","date":"1649268636","viewed":88,"name":"Ray tracing?","username":"SandyOwa","description":"first knock at ray tracing. Definitely in progress for now. I've only barely got Normals sorted out.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float f = 1.0;\n\nfloat tMin = 0.1;\nfloat tMax = 100.0;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 N;\n    float t;\n    \n    bool front_face;\n};\n\nstruct sphere {\n    vec3 center;\n    float r;\n};\n\nvec3 rLoc(ray R, float t) {\n    return R.origin + t*normalize(R.dir);\n}\n\nvoid setRecFaceNormal(inout hit_record rec, ray R, vec3 outward_normal) {\n    rec.front_face = dot(R.dir, outward_normal) < 0.0;\n    rec.N = rec.front_face ? outward_normal : -outward_normal;\n}\n\nbool hitSphere(ray R, float t_min, float t_max, sphere S, inout hit_record rec) {\n    vec3 oc = R.origin - S.center;\n    float a = pow(length(R.dir), 2.0);\n    float halfB = dot(oc, R.dir);\n    float c = pow(length(oc), 2.0) - S.r*S.r;\n    \n    float discriminant = halfB*halfB - a*c;\n    if (discriminant < 0.0) return false;\n    float sqrtd = sqrt(discriminant);\n    \n    float root = (-halfB - sqrtd) / a;\n    if (root < t_min || t_max < root) {\n        root = (-halfB + sqrtd) / a;\n        if (root < t_min || t_max < root)\n            return false;\n    }\n    \n    rec.t = root;\n    rec.p = rLoc(R, rec.t);\n    vec3 outward_normal = (rec.p - S.center) / S.r;\n    setRecFaceNormal(rec, R, outward_normal);\n    \n    return true;\n}\n\nconst int numSpheres = 10;\n\nsphere Spheres[numSpheres] = sphere[numSpheres](\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1),\n    sphere(vec3(0, 0, 0), 0.1)\n);\n\nvoid hitSphereList(ray R, float t_min, float t_max, sphere spheres[numSpheres], hit_record rec) {\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    for (int i = 0; i < numSpheres; i++) {\n        if (hitSphere(R, t_min, closest_so_far, spheres[i], temp_rec)) {\n            \n        }\n    }\n    \n}\n\nray getCamRay(vec2 coord) {\n    return ray(vec3(0.0), normalize(vec3(coord, -f)));\n}\n\nvec3 rayColor(ray R) {\n    float t = (normalize(R.dir).y + 1.0) / 2.0;\n    return (1.0 - t)*vec3(1.0) + t*vec3(0.5, 0.6, 0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords from -1 to 1\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - vec2(1.0);\n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    ray R = getCamRay(uv);\n    sphere S = sphere(vec3(cos(iTime), 0.0, -sin(iTime)-3.0), 1.0);\n    \n    vec3 result = rayColor(R);\n    hit_record record;\n    bool hit = hitSphere(R, tMin, tMax, S, record);\n    if (hit) {\n        result = 0.5 * (record.N + vec3(1.0));\n    }\n    \n    // Final Color\n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}