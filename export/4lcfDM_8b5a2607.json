{"ver":"0.1","info":{"id":"4lcfDM","date":"1539857644","viewed":276,"name":"Dangling chain simulation","username":"cnbjw","description":"A physic simulation of dangling chain using RK4 method.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["simulation","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 GetPusherPos(){\n\treturn vec2(pusherRange * sin(float(iFrame) * pusherMoveFreq), pusherY);\n}\n\nvec4 CalcColor(int i){\n\treturn vec4(1.0, 0.3 + float(i) / float(nChain) * 0.7, 0.3, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - vec2(0.5 * iResolution.x, iResolution.y)) / iResolution.y;\n    pos *= (float(nChain) * windowSize);\n    \n    for (int i = 0; i < nChain; i++){\n        // use temporary results to smooth the movement\n        vec2 Yn = texture(iChannel0, vec2(float(i) + 0.5, 0.5)/iResolution.xy).rg;\n        vec2 k1 = texture(iChannel0, vec2(float(i) + 0.5, 1.5)/iResolution.xy).rg;\n        vec2 k2 = texture(iChannel0, vec2(float(i) + 0.5, 2.5)/iResolution.xy).rg;\n        vec2 k3 = texture(iChannel0, vec2(float(i) + 0.5, 3.5)/iResolution.xy).rg;\n        if (mod(float(iFrame), 4.0) == 1.0){\n            Yn += k1 / 4.0;\n        }else if (mod(float(iFrame), 4.0) == 2.0){\n            Yn += (k1 + 2.0 * k2) / 6.0;\n        }else if (mod(float(iFrame), 4.0) == 3.0){\n            Yn += (k1 + 2.0 * k2 + 2.0 * k3) * 0.15;\n        }\n        \n        // draw the balls\n        vec2 diff = pos - Yn;\n        fragColor += (1.0 - smoothstep(ballSize, ballSize + 0.1, sqrt(dot(diff, diff)))) * CalcColor(i);\n    }\n    \n    // draw pusher\n    vec2 diff = pos - GetPusherPos();\n    fragColor += (1.0 - smoothstep(pusherSize + 1.6, pusherSize + 1.7, sqrt(dot(diff, diff)))) * vec4(0.3, 0.3, 1.0, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// classical Rungeâ€“Kutta method (RK4)\n// https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\n\n// rgba : x y vx vy\n\nvec2 GetPusherPos(){\n\treturn vec2(pusherRange * sin(float(iFrame) * pusherMoveFreq), pusherY);\n}\n\nvoid CalcNeighbour(vec4 self, vec4 other, out vec2 force){\n\tvec2 offset = other.rg - self.rg;\n    vec2 norm = normalize(offset);\n    float d = sqrt(dot(offset, offset)) - segLength;\n    force += norm * (d * elasticFactor + dot(other.ba - self.ba, norm) * chainDamping);\n}\n\nvoid CalcPusher(vec4 self, out vec2 force){\n    vec2 offset = GetPusherPos() - self.rg;\n    vec2 norm = normalize(offset);\n    float d = sqrt(dot(offset, offset));\n    force += pusherForce * norm * (smoothstep(pusherSize + ballSize, pusherSize + ballSize + 2.0, d) - 1.0);\n    force -= norm * dot(self.ba, norm) * pusherDamping * step(d, pusherSize + ballSize + 2.0);\n}\n\nvec2 Force_Common(vec4 self, vec4 prev, vec4 next){\n\tvec2 ret = vec2(0.0, gravity * ballMass);\n    CalcNeighbour(self, prev, ret);\n    CalcNeighbour(self, next, ret);\n    CalcPusher(self, ret);\n    return ret;\n}\n\nvec2 Force_Last(vec4 self, vec4 prev, vec4 next){\n\tvec2 ret = vec2(0.0, gravity * ballMass);\n    CalcNeighbour(self, prev, ret);\n    CalcPusher(self, ret);\n    return ret;\n}\n\n// Y' = F(Y)\nvec4 F(vec4 self, vec4 pre, vec4 next, int i){\n\tvec4 ret;\n    ret.rg = self.ba;\n    if (i == 0){\n    \tret.ba = vec2(0.0, 0.0);\n    }else if (i == nChain - 1){\n    \tret.ba = Force_Last(self, pre, next) / ballMass;\n    }else{\n    \tret.ba = Force_Common(self, pre, next) / ballMass;\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = int(floor(fragCoord.x));\n    int j = int(floor(fragCoord.y));\n    \n    if (iFrame == 0){\n    \tfragColor = vec4(float(i), -float(i), 0.0, 0.0);\n    }else{\n        // default : copy last frame's value\n        fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n        \n        // Y, k1, k2, k3 value of last frame\n        vec4 self = texture(iChannel0, vec2(fragCoord.x      , 0.5)/iResolution.xy);\n        vec4 prev = texture(iChannel0, vec2(fragCoord.x - 1.0, 0.5)/iResolution.xy);\n        vec4 next = texture(iChannel0, vec2(fragCoord.x + 1.0, 0.5)/iResolution.xy);\n        \n        vec4 self_1 = texture(iChannel0, vec2(fragCoord.x      , 1.5)/iResolution.xy);\n        vec4 prev_1 = texture(iChannel0, vec2(fragCoord.x - 1.0, 1.5)/iResolution.xy);\n        vec4 next_1 = texture(iChannel0, vec2(fragCoord.x + 1.0, 1.5)/iResolution.xy);\n        \n        vec4 self_2 = texture(iChannel0, vec2(fragCoord.x      , 2.5)/iResolution.xy);\n        vec4 prev_2 = texture(iChannel0, vec2(fragCoord.x - 1.0, 2.5)/iResolution.xy);\n        vec4 next_2 = texture(iChannel0, vec2(fragCoord.x + 1.0, 2.5)/iResolution.xy);\n        \n        vec4 self_3 = texture(iChannel0, vec2(fragCoord.x      , 3.5)/iResolution.xy);\n        vec4 prev_3 = texture(iChannel0, vec2(fragCoord.x - 1.0, 3.5)/iResolution.xy);\n        vec4 next_3 = texture(iChannel0, vec2(fragCoord.x + 1.0, 3.5)/iResolution.xy);\n        \n        // do RK4\n        if (mod(float(iFrame), 4.0) == 1.0){\n            if (j == 1){\n                // k1 = F(Yn) * dt\n            \tfragColor = F(self, prev, next, i) * delta;\n            }\n        }else if (mod(float(iFrame), 4.0) == 2.0){\n            if (j == 2){\n                // k2 = F(Yn + k1/2) * dt\n                fragColor = F(self + 0.5 * self_1, prev + 0.5 * prev_1, next + 0.5 * next_1, i) * delta;\n            }\n        }else if (mod(float(iFrame), 4.0) == 3.0){\n            if (j == 3){\n                // k3 = F(Yn + k2/2) * dt\n                fragColor = F(self + 0.5 * self_2, prev + 0.5 * prev_2, next + 0.5 * next_2, i) * delta;\n            }\n        }else{\n        \tif (j == 0){\n                // k4 = F(Yn + k3) * dt\n                vec4 self_4 = F(self + self_2, prev + prev_2, next + next_2, i) * delta;\n                // Yn+1 = Yn + (k1 + 2*k2 + 2*k3 + k4)/6\n                fragColor += (self_1 + 2.0 * self_2 + 2.0 * self_3 + self_4) / 6.0;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int nChain = 12;\nconst float delta = 0.05;\nconst float windowSize = 1.6;\nconst float ballMass = 1.0;\nconst float segLength = 1.414213562;\nconst float gravity = -10.0;\nconst float elasticFactor = 600.0;\nconst float chainDamping = 10.0;\nconst float ballSize = 0.65;\nconst float pusherSize = 1.5;\nconst float pusherForce = 2000.0;\nconst float pusherDamping = 10.0;\nconst float pusherRange = 12.0;\nconst float pusherY = -12.0;\nconst float pusherMoveFreq = 0.004;","name":"Common","description":"","type":"common"}]}