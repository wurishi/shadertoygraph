{"ver":"0.1","info":{"id":"Mdcyzj","date":"1519555393","viewed":329,"name":"Naive Buddhabrot","username":"soulsource","description":"First naive implementation of buddhabrot.\n\nEach fragement calculates the same orbit, and only increments its colour value if the orbit passes through it. Optimizations: Symmetry, and most orbits starting in main cardioid and bulb are skipped.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["fractal","buddhabrot","naive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The rendering speed is limited pretty much by WebGL's lack of random access storage.\n//Check out my compute-shader implementation to see how fast this could be:\n// https://github.com/soulsource/BuddhaShader\n\n//Nearly all tweakable values are in Buf A, head over there if you want to adjust things\n//or get this to run better on your hard- and software.\n\n//The only tweakable over here is the following line. If you want gamma correction,\n//uncomment and set the value.\n//#define gamma 1.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 brightness = texture(iChannel0, vec2(0.38046875,0.5)).rgb;\n   \n    vec3 c = texture(iChannel0, (fragCoord.xy / iResolution.xy)).rgb;\n\tvec3 d = texture(iChannel0, vec2((fragCoord.x / iResolution.x),1.0-(fragCoord.y / iResolution.y))).rgb;\n    // Output to screen\n#ifdef gamma\n    fragColor = vec4(pow((c+d)/sqrt(dot(brightness,brightness)),vec3(gamma)),1.0);\n#else\n    fragColor = vec4(((c+d)/sqrt(dot(brightness,brightness))),1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//How many orbits should be drawn per frame? \n//Setting this too high on low-end hardware will cause the browser to become sluggish,\n//but setting it so low that the shader runs at the 60 fps cap is a waste of time.\n#define orbitsPerFrame 100\n\n//How many iterations per orbit the code should do. Setting this higher will lead\n//to more pronounced features, but rendering will take longer.\n//See https://en.wikipedia.org/wiki/Buddhabrot for (post-processed...) example images.\n#define stepsPerOrbit 1000\n\n//Orbits will only be drawn if they diverge. For certain points it's easy to\n//tell that they won't lead to a visible orbit.\n//This defines how many pseudo-random starting points should be generated.\n//The code then selects one of them for which it's not known that it will not be drawn.\n//(This is implemented without branching, by the way).\n#define startPointAttempts 5\n\n//branching in shaders is \"slow\" on most hardware, so people tend to\n//avoid it. If branching can save a huge amount of instructions though,\n//it becomes favorable again. Depending on your steps per orbit setting, it\n//therefore might be faster to enable or disable the early-out branch.\n//To enable branching, uncomment the following define.\n//To disable branching, comment it out.\n#define branchInLoop\n\n#if __VERSION__ >= 300\n#define hashtype uint\n//WebGL 2 hash function based on https://stackoverflow.com/a/12996028/759323\n//This is slightly slower than what most other shaders on this site use, but\n//yields much better randomness from my experience.\nuint intHash(uint x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3bU;\n    x = ((x >> 16) ^ x) * 0x45d9f3bU;\n    x = (x >> 16) ^ x;\n    return x;\n}\nvec2 hash2(uint n, out uint hash)\n{\n    uint ih =intHash(n);\n    hash = intHash(ih);\n    uvec2 k = uvec2(ih,hash);\n    return vec2(k & uvec2(0xffffffffU))/float(0xffffffffU);\n}\n#else\n//WebGL 1 does not support bitwise operations.\n#define hashtype float\nvec2 hash2(float p, out float hash)\n{\n    //stolen from https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    hash = (p3.x + p3.y)*p3.z;\n\treturn fract(vec2(hash, (p3.x+p3.z)*p3.y));\n}\n#endif\n\nvec2 compSqr(in vec2 v)\n{\n \treturn vec2(v.x*v.x-v.y*v.y, 2.0*v.x*v.y);\n}\n\n//commented out, as no longer used\n//square root of a complex. Only one of the two results is output, the other one is \n//just the negative value.\n//vec2 compSqrt(in vec2 v)\n//{\n//    float angle = 0.5*atan(v.y,v.x);\n//    float norm = sqrt(dot(v,v));\n//    float sqrtnorm = sqrt(norm);\n//    return vec2(sqrtnorm*cos(angle),sqrtnorm*sin(angle));\n//}\n\nfloat isInMainCardioid(vec2 v)\n{\n    /*\n\tThe condition that a point c is in the main cardioid is that its orbit has \n\tan attracting fixed point. In other words, it must fulfill\n\tz**2 -z + v = 0 (z**2+v has a fixed point at z)\n\tand\n\td/dz(z**2+v) < 1 (fixed point at z is attractive)\n\tSolving these equations yields\n\tv = u/2*(1-u/2), where u is a complex number inside the unit circle\n\n\tSadly we only know v, not u, and inverting this formula leads to a complex square root.\n\tThis is the old code that uses the compSqrt method, which is rather slow...\n\n    vec2 toRoot = (vec2(1.0,0.0)-vec2(4.0)*v);\n    vec2 root = compSqrt(toRoot);\n    vec2 t1,t2;\n    t1=vec2(1,0)-root;\n    t2=vec2(1,0)+root;\n    float retval = step(dot(t1,t1),0.99999);\n    retval += step(dot(t2,t2),0.99999);\n    retval = min(retval,1.0);\n    return retval;\n\n\tOn several websites (and several mandelbrot-related shaders on ShaderToy) one can\n\tfind various faster formulas that check the same inequality.\n\tWhat however is hard to find is the actual derivation of those formulas,\n\tand they are not as trivial as one might think at first.\n\tThat's why I'm writing this lengthy comment, to preserve the scrap notes I made\n\tfor future reuse by myself and others...\n\n\tNow the actual derivation looks like this:\n\tWe start with the following line\n\tu = 1 +- sqrt(1-4*v) \n\tdon't mind the +-, that's just me being too lazy to check which solution is the right one\n\tWe know that |u| < 1, and we immediately square the whole beast to get rid of the root\n\tSome definitions: r := sqrt(1-4*v), z = 1-4*v\n\n\t1 > Re(u)**2+Im(u)**2 = (1 +- Re(r))**2+Im(r)**2\n\t1 > 1 +- 2*Re(r) + Re(r)**2+Im(r)**2\n\t1 > 1 +- 2*Re(r) + |r|**2\n\tFor complex values the square root of the norm is the same as the norm of the square root\n\t1 > 1 +- 2*Re(r) + |z|\n\t+-2*Re(r) > |z|\n\t4*Re(r)**2 > |z|**2\n\tThis step is now a bit arcane. If one solves the two coupled equations\n\t(a+i*b) = (x+i*y)*(x+i*y) component-wise for x and y,\n\tone can see that x**2 = (|a+i*b|+a)/2\n\tWith this follows\n\t2*(|z|+Re(z)) > |z|**2\n\t|z| > 1/2*|z|**2-Re(z)\n\t|z|**2 > (1/2*|z|**2-Re(z))**2\n\t\n\tAnd long story short, the result is the following few operations.\n    */\n    vec2 z = vec2(1.0,0.0)-4.0*v;\n    float zNormSqr = dot(z,z);\n    float rhsSqrt = 0.5*zNormSqr - z.x;\n    return step(rhsSqrt*rhsSqrt,zNormSqr);\n}\n\nfloat isInMainBulb(vec2 v)\n{\n    //The condition for this is that f(f(z)) = z\n    //where f(z) = z*z+v\n    //This is an equation of fourth order, but two solutions are the same as\n    //for f(z) = z, which has been solved for the cardioid above.\n    //Factoring those out, you end up with a second order equation.\n    //Again, the solutions need to be attractive (|d/dz f(f(z))| < 1)\n    //Well, after a bit of magic one finds out it's a circle around -1, radius 1/4.\n    vec2 shifted = v + vec2(1,0);\n    float sqrRadius = dot(shifted,shifted);\n    return step(sqrRadius,0.062499999);\n}\n\nfloat mandel(vec2 coords, vec2 minVal, vec2 maxVal)\n{\n    float cnt = 0.0;\n    vec2 value = vec2(0.0);\n    for(int i=0;i < stepsPerOrbit; ++i)\n    {\n        value = clamp(compSqr(value)+coords,vec2(-10000.0),vec2(10000.0));\n        vec2 valueUpper = vec2(value.x,abs(value.y));\n#if __VERSION__ >= 300\n        cnt += float(minVal.x < valueUpper.x && minVal.y < valueUpper.y && maxVal.x > valueUpper.x && maxVal.y > valueUpper.y);\n#else        \n        //don't know why, but this seems to be faster on WebGL 1.0, but slower on WebGL 2.0\n        vec2 stepped = step(minVal,valueUpper)*step(valueUpper,maxVal);\n        cnt += stepped.x*stepped.y;\n#endif\n\n#ifdef branchInLoop\n        if(dot(value,value) > 20.0)\n            return cnt;\n#endif\n    }\n    return step(4.0,dot(value,value))*cnt;\n}\n\nvec2 getStartValue(int seed)\n{\n    hashtype hash = hashtype(seed);\n\n    vec2 retval = vec2(0);\n    for(int i = 0; i <startPointAttempts; ++i)\n    {\n        vec2 random = hash2(hash,hash);\n        vec2 point = vec2(random.x * 3.5-2.5,random.y*1.55);\n        float useThisPoint =1.0-(isInMainBulb(point) + isInMainCardioid(point));\n        retval = mix(retval,point,useThisPoint);\n    }\n    return retval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 minVal = vec2(uv.x*3.5-2.5,abs(uv.y*2.0-1.0));\n    vec2 maxVal = minVal + vec2(3.5,2.0)/iResolution.xy;\n    \n    \n    float sum = 0.0;\n    for(int idx=0;idx < orbitsPerFrame;++idx)\n    {\n        int seed = (iFrame*orbitsPerFrame*2+idx*2+int(step(uv.y,0.5)));\n\n    \tvec2 startvalue = getStartValue(seed);\n    \tfloat man = mandel(startvalue,minVal,maxVal);\n        sum += man;\n    }\n    \n    \n    vec3 prev = texture(iChannel0, (fragCoord.xy / iResolution.xy)).rgb;\n    fragColor = vec4(prev + vec3(sum),1);\n}","name":"Buf A","description":"","type":"buffer"}]}