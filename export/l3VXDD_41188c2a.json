{"ver":"0.1","info":{"id":"l3VXDD","date":"1719988723","viewed":54,"name":"HW3/4-Hzzzch","username":"Hzzzch","description":"Turner, sunset sunrise with stars , meteors and a wormhole in the sky","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Hzzzch, 2024\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// based on \n// https:www.shadertoy.com/view/l3jXDV\n// https://www.shadertoy.com/view/lsVBWy\n#define PI 3.14159\n#define CELLS vec2(60.0,30.0)\n#define FALLERS 2.0\n#define FALLERHEIGHT 20.0\n#define angle PI/6.0\n#define REFLECTION_NUMBER 5\n\nvec3 colorA = vec3(0.306,0.445,0.912);\nvec3 colorB = vec3(1.000,0.508,0.224);\nvec3 colorC = vec3(0.007,0.115,0.300);\n\nvec3 colorD = vec3(0.231,0.359,0.625);\nvec3 colorE = vec3(0.003,0.011,0.180);\nvec3 colorF = vec3(0.098,0.172,0.345);\nvec3 colorG = vec3(0.388,0.360,0.685);\n\nvec3 colorSun = vec3(0.985,0.478,0.544);\nvec3 colorSuncrown = vec3(1.0, 0.8, 0.5);\nvec3 colorMoon = vec3(0.628,0.711,0.912);\nvec3 colorMooncrown = vec3(1.0, 1.0, 1.0);\n\nfloat crown = 0.2;\n\nfloat StarFieldThreshhold = 0.98;\nfloat xRate = -0.1;\nfloat yRate = 0.0;\n    \nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.1, pct, st.y) -\n          smoothstep( pct, pct+0.1, st.y);\n}\n\nfloat easeOutHalfQuart(float x) {\n\treturn 1.0 - pow(1.0 - x, 2.0);\n}\n\nfloat halfQuad(float x) {\n    return pow(cos(x * PI / 2.0), 2.5);\n}\n\nfloat easeInSine(float x) {\n\treturn 1.0 - cos((x * PI) / 2.0);\n}\n\nvec3 circle(vec2 uv, vec2 pos, float rad, vec3 color, vec3 colorcrown) {\n    float d = abs(length(pos-uv));\n    vec3 colorcircle = mix( color ,colorcrown, d/crown);\n\treturn colorcircle;\n}\n\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 36.0 );\n    float yhash = cos( x.y * 58.0 );\n    return fract( 400.0 * ( xhash + yhash ) );\n}\n\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 rand(vec2 uv) {\n    return floor(abs(mod(cos(\n        uv * 652.6345 + uv.yx * 534.375 +\n        iTime * 0.0000005 * dot(uv, vec2(0.364, 0.934))),\n     0.001)) * 16000.0);\n}\n\nfloat fallerSpeed(float col, float faller) {\n    return mod(cos(col * 363.435  + faller * 234.323), 0.1) * 1.0 + 0.3;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat random(vec2 uv)\n{\n\treturn fract(sin(dot(uv.xy, vec2(10., 78.233))) * 43758.5453123);    \n}\n\nmat3 rotation(float _angle)\n{\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3( c, -s, 0.,  s, c, 0.,  0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 colorday = vec3(0.0);\n    vec3 colornight = vec3(0.0);\n    vec3 pct = vec3(st.y);\n    vec2 uv = st; \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //让圆周期性运动\n\tvec2 center =vec2(0.5*cos(iTime)+0.7, 0.3*sin(iTime)-0.4);\n\tfloat radius = 0.2 ;\n        \n    //配置白天颜色\n    pct.r = easeOutHalfQuart(0.5-st.x) * smoothstep(0.8, 1.0, st.y);\n    pct.b = easeInSine(st.y);\n    pct.g = 0.0;\n    colorday = mix(colorB, colorA, pct);\n\n    pct = vec3(halfQuad(st.y)) * smoothstep(0.0, 0.4, st.y);\n    colorday = mix(colorday, colorA, pct);\n\n    pct = vec3(halfQuad(st.y)) * smoothstep(0., 0.2, st.y) * smoothstep(1.5, 0.0, st.x);\n    colorday = mix(colorday, colorC, pct);\n    \n    pct = vec3(plot(st, 0.25) * 0.3);\n    colorday = mix(colorday, colorC/2.0, pct);\n    \n    //配置夜晚颜色\n    \n    pct = vec3(st.y);\n    colornight = mix(colorD , colorE, pct);\n    \n    vec2 vSamplePos = fragCoord.xy + vec2( xRate * float( iFrame ), yRate * float( iFrame ) );\n\tfloat StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    colornight += vec3( StarVal );\n    \n    vec2 pq = (fragCoord/iResolution.y - iResolution.xy/iResolution.y*.5)*2.;\n    pq.x -= 0.5;\n    pq.y -= 0.7;\n    pq *= 5.;\n    \n    vec3 huv = vec3(pq, 0.);\n    huv *= rotation(iTime*.3);\n    \n    vec3 axisOrigin = vec3(0.1, 0.1, 1.);\n    vec3 axisDirection = vec3(normalize(vec2(2., 1.5)), 0.);\n    \n    for(int i = 0; i < REFLECTION_NUMBER; i++)\n    {\n        float offset = (3. * 2. / float(REFLECTION_NUMBER) ) * float(i);\n        float axisRotation = offset;\n    \tvec3 tuv = (huv - axisOrigin)* rotation(-axisRotation) ;\n    \tif(tuv.y < 0.)\n    \t{\n    \t\tvec3 invuv = tuv;\n        \tinvuv.y = -invuv.y;\n        \tinvuv = (invuv * rotation(axisRotation)) + axisOrigin;\n        \thuv = invuv;\n    \t}\n    }\n    \n    vec3 wormhole = vec3(texture(iChannel0, huv.xy - vec2(iTime *.1, 0.) ))* smoothstep(0.0 , 0.5, pq.x*pq.x+pq.y*pq.y) * smoothstep(3.0 , 0.0, (pq.x*pq.x+pq.y*pq.y));\n    colornight *= smoothstep(0.0 , 3.5, (pq.x*pq.x+pq.y*pq.y));\n    colornight += wormhole;\n    \n    vec2 mn = rotate2d(angle)*fragCoord/iResolution.xy;\n    vec2 pix = mod(mn, 0.1/CELLS);\n    vec2 cell = (mn - pix) * CELLS;\n    pix *= CELLS * vec2(0.8, 1.0) + vec2(0.1, 0.0);\n    \n    float c = texture(iChannel1, (pix) / 2.0).x;\n    \n    float b = 0.0;\n    for (float i = 0.0; i < FALLERS; ++i) {\n        float h = 1.0 - cell.x * 0.005 -\n            mod((iTime + i * 9000.0) * fallerSpeed(cell.y, i), FALLERHEIGHT);\n        float s = 1.0 - cell.y * 0.005 -\n            mod((iTime + i * 9000.0) * fallerSpeed(cell.x, i), FALLERHEIGHT);\n       \n        if (h > 0.0 && h < 0.5)\n            b += h;\n\n    }\n    colornight = (uv.y>-0.3)?  colornight+vec3(c * b)*0.3 : colornight;\n    \n    pct = vec3(halfQuad(st.y)) * smoothstep(0.0, 0.4, st.y);\n    colornight = mix(colornight, vec3(1.0), pct);\n\n    pct = vec3(halfQuad(st.y)) * smoothstep(0., 0.2, st.y) * smoothstep(1.5, 0.0, st.x);\n    colornight = mix(colornight, colorF, pct);\n    \n    pct = vec3(plot(st, 0.25) * 0.3);\n    colornight = mix(colornight, colorG/2.0, pct);\n    \n    //颜色合并\n    vec3 background = colorday*(1.0+sin(iTime))/2.0+colornight*(1.0-sin(iTime))/2.0;\n    \n    //加上圆\n    vec3 layer1 = background;\n    vec3 layer2 = circle(uv, center, radius, colorSun*(1.0+sin(iTime))/2.0 , colorSuncrown);\n    vec3 layer3 = circle(uv, center, radius, colorMoon*(1.0-sin(iTime))/2.0 , colorMooncrown);\n    \n    vec3 layersun = layer2 +layer3;\n    \n    //处理颜色混合\n    vec3 layerall = mix (layer1, layersun, smoothstep(radius + crown, radius, length(uv-center)/crown))-0.2;\n    \n    fragColor = vec4(layerall, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}