{"ver":"0.1","info":{"id":"lccXDl","date":"1714686804","viewed":163,"name":"Mouse interaction on feedback","username":"abdt","description":"Mouse interaction on noisy feedback loop.\nFeedback effects increase when mouse is near center.\nScale pivot of the feedback loop is mapped to mouse pos.\nSimplex noise and mouse affect displacement in the feedback loop.\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["mouse","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 bufferB_result = texture(iChannel1, uv ).rgba;\n    fragColor = bufferB_result;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 WHITE = vec3(1., 1., 1.);\n\nvec4 drawCircle(vec3 color, vec2 fragCoord, vec2 center, float r, float smooth_ratio)\n{\n    vec2 circle_uv = fragCoord/iResolution.xy - center/iResolution.xy;\n    circle_uv.x *= iResolution.x / iResolution.y;\n    float d = length(circle_uv);\n    float circle = 0.;\n    if (smooth_ratio > 0.) {\n        circle = smoothstep(r, (1.-smooth_ratio)*r, d);\n    }\n    else {\n        circle = step(d, r);\n    }\n    return vec4(circle*color.r, circle*color.g, circle*color.b, circle);\n    \n}\n\nvec4 compOver(vec4 front, vec4 back)\n{\n    vec4 composite = vec4(0.);\n    composite.rgb = front.rgb + back.rgb*(1.-front.a);\n    composite.a = clamp(front.a + back.a, 0., 1.);\n    return composite;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 im_uv = fragCoord/iResolution.xy;\n    \n    vec2 circle_uv = im_uv - iMouse.xy/iResolution.xy;\n    circle_uv.x *= iResolution.x / iResolution.y;\n   \n    float d = length(circle_uv);\n    vec4 white_circle1 = drawCircle(WHITE, fragCoord, vec2(0.5, 0.6)*iResolution.xy, 0.2, 0.);\n    vec4 white_circle2 = drawCircle(WHITE, fragCoord, vec2(0.5, 0.4)*iResolution.xy, 0.2, 0.);\n\n    vec4 col = compOver(white_circle1, white_circle2);\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float EDGE_STRENGTH = 0.1;\nconst vec3 WHITE = vec3(1., 1., 1.);\nconst vec2 MASK_RES = vec2(2048., 3072.);\nconst bool USE_CUSTOM_IMAGE = false;\n\nfloat lookup(sampler2D image, vec2 p, float dx, float dy, float strength)\n{\n    vec2 uv = (p.xy + vec2(dx , dy) * strength) / iResolution.xy;\n    vec4 c = texture(image, uv.xy);\n\t\n\t// return as luma\n    return 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n}\n\nfloat edge(sampler2D image, vec2 p, float strength, vec2 pos_uv)\n{\n    p += pos_uv*iResolution.xy;\n    if (USE_CUSTOM_IMAGE) {\n        p -= 0.5;\n        float mask_ratio = MASK_RES.x / MASK_RES.y;\n        float win_ratio = iResolution.x / iResolution.y;\n        p.x -= 0.5 * (iResolution.x - iResolution.y*mask_ratio);\n        p.x *= win_ratio / mask_ratio;\n        // Correct shift in x\n    }\n    \n    // simple sobel edge detection\n    float gx = 0.0;\n    gx += -1.0 * lookup(image, p, -1.0, -1.0, strength);\n    gx += -2.0 * lookup(image, p, -1.0,  0.0, strength);\n    gx += -1.0 * lookup(image, p, -1.0,  1.0, strength);\n    gx +=  1.0 * lookup(image, p,  1.0, -1.0, strength);\n    gx +=  2.0 * lookup(image, p,  1.0,  0.0, strength);\n    gx +=  1.0 * lookup(image, p,  1.0,  1.0, strength);\n    \n    float gy = 0.0;\n    gy += -1.0 * lookup(image, p, -1.0, -1.0, strength);\n    gy += -2.0 * lookup(image, p,  0.0, -1.0, strength);\n    gy += -1.0 * lookup(image, p,  1.0, -1.0, strength);\n    gy +=  1.0 * lookup(image, p, -1.0,  1.0, strength);\n    gy +=  2.0 * lookup(image, p,  0.0,  1.0, strength);\n    gy +=  1.0 * lookup(image, p,  1.0,  1.0, strength);\n    float g = gx*gx + gy*gy;\n    return g;\n}\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nvec4 drawCircle(vec3 color, vec2 fragCoord, vec2 center, float r, float smooth_ratio)\n{\n    vec2 circle_uv = fragCoord/iResolution.xy - center/iResolution.xy;\n    circle_uv.x *= iResolution.x / iResolution.y;\n    float d = length(circle_uv);\n    float circle = 0.;\n    if (smooth_ratio > 0.) {\n        circle = smoothstep(r, (1.-smooth_ratio)*r, d);\n    }\n    else {\n        circle = step(d, r);\n    }\n    return vec4(circle*color.r, circle*color.g, circle*color.b, circle);\n    \n}\n\n\nvec4 compOver(vec4 front, vec4 back)\n{\n    vec4 composite = vec4(0.);\n    composite.rgb = front.rgb + back.rgb*(1.-front.a);\n    composite.a = clamp(front.a + back.a, 0., 1.);\n    return composite;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 saturate(vec3 color, float exponent)\n{\n    vec3 result = clamp(pow(color, vec3(exponent)), 0.0, 1.0);\n    return result;\n}\n\nvec4 feedbackBlock(vec4 im_base, vec2 fragCoord, vec2 pos_uv)\n{\n    float center_dist = distance(iMouse.xy/iResolution.xy, pos_uv);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // adapt scale from mouse position\n    vec2 scale = vec2(mix(1.01, 1., center_dist));\n    \n    // add offset to the pivot to get interaction from mouse pos \n    vec2 scale_pivot;\n    if (iMouse.x/iResolution.x < pos_uv.x)\n        scale_pivot.x = pos_uv.x + center_dist;\n    else\n        scale_pivot.x = pos_uv.x - center_dist;\n    scale_pivot.x = pos_uv.x + 1.5*(pos_uv.x - iMouse.x/iResolution.x);\n    scale_pivot.y = pos_uv.y + 1.5*(pos_uv.y - iMouse.y/iResolution.y);\n    // place uv coordinates, scale and pivot\n    uv = (uv-scale_pivot)/scale+scale_pivot;\n    // add some displace noise\n    vec2 uv_noise = uv;\n    uv_noise.x *= iResolution.x/iResolution.y;\n    vec2 noise_color = vec2(0.0);\n    \n    // Apply noise displace\n    // Scale the space in order to see the function\n    uv_noise *= 7.;\n    // time ramps\n    float ramp = iTime*0.1;\n    vec2 vel = vec2(ramp, ramp + 123456.);\n    noise_color = vec2(snoise(uv_noise + vec2(vel.x, 0.)), snoise(uv_noise + vec2(0., vel.y)));\n    noise_color *= 0.003;\n    uv.xy += noise_color.rg;\n    \n    // mouse also alters uv map\n    vec2 mouse_mask = drawCircle(WHITE, fragCoord, iMouse.xy, 0.4, 1.5).rg;\n    mouse_mask.rg *= fragCoord/iResolution.xy - pos_uv;\n    uv.xy += 0.07*mouse_mask.rg;\n    \n    \n    // load texture on uv coords and apply color adjustments\n    vec4 old = texture(iChannel1, uv).rgba;\n    old = vec4(old.r * 0.962, old.g * 0.957, old.b * 0.951, old.a);\n    float gain = clamp(mix(0.985, 0.95, center_dist), 0., 1.);\n    old *=gain;\n    \n    // go to hsv representation\n    vec3 hsv = rgb2hsv(old.rgb);\n    // Hue shift\n    hsv.x += clamp(mix(30./360., -0.2, center_dist), 0., 50./360.);\n    hsv.y *= clamp(mix(1.22, 0., center_dist), 0., 1.22);\n    hsv.z *= 1.03;\n    // back to rgb repr\n    old.rgb = hsv2rgb(hsv);\n    \n    float imbase_gain = clamp(mix(3., -1., center_dist), 0., 1.);\n    \n    vec4 result = clamp(compOver(imbase_gain * im_base, old), 0., 1.);\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos_uv = vec2(0.5, 0.5);\n    \n    vec4 edge_from_buffA = vec4(edge(iChannel0, fragCoord, EDGE_STRENGTH, -pos_uv + 0.5));\n    \n    vec4 col = edge_from_buffA;\n    col *= 4.;\n    col = clamp(col, 0., 1.);\n    \n    col = feedbackBlock(col, fragCoord, pos_uv);\n        \n    fragColor = vec4(col);\n}","name":"Buffer B","description":"","type":"buffer"}]}