{"ver":"0.1","info":{"id":"lc3SWr","date":"1713782573","viewed":96,"name":"lights fracturing","username":"akr51","description":"sphere taken mod in 3-space ray marching context with symmetry about y axis. Applied fracturing on a second ray marching of the scene to overlay effect by small scalar on glow. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fracturing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SURFD 0.0001\n#define MAXLM 80.0\n#define ITERATIONS 90\n\n\nmat2 rt(float t)\n{\n\n\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n\n}\n\nfloat glw(float d, float r, float i)\n{\n\t\n    \n    return pow(r / max(d, 0.0001), i);\t\n\n}\n\n\nfloat map(vec3 sp)\n{\n    \n    \n    sp.z -= 1.0;\n    sp.y += 0.7;\n    \n    sp.xz *= rt(iTime);\n    sp = mod(sp + iTime, 14.0) - 7.0;\n    sp.z += sin(sp.z * 5.0 + iTime)  * 0.05;\n    sp.x += cos(sp.x * 7.0 + iTime)  * 0.05;\n    sp.y += sin(sp.y * 11.0 + iTime) * 0.05;\n    return length(sp) - 0.2;\n\n}\n\n\nfloat mrch(vec3 ro, vec3 rd, inout float g)\n{\n\n\n    float d0 = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; i++)\n    {\n    \n        \n        vec3 sp = ro + rd * d0;\n        float ds = map(sp);\n        g += glw(ds, 0.04, 1.5) * length(ro) * 7.2;\n        d0 += ds * 0.9;\n        if (d0 > MAXLM || abs(ds) < SURFD)\n        {\n        \n            \n            break;\n        \n        }\n        \n    \n    }\n    \n    return d0;\n\n}\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n    \n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n\n\n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    vec2 uvf = vec2(length(uv), atan(uv.y, uv.x));\n    uvf = fract(uv * 2.0) - 0.5;\n    \n    uvf.x = abs(uvf.x);\n    \n    uv.x += sin(uv.x * 5.0 + iTime) * 0.1;\n    \n    uv.x = abs(uv.x);\n    \n    vec3 ro = normalize(vec3(0.0, 1.1, -1.0));\n    vec3 fx = vec3(sin(iTime) * 0.1, cos(iTime) * 0.1, 0.0);\n    vec3 rd = dir(uv, ro, fx);\n    vec3 rdf = dir(uvf, ro, fx);\n    \n    \n    float f = 0.0;\n    float g = 0.0;\n    float gf = 0.0;\n    \n    float d0 = mrch(ro, rd, g);\n    float f0 = mrch(ro, rdf, gf);\n    \n    float t = clamp((d0 - 4.6) / (SURFD - 2.6), 0.0, 1.0);\n    f = smoothstep(0.0, 1.0, t);\n   \n    f += g * 2.0 + gf * 0.04;\n    \n    c_out = vec4(vec3(f), 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}