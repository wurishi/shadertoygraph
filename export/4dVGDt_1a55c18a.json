{"ver":"0.1","info":{"id":"4dVGDt","date":"1457108226","viewed":1712,"name":"Approx Analytic Area Light","username":"neoragex2002","description":"modified from 1) dys129's demo (https://www.shadertoy.com/view/4tXSR4)  and be updated to 2) pascal's recent approx method (http://pascal.lecocq.home.free.fr/publications/lecocq_i3D2016_specularAreaLighting.pdf)","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define MAT_ID_LIGHT 3.\n#define saturate(a) clamp(a, 0.,1.)\n\n/*\nSet USE_APPROX to 0 to use reference solution (Arvo 1995)\nSet USE_APPROX to 1 to use Siggraph 2015: Accurate Analytic Approximations for Real-Time Specular Area Lighting\n*/\n#define USE_APPROX 1\n\n//0 - for triangle area light\n//1 - for quad area light\n#define AREA_LIGHT_TYPE 1\n\nvec3 lightClr = vec3(0.7, 0.0, 0.0);\n\n//------------------------------------------------------------\n//approx method\n#define PEARSON_VII 1\n\n//specular power\n#define ODD 0\nconst int N = 100;\n\n//------------------------------------------------------------\n#if AREA_LIGHT_TYPE==0\n#define NUM_VERTS 3\nvec3 get_arr(int i)\n{\n\t//right handï¼Œ+Y up\n\tif (i == 0) return vec3(0.1, 0.01, 0.01);\n\tif (i == 1) return vec3(-0.5, 2.0, 0.02);\n\tif (i == 2) return vec3(0.5, 2.0, 0.03);\n\n\treturn vec3(0.);\n}\n#elif AREA_LIGHT_TYPE==1\n#define NUM_VERTS 6\nvec3 get_arr(int i)\n{\n\t//right handï¼Œ+Y up\n\tif (i == 0) return vec3(1.0, 0.1, 0.0);\n\tif (i == 1) return vec3(-1.0, 0.1, 0.0);\n\tif (i == 2) return vec3(-1.0, 2.0, 0.0);\n\n\tif (i == 5) return vec3(-1.0, 2.0, 0.0);\n\tif (i == 3) return vec3(1.0, 2.0, 0.0);\n\tif (i == 4) return vec3(1.0, 0.1, 0.0);\n\n\treturn vec3(0.);\n}\n#endif\n\n\nfloat plane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sphere(vec3 ro, float r)\n{\n\treturn length(ro) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 ba = b - a; vec3 pa = p - a;\n\tvec3 cb = c - b; vec3 pb = p - b;\n\tvec3 ac = a - c; vec3 pc = p - c;\n\tvec3 nor = cross(ba, ac);\n\n\treturn sqrt(\n\t\t(sign(dot(cross(ba, nor), pa)) +\n\t\tsign(dot(cross(cb, nor), pb)) +\n\t\tsign(dot(cross(ac, nor), pc)) < 2.0)\n\t\t?\n\t\tmin(min(\n\t\tdot2(ba*clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),\n\t\tdot2(cb*clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),\n\t\tdot2(ac*clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc))\n\t\t:\n\t\tdot(nor, pa)*dot(nor, pa) / dot2(nor));\n}\n\nvec2 scene(vec3 ro)\n{\n\tvec2 polygon = vec2(1000.0, 0.);\n\n\tfor (int i = 0; i < NUM_VERTS; i += 3)\n\t{\n\t\tpolygon = opU(polygon, vec2(udTriangle(ro, get_arr(i), get_arr(i + 1), get_arr(i + 2)), MAT_ID_LIGHT));\n\t}\n\tvec2 pl0 = vec2(plane(ro), 0.0);\n\n\treturn opU(polygon, pl0);\n}\n\nvec4 getMaterial(float mat_id)\n{\n\tif (mat_id == 0.0) return vec4(1.0, 1.0, 1.0, 0.0);\n\telse if (mat_id == 1.0) return vec4(0.0, 1.0, 0.0, 0.0);\n\telse if (mat_id == 2.0) return vec4(1.0, 0.0, 0.0, 0.0);\n\telse if (mat_id == MAT_ID_LIGHT) return vec4(1.0, 1.0, 1.0, 0.0);\n\treturn vec4(0.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec3 eps = vec3(0.01, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tscene(pos + eps.xyy).x - scene(pos - eps.xyy).x,\n\t\tscene(pos + eps.yxy).x - scene(pos - eps.yxy).x,\n\t\tscene(pos + eps.yyx).x - scene(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\n\nfloat cosine_sine_power_integral_sum(float theta, float cos_theta, float sin_theta,\n\tint n, float a, float b)\n{\n\tfloat f = a*a + b*b;\n\tfloat g = a*cos_theta + b*sin_theta;\n\tfloat gsq = g*g;\n\tfloat asq = a*a;\n\tfloat h = a*sin_theta - b*cos_theta;\n\tfloat T, Tsum;\n\tfloat l, l2;\n\tint start;\n\n\t/* initial conditions for recurrence */\n\t//if (n&1) {\n\t/*T = h+b;\n\tl = gsq*h;\n\tl2 = b*asq;\n\tstart = 1;*/\n\t/*} else { */\n\n\tT = theta;\n\tl = g*h;\n\tl2 = b*a;\n\tstart = 0;\n\t//}\n\n\tTsum = T;\n\tfor (int i = 2; i <= N - 1; i += 2)\n\t{\n\t\tT = (l + l2 + f*(float(i) - 1.)*T) / float(i);\n\t\tl *= gsq;\n\t\tl2 *= asq;\n\t\tTsum += T;\n\t}\n\treturn Tsum;\n}\n\nfloat P(float theta, float a)\n{\n\treturn 1.0 / (1.0 + a * theta * theta);\n}\n\n#if PEARSON_VII==1\nfloat L(float theta, float b)\n{\n\tfloat ret = 1. / (1. + b * theta * theta);\n\treturn ret * ret;\n}\n#endif\n\nfloat I_org(float theta, float c, float n) //eq.(6)\n{\n\tfloat cCos = c * cos(theta);\n\n#if ODD==1\n\treturn (pow(cCos, n + 2.) - cCos) / (cCos * cCos - 1.);\n#else\n\treturn (pow(cCos, n + 2.) - 1.0) / (cCos * cCos - 1.);\n#endif\t\n}\n\nfloat evaluateXW(float c, float n)\n{\n#if ODD==1\n\treturn PI / 3. * pow(1. - pow(c - c / n, 2.), 0.5);\n#else\n\treturn PI / 4. * pow(1. - pow(c - c / (n - 1.), 2.5), 0.45);\n#endif\n}\n\nfloat shd_edge_contribution_approx(vec3 v0, vec3 v1, vec3 n, int e)\n{\n\tfloat f;\n\tfloat cos_theta, sin_theta;\n\tvec3 q = cross(v0, v1); //ni\n\tsin_theta = length(q);\n\tq = normalize(q);\n\tcos_theta = dot(v0, v1);\n\n\tif (e == 1) {\n\t\tf = acos(cos_theta);\n\t}\n\telse {\n\t\tvec3 w;\n\t\tfloat theta;\n\t\ttheta = acos(cos_theta);\n\t\tw = cross(q, v0); //ti\n\n\t\tfloat a = dot(v0, n);\n\t\tfloat b = dot(w, n);\n\t\tfloat x = theta; //arc length\n\t\tfloat delta = atan(b, a);\n\t\tfloat c = sqrt(a*a + b*b);\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat xw = evaluateXW(c, float(N));\n\n\t\t//-------------------------------------------------------------------------------------------\n#if ODD==1\n\t\tfloat Imin = 0.;\n\t\tfloat Imax = (pow(c, float(N) + 2.) - c) / (c*c - 1.);\n#else\n\t\tfloat Imin = 1.;\n\t\tfloat Imax = (pow(c, float(N) + 2.) - 1.) / (c*c - 1.);\n#endif\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat Io = I_org(xw, c, float(N)); //I(xw)\n\n\t\t//-------------------------------------------------------------------------------------------       \n\t\tfloat yw = (Io - Imin) / (Imax - Imin);\n\t\tfloat A = (1. - yw - 4. * xw * xw / (PI * PI)) / (yw * xw * xw);\n\n\t\t//DEBUG snippet:\n\t\t//float A = 1. / (xw*xw) - 8. / (PI*PI); //for even\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat integral_1 = 1. / sqrt(A) * atan(sqrt(A) * x, (1. - A * delta * (x - delta)));\n\n#if PEARSON_VII==1\n\t\tfloat B = A / 2.;\n\t\tfloat integral_2 = x / (2. * (B + x*x)) + atan(x, sqrt(B)) / (2. * sqrt(B));\n\n\t\t//DEBUG snippet:\n\t\t//float xw0 = PI/4.; //how to decide?\n\t\t//float xtail = xw + 0.3946 * xw0 * (1. - pow(1. - xw/xw0, 12.));       \n\t\t//float alpha = (L(xtail,B) - I_org(xtail, c, float(N))) / (L(xtail, B) - P(xtail, A));\n\n\t\tfloat alpha = 0.9; //hardcoded for now...may be incorrect, but visually ok...\n#endif\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat Pmin = P(PI / 2., A);\n\t\tfloat Pmax = P(0., A);\n\t\tfloat s1 = (Imax - Imin) / (Pmax - Pmin);\n\t\tfloat t1 = Imin - s1 * Pmin;\n\n#if PEARSON_VII==1\t\n\t\tfloat LPmin = L(PI / 2., B);\n\t\tfloat LPmax = L(0., B);\n\t\tfloat s2 = (Imax - Imin) / (LPmax - LPmin);\n\t\tfloat t2 = Imin - s2 * LPmin;\n#endif\n\n#if PEARSON_VII==1\t\t\n\t\tf = alpha * (s1*integral_1 + t1*x) + (1. - alpha) * (s2*integral_2 + t2*x);\n#else\n\t\tf = s1*integral_1 + t1*x;\n#endif\t\n\n\t\tf = max(theta, f);\n\t}\n\n\treturn f*dot(q, n);\n}\n\nfloat shd_edge_contribution(vec3 v0, vec3 v1, vec3 n, int e)\n{\n\tfloat f;\n\tfloat cos_theta, sin_theta;\n\tvec3 q = cross(v0, v1); //ni\n\tsin_theta = length(q);\n\tq = normalize(q);\n\tcos_theta = dot(v0, v1);\n\n\tif (e == 1) {\n\t\tf = acos(cos_theta);\n\t}\n\telse {\n\t\tvec3 w;\n\t\tfloat theta;\n\t\ttheta = acos(cos_theta);\n\t\tw = cross(q, v0);\n\t\tf = cosine_sine_power_integral_sum(theta, cos_theta, sin_theta, e - 1, dot(v0, n), dot(w, n));\n\t}\n\treturn f * dot(q, n);\n}\n\n\n\nvoid seg_plane_intersection(vec3 v0, vec3 v1, vec3 n, out vec3 q)\n{\n\tvec3 vd;\n\tfloat t;\n\tvd = v1 - v0;\n\tt = -dot(v0, n) / (dot(vd, n));\n\tq = v0 + t * vd;\n}\n\nfloat shd_polygonal(vec3 p, vec3 n, bool spc)\n{\n\tint i, i1;\n\tint J = 0;\n\tfloat sum = 0.;\n\tvec3 ui0, ui1; /* unnormalized vertices of edge */\n\tvec3 vi0, vi1; /* unit-length vector vertices of edge */\n\tint belowi0 = 1, belowi1 = 1; /* flag for whether last vertex was below pointâ€™s \"horizon\" */\n\t/* find first vertex above horizon */\n\tfor (int j = 0; j < NUM_VERTS; j++) {\n\t\tvec3 u;\n\t\tu = get_arr(j) - p;\n\t\tif (dot(u, n) >= 0.0) {\n\t\t\tui0 = u;\n\t\t\tvi0 = u;\n\t\t\tvi0 = normalize(vi0);\n\t\t\tbelowi0 = 0;\n\t\t\tJ = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (J >= NUM_VERTS) return 0.;\n\n\ti1 = J;\n\tfor (int i = 0; i < NUM_VERTS; i++)\n\t{\n\t\ti1++;\n\t\tif (i1 >= NUM_VERTS) i1 = 0;\n\n\t\tui1 = get_arr(i1) - p;\n\t\tbelowi1 = int(dot(ui1, n) < 0.);\n\n\t\tif (belowi1 == 0) {\n\t\t\tvi1 = ui1;\n\t\t\tvi1 = normalize(vi1);\n\t\t}\n\n\t\tif (belowi0 != 0 && belowi1 == 0) {\n\t\t\tvec3 vinter;\n\t\t\tseg_plane_intersection(ui0, ui1, n, vinter);\n\t\t\tvinter = normalize(vinter + 0.01);\n\t\t\tsum += shd_edge_contribution(vi0, vinter, n, 1);\n\t\t\tvi0 = vinter;\n\t\t}\n\t\telse if (belowi0 == 0 && belowi1 != 0) {\n\t\t\tseg_plane_intersection(ui0, ui1, n, vi1);\n\t\t\tvi1 = normalize(vi1);\n\t\t}\n\t\tint K = spc ? N : 1;\n#if USE_APPROX\n\t\tif (belowi0 == 0 || belowi1 == 0) sum += shd_edge_contribution_approx(vi0, vi1, n, K);\n#else\n\t\tif (belowi0 == 0 || belowi1 == 0) sum += shd_edge_contribution(vi0, vi1, n, K);\n#endif\n\n\t\tui0 = ui1;\n\t\tvi0 = vi1;\n\t\tbelowi0 = belowi1;\n\t}\n\n\tif (sum < 0.) sum = -sum;\n\n\treturn sum / (2.0 * PI);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t// vec2 mo = -1.0 + 2.0 * iMouse.xy/iResolution.xy;\n\n\n\tvec3 ro = vec3(6.0 * sin(iTime), 2.2, 6.0 * cos(iTime));\n\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\n\n\tfloat t = 1.0;\n\tvec4 clr = vec4(0.0);\n\tfor (int i = 0; i < 64; i++)\n\t{\n\t\tvec2 hit = scene(ro + t*rd);\n\t\tfloat eps = 0.001;\n\t\tif (hit.x < eps)\n\t\t{\n\t\t\tvec4 mat = getMaterial(hit.y);\n\t\t\tif (hit.y == MAT_ID_LIGHT)\n\t\t\t{\n\t\t\t\tclr.rgb = lightClr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tvec3 nrm = calcNormal(pos);\n\t\t\tvec3 rfl = reflect(rd, nrm);\n\t\t\tvec3 test_out;\n\t\t\tfloat diff = shd_polygonal(pos, nrm, false);\n\n\n\t\t\tfloat spc = saturate(shd_polygonal(pos, rfl, true));\n\t\t\tclr.rgb = lightClr * (diff + spc) * mat.rgb;\n\t\t\tbreak;\n\t\t}\n\n\t\tt += max(hit.x, 0.001);\n\t}\n\n\tclr.rgb = pow(clr.rgb, vec3(1.0 / 2.2));\n\n\tfragColor = clr;\n}","name":"Image","description":"","type":"image"}]}