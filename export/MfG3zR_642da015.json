{"ver":"0.1","info":{"id":"MfG3zR","date":"1712317162","viewed":54,"name":"voronoi when polar","username":"yufengjie","description":"aaaa","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution 10.\n#define angleGap (PI / 6.)\n#define distGap 2.\n#define gap vec2(angleGap, distGap)\n\nfloat angleGapMax = PI * 2. / angleGap;\nfloat distGapMax = resolution * 2. / distGap;\n\n\nfloat plotCircle(vec2 uv, vec2 c, float r) {\n    float cir = length(uv-c)-r;\n    return smoothstep(0.01, 0., cir);\n}\n\nvec2 getPos(vec2 uvi){\n    float x = sin(uvi.x) * 0.5 + 0.5;\n    float y = noise( (fract(iTime / 10.) > 0.5 ? uvi.x : uvi.y) + iTime);\n    return vec2(mod(y,2.)==0.?x:-x,y);\n}\n\nfloat dist_polar(vec2 a, vec2 b) {\n    return sqrt(a.y*a.y+b.y*b.y-2.*a.y*b.y*cos(a.x-b.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y * resolution;\n    vec3 c_fin = vec3(1.);\n    \n    vec2 uv2 = vec2(atan(uv.y,uv.x) + PI, length(uv));// atan求得角度是正负各半，需要+PI来连续化\n    vec2 uv3 = uv2 / gap; // 使用gap来归一化（0-1-2-3的形式）uv3\n\n    float pix = resolution / iResolution.y;\n    \n    #if 0\n        vec3 color = vec3(1.);\n        float xi = floor(uv3.x);\n        if(xi==0.) { color = vec3(1.,0.,0.); }\n        if(xi==1.) { color = vec3(0.,1.,0.); }\n        if(xi==2.) { color = vec3(0.,0.,1.); }\n        if(xi==3.) { color = vec3(1.,1.,0.); }\n        if(xi==4.) { color = vec3(1.,0.,1.); }\n        if(xi==5.) { color = vec3(0.,1.,1.); }\n        if(xi==6.) { color = vec3(.5,.5,1.); }\n        if(xi==7.) { color = vec3(.5,1.,.5); }\n\n        \n        float g1 = fract(uv3.x);\n        float b1 = smoothstep(0.1, 0., g1) + smoothstep(0.9, 1., g1);\n        \n        float g2 = fract(uv3.y);\n        float b2 = smoothstep(0.05, 0., g2) + smoothstep(0.95, 1., g2);\n        \n        float b = b1 + b2;\n        c_fin = mix(c_fin, color,b);\n        \n        float circle = plotCircle(uv2, (floor(uv3)+0.5)*gap, 0.1);\n        c_fin = mix(c_fin, color, circle);\n    #endif\n    \n    \n    float dist_min = resolution; // 可以把dist_min理解成当前格子（“线程”）的绘制变量\n    \n    \n    vec2 range = vec2(angleGapMax, distGapMax); // x=1代表1 * angelGap,y=1代表 1 * distGap\n\n    \n    vec2 cur = uv3;\n\n    // 当x==0 & y==0时，是计算了当前格子像素位置到当前格子特征点坐标的距离\n    for(float x=-range.x/2.;x<=range.x/2.;x+=1.) {\n        for(float y=0.;y<=range.y;y+=1.) {\n        \n            vec2 nei = cur + vec2(x,y); // 邻居像素坐标\n            vec2 nei_coor = floor(nei); \n            nei_coor = mod(nei_coor, range);// 越界\n            //if(nei_coor.x < 0.) { nei_coor.x = angleGapMax - nei_coor.x; }\n\n                \n            vec2 nei_point = getPos(nei_coor) * range; // 邻居格子特征点位置\n            float dist = dist_polar(cur*gap, nei_point*gap); // 在计算距离时，要用原始极坐标系!!!!\n            dist_min = min(dist_min, dist); // 当前格子像素针对邻居特征点确定距离\n            \n            \n            // 邻居格子越界,所以需要在当前格子判断邻居格子的像素到邻居特征点距离\n            //float dist2 = dist_polar(nei, nei_point);\n            //dist_min = min(dist_min, dist2);\n            \n        }\n    }\n    \n    vec2 cur_coor = floor(cur);\n\n    float dist_min_normal = dist_min / (resolution);\n    vec3 color = vec3(0.);\n    c_fin = mix(c_fin, color, dist_min_normal);\n    \n\n    fragColor = vec4(c_fin,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\nfloat random(float x) {\n    float v = sin(x) * 4523.1254 + 1234.1313;\n    return v * 0.5 + 0.5;\n}\nvec2 random( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n\n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n  float n = dot(i, step);\n\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix(hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix(hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix(hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix(hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nvec3 palette(float t) {\n  vec3 a = vec3(0.731, 1.098, 0.192);\n  vec3 b = vec3(0.358, 1.090, 0.657);\n  vec3 c = vec3(1.077, 0.360, 0.328);\n  vec3 d = vec3(0.965, 2.265, 0.837);\n  return a + b * cos(6.28318 * (c * t + d));\n}","name":"Common","description":"","type":"common"}]}