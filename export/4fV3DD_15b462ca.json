{"ver":"0.1","info":{"id":"4fV3DD","date":"1725918777","viewed":21,"name":"raypassreturn3d test 9873098q175","username":"SwissCheez84","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 pos; //position\n    vec3 dir; //direction (normalized)\n};\n\nconst vec2 textureStretch = vec2(1, 1);\n\nconst float glassIOR = 1.5;\n\nstruct RayPass {\n    float enterDepth;\n    vec3 enterNormal;\n    float exitDepth;\n    vec3 exitNormal;\n    bool entered;\n    bool exited;\n    float nearEdge;\n    bool onEdge;\n    bool refractive;\n    bool reflective;\n};\n\nconst RayPass BlankRayPass = RayPass(\n    0., vec3(0), 0., vec3(0), false, false, 0., false, false, false\n);\n\nstruct Material {\n    vec3 color;\n};\n\nvec3 move(Ray r, float d) {\n    return r.dir * d + r.pos;\n}\n\n// transformations\nmat2 rot2D(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nRay translate(Ray r, vec3 pos) {\n    return Ray(\n        r.pos - pos,\n        r.dir\n    );\n}\n\nRayPass passCircle(Ray r, float radius) {\n    RayPass rayPass = BlankRayPass;\n    float d = dot(-r.dir, r.pos);\n    float l = length(move(r, d));\n    float a = cos(asin(l / radius)) * radius;\n    rayPass.enterDepth = d - a;\n    rayPass.enterNormal = normalize(move(r, rayPass.enterDepth));\n    rayPass.exitDepth = d + a;\n    rayPass.exitNormal = normalize(move(r, rayPass.exitDepth));\n    rayPass.entered = l <= radius;\n    rayPass.exited = rayPass.entered;\n    rayPass.nearEdge = radius - l;\n    rayPass.onEdge = true;\n    rayPass.refractive = true;\n    rayPass.reflective = false;\n    return rayPass;\n}\n\nRayPass passFloor(Ray r) {\n    float d = r.pos.y / -r.dir.y;\n    bool hit = (r.pos.y > 0. && r.dir.y < 0.) || (r.pos.y < 0. && r.dir.y > 0.);\n    return RayPass(\n        d, vec3(0, 1, 0), d, vec3(0, -1, 0),\n        hit || (r.pos.y == 0.),\n        hit || ((r.pos.y == 0.) && (r.dir.y != 0.)),\n        0., false, false, false\n    );\n}\n\n//boolean operations\nvoid rp_Union(inout RayPass a, in RayPass b) {\n    /* // backface culling\n    a.entered = a.entered && a.enterDepth >= 0.;\n    b.entered = b.entered && b.enterDepth >= 0.;*/\n    \n    // no backface culling\n    a.entered = a.entered && a.exitDepth >= 0.;\n    b.entered = b.entered && b.exitDepth >= 0.;\n    if (a.entered && b.entered) {\n        bool enter =  (a.enterDepth <= b.enterDepth);\n        bool exit  = ((a.exitDepth  <= b.exitDepth ) || !a.exited) && !b.exited;\n        a = RayPass(\n            (enter) ? a.enterDepth  : b.enterDepth ,\n            (enter) ? a.enterNormal : b.enterNormal,\n            (exit ) ? a.exitDepth   : b.exitDepth  ,\n            (exit ) ? a.exitNormal  : b.exitNormal ,\n            true,\n            (a.exited || b.exited),\n            max(a.nearEdge, b.nearEdge),\n            (a.onEdge && b.onEdge),\n            (enter) ? a.refractive : b.refractive,\n            (enter) ? a.reflective : b.reflective\n        );\n    }\n    else if (!a.entered && !b.entered) {\n        a = BlankRayPass;\n    }\n    else if (b.entered) {\n        a = b;\n    }\n}\n\nRayPass map(Ray r) {\n    RayPass rayPass = BlankRayPass;\n    rayPass = passFloor(r);\n    //rayPass = passCircle(r, 1.);\n    rp_Union(rayPass, passCircle(translate(r, vec3(0, 1, 0)), 1.));\n    return rayPass;\n}\n\nvec3 boxMap(in sampler2D sampler, in vec3 position, in vec3 normal, in float k) {\n    vec3 x = texture(sampler, position.yz * textureStretch).xyz;\n    vec3 y = texture(sampler, position.xz * textureStretch).xyz;\n    vec3 z = texture(sampler, position.xy * textureStretch).xyz;\n    vec3 weights = pow(abs(normal), vec3(k));\n    return (x * weights.x + y * weights.y + z * weights.z) / dot(weights, vec3(1));\n}\n\nMaterial rayPassMaterialReturn(Ray r, RayPass m) {\n    Material mat;\n    if (m.entered) {\n        mat = Material(\n            boxMap(iChannel0, move(r, m.enterDepth), m.enterNormal, 1.)\n        );\n    } else {\n        mat = Material(\n            vec3(dot(r.dir, normalize(vec3(1))))\n        );\n    }\n    return mat;\n}\n\nvoid moveReflect(inout Ray r, in RayPass m) {\n    r.pos = move(r, m.enterDepth);\n    r.dir = reflect(r.dir, m.enterNormal);\n}\n\n//light sources\nfloat directionalLight(Ray r, RayPass m) {\n    Ray nr = r;\n    nr.pos = move(r, m.enterDepth);\n    nr.dir = normalize(vec3(1));\n    nr.pos = move(nr, 0.01);\n    RayPass nm = map(nr);\n    float l = 1.;\n    if (nm.entered) {\n        l -= nm.nearEdge / nm.enterDepth;\n        l = (nm.enterDepth < 0.) ? 0. : l;\n    }\n    l *= dot(m.enterNormal, normalize(vec3(1)));\n    //l += vec3(0.5);\n    if (!m.entered) {\n        l = 1.;\n    }\n    return l;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord *2. - iResolution.xy) /iResolution.y;\n    vec2 mouse = 2. * (iMouse.xy *2. - iResolution.xy) /iResolution.y;\n    \n    Ray r = Ray(\n        vec3(0, 0, -3),\n        normalize(vec3(uv, 0.5)) // lower = higher fov\n    );\n    \n    mat2 rot = rot2D(mouse.y);\n    r.pos.yz *= rot;\n    r.dir.yz *= rot;\n    rot = rot2D(mouse.x);\n    r.pos.xz *= rot;\n    r.dir.xz *= rot;\n    Ray or = r;\n    \n    RayPass m = map(r);\n    vec3 originalRDir = r.dir;\n    if (m.refractive) {\n        r.pos = move(r, m.enterDepth);\n        r.dir = refract(r.dir, m.enterNormal, 1. / glassIOR);\n        m = map(r);\n        r.pos = move(r, m.exitDepth);\n        //r.dir = originalRDir;\n        r.dir = refract(r.dir, (m.reflective) ? m.exitNormal : -m.exitNormal, glassIOR / 1.);\n        r.pos = move(r, 0.01);\n        m = map(r);\n    } else if (false) {\n        r.pos = move(r, m.enterDepth);\n        r.dir = reflect(r.dir, m.enterNormal);\n        r.pos = move(r, 0.01);\n        m = map(r);\n    }\n    vec3 color = rayPassMaterialReturn(r, m).color;\n    //color = vec3(1);\n    vec3 l = vec3(1) * directionalLight(r, m);\n    color *= l;\n    //fragColor = vec4((m.entered) ? m.enterNormal : vec3(dot(r.dir, normalize(vec3(1)))), 1);\n    //fragColor = vec4((m.entered) ? ((m.onEdge) ? m.nearEdge : 0.) : dot(r.dir, normalize(vec3(1))));\n    \n    //fragColor = vec4(rayPassMaterialReturn(r, m).color, 1);\n    //fragColor = vec4(m.enterDepth * 0.1);\n    //fragColor = vec4((m.refractive) ? 1 : 0);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}