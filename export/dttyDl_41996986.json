{"ver":"0.1","info":{"id":"dttyDl","date":"1700463157","viewed":30,"name":"20231113","username":"wwwww","description":"random\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nprecision highp float;\n\nfloat gTime = 0.;\nconst float REPEAT = 5.0;\n\n// 回転行列\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// 箱の符号付き距離関数\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nfloat box(vec3 pos, float scale) {\n    pos *= scale;\n    float dynamicScale = sin(iTime) * 0.5 + 1.0;\n    pos *= dynamicScale;\n\n    // 半径をスカラー値として指定\n    float base = sdSphere(pos, 0.4) / 1.5;\n\n    pos.xy *= 5.;\n    pos.y -= 3.5;\n    pos.xy *= rot(.75);\n    float result = -base;\n    return result;\n}\n\n\n\n// 箱の集合体を生成する関数\nfloat box_set(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y += sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .y -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .x +=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos .x -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos.xy *=   rot(.8);\n\tfloat box5 = box(pos,.5) * 6.;\t\n\tpos = pos_origin;\n\tfloat box6 = box(pos,.5) * 6.;\t\n    float result = max(max(max(max(max(box1, box2), box3), box4), box5), box6);\n    return result;\n}\n\n\n// シーンのマッピング関数\nfloat map(vec3 pos, float iTime) {\n    vec3 pos_origin = pos;\n    float box_set1 = box_set(pos, iTime);\n    return box_set1;\n}\n\n// 2Dハッシュ関数\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// HSVからRGBへの変換\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// 2D胞体ノイズ生成関数\nfloat cellularNoise(vec2 p) {\n    float K = 1.0 / 7.0; // スケール調整\n    vec2 i = floor(p * K);\n    vec2 f = fract(p * K);\n    float m = 1.0;\n\n    for (int j = -1; j <= 1; j++) {\n        for (int k = -1; k <= 1; k++) {\n            vec2 g = vec2(float(k), float(j));\n            vec2 o = hash2(i + g);\n            vec2 r = g - f + o;\n            float d = dot(r, r);\n            m = min(m, d);\n        }\n    }\n    return m;\n}\n\n// メインイメージ関数\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(0., -0.2, iTime * 4.);\n    vec3 ray = normalize(vec3(p, 1.5));\n    ray.xy *= rot(sin(iTime * .03) * 5.);\n    ray.yz *= rot(sin(iTime * .05) * .2);\n    float t = 0.1;\n    vec3 col = vec3(0.);\n    float ac = 0.0;\n\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = ro + ray * t;\n        pos = mod(pos - 2., 4.) - 2.;\n        gTime = iTime - float(i) * 0.01;\n        float d = map(pos, iTime);\n        d = max(abs(d), 0.01);\n        ac += exp(-d * 23.);\n        t += d * 0.55;\n    }\n\n    float noise = cellularNoise(fragCoord.xy * 0.03);\n    vec3 noiseColor = hsv2rgb(vec3(noise * 1.1, 0.01, 0.4));\n    col = vec3(ac * 0.01) + noiseColor;\n\n    fragColor = vec4(col, 1.0 - t * (0.02 + 0.02 * cos(iTime)));\n}\n","name":"Image","description":"","type":"image"}]}