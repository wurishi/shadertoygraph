{"ver":"0.1","info":{"id":"tts3WB","date":"1557577640","viewed":91,"name":"Squareable WallpaperGroup","username":"ollj","description":"I want all wallpaper groups in one shader\n12/17 done (all those, that (easily) make sense in charthesian coordinates) (180deg and 90deg symmetry)\n\nthe ones that only make sense in barycentric|hex are next. (120deg symmetry)\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tiling","tiles","lattice","skew","wallpapergroup","p1","p2","wallpapergoup","cmm","pmm","p4g","p4m","pmg","pg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//the skew barely makes sense for many cases.\n//#define skewIt\n//you might want to pause time at iTime==0\n\n//2d zoom\n#define ViewZoom 5.2\n\n/*\n2 lines of code for editing are named:\n- [[12 of 17 wallpaper group function names]]\n- [[change function name here              ]]\n\n\n\n--- Tags:\nWallpaperGoup,cmm,pmm,p1,p2,p4g,p4m,pmg,pg,tiling,lattice,skew,tiles\n\n12 of 17 included\n 5 of 17 missing\n, the ones that only make sense in barycentric|hex coordinates: \n, p3, p3m1, p31m, p6,p6m\n\nthis shader is a preview bacup, that is likely obsolete soon\n\nself        : https://www.shadertoy.com/view/tts3WB\nparent skew : https://www.shadertoy.com/view/lltcR7\nparent glide: https://www.shadertoy.com/view/XsfBDH\nrecipe      : https://twitter.com/ollj/status/112690634711778508\n\ngoal is to have the complete wallpaper group in one shader\nfirst implement each of the 17 cases, then have them share as many subroutines as possible.\nthen make them parametric and interpolateable\nrecipe:\nhttps://twitter.com/ollj/status/112690634711778508\nis still missing some ingredients:\n*/\n\n//do 3x3 taps for a shape with kerning (it repeats AND overlaps skewing AND rotating tile borders)\n#define doNeighborhood\n\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n//color of outlined shape (bound by tile borders)\n#define cOutlined vec3(0,0,0)\n\n//color of cursor\n#define cCursor vec3(u5(cos(iTime*2.)))\n\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 ad(v3 a){return dot(v3(1),a);}\nv0 ad(v2 a){return dot(v2(1),a);}\nv0 ad(v1 a){return a.x+a.y;}//aka suv()\nv0 ma(v1 a){return max(a.y,a.x);}\nv0 ma(v2 a){return max(a.z,ma(a.xy));}\nv0 ma(v3 a){return max(ma(a.zw),ma(a.xy));}\n#define mi(a)-ma(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\n\n#define pi acos(-1.)\n//float TAU=6.28318530718;\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define u2(a)((a)*2.-1.)\n#define u3(a)((a)*2.+1.)\n#define u4(a)((a)*.5-.5)\n#define u5(a)((a)*.5+.5)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\nvec2   skew(vec2 u){return u+ad(u)*ske;}\nvec2 unskew(vec2 u){return u-ad(u)*reSke;}\n\n//generalized \"rainbow\" by ollj\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for:0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;,for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\",range [-.159 ...159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green)blue;try;p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n//;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds,sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n//;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*iResolution.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(iTime)//;g=.1//a 3rd domain as time for demoing,whould actually be constant\n//;c=gradVis(c,u,v)//a graph plotter,not included here.\n ;return c;}\nvec3 rainbowN11(vec2 u){return rainbowN(u,vec2(1),vec3(1));}\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5//parametric j-shape m sets limb lengths.\n ;if(!(u.y-1.>0.||u.x+1.<0.))return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;c=.5*u.y*(b+c)-c//c=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(c);}\n\nfloat ff(vec2 u,vec2 m//parametric f-shape m sets limb lengths.\n){vec2 v=u\n ;v.x=abs(abs(v.x-.75)-1.)+1.//-.2\n ;//v.x/=2.\n ;//u.x=abs(u.x+2.)\n ;float a=length(v-m+vec2(0,4))\n ;return min(a,jj(-u,m))\n ;}\n\nfloat TinyDith(vec2 a){;if(fract(a.x*a.y)>.5)return 1.;return 0.;}\n\nvec4 greyBorderCoss(vec2 U,vec4 o){\n ;U=abs(U)\n ;return smoothstep(.5,-.5,min(U.x,U.y)-1.)*(vec4(.5,.5,.5,1.)-o)+o;}\n\nfloat neighborhood(vec4 o,float t,vec2 u,mat2 r,vec2 m,vec2 U,vec2 K\n#ifndef doNeighborhood\n){return 0.;}           \n#else\n){float d=0.\n ;for (float i=-1.;i<2.;i++){for (float j=-1.;j<2.;j++ //[kerning] 3x3 neighborhood\n ){vec2 a=u-m+vec2(i,j)\n  ;if(U.y<0.)a=mix(a,unskew(a),t)\n  ;a=r*a\n  ;d+=smoothstep(.01,-.01,ff(a*19.,K)-.3)\n  ;}};return d;;}\n#endif\n\nfloat smoothFf(vec2 U,vec2 K){\n ;return smoothstep(.1,-.1,abs(ff(U*19.,K)-.6)-.3);}\n\nvec4 cursor(vec2 U,vec2 M,vec2 K,vec4 o,vec3 c\n){U=(U-M)/iResolution.xy\n ;U.y*=iResolution.y/iResolution.x\n ;U*=3.*iResolution.x/vec2(512.) //very hacky     \n ;o.xyz=mix(o.xyz\n           ,c\n           ,smoothstep(.1,-.1\n                       ,abs(ff(U*19.,K)-.6)-.3))\n ;return o;}\n\n/*\n//I know this is sloppy, all good prototypes are designed to learn from experimental failures:\n//parent shader was an older semi mess, but full of useful subroutines\nvec4 parent(vec4 o,vec2 u\n){float td=TinyDith(u)//basic dithering of 2 complemenraty,usually alternating complemenraty colors,avoids a mixing to grey.\n ;u     =u        -.5*iResolution.xy\n ;vec2 m=iMouse.xy-.5*iResolution.xy\n ;vec2 U=u\n ;vec2 M=m;\n ;mat2 r=mat2(1)\n ;if(u.x>0.)r=r2(iTime*.1)\n ;u*=r\n ;m*=r\n ;float t=cos(iTime+pi)*.5+.5\n ;o=vec4(1)\n ;u/=164.;m/=164.\n ;if(U.y<0.\n ){u=mix(u,skew(u),t)//t*skew(u)+(1.-t)*u\n  ;m=mix(m,skew(m),t);}\n ;vec2 a=u-fract(u+.5)//fract,with offset\n ;u=u-floor(u+.5)//floor,with offset\n ;m=m-floor(m+.5)//floor,with offset \n #ifdef MirrorTest\n ;if(td>.5){//additional symmetry is ghosted\n  ;if(u.x<.0)u.x=-u.x//works but is not super pretty (the mirror is skewed badly)\n  ;//if(u.x<u.y)u=-u//works but is not pretty (more issues)\n  ;//if(u.y<.0)u.y=-u.y//works but is is dumb and doesnt fo gell with a j-shape (more issues)\n ;}\n #endif\n ;vec2 k=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.+a.x*4.-a.y*sqrt(5.))))//wiggly j-shape proportions tile dependent\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n //uniting both would require to calculate the above wiggle 9 times,witzhin the O(n*n)loop below,not doing that\n ;o.xyz=rainbowN11((a+a.yx)*vec2(phi,.5))//base tile color\n ;o.xyz-=smoothstep(.1,-.1,u.x-u.y)*u2(o.xyz)//changes diagonal half to complementary color.\n ;//if(u.x>u.y)o.xyz=1.-o.xyz//grey line over diagonal instead of complemenraty color on other half.     \n ;float                                 e=neighborhood(o,t,u,r,m,U,K)\n ;o.xyz=mix(o.xyz,vec3(u5(cos(U*.1)),1),e)\n ;if(U.y<0.)u=mix(u,unskew(u),t)//if(lower half of screen) unskew()\n ;//u=r*u //optional rotate of hollow repeated shape\n ;o.xyz=mix(o.xyz\n           ,cOutlined\n           ,smoothstep(.1,-.1\n                       ,abs(ff((u-r*vec2(0,0))*19.,k)-.361)-.1))\n ;o=greyBorderCoss(U,o)\n ;o=cursor(U,M,K,o,cCursor)\n ;return o;}\n/**/\n\n//below are subroutines for WallpaperGroup\n\nvec2 md0(vec2 u//mirror diagonally\n){if(u.x<u.y)u=u.yx//*vec2(1,-1)\n ;return u;}\n\nvec2 md1(vec2 u//mirror diagonally\n){u.y=-u.y\n ;u=md0(u)\n ;u.y=-u.y\n ;return u;}\n\nvec2 mh(vec2 u//glideReflect horizontally\n){u.y=abs(u.y)\n ;return u;}\n\n\nvec2 gh(vec2 u//glideReflect horizontally\n){if(u.y<0.)u.x=-u.x\n ;u.y=abs(u.y)\n ;return u;}\n\nvec2 gd0(vec2 u//glideReflect diagonally\n){if(u.x<u.y)u.xy=-u.yx\n ;u=md0(u)\n ;return u;}\n\nvec2 gd1(vec2 u//glideReflect diagonally\n){u.y=-u.y\n ;u=gd0(u)\n ;u.y=-u.y  \n ;return u;}\n\nvec2 pmgs(vec2 u){if(u.x<.0)return vec2(u.x,abs(u.y))\n               ;return vec2(0,1)-abs(u);}//pmg is a special snowflake\n\n\n\n/*\nvec2 p4mss(vec2 u){\n    //;vec2 f=vec2(1)\n    //;if(sign(u.x)!=sign(u.y))f=vec2(-1,1)\n    ;if(u.x>0.){\n        if(u.y>0.){return u\n        ;}else{return u.yx*vec2(-1,1) \n        ;}\n    }else{\n      if(u.y>0.){return u.yx*vec2(-1,1).yx\n        ;}else{return -u \n          ;}}}*/\n\nvec2 p4S(vec2 u){\n       /* ;     if(!((u.x>0.||u.y<0.)&&(u.x<0.||u.y>0.)))*/\n            \n         if(sign(u.x)!=sign(u.y))           u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1)\n  \n  //  ;     if(u.x<0.&&u.y>0.)u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1) \n;return gh(u);}\n\nvec2 p4gs(vec2 u){return md1(p4S(u)*2.-.5);}\n\nvec2 pggs(vec2 u\n){//u=u.yx*vec2(1,-1)\n ;u=gh(u)\n ;vec2 d=vec2(u.x,-u.x)+u.y-1.;\n ;d.x=max(d.x,d.y)\n ;if(d.x>0.)return mix(vec2(1)-gd1(u),gd0(u)+vec2(-1,1),step(u.x,0.))\n ;return u;}\n\nvec2 pggsbackup(vec2 u){//this one was hard, this was my first sucess to getting pggs()\n    ;u=gh(u)\n    ;if(u.x+u.y-1.>0.)return (gd1(u)*vec2(-1,-1)+vec2(1,-1)*vec2(-1,-1))+vec2(2,0)\n    ;if(u.x-u.y+1.<0.)return gd0(u)+vec2(-1,1)\n    ;return u;}\n\nvec2 pmod2(vec2 u){return fract(u-.5)-.5;}//no floor returned\n\n\n//vec2 pm(vec2 u){return pmod2(u);}//just a wrapper for now\n\n\n\n//below are beta-wrappers of the abive\n//i have not yet decided on how to unify them \n//as scaling are a bit off between a few of them\n\n//[[12 of 17 wallpaper group function names]]\nvec2 cmm(vec2 u){return    md1(md0(pmod2(u)));}\nvec2 cm (vec2 u){return        md0(pmod2(u));}\nvec2 pm (vec2 u){return        mh (pmod2(u));}\nvec2 pmm(vec2 u){return     mh(mh (pmod2(u).yx).yx);}//swivel gallore.\nvec2 p1 (vec2 u){return           (pmod2(u));}\nvec2 p2 (vec2 u){return        gd0(pmod2(u));}\nvec2 p4 (vec2 u){return        p4S(pmod2(u));}\nvec2 p4g(vec2 u){return       p4gs(pmod2(u));}\nvec2 pmg(vec2 u){return       pmgs(pmod2(u/2.)*2.);}//pmg is a special snowflake\nvec2 pgg(vec2 u){return       pggs(pmod2(u   )*2.);}\nvec2 pg (vec2 u){return        gh (pmod2(u));}\nvec2 p4m(vec2 u){return mh(md1(md0(pmod2(u))));}\n\n\n\n//vec2 pgg(vec2 u){return pggsbackup(pmod2(u)*2.);}\n\n/*\n//learning mostly how to NOT intertpolate things\n//i guess mixing of polar coords makes moresense here.\nvoid misstuff(inout vec2 u,inout vec2 m\n){vec2 U=md0(u)\n ;vec2 M=md0(m)\n ;     u=pmg(u)\n ;     m=pmg(m)   \n ;float t=cos(iTime)*.5+.5\n ;u=mix(u,U,t)\n ;m=mix(m,M,t)\n ;}*/\n\nvoid mainImage(out vec4 o,vec2 u\n){o=vec4(1)\n ;vec2 m=fra(iMouse.xy)\n ;u=fra(u)\n ;//o=parent(o,u)\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n\n ;float s=-cos(iTime)*.5+.5\n ;//s=0.\n //#if 1\n  #ifdef skewIt\n  ;u=mix(u,skew(u),s)\n  ;m=mix(m,skew(m),s)\n  #endif\n  ;u=pmg(u)//[[change function name here]]\n  ;m=pmg(m)//[[change function name here]]\n  #ifdef skewIt\n  ;u=mix(u,unskew(u),s)\n  ;m=mix(m,unskew(m),s) \n  #endif\n     /*\n  ;u=gd1(u)\n  ;m=gd1(m)  \n  ;u=md0(u)\n  ;m=md0(m)*/\n// #else\n//  ;misstuff(u,m)\n// #endif\n ;o.xyz=vec3(smoothFf((u-m)*1.5,K))\n ;if(u.x>iResolution.y-u.y)o.x=0.\n ;o.xz=u+.5\n ;}","name":"Image","description":"","type":"image"}]}