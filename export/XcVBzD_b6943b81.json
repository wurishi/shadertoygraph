{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 C, in vec2 O )\n{\n    C=texelFetch(iChannel0,ivec2(O),0);\n    }","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const float rot1=0.;\nconst float rot2=0.;\n\n\nvec3 rot(vec3 point, vec3 axis, float angle)\n{\n    // based on https://suricrasia.online/demoscene/functions/#erot\n    // axis should be normalized, angle should be in radians\n    vec3 origin = dot(point, axis)*axis;\n    vec3 diff = point - origin;\n    vec3 z_axis = -axis;\n    vec3 x_axis = normalize(diff);\n    vec3 y_axis = normalize(cross(z_axis, x_axis));\n    float R = length(diff);\n    return origin + x_axis*R*cos(angle) + y_axis*R*sin(angle);\n}\nvoid mainImage( out vec4 C, in vec2 O )\n{\n    vec3 view=vec3(O.x/iResolution.x*100.-50.,O.y/iResolution.y*80.-40.,iTime*1.-20.);\n    view=rot(view,vec3(0,1,0),rot1);\n    view=rot(view,vec3(1,0,0),rot2);\n    if(iFrame==0)C=vec4(0);\n    vec4 C0=texelFetch(iChannel0,ivec2(O),0);\n    hit a=getVoxel(view);\n    vec4 n=vec4(a.col,1);\n    if(a.didHit){\n        if(C0==vec4(0)){C=n;}\n        else{C=n;}}\n        else{C=C0;}\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nconst float iDist=10.;\n\nconst float iPowerZ1=2.;\nconst float iPowerC1=0.;\nconst float iQuot1=1.;\n\nconst float iPowerZ2=0.;\nconst float iPowerC2=1.;\nconst float iQuot2=1.;\n\nconst float iPowerZ3=0.;\nconst float iPowerC3=0.;\nconst float iQuot3=0.;\n\nconst float iVoxRes=3.0;\nconst int iMaxTrace=500;\nconst bool isJulia=false;\nconst bool isAnti=false;\nconst float iAlpha=1.;\n\nconst bool intermode=true;\nconst float intervoidstepsize=5.0;\nconst float interhitstepsize=0.05;\nconst int interhitbreakval=100;\n\nconst float huefactor=3.0;\nconst float hueshift=0.0;\nconst float saturation=1.0;\nconst float colval=2.0;\nconst int colormode=0;\nconst float cm1base=0.1;\n\nconst int alphamode=0;\nconst float hitfactor=0.1;\n\nconst bool mixmul=false;\n\nconst float pi = 3.141592;\nconst float tau = 2.0*pi;\nconst float ee=2.71828182846 ;\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\nstruct HON{\n    vec3 val;\n    vec2 ori;\n};\n\nfloat h1(float oa,float ob,float a,float b){\n    float c=(a*floor(abs(oa)/4./PI)*sign(oa)+b*floor(abs(ob)/4./PI)*sign(ob))/(a+b);\n    \n    return c;\n\n}\nfloat rz(float a){\n    return floor(abs(a)/4./PI)*sign(a);\n}\n\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nHON cAdd(HON a,HON b){\n    HON c=HON(vec3(0),vec2(0));\n    \n    c.val=vec3(a.val.x+b.val.x,a.val.y+b.val.y,a.val.z+b.val.z);\n\n\n    if(length(a.val)==0.0){c.ori=b.ori;return c;}\n    if(length(b.val)==0.0){c.ori=a.ori;return c;}\n\n\n    if(length(b.ori.x)+length(a.ori.x)==0.0){c.ori.x=0.;}\n    else{\n      c.ori.x=atan(sin(a.ori.x)*length(a.val)+sin(b.ori.x)*length(b.val),cos(a.ori.x)*length(a.val)+cos(b.ori.x)*length(b.val));\n      }\n\n    \n    if(length(b.ori.y)+length(a.ori.y)==0.0){c.ori.y=0.;}\n    else{\n      c.ori.y=atan(sin(a.ori.y)*length(a.val)+sin(b.ori.y)*length(b.val),cos(a.ori.y)*length(a.val)+cos(b.ori.y)*length(b.val));\n    }\n    return c;\n\n}\n\n\n\n\nHON cMul(HON a,HON b){\n    HON c=HON(vec3(1,0,0),a.ori+b.ori);\n\n    vec3 n=c.val;\n    vec2 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.x*sin(nd.y)+n.z*cos(nd.y);\n\n    c.val*=length(a.val)*length(b.val);\n    return c;\n}\n\nHON cDiv(HON a,HON b){\n    HON c=HON(vec3(1,0,0),a.ori-b.ori);\n\n    vec3 n=c.val;\n    vec2 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.x*sin(nd.y)+n.z*cos(nd.y);\n\n    c.val*=length(a.val)/length(b.val);\n    return c;\n}\n\nHON cPowf(HON a,float npow){\n    HON c=HON(vec3(1,0,0),a.ori*npow);\n    if(npow==0.)return c;\n\n    vec3 n=c.val;\n    vec2 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n    \n    \n    n=c.val;\n    c.val.x=n.x*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.x*sin(nd.y)+n.z*cos(nd.y);\n    \n\n    c.val*=pow(length(a.val),npow);\n    return c;\n\n}\n\nHON cInit(float a, float b, float c){\n    HON d=HON(vec3(0),vec2(0));\n    d=cAdd(HON(vec3(a,0.0,0.0),vec2(((a<0.)?PI:0.),0.0)),HON(vec3(0.0,b,0.0),vec2(PI/2.+((b<0.)?PI:0.),0.0)));\n    d=cAdd(d,HON(vec3(0.0,0.0,c),vec2(0.0,PI/2.+((c<0.)?PI:0.))));\n    return d;\n}\n\nHON cLog(HON a) {\n    HON c = HON(vec3(0), vec2(0));\n    float magnitude = length(a.val);\n\n    if (magnitude==0.) {\n        return HON(vec3(0), vec2(0));\n    }\n\n    float m = log(magnitude);\n\n    c=cInit(m,a.ori.x,a.ori.y);\n    return c;\n}\n\n\n\n\n\nHON cExp(HON a) {\n    HON c=HON(vec3(0),vec2(0));\n    \n    HON expN = cInit(ee,0.0,0.0);\n    HON expI = cInit(cos(a.val.y), sin(a.val.y), 0.0); \n    HON expJ = cInit(cos(a.val.z), 0.0, sin(a.val.z));\n    \n    \n    expN=cPowf(expN,a.val.x);\n\n    //vec2 o=vec2(length(a.val)*sin(a.ori.x),length(a.val)*sin(a.ori.y));\n    \n\n    c=cMul(cMul(expJ,expI),expN);\n    //c.ori=o;\n    return c;\n}\nHON cfPow(float f,HON a) {\n    HON c=HON(vec3(0),vec2(0));\n    if(f==0.)return cInit(0.,0.,0.);\n    \n    HON expN = cInit(f,0.0,0.0);\n    HON expI = cInit(cos(a.val.y*log(f)), sin(a.val.y*log(f)), 0.0); \n    HON expJ = cInit(cos(a.val.z*log(f)), 0.0, sin(a.val.z*log(f))); \n    \n    \n    expN=cPowf(expN,a.val.x);\n    //vec2 o=vec2(length(a.val.xy)*log(f)*sin(a.ori.x),length(a.val.xz)*log(f)*sin(a.ori.y));\n    \n    c=cMul(cMul(expJ,expI),expN);\n    //c.ori=o;\n    return c;\n}\n\nHON cPow(HON a,HON b){\n    HON c=HON(vec3(0),vec2(0));\n\n    if(length(b.val)==0.)return cInit(1.,0.,0.);\n    if(length(a.val)==0.)return c;\n    \n    \n    HON t1=cPowf(a,length(b.val));\n    HON t2=cExp(cMul(b,cLog(a)));\n    HON v=cLog(cPowf(a,-length(b.val)));\n    //v.val/=log(length(b.val));\n    \n    v=cDiv(v,cLog(cInit(length(b.val),0.,0.)));\n    HON t3=cfPow(length(b.val),v);\n    c=cMul(t1,cMul(t2,t3));\n    return c;\n}\n\n\n\nvec3 mandi(in vec3 p ) {\n\n    HON z=HON(vec3(0),vec2(0));\n    HON q;\n    HON k;\n    HON m;\n    HON g;\n    HON c=cInit(p.x,p.y,p.z);\n    HON wo1=cInit(iQuot1,0.,0.);\n    HON wo2=cInit(iQuot2,0.,0.);\n    HON wo3=cInit(iQuot3,0.,0.);\n\n    bool inMandelbrotSet = true;\n\n    for (int i=0; i<100; i++) {\n\n\tm=HON(vec3(0),vec2(0));\n\tif(iQuot1==0.){\n\t\tg=HON(vec3(0),vec2(0));\n\t}\n\telse{\n\t  q=cPowf(z,iPowerZ1);\n      k=cPowf(c,iPowerC1);\n      g=cMul(q,k);\n      m=cMul(g,wo1);\n \n\t}\n\tm=cAdd(m,g);\n\tif(iQuot2==0.){\n\t\tg=HON(vec3(0),vec2(0));\n\t}\n\telse{\n        q=cPowf(z,iPowerZ2);\n        k=cPowf(c,iPowerC2);\n\t\tg=cMul(q,k);\n\t\tg=cMul(g,wo2);\n\t}\n\n\n    m=cAdd(m,g);\n\tif(iQuot3==0.){\n\t\tg=HON(vec3(0),vec2(0));\n\t}\n\telse{\n\t\tq=cPowf(z,iPowerZ3);\n        k=cPowf(c,iPowerC3);\n\t\tg=cMul(q,k);\n\t\tg=cMul(g,wo3);\n\t}\n        m=cAdd(m,g);\n\n\tz=m;\n    //z=cExp(cLog(m));\n    //HON mlog=cLog(m);\n    //mlog.val/=log(2.);\n    //z=cfPow(2.,mlog);\n    //z=cLog(m);\n\n        if (length(z.val) > 2.) {\n            inMandelbrotSet = false;\n            break;\n        }\n    }\n    if (inMandelbrotSet^^isAnti) {\n        return(z.val);\n    } else {\n        return(vec3(0.));\n    }\n}\n\nvec3 julia(in vec3 p ) {\n\n    HON z=HON(vec3(0),vec2(0));\n\n    HON c;\n    HON q;\n    z=cInit(p.x,p.y,p.z);\n    c=cInit(0.3,0.5,0.4);\n    int j=0;\n\n    for (int i=0; i<100; i++) {\n\n        q=cPowf(z,iPowerZ1);\n\n        z=cAdd(q,c);\n\n        if (length(z.val) > 100.) {\n            break;\n        }\n        j++;\n    }\n\tif((float(j)/100.<0.1)^^isAnti){return vec3(0.0);}\n\telse return(z.val);\n}\n\n\n\n#define TIME iTime/2.0\n\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n\nhit getVoxel(vec3 p) {\n        vec3 c;\n        if(isJulia){c=julia(vec3(p)*.05/iVoxRes);}\n        else{c=mandi(vec3(p)*.05/iVoxRes);}\n    if (length(c)!=0.) {\n        vec3 color=vec3(1);\n        if(colormode==0){\n            color=hsv2rgb(vec3(length(c)*huefactor+hueshift,saturation,colval));}\n        if(colormode==1){\n            color=rgb2hsv(vec3(pow(cm1base,c.x),pow(cm1base,c.y),pow(cm1base,c.z)));\n            color.y=saturation;\n            color.z=colval;\n            color=hsv2rgb(color);\n            }\n           if(colormode==2){\n               color=vec3(length(c));\n           }\n           if(colormode==3){\n               color=vec3(abs(c.x),abs(c.y),abs(c.z));\n           }\n        return hit(true, color);}\n    else\n        return hit(false, vec3(0,0,0));\n\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcVBzD","date":"1733826792","viewed":31,"name":"BufferFrac","username":"maxiie","description":"fractal","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}