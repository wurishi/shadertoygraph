{"ver":"0.1","info":{"id":"7dSyzw","date":"1643324647","viewed":247,"name":"optimized grid neighbours++","username":"Carandiru","description":"trying to convert to 3D sampling where there would be 27 samples via the classical method. It would really speed up the JFA process for a volume if this alternate method can be used. (far less samples)\nclick to see the full Voronoi\n","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","grid","worley","tuto"],"hasliked":0,"parentid":"NsfyDs","parentname":"optimized grid neighborhood"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original shader by fabrice neyret : https://www.shadertoy.com/view/NsfyDs\n\n// attempt to upgrade to 3D / volume sampling....\n// trying to convert to 3D sampling where there would be 27 samples via the classical method. \n// It would really speed up the jumpflooding process for a volume if this alternate method can be used. \n// (far less samples)\n\n#define hash(p) fract(sin((p)*mat3(127.1,311.7,269.5, 183.3,127.1,311.7, 269.5,183.3,311.7)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    \n    vec2 R = iResolution.xy;\n    vec3 U = vec3(u/iResolution.y, iTime*0.025f) * 10.0f, \n         I = floor(U), F = fract(U), P,H,S;\n    float d = 1e9;\n    \n#if 0                                // --- the classical 9-cells loop (would be 27 for volume)\n    for( int k=0; k<9; k++) {   \n        P = vec2(k%3,k/3)-1.;         // variant: P = I+...; P+= hash(P) - U\n        H = hash(I+P);                // random point in cell\n        A = hash(I+P+.5);             // for random rotation\n  #if rot    \n        A = .3*cos(5.*(A.x-.5)*iTime +6.3*A.y +vec2(0,11));\n        P += .1+.8*H -F + A;\n  #else\n        P += H - F;\n  #endif\n        d = min(d, dot(P,P) );\n    }\n\n#else                                 // --- the alternate 4-cells loop  (7 ? 13? for volume?)\n// loopless form\n#define C(u,v,w) P = vec3(u,v,w); H = hash(I+P); P += H - F; d = min(d, dot(P,P) );\n\n    C(0,0,0);\n    S = sign(F-.5);                         // neighbors can win only on the side the pixel is in the cell\n    C(S.x,0,0);   C(0,S.y,0);   C(S.x,S.y,0);\n    C(S.x,0,S.z); C(0,S.y,S.z); C(S.x,S.y,S.z);  // is this correct ?\n    \n#endif\n\n    O = vec4( iMouse.z>0. \n                ? sqrt(d)                                  // show Vorono√Ø\n                : smoothstep( 15./R.y,0., sqrt(d)-.3 )  ); // show dots\n    O.rgb += .3*mod(I,2.);                                  // show tiling\n // O += .2* ( .6 + .6 * cos( 6.3*hash(I).x  + vec4(0,23,21,0)  ) );\n}","name":"Image","description":"","type":"image"}]}