{"ver":"0.1","info":{"id":"NsjSzh","date":"1619644057","viewed":95,"name":"December InertiaRoyale MS","username":"MonsieurSoleil","description":"I don't really remember what I was doing at this moment :D","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    So, \n    I forgot to publish my shaders.\n    This was from inertiaRoyale Shader from January/December.\n\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n#define time iTime\n#define mod01 floor(mod(time, 4.0))\n#define mod02 floor(mod(time, 4.0))\n#define mod03 floor(mod(time * 2.0, 4.0))\n#define mod04 floor(mod(time * 2.0, 8.0))\n\nstruct matter\n{\n  float m;\n  vec3 col;\n  int type;\n  float dist;\n  float glow;\n  bool reflected;\n  \n};\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec2 repeat(vec2 p, float rep)\n{\n  return (fract(abs(p)/rep - 0.5) - 0.5) * rep;\n}\n\nvec2 id(vec2 p, float rep)\n{\n  return (floor(abs(p)/rep - 0.5) - 0.5) * rep;\n}\n\nfloat rnd(vec2 x)\n{\n    return fract(dot(sin(x * 352.1263 + x.yx * 5623.2365), vec2(451.2365)));\n}\n\nfloat rnd(float x)\n{\n    return fract(sin(x * 352.1263 + x * 5623.2365));\n}\n\nfloat curve(float x)\n{\n  return mix(rnd(x), rnd(x + 1.0), fract(time));\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n  p.xy *= rot( p.z * (0.001 - sin(abs(time * 0.000025)) * 0.075) + (mod03 * 8.5) + time * 1.25) * 2.25;\n  \n  float repV = 0.25 + sin(abs(mod03 * 0.1)) * 2.0;\n  vec3 p01 = p, p02 = p, p03 = p, p04 = p;\n  \n  vec2 id0111 = id(p01.xz, repV * 22.0);\n  \n  vec2 id011 = id(p01.xz, repV * 4.0);\n  vec2 id01 = id(p01.xz, repV);\n  p01.xz = repeat(p01.xz, repV);\n  \n  float rnd01 = rnd(id01 * 32.0);\n  float rnd011 = rnd(id011 * 32.0);\n  float rnd0111 = rnd(id0111 * 132.0);\n  \n  vec2 id02 = id(p02.yz, repV);\n  p02.yz = repeat(p02.yz, repV);\n  \n  float rnd02 = rnd(id02 * 32.0);\n  \n  vec2 id031 = id(p03.yz, repV * 8.0);\n  vec2 id03 = id(p03.yz, repV);\n  p03.yz = repeat(p03.yz, repV);\n  \n  float rnd03 = rnd(id03 * 32.0);\n  float rnd031 = rnd(id031 * 32.0);\n  \n  vec2 id041 = id(p04.xz, repV * 6.0);\n  p04.xz = repeat(p04.xz, repV);\n  float rnd041 = rnd(id041 * 32.0);\n  \n  float scaleV = 0.4 * sin(abs(time * 1.5)) + 0.75;\n  \n    float mat01 = box(p01 + vec3(0.0,26.0 + 4.0 * sin(p.z * 0.1 + time) + rnd0111 * 4.0, 0.0), vec3(scaleV) + vec3(0.8 * rnd01 + 0.575 * mod01 * rnd01) - vec3(0.0, rnd011 * 8.55 * sin(time * 2.0), 0.0) - vec3(0.0, 2.0 * rnd0111, 0.0)) ;\n  \n  float mat02 = box(p02 + vec3(55.0 - fract(time * 0.45) * 32.0, 0.0 , 0.0), vec3(scaleV) * 0.8 * rnd02 * (mod02 + 0.25) - vec3(rnd031 * sin(abs(time * 4.0)) * 7.0));\n  \n  float mat03 = box(p03 + vec3(-45.0 - fract(time * 0.05 + mod03) * 38.0, 0.0, 0.0), vec3(scaleV * 0.8 * rnd03 * (mod02 + 0.25)));\n  \n  float mat04 = box(p04 + vec3(0.0, -45.0  + 2.0 * sin(p.z * 0.25 + time + (mod03)) , 0.0), vec3(0.1) + vec3(0.1 + 0.275 - sin(time * rnd041)));\n  \n  mat.m = min(mat01, mat02);\n  mat.m = min(mat.m, mat03);\n  mat.m = min(mat.m, mat04);\n  \n  mat.glow += 0.15/(0.05+abs(mat.m));\n}\nvec3 normals(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map(m01, p);\n   map(m02, p - uv.xyy);\n   map(m03, p - uv.yxy);\n   map(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord/iResolution.xy);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, 5.0, 5.0 + time * 85.0 + mod01 * 5.0), t = vec3(00., 1.5 * sin(time * 0.5) + 4.0, time * 85.0 + mod01 * 5.0 );\n  vec3 fr = normalize(t-o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  vec3 dir = normalize(fr + ri * uv.x + up * uv.y);\n  vec3 p = o + dir * 0.25;\n  \n  \n  matter mat;\n for(int i = 0; i < 100; ++i)\n  {\n    map(mat, p);\n    \n    if(mat.m < 0.01)\n    {\n      mat.m = 0.15;\n      mat.glow *= 0.95;\n      mat.dist -= 0.1 * mat.dist;\n      if(!mat.reflected)\n      {\n        vec3 n= normals(p);\n        dir = reflect(-n, dir);\n        mat.m = 2.5;\n        mat.reflected = true;\n        mat.glow *= 5.95;\n      }\n      \n    }\n    \n    \n    vec3 selCol = vec3(1.0, 1.0, 1.0) * 1.0;\n    if(mod01 > 1.0)\n    {\n      selCol = vec3(0.0, 0.5, 1.0);\n    }\n    if(mod01 > 2.0)\n    {\n      selCol = vec3(0.0, 0.5, 1.0);\n    }\n    \n    mat.col += mat.glow * (0.00010 - (sin(abs(p.z * 0.001 + time * 2.25)) * 0.000155)) * selCol * 0.2325;\n    p+= mat.m * dir * 0.5;\n    mat.dist += 0.5;\n    \n  }\n  \n  mat.col += pow(clamp((mat.dist/100.0), 0.0, 1.0), 1.2) * mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.0), sin(abs(time * 0.1 + (mat.dist/100.0 * 2.5)))) * ((0.8 * mod04)/8.0);\n  \n  mat.col = pow(mat.col, vec3(1.0/2.2));\n  \n  fragColor = vec4(mat.col, 1.0);\n}","name":"Image","description":"","type":"image"}]}