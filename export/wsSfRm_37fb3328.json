{"ver":"0.1","info":{"id":"wsSfRm","date":"1589900089","viewed":124,"name":"ray marching experiments","username":"cankansin","description":"Ray marching, light and shadow experiments.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","shadow","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Hit{\n   vec3 position;\n   vec3 normal;\n   vec3 color;\n   float dist;\n};  \n    \nstruct HitResult{\n   Hit hit;\n   bool valid;\n};  \n\nstruct Sphere{\n   vec3 origin;\n   float radius;\n   vec3 color;\n};\n    \nHit nearestHitSphere(Sphere s, vec3 from){\n    Hit hit;\n    hit.dist = length(from-s.origin)-s.radius;\n    hit.normal = normalize(from - s.origin);\n    hit.position = s.origin + (hit.normal * s.radius);\n    hit.color = s.color;\n    return hit;\n}\n\nstruct Ray{\n   vec3 origin;\n   vec3 direction;\n   float len;\n}; \n    \nstruct Light{\n   vec3 origin;\n   float intensity;\n   vec3 color;\n};  \n    \nHit nearestHitMap(vec3 origin){\n    Sphere[] spheres = Sphere[](   \n        //TODO: This part is creating artifacts and performance issues\n    \t//Sphere(vec3(0.0,  0.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(0.0,  4.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(4.0,  0.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(4.0,  4.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(-4.0, 0.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(0.0,  -4.0, 12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(4.0,  -4.0, 12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(-4.0, 4.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(-4.0, -4.0, 12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(8.0,  -4.0, 12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(-8.0, 4.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(-8.0, -4.0, 12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(8.0,  4.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(-8.0, 0.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        //Sphere(vec3(8.0,  0.0,  12.0),2.0, vec3(1.0, 1.0, 1.0)),\n        \t\t\n        Sphere(vec3( sin(iTime+1.0),  cos(iTime+1.0), 4.0), \t\t        0.4, vec3(0.0, 0.0, 0.5)),\n    \tSphere(vec3(-sin(iTime+1.0), -cos(iTime+1.0), 4.0), \t\t        0.4, vec3(0.5, 0.0, 0.0)),\n    \tSphere(vec3( sin(iTime+2.5), 0.0,  \t\t\t  cos(iTime+2.5)+4.0),  0.4, vec3(0.0, 0.5, 0.0)),\n    \tSphere(vec3(-sin(iTime+2.5), 0.0, \t\t\t  -cos(iTime+2.5)+4.0), 0.4, vec3(0.5, 0.5, 0.0)),\n    \tSphere(vec3(0.0,             sin(iTime+4.0),  cos(iTime+4.0)+4.0),  0.4, vec3(0.5, 0.0, 0.5)),\n    \tSphere(vec3(0.0,             -sin(iTime+4.0), -cos(iTime+4.0)+4.0), 0.4, vec3(0.0, 0.5, 0.5))\n    );\n    \n    Hit nearestHit = nearestHitSphere(spheres[0], origin);\n    for (int i = 1; i < spheres.length(); i++){\n        Hit hit = nearestHitSphere(spheres[i], origin);\n        if (hit.dist < nearestHit.dist){\n        \tnearestHit = hit;\n        }\n    }\n\n    return nearestHit;\n}\n\nHitResult sphereTracing(Ray ray){  \n\tconst int   MAX_STEP = 100;\n\tconst float MIN_DIST = 0.01;\n\n    float rayDistance = 0.0;\n \n    HitResult hitResult;\n    for(int stepCount = 0;  ; stepCount++){\n        hitResult.hit = nearestHitMap(ray.origin + (ray.direction * rayDistance));\n        rayDistance += hitResult.hit.dist;\n        if (hitResult.hit.dist < MIN_DIST){\n            hitResult.valid = true;\n            break;\n        }\n        if ((rayDistance > ray.len) || (stepCount >= MAX_STEP)){\n        \thitResult.valid = false;\n            break;\n    \t}\n    }\n    return hitResult;\n}\n\nvec4 render(Ray ray){\n    Light light = Light(vec3(sin(iTime)*3.0, cos(iTime), 0.0), 25.0, vec3(1.0, 1.0, 1.0));\n      \n    HitResult cameraHit = sphereTracing(ray);\n    if (!cameraHit.valid){\n        return vec4(0.05);\n    }\n    \n  \tfloat diffuseLight = clamp(dot(cameraHit.hit.normal, normalize(light.origin - cameraHit.hit.position)), 0.0, 1.0);\n    float attenuation = light.intensity / (length(light.origin - cameraHit.hit.position) * length(light.origin - cameraHit.hit.position));\n    \n    float shadowCoefficient = 1.0;\n    HitResult lightHit = sphereTracing(Ray(light.origin,normalize(cameraHit.hit.position-light.origin),100.0));\n    if (lightHit.valid && length(lightHit.hit.position-cameraHit.hit.position) > 0.1){\n        shadowCoefficient = 0.3;\n    }\n\n    vec3 reflectColor = cameraHit.hit.color;\n    HitResult reflectHit = sphereTracing(Ray(cameraHit.hit.position+cameraHit.hit.normal*0.1,cameraHit.hit.normal,100.0));\n    if (reflectHit.valid){\n        reflectColor = reflectColor*reflectHit.hit.color;\n    }\n\n    //TODO: this is not the correct way but...\n    return vec4(mix(vec3(cameraHit.hit.color * attenuation * light.color * diffuseLight * shadowCoefficient), reflectColor, 0.05), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = render(Ray(vec3(0.0, 0.0, 0.0), normalize(vec3(vec2((fragCoord-.5*iResolution.xy)/iResolution.y), 1.0)), 100.0));\n}","name":"Image","description":"","type":"image"}]}