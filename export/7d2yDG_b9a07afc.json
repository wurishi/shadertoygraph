{"ver":"0.1","info":{"id":"7d2yDG","date":"1644086355","viewed":207,"name":"Recursive Circle Tree","username":"c0rymcg","description":"recursively branching chrome balls gently spin.\n\nI would like to eventually figure out how to get the chrome effect to do a better job of pointing up, but I haven't figured that out yet.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fractal","chrome","recursion","fordcircles"],"hasliked":0,"parentid":"sdjyDG","parentname":"Fork M-brot wit c0rymcg 628"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.14159\n#define TAU 6.28318\n#define AA 3\n#define maxIterations 5\n\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\nvec2 circleInvert(in vec2 p, in float radius, in vec2 offset){\n    p = (p - offset)/radius;\n    \n    float radius2 = dot(p,p);\n    p = p/radius2;\n    return p*radius + offset;    \n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 aacol=vec3(0.);\n  \n   //mouse control\n   vec2 m = iMouse.xy/iResolution.xy;\n      \n   //this controls the ratio of ball sizes\n   float warp = 0.3;\n  \n  \n   //aa code here\n   for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n     vec2 p = vec2(0.);\n     \n     \n     float smallestGap=20.;\n     \n     vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xy;\n     \n     uv -= 0.5;uv *= 1.3;uv += 0.5;\n     \n     uv.x = 3.5 * (uv.x - 0.5);\n     uv.y = -2.0 * (uv.y - 0.5);\n     p=uv;   \n     \n         //ford circle minis.\n      p.x = p.x/2.;\n      p.y=0.-p.y;\n      p.y = p.y/2.+0.5;\n\n      \n      //diameter of the whole circle is 1.\n      float majorRadius = 0.5;\n      float minorRadius = warp;\n      \n      float miniRadius = majorRadius - minorRadius;\n      \n      //the radius for a circle inversion that will preserve the first circle in the circle chain is sqrt(2minorRadius)\n      //we can imagine the structure of this as a Pappus Chain\n      for(int i = 0; i < maxIterations; i++){\n        //circle invert the point\n\t\tfloat invertRadius = sqrt(2.*minorRadius);\n\t\tp = circleInvert(p, invertRadius, vec2(0));\n\n\t\tif (p.y < majorRadius*2.){\n\t\t\t//now the system is theoretically a horizontal strip of equal circles to infinity\n\t\t\t//modulo horizontally to result in a single circle right in the middle\n\t\t\tp.x = mod(p.x+iTime/20.+m.y, (2.*miniRadius));\n\n\t\t\tif (p.x > miniRadius) p.x-= 2.*miniRadius;\n\n\t\t\tint counter = 0;\n\t\t\t//check to see if the point is now potentially in a Ford Circle\n\t\t\twhile (counter < maxIterations && p.y > majorRadius*2. - miniRadius && distance(p, vec2( 0, minorRadius*2. + miniRadius))>miniRadius){\n\t\t\t\tp = circleInvert(p, miniRadius, vec2(0, majorRadius*2.));\n\n\t\t\t\tp.x = mod(abs(p.x), miniRadius*0.5)+miniRadius;\n\t\t\t\tif (p.x > miniRadius*1.25) p.x = p.x - (miniRadius*0.5);\n\n\t\t\t\tp = circleInvert(p, miniRadius,vec2(0, majorRadius*2.));\n\n\t\t\t\tp.x-=miniRadius;\n\t\t\t\tp.y-=majorRadius*2.;\n\t\t\t\tp.x*=4.;\n\t\t\t\tp.y*=4.;\n\t\t\t\tp.y+=majorRadius*2.;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\n\t\t//back to normal\n\t\tp = circleInvert(p, invertRadius, vec2(0));\n\n\t\t//only do this if the point is not already in the main circle's trap\n\t\tif (distance(p, vec2(0., minorRadius))>minorRadius){\n\t\t\t//stretch the mini circle to the size and position of the whole diameter 1 circle\n\t\t\tp.y = p.y - minorRadius - majorRadius;\n\t\t\tp.x *= majorRadius / miniRadius;\n\t\t\tp.y *= majorRadius / miniRadius;\n\t\t\tp.y = p.y + majorRadius;\n\t\t}\n\t}\n    \n    \n    //do some simple chrome shading//        \n    uv.y*=-1.;\n        \n    vec3 normal;\n        \n    if (distance(p, vec2(0., minorRadius))<minorRadius){\n        //ray*=-1.;\n        p.y=p.y-minorRadius;\n        p=p/minorRadius;\n    \n        float pDist = length(p);\n        normal=vec3(p.x, p.y, sqrt(1.-pDist*pDist));\n    }else{\n        //normal=vec3(uv.x,uv.y,-1);//reveal background\n    }\n\n    //rotate normal using time\n    float nAngle=atan(normal.z,normal.x)-iTime/2.-m.x*3.;\n    float nDist = length(normal.xz);\n    normal.x=cos(nAngle)*nDist;normal.z=sin(nAngle)*nDist;\n    vec3 col = texture(iChannel0, (normal)).rgb;\n    \n\taacol+= col;\n   }\n  }\n  fragColor=vec4(aacol.xyz/float(AA*AA),1.);\n}\n\n","name":"Image","description":"","type":"image"}]}