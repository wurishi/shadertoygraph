{"ver":"0.1","info":{"id":"ssf3D8","date":"1615854097","viewed":117,"name":"Mandelbar Julia Set Zoom","username":"enslow","description":"another fractal ¯\\_(ツ)_/¯","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ryan Enslow March 1, 2021.\n//Mandelbar Fractal (julia set)\n//https://twitter.com/ComplexFractal\n\n#define PI 3.14159\n#define AA 2.\n\n#define CONSTANT vec2(-0.510, -0.412)\n#define CENTER 2.*vec2(-0.048, 0.1765)\n\n#define RE 2.*z.x*z.y+CONSTANT.x\n#define IM z.x*z.x-z.y*z.y+CONSTANT.y\n\n//This technique is outlined in this article by Inigo Quilez. I would highly suggest reading it; it's an amazing technique. https://iquilezles.org/articles/msetsmooth\n#define SMOOTH float(i)-log2(log2(length(z))) + 4.0\n#define COLORFUN 0.5 + 0.5*cos(3.0 + mix(float(i),SMOOTH,1.0)*0.10+vec3(0.059, 0.455, 0.340));\n\n//I've pasted this from Smoothstep so I've just decided to define these here with trig functions.\n#define IFLOAT0 4.*(-cos(iTime/(2.*PI))+2.)\n#define IFLOAT1 5.*(-cos(iTime/(2.*PI))+1.2)\n#define IFLOAT2 10.*smoothstep(0.,38.,mod(iTime,38.))\n\n#define ITERATION 80.\n#define ESCAPE 4.\n\nmat2 rotate(float theta){\n  return mat2(cos(theta),-sin(theta)\n             ,sin(theta), cos(theta));\n}\n\n//Determine the color of a given point after its iterative transformation\n//  z: point in complex plane\n//  i: current iteration\n//  col: output color\nvoid colord (in vec2 z, in float i, out vec3 col, inout bool br){\n  col = vec3(1.0);\n  if (length(z)>ESCAPE){\n    br = true;\n    col = COLORFUN;\n  }\n  else{\n    col = vec3(0.0);\n  }\n}\n\n\n//The complex function to transform a point\nvoid anon (in vec2 z, inout vec3 s, in float t){\n  vec2 c = z; //Original point\n  vec2 temp;\n  bool br;\n  for (float i=0.0; i<ITERATION+exp(IFLOAT0)/IFLOAT0;i += 1.0){\n    colord(z,i,s,br);\n    if (br) break;\n    \n      temp.x = RE;\n      temp.y = IM;\n    z = temp;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 a = iResolution.xy;\n  vec3 s = vec3(1.0);\n  vec3 col = vec3(0.0);\n  \n  float t = exp(IFLOAT1)+1.0;\n  for (float j = 0.; j < AA; j += 1.0){\n    for (float k = 0.; k < AA; k += 1.0){\n      vec2 uv;\n      uv = 10.*rotate(IFLOAT2)*(fragCoord + vec2(j,k)/AA - .5*a.xy)/a.y / t+CENTER;\n      anon(uv,s,t);\n      col += s;\n    }\n  }\n  col /= AA*AA;\n  \n  //fragColor = vec4(mix(col,second,0.2),1.0);\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}