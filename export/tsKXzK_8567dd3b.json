{"ver":"0.1","info":{"id":"tsKXzK","date":"1574482270","viewed":293,"name":"Simple Light Door","username":"ParaBellum","description":"A naive approach to get area light","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","light","arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 A = vec3(-3., 6., 0.); \nvec3 B = vec3(3., 6., 0.); \nvec3 C = vec3(3., 0., 0.); \nvec3 D = vec3(-3., 0., 0.);\nvec3 lightColor = vec3(0.9, .9, .9);\n\nvec3 area_light(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d, out vec3 n)\n{\n    vec3 o = (a+b+c+d)/4.;\n    vec3 ba = b-a;\n    vec3 cb = c-b;\n    vec3 dc = d-c;\n    vec3 ad = a-d;\n    n = normalize(cross(ba, ad));\n    p = p-n*dot(p-o, n);\n    vec3 pa = p-a;\n    vec3 pb = p-b;\n    vec3 pc = p-c;\n    vec3 pd = p-d;\n    float s = 4., l = 100000.;\n    vec3 vo, vh, vd;\n    if (sign(dot(cross(ba, n), pa)) <= -1. && length(pa) < l)\n    {\n        s--; l = length(pa); vo = a; vh = b; vd = pa;\n    }\n    if (sign(dot(cross(cb, n), pb)) <= -1. && length(pb) < l)\n    {\n        s--; l = length(pb); vo = b; vh = c; vd = pb;\n    }\n    if (sign(dot(cross(dc, n), pc)) <= -1. && length(pc) < l)\n    {\n        s--; l = length(pc); vo = c; vh = d; vd = pc;\n    }\n    if (sign(dot(cross(ad, n), pd)) <= -1. && length(pd) < l)\n    {\n        s--; l = length(pd); vo = d; vh = a; vd = pd;\n    }\n    if (s < 4.)\n    {\n        float t = clamp(dot(vh-vo, vd)/dot(vh-vo, vh-vo), 0., 1.);\n        return mix(vo, vh, t);\n    }\n    else\n        return p;\n}\n\n// Quad function from IQ\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat quad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 opU(in vec2 a, in vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 scene(in vec3 p)\n{\n    vec2 plane1 = vec2(p.y, 1.5);\n    vec2 quad1 = vec2(quad(p, A, B, C, D), 2.5);\n    return opU(plane1, quad1);\n}\n\nvec3 getNormal(in vec3 p)\n{\n    float d = scene(p).x;\n    vec2 e = vec2(.1, 0.);\n    vec3 n = d - vec3\n        \t\t\t(\n                        scene(p-e.xyy).x,\n                        scene(p-e.yxy).x,\n                        scene(p-e.yyx).x\n    \t\t\t\t);\n    return normalize(n);\n}\n\nvec2 marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 s = scene(o + d * t);\n        if (s.x < .01)\n            return vec2(t, s.y);\n        t += s.x*.5;\n    }\n    return vec2(-1.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    vec3 o = vec3(0., 3., 10.);\n    vec3 d = vec3(uv, -1.);\n    \n    float T = .6;\n    mat2 rot = mat2(cos(T), sin(T), -sin(T), cos(T));\n    \n    A.xz *= rot;\n    B.xz *= rot;\n    C.xz *= rot;\n    D.xz *= rot;\n    \n    vec2 m = marcher(o, d);\n    int index = int(floor(m.y));\n    if (index != -1)\n    {\n        vec3 p = o + d * m.x;\n        if (index == 1)\n        {\n            vec3 n = vec3(0.);\n            vec3 pl = area_light(p, A, B, C, D, n);\n            float df = dot(normalize(p-pl), n);\n            \n            float l = length(p-pl);\n            float kc = 1.;\n            float kl = .7;\n            float kq = 1.8;\n            float attenuation = 1. / (kc+kl*l+kq*l*l);\n            \n        \tcol += lightColor*df*attenuation;\n        }\n        if (index == 2)\n        {\n            col += lightColor;\n        }\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}