{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Curvature average by nimitz (stormoid.com) (twitter: @stormoid)\n\n/*\n\tThis is a somewhat old technique of coloring fractals, according to the paper\n\t(http://jussiharkonen.com/files/on_fractal_coloring_techniques(lo-res).pdf)\n\tthe technique was devised by Damien Jones in 1999, the idea is to color based\n\tthe sum of the angles of z as it's being iterated.  I am also using a sinus function\n\tin the loop to greate a more \"hairy\" look.\n\n\tI should be converting to hsv to do color blending, but it looks good enough that way.\n*/\n\n#define ITR 80.\n#define BAILOUT 1e10\n\n#define R .35\n#define G .2\n#define B .15\n\n#define time iTime\nmat2 mm2(const in float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\n\n//lerp between 3 colors\n//usage: 0=a | 0.33=b | 0.66=c | 1=a\nvec3 wheel(in vec3 a, in vec3 b, in vec3 c, in float delta)\n{\n\treturn mix(mix(mix( a,b,clamp((delta-0.000)*3., 0., 1.)),\n\t\t\t\t\t\t  c,clamp((delta-0.333)*3., 0., 1.)),\n\t\t\t\t\t\t  a,clamp((delta-0.666)*3., 0., 1.));\n}\n\n//Reinhard based tone mapping (https://www.shadertoy.com/view/lslGzl)\nvec3 tone(vec3 color, float gamma)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec2 render(in vec2 p)\n{\n    //init vars\n\tvec2 c = p, z = p;\n\tvec2 oldz1 = vec2(1);\n\tvec2 oldz2 = vec2(1);\n\tfloat curv = 0.;\n\tfloat rz = 1., rz2 = 0.;\n\tfloat numitr = 0.;\n    \n    for( int i=0; i<int(ITR); i++ )\n\t{\n\t\tif (dot(z,z)<BAILOUT)\n\t\t{\n\t\t\tz = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y)+c;\n\t\t\tvec2 tmp = vec2(1);\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\ttmp = (z-oldz1)/(oldz1-oldz2);\n\t\t\t}\n\t\t\tcurv = abs(atan(tmp.y,tmp.x));\n\t\t\tcurv = sin(curv*5.)*0.5+0.5;\n\t\t\t\n\t\t\toldz2 = oldz1;\n\t\t\toldz1 = z;\n\t\t\trz2 = rz;\n\t\t\trz += (.95-curv);\n\t\t\tnumitr += 1.;\n\t\t}\n\t}\n\t\n\t//Thanks to iq for the proper smoothing formula\n\tfloat f = 1.-log2( (log(dot(z,z))/log(BAILOUT)) );\n\tf = smoothstep(0.,1.,f);\n\t\n\t//linear interpolation\n\trz = rz / numitr;\n\trz2 = rz2 / (numitr-1.);\n\trz = mix(rz2,rz,f);\n    return vec2(rz,rz2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//setup coords and mouse\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tfloat zoom = sin(time*.1+2.)*0.025+0.027;\n    p*= zoom;\n\tvec2 um = iMouse.xy==vec2(0)?vec2(0):(iMouse.xy / iResolution.xy)-0.5;\n\tum.x *= iResolution.x/iResolution.y;\n\tp += um*0.03+vec2(-.483,0.6255);\n\t\n    float px=.75/iResolution.x*zoom;\n    vec2 rz = vec2(0);\n    for (float i=0.; i<4.; i++) \n    {\n        vec2  of = floor(vec2(i/2.,mod(i,2.)));\n\t\trz += render(p+ of*px);\n\t}\n    rz /= 4.;\n    \n\t//coloring\t\n\trz.y = smoothstep(0.,1.2,rz.x);\n\tvec3 col = (sin(vec3(R,G,B)+6.*rz.y+2.9)*.5+0.51)*1.4;\n\tvec3 col2 = vec3(R*(sin(rz.x*5.+1.2)),G*sin(rz.x*5.+4.1),B*sin(rz.x*5.+4.4));\n\tcol2= clamp(col2,0.,1.);\n    vec3 col3 = vec3(R,G,B)*smoothstep(0.5,1.,1.-rz.x);\n    col3 = pow(col3,vec3(1.2))*2.6;\n\tcol3= clamp(col3,0.,1.);\n\tcol = wheel(col,col2,col3,fract((time-20.)*0.015));\n\tcol = tone(col,.8)*3.5;\n    \n\tfragColor = vec4(col,1.);\n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfXzs","date":"1405529758","viewed":3100,"name":"Curvature average","username":"nimitz","description":"Click and drag to move a bit.\nMostly based on Jussi HÃ¤rkÃ¶nen's paper: http://jussiharkonen.com/files/on_fractal_coloring_techniques(lo-res).pdf","likes":66,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot","curvatureaverage"],"hasliked":0,"parentid":"","parentname":""}}