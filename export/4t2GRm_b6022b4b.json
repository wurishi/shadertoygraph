{"ver":"0.1","info":{"id":"4t2GRm","date":"1427708288","viewed":7865,"name":"Tetrahedron with depth","username":"candycat","description":"A rotating tetrahedron. Dased lines and color to offer depth infomation.","likes":58,"published":1,"flags":0,"usePreview":0,"tags":["tetrahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define pi 3.14159265358979\n#define sqrt3_divide_6 0.289\n#define sqrt6_divide_12 0.204\n\nconst float seg = 4.0;\nconst float segwidth = 1./(2.*seg-1.);\n\nfloat _CircleRadius = 0.10;\nfloat _OutlineWidth = 0.02;\nfloat _LineWidth = 0.08;\nvec4 _OutlineColor = vec4(0.,0.,0.,0.);\nvec4 _FrontColor = vec4(186.0/256.0,42.0/256.0,42.0/256.0,1.);\nvec4 _BackColor = vec4(120.0/256.0,30.0/256.0,30.0/256.0,1.);\nvec4 _BackgroundColor = vec4(227./256.,206./256.,178./256.,1.);\n\n//======================\n// Line functions\n//======================\nfloat line(vec2 pos, vec2 point1, vec2 point2, float width) {\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\nvec4 line_with_color(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    float d = line(pos, point1, point2, width);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(_FrontColor.rgb, 1.-smoothstep(-w, w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\n//======================\n// Dashed line functions\n//======================\nfloat dashedline(vec2 pos, vec2 point1, vec2 point2, float width) {\n    vec2 prePoint = point1;\n    vec2 curPoint = point1*(1.-segwidth)+segwidth*point2;\n    float d = 1.;\n    for (float t=segwidth; t<1.01; t+=2.*segwidth) {\n        curPoint = point1*(1.-t)+t*point2;\n        d = min(d, line(pos, prePoint, curPoint, width));\n        prePoint = point1*(1.-(t+segwidth))+(t+segwidth)*point2;\n    }\n    return d;\n}\n\nvec4 dashedline_with_color(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\n    float d = dashedline(pos, point1, point2, width);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(_BackColor.rgb, 1.-smoothstep(0., w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\n//======================\n// Circle functions\n//======================\nfloat circle(vec2 pos, vec2 center, float radius) {\n    float d = length(pos - center) - radius;\n    return d;\n}\n\nvec4 circle_with_color(vec2 pos, vec2 center, float radius, vec4 color) {\n    float d = circle(pos, center, radius);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(color.rgb, 1.-smoothstep(0., w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\n//======================\n// Helper functions\n//======================\nvoid setlayer(inout vec4 layers[6], int index, vec4 val) {\n    if (index == 0) {\n        layers[0] = val;\n    } else if (index == 1) {\n        layers[1] = val;\n    } else if (index == 2) {\n        layers[2] = val;\n    } else if (index == 3) {\n        layers[3] = val;\n    } else if (index == 4) {\n        layers[4] = val;\n    } else if (index == 5) {\n        layers[5] = val;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 originalPos = (2.0 * fragCoord - iResolution.xy)/iResolution.yy;\n    vec2 pos = originalPos;\n\n    // Apply X Y Z rotations\n    // Find more info from http://en.wikipedia.org/wiki/Rotation_matrix\n    float xSpeed = 0.3*iTime+iMouse.x*0.01;\n    float ySpeed = 0.5*iTime+iMouse.y*0.01;\n    float zSpeed = 0.7*iTime;\n    mat3 matrix = mat3(1., 0., 0.,\n                      0., cos(xSpeed), sin(xSpeed),\n                      0., -sin(xSpeed), cos(xSpeed));\n    matrix = mat3(cos(ySpeed), 0., -sin(ySpeed),\n                      0., 1., 0.,\n                      sin(ySpeed), 0., cos(ySpeed))*matrix;\n    matrix = mat3(cos(zSpeed), sin(zSpeed), 0.,\n                 \t  -sin(zSpeed), cos(zSpeed), 0.,\n                 \t  0., 0., 0.)*matrix;\n    \n    float l = 1.5;\n    vec3 p[4];\n    p[0] = vec3(0., 0., sqrt6_divide_12 * 3.) * l;\n    p[1] = vec3(-0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    p[2] = vec3(0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    p[3] = vec3(0, sqrt3_divide_6 * 2., -sqrt6_divide_12) * l;\n\n    for (int i = 0; i < 4; i++) {\n        p[i] = matrix * p[i];\n    }\n    \n    // Compure normals\n    vec3 normalOf012 = cross(p[1]-p[0], p[2]-p[0]);\n    vec3 normalOf013 = cross(p[3]-p[0], p[1]-p[0]);\n    vec3 normalOf023 = cross(p[2]-p[0], p[3]-p[0]);\n    vec3 normalOf123 = cross(p[3]-p[1], p[2]-p[1]);\n\n    vec4 layers[6];\n    int upperLayer = 0;\n    int underlayer = 5;\n    float circleColors[4];\n    for (int i = 0; i < 4; i++) {\n        circleColors[i] = -1.;\n    }\n    \n    if (normalOf012.z < 0. && normalOf013.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[0].xy, p[1].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[0].xy, p[1].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[0] = 1.;\n        circleColors[1] = 1.;\n    }\n    if (normalOf012.z < 0. && normalOf123.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[1].xy, p[2].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[1].xy, p[2].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[1] = 1.;\n        circleColors[2] = 1.;\n    }\n    if (normalOf023.z < 0. && normalOf123.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[2].xy, p[3].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[2].xy, p[3].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[2] = 1.;\n        circleColors[3] = 1.;\n    }\n    if (normalOf023.z < 0. && normalOf012.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[0].xy, p[2].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[0].xy, p[2].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[0] = 1.;\n        circleColors[2] = 1.;\n    }\n    if (normalOf023.z < 0. && normalOf013.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[0].xy, p[3].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[0].xy, p[3].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[0] = 1.;\n        circleColors[3] = 1.;\n    }\n    if (normalOf123.z < 0. && normalOf013.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[1].xy, p[3].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[1].xy, p[3].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[1] = 1.;\n        circleColors[3] = 1.;\n    }\n    \n    // Background\n\tfragColor = vec4(_BackgroundColor.rgb * (1.0-0.2*length(originalPos)), 1.);\n    for (int i = 5; i >= 0; i--) {\n        fragColor = mix(fragColor, layers[i], layers[i].a);\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (circleColors[i] > 0.) {\n            vec4 c = circle_with_color(pos, p[i].xy, _CircleRadius, _FrontColor);\n            fragColor = mix(fragColor, c, c.a);\n        }\n    }\n}","name":"","description":"","type":"image"}]}