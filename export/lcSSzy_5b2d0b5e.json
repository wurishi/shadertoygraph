{"ver":"0.1","info":{"id":"lcSSzy","date":"1708292216","viewed":105,"name":"Basic Kuwahara Filtering","username":"Skelly","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thank you Acerola!\n\n#define quadrant_height 8.\n// Only use if you don't want to use nearest filtering - MUCH better turned off but only works with nearest.\n#define scale_kuwahara_with_image 0\n#define quadrant_height_sq_ci int(quadrant_height * quadrant_height)\n\nvec3 ar_reproject(vec2 uv, int channel)\n{\n    float scr_ratio = iResolution.x/iResolution.y;\n    float img_ratio = iChannelResolution[channel].x/iChannelResolution[channel].y;\n    \n    vec2 img_uv = (uv - vec2(.5)) *\n        vec2(max(1., scr_ratio/img_ratio), max(1., img_ratio/scr_ratio)) + \n        vec2(.5);\n    bool on_screen = img_uv.x >= 0. && img_uv.x <= 1. && img_uv.y >= 0. && img_uv.y <= 1.;\n    \n    return vec3(img_uv, on_screen? 1. : 0.);\n}\n\nvec4 quadrant(vec2 point, vec2 units_per_pixel)\n{\n    float quadrant_height_sq = quadrant_height * quadrant_height;\n    vec3[quadrant_height_sq_ci] set;\n    vec3 average;\n    for (float i = 0.; i < quadrant_height_sq; i++)\n    {\n        vec3 pixelCol = texture(iChannel0, point + vec2(floor(i/quadrant_height),\n            mod(i, quadrant_height)) * units_per_pixel).rgb;\n        set[int(i)] = pixelCol;\n        average += pixelCol;\n    }\n    average /= quadrant_height_sq;\n    float sd = 0.;\n    for (int i = 0; i < int(quadrant_height_sq); i++)\n    {\n        vec3 delta = abs(set[i] - average);\n        sd += max(delta.r, max(delta.g, delta.b));\n    }\n    sd /= quadrant_height_sq;\n    \n    return vec4(average, sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 image_uv = ar_reproject(fragCoord/iResolution.xy, 0);\n    vec2 uv = image_uv.xy;\n    \n    vec2 units_per_pixel;\n    \n    #if scale_kuwahara_with_image\n        units_per_pixel = 1./iResolution.xy;\n    #else\n        units_per_pixel = 1./iChannelResolution[0].xy;\n    #endif\n\n    vec4 quad1 = quadrant(uv, units_per_pixel);\n    vec4 quad2 = quadrant(uv, units_per_pixel * vec2(1., -1.));\n    vec4 quad3 = quadrant(uv, units_per_pixel * vec2(-1., 1.));\n    vec4 quad4 = quadrant(uv, units_per_pixel * -1.);\n    float minsd = min(min(quad1.w, quad2.w), min(quad3.w, quad4.w));\n    \n    vec3 col;\n    \n    if (quad1.w == minsd)\n    {\n        col = quad1.rgb;\n    }\n    else if (quad2.w == minsd)\n    {\n        col = quad2.rgb;\n    }\n    else if (quad3.w == minsd)\n    {\n        col = quad3.rgb;\n    }\n    else\n    {\n        col = quad4.rgb;\n    }\n    \n    fragColor = vec4(image_uv.z > .5? col : vec3(0.), 0);\n}","name":"Image","description":"","type":"image"}]}