{"ver":"0.1","info":{"id":"7ltSWH","date":"1639062359","viewed":168,"name":"RayMarching  VFX T1000","username":"amousa","description":"Shader Inspired By Terminator-ish VFX T1000 amalgemation material\nBasically It's a RayMarching scene with a light source and surface displacement added to the texture of Vandam.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader Inspired By Terminator-ish VFX T1000 amalgemation material\n//Basically It's a RayMarching scene with a light source and surface displacement added to the texture of Vandam\n\nvec3 ballposition = vec3(0.0);\nconst vec3 gradientoffset = vec3(0.001,0.0,0.0);\nfloat disp =0.0;\nvec2 UV =vec2(0,0);\n\nfloat getdistancefromsphere(vec3 p,vec3 target)\n\n{\n  float displacement = sin(25.0 * p.x +atan(iTime*15.0)) * cos(-5.0 *sin(iTime) * p.y) * sin(15.0* p.z+sin(iTime)) * 0.25;\n   disp = displacement*(sin(iTime)/0.5+1.0)+0.0155;\n  // disp = sin(25.0 * p.x) * cos(-5.0* p.y) * sin(5.0* p.z) * 0.25;\n   return length(p-target)-(1.0*texture(iChannel0,UV).r*4.0) + disp;\n}\n\nfloat getdistancefromlight(vec3 p,vec3 target)\n\n{\n   return length(p-target)-0.5;\n}\n\nvec3 calculatenormal(vec3 p,vec3 t)\n\n{\n   vec3 gradient = vec3(0.0);\n   gradient.x = getdistancefromsphere(p+gradientoffset.xyy,t) - getdistancefromsphere(p-gradientoffset.xyy,t);\n   gradient.y = getdistancefromsphere(p+gradientoffset.yxy,t) - getdistancefromsphere(p-gradientoffset.yxy,t);\n   gradient.z = getdistancefromsphere(p+gradientoffset.yyx,t) - getdistancefromsphere(p-gradientoffset.yyx,t);\n   \n   return(normalize(gradient));\n}\n\n\n\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 100;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 10000.0;\n    vec3 ambientcolor = vec3(0.5,0.5,0.5);\n         \n    vec3 diffusecolor = vec3(1.0,1.0,1.0);\n         \n    vec3 lightposition = vec3(0.0,0.0,5.0);\n    \n    vec3 lightcolor = vec3(0.2,0.4,0.65);\n    \n    for(int i=0;i<NUMBER_OF_STEPS;i++)\n    {\n       //\n       vec3 currentposition = ro + rd*total_distance_traveled;\n       \n       float distancetoobject = getdistancefromsphere(currentposition,ballposition);\n       \n       float distancetoolight = getdistancefromlight(currentposition,lightposition);\n       \n       vec3 objectcolor =  vec3(0.0);\n       \n       if(distancetoobject < MINIMUM_HIT_DISTANCE)\n       \n       {         \n         vec3 surfacenormal = calculatenormal(currentposition,ballposition);\n                 \n         vec3 lightdirection = normalize(currentposition - lightposition);\n         \n         objectcolor =  (ambientcolor + disp*10.0 + diffusecolor *lightcolor* dot(surfacenormal,lightdirection));\n         \n          {return objectcolor;}\n       }\n       \n       else if(distancetoolight<distancetoobject && distancetoolight<MINIMUM_HIT_DISTANCE)\n       {\n         //return vec3(0.0,1.0,0.0);\n       }\n       \n       if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n       {\n         break;\n       }\n       total_distance_traveled += distancetoobject;\n       \n    }\n    \n    return vec3(0.0);\n }\n\nvec3 computeRayDirection (vec2 uv,vec3 target,vec3 look,vec3 up)\n{\n   float focallength = 0.75;\n   vec3 cameraforward = -look;\n   vec3 cameraright = normalize(cross(cameraforward,up));\n   vec3 cameraup = normalize(cross(cameraright,cameraforward));\n   return normalize(uv.x*cameraright + uv.y*cameraup + focallength*cameraforward);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cameraposition = vec3(0, -0.5,-5) + vec3(sin(iTime)/4.0);\n    \n    ballposition = vec3(sin(iTime/2.0),cos(iTime)/2.0,sin(iTime));\n    UV = uv;\n    uv = uv-0.5;\n    uv.x = uv.x/0.5;\n    \n    vec3 target = vec3(ballposition+vec3(sin(iTime),cos(iTime),0.0));\n    \n    vec3 look = normalize(cameraposition-target);\n    \n    vec3 up = vec3(0,1,0);\n    \n    vec3 raydirection = computeRayDirection(uv,target,look,up);\n    \n    vec3 raycolor = ray_march(cameraposition,raydirection);\n    \n    fragColor = vec4(raycolor,1);\n}","name":"Image","description":"","type":"image"}]}