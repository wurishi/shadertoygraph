{"ver":"0.1","info":{"id":"ttKBWK","date":"1615100246","viewed":359,"name":"modeling scenes","username":"aganztracy","description":"try to use different kinds of materials done!\ntry to modeling with sdf","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"3lyBWy","parentname":"reflection scenes "},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat getTerrainDist(vec3 p){//p:着色点，此处只用点的平面坐标p.xz layers:山的噪声规模？ \n    //return p.y - getTerrainNoise(p,9)*0.1;////vec3 p, int layers\n    return p.y - getTerrainNoise1(p.xz,1)*0.2;////vec3 p, int layers\n}\n//-----\n\nfloat getDist_plant_cylinder(vec3 p,float h,float r){\n    p.xz *= pow(mix(r*2.,r*3.,smoothstep(0.0,3.,p.y)),1.2);//上细下粗\n    float dist = sdCapsule(p,vec3(0.,h,0.),vec3(0.,0.,0.),.04) - 0.1;\n    return dist;\n}\nfloat getDist_plant_branch(vec3 wp,float h){//h:0.3-1.8\n    float b_s = getDist_plant_cylinder(rotation(wp-vec3(0.25,1.,0.),vec3(0.,0.,1.),-0.74),0.11,0.6)-0.04;//转折处的短枝\n    float b_l = getDist_plant_cylinder(rotation(wp-vec3(0.40,1.28,0.),vec3(0.,0.,1.),-0.05),h,0.50);//长枝干\n    float branch = smin(b_s,b_l,0.13)-0.02;//圆滑连接过渡\n    return branch;\n}\n\nfloat getDist_plant(vec3 p){//画一株植物\n    float dist = getDist_plant_cylinder(p,3.2,0.3);\n   \n    for(float i=0.;i<4.;i++){\n        //float scale = .1*i;\n        float height = 1.12*noise(i*1066.43);\n        float branch1 = getDist_plant_branch(rotation(p-vec3(0.,height*0.4,0.),vec3(0.,1.,0.),1.7*i),height);\n        dist = smin(dist,branch1,0.02);\n    } \n    dist += opDisplace(p,dist)*0.004;//植物上的纹理\n\n    return dist;\n}\n\n//计算从p点出发，继续步进，hit到场景中一点的最短距离\nvec2 GetDist(vec3 p){//返回的x分量为最短距离，y分量指示了该最短距离对应的物体，不同物体y分量不同\n\n    //此处场景中假设只有一个平面和球体，\n    //那么要计算p到平面的最短距离以及p到球体最短距离的较小值\n    \n    vec4 s = vec4(0, 2., 0, 0.6);//球体x,y,z,r\n    float sphereDist = sdSphere(p-s.xyz, s.w);\n    \n    float terrainDist = getTerrainDist(p);\n    //float planeDist = sdPlane(p);//点到地面距离为点的y坐标\n    \n    float cylinderDist = sdCylinder(p,vec3(-0.5,1.61,1.0),vec3(-0.5,1.6,1.05),1.5) - 0.02;\n    //p-vec3(x)是为了设置物体的世界坐标，这样在sd函数中的数字写的简单清晰一些，形成了物体形状后，再平移旋转缩放就会更清晰\n    float plantDist = getDist_plant(p - vec3(0.,0.05,-4.));//p-植物的世界坐标\n    float plantDist1 = getDist_plant(p - vec3(0.,0.05,4.))+0.034;//p-植物的世界坐标\n    float plantDist2 = getDist_plant(p - vec3(-4.,0.05,-12.))+0.034;//p-植物的世界坐标\n   \n    //取（最）较小5\n    vec2 d = vec2(terrainDist,1.);\n    //d = opU(d,vec2(sphereDist,2.));\n    d = opU(d,vec2(cylinderDist,3.));\n    d = opU(d,vec2(plantDist,1.));\n    //d = opU(d,vec2(plantDist1,1.));\n    //d = opU(d,vec2(plantDist2,1.));\n    \n\n    return d;//由此得到了p点到场景中hit到的最近点的距离\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd){\n    //射线以hit到场景中物体的最小距离向前步进\n    vec2 d0=vec2(0.);\n    \n    for(int i=0;i<MAX_STEPS;i++){//在给定的步数下步进\n        vec3 p = ro+rd*d0.x;//当前步进到的点的位置\n        vec2 dS = GetDist(p);//算出从当前点向前步进能hit物体的最短距离\n        d0.x += dS.x;//向前一步，更新当前位置\n        d0.y = dS.y;\n        \n        if(d0.x > MAX_DIST || dS.x <SURF_DIST)//如果ray已经超过设定的最长步进距离或者hit到了某一点\n   \t\tbreak;//不再向前步进\n    }\n    \n    return d0;//返回相机到hit的点的距离\n    //之后根据得到的距离计算材质 颜色 光照。\n}\n\nvec3 GetNormal(vec3 p){//得到着色点的法向量\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy).x,\n        GetDist(p - e.yxy).x,\n        GetDist(p - e.yyx).x);\n    //注意上下两个表达式是一样的\n    //vec3 n = vec3(\n    //   d - GetDist(p - e.xyy).x,\n    //   d - GetDist(p - e.yxy).x,\n    //   d - GetDist(p - e.yyx).x);\n    return normalize(n);\n}\n\n\n//采样纹理\nvec3 sampleTexture(vec3 rd) {\n    return texture(iChannel0, rd).rgb;\n}\nvec3 shading_skyBg(vec3 rd){\n    //return vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec3 sky_col = mix(SKY_COLOR_UP, SKY_COLOR_DOWN, (rd.y+0.2)*0.9);\n    return pow(sky_col, vec3(2.2));\n}\n\n\n//AO = ambiemt occlusion (基于sdf)\n//从当前点出发，沿着点法线方向发射一条迭代前进的“光线”，\n//每一步都用getdist查看当前落点距离周围物体表面的最小距离dd\n//将每次的dd依次叠加（叠加的权重依次减弱）即可得到当前点的环境光遮蔽量\nfloat calcAO( in vec3 pos, in vec3 normal )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )//ao iteration\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;////怎么得到的？？\n        \n        vec3 aoPos =  normal * hr + pos;\n        float dd = GetDist( aoPos).x;\n        \n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float maxt, float lightSize){\n//ro：当前点位置 /rd:光源方向 /mint：“光线”前进起点  /maxt：“光线”最远前进距离 /k:灯光大小？控制阴影的软硬\n    //float res = 1.0;\n    //for( float t=mint; t<maxt; )\n    //{\n    //    float d = map(ro + rd*t);  \n    //}\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )//要步进几次似乎只是看情况设置，在性能和能包括到的距离内权衡吗？\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, lightSize*h/t );//k\n        t += clamp( h, 0.02, 0.10 );\n        if( h< PRECISION || t> maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n    \n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec3 col = vec3(0.);\n    //------skyBg--------\n    vec3 skyColor = shading_skyBg(rd);\n    \n    \n    vec2 res = RayMarch(ro ,rd);//得到当前射线方向能hit到的物体表面的最小距离\n    float d = res.x;\n    float material = res.y;\n    \n    vec3 p = ro + rd * d;//着色点，即从相机发出的射线hit到的物体表面点\n    \n    if(d < MAX_DIST){//如果超过ray的检测最大距离，就采样天空颜色；如果有碰撞到场景中几何体，就进行相应的着色即可\n        \n        //----------------\n        vec3 normal = GetNormal(p);//法线\n        vec3 refDir = reflect(rd, normal);//反射光方向\n        //--------diffuse--------\n        //--点灯光--\n        //vec3 lightPos = vec3(0, 5, 6);\n        //lightPos.xz += vec2(sin(iTime), cos(iTime)) *2.;//让灯光绕圈运动\n        //vec3 lightDir = normalize(lightPos - p);\n  \n        //--平行光--\n        vec3 lightDir = normalize(vec3(-0.5, 0.4, -0.6));\n        //vec3 lightDir = normalize(vec3(5.,3,-1.0));\n        //--环境光--\n        float amb = clamp(0.5 + 0.5*normal.y, 0.0, 1.0);//为什么有个normal.y\n        //--漫反射--\n        float dif = clamp(dot(normal, lightDir), 0., 1.);//dot点乘有可能为负，所以需要clamp\n        //--环境光遮蔽oc--\n        float occ = calcAO(p, normal);\n        //--fresnel reflection term\n        float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n        //--半程向量half--\n        vec3 hal = normalize(lightDir - rd);//rd是从相机屏幕向外射出，- rd 得到了从着色点指向相机的方向，因此lightDir - rd = 2 * half ，最后normalize一下则得到方向\n        //-specular--\n        float spe = pow(clamp(dot(normal,hal), 0.0, 1.0),128.0) * dif;\n        \n        //采样cubemap\n        vec3 reflection = sampleTexture(refDir);\n        \n        //--hardshadow--\n        //从着色点p向着灯光方向l发射ray 进行march，如果距离小于灯光到该点的距离，则说明该点没有直接照射到灯光，处于阴影之下。\n        //由于着色点p实际上是在某个物体的表面点，因此距离本身所在的物体极近，为了不让该射线hit到自身，因此p点要做一点小小的偏移n*SURF_DIST\n        //如果场景还是有问题，就再把该偏移拉大一点，所以此处乘以2.了\n        //float d_p_to_light = RayMarch(p+normal*SURF_DIST*2., light);\n        //if(d_p_to_light < length(lightPos-p))  dif *= .1;//乘以一个小点的数，表示阴影。或者也可直接设置成0；\n        \n        //-softshadow--\n        dif *=softShadow(p+normal*SURF_DIST*2., lightDir, SOFT_SHADOW_START, SOFT_SHADOW_FAR, LIGHT_SIZE);\n        \n\n        \n        \n        //合并不同着色项 为什么乘以occ？？？\n        vec3 lin = vec3(0.0);\n        lin += 0.80*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        //lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        //lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        \n        col = skyColor * lin;//只是单纯得加一个渐变色，为了好看而已\n        \n        //镜子反射\n        if(material == 3.0){\n           col = reflection;\n        }\n\n        \n  \n        //col = lin;\n        \n        //col += 10.00*spe*vec3(1.00,0.90,0.70);\n        \n        //col = vec3(occ);\n    }else{\n        col = skyColor;//一个渐变背景\n        \n    }\n    \n    //--fake fog--\n    float fog = smoothstep(0.0, MAX_DIST, d);\n    fog = pow(fog,0.5);\n    col = mix(col, skyColor, fog);\n    \n    //col = vec3(fog);//for test\n    return clamp(col, .0, 1.0);\n}\n\n// camera to world \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )//rayorigin相机位置 lookat-target目标位置\n{\n\tvec3 cw = normalize(ta-ro);//相机拍摄的forward vector\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);//world up vector（此处只是计算的一个中间量）\n\tvec3 cu = normalize( cross(cw,cp) );//相机屏幕u方向的 right vector\n\tvec3 cv = normalize( cross(cu,cw) );//相机屏幕v方向的 up vector\n    return mat3( cu, cv, cw );\n}\n\n\n//------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord)/iResolution.xy-0.5;//仅仅把uv坐标映射到-0.5～0.5，u和v的单位长度不一致，因此画面会拉伸\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;//为了让屏幕坐标原点在屏幕中心，且xy轴伸缩一致\n    \n    \n    ///--------camera--------\n    \n    //（直接设置相机位置及其方向），该相机是一个正交相机\n    //vec3 ro=vec3(0,1,0);//ray origin-->camera position\n    //vec3 rd=normalize(vec3(uv.x,uv.y,1));// 根据相机位置和屏幕uv得到从相机发出的ray的direction\n \n    \n    //（根据鼠标位置绕目标旋转），该相机是一个针孔相机？\n    //ray origin 相机位置, iTime后乘积是为了让屏幕自动旋转\n    vec3 ro = vec3(sin(iMouse.x / iResolution.x*3. + iTime*0.1) * 10., 2.0, cos(iMouse.x / iResolution.x*3. + iTime*0.1) * 10.);\n    //camera target\n    vec3 ta = normalize(vec3(0.0, 0.1, 0.0));\n    //根据相机的参数求到相机变换矩阵ViewMat ca\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(uv.xy,2.0) );//相机屏幕在z轴为2.0处，ra为从相机出发射向屏幕的ray的raydirection\n    \n    \n    ///--------render--------\n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction ：1/2.2 = .4545\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DIST 90.\n#define SURF_DIST .01\n//Lightsize越小越像阴天，阴影柔和到看不见；越大越像晴天，阴影越来越硬\n#define LIGHT_SIZE 2.5 \n#define SOFT_SHADOW_START .02\n#define SOFT_SHADOW_FAR 2.5\n\n#define PRECISION 0.001\n\n#define SKY_COLOR_UP  vec3(0.9, 0.82, 0.82)\n#define SKY_COLOR_DOWN  vec3(0.7, 0.9, 0.95)\n\n#define MAX_VIEW_DISTANCE 30.0\n\n//注意define的时候不要写=符号哦\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\nfloat sdPlane( vec3 p )//p离地面的高度\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )//p球心 a半径\n{\n    return length(p)- s;\n}\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)//p射线发射点 a柱体一头pos，b柱体另一头pos,中间柱体半径\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )////p射线发射点 a柱体一头pos，b柱体另一头pos,中间柱体半径\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//用来取sdf的最短距离，x分量是距离，y分量用来区别不同材质，\n//感觉这个函数改个更形象的名字更好？\nvec2 opU( vec2 d1, vec2 d2 )//union sfd的并操作？\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n// polynomial smooth min (k = 0.1); \n//和opU一样的并操作，但是会平滑过渡\n//这样平滑的相交适用于两个部分都是同个物体，材质一样。因此此处只返回了距离，而非带着材质因子的vec2\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//float smin( float a, float b, float k )\n//{\n//    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n//    return mix( b, a, h ) - k*h*(1.0-h);\n//}\n\n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n//---------------------------\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\n\n//----\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//https://www.shadertoy.com/view/XsVGz3 --- candycat\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    // add animation\n    //p = p - vec3(1.0, 1.0, 0.0) * iTime * 0.1;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n//-----------\n//fbm!!!还是要弄懂才可以呀。\nfloat getTerrainNoise(vec3 p, int layers){\n    vec2 pos = p.xz * 0.3;//调整地形的宽高比例\n    \n    float h = 0.;\n    float s = 1.0;\n    for (int i = 0 ; i < layers ; i++) {\n        h += s*noise(vec3(pos, 1.));\n        pos = m2 * pos * 3.01;\n        s *= 0.334;\n    }\n    h *= 25.;\n    return h;\n}\n\n//https://www.shadertoy.com/view/WsS3zG\n//Mountain height\n//Useful functions\n#define POW4(x) x*x*x*x\n#define POW2(x) x*x\n\n//terrain generation\n#define NOISE_LAYERS 5\n#define NOISE_Q 0.32\n#define NOISE_MUL 2.6\n#define NORMAL_NOISE_LAYERS 6\n#define MAX_HEIGHT 8.0\nfloat hash(vec2 v)\n{\n \treturn fract(sin(dot(v, vec2(51.2838, 8.4117))) * 2281.2231); \n}\n\nfloat getNoise(vec2 v)\n{\n \tvec2 rootV = floor(v);\n    vec2 f = smoothstep(0.0, 1.0, fract(v));\n\n    vec4 n;\n    n.x = hash(rootV);\n    n.y = hash(rootV + vec2(0.0, 1.0));\n    n.z = hash(rootV + vec2(1.0, 0.0));\n    n.w = hash(rootV + vec2(1.0, 1.0));\n    \n    n.xy = mix(n.xz, n.yw, f.y);\n    return mix(n.x, n.y, f.x);\n}\n\nfloat getTerrainNoise1(vec2 v, int layers)\n{\n    float bigNoise = (getNoise(v * 0.16));\n    \n    float smallNoise = smoothstep(0.7, 1.0, getNoise(v * 30.0));\n    smallNoise *= POW4(smallNoise) * 0.003 * bigNoise;\n    \n \tfloat noise = 0.0;\n    float noiseStrength = 1.0;\n    \n    for(int i = 0; i < layers; i++)\n    {\n     \tnoise += pow(getNoise(v), 2.5 - noiseStrength) * noiseStrength * sqrt(bigNoise);\n        v *= NOISE_MUL;\n        noiseStrength *= NOISE_Q;\n    }\n    \n    noise *= (1.0 - NOISE_Q)/(1.0 - pow(NOISE_Q, float(NOISE_LAYERS)));\n\n    bigNoise *= bigNoise;\n    bigNoise *= (MAX_HEIGHT - 1.0);\n    return (noise + bigNoise + smallNoise);\n}\n\n\n//----\n\nfloat opDisplace(vec3 p,float d){//植物的displacement\n    return d+sin(100.*p.x)*sin(100.*p.y)*sin(100.*p.z);\n}\n//float opDisplace1(vec3 p,float d){//植物的displacement\n    //return d + getTerrainNoise1(p.xy,9)*6.;\n//}\n","name":"Common","description":"","type":"common"}]}