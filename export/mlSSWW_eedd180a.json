{"ver":"0.1","info":{"id":"mlSSWW","date":"1676439422","viewed":255,"name":"physarum","username":"grrrwaaa","description":"messing around with physarum modeling, borrowing ideas from @wyatt ","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["physarum"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 OUT, in vec2 U ) {\n    \n    vec4 a = A(U);\n    vec4 b = B(U);\n    \n    OUT = a;\n    \n    // particles\n    //OUT = vec4(b.xy/R, b.z, 1.);\n    //OUT = vec4(hsl2rgb(vec3(b.z, 0.5, 0.5)), 1.);\n    \n    float dist = length(U - b.xy);\n    \n    OUT = mix(OUT, vec4(exp(-dist)), show_particles);\n    \n    //OUT = vec4(dist * 0.01);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define R iResolution.xy\n#define dt iTimeDelta\n\n#define A(U) texture(iChannel0, (U)/R)\n#define B(U) texture(iChannel1, (U)/R)\n#define C(U) texture(iChannel2, (U)/R)\n#define D(U) texture(iChannel3, (U)/R)\n\n#define pi 3.141592653589793\n\n#define twopi (pi*2.)\n\n\nfloat blur_rate = 28.;\nfloat decay_rate = 0.97;\nfloat deposit_rate = 12.;\n\nfloat sensor_angle = pi * 0.2;\nfloat sensor_distance = 10.;\n\nfloat turn_angle = pi * 0.005;\nfloat wander_angle = pi * 0.01;\nfloat speed = 80.;\n\nfloat spawn_distance = 10.;\nfloat spawn_threshold = 0.5;\nfloat spawn_mix = 0.;\n\nfloat show_particles = 0.1;\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n// distance from point p to the nearest point on the line a->b\nfloat line (vec2 p, vec2 a, vec2 b) {\n    // position on line a+tb\n    float t = dot(p-a,b-a)/dot(b-a,b-a); \n    // clamp to line bounds:\n    t = clamp(t,0.,1.);\n    // nearest point:\n    vec2 n = a + t*(b-a);\n    // distance to that point:\n\treturn length(p-n);\n}\n\nmat2 rotate_mat(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Trails\n\nvec4 init(in vec2 U) {\n    vec2 uv = U/R - 0.5;\n    return vec4(length(uv) < 0.3 ? 0.5 : 0.);\n    \n    // manhattan:\n    float g = 100.;\n    vec2 q = g * (floor(U/g)+0.5);\n    vec2 rel = 2.*(U-q)/g;\n    //float dist = length(rel);\n    float dist = max(abs(rel.x), abs(rel.y));\n    return vec4(smoothstep(0.9, 1., dist));\n}\n\nvoid mainImage( out vec4 OUT, in vec2 U ) {\n    \n    vec4 c = A(U);\n    OUT = c;\n    // blur:\n    /*\n    vec4 sum = vec4(0.);\n    for (float y=-1.; y<=1.; y++) {\n        for (float x=-1.;x<=1.;x++) {\n            sum += A(U+vec2(x,y));\n        }\n    }\n    vec4 avg = sum/ 9.;\n    */\n    vec4 n = A(U+vec2(0,1));\n    vec4 s = A(U+vec2(0,-1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 w = A(U+vec2(-1,0));\n    vec4 avg = 0.25*(n+s+e+w);\n    \n    OUT = mix(c, avg, blur_rate * dt);\n    \n    // decay:\n    OUT *= decay_rate;\n    \n    // find nearest particle:\n    vec4 b = B(U);\n    float dist = length(U-b.xy);\n    // deposit:\n    OUT += vec4(deposit_rate * dt * exp(-dist*dist));\n    \n    if (iFrame == 0) OUT = init(U);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// particles\n// .xy is pos, in pixels\n// .z is direction\n\nvec4 getfield(in vec2 U) {\n    return mix(A(U), C(U), 0.95);\n}\n\nvec4 init(in vec2 U) {\n\n    // grid:\n    float g = 30.;\n    U = g*floor(U/g);\n    float a = rand(U/R);\n    //return vec4(U, a, 1.);\n    \n    return vec4(R/2., a, 1.);\n}\n\nvoid swap (inout vec4 Q, vec2 U, vec2 r) {\n    // Q is our current estimated nearest particle\n    // n is the particle at a pixel nearby\n\tvec4 n = B(U+r); \n    // if n is closer to our pixel coordinate, pick that one instead (via Q=n)\n    if (length(U-n.xy) < length(U-Q.xy)) Q = n;\n}\n\nvoid mainImage( out vec4 OUT, in vec2 U ) {\n\n    // FIND NEAREST PARTICLE\n    vec4 P = B(U);\n    \n    // in each axis consider a couple of steps:\n    // if particle.xy there is actually closer to our pixel, use that particle instead\n    if (true) {\n        for (int y=-2; y<=2; y++) {\n            for (int x=-2; x<2; x++) {\n                vec4 n = B(U+vec2(x, y));\n                if (length(U-n.xy) < length(U-P.xy)) P = n;\n            }\n        }\n    } else {\n        // cheaper but less accurate version:\n        swap(P,U,vec2(1,0));\n        swap(P,U,vec2(0,1));\n        swap(P,U,vec2(-1,0));\n        swap(P,U,vec2(0,-1));\n        swap(P,U,vec2(2,2));\n        swap(P,U,vec2(2,-2));\n        swap(P,U,vec2(-2,2));\n        swap(P,U,vec2(-2,-2));\n    }\n    \n    \n    vec4 a = A(P.xy);\n    \n    float dist = length(U - P.xy);\n    \n    \n    \n    \n    //if (spawn_mix)\n    // spawn if particle is too far away\n    if (dist > spawn_distance && a.r > spawn_threshold) {\n        P.xy = mix(P.xy, U, spawn_mix);\n        P.z = rand(P.xy);\n    }\n    \n    \n    //P.xy = mix(P.xy, U, spawn_mix);\n    \n    // now we have our nearest particle\n    // get direction matrix:\n    mat2 rot = rotate_mat(twopi * P.z);\n    \n    //P.z = mod(P.z - 0.01, 1.);\n    \n    \n    if (true) {\n    \n        // this could all be precomputed:\n        float sd = sensor_distance * a.x*a.x;\n        mat2 sense_rot = rotate_mat(sensor_angle);\n        vec2 s1 = vec2(sd, 0.);\n        vec2 s2 = sense_rot * s1;\n        vec2 s0 = s1 * sense_rot;\n\n        // traslate & rotate by particle into world space:\n        s0 = P.xy + rot*s0;\n        s1 = P.xy + rot*s1;\n        s2 = P.xy + rot*s2;\n\n        // read field at sensor:\n        float f0 = getfield(s0).x;\n        float f1 = getfield(s1).x;\n        float f2 = getfield(s2).x;\n\n        if (true) {\n            // Jeff Jones version\n            if (f0 > f2 && f0 > f1) {\n                // turn left:\n                P.z = mod(P.z - turn_angle, 1.);\n            } else if (f2 > f0 && f2 > f1) {\n                // turn right:\n                P.z = mod(P.z + turn_angle, 1.);\n            } else if (f0 > f1 && f2 > f1) {\n                // turn randomly\n                //wander\n                P.z = mod(P.z + wander_angle*(rand(P.xy)-0.5), 1.);\n            } else {\n                // no turn\n            }\n        } \n    \n    }\n\n    // move it:\n    rot = rotate_mat(twopi * P.z);\n    P.xy += (rot * vec2(speed*dt*a.r, 0.));\n    \n    // clamp at borders:\n    //P.xy = clamp(P.xy, vec2(0.5), vec2(R-0.5));\n    \n    OUT = P;\n    \n    if (iFrame == 0) OUT = init(U);\n    \n    if (U.x < R.x/2.+1. && U.x > R.x/2.-1. && U.y < R.y/2.+1. && U.y > R.y/2.-1.) {\n        OUT = vec4(R/2., rand(iTime), 1.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}