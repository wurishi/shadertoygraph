{"ver":"0.1","info":{"id":"Wsd3zr","date":"1567789007","viewed":383,"name":"Infinite spheres in spheres","username":"TambakoJaguar","description":"I wanted to do something simple but infinite, inspired by something I saw on the TV.\nI hope you like it.\nUse mouse to move around!","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["mouse","patterns","colorful","sphere","animation","reflections","infinite","opening","futuristic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Infinite spheres in spheres\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n//#define shadow\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.31;\n\n// Specular options\nconst float specint = 0.41;\nconst float specshin = 28.;\n\n// Shadow options\nconst float shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0005;\nconst float maxdist = 50.;\n\n// Color options\nconst vec3 sphere_color = vec3(1., 0.3, 0.2);\nconst vec3 floor_color = vec3(0.5, 0.55, 0.6);\n\n// Geometry options\nfloat sphereR = 1.5;\nconst float sizeFact1 = 0.94;\nconst float sizeFact2 = 0.85;\n\n// Timing options\nconst float period = 16.;\nconst float startTime = 0.;\n\n// Campera options\nvec3 campos = vec3(12., 0., 0.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 6.5;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define SPHERE_OBJ    5\n    \nLamp lamps[2];\nvec3 colors[6];\n\nvoid init()\n{\n    sphereR/= pow(pow(sizeFact2, 6.), mod((iTime + startTime)/period, 1.));\n    \n    float c = 0.25;\n    colors[0] = vec3(1., c, c);\n    colors[1] = vec3(c, 1., c);\n    colors[2] = vec3(c, c, 1.);\n    colors[3] = vec3(c, 1., 1.);\n    colors[4] = vec3(1., c, 1.);\n    colors[5] = vec3(1., 1., c);      \n    \n    lamps[0] = Lamp(vec3(-6., 7., -2.), vec3(1., 1., 1.), 1.1, 0.01);\n    lamps[1] = Lamp(vec3(7., 13., 8.), vec3(0.7, 0.8, 1.), 0.85, 0.01);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdCylinder(vec3 p, vec2 h, float t, float rr)\n{\n    h-= vec2(rr);\n    vec2 d = abs(vec2(length(p.xz*(1. + t*p.y)),p.y)) - h;\n    return -rr + min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat getStime(float i)\n{\n   float time2 = max(0., mod(iTime + startTime, period) - (i - 1.)*period/6.);\n   return clamp(6.*time2/period, 0., 1.);    \n   //return smoothstep(-0.1, 1., clamp(6.*time2/period, 0., 1.));\n}\n\nfloat getOpening(float i, float sphere, vec2 o, vec2 o2, float f)\n{\n   float aa = getStime(i)*pi;\n   float rf = pow(sizeFact2, i - 1.);\n    \n   float angle;\n   if (i>3.)\n   {\n      angle = asin(o2.x/(sphereR*rf))*sign(o2.y);\n      aa+= 0.05*smoothstep(-0.8, 0.8, sin(angle*15.*(sphereR*rf)));\n   }\n    \n   float b = 0.09 - 0.27*smoothstep(0.5, 0.05, aa) + clamp(0.2*(1. - sqrt(1. - pow(f*(sphere+0.045), 2.))), 0., 0.1);\n   float c;\n   if (aa<pi*0.5)\n      c = min(rotateVec(o, aa).x + b, -rotateVec(o, -aa).x + b);\n   else\n      c = max(rotateVec(o, aa).x + b, -rotateVec(o, -aa).x + b);\n    \n   return c;\n}\n\nfloat map_sphere0(vec3 pos, float r, float level)\n{\n   float rf = pow(sizeFact2, level - 1.);\n    \n   float outside = length(pos) - r*rf;\n   float inside = length(pos) - r*sizeFact1*rf;\n    \n   return max(outside, -inside);\n}\n\nfloat map_sphere(vec3 pos, float level)\n{\n   float sphere = map_sphere0(pos, sphereR, level);\n   float c = getOpening(level, sphere, mod(level, 2.)==1.?pos.zx:pos.yx, mod(level, 2.)==1.?pos.yz:pos.zy, 16.);\n    \n   float rf = pow(sizeFact2, level - 1.);\n   if (level==3.)\n   {\n      float a1 = atan(pos.x, pos.y);\n      float s1 = sin(a1*16.)*smoothstep(sphereR*0.97*rf, sphereR*0.8*rf, abs(pos.z)); \n      sphere-= 0.022*smoothstep(0.6, 1.3, s1);\n   }\n   if (level==5.)\n   {\n      float a1 = atan(pos.x, pos.y) + pos.z/(sphereR*rf);\n      float a2 = atan(pos.x, pos.y) - pos.z/(sphereR*rf);\n      float s1 = sin(a1*28.)*smoothstep(sphereR*0.97*rf, sphereR*0.88*rf, abs(pos.z)); \n      float s2 = sin(a2*28.)*smoothstep(sphereR*0.97*rf, sphereR*0.88*rf, abs(pos.z)); \n      sphere+= 0.03*smax(smoothstep(0.6, 1.5, s1), smoothstep(0.6, 1.5, s2), .5);\n   }    \n    \n   return max(sphere, c);\n   //return max(max(sphere, c), pos.y);\n}\n\nfloat map_sphere7(vec3 pos)\n{\n   return map_sphere0(pos, sphereR, 7.);\n}\n\nvec2 map(vec3 pos)\n{ \n    float sphere1 = map_sphere(pos, 1.);\n    float sphere2 = map_sphere(pos, 2.);\n    float sphere3 = map_sphere(pos, 3.);\n    float sphere4 = map_sphere(pos, 4.);\n    float sphere5 = map_sphere(pos, 5.);\n    float sphere6 = map_sphere(pos, 6.);\n    float sphere7 = map_sphere7(pos);\n    \n    vec2 res = vec2(sphere7, SPHERE_OBJ);\n    \n    if (getStime(1.)<1.)\n       res = opU(res, vec2(sphere1, SPHERE_OBJ));\n    if (getStime(2.)<1. && getStime(1.)>0.)\n       res = opU(res, vec2(sphere2, SPHERE_OBJ + 1));\n    if (getStime(3.)<1. && getStime(2.)>0.)\n       res = opU(res, vec2(sphere3, SPHERE_OBJ + 2));\n    if (getStime(4.)<1. && getStime(3.)>0.)\n       res = opU(res, vec2(sphere4, SPHERE_OBJ + 3));\n    if (getStime(5.)<1. && getStime(4.)>0.)\n       res = opU(res, vec2(sphere5, SPHERE_OBJ + 4));\n    if (getStime(6.)<1. && getStime(5.)>0.)\n       res = opU(res, vec2(sphere6, SPHERE_OBJ + 5));     \n      \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 130; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.5;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat h = map(ro + rd*t).x;\n        res = min( res, 24.0*h/t );\n        t += clamp( h, 0.0, 0.80 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    //return texture(iChannel0, ray).rgb;\n    \n    float axz = atan(ray.x, ray.z);\n    float sc = mix(0.7, 0.15, smoothstep(-1., 0., ray.y));\n    sc+= 0.4*smoothstep(0., 0.02, ray.y);\n    sc+= 0.4*smoothstep(0., 1., ray.y);\n    \n    sc+= 2.5*(smoothstep(0.4, 0.42, ray.y) - smoothstep(0.58, 0.6, ray.y))*smoothstep(0.5, 0.7, sin(axz*8.));\n    //sc+= 0.6*(smoothstep(0.65, 0.77, ray.y) - smoothstep(0.85, 0.87, ray.y))*smoothstep(0.5, 0.7, sin(axz*5.));\n    \n    float cc1 = pow(smoothstep(0.01, -0.01, ray.y) - smoothstep(0., -1.1, ray.y), 1.5);\n    float cc2 = pow(smoothstep(-0.4, -0.99, ray.y), 2.1);\n    sc*= (1. - cc1*smoothstep(0.98 - cc2*2.1, 1., sin(axz*15.)));\n    sc*= (1. - cc1*smoothstep(0.98 - cc2*2.5, 1., sin(ray.y*35.)));\n    \n    sc*= 1. + 0.5*sin(axz)*cc1;\n    \n    return vec3(sc);\n}\n\nvec3 getSphereColor(int objnr)\n{\n   return colors[objnr - SPHERE_OBJ];\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr>=SPHERE_OBJ)\n      return getSphereColor(objnr);   \n   if (objnr==SKY_OBJ)\n      return getSkyColor(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n  \n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm);\n\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist, false);\n  \tvec3 col = traceinf.col;\n    \n    #ifdef reflections\n    float rf;\n    if (traceinf.objnr!=SKY_OBJ)\n    {\n       rf = fresnel(ray, traceinf.norm, 4.5);\n       int objnr = traceinf.objnr; \n       vec3 refray = reflect(ray, traceinf.norm);\n       traceinf = trace0(traceinf.pos, refray, maxdist*0.5, false);\n       col = mix(col, mix(getSphereColor(objnr), vec3(1.), 0.4)*traceinf.col, rf);\n    }\n    #endif\n    \n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"}]}