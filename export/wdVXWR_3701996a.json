{"ver":"0.1","info":{"id":"wdVXWR","date":"1573812255","viewed":1017,"name":"Fireball 2","username":"vegardno","description":"Asdf","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["sun","fire","supernova","fireball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// max(A, B)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 glow = fire_color(2.) * max(0., 1.3 - 1.8 * length(fragCoord - .5 * iResolution.xy ) / iResolution.y );\n\tvec3 col0 = texture(iChannel0, uv).rgb;\n    vec3 col1 = texture(iChannel1, uv).rgb;\n    fragColor = vec4(.09 * glow + max(col0, .8 * col1), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        v.x, v.y, v.z, 1\n    );\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// intersect ray with sphere to find\n//  - the distance to the sphere\n//  - and the point of intersection on the sphere\n// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/\nfloat intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius)\n{\n    vec3 oc = origin - center;\n    float a = dot(direction, direction);\n    float b = 2. * dot(oc, direction);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.) {\n        // no intersection?\n        return -1.;\n    } else {\n        return (-b - sqrt(disc)) / (2. * a);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 mvp = rotate(radians(0. * iTime), vec3(0, 1, 0));\n    \n\tvec3 dir = (mvp * vec4(rayDirection(120.0, iResolution.xy, fragCoord), 1.)).xyz;\n    vec3 eye = (mvp * vec4(0., 0., 1.9, 1.)).xyz;\n\n    vec3 sphere_pos = vec3(0., 0., 0.);\n\n    float intensity = 0.;\n    \n    mat4 tex_mat = mat4(1.);\n    mat4 wind_mat = mat4(1.);\n    for (int i = 0; i < 10; ++i) {\n        float dist = intersect_ray_sphere(eye, dir, sphere_pos, 1. - float(i) / 40.);\n\n        if (dist > 0.) {\n            vec3 hit_pos = eye + dir * dist;\n            vec3 t_hit_pos = (tex_mat * wind_mat * vec4(hit_pos, 1.)).xyz;\n            vec3 normal = normalize(t_hit_pos - sphere_pos);\n\n            float alpha = texture(iChannel0, 1. / float(i) * vec2(atan(normal.z, normal.x) / radians(90.), normal.y)).r;\n\t\t\tintensity += step(1. - float(i) / 6., alpha) * .8 * alpha * max(0., dot(vec3(0, 0, 1.), hit_pos));\n\n            tex_mat = rotate(radians(11.) * iTime, normalize(vec3(.3, -.7, .1))) * tex_mat;\n            wind_mat = rotate(radians(25.) * iTime, normalize(vec3(1., 0., 0.))) * wind_mat;\n        }\n    }\n\n\tfragColor = vec4(fire_color(intensity), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float A = 1.;\n\tconst int N = 2;\n\n    vec4 col = vec4(0);\n    for (int yoff = -N; yoff <= N; ++yoff) {\n        for (int xoff = -N; xoff <= N; ++xoff) {\n            vec2 off = vec2(xoff, yoff);\n            vec2 uv = (fragCoord + A * off) / iResolution.xy;\n            col += texture(iChannel0, uv) / (.5 + 1. * length(off / vec2(N, N)));\n        }\n    }\n\n    fragColor = vec4(col.rgb / float((N + N) * (N + N)), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 fire_color(float x)\n{\n\treturn\n        // red\n        vec3(1., 0., 0.) * x\n        // yellow\n        + vec3(1., 1., 0.) * clamp(x - .5, 0., 1.)\n        // white\n        + vec3(1., 1., 1.) * clamp(x - .7, 0., 1.);\n}","name":"Common","description":"","type":"common"}]}