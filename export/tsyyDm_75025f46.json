{"ver":"0.1","info":{"id":"tsyyDm","date":"1614462578","viewed":81,"name":"Star-to-Sun","username":"snolot","description":"test raymarching with tween.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R\t\t\tiResolution\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n#define PI          3.1415926\n\n#define MINDIST     .001\n#define MAXDIST     75.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\nfloat tt, g;\nmat2 rTm;\nfloat ga1,ga2,ga3,ga4,ga5,ga6;\nfloat scatter =0.;\nmat2 rotA,rotB,spin;\n\nvec2 sdBox(vec3 p,vec3 r, float id){\n    p=abs(p)-r;\n    return vec2(max(max(p.x,p.y),p.z),id);\n} \n\n\nvec2 map(in vec3 pos)\n{\t\n    \n    vec2 d = vec2(1e10, 0.0);\n   \tpos.zy-=-.3;\n   // pos.yx *= rotA;\n   // pos.xz *= rotB;\n    // map stuff\n \tvec3 q = pos-vec3(0.,-0.3,-.3);\n   //q.y = mod(q.y, 2.5) - 1.25;\n \tq.yx *= r2(.95);\n    //q=abs(q)-2.5 * ga1+ga2+ga3+ga4+ga5;\n    pModPolar(q.xy,7.);\n    pMirrorOctant(q.xy, vec2(.7,.4),(ga1+ga2+ga3+ga4+ga5));\n    \n    d = min(d, sdBox(q, vec3(.1, .9, .05), .5));\n    d = max(d, -sdBox(q, vec3(.2, 1.1, .02), .5));\n    d = max(d, -sdBox(q, vec3(.04, 1.1, .08), .5));\n   \t\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tvec2 h = map( ro + rd*t );\n        res = min( res, k*h.x/t );\n        t += clamp( h.x, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord.y += .2*tan(-.5*(iTime+1.4*sin(iTime*.8+.05))+.6*fragCoord.y/iResolution.y);\n    \n   tt=mod(iTime,62.8318);\n   rTm = r2(T*.5);\n\n    // pixel screen coordinates\n    vec2 uv = (fragCoord.xy - R.xy*0.5)/R.y;\n    vec3 C = vec3(0.);\n    vec3 FC = vec3(.02);\n\n    float tf = mod(T, 14.);\n    // move x steps in rotation\n    float t1 = linearstep(0.0, 1.0, tf);\n    float t2 = linearstep(3.0, 4.0, tf);\n    float a1 = easeInCubic(t1);\n    float a2 = easeOutCubic(t2);\n\n    float t3 = linearstep(5.0, 6.0, tf);\n    float t4 = linearstep(7.0, 8.0, tf);\n    float a3 = easeInCubic(t3);\n    float a4 = easeOutCubic(t4);\n\n    float t5 = linearstep(10.0, 11.0, tf);\n    float t6 = linearstep(12.0, 13.0, tf);\n    float a5 = easeInCubic(t5);\n    float a6 = easeOutCubic(t6);\n\n\tga1 = (a1-a3);\n    ga2 = (a3-a5);\n    ga3 = (a5-a6);\n    ga4 = (a2-a3);\n    ga5 = (a3-a4);\n    ga6 = (a1-a2);\n    \n   vec3 tot = vec3(.5,0.0,0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \t\t\n       \n        vec3 ro = vec3(0.0,2.5,4.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.6),-2.5));\n\n        vec2 t = vec2(.1);\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t.x*rd;\n            vec2 h = map(p);\n            if( abs(h.x)<0.001 || t.x>11.0 ) break;\n            t.x+=h.x;t.y=h.y;\n        }\n\n        vec3 col = mix(vec3(0.1, .1, .03), vec3(0.0, 0.0, 0.03),   ga1+ga2+ga3+ga4+ga5);\n\t\t\n        \n        if( t.x<11.0 )\n        {\n            vec3 _col;\n            \n            if(t.y == .3)\n                _col = vec3(1., .7, 0.0);\n            else if(t.y == .5)\n                _col = vec3(1., 0.0, 0.0);\n            else if(t.y == .7)\n                _col = vec3(0.0, 0.0, 0.0);\n            \n            vec3 pos = ro + t.x*rd;\n            vec3 nor = calcNormal(pos);\n            //vec3 refl = reflect(rd, nor);\n            //vec3 r = texture(iChannel0,refl).rgb;\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0) ;\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col =  mix(vec3(1., .1, .03), vec3(1.0, .7, .0),   ga1+ga2+ga3+ga4+ga5)*amb + (_col )  *dif*sha  ;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\t\n\tfragColor = vec4( tot, 1.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI          3.1415926\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\treturn max(v.x, v.y);\t\t\t\t\t\t}\nfloat vmax(vec3 v) {\treturn max(max(v.x, v.y), v.z);\t\t\t\t}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) { \treturn (x<0.)?-1.:1.;\t\t\t\t\t\t\t}\nvec2 sgn(vec2 v)   {\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\t}\n\n// Repeat around the origin by a fixed angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n    float s = sgn(p);\n    p = abs(p)-dist;\n    return s;\n}\n\n// @pjkarlik Modified to have angle passed in for post rotation\nvec2 pMirrorOctant (inout vec2 p, vec2 dist, float r) {\n    vec2 s = sgn(p);\n    pMirror(p.x, dist.x);\n    pMirror(p.y, dist.y);\n    p*=r2(r);\n    if (p.y > p.x) p.xy = p.yx;\n    return s;\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// Book Of Shaders - timing functions\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat easeOutCubic(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\nfloat easeInCubic(float t) {\n    return t * t * t;\n}","name":"Common","description":"","type":"common"}]}