{"ver":"0.1","info":{"id":"Dl3yD8","date":"1699109462","viewed":272,"name":"Upscaling: dark star ","username":"MV10","description":"Forking another that won't run smoothly at 2K+ at full-res. Rendering to a lower resolution then upscaling to full-screen in the final pass lets it run at a smooth frame rate. Original [url=https://shadertoy.com/view/DtBSWw]here[/url].","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["resolution","upscaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Resolution-limited fork of \"dark star\" https://shadertoy.com/view/DtBSWw\n// which is FabriceNeyret2's implementation of zozuar's twitter post, with\n// user tve's all-important Halloweeny e=50.0 setting.\n\n// What I can't figure out is why the crepuscular rays disappear at higher\n// resolutions. This doesn't happen on multiple GPUs running the same code under\n// full-desktop OpenGL 4.6 at upscaled resolutions as high as 4K but applying\n// the same horizontal resolution limit used here. (Edit: Thanks to morimea for\n// the fix; I didn't see this on my stand-alone OpenGL program since those use\n// a correctly-sized smaller framebuffer, whereas Shadertoy buffers are all the\n// same size.)\n\n// <editorializing>\n// Since I make my living fixing other people's code, this fascination with\n// \"golfing\" drives me nuts, so I de-obfuscated some of it along the way. :)\n// </editorializing>\n\n// Like my upscale fork of Protean Clouds (https://www.shadertoy.com/view/Dt3yW8),\n// the original code is in BufferA and BufferB, and you should match the MAXRES\n// definitions here and in Common.\n\n#define MAXRES 1920.0\n\n// Comment this to see resolution-limited output (obviously you must\n// either have the drawing canvas larger than MAXRES, or be running\n// full-screen.\n\n#define UPSCALE\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    #ifdef UPSCALE\n        float scaling = (iResolution.x > MAXRES)\n            ? MAXRES / iResolution.x\n            : 1.0;\n    #else\n        float scaling = 1.0;\n    #endif\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * scaling;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n    // declared in Common\n    res = iResolution.xy;\n    time = iTime;\n\n    vec4 color;\n    fragColor = Image(color, fragCoord, iChannel0);\n    fragColor = clamp(fragColor, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// See Image tab comments for details.\n#define MAXRES 1920.0\n\n// Buffer tabs must set these before calling Image()\nvec2 res;\nfloat time;\n\n#define R(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n\nvec4 Image(out vec4 color, vec2 fragCoord, sampler2D tex)\n{\n    // Apply the maximum resolution if applicable, and\n    // bail out whenever fragCoord is outside that range\n    float aspect = res.y / res.x;\n    vec2 orig_res = res;\n    if(res.x > MAXRES)\n    {\n        res = vec2(MAXRES, MAXRES * aspect); \n        if(fragCoord.y >= res.y || fragCoord.x >= res.x)\n        {\n            color = vec4(0);\n            return color;\n        }\n    }\n\n    vec2 p = (fragCoord + fragCoord - res) / res.y,\n        q = vec2(0),\n        n = vec2(0);\n    \n    float S = 6.0,\n        a = 0.0,\n        i = 0.0,\n        d = dot(p, p), \n        s = 0.0;\n    \n    float e = 50.0; // user \"tve\" for the win!\n    \n    p = p / (0.7 - d) + time / 3.14;\n    \n    for(color *= 0.0; i++ < e; color += texture(tex, fract((fragCoord / res - 0.5) * i / e + 0.5) * res / orig_res) / e)\n        p *= R(5.0), \n        n *= R(5.0),\n        q = p * S + i - abs(n) * R(time * 0.2),\n        a += dot(sin(q) / S, res / res),\n        n += cos(q), \n        S *= 1.1;\n    \n    a = max(s, 0.9 - a * 0.2 - d);\n    \n    return pow(a + a * vec4(8, 4, 1, 0) / e, color + 15.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // declared in Common\n    res = iResolution.xy;\n    time = iTime;\n\n    vec4 color;\n    fragColor = Image(color, fragCoord, iChannel0);\n    fragColor += color;\n}","name":"Buffer B","description":"","type":"buffer"}]}