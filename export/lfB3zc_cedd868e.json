{"ver":"0.1","info":{"id":"lfB3zc","date":"1704469026","viewed":58,"name":" Error Function Approximation","username":"chronos","description":"Simple error function plot. based on method from wikipedia: https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\nin turn from Abramowitz and Stegun.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["approximation","function","error","erf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Error Function Approximation by Chronos\n\n    ------------------------------------------------------------------\n\n    Approximation of the error function aka 'erf'\n\n    The so-called 'error function' is the integrals of Gaussians / normal distributions\n    en.wikipedia.org/wiki/Error_function\n    \n    Can be useful for math involving Gaussians / normal distributions,\n    but also as a sigmoid function\n    \n    Simple error function plot. based on method from wikipedia: \n        https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n    in turn from Abramowitz and Stegun.\n    \n    Supposedly maximum error: 1.5×10−7\n    I haven't checked :P\n    \n    this approximation is composed of a rational / reciprocal function (t1)\n    fed into a polynomial and multiplied with a gaussian.\n    \n    The approximation is valid for x > 0., so I used its symmetry for negative values,\n    and filled in the zero value.\n    \n*/\n\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\nfloat erf(float x)\n{\n    // I thought that one can also do: \n    //     if(abs(x) < eps) return x;\n    // for very small eps, e.g eps = 1e-7 or so.\n    // But of course, the first derivative of erf is a gaussian which is not 1 at zero\n    // So that would be incorrect.\n    // Instead one would have to use:\n    //     if(abs(x) < eps) return x * 2./sqrt(PI);\n    if(x == 0.) return 0.;\n\n    float p = 0.3275911,\n    a1 = 0.254829592,\n    a2 = -0.284496736,\n    a3 = 1.421413741,\n    a4 = -1.453152027,\n    a5 = 1.061405429;\n    \n    float t1 = 1. / (1. + p * abs(x));\n    float t2 = t1 * t1;\n    float t3 = t2 * t1;\n    float t4 = t2 * t2;\n    float t5 = t3 * t2; \n    \n    float result = 1.- exp(-x*x) * (a1 * t1 + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5);\n    \n    result *= sign(x);\n    \n    return result;\n}\n\nfloat polynomial(float x)\n{\n    if(x == 0.) return 0.;\n\n    float p = 0.3275911,\n    a1 = 0.254829592,\n    a2 = -0.284496736,\n    a3 = 1.421413741,\n    a4 = -1.453152027,\n    a5 = 1.061405429;\n    \n    float t1 = 1. / (1. + p * x);\n    float t2 = t1 * t1;\n    float t3 = t2 * t1;\n    float t4 = t2 * t2;\n    float t5 = t3 * t2; \n    \n    float result = (a1 * t1 + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5);\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.) mouse = vec2(1);\n\n    float zoom = 1. /(0.001 + max(abs(mouse.x), abs(mouse.y)));\n\n    vec2 uv = zoom * (2. * fragCoord- iResolution.xy)/iResolution.y;\n    float pix_size = zoom * 2. / iResolution.y;\n    vec3 color = vec3(0);\n\n    float y = erf(uv.x);\n    \n    #if 0\n    y = polynomial(uv.x);\n    #endif\n    \n    #if 0\n    y = tanh(uv.x);\n    #endif\n    \n\n    float thickness = 1. * pix_size;\n    \n    // draw erf graph\n    float graph = \n        smoothstep(y+2.*pix_size +thickness/2., y+thickness/2., uv.y) -\n        smoothstep(y-thickness/2., y-2.*pix_size-thickness/2., uv.y);\n        \n    // draw axes\n    float zero_axes = \n        0.25 * (\n        smoothstep(1.5 * pix_size, pix_size/2., uv.y) -\n        smoothstep(-pix_size/2., -1.5*pix_size, uv.y)\n        +\n        smoothstep(1.5 * pix_size, pix_size/2., uv.x) -\n        smoothstep(-pix_size/2., -1.5*pix_size, uv.x)\n        );\n        \n    // Draw +/- 1 axes. Too lazy to compact this :P    \n    float one_axes =  \n        0.05 * ( // +1 y\n                smoothstep(1. + 1.5 * pix_size, 1. + pix_size/2., uv.y) -\n                smoothstep(1. + -pix_size/2., 1. -1.5*pix_size, uv.y)\n            +   // -1 y\n                smoothstep(-1. + 1.5 * pix_size, -1. + pix_size/2., uv.y) -\n                smoothstep(-1. + -pix_size/2., -1. -1.5*pix_size, uv.y)\n            +   // +1 x\n                smoothstep(1.+1.5 * pix_size, 1.+pix_size/2., uv.x) -\n                smoothstep(1.-pix_size/2., 1.-1.5*pix_size, uv.x)\n            +   // -1 x\n                smoothstep(-1.+1.5 * pix_size, -1.+pix_size/2., uv.x) -\n                smoothstep(-1.-pix_size/2., -1.-1.5*pix_size, uv.x)\n        );\n        \n    color = mix(color, vec3(1), one_axes);\n    color = mix(color, vec3(1), zero_axes);\n    color = mix(color, vec3(1), graph);\n\n    color = sRGBencode(color);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}