{"ver":"0.1","info":{"id":"flGXRy","date":"1640875409","viewed":184,"name":"Frankenshader II","username":"Synthesoft","description":"More experimentation and two new maps.  This time defaulting to union.   Like Frankenshader, cobbled together from bits and pieces of other shaders. \n\nLeft-click & drag left/right in output window will help find interesting areas.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","psychedelic","flythrough","mapmix"],"hasliked":0,"parentid":"ftVXWw","parentname":"Frankenshader's Lair"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a variation on Remnant X by David Hoskins.\n// Original: https://www.shadertoy.com/view/4sjSW1\n// \n// Frankeshaders Lair (https://www.shadertoy.com/view/ftVXWw)\n//   Changes by Synthesoft: \n//      I took core + cinematics from Remnant X and...\n//        Added noise to surfaces\n//        Swapped out the original map() for two new ones which I mix together in Map() (Weight: fbvar2 & Mode: fbvar5) \n//           See MapA()/MapB() below for info on sources\n//           I was curious what it would look like to blend maps and was really pleased with the results\n//        Changed the Dizzolve sphere (fbvar4) 0.0-0.5 solid, 0.5..1.0 fuzz \n//        Parameterized FOV (fbvar4)   \n//        Replaced original color handling.  Made the colors annoyingly garish (it's a gift.  ...and a curse.)\n// \n//  \n// Frankenshader II ( forked from Frankenshaders Lair )\n//   Changes by Synthesoft: \n//      Added mix parameters\n//      Swapped in two new map() functions\n//      Cleaned up vars\n//      Added some parmsets that produce interesting results \n//      Fixed lighting issues\n//      Added light originating from camera position\n\n//#define FLASHBACK\n#ifdef FLASHBACK\n// tl;dr - These are not the variables you're looking for (/gestures with hand)\n//\n// These vars are used by a Windows desktop application I'm writing called Flashback.  It \n// has sliders that adjust the values on-the-fly.  I've replaced them below with #defines for \n// some alternate configurations ( USE_PARMSET_[n] ) to use on ShaderToy\n//\n#define FORCE_MISS_TO_BLACK\nuniform float iTime;\nuniform vec3 iResolution;\nuniform vec4 iMouse;\n\nuniform float fbvar1;  // fract iterations -- changes here are interesting\nuniform float fbvar2;  // Map weighting (when fbvar5 set to mix()) \nuniform float fbvar3;  // Dizzolve sphere: 0.0-0.5 solid, 0.5..1.0 fuzz \nuniform float fbvar4;  // FOV\nuniform float fbvar5;  // less than 0.5 = mix(), greater than 0.5 = min()    (Merge/mix vs Union)\nuniform float fbvar6;  // fractal calc tweaks\nuniform float fbvar7;  // brightness: light originating from camera position\nuniform float fbvar8;  // brightness: light originating from forward probe\nuniform float fbvar9;  // brightness: sun\n#else // not Flashback\n\n#define USE_PARMSET_1  // <-- Use this to change between parameter sets\n\n#ifdef USE_PARMSET_1  \n#define fbvar1 \t0.482\n#define fbvar2 \t0.522   // unused for union\n#define fbvar3 \t0.02\n#define fbvar4 \t0.253\n#define fbvar5 \t0.516   // Union of maps\n#define fbvar6 \t0.672\n#define fbvar7 \t0.05\n#define fbvar8 \t0.065\n#define fbvar9 \t0.080\n#endif\n\n#ifdef USE_PARMSET_2\n#define fbvar1 \t0.202\n#define fbvar2 \t0.223  // Map mix weighting\n#define fbvar3 \t0.695\n#define fbvar4 \t0.109\n#define fbvar5 \t0.425  // Merge/mix maps Union of maps (show intersection)\n#define fbvar6 \t0.069\n#define fbvar7 \t0.027\n#define fbvar8 \t0.065\n#define fbvar9 \t0.080\n#endif\n\n\n#endif\n\n// #define STEREO\n\nvec3 sunDir = normalize(vec3(  0.35, 0.1,  0.3 ));\n\n#define pi 3.14159\n#define SCALE 2.8\n#define MINRAD2 .25\nfloat minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\n#define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)\nvec3 col1,col2,col3;\nfloat gTime;\n\n\n//----------------------------------------------------------------------------------------\n\n#define CSize vec3(1., 1.7, 1.)\n\n// From Shane: https://www.shadertoy.com/view/lstGRB\nfloat Noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nfloat MapB( vec3 p )\n{\n\tp = p.xzy;\n\tfloat mscale = 1.1;\n\tfor( int i=0; i < int(fbvar1*8.+1.0);i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\t//float r2 = dot(p,p);\n        float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal\n\t\tfloat k = max(((fbvar6 * 8. + 1.))/(r2), .5);\n\t\tp     *= k;\n\t\tmscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 1.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, (n) / 8.);\n\treturn (rxy) / abs(mscale);\n}\n\nfloat MapA(vec3 p) \n{\n\tp.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n\tvec4 q = vec4(p, 1);\n\n\tfor(int i = 0; i <  int(fbvar1*48.+1.0); i++) \n  {\n\t\tq.xyz = abs(q.xyz) - vec3(-0.02, 1.07, -0.02);\n\t\tq = ((fbvar6 * 0.6)+1.6)*q/clamp(dot(q.xyz, q.xyz), 0.4, 1.0) - vec4(1.0, 0.0, 0.6, 0.0);\n\t}\n\n\treturn length(q.xyz)/q.w;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nvec3 vmax(vec3 a, vec3 b)\n{\n    return vec3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));\n}\n\n\nfloat Map(vec3 v)\n{\n  if (fbvar5 < 0.5)\n\t\treturn mix(MapA(v),MapB(v), fbvar2);\n  else\n\t\treturn min(MapA(v),MapB(v));\n}\n\n//----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\n//----------------------------------------------------------------------------------------\n\n\nvec3 Colour(vec3 pos) \n{\n  vec3 ca = (pos * col1);\n  vec3 cb = (pos * col2);\n  vec3 cc = (pos * col3);\n\n  vec3 c1 = vmax(ca,cb);\n  vec3 c2 = Noise(pos*100.) * cc;\nc1=abs(c1);\nc2=abs(c2);\n//  c1 *=c1;\n//  c2 *=c2;\n  return normalize(c1) + normalize(log(c2));\n}\n\n\n\n//----------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 pos, float distance)\n{\n    distance *= 0.001+.0001;\n\tvec2 eps = vec2(distance, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t    Map(pos+eps.yxy) - Map(pos-eps.yxy),\n\t    Map(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n//----------------------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 6; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = Map(rO + halfwayT*rD); \n        //if (abs(d) < 0.001) break;\n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.0005, d));\n\n    }\n\n\treturn halfwayT;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)\n{\n  float t;\n  if (fbvar3> 0.5)\n\t\tt = 0.001 + (1.0-fbvar3) + 0.04 * Hash(fragCoord*rO.x); // Dizzolve \n  else\n    t = 0.001 + (fbvar3);  // Clean\n\tvec3 p = vec3(0.0);\n  float oldT = 0.0;\n  bool hit = false;\n  float glow = 0.0;\n  vec2 dist;\n \n\tfor( int j=0; j < 100; j++ )\n\t{\n\t\tif (t > 12.0) break;\n        p = rO + t*rD;\n       \n\t\tfloat h = Map(p);\n        \n\t\tif (h  < 0.0005)\n\t\t{\n       dist = vec2(oldT, t);\n       hit = true;\n       break;\n    }\n\n   \tglow += clamp(.05-h, 0.0, .4);\n    oldT = t;\n  \tt +=  h + t*0.001;\n \t}\n\n#ifdef FORCE_MISS_TO_BLACK\n  if (!hit)\n    return vec2(0.0,0.0);\n  else     \n    t = BinarySubdivision(rO, rD, dist);\n#else\n\tif (!hit)\n     t = 1000.0;\n  else       \n     t = BinarySubdivision(rO, rD, dist);\n#endif\n\n  return vec2(t, clamp(glow*.25, 0.0, 1.0));\n}\n\n//----------------------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\t\n\n\t// Then...\n\t#define CONTRAST 1.0\n\t#define SATURATION 1.2\n\t#define BRIGHTNESS 1.4\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Noise...\n\t//rgb = clamp(rgb+Hash(xy*iTime)*.1, 0.0, 1.0); \n\t// Vignette...\n\trgb *= .5 + 0.5*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\t\n\n    rgb = pow(rgb, vec3(0.47));\n\treturn rgb;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 8; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 LightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n        float a = max(dot(normalize(spotLight), dir), 0.0);\n\t\tg = pow(a, 500.0);\n        g +=  pow(a, 5000.0)*.2;\n    }\n   \n    return vec3(.6) * g;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-.78 + 3. * sin(2.14*t),.05+2.5 * sin(.942*t+1.3),.05 + 3.5 * cos(3.594*t) );\n\treturn p;\n} \n    \n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // three ever-changing colors used in\n    float fTime = iTime * 2.5;\n    col1 = vec3(sin(fTime/3.1), sin(fTime/4.3), sin(fTime/5.9)) + 2.1;  \n    col2 = vec3(cos(fTime/10.7), cos(fTime/8.9), cos(fTime/7.3)) + 2.1;  \n    col3 = vec3(sin(fTime/7.7), sin(fTime/9.3), sin(fTime/13.3)) + 2.1;  \n\t    \n    float m = (iMouse.x/iResolution.x)*300.0;\n\tgTime = (iTime+m)*.01 + 15.00;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * (vec2(iResolution.x/iResolution.y, 1.0) * (0.1+(fbvar4*5.0)));\n\t\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y, 2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos\t= CameraPath(gTime);\n  vec3 camTar\t\t= CameraPath(gTime + .01);\n\n\tfloat roll = 13.0*sin(gTime*.5+.4);\n\tvec3 cw = normalize(camTar-cameraPos);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\n\tvec3 cv = normalize(cross(cu,cw));\n  cw = RotationMatrix(cv, sin(-gTime*20.0)*.7) * cw;\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\n\t#ifdef STEREO\n\tcameraPos += .008*cu*isRed; // move camera to the right\n\t#endif\n\n    vec3 spotLight = CameraPath(gTime + .05) + vec3(sin(gTime*19.4), cos(gTime*17.58), sin(gTime * 15.53))*.02;\n\t\tvec3 col = vec3(0.0);\n\t\tvec2 ret = Scene(cameraPos, dir,fragCoord);\n#ifdef FORCE_MISS_TO_BLACK\n    if (ret == vec2(0.0)) {\n\t\t\t\tfragColor=vec4(0.0,0.0,0.0,0.0);  // We missed so force to black\n\t\t\treturn;\n\t\t}\n#endif    \n\t\tif (ret.x < 900.0)\n    {\n\t\t\t\tvec3 p = cameraPos + ret.x*dir; \n\t\t\t\tvec3 nor = GetNormal(p, ret.x);\n        \n       \tvec3 spotDir = spotLight - p;\n        vec3 camDir = cameraPos - p;\n\n    \t\tfloat attenSpot = length(spotDir);\n    \t\tfloat attenCam = length(camDir);\n\n        spotDir /= attenSpot;\n        camDir /= attenCam;\n        \n        float shaSpot = Shadow(p, spotDir);\n        float shaSun = Shadow(p, sunDir);\n        float shaCam = 1.0;  // No need to calc shadows from light originating at the camera position\n        \n       \tfloat briCam = (max(dot(camDir, nor), 0.0) / pow(attenCam, 0.5)) * fbvar7;\n       \tfloat briSpot = (max(dot(spotDir, nor), 0.0) / pow(attenSpot, 1.5)) * fbvar8;\n        float briSun = max(dot(sunDir, nor), 0.0) * (fbvar9*2.);\n        \n       col = Colour(p) * 2.0;\n       col = (col * briSpot * shaSpot) + (col * briSun * shaSun)  + (col * briCam * shaCam);\n        \n       vec3 ref = reflect(dir, nor);\n       col += pow(max(dot(camDir,  ref), 0.0), 10.0) * 2.0 * shaCam * briCam;\n       col += pow(max(dot(spotDir,  ref), 0.0), 10.0) * 2.0 * shaSpot * briSpot;\n       col += pow(max(dot(sunDir, ref), 0.0), 10.0) * 2.0 * shaSun  * briSun;\n    }\n    \n    //col = mix(sky, col, min(exp(-ret.x+1.5), 1.0));\n    col += vec3(pow(abs(ret.y), 2.)) * vec3(.02, .04, .1); \n    col += LightSource(spotLight-cameraPos, dir, ret.x);\n\tcol = PostEffects(col, xy);\t\n\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\n\tcol = max(col, vec3(0.01,0.01,0.01)); // Force any hit to non-black\n\t\n\tfragColor=vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#ifdef FLASHBACK\nvoid main(void)\n{\n\t mainImage(gl_FragColor, gl_FragCoord.xy);\n} \n#endif\n\n\n","name":"Image","description":"","type":"image"}]}