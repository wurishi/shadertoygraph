{"ver":"0.1","info":{"id":"tsl3Rs","date":"1547248779","viewed":533,"name":"Cell Displacement Effect","username":"jaszunio15","description":"Cellular Displacement based on Voronoi noise idea.\nUse mouse to adjust strength. Looks best on fullscreen.\nYou can adjust the effect at the beginning of the code ;)\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)\n","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["voronoi","noise","effect","image","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//More iterations - bigger cell travel distance (more calculations)\n#define ITERATIONS 5\n\n//Average cell size in pixels\n#define CELL_SIZE 8.0\n\n//Time multiplier, cell travel speed\n#define TIME_SCALE 1.0\n\n//Multiplies cell travel distance. \n//Values > 1.0 may cause unwanted artifacts (like cell not processed in some cases)\n#define TRAVEL_DISTANCE_MULTIPLIER 1.0\n\n#define ROTATED_VEC(angle) vec2(cos(angle), sin(angle))\n\nfloat mouseX()\n{\n    if (iMouse.z > 0.0) return iMouse.x / iResolution.x;// * 5.0; //uncomment to produce weird results\n    else return sin(iTime * TIME_SCALE * 0.3) * 0.5 + 0.5;   \n}\n\nfloat hash(vec2 v)\n{\n \treturn fract(sin(dot(v, vec2(12.5289, 42.5091))) * 426.4912);\n}\n\nvec2 PointPosition(vec2 pos)\n{\n    //moving point around (pos + 0.5) with random speed and radius\n \tfloat radius = hash(pos);\n    return pos + 0.5\n        + ROTATED_VEC(iTime * TIME_SCALE + radius * 51.2151) \n        * radius * mouseX() * float(ITERATIONS) \n        * TRAVEL_DISTANCE_MULTIPLIER;\n}\n\nvec2 ImageToCellUV(vec2 imageUV)\n{\n\treturn (imageUV.xy * iResolution.xy) / CELL_SIZE;   \n}\n\nvec2 CellToImageUV(vec2 cellUV)\n{\n \treturn (cellUV * CELL_SIZE) / iResolution.xy;\n}\n\nvec4 CellDisplacement(vec2 uv)\n{\n    vec2 pos = ImageToCellUV(uv);\n    vec2 rootPos = floor(pos);\n    \n    float minDist = 999999.0;\n    vec2 otherRootPos = rootPos;\n\n    //Find closest point\n    for (int x = -ITERATIONS; x <= ITERATIONS; x++)\n    {\n     \tfor (int y = -ITERATIONS; y <= ITERATIONS; y++)\n        {\n        \tvec2 altCellPoint = PointPosition(rootPos + vec2(x,y));\n            float dist = distance(altCellPoint, pos);\n            \n            if(minDist > dist)\n            {\n             \tminDist = dist;\n                otherRootPos = (rootPos + vec2(x,y));\n            }\n        }\n    }\n\n    float distortion = mouseX();\n    vec4 cellColor = texture(iChannel0, CellToImageUV(mix(pos, otherRootPos + 0.5, distortion)));\n    return cellColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(CellDisplacement(uv));\n}","name":"Image","description":"","type":"image"}]}