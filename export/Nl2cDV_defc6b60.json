{"ver":"0.1","info":{"id":"Nl2cDV","date":"1659429799","viewed":89,"name":"Fork Circle Gra jkai421 588","username":"jkai421","description":"A circle graph that has segments that increase in size according to its percentage","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circlegraph"],"hasliked":0,"parentid":"XtjXR1","parentname":"Circle Graph"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI2 6.28318\n#define blur 0.005\n#define INDEX(s, o) int(mod(s+o, 6.0))\n\n\nconst float inversePi = 1.0 / 3.14159;\n\nfloat dLine(vec2 p, vec2 a, vec2 b) \n{\n    b -= a;  \n    p -= a;\n    return length (p - clamp (dot (p, b) / dot (b, b), 0.0, 1.0) * b);\n}\n\nfloat mix2(float a, float b, float x)\n{\n   return mix(a, b + step(b, a), x); \n}\n\nfloat getCircleSegment(vec2 uv, float start, float end, float radius, float width)\n{\n  end += step(end, start);\n  float distanceO = length( uv );\n    \n  float angle = atan( uv.x, uv.y ) * inversePi * 0.5;\n  angle = fract( angle );\n  float circle; \n  circle = smoothstep( width + blur, width - blur, distanceO); \n  circle -= smoothstep(radius + blur, radius - blur, distanceO);\n    \n  //add the segment\n  float segment = smoothstep(end + blur*0.5, end - blur*0.5, angle);\n  segment -= smoothstep(start + blur*0.5,  start - blur*0.5, angle);\n  \n  float s = step(1.0, end);\n  segment += s * smoothstep(fract(end) + blur*0.5, fract(end) - blur*0.5, angle);\n  circle = circle * segment;\n    \n  return circle;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy; // calculate the texture coords\n    // Convert from range [0,1] to [-1,1]\n    uv = 2.0 * uv - 1.0;\n    // this line adjusts for the aspect ratio\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    float t = mod(0.5*iTime, 6.0);\n    float offset = floor(t);\n    float lambda = smoothstep(0.6, 1.0, fract(t));\n    float array[7] = float[7](0.0, 0.09, 0.18, 0.32, 0.41, 0.5, 1.0);\n    \n    float p1 = mix2(array[INDEX(0.0, offset)], array[INDEX(1.0, offset)], lambda); \n    float p2 = mix2(array[INDEX(1.0, offset)], array[INDEX(2.0, offset)], lambda); \n\tfloat p3 = mix2(array[INDEX(2.0, offset)], array[INDEX(3.0, offset)], lambda); \n\tfloat p4 = mix2(array[INDEX(3.0, offset)], array[INDEX(4.0, offset)], lambda); \n    float p5 = mix2(array[INDEX(4.0, offset)], array[INDEX(5.0, offset)], lambda);\n    float p6 = mix2(array[INDEX(5.0, offset)], array[INDEX(6.0, offset)], lambda);\n    float radius = 0.4; //Range (0f, 1f]\n\t\n    float width = radius + 0.3; //segment length determines the width\n\tvec3 rgb = vec3( 1.0, 0.0, 0.0 ) * getCircleSegment(uv, p1, p2, radius, width); \n \trgb += vec3( 0.0, 1.4, 0.0 ) * getCircleSegment(uv, p2, p3, radius, width);  \n    rgb += vec3( 0.0, 0.0, 1.0 ) * getCircleSegment(uv, p3, p4, radius, width); \n    rgb += vec3( 1.0, 0.0, 1.0 ) * getCircleSegment(uv, p4, p5, radius, width); \n    rgb += vec3( 0.4, 0.3, 1.0 ) * getCircleSegment(uv, p5, p6, radius, width);\n    rgb += vec3( 1.0, 1.0, 0.0 ) * getCircleSegment(uv, p6, p1, radius, width);        \n    rgb *= smoothstep(0.02 - blur, 0.02, dLine(uv, vec2(0.0, 0.0), vec2(width*sin(p1 * PI2), width*cos(p1 * PI2))));\n    rgb *= smoothstep(0.02 - blur, 0.02, dLine(uv, vec2(0.0, 0.0), vec2(width*sin(p2 * PI2), width*cos(p2 * PI2))));\n    rgb *= smoothstep(0.02 - blur, 0.02, dLine(uv, vec2(0.0, 0.0), vec2(width*sin(p3 * PI2), width*cos(p3 * PI2))));\n    rgb *= smoothstep(0.02 - blur, 0.02, dLine(uv, vec2(0.0, 0.0), vec2(width*sin(p4 * PI2), width*cos(p4 * PI2))));\n    rgb *= smoothstep(0.02 - blur, 0.02, dLine(uv, vec2(0.0, 0.0), vec2(width*sin(p5 * PI2), width*cos(p5 * PI2))));\n    rgb *= smoothstep(0.02 - blur, 0.02, dLine(uv, vec2(0.0, 0.0), vec2(width*sin(p6 * PI2), width*cos(p6 * PI2))));\n    fragColor = vec4( rgb, 1.0);    \n}","name":"Image","description":"","type":"image"}]}