{"ver":"0.1","info":{"id":"stB3zW","date":"1623429624","viewed":819,"name":"Volumetric God Rays - Andrew","username":"andrew741","description":"A basic scene rendered using ray marching with volumetric shadows also known as god rays. Theres also specular reflection. This is an improvement/revision of my last attempt at god rays and is much better in performance and looks.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","godrays","volumetrics","volumetricclouds","specularreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nA revision of my last attempt, the main difference is that instead of\ngathering the volume info during the ray march, i gather it after by\nfinding the start and end position and create 180 sample points inbetween where\ni gather the volume info. (For the sky i step into the scene by 0.2 160\ntimes to gather the volume info).\n*/\n\n\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat Dimple(vec3 p)\n{\n    return min(p.y + 10., 1. - (abs(length(p.xz) / max((p.y + 5.) / 10., 1.)) - 15.));\n}\n\n\nfloat Boxes(vec3 p)\n{\n    return sdBox(abs(p) - vec3(10., 0., 10.), vec3(1., 15., 1.));\n}\n\n\nfloat GetDst(vec3 p)\n{\n    float dst1 = length(p) - 2.5;\n    float dst2 = Dimple(p);\n    float dst3 = Boxes(p);\n    \n    return min(min(dst1, dst2), dst3);\n}\n\n\nvec4 GetCol(vec3 p)\n{\n    float dst1 = length(p) - 2.;\n    float dst2 = Dimple(p);\n    float dst3 = Boxes(p);\n    \n    float dst = min(min(dst1, dst2), dst3);\n    \n    if (dst == dst1) return vec4(0.2, 0.2, 0.8, 0.);\n    if (dst == dst2) return vec4(0.8, 0.2, 0.8, 1.);\n    if (dst == dst3) return vec4(0.2, 0.8, 0.8, 2.);\n    return vec4(0., 0., 0., -1.);\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;  // * vec2(1., 0.62);\n    vec3 col = vec3(0.);\n\n    vec3 sun_dir = normalize(vec3(sin(iTime), 1.5, cos(iTime)));\n    vec3 sun_col = vec3(1., 0.95, 0.85);\n\n    // from https://www.shadertoy.com/view/WtGXDD (getting ro and rd)\n    vec3 ro = vec3(0, 8, -8);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0., 0., 0.), 1.);\n\n    vec3 p = ro;\n    float depth = 0.;\n    bool collided = false;\n    for (int s = 0; s < 125; s++)\n    {\n        float dst = GetDst(p);\n        p += rd * dst;\n        depth += dst;\n        \n        if (dst < 0.01)\n        {\n            collided = true;\n            break;\n        }\n        else if (dst > 35.) break;\n    }\n    if (collided)\n    {\n        vec4 object_col_and_mat = GetCol(p);\n        vec3 object_col = object_col_and_mat.rgb;\n        vec3 normal = GetNormal(p);\n        object_col *= dot(sun_dir, normal) * 0.5 + 0.5;\n        SpecularLight spec = Specular(0.8, normal, rd, sun_dir);\n        object_col += sun_col * spec.highlight;\n\n        float sun_depth = 0.;\n        bool shadow_collided = false;\n        vec3 sp = p + normal * 0.01 * 2.;\n        for (int s = 0; s < 50; s++)\n        {\n            float dst = GetDst(sp);\n            sp += sun_dir * dst;\n            sun_depth += dst;\n            \n            if (dst < 0.01)\n            {\n                shadow_collided = true;\n                break;\n            }\n            else if (sun_depth > 35.) break;\n        }\n        float total_density = 0.;\n        float step_size_f = depth / 180.;\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        for (int s = 0; s < 180; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 75; sr++)\n            {\n                float dst = GetDst(srp);\n                srp += sun_dir * dst;\n                slrd += dst;\n                \n                if (dst < 0.075)\n                {\n                    total_density += 0.15 * step_size_f;\n                    break;\n                }\n                else if (slrd > 25.) break;\n            }\n            dp += step_size;\n        }\n        \n        object_col *= exp(-total_density);\n        object_col *= shadow_collided ? 0.5 : 1.;\n        \n        col = object_col;\n    }\n    else\n    {\n        float total_density = 0.;\n        float step_size_f = 0.175;\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        for (int s = 0; s < 180; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 75; sr++)\n            {\n                float dst = GetDst(srp);\n                srp += sun_dir * dst;\n                slrd += dst;\n                \n                if (dst < 0.075)\n                {\n                    total_density += 0.15 * step_size_f;\n                    break;\n                }\n                else if (slrd > 25.) break;\n            }\n            dp += step_size;\n        }\n        \n        col = vec3(0.3, 0.3, rd.y * 0.5 + 0.5);\n        if (rd.y > 0.) col = mix(col, sun_col * 1.3, min(max(pow(dot(sun_dir, rd), 20.) * 0.7, 0.), 1.));\n        col *= exp(-total_density);\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}