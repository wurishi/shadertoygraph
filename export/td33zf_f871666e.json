{"ver":"0.1","info":{"id":"td33zf","date":"1580061324","viewed":58,"name":"BabyRayTracer","username":"tkozjak","description":"A simple ray tracer. Baby steps. Just a few spheres rendered with a classic ray tracing method. And a torus rendered with SDF.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// GLOBALS\nvec3 lightDir  = vec3(-1.0, -1.0, 1.0);\nvec4 backColor = vec4(0.2, 0.1, 0.0, 1.0);\n\nvec3 camPos = vec3(0.0, 1.5, 5.0);\nvec3 camDir = vec3(0.0, -0.3, -1.0);\n\n// SDF GLOBALS\nfloat MARCH_START = 0.001;\nint MAX_MARCHING_STEPS = 300;\nfloat EPSILON = 0.01;\nfloat MARCH_END = 100.0;\n\n// function that returns just a hit: yes or no\nbool hit_sphere( vec3 center, float radius, vec3 ray, vec3 camera ){\n    \n    vec3 oc = center - camera;\n    float a = dot(ray, ray);\n    float b = 2.0 * dot(oc, ray);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    \n    return (discriminant > 0.0);\n}\n\n// hit function - returns .w = 1 if hit and hitpoint's normal in .xzy\nvec4 hit_sphere_2( vec3 center, float radius, vec3 ray, vec3 camera ){\n    \n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec3 shift = camera - center;\n    float a = dot(ray, ray); \n    float b = 2.0 * dot( ray, shift );\n    float c = dot( shift,shift ) - radius*radius;\n        \n    float dicsriminant = b*b - 4.0*a*c;\n    \n    float t_0 = ( -b + sqrt( dicsriminant ) )/2.0*a;\n    float t_1 = ( -b - sqrt( dicsriminant ) )/2.0*a;\n    \n    if( dicsriminant >= 0.0 && t_0 > 0.0){\n\n        vec3 p0 = camera + t_0 * ray;\n        result.xyz = normalize(p0-center);\n        result.w = 1.0;\n        return result;\n    }\n    else\n        return result;\n}\n\n// torus SDF\nfloat sdTorus( vec3 point, vec2 t ){\n    \n    vec2 q = vec2(length(point.xz)-t.x, point.y);\n    \n    return length(q)-t.y;\n}\n\n// ray marching function that returns distance\nfloat rayMarch( vec3 camera, vec3 ray, vec3 objectCenter ){\n    float depth = MARCH_START;\n    \n    for( int i=0; i < MAX_MARCHING_STEPS; i++){\n        float distance = sdTorus( camera + depth * ray, vec2(1.2, 0.2) );\n        \n        if( distance < EPSILON ){\n            return depth;\n        }\n        \n        depth += distance;\n        \n        if( depth >= MARCH_END ){\n            return MARCH_END;\n        }\n    }\n    \n    return MARCH_END;\n}\n\nvec4 rayMarch_Normal( vec3 camera, vec3 ray, vec3 objectCenter ){\n    \n    vec4 normal = vec4 (0.0, 0.0, 0.0, 0.0 );\n    \n    float ray_march_distance = rayMarch( camera, ray, vec3(0.0, 0.0, 0.0) );\n        if( ray_march_distance < MARCH_END ){\n        \n        normal.w = 1.0;\n            \n        // calculate normal\n        vec3 hit_point = camera + ray_march_distance * ray;\n        vec3 p_normal = vec3(\n            sdTorus(vec3(hit_point.x + EPSILON,hit_point.y,hit_point.z), vec2(1.2, 0.2))-sdTorus(vec3(hit_point.x - EPSILON,hit_point.y,hit_point.z), vec2(1.2, 0.2)),\n            sdTorus(vec3(hit_point.x,hit_point.y + EPSILON,hit_point.z), vec2(1.2, 0.2))-sdTorus(vec3(hit_point.x,hit_point.y - EPSILON,hit_point.z), vec2(1.2, 0.2)),\n            sdTorus(vec3(hit_point.x,hit_point.y,hit_point.z + EPSILON), vec2(1.2, 0.2))-sdTorus(vec3(hit_point.x,hit_point.y,hit_point.z - EPSILON), vec2(1.2, 0.2))\n        );\n            \n        normal.xyz = normalize(p_normal);\n        return normal;\n    }\n    \n    return normal;\n}\n\n// hit function - experiment with texture lookup\nvec4 hit_sphere_3( vec3 center, float radius, vec3 ray, vec3 camera ){\n    \n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec3 shift = camera - center;\n    float a = dot(ray, ray); \n    float b = 2.0 * dot( ray, shift );\n    float c = dot( shift,shift ) - radius*radius;\n        \n    float dicsriminant = b*b - 4.0*a*c;\n    \n    float t_0 = ( -b + sqrt( dicsriminant ) )/2.0*a;\n    float t_1 = ( -b - sqrt( dicsriminant ) )/2.0*a;\n    \n    if( dicsriminant >= 0.0 && t_0 > 0.0){\n\n        vec3 p0 = camera + t_0 * ray;\n        \n        float fi = atan(p0.z, p0.x);\n        float theta = acos( p0.y / radius );\n        vec4 color = texture( iChannel0, vec2(fi, theta));\n        result.xyz = color.rgb;\n        result.w = 1.0;\n        return result;\n    }\n    else\n        return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    //just an input test\n    vec2 normCoords = iMouse.xy / iResolution.xy - vec2(0.5, 0.5);\n    \n    //just an oscilating light test\n    float oscilator = 1.0*sin(iTime);\n    \n    // cosine factor for light\n    float factor = 1.0;\n    \n    // coordinate vector is a vector that describes a position of a fragment/pixel on the screen\n    // origin is at the center of the screen\n    // positive x axis is to right\n    // postive y axis is to up\n    vec2 coordVector;\n    coordVector = vec2(fragCoord.x, fragCoord.y) - vec2(iResolution.x/2.0, iResolution.y/2.0);    \n\n    // view ray is our primary ray\n    // rays are in world space coordinates\n    // we calculate coordinates of a ray from WS camera direction and coordinate vector\n    // (assuming that camera direction points at the center of the projection plane and is perpendicular to it\n    vec3 viewRay = vec3( vec3(coordVector/800.0, 0.0 ) + normalize(camDir) );\n    \n        \n    fragColor = backColor;\n    vec3 oscliatingLightDir = -normalize( vec3( oscilator, lightDir.yz) );\n\n\n    vec4 isHit2;\n    \n    isHit2 = hit_sphere_2( vec3(0.0 + normCoords.x*15.0, 1.0 + normCoords.y*15.0, -30.0), 5.0, normalize(viewRay), camPos);\n\n    if( isHit2.w > 0.0 ){\n        factor = clamp(dot(isHit2.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor, factor, factor, 1.0 );\n    }\n    \n    isHit2 = hit_sphere_2( vec3(0.0 + normCoords.x*5.0, 1.0 + normCoords.y*5.0, -15.0), 2.0, normalize(viewRay), camPos);\n\n    if( isHit2.w > 0.0 ){\n        factor = clamp(dot(isHit2.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor, factor, factor, 1.0 );\n    }\n    \n    isHit2 = hit_sphere_2( vec3(0.0 + normCoords.x*10.0, 1.0 + normCoords.y*10.0, -10.0), 1.0, normalize(viewRay), camPos);\n\n    if( isHit2.w > 0.0 ){\n        factor = clamp(dot(isHit2.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor, factor, factor, 1.0 );\n    }\n    /*\n    float ray_march_distance = rayMarch( camPos, normalize(viewRay), vec3(0.0, 0.0, 0.0) );\n    if( ray_march_distance < MARCH_END ){\n        fragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n    }\n    */\n    \n    vec4 ray_march_normal = rayMarch_Normal( camPos, normalize(viewRay), vec3(0.0, 0.0, 0.0) );\n    if( ray_march_normal.w > 0.0 ){\n        factor = clamp(dot(ray_march_normal.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor * ray_march_normal.xyz, 1.0 );\n    }\n    \n}","name":"Image","description":"","type":"image"}]}