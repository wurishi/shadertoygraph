{"ver":"0.1","info":{"id":"4lsBWX","date":"1513810759","viewed":141,"name":"SuperF0rmula","username":"jgkling","description":"Ellipse superformula using IQ distance estimation. Links:\nhttps://iquilezles.org/articles/distance/distance.htm\nhttps://en.wikipedia.org/wiki/Superformula","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define OneD // use some 1D function\n#define ROTATE\n\n// Superformula: https://en.wikipedia.org/wiki/Superformula\nfloat Superformula( in vec2 p, in vec4 params ) {\n    vec2 pt = abs(vec2(cos(p.y * params.x * 0.25), sin(p.y * params.x * 0.25)));\n    pt = pow(pt, vec2(params.z, params.w));\n    return pow(pt.x + pt.y, -1.0 / params.y) * 0.5 - p.x; // the * 0.5 is a tweaked trick I stole from here: https://www.shadertoy.com/view/llsyz8\n}\n\nfloat func( in vec2 p ) {\n    #ifdef OneD\n    return cos(p.x * 32.0 + iTime * 0.5) * sin(p.x * 13.0 + iTime * 1.5) * 0.15; // some 1D fxn\n    \n    #else\n    \n    //return p.x - 1.0 + 0.5 * sin(3.0 * p.y + 2.0 * p.x * p.x); // 3-blade fan\n    \n    vec4 shapes [2];\n    \n    shapes[0] = vec4(3, 3, 14, 2);\n    shapes[1] = vec4(7, 3, 6, 6);\n    \n    float animate = sin(iTime) * 0.5 + 0.5;\n    animate = (max(min(animate, 0.75), 0.25) - 0.25) * 2.0;\n    \n    return mix(Superformula(p, shapes[0]), Superformula(p, shapes[1]), animate);\n    \n    #endif\n}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2(/*1.0 / iResolution.y*/0.1, 0.0);\n    #ifdef OneD\n    vec2 result;\n    result.x = (func(x + h.xy) - func(x - h.xy)) / (2.0 * h.x);\n    result.y = 1.0;\n    return result;\n    #else\n    return vec2(func(x + h.xy) - func(x - h.xy),\n                func(x + h.yx) - func(x - h.yx)) / (2.0 * h.x);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 scrPt = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    #ifdef ROTATE\n    // Rotate the scrPt for funsies\n    float theta = -iTime * 0.25;\n    mat2 rot;\n    \n    // cache calls to sin/cos\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    scrPt *= rot;\n    #endif\n    \n    vec2 inputVal;\n    #ifdef OneD\n    inputVal = scrPt;\n    #else\n    scrPt *= 2.0;\n    inputVal = vec2(length(scrPt * 1.0), atan(scrPt.y, scrPt.x)); // for 3-blade fan\n    #endif\n    \n    float val = func(inputVal);\n    \n    // Compute numerical gradient\n    vec2 gradient;\n    gradient = grad(inputVal);\n    \n    float gradDenom = length(gradient);\n    \n    float valNum;\n    #ifdef OneD\n    valNum = abs(val - scrPt.y); // only subtract for 1D fxns\n    #else\n    valNum = abs(val);\n    #endif\n    \n    float distEst = valNum / gradDenom; // improve distance estimation\n    \n    #ifdef OneD\n    distEst = smoothstep(0.005, 0.0051, distEst);\n    #else\n    distEst = 1.0 - smoothstep(0.0, 0.009, distEst);\n    #endif\n    \n    vec3 color;\n    color = vec3(distEst);\n    \n    // Compute some outline color\n    vec3 outlineCol;\n    \n    float alternate = sign(sin(inputVal.y * 20.0 + iTime * 8.0));\n    outlineCol = mix(vec3(0.2, 0.3, 0.4), vec3(1.0, 0.3, 0.2), alternate);\n    \n    color = outlineCol * pow(color, vec3(0.175));\n    \n    vec3 bgColor;\n    bgColor = vec3(0.08, 0.25, 0.21);\n    color = mix(bgColor, color, ceil(distEst));\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}