{"ver":"0.1","info":{"id":"MXBBDc","date":"1730007595","viewed":28,"name":"Julia depth kuko","username":"kukovisuals","description":"fact","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","julia3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Quaternion Julia Set Rendering Kuko Visuals\n// Inspired by IÃ±igo Quilez's work on fractals\n// https://www.shadertoy.com/view/MsfGRr\n\n// Maximum iterations and escape radius for the fractal\nconst int MAX_ITERATIONS = 20;\nconst float BAILOUT = 4.0;\n\nfloat animateRange(){\n    float animatedValue = 1.0 + sin(iTime) * 0.2;\n    return animatedValue;\n}\n\n// Quaternion multiplication\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x + a.z * b.w - a.w * b.z,\n        a.x * b.z - a.y * b.w + a.z * b.x + a.w * b.y,\n        a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x\n    );\n}\n\n// Quaternion magnitude squared\nfloat qlength2(vec4 q) {\n    return dot(q, q);\n}\n\n// Quaternion Julia set distance estimator\nfloat DE_QuaternionJulia(vec3 pos) {\n    vec4 z = vec4(pos, 0.0);\n    vec4 c = vec4(0.4, 0.651, animateRange(), 0.0); // Constant defining the Julia set shape\n    float dr = 1.0;\n    float r = 0.0;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n\n        // Compute derivative\n        dr = 2.0 * pow(r, 1.0) * dr;\n\n        // Quaternion square: z = z^2 + c\n        z = qmul(z, z) + c;\n    }\n\n    // Distance estimation formula\n    return 0.5 * r * log(r) / dr;\n}\n\n// Calculate normal for lighting using numerical gradient\nvec3 getNormal(vec3 p) {\n    float eps = 0.001;\n    vec3 n;\n    n.x = DE_QuaternionJulia(p + vec3(eps, 0.0, 0.0)) - DE_QuaternionJulia(p - vec3(eps, 0.0, 0.0));\n    n.y = DE_QuaternionJulia(p + vec3(0.0, eps, 0.0)) - DE_QuaternionJulia(p - vec3(0.0, eps, 0.0));\n    n.z = DE_QuaternionJulia(p + vec3(0.0, 0.0, eps)) - DE_QuaternionJulia(p - vec3(0.0, 0.0, eps));\n    return normalize(n);\n}\n\n// Main ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p) {\n    float totalDist = 0.0;\n    const float MAX_DIST = 100.0;\n    const float MIN_DIST = 0.003;\n    const int MAX_STEPS = 40;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * totalDist;\n        float dist = DE_QuaternionJulia(p);\n        if (dist < MIN_DIST || totalDist > MAX_DIST) break;\n        totalDist += dist;\n    }\n    return totalDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, -0.3, -1.2); // Camera position\n    vec3 rd = normalize(vec3(uv, 0.5)); // Ray direction\n\n    // Rotate the scene over time\n    float angle = iTime * 0.04;\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    mat3 rotY = mat3(\n        cosAngle, 0.0, sinAngle,\n        0.0,      1.0,      0.0,\n        -sinAngle, 0.0, cosAngle\n    );\n    ro = rotY * ro;\n    rd = rotY * rd;\n\n    // Ray marching\n    vec3 p;\n    float totalDist = rayMarch(ro, rd, p);\n\n    // Shading\n    vec3 color = vec3(0.0);\n    if (totalDist < 100.0) {\n        vec3 normal = getNormal(p);\n        vec3 lightDir = normalize(vec3(-1.0, 0.0, 1.0));\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        // Coloring based on position and normal for depth effect\n        color = diff * vec3(0.2, 0.6, 1.0) * (1.5 + 0.5 * normal.y);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}