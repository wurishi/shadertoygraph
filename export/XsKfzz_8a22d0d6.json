{"ver":"0.1","info":{"id":"XsKfzz","date":"1527495588","viewed":259,"name":"DAT205 project GPU terrain v0.3","username":"IT_Viking","description":"This is an updated version of https://www.shadertoy.com/view/MsKcRd\n\nAdded snow and grass\nAdded texture on water. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terraingeneration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TODO create a per pixel colour selection function that creates realistic looking cliffsides.\n//TODO try to increase FPS\n//TODO lightsource and shadows?\n//TODO Fog? \n//TODO Add snow line\n//TODO Green when normal is flat.\n\n//TODO add the broken functions for binarysearch again for presentation.\n\nconst int MAX_MARCHING_STEPS = 255; //255\nconst float MIN_DIST = 0.0; //0.0\nconst float MAX_DIST = 100.0; //100\nconst float EPSILON = 0.001; //0.0001\nconst int OCTAVES = 6; //9 is realistic, 3 works for a cartoony landscape\nconst float SCALE_STEP = 0.22; //0.23;\nconst int WATER_WORLD = 1; //True for water, false for land\nconst int BINARY_SEARCH = 0; //Enables binary search algorithm for the raymarcher\n\n// Simple 2d noise algorithm contributed by Trisomie21 (Thanks!)\nfloat snoise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\n// This is my first attempt att creating terrain\nfloat densityFunc(vec3 point, int oct){\n    float dens = point.y + 1.5; //Why do I need to add a float here? \n  \tfloat freq = 0.5;\n    float amp = 2.0;\n    for (int i=0;i<oct; i++){\n   \t\tdens += snoise(point.xz*freq)*amp;\n        //dens += sin(point.x)+sin(point.z)+amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    \n    //dens += snoise(point.xz*1.01);\n    //dens += snoise(point.xz*1.98)*0.5;\n    //dens += snoise(point.xz*4.03)*0.25;\n    \n    \n    return dens; \n\n}\n\n\nvec2 map(vec3 p){\n    \n    if (p.y < -1.0 && WATER_WORLD == 1) return vec2(-1.0, 0);\n    if (p.y < -1.0) return vec2(densityFunc(p, 1)*0.005, 3.0); //This should use a density function tailored for it. \n    float height = densityFunc(p, OCTAVES);\n    \n      //Create a hard floor\n      //if (height >= 1.05) return p.y + 1.05; //THis is bugged. Ask for help. \n    // Do this in the raymarcher instead. \n    \n   \n    \n    return vec2(height, 1);\n}\n\n\n//Raymatching with binary search\nvec2 traceBin(vec3 eye, vec3 viewRayDirection, float start, float end){\n\tfloat depth = start;\n    float scaleStep = SCALE_STEP;\n    \n    for (int i=0; i < MAX_MARCHING_STEPS; i++){\n        vec2 dist = map(eye + depth * viewRayDirection);\n        if (dist.x<EPSILON){//We're inside the geometry\n            float oldDepth = depth; \n            for (int j=0; j<8; j++){\n                if (abs(dist.x)<EPSILON){\n                    return vec2(depth, dist.y); //Correct spot\n                }\n                else if (dist.x>EPSILON){ //depth is too high, continue marching\n                    oldDepth = depth; \n                    depth += dist.x * scaleStep; //Move along the ray\n        \t\t\tif (depth >= end) return vec2(end, -1); //We've gone too far 7\n                }\n                else { //if (dist.x<-EPSILON) //Our step is too long; \n                    scaleStep *= 0.5; //Half the step length and continue; \n                    depth = oldDepth + dist.x * scaleStep; \n                    \n                }\n                dist = map(eye + depth * viewRayDirection);\n                \n            }\n        \treturn vec2(depth, dist.y); \n        }\n        depth += dist.x * scaleStep; //Move along the ray\n        if (depth >= end) return vec2(end, -1); //We've gone too far\n    }\n    if (depth < end) return vec2(depth, -2);\n    return vec2(end, -1);\n}\n\n//Raymarching\nvec2 trace(vec3 eye, vec3 viewRayDirection, float start, float end){\n    if (BINARY_SEARCH == 1) return traceBin(eye, viewRayDirection, start, end);\n\tfloat depth = start;\n    \n    for (int i=0; i < MAX_MARCHING_STEPS; i++){\n        vec2 dist = map(eye + depth * viewRayDirection);\n        if (abs(dist.x)<EPSILON){//We're inside the geometry\n        \treturn vec2(depth, dist.y); \n        }\n        depth += dist.x * SCALE_STEP; //Move along the ray\n        if (depth >= end) return vec2(end, -1); //We've gone too far\n    }\n    if (depth < end) return vec2(depth, -2);\n    return vec2(end, -1);\n}\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n\treturn normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal (vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n \n}\n\nvec3 renderSky (vec3 p, vec3 cameraPos){\n    \n    vec3 sky = vec3(0.5, 0.75, 1.0);\n    \n    if (p.y < 0.01) return sky;\n\t\n    /*oat v = (300.0-cameraPos.y)/p.y;\n\tp.xz *= v;\n    p.xz += cameraPos.xz;\n\tp.xz *= .005;\n    float rand = snoise(p.xz); \n    rand += snoise(p.xz*0.5)*2.0; \n    \n\t*/\n\t\n    float v = (0200.0-cameraPos.y)/p.y;\n\tp.xz *= v;\n\tp.xz += cameraPos.xz;\n\tp.xz *= .005;\n    \n    float rand = snoise(p.xz); \n    rand += snoise(p.xz * 0.5) *2.0;\n\trand = smoothstep(0.0, 0.5, rand);\n    \n    \n    //sky = mix(sky, vec3(.95, .95, .92), clamp(rand*p.y-.1, 0.0, 1.0));\n   \n\treturn vec3(0.5+rand, 0.75+rand/2.0, 1.0);\n}\n\nvec3 renderCliffs(vec3 p){\n    vec3 norm = estimateNormal(p);\n    vec3 colour = vec3(0.0);\n    \n    float r = mix( 0.5, 0.9, norm.x ); //This only works due to the angle we are looking from.\n    if (norm.y>0.45 && p.y>0.5) { //Adds terrain effects\n        colour = vec3(0.8+r*0.5, 0.8+r, 1.0);//Add snow\n    }else if (norm.y>0.6) { \n        colour = vec3(0.5, 0.4+r*0.5, 0.3+r*0.1); //add grass\n\n    } else {\t\n\t\tcolour = vec3(0.85*r, 0.75*r, 0.75*r);\n    }\n    /*\n    if (norm.y==1.0) colour = vec3(0.0, 0.8, 1.0);\n    else if (norm.y>0.9) colour = vec3(1.0, 1.0, 1.0);\n    else if (norm.y>0.7) colour = vec3(0.9, 0.9, 1.0);\n    else if (norm.y>0.5) colour = vec3(0.3, 0.3, 0.3);\n    else if (norm.y>0.3) colour = vec3(0.4, 0.4, 0.4);\n    else if (norm.y>0.1) colour = vec3(0.5, 0.5, 0.5);\n    else colour = vec3(0.6, 0.6, 0.6);\n    */\n    return colour; \n}\n\nvec3 renderGrass(vec3 p){\n    vec3 norm = estimateNormal(p);\n    float r = mix( 0.5, 0.9, norm.x );\n    return vec3(0.5, 0.3+r*0.4, 0.2+r*0.1);\n}\n\nvec3 renderWater(vec3 p, vec3 cameraPos){\n     vec3 water = vec3(0.0, 0.3, 0.4);\n    \n    if (p.y > 0.01) return water;\n\t\t\n    float v = (0200.0-cameraPos.y)/p.y;\n\tp.xz *= v;\n\tp.xz += cameraPos.xz;\n\tp.xz *= .005;\n    \n    float rand = snoise(p.xz); \n    rand += snoise(p.xz * 0.5) *2.0;\n    rand += snoise(p.xz * 0.25) *4.0;\n\t//rand = smoothstep(0.0, 0.3, rand);\n    \n    \n    //return mix(water, vec3(.92, .92, .95), clamp(rand*p.y-.1, 0.0, 1.0));\n   \n\treturn vec3(0.1-rand*0.015, 0.35-rand*0.015, 0.55-rand*0.005);\n\t//return vec3(0.0, 0.3, 0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    \n    \n    //This is the trace to render\n    vec3 dir = rayDirection (45.0, iResolution.xy, fragCoord); //45 FoV before experimenting\n    \n    /*\n    //Let's try to trace down\n    vec3 dirDown =  rayDirection (45.0, iResolution.xy, vec2(1.0, 0.5));\n    vec2 distDown = trace(vec3(0.0, 0.1, -iTime*2.0), dir, MIN_DIST, MAX_DIST);\n    vec3 eye = vec3(0.0, 1.0-distDown.x* 0.5, -iTime*2.0);\n    */\n    \n    vec3 eye = vec3(0.0, 1.5, -iTime*2.0);\n    //vec3 eye = vec3(0.0, 1.0, 15.0);\n    vec2 dist = trace(eye, dir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    //Render sky\n    if (dist.x > MAX_DIST - EPSILON) { \n        //Didn't hit anything\n        fragColor = vec4(renderSky(eye + dist.x * dir, eye), 0.0);\n        return;\n    }\n    // The closest point on the surface to the eyepoint along the view ray\n    if (dist.y == 1.0) fragColor = vec4(renderCliffs(eye + dist.x * dir), 0.0); //Cliffs\n    else if (WATER_WORLD == 1) fragColor = vec4(renderWater(eye + dist.x * dir, eye), 0.0); //water\n    else  fragColor = vec4(renderGrass(eye + dist.x * dir), 0.0); //grass \n    \n}","name":"Image","description":"","type":"image"}]}