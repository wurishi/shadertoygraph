{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\n    \"Circle Anti-aliasing\" by @XorDev\n    \n    Often shaders introduce hard edges (aliasing) unintentionally.\n    Aliasing is fine if you're going for pixelated style, but aliasing\n    rarely occurs in nature and it often makes shaders look fake.\n    \n    The simplest example I could think of is to draw a circle. You could\n    draw a circle by checking if a pixel is within the radius of the circle.\n    Like: fragColor = vec4(dist < rad);\n    It does however introduce hard pixel edges.\n    Alternatively, if you know (or can approximate) how close a pixel is\n    to the edge, you can do a little sub-pixel gradient along the edge.\n    This is easy to do with distance-fields because they have a\n    consistent scale, but it can also be approximated when needed.\n    \n    \n    More on this in the full tutorial:\n    https://mini.gmshaders.com/p/antialiasing\n*/\n\n//Number of pixel rows\n#define ROWS 20.0\n//Edge softness (0.5 spreads across 2 pixels)\n#define SOFT 0.5\n//Gamma for gamma correction\n#define GAMMA 2.2\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    //Center the fragment coordinates\n    vec2 center = fragCoord - 0.5*iResolution.xy;\n    //Screen height for scaling\n    float height = iResolution.y;\n    //Set texel scale\n    float texel = 1.0 / ROWS;\n    //Set the displayed pixel scale\n    float scale = height * texel;\n    \n    //Get centered pixel coordinates\n    vec2 pixel = floor(center/scale)+0.5;\n\n    //Circle radius (0.5 spans the full screen height)\n    float radius = 0.35+0.1*cos(iTime);\n    //Get the distance to the circle in texel units\n    float dist = radius - texel * length(pixel);\n    \n    //Move divider with mouse\n    float mouse = (iResolution.x*0.5-iMouse.x)*float(iMouse.z>0.0);\n    //Display anti-aliasing on the right\n    bool AA = pixel.x*scale+mouse>0.0;\n    //Circle with hard clipping\n    float clip = float(dist>0.0);\n    //Circle with smooth gradient edges\n    float grad = clamp(dist / texel + 0.5, 0.0, 1.0);\n\n    //Toggle anti-aliasing across divider\n    fragColor = vec4(AA ? grad : clip);\n    \n    //Red circle alpha:\n    //Ring distance in pixel units\n    float ring = abs(radius*height - length(center));\n    //Set thickness based on pixel scale\n    float circle = clamp(SOFT*(0.08*scale - ring) + 0.5, 0.0, 1.0);\n    \n    //Green pixel alpha:\n    //Distance to nearest dot cell\n    float dots = distance(pixel*scale, center);\n    //Set thickness based on pixel scale\n    float pixels = clamp(SOFT*(0.12*scale - dots) + 0.5, 0.0, 1.0);\n    //Only draw pixels within radius\n    pixels *= float(dist > -0.5*texel*float(AA));\n    \n    //Blue divider alpha:\n    float divider = clamp(SOFT * (0.1*scale - abs(center.x+mouse))+0.5, 0.0, 1.0);\n    \n    //Blend elements together\n    fragColor += (vec4(1,0,0,1) - fragColor) * circle;\n    fragColor += (vec4(0,1,0,1) - fragColor) * pixels;\n    fragColor += (vec4(0,0,1,1) - fragColor) * divider;\n    //Gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/GAMMA));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcKcWh","date":"1734125618","viewed":704,"name":"Circle Anti-aliasing","username":"Xor","description":"Often times shaders introduce hard edges (aliasing) unintentionally. Aliasing is fine if you're going for pixelated style, but aliasing rarely occurs in nature and it often makes shaders look fake.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""}}