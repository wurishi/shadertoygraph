{"ver":"0.1","info":{"id":"lctGRB","date":"1711851493","viewed":533,"name":"20240331_Brainfiller","username":"0b5vr","description":"The shadertoy port of \"Brainfiller\", my Windows 4kb intro\n","likes":33,"published":1,"flags":40,"usePreview":0,"tags":["3d","pathtracing","quadtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture( iChannel0, fragCoord / iResolution.xy );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = acos(-1.0);\nconst float TAU = PI + PI;\nconst float FAR = 30.0;\n\nconst int SAMPLES_PER_FRAME = 15;\nconst int TRAVERSAL_STEPS = 30;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) min(max(((x) - (a)) / ((b) - (a)), 0.0), 1.0)\n\n// == common =======================================================================================\nuvec3 seed;\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash3f( vec3 s ) {\n  uvec3 r = floatBitsToUint( s );\n  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;\n  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;\n  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;\n  return vec3( r ) / float( -1u );\n}\n\nvec2 cis(float t) {\n  return vec2(cos(t), sin(t));\n}\n\nmat2 rotate2D(float t) {\n  return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nmat3 orthBas(vec3 z) {\n  z = normalize(z);\n  vec3 up = abs(z.y) < 0.99 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n  vec3 x = normalize(cross(up, z));\n  return mat3(x, cross(z, x), z);\n}\n\n// == noise ========================================================================================\nvec3 cyclicNoise(vec3 p, float pers) {\n  vec4 sum = vec4(0.0);\n\n  for (int i = 0; i ++ < 4;) {\n    p *= orthBas(vec3(-1.0, 2.0, -3.0));\n    p += sin(p.yzx);\n    sum = (sum + vec4(cross(sin(p.zxy), cos(p)), 1.0)) / pers;\n    p *= 2.0;\n  }\n\n  return sum.xyz / sum.w;\n}\n\n// == isects =======================================================================================\nvec4 isectBox(vec3 ro, vec3 rd, vec3 s) {\n  vec3 xo = -ro / rd;\n  vec3 xs = abs(s / rd);\n\n  vec3 dfv = xo - xs;\n  vec3 dbv = xo + xs;\n\n  float df = max(max(dfv.x, dfv.y), dfv.z);\n  float db = min(min(dbv.x, dbv.y), dbv.z);\n  if (df < 0.0 || db < df) { return vec4(FAR); }\n\n  vec3 n = -sign(rd) * step(vec3(df), dfv);\n  return vec4(n, df);\n}\n\nvec4 isectSphere(vec3 ro, vec3 rd, float r) {\n  float b = dot(ro, rd);\n  float c = dot(ro, ro) - r * r;\n  float h = b * b - c;\n\n  float rl = -b - sqrt(h);\n  if (h < 0.0 || rl < 0.0) { return vec4(FAR); }\n\n  return vec4(normalize(ro + rd * rl), rl);\n}\n\n// == main =========================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  fragColor *= 0.0;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 p = uv - 0.5;\n  p.x *= iResolution.x / iResolution.y;\n\n  vec3 seed = hash3f(vec3(p, iTime));\n  float time = iTime;\n  float beat = time * 135.0 / 60.0;\n\n  for (int i = 0; i ++ < SAMPLES_PER_FRAME;) {\n    vec3 colRem = mix(\n      vec3(-0.0001, 0.0001, 1.0),\n      vec3(-0.4, 0.1, 1.0),\n      smoothstep(31.5, 32.5, beat) * smoothstep(224.5, 223.5, beat)\n    );\n\n    vec3 ro = orthBas(colRem) * vec3(1.5 * (p + (seed = hash3f(seed)).xy / iResolution.y) + vec2(0, 0.1 * time), 6.0) - vec3(0.0, 0.0, 2.0);\n    vec3 rd = orthBas(colRem) * vec3(0.0, 0.0, -1.0);\n\n    colRem /= colRem;\n\n    for (int i = 0; i ++ < TRAVERSAL_STEPS;) {\n      mat3 material = mat3(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0, 1.0, 0.0)\n      );\n\n      vec4 isect = isectBox(ro + vec3(0.0, 0.0, 5.0), rd, vec3(1E3, 1E3, 0.01));\n      vec4 isect2;\n\n      {\n        // quadtree subdivision\n        ro += rd * 0.001;\n\n        const float QUADTREE_SIZE = 0.5;\n        const float QUADTREE_DEPTH = 6.0;\n\n        float gen;\n        vec3 cell = vec3(0.0, 0.0, 0.5 * FAR);\n        vec3 cellSize = vec3(FAR);\n        vec3 cellDice = vec3(1e9);\n\n        if (ro.z < 0.0) {\n          cellSize = vec3(QUADTREE_SIZE, QUADTREE_SIZE, QUADTREE_DEPTH);\n          for (int i = 0; i ++ < 5; ) {\n            cellSize.xy *= 0.5 + 0.5 * step(gen < 96.0 ? 0.3 : gen < 160.0 ? 0.4 : gen < 256.0 ? 0.5 : 0.3, cellDice.xy);\n            cellSize.z = QUADTREE_DEPTH;\n\n            cell = (floor(ro / cellSize) + 0.5) * cellSize;\n            cell.z = 0.0;\n\n            gen = floor(\n              dot(cell + cellSize / 2.0 - vec3(0.0, 0.1 * time, 0.0), vec3(-0.03, 0.3, 0.0)) + beat\n            );\n            cellDice = hash3f(cell + clamp(gen, 31.0, 288.0));\n          }\n        }\n\n        ro -= rd * 0.001;\n\n        {\n          // quadtree traversal\n          vec3 i_src = -( ro - cell ) / rd;\n          vec3 i_dst = abs( 0.5 * cellSize / rd );\n          vec3 bvOrRot = i_src + i_dst;\n          float distToNextCell = min(min(bvOrRot.x, bvOrRot.y), bvOrRot.z);\n\n          vec3 rand = vec3(0.0);\n\n          // scene\n          bvOrRot = ro - cell + vec3(0.0, 0.0, 5.5 + cellDice.y);\n\n          cellDice = hash3f(cellDice);\n\n          isect2 = isectBox(\n            bvOrRot,\n            rd,\n            vec3(0.5 * cellSize.xy - 0.004, 4.0)\n          );\n\n          if (cell.z != 0.0) {\n            // skip\n\n          } else if (cellSize.x == cellSize.y && cellSize.x < 1.0 && cellDice.x < 0.1) { // sphere\n            if (isect2.w < isect.w) {\n              isect = isect2;\n\n              material = mat3(\n                vec3(0.04),\n                vec3(0.0),\n                vec3(0.1, 0.0, 0.0)\n              );\n            }\n\n            vec3 rotSphere = bvOrRot - vec3(0.0, 0.0, 4.0 + 0.5 * cellSize);\n            isect2 = isectSphere(\n              rotSphere,\n              rd,\n              0.4 * min(cellSize.x, cellSize.y)\n            );\n\n            if (isect2.w < isect.w) {\n              isect = isect2;\n\n              vec3 i_noise = cyclicNoise(4.0 * (ro + rd * isect.w + cellDice), 0.5);\n              // vec3 coord = ((rotSphere + rd * isect.w) * orthBas(vec3(cis(time + TAU * cellDice.z), 3.0))) / cellSize.x;\n              // material = mat3(\n              //   mix(\n              //     vec3(0.8, 0.6, 0.02),\n              //     vec3(0.02),\n              //     step(0.0, coord.z) * (\n              //       step(length(abs(coord.xy * vec2(2.0, 1.0) - vec2(0.0, 0.15)) - vec2(0.2, 0.0)), 0.1)\n              //       + step(abs(length(coord.xy) - 0.24), step(1.9, abs(atan(coord.x, coord.y))) * 0.01 + step(abs(abs(atan(coord.x, coord.y)) - 1.9), 0.05) * 0.02)\n              //     )\n              //   ),\n              //   vec3(0.0),\n              //   vec3(0.1, 0.0, 0.0)\n              // );\n\n              material = mat3(\n                vec3(0.63, 0.65, 0.66),\n                vec3(0.0),\n                vec3(0.1, 1.0, 0.0)\n              );\n            }\n          } else if (cellSize.x == cellSize.y && cellSize.x < 1.0 && cellDice.x < (gen > 63.0 ? 0.8 : 0.3)) { // holo\n            if (isect2.w < isect.w) {\n              isect = isect2;\n\n              material = mat3(\n                vec3(0.4),\n                vec3(0.0),\n                vec3(0.04, 1.0, 0.0)\n              );\n            }\n\n            vec3 rotPlane = bvOrRot - vec3(0.0, 0.0, 4.02);\n            isect2 = isectBox(\n              rotPlane,\n              rd,\n              vec3(cellSize.xy, 0.001)\n            );\n            if (isect2.w < isect.w) {\n              vec3 coord = (bvOrRot + rd * isect2.w);\n              vec2 ncoord = ((coord / (0.5 * cellSize - 0.004)).xy);\n\n              float mask = step(max(abs(ncoord.x), abs(ncoord.y)), 0.9) * (\n                cellDice.y < 0.2 ? step(length(ncoord), 0.9) * step(0.5, length(ncoord)) :\n                cellDice.y < 0.4 ? max(step(abs(ncoord.x + ncoord.y), 0.3), step(abs(ncoord.x - ncoord.y), 0.3)) :\n                cellDice.y < 0.5 ? max(step(abs(ncoord.y), 0.2), step(abs(ncoord.x), 0.2)) :\n                cellDice.y < 0.6 ? max(step(abs(ncoord.y), 0.22) * step(ncoord.x, 0.3), step(abs(abs(ncoord.y) + ncoord.x - 0.6), 0.3) * step(abs(ncoord.y), 0.8)) :\n                cellDice.y < 0.7 ? step(abs(abs(ncoord.y) - 0.4), 0.2) :\n                cellDice.y < 0.8 ? step(hash3f(floor(ncoord.xyy / 0.45) + cellDice).x, 0.5) * step(length(fract(ncoord / 0.45) - 0.5), 0.4) :\n                cellDice.y < 0.9 ? step(max(abs(ncoord.x), abs(ncoord.y)), 0.9) * step(0.6, max(abs(ncoord.x), abs(ncoord.y))) :\n                max(step(max(abs(ncoord.x), abs(ncoord.y)), 0.1), step(min(abs(ncoord.x), abs(ncoord.y)), 0.3) * step(0.3, max(abs(ncoord.x), abs(ncoord.y))) * step(max(abs(ncoord.x), abs(ncoord.y)), 0.5))\n              );\n\n              if (mask > 0.0) {\n                isect = isect2;\n\n                material = mat3(\n                  vec3(0.0),\n                  (0.54 - 0.5 * cos(9.0 * PI * max(smoothstep(128.5, 127.5, beat), smoothstep(159.5, 160.5, beat)))) * vec3(1.0, 2.0, 3.0) * (1.0 + 0.5 * sin(120.0 * (coord.y + time))),\n                  vec3(0.0, 1.0, 0.0)\n                );\n              }\n            }\n\n          } else if (cellSize.x * cellSize.y < 0.125 && cellDice.x < 0.5 * pow(smoothstep(128.0, 160.0, gen), 2.0) * step(gen, 255.0)) { // grafix\n            isect2 = isectBox(\n              bvOrRot,\n              rd,\n              vec3(0.5 * cellSize.xy - 0.004, 3.5 + smoothstep(159.5, 160.5, beat))\n            );\n\n            if (isect2.w < isect.w) {\n              isect = isect2;\n\n              vec3 coord = (bvOrRot + rd * isect.w);\n              vec3 i_gridcoord = (coord - vec3(0.0, 0.0, 4.5)) / (cellSize - 0.008) * cellSize;\n              vec2 uv = 0.5 + ((coord / (cellSize - 0.008)).xy);\n              vec3 grafix =\n                cellDice.y < 0.05 ? vec3(1.0) :\n                cellDice.y < 0.2 ? max(sin(80.0 * cyclicNoise(5.0 * coord + 8.0 * cellDice, 0.5).x + 20.0 * time + vec3(0.0, 1.0, 2.0)), 0.0) :\n                cellDice.y < 0.4 ? saturate(abs(mod(6.0 * (uv.y + time + cellDice.z) + vec3(0, 4, 2), 6.0) - 3.0) - 1.0) :\n                cellDice.y < 0.6 ? vec3(dot(1.0 - abs(isect.xyz), 1.0 - step(0.05, abs(fract(64.0 * i_gridcoord + 0.5) - 0.5)))) :\n                cellDice.y < 0.8 ? step(0.5, vec3(fract(20.0 * (abs(coord.x) + abs(coord.y) + abs(coord.z) + cellDice.z) - 3.0 * time))) :\n                cellDice.y < 0.95 ? vec3(step(hash3f(floor(coord * 256.0) + floor(beat * 4.0) + cellDice).x, 0.4)) :\n                vec3(0.02, 0.02, 1.0);\n\n              material = mat3(\n                vec3(0.0),\n                grafix,\n                vec3(0.04, 0.0, 0.0)\n              );\n            }\n\n          } else {\n            if (isect2.w < isect.w) {\n              isect = isect2;\n\n              material = mat3(\n                vec3(0.8, 0.82, 0.85),\n                vec3(0.0),\n                vec3(0.2, step(0.5, cellDice.y), 0.0)\n              );\n            }\n          }\n\n          rand += 1.0 + step(0.5, cellDice);\n\n          // should we skip the cell?\n          if (distToNextCell < isect.w) {\n            ro += distToNextCell * rd;\n            continue;\n          }\n        }\n      }\n\n      if (isect.w > FAR - 1.0) {\n        break;\n      }\n\n      vec3 i_baseColor = material[0];\n      vec3 i_emissive = material[1];\n      float i_roughness = material[2].x;\n      float i_metallic = material[2].y;\n\n      fragColor.xyz += colRem * i_emissive;\n\n      // if hit then\n      ro += isect.w * rd + isect.xyz * 0.001;\n      float sqRoughness = i_roughness * i_roughness;\n      float sqSqRoughness = sqRoughness * sqRoughness;\n      float halfSqRoughness = 0.5 * sqRoughness;\n\n      {\n        float NdotV = dot( isect.xyz, -rd );\n        float Fn = mix( 0.04, 1.0, pow( 1.0 - NdotV, 5.0 ) );\n        float spec = max(\n          step((seed = hash3f(seed)).x, Fn), // non metallic, fresnel\n          i_metallic // metallic\n        );\n\n        // sample ggx or lambert\n        seed.y = sqrt( ( 1.0 - seed.y ) / ( 1.0 - spec * ( 1.0 - sqSqRoughness ) * seed.y ) );\n        vec3 woOrH = orthBas( isect.xyz ) * vec3(\n          sqrt( 1.0 - seed.y * seed.y ) * sin( TAU * seed.z + vec2( 0.0, TAU / 4.0 ) ),\n          seed.y\n        );\n\n        if (spec > 0.0) {\n          // specular\n          // note: woOrH is H right now\n          vec3 i_H = woOrH;\n          vec3 i_wo = reflect(rd, i_H);\n          if (dot(i_wo, isect.xyz) < 0.0) {\n            break;\n          }\n\n          // vector math\n          float NdotL = dot( isect.xyz, i_wo );\n          float i_VdotH = dot( -rd, i_H );\n          float i_NdotH = dot( isect.xyz, i_H );\n\n          // fresnel\n          vec3 i_F0 = mix(vec3(0.04), i_baseColor, i_metallic);\n          vec3 i_Fh = mix(i_F0, vec3(1.0), pow(1.0 - i_VdotH, 5.0));\n\n          // brdf\n          // colRem *= Fh / Fn * G * VdotH / ( NdotH * NdotV );\n          colRem *= max(\n            i_Fh / mix(Fn, 1.0, i_metallic)\n              / ( NdotV * ( 1.0 - halfSqRoughness ) + halfSqRoughness ) // G1V / NdotV\n              * NdotL / ( NdotL * ( 1.0 - halfSqRoughness ) + halfSqRoughness ) // G1L\n              * i_VdotH / i_NdotH,\n            0.0\n          );\n\n          // wo is finally wo\n          woOrH = i_wo;\n        } else {\n          // diffuse\n          // note: woOrH is wo right now\n          if (dot(woOrH, isect.xyz) < 0.0) {\n            break;\n          }\n\n          // calc H\n          // vector math\n          vec3 i_H = normalize( -rd + woOrH );\n          float i_VdotH = dot( -rd, i_H );\n\n          // fresnel\n          float i_Fh = mix(0.04, 1.0, pow(1.0 - i_VdotH, 5.0));\n\n          // brdf\n          colRem *= (1.0 - i_Fh) / (1.0 - Fn) * i_baseColor;\n        }\n\n        // prepare the rd for the next ray\n        rd = woOrH;\n\n        // if the ray goes beind the surface, invalidate it\n        colRem *= max(step(0.0, dot(woOrH, isect.xyz)), 0.0);\n      }\n\n      if (dot(colRem, colRem) < 0.01) {\n        break;\n      }\n    }\n\n    fragColor.xyz += vec3(1.0, 2.0, 3.0) * step(0.0, saturate(rd.z)) * colRem * step(mod(beat - 1.25 + 0.5 * rd.y, 4.0), 0.1) * smoothstep(16.0, 32.0, beat);\n  }\n\n  fragColor = mix(\n    max(sqrt(fragColor / float(SAMPLES_PER_FRAME)), 0.0),\n    max(texture(iChannel0, uv), 0.0),\n    0.5\n  ) * smoothstep(0.0, 16.0, beat) * smoothstep(320.0, 288.0, beat);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n#define saturate(i) clamp(i,0.,1.)\n#define linearstep(a,b,x) saturate(((x)-(a))/((b)-(a)))\n#define p2f(i) (exp2(((i)-69.)/12.)*440.)\n#define repeat(i, n) for(int i=0; i<(n); i++)\n#define inRange(t,a,b) (step(a,t)*(1.-step(b,t)))\n#define inRangeB(t,a,b) ((a<=t)&&(t<b))\n\nconst float PI = acos( -1.0 );\nconst float TAU = PI * 2.0;\nconst float GOLD = PI * (3.0 - sqrt(5.0));// 2.39996...\n\nconst float BPS = 2.25;\nconst float B2T = 1.0 / BPS;\nconst float S2T = 0.25 * B2T;\nconst float SWING = 1.15;\n\nuvec3 hash3u(uvec3 v) {\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * v.z;\n  v.y += v.z * v.x;\n  v.z += v.x * v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y * v.z;\n  v.y += v.z * v.x;\n  v.z += v.x * v.y;\n\n  return v;\n}\nvec3 hash3f(vec3 v) {\n  uvec3 u = hash3u(floatBitsToUint(v));\n  return vec3(u) / float(-1u);\n}\n\nvec2 cis(float t) {\n  return vec2(cos(t), sin(t));\n}\n\nmat2 rotate2D( float x ) {\n  vec2 v = cis(x);\n  return mat2(v.x, v.y, -v.y, v.x);\n}\n\nmat3 orthBas(vec3 z) {\n  z = normalize(z);\n  vec3 x = normalize(cross(vec3(0, 1, 0), z));\n  vec3 y = cross(z, x);\n  return mat3(x, y, z);\n}\n\nvec3 cyclicNoise(vec3 p, float pers) {\n  vec4 sum = vec4(0.0);\n\n  for (int i = 0; i ++ < 4;) {\n    p *= orthBas(vec3(-1.0, 2.0, -3.0));\n    p += sin(p.yzx);\n    sum = (sum + vec4(cross(sin(p.zxy), cos(p)), 1.0)) / pers;\n    p *= 2.0;\n  }\n\n  return sum.xyz / sum.w;\n}\n\n\nvec2 shotgun( float t, float spread ) {\n  vec2 sum = vec2( 0.0 );\n\n  for ( int i = 0; i < 64; i ++ ) {\n    vec3 dice = hash3f( vec3( i ) );\n    sum += vec2( sin( TAU * t * exp2( spread * dice.x ) ) ) * rotate2D( TAU * dice.y );\n  }\n\n  return sum / 64.0;\n}\n\nvec2 cheapnoise(float t) {\n  uvec3 s=uvec3(t * 256.0);\n  float p=fract(t * 256.0);\n\n  vec3 dice;\n  vec2 v = vec2(0.0);\n\n  dice=vec3(hash3u(s + 0u)) / float(-1u) - vec3(0.5, 0.5, 0.0);\n  v += dice.xy * smoothstep(1.0, 0.0, abs(p + dice.z));\n  dice=vec3(hash3u(s + 1u)) / float(-1u) - vec3(0.5, 0.5, 1.0);\n  v += dice.xy * smoothstep(1.0, 0.0, abs(p + dice.z));\n  dice=vec3(hash3u(s + 2u)) / float(-1u) - vec3(0.5, 0.5, 2.0);\n  v += dice.xy * smoothstep(1.0, 0.0, abs(p + dice.z));\n\n  return 2.0 * v;\n}\n\nvec2 ladderLPF(float freq, float cutoff, float reso) {\n  float omega = freq / cutoff;\n  float omegaSq = omega * omega;\n\n  float a = 4.0 * reso + omegaSq * omegaSq - 6.0 * omegaSq + 1.0;\n  float b = 4.0 * omega * (omegaSq - 1.0);\n\n  return vec2(\n    1.0 / sqrt(a * a + b * b),\n    atan(a, b)\n  );\n}\n\nvec2 twoPoleHPF(float freq, float cutoff, float reso) {\n  float omega = freq / cutoff;\n  float omegaSq = omega * omega;\n\n  float a = 2.0 * (1.0 - reso) * omega;\n  float b = omegaSq - 1.0;\n\n  return vec2(\n    omegaSq / sqrt(a * a + b * b),\n    atan(a, b)\n  );\n}\n\nvec4 quant(float x, float ks, float kt, out float i) {\n  i = floor(floor(x / ks + 1E-4) * ks / kt + 1E-4);\n\n  float s = kt <= ks\n    ? ks * floor(x / ks + 1E-4)\n    : ks * ceil(i * kt / ks - 1E-4);\n  float l = kt <= ks\n    ? ks\n    : ks * ceil((i + 1.0) * kt / ks - 1E-4) - s;\n\n  float t = x - s;\n  float q = l - t;\n\n  return vec4(s, t, s + l, q);\n}\n\nvec4 quant(float x, float ks, float kt) {\n  float i;\n  return quant(x, ks, kt, i);\n}\n\nfloat swing(float x, float k) {\n  float xm = mod(x, 2.0);\n  return x + (1.0 - k) * linearstep(0.0, k, xm) * linearstep(2.0, k, xm);\n}\n\nfloat unswing(float x0, float x, float y, float k) {\n  return (\n    x0\n    - 2.0 * floor((x - y) / 2.0)\n    - k * linearstep(0.0, 1.0, mod(x - y, 2.0))\n    - (2.0 - k) * linearstep(1.0, 2.0, mod(x - y, 2.0))\n  );\n}\n\nfloat cheapFilterSaw( float phase, float k ) {\n  float i_wave = fract( phase );\n  float i_c = smoothstep( 1.0, 0.0, i_wave / k );\n  return ( i_wave + i_c ) * 2.0 - 1.0 - k;\n}\n\nfloat CHORDS[] = float[](\n  0.0, 2.0, 3.0, 7.0, 14.0, 15.0, 19.0, 22.0,\n  -5.0, 2.0, 3.0, 5.0, 7.0, 10.0, 14.0, 15.0,\n  -4.0, 0.0, 3.0, 7.0, 14.0, 15.0, 19.0, 24.0,\n  -7.0, 0.0, 7.0, 8.0, 10.0, 12.0, 15.0, 19.0\n);\n\nvec2 mainSound( int samp, float _time ) {\n  int SAMPLES_PER_STEP = int( iSampleRate / BPS / 4.0 );\n  int SAMPLES_PER_BEAT = 4 * SAMPLES_PER_STEP;\n\n\n  vec4 time = vec4(samp % (SAMPLES_PER_BEAT * ivec4(1, 4, 64, 65536))) / iSampleRate;\n  vec4 beats = time * BPS;\n\n  // return float( max( 0, frame + SAMPLES_PER_STEP * offset ) % ( SAMPLES_PER_STEP * every ) ) / SAMPLES_PER_SEC;\n\n  vec2 dest = vec2(0);\n  float sidechain;\n\n  { // kick\n    float t = time.x;\n    float q = B2T - t;\n    sidechain = 0.2 + 0.8 * smoothstep(0.0, 0.4, t) * smoothstep(0.0, 0.001, q);\n\n    float env = smoothstep(0.0, 0.001, q) * smoothstep(2.0 * B2T, 0.1 * B2T, t);\n\n    if (128.0 < beats.w && beats.w < 160.0) {\n      env *= exp(-70.0 * t);\n    }\n\n    if (32.0 < beats.w && beats.w < 287.9) {\n      float wave = sin(\n        270.0 * t\n        - 40.0 * exp(-t * 20.0)\n        - 20.0 * exp(-t * 60.0)\n        - 10.0 * exp(-t * 300.0)\n        - 0.4 * sin(120.0 * t)\n      );\n      dest += 0.6 * tanh(2.0 * env * wave);\n    }\n  }\n\n  if (64.0 - 0.75 < beats.w && beats.w < 256.0) { // hihat\n    float t = mod(time.x, S2T);\n    float st = mod(floor(time.y / S2T), 16.0);\n\n    float vel = fract(st * 0.2 + 0.42);\n    float env = exp(-exp2(7.0 - 3.0 * vel) * t);\n    vec2 wave = shotgun(6000.0 * t, 2.0);\n    dest += 0.2 * env * sidechain * tanh(8.0 * wave);\n  }\n\n  if (96.0 < beats.w && beats.w < 290.0) { // clap\n    float t = mod(time.y + S2T, 4.0 * B2T);\n\n    float env = mix(\n      exp(-26.0 * t),\n      exp(-200.0 * mod(t, 0.013)),\n      exp(-80.0 * max(0.0, t - 0.02))\n    );\n\n    vec2 wave = cyclicNoise(vec3(4.0 * cis(800.0 * t), 1940.0 * t), 1.5).xy;\n\n    dest += 0.1 * tanh(20.0 * env * wave);\n  }\n\n  if (32.0 < beats.w && beats.w < 256.0) { // shaker\n    float t = mod(time.x, S2T);\n    float st = mod(floor(time.y / S2T), 16.0);\n\n    float vel = fract(st * 0.41 + 0.63);\n    float env = smoothstep(0.0, 0.02, t) * exp(-exp2(6.0 - 3.0 * vel) * t);\n    vec2 wave = cyclicNoise(vec3(cis(2800.0 * t), exp2(8.0 + 3.0 * vel) * t), 0.8).xy;\n    dest += 0.15 * env * sidechain * tanh(2.0 * wave);\n  }\n\n  { // perc 1\n    float t = mod(time.z - S2T, 6.0 * S2T);\n\n    float env = mix(\n      exp(-t),\n      exp(-30.0 * t),\n      0.95\n    );\n    vec2 wave = sin(7100.0 * t + vec2(0, PI / 2.0) + 10.0 * cheapnoise(t));\n    dest += 0.3 * env * tanh(wave) * smoothstep(128.0, 160.0, beats.w);\n  }\n\n  { // perc 2\n    float t = mod(time.z - 3.0 * S2T, 6.0 * S2T);\n\n    float env = mix(\n      exp(-t),\n      exp(-30.0 * t),\n      0.95\n    );\n    vec2 wave = 2.0 * fract(1200.0 * t + sin(1000.0 * t) + vec2(0.0, 0.25)) - 1.0;\n    dest += 0.3 * env * tanh(wave) * smoothstep(128.0, 160.0, beats.w);\n  }\n\n  { // beep\n    float t = mod(time.y - 5.0 * S2T, 16.0 * S2T);\n\n    float env = smoothstep(0.0, 0.001, t) * mix(\n      exp(-2.0 * t),\n      smoothstep(0.0, 0.001, 0.07 - t),\n      0.98\n    );\n    vec2 wave = sin(50000.0 * t + vec2(PI / 2.0, 0));\n    dest += 0.2 * env * wave * smoothstep(16.0, 32.0, beats.w);\n  }\n\n  if (96.0 < beats.w) { // crash\n    float t = mod(time.z - 32.0 * B2T, 64.0 * B2T);\n\n    float env = mix(exp(-t), exp(-10.0 * t), 0.7);\n    vec2 wave = shotgun(3800.0 * t, 2.0);\n    dest += 0.3 * env * sidechain * tanh(8.0 * wave);\n  }\n\n  if (160.0 < beats.w && beats.w < 224.0) { // ride\n    float t = mod(time.x, 2.0 * S2T);\n    float q = 2.0 * S2T - t;\n\n    float env = exp(-5.0 * t);\n\n    vec2 sum = vec2(0.0);\n\n    repeat(i, 8) {\n      vec3 dice = hash3f(vec3(i));\n      vec3 dice2 = hash3f(dice);\n\n      vec2 wave = vec2(0.0);\n      wave = 4.5 * env * sin(wave + exp2(12.10 + 0.1 * dice.x) * t + dice2.xy);\n      wave = 2.2 * env * sin(wave + exp2(14.67 + 0.5 * dice.y) * t + dice2.yz);\n      wave = 1.0 * env * sin(wave + exp2(13.89 + 1.0 * dice.z) * t + dice2.zx);\n\n      sum += wave;\n    }\n\n    dest += 0.08 * env * sidechain * tanh(sum);\n  }\n\n  { // additive riff\n    vec2 sum = vec2(0.0);\n\n    float t = mod(time.x, S2T);\n    float q = S2T - t;\n    float st = floor(time.z / S2T);\n    float env = smoothstep(0.0, 0.01, t) * smoothstep(0.0, 0.01, q);\n\n    float basefreq = 80.0;\n    float stmod = fract(0.615 * st);\n\n    float cutenv = smoothstep(0.0, 0.01, t) * exp(-14.0 * t);\n    float cutoff = exp2(\n      5.0\n      - 2.0 * smoothstep(32.0, 16.0, beats.w)\n      + 2.5 * smoothstep(128.0, 160.0, beats.w)\n      - step(256.0, beats.w)\n      - 2.0 * smoothstep(288.0, 320.0, beats.w)\n      + 3.0 * stmod\n      + 4.0 * cutenv\n    );\n\n    repeat(i, 128) {\n      float fi = float(i);\n\n      float p = 1.0 + fi;\n      p = pow(p, 1.1); // metal\n      p = mix(p, 1.0, 0.1); // centroid\n      float freq = basefreq * p;\n\n      vec2 phase = vec2(t * freq);\n      vec2 lpf = ladderLPF(freq, cutoff, 0.3);\n      vec2 hpf = twoPoleHPF(freq, 200.0, 0.0);\n\n      sum += sin(TAU * phase + lpf.y + hpf.y) / p * lpf.x * hpf.x * env * rotate2D(2.4 * fi);\n    }\n\n    dest += 0.2 * mix(0.2, 1.0, sidechain) * tanh(5.0 * sum) * smoothstep(8.0, 32.0, beats.w);\n  }\n\n  if (beats.w < 224.0) { // oidos drone\n    vec2 sum=vec2(0.0);\n\n    repeat(i, 2500) {\n      vec3 diceA = hash3f(vec3(i / 50));\n      vec3 diceB = hash3f(vec3(i));\n\n      float t = mod(time.z - diceA.x * (64.0 * B2T), 64.0 * B2T);\n      float env = sin(PI * t / (64.0 * B2T));\n\n      float tone = 8.0 + 9.0 * diceA.y + 0.06 * diceB.y;\n      float freq = exp2(tone);\n      vec2 phase = t * freq + fract(diceB.xy * 999.0);\n      phase += 0.1 * fract(32.0 * phase); // add high freq\n\n      sum += sin(TAU * phase) * env / 1000.0;\n    }\n\n    dest += 1.0 * mix(0.2, 1.0, sidechain) * sum * smoothstep(0.0, 32.0, beats.w);\n  }\n\n  return clamp(dest, -1.0, 1.0) * smoothstep(320.0, 288.0, beats.w);\n}\n","name":"Sound","description":"","type":"sound"}]}