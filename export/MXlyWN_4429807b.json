{"ver":"0.1","info":{"id":"MXlyWN","date":"1726211407","viewed":18,"name":"Gyroid Surface with Lie Group Tr","username":"nbardy","description":"Gyroid Surface with Lie Group Transformations","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gyroid","liegroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Title: Gyroid Surface with Lie Group Transformations\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n// Constants\nconst float PI = 3.14159265359;\n\n// Camera setup\nvec3 cameraPos = vec3(0.0, 0.0, 5.0);\nvec3 lightPos = vec3(5.0, 5.0, 5.0);\n\n// Function to rotate a vector using a rotation matrix (Lie group SO(3))\nmat3 rotationMatrix(float angle, vec3 axis) {\n    axis = normalize(axis);\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    float oneMinusCosA = 1.0 - cosA;\n    \n    return mat3(\n        cosA + axis.x * axis.x * oneMinusCosA,\n        axis.x * axis.y * oneMinusCosA - axis.z * sinA,\n        axis.x * axis.z * oneMinusCosA + axis.y * sinA,\n        \n        axis.y * axis.x * oneMinusCosA + axis.z * sinA,\n        cosA + axis.y * axis.y * oneMinusCosA,\n        axis.y * axis.z * oneMinusCosA - axis.x * sinA,\n        \n        axis.z * axis.x * oneMinusCosA - axis.y * sinA,\n        axis.z * axis.y * oneMinusCosA + axis.x * sinA,\n        cosA + axis.z * axis.z * oneMinusCosA\n    );\n}\n\n// Gyroid implicit surface function\nfloat gyroid(vec3 p) {\n    float t = iTime * 0.5;\n    // Apply rotation using Lie group transformation\n    mat3 rot = rotationMatrix(t, vec3(1.0, 1.0, 0.0));\n    p = rot * p;\n    \n    // Gyroid equation: sin(x) * cos(y) + sin(y) * cos(z) + sin(z) * cos(x) = 0\n    float value = sin(p.x) * cos(p.y) + sin(p.y) * cos(p.z) + sin(p.z) * cos(p.x);\n    return value;\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float tMax = 10.0;\n    for (int i = 0; i < 128; i++) {\n        vec3 pos = ro + rd * t;\n        float d = abs(gyroid(pos));\n        if (d < 0.001 || t > tMax) break;\n        t += d * 0.5;\n    }\n    if (t > tMax) t = -1.0;\n    return t;\n}\n\n// Estimate normal at point p\nvec3 estimateNormal(vec3 p) {\n    float h = 0.001;\n    float gx = gyroid(p + vec3(h, 0.0, 0.0)) - gyroid(p - vec3(h, 0.0, 0.0));\n    float gy = gyroid(p + vec3(0.0, h, 0.0)) - gyroid(p - vec3(0.0, h, 0.0));\n    float gz = gyroid(p + vec3(0.0, 0.0, h)) - gyroid(p - vec3(0.0, 0.0, h));\n    return normalize(vec3(gx, gy, gz));\n}\n\n// Lighting function\nvec3 lighting(vec3 pos, vec3 normal) {\n    vec3 lightDir = normalize(lightPos - pos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 color = vec3(0.5 + 0.5 * sin(pos.x + iTime), 0.5 + 0.5 * cos(pos.y + iTime), 0.5 + 0.5 * sin(pos.z - iTime));\n    color *= diff;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Ray origin and direction\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(vec3(uv, -1.5));\n    \n    // Ray marching\n    float t = rayMarch(ro, rd);\n    vec3 color;\n    if (t > 0.0) {\n        vec3 pos = ro + rd * t;\n        vec3 normal = estimateNormal(pos);\n        color = lighting(pos, normal);\n    } else {\n        // Background color\n        color = vec3(0.0);\n    }\n    \n    // Gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}