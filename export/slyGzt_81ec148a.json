{"ver":"0.1","info":{"id":"slyGzt","date":"1638172050","viewed":387,"name":"Cubes feedback","username":"Bleuje","description":"My first shader using buffer","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["cubes","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 color, in vec2 position )\n{\n    color = texture(iChannel0, position/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// by @etiennejcb\n// Thanks to tdhooper and iq\n\n#define PI 3.14159\n#define TAU (2.*PI)\n#define duration 7.0\n\n// hglib / iq\n// http://mercury.sexy/hg_sdf/\n// https://iquilezles.org/articles/distfunctions\nvec3 rep(vec3 p, float d) {\n\treturn mod(p + d*.5, d) - d*.5;\n}\n\nfloat sp = 1.8;\nfloat bsz = 0.45;\nfloat bd = 90.0;\nfloat nbSquares = 6.0;\nfloat eps = 0.0001;\nfloat f = 0.98;\n\nfloat time;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 map(vec3 p) {\n    p += vec3(sp/2.0);\n    p = rep(p,sp);\n    \n    float d = sdBox(p,vec3(0.45));\n    \n    vec2 uv;\n    \n    if(abs(p.x)<=bsz+eps&&abs(p.y)<=bsz+eps)\n    {\n        uv = p.xy;\n    }\n    else if(abs(p.y)<=bsz+eps&&abs(p.z)<=bsz+eps)\n    {\n        uv = p.yz;\n    }\n    else\n    {\n        uv = p.xz;\n    }\n    \n\treturn vec4(uv,0,d);\n\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1., 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 distorter = vec2(iResolution.y/iResolution.x,1.);\n\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n    \n    time = mod(iTime/duration,1.0);\n\n\tvec3 cpos = vec3(0.,0.4*sin(TAU*time),4.*sp*time);\n    \n\tvec3 ro = cpos;\n\tvec3 ta = cpos+vec3(0.,0.,4.);\n\tvec3 rd;\n\n\trd = camera(ro, uv, ta);\n    \n\tvec3 p;\n\tvec4 res;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += 1.0/40.0) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tres = map(p);\n\t\tif (res.w<.001 || t>50.) break;\n\t\tt += res.w;\n\t}\n    \n    uv = res.xy;\n    vec2 impos = vec2(uv/bsz/2.0)*distorter+vec2(0.5);\n    vec3 cols = texture(iChannel0, impos).xyz + vec3(clamp(2.1-bd*abs(abs(uv.x)-bsz),0.,1.)) + vec3(clamp(2.1-bd*abs(abs(uv.y)-bsz),0.,1.));\n    vec3 col = cols*exp(-t/8.0)*1.5;\n    \n    col = vec3(pow(clamp(col.x,0.,1.),1.1));\n\n\tfragColor = vec4(col, 1.);\n}\n\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}