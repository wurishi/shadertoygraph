{"ver":"0.1","info":{"id":"tl2fzK","date":"1599404591","viewed":353,"name":"blackhole-v7","username":"feefi","description":"blackhole withe star background and x ray glow,disk and jets","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Pi = 3.1415926;\nvec3 black_hole_pos = vec3(0.0,-0.35,2.0); \t\t//黑洞的位置\nfloat event_horizon_radius = 0.3;\t\t//黑洞的事件视界半径\nfloat HitTest(vec3 p){\n\treturn length(p) - event_horizon_radius;\n}\nvec2 N22(vec2 id)\n{\n    id = id*vec2(123.1,456.2);\n    id += dot(id,id);\n    return fract(sin(id)*vec2(5.123,123.3));\n}\nfloat N21(vec2 id)\n{\n    id = id*vec2(227.1,125.2);\n    return fract(sin(dot(id,id))*215.3);\n}\nvec2 rPos(vec2 id)\n{\n    return  N22(id) -.5;\n}\nvec3 star(vec2 uv,vec2 id)\n{\n    float l = length(uv);\n    //float l = max(abs(uv.x),abs(uv.y));\n    float center = 0.035/l;\n    float st = center  ;\n\n    float N = N21(id);\n    float Size = N*2.;\n    vec3 color = sin(vec3(0.2,0.5,0.7)*fract(N*73.1)*15.)*0.5+0.5;\n    return st * N * smoothstep(1.,0.,l) * color*vec3(1.0,0.7,Size);\n}\nvec3 starLayer(vec2 uv,float i)\n{\n    vec2 id = floor(uv);\n    uv = fract(uv)-0.5;\n\n    vec3 col = vec3(0.);\n    \n    for(float x = -1.;x<=1.;++x){\n        for(float y = -1.;y<=1.;++y){\n            vec2 nid = id + vec2(x,y);\n            vec2 rpos = rPos(nid+i+1.);   \n            vec2 nuv = uv + rpos - vec2(x,y);         \n            vec3 st = star(nuv,nid);           \n            col += st*fract(cos((i+1.)*100.)*23.1)*3.5;\n        }\n    }\n\n    return col;\n}\nvec3 GetBg(vec3 p)\n{\n    return starLayer(p.xy+vec2(4.8,0.),8.)*0.3;\n}\n\nfloat torus_sdf( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //映射到0~1之间\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.  - 1.;\t\n    uv.x *= iResolution.x / iResolution.y;\t\n\tvec3 eye = vec3(0.,0.2,-2);    //eye or camera postion 相机位置\n    vec3 sd = vec3(uv.x,uv.y,-1); //screen coord 屏幕坐标\n    vec3 ray_dir = normalize( sd - eye);//ray direction 射线方向\n    \n    vec3 col = vec3(0.);\n    \n\tfloat hitbh = 0.;\n    \n    const int maxStep = 250;//光线最大步进数\n    float st = 0.;      \n    vec3 p = sd;\n    vec3 v = ray_dir;\n    float dt = 0.02;\n    float GM = 0.8;   \n    vec3 cp = black_hole_pos ;//+ 2.*vec3(1.*sin(iTime),sin(1.31*iTime),0.);\n    float bc = 0.0;\n    float hitbhglow = 0.;\n    vec3 torCol = vec3(0);\n    vec3 jetCol = vec3(0);\n    for(int i = 0;i<maxStep;++i)\n    {\n        p += v * dt;\n        vec3 relP = p - cp; //黑洞相对原点的位置       \n        float r2 = dot(relP,relP);\n        vec3 a = GM/r2 * normalize(-relP); //加速度的方向朝向黑洞，为-relP\n        v += a * dt;   \n\n        float hit = HitTest(relP); //hit表示距物体的最小距离\n\t\thitbh = max(hitbh,smoothstep(0.02,-0.02,hit));  \n        hitbhglow = max(hitbhglow,smoothstep(0.02,-0.05,hit));\n        \n        float glow = 0.01/r2;//0.01*(exp(0.2/r2)-0.5);\n        \n        bc += glow * (1.-hitbhglow) ;\n        \n        //吸积盘\n        float rotangle = Pi/18.0;\n                mat3 torRot = mat3(\n            vec3(cos(rotangle),-sin(rotangle),0),\n            vec3(sin(rotangle),cos(rotangle),0),\n            vec3(0,0,1)\n        );\n        vec3 torpos = (torRot*relP);\n        \n        float tor = torus_sdf(torpos*vec3(1,13.,1.),vec2(1.8,1.2));\n        float hitTor = smoothstep(0.,-0.01,tor);\n        \n        \n        float v = smoothstep(0.,1.,length(torpos.xz)/18.);\n        float u = atan(torpos.z,torpos.x)/Pi *v -iTime*0.03;\n        \n        vec2 toruv = vec2(u,v)*vec2(15,10.1);\n        vec3 distor = texture(iChannel0,toruv).r*vec3(0.9,0.6,0.4);\n        float fade = smoothstep(4.,1.5,length(torpos.xz));\n\t\ttorCol += 0.025 *distor* hitTor*(1.-hitbh)*fade;\n\n        //jets\n        float jetHeight = smoothstep(0.,2.5, abs(torpos.y));\n        vec3 blue = vec3(0.3,0.3,0.6);\n        vec3 red = vec3(0.6,0.3,0.3);\n        float jetWidth = 0.001/dot(torpos.xz,torpos.xz);\n        \n        //animation\n        float t = iTime;\n        float jetAnim = (0.5*sin(t+sin(t+sin(t+sin(t*2.))))+0.5) ;\n        jetAnim = smoothstep(0.5,0.6,jetAnim);\n        jetAnim = 12.5*jetAnim;\n        \n\t\tjetCol += jetWidth*(1.-hitbh)\n            \t*mix(blue,red,jetHeight)\n            \t*smoothstep(jetAnim,0., abs(torpos.y));\n\n    }\n    //float dis = dot(p-cp,p-cp);\n    //\n    col = 0.23*bc*vec3(0.9,0.8,0.8) + GetBg(p)*(1.-hitbh) ;\n    col += torCol;\n    col += jetCol;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}