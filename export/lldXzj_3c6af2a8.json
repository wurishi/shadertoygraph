{"ver":"0.1","info":{"id":"lldXzj","date":"1480697980","viewed":402,"name":"sweep sphere vs triangle","username":"xchip","description":"Testing a capsule algorithm I found here: https://gist.github.com/jdryg/ecde24d34aa0ce2d4d87\n\nThe surface is not fully smooth, you can see the seams between the different primitives. I'll keep on searching...","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sweepspheretriangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Computes when a sweeping sphere woudl collide with a triangle.\n// Uses the minkowski sum of geometry:\n//  - the sweeping A sweeping spherebecomes an ray\n//  - every point of the trienalge becomes an sphere, resulting in the image you are seeing\n//\n// The volume represents all the points where a sphere would collide with the triangle\n//\n// This code was a quick test to validate the capsule code I found here:\n// \t https://gist.github.com/jdryg/ecde24d34aa0ce2d4d87. \n//\n// As Iq pointer out a much better code is this one: https://www.shadertoy.com/view/Xt3SzX\n//   \n\n\nstruct Ray\n{\n\tvec3 m_Origin;\n\tvec3 m_Direction;\n};\n\nstruct Sphere\n{\n\tvec3 m_Center;\n\tfloat m_Radius;\n};\n\nstruct Capsule\n{\n\tvec3 m_A;\n\tvec3 m_B;\n\tfloat m_Radius;\n};\n\nbool IntersectRaySphere(const Ray ray, const Sphere sphere, out float tmin, out float tmax)\n{\n\tvec3 CO = ray.m_Origin - sphere.m_Center;\n\n\tfloat a = dot(ray.m_Direction,ray.m_Direction);\n\tfloat b = 2.0 * dot(CO,ray.m_Direction);\n\tfloat c = dot(CO,CO) - (sphere.m_Radius * sphere.m_Radius);\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t\treturn false;\n\n\ttmin = (-b - sqrt(discriminant)) / (2.0 * a);\n\ttmax = (-b + sqrt(discriminant)) / (2.0 * a);\n\tif (tmin > tmax)\n\t{\n\t\tfloat temp = tmin;\n\t\ttmin = tmax;\n\t\ttmax = temp;\n\t}\n\n\treturn true;\n}\n\nbool IntersectRayTriangle(const Ray r, vec3 v0,vec3 v1,vec3 v2, out vec3 n1, out float tout) \n{\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 normal = cross(e0,e1);\n    \n    // ray vs plane    \n    float t = (-dot(normal,r.m_Origin) + dot(normal,v0)) / dot(normal,r.m_Direction);\n    \n    // point inside triangle\n    vec3 point = r.m_Origin + r.m_Direction * t;\n    \n    if(dot(normal, cross(e0,point-v0)) < 0.0 ||\n       dot(normal, cross(e1,v2-point)) < 0.0 ||\n       dot(normal, cross(v2-v1,point-v1)) < 0.0) return false;   \n    \n    tout = t;\n    n1 = normalize(normal);\n    \n\treturn true;\n}\n\n\n\nbool IntersectRayCapsule(const Ray ray, const Capsule capsule, out vec3 p1, out vec3 n1, out float tout)\n{\n\t// http://pastebin.com/2XrrNcxb\n\n\t// Substituting equ. (1) - (6) to equ. (I) and solving for t' gives:\n\t//\n\t// t' = (t * dot(AB, d) + dot(AB, AO)) / dot(AB, AB); (7) or\n\t// t' = t * m + n where \n\t// m = dot(AB, d) / dot(AB, AB) and \n\t// n = dot(AB, AO) / dot(AB, AB)\n\t//\n\tvec3 AB = capsule.m_B - capsule.m_A;\n\tvec3 AO = ray.m_Origin - capsule.m_A;\n\n\tfloat AB_dot_d = dot(AB, ray.m_Direction);\n\tfloat AB_dot_AO = dot(AB, AO);\n\tfloat AB_dot_AB = dot(AB, AB);\n\n\tfloat m = AB_dot_d / AB_dot_AB;\n\tfloat n = AB_dot_AO / AB_dot_AB;\n\n\t// Substituting (7) into (II) and solving for t gives:\n\t//\n\t// dot(Q, Q)*t^2 + 2*dot(Q, R)*t + (dot(R, R) - r^2) = 0\n\t// where\n\t// Q = d - AB * m\n\t// R = AO - AB * n\n\tvec3 Q = ray.m_Direction - (AB * m);\n\tvec3 R = AO - (AB * n);\n\n\tfloat a = dot(Q,Q);\n\tfloat b = 2.0 * dot(Q,R);\n\tfloat c = dot(R,R) - (capsule.m_Radius * capsule.m_Radius);\n\n\tif (a == 0.0)\n\t{\n\t\t// Special case: AB and ray direction are parallel. If there is an intersection it will be on the end spheres...\n\t\t// NOTE: Why is that?\n\t\t// Q = d - AB * m =>\n\t\t// Q = d - AB * (|AB|*|d|*cos(AB,d) / |AB|^2) => |d| == 1.0\n\t\t// Q = d - AB * (|AB|*cos(AB,d)/|AB|^2) =>\n\t\t// Q = d - AB * cos(AB, d) / |AB| =>\n\t\t// Q = d - unit(AB) * cos(AB, d)\n\t\t//\n\t\t// |Q| == 0 means Q = (0, 0, 0) or d = unit(AB) * cos(AB,d)\n\t\t// both d and unit(AB) are unit vectors, so cos(AB, d) = 1 => AB and d are parallel.\n\t\t// \n\t\tSphere sphereA, sphereB;\n\t\tsphereA.m_Center = capsule.m_A;\n\t\tsphereA.m_Radius = capsule.m_Radius;\n\t\tsphereB.m_Center = capsule.m_B;\n\t\tsphereB.m_Radius = capsule.m_Radius;\n\n\t\tfloat atmin, atmax, btmin, btmax;\n\t\tif (!IntersectRaySphere(ray, sphereA, atmin, atmax) ||\n\t\t\t!IntersectRaySphere(ray, sphereB, btmin, btmax))\n\t\t{\n\t\t\t// No intersection with one of the spheres means no intersection at all...\n\t\t\treturn false;\n\t\t}\n\n\t\tif (atmin < btmin)\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * atmin);\n\t\t\tn1 = p1 - capsule.m_A;\n\t\t\tn1 = normalize(n1);\n            tout = atmin;    \n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * btmin);\n\t\t\tn1 = p1 - capsule.m_B;\n\t\t\tn1 = normalize(n1);\n            tout = btmin;   \n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t{\n\t\t// The ray doesn't hit the infinite cylinder defined by (A, B).\n\t\t// No intersection.\n\t\treturn false;\n\t}\n\n\tfloat tmin = (-b - sqrt(discriminant)) / (2.0 * a);\n\tfloat tmax = (-b + sqrt(discriminant)) / (2.0 * a);\n\tif (tmin > tmax)\n\t{\n\t\tfloat temp = tmin;\n\t\ttmin = tmax;\n\t\ttmax = temp;\n\t}\n\n\t// Now check to see if K1 and K2 are inside the line segment defined by A,B\n\tfloat t_k1 = tmin * m + n;\n\tif (t_k1 < 0.0)\n\t{    \n\t\t// On sphere (A, r)...\n\t\tSphere s;\n\t\ts.m_Center = capsule.m_A;\n\t\ts.m_Radius = capsule.m_Radius;\n\n\t\tfloat stmin, stmax;\n\t\tif (IntersectRaySphere(ray, s, stmin, stmax))\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * stmin);\n\t\t\tn1 = p1 - capsule.m_A;\n\t\t\tn1 = normalize(n1);\n            tout = stmin; \n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse if (t_k1 > 1.0)\n\t{\n\t\t// On sphere (B, r)...\n\t\tSphere s;\n\t\ts.m_Center = capsule.m_B;\n\t\ts.m_Radius = capsule.m_Radius;\n\n\t\tfloat stmin, stmax;\n\t\tif (IntersectRaySphere(ray, s, stmin, stmax))\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * stmin);\n\t\t\tn1 = p1 - capsule.m_B;\n\t\t\tn1 = normalize(n1);\n            tout = stmin;    \n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\t// On the cylinder...\n\t\tp1 = ray.m_Origin + (ray.m_Direction * tmin);\n\n\t\tvec3 k1 = capsule.m_A + AB * t_k1;\n\t\tn1 = p1 - k1;\n\t\tn1 = normalize(n1);        \n        tout = tmin;    \n\t}\n \n\n\treturn true;\n}\n\nbool Triangle(const in Ray ray, in vec3 v1, in vec3 v2, in vec3 v3, out vec3 normal, out float tmin)\n{\n    Capsule capsule;\n    capsule.m_Radius = 1.;   \n\n    float t;    \n\tvec3 p1,n1; \n    \n    capsule.m_A = v1.xyz;\n    capsule.m_B = v2.xyz;    \n    \n    bool res = IntersectRayCapsule(ray, capsule, p1, n1, t);\n    if (res && t<tmin)\n    {\n        tmin = t;\n        normal = n1;\n    }\n   \n    capsule.m_A = v2.xyz;\n    capsule.m_B = v3.xyz;\n\n    res = IntersectRayCapsule(ray, capsule, p1, n1, t);\n    if (res && t<tmin)\n    {\n        tmin = t;\n        normal = n1;\n    }\n    \n    capsule.m_A = v3.xyz;\n    capsule.m_B = v1.xyz;\n\n    res = IntersectRayCapsule(ray, capsule, p1, n1, t);\n    if (res && t<tmin)\n    {\n        tmin = t;\n        normal = n1;\n    }\n   \n\n   vec3 e0 = v2-v1, e1 = v3-v1;\n   vec3 normal2 = normalize(cross(e0,e1)) * capsule.m_Radius; \n    \n   if (IntersectRayTriangle(ray, v1+normal2, v2+normal2, v3+normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n       }\n   }\n\n   if (IntersectRayTriangle(ray, v2-normal2, v1-normal2, v3-normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n       }\n   }\n    \n    \n    return true;    \n}\n\nvec3 RotY(float angle, vec3 pos)\n{\n    return vec3(cos(angle) * pos.x - sin(angle)* pos.z, pos.y, sin(angle) * pos.x + cos(angle) * pos.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n    vec3 col = vec3(0.0);\n\n    Ray ray;\n    ray.m_Origin = vec3(0.0, -0.4, 8.0 );\n    ray.m_Direction = normalize( vec3(p,-2.0) );\n\n    vec3 v1 = RotY(iTime, vec3(-2.0,-2.0,0.0));\n    vec3 v2 = RotY(iTime, vec3(0.0,2.0,.0));\n    vec3 v3 = RotY(iTime, vec3(2.0,-2.0,0.0));\n\n    float tmin = 1e10;\n    vec3 nor = vec3(0.0, 0.0, 0.0 );\n    Triangle( ray, v1, v2, v3, nor, tmin );\n    if (tmin<1e10)\n    {\n    \tcol = nor;\n    }\n\n    \n   if (IntersectRayTriangle(ray, v1, v2, v3, nor, tmin))\n   {\n       col += vec3(.3,.3,.3);\n   }\n    \n    \n    \n    //col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}    \n    ","name":"Image","description":"","type":"image"}]}