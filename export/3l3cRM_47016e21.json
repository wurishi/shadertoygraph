{"ver":"0.1","info":{"id":"3l3cRM","date":"1608873801","viewed":172,"name":"Kaleidoscope WIP","username":"mooseontherocks","description":"A kaleidoscope project","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 kaleidoTransform(float angle, float distance) {\n    float angle2 = (angle + 2.*PI) / PI;\n    angle2 = mod(angle2 * float(SYMMETRY), 2.);\n    if (angle2 > 1.) angle2 = 2. - angle2;\n    angle2 = angle2 / float(SYMMETRY) * PI;\n    vec2 xy = vec2(cos(angle2), sin(angle2)) * distance;\n    \n    const int maxReflections = 3;\n    int reflections = 0;\n    do {\n        xy.x = mod(xy.x, 2.);\n        if (xy.x > 1.) xy.x = 2. - xy.x;\n        \n        if (xy.y > xy.x * tansym) {\n\t        float newAngle = atan(xy.y / xy.x);\n            newAngle = mod(newAngle, symmetry * 2.);\n            if (newAngle > symmetry) newAngle = symmetry * 2. - newAngle;\n            xy = vec2(cos(newAngle), sin(newAngle)) * length(xy);\n        }\n    } while (xy.x > 1. && ++reflections < maxReflections);\n    \n    return xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/MIN_RES;\n    float angle = angleOf(uv);\n    float distance = length(uv);\n    float rotation = iTime*0.1;\n    float zoom = 2. + (0.5+cos(iTime*.1)*0.5)*3.;\n    vec2 xy = kaleidoTransform(angle + rotation, distance * zoom);\n    fragColor = (texelFetch(iChannel0, ivec2(xy * MIN_RES), 0));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(vec2 vec, float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec2(vec.x * ca - vec.y * sa,\n                vec.x * sa + vec.y * ca);\n}\n\n#define MAX_ITERS 100\n#define BAILOUT_VALUE 20. //larger bailout value to assist normalized iteration count\n#define COLOR_DENSITY 3. //number of rotations through the palette.  Negative to flow in reverse.\n#define COLOR_SPEED .25 //iTime multiple for time-based cycles (like color)\n\nvec3 palette1d(float i) {\n    i = i * COLOR_DENSITY + iTime * COLOR_SPEED;\n    float h = sin(i) + sin(i * 2.618) * .5;\n    float l = (sin(i * 6.618 + 1.) + 1.) * .5;\n    float s = (sin(i * 10.141 + 4.) + 1.) * .5;\n    return vec3(hsv2rgb(vec3(h, 1. - s * s, 1. - l * l)));\n}\n\nvec3 mandelbrot(vec2 z, vec2 c) {\n    int iters = 0;\n    for (; iters < MAX_ITERS; iters++)\n    {\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + c;\n        if (dot(z,z) > BAILOUT_VALUE * BAILOUT_VALUE) { break; }\n    }\n    \n    if (iters == MAX_ITERS) {\n        return vec3(0,0,0);\n    }\n    else { \t\n        return palette1d((float(iters) - log2(log(dot(z, z)))) / float(MAX_ITERS));\n    }\n\n}\n\n\nvec2 warp(vec2 uv) { \n    float px = sin(uv.x * 12. + sin(uv.y * 6. + iTime) * 2.);\n    float py = sin(uv.y * 12. + sin(uv.x * 3.75 + iTime) * .35);\n    uv *= 1. + px * py * .5;\n    return uv;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / MIN_RES;\n    \n    if (fragCoord.x > MIN_RES) return;\n    if ((fragCoord.y - 1.) > fragCoord.x * tansym) return;\n    \n    float t1 = iTime * 0.5;\n    float t2 = iTime * 0.5;\n    float s2 = .8 + .1 * sin(t2);\n    vec2 z = vec2(cos(t1), sin(t1)) * s2;\n    \n    vec2 c = (fragCoord / MIN_RES - vec2(.65, .35)) * 2.;\n    vec3 mandelbrotCol = mandelbrot(z, c);\n    \n    vec2 sv = warp(uv);\n    vec3 bg = texture(iChannel0, sv - iTime * .1).xyz;\n    vec3 col = mix(vec3(sv.y, 0., sv.x), mandelbrotCol, dot(vec3(sv, 1.05), bg)) * 1.; \n    fragColor = vec4(col, 1.0) ;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n#define SYMMETRY 5.\n#define MIN_RES min(iResolution.x, iResolution.y)\n\nconst float symmetry = PI / float(SYMMETRY);\nconst float tansym = tan(symmetry);\n\nfloat angleOf(vec2 xy) {\n    float angle = atan(xy.y / xy.x);\n    // Edge case\n    if (xy.x == 0.) {\n        if (xy.y > 0.) return PI / 2.;\n        else if (xy.y < 0.) return 3.*PI/2.;\n        else return 0.;\n    }\n    // Edge case\n    else if (xy.y == 0.) {\n        if (xy.y >= 0.) return 0.;\n        else return PI;\n    }\n    // General\n    else {\n        // Quadrant 3\n        if (xy.x < 0. && xy.y < 0.) {\n            return PI + angle;\n        }\n        // Quadrant 2\n        else if (xy.x < 0.) {\n            return PI + angle;\n        }\n        // Quadrant 4\n        else if (xy.y < 0.) {\n            return 3.*PI/2. + (PI/2. + angle);\n        }\n        // Quadrant 1\n        else {\n            return angle;\n        }\n    }\n}\n","name":"Common","description":"","type":"common"}]}