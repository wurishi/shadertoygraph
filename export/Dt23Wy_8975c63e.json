{"ver":"0.1","info":{"id":"Dt23Wy","date":"1674573055","viewed":283,"name":"Warped Angular Grid.","username":"lz","description":"Colorful animation from warping cylindric coordinates.\nShould work on mobile as well (tested newer android). If the performance is too low, uncomment V_MOBILE (without antialiasing - though less needed for mobiles that usually has higher resolution).","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["2d","normalmapping","angulargrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n - Warped Angular Grid: Leonid Zaides\n - \n - Warping angular grid by constructing 3 levels of cylindrical coordinates (first from carthesian then \n - from the constructed cylindrical and one more like that) and interpolating between them.\n - \n - Coloring uses dynamic texture and normal maps.\n - \n - Anti-Aliasing: \n - 1) Using analytic derivatives for the 'bumps' (on mobile this was significantly faster than dFdx,dFdy). \n -    This makes cleaner gradients.\n - 2) The radial edges of the cells are interpolated by calculateing 2 cell neighbors.\n - 3) The (running) radial lines are filterd by taking 4 samples.\n -\n - Uncommenting V_MOBILE won't use anti-aliasing. \n - Tested on Samsung S6 Lite (adreno 618): \n - Resolution 1200x2000 (fullscreen), without anti-aliasing ~ 10 fps.\n - 768x432, with anti-aliasing ~ 18 fps.\n - 768x432, without anti-aliasing ~ 55 fps.\n - \n - Buffer A: precomputing frame parameters and constants.\n */\n\nfloat hash(in float _x) { return fract(5313.235 * mod(_x, 0.75182) * mod(_x, 0.1242)); }\nfloat noise(in float _x) { float i = floor(_x); float f = fract(_x); return mix(hash(i), hash(i + 1.), 3.*f*f - 2.*f*f*f); }\nvec3 smbox(in vec2 _f, in vec2 _t, in float _eps, in vec2 _uv) { vec2 bin = smoothstep(_f - _eps, _f, _uv) - smoothstep(_t, _t + _eps, _uv); return vec3(bin, bin.x * bin.y);}\n\n#define ANIM_T(_t, _e, _p) (smoothstep(_p - _e, _p, _t) - smoothstep(_p, _p + _e, _t))\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ASYM_PULSE_T(_t, _ea, _pa, _eb, _pb) (smoothstep(_pa - _ea, _pa, _t) - smoothstep(_pb, _pb + _eb, _t))\n\n#define ROT2D(p2d, ang) (cos(ang) * p2d.xy + sin(ang) * vec2(p2d.y, -p2d.x))\n#define TEX_LIGHT 4\n#define DF(_x, _m) 6. * (_x * _m - (_x * _x) / (_m * _m) )\n#define DRV(_x, _m) DF(_x, _m) * (step(0., _x) - step(_m, _x)) + (1. - DF(_x, _m)) * (step(1. - _m, _x) - step(1., _x))\n\n//https://iquilezles.org/articles/palettes/\n#define CL(_id, _noise)  0.5 + 0.5*cos(6.28 * (_noise * vec3(0.2, 0.8, 0.4) + vec3(3.3, 1., 1.1) * vec3(hash(_id))));\n//const vec4 lights[NLIGHTS] = vec4[NLIGHTS](vec4(0., 0., 5., 1.));\n\n#define GRID_SIZE 5.\n#define N_RAD_COLS 4\n#define TEX_RAD_COLS 5\n#define TEX_FRAME_CONSTS 6\n\n#define FLW(_grid) ASYM_PULSE_T(mod(_grid.y + floor(_grid).x, 15.), 0.2, 2.5, 0.2, 2.6)\n#define RMARGIN(_grid) 0.05 * (1. + 0.5 * FLW(_grid))\n#define radialLine(_grid) ANIM_T(fract(_grid.x), RMARGIN(_grid), 0.5) * mix(0.9, 1.0, 0.5 + 0.5 * sin(6.28 * fract(_grid.y)))\n\n#define TR(_i, _layer) texelFetch(iChannel0, ivec2(_i, _layer), 0).r\n#define TF(_i, _layer) texelFetch(iChannel0, ivec2(_i, _layer), 0)\n\n//#define V_MOBILE\n\nvec2 transformUV(in vec2 uv, in float _t, in float _layer)\n{\n    uv *= (1. + 1.5 * TR(0,_layer) * length(uv));\n    vec2 st = uv - 0.2 * (_layer + 1.) * vec2(TR(1,_layer), TR(2,_layer));\n    uv.xy = ROT2D(st, TR(3,_layer));\n\n    float alpha = atan(abs(uv.y), uv.x);\n    float rad = length(uv);\n    vec2 angUv = vec2(alpha, rad);\n    vec2 angUv2 = vec2(atan(abs(angUv.y), angUv.x), length(angUv));\n    vec2 angUv3 = vec2(atan(angUv2.y, angUv2.x), length(angUv2));\n    vec2 angUv4 = vec2(atan(angUv3.y, angUv3.x), length(angUv3));\n\n    vec2 uva = mix(angUv, angUv2, TR(4, _layer));\n    vec2 uvb = mix(angUv3, angUv3, TR(5, _layer));\n\n    uv = mix(uva, uvb, TR(6, _layer));\n    \n    return uv * GRID_SIZE;\n}\n\nfloat filteredRadialLines(in vec2 uv, in float time, float invRes)\n{\n    vec2 uvh = transformUV(uv + vec2(1.25, 1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n    vec2 uvl = transformUV(uv + vec2(-1.25, 1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n    vec2 uvr = transformUV(uv + vec2(1.25, -1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n    vec2 uvd = transformUV(uv + vec2(-1.25, -1.25)*invRes, time, 0.) + vec2(0.5) + vec2(0., TR(13,0));\n\n    float yh = radialLine(uvh);\n    float yl = radialLine(uvl);\n    float yr = radialLine(uvr);\n    float yd = radialLine(uvd);\n\n    return 0.25 * (yh + yl + yr + yd);\n}\n\nvec4 angularLayer(in vec2 uv, in vec2 grid, in float layer, float invRes, float radline)\n{ \n    vec2 igrid = floor(grid);\n    vec2 fgrid = fract(grid);\n    float gid = igrid.x * 1000. + igrid.y;   \n    \n    float margin = TR(7, layer);\n    \n    vec3 inside = smbox(vec2(margin), vec2(1. - margin), margin, fgrid);\n    \n    // analytical derivatives.\n    float dx = DRV(fgrid.x, margin);\n    float dy = DRV(fgrid.y, margin);\n    vec3 grad = normalize(vec3(dx, dy, iResolution.y * length(grid)));\n    \n    // numerical derivatives (not used).\n    //vec3 grad = normalize(vec3(dFdx(inside.x), dFdy(inside.y), 2.));\n    \n    float border = 1. - (1. + noise(fgrid.x*20.)) * inside.z;\n\n    vec2 roadGrid = grid + vec2(0.5);\n    roadGrid.y += TR(13,layer);\n    vec2 iroadGrid = floor(roadGrid);\n    vec2 froadGrid = fract(roadGrid);\n    int rrID = int(iroadGrid.x);\n    float flowCf = ASYM_PULSE_T(mod(roadGrid.y + iroadGrid.x, 15.), 0.2, 2.5, 0.2, 2.6);\n    float roadMargin = 0.05 * (1. + 0.3 * flowCf);\n    float yroad = radline;\n    float shRoad = (1. + 0.2 * flowCf) * ANIM_T(froadGrid.x, roadMargin*3., 0.5);\n\n    ///\n    float attenuation = floor(max(grid.x, grid.y));\n    \n    float attCf = 1./(1. + invRes * attenuation * attenuation);\n    float intensity;\n    float spec;\n    for (int il = 0; il < 4; il++)\n    {\n      vec4 light = TF(il, TEX_LIGHT);\n      vec3 pl = normalize(light.xyz - vec3(uv, 0.));\n      float f = clamp(abs(dot(pl, grad)), 0., 1.);\n      intensity += light.w * f * attCf;\n      spec += light.w * clamp(dot(normalize(-reflect(pl, grad)), (vec3(TR(8,layer), TR(9,layer), -3.))), 0., 1.);\n    }\n    \n    float ns = TR(10,layer);\n    vec3 col = CL(gid, ns);\n#ifndef V_MOBILE\n    if (layer < 0.5)\n    {\n        // AA\n        // Smoothing raw color, before lighting.\n        float im = 0.05;\n        float flow = clamp((fgrid.y - im) / im, 0., 1.);\n        float fhigh = clamp((fgrid.y - (1. - im)) / im, 0., 1.);\n        vec3 colH = CL(gid + 1., ns);\n        vec3 colL = CL(gid - 1., ns);\n        col = mix(col, colH, 0.5 * fhigh);\n        col = mix(colL, col, 0.5 + 0.5 * flow);\n    }\n#endif\n    \n    // shadow y - angular sections\n    col -= TR(11,layer) * mod(igrid.x, 2.);\n    // waves\n    col *= (1. - border) + border * (0.75 * col);\n     // x - radial shadow lines.\n    col = mix(col, (shRoad) * col, shRoad * shRoad * (1. - 0.5 * TR(12,layer)));\n    \n    // x - radial colored lines.\n    col = mix(col, yroad * (1. + 0.5*flowCf + TR(12,layer) * noise(roadGrid.y)) * TF(rrID % N_RAD_COLS, TEX_RAD_COLS).rgb, yroad);\n    // lighting.\n    col = intensity*col + spec * vec3(0.97, 0.87, 0.65);\n    \n    // \n    //col = 0.5 * grad + 0.5;\n    \n    return vec4(col, yroad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    float invRes = 1./iResolution.y;\n    \n    vec4 fcol;\n    float t = iTime;\n    \n    vec2 grid0 = transformUV(uv, t, 0.);\n    vec2 grid1 = transformUV(uv, t - 3., 1.);\n    vec2 grid2 = transformUV(uv, t - 6., 2.);\n   \n#ifndef V_MOBILE\n    // AA - filtered radial lines\n    // for layer 0 using 4 samples to draw the radial lines.\n    float rdl0 = filteredRadialLines(uv, t, invRes);\n#else\n    float rdl0 = radialLine((grid0 + 0.5));\n#endif\n    float rdl1 = radialLine((grid1 + 0.5));\n    float rdl2 = radialLine((grid2 + 0.5));\n    \n    vec4 c0 = angularLayer(uv, grid0, 0., invRes, rdl0);\n    vec4 c1 = angularLayer(uv, grid1, 1., invRes, rdl1);\n    vec4 c2 = angularLayer(uv, grid2, 2., invRes, rdl2);\n    \n    float f1 = TR(0, TEX_FRAME_CONSTS);\n    float f2 = TR(1, TEX_FRAME_CONSTS);\n    \n    fcol = c0;\n    fcol = mix(fcol, c1, 0.2 * f1);\n    fcol = mix(fcol, c2, 0.2 * f2);\n    \n    fcol.rgb = pow(fcol.rgb, vec3(2.2));\n    \n    fragColor = vec4(fcol);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// precompute texture buffer\n// mainly reducing compilation time\n\nfloat hash(in float _x) { return fract(5313.235 * mod(_x, 0.75182) * mod(_x, 0.1242)); }\nfloat noise(in float _x) { float i = floor(_x); float f = fract(_x); return mix(hash(i), hash(i + 1.), 3.*f*f - 2.*f*f*f); }\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ATR(_aid, _layer, _f) if (coord.x == _aid && coord.y == _layer) { ctrl.r = _f; }\n#define ATF(_aid, _layer, _f) if (coord.x == _aid && coord.y == _layer) { ctrl = _f; }\n#define LIGHT 4\n#define RAD_COLS 5\n#define FRAME_CONSTS 6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ctrl;\n    ivec2 coord = ivec2(fragCoord);\n    // float t[3] = float[3](iTime, iTime - 3., iTime - 6.); - crashes mobile browsers\n    float t0 = iTime;\n    float t1 = iTime - 3.;\n    float t2 = iTime - 6.;\n    \n    for (int layer = 0; layer < 3; layer++)\n    {\n        float t = layer == 0 ? t0 : layer == 1 ? t1 : t2;\n        // transform states\n        ATR(0,layer, noise(t * 0.18 + 1.3))\n        ATR(1,layer, cos(6.28 * noise(t * 0.1 + 193.)))\n        ATR(2,layer, sin(6.28 * noise(t * 0.1 + 35.)))\n        ATR(3,layer, noise(t * 0.1 + 17.))\n        ATR(4,layer, noise(t * 0.13 + 31.))\n        ATR(5,layer, noise(t * 0.21 + 73.))\n        ATR(6,layer, noise(t * 0.1 + 23.))\n        \n        //\n        ATR(7,layer, 0.1 + 0.1 * noise(t * 0.25 + 21.))\n        ATR(8,layer, noise(t * 0.5 + 3.2))\n        ATR(9,layer, noise(t * 0.5 + 4.7))\n        ATR(10,layer, noise(t * 0.5))\n        ATR(11,layer, noise(t * 0.25 + 321.23) * 0.5)\n        ATR(12,layer, 1.5 * PULSE_T(mod(t, 30.), 1.25, 8., 16.))\n        ATR(13,layer, 4.*t)\n    }\n    \n    // constants\n    ATF(0,LIGHT, vec4(0., 0., 5., 0.2));\n    ATF(1,LIGHT, vec4(0., 0.25, 3., 0.2));\n    ATF(2,LIGHT, vec4(-1., -1., 3., 0.2));\n    ATF(3,LIGHT, vec4(1., -1., 3., 0.2));\n    \n    // radial light colors\n    // https://www.shutterstock.com/blog/neon-color-palettes #12\n    ATF(0,RAD_COLS, vec4(0.808, 0.588, 0.984, 1.));\n    ATF(1,RAD_COLS, vec4(1.0, 0.561, 0.812, 1.));\n    ATF(2,RAD_COLS, vec4(0.0, 0.761, 0.729, 1.));\n    ATF(3,RAD_COLS, vec4(0.012, 0.478, 0.565, 1.));\n    \n    ATR(0, FRAME_CONSTS, PULSE_T(mod(t0, 60.), 20., 55., 1.));\n    ATR(1, FRAME_CONSTS, PULSE_T(mod(t0, 60.), 30., 55., 1.));\n    \n    fragColor = vec4(ctrl);\n}","name":"Buffer A","description":"","type":"buffer"}]}