{"ver":"0.1","info":{"id":"lXjSWV","date":"1711116794","viewed":70,"name":"Desert dunes and sand","username":"nisoniso","description":"Desert \nSand\nDune","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec2 p) {\n\tvec2 i = floor(p); p -= i; \n    float res = dot(mat2(fract(sin(mod(vec4(0, 1, 111, 114)\n     + dot(i, vec2(1, 113)), 6.2831853))))\n     *vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n    res = 0.5 + 0.5*cos(3.14159265*res);\n    return res;\n}\n\n\nfloat gradN2D(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = noise(i);\n    float b = noise(i + vec2(1.0, 0.0));\n    float c = noise(i + vec2(0., 1.));\n    float d = noise(i + vec2(1., 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n\nfloat sand(vec2 p){\n    vec2 q = p * 0.1;\n    float grad1 = gradN2D(q.xy*4.);\n    float grad2 = gradN2D(q.yx*4.);\n    float a2 = dot(sin(q*15.2546), vec2(.2)) + .8;\n    float a1 = 1. - a2;\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    return c;\n}\n\n\nvec3 timeRendering( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(0.5,0.8,0.) );\n    vec3 sandColor = vec3(0.85,0.7,0.6);\n\n    float tmin = 0.;\n    float tmax = 25.0; // max distance to trace\n    float t = tmin;\n\t\n    for( int i=0; i<100; i++ ) // this is the main raymarching loop\n\t{\n        vec3 pos = ro + t*rd; // current position\n\t\tfloat h = pos.y - sand( pos.xz ); // distance to the surface\n\t\tif( h<(0.0001*t) || t>tmax ) break; // stop marching when close enough or too far\n\t\tt += 0.5 * h; // step forward along the ray\n\t}\n\n    vec3 col;\n    if(t>tmax){ \n        vec3 sky = vec3(0.6, 0.7, 0.7); // Light blue base color\n        col = sky * pow(1. + rd.y, 1.5); // Add some gradient\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        vec3 normal = normalize(vec3(sand(pos.xz-vec2(0.002*t,0.0)) - sand(pos.xz+vec2(0.002*t,0.0)),\n                                     2.0*0.002*t,\n                                     sand(pos.xz-vec2(0.0,0.002*t)) - sand(pos.xz+vec2(0.0,0.002*t))));\n        \n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        float lambertian = max(dot(lightDir,normal), 0.); // calculate lambertian shading\n        col = sandColor * lambertian;\n\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    float rotY;\n    float rotX;\n    \n    // Camera rotation\n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \trotY = time;\n    \trotX = 1.2;        \n    }\n    else{\n        float PI = 3.14159265;\n        rotY = iMouse.x * 0.05;\n    \trotX = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n\n    // Camera setup\n    vec2 p0 = fragCoord.xy / iResolution.xy; // 0 to 1\n    p0.x *= iResolution.x/iResolution.y; // correct aspect ratio\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*rotY),2.5 * cos(rotX),2.5*cos(0.25*rotY)); // camera position\n    vec3 ww = normalize(vec3(0.0) - ro); // look at\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww )); // right\n    vec3 vv = normalize(cross(ww,uu)); // up\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww ); // ray direction\n    vec3 col = timeRendering( vec3(time,1.8,0.0), rd ); // render\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}