{"ver":"0.1","info":{"id":"tdyXRR","date":"1576674118","viewed":68,"name":"Ray Tracing 2 - csblo","username":"csblo","description":"raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF 1/0\n#define PI 3.1415\n\nconst vec3 BG_COLOR = vec3(0.,0.15,0.2);\n\nstruct Ray\n{\n    vec3 ori;\n    vec3 dir;\n};\n    \nstruct _Material\n{\n    vec3 color;\n    float albedo;\n    float specular;\n};\n\n// Material constructors\n    \n_Material Material(vec3 color)\n{\n    return _Material(color, 1., 0.);\n}\n\n_Material Material(vec3 color, float albedo)\n{\n    return _Material(color, albedo, 0.);\n}\n\n_Material Material(vec3 color, float albedo, float specular)\n{\n    return _Material(color, albedo, specular);\n}\n    \nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n    \nstruct DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n    float intensity;\n};\n    \nstruct Sphere\n{\n    vec3 pos;\n    vec3 rot;\n    float radius;\n    _Material material;\n};\n    \nstruct Hit\n{\n    bool collide;\n    vec3 point;\n    vec3 normal;\n    _Material material;\n};\n    \nstruct Scene\n{\n    Sphere[3] spheres;\n};\n\n// Create lights\nconst DirectionalLight sun = DirectionalLight(vec3(-0.1,-0.1,1.), vec3(1.), 3.);\nconst PointLight light1 = PointLight(vec3(0., 1.2, 7.2), vec3(1.), 3.);\n \n\nvec3 trace(Ray ray, Scene scene);\nvec3 trace_2(Ray ray, Scene scene);\n\n\nvec2 screenUV(vec2 uv)\n{\n    vec2 resizeUV = uv / iResolution.x;\n    return vec2(resizeUV.x - 0.5, resizeUV.y - (iResolution.y / iResolution.x * 0.5)); \n}\n\n\n//https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\nHit raycast(Ray ray, Sphere sphere)\n{\n    vec3 primaryRay = ray.ori - sphere.pos;\n    \n    // Line to sphere intersection equation\n    float a = -dot(ray.dir, primaryRay);\n    float b = pow(dot(ray.dir, primaryRay), 2.);\n    float c = dot(primaryRay, primaryRay) - sphere.radius;\n    float f = b - c;\n    float e = sqrt(f);\n    \n    // No solution because member to square root is negative\n    if (f < 0.)\n        return Hit(false, vec3(0.), vec3(0.), Material(vec3(0.)));\n    \n    // Check the two solutions\n    float s1 = a + e;\n    float s2 = a - e;\n    \n    if (s1 >= 0. || s2 >= 0.)\n    {\n        // Take the nearest\n        float d = min(s1, s2);\n        // compute hit point and normal\n        vec3 point = ray.ori + ray.dir * d;\n        vec3 normal = normalize(point - sphere.pos);\n        // Create hit\n        return Hit(true, point, normal, sphere.material);\n    }\n        \n}\n\n\n\nvec3 computeDirectionalLight(DirectionalLight light, Hit hit, Scene scene)\n{\n    // Shadow raycast   \n\n    // Add little offset from hit point for removing artefacts\n    Ray shadowRay = Ray(hit.point + hit.normal * 0.0001, -light.dir);\n    \n    // TODO check other sphere\n    Hit shadowHit = raycast(shadowRay, scene.spheres[1]);\n\n    float visible = float(!shadowHit.collide);\n\n    // compute color from light\n    float receiveIntensity = dot(-light.dir, hit.normal) * light.intensity;\n    return visible * hit.material.color * receiveIntensity * hit.material.albedo / PI;\n}\n\nvec3 computePointLight(PointLight light, Hit hit, Scene scene)\n{\n    // Shadow raycast   \n    vec3 lightDir = normalize(light.pos - hit.point);\n    float d = distance(light.pos, hit.point);\n    // Add little offset from hit point for removing artefacts\n    Ray shadowRay = Ray(hit.point + hit.normal * 0.0001, lightDir);\n    Hit shadowHit = raycast(shadowRay, scene.spheres[1]);\n\n    float visible = float(!shadowHit.collide);\n    \n    \n    // compute intensity\n    float receiveIntensity = dot(lightDir, hit.normal) * light.intensity;\n\treturn (visible * hit.material.color * receiveIntensity * hit.material.albedo) / (4. * PI * pow(d, 2.));\n}\n\nvec3 computeReflection(Ray ray, Hit hit, Scene scene)\n{\n    Ray specularRay = Ray(hit.point + hit.normal * 0.0001, reflect(ray.dir, hit.normal));   \n    return trace_2(specularRay, scene);\n    //return vec3(0);\n}\n\n#define MAX_DEPTH 3\n\nHit raycast(Ray ray, Scene scene)\n{\n   // Default hit\n    Hit maxHit = Hit(false, vec3(INF), vec3(0), Material(vec3(0)));\n    \n    for (int i = 0; i < scene.spheres.length(); i++)\n    {\n        Hit hit = raycast(ray, scene.spheres[i]);\n        \n        \n        if (hit.collide)\n        {\n            // Compare current hit and current nearest hit\n            float dHit = distance(ray.ori, hit.point);\n            float dMaxHit = distance(ray.ori, maxHit.point);\n            \n            // Get nearest hit\n            if (dHit < dMaxHit)\n            \tmaxHit = hit;\n        }\n        \n           \n    }\n    \n    return maxHit;\n}\n\n\nvec3 trace(Ray ray, Scene scene)\n{\n    Hit maxHit = raycast(ray, scene);\n    \n    if (maxHit.collide)\n    {\n\n\n        vec3 r = computeReflection(ray, maxHit, scene) * maxHit.material.specular;\n\n        // compute light & shadow ray\n        return r + (computePointLight(light1, maxHit, scene) + computeDirectionalLight(sun, maxHit, scene));\n    }    \n\n\treturn vec3(BG_COLOR);\n}\n\nvec3 trace_2(Ray ray, Scene scene)\n{\n\tHit maxHit = raycast(ray, scene);\n    \n    if (maxHit.collide)\n    {\n        // compute light & shadow ray\n        return computePointLight(light1, maxHit, scene) + computeDirectionalLight(sun, maxHit, scene);\n    }    \n\n\treturn vec3(BG_COLOR);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = screenUV(fragCoord);\n    vec3 planeUV = vec3(uv, 1.);\n        \n    \n    // Create spheres\n    //Sphere sphere1 = Sphere(vec3(0., 0., 8.), vec3(0.), 1., Material(vec3(1.,0.56,0.23)));\n    Sphere sphere1 = Sphere(vec3(0., 0., 8.), vec3(0.), 1., Material(vec3(1.), 1., .8));\n    Sphere sphere2 = Sphere(vec3(1., 0., 7.), vec3(0.), 0.3, Material(vec3(0.56,1.,0.23)));\n    Sphere sphere3 = Sphere(vec3(1., 1.5, 7.), vec3(0.), 0.2, Material(vec3(0.86,0.23,0.47)));\n    sphere2.pos = vec3(cos(iTime) * 2., 0., 8. + sin(iTime) * 2.);\n    sphere3.pos = vec3(sin(iTime), cos(iTime + 2.) * 2., 8. + sin(iTime + 2.) * 2.);\n    \n    // Create scene\n    Scene scene = Scene(Sphere[3] (sphere1, sphere2, sphere3));\n    \n    // Create primary ray, from eye to current fragment\n    vec3 dir = normalize(planeUV);\n    Ray ray = Ray(vec3(0.), dir);\n\t\n    vec3 col = trace(ray, scene);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}