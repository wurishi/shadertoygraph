{"ver":"0.1","info":{"id":"tdBSWh","date":"1553582319","viewed":256,"name":"Normal and cloud ray marching","username":"edo_m18","description":"Combine a normal ray marching and a cloud ray marching.\n\nBuffer A is to use as Depth buffer.\n\nI cannot understand the scene often occurred white flash.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","cloud","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float cloudSize = 1.1;\nconst vec3 cloudOffset = vec3(0.0, -5.0, 0.0);\n\n\nconst vec3 light = normalize(vec3(1.0, 0.8, 0.5));\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    // -2.0f^3 + 3.0f^2\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p += cloudOffset;\n    return cloudSize - length(p) * 0.1 + fbm(p * 0.3);\n}\n\nvec4 cloudRaymarch(vec3 ro, vec3 dir, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    const int sampleCount = 48;\n    const int shadowSampleCount = 8;\n    \n    float zmax = 25.0;\n    float zstep = zmax / float(sampleCount);\n    float invStep = 1.0 / float(sampleCount);\n    \n    float shadowmax = 3.0;\n    float shadowstep = shadowmax / float(shadowSampleCount);\n    float invShadowStep = 1.0 / float(shadowSampleCount);\n    \n    vec3 p = ro;\n    \n    vec3 lightenergy = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float depth = texture(iChannel0, uv).r * maxdist;\n    float dist = 0.0;\n\n    for (int i = 0; i < sampleCount; i++)\n    {        \n        if (dist >= depth)\n        {\n            break;\n        }\n        \n        if (transmittance < 0.1)\n        {\n            break;\n        }\n        \n        float density = cloud(p);\n        \n        if (density > 0.001)\n        {\n            vec3 lpos = p;\n            float shadow = 0.0;\n            \n            for (int s = 0; s < shadowSampleCount; s++)\n            {\n                lpos += light * shadowstep;\n                shadow += cloud(lpos);\n            }\n            \n            float opacity = 20.0;\n            float ds = density * invStep;\n            float linearDensity = ds * opacity;\n            linearDensity = clamp(linearDensity, 0.0, 1.0);\n            \n            float shadowStrength = 3.0;\n            float shadowterm = exp(-shadow * invShadowStep * shadowStrength);\n            \n            vec3 cloudCol = vec3(1.1, 0.9, 0.5);\n            float cloudDarkness = shadowterm * linearDensity * transmittance;\n            lightenergy += cloudCol * cloudDarkness;\n            \n            vec3 offset = p + vec3(0.0, 0.25, 0.0);\n            vec3 col = vec3(0.15, 0.45, 1.1);\n            \n            lightenergy += col * (exp(-cloud(offset) * 0.2) * linearDensity * transmittance);\n            \n            shadow = 0.0;\n            lpos = p + vec3(0.0, 0.0, 0.05);\n            float lsample = cloud(lpos);\n            shadow += lsample;\n            \n            lpos = p + vec3(0.0, 0.0, 0.1);\n            lsample = cloud(lpos);\n            shadow += lsample;\n            \n            lpos = p + vec3(0.0, 0.0, 0.2);\n            lsample = cloud(lpos);\n            shadow += lsample;\n            \n            float ambientDensity = 2.0;\n            vec3 ambcolor = vec3(1.0, 0.2, 0.3);\n            lightenergy += ambcolor * (exp(-shadow * ambientDensity) * linearDensity * transmittance);\n            \n            transmittance *= 1.0 - linearDensity;\n        }\n        \n        dist += zstep;\n        \n        p += dir * zstep;\n    }\n    \n    return vec4(lightenergy, transmittance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    const int MAX = 64;\n    \n    float rad = iTime * sp;\n    float x = cos(rad) * camDist;\n    float y = 4.0;\n    float z = sin(rad) * camDist;\n    vec3 ro = vec3(x, y, z);\n    mat3 cam = camera(ro, ta);\n    \n    vec3 ray = cam * normalize(vec3(uv, 1.3));\n    \n    vec3 p = ro;\n    float d = 0.0;\n    float dist = 0.0;\n    \n    vec2 duv = (fragCoord / iResolution.xy);\n    float depth = texture(iChannel0, duv).r * maxdist;\n    \n    for (int i = 0; i < MAX; i++)\n    {\n        if (dist - EPS > depth)\n        {\n            break;\n        }\n        \n        d = dist_func(p);\n        \n        if (d < EPS)\n        {\n            break;\n        }\n        \n        dist += d;\n        \n        p += ray * d;\n    }\n    \n    const vec3 bgCol = vec3(0.3, 0.5, 0.8);\n    \n    vec3 col = vec3(1.0);\n    vec3 bg = mix(col, bgCol, (uv.y + 1.0) * 0.5 + 0.5);\n    \n    if (d < EPS)\n    {\n        vec3 normal = getNormal(p);\n        float diff = clamp(dot(normal, light), 0.0, 1.0);\n        float amb = 0.2;\n        vec3 normCol = (getNormal(p) + 1.0) * 0.5;\n        col = vec3(diff + amb);// * normCol;\n    }\n    else\n    {\n    \tcol = bg;\n    }\n    \n    float fogIntencity = 0.05;\n    float fog = 1.0 - exp(-dist * fogIntencity);\n    col = mix(col, bg, fog);\n    \n    vec4 cl = cloudRaymarch(ro, ray, fragCoord);\n    col = mix(col, cl.rgb, 1.0 - cl.a);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///\n/// Calculate depth.\n///\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    const int MAX = 64;\n    \n    float rad = iTime * sp;\n    float x = cos(rad) * camDist;\n    float y = 4.0;\n    float z = sin(rad) * camDist;\n    vec3 ro = vec3(x, y, z);\n    mat3 cam = camera(ro, ta);\n    \n    vec3 ray = cam * normalize(vec3(uv, 1.3));\n    \n    vec3 p = ro;\n    float d = 0.0;\n    float dist = 0.0;\n    \n    for (int i = 0; i < MAX; i++)\n    {\n        d = dist_func(p);\n        \n        if (d < EPS)\n        {\n            break;\n        }\n        \n        dist += d;\n        \n        p += ray * d;\n    }\n    \n\tfragColor = vec4(vec3(dist / maxdist), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EPS (0.0001)\n#define PI (3.1415)\nconst float maxdist = 100.0;\nconst float camDist = 28.0;\nconst vec3 ta = vec3(0, 0, 0);\nconst float sp = 0.1;   \n\n///\n/// Translate the ray.\n/// \nvec3 trans(vec3 p, float space)\n{\n    return mod(p, space) - space * 0.5;\n}\n\n///\n/// Sphere distance function.\n///\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n///\n/// Twist the position.\n///\nvec3 twist(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3\n    (\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\n///\n/// Sphere distance function.\n///\nfloat dist_sphere(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\n///\n/// Rounded box distance function.\n///\nfloat dist_round_box(vec3 p)\n{\n    vec3 q = abs(p);\n    return length(max(q - vec3(0.5, 0.5, 0.5), 0.0)) - 0.1;\n}\n\n///\n/// Capped cylinder distance function.\n///\nfloat dist_capped_cylinder(vec3 p, float h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n///\n/// Cylinder distance function.\n///\nfloat dist_cylinder(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\n///\n/// Box distance function.\n///\nfloat dist_box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n           + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n///\n/// Totaly distance function.\n///\nfloat dist_func(vec3 p)\n{\n    float rad = 45.0 * PI / 180.0;\n    vec3 axis = vec3(0.5, 1.0, 0.0);\n    \n    vec3 q = rotate(trans(p, 5.0), rad, axis);\n    float d1 = dist_box(q, vec3(1.0, 0.3, 0.3));\n    float d2 = dist_round_box(q);\n    \n    vec3 r = trans(p, 10.0);\n    float d3 = dist_cylinder(r, vec3(0.5));\n    return min(max(-d1, d2), d3);\n}\n\n///\n/// Get normal by distance function.\n///\nvec3 getNormal(vec3 p)\n{\n    const vec2 d = vec2(EPS, 0.0);\n    return normalize(vec3(\n\t\tdist_func(p + d.xyy) - dist_func(p - d.xyy),\n        dist_func(p + d.yxy) - dist_func(p - d.yxy),\n        dist_func(p + d.yyx) - dist_func(p - d.yyx)\n    ));\n}\n\n///\n/// Create camera pose matrix.\n///\nmat3 camera(vec3 ro, vec3 ta)\n{\n    const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    return mat3(uu, vv, ww);\n}","name":"Common","description":"","type":"common"}]}