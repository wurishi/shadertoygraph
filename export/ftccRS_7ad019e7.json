{"ver":"0.1","info":{"id":"ftccRS","date":"1660075192","viewed":244,"name":"Shield and Waves","username":"CasualGarageCoder","description":"A simple shield with an impact with waves. Works better with seamless simplex noise texture at iChannel1.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","waves","shield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0 License.\n\nconst float MPI = 1.5707966326;\n\nconst int STEPS = 20;\n\nconst float LOWER_LIMIT = 0.01;\n\nfloat zoom_out = 1.6;\n\nfloat border_decay = 0.6;\n\nvec4 shield_tint = vec4(0.2, 0.2, 0.5, 0.2);\n\nvec4 shield_saturation = vec4(1.);\n\nfloat attack_angle = MPI / 2.;\n\nfloat attack_penetration = 0.2;\n\nfloat attack_radius = 1.6;\n\nfloat attack_amplitude = 0.4;\n\nfloat wave_speed = 16.;\n\nfloat wave_num = 17.;\n\nfloat noise_speed = 0.8;\n\nfloat noise_amplitude = 0.95;\n\nfloat noise_deformation = 8.0;\n\nfloat compute_z_radius(vec2 pos, float r) {\n\tvec3 o = vec3(pos, -1.);\n\treturn -sqrt(1. - dot(o, o) + (r * r));\n}\n\nfloat compute_front_z(vec2 pos) {\n\tvec3 p = vec3(pos, -1.);\n\treturn (-sqrt(2. - dot(p, p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Sphere computation\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 current_pos = (uv - 0.5) * (2.0 * zoom_out);\n    current_pos.x *= iResolution.x/iResolution.y;\n\tfloat len = length(current_pos);\n\tvec2 attack_direction = vec2(cos(attack_angle), sin(attack_angle));\n\tvec4 noise_texel = texture(iChannel1, current_pos + iTime * attack_direction * noise_speed);\n\tvec4 noise_amount = (noise_texel * (1. - noise_amplitude)) + noise_amplitude;\n\tfloat noise_mask = (noise_amount.r + noise_amount.g + noise_amount.b) / 3.0;\n\tfloat amplitude_decay = (1. + attack_amplitude) * border_decay * noise_mask;\n\tfloat border_mask = clamp(len - amplitude_decay, 0., 1. - border_decay) / (1. - border_decay);\n\tfloat mask = clamp(ceil(noise_mask * (1. + attack_amplitude) - len), 0., 1.);\n\tvec4 shield_color = mix(shield_saturation, shield_tint, 1. - border_mask) * mask;\n\tvec2 deformation_mask = (noise_texel.rg - vec2(.5)) * 2. * mask;\n\n\t// Waves\n\tif(len <= 1. + attack_amplitude) {\n\t\tvec2 attack_norm = attack_direction * (1. - attack_penetration);\n\t\tvec3 attack_position = vec3(attack_norm, compute_front_z(attack_norm));\n\t\tfloat retained_len = 0.;\n\t\tfloat retained_intensity = 0.;\n\t\tfloat z_step = compute_z_radius(current_pos, 1. + attack_amplitude);\n\t\tfloat hdiff = 1.01 + attack_amplitude;\n\t\tfloat min_diff = hdiff;\n\t\tint step_id = STEPS;\n\t\tfor(int i = 0; i < STEPS; ++i) {\n\t\t\tvec3 current_projection = vec3(current_pos, z_step);\n\t\t\tvec3 pos_on_surface = normalize(current_projection);\n\t\t\tfloat att_len = length(attack_position - pos_on_surface);\n\t\t\tif(att_len < attack_radius) {\n\t\t\t\tfloat intensity = (cos(att_len * wave_num - iTime * wave_speed) + 1.)/2. * cos((att_len / attack_radius) * MPI);\n\t\t\t\thdiff = abs(length(current_projection) - 1. - (intensity * attack_amplitude));\n\t\t\t\tif(hdiff < min_diff) {\n\t\t\t\t\tretained_intensity = intensity;\n\t\t\t\t\tretained_len = att_len;\n\t\t\t\t\tmin_diff = hdiff;\n\t\t\t\t\tif (hdiff < LOWER_LIMIT) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfloat extra = pos_on_surface.z * (1. + (intensity * attack_amplitude));\n\t\t\t\tz_step += (extra - z_step) * (1. - (float(i) / float(STEPS)));\n\t\t\t} else {\n                break;\n            }\n\t\t}\n\t\tif ((hdiff < LOWER_LIMIT) || ((step_id == STEPS) && (min_diff < (1.0 + attack_amplitude)))) {\n\t\t\tshield_color = mask*mix(shield_color, shield_saturation, retained_intensity);\n\t\t\tdeformation_mask = mask*mix(current_pos * (1. - retained_intensity), deformation_mask, cos(((1. - (len / attack_radius))) * MPI));\n\t\t}\n\t}\n\n\tvec4 screen_color = texture(iChannel0, uv + (noise_deformation * deformation_mask)/iResolution.xy);\n\tfragColor = vec4(mix(screen_color.rgb, shield_color.rgb, shield_color.a), 1.0);\n}","name":"Image","description":"","type":"image"}]}