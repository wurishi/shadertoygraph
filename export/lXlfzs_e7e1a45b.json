{"ver":"0.1","info":{"id":"lXlfzs","date":"1728807773","viewed":36,"name":"Space-Time swapper","username":"Ceffa93","description":"Simple SDF shader that plays with swapping the space and time coordinates.\nLeft is the normal \"video\", right is the same data with Y and T swapped.\nChange line 97 to test different swappings. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["time","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nvec2 saturate2(vec2 i)\n{\n    return vec2(clamp(i.x,0.,1.), clamp(i.y,0.,1.));\n}\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\nvec3 lerp3(vec3 a, vec3 b, float t) {\n    return a + t * (b - a);\n}\n\nbool sphereSdf(vec2 pos, vec2 center, float radius)\n{\n    vec2 distVec = pos - center;\n    float dist2 = dot(distVec, distVec);\n    return dist2 <= radius;\n}\nbool rectSdf(vec2 pos, vec2 center, vec2 size)\n{\n    vec2 distVec = pos - center;\n    return abs(distVec.x) <= size.x/2. && abs(distVec.y) <= size.y/2.;\n}\nbool triangleSdf(vec2 p, vec2 v0, vec2 v1, vec2 v2) {\n    vec2 e0 = v1 - v0;\n    vec2 e1 = v2 - v1;\n    vec2 e2 = v0 - v2;\n    vec2 v0p = p - v0;\n    vec2 v1p = p - v1;\n    vec2 v2p = p - v2;\n    vec2 pq0 = v0p - e0 * clamp(dot(v0p, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1p - e1 * clamp(dot(v1p, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2p - e2 * clamp(dot(v2p, e2) / dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0p.x * e0.y - v0p.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (v1p.x * e1.y - v1p.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (v2p.x * e2.y - v2p.y * e2.x)));\n    return 0. > -sqrt(d.x) * sign(d.y);\n}\n\n\nvec3 evaluateColor(float c1, float c2, float c3)\n{\n    bool sun = sphereSdf(vec2(c1,c2), vec2(lerp(.3, .9, c3), lerp(.9, .3, pow(c3,2.))), .015);\n    bool cloud1 = sphereSdf(vec2(c1,c2), vec2(.78,.9), .003);\n    bool cloud2 = sphereSdf(vec2(c1,c2), vec2(.85,.9), .004);\n    bool cloud3 = sphereSdf(vec2(c1,c2), vec2(.92,.9), .003);\n\n    bool ground = rectSdf(vec2(c1,c2), vec2(.5,.05), vec2(1,.1)); \n    bool houseFront = rectSdf(vec2(c1,c2), vec2(.2,.15), vec2(.3,.2));\n    bool door = rectSdf(vec2(c1,c2), vec2(.2,.1), vec2(.07,.1));\n    bool window1 = rectSdf(vec2(c1,c2), vec2(.12,.2), vec2(.07,.07));\n    bool window2 = rectSdf(vec2(c1,c2), vec2(.28,.2), vec2(.07,.07));\n    bool chimney = rectSdf(vec2(c1,c2), vec2(.29,.33), vec2(.05,.1));\n    bool houseRoof = triangleSdf(vec2(c1,c2), vec2(.05,.25), vec2(.35, .25), vec2(.2, .4)); \n    bool ball = sphereSdf(vec2(c1,c2), vec2(c3*.6+.4,sin(c3*32.*PI)*.05+.15), .005);\n\n    vec3 color = lerp3(vec3(.7,.9,1.), vec3(.1,.2,.5), c3);\n    color = sun ? lerp3(vec3(.9,.9,.0), vec3(.9,.2,0), c3) : color;\n    color = cloud1 ? vec3(1,1,1) : color;\n    color = cloud2 ? vec3(1,1,1) : color;\n    color = cloud3 ? vec3(1,1,1) : color;\n    color = ground ? vec3(.5,.5,.0) : color;\n    color = houseFront ? vec3(1,1,.8) : color;\n    color = door ? vec3(.5,.3,.0) : color;\n    color = window1 ? vec3(.0,.8,1.) : color;\n    color = window2 ? vec3(.0,.8,1.) : color;\n    color = chimney ? vec3(.5,.3,.0) : color;\n    color = houseRoof ? vec3(1,0,0) : color;\n    color = ball ? vec3(.7,.0,.9) : color;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float separatorSize = 5.;\n    float size = min(iResolution.x/2. - separatorSize, iResolution.y);\n    float offset = (iResolution.y - size)*.5;\n    \n    vec3 colorLeft = vec3(0,0,0);\n    vec3 colorRight = vec3(0,0,0);\n    \n    float t = fract(iTime*.1);\n\n    {\n        vec2 uv = vec2(fragCoord.x / size, (fragCoord.y - offset) / size);\n        float x = uv.x;\n        float y = uv.y;   \n        colorLeft = uv != saturate2(uv) ? vec3(0,0,0) : evaluateColor(x, y, t);\n    }\n    \n    {\n        vec2 uv = vec2((fragCoord.x - size - 2.*separatorSize) / size, (fragCoord.y - offset) / size);\n        float x = uv.x;\n        float y = uv.y;   \n        colorRight = uv != saturate2(uv) ? vec3(0,0,0) : evaluateColor(x,t,y);\n    }\n\n\n   \n    fragColor = vec4(colorLeft + colorRight,1.0);\n}","name":"Image","description":"","type":"image"}]}