{"ver":"0.1","info":{"id":"MtVSDc","date":"1486306521","viewed":200,"name":"Ray Marching Shading Example","username":"yumcyawiz","description":"this is the example code of ray marching ADS(ambient + diffuse + specular) shading.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\n//rotation matrix\n//mat3 ry = mat3(cos(time), 0, -sin(time), 0, 1, 0, sin(time), 0, cos(time));\n\n\n//lots of these functions are imported from here\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\nfloat opS(float d1, float d2) {\n\treturn max(-d1, d2);\n}\nfloat opI(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat displace(vec3 p) {\n\treturn sin(p.x + 1.1*time)*sin(p.y + 1.3*time)*sin(p.z + 1.2*time);\n}\n\nfloat opDisplace(vec3 p) {\n\tfloat d1 = opS(sdBox(mod(p, vec3(2.0)) - 0.5*vec3(2.0), vec3(1.0)), sdSphere(p, 3.0));\n\tfloat d2 = displace(p);\n\treturn d1+d2;\n}\n\n\n//distance field\nfloat dist(vec3 p) {\n\treturn opU(opDisplace(p), sdBox(p + vec3(0, 1.1, 0), vec3(6, 0.1, 6)));\n}\n\n\n//normal\nvec3 calcNormal(vec3 p) {\n\tfloat d = 0.001;\n\treturn normalize(vec3(\n\t\tdist(p + vec3(d, 0, 0)) - dist(p + vec3(-d, 0, 0)),\n\t\tdist(p + vec3(0, d, 0)) - dist(p + vec3(0, -d, 0)),\n\t\tdist(p + vec3(0, 0, d)) - dist(p + vec3(0, 0, -d))\n\t\t));\n}\n\n\nstruct ray {\n\tvec3 rayDir;\n\tvec3 position;\n\tvec3 normal;\n\tint steps;\n\tfloat t;\n};\n\n//ray marching\nconst int maxStep = 100;\nray trace(vec3 from, vec3 rayDir) {\n\tfloat t = 0.0;\n\tvec3 p;\n\tint steps;\n\tfor(int i = 0; i < maxStep; i++) {\n\t\tp = from + t*rayDir;\n\t\tfloat d = dist(p)/2.0;\n\t\tt += d;\n\t\tif(d < 0.01) {\n\t\t\tp -= 0.001*rayDir;\n\t\t\tsteps = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ray(rayDir, p, calcNormal(p), steps, t);\n}\n\n//shading function\nvec3 lightPos = vec3(0, 10, 10);\nconst float mix1 = 0.3;\nconst float mix2 = 0.5;\nconst float shininess = 12.0;\nvec3 shade(vec3 position, vec3 rayDir, vec3 normal, int steps) {\n\tray tr = trace(lightPos, normalize(position - lightPos));\n\tbool visible;\n\tif(distance(tr.position, position) < 0.1) {\n\t\tvisible = true;\n\t}\n\telse {\n\t\tvisible = false;\n\t}\n\t\n\tfloat diffuse = max(dot(normal, -tr.rayDir), 0.0);\n\tfloat specular = pow(max(dot(rayDir, reflect(normal, -tr.rayDir)), 0.0), shininess);\n\tvec3 directColor = vec3(0);\n\tif(visible) directColor = vec3(mix(diffuse, specular, mix1));\n\t\n\tfloat ao = 1.0 - float(steps)/float(maxStep);\n\tvec3 indirectColor = ao * vec3(0.6, 0.7, 1);\n\t\n\treturn 2.0*mix(directColor, indirectColor, mix2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*gl_FragCoord.xy - iResolution.xy)/iResolution.x;\n\t\n    //camera settings\n\tvec3 camPos = vec3(10.0*cos(time/2.0), 1, -10.0*sin(time/2.0));\n\tvec3 camFront = normalize(-camPos);\n\tvec3 camUp = vec3(0, 1.0, 0);\n\tvec3 camRight = cross(camFront, camUp);\n\t\n    //ray marching\n\tvec3 rayDir = normalize(uv.x*camRight + uv.y*camUp + 1.0*camFront);\n\tray tr = trace(camPos, rayDir);\n    //shading\n\tvec3 color = shade(tr.position, tr.rayDir, tr.normal, tr.steps);\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}