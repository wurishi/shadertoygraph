{"ver":"0.1","info":{"id":"XXXfzs","date":"1728767821","viewed":97,"name":"Wave ABC PML 1D","username":"spalmer","description":"trying simple ABC in 1D where I might be able to nail it.  Apparently it's trickier in 2D+\nI got athibaul's [url=fsyfWt]http://shadertoy.com/view/fsyfWt[/url] chopped down to 1D and still working  :)","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["wave","abc","layer","boundary","match","perfect","condition","absor","pml"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by spalmer, based on athibaul's 2D toy.\n\n// perfectly matched layers absorb reflections at boundary\n\n// PML is probably overkill for 1D,\n// but it's the first thing I got working,\n// even though I don't 100% grok everything yet.\n\n// hope will help us over at http://shadertoy.com/view/43lBzS\n\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    vec2 uv = fc / R;\n    float p = texture(iChannel0, vec2(uv.x, 0)).x;\n    float u = texture(iChannel1, vec2(uv.x, 0)).x;\n    float h = p; //u; // what to graph?  graphing pressure as amplitude seems right\n    float g = clamp((h + .5 - uv.y) * R.y, 0., 1.); // graph quantity h\n    o = vec4(vec3(sqrt(g)), 1);\n    o.g += alphax_at(fc, R); // show PML boundary region green\n    if (isinf(u)) o.r = 1.; // bad\n    if (isnan(u)) o.b = 1.; // very bad\n}\n\n\n// see:\n// Yuan, X., Borup, D., Wiskin, J. W., Berggren, M., \n//  Eidens, R., & Johnson, S. A. (1997):\n// \"Formulation and validation of Berenger's PML absorbing boundary \n//  for the FDTD simulation of acoustic scattering.\"\n// - IEEE transactions on ultrasonics, ferroelectrics, \n//    and frequency control, 44(4), 816-822.\n// https://sci-hub.st/10.1109/58.655197\n\n/* must go to the source paper for clarity\n𝑝 is pressure field\n𝘂 is vector velocity field\nρ (rho) is mass density of medium\nα (alpha) is attenuation coefficient for compressibility\nα∗ is attenuation coeff associated with density\nκ (kappa) is compressibility\nc (speed of waves) = 1/√(κρ)\n∇ 𝑝(x,t) = -ρ(∂/∂t) 𝘂(x,t) - α∗𝘂(x,t)\n∇⋅𝘂(x,t) = -κ(∂/∂t) 𝑝(x,t) - α 𝑝(x,t)\n\nso, use laplacian of 𝘂, partial derivatives (gradient) of 𝑝\n*/\n\n\n// see also the recent rreusser toy http://shadertoy.com/view/l3ccRr,\n// explains the math in a reasonable manner I can mostly follow","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// PML part A from http://shadertoy.com/view/fsyfWt - P buffer (pressure-gradient)\n\n// P aka 𝑝 is a pressure field.  original toy split it into x and y components somehow.\n\n// \"for the 2D case, 𝑝 is first split into two additive components, 𝑝 = 𝑝_x + 𝑝_y,\n// such that ..\" yeah, they split P up into directional components\n// similar to partial derivatives so they can do the x and y parts separately.\n\nfloat hash11(float p) // by Dave Hoskins\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// simple 1D value noise\nfloat noise(float t)\n{\n    float i = floor(t), f = fract(t);\n    f = (3. - 2. * f) * f * f; //smoothstep(0., 1., f);\n    return mix(hash11(i), hash11(i + 1.), f);\n}\n\n// pressureSource(u).y is mask, 1 if we impose pressure at that point\n//   .x is the pressure (gradient) value\nvec2 pressureSource(float u, float iF)\n{\n    if (abs(u - .5) < .007)\n        return vec2(.2 * (noise(iF * .05) - .5) * smoothstep(0., 20., iF), 1.);\n    \n    return vec2(0);\n}\n        //return vec2(1.*sin(iF*0.2), 1.);\n        //return vec2(10.*smoothstep(0.,10.,iF)*smoothstep(20.,10., iF), 1);\n        //return vec2(2.*sin(iF*0.2)*sqr(sqr(cos(iF*0.0162))), 1.);\n/*\n// simplified, without any PML, and with all 1.0 constants removed for clarity, so I may try to grok the integration algorithm\nvoid mainImage2(out vec4 o, vec2 fc)\n{\n    ivec2 ij = ivec2(fc);\n    if (ij.y != 0) discard;\n    if (iFrame == 0) {\n        o = vec4(0, 0, 0, R.x);\n        return;\n    }\n\n    ivec2 di = ivec2(1, 0);\n    // I believe what looks like a backward (partial) gradient\n    // here is actually a Laplacian ∇⋅𝘂\n    float px_np1 = Px(ij) - 1./2. * (Ux(ij) - Ux(ij - di)); // backward gradient\n    //    px_np1 = Px(ij + 0*di) - 1./2. * (Ux(ij + di) - Ux(ij)); // alternative gradient FAIL\n    // indicates P and U may not be on the same grid, may be offset by 1/2 somehow\n    // I just can't seem to get an alternative gradient to succeed, have tried many variants.\n    // that's because it's not a gradient at all, duh, it's a Laplacian.  Read the paper!\n    \n    vec2 uv = fc / R,\n        ps = pressureSource(uv.x, float(iFrame));\n    if (false &&  // Zero pressure on boundary - won't help without PML layers\n         ij.x == 0 \n      || ij.x == int(R.x) - 1)\n    {\n        o = vec4(0, 0, 0, R.x);\n    }\n    else if (ps.y > 0.)\n    {\n        o = vec4(ps.x * .5, 0, 0, R.x);\n    }\n    else\n    {\n        o = vec4(px_np1, 0, 0, R.x);\n    }\n}\n*/\n// actual PML code\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    ivec2 ij = ivec2(fc);\n    if (ij.y != 0) discard;\n    vec2 uv = fc / R;\n    \n    if (iFrame == 0) // || texelFetch(iChannel0, ivec2(0), 0).w != R.x)\n    {\n        float p0 = 0.;\n        // something about an initial wave reflects back\n        //p0 = .01 * sin(24. * 3.1416 * uv.x); // * sin(7.*3.1416*fc.y/R.y);\n        //p0 = .5 * smoothstep(.95, .9,length(uv));\n        o = vec4(p0, 0, 0, R.x);\n        return;\n    }\n    // no .5 offset here - tried, did bad things\n    float ax = alphax_at(vec2(ij), R);\n    \n    float h = Delta / (2. * c_max);\n    \n    float e1x = ax > 0. ? exp(-ax * h / kappa) : 1.;\n    float e2x = ax > 0. ? (1. - e1x) / (Delta * ax) : h / (Delta * kappa);\n    ivec2 di = ivec2(1, 0);\n    float px_np1 = Px(ij) * e1x - e2x * (Ux(ij) - Ux(ij - di));\n    // it's a Laplacian operator dropped to 1D\n\n    vec2 ps = pressureSource(uv.x, float(iFrame));\n    /*if (iMouse.z > 0.) // no interaction (yet)\n    {\n        float d = length(fc - iMouse.zw);\n        float source = smoothstep(30., 0.0, d);\n        px_np1 += source;\n        py_np1 += source;\n    }*/\n    // \"At the outer boundary a perfectly reflecting boundary condition is enforced\"\n    if ( ij.x == 0 \n      || ij.x == int(R.x) - 1)\n    {\n        // Zero pressure on boundary\n        o = vec4(0, 0, 0, R.x);\n    }\n    else if (ps.y > 0.)\n    {\n        o = vec4(ps.x * .5, 0, 0, R.x);\n    }\n    else\n    {\n        o = vec4(px_np1, 0, 0, R.x);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// PML part B from http://shadertoy.com/view/fsyfWt - U buffer (position/amplitude)\n\n// U aka 𝘂 is a vector velocity field, but in 1D it's just scalar.\n/*\n// no PML, all 1.0 constants removed for clarity\nvoid mainImage2(out vec4 o, vec2 fc)\n{\n    ivec2 ij = ivec2(fc);\n    if (ij.y != 0) discard;\n    \n    if (iFrame == 0) {\n        o = vec4(0, 0, 0, R.x);\n        return;\n    }\n\n    ivec2 di = ivec2(1, 0);\n    // pressure (partial) derivative\n    float ux_np1 = Ux(ij) - 1./2. * (Px(ij + di) - Px(ij));\n    \n    o = vec4(ux_np1, 0, 0, R.x);\n}\n*/\n// with PML\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    ivec2 ij = ivec2(fc);\n    if (ij.y != 0) discard;\n    \n    if (iFrame == 0) // || texelFetch(iChannel1, ivec2(0),0).w != R.x)\n    {\n        float p0 = 0.;\n        // an initial wave reflects back.  hrmm.\n        //p0 = .1 * sin(24. * 3.1416 * fc.x/R.x); // * sin(7.*3.1416*fc.y/R.y);\n        o = vec4(p0, 0, 0, R.x);\n        return;\n    }\n\n    float h = Delta / (2. * c_max);\n    // why + .5? seems crucial.\n    float gx = alphax_at(vec2(ij) + vec2(.5, 0), R) / kappa; // gamma 𝛾 γ\n    // paper discusses gamma in terms of the boundary layer index.\n    // γ_x(i,j) = α_max((m-i-1/2)/m)², i = 0,...,m-1, j = m,...,N_y-m-1\n    // 𝚫 is the spatial sample interval.\n    // γ_x(i,j) = α_x((i+1/2)𝚫,j𝚫)/κ((i+1/2)𝚫,j𝚫) // 2D eqn\n    // γ_x(i)   = α_x((i+1/2)𝚫   )/κ((i+1/2)𝚫) // chopped down 3D eqn to 1D :)\n    // ρ_x(i,j) = ρ((i+1/2)𝚫,j𝚫)\n\n    float e3x = gx > 0. ? exp(-gx * h) : 1.;\n    float e4x = gx > 0. ? (1. - e3x) / (Delta * rhox * gx) : h / (Delta * rhox);\n    ivec2 di = ivec2(1, 0);\n    float ux_np1 = Ux(ij) * e3x - e4x * (Px(ij + di) - Px(ij));\n    \n    o = vec4(ux_np1, 0, 0, R.x);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// from http://shadertoy.com/view/fsyfWt\n\n// pretty good w m = 3. now in 1D\nconst float m = 4.; // PML thickness\n// original toy used 8. for 2D.\n// seems can get away with fewer in 1D.\n// I believe the imbalance problem was in alphax_at ... now fixed, hopefully.\n\nconst float\n    alphamax = 2.3, // α\n    Delta = 1., // might be dt?  𝚫t, fixed framerate stuff\n    c_max = 1., // wave speed limit = 1 grid cell / frame\n    kappa = 1., // ρ\n    rhox = 1.; // κ\n// all these constants that are 1.0 clutter up the code visually.\n// too bad we can't use actual greek letters in code!  would help.\n    \n#define sqr(x) ((x) * (x))\n#define R iResolution.xy\n\n#define Px(ij) texelFetch(iChannel0, ij, 0).x\n#define Ux(ij) texelFetch(iChannel1, ij, 0).x\n\nfloat alphax_at(vec2 c, vec2 r)\n{\n    float i = min(c.x, r.x - 1. - c.x);  // bugfix right boundary, improves balance\n    i = min(i, m); // FIXME the paper pg 819 says i = 0,...,m-1 so this clamp seems wrong, off by 1\n    return alphamax * sqr((m - i) / m); // the squaring seems important\n}\n\n    // account for exact boundary which always gets pressure 0..?\n    // idk helps or harms things.  Unnecessary.\n    //float z = 0.; //1.; //\n    //float i = min(c.x - z, r.x - 1. - z - c.x);\n","name":"Common","description":"","type":"common"}]}