{"ver":"0.1","info":{"id":"MfSXDW","date":"1708412397","viewed":73,"name":"shiny silver","username":"eissa","description":"new renderer with Phong lighting.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"MflSWX","parentname":"Fork Fork Rayma eissa 282"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .0001\n#define MAX_VIEW_STEPS 100\n#define MAX_SHADOW_STEPS 64\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR .1\n#define MAX_DEPTH 10.0\n#define BUMP_FACTOR 0.03\n#define TEX_SCALE_FACTOR 1.\n#define repeat(p,r) (mod(p,r)-r/2.)\n\nLight light;\n\nfloat fmelty( vec3 p )\n{ \n    return length(      cos(p)\n                  + .05*cos(9.*p.y*p.x-p.y+p.z)\n                  - .05*cos(3.*(.3*p.x-p.y+p.z))\n                  ) - 1.; \n}\n\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\nvoid textureDistort(vec3 p, vec3 normal, float mat, out float bump) {\n\n    vec3 col = tex3D(p*TEX_SCALE_FACTOR, normal, iChannel0).rgb;\n    bump = dot(col, vec3(0.2126, 0.7152, 0.0722))*BUMP_FACTOR;\n    bump = bump;\n}\n\nvec3 screenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), 1);\n}\n\n// Cast regular ray\nvec4 raycast(in vec3 from, in vec3 dir) {\n    \n    float t = tmin;\n    vec4 d;\n    for (int i = 0; i < raySteps && t < tmax; i++) {\n        vec3 p = from + dir * t;\n        d = map(p);\n        if (abs(d.z) <= limit * t) {\n            d.z = t;\n            return d;\n        }\n        t += d.z;\n    }    \n    \n    // Avoid flicker when polygons are edgewise to the camera.\n    // In this case the ray cannot quite find the surface and runs out of steps.\n    // Just return the last sample point.\n    if (t < tmax) {\n        d.z = t;\n        return d;\n    }\n    \n    return vec4(0,0,-1.0,0);    \n}\n\n\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-map(pos).z;\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\nfloat calcShadow( vec3 origin, vec3 lightDir, Light light)\n{\n\tfloat dist;\n\tfloat result = 1.0;\n\tfloat lightDist = length(light.position-origin);\n\t\n\tvec3 pos = vec3(origin)+(lightDir*(EPSILON*15.0));\n\t\n\tfor(int i = 0; i < MAX_SHADOW_STEPS; i++)\n\t{\n\t\tvec4 ray = map(pos);\n        dist = ray.z;\n\t\tif(dist < EPSILON)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tif(length(pos-origin) > lightDist || length(pos-origin) > MAX_DEPTH)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tpos+=lightDir*dist;\n\t\tif( length(pos-origin) < lightDist )\n\t\t{\n\t\t\tresult = min( result, light.penumbraFactor*dist / length(pos-origin) );\n\t\t}\n\t}\n\treturn result;\n}\n\nvec3 normal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).z;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).z - d,\n        map(p + vec3(0,s,0)).z - d,\n        map(p + vec3(0,0,s)).z - d);\n    \n    return normalize(r);\n}\n\nvec3 drawPixel(in rayInfo ray) {\n    ray.dir = normalize(ray.dir);\n\n    // Sum up reflection bounces    \n    vec3 sumCol = vec3(0);\n    float alpha = 1.0;\n    for (int bounce = 0; bounce < bounces && alpha > 0.0002; bounce++) {\n    \n\t    // Ray cast\n\t    vec4 r = raycast(ray.origin, ray.dir);\n    \n        // Distance is returned in r.z\n\t    // Miss?\n\t    if (r.z == -1.0)\n\t    {\n            \n            vec3 missCol = getRayMissCol(ray);\n            sumCol += missCol * alpha;\n\t        break;\n\t    }\n        \n        \n\t    // Position and normal\n\t    vec3 p = ray.origin + r.z * ray.dir;\n\t    vec3 n = normal(p, r.z); \n        \n       \n        // Get material info\n        material mat = getMaterial(r.w, r.xy/2.);\n \n        // Cancel reflection if on last bounce\n        if (bounce == bounces - 1)\n            mat.reflective = 0.0001;\n    \n        // Apply lighting\n        float lightDist = length(light.position-vec3(0., 0., 0.));\n        vec3 lightDir = normalize(light.position-vec3(100., 0., 100.));\n        vec3 eyeDir = normalize(p-ray.origin);\n        float attenuation = min(1.0, 1.0/(lightDist/light.brightness));\n        float shadow = calcShadow(p, lightDir, light);\n        float occlusion = calcOcclusion(p, n);\n        vec3 reflection = normalize(reflect(eyeDir, n));\n\n        float specular = pow(max( 0.0, dot(lightDir, reflection)), 5.0);\n        float diffuse = max( 0.0, dot(lightDir, n));\n        float ambient = .05;\n\t\n\n        // Apply fog\n        float f = clamp(r.z * r.z / 3500.0, 0.0, 1.0);\n        sumCol += fog * f * alpha;\n        alpha *= (1.0 - f);\n        vec3 R = normalize(reflect(-eyeDir, n));\n        float dotRV = max(0.0, dot(R, -ray.dir));\n        \n        mat.col *= light.color.xyz*mat.col*clamp(((specular+diffuse)*attenuation)+(ambient*occlusion)* pow(dotRV, glossiness), 0.0, 1.0);\n\t    \n        // Add to sum of colours\n        mat.col *= (1.0 - mat.reflective);\n        sumCol += mat.col * alpha;\n        alpha *= mat.reflective;\n        \n        \n        \n        // Calculate reflection vector\n        ray.origin = p;\n        ray.dir = normalize(reflect(ray.dir, n));\n    }\n    \n    \n    return sumCol;\n}\n\n// Main entrypoints\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = Light(vec3(.0, .0+sin(iTime), -13.0), vec4(1.0,1.0,1.,1.0), 50.0, 50.0);\n    rayInfo ray = getRay(fragCoord);\n    vec3 col = drawPixel(ray);\n    // moving fog\n    //float c = 350.0 / (ray.dir.x+1.1+25.);\n    //vec3 cpos = ray.origin + c*ray.dir + vec3(831.0-iTime*1000., 321.0, 0.0);\n    //col += fbm( cpos*0.0015 )*.3 - .10;\n\n    col = encodeSRGB(col);\n    col = gamma(col,2.0);\n    \n    \n    fragColor = vec4(col, 1);\n}\n\n\n\nrayInfo getRay(in vec2 fragCoord) {\n    rayInfo ray;\n    \n    vec3 ang = vec3(0., 0., 0.);\n    ray.origin = vec3(2.8,0.+cos(iTime)*.05,-15.);\n    ray.dir = rotate(screenRay(fragCoord), ang);\n    return ray;\n}\n\n\nvec3 getRayMissCol(in rayInfo ray) {\n    vec3 skycol = fog;\n    if (ray.dir.y > 0.0) {\n    \n    }\n    \n    return skycol;\n}\n\n// Material types.\n// Returned by map(). Then passed into getMaterial() to get colour, lighting etc.\nconst float redMat \t\t= 1.0;\nconst float blueMat \t= 2.0;\nconst float mirrorMat \t= 3.0;\nconst float marbleMat \t= 4.0;\nconst float woodMat \t= 5.0;\nconst float blendMat \t= 6.0;\nconst float metalMat \t= 7.0;\n\n// Lookup material colour etc\nmaterial getMaterial(float matType, vec2 uv) {\n\n    // Set defaults\n    material mat;\n    mat.lighting.diffuse = 0.6;\n    mat.lighting.specular = 0.8;\n    mat.lighting.shiny = 32.0;\n    mat.reflective = 0.0001;\n    \n    if (matType == redMat) {        \n        mat.col = vec3(0.8, 0.8, 0.8);\n        mat.lighting.specular = 2.5;\n        mat.lighting.diffuse = 0.8;\n        mat.reflective =.15;\n    }\n    else if (matType == blueMat) {        \n        mat.col = vec3(0.3, 0.5, 0.9);\n    }        \n    else if (matType == marbleMat) {\n        mat.reflective = 0.15;\n        mat.col = texture(iChannel0, uv * 0.1).xyz*2.0;\n    }\n    else if (matType == mirrorMat) {\n        mat.reflective = 0.6;\n        mat.col = vec3(0.7);\n    }\n    else if (matType == woodMat) {\n        mat.col = texture(iChannel1, uv * 0.05).xyz;  \n    }\n    \n    else if (matType == metalMat) {\n        mat.reflective = 0.15;\n        mat.col = texture(iChannel2, uv * 0.05).xyz * 2.0;              \n    }\n    \n    return mat;\n}\n\nvec4 _sphere1, _box1;\n\nvec4 map(in vec3 p) {\n    // Combine shapes with materials\n    //float modx = pMod1(p.x, 12.0);\n    //float mody = pMod1(p.y, 12.0);\n    //float modz = pMod1(p.z, 12.0);\n    \n    //    _sphere1 = vec4(0.0, 0.0, 0.0, 7.5);\n    //_box1 = vec4(0.0, 0.0, 0.0, 6.0);\n    \n    //play around with displacement, super cool!\n    //vec3 r = carve(box(p, _box1.xyz, _box1.www),sphere(p , _sphere1.xyz, _sphere1.w));\n    //vec4 R = makes(r, redMat);\n    //return R;\n    vec3 r1 = vec3(p.x,p.y,fmelty(p));\n    vec3 r2 = plane(p,vec3(.0,-1.0,.0),vec3(.0,1.0,.0));\n    \n    vec3 combined = combine(r1,r2,.5);\n    \n    \n    \n    \n    return makes(combined, redMat); \n    \n    \n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// A little SDF ray-marching \"framework\".\n// Much of the techniques are copied from IQ's demos and articles.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst float tmin = 0.01;\t\t\t\t\t\t\t\t// Ray minimum distance\nconst float tmax = 500.0;\t\t\t\t\t\t\t\t\nconst int raySteps = 256;\t\t\t\t\t\t\t\t// Max iterations when resolving a ray\nconst int shadowSteps = 50;\t\t\t\t\t\t\t\t// Max iterations when resolving a shadow ray\nconst float limit = 0.0005;\t\t\t\t\t\t\t\t// Convergence to surface limit when ray tracing\nconst float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\t// Light direction\nconst float ambient = 0.2;\t\t\t\t\t\t\t\t// Ambient light\nconst vec3 fog = vec3(94.,55.,21.);\t\t\t\t\t\t// Fog colour\nconst int bounces = 2;\t\t\t\t\t\t\t\t\t// Max reflection bounces (actually bounces + 1, as includes initial ray)\nconst float glossiness = 55.;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Data structures\nstruct Light\n{\n\tvec3 position;\n\tvec4 color;\n\tfloat brightness;\n\tfloat penumbraFactor;\n};\n\n\n\nstruct lightingParams {\n \tfloat diffuse;\n    float specular;\n    float shiny;\n};\n\nstruct material {\n    vec3 col;\t\t\t\t\t\t\t\t\t\t\t// Surface colour\n    lightingParams lighting;\n    float reflective;\t\t\t\t\t\t\t\t\t// Reflectiveness. 0 = not reflective. 1 = completely reflective (e.g. mirror).\n};\n    \nstruct rayInfo {\n    vec3 origin;\n    vec3 dir;\n};\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Functions (implemented at the bottom)\n    \n// Get camera ray for specified pixel\nrayInfo getRay(in vec2 fragCoord);\n\n// Get VR ray\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir);\n\n// Get sample point.\n// Format is vec4:\n//\tx,y\t\t= Material parameter (e.g. uv)\n//\tz\t\t= Distance to nearest surface\n//\tw\t\t= Material index (will be passed to getMaterial())\nvec4 map(in vec3 p);\n\n// Get material properties by index\nmaterial getMaterial(float index, vec2 uv);\n\n// Get colour for ray that misses\nvec3 getRayMissCol(in rayInfo ray);\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Trig\n\nconst float PI = 3.14159265;\n\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotatez(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 euler) {\n \treturn rotatey(rotatex(rotatez(p, euler.z), euler.x), euler.y);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Helper functions\n\n\n// Pinched from: https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 2d noise function\nfloat noise( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.2;\n  f += 0.2500*noise( p ); p = m*p*1.3;\n  f += 0.1666*noise( p ); p = m*p*1.4;\n  f += 0.0834*noise( p );\n  return f;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Combining shapes\n//\n// Sample format is vec3:\n//\tx,y\t\t= Material parameter (e.g. texture coordinates)\n//\tz\t\t= Distance\n\n// Union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2) { \n    return p1.z < p2.z ? p1 : p2;\n}\n\n// Smoothed union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z < p2.z ? p1.xy : p2.xy, sminCubic(p1.z, p2.z, k));\n}\n\n// Subtract shape p2 from p1\nvec3 carve(in vec3 p1, in vec3 p2) { \n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\n// Intersection of two shapes\nvec3 intersect(in vec3 p1, in vec3 p2) { \n    return p1.z > p2.z ? p1 : p2;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shape primitives\n\nvec3 sphere(in vec3 p, in vec3 center, float rad) { \n    p -= center;\n    return vec3(atan(p.x, p.y) * rad, atan(length(p.xy), p.z) * rad, length(p) - rad); \n}\nvec3 box(in vec3 p, in vec3 center, in vec3 size) {\n    p -= center;\n    vec3 x = vec3(p.yz, abs(p.x) - size.x);\n    vec3 y = vec3(p.xz, abs(p.y) - size.y);\n    vec3 z = vec3(p.xy, abs(p.z) - size.z);\n    return intersect(x, intersect(y, z));\n}\nvec3 cube(in vec3 p, in vec3 center, float size) \t{ return box(p, center, vec3(size)); }\nvec3 planeLeft(in vec3 p, float x)\t\t\t\t\t{ return vec3(p.yz, x-p.x); }\nvec3 planeRight(in vec3 p, float x)\t\t\t\t\t{ return vec3(p.yz, p.x-x); }\nvec3 planeBottom(in vec3 p, float y)\t\t\t\t{ return vec3(p.xz, y-p.y); }\nvec3 planeTop(in vec3 p, float y) \t\t\t\t\t{ return vec3(p.xz, p.y-y); }\nvec3 planeFront(in vec3 p, float z)\t\t\t\t\t{ return vec3(p.xy, z-p.z); }\nvec3 planeBack(in vec3 p, float z)\t\t\t\t\t{ return vec3(p.xy, p.z-z); }\nvec3 cylinder(in vec3 p, in vec3 center, float radius, float height) { \n    p -= center;\n    vec3 tube = vec3(atan(p.x, p.z) * radius, p.y, length(p.xz) - radius);\n    vec3 top = planeTop(p, height);\n    vec3 bottom = planeBottom(p, -height);\n    return intersect(tube, intersect(top, bottom));\n}\nvec3 torus(in vec3 p, in vec3 center, float radius, float thickness) { \n    p -= center;\n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\nvec3 plane(in vec3 p, in vec3 center, in vec3 n) { \n    return vec3(0, 0, dot(p - center, n)); \n}\nvec3 pyramid(in vec3 p, in vec3 center, float width, float height) {\n    vec3 top = center + vec3(0, height, 0);\n    vec3 r = planeBottom(p, center.y);\n    r = intersect(r, plane(p, top, normalize(vec3( height,width, 0))));\n    r = intersect(r, plane(p, top, normalize(vec3(-height,width, 0))));\n    r = intersect(r, plane(p, top, normalize(vec3( 0,width, height))));\n    r = intersect(r, plane(p, top, normalize(vec3( 0,width,-height))));\n    return r;\n}\n\n\n\n\n// Creating and combining full sample including material index\nvec4 makes(in vec3 d, float material) {\n    // Like a distance sample, but with w = material index.\n    // Specifically:\n    //\tx,y\t= material parameter (e.g. texture coord)\n    //\tz\t= distance\n    //\tw\t= material index\n \treturn vec4(d, material);   \n}\n\nvec4 merges(in vec4 result, in vec3 d, float material) {\n \treturn d.z < result.z ? makes(d, material) : result;\n}\n\nfloat pMod1 (inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p+halfsize)/size);\n\tp = mod(p+halfsize,size)-halfsize;\n\tp = mod(-p+halfsize,size)-halfsize;\n\treturn c;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Gamma Correction\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}","name":"Common","description":"","type":"common"}]}