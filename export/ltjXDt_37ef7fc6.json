{"ver":"0.1","info":{"id":"ltjXDt","date":"1447442047","viewed":549,"name":"Different gradients","username":"anastadunbar","description":"Gradients between two points.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","tutorial","gradient","distance","linear","photoshop","shade","tip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793238462\nvec2 rotation(float rot,vec2 pos)\n{\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2(pos*rotation);\n}\nfloat linearstep(float a, float b, float x) //Thank you Dave_Hoskins\n{\n    return clamp((x-a)/(b-a),0.0,1.0);\n}\n//Gradients\nfloat gradient_linedist(vec2 uv, vec2 p1, vec2 p2) {\n    return abs(((p2.x-p1.x)*(p1.y-uv.y))-((p1.x-uv.x)*(p2.y-p1.y)))/length(p1-p2);\n}\nfloat gradient_radial(vec2 uv, vec2 p1, vec2 p2) {\n    return length(uv-p1)/length(p1-p2);\n}\nfloat gradient_diamond(vec2 uv, vec2 p1, vec2 p2) {\n    float a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    vec2 d = rotation((a*PI*2.)+(PI/4.),uv-p1);\n    vec2 d2 = rotation((a*PI*2.)+(PI/4.),p1-p2);\n    return max(abs(d.x),abs(d.y))/max(abs(d2.x),abs(d2.y));\n}\nfloat gradient_angle(vec2 uv, vec2 p1, vec2 p2) {\n    //Non-smooth version:\n    /*float a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    return fract((atan(p1.x-uv.x,p1.y-uv.y)+PI)/(PI*2.)-a);*/\n    //Smooth version (For those who hate pixels, includes linearstep function):\n    float a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    float a2 = fract((atan(p1.x-uv.x,p1.y-uv.y)+PI)/(PI*2.)-a);\n    return a2+linearstep(0.0005/length(uv-p1),0.,a2);\n}\nfloat gradient_linear(vec2 uv, vec2 p1, vec2 p2) {\n    /* TOO LONG.\n\tfloat a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    uv -= p1;\n    uv = uv/length(p1-p2);\n    uv = rotation((a*PI*2.)-(PI/2.),uv);\n    return uv.x;\n\t*/\n\t//dot = (x1*y1)+(x2*y2)+...\n    //Found out when seeing this: https://www.shadertoy.com/view/lscGDr\n    return clamp(dot(uv-p1,p2-p1)/dot(p2-p1,p2-p1),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = vec2(((uv.x-0.5)*(iResolution.x / iResolution.y))+0.5,uv.y);\n    float time = iTime;\n    \n    vec2 point1 = vec2(sin(time*0.96),cos(time*2.12));\n    point1 = (point1+1.)/2.;\n    /*\n    if (iMouse.z >= 1.) {\n        point1 = vec2((((((iMouse.x*(iResolution.x/iResolution.y))*2.)/iResolution.x)-(iResolution.x/iResolution.y))+1.)/2.,iMouse.y/iResolution.y);\n    }*/\n    vec2 point2 = vec2(sin(time*3.11),cos(time*1.05));\n    point2 = (point2+1.)/2.;\n    \n    float drawing = 0.;\n    float time2 = floor(mod(time/2.,5.));\n    \n    if (time2 == 0.) {\n    drawing = gradient_linear(suv,point1,point2);\n    }\n    if (time2 == 1.) {\n    drawing = gradient_radial(suv,point1,point2);\n    }\n    if (time2 == 2.) {\n    drawing = gradient_angle(suv,point1,point2);\n    }\n    if (time2 == 3.) {\n    drawing = gradient_diamond(suv,point1,point2);\n    }\n    if (time2 == 4.) {\n    drawing = gradient_linedist(suv,point1,point2);\n    }\n    \n    fragColor = vec4(drawing,1.-((length(suv-point1)-0.01)*400.),1.-((length(suv-point2)-0.01)*400.),1.0);\n}","name":"","description":"","type":"image"}]}