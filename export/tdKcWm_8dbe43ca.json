{"ver":"0.1","info":{"id":"tdKcWm","date":"1603132333","viewed":78,"name":"BlinnPhongs","username":"emedan","description":"Test for BlinnPhong. Using Struct to easier manage different materials and lights. Slow with > 1 light source on laptop.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// BlinnPhong shading.\n// With a twist of shadow.\n//\n// Jon Bolmstedt 2020-10-19\n\nint NBR_LIGHT = 3;\t// 1-3.\n\n// Ray march to find object empirically.\n// Spherical algorithm, so it's only the qualifying short distance \n//   to find an object that affects performance.\n\n\n//  Ray marching parameters\n//  MAX_STEPS - Exit march regardless of finding an object.\t\n//                Does not affect performance much.\n//                Can be used for nice halo, because this code returns \"no object and no background\".\n//  SURF_DIST - Small distance to reach when object is found.\t\t\n//                Affects performance much.. need depends on geometry.\n//  MAX_DIST  - Far \"clipping plane\".\n//                Does not affect performance much.\n//                In this code \"background\" is returned when this distance is reached.\n//                Can make trippy 4D effects.\n#define MAX_STEPS 300\n#define SURF_DIST 0.01\n#define MAX_DIST 100.0\n\n#define pi 3.141593\n#define pi2 6.28318530718\n#define pi4 12.5663706144\n\nbool BLINN = true;\n\n\nstruct Material {\n    // Each type of reflected light can be given a separate tint.\n    vec3 ambCol;\t// Material color of reflected ambient light.\n    vec3 diffCol;\t// Material color of reflected diffuse light.\n    vec3 specCol;\t// Material color of reflected specular light.\n    \n    // Use the intensities to darken/brighten the defined light color.\n    float ambFac;\t// Material intensity modifier for ambient light.\t\n    float diffFac;\t// Material intensity modifier for diffuse light.\n    float specFac;\t// Material intensity modifier for specular light.\n\n    // How tight the glare is.\n    float shininess;// Material specular shininess.\n}; \n    \nstruct Light {\n    // A magical light source may not have the same color if it's diffused or reflected.\n    // But for normal light sources the colors are the same.\n    vec3 ambCol;\t// Light ambient color\n    vec3 diffCol;\t// Light diffuse color\n    vec3 specCol;\t// Light ambient color\n    \n    // Use the intensities to darken/brighten the defined light color.\n    float ambFac;\t// Light intensity modifier\n    float diffFac;\t// Light intensity modifier\n    float specFac;  // Light intensity modifier\n    \n    // Not here? Separate for PointLight, AreaLight and so on?\n    float power;\n    float falloffLinFac;\n    float falloffQuadFac;\n    vec3 pos;\n    float powerAtt;\t// Placeholder for calculation.\n    float dist;\t\t\t// Placeholder for calculation.\n}; \n\n\n// Possible light sources \nLight lights[4];\n    \n\n// Global list to simplify function returns.\nfloat objectDistances[10];\n\n\n// map from to, clamped\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n// Return rotation matrix\nmat3 rotate3dx(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        1, 0,  0, \n        0, c, -s,\n        0, s,  c\n    );\n}\nmat3 rotate3dy(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n         c, 0, s,\n         0, 1, 0,  \n        -s, 0, c\n    );\n}\nmat3 rotate3dz(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n\n// Signed, negative inside object\nfloat SDF_box(vec3 p, vec3 size, float rounding) {\n\tp = abs(p)-size;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - rounding;\n}\n\n\n// Signed, negative inside object\nfloat SDF_capsule(vec3 p, vec3 A, vec3 B, float r) {\n    vec3 AB = B-A;\n    vec3 AP = p-A;\n    \n    float t = dot(AB, AP) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    \n    //return length(p - (A + t*AB)) - r;\n    float tt = 2.0*abs(0.5 - t);\t// 1 .. 0 .. 1\n    tt = t;\n    return length(p - (A + t*AB)) -r + r*smoothstep(1.0, 0.0, pow(tt, 0.9));\n    \n    float s1 = length(p - (A + t*AB)) - r*smoothstep(1.0, 0.0, tt);\n    float s2 =  length(p - (A + t*AB)) - r*(1.0+1.0*pow((t-0.5), 2.0));\n    float s = 0.5*(1.0+sin(iTime));\n    s = 0.0;\n    return s*s1+(1.0-s)*s2;\n}\n\n\n//Signed, negative inside object.\nfloat SDF_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n\n// Get the distance from point p to the closest object of all objects in the scene.\n// Returns: distance, object index\n// Distance can be constrained to selected object.\nfloat GetDist(vec3 p, out int objIndex, in int objConstraint) {\n    // Reusable translation variable.\n    vec3 trans;\n    \n    // Sphere /////////////////////////////////////////\n    //vec4 sphere = vec4(2.*sin(iTime), 0, 10.+6.*cos(iTime), 2);\n    vec4 sphere;\n    sphere = vec4(0, 3, 4, 2.1);\n    float sdf_sphere = SDF_sphere(p, sphere.xyz, sphere.w);\n    //sdf_sphere = abs(sdf_sphere) - 0.05;\t// Shell\n\t///////////////////////////////////////////////////\n    \n    // A sphere above the light to make a lamp\n    float sdf_sphereLight = SDF_sphere(p, vec3(12.*sin(iTime/4.), 13, 12.*cos(iTime/4.) + 6.), 0.8);\n\tsdf_sphereLight = SDF_sphere(p, vec3(0, 15, 0), 0.8);\n    \n    // Capsule ///////////////////////////////////////\n\tvec3 cpA, cpB;\n    float cr;\n    cr = 0.85;\n\n    // Position object before rotating around world origo\n\t// Rotate around origo\n    float xang = iTime*0.6+pi/4.0;\n    float yang = iTime*0.3;\n    float zang = iTime*0.3+pi/3.0;\n    mat3 rot = rotate3dy(yang) * rotate3dx(xang) * rotate3dz(zang);\n    \n    float a = 1.0;\n    float b = 4.0;\n    vec3 cpA1 = vec3(a, 0, 0);\n    vec3 cpB1 = vec3(b, 0, 0);\n    vec3 cpA2 = vec3(-a, 0, 0);\n    vec3 cpB2 = vec3(-b, 0, 0);\n    vec3 cpA3 = vec3(0, a, 0);\n    vec3 cpB3 = vec3(0, b, 0);\n    vec3 cpA4 = vec3(0, -a, 0);\n    vec3 cpB4 = vec3(0, -b, 0);\n    vec3 cpA5 = vec3(0, 0, a);\n    vec3 cpB5 = vec3(0, 0, b);\n    vec3 cpA6 = vec3(0, 0, -a);\t\t\n    vec3 cpB6 = vec3(0, 0, -b);\n    vec3 baseT = vec3(0, 3, 4);\n    cpA1 *= rot;\n    cpB1 *= rot;\n    cpA2 *= rot;\n    cpB2 *= rot;\n    cpA3 *= rot;\n    cpB3 *= rot;\n    cpA4 *= rot;\n    cpB4 *= rot;\n    cpA5 *= rot;\n    cpB5 *= rot;\n    cpA6 *= rot;\n    cpB6 *= rot;\n    cpA1 += baseT;\n    cpB1 += baseT;\n    cpA2 += baseT;\n    cpB2 += baseT;\n    cpA3 += baseT;\n    cpB3 += baseT;\n    cpA4 += baseT;\n    cpB4 += baseT;\n    cpA5 += baseT;\n    cpB5 += baseT;\n    cpA6 += baseT;\n    cpB6 += baseT;\n    \n    \n    ///////////////////////////////////////////////////\n    float sdf_capsule1 = SDF_capsule(p, cpA1, cpB1, cr);\n    float sdf_capsule2 = SDF_capsule(p, cpA2, cpB2, cr);\n    float sdf_capsule3 = SDF_capsule(p, cpA3, cpB3, cr);\n    float sdf_capsule4 = SDF_capsule(p, cpA4, cpB4, cr);\n    float sdf_capsule5 = SDF_capsule(p, cpA5, cpB5, cr);\n    float sdf_capsule6 = SDF_capsule(p, cpA6, cpB6, cr);\n    \n    // Box ////////////////////////////////////////////\n    vec3 boxSize = vec3(0.7);\n    vec3 boxCenter = vec3(-6, 3., 6);\n    float boxRounding = 1.5;\n    float boxThickness = 0.05;\n    vec3 boxPos = p-boxCenter;\n    \n    // Mirror in x. Works because position contains marching point and box sdf function\n    //  is made for box at origo.\n    //boxPos.x = abs(boxPos.x); \n    //boxPos.x -= 4.;\t\t\t\t// Space mirrored out from original pos.\n    \n    float sdf_box = SDF_box(boxPos, boxSize, boxRounding);\n    //sdf_box = abs(sdf_box) - boxThickness;\t// Makes shell with thickness.\n    ///////////////////////////////////////////////////\n    \n    // Floor plane ////////////////////////////////////\n    float sdf_plane = p.y;\t//  flat and at y = 0.\n    sdf_plane = dot(p, normalize(vec3(0, 1, 0 )));\t// Tilt plane\n    sdf_plane += sin(p.x/4. +iTime/4.) /5.;\n    sdf_plane += sin(p.x/2. +iTime/2.) /7.;\n    sdf_plane += sin(p.x    +iTime/1.) /9.;\n\n    sdf_plane += sin(p.z/2. +iTime)    /3.;\n    sdf_plane += sin(p.z    +iTime*3.) /7.;\n    ///////////////////////////////////////////////////\n    \n    // Info about hit object.\n    int objIndexDist = 0;\n    float objLimit = SURF_DIST;\n\n    // Capsules + sphere\n    if      (sdf_capsule1   < objLimit) objIndexDist = 1;\n    else if (sdf_capsule2   < objLimit) objIndexDist = 2;\n    else if (sdf_capsule3   < objLimit) objIndexDist = 3;\n    else if (sdf_capsule4   < objLimit) objIndexDist = 4;\n    else if (sdf_sphere     < objLimit) objIndexDist = 5;\n    else if (sdf_capsule5   < objLimit) objIndexDist = 6;\n    else if (sdf_capsule6   < objLimit) objIndexDist = 7;\n\n    ///////////////////////////////////////////////////    \n    // Copy all distances to a global array\n    objectDistances[0] = sdf_capsule1;\n    objectDistances[1] = sdf_capsule2;\n    objectDistances[2] = sdf_capsule3;\n    objectDistances[3] = sdf_capsule4;\n    objectDistances[4] = sdf_sphere;\n    objectDistances[5] = sdf_capsule5;\n    objectDistances[6] = sdf_capsule6;\n\t    \n    // Return the distance to any object for this position p.\n    // The ray marcher will march until the distance is really small.\n    // Distance functions must be signed, and return negative value inside object.\n    //\n    // abs(object distance) - Creates shell. Distance will increase from edges.\n    //\n    // Using: \n    //  min(d1, d2)  - Ray will stop at closest to either one. Typical usage.\n    //  max(d1, d2)  - Ray point requires both d1 and d2 small. Will get the intersection.\n    //  max(-d1, d2) - Object 1 will cut out object 2.\n    float d = MAX_DIST;\n    \n    \n        \n    // Capsules + sphere\n    d = MAX_DIST;\n    d = min(d, sdf_capsule1);\n    d = min(d, sdf_capsule2);\n    d = min(d, sdf_capsule3);\n    d = min(d, sdf_capsule4);\n    d = min(d, sdf_capsule5);\n    d = min(d, sdf_capsule6);\n    d = min(d, sdf_sphere);\n\n    \n    // With object constraint, only give the distance to the selected object.\n    if (objConstraint > -1) {\n        d = MAX_DIST;\n        if      (objConstraint == 1) d = min(d, sdf_capsule1);\n        else if (objConstraint == 2) d = min(d, sdf_capsule2);\n        else if (objConstraint == 3) d = min(d, sdf_capsule3);\n        else if (objConstraint == 4) d = min(d, sdf_capsule4);\n        else if (objConstraint == 5) d = min(d, sdf_sphere);\n        else if (objConstraint == 6) d = min(d, sdf_capsule5);\n        else if (objConstraint == 7) d = min(d, sdf_capsule6);\n    }\n    \n    objIndex = objIndexDist;\n    return d;\n    //return vec2(d, float(objIndexDist));\n}\n\n\n// Ray march / sphere trace. Walk in ray direction, but the distance of the closest object.\n//  Guarantees to not oveshoot the second closest object.\n// Returns: distance to first hit object, hit object index, iterations\nvoid RayMarch(vec3 ro, vec3 rd, \n              out float dO, out int objIndex, out int iterations) {\n\t\n    // Distance from origin start 0 each loop\n    dO = 0.0;\n    float dS;\n    vec2 distResult;\n    int i;\n    for ( i=0; i<MAX_STEPS; i++ ) {\n        // Point marches along ray direction.\n        vec3 p = ro + dO*rd;\n        \n        // Check if the point is so close to a surface that it's a hit.\n        // GetDist returns (distance, object index)\n        dS = GetDist(p, objIndex, -1);\n        //dS = distResult.x;\n        \n        // March the length of closest distance, but in ray direction.\n        dO += dS; \n        \n        // Exit loop if hit object or too long distance.\n        if (abs(dS) < SURF_DIST || dO > MAX_DIST) {\n        \tbreak;\n        } \n    }\n    \n    //Outputs\n    //dO\n    //objIndex\n    iterations = i;\n    return;\n    //return; vec3(dO, float(objIndex), float(i));\n    //return vec3(dO, float(distResult.y), float(i));\t// Always return distance for when loop was exited.\n    // Return nbr of iterations for glow effect. Iteratons increase for rays passing close to objects. \n}\n\n\n// Approximate normal calculation. Uses GetDist to \"find\" the actual object.\n//  Needs p on object for relevant result.\n// The approximate surface of different objects is used if they are close.\n// Approxmation of normal can be constrained to surface of the object found at point p.\nvec3 GetNormal(vec3 p, bool useObjConstraint) {\n    int objConstraint;\n    int dummy;\n    float d =  GetDist(p, objConstraint, -1);\t// Since p is passed here, the distance to p is likely known.\n\tvec2 eps = vec2(0.01 ,0);\n    \n    if (!useObjConstraint) objConstraint = -1;\n    \n    // Get tangent plane\n    float xd =  GetDist(p + eps.xyy, dummy, objConstraint);\n    \n    float yd = GetDist(p + eps.yxy, dummy, objConstraint);\n    \n    float zd = GetDist(p + eps.yyx, dummy, objConstraint);\n    \n    // Normal?? Detta är väl planet?\n    // Det är normalen. Färglägger man blir planet grönt, dvs y = 1.\n    return normalize( vec3(xd, yd, zd) - d );\n}\n\n\n// Get the material properties for the selected object.\nMaterial GetMaterial(int objIndex) {\n    Material material;\n    \n    // Material constants\n    material.ambFac = 0.2;\n    material.diffFac = 1.0;\n    material.specFac = 1.0;\n    material.shininess = 4.0;\n    \n    // Material colors\n    material.ambCol = vec3(0);\t\t\t\t// Init to 0 if no object found for debug.\n    material.specCol = vec3(1, 1, 0.6);\n\n    if (objIndex == 1) { \n        material.diffCol = vec3(1, 0, 0);\n        material.specFac = 3.;\n\t    material.shininess = 4.;\n    }\n    else if (objIndex == 2) { \n        material.diffCol = vec3(0, 1, 0);\n        material.specFac = 3.;\n\t    material.shininess = 8.;\n    }\n    else if (objIndex == 3) {\n\t\tmaterial.diffCol = vec3(0, 0, 1);\n        material.specFac = 3.;\n\t    material.shininess = 16.;\n    }\n    else if (objIndex == 4) {\n        material.diffCol = vec3(1, 0, 1);\n        material.specFac = 3.;\n\t    material.shininess = 32.;\n    }\n    else if (objIndex == 5) {\t// Sphere\n        material.diffCol = vec3(1, 1, 1);\n        material.specFac = 3.;\n\t    material.shininess = 8.;\n    }\n    else if (objIndex == 6) {\n        material.diffCol = vec3(1, 1, 0);\n        material.specFac = 3.;\n\t    material.shininess = 32.;\n    }\n    else if (objIndex == 7) {\n        material.diffCol = vec3(0, 1, 1);\n        material.specFac = 3.;\n\t    material.shininess = 32.;\n    }\n    \n    material.ambCol = material.diffCol;\t\t// Make the same. \n    \n    if (BLINN) {\n    \tmaterial.shininess *= 3.5;\t// For BlinnPhong compared to Phong.\n    }\n    return material;\n}\n\n\nvec3 BlinnPhong(vec3 p, int objIndex, vec3 ro) {\n    vec3 v_N = GetNormal(p, true);\t\t// Normal\n\n    // Define light sources ///////////////////////////////\n    // Point light\n    lights[0].ambCol = vec3(1);\n    lights[0].diffCol = vec3(1);\n    lights[0].specCol = vec3(1);\n    lights[0].ambFac = 0.4;\n    lights[0].diffFac = 1.0;\n    lights[0].specFac = 1.0;\n    lights[0].power = 2500.0 / float(NBR_LIGHT);\n    lights[0].falloffQuadFac = 12.56637;\n\n    lights[0].pos = vec3(10.0, 25, -5);\n    lights[0].dist = length(lights[0].pos - p);\n\tlights[0].powerAtt = lights[0].power/(lights[0].falloffQuadFac*pow(lights[0].dist, 2.0));\n    \n    \n    lights[1] = lights[0];\n\tlights[1].pos = vec3(-8, 15, 4);\n    lights[1].dist = length(lights[1].pos - p);\n\n    lights[2] = lights[0];\n\tlights[2].pos = vec3(0, 15, 20);\n    lights[2].dist = length(lights[2].pos - p);\n    \n    // Ambient should probably be treated outside lights. An approximated value anyway.\n    for (int i = 0; i < NBR_LIGHT; i++) {\n    \tlights[i].ambFac /= float(NBR_LIGHT);\n    }\n\n    \n    // Get material properties ////////////////////////////\n    Material material = GetMaterial(objIndex);\n    ///////////////////////////////////////////////////////\n    \n    \n    // Calculate contribution of all light sources ////////\n    // But not material colors.\n    vec3 ambientSum = vec3(0);\t\t// Combined contribution from all lights.\n    vec3 diffuseSum = vec3(0);\t\t// Combined contribution from all lights.\n    vec3 specularSum = vec3(0);\t// Combined contribution from all lights.\n    for (int i = 0; i < NBR_LIGHT; i++) {\n        Light light = lights[i];\n\n        // Vectors ////////////////////////////////////////////\n        vec3 v_L = normalize(light.pos - p);     // From point to light (depends on type of light).\n        vec3 v_R = reflect(-v_L, v_N);  \t// Reflected light in normal\n        vec3 v_V = normalize( ro - p );\t\t// View direction\n        vec3 v_H = normalize(v_L + v_V); \t// Halfway direction - Blinn.\n\n        float dotLN = dot(v_N, v_L);\n        ///////////////////////////////////////////////////////\n\n        // Ambient\n        vec3 ambient = light.ambCol * light.ambFac * material.ambFac;\n\n        // Diffuse \n        float diff = max(dotLN, 0.0);\n        vec3 diffuse = diff * light.powerAtt * light.diffCol * light.diffFac * material.diffFac;\n\n        // Specular\n        float spec;\n        spec = pow(max(dot(v_V, v_R), 0.0), material.shininess);\t// Phong\n        if (BLINN) {\n            spec = pow(max(dot(v_N, v_H), 0.0), material.shininess);\t// Blinn\n        }\n        vec3 specular = spec * light.powerAtt * light.specCol * light.specFac * material.specFac;\n        \n        \n        // Additional shading. Not Blinn or Phong.\n        // Add ambient occlusion where dot L N is -1, and the diffuse part is already 0.\n        // This will make the core shadow darker. Sort of the same as adding diffuse light\n        //  all the way round.\n        // Material parameter?\n        // An opposite would also be interesting - to lead the diffuse light further around,\n        //  as if the material conducts light on the surface.\n        float M_da = 0.7;\t// Reduction of ambient light in the shadow. 1 = no reduction.\n        ambient *= M_da * (1.0 + clamp(dotLN, -1.0, 0.0));\n        \n        \n        // Add more shadows if no path to light source from point p.  //////////\n        // This causes extra ray march. Approximation.\n        // Go from point towards light. If hit an object first - no light path.\n        //  But start a little bit above the surface of p.\n        // Must shadow a point by its own object or else a strange gradient comes.\n        float dShadowObject;\n        int dummy_iterations;\n        int shadowindex;\n        const float SHADOW_FO = 2.5;\t// Falloff\n        RayMarch(p + 3.0*SURF_DIST*v_N, v_L, \n                 dShadowObject, shadowindex, dummy_iterations);\n        bool inShade = dShadowObject < light.dist + SURF_DIST;\n        bool selfShade = inShade && shadowindex == objIndex;\n        if (inShade) {\n            // Point is affected by shadow.\n            float sf = clamp(M_da*dShadowObject/SHADOW_FO, 0.0, 1.0);\n            sf = pow(sf, 2.0);\n            diffuse *= sf;\n            specular *= pow(sf, 1.1);\n        }\n        //if (selfShade) { I_ambient = vec3(1); I_diffuse = vec3(1); } // Debug\n        //if (inShade && !selfShade) { I_ambient = vec3(0); I_diffuse = vec3(0); } // Debug\n        ////////////////////////////////////////////////\n        \n        // Totalize contribution of this light\n        ambientSum += ambient;\n        diffuseSum += diffuse;\n        specularSum += specular;\n    }\n    ///////////////////////////////////////////////////////\n    \n \n    return ambientSum * material.ambCol + \n           diffuseSum * material.diffCol + \n           specularSum * material.specCol;\n    \n}\n\n\n// Ambient occlusion affect objects close to each other.\n// It's an simplification. \n//  Don't detect the object intersect edge, but should shadow narrow angles more.\n//  Improve by using normal of the other object. How to get that?\nfloat AO(vec3 p, int objIndex) {\n    // Point p is on the surface of object[objIndex], so the distance to other objects\n    //  will be from this.\n    // But when objects intersect the distance will be wrong - it should be only distances\n    //  to visible parts. Can the GetDist / RayMarch also return p of all other distances, and\n    //  not only the p of the \"found\" object?\n    float ao, ao_sum = 0.0;\t\t\t// 0: No ao at all\n    const int NBR_RODS = 6;\n    const int sphereIndex = 5;\n    const float d_fo = 0.3;\t\t// 0..r Fall off distance\n    const float ao_max = 0.8;\t// 0..1 Maximum amount of ao \n    \n    // Make sure global distance variables are updated. XXX now it starts becoming unnecessary (costly).\n    int dummy_index;\n    GetDist(p, dummy_index, -1);\n    \n    // Point is on the sphere.\n    if (objIndex == sphereIndex) {\n        // Move the rod distances to array for iteration possibility.\n        float rd[NBR_RODS];\n        rd[0] = objectDistances[0];\n        rd[1] = objectDistances[1];\n        rd[2] = objectDistances[2];\n        rd[3] = objectDistances[3];\n        rd[4] = objectDistances[5];\n        rd[5] = objectDistances[6];\n\n        // Shadow depending on the distance to each rod.\n        for (int i = 0; i < NBR_RODS; i++) {\n            // Normalize distance between 0..1\n            float d = clamp(rd[i] / d_fo, 0.0, 1.0);\n            \n            // Calculate ao based on distance function.\n            ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n            //ao = 0.3*d;\n            \n            // Add to existing ao with a reduction factor.\n            ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0);\n        }\n    }\n    else {\n    \t// Point is on a rod.\n        // Normalize distance between 0..1\n        float d = clamp(objectDistances[4] / d_fo, 0.0, 1.0);\n\n        // Calculate ao based on distance function.\n        ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n        //ao = 0.3*d;\n\n        // Add to existing ao with a reduction factor. Will matter when several nearby objects\n        //  contribute to the same occlusion.\n        ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0); \n    }\n    \n    return 1.0 - min(ao_sum, ao_max);\n}\n\n\n// Sky color\nvec3 skyColor(vec2 uv) {\n    // 077b88 = \n    // 9dc6ca = \n\tvec3 col; \n    col = mix(vec3(0.615, 0.776, 0.792), vec3(0.027, 0.482, 0.533), 2.0*sqrt(abs(uv.y)));\n    \n    // Lighten middle, darken out. Multiply with > 1.\n    col *= mix(vec3(2), vec3(1), 2.0*pow(abs(uv.y), 0.25));\n        \n    col = pow( clamp(col,0.0,1.0), vec3(2.2) );\t// Inverse gamma bc sky color was chosen from palette.\n\treturn col;\n}\n\n// Render the point of the ray\n// returns: vec3 color, object index, object distance\nvec3 Render(vec3 ro, vec3 rd, vec2 uv,\n            out int objIndex, out float d) {\n    \n    // Ray march in direction for this uv-coordinate / screen pixel.\n    int raySteps;\n    RayMarch(ro, rd, \n             d, objIndex, raySteps);\t// Returns (distance, object index, ray iterations)\n    \n    // Light and color for the intersected point.\n    // Don't do color calculations if there was no hit.\n    vec3 col = vec3(1);\n    if (d < MAX_DIST) {\n        vec3 p = ro + d*rd;\n        col = BlinnPhong(p, objIndex, ro);\n\n        // Ambient occlusion \n        col *= AO(p, objIndex);\n\n        // Use the nbr of marched steps for glow.\n        //if (objIndex > 1) {\n        //    float stepF = float(raySteps)/float(MAX_STEPS); \n        //    difCol += (pow(stepF*10., 2.0)*1.);   \n        //}\n\n        // Do not shade the light ball\n        //if (objIndex == 5) col = vec3(1, 1, 0);\n    }\n    else {\n        // Background. Remove anything when marcher did not reach because of distance.\n        col = skyColor(uv);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rescale x so a circle looks like a circle, and move to new center.\n    // uv.y: -0.5 .. 0.5\n    // uv.x: ( -0.5 .. 0.5 ) * aspect ratio.\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera ////////////////////////////////////////////////////////////\n    // Camera ray origin, ray direction, ro, rd\n    // x, y view plane and z is depth.\n    vec3 ro;\n\n    // Camera ray direction - look from origin in the direction of each screen pixel.\n    // XXX - Är det ortogonal view genom att sätta x, y, 1 alltid. Nej...\n\tvec3 rd;\n    \n    // Pixel color for what the ray hit.\n    vec3 col;\n    \n    // Camera ray origin\n    ro = vec3(0, 4, -8);\t\n\n    // Camera ray direction\n    rd = normalize( vec3(uv.x, uv.y-0.1, 1) );\n    //////////////////////////////////////////////////////////////////////\n\n    // Cast original ray\n\tvec2 uvorg = uv;\n            \n    // Render what the ray hits.\n    int objIndex;\n    float dist;\n    col = Render(ro, rd, uvorg,\n          objIndex, dist);  // Color of hit point\n    \n    \n    // Focus blur /////////////////////////////////////\n    float fact;\n    fact = 700.0;\t// Use 700 for good AA.\n\n    float range = 0.5;\n    float fp = 4.5;\n    fact =  clamp(pow(abs(dist-fp), 3.2), 20.0, 700.0);\n    ///////////////////////////////////////////////////\n    \n    \n    // Calculate distance\n    //XXXvec3 p = GetDist();\n    //float centerDist = p.z-ro.z;\t// Orthogonal distance to object from camera.\n    //if (objIndex1 == 0) centerDist = MAX_DIST;\n    \n    // Cast ray\n    // How to calculate backwards from uv into a ray direction?\n    // Seems better than to ray with small angular difference.\n\n    // Anti-aliasing - sample 4 points (or perhaps only affect when point is on object edge).\n    // 4 sample is just blur everywhere.\n    // \n    \n    // Procesing saving algorithm for at least few objects:\n    //  Cast the ray.\n    //  If ray hits an object\n    //    Cast the AA rays.\n    //    Optional:\n    //    Blur only if one or more AA ray does not hit object. Prevents pure object internal blur.\n    //\n    // Rays cast: 1 per \"normal cast\". 5 per normal cast that hits an object.\n    \n    // And AA only on \"edge between objects\" but not \"edges within the same object\"\n    //  Cast the ray\n    //  If ray hits Object obj at Point p:\n    //    Calculate a new point pp that is a small view angle in the normal direction of p\n    //     Point pp distance from p depends on camera and perspective transform.\n    //    Cast a ray towards pp\n    //      If ray does not hit obj:\n    //        Blur color of p with whatever color was found in direction of pp.\n    //\n    // Rays cast: 1 per \"normal cast\". 2 per normal cast that hits an object.\n\n    // AA 2 is 4 passes. Costs.\n    #define AA 2\n    \n    // Mouse top half - no AA\n    // Mouse lower left - fixed blur\n    // Mouse lower right - variable blur.\n    bool useAA = (iMouse.y/iResolution.y < 0.5);\n    \n    // Don't cast additional AA rays unless the first ray hit an object.\n    //useAA = useAA && objIndex > 0;\t// XXX Have to or edge can be missed. Blur avoided by not blurring if all points was on object.\n\n\tvec3 tot = vec3(0.0);\t// Summary of all render passes.\n    int m, n;\n    int samples = 0;\n    bool allPointsOnObject = true;\n    for( m=0; m<AA; m++ ) {\n        for( n=0; n<AA; n++ ) {\n            // How to calculate backwards from uv into a ray direction?\n            // Seems better than to ray with small angular difference.\n            vec2 uvorg = uv;\n            \n            // Create offset for the cast ray.\n            vec2 of = vec2(m, n) - 0.5;\n            of /= fact;\n\t\t\t\n            // Modify camera ray direction a little for each AA pass.\n            rd = normalize( rd + vec3(of.x, of.y, 0) );\n\n            // Render what the ray hits.\n            int objIndexOld = objIndex;\n            float distDummy;\n            vec3 col = Render(ro, rd, uvorg,\n                              objIndex, distDummy);  // Color of hit point\n\n \t\t\t// accumulate for AA\n            tot += col;\n            samples++;\n            allPointsOnObject = allPointsOnObject && objIndexOld == objIndex;\n  \t    }        \n    }\n    if (useAA && true) {//!allPointsOnObject) {\n    \tcol = tot / (float(samples));\n    }\n    \n    //if (dist < 7.5) col*= 0.0;\n            \n\n\n    // hdr->ldr tonemap (iniqo)\n    col = col*1.6/(1.0+col);\n    col = col*col*(3.0-2.0*col);\n\n    // Gamma\n    col = pow( clamp(col,0.0,1.0), vec3(1.0 / 2.2) );\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}