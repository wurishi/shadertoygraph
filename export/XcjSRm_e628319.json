{"ver":"0.1","info":{"id":"XcjSRm","date":"1706378190","viewed":84,"name":"Dead Reckoning","username":"Dudeguy18","description":"Dead Reckoning:\n\n* Entity will smooth towards packet trajectory (green) from last extrapolated trajectory (red)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["deadreckoning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Trajectory\n{\n  // Packet Data\n  float receive_time;\n  vec3 color;\n  \n  // Trajectory Data\n  float timestamp;\n  vec2 pos;\n  vec2 vel;\n  vec2 acc;\n};\n\nstruct Entity\n{\n  Trajectory A;\n  Trajectory B;\n  Trajectory extrap;\n  float dr_time;\n};\n\nvoid drawDot(inout vec4 canvas, vec2 uv, vec2 pos, float rad, vec3 color) \n{\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\tvec4 layer = vec4(color, 1.0 - t);\n    canvas = mix(canvas, layer, layer.a);\n}\n\nvoid drawTick(inout vec4 canvas, vec2 uv, vec2 pos, vec2 dim, vec3 color) \n{\n\tfloat a = 0.0;\n    vec2 center = pos - uv;\n    \n    if(uv.x > pos.x - dim.x && \n       uv.x < pos.x + dim.x &&\n       uv.y > pos.y - dim.y &&\n       uv.y < pos.y + dim.y)\n    {\n       a = 1.0;\n    }\n       \n\tvec4 layer = vec4(color, a);\n    canvas = mix(canvas, layer, layer.a);\n}\n\nvoid drawTrajectory(inout vec4 canvas, vec2 uv, Trajectory t, vec3 color)\n{\n  drawDot(canvas, uv, t.pos, 6.0, color);\n  for(float i = 0.1; i < 4.96; i = i + 0.06)\n  {\n    vec2 pos = t.pos + t.vel * i + 0.5 * t.acc * i * i;\n    drawDot(canvas, uv, pos, 1.0, color);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Entity\n    Entity entity;\n    \n    entity.A.timestamp = 0.0;\n    entity.A.pos = vec2(0.0, iResolution.y/2.0);    // Initial Trajectory\n    entity.A.vel = vec2(100.0, 0.0);\n    entity.A.acc = vec2(0.0, 40.0);\n    \n    entity.B.timestamp = entity.A.timestamp;\n    entity.B.pos = entity.A.pos;\n    entity.B.vel = entity.A.vel;\n    entity.B.acc = entity.A.acc;\n    \n    entity.extrap.timestamp = entity.A.timestamp;\n    entity.extrap.pos = entity.A.pos;\n    entity.extrap.vel = entity.A.vel;\n    entity.extrap.acc = entity.A.acc;\n    \n    \n    \n    // Packets\n    const int num_packets = 3;\n    Trajectory packets[num_packets];\n    \n    packets[0].receive_time = 1.0;\n    packets[0].timestamp = 1.0;\n    packets[0].pos = vec2(100.0, iResolution.y/4.0 * 3.0);\n    packets[0].vel = vec2(100.0, 0.0);\n    packets[0].acc = vec2(0.0, -40.0);\n    packets[0].color = vec3(0.25, 0.25, 0.25);\n    \n    packets[1].receive_time = 4.0;\n    packets[1].timestamp = 4.0;\n    packets[1].pos = vec2(400.0, iResolution.y/4.0 * 1.0);\n    packets[1].vel = vec2(100.0, 0.0);\n    packets[1].acc = vec2(0.0, 40.0);\n    packets[1].color = vec3(0.5, 0.5, 0.5);\n    \n    packets[2].receive_time = 7.0;\n    packets[2].timestamp = 7.0;\n    packets[2].pos = vec2(700.0, iResolution.y/4.0 * 3.0);\n    packets[2].vel = vec2(100.0, 0.0);\n    packets[2].acc = vec2(0.0, -40.0);\n    packets[2].color = vec3(0.75, 0.75, 0.75);\n\n\n    // Simulation Config\n    float frame_time = 0.5;\n    int num_frames = int(iTime * 1.0 + 1.0);\n    float smooth_frame_count = 3.0;\n    \n    // Setup\n    vec2 uv = fragCoord.xy;\n    vec4 canvas = vec4(0.4, 0.0, 0.0, 1.0);\n    float time = 0.0;\n    float T = 1.0;\n    int first_valid_packet = 0;\n    float smoothing_rate = frame_time / smooth_frame_count;\n    \n    \n    \n    for(int frame_id = 0; frame_id < num_frames && iTime < 20.0; frame_id++)\n    {\n      // ----------  processPackets  ----------\n      for(int packet_id = first_valid_packet; packet_id < num_packets; packet_id++)\n      {\n        // Check if Packet has been received\n        if(time >= packets[packet_id].receive_time)\n        {\n          // Throw away packets that are older than last received packet\n          if(packets[packet_id].timestamp >= entity.extrap.timestamp)\n          {\n            // Trajectory A - Becomes last extrapolated position\n            //                a_dt = time - dr_time\n            entity.A.timestamp = entity.dr_time;\n            entity.A.pos       = entity.extrap.pos;\n            entity.A.vel       = entity.extrap.vel;\n            entity.A.acc       = entity.extrap.acc;\n            entity.A.color     = entity.extrap.color;\n            \n            // Trajectory B - Becomes packet trajectory\n            //                b_dt = time - entity.B.timestamp\n            entity.B.timestamp = packets[packet_id].timestamp;\n            entity.B.pos       = packets[packet_id].pos;\n            entity.B.vel       = packets[packet_id].vel;\n            entity.B.acc       = packets[packet_id].acc;\n            entity.B.color     = packets[packet_id].color;\n            \n            // Received new packet - blend from Trajectory A to Trajectory B\n            T = 0.0;\n          }\n          \n          // Remove packet from list\n          first_valid_packet++;\n        }\n      }\n      // --------------------------------------\n      \n      \n      \n      // ----------  Dead Reckon ----------    https://en.wikipedia.org/wiki/Dead_reckoning\n      // Calculate T\n      T = clamp(T + smoothing_rate, 0.0, 1.0);\n    \n      // Calculate Trajectory Times\n      float a_dt = time - entity.A.timestamp;\n      float b_dt = time - entity.B.timestamp;\n      \n      // Blend Accelerations\n      entity.extrap.acc = entity.A.acc + (entity.B.acc - entity.A.acc) * T;\n      \n      // Calculate both trajectories instantaneous velocity and blend\n      vec2 A_vel = entity.A.vel + entity.A.acc * a_dt;\n      vec2 B_vel = entity.B.vel + entity.B.acc * b_dt;\n      entity.extrap.vel = A_vel + (B_vel - A_vel) * T;\n      \n      // Calculate extrapolated position on each trajectory and blend\n      vec2 Pt_A = entity.A.pos + entity.A.vel * a_dt + 0.5 * entity.A.acc * a_dt * a_dt;  // Extrap on A at dt\n      vec2 Pt_B = entity.B.pos + entity.B.vel * b_dt + 0.5 * entity.B.acc * b_dt * b_dt;  // Extrap on B at dt\n      entity.extrap.pos = Pt_A + (Pt_B - Pt_A) * T;                                            // Blend A & B pos\n      \n      // Mix color\n      entity.extrap.color = mix(entity.A.color, entity.B.color, 0.5);\n      \n      // Store Dead Reckon Time in timestamp\n      entity.dr_time = time;\n      // ----------------------------------\n      \n      \n      \n      // ----------  Draw  ----------\n      canvas = vec4(0.0, 0.0, 0.0, 1.0);\n      // Grid\n      for(float i = 0.0; i <= iResolution.x; i = i + 100.0)\n      {\n        drawTick(canvas, uv, vec2(i, 100.0), vec2(1.0, iResolution.y) ,vec3(0.3, 0.3, 0.3));\n      }\n      // Frame\n      drawTick(canvas, uv, vec2(time * 100.0, 20.0), vec2(1.0, iResolution.y), vec3(0.8, 0.8, 0.8));\n      // Trajectory A Info\n      drawTrajectory(canvas, uv, entity.A, vec3(1.0, 0.0, 0.0));\n      drawTick(canvas, uv, Pt_A, vec2(20.0, 2.0), vec3(1.0, 0.0, 0.0));\n      // Trajectory B Info\n      drawTrajectory(canvas, uv, entity.B, vec3(0.0, 1.0, 0.0));\n      drawTick(canvas, uv, Pt_B, vec2(20.0, 2.0), vec3(0.0, 1.0, 0.0));\n      // T\n      //drawTick(canvas, uv, vec2(T * 800.0, 40.0), vec2(4.0, 20.0), vec3(1.0, 1.0, 0.0));\n      // Extrapolated Position\n      drawDot(canvas, uv, entity.extrap.pos, 10.0, vec3(0.0, 0.0, 1.0));\n      drawTrajectory(canvas, uv, entity.extrap, vec3(0.0, 0.0, 1.0));\n      // ----------------------------\n      \n      \n      \n      // Step time\n      time = time + frame_time;\n    }    \n    \n    // Set Frag Color\n    fragColor = canvas;\n}","name":"Image","description":"","type":"image"}]}