{"ver":"0.1","info":{"id":"3ldXWS","date":"1581701101","viewed":453,"name":"Cheese Sniffer","username":"spalmer","description":"help the mouse find the cheese.  rewind toy to try again.  Big thanks to [url]https://shadertoy.com/user/ttg[/url] and [url]https://shadertoy.com/user/FabriceNeyret2[/url]!","likes":35,"published":1,"flags":48,"usePreview":0,"tags":["maze","pathfind","dijkstra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a small demo of using \n// simple Dijkstra fields\n// for pathfinding purposes.\n\n// You don't know what a Dijkstra field is?\n// Or what it may be good for?  Read this:\n// http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps\n// it's like an Eikonal field, but simpler.\n// So I won't get into those here.\n\n#define BufferA iChannel0\n\nconst float scale = 12.; //8.; //1.; //2.; //4.; //\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n    return (s - .5 * r) / scale; // fabrice-ish\n}\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    c = vec4(1);\n\tvec4 qh = MiscData // hunger in z\n\t, mh = MouseData // mouse old loc in xy new loc in zw\n    , vh = ViewData; // slow in xy, fast in zw\n    float tf = fract(iTime*tickrate); //fract(qh.w); is jerky?!\n    vec2 s = mh.zw; // mouse loc - jerky \n    s = mix(mh.xy, s, tf); // smooth\n    vec2 q = mix(vh.xy, vh.zw, 2.5); // ttg - super smooth predict camera - ignore tf here\n    ivec2 r = ivec2(R)\n    , i = ivec2(q + StoQ(p, R))\n    , ic = clamp(i, ivec2(2), r-2)\n    // fabrice - smell range past fake inset border clip (ttg's idea)\n    , ie = abs(ic-i);\n    float smellrange = float(ie.x+ie.y);\n    i = ic;\n    // FIXME the maze itself is aliasy btw, when it scrolls\n \tvec4 m = MazeData(ic); // playfield\n    smellrange += m.y;\n    const float stinkdissipate = 64.; // exponent tuned so can't see trail until close\n    float smell = pow(max(0., 1.-smellrange/maxrange), stinkdissipate)\n    , s1 = max(m.z, smell*.25);\n    c.rgb = vec3(s1, max(s1,m.x), m.x); // colorize walls, cheese, smell together\n    vec2 mq = .5*R - p - (q - s) * scale; // mouse relative pixels\n    float msize = mix(.25, .75, pow(clamp(.5 - qh.z/maxhunger, 0., 1.), 2.))\n    , md = length(mq) - msize * scale; // body disc\n    vec2 mdir = (mh.zw - mix(mh.xy, vh.zw, .4)) + .025 * (vh.zw - vh.xy);\n    mdir += .4 * sin(iTime * 8. + vec2(0,1.57));\n    if (dot(mdir,mdir) > .5) { // not quite a tail yet; wip nub indicates facing, mostly\n        mdir = normalize(mdir);\n        md = min(md, distance(mdir * msize * scale, mq) - .2*scale);\n    }\n\tfloat mc = .5 - md; // aa coverage \n    c.rgb = mix(c.rgb, vec3(1,.3,.1), clamp(mc, 0., 1.)); // mouse\n    c = vec4(pow(c.rgb, vec3(.4545)), 1); // output srgb gamma\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n\nconst float maxrange = 2048.; // of smell\nconst float maxhunger = 2048.; // goes from - to + so that will start halfway at 0\nconst float cheesefood = 1700.; // cheese satiation factor\nconst float tickrate = 18.; // controls motion speed - ticks per second\n\nconst int // data pixel index BufferA on row 0\n  dataMisc   = 0 // xy=window resolution, z=hunger, w=iTime*tickrate\n, dataMouse  = 1 // xy=smooth mouse old location, zw=new pos\n, dataView   = 2 // xy=smoother, zw=smoothed camera pos\n, dataCount  = 3 // how many data pixels total?\n; // it has gotten complicated; this is why we document.\n\n#define MazeData(i) texelFetch(BufferA, i, 0)\n#define MiscData    MazeData(ivec2(dataMisc  ,0))\n#define MouseData   MazeData(ivec2(dataMouse, 0))\n#define ViewData    MazeData(ivec2(dataView,  0))\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this is for the maze (x component 0 or 1=wall)\n// and the odor/dijkstra field (y component = taxicab metric distance to cheese)\n// and cheese (z component > 0)\n// but also there are a few special pixels:\n// pixel at (0,0) is the resolution pixel (in .xy) also hunger in z, ticker in w\n// to detect window size changes / fullscreen mode\n// and the pixel at (1,0) .zw is the player (mouse) location (old/new)\n// also view pixel at (2,0).  See Common tab for data slot details.\n\n#define BufferA  iChannel0\n#define Keyboard iChannel3\n\nmat4 neighbors(ivec2 p)\n{\n     ivec2 x = ivec2(1,0), y = x.yx; // there :) ftfy\n     return mat4(\n         MazeData(p + x)\n       , MazeData(p + y)\n       , MazeData(p - x)\n\t   , MazeData(p - y)\n     );\n} // simply texelFetching\n\nfloat key(int k)\n{\n    return step(.5, texelFetch(Keyboard, ivec2(k,0), 0).x);\n}\n\nvoid LogicMouse(inout vec4 c) // c IS MouseData()\n{\n    ivec2 q = ivec2(c.zw); // mouse loc\n    mat4 s = neighbors(q);\n    vec4 s0 = MazeData(q) // playfield\n\t, S = transpose(s)[1]; // slice y column\n    // walks upwind automatically\n    // toward the cheese gradient direction\n\t// only follow upwind; don't avoid lack of cheese downwind\n    // because walls will appear absolutely toxic if we do.\n    // sniff gradient of cheese odor (measure derivative of dijkstra field)\n    S = min(S, s0.y); vec2 g = .5 * (S.zw - S.xy); // thanks Fabrice!\n\t// if doesn't know which way to go - to help prevent getting stuck, and for character\n  //  if (s0.y > 50. || mod(iTime,4.) < .2) // once he picks up a strong enough trail, he knows precisely which way to go - unless he gets really stuck, he still jitters occasionally\n  //  g += .81 * sin(1.5*iTime) * sin(vec2(0,1.57)*.3*iTime); // add jittery motion - seems like he pauses, stops & sniffs, looks around, thinks?  occasionally makes wrong turn\n    g *= abs(sin(1.3*iTime)*sin(.7*iTime)) + 1./(s0.y+1.); // random pauses\n    // keyboard control - arrow keys\n    g += 4. * vec2(key(39) - key(37), key(38) - key(40));\n    if (dot(g,g) > 1e-2)\n    \tg = normalize(g);\n    q += ivec2(round(g));\n    vec4 u = MazeData(q); // new loc cell\n    if (u.x == 0.) { // not blocked?\n    \tc.xy = c.zw;\n        c.zw = vec2(q) + .5; // output loc to data pixel\n    }\n}\n\n// runs each frame for camera view pixel\nvoid LogicView(inout vec4 c, vec4 r, vec4 m)\n{ \n    c = mix(m.zwzw, c, exp2(-vec4(2,2,4,4)*iTimeDelta)); // putted by fabrice!\n    // ttg's way but with framerate independence?\n    // not tuned identically but close enough\n    // like he says, probably wouldn't have noticed \n    // much 144 vs 60 anyway because iTimeDelta is so small \n    // and the limit trends to linear anyway.\n    // But this should be perfectly framerate independent,\n    // to the precision of the browser clock anyway!\n}\n\n// c = maze data\n// i = pixel\n// r = res data\nvoid LogicField(inout vec4 c, ivec2 i, vec4 r, vec4 m)\n{\n    if (c.z > 0.) { // cheese here? most cells don't care about mouse\n        ivec2 q = ivec2(m.xy); // mouse for ttg eating\n        if (all(lessThan(abs(i-q), ivec2(2)))) c.z = 0.; // cheese eaten\n        else c.y = 0.; // strongest smell at 0 distance\n    } else { // exude dijkstra field from cheese\n        mat4 n = neighbors(i);\n        c.y = min(maxrange, min(min(n[0],n[1]), min(n[2],n[3])).y + 1.);\n        // +1 makes smell dissipate once a cheese is removed\n    }\n}\n\n// resolution, satiation, timing\nvoid LogicMisc(inout vec4 c, vec4 m)\n{\n    c.xy = R;\n    ivec2 q = ivec2(m.zw); // mouse loc\n\tvec4 s0 = MazeData(q); // playfield\n\tif (s0.y < 3.0 // cheese within nibbling distance?\n        //|| u.z > 0. // cheese there?!!\n        )\n        c.z = max(-maxhunger, c.z - cheesefood); // CHEEEZ!\n    else\n        c.z += 5.; // hungrier\n    // cheese removal in LogicField!\n    // Image tab shows mouse size based on hunger.\n    // starving checked in BufferA mainImage.\n    c.w = iTime * tickrate; // ticks and fraction thereof\n}\n\n// c = buffer data\n// i = pixel\n// r = res data\n// m = mouse data\nvoid Tick(inout vec4 c, ivec2 i, vec4 r, vec4 m)\n{\n\tc = MazeData(i); // passthru prior state\n    if (i.y == 0) { // entire row is border or data pixels\n        // ttg - filter view each frame!\n        if (i.x == dataView)\n            LogicView(c, r, m);\n        // had to store my own time state\n        // to avoid iTimeDelta problems in previews\n        if (int(r.w) == int(iTime * tickrate)) return;\n        // only tick mouse periodically\n        switch (i.x) {\n            case dataMisc:  LogicMisc(c, m); break;\n            case dataMouse: LogicMouse(c); break;\n        }\n    } else if (c.x == 0.) // walls do nothing.  otherwise:\n        LogicField(c, i, r, m);\n}\n\n// I get a lot of mileage out of Fabrice's maze snippet\n// https://www.shadertoy.com/view/lt2cRR\nfloat mazeFabrice(vec2 p)\n{\n\treturn mod(p[int(1e4*length(ceil(p/4.)))&1], 4.) >= 1. ? 0. : 1.;\n}\n\nvoid Init(inout vec4 c, ivec2 i)\n{\n    c = vec4(0); // init\n    if (i.y == 0 && i.x < dataCount) { // data pixels?\n        vec2 v = .5*R + 2.;\n        switch (i.x) {\n            case dataMisc: c.xy = R; break;\n            case dataMouse: \n            case dataView: c = v.xyxy; break;\n        }\n    } else {\n\t    ivec2 r = ivec2(R)\n        , o = min(i,r-i)\n        , e = abs(r/2+2-i); // yep, mo' better; for hallway\n        int border = min(o.x,o.y);\n        // ttg: maze border\n        if (border < 2)\n            c.x = 1.; // make wall\n        // ttg: corridor around edge of maze\n        // so mouse can access more cheeses.\n        else if (border < 4 \n            || (e.x < 2 && e.y < r.y/3)) // hallway split - Fabrice style\n            c.x = 0.; // clear wall\n        else\n\t    \tc.x = mazeFabrice(vec2(i + ivec2(int(iDate.w/50.) & 124, 0)));                \n        // otherwise z should be nonzero if there's cheese there\n        if (border > 3 // not near border\n            && c.x == 0. // not on wall\n            && (i.x+r.x*i.y) % 1777 == 0) // worst prng evar\n\t        c.z = 1.; // cheese\n    \tc.y = maxrange;\n    }\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    ivec2 i = ivec2(p);\n    vec4 r = MiscData\n    , m = MouseData;\n    if (iFrame < 2 // reset\n        || ivec2(r.xy) != ivec2(R) // window size changed\n        || m.y > maxrange) // upon mouse starvation (no cheese left)        \n        Init(c, i);\n    else\n        Tick(c, i, r, m);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}