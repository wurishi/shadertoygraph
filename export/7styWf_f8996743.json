{"ver":"0.1","info":{"id":"7styWf","date":"1654191781","viewed":133,"name":"Quadcopter SDF","username":"sin3point14","description":"quadcopter sdf modelling","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 camera = vec3(0,0, -1.5);\n\nconst vec3 MAT_COLOR = vec3(0.7,0.3,0.1);\n\nconst vec3 LIGHT = vec3(15.0f, 3.0f, 5.0f);\n\nconst vec3 DIFFUSE_COL = vec3(0,0.4,0);\nconst vec3 AMBIENT_COL = vec3(0.1, 0.1, 0.1);\nconst vec3 SPECULAR_COL = vec3(1,1,1);\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 lighting(vec3 intersection, vec3 rayDirecn, vec3 normal)\n{\n    vec3 color = vec3(0,0,0);\n    \n    color += AMBIENT_COL;\n    \n    vec3 lightDisplacement = intersection - LIGHT;\n    \n    color += DIFFUSE_COL * dot(-normalize(lightDisplacement), normal);\n    \n    vec3 reflected = normalize(reflect(lightDisplacement, normal));\n    \n    color += SPECULAR_COL * pow(clamp(dot(reflected, normalize(-intersection)), 0.0f, 1.0f), 6.0);\n    \n    color *= MAT_COLOR;\n    \n    return color;\n}\n\nfloat circularShaft(vec3 point)\n{\n    float R = 10.0f;\n    float T = 1.0f;\n    float inPlane = abs(length(point.xy) - R) - T;\n    float perpPlane = abs(point.z) - T;\n    \n    return length( vec2( max( inPlane, 0.0f ), max( perpPlane, 0.0f ) ) ) + min(max(inPlane, perpPlane), 0.0f);\n}\n\nfloat cameraBox(vec3 point)\n{\n    float L = 2.5f;\n    float B = 5.0f;\n    float H = 2.0f;\n    float R = 0.5;\n    \n    point -= vec3(0,0, H - 1.0f ); // 1.0f here refers to t of circularShaft\n    \n    \n    vec3 q = abs(point) - vec3(L,B,H);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - R;\n}\n\nfloat howFarScene(vec3 point)\n{\n    const vec3 C = vec3(0,0,80);\n    const vec3 ROT_AXIS = vec3(1,1,0);\n    const float ROT_ANGLE = 0.0f;\n    point -= C;\n    \n    point = (vec4(point, 0) * rotationMatrix(ROT_AXIS, ROT_ANGLE)).xyz;\n    \n    float dist = circularShaft(point);\n    \n    dist = min(dist, cameraBox(point));\n    \n    return dist;\n}\n\nvec3 gradient(vec3 point)\n{\n    vec2 d = vec2(0.001f, 0.0f);\n    \n    float dx = howFarScene(point + d.xyy) - howFarScene(point - d.xyy);\n    float dy = howFarScene(point + d.yxy) - howFarScene(point - d.yxy);\n    float dz = howFarScene(point + d.yyx) - howFarScene(point - d.yyx);\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/iResolution.y - vec2(0.5 * iResolution.x / iResolution.y,0.5);\n    vec3 ray = normalize(vec3(uv, 0) - camera);\n\n    // ray tracing\n    // fragColor = vec4(colorIntersectSphere(ray), 1.0f);\n    \n    // ray marching\n    float curr = 0.0f;\n    for(float dist = 0.0f; dist < 1000.0f; dist += curr)\n    {\n        vec3 currRay = camera + dist * ray;\n        curr = howFarScene(currRay);\n        if (curr < 0.001f) // hit\n        {\n            fragColor = vec4(lighting(currRay, ray, gradient(currRay)), 1.0f);\n            return;\n        }\n    }\n    fragColor = vec4(0,0,0,1);\n}","name":"Image","description":"","type":"image"}]}