{"ver":"0.1","info":{"id":"XcyyDG","date":"1732311267","viewed":34,"name":"Ontwikkeling van AI","username":"Mirtheamvm","description":"Ontwikkeling van Kunstmatige Intelligentie (21e eeuw)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for \"Development of Artificial Intelligence\" with enhanced depth, shadow, AI-inspired color scheme, and filmic lighting for dramatic contrast, including moving detailed forms\n\n// User parameters\nuniform float tech_input;      // Technology input for sigmoid function\n\n#define AA 2  // Set AA to 1 if your machine is too slow\n#define METHOD 3\n\n// Sigmoid function for technology growth\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// Function to compute the quaternion constant c based on the \"Development of Artificial Intelligence\"\nvec4 computeC(float time) {\n    float health;\n    float freedom;\n    float interconnectivity;\n    float tech_factor = sigmoid(tech_input);\n\n    // CARE values for the \"Development of Artificial Intelligence\"\n    if (time < 0.33) {  // Early phase\n        health = 4.0;\n        freedom = 4.0;\n        interconnectivity = 5.0;\n    } else if (time < 0.66) {  // Acceleration phase\n        health = 7.0;\n        freedom = 6.0;\n        interconnectivity = 8.0;\n    } else {  // Maturity phase\n        health = 8.0;\n        freedom = 7.0;\n        interconnectivity = 9.0;\n    }\n\n    // Normalize the CARE values and compute the quaternion constant\n    return vec4(\n        (5.0 + min(health, 8.5)) / 10.0 * (5.0 + min(freedom, 8.5)) / 10.0 * (5.0 + min(interconnectivity, 8.5)) / 10.0 * tech_factor,\n        0.8 * (5.0 + health) / 10.0 * sin(time * 0.7),\n        0.8 * (5.0 + freedom) / 10.0 * cos(time * 0.5),\n        0.8 * (5.0 + interconnectivity) / 10.0\n    );\n}\n\nvec4 qsqr(in vec4 a) {\n    return vec4(\n        a.x * a.x - a.y * a.y - a.z * a.z - a.w * a.w,\n        2.0 * a.x * a.y,\n        2.0 * a.x * a.z,\n        2.0 * a.x * a.w\n    );\n}\n\nconst int numIterations = 4000; // Higher number of iterations for even richer detail\n\n// Function to map the fractal and limit bailout-radius for stability\nfloat map(in vec3 p, out vec4 oTrap, in vec4 c, out float iteration) {\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    oTrap = vec4(abs(z.xyz), dot(z, z));\n\n    iteration = 0.0;\n    for (int i = 0; i < numIterations; i++) {\n        md2 *= 4.0 * mz2;\n        z = qsqr(z) + c;\n\n        // Add subtle noise for organic deformation\n        z.xyz += 0.1 * sin(5.0 * z.xyz + iTime * 0.04);\n\n        // Add moving shapes around the main fractal to create dynamism\n        z.xyz += 0.05 * cos(10.0 * z.xyz + iTime * 0.3);\n\n        // Orbit trap to enhance visual detail\n        oTrap = min(oTrap, vec4(abs(z.xyz), dot(z, z)));\n        mz2 = dot(z, z);\n        iteration += 1.0;\n\n        // Adjust the bailout threshold for stability and visibility\n        if (mz2 > 1500.0) break; // Increased bailout threshold for better stability and more detail\n    }\n\n    return 0.02 * sqrt(mz2 / md2) * log(mz2);  // Adjusted scaling factor for more intense detail\n}\n\n// Function to get AI-inspired colors representing growth, interconnectivity, and evolution\nvec3 getAIColor(float health, float freedom, float interconnectivity) {\n    float totalCARE = (health + freedom + interconnectivity) / 3.0;\n\n    // Define AI-inspired colors\n    vec3 deepBlue = vec3(0.1, 0.1, 0.4);  // Deep blue for the early stages, representing unknown potential\n    vec3 techGreen = vec3(0.2, 0.8, 0.4);  // Tech green for growth and evolution\n    vec3 vibrantPurple = vec3(0.5, 0.1, 0.7);  // Vibrant purple representing the complexity and creativity of AI\n    vec3 electricCyan = vec3(0.0, 1.0, 1.0);  // Electric cyan for connectivity and digital evolution\n    vec3 softWhite = vec3(0.95, 0.95, 1.0);  // Soft white for maturity, indicating the integration of AI into society\n\n    // Gradual transitions between AI-inspired colors\n    if (totalCARE <= 5.0) {\n        return mix(deepBlue, techGreen, totalCARE / 5.0);  // Transition from deep blue to tech green\n    }\n    if (totalCARE <= 7.0) {\n        return mix(techGreen, vibrantPurple, (totalCARE - 5.0) / 2.0);  // Transition from tech green to vibrant purple\n    }\n    if (totalCARE <= 8.0) {\n        return mix(vibrantPurple, electricCyan, (totalCARE - 7.0));  // Transition from vibrant purple to electric cyan\n    }\n    return mix(electricCyan, softWhite, (totalCARE - 8.0));  // Transition from electric cyan to soft white\n}\n\n// Function to adjust color based on the CARE-scores using AI colors\nvec3 getColor(float iteration, float maxIteration, vec4 oTrap, float health, float freedom, float interconnectivity) {\n    float t = iteration / maxIteration;\n\n    // Get AI-based color depending on CARE values\n    vec3 baseColor = getAIColor(health, freedom, interconnectivity);\n    \n    // Add orbit trap influence to color for more visual complexity\n    baseColor += 0.45 * vec3(oTrap.x, oTrap.y, oTrap.z) * (1.0 - t);\n    \n    // Add a glow effect for areas with high interconnectivity\n    baseColor += 0.7 * pow(max(0.0, 1.0 - t), 3.0) * vec3(1.0, 1.1, 0.9);\n    \n    return baseColor;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in vec4 c, out vec4 res, out float iteration) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 300.0;  // Increased maximum distance for better visibility\n    float h = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 4000; i++) {\n        if (h < 0.0001 || t > maxd) break;\n        h = map(ro + rd * t, tmp, c, iteration);\n        t += h;\n    }\n    if (t < maxd) {\n        resT = t;\n        res = tmp;\n    }\n    return resT;\n}\n\n// Function to render the fractal and ensure it remains visible\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c, float health, float freedom, float interconnectivity) {\n    const vec3 sun = vec3(0.877, 0.877, 0.877);  // Brighter sun for more intense lighting\n\n    vec4 tra;\n    float iteration;\n    float t = intersect(ro, rd, c, tra, iteration);\n\n    vec3 col;\n    if (t < 0.0) {\n        // Background gradient with a beige tone\n        col = vec3(0.94, 0.87, 0.78) * (0.6 + 0.4 * rd.y); // Beige background for consistency\n    } else {\n        vec3 mate = vec3(0.3, 0.9, 0.6) * 0.5;  // Adjusted material color for better complementing\n        vec3 pos = ro + t * rd;\n        vec3 nor = normalize(pos);  // Normal approximation\n\n        // Get color based on iteration count and orbit trap using AI colors\n        col = getColor(iteration, float(numIterations), tra, health, freedom, interconnectivity);\n\n        // Add some subsurface scattering effect for an organic feel\n        float subsurface = clamp(dot(rd, nor) + 0.5, 0.0, 1.0);\n        col += mate * 0.9 * subsurface;\n\n        // Sun lighting\n        vec3 lig = normalize(sun + vec3(sin(iTime * 0.5), cos(iTime * 0.5), sin(iTime * 0.7)) * 0.1);  // Dynamic lighting\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        col += mate * vec3(1.2, 1.1, 1.0) * dif;\n\n        // Enhanced shadows for a more dramatic and cinematic effect\n        float shadow = 0.2 + 0.8 * pow(max(0.0, dot(nor, lig)), 24.0) * (0.8 + 0.2 * sin(iTime * 0.3));\n        col *= shadow;\n\n        // Additional ambient occlusion for depth\n        float ambientOcclusion = 1.0 - clamp(t / 150.0, 0.0, 1.0);\n        col *= ambientOcclusion;\n\n        // Enhanced brightness variation for depth perception\n        col *= 0.9 + 0.7 * sin(iTime * 0.2 + iteration) * (0.8 + 0.3 * cos(iTime * 0.3));\n\n        // Specular highlights for realism\n        vec3 halfVector = normalize(lig - rd);\n        float spec = pow(clamp(dot(nor, halfVector), 0.0, 1.0), 150.0);\n        col += vec3(1.2, 1.15, 1.1) * spec * 0.8;\n    }\n\n    return pow(col, vec3(0.4545));  // Gamma correction for realistic brightness\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Parameters for animation\n    float time = iTime * 0.0025;  // Slower movement for a calmer effect\n    vec4 c = computeC(time);\n\n    // Set up the camera\n    float r = 3.0;  // Adjust zoom level here\n    vec3 ro = vec3(r * cos(0.3 + 0.37 * time), 0.3 + 0.8 * r * cos(1.0 + 0.33 * time), r * cos(2.2 + 0.31 * time)); // Adjusted camera position to match other shaders\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    float cr = 0.1 * cos(0.1 * time);\n\n    // Compute camera direction vectors\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    // Ray direction\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec3 rd = normalize(p.x * cu + p.y * cv + 2.0 * cw);\n\n    // CARE parameters for the \"Development of Artificial Intelligence\"\n    float health, freedom, interconnectivity;\n    if (time < 0.33) {\n        // Early phase\n        health = 4.0;\n        freedom = 4.0;\n        interconnectivity = 5.0;\n    } else if (time < 0.66) {\n        // Acceleration phase\n        health = 7.0;\n        freedom = 6.0;\n        interconnectivity = 8.0;\n    } else {\n        // Maturity phase\n        health = 8.0;\n        freedom = 7.0;\n        interconnectivity = 9.0;\n    }\n\n    // Render the scene with AI-based color scheme\n    vec3 col = render(ro, rd, c, health, freedom, interconnectivity);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}