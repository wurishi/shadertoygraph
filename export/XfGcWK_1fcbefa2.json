{"ver":"0.1","info":{"id":"XfGcWK","date":"1732361257","viewed":26,"name":"Dissected Cube","username":"Longingly","description":"A very non-performant dissecting cube","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","replication"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfCube(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float c = cos(angle);\n    float s = sin(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        vec3(c + axis.x * axis.x * oc, axis.x * axis.y * oc - axis.z * s, axis.x * axis.z * oc + axis.y * s),\n        vec3(axis.y * axis.x * oc + axis.z * s, c + axis.y * axis.y * oc, axis.y * axis.z * oc - axis.x * s),\n        vec3(axis.z * axis.x * oc - axis.y * s, axis.z * axis.y * oc + axis.x * s, c + axis.z * axis.z * oc)\n    );\n}\n\nfloat improvedSine(float seed, float a, float b) {\n    return mix(a, b, (sin(iTime * seed) + 1.0) * 0.5);\n}\n\nfloat improvedCosine(float seed, float a, float b) {\n    return mix(a, b, (cos(iTime * seed) + 1.0) * 0.5);\n}\n\nfloat map(vec3 p) {\n    vec3 q2 = p;\n    \n    vec3 center = vec3(0, 0, -3.);\n    center.x = sin(iTime / 4.);\n    center.y = cos(iTime / 4.);\n\n    float result = 100.;\n    const int gridSize = 1;\n    const float rotationFrequency = .25;\n    for (int i = -gridSize; i <= gridSize; i++) { \n        for (int j = -gridSize; j <= gridSize; j++) {\n            for (int k = -gridSize; k <= gridSize; k++) {\n            \n                vec3 origin = vec3(float(i), float(j), float(k));\n                origin *= improvedCosine(3.14 * rotationFrequency, 1., 2.5);\n                if (origin.z == 0.) origin.z = 0.0001; \n                \n                vec3 position = q2 + origin + center;\n                position *= rotationMatrix(vec3(origin.x, origin.y, origin.z), iTime * 3.14 * rotationFrequency * 2.);\n                \n                vec3 scale = vec3(1.);\n                scale.xy *= improvedCosine(3.14 * 2. * rotationFrequency, .3, .5);\n                float cube = sdfCube(position,scale);\n                result = min(result, cube);\n                if (result < .1) return result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 col = vec3(0);\n    \n    float t = 0.;\n    \n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        //p.y += sin(iTime);\n        //p.x += cos(iTime);\n\n        float d = map(p);\n        \n        t += d;\n        \n        col = vec3(float(i) / 80., t / 20., t/float(i));\n        \n        if (d < .1) break;\n    }\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}