{"ver":"0.1","info":{"id":"3ttBRX","date":"1730240073","viewed":56,"name":"Super Simple fluid buoyancy test","username":"niels747","description":"buoyancy proportional to temperature deviation from average of horizontal layer","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","convection"],"hasliked":0,"parentid":"ttGczW","parentname":"Super Simple Fluid texelFetch()"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 fluid = texture(iChannel0,uv);\n    \n    vec2 normMouse = iMouse.xy / iResolution.xy;\n    \n    // temperature view\n    fragColor = vec4(hsv2rgb(vec3(-fluid.w*0.31+0.3,1.0,1.0)),1.0); // hue\n    //fragColor = vec4(1.0 + fluid.w, 1.0 - abs(fluid.w),1.0 - fluid.w, 1.0); // red and blue\n    \n    // presure view\n    fluid.z*=2.;\n    //fragColor = vec4(1.0 + fluid.z, 1.0 - abs(fluid.z),1.0 - fluid.z, 1.0); // red and blue\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\nw = temperature\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iRes = ivec2(iResolution);\n    ivec2 center = ivec2(fragCoord);\n    ivec2 right  = center + ivec2(1,0);\n    ivec2 up     = center + ivec2(0,1);\n    \n    if(right.x > iRes.x-1) // needed for wrapping texture horizontally with texelFetch\n    right.x = 0;\n   \n    \n    vec4 t = texelFetch(iChannel0,center,0);\n    \n    // velocity changes proportional to pressure gradient across point\n    t.x += t.z - texelFetch(iChannel0,right,0).z; \n    t.y += t.z - texelFetch(iChannel0,up,0).z; \n    \n    //t.y += t.w * 0.002; //0.002 Buoyancy force\n    \n    t.y += (t.w - texelFetch(iChannel0,ivec2(0,center.y),0).w) * 0.002; //0.002 New Buoyancy force\n    \n    t.x *=0.998; // drag to prevent too high velocities\n    t.y *=0.998; // simulation is only stable and accurate if x and y velocies < 1.0 (fragments/iteration)\n    \n\n    // mouse adds heat\n    if(length(iMouse.xy - fragCoord) < 30.1 && iMouse.z > 0.5){\n        t.w += 0.1;\n    }\n    \n    // heating and cooling\n   // if(center.x > 10 && center.x < iRes.x - 11){\n    if(center.y < 200 && center.y > 5)\n    t.w += 0.0005; // heat at bottem\n    else if(center.y > iRes.y - 200 && center.y < iRes.y - 5)\n    t.w -= 0.0005; // cool at top\n  //  }\n  \n  \n  if(iTime < 1.0 && length(vec2(center - iRes/2)) < 10.) // add some slight asymmetry to get it started\n  t.w -= 0.01;\n    \n    t.w = clamp(t.w,-1.0,1.0); // constrain temperature\n    \n    if(center.y < 1 || center.y > iRes.y - 2){ // top and bottem\n    //if(center.x < 1 || center.x > iRes.x - 2 || center.y < 1 || center.y > iRes.y - 2){ // all 4 sides\n    t.x = t.y = 0.0; // set velocity to 0 at boundaries\n    }\n\n    fragColor = vec4(t.x ,t.y, t.z, t.w);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iRes = ivec2(iResolution);\n    ivec2 center = ivec2(fragCoord);\n    ivec2 left  = center + ivec2(-1,0);\n    ivec2 down     = center + ivec2(0,-1);\n    \n    \n    if(left.x < 0) // needed for wrapping texture horizontally with texelFetch\n    left.x = iRes.x-1;\n    \n\nvec4 t = texelFetch(iChannel0,center,0);\n   \n   // pressure changes proportional to the net inflow - outflow of the cell\n   t.z += (texelFetch(iChannel0,left,0).x - t.x + texelFetch(iChannel0,down,0).y - t.y) *0.499; // multiplier has to be < 0.5\n\n   fragColor = vec4(t.x, t.y, t.z, t.w);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Advection\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec4 t = texelFetch(iChannel0,ivec2(fragCoord),0);\n\nvec2 center = fragCoord/iResolution.xy;\nvec2 backtracedPos = center - t.xy/iResolution.xy;\n\n    fragColor = texture(iChannel0,backtracedPos);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nivec2 iRes = ivec2(iResolution);\nivec2 center = ivec2(fragCoord);\n\nfloat totalTemp = 0.0;\n\nif(center.x == 0){\n\nfor(int x = 0; x < iRes.x; x++){\ntotalTemp += texelFetch(iChannel0,ivec2(x,center.y),0).w;\n}\n\ntotalTemp /= float(iRes.x); // calc average\n}\n\nfragColor = vec4(0.0,0.0,0.0,totalTemp);\n}","name":"Buffer D","description":"","type":"buffer"}]}