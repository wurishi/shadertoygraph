{"ver":"0.1","info":{"id":"DsGGDz","date":"1678392388","viewed":72,"name":"The Mysterious Gravity Fractal","username":"metabog","description":"todo","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["gravity"],"hasliked":0,"parentid":"fdjBDK","parentname":"3body problem - verlet"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec4 cl = 2.*texel(iChannel0, pos);\n    fragColor = cl;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n\n//https://www.shadertoy.com/view/fstSW8\nvec2 FindNearestPointOnLine(vec2 origin, vec2 end, vec2 point)\n{\n    //Get heading\n    vec2 heading = (end - origin);\n    float magnitudeMax = length(heading);\n    heading = normalize(heading);\n\n    //Do projection from the point but clamp it\n    vec2 lhs = point - origin;\n    float dotP = dot(lhs, heading);\n    dotP = clamp(dotP, 0.0f, magnitudeMax);\n    return origin + heading * dotP;\n}\n\nbool checkCollided(vec2 cp, float cr, vec2 cur, vec2 old)\n{\n    vec2 pl = FindNearestPointOnLine(old,cur,cp);\n    \n    if(length(pl-cp)<cr)\n        return true;\n    \n    return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 mpos = vec2(0.5,0.5);\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 compute_grav_pull(vec2 me, vec2 other, float mass)\n{\n    vec2 vec = other-me;\n    float d = length(vec);\n    vec = normalize(vec);\n    \n    float pull = 1.0f/(d*0.3); \n    vec *= pull * mass;\n    \n    const float G = 0.01;\n    vec*=G;\n    \n    return vec;\n}\n\n//change these to set the starting velocities of the other bodies\nvec2 body1_start_vel = vec2(0.000,0.0);\nvec2 body2_start_vel = vec2(0.000,0.0);\n\n//the masses of the bodies\nfloat b1mass = 1.0;\nfloat b2mass = 1.0;\nfloat movermass = 1.0;\n\nfloat dt = 0.5;\n\nfloat doFractal(vec2 pos, vec2 second_body_pos)\n{\n    vec2 b1pos = vec2(-0.2,0.0);\n    vec2 b2pos = vec2(0.2,0.0);\n    pos = pos/exp(iTime*0.6 + 1.0)*10.0;\n    vec2 midpoint = (b1pos+b2pos)*0.5;\n    \n    pos += mpos;\n    \n    vec2 b1vel = body1_start_vel;// + vec2(0.0,cos(iTime*0.002)*0.1);\n    vec2 b2vel = body2_start_vel;// + vec2(0.0,sin(iTime*0.002)*0.1);\n    \n    \n    //start at uv coords\n    vec2 moverpos = pos;\n    \n    //set start velocity for the tracked body to rotate slowly\n    vec2 movervel = vec2(0.0,0.0);\n    int maxiter = 64;\n    \n    int iter_reached = 0;\n   \n    vec2 b1acc = vec2(0.0,0.0);\n    vec2 b2acc =  vec2(0.0,0.0);\n    vec2 moveracc =  vec2(0.0,0.0);\n   \n    bool escaped = false;\n    float max_dist_from_a = 0.0;\n    while(iter_reached<maxiter)\n    {\n        //VERLET INTEGRATION UPDATE\n        vec2 new_b1pos = b1pos + b1vel*dt + b1acc*dt*dt*0.5;\n        vec2 new_b2pos = b2pos + b2vel*dt + b2acc*dt*dt*0.5;\n        vec2 new_moverpos = moverpos + movervel*dt + moveracc*dt*dt*0.5;\n        \n        //get the new velocities\n        vec2 new_b1acc  = compute_grav_pull(b1pos, b2pos, b2mass) + compute_grav_pull(b1pos,moverpos, movermass);\n        vec2 new_b2acc  = compute_grav_pull(b2pos, b1pos, b1mass) + compute_grav_pull(b2pos,moverpos,movermass);\n        vec2 new_moveracc = compute_grav_pull(moverpos, b1pos,b1mass) + compute_grav_pull(moverpos,b2pos,b2mass);\n\n        vec2 new_b1vel = (b1vel + (b1acc + new_b1acc))*dt*0.5;\n        vec2 new_b2vel = (b2vel + (b2acc + new_b2acc))*dt*0.5;\n        vec2 new_movervel = (movervel + (moveracc + new_moveracc))*dt*0.5;\n       \n        b1acc = new_b1acc;\n        b2acc = new_b2acc;\n        moveracc = new_moveracc;\n        \n        b1vel = new_b1vel;\n        b2vel = new_b2vel;\n        movervel = new_movervel;\n        \n        b1pos = new_b1pos;\n        b2pos = new_b2pos;\n        \n        const float schwarz = 0.02;\n        \n        //max_dist_from_a = max(max_dist_from_a,length(moverpos-midpoint));\n        max_dist_from_a = max(max_dist_from_a,length(movervel));\n        \n        //stop conditions are colliding with one of the bodies\n        //use a form of continuous collision detection to avoid\n        //endless oscillation around a body that never actually collides with it\n        if(checkCollided(b1pos,schwarz,moverpos,new_moverpos) || length(moverpos-b1pos)<schwarz)\n        {\n            moverpos=b1pos;\n            break;\n        }\n        \n        if(checkCollided(b2pos,schwarz,moverpos,new_moverpos) || length(moverpos-b2pos)<schwarz)\n        {\n            moverpos=b2pos;\n            break;\n        }\n        \n        moverpos = new_moverpos;\n        \n        //or escaping past some range\n        if(length(moverpos-b1pos)>1.5)\n        {\n            break;\n        }\n        \n        \n        iter_reached++;\n    }\n      \n    return max_dist_from_a*0.2;    \n    //return float(iter_reached)/float(maxiter);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord-iResolution.xy*0.5)/iResolution.xx);\n\n    vec4 cl = texel(iChannel0, fragCoord);\n    mpos =cl.zw;\n\n    //do some extra sampling\n    //super expensive\n    \n    //float d1 = doFractal(uv, mpos);\n    //float d2 = doFractal(uv+vec2(0.0005,0.0), mpos);\n    //float d3 = doFractal(uv+vec2(-0.0005,0.0), mpos);\n    //float d4 = doFractal(uv+vec2(0.0,0.0005), mpos);\n    //float d5 = doFractal(uv+vec2(0.0,-0.0005), mpos);\n    //float d = (d2+d3+d4+d5)/5.0;\n    \n    float d = doFractal(uv,mpos);\n    fragColor = vec4(hsv2rgb(vec3(0.4,0.4,d*3.0)),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord-iResolution.xy*0.5)/iResolution.xx);\n    vec2 mpos = vec2 (0.0,0.0);\n    mpos = iMouse.xy;\n    mpos = ((mpos-iResolution.xy*0.5)/iResolution.xx);\n    \n    vec4 cl = texel(iChannel0, vec2(0,0));\n    \n    fragColor = vec4(mpos.x,mpos.y,mpos.x-cl.x,mpos.y-cl.y);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 deltas = texel(iChannel0, fragCoord);\n    \n    if(length(deltas.wz)>0.09)\n        deltas=vec4(0.0,0.0,0.0,0.0);\n        \n    deltas = deltas/exp(iTime*0.6 + 1.0)*10.0;    \n    \n    vec4 curmouse = texel(iChannel1, vec2(0,0));\n    fragColor = vec4(curmouse.x+deltas.z,curmouse.y+deltas.w,\n        mix(curmouse.z,curmouse.x+deltas.z,0.1),\n        mix(curmouse.w,curmouse.y+deltas.w,0.1));\n}","name":"Buffer C","description":"","type":"buffer"}]}